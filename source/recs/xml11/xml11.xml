<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE spec SYSTEM "../xmlspec-tr.dtd" [
  <!ENTITY w3c "http://www.w3.org">
	<!ENTITY base.uri "&w3c;/TR/2006/">
	<!ENTITY maturity.level "REC">
	<!ENTITY doc.shortname "xml11">
	<!ENTITY draft.year "2006">
	<!ENTITY draft.month.name "Ağustos">
	<!ENTITY draft.month "08">
	<!ENTITY draft.day "16">
	<!ENTITY iso6.doc.date "&draft.year;&draft.month;&draft.day;">
	<!ENTITY doc.ident "&maturity.level;-&doc.shortname;-&iso6.doc.date;">
	<!ENTITY this.version "&base.uri;&doc.ident;">
	<!ENTITY xml.version "&doc.ident;.xml">
	<!ENTITY review.version "&doc.ident;-review.html">
	<!ENTITY pdf.version "&doc.ident;.pdf">
	<!ENTITY errataloc "&w3c;/XML/xml-V11-2e-errata">
	<!ENTITY preverrataloc "&w3c;/XML/xml-V11-1e-errata">
	<!ENTITY translationloc "&w3c;/2003/03/Translations/byTechnology?technology=&doc.shortname;">
	<!ENTITY impreploc "&w3c;/XML/2006/06/xml11-2e-implementation.html">
	<!ENTITY versionOfXML "1.1">
	<!ENTITY WebSGML "ISO 8879'a WebSGML Uyarlamaları Eki">
	<!ENTITY nbsp "&#160;">
	<!ENTITY mdash "&#x2014;">
	<!ENTITY magicents "<code>amp</code>,
<code>lt</code>,
<code>gt</code>,
<code>apos</code>,
<code>quot</code>">
	<!ENTITY % local.common.att "xml:lang    CDATA  #IMPLIED">
  <!ENTITY latestloc "&w3c;/TR/xml11/">
  <!ATTLIST authlist
    translator-name   CDATA #FIXED "Nilgün Belma Bugüner"
    translator-email  CDATA #FIXED "nilgun (at) belgeler·org"
    translation-date  CDATA #FIXED "6 Haziran 2007" >
]>
<?xml-stylesheet type="text/xsl" href="xml11.xsl"?>
<spec w3c-doctype="rec" xml:lang="tr">
	<header>
		<title>Genişletilebilir İmlenim Dili (XML)</title>
		<version>&versionOfXML; (İkinci Düzeltme)</version>
		<w3c-designation>&doc.ident;</w3c-designation>
		<w3c-doctype>W3C Önergesi</w3c-doctype>
		<pubdate>
			<day>&draft.day;</day>
			<month>&draft.month.name;</month>
			<year>&draft.year;</year>
		</pubdate>
		<publoc>
			<loc href="&this.version;"/>
		</publoc>
		<altlocs>
			<loc href="&latestloc;&xml.version;">XML</loc>
			<!--loc href="&pdf.version;">PDF</loc-->
			<loc href="&latestloc;&review.version;">değişikliklerin renklerle vurgulandığı XHTML sürümü</loc>
		</altlocs>
		<latestloc>
			<loc href="&w3c;/TR/&doc.shortname;"/>
		</latestloc>
		<prevlocs>
			<loc href="&w3c;/TR/2006/PER-xml11-20060614"/>
		</prevlocs>
		<authlist>
			<author>
				<name>Tim Bray</name>
				<affiliation>Textuality ve Netscape</affiliation>
				<email href="mailto:tbray@textuality.com">tbray@textuality.com</email>
			</author>
			<author>
				<name>Jean Paoli</name>
				<affiliation>Microsoft</affiliation>
				<email href="mailto:jeanpa@microsoft.com">jeanpa@microsoft.com</email>
			</author>
			<author>
				<name>C. M. Sperberg-McQueen</name>
				<affiliation>W3C</affiliation>
				<email href="mailto:cmsmcq@w3.org">cmsmcq@w3.org</email>
			</author>
			<author>
				<name>Eve Maler</name>
				<affiliation>Sun Microsystems, Inc.</affiliation>
				<email href="mailto:elm@east.sun.com">eve.maler@east.sun.com</email>
			</author>
			<author>
				<name>François Yergeau</name>
			</author>
      <author>
        <name>John Cowan</name>
        <email href="mailto:cowan@ccil.org">cowan@ccil.org</email>
      </author>
		</authlist>
		<errataloc href="&errataloc;"/>
		<preverrataloc href="&preverrataloc;"/>
		<translationloc href="&translationloc;"/>
		<abstract>
			<p>Bu belgede tamamen açıklanan Genişletilebilir İmlenim Dili [XML - e<kw>X</kw>tensible <kw>M</kw>arkup <kw>L</kw>anguage] SGML'nin bir alt kümesidir. Amacı, soysal SGML'nin sunulması, alınması ve şu an HTML ile mümkün olan yöntemle Web'de işlenmesidir. XML, SGML ve HTML'nin birarada çalışabilirliğini ve bunun gerçeklenimini kolaylaştırmak için tasarlanmıştır.</p>
		</abstract>
		<status>
			<p><emph>Bu bölüm belgenin yayımı sırasındaki durumunu açıklar. Bu belgeyi geçersiz kılacak başka belgeler olabilir. Şu anki W3C yayınlarının ve bu teknik raporların en son sürümleri &w3c;/TR/ adresindeki <loc href="&w3c;/TR/">W3C teknik raporları dizini</loc>nde bulunabilir.</emph></p>

			<p>Bu belge, geniş çapta kullanılmakta olan uluslararası metin işleme standardının [SGML - Standard Generalized Markup Language, iyileştirilmiş ve düzeltilmiş olarak ISO 8879:1986(E)] mevcut alt kümesi tarafından oluşturulmuş sözdiziminin belirtimidir. Bu belge, <loc href="&w3c;/XML/Activity.html">W3C XML Etkinliği</loc>nin bir parçası olarak <loc href="&w3c;/XML/Core/">XML Çekirdek Çalışma Grubu</loc> tarafından üretilmiştir.</p>

      <p>Bu belge 29 Eylül 2006 tarihinde istenmeyen sonuçlara yol açması olası boşluklar ve süprüntüler silinmek suretiyle yerinde düzeltilmiştir.</p>

      <p>Bu belirtimin fiilen geçerli (İng: normative) tek sürümü İngilizce sürümü olmakla birlikte bilgilendirici (İng: non-normative) mahiyette olarak bu belgenin başka dillere <loc href="&translationloc;">tercümeleri</loc> de mevcuttur.</p>

      <p>Bu belge bir <loc href="&w3c;/2005/10/Process-20051014/tr.html#q74">W3C Önergesidir</loc>. Bu ikinci düzeltme XML'nin yeni bir sürümü <emph>değildir</emph>. Okuyuculara kolaylık olsun diye, (<loc href="&preverrataloc;"/> adresinde) biriken hata raporlarının gerektirdiği değişikliklerin <loc href="&w3c;/TR/2004/REC-xml11-20040204">XML 1.1'in 4 Şubat 2004 tarihli ilk yayımına</loc> uygulanmış halidir. Ayrıca, biçimsel olarak kullanılan <bibref ref="rfc2119"/>'da tanımlı kural koyucu anahtar sözcükler, <bibref ref="rfc2119"/>'un ana fikrine daha iyi uyum sağlayacak şekilde değiştirilmiştir. Bu düzeltme sürümü önceki <loc href="&w3c;/TR/2004/REC-xml11-20040204">4 Şubat 2004 tarihli W3C Önergesini</loc> geçersiz kılar.</p>

			<p>Bu belgede (İngilizce sürümünde) bulduğunuz hataları lütfen <loc href="mailto:mailto:xml-editor@w3.org"/> listesine bildiriniz; listenin halka açık <loc href="http://lists.w3.org/Archives/Public/xml-editor/">arşivleri</loc> de mevcuttur. Okuyuculara kolaylık olması için belgenin <loc href="&latestloc;&review.version;">yapılan değişikliklerin renklerle vurgulandığı bir XHTML sürümü</loc> de mevcuttur; bu sürüm <loc href="&preverrataloc;">hata raporları listesinde</loc> yayınlanmış hatalardan dolayı yapılan her değişikliği listedeki ilgili hata raporuna bir bağ vererek vurgular. Listedeki çoğu hata, değişiklikle ilgili bir açıklama içerir. Bu ikinci sürüm için <loc href="&errataloc;"/> adresinde bir hata raporları listesi mevcuttur.</p>

			<p><loc href="&impreploc;"/> adresinde bir gerçeklenim raporu bulunmaktadır. Bu belirtime ne derece uyum sağlanabildiğini sınamaya yardımcı <loc href="&w3c;/XML/Test/">sınama araçları</loc> da sağlanmıştır.</p>

      <p>Bu belge W3C üyeleri ve diğer ilgili taraflarca gözden geçirilmiş ve W3C Yönetimi tarafından bir W3C Önergesi olarak onaylanmıştır. Kararlı bir belge olup başka belgelerden uyulması gerekli bir kaynak olarak atıfta bulunarak veya bir başvuru malzemesi olarak kullanılabilir. W3C'nin Önergedeki rolü, belirtime dikkatleri çekmek ve geniş bir alanda kullanımını yaygınlaştırmaktır. Bu, Web'in işlevselliğini ve birlikte çalışabilirliğini arttırmaktadır.</p>

			<p>Bu belge <loc href="http://www.w3.org/2004/02/05-pp-transition">W3C Patent Politikası Geçiş İşlemleri</loc> tarafından değiştirilmiş olarak <loc href="http://www.w3.org/TR/2002/NOTE-patent-practice-20020124">24 January 2002 CPP</loc>'ye göre kullanılmaktadır. W3C, kendi çıktılarının barındırdığı patentler varsa bunları bir <loc role="disclosure" href="&w3c;/2002/08/xmlcore-IPR-statements">liste halinde ve patent açıklama talimatlarıyla birlikte</loc> duyurur. <loc href="&w3c;/Consortium/Patent-Policy-20040205/#def-essential">Temel Hak İddiasında</loc> bulunabilecek (başka) bir patent hakkında elinde somut bilgisi bulunanlar, <loc href="&w3c;/Consortium/Patent-Policy-20040205/#sec-Disclosure">W3C Patent Politikası 6. Bölümde</loc> belirtildiği şekilde ellerindeki bilgileri açıklamalıdırlar.</p>
		</status>
		<pubstmt>
			<p>Chicago, Vancouver, Mountain View, et al.: World-Wide Web Consortium, XML Working Group, 1996, 1997, 2000, 2003.</p>
		</pubstmt>
		<sourcedesc>
			<p>Elektronik ortamda oluşturulmuştur.</p>
		</sourcedesc>
		<langusage>
			<language id="tr">Türkçe</language>
			<language id="special-bnf">Special Backus-Naur Form (UTF-8 Form)</language>
		</langusage>
		<revisiondesc>
			<p role="cvsid">$-Id: REC-xml11-20060816.xml,v 1.2 2006/09/29 19:02:09 jean-gui Exp $</p>
		</revisiondesc>
	</header>
	<body>
		<div1 id="sec-intro">
			<head>Giriş</head>
			<p>Genişletilebilir İmlenim Dili [XML - e<kw>X</kw>tensible <kw>M</kw>arkup <kw>L</kw>anguage], <termref def="dt-xml-doc">XML belgeleri</termref> denen veri nesneleri sınıfını ve kısmen de bunlar üzerinde işlem yapacak bilgisayar programlarının davranışını açıklar. XML, SGML'nin <bibref ref="ISO8879"/> sınırlı biçimi veya uygulamaya dönük yüzüdür. Oluşumları bakımından, XML belgeler SGML belgelerle uyumludur.</p>
			<p>XML belgeler, <termref def="dt-entity">öğe</termref> denilen ve çözümlenmiş ya da çözümlenmemiş, veri içeren saklama birimlerinden oluşur. Çözümlenmiş veri kısmen <termref def="dt-chardata">karakter verisi</termref> biçiminde, kısmen de <termref def="dt-markup">imlenim</termref> biçiminde biraraya getirilmiş <termref def="dt-character">karakter</termref>lerden oluşur. İmlenim, belgenin depolama katmanının ve mantıksal yapısının tanımını kodlar. XML ise depolama katmanı ve mantıksal yapı üzerinde kural koyucu bir mekanizma sağlar.</p>

      <p><termdef id="dt-xml-proc" term="XML İşlemci">XML belgeleri okuyup içeriğine ve yapısına erişim sağlamak için <term>XML işlemci</term> denilen bir yazılım modülü kullanılır</termdef>. <termdef id="dt-app" term="Uygulama">Bir XML işlemcinin bu işi <term>uygulama</term> adı verilen başka bir modülün yararına  yapacağı varsayılır</termdef>. Bu belirtim bir XML işlemciden beklenen davranışı, XML veriyi nasıl okuması ve uygulamaya bilgiyi nasıl sağlaması gerektiğiyle ilgili kuralları açıklar.</p>
			<div2 id="sec-origin-goals">
				<head>Öncüler ve Hedefler</head>
				<p>XML, W3C himayesi altında 1996 yılında kurulan (öncülü SGML Editorial Review Board olarak bilinen) bir XML Çalışma Grubu tarafından geliştirilmiştir. XML Çalışma Grubu, Sun Microsystems'tan Jon Bosak başkanlığında W3C tarafından ayrıca örgütlenen bir XML Özel İlgi Grubunun etkin katılımıyla kuruldu. XML Çalışma Grubunun üyeleri bir ek bölümde listelenmiştir. Çalışma Grubunun W3C ile iletişimi Dan Connolly tarafından sağlanmıştır.</p>

				<p>XML için tasarım hedefleri:</p>
				<olist>
					<item>
						<p>XML, Genel Ağ'da düz mantıkla (doğrudan doğruya) kullanılabilmelidir.</p>
					</item>
					<item>
						<p>XML, geniş çapta çok çeşitli uygulamayı destekleyecektir.</p>
					</item>
					<item>
						<p>XML, SGML ile uyumlu olacaktır.</p>
					</item>
					<item>
						<p>XML belgeleri işleyen programları yazmak kolay olacaktır.</p>
					</item>
					<item>
						<p>XML'deki isteğe bağlı özellikler olabildiğince az, hatta sıfır olmalıdır.</p>
					</item>
					<item>
						<p>XML belgeler insanlar için okunaklı olacaktır.</p>
					</item>
					<item>
						<p>XML tasarımı çabucak yapılabilecektir.</p>
					</item>
					<item>
						<p>XML tasarımı özlü ve biçimsel olacaktır.</p>
					</item>
					<item>
						<p>XML belgeler kolayca oluşturulabilecektir.</p>
					</item>
					<item>
						<p>XML imlenimin kısalığı asgari önemdedir.</p>
					</item>
				</olist>
				<p>Bu belirtim, ilgili standartlarla birlikte, XML &versionOfXML;'ı anlamak ve üzerinde işlem yapacak bilgisayar programlarını oluşturmak için gerekli tüm bilgiyi sağlar (ilgili standartlar: karakterler için Unicode <bibref ref="Unicode"/> ve ISO/IEC 10646 <bibref ref="ISO10646"/>, dil betimleme yaftaları için RFC 3066 <bibref ref="RFC1766"/>, dil isimlerinin kodları için ISO 639 <bibref ref="ISO639"/> ve ülke isimlerinin kodları için ISO 3166 <bibref ref="ISO3166"/>).</p>
				<p>XML belirtiminin bu sürümü, metnin tamamı ve yasal uyarıları aynen korunduğu takdirde özgürce dağıtılabilir.</p>
			</div2>
			<div2 id="sec-terminology">
				<head>Terminoloji</head>
				<p>XML belgeleri açıklamakta kullanılan terminoloji bu belirtim boyunca tanımlanmıştır. Bu çeviride, vurgulandıklarında, <rfc2119>ZORUNLU</rfc2119>, <rfc2119>ÖNERİ</rfc2119> ve <rfc2119>SEÇİMLİK</rfc2119> anahtar sözcükleri <bibref ref="rfc2119"/>'un Türkçe çevirisinde açıklandığı gibi yorumlanır. Ayrıca, aşağıdaki listede tanımlanan terimler, XML belgeleri açıklamakta kullanılan terminolojiyi oluşturmak ve bir XML işlemcinin eylemlerini açıklamakta kullanılır:</p><glist>
						<gitem>
							<label>hata</label>
							<def>
								<p>
									<termdef id="dt-error" term="Hata">Bu belirtimin kurallarıyla bir uyumsuzluk bir hatadır; sonuçları bilinemez. Aksi belirtilmedikçe, bu belirtimde <rfc2119>ZORUNLU</rfc2119>, <rfc2119>ÖNERİ</rfc2119> ve <rfc2119>SEÇİMLİK</rfc2119> anahtar sözcüklerinden biri tarafından imlenmiş bir talimatı yerine getirmekte başarısız olmak bir hatadır. Uyumlu bir yazılım bir hatayı saptayabilir <rfc2119>SEÇİMLİK</rfc2119>, raporlayabilir ve ondan kurtulabilir <rfc2119>SEÇİMLİK</rfc2119></termdef>.
								</p>
							</def>
						</gitem>
						<gitem>
							<label>ölümcül hata</label>
							<def>
								<p>
									<termdef id="dt-fatal" term="Ölümcül Hata">Bir uyumlu <termref def="dt-xml-proc">XML işlemci</termref>nin saptayıp raporlamasının <rfc2119>ZORUNLU</rfc2119> olduğu bir hata. Bir ölümcül hataya rastladığında işlemci başka hataları da bulmak ve böyle hataları uygulamaya raporlamak <rfc2119>SEÇİMLİK</rfc2119> için veriyi işlemeye devam edebilir <rfc2119>SEÇİMLİK</rfc2119>. Hataların düzeltilmesine destek vermek için işlemci belgedeki işlenmemiş veriyi  (karakter verisi ve imlenim karışık halde) uygulamaya kullanılır kılabilir <rfc2119>SEÇİMLİK</rfc2119>. Ölümcül hata saptandığı anda, işlemci normal işleme devam etmemelidir <rfc2119>ZORUNLU</rfc2119> (yani, belgenin mantıksal yapısı hakkındaki bilgiyi ve karakter verisini uygulamaya normal yolla aktarmaya devam etmemelidir <rfc2119>ZORUNLU</rfc2119>).</termdef>
								</p>
							</def>
						</gitem>
						<gitem>
							<label>seçim kullanıcının</label>
							<def>
								<p>
									<termdef id="dt-atuseroption" term="seçim kullanıcının">Uyumlu yazılım (cümledeki fiilin çekim kipine bağlı olarak) ya açıklandığı gibi davranabilir <rfc2119>SEÇİMLİK</rfc2119> ya da açıklandığı gibi davranmalıdır <rfc2119>ZORUNLU</rfc2119>; her ne yapılacaksa, (işlemci/uygulama) kullanıcının açıklanan davranışı iptal etmesini veya etkin kılmasını sağlamalıdır. <rfc2119>ZORUNLU</rfc2119>.</termdef>
								</p>
							</def>
						</gitem>
						<gitem>
							<label>geçerlilik kuralı</label>
							<def>
								<p>
									<termdef id="dt-vc" term="Geçerlilik kuralı"><termref def="dt-valid">Geçerli</termref> tüm XML belgelere uygulanan kural. Geçerlilik kuralıyla uyumsuzluk hatadır; bu hatalar <termref def="dt-validating">geçerliliği sınayan XML işlemciler</termref> tarafından, seçim kullanıcıya bırakılarak, raporlanmalıdır <rfc2119>ZORUNLU</rfc2119>.</termdef>
								</p>
							</def>
						</gitem>
						<gitem>
							<label>iyi biçimlilik kuralı</label>
							<def>
								<p>
									<termdef id="dt-wfc" term="İyi biçimlilik kuralı"><termref def="dt-wellformed">İyi biçimli</termref> tüm XML belgelere uygulanan kural. İyi biçimlilik kuralıyla uyumsuzluk <termref def="dt-fatal">ölümcül hata</termref>dır.</termdef>
								</p>
							</def>
						</gitem>
						<gitem>
							<label>eşleşme</label>
							<def>
								<p>
									<termdef id="dt-match" term="eşleşme">(Dizgeler ve isimler için:)İki dizge veya isim, karşılaştırıldıklarında aynıysalar eşleşiyorlar demektir. Unicode'da çok sayıda olası gösterimi olan karakterler (yani, birden fazla karakterin birleşiminden oluşan karakterlerin, birleşik tek karakterlik ve çok karakterli gösterimleri) bakımından, iki dizge, sadece her iki dizge de aynı gösterimi içeriyorsa eşleşirler. Karakter büyüklüğü ile ilgili hiçbir işlem yapılmaz. (dizgeler ve dilbilgisi kuralları için:) Bir sözdizimsel tanım tarafından üretilmiş dile mensup bir dizge aynı sözdizimsel tanımla eşleşir. (içerikler ve içerik modelleri için:) Bir eleman <specref ref="elementvalid"/> kuralında açıklanan anlamda uyumlu olduğunda kendi bildirimi ile eşleşir.</termdef>
								</p>
							</def>
						</gitem>
						<gitem>
							<label>uyumluluk için</label>
							<def>
								<p>
									<termdef id="dt-compat" term="Uyumluluk için">Sadece XML'nin SGML ile uyumlu kalacağından emin olmak için içerilmiş bir XML özelliğini açıklayan bir cümleyi imler.</termdef>
								</p>
							</def>
						</gitem>
						<gitem>
							<label>birlikte çalışabilirlik için</label>
							<def>
								<p><termdef id="dt-interop" term="Birlikte çalışabilirlik için">XML belgelerin sistemde kurulu olan &WebSGML; öncesi SGML işlemcileri tabanı tarafından işlenebilme şansını arttırmak için içerilmiş ilgisiz bir önergeyi açıklayan bir cümleyi imler.</termdef>
								</p>
							</def>
						</gitem>
					</glist>
			 </div2>
      <div2 id="sec-xml11">
        <head>Gerekçeler ve XML 1.1 Değişiklik listesi</head>
        <p>W3C'nin XML 1.0 Önergesi ilk olarak 1998'de yayınlandı ve çoğu hata raporunun belirtime yansıtılıp 2004 yılındaki üçüncü düzeltmeyle  hatalardan arındırılmasına karşın, neyin iyi biçimli XML olduğu neyin olmadığı konusu değişmeden kaldı (kasten). Bu kararlılık, birlikte çalışabilirlik açısından oldukça yararlı oldu. Bununla birlikte, XML 1.0'ın karakter belirtimleri için güvendiği Unicode Standardı yerinde durmadı, gelişimini sürdürerek 2.0 sürümünden 4.0 sürümüne geldi ve gelişmeye devam ediyor. Unicode 2.0'da mevcut olmayan karakterler XML 1.0 karakter verisinde zaten kullanılabiliyordu. Yine de, bunların eleman türü adları, öznitelik isimleri, sabit öznitelik değerleri, işlem yönergelerinin hedefleri gibi XML adlarında kullanımına izin verilmiyordu. Bundan başka, XML adlarında kabul edilmesi gereken karakterler Unicode 2.0'daki tutarsızlıklar ve kusurlar yüzünden kullanılamıyordu.</p>

        <p>Adlandırma ile ilgili gerekçeler XML 1.0'dan beri baştan sona değişti. Oysa XML 1.0, izin verilmemiş herşeyi kullanımdan kaldıran katı isim tanımlamaları yapmıştı, XML 1.1 adları (belli bir sebeple) yasaklanmamış herşeye izin verecek şekilde tasarlandı. Unicode, 4.0'dan sonra da gelişmeye devam edeceğinden isimlerde hemen her karaktere, henüz atanmamışlara bile izin vererek XML'de başka değişiklik olmaması sağlanabildi.</p>

        <p>Ek olarak, XML 1.0 günümüzün çeşitli işletim sistemlerinin satırsonu uzlaşımların uyum sağlamaya çalışırken IBM ve IBM uyumlu büyük bilgisayarlarda kullanılan uzlaşımlarda ayrımcılık yapıyordu. Büyük bilgisayarlardaki XML belgeler yerel kabullere uygun olarak salt metin dosyalar değillerdir. Sonuç olarak, büyük bilgisayarlarda üretilen XML belgeler ya yerel satırsonu uzlaşımları ile çelişiyor ya da çözümleme öncesindeki ve üretim sonrasındaki aşamalarda gereksiz dönüşümlerle verimsizliğe sebep oluyorlardı. Veriler, dosyaları büyük sistemlerle normal bilgisayarlar arasında paylaşarak (birinden diğerine dosya kopyalama anlamında değil) saklandığı zaman düz mantıkla birlikte çalışabilirliği mümkün kılmak önem kazanır. Bu yüzden, XML 1.1 satırsonu karakterleri listesine NEL (#x85) karakterini eklemiştir. Yapmışken tam olsun diye, Unicode satır ayırma karakteri olan #x2028'de ayrıca desteklenmiştir.</p>

        <p>Sonuçta, XML belgelerde Unicode karakterlerin standart gösterimini tanımlama konusunda öngörülebilir bir ısrar vardı. Bu yüzden, XML 1.1, XML 1.0'da çoğu yasak olan #x1 ile #x1F arasındaki denetim karakerlerine gönderime izin verir. Sağlamlık bakımından, yine de bu karakterler belgelerde doğrudan doğruya kullanılamazlar. Karakter kodlamasının saptanması konusuna sağlamlığı arttırmak için, XML 1.0 belgelerde serbestçe kullanınıma izin verilen #x7F ile #x9F arasındaki denetim karakterlerinin artık sadece karakter gönderimlerinde yer alması gerekmektedir (Boşluk karakterleri tabii ki müstesna). Geriye uyumluluk konusunda bu küçük fedakarlık önemli sayılmaz. Uygulama geliştirme arayüzleriyle olası sorunlar nedeniyle gerek doğrudan gerekse karakter gönderimi olarak #x0 karakterine hala izin verilmemektedir.</p>

        <p>Son olarak, XML 1.1, belge oluşturucuların uyması <rfc2119>ÖNERİ</rfc2119>len ve belge işlemcilerenen de doğrulaması  <rfc2119>ÖNERİ</rfc2119>len "tam normalleştirme" adı verilen bir kural kümesi tanımlamaktadır. Tamamen normalleştirilmiş belge kullanımı, Unicode dizgelerin ikilik karşılaştırmasını basitleştirerek         adların, öznitelik değerlerinin ve karakterlerin özdeşlik karşılaştırmalarının doğru olarak yapılabilmesini sağlar.</p>

        <p>Değişikliklerin iyi biçimle belge tanımını değiştirmesi sebebiyle, XML 1.0'a hata raporlarını yansıtmak yerine yeni bir XLM sürümü oluşturuldu. XML 1.0 işlemcilerinin XML adlarınad yeni karakterleri, yeni satırsonu uzlaşımlarını ve denetim karakterlerine gönderimleri içeren XML belgeleri reddetmeye devam etmeleri gerekmektedir. XML 1.0 ve XML 1.1 belgeler arasındaki ayrım, her belgenin başında bulunan XML bildirimindeki sürüm numarası bilgisiyle belirtilir.</p>
      </div2>
		</div1>
		<!-- &Docs; -->
		<div1 id="sec-documents">
			<head>Belgeler</head>
			<p><termdef id="dt-xml-doc" term="XML Belge">Bir veri nesnesi bu belirtimde tanımlandığı gibi <termref def="dt-wellformed">iyi biçimli</termref> ise o bir <term>XML belge</term>dir. Eğer belli başlı ek kuralları karşılıyorsa XML belge ayrıca <termref def="dt-valid">geçerli</termref>dir.</termdef></p>

			<p>Her XML belge, mantıksal ve fiziksel yapıların her ikisine de sahiptir. Fiziksel olarak, belge <termref def="dt-entity">öğe</termref> denilen birimlerden oluşur. Bir öğe belge içinde içerilmesini sağlamak için başka öğelere <termref def="dt-entref">gönderim</termref>de bulunabilir. Bir belge bir <quote>kök</quote> veya <termref def="dt-docent">belge öğesi</termref>nde başlar. Mantıksal olarak, belge, hepsi belgede açıkça imlenim tarafından belirtilmiş bildirimler, elemanlar, açıklamalar, karakter gönderimleri ve işlem yönergelerinden oluşur, Mantıksal ve fiziksel yapılar, <specref ref="wf-entities"/> bölümünde açıklandığı gibi uygun şekilde iç içe geçmiş olmalıdır <rfc2119>ZORUNLU</rfc2119></p>
			<div2 id="sec-well-formed">
				<head>İyi Biçimli XML Belgeler</head>
				<p><termdef id="dt-wellformed" term="İyi Biçimli">Bir metin nesnesinin <term>iyi biçimli</term> bir XML belge olması için:</termdef></p>
				<olist>
					<item>
						<p>Bir bütün olarak, <nt def="NT-document">belge</nt>  sözdizimiyle eşleşmelidir.</p>
					</item>
					<item>
						<p>Bu belgede verilen bütün iyi biçimlilik kurallarına uygun olmalıdır.</p>
					</item>
					<item>
						<p>Belgede doğrudan veya dolaylı gönderim yapılan <termref def="dt-parsedent">çözümlü öğeler</termref>in her biri <termref def="dt-wellformed">iyi biçimli</termref> olmalıdır.</p>
					</item>
				</olist>
				<scrap id="document">
					<head>Belge</head>
					<prod id="NT-document" num="1">
						<lhs>belge</lhs>
						<rhs>(<nt def="NT-prolog">önbölük</nt>
							<nt def="NT-element">eleman</nt>
							<nt def="NT-Misc">Muhtelif</nt>*) -
              (<nt def="NT-Char">Kark</nt>*
              <nt def="NT-RestrictedChar">SınırlıKark</nt>
              <nt def="NT-Char">Kark</nt>*)</rhs>
					</prod>
				</scrap>
				<p>Bir XML belgenin <nt def="NT-document">belge</nt> sözdizimiyle eşleşmesi için:</p>
				<olist>
					<item>
						<p>Bir veya daha fazla <termref def="dt-element">eleman</termref> içermelidir.</p>
					</item>
					<item>
						<p><termdef id="dt-root" term="Kök Eleman">Başka bir elemanın içeriğinde hiçbir parçası bulunmayan, <term>kök</term> veya belge elemanı adı verilen sadece tek bir elemanı vardır</termdef>. Diğer tüm elemanlar bakımından, eğer <termref def="dt-stag">başlangıç etiketi</termref> başka bir elemanın içindeyse, <termref def="dt-etag">bitiş etiketi</termref> de aynı elemanın içindedir. Başka bir deyişle, elemanlar başlangıç ve bitiş etiketleri ile sınırlanmış olarak bir diğerini içerebilir.</p>
					</item>
				</olist>
				<p><termdef id="dt-parentchild" term="Ebeveyn/Çocuk">Bunun bir sonucu olarak, belgedeki, kök eleman olmayan her  <var>C</var> elemanı için, onu içeren bir  <var>P</var> elemanı vardır. <var>P</var>'ye <var>C</var>'nin <term>ebeveyni</term> olarak atıf yapılırken <var>C</var>'ye <var>P</var>'nin <term>çocuğu</term> olarak atıf yapılır.</termdef>
				</p>
			</div2>
			<div2 id="charsets">
				<head>Karakterler</head>
				<p>
					<termdef id="dt-text" term="Metin">Bir çözümlenmiş öğe, karakter veriler yanında imlenimi de göstermekte kullanılan <termref def="dt-character">karakter</termref>lerden oluşan bir dizi olarak bir <term>metin</term> içeriğe sahiptir</termdef>. 	<termdef id="dt-character" term="Karakter">Bir <term>karakter</term> ISO/IEC 10646 <bibref ref="ISO10646"/> tarafından belirtildiği gibi metnin bir atomsal birimidir. Geçerli karakterler sekme, satırsonu, satırbaşı ile Unicode ve ISO/IEC 10646'nın geçerli karakterleridir. Standartların bu belge hazırlandığı sırada geçerli olan sürümlerinden <specref ref="sec-existing-stds"/> bölümünde bahsedilmiştir. Bu standartların düzeltmelerinde ve eklerinde yeni karakterler eklenebilir. Sonuçta, XML işlemcilerin <nt def="NT-Char">Kark</nt> için belirtilen aralıktaki her karakteri kabul etmeleri <rfc2119>ZORUNLU</rfc2119>dur.</termdef>
				</p>
				<scrap id="char32">
					<head>Karakter Aralığı</head>
					<prodgroup pcw2="4" pcw4="17.5" pcw5="11">
						<prod id="NT-Char" num="2">
							<lhs>Kark</lhs>
							<rhs>[#x1-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF]</rhs>
							<com>İkame bloklar, FFFE ve FFFF hariç Unicode karakterler.</com>
						</prod>
            <prod id="NT-RestrictedChar" num="2a">
              <lhs>SınırlıKark</lhs>
              <rhs>[#x1-#x8] | [#xB-#xC] | [#xE-#x1F] | [#x7F-#x84] | [#x86-#x9F]</rhs>
            </prod>
					</prodgroup>
				</scrap>
				<p>Karakter kodlarını bit kalıpları halinde kodlayan mekanizmalar öğeden öğeye değişiklik gösterebilir. Tüm XML işlemcilerinin Unicode'un  <bibref ref="Unicode"/> UTF-8 ve UTF-16 kodlamalarını kabul etmesi <rfc2119>ZORUNLU</rfc2119>dur; bu ikisini işaret eden kullanımdaki mekanizmalar ile diğer kodlamaları oyuna dahil eden mekanizmalar <specref ref="charencoding"/> bölümünde açıklanmıştır.</p>
				<note>
					<p>Belge yazarlarının <bibref ref="Unicode"/>'da tanımlanan <quote>uyumluluk karakterleri</quote>ni kullanmaktan kaçınmaları önerilir. Ayrıca, aşağıdaki karakter aralıklarını kullanmaktan da vazgeçilmiştir. Bu karakterler ya denetim karakterleridir ya da kalıcı olarak tanımlanmamış Unicode karakterleridir:</p>
<eg>[#x1-#x8], [#xB-#xC], [#xE-#x1F], [#x7F-#x84], [#x86-#x9F], [#xFDD0-#xFDDF],
[#x1FFFE-#x1FFFF], [#x2FFFE-#x2FFFF], [#x3FFFE-#x3FFFF],
[#x4FFFE-#x4FFFF], [#x5FFFE-#x5FFFF], [#x6FFFE-#x6FFFF],
[#x7FFFE-#x7FFFF], [#x8FFFE-#x8FFFF], [#x9FFFE-#x9FFFF],
[#xAFFFE-#xAFFFF], [#xBFFFE-#xBFFFF], [#xCFFFE-#xCFFFF],
[#xDFFFE-#xDFFFF], [#xEFFFE-#xEFFFF], [#xFFFFE-#xFFFFF],
[#x10FFFE-#x10FFFF].</eg>
				</note>
			</div2>
			<div2 id="sec-common-syn">
				<head>Ortak Sözdizimsel Oluşumlar</head>
				<p>Bu bölümde dilbilgisi içinde geniş çapta kullanılan simgeler tanımlanmaktadır.</p>
				<p><nt def="NT-S">B</nt> (boşluk karakterleri) bir veya daha fazla boşluk (<code>#x20</code>), sekme (<code>#x9</code>), satırsonu (<code>#xA</code>) veya satırbaşı (<code>#xD</code>) karakterinden oluşur.</p>
				<scrap id="white">
					<head>Boşluk Karakterleri</head>
					<prodgroup pcw2="4" pcw4="17.5" pcw5="11">
						<prod id="NT-S" num="3">
							<lhs>B</lhs>
							<rhs>(#x20 | #x9 | #xD | #xA)+</rhs>
						</prod>
					</prodgroup>
				</scrap>
				<note>
					<p>Yukarıdaki sözdizimi tanımında yer alan <code>#xD</code> karakteri tamamen <loc href="&w3c;/TR/1998/REC-xml-19980210">ilk belirtim</loc> ile geriye uyumluluk adına vardır. <specref ref="sec-line-ends"/> bölümünde açıklandığı gibi bir XML belgedeki <code>#xD</code> karakterleri herhangi bir başka işlem yapılmadan önce tek tek silinir veya yerlerine <code>#xA</code> karakterleri yerleştirilir. <nt def="NT-S">B</nt> sözdizimiyle eşleşen <code>#xD</code> karakterini almanın tek yolu bir öğe değerinde bu karakter için bir karakter gönderimi belirtmektir.</p>
				</note>
				<p><termdef id="dt-name" term="Ad">Bir <term>Ad</term>, bir harf veya bir kaç noktalama iminden biri ile başlar ve isim karakterleri adı verilen, harfler, rakamlar, tire, altçizgi, ikinokta veya nokta imleri ile devam eder</termdef>. <quote><code>xml</code></quote> dizgesi ile veya <code>(('X'|'x') ('M'|'m') ('L'|'l'))</code> ile eşleşen herhangi bir dizge ile başlayan adlar, bu belirtimin bu ve gelecek sürümlerinde standartlaşım adına ayrılıp kayıt altına alınmıştır.</p>
				<note>
					<p>XML önergesindeki isim-alanları <bibref ref="xml-names"/>, ikinokta imleri içeren adlara bir anlam yükler. Bu bakımdan, yazarlar XML adlarında isim-alanlarının amaçları dışında ikinokta imi kullanmamalı, ama XML işlemciler, ikinokta imini 'bir isim karakteri olarak' kabul etmelidirler.</p>
				</note>
				<p>Bir <nt def="NT-Nmtoken">ad dizgeciği</nt> isim karakterlerinin bir karışımıdır.</p>

        <p>Bir <nt def="NT-Name">Ad</nt>ın ilk karakteri bir <nt def="NT-NameStartChar">AdBaşlKark</nt> olmalı <rfc2119>ZORUNLU</rfc2119> ve diğer karakterleri birer <nt def="NT-NameChar">AdKark</nt> olmalıdır <rfc2119>ZORUNLU</rfc2119>; bu mekanizma isimlerin temel aksan karakterleri ve ASCII rakamları ile başlatılmasını engellemek için kullanılır. İsimlerde ayraçlar ve ayraç olması olası karakterler dışında hemen her karaktere izin verilmiştir. Amaç zorlayıcı değil yol gösterici olmaktır, böylece henüz Unicode kodlama yapmayan yazım sistemleri XML adlarında kullanılabililir olmaktadır. İsim oluşturma konusunaku öneriler için <specref ref="sec-suggested-names"/> bölümüne bakınız.</p>

        <p>Belge yazarlarının isimlerde anlamlı sözcükleri ve doğal sözcük birleşimlerini kullanmaları; boşluk karakterlerini ve işaretleri kullanmaktan kaçınmaları önerilir. İkinokta, tire, nokta, altçizgi ve ortanokta karakterlerinin kullanımına izin verildiğine dikkat ediniz.</p>

        <p>XML adlarının XML belgeler dışında kullanıldığı yerlerde ayraç olarak daha kullanışlı olduklarından, Unicode sembol karakterlerinden büyükçe bir gruptan başka ASCII semboller ve noktalama işaretlerinin isimlerde kullanımı yasaktır; bu grubun sağlanmasıyla, bu bağlamlarda XML isimleri olamayacak şeyler hakkında kesin garanti verilmiştir. #x037E, Yunan soru işaretine normalleştirildiğinde öğe gönderiminin anlamını değiştiren noktalı virgüle dönüştüğünden izin verilmemiştir.</p>
				<scrap>
					<head>Adlar ve Dizgecikler</head>
          <prod id="NT-NameStartChar" num="4">
            <lhs>AdBaşlKark</lhs>
            <rhs>":" | [A-Z] | "_" | [a-z] | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF] | [#x370-#x37D] | [#x37F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]</rhs>
          </prod>
          <prod id="NT-NameChar" num="4a">
						<lhs>AdKark</lhs>
            <rhs>
              <nt def="NT-NameStartChar">AdBaşlKark</nt> | "-" | "." | [0-9] | #xB7 | [#x0300-#x036F] | [#x203F-#x2040]</rhs>
					</prod>
					<prod id="NT-Name" num="5">
						<lhs>Ad</lhs>
            <rhs>
              <nt def="NT-NameStartChar">AdBaşlKark</nt> | "-" | "." | [0-9] | #xB7 | [#x0300-#x036F] | [#x203F-#x2040]</rhs>
					</prod>
					<prod id="NT-Names" num="6">
						<lhs>Adlar</lhs>
						<rhs>
							<nt def="NT-Name">Ad</nt> (#x20 <nt def="NT-Name">Ad</nt>)*</rhs>
					</prod>
					<prod id="NT-Nmtoken" num="7">
						<lhs>AdDizge</lhs>
						<rhs>(<nt def="NT-NameChar">AdKark</nt>)+</rhs>
					</prod>
					<prod id="NT-Nmtokens" num="8">
						<lhs>AdDizgeler</lhs>
						<rhs>
							<nt def="NT-Nmtoken">AdDizge</nt> (#x20 <nt def="NT-Nmtoken">AdDizge</nt>)*</rhs>
					</prod>
				</scrap>
				<note>
					<p><nt def="NT-Names">Adlar</nt> ve <nt def="NT-Nmtokens">AdDizgeler</nt> sözdizimi tanımları normalleştirme sonrası dizgecikli öznitelik değerlerinin geçerliliğini tanımlamakta kullanılır (bkz, <specref ref="sec-attribute-types"/>).</p>
				</note>
				<p>Dizgesel sabitler, tırnak içine alınmış, içinde ayraç olarak tırnak imlerinin kullanılmadığı bir dizgedir. Dizgesel sabitler, dahili öğelerin (<nt def="NT-EntityValue">ÖğeDeğeri</nt>), öznitelik değerlerinin (<nt def="NT-AttValue">ÖznitDeğeri</nt>) ve harici belirteçlerin (<nt def="NT-SystemLiteral">SistemSabiti</nt>) içeriğini belirtmekte kullanılırlar. Bir <nt def="NT-SystemLiteral">SistemSabiti</nt>nin imlenim taranmaksızın çözümlenebileceğine dikkat ediniz.</p>
				<scrap>
					<head>Dizgesel sabitler</head>
					<prod id="NT-EntityValue" num="9">
						<lhs>ÖğeDeğeri</lhs>
						<rhs>'"' ([^%&amp;"] | <nt def="NT-PEReference">ParÖğeGönd</nt>
| <nt def="NT-Reference">Gönderim</nt>)* '"' </rhs>
						<rhs>|&nbsp; "'" ([^%&amp;'] | <nt def="NT-PEReference">ParÖğeGönd</nt> | <nt def="NT-Reference">Gönderim</nt>)* "'"</rhs>
					</prod>
					<prod id="NT-AttValue" num="10">
						<lhs>ÖznitDeğeri</lhs>
						<rhs>'"' ([^&lt;&amp;"] | <nt def="NT-Reference">Gönderim</nt>)*
'"' </rhs>
						<rhs>|&nbsp; "'" ([^&lt;&amp;'] | <nt def="NT-Reference">Gönderim</nt>)*
"'"</rhs>
					</prod>
					<prod id="NT-SystemLiteral" num="11">
						<lhs>SistemSabiti</lhs>
						<rhs>('"' [^"]* '"') |&nbsp;("'" [^']* "'") </rhs>
					</prod>
					<prod id="NT-PubidLiteral" num="12">
						<lhs>GenidSabiti</lhs>
						<rhs>'"' <nt def="NT-PubidChar">GenidKark</nt>* '"'
| "'" (<nt def="NT-PubidChar">GenidKark</nt> - "'")* "'"</rhs>
					</prod>
					<prod id="NT-PubidChar" num="13">
						<lhs>GenidKark</lhs>
						<rhs>#x20 | #xD | #xA |&nbsp;[a-zA-Z0-9] |&nbsp;[-'()+,./:=?;!*#@$_%]</rhs>
					</prod>
				</scrap>
				<note>
					<p><nt def="NT-EntityValue">ÖğeDeğeri</nt> sözdizimi tanımı, bir genel öğenin tanımının bir sabitte tek bir <code>&lt;</code> bulunmasına (örn, <code>&lt;!ENTITY sabitim "&lt;"&gt;</code>) izin verdiğinden ve böyle bir öğeye yapılacak bir gönderim bir iyi biçimlilik hatasına yol açacağından böyle bir uygulamadan kesinlikle kaçınılması önerilir.</p>
				</note>
			</div2>
			<div2 id="syntax">
				<head>Karakter Verisi ve İmlenim</head>
				<p>Bir <termref def="dt-text">Metin</termref> imlenim ile <termref def="dt-chardata">karakter verisi</termref>nin karışımından oluşur.
        <termdef id="dt-markup" term="İmlenim"><term>İmlenim</term> ise,
         <termref def="dt-stag">başlangıç etiketleri</termref>,
         <termref def="dt-etag">bitiş etiketleri</termref>,
         <termref def="dt-empty">boş eleman etiketleri</termref>,
         <termref def="dt-entref">öğe gönderimleri</termref>,
         <termref def="dt-charref">karakter gönderimleri</termref>,
         <termref def="dt-comment">açıklamalar</termref>,
         <termref def="dt-cdsection">CDATA bölümü</termref> ayraçları,
         <termref def="dt-doctype">belge türü bildirimleri</termref>,
         <termref def="dt-pi">işlem yönergeleri</termref>,
         <nt def="NT-XMLDecl">XML bildirimleri</nt>,
         <nt def="NT-TextDecl">metin bildirimleri</nt> ve belge öğesinin tepe seviyesindeki (yani, belge elemanının ve herhangi bir başka imlenimin dış tarafındaki) boşluk karakterleriyle şekillenir.</termdef></p>

				<p><termdef id="dt-chardata" term="Karakter Verisi">İmlenim dışındaki tüm metin belgenin <term>karakter verisi</term>ni oluşturur.</termdef></p>

				<p>Ve imi (&amp;) ve açılı sol ayraç (&lt;),
        bir <termref def="dt-comment">açıklama</termref>,
        bir <termref def="dt-pi">işlem yönergesi</termref> veya
        <termref def="dt-cdsection">CDATA bölümü</termref> içinde veya birer imlenim ayracı olarak kullanılmaları dışında, birer dizge sabiti biçiminde görünmemelidirler <rfc2119>ZORUNLU</rfc2119>. Böyle bir durumda, ya <termref def="dt-charref">sayısal karakter gönderimleri</termref>  ya da sırasıyla <quote><code>&amp;amp;</code></quote> ve <quote><code>&amp;lt;</code></quote> dizgeleri olarak görünmelidirler <rfc2119>ZORUNLU</rfc2119>. Açılı sağ ayraç (>), <quote><code>&amp;gt;</code></quote> dizgesi kullanılarak gösterilebilirse de, <termref def="dt-compat">uyumluluk için</termref> içerik içinde <quote><code>]]&gt;</code></quote> dizgesi bir <termref def="dt-cdsection">CDATA bölümü</termref>nün sonunu işaret etmiyorsa,  dizge içinde bir karakter gönderimi veya <quote><code>&amp;gt;</code></quote> kullanılarak gösterilmelidir <rfc2119>ZORUNLU</rfc2119>.</p>

				<p>Karakter verisi, elemanların içeriğinde, imlenim başlatma karakterini ve CDATA bölümü kapama ayracı olan <quote><code>]]&gt;</code></quote> dizgesini içermeyen bir karakter dizgesidir. Karakter verisi, CDATA bölümünde, CDATA bölümü kapama ayracını içermeyen bir karakter dizisidir.</p>

				<p>Öznitelik değerlerinin tek ve çift tırnakları içermesini sağlamak için, tek tırnak karakteri ('), <quote><code>&amp;apos;</code></quote> ile ve çift tırnak tarakteri ("), <quote><code>&amp;quot;</code></quote> ile gösterilebilir.</p>

				<scrap>
					<head>Belgenin Karakter Verisi</head>
					<prod id="NT-CharData" num="14">
						<lhs>KarkVeri</lhs>
						<rhs>[^&lt;&amp;]* - ([^&lt;&amp;]* ']]&gt;' [^&lt;&amp;]*)</rhs>
					</prod>
				</scrap>
			</div2>

			<div2 id="sec-comments">
				<head>Açıklamalar</head>
				<p><termdef id="dt-comment" term="Açıklama"><term>Açıklama</term>lar bir belge <termref def="dt-markup">imlenim</termref> dışında her yerde bulunabilir; ek olarak, belge türü bildiriminin içinde dilbilgisi kurallarının izin verdiği yerlerde bulunabilir. Açıklamalar belgenin <termref def="dt-chardata">karakter verisi</termref>nin bir parçası değillerdir; bir XML işlemci, bir uygulamanın açıklamaların metnini almasını mümkün kılmak için açıklamaları karakter verisinin bir parçası olarak değerlendirebilir <rfc2119>SEÇİMLİK</rfc2119>, fakat bu gerekli değildir. <termref def="dt-compat">Uyumluluk için</termref>, <quote><code>--</code></quote> (çift tire) dizgesi açıklamaların içinde bulunmamalıdır <rfc2119>ZORUNLU</rfc2119>.</termdef> Parametre öğelerine gönderimler, açıklamaların içinde tanınır olmamalıdır <rfc2119>ZORUNLU</rfc2119>.</p>

				<scrap>
					<head>Açıklamalar</head>
					<prod id="NT-Comment" num="15">
						<lhs>Açıklama</lhs>
						<rhs>'&lt;!--' ((<nt def="NT-Char">Kark</nt> - '-') | ('-'
(<nt def="NT-Char">Kark</nt> - '-')))* '--&gt;'</rhs>
					</prod>
				</scrap>

				<p>Bir açıklama örneği:</p>

				<eg>&lt;!-- &lt;head&gt; &amp; &lt;body&gt; için bildirim --&gt;</eg>

				<p>Açıklama sözdiziminin, bir açıklamanın <code>---&gt;</code> ile bitmesine izin vermediğine dikkat ediniz. Bu bakımdan aşağıdaki örnek iyi biçimli <emph>değildir</emph>.</p>

				<eg>&lt;!-- B+, B veya B---&gt;</eg>
			</div2>
			<div2 id="sec-pi">
				<head>İşlem Yönergeleri</head>
				<p><termdef id="dt-pi" term="İşlem yönergeleri"><term>İşlem yönergeleri</term> (İng: Processing Instruction) belgelerde uygulamaya yönelik yönergelerin bulunmasını sağlar.</termdef>
				</p>
				<scrap>
					<head>İşlem yönergeleri</head>
					<prod id="NT-PI" num="16">
						<lhs>PI</lhs>
						<rhs>'&lt;?' <nt def="NT-PITarget">PIHedefi</nt> (<nt def="NT-S">B</nt>
(<nt def="NT-Char">Kark</nt>* - (<nt def="NT-Char">Kark</nt>* '?>' <nt def="NT-Char">Kark</nt>*)))? '?>'</rhs>
					</prod>
					<prod id="NT-PITarget" num="17">
						<lhs>PIHedefi</lhs>
						<rhs>
							<nt def="NT-Name">Ad</nt> - (('X' | 'x') ('M' |
'm') ('L' | 'l'))</rhs>
					</prod>
				</scrap>
				<p>İşlem yönergeleri belgenin <termref def="dt-chardata">karakter verisi</termref>nin bir parçası değillerdir, ama uygulamaya aktarılmaları gerekir <rfc2119>ZORUNLU</rfc2119>. İşlem yönergesi, yönergenin yönlendirildiği uygulamayı betimlemekte kullanılan bir hedefle (<nt def="NT-PITarget">PIHedefi</nt>) başlar. <quote><code>XML</code></quote>, <quote><code>xml</code></quote>, ve benzerleri, bu belirtimin bu veya gelecek sürümlerinin standartlaşımı için ayrılıp kayıt altına alınmıştır. İşlem yönergelerinin biçimsel bildirimi için XML <termref def="dt-notation">Gösterim</termref> mekanizması kullanılabilir. Parametre öğelerinin gönderimleri işlem yönergeleri içinde tanınır olmamalıdır <rfc2119>ZORUNLU</rfc2119>.</p>
			</div2>
			<div2 id="sec-cdata-sect">
				<head>CDATA Bölümleri</head>
				<p><termdef id="dt-cdsection" term="CDATA Bölümü"><term>CDATA bölümleri</term> karakter verisinin her yerinde yer alabilir; imlenim olarak tanınmaması gereken karakterleri içeren metin bloklarını sarmalamakta kullanılır. CDATA bölümleri <quote><code>&lt;![CDATA[</code></quote> dizgesi ile başlar ve <quote><code>]]&gt;</code></quote>dizgesi ile biter:</termdef></p>

				<scrap>
					<head>CDATA Bölümleri</head>
					<prod id="NT-CDSect" num="18">
						<lhs>CDATABölümü</lhs>
						<rhs>
							<nt def="NT-CDStart">CDATABaşl</nt>
							<nt def="NT-CData">CDATAVerisi</nt>
							<nt def="NT-CDEnd">CDATABitiş</nt>
						</rhs>
					</prod>
					<prod id="NT-CDStart" num="19">
						<lhs>CDATABaşl</lhs>
						<rhs>'&lt;![CDATA['</rhs>
					</prod>
					<prod id="NT-CData" num="20">
						<lhs>CDATAVerisi</lhs>
						<rhs>(<nt def="NT-Char">Kark</nt>* - (<nt def="NT-Char">Kark</nt>*
']]&gt;' <nt def="NT-Char">Kark</nt>*)) </rhs>
					</prod>
					<prod id="NT-CDEnd" num="21">
						<lhs>CDATABitiş</lhs>
						<rhs>']]&gt;'</rhs>
					</prod>
				</scrap>
				<p>Bir CDATA bölümünün içinde sadece <nt def="NT-CDEnd">CDATABitiş</nt> dizgesi imlenim olarak tanınır, dolayısıyla açılı sol ayraç ve ve-imi bölüm içinde birebir yer alabilir; <quote><code>&amp;lt;</code></quote> ve <quote><code>&amp;amp;</code></quote> biçiminde olmaları gerekmez (gerekmemeli). CDATA bölümleri birbirlerinin içinde bulunamazlar.</p>

				<p><quote><code>&lt;greeting&gt;</code></quote> ve <quote><code>&lt;/greeting&gt;></code></quote> etiketlerinin <termref def="dt-markup">imlenim</termref> olarak değil, <termref def="dt-chardata">karakter verisi</termref> olarak ele alındığı bir CDATA bölümü örneği:</p>

				<eg>&lt;![CDATA[&lt;greeting&gt;Merhaba, Dünyalı!&lt;/greeting&gt;]]&gt; </eg>
			</div2>

			<div2 id="sec-prolog-dtd">
				<head>Önbölük ve Belge Türü Bildirimi</head>
				<p><termdef id="dt-xmldecl" term="XML Bildirimi">XML 1.1 belgelerin kullanılan XML sürümünün belirtildiği bir <term>XML bildirimi</term> ile başlamaları <rfc2119>ZORUNLU</rfc2119>dur</termdef>. Örneğin, aşağıdaki eksiksiz bir XML 1.1 belgesidir, <termref def="dt-wellformed">iyi biçimli</termref>dir ama <termref def="dt-valid">geçerli</termref> değildir:</p>

				<eg><![CDATA[<?xml version="1.1"?>
<greeting>Merhaba, Dünyalı!</greeting> ]]></eg>

				<p>fakat bu, bir XML bildirimi içermediğinden bir XML 1.0 belgesidir:</p>

				<eg><![CDATA[<greeting>Merhaba, Dünyalı!</greeting>]]></eg>

				<p>Bir XML belgedeki imlenimin işlevi belgenin saklatım ve mantıksal yapısını tanımlamak ve öznitelik isim-değer çiftlerini belgenin mantıksal yapısıyla ilişkilendirmektir. XML, mantıksal yapının kurallarını tanımlamak ve önceden tanımlanmış saklatım birimlerinin kullanımını desteklemek için <termref def="dt-doctype">belge türü bildirimi</termref> denen bir mekanizma sağlar. <termdef id="dt-valid" term="Geçerlilik">Bir XML belge, bir ilişkili belge türü bildirimine sahipse ve kendi içinde ifade edilen kurallara uygunsa, <term>geçerli</term>dir.</termdef></p>

				<p>Belge türü bildiriminin belgedeki ilk <termref def="dt-element">eleman</termref>dan önce yer alması <rfc2119>ZORUNLU</rfc2119>dur.</p>

				<scrap id="xmldoc">
					<head>Önbölük</head>
					<prodgroup pcw2="6" pcw4="17.5" pcw5="9">
						<prod id="NT-prolog" num="22">
							<lhs>önbölük</lhs>
							<rhs>
								<nt def="NT-XMLDecl">XMLBild</nt> <nt def="NT-Misc">Muhtelif</nt>*
(<nt def="NT-doctypedecl">belgetürübild</nt>
								<nt def="NT-Misc">Muhtelif</nt>*)?</rhs>
						</prod>
						<prod id="NT-XMLDecl" num="23">
							<lhs>XMLBild</lhs>
							<rhs>'&lt;?xml' <nt def="NT-VersionInfo">SürümBilgisi</nt>
								<nt def="NT-EncodingDecl">KodlamaBild</nt>? <nt def="NT-SDDecl">TBBild</nt>? <nt def="NT-S">B</nt>? '?>'</rhs>
						</prod>
						<prod id="NT-VersionInfo" num="24">
							<lhs>SürümBilgisi</lhs>
							<rhs>
								<nt def="NT-S">B</nt> 'version' <nt def="NT-Eq">Eşittir</nt>
("'" <nt def="NT-VersionNum">SürümNum</nt> "'" | '"' <nt def="NT-VersionNum">SürümNum</nt>
'"')</rhs>
						</prod>
						<prod id="NT-Eq" num="25">
							<lhs>Eşittir</lhs>
							<rhs>
								<nt def="NT-S">B</nt>? '=' <nt def="NT-S">B</nt>?</rhs>
						</prod>
						<prod id="NT-VersionNum" num="26">
							<lhs>SürümNum</lhs>
							<rhs>'&versionOfXML;'</rhs>
						</prod>
						<prod id="NT-Misc" num="27">
							<lhs>Muhtelif</lhs>
							<rhs>
								<nt def="NT-Comment">Açıklama</nt> | <nt def="NT-PI">PI</nt>
| <nt def="NT-S">B</nt>
							</rhs>
						</prod>
					</prodgroup>
				</scrap>
				<p><termdef id="dt-doctype" term="Belge Türü Bildirimi">XML <term>belge türü bildirimi</term> bir belge sınıfı için dilbilgisi sağlayan <termref def="dt-markupdecl">imlenim bildirimleri</termref>ni içerir veya bunları işaret eder. Bu dilbilgisi, belge türü bildirimi veya <term>DTD</term> (<emph>Document Type Definition</emph> kısaltması) olarak bilinir. DTD, imlenim bildirimlerini içeren bir harici altkümeyi (özel bir <termref def="dt-extent">harici öğe</termref> çeşidi) işaret edebileceği gibi imlenim bildirimlerini bir dahili altküme olarak içerebilir veya her ikisini birden yapabilir.</termdef></p>

				<p><termdef id="dt-markupdecl" term="imlenim bildirimi">Bir <term>imlenim bildirimi</term> ya bir <termref def="dt-attdecl">öznitelik listesi bildirimi</termref> ya bir <termref def="dt-entdecl">öğe bildirimi</termref> ya da bir <termref def="dt-notdecl">gösterim bildirimi</termref>dir</termdef>. Bu bildirimler, aşağıda iyi biçimlilik ve geçerlilik kurallarında açıklandığı gibi tamamen veya kısmen <termref def="dt-PE">parametre öğeleri</termref>nde yer alabilirler. Daha fazla bilgi için <specref ref="sec-physical-struct"/> bölümüne bakınız.</p>

				<scrap id="dtd">
					<head>Belge Türü Bildirimi</head>
					<prodgroup pcw2="6" pcw4="17.5" pcw5="9">
						<prod id="NT-doctypedecl" num="28">
							<lhs>belgetürübild</lhs>
							<rhs>'&lt;!DOCTYPE' <nt def="NT-S">B</nt>
								<nt def="NT-Name">Ad</nt>
(<nt def="NT-S">B</nt>
								<nt def="NT-ExternalID">HariciID</nt>)? <nt def="NT-S">B</nt>?
('[' <nt def="NT-intSubset">içAltKüme</nt> ']' <nt def="NT-S">B</nt>?)? '&gt;'</rhs>
							<vc def="vc-roottype"/>
							<wfc def="ExtSubset"/>
						</prod>
						<prod id="NT-DeclSep" num="28a">
							<lhs>BildAyr</lhs>
							<rhs>
								<nt def="NT-PEReference">ParÖğeGönd</nt> | <nt def="NT-S">B</nt>
							</rhs>
							<wfc def="PE-between-Decls"/>
						</prod>
						<prod id="NT-intSubset" num="28b">
							<lhs>içAltKüme</lhs>
							<rhs>(<nt def="NT-markupdecl">imlenimBild</nt> | <nt def="NT-DeclSep">BildAyr</nt>)*</rhs>
						</prod>
						<prod id="NT-markupdecl" num="29">
							<lhs>imlenimBild</lhs>
							<rhs>
								<nt def="NT-elementdecl">elemanBild</nt> | <nt def="NT-AttlistDecl">ÖznitListBild</nt> | <nt def="NT-EntityDecl">ÖğeBild</nt>
| <nt def="NT-NotationDecl">GösterimBild</nt> | <nt def="NT-PI">PI</nt> | <nt def="NT-Comment">Açıklama</nt>
							</rhs>
							<vc def="vc-PEinMarkupDecl"/>
							<wfc def="wfc-PEinInternalSubset"/>
						</prod>
					</prodgroup>
				</scrap>

				<p>Yalnız dikkat edin, bir iyi biçimli belge <nt def="NT-doctypedecl">belgetürübild</nt> içinde ya bir harici altkümeyi işaret etmeli ya bir dahili bir altkümeyi içermeli veya ikisini de yapmalıdır. Hiçbirinin olmaması iyi biçimlilik için olası değildir.</p>

				<p>İmlenim bildirimleri tamamen veya kısmen <termref def="dt-PE">parametre öğeleri</termref>nin <termref def="dt-repltext">ikame metni</termref> içinde yer alabilir. Bu belirtimdeki tek tek tanım terimlerinin (<nt def="NT-elementdecl">elemanBild</nt>, <nt def="NT-AttlistDecl">ÖznitListBild</nt>, vs.) bundan sonraki sözdizimi tanımları, tüm parametre öğeleri <termref def="dt-include">içerildikten</termref> sonraki bildirimleri tanımlayacaktır.</p>

				<p>Parametre öğesi gönderimlerinden dizgesel sabitlerin, işlem yönergelerinin, açıklamaların ve yoksayılan şart bölümlerinin (bkz, <specref ref="sec-condition-sect"/>) içinde olanlar hariç, kalan hepsi DTD (dahili ve harici altkümeler ile harici parametre öğeleri) içinde her yerde tanınırlar (anlamlarını korurlar). Ayrıca, öğe değeri dizgesel sabitlerinde de tanınırlar. Parametre öğelerinin dahili altkümelerde kullanımı aşağıda açıklandığı gibi kısıtlanmıştır.</p>

				<vcnote id="vc-roottype">
					<head>Kök Eleman Türü</head>
					<p><nt def="NT-doctypedecl">belgetürübild</nt> içindeki <nt def="NT-Name">Ad</nt>, <termref def="dt-root">kök eleman</termref> türündeki elemanla eşleşmelidir <rfc2119>ZORUNLU</rfc2119>.</p>
				</vcnote>

				<vcnote id="vc-PEinMarkupDecl">
					<head>Düzgün Bildirim/Parametre Öğesi İç İçeliği</head>
					<p>Parametre öğesi <termref def="dt-repltext">ikame metni</termref> ile imlenim bildirimleri olması gerektiği biçimde iç içe olmalıdır <rfc2119>ZORUNLU</rfc2119>. Yani, bir imlenim bildiriminin ilk veya son karakteri gönderim yapılan <termref def="dt-PE">parametre öğesi</termref> ikame metninin içinde yer alıyorsa, her ikisi de aynı ikame metninde içeriliyor olmalıdırlar <rfc2119>ZORUNLU</rfc2119>.</p>
				</vcnote>

				<wfcnote id="wfc-PEinInternalSubset">
					<head>Dahili Altkümedeki Parametre Öğeleri</head>
					<p>Dahili DTD altkümesinde, <termref def="dt-PERef">parametre öğesi gönderimleri</termref>, imlenim bildirimleri içinde yer almalıdır <rfc2119>ZORUNLU</rfc2119>; imlenim bildirimlerinin yer alabilecekleri her yerde yer alabilirler. (Bu, harici parametre öğeleri içinde veya harici altkümelerde yer alan gönderimlere uygulanmaz.)</p>
				</wfcnote>

				<wfcnote id="ExtSubset">
					<head>Harici Altküme</head>
					<p>Bir harici altküme (varsa), <nt def="NT-extSubset">dışAltKüme</nt> sözdizimiyle eşleşmelidir <rfc2119>ZORUNLU</rfc2119>.</p>
				</wfcnote>
				<wfcnote id="PE-between-Decls">
					<head>Bildirimler arasında Parametre Öğeleri</head>
					<p>Bir <nt def="NT-DeclSep">BildAyr</nt> içindeki bir parametre öğesi gönderiminin ikame metni <nt def="NT-extSubsetDecl">dışAltKümeBild</nt> sözdizimiyle eşleşmelidir <rfc2119>ZORUNLU</rfc2119>.</p>
				</wfcnote>
				<p>Dahili altküme gibi, bir <nt def="NT-DeclSep">BildAyr</nt> içinden gönderimde bulunulan bir harici altküme ve her harici parametre öğesi, boşluklar veya <termref def="dt-PERef">parametre öğesi gönderimleri</termref> arasına serpiştirilmiş <nt def="NT-markupdecl">imlenimBild</nt> tanım terimi tarafından izin verilen türlerdeki bir dizi eksiksiz imlenim bildiriminden oluşmalıdır. Harici altkümenin veya bu harici parametre öğelerinin içeriği kısmen <termref def="dt-cond-section">şart bölümü</termref> oluşumu kullanılarak şartlı olarak yoksayılabilir; buna dahili altkümede izin verilmez ama dahili altkümeden atıf yapılan harici parametre öğelerinde izin verilir.</p>

				<scrap id="ext-Subset">
					<head>Harici Altküme</head>
					<prodgroup pcw2="6" pcw4="17.5" pcw5="9">
						<prod id="NT-extSubset" num="30">
							<lhs>dışAltKüme</lhs>
							<rhs>
								<nt def="NT-TextDecl">MetinBild</nt>? <nt def="NT-extSubsetDecl">dışAltKümeBild</nt>
							</rhs>
						</prod>
						<prod id="NT-extSubsetDecl" num="31">
							<lhs>dışAltKümeBild</lhs>
							<rhs>( <nt def="NT-markupdecl">imlenimBild</nt> | <nt def="NT-conditionalSect">şartBölümü</nt> | <nt def="NT-DeclSep">BildAyr</nt>)*</rhs>
						</prod>
					</prodgroup>
				</scrap>

				<p>Harici altküme ve harici parametre öğeleri, dahili altkümedekilerden, <termref def="dt-PERef">parametre öğesi gönderimleri</termref>ne imlenim bildirimlerinin <emph>arasında değil, içinde</emph> izin veriliyor olmasıyla da ayrıca farklıdırlar.</p>

				<p>Belge türü bildirimine sahip bir XML belge örneği:</p>

				<eg><![CDATA[<?xml version="1.1"?>
<!DOCTYPE greeting SYSTEM "hello.dtd">
<greeting>Merhaba, Dünyalı!</greeting> ]]></eg>

				<p><termref def="dt-sysid">Sistem belirteci</termref> 					<quote><code>hello.dtd</code></quote>, belge için bir DTD adresi (veya bir tanım-yeri başvurusu) vermektedir.</p>

				<p>Bildirimler bu örnekteki gibi yerel olarak da yapılabilir:</p>

				<eg><![CDATA[<?xml version="1.1" encoding="UTF-8" ?>
<!DOCTYPE greeting [
  <!ELEMENT greeting (#PCDATA)>
]>
<greeting>Merhaba, Dünyalı!</greeting>]]></eg>

        <p>Harici ve dahili altkümelerin her ikisi de kullanılmışsa, dahili altküme, harici altkümeden önceymiş gibi ele alınmalıdır <rfc2119>ZORUNLU</rfc2119>. Bu, dahili altkümedeki öğe ve öznitelik listesi bildirimlerinin harici altkümedekilerden öncelikli olması demektir.</p>
        <p>Eğer bir belge XML 1.0 olarak iyi biçimli ve geçerliyse ve karakter öncelemeleri halinde olmak dışında [#x7F-#x9F] aralığındaki denetim karakterlerini içermiyorsa basitçe sürüm numarasını değiştirerek XML 1.1 olarak da iyi biçimli ve geçerli yapılabilir.</p>
			</div2>
			<div2 id="sec-rmd">
				<head>Tekbaşına Belge Bildirimi</head>
				<p><termref def="dt-xml-proc">XML işlemci</termref> tarafından uygulamaya aktarıldığından imlenim bildirimleri belge içeriğini etkileyebilir; örneğin, özniteliklerin öntanımlıları ve öğe bildirimleri. XML bildiriminin bir bileşeni olarak karşımıza çıkabilen tekbaşına belge bildirimi, <termref def="dt-docent">belge öğesi</termref>ne veya parametre öğelerine harici bildirim olarak görünen bildirimlerin olup olmadığını bilgisini taşır. <termdef id="dt-extmkpdecl" term="Harici İmlenim Bildirimi">Bir <term>harici imlenim bildirimi</term> harici altkümede veya bir parametre öğesinin (dahili veya harici) içinde  bulunan bir imlenim bildirimidir (geçerlilik sınaması yapmayan XML işlemciler parametre öğelerini de okumadıklarından bunlarda listeye dahildir).</termdef></p>

				<scrap id="fulldtd">
					<head>Tekbaşına Belge Bildirimi</head>
					<prodgroup pcw2="4" pcw4="19.5" pcw5="9">
						<prod id="NT-SDDecl" num="32">
							<lhs>TBBild</lhs>
							<rhs>
								<nt def="NT-S">B</nt> 'standalone' <nt def="NT-Eq">Eşittir</nt>
(("'" ('yes' | 'no') "'") | ('"' ('yes' | 'no') '"')) </rhs>
							<vc def="vc-check-rmd"/>
						</prod>
					</prodgroup>
				</scrap>
				<p>Bir tekbaşına belge bildiriminde <attval>yes</attval> değeri, XML işlemciden uygulamaya aktarılan bilgiyi etkileyen hiçbir <termref def="dt-extmkpdecl">harici imlenim bildirimi</termref> olmadığı anlamına gelir. <attval>yes</attval> değeri ise böyle harici bildirimlerin olduğunu veya olabileceğini belirtir. Tek başına belge bildiriminin sadece harici <emph>bildirimlerin</emph> varlığının belirtisi olduğuna; bir belgede, harici <emph>öğelere</emph> gönderimlerin varlığının, bu öğeler dahili olarak bildirildiğinde belgenin tekbaşınalık halini etkilemeyeceğine dikkat ediniz.</p>

				<p>Eğer hiçbir harici imlenim bildirimi yoksa, tekbaşına belge bildiriminin hiçbir anlamı yoktur. Eğer harici imlenim bildirimleri varsa fakat tekbaşına belge bildirimi yapılmamışsa değerin <attval>no</attval> olduğu varsayılır.</p>

				<p><code>standalone="no"</code> bildirimli bir XML belgesi, bazı ağ üzerinden teslimat uygulamaları tarafından talep edilmesi nedeniyle, algoritmik olarak bir tekbaşına belgeye dönüştürülebilir.</p>

				<vcnote id="vc-check-rmd">
					<head>Tekbaşına Belge Bildirimi</head>
					<p>Harici imlenim bildirimleri şunları içeriyorsa:</p>

					<ulist>
						<item>
							<p><termref def="dt-default">öntanımlı</termref> değerlere sahip öznitelikler; eğer bu özniteliklere sahip elemanlar belgede bu öznitelikler belirtilmeksizin kullanılmışsa,</p>
						</item>
						<item>
							<p>öğeler (&magicents; dışındakiler); eğer belgede bu öğelere <termref def="dt-entref">gönderimler</termref> varsa,</p>
						</item>
						<item>
							<p>dizgecikli türde öznitelikler; öznitelik belgede, <titleref href="#AVNormalize">normalleştirilmesi</titleref> halinde bildiriminin yokluğunda üretilenden farklı bir değer üretecek bir
              değerle kullanılmışsa,</p>
						</item>
						<item>
							<p><termref def="dt-elemcontent">eleman içeriği</termref> bildirilmiş eleman türleri; bu türlerin gerçeklenenlerinden içlerinde doğrudan boşluk karakterleri kullanılmış olanlar varsa,</p>
						</item>
					</ulist>

          <p>tekbaşına belge bildiriminin <attval>no</attval> değerine sahip olması <rfc2119>ZORUNLU</rfc2119>dur.</p>
				</vcnote>

				<p>Tekbaşına belge bildirimli bir XML bildirimi örneği:</p>

				<eg>&lt;?xml version="&versionOfXML;" standalone='yes'?&gt;</eg>

			</div2>

			<div2 id="sec-white-space">
				<head>Boşlukların İşlenmesi</head>
				<p>İmlenimden bağımsız olarak okunabilirliği arttırmak için XML belgeler düzenlenirken <quote>boşluk karakterleri</quote> (boşluklar, sekmeler, boş satırlar) bol bol kullanılır. XML belgenin dönüşeceği belgede böyle boşlukların istenmediği ve/veya özellikle korunmasının istendiği içerikler (şiir, kaynak kod gibi) olacaktır.</p>

				<p>Bir <termref def="dt-xml-proc">XML işlemci</termref>nin imlenime ait olmayan tüm karakterleri uygulamaya aktarması <rfc2119>ZORUNLU</rfc2119>dur. Ayrıca, bir <termref def="dt-validating">geçerlilik denetimi yapan XML işlemci</termref>nin bu karakterlerin <termref def="dt-elemcontent">eleman içeriği</termref>nde bulunan boşluk karakterlerinden olup olmadıkları konusunda da uygulamayı bilgilendirmesi <rfc2119>ZORUNLU</rfc2119>dur.</p>

				<p>İçeriğindeki boşlukların korunması gereken elemanlar bunu uygulamaya, <att>xml:space</att> adlı özel bir öznitelikle bildirebilirler. Geçerli belgelerde, bu özniteliklerin, diğerleri gibi kullanıldıkları takdirde bildirilmeleri <rfc2119>ZORUNLU</rfc2119>dur. Bildirilirken, değeri bir <termref def="dt-enumerated">sayısı sabit tür</termref> olarak, <attval>default</attval> ve <attval>preserve</attval> değerlerinden biri veya ikisiyle birden bildirilmelidir. Örnek:</p>

				<eg><![CDATA[<!ATTLIST manzume  xml:space (default|preserve) 'preserve'>]]>

&lt;!ATTLIST kaynakkod xml:space (preserve) #FIXED 'preserve'&gt;</eg>

				<p><attval>default</attval> değeri, bu eleman için uygulamaca kabul edilen boşluk karakterleri işleme kipinin uygun olacağını; <attval>preserve</attval> değeri ise, uygulamanın boşluk karakterlerinin oluşturduğu boşlukları korumasının istendiğini belirtir. Bildirilen isteğin, elemanın içeriğindeki tüm elemanlara (onlarda ayrıca birer <att>xml:space</att> özniteliği bulunmadıkça) uygulanacağı varsayılır. Bu belirtim <att>xml:space</att> özniteliğine <attval>default</attval> ve <attval>preserve</attval> dışında anlamlı bir değer atamaz. Başka değerlerin belirtilmesi bir hatadır; XML işlemci hatayı raporlayabileceği gibi <rfc2119>SEÇİMLİK</rfc2119>, öznitelik belirtimini yoksayarak veya hatalı değeri uygulamaya raporlayarak hatadan kurtulabilir <rfc2119>SEÇİMLİK</rfc2119>. Uygulamalar hatalı değerleri reddedebilir veya yoksayabilir.</p>

				<p>Bir belgenin <termref def="dt-root">kök elemanı</termref>nın, bu öznitelik için bir değer sağlanmadıkça veya öznitelik bir öntanımlı değerle bildirilmiş olmadıkça, uygulamanın boşluk işleme ile ilgili olarak uygulamaya hiçbir istek bildirmek zorunda olmadığı varsayılır.</p>

			</div2>

			<div2 id="sec-line-ends">
				<head>Satırsonlarının İşlenmesi</head>
				<p>XML <termref def="dt-parsedent">çözümlü öğeleri</termref> genellikle, düzenleme kolaylığı bakımından satırlar halinde düzenlenmiş dosyalardan oluşur. Bu satırlar genellikle satırsonu (<code>#xA</code>) ve satırbaşı (<code>#xD</code>) karakterlerinin biri veya ikisi kullanılarak birbirlerinden ayrılırlar.</p>

				<!--p><termref def="dt-app">Uygulama</termref>ların görevlerini basitleştirmek için <termref def="dt-xml-proc">XML işlemci</termref> girdideki harici çözümlenmiş öğelerde (belge öğesini de içererek) bulunan tüm satırsonları, girdi çözümlenmeden önce,  iki karakterlik <code>#xD #xA</code> dizilimi ve ardından bir <code>#xA</code> gelmeyen <code>#xD</code> karakteri tek bir <code>#xA</code> karakterine dönüştürülerek normalleştirilmiş gibi davranmalıdır <rfc2119>ZORUNLU</rfc2119>.</p-->
        <p><termref def="dt-app">Uygulama</termref>ların görevlerini basitleştirmek için <termref def="dt-xml-proc">XML işlemci</termref> girdideki harici çözümlenmiş öğelerde (belge öğesini de içererek) bulunan tüm satırsonları, girdi çözümlenmeden önce, aşağıdakileri
        tek bir <code>#xA</code> karakterine dönüştürülerek normalleştirilmiş gibi davranmalıdır <rfc2119>ZORUNLU</rfc2119>:</p>
        <olist>
          <item>
            <p>iki karakterlik #xD #xA dizisi</p>
          </item>
          <item>
            <p>iki karakterlik #xD #x85 dizisi</p>
          </item>
          <item>
            <p>tek başına #x85 karakteri</p>
          </item>
          <item>
            <p>tek başına #x2028 karakteri</p>
          </item>
          <item>
            <p>hemen ardından #xA veya #x85 gelmeyen #xD karakteri</p>
          </item>
        </olist>
        <p>#x85 ve #x2028 karakterleri bir öğenin kodlama bildirimi (varsa) okunana kadar güvenilir şekilde tanınamaz ve dönüştürülemez. Bu yüzden, bunları XML ve metin bildirimlerinde kullanmak ölümcül bir hatadır.</p>
			</div2>

			<div2 id="sec-lang-tag">
				<head>Dilin Belirtilmesi</head>
				<p>Belge işlemede genellikle, içeriğin yazıldığı doğal ve biçimsel dili bilmek yararlıdır. Bir XML belgedeki elemanların öznitelik değerlerinde ve içeriğinde kullanılan dili belirtmek için belgeye <att>xml:lang</att> isimli özel bir öznitelik yerleştirilebilir. Geçerli bir belgede bu özniteliğin, diğerleri gibi, kullanılmışsa <termref def="dt-attdecl">bildirilmiş</termref> olması <rfc2119>ZORUNLU</rfc2119>dur. Özniteliğin değeri olarak <bibref ref="RFC1766"/> (<titleref>Dil Tanıtım Yaftaları</titleref>) veya bir ardılı tarafından tanımlanmış dil belirteçlerinden biri veya boş dizge belirtilebilir.</p>

				<p>(33'ten 38'e kadar olan tanım terimleri silindi.)</p>

				<p>Örnek:</p>

				<eg><![CDATA[<p xml:lang="en">The quick brown fox jumps over the lazy dog.</p>
<p xml:lang="en-GB">What colour is it?</p>
<p xml:lang="en-US">What color is it?</p>
<sp who="Faust" desc='leise' xml:lang="de">
  <l>Habe nun, ach! Philosophie,</l>
  <l>Juristerei, und Medizin</l>
  <l>und leider auch Theologie</l>
  <l>durchaus studiert mit hei&#xDF;em Bem&#xFC;h'n.</l>
</sp>]]></eg>

        <p><att>xml:lang</att> tarafından belirtilen dil, belirtildiği elemana (özniteliklerinin değerleri dahil) ve içindeki tüm elemanlara (<att>xml:lang</att> belirtilmiş iç elemanlar hariç) uygulanır. Özellikle, B elemanını kapsayan bir A elemanındaki bir <att>xml:lang</att> belirtimi, B elemanındaki <att>xml:lang</att> özniteliğinde başka bir dil belirtmeksizin, boş değer belirterek,  B elemanı için değiştirilebilir. B elemanının içeriği, sanki üstsel elemanlarında veya kendisinde hiç <att>xml:lang</att> belirtilmemiş gibi hiçbir dil içeriğiyle ilişkilendirilmez. Uygulamalar, hangi elemanların öznitelik değerlerinin ve hangi içerik parçalarının, belirtildiği takdirde, <att>xml:lang</att> ile belirtilen dile bağlı olarak ele alınacağını kendileri saptar.</p>

				<note>
					<p>Dil bilgisi ayrıca, (HTTP veya MIME gibi) harici aktarım protokollerince de sağlanmış olabilir. Bu olduğu takdirde, bu bilgi XML uygulamalarınca kullanılabilir, ancak  yerel olarak sağlanmış bir <att>xml:lang</att> özniteliği ile belirtilen bir değerin bu değeri değiştireceği varsayılmalıdır.</p>
				</note>

				<p><att>xml:lang</att> için basit bir bildirim şöyle olabilir:</p>

				<eg>xml:lang CDATA #IMPLIED</eg>

				<p>Ancak, eğer uygunsa, özel öntanımlı değerler ayrıca verilebilir. İngiliz öğrenciler için Fransız şiirlerinin bir kolleksiyonu ile İngilizce olan tefsirler ve notlar <att>xml:lang</att> özniteliği şöyle bildirilebilir:</p>

				<eg>&lt;!ATTLIST manzume   xml:lang CDATA 'fr'&gt;
&lt;!ATTLIST tefsir  xml:lang CDATA 'en'&gt;
&lt;!ATTLIST not   xml:lang CDATA 'en'&gt;</eg>

			</div2>
      <div2 id="sec-normalization-checking">
        <head>Normalleştirme Sınaması</head>
        <p>Aşağıdaki XML <emph id="dt-relconst">uyumlu oluşumların</emph> tanımlarına ilaveten tüm XML <termref def="dt-parsedent">çözümlü öğe</termref>lerinin (<termref def="dt-docent">belge öğeleri</termref> dahil) <specref ref="sec-CharNorm"/> tanımına uygun olarak <termref def="dt-fullnorm">tamamen normalleştirilmesi</termref> <rfc2119>ÖNERİ</rfc2119>lir:</p>
        <olist>
          <item>
            <p>tüm <termref def="dt-parsedent">çözümlü öğe</termref>lerin <termref def="dt-repltext">ikame metni</termref>
            </p>
          </item>
          <item>
            <p>Bağlamda, aşağıdaki sözdizimlerinden biriyle eşleşen tüm metinler:</p>
            <olist>
              <item>
                <p>
                  <nt def="NT-CData">CDATAVerisi</nt>
                </p>
              </item>
              <item>
                <p>
                  <nt def="NT-CharData">KarkVeri</nt>
                </p>
              </item>
              <item>
                <p>
                  <nt def="NT-content">içerik</nt>
                </p>
              </item>
              <item>
                <p>
                  <nt def="NT-Name">Ad</nt>
                </p>
              </item>
              <item>
                <p>
                  <nt def="NT-Nmtoken">AdDizge</nt>
                </p>
              </item>
            </olist>
          </item>
        </olist>
        <p>Yine de, <termref def="dt-fullnorm">tamamen normalleştirilmiş</termref> olmasa bile bir belge hala iyi biçimlidir. XML işlemcilerin belgenin <termref def="dt-fullnorm">tamamen normalleştirilmiş</termref> biçimde işlenmesi konusunda kullanıcıya bir seçenek sunmaları ve bunun istenip istenmediğini uygulamaya raporlamaları <rfc2119>ÖNERİ</rfc2119>lir. Doğrulamama seçeneğinin sadece girdi metni <specref ref="sec-CharNorm"/> bölümünde tanımlandığı gibi <termref def="dt-certified">onaylı</termref> olduğu takdirde seçilmiş olması <rfc2119>ÖNERİ</rfc2119>lir.</p>

        <p>Tamamen normalleştirme doğrulaması, öğenin, <specref ref="sec-CharNorm"/> bölümünde açıklandığı gibi <termref def="dt-inclnorm">dahili normalleştirmeli</termref> biçimde olduğu doğrulandıktan sonra <specref ref="sec-CharNorm"/> bölümünde açıklandığı gibi <termref def="dt-compchar">aksan karakteri</termref> ile başlayan yukarıda listelenmiş uyumlu oluşumlardan hiçbiri doğrulanmayarak başarılmış olmalıdır <rfc2119>ZORUNLU</rfc2119>.  Geçerlilik sınaması yapmayan işlemcilerin okunmayan harici öğelerin içerilmesine sebep olacak olası normalleştirmemeleri yoksayması <rfc2119>ZORUNLU</rfc2119>dur.</p>

        <note>
          <p><termref def="dt-compchar">aksan karakterleri</termref>nin hepsi,
          sıfırıncı aksan sınıfından olmayanlarla, bir miktarı sıfırıncı aksan sınıfında yer alanlardan belli bir kurallı Unicode birleşiminde ilk karakter olarak yer almayanlardan oluşan Unicode karakterleridir. Bu karakterler bir temel karakterin hemen ardından geldiklerinde anlamlı olduklarından, bir <termref def="dt-compchar">aksan karakteri</termref> ile başlayan uyumlu oluşumların sınırlanması XML'in ifade gücünde önemli bir azalmaya yol açmayacaktır.</p>
        </note>

        <p>Tamamen normalleştirme doğrulanırken, bir işlemci normalleştirme özellikleri saptanamayan karakterlere (yani, işlemcinin gerçekleştiriminde kullanılan Unicode sürümünde henüz bulunmayan karakterlere) rastlarsa, işlemci, seçim kullanıcının olmak üzere, bu karakterlerin sebep olması olası normalleştirmemeleri yoksayabilir <rfc2119>SEÇİMLİK</rfc2119>. Bu normalleştirmemeleri yoksayma seçeneği, güvenilirlik ve güvenlik önem kazandığında uygulamalar tarafından seçilmiş olmamalıdır <rfc2119>ÖNERİ</rfc2119>.</p>

        <p>XML işlemcilerin <termref def="dt-fullnorm">tamamen normalleştirilecek</termref> girdiyi dönüştürmemesi <rfc2119>ZORUNLU</rfc2119>dur. Gerek XML 1.1 gerekse XML 1.0 girdiden XML 1.1 çıktı oluşturacak XML uygulamalarının çıktının <termref def="dt-fullnorm">tamamen normalleştirilmiş</termref> olduğundan emin olmaları <rfc2119>ÖNERİ</rfc2119>lir; dahili işlemler için <termref def="dt-fullnorm">tamamen normalleştirme</termref> gerekli değildir.</p>

        <p>Bu bölümün amacı XML işlemcileri, XML belge oluşturucuların belgeyi gerektiği gibi normalleştirdiklerinden emin olmaya teşvik etmektir. Böylece, XML uygulamaları, Unicode'un mümkün kıldığı olası farklı dizge hecelemeler hakkında endişelenmeksizin dizgelerin özdeşlik karşılaştırmaları gibi sınamaları yapabilirler.</p>

        <p>Öğeler Unicode kodlu olmadıklarında, eğer bunların kodlamasını işlemci dönüştürecekse, işlemcinin normalleştirme yapan bir dönüştürücü kullanması <rfc2119>ÖNERİ</rfc2119>lir.</p>
      </div2>
		</div1>

		<!-- &Elements; -->
		<div1 id="sec-logical-struct">
			<head>Mantıksal Yapılar</head>
			<p><termdef id="dt-element" term="Eleman">Her <termref def="dt-xml-doc">XML belge</termref>, her biri <termref def="dt-stag">başlangıç etiketi</termref> ve <termref def="dt-etag">bitiş etiketi</termref> ile sınırlanmış veya <termref def="dt-eetag">boş eleman etiketi</termref>nden oluşan bir veya daha fazla eleman içerir. Her eleman ismiyle betimlenen bir türe (bazan buna soysal betimleyici (SB) dendiği de olur) ve çeşitli öznitelik belirtimlerine sahiptir</termdef>. Her öznitelik bir <termref def="dt-attrname">isim</termref> ve bir <termref def="dt-attrval">değer</termref> ile belirtilir.</p>

			<scrap>
				<head>Eleman</head>
				<prod id="NT-element" num="39">
					<lhs>eleman</lhs>
					<rhs>
						<nt def="NT-EmptyElemTag">BoşElemEtiketi</nt>
					</rhs>
					<rhs>| <nt def="NT-STag">BaşlEtiketi</nt>
						<nt def="NT-content">içerik</nt>
						<nt def="NT-ETag">BitişEtiketi</nt>
					</rhs>
					<wfc def="GIMatch"/>
					<vc def="elementvalid"/>
				</prod>
			</scrap>

			<p>Bu belirtimin bu ve gelecek sürümlerinin standartlaşımı için ayrılmış olan <code>(('X'|'x')('M'|'m')('L'|'l'))</code> ifadesiyle eşleşen dizgelerle başlayan isimler hariç, eleman türlerinin ve özniteliklerinin isimlerine, kullanımına ve uygulama anlamsallığına bu belirtimde kısıtlama konmamıştır.</p>

			<wfcnote id="GIMatch">
				<head>Eleman Türü Eşleşmeli</head>
				<p>Bir elemanın bitiş etiketindeki <nt def="NT-Name">Ad</nt> ile başlangıç etiketindeki eleman türünün eşleşmesi <rfc2119>ZORUNLU</rfc2119>dur.</p>
			</wfcnote>

			<vcnote id="elementvalid">
				<head>Geçerli Eleman</head>
				<p>Bir elemanın geçerli olması için, <nt def="NT-Name">Ad</nt>'ın eleman türü ile eşleştiği yerde <nt def="NT-elementdecl">elemanBild</nt> ile eşleşen bir bildirim olmalı ve aşağıdakilenden biri gerçekleşmelidir:</p>

        <olist>
					<item>
						<p>Bildirim <kw>EMPTY</kw> ile eşleşir ve eleman hiçbir <termref def="dt-content">içeriğe</termref> sahip değildir (hatta öğe gönderimleri, açıklamalar, işlem yönergeleri ve boşluk karakterleri bile yoktur).</p>
					</item>
					<item>
						<p>Bildirim <nt def="NT-children">çocuklar</nt> sözdizimiyle eşleşir ve <termref def="dt-parentchild">çocuk elemanlar</termref> dizisi, içerik modelindeki düzenli ifadeye uygun olarak üretilen dilde olup başlangıç etiketi ile ilk çocuk eleman arasında, çocuk elemanlar arasında veya son çocuk elemanla bitiş etiketi arasında isteğe bağlı olarak boşluk karakterleri, açıklamalar veya işlem yönergeleri (yani <nt def="NT-Misc">Muhtelif</nt> tanım teriminde yer alan imlenimler) içerebilir. İçinde sadece boşluk karakterleri veya boşluk karakterlerine ikame edilen karakter gönderimleri olan CDATA (imlenim olarak okunmayan açıklama) bölümleri, <nt def="NT-S">B</nt> sözdizimiyle eşleşmeyeceğinden burada yer alamaz, ancak içerdiği karakter gönderimleri boşluk karakterlerine ikame edilen sabit değerli dahili öğeler, <nt def="NT-S">B</nt> ile eşleşeceklerinden burada yer alabilir.</p>
					</item>
					<item>
						<p>Bildirim <nt def="NT-Mixed">Karışık</nt> ile eşleşir; içerik ise (öğe gönderimlerinin yerlerine ikame metinleri yerleştirildikten sonra), <termref def="dt-chardata">karakter verisi</termref> (<termref def="dt-cdsection">CDATA bölümleri</termref> dahil), <termref def="dt-comment">açıklamalar</termref>, <termref def="dt-pi">işlem yönergeleri</termref> ve türleri içerik modelindeki isimlerle eşleşen <termref def="dt-parentchild">çocuk elemanlar</termref>dan oluşur.</p>
					</item>
					<item>
						<p>Bildirim <kw>ANY</kw> ile eşleşir; içerik ise (öğe gönderimlerinin yerlerine ikame metinleri yerleştirildikten sonra), <termref def="dt-chardata">karakter verisi</termref>, <termref def="dt-cdsection">CDATA bölümleri</termref>, <termref def="dt-comment">açıklamalar</termref>, <termref def="dt-pi">işlem yönergeleri</termref> ve türleri bildirilmiş olan <termref def="dt-parentchild">çocuk elemanlar</termref>dan oluşur.</p>
					</item>
				</olist>
			</vcnote>
			<div2 id="sec-starttags">
				<head>Başlangıç, Bitiş ve Boş-Eleman Etiketleri</head>
				<p><termdef id="dt-stag" term="Start-Tag">Boş olmayan her XML elemanının başlangıcı bir <term>başlangıç etiketi</term> ile imlenir.</termdef></p>

				<scrap>
					<head>Başlangıç Etiketi</head>
					<prodgroup pcw2="6" pcw4="15" pcw5="11.5">
						<prod id="NT-STag" num="40">
							<lhs>BaşlEtiketi</lhs>
							<rhs>'&lt;' <nt def="NT-Name">Ad</nt> (<nt def="NT-S">B</nt>
								<nt def="NT-Attribute">Öznitelik</nt>)* <nt def="NT-S">B</nt>? '&gt;'</rhs>
							<wfc def="uniqattspec"/>
						</prod>
						<prod id="NT-Attribute" num="41">
							<lhs>Öznitelik</lhs>
							<rhs>
								<nt def="NT-Name">Ad</nt>
								<nt def="NT-Eq">Eşittir</nt>
								<nt def="NT-AttValue">ÖznitDeğeri</nt>
							</rhs>
							<vc def="ValueType"/>
							<wfc def="NoExternalRefs"/>
							<wfc def="CleanAttrVals"/>
						</prod>
					</prodgroup>
				</scrap>

				<p>Başlangıç ve bitiş etiketindeki <nt def="NT-Name">Ad</nt>, elemanın <term>türü</term>nü verir. <termdef id="dt-attr" term="Öznitelik"><nt def="NT-Name">Ad</nt>-<nt def="NT-AttValue">ÖznitDeğeri</nt> çiftine elemanın <term>öznitelik belirtimi</term></termdef>, <termdef id="dt-attrname" term="Öznitelik Adı">her çiftteki <nt def="NT-Name">Ad</nt>a <term>öznitelik adı</term></termdef> ve <termdef id="dt-attrval" term="Öznitelik Değeri"><nt def="NT-AttValue">ÖznitDeğeri</nt> (<code>'</code> veya <code>"</code> ayraçları arasındaki metin) içeriğine de <term>öznitelik değeri</term> denir</termdef>. Bir başlangıç etiketindeki veya bir boş etiketteki öznitelik belirtimlerinin sırasının önemsizliğine dikkat ediniz.</p>

				<wfcnote id="uniqattspec">
					<head>Eşsiz Öznitelik Belirtimi</head>
					<p>Bir öznitelik ismi aynı başlangıç veya boş eleman etiketinde birden fazla yer almamalıdır <rfc2119>ZORUNLU</rfc2119>.</p>

				</wfcnote>
				<vcnote id="ValueType">
					<head>Öznitelik Değerinin Türü</head>
					<p>Öznitelik bildirilmiş olmalıdır <rfc2119>ZORUNLU</rfc2119>; değeri onun için bildirilmiş türde olmalıdır <rfc2119>ZORUNLU</rfc2119>. (Öznitelik türleri için <specref ref="attdecls"/> bölümüne bakınız.)</p>
				</vcnote>
				<wfcnote id="NoExternalRefs">
					<head>Harici Öğe Gönderimleri Olmamalı</head>
					<p>Öznitelik değerleri doğrudan veya dolaylı olarak harici öğelere öğe gönderimleri içermemelidir <rfc2119>ZORUNLU</rfc2119>.</p>
				</wfcnote>
				<wfcnote id="CleanAttrVals">
					<head>Öznitelik Değerleri <code>&lt;</code> İçermemeli</head>
					<p>Bir öznitelik değeri içinde doğrudan veya dolaylı olarak atıfta bulunulmuş bir öğenin <termref def="dt-repltext">ikame metni</termref> bir <code>&lt;</code> içermemelidir <rfc2119>ZORUNLU</rfc2119>.</p>
				</wfcnote>
				<p>Bir başlangıç etiketi örneği:</p>

				<eg>&lt;termdef id="dt-dog" term="köpek"&gt;</eg>

				<p><termdef id="dt-etag" term="Bitiş Etiketi">Bir başlangıç etiketi ile başlayan her elemanın sonu, başlangıç etiketinde belirtilen eleman türünü yansıtan ismi içeren bir <term>bitiş etiketi</term> tarafından imlenir:</termdef></p>

				<scrap>
					<head>Bitiş Etiketi</head>
					<prodgroup pcw2="6" pcw4="15" pcw5="11.5">
						<prod id="NT-ETag" num="42">
							<lhs>BitişEtiketi</lhs>
							<rhs>'&lt;/' <nt def="NT-Name">Ad</nt>
								<nt def="NT-S">B</nt>? '&gt;'</rhs>
						</prod>
					</prodgroup>
				</scrap>

				<p>Bir bitiş etiketi örneği:</p>
				<eg>&lt;/termdef&gt;</eg>

				<p><termdef id="dt-content" term="İçerik">Başlangıç ve bitiş ekiketleri arasındaki  <termref def="dt-text">metin</termref>e elemanın <term>içeriği</term> denir:</termdef></p>

				<scrap>
					<head>Eleman İçeriği</head>
					<prodgroup pcw2="6" pcw4="15" pcw5="11.5">
						<prod id="NT-content" num="43">
							<lhs>içerik</lhs>
							<rhs>
								<nt def="NT-CharData">KarkVeri</nt>? ((<nt def="NT-element">eleman</nt>
| <nt def="NT-Reference">Gönderim</nt> | <nt def="NT-CDSect">CDATABölümü</nt>
| <nt def="NT-PI">PI</nt> | <nt def="NT-Comment">Açıklama</nt>) <nt def="NT-CharData">KarkVeri</nt>?)*</rhs>
						</prod>
					</prodgroup>
				</scrap>

				<p><termdef id="dt-empty" term="Boş">Hiç <nt def="NT-content">içeriği</nt> olmayan eleman <term>boş</term>tur</termdef>. Bir boş eleman ya bir başlangıç etiketinin hemen ardına bir bitiş etiketi yerleştirerek ya da bir boş eleman etiketi ile gösterilir. <termdef id="dt-eetag" term="boş eleman etiketi">Bir <term>boş eleman etiketi</term> özel bir biçime sahiptir:</termdef></p>

				<scrap>
					<head>Boş Eleman Etiketi</head>
					<prodgroup pcw2="6" pcw4="15" pcw5="11.5">
						<prod id="NT-EmptyElemTag" num="44">
							<lhs>BoşElemEtiketi</lhs>
							<rhs>'&lt;' <nt def="NT-Name">Ad</nt> (<nt def="NT-S">B</nt>
								<nt def="NT-Attribute">Öznitelik</nt>)* <nt def="NT-S">B</nt>? '/&gt;'</rhs>
							<wfc def="uniqattspec"/>
						</prod>
					</prodgroup>
				</scrap>

				<p>Boş eleman etiketi <kw>EMPTY</kw> anahtar sözcüğüyle bildirilmiş olsun ya da olmasın hiçbir içeriğe sahip olmayan her eleman için kullanılabilir. <termref def="dt-interop">Birlikte çalışabilirlik için</termref>, boş eleman etiketi sadece ve sadece <kw>EMPTY</kw> bildirimli elemanlar için kullanılmalıdır <rfc2119>ÖNERİ</rfc2119>.</p>

				<p>Boş eleman örnekleri:</p>

				<eg>&lt;IMG align="left"
 src="http://www.w3.org/Icons/WWW/w3c_home" /&gt;
&lt;br>&lt;/br&gt;
&lt;br /&gt;</eg>

			</div2>

			<div2 id="elemdecls">
				<head>Eleman Türü Bildirimleri</head>
				<p><termref def="dt-xml-doc">XML belge</termref>nin <termref def="dt-element">eleman</termref> yapısı, <termref def="dt-valid">geçerlilik</termref>le ilgili amaçlara yönelik olarak, eleman türü ve öznitelik listesi bildirimleri kullanılarak kısıtlanabilir. Bir eleman türü bildirimi elemanın <termref def="dt-content">içeriği</termref>ni kısıtlar.</p>

				<p>Eleman türü bildirimleri çoğunlukla elemanın <termref def="dt-parentchild">çocuklar</termref>ı olan eleman türlerini kısıtlar. <termref def="dt-atuseroption">Seçim kullanıcının olmak üzere</termref>, bir XML işlemci, bir bildirimin hakkında hiçbir bildirimin yapılmadığı bir elemanı içermesi ama bunun bir hata olmaması durumunda bir uyarı verebilir <rfc2119>SEÇİMLİK</rfc2119>.</p>

				<p><termdef id="dt-eldecl" term="Eleman Türü bildirimi">Bir <term>eleman
türü bildirimi</term>nin biçimi:</termdef></p>
				<scrap>
					<head>Eleman Türü Bildirimi</head>
					<prodgroup pcw2="5.5" pcw4="18" pcw5="9">
						<prod id="NT-elementdecl" num="45">
							<lhs>elemanBild</lhs>
							<rhs>'&lt;!ELEMENT' <nt def="NT-S">B</nt>
								<nt def="NT-Name">Ad</nt>
								<nt def="NT-S">B</nt>
								<nt def="NT-contentspec">içerikBelirtimi</nt>
								<nt def="NT-S">B</nt>? '&gt;'</rhs>
							<vc def="EDUnique"/>
						</prod>
						<prod id="NT-contentspec" num="46">
							<lhs>içerikBelirtimi</lhs>
							<rhs>'EMPTY' | 'ANY' | <nt def="NT-Mixed">Karışık</nt> | <nt def="NT-children">çocuklar</nt>
							</rhs>
						</prod>
					</prodgroup>
				</scrap>

				<p>Burada <nt def="NT-Name">Ad</nt> bildirdiği elemanın türüdür.</p>

        <vcnote id="EDUnique">
					<head>Eşsiz Eleman Türü Bildirimi</head>
					<p>Bir eleman türü birden fazla bildirilmemelidir <rfc2119>ZORUNLU</rfc2119>.</p>
				</vcnote>
				<p>Eleman türü bildirimi örnekleri:</p>
				<eg>&lt;!ELEMENT br EMPTY&gt;
&lt;!ELEMENT p (#PCDATA|emph)* &gt;
&lt;!ELEMENT %name.para; %content.para; &gt;
&lt;!ELEMENT container ANY&gt;</eg>
				<div3 id="sec-element-content">
					<head>Eleman İçeriği</head>
					<p><termdef id="dt-elemcontent" term="Eleman içeriği">Elemanların sadece aralarında boşluk karakterlerinin (<nt def="NT-S">B</nt> sözdizimiyle eşleşen karakterler) bulunmasının isteğe bağlı olduğu <termref def="dt-parentchild">çocuk</termref> elemanlardan oluşmasının <rfc2119>ZORUNLU</rfc2119> olduğu durumda, böyle bir eleman <termref def="dt-stag">türü</termref> bir <term>eleman içeriği</term>ne sahip demektir</termdef>. <termdef id="dt-content-model" term="İçerik Modeli">Bu durumda kural basit bir dilbilgisine sahip bir <term>içerik modeli</term> içerir. Bu model izin verilen çocuk eleman türlerini ve bunların içerikte yer alabilecekleri sırayı içerir</termdef>. Dilbilgisi, isimler, içerik parçacıkları seçim listeleri veya içerik parçacıkları sıralama listelerinden oluşan içerik parçacıklarından (<nt def="NT-cp">içerikparçacığı</nt>) oluşur:</p>

					<scrap>
						<head>Eleman İçerik Modelleri</head>
						<prodgroup pcw2="5.5" pcw4="16" pcw5="11">
							<prod id="NT-children" num="47">
								<lhs>çocuklar</lhs>
								<rhs>(<nt def="NT-choice">seçim</nt> | <nt def="NT-seq">sıra</nt>)
('?' | '*' | '+')?</rhs>
							</prod>
							<prod id="NT-cp" num="48">
								<lhs>içerikparçacığı</lhs>
								<rhs>(<nt def="NT-Name">Ad</nt> | <nt def="NT-choice">seçim</nt>
| <nt def="NT-seq">sıra</nt>) ('?' | '*' | '+')?</rhs>
							</prod>
							<prod id="NT-choice" num="49">
								<lhs>seçim</lhs>
								<rhs>'(' <nt def="NT-S">B</nt>? <nt def="NT-cp">içerikparçacığı</nt> ( <nt def="NT-S">B</nt>? '|' <nt def="NT-S">B</nt>? <nt def="NT-cp">içerikparçacığı</nt> )+ <nt def="NT-S">B</nt>? ')'</rhs>
								<vc def="vc-PEinGroup"/>
							</prod>
							<prod id="NT-seq" num="50">
								<lhs>sıra</lhs>
								<rhs>'(' <nt def="NT-S">B</nt>? <nt def="NT-cp">içerikparçacığı</nt> ( <nt def="NT-S">B</nt>? ',' <nt def="NT-S">B</nt>? <nt def="NT-cp">içerikparçacığı</nt> )* <nt def="NT-S">B</nt>? ')'</rhs>
								<vc def="vc-PEinGroup"/>
							</prod>
						</prodgroup>
					</scrap>

					<p>Burada her <nt def="NT-Name">Ad</nt>, bir <termref def="dt-parentchild">çocuk</termref> eleman olarak karşımıza çıkabilecek bir elemanın türüdür. Bir seçim listesindeki bir içerik parçacığı, <termref def="dt-elemcontent">eleman içeriği</termref>nde, seçim listesinin dilbilgisi içinde görüldüğü yerde bulunabilir; bir sıralama listesinde bulunan içerik parçacıklarının her biri <termref def="dt-elemcontent">eleman içeriği</termref>nde listede belirtilen sırada yer almalıdır <rfc2119>ZORUNLU</rfc2119>. Bir isim veya listeyi izleyen isteğe bağlı karakterler, listedeki elemanların ve içerik parçacıklarının, bir kere veya daha fazla mı (<code>+</code>), hiç veya bir kere mi (<code>?</code>) yoksa hiç veya defalarca mı (<code>*</code>) yer alabileceklerini belirtirler. Böyle bir işlecin yokluğu, eleman veya içerik parçacığının listede sadece ve sadece bir kere yer alabileceği <rfc2119>ZORUNLU</rfc2119> anlamına gelir. Bu sözdizimi ve manası bu belirtimdeki sözdizimi tanımlarında kullanılanla aynıdır.</p>

					<p>Bir eleman içeriğinin bir içerik modeliyle eşleşmesi için, sıralama, seçim ve yineleme işleçlerine tabi olarak ve içeriğindeki her elemanı içerik modelindeki bir eleman türüne eşleyerek, içerik modeli boyunca sadece ve sadece tek bir yol izlenebilir olmalıdır. <termref def="dt-compat">Uyumluluk için</termref>, içerik modelinin, bir elemanın, model içindeki bir eleman türünün birden fazla oluşumu ile eşleşmesine izin vermesi hatadır. Daha fazla bilgi için <specref ref="determinism"/> bölümüne bakınız.</p>

					<vcnote id="vc-PEinGroup">
						<head>Düzgün Gruplama/Parametre Öğesi İç İçeliği</head>
						<p>Parametre öğesinin <termref def="dt-repltext">ikame metni</termref> parantezli gruplar halinde düzgün biçimde iç içe geçmiş olmalıdır <rfc2119>ZORUNLU</rfc2119>. Başka bir deyişle, bir <nt def="NT-choice">seçim</nt>, <nt def="NT-seq">sıra</nt> veya <nt def="NT-Mixed">Karışık</nt> oluşumundaki açan veya kapatan parantezlerden herhangi biri bir <termref def="dt-PERef">parametre öğesi</termref>nin ikame metni içindeyse, ikisinin de aynı ikame metninde içeriliyor olması gerekir <rfc2119>ZORUNLU</rfc2119>.</p>

						<p><termref def="dt-interop">Birlikte çalışabilirlik için</termref>, eğer bir parametre öğesi gönderimi, bir <nt def="NT-choice">seçim</nt>, <nt def="NT-seq">sıra</nt> veya <nt def="NT-Mixed">Karışık</nt> oluşumunda bulunuyorsa, parametre öğesinin ikame metni en azından bir boş olmayan karakter içermeli <rfc2119>ÖNERİ</rfc2119> ve ikame metninin ne ilk ne de son boş olmayan karakteri bir bağlaç (<code>|</code> veya <code>,</code>) olmalıdır <rfc2119>ÖNERİ</rfc2119>.</p>
					</vcnote>

					<p>Eleman içerik modelleri örnekleri:</p>
					<eg>&lt;!ELEMENT spec (front, body, back?)&gt;
&lt;!ELEMENT div1 (head, (p | list | note)*, div2*)&gt;
&lt;!ELEMENT dictionary-body (%div.mix; | %dict.mix;)*&gt;</eg>
				</div3>

				<div3 id="sec-mixed-content">
					<head>Karışık İçerik</head>
					<p><termdef id="dt-mixed" term="Karışık İçerik">Bir eleman <termref def="dt-stag">türü</termref>,  karakter verisi (tercihan aralarına <termref def="dt-parentchild">çocuk</termref> elemanlar serpiştirilmiş olarak) içerebilen türde olduğu takdirde <term>karışık içerik</term> sahibi demektir.</termdef> Bu durumda, çocuk elemanların türleri, sıralanışları ve oluşum sayısı dışında herşeyi kısıtlanabilir:</p>

					<scrap>
						<head>Karışık İçerik Bildirimi</head>
						<prodgroup pcw2="5.5" pcw4="16" pcw5="11">
							<prod id="NT-Mixed" num="51">
								<lhs>Karışık</lhs>
								<rhs>'(' <nt def="NT-S">B</nt>? '#PCDATA' (<nt def="NT-S">B</nt>?
'|' <nt def="NT-S">B</nt>? <nt def="NT-Name">Ad</nt>)* <nt def="NT-S">B</nt>?
')*' </rhs>
								<rhs>| '(' <nt def="NT-S">B</nt>? '#PCDATA' <nt def="NT-S">B</nt>? ')' </rhs>
								<vc def="vc-PEinGroup"/>
								<vc def="vc-MixedChildrenUnique"/>
							</prod>
						</prodgroup>
					</scrap>

					<p>Buradaki <nt def="NT-Name">Ad</nt>lar çocuk elemanların türleridir. <kw>#PCDATA</kw> anahtar sözcüğü ezelden beridir <quote>parsed character data</quote> (çözümlenmiş karakter verisi) sözcüklerinden türetilmektetir.</p>

					<vcnote id="vc-MixedChildrenUnique">
						<head>Türler Yinelenmemeli</head>
						<p>Aynı ad tek bir karışık içerikte birden fazla gözükmemelidir <rfc2119>ZORUNLU</rfc2119>.</p>
					</vcnote>

					<p>Karışık içerik bildirimleri örnekleri:</p>
					<eg>&lt;!ELEMENT p (#PCDATA|a|ul|b|i|em)*&gt;
&lt;!ELEMENT p (#PCDATA | %font; | %phrase; | %special; | %form;)* &gt;
&lt;!ELEMENT b (#PCDATA)&gt;</eg>
				</div3>
			</div2>

			<div2 id="attdecls">
				<head>Öznitelik Listesi Bildirimleri</head>
				<p><termref def="dt-attr">Öznitelikler</termref> isim-değer çiftlerini <termref def="dt-element">eleman</termref>larla ilişkilendirmek için kullanılmalıdır. Öznitelik belirtimleri <termref def="dt-stag">başlangıç etiketleri</termref> ve <termref def="dt-eetag">boş eleman etiketleri</termref> dışında gözükmemelidir <rfc2119>ZORUNLU</rfc2119>; bu nedenle, bunları eşleştirmek için <specref ref="sec-starttags"/> bölümündeki sözdizimi tanımları kullanılır. Öznitelik listesi bildirimlerinin kullanım yerleri:</p>

				<ulist>
					<item>
						<p>Belli bir eleman türüne ait öznitelik kümesini tanımlamak için.</p>
					</item>
					<item>
						<p>Bu öznitelikler için tür kuralları oluşturmak için.</p>
					</item>
					<item>
						<p>Özniteliklere <termref def="dt-default">öntanımlı değerler</termref> sağlamak için.</p>
					</item>
				</ulist>
				<p><termdef id="dt-attdecl" term="Öznitelik Listesi Bildirimi"><term>Öznitelik listesi bildirimleri</term> ile ad, veri türü ve belli bir eleman türü ile ilişkili öznitelikler için (varsa) öntanımlı değer belirtilir:</termdef></p>

				<scrap>
					<head>Öznitelik Listesi Bildirimi</head>
					<prod id="NT-AttlistDecl" num="52">
						<lhs>ÖznitListBild</lhs>
						<rhs>'&lt;!ATTLIST' <nt def="NT-S">B</nt>
							<nt def="NT-Name">Ad</nt>
							<nt def="NT-AttDef">ÖznitTanımı</nt>* <nt def="NT-S">B</nt>? '&gt;'</rhs>
					</prod>
					<prod id="NT-AttDef" num="53">
						<lhs>ÖznitTanımı</lhs>
						<rhs>
							<nt def="NT-S">B</nt>
							<nt def="NT-Name">Ad</nt>
							<nt def="NT-S">B</nt>
							<nt def="NT-AttType">ÖznitTürü</nt>
							<nt def="NT-S">B</nt>
							<nt def="NT-DefaultDecl">ÖntanımlıBild</nt>
						</rhs>
					</prod>
				</scrap>

				<p><nt def="NT-AttlistDecl">ÖznitListBild</nt> sözdizimi tanımındaki <nt def="NT-Name">Ad</nt> bir eleman türüdür. <termref def="dt-atuseroption">Seçim kullanıcının olmak üzere</termref>, bir XML işlemci, eğer bir öznitelik, bildirilmemiş bir eleman türü için bildirilmişse uyarı verebilir <rfc2119>SEÇİMLİK</rfc2119>, fakat bu bir hata değildir. <nt def="NT-AttlistDecl">ÖznitListBild</nt> sözdizimi tanımındaki <nt def="NT-Name">Ad</nt> özniteliğin ismidir.</p>
				<p>Bir eleman türü için birden fazla <nt def="NT-AttlistDecl">ÖznitListBild</nt> varsa bunların içerikleri birleştirilir. Bir eleman türünün aynı özniteliği için birden fazla bildirim varsa, ilk bildirim dışındakiler yok sayılır. <termref def="dt-interop">Birlikte çalışabilirlik için</termref>, DTD yazarları belli bir eleman türü için en fazla bir öznitelik listesi bildirimi, bir öznitelik listesi bildirimindeki belli bir öznitelik ismi için en fazla bir öznitelik tanımı ve her öznitelik listesi bildiriminde en az bir öznitelik tanımı yapmayı tercih edebilir. <termref def="dt-interop">Birlikte çalışabilirlik için</termref>, <termref def="dt-atuseroption">seçim kullanıcının olmak üzere</termref>, bir XML işlemci, bir eleman türü için birden fazla öznitelik listesi bildirimi veya bir öznitelik için birden fazla öznitelik tanımı varsa, bir uyarı verebilir <rfc2119>SEÇİMLİK</rfc2119>, fakat bu bir hata değildir.</p>

				<div3 id="sec-attribute-types">
					<head>Öznitelik Türleri</head>
					<p>XML öznitelik türleri üç tanedir: dizge türü, dizgecik kümesi türü ve sayısı sabit tür. Dizge türü değer olarak bir dizgesel sabit alırken dizgecik kümesi türü biraz daha fazla kurala tabidir. Aşağıdaki dilbilgisi içinde belirtilen geçerlilik kısıtları, öznitelik değeri <specref ref="AVNormalize"/> bölümünde açıklandığı gibi normalleştirildikten sonra uygulanır.</p>

					<scrap>
						<head>Öznitelik Türleri</head>
						<prodgroup pcw4="14" pcw5="11.5">
							<prod id="NT-AttType" num="54">
								<lhs>ÖznitTürü</lhs>
								<rhs>
									<nt def="NT-StringType">DizgeTürü</nt> | <nt def="NT-TokenizedType">DizgecikTürü</nt>
| <nt def="NT-EnumeratedType">SayısıSabitTür</nt>
								</rhs>
							</prod>
							<prod id="NT-StringType" num="55">
								<lhs>DizgeTürü</lhs>
								<rhs>'CDATA'</rhs>
							</prod>
							<prod id="NT-TokenizedType" num="56">
								<lhs>DizgecikTürü</lhs>
								<rhs>'IDREF'</rhs>
								<vc def="idref"/>
								<rhs>| 'IDREFS'</rhs>
								<vc def="idref"/>
								<rhs>| 'ENTITY'</rhs>
								<vc def="entname"/>
								<rhs>| 'ENTITIES'</rhs>
								<vc def="entname"/>
								<rhs>| 'NMTOKEN'</rhs>
								<vc def="nmtok"/>
								<rhs>| 'NMTOKENS'</rhs>
								<vc def="nmtok"/>
                <rhs>| 'ID'</rhs>
                <vc def="id"/>
                <vc def="one-id-per-el"/>
                <vc def="id-default"/>
							</prod>
						</prodgroup>
					</scrap>

					<vcnote id="id">
						<head>ID Eşsizliği</head>
						<p><kw>ID</kw> türünden değerlerin <nt def="NT-Name">Ad</nt> sözdizimi tanımı ile eşleşmesi <rfc2119>ZORUNLU</rfc2119>dur. Bir Ad, bu türden bir değer olarak bir XML belgede bir kereden fazla gözükmemelidir <rfc2119>ZORUNLU</rfc2119>. Yani, ID değerlerinin belirtildikleri elemanları eşsiz olarak betimlemesi <rfc2119>ZORUNLU</rfc2119>dur.</p>
					</vcnote>

					<vcnote id="one-id-per-el">
						<head>Eleman Türü Başına Bir ID</head>
						<p>Bir eleman türü için birden fazla ID özniteliği belirtilemez <rfc2119>ZORUNLU</rfc2119>.</p>
					</vcnote>

					<vcnote id="id-default">
						<head>ID Özniteliği Öntanımlısı</head>
						<p>Bir ID özniteliğinin <kw>#IMPLIED</kw> veya <kw>#REQUIRED</kw> öntanımlısı ile bildirilmesi <rfc2119>ZORUNLU</rfc2119>dur.</p>
					</vcnote>

					<vcnote id="idref">
						<head>IDREF</head>
						<p><kw>IDREF</kw> türünden değerlerin <nt def="NT-Name">Ad</nt> sözdizimi tanımıyla eşleşmesi <rfc2119>ZORUNLU</rfc2119> olup <kw>IDREFS</kw> türünden değerlerin de <nt def="NT-Names">Adlar</nt> sözdizimi tanımıyla eşleşmesi <rfc2119>ZORUNLU</rfc2119>dur; her <nt def="NT-Name">Ad</nt>ın XML belgedeki elemanlardan yalnız birinin ID özniteliğinin değeri ile eşleşmesi <rfc2119>ZORUNLU</rfc2119>dur; yani, <kw>IDREF</kw> değerlerinin bazı ID özniteliklerinin değerleri ile eşleşmesi gerekir <rfc2119>ZORUNLU</rfc2119>.</p>
					</vcnote>

					<vcnote id="entname">
						<head>Öğe İsmi</head>
						<p><kw>ENTITY</kw> türünden değerlerin <nt def="NT-Name">Ad</nt> sözdizimiyle, <kw>ENTITIES</kw> türünden değerlerin <nt def="NT-Names">Adlar</nt> sözdizimiyle eşleşmesi <rfc2119>ZORUNLU</rfc2119>dur; her <nt def="NT-Name">Ad</nt>'ın <termref def="dt-doctype">DTD</termref> içinde bildirilmiş bir <termref def="dt-unparsed">çözümlenmemiş öğe</termref> ismiyle eşleşmesi <rfc2119>ZORUNLU</rfc2119>dur.</p>
					</vcnote>

					<vcnote id="nmtok">
						<head>Ad Dizgeciği</head>
						<p><kw>NMTOKEN</kw> türünden değerlerin <nt def="NT-Nmtoken">AdDizge</nt> sözdizimiyle, <kw>NMTOKENS</kw> türünden değerlerin <nt def="NT-Nmtokens">AdDizgeler</nt> sözdizimiyle eşleşmesi <rfc2119>ZORUNLU</rfc2119>dur.</p>
					</vcnote>
					<!-- why?
<p>The XML processor must normalize attribute values before
passing them to the application, as described in
<specref ref="AVNormalize"/>.</p>-->
					<p><termdef id="dt-enumerated" term="Sayısı Sabit Öznitelik Değerleri"><term>Sayısı sabit türden öznitelikler</term>in bildirimleri izin verilen değerlerin bir listesini içerir</termdef>. Bu özniteliklerin bu değerlerden birini alması <rfc2119>ZORUNLU</rfc2119>dur. İki çeşit sayısı sabit türde öznitelik vardır:</p>

					<scrap>
						<head>Sayısı Sabit Öznitelik Türleri</head>
						<prod id="NT-EnumeratedType" num="57">
							<lhs>SayısıSabitTür</lhs>
							<rhs>
								<nt def="NT-NotationType">GösterimTürü</nt>
| <nt def="NT-Enumeration">Sayım</nt>
							</rhs>
						</prod>
						<prod id="NT-NotationType" num="58">
							<lhs>GösterimTürü</lhs>
							<rhs>'NOTATION' <nt def="NT-S">B</nt> '(' <nt def="NT-S">B</nt>? <nt def="NT-Name">Ad</nt> (<nt def="NT-S">B</nt>? '|' <nt def="NT-S">B</nt>? <nt def="NT-Name">Ad</nt>)* <nt def="NT-S">B</nt>? ')' </rhs>
							<vc def="notatn"/>
							<vc def="OneNotationPer"/>
							<vc def="NoNotationEmpty"/>
							<vc def="NoDuplicateTokens"/>
						</prod>
						<prod id="NT-Enumeration" num="59">
							<lhs>Sayım</lhs>
							<rhs>'(' <nt def="NT-S">B</nt>? <nt def="NT-Nmtoken">AdDizge</nt>
(<nt def="NT-S">B</nt>? '|' <nt def="NT-S">B</nt>? <nt def="NT-Nmtoken">AdDizge</nt>)* <nt def="NT-S">B</nt>? ')'</rhs>
							<vc def="enum"/>
							<vc def="NoDuplicateTokens"/>
						</prod>
					</scrap>

					<p>Bir <kw>NOTATION</kw> özniteliği, özniteliğin eklendiği elemanı yorumlamakta kullanılacak, <code>SYSTEM</code> ve/veya <code>PUBLIC</code> betimleyicileri ile belirtilmiş DTD'de bildirilmiş bir <termref def="dt-notation">gösterim</termref>i betimler.</p>

					<vcnote id="notatn">
						<head>Gösterim Öznitelikleri</head>
						<p>Bu türden değerlerin bildirimde içerilen <titleref href="#Notations">gösterim</titleref> adlarından biri ile eşleşmesi <rfc2119>ZORUNLU</rfc2119>dur; bildirimdeki tüm gösterim adlarının bildirilmiş olması <rfc2119>ZORUNLU</rfc2119>dur.</p>
					</vcnote>

					<vcnote id="OneNotationPer">
						<head>Eleman Türü Başına Bir Gösterim</head>
						<p>Bir eleman türü içinde birden fazla <kw>NOTATION</kw> özniteliği belirtilemez <rfc2119>ZORUNLU</rfc2119>.</p>
					</vcnote>

					<vcnote id="NoNotationEmpty">
						<head>Boş Elemanda Gösterim Olmaz</head>
						<p><termref def="dt-compat">Uyumluluk için</termref>, <kw>NOTATION</kw> türünden bir öznitelik <kw>EMPTY</kw> ile bildirilmiş bir elemanda bildirilemez <rfc2119>ZORUNLU</rfc2119>.</p>
					</vcnote>

					<vcnote id="NoDuplicateTokens">
						<head>Dizgecikler Yinelenemez</head>
						<p>Gösterim adlarının müstakilen tek bir <nt def="NT-NotationType">GösterimTürü</nt> öznitelik bildiriminde gözükmesi <rfc2119>ZORUNLU</rfc2119> olup <nt def="NT-Nmtoken">AdDizge</nt>ciklerinin de müstakilen tek bir <nt def="NT-Enumeration">Sayım</nt> öznitelik bildiriminde gözükmesi <rfc2119>ZORUNLU</rfc2119>dur.</p>
					</vcnote>

					<vcnote id="enum">
						<head>Sayım</head>
						<p>Bu türden değerlerin bildirimdeki <nt def="NT-Nmtoken">AdDizge</nt>ciklerinden biri ile eşleşmesi <rfc2119>ZORUNLU</rfc2119>dur.</p>
					</vcnote>

					<p><termref def="dt-interop">Birlikte çalışabilirlik için</termref>, aynı <nt def="NT-Nmtoken">AdDizge</nt>ciğinin bir eleman türünün sayısı sabit öznitelik türlerinde birden fazla gözükmemesi <rfc2119>ÖNERİ</rfc2119>lir.</p>
				</div3>

				<div3 id="sec-attr-defaults">
					<head>Öznitelik Öntanımlıları</head>
					<p>Bir <termref def="dt-attdecl">Öznitelik bildirimi</termref>, özniteliğin varlığının gerekli olup olmadığına dair bilgi sağlar <rfc2119>ZORUNLU</rfc2119>; gerekli değilse XML işlemcinin bir bildirilmiş özniteliğin bir belgede bulunmayışı halinde nasıl tepki vereceği bilgisini sağlar.</p>

					<scrap>
						<head>Öznitelik Öntanımlıları</head>
						<prodgroup pcw4="14" pcw5="11.5">
							<prod id="NT-DefaultDecl" num="60">
								<lhs>ÖntanımlıBild</lhs>
								<rhs>'#REQUIRED' |&nbsp;'#IMPLIED' </rhs>
								<rhs>| (('#FIXED' <nt def="NT-S">B</nt>)? <nt def="NT-AttValue">ÖznitDeğeri</nt>)</rhs>
								<vc def="RequiredAttr"/>
								<vc def="defattrvalid"/>
								<wfc def="CleanAttrVals"/>
								<vc def="FixedAttr"/>
								<wfc def="NoExternalRefs"/>
							</prod>
						</prodgroup>
					</scrap>

					<p>Bir öznitelik bildiriminde <kw>#REQUIRED</kw> anahtar sözcüğü özniteliğin varlığının <rfc2119>ZORUNLU</rfc2119> olduğu, <kw>#IMPLIED</kw> ise hiçbir öntanımlı değerin sağlanmadığı anlamına gelir.	<termdef id="dt-default" term="Öznitelik Öntanımlısı">Bildirim ne <kw>#REQUIRED</kw> ne de <kw>#IMPLIED</kw> sözcüğünü içeriyorsa, <nt def="NT-AttValue">ÖznitDeğeri</nt>nin içeriği <term>öntanımlı</term> değer olarak kabul edilir; bildirimde <kw>#FIXED</kw> anahtar sözcüğünün varlığı, özniteliğin  <rfc2119>ZORUNLU</rfc2119> olarak daima bu öntanımlı değere sahip olacağı anlamına gelir. XML işlemci, bir elemanın bir öznitelik belirtimi olmaksızın bir öntanımlı değer bildirimiyle okunmasının gerekliliğini saptadığında, XML işlemcinin özniteliği uygulamaya bildirilmiş öntanımlı değeriyle raporlaması <rfc2119>ZORUNLU</rfc2119>dur.</termdef></p>

					<vcnote id="RequiredAttr">
						<head>Öznitelik Gerekliliği</head>
						<p>Eğer öntanımlı bildirim <kw>#REQUIRED</kw> anahtar sözcüğü ise, özniteliğin öznitelik listesi bildiriminde türü belirtilen tüm elemanlar için belirtilmesi <rfc2119>ZORUNLU</rfc2119>dur.</p>
					</vcnote>

					<vcnote id="defattrvalid">
						<head>Öntanımlı Öznitelik Değerinin Sözdizimsel Doğruluğu</head>
						<p>Bildirilen öntanımlı değerin, bildirilen öznitelik türünün sözdizimsel kurallarına uygun olması <rfc2119>ZORUNLU</rfc2119>dur. Yani, bir özniteliğin öntanımlı değeri:</p>

						<ulist>
							<item>
								<p>IDREF veya ENTITY türündeyse, <nt def="NT-Name">Ad</nt> sözdizimi tanımıyla eşleşmelidir;</p>
							</item>
							<item>
								<p>IDREFS veya ENTITIES türündeyse, <nt def="NT-Names">Adlar</nt> sözdizimi tanımıyla eşleşmelidir;</p>
							</item>
							<item>
								<p>NMTOKEN türündeyse, <nt def="NT-Nmtoken">AdDizge</nt> sözdizimi tanımıyla eşleşmelidir;</p>
							</item>
							<item>
								<p>NMTOKENS türündeyse, <nt def="NT-Nmtokens">AdDizgeler</nt> sözdizimi tanımıyla eşleşmelidir;</p>
							</item>
							<item>
								<p>bir <nt def="NT-EnumeratedType">sayısı sabit tür</nt>deyse (ya <nt def="NT-NotationType">NOTATION</nt> türünde ya da bir <nt def="NT-Enumeration">sayısı sabit değerli</nt>), sayısı belli değerlerden biriyle eşleşmelidir.</p>
							</item>
						</ulist>
						<p>Burada sadece türün sözdizimsel kurallarının gerekli oluşuna dikkat ediniz; diğer kurallar (örneğin, ENTITY türünde bir öznitelik için değerin bildirilmiş bir çözümlenmemiş öğenin ismi olması) bir geçerliliği sınayan çözümleyici tarafından sadece bu özniteliğin gözükmediği bir elemanın varlığında raporlanacaktır.</p>
					</vcnote>
					<vcnote id="FixedAttr">
						<head>Sabit Öznitelik Değeri</head>
						<p>Eğer bir öznitelik <kw>#FIXED</kw> anahtar sözcüğü ile bildirilmiş bir öntanımlı değere sahipse, bu öznitelik ait olduğu elemanda öntanımlı değeriyle eşleştirilmelidir <rfc2119>ZORUNLU</rfc2119>.</p>
					</vcnote>

					<p>Öznitelik listesi bildirimleri için örnekler:</p>
					<eg>&lt;!ATTLIST termdef
          id      ID      #REQUIRED
          name    CDATA   #IMPLIED&gt;
&lt;!ATTLIST list
          type    (bullets|ordered|glossary)  "ordered"&gt;
&lt;!ATTLIST form
          method  CDATA   #FIXED "POST"&gt;</eg>
				</div3>

				<div3 id="AVNormalize">
					<head>Öznitelik Değerinin Normalleştirilmesi</head>
					<p>Bir öznitelik bir uygulamaya aktarılmadan veya geçerliliği sınanmadan önce XML işlemci tarafından, aşağıdaki algoritma uygulanarak veya bu algoritma ile aynı sonucu verecek bir takım başka yöntemler kullanılarak, öznitelik değerlerinin normalleştirilmesi <rfc2119>ZORUNLU</rfc2119>dur.</p>

					<olist>
						<item>
							<p>Tüm satırsonları <specref ref="sec-line-ends"/> bölümünde açıklandığı gibi girdi satırsonlarında sadece <code>#xA</code> içeriyormuş gibi normalleştirilmelidir <rfc2119>ZORUNLU</rfc2119>; öyle ki, algoritmanın kalanı bu şekilde normalleştirilmiş metin üzerinde uygulansın.</p>
						</item>
						<item>
							<p>Boş dizgeden oluşan bir normalleştirilmiş değerle başlar. (?)</p>
						</item>
						<item>
							<p>Her karakter için, öğe gönderimi veya normalleştirilmemiş öznitelik değerindeki karakter gönderimi, başından sonuna kadar aşağıdakileri yapar:</p>
							<ulist>
								<item>
									<p>Bir karakter gönderimi için, atıf yapılan karakter normalleştirilmiş değere eklenir.</p>
								</item>
								<item>
									<p>Bir öğe gönderimi için, bu algoritmanın 3. adımı öğenin ikame metnine dönüşümlü olarak uygulanır.</p>
								</item>
								<item>
									<p>Bir boşluk karakteri (<code>#x20</code>, <code>#xD</code>, <code>#xA</code>, <code>#x9</code>) için, normalleştirilmiş değere bir boşluk (<code>#x20</code>) eklenir.</p>
								</item>
								<item>
									<p>Diğer karakterler için, normalleştirilmiş değere o karakter eklenir.</p>
								</item>
							</ulist>
						</item>
					</olist>

          <p>Eğer öznitelik türü CDATA değilse, XML işlemci öznitelik değerini normalleştirme işleminde, baştaki ve sondaki boşlukları (<code>#x20</code>) silmeli <rfc2119>ZORUNLU</rfc2119> ve aradakileri (<code>#x20</code>) de tek bir boşluk (<code>#x20</code>) ile değiştirmelidir <rfc2119>ZORUNLU</rfc2119>.</p>

					<p>Normalleştirilmemiş öznitelik değeri boşluk (<code>#x20</code>) dışındaki boşluk karakterlerine bir karakter gönderimi içeriyorsa, normalleştirilmiş değerde atıf yapılan karakterin kendisinin (<code>#xD</code>, <code>#xA</code> veya <code>#x9</code>) bulunacağına dikkat ediniz. Bu, normalleştirilmemiş değeri boşluk karakterlerinden birini içerip de normalleştirilmiş değere bunun için bir boşluk (<code>#x20</code>) yerleştirildiği duruma ve ayrıca, normalleştirilmemiş değerin, ikame metninde boşluk karakterlerinden birini içeren bir öğeye gönderim içerip de dönüşümlü olarak işlenerek, normalleştirilmiş değere bunun için bir boşluk (<code>#x20</code>) yerleştirildiği duruma aykırıdır.</p>

					<p>Bildirimleri olmayan tüm öznitelikler, geçerlilik sınaması yapmayan bir işlemci tarafından <kw>CDATA</kw> bildirimli olarak ele alınmalıdır <rfc2119>ZORUNLU</rfc2119>.</p>

					<p>Bildirimi olmayan bir öğeye bir <termref def="dt-entref">gönderim</termref> içeren bir <termref def="dt-attrval">öznitelik değeri</termref>nin varlığı bir hatadır.</p>

					<p>Biraz aşağıdaki öznitelik normalleştirme örnekleri için bildirimler şöyledir:</p>
					<eg>&lt;!ENTITY d "&amp;#xD;"&gt;
&lt;!ENTITY a "&amp;#xA;"&gt;
&lt;!ENTITY da "&amp;#xD;&amp;#xA;"&gt;</eg>

					<p>öznitelik belirtimleri soldaki sütunda, normalleştirilecek karakter dizilerinden <att>a</att> özniteliğinin <kw>NMTOKENS</kw> bildirimli olanları ortadaki sütunda, <kw>CDATA</kw> bildirimli olanları sağdaki sütundadır.</p>
					<table border="1" frame="border" summary="Öznitelik normalleştirmeleri">
						<thead>
							<tr>
								<th>Öznitelik belirtimi</th>
								<th>NMTOKENS olarak a</th>
								<th>CDATA olarak a</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>
									<eg>a="

xyz"</eg>
								</td>
								<td>
									<eg>x y z</eg>
								</td>
								<td>
									<eg>#x20 #x20 x y z</eg>
								</td>
							</tr>
							<tr>
								<td>
									<eg>a="&amp;d;&amp;d;A&amp;a;&amp;#x20;&amp;a;B&amp;da;"</eg>
								</td>
								<td>
									<eg>A #x20 B</eg>
								</td>
								<td>
									<eg>#x20 #x20 A #x20 #x20 #x20 B #x20 #x20</eg>
								</td>
							</tr>
							<tr>
								<td>
									<eg>a=
"&amp;#xd;&amp;#xd;A&amp;#xa;&amp;#xa;B&amp;#xd;&amp;#xa;"</eg>
								</td>
								<td>
									<eg>#xD #xD A #xA #xA B #xD #xA</eg>
								</td>
								<td>
									<eg>#xD #xD A #xA #xA B #xD #xA</eg>
								</td>
							</tr>
						</tbody>
					</table>

          <p>Son örneğin, <kw>NMTOKENS</kw> türünde bildirimli <att>a</att> için geçersiz (ama iyi biçimli) oluşuna dikkat ediniz.</p>
				</div3>
			</div2>

			<div2 id="sec-condition-sect">
				<head>Şart Bölümleri</head>
				<p><termdef id="dt-cond-section" term="şart bölümü"><term>Şart
bölümleri</term> <termref def="dt-doctype">belge türü bildirimi</termref> harici altkümesinin veya içerme ve yoksayma ile ilgili anahtar sözcüklere dayalı olarak DTD'nin mantıksal yapısına dahil edilen veya dışlanan harici parametre öğelerinin bölümleridir.</termdef></p>

				<scrap>
					<head>Şart Bölümü</head>
					<prodgroup pcw2="9" pcw4="14.5">
						<prod id="NT-conditionalSect" num="61">
							<lhs>şartBölümü</lhs>
							<rhs>
								<nt def="NT-includeSect">includeBölümü</nt> | <nt def="NT-ignoreSect">ignoreBölümü</nt>
							</rhs>
						</prod>
						<prod id="NT-includeSect" num="62">
							<lhs>includeBölümü</lhs>
							<rhs>'&lt;![' <nt def="NT-S">B</nt>? 'INCLUDE' <nt def="NT-S">B</nt>? '[' <nt def="NT-extSubsetDecl">dışAltKümeBild</nt> ']]&gt;' </rhs>
							<vc def="condsec-nesting"/>
						</prod>
						<prod id="NT-ignoreSect" num="63">
							<lhs>ignoreBölümü</lhs>
							<rhs>'&lt;![' <nt def="NT-S">B</nt>? 'IGNORE' <nt def="NT-S">B</nt>? '[' <nt def="NT-ignoreSectContents">ignoreBlmİçeriği</nt>* ']]&gt;'</rhs>
							<vc def="condsec-nesting"/>
						</prod>
						<prod id="NT-ignoreSectContents" num="64">
							<lhs>ignoreBlmİçeriği</lhs>
							<rhs>
								<nt def="NT-Ignore">Yoksayılan</nt> ('&lt;![' <nt def="NT-ignoreSectContents">ignoreBlmİçeriği</nt> ']]&gt;' <nt def="NT-Ignore">Yoksayılan</nt>)*</rhs>
						</prod>
						<prod id="NT-Ignore" num="65">
							<lhs>Yoksayılan</lhs>
							<rhs>
								<nt def="NT-Char">Kark</nt>* - (<nt def="NT-Char">Kark</nt>* ('&lt;![' | ']]&gt;') <nt def="NT-Char">Kark</nt>*) </rhs>
						</prod>
					</prodgroup>
				</scrap>

				<vcnote id="condsec-nesting">
					<head>Düzgün Şart Bölümü/Parametre Öğesi İç İçeliği</head>
					<p>"<code>&lt;![</code>", "<code>[</code>" veya "<code>]]&gt;</code>" şart bölümlerinden biri, bir parametre öğesi gönderiminin ikame metninde içeriliyorsa, bunların hepsinin aynı ikame metninde içeriliyor olmaları gerekir <rfc2119>ZORUNLU</rfc2119>.</p>
				</vcnote>

				<p>Dahili ve harici DTD altkümelerinde olduğu gibi, bir şart bölümü boşluk karakterlerinin arasına serpiştirilmiş olarak bir veya daha fazla tam bildirim, açıklama, işlem yönergesi veya iç içe şart bölümleri içerebilir.</p>

				<p>Şart bölümünün anahtar sözcüğü <kw>INCLUDE</kw> ise, şart bölümü içeriği DTD'nin parçası olarak işlenmelidir <rfc2119>ZORUNLU</rfc2119>. Şart bölümünün anahtar sözcüğü <kw>IGNORE</kw> ise, şart bölümü içeriği DTD'nin parçası olarak işlenmemelidir <rfc2119>ZORUNLU</rfc2119>. Eğer <kw>INCLUDE</kw> sözcüklü bir şart bölümü daha geniş bir <kw>IGNORE</kw> sözcüklü şart bölümünün içeriğinde yer alıyorsa, hem iç hem de dıştaki şart bölümleri yoksayılmalıdır <rfc2119>ZORUNLU</rfc2119>. Yoksayılan bir şart bölümünün içeriği, anahtar sözcüğü izleyen "<code>[</code>" ile başlayıp, şart bölümünün sonuna kadar, başı "<code>&lt;![</code>", sonu "<code>]]&gt;</code>" olan şart bölümleri dışında kalan herşey yoksayılarak çözümlenmelidir <rfc2119>ZORUNLU</rfc2119>. Parametre öğesi gönderimleri bu işlemde tanınır olmamalıdır <rfc2119>ZORUNLU</rfc2119>.</p>

				<p>Şart bölümünün anahtar sözcüğü bir parametre öğesi gönderimi ise,  işlemci şart bölümünün içerileceğine mi yoksa yok mu sayılacağına karar vermeden önce parametre öğesinin yerine içeriği yerleştirilmelidir <rfc2119>ZORUNLU</rfc2119>.</p>

				<p>Bir örnek:</p>
				<eg>&lt;!ENTITY % draft 'INCLUDE' &gt;
&lt;!ENTITY % final 'IGNORE' &gt;

&lt;![%draft;[
&lt;!ELEMENT book (comments*, title, body, supplements?)&gt;
]]&gt;
&lt;![%final;[
&lt;!ELEMENT book (title, body, supplements?)&gt;
]]&gt;</eg>
			</div2>
			<!--
<div2 id='sec-pass-to-app'>
<head>XML Processor Treatment of Logical Structure</head>
<p>When an XML processor encounters a start-tag, it must make
at least the following information available to the application:
<ulist>
<item>
<p>the element type's generic identifier</p>
</item>
<item>
<p>the names of attributes known to apply to this element type
(validating processors must make available names of all attributes
declared for the element type; non-validating processors must
make available at least the names of the attributes for which
values are specified.
</p>
</item>
</ulist>
</p>
</div2>
-->
		</div1>

		<!-- &Entities; -->
		<div1 id="sec-physical-struct">
			<head>Fiziksel Yapılar</head>
			<p><termdef id="dt-entity" term="Öğe">Bir XML belge birden fazla saklama biriminden oluşabilir. Bunların her birine <term>öğe</term> denir. Bunlar  bir <term>isim</term> ile <termref def="dt-docent">belge öğesi</termref> ve <termref def="dt-doctype">harici DTD altkümesi</termref> hariç bu isimle  betimlenen bir <term>içeriğe</term> sahiptirler</termdef>. Her XML belgenin daima <termref def="dt-docent">belge öğesi</termref> denilen bir öğesi vardır; belgenin tamamını içerir ve <termref def="dt-xml-proc">XML işlemci</termref>ye bir başlangıç noktası teşkil eder.</p>

			<p>Öğeler ya çözümlü öğedir ya da çözümlenmemiş öğedir. <termdef id="dt-parsedent" term="Çözümlü Öğe">Bir <term>çözümlü öğe</term>nin içeriğine onun <termref def="dt-repltext">ikame metni</termref> denir ve bu <termref def="dt-text">metin</termref>, belgenin bütünleyici bir parçası sayılır.</termdef></p>

			<p><termdef id="dt-unparsed" term="Çözümlenmemiş Öğe">Bir <term>çözümlenmemiş öğe</term>nin içeriği <termref def="dt-text">metin</termref> olabileceği gibi olmayabilir de; eğer metinse, XML olmayabilir. Her çözümlenmemiş öğenin bir isimle betimlenen öğeye uygun bir <termref def="dt-notation">gösterim</termref>i vardır. XML işlemcinin öğe için betimleyiciler sağlaması ve gösterimi uygulamaya elverişli hale getirmesinin gerekliliği dışında XML, çözümlenmemiş öğelerin içerikleriyle ilgili kısıtlamalar koymaz.</termdef></p>

			<p>Çözümlü öğelere öğe gönderimlerindeki isimleri üzerinden, çözümlenmemiş öğelere ise öğe gönderimlerindeki <kw>ENTITY</kw> veya <kw>ENTITIES</kw> özniteliklerinin değeri olarak verilen isimlerinden erişilir.</p>

			<p><termdef id="gen-entity" term="Genel Öğeler"><term>Genel öğeler</term>, belge içeriğinde kullanmak içindir. Bu belirtimde genel öğelere bazan bir belirsizliğe yol açmayacaksa <emph>genel</emph> sıfatı olmasızın sadece <emph>öğe</emph> denmekle yetinilmiştir.</termdef></p>

      <p><termdef id="dt-PE" term="Parametre Öğesi"><term>Parametre öğeleri</term> DTD içeriğinde kullanmak için olup çözümlü öğelerden oluşurlar</termdef>. Bu iki öğe türü farklı gönderim biçimleri kullanırlar ve farklı bağlamları tanırlar. Dahası, farklı isim-alanlarına sahiptirler; aynı isme sahip bir genel öğe ile bir parametre öğesi bir diğeriyle hiç alakası olmayan iki ayrı öğedir.</p>
			<div2 id="sec-references">
				<head>Karakter ve Öğe Gönderimleri</head>
				<p><termdef id="dt-charref" term="Karakter Gönderimleri">Bir <term>karakter gönderimi</term> ISO/IEC 10646 karakter kümesinden belli bir karaktere atıf yapar; örneğin, girdi aygıtları tarafından doğrudan erişilebilir olmayan bir karakteri belirtmek için.</termdef></p>

				<scrap>
					<head>Karakter Gönderimi</head>
					<prod id="NT-CharRef" num="66">
						<lhs>KarkGönd</lhs>
						<rhs>'&amp;#' [0-9]+ ';' </rhs>
						<rhs>| '&amp;#x' [0-9a-fA-F]+ ';'</rhs>
						<wfc def="wf-Legalchar"/>
					</prod>
				</scrap>

				<wfcnote id="wf-Legalchar">
					<head>Geçerli Karakter</head>
					<p>Karakter gönderimlerinde kullanılacak karakterlerin <nt def="NT-Char">Kark</nt> sözdizimi tanımıyla eşleşmeleri <rfc2119>ZORUNLU</rfc2119>dur.</p>
				</wfcnote>

				<p>Eğer karakter gönderimi <quote><code>&amp;#x</code></quote> ile başlıyor, rakamlar ve harflerden sonra bir <code>;</code> ile bitiyorsa, bu gönderim karaktere ISO/IEC 10646'daki onaltılık kodu ile atıf yapıyor demektir; eğer <quote><code>&amp;#</code></quote> ile başlıyor ve rakamlardan sonra <code>;</code> ile bitiyorsa, karaktere onluk koduyla atıf yapıyor demektir.</p>

				<p><termdef id="dt-entref" term="Öğe Gönderimi">Bir <term>öğe gönderimi</term> bir isimli öğenin içeriğine atıfta bulunur</termdef>. <termdef id="dt-GERef" term="Genel Öğe Gönderimi">Genel öğelere atıf yapmak için ve-imini (<code>&amp;</code>) ve noktalı virgülü (<code>;</code>) ayraç olarak kullanan gönderimlerdir</termdef>. <termdef id="dt-PERef" term="Paramete Öğesi Gönderimi"><term>Paramete öğesi gönderimleri</term> ayraç olarak yüzde imini (<code>%</code>) ve noktalı virgülü (<code>;</code>) kullanan gönderimlerdir</termdef>.</p>

				<scrap>
					<head>Öğe Gönderimi</head>
					<prod id="NT-Reference" num="67">
						<lhs>Gönderim</lhs>
						<rhs>
							<nt def="NT-EntityRef">ÖğeGönd</nt> | <nt def="NT-CharRef">KarkGönd</nt>
						</rhs>
					</prod>
					<prod id="NT-EntityRef" num="68">
						<lhs>ÖğeGönd</lhs>
						<rhs>'&amp;' <nt def="NT-Name">Ad</nt> ';'</rhs>
						<wfc def="wf-entdeclared"/>
						<vc def="vc-entdeclared"/>
						<wfc def="textent"/>
						<wfc def="norecursion"/>
					</prod>
					<prod id="NT-PEReference" num="69">
						<lhs>ParÖğeGönd</lhs>
						<rhs>'%' <nt def="NT-Name">Ad</nt> ';'</rhs>
						<vc def="vc-entdeclared"/>
						<wfc def="norecursion"/>
						<wfc def="indtd"/>
					</prod>
				</scrap>

				<wfcnote id="wf-entdeclared">
					<head>Öğe Bildirilmeli</head>
					<p>Bir parametre öğesi içinde veya harici altkümede olmayan bir öğe gönderimi için, herhangi bir DTD'si olmayan veya sadece, hiçbir parametre öğesi bildirimi içermeyen bir dahili DTD altkümesi olan ya da <quote><code>standalone='yes'</code></quote> bildirimi olan bir belgede, öğe gönderiminde belirtilen <nt def="NT-Name">Ad</nt>'ın bir parametre öğesi içinde veya harici altkümede olmayan bir <titleref href="#sec-entity-decl">öğe bildirimi</titleref>ndeki adla eşleşmesi (&magicents; öğelerinin bildirilmesini gerektirmeyen iyi biçimli belgeler hariç) <rfc2119>ZORUNLU</rfc2119>dur. Bir genel öğe bildiriminin, bir öznitelik listesi bildiriminde bir öntanımlı değerin içinde gözüken gönderiminden önce yapılmış olması <rfc2119>ZORUNLU</rfc2119>dur.</p>

					<p>Geçerlilik sınaması yapmayan işlemcilerin, harici altkümedeki veya parametre öğeleri içindeki öğe bildirimlerini okumak ve işlemek  <titleref href="#include-if-valid">zorunda olmadıkları</titleref>na dikkat ediniz; böyle belgeler için, bir öğenin bildirilmesini gerektiren tek kural, sadece <titleref href="#sec-rmd">standalone='yes'</titleref> olması halinde iyi biçimlilik kuralıdır.</p>
				</wfcnote>

				<vcnote id="vc-entdeclared">
					<head>Öğe Bildirilmeli</head>
					<p><quote><code>standalone='no'</code></quote> bildirimli parametre öğesi başvuruları veya harici altkümesi olan bir belgede, öğe gönderiminde belirtilen <nt def="NT-Name">Ad</nt>'ın bir <titleref href="#sec-entity-decl">öğe bildirimi</titleref>ndeki adla eşleşmesi <rfc2119>ZORUNLU</rfc2119>dur. Birlikte çalışabilirlik için, geçerli belgelerin &magicents; öğelerini <specref ref="sec-predefined-ent"/> bölümünde belirtildiği şekilde bildirmeleri <rfc2119>ÖNERİ</rfc2119>lir. Bir parametre öğesinin bildiriminin, gönderiminden önce yer alması <rfc2119>ZORUNLU</rfc2119>dur. Benzer şekilde, bir genel öğenin bildiriminin de bu genel öğeye doğrudan veya dolaylı gönderimli bir öntanımlı değer içeren bir öznitelik listesi bildiriminden önce yer alması <rfc2119>ZORUNLU</rfc2119>dur.</p>
				</vcnote>
				<!-- FINAL EDIT: is this duplication too clumsy? -->
				<wfcnote id="textent">
					<head>Çözümlü Öğe</head>
					<p>Bir öğe başvurusu, bir <termref def="dt-unparsed">çözümlenmemiş öğe</termref> adı içermemelidir <rfc2119>ZORUNLU</rfc2119>. Çözümlenmemiş öğelere sadece <kw>ENTITY</kw> veya <kw>ENTITIES</kw> türünde bildirilmiş <termref def="dt-attrval">öznitelik değerleri</termref> içinden atıf yapılabilir.</p>
				</wfcnote>
				<wfcnote id="norecursion">
					<head>Özyineleme Yapılmamalı</head>
					<p>Bir çözümlü öğe dolaylı yada dolaysız kendisine atıf yapmamalıdır <rfc2119>ZORUNLU</rfc2119>.</p>
				</wfcnote>

				<wfcnote id="indtd">
					<head>DTD İçinde Olmalı</head>
					<p>Parametre öğe gönderimleri <termref def="dt-doctype">DTD</termref> dışında kullanılmamalıdır <rfc2119>ZORUNLU</rfc2119>.</p>
				</wfcnote>

				<p>Karakter ve öğe gönderimi örnekleri:</p>
				<eg>Seçenekleri kaydetmek için &lt;key>&amp;#x3C;&lt;/key&gt; yazınız.
Bu belge &amp;belgetarihi; tarihinde hazırlanmış ve
&amp;güvenlik-derecesi; olarak sınıflanmıştır.</eg>

				<p>Parametre öğesi gönderimi örneği:</p>
				<eg><![CDATA[<!-- "ISOLat2" parametre öğesini bildirelim ... -->
<!ENTITY % ISOLat2
         SYSTEM "http://www.xml.com/iso/isolat2-xml.entities" >
<!-- ... artık başvurabiliriz. -->
%ISOLat2;]]></eg>
			</div2>

			<div2 id="sec-entity-decl">
				<head>Öğe Bildirimleri</head>
				<p><termdef id="dt-entdecl" term="Öğe Bildirimi">Öğeler bu tanımla eşleşecek şekilde bildirilir:</termdef></p>

				<scrap>
					<head>Öğe Bildirimi</head>
					<prodgroup pcw2="5" pcw4="18.5">
						<prod id="NT-EntityDecl" num="70">
							<lhs>ÖğeBild</lhs>
							<rhs>
								<nt def="NT-GEDecl">GenÖğeBild</nt>
								<!--</rhs><com>General entities</com>
<rhs>--> | <nt def="NT-PEDecl">ParÖğeBild</nt>
							</rhs>
							<!--<com>Parameter entities</com>-->
						</prod>
						<prod id="NT-GEDecl" num="71">
							<lhs>GenÖğeBild</lhs>
							<rhs>'&lt;!ENTITY' <nt def="NT-S">B</nt>
								<nt def="NT-Name">Ad</nt>
								<nt def="NT-S">B</nt>
								<nt def="NT-EntityDef">ÖğeTanımı</nt>
								<nt def="NT-S">B</nt>?
'&gt;'</rhs>
						</prod>
						<prod id="NT-PEDecl" num="72">
							<lhs>ParÖğeBild</lhs>
							<rhs>'&lt;!ENTITY' <nt def="NT-S">B</nt> '%' <nt def="NT-S">B</nt>
								<nt def="NT-Name">Ad</nt>
								<nt def="NT-S">B</nt>
								<nt def="NT-PEDef">ParÖğeTanımı</nt>
								<nt def="NT-S">B</nt>? '&gt;'</rhs>
							<!--<com>Parameter entities</com>-->
						</prod>
						<prod id="NT-EntityDef" num="73">
							<lhs>ÖğeTanımı</lhs>
							<rhs>
								<nt def="NT-EntityValue">ÖğeDeğeri</nt> | (<nt def="NT-ExternalID">HariciID</nt>
								<nt def="NT-NDataDecl">NDataBild</nt>?)</rhs>
							<!-- <nt def='NT-ExternalDef'>ExternalDef</nt></rhs> -->
						</prod>
						<!-- FINAL EDIT: what happened to WFs here? -->
						<prod id="NT-PEDef" num="74">
							<lhs>ParÖğeTanımı</lhs>
							<rhs>
								<nt def="NT-EntityValue">ÖğeDeğeri</nt> | <nt def="NT-ExternalID">HariciID</nt>
							</rhs>
						</prod>
					</prodgroup>
				</scrap>

				<p><nt def="NT-Name">Ad</nt> bir <termref def="dt-entref">öğe gönderimi</termref>ni veya çözümlenmemiş öğe durumunda <kw>ENTITY</kw> veya <kw>ENTITIES</kw> özniteliğinin değerindeki öğeyi betimler. Eğer aynı öğe bir kereden fazla bildirilmişse, ilk bildirim bağlayıcıdır; seçim kullanıcının olmak üzere, bir XML işlemci eğer defalarca bildirilmiş öğeler varsa bir uyarı verebilir <rfc2119>SEÇİMLİK</rfc2119>.</p>

				<div3 id="sec-internal-ent">
					<head>Dahili Öğeler</head>
					<p><termdef id="dt-internent" term="Dahili Öğe İkame Metni">Eğer öğe tanımı bir <nt def="NT-EntityValue">ÖğeDeğeri</nt> ise tanımlı öğeye <term>dahili öğe</term> denir. Ayrıca bir fiziksel saklama nesnesi olmayıp öğenin içeriği bildirimde verilir</termdef>. <termref def="dt-litentval">Dizgesel sabitli öğe değeri</termref> durumunda, bazı öğe ve karakter gönderimlerinin işlenmesinin doğru <termref def="dt-repltext">ikame metni</termref>nin üretilmesini gerektirebileceğine dikkat ediniz; bkz, <specref ref="intern-replacement"/>.</p>

					<p>Bir dahili öğe bir <termref def="dt-parsedent">çözümlü öğe</termref>dir.</p>

					<p>İç öğe bildirimi örneği:</p>
					<eg>&lt;!ENTITY Gen-durum "Bu, belirtimin ön sürümüdür."&gt;</eg>
				</div3>

				<div3 id="sec-external-ent">
					<head>Harici Öğeler</head>
					<p><termdef id="dt-extent" term="Harici Öğe">Bir öğe dahili değilse bir <term>harici öğe</term>dir ve şöyle bildirilir:</termdef></p>

					<scrap>
						<head>Harici Öğe Bildirimi</head>
						<!--
<prod id='NT-ExternalDef'><lhs>ExternalDef</lhs>
<rhs></prod> -->
						<prod id="NT-ExternalID" num="75">
							<lhs>HariciID</lhs>
							<rhs>'SYSTEM' <nt def="NT-S">B</nt>
								<nt def="NT-SystemLiteral">SistemSabiti</nt>
							</rhs>
							<rhs>| 'PUBLIC' <nt def="NT-S">B</nt>
								<nt def="NT-PubidLiteral">GenidSabiti</nt>
								<nt def="NT-S">B</nt>
								<nt def="NT-SystemLiteral">SistemSabiti</nt>
							</rhs>
						</prod>
						<prod id="NT-NDataDecl" num="76">
							<lhs>NDataBild</lhs>
							<rhs>
								<nt def="NT-S">B</nt> 'NDATA' <nt def="NT-S">B</nt>
								<nt def="NT-Name">Ad</nt>
							</rhs>
							<vc def="not-declared"/>
						</prod>
					</scrap>
					<p>Eğer <nt def="NT-NDataDecl">NDataBild</nt> mevcutsa, o bir genel <termref def="dt-unparsed">çözümlenmemiş öğe</termref>dir; aksi takdirde çözümlü öğedir.</p>

					<vcnote id="not-declared">
						<head>Gösterim Bildirilmeli</head>
						<p><nt def="NT-Name">Ad</nt>'ın bir <termref def="dt-notation">gösterim</termref>in bildirilmiş ismiyle eşleşmesi <rfc2119>ZORUNLU</rfc2119>dur.</p>
					</vcnote>

					<p><termdef id="dt-sysid" term="Sistem Betimleyici"><nt def="NT-SystemLiteral">SistemSabiti</nt>'ne öğenin <term>sistem betimleyicisi</term> denir. Bu onun, öğenin ikame metnini oluşturacak XML işlemciye girdi sağlamak için gönderimi çözümleyecek işlemin bir parçası olarak, bir tanım-yeri (URI) başvurusuna dönüştürüleceği (<bibref ref="rfc3986"/>'da açıklandığı gibi) anlamına gelir</termdef>. Bir <code>#</code> karakteri ile başlayan betimleyicinin bir bölümünün sistem betimleyicinin bir parçası olması bir hatadır. Bu belirtimin kapsamı dışında bir bilgi kaynağı tarafından (örn, belli bir DTD tarafından tanımlanan özel bir XML elemanı türü veya belli bir uygulama belirtimi tarafından tanımlanmış bir işlem yönergesi) sağlanmış olmadıkça, göreli tarım-yerleri (URI'ler) içinde öğe bildiriminin bulunduğu özkaynağın konumuna görelidir ve bir bildirim olarak çözümlendiği noktada bildirimi başlatan '&lt;' karakterini içeren harici öğe olarak tanımlanmıştır. Dolayısıyla, bir tanım-yeri <termref def="dt-docent">belge öğesi</termref>ne, öğeyi içeren <termref def="dt-doctype">harici DTD altkümesi</termref>ne veya başka bir <termref def="dt-extent">harici parametre öğesi</termref>ne göreli olabilir. Bir tanım-yeri tarafından betimlenen özkaynağı getirme çabaları çözümleyici seviyesinde (örn, bir öğe çözümleyicide) veya daha alt seviyede (protokol seviyesinde, örn, HTTP <code>Location:</code> başlığı üzerinden) yönlendirilebilir. Özkaynak içinde, bu belirtimin kapsamı dışındaki ek bilgi kaynaklarının yokluğunda, bir özkaynağın temel tanım-yeri daima döndürülen asıl özkaynağın tanım-yeridir. Başka bir deyişle, özkaynağın tanım-yeri, tüm yönlendirmelerden sonra elde edilen tanım-yeridir.</p>

					<p>Sistem betimleyiciler (ve tanım-yeri başvurusu anlamında kullanılan diğer XML dizgeleri) <bibref ref="rfc3986"/> ile ilgili olarak, başvurulan özkaynağı getirmekte kullanılabilen bir tanım-yerinden önce, öncelenmiş olması gereken karakterler içerebilir. Öncelenecek karakterler, denetim karakterleri (#x0 dan #x1F'e kadar ve #x7F; çoğu XML'de bulunamaz), boşluk (#x20), ayraçlar ('&lt;' #x3C, '&gt;' #x3E ve '"' #x22), <emph>orada kullanımı makul olmayan</emph> karakterler ('{' #x7B, '}' #x7D, '|' #x7C, '\' #x5C, '^' #x5E ve '`' #x60) ve karakter numarası #x7F'den büyük karakterlerdir. Önceleme daima tamamen geri alınabilir bir işlem olmadığından, sadece mutlak gereklilik halinde ve işlem zincirinin olası en son halkalarında uygulanmalıdır <rfc2119>ZORUNLU</rfc2119>. Özellikle ne bir göreli tanım yerini mutlak olanına dönüştürme işlemi ne de bir tanım-yeri başvurusunu onu çözümleyecek bir sürece veya yazılıma aktarma işlemi öncelemeyi tetiklemelidir <rfc2119>ÖNERİ</rfc2119>. Önceleme varsa, şöyle uygulanmalıdır <rfc2119>ZORUNLU</rfc2119>:</p>

					<olist>
						<item>
							<p>Öncelenecek her karakter <bibref ref="Unicode"/> UTF-8 içinde bir veya daha fazla baytlı olacak şekilde ifade edilir.</p>
						</item>
						<item>
							<p>Elde edilen baytlar tanım-yeri önceleme mekanizması ile öncelenirler (yani, bayt değerinin onaltılık gösterimi HH, <code>%</code><var>HH</var>'a dönüştürülür).</p>
						</item>
						<item>
							<p>Özgün karakterin yerine bu işlem sonucunda elde edilen karakter yerleştirilir.</p>
						</item>
					</olist>

					<p><termdef id="dt-pubid" term="Genel Betimleyici">Bir harici betimleyici sistem betimleyiciye ek olarak bir <term>genel betimleyici</term> içerebilir</termdef>. Öğenin içeriğini getirmeye çalışan bir XML işlemci, bir alternatif tarım-yeri başvurusu üretmeyi denemek için bu belirtimin kapsamı dışındaki ek bilgi kaynaklarına ilaveten sistem ve genel betimleyicilerinin herhangi bir birleşimini kullanabilir. Eğer işlemci bunu yapamıyorsa, sistem dizgesel sabitinde belirtilen tanım-yeri başvurusunu kullanmalıdır <rfc2119>ZORUNLU</rfc2119>. Bir eşleşme sağlanmaya çalışılmadan önce, genel betimleyici içindeki boşluk karakterlerinden oluşan dizgelerin tümü tek boşluk karakteriyle (#x20) normalleştirilmeli <rfc2119>ZORUNLU</rfc2119>; baştaki ve sondaki boşluk karakterleri silinmelidir <rfc2119>ZORUNLU</rfc2119>.</p>

					<p>Harici öge bildirimleri örnekleri:</p>
					<eg>&lt;!ENTITY open-hatch
         SYSTEM "http://www.textuality.com/boilerplate/OpenHatch.xml"&gt;
&lt;!ENTITY open-hatch
         PUBLIC "-//Textuality//TEXT Standard open-hatch boilerplate//EN"
         "http://www.textuality.com/boilerplate/OpenHatch.xml"&gt;
&lt;!ENTITY hatch-pic
         SYSTEM "../grafix/OpenHatch.gif"
         NDATA gif &gt;</eg>
				</div3>
			</div2>

			<div2 id="TextEntities">
				<head>Çözümlü Öğeler</head>
				<div3 id="sec-TextDecl">
					<head>Metin Bildirimi</head>
					<p>Harici çözümlü öğelerin her birinin bir <term>metin bildirimi</term> ile başlaması <rfc2119>ÖNERİ</rfc2119>lir.</p>

					<scrap>
						<head>Metin Bildirimi</head>
						<prodgroup pcw4="12.5" pcw5="13">
							<prod id="NT-TextDecl" num="77">
								<lhs>MetinBild</lhs>
								<rhs>'&lt;?xml' <nt def="NT-VersionInfo">SürümBilgisi</nt>? <nt def="NT-EncodingDecl">KodlamaBild</nt>
									<nt def="NT-S">B</nt>? '?>'</rhs>
							</prod>
						</prodgroup>
					</scrap>
					<p>Metin bildirimi birebir sağlanmış olmalı <rfc2119>ZORUNLU</rfc2119>, bir çözümlü öğeye gönderim olmamalıdır. Metin bildirimi bir harici çözümlü öğenin başlangıcından başka bir yerde gözükemez <rfc2119>ZORUNLU</rfc2119>. Bir harici çözümlü öğedeki bir metin bildirimi öğenin <termref def="dt-repltext">ikame metni</termref>nin parçası olarak ele alınmaz.</p>
				</div3>

				<div3 id="wf-entities">
					<head>İyi Biçimli Çözümlü Öğeler</head>
					<p>Bir belge öğesi <nt def="NT-document">belge</nt> sözdizimi tanımı ile eşleşiyorsa iyi biçimlidir. Bir harici genel çözümlü öğe <nt def="NT-extParsedEnt">dışÇözümlüÖğe</nt> sözdizimi tanımı ile eşleşiyorsa iyi biçimlidir. Harici parametre öğelerinin tümü tanımları gereği iyi biçimlidir.</p>
					<note>
							<p>Belge içinden sadece doğrudan veya dolaylı atıf yapılan çözümlü öğelerin iyi biçimli olmaları gerekir.</p>
					</note>

					<scrap>
						<head>İyi Biçimli Harici Çözümlü Öğe</head>
						<prod id="NT-extParsedEnt" num="78">
							<lhs>dışÇözümlüÖğe</lhs>
							<rhs>(<nt def="NT-TextDecl">MetinBild</nt>?
              <nt def="NT-content">içerik</nt> -
              (<nt def="NT-Char">Kark</nt>*
              <nt def="NT-RestrictedChar">SınırlıKark</nt>
              <nt def="NT-Char">Kark</nt>*)</rhs>
						</prod>
					</scrap>
					<p>Bir harici genel çözümlü öğe, eğer ikame metni <nt def="NT-content">içerik</nt> sözdizimi tanımı ile eşleşiyorsa iyi biçimlidir. Dahili parametre öğelerinin tümü tanımları gereği iyi biçimlidir.</p>

					<p>Genel öğelerdeki iyi biçimliliğin bir sonucu, bir XML belgedeki mantıksal ve fiziksel yapıların düzgün şekilde iç içe olmasıdır; hiçbir <termref def="dt-stag">başlangıç etiketi</termref>, <termref def="dt-etag">bitiş etiketi</termref>, <termref def="dt-empty">boş eleman etiketi</termref>, <termref def="dt-element">eleman</termref>, <termref def="dt-comment">açıklama</termref>, <termref def="dt-pi">işlem yönergesi</termref>, <termref def="dt-charref">karakter gönderimi</termref> veya <termref def="dt-entref">öğe gönderimi</termref> bir öğede başlayıp bir diğerinde bitemez.</p>
				</div3>

				<div3 id="charencoding">
					<head>Öğelerdeki Karakter Kodlaması</head>
					<p>Bir XML belgedeki her harici çözümlü öğe kendi karakterleri için farklı bir karakter kodlaması kullanabilir. Tüm XML işlemcilerin UTF-8 ve UTF-16 kodlamalı öğeleri okuyabilmesi <rfc2119>ZORUNLU</rfc2119>dur. Bu belirtimdeki <quote>UTF-8</quote> ve <quote>UTF-16</quote> terimleri, kodlamalar ve yaftalar UTF-8 veya UTF-16'ya benzese bile, başka yaftalı karakter kodlamalarına uygulanmaz.</p>

					<p>UTF-16 kodlu öğeler <rfc2119>ZORUNLU</rfc2119> olarak, UTF-8 kodlu öğeler <rfc2119>SEÇİMLİK</rfc2119> olarak, ISO/IEC 10646 <bibref ref="ISO10646"/> veya Unicode <bibref ref="Unicode"/>'da açıklandığı gibi Bayt Sıralama İmi (SIFIR GENİŞLİKTE BOŞLUK GİBİ BOŞLUK karakteri, #xFEFF) ile başlamalıdır. Bu bir kodlama imzasıdır, XML belgenin karakter verisinin veya imleniminin bir parçası değildir. XML işlemciler bu karakteri UTF-8 ve UTF-16 kodlu belgeler arasında ayrım yapabilmek için kullanmalıdırlar <rfc2119>ZORUNLU</rfc2119>.</p>

					<p>Bir XML işlemcinin sadece UTF-8 ve UTF-16 kodlamalara sahip öğeleri okuması zorunlu olsa da, dünya çapında kullanılan diğer kodlamaları da tanıması ve bunları kullanan öğeleri de okuması istenebilir. Harici karakter kodlaması bilgisinin (örn, MIME başlıklarında) yokluğunda, UTF-8 veya UTF-16 dışında bir kodlamayla saklanmış çözümlü öğelerin bir kodlama bildirimi içeren bir metin bildirimi ile başlaması <rfc2119>ZORUNLU</rfc2119>dur (bkz, <specref ref="sec-TextDecl"/>):</p>

					<scrap>
						<head>Kodlama Bildirimi</head>
						<prod id="NT-EncodingDecl" num="80">
							<lhs>KodlamaBild</lhs>
							<rhs>
								<nt def="NT-S">B</nt> 'encoding' <nt def="NT-Eq">Eşittir</nt>
('"' <nt def="NT-EncName">KodlamaAdı</nt> '"' | "'" <nt def="NT-EncName">KodlamaAdı</nt>
"'" ) </rhs>
						</prod>
						<prod id="NT-EncName" num="81">
							<lhs>KodlamaAdı</lhs>
							<rhs>[A-Za-z] ([A-Za-z0-9._] | '-')*</rhs>
							<com>Kodlama adı sadece Latin karakterlerini içerir</com>
						</prod>
					</scrap>

					<p><termref def="dt-docent">Belge öğesi</termref>nde, kodlama bildirimi <termref def="dt-xmldecl">XML bildirimi</termref>nin parçasıdır. <nt def="NT-EncName">KodlamaAdı</nt> kullanılan kodlamanın adıdır.</p>
					<!-- FINAL EDIT: check name of IANA and charset names -->
					<p>Bir kodlama bildiriminde <quote><code>UTF-8</code></quote>, <quote><code>UTF-16</code></quote>, <quote><code>ISO-10646-UCS-2</code></quote> ve <quote><code>ISO-10646-UCS-4</code></quote> değerleri Unicode / ISO/IEC 10646'nın kodlama ve dönüşüm çeşitleri için kullanılmalı <rfc2119>ÖNERİ</rfc2119>; <quote><code>ISO-8859-1</code></quote>, <quote><code>ISO-8859-2</code></quote>, ... <quote><code>ISO-8859-</code><var>n</var></quote> (burada <var>n</var> kısım numarasıdır) ISO 8859 kısımları için kullanılmalı <rfc2119>ÖNERİ</rfc2119> ve <quote><code>ISO-2022-JP</code></quote>, <quote><code>Shift_JIS</code></quote> ve <quote><code>EUC-JP</code></quote> değerleri de JIS X-0208-1997'nin çeşitli kodlamaları için kullanalmalıdır <rfc2119>ÖNERİ</rfc2119>. Burada listelenenlerin dışında kalan karakter kodlamalarından <bibref ref="IANA"/>'de (karakter kümesi olarak) kayıtlı olanlarına kayıtlı isimleri kullanılarak atıfta bulunulmalı <rfc2119>ÖNERİ</rfc2119>; bunların dışında kalan kodlamalara ise adları <quote>x-</quote> öneki ile başlatılarak atıfta bulunulmalıdır <rfc2119>ÖNERİ</rfc2119>. XML işlemciler karakter kodlamalarını eşleştirirken harf büyüklüğüne duyarlı olmamalılar <rfc2119>ÖNERİ</rfc2119> ve IANA'da kayıtlı bir ismi IANA'da kayıtlı bir kodlama olarak yorumlamalı <rfc2119>ÖNERİ</rfc2119> veya bilinmeyen olarak ele almalıdır <rfc2119>ÖNERİ</rfc2119> (şüphesiz, XML işlemcilerin IANA'ya kayıtlı tüm kodlamaları desteklemesi gerekmez).</p>

					<p>Bir harici aktarım protokolü (örn, HTTP veya MIME) tarafından sağlanan bilginin yokluğunda, bir öğe, bildirimdeki isimden başka bir kodlamayla XML işlemciye sunulmuşsa veya ne Bayt Sıralama İmi ne de UTF-8 dışında bir kodlama için kullanılacak kodlama bildirimi olması bir öğe için <termref def="dt-fatal">ölümcül hata</termref>dır. ASCII, UTF-8'in bir altkümesi olduğundan sıradan ASCII öğelerin bir kodlama bildirimine kesinlikle ihtiyaç duymayacaklarına dikkat ediniz.</p>

					<p>Bir <nt def="NT-TextDecl">MetinBild</nt>iriminin bir harici öğenin başlangıcından farklı bir yerde bulunması <termref def="dt-fatal">ölümcül hata</termref>dır.</p>

					<p>XML işlemci bir öğenin işlenmeye elverişli olmayan bir kodlamaya sahip olduğunu saptarsa bu bir <termref def="dt-fatal">ölümcül hata</termref>dır. Eğer bir XML öğenin belli bir kodlamaya sahip olduğu saptandığı (öntanımlı olarak, kodlama bildirimi veya daha yüksek seviyeli bir protokol üzerinden) halde içeriğinde bu kodlamaya uygun olmayan bayt dizilimleri mevcutsa bu bir <termref def="dt-fatal">ölümcül hata</termref>dır. Özellikle, UTF-8 kodlanmış bir öğe içeriğinde Unicode'da <bibref ref="Unicode"/> tanımlandığı gibi düzensiz kod dizilimleri varsa bu bir <termref def="dt-fatal">ölümcül hata</termref>dır. Daha yüksek seviyeli bir protokol tarafından bir kodlama saptanmış olmadıkça, XML öğesi hiçbir kodlama bildirimi içermediği halde içeriği UTF-8 veya UTF-16 için uygun değilse bu da bir <termref def="dt-fatal">ölümcül hata</termref>dır.</p>

					<p>Kodlama bildirimleri içeren metin bildirimi örnekleri:</p>
					<eg>&lt;?xml encoding='UTF-8'?&gt;
&lt;?xml encoding='EUC-JP'?&gt;</eg>
				</div3>
        <div3 id="sec-version-info">
          <head>Öğelerdeki Sürüm Bilgisi</head>
          <p><termref def="dt-docent">Belge öğesi</termref> dahil, her öğe ayrı ayrı XML 1.0 veya XML 1.1 olarak bildirilebilir. Belge öğesinde yer alan sürüm bildirimi, belgenin bütünü içindir. Bir XML 1.1 belge XML 1.0 harici öğelerini çağırabilir, böylece sürümleri yinelenmediği sürece harici öğeler özellikle DTD altkümeleri elden geçirilmeyi gerektirmez. Yine de böyle bir durumda belgenin tamamına XML 1.1 kuralları uygulanır.</p>
          <p><termref def="dt-docent">Belge öğesi</termref> dahil, bir öğe, bir sürüm bilgisi belirtilmedikçe 1.0 sürümü bir öğe olarak ele alınır.</p>
        </div3>
			</div2>

			<div2 id="entproc">
				<head>Öğelerin ve Gönderimlerin XML İşlemcide Ele Alınışları</head>
				<p>Aşağıdaki liste, karakter ve öğe gönderimleri ve çözümlenmemiş öğe çağrıları bağlamında, hangi durumda <termref def="dt-xml-proc">XML işlemci</termref>nin nasıl davranmasının  <rfc2119>ZORUNLU</rfc2119> olduğunu özetler. Soldaki başlıklar tanınma şeklini belirtir:</p>

       <glist>
				<gitem>
					<label>İçerikte gönderim</label>
					<def><p>bir elemanın <termref def="dt-stag">başlangıç etiketi</termref> ile <termref def="dt-etag">bitiş etiketi</termref> arasındaki her yerde bir gönderim olarak; <nt def="NT-content">içerik</nt> sözdizimine karşılıktır.</p>
          </def>
        </gitem>
        <gitem>
          <label>Öznitelik değeri içinde gönderim</label>
          <def><p><termref def="dt-stag">başlangıç etiketi</termref>ndeki bir özniteliğin değeri veya bir <termref def="dt-attdecl">öznitelik bildirimi</termref>ndeki bir öntanımlı değer içinde bir gönderim olarak; <nt def="NT-AttValue">ÖznitDeğeri</nt> sözdizimine karşılıktır.</p>
          </def>
        </gitem>
        <gitem>
          <label>Öznitelik değeri içinde gözükmek</label>
          <def><p><kw>ENTITY</kw> türünde bildirilmiş bir özniteliğin değeri olarak veya <kw>ENTITIES</kw> türünde bildirilmiş bir özniteliğin değerinde boşluklarla ayrılmış dizgeciklerden biri olarak gözüktüğünde bir gönderim değil bir <nt def="NT-Name">Ad</nt> olarak.</p>
          </def>
        </gitem>
        <gitem>
          <label>Öğe değeri içinde gönderim</label>
          <def><p>öğe bildiriminde dahili öğenin <termref def="dt-litentval">dizgesel sabitli öğe değeri</termref> içinde veya bir parametre içinde bir gönderim olarak; <nt def="NT-EntityValue">ÖğeDeğeri</nt> sözdizimine karşılıktır.</p>
          </def>
        </gitem>
        <gitem>
          <label>DTD içinde gönderim</label>
          <def><p><termref def="dt-doctype">DTD</termref>'nin dahili veya harici altkümelerinde fakat bir <nt def="NT-EntityValue">ÖğeDeğeri</nt>, <nt def="NT-AttValue">ÖznitDeğeri</nt>, <nt def="NT-PI">PI</nt>, <nt def="NT-Comment">Açıklama</nt>, <nt def="NT-SystemLiteral">SistemSabiti</nt>, <nt def="NT-PubidLiteral">GenidSabiti</nt> veya yoksayılan bir şart bölümünün içeriğinde yer almamak şartıyla bir gönderim olarak (bkz, <specref ref="sec-condition-sect"/>).</p>
          </def>
        </gitem>
      </glist>

      <table border="1" frame="border" cellpadding="7" summary="Öğe türü/gönderimi tablosu">
        <tbody align="center">
          <tr>
            <td rowspan="2" colspan="1"/>
            <td colspan="4" align="center" valign="bottom">Öğe türü</td>
            <td rowspan="2" align="center">Karakter</td>
          </tr>
          <tr align="center" valign="bottom">
            <td>Parametre</td>
            <td>Dahili Genel</td>
            <td>Harici Çözümlü Genel</td>
            <td>Çözümlenmemiş</td>
          </tr>
          <tr align="center" valign="middle">
          <td align="right">İçerikte gönderim</td>
            <td>
              <titleref href="#not-recognized">Tanınmaz</titleref>
            </td>
            <td>
              <titleref href="#included">İçerilir</titleref>
            </td>
            <td>
              <titleref href="#include-if-valid">Geçerliyse İçerilir</titleref>
            </td>
            <td>
              <titleref href="#forbidden">Yasak</titleref>
            </td>
            <td>
              <titleref href="#included">İçerilir</titleref>
            </td>
          </tr>
          <tr align="center" valign="middle">
            <td align="right">Öznitelik değeri içinde gönderim</td>
            <td>
              <titleref href="#not-recognized">Tanınmaz</titleref>
            </td>
            <td>
              <titleref href="#inliteral">Dizgesel Sabitte İçerilir</titleref>
            </td>
            <td>
              <titleref href="#forbidden">Yasak</titleref>
            </td>
            <td>
              <titleref href="#forbidden">Yasak</titleref>
            </td>
            <td>
              <titleref href="#included">İçerilir</titleref>
            </td>
          </tr>
          <tr align="center" valign="middle">
            <td align="right">Öznitelik değeri içinde gözükmek</td>
            <td>
              <titleref href="#not-recognized">Tanınmaz</titleref>
            </td>
            <td>
              <titleref href="#forbidden">Yasak</titleref>
            </td>
            <td>
              <titleref href="#forbidden">Yasak</titleref>
            </td>
            <td>
              <titleref href="#notify">Uyarı</titleref>
            </td>
            <td>
              <titleref href="#not-recognized">Tanınmaz</titleref>
            </td>
          </tr>
          <tr align="center" valign="middle">
            <td align="right">Öğe değeri içinde gönderim</td>
            <td>
              <titleref href="#inliteral">Dizgesel Sabitte İçerilir</titleref>
            </td>
            <td>
              <titleref href="#bypass">Atlanır</titleref>
            </td>
            <td>
              <titleref href="#bypass">Atlanır</titleref>
            </td>
            <td>
              <titleref href="#error">Hata</titleref>
            </td>
            <td>
              <titleref href="#included">İçerilir</titleref>
            </td>
          </tr>
          <tr align="center" valign="middle">
            <td align="right">DTD içinde gönderim</td>
            <td>
              <titleref href="#as-PE">Parametre Öğesi olarak İçerilir</titleref>
            </td>
            <td>
              <titleref href="#forbidden">Yasak</titleref>
            </td>
            <td>
              <titleref href="#forbidden">Yasak</titleref>
            </td>
            <td>
              <titleref href="#forbidden">Yasak</titleref>
            </td>
            <td>
              <titleref href="#forbidden">Yasak</titleref>
            </td>
          </tr>
        </tbody>
      </table>

      <div3 id="not-recognized">
        <head>Tanınmaz</head>
        <p>DTD dışında <code>%</code> karakterinin özel bir anlamı yoktur; bu bakımdan parametre öğesi gönderimleri <nt def="NT-content">içerik</nt> içinde imlenim olarak tanınmaz. Benzer şekilde, çözümlenmemiş öğelerin isimleri de uygun şekilde bildirilmiş bir öznitelik değerinde gözükmesi dışında tanınmazlar.</p>
				</div3>

      <div3 id="included">
        <head>İçerilir</head>
        <p><termdef id="dt-include" term="İçerilir">Bir öğe, kendisine yapılan gönderimin tanındığı noktada ikame metni alınıp işlendiğinde içerilmiş olur.</termdef> İkame metni, uygun şekilde tanınması <rfc2119>ZORUNLU</rfc2119> olarak hem <termref def="dt-chardata">karakter verisi</termref> hem de <termref def="dt-markup">imlenim</termref> (parametre öğeleri için değil) içerebilir. (<quote><code>AT&amp;amp;T;</code></quote> dizgesi <quote><code>AT&amp;T;</code></quote> olarak yorumlanır ve dizge içinde kalan ve-imi bir öğe gönderim ayracı olarak tanınmaz.) Belirtilen karakter gönderimin olduğu yere yerleştirildiğinde bir karakter gönderimi içerilmiş olur.</p>
      </div3>

      <div3 id="include-if-valid">
        <head>Geçerliyse İçerilir</head>
        <p>Bir XML işlemci belgenin <termref def="dt-valid">geçerli</termref>liğini sınarken bir çözümlü öğe gönderimini tanıdığında, işlemcinin onun ikame metnini <termref def="dt-include">içermesi</termref> <rfc2119>ZORUNLU</rfc2119>dur.
        Eğer öğe harici bir öğeyse ve işlemci belgenin geçerliliğini sınamaya çalışmıyorsa, işlemci, öğenin ikame metnini içerebilir <rfc2119>SEÇİMLİK</rfc2119>, fakat bu gerekli değildir. Eğer geçerlilik sınaması yapmayan bir işlemci ikame metnini içermezse, öğeyi tanıdığını ama onu okumadığını uygulamaya bildirmesi <rfc2119>ZORUNLU</rfc2119>dur.</p>

        <p>Bu kural, SGML ve XML öğe mekanizması tarafından sağlanan, başka uygulamalar, kısmen, belge tarama için uygun olması gerekmeyen, modülerliği özellikle yazım sırasında desteklemek için tasarlanmış, özdevinimli içerilme anlamındaki tanımaya dayanır. Tarayıcılar, örneğin,bir harici çözümlü öğe gönderimine rastladıklarında, öğenin varlığının görsel bir belirtisini sağlamayı seçebilirler ve talep halinde göstermek için bunu alabilirler.</p>
				</div3>

				<div3 id="forbidden">
					<head>Yasak</head>
					<p>Aşağıdakiler yasak olup <termref def="dt-fatal">ölümcül hata</termref>ya sebep olurlar:</p>
					<ulist>
						<item>
							<p>Bir öğe bildirimindeki <nt def="NT-EntityValue">ÖğeDeğeri</nt> içindekiler hariç, bir <termref def="dt-unparsed">çözümsüz öğe</termref>ye gönderiminin varlığı.</p>
						</item>
						<item>
							<p>Bir <nt def="NT-EntityValue">ÖğeDeğeri</nt> veya <nt def="NT-AttValue">ÖznitDeğeri</nt> içindekiler hariç DTD içinde bir karakter veya genel öğe gönderiminin varlığı.</p>
						</item>
						<item>
							<p>Bir öznitelik değeri içinde bir harici öğeye gönderim.</p>
						</item>
					</ulist>
				</div3>

				<div3 id="inliteral">
					<head>Dizgesel Sabitte İçerilir</head>
					<p>Bir <termref def="dt-entref">öğe gönderimi</termref> bir öznitelik değerinde veya bir parametre öğesi gönderimi bir dizgesel sabit öğesi değerinde gözüküyorsa, onun <termref def="dt-repltext">ikame metni</termref>nin, belge içinde gönderimin tanındığı yerde gönderimin yerine yerleştirilerek işlenmesi <rfc2119>ZORUNLU</rfc2119>dur (ikame metni içinde tek veya çift tırnak karakterlerinin daima bir normal veri karakteri olarak ele alınmasının <rfc2119>ZORUNLU</rfc2119> ve dizgesel sabiti sonlandırmamasının <rfc2119>ZORUNLU</rfc2119> olduğu durumlar hariç). Örneğin, bu iyi biçimliyken:</p>
					<eg><![CDATA[<!ENTITY % EH '"Evet"' >
<!ENTITY NeDedi "%EH; dedi" >]]></eg>
					<p>bu değildir:</p>
					<eg>&lt;!ENTITY SonNit "27'" &gt;
&lt;eleman nitelik='a-&amp;SonNit;&gt;</eg>
				</div3>

				<div3 id="notify">
					<head>Uyarı</head>
					<p>Bir <termref def="dt-unparsed">çözümlenmemiş öğe</termref> ismi <kw>ENTITY</kw> veya <kw>ENTITIES</kw> türünde bildirilmiş bir özniteliğin değerinde bir dizgecik olarak görünüyorsa, geçerlilik sınaması yapan bir işlemcinin uygulamayı hem öğe hem de onunla ilişkili <termref def="dt-notation">gösterim</termref> için <termref def="dt-sysid">sistem</termref> ve <termref def="dt-pubid">genel</termref> betimleyiciler bakımından bilgilendirmesi <rfc2119>ZORUNLU</rfc2119>dur.</p>
				</div3>

				<div3 id="bypass">
					<head>Atlanır</head>
					<p>Bir genel öğe gönderimi bir öğe bildiriminin <nt def="NT-EntityValue">ÖğeDeğeri</nt> içinde görünüyorsa, atlanmalı <rfc2119>ZORUNLU</rfc2119> ve olduğu gibi bırakılmalıdır.</p>
				</div3>

				<div3 id="as-PE">
					<head>Parametre Öğesi olarak İçerilir</head>
					<p>Harici çözümlü öğelerde olduğu gibi, parametre öğelerinin de sadece <titleref href="#include-if-valid">geçerliyse içerilmeleri</titleref> gerekir. Bir parametre öğesi gönderimi DTD'de tanınıp ve içerildiğinde, <termref def="dt-repltext">ikame metni</termref> başına ve sonuna birer boşluk karakteri (#x20) eklenerek genişletilmelidir <rfc2119>ZORUNLU</rfc2119>; amaç, parametre öğesinin ikame metnini DTD'deki sözdizimsel dizgeciklerden bütünleyici bir miktarı içermeye zorlamaktır. Bu davranış, öğe değerleri içindeki parametre öğesi gönderimlerine uygulanmamalıdır <rfc2119>ZORUNLU</rfc2119>; bunlar <specref ref="inliteral"/> bölümünde açıklanmıştır.</p>
				</div3>

				<div3 id="error">
					<head>Hata</head>
					<p>Bir öğe bildirimi içindeki <nt def="NT-EntityValue">ÖğeDeğeri</nt>nde görünecek bir çözümlenmemiş öğeye gönderim bir <termref def="dt-error">hatadır</termref>.</p>
				</div3>
			</div2>

			<div2 id="intern-replacement">
				<head>Öğe İkame Metninin Oluşturulması</head>
				<p>Öğelerin elde edilişi tartışılırken, öğe değerinin iki biçimini birbirinden ayrı ele almak daha yararlıdır. <termdef id="dt-litentval" term="Dahili dizgesel sabitli öğe değeri">Bir dahili öğe için, <term>dizgesel sabitli öğe değeri</term> aslında öğe bildiriminde yer alan ve <nt def="NT-EntityValue">ÖğeDeğeri</nt> sözdizimine karşı düşen tırnaklı bid dizgedir</termdef>.</p>

        <p><termdef id="dt-extlitentval" term="Harici dizgesel sabitli öğe değeri">Bir harici öğe için, <term>dizgesel sabitli öğe değeri</term> öğede içerilmiş metnin ta kendisidir</termdef>.</p>

        <p><termdef id="dt-repltext" term="Dahili Öğe İkame Metni">Bir dahili öğe için <term>ikame metni</term> karakter ve parametre öğesi gönderimleri yerine atıf yapılan değerleri yerleştirildikten sonraki öğe içeriğidir.</termdef></p>

        <p><termdef id="dt-extrepltext" term="Harici Öğe İkame Metni">Bir harici öğe için <term>ikame metni</term> öğenin eğer varsa metin bildirimi ayrıldıktan (çevresindeki boşluk karakterleri hariç) sonra, parametre öğesi ve karakter gönderimleri çözümlenmeksizin kalan içeriğidir.</termdef></p>

				<p>Dizgesel sabitli öğe değeri, bir dahili öğe bildiriminde verilmiş (<nt def="NT-EntityValue">ÖğeDeğeri</nt>) olarak, karakter, parametre öğesi ve genel öğe gönderimleri içerebilir. Böyle gönderimlerin dizgesel sabitli öğe değerinde tamamen içerilmiş olması <rfc2119>ZORUNLU</rfc2119>dur. Yukarıda açıklandığı gibi, <termref def="dt-include">içerilmiş</termref> (veya <termref def="inliteral">dizgesel sabitte içerilmiş</termref>) olan asıl ikame metninin, gönderim yapılan parametre öğelerinin ikame metnini ve gönderim yapılan karakteri içermesi <rfc2119>ZORUNLU</rfc2119>dur; bununla birlikte, genel öğe gönderimlerinin yorumlanmaksızın olduğu gibi bırakılmaları <rfc2119>ZORUNLU</rfc2119>dur. Örneğin, aşağıda belirtilen bildirimleri ele alalım:</p>

				<eg><![CDATA[<!ENTITY % pub    "&#xc9;ditions Gallimard" >
<!ENTITY   rights "All rights reserved" >
<!ENTITY   book   "La Peste: Albert Camus,
&#xA9; 1947 %pub;. &rights;" >]]></eg>

				<p><quote><code>book</code></quote> öğesi için ikame metni:</p>

				<eg>La Peste: Albert Camus,
© 1947 Éditions Gallimard. &amp;rights;</eg>

				<p>Genel öğe gönderimi <quote><code>&amp;rights;</code></quote>, <quote><code>&amp;book;</code></quote> gönderimi belge içeriğinde veya bir öznitelik değerinde yer aldığında yorumlanacaktır.</p>

				<p>Bu basit kurallar, daha karmaşık etkileşimlere sahip olabilirler; daha zor bir örneğin açıklaması için <specref ref="sec-entexpand"/> bölümüne bakınız.</p>
			</div2>

			<div2 id="sec-predefined-ent">
				<head>Önceden Tanımlanmış Öğeler</head>
				<p><termdef id="dt-escape" term="önceleme">Öğe ve karakter gönderimlerinin ikisi de açılı sol ayraç, ve-imi ve diğer ayraçları <term>önceleme</term>kte kullanılabilir. Genel öğeler kümesi (&magicents;) bu amaçla belirtilmiştir. Sayısal karakter gönderimleri de kullanılabilir; bunlar tanındıkları anda yorumlanırlar ve karakter verisi olarak ele alınırlar <rfc2119>ZORUNLU</rfc2119>, dolayısıyla karakter verisi içindeki <quote><code>&amp;#60;</code></quote> ve <quote><code>&amp;#38;</code></quote> sayısal karakter gönderimleri <code>&lt;</code> ve <code>&amp;</code> karakterlerini öncelemekte kullanılabilir.</termdef></p>

				<p>Tüm XML işlemcilerin bu öğeleri bildirilsin ya da bildirilmesin tanımaları <rfc2119>ZORUNLU</rfc2119>dur. <termref def="dt-interop">Birlikte çalışabilirlik için</termref>, geçerli XML belgelerin, diğerleri gibi onları kullanmadan önce bildirmeleri <rfc2119>ÖNERİ</rfc2119>lir. Eğer <code>lt</code> veya <code>amp</code> öğeleri bildirilecekse, bunların dahili öğeler (ikame metni öncelenmiş olarak ilgili karaktere bir karakter gönderimi olan) olarak bildirilmesi <rfc2119>ZORUNLU</rfc2119>dur; bu gönderimlerin iyi biçimli sonuçlar vermesi için bu öğelerin çifte öncelemeli olması <rfc2119>ZORUNLU</rfc2119>dur. Eğer <code>gt</code>, <code>apos</code> veya <code>quot</code> bildirilecekse, bunlar dahili öğeler (ikame metni öncelenmiş olarak tek karakter veya o karaktere bir karakter gönderimi olan) olarak bildirilmelidir <rfc2119>ZORUNLU</rfc2119>; çifte önceleme burada <rfc2119>SEÇİMLİK</rfc2119>tir, fakat bir soruna yol açmaz. Örnek:</p>
				<eg><![CDATA[<!ENTITY lt     "&#38;#60;">
<!ENTITY gt     "&#62;">
<!ENTITY amp    "&#38;#38;">
<!ENTITY apos   "&#39;">
<!ENTITY quot   "&#34;">]]></eg>
			</div2>

			<div2 id="Notations">
				<head>Gösterim Bildirimleri</head>
				<p><termdef id="dt-notation" term="Gösterim"><term>Gösterim</term>ler, <termref def="dt-unparsed">çözümlenmemiş öğe</termref> biçiminde, bir gösterim özniteliğine veya bir <termref def="dt-pi">işlem yönergesi</termref>nin adreslendiği uygulamaya dayanan elemanlar biçiminde, isimleriyle betimlenirler.</termdef></p>

				<p><termdef id="dt-notdecl" term="Gösterim Bildirimleri"><term>Gösterim bildirimleri</term> öğe ve öznitelik listesi bildirimlerinde ve öznitelik belirtimlerinde kullanmak için gösterime bir ad ve belirtilen gösterimdeki veriyi işlemeye yetkin bir yardımcı uygulamayı devreye sokabilecek bir XML işlemciye veya onun istemci uygulamasına  izin verebilen gösterim için bir harici betimleyici sağlar.</termdef></p>

				<scrap>
					<head>Gösterim Bildirimleri</head>
					<prod id="NT-NotationDecl" num="82">
						<lhs>GösterimBild</lhs>
						<rhs>'&lt;!NOTATION' <nt def="NT-S">B</nt>
							<nt def="NT-Name">Ad</nt>
							<nt def="NT-S">B</nt> (<nt def="NT-ExternalID">HariciID</nt> | <nt def="NT-PublicID">PublicID</nt>) <nt def="NT-S">B</nt>? '&gt;'</rhs>
						<vc def="UniqueNotationName"/>
					</prod>
					<prod id="NT-PublicID" num="83">
						<lhs>PublicID</lhs>
						<rhs>'PUBLIC' <nt def="NT-S">B</nt>
							<nt def="NT-PubidLiteral">GenidSabiti</nt>
						</rhs>
					</prod>
				</scrap>

				<vcnote id="UniqueNotationName">
					<head>Gösterim Adının Eşsizliği</head>
					<p>Belli bir <nt def="NT-Name">Ad</nt> birden fazla gösterimde bildirilemez <rfc2119>ZORUNLU</rfc2119>.</p>
				</vcnote>

				<p>XML işlemcilerin, bildirilmiş olan veya bir öğe bildirimine, bir öznitelik tanımına veya değerine atıfta bulunan bir gösterimin adıyla aynı veya gösterimin harici betimleyicisi olan dizgeyle aynı isimli uygulamalar sağlaması <rfc2119>ZORUNLU</rfc2119>dur. Bunlar ayrıca, harici betimleyicileri <termref def="dt-sysid">sistem betimleyici</termref>ye, dosya ismine, veya gösterimde açıklanan veri için bir XML işlemci çağıracak uygulamaya izin vermesi gereken başka bir bilgiye dönüştürülebilir <rfc2119>SEÇİMLİK</rfc2119>. (XML işlemcinin veya uygulamanın çalıştığı sistemde, XML belgenin bildirdiği veya atıfta bulunduğu gösterim için gösterime özel uygulamaların sistemde bulunmayışı bir hata değildir.)</p>
			</div2>

			<div2 id="sec-doc-entity">
				<head>Belge Öğesi</head>
				<p><termdef id="dt-docent" term="Belge Öğesi"><term>Belge öğesi</term>, öğe ağacının kökü ve bir <termref def="dt-xml-proc">XML işlemci</termref> için başlangıç noktası olarak hizmet verir</termdef>. Bu belirtim belge öğesinin bir XML işlemci tarafından nasıl bulunacağını belirtmez; diğer öğelerin aksine, belge öğesinin bir ismi yoktur ve herhangi bir betimleme olmaksızın bir işlemci girdi akımı üzerinde görünmesi daha iyi olur.</p>
			</div2>
		</div1>

		<!-- &Conformance; -->
		<div1 id="sec-conformance">
			<head>Uygunluk</head>

			<div2 id="proc-types">
				<head>Geçerliliği Sınayan ve Sınamayan İşlemciler</head>
				<p>Uyumlu <termref def="dt-xml-proc">XML işlemciler</termref> iki sınıfa ayrılırlar: geçerlilik sınaması yapanlar ve yapmayanlar.</p>

        <p>Geçerlik sınaması yapanların da yapmayanların da <termref def="dt-docent">belge öğesi</termref>nin ve okunan diğer tüm <termref def="dt-parsedent">çözümlü öğe</termref>lerin içeriğinde, bu belirtimin iyi biçimlilik kurallarıyla çelişen herşeyi raporlamaları <rfc2119>ZORUNLU</rfc2119>dur.</p>

				<p><termdef id="dt-validating" term="Geçerliliği Sınayan İşlemciler"><term>Geçerliliği sınayan işlemciler</term>in seçim kullanıcının olmak üzere, <termref def="dt-doctype">DTD</termref>'de bildirimler tarafından ifade edilen kurallarla çelişenleri ve bu belirtimde belirtilen geçerlilik kurallarını yerine getirmekteki başarısızlıkları raporlaması <rfc2119>ZORUNLU</rfc2119>dur</termdef>. Bunun üstesinden gelmek için, geçerlilik sınaması yapan XML işlemcilerin DTD'nin tamamını ve belgede atıf yapılan tüm harici çözümlü öğeleri okuyup işlemesi <rfc2119>ZORUNLU</rfc2119>dur.</p>

				<p>Geçerliliği sınamayan XML işlemcilerin, sadece iyi biçimlilik için dahili DTD altkümesinin tamamını içeren <termref def="dt-docent">belge öğesi</termref>ni sınamaları gerekir <rfc2119>ZORUNLU</rfc2119>. <termdef id="dt-use-mdecl" term="Bildirimler İşlenmelidir">Belgenin geçerliliğini sınamak için gerekli olmasa da, <emph>okumadıkları</emph> ilk parametre öğesi gönderimine kadar okudukları her parametre öğesinde ve dahili DTD altkümesinde okudukları tüm bildirimleri işlemeleri <rfc2119>ZORUNLU</rfc2119>dur; başka bir deyişle, bu bildirimlerdeki bilgiyi, öznitelik değerlerini <titleref href="#AVNormalize">normalleştirmek</titleref> için, dahili öğelerin ikame metnini <titleref href="#included">içermek</titleref> için ve <titleref href="#sec-attr-defaults">öntanımlı öznitelik değerleri</titleref>ni sağlamak için kullanmaları <rfc2119>ZORUNLU</rfc2119>dur</termdef>. <code>standalone="yes"</code> durumu hariç, öğe, bildirimlerin yerini almak üzere bildirilmiş olabileceğinden, okunmamış bir parametre öğesine bir gönderimden sonra,  rastlanan <termref def="dt-attdecl">öznitelik listesi bildirimleri</termref>ni veya <termref def="dt-entdecl">öğe bildirimleri</termref>ni <termref def="dt-use-mdecl">işlememeleri</termref> gerekir <rfc2119>ZORUNLU</rfc2119>; <code>standalone="yes"</code> durumunda, işlemcilerin bu bildirimleri işlemeleri <rfc2119>ZORUNLU</rfc2119>dur.</p>

				<p>Geçersiz belgeleri geçerliliği sınamayan bir işlemci ile işlerken uygulamanın tutarlı bilgi vermeyebileceğine dikkat ediniz. Örneğin, belge içinde eşsizlikle ilgili çeşitli gereksinimler (aynı ID'ye sahip birden fazla elemanın varlığı, yinelenmiş eleman bildirimleri veya aynı isimli gösterimler gibi) sağlanmıyor olabilir. Bu gibi durumlarda,   çözümleyicinin böyle bilgileri uygulamaya raporlamak konusundaki davranışı belirsizdir.</p>

        <p>XML 1.1 işlemcilerin hem XML 1.0 hem de XML 1.1 belgeleri işleyebilmeleri gerekir <rfc2119>ZORUNLU</rfc2119>. XML üreten programların belli bir özellik XML 1.1'i gerektirmedikçe XML 1.0 üretmeleri <rfc2119>ÖNERİ</rfc2119>lir.</p>
			</div2>

			<div2 id="safe-behavior">
				<head>XML İşlemcilerin Kullanımı</head>
				<p>Geçerliliği sınayan bir XML işlemcinin davranışı oldukça öngörülebilir bir davranıştır; belgenin her parçasını okuması ve tüm iyi biçimlilik ve geçerlilik uyumsuzluklarını raporlaması gerekir. Geçerliliği sınamayan bir XML işlemci için daha azı gerekir; belgenin belge öğesi hariç hiçbir parçasını okuması gerekmez. Bu, XML işlemcilerin kullanıcıları açısından önemli olabilecek iki etkiye sahiptir:</p>
				<ulist>
					<item>
						<p>Belli başlı iyi biçimlilik hataları, özellikle harici öğelerin okunmasını gerektirenler, geçerlilik sınaması yapmayan işlemciler tarafından saptanamayabilir. <titleref href="#wf-entdeclared">Öğe Bildirilmeli</titleref>, <titleref href="#textent">Çözümlü Öğe</titleref> ve <titleref href="#norecursion">Özyineleme Yapılmamalı</titleref> başlıklı kuralları içerenler yanında <specref ref="entproc"/> bölümünde <titleref href="#forbidden">yasak</titleref> olarak açıklanan durumların bazıları örnek olarak verilebilir.</p>
					</item>
					<item>
						<p>İşlemciden uygulamaya aktarılan bilgi, işlemcinin parametre ve harici öğeleri okuyup okumamasına bağlı olarak değişebilir. Örneğin geçerlilik sınaması yapmayan bir işlemci, harici veya parametre öğelerindeki bildirimlerin okunmasına/okunmamasına bağlı olarak, öznitelik değerlerini <titleref href="#AVNormalize">normalleştirme</titleref>de, dahili öğelerin ikame metnini <titleref href="#included">içerme</titleref>de ve <titleref href="#sec-attr-defaults">öntanımlı öznitelik değerleri</titleref>ni sağlamada başarısız olabilir.</p>
					</item>
				</ulist>
				<p>Farklı XML işlemciler arasında birlikte çalışabilirlik bakımından azami güvenilirlik için, geçerlilik sınaması yapmayan işlemcileri kullanan uygulamaların böyle işlemcilerin gerekli olmayan davranışlarına güvenmemeleri  <rfc2119>ÖNERİ</rfc2119>lir. Geçerlilikle ilgili olmayan DTD oluşumlarını (öntanımlı özniteliklerin bildirimi ve harici öğelerde belirtilmesi olası dahili öğeler gibi) gerektiren uygulamaların geçerlilik sınaması yapan XML işlemcileri kullanmaları <rfc2119>ÖNERİ</rfc2119>lir.</p>
			</div2>
		</div1>

		<div1 id="sec-notation">
			<head>Gösterim</head>
			<p>XML'nin biçimsel dilbilgisi kuralları bu belirtimde Eklentili Backus-Naur Biçiminin (EBNF)  basit bir gösterimi kullanılarak belirtilmiştir. Her dilbilgisi kuralı,</p>
			<eg>sembol ::= ifade</eg>
			<p>şeklinde bir sembolle tanımlanır. Sembol bir düzenli dil başlangıç sembolü ise büyük harfle başlar, yoksa küçük harfle başlar. Dizgesel sabitler tırnak içine alınır.</p>
			<p>Kuralın sağ tarafında bulunan ifade içinde dizgeleri bir veya daha fazla karakterle eşleştirmek için şu ifadeler kullanılmıştır:</p>
       <glist>
					<gitem>
						<label>
							<code>#xN</code>
						</label>
						<def>
							<p>Burada <code>N</code> bir onaltılık tamsayı olup ifade,  ISO/IEC 10646'daki karakter numarası <code>N</code> olan karakter ile eşleşir. <code>#xN</code> içindeki sıfırlardan soldakiler değersizdir.</p>
						</def>
					</gitem>
					<gitem>
						<label>
							<code>[a-zA-Z]</code>, <code>[#xN-#xN]</code>
						</label>
						<def>
							<p><nt def="NT-Char">Kark</nt>, belirtilen aralıktaki (sınırlar dahil) her değerle eşleşir.</p>
						</def>
					</gitem>
					<gitem>
						<label>
							<code>[abc]</code>, <code>[#xN#xN#xN]</code>
						</label>
						<def>
							<p><nt def="NT-Char">Kark</nt>, ifadede belirtilen değerlerle eşleşir. Bu gösterime köşeli ayraçlarla sınırlanarak aralıklar da dahil edilebilir.</p>
						</def>
					</gitem>
					<gitem>
						<label>
							<code>[^a-z]</code>, <code>[^#xN-#xN]</code>
						</label>
						<def>
							<p><nt def="NT-Char">Kark</nt>, belirtilen aralık (sınırlar dahil) <emph>dışında</emph> kalan her değerle eşleşir.</p>
						</def>
					</gitem>
					<gitem>
						<label>
							<code>[^abc]</code>, <code>[^#xN#xN#xN]</code>
						</label>
						<def>
							<p><nt def="NT-Char">Kark</nt>, ifadede belirtilen değerler dışında kalan değerlerle eşleşir. Bu gösterime köşeli ayraçlarla sınırlanarak yasaklanacak aralıklar da dahil edilebilir.</p>
						</def>
					</gitem>
					<gitem>
						<label>
							<code>"dizge"</code>
						</label>
						<def>
							<p>çift tırnaklar arasında verilen dizgesel sabit ile <termref def="dt-match">eşleşilir</termref>.</p>
						</def>
					</gitem>
					<gitem>
						<label>
							<code>'dizge'</code>
						</label>
						<def>
							<p>tek tırnaklar arasında verilen dizgesel sabit ile <termref def="dt-match">eşleşilir</termref>.</p>
						</def>
					</gitem>
				</glist>

        <p>Bu semboller, daha karmaşık örüntülerle eşleşmek için birleştirilebilir; <code>A</code> ve <code>B</code> basit ifadeleri göstermek üzere:</p>
       <glist>
					<gitem>
						<label>(<code>ifade</code>)</label>
						<def>
							<p><code>ifade</code> tek birim olarak ele alınır ve bu listede açıklandığı gibi başka ifadelerle birleşebilir.</p>
						</def>
					</gitem>
					<gitem>
						<label>
							<code>A?</code>
						</label>
						<def>
							<p>ya <code>A</code> ya da hiçbir şey ile eşleşir; <code>A</code>'nın isteğe bağlı olduğu anlamına gelir.</p>
						</def>
					</gitem>
					<gitem>
						<label>
							<code>A B</code>
						</label>
						<def>
							<p><code>A</code> ve <code>A</code>'dan sonra gelen <code>B</code> ile eşleşir. Bu işleç yerdeğiştirmeli işleçten daha yüksek önceliğe sahiptir; bu nedenle, <code>A B | C D</code> ile <code>(A B) | (C D)</code> aynıdır.</p>
						</def>
					</gitem>
					<gitem>
						<label>
							<code>A | B</code>
						</label>
						<def>
							<p><code>A</code> veya <code>B</code> ile eşleşilir.</p>
						</def>
					</gitem>
					<gitem>
						<label>
							<code>A - B</code>
						</label>
						<def>
							<p><code>B</code>'nin eksiltilmesi halinde <code>A</code> ile eşleşilir.</p>
						</def>
					</gitem>
					<gitem>
						<label>
							<code>A+</code>
						</label>
						<def>
							<p><code>A</code>'nın bir veya daha fazla örneği ile eşleşilir. Birleştirme, yerdeğiştirmeden daha yüksek önceliğe sahiptir; bu nedenle, <code>A+ | B+</code> ile <code>(A+) | (B+)</code> aynıdır.</p>
						</def>
					</gitem>
					<gitem>
						<label>
							<code>A*</code>
						</label>
						<def>
							<p><code>A</code>'nın sıfır veya daha fazla örneği ile eşleşilir. Birleştirme, yerdeğiştirmeden daha yüksek önceliğe sahiptir; bu nedenle, <code>A* | B*</code> ile <code>(A*) | (B*)</code> aynıdır.</p>
						</def>
					</gitem>
				</glist>
        <p>Sözdizimi tanımlarında kullanılan diğer gösterimler:</p>
        <glist>
					<gitem>
						<label>
							<code>/* ... */</code>
						</label>
						<def>
							<p>açıklama.</p>
						</def>
					</gitem>
					<gitem>
						<label>
							<code>[ İBK: ... ]</code>
						</label>
						<def>
							<p>İyi Biçimlilik Kuralı; bir sözdizimi tanımıyla ilişkili olarak <termref def="dt-wellformed">iyi biçimli</termref> belgelere uygulanacak bir kural ismini betimler.</p>
						</def>
					</gitem>
					<gitem>
						<label>
							<code>[ GK: ... ]</code>
						</label>
						<def>
							<p>Geçerlilik Kuralı; bir sözdizimi tanımıyla ilişkili olarak <termref def="dt-valid">geçerli</termref> belgelere uygulanacak bir kural ismini betimler.</p>
						</def>
					</gitem>
				</glist>
		 </div1>
	</body>
	<back>
		<!-- &SGML; -->
		<!-- &Biblio; -->
		<div1 id="sec-bibliography">
			<head>Kaynakça</head>
			<div2 id="sec-existing-stds">
				<head>Uyulması Gerekli Olanlar</head>
				<blist>
					<bibl id="IANA" href="http://www.iana.org/assignments/character-sets" key="IANA-KARKÜM">(Genel Ağ Atanmış Numaralar Yetkilisi) <titleref>Karakter Kümeleri için Resmi Adlar</titleref>, ed. Keld Simonsen.</bibl>

					<bibl id="rfc2119" href="http://belgeler.org/rfc/rfc2119.html" key="IETF RFC 2119">IETF. <titleref>RFC 2119: RFC'lerde Gereksinim Seviyelerini Belirtmek için Kullanılan Anahtar Sözcükler</titleref>. Scott Bradner, 1997. Uyulması zorunlu İngilizce sürümü http://www.rfc-editor.org/rfc/rfc2119.txt adresindedir.</bibl>

					<bibl id="RFC1766" href="http://www.ietf.org/rfc/rfc3066.txt" key="IETF RFC 3066">IETF. <titleref>RFC 3066: Dilleri Betimleyen Yaftalar</titleref>, ed. H. Alvestrand. 2001.</bibl>

					<bibl id="rfc3986" href="http://www.ietf.org/rfc/rfc3986.txt" key="IETF RFC 3986">IETF. <titleref>RFC 3986: Tektip Özkaynak Betimleyici (URI - Uniform Resource Identifier): Soysal Sözdizimi</titleref>. T. Berners-Lee, R. Fielding, L. Masinter. 2005.</bibl>

					<bibl id="ISO10646" key="ISO/IEC 10646">ISO (Uluslararası Standartlaşım Örgütü). <titleref>ISO/IEC 10646-1:2000. Bilgi teknolojileri &mdash; Evrensel Çok Sekizli Kodlanmış Karakter Kümesi (UCS - Universal Multiple-Octet Coded Character Set) &mdash; 1. Kısım: Mimari ve Temel Çokdilli Düzey</titleref>, zaman zaman eklemeler yapılmakta, yeni düzeltmelerle bunlar değiştirilmekte veya yeni parçalar eklenerek genişletilmektedir. (En son sürüm için <loc href="http://www.iso.ch"/> adresine bakınız.)</bibl>

          <bibl id="Unicode" key="Unicode">The Unicode Consortium. <emph>Unicode Standardı, Sürüm 4.0.</emph> Reading, Mass.: Addison-Wesley, 2003, yeni sürümleri yayınlanarak güncellenmektedir. (Unicode Karakter Veritabanı, son sürüm ve standardın sürümleri ile ilgili diğer bilgiler için <loc href="http://www.unicode.org/unicode/standard/versions"/> adresine bakınız).</bibl>

          <bibl id="XML1.0" href="../xml/" key="XML-1.0">W3C.  <titleref>Genişletilebilir İmlenim Dili (XML) 1.0 (Dördüncü Düzeltme)</titleref>, Tim Bray, Jean Paoli, C. M. Sperberg-McQueen, Eve Maler ve François Yergeau eds. W3C (World Wide Web Consortium), 16 Ağustos 2006. Uyulması zorunlu İngilizce sürümü &w3c;/TR/2006/REC-xml-20060816/ adresindedir.</bibl>

				</blist>
			</div2>
			<div2 id="null">
				<!--
ID made "null" to match its previous value in the First
Edition; it's odd, but if there's no set value, the stylesheet
currently generates an odd string that would be backwards
incompatible with any references anyone might have made before.
-->
				<head>Diğerleri</head>
				<blist>
					<bibl id="Aho" key="Aho/Ullman">Aho, Alfred V., Ravi Sethi ve Jeffrey D. Ullman. <titleref>Derleyiciler: Prensipler, Teknikler ve Araçlar</titleref>. Reading: Addison-Wesley, 1986, rpt. corr. 1988.</bibl>

					<bibl id="ABK" href="ftp://ftp.informatik.uni-freiburg.de/documents/papers/brueggem/habil.ps" key="Brüggemann-Klein">Brüggemann-Klein, Anne. <titleref>Belge İşlemede Biçimsel Modeller</titleref>. Habilitationsschrift. Freiburg Üniversitesi Matematik Fakültesi, 1993.</bibl>

					<bibl id="ABKDW" key="Brüggemann-Klein and Wood">Brüggemann-Klein, Anne ve Derick Wood. <titleref>Belirlenimci Düzenli Diller</titleref>. Freiburg Üniversitesi Bilişim Enstitüsü, Bericht 38, Oktober 1991. Extended abstract in A. Finkel, M. Jantzen, Hrsg., STACS 1992, S. 173-184. Springer-Verlag, Berlin 1992. Lecture Notes in Computer Science 577. Full version titled <titleref>One-Unambiguous Regular Languages</titleref> in Information and Computation 140 (2): 229-253, February 1998.</bibl>

          <bibl id="Charmod" href="http://www.w3.org/TR/2003/WD-charmod-20030822/" key="Charmod">W3C Çalışma Taslağı. <titleref>WWW 1.0 için Karakter Modeli</titleref>. Martin J. D&#xFC;rst, Fran&#xE7;ois Yergeau, Richard Ishida, Misha Wolf, Tex Texin.</bibl>

					<bibl id="Clark" href="&w3c;/TR/NOTE-sgml-xml-971215" key="Clark">James Clark. <titleref>SGML ile XML'ın Karşılaştırılması</titleref>.</bibl>

					<bibl id="IANA-LANGCODES" href="http://www.iana.org/assignments/language-tags" key="IANA-DİLKOD">(Genel Ağ Atanmış Numaralar Yetkilisi) <titleref>Dil Yaftaları Kütüğü</titleref>, ed. Keld Simonsen.</bibl>

					<bibl id="RFC2141" href="http://www.ietf.org/rfc/rfc2141.txt" key="IETF RFC 2141">IETF. <titleref>RFC 2141: URN Sözdizimi</titleref>, ed. R. Moats. 1997. </bibl>

					<bibl id="rfc2376" href="http://www.ietf.org/rfc/rfc3023.txt" key="IETF RFC 3023">IETF. <titleref>RFC 3023: XML Ortam Türleri</titleref>. eds. M. Murata, S. St.Laurent, D. Kohn. 2001.</bibl>

					<bibl id="rfc2781" href="http://www.ietf.org/rfc/rfc2781.txt" key="IETF RFC 2781">IETF. <titleref>RFC 2781: UTF-16, ISO 10646'nın bir kodlaması</titleref>, ed. P. Hoffman, F. Yergeau. 2000.</bibl>

					<bibl id="ISO639" key="ISO 639">(Uluslararası Standartlaşım Örgütü). <titleref>ISO 639:1988 (E). Dil isimlerinin gösterimi için kodlar.</titleref> [Geneva]: International Organization for Standardization, 1988.</bibl>

					<bibl id="ISO3166" key="ISO 3166">(Uluslararası Standartlaşım Örgütü). <titleref>ISO 3166-1:1997 (E). Ülkelerin ve alt bölümlerinin isimlerinin gösterimi için kodlar &mdash; 1. Kısım: Ülke kodları</titleref> [Geneva]: International Organization for Standardization, 1997.</bibl>

					<bibl id="ISO8879" key="ISO 8879">ISO (Uluslararası Standartlaşım Örgütü). <titleref>ISO 8879:1986(E). Bilgi işlem &mdash; Metin ve Büro Sistemleri &mdash; Standart Genelleştirilmiş İmlenim Dili (SGML).</titleref> İlk Düzenleme &mdash; 1986-10-15. [Geneva]: International Organization for Standardization, 1986. </bibl>

					<bibl id="ISO10744" key="ISO/IEC 10744">ISO (Uluslararası Standartlaşım Örgütü). <titleref>ISO/IEC 10744-1992 (E). Bilgi teknolojileri &mdash; Hiper Ortam/Zamana Dayalı Yapı Dili (HyTime). </titleref> [Geneva]: International Organization for Standardization, 1992. <emph>Extended Facilities Annexe.</emph> [Geneva]: International Organization for Standardization, 1996. </bibl>

					<bibl id="websgml" href="http://www.sgmlsource.com/8879/n0029.htm" key="WEBSGML">ISO (Uluslararası Standartlaşım Örgütü). <titleref>ISO 8879:1986 TC2. Bilgi teknolojileri &mdash; Belge Açıklama ve İşleme Dilleri</titleref>. [Geneva]: International Organization for Standardization, 1998.</bibl>

					<bibl id="xml-names" href="http://belgeler.org/recs/xml-names/" key="XML Adları">Tim Bray, Dave Hollander ve Andrew Layman. <titleref>XML 1.0'da İsim-alanları</titleref>. Textuality, Hewlett-Packard ve Microsoft. World Wide Web Consortium, 1999. Uyulması zorunlu İngilizce sürümü http://www.w3.org/TR/xml-names/ adresindedir.</bibl>
				</blist>
			</div2>
		</div1>
    <div1 id="sec-CharNorm">
      <head>Karakter Normalleştirme Tanımları</head>
      <p>Bu ek bölüm karakter normalleştirmesi ile ilgili tanımları içerir. Daha fazla temel bilgi ve örnekler için <bibref ref="Charmod"/> bölümüne bakınız.</p>

      <p><termdef term="Unicode kodlamalı" id="dt-Uni-encform">Bir metin eğer UTF-8, UTF-16 veya UTF-32 kodlamalı ise bu metinden <term>Unicode kodlamalı</term> olarak bahsedilir.</termdef></p>

      <p><termdef term="Kadim kodlamalı" id="dt-legacyenc"><term>Kadim kodlama</term> Unicode'a dayalı olmayan karakter kodlaması anlamındadır.</termdef></p>

      <p><termdef term="Normalleştiren dönüştürücü" id="dt-normtransc">Bir <term>normalleştiren dönüştürücü</term> bir <termref def="dt-legacyenc">kadim kodlamalı</termref> belgeyi bir <termref def="dt-Uni-encform">Unicode kodlamalı</termref> belgeye dönüştürür ve sonucun Unicode Normalleştirme Biçimi C'ye uygun olmasını sağlar (<bibref ref="Unicode"/> UAX #15'e bakınız).</termdef></p>

      <p><termdef term="Karakter öncelemi" id="dt-charesc">Bir <term>karakter öncelemi</term> bir imlenim veya programlama dilinde tanımlı sözdizimsel bir araç olup şunların biri veya bir kaçını mümkün kılar:</termdef></p>

      <olist>
        <item>
          <p>Sözdizimsel öneme sahip karakterlerin dilin sözdizimi içinde sözdizimsel önemini yitirmesini sağlayacak şekilde ifade edilmesi.</p>
        </item>
        <item>
          <p>Dilin bir gerçeklenimi için seçilen kodlamayla gösterilemeyen karakterlerin ifade edilmesi.</p>
        </item>
        <item>
          <p>Genel olarak karakterlerin karşılıkları olan karakter kodları kullanılmaksızın ifade edilmesi.</p>
        </item>
      </olist>
      <p><termdef term="Onaylı" id="dt-certified"><term>Onaylı</term> metin aşağıdaki durumlardan en az birine uyan metindir:</termdef>
      </p>
      <olist>
        <item>
          <p>Metnin normalleştirilmiş biçimde olduğu sınanarak onaylanmıştır.</p>
        </item>
        <item>
          <p>Kaynak metin işleme bileşeninin sadece normalleştirilmiş metin ürettiği bilinmekte ve öyle tanınmaktadır.</p>
        </item>
      </olist>
      <p><termdef term="Unicode normalleştirmeli" id="dt-uninorm">Metin eğer <termref def="dt-Uni-encform">Unicode kodlamalı</termref> ise bu belirtimin amacına uygun olarak aynı zamanda <term>Unicode normalleştirmeli</term>dir. Böyle bir metin ayrıca, Unicode Standardının ilgili bir sürümünün Unicode Normalleştirme Biçimi C Ek #15'e uygundur: Metnin içinde bulunan karakterlerin hepsi Unicode Standardının 3.2'den daha eski olmayan olası en eski sürümündeki Unicode Normalleştirme Biçimlerindedir.</termdef></p>

      <p><termdef term="Dahili normalleştirmeli" id="dt-inclnorm">Metin şunları sağlıyorsa <term>dahili normalleştirmeli</term>dir:</termdef></p>

      <olist>
        <item>
          <p>Metin <termref def="dt-uninorm">Unicode normalleştirmeli</termref>dir ve herhangi bir <termref def="dt-charesc">karakter öncelemi</termref> veya yorumlandığında bir daha <termref def="dt-uninorm">Unicode normalleştirmeli</termref> olamayacak <termref def="dt-include">içerilenleri</termref> içermez.</p>
        </item>
        <item>
          <p>Metin <termref def="dt-legacyenc">kadim kodlamalı</termref>dır ve eğer bir <termref def="dt-normtransc">normalleştiren dönüştürücü</termref> tarafından <termref def="dt-Uni-encform">Unicode kodlamalı</termref> metne dönüştürülseydi sonuç üstteki 1. maddeyi yerine getirirdi.</p>
        </item>
      </olist>

      <p><termdef term="Aksan karakteri" id="dt-compchar">Bir <term>aksan karakteri</term> şunlardan biri veya birkaçıdır:</termdef></p>

      <olist>
        <item><p>İkinci karakter bir başat birleşimin kurallı oluşum eşlemindedir (<bibref ref="Unicode"/> UAX #15'in D3' of UAX #15ünde tanımlandığı gibi)</p>
        </item>
        <item>
          <p>sıfırıncı kurallı birleşim sınıfından değildir (<bibref ref="Unicode"/>'da tanımlandığı gibi).</p>
        </item>
      </olist>

      <p><termdef term="Tamamen normalleştirilmiş" id="dt-fullnorm">Bir metnin <term>tamamen normalleştirilmiş</term> olması için:</termdef></p>

      <olist>
        <item>
          <p>Metin <termref def="dt-Uni-encform">Unicode kodlamalı</termref> ve <termref def="dt-inclnorm">dahili normalleştirmeli</termref> olup dahili oluşumların hiçbiri bir <termref def="dt-compchar">aksan karakteri</termref> veya bir <termref def="dt-compchar">aksan karakteri</termref>ni gösteren bir karakter öncelemi ile başlayan bir metin içermez.</p>
        </item>
        <item>
          <p>Metin <termref def="dt-legacyenc">kadim kodlamalı</termref>dır ve eğer bir <termref def="dt-normtransc">normalleştiren dönüştürücü</termref> tarafından <termref def="dt-Uni-encform">Unicode kodlamalı</termref> metne dönüştürülseydi sonuç üstteki 1. maddeyi yerine getirirdi.</p>
        </item>
      </olist>
    </div1>

		<inform-div1 id="sec-entexpand">
			<head>Öğe ve Karakter gönderimlerinin Yorumlanması</head>
			<p>Bu ek bölümde, <specref ref="entproc"/> bölümünde belirtildiği gibi, öğe ve karakter gönderimlerinin tanınması ve yorumlanması ile ilgili örnekler bulunmaktadır.</p>

			<p>Eğer DTD</p>
			<eg><![CDATA[<!ENTITY example "<p>Bir ve-imi (&#38;#38;) sayısal olarak
                  (&#38;#38;#38;) veya bir genel öğe olarak
                  (&amp;amp;) gösterilebilir.</p>" >]]></eg>
			<p>diye bir öğe bildirimi içeriyorsa, XML işlemci öğe bildirimini çözümlerken karakter gönderimlerini tanıyıp çözümleyecek ve</p>
			<eg><![CDATA[<p>Bir ve-imi (&#38;) sayısal olarak
(&#38;#38;) veya bir genel öğe olarak
(&amp;amp;) gösterilebilir.</p>]]></eg>
			<p>dizgesini <quote><code>example</code></quote> öğesinin değeri olarak saklayacaktır. Belge içindeki <quote><code>&amp;example;</code></quote> şeklinde bir gönderim, <el>p</el> elemanının başlangıç ve bitiş etiketlerinin tanınıp dizgenin içindeki üç karakter gönderiminin tanınıp yorumlanarak metnin yeniden çözümlenmesine ve <el>p</el> elemanının aşağıdaki içerikle (ayraçlar ve imlenim olmaksızın verinin tümü) sonuçlanmasına sebep olacaktır:</p>
			<eg><![CDATA[Bir ve-imi (&) sayısal olarak
(&#38;) veya bir genel öğe olarak
(&amp;) gösterilebilir.]]></eg>
			<p>Daha karmaşık bir örnek kuralları ve etkilerini daha iyi görmemizi sağlayacaktır. Bu örnekte satırların başlarındaki numaralar kaynak koda dahil değildir:</p>

			<eg><![CDATA[1 <?xml version='1.]]>1<![CDATA['?>
2 <!DOCTYPE test [
3 <!ELEMENT test (#PCDATA) >
4 <!ENTITY % xx '&#37;zz;'>
5 <!ENTITY % zz '&#60;!ENTITY becerikli "hataya eğilimli" >' >
6 %xx;
7 ]>
8 <test>Bu örnek &becerikli; bir yöntemi göstermektedir.</test>]]></eg>

			<p>İşlemler şöyle yürür:</p>
			<ulist spacing="compact">
				<item>
					<p>4. satırda, 37. karaktere gönderim hemen yerine getirilir ve <quote><code>xx</code></quote> parametre öğesi sembol tablosunda <quote><code>%zz;</code></quote> değeri ile saklanır. İkame metin henüz taranmamış olduğundan <quote><code>zz</code></quote> parametre öğesine gönderim tanınmayacaktır.  (Ve <quote><code>zz</code></quote> henüz bildirilmemiş olacağından bir hata oluşacaktır.)</p>
				</item>
				<item>
					<p>5. satırda, <quote><code>&amp;#60;</code></quote> karakter gönderimi hemen yerine getirilir ve <quote><code>zz</code></quote> parametre öğesi iyi biçimli bir öğe bildirimi olan <quote><code>&lt;!ENTITY becerikli "hataya eğilimli"></code></quote> ikame metni ile saklanır.</p>
				</item>
				<item>
					<p>6. satırda, <quote><code>xx</code></quote> öğesine gönderim tanınır ve <quote><code>xx</code></quote> öğesinin ikame metni (yani, <quote><code>%zz;</code></quote>) çözümlenir. Ardından <quote><code>zz</code></quote> öğesine gönderim tanınır ve ikame metni (<quote><code>&lt;!ENTITY becerikli "hataya eğilimli"></code></quote>) çözümlenir.  <quote><code>becerikli</code></quote> genel öğesi bundan böyle <quote><code>hataya eğilimli</code></quote> ikame metni ile bildirilmiş olur.</p>
				</item>
				<item>
					<p>8. satırda <quote><code>becerikli</code></quote> genel öğesi tanınır ve yorumlanır. Böylece <el>test</el> elemanının içeriği kendini açıklayan <emph>Bu örnek hataya eğilimli bir yöntemi göstermektedir.</emph> dizgesi olur.
					</p>
				</item>
			</ulist>
		</inform-div1>

		<inform-div1 id="determinism">
			<head>Belirlenimci İçerik Modelleri</head>
			<p><specref ref="sec-element-content"/> bölümünde bahsedildiği gibi, eleman türü bildirimlerindeki içerik modellerinin belirlenimci olmaları gerekir. Bu gereksinim SGML ile <termref def="dt-compat">uyumluluk için</termref>dir (<quote>iki anlamlı olmayan</quote> belirlenimci içerik modellerine çağrılar); XML işlemciler, belirlenimci olmayan içerik modellerini hata olarak imleyebilen SGML sistemleri kullanılarak oluşturulabilirler.</p>

			<p>Örneğin, <code>((b, c) | (b, d))</code> içerik modeli belirlenimci değildir, çünkü <el>b</el> içerikte başta yer almak üzere verildiğinden, XML işlemci modeldeki hangi <el>b</el>'yi eşleştireceğini <el>b</el>'i, izleyen elemanı görmek için başa bakmadan anlayamaz. Bu durumda, iki <el>b</el> gönderimi modeli <code>(b, (c | d))</code> şeklinde okuyarak tek gönderime indirgenebilir. Artık, baştaki <el>b</el> içerik modelindeki tek bir adla eşleşir. İşlemci artık onu neyin izlediğine bakmak ihtiyacını duymaz; <el>c</el> veya <el>d</el>, ikisinden biri kabul edilir.</p>

			<p>Daha biçimsel olarak: Bir sonlu durum otomatı, Aho, Sethi ve Ullman'ın <bibref ref="Aho"/> 3.9. bölümündeki 3.5. algoritma gibi standart algoritmalar kullanılarak içerik modelinden oluşturulabilir. Böyle algoritmaların çoğunda, düzenli ifade içindeki her konum (yani, düzenli ifadenin sözdizimi ağacındaki her çocuksuz düğüm) için bir izleme kümesi oluşturulur; eğer bir konum, aynı eleman türü adı ile yaftalanmış birden fazla izleme konumu olan bir izleme kümesine sahipse, içerik modeli hatalıdır ve bir hata olarak raporlanabilir.</p>

			<p>Belirlenimci olmayan içerik modellerinin tümü için olmasa da çoğu için modeli özdevinimli olarak eşdeğer belirlenimci modellere indirgeyecek algoritmalar mevcuttur; bkz, Brüggemann-Klein 1991 <bibref ref="ABK"/>.</p>
		</inform-div1>

		<inform-div1 id="sec-guessing">
			<head>Karakter Kodlamalarının Kendiliğinden Saptanması</head>
			<p>XML karakter kodlaması bildirimi, her öğe üzerinde hangi karakter kodlamasının kullanılacağını belirten bir dahili yafta olarak işlev yapar. XML işlemci dahili yaftayı okumadan önce, hangi karakter kodlamasının kullanımda olduğunu; dahili yaftanın neyi belirtmeyi deneyeceğini bilir. Genel olarak, bu ümitsiz bir durumdur ama XML'de durum tamamen ümitsiz değildir, çünkü XML genel durumu iki yolla sınırlar: her gerçeklenimin karakter kodlamalarının sadece bir sonlu kümesini destekleyeceği varsayılır ve XML karakter kodlaması bildirimi, normal şartlarda her öğede kullanılan karakter kodlamasının kendiliğinden saptanabilmesinin mümkün kılınması aşamasında konum ve içerik bakımından kısıtlanır. Ayrıca, çoğu durumda XML veri akımının kendisine ilaveten diğer bilgi kaynakları da kullanılabilir. XML öğenin, eşlik eden (harici) bir bilgi olsun olmasın işlemciye hazır olup olmadığına bağlı olarak iki durum ayırdedilebilir. Biz ilk durumu önce inceleyeceğiz.</p>

			<div2 id="sec-guessing-no-ext-info">
				<head>Harici Kodlama Bilgisi Olmadan Saptama</head>
				<p>Her XML öğeye bir harici kodlama bilgisi eşlik etmeyeceğinden ve UTF-8 veya UTF-16 olmayan kodlamanın ilk karakterleri '<code>&lt;?xml</code>' olması gereken bir XML kodlama bildirimi ile başlaması gerektiğinden, bir uyumlu işlemci, aşağıdakilere uygun olarak girdinin en az iki en çok 4 sekizliğinden sonra uygulanacak kodlamayı saptayabilir. UCS-4'te '&lt;' iminin <quote><code>#x0000003C</code></quote> ve '?' iminin <quote><code>#x0000003F</code></quote> olduğunu ve  UTF-16 veri akımlarında gerekli Bayt Sıralama İminin <quote><code>#xFEFF</code></quote> olduğunu bilmek bu listenin okunmasında yardımcı olabilir. <var>##</var> gösterimi iki ardışık <var>##</var>'ın ikisinin de 00 olamayacağı durum hariç herhangi bir bayt değerini ifade etmekte kullanılmıştır.</p>
				<p>Bayt Sıralama İmi ile:</p>
				<table border="1" frame="border" summary="Kodlamanın saptanması">
					<tbody>
						<tr>
							<td>
								<code>00 00 FE FF</code>
							</td>
							<td>UCS-4, kıymetli baytın başta olduğu makine (1234 sırası)</td>
						</tr>
						<tr>
							<td>
								<code>FF FE 00 00</code>
							</td>
							<td>UCS-4, kıymetsiz baytın başta olduğu makine (4321 sırası)</td>
						</tr>
						<tr>
							<td>
								<code>00 00 FF FE</code>
							</td>
							<td>UCS-4, yararsız sekizlik sıralama (2143)</td>
						</tr>
						<tr>
							<td>
								<code>FE FF 00 00</code>
							</td>
							<td>UCS-4, yararsız sekizlik sıralama (3412)</td>
						</tr>
						<tr>
							<td>
								<code>FE FF ## ##</code>
							</td>
							<td>UTF-16,  kıymetli bayt başta</td>
						</tr>
						<tr>
							<td>
								<code>FF FE ## ##</code>
							</td>
							<td>UTF-16, kıymetsiz bayt başta</td>
						</tr>
						<tr>
							<td>
								<code>EF BB BF</code>
							</td>
							<td>UTF-8</td>
						</tr>
					</tbody>
				</table>
				<p>Bayt Sıralama İmi olmaksızın:</p>
				<table border="1" frame="border" summary="Kodlamanın saptanması">
					<tbody>
						<tr>
							<td>
								<code>00&nbsp;00&nbsp;00&nbsp;3C</code>
							</td>
							<td rowspan="4">UCS-4 veya 32 bitlik kodlu başka bir kodlama ve ASCII değer olarak kodlu ASCII karakterler. Bayt sıralamaları yukarıdan aşağı: kıymetli bayt başta (1234), kıymetsiz bayt başta (4321) ve iki yararsız bayt sıralaması (2143 ve 3412). UCS-4 mü yoksa başka bir 32 bitlik kodlama mı uygulanacağına karar vermek için kodlama bildirimi okunmalıdır.</td>
						</tr>
						<tr>
							<td>
								<code>3C 00 00 00</code>
							</td>
							<!--<td>UCS-4, little-endian machine (4321 order)</td>-->
						</tr>
						<tr>
							<td>
								<code>00 00 3C 00</code>
							</td>
							<!--<td>UCS-4, unusual octet order (2143)</td>-->
						</tr>
						<tr>
							<td>
								<code>00 3C 00 00</code>
							</td>
							<!--<td>UCS-4, unusual octet order (3412)</td>-->
						</tr>
						<tr>
							<td>
								<code>00 3C 00 3F</code>
							</td>
							<td>Bayt sıralamaları kıymetli bayt başta olmak üzere, UTF-16, ISO-10646-UCS-2 veya 16 bitlik kodlu başka bir kodlama ve ASCII değer olarak kodlu ASCII karakterler (neyin uygulanacağına karar vermek için kodlama bildirimi okunmalıdır).</td>
						</tr>
						<tr>
							<td>
								<code>3C 00 3F 00</code>
							</td>
							<td>Bayt sıralamaları kıymetsiz bayt başta olmak üzere, UTF-16, ISO-10646-UCS-2 veya 16 bitlik kodlu başka bir kodlama ve ASCII değer olarak kodlu ASCII karakterler (neyin uygulanacağına karar vermek için kodlama bildirimi okunmalıdır).</td>
						</tr>
						<tr>
							<td>
								<code>3C 3F 78 6D</code>
							</td>
							<td>UTF-8, ISO 646, ASCII, bazı ISO 8859 kısımları, Shift-JIS, EUC veya ASCII karakterlerin konumların, genişliklerini ve değerlerini koruduğu 7 bitlik, 8 bitlik veya karışık genişlikli başka kodlamalar; bunlardan hangisinin uygulanacağına karar vermek için kodlama bildirimi okunmalıdır, fakat bu kodlamaların hepsi ASCII karakterler için aynı bit örüntüsünü kullandıklarından kodlama bildiriminin kendisi düzgün olarak okunmalıdır.</td>
						</tr>
						<tr>
							<td>
								<code>4C 6F A7 94</code>
							</td>
							<td>EBCDIC (bazı çeşitlerinde; hangi kod sayfasının kullanılacağına karar vermek için kodlama bildiriminin tamamı okunmalıdır)</td>
						</tr>
						<tr>
							<td>Diğer</td>
							<td>Kodlama bildirimi olmaksızın UTF-8. aksi takdirde veri akımı yanlış isimlendirilmiştir (gerekli kodlama bildiriminin yokluğu), bozuktur, parça parçadur ya da bir çeşit sarmalayıcı içine alınmıştır.</td>
						</tr>
					</tbody>
				</table>

				<note>
					<p>Kodlamanın saptanması için kodlama bildiriminin okunmasını gerektirmeyen yukarıdaki durumlarda, <specref ref="charencoding"/> bölümü hala kodlama bildiriminin eğer varsa okunmasını ve o kodlama adının öğenin asıl kodlamasıyla eşleşmesine bakılmasını gerektirir. Ayrıca, kodlamayı saptamak için, halihazırda bunun gerekmediği durumlarda, kodlama bildiriminde kullanımı gerekli olacak yeni karakter kodlamalarını türetmek de mümkündür.</p>
				</note>

				<p>Kendiliğinden saptama için bu seviye XML kodlama bildirimini okumakta ve kodlamanın her ailesinin üyelerini tek tek ayırdetmek (yani, UTF-8'den 8859'a ve 8859 kısımlarından başka birine veya kullanılacak belirli bir EBCDIC kod sayfasını ayırdetmek ve  benzeri) için gereken karakter kodlaması belirtecini çözümlemekte yeterlidir.</p>
				<p>Kodlama bildiriminin içeriği ASCII karakter kümesinden karakterlerle sınırlı olduğundan, bir işlemci kodlama bildiriminin tamamını düzgün olarak okuyup kullanılacak kodlama ailesini hemen saptayabilir. Pratikte, geniş çapta kullanılan karakter kodlamalarının hepsi yukarıdaki kategorilerden birine karşı düştüğünden, XML kodlama bildirimi, harici bilgi kaynakları işletim sisteminde veya aktarım protokolü seviyesinde güvenilir olmasa bile bant içi karakter kodlaması isimlendirmesini oldukça güvenilir kılar. UTF-7 gibi ASCII değerle baytların aşırı yüklenmesine sebep olar karakter kodlamaları güvenilir olarak saptama konusunda başarısızlığa yol açabilir.</p>
				<p>İşlemci kullanımdaki karakter kodlamasını saptar saptamaz, her durum için ayrı bir girdi yordamı mı yoksa girdideki her karakter için uygun dönüşüm işlevini mi çağıracağına bağlı olarak uygun davranışta bulunabilir.</p>
				<p>Herhangi bir özadlandırmalı sistem gibi XML kodlama bildirimi de, eğer bir yazılım kodlama bildirimini güncellemeden öğenin karakter kümesi veya kodlaması değiştirirse çalışmayacaktır. Karakter kodlaması yordamlarının gerçeklenimcileri öğeyi yaftalamada kullanılan dahili ve harici bilginin doğruluğundan emin olmak konusunda dikkatli olmalıdırlar.</p>
			</div2>

			<div2 id="sec-guessing-with-ext-info">
				<head>Harici Kodlama Bilgisinin Varlığında Öncelikler</head>
				<p>İkinci olası durum, bazı dosya sistemlerinde veya bazı ağ protokollerindeki gibi XML öğeye kodlama bilgisi eşlik ettiği zaman ortaya çıkar. Çok sayıda elverişli bilgi kaynağı olduğunda bunların göreli önceliklerini ve uyumsuzluklarını işlemede tercih edilen yöntem, XML teslimatında kullanılacak daha yüksek seviyeden bir protokolün parçası olarak belirtilmelidir. Özellikle, lütfen <code>text/xml</code> ve <code>application/xml</code> MIME türlerini tanımlayan ve bu konuda biraz yol gösterici olan <bibref ref="rfc2376"/> veya ardıllarına bakınız. Birlikte çalışabilirlik bağlamında, aşağıdaki kural önerilir:</p>
				<ulist>
					<item>
						<p>Eğer XML öğe bir dosyadaysa, karakter kodlamasını (varsa) saptamada Bayt Sıralama İmi ve kodlama bildirimi kullanılır.</p>
					</item>
				</ulist>
			</div2>
		</inform-div1>

		<inform-div1 id="sec-xml-wg">
			<head>W3C XML Çalışma Grubu</head>
			<p>Bu belirtim yayına W3C XML Çalışma Grubu (ÇG) tarafından hazırlanmış ve onaylanmıştır. Bu belirtimin ÇG onayı tüm ÇG üyelerinin oylarının gerektiği anlamına gelmez. XML ÇG'nin şimdiki ve sabık üyeleri:</p>
			<orglist>
				<member>
					<name>Jon Bosak</name>
					<affiliation>Sun</affiliation>
					<role>Chair</role>
				</member>
				<member>
					<name>James Clark</name>
					<role>Technical Lead</role>
				</member>
				<member>
					<name>Tim Bray</name>
					<affiliation>Textuality and Netscape</affiliation>
					<role>XML Co-editor</role>
				</member>
				<member>
					<name>Jean Paoli</name>
					<affiliation>Microsoft</affiliation>
					<role>XML Co-editor</role>
				</member>
				<member>
					<name>C. M. Sperberg-McQueen</name>
					<affiliation>U. of Ill.</affiliation>
					<role>XML Co-editor</role>
				</member>
				<member>
					<name>Dan Connolly</name>
					<affiliation>W3C</affiliation>
					<role>W3C Liaison</role>
				</member>
				<member>
					<name>Paula Angerstein</name>
					<affiliation>Texcel</affiliation>
				</member>
				<member>
					<name>Steve DeRose</name>
					<affiliation>INSO</affiliation>
				</member>
				<member>
					<name>Dave Hollander</name>
					<affiliation>HP</affiliation>
				</member>
				<member>
					<name>Eliot Kimber</name>
					<affiliation>ISOGEN</affiliation>
				</member>
				<member>
					<name>Eve Maler</name>
					<affiliation>ArborText</affiliation>
				</member>
				<member>
					<name>Tom Magliery</name>
					<affiliation>NCSA</affiliation>
				</member>
				<member>
					<name>Murray Maloney</name>
					<affiliation>SoftQuad, Grif SA, Muzmo and Veo Systems</affiliation>
				</member>
				<member>
					<name>MURATA Makoto (FAMILY Given)</name>
					<affiliation>Fuji Xerox Information Systems</affiliation>
				</member>
				<member>
					<name>Joel Nava</name>
					<affiliation>Adobe</affiliation>
				</member>
				<member>
					<name>Conleth O'Connell</name>
					<affiliation>Vignette</affiliation>
				</member>
				<member>
					<name>Peter Sharpe</name>
					<affiliation>SoftQuad</affiliation>
				</member>
				<member>
					<name>John Tigue</name>
					<affiliation>DataChannel</affiliation>
				</member>
			</orglist>
		</inform-div1>

		<inform-div1 id="sec-core-wg">
			<head>W3C XML Çekirdek Çalışma Grubu</head>
			<p>Bu belirtimin ikinci düzeltmesi W3C XML Çekirdek Çalışma Grubu (ÇG) tarafından hazırlandı. Bu belirtimin yayınlanması sırasında ÇG katılımcıları şunlardı:</p>
			<orglist>
				<member>
					<name>Leonid Arbouzov</name>
					<affiliation>Sun Microsystems</affiliation>
				</member>
				<member>
					<name>John Cowan</name>
				</member>
				<member>
					<name>Andrew Fang</name>
					<affiliation>PTC-Arbortext</affiliation>
				</member>
				<member>
					<name>Paul Grosso</name>
					<affiliation>PTC-Arbortext</affiliation>
					<role>Co-Chair</role>
				</member>
				<member>
					<name>Konrad Lanz</name>
					<affiliation>A-SIT</affiliation>
				</member>
				<member>
					<name>Philippe Le Hégaret</name>
					<affiliation>W3C</affiliation>
					<role>Staff Contact</role>
				</member>
				<member>
					<name>Glenn Marcy</name>
					<affiliation>IBM</affiliation>
				</member>
				<member>
					<name>Sandra Martinez</name>
					<affiliation>NIST</affiliation>
				</member>
				<member>
					<name>Ravindrakumar R</name>
					<affiliation>CDAC</affiliation>
				</member>
				<member>
					<name>Lew Shannon</name>
				</member>
				<member>
					<name>Henry Thompson</name>
					<affiliation>W3C</affiliation>
					<role>Staff Contact</role>
				</member>
				<member>
					<name>Richard Tobin</name>
					<affiliation>University of Edinburgh</affiliation>
				</member>
				<member>
					<name>Daniel Veillard</name>
				</member>
				<member>
					<name>Norman Walsh</name>
					<affiliation>Sun Microsystems</affiliation>
					<role>Co-Chair</role>
				</member>
				<member>
					<name>François Yergeau</name>
				</member>
			</orglist>
		</inform-div1>

		<inform-div1 id="prod-notes">
			<head>Üretim Bilgileri</head>
			<p>Bu ikinci düzeltme (İngilizce olan özgün belge),  <loc href="&w3c;/2002/xmlspec/dtd/2.10/xmlspec.dtd">XMLspec DTD, 2.10</loc> sürümü çok az değiştirilerek kodlandı. XHTML sürümleri, birbirlerinin devamı niteliğindeki <loc href="&w3c;/2002/xmlspec/xhtml/1.13/xmlspec.xsl">xmlspec.xsl</loc>, <loc href="&w3c;/2002/xmlspec/xhtml/1.13/diffspec.xsl">diffspec.xsl</loc>, ve <loc href="REC-xml.xsl">REC-xml.xsl</loc> XSLT biçembentleri ile üretildi.</p>

      <p>Bu çeviri ise, özgün XMLspec belgesi üzerinde yapılmış olup, çevirinin XHTML sürümü bu belgeye özel olan <loc href="xml11.xsl"/> ve bütün önerge çevirileri için geçerli olan <loc href="../xmlspec-tr.xsl">xmlspec-tr.xsl</loc> XSLT biçembentleri ile üretilmiştir.</p>
		</inform-div1>
    <inform-div1 id="sec-suggested-names">
      <head>XML Adları için Öneriler</head>
      <p> Belge yazarlarına ve şema tasarımcılarına bir rehber niteliğinde tasarlanan bu bölümde, eleman isimleri, öznitelik isimleri, işlem yönergesi hedefleri, öğe isimleri, gösterim isimleri ve ID türünden değerler olarak kullanılan XML adlarını oluşturmakta en iyi uygulamalar olduğuna inanılan önerilere yer verilmiştir. Unicod'a yapılan bütün atıflar, Unicode Standardının 3.0 sürümüne eşit veya ondan büyük bir sürümü ile ilgili olarak ele alınmalıdır; hangi sürümün kullanılacağı belge yazarına veya şema tasarımcısına bırakılmıştır.</p>

      <p>İlk  iki öneri, tüm denetim karakterleri, kapsayıcı boşluksuz imler, ondalık olmayan sayılar, özel-kullanım karakterleri, noktalama karakterleri (istisnalarla), simge karakterleri, atanmamış kod değerleri ve boşluk karakterleri hariç olmak üzere doğrudan Unicode Standardının 3.0 sürümündeki betimleyiciler için belirtilmiş kurallardan türetilmiştir. Diğer önerilerin çoğu <bibref ref="XML1.0"/>'ın B. Ekinden türetilmiştir.</p>

      <olist>
        <item>
          <p>Herhangi bir ismin ilk karakteri Ll, Lu, Lo, Lm, Lt veya Nl Unicode Genel Kategorilerinden birinde veya '_' #x5F olmalıdır.</p>
        </item>
        <item>
          <p>İlk karakter dışında kalan karakterler, Ll, Lu, Lo, Lm, Lt, Mc, Mn, Nl, Nd, Pc veya Cf Unicode Genel Kategorilerinden birinde veya şunlardan biri olmalıdır: '-' #x2D, '.' #x2E, ':' #x3A veya '·' #xB7.
          Cf karakterleri doğrudan görünür olmadıklarından dikkatle ve sadece gerektiğinde kullanılmalıdır.</p>
        </item>
        <item>
          <p>Kurallı bir oluşuma sahip kavram karakterleri isimlerde kullanılmamalıdır (12 tanesi hariç [#xF900-#xFAFF] ve [#x2F800-#x2FFFD] aralıkları).</p>
        </item>
        <item>
          <p>Bir uyumluluk oluşumuna sahip karakterler (Unicode Karakter Veritabanının 5. alanında 2uyumluluk biçimleme etiketli olanlar -- 5. alan tarafından &lt;" ile başlayan şeklinde imli) isimlerde kullanılmamalıdır. Bu öneri, uyumluluk oluşumları bu betiklerde düzenli kullanılmasına rağmen #x0E33 THAI CHARACTER SARA AM veya #x0EB3 LAO CHARACTER AM karakterlerine uygulanmaz.</p>
        </item>
        <item>
          <p>Sadece simgelerle [#x20D0-#x20EF] ve [#x1D165-#x1D1AD]) aralıklarındakiler dahil) kullanmak için olan aksan karakterleri isimlerde kullanılmamalıdır.</p>
        </item>
        <item>
          <p>Satır arası ek açıklama karakterleri ([#xFFF9-#xFFFB]) isimlerde kullanılmamalıdır.</p>
        </item>
        <item>
          <p>Düzenli değişiklik seçim karakterleri isimlerde kullanılmamalıdır.</p>
        </item>
        <item>
          <p>Saçma, telaffuz edilemeyen, okunması zor veya başka isimlerle kolayca karıştırılabilecek isimler kullanılmamalıdır.</p>
        </item>
      </olist>
    </inform-div1>
	</back>
</spec>
