<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="xslt.xsl"?>
<!DOCTYPE spec SYSTEM "../xmlspec-v20.dtd" [
<!ENTITY XML "../xml">
<!ENTITY XMLNames "../xml-names">
<!ENTITY XSLT.ns "http://www.w3.org/1999/XSL/Transform">
<!ENTITY XSLTA.ns "http://www.w3.org/1999/XSL/TransformAlias">
<!ENTITY XSLFO.ns "http://www.w3.org/1999/XSL/Format">
<!ENTITY XHTML.ns "http://www.w3.org/TR/xhtml1/strict">
<!ENTITY year "1999">
<!ENTITY month "November">
<!ENTITY MM "11">
<!ENTITY day "16">
<!ENTITY DD "16">
<!ENTITY YYYYMMDD "&year;&MM;&DD;">
<!ENTITY LEV "REC">
<!--!ENTITY XPath "http://www.w3.org/TR/xpath"-->
<!ENTITY XPath "../xpath">
<!ATTLIST xfunction href CDATA "&XPath;">
<!-- DTD customizations -->
<!ELEMENT proto (arg*)>
<!ATTLIST proto
  name NMTOKEN #REQUIRED
  return-type (number|string|boolean|node-set|object) #REQUIRED
>
<!ELEMENT arg EMPTY>
<!ATTLIST arg
  type (number|string|boolean|node-set|object) #REQUIRED
  occur (opt|rep) #IMPLIED
>
<!ELEMENT function (#PCDATA)>
<!ELEMENT xfunction (#PCDATA)>
<!--ATTLIST xfunction href CDATA #REQUIRED-->
<!ELEMENT e:element-syntax
  (e:in-category*, e:attribute*, (e:empty|e:text|e:element|e:model|e:sequence|e:choice))
>
<!ATTLIST e:element-syntax
  xmlns:e CDATA #FIXED "http://www.w3.org/1999/XSL/Spec/ElementSyntax"
  name NMTOKEN #REQUIRED
>
<!ELEMENT e:in-category EMPTY>
<!ATTLIST
  e:in-category name NMTOKEN #REQUIRED
  xmlns:e CDATA #FIXED "http://www.w3.org/1999/XSL/Spec/ElementSyntax"
>
<!ELEMENT e:attribute (e:attribute-value-template|(e:constant|e:data-type)+)>
<!ATTLIST e:attribute
  name NMTOKEN #REQUIRED
  required (yes) #IMPLIED
  xmlns:e CDATA #FIXED "http://www.w3.org/1999/XSL/Spec/ElementSyntax"
>
<!ELEMENT e:attribute-value-template (e:constant|e:data-type)+>
<!ATTLIST e:attribute-value-template
  xmlns:e CDATA #FIXED "http://www.w3.org/1999/XSL/Spec/ElementSyntax"
>
<!ELEMENT e:constant EMPTY>
<!ATTLIST
  e:constant value CDATA #REQUIRED
  xmlns:e CDATA #FIXED "http://www.w3.org/1999/XSL/Spec/ElementSyntax"
>
<!ELEMENT e:data-type EMPTY>
<!ATTLIST e:data-type
  name NMTOKEN #REQUIRED
  xmlns:e CDATA #FIXED "http://www.w3.org/1999/XSL/Spec/ElementSyntax"
>
<!ELEMENT e:empty EMPTY>
<!ATTLIST e:empty
  xmlns:e CDATA #FIXED "http://www.w3.org/1999/XSL/Spec/ElementSyntax"
>
<!ELEMENT e:text EMPTY>
<!ATTLIST e:text
  xmlns:e CDATA #FIXED "http://www.w3.org/1999/XSL/Spec/ElementSyntax"
>
<!ELEMENT e:element EMPTY>
<!ATTLIST e:element
  name NMTOKEN #REQUIRED
  repeat (zero-or-one|zero-or-more|one-or-more) #IMPLIED
  xmlns:e CDATA #FIXED "http://www.w3.org/1999/XSL/Spec/ElementSyntax"
>
<!ELEMENT e:model EMPTY>
<!ATTLIST e:model
  name NMTOKEN #REQUIRED
  repeat (zero-or-one|zero-or-more|one-or-more) #IMPLIED
  xmlns:e CDATA #FIXED "http://www.w3.org/1999/XSL/Spec/ElementSyntax"
>
<!ELEMENT e:sequence (e:element|e:model|e:choice)+>
<!ATTLIST e:sequence
  repeat (zero-or-one|zero-or-more|one-or-more) #IMPLIED
  xmlns:e CDATA #FIXED "http://www.w3.org/1999/XSL/Spec/ElementSyntax"
>
<!ELEMENT e:choice (e:element|e:model|e:sequence)+>
<!ATTLIST e:choice
  repeat (zero-or-one|zero-or-more|one-or-more) #IMPLIED
  xmlns:e CDATA #FIXED "http://www.w3.org/1999/XSL/Spec/ElementSyntax"
>
<!ELEMENT e:element-syntax-summary EMPTY>
<!ATTLIST e:element-syntax-summary
  xmlns:e CDATA #FIXED "http://www.w3.org/1999/XSL/Spec/ElementSyntax"
>
<!ENTITY % local.illus.class "|proto|e:element-syntax|e:element-syntax-summary">
<!ENTITY % local.tech.class "|function|xfunction">
<!ENTITY % local.loc.class "|var">
<!ELEMENT var (#PCDATA)>
<!ATTLIST spec
  xmlns:e CDATA #FIXED "http://www.w3.org/1999/XSL/Spec/ElementSyntax">
 <!ENTITY translator.name 'Nilgün Belma Bugüner'>
 <!ENTITY translator.email 'nilgun (at) belgeler·org'>
 <!ENTITY translation.date 'Mayıs 2007'>
]>
<spec xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax">
<header>
<title>XSL Dönüşümleri (XSLT)</title>
<version>Version 1.0</version>
<w3c-designation>&LEV;-xslt-&YYYYMMDD;</w3c-designation>
<w3c-doctype>W3C Önergesi</w3c-doctype>
<pubdate><day>&day;</day><month>&month;</month><year>&year;</year></pubdate>
<publoc>
<loc href="http://www.w3.org/TR/&year;/&LEV;-xslt-&YYYYMMDD;"
          >http://www.w3.org/TR/&year;/&LEV;-xslt-&YYYYMMDD;</loc>
<loc role="available-format"
href="http://www.w3.org/TR/&year;/&LEV;-xslt-&YYYYMMDD;.xml">XML</loc>
<loc role="available-format"
href="http://www.w3.org/TR/&year;/&LEV;-xslt-&YYYYMMDD;.html">HTML</loc>
</publoc>
<latestloc>
<loc href="http://www.w3.org/TR/xslt"/>
</latestloc>
<prevlocs>
<loc href="http://www.w3.org/TR/1999/PR-xslt-19991008"/>
<loc href="http://www.w3.org/1999/08/WD-xslt-19990813"/>
<loc href="http://www.w3.org/1999/07/WD-xslt-19990709"/>
<loc href="http://www.w3.org/TR/1999/WD-xslt-19990421"/>
<loc href="http://www.w3.org/TR/1998/WD-xsl-19981216"/>
<loc href="http://www.w3.org/TR/1998/WD-xsl-19980818"/>
</prevlocs>
<authlist>
<author>
<name>James Clark</name>
<email href="mailto:jjc@jclark.com">jjc@jclark.com</email>
</author>
</authlist>

<status>

<p>Bu belge W3C üyeleri ve diğer ilgili taraflarca gözden geçirilmiş ve W3C Yönetimi tarafından bir W3C <loc href="http://www.w3.org/Consortium/Process/#RecsW3C">Önergesi</loc> olarak onaylanmıştır. Kararlı bir belge olup başka belgelerden uyulması gerekli bir kaynak olarak atıfta bulunarak veya bir başvuru malzemesi olarak kullanılabilir. W3C'nin Önergedeki rolü, belirtime dikkatleri çekmek ve geniş bir alanda kullanımını yaygınlaştırmaktır. Bu, Web'in işlevselliğini ve birlikte çalışabilirliğini arttırmaktadır.</p>

<p>Bu belgede tespit edilmiş hatalar <loc href="http://www.w3.org/&year;/&MM;/&LEV;-xslt-&YYYYMMDD;-errata"/> adresinde listelenmiştir.</p>

<p>Bu belirtimle ilgili yorumlar <loc href="mailto:xsl-editors@w3.org">xsl-editors@w3.org</loc> adresine gönderilebilir; yorum <loc href="http://lists.w3.org/Archives/Public/xsl-editors">arşivleri</loc> de mevcuttur. XSL'nin, XSLT'yi de içererek halka açık tartışma alanı olarak <loc href="http://www.mulberrytech.com/xsl/xsl-list/index.html">XSL-List</loc> eposta listesi vardır.</p>

<p>Bu belirtimin İngilizce sürümü uyulması gerekli tek sürümdür. Bununla birlikte bu belgenin (bilgilendirici mahiyette) <loc
href="http://www.w3.org/Style/XSL/translations.html">çeviriler</loc>i de mevcuttur.</p>

<p>W3C Önergelerinin ve diğer teknik belgelerinin bir listesi <loc
href="http://www.w3.org/TR"/> adresinde bulunabilir.</p>

<p>Bu belirtim <loc href="http://www.w3.org/Style/Activity">W3C Biçem etkinliği</loc>nin bir parçası olarak üretilmiştir.</p>

</status>

<abstract>

<p>Bu belirtim, XML belgeleri başka XML belgelere dönüştürmekte kullanılan bir dil olan XSLT'nin sözdizimini ve anlamlandırmasını tanımlar.</p>

<p>XSLT, XML için bir biçembent (İng: stylesheet) dili olan XSL'nin bir parçası olarak kullanılmak üzere tasarlanmıştır. XSL, biçimleme belirtmek için XSLT'ye ilaveten bir XML söz varlığına sahiptir. XSL, bir XML belgenin, biçimleme söz varlığını kullanan başka bir XML belgeye nasıl dönüştürüleceğini açıklayan XSLT'yi kullanarak XML belgenin biçemini belirtir.</p>

<p>XSLT, ayrıca, XSL'den bağımsız olarak kullanmak için de tasarlanmışsa da bir genel amaçlı XML dönüşüm dili olarak düşünülmemiştir. Daha çok, asıl olarak XSLT XSL'nin parçası olarak kullanıldığında gereken dönüşüm çeşitleri için tasarlanmıştır.</p>

</abstract>

<langusage>
<language id="TR">Türkçe</language>
<language id="ebnf">EBNF</language>
</langusage>
<revisiondesc>
<slist>
<sitem>See RCS log for revision history.</sitem>
</slist>
</revisiondesc>
</header>
<body>
<div1>
<head>Giriş</head>

<p>Bu belirtim, XSLT dilinin sözdizimini ve anlamlandırmasını tanımlar. XSLT dilinde bir dönüşüm, XSLT tarafından tanımlanmış olsun olmasın bütün elemanları içererek, XML Önergesindeki İsim Alanlarına <bibref ref="XMLNAMES"/> uygun ve iyi biçimlenmiş bir XML belge <bibref ref="XML"/> olarak ifadesini bulur. <termdef id="dt-xslt-namespace" term="XSLT
İsim-alanı">XSLT tarafından tanımlanmış elemanlar belli bir XML isim-alanına karşılık olmakla diğerlerinden ayrılırlar (bkz, <specref ref="xslt-namespace"/>); bu belirtimde bu isim-alanından <term>XSLT isim-alanı</term> olarak bahsedilecektir. Bu belirtim aynı zamanda, XSLT isim-alanının sözdizimi ve anlamlandırmasının bir tanımıdır.</termdef></p>

<p>XSLT'de ifadesini bulan bir dönüşüm, bir kaynak ağacı bir hedef ağaca dönüştürecek kuralları açıklar. Dönüşüm, örüntüler örneklerle ilişkilendirilerek elde edilir. Bir örüntü kaynak ağacındaki elemanlarla eşleşirken, bir örnek hedef ağacın elemanlarını oluşturur. Hedef ağaç, kaynak ağaçtan ayrıdır. Hedef ağacın yapısı kaynak ağacın yapısından tamamen farklı olabilir. Hedef ağaç oluşturulurken, kaynak ağaçtaki elemanlar süzülebilir, yeni bir sırayla dizilebilir ve hatta ağaca tamamen keyfi bir yapı eklenebilir.</p>

<p>XSLT'de ifadesini bulan dönüşüme <kw>biçembent</kw> (İng: stylesheet) denir. Çünkü, XSLT'nin XSL biçimleme söz varlığına dönüştüğü durumda dönüşüm bir biçembent (biçem demeti) olarak iş görür.</p>

<p>Bu belge bir XSLT biçembendinin bir XML belgesi ile nasıl ilişkilendirileceğini açıklamaz. Bunun için XSL işlemcilerin desteklediği mekanizmaları açıklayan <bibref ref="XMLSTYLE"/> önerilir. Bu veya herhangi bir başka mekanizma, bir XML belgeye aynı anda uygulanacak bir XSLT biçembent silsilesinden oluştuğunda, etkisi, silsileyi oluşturan üyeleri aynı sırayla içeren (bkz, <specref ref="import"/>) tek bir biçembendin uygulanmasına eşit olmalıdır.</p>

<p>Bir biçembent, örneklenim kurallarından oluşan bir küme içerir. Bir örneklenim kuralı iki parçadan oluşur: kaynak ağacındaki düğümlere karşılık olan bir örüntü ve hedef ağacın biçimlenecek parçasının biçimleme örneğini içeren bir örneklenim (İng: template). Bu, bir biçembendin kaynak ağaç yapıları birbirine benzeyen geniş bir belge sınıfına uygulanabilirliğini mümkün kılar.</p>

<p>Bir örneklenim, hedef ağacın bir bölümünü oluşturmak üzere belli bir kaynak elemanı için işleme sokulur. Bir örneklenim, hedef eleman yapısını belirten elemanları  birebir içerebileceği gibi, ayrıca, hedef ağaç yapısını oluşturacak yönergelerden oluşan XSLT isim-alanındaki elemanları da içerebilir. Bir örneklenim işleme sokulduğunda, içerdiği her yönerge yorumlanır ve oluşturacağı hedef ağaç bölümüyle değiştirilir. Yönergeler kaynak elemanların bir alt kümesini seçebilir ve işleyebilir. Alt kümeden bir elemanın işlenmesi, uygun örneklenim kuralının bulunması ve bu örneklenimin işleme sokularak hedef ağacın bir bölümünün  oluşturulması anlamına gelir. Bir yönergenin yorumlanmasıyla seçildiklerinde elemanlar tek başlarına işlem görürler. Hedef ağaç, kök düğümü için hazırlanmış örneklenim kuralı bulunarak ve bu örneklenim işleme sokularak oluşturulur.</p>

<p>Uygun örneklenim kuralını bulma işleminde, birden fazla örneklenim kuralı belli bir elemanla eşleşen bir örüntüye sahip olabilir. Ancak, sadece bir örneklenim kuralı uygulanacaktır. Hangi örneklenim kuralının uygulanacağına karar verme yöntemi <specref ref="conflict"/> bölümünde açıklanmıştır.</p>

<p>Bir örneklenim tek başına oldukça güçlü sayılır: az veya çok karmaşıklıkta yapılar oluşturabilir; kaynak ağacın çeşitli yerlerindeki dizge değerlerini çekip çıkarabilir; elemanların kaynak ağaçta yer alışlarına bağlı olarak yinelenen yapılar üretebilir. Basit dönüşümler bakımından, hedef ağacın yapısı kaynak ağacın yapısından bağımsız olduğunda, bir biçembent çoğunlukla kaynak ağacın tamamı için işlem yapan tek bir örneklenimden meydana gelir. İçeriği verilerden oluşan XML belgeler üzerindeki dönüşümler çoğunlukla bu türdendir (bkz, <specref ref="data-example"/>).XSLT bu tür biçembentler için basitleştirilmiş bir sözdizimi sağlar (bkz, <specref ref="result-element-stylesheet"/>).</p>

<p>Bir örneklenim işleme sokulduğunda daima bir <termdef id="dt-current-node" term="Geçerli Düğüm"><term>geçerli düğüm</term></termdef> ve bir <termdef
id="dt-current-node-list" term="Current Node List"><term>geçerli düğüm listesi</term></termdef> ile ilgili olarak işlem yapar. Geçerli düğüm daima geçerli düğüm listesinin bir üyesidir. XSLT'deki işlemlerin çoğu geçerli düğüme görelidir. Pek az yönerge geçerli düğüm listesini veya geçerli düğümü değiştirir (bkz, <specref ref="rules"/> ve <specref ref="for-each"/>); bu yönergeler işlem yaptığı sırada, geçerli düğüm listesi yerini yeni düğüm listesine bırakır; yani yeni listenin her üyesi geçerli düğüm haline gelir; yönergenin işi bittiğinde geçerli düğüm listesi veya geçerli düğüm tekrar yönerge öncesinde geçerli olan düğüm listesi ve düğüm olur.</p>

<p>XSLT metin üretmek ve koşullu işlemler için eleman seçerken <bibref
ref="XPATH"/> tarafından tanımlanmış ifade dilini kullanır.</p>

<p>XSLT, dili genişletmek için kullanıcı tarafından değiştirilerek kullanılmak üzere iki özellik sağlar, biri örneklenimlerde kullanılan yönerge elemanları kümesini, diğeri XPath ifadelerinde kullanılan işlev kümesini genişletir. Bu özelliklerin her ikisi de XML isim alanlarına dayandırılmıştır. XSLT'nin bu sürümü bu özellikleri gerçeklemek için bir mekanizma tanımlamamıştır (bkz, <specref ref="extension"/>).</p>

<note><p>XSL Çalışma Grubu böyle bir mekanizmayı bu belirtimin ileriki sürümlerinde veya ayrı bir belirtimde tanımlamayı düşünmektedir.</p></note>

<p>XSLT tarafından tanımlanmış elemanların sözdizimlerini belirleyen eleman sözdizimi gösterim özeti <specref ref="notation"/> bölümünde açıklanmıştır.</p>

<p>XSLT biçembentleri için MIME ortam türleri olarak <code>text/xml</code> ve
<code>application/xml</code> <bibref ref="RFC2376"/> kullanılmalıdır. Özellikle XSLT biçembentleri için kayda geçirilmiş bir ortam türü olduğunda, bu ortam türü de kullanılabilir.</p>

</div1>

<div1>
<head>Biçembent Yapısı</head>

<div2 id="xslt-namespace">
<head>XSLT İsim-alanı</head>

<p>XSLT isim-alanı tanımı <code>&XSLT.ns;</code>adresinde bulunmaktadır.</p>

<note><p>Adresin içindeki <code>1999</code> iibaresi, bu tanım-yerinin (URI) W3C tarafından tahsis edildiği yılı belirtir. XSLT'nin kullanılmakta olan sürümünü göstermez (kullanılmakta olan XSLT sürümü özniteliklerle belirtilir (bkz, <specref ref="stylesheet-element"/> ve <specref ref="result-element-stylesheet"/>).</p></note>

<p>XSLT işlemcileri bu isim-alanındaki elemanları ve öznitelikleri tanımak için XML isim alanları mekanizmasını <bibref ref="XMLNAMES"/> kullanmalıdır. XSLT isim-alanındaki elemanlar sadece biçembent içindekiler için tanınırlar, kaynak belge içindekiler için değil. XSLT tarafından tanımlanmış elemanların tam  listesi <specref ref="element-syntax-summary"/> bölümündedir. Üreticiler XSLT isim-alanını yeni elemanlar ve öznitelikler ekleyerek genişletmemelidirler. Böyle bir genişletme yapılacaksa, bu ayrı bir isim-alanında yapılmalıdır. Ek yönerge elemanları için kullanılacak bir isim-alanı <specref ref="extension-element"/> bölümünde belirtilmiş olan ek eleman mekanizmasına göre tanımlanmalıdır.</p>

<p>Bu belirtimde, XSLT isim-alanındaki elemanlara atıfta bulunmak için <code>xsl:</code> öneki kullanılmıştır. Ancak, XSLT biçembentleri, XSLT isim-alanının tanım-yerine (URI) önek belirten bir isim-alanı bildirimi yaparak başka bir önek kullanmakta özgürdürler.</p>

<p>XSLT isim-alanındaki bir eleman XSLT isim-alanında bulunmayan bir özniteliği, boş olmayan bir isim-alanı tanım-yerine sahip öznitelik <xtermref href="&XPath;#dt-expanded-name">isim genişletmesi</xtermref> belirterek içerebilir. Böyle özniteliklerin varlığı, XSLT elemanlarının ve işlevlerinin bu belgede tanımlanmış davranışını değiştirmemelidir. Bu bakımdan, bir XSLT işlemci böyle öznitelikleri yoksaymakta daima özgürdür ve isim-alanı tanım-yerini bulamıyorsa bunları bir hata vermeksizin yoksaymalıdır. Bu tür özniteliklerle, örneğin, eşsiz tanıtıcılar, eniyileme ipuçları veya belgeleme içerilebilir.</p>

<p>XSLT isim-alanındaki elemanlar açısından, bu belgede o eleman için tanımlananlardan başka, boş isim-alanı tanım-yeri belirten isim genişletmeli özniteliklere (isimleri öneksiz özniteliklere) sahip olmak bir hatadır.</p>

<note><p>XSLT eleman, öznitelik ve işlev isimleri için kullanılmakta olan uzlaşımlar şunlardır: isimler küçük harflerden oluşur, sözcükleri ayırmak için tire imleri  ve XML veya HTML gibi alakalı bir dilin sözdiziminde yeralmak kaydıyla kısaltmalar kullanılabilir.</p></note>
</div2>

<div2 id="stylesheet-element">
<head>Stylesheet Elemanı</head>

<e:element-syntax name="stylesheet">
  <e:attribute name="id">
    <e:data-type name="id"/>
  </e:attribute>
  <e:attribute name="extension-element-prefixes">
    <e:data-type name="dizgecikler"/>
  </e:attribute>
  <e:attribute name="exclude-result-prefixes">
    <e:data-type name="dizgecikler"/>
  </e:attribute>
  <e:attribute name="version" required="yes">
    <e:data-type name="sayı"/>
  </e:attribute>
  <e:sequence>
    <e:element repeat="zero-or-more" name="import"/>
    <e:model name="tepe-seviyeden-elemanlar"/>
  </e:sequence>
</e:element-syntax>

<e:element-syntax name="transform">
  <e:attribute name="id">
    <e:data-type name="id"/>
  </e:attribute>
  <e:attribute name="extension-element-prefixes">
    <e:data-type name="dizgecikler"/>
  </e:attribute>
  <e:attribute name="exclude-result-prefixes">
    <e:data-type name="dizgecikler"/>
  </e:attribute>
  <e:attribute name="version" required="yes">
    <e:data-type name="sayı"/>
  </e:attribute>
  <e:sequence>
    <e:element repeat="zero-or-more" name="import"/>
    <e:model name="tepe-seviyeden-elemanlar"/>
  </e:sequence>
</e:element-syntax>

<p>Bir biçembent, bir XML belgede bir <code>xsl:stylesheet</code> elemanı tarafından ifade edilir. <code>xsl:transform</code> elemanı <code>xsl:stylesheet</code> elemanının yerine (eşanlamlı) kullanmak içindir.</p>

<p>Bir <code>xsl:stylesheet</code> elemanı, biçembendin gerekirdiği XSLT sürümünün belirtildiği bir <code>version</code> özniteliğine sahip olmak zorundadır (varlığı zorunlu öznitelik isimleri gösterimde kalın yazıyla vurgulanmıştır) ve XSLT'nin bu sürümü için değeri <code>1.0</code> olmalıdır. Değer <code>1.0</code> olmadığı takdirde, ileriye uyumlu işlem kipi etkin olur (bkz, <specref ref="forwards"/>).</p>

<p><code>xsl:stylesheet</code> elemanı şu elemanları içerebilir:</p>
<ulist>
<item><p><code>xsl:import</code></p></item>
<item><p><code>xsl:include</code></p></item>
<item><p><code>xsl:strip-space</code></p></item>
<item><p><code>xsl:preserve-space</code></p></item>
<item><p><code>xsl:output</code></p></item>
<item><p><code>xsl:key</code></p></item>
<item><p><code>xsl:decimal-format</code></p></item>
<item><p><code>xsl:namespace-alias</code></p></item>
<item><p><code>xsl:attribute-set</code></p></item>
<item><p><code>xsl:variable</code></p></item>
<item><p><code>xsl:param</code></p></item>
<item><p><code>xsl:template</code></p></item>
</ulist>

<p><termdef id="dt-top-level" term="Tepe-seviyeden eleman">Bir <code>xsl:stylesheet </code> elemanının çocuğu olan bir elemana <term>tepe-seviyeden</term> eleman denir.</termdef></p>

<p>Bu örnekte bir biçembendin yapısı gösterilmiştir. Üç nokta imleri (<code>...</code>) içeriği veya öznitelik değerini betimler. Bu örnek olası elemanların her birinden sadece bir tane içeriyorsa da biçembentler bu elemanların birden fazlasını içerebileceği gibi hiç içermeyebilir de.</p>

<eg>&lt;xsl:stylesheet version="1.0"
                xmlns:xsl="&XSLT.ns;"><![CDATA[
  <xsl:import href="..."/>

  <xsl:include href="..."/>

  <xsl:strip-space elements="..."/>

  <xsl:preserve-space elements="..."/>

  <xsl:output method="..."/>

  <xsl:key name="..." match="..." use="..."/>

  <xsl:decimal-format name="..."/>

  <xsl:namespace-alias stylesheet-prefix="..." result-prefix="..."/>

  <xsl:attribute-set name="...">
    ...
  </xsl:attribute-set>

  <xsl:variable name="...">...</xsl:variable>

  <xsl:param name="...">...</xsl:param>

  <xsl:template match="...">
    ...
  </xsl:template>

  <xsl:template name="...">
    ...
  </xsl:template>

</xsl:stylesheet>]]></eg>

<p><code>xsl:stylesheet</code>elemanının çocuklarının yer alış sırası hata takibi ve <code>xsl:import</code> elemanları dışında önemsizdir. Kullanıcılar elemanları istedikleri sırada kullanmakta özgürdürler ve biçembent oluşturma araçları elemanların yer alış sırası üzerinde bir denetime sahip olmamalıdır.</p>

<p>Bundan başka, <code>xsl:stylesheet</code> elemanı XSLT isim-alanında bulunmayan elemanlar (isim-alanının tanım-yerine (URI) önek belirten bir isim-alanı bildirimi yaparak ve bu öneki isminde içererek) içerebilir. Bu tür üst seviyeden elemanların varlığı, XSLT elemanlarının ve işlevlerinin bu belgede tanımlanmış davranışını değiştirmemelidir; örneğin, çelişkileri çözümlemede farklı kuralların kullanıldığı <code>xsl:apply-templates</code>'ler belirten bu türden bir üst seviyeden elemana izin verilmemelidir. Dolayısıyla, bir XSLT işlemci bu türden üst seviyeden elemanları yoksaymakta daima özgürdür ve isim-alanı tanım-yerini bulamıyorsa bunları bir hata vermeksizin yoksaymalıdır. Bu tür elemanlar şunlar için gerekebilir:</p>

<ulist>
<item><p>Ek elemanlar veya ek işlevler tarafından kullanılan bilgiler (bkz, <specref ref="extension"/>),</p></item>

<item><p>hedef ağaçta yapılacaklarla ilgili bilgiler,</p></item>

<item><p>kaynak ağacın nasıl temin edileceği bilgisi,</p></item>

<item><p>biçembentle ilgili temel veriler,</p></item>

<item><p>biçembentle ilgili belgeleme.</p></item>

</ulist>

</div2>

<div2 id="result-element-stylesheet">
<head>Birebir Sonuç Elemanı olarak Biçembent</head>
<p>Biçembentin kök düğüm için tek bir örneklenim oluşturacak şekilde kullanımı basitleştirilmiş sözdizimi ile mümkün kılınmıştır. Biçembentin kendisi birebir sonuç elemanını oluşturabilir (bkz, <specref ref="literal-result-element"/>). Böyle bir biçembent, birebir sonuç elemanı içeren ve <code>/</code> örüntüsü ile eşleşen bir örneklenim kuralına sahip bir örneklenim içeren bir biçembente eşdeğerdir. Örneğin,</p>

<eg>&lt;html xsl:version="1.0"
      xmlns:xsl="&XSLT.ns;"
      xmlns="&XHTML.ns;"><![CDATA[
  <head>
    <title>Harcama Raporu Hülâsası</title>
  </head>
  <body>
    <p>Toplam Miktar: <xsl:value-of select="harcama-raporu/toplam"/></p>
  </body>
</html>]]></eg>

<p>ile</p>

<eg>&lt;xsl:stylesheet version="1.0"
                xmlns:xsl="&XSLT.ns;"
                xmlns="&XHTML.ns;"><![CDATA[
<xsl:template match="/">
<html>
  <head>
    <title>Harcama Raporu Hülâsası</title>
  </head>
  <body>
    <p>Toplam Miktar: <xsl:value-of select="harcama-raporu/toplam"/></p>
  </body>
</html>
</xsl:template>
</xsl:stylesheet>]]></eg>

<p>eşdeğerdir.</p>

<p>Bir biçembendin belge elemanı olan bir birebir sonuç elemanı, biçembendin gerektirdiği XSLT sürümünü belirten bir <code>xsl:version</code> özniteliğine sahip olmak zorundadır. XSLT'nin bu sürümü için bu değer <code>1.0</code> ve değerin kendisi de bir <xnt href="&XPath;#NT-Number">Sayı</xnt> olmalıdır. Diğer birebir sonuç elemanları ayrıca bir <code>xsl:version</code> özniteliğine sahip olabilir. <code>xsl:version</code> özniteliğinin değeri <code>1.0</code> olmadığı takdirde, ileriye uyumlu işlem kipi etkin olur (bkz, <specref ref="forwards"/>).</p>

<p>Bir biçembent olarak kullanıldığında bir birebir sonuç elemanının içeriği,  biçembendin içinde kullanılandakinden farklı değildir. Bu bakımdan, bir biçembent olarak kullanılmış olan bir birebir sonuç elemanı <termref def="dt-top-level">tepe-seviyeden</termref> elemanlar içeremez.</p>

<p>Bazı durumlarda, sistemin bir XML belgenin bir XSLT biçembendi olarak bir XSLT işlemcisi tarafından işlenmesinin gerektiğini anlamasının tek yolu XML belgenin kendisini incelemesi olabilir. Basitleştirilmiş sözdiziminin kullanılması bu süreci daha da zorlaştıracaktır.</p>

<note><p>Örneğin, başka XML dili (BXD) diye bir dil belge elemanı üzerinde, XML belgenin bir BXD işlemcisi tarafından işlenmesi gereken bir BXD belgesi olduğunu belirten, bir <code>bxd:version</code> özniteliği kullanmış olsun. Eğer bir belge hem <code>bxd:version</code> hem de <code>xsl:version</code> özniteliklerine sahipse belgenin bir BXD işlemci tarafından mı yoksa bir XSLT işlemci tarafından mı işleneceği belli olmayacaktır.</p></note>

<p>Diğer taraftan, böyle bir durumda, XSLT biçembendinde basitleştirilmiş sözdiziminin kullanılmaması gerekir. Bu durum, örneğin, içeriğini işlemek için iletinin MIME ortam türüne bakan bir alıcıya bir XSLT biçembendinin <code>text/xml</code> veya <code>application/xml</code> MIME ortam türünde bir ileti olarak aktarıldığı bir durum olarak karşımıza çıkabilir.</p>

</div2>

<div2 id="qname">
<head>Nitelikli Adlar</head>

<p>Bir dahili XSLT nesnesinin ismi, özellikle bir isimli örneklenim (<specref ref="named-templates"/>), bir kip (<specref ref="modes"/>), bir öznitelik kümesi (<specref ref="attribute-sets"/>), bir anahtar (<specref ref="key"/>), bir onluk sayı biçimi (<specref ref="format-number"/>), bir değişken veya parametre (<specref ref="variables"/>) bir <xnt href="&XMLNames;#NT-QName">NitelikliAd</xnt> olarak belirtilir. Bir önek varsa, ismi içeren öznitelik üstünde etkili olan isim-alanı bildirimleri kullanılarak önek bir tanım-yeri başvurusuna genişletilir.
<xtermref href="&XPath;#dt-expanded-name">Genişletilen ad</xtermref> ismin yerel parçası ile nesne ismi olarak kullanılan ve boş olabilen bir tanım-yeri başvurusundan oluşur. Öntanımlı isim-alanı öneksiz isimler için kullanılMAZ.</p>

</div2>

<div2 id="forwards">
<head>İleriye Uyumlu İşlem</head>

<p>Bir eleman ileriye uyumlu kipi kendisi, öznitelikleri, torunları ve torunlarının öznitelikleri için şunlardan birinin varlığı halinde etkinleştirir:</p>

<slist>
<sitem>Eleman, <code>version</code> özniteliği <code>1.0</code> değerine eşit olan bir <code>xsl:stylesheet</code> elemanıdır.</sitem>

<sitem>Eleman, <code>xsl:version</code> özniteliği <code>1.0</code>'dan farklı bir değerde olan bir birebir sonuç elemanıdır.</sitem>

<sitem>Eleman, <code>xsl:version</code> özniteliğine sahip olmayan bir birebir sonuç elemanı olup basitleştirilmiş sözdizimi kullanan bir biçembentin belge elemanıdır (bkz, <specref ref="result-element-stylesheet"/>).</sitem>

</slist>

<p>Değeri <code>1.0</code> olan bir <code>xsl:version</code> özniteliğine sahip bir birebir sonuç elemanı ileriye uyumlu kipi kendisi, öznitelikleri, altkümesi ve altkümesinin öznitelikleri için etkinleştirmeyecektir.</p>

<p>Eğer bir eleman ileriye uyumlu kipte işlem yapıyorsa:</p>

<ulist>

<item><p>Eleman, bir <termref def="dt-top-level">tepe-seviyeden</termref> elemansa ve XSLT 1.0 böyle elemanlara tepe seviyeden elemanlar olarak izin vermiyorsa, eleman içeriğiyle birlikte yoksayılmalıdır.</p></item>

<item><p>Eleman bir örneklenim içindeyse ve XSLT 1.0 böyle elemanların bir örneklenim içinde bulunmasına izin vermiyorsa,  eleman işleme sokulamadığı takdirde bir hata oluşmalı, aksi takdirde XSLT, eleman için <specref ref="fallback"/> bölümünde belirtildiği gibi bir son çareye başvurmalıdır.</p></item>

<item><p>Eleman, XSLT 1.0 tarafından bir elemanın sahip olmasına izin verilmeyen bir özniteliğe sahipse ya da XSLT 1.0 tarafından bir seçimlik özniteliğin sahip olmasına izin verilmeyen bir değere sahip bir özniteliğe sahipse, öznitelik yoksayılmalıdır.</p></item>

</ulist>

<p>Bu bakımlardan, bir XSLT işlemci aşağıdaki biçembenti, bu belirtimde tanımlanmamış bir XSLT isim-alanından elemanlar içerse bile hatasız işleyebilmelidir.</p>

<eg>&lt;xsl:stylesheet version="1.1"
                xmlns:xsl="&XSLT.ns;"><![CDATA[
  <xsl:template match="/">
    <xsl:choose>
      <xsl:when test="system-property('xsl:version') >= 1.1">
        <xsl:yeni-heyecan-verici-1.1-özelliği/>
      </xsl:when>
      <xsl:otherwise>
        <html>
        <head>
          <title>XSLT 1.1 gerekli</title>
        </head>
        <body>
          <p>Bu biçembent XSLT 1.1 gerektiriyor.</p>
        </body>
        </html>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>
</xsl:stylesheet>]]></eg>

<note><p>Eğer bir biçembent sürümü 1.0'dan sonraki bir XSL'e ait bir tepe seviyeden elemana son derece bağımlıysa, biçembent, XSL'in daha erken sürümlerini gerçekleyen XSLT işlemcilerin tepe seviyeden elemanları sessizce yoksaymayacağından emin olmak için bir <code>xsl:message</code> elemanını <code>terminate="yes"</code> özniteliği ile kullanabilir (bkz, <specref ref="message"/>). Örnek:</p>

<eg>&lt;xsl:stylesheet version="1.5"
                xmlns:xsl="&XSLT.ns;"><![CDATA[

  <xsl:etkili-yeni-1.1-bildirimi/>

  <xsl:template match="/">
    <xsl:choose>
      <xsl:when test="system-property('xsl:version') &lt; 1.1">
        <xsl:message terminate="yes">
          <xsl:text>Bu biçembent XSLT 1.1 gerektiriyor.</xsl:text>
        </xsl:message>
      </xsl:when>
      <xsl:otherwise>
        ...
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>
  ...
</xsl:stylesheet>]]></eg>
</note>

<p>
Eğer bir <termref def="dt-expression">ifade</termref> ileriye uyumlu kipte işlem yapan bir öznitelikte bulunuyorsa, XSLT işlemci ifadedeki bazı hatalar için şöyle davranmalıdır:</p>

<ulist>

<item><p>Eğer ifade XPath dilbilgisine göre izin verilen sözdizimine uygun değilse, ifade gerçekten değerlendirilemedikçe bir hata üretilmemelidir.</p></item>

<item><p>Eğer ifade XSLT kütüphanesinin bir parçası olmayan ve ismi öneksiz olan bir işlevi çağırıyorsa, işlev gerçekten çağrılamadıkça bir hata üretilmemelidir.</p></item>

<item><p>Eğer ifade  bir işlevi, XSLT tarafından izin verilmeyen sayıda argümanla veya XSLT tarafından izin verilmeyen türdeki argümanlarla çağırıyorsa, işlev gerçekten çağrılamadıkça bir hata üretilmemelidir.</p></item>

</ulist>


</div2>

<div2>
<head>Biçembentlerin Birleştirilmesi</head>

<p>XSLT biçembentlerin bileştirilmesi için iki mekanizmaya sahiptir:</p>

<slist>

<sitem>Anlamsallıkları değişmeksizin biçembentlerin birleştirilebilmelerini mümkün kılan içerme mekanizması ve</sitem>

<sitem>her biçembentin diğerlerinin yukarısına gelecek şekilde birleştirilmesini mümkün kılan ithal mekanizması.</sitem>

</slist>

<div3 id="include">
<head>Biçembentlerin İçerilmesi</head>

<e:element-syntax name="include">
  <e:in-category name="tepe-seviyeden-eleman"/>
  <e:attribute name="href" required="yes">
    <e:data-type name="tanım-yeri-başvurusu"/>
  </e:attribute>
  <e:empty/>
</e:element-syntax>

<p>Bir XSLT biçembendi başka bir XSLT biçembendini bir <code>xsl:include</code> elemanı kullanarak içerebilir. <code>xsl:include</code> elemanı, değeri içerilecek biçembendin tanım-yerine bir başvuru olan bir <code>href</code> özniteliğine sahiptir. Göreli bir tanım-yeri <code>xsl:include</code> elemanını içeren biçembendin tanım-yerine göre çözümlenir (bkz, <specref ref="base-uri"/>).</p>

<p><code>xsl:include</code> elemanına sadece <termref def="dt-top-level">tepe-seviyeden</termref> bir eleman olarak izin verilir.</p>

<p>İçerme işlemi XML ağaç seviyesinde gerçekleşir. <code>href</code> özniteliğinin değeriyle yeri belirlenen kaynak bir XML belge olarak ele alınır ve  bu belgedeki <code>xsl:stylesheet</code> elemanının çocukları <code>xsl:include</code> elemanının yerine yerleştirilirler. İçerilen örneklenim kuralları ve tanımları işlem sırasını fiilen etkilemezler.</p>

<p>İçerilen biçembent <specref ref="result-element-stylesheet"/> bölümünde açıklanan basitleştirilmiş sözdizimini kullanıyor olabilir ve böyle bir durumda biçembent eşdeğer <code>xsl:stylesheet</code> elemanı ile aynı şekilde ele alınır.</p>

<p>Bir biçembendin doğrudan veya dolaylı kendi kendini içeriyor olması bir hatadır.</p>

<note><p>Defalarca içerilen bir biçembent tanımların tekrarı sebebiyle hatalara yol açabilir. Böyle çoklu içerimler dolaylı olduklarında daha az belirgin olurlar. Örneğin, <var>B</var> ve <var>C</var> biçembendleri <var>A</var> biçembendini içeriyorsa ve <var>D</var> biçembendi de hem <var>B</var> hem de <var>C</var> biçembendini içeriyorsa, <var>A</var> biçembendi, <var>D</var> biçembendi tarafından dolaylı olarak iki kere içerilmiş olacaktır. <var>B</var>, <var>C</var> ve <var>D</var> biçembentlerinin herbiri bağımsız biçembentler olarak kullanılıyorsa, <var>B</var> biçembendindeki <var>A</var> biçembendinin içerilmesi dışındaki herşeyi bir <var>B'</var> biçembendine aktararak ve benzer bir işlemi <var>C</var> biçembendi içinde yaptıktan sonra <var>D</var> biçembendini <var>A</var>, <var>B'</var> ve <var>C'</var> biçembentlerini içerecek şekilde değiştirerek hatadan kurtulmak mümkün olabilir.</p></note>

</div3>

<div3 id="import">
<head>Biçembent İthali</head>

<e:element-syntax name="import">
  <e:attribute name="href" required="yes">
    <e:data-type name="tanım-yeri-başvurusu"/>
  </e:attribute>
  <e:empty/>
</e:element-syntax>

<p>Bir XSLT biçembendi başka bir XSLT biçembendini bir <code>xsl:import</code> elemanı kullanarak ithal edebilir. İthal edilen biçembentteki örneklenim kurallarının ve tanımlarının ithal eden biçembenttekilerin önüne geçmesi dışında ithal işlemi içerme işlemine (bkz, <specref ref="include"/>) benzer; işlem aşağıda daha ayrıntılı olarak açıklanmıştır. <code>xsl:import</code> elemanı, değeri ithal edilecek biçembendin tanım-yerine bir başvuru olan bir <code>href</code> özniteliğine sahiptir. Göreli bir tanım-yeri <code>xsl:import</code> elemanını içeren biçembendin tanım-yerine göre çözümlenir (bkz, <specref ref="base-uri"/>).</p>

<p><code>xsl:import</code> elemanına sadece <termref def="dt-top-level">tepe-seviyeden</termref> bir eleman olarak izin verilir.</p>

<p><code>xsl:import</code> elemanının çocukları, bir <code>xsl:stylesheet</code> elemanının diğer bütün çocuklarının ve varsa <code>xsl:include</code> elemanlarının herbirinin çocuklarının öncesine geçmelidir. <code>xsl:include</code> bir biçembendi içermek üzere kullanıldığında, içerilen belgedeki <code>xsl:import</code> elemanları yine yukarıya ama, içeren belgedeki <code>xsl:import</code> elemanlarının sonrasına gider. Örnek:</p>

<eg>&lt;xsl:stylesheet version="1.0"
                xmlns:xsl="&XSLT.ns;"><![CDATA[
  <xsl:import href="article.xsl"/>
  <xsl:import href="bigfont.xsl"/>
  <xsl:attribute-set name="note-style">
    <xsl:attribute name="font-style">italic</xsl:attribute>
  </xsl:attribute-set>
</xsl:stylesheet>]]></eg>

<p><termdef id="dt-import-tree" term="İthal Ağaç"><code>xsl:import</code> elemanları içeren bir biçembentin işlenmesi sırasında karşılaşılan <code>xsl:stylesheet</code> elemanları bir <term>ithal ağaç</term> olarak ele alınır. İthal ağaçtaki her <code>xsl:stylesheet</code> elemanı, içerdiği her
<code>xsl:import</code> elemanı için bir ithal çocuğa sahip olur. <code>xsl:include</code> elemanları ithal ağaç oluşturulmadan önce çözümlenir. </termdef> <termdef id="dt-import-precedence" term="İthal Önceliği"> İthal ağaçtaki bir <code>xsl:stylesheet</code> elemanına, ithal ağacın çocuğu olarak işleme alınacak bir <code>xsl:stylesheet</code>  elemanından önce ziyaret edilmiş diğer bir <code>xsl:stylesheet</code> elemanından daha düşük bir  <term>ithal önceliği</term> tanınır. (Türkçesi, bir sülaledeki bir evlatlığın öz evlatları evlatlıklarından sonra ziyaret edilir.)</termdef>  Her tanımın ve örneklenim kuralının ithal önceliği kendini içeren <code>xsl:stylesheet</code> elemanına göre belirlenir.</p>

<p>Varsayalım,</p>

<ulist>

<item><p><var>A</var> biçembendi sırasıyla <var>B</var> ve <var>C</var> biçembentlerini ithal etmiş olsun;</p></item>

<item><p><var>B</var> biçembenti <var>D</var>'yi,</p></item>

<item><p><var>C</var> biçembendi de <var>E</var>'yi ithal etmiş olsun.</p></item>

</ulist>

<p>İthal önceliği sırası <var>D</var>, <var>B</var>, <var>E</var>, <var>C</var>,
<var>A</var> olacaktır.</p>

<note><p><code>xsl:import</code> elemanlarının herhangi bir tanım veya örneklenim kuralından önce kullanılması gerektiğinden, ithal edilen biçembentleri <code>xsl:import</code> elemanına rastlandığı noktada işleme sokan bir gerçeklenim, tanımlara ve örneklenim kurallarına artan ithal önceliğiyle rastlayacaktır.</p></note>

<p>Genel olarak, daha yüksek önceliğe sahip bir tanım veya örneklenim kuralı, daha düşük ithal önceliğine sahip bir tanım veya örneklenim kuralından öncelikli olur. Bu, her tanım veya örneklenim kuralı çeşidi için ayrı ayrı tanımlanır.</p>

<p>Bir biçembendin doğrudan veya dolaylı kendi kendini ithal ediyor olması bir hatadır. Bundan kaçınmak için, belli bir tanım-yeri ile bir biçembendin birden fazla yerde ithal edilmesi durumunda, biçembent özel olarak ele alınmaz. <termref def="dt-import-tree">İthal ağaç</termref>, ithal edildiği her noktada ayrı bir <code>xsl:stylesheet</code>'e sahip olur.</p>

<note><p>Eğer <code>xsl:apply-imports</code> kullanılmışsa (bkz, <specref
ref="apply-imports"/>), davranış, biçembendin sadece en yüksek <termref def="dt-import-precedence">ithal öncelikli</termref> yerde ithal edilmesi durumundakinden farklı olabilir.</p></note>

</div3>

</div2>

<div2>
<head>Gömülü Biçembentler</head>

<p>Normalde bir biçembent, belge elemanı <code>xsl:stylesheet</code> elemanı olan eksiksiz bir XML belgedir. Buna rağmen, bir XSLT biçembenti başka bir kaynağa da gömülebilir. İki çeşit gömülüm mümkündür:</p>

<slist>

<sitem>XSLT biçembendi XML olmayan bir kaynağa gömülebilir veya</sitem>

<sitem>XML belgenin belge elemanı <code>xsl:stylesheet</code> elemanı olmaksızın biçembent bir XML kaynağa gömülebilir.</sitem>

</slist>

<p>İkinci şeklini kolaylaştırmak için, <code>xsl:stylesheet</code> elemanının eşsiz bir betimleyici içeren bir ID özniteliğine sahip olması mümkün kılınmıştır.</p>

<note><p>Böyle bir özniteliğin XPath <xfunction>id</xfunction> işlevi ile kullanılabilmesi için gerçekten de bir ID olarak DTD'de bildirilmiş olması gerekir.</p></note>

<p>Aşağıdaki örnekte <code>xml-stylesheet</code> işlem yönergesinin <bibref ref="XMLSTYLE"/> bir belgenin kendi biçembendini içermesini mümkün kılmak için nasıl kullanılabileceği gösterilmiştir. Tanım-yeri başvurusunda <code>xsl:stylesheet</code> elemanının yeri olarak bölüm betimleyicili bir göreli tanım-yeri kullanılmıştır:</p>

<eg><![CDATA[<?xml-stylesheet type="text/xml" href="#style1"?>
<!DOCTYPE doc SYSTEM "doc.dtd">
<doc>
<head>

<xsl:stylesheet id="style1"
                version="1.0"]]>
                xmlns:xsl="&XSLT.ns;"
                xmlns:fo="&XSLFO.ns;"><![CDATA[
<xsl:import href="doc.xsl"/>
<xsl:template match="id('foo')">
  <fo:block font-weight="bold"><xsl:apply-templates/></fo:block>
</xsl:template>
<xsl:template match="xsl:stylesheet">
  <!-- ignore -->
</xsl:template>
</xsl:stylesheet>

</head>
<body>
<para id="foo">
...
</para>
</body>
</doc>
]]></eg>

<note><p>Bir biçembent, ister uygulansın, ister içerilsin, ister ithal edilsin bir belgeye gömüldüğü takdirde yoksayılacak bir <code>xsl:stylesheet</code> elemanı belirtilmiş bir örneklenim kuralının varlığını gerektirir.</p></note>

</div2>

</div1>

<div1 id="data-model">
<head>Veri Modeli</head>

<p>XSLT tarafından kullanılan veri modeli, bu bölümdeki açıklananlar dışında <xspecref href="&XPath;#data-model">XPath</xspecref> veri modeli ile aynıdır. XSLT aynı veri modelini kullanan kaynak, hedef ve biçembent belgeleri üzerinde işlem yapar. Aynı ağaca sahip herhangi iki XML belge XSLT'ye göre aynı belgedir.</p>

<p>Biçembentteki işlem yönergeleri ve açıklamalar yoksayılır: biçembent, ağacında ne işlem yönergesi (İng: processing instruction) ne de açıklama varmış gibi ele alınır.</p>

<div2 id="root-node-children">
<head>Kök Düğümün Çocukları</head>

<p>Kök düğümün çocukları üzerindeki normal kısıtlamalar hedef ağaç için esnetilir.  Hedef ağacın çocukları bir eleman düğümü için olası herhangi bir sırada olabilir. Özellikle, metin düğümü çocuklara sahip olabileceği gibi istenen sayıda eleman düğümü çocuğa sahip olabilir. <code>xsl:output</code> yöntemi (bkz, <specref ref="output"/>) XML çıktı için kullanıldığında hedef ağacın iyi biçimlenmiş bir XML belgesi olması gerekmeyebilir; yine de, çıktı daima iyi biçimlenmiş haricen çözümlenebilir bir öğe olacaktır.</p>

<p>Kaynak ağacı iyi biçimlenmiş bir XML belge çözümlenerek oluşturulduğunda, kaynak ağacın kök düğümü, bir metin düğümüne sahip olmamak ve tek bir çocuk elemana sahip olmak gibi normal kısıtlamaları kendiliğinden yerine getirecektir. Kaynak ağacı, DOM kullanımı gibi başka bir yöntemle oluşturulduğunda geçerli kısıtlamalar kaynak ağaç için hedef ağaçtaki kadar esnektir.</p>

</div2>

<div2 id="base-uri">
<head>Temel Tanım-yeri</head>

<p>Her düğümün kendisiyle ilişkili tanım-yerine o düğümün <kw>temel tanım-yeri</kw> denir ve göreli tanım-yerlerini mutlak tanım-yerleri haline getirmek için öznitelik değerlerini çözümlemekte kullanılır. Eğer bir eleman veya işlem yönergesi harici bir öğe içinde yer alıyorsa, bu elemanın veya işlem yönergesinin temel tanım-yeri harici öğenin tanım-yeri olur; aksi takdirde, temel tanım-yeri, belgenin tanım-yeridir. Belge düğümünün temel tanım-yeri belge öğesinin tanım-yeridir. Bir metin, açıklama, öznitelik veya bir isim-alanı düğümümünün temel tanım-yeri ise, ata düğümün temel tanım-yeridir.</p>

</div2>

<div2 id="unparsed-entities">
<head>Çözümlenmemiş Öğeler</head>

<p>Kök düğüm, belgenin DTD'sinde bildirilmiş her çözümlenmemiş öğe için tanım-yeri veren bir eşleme sahiptir. Tanım-yeri, öğe (<code>&lt;!ENTITY</code>) bildirimindeki <code>SYSTEM</code> ve <code>PUBLIC</code> belirteçlerinin değerlerinden üretilir. XSLT işlemci, tanım-yerini üretmek için <code>SYSTEM</code> belirtecinde belirtilen tanım-yeri yerine <code>PUBLIC</code> belirtecinde belirtileni kullanabilir. Eğer XSLT işlemci tanım-yerini üretmek için <code>PUBLIC</code> belirtecinde belirtileni kullanmıyorsa, <code>SYSTEM</code> belirtecinde belirtileni kullanmalıdır; eğer <code>SYSTEM</code> belirtecinde belirtilen bir göreli tanım-yeri ise, temel tanım-yeri <bibref ref="RFC2396"/> olarak öğe bildirimini içeren kaynağın tanım-yerini kullanarak onu bir mutlak tanım-yeri olarak çözümlemelidir.</p>

</div2>

<div2 id="strip">
<head>Boşluk Ayıklama</head>

<p>Kaynak belge veya biçembent belgesi için ağaç oluşturulup, XSLT tarafından bir şekilde işleme sokulmadan önce bazı metin düğümleri ayıklanabilir. Bir metin düğümü salt boşluk karakterlerini içeriyor olmadıkça asla ayıklanamaz. Metin düğümünün ayıklanması metin düğümünü ağaçtan siler. Ayıklama işleminde boşlukları korunması gereken elemanların isimlerinden oluşan bir küme girdi olarak alınır. Ayıklama işlemi biçembentlerin ve kaynak belgelerin her ikisine de uygulanır, ancak boşlukları korunması gereken elemanlar saptanırken uygulama farklı olur.</p>

<p>Aşağıdakilerin herhangi biri uygulanabiliyorsa bir metin düğümü korunur:</p>

<ulist>

<item><p>Metin düğümünün atasının eleman ismi boşlukları korunması gereken eleman isimleri arasındadır.</p></item>

<item><p>Metin düğümü en azından bir tane boşluk olmayan karakter içeriyordur. XML'deki gibi, bir boşluk karakteri <code>#x20</code>, <code>#x9</code>, <code>#xD</code> veya <code>#xA</code> olabilir.</p></item>

<item><p>Bir metin düğümünün bir üstküme (İng: ancestor) elemanı <code>preserve</code> değerli bir <code>xml:space</code> özniteliğine sahiptir ve üstküme elemanları arasında <code>default</code> değerli bir <code>xml:space</code> özniteliğine sahip eleman hiç yoktur.</p></item>

</ulist>

<p>Aksi takdirde, metin düğümü ayıklanır.</p>

<p><code>xml:space</code> öznitelikleri ağaçtan ayıklanmaz.</p>

<note><p>Eğer bir birebir sonuç elemanında bir <code>xml:space</code> özniteliği belirtilmişse, bu uygulanır ve sonuç özniteliği içerir.</p></note>

<p>Biçembentler bakımından, boşlukları korunması gereken eleman isimleri kümesi sadece <code>xsl:text</code> içerir.</p>

<e:element-syntax name="strip-space">
  <e:in-category name="tepe-seviyeden-eleman"/>
  <e:attribute name="elements" required="yes">
    <e:data-type name="dizgecikler"/>
  </e:attribute>
  <e:empty/>
</e:element-syntax>

<e:element-syntax name="preserve-space">
  <e:in-category name="tepe-seviyeden-eleman"/>
  <e:attribute name="elements" required="yes">
    <e:data-type name="dizgecikler"/>
  </e:attribute>
  <e:empty/>
</e:element-syntax>

<p>Kaynak belgeler için, boşlukları korunması gereken eleman isimleri <termref
def="dt-top-level">tepe-seviyeden</termref> elemanlar olan <code>xsl:strip-space</code> ve <code>xsl:preserve-space</code> ile belirtilir. Bu elemanların ikisi de değeri boşluk ayraçlı <xnt
href="&XPath;#NT-NameTest">İsimSınaması</xnt> listesi olan birer <code>elements</code> özniteliğine sahiptir. Başlangıç olarak, boşlukları korunması gereken isimler kümesi bütün eleman isimlerini içerir. Eğer bir eleman bir <code>xsl:strip-space</code> elemanındaki bir
<xnt href="&XPath;#NT-NameTest">İsimSınaması</xnt> ile eşleşiyorsa, boşlukları korunması gereken isimler kümesinden silinir. Eğer bir eleman bir <code>xsl:preserve-space</code> elemanındaki bir <xnt
href="&XPath;#NT-NameTest">İsimSınaması</xnt> ile eşleşiyorsa, boşlukları korunması gereken isimler kümesine eklenir. Bir elemanın <xnt href="&XPath;#NT-NameTest">İsimSınaması</xnt> ile eşleşebilmesi için sadece ve sadece, eleman için bir <xspecref href="&XPath;#node-tests">XPath düğüm sınaması</xspecref> olarak <xnt
href="&XPath;#NT-NameTest">İsimSınaması</xnt>nın doğru olması gerekir. <code>xsl:strip-space</code> ve <code>xsl:preserve-space</code> elemanları arasındaki eşleşme uyuşmazlıkları, örneklenim kuralları arasındaki uyuşmazlıklara uygulanan yöntemle çözülür (bkz,  <specref ref="conflict"/>). Sonuç olarak, belli bir eleman ismi için uygun eşleşme şöyle saptanır:</p>

<ulist>

<item><p>Önce, diğer eşleşmeden daha düşük <termref
def="dt-import-precedence">ithal önceliğine</termref> sahip eşleşmeler yoksayılır.</p></item>

<item><p>Sonra, diğer eşleşmenin <xnt
href="&XPath;#NT-NameTest">İsimSınaması</xnt>nın <termref def="dt-default-priority">öntanımlı önceliğinden</termref> düşük <termref def="dt-default-priority">öntanımlı öncelikli </termref> <xnt href="&XPath;#NT-NameTest"> İsimSınaması</xnt>na sahip eşleşmeler yoksayılır.</p></item>

</ulist>

<p>Eğer bu yöntemle geriye birden fazla eşleşme kalırsa bu bir hatadır. Bir XSLT işlemci hatayı bildirebilir; eğer bildirmiyorsa, kalan eşleşmeler arasından biçembentte sona doğru yer alanını seçerek hatayı bertaraf etmelidir.</p>

</div2>

</div1>

<div1>
<head>İfadeler</head>

<p>XSLT, XPath <bibref ref="XPATH"/> tarafından tanımlanmış ifade dilini kullanır. XSLT'de ifadeler aşağıdaki amaçlar dahil çeşitli amaçlarla kullanılırlar:</p>

<slist>
<sitem>İşlem için düğümlerin seçimi;</sitem>
<sitem>bir düğümü farklı yollarla işlemek için koşulların belirtilmesi;</sitem>
<sitem>hedef ağaca yerleştirilecek metnin üretilmesi.</sitem>
</slist>

<p><termdef id="dt-expression" term="Expression">Bir <term>ifade</term> bir XPath ürünü olan <xnt href="&XPath;#NT-Expr">İfade</xnt> ile eşleşmelidir.</termdef></p>

<p>İfadeler, XSLT tarafından tanımlanmış elemanların belirli özniteliklerinin değerlerinde ve <termref
def="dt-attribute-value-template">öznitelik değeri örneklenimlerinde</termref> kaşlı ayraçların arasında karşımıza çıkarlar.</p>

<p>XSLT'de bağımsız (başka bir ifadenin parçası olmayan) bir ifadenin bağlamı şöyle oluşur:</p>

<ulist>

<item><p>Bağlam düğümü <termref def="dt-current-node">geçerli düğümden</termref> gelir.</p></item>

<item><p>Bağlam konumu, <termref def="dt-current-node-list">geçerli düğüm listesi</termref>ndeki <termref
def="dt-current-node">geçerli düğüm</termref>ün konumundan gelir ve ilk konum 1'dir.</p></item>

<item><p>Bağlam boyu, <termref def="dt-current-node-list">geçerli düğüm listesinin</termref> boyutundan gelir.</p></item>

<item><p>Değişken bağlantıları, ifadeyi içeren özniteliğe sahip elemanın etki alanındaki bağlantılardır (bkz, <specref ref="variables"/>).</p></item>

<item><p>İsim-alanı bildirimleri kümesi, ifadeyi içeren özniteliğe sahip elemanın etki alanındaki bildirimlerdir; bu, XML İsim-alanları Önergesi'nce <bibref ref="XMLNAMES"/> gereken <code>xml</code> önekinin örtük bildirimini de içerir; öntanımlı isim-alanı (<code>xmlns</code> tarafından bildirilmiş olarak) bu kümenin bir parçası değildir.</p></item>

<item><p>İşlev kütüphanesi,  temel işlev kütüphanesine ek olarak  <specref
ref="add-func"/> bölümünde tanımlanmış işlevler ile  <specref
ref="extension"/> bölümünde açıklanan ek işlevlerden oluşur; bir ifadeden bunlar dışında bir işleve yapılan bir çağrı bir hatadır.</p></item>

</ulist>

</div1>

<div1 id="rules">
<head>Örneklenim Kuralları</head>

<div2>
<head>İşlem Modeli</head>

<p>A list of source nodes is processed to create a result tree
fragment.  The result tree is constructed by processing a list
containing just the root node.  A list of source nodes is processed by
appending the result tree structure created by processing each of the
members of the list in order.  A node is processed by finding all the
template rules with patterns that match the node, and choosing the
best amongst them; the chosen rule's template is then instantiated
with the node as the <termref def="dt-current-node">current
node</termref> and with the list of source nodes as the <termref
def="dt-current-node-list">current node list</termref>.  A template
typically contains instructions that select an additional list of
source nodes for processing.  The process of matching, instantiation
and selection is continued recursively until no new source nodes are
selected for processing.</p>

<p>Implementations are free to process the source document in any way
that produces the same result as if it were processed using this
processing model.</p>

</div2>

<div2 id="patterns">
<head>Patterns</head>

<p><termdef id="dt-pattern" term="Pattern">Template rules identify the
nodes to which they apply by using a <term>pattern</term>.  As well as
being used in template rules, patterns are used for numbering (see
<specref ref="number"/>) and for declaring keys (see <specref
ref="key"/>).  A pattern specifies a set of conditions on a node.  A
node that satisfies the conditions matches the pattern; a node that
does not satisfy the conditions does not match the pattern.  The
syntax for patterns is a subset of the syntax for expressions. In
particular, location paths that meet certain restrictions can be used
as patterns.  An expression that is also a pattern always evaluates to
an object of type node-set.  A node matches a pattern if the node is a
member of the result of evaluating the pattern as an expression with
respect to some possible context; the possible contexts are those
whose context node is the node being matched or one of its
ancestors.</termdef></p>

<p>Here are some examples of patterns:</p>

<ulist>

<item><p><code>para</code> matches any <code>para</code> element</p></item>

<item><p><code>*</code> matches any element</p></item>

<item><p><code>chapter|appendix</code> matches any
<code>chapter</code> element and any <code>appendix</code>
element</p></item>

<item><p><code>olist/item</code> matches any <code>item</code> element with
an <code>olist</code> parent</p></item>

<item><p><code>appendix//para</code> matches any <code>para</code> element with
an <code>appendix</code> ancestor element</p></item>

<item><p><code>/</code> matches the root node</p></item>

<item><p><code>text()</code> matches any text node</p></item>

<item><p><code>processing-instruction()</code> matches any processing
instruction</p></item>

<item><p><code>node()</code> matches any node other than an attribute
node and the root node</p></item>

<item><p><code>id("W11")</code> matches the element with unique ID
<code>W11</code></p></item>

<item><p><code>para[1]</code> matches any <code>para</code> element
that is the first <code>para</code> child element of its
parent</p></item>

<item><p><code>*[position()=1 and self::para]</code> matches any
<code>para</code> element that is the first child element of its
parent</p></item>

<item><p><code>para[last()=1]</code> matches any <code>para</code>
element that is the only <code>para</code> child element of its
parent</p></item>

<item><p><code>items/item[position()>1]</code> matches any
<code>item</code> element that has a <code>items</code> parent and
that is not the first <code>item</code> child of its parent</p></item>

<item><p><code>item[position() mod 2 = 1]</code> would be true for any
<code>item</code> element that is an odd-numbered <code>item</code>
child of its parent.</p></item>

<item><p><code>div[@class="appendix"]//p</code> matches any
<code>p</code> element with a <code>div</code> ancestor element that
has a <code>class</code> attribute with value
<code>appendix</code></p></item>

<item><p><code>@class</code> matches any <code>class</code> attribute
(<emph>not</emph> any element that has a <code>class</code>
attribute)</p></item>

<item><p><code>@*</code> matches any attribute</p></item>

</ulist>

<p>A pattern must match the grammar for <nt
def="NT-Pattern">Pattern</nt>.  A <nt def="NT-Pattern">Pattern</nt> is
a set of location path patterns separated by <code>|</code>.  A
location path pattern is a location path whose steps all use only the
<code>child</code> or <code>attribute</code> axes.  Although patterns
must not use the <code>descendant-or-self</code> axis, patterns may
use the <code>//</code> operator as well as the <code>/</code>
operator.  Location path patterns can also start with an
<xfunction>id</xfunction> or <function>key</function> function call
with a literal argument.  Predicates in a pattern can use arbitrary
expressions just like predicates in a location path.</p>

<scrap>
<head>Patterns</head>
<prodgroup pcw5="1" pcw2="10">
<prod id="NT-Pattern">
<lhs>Pattern</lhs>
<rhs><nt def="NT-LocationPathPattern">LocationPathPattern</nt></rhs>
<rhs>| <nt def="NT-Pattern">Pattern</nt> '|' <nt def="NT-LocationPathPattern">LocationPathPattern</nt></rhs>
</prod>
<prod id="NT-LocationPathPattern">
<lhs>LocationPathPattern</lhs>
<rhs>'/' <nt def="NT-RelativePathPattern">RelativePathPattern</nt>?</rhs>
<rhs>| <nt def="NT-IdKeyPattern">IdKeyPattern</nt> (('/' | '//') <nt def="NT-RelativePathPattern">RelativePathPattern</nt>)?</rhs>
<rhs>| '//'? <nt def="NT-RelativePathPattern">RelativePathPattern</nt></rhs>
</prod>
<prod id="NT-IdKeyPattern">
<lhs>IdKeyPattern</lhs>
<rhs>'id' '(' <xnt href="&XPath;#NT-Literal">Literal</xnt> ')'</rhs>
<rhs>| 'key' '(' <xnt href="&XPath;#NT-Literal">Literal</xnt> ',' <xnt href="&XPath;#NT-Literal">Literal</xnt> ')'</rhs>
</prod>
<prod id="NT-RelativePathPattern">
<lhs>RelativePathPattern</lhs>
<rhs><nt def="NT-StepPattern">StepPattern</nt></rhs>
<rhs>| <nt def="NT-RelativePathPattern">RelativePathPattern</nt> '/' <nt def="NT-StepPattern">StepPattern</nt></rhs>
<rhs>| <nt def="NT-RelativePathPattern">RelativePathPattern</nt> '//' <nt def="NT-StepPattern">StepPattern</nt></rhs>
</prod>
<prod id="NT-StepPattern">
<lhs>StepPattern</lhs>
<rhs>
<nt def="NT-ChildOrAttributeAxisSpecifier">ChildOrAttributeAxisSpecifier</nt>
<xnt href="&XPath;#NT-NodeTest">NodeTest</xnt>
<xnt href="&XPath;#NT-Predicate">Predicate</xnt>*
</rhs>
</prod>
<prod id="NT-ChildOrAttributeAxisSpecifier">
<lhs>ChildOrAttributeAxisSpecifier</lhs>
<rhs><xnt href="&XPath;#NT-AbbreviatedAxisSpecifier">AbbreviatedAxisSpecifier</xnt></rhs>
<rhs>| ('child' | 'attribute') '::'</rhs>
</prod>
</prodgroup>
</scrap>

<p>A pattern is defined to match a node if and only if there is
possible context such that when the pattern is evaluated as an
expression with that context, the node is a member of the resulting
node-set.  When a node is being matched, the possible contexts have a
context node that is the node being matched or any ancestor of that
node, and a context node list containing just the context node.</p>

<p>For example, <code>p</code> matches any <code>p</code> element,
because for any <code>p</code> if the expression <code>p</code> is
evaluated with the parent of the <code>p</code> element as context the
resulting node-set will contain that <code>p</code> element as one of
its members.</p>

<note><p>This matches even a <code>p</code> element that is the
document element, since the document root is the parent of the
document element.</p></note>

<p>Although the semantics of patterns are specified indirectly in
terms of expression evaluation, it is easy to understand the meaning
of a pattern directly without thinking in terms of expression
evaluation.  In a pattern, <code>|</code> indicates alternatives; a
pattern with one or more <code>|</code> separated alternatives matches
if any one of the alternative matches.  A pattern that consists of a
sequence of <nt def="NT-StepPattern">StepPattern</nt>s separated by
<code>/</code> or <code>//</code> is matched from right to left.  The
pattern only matches if the rightmost <nt
def="NT-StepPattern">StepPattern</nt> matches and a suitable element
matches the rest of the pattern; if the separator is <code>/</code>
then only the parent is a suitable element; if the separator is
<code>//</code>, then any ancestor is a suitable element.  A <nt
def="NT-StepPattern">StepPattern</nt> that uses the child axis matches
if the <xnt href="&XPath;#NT-NodeTest">NodeTest</xnt> is true for the
node and the node is not an attribute node.  A <nt
def="NT-StepPattern">StepPattern</nt> that uses the attribute axis
matches if the <xnt href="&XPath;#NT-NodeTest">NodeTest</xnt> is true
for the node and the node is an attribute node.  When <code>[]</code>
is present, then the first <xnt
href="&XPath;#NT-PredicateExpr">PredicateExpr</xnt> in a <nt
def="NT-StepPattern">StepPattern</nt> is evaluated with the node being
matched as the context node and the siblings of the context node that
match the <xnt href="&XPath;#NT-NodeTest">NodeTest</xnt> as the
context node list, unless the node being matched is an attribute node,
in which case the context node list is all the attributes that have
the same parent as the attribute being matched and that match the <xnt
href="&XPath;#NT-NameTest">NameTest</xnt>.</p>

<p>For example</p>

<eg>appendix//ulist/item[position()=1]</eg>

<p>matches a node if and only if all of the following are true:</p>

<ulist>

<item><p>the <xnt href="&XPath;#NT-NodeTest">NodeTest</xnt> <code>item</code> is
true for the node and the node is not an attribute; in other words the
node is an <code>item</code> element</p></item>

<item><p>evaluating the <xnt href="&XPath;#NT-PredicateExpr">PredicateExpr</xnt>
<code>position()=1</code> with the node as context node and the
siblings of the node that are <code>item</code> elements as the
context node list yields true</p></item>

<item><p>the node has a parent that matches
<code>appendix//ulist</code>; this will be true if the parent is a
<code>ulist</code> element that has an <code>appendix</code> ancestor
element.</p></item>

</ulist>

</div2>

<div2>
<head>Defining Template Rules</head>

<e:element-syntax name="template">
  <e:in-category name="tepe-seviyeden-eleman"/>
  <e:attribute name="match">
    <e:data-type name="pattern"/>
  </e:attribute>
  <e:attribute name="name">
    <e:data-type name="qname"/>
  </e:attribute>
  <e:attribute name="priority">
    <e:data-type name="sayı"/>
  </e:attribute>
  <e:attribute name="mode">
    <e:data-type name="qname"/>
  </e:attribute>
  <e:sequence>
    <e:element repeat="zero-or-more" name="param"/>
    <e:model name="template"/>
  </e:sequence>
</e:element-syntax>

<p>A template rule is specified with the <code>xsl:template</code>
element. The <code>match</code> attribute is a <nt
def="NT-Pattern">Pattern</nt> that identifies the source node or nodes
to which the rule applies.  The <code>match</code> attribute is
required unless the <code>xsl:template</code> element has a
<code>name</code> attribute (see <specref ref="named-templates"/>).
It is an error for the value of the <code>match</code> attribute to
contain a <xnt
href="&XPath;#NT-VariableReference">VariableReference</xnt>. The
content of the <code>xsl:template</code> element is the template that
is instantiated when the template rule is applied.</p>

<p>For example, an XML document might contain:</p>

<eg><![CDATA[This is an <emph>important</emph> point.]]></eg>

<p>The following template rule matches <code>emph</code> elements and
produces a <code>fo:inline-sequence</code> formatting object with a
<code>font-weight</code> property of <code>bold</code>.</p>

<eg><![CDATA[<xsl:template match="emph">
  <fo:inline-sequence font-weight="bold">
    <xsl:apply-templates/>
  </fo:inline-sequence>
</xsl:template>
]]></eg>

<note><p>Examples in this document use the <code>fo:</code> prefix for
the namespace <code>&XSLFO.ns;</code>, which is
the namespace of the formatting objects defined in <bibref
ref="XSL"/>.</p></note>

<p>As described next, the <code>xsl:apply-templates</code> element
recursively processes the children of the source element.</p>

</div2>

<div2>
<head>Applying Template Rules</head>

<e:element-syntax name="apply-templates">
  <e:in-category name="instruction"/>
  <e:attribute name="select">
    <e:data-type name="node-set-expression"/>
  </e:attribute>
  <e:attribute name="mode">
    <e:data-type name="qname"/>
  </e:attribute>
  <e:choice repeat="zero-or-more">
    <e:element name="sort"/>
    <e:element name="with-param"/>
  </e:choice>
</e:element-syntax>

<p>This example creates a block for a <code>chapter</code> element and
then processes its immediate children.</p>

<eg><![CDATA[<xsl:template match="chapter">
  <fo:block>
    <xsl:apply-templates/>
  </fo:block>
</xsl:template>]]></eg>

<p>In the absence of a <code>select</code> attribute, the
<code>xsl:apply-templates</code> instruction processes all of the
children of the current node, including text nodes.  However, text
nodes that have been stripped as specified in <specref ref="strip"/>
will not be processed.  If stripping of whitespace nodes has not been
enabled for an element, then all whitespace in the content of the
element will be processed as text, and thus whitespace
between child elements will count in determining the position of a
child element as returned by the <xfunction>position</xfunction>
function.</p>

<p>A <code>select</code> attribute can be used to process nodes
selected by an expression instead of processing all children.  The
value of the <code>select</code> attribute is an <termref
def="dt-expression">expression</termref>.  The expression must
evaluate to a node-set.  The selected set of nodes is processed in
document order, unless a sorting specification is present (see
<specref ref="sorting"/>).  The following example processes all of the
<code>author</code> children of the <code>author-group</code>:</p>

<eg><![CDATA[<xsl:template match="author-group">
  <fo:inline-sequence>
    <xsl:apply-templates select="author"/>
  </fo:inline-sequence>
</xsl:template>]]></eg>

<p>The following example processes all of the <code>given-name</code>s
of the <code>author</code>s that are children of
<code>author-group</code>:</p>

<eg><![CDATA[<xsl:template match="author-group">
  <fo:inline-sequence>
    <xsl:apply-templates select="author/given-name"/>
  </fo:inline-sequence>
</xsl:template>]]></eg>

<p>This example processes all of the <code>heading</code> descendant
elements of the <code>book</code> element.</p>

<eg><![CDATA[<xsl:template match="book">
  <fo:block>
    <xsl:apply-templates select=".//heading"/>
  </fo:block>
</xsl:template>]]></eg>

<p>It is also possible to process elements that are not descendants of
the current node.  This example assumes that a <code>department</code>
element has <code>group</code> children and <code>employee</code>
descendants. It finds an employee's department and then processes
the <code>group</code> children of the <code>department</code>.</p>

<eg><![CDATA[<xsl:template match="employee">
  <fo:block>
    Employee <xsl:apply-templates select="name"/> belongs to group
    <xsl:apply-templates select="ancestor::department/group"/>
  </fo:block>
</xsl:template>]]></eg>

<p>Multiple <code>xsl:apply-templates</code> elements can be used within a
single template to do simple reordering.  The following example
creates two HTML tables. The first table is filled with domestic sales
while the second table is filled with foreign sales.</p>

<eg><![CDATA[<xsl:template match="product">
  <table>
    <xsl:apply-templates select="sales/domestic"/>
  </table>
  <table>
    <xsl:apply-templates select="sales/foreign"/>
  </table>
</xsl:template>]]></eg>

<note>

<p>It is possible for there to be two matching descendants where one
is a descendant of the other.  This case is not treated specially:
both descendants will be processed as usual. For example, given a
source document</p>

<eg><![CDATA[<doc><div><div></div></div></doc>]]></eg>

<p>the rule</p>

<eg><![CDATA[<xsl:template match="doc">
  <xsl:apply-templates select=".//div"/>
</xsl:template>]]></eg>

<p>will process both the outer <code>div</code> and inner <code>div</code>
elements.</p>

</note>

<note><p>Typically, <code>xsl:apply-templates</code> is used to
process only nodes that are descendants of the current node.  Such use
of <code>xsl:apply-templates</code> cannot result in non-terminating
processing loops.  However, when <code>xsl:apply-templates</code> is
used to process elements that are not descendants of the current node,
the possibility arises of non-terminating loops. For example,</p>

<eg role="error"><![CDATA[<xsl:template match="foo">
  <xsl:apply-templates select="."/>
</xsl:template>]]></eg>

<p>Implementations may be able to detect such loops in some cases, but
the possibility exists that a stylesheet may enter a non-terminating
loop that an implementation is unable to detect. This may present a
denial of service security risk.</p></note>

</div2>

<div2 id="conflict">
<head>Conflict Resolution for Template Rules</head>

<p>It is possible for a source node to match more than one template
rule. The template rule to be used is determined as follows:</p>

<olist>

<item><p>First, all matching template rules that have lower <termref
def="dt-import-precedence">import precedence</termref> than the
matching template rule or rules with the highest import precedence are
eliminated from consideration.</p></item>

<item><p>Next, all matching template rules that have lower priority
than the matching template rule or rules with the highest priority are
eliminated from consideration.  The priority of a template rule is
specified by the <code>priority</code> attribute on the template rule.
The value of this must be a real number (positive or negative),
matching the production <xnt href="&XPath;#NT-Number">Number</xnt>
with an optional leading minus sign (<code>-</code>).  <termdef
id="dt-default-priority" term="Default Priority">The <term>default
priority</term> is computed as follows:</termdef></p>

<ulist>

<item><p>If the pattern contains multiple alternatives separated by
<code>|</code>, then it is treated equivalently to a set of template
rules, one for each alternative.</p></item>

<item><p>If the pattern has the form of a <xnt
href="&XMLNames;#NT-QName">QName</xnt> preceded by a <nt
def="NT-ChildOrAttributeAxisSpecifier">ChildOrAttributeAxisSpecifier</nt>
or has the form
<code>processing-instruction(</code><xnt href="&XPath;#NT-Literal"
>Literal</xnt><code>)</code> preceded by a <nt
def="NT-ChildOrAttributeAxisSpecifier">ChildOrAttributeAxisSpecifier</nt>,
then the priority is 0.</p></item>

<item><p>If the pattern has the form <xnt
href="&XMLNames;#NT-NCName">NCName</xnt><code>:*</code> preceded by a
<nt
def="NT-ChildOrAttributeAxisSpecifier">ChildOrAttributeAxisSpecifier</nt>,
then the priority is -0.25.</p></item>

<item><p>Otherwise, if the pattern consists of just a <xnt
href="&XPath;#NT-NodeTest">NodeTest</xnt> preceded by a <nt
def="NT-ChildOrAttributeAxisSpecifier">ChildOrAttributeAxisSpecifier</nt>,
then the priority is -0.5.</p></item>

<item><p>Otherwise, the priority is 0.5.</p></item>

</ulist>

<p>Thus, the most common kind of pattern (a pattern that tests for a
node with a particular type and a particular expanded-name) has
priority 0. The next less specific kind of pattern (a pattern that
tests for a node with a particular type and an expanded-name with a
particular namespace URI) has priority -0.25.  Patterns less specific
than this (patterns that just tests for nodes with particular types)
have priority -0.5.  Patterns more specific than the most common kind
of pattern have priority 0.5.</p>

</item>

</olist>

<p>It is an error if this leaves more than one matching template
rule.  An XSLT processor may signal the error; if it does not signal
the error, it must recover by choosing, from amongst the matching
template rules that are left, the one that occurs last in the
stylesheet.</p>

</div2>

<div2 id="apply-imports">
<head>Overriding Template Rules</head>

<e:element-syntax name="apply-imports">
  <e:in-category name="instruction"/>
  <e:empty/>
</e:element-syntax>

<p>A template rule that is being used to override a template rule in
an imported stylesheet (see <specref ref="conflict"/>) can use the
<code>xsl:apply-imports</code> element to invoke the overridden
template rule.</p>

<p><termdef id="dt-current-template-rule" term="Current Template
Rule">At any point in the processing of a stylesheet, there is a
<term>current template rule</term>.  Whenever a template rule is
chosen by matching a pattern, the template rule becomes the current
template rule for the instantiation of the rule's template. When an
<code>xsl:for-each</code> element is instantiated, the current
template rule becomes null for the instantiation of the content of the
<code>xsl:for-each</code> element.</termdef></p>

<p><code>xsl:apply-imports</code> processes the current node using
only template rules that were imported into the stylesheet element
containing the current template rule; the node is processed in the
current template rule's mode.  It is an error if
<code>xsl:apply-imports</code> is instantiated when the current
template rule is null.</p>

<p>For example, suppose the stylesheet <code>doc.xsl</code> contains a
template rule for <code>example</code> elements:</p>

<eg><![CDATA[<xsl:template match="example">
  <pre><xsl:apply-templates/></pre>
</xsl:template>]]></eg>

<p>Another stylesheet could import <code>doc.xsl</code> and modify the
treatment of <code>example</code> elements as follows:</p>

<eg><![CDATA[<xsl:import href="doc.xsl"/>

<xsl:template match="example">
  <div style="border: solid red">
     <xsl:apply-imports/>
  </div>
</xsl:template>]]></eg>

<p>The combined effect would be to transform an <code>example</code>
into an element of the form:</p>

<eg><![CDATA[<div style="border: solid red"><pre>...</pre></div>]]></eg>

</div2>

<div2 id="modes">
<head>Modes</head>

<p>Modes allow an element to be processed multiple times, each time
producing a different result.</p>

<p>Both <code>xsl:template</code> and <code>xsl:apply-templates</code>
have an optional <code>mode</code> attribute.  The value of the
<code>mode</code> attribute is a <xnt
href="&XMLNames;#NT-QName">QName</xnt>, which is expanded as described
in <specref ref="qname"/>. If <code>xsl:template</code> does not have
a <code>match</code> attribute, it must not have a <code>mode</code>
attribute.  If an <code>xsl:apply-templates</code> element has a
<code>mode</code> attribute, then it applies only to those template
rules from <code>xsl:template</code> elements that have a
<code>mode</code> attribute with the same value; if an
<code>xsl:apply-templates</code> element does not have a
<code>mode</code> attribute, then it applies only to those template
rules from <code>xsl:template</code> elements that do not have a
<code>mode</code> attribute.</p>

</div2>

<div2 id="built-in-rule">
<head>Built-in Template Rules</head>

<p>There is a built-in template rule to allow recursive processing to
continue in the absence of a successful pattern match by an explicit
template rule in the stylesheet.  This template rule applies to both
element nodes and the root node.  The following shows the equivalent
of the built-in template rule:</p>

<eg><![CDATA[<xsl:template match="*|/">
  <xsl:apply-templates/>
</xsl:template>]]></eg>

<p>There is also a built-in template rule for each mode, which allows
recursive processing to continue in the same mode in the absence of a
successful pattern match by an explicit template rule in the
stylesheet.  This template rule applies to both element nodes and the
root node.  The following shows the equivalent of the built-in
template rule for mode <code><var>m</var></code>.</p>

<eg>&lt;xsl:template match="*|/" mode="<var>m</var>">
  &lt;xsl:apply-templates mode="<var>m</var>"/>
&lt;/xsl:template></eg>

<p>There is also a built-in template rule for text and attribute nodes
that copies text through:</p>

<eg><![CDATA[<xsl:template match="text()|@*">
  <xsl:value-of select="."/>
</xsl:template>]]></eg>

<p>The built-in template rule for processing instructions and comments
is to do nothing.</p>

<eg><![CDATA[<xsl:template match="processing-instruction()|comment()"/>]]></eg>

<p>The built-in template rule for namespace nodes is also to do
nothing. There is no pattern that can match a namespace node; so, the
built-in template rule is the only template rule that is applied for
namespace nodes.</p>

<p>The built-in template rules are treated as if they were imported
implicitly before the stylesheet and so have lower <termref
def="dt-import-precedence">import precedence</termref> than all other
template rules.  Thus, the author can override a built-in template
rule by including an explicit template rule.</p>

</div2>


</div1>

<div1 id="named-templates">
<head>Named Templates</head>

<e:element-syntax name="call-template">
  <e:in-category name="instruction"/>
  <e:attribute name="name" required="yes">
    <e:data-type name="qname"/>
  </e:attribute>
  <e:element repeat="zero-or-more" name="with-param"/>
</e:element-syntax>

<p>Templates can be invoked by name.  An <code>xsl:template</code>
element with a <code>name</code> attribute specifies a named template.
The value of the <code>name</code> attribute is a <xnt
href="&XMLNames;#NT-QName">QName</xnt>, which is expanded as described
in <specref ref="qname"/>. If an <code>xsl:template</code> element has
a <code>name</code> attribute, it may, but need not, also have a
<code>match</code> attribute.  An <code>xsl:call-template</code>
element invokes a template by name; it has a required
<code>name</code> attribute that identifies the template to be
invoked.  Unlike <code>xsl:apply-templates</code>,
<code>xsl:call-template</code> does not change the current node or the
current node list.</p>

<p>The <code>match</code>, <code>mode</code> and <code>priority</code> attributes on an
<code>xsl:template</code> element do not affect whether the template
is invoked by an <code>xsl:call-template</code> element.  Similarly,
the <code>name</code> attribute on an <code>xsl:template</code>
element does not affect whether the template is invoked by an
<code>xsl:apply-templates</code> element.</p>

<p>It is an error if a stylesheet contains more than one template with
the same name and same <termref def="dt-import-precedence">import
precedence</termref>.</p>

</div1>


<div1>
<head>Creating the Result Tree</head>

<p>This section describes instructions that directly create nodes in
the result tree.</p>

<div2>
<head>Creating Elements and Attributes</head>

<div3 id="literal-result-element">
<head>Literal Result Elements</head>

<p>In a template, an element in the stylesheet that does not belong to
the XSLT namespace and that is not an extension element (see <specref
ref="extension-element"/>) is instantiated to create an element node
with the same <xtermref
href="&XPath;#dt-expanded-name">expanded-name</xtermref>.  The content
of the element is a template, which is instantiated to give the
content of the created element node. The created element node will
have the attribute nodes that were present on the element node in the
stylesheet tree, other than attributes with names in the XSLT
namespace.</p>

<p>The created element node will also have a copy of the namespace
nodes that were present on the element node in the stylesheet tree
with the exception of any namespace node whose string-value is the
XSLT namespace URI (<code>&XSLT.ns;</code>), a
namespace URI declared as an extension namespace (see <specref
ref="extension-element"/>), or a namespace URI designated as an
excluded namespace.  A namespace URI is designated as an excluded
namespace by using an <code>exclude-result-prefixes</code> attribute
on an <code>xsl:stylesheet</code> element or an
<code>xsl:exclude-result-prefixes</code> attribute on a literal result
element.  The value of both these attributes is a whitespace-separated
list of namespace prefixes. The namespace bound to each of the
prefixes is designated as an excluded namespace.  It is an error if
there is no namespace bound to the prefix on the element bearing the
<code>exclude-result-prefixes</code> or
<code>xsl:exclude-result-prefixes</code> attribute.  The default
namespace (as declared by <code>xmlns</code>) may be designated as an
excluded namespace by including <code>#default</code> in the list of
namespace prefixes.  The designation of a namespace as an excluded
namespace is effective within the subtree of the stylesheet rooted at
the element bearing the <code>exclude-result-prefixes</code> or
<code>xsl:exclude-result-prefixes</code> attribute;
a subtree rooted at an <code>xsl:stylesheet</code> element
does not include any stylesheets imported or included by children
of that <code>xsl:stylesheet</code> element.</p>

<note><p>When a stylesheet uses a namespace declaration only for the
purposes of addressing the source tree, specifying the prefix in the
<code>exclude-result-prefixes</code> attribute will avoid superfluous
namespace declarations in the result tree.</p></note>

<p>The value of an attribute of a literal result element is
interpreted as an <termref def="dt-attribute-value-template">attribute
value template</termref>: it can contain expressions contained
in curly braces (<code>{}</code>).</p>

<p><termdef id="dt-literal-namespace-uri" term="Literal Namespace
URI">A namespace URI in the stylesheet tree that is being used to
specify a namespace URI in the result tree is called a <term>literal
namespace URI</term>.</termdef> This applies to:</p>

<ulist>

<item><p>the namespace URI in the expanded-name of a literal
result element in the stylesheet</p></item>

<item><p>the namespace URI in the expanded-name of an attribute
specified on a literal result element in the stylesheet</p></item>

<item><p>the string-value of a namespace node on a literal result
element in the stylesheet</p></item>

</ulist>

<e:element-syntax name="namespace-alias">
  <e:in-category name="tepe-seviyeden-eleman"/>
  <e:attribute name="stylesheet-prefix" required="yes">
    <e:data-type name="prefix"/>
    <e:constant value="#default"/>
  </e:attribute>
  <e:attribute name="result-prefix" required="yes">
    <e:data-type name="prefix"/>
    <e:constant value="#default"/>
  </e:attribute>
  <e:empty/>
</e:element-syntax>

<p><termdef id="dt-alias" term="Alias">A stylesheet can use the
<code>xsl:namespace-alias</code> element to declare that one namespace
URI is an <term>alias</term> for another namespace URI.</termdef> When
a <termref def="dt-literal-namespace-uri">literal namespace
URI</termref> has been declared to be an alias for another namespace
URI, then the namespace URI in the result tree will be the namespace
URI that the literal namespace URI is an alias for, instead of the
literal namespace URI itself.  The <code>xsl:namespace-alias</code>
element declares that the namespace URI bound to the prefix specified
by the <code>stylesheet-prefix</code> attribute is an alias for the
namespace URI bound to the prefix specified by the
<code>result-prefix</code> attribute.  Thus, the
<code>stylesheet-prefix</code> attribute specifies the namespace URI
that will appear in the stylesheet, and the
<code>result-prefix</code> attribute specifies the corresponding
namespace URI that will appear in the result tree.  The default
namespace (as declared by <code>xmlns</code>) may be specified by
using <code>#default</code> instead of a prefix.  If a namespace URI
is declared to be an alias for multiple different namespace URIs, then
the declaration with the highest <termref
def="dt-import-precedence">import precedence</termref> is used. It is
an error if there is more than one such declaration.  An XSLT
processor may signal the error; if it does not signal the error, it
must recover by choosing, from amongst the declarations with the
highest import precedence, the one that occurs last in the
stylesheet.</p>

<p>When literal result elements are being used to create element,
attribute, or namespace nodes that use the XSLT namespace URI, the
stylesheet must use an alias.  For example, the stylesheet</p>

<eg>&lt;xsl:stylesheet
  version="1.0"
  xmlns:xsl="&XSLT.ns;"
  xmlns:fo="&XSLFO.ns;"
  xmlns:axsl="&XSLTA.ns;"><![CDATA[

<xsl:namespace-alias stylesheet-prefix="axsl" result-prefix="xsl"/>

<xsl:template match="/">
  <axsl:stylesheet>
    <xsl:apply-templates/>
  </axsl:stylesheet>
</xsl:template>

<xsl:template match="block">
  <axsl:template match="{.}">
     <fo:block><axsl:apply-templates/></fo:block>
  </axsl:template>
</xsl:template>

</xsl:stylesheet>]]></eg>

<p>will generate an XSLT stylesheet from a document of the form:</p>

<eg><![CDATA[<elements>
<block>p</block>
<block>h1</block>
<block>h2</block>
<block>h3</block>
<block>h4</block>
</elements>]]></eg>

<note><p>It may be necessary also to use aliases for namespaces other
than the XSLT namespace URI.  For example, literal result elements
belonging to a namespace dealing with digital signatures might cause
XSLT stylesheets to be mishandled by general-purpose security
software; using an alias for the namespace would avoid the possibility
of such mishandling.</p></note>

</div3>

<div3>
<head>Creating Elements with <code>xsl:element</code></head>

<e:element-syntax name="element">
  <e:in-category name="instruction"/>
  <e:attribute name="name" required="yes">
    <e:attribute-value-template>
      <e:data-type name="qname"/>
    </e:attribute-value-template>
  </e:attribute>
  <e:attribute name="namespace">
    <e:attribute-value-template>
      <e:data-type name="tanım-yeri-başvurusu"/>
    </e:attribute-value-template>
  </e:attribute>
  <e:attribute name="use-attribute-sets">
    <e:data-type name="qnames"/>
  </e:attribute>
  <e:model name="template"/>
</e:element-syntax>

<p>The <code>xsl:element</code> element allows an element to be
created with a computed name.  The <xtermref
href="&XPath;#dt-expanded-name">expanded-name</xtermref> of the
element to be created is specified by a required <code>name</code>
attribute and an optional <code>namespace</code> attribute.  The
content of the <code>xsl:element</code> element is a template for the
attributes and children of the created element.</p>

<p>The <code>name</code> attribute is interpreted as an <termref
def="dt-attribute-value-template">attribute value template</termref>.
It is an error if the string that results from instantiating the
attribute value template is not a <xnt
href="&XMLNames;#NT-QName">QName</xnt>.  An XSLT processor may signal
the error; if it does not signal the error, then it must recover
by making the the result of instantiating the <code>xsl:element</code>
element be the sequence of nodes created by instantiating
the content of the  <code>xsl:element</code> element, excluding
any initial attribute nodes. If the <code>namespace</code> attribute is
not present then the <xnt href="&XMLNames;#NT-QName">QName</xnt> is
expanded into an expanded-name using the namespace declarations in
effect for the <code>xsl:element</code> element, including any default
namespace declaration.</p>

<p>If the <code>namespace</code> attribute is present, then it also is
interpreted as an <termref def="dt-attribute-value-template">attribute
value template</termref>. The string that results from instantiating
the attribute value template should be a URI reference.  It is not an
error if the string is not a syntactically legal URI reference.  If
the string is empty, then the expanded-name of the element has a null
namespace URI.  Otherwise, the string is used as the namespace URI of
the expanded-name of the element to be created. The local part of the
<xnt href="&XMLNames;#NT-QName">QName</xnt> specified by the
<code>name</code> attribute is used as the local part of the
expanded-name of the element to be created.</p>

<p>XSLT processors may make use of the prefix of the <xnt
href="&XMLNames;#NT-QName">QName</xnt> specified in the
<code>name</code> attribute when selecting the prefix used for
outputting the created element as XML; however, they are not required
to do so.</p>

</div3>

<div3 id="creating-attributes">
<head>Creating Attributes with <code>xsl:attribute</code></head>

<e:element-syntax name="attribute">
  <e:in-category name="instruction"/>
  <e:attribute name="name" required="yes">
    <e:attribute-value-template>
      <e:data-type name="qname"/>
    </e:attribute-value-template>
  </e:attribute>
  <e:attribute name="namespace">
    <e:attribute-value-template>
      <e:data-type name="tanım-yeri-başvurusu"/>
    </e:attribute-value-template>
  </e:attribute>
  <e:model name="template"/>
</e:element-syntax>

<p>The <code>xsl:attribute</code> element can be used to add
attributes to result elements whether created by literal result
elements in the stylesheet or by instructions such as
<code>xsl:element</code>. The <xtermref
href="&XPath;#dt-expanded-name">expanded-name</xtermref> of the
attribute to be created is specified by a required <code>name</code>
attribute and an optional <code>namespace</code> attribute.
Instantiating an <code>xsl:attribute</code> element adds an attribute
node to the containing result element node. The content of the
<code>xsl:attribute</code> element is a template for the value of the
created attribute.</p>

<p>The <code>name</code> attribute is interpreted as an <termref
def="dt-attribute-value-template">attribute value template</termref>.
It is an error if the string that results from instantiating the
attribute value template is not a <xnt
href="&XMLNames;#NT-QName">QName</xnt> or is the string
<code>xmlns</code>.  An XSLT processor may signal the error; if it
does not signal the error, it must recover by not adding the attribute
to the result tree. If the <code>namespace</code> attribute is not
present, then the <xnt href="&XMLNames;#NT-QName">QName</xnt> is
expanded into an expanded-name using the namespace declarations in
effect for the <code>xsl:attribute</code> element, <emph>not</emph>
including any default namespace declaration.</p>

<p>If the <code>namespace</code> attribute is present, then it also is
interpreted as an <termref def="dt-attribute-value-template">attribute
value template</termref>. The string that results from instantiating
it should be a URI reference.  It is not an error if the string is not
a syntactically legal URI reference.  If the string is empty, then the
expanded-name of the attribute has a null namespace URI.  Otherwise,
the string is used as the namespace URI of the expanded-name of the
attribute to be created. The local part of the <xnt
href="&XMLNames;#NT-QName">QName</xnt> specified by the
<code>name</code> attribute is used as the local part of the
expanded-name of the attribute to be created.</p>

<p>XSLT processors may make use of the prefix of the <xnt
href="&XMLNames;#NT-QName">QName</xnt> specified in the
<code>name</code> attribute when selecting the prefix used for
outputting the created attribute as XML; however, they are not
required to do so and, if the prefix is <code>xmlns</code>, they must
not do so. Thus, although it is not an error to do:</p>

<eg>&lt;xsl:attribute name="xmlns:xsl" namespace="whatever">&XSLT.ns;&lt;/xsl:attribute></eg>

<p>it will not result in a namespace declaration being output.</p>

<p>Adding an attribute to an element replaces any existing attribute
of that element with the same expanded-name.</p>

<p>The following are all errors:</p>

<ulist>

<item><p>Adding an attribute to an element after children have been
added to it; implementations may either signal the error or ignore the
attribute.</p></item>

<item><p>Adding an attribute to a node that is not an element;
implementations may either signal the error or ignore the
attribute.</p></item>

<item><p>Creating nodes other than text nodes during the
instantiation of the content of the <code>xsl:attribute</code>
element; implementations may either signal the error or ignore the
offending nodes.</p></item>

</ulist>

<note><p>When an <code>xsl:attribute</code> contains a text node with
a newline, then the XML output must contain a character reference.
For example,</p>

<eg><![CDATA[<xsl:attribute name="a">x
y</xsl:attribute>]]></eg>

<p>will result in the output</p>

<eg><![CDATA[a="x&#xA;y"]]></eg>

<p>(or with any equivalent character reference). The XML output cannot
be</p>

<eg><![CDATA[a="x
y"]]></eg>

<p>This is because XML 1.0 requires newline characters in attribute
values to be normalized into spaces but requires character references
to newline characters not to be normalized.  The attribute values in
the data model represent the attribute value after normalization.  If
a newline occurring in an attribute value in the tree were output as a
newline character rather than as character reference, then the
attribute value in the tree created by reparsing the XML would contain
a space not a newline, which would mean that the tree had not been
output correctly.</p></note>

</div3>

<div3 id="attribute-sets">

<head>Named Attribute Sets</head>

<e:element-syntax name="attribute-set">
  <e:in-category name="tepe-seviyeden-eleman"/>
  <e:attribute name="name" required="yes">
    <e:data-type name="qname"/>
  </e:attribute>
  <e:attribute name="use-attribute-sets">
    <e:data-type name="qnames"/>
  </e:attribute>
  <e:element repeat="zero-or-more" name="attribute"/>
</e:element-syntax>

<p>The <code>xsl:attribute-set</code> element defines a named set of
attributes.  The <code>name</code> attribute specifies the name of the
attribute set.  The value of the <code>name</code> attribute is a <xnt
href="&XMLNames;#NT-QName">QName</xnt>, which is expanded as described
in <specref ref="qname"/>. The content of the <code>xsl:attribute-set</code>
element consists of zero or more <code>xsl:attribute</code> elements
that specify the attributes in the set.</p>

<p>Attribute sets are used by specifying a
<code>use-attribute-sets</code> attribute on <code>xsl:element</code>,
<code>xsl:copy</code> (see <specref ref="copying"/>) or
<code>xsl:attribute-set</code> elements.  The value of the
<code>use-attribute-sets</code> attribute is a whitespace-separated
list of names of attribute sets.  Each name is specified as a <xnt
href="&XMLNames;#NT-QName">QName</xnt>, which is expanded as described
in <specref ref="qname"/>.  Specifying a
<code>use-attribute-sets</code> attribute is equivalent to adding
<code>xsl:attribute</code> elements for each of the attributes in each
of the named attribute sets to the beginning of the content of the
element with the <code>use-attribute-sets</code> attribute, in the
same order in which the names of the attribute sets are specified in
the <code>use-attribute-sets</code> attribute.  It is an error if use
of <code>use-attribute-sets</code> attributes on
<code>xsl:attribute-set</code> elements causes an attribute set to
directly or indirectly use itself.</p>

<p>Attribute sets can also be used by specifying an
<code>xsl:use-attribute-sets</code> attribute on a literal result
element.  The value of the <code>xsl:use-attribute-sets</code>
attribute is a whitespace-separated list of names of attribute sets.
The <code>xsl:use-attribute-sets</code> attribute has the same effect
as the <code>use-attribute-sets</code> attribute on
<code>xsl:element</code> with the additional rule that attributes
specified on the literal result element itself are treated as if they
were specified by <code>xsl:attribute</code> elements before any
actual <code>xsl:attribute</code> elements but after any
<code>xsl:attribute</code> elements implied by the
<code>xsl:use-attribute-sets</code> attribute.  Thus, for a literal
result element, attributes from attribute sets named in an
<code>xsl:use-attribute-sets</code> attribute will be added first, in
the order listed in the attribute; next, attributes specified on the
literal result element will be added; finally, any attributes
specified by <code>xsl:attribute</code> elements will be added.  Since
adding an attribute to an element replaces any existing attribute of
that element with the same name, this means that attributes specified
in attribute sets can be overridden by attributes specified on the
literal result element itself.</p>

<p>The template within each <code>xsl:attribute</code> element in an
<code>xsl:attribute-set</code> element is instantiated each time the
attribute set is used; it is instantiated using the same current node
and current node list as is used for instantiating the element bearing
the <code>use-attribute-sets</code> or
<code>xsl:use-attribute-sets</code> attribute. However, it is the
position in the stylesheet of the <code>xsl:attribute</code> element
rather than of the element bearing the <code>use-attribute-sets</code>
or <code>xsl:use-attribute-sets</code> attribute that determines which
variable bindings are visible (see <specref ref="variables"/>); thus,
only variables and parameters declared by <termref
def="dt-top-level">top-level</termref> <code>xsl:variable</code> and
<code>xsl:param</code> elements are visible.</p>

<p>The following example creates a named attribute set
<code>title-style</code> and uses it in a template rule.</p>

<eg><![CDATA[<xsl:template match="chapter/heading">
  <fo:block quadding="start" xsl:use-attribute-sets="title-style">
    <xsl:apply-templates/>
  </fo:block>
</xsl:template>

<xsl:attribute-set name="title-style">
  <xsl:attribute name="font-size">12pt</xsl:attribute>
  <xsl:attribute name="font-weight">bold</xsl:attribute>
</xsl:attribute-set>]]></eg>

<p>Multiple definitions of an attribute set with the same
expanded-name are merged.  An attribute from a definition that has
higher <termref def="dt-import-precedence">import precedence</termref>
takes precedence over an attribute from a definition that has lower
<termref def="dt-import-precedence">import precedence</termref>.  It
is an error if there are two attribute sets that have the same
expanded-name and equal import precedence and that both contain
the same attribute, unless there is a definition of the attribute set
with higher <termref def="dt-import-precedence">import
precedence</termref> that also contains the attribute.  An XSLT
processor may signal the error; if it does not signal the error, it
must recover by choosing from amongst the definitions that specify the
attribute that have the highest import precedence the one that was
specified last in the stylesheet.  Where the attributes in an
attribute set were specified is relevant only in merging the
attributes into the attribute set; it makes no difference when the
attribute set is used.</p>

</div3>

</div2>

<div2>

<head>Creating Text</head>

<p>A template can also contain text nodes.  Each text node in a
template remaining after whitespace has been stripped as specified in
<specref ref="strip"/> will create a text node with the same
string-value in the result tree.  Adjacent text nodes in the result
tree are automatically merged.</p>

<p>Note that text is processed at the tree level. Thus, markup of
<code>&amp;lt;</code> in a template will be represented in the
stylesheet tree by a text node that includes the character
<code>&lt;</code>. This will create a text node in the result tree
that contains a <code>&lt;</code> character, which will be represented
by the markup <code>&amp;lt;</code> (or an equivalent character
reference) when the result tree is externalized as an XML document
(unless output escaping is disabled as described in <specref
ref="disable-output-escaping"/>).</p>

<e:element-syntax name="text">
  <e:in-category name="instruction"/>
  <e:attribute name="disable-output-escaping">
    <e:constant value="yes"/>
    <e:constant value="no"/>
  </e:attribute>
  <e:text/>
</e:element-syntax>

<p>Literal data characters may also be wrapped in an
<code>xsl:text</code> element.  This wrapping may change what
whitespace characters are stripped (see <specref ref="strip"/>) but
does not affect how the characters are handled by the XSLT processor
thereafter.</p>

<note><p>The <code>xml:lang</code> and <code>xml:space</code>
attributes are not treated specially by XSLT. In particular,</p>

<ulist>
<item><p>it is the responsibility of the stylesheet author explicitly
to generate any <code>xml:lang</code> or <code>xml:space</code>
attributes that are needed in the result;</p></item>

<item><p>specifying an <code>xml:lang</code> or <code>xml:space</code>
attribute on an element in the XSLT namespace will not cause any
<code>xml:lang</code> or <code>xml:space</code> attributes to appear
in the result.</p></item>
</ulist>
</note>

</div2>


<div2>
<head>Creating Processing Instructions</head>


<e:element-syntax name="processing-instruction">
  <e:in-category name="instruction"/>
  <e:attribute name="name" required="yes">
    <e:attribute-value-template>
      <e:data-type name="ncname"/>
    </e:attribute-value-template>
  </e:attribute>
  <e:model name="template"/>
</e:element-syntax>

<p>The <code>xsl:processing-instruction</code> element is instantiated
to create a processing instruction node.  The content of the
<code>xsl:processing-instruction</code> element is a template for the
string-value of the processing instruction node.  The
<code>xsl:processing-instruction</code> element has a required
<code>name</code> attribute that specifies the name of the processing
instruction node.  The value of the <code>name</code> attribute is
interpreted as an <termref def="dt-attribute-value-template">attribute
value template</termref>.</p>

<p>For example, this</p>

<eg><![CDATA[<xsl:processing-instruction name="xml-stylesheet">href="book.css" type="text/css"</xsl:processing-instruction>]]></eg>

<p>would create the processing instruction</p>

<eg><![CDATA[<?xml-stylesheet href="book.css" type="text/css"?>]]></eg>

<p>It is an error if the string that results from instantiating the
<code>name</code> attribute is not both an <xnt
href="&XMLNames;#NT-NCName">NCName</xnt> and a <xnt
href="&XML;#NT-PITarget">PITarget</xnt>.  An XSLT processor may signal
the error; if it does not signal the error, it must recover by not
adding the processing instruction to the result tree.</p>

<note><p>This means that <code>xsl:processing-instruction</code>
cannot be used to output an XML declaration.  The
<code>xsl:output</code> element should be used instead (see <specref
ref="output"/>).</p></note>

<p>It is an error if instantiating the content of
<code>xsl:processing-instruction</code> creates nodes other than
text nodes.  An XSLT processor may signal the error; if it does not
signal the error, it must recover by ignoring the offending nodes
together with their content.</p>

<p>It is an error if the result of instantiating the content of the
<code>xsl:processing-instruction</code> contains the string
<code>?&gt;</code>.  An XSLT processor may signal the error; if it does
not signal the error, it must recover by inserting a space after any
occurrence of <code>?</code> that is followed by a <code>&gt;</code>.</p>

</div2>

<div2>
<head>Creating Comments</head>

<e:element-syntax name="comment">
  <e:in-category name="instruction"/>
  <e:model name="template"/>
</e:element-syntax>

<p>The <code>xsl:comment</code> element is instantiated to create a
comment node in the result tree.  The content of the
<code>xsl:comment</code> element is a template for the string-value of
the comment node.</p>

<p>For example, this</p>

<eg><![CDATA[<xsl:comment>This file is automatically generated. Do not edit!</xsl:comment>]]></eg>

<p>would create the comment</p>

<eg><![CDATA[<!--This file is automatically generated. Do not edit!-->]]></eg>

<p>It is an error if instantiating the content of
<code>xsl:comment</code> creates nodes other than text nodes.  An
XSLT processor may signal the error; if it does not signal the error,
it must recover by ignoring the offending nodes together with their
content.</p>

<p>It is an error if the result of instantiating the content of the
<code>xsl:comment</code> contains the string <code>--</code> or ends
with <code>-</code>.  An XSLT processor may signal the error; if it
does not signal the error, it must recover by inserting a space after
any occurrence of <code>-</code> that is followed by another
<code>-</code> or that ends the comment.</p>

</div2>

<div2 id="copying">
<head>Copying</head>

<e:element-syntax name="copy">
  <e:in-category name="instruction"/>
  <e:attribute name="use-attribute-sets">
    <e:data-type name="qnames"/>
  </e:attribute>
  <e:model name="template"/>
</e:element-syntax>

<p>The <code>xsl:copy</code> element provides an easy way of copying
the current node. Instantiating the <code>xsl:copy</code> element
creates a copy of the current node.  The namespace nodes of the
current node are automatically copied as well, but the attributes and
children of the node are not automatically copied.  The content of the
<code>xsl:copy</code> element is a template for the attributes and
children of the created node; the content is instantiated only for
nodes of types that can have attributes or children (i.e. root
nodes and element nodes).</p>

<p>The <code>xsl:copy</code> element may have a
<code>use-attribute-sets</code> attribute (see <specref
ref="attribute-sets"/>). This is used only when copying element
nodes.</p>

<p>The root node is treated specially because the root node of the
result tree is created implicitly.  When the current node is the root
node, <code>xsl:copy</code> will not create a root node, but will just
use the content template.</p>

<p>For example, the identity transformation can be written using
<code>xsl:copy</code> as follows:</p>

<eg><![CDATA[<xsl:template match="@*|node()">
  <xsl:copy>
    <xsl:apply-templates select="@*|node()"/>
  </xsl:copy>
</xsl:template>]]></eg>

<p>When the current node is an attribute, then if it would be an error
to use <code>xsl:attribute</code> to create an attribute with the same
name as the current node, then it is also an error to use
<code>xsl:copy</code> (see <specref ref="creating-attributes"/>).</p>

<p>The following example shows how <code>xml:lang</code> attributes
can be easily copied through from source to result. If a stylesheet
defines the following named template:</p>

<eg><![CDATA[<xsl:template name="apply-templates-copy-lang">
 <xsl:for-each select="@xml:lang">
   <xsl:copy/>
 </xsl:for-each>
 <xsl:apply-templates/>
</xsl:template>]]></eg>

<p>then it can simply do</p>

<eg><![CDATA[<xsl:call-template name="apply-templates-copy-lang"/>]]></eg>

<p>instead of</p>

<eg><![CDATA[<xsl:apply-templates/>]]></eg>

<p>when it wants to copy the <code>xml:lang</code> attribute.</p>

</div2>

<div2>
<head>Computing Generated Text</head>

<p>Within a template, the <code>xsl:value-of</code> element can be
used to compute generated text, for example by extracting text from
the source tree or by inserting the value of a variable.  The
<code>xsl:value-of</code> element does this with an <termref
def="dt-expression">expression</termref> that is specified as the
value of the <code>select</code> attribute.  Expressions can
also be used inside attribute values of literal result elements by
enclosing the expression in curly braces (<code>{}</code>).</p>

<div3 id="value-of">
<head>Generating Text with <code>xsl:value-of</code></head>

<e:element-syntax name="value-of">
  <e:in-category name="instruction"/>
  <e:attribute name="select" required="yes">
    <e:data-type name="string-expression"/>
  </e:attribute>
  <e:attribute name="disable-output-escaping">
    <e:constant value="yes"/>
    <e:constant value="no"/>
  </e:attribute>
  <e:empty/>
</e:element-syntax>

<p>The <code>xsl:value-of</code> element is instantiated to create a
text node in the result tree.  The required <code>select</code>
attribute is an <termref def="dt-expression">expression</termref>;
this expression is evaluated and the resulting object is converted to
a string as if by a call to the <xfunction>string</xfunction>
function. The string specifies the string-value of the created text
node.  If the string is empty, no text node will be created.  The
created text node will be merged with any adjacent text nodes.</p>

<p>The <code>xsl:copy-of</code> element can be used to copy a node-set
over to the result tree without converting it to a string. See <specref
ref="copy-of"/>.</p>

<p>For example, the following creates an HTML paragraph from a
<code>person</code> element with <code>given-name</code> and
<code>family-name</code> attributes.  The paragraph will contain the value
of the <code>given-name</code> attribute of the current node followed
by a space and the value of the <code>family-name</code> attribute of the
current node.</p>

<eg><![CDATA[<xsl:template match="person">
  <p>
   <xsl:value-of select="@given-name"/>
   <xsl:text> </xsl:text>
   <xsl:value-of select="@family-name"/>
  </p>
</xsl:template>]]></eg>

<p>For another example, the following creates an HTML paragraph from a
<code>person</code> element with <code>given-name</code> and
<code>family-name</code> children elements.  The paragraph will
contain the string-value of the first <code>given-name</code> child
element of the current node followed by a space and the string-value
of the first <code>family-name</code> child element of the current
node.</p>

<eg><![CDATA[<xsl:template match="person">
  <p>
   <xsl:value-of select="given-name"/>
   <xsl:text> </xsl:text>
   <xsl:value-of select="family-name"/>
  </p>
</xsl:template>]]></eg>

<p>The following precedes each <code>procedure</code> element with a
paragraph containing the security level of the procedure.  It assumes
that the security level that applies to a procedure is determined by a
<code>security</code> attribute on the procedure element or on an
ancestor element of the procedure. It also assumes that if more than
one such element has a <code>security</code> attribute then the
security level is determined by the element that is closest to the
procedure.</p>

<eg><![CDATA[<xsl:template match="procedure">
  <fo:block>
    <xsl:value-of select="ancestor-or-self::*[@security][1]/@security"/>
  </fo:block>
  <xsl:apply-templates/>
</xsl:template>]]></eg>

</div3>

<div3 id="attribute-value-templates">
<head>Attribute Value Templates</head>

<p><termdef id="dt-attribute-value-template" term="Attribute Value
Template">In an attribute value that is interpreted as an
<term>attribute value template</term>, such as an attribute of a
literal result element, an <termref
def="dt-expression">expression</termref> can be used by surrounding
the expression with curly braces (<code>{}</code>)</termdef>.  The
attribute value template is instantiated by replacing the expression
together with surrounding curly braces by the result of evaluating the
expression and converting the resulting object to a string as if by a
call to the <xfunction>string</xfunction> function.  Curly braces are
not recognized in an attribute value in an XSLT stylesheet unless the
attribute is specifically stated to be one that is interpreted as an
attribute value template; in an element syntax summary, the value
of such attributes is surrounded by curly braces.</p>

<note><p>Not all attributes are interpreted as attribute value
templates.  Attributes whose value is an expression or pattern,
attributes of <termref def="dt-top-level">top-level</termref> elements
and attributes that refer to named XSLT objects are not interpreted as
attribute value templates. In addition, <code>xmlns</code> attributes
are not interpreted as attribute value templates; it would not be
conformant with the XML Namespaces Recommendation to do
this.</p></note>

<p>The following example creates an <code>img</code> result element
from a <code>photograph</code> element in the source; the value of the
<code>src</code> attribute of the <code>img</code> element is computed
from the value of the <code>image-dir</code> variable and the
string-value of the <code>href</code> child of the
<code>photograph</code> element; the value of the <code>width</code>
attribute of the <code>img</code> element is computed from the value
of the <code>width</code> attribute of the <code>size</code> child of
the <code>photograph</code> element:</p>

<eg><![CDATA[<xsl:variable name="image-dir">/images</xsl:variable>

<xsl:template match="photograph">
<img src="{$image-dir}/{href}" width="{size/@width}"/>
</xsl:template>]]></eg>

<p>With this source</p>

<eg><![CDATA[<photograph>
  <href>headquarters.jpg</href>
  <size width="300"/>
</photograph>]]></eg>

<p>the result would be</p>

<eg><![CDATA[<img src="/images/headquarters.jpg" width="300"/>]]></eg>

<p>When an attribute value template is instantiated, a double left or
right curly brace outside an expression will be replaced by a single
curly brace.  It is an error if a right curly brace occurs in an
attribute value template outside an expression without being followed
by a second right curly brace.  A right curly brace inside a <xnt
href="&XPath;#NT-Literal">Literal</xnt> in an expression is not
recognized as terminating the expression.</p>

<p>Curly braces are <emph>not</emph> recognized recursively inside
expressions.  For example:</p>

<eg role="error"><![CDATA[<a href="#{id({@ref})/title}">]]></eg>

<p>is <emph>not</emph> allowed.  Instead, use simply:</p>

<eg><![CDATA[<a href="#{id(@ref)/title}">]]></eg>

</div3>

</div2>

<div2 id="number">
<head>Numbering</head>

<e:element-syntax name="number">
  <e:in-category name="instruction"/>
  <e:attribute name="level">
    <e:constant value="single"/>
    <e:constant value="multiple"/>
    <e:constant value="any"/>
  </e:attribute>
  <e:attribute name="count">
    <e:data-type name="pattern"/>
  </e:attribute>
  <e:attribute name="from">
    <e:data-type name="pattern"/>
  </e:attribute>
  <e:attribute name="value">
    <e:data-type name="number-expression"/>
  </e:attribute>
  <e:attribute name="format">
    <e:attribute-value-template>
      <e:data-type name="string"/>
    </e:attribute-value-template>
  </e:attribute>
  <e:attribute name="lang">
    <e:attribute-value-template>
      <e:data-type name="nmtoken"/>
    </e:attribute-value-template>
  </e:attribute>
  <e:attribute name="letter-value">
    <e:attribute-value-template>
      <e:constant value="alphabetic"/>
      <e:constant value="traditional"/>
    </e:attribute-value-template>
  </e:attribute>
  <e:attribute name="grouping-separator">
    <e:attribute-value-template>
      <e:data-type name="char"/>
    </e:attribute-value-template>
  </e:attribute>
  <e:attribute name="grouping-size">
    <e:attribute-value-template>
      <e:data-type name="sayı"/>
    </e:attribute-value-template>
  </e:attribute>
  <e:empty/>
</e:element-syntax>

<p>The <code>xsl:number</code> element is used to insert a formatted
number into the result tree.  The number to be inserted may be
specified by an expression. The <code>value</code> attribute contains
an <termref def="dt-expression">expression</termref>.  The expression
is evaluated and the resulting object is converted to a number as if
by a call to the <xfunction>number</xfunction> function.  The number is
rounded to an integer and then converted to a string using the
attributes specified in <specref ref="convert"/>; in this
context, the value of each of these attributes is
interpreted as an <termref def="dt-attribute-value-template">attribute
value template</termref>.  After conversion, the resulting string is
inserted in the result tree. For example, the following example
numbers a sorted list:</p>

<eg><![CDATA[<xsl:template match="items">
  <xsl:for-each select="item">
    <xsl:sort select="."/>
    <p>
      <xsl:number value="position()" format="1. "/>
      <xsl:value-of select="."/>
    </p>
  </xsl:for-each>
</xsl:template>]]></eg>

<p>If no <code>value</code> attribute is specified, then the
<code>xsl:number</code> element inserts a number based on the position
of the current node in the source tree. The following attributes
control how the current node is to be numbered:</p>

<ulist>

<item><p>The <code>level</code> attribute specifies what levels of the
source tree should be considered; it has the values
<code>single</code>, <code>multiple</code> or <code>any</code>. The
default is <code>single</code>.</p></item>

<item><p>The <code>count</code> attribute is a pattern that specifies
what nodes should be counted at those levels.  If <code>count</code>
attribute is not specified, then it defaults to the pattern that
matches any node with the same node type as the current node and, if
the current node has an expanded-name, with the same expanded-name as
the current node.</p></item>

<item><p>The <code>from</code> attribute is a pattern that specifies
where counting starts.</p></item>

</ulist>

<p>In addition, the attributes specified in <specref ref="convert"/>
are used for number to string conversion, as in the case when the
<code>value</code> attribute is specified.</p>

<p>The <code>xsl:number</code> element first constructs a list of
positive integers using the <code>level</code>, <code>count</code> and
<code>from</code> attributes:</p>

<ulist>

<item><p>When <code>level="single"</code>, it goes up to the first
node in the ancestor-or-self axis that matches
the <code>count</code> pattern, and constructs a list of length one
containing one plus the number of preceding siblings of that ancestor
that match the <code>count</code> pattern. If there is no such
ancestor, it constructs an empty list.  If the <code>from</code>
attribute is specified, then the only ancestors that are searched are
those that are descendants of the nearest ancestor that matches the
<code>from</code> pattern. Preceding siblings has the same meaning
here as with the <code>preceding-sibling</code> axis.</p></item>

<item><p>When <code>level="multiple"</code>, it constructs a list of all
ancestors of the current node in document order followed by the
element itself; it then selects from the list those nodes that match
the <code>count</code> pattern; it then maps each node in the list to
one plus the number of preceding siblings of that node that match the
<code>count</code> pattern.  If the <code>from</code> attribute is
specified, then the only ancestors that are searched are those that
are descendants of the nearest ancestor that matches the
<code>from</code> pattern. Preceding siblings has the same meaning
here as with the <code>preceding-sibling</code> axis.</p></item>

<item><p>When <code>level="any"</code>, it constructs a list of length
one containing the number of nodes that match the <code>count</code>
pattern and belong to the set containing the current node and all
nodes at any level of the document that are before the current node in
document order, excluding any namespace and attribute nodes (in other
words the union of the members of the <code>preceding</code> and
<code>ancestor-or-self</code> axes). If the <code>from</code>
attribute is specified, then only nodes after the first node before
the current node that match the <code>from</code> pattern are
considered.</p></item>

</ulist>

<p>The list of numbers is then converted into a string using the
attributes specified in <specref ref="convert"/>; in this
context, the value of each of these attributes is
interpreted as an <termref def="dt-attribute-value-template">attribute
value template</termref>.  After conversion, the resulting string is
inserted in the result tree.</p>

<p>The following would number the items in an ordered list:</p>

<eg><![CDATA[<xsl:template match="ol/item">
  <fo:block>
    <xsl:number/><xsl:text>. </xsl:text><xsl:apply-templates/>
  </fo:block>
<xsl:template>]]></eg>

<p>The following two rules would number <code>title</code> elements.
This is intended for a document that contains a sequence of chapters
followed by a sequence of appendices, where both chapters and
appendices contain sections, which in turn contain subsections.
Chapters are numbered 1, 2, 3; appendices are numbered A, B, C;
sections in chapters are numbered 1.1, 1.2, 1.3; sections in
appendices are numbered A.1, A.2, A.3.</p>

<eg><![CDATA[<xsl:template match="title">
  <fo:block>
     <xsl:number level="multiple"
                 count="chapter|section|subsection"
                 format="1.1 "/>
     <xsl:apply-templates/>
  </fo:block>
</xsl:template>

<xsl:template match="appendix//title" priority="1">
  <fo:block>
     <xsl:number level="multiple"
                 count="appendix|section|subsection"
                 format="A.1 "/>
     <xsl:apply-templates/>
  </fo:block>
</xsl:template>]]></eg>

<p>The following example numbers notes sequentially within a
chapter:</p>

<eg><![CDATA[<xsl:template match="note">
  <fo:block>
     <xsl:number level="any" from="chapter" format="(1) "/>
     <xsl:apply-templates/>
  </fo:block>
</xsl:template>]]></eg>

<p>The following example would number <code>H4</code> elements in HTML
with a three-part label:</p>

<eg><![CDATA[<xsl:template match="H4">
 <fo:block>
   <xsl:number level="any" from="H1" count="H2"/>
   <xsl:text>.</xsl:text>
   <xsl:number level="any" from="H2" count="H3"/>
   <xsl:text>.</xsl:text>
   <xsl:number level="any" from="H3" count="H4"/>
   <xsl:text> </xsl:text>
   <xsl:apply-templates/>
 </fo:block>
</xsl:template>]]></eg>

<div3 id="convert">
<head>Number to String Conversion Attributes</head>

<p>The following attributes are used to control conversion of a list
of numbers into a string. The numbers are integers greater than
0. The attributes are all optional.</p>

<p>The main attribute is <code>format</code>.  The default value for
the <code>format</code> attribute is <code>1</code>.  The
<code>format</code> attribute is split into a sequence of tokens where
each token is a maximal sequence of alphanumeric characters or a
maximal sequence of non-alphanumeric characters.  Alphanumeric means
any character that has a Unicode category of Nd, Nl, No, Lu, Ll, Lt,
Lm or Lo.  The alphanumeric tokens (format tokens) specify the format
to be used for each number in the list.  If the first token is a
non-alphanumeric token, then the constructed string will start with
that token; if the last token is non-alphanumeric token, then the
constructed string will end with that token.  Non-alphanumeric tokens
that occur between two format tokens are separator tokens that are
used to join numbers in the list.  The <var>n</var>th format token
will be used to format the <var>n</var>th number in the list.  If
there are more numbers than format tokens, then the last format token
will be used to format remaining numbers.  If there are no format
tokens, then a format token of <code>1</code> is used to format all
numbers.  The format token specifies the string to be used to
represent the number 1.  Each number after the first will be separated
from the preceding number by the separator token preceding the format
token used to format that number, or, if there are no separator
tokens, then by <code>.</code> (a period character).</p>

<p>Format tokens are a superset of the allowed values for the
<code>type</code> attribute for the <code>OL</code> element in HTML
4.0 and are interpreted as follows:</p>

<ulist>

<item><p>Any token where the last character has a decimal digit value
of 1 (as specified in the Unicode character property database),
and the Unicode value of preceding characters is one less than the
Unicode value of the last character generates a decimal
representation of the number where each number is at least as long as
the format token.  Thus, a format token <code>1</code> generates the
sequence <code>1 2 ... 10 11 12 ...</code>, and a format token
<code>01</code> generates the sequence <code>01 02 ... 09 10 11 12
... 99 100 101</code>.</p></item>

<item><p>A format token <code>A</code> generates the sequence <code>A
B C ... Z AA AB AC...</code>.</p></item>

<item><p>A format token <code>a</code> generates the sequence <code>a
b c ... z aa ab ac...</code>.</p></item>

<item><p>A format token <code>i</code> generates the sequence <code>i
ii iii iv v vi vii viii ix x ...</code>.</p></item>

<item><p>A format token <code>I</code> generates the sequence <code>I
II III IV V VI VII VIII IX X ...</code>.</p></item>

<item><p>Any other format token indicates a numbering sequence that
starts with that token.  If an implementation does not support a
numbering sequence that starts with that token, it must use a format
token of <code>1</code>.</p></item>

</ulist>

<p>When numbering with an alphabetic sequence, the <code>lang</code>
attribute specifies which language's alphabet is to be used; it has
the same range of values as <code>xml:lang</code> <bibref ref="XML"/>;
if no <code>lang</code> value is specified, the language should be
determined from the system environment.  Implementers should document
for which languages they support numbering.</p>

<note><p>Implementers should not make any assumptions about how
numbering works in particular languages and should properly research
the languages that they wish to support.  The numbering conventions of
many languages are very different from English.</p></note>

<p>The <code>letter-value</code> attribute disambiguates between
numbering sequences that use letters.  In many languages there are two
commonly used numbering sequences that use letters.  One numbering
sequence assigns numeric values to letters in alphabetic sequence, and
the other assigns numeric values to each letter in some other manner
traditional in that language.  In English, these would correspond to
the numbering sequences specified by the format tokens <code>a</code>
and <code>i</code>.  In some languages, the first member of each
sequence is the same, and so the format token alone would be
ambiguous.  A value of <code>alphabetic</code> specifies the
alphabetic sequence; a value of <code>traditional</code> specifies the
other sequence.  If the <code>letter-value</code> attribute is not
specified, then it is implementation-dependent how any ambiguity is
resolved.</p>

<note><p>It is possible for two conforming XSLT processors not to
convert a number to exactly the same string.  Some XSLT processors may not
support some languages.  Furthermore, there may be variations possible
in the way conversions are performed for any particular language that
are not specifiable by the attributes on <code>xsl:number</code>.
Future versions of XSLT may provide additional attributes to provide
control over these variations.  Implementations may also use
implementation-specific namespaced attributes on
<code>xsl:number</code> for this.</p></note>

<p>The <code>grouping-separator</code> attribute gives the separator
used as a grouping (e.g. thousands) separator in decimal numbering
sequences, and the optional <code>grouping-size</code> specifies the
size (normally 3) of the grouping.  For example,
<code>grouping-separator=","</code> and <code>grouping-size="3"</code>
would produce numbers of the form <code>1,000,000</code>.  If only one
of the <code>grouping-separator</code> and <code>grouping-size</code>
attributes is specified, then it is ignored.</p>

<p>Here are some examples of conversion specifications:</p>

<ulist>

<item><p><code>format="&amp;#x30A2;"</code> specifies Katakana
numbering</p></item>

<item><p><code>format="&amp;#x30A4;"</code> specifies Katakana
numbering in the <quote>iroha</quote> order</p></item>

<item><p><code>format="&amp;#x0E51;"</code> specifies numbering with
Thai digits</p></item>

<item><p><code>format="&amp;#x05D0;" letter-value="traditional"</code>
specifies <quote>traditional</quote> Hebrew numbering</p></item>

<item><p><code>format="&amp;#x10D0;" letter-value="traditional"</code>
specifies Georgian numbering</p></item>

<item><p><code>format="&amp;#x03B1;" letter-value="traditional"</code>
specifies <quote>classical</quote> Greek numbering</p></item>

<item><p><code>format="&amp;#x0430;" letter-value="traditional"</code>
specifies Old Slavic numbering</p></item>

</ulist>

</div3>
</div2>
</div1>

<div1 id="for-each">

<head>Repetition</head>

<e:element-syntax name="for-each">
  <e:in-category name="instruction"/>
  <e:attribute name="select" required="yes">
    <e:data-type name="node-set-expression"/>
  </e:attribute>
  <e:sequence>
    <e:element repeat="zero-or-more" name="sort"/>
    <e:model name="template"/>
  </e:sequence>
</e:element-syntax>

<p>When the result has a known regular structure, it is useful to be
able to specify directly the template for selected nodes.  The
<code>xsl:for-each</code> instruction contains a template, which is
instantiated for each node selected by the <termref
def="dt-expression">expression</termref> specified by the
<code>select</code> attribute. The <code>select</code> attribute is
required.  The expression must evaluate to a node-set.  The template
is instantiated with the selected node as the <termref
def="dt-current-node">current node</termref>, and with a list of all
of the selected nodes as the <termref
def="dt-current-node-list">current node list</termref>.  The nodes are
processed in document order, unless a sorting specification is present
(see <specref ref="sorting"/>).</p>

<p>For example, given an XML document with this structure</p>

<eg><![CDATA[<customers>
  <customer>
    <name>...</name>
    <order>...</order>
    <order>...</order>
  </customer>
  <customer>
    <name>...</name>
    <order>...</order>
    <order>...</order>
  </customer>
</customers>]]></eg>

<p>the following would create an HTML document containing a table with
a row for each <code>customer</code> element</p>

<eg><![CDATA[<xsl:template match="/">
  <html>
    <head>
      <title>Customers</title>
    </head>
    <body>
      <table>
	<tbody>
	  <xsl:for-each select="customers/customer">
	    <tr>
	      <th>
		<xsl:apply-templates select="name"/>
	      </th>
	      <xsl:for-each select="order">
		<td>
		  <xsl:apply-templates/>
		</td>
	      </xsl:for-each>
	    </tr>
	  </xsl:for-each>
	</tbody>
      </table>
    </body>
  </html>
</xsl:template>]]></eg>

</div1>

<div1>
<head>Conditional Processing</head>

<p>There are two instructions in XSLT that support conditional
processing in a template: <code>xsl:if</code> and
<code>xsl:choose</code>. The <code>xsl:if</code> instruction provides
simple if-then conditionality; the <code>xsl:choose</code> instruction
supports selection of one choice when there are several
possibilities.</p>

<div2>
<head>Conditional Processing with <code>xsl:if</code></head>

<e:element-syntax name="if">
  <e:in-category name="instruction"/>
  <e:attribute name="test" required="yes">
    <e:data-type name="boolean-expression"/>
  </e:attribute>
  <e:model name="template"/>
</e:element-syntax>

<p>The <code>xsl:if</code> element has a <code>test</code> attribute,
which specifies an <termref def="dt-expression">expression</termref>.
The content is a template.  The expression is evaluated and the
resulting object is converted to a boolean as if by a call to the
<xfunction>boolean</xfunction> function.  If the result is true, then
the content template is instantiated; otherwise, nothing is created.
In the following example, the names in a group of names are formatted
as a comma separated list:</p>

<eg><![CDATA[<xsl:template match="namelist/name">
  <xsl:apply-templates/>
  <xsl:if test="not(position()=last())">, </xsl:if>
</xsl:template>]]></eg>

<p>The following colors every other table row yellow:</p>

<eg><![CDATA[<xsl:template match="item">
  <tr>
    <xsl:if test="position() mod 2 = 0">
       <xsl:attribute name="bgcolor">yellow</xsl:attribute>
    </xsl:if>
    <xsl:apply-templates/>
  </tr>
</xsl:template>]]></eg>

</div2>


<div2>
<head>Conditional Processing with <code>xsl:choose</code></head>

<e:element-syntax name="choose">
  <e:in-category name="instruction"/>
  <e:sequence>
    <e:element repeat="one-or-more" name="when"/>
    <e:element repeat="zero-or-one" name="otherwise"/>
  </e:sequence>
</e:element-syntax>

<e:element-syntax name="when">
  <e:attribute name="test" required="yes">
    <e:data-type name="boolean-expression"/>
  </e:attribute>
  <e:model name="template"/>
</e:element-syntax>

<e:element-syntax name="otherwise">
  <e:model name="template"/>
</e:element-syntax>

<p>The <code>xsl:choose</code> element selects one among a number of
possible alternatives. It consists of a sequence of
<code>xsl:when</code> elements followed by an optional
<code>xsl:otherwise</code> element.  Each <code>xsl:when</code>
element has a single attribute, <code>test</code>, which specifies an
<termref def="dt-expression">expression</termref>. The content of the
<code>xsl:when</code> and <code>xsl:otherwise</code> elements is a
template.  When an <code>xsl:choose</code> element is processed, each
of the <code>xsl:when</code> elements is tested in turn, by evaluating
the expression and converting the resulting object to a boolean as if
by a call to the <xfunction>boolean</xfunction> function.  The content
of the first, and only the first, <code>xsl:when</code> element whose
test is true is instantiated.  If no <code>xsl:when</code> is true,
the content of the <code>xsl:otherwise</code> element is
instantiated. If no <code>xsl:when</code> element is true, and no
<code>xsl:otherwise</code> element is present, nothing is created.</p>

<p>The following example enumerates items in an ordered list using
arabic numerals, letters, or roman numerals depending on the depth to
which the ordered lists are nested.</p>

<eg><![CDATA[<xsl:template match="orderedlist/listitem">
  <fo:list-item indent-start='2pi'>
    <fo:list-item-label>
      <xsl:variable name="level"
                    select="count(ancestor::orderedlist) mod 3"/>
      <xsl:choose>
        <xsl:when test='$level=1'>
          <xsl:number format="i"/>
        </xsl:when>
        <xsl:when test='$level=2'>
          <xsl:number format="a"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:number format="1"/>
        </xsl:otherwise>
      </xsl:choose>
      <xsl:text>. </xsl:text>
    </fo:list-item-label>
    <fo:list-item-body>
      <xsl:apply-templates/>
    </fo:list-item-body>
  </fo:list-item>
</xsl:template>]]></eg>

</div2>
</div1>

<div1 id="sorting">
<head>Sorting</head>

<e:element-syntax name="sort">
  <e:attribute name="select">
    <e:data-type name="string-expression"/>
  </e:attribute>
  <e:attribute name="lang">
    <e:attribute-value-template>
      <e:data-type name="nmtoken"/>
    </e:attribute-value-template>
  </e:attribute>
  <e:attribute name="data-type">
    <e:attribute-value-template>
       <e:constant value="text"/>
       <e:constant value="number"/>
       <e:data-type name="qname-but-not-ncname"/>
    </e:attribute-value-template>
  </e:attribute>
  <e:attribute name="order">
    <e:attribute-value-template>
       <e:constant value="ascending"/>
       <e:constant value="descending"/>
    </e:attribute-value-template>
  </e:attribute>
  <e:attribute name="case-order">
    <e:attribute-value-template>
       <e:constant value="upper-first"/>
       <e:constant value="lower-first"/>
    </e:attribute-value-template>
  </e:attribute>
  <e:empty/>
</e:element-syntax>

<p>Sorting is specified by adding <code>xsl:sort</code> elements as
children of an <code>xsl:apply-templates</code> or
<code>xsl:for-each</code> element.  The first <code>xsl:sort</code>
child specifies the primary sort key, the second <code>xsl:sort</code>
child specifies the secondary sort key and so on.  When an
<code>xsl:apply-templates</code> or <code>xsl:for-each</code> element
has one or more <code>xsl:sort</code> children, then instead of
processing the selected nodes in document order, it sorts the nodes
according to the specified sort keys and then processes them in sorted
order.  When used in <code>xsl:for-each</code>, <code>xsl:sort</code>
elements must occur first.  When a template is instantiated by
<code>xsl:apply-templates</code> and <code>xsl:for-each</code>, the
<termref def="dt-current-node-list">current node list</termref> list
consists of the complete list of nodes being processed in sorted
order.</p>

<p><code>xsl:sort</code> has a <code>select</code> attribute whose
value is an <termref def="dt-expression">expression</termref>. For
each node to be processed, the expression is evaluated with that node
as the current node and with the complete list of nodes being
processed in unsorted order as the current node list.
The resulting object is converted to a string as
if by a call to the <xfunction>string</xfunction> function; this string
is used as the sort key for that node. The default value of the
<code>select</code> attribute is <code>.</code>, which will cause the
string-value of the current node to be used as the sort key.</p>

<p>This string serves as a sort key for the node.  The following
optional attributes on <code>xsl:sort</code> control how the list of
sort keys are sorted; the values of all of these attributes are
interpreted as <termref def="dt-attribute-value-template">attribute
value templates</termref>.</p>

<ulist>

<item><p><code>order</code> specifies whether the strings should be
sorted in ascending or descending order; <code>ascending</code>
specifies ascending order; <code>descending</code> specifies
descending order; the default is <code>ascending</code></p></item>

<item><p><code>lang</code> specifies the language of the sort keys; it
has the same range of values as <code>xml:lang</code> <bibref
ref="XML"/>; if no <code>lang</code> value is specified, the language
should be determined from the system environment</p></item>

<item><p><code>data-type</code> specifies the data type of the
strings; the following values are allowed:</p>

<ulist>

<item><p><code>text</code> specifies that the sort keys should be
sorted lexicographically in the culturally correct manner for the
language specified by <code>lang</code></p></item>

<item><p><code>number</code> specifies that the sort keys should be
converted to numbers and then sorted according to the numeric value;
the sort key is converted to a number as if by a call to the
<xfunction>number</xfunction> function; the <code>lang</code>
attribute is ignored</p></item>

<item><p>a <xnt href="&XMLNames;#NT-QName">QName</xnt> with a prefix
is expanded into an <xtermref
href="&XPath;#dt-expanded-name">expanded-name</xtermref> as described
in <specref ref="qname"/>; the expanded-name identifies the data-type;
the behavior in this case is not specified by this document</p></item>

</ulist>

<p>The default value is <code>text</code>.</p>

<note><p>The XSL Working Group plans that future versions of XSLT will
leverage XML Schemas to define further values for this
attribute.</p></note>

</item>

<item><p><code>case-order</code> has the value
<code>upper-first</code> or <code>lower-first</code>; this applies
when <code>data-type="text"</code>, and specifies that upper-case
letters should sort before lower-case letters or vice-versa
respectively. For example, if <code>lang="en"</code>, then <code>A a B
b</code> are sorted with <code>case-order="upper-first"</code> and
<code>a A b B</code> are sorted with
<code>case-order="lower-first"</code>. The default value is language
dependent.</p></item>

</ulist>

<note><p>It is possible for two conforming XSLT processors not to sort
exactly the same.  Some XSLT processors may not support some
languages.  Furthermore, there may be variations possible in the
sorting of any particular language that are not specified by the
attributes on <code>xsl:sort</code>, for example, whether Hiragana or
Katakana is sorted first in Japanese.  Future versions of XSLT may
provide additional attributes to provide control over these
variations.  Implementations may also use implementation-specific
namespaced attributes on <code>xsl:sort</code> for this.</p></note>

<note><p>It is recommended that implementers consult <bibref
ref="UNICODE-TR10"/> for information on internationalized
sorting.</p></note>

<p>The sort must be stable: in the sorted list of nodes, any sub list
that has sort keys that all compare equal must be in document
order.</p>

<p>For example, suppose an employee database has the form</p>

<eg><![CDATA[<employees>
  <employee>
    <name>
      <given>James</given>
      <family>Clark</family>
    </name>
    ...
  </employee>
</employees>
]]></eg>

<p>Then a list of employees sorted by name could be generated
using:</p>

<eg><![CDATA[<xsl:template match="employees">
  <ul>
    <xsl:apply-templates select="employee">
      <xsl:sort select="name/family"/>
      <xsl:sort select="name/given"/>
    </xsl:apply-templates>
  </ul>
</xsl:template>

<xsl:template match="employee">
  <li>
    <xsl:value-of select="name/given"/>
    <xsl:text> </xsl:text>
    <xsl:value-of select="name/family"/>
  </li>
</xsl:template>]]></eg>

</div1>

<div1 id="variables">
<head>Variables and Parameters</head>

<e:element-syntax name="variable">
  <e:in-category name="tepe-seviyeden-eleman"/>
  <e:in-category name="instruction"/>
  <e:attribute name="name" required="yes">
    <e:data-type name="qname"/>
  </e:attribute>
  <e:attribute name="select">
    <e:data-type name="expression"/>
  </e:attribute>
  <e:model name="template"/>
</e:element-syntax>

<e:element-syntax name="param">
  <e:in-category name="tepe-seviyeden-eleman"/>
  <e:attribute name="name" required="yes">
    <e:data-type name="qname"/>
  </e:attribute>
  <e:attribute name="select">
    <e:data-type name="expression"/>
  </e:attribute>
  <e:model name="template"/>
</e:element-syntax>

<p>A variable is a name that may be bound to a value.  The value to
which a variable is bound (the <term>value</term> of the variable) can
be an object of any of the types that can be returned by expressions.
There are two elements that can be used to bind variables:
<code>xsl:variable</code> and <code>xsl:param</code>. The difference
is that the value specified on the <code>xsl:param</code> variable is
only a default value for the binding; when the template or stylesheet
within which the <code>xsl:param</code> element occurs is invoked,
parameters may be passed that are used in place of the default
values.</p>

<p>Both <code>xsl:variable</code> and <code>xsl:param</code> have a
required <code>name</code> attribute, which specifies the name of the
variable.  The value of the <code>name</code> attribute is a <xnt
href="&XMLNames;#NT-QName">QName</xnt>, which is expanded as described
in <specref ref="qname"/>.</p>

<p>For any use of these variable-binding elements, there is a region
of the stylesheet tree within which the binding is visible; within
this region, any binding of the variable that was visible on the
variable-binding element itself is hidden.  Thus, only the innermost
binding of a variable is visible.  The set of variable bindings in
scope for an expression consists of those bindings that are visible at
the point in the stylesheet where the expression occurs.</p>

<div2>
<head>Result Tree Fragments</head>

<p>Variables introduce an additional data-type into the expression
language.  <termdef id="dt-result-tree-fragment" term="Result Tree
Fragment">This additional data type is called <term>result tree
fragment</term>.  A variable may be bound to a result tree fragment
instead of one of the four basic XPath data-types (string, number,
boolean, node-set).  A result tree fragment represents a fragment of
the result tree. A result tree fragment is treated equivalently to a
node-set that contains just a single root node.</termdef> However, the
operations permitted on a result tree fragment are a subset of those
permitted on a node-set.  An operation is permitted on a result tree
fragment only if that operation would be permitted on a string (the
operation on the string may involve first converting the string to a
number or boolean). In particular, it is not permitted to use the
<code>/</code>, <code>//</code>, and <code>[]</code> operators on
result tree fragments.  When a permitted operation is performed on a
result tree fragment, it is performed exactly as it would be on the
equivalent node-set.</p>

<p>When a result tree fragment is copied into the result tree (see
<specref ref="copy-of"/>), then all the nodes that are children of the
root node in the equivalent node-set are added in sequence to the
result tree.</p>

<p>Expressions can only return values of type result tree fragment by
referencing variables of type result tree fragment or calling
extension functions that return a result tree fragment or getting a
system property whose value is a result tree fragment.</p>

</div2>

<div2 id="variable-values">
<head>Values of Variables and Parameters</head>

<p>A variable-binding element can specify the value of the variable in
three alternative ways.</p>

<ulist>

<item><p>If the variable-binding element has a <code>select</code>
attribute, then the value of the attribute must be an <termref
def="dt-expression">expression</termref> and the value of the variable
is the object that results from evaluating the expression.  In this
case, the content must be empty.</p></item>

<item>

<p>If the variable-binding element does not have a <code>select</code>
attribute and has non-empty content (i.e. the variable-binding element
has one or more child nodes), then the content of the
variable-binding element specifies the value. The content of the
variable-binding element is a template, which is instantiated to give
the value of the variable. The value is a result tree fragment
equivalent to a node-set containing just a single root node having as
children the sequence of nodes produced by instantiating the template.
The base URI of the nodes in the result tree fragment is the base URI
of the variable-binding element.</p>

<p>It is an error if a member of the sequence of nodes created by
instantiating the template is an attribute node or a namespace node,
since a root node cannot have an attribute node or a namespace node as
a child. An XSLT processor may signal the error; if it does not signal
the error, it must recover by not adding the attribute node or
namespace node.</p>

</item>

<item>

<p>If the variable-binding element has empty content and does not have
a <code>select</code> attribute, then the value of the variable is an
empty string. Thus</p>

<eg><![CDATA[<xsl:variable name="x"/>]]></eg>

<p>is equivalent to</p>

<eg><![CDATA[<xsl:variable name="x" select="''"/>]]></eg>

</item>

</ulist>

<note><p>When a variable is used to select nodes by position, be careful
not to do:</p>

<eg><![CDATA[<xsl:variable name="n">2</xsl:variable>
...
<xsl:value-of select="item[$n]"/>]]></eg>

<p>This will output the value of the first item element, because the
variable <code>n</code> will be bound to a result tree fragment, not a
number. Instead, do either</p>

<eg><![CDATA[<xsl:variable name="n" select="2"/>
...
<xsl:value-of select="item[$n]"/>]]></eg>

<p>or</p>

<eg><![CDATA[<xsl:variable name="n">2</xsl:variable>
...
<xsl:value-of select="item[position()=$n]"/>]]></eg>
</note>

<note><p>One convenient way to specify the empty node-set as the default
value of a parameter is:</p>

<eg><![CDATA[<xsl:param name="x" select="/.."/>]]></eg>
</note>

</div2>

<div2 id="copy-of">
<head>Using Values of Variables and Parameters with
<code>xsl:copy-of</code></head>

<e:element-syntax name="copy-of">
  <e:in-category name="instruction"/>
  <e:attribute name="select" required="yes">
    <e:data-type name="expression"/>
  </e:attribute>
  <e:empty/>
</e:element-syntax>

<p>The <code>xsl:copy-of</code> element can be used to insert a result
tree fragment into the result tree, without first converting it to a
string as <code>xsl:value-of</code> does (see <specref
ref="value-of"/>).  The required <code>select</code> attribute
contains an <termref def="dt-expression">expression</termref>.  When
the result of evaluating the expression is a result tree fragment, the
complete fragment is copied into the result tree.  When the result is
a node-set, all the nodes in the set are copied in document order into
the result tree; copying an element node copies the attribute nodes,
namespace nodes and children of the element node as well as the
element node itself; a root node is copied by copying its children.
When the result is neither a node-set nor a result tree fragment, the
result is converted to a string and then inserted into the result
tree, as with <code>xsl:value-of</code>.</p>

</div2>

<div2 id="top-level-variables">
<head>Top-level Variables and Parameters</head>

<p>Both <code>xsl:variable</code> and <code>xsl:param</code> are
allowed as <termref def="dt-top-level">top-level</termref> elements.
A top-level variable-binding element declares a global variable that
is visible everywhere.  A top-level <code>xsl:param</code> element
declares a parameter to the stylesheet; XSLT does not define the
mechanism by which parameters are passed to the stylesheet.  It is an
error if a stylesheet contains more than one binding of a top-level
variable with the same name and same <termref
def="dt-import-precedence">import precedence</termref>. At the
top-level, the expression or template specifying the variable value is
evaluated with the same context as that used to process the root node
of the source document: the current node is the root node of the
source document and the current node list is a list containing just
the root node of the source document.  If the template or expression
specifying the value of a global variable <var>x</var> references a
global variable <var>y</var>, then the value for <var>y</var> must
be computed before the value of <var>x</var>.  It is an error if it
is impossible to do this for all global variable definitions; in other
words, it is an error if the definitions are circular.</p>

<p>This example declares a global variable <code>para-font-size</code>,
which it references in an attribute value template.</p>

<eg><![CDATA[<xsl:variable name="para-font-size">12pt</xsl:variable>

<xsl:template match="para">
 <fo:block font-size="{$para-font-size}">
   <xsl:apply-templates/>
 </fo:block>
</xsl:template>
]]></eg>

</div2>

<div2 id="local-variables">
<head>Variables and Parameters within Templates</head>

<p>As well as being allowed at the top-level, both
<code>xsl:variable</code> and <code>xsl:param</code> are also
allowed in templates.  <code>xsl:variable</code> is allowed anywhere
within a template that an instruction is allowed.  In this case, the
binding is visible for all following siblings and their descendants.
Note that the binding is not visible for the <code>xsl:variable</code>
element itself.  <code>xsl:param</code> is allowed as a child
at the beginning of an <code>xsl:template</code> element.  In this
context, the binding is visible for all following siblings and their
descendants.  Note that the binding is not visible for the
<code>xsl:param</code> element itself.</p>

<p><termdef id="dt-shadows" term="Shadows">A binding
<term>shadows</term> another binding if the binding occurs at a point
where the other binding is visible, and the bindings have the same
name.</termdef> It is an error if a binding established by an
<code>xsl:variable</code> or <code>xsl:param</code> element within a
template <termref def="dt-shadows">shadows</termref> another binding
established by an <code>xsl:variable</code> or <code>xsl:param</code>
element also within the template.  It is not an error if a binding
established by an <code>xsl:variable</code> or <code>xsl:param</code>
element in a template <termref def="dt-shadows">shadows</termref>
another binding established by an <code>xsl:variable</code> or
<code>xsl:param</code> <termref def="dt-top-level">top-level</termref>
element.  Thus, the following is an error:</p>

<eg role="error"><![CDATA[<xsl:template name="foo">
<xsl:param name="x" select="1"/>
<xsl:variable name="x" select="2"/>
</xsl:template>]]></eg>

<p>However, the following is allowed:</p>

<eg><![CDATA[<xsl:param name="x" select="1"/>
<xsl:template name="foo">
<xsl:variable name="x" select="2"/>
</xsl:template>]]></eg>

<note><p>The nearest equivalent in Java to an <code>xsl:variable</code>
element in a template is a final local variable declaration with an
initializer.  For example,</p>

<eg><![CDATA[<xsl:variable name="x" select="'value'"/>]]></eg>

<p>has similar semantics to</p>

<eg>final Object x = "value";</eg>

<p>XSLT does not provide an equivalent to the Java assignment operator</p>

<eg>x = "value";</eg>

<p>because this would make it harder to create an implementation that
processes a document other than in a batch-like way, starting at the
beginning and continuing through to the end.</p></note>

</div2>

<div2>
<head>Passing Parameters to Templates</head>

<e:element-syntax name="with-param">
  <e:attribute name="name" required="yes">
    <e:data-type name="qname"/>
  </e:attribute>
  <e:attribute name="select">
    <e:data-type name="expression"/>
  </e:attribute>
  <e:model name="template"/>
</e:element-syntax>

<p>Parameters are passed to templates using the
<code>xsl:with-param</code> element.  The required <code>name</code>
attribute specifies the name of the parameter (the variable the value
of whose binding is to be replaced).  The value of the
<code>name</code> attribute is a <xnt
href="&XMLNames;#NT-QName">QName</xnt>, which is expanded as described
in <specref ref="qname"/>.  <code>xsl:with-param</code> is allowed
within both <code>xsl:call-template</code> and
<code>xsl:apply-templates</code>.  The value of the parameter is
specified in the same way as for <code>xsl:variable</code> and
<code>xsl:param</code>.  The current node and current node list used
for computing the value specified by <code>xsl:with-param</code>
element is the same as that used for the
<code>xsl:apply-templates</code> or <code>xsl:call-template</code>
element within which it occurs.  It is not an error to pass a
parameter <var>x</var> to a template that does not have an
<code>xsl:param</code> element for <var>x</var>; the parameter is
simply ignored.</p>

<p>This example defines a named template for a
<code>numbered-block</code> with an argument to control the format of
the number.</p>

<eg><![CDATA[<xsl:template name="numbered-block">
  <xsl:param name="format">1. </xsl:param>
  <fo:block>
    <xsl:number format="{$format}"/>
    <xsl:apply-templates/>
  </fo:block>
</xsl:template>

<xsl:template match="ol//ol/li">
  <xsl:call-template name="numbered-block">
    <xsl:with-param name="format">a. </xsl:with-param>
  </xsl:call-template>
</xsl:template>]]></eg>

</div2>

</div1>

<div1 id="add-func">
<head>Additional Functions</head>

<p>This section describes XSLT-specific additions to the core XPath
function library.  Some of these additional functions also make use of
information specified by <termref def="dt-top-level">top-level</termref>
elements in the stylesheet; this section also describes these
elements.</p>

<div2 id="document">

<head>Multiple Source Documents</head>

<proto name="document" return-type="node-set"><arg type="object"/>
<arg type="node-set" occur="opt"/></proto>

<p>The <function>document</function> function allows
access to XML documents other than the main source document.</p>

<p>When the <function>document</function> function has exactly one
argument and the argument is a node-set, then the result is the union,
for each node in the argument node-set, of the result of calling the
<function>document</function> function with the first argument being
the <xtermref href="&XPath;#dt-string-value">string-value</xtermref>
of the node, and the second argument being a node-set with the node as
its only member. When the <function>document</function> function has
two arguments and the first argument is a node-set, then the result is
the union, for each node in the argument node-set, of the result of
calling the <function>document</function> function with the first
argument being the <xtermref
href="&XPath;#dt-string-value">string-value</xtermref> of the node,
and with the second argument being the second argument passed to the
<function>document</function> function.</p>

<p>When the first argument to the <function>document</function>
function is not a node-set, the first argument is converted to a
string as if by a call to the <xfunction>string</xfunction> function.
This string is treated as a URI reference; the resource identified by
the URI is retrieved. The data resulting from the retrieval action is
parsed as an XML document and a tree is constructed in accordance with
the data model (see <specref ref="data-model"/>).  If there is an
error retrieving the resource, then the XSLT processor may signal an
error; if it does not signal an error, it must recover by returning an
empty node-set.  One possible kind of retrieval error is that the XSLT
processor does not support the URI scheme used by the URI.  An XSLT
processor is not required to support any particular URI schemes.  The
documentation for an XSLT processor should specify which URI schemes
the XSLT processor supports.</p>

<p>If the URI reference does not contain a fragment identifier, then a
node-set containing just the root node of the document is returned.
If the URI reference does contain a fragment identifier, the function
returns a node-set containing the nodes in the tree identified by the
fragment identifier of the URI reference. The semantics of the
fragment identifier is dependent on the media type of the result of
retrieving the URI.  If there is an error in processing the fragment
identifier, the XSLT processor may signal the error; if it does not
signal the error, it must recover by returning an empty node-set.
Possible errors include:</p>

<ulist>

<item><p>The fragment identifier identifies something that cannot be
represented by an XSLT node-set (such as a range of characters within
a text node).</p></item>

<item><p>The XSLT processor does not support fragment identifiers for
the media-type of the retrieval result.  An XSLT processor is not
required to support any particular media types.  The documentation for
an XSLT processor should specify for which media types the XSLT
processor supports fragment identifiers.</p></item>

</ulist>

<p>The data resulting from the retrieval action is parsed as an XML
document regardless of the media type of the retrieval result; if the
top-level media type is <code>text</code>, then it is parsed in the
same way as if the media type were <code>text/xml</code>; otherwise,
it is parsed in the same way as if the media type were
<code>application/xml</code>.</p>

<note><p>Since there is no top-level <code>xml</code> media type, data
with a media type other than <code>text/xml</code> or
<code>application/xml</code> may in fact be XML.</p></note>

<p>The URI reference may be relative. The base URI (see <specref
ref="base-uri"/>) of the node in the second argument node-set that is
first in document order is used as the base URI for resolving the
relative URI into an absolute URI.  If the second argument is omitted,
then it defaults to the node in the stylesheet that contains the
expression that includes the call to the <function>document</function>
function.  Note that a zero-length URI reference is a reference to the
document relative to which the URI reference is being resolved; thus
<code>document("")</code> refers to the root node of the stylesheet;
the tree representation of the stylesheet is exactly the same as if
the XML document containing the stylesheet was the initial source
document.</p>

<p>Two documents are treated as the same document if they are
identified by the same URI. The URI used for the comparison is the
absolute URI into which any relative URI was resolved and does not
include any fragment identifier.  One root node is treated as the same
node as another root node if the two nodes are from the same document.
Thus, the following expression will always be true:</p>

<eg>generate-id(document("foo.xml"))=generate-id(document("foo.xml"))</eg>

<p>The <function>document</function> function gives rise to the
possibility that a node-set may contain nodes from more than one
document.  With such a node-set, the relative document order of two
nodes in the same document is the normal <xtermref
href="&XPath;#dt-document-order">document order</xtermref> defined by
XPath <bibref ref="XPATH"/>.  The relative document order of two nodes
in different documents is determined by an implementation-dependent
ordering of the documents containing the two nodes.  There are no
constraints on how the implementation orders documents other than that
it must do so consistently: an implementation must always use the same
order for the same set of documents.</p>

</div2>

<div2 id="key">
<head>Keys</head>

<p>Keys provide a way to work with documents that contain an implicit
cross-reference structure.  The <code>ID</code>, <code>IDREF</code>
and <code>IDREFS</code> attribute types in XML provide a mechanism to
allow XML documents to make their cross-reference explicit.  XSLT
supports this through the XPath <xfunction>id</xfunction> function.
However, this mechanism has a number of limitations:</p>

<ulist>

<item><p>ID attributes must be declared as such in the DTD.  If an ID
attribute is declared as an ID attribute only in the external DTD
subset, then it will be recognized as an ID attribute only if the XML
processor reads the external DTD subset.  However, XML does not require
XML processors to read the external DTD, and they may well choose not
to do so, especially if the document is declared
<code>standalone="yes"</code>.</p></item>

<item><p>A document can contain only a single set of unique IDs.
There cannot be separate independent sets of unique IDs.</p></item>

<item><p>The ID of an element can only be specified in an attribute;
it cannot be specified by the content of the element, or by a child
element.</p></item>

<item><p>An ID is constrained to be an XML name.  For example, it
cannot contain spaces.</p></item>

<item><p>An element can have at most one ID.</p></item>

<item><p>At most one element can have a particular ID.</p></item>

</ulist>

<p>Because of these limitations XML documents sometimes contain a
cross-reference structure that is not explicitly declared by
ID/IDREF/IDREFS attributes.</p>

<p>A key is a triple containing:</p>

<olist>

<item><p>the node which has the key</p></item>

<item><p>the name of the key (an <xtermref
href="&XPath;#dt-expanded-name">expanded-name</xtermref>)</p></item>

<item><p>the value of the key (a string)</p></item>

</olist>

<p>A stylesheet declares a set of keys for each document using the
<code>xsl:key</code> element.  When this set of keys contains a member
with node <var>x</var>, name <var>y</var> and value
<var>z</var>, we say that node <var>x</var> has a key with name
<var>y</var> and value <var>z</var>.</p>

<p>Thus, a key is a kind of generalized ID, which is not subject to the
same limitations as an XML ID:</p>

<ulist>

<item><p>Keys are declared in the stylesheet using
<code>xsl:key</code> elements.</p></item>

<item><p>A key has a name as well as a value; each key name may be
thought of as distinguishing a separate, independent space of
identifiers.</p></item>

<item><p>The value of a named key for an element may be specified in
any convenient place; for example, in an attribute, in a child element
or in content.  An XPath expression is used to specify where to find
the value for a particular named key.</p></item>

<item><p>The value of a key can be an arbitrary string; it is not
constrained to be a name.</p></item>

<item><p>There can be multiple keys in a document with the same node,
same key name, but different key values.</p></item>

<item><p>There can be multiple keys in a document with the same key
name, same key value, but different nodes.</p></item>

</ulist>

<e:element-syntax name="key">
  <e:in-category name="tepe-seviyeden-eleman"/>
  <e:attribute name="name" required="yes">
    <e:data-type name="qname"/>
  </e:attribute>
  <e:attribute name="match" required="yes">
    <e:data-type name="pattern"/>
  </e:attribute>
  <e:attribute name="use" required="yes">
    <e:data-type name="expression"/>
  </e:attribute>
  <e:empty/>
</e:element-syntax>

<p>The <code>xsl:key</code> element is used to declare keys.  The
<code>name</code> attribute specifies the name of the key.  The value
of the <code>name</code> attribute is a <xnt
href="&XMLNames;#NT-QName">QName</xnt>, which is expanded as described
in <specref ref="qname"/>. The <code>match</code> attribute is a <nt
def="NT-Pattern">Pattern</nt>; an <code>xsl:key</code> element gives
information about the keys of any node that matches the pattern
specified in the match attribute.  The <code>use</code> attribute is
an <termref def="dt-expression">expression</termref> specifying the
values of the key; the expression is evaluated once for each node that
matches the pattern.  If the result is a node-set, then for each node
in the node-set, the node that matches the pattern has a key of the
specified name whose value is the string-value of the node in the
node-set; otherwise, the result is converted to a string, and the node
that matches the pattern has a key of the specified name with value
equal to that string.  Thus, a node <var>x</var> has a key with name
<var>y</var> and value <var>z</var> if and only if there is an
<code>xsl:key</code> element such that:</p>

<ulist>

<item><p><var>x</var> matches the pattern specified in the
<code>match</code> attribute of the <code>xsl:key</code> element;</p></item>

<item><p>the value of the <code>name</code> attribute of the
<code>xsl:key</code> element is equal to <var>y</var>;
and</p></item>

<item><p>when the expression specified in the <code>use</code>
attribute of the <code>xsl:key</code> element is evaluated with
<var>x</var> as the current node and with a node list containing
just <var>x</var> as the current node list resulting in an object
<var>u</var>, then either <var>z</var> is equal to the result of
converting <var>u</var> to a string as if by a call to the
<xfunction>string</xfunction> function, or <var>u</var> is a
node-set and <var>z</var> is equal to the string-value of one or
more of the nodes in <var>u</var>.</p></item>

</ulist>

<p>Note also that there may be more than one <code>xsl:key</code>
element that matches a given node; all of the matching
<code>xsl:key</code> elements are used, even if they do not have the
same <termref def="dt-import-precedence">import
precedence</termref>.</p>

<p>It is an error for the value of either the <code>use</code>
attribute or the <code>match</code> attribute to contain a <xnt
href="&XPath;#NT-VariableReference">VariableReference</xnt>.</p>

<proto name="key" return-type="node-set"><arg type="string"/><arg type="object"/></proto>

<p>The <function>key</function> function does for keys what the
<xfunction>id</xfunction> function does for IDs.  The first argument
specifies the name of the key. The value of the argument must be a
<xnt href="&XMLNames;#NT-QName">QName</xnt>, which is expanded as
described in <specref ref="qname"/>. When the second argument to the
<function>key</function> function is of type node-set, then the result
is the union of the result of applying the <function>key</function>
function to the string <xtermref
href="&XPath;#dt-value">value</xtermref> of each of the nodes in the
argument node-set.  When the second argument to
<function>key</function> is of any other type, the argument is
converted to a string as if by a call to the
<xfunction>string</xfunction> function; it returns a node-set
containing the nodes in the same document as the context node that
have a value for the named key equal to this string.</p>

<p>For example, given a declaration</p>

<eg><![CDATA[<xsl:key name="idkey" match="div" use="@id"/>]]></eg>

<p>an expression <code>key("idkey",@ref)</code> will return the same
node-set as <code>id(@ref)</code>, assuming that the only ID attribute
declared in the XML source document is:</p>

<eg><![CDATA[<!ATTLIST div id ID #IMPLIED>]]></eg>

<p>and that the <code>ref</code> attribute of the current node
contains no whitespace.</p>

<p>Suppose a document describing a function library uses a
<code>prototype</code> element to define functions</p>

<eg><![CDATA[<prototype name="key" return-type="node-set">
<arg type="string"/>
<arg type="object"/>
</prototype>]]></eg>

<p>and a <code>function</code> element to refer to function names</p>

<eg><![CDATA[<function>key</function>]]></eg>

<p>Then the stylesheet could generate hyperlinks between the
references and definitions as follows:</p>

<eg><![CDATA[<xsl:key name="func" match="prototype" use="@name"/>

<xsl:template match="function">
<b>
  <a href="#{generate-id(key('func',.))}">
    <xsl:apply-templates/>
  </a>
</b>
</xsl:template>

<xsl:template match="prototype">
<p><a name="{generate-id()}">
<b>Function: </b>
...
</a></p>
</xsl:template>]]></eg>

<p>The <function>key</function> can be used to retrieve a key from a
document other than the document containing the context node.  For
example, suppose a document contains bibliographic references in the
form <code><![CDATA[<bibref>XSLT</bibref>]]></code>, and there is a
separate XML document <code>bib.xml</code> containing a bibliographic
database with entries in the form:</p>

<eg><![CDATA[<entry name="XSLT">...</entry>]]></eg>

<p>Then the stylesheet could use the following to transform the
<code>bibref</code> elements:</p>

<eg><![CDATA[<xsl:key name="bib" match="entry" use="@name"/>

<xsl:template match="bibref">
  <xsl:variable name="name" select="."/>
  <xsl:for-each select="document('bib.xml')">
    <xsl:apply-templates select="key('bib',$name)"/>
  </xsl:for-each>
</xsl:template>]]></eg>

</div2>

<div2 id="format-number">
<head>Number Formatting</head>

<proto name="format-number" return-type="string"><arg type="number"/><arg type="string"/><arg occur="opt" type="string"/></proto>

<p>The <function>format-number</function> function converts its first
argument to a string using the format pattern string specified by the
second argument and the decimal-format named by the third argument, or
the default decimal-format, if there is no third argument.  The format
pattern string is in the syntax specified by the JDK 1.1 <loc href=
"http://java.sun.com/products/jdk/1.1/docs/api/java.text.DecimalFormat.html"
>DecimalFormat</loc> class. The format pattern string is in a
localized notation: the decimal-format determines what characters have
a special meaning in the pattern (with the exception of the quote
character, which is not localized).  The format pattern must not
contain the currency sign (#x00A4); support for this feature was added
after the initial release of JDK 1.1.  The decimal-format name must be
a <xnt href="&XMLNames;#NT-QName">QName</xnt>, which is expanded as
described in <specref ref="qname"/>.  It is an error if the stylesheet
does not contain a declaration of the decimal-format with the specified
<xtermref href="&XPath;#dt-expanded-name">expanded-name</xtermref>.</p>

<note><p>Implementations are not required to use the JDK 1.1
implementation, nor are implementations required to be implemented in
Java.</p></note>

<note><p>Stylesheets can use other facilities in XPath to control
rounding.</p></note>

<e:element-syntax name="decimal-format">
  <e:in-category name="tepe-seviyeden-eleman"/>

  <e:attribute name="name">
    <e:data-type name="qname"/>
  </e:attribute>
  <e:attribute name="decimal-separator">
    <e:data-type name="char"/>
  </e:attribute>
  <e:attribute name="grouping-separator">
    <e:data-type name="char"/>
  </e:attribute>
  <e:attribute name="infinity">
    <e:data-type name="string"/>
  </e:attribute>
  <e:attribute name="minus-sign">
    <e:data-type name="char"/>
  </e:attribute>
  <e:attribute name="NaN">
    <e:data-type name="string"/>
  </e:attribute>
  <e:attribute name="percent">
    <e:data-type name="char"/>
  </e:attribute>
  <e:attribute name="per-mille">
    <e:data-type name="char"/>
  </e:attribute>
  <e:attribute name="zero-digit">
    <e:data-type name="char"/>
  </e:attribute>
  <e:attribute name="digit">
    <e:data-type name="char"/>
  </e:attribute>
  <e:attribute name="pattern-separator">
    <e:data-type name="char"/>
  </e:attribute>
  <e:empty/>
</e:element-syntax>

<p>The <code>xsl:decimal-format</code> element declares a
decimal-format, which controls the interpretation of a format pattern
used by the <function>format-number</function> function.  If there is
a <code>name</code> attribute, then the element declares a named
decimal-format; otherwise, it declares the default decimal-format.
The value of the <code>name</code> attribute is a <xnt
href="&XMLNames;#NT-QName">QName</xnt>, which is expanded as described
in <specref ref="qname"/>.  It is an error to declare either the
default decimal-format or a decimal-format with a given name more than
once (even with different <termref def="dt-import-precedence">import
precedence</termref>), unless it is declared every time with the same
value for all attributes (taking into account any default values).</p>

<p>The other attributes on <code>xsl:decimal-format</code> correspond
to the methods on the JDK 1.1 <loc href=
"http://java.sun.com/products/jdk/1.1/docs/api/java.text.DecimalFormatSymbols.html"
>DecimalFormatSymbols</loc> class.  For each
<code>get</code>/<code>set</code> method pair there is an attribute
defined for the <code>xsl:decimal-format</code> element.</p>

<p>The following attributes both control the interpretation of
characters in the format pattern and specify characters that may
appear in the result of formatting the number:</p>

<ulist>

<item><p><code>decimal-separator</code> specifies the character used
for the decimal sign; the default value is the period character
(<code>.</code>)</p></item>

<item><p><code>grouping-separator</code> specifies the character used
as a grouping (e.g. thousands) separator; the default value is the
comma character (<code>,</code>)</p></item>

<item><p><code>percent</code> specifies the character used as a
percent sign; the default value is the percent character
(<code>%</code>)</p></item>

<item><p><code>per-mille</code> specifies the character used as a per
mille sign; the default value is the Unicode per-mille character
(#x2030)</p></item>

<item><p><code>zero-digit</code> specifies the character used as the
digit zero; the default value is the digit zero
(<code>0</code>)</p></item>

</ulist>

<p>The following attributes control the interpretation of characters
in the format pattern:</p>

<ulist>

<item><p><code>digit</code> specifies the character used for a digit
in the format pattern; the default value is the number sign character
(<code>#</code>)</p></item>

<item><p><code>pattern-separator</code> specifies the character used
to separate positive and negative sub patterns in a pattern; the
default value is the semi-colon character (<code>;</code>)</p></item>

</ulist>

<p>The following attributes specify characters or strings that may
appear in the result of formatting the number:</p>

<ulist>

<item><p><code>infinity</code> specifies the string used to represent
infinity; the default value is the string
<code>Infinity</code></p></item>

<item><p><code>NaN</code> specifies the string used to represent the
NaN value; the default value is the string <code>NaN</code></p></item>

<item><p><code>minus-sign</code> specifies the character used as the
default minus sign; the default value is the hyphen-minus character
(<code>-</code>, #x2D)</p></item>

</ulist>

</div2>

<div2 id="misc-func">
<head>Miscellaneous Additional Functions</head>

<proto name="current" return-type="node-set"></proto>

<p>The <function>current</function> function returns a node-set that
has the <termref def="dt-current-node">current node</termref> as its
only member.  For an outermost expression (an expression not occurring
within another expression), the current node is always the same as the
context node.  Thus,</p>

<eg><![CDATA[<xsl:value-of select="current()"/>]]></eg>

<p>means the same as</p>

<eg><![CDATA[<xsl:value-of select="."/>]]></eg>

<p>However, within square brackets the current node is usually
different from the context node. For example,</p>

<eg><![CDATA[<xsl:apply-templates select="//glossary/item[@name=current()/@ref]"/>]]></eg>

<p>will process all <code>item</code> elements that have a
<code>glossary</code> parent element and that have a <code>name</code>
attribute with value equal to the value of the current node's
<code>ref</code> attribute. This is different from</p>

<eg><![CDATA[<xsl:apply-templates select="//glossary/item[@name=./@ref]"/>]]></eg>

<p>which means the same as</p>

<eg><![CDATA[<xsl:apply-templates select="//glossary/item[@name=@ref]"/>]]></eg>

<p>and so would process all <code>item</code> elements that have a
<code>glossary</code> parent element and that have a <code>name</code>
attribute and a <code>ref</code> attribute with the same value.</p>

<p>It is an error to use the <function>current</function> function in
a <termref def="dt-pattern">pattern</termref>.</p>

<proto name="unparsed-entity-uri" return-type="string"><arg type="string"/></proto>

<p>The <function>unparsed-entity-uri</function> returns the URI of the
unparsed entity with the specified name in the same document as the
context node (see <specref ref="unparsed-entities"/>).  It returns the
empty string if there is no such entity.</p>

<proto name="generate-id" return-type="string"><arg occur="opt" type="node-set"/></proto>

<p>The <function>generate-id</function> function returns a string that
uniquely identifies the node in the argument node-set that is first in
document order.  The unique identifier must consist of ASCII
alphanumeric characters and must start with an alphabetic character.
Thus, the string is syntactically an XML name.  An implementation is
free to generate an identifier in any convenient way provided that it
always generates the same identifier for the same node and that
different identifiers are always generated from different nodes. An
implementation is under no obligation to generate the same identifiers
each time a document is transformed.  There is no guarantee that a
generated unique identifier will be distinct from any unique IDs
specified in the source document.  If the argument node-set is empty,
the empty string is returned. If the argument is omitted, it defaults
to the context node.</p>

<proto name="system-property" return-type="object"><arg type="string"/></proto>

<p>The argument must evaluate to a string that is a <xnt
href="&XMLNames;#NT-QName">QName</xnt>.  The <xnt
href="&XMLNames;#NT-QName">QName</xnt> is expanded into a name using
the namespace declarations in scope for the expression. The
<function>system-property</function> function returns an object
representing the value of the system property identified by the name.
If there is no such system property, the empty string should be
returned.</p>

<p>Implementations must provide the following system properties, which
are all in the XSLT namespace:</p>

<slist>

<sitem><code>xsl:version</code>, a number giving the version of XSLT
implemented by the processor; for XSLT processors implementing the
version of XSLT specified by this document, this is the number
1.0</sitem>

<sitem><code>xsl:vendor</code>, a string identifying the vendor of the
XSLT processor</sitem>

<sitem><code>xsl:vendor-url</code>, a string containing a URL
identifying the vendor of the XSLT processor; typically this is the
host page (home page) of the vendor's Web site.</sitem>

</slist>

</div2>

</div1>

<div1 id="message">
<head>Messages</head>

<e:element-syntax name="message">
  <e:in-category name="instruction"/>
  <e:attribute name="terminate">
    <e:constant value="yes"/>
    <e:constant value="no"/>
  </e:attribute>
  <e:model name="template"/>
</e:element-syntax>

<p>The <code>xsl:message</code> instruction sends a message in a way
that is dependent on the XSLT processor.  The content of the
<code>xsl:message</code> instruction is a template.  The
<code>xsl:message</code> is instantiated by instantiating the content
to create an XML fragment.  This XML fragment is the content of the
message.</p>

<note><p>An XSLT processor might implement <code>xsl:message</code> by
popping up an alert box or by writing to a log file.</p></note>

<p>If the <code>terminate</code> attribute has the value
<code>yes</code>, then the XSLT processor should terminate processing
after sending the message.  The default value is <code>no</code>.</p>

<p>One convenient way to do localization is to put the localized
information (message text, etc.) in an XML document, which becomes an
additional input file to the stylesheet.  For example, suppose
messages for a language <code><var>L</var></code> are stored in an XML
file <code>resources/<var>L</var>.xml</code> in the form:</p>

<eg><![CDATA[<messages>
  <message name="problem">A problem was detected.</message>
  <message name="error">An error was detected.</message>
</messages>
]]></eg>

<p>Then a stylesheet could use the following approach to localize
messages:</p>

<eg><![CDATA[<xsl:param name="lang" select="en"/>
<xsl:variable name="messages"
  select="document(concat('resources/', $lang, '.xml'))/messages"/>

<xsl:template name="localized-message">
  <xsl:param name="name"/>
  <xsl:message>
    <xsl:value-of select="$messages/message[@name=$name]"/>
  </xsl:message>
</xsl:template>

<xsl:template name="problem">
  <xsl:call-template name="localized-message"/>
    <xsl:with-param name="name">problem</xsl:with-param>
  </xsl:call-template>
</xsl:template>]]></eg>

</div1>

<div1 id="extension">
<head>Extensions</head>

<p>XSLT allows two kinds of extension, extension elements and
extension functions.</p>

<p>This version of XSLT does not provide a mechanism for defining
implementations of extensions.  Therefore, an XSLT stylesheet that must
be portable between XSLT implementations cannot rely on particular
extensions being available.  XSLT provides mechanisms that allow an
XSLT stylesheet to determine whether the XSLT processor by which it is
being processed has implementations of particular extensions
available, and to specify what should happen if those extensions are
not available.  If an XSLT stylesheet is careful to make use of these
mechanisms, it is possible for it to take advantage of extensions and
still work with any XSLT implementation.</p>

<div2 id="extension-element">
<head>Extension Elements</head>

<p><termdef id="dt-extension-namespace" term="Extension Namespace">The
element extension mechanism allows namespaces to be designated as
<term>extension namespace</term>s. When a namespace is designated as
an extension namespace and an element with a name from that namespace
occurs in a template, then the element is treated as an instruction
rather than as a literal result element.</termdef> The namespace
determines the semantics of the instruction.</p>

<note><p>Since an element that is a child of an
<code>xsl:stylesheet</code> element is not occurring <emph>in a
template</emph>, non-XSLT <termref
def="dt-top-level">top-level</termref> elements are not extension
elements as defined here, and nothing in this section applies to
them.</p></note>

<p>A namespace is designated as an extension namespace by using an
<code>extension-element-prefixes</code> attribute on an
<code>xsl:stylesheet</code> element or an
<code>xsl:extension-element-prefixes</code> attribute on a literal
result element or extension element.
The value of both these attributes is a
whitespace-separated list of namespace prefixes. The namespace bound
to each of the prefixes is designated as an extension namespace.  It
is an error if there is no namespace bound to the prefix on the
element bearing the <code>extension-element-prefixes</code> or
<code>xsl:extension-element-prefixes</code> attribute.  The default
namespace (as declared by <code>xmlns</code>) may be designated as an
extension namespace by including <code>#default</code> in the list of
namespace prefixes.  The designation of a namespace as an extension
namespace is effective within the subtree of the stylesheet rooted at
the element bearing the <code>extension-element-prefixes</code> or
<code>xsl:extension-element-prefixes</code> attribute;
a subtree rooted at an <code>xsl:stylesheet</code> element
does not include any stylesheets imported or included by children
of that <code>xsl:stylesheet</code> element.</p>

<p>If the XSLT processor does not have an implementation of a
particular extension element available, then the
<function>element-available</function> function must return false for
the name of the element.  When such an extension element is
instantiated, then the XSLT processor must perform fallback for the
element as specified in <specref ref="fallback"/>.  An XSLT processor
must not signal an error merely because a template contains an
extension element for which no implementation is available.</p>

<p>If the XSLT processor has an implementation of a particular
extension element available, then the
<function>element-available</function> function must return true for
the name of the element.</p>

</div2>

<div2>
<head>Extension Functions</head>

<p>If a <xnt href="&XPath;#NT-FunctionName">FunctionName</xnt> in a
<xnt href="&XPath;#NT-FunctionCall">FunctionCall</xnt> expression is
not an <xnt href="&XMLNames;#NT-NCName">NCName</xnt> (i.e. if it
contains a colon), then it is treated as a call to an extension
function.  The <xnt href="&XPath;#NT-FunctionName">FunctionName</xnt>
is expanded to a name using the namespace declarations from the
evaluation context.</p>

<p>If the XSLT processor does not have an implementation of an
extension function of a particular name available, then the
<function>function-available</function> function must return false for
that name.  If such an extension function occurs in an expression and
the extension function is actually called, the XSLT processor must
signal an error.  An XSLT processor must not signal an error merely
because an expression contains an extension function for which no
implementation is available.</p>

<p>If the XSLT processor has an implementation of an extension
function of a particular name available, then the
<function>function-available</function> function must return
true for that name. If such an extension is called, then the XSLT
processor must call the implementation passing it the function call
arguments; the result returned by the implementation is returned as
the result of the function call.</p>

</div2>

</div1>

<div1 id="fallback">
<head>Fallback</head>

<e:element-syntax name="fallback">
  <e:in-category name="instruction"/>
  <e:model name="template"/>
</e:element-syntax>

<p>Normally, instantiating an <code>xsl:fallback</code> element does
nothing.  However, when an XSLT processor performs fallback for an
instruction element, if the instruction element has one or more
<code>xsl:fallback</code> children, then the content of each of the
<code>xsl:fallback</code> children must be instantiated in sequence;
otherwise, an error must be signaled. The content of an
<code>xsl:fallback</code> element is a template.</p>

<p>The following functions can be used with the
<code>xsl:choose</code> and <code>xsl:if</code> instructions to
explicitly control how a stylesheet should behave if particular
elements or functions are not available.</p>

<proto name="element-available" return-type="boolean"><arg
type="string"/></proto>

<p>The argument must evaluate to a string that is a <xnt
href="&XMLNames;#NT-QName">QName</xnt>.  The <xnt
href="&XMLNames;#NT-QName">QName</xnt> is expanded into an <xtermref
href="&XPath;#dt-expanded-name">expanded-name</xtermref> using the
namespace declarations in scope for the expression. The
<function>element-available</function> function returns true if and
only if the expanded-name is the name of an instruction.  If the
expanded-name has a namespace URI equal to the XSLT namespace URI,
then it refers to an element defined by XSLT.  Otherwise, it refers to
an extension element. If the expanded-name has a null namespace URI,
the <function>element-available</function> function will return
false.</p>

<proto name="function-available" return-type="boolean"><arg
type="string"/></proto>

<p>The argument must evaluate to a string that is a <xnt
href="&XMLNames;#NT-QName">QName</xnt>.  The <xnt
href="&XMLNames;#NT-QName">QName</xnt> is expanded into an <xtermref
href="&XPath;#dt-expanded-name">expanded-name</xtermref> using the
namespace declarations in scope for the expression. The
<function>function-available</function> function returns true if and
only if the expanded-name is the name of a function in the function
library. If the expanded-name has a non-null namespace URI, then it
refers to an extension function; otherwise, it refers to a function
defined by XPath or XSLT.</p>

</div1>

<div1 id="output">
<head>Output</head>

<e:element-syntax name="output">
  <e:in-category name="tepe-seviyeden-eleman"/>
  <e:attribute name="method">
    <e:constant value="xml"/>
    <e:constant value="html"/>
    <e:constant value="text"/>
    <e:data-type name="qname-but-not-ncname"/>
  </e:attribute>
  <e:attribute name="version">
    <e:data-type name="nmtoken"/>
  </e:attribute>
  <e:attribute name="encoding">
    <e:data-type name="string"/>
  </e:attribute>
  <e:attribute name="omit-xml-declaration">
    <e:constant value="yes"/>
    <e:constant value="no"/>
  </e:attribute>
  <e:attribute name="standalone">
    <e:constant value="yes"/>
    <e:constant value="no"/>
  </e:attribute>
  <e:attribute name="doctype-public">
    <e:data-type name="string"/>
  </e:attribute>
  <e:attribute name="doctype-system">
    <e:data-type name="string"/>
  </e:attribute>
  <e:attribute name="cdata-section-elements">
    <e:data-type name="qnames"/>
  </e:attribute>
  <e:attribute name="indent">
    <e:constant value="yes"/>
    <e:constant value="no"/>
  </e:attribute>
  <e:attribute name="media-type">
    <e:data-type name="string"/>
  </e:attribute>
  <e:empty/>
</e:element-syntax>

<p>An XSLT processor may output the result tree as a sequence of
bytes, although it is not required to be able to do so (see <specref
ref="conformance"/>). The <code>xsl:output</code> element allows
stylesheet authors to specify how they wish the result tree to be
output. If an XSLT processor outputs the result tree, it should do so
as specified by the <code>xsl:output</code> element; however, it is
not required to do so.</p>

<p>The <code>xsl:output</code> element is only allowed as a <termref
def="dt-top-level">top-level</termref> element.</p>

<p>The <code>method</code> attribute on <code>xsl:output</code>
identifies the overall method that should be used for outputting the
result tree.  The value must be a <xnt
href="&XMLNames;#NT-QName">QName</xnt>.  If the <xnt
href="&XMLNames;#NT-QName">QName</xnt> does not have a prefix, then it
identifies a method specified in this document and must be one of
<code>xml</code>, <code>html</code> or <code>text</code>.  If the <xnt
href="&XMLNames;#NT-QName">QName</xnt> has a prefix, then the <xnt
href="&XMLNames;#NT-QName">QName</xnt> is expanded into an <xtermref
href="&XPath;#dt-expanded-name">expanded-name</xtermref> as described
in <specref ref="qname"/>; the expanded-name identifies the output
method; the behavior in this case is not specified by this
document.</p>

<p>The default for the <code>method</code> attribute is chosen as
follows.  If</p>

<ulist>

<item><p>the root node of the result tree has an element
child,</p></item>

<item><p>the expanded-name of the first element child of the root node
(i.e. the document element) of the result tree has local part
<code>html</code> (in any combination of upper and lower case) and a
null namespace URI, and</p></item>

<item><p>any text nodes preceding the first element child of the root
node of the result tree contain only whitespace characters,</p></item>

</ulist>

<p>then the default output method is <code>html</code>; otherwise, the
default output method is <code>xml</code>.  The default output method
should be used if there are no <code>xsl:output</code> elements or if
none of the <code>xsl:output</code> elements specifies a value for the
<code>method</code> attribute.</p>

<p>The other attributes on <code>xsl:output</code> provide parameters
for the output method.  The following attributes are allowed:</p>

<ulist>

<item><p><code>version</code> specifies the version of the output
method</p></item>

<item><p><code>indent</code> specifies whether the XSLT processor may
add additional whitespace when outputting the result tree; the value
must be <code>yes</code> or <code>no</code></p></item>

<item><p><code>encoding</code> specifies the preferred character
encoding that the XSLT processor should use to encode sequences of
characters as sequences of bytes; the value of the attribute should be
treated case-insensitively; the value must contain only characters in
the range #x21 to #x7E (i.e. printable ASCII characters); the value
should either be a <code>charset</code> registered with the Internet
Assigned Numbers Authority <bibref ref="IANA"/>, <bibref
ref="RFC2278"/> or start with <code>X-</code></p></item>

<item><p><code>media-type</code> specifies the media type (MIME
content type) of the data that results from outputting the result
tree; the <code>charset</code> parameter should not be specified
explicitly; instead, when the top-level media type is
<code>text</code>, a <code>charset</code> parameter should be added
according to the character encoding actually used by the output
method</p></item>

<item><p><code>doctype-system</code> specifies the system identifier
to be used in the document type declaration</p></item>

<item><p><code>doctype-public</code> specifies the public identifier
to be used in the document type declaration</p></item>

<item><p><code>omit-xml-declaration</code> specifies whether the XSLT
processor should output an XML declaration; the value must be
<code>yes</code> or <code>no</code></p></item>

<item><p><code>standalone</code> specifies whether the XSLT processor
should output a standalone document declaration; the value must be
<code>yes</code> or <code>no</code></p></item>

<item><p><code>cdata-section-elements</code> specifies a list of the
names of elements whose text node children should be output using
CDATA sections</p></item>

</ulist>

<p>The detailed semantics of each attribute will be described
separately for each output method for which it is applicable.  If the
semantics of an attribute are not described for an output method, then
it is not applicable to that output method.</p>

<p>A stylesheet may contain multiple <code>xsl:output</code> elements
and may include or import stylesheets that also contain
<code>xsl:output</code> elements.  All the <code>xsl:output</code>
elements occurring in a stylesheet are merged into a single effective
<code>xsl:output</code> element. For the
<code>cdata-section-elements</code> attribute, the effective value is
the union of the specified values.  For other attributes, the
effective value is the specified value with the highest <termref
def="dt-import-precedence">import precedence</termref>. It is an error
if there is more than one such value for an attribute.  An XSLT
processor may signal the error; if it does not signal the error, if
should recover by using the value that occurs last in the stylesheet.
The values of attributes are defaulted after the
<code>xsl:output</code> elements have been merged; different output
methods may have different default values for an attribute.</p>

<div2>
<head>XML Output Method</head>

<p>The <code>xml</code> output method outputs the result tree as a
well-formed XML external general parsed entity. If the root node of
the result tree has a single element node child and no text node
children, then the entity should also be a well-formed XML document
entity. When the entity is referenced within a trivial XML document
wrapper like this</p>

<eg><![CDATA[
<!DOCTYPE doc [
<!ENTITY e SYSTEM "]]><var>entity-URI</var><![CDATA[">
]>
<doc>&e;</doc>]]></eg>

<p>where <code><var>entity-URI</var></code> is a URI for the entity,
then the wrapper
document as a whole should be a well-formed XML document conforming to
the XML Namespaces Recommendation <bibref ref="XMLNAMES"/>.  In
addition, the output should be such that if a new tree was constructed
by parsing the wrapper as an XML document as specified in <specref
ref="data-model"/>, and then removing the document element, making its
children instead be children of the root node, then the new tree would
be the same as the result tree, with the following possible
exceptions:</p>

<ulist>

<item><p>The order of attributes in the two trees may be
different.</p></item>

<item><p>The new tree may contain namespace nodes that were not
present in the result tree.</p>
<note><p>An XSLT processor may need to add
namespace declarations in the course of outputting the result tree as
XML.</p></note>
</item>

</ulist>

<p>If the XSLT processor generated a document type declaration because
of the <code>doctype-system</code> attribute, then the above
requirements apply to the entity with the generated document type
declaration removed.</p>

<p>The <code>version</code> attribute specifies the version of XML to
be used for outputting the result tree.  If the XSLT processor does
not support this version of XML, it should use a version of XML that
it does support.  The version output in the XML declaration (if an XML
declaration is output) should correspond to the version of XML that
the processor used for outputting the result tree. The value of the
<code>version</code> attribute should match the <xnt
href="&XML;#NT-VersionNum">VersionNum</xnt> production of the XML
Recommendation <bibref ref="XML"/>. The default value is
<code>1.0</code>.</p>

<p>The <code>encoding</code> attribute specifies the preferred
encoding to use for outputting the result tree.  XSLT processors are
required to respect values of <code>UTF-8</code> and
<code>UTF-16</code>.  For other values, if the XSLT processor does not
support the specified encoding it may signal an error; if it does not
signal an error it should use <code>UTF-8</code> or
<code>UTF-16</code> instead.  The XSLT processor must not use an
encoding whose name does not match the <xnt
href="&XML;#NT-EncName">EncName</xnt> production of the XML
Recommendation <bibref ref="XML"/>.  If no <code>encoding</code>
attribute is specified, then the XSLT processor should use either
<code>UTF-8</code> or <code>UTF-16</code>.  It is possible that the
result tree will contain a character that cannot be represented in the
encoding that the XSLT processor is using for output.  In this case,
if the character occurs in a context where XML recognizes character
references (i.e. in the value of an attribute node or text node), then
the character should be output as a character reference; otherwise
(for example if the character occurs in the name of an element) the
XSLT processor should signal an error.</p>

<p>If the <code>indent</code> attribute has the value
<code>yes</code>, then the <code>xml</code> output method may output
whitespace in addition to the whitespace in the result tree (possibly
based on whitespace stripped from either the source document or the
stylesheet) in order to indent the result nicely; if the
<code>indent</code> attribute has the value <code>no</code>, it should
not output any additional whitespace. The default value is
<code>no</code>.  The <code>xml</code> output method should use an
algorithm to output additional whitespace that ensures that the result
if whitespace were to be stripped from the output using the process
described in <specref ref="strip"/> with the set of
whitespace-preserving elements consisting of just
<code>xsl:text</code> would be the same when additional whitespace is
output as when additional whitespace is not output.</p>

<note><p>It is usually not safe to use <code>indent="yes"</code> with
document types that include element types with mixed content.</p></note>

<p>The <code>cdata-section-elements</code> attribute contains a
whitespace-separated list of <xnt
href="&XMLNames;#NT-QName">QName</xnt>s.  Each <xnt
href="&XMLNames;#NT-QName">QName</xnt> is expanded into an
expanded-name using the namespace declarations in effect on the
<code>xsl:output</code> element in which the <xnt
href="&XMLNames;#NT-QName">QName</xnt> occurs; if there is a default
namespace, it is used for <xnt href="&XMLNames;#NT-QName">QName</xnt>s
that do not have a prefix.  The expansion is performed before the
merging of multiple <code>xsl:output</code> elements into a single
effective <code>xsl:output</code> element. If the expanded-name of the
parent of a text node is a member of the list, then the text node
should be output as a CDATA section. For example,</p>

<eg><![CDATA[<xsl:output cdata-section-elements="example"/>]]></eg>

<p>would cause a literal result element written in the stylesheet as</p>

<eg><![CDATA[<example>&lt;foo></example>]]></eg>

<p>or as</p>

<eg>&lt;example>&lt;![CDATA[&lt;foo>]]&gt;&lt;/example></eg>

<p>to be output as</p>

<eg>&lt;example>&lt;![CDATA[&lt;foo>]]&gt;&lt;/example></eg>

<p>If the text node contains the sequence of characters
<code>]]&gt;</code>, then the currently open CDATA section should be
closed following the <code>]]</code> and a new CDATA section opened
before the <code>&gt;</code>. For example, a literal result element
written in the stylesheet as</p>

<eg>&lt;example&gt;]]&amp;gt;&lt;/example&gt;</eg>

<p>would be output as</p>

<eg>&lt;example&gt;&lt;![CDATA[]]]]&gt;&lt;![CDATA[&gt;]]&gt;&lt;/example&gt;</eg>

<p>If the text node contains a character that is not representable in
the character encoding being used to output the result tree, then the
currently open CDATA section should be closed before the character,
the character should be output using a character reference or entity
reference, and a new CDATA section should be opened for any further
characters in the text node.</p>

<p>CDATA sections should not be used except for text nodes that the
<code>cdata-section-elements</code> attribute explicitly specifies
should be output using CDATA sections.</p>

<p>The <code>xml</code> output method should output an XML declaration
unless the <code>omit-xml-declaration</code> attribute has the value
<code>yes</code>. The XML declaration should include both version
information and an encoding declaration. If the
<code>standalone</code> attribute is specified, it should include a
standalone document declaration with the same value as the value as
the value of the <code>standalone</code> attribute.  Otherwise, it
should not include a standalone document declaration; this ensures
that it is both a XML declaration (allowed at the beginning of a
document entity) and a text declaration (allowed at the beginning of
an external general parsed entity).</p>

<p>If the <code>doctype-system</code> attribute is specified, the
<code>xml</code> output method should output a document type
declaration immediately before the first element.  The name following
<code>&lt;!DOCTYPE</code> should be the name of the first element.  If
<code>doctype-public</code> attribute is also specified, then the
<code>xml</code> output method should output <code>PUBLIC</code>
followed by the public identifier and then the system identifier;
otherwise, it should output <code>SYSTEM</code> followed by the system
identifier.  The internal subset should be empty.  The
<code>doctype-public</code> attribute should be ignored unless the
<code>doctype-system</code> attribute is specified.</p>

<p>The <code>media-type</code> attribute is applicable for the
<code>xml</code> output method.  The default value for the
<code>media-type</code> attribute is <code>text/xml</code>.</p>

</div2>

<div2>
<head>HTML Output Method</head>

<p>The <code>html</code> output method outputs the result tree as
HTML; for example,</p>

<eg>&lt;xsl:stylesheet version="1.0"
                xmlns:xsl="&XSLT.ns;"><![CDATA[

<xsl:output method="html"/>

<xsl:template match="/">
  <html>
   <xsl:apply-templates/>
  </html>
</xsl:template>

...

</xsl:stylesheet>]]></eg>

<p>The <code>version</code> attribute indicates the version of the
HTML.  The default value is <code>4.0</code>, which specifies that the
result should be output as HTML conforming to the HTML 4.0
Recommendation <bibref ref="HTML"/>.</p>

<p>The <code>html</code> output method should not output an element
differently from the <code>xml</code> output method unless the
expanded-name of the element has a null namespace URI; an element
whose expanded-name has a non-null namespace URI should be output as
XML.  If the expanded-name of the element has a null namespace URI,
but the local part of the expanded-name is not recognized as the name
of an HTML element, the element should output in the same way as a
non-empty, inline element such as <code>span</code>.</p>

<p>The <code>html</code> output method should not output an end-tag
for empty elements.  For HTML 4.0, the empty elements are
<code>area</code>, <code>base</code>, <code>basefont</code>,
<code>br</code>, <code>col</code>, <code>frame</code>,
<code>hr</code>, <code>img</code>, <code>input</code>,
<code>isindex</code>, <code>link</code>, <code>meta</code> and
<code>param</code>. For example, an element written as
<code>&lt;br/></code> or <code>&lt;br>&lt;/br></code> in the
stylesheet should be output as <code>&lt;br></code>.</p>

<p>The <code>html</code> output method should recognize the names of
HTML elements regardless of case.  For example, elements named
<code>br</code>, <code>BR</code> or <code>Br</code> should all be
recognized as the HTML <code>br</code> element and output without an
end-tag.</p>

<p>The <code>html</code> output method should not perform escaping for
the content of the <code>script</code> and <code>style</code>
elements. For example, a literal result element written in the
stylesheet as</p>

<eg><![CDATA[<script>if (a &lt; b) foo()</script>]]></eg>

<p>or</p>

<eg><![CDATA[<script><![CDATA[if (a < b) foo()]]]]><![CDATA[></script>]]></eg>

<p>should be output as</p>

<eg><![CDATA[<script>if (a < b) foo()</script>]]></eg>

<p>The <code>html</code> output method should not escape
<code>&lt;</code> characters occurring in attribute values.</p>

<p>If the <code>indent</code> attribute has the value
<code>yes</code>, then the <code>html</code> output method may add or
remove whitespace as it outputs the result tree, so long as it does
not change how an HTML user agent would render the output.  The
default value is <code>yes</code>.</p>

<p>The <code>html</code> output method should escape non-ASCII
characters in URI attribute values using the method recommended in
<loc
href="http://www.w3.org/TR/REC-html40/appendix/notes.html#h-B.2.1">Section
B.2.1</loc> of the HTML 4.0 Recommendation.</p>

<p>The <code>html</code> output method may output a character using a
character entity reference, if one is defined for it in the version of
HTML that the output method is using.</p>

<p>The <code>html</code> output method should terminate processing
instructions with <code>&gt;</code> rather than
<code>?&gt;</code>.</p>

<p>The <code>html</code> output method should output boolean
attributes (that is attributes with only a single allowed value that
is equal to the name of the attribute) in minimized form. For example,
a start-tag written in the stylesheet as</p>

<eg><![CDATA[<OPTION selected="selected">]]></eg>

<p>should be output as</p>

<eg><![CDATA[<OPTION selected>]]></eg>

<p>The <code>html</code> output method should not escape a
<code>&amp;</code> character occurring in an attribute value
immediately followed by a <code>{</code> character (see <loc
href="http://www.w3.org/TR/REC-html40/appendix/notes.html#h-B.7.1.1">Section
B.7.1</loc> of the HTML 4.0 Recommendation). For example, a start-tag
written in the stylesheet as</p>

<eg><![CDATA[<BODY bgcolor='&amp;{{randomrbg}};'>]]></eg>

<p>should be output as</p>

<eg><![CDATA[<BODY bgcolor='&{randomrbg};'>]]></eg>

<p>The <code>encoding</code> attribute specifies the preferred
encoding to be used. If there is a <code>HEAD</code> element, then the
<code>html</code> output method should add a <code>META</code> element
immediately after the start-tag of the <code>HEAD</code> element
specifying the character encoding actually used. For example,</p>

<eg><![CDATA[<HEAD>
<META http-equiv="Content-Type" content="text/html; charset=EUC-JP">
...]]></eg>

<p>It is possible that the result tree will contain a character that
cannot be represented in the encoding that the XSLT processor is using
for output.  In this case, if the character occurs in a context where
HTML recognizes character references, then the character should be
output as a character entity reference or decimal numeric character
reference; otherwise (for example, in a
<code>script</code> or <code>style</code> element or in a comment),
the XSLT processor should signal an error.</p>

<p>If the <code>doctype-public</code> or <code>doctype-system</code>
attributes are specified, then the <code>html</code> output method
should output a document type declaration immediately before the first
element.  The name following <code>&lt;!DOCTYPE</code> should be
<code>HTML</code> or <code>html</code>.  If the
<code>doctype-public</code> attribute is specified, then the output
method should output <code>PUBLIC</code> followed by the specified
public identifier; if the <code>doctype-system</code> attribute is
also specified, it should also output the specified system identifier
following the public identifier.  If the <code>doctype-system</code>
attribute is specified but the <code>doctype-public</code> attribute
is not specified, then the output method should output
<code>SYSTEM</code> followed by the specified system identifier.</p>

<p>The <code>media-type</code> attribute is applicable for the
<code>html</code> output method.  The default value is
<code>text/html</code>.</p>

</div2>

<div2>
<head>Text Output Method</head>

<p>The <code>text</code> output method outputs the result tree by
outputting the string-value of every text node in the result tree in
document order without any escaping.</p>

<p>The <code>media-type</code> attribute is applicable for the
<code>text</code> output method.  The default value for the
<code>media-type</code> attribute is <code>text/plain</code>.</p>

<p>The <code>encoding</code> attribute identifies the encoding that
the <code>text</code> output method should use to convert sequences of
characters to sequences of bytes.  The default is system-dependent. If
the result tree contains a character that cannot be represented in the
encoding that the XSLT processor is using for output, the XSLT
processor should signal an error.</p>

</div2>

<div2 id="disable-output-escaping">
<head>Disabling Output Escaping</head>

<p>Normally, the <code>xml</code> output method escapes &amp; and &lt;
(and possibly other characters) when outputting text nodes.  This
ensures that the output is well-formed XML. However, it is sometimes
convenient to be able to produce output that is almost, but not quite
well-formed XML; for example, the output may include ill-formed
sections which are intended to be transformed into well-formed XML by
a subsequent non-XML aware process.  For this reason, XSLT provides a
mechanism for disabling output escaping. An <code>xsl:value-of</code>
or <code>xsl:text</code> element may have a
<code>disable-output-escaping</code> attribute; the allowed values are
<code>yes</code> or <code>no</code>; the default is <code>no</code>;
if the value is <code>yes</code>, then a text node generated by
instantiating the <code>xsl:value-of</code> or <code>xsl:text</code>
element should be output without any escaping. For example,</p>

<eg><![CDATA[<xsl:text disable-output-escaping="yes">&lt;</xsl:text>]]></eg>

<p>should generate the single character <code>&lt;</code>.</p>

<p>It is an error for output escaping to be disabled for a text node
that is used for something other than a text node in the result tree.
Thus, it is an error to disable output escaping for an
<code>xsl:value-of</code> or <code>xsl:text</code> element that is
used to generate the string-value of a comment, processing instruction
or attribute node; it is also an error to convert a <termref
def="dt-result-tree-fragment">result tree fragment</termref> to a
number or a string if the result tree fragment contains a text node for
which escaping was disabled.  In both cases, an XSLT processor may
signal the error; if it does not signal the error, it must recover by
ignoring the <code>disable-output-escaping</code> attribute.</p>

<p>The <code>disable-output-escaping</code> attribute may be used with
the <code>html</code> output method as well as with the
<code>xml</code> output method.  The <code>text</code> output method
ignores the <code>disable-output-escaping</code> attribute, since it
does not perform any output escaping.</p>

<p>An XSLT processor will only be able to disable output escaping if
it controls how the result tree is output. This may not always be the
case.  For example, the result tree may be used as the source tree for
another XSLT transformation instead of being output.  An XSLT
processor is not required to support disabling output escaping.  If an
<code>xsl:value-of</code> or <code>xsl:text</code> specifies that
output escaping should be disabled and the XSLT processor does not
support this, the XSLT processor may signal an error; if it does not
signal an error, it must recover by not disabling output escaping.</p>

<p>If output escaping is disabled for a character that is not
representable in the encoding that the XSLT processor is using for
output, then the XSLT processor may signal an error; if it does not
signal an error, it must recover by not disabling output escaping.</p>

<p>Since disabling output escaping may not work with all XSLT
processors and can result in XML that is not well-formed, it should be
used only when there is no alternative.</p>


</div2>

</div1>

<div1 id="conformance">
<head>Conformance</head>

<p>A conforming XSLT processor must be able to use a stylesheet to
transform a source tree into a result tree as specified in this
document.  A conforming XSLT processor need not be able to output the
result in XML or in any other form.</p>

<note><p>Vendors of XSLT processors are strongly encouraged to provide
a way to verify that their processor is behaving conformingly by
allowing the result tree to be output as XML or by providing access to
the result tree through a standard API such as the DOM or
SAX.</p></note>

<p>A conforming XSLT processor must signal any errors except for those
that this document specifically allows an XSLT processor not to
signal. A conforming XSLT processor may but need not recover from any
errors that it signals.</p>

<p>A conforming XSLT processor may impose limits on the processing
resources consumed by the processing of a stylesheet.</p>

</div1>

<div1 id="notation">
<head>Notation</head>

<p>The specification of each XSLT-defined element type is preceded by
a summary of its syntax in the form of a model for elements of that
element type.  The meaning of syntax summary notation is as
follows:</p>

<ulist>

<item><p>An attribute is required if and only if its name is in
bold.</p></item>

<item><p>The string that occurs in the place of an attribute value
specifies the allowed values of the attribute.  If this is surrounded
by curly braces, then the attribute value is treated as an <termref
def="dt-attribute-value-template">attribute value template</termref>,
and the string occurring within curly braces specifies the allowed
values of the result of instantiating the attribute value template.
Alternative allowed values are separated by <code>|</code>.  A quoted
string indicates a value equal to that specific string. An unquoted,
italicized name specifies a particular type of value.</p></item>

<item><p>If the element is allowed not to be empty, then the element
contains a comment specifying the allowed content.  The allowed
content is specified in a similar way to an element type declaration
in XML; <emph>template</emph> means that any mixture of text nodes,
literal result elements, extension elements, and XSLT elements from
the <code>instruction</code> category is allowed;
<emph>top-level-elements</emph> means that any mixture of XSLT
elements from the <code>top-level-element</code> category is
allowed.</p></item>

<item><p>The element is prefaced by comments indicating if it belongs
to the <code>instruction</code> category or
<code>top-level-element</code> category or both.  The category of an
element just affects whether it is allowed in the content of elements
that allow a <emph>template</emph> or
<emph>top-level-elements</emph>.</p></item>

</ulist>

</div1>

</body>

<back>
<div1>
<head>References</head>
<div2>
<head>Normative References</head>

<blist>

<bibl id="XML" key="XML">World Wide Web Consortium. <emph>Extensible
Markup Language (XML) 1.0.</emph> W3C Recommendation. See <loc
href="http://www.w3.org/TR/1998/REC-xml-19980210">http://www.w3.org/TR/1998/REC-xml-19980210</loc></bibl>

<bibl id="XMLNAMES" key="XML Names">World Wide Web
Consortium. <emph>Namespaces in XML.</emph> W3C Recommendation. See
<loc
href="http://www.w3.org/TR/REC-xml-names">http://www.w3.org/TR/REC-xml-names</loc></bibl>

<bibl id="XPATH" key="XPath">World Wide Web Consortium. <emph>XML Path
Language.</emph> W3C Recommendation. See <loc
href="&XPath;">http://www.w3.org/TR/xpath</loc></bibl>

</blist>
</div2>
<div2>
<head>Other References</head>

<blist>

<bibl id="CSS2" key="CSS2">World Wide Web Consortium.  <emph>Cascading
Style Sheets, level 2 (CSS2)</emph>.  W3C Recommendation.  See <loc
href="http://www.w3.org/TR/1998/REC-CSS2-19980512"
>http://www.w3.org/TR/1998/REC-CSS2-19980512</loc></bibl>

<bibl id="DSSSL" key="DSSSL">International Organization
for Standardization, International Electrotechnical Commission.
<emph>ISO/IEC 10179:1996.  Document Style Semantics and Specification
Language (DSSSL)</emph>.  International Standard.</bibl>

<bibl id="HTML" key="HTML">World Wide Web Consortium. <emph>HTML 4.0
specification</emph>. W3C Recommendation. See <loc
href="http://www.w3.org/TR/REC-html40"
>http://www.w3.org/TR/REC-html40</loc></bibl>

<bibl id="IANA" key="IANA">Internet Assigned Numbers
Authority. <emph>Character Sets</emph>. See <loc
href="ftp://ftp.isi.edu/in-notes/iana/assignments/character-sets"
>ftp://ftp.isi.edu/in-notes/iana/assignments/character-sets</loc>.</bibl>

<bibl id="RFC2278" key="RFC2278">N. Freed, J. Postel.  <emph>IANA
Charset Registration Procedures</emph>.  IETF RFC 2278. See <loc
href="http://www.ietf.org/rfc/rfc2278.txt"
>http://www.ietf.org/rfc/rfc2278.txt</loc>.</bibl>

<bibl id="RFC2376" key="RFC2376">E. Whitehead, M. Murata.  <emph>XML
Media Types</emph>. IETF RFC 2376. See <loc
href="http://www.ietf.org/rfc/rfc2376.txt"
>http://www.ietf.org/rfc/rfc2376.txt</loc>.</bibl>

<bibl id="RFC2396" key="RFC2396">T. Berners-Lee, R. Fielding, and
L. Masinter.  <emph>Uniform Resource Identifiers (URI): Generic
Syntax</emph>. IETF RFC 2396. See <loc
href="http://www.ietf.org/rfc/rfc2396.txt">http://www.ietf.org/rfc/rfc2396.txt</loc>.</bibl>

<bibl id="UNICODE-TR10" key="UNICODE TR10">Unicode Consortium.
<emph>Unicode Technical Report #10. Unicode Collation
Algorithm</emph>.  Unicode Technical Report.  See <loc
href="http://www.unicode.org/unicode/reports/tr10/index.html"
>http://www.unicode.org/unicode/reports/tr10/index.html</loc>.</bibl>

<bibl id="XHTML" key="XHTML">World Wide Web Consortium. <emph>XHTML
1.0: The Extensible HyperText Markup Language.</emph> W3C Proposed
Recommendation. See <loc href="http://www.w3.org/TR/xhtml1"
>http://www.w3.org/TR/xhtml1</loc></bibl>

<bibl id="XPTR" key="XPointer">World Wide Web
Consortium. <emph>XML Pointer Language (XPointer).</emph> W3C Working
Draft. See <loc href="http://www.w3.org/TR/xptr"
>http://www.w3.org/TR/xptr</loc></bibl>

<bibl id="XMLSTYLE" key="XML Stylesheet">World Wide Web
Consortium. <emph>Associating stylesheets with XML documents.</emph>
W3C Recommendation. See <loc
href="http://www.w3.org/TR/xml-stylesheet"
>http://www.w3.org/TR/xml-stylesheet</loc></bibl>

<bibl id="XSL" key="XSL">World Wide Web Consortium.  <emph>Extensible
Stylesheet Language (XSL).</emph>  W3C Working Draft.  See <loc
href="http://www.w3.org/TR/WD-xsl"
     >http://www.w3.org/TR/WD-xsl</loc></bibl>

</blist>

</div2>
</div1>

<div1 id="element-syntax-summary">
<head>Element Syntax Summary</head>

<e:element-syntax-summary/>

</div1>

<inform-div1 id="dtd">
<head>DTD Fragment for XSLT Stylesheets</head>

<note><p>This DTD Fragment is not normative because XML 1.0 DTDs do
not support XML Namespaces and thus cannot correctly describe the
allowed structure of an XSLT stylesheet.</p></note>

<p>The following entity can be used to construct a DTD for XSLT
stylesheets that create instances of a particular result DTD.  Before
referencing the entity, the stylesheet DTD must define a
<code>result-elements</code> parameter entity listing the allowed
result element types.  For example:</p>

<eg><![CDATA[<!ENTITY % result-elements "
  | fo:inline-sequence
  | fo:block
">]]></eg>

<p>Such result elements should be declared to have
<code>xsl:use-attribute-sets</code> and
<code>xsl:extension-element-prefixes</code> attributes.  The following
entity declares the <code>result-element-atts</code> parameter for
this purpose. The content that XSLT allows for result elements is the
same as it allows for the XSLT elements that are declared in the
following entity with a content model of <code>%template;</code>.  The
DTD may use a more restrictive content model than
<code>%template;</code> to reflect the constraints of the result
DTD.</p>

<p>The DTD may define the <code>non-xsl-top-level</code> parameter
entity to allow additional top-level elements from namespaces other
than the XSLT namespace.</p>

<p>The use of the <code>xsl:</code> prefix in this DTD does not imply
that XSLT stylesheets are required to use this prefix.  Any of the
elements declared in this DTD may have attributes whose name starts
with <code>xmlns:</code> or is equal to <code>xmlns</code> in addition
to the attributes declared in this DTD.</p>

<eg><![CDATA[<!ENTITY % char-instructions "
  | xsl:apply-templates
  | xsl:call-template
  | xsl:apply-imports
  | xsl:for-each
  | xsl:value-of
  | xsl:copy-of
  | xsl:number
  | xsl:choose
  | xsl:if
  | xsl:text
  | xsl:copy
  | xsl:variable
  | xsl:message
  | xsl:fallback
">

<!ENTITY % instructions "
  %char-instructions;
  | xsl:processing-instruction
  | xsl:comment
  | xsl:element
  | xsl:attribute
">

<!ENTITY % char-template "
 (#PCDATA
  %char-instructions;)*
">

<!ENTITY % template "
 (#PCDATA
  %instructions;
  %result-elements;)*
">

<!-- Used for the type of an attribute value that is a URI reference.-->
<!ENTITY % URI "CDATA">

<!-- Used for the type of an attribute value that is a pattern.-->
<!ENTITY % pattern "CDATA">

<!-- Used for the type of an attribute value that is an
     attribute value template.-->
<!ENTITY % avt "CDATA">

<!-- Used for the type of an attribute value that is a QName; the prefix
     gets expanded by the XSLT processor. -->
<!ENTITY % qname "NMTOKEN">

<!-- Like qname but a whitespace-separated list of QNames. -->
<!ENTITY % qnames "NMTOKENS">

<!-- Used for the type of an attribute value that is an expression.-->
<!ENTITY % expr "CDATA">

<!-- Used for the type of an attribute value that consists
     of a single character.-->
<!ENTITY % char "CDATA">

<!-- Used for the type of an attribute value that is a priority. -->
<!ENTITY % priority "NMTOKEN">

<!ENTITY % space-att "xml:space (default|preserve) #IMPLIED">

<!-- This may be overridden to customize the set of elements allowed
at the top-level. -->

<!ENTITY % non-xsl-top-level "">

<!ENTITY % top-level "
 (xsl:import*,
  (xsl:include
  | xsl:strip-space
  | xsl:preserve-space
  | xsl:output
  | xsl:key
  | xsl:decimal-format
  | xsl:attribute-set
  | xsl:variable
  | xsl:param
  | xsl:template
  | xsl:namespace-alias
  %non-xsl-top-level;)*)
">

<!ENTITY % top-level-atts '
  extension-element-prefixes CDATA #IMPLIED
  exclude-result-prefixes CDATA #IMPLIED
  id ID #IMPLIED
  version NMTOKEN #REQUIRED
  xmlns:xsl CDATA #FIXED "]]>&XSLT.ns;<![CDATA["
  %space-att;
'>

<!-- This entity is defined for use in the ATTLIST declaration
for result elements. -->

<!ENTITY % result-element-atts '
  xsl:extension-element-prefixes CDATA #IMPLIED
  xsl:exclude-result-prefixes CDATA #IMPLIED
  xsl:use-attribute-sets %qnames; #IMPLIED
  xsl:version NMTOKEN #IMPLIED
'>

<!ELEMENT xsl:stylesheet %top-level;>
<!ATTLIST xsl:stylesheet %top-level-atts;>

<!ELEMENT xsl:transform %top-level;>
<!ATTLIST xsl:transform %top-level-atts;>

<!ELEMENT xsl:import EMPTY>
<!ATTLIST xsl:import href %URI; #REQUIRED>

<!ELEMENT xsl:include EMPTY>
<!ATTLIST xsl:include href %URI; #REQUIRED>

<!ELEMENT xsl:strip-space EMPTY>
<!ATTLIST xsl:strip-space elements CDATA #REQUIRED>

<!ELEMENT xsl:preserve-space EMPTY>
<!ATTLIST xsl:preserve-space elements CDATA #REQUIRED>

<!ELEMENT xsl:output EMPTY>
<!ATTLIST xsl:output
  method %qname; #IMPLIED
  version NMTOKEN #IMPLIED
  encoding CDATA #IMPLIED
  omit-xml-declaration (yes|no) #IMPLIED
  standalone (yes|no) #IMPLIED
  doctype-public CDATA #IMPLIED
  doctype-system CDATA #IMPLIED
  cdata-section-elements %qnames; #IMPLIED
  indent (yes|no) #IMPLIED
  media-type CDATA #IMPLIED
>

<!ELEMENT xsl:key EMPTY>
<!ATTLIST xsl:key
  name %qname; #REQUIRED
  match %pattern; #REQUIRED
  use %expr; #REQUIRED
>

<!ELEMENT xsl:decimal-format EMPTY>
<!ATTLIST xsl:decimal-format
  name %qname; #IMPLIED
  decimal-separator %char; "."
  grouping-separator %char; ","
  infinity CDATA "Infinity"
  minus-sign %char; "-"
  NaN CDATA "NaN"
  percent %char; "%"
  per-mille %char; "&#x2030;"
  zero-digit %char; "0"
  digit %char; "#"
  pattern-separator %char; ";"
>

<!ELEMENT xsl:namespace-alias EMPTY>
<!ATTLIST xsl:namespace-alias
  stylesheet-prefix CDATA #REQUIRED
  result-prefix CDATA #REQUIRED
>

<!ELEMENT xsl:template
 (#PCDATA
  %instructions;
  %result-elements;
  | xsl:param)*
>

<!ATTLIST xsl:template
  match %pattern; #IMPLIED
  name %qname; #IMPLIED
  priority %priority; #IMPLIED
  mode %qname; #IMPLIED
  %space-att;
>

<!ELEMENT xsl:value-of EMPTY>
<!ATTLIST xsl:value-of
  select %expr; #REQUIRED
  disable-output-escaping (yes|no) "no"
>

<!ELEMENT xsl:copy-of EMPTY>
<!ATTLIST xsl:copy-of select %expr; #REQUIRED>

<!ELEMENT xsl:number EMPTY>
<!ATTLIST xsl:number
   level (single|multiple|any) "single"
   count %pattern; #IMPLIED
   from %pattern; #IMPLIED
   value %expr; #IMPLIED
   format %avt; '1'
   lang %avt; #IMPLIED
   letter-value %avt; #IMPLIED
   grouping-separator %avt; #IMPLIED
   grouping-size %avt; #IMPLIED
>

<!ELEMENT xsl:apply-templates (xsl:sort|xsl:with-param)*>
<!ATTLIST xsl:apply-templates
  select %expr; "node()"
  mode %qname; #IMPLIED
>

<!ELEMENT xsl:apply-imports EMPTY>

<!-- xsl:sort cannot occur after any other elements or
any non-whitespace character -->

<!ELEMENT xsl:for-each
 (#PCDATA
  %instructions;
  %result-elements;
  | xsl:sort)*
>

<!ATTLIST xsl:for-each
  select %expr; #REQUIRED
  %space-att;
>

<!ELEMENT xsl:sort EMPTY>
<!ATTLIST xsl:sort
  select %expr; "."
  lang %avt; #IMPLIED
  data-type %avt; "text"
  order %avt; "ascending"
  case-order %avt; #IMPLIED
>

<!ELEMENT xsl:if %template;>
<!ATTLIST xsl:if
  test %expr; #REQUIRED
  %space-att;
>

<!ELEMENT xsl:choose (xsl:when+, xsl:otherwise?)>
<!ATTLIST xsl:choose %space-att;>

<!ELEMENT xsl:when %template;>
<!ATTLIST xsl:when
  test %expr; #REQUIRED
  %space-att;
>

<!ELEMENT xsl:otherwise %template;>
<!ATTLIST xsl:otherwise %space-att;>

<!ELEMENT xsl:attribute-set (xsl:attribute)*>
<!ATTLIST xsl:attribute-set
  name %qname; #REQUIRED
  use-attribute-sets %qnames; #IMPLIED
>

<!ELEMENT xsl:call-template (xsl:with-param)*>
<!ATTLIST xsl:call-template
  name %qname; #REQUIRED
>

<!ELEMENT xsl:with-param %template;>
<!ATTLIST xsl:with-param
  name %qname; #REQUIRED
  select %expr; #IMPLIED
>

<!ELEMENT xsl:variable %template;>
<!ATTLIST xsl:variable
  name %qname; #REQUIRED
  select %expr; #IMPLIED
>

<!ELEMENT xsl:param %template;>
<!ATTLIST xsl:param
  name %qname; #REQUIRED
  select %expr; #IMPLIED
>

<!ELEMENT xsl:text (#PCDATA)>
<!ATTLIST xsl:text
  disable-output-escaping (yes|no) "no"
>

<!ELEMENT xsl:processing-instruction %char-template;>
<!ATTLIST xsl:processing-instruction
  name %avt; #REQUIRED
  %space-att;
>

<!ELEMENT xsl:element %template;>
<!ATTLIST xsl:element
  name %avt; #REQUIRED
  namespace %avt; #IMPLIED
  use-attribute-sets %qnames; #IMPLIED
  %space-att;
>

<!ELEMENT xsl:attribute %char-template;>
<!ATTLIST xsl:attribute
  name %avt; #REQUIRED
  namespace %avt; #IMPLIED
  %space-att;
>

<!ELEMENT xsl:comment %char-template;>
<!ATTLIST xsl:comment %space-att;>

<!ELEMENT xsl:copy %template;>
<!ATTLIST xsl:copy
  %space-att;
  use-attribute-sets %qnames; #IMPLIED
>

<!ELEMENT xsl:message %template;>
<!ATTLIST xsl:message
  %space-att;
  terminate (yes|no) "no"
>

<!ELEMENT xsl:fallback %template;>
<!ATTLIST xsl:fallback %space-att;>]]></eg>

</inform-div1>

<inform-div1>
<head>Examples</head>

<div2>
<head>Document Example</head>

<p>This example is a stylesheet for transforming documents that
conform to a simple DTD into XHTML <bibref ref="XHTML"/>.  The DTD
is:</p>

<eg><![CDATA[<!ELEMENT doc (title, chapter*)>
<!ELEMENT chapter (title, (para|note)*, section*)>
<!ELEMENT section (title, (para|note)*)>
<!ELEMENT title (#PCDATA|emph)*>
<!ELEMENT para (#PCDATA|emph)*>
<!ELEMENT note (#PCDATA|emph)*>
<!ELEMENT emph (#PCDATA|emph)*>]]></eg>

<p>The stylesheet is:</p>

<eg>&lt;xsl:stylesheet version="1.0"
                xmlns:xsl="&XSLT.ns;"
                xmlns="&XHTML.ns;"><![CDATA[

<xsl:strip-space elements="doc chapter section"/>
<xsl:output
   method="xml"
   indent="yes"
   encoding="iso-8859-1"
/>

<xsl:template match="doc">
 <html>
   <head>
     <title>
       <xsl:value-of select="title"/>
     </title>
   </head>
   <body>
     <xsl:apply-templates/>
   </body>
 </html>
</xsl:template>

<xsl:template match="doc/title">
  <h1>
    <xsl:apply-templates/>
  </h1>
</xsl:template>

<xsl:template match="chapter/title">
  <h2>
    <xsl:apply-templates/>
  </h2>
</xsl:template>

<xsl:template match="section/title">
  <h3>
    <xsl:apply-templates/>
  </h3>
</xsl:template>

<xsl:template match="para">
  <p>
    <xsl:apply-templates/>
  </p>
</xsl:template>

<xsl:template match="note">
  <p class="note">
    <b>NOTE: </b>
    <xsl:apply-templates/>
  </p>
</xsl:template>

<xsl:template match="emph">
  <em>
    <xsl:apply-templates/>
  </em>
</xsl:template>

</xsl:stylesheet>]]></eg>

<p>With the following input document</p>

<eg><![CDATA[<!DOCTYPE doc SYSTEM "doc.dtd">
<doc>
<title>Document Title</title>
<chapter>
<title>Chapter Title</title>
<section>
<title>Section Title</title>
<para>This is a test.</para>
<note>This is a note.</note>
</section>
<section>
<title>Another Section Title</title>
<para>This is <emph>another</emph> test.</para>
<note>This is another note.</note>
</section>
</chapter>
</doc>]]></eg>

<p>it would produce the following result</p>

<eg>&lt;?xml version="1.0" encoding="iso-8859-1"?>
&lt;html xmlns="&XHTML.ns;"><![CDATA[
<head>
<title>Document Title</title>
</head>
<body>
<h1>Document Title</h1>
<h2>Chapter Title</h2>
<h3>Section Title</h3>
<p>This is a test.</p>
<p class="note">
<b>NOTE: </b>This is a note.</p>
<h3>Another Section Title</h3>
<p>This is <em>another</em> test.</p>
<p class="note">
<b>NOTE: </b>This is another note.</p>
</body>
</html>]]></eg>

</div2>

<div2 id="data-example">
<head>Data Example</head>

<p>This is an example of transforming some data represented in XML
using three different XSLT stylesheets to produce three different
representations of the data, HTML, SVG and VRML.</p>

<p>The input data is:</p>

<eg><![CDATA[<sales>

        <division id="North">
                <revenue>10</revenue>
                <growth>9</growth>
                <bonus>7</bonus>
        </division>

        <division id="South">
                <revenue>4</revenue>
                <growth>3</growth>
                <bonus>4</bonus>
        </division>

        <division id="West">
                <revenue>6</revenue>
                <growth>-1.5</growth>
                <bonus>2</bonus>
        </division>

</sales>]]></eg>

<p>The following stylesheet, which uses the simplified syntax
described in <specref ref="result-element-stylesheet"/>, transforms
the data into HTML:</p>

<eg>&lt;html xsl:version="1.0"
      xmlns:xsl="&XSLT.ns;"<![CDATA[
      lang="en">
    <head>
	<title>Sales Results By Division</title>
    </head>
    <body>
	<table border="1">
	    <tr>
		<th>Division</th>
		<th>Revenue</th>
		<th>Growth</th>
		<th>Bonus</th>
	    </tr>
	    <xsl:for-each select="sales/division">
		<!-- order the result by revenue -->
		<xsl:sort select="revenue"
			  data-type="number"
			  order="descending"/>
		<tr>
		    <td>
			<em><xsl:value-of select="@id"/></em>
		    </td>
		    <td>
			<xsl:value-of select="revenue"/>
		    </td>
		    <td>
			<!-- highlight negative growth in red -->
			<xsl:if test="growth &lt; 0">
			     <xsl:attribute name="style">
				 <xsl:text>color:red</xsl:text>
			     </xsl:attribute>
			</xsl:if>
			<xsl:value-of select="growth"/>
		    </td>
		    <td>
			<xsl:value-of select="bonus"/>
		    </td>
		</tr>
	    </xsl:for-each>
	</table>
    </body>
</html>]]></eg>

<p>The HTML output is:</p>

<eg><![CDATA[<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Sales Results By Division</title>
</head>
<body>
<table border="1">
<tr>
<th>Division</th><th>Revenue</th><th>Growth</th><th>Bonus</th>
</tr>
<tr>
<td><em>North</em></td><td>10</td><td>9</td><td>7</td>
</tr>
<tr>
<td><em>West</em></td><td>6</td><td style="color:red">-1.5</td><td>2</td>
</tr>
<tr>
<td><em>South</em></td><td>4</td><td>3</td><td>4</td>
</tr>
</table>
</body>
</html>]]></eg>

<p>The following stylesheet transforms the data into SVG:</p>

<eg>&lt;xsl:stylesheet version="1.0"
                xmlns:xsl="&XSLT.ns;"<![CDATA[
                xmlns="http://www.w3.org/Graphics/SVG/SVG-19990812.dtd">

<xsl:output method="xml" indent="yes" media-type="image/svg"/>

<xsl:template match="/">

<svg width = "3in" height="3in">
    <g style = "stroke: #000000">
        <!-- draw the axes -->
        <line x1="0" x2="150" y1="150" y2="150"/>
        <line x1="0" x2="0" y1="0" y2="150"/>
        <text x="0" y="10">Revenue</text>
        <text x="150" y="165">Division</text>
        <xsl:for-each select="sales/division">
	    <!-- define some useful variables -->

	    <!-- the bar's x position -->
	    <xsl:variable name="pos"
	                  select="(position()*40)-30"/>

	    <!-- the bar's height -->
	    <xsl:variable name="height"
	                  select="revenue*10"/>

	    <!-- the rectangle -->
	    <rect x="{$pos}" y="{150-$height}"
                  width="20" height="{$height}"/>

	    <!-- the text label -->
	    <text x="{$pos}" y="165">
	        <xsl:value-of select="@id"/>
	    </text>

	    <!-- the bar value -->
	    <text x="{$pos}" y="{145-$height}">
	        <xsl:value-of select="revenue"/>
	    </text>
        </xsl:for-each>
    </g>
</svg>

</xsl:template>
</xsl:stylesheet>]]></eg>

<p>The SVG output is:</p>

<eg><![CDATA[<svg width="3in" height="3in"
     xmlns="http://www.w3.org/Graphics/SVG/svg-19990412.dtd">
    <g style="stroke: #000000">
	<line x1="0" x2="150" y1="150" y2="150"/>
	<line x1="0" x2="0" y1="0" y2="150"/>
	<text x="0" y="10">Revenue</text>
	<text x="150" y="165">Division</text>
	<rect x="10" y="50" width="20" height="100"/>
	<text x="10" y="165">North</text>
	<text x="10" y="45">10</text>
	<rect x="50" y="110" width="20" height="40"/>
	<text x="50" y="165">South</text>
	<text x="50" y="105">4</text>
	<rect x="90" y="90" width="20" height="60"/>
	<text x="90" y="165">West</text>
	<text x="90" y="85">6</text>
    </g>
</svg>]]></eg>

<p>The following stylesheet transforms the data into VRML:</p>

<eg>&lt;xsl:stylesheet version="1.0"
                xmlns:xsl="&XSLT.ns;"><![CDATA[

<!-- generate text output as mime type model/vrml, using default charset -->
<xsl:output method="text" encoding="UTF-8" media-type="model/vrml"/>

        <xsl:template match="/">#VRML V2.0 utf8

# externproto definition of a single bar element
EXTERNPROTO bar [
  field SFInt32 x
  field SFInt32 y
  field SFInt32 z
  field SFString name
  ]
  "http://www.vrml.org/WorkingGroups/dbwork/barProto.wrl"

# inline containing the graph axes
Inline {
        url "http://www.vrml.org/WorkingGroups/dbwork/barAxes.wrl"
        }

                <xsl:for-each select="sales/division">
bar {
        x <xsl:value-of select="revenue"/>
        y <xsl:value-of select="growth"/>
        z <xsl:value-of select="bonus"/>
        name "<xsl:value-of select="@id"/>"
        }
                </xsl:for-each>

        </xsl:template>

</xsl:stylesheet>]]></eg>

<p>The VRML output is:</p>

<eg><![CDATA[#VRML V2.0 utf8

# externproto definition of a single bar element
EXTERNPROTO bar [
  field SFInt32 x
  field SFInt32 y
  field SFInt32 z
  field SFString name
  ]
  "http://www.vrml.org/WorkingGroups/dbwork/barProto.wrl"

# inline containing the graph axes
Inline {
        url "http://www.vrml.org/WorkingGroups/dbwork/barAxes.wrl"
        }


bar {
        x 10
        y 9
        z 7
        name "North"
        }

bar {
        x 4
        y 3
        z 4
        name "South"
        }

bar {
        x 6
        y -1.5
        z 2
        name "West"
        }]]></eg>

</div2>

</inform-div1>

<inform-div1>
<head>Acknowledgements</head>
<p>The following have contributed to authoring this draft:</p>
<slist>
<sitem>Daniel Lipkin, Saba</sitem>
<sitem>Jonathan Marsh, Microsoft</sitem>
<sitem>Henry Thompson, University of Edinburgh</sitem>
<sitem>Norman Walsh, Arbortext</sitem>
<sitem>Steve Zilles, Adobe</sitem>
</slist>

<p>This specification was developed and approved for publication by the
W3C XSL Working Group (WG). WG approval of this specification does not
necessarily imply that all WG members voted for its approval. The
current members of the XSL WG are:</p>

<orglist>
<member>
<name>Sharon Adler</name>
<affiliation>IBM</affiliation>
<role>Co-Chair</role>
</member>
<member>
<name>Anders Berglund</name>
<affiliation>IBM</affiliation>
</member>
<member>
<name>Perin Blanchard</name>
<affiliation>Novell</affiliation>
</member>
<member>
<name>Scott Boag</name>
<affiliation>Lotus</affiliation>
</member>
<member>
<name>Larry Cable</name>
<affiliation>Sun</affiliation>
</member>
<member>
<name>Jeff Caruso</name>
<affiliation>Bitstream</affiliation>
</member>
<member>
<name>James Clark</name>
</member>
<member>
<name>Peter Danielsen</name>
<affiliation>Bell Labs</affiliation>
</member>
<member>
<name>Don Day</name>
<affiliation>IBM</affiliation>
</member>
<member>
<name>Stephen Deach</name>
<affiliation>Adobe</affiliation>
</member>
<member>
<name>Dwayne Dicks</name>
<affiliation>SoftQuad</affiliation>
</member>
<member>
<name>Andrew Greene</name>
<affiliation>Bitstream</affiliation>
</member>
<member>
<name>Paul Grosso</name>
<affiliation>Arbortext</affiliation>
</member>
<member>
<name>Eduardo Gutentag</name>
<affiliation>Sun</affiliation>
</member>
<member>
<name>Juliane Harbarth</name>
<affiliation>Software AG</affiliation>
</member>
<member>
<name>Mickey Kimchi</name>
<affiliation>Enigma</affiliation>
</member>
<member>
<name>Chris Lilley</name>
<affiliation>W3C</affiliation>
</member>
<member>
<name>Chris Maden</name>
<affiliation>Exemplary Technologies</affiliation>
</member>
<member>
<name>Jonathan Marsh</name>
<affiliation>Microsoft</affiliation>
</member>
<member>
<name>Alex Milowski</name>
<affiliation>Lexica</affiliation>
</member>
<member>
<name>Steve Muench</name>
<affiliation>Oracle</affiliation>
</member>
<member>
<name>Scott Parnell</name>
<affiliation>Xerox</affiliation>
</member>
<member>
<name>Vincent Quint</name>
<affiliation>W3C</affiliation>
</member>
<member>
<name>Dan Rapp</name>
<affiliation>Novell</affiliation>
</member>
<member>
<name>Gregg Reynolds</name>
<affiliation>Datalogics</affiliation>
</member>
<member>
<name>Jonathan Robie</name>
<affiliation>Software AG</affiliation>
</member>
<member>
<name>Mark Scardina</name>
<affiliation>Oracle</affiliation>
</member>
<member>
<name>Henry Thompson</name>
<affiliation>University of Edinburgh</affiliation>
</member>
<member>
<name>Philip Wadler</name>
<affiliation>Bell Labs</affiliation>
</member>
<member>
<name>Norman Walsh</name>
<affiliation>Arbortext</affiliation>
</member>
<member>
<name>Sanjiva Weerawarana</name>
<affiliation>IBM</affiliation>
</member>
<member>
<name>Steve Zilles</name>
<affiliation>Adobe</affiliation>
<role>Co-Chair</role>
</member>
</orglist>

</inform-div1>

<inform-div1>
<head>Changes from Proposed Recommendation</head>

<p>The following are the changes since the Proposed Recommendation:</p>

<ulist>

<item><p>The <code>xsl:version</code> attribute is required on a
literal result element used as a stylesheet (see <specref
ref="result-element-stylesheet"/>).</p></item>

<item><p>The <code>data-type</code> attribute on <code>xsl:sort</code>
can use a prefixed name to specify a data-type not defined by
XSLT (see <specref ref="sorting"/>).</p></item>

</ulist>

</inform-div1>

<inform-div1>
<head>Features under Consideration for Future Versions of XSLT</head>

<p>The following features are under consideration for versions of XSLT
after XSLT 1.0:</p>

<ulist>

<item><p>a conditional expression;</p></item>

<item><p>support for XML Schema datatypes and archetypes;</p></item>

<item><p>support for something like style rules in the original XSL
submission;</p></item>

<item><p>an attribute to control the default namespace for names
occurring in XSLT attributes;</p></item>

<item><p>support for entity references;</p></item>

<item><p>support for DTDs in the data model;</p></item>

<item><p>support for notations in the data model;</p></item>

<item><p>a way to get back from an element to the elements that
reference it (e.g. by IDREF attributes);</p></item>

<item><p>an easier way to get an ID or key in another document;</p></item>

<item><p>support for regular expressions for matching against any or
all of text nodes, attribute values, attribute names, element type
names;</p></item>

<item><p>case-insensitive comparisons;</p></item>

<item><p>normalization of strings before comparison, for example for
compatibility characters;</p></item>

<item><p>a function <code>string resolve(node-set)</code> function
that treats the value of the argument as a relative URI and turns it
into an absolute URI using the base URI of the node;</p></item>

<item><p>multiple result documents;</p></item>

<item><p>defaulting the <code>select</code> attribute on
<code>xsl:value-of</code> to the current node;</p></item>

<item><p>an attribute on <code>xsl:attribute</code> to control how the
attribute value is normalized;</p></item>

<item><p>additional attributes on <code>xsl:sort</code> to provide
further control over sorting, such as relative order of
scripts;</p></item>

<item><p>a way to put the text of a resource identified by a URI into
the result tree;</p></item>

<item><p>allow unions in steps (e.g. <code>foo/(bar|baz)</code>);</p></item>

<item><p>allow for result tree fragments all operations that are
allowed for node-sets;</p></item>

<item><p>a way to group together consecutive nodes having duplicate
subelements or attributes;</p></item>

<item><p>features to make handling of the HTML <code>style</code>
attribute more convenient.</p></item>

</ulist>

</inform-div1>

</back>
</spec>
