<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE spec SYSTEM "../../xmlspec-tr.dtd" [
<!ENTITY w3c "http://www.w3.org">
<!ENTITY XML "../xml">
<!ENTITY XMLNames "../xml-names">
<!ENTITY XML11 "../xml11">
<!ENTITY XMLNames11 "../xml-names11">
<!ENTITY XMLNames "../xml-names">
<!ENTITY XPath "../xpath">
<!ENTITY XMLSTYLE "../xml-stylesheet/">
<!ENTITY XSLT.ns "http://www.w3.org/1999/XSL/Transform">
<!ENTITY XSLTA.ns "http://www.w3.org/1999/XSL/TransformAlias">
<!ENTITY XSLFO.ns "http://www.w3.org/1999/XSL/Format">
<!ENTITY XHTML.ns "http://www.w3.org/TR/xhtml1/strict">
<!ENTITY year "1999">
<!ENTITY month "Kasım">
<!ENTITY MM "11">
<!ENTITY day "16">
<!ENTITY DD "16">
<!ENTITY YYYYMMDD "&year;&MM;&DD;">
<!ENTITY LEV "REC">
<!-- DTD customizations -->
<!ATTLIST proto
  name NMTOKEN #REQUIRED
  return-type (dizge|sayı|mantıksal-değer|düğüm-kümesi|nesne) #REQUIRED
>
<!ATTLIST arg
  type (dizge|sayı|mantıksal-değer|düğüm-kümesi|nesne) #REQUIRED
  occur (opt|rep) #IMPLIED
>

<!ELEMENT xfunction (#PCDATA)>
<!ATTLIST xfunction href CDATA "&XPath;">

<!ELEMENT e:element-syntax
  (e:in-category*, e:attribute*, (e:empty|e:text|e:element|e:model|e:sequence|e:choice))
>
<!ATTLIST e:element-syntax
  xmlns:e CDATA #FIXED "http://www.w3.org/1999/XSL/Spec/ElementSyntax"
  name NMTOKEN #REQUIRED
>
<!ELEMENT e:in-category EMPTY>
<!ATTLIST
  e:in-category name NMTOKEN #REQUIRED
  xmlns:e CDATA #FIXED "http://www.w3.org/1999/XSL/Spec/ElementSyntax"
>
<!ELEMENT e:attribute (e:attribute-value-template|(e:constant|e:data-type)+)>
<!ATTLIST e:attribute
  name NMTOKEN #REQUIRED
  required (yes) #IMPLIED
  xmlns:e CDATA #FIXED "http://www.w3.org/1999/XSL/Spec/ElementSyntax"
>
<!ELEMENT e:attribute-value-template (e:constant|e:data-type)+>
<!ATTLIST e:attribute-value-template
  xmlns:e CDATA #FIXED "http://www.w3.org/1999/XSL/Spec/ElementSyntax"
>
<!ELEMENT e:constant EMPTY>
<!ATTLIST
  e:constant value CDATA #REQUIRED
  xmlns:e CDATA #FIXED "http://www.w3.org/1999/XSL/Spec/ElementSyntax"
>
<!ELEMENT e:data-type EMPTY>
<!ATTLIST e:data-type
  name NMTOKEN #REQUIRED
  xmlns:e CDATA #FIXED "http://www.w3.org/1999/XSL/Spec/ElementSyntax"
>
<!ELEMENT e:empty EMPTY>
<!ATTLIST e:empty
  xmlns:e CDATA #FIXED "http://www.w3.org/1999/XSL/Spec/ElementSyntax"
>
<!ELEMENT e:text EMPTY>
<!ATTLIST e:text
  xmlns:e CDATA #FIXED "http://www.w3.org/1999/XSL/Spec/ElementSyntax"
>
<!ELEMENT e:element EMPTY>
<!ATTLIST e:element
  name NMTOKEN #REQUIRED
  repeat (zero-or-one|zero-or-more|one-or-more) #IMPLIED
  xmlns:e CDATA #FIXED "http://www.w3.org/1999/XSL/Spec/ElementSyntax"
>
<!ELEMENT e:model EMPTY>
<!ATTLIST e:model
  name NMTOKEN #REQUIRED
  repeat (zero-or-one|zero-or-more|one-or-more) #IMPLIED
  xmlns:e CDATA #FIXED "http://www.w3.org/1999/XSL/Spec/ElementSyntax"
>
<!ELEMENT e:sequence (e:element|e:model|e:choice)+>
<!ATTLIST e:sequence
  repeat (zero-or-one|zero-or-more|one-or-more) #IMPLIED
  xmlns:e CDATA #FIXED "http://www.w3.org/1999/XSL/Spec/ElementSyntax"
>
<!ELEMENT e:choice (e:element|e:model|e:sequence)+>
<!ATTLIST e:choice
  repeat (zero-or-one|zero-or-more|one-or-more) #IMPLIED
  xmlns:e CDATA #FIXED "http://www.w3.org/1999/XSL/Spec/ElementSyntax"
>
<!ELEMENT e:element-syntax-summary EMPTY>
<!ATTLIST e:element-syntax-summary
  xmlns:e CDATA #FIXED "http://www.w3.org/1999/XSL/Spec/ElementSyntax"
>
<!ENTITY % local.illus.class "|e:element-syntax|e:element-syntax-summary">
<!ENTITY % local.tech.class "|xfunction">

<!ATTLIST spec
  xmlns:e CDATA #FIXED "http://www.w3.org/1999/XSL/Spec/ElementSyntax">
<!ATTLIST authlist
    translator-name     CDATA #FIXED "Nilgün Belma Bugüner"
    translator-email    CDATA #FIXED "nilgun (at) belgeler·org"
    translation-date    CDATA #FIXED "25 Haziran 2007" >
]>
<spec id="index" xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax">
<header>
<title>XSL Dönüşümleri (XSLT)</title>
<version>Sürüm 1.0</version>
<w3c-designation>&LEV;-xslt-&YYYYMMDD;</w3c-designation>
<w3c-doctype>W3C Önergesi</w3c-doctype>
<pubdate><day>&day;</day><month>&month;</month><year>&year;</year></pubdate>
<publoc>
<loc href="http://www.w3.org/TR/&year;/&LEV;-xslt-&YYYYMMDD;"
          >http://www.w3.org/TR/&year;/&LEV;-xslt-&YYYYMMDD;</loc>
<loc role="available-format"
href="http://www.w3.org/TR/&year;/&LEV;-xslt-&YYYYMMDD;.xml">XML</loc>
<loc role="available-format"
href="http://www.w3.org/TR/&year;/&LEV;-xslt-&YYYYMMDD;.html">HTML</loc>
</publoc>
<latestloc>
<loc href="http://www.w3.org/TR/xslt"/>
</latestloc>
<prevlocs>
<loc href="http://www.w3.org/TR/1999/PR-xslt-19991008"/>
<loc href="http://www.w3.org/1999/08/WD-xslt-19990813"/>
<loc href="http://www.w3.org/1999/07/WD-xslt-19990709"/>
<loc href="http://www.w3.org/TR/1999/WD-xslt-19990421"/>
<loc href="http://www.w3.org/TR/1998/WD-xsl-19981216"/>
<loc href="http://www.w3.org/TR/1998/WD-xsl-19980818"/>
</prevlocs>
<authlist>
<author>
<name>James Clark</name>
<email href="mailto:jjc@jclark.com">jjc@jclark.com</email>
</author>
</authlist>

<status>

<p>Bu belge W3C üyeleri ve diğer ilgili taraflarca gözden geçirilmiş ve W3C Yönetimi tarafından bir W3C <loc href="http://www.w3.org/Consortium/Process/#RecsW3C">Önergesi</loc> olarak onaylanmıştır. Kararlı bir belge olup başka belgelerden uyulması gerekli bir kaynak olarak atıfta bulunarak veya bir başvuru malzemesi olarak kullanılabilir. W3C'nin Önergedeki rolü, belirtime dikkatleri çekmek ve geniş bir alanda kullanımını yaygınlaştırmaktır. Bu, Web'in işlevselliğini ve birlikte çalışabilirliğini arttırmaktadır.</p>

<p>Bu belgede tespit edilmiş hatalar <loc href="http://www.w3.org/&year;/&MM;/&LEV;-xslt-&YYYYMMDD;-errata"/> adresinde listelenmiştir. <kw>Bunlardan 2 Kasım 2005'e (E39'a) kadar bilinen hatalarla ilgili değişiklikler çeviriye yansıtılmıştır</kw>.</p>

<p>Bu belirtimle ilgili yorumlar <loc href="mailto:xsl-editors@w3.org">xsl-editors@w3.org</loc> adresine gönderilebilir; yorum <loc href="http://lists.w3.org/Archives/Public/xsl-editors">arşivleri</loc> de mevcuttur. XSL'nin, XSLT'yi de içererek halka açık tartışma alanı olarak <loc href="http://www.mulberrytech.com/xsl/xsl-list/index.html">XSL-List</loc> eposta listesi vardır.</p>

<p>Bu belirtimin İngilizce sürümü uyulması gerekli tek sürümdür. Bununla birlikte bu belgenin (bilgilendirici mahiyette) <loc
href="http://www.w3.org/Style/XSL/translations.html">çeviriler</loc>i de mevcuttur.</p>

<p>W3C Önergelerinin ve diğer teknik belgelerinin bir listesi <loc
href="http://www.w3.org/TR"/> adresinde bulunabilir.</p>

<p>Bu belirtim <loc href="http://www.w3.org/Style/Activity">W3C Biçem etkinliği</loc>nin bir parçası olarak üretilmiştir.</p>

</status>

<abstract>

<p>Bu belirtim, XML belgeleri başka XML belgelere dönüştürmekte kullanılan bir dil olan XSLT'nin sözdizimini ve anlamlandırmasını tanımlar.</p>

<p>XSLT, XML için bir biçembent (İng: stylesheet) dili olan XSL'nin bir parçası olarak kullanılmak üzere tasarlanmıştır. XSL, biçimleme belirtmek için XSLT'ye ilaveten bir XML söz varlığına sahiptir. XSL, bir XML belgenin, biçimleme söz varlığını kullanan başka bir XML belgeye nasıl dönüştürüleceğini açıklayan XSLT'yi kullanarak XML belgenin biçemini belirtir.</p>

<p>XSLT, ayrıca, XSL'den bağımsız olarak kullanmak için de tasarlanmışsa da bir genel amaçlı XML dönüşüm dili olarak düşünülmemiştir. Daha çok, asıl olarak XSLT XSL'nin parçası olarak kullanıldığında gereken dönüşüm çeşitleri için tasarlanmıştır.</p>

</abstract>

<langusage>
<language id="tr">Türkçe</language>
<language id="special-bnf">Special Backus-Naur Form (UTF-8 Form)</language>
</langusage>
<revisiondesc>
<slist>
<sitem>See RCS log for revision history.</sitem>
</slist>
</revisiondesc>
</header>
<body>

<div1 id="intro">
<head>Giriş</head>

<p>Bu belirtim, XSLT dilinin sözdizimini ve anlamlandırmasını tanımlar. XSLT dilinde bir dönüşüm, XSLT tarafından tanımlanmış olsun olmasın bütün elemanları içererek, <bibref ref="XMLNAMES"/> veya <bibref ref="XMLNAMES11"/> İsim-alanları Önergesine uygun ve iyi biçimlenmiş bir <bibref ref="XML"/> veya <bibref ref="XML11"/> belge olarak ifadesini bulur. Kolaylık olsun diye, XML 1.0 ve XML Adları 1.0 Önergelerine atıf yapılmıştır. Bu bakımdan, tek biçimli tanım-yeri başvuruları kullanılmışsa da uluslararası tanım-yeri başvuruları da ayrıca desteklenebilir. Bazı durumlarda XML 1.0 ve XML 1.1 tanımları tamamen aynı olabilir. <termdef id="dt-xslt-namespace" term="XSLT
İsim-alanı">XSLT tarafından tanımlanmış elemanlar belli bir XML isim-alanına karşılık olmakla diğerlerinden ayrılırlar (bkz, <specref ref="xslt-namespace"/>); bu belirtimde bu isim-alanından <term>XSLT isim-alanı</term> olarak bahsedilecektir. Bu belirtim aynı zamanda, XSLT isim-alanı sözdiziminin ve anlamlandırmasının bir tanımıdır.</termdef></p>

<p>XSLT'de ifadesini bulan bir dönüşüm, bir kaynak ağacı bir hedef ağaca dönüştürecek kuralları açıklar. Dönüşüm, örüntüler örneklerle ilişkilendirilerek elde edilir. Bir örüntü kaynak ağacındaki elemanlarla eşleşirken, bir örnek hedef ağacın elemanlarını oluşturur. Hedef ağaç, kaynak ağaçtan ayrıdır. Hedef ağacın yapısı kaynak ağacın yapısından tamamen farklı olabilir. Hedef ağaç oluşturulurken, kaynak ağaçtaki elemanlar süzülebilir, yeni bir sırayla dizilebilir ve hatta ağaca tamamen keyfi bir yapı eklenebilir.</p>

<p>XSLT'de ifadesini bulan dönüşüme <kw>biçembent</kw> (İng: stylesheet) denir. Çünkü, XSLT'nin XSL biçimleme söz varlığına dönüştüğü durumda dönüşüm bir biçembent (biçem demeti) olarak iş görür.</p>

<p>Bu belge bir XSLT biçembendinin bir XML belgesi ile nasıl ilişkilendirileceğini açıklamaz. XSL işlemcilerinin <bibref ref="XMLSTYLE"/>'te açıklanan mekanizmayı desteklemeleri önerilir. Bu veya herhangi bir başka mekanizma, bir XML belgeye aynı anda uygulanacak bir XSLT biçembent silsilesinden oluştuğunda, etkisi, silsileyi oluşturan üyeleri aynı sırayla içeren (bkz, <specref ref="import"/>) tek bir biçembendin uygulanmasına eşit olmalıdır.</p>

<p>Bir biçembent, örneklenim kurallarından oluşan bir küme içerir. Bir örneklenim kuralı iki parçadan oluşur: kaynak ağacındaki düğümlere karşılık olan bir örüntü ve hedef ağacın biçimlenecek parçasının biçimleme örneğini içeren bir örneklenim (İng: template). Bu, bir biçembendin kaynak ağaç yapıları birbirine benzeyen geniş bir belge sınıfına uygulanabilmesini mümkün kılar.</p>

<p>Bir örneklenim, hedef ağacın bir bölümünü oluşturacak belli bir kaynak eleman için bir örneklenimdir. Bir örneklenim, hedef eleman yapısını birebir belirten elemanlar içerebileceği gibi, hedef ağaç yapısını oluşturacak yönergeler olarak XSLT isim-alanındaki elemanları da içerebilir. Bir örneklenim işleme sokulduğunda, içerdiği her yönerge yorumlanır ve oluşturacağı hedef ağaç bölümüyle değiştirilir. Yönergeler astsal kaynak elemanlarını seçebilir ve işleyebilir. Bir astsal elemanın işlenmesi, uygun örneklenim kuralının bulunması ve bu kuraldaki örneklenimin işleme sokularak hedef ağacın bir bölümünün  oluşturulması anlamına gelir. Elemanların sadece bir yönergenin yorumlanmasıyla seçildikleri takdirde işleme sokulabileceğine dikkat ediniz. Hedef ağaç, kök düğümü için hazırlanmış örneklenim kuralı bulunup onun örneklenimi işleme sokularak oluşturulur.</p>

<p>Uygun örneklenim kuralını bulma işleminde, birden fazla örneklenim kuralı belirtilen elemanla eşleşen örüntüye sahip olabilir. Ancak, sadece bir örneklenim kuralı uygulanacaktır. Hangi örneklenim kuralının uygulanacağına karar verme yöntemi <specref ref="conflict"/> bölümünde açıklanmıştır.</p>

<p>Bir örneklenim tek başına oldukça güçlü sayılır: az veya çok karmaşıklıkta yapılar oluşturabilir; kaynak ağacın çeşitli yerlerindeki dizge değerlerini çekip çıkarabilir; elemanların kaynak ağaçta yer alışlarına bağlı olarak yinelenen yapılar üretebilir. Basit dönüşümler bakımından, hedef ağacın yapısı kaynak ağacın yapısından bağımsız olduğunda, bir biçembent çoğunlukla kaynak ağacın tamamı için işlem yapan tek bir örneklenimden meydana gelir. İçeriği verilerden oluşan XML belgeler üzerindeki dönüşümler çoğunlukla bu türdendir (bkz, <specref ref="data-example"/>). XSLT bu tür biçembentler için basitleştirilmiş bir sözdizimi sağlar (bkz, <specref ref="result-element-stylesheet"/>).</p>

<p>Bir örneklenim işleme sokulduğunda daima bir <termdef id="dt-current-node" term="Geçerli Düğüm"><term>geçerli düğüm</term></termdef> ve bir <termdef
id="dt-current-node-list" term="Geçerli Düğüm Listesi"><term>geçerli düğüm listesi</term></termdef> ile ilgili olarak işlem yapar. Geçerli düğüm daima geçerli düğüm listesinin bir üyesidir. XSLT'deki işlemlerin çoğu geçerli düğüme göredir. Pek az yönerge geçerli düğüm listesini veya geçerli düğümü değiştirir (bkz, <specref ref="rules"/> ve <specref ref="for-each"/>); bu yönergeler işlem yaptığı sırada, geçerli düğüm listesi yerini yeni düğüm listesine bırakır; yani yeni listenin her üyesi geçerli düğüm haline gelir; yönergenin işi bittiğinde geçerli düğüm listesi veya geçerli düğüm tekrar yönerge öncesinde geçerli olan düğüm listesi ve düğüm olur.</p>

<p>XSLT metin üretmek ve koşullu işlemler için eleman seçerken <bibref
ref="XPATH"/> tarafından tanımlanmış ifade dilini kullanır.</p>

<p>XSLT, dili genişletmek için kullanıcı tarafından değiştirilerek kullanılmak üzere iki özellik sağlar, biri örneklenimlerde kullanılan yönerge elemanları kümesini, diğeri XPath ifadelerinde kullanılan işlev kümesini genişletir. Bu özelliklerin her ikisi de XML isim-alanlarına dayandırılmıştır. XSLT'nin bu sürümü bu özellikleri gerçeklemek için bir mekanizma tanımlamamıştır (bkz, <specref ref="extension"/>).</p>

<note><p>XSL Çalışma Grubu böyle bir mekanizmayı bu belirtimin ileriki sürümlerinde veya ayrı bir belirtimde tanımlamayı düşünmektedir.</p></note>

<p>XSLT tarafından tanımlanmış elemanların sözdizimlerini belirleyen eleman sözdizimi gösterim özeti <specref ref="notation"/> bölümünde açıklanmıştır.</p>

<p>XSLT biçembentleri için MIME ortam türleri olarak <code>text/xml</code> ve
<code>application/xml</code> <bibref ref="RFC2376"/> kullanılmalıdır. Özellikle XSLT biçembentleri için kayda geçirilmiş bir ortam türü olduğunda, bu ortam türü de kullanılabilir.</p>

</div1>

<div1 id="struct">
<head>Biçembent Yapısı</head>

<div2 id="xslt-namespace">
<head>XSLT İsim-alanı</head>

<p>XSLT isim-alanı tanımı <code>&XSLT.ns;</code>adresinde bulunmaktadır.</p>

<note><p>Adresin içindeki <code>1999</code> ibaresi, bu tanım-yerinin (URI) W3C tarafından tahsis edildiği yılı belirtir. XSLT'nin kullanılmakta olan sürümünü göstermez (kullanılmakta olan XSLT sürümü özniteliklerle belirtilir (bkz, <specref ref="stylesheet-element"/> ve <specref ref="result-element-stylesheet"/>).</p></note>

<p>XSLT işlemcileri bu isim-alanındaki elemanları ve öznitelikleri tanımak için XML isim-alanları mekanizmasını <bibref ref="XMLNAMES"/> kullanmalıdır. XSLT isim-alanındaki elemanlar sadece biçembent içinde tanınırlar, kaynak belge içinde tanınmazlar. XSLT tarafından tanımlanmış elemanların tam  listesi <specref ref="element-syntax-summary"/> bölümündedir. Üreticiler XSLT isim-alanını yeni elemanlar ve öznitelikler ekleyerek genişletmemelidirler. Böyle bir genişletme yapılacaksa, bu ayrı bir isim-alanında yapılmalıdır. Ek yönerge elemanları için kullanılacak bir isim-alanı <specref ref="extension-element"/> bölümünde belirtilmiş olan eleman ekleme mekanizmasına göre tanımlanmalıdır.</p>

<p>Bu belirtimde, XSLT isim-alanındaki elemanlara atıfta bulunmak için <tt>xsl:</tt> öneki kullanılmıştır. Ancak, XSLT biçembentleri, XSLT isim-alanının tanım-yerine (URI) önek belirten bir isim-alanı bildirimi yaparak başka bir önek kullanmakta özgürdürler.</p>

<p>XSLT isim-alanındaki bir eleman XSLT isim-alanında bulunmayan bir özniteliği, boş olmayan bir isim-alanı tanım-yerine sahip öznitelik <xtermref href="&XPath;#dt-expanded-name">genişletilmiş ismi</xtermref> belirterek içerebilir. Böyle özniteliklerin varlığı, XSLT elemanlarının ve işlevlerinin bu belgede tanımlanmış davranışını değiştirmemelidir. Bu bakımdan, bir XSLT işlemci böyle öznitelikleri yoksaymakta daima özgürdür ve isim-alanı tanım-yerini bulamıyorsa bunları bir hata vermeksizin yoksaymalıdır. Bu tür özniteliklerle, örneğin, eşsiz tanıtıcılar, eniyileme ipuçları veya belgeleme içerilebilir.</p>

<p>XSLT isim-alanından bir eleman için, bu belgede o eleman için tanımlananlardan başka, boş isim-alanı tanım-yeri belirten genişletilmiş isimli özniteliklere sahip olmak bir hatadır.</p>

<note><p>XSLT eleman, öznitelik ve işlev isimleri için kullanılmakta olan uzlaşımlar şunlardır: isimler küçük harflerden oluşur, sözcükleri ayırmak için tire imleri  ve XML veya HTML gibi alakalı bir dilin sözdiziminde yeralmak kaydıyla kısaltmalar kullanılabilir.</p></note>
</div2>

<div2 id="stylesheet-element">
<head><code>stylesheet</code> Elemanı</head>

<e:element-syntax name="stylesheet">
  <e:attribute name="id">
    <e:data-type name="id"/>
  </e:attribute>
  <e:attribute name="extension-element-prefixes">
    <e:data-type name="dizgecikler"/>
  </e:attribute>
  <e:attribute name="exclude-result-prefixes">
    <e:data-type name="dizgecikler"/>
  </e:attribute>
  <e:attribute name="version" required="yes">
    <e:data-type name="sayı"/>
  </e:attribute>
  <e:sequence>
    <e:element repeat="zero-or-more" name="import"/>
    <e:model name="tepe-seviyeden-elemanlar"/>
  </e:sequence>
</e:element-syntax>

<e:element-syntax name="transform">
  <e:attribute name="id">
    <e:data-type name="id"/>
  </e:attribute>
  <e:attribute name="extension-element-prefixes">
    <e:data-type name="dizgecikler"/>
  </e:attribute>
  <e:attribute name="exclude-result-prefixes">
    <e:data-type name="dizgecikler"/>
  </e:attribute>
  <e:attribute name="version" required="yes">
    <e:data-type name="sayı"/>
  </e:attribute>
  <e:sequence>
    <e:element repeat="zero-or-more" name="import"/>
    <e:model name="tepe-seviyeden-elemanlar"/>
  </e:sequence>
</e:element-syntax>

<p>Bir biçembent, bir XML belgede bir <code>xsl:stylesheet</code> elemanı tarafından ifade edilir. <code>xsl:transform</code> elemanı <code>xsl:stylesheet</code> elemanının yerine (eşanlamlı) kullanmak içindir.</p>

<p>Bir <code>xsl:stylesheet</code> elemanı, biçembendin gerekirdiği XSLT sürümünün belirtildiği bir <code>version</code> özniteliğine sahip olmak zorundadır ve XSLT'nin bu sürümü için değeri <code>1.0</code> olmalıdır. Değer <code>1.0</code> olmadığı takdirde, ileriye uyumlu işlem kipi etkin olur (bkz, <specref ref="forwards"/>).</p>

<p><code>xsl:stylesheet</code> elemanı şu elemanları içerebilir:</p>
<slist>
<sitem><code>xsl:import</code></sitem>
<sitem><code>xsl:include</code></sitem>
<sitem><code>xsl:strip-space</code></sitem>
<sitem><code>xsl:preserve-space</code></sitem>
<sitem><code>xsl:output</code></sitem>
<sitem><code>xsl:key</code></sitem>
<sitem><code>xsl:decimal-format</code></sitem>
<sitem><code>xsl:namespace-alias</code></sitem>
<sitem><code>xsl:attribute-set</code></sitem>
<sitem><code>xsl:variable</code></sitem>
<sitem><code>xsl:param</code></sitem>
<sitem><code>xsl:template</code></sitem>
</slist>

<p><termdef id="dt-top-level" term="Tepe-seviyeden eleman">Bir <code>xsl:stylesheet </code> elemanının çocuğu olan bir elemana <term>tepe-seviyeden</term> eleman denir.</termdef></p>

<p>Bu örnekte bir biçembendin yapısı gösterilmiştir. Üç nokta imleri (<code>...</code>) içeriği veya öznitelik değerini betimler. Bu örnek olası elemanların her birinden sadece bir tane içeriyorsa da biçembentler bu elemanların birden fazlasını içerebileceği gibi hiç içermeyebilir de.</p>

<eg>&lt;xsl:stylesheet version="1.0"
                xmlns:xsl="&XSLT.ns;"><![CDATA[
  <xsl:import href="..."/>

  <xsl:include href="..."/>

  <xsl:strip-space elements="..."/>

  <xsl:preserve-space elements="..."/>

  <xsl:output method="..."/>

  <xsl:key name="..." match="..." use="..."/>

  <xsl:decimal-format name="..."/>

  <xsl:namespace-alias stylesheet-prefix="..." result-prefix="..."/>

  <xsl:attribute-set name="...">
    ...
  </xsl:attribute-set>

  <xsl:variable name="...">...</xsl:variable>

  <xsl:param name="...">...</xsl:param>

  <xsl:template match="...">
    ...
  </xsl:template>

  <xsl:template name="...">
    ...
  </xsl:template>

</xsl:stylesheet>]]></eg>

<p><code>xsl:stylesheet</code>elemanının çocuklarının yer alış sırası hata takibi ve <code>xsl:import</code> elemanları dışında önemsizdir. Kullanıcılar elemanları istedikleri sırada kullanmakta özgürdürler ve biçembent oluşturma araçları, elemanların yer alış sırası üzerinde bir denetime sahip olmamalıdır.</p>

<p>Bundan başka, <code>xsl:stylesheet</code> elemanı XSLT isim-alanında bulunmayan elemanlar (isim-alanının tanım-yerine (URI) önek belirten bir isim-alanı bildirimi yaparak ve bu öneki isminde içererek) içerebilir. Bu tür üst seviyeden elemanların varlığı, XSLT elemanlarının ve işlevlerinin bu belgede tanımlanmış davranışını değiştirmemelidir; örneğin, çelişkileri çözümlemede farklı kuralların kullanıldığı <code>xsl:apply-templates</code>'ler belirten bu türden bir üst seviyeden elemana izin verilmemelidir. Dolayısıyla, bir XSLT işlemci bu türden üst seviyeden elemanları yoksaymakta daima özgürdür ve isim-alanı tanım-yerini bulamıyorsa bunları bir hata vermeksizin yoksaymalıdır. Bu tür elemanlar şunlar için gerekebilir:</p>

<slist>
<sitem>Ek elemanlar veya ek işlevler tarafından kullanılan bilgiler (bkz, <specref ref="extension"/>),</sitem>
<sitem>hedef ağaçta yapılacaklarla ilgili bilgiler,</sitem>
<sitem>kaynak ağacın nasıl temin edileceği bilgisi,</sitem>
<sitem>biçembentle ilgili temel veriler,</sitem>
<sitem>biçembentle ilgili belgeleme.</sitem>
</slist>

</div2>

<div2 id="result-element-stylesheet">
<head>Birebir Hedef Eleman olarak Biçembent</head>
<p>Basitleştirilmiş sözdizimi, bir biçembentin kök düğüme denk gelen tek bir örneklenimle oluşturulmasını mümkün kılar. Yani, biçembentin kendisi hedef elemandan oluşabilir (bkz, <specref ref="literal-result-element"/>). Böyle bir biçembent, içeriği birebir hedef eleman olan bir örneklenim kuralını içeren <code>xsl:stylesheet</code> elemanlı bir biçembente eşdeğerdir; örneklenim kuralı <code>/</code> örüntüsü ile eşleşir. Örneğin,</p>

<eg>&lt;html xsl:version="1.0"
      xmlns:xsl="&XSLT.ns;"
      xmlns="&XHTML.ns;"><![CDATA[
  <head>
    <title>Harcama Raporu Hülâsası</title>
  </head>
  <body>
    <p>Toplam Miktar: <xsl:value-of select="harcama-raporu/toplam"/></p>
  </body>
</html>]]></eg>

<p>ile</p>

<eg>&lt;xsl:stylesheet version="1.0"
                xmlns:xsl="&XSLT.ns;"
                xmlns="&XHTML.ns;"><![CDATA[
<xsl:template match="/">
<html>
  <head>
    <title>Harcama Raporu Hülâsası</title>
  </head>
  <body>
    <p>Toplam Miktar: <xsl:value-of select="harcama-raporu/toplam"/></p>
  </body>
</html>
</xsl:template>
</xsl:stylesheet>]]></eg>

<p>eşdeğerdir.</p>

<p>Bir biçembendin belge elemanı olan bir birebir hedef eleman, biçembendin gerektirdiği XSLT sürümünü belirten bir <tt>xsl:version</tt> özniteliğine sahip olmak zorundadır. XSLT'nin bu sürümü için bu değer <code>1.0</code> olup değer bir <xnt href="&XPath;#NT-Number">Sayı</xnt> olmalıdır. Diğer birebir hedef elemanlar ayrıca birer <tt>xsl:version</tt> özniteliğine sahip olabilir. <tt>xsl:version</tt> özniteliğinin değeri <code>1.0</code> olmadığı takdirde, ileriye uyumlu işlem kipi etkin olur (bkz, <specref ref="forwards"/>).</p>

<p>Bir biçembent olarak kullanıldığında bir birebir hedef elemanın içeriği,  biçembendin içinde kullanılandakinden farklı değildir. Bu bakımdan, bir biçembent olarak kullanılmış olan bir birebir hedef eleman <termref def="dt-top-level">tepe-seviyeden</termref> elemanlar içeremez.</p>

<p>Bazı durumlarda, sistemin bir XML belgenin bir XSLT biçembendi olarak bir XSLT işlemcisi tarafından işlenmesinin gerektiğini anlamasının tek yolu XML belgenin kendisini incelemesi olabilir. Basitleştirilmiş sözdiziminin kullanılması bu süreci daha da zorlaştıracaktır.</p>

<note><p>Örneğin, başka XML dili (BXD) diye bir dilin belge elemanı üzerinde, XML belgenin bir BXD işlemcisi tarafından işlenmesi gereken bir BXD belgesi olduğunu belirten, bir <code>bxd:version</code> özniteliği kullanmış olsun. Eğer bir belge hem <code>bxd:version</code> hem de <tt>xsl:version</tt> özniteliklerine sahipse belgenin bir BXD işlemci tarafından mı yoksa bir XSLT işlemci tarafından mı işleneceği belli olmayacaktır.</p></note>

<p>Diğer taraftan, böyle bir durumda, XSLT biçembendinde basitleştirilmiş sözdiziminin kullanılmaması gerekir. Bu durum, örneğin, içeriğini işlemek için iletinin MIME ortam türüne bakan bir alıcıya, bir XSLT biçembendinin <code>text/xml</code> veya <code>application/xml</code> MIME ortam türünde bir ileti olarak aktarıldığı bir durum olarak karşımıza çıkabilir.</p>

</div2>

<div2 id="qname">
<head>Nitelikli Adlar</head>

<p>Bir dahili XSLT nesnesinin ismi, özellikle bir isimli örneklenim (<specref ref="named-templates"/>), bir kip (<specref ref="modes"/>), bir öznitelik kümesi (<specref ref="attribute-sets"/>), bir anahtar (<specref ref="key"/>), bir onluk sayı biçimi (<specref ref="format-number"/>), bir değişken veya değergeç (<specref ref="variables"/>) birer <xnt href="&XMLNames;#NT-QName">NitelAd</xnt> olarak belirtilir. Eğer nitelikli ad bir öneke sahipse, önek bir tanım-yeri başvurusuna genişletilir; bu tanım-yerine başvurusuna genişletme işlemi, ismin yer aldığı öznitelik üzerinden etkili olan isim-alan bildirimleri kullanılarak yapılır.
<xtermref href="&XPath;#dt-expanded-name">Genişletilmiş isim</xtermref> ismin yerel kısmı ile nesne ismi olarak kullanılan ve boş olabilen bir tanım-yeri başvurusundan oluşur. Öntanımlı isim-alanı öneksiz isimler için kullanılMAZ.</p>

</div2>

<div2 id="forwards">
<head>İleriye Uyumlu İşlem</head>

<p>Bir eleman ileriye uyumlu kipi kendisi, öznitelikleri, astsalları için şunlardan birinin varlığı halinde etkinleştirir:</p>

<slist>
<sitem>Eleman, <code>version</code> özniteliği <code>1.0</code>'dan farklı bir <code>xsl:stylesheet</code> elemanıdır.</sitem>

<sitem>Eleman, <tt>xsl:version</tt> özniteliği <code>1.0</code>'dan farklı bir değerde olan bir birebir hedef elemandır.</sitem>

</slist>

<p>Değeri <code>1.0</code> olan bir <tt>xsl:version</tt> özniteliğine sahip bir birebir hedef eleman ileriye uyumlu kipi kendisi, öznitelikleri, astsalları ve astsallarının öznitelikleri için etkinleştirmeyecektir.</p>

<p>Eğer bir eleman ileriye uyumlu kipte işlem yapıyorsa:</p>

<ulist>

<item><p>Eleman, bir <termref def="dt-top-level">tepe-seviyeden</termref> elemansa ve XSLT 1.0 böyle elemanlara tepe seviyeden elemanlar olarak izin vermiyorsa, eleman içeriğiyle birlikte yoksayılmalıdır.</p></item>

<item><p>Eleman bir örneklenim içindeyse ve XSLT 1.0 böyle elemanların bir örneklenim içinde bulunmasına izin vermiyorsa,  eleman işleme sokulamadığı takdirde bir hata oluşmalı, aksi takdirde XSLT, eleman için <specref ref="fallback"/> bölümünde belirtildiği gibi bir son çareye başvurmalıdır.</p></item>

<item><p>Eleman, XSLT 1.0 tarafından bir elemanın sahip olmasına izin verilmeyen bir özniteliğe sahipse ya da XSLT 1.0 tarafından bir seçimlik özniteliğin sahip olmasına izin verilmeyen bir değere sahip bir özniteliğe sahipse, öznitelik yoksayılmalıdır.</p></item>

</ulist>

<p>Bu bakımlardan, bir XSLT işlemci aşağıdaki biçembenti, bu belirtimde tanımlanmamış bir XSLT isim-alanından elemanlar içerse bile hatasız işleyebilmelidir.</p>

<eg>&lt;xsl:stylesheet version="1.1"
                xmlns:xsl="&XSLT.ns;"><![CDATA[
  <xsl:template match="/">
    <xsl:choose>
      <xsl:when test="system-property('xsl:version') >= 1.1">
        <xsl:yeni-heyecan-verici-1.1-özelliği/>
      </xsl:when>
      <xsl:otherwise>
        <html>
        <head>
          <title>XSLT 1.1 gerekli</title>
        </head>
        <body>
          <p>Bu biçembent XSLT 1.1 gerektiriyor.</p>
        </body>
        </html>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>
</xsl:stylesheet>]]></eg>

<note><p>Eğer bir biçembent sürümü 1.0'dan sonraki bir XSLT'ye ait bir tepe seviyeden elemana son derece bağımlıysa, biçembent, XSLT'nin daha erken sürümlerini gerçekleyen XSLT işlemcilerin tepe seviyeden elemanları sessizce yoksaymayacağından emin olmak için bir <code>xsl:message</code> elemanını <code>terminate="yes"</code> özniteliği ile kullanabilir (bkz, <specref ref="message"/>). Örnek:</p>

<eg>&lt;xsl:stylesheet version="1.5"
                xmlns:xsl="&XSLT.ns;"><![CDATA[

  <xsl:etkili-yeni-1.1-bildirimi/>

  <xsl:template match="/">
    <xsl:choose>
      <xsl:when test="system-property('xsl:version') &lt; 1.1">
        <xsl:message terminate="yes">
          <xsl:text>Bu biçembent XSLT 1.1 gerektiriyor.</xsl:text>
        </xsl:message>
      </xsl:when>
      <xsl:otherwise>
        ...
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>
  ...
</xsl:stylesheet>]]></eg>
</note>

<p>
Eğer bir <termref def="dt-expression">ifade</termref> ileriye uyumlu kipte işlem yapan bir öznitelikte bulunuyorsa, XSLT işlemci ifadedeki bazı hatalar için şöyle davranmalıdır:</p>

<ulist>

<item><p>Eğer ifade XPath dilbilgisine göre izin verilen sözdizimine uygun değilse, ifade gerçekten değerlendirilemedikçe bir hata üretilmemelidir.</p></item>

<item><p>Eğer ifade XSLT kütüphanesinin bir parçası olmayan ve ismi öneksiz olan bir işlevi çağırıyorsa, işlev gerçekten çağrılamadıkça bir hata üretilmemelidir.</p></item>

<item><p>Eğer ifade  bir işlevi, XSLT tarafından izin verilmeyen sayıda argümanla veya XSLT tarafından izin verilmeyen türdeki argümanlarla çağırıyorsa, işlev gerçekten çağrılamadıkça bir hata üretilmemelidir.</p></item>

</ulist>


</div2>

<div2>
<head>Biçembentlerin Birleştirilmesi</head>

<p>XSLT biçembentlerin birleştirilmesi için iki mekanizmaya sahiptir:</p>

<slist>

<sitem>Anlamsallıkları değişmeksizin biçembentlerin birleştirilebilmelerini mümkün kılan içerme mekanizması ve</sitem>

<sitem>her biçembentin diğerlerinin yukarısına gelecek şekilde birleştirilmesini mümkün kılan ithal mekanizması.</sitem>

</slist>

<div3 id="include">
<head>Biçembentlerin İçerilmesi</head>

<e:element-syntax name="include">
  <e:in-category name="tepe-seviyeden-eleman"/>
  <e:attribute name="href" required="yes">
    <e:data-type name="tanım-yeri-başvurusu"/>
  </e:attribute>
  <e:empty/>
</e:element-syntax>

<p>Bir XSLT biçembendi başka bir XSLT biçembendini bir <code>xsl:include</code> elemanı kullanarak içerebilir. <code>xsl:include</code> elemanı, değeri içerilecek biçembendin tanım-yerine bir başvuru olan bir <code>href</code> özniteliğine sahiptir. Göreli bir tanım-yeri <code>xsl:include</code> elemanını içeren biçembendin tanım-yerine göre çözümlenir (bkz, <specref ref="base-uri"/>).</p>

<p><code>xsl:include</code> elemanına sadece <termref def="dt-top-level">tepe-seviyeden</termref> bir eleman olarak izin verilir.</p>

<p>İçerme işlemi XML ağaç seviyesinde gerçekleşir. <code>href</code> özniteliğinin değeriyle yeri belirlenen kaynak bir XML belge olarak ele alınır ve  bu belgedeki <code>xsl:stylesheet</code> elemanının çocukları <code>xsl:include</code> elemanının yerine yerleştirilirler. İçerilen örneklenim kuralları ve tanımları işlem sırasını fiilen etkilemezler.</p>

<p>İçerilen biçembent <specref ref="result-element-stylesheet"/> bölümünde açıklanan basitleştirilmiş sözdizimini kullanıyor olabilir ve böyle bir durumda biçembent eşdeğer <code>xsl:stylesheet</code> elemanı ile aynı şekilde ele alınır.</p>

<p>Bir biçembendin doğrudan veya dolaylı kendi kendini içeriyor olması bir hatadır.</p>

<note><p>Defalarca içerilen bir biçembent tanımların tekrarı sebebiyle hatalara yol açabilir. Böyle çoklu içerimler dolaylı olduklarında daha az belirgin olurlar. Örneğin, <var>B</var> ve <var>C</var> biçembendleri <var>A</var> biçembendini içeriyorsa ve <var>D</var> biçembendi de hem <var>B</var> hem de <var>C</var> biçembendini içeriyorsa, <var>A</var> biçembendi, <var>D</var> biçembendi tarafından dolaylı olarak iki kere içerilmiş olacaktır. <var>B</var>, <var>C</var> ve <var>D</var> biçembentlerinin herbiri bağımsız biçembentler olarak kullanılıyorsa, <var>B</var> biçembendindeki <var>A</var> biçembendinin içerilmesi dışındaki herşeyi bir <var>B'</var> biçembendine aktararak ve benzer bir işlemi <var>C</var> biçembendi içinde yaptıktan sonra <var>D</var> biçembendini <var>A</var>, <var>B'</var> ve <var>C'</var> biçembentlerini içerecek şekilde değiştirerek hatadan kurtulmak mümkün olabilir.</p></note>

</div3>

<div3 id="import">
<head>Biçembent İthali</head>

<e:element-syntax name="import">
  <e:attribute name="href" required="yes">
    <e:data-type name="tanım-yeri-başvurusu"/>
  </e:attribute>
  <e:empty/>
</e:element-syntax>

<p>Bir XSLT biçembendi başka bir XSLT biçembendini bir <code>xsl:import</code> elemanı kullanarak ithal edebilir. İthal edilen biçembentteki örneklenim kurallarının ve tanımlarının ithal eden biçembenttekilerin önüne geçmesi dışında ithal işlemi içerme işlemine (bkz, <specref ref="include"/>) benzer; işlem aşağıda daha ayrıntılı olarak açıklanmıştır. <code>xsl:import</code> elemanı, değeri ithal edilecek biçembendin tanım-yerine bir başvuru olan bir <code>href</code> özniteliğine sahiptir. Göreli bir tanım-yeri <code>xsl:import</code> elemanını içeren biçembendin tanım-yerine göre çözümlenir (bkz, <specref ref="base-uri"/>).</p>

<p><code>xsl:import</code> elemanına sadece <termref def="dt-top-level">tepe-seviyeden</termref> bir eleman olarak izin verilir.</p>

<p><code>xsl:import</code> elemanının çocukları, bir <code>xsl:stylesheet</code> elemanının diğer bütün çocuklarının ve varsa <code>xsl:include</code> elemanlarının herbirinin çocuklarının öncesine geçmelidir. <code>xsl:include</code> bir biçembendi içermek üzere kullanıldığında, içerilen belgedeki <code>xsl:import</code> elemanları yine yukarıya ama, içeren belgedeki <code>xsl:import</code> elemanlarının sonrasına gider. Örnek:</p>

<eg>&lt;xsl:stylesheet version="1.0"
                xmlns:xsl="&XSLT.ns;"><![CDATA[
  <xsl:import href="article.xsl"/>
  <xsl:import href="bigfont.xsl"/>
  <xsl:attribute-set name="note-style">
    <xsl:attribute name="font-style">italic</xsl:attribute>
  </xsl:attribute-set>
</xsl:stylesheet>]]></eg>

<p><termdef id="dt-import-tree" term="İthal Ağaç"><code>xsl:import</code> elemanları içeren bir biçembentin işlenmesi sırasında karşılaşılan <code>xsl:stylesheet</code> elemanları bir <term>ithal ağaç</term> olarak ele alınır. İthal ağaçtaki her <code>xsl:stylesheet</code> elemanı, içerdiği her
<code>xsl:import</code> elemanı için bir ithal çocuğa sahip olur. <code>xsl:include</code> elemanları ithal ağaç oluşturulmadan önce çözümlenir. </termdef> <termdef id="dt-import-precedence" term="İthal Önceliği"> İthal ağaçtaki bir <code>xsl:stylesheet</code> elemanına, ithal ağacın çocuğu olarak işleme alınacak bir <code>xsl:stylesheet</code>  elemanından önce ziyaret edilmiş diğer bir <code>xsl:stylesheet</code> elemanından daha düşük bir  <term>ithal önceliği</term> tanınır. (Türkçesi, bir sülaledeki bir evlatlığın öz evlatları evlatlıklarından sonra ziyaret edilir.)</termdef>  Her tanımın ve örneklenim kuralının ithal önceliği kendini içeren <code>xsl:stylesheet</code> elemanına göre belirlenir.</p>

<p>Varsayalım,</p>

<slist>
<sitem><var>A</var> biçembendi sırasıyla <var>B</var> ve <var>C</var> biçembentlerini ithal etmiş olsun;</sitem>
<sitem><var>B</var> biçembenti <var>D</var>'yi</sitem>
<sitem><var>C</var> biçembendi de <var>E</var>'yi ithal etmiş olsun.</sitem>
</slist>

<p>İthal önceliği sırası <var>D</var>, <var>B</var>, <var>E</var>, <var>C</var>, <var>A</var> olacaktır.</p>

<note><p><code>xsl:import</code> elemanlarının herhangi bir tanım veya örneklenim kuralından önce kullanılması gerektiğinden, ithal edilen biçembentleri <code>xsl:import</code> elemanına rastlandığı noktada işleme sokan bir gerçeklenim, tanımlara ve örneklenim kurallarına artan ithal önceliğiyle rastlayacaktır.</p></note>

<p>Genel olarak, daha yüksek önceliğe sahip bir tanım veya örneklenim kuralı, daha düşük ithal önceliğine sahip bir tanım veya örneklenim kuralından öncelikli olur. Bu, her tanım veya örneklenim kuralı çeşidi için ayrı ayrı tanımlanır.</p>

<p>Bir biçembendin doğrudan veya dolaylı kendi kendini ithal ediyor olması bir hatadır. Bundan kaçınmak için, belli bir tanım-yeri ile bir biçembendin birden fazla yerde ithal edilmesi durumunda, biçembent özel olarak ele alınmaz. <termref def="dt-import-tree">İthal ağaç</termref>, ithal edildiği her noktada ayrı bir <code>xsl:stylesheet</code>'e sahip olur.</p>

<note><p>Eğer <code>xsl:apply-imports</code> kullanılmışsa (bkz, <specref
ref="apply-imports"/>), davranış, biçembendin sadece en yüksek <termref def="dt-import-precedence">ithal öncelikli</termref> yerde ithal edilmesi durumundakinden farklı olabilir.</p></note>

</div3>

</div2>

<div2>
<head>Gömülü Biçembentler</head>

<p>Normalde bir biçembent, belge elemanı <code>xsl:stylesheet</code> elemanı olan eksiksiz bir XML belgedir. Buna rağmen, bir XSLT biçembenti başka bir kaynağa da gömülebilir. İki çeşit gömülüm mümkündür:</p>

<slist>
<sitem>XSLT biçembendi XML olmayan bir kaynağa gömülebilir veya</sitem>
<sitem>XML belgenin belge elemanı <code>xsl:stylesheet</code> elemanı olmaksızın biçembent bir XML kaynağa gömülebilir.</sitem>
</slist>

<p>İkinci şeklini kolaylaştırmak için, <code>xsl:stylesheet</code> elemanının eşsiz bir betimleyici içeren bir ID özniteliğine sahip olması mümkün kılınmıştır.</p>

<note><p>Böyle bir özniteliğin XPath <xfunction>id</xfunction> işlevi ile kullanılabilmesi için gerçekten de ID türünden bir öznitelik olarak DTD'de bildirilmiş olması gerekir.</p></note>

<p>Aşağıdaki örnekte <code>xml-stylesheet</code> işlem yönergesinin <bibref ref="XMLSTYLE"/> bir belgenin kendi biçembendini içermesini mümkün kılmak için nasıl kullanılabileceği gösterilmiştir. Tanım-yeri başvurusunda <code>xsl:stylesheet</code> elemanının yeri olarak bölüm betimleyicili bir göreli tanım-yeri kullanılmıştır:</p>

<eg><![CDATA[<?xml-stylesheet type="text/xml" href="#style1"?>
<!DOCTYPE doc SYSTEM "doc.dtd">
<doc>
<head>

<xsl:stylesheet id="style1"
                version="1.0"]]>
                xmlns:xsl="&XSLT.ns;"
                xmlns:fo="&XSLFO.ns;"><![CDATA[

<xsl:import href="doc.xsl"/>

<xsl:template match="id('foo')">
  <fo:block font-weight="bold">
    <xsl:apply-templates/>
  </fo:block>
</xsl:template>

<xsl:template match="xsl:stylesheet">
  <!-- ignore -->
</xsl:template>

</xsl:stylesheet>

</head>
<body>
<para id="foo">
...
</para>
</body>
</doc>
]]></eg>

<note><p>Bir biçembent, ister uygulansın, ister içerilsin, ister ithal edilsin bir belgeye gömüldüğü takdirde yoksayılacak bir <code>xsl:stylesheet</code> elemanı belirtilmiş bir örneklenim kuralının varlığını gerektirir.</p></note>

</div2>

</div1>

<div1 id="data-model">
<head>Veri Modeli</head>

<p>XSLT tarafından kullanılan veri modeli, bu bölümdeki açıklananlar dışında <xspecref href="&XPath;#data-model">XPath veri modeli</xspecref> ile aynıdır. XSLT aynı veri modelini kullanan kaynak, hedef ve biçembent belgeleri üzerinde işlem yapar. Aynı ağaca sahip herhangi iki XML belge XSLT'ye göre aynı belgedir.</p>

<p>Biçembentteki işlem yönergeleri ve açıklamalar yoksayılır: biçembent, ağacında ne işlem yönergesi (İng: processing instruction) ne de açıklama varmış gibi ele alınır.</p>

<div2 id="root-node-children">
<head>Kök Düğümün Çocukları</head>

<p>Kök düğümün çocukları üzerindeki normal kısıtlamalar hedef ağaç için esnetilir.  Hedef ağacın çocukları bir eleman düğümü için olası herhangi bir sırada olabilir. Özellikle, metin düğümü çocuklara sahip olabileceği gibi istenen sayıda eleman düğümü çocuğa sahip olabilir. <code>xsl:output</code> yöntemi (bkz, <specref ref="output"/>) XML çıktı için kullanıldığında hedef ağacın iyi biçimlenmiş bir XML belgesi olması gerekmeyebilir; yine de, çıktı daima iyi biçimlenmiş haricen çözümlenebilir bir öğe olacaktır.</p>

<p>Kaynak ağacı iyi biçimlenmiş bir XML belge çözümlenerek oluşturulduğunda, kaynak ağacın kök düğümü, bir metin düğümüne sahip olmamak ve tek bir çocuk elemana sahip olmak gibi normal kısıtlamaları kendiliğinden yerine getirecektir. Kaynak ağacı, DOM kullanımı gibi başka bir yöntemle oluşturulduğunda geçerli kısıtlamalar kaynak ağaç için hedef ağaçtaki kadar esnektir.</p>

</div2>

<div2 id="base-uri">
<head>Temel Tanım-yeri</head>

<p>Her düğümün kendisiyle ilişkili tanım-yerine o düğümün <kw>temel tanım-yeri</kw> denir ve göreli tanım-yerlerini mutlak tanım-yerleri haline getirmek için öznitelik değerlerini çözümlemekte kullanılır. Eğer bir eleman veya işlem yönergesi harici bir öğe içinde yer alıyorsa, bu elemanın veya işlem yönergesinin temel tanım-yeri harici öğenin tanım-yeri olur; aksi takdirde, temel tanım-yeri, belgenin tanım-yeridir. Belge düğümünün temel tanım-yeri belge öğesinin tanım-yeridir. Bir metin, açıklama, öznitelik veya bir isim-alanı düğümümünün temel tanım-yeri ise, ebeveyn düğümün temel tanım-yeridir.</p>

</div2>

<div2 id="unparsed-entities">
<head>Çözümlenmemiş Öğeler</head>

<p>Kök düğüm, belgenin DTD'sinde bildirilmiş her çözümlenmemiş öğe için tanım-yeri veren bir eşleme sahiptir. Tanım-yeri, <xspecref href="&XML;#sec-external-ent">öğe bildiriminde</xspecref> belirtilen <xtermref href="&XML;#dt-sysid">sistem betimleyici</xtermref> ve <xtermref href="&XML;#dt-pubid">genel betimleyiciden</xtermref> üretilir. XSLT işlemci, tanım-yerini üretmek için sistem betimleyicide belirtilen tanım-yerini bırakıp genel betimleyiciyi kullanabilir. Eğer XSLT işlemci tanım-yerini üretmek için genel betimleyiciyi kullanmıyorsa, sistem betimleyiciyi kullanmalıdır; eğer sistem betimleyici bir göreli tanım-yeri ise, temel tanım-yeri <bibref ref="RFC2396"/> olarak öğe bildirimini içeren kaynağın tanım-yerini kullanarak onu bir mutlak tanım-yeri olarak çözümlemelidir.</p>

</div2>

<div2 id="strip">
<head>Boşluk Ayıklama</head>

<p>Kaynak belge veya biçembent belgesi için ağaç oluşturulup, XSLT tarafından bir şekilde işleme sokulmadan önce bazı metin düğümleri ayıklanabilir. Bir metin düğümü salt boşluk karakterlerini içeriyor olmadıkça asla ayıklanamaz. Metin düğümünün ayıklanması metin düğümünü ağaçtan siler. Ayıklama işleminde boşlukları korunması gereken elemanların isimlerinden oluşan bir küme girdi olarak alınır. Ayıklama işlemi biçembentlerin ve kaynak belgelerin her ikisine de uygulanır, ancak boşlukları korunması gereken elemanlar saptanırken uygulama farklı olur.</p>

<p>Aşağıdakilerin herhangi biri uygulanabiliyorsa bir metin düğümü korunur:</p>

<ulist>

<item><p>Metin düğümünün <xtermref href="&XPath;#axis-parent">ebeveyn</xtermref>inin eleman ismi boşlukları korunması gereken eleman isimleri arasındadır.</p></item>

<item><p>Metin düğümü en azından bir tane boşluk olmayan karakter içeriyordur. XML'deki gibi, bir boşluk karakteri <code>#x20</code>, <code>#x9</code>, <code>#xD</code> veya <code>#xA</code> olabilir.</p></item>

<item><p>Metin düğümünün bir <xtermref href="&XPath;#axis-ancestor">üstsel</xtermref> elemanı <code>preserve</code> değerli bir <code>xml:space</code> özniteliğine sahiptir ve üstsel elemanları arasında <code>default</code> değerli <code>xml:space</code> özniteliğine sahip eleman hiç yoktur.</p></item>

</ulist>

<p>Aksi takdirde, metin düğümü ayıklanır.</p>

<p><code>xml:space</code> öznitelikleri ağaçtan ayıklanmaz.</p>

<note><p>Eğer bir birebir hedef elemanda bir <code>xml:space</code> özniteliği belirtilmişse, bu uygulanır ve sonuç özniteliği içerir.</p></note>

<p>Biçembentler bakımından, boşlukları korunması gereken eleman isimleri kümesi sadece <code>xsl:text</code> içerir.</p>

<e:element-syntax name="strip-space">
  <e:in-category name="tepe-seviyeden-eleman"/>
  <e:attribute name="elements" required="yes">
    <e:data-type name="dizgecikler"/>
  </e:attribute>
  <e:empty/>
</e:element-syntax>

<e:element-syntax name="preserve-space">
  <e:in-category name="tepe-seviyeden-eleman"/>
  <e:attribute name="elements" required="yes">
    <e:data-type name="dizgecikler"/>
  </e:attribute>
  <e:empty/>
</e:element-syntax>

<p>Kaynak belgeler için, boşlukları korunması gereken eleman isimleri <termref
def="dt-top-level">tepe-seviyeden</termref> elemanlar olan <code>xsl:strip-space</code> ve <code>xsl:preserve-space</code> ile belirtilir.
Bir eleman isminin boşlukları korunması gereken isimler arasında bulunup bulunmadığı en iyi <code>xsl:strip-space</code> veya <code>xsl:preserve-space</code> elemanlarında belirtilmiş isimlerden saptanır. Bir eleman isminin boşlukları korunması gereken isimler arasında bulunması için gerek ve yeter koşul, bir <code>xsl:preserve-space</code> elemanında belirtilen isimlerden biri ile bir eşleşmenin varlığıdır. <code>xsl:strip-space</code> ve <code>xsl:preserve-space</code> elemanların ikisi de değeri boşluk ayraçlı <xnt href="&XPath;#NT-NameTest">AdSınaması</xnt> listesi olan birer <code>elements</code> özniteliğine sahiptir; Bir elemanın bir <code>xsl:strip-space</code> veya <code>xsl:preserve-space</code> ile eşleşmesi <xnt href="&XPath;#NT-NameTest">AdSınamaları</xnt>ndan biri ile eşleşmesi demektir. Bir elemanın bir <xnt href="&XPath;#NT-NameTest">AdSınaması</xnt> ile eşleşmesi için gerek ve yeter koşul, <xnt href="&XPath;#NT-NameTest">AdSınaması</xnt>nın bir <xtermref href="&XPath;#dt-node-test">XPath düğüm sınaması</xtermref> olarak eleman için doğru olmasıdır. Birden fazla <code>xsl:strip-space</code> ve <code>xsl:preserve-space</code> elemanı ile eşleşme olduğu takdirde, en iyi eşleşen eleman, en iyi eşleşen <xnt href="&XPath;#NT-NameTest">AdSınaması</xnt> saptanarak bulunur. Bu saptama örneklenim kurallarındaki yöntemle aynıdır:</p>

<ulist>

<item><p>Önce, diğer eşleşmeden daha düşük <termref
def="dt-import-precedence">ithal önceliğine</termref> sahip eşleşmeler yoksayılır.</p></item>

<item><p>Sonra, diğer eşleşmenin <termref def="dt-default-priority">öntanımlı önceliğinden</termref> düşük <termref def="dt-default-priority">öntanımlı öncelikli </termref> eşleşmeler yoksayılır.</p></item>

</ulist>

<p>Eğer bu yöntemle geriye birden fazla eşleşme kalırsa bu bir hatadır. Bir XSLT işlemci hatayı bildirebilir; eğer bildirmiyorsa, kalan eşleşmeler arasından biçembentte sona doğru yer alanını seçerek hatayı ortadan kaldırmalıdır.</p>

</div2>

<div2 id="E38">
<head>XML Sürümü</head>
<p>Veri modeli, bir XML 1.0 belgeyi (<bibref ref="XML"/> ve <bibref ref="XMLNAMES"/> ile uyumlu) veya bir XML 1.1 belgeyi (<bibref ref="XML11"/> ve <bibref ref="XMLNAMES11"/> ile uyumlu) ifade edebilecek ve ikisi arasında bir ayrım yapmayacak yetenektedir. Bu bakımdan, ilke olarak, XSLT 1.0 bu XML sürümlerinden biri ile kullanılabilir; farklılık sadece, dönüşüme özel sınırların dışında, ya veri modeli metinsel XML'den (çözümlenerek) oluşturulurken ya da metinsel XML veri modelinden üretilirken (sırayla denk düşürerek) ortaya çıkar.</p>

<p>Veri modelinin oluşturulması bu belirtimin kapsamı dışındadır, dolayısıyla bir XSLT işlemcinin girdiyi bir XML 1.0 veya XML 1.1 belgeden ya da her ikisinden de kabul etmesi ile ilgili bir gereksinim yer almaz. Bu belge XML 1.0 veya XML 1.1 belgeleri çıktılama yeteneğini tanımlar. Ve yine, bir XSLT işlemcinin XML sürümlerinden birini veya ikisini de desteklemesi ile ilgili bir gereksinim yer almaz.</p>

<p>Kaynak belge ister XML 1.0 ister XML 1.1 olsun veri modeli aynı olduğundan, XSLT işleminin anlambilgisi kaynak belgenin XML sürümüne bağlı değildir. İlke olarak, tek bir dönüşümde kullanılan tüm girdi ve çıktı belgelerinin aynı XML sürümüne uygun olmasını gerektiren bir sebep yoktur.</p>

</div2>

</div1>

<div1 id="expr">
<head>İfadeler</head>

<p>XSLT, XPath <bibref ref="XPATH"/> tarafından tanımlanmış ifade dilini kullanır. XSLT'de ifadeler aşağıdaki amaçlar dahil çeşitli amaçlarla kullanılırlar:</p>

<slist>
<sitem>İşlem için düğümlerin seçimi;</sitem>
<sitem>bir düğümü farklı yollarla işlemek için koşulların belirtilmesi;</sitem>
<sitem>hedef ağaca yerleştirilecek metnin üretilmesi.</sitem>
</slist>

<p><termdef id="dt-expression" term="İfade">Bir <term>ifade</term> bir XPath <xnt href="&XPath;#NT-Expr">İfade</xnt> sözdizimi ile eşleşmelidir.</termdef></p>

<p>İfadeler, XSLT tarafından tanımlanmış elemanların belirli özniteliklerinin değerlerinde ve <termref
def="dt-attribute-value-template">öznitelik değeri örneklenimleri</termref>nde kaşlı ayraçların arasında karşımıza çıkarlar.</p>

<p>XSLT'de bağımsız (başka bir ifadenin parçası olmayan) bir ifadenin bağlamı şöyle oluşur:</p>

<ulist>

<item><p>Bağlam düğümü <termref def="dt-current-node">geçerli düğümden</termref> gelir.</p></item>

<item><p>Bağlam konumu, <termref def="dt-current-node-list">geçerli düğüm listesi</termref>ndeki <termref
def="dt-current-node">geçerli düğüm</termref>ün konumundan gelir ve ilk konum 1'dir.</p></item>

<item><p>Bağlam boyu, <termref def="dt-current-node-list">geçerli düğüm listesinin</termref> boyutundan gelir.</p></item>

<item><p>Değişken bağıntıları, ifadeyi içeren özniteliğe sahip elemanın etki alanındaki bağıntılardır (bkz, <specref ref="variables"/>).</p></item>

<item><p>İsim-alanı bildirimleri kümesi, ifadeyi içeren özniteliğe sahip elemanın etki alanındaki bildirimlerdir; bu, XML İsim-alanları Önergesi'nce <bibref ref="XMLNAMES"/> gereken <code>xml</code> önekinin örtük bildirimini de içerir; öntanımlı isim-alanı (<code>xmlns</code> tarafından bildirilmiş olarak) bu kümenin bir parçası değildir.</p></item>

<item><p>İşlev kütüphanesi,  <xspecref href="&XPath;#corelib">temel işlev kütüphanesi</xspecref>ne ek olarak  <specref
ref="add-func"/> bölümünde tanımlanmış işlevler ile  <specref
ref="extension"/> bölümünde açıklanan ek işlevlerden oluşur; bir ifadeden bunlar dışında bir işleve çağrı bir hatadır.</p></item>

</ulist>

</div1>

<div1 id="rules">
<head>Örneklenim Kuralları</head>

<div2>
<head>İşlem Modeli</head>

<p>Bir kaynak düğümleri listesi işlendiğinde hedef ağacın bir bölümü oluşturulmuş olur. Hedef ağacı oluşturmak için kök düğümü içeren ana listeyi işlemek gerekir. Bir kaynak düğümleri listesi, ana listenin her üyesi sırayla işlenerek oluşturulan hedef ağaç yapısına eklenerek işlenir. Bir düğüm ise, düğümle eşleşen örüntülere sahip tüm örneklenim kuralları bulunarak ve bunların en uygunu seçilerek işlenir; seçilen kuralın örneklenimi, kaynak düğüm <termref def="dt-current-node">geçerli düğüm</termref> olarak, kaynak düğüm listesi <termref def="dt-current-node-list">geçerli düğüm listesi</termref> olarak ele alınarak örneklenir. Bir örneklenim genelde, işlem için ek kaynak düğümü listesini seçmekte kullanılan yönergelerden oluşur. Eşleştirme, örnekleme ve seçim işlemleri işlem için seçilecek kaynak düğümü kalmayıncaya kadar ardışık olarak sürer.</p>

<p>Gerçeklenimler, kaynak belgeyi, bu işlem modeli kullanılarak elde edilen sonucun aynısını üretecek şekilde işleyecek yöntemi seçmekte özgürdürler.</p>

</div2>

<div2 id="patterns">
<head>Örüntüler</head>

<p><termdef id="dt-pattern" term="Örüntü">Örneklenim kuralları düğümlerle bir <term>örüntü</term> aracılığıyla özdeşleşir. Örüntüler, örneklenim kurallarından başka, numaralama (<specref ref="number"/>) ve anahtar bildirimi (<specref ref="key"/>) için de kullanılırlar. Bir örüntü, bir düğüme uygulanacak koşul kümesini belirtir. Bu koşulları yerine getiren bir düğüm örüntüyle eşleşir; yerine getirmiyorsa eşleşmez. Örüntü sözdizimi, ifade sözdiziminin bir alt kümesidir. Özellikle, belli şartları sağladığı takdirde bir <xspecref href="&XPath;#location-paths">konumsal yol</xspecref> örüntü olarak kullanılabilir. Bir ifade ayrıca, daima düğüm kümesi türünde bir nesne olarak değerlendirilen bir örüntüdür. Bir düğüm, bir örüntünün belli bir bağlamla ilgili bir ifade olarak değerlendirilmesinin sonucunda elde edilen düğüm kümesinin bir üyesiyse, düğüm örüntüyle eşleşir; sözkonusu bağlam, <xtermref href="&XPath;#axis-ancestor-or-self">bu düğüm veya üstsellerinden birinin</xtermref> eşleştiği bağlamsal düğümlerdir.</termdef></p>

<p>Bazı örüntü örnekleri:</p>

<ulist>

<item><p><code>para</code> örüntüsü herhangi bir <code>para</code> elemanıyla eşleşir</p></item>

<item><p><code>*</code> örüntüsü herhangi bir elemanla eşleşir</p></item>

<item><p><code>chapter|appendix</code> örüntüsü herhangi bir <code>chapter</code> veya <code>appendix</code> elemanıyla eşleşir</p></item>

<item><p><code>olist/item</code> örüntüsü <xtermref href="&XPath;#axis-parent">ebeveyni</xtermref> <code> olist</code> olan herhangi bir <code>item</code> elemanıyla eşleşir</p></item>

<item><p><code>appendix//para</code> örüntüsü <xtermref href="&XPath;#axis-ancestor">üstseli</xtermref> <code> appendix</code> olan herhangi bir <code>para</code> elemanıyla ile eşleşir</p></item>

<item><p><code>/</code> örüntüsü sadece <xspecref href="&XPath;#root-node">kök düğümle</xspecref> eşleşir</p></item>

<item><p><code>text()</code> örüntüsü herhangi bir <xspecref href="&XPath;#text-nodes"> metin düğümü</xspecref> ile eşleşir</p></item>

<item><p><code>processing-instruction()</code> örüntüsü herhangi bir işlem yönergesi ile eşleşir</p></item>

<item><p><code>node()</code> örüntüsü bir <xspecref href="&XPath;#attr-nodes"> öznitelik düğümü</xspecref> veya kök düğüm olmayan herhangi bir düğümle eşleşir</p></item>

<item><p><code>id("W11")</code> örüntüsü <xspecref href="&XPath;#unique-id">eşsiz ID</xspecref>'si <code>W11</code> olan elemanla eşleşir</p></item>

<item><p><code>para[1]</code> örüntüsü ilk <code>para</code> çocukla eşleşir</p></item>

<item><p><code>*[position()=1 and self::para]</code> örüntüsü çocuklardan <code>para</code> türündekilerin ilkiyle eşleşir</p></item>

<item><p><code>para[last()=1]</code> örüntüsü sonuncu <code>para</code> çocukla eşleşir</p></item>

<item><p><code>items/item[position()>1]</code> örüntüsü ebeveynleri <code>items</code> olan <code>item</code> elemanlarından ilki hariç hepsiyle eşleşir</p></item>

<item><p><code>item[position() mod 2 = 1]</code> örüntüsü çift numaralı <code>item</code> çocuklarla eşleşir</p></item>

<item><p><code>div[@class="appendix"]//p</code> örüntüsü <code>appendix</code> değerli bir <code>class</code> özniteliğine sahip <code>div</code> üstseli olan herhangi bir <code>p</code> elemanıyla eşleşir</p></item>

<item><p><code>@*</code> örüntüsü herhangi bir öznitelikle eşleşir</p></item>

<item><p><code>@class</code> örüntüsü herhangi bir <code>class</code> özniteliği ile eşleşir</p></item>

<item><p><code>*[@class]</code> örüntüsü <code>class</code> özniteliğine sahip herhangi bir elemanla eşleşir</p></item>

<item><p><code>code[starts-with(normalize-space(text()), 'xsl:')]</code> örüntüsü metin düğümünün <loc href="&XPath;#function-normalize-space">normalleştirilmiş değeri</loc> <code> 'xsl:'</code> dizgesi ile başlayan herhangi bir <code>code</code> elemanıyla eşleşir (Ç.N. - Bu örüntü, bu belirtimin XML belgesini XHTML'ye dönüştürmekte <loc href="../esyntax.xsl">kullanılan örneklenimlerden birinde</loc> kullanılmıştır.)</p></item>

</ulist>

<p>Bir örüntünün <nt def="NT-Pattern">Örüntü</nt> sözdizimi ile eşleşmesi gerekir. Bir <nt def="NT-Pattern">Örüntü</nt>, <code>|</code> imleriyle ayrılmış konumsal yol örüntülerinden oluşur.  Bir konumsal yol örüntüsü, <xspecref href="&XPath;#steps">konumlarının</xspecref> her birinde <code>child</code> veya <code>attribute</code> dallarının kullanıldığı bir <xspecref href="&XPath;#location-paths">konumsal yol</xspecref>dur. <code>descendant-or-self</code> dalının kullanımının gerekli olmadığı yerlerde <code>//</code> veya <code>/</code> işleci kullanılabilir. Konumsal yol örüntüleri ayrıca, bir dizgesel sabit argümana sahip <xfunction>id</xfunction> veya <function>key</function> işlev çağrıları ile başlayabilir. Bir örüntüdeki dayanaklarda da bir konumsal yoldaki <xspecref href="&XPath;#predicates">dayanaklarda</xspecref> olduğu gibi keyfî ifadeler kullanılabilir.</p>

<scrap>
<head>Örüntüler</head>
<prodgroup pcw5="1" pcw2="10">
<prod id="NT-Pattern">
  <lhs>Örüntü</lhs>
  <rhs><nt def="NT-LocationPathPattern">KonumsalYolÖrüntüsü</nt></rhs>
  <rhs>| <nt def="NT-Pattern">Örüntü</nt> '|' <nt def="NT-LocationPathPattern">KonumsalYolÖrüntüsü</nt></rhs>
</prod>
<prod id="NT-LocationPathPattern">
  <lhs>KonumsalYolÖrüntüsü</lhs>
  <rhs>'/' <nt def="NT-RelativePathPattern">GöreliYolÖrüntüsü</nt>?</rhs>
  <rhs>| <nt def="NT-IdKeyPattern">IdKeyÖrüntüsü</nt> (('/' | '//') <nt def="NT-RelativePathPattern">GöreliYolÖrüntüsü</nt>)?</rhs>
  <rhs>| '//'? <nt def="NT-RelativePathPattern">GöreliYolÖrüntüsü</nt></rhs>
</prod>
<prod id="NT-IdKeyPattern">
  <lhs>IdKeyÖrüntüsü</lhs>
  <rhs>'id' '(' <xnt href="&XPath;#NT-Literal">DizgeselSabit</xnt> ')'</rhs>
  <rhs>| 'key' '(' <xnt href="&XPath;#NT-Literal">DizgeselSabit</xnt> ',' <xnt href="&XPath;#NT-Literal">DizgeselSabit</xnt> ')'</rhs>
</prod>
<prod id="NT-RelativePathPattern">
  <lhs>GöreliYolÖrüntüsü</lhs>
  <rhs><nt def="NT-StepPattern">KonumÖrüntüsü</nt></rhs>
  <rhs>| <nt def="NT-RelativePathPattern">GöreliYolÖrüntüsü</nt> '/' <nt def="NT-StepPattern">KonumÖrüntüsü</nt></rhs>
  <rhs>| <nt def="NT-RelativePathPattern">GöreliYolÖrüntüsü</nt> '//' <nt def="NT-StepPattern">KonumÖrüntüsü</nt></rhs>
</prod>
<prod id="NT-StepPattern">
  <lhs>KonumÖrüntüsü</lhs>
  <rhs>
  <nt def="NT-ChildOrAttributeAxisSpecifier">ÇocukVeyaÖznitelikBelirteci</nt>
  <xnt href="&XPath;#NT-NodeTest">DüğümSınaması</xnt>
  <xnt href="&XPath;#NT-Predicate">Dayanak</xnt>*</rhs>
</prod>
<prod id="NT-ChildOrAttributeAxisSpecifier">
  <lhs>ÇocukVeyaÖznitelikBelirteci</lhs>
  <rhs><xnt href="&XPath;#NT-AbbreviatedAxisSpecifier">KısaKonumBelirteci</xnt></rhs>
  <rhs>| ('child' | 'attribute') '::'</rhs>
</prod>
</prodgroup>
</scrap>

<p>Bir örüntünün bir düğümle eşleşmesi için gerek ve yeter koşul, örüntünün bir ifade olarak değerlendirildiği olası bir bağlamda, düğümün bu değerlendirme sonucunda elde edilen düğüm kümesinin bir üyesi olmasıdır. Bir düğüm eşleştiği takdirde, olası bağlamlar, bu düğümün veya bir üstselinin eşleştiği bir bağlamsal düğüme ve bu bağlamsal düğümü içeren bir bağlamsal düğüm listesine sahip bağlamlar olur.</p>

<p>Örneğin, <code>p</code> örüntüsü herhangi bir <code>p</code> elemanı ile eşleşir; <code>p</code> ifadesi, bağlamsal düğüm olarak <code>p</code>'nin ebeveyni ile değerlendirilirse, elde edilen düğüm kümesi <code>p</code> elemanını üyesi olarak içerecektir.</p>

<note><p>Bu örüntü, <code>p</code> elemanı belge elemanı olsa bile elemanla eşleşir, çünkü belge elemanının ebeveyni kök düğümdür.</p></note>

<p>Örüntülerin anlambilgisi dolaylı olarak ifade değerlendirme kuralları ile belirtiliyor olsa da, bir örüntünün ne anlam geldiğini ifade değerlendirme kurallarıyla düşünmeksizin doğrudan doğruya anlamak daha kolaydır. Bir örüntüde <code>|</code> imi seçenekleri belirtir; eğer bir örüntüde bir veya daha fazla sayıda <code>|</code> imi ile ayrılmış seçenek varsa, seçeneklerden birinin eşleşmesi halinde örüntü eşleşmiş olur.</p>

<p><code>/</code> veya <code>//</code> ayraçları ile ayrılmış çok sayıda <nt def="NT-StepPattern">KonumÖrüntüsü</nt>den oluşmuş bir örüntü sağdan sola doğru eşleşir. Örüntünün eşleşmesi için en sağdaki <nt def="NT-StepPattern">KonumÖrüntüsü</nt>nün düğümle eşleşip örüntünün kalanının da uygun bir elemanla eşleşmesi yeterlidir; uygun eleman, ayraç olarak <code>//</code> kullanılmışsa düğümün üstsellerden biri, <code>/</code> kullanılmışsa düğümün ebeveyni olacaktır.</p>

<p>Çocuk dal kullanan bir <nt def="NT-StepPattern">KonumÖrüntüsü</nt>, eğer <xnt href="&XPath;#NT-NodeTest">DüğümSınaması</xnt>nın sonucu düğüm için doğruysa ve düğüm bir öznitelik düğümü ise eşleşir.</p>

<p>İfade <code>[]</code> içerdiği takdirde, <nt def="NT-StepPattern">KonumÖrüntüsü</nt>ndeki ilk <xnt href="&XPath;#NT-PredicateExpr">Dayanakİfadesi</xnt> bağlamsal düğüm olarak düğümle ve eşleştirilecek düğüm bir öznitelik düğümü olmadıkça, <xnt href="&XPath;#NT-NodeTest">DüğümSınaması</xnt> bağlamsal düğüm listesi olarak bağlamsal düğümün kardeşleri ile eşleşecek şekilde değerlendirilir; eşleştirilecek düğüm bir öznitelik düğümü olduğu takdirde, bağlamsal düğüm listesi, tamamen, eşleşen öznitelikle aynı düğümde olan özniteliklerden oluşur ve bu <xnt href="&XPath;#NT-NameTest">AdSınaması</xnt> ile eşleşir.</p>

<p>Örneğin, bu ifadenin,</p>

<eg>appendix//ulist/item[position()=1]</eg>

<p>bir düğümle eşleşmesi için gerek ve yeter koşullar şunlardır:</p>

<ulist>

<item><p><code>item</code> <xnt href="&XPath;#NT-NodeTest"> DüğümSınaması</xnt> düğüm için doğru olmalı ve düğüm bir öznitelik olmamalıdır; başka bir deyişle düğüm bir <code>item</code> elemanı olmalıdır.</p></item>

<item><p><code>position()=1 </code><xnt href="&XPath;#NT-PredicateExpr"> Dayanakİfadesi</xnt>nin bağlamsal düğüm olarak düğümle ve bağlamsal düğüm listesi olarak düğümün <code>item</code> kardeşleriyle değerlendirilmesinin  sonucu doğru olmalıdır.</p></item>

<item><p>düğümün <code>appendix//ulist</code> ile eşleşen bir ebeveyni olmalıdır; ebeveyn, <code>appendix</code> üstsele sahip bir <code>ulist</code> elemanı ise bu doğru olacaktır.</p></item>

</ulist>

</div2>

<div2>
<head>Örneklenim Kurallarının Tanımlanması</head>

<e:element-syntax name="template">
  <e:in-category name="tepe-seviyeden-eleman"/>
  <e:attribute name="match">
    <e:data-type name="örüntü"/>
  </e:attribute>
  <e:attribute name="name">
    <e:data-type name="nitelikli-ad"/>
  </e:attribute>
  <e:attribute name="priority">
    <e:data-type name="sayı"/>
  </e:attribute>
  <e:attribute name="mode">
    <e:data-type name="nitelikli-ad"/>
  </e:attribute>
  <e:sequence>
    <e:element repeat="zero-or-more" name="param"/>
    <e:model name="örneklenim"/>
  </e:sequence>
</e:element-syntax>

<p>Bir örneklenim kuralı <code>xsl:template</code> elemanı ile belirtilir. <code>match</code> özniteliği, kuralın uygulanacağı kaynak düğüm ya da düğümleri tanımlayan bir <nt def="NT-Pattern">Örüntü</nt>dür. <code>match</code> özniteliği <code>xsl:template</code> elemanı bir <code>name</code> özniteliğine sahip olmadıkça gereklidir (<specref ref="named-templates"/> bölümüne bakınız). <code>match</code> özniteliğinin değer olarak bir <xnt href="&XPath;#NT-VariableReference">DeğişkenGönderimi</xnt> içermesi bir hatadır. <code>xsl:template</code> elemanının içeriği, örneklenim kuralı uygulandığında nesnelleşmiş olacak olan örneklenimdir.</p>

<p>Örneğin bir XML belge şunu içersin:</p>

<eg><![CDATA[Bu <emph>önemli</emph> bir noktadır.]]></eg>

<p>Aşağıdaki örneklenim kuralı <code>emph</code> elemanı ile eşleşir ve <code>font-weight</code> özniteliğinin değeri <code>bold</code> olan bir <code>fo:inline-sequence</code> biçimleme nesnesini üretir.</p>

<eg><![CDATA[<xsl:template match="emph">
  <fo:inline-sequence font-weight="bold">
    <xsl:apply-templates/>
  </fo:inline-sequence>
</xsl:template>
]]></eg>

<note><p>Bu belgedeki örneklerde, <bibref ref="XSL"/>'de tanımlanmış olan biçimleme nesnelerinin isim-alanı olan <code>&XSLFO.ns;</code> için <code>fo:</code> öneki kullanılmıştır.</p></note>

<p>Biraz sonra açıklanacağı gibi <code>xsl:apply-templates</code> elemanı kaynak elemanın çocuklarını peşpeşe işleyecektir.</p>

</div2>

<div2>
<head>Örneklenim Kurallarının Uygulanması</head>

<e:element-syntax name="apply-templates">
  <e:in-category name="yönerge"/>
  <e:attribute name="select">
    <e:data-type name="düğüm-kümesi-ifadesi"/>
  </e:attribute>
  <e:attribute name="mode">
    <e:data-type name="nitelikli-ad"/>
  </e:attribute>
  <e:choice repeat="zero-or-more">
    <e:element name="sort"/>
    <e:element name="with-param"/>
  </e:choice>
</e:element-syntax>

<p>Bu örnek bir <code>chapter</code> elemanı için bir blok oluşturup ardından çocukları işler.</p>

<eg><![CDATA[<xsl:template match="chapter">
  <fo:block>
    <xsl:apply-templates/>
  </fo:block>
</xsl:template>]]></eg>

<p><code>select</code> özniteliğinin yokluğunda <code>xsl:apply-templates</code> yönergesi geçerli düğümün tüm çocuklarını, metin düğümleri de dahil olmak üzere işler. Bununla birlikte, <specref ref="strip"/> bölümünde belirtildiği gibi ayıklanan metin düğümleri işlenmeyecektir. Eğer bir eleman için boşluk düğümlerinin ayıklanması etkin kılınmamışsa, eleman içeriğindeki bütün boşluk karakterleri metin olarak işlenecektir ve bu bakımdan <xfunction>position</xfunction> işlevi tarafından döndürülen bir çocuk elemanın yakınlık derecesi saptanırken, çocuk elemanların arasındaki boşluklar da sayılacaktır.</p>

<p><code>select</code> özniteliğinde belirtilecek bir ifadeyle, tüm çocukların değil de sadece seçilen çocukların işlenmesi sağlanabilir. <code>select</code> özniteliğinin değeri bir <termref def="dt-expression">ifade</termref>dir. İfade bir düğüm kümesiyle sonuçlanacak şekilde değerlendirilmelidir. Seçilen düğüm kümesi, bir sıralama (<specref ref="sorting"/>) belirtilmemişse  belgedeki sıraya göre işlenecektir. Aşağıdaki örnekte, <code>yazar-grubu</code>'nun tüm <code>yazar</code> çocukları işlenmektedir:</p>

<eg><![CDATA[<xsl:template match="yazar-grubu">
  <fo:inline-sequence>
    <xsl:apply-templates select="yazar"/>
  </fo:inline-sequence>
</xsl:template>]]></eg>

<p>Aşağıdaki örnekte ise, <code>yazar-grubu</code>'nun <code>yazar</code> çocuklarının tüm <code>verilen-ad</code>'ları işlenmektedir:</p>

<eg><![CDATA[<xsl:template match="yazar-grubu">
  <fo:inline-sequence>
    <xsl:apply-templates select="yazar/verilen-ad"/>
  </fo:inline-sequence>
</xsl:template>]]></eg>

<p>Bu örnekte, <code>book</code>  elemanının tüm <code>heading</code> astsalları işlenir:</p>

<eg><![CDATA[<xsl:template match="book">
  <fo:block>
    <xsl:apply-templates select=".//heading"/>
  </fo:block>
</xsl:template>]]></eg>

<p>Ayrıca, geçerli düğümün astsalı olmayan elemanları da işlemek mümkündür. Bu örnekte <code>ekip</code> çocuklara ve <code>personel</code> torunlara sahip bir <code>bölüm</code> ele alınmaktadır. Bir personelin bölümü bulunmakta ve <code>bölüm</code>'ün <code>ekip</code> çocukları işleme sokulmaktadır:</p>

<eg><![CDATA[<xsl:template match="personel">
  <fo:block>
    <xsl:apply-templates select="name"/> ismindeki çalışanımız
    <xsl:apply-templates select="ancestor::bölüm/ekip"/> ekibindedir.
  </fo:block>
</xsl:template>]]></eg>

<p>Basit bir baştan sıralama yapmak için tek bir örüntünün içinde çok sayıda <code>xsl:apply-templates</code> elemanı kullanılabilir. Aşağıdaki örnekte iki HTML tablosu oluşturulmaktadır. İlk tablo yurtiçi satışlarla, ikinci tablo yurtdışı satışlarla doldurulmaktadır.</p>

<eg><![CDATA[<xsl:template match="ürün">
  <table>
    <xsl:apply-templates select="satışlar/yurtiçi"/>
  </table>
  <table>
    <xsl:apply-templates select="satışlar/yurtdışı"/>
  </table>
</xsl:template>]]></eg>

<note>

<p>Biri diğerinin astsalı olan iki astsalla eşleşim mümkündür. Bu özel bir durum olarak ele alınmaz: her iki astsal normal olarak işlenir. Şöyle bir kaynak belgemiz olsun:</p>

<eg><![CDATA[<doc><div><div></div></div></doc>]]></eg>

<p>Bu kuralla,</p>

<eg><![CDATA[<xsl:template match="doc">
  <xsl:apply-templates select=".//div"/>
</xsl:template>]]></eg>

<p>hem dış <code>div</code> hem de iç <code>div</code> işlenecektir.</p>

</note>

<note><p>Genellikle, <code>xsl:apply-templates</code> sadece geçerli düğümün astsal düğümlerini işlemekte kullanılır. <code>xsl:apply-templates</code>'in böyle kullanımı bitmeyen işlem döngüleriyle sonuçlanamaz. Bununla birlikte, <code>xsl:apply-templates</code> geçerli düğümün astsalları olmayan elemanları işlemek için kullanıldığında bitmeyen döngülere yol açılması olasıdır. Örnek:</p>

<eg role="error"><![CDATA[<xsl:template match="foo">
  <xsl:apply-templates select="."/>
</xsl:template>]]></eg>

<p>Gerçeklenimler böyle döngüleri bazı durumlarda saptayabilir, fakat bir biçembentin bir gerçeklenimin saptayamadığı bitmeyen döngülere girme olasılığı mevcuttur. Bu bir hizmet reddi şeklinde bir güvenlik açığını yol açabilir.</p></note>

</div2>

<div2 id="conflict">
<head>Şablon Kuralları için Uyuşmazlıkların Çözümlenmesi</head>

<p>Bir kaynak düğümün birden fazla örneklenim kuralı ile eşleşmesi olasıdır.Kullanılacak örneklenim kuralı şöyle belirlenir:</p>

<olist>

<item><p>Önce tüm eşleşen kurallardan düşük <termref def="dt-import-precedence">ithal önceliği</termref>ne sahip olanlar elenir.</p></item>

<item><p>Sonra, kalan eşleşen kurallardan düşük işlem önceliğine sahip olanlar elenir. Bir örneklenim kuralının işlem önceliği o örneklenim kuralı üzerinde <code>priority</code> özniteliği ile belirtilir. Değeri bir gerçel sayı (pozitif veya negatif) olmalı ve isteğe bağlı bir eksi imi (<code>-</code>) ile öncelenmiş olarak <xnt href="&XPath;#NT-Number">Sayı</xnt> sözdizimi ile eşleşmelidir. <termdef
id="dt-default-priority" term="Öntanımlı İşlem Önceliği"><term>Öntanımlı işlem önceliği</term> şöyle hesaplanır:</termdef></p>

<ulist>

<item><p>Eğer bir örüntü <code>|</code> imleri le birbirlerinden ayrılmış çok sayıda seçenek içeriyorsa, bunların her birinin işlem önceliği bir diğerine denk ele alınır.</p></item>

<item><p>Eğer bir örüntü önüne bir <nt def="NT-ChildOrAttributeAxisSpecifier">ÇocukVeyaÖznitelikBelirteci</nt> getirilmiş bir <xnt href="&XMLNames;#NT-QName">NitelAd</xnt> ya da önüne bir <nt def="NT-ChildOrAttributeAxisSpecifier">ÇocukVeyaÖznitelikBelirteci</nt> getirilmiş <code>processing-instruction(</code><xnt href="&XPath;#NT-Literal" >DizgeselSabit</xnt><code>)</code> biçiminde ise işlem önceliği 0'dır.</p></item>

<item><p>Eğer bir örüntü önüne bir <nt def="NT-ChildOrAttributeAxisSpecifier">ÇocukVeyaÖznitelikBelirteci</nt> getirilmiş bir <xnt href="&XMLNames;#NT-NCName">KısaAd</xnt><code>:*</code> biçiminde ise işlem önceliği -0.25'tir.</p></item>

<item><p>Aksi takdirde, eğer bir örüntü önüne bir <nt def="NT-ChildOrAttributeAxisSpecifier">ÇocukVeyaÖznitelikBelirteci</nt> getirilmiş bir <xnt href="&XPath;#NT-NodeTest">DüğümSınaması</xnt> biçimindeyse işlem önceliği -0.5'tir.</p></item>

<item><p>Aksi takdirde, işlem önceliği 0.5'tir.</p></item>

</ulist>

<p>Bu bakımdan, en bilinen örüntü çeşidinin (bir düğümü belli bir tür veya  genişletilmiş isimle sınayan) işlem önceliği 0'dır. Sonraki en özel örüntü çeşidinin (bir düğümü belli bir isim-alanındaki belli bir tür veya genişletilmiş isimle sınayan) işlem önceliği -0.25'tir. Bundan daha az özel (düğümleri sadece belli bir türle sınayan) örüntülerin işlem önceliği -0.5'tir. En bilinen örüntü çeşidinden daha özel örüntülerin işlem önceliği ise 0.5'tir.</p>

</item>

</olist>

<p>Eğer bu elemeden geriye birden fazla eşleşmiş örneklenim kuralı kalıyorsa bu bir hatadır. Bir XSLT işlemci hatayı raporlayabilir; eğer raporlamıyorsa, kalanlardan biçembentte daha sonlarda yer alan örneklenim kuralını seçerek hatadan kurtulmalıdır.</p>

</div2>

<div2 id="apply-imports">
<head>Örneklenim Kurallarının Geçerli Kılınması</head>

<e:element-syntax name="apply-imports">
  <e:in-category name="yönerge"/>
  <e:empty/>
</e:element-syntax>

<p>İthal edilmiş bir biçembentteki bir örneklenim kuralını geçersiz kılmak için kullanılmış bir örneklenim kuralı (bkz, <specref ref="conflict"/>) geçersiz kılınan örneklenim kuralını <code>xsl:apply-imports</code> elemanını kullanarak çağırabilir.</p>

<p><termdef id="dt-current-template-rule" term="Geçerli Örneklenim Kuralı">Bir biçembentin işlenmesi sırasında, herhangi bir anda tek bir <term>geçerli örneklenim kuralı</term> vardır. Bir örneklenim kuralı örüntü eşleştirerek her seçilişinde, kuralın örnekleniminin nesnelleştirilmesi için geçerli örneklenim kuralı haline gelir. Bir <code>xsl:for-each</code> elemanı işleme sokulduğunda geçerli örneklenim kuralı <code>xsl:for-each</code> elemanının içeriğinin nesnelleştirilmesi için tanımsız hale gelir.</termdef></p>

<p><code>xsl:apply-imports</code> elemanı sadece, geçerli örneklenim kuralını içeren biçembente ithal edilmiş olan örneklenim kuralının kullanılarak geçerli düğümün işlenmesini sağlar; düğüm geçerli örneklenim kuralının kipinde işlenir. Geçerli örneklenim kuralı tanımsızken <code>xsl:apply-imports</code> nesnelleştirme için kullanılmaya çalışılırsa bu bir hatadır.</p>

<p>Örneğin, <code>doc.xsl</code> biçembenti <code>example</code> elemanları için şöyle bir örneklenim kuralı içeriyor olsun:</p>

<eg><![CDATA[<xsl:template match="example">
  <pre><xsl:apply-templates/></pre>
</xsl:template>]]></eg>

<p>Başka bir biçembent de <code>doc.xsl</code>'i ithal edip <code>example</code> elemanını şöyle ele alıyor olsun:</p>

<eg><![CDATA[<xsl:import href="doc.xsl"/>

<xsl:template match="example">
  <div style="border: solid red">
     <xsl:apply-imports/>
  </div>
</xsl:template>]]></eg>

<p>Dönüşümün birleşik etkisi bir <code>example</code> elemanını şu biçime getirir:</p>

<eg><![CDATA[<div style="border: solid red"><pre>...</pre></div>]]></eg>

</div2>

<div2 id="modes">
<head>Kipler</head>

<p>Kipler bir elemanın her seferinde farklı bir sonuç üretmek üzere defalarca işlenmesini mümkün kılar.</p>

<p><code>xsl:template</code> ve <code>xsl:apply-templates</code> elemanlarının ikisi de isteğe bağlı bir <code>mode</code> özniteliğine sahiptir. <code>mode</code> özniteliğinin değeri bir <xnt href="&XMLNames;#NT-QName">NitelAd</xnt> olup <specref ref="qname"/> bölümünde açıklandığı gibi yorumlanır. Eğer bir <code>xsl:template</code> elemanı bir <code>match</code> özniteliğine sahip değilse bir <code>mode</code> özniteliğine sahip olmamalıdır. Eğer bir <code>xsl:apply-templates</code> elemanı bir <code>mode</code> özniteliğine sahipse sadece kendi <code>mode</code> özniteliğinin değeriyle aynı <code>mode</code> özniteliğine sahip <code>xsl:template</code> elemanlarındaki örneklenim kuralları uygulanır; eğer bir <code>xsl:apply-templates</code> elemanı bir <code>mode</code> özniteliğine sahip değilse sadece <code>mode</code> özniteliğine sahip olmayan <code>xsl:template</code> elemanlarındaki örneklenim kuralları uygulanır.</p>

</div2>

<div2 id="built-in-rule">
<head>Yerleşik Örneklenim Kuralları</head>

<p>Biçembentte örtük bir örneklenim kuralıyla eşleşen başarılı bir örüntünün yokluğunda işlemlerin ardışık olarak sürmesini sağlayan bir yerleşik örneklenim kuralı vardır. Bu örneklenim kuralı hem eleman düğümlerine hem de kök düğüme uygulanır. Yerleşik örneklenim kuralının eşdeğeri şöyle birşey olurdu:</p>

<eg><![CDATA[<xsl:template match="*|/">
  <xsl:apply-templates/>
</xsl:template>]]></eg>

<p>Ayrıca, her kip için de benzer şekilde, biçembentte örtük bir örneklenim kuralıyla eşleşen başarılı bir örüntünün yokluğunda işlemlerin ardışık olarak sürmesini sağlayan bir yerleşik örneklenim kuralı vardır. Bu örneklenim kuralı hem eleman düğümlerine hem de kök düğüme uygulanır. Örneğin, <var>m</var> kipi için yerleşik örneklenim kuralının eşdeğeri şöyle birşey olurdu:</p>

<eg>&lt;xsl:template match="*|/" mode="<var>m</var>">
  &lt;xsl:apply-templates mode="<var>m</var>"/>
&lt;/xsl:template></eg>

<p>Ayrıca, metin ve öznitelik düğümleri için metinlerin kopyalanmasını sağlayan bir yerleşik örneklenim kuralı vardır:</p>

<eg><![CDATA[<xsl:template match="text()|@*">
  <xsl:value-of select="."/>
</xsl:template>]]></eg>

<p>İşlem yönergeleri ve açıklamalar için olan yerleşik örneklenim kuralı hiçbir şey yapmaz:</p>

<eg><![CDATA[<xsl:template match="processing-instruction()|comment()"/>]]></eg>

<p>İsim-alanı düğümleri için olan yerleşik örneklenim kuralı da hiçbir şey yapmaz. Bir isim-alanı düğümüyle eşleşen bir örüntü olmayacağı için isim-alanı düğümlerine uygulanan yegane örneklenim kuralı bu yerleşik örneklenim kuralıdır.</p>

<p>Yerleşik örneklenim kuralları biçembentten önce örtük olarak ithal edilmişler gibi ele alınırlar, dolayısıyla tüm diğer örneklenim kurallarından daha düşük <termref def="dt-import-precedence">ithal önceliği</termref>ne sahip olurlar. Bu bakımdan biçembent yazarları bir yerleşik örneklenim kuralını biçimbente açıkça bir örneklenim kuralı ekleyerek geçersiz kılabilirler.</p>

</div2>


</div1>

<div1 id="named-templates">
<head>İsimli Örneklenimler</head>

<e:element-syntax name="call-template">
  <e:in-category name="yönerge"/>
  <e:attribute name="name" required="yes">
    <e:data-type name="nitelikli-ad"/>
  </e:attribute>
  <e:element repeat="zero-or-more" name="with-param"/>
</e:element-syntax>

<p>Örneklenimler isimleriyle çağrılabilirler. Bir <code>xsl:template</code> elemanı bir <code>name</code> özniteliği ile birlikte bir isimli örneklenim belirtir. <code>name</code> özniteliğinin değeri bir <xnt href="&XMLNames;#NT-QName">NitelAd</xnt> olup <specref ref="qname"/> bölümünde açıklandığı gibi yorumlanır. Bir <code>xsl:template</code> elemanının <code>name</code> özniteliğine ek olarak bir de <code>match</code> özniteliği  olabilir ama bu gerekli değildir. <code>xsl:call-template</code> elemanı bir  örneklenimi ismiyle çağırmak için kullanılır; çağrılacak örneklenimi belirtmek için <code>name</code> özniteliğinin kullanımı zorunludur. <code>xsl:apply-templates</code> elemanının aksine, <code>xsl:call-template</code> geçerli düğümü veya geçerli düğüm listesini değiştirmez.</p>

<p>Bir <code>xsl:call-template</code> elemanı tarafından çağrıldığında <code>match</code>, <code>mode</code> ve <code>priority</code> özniteliklerinin <code>xsl:template</code> üzerinde bir etkisi yoktur. Benzer şekilde, <code>xsl:template</code> elemanı <code>xsl:apply-templates</code> elemanı tarafından çağrıldığında <code>name</code> özniteliğinin bir önemi yoktur.</p>

<p>Bir biçembentin aynı <termref def="dt-import-precedence">ithal önceliği</termref>ne sahip birden fazla aynı isimde örneklenime sahip olması bir hatadır.</p>

</div1>


<div1 id="rtree">
<head>Hedef Ağacın Oluşturulması</head>

<p>Bu bölümde hedef ağaç üzerinde düğümleri doğrudan oluşturan yönergeler açıklanmaktadır.</p>

<div2>
<head>Elemanların ve Özniteliklerin Oluşturulması</head>

<div3 id="literal-result-element">
<head>Birebir Hedef Elemanlar</head>

<p>Bir örneklenimde, XSLT isim-alanına ait olmadığı gibi bir ek eleman da (bkz, <specref ref="extension-element"/>) olmayan bir eleman aynı <xtermref href="&XPath;#dt-expanded-name">genişletilmiş isim</xtermref>le bir eleman düğümü oluşturmak üzere nesnelleştirilir. Elemanın içeriği, oluşturulan eleman düğümünün içeriğini vermek için nesnelleştiren bir örneklenimdir. Oluşturulan eleman düğümü, biçembent ağacındaki eleman düğümünde mevcut ancak isimleri XSLT isim-alanından olmayan öznitelik düğümlerine sahip olacaktır.</p>

<p>Oluşturulan eleman düğümü, ayrıca biçembent ağacındaki eleman düğümünde mevcut olan isim-alanı düğümlerinin bir kopyasına sahip olacaktır; kopyanın içinde, dizgesel değeri XSLT isim-alanı tanım-yeri (<code>&XSLT.ns;</code>), eklenti isim-alanı olarak bildirilmiş bir isim-alanı tanım-yeri (bkz, <specref ref="extension-element"/>) veya dışlanmış bir isim-alanı olarak belirtilmiş bir isim-alanı tanım-yeri olan isim-alanı düğümleri olmayacaktır. Bir isim-alanı tanım-yeri, <code>xsl:stylesheet</code> elemanının <code>exclude-result-prefixes</code> özniteliği veya birebir hedef elemanın <tt>xsl:exclude-result-prefixes</tt> özniteliği kullanılarak, dışlanmış bir isim-alanı olarak belirtilir. Bu özniteliklerin ikisinin de değeri boş karakter ayraçlı isim-alanı önekleri listesidir. Öneklerin her birine bağlı isim-alanları birer dışlanmış isim-alanı olarak belirtilmiş olur. <code>exclude-result-prefixes</code> veya <tt>xsl:exclude-result-prefixes</tt> özniteliğini taşıyan eleman üzerinde öneke bağlı bir isim-alanının olmayışı bir hatadır. Öntanımlı isim-alanı, isim-alanı önekleri listesine <code>#default</code> dizgesi dahil edilerek dışlanmış bir isim-alanı olarak belirtilebilir. Bir isim-alanının dışlanmış bir isim-alanı olarak atanması, <code>exclude-result-prefixes</code> veya <tt>xsl:exclude-result-prefixes</tt> özniteliğini taşıyan eleman biçembendin kök düğümü olmak üzere, biçembentin alt ağacı içinde etkilidir; kökü bir <code>xsl:stylesheet</code> elemanı olan bir alt ağaç, <code>xsl:stylesheet</code> elemanının çocukları tarafından içerilmiş veya ithal edilmiş bir biçembent içermez.</p>

<note><p>Bir biçembent, bir isim-alanı bildirimini sadece kaynak ağacını adreslemek amacıyla kullandığı zaman, önekin <code>exclude-result-prefixes</code> özniteliğinde belirtilmesi hedef ağaçta gereksiz isim-alanı bildirimlerini ortadan kaldıracaktır.</p></note>

<p>Bir birebir hedef elemanın bir özniteliğinin değeri bir <termref def="dt-attribute-value-template">öznitelik değeri örneklenimi</termref> olarak yorumlanır: kaşlı ayraçlar (<code>{}</code>) içinde belirtilmiş ifadeler içerir.</p>

<p><termdef id="dt-literal-namespace-uri" term="Birebir İsim-alanı Tanım-yeri">Biçembent ağacında, hedef ağaçta bir isim-alanı tanım-yeri belirtmek için kullanılan bir isim-alanı tanım-yerine <term>birebir isim-alanı tanım-yeri</term> denir.</termdef> Bu şunlara uygulanır:</p>

<ulist>

<item><p>biçembentte bir birebir hedef elemanın genişletilmiş isminde bir isim-alanı tanım-yerine,</p></item>

<item><p>biçembentte bir birebir hedef elemanında belirtilen bir özniteliğin genişletilmiş isminde bir isim-alanı tanım-yerine,</p></item>

<item><p>biçembentte bir birebir hedef elemanındaki bir isim-alanı düğümünün dizgesel değerine.</p></item>

</ulist>

<e:element-syntax name="namespace-alias">
  <e:in-category name="tepe-seviyeden-eleman"/>
  <e:attribute name="stylesheet-prefix" required="yes">
    <e:data-type name="önek"/>
    <e:constant value="#default"/>
  </e:attribute>
  <e:attribute name="result-prefix" required="yes">
    <e:data-type name="önek"/>
    <e:constant value="#default"/>
  </e:attribute>
  <e:empty/>
</e:element-syntax>

<p><termdef id="dt-alias" term="Takma ad">Bir biçembent <code>xsl:namespace-alias</code> elemanını başka bir isim-alanı tanım-yeri için <term>takma ad</term> olan bir isim-alanı tanım yerini bildirmek için kullanabilir</termdef>. Bir <termref def="dt-literal-namespace-uri">birebir isim-alanı tanım-yeri</termref> başka bir isim-alanı tanım-yeri için bir takma ad olarak bildirildiğinde, hedef ağaçtaki isim-alanı tanım-yeri, birebir isim-alanı tanım-yerinin kendisi için değil onun için bir takma ad olacağı isim-alanı tanım-yeri olacaktır. <code>xsl:namespace-alias</code> elemanı, <code>result-prefix</code> özniteliği tarafından belirtilen öneke bağlı isim-alanı tanım-yeri için bir takma ad olan <code>stylesheet-prefix</code> özniteliği tarafından belirtilen öneke bağlı isim-alanı tanım-yerini bildirir. Bu bakımdan, <code>stylesheet-prefix</code> özniteliği biçembentte görünecek isim-alanı tanım-yerini, <code>result-prefix</code> özniteliği ise hedef ağaçta görünecek diğerinin karşılığı olan isim-alanı tanım-yerini belirtir. Öntanımlı isim-alanı (<code>xmlns</code> ile bildirilen) bir önek yerine <code>#default</code> kullanılarak belirtilebilir. Eğer bir isim-alanı tanım-yeri çok sayıda isim-alanı tanım-yeri için bir takma ad olarak bildirilmişse <termref def="dt-import-precedence">ithal önceliği</termref> en yüksek bildirim kullanılır. Birden fazla böyle bildirim olması bir hatadır. Bir XSLT işlemci hatayı bildirebilir; eğer bildirmiyorsa, en yüksek ithal öncelikli bildirimler arasından biçembendin sonlarına doğru yer alan birini seçerek hatadan kurtulmalıdır.</p>

<p>Birebir hedef elemanlar XSLT isim-alanı tanım-yerini kullanan eleman, öznitelik veya isim-alanı düğümleri oluşturmak için kullanıldıklarında, biçembendin bir takma ad kullanması gerekir. Örneğin,</p>

<eg>&lt;xsl:stylesheet
  version="1.0"
  xmlns:xsl="&XSLT.ns;"
  xmlns:fo="&XSLFO.ns;"
  xmlns:axsl="&XSLTA.ns;"><![CDATA[

<xsl:namespace-alias stylesheet-prefix="axsl" result-prefix="xsl"/>

<xsl:template match="/">
  <axsl:stylesheet>
    <xsl:apply-templates/>
  </axsl:stylesheet>
</xsl:template>

<xsl:template match="block">
  <axsl:template match="{.}">
     <fo:block><axsl:apply-templates/></fo:block>
  </axsl:template>
</xsl:template>

</xsl:stylesheet>]]></eg>

<p>biçembendi aşağıdaki biçimdeki bir belgeden bir biçembent üretecektir:</p>

<eg><![CDATA[<elements>
<block>p</block>
<block>h1</block>
<block>h2</block>
<block>h3</block>
<block>h4</block>
</elements>]]></eg>

<note><p>XSLT isim-alanı tanım-yerinden başka isim-alanları için de takma adlar kullanmak gerekli olabilir. Örneğin, sayısal imzalarla iş yapılan bir isim-alanına ait olan birebir sonuç elemanlar, XSLT biçembentlerinin genel amaçlı güvenlik yazılımları tarafından kötü kullanımına sebep olabilir; isim-alanı için bir takma ad kullanımı böyle bir kötü kullanım olasılığını ortadan kaldıracaktır.</p></note>

</div3>

<div3>
<head>Elemanların <code>xsl:element</code> ile Oluşturulması</head>

<e:element-syntax name="element">
  <e:in-category name="yönerge"/>
  <e:attribute name="name" required="yes">
    <e:attribute-value-template>
      <e:data-type name="nitelikli-ad"/>
    </e:attribute-value-template>
  </e:attribute>
  <e:attribute name="namespace">
    <e:attribute-value-template>
      <e:data-type name="tanım-yeri-başvurusu"/>
    </e:attribute-value-template>
  </e:attribute>
  <e:attribute name="use-attribute-sets">
    <e:data-type name="nitelikli-adlar"/>
  </e:attribute>
  <e:model name="örneklenim"/>
</e:element-syntax>

<p><code>xsl:element</code> elemanı hesaplanmış bir isimle bir eleman oluşturmayı mümkün kılar. Oluşturulacak elemanın <xtermref href="&XPath;#dt-expanded-name">genişletilmiş ismi</xtermref>, zorunlu olan <code>name</code> ile seçimlik olan <code>namespace</code> öznitelikleri ile belirtilir. <code>xsl:element</code> elemanının içeriği oluşturulan elemanın çocukları ve öznitelikleri için bir örneklenimdir.</p>

<p><code>name</code> özniteliği bir <termref def="dt-attribute-value-template" >öznitelik değeri örneklenimi</termref> olarak yorumlanır. Öznitelik değeri örnekleniminin nesnelleştirilmesinin sonucu olan dizgenin bir <xnt href="&XMLNames;#NT-QName" >NitelAd</xnt> olmaması bir hatadır.  Bir XSLT işlemci hatayı raporlayabilir; raporlamıyorsa, <code>xsl:element</code> elemanının nesnelleştirilmesinin sonucunu, baştaki öznitelik düğümleri hariç, <code>xsl:element</code> elemanının içeriğinin nesnelleştirilmesiyle oluşturulan düğüm silsilesi yaparak hatayı ortadan kaldırmalıdır. <code>namespace</code> özniteliği kullanılmamışsa, <xnt href="&XMLNames;#NT-QName">NitelAd</xnt>, <code>xsl:element</code> elemanı için etkili olan isim-alanı bildirimleri (öntanımlı isim-alanı bildirimi dahil) kullanılarak bir genişletilmiş isme genişletilir.</p>

<p>Eğer <code>namespace</code> özniteliği kullanılmışsa, o da ayrıca bir <termref def="dt-attribute-value-template">öznitelik değeri örneklenimi</termref> olarak yorumlanır. Öznitelik değeri örnekleniminin nesnelleştirilmesinin sonucu olan dizge bir tanım-yeri başvurusu olmalıdır. Dizgenin sözdizimsel olarak geçerli bir tanım-yeri başvurusu olmaması bir hata değildir. Eğer dizge boşsa, elemanın genişletilmiş ismi tanımsız isim-alanı tanım-yerine sahip olur. Aksi takdirde, dizge, oluşturulan elemanın genişletilmiş isminin isim-alanı tanım-yeri olarak kullanılır. <xnt href="&XMLNames;#NT-QName">NitelAd</xnt>'ın yerel kısmı, oluşturulan elemanın genişletilmiş isminin yerel kısmı olarak kullanılan <code>name</code> özniteliği tarafından belirtilir.</p>

<p>XSLT işlemciler, oluşturulan elemanın XML olarak çıktılanması için kullanılan öneki seçerken, <code>name</code> özniteliğinde belirtilen <xnt
href="&XMLNames;#NT-QName">NitelAd</xnt>ın önekini kullanılır yapabilirler; yine de,bunun böyle olması gerekli değildir.</p>

</div3>

<div3 id="creating-attributes">
<head>Özniteliklerin <code>xsl:attribute</code> ile Oluşturulması</head>

<e:element-syntax name="attribute">
  <e:in-category name="yönerge"/>
  <e:attribute name="name" required="yes">
    <e:attribute-value-template>
      <e:data-type name="nitelikli-ad"/>
    </e:attribute-value-template>
  </e:attribute>
  <e:attribute name="namespace">
    <e:attribute-value-template>
      <e:data-type name="tanım-yeri-başvurusu"/>
    </e:attribute-value-template>
  </e:attribute>
  <e:model name="örneklenim"/>
</e:element-syntax>

<p><code>xsl:attribute</code> elemanı biçembentteki birebir hedef elemanlar veya <code>xsl:element</code> gibi yönergeler tarafından oluşturulan hedef elemanlara öznitelikler eklemek için kullanılır. Özniteliğin <xtermref href="&XPath;#dt-expanded-name">genişletilmiş ismi</xtermref> belirtilmesi zorunlu <code>name</code> özniteliği ile seçimlik <code>namespace</code> özniteliği tarafından oluşturulur. Bir <code>xsl:attribute</code> elemanının nesnelleştirilmesi, hedef eleman düğümüne bir öznitelik düğümü ekler. <code>xsl:attribute</code> elemanının içeriği oluşturulan özniteliğin değeri için bir örneklenimdir.</p>

<p><code>name</code> özniteliği bir <termref def="dt-attribute-value-template" >öznitelik değeri örneklenimi</termref> olarak yorumlanır. Öznitelik değeri örnekleniminin nesnelleştirilmesinin sonucu olan dizgenin bir <xnt href="&XMLNames;#NT-QName" >NitelAd</xnt> olmaması veya <code>xmlns</code> dizgesi olması bir hatadır. Bir XSLT işlemci hatayı raporlayabilir; raporlamıyorsa, özniteliği hedef ağaca eklemeyerek hatayı ortadan kaldırmalıdır. <code>namespace</code> özniteliği kullanılmamışsa, <xnt href="&XMLNames;#NT-QName">NitelAd</xnt>, <code>xsl:attribute</code> elemanı için etkili olan isim-alanı bildirimleri (öntanımlı isim-alanı bildirimi hariç) kullanılarak bir genişletilmiş isme genişletilir.</p>

<p>Eğer <code>namespace</code> özniteliği kullanılmışsa, o da ayrıca bir <termref def="dt-attribute-value-template">öznitelik değeri örneklenimi</termref> olarak yorumlanır. Öznitelik değeri örnekleniminin nesnelleştirilmesinin sonucu olan dizge bir tanım-yeri başvurusu olmalıdır. Dizgenin sözdizimsel olarak geçerli bir tanım-yeri başvurusu olmaması bir hata değildir. Eğer dizge boşsa, özniteliğin genişletilmiş ismi tanımsız isim-alanı tanım-yerine sahip olur. Aksi takdirde, dizge, oluşturulan özniteliğin genişletilmiş isminin isim-alanı tanım-yeri olarak kullanılır. <xnt href="&XMLNames;#NT-QName">NitelAd</xnt>'ın yerel kısmı, oluşturulan özniteliğin genişletilmiş isminin yerel kısmı olarak kullanılan <code>name</code> özniteliği tarafından belirtilir.</p>

<p>XSLT işlemciler, oluşturulan özniteliğin XML olarak çıktılanması için kullanılan öneki seçerken, <code>name</code> özniteliğinde belirtilen <xnt
href="&XMLNames;#NT-QName">NitelAd</xnt>ın önekini kullanılır yapabilirler; yine de,bunun böyle olması gerekli değildir. Bu bakımdan,</p>

<eg>&lt;xsl:attribute name="xmlns:xsl" namespace="herneyse">
  &XSLT.ns;
&lt;/xsl:attribute></eg>

<p>hatalı olmasa da, bu işlem çıktıda bir isim-alanı bildirimi ile sonuçlanmayacaktır.</p>

<p>Bir özniteliğin bir elemana eklenmesi elemanın mevcut özniteliklerinden  genişletilmiş ismi aynı olanını değiştirir.</p>

<p>Aşağıdakilerin hepsi hata ile sonuçlanır:</p>

<ulist>

<item><p>Bir elemana çocukları eklendikten sonra bir özniteliğin eklenmesi; gerçeklenimler bu hatayı bildirebilir ya da özniteliği yoksayabilirler.</p></item>

<item><p>Bir özniteliğin bir eleman olmayan bir düğüme eklenmesi; gerçeklenimler bu hatayı bildirebilir ya da özniteliği yoksayabilirler.</p></item>

<item><p><code>xsl:attribute</code> elemanının nesnelleştirilmesi sırasında metin düğümlerinden farklı düğümlerin oluşturulması; gerçeklenimler bu hatayı bildirebilir ya da hatalı düğümleri içerikleriyle birlikte yoksayabilirler.</p></item>

</ulist>

<note><p>Bir <code>xsl:attribute</code> elemanı satırsonu içeren bir metin düğümü içeriyorsa, XML çıktının bir karakter gönderimi içermesi gerekir. Örneğin,</p>

<eg><![CDATA[<xsl:attribute name="a">x
y</xsl:attribute>]]></eg>

<p>kodu şu çıktıyı üretecektir:</p>

<eg><![CDATA[a="x&#xA;y"]]></eg>

<p>(veya eşdeğeri bir karakter gönderimi ile). XML çıktı asla şöyle olamaz:</p>

<eg><![CDATA[a="x
y"]]></eg>

<p>XML 1.0'ın öznitelik değerlerindeki satırsonu karakterlerini boşluk olarak normalleştirmesi fakat satır sonu karakterlerine yapılan gönderimleri normalleştirmemesi sebebiyle bu böyledir. Veri modelindeki öznitelik değerleri normalleştirme sonrası öznitelik değerleri olarak gösterilir. Eğer bir satırsonu karakteri çıktılanan ağaçtaki bir öznitelik değerinde bir karakter gönderimi olarak değilde kendisi olarak yer alıyorsa, ağaçtaki öznitelik değeri bir satırsonu değil de bir boşluk içerecek şekilde XML'in yeniden çözümlenerek ağacın doğru olarak çıktılanması gerekir.</p></note>

</div3>

<div3 id="attribute-sets">

<head>İsimli Öznitelik Kümeleri</head>

<e:element-syntax name="attribute-set">
  <e:in-category name="tepe-seviyeden-eleman"/>
  <e:attribute name="name" required="yes">
    <e:data-type name="nitelikli-ad"/>
  </e:attribute>
  <e:attribute name="use-attribute-sets">
    <e:data-type name="nitelikli-adlar"/>
  </e:attribute>
  <e:element repeat="zero-or-more" name="attribute"/>
</e:element-syntax>

<p><code>xsl:attribute-set</code> elemanı bir isimli öznitelik kümesi tanımlar. <code>name</code> özniteliği öznitelik kümesinin ismini belirtir. <code>name</code> özniteliğinin değeri bir <xnt href="&XMLNames;#NT-QName">NitelAd</xnt> olup <specref ref="qname"/> bölümünde açıklandığı gibi yorumlanır. <code>xsl:attribute-set</code> elemanının içeriği kümedeki öznitelikleri belirten sıfır veya daha fazla sayıda <code>xsl:attribute</code> elemanından oluşur.</p>

<p>Öznitelik kümeleri, bir <code>xsl:element</code>, <code>xsl:copy</code> (bkz, <specref ref="copying"/>) veya <code>xsl:attribute-set</code> elemanının <code>use-attribute-sets</code> özniteliğinde belirtilerek kullanılırlar. <code>use-attribute-sets</code> özniteliğinin değeri öznitelik kümesi isimlerinin boşluk ayraçlı listesidir. Belirtilen her isim, <specref ref="qname"/> bölümünde açıklandığı gibi yorumlanan birer <xnt href="&XMLNames;#NT-QName">NitelAd</xnt> olarak belirtilir. Bir <code>use-attribute-sets</code> özniteliğinin belirtilmesi, özniteliğe sahip elemanın içeriğinin başlangıcında isimli öznitelik kümelerinin her birindeki özniteliklerin her biri için (<code>use-attribute-sets</code> özniteliğinde belirtilen öznitelik isimleriyle aynı sırada) bir <code>xsl:attribute</code> elemanı belirtilmesine eşdeğerdir. <code>use-attribute-sets</code> özniteliklerinin <code>xsl:attribute-set</code> elemanlarında doğrudan veya dolaylı olarak kendilerini öznitelik kümesi olarak kullanmaları bir hatadır.</p>

<p>Öznitelik kümeleri ayrıca bir birebir hedef elemanda da bir <tt>xsl:use-attribute-sets</tt> özniteliği belirterek kullanılabilir. <tt>xsl:use-attribute-sets</tt> özniteliğinin değeri öznitelik kümesi isimlerinin boşluk ayraçlı bir listesidir. <tt>xsl:use-attribute-sets</tt> özniteliği tarafından belirtilen <code>xsl:attribute</code> elemanlarından sonra ama asıl <code>xsl:attribute</code> elemanlarından önce yer alan <code>xsl:attribute</code> elemanları tarafından belirtilmiş gibi ele alınan birebir hedef elemanın kendi üzerindeki öznitelikler tarafından belirtilen ek kurallarla birlikte <code>xsl:element</code> üzerindeki <code>use-attribute-sets</code> özniteliği ile <tt>xsl:use-attribute-sets</tt> özniteliği aynı etkiye sahiptir. Bu bakımdan, bir birebir hedef eleman için, bir <tt>xsl:use-attribute-sets</tt> özniteliğinde isimleri bulunan öznitelik kümelerindeki öznitelikler önce (ama kümelerin listede yer alış sırasına uygun olarak) eklenecektir; ardından birebir hedef elemanda belirtilen öznitelikler eklenecek; son olarak da, <code>xsl:attribute</code> elemanları tarafından belirtilen öznitelikler eklenecektir. Bir özniteliğin bir elemana eklenmesi, bu elemanın aynı isimdeki mevcut özniteliğini değiştirdiğinden, bu, öznitelik kümelerinde belirtilen öznitelikler, birebir hedef elemanın kendisinde belirtilen öznitelikler tarafından geçersiz kılınabilirler anlamına gelir.</p>

<p>Bir <code>xsl:attribute-set</code> elemanınındaki  <code>xsl:attribute</code> elemanlarının her birindeki örneklenimler, öznitelik kümesinin her kullanılışında yeniden nesnelleştirilir; nesnelleştirme, aynı geçerli düğüm ve geçerli düğüm listesi kullanılarak, nesnelleştirme için <code>use-attribute-sets</code> veya <tt>xsl:use-attribute-sets</tt> özniteliğini taşıyan eleman kullanılıyormuş gibi yapılır. Bununla birlikte, hangi değişken bağıntısının görünür (bkz, <specref ref="variables"/>) olduğunu belirleyen <code>use-attribute-sets</code> veya <tt>xsl:use-attribute-sets</tt> özniteliğini taşıyan elemandan ziyade biçembentteki <code>xsl:attribute</code> elemanının konumudur; bu bakımdan, sadece <termref
def="dt-top-level">tepe-seviyeden</termref> <code>xsl:variable</code> ve
<code>xsl:param</code> elemanları ile bildirilen değişken ve değergeçler görünürdür.</p>

<p>Aşağıdaki örnekte <code>title-style</code> isimli bir öznitelik kümesi oluşturulmakta ve bir örneklenim kuralında kullanılmaktadır:</p>

<eg><![CDATA[<xsl:template match="chapter/heading">
  <fo:block quadding="start" xsl:use-attribute-sets="title-style">
    <xsl:apply-templates/>
  </fo:block>
</xsl:template>

<xsl:attribute-set name="title-style">
  <xsl:attribute name="font-size">12pt</xsl:attribute>
  <xsl:attribute name="font-weight">bold</xsl:attribute>
</xsl:attribute-set>]]></eg>

<p>Bir özniteliğin aynı genişletilmiş isimle çok sayıda tanımı varsa bunlar birleştirilir. Yüksek <termref def="dt-import-precedence">ithal önceliği</termref>ne sahip bir öznitelik, düşük <termref def="dt-import-precedence">ithal önceliği</termref>ndeki bir özniteliğe göre önceliklidir. Aynı genişletilmiş isimle aynı özniteliği içeren iki öznitelik kümesinin, aynı genişletilmiş isim ve aynı öznitelikle daha yüksek <termref def="dt-import-precedence">ithal öncelikli</termref> bir üçüncünün yokluğunda aynı ithal önceliğine sahip olması bir hatadır. Bir XSLT işlemci bu hatayı raporlayabilir; raporlamıyorsa, biçembentin sonuna doğru yer alan tanımlar arasından daha yüksek işlem önceliğine sahip olanını seçerek hatayı ortadan kaldırabilir. Bir öznitelik kümesinde belirtilen özniteliklerin yeri kümedeki öznitelikler bir birleşmeye konu olduklarında önem kazanır; öznitelik kümeleri kullanılırken bunun bir önemi yoktur. Bir <code>xsl:attribute-set</code> elemanının <code>use-attribute-sets</code> özniteliğinde yer alan her öznitelik kümesi ismi için, aynı isimdeki bir öznitelik kümesinin bütün tanımlarının, <code>use-attribute-sets</code> özniteliği, eşdeğeri olan <code>xsl:attribute</code> çocuk elemanlarıyla değiştirilmeden önce birleştirilmesi gerekir. Bir <code>xsl:attribute-set</code> elemanının <code>use-attribute-sets</code> özniteliğinin eşdeğeri olan <code>xsl:attribute</code> çocuk elemanlarıyla, bu <code>xsl:attribute-set</code> elemanı, aynı genişletilmiş isimli başka bir <code>xsl:attribute-set</code> elemanı ile birleştirilmeden önce değiştirilmesi gerekir. <code>xsl:attribute-set</code>  elemanları aynı genişletilmiş isimli olanlarla birleştirildiğinde, bir <code>use-attribute-sets</code> özniteliğine değiştirilmek için eklenen her <code>xsl:attribute</code> çocuk elemanı, biçembentte gerçekten bir çocuk eleman olarak belirtilmiş gibi ele alınır.</p>

</div3>

</div2>

<div2>

<head>Metin Oluşturma</head>

<p>Bir örneklenim ayrıca metin düğümleri de içerebilir. Bir örneklenimdeki her metin düğümünün boşluk karakterleri <specref ref="strip"/> bölümünde belirtildiği gibi ayıklandıktan sonra kalan dizgeyle hedef ağaçtaki metin düğümü oluşturulur. Bitişik metin düğümleri hedef ağaçta kendiliğinden birleşir.</p>

<p>Metnin ağaç seviyesinde işlendiğine dikkat ediniz. Bu bakımdan, bir örneklenimdeki <code>&amp;lt;</code> imlenimi biçembent ağacında <code>&lt;</code> karakterini içeren bir metin düğümüyle gösterilecektir. Bu, hedef ağaç bir XML belge olarak çıktılandığında,  hedef ağaçta (<code>&amp;lt;</code> imlenimi -veya eşdeğeri karakter gönderimi- ile gösterilecek olan) <code>&lt;</code> karakterini içeren bir metin düğümü oluşturacaktır (<specref ref="disable-output-escaping"/> bölümünde belirtildiği gibi çıktı öncelenimi iptal edilmiş olmadıkça).</p>

<e:element-syntax name="text">
  <e:in-category name="yönerge"/>
  <e:attribute name="disable-output-escaping">
    <e:constant value="yes"/>
    <e:constant value="no"/>
  </e:attribute>
  <e:text/>
</e:element-syntax>

<p>Dizgesel sabit veri karakterleri bir <code>xsl:text</code> elemanında satır katlamaya konu olabilir. Satır katlama, boşluk karakterleri ayıklanarak (bkz, <specref ref="strip"/>) değiştirilebilir fakat karakterlerin XSLT işlemci tarafından sonradan nasıl elde edileceğine bir etkisi yoktur.</p>

<note><p><code>xml:lang</code> ve <code>xml:space</code> öznitelikleri XSLT tarafından özel olarak ele alınmaz. Özellikle,</p>

<ulist>
<item><p>hedefte, <code>xml:lang</code> veya <code>xml:space</code> özniteliklerinin üretmesi gerekeni belirtmek doğrudan doğruya biçembent yazarının sorumluluğundadır;</p></item>

<item><p>XSLT isim-alanındaki bir elemanda <code>xml:lang</code> veya <code>xml:space</code> özniteliğinin belirtilmesi bu özniteliklerin hedefte de yer almasına sebep olmayacaktır.</p></item>
</ulist>
</note>

</div2>


<div2>
<head>İşlem Yönergelerinin Oluşturulması</head>


<e:element-syntax name="processing-instruction">
  <e:in-category name="yönerge"/>
  <e:attribute name="name" required="yes">
    <e:attribute-value-template>
      <e:data-type name="kısa-ad"/>
    </e:attribute-value-template>
  </e:attribute>
  <e:model name="örneklenim"/>
</e:element-syntax>

<p><code>xsl:processing-instruction</code> elemanı, bir işlem yönergesi düğümü oluşturmak için nesnelleştirilir. <code>xsl:processing-instruction</code> elemanının içeriği işlem yönergesi düğümünün dizgesel değeri için bir örneklenimdir. <code>xsl:processing-instruction</code> elemanının, işlem yönergesi düğümünün ismini belirtmek için kullanımı zorunlu olan bir <code>name</code> özniteliği vardır. <code>name</code> özniteliğinin değeri bir <termref def="dt-attribute-value-template">öznitelik değeri örneklenimi</termref> olarak yorumlanır.</p>

<p>Örneğin, bu:</p>

<eg><![CDATA[<xsl:processing-instruction name="xml-stylesheet">
  href="book.css" type="text/css"
</xsl:processing-instruction>]]></eg>

<p>şu işlem yönergesini oluşturacaktır:</p>

<eg><![CDATA[<?xml-stylesheet href="book.css" type="text/css"?>]]></eg>

<p><code>name</code> özniteliğinin nesnelleştirilmesinin sonucu olan dizgenin hem bir <xnt href="&XMLNames;#NT-NCName">KısaAd</xnt> hem de bir <xnt href="&XML;#NT-PITarget">PIHedefi</xnt> olmaması bir hatadır. Bir XSLT işlemci bu hatayı raporlayabilir; raporlamıyorsa, işlem yönergesini hedef ağaca ekleyerek hatayı ortadan kaldırabilir.</p>

<note><p>Bu, <code>xsl:processing-instruction</code> elemanının bir XML bildirimi çıktılamakta kullanılamaması demektir. Yerine <code>xsl:output</code> elemanı kullanılmalıdır (bkz, <specref
ref="output"/>).</p></note>

<p><code>xsl:processing-instruction</code> içeriğinin nesnelleştirilmesinin metin düğümünden farklı bir düğüm oluşturması bir hatadır. Bir XSLT işlemci bu hatayı raporlayabilir; raporlamıyorsa, hatalı düğümleri içerikleriyle birlikte yoksayarak hatayı ortadan kaldırabilir.</p>

<p><code>xsl:processing-instruction</code> içeriğinin nesnelleştirilme sonucunun <code>?&gt;</code> dizgesini içermesi bir hatadır. Bir XSLT işlemci bu hatayı raporlayabilir; raporlamıyorsa, <code>?</code> karakteri ile <code>&gt;</code> karakteri arasına bir boşluk yerleştirerek hatayı ortadan kaldırabilir.</p>

</div2>

<div2>
<head>Açıklamaların Oluşturulması</head>

<e:element-syntax name="comment">
  <e:in-category name="yönerge"/>
  <e:model name="örneklenim"/>
</e:element-syntax>

<p><code>xsl:comment</code> elemanı hedef ağaçta bir açıklama oluşturmak için nesnelleştirilir. <code>xsl:comment</code> elemanının içeriği, açıklama düğümünün dizgesel değeri için bir örneklenimdir.</p>

<p>Örneğin, bu:</p>

<eg><![CDATA[<xsl:comment>This file is automatically generated. Do not edit!</xsl:comment>]]></eg>

<p>şu açıklamayı üretecektir:</p>

<eg><![CDATA[<!--This file is automatically generated. Do not edit!-->]]></eg>

<p><code>xsl:comment</code> içeriğinin nesnelleştirilmesinin metin düğümünden farklı bir düğüm oluşturması bir hatadır. Bir XSLT işlemci bu hatayı raporlayabilir; raporlamıyorsa, hatalı düğümleri içerikleriyle birlikte yoksayarak hatayı ortadan kaldırabilir.</p>

<p><code>xsl:comment</code> içeriğinin nesnelleştirilme sonucunun <code>--</code> dizgesini içermesi bir hatadır. Bir XSLT işlemci bu hatayı raporlayabilir; raporlamıyorsa, <code>-</code> karakterlerinin arasına bir boşluk yerleştirerek hatayı ortadan kaldırabilir.</p>

</div2>

<div2 id="copying">
<head>Kopyalama</head>

<e:element-syntax name="copy">
  <e:in-category name="yönerge"/>
  <e:attribute name="use-attribute-sets">
    <e:data-type name="nitelikli-adlar"/>
  </e:attribute>
  <e:model name="örneklenim"/>
</e:element-syntax>

<p><code>xsl:copy</code> elemanı, geçerli düğümün kopyalanmasını kolaylaştıran bir yol sağlar. <code>xsl:copy</code> elemanının nesnelleştirilmesi, geçerli düğümün bir kopyasını oluşturur. Geçerli düğümün isim-alanı düğümleri de kendiliğinden kopyalanır, fakat öznitelikler ve düğümün çocukları kendiliklerinden kopyalanmazlar. <code>xsl:copy</code> elemanının içeriği, oluşturulan düğümün öznitelikleri ve çocukları için bir örneklenimdir; içerik sadece özniteliklerin ve çocukların sahip olabileceği türdeki düğümler için nesnelleştirilir (örn, kök düğüm ve eleman düğümleri için).</p>

<p><code>xsl:copy</code> elemanı bir <code>use-attribute-sets</code> özniteliğine sahip olabilir (bkz, <specref
ref="attribute-sets"/>). Bu sadece eleman düğümleri kopyalanırken kullanılır.</p>

<p>Kök düğüm özel olarak ele alınır, çünkü hedef ağacın kök düğümü örtük olarak oluşturulur. Geçerli düğüm, kök düğüm olduğu takdirde, <code>xsl:copy</code> bir kök düğüm oluşturmayacak, sadece içerik örneklenimini kullanacaktır.</p>

<p>Örneğin, özdeşlik dönüşümü <code>xsl:copy</code> kullanılarak şöyle yazılabilir:</p>

<eg><![CDATA[<xsl:template match="@*|node()">
  <xsl:copy>
    <xsl:apply-templates select="@*|node()"/>
  </xsl:copy>
</xsl:template>]]></eg>

<p>Geçerli düğüm bir öznitelik olduğunda, geçerli düğümle aynı isimde bir öznitelik oluşturmak için <code>xsl:attribute</code> kullanmak bir hata olsaydı, <code>xsl:copy</code> kullanmak da bir hata olurdu  (bkz, <specref ref="creating-attributes"/>).</p>

<p>Aşağıdaki örnekte, <code>xml:lang</code> özniteliklerinin nasıl kolayca kaynaktan hedefe kopyalanabileceği gösterilmiştir. Bir biçembent şöyle bir isimli örneklenim tanımlasaydı:</p>

<eg><![CDATA[<xsl:template name="apply-templates-copy-lang">
 <xsl:for-each select="@xml:lang">
   <xsl:copy/>
 </xsl:for-each>
 <xsl:apply-templates/>
</xsl:template>]]></eg>

<p><code>xml:lang</code> özniteliği kopyalanmak istendiği takdirde, bunun yerine:</p>

<eg><![CDATA[<xsl:apply-templates/>]]></eg>

<p>bu daha basit olurdu:</p>

<eg><![CDATA[<xsl:call-template name="apply-templates-copy-lang"/>]]></eg>

<p>Geçerli düğüm bir isim-alanı düğümü olduğu takdirde, kopyalama işlemi, hedef ağaçta içerilen düğüme bir isim-alanı düğümü ekler. Bunun içerildiği düğümün bir eleman olmaması bir hatadır; gerçeklenimler hatayı raporlayabilir veya isim-alanı düğümünü yoksayabilir. Bir isim-alanı düğümünü bir elemana çocuklarını veya özniteliklerini eklendikten sonra eklemek bir hatadır; gerçeklenimler hatayı raporlayabilir veya isim-alanı düğümünü yoksayabilir. Bir isim-alanı düğümünü, aynı isimde bir isim-alanına zaten sahip olan bir elemana eklemek, her iki isim-alanı düğümü aynı <xtermref href="&XPath;#dt-string-value">dizgesel değer</xtermref>e sahip olmadıkça (bu durumda yineleme yok sayılır), bir hatadır. Bir isim-alanı düğümünü bir elemana eklemek, eğer isim-alanı düğümünün ismi tanımsızsa ve eleman bir tanımsız isim-alanı tanım-yerine sahipse, bir hatadır.</p>

</div2>

<div2>
<head>Üretilen Metnin Hesaplanması</head>

<p>Bir örneklenim içinde, <code>xsl:value-of</code> elemanı üretilen metni hesaplamakta kullanılabilir; örneğin, metni kaynak ağaçtan çekip çıkarmak veya bir değişkene bir değer yerleştirmek için kullanılabilir. <code>xsl:value-of</code> elemanı bunu, <code>select</code> özniteliğine değer olarak belirtilen bir <termref def="dt-expression">ifade</termref> ile yapar. İfadeler ayrıca, birebir hedef elemanların öznitelikleri içinde kaşlı ayraçlarla (<code>{}</code>) sarmalanarak kullanılabilir.</p>

<div3 id="value-of">
<head>Metnin <code>xsl:value-of</code> ile Üretilmesi</head>

<e:element-syntax name="value-of">
  <e:in-category name="yönerge"/>
  <e:attribute name="select" required="yes">
    <e:data-type name="dizgesel-ifade"/>
  </e:attribute>
  <e:attribute name="disable-output-escaping">
    <e:constant value="yes"/>
    <e:constant value="no"/>
  </e:attribute>
  <e:empty/>
</e:element-syntax>

<p><code>xsl:value-of</code> elemanı hedef ağaçta bir metin düğümü oluşturmak için nesnelleştirilir. Belirtilmesi zorunlu olan <code>select</code> özniteliği bir ifade olup değerlendirilmesiyle elde edilen nesne <xfunction>string</xfunction> işlevi çağrılmış gibi bir dizgeye dönüştürülür. Bu dizge oluşturulan metin düğümünün dizgesel değerini belirtir. Dizge boşsa bir metin düğümü oluşturulmaz. Oluşturulan metin düğümü bitişik metin düğümü komşuları ile birleşir.</p>

<p><code>xsl:copy-of</code> elemanı bir düğüm kümesini bir dizgeye dönüştürmeksizin hedef ağaca kopyalamak için kullanılabilir. Daha fazla bilgi için <specref ref="copy-of"/> bölümüne bakınız.</p>

<p>Aşağıdaki örnekte, <code>adı</code> ve <code>soyadı</code> özniteliklerine sahip <code>kişi</code> elemanından bir HTML paragrafı oluşturulmaktadır. Paragraf geçerli düğümün <code>adı</code> ve <code>soyadı</code> özniteliklerinin değerleri arasında bir boşluk karakteri içerecektir.</p>

<eg><![CDATA[<xsl:template match="kişi">
  <p>
   <xsl:value-of select="@adı"/>
   <xsl:text> </xsl:text>
   <xsl:value-of select="@soyadı"/>
  </p>
</xsl:template>]]></eg>

<p>Başka bir örnek olarak aşağıda aynı paragraf <code>kişi</code> elemanının <code>adı</code> ve <code>soyadı</code> çocuk elemanlarının dizgesel değerleri ile oluşturulmaktadır.</p>

<eg><![CDATA[<xsl:template match="kişi">
  <p>
   <xsl:value-of select="adı"/>
   <xsl:text> </xsl:text>
   <xsl:value-of select="soyadı"/>
  </p>
</xsl:template>]]></eg>

<p>Aşağıdaki örnekte, her <code>işlem</code> elemanı için metnin başına işlemin güvenlik seviyesini belirten bir paragraf yerleştirilmektedir. Burada, işleme uygulanacak güvenlik seviyesinin <code>işlem</code> elemanının kendisindeki veya bir üstselindeki <code>güvenlik</code> özniteliğinden elde edildiği kabul edilmektedir. Eğer birden fazla <code>güvenlik</code> özniteliği belirtilmişse işleme en yakın elemanın <code>güvenlik</code> özniteliğinin değeri kullanılmaktadır.</p>

<eg><![CDATA[<xsl:template match="işlem">
  <fo:block>
    <xsl:value-of select="ancestor-or-self::*[@güvenlik][1]/@güvenlik"/>
  </fo:block>
  <xsl:apply-templates/>
</xsl:template>]]></eg>

</div3>

<div3 id="attribute-value-templates">
<head>Öznitelik Değeri Örneklenimleri</head>

<p><termdef id="dt-attribute-value-template" term="Öznitelik Değeri Örneklenimi">Bir <term>öznitelik değeri örneklenimi</term> olarak yorumlanan bir öznitelik değerinde, örneğin, bir birebir hedef elemanın bir özniteliğinin değeri olarak, bir <termref def="dt-expression">ifade</termref> kaşlı ayraçlar (<code>{}</code>) arasında kullanılabilir</termdef>. Öznitelik değeri örneklenimi, kaşlı ayraçlarla birlikte ifadenin yerine, ifadenin değerlendirilme sonucunun <xfunction>string</xfunction> işlevi çağrılmış gibi bir dizgeye dönüştürülmesiyle elde edilen dizge yerleştirilerek nesnelleştirilir. Bir XSLT biçembendinde bir öznitelik değerindeki kaşlı ayraçların, öznitelik özellikle, bir öznitelik değeri örneklenimi olarak yorumlanan bir öznitelik olmadıkça özel bir anlamı yoktur; eleman sözdizimi özetinde, böyle özniteliklerin değeri kaşlı ayraçlarla sarmalanır.</p>

<note><p>Tüm öznitelikler birer öznitelik değeri örneklenimi olarak yorumlanmaz. Değeri bir ifade veya örüntü olan öznitelikler, <termref def="dt-top-level">tepe-seviyeden</termref> elemanların öznitelikleri ve isimli XSLT nesnelerine atıfta bulunan öznitelikler öznitelik değeri örneklenimi olarak yorumlanmaz. Ek olarak, <code>xmlns</code> öznitelikleri de öznitelik değeri örneklenimi olarak yorumlanmaz;  çünkü yorumlansaydı XML İsim-alanları Önergesi ile uyumluluk sağlanamazdı.</p></note>

<p>Aşağıdaki örnekte, kaynak içeriğindeki  <code>photograph</code> elemanından bir <code>img</code> hedef elemanı oluşturulmaktadır; <code>img</code> elemanının <code>src</code> özniteliğinin değeri <code>image-dir</code> değişkeninin değerinden ve <code>photograph</code> elemanının <code>href</code> çocuğunun dizgesel değerinden hesaplanmakta; <code>width</code> özniteliğinin değeri ise, <code>photograph</code> elemanının <code>size</code> çocuğunun <code>width</code> özniteliğinin değerinden hesaplanmaktadır:</p>

<eg><![CDATA[<xsl:variable name="image-dir">/images</xsl:variable>

<xsl:template match="photograph">
<img src="{$image-dir}/{href}" width="{size/@width}"/>
</xsl:template>]]></eg>

<p>biçembendi ile</p>

<eg><![CDATA[<photograph>
  <href>headquarters.jpg</href>
  <size width="300"/>
</photograph>]]></eg>

<p>kaynak içeriğinden hedef ağaçta</p>

<eg><![CDATA[<img src="/images/headquarters.jpg" width="300"/>]]></eg>

<p>düğümü elde edilmektedir.</p>
<p>Bir öznitelik değeri örneklenimi nesnelleştirildiğinde, ifadeyi sarmalayan kaşlı ayraçlar çifter çifter ise bunlar birer kaşlı ayraç olarak ele alınır. Bir öznitelik değeri örnekleniminin ifadesi içinde bir kapatan kaşlı ayracın yer alıp, ifadenin dışında kapatan kaşlı ayracın bulunmaması bir hatadır. Bir ifadedeki bir <xnt href="&XPath;#NT-Literal">DizgeselSabit</xnt> içinde yer alan bir kapatan kaşlı ayraç ifadeyi sonlandıran kaşlı ayraç olarak ele alınmaz.</p>

<p>İfadelerin içindeki kaşlı ayraçlar tanınmazlar. Örneğin, buna</p>

<eg role="error"><![CDATA[<a href="#{id({@ref})/title}">]]></eg>

<p>izin verilmez. Yerine bunu kullanın:</p>

<eg><![CDATA[<a href="#{id(@ref)/title}">]]></eg>

</div3>

</div2>

<div2 id="number">
<head>Numaralama</head>

<e:element-syntax name="number">
  <e:in-category name="yönerge"/>
  <e:attribute name="level">
    <e:constant value="single"/>
    <e:constant value="multiple"/>
    <e:constant value="any"/>
  </e:attribute>
  <e:attribute name="count">
    <e:data-type name="örüntü"/>
  </e:attribute>
  <e:attribute name="from">
    <e:data-type name="örüntü"/>
  </e:attribute>
  <e:attribute name="value">
    <e:data-type name="sayısal-ifade"/>
  </e:attribute>
  <e:attribute name="format">
    <e:attribute-value-template>
      <e:data-type name="dizge"/>
    </e:attribute-value-template>
  </e:attribute>
  <e:attribute name="lang">
    <e:attribute-value-template>
      <e:data-type name="ad-dizgeciği"/>
    </e:attribute-value-template>
  </e:attribute>
  <e:attribute name="letter-value">
    <e:attribute-value-template>
      <e:constant value="alphabetic"/>
      <e:constant value="traditional"/>
    </e:attribute-value-template>
  </e:attribute>
  <e:attribute name="grouping-separator">
    <e:attribute-value-template>
      <e:data-type name="karakter"/>
    </e:attribute-value-template>
  </e:attribute>
  <e:attribute name="grouping-size">
    <e:attribute-value-template>
      <e:data-type name="sayı"/>
    </e:attribute-value-template>
  </e:attribute>
  <e:empty/>
</e:element-syntax>

<p><code>xsl:number</code> elemanı hedef ağaca biçimli bir numara yerleştirmek için kullanılır. Yerleştirilecek numara bir ifade tarafından belirtilir. Bu <termref def="dt-expression">ifade</termref>yi <code>value</code> özniteliği içerir. İfadenin değerlendirilmesinin sonucu olan nesne <xfunction>number</xfunction> işlevi çağrılmış gibi bir sayıya dönüştürülür. Sayının NaN, sonsuz veya 0.5'ten küçük olması bir hatadır; bir XSLT işlemci bu hatayı raporlayabilir; raporlamıyorsa, sayıyı <xfunction>string</xfunction> işlevi çağrılmış gibi dizgeye dönüştürüp hedef ağaca yerleştirerek hatayı ortadan kaldırmalıdır. Aksi takdirde, sayı bir tamsayıya yuvarlanır ve <specref ref="convert"/> bölümünde belirtilen öznitelikler kullanılarak bir dizgeye dönüştürülür; bu bağlamda, bu özniteliklerin her birinin değeri, bir <termref def="dt-attribute-value-template">öznitelik değeri örneklenimi</termref> olarak yorumlanır. Dönüşümden sonra, elde edilen dizge hedef ağaca yerleştirilir. Örneğin, aşağıda sıralı bir listenin üyeleri numaralanmaktadır:</p>

<eg><![CDATA[<xsl:template match="items">
  <xsl:for-each select="item">
    <xsl:sort select="."/>
    <p>
      <xsl:number value="position()" format="1. "/>
      <xsl:value-of select="."/>
    </p>
  </xsl:for-each>
</xsl:template>]]></eg>

<p>Eğer <code>value</code> özniteliği belirtilmezse, <code>xsl:number</code> elemanı geçerli düğümün kaynak ağacındaki konumuna karşılık gelen sayıyı bir numara olarak hedef ağaca yerleştirir. Aşağıdaki öznitelikler geçerli düğümün nasıl numaralanacağını denetler:</p>

<ulist>

<item><p><code>level</code> özniteliğinde kaynak ağacın hangi seviyelerde ele alınacağı belirtilir; değer olarak <code>single</code>, <code>multiple</code> veya <code>any</code> belirtilebilir. <code>single</code> değeri öntanımlı değerdir.</p></item>

<item><p><code>count</code> özniteliğinin değeri, bu seviyelerdeki hangi düğümlerin sayılacağını belirten bir örüntüdür. <code>count</code> özniteliği belirtilmezse, geçerli düğümle aynı türdeki düğümle eşleşen örüntü öntanımlı değerdir; eğer geçerli düğüm bir genişletilmiş isme sahipse, öntanımlı örüntü geçerli düğümle aynı genişletilmiş isme sahip düğümle eşleşecektir.</p></item>

<item><p><code>from</code> özniteliğinin değeri, sayımın nereden başlatılacağını belirten bir örüntüdür.</p></item>

</ulist>

<p>Ek olarak, <specref ref="convert"/> bölümünde belirtilen öznitelikler, <code>value</code> özniteliğinin belirtilmesi halinde sayıyı dizgeye dönüştürmek için kullanılırlar.</p>

<p><code>xsl:number</code> elemanı önce <code>level</code>, <code>count</code> ve <code>from</code> özniteliklerini kullanarak bir liste oluşturur:</p>

<ulist>

<item><p><code>level="single"</code> olduğu takdirde, <code>count</code>  örüntüsü ile eşleşen <xtermref href="&XPath;#axis-ancestor-or-self"><code>ancestor-or-self</code></xtermref> dalındaki ilk düğüme gidilir ve <code>count</code> örüntüsü ile eşleşen üstselin büyük kardeşinin numarası artı bir değerini içeren tek üyeli bir liste oluşturulur. Eğer böyle bir üstsel yoksa, boş liste oluşur. Eğer <code>from</code> özniteliği belirtilmişse, sadece, <code>from</code> örüntüsüyle eşleşen en yakın üstselin astsalları olan üstseller araştırılır. Burada büyük kardeşlerle, <xtermref href="&XPath;#axis-preceding-sibling"><code>preceding-sibling</code></xtermref> dalı kastedilmektedir.</p></item>

<item><p><code>level="multiple"</code> olduğu takdirde, geçerli düğümün, sırada kendisinin de bulunduğu, tüm üstsellerinin belge sırasına göre bir listesi oluşturulur; sonra, bu listeden <code>count</code> örüntüsü ile eşleşen düğümler seçilir; ardından, listenin her düğümüne, <code>count</code> örüntüsü ile eşleşen düğümün büyük kardeşinin numarası artı bir değeri eşlenir. Eğer <code>from</code> özniteliği belirtilmişse, sadece, <code>from</code> örüntüsüyle eşleşen en yakın üstselin astsalları olan üstseller araştırılır. Burada büyük kardeşlerle, <xtermref href="&XPath;#axis-preceding-sibling"><code>preceding-sibling</code></xtermref> dalı kastedilmektedir.</p></item>

<item><p><code>level="any"</code> olduğu takdirde, geçerli düğümü içeren kümeye ait olan düğümler artı <code>count</code> örüntüsü ile eşleşen düğümler artı belgedeki sıraya göre geçerli düğümden önce yer alan her seviyeden (isim-alanı ve öznitelik düğümleri hariç) tüm düğümlerin sayısı toplamını  içeren tek üyeli bir liste oluşturulur (başka bir deyişle, <xtermref href="&XPath;#axis-preceding"><code>preceding</code></xtermref> ve <xtermref href="&XPath;#axis-ancestor-or-self"><code>ancestor-or-self</code></xtermref> dallarının üyelerinin hepsi). Hiç eşleşen düğüm yoksa, boş liste oluşur. <code>from</code> özniteliği belirtilmişse, sadece geçerli düğümden önceki ilk düğümden sonraki düğümlerin <code>from</code> örüntüsü ile eşleştiği varsayılır.</p></item>

</ulist>

<p>Bundan sonra, numara listesi <specref ref="convert"/> bölümünde belirtilen öznitelikler kullanılarak bir dizgeye dönüştürülür; bu bağlamda, bu özniteliklerin her birinin değeri, bir <termref def="dt-attribute-value-template">öznitelik değeri örneklenimi</termref> olarak yorumlanır. Dönüşümden sonra, elde edilen dizge hedef ağaca yerleştirilir.</p>

<p>Aşağıda numaralı bir listenin üyeleri numaralanmaktadır:</p>

<eg><![CDATA[<xsl:template match="ol/item">
  <fo:block>
    <xsl:number/><xsl:text>. </xsl:text><xsl:apply-templates/>
  </fo:block>
<xsl:template>]]></eg>

<p>Aşağıdaki iki kural <code>başlık</code> elemanlarını numaralayacaktır. Anabölüm ve ekbölümlerden oluşan bir belgede, anabölümlerin ve ekbölümlerin bölümlere, bu bölümlerinde altbölümlere sahip olduğu düşünülerek, anabölümler 1, 2, 3; ekbölümler A, B, C; anabölüm bölümleri 1.1, 1.2, 1.3; ve ekbölüm bölümlerinin de A.1, A.2, A.3 biçiminde numaralanacakları düşünülmüştür.</p>

<eg><![CDATA[<xsl:template match="başlık">
  <fo:block>
     <xsl:number level="multiple"
                 count="anabölüm|bölüm|altbölüm"
                 format="1.1 "/>
     <xsl:apply-templates/>
  </fo:block>
</xsl:template>

<xsl:template match="ekbölüm//başlık" priority="1">
  <fo:block>
     <xsl:number level="multiple"
                 count="ekbölüm|bölüm|altbölüm"
                 format="A.1 "/>
     <xsl:apply-templates/>
  </fo:block>
</xsl:template>]]></eg>

<p>Aşağıdaki örnekte bir anabölüm içindeki notlar numaralanmaktadır:</p>

<eg><![CDATA[<xsl:template match="not">
  <fo:block>
     <xsl:number level="any" from="anabölüm" format="(1) "/>
     <xsl:apply-templates/>
  </fo:block>
</xsl:template>]]></eg>

<p>Aşağıdaki örnekte HTML'deki <code>H4</code> elemanları üç parçalı bir madde başlığı ile numaralanmaktadır:</p>

<eg><![CDATA[<xsl:template match="H4">
 <fo:block>
   <xsl:number level="any" from="H1" count="H2"/>
   <xsl:text>.</xsl:text>
   <xsl:number level="any" from="H2" count="H3"/>
   <xsl:text>.</xsl:text>
   <xsl:number level="any" from="H3" count="H4"/>
   <xsl:text> </xsl:text>
   <xsl:apply-templates/>
 </fo:block>
</xsl:template>]]></eg>

<div3 id="convert">
<head>Sayıdan Dizgeye Dönüşüm Öznitelikleri</head>

<p>Aşağıdaki öznitelikler bir numara listesinin dizgeye dönüşümünü denetlemekte kullanılırlar. Numaralar sıfırdan büyük tamsayılardır. Özniteliklerin hepsi isteğe bağlıdır.</p>

<p>Ana öznitelik <code>format</code> olup öntanımlı değeri <code>1</code>'dir. <code>format</code> özniteliği bir dizgecik dizisine bölünmüştür; buradaki her dizgecik ya olası en çok sayıda abecesayısal karakterden ya da olası en çok sayıda abecesayısal olmayan karakterden oluşur. Abecesayısal, Unicode kategorileri Nd, Nl, No, Lu, Ll, Lt, Lm veya Lo olan karakterler anlamındadır. Abecesayısal dizgecikler (biçim dizgecikleri) listedeki her numara için kullanılacak biçimi belirtirler. Eğer ilk dizgecik bir abecesayısal olmayan dizgecikse, oluşturulacak dizge bu dizgecikle başlar; eğer son dizgecik bir abecesayısal olmayan dizgecikse, oluşturulacak dizge bu dizgecikle biter. İki biçim dizgesi arasında yer alan abecesayısal olmayan dizgecikler, listedeki numaraları birbirine bağlamakta kullanılan ayraçlardır. <var>n</var>'inci biçim dizgesi listedeki <var>n</var>'inci numarayı biçimlemekte kullanılır. Eğer biçim dizgeciklerinden daha fazla numara varsa, son biçim dizgeciği kalan numaraları biçimlemekte kullanılır. Hiç biçim dizgeciği yoksa, bütün numaraları biçimlemek için biçim dizgeciği olarak <code>1</code> kullanılır. Biçim dizgeciği 1 sayısını göstermekte kullanılacak dizgeciği belirtir. İlkinden sonraki her numara, önceki numaradan ayraç dizgeciği ile ayrılır. Bir ayraç dizgeciği yoksa . (nokta) kullanılır.</p>

<p>Biçim dizgecikleri, HTML 4.0'daki <code>OL</code> elemanının <code>type</code> özniteliği için izin verilen değerlerin bir üstkümesidir ve şöyle yorumlanır:</p>

<ulist>

<item><p>Eğer bir biçim dizgeciğinin son karakterinin onluk rakam değeri 1 (Unicode karakter varlığı veritabanında belirtildiği gibi) ise ve sondan önceki karakterlerin Unicode değeri son karakterin Unicode değerinden 1 azsa o zaman bu dizgeciğe göre biçimlenen herhangi bir sayının onluk gösterimi en az biçim dizgeciği uzunluğundadır. Bu bakımdan, <code>1</code> biçim dizgeciği <code>1 2 ... 10 11 12 ...</code> dizisini üretirken, <code>01</code> biçim dizgeciği <code>01 02 ... 09 10 11 12 ... 99 100 101</code> dizisini üretecektir.</p></item>

<item><p><code>A</code> biçim dizgeciği <code>A B C ... Z AA AB AC...</code> dizisini üretir.</p></item>

<item><p><code>a</code> biçim dizgeciği <code>a b c ... z aa ab ac...</code> dizisini üretir.</p></item>

<item><p><code>i</code> biçim dizgeciği <code>i ii iii iv v vi vii viii ix x ...</code> dizisini üretir.</p></item>

<item><p><code>I</code> biçim dizgeciği <code>I II III IV V VI VII VIII IX X ...</code> dizisini üretir.</p></item>

<item><p>Bunlar dışında herhangi bir biçim dizgeciği o dizgecikle başlayan bir dizi üretir. Bu numaralama dizisini desteklemeyen gerçeklenimler <code>1</code> biçim dizgeciğini kullanmalıdır.</p></item>

</ulist>

<p>Bir abecesayısal dizi numaralanırken, <code>lang</code> özniteliği hangi dilin elifbasının kullanılacağını belirtir; <code>xml:lang</code> <bibref ref="XML"/> ile aynı aralıktaki değerler kullanılır; hiç <code>lang</code> değeri belirtilmemişse, dil, sistem ortamından saptanır. Gerçeklenimciler hangi dili desteklediklerini belgelemelidirler.</p>

<note><p>Gerçeklenimciler belli bir dilde nasıl numaralama yapılacağına ilişkin herhangi bir kabulde bulunmamalıdırlar ve desteklemek istedikleri dilleri gerektiği gibi araştırmalıdırlar. Çoğu dilin numaralama uzlaşımları İngilizce'dekinden çok farklıdır.</p></note>

<p><code>letter-value</code> özniteliği, harflerin kullanıldığı numaralama dizileri arasındaki belirsizliği ortadan kaldırır. Çoğu dilde, harflerin kullanıldığı numaralama dizileri başlıca iki çeşittir. Birinde, harflere abecesel sıraya göre sayısal değer atanırken, diğerinde sayısal değerler dildeki geleneksel anlamlandırmaya göre atanırlar. İngilizce'de bu iki çeşide ait biçim dizgecikleri <code>a</code> ve <code>i</code>'dir. Bazı dillerde dizilerin ilk üyesi aynıdır ve dolayısıyla biçim dizgeciği tek başına belirleyici olmaz. <code>alphabetic</code> değeri abecesel sıralamayı, <code>traditional</code> değeri ise diğer sıralamayı belirtir. Eğer <code>letter-value</code> özniteliği belirtilmemişse, belirsizliğin nasıl çözümleneceği gerçeklenime bağlıdır.</p>

<note><p>İki uyumlu XSLT işlemcisinin bir sayıyı tamamen aynı dizgeye dönüştürmemesi olasıdır. Bazı XSLT işlemci bazı dilleri desteklemeyebilir. Bundan başka, belli bir dildeki biçim çeşitlemelerini gerçekleştirecek dönüşümleri belirtmek için <code>xsl:number</code> öznitelikleri yeterli olmayabilir. Gerçeklenimler, bunun için <code>xsl:number</code> üzerinde gerçeklenime özgü isim-alanlı öznitelikler kullanabilirler.</p></note>

<p><code>grouping-separator</code> özniteliği onluk numaralama dizilerinde gruplama ayracı (binler ayracı gibi) olarak kullanılacak bir ayraç belirtilebilmesini ve isteğe bağlı olan <code>grouping-size</code> özniteliği ise ile gruplama miktarının (normalde 3'tür) belirtilebilmesini mümkün kılar. Örneğin, <code>grouping-separator=","</code> ve <code>grouping-size="3"</code> belirtimi <code>1,000,000</code> biçiminde bir sayı üretecektir. Bu ikisinden biri tek başına kullanılırsa yoksayılır.</p>

<p>Bazı dönüşüm belirtimi örnekleri:</p>

<ulist>

<item><p><code>format="&amp;#x30A2;"</code> Katakana numaralaması belirtir</p></item>

<item><p><code>format="&amp;#x30A4;"</code> Katakana numaralamasını <quote>iroha</quote> sıralamasıyla belirtir</p></item>

<item><p><code>format="&amp;#x0E51;"</code> Tay rakamlı numaralama belirtir</p></item>

<item><p><code>format="&amp;#x05D0;" letter-value="traditional"</code>
İbranice <quote>geleneksel</quote> numaralama belirtir</p></item>

<item><p><code>format="&amp;#x10D0;" letter-value="traditional"</code>
Gürcü tarzı numaralama belirtir</p></item>

<item><p><code>format="&amp;#x03B1;" letter-value="traditional"</code>
<quote>klasik</quote> Yunan numaralaması belirtir</p></item>

<item><p><code>format="&amp;#x0430;" letter-value="traditional"</code>
eski Slav tarzı numaralama belirtir</p></item>

</ulist>

</div3>
</div2>
</div1>

<div1 id="for-each">

<head>Yineleme</head>

<e:element-syntax name="for-each">
  <e:in-category name="yönerge"/>
  <e:attribute name="select" required="yes">
    <e:data-type name="düğüm-kümesi-ifadesi"/>
  </e:attribute>
  <e:sequence>
    <e:element repeat="zero-or-more" name="sort"/>
    <e:model name="örneklenim"/>
  </e:sequence>
</e:element-syntax>

<p>Sonucun düzenli bir yapıda olacağı biliniyorsa, örneklenimde doğrudan düğümleri seçmek daha kullanışlıdır. <code>xsl:for-each</code> yönergesi, <code>select</code> özniteliğinde belirtilen <termref
def="dt-expression">ifade</termref>ye göre seçilen her düğümü nesnelleştiren bir örneklenim içerir. <code>select</code> özniteliğinin kullanılması zorunludur. İfadeden bir düğüm kümesi elde edilmelidir. Örneklenim seçilen düğümleri birer <termref def="dt-current-node">geçerli düğüm</termref> olarak, tamamını da bir <termref def="dt-current-node-list">geçerli düğüm listesi</termref> olarak nesnelleştirir. Bir sıralama belirtilmedikçe düğümler belgedeki sıralarına göre işlenirler (bkz, <specref ref="sorting"/>).</p>

<p>Örneğin, bir XML belge şu yapıda olsun:</p>

<eg><![CDATA[<müşteriler>
  <müşteri>
    <isim>...</isim>
    <sipariş>...</sipariş>
    <sipariş>...</sipariş>
  </müşteri>
  <müşteri>
    <isim>...</isim>
    <sipariş>...</sipariş>
    <sipariş>...</sipariş>
  </müşteri>
</customers>]]></eg>

<p>Aşağıdaki kod her <code>müşteri</code> elemanı için bir satır bulunan bir tablo içeren bir HTML belge oluşturacaktır:</p>

<eg><![CDATA[<xsl:template match="/">
  <html>
    <head>
      <title>Müşteriler</title>
    </head>
    <body>
      <table>
        <tbody>
          <xsl:for-each select="müşteriler/müşteri">
            <tr>
              <th>
                <xsl:apply-templates select="isim"/>
              </th>
              <xsl:for-each select="sipariş">
                <td>
                  <xsl:apply-templates/>
                </td>
              </xsl:for-each>
            </tr>
          </xsl:for-each>
        </tbody>
      </table>
    </body>
  </html>
</xsl:template>]]></eg>

</div1>

<div1 id="condproc">
<head>Koşullu İşlem</head>

<p>XSLT'de bir örneklenim içinde koşullu işlemi destekleyen iki yönerge vardır: <code>xsl:if</code> ve <code>xsl:choose</code>. <code>xsl:if</code> yönergesi basit if-then koşullu işlemi içindir; <code>xsl:choose</code> yönergesi ise çeşitli olasılıklardan birinin seçilebilmesini sağlar.</p>

<div2>
<head><code>xsl:if</code> ile Koşullu İşlem</head>

<e:element-syntax name="if">
  <e:in-category name="yönerge"/>
  <e:attribute name="test" required="yes">
    <e:data-type name="mantıksal-ifade"/>
  </e:attribute>
  <e:model name="örneklenim"/>
</e:element-syntax>

<p><code>xsl:if</code> elemanı <termref def="dt-expression">ifade</termref> belirtmekte kullanılan bir <code>test</code> özniteliğine sahiptir. İfade değerlendirildikten sonra elde edilen sonuç <xfunction>boolean</xfunction> işlevinin yaptığı gibi bir mantıksal değere dönüştürülür. Eğer sonuç doğruysa, elemanının içeriğindeki örneklenim nesnelleştirilir; aksi takdirde, hiçbir şey yapılmaz. Aşağıdaki örnekte, bir isim grubundaki isimler bir virgül ayraçlı liste haline getirilmektedir:</p>

<eg><![CDATA[<xsl:template match="isimlistesi/isim">
  <xsl:apply-templates/>
  <xsl:if test="not(position()=last())">, </xsl:if>
</xsl:template>]]></eg>

<p>Bu örnekte bir tablonun satırları birer atlayarak sarıya boyanmaktadır:</p>

<eg><![CDATA[<xsl:template match="item">
  <tr>
    <xsl:if test="position() mod 2 = 0">
       <xsl:attribute name="bgcolor">yellow</xsl:attribute>
    </xsl:if>
    <xsl:apply-templates/>
  </tr>
</xsl:template>]]></eg>

</div2>


<div2>
<head><code>xsl:choose</code> ile Koşullu İşlem</head>

<e:element-syntax name="choose">
  <e:in-category name="yönerge"/>
  <e:sequence>
    <e:element repeat="one-or-more" name="when"/>
    <e:element repeat="zero-or-one" name="otherwise"/>
  </e:sequence>
</e:element-syntax>

<e:element-syntax name="when">
  <e:attribute name="test" required="yes">
    <e:data-type name="mantıksal-ifade"/>
  </e:attribute>
  <e:model name="örneklenim"/>
</e:element-syntax>

<e:element-syntax name="otherwise">
  <e:model name="örneklenim"/>
</e:element-syntax>

<p><code>xsl:choose</code> elemanı bir miktar olasılık arasından uygun olanını seçer. Bir veya daha fazla sayıda <code>xsl:when</code> elemanı ile varlığı isteği bağlı olan <code>xsl:otherwise</code> elemanını içerebilir. Her <code>xsl:when</code> elemanının bir <termref def="dt-expression">ifade</termref> belirtmekte kullanılan tek bir <code>test</code> özniteliği vardır. <code>xsl:when</code> ve <code>xsl:otherwise</code> elemanlarının içerikleri birer örneklenimdir. Bir <code>xsl:choose</code> elemanı işleme sokulduğunda, <code>xsl:when</code> elemanlarının içerdiği ifadeler sırayla değerlendirilip elde edilen sonuçlar <xfunction>boolean</xfunction> işlevinin yaptığı gibi birer mantıksal değere dönüştürülerek denenir. <code>xsl:when</code> elemanlarından doğru sonucu veren ilkinin içeriği nesnelleştirilir, diğerlerine bakılmaz. Eğer hiçbir <code>xsl:when</code> elemanı doğru sonuç vermemişse, <code>xsl:otherwise</code> elemanının içeriği nesnelleştirilir. Eğer hiçbir <code>xsl:when</code> elemanı doğru sonuç vermemişse ve <code>xsl:otherwise</code> elemanı da yoksa hiçbir nesnelleştirme yapılmaz.</p>

<p>Aşağıdaki örnekte, alt listeleri de olan sıralı bir listenin üyeleri, alt liste derinliğine bağlı olarak arap rakamları, harfler ve yunan rakamları kullanılarak numaralanmaktadır:</p>

<eg><![CDATA[<xsl:template match="orderedlist/listitem">
  <fo:list-item indent-start='2pi'>
    <fo:list-item-label>
      <xsl:variable name="level"
                    select="count(ancestor::orderedlist) mod 3"/>
      <xsl:choose>
        <xsl:when test='$level=1'>
          <xsl:number format="i"/>
        </xsl:when>
        <xsl:when test='$level=2'>
          <xsl:number format="a"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:number format="1"/>
        </xsl:otherwise>
      </xsl:choose>
      <xsl:text>. </xsl:text>
    </fo:list-item-label>
    <fo:list-item-body>
      <xsl:apply-templates/>
    </fo:list-item-body>
  </fo:list-item>
</xsl:template>]]></eg>

</div2>
</div1>

<div1 id="sorting">
<head>Sıralama</head>

<e:element-syntax name="sort">
  <e:attribute name="select">
    <e:data-type name="dizgesel-ifade"/>
  </e:attribute>
  <e:attribute name="lang">
    <e:attribute-value-template>
      <e:data-type name="ad-dizgeciği"/>
    </e:attribute-value-template>
  </e:attribute>
  <e:attribute name="data-type">
    <e:attribute-value-template>
       <e:constant value="text"/>
       <e:constant value="number"/>
       <e:data-type name="nitelikli-ad-ama-kısa-ad-değil"/>
    </e:attribute-value-template>
  </e:attribute>
  <e:attribute name="order">
    <e:attribute-value-template>
       <e:constant value="ascending"/>
       <e:constant value="descending"/>
    </e:attribute-value-template>
  </e:attribute>
  <e:attribute name="case-order">
    <e:attribute-value-template>
       <e:constant value="upper-first"/>
       <e:constant value="lower-first"/>
    </e:attribute-value-template>
  </e:attribute>
  <e:empty/>
</e:element-syntax>

<p>Sıralama, bir <code>xsl:apply-templates</code> veya <code>xsl:for-each</code> elemanının çocukları olarak <code>xsl:sort</code> elemanları kullanılarak belirtilir. İlk <code>xsl:sort</code> birincil sıralama anahtarını, ikincisi ikincil olanını belirtir ve bu böyle çoğaltılabilir. Bir <code>xsl:apply-templates</code> veya <code>xsl:for-each</code> elemanının çocukları olarak bir veya daha fazla sayıda <code>xsl:sort</code> elemanı olduğu takdirde, seçilen düğümler belgedeki sıralarına göre değil, sıralama anahtarları ile belirtilen sıraya göre işlenirler. <code>xsl:sort</code> elemanları <code>xsl:for-each</code> elemanında kullanıldıklarında, ilk çocuklar olmalıdırlar. Bir örneklenimin <code>xsl:apply-templates</code> veya <code>xsl:for-each</code> elemanı tarafından nesnelleştirilmesi halinde, <termref def="dt-current-node-list">geçerli düğüm listesi</termref>nin düğümleri <code>xsl:sort</code> elemanları tarafından belirtilen sıraya göre sıralanırlar.</p>

<p><code>xsl:sort</code> elemanının bir <termref def="dt-expression">ifade</termref> belirtmekte kullanılan bir <code>select</code> özniteliği vardır. İşlenen her düğüm için, düğüm geçerli düğüm kabul edilerek ve işlenen bütün düğümler için, belgedeki sırasıyla  bu düğümlerin tamamı geçerli düğüm listesi kabul edilerek ifade değerlendirilir. Elde edilen nesne <xfunction>string</xfunction> işlevinin yaptığı gibi bir dizgeye dönüştürülür; bu dizge düğüm için sıralama anahtarı olarak kullanılır. <code>select</code> özniteliğini öntanımlı değeri <code>.</code> olup, sıralama anahtarı olarak geçerli düğümün dizgesel değerinin kullanılmasına sebep olur.</p>

<p>Bu dizge düğüm için bir sıralama anahtarı işlevini görür. Aşağıdaki isteğe bağlı öznitelikler <code>xsl:sort</code> üzerinde sıralama anahtarları listesinin nasıl sıralanacağını denetlerler; bu özniteliklerin değerleri birer <termref def="dt-attribute-value-template">öznitelik değeri örneklenimi</termref> olarak yorumlanır.</p>

<ulist>

<item><p><code>order</code> özniteliği dizgelerin artan sırada mı yaksa azalan sırada mı sıralanacaklarını belirtir; <code>ascending</code> değeri sıralamanın artan sırada olacağını belirtirken, <code>descending</code> azalan sıralamada olacağını belirtir. <code>ascending</code> değeri öntanımlı değerdir.</p></item>

<item><p><code>lang</code> özniteliği sıralama anahtarları için dil belirtir; değeri <bibref ref="XML"/> <code>xml:lang</code> değerlerinden biri olmalıdır; <code>lang</code> özniteliği kullanılmamışsa, geçerli dil sistem ortamından elde edilmelidir.</p></item>

<item><p><code>data-type</code> özniteliği dizgelerin veri türünü belirtir; şu değerlere izin verilir:</p>

<ulist>

<item><p><code>text</code> değeri, sıralama anahtarlarının <code>lang</code> tarafından belirtilen dil için kültürel olarak doğru sözlük sırasında olacağını belirtir.</p></item>

<item><p><code>number</code> değeri, sıralama anahtarları sayıya dönüştürüldükten sonra sıralamanın sayısal değerlerine göre olacağını belirtir; her sıralama anahtarı <xfunction>number</xfunction> işlevinin yaptığı gibi birer sayıya dönüştürülür; <code>lang</code> özniteliği yoksayılır; bir NaN değeri artan sırada sayılardan önceye, azalan sırada sayılardan sonraya yerleştirilir.</p></item>

<item><p>Bir önekle birlikte bir <xnt href="&XMLNames;#NT-QName">NitelAd</xnt>, <specref ref="qname"/> bölümünde açıklandığı gibi bir <xtermref href="&XPath;#dt-expanded-name">genişletilmiş isme</xtermref> genişletilir; genişletilmiş isim veri türünü belirtir; bu durumda davranışın ne olacağı bu belgede belirtilmemiştir.</p></item>

</ulist>

<p>Öntanımlı değer <code>text</code>'tir.</p>

<note><p>XSL Çalışma Grubu, XSLT'nin ileri sürümlerinde bu özniteliğin değerlerini tanımlamak için daha kapsamlı XML Şemaları kullanmayı planlamaktadır.</p></note>

</item>

<item><p><code>case-order</code> özniteliği <code>upper-first</code> veya <code>lower-first</code> değerine sahip olabilir; <code>data-type="text"</code> ve artan sıra belirtildiğinde, büyük harflerin mi yoksa küçük harflerin mi önce geleceğini belirtirler. Örneğin, <code>lang="en"</code> için <code>case-order="upper-first"</code> olduğunda sıralama <code>A a B b</code>, <code>case-order="lower-first"</code> olduğunda ise <code>a A b B</code> şeklinde olur. Azalan sıra için herşey tersine olur. Örneğin, <code>lang="en"</code> için <code>case-order="upper-first"</code> olduğunda sıralama <code>b B a A</code>, <code>case-order="lower-first"</code> olduğunda ise <code>B b A a</code> şeklinde olur. Öntanımlı değer dile bağlıdır.</p></item>

</ulist>

<note><p>İki uyumlu XSLT işlemcinin tamamen aynı sıralamayı yapmaması olasıdır. Bazı XSLT işlemciler bazı dilleri desteklemeyebilir. Bundan başka, bazı diller için <code>xsl:sort</code> öznitelikleriyle elde edilemeyecek kadar çeşitli sıralamalar olası olabilir; örneğin, Japonca'da sıralamanın Hiragana mı yoksa Katakana mı olacağı gibi. XSLT'nin ileri sürümlerinde bu olasılıklar üzerinde denetim sağlayacak ek öznitelikler sağlanabilir. Gerçeklenimler ayrıca, bunun için <code>xsl:sort</code> üzerinde gerçeklenime özel isim-alanlı öznitelikler kullanabilirler.</p></note>

<note><p>Gerçeklenimcilerin uluslararası sıralama hakkında bilgi edinmek için <bibref ref="UNICODE-TR10"/>'u incelemeleri önerilir.</p></note>

<p>Sıralama kararlı olmalıdır: sıralı düğüm listesinde sıralama anahtarı belirtilmiş her alt listenin üyelerinin belgedeki sıraya göre eş sırada ele alınmaları gerekir.</p>

<p>Örneğin, şu biçimde düzenlenmiş bir çalışanlar veritabanımız olsun:</p>

<eg><![CDATA[<çalışanlar>
  <çalışan>
    <isim>
      <önadı>James</önadı>
      <soyadı>Clark</soyadı>
    </isim>
    ...
  </çalışan>
</çalışanlar>
]]></eg>

<p>İsme göre sıralı çalışanlar listesini üretecek kod şöyle olurdu:</p>

<eg><![CDATA[<xsl:template match="çalışanlar">
  <ul>
    <xsl:apply-templates select="çalışan">
      <xsl:sort select="isim/soyadı"/>
      <xsl:sort select="isim/önadı"/>
    </xsl:apply-templates>
  </ul>
</xsl:template>

<xsl:template match="çalışan">
  <li>
    <xsl:value-of select="isim/önadı"/>
    <xsl:text> </xsl:text>
    <xsl:value-of select="isim/soyadı"/>
  </li>
</xsl:template>]]></eg>

</div1>

<div1 id="variables">
<head>Değişkenler ve Değergeçler</head>

<e:element-syntax name="variable">
  <e:in-category name="tepe-seviyeden-eleman"/>
  <e:in-category name="yönerge"/>
  <e:attribute name="name" required="yes">
    <e:data-type name="nitelikli-ad"/>
  </e:attribute>
  <e:attribute name="select">
    <e:data-type name="ifade"/>
  </e:attribute>
  <e:model name="örneklenim"/>
</e:element-syntax>

<e:element-syntax name="param">
  <e:in-category name="tepe-seviyeden-eleman"/>
  <e:attribute name="name" required="yes">
    <e:data-type name="nitelikli-ad"/>
  </e:attribute>
  <e:attribute name="select">
    <e:data-type name="ifade"/>
  </e:attribute>
  <e:model name="örneklenim"/>
</e:element-syntax>

<p>Bir değişken bir değere atanmış bir isimdir. Bir değişken atanmış bir değer ifadelerden elde edilen herhangi bir türde nesne olabilir. Değişken atamakta kullanılabilen iki eleman vardır: <code>xsl:variable</code> ve <code>xsl:param</code>. Farkları, <code>xsl:param</code> elemanının  değişkene sadece bir öntanımlı değer atamasıdır; <code>xsl:param</code> elemanının yer aldığı örneklenim veya biçembent çağrıldığında değergeçler kullanıldıkları yerlere öntanımlı değer geçirirler.</p>

<p><code>xsl:variable</code> ve <code>xsl:param</code> elemanlarının ikisinin de değişkenin ismi olarak kullanıldığından belirtilmesi zorunlu birer <code>name</code> özniteliği vardır. <code>name</code> özniteliğinin değeri <specref ref="qname"/> bölümünde açıklandığı gibi bir <xnt
href="&XMLNames;#NT-QName">NitelAd</xnt>a genişletilir.</p>

<p>Bu değişken atama elemanlarından herhangi biri için, içinde atamanın görünür olduğu bir biçembent ağacı bölümü mevcuttur. Bir ifadenin etki alanındaki değişken atamaları, bu ifadenin yer aldığı biçembentte değişkenin görünür olduğu yerdeki atamalardan oluşur.</p>

<div2>
<head>Hedef Ağaç Bölümleri</head>

<p>Değişkenler ifade diline yeni bir veri türü ekler.
<termdef id="dt-result-tree-fragment" term="Hedef Ağaç Bölümü">Bu yeni türe <term>hedef ağaç bölümü</term> adı verilir. Bir değişken dört temel XPath türünden (dizge, sayı, mantıksal değer ve düğüm kümesi) başka bir hedef ağaç bölümü türünde de atanabilir. Bir hedef ağaç bölümü, hedef ağacın bir bölümü olarak ifade edilir ve tek bir kök düğüm içeren bir düğüm kümesine eşdeğer tarzda ele alınır</termdef>. Bununla birlikte, bir hedef ağaç bölümünde izin verilen işlemler bir düğüm kümesinde izin verilen işlemlerin bir altkümesidir. Böyle bir işleme sadece bir dizge üzerinde izin verilen bir işlemse izin verilir (dizge üzerindeki ilk işlem, dizgeyi bir mantıksal değere veya sayıya dönüştürme işlemi olabilir). Özellikle, hedef ağaç bölümü üzerinde <code>/</code>, <code>//</code> ve <code>[]</code> işleçlerinin kullanımına izin verilmez. Bir hedef ağaç bölümünde izin verilen işlemlerden biri her uygulanışında, eşdeğeri bir düğüm kümesinde uygulandığı gibi uygulanır.</p>

<p>Bir hedef ağaç bölümü hedef ağaca kopyalanırken (bkz, <specref ref="copy-of"/>), eşdeğer düğüm kümesinde kök düğümün çocukları olan tüm düğümler hedef ağaca aynı sırayla kopyalanırlar.</p>

<p>İfadeler, hedef ağaç bölümü türündeki değerleri sadece, hedef ağaç bölümü türündeki değişkenlere atıfta bulunarak veya bir hedef ağaç bölümü döndüren bir eklenti işlevini çağırarak ya da değeri bir hedef ağaç bölümü olan bir sistem gerecini getirerek döndürürler.</p>
</div2>

<div2 id="variable-values">
<head>Değişken ve Değergeçlerin Değerleri</head>

<p>Bir değişken atama elemanı bir değişken değerini üç yoldan biriyle belirtebilir.</p>

<ulist>

<item><p>Değişken atama elemanı bir <code>select</code> özniteliğine sahipse, bu özniteliğin değeri, değerlendirilmesinin sonucunda değişkenin değeri haline gelecek olan bir nesnenin elde edileceği bir <termref def="dt-expression">ifade</termref> olmalıdır. Bu durumda, değişken atama elemanının içeriği boş olmalıdır.</p></item>

<item>
<p>Değişken atama elemanı bir <code>select</code> özniteliğine sahip değilse ve eleman boş olmayan bir içeriğe sahipse (yani, değişken atama elemanı bir veya daha fazla sayıda çocuk elemana sahipse), değeri değişken atama elemanının içeriği belirler. Değişken atama elemanının içeriği, değişkenin değerini vermek üzere nesnelleştirilecek olan örneklenimdir. Değeri, çocukları örneklenimin nesnelleştirilmesiyle üretilen düğümlerden oluşan tek bir kök düğüm içeren bir düğüm kümesine eşdeğer bir hedef ağaç bölümüdür. Hedef ağaç bölümündeki düğümlerin temel tanım-yeri (URI), değişken atama elemanının temel tanım-yeridir.</p>

<p>Örneklenim nesnelleştirilerek elde edilen düğümlerin bir üyesinin bir öznitelik düğümü veya bir isim-alanı düğümü olması, bir kök düğüm böyle bir çocuk düğüme sahip olamayacağından, bir hatadır. Bir XSLT işlemci bu hatayı raporlayabilir; raporlamıyorsa, öznitelik veya isim-alanı düğümünü hedef ağaca eklemeyerek hatayı ortadan kaldırabilir.</p>
</item>

<item>
<p>Değişken atama elemanı boş bir içeriğe sahipse ve bir <code>select</code> özniteliği de belirtilmemişse, değişkenin değeri bir boş dizge olacaktır. Bu bakımdan,</p>

<eg><![CDATA[<xsl:variable name="x"/>]]></eg>

<p>buna eşdeğerdir:</p>

<eg><![CDATA[<xsl:variable name="x" select="''"/>]]></eg>
</item>
</ulist>

<note><p>Bir değişken, düğümleri konumlarına göre seçmek için kullanılmışsa, aşağıdakini yapmamak konusunda dikkatli olunmalıdır:</p>

<eg><![CDATA[<xsl:variable name="n">2</xsl:variable>
...
<xsl:value-of select="item[$n]"/>]]></eg>

<p>Bu örneklenim, ilk item elemanının değerini çıktılayacaktır. Sebebi, <code>n</code> değişkeninin bir sayıya değil bir hedef ağaç bölümüne atanmış olmasıdır. Şöyle,</p>

<eg><![CDATA[<xsl:variable name="n" select="2"/>
...
<xsl:value-of select="item[$n]"/>]]></eg>

<p>veya şöyle yapılabilirdi:</p>

<eg><![CDATA[<xsl:variable name="n">2</xsl:variable>
...
<xsl:value-of select="item[position()=$n]"/>]]></eg>
</note>

<note><p>Boş bir düğüm kümesini bir değergeçe öntanımlı değer olarak atamanın tek uygun yolu şudur:</p>

<eg><![CDATA[<xsl:param name="x" select="/.."/>]]></eg>
</note>

</div2>

<div2 id="copy-of">
<head>Değişken ve Değergeçlerin Değerlerinin <code>xsl:copy-of</code> ile Kullanımı</head>

<e:element-syntax name="copy-of">
  <e:in-category name="yönerge"/>
  <e:attribute name="select" required="yes">
    <e:data-type name="ifade"/>
  </e:attribute>
  <e:empty/>
</e:element-syntax>

<p><code>xsl:copy-of</code> elemanı hedef ağaca bir hedef ağaç bölümü yerleştirmekte kullanılabilir ve bunu yapmak için <code>xsl:value-of</code> elemanının yaptığı gibi (bkz, <specref ref="value-of"/>) önce bir dizgeye dönüşüm gerekmez. Bir <termref def="dt-expression">ifade</termref> içeren bir <code>select</code> özniteliğinin belirtilmesi zorunludur. İfadenin değerlendirme sonucunun bir hedef ağaç bölümü olması durumunda, bölümün tümü hedef ağaca kopyalanır. Sonucun bir düğüm kümesi olması durumunda ise, kümenin düğümleri belgedeki sıralarına göre hedef ağaca kopyalanırlar; bir eleman düğümünün kopyalanması, elemanın kendinden başka, isim-alanı düğümlerinin, öznitelik düğümlerinin ve elemanın çocuk düğümlerinin de kopyalanmasına sebep olur; bir kök düğüm ise, çocuklarının kopyalanmasıyla kopyalanmış olur. Bir öznitelik veya isim-alanının kopyalanmasında, <code>xsl:copy</code> ile kopyalamada geçerli olan kurallar burada da aynen geçerlidir (bkz, <specref ref="copying"/>). Sonucun ne bir düğüm kümesi ne de hedef ağaç bölümü olması durumunda, tıpkı <code>xsl:value-of</code> elemanının yaptığı gibi, sonuç bir dizgeye dönüştürüldükten sonra hedef ağaca yerleştirilir.</p>
</div2>

<div2 id="top-level-variables">
<head>Tepe-Seviyeden Değişkenler ve Değergeçler</head>

<p><code>xsl:variable</code> ve <code>xsl:param</code> elemanlarının her ikisi de <termref def="dt-top-level">tepe-seviyeden</termref> elemanlar olabilir. Bir tepe-seviyeden değişken atama elemanı, her yerde (başka bir atama tarafından geçersiz kılınmadıkça) görünür olan bir genel değişken bildirir. Bir tepe-seviyeden <code>xsl:param</code> elemanı biçembende bir değergeç bildirir; XSLT, biçembente değergeç aktarımı ile ilgili bir mekanizma tanımlamaz. Bir biçembent aynı isme sahip birden fazla değişken ataması içeriyorsa, <termref
def="dt-import-precedence">ithal önceliği</termref> en yüksek atama kullanılır. Bir biçembendin aynı <termref def="dt-import-precedence">ithal önceliği</termref> ile aynı isme atama yapan birden fazla değişken ataması içermesi bir hatadır. Tepe seviyede, değişken değeri belirten bir ifade veya örneklenim, kaynak belgenin kök düğümünü işlemekte kullanılan bağlama eşdeğer bir bağlamla değerlendirilir: geçerli düğüm kaynak belgenin kök düğümü olup geçerli düğüm kümesi kaynak belgenin sadece kök düğümünü içeren bir listedir. Eğer bir örneklenim veya ifade bir <var>y</var> genel değişkenine atıf yapan bir <var>x</var> genel değişkeni belirtiyorsa, <var>y</var> değişkeninin değerinin <var>x</var> değişkeninin değerinden önce hesaplanması gerekir. Tüm genel değişken tanımları açısından bunun olması olanaksızsa bu bir hatadır; başka bir deyişle, atamanın bitmeyen bir döngüye yol açabilecek şekilde hesaplanması bir hatadır.</p>

<p>Burada, bir öznitelik değeri örnekleniminden atıfta bulunulan <code>para-font-size</code> isimli bir genel değişken bildirilmektedir:</p>

<eg><![CDATA[<xsl:variable name="para-font-size">12pt</xsl:variable>

<xsl:template match="para">
 <fo:block font-size="{$para-font-size}">
   <xsl:apply-templates/>
 </fo:block>
</xsl:template>
]]></eg>

</div2>

<div2 id="local-variables">
<head>Örneklenimlerin içinde Değişkenler ve Değergeçler</head>

<p><code>xsl:variable</code> ve <code>xsl:param</code> elemanlarına tepe seviyede izin verildiği gibi örneklenimlerin içinde de izin verilir. <code>xsl:variable</code> elemanına, bir örneklenimin içinde bir yönergeye izin verilen her yerde izin verilir. Bu durumda, atama, <code>xsl:fallback</code> yönergeleri hariç tüm küçük kardeşlerin astsallarına görünür olacaktır. Atamanın <code>xsl:variable</code> elemanının kendisi için görünür olmayacağına dikkat ediniz.</p>

<p><code>xsl:param</code> elemanına bir <code>xsl:template</code> elemanının başlangıcında bir çocuk olarak bulunmasına izin verilir. Bu bağlamda, atama, <code>xsl:fallback</code> yönergeleri hariç tüm küçük kardeşlerin astsallarına görünür olacaktır. Atamanın <code>xsl:param</code> elemanının kendisi için görünür olmayacağına dikkat ediniz.</p>

<p><termdef id="dt-shadows" term="Geçersizleştirme">Eğer bir atamanın görünür olduğu yerde başka bir atama yer alıyorsa ve bu atamalar aynı isme yapılmışsa, yeni atama o bağlamda eskisini geçersiz bırakır.</termdef> Aynı örneklenim içinde <code>xsl:variable</code> veya <code>xsl:param</code> elemanlarınca yapılmış atamaların birbirlerini <termref def="dt-shadows">geçersizleştirme</termref>leri bir hatadır. Bir örneklenim içinde, <code>xsl:variable</code> veya <code>xsl:param</code> elemanlarınca yapılmış atamaların <termref def="dt-top-level">tepe-seviyeden</termref> yapılmış atamaları <termref def="dt-shadows">geçersizleştirme</termref>leri hata değildir. Bu durumda, bir tepe-seviyeden atama, başka bir atamanın kendisini geçersizleştirdiği bir biçembent bölümünde görünür olmayacaktır. Bu bakımdan şu bir hatadır:</p>

<eg role="error"><![CDATA[<xsl:template name="foo">
  <xsl:param name="x" select="1"/>
  <xsl:variable name="x" select="2"/>
</xsl:template>]]></eg>

<p>Ama, buna izin verilir:</p>

<eg><![CDATA[<xsl:param name="x" select="1"/>

<xsl:template name="foo">
  <xsl:variable name="x" select="2"/>
</xsl:template>]]></eg>

<note><p>Bir örneklenim içindeki bir <code>xsl:variable</code> elemanının Java dilindeki en yakın eşdeğeri, ilklendiricili bir nihai yerel değişken bildirimidir. Örneğin,</p>

<eg><![CDATA[<xsl:variable name="x" select="'value'"/>]]></eg>

<p>ile</p>

<eg>final Object x = "value";</eg>

<p>aynı anlambilgisine sahiptir. XSLT, böyle bir Java atama işlecinin bir eşdeğerini sağlamaz:</p>

<eg>x = "value";</eg>

<p>Çünkü bir belgeyi başından sonuna kadar, betik benzeri bir yöntemden başka bir yöntemle işleyen bir gerçeklenimi oluşturmak daha zor olurdu.</p></note>
</div2>

<div2>
<head>Değergeçlerin Örneklenimlere Aktarılması</head>

<e:element-syntax name="with-param">
  <e:attribute name="name" required="yes">
    <e:data-type name="nitelikli-ad"/>
  </e:attribute>
  <e:attribute name="select">
    <e:data-type name="ifade"/>
  </e:attribute>
  <e:model name="örneklenim"/>
</e:element-syntax>

<p>Değergeçler örneklenimlere <code>xsl:with-param</code> elemanı kullanılarak aktarılırlar. Belirtilmesi zorunlu olan <code>name</code> özniteliği değergeçin (atamanın değerini değiştirdiği değişken) ismini belirtir. <code>name</code> özniteliğinin değeri <specref ref="qname"/> bölümünde belirtildiği gibi yorumlanan bir <xnt href="&XMLNames;#NT-QName">NitelAd</xnt>dır. <code>xsl:with-param</code> elemanına <code>xsl:call-template</code> ve <code>xsl:apply-templates</code> elemanlarının her ikisinde de izin verilir. Bir <code>xsl:call-template</code> veya <code>xsl:apply-templates</code> elemanının birden fazla aynı isimli <code>xsl:with-param</code> elemanı içermesi bir hatadır. Değergeç değeri <code>xsl:variable</code> ve <code>xsl:param</code> elemanlarında kullanılan yöntemle belirtilir. <code>xsl:with-param</code> ile belirtilen değerin hesaplanmasında kullanılan geçerli düğüm ve geçerli düğüm listesi, içinde kullanıldığı <code>xsl:call-template</code> veya <code>xsl:apply-templates</code> elemanlarınınkilerle aynıdır. <var>x</var> için bir <code>xsl:param</code> elemanına sahip olmayan bir örneklenime bir <var>x</var> değergecini aktarmak hata değildir; değergeç basitçe yoksayılır.</p>

<p>Bu örnekte, sayı biçimini denetleyen bir değergeçe sahip <code>numbered-block</code> isminde bir örneklenim, değergeçine değer aktarılarak çağrılmaktadır:</p>

<eg><![CDATA[<xsl:template name="numbered-block">
  <xsl:param name="format">1. </xsl:param>
  <fo:block>
    <xsl:number format="{$format}"/>
    <xsl:apply-templates/>
  </fo:block>
</xsl:template>

<xsl:template match="ol//ol/li">
  <xsl:call-template name="numbered-block">
    <xsl:with-param name="format">a. </xsl:with-param>
  </xsl:call-template>
</xsl:template>]]></eg>
</div2>
</div1>

<div1 id="add-func">
<head>Ek İşlevler</head>

<p>Bu bölümde temel XPath işlev kütüphanesine ek olarak XSLT'ye özgü  işlevlere yer verilmiştir. Bu ek işlevlerin bazıları ayrıca, biçembentte <termref def="dt-top-level">tepe-seviyeden</termref> elemanlar tarafından belirtilen bilgileri de kullanıma sokarlar; bu bölümde bu işlevler ayrıca açıklanacaktır.</p>

<div2 id="document">
<head>Çok Kaynaklı Belgeler</head>

<proto name="document" return-type="düğüm-kümesi">
  <arg type="nesne"/>
  <arg type="düğüm-kümesi" occur="opt"/>
</proto>

<p><function>document</function> işlevi asıl kaynak belgeden başka XML belgelere de erişimi mümkün kılar.</p>

<p><function>document</function> işlevi tek bir argümana sahipse ve bu argüman da bir düğüm kümesi ise, sonuç, belirtilen düğüm kümesinin her düğümü için, düğümün kendi <xtermref href="&XPath;#dt-string-value">dizgesel değeri</xtermref>nin <function>document</function> işlevinin ilk argümanı, düğümün üyesi olduğu düğüm kümesinin ikinci argümanı olduğu <function>document</function> çağrılarının sonuçlarının birleşimidir.</p>

<p><function>document</function> işlevi iki argümana sahipse ve ilk argüman bir düğüm kümesi ise, sonuç, belirtilen düğüm kümesinin her düğümü için, düğümün <xtermref href="&XPath;#dt-string-value">dizgesel değeri</xtermref>nin <function>document</function> işlevinin ilk argümanı, ikinci argümanın yine ikinci argümanı olduğu <function>document</function> çağrılarının sonuçlarının birleşimidir.</p>

<p><function>document</function> işlevine aktarılan ilk argümanın bir düğüm kümesi olmaması halinde, ilk argüman <xfunction>string</xfunction> işlevinin yaptığı gibi bir dizgeye dönüştürülür ve bu dizge bir tanım-yeri (URI) başvurusu olarak ele alınır; Bu tanım-yeri ile tanımlanan özkaynak alınıp getirilir. Bu algetir işleminin sonucu olan veri bir XML belge olarak çözümlenir ve veri modeline uygun ber ağaç oluşturulur (bkz, <specref ref="data-model"/>). Özkaynağın alınıp getirilmesi ile ilgili bir hata oluşmuşsa, XSLT işlemci hatayı raporlayabilir, raporlamıyorsa, bir boş düğüm kümesi döndürerek hatayı ortadan kaldırabilir. Özkaynağın alınıp getirilmesi ile ilgili olası tek hata çeşidi XSLT işlemcinin tanım-yeri tarafından kullanılan tanım-yeri şemasını desteklemeyişidir. Bir XSLT işlemcinin her tanım-yeri şemasını desteklemesi gerekmez. XSLT işlemcinin belgeleri, XSLT işlemcinin hangi tanım-yeri şemalarını desteklediğini açıklamalıdır.</p>

<p>Eğer tanım-yeri başvurusu bir bölüm betimleyici (adresin sonunda yer alan ve # imi ile başlayan dizgecik) içermiyorsa, belgenin sadece kök düğümünü içeren bir düğüm kümesi döner. Eğer tanım-yeri başvurusu bir bölüm betimleyici içeriyorsa, tanım-yeri başvurusunun bölüm betimleyicisi tarafından betimlenen ağaçtaki düğümleri içeren bir düğüm kümesi döner. Bölüm betimleyicinin ifade ettiği anlam, tanım-yerinden alınıp getirilen özkaynağın ortam türüne bağımlıdır. Eğer bölüm betimleyicinin işlenmesi ile ilgili bir hata oluşmuşsa, XSLT işlemci hatayı raporlayabilir, raporlamıyorsa, bir boş düğüm kümesi döndürerek hatayı ortadan kaldırabilir. Olası hatalar şunlar olabilir:</p>

<ulist>
<item><p>Bölüm betimleyici bir XSLT düğüm kümesi tarafından ifade edilemeyecek şeyleri betimliyordur (örneğin, bir metin düğümündeki bir karakter aralığı).</p></item>

<item><p>XSLT işlemci tanım-yerinden alınıp getirilen özkaynağın ortam türüne özgü bölüm betimleyiciyi desteklemiyordur. Bir XSLT işlemcinin her ortam türünü desteklemesi gerekmez. XSLT işlemcinin belgeleri, XSLT işlemcinin hangi ortam türlerini desteklediğini açıklamalıdır.</p></item>
</ulist>

<p>Özkaynağın alınıp getirilmesinin sonucu olan veri algetir işleminin sonucunun ortam türünden bağımsız olarak bir XML belge olarak çözümlenir; eğer tepe seviye ortam türü <code>text</code> ise, ortam türünün <code>text/xml</code> olduğu durumda uygulanan yöntemle çözümlenir; aksi takdirde, <code>application/xml</code> ortam türüne özgü yöntemle çözümlenir.</p>

<note><p>Tepe-seviyeden bir <code>xml</code> ortam türü olmadığından <code>text/xml</code> veya <code>application/xml</code> ortam türünde olmayan veri yine de fiilen XML olabilir.</p></note>

<p>Tanım-yeri başvurusu göreli olabilir. İkinci argümandaki düğüm kümesinde, belgedeki sıraya göre ilk olan düğümün temel tanım-yeri (bkz, <specref
ref="base-uri"/>), göreli tanım yerlerini mutlak tanım yerine dönüştürmek için temel tanım-yeri olarak kullanılır. İkinci argümanda boş düğüm kümesi ile göreli tanım-yeri belirtmek bir hatadır.  XSLT işlemci hatayı raporlayabilir, raporlamıyorsa, bir boş düğüm kümesi döndürerek hatayı ortadan kaldırabilir. Eğer ikinci argüman hiç belirtilmemişse, biçembentte <function>document</function> işlevinin çağrıldığı ifadeyi içeren düğüm öntanımlı değerdir. Göreli tanım-yeri başvurusunun çözümlenmesini sağlaması nedeniyle, sıfır uzunluktaki bir tanım-yeri başvurusunun belgeye bir başvuru oluşuna dikkat ediniz; bu bakımdan, <code>document("")</code> ifadesi biçembendin kök düğümüne karşılıktır; biçembendin ağaç gösterimi, biçembendi kaynak belgenin başında içeren XML belgeyle tamamen aynıdır.</p>

<p>Eğer iki belge aynı tanım-yerine sahipse bunlar aynı belge olarak ele alınır. Karşılaştırma için kullanılan tanım-yeri, göreli tanım-yerlerini çözümlemekte kullanılan ve bir bölüm betimleyici içermeyen mutlak tanım-yeridir. Eğer ikisi de aynı belgeye aitse iki kök düğüm aynı kök düğüm olarak ele alınır. Bu bakımdan aşağıdaki ifade daima doğru sonuç verecektir:</p>

<eg>generate-id(document("foo.xml"))=generate-id(document("foo.xml"))</eg>

<p><function>document</function> işlevi, bir düğüm kümesinin birden fazla belgeden düğümler içermesini olasılığını arttırır.  Böyle bir düğüm kümesi ile aynı belgedeki iki düğümün göreli belge sırası XPath <bibref ref="XPATH"/> tarafından tanımlanmış normal <xtermref href="&XPath;#dt-document-order">belge sırası</xtermref> olacaktır. İki düğümün farklı belgelerdeki göreli belge sırası, bu iki düğümü içeren belgelerin gerçeklenime bağımlı sıralamasına göre saptanır. Sürekli olarak aynı sonucu vermek dışında gerçeklenimlerin belgeleri nasıl sıralayacağıyla ilgili bir kısıtlama yoktur: Bir gerçeklenim, aynı belge kümesi için daima aynı sıralamayı yapmak zorundadır.</p>
</div2>

<div2 id="key">
<head>Anahtarlar</head>

<p>Anahtarlar, belgelerde örtük bir çapraz başvuru yapısıyla çalışma imkanı verir. XML'deki <code>ID</code>, <code>IDREF</code> ve <code>IDREFS</code> öznitelik türleri XML belgelerin kendi çapraz başvurularını doğrudan oluşturabilmeleri için bir mekanizma sağlar. XSLT bunu XPath <xfunction>id</xfunction> işlevi üzerinden destekler. Bununla birlikte bu mekanizmanın bazı gereklilikleri vardır:</p>

<ulist>
<item><p>ID türündeki öznitelikler örneğin DTD gibi bir yerde bildirilmelidir. Eğer bir ID özniteliği bir ID türünden öznitelik olarak sadece harici bir DTD altkümesinde bildirilmişse, bu öznitelik sadece, eğer XML işlemci bu harici DTD altkümesini okursa bir ID türünde öznitelik olarak tanınacaktır. Ancak, XML Önergesi, XML işlemcilerin harici DTD altkümelerini okumasını bir zorunluluk değil, bir öneri olarak belirtir.</p></item>

<item><p>Bir belge eşsiz ID'lerin tek bir kümesine sahip olabilir. Ayrı ayrı bağımsız eşsiz ID kümeleri olamaz.</p></item>

<item><p>Bir elemanın ID'si sadece bir öznitelikte belirtilebilir; elemanın içeriğinde veya bir çocuk eleman tarafından belirtilemez.</p></item>

<item><p>Bir ID bir XML adı olmak zorundadır. Örneğin, boşluk içeremez.</p></item>

<item><p>Bir eleman en çok bir ID'ye sahip olabilir.</p></item>

<item><p>Belli bir ID'ye en çok bir eleman sahip olabilir.</p></item>
</ulist>

<p>Bu gerekliliklerden dolayı XML belgeler, ID/IDREF/IDREFS öznitelikleriyle açıkça belirtilmese bile bir çapraz başvuru yapısına sahip olurlar.</p>

<p>Bir anahtar şu üçlemeye sahiptir:</p>

<olist>
<item><p>anahtarın sahibi olan düğüm</p></item>
<item><p>anahtarın ismi (bir <xtermref
href="&XPath;#dt-expanded-name">genişletilmiş isim</xtermref>)</p></item>
<item><p>anahtarı değeri (bir dizge)</p></item>
</olist>

<p>Bir biçembentte her belge için anahtar kümesi <code>xsl:key</code> elemanı kullanılarak bildirilir. Bu anahtar kümesi, <var>x</var> diye bir düğüme, <var>y</var> diye bir isme ve <var>z</var> diye bir değere sahipse, <var>x</var> düğümünün <var>z</var> değerli bir <var>y</var> anahtarı olduğundan bahsedebiliriz.</p>

<p>Bu bakımdan, bir anahtar, bir XML ID'sinin sınırlamalarına konu olmayan genelleştirilmiş bir ID çeşididir:</p>

<ulist>

<item><p>Anahtarlar bir biçembentte <code>xsl:key</code> elemanları kullanılarak bildirilirler.</p></item>

<item><p>Bir anahtarın değerinden başka bir de ismi vardır; her anahtar ismi betimleyici uzayından bağımsız, ayrı bir isim olarak düşünülebilir.</p></item>

<item><p>Bir isimli anahtar değeri bir eleman için, uygun herhangi bir yerde belirtilebilir; örneğin bir öznitelikte, bir çocuk elemanda veya içerikte belirtilebilir. Belli bir isimli anahtar için bulunacak değerin yerini belirtmek için bir XPath ifadesi kullanılır.</p></item>

<item><p>Bir anahtarın değeri keyfi bir dizge olabilir; bir XML adı olmak zorunda değildir.</p></item>

<item><p>Bir belgede aynı düğümün farklı anahtar değerleri için aynı isimde çok sayıda anahtarı olabilir.</p></item>

<item><p>Bir belgede aynı anahtar ismine ve aynı anahtar değerine sahip çok sayıda farklı düğüm olabilir.</p></item>
</ulist>

<e:element-syntax name="key">
  <e:in-category name="tepe-seviyeden-eleman"/>
  <e:attribute name="name" required="yes">
    <e:data-type name="nitelikli-ad"/>
  </e:attribute>
  <e:attribute name="match" required="yes">
    <e:data-type name="örüntü"/>
  </e:attribute>
  <e:attribute name="use" required="yes">
    <e:data-type name="ifade"/>
  </e:attribute>
  <e:empty/>
</e:element-syntax>

<p><code>xsl:key</code> elemanı anahtarları bildirmek için kullanılır. <code>name</code> özniteliği ile anahtarın ismi belirtilir. <code>name</code> özniteliğinin değeri, <specref ref="qname"/> bölümünde açıklandığı gibi yorumlanan bir <xnt href="&XMLNames;#NT-QName">NitelAd</xnt> olmalıdır. <code>match</code> özniteliği bir <nt def="NT-Pattern">Örüntü</nt> olup, bir <code>xsl:key</code> elemanı, belirtilen bu örüntüyle eşleşen düğümlerin anahtarları hakkında bilgi verir. <code>use</code> özniteliği anahtarın değerini belirten bir <termref def="dt-expression">ifade</termref> olup, örüntüyle eşleşen her düğüm için bir kere değerlendirilir. Eğer sonuç bir düğüm kümesi ise, düğüm kümesindeki her düğümün belirtilen isimde, değeri düğümün dizgesel değeri olan bir anahtarı olur; aksi takdirde, sonuç bir dizgeye dönüştürülür ve örüntüyle eşleşen düğümün belirtilen isimde değeri bu dizge olan bir anahtarı olur. Bu bakımdan, bir <var>x</var> düğümünün <var>y</var> isminde ve <var>z</var> değerinde bir anahtara sahip olması için bir <code>xsl:key</code> elemanının sağlaması gerek ve yeter koşullar şunlardır:</p>

<ulist>
<item><p><var>x</var> düğümü, <code>xsl:key</code> elemanının <code>match</code> özniteliğinde belirtilen örüntüyle eşleşir;</p></item>

<item><p><code>xsl:key</code> elemanının <code>name</code> özniteliğinin değeri <var>y</var>'ye eşit olup,</p></item>

<item><p><code>xsl:key</code> elemanının <code>use</code> özniteliğinde belirtilen ifade, bir <var>u</var> nesnesinden elde edilen bir geçerli düğüm listesindeki geçerli düğüm olarak <var>x</var> düğümüyle değerlendirildiğinde, <var>z</var>, ya <var>u</var>'nun <xfunction>string</xfunction> işlevinin yaptığı gibi bir dizgeye dönüştürülmesinin sonucuna eşittir ya da <var>u</var> bir düğüm kümesi olup, <var>z</var> değeri de <var>u</var>'daki düğümlerin bir veya daha fazlasının dizgesel değerine eşittir.</p></item>
</ulist>

<p>Ayrıca, belli bir düğümle eşleşen birden fazla <code>xsl:key</code> elemanı olabileceğini de aklınızdan çıkarmayın; böyle <code>xsl:key</code> elemanlarının hepsi aynı <termref def="dt-import-precedence">ithal önceliği</termref>ne sahip olmasalar bile kullanılırlar.</p>

<p><code>use</code> veya <code>match</code> özniteliğinin değer olarak bir <xnt
href="&XPath;#NT-VariableReference">DeğişkenGönderimi</xnt> veya bir <function>key</function> işlev çağrısı içermesi bir hatadır.</p>

<proto name="key" return-type="düğüm-kümesi"><arg type="dizge"/><arg type="nesne"/></proto>

<p><function>key</function> işlevi ID'ler için <xfunction>id</xfunction> işlevinin yaptığını anahtarlar için yapar. İlk argüman anahtarın ismini belirtir. Argümanın değeri <specref ref="qname"/> bölümünde açıklandığı gibi yorumlanan bir <xnt href="&XMLNames;#NT-QName">NitelAd</xnt> olmalıdır. İkinci argüman bir düğüm kümesi olduğunda, sonuç, bu düğüm kümesindeki her düğümün <xtermref href="&XPath;#dt-string-value">dizgesel değer</xtermref>ine <function>key</function> işlevinin uygulanmasından elde edilen sonuçlarının birleşimi olacaktır. İkinci argüman herhangi bir başka türde bir değer içerdiğinde, argüman <xfunction>string</xfunction> işlevinin yaptığı gibi bir dizgeye dönüştürülür; bu durumda, işlevden dönen sonuç, değeri bu dizgeye eşit bir isimli anahtara sahip bağlamsal düğümle aynı belgedeki düğümleri içeren bir düğüm kümesi olur.</p>

<example>
<p>Örneğin, şöyle bir bildirim olsun:</p>

<eg><![CDATA[<xsl:key name="idkey" match="div" use="@id"/>]]></eg>

<p><code>key('idkey', @ref)</code> ifadesi, <code>id(@ref)</code> ifadesinin sonucu olan düğüm kümesi ile döner; XML kaynak belgesinde özniteliğin ID türünde şöyle bildirilmiş olduğu,</p>

<eg><![CDATA[<!ATTLIST div id ID #IMPLIED>]]></eg>

<p>ve geçerli düğümün <code>ref</code> özniteliğinin herhangi bir boşluk karakteri içermediği varsayımıyla.</p>
</example>

<example>
<p>Bir işlev kütüphanesini açıklayan bir belgemiz olduğunu ve işlevleri tanımlamak için bir <code>prototype</code> elemanı kullanıldığını varsayalım.</p>

<eg><![CDATA[<prototype name="key" return-type="düğüm-kümesi">
<arg type="dizge"/>
<arg type="nesne"/>
</prototype>]]></eg>

<p>İşlev isimlerinden bu tanıma atıfta bulunmak için de <code>function</code> elemanı kullanılıyor olsun.</p>

<eg><![CDATA[<function>key</function>]]></eg>

<p>Buradan hareketle biçembent gönderimlerle tanımlar arasındaki hiper bağları şöyle üretecektir:</p>

<eg><![CDATA[<xsl:key name="func" match="prototype" use="@name"/>

<xsl:template match="function">
<b>
  <a href="#{generate-id(key('func',.))}">
    <xsl:apply-templates/>
  </a>
</b>
</xsl:template>

<xsl:template match="prototype">
<p><a name="{generate-id()}">
<b>Function: </b>
...
</a></p>
</xsl:template>]]></eg>
</example>

<example><head>(çevirmenden)</head>
<p>Bu anahtarlar konusu bu işin en zor anlaşılan kısmıdır. Yukarıdakine benzer ama yukarıdakinden her bakımdan daha yararlı olacağını umduğum bir örneği vermek istiyorum.</p>

<p>Bir belirtim belgemiz olsun. Belgede bahsedilen sabitlerden bazılarının tanımları varken bazıları sadece birer dizgesel sabit olsun. Tanımları olanların isimleri belgede geçtikçe (<code><![CDATA[<literal>sabit</literal>]]></code> gibi) bu isimler bu tanımlara aynı zamanda birer hiper bağ olsun, tanımları olmayanların da birer sabit oldukları belli olsun, istiyoruz. </p>

<eg><![CDATA[<xsl:template match="literal">
  <xsl:variable name="idx" select="concat('value-def-', text())"/>
  <xsl:variable name="targets" select="key('ids', $idx)"/>

  <xsl:choose>
    <xsl:when test="count($targets) > 0">
      <a href="#{$idx}">
        <code><xsl:apply-templates/></code>
      </a>
    </xsl:when>
    <xsl:otherwise>
      <tt><xsl:apply-templates/></tt>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>]]></eg>

<p>Örneklenimin ilk yönergesinde bir değişken ataması yapılıyor. <code>$idx</code> değişkenine, <code>literal</code> elemanının içeriğinden bir ID değeri oluşturup bunu atıyoruz. İkinci yönergedeki değişken atamasında ise <code>$idx</code> değişkenine atadığımız ID değerini içeren düğümleri <code>$ids</code> değişkeninin değerinden alıp <code>$targets</code> değişkenine atıyoruz. Tabii bunu yapabilmek için biçembentin başlarında şöyle bir yönergemiz olması gerek (bu anahtar, belgede birer <code>id</code> özniteliğine sahip bütün elemanları toplayıp <code>$ids</code> değişkenine atar):</p>

<eg>&lt;xsl:key name="ids" match="*" use="@id"/></eg>

<p><code>xsl:when</code> elemanında aradığımız ID'ye sahip eleman var mı acaba diye bir sınama yapıyoruz. Varsa, XML belgedeki  <code><![CDATA[<literal>sabit</literal>]]></code> yerine XHTML belgeye sabitin tanımını işaret eden bir hiper bağ yerleştiriyoruz (bu bağ için gereken ID değerini bildiğimiz için bir önceki örnekte olduğu gibi bir ID üretmemiz gerekmiyor). Yoksa, içeriğini bir dizgesel sabit olduğunu vurgulayacak bir imlenimin (<code>tt</code>) içine alıyoruz.</p>
</example>

<p><function>key</function> işlevi daima geçerli düğümle aynı belgede yer alan düğümleri döndürür; bir anahtarı başka bir belgeden almak için önce geçerli düğümün değiştirilmesi gerekir.</p>

<example>
<p>Bir belgenin <code><![CDATA[<bibref>XSLT</bibref>]]></code> biçiminde kaynakça girdilerine atıfta bulunduğunu ve bu kaynakçanın da <code>bib.xml</code> adlı ayrı bir XML belgede girdilerinin şöyle bir veri modeliyle tutulduğunu varsayalım:</p>

<eg><![CDATA[<entry name="XSLT">...</entry>]]></eg>

<p>Bu durumda biçembent <code>bibref</code> elemanlarını dönüştürmek için şu kodları içerebilirdi:</p>

<eg><![CDATA[<xsl:key name="bib" match="entry" use="@name"/>

<xsl:template match="bibref">
  <xsl:variable name="name" select="."/>
  <xsl:for-each select="document('bib.xml')">
    <xsl:apply-templates select="key('bib',$name)"/>
  </xsl:for-each>
</xsl:template>]]></eg>
</example>
</div2>

<div2 id="format-number">
<head>Sayı Biçimleme</head>

<proto name="format-number" return-type="dizge">
  <arg type="sayı"/>
  <arg type="dizge"/>
  <arg occur="opt" type="dizge"/>
</proto>

<p><function>format-number</function> işlevi birinci argümanında belirtilen sayıyı ikinci argümanında belirtilen biçim örüntüsü dizgesini kullanarak bir dizgeye dönüştürür. Üçüncü argümanda onluk sayı biçimi belirtilir, üçüncü argümanın yokluğunda öntanımlı onluk sayı biçimi kullanılır. Biçim örüntüsü dizgesi JDK 1.1 <loc href= "http://java.sun.com/products/jdk/1.1/docs/api/java.text.DecimalFormat.html"
>DecimalFormat</loc> sınıfı tarafından belirtilen sözdizimine sahiptir. Biçim örüntüsü dizgesinin gösterimi yerelleştirilebilir: onluk biçim örüntüdeki karakterlerin hangilerinin ne anlama geldiğini belirler (yerelleştirilmeyen tırnak karakteri hariç). Biçim örüntüsü sent imini (#x00A4) içeremez; Bu özellik için destek JDK 1.1'e ilk sürümünden sonra eklenmiştir. Onluk biçim ismi <specref ref="qname"/> bölümünde açıklandığı gibi yorumlanan bir <xnt href="&XMLNames;#NT-QName">NitelAd</xnt> olmalıdır. Biçembendin onluk biçimin  <xtermref href="&XPath;#dt-expanded-name">genişletilmiş isim</xtermref>li bir bildirimini içermemesi bir hatadır.</p>

<note><p>Gerçeklenimlerin ne JDK 1.1 kullanması ne de Java dilinde geliştirme yapmaları gereklidir.</p></note>

<note><p>Biçembentler yuvarlamayı denetim altına almak için XPath'daki diğer oluşumları kullanabilirler.</p></note>

<e:element-syntax name="decimal-format">
  <e:in-category name="tepe-seviyeden-eleman"/>

  <e:attribute name="name">
    <e:data-type name="nitelikli-ad"/>
  </e:attribute>
  <e:attribute name="decimal-separator">
    <e:data-type name="karakter"/>
  </e:attribute>
  <e:attribute name="grouping-separator">
    <e:data-type name="karakter"/>
  </e:attribute>
  <e:attribute name="infinity">
    <e:data-type name="dizge"/>
  </e:attribute>
  <e:attribute name="minus-sign">
    <e:data-type name="karakter"/>
  </e:attribute>
  <e:attribute name="NaN">
    <e:data-type name="dizge"/>
  </e:attribute>
  <e:attribute name="percent">
    <e:data-type name="karakter"/>
  </e:attribute>
  <e:attribute name="per-mille">
    <e:data-type name="karakter"/>
  </e:attribute>
  <e:attribute name="zero-digit">
    <e:data-type name="karakter"/>
  </e:attribute>
  <e:attribute name="digit">
    <e:data-type name="karakter"/>
  </e:attribute>
  <e:attribute name="pattern-separator">
    <e:data-type name="karakter"/>
  </e:attribute>
  <e:empty/>
</e:element-syntax>

<p><code>xsl:decimal-format</code> elemanı, <function>format-number</function> işlevi tarafından kullanılan bir biçim örüntüsünün yorumlanışını denetleyen bir onluk biçim bildirir. <code>name</code> özniteliği belirtilmişse, eleman isimli bir onluk biçim belirtir. <code>name</code> özniteliğinin değeri <specref ref="qname"/> bölümünde açıklandığı gibi yorumlanan bir <xnt href="&XMLNames;#NT-QName">NitelAd</xnt> olmalıdır. Öntanımlı onluk biçim bildirimi yapmak veya tüm öznitelikler (öntanımlılar dahil) için aynı değerle bildirilmiş olmadıkça aynı isimde birden fazla onluk biçim bildirimi yapmak (<termref def="dt-import-precedence">ithal öncelikleri</termref> farklı olsa bile) bir hatadır. Eğer bir biçembent bir öntanımlı onluk biçim bildirimi içermiyorsa, özniteliksiz <code>xsl:decimal-format</code> elemanına eşdeğer bir bildirim uygulanır.</p>

<p><code>xsl:decimal-format</code> elemanının diğer öznitelikleri JDK 1.1 <loc href=
"http://java.sun.com/products/jdk/1.1/docs/api/java.text.DecimalFormatSymbols.html">DecimalFormatSymbols</loc> sınıfındaki yöntemlere karşılıktır. Her <code>get</code>/<code>set</code> çiftine karşılık <code>xsl:decimal-format</code> elemanı için tanımlanmış bir öznitelik vardır.</p>

<p>Aşağıdaki öznitelikler hem biçim örüntüsündeki karakterlerin yorumlanışını denetler hem de sayının biçimlenmesi sonucu elde edilebilen karakterleri belirtirler:</p>

<ulist>
<item><p><code>decimal-separator</code> özniteliği ondalık ayraç olarak kullanılacak karakteri (Türkçe için virgüldür) belirtir; öntanımlı değer nokta (<code>.</code>) karakteridir.</p></item>

<item><p><code>grouping-separator</code> özniteliği bölükleme için kullanılan (Türkçe için noktadır) karakteri belirtir (binler bölükleri gibi); öntanımlı değer virgül (<code>,</code>) karakteridir.</p></item>

<item><p><code>percent</code> özniteliği yüzde imi olarak kullanılacak karakteri (Türkçe için de % karakteridir ama sayının ardına değil önüne konur) belirtir;  öntanımlı değer yüzde (<code>%</code>) karakteridir.</p></item>

<item><p><code>per-mille</code> özniteliği her-milde-bir karakteri olarak kullanılacak karakteri;  öntanımlı değer Unicode her-milde-bir (<code>#x2030</code>) karakteridir.</p></item>

<item><p><code>zero-digit</code> özniteliği sıfır ratamı olarak kullanılacak karakteri belirtir; öntanımlı değer sıfır (<code>0</code>) rakamıdır.</p></item>
</ulist>

<p>Aşağıdaki öznitelikler biçim örüntüsündeki karakterlerin yorumlanışını denetlerler:</p>

<ulist>
<item><p><code>digit</code> özniteliğinde biçim örüntüsünde rakam ifade eden karakter belirtilir; öntanımlı değer diyez (<code>#</code>) karakteridir.</p></item>

<item><p><code>pattern-separator</code> özniteliğinde pozitif ve negatif alt örüntüleri ayırmakta kullanılan karakter belirtilir; öntanımlı değer noktalı virgül (<code>;</code>) karakteridir.</p></item>
</ulist>

<p>Aşağıdaki öznitelikler biçimlenmiş sayıda yer alan karakterleri veya dizgeleri belirtmekte kullanılır:</p>

<ulist>
<item><p><code>infinity</code> özniteliğinde sonsuzluğu belirtmekte kullanılan dizge belirtilir;  öntanımlı değer <code>Infinity</code> dizgesidir.</p></item>

<item><p><code>NaN</code> özniteliğinde NaN (Not-a-Number: bir-Sayı-Değil) değerini belirtmekte kullanılan dizge belirtilir;  öntanımlı değer <code>NaN</code> dizgesidir.</p></item>

<item><p><code>minus-sign</code> özniteliğinde eksi imi olarak kullanılacak karakter belirtilir; öntanımlı değer tire (<code>-</code>, #x2D) karakteridir.</p></item>
</ulist>

</div2>

<div2 id="misc-func">
<head>Çeşitli Ek İşlevler</head>

<proto name="current" return-type="düğüm-kümesi"></proto>

<p><function>current</function> işlevi, tek üyesi <termref def="dt-current-node">geçerli düğüm</termref> olan bir düğüm kümesi ile döner. Son tahlilde (başka bir ifadenin içinde yer almayan bir ifadede), geçerli düğüm daima bağlamsal düğümle aynıdır. Bu bakımdan,</p>

<eg><![CDATA[<xsl:value-of select="current()"/>]]></eg>

<p>ile</p>

<eg><![CDATA[<xsl:value-of select="."/>]]></eg>

<p>aynı anlama gelir. Bununla birlikte, köşeli ayraçlar içindeki geçerli düğüm bağlamsal düğümden farklı bir düğüm olacaktır. Örneğin,</p>

<eg><![CDATA[<xsl:apply-templates select="//glossary/item[@name=current()/@ref]"/>]]></eg>

<p>ebeveynleri <code>glossary</code> elemanları olup, değerleri geçerli düğümün <code>ref</code> özniteliğinin değerine eşit olan birer <code>name</code> özniteliğine sahip  tüm <code>item</code> elemanlarını işleyecektir. Aşağıdaki yönerge bunu yapmaz:</p>

<eg><![CDATA[<xsl:apply-templates select="//glossary/item[@name=./@ref]"/>]]></eg>

<p>yönergesi</p>

<eg><![CDATA[<xsl:apply-templates select="//glossary/item[@name=@ref]"/>]]></eg>

<p>ile aynı anlama gelir. Bunlar, ebeveynleri <code>glossary</code> elemanları olup, <code>name</code> ve <code>ref</code> özniteliklerinin değerleri aynı olan tüm <code>item</code> elemanlarını işleyecektir.</p>

<p><function>current</function> işlevini bir <termref def="dt-pattern">Örüntü</termref> içinde kullanmak bir hatadır.</p>

<ednote><edtext>Geçerli düğümü bir değişkene atayıp işlevin yerine bu değişkeni köşeli ayraçlar içinde kullanmak da istenen sonucu verecektir.</edtext></ednote>

<proto name="unparsed-entity-uri" return-type="dizge">
  <arg type="dizge"/>
</proto>

<p><function>unparsed-entity-uri</function> işlevi, bağlamsal düğümle aynı belgede ismiyle belirtilmiş bir çözümlenmemiş öğenin tanım-yerini döndürür  (bkz, <specref ref="unparsed-entities"/>). Böyle bir öğe yoksa boş dizgeyle döner.</p>

<proto name="generate-id" return-type="dizge">
  <arg occur="opt" type="düğüm-kümesi"/>
</proto>

<p><function>generate-id</function> işlevi argümanında belirtilen düğüm kümesinin belgedeki sıraya göre ilk rastlanılan düğümünü eşsiz olarak betimleyen bir dizge ile döner. Eşsiz betimleyici bir ASCII harf ile başlamalı ve ASCII abecesayısal karakterlerinden oluşmalıdır. Bir gerçeklenim, aynı düğüm için daima aynı betimleyiciyi ve farklı düğümler için farklı betimleyicileri üretecek herhangi bir yöntemi seçmekte özgürdür. Bir gerçeklenim her dönüşümde aynı betimleyicileri üretmek zorunda değildir. Üretilmiş bir eşsiz betimleyicinin belgedeki mevcut (bu üretimin sonucu olmayan) eşsiz betimleyicilerden farklı olmak zorunda değildir. Eğer işleve belirtilen düğüm kümesi boşsa işlev boş dizge döndürür. Hiç argüman belirtilmemişse, bağlamsal düğüm öntanımlıdır.</p>

<proto name="system-property" return-type="nesne">
  <arg type="dizge"/>
</proto>

<p>Argüman bir <xnt href="&XMLNames;#NT-QName">NitelAd</xnt> olarak değerlendirilecek bir dizge olmalıdır. Bu <xnt href="&XMLNames;#NT-QName">NitelAd</xnt> ifadenin  etki alanındaki isim-alanı bildirimleri kullanılarak bir isme genişletilir. <function>system-property</function> işlevi bu isim tarafından betimlenen sistem gerecinin değeri olan nesne ile döner.  Böyle bir sistem gereci yoksa boş dizge döner.</p>

<p>Gerçeklenimlerin aşağıdaki sistem gereçlerini hepsi XSLT isim-alanında yer alacak şekilde sağlamalıdırlar:</p>

<slist>
<sitem><tt>xsl:version</tt>, işlemci tarafından gerçeklenmiş XSLT sürümünü belirten bir sayı; bu sayı bu belirtimin gerçeklenimi için 1.0 olmalıdır.</sitem>

<sitem><tt>xsl:vendor</tt>, XSLT işlemcinin üreticisini tanıtan bir dizge.</sitem>

<sitem><tt>xsl:vendor-url</tt>, XSLT işlemcinin üreticisinin adresini içeren bir dizge; genellikle üreticinin ev sayfasının adresidir.</sitem>
</slist>

<p>Üreticilerin XSLT isim-alanında başka sistem gereci tanımlamaması gerekir.</p>
</div2>
</div1>

<div1 id="message">
<head>İletiler</head>

<e:element-syntax name="message">
  <e:in-category name="yönerge"/>
  <e:attribute name="terminate">
    <e:constant value="yes"/>
    <e:constant value="no"/>
  </e:attribute>
  <e:model name="örneklenim"/>
</e:element-syntax>

<p><code>xsl:message</code> yönergesi XSLT işlemcisine özgü bir yöntemle bir ileti gönderir. <code>xsl:message</code> yönergesinin içeriği bir örneklenimdir. <code>xsl:message</code>, bir XML bölümünü oluşturacak içerik nesnelleştirilerek nesnelleştirilir. Bu XML bölümü iletinin içeriğidir.</p>

<note><p>Bir XSLT işlemci <code>xsl:message</code>  yönergesini bir uyarı kutusu  ortaya çıkararak veya bir günlük dosyasına yazarak (ya da bir konsol çıktısı olarak) gerçekleştirebilir.</p></note>

<p>Eğer <code>terminate</code> özniteliği <code>yes</code> diye bir değere sahipse, XSLT işlemcinin iletiyi gönderdikten sonra işlemi sonlandırması gerekir. Özniteliğin öntanımlı değeri <code>no</code>'dur.</p>

<p>Yerelleştirmenin uygun tek yolu, yerelleştirilmiş bilgiyi (ileti metni, vs.) bir XML belgeye koymaktır (biçembente ek bir girdi dosyası haline gelmek üzere).</p>

<example>
<p>Bir XML belgedeki Türkçe iletilerin <code>resources/tr.xml</code> dosyasında şu biçimde tutulduğunu varsayalım:</p>

<eg><![CDATA[<messages>
  <message name="problem">Bir cisim yaklaşıyor.</message>
  <message name="error">Bir sorun saptandı.</message>
</messages>
]]></eg>

<p>Bu veri modelinden hareketle bir biçembentte aşağıdaki gibi bir yerelleştirme yaklaşımında bulunulabilir:</p>

<eg><![CDATA[<xsl:param name="lang" select="'tr'"/>
<xsl:variable name="messages"
  select="document(concat('resources/', $lang, '.xml'))/messages"/>

<xsl:template name="localized-message">
  <xsl:param name="name"/>
  <xsl:message>
    <xsl:value-of select="$messages/message[@name=$name]"/>
  </xsl:message>
</xsl:template>

<xsl:template name="problem">
  <xsl:call-template name="localized-message"/>
    <xsl:with-param name="name">problem</xsl:with-param>
  </xsl:call-template>
</xsl:template>]]></eg>
</example>
</div1>

<div1 id="extension">
<head>Eklentiler</head>

<p>XSLT iki çeşit eklentiye izin verir: eklenti elemanlar ve eklenti işlevler.</p>

<p>XSLT'nin bu sürümü eklentilerin gerçeklenimlerini tanımlayan bir mekanizma sağlamaz. Bu yüzden, bir XSLT biçembendinin XSLT işlemciler arasında taşınabilir olması gerekiyorsa, böyle eklentileri kullanmaması gerekir. XSLT, bir XSLT biçembendinin, bir XSLT işlemcinin belli bir eklentiye desteği olup olmadığını saptamasını, eğer yoksa ne olacağını belirtilmesini sağlayacak mekanizmaları sağlar. Eğer bir XSLT biçembendi bu mekanizmaları kullanmakta dikkatliyse, eklentilerin getirilerinden yararlanması mümkün olacak ve herhangi bir XSLT gerçeklenimi ile hala çalışabilecektir.</p>

<div2 id="extension-element">
<head>Eklenti Elemanlar</head>

<p><termdef id="dt-extension-namespace" term="Eklenti İsim-alanı">Eleman eklenti mekanizması isim-alanlarının <term>eklenti isim-alanları</term> olarak tasarlanmasını mümkün kılar. Bir isim-alanı bir eklenti isim-alanı olarak tasarlanmışsa ve bu isim-alanından bir eleman bir örneklenimde yer alıyorsa, bu eleman bir birebir hedef eleman olmaktan ziyade bir yönerge olarak ele alınır.</termdef> İsim-alanı yönergenin anlambilgisini belirler.</p>

<note><p>Bir <code>xsl:stylesheet</code> elemanının çocuğu olmayan bir eleman bir örneklenimde yer almayacağından XSLT-dışı <termref
def="dt-top-level">tepe-seviyeden</termref> elemanlar burada tanımlanan eklenti elemanlarından sayılmazlar ve bu bölümdeki hiçbir şey onlara uygulanmaz.</p></note>

<p>Bir isim-alanı, bir eklenti isim-alanı olarak <code>xsl:stylesheet</code> elemanının <tt>extension-element-prefixes</tt> özniteliği veya bir birebir hedef elemanın <tt>xsl:extension-element-prefixes</tt> özniteliği ya da eklenti elemanı kullanılarak belirtilebilir. Bu özniteliklerin ikisi de önekleri boşluk ayraçlı bir liste olarak kabul ederler. Bu öneklerin herbiri bir eklenti isim-alanı olarak atanır. <code>extension-element-prefixes</code> veya <tt>xsl:extension-element-prefixes</tt> özniteliğinde belirtilmiş bir önek için bir isim-alanı bildiriminin olmaması bir hatadır. Öntanımlı isim-alanı (<code>xmlns</code> ile bildirilen) önek listesinde <code>#default</code> ismiyle bir eklenti isim-alanı olarak belirtilebilir. Bir isim-alanının eklente isim-alanı olarak atanması <code>extension-element-prefixes</code> veya <tt>xsl:extension-element-prefixes</tt> özniteliğinin kullanıldığı elemanın kökü olduğu alt ağaçta etkilidir; bir <code>xsl:stylesheet</code> elemanının kökü olduğu bir alt ağaç ithal edilmiş veya içerilmiş bir biçembent içermez.</p>

<p>Eğer bir XSLT işlemci belli bir eklenti elemanının gerçeklenimine sahip değilse, <function>element-available</function> işlevi bu eleman ismi için olumsuz sonuç döndürmelidir. Böyle bir eklenti elemanı nesnelleştirildiğinde XSLT işlemci <specref ref="fallback"/> bölümünde bahsedildiği gibi bir son çareye başvurmalıdır. Bir XSLT işlemci bir örneklenim gerçeklenmemiş bir eklenti elemanı içermekte olduğundan böyle bir durumda sadece bir hata rapor etmekle kalmamalıdır.</p>

<p>Eğer bir XSLT işlemci belli bir eklenti elemanının gerçeklenimine sahipse, <function>element-available</function> işlevi bu eleman ismi için olumlu sonuç döndürmelidir.</p>
</div2>

<div2>
<head>Eklenti İşlevler</head>

<p>Eğer bir <xnt href="&XPath;#NT-FunctionCall">İşlevÇağrısı</xnt> ifadesindeki bir <xnt href="&XPath;#NT-FunctionName">İşlevAdı</xnt> bir <xnt href="&XMLNames;#NT-NCName">KısaAd</xnt> değilse (yani, bir ikinokta imi içeriyorsa), bir eklenti işlev çağrısı olarak ele alınır. <xnt href="&XPath;#NT-FunctionName">İşlevAdı</xnt> değerlendirme bağlamındaki isim-alanı bildirimi killanılarık bir isme genişletilir.</p>

<p>Eğer bir XSLT işlemci belli bir eklenti işlevinin gerçeklenimine sahip değilse, <function>function-available</function> işlevi bu eleman ismi için olumsuz sonuç döndürmelidir. Böyle bir eklenti işliv bir ifade içinde kullanılmış ve bu işlev çağrılmışsa, XSLT işlemci bunu bir hata olarak bildirmelidir. Bir XSLT işlemci bir ifade gerçeklenmemiş bir eklenti işlev içermekte olduğundan böyle bir durumda sadece bir hata rapor etmekle kalmamalıdır.</p>

<p>Eğer bir XSLT işlemci belli bir eklenti işlevinin gerçeklenimine sahipse, <function>function-available</function> işlevi bu eleman ismi için olumlu sonuç döndürmelidir. Böyle bir eklenti çağrılmışsa, XSLT işlemci işlevi argümanlarıyla birlikte gerçeklenime aktarmalı ve ve gerçekleniminin döndürdüğü sonucu işlev çağrısının sonucu olarak döndürmelidir.</p>
</div2>

</div1>

<div1 id="fallback">
<head>Son Çare</head>

<e:element-syntax name="fallback">
  <e:in-category name="yönerge"/>
  <e:model name="örneklenim"/>
</e:element-syntax>

<p>Normalde, bir <code>xsl:fallback</code> elemanı nesnelleştirmesi hiçbir şey yapmaz. Ancak, bir XSLT işlemci bir yönerge elemanı için bir son çareye başvurma durumunda kalırsa ve o yönerge elemanının bir veya daha fazla sayıda <code>xsl:fallback</code> çocuğu varsa, bu <code>xsl:fallback</code> çocuklarının her birinin sırayla nesnelleştirilmesi gerekir; aksi takdirde, bir hata bildirimi yapılmalıdır. <code>xsl:fallback</code> elemanının içeriği bir örneklenimdir.</p>

<p>Eğer belli bir işlev veya eleman kullanılabilir değilse bir biçembentin nasıl davranacağını denetlemek için aşağıdaki işlevler <code>xsl:choose</code> ve <code>xsl:if</code> yönergeleriyle kullanılabilir.</p>

<proto name="element-available" return-type="mantıksal-değer">
  <arg type="dizge"/>
</proto>

<p>Argüman bir <xnt href="&XMLNames;#NT-QName">NitelAd</xnt> olarak değerlendirilmeli ve ifade etki alanındaki isim-alanı bildirimi kullanılarak bir <xtermref href="&XPath;#dt-expanded-name">genişletilmiş isim</xtermref>e genişletilmeidir.  Eğer etki alanında bir öntanımlı isim-alanı varsa, <xnt href="&XMLNames;#NT-QName">NitelAd</xnt>ın öneksiz bir isim olarak yorumlanmasında kullanılır. <function>element-available</function> işlevinin doğru sonucunu döndürmesi için gerek ve yeter koşul genişletilmiş ismin bir yönerge ismi olmasıdır. Eğer genişletilmiş ismin isim-alanı tanım-yeri, XSLT'ninkiyle aynıysa bu isim XSLT tarafından tanımlanmış bir elemana ait demektir. Aksi takdirde, bir eklenti elemandır. Eğer genişletilmiş ismin isim-alanı tanım-yeri tanımsızsa, <function>element-available</function> işlevi olumsuz sonuç döndürecektir.</p>

<proto name="function-available" return-type="mantıksal-değer">
  <arg type="dizge"/>
</proto>

<p>Argüman bir <xnt href="&XMLNames;#NT-QName">NitelAd</xnt> olarak değerlendirilmeli ve ifade etki alanındaki isim-alanı bildirimi kullanılarak bir <xtermref href="&XPath;#dt-expanded-name">genişletilmiş isim</xtermref>e genişletilmeidir. <function>function-available</function> işlevinin doğru sonucunu döndürmesi için gerek ve yeter koşul genişletilmiş ismin işlev kütüphanesindeki bir işlevin ismi olmasıdır. Eğer genişletilmiş isim tanımlı bir isim-alanına sahipse, isim bir eklenti işleve ati demektir, aksi takdirde XPath vya XSLT tarafından tanımlanmış bir işleve aittir.</p>
</div1>

<div1 id="output">
<head>Çıktı</head>

<e:element-syntax name="output">
  <e:in-category name="tepe-seviyeden-eleman"/>
  <e:attribute name="method">
    <e:constant value="xml"/>
    <e:constant value="html"/>
    <e:constant value="text"/>
    <e:data-type name="nitelikli-ad-ama-kısa-ad-değil"/>
  </e:attribute>
  <e:attribute name="version">
    <e:data-type name="ad-dizgeciği"/>
  </e:attribute>
  <e:attribute name="encoding">
    <e:data-type name="dizge"/>
  </e:attribute>
  <e:attribute name="omit-xml-declaration">
    <e:constant value="yes"/>
    <e:constant value="no"/>
  </e:attribute>
  <e:attribute name="standalone">
    <e:constant value="yes"/>
    <e:constant value="no"/>
  </e:attribute>
  <e:attribute name="doctype-public">
    <e:data-type name="dizge"/>
  </e:attribute>
  <e:attribute name="doctype-system">
    <e:data-type name="dizge"/>
  </e:attribute>
  <e:attribute name="cdata-section-elements">
    <e:data-type name="nitelikli-adlar"/>
  </e:attribute>
  <e:attribute name="indent">
    <e:constant value="yes"/>
    <e:constant value="no"/>
  </e:attribute>
  <e:attribute name="media-type">
    <e:data-type name="dizge"/>
  </e:attribute>
  <e:empty/>
</e:element-syntax>

<p>Bir XSLT işlemci hedef ağacı bir bayt dizisi olarak çıktılayabilir (böyle olması gerekmese bile; <specref ref="conformance"/> bölümüne bakınız). <code>xsl:output</code> elemanı biçembent yazarına hedef ağacın nasıl çıktılanmasını istediğini belirtebilme imkanı verir. Eğer bir XSLT işlemci hedef ağacı çıktılıyorsa, bu, <code>xsl:output</code> elemanı tarafından belirtilmiş demektir; ancak bunun böyle olması gerekli değildir.</p>

<p><code>xsl:output</code> elemanına sadece bir <termref
def="dt-top-level">tepe-seviyeden</termref> eleman olarak izin verilir.</p>

<p>The <code>method</code> özniteliğinde hedef ağacın çıktılanma yöntemi belirtilir. Değer bir  <xnt href="&XMLNames;#NT-QName">NitelAd</xnt> olmalıdır. Eğer bu  <xnt href="&XMLNames;#NT-QName">NitelAd</xnt> bir önek içermiyorsa, bu belgede belirtilmiş yöntemlerden biri olarak ele alınır ve <code>xml</code>, <code>html</code> veya <code>text</code> değerlerinden biri olmalıdır. Eğer bu  <xnt href="&XMLNames;#NT-QName">NitelAd</xnt> bir önek içeriyorsa, <specref ref="qname"/> bölümünde açıklandığı gibi bir <xtermref
href="&XPath;#dt-expanded-name">genişletilmiş isim</xtermref>e genişletilir; genişletilmiş isim çıktılama yöhtemini belirtir; bu durumdaki davranışın ne olacağı bu belgede belirtilmemiştir.</p>

<p><code>method</code> özniteliği için öntanımlı davranış şöyle seçilir. Eğer,</p>

<ulist>
<item><p>hedef ağacın kök düğümünün çocuğu varsa,</p></item>

<item><p>hedef ağacın kök düğümünün (yani, belge elemanının) ilk çocuğunun genişletilmiş isminin yerel kısmı <code>html</code> (büyük/küçük harflerin herhangi bir birleşimi olarak) ise ve isim-alanı tanım-yeri tanımsızsa ve</p></item>

<item><p>hedef ağacın kök düğümünün ilk çocuğunu önceleyen metin düğümleri sadece boşluk karakterlerinden oluşuyorsa,</p></item>
</ulist>

<p>öntanımlı çıktılama yöntemi <code>html</code> olacaktır; aksi takdirde <code>xml</code>'dir.  Öntanımlı çıktılama yöntemi eğer bir <code>xsl:output</code> elemanı belirtilmemişse veya <code>xsl:output</code> elemanı <code>method</code> özniteliksiz belirtilmişse kullanılmalıdır.</p>

<p><code>xsl:output</code> elemanının diğer öznitelikleri çıktılama yönteminin parametreleridir. Şu özniteliklere izin verilir:</p>

<ulist>
<item><p><code>version</code> çıktılama yönteminin sürümünü belirtir.</p></item>

<item><p><code>indent</code> XSLT işlemcinin hedef ağacı çıktılarken, boşluk karakterleri ekleyebileceğini belirtir; değer, ekleyebilecekse <code>yes</code> aksi takdirde <code>no</code> olmalıdır.</p></item>

<item><p><code>encoding</code>, XSLT işlemci karakter dizilerini bayt dizileri olarak çıktılarken kullanacağı karakter kodlaması için tercihi belirtirken kullanılır; değerin harf büyüklüğünün bir önemi yoktur; değer sadece [#x21-#x7E] aralığındaki karakterleri (yani basılabilir ASCII karakterleri) içerebilir; değer ya Genel Ağ Atanmış numaralar Yetkilisi <bibref ref="IANA"/> tarafından kayda geçirilmiş karakter kümelerinden biri olmalı yoksa <code>X-</code> ile başlamalıdır.</p></item>

<item><p><code>media-type</code> ile hedef ağacın çıktılanmasının sonucu olan verinin ortam türü (MIME türü) belirtilir; karakter kümesi parametresi doğrudan belirtilmemeli; bunun yerin, tepe-seviyeden ortam türü <code>text</code> olduğu takdirde, çıktılama yöntemi tarafından kullanılan asıl kodlamaya ait olan karakter kümesi parametresi eklenmelidir.</p></item>

<item><p><code>doctype-system</code> ile belge türü bildiriminde (DTD) kullanılan sistem betimleyici belirtilir.</p></item>

<item><p><code>doctype-public</code> ile belge türü bildiriminde (DTD) kullanılan genel betimleyici belirtilir.</p></item>

<item><p><code>omit-xml-declaration</code> ile XSLT işlemcinin bir XML bildirimi çıktılayıp çıktılamayacağı belirtilir; XML bildiriminin çıktılanması isteniyorsa değer <code>yes</code>, aksi takdirde <code>no</code> olmalıdır.</p></item>

<item><p><code>standalone</code> ile XSLT işlemcinin bir tekbaşına belge bildirimi çıktılayıp çıktılamayacağı belirtilir; tekbaşına belge bildiriminin çıktılanması isteniyorsa değer <code>yes</code>, aksi takdirde <code>no</code> olmalıdır.</p></item>

<item><p><code>cdata-section-elements</code> özniteliği, CDATA bölümleri halinde çıktılanacak metin düğümü çocukları olan elemanların isimlerini liste halinde belirtmek için kullanılır.</p></item>
</ulist>

<p>Her özniteliğin her çıktılama yöntemi için anlamı ayrı ayrı çıktılama yöntemlerinin açıklamalarında açıklanacaktır.  Çıktılama yöntemi açıklamalarında yer verilmemiş öznitelikler o çıktılama yöntemi için uygulanabilir değillerdir.</p>

<p>Bir biçembent çık sayıda <code>xsl:output</code> elemanı içerebileceği gibi, ithal ettiği veya içerdiği biçembentlerin her birinde de çok sayıda <code>xsl:output</code> elemanı olabilir. Bir biçembentte yer alan tüm <code>xsl:output</code> elemanları tek bir etkin <code>xsl:output</code> elemanı olarak birleştirilir. <code>cdata-section-elements</code> özniteliği için etkili değer belirtilmiş değerlerin birleşimidir. Diğer öznitelikler için etkili değer, en yüksek <termref def="dt-import-precedence">ithal önceliği</termref> ile belirtilmiş olan değerdir. Bir öznitelik için böyle birden fazla değerin varlığı bir hatadır. Bir XSKLT işlemci hatalı raporlayabilir, raporlamıyorsa, biçembentte son yer alan değeri kullanarak hatadan kurtulmalıdır. Özniteliklerin öntanımlı değerleri <code>xsl:output</code> elemanları birleştirildikten sonra saptanır; farklı çıktılama yöntemleri için bazı özniteliklerin öntanımlı değerleri farklı olabilir.</p>

<div2>
<head>XML Çıktılama Yöntemi</head>

<p><code>xml</code> çıktılama yöntemi, hedef ağacı bir iyi biçimli XML harici genel çözümlü öğe olarak çıktılar. Eğer hedef ağcın kök düğümü tek bir çocuk elemana sahipse ve hiç metin düğümü çocuğu yoksa, öğenin ayrıca iyi biçimli XML belge öğesi olması gerekir. Şunun gibi sıradan bir XML belge sarmalayıcı içindeki bir öğeye atıfta bulunurken,</p>

<eg><![CDATA[<?xml version="]]><var>xml-sürümü</var><![CDATA["?>
<!DOCTYPE doc [
<!ENTITY e SYSTEM "]]><var>öğenin-yeri</var><![CDATA[">
]>
<doc>&e;</doc>]]></eg>

<p><var>öğenin-yeri</var> ile öğenin dosya sistemindeki yeri, <var>xml-sürümü</var> ile de öğenin XML sürümü belirtiliyorsa, atıfta bulunulan elemanın bir bütün olarak <bibref ref="XMLNAMES"/> veya <bibref ref="XMLNAMES11"/> ile uyumlu bir iyi biçimli XML belge olması gerekir. Ek olarak, yeni ağaç, öğenin <specref
ref="data-model"/> bölümünde belirtildiği gibi bir XML belge olarak çözümlenmesiyle oluşmuşsa, belge elemanı kaldırıldıktan sonra, onun çocuklarını kök düğümün çocukları yaparak oluşturulan yeni ağaç aşağıdaki olasılıkların dışında hedef ağaçla aynı olacaktır:</p>

<ulist>
<item><p>Öznitelik ve isim-alanı düğümlerinin sırası iki ağaçta farklı olabilir.</p></item>

<item><p>yeni ağaç, hedef ağaçta mevcut olmayan isim-alanı düğümleri içerebilir.</p>

<note><p>Bir XSLT işlemci hedef ağacın XML olarak çıktılanması durumunda isim-alanı bildirimlerini eklemek ihtiyacı duyabilir.</p></note>
</item>

<item><p>Düğümlerin temel tanım-yerleri iki ağaçta farklı olabilir.</p></item>
</ulist>

<p>Eğer XSLT işlemci, <code>doctype-system</code> özniteliği sebebiyle bir belge türü bildirimli veya <code>standalone</code> özniteliği sebebiyle tekbaşına belge bildirimli çıktılama yapıyorsa, çıktının bir iyi biçimli XML belge olması ve yukarıdaki gereksinimlerin, herhangi bir sarmalayıcı olmaksızın, DTD'yi işleme sokmayan bir XML işlemci kullanılarak belgenin doğrudan çözümlenmesiyle oluşturulan ağaca uygulanması gerekir.</p>

<note>
<p>DTD'nin işlenmesi, öznitelik öntanımlaması sebebiyle, ağaçta ek özniteliklerin yer almasına sebep olabilir.</p>
</note>

<p><code>version</code> özniteliği hedef ağacı çıktılarken kullanılacak XML sürümünü belirtmek için kullanılır. Eğer XSLT işlemci bu XML sürümünü desteklemiyorsa, desteklediği XMl sürümünü kullanmalıdır.  Eğer çıktı xML bildirimini içerecekse, bu bildirimde XSLT işlemcinin desteklediği sürüm numarasına karşı düşen çıktılama yapılmalıdır. Öntanımlı değer 1.0'dır. Eğer değer 1.1 ise ve XSLT işlemci XML 1.1 ve XML 1.1 için İsim-alanlarını destekliyorsa, çıktıya aşağıdaki kısıtlamalar uygulanır:</p>

<ulist>
<item><p>Bildirimsiz önekler yer almamalıdır</p></item>
<item><p>Unicode normalleştirmesi yer almamalıdır.</p></item>
</ulist>

<p><code>encoding</code> özniteliğiyle hedef ağacı çıktılamakta kullanılacak karakter kodlaması tercihi belirtilir. XSLT işlemcilerinin <code>UTF-8</code> ve <code>UTF-16</code> değerlerini kabul etmeleri gerekir. Diğer değerler için, eğer XSLT işlemci bunları desteklemiyorsa bunu hata olarak raporlayabiyir, raporlamıyorsa, <code>UTF-8</code> veya <code>UTF-16</code> kodlanmış çıktılama yapmalıdır. XSLT işlemci, <bibref ref="XML"/> ve <bibref ref="XML11"/> önergelerinin <xnt href="&XML;#NT-EncName">KodlamaAdı</xnt> sözdizimi ile eşleşmeyen kodlama isimlerini kullanmaması gerekir. <code>encoding</code> özniteliği kullanılmamışsa, XSLT işlemcinin <code>UTF-8</code> veya <code>UTF-16</code> kodlanmış çıktılama yapması gerekir.</p>

<p>Hedef ağacın, XSLT işlemcinin çıktılama için kullandığı kodlamada bulunmayan bir karakteri içermesi olasıdır. Bu durumda, eğer karakter XML'in karakter gönderimlerini tanıdığı bir bağlamda yer alıyorsa (örn, bir öznitelik değerinde veya bir metin düğümünde),  karakterin bir karakter gönderimi olarak çıktılanması gerekir; aksi takdirde (örn, karakter bir eleman isminde yer alıyorsa), XSLT işlemci hatayı raporlamalıdır.</p>

<p>Eğer <code>indent</code> özniteliği <code>yes</code> değeri ile kullanılmışsa, <code>xml</code> çıktılama yöntemi, sonucun göze hoş görünecek şekilde girintilenmesi için hedef ağaçta mevcut boşluk karakterlerine ek olarak (muhtemelen biçembent ve kaynak belgedeki boşluk ayıklamaya uygun olarak), ek boşluklar çıktılayabilir; eğer özniteliğin değeri olarak <code>no</code> belirtilmişse, ilave bir boşluk çıktılanmayacaktır. Öntanımlı değer <code>no</code>'dur. <code>xml</code> çıktılama yöntemi ek boşlukları çıktılamak için bir algoritma kullanmalıdır; bu algoritma,
boşluklar çıktıdan ayıklanırken, sadece <code>xsl:text</code> elemanlarından oluşan boşlukları korunacak elemanlar listesiyle <specref ref="strip"/> bölümünde açıklandığı gibi ayıklanıyorsa, ek boşlukların çıktılanması ile çıktılanmaması arasında bir fark olmayacak şekilde çıktılamayı sağlamalıdır.</p>

<note><p>Karışık içerikli eleman türleri içeren belge türleri için <code>indent="yes"</code> kullanmak iyi sonuç vermeyecektir.</p></note>

<p><code>cdata-section-elements</code> özniteliği boşluk ayraçlı olarak <xnt href="&XMLNames;#NT-QName">NitelAd</xnt>lardan oluşan bir liste içerebilir. Her <xnt href="&XMLNames;#NT-QName">NitelAd</xnt> yer aldığı <code>xsl:output</code> elemanında etkili olan isim-alanı bildirimleri kullanılarak bir genişletilmiş isme genişletilir; eğer bir öntanımlı isim-alanı varsa, öneksiz <xnt href="&XMLNames;#NT-QName">NitelAd</xnt>lar kullanılır. Genişletme işlemi çok sayıda <code>xsl:output</code> elemanı tek bir <code>xsl:output</code>  elemanı olarak birleştirilmeden önce yapılır. Eğer bir metin düğümünün ebeveyninin genişletilmiş ismi bu listenin bir üyesiyse, metin düğümü bir CDATA bölümü olarak çıktılanacaktır. Örneğin,</p>

<eg><![CDATA[<xsl:output cdata-section-elements="example"/>]]></eg>

<p>yönergesi, biçembentte</p>

<eg><![CDATA[<example>&lt;foo></example>]]></eg>

<p>veya</p>

<eg>&lt;example>&lt;![CDATA[&lt;foo>]]&gt;&lt;/example></eg>

<p>olarak yer alan bir birebir hedef elemanının şöyle çıktılanmasına sebep olacaktır:</p>

<eg>&lt;example>&lt;![CDATA[&lt;foo>]]&gt;&lt;/example></eg>

<p>Eğer metin düğümü <code>]]&gt;</code> dizgesini içeriyorsa, açık olan CDATA bölümü <code>]]</code> karakterlerinden sonra kapanır ve <code>&gt;</code> karakterinden önce yenisi açılır. Örneğin, bir birebir hedef elemanı biçembentte şöyle yer alıyor olsun:</p>

<eg>&lt;example&gt;]]&amp;gt;&lt;/example&gt;</eg>

<p>Bunun çıktısı şöyle olurdu:</p>

<eg>&lt;example&gt;&lt;![CDATA[]]]]&gt;&lt;![CDATA[&gt;]]&gt;&lt;/example&gt;</eg>

<p>Eğer metin düğümü hedef ağacı çıktılamakta kullanılan karakter kodlaması ile gösterilemeyecek bir karakter içeriyorsa, açık olan CDATA bölümü bu karakterden önce kapatılmalı, karakter bir karakter veya öğe gönderimi olarak çıktılandıktan sonra metnin kalanı için yeni bir CDATA bölümü açılmalıdır.</p>

<p>CDATA bölümleri, <code>cdata-section-elements</code> özniteliğinde açıkça CDATA bölümü olarak çıktılanmak üzere belirtilmiş olan metin düğümleri haricinde kullanılmamalıdır.</p>

<p><code>xml</code> çıktılama yönteminin, <code>omit-xml-declaration</code> özniteliği <code>yes</code> değeri ile kullanılmış olmadıkça bir XML bildirimi çıktılaması gereklidir. XML bildirimi hem hem sürüm bilgisi hem de karakter kodlaması belirtimini içermelidir. Eğer <code>standalone</code> özniteliği belirtilmişse, bir tekbaşına belge bildiriminin de <code>standalone</code> özniteliğinde belirtilen değerle XML bildiriminde yer alması gerekir. Aksi takdirde, XML bildirimi bir tekbaşına belge bildirimi içermemelidir. Bu kural, hem XML bildirimine (bir belge öğesinin başında bulunur) hem de metin bildirimine (bir harici genel çözümlü öğenin başında bulunur) uygulanır.</p>

<p>Eğer <code>doctype-system</code> özniteliği belirtilmişse, <code>xml</code> çıktılama yöntemi, ilk elemandan hemen önce bir belge türü bildirimi çıktılayacaktır. <code>&lt;!DOCTYPE</code>'i takibeden isim ilk elemanın ismiyle aynı olmak zorundudır. Bir de <code>doctype-public</code> özniteliği belirtilmişse, <code>xml</code> çıktılama yöntemi, bir <code>PUBLIC</code> ile bunu izleyen bir genel betimleyici ve bir sistem betimleyicisi çıktılayacaktır; aksi takdirde, bir <code>SYSTEM</code> ile bunu izleyen bir sistem betimleyicisi çıktılayacaktır. Dahili altküme boş olmalıdır. <code>doctype-system</code> özniteliği belirtilmiş olmadığı takdirde, <code>doctype-public</code> özniteliği yok sayılmalıdır.</p>

<p><code>media-type</code> özniteliği <code>xml</code> çıktılama yöntemi için uygulanabilir olup öntanımlı değeri <code>text/xml</code>'dir.</p>

</div2>

<div2>
<head>HTML Çıktılama Yöntemi</head>

<p><code>html</code> çıktılama yöntemi hedef ağacı HTML olarak çıktılar; örnek:</p>

<eg>&lt;xsl:stylesheet version="1.0"
                xmlns:xsl="&XSLT.ns;"><![CDATA[

<xsl:output method="html"/>

<xsl:template match="/">
  <html>
   <xsl:apply-templates/>
  </html>
</xsl:template>

...

</xsl:stylesheet>]]></eg>

<p><code>version</code> özniteliği ile HTML sürümü belirtilir ve öntanımlı değeri <code>4.0</code> olup, çıktının HTML 4.0 <bibref ref="HTML"/> önergesi ile uyumlu olacağını belirtir.</p>

<p><code>html</code> çıktılama yöntemi, genişletilmiş ismi tanımsız bir isim-alanı tanım-yerine sahip olmadıkça bir elemanı <code>xml</code>  çıktılama yönteminden farklı bir biçimde çıktılamamalıdır; genişletilmiş ismi tanımlı bir isim-alanı tanım-yerine sahip bir eleman XML olarak çıktılanmalıdır. Eğer bir elemanın genişletilmiş ismi tanımsız isim-alanı tanım-yerine sahipse, ancak genişletilmiş ismin yerel kısmı bir HTML eleman olarak tanınmıyorsa, <code>span</code> gibi bir satıriçi eleman olarak boş olmayacak şekilde çıktılanmalıdır.</p>

<p><code>html</code> çıktılama yöntemi, boş elemanlar için bir bitiş etiketi çıktılamamalıdır. HTML 4.0 için boş elemanlar,
<code>area</code>, <code>base</code>, <code>basefont</code>,
<code>br</code>, <code>col</code>, <code>frame</code>,
<code>hr</code>, <code>img</code>, <code>input</code>,
<code>isindex</code>, <code>link</code>, <code>meta</code> ve
<code>param</code> elemanlarıdır. Örneğin bir eleman biçembette <code>&lt;br/></code> veya <code>&lt;br>&lt;/br></code>  biçiminde yazılmışsa, çıktı <code>&lt;br></code> olacaktır.</p>

<p><code>html</code> çıktılama yöntemi, HTML elemanlarının isimlerini harf büyüklüğüne duyarsız biçimde algılamalıdır. Örneğin, <code>br</code>, <code>BR</code> veya <code>Br</code> HTML için <code>br</code> elemanı olup bitiş elemanı olmaksızın çıktılanmalıdır.</p>

<p><code>html</code> çıktılama yöntemi, <code>script</code> ve <code>style</code> elemanlarının içeriği için önceleme uygulamamalıdır. Örneğen bir biçembentte bir birebir hedef eleman şöyle yer alıyor olsun:</p>

<eg><![CDATA[<script>if (a &lt; b) foo()</script>]]></eg>

<p>veya</p>

<eg><![CDATA[<script><![CDATA[if (a < b) foo()]]]]><![CDATA[></script>]]></eg>

<p>için çıktı şöyle olacaktır:</p>

<eg><![CDATA[<script>if (a < b) foo()</script>]]></eg>

<p><code>html</code> çıktılama yöntemi, öznitelik değerlerinde yer alan <code>&lt;</code> karakterlerini öncelememelidir.</p>

<p>Eğer <code>indent</code> özniteliğini değeri <code>yes</code> ise, <code>html</code> çıktılama yöntemi, HTML tarayıcısının çıktıyı oluşturma yöntemini değiştirmediği sürece hedef ağaca çıktılanan boşluk karakterlerine ekleme yapabileceği gibi bunları silebilir de.</p>

<p><code>html</code> çıktılama yöntemi, HTML 4.0 Önergesinin <loc
href="http://www.w3.org/TR/REC-html40/appendix/notes.html#h-B.2.1">B 2.1</loc> ek bölümünde önerilen yöntemi kullanarak tanım-yeri (URI) öznitelik değerlerindeki ASCII olmayan karakterleri öncelemelidir.</p>

<p><code>html</code> çıktılama yöntemi, bir karakteri, eğer çıktılama yönteminde kullanılan HTML sürümünde tanımlıysa, bir karakter öğesi gönderimi kullanarak çıktılayabilir.</p>

<p><code>html</code> çıktılama yöntemi, işlem yönergelerini <code>?&gt;</code> ile değil, <code>&gt;</code> ile sonlandırmalıdır.</p>

<p><code>html</code> çıktılama yöntemi, mantıksal değerli öznitelikleri (değerleri olarak kendi isimleri verilmiş öznitelikler) kısaltılmış biçimde çıktılamalıdır. Örneğin başlangıç etiketi,</p>

<eg><![CDATA[<OPTION selected="selected">]]></eg>

<p>biçiminde yazılmışsa, bunun çıktısı şöyle olurdu:</p>

<eg><![CDATA[<OPTION selected>]]></eg>

<p><code>html</code> çıktılama yöntemi, bir öznitelik değerinde <code>{</code> karakterinin önünde bir <code>&amp;</code> karakteri yer alıyorsa bu karakteri öncelememelidir (HTML 4.0 Önergesinin <loc
href="http://www.w3.org/TR/REC-html40/appendix/notes.html#h-B.7.1.1">B 7.1.1</loc> ek bölümüne bakınız). Örneğin bir biçembentte bir başlangıç etiketi şöyle yer alıyor olsun:</p>

<eg><![CDATA[<BODY bgcolor='&amp;{{randomrbg}};'>]]></eg>

<p>Bu örneklenim şöyle çıktılanmalıdır:</p>

<eg><![CDATA[<BODY bgcolor='&{randomrbg};'>]]></eg>

<p><code>encoding</code> özniteliği ile tercih edilen karakter kodlaması belirtilir. Bir <code>HEAD</code> elemanı varsa <code>html</code> çıktılama yöntemi bu elemanın başlangıç etiketinin hemen ardına kullanılan karakter kodlamasının belirtildiği bir <code>META</code> elemanını eklemesi gerekir. Örnek:</p>

<eg><![CDATA[<HEAD>
<META http-equiv="Content-Type" content="text/html; charset=EUC-JP">
...]]></eg>

<p>Hedef ağacın, XSLT işlemcinin çıktılama için kullandığı karakter kodlamasında bulunmayan bir karakteri içermesi olasıdır. Eğer bu karakter, HTML'nin karakter gönderimlerini tanıdığı bir bağlamda yer alıyorsa, karakter bir karakter öğesi gönderimi olarak veya onluk sayılı karakter gönderimi olarak çıktılanmalıdır; aksi takdirde (örneğin, bir <code>script</code> veya <code>style</code> elemanında veya bir açıklamada), XSLT işlemci durumu hata olarak bildirmelidir.</p>

<p>Eğer <code>doctype-public</code> veya <code>doctype-system</code> öznitelikleri belirtilmişse, <code>html</code> çıktılama yönteminin ilk elemandan hemen önce bir belge türü bildirimi çıktılaması gerekir. Bu bildirimde, <code>&lt;!DOCTYPE</code> dizgesinden sonra gelen isim <code>HTML</code> veya <code>html</code> olmalıdır. <code>doctype-public</code> özniteliği belirtilmişse, öznitelik değerini (genel betimleyici) <code>PUBLIC</code> ibaresinden sonra eklemelidir; <code>doctype-system</code> özniteliği de ayrıca belirtilmişse, bunun değerinin (sistem betimleyici) de genel betimleyicinin ardından çıktılanması gerekir. Eğer <code>doctype-system</code> özniteliği, <code>doctype-public</code> olmaksızın tek başına belirtilmişse, çıktılama yöntemi bu değeri <code>SYSTEM</code> ibaresinin ardına ekleyerek çıktılamalıdır.</p>

<p><code>media-type</code> özniteliği de <code>html</code> çıktılama yönteminde uygulanabilir olup öntanımlı değeri <code>text/html</code>'dir.</p>

</div2>

<div2>
<head>Metin Çıktılama Yöntemi</head>

<p><code>text</code> çıktılama yöntemi, hedef ağacı çıktıda, hedef ağaçtaki her metin düğümünün değerini  belgedeki sıraya uygun olarak ve buna herhangi bir önceleme uygulamaksızın çıktılamak suretiyle oluşturur.</p>

<p><code>media-type</code> özniteliği <code>text</code> çıktılama yönteminde uygulanabilir olup öntanımlı değeri <code>text/plain</code>'dir..</p>

<p><code>encoding</code> özniteliği ile <code>text</code> çıktılama yönteminin karakter dizilerini bayt dizilerine dönüştürürken kullanacağı karakter kodlaması belirtilir. Öntanımlı değer sisteme bağlıdır. Eğer hedef ağaç, XSLT işlemcinin çıktılama için kullandığı karakter kodlamasıyla ifade edilemeyen bir karakter içeriyorsa, XSLT işlemcinin bunu bir haka olarak bildirmesi gerekir.</p>

</div2>

<div2 id="disable-output-escaping">
<head>Çıktı Önceleniminin İptal Edilmesi</head>

<p>Normalde, <code>xml</code> çıktılama yöntemi &amp; ve &lt; karakterlerini (ve olası diğer karakterleri) metin düğümlerini çıktılarken önceler. Bu, çıktının iyi biçimli XML olması için gereklidir. Bununla birlikte, bazan çıktının iyi biçimli XML olarak çıktılanmaması daha uygun olabilir; örneğin, çıktı, sonradan XML'e duyarlı olmayan bir süreç tarafından iyi biçimli XML'e dönüştürüleceği düşünülen yetersiz biçimlenmiş bölümler içerebilir. Bu amaca uygun olarak, XSLT, çıktı önceleniminin iptalini mümkün kılan bir mekanizma sağlar. <code>xsl:value-of</code> ve <code>xsl:text</code> elemanlarının <code>disable-output-escaping</code> diye, <code>no</code> öntanımlı olmak üzere değer olarak sadece <code>yes</code> veya <code>no</code> kabul eden bir öznitelikleri olabilir; eğer değer <code>yes</code> ise, <code>xsl:value-of</code> veya <code>xsl:text</code> ile üretilen metin düğümü herhangi bir öncelenim uygulanmaksızın çıktılanacaktır. Örnek:</p>

<eg><![CDATA[<xsl:text disable-output-escaping="yes">&lt;</xsl:text>]]></eg>

<p>yönergesi tek bir <code>&lt;</code> karakteri üretecektir.</p>

<p>Bir kök düğüm, öncelenim, kök düğümünün astsalları için iptal edilmiş durumda bir <code>xsl:copy-of</code> elemanı kullanılarak kopyalanırken (bkz <specref ref="copy-of"/>), öncelenim, metin düğümünün çıktılanan kopyası için ayrıca iptal edilmiş olmalıdır. Örnek:</p>

<eg><![CDATA[<xsl:variable name="x">
  <xsl:text disable-output-escaping="yes">&lt;</xsl:text>
</xsl:variable>
<xsl:copy-of select="$x"/>]]></eg>

<p>Bu örneklenim &amp;lt; değil &lt; çıktılayacaktır.</p>

<p>Bir metin düğümü için çıktı önceleniminin iptal edilmiş oluşunun hedef ağaçta metin düğümünün çıktılanması amacının dışında kullanılması bir hatadır. Bu bakımdan, bir açıklama, işlem yönergesi veya bir öznitelik düğümünü üretmek için bir <code>xsl:value-of</code> veya <code>xsl:text</code> elemanını, çıktı öncelenimini iptal ederek kullanmak bir hatadır; ayrıca, eğer hedef ağaç bölümü öncelenimin iptal edildiği bir metin düğümü içeriyorsa, bir <termref
def="dt-result-tree-fragment">hedef ağaç bölümünü</termref> bir sayı veya dizgeye dönüştürmek de bir hatadır. Her iki durumda da, bir XSLT işlemci htayı raporlayabilir, raporlamıyorsa, <code>disable-output-escaping</code> özniteliğini yoksayarak hatadan kurtulmalıdır.</p>

<p><code>disable-output-escaping</code> özniteliği <code>xml</code> çıktılama yönteminden başka <code>html</code> çıktılama yönteminde de kullanılabilir. <code>text</code> çıktılama yönteminde herhangi bir çıktı öncelenimi zaten yapılmadığından, <code>disable-output-escaping</code> özniteliği yoksayılır.</p>

<p>Bir XSLT işlemcinin çıktı öncelenimini iptal edebileceği tek durum, hedef ağacın nasıl çıktılanacağını denetleyebildiği durumdur. Yine de, bu hep böyle olmayabilir. Örneğin, hedef ağaç çıktılanmak yerine başka bir hedef ağacın çıktılanmasına kaynaklık edebilir. Bu durumda XSLT işlemcinin çıktı önceleniminin iptal edilmesini desteklemesi gerekmez. Eğer bir <code>xsl:value-of</code> veya <code>xsl:text</code> elemanı çıktı öncelenimi iptal edilerek kullanılmışsa ve XSLT işlemci de bunu desteklemiyorsa, XSLT işlemci durumu hata olarak raporlayabilir, raporlamıyorsa, çıktı öncelenimini iptal etmeyerek hatadan kurtulmalıdır.</p>

<p>Eğer çıktı öncelenimin iptali, XSLT işlemcinin çıktılama için kullandığı kodlama tarafından desteklenmeyen bir karakter için kullanılmışsa, XSLT işlemci durumu bir hata olarak raporlayabilir, raporlamıyorsa, çıktı öncelenimini iptal etmeyerek hatadan kurtulmalıdır.</p>

<p>Çıktı önceleniminin iptali bütün XSLT işlemcilerle çalışmayabileceğinden ve XML için çıktı iyi biçimli olmayabileceğinden sadece başka çare yoksa kullanılmalıdır.</p>
</div2>
</div1>

<div1 id="conformance">
<head>Uyumluluk</head>

<p>Bir uyumlu XSLT işlemci, bir biçembendi bir kaynak ağacı bir hedef ağaca bu belirtimde belirtildiği gibi dönüştürmek için kullanabilen işlemcidir. Bir uyumlu XSLT işlemciden beklenen, sonucu XML veya bir başka biçimde çıktılayabiliyor olması değildir.</p>

<note><p>XSLT işlemci üreticilerine, işlemcilerinin hedef ağacı XML olarak çıktılarken uyumlu davranmakta olduğunu doğrulayacak bir yöntem sunmaları   veya hedef ağaca DOM veya SAX gibi bir standart yazılım geliştirme arayüzü üzerinden erişmeye imkan sağlamaları önemle tavsiye edilir.</p></note>

<p>Bir uyumlu XSLT işlemci, bu belgede özellikle bir XSLT işlemci tarafından bildirilmemesinin istendiği durumlar haricindeki bütün hataları bildirmesi gerekir. Bir uyumlu XSLT işlemciden beklenen, bildirdiği hatalı durumdan  kurtarabilmesi değildir, ama kurtarabilirse iyi olur.</p>

<p>Bir uyumlu XSLT işlemci, bir biçembendin işlenmesi için gereken sistem kaynaklarının sınırları konusunda belirleyici olmayabilir.</p>

</div1>

<div1 id="notation">
<head>Gösterim</head>

<p>Her XSLT tanımlı eleman türünün belirtiminde önce o eleman türünden elemanlar için bir model teşkil edecek şekilde bir sözdizimi özeti verilmiştir. Bu özet sözdizimi gösterimine anlam yükleme işlemi şöyle yapılmıştır:</p>

<ulist>

<item><p>Kullanımı zorunlu bir öznitelik kalın yazıyla belirtilmiştir.</p></item>

<item><p>Bir öznitelik değeri olarak görünen dizge, özniteliğin izin verilen değerlerini belirtir. Eğer bir değer, kaşlı ayraçlar arasına alınmışsa, öznitelik değeri bir <termref def="dt-attribute-value-template">öznitelik değeri örneklenimi</termref> (bazı hata iletilerinde AVT şeklinde bir kısaltma olarak karşınıza çıkabilir) olarak ele alınır ve kaşlı ayraçlar arasında yer alan dizge, öznitelik değeri örnekleniminden elde edilen sonucun izin verilen değerlerini belirtir. Birden fazla olası değer aralarına <code>|</code> karakteri konarak belirtilir. Tırnak içinde belirtilen dizgeler öznitelik için sadece bu değerlere eşit değerlere izin verildiğini gösterir. Tırnak içine alınmamış ve eğik yazıyla belirtilmiş isimler belli bir değer türünü belirtir.</p></item>

<item><p>Eğer bir elemanın içeriği özellikle boş değilse, izin verilen içerik bir XML açıklaması olarak belirtilmiştir; açıklama içeriğinde XML'deki eleman türü bildirimide kullanılan yöntem kullanılmıştır; bu içerikten olarak <var>örneklenim</var>, metin düğümlerinin, birebir hedef elemanların, eklenti elemanların ve <tt>yönerge</tt> grubundaki XSLT elemanlarının bir karışımını ifade eder; <tt>tepe-seviyeden-eleman</tt> ise <termref def="dt-top-level">tepe-seviyeden</termref> eleman grubuna giren XSLT elemanlarına izin verildiği anlamındadır.</p></item>

<item><p>Eleman isminden önceki açıklama satırı elemanın hangi eleman grubunda kullanılabildiğini belirtir; ya <tt>yönerge</tt> ya <tt>tepe-seviyeden-eleman</tt> ya da her ikisi birden olabilir. Eleman grubu, elemanın içerikte bir örneklenim olarak mı yoksa bir tepe-seviyeden bir eleman olarak mı yer alabileceğini belirtir.</p></item>
</ulist>
</div1>
</body>

<back>
<div1 id="bibref">
<head>Kaynakça</head>
<div2>
<head>Uyulması Gerekenler</head>

<blist>

<bibl id="XML" key="XML" href="&XML;">World Wide Web Consortium, <titleref>Genişletilebilir İmlenim Dili (XML) 1.0</titleref>, W3C Önergesi, Uyulması zorunlu İngilizce sürümü <loc href="&w3c;/TR/xml"/> adresindedir.</bibl>

<bibl id="XMLNAMES" key="XML Adları" href="&XMLNames;">World Wide Web
Consortium, <titleref>XML 1.0'da İsim-alanları</titleref>, W3C Önergesi, Uyulması zorunlu İngilizce sürümü <loc href="&w3c;/TR/xml-names"/> adresindedir.</bibl>

<bibl id="XML11" key="XML 1.1" href="&XML11;">World Wide Web Consortium, <titleref>Genişletilebilir İmlenim Dili (XML) 1.1</titleref>, W3C Önergesi, Uyulması zorunlu İngilizce sürümü  <loc href="&w3c;/TR/xml11/"/> adresindedir.</bibl>

<bibl id="XMLNAMES11" key="XML Adları 1.1" href="&XMLNames11;">World Wide Web Consortium, <titleref>XML 1.1'de İsim-alanları</titleref>, W3C Önergesi, Uyulması zorunlu İngilizce sürümü <loc href="&w3c;/TR/xml-names11/"/> adresindedir.</bibl>

<bibl id="XPATH" key="XPath" href="&XPath;">World Wide Web Consortium, <titleref>XML Adresleme Dili</titleref>, W3C Önergesi, Uyulması zorunlu İngilizce sürümü <loc href="&w3c;/TR/xpath"/> adresindedir.</bibl>

</blist>
</div2>
<div2>
<head>Diğerleri</head>

<blist>

<bibl id="CSS2" key="CSS2" href="&w3c;/TR/CSS2/">World Wide Web Consortium.  <titleref>Basamaklı Biçembentler, 2. seviye (CSS2)</titleref>.  W3C Önergesi.</bibl>

<bibl id="DSSSL" key="DSSSL">Uluslararası Standartlaşım Örgütü, Uluslararası Elektroteknik Komisyonu. <titleref>ISO/IEC 10179:1996.  Belge Biçem Anlambilimi ve Belirtim Dili (DSSSL)</titleref>.  Uluslararası Standart.</bibl>

<bibl id="HTML" key="HTML" href="&w3c;/TR/html40/">World Wide Web Consortium. <titleref>HTML 4.0 Belirtimi</titleref>. W3C Önergesi.</bibl>

<bibl id="IANA" key="IANA" href="ftp://ftp.isi.edu/in-notes/iana/assignments/character-sets">Internet Assigned Numbers Authority. <titleref>Karakter Kümeleri</titleref>.</bibl>

<bibl id="RFC2278" key="RFC2278" href="http://www.ietf.org/rfc/rfc2278.txt">N. Freed, J. Postel.  <titleref>IANA Karakter Kümesi Sicil kaydı İşlemleri</titleref>.  IETF RFC 2278.</bibl>

<bibl id="RFC2376" key="RFC2376" href="http://www.ietf.org/rfc/rfc2376.txt">E. Whitehead, M. Murata.  <titleref>XML Ortam Türleri</titleref>. IETF RFC 2376. </bibl>

<bibl id="RFC2396" key="RFC2396" href="http://www.ietf.org/rfc/rfc2396.txt">T. Berners-Lee, R. Fielding ve L. Masinter.  <titleref>TekBiçimli Özkaynak Betimleyiciler (URI): Soysal Sözdizimi</titleref>. IETF RFC 2396.</bibl>

<bibl id="UNICODE-TR10" key="UNICODE TR10" href="http://www.unicode.org/unicode/reports/tr10/index.html">Unicode Consortium. <titleref>Unicode Teknik Rapor #10. Unicode Collation
Algorithm</titleref>.  Unicode Technical Report.</bibl>

<bibl id="XHTML" key="XHTML" href="&w3c;/TR/xhtml1/">World Wide Web Consortium. <titleref>XHTML 1.0: Genişletilebilir HiperMetin İmlenim Dili.</titleref> W3C Önergesi.</bibl>

<bibl id="XPTR" key="XPointer" href="&w3c;/TR/xptr/">World Wide Web
Consortium. <titleref>XML Gösterici Dili (XPointer).</titleref> W3C Çalışma
Taslağı.</bibl>

<bibl id="XMLSTYLE" key="XML Stylesheet" href="&XMLSTYLE;">World Wide Web Consortium. <titleref>Biçembentlerin XML Belgelerle İlişkilendirilmesi</titleref> W3C Önergesi, Uyulması zorunlu İngilizce sürümü <loc href="&w3c;/TR/xml-stylesheet"/> adresindedir.</bibl>

<bibl id="XSL" key="XSL" href="&w3c;/TR/xsl/">World Wide Web Consortium.  <titleref>Genişletilebilir Biçembent Dili (XSL).</titleref>  W3C Önergesi.</bibl>

</blist>

</div2>
</div1>

<div1 id="element-syntax-summary">
<head>Elemanların Özet Sözdizimleri</head>

<e:element-syntax-summary/>

</div1>

<inform-div1 id="dtd">
<head>XSLT Biçembentlerinde DTD Bölümü</head>

<note><p>XML 1.0 DTD'leri XML isim-alanlarını desteklemediğinden bu DTD Bölümü bilgilendirici niteliktedir ve bu bakımdan bir XSLT biçembendinde izin verilen yapıyı gerektiği gibi açıklayamaz.</p></note>

<p>Aşağıdaki öğe, belli bir hedef DTD'sinin nesnel sonucunu oluşturacak XSLT biçembentleri için bir DTD oluşturmakta kullanılabilir. Öğeye atıfta bulunmadan önce, biçembent DTD'si izin verilen hedef eleman türlerini listeleyen bir <code>result-elements</code> değergeç öğesi tanımlamalıdır. Örnek:</p>

<eg><![CDATA[<!ENTITY % result-elements "
  | fo:inline-sequence
  | fo:block
">]]></eg>

<p>Böyle hedef elemanları <tt>xsl:use-attribute-sets</tt> ve <tt>xsl:extension-element-prefixes</tt> özniteliklerine sahip olarak bildirilmelidir. Aşağıdaki öğe, <code>result-element-atts</code> değergecini bu amaçla bildirmektedir. XSLT'nin hedef elemanlar için izin verdiği içerik,  <code>%template;</code> içerik modeliyle aşağıda öğede bildirilen XSLT elemanları için izin verilenlerle aynıdır.  DTD, hedef DTD'nin kısıtlamalarına uygun olarak <code>%template;</code>'den daha kısıtlayıcı içerik modelleri kullanabilir.</p>

<p>XSLT isim-alanından farklı isim-alanlarındaki tepe-seviyeden elemanlara da izin vermek için DTD <code>non-xsl-top-level</code> diye bir değergeç öğesi tanımlayabilir.</p>

<p>Bu DTD'deki <tt>xsl:</tt> öneki kullanımı XSLT biçembentlerinin bu öneki kullanmaları zorunludur anlamında ele alınmamalıdır. Bu DTD'de bildirilmiş herhangi bir eleman, bu DTD'de bildirilmiş özniteliklere ek olarak isimleri <code>xmlns</code>'e eşit veya <code>xmlns:</code> ile başlayan özniteliklere sahip olabilir.</p>

<eg><![CDATA[<!ENTITY % char-instructions "
  | xsl:apply-templates
  | xsl:call-template
  | xsl:apply-imports
  | xsl:for-each
  | xsl:value-of
  | xsl:copy-of
  | xsl:number
  | xsl:choose
  | xsl:if
  | xsl:text
  | xsl:copy
  | xsl:variable
  | xsl:message
  | xsl:fallback
">

<!ENTITY % instructions "
  %char-instructions;
  | xsl:processing-instruction
  | xsl:comment
  | xsl:element
  | xsl:attribute
">

<!ENTITY % char-template "
 (#PCDATA
  %char-instructions;)*
">

<!ENTITY % template "
 (#PCDATA
  %instructions;
  %result-elements;)*
">

<!-- Değeri bir tanım-yeri başvurusu olan
     bir öznitelik türü için kullanılır. -->
<!ENTITY % URI "CDATA">

<!-- Değeri bir örüntü olan bir öznitelik türü için kullanılır. -->
<!ENTITY % pattern "CDATA">

<!-- Değeri bir öznitelik değeri örneklenimi
     olan bir öznitelik türü için kullanılır. -->
<!ENTITY % avt "CDATA">

<!-- Değeri bir NitelAd olan bir öznitelik türü için kullanılır;
     önek, XSLT işlemcinin yorumladığı bir önek olacaktır. -->
<!ENTITY % qname "NMTOKEN">

<!-- %qname; gibi ama bu onların boşluk ayraçlı bir listesi. -->
<!ENTITY % qnames "NMTOKENS">

<!-- Değeri bir ifade olan bir öznitelik türü için kullanılır. -->
<!ENTITY % expr "CDATA">

<!-- Değeri tek bir karakterden oluşan
     bir öznitelik türü için kullanılır. -->
<!ENTITY % char "CDATA">

<!-- Değeri bir öncelik belirten bir
     öznitelik türü için kullanılır. -->
<!ENTITY % priority "NMTOKEN">

<!ENTITY % space-att "xml:space (default|preserve) #IMPLIED">

<!-- Bu tepe-seviyede izin verilmiş eleman listesini
     genişleten bir özelleştirme olabilir. -->
<!ENTITY % non-xsl-top-level "">

<!ENTITY % top-level "
 (xsl:import*,
  (xsl:include
  | xsl:strip-space
  | xsl:preserve-space
  | xsl:output
  | xsl:key
  | xsl:decimal-format
  | xsl:attribute-set
  | xsl:variable
  | xsl:param
  | xsl:template
  | xsl:namespace-alias
  %non-xsl-top-level;)*)
">

<!ENTITY % top-level-atts '
  extension-element-prefixes CDATA   #IMPLIED
  exclude-result-prefixes    CDATA   #IMPLIED
  id                         ID      #IMPLIED
  version                    NMTOKEN #REQUIRED
  xmlns:xsl                  CDATA   #FIXED    "]]>&XSLT.ns;<![CDATA["
  %space-att;
'>

<!-- Bu öğe hedef elemanların ATTLIST bildirimlerinde
     kullanmak için tanımlanmıştır. -->

<!ENTITY % result-element-atts '
  xsl:extension-element-prefixes CDATA    #IMPLIED
  xsl:exclude-result-prefixes    CDATA    #IMPLIED
  xsl:use-attribute-sets         %qnames; #IMPLIED
  xsl:version                    NMTOKEN  #IMPLIED
'>

<!ELEMENT xsl:stylesheet %top-level;>
<!ATTLIST xsl:stylesheet %top-level-atts;>

<!ELEMENT xsl:transform %top-level;>
<!ATTLIST xsl:transform %top-level-atts;>

<!ELEMENT xsl:import EMPTY>
<!ATTLIST xsl:import href %URI; #REQUIRED>

<!ELEMENT xsl:include EMPTY>
<!ATTLIST xsl:include href %URI; #REQUIRED>

<!ELEMENT xsl:strip-space EMPTY>
<!ATTLIST xsl:strip-space elements CDATA #REQUIRED>

<!ELEMENT xsl:preserve-space EMPTY>
<!ATTLIST xsl:preserve-space elements CDATA #REQUIRED>

<!ELEMENT xsl:output EMPTY>
<!ATTLIST xsl:output
  method                 %qname;  #IMPLIED
  version                NMTOKEN  #IMPLIED
  encoding               CDATA    #IMPLIED
  omit-xml-declaration  (yes|no)  #IMPLIED
  standalone            (yes|no)  #IMPLIED
  doctype-public         CDATA    #IMPLIED
  doctype-system         CDATA    #IMPLIED
  cdata-section-elements %qnames; #IMPLIED
  indent                (yes|no)  #IMPLIED
  media-type             CDATA    #IMPLIED
>

<!ELEMENT xsl:key EMPTY>
<!ATTLIST xsl:key
  name    %qname;   #REQUIRED
  match   %pattern; #REQUIRED
  use     %expr;    #REQUIRED
>

<!ELEMENT xsl:decimal-format EMPTY>
<!ATTLIST xsl:decimal-format
  name               %qname; #IMPLIED
  decimal-separator  %char;  "."
  grouping-separator %char;  ","
  infinity           CDATA   "Infinity"
  minus-sign         %char;  "-"
  NaN                CDATA   "NaN"
  percent            %char;  "%"
  per-mille          %char;  "&#x2030;"
  zero-digit         %char;  "0"
  digit              %char;  "#"
  pattern-separator  %char;  ";"
>

<!ELEMENT xsl:namespace-alias EMPTY>
<!ATTLIST xsl:namespace-alias
  stylesheet-prefix CDATA #REQUIRED
  result-prefix     CDATA #REQUIRED
>

<!ELEMENT xsl:template
 (#PCDATA
  %instructions;
  %result-elements;
  | xsl:param)*
>

<!ATTLIST xsl:template
  match    %pattern;  #IMPLIED
  name     %qname;    #IMPLIED
  priority %priority; #IMPLIED
  mode     %qname;    #IMPLIED
  %space-att;
>

<!ELEMENT xsl:value-of EMPTY>
<!ATTLIST xsl:value-of
  select                  %expr;   #REQUIRED
  disable-output-escaping (yes|no) "no"
>

<!ELEMENT xsl:copy-of EMPTY>
<!ATTLIST xsl:copy-of select %expr; #REQUIRED>

<!ELEMENT xsl:number EMPTY>
<!ATTLIST xsl:number
   level  (single|multiple|any) "single"
   count  %pattern; #IMPLIED
   from   %pattern; #IMPLIED
   value  %expr;    #IMPLIED
   format %avt;     '1'
   lang   %avt;     #IMPLIED
   letter-value       %avt; #IMPLIED
   grouping-separator %avt; #IMPLIED
   grouping-size      %avt; #IMPLIED
>

<!ELEMENT xsl:apply-templates (xsl:sort|xsl:with-param)*>
<!ATTLIST xsl:apply-templates
  select %expr; "node()"
  mode %qname; #IMPLIED
>

<!ELEMENT xsl:apply-imports EMPTY>

<!-- xsl:sort, bir boşluk olmayan karakterden
     veya bir imlenimden sonra yer alamaz. -->

<!ELEMENT xsl:for-each
 (#PCDATA
  %instructions;
  %result-elements;
  | xsl:sort)*
>

<!ATTLIST xsl:for-each
  select %expr; #REQUIRED
  %space-att;
>

<!ELEMENT xsl:sort EMPTY>
<!ATTLIST xsl:sort
  select     %expr; "."
  lang       %avt;  #IMPLIED
  data-type  %avt;  "text"
  order      %avt;  "ascending"
  case-order %avt;  #IMPLIED
>

<!ELEMENT xsl:if %template;>
<!ATTLIST xsl:if
  test %expr; #REQUIRED
  %space-att;
>

<!ELEMENT xsl:choose (xsl:when+, xsl:otherwise?)>
<!ATTLIST xsl:choose %space-att;>

<!ELEMENT xsl:when %template;>
<!ATTLIST xsl:when
  test %expr; #REQUIRED
  %space-att;
>

<!ELEMENT xsl:otherwise %template;>
<!ATTLIST xsl:otherwise %space-att;>

<!ELEMENT xsl:attribute-set (xsl:attribute)*>
<!ATTLIST xsl:attribute-set
  name               %qname;  #REQUIRED
  use-attribute-sets %qnames; #IMPLIED
>

<!ELEMENT xsl:call-template (xsl:with-param)*>
<!ATTLIST xsl:call-template
  name %qname; #REQUIRED
>

<!ELEMENT xsl:with-param %template;>
<!ATTLIST xsl:with-param
  name   %qname; #REQUIRED
  select %expr;  #IMPLIED
>

<!ELEMENT xsl:variable %template;>
<!ATTLIST xsl:variable
  name   %qname; #REQUIRED
  select %expr;  #IMPLIED
>

<!ELEMENT xsl:param %template;>
<!ATTLIST xsl:param
  name   %qname; #REQUIRED
  select %expr;  #IMPLIED
>

<!ELEMENT xsl:text (#PCDATA)>
<!ATTLIST xsl:text
  disable-output-escaping (yes|no) "no"
>

<!ELEMENT xsl:processing-instruction %char-template;>
<!ATTLIST xsl:processing-instruction
  name %avt; #REQUIRED
  %space-att;
>

<!ELEMENT xsl:element %template;>
<!ATTLIST xsl:element
  name               %avt;    #REQUIRED
  namespace          %avt;    #IMPLIED
  use-attribute-sets %qnames; #IMPLIED
  %space-att;
>

<!ELEMENT xsl:attribute %char-template;>
<!ATTLIST xsl:attribute
  name      %avt; #REQUIRED
  namespace %avt; #IMPLIED
  %space-att;
>

<!ELEMENT xsl:comment %char-template;>
<!ATTLIST xsl:comment %space-att;>

<!ELEMENT xsl:copy %template;>
<!ATTLIST xsl:copy
  %space-att;
  use-attribute-sets %qnames; #IMPLIED
>

<!ELEMENT xsl:message %template;>
<!ATTLIST xsl:message
  %space-att;
  terminate (yes|no) "no"
>

<!ELEMENT xsl:fallback %template;>
<!ATTLIST xsl:fallback %space-att;>]]></eg>

</inform-div1>

<inform-div1 id="examples">
<head>Örnekler</head>

<div2>
<head>Belge Örneği</head>

<p>Bu örnekte, basit bir DTD ile uyumlu belgeleri XHTML'ye <bibref ref="XHTML"/> dönüştürmek için bir biçembent kullanımı gösterilmiştir. DTD şöyledir:</p>

<eg><![CDATA[<!ELEMENT doc     (title, chapter*)>
<!ELEMENT chapter (title, (para|note)*, section*)>
<!ELEMENT section (title, (para|note)*)>
<!ELEMENT title   (#PCDATA|emph)*>
<!ELEMENT para    (#PCDATA|emph)*>
<!ELEMENT note    (#PCDATA|emph)*>
<!ELEMENT emph    (#PCDATA|emph)*>]]></eg>

<p>Biçembent böyle:</p>

<eg>&lt;xsl:stylesheet version="1.0"
                xmlns:xsl="&XSLT.ns;"
                xmlns="&XHTML.ns;"><![CDATA[

<xsl:strip-space elements="doc chapter section"/>
<xsl:output
   method="xml"
   indent="yes"
   encoding="iso-8859-9"
/>

<xsl:template match="doc">
 <html>
   <head>
     <title>
       <xsl:value-of select="title"/>
     </title>
   </head>
   <body>
     <xsl:apply-templates/>
   </body>
 </html>
</xsl:template>

<xsl:template match="doc/title">
  <h1>
    <xsl:apply-templates/>
  </h1>
</xsl:template>

<xsl:template match="chapter/title">
  <h2>
    <xsl:apply-templates/>
  </h2>
</xsl:template>

<xsl:template match="section/title">
  <h3>
    <xsl:apply-templates/>
  </h3>
</xsl:template>

<xsl:template match="para">
  <p>
    <xsl:apply-templates/>
  </p>
</xsl:template>

<xsl:template match="note">
  <p class="note">
    <b>BİLGİ: </b>
    <xsl:apply-templates/>
  </p>
</xsl:template>

<xsl:template match="emph">
  <em>
    <xsl:apply-templates/>
  </em>
</xsl:template>

</xsl:stylesheet>]]></eg>

<p>Kaynak belgemiz böyle olsaydı:</p>

<eg><![CDATA[<!DOCTYPE doc SYSTEM "doc.dtd">
<doc>
<title>Belge Başlığı</title>
<chapter>
<title>Fasıl Başlığı</title>
<section>
<title>Bölüm Başlığı</title>
<para>Bu bir denemedir.</para>
<note>Bu bir ek bilgidir.</note>
</section>
<section>
<title>Başka Bir Bölüm Başlığı</title>
<para>Bu da <emph>başka</emph> bir DNMdir.</para>
<note>Bu bir ek malumattır.</note>
</section>
</chapter>
</doc>]]></eg>

<p>Üretilecek hedef belgemiz böyle olurdu:</p>

<eg>&lt;?xml version="1.0" encoding="iso-8859-9"?>
&lt;html xmlns="&XHTML.ns;"><![CDATA[
<head>
<title>Belge Başlığı</title>
</head>
<body>
<h1>Belge Başlığı</h1>
<h2>Fasıl Başlığı</h2>
<h3>Bölüm Başlığı</h3>
<p>Bu bir denemedir.</p>
<p class="note">
<b>BİLGİ: </b>Bu bir ek bilgidir.</p>
<h3>Başka Bir Bölüm Başlığı</h3>
<p>Bu da <em>başka</em> bir DNMdir.</p>
<p class="note">
<b>BİLGİ: </b>Bu ilaveten diğer bir malumattır.</p>
</body>
</html>]]></eg>

</div2>

<div2 id="data-example">
<head>Veri Örneği</head>

<p>Bu örnekte, bir XML belge olarak tutulan veriden üç farklı biçembent kullanarak verinin üç farklı gösterimi (HTML, SVG ve VRML) elde edilmektedir.</p>

<p>Veri girdimiz:</p>

<eg><![CDATA[<satışlar>

        <bölge id="Kuzey">
                <gelir>10</gelir>
                <artış>9</artış>
                <ikram>7</ikram>
        </bölge>

        <bölge id="Güney">
                <gelir>4</gelir>
                <artış>3</artış>
                <ikram>4</ikram>
        </bölge>

        <bölge id="Batı">
                <gelir>6</gelir>
                <artış>-1.5</artış>
                <ikram>2</ikram>
        </bölge>

</sales>]]></eg>

<p>Aşağıdaki biçembent, <specref ref="result-element-stylesheet"/> bölümünde açıklanan basitleştirilmiş sözdizimini kullanarak veriyi HTML'ye dönüştürmek içindir:</p>

<eg>&lt;html xsl:version="1.0"
      xmlns:xsl="&XSLT.ns;"<![CDATA[
      lang="tr">
    <head>
	<title>Bölgelere göre Satış Sonuçları</title>
    </head>
    <body>
	<table border="1">
	    <tr>
		<th>Bölge</th>
		<th>Gelir</th>
		<th>Büyüme</th>
		<th>İkramiye</th>
	    </tr>
	    <xsl:for-each select="satışlar/bölge">
		<!-- sonuçları gelire göre sırala -->
		<xsl:sort select="gelir"
			  data-type="number"
			  order="descending"/>
		<tr>
		    <td>
			<em><xsl:value-of select="@id"/></em>
		    </td>
		    <td>
			<xsl:value-of select="gelir"/>
		    </td>
		    <td>
			<!-- büyüme aslında küçülmeyse kırmızı göster -->
			<xsl:if test="artış &lt; 0">
			     <xsl:attribute name="style">
				 <xsl:text>color:red</xsl:text>
			     </xsl:attribute>
			</xsl:if>
			<xsl:value-of select="artış"/>
		    </td>
		    <td>
			<xsl:value-of select="ikram"/>
		    </td>
		</tr>
	    </xsl:for-each>
	</table>
    </body>
</html>]]></eg>

<p>The HTML output is:</p>

<eg><![CDATA[<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-9">
<title>Bölgelere göre Satış Sonuçları</title>
</head>
<body>
<table border="1">
<tr>
<th>Bölge</th><th>Gelir</th><th>Büyüme</th><th>İkramiye</th>
</tr>
<tr>
<td><em>Kuzey</em></td><td>10</td><td>9</td><td>7</td>
</tr>
<tr>
<td><em>Batı</em></td><td>6</td><td style="color:red">-1.5</td><td>2</td>
</tr>
<tr>
<td><em>Güney</em></td><td>4</td><td>3</td><td>4</td>
</tr>
</table>
</body>
</html>]]></eg>

<p>Bu biçembent veriyi SCG'ye dönüştürmek içinder:</p>

<eg>&lt;xsl:stylesheet version="1.0"
                xmlns:xsl="&XSLT.ns;"<![CDATA[
                xmlns="http://www.w3.org/Graphics/SVG/SVG-19990812.dtd">

<xsl:output method="xml" indent="yes" media-type="image/svg"/>

<xsl:template match="/">

<svg width = "3in" height="3in">
    <g style = "stroke: #000000">
        <!-- eksenlere çiz -->
        <line x1="0" x2="150" y1="150" y2="150"/>
        <line x1="0" x2="0" y1="0" y2="150"/>
        <text x="0" y="10">Gelir</text>
        <text x="150" y="165">Bölüm</text>
        <xsl:for-each select="satışlar/bölüm">
	    <!-- bazı yararlı değişkenleri tanımlayalım -->

	    <!-- çubuğun x konumu -->
	    <xsl:variable name="pos"
	                  select="(position()*40)-30"/>

	    <!-- çubuğun yüksekliği -->
	    <xsl:variable name="height"
	                  select="gelir*10"/>

	    <!-- dikdörtgen -->
	    <rect x="{$pos}" y="{150-$height}"
                  width="20" height="{$height}"/>

	    <!-- metinsel yafta -->
	    <text x="{$pos}" y="165">
	        <xsl:value-of select="@id"/>
	    </text>

	    <!-- çubuk değeri -->
	    <text x="{$pos}" y="{145-$height}">
	        <xsl:value-of select="gelir"/>
	    </text>
        </xsl:for-each>
    </g>
</svg>

</xsl:template>
</xsl:stylesheet>]]></eg>

<p>SVG çıktısı:</p>

<eg><![CDATA[<svg width="3in" height="3in"
     xmlns="http://www.w3.org/Graphics/SVG/svg-19990412.dtd">
    <g style="stroke: #000000">
	<line x1="0" x2="150" y1="150" y2="150"/>
	<line x1="0" x2="0" y1="0" y2="150"/>
	<text x="0" y="10">Gelir</text>
	<text x="150" y="165">Bölüm</text>
	<rect x="10" y="50" width="20" height="100"/>
	<text x="10" y="165">Kuzey</text>
	<text x="10" y="45">10</text>
	<rect x="50" y="110" width="20" height="40"/>
	<text x="50" y="165">Güney</text>
	<text x="50" y="105">4</text>
	<rect x="90" y="90" width="20" height="60"/>
	<text x="90" y="165">Batı</text>
	<text x="90" y="85">6</text>
    </g>
</svg>]]></eg>

<p>Aşağıdaki biçembent veriyi VRML'ye dönüştürmek içindir:</p>

<eg>&lt;xsl:stylesheet version="1.0"
                xmlns:xsl="&XSLT.ns;"><![CDATA[

<!-- metni, öntanımlı karakter kümesini kullanarak
     model/vrmlmime türünde üretelim -->
<xsl:output method="text" encoding="UTF-8" media-type="model/vrml"/>

        <xsl:template match="/">#VRML V2.0 utf8

# tek bir bar elemanının externproto tanımı
EXTERNPROTO bar [
  field SFInt32 x
  field SFInt32 y
  field SFInt32 z
  field SFString name
  ]
  "http://www.vrml.org/WorkingGroups/dbwork/barProto.wrl"

# taşıyıcı çizge eksenlerini satıriçine alalım
Inline {
        url "http://www.vrml.org/WorkingGroups/dbwork/barAxes.wrl"
        }

                <xsl:for-each select="satışlar/bölüm">
bar {
        x <xsl:value-of select="gelir"/>
        y <xsl:value-of select="artış"/>
        z <xsl:value-of select="ikram"/>
        name "<xsl:value-of select="@id"/>"
        }
                </xsl:for-each>

        </xsl:template>

</xsl:stylesheet>]]></eg>

<p>VRML çıktısı:</p>

<eg><![CDATA[#VRML V2.0 utf8

# tek bir bar elemanının externproto tanımı
EXTERNPROTO bar [
  field SFInt32 x
  field SFInt32 y
  field SFInt32 z
  field SFString name
  ]
  "http://www.vrml.org/WorkingGroups/dbwork/barProto.wrl"

# taşıyıcı çizge eksenlerini satıriçine alalım
Inline {
        url "http://www.vrml.org/WorkingGroups/dbwork/barAxes.wrl"
        }


bar {
        x 10
        y 9
        z 7
        name "Kuzey"
        }

bar {
        x 4
        y 3
        z 4
        name "Güney"
        }

bar {
        x 6
        y -1.5
        z 2
        name "Batı"
        }]]></eg>

</div2>

</inform-div1>

<inform-div1 id="ack">
<head>Teşekkür</head>
<p>Bu taslağın yazımına katkıda bulunanlar:</p>
<slist>
<sitem>Daniel Lipkin, Saba</sitem>
<sitem>Jonathan Marsh, Microsoft</sitem>
<sitem>Henry Thompson, University of Edinburgh</sitem>
<sitem>Norman Walsh, Arbortext</sitem>
<sitem>Steve Zilles, Adobe</sitem>
</slist>

<p>Bu belirtim W3C XSL Çalışma Grubu (ÇG) tarafından geliştirildi ve yayımı için onaylandı. Bu belirtimin ÇG onayı tüm ÇG üyülerinin onaylarını oylarıyla belirtmelerini gerektirmez. XSL ÇG'nin şu an ki üyeleri:</p>

<orglist>
<member>
<name>Sharon Adler</name>
<affiliation>IBM</affiliation>
<role>Co-Chair</role>
</member>
<member>
<name>Anders Berglund</name>
<affiliation>IBM</affiliation>
</member>
<member>
<name>Perin Blanchard</name>
<affiliation>Novell</affiliation>
</member>
<member>
<name>Scott Boag</name>
<affiliation>Lotus</affiliation>
</member>
<member>
<name>Larry Cable</name>
<affiliation>Sun</affiliation>
</member>
<member>
<name>Jeff Caruso</name>
<affiliation>Bitstream</affiliation>
</member>
<member>
<name>James Clark</name>
</member>
<member>
<name>Peter Danielsen</name>
<affiliation>Bell Labs</affiliation>
</member>
<member>
<name>Don Day</name>
<affiliation>IBM</affiliation>
</member>
<member>
<name>Stephen Deach</name>
<affiliation>Adobe</affiliation>
</member>
<member>
<name>Dwayne Dicks</name>
<affiliation>SoftQuad</affiliation>
</member>
<member>
<name>Andrew Greene</name>
<affiliation>Bitstream</affiliation>
</member>
<member>
<name>Paul Grosso</name>
<affiliation>Arbortext</affiliation>
</member>
<member>
<name>Eduardo Gutentag</name>
<affiliation>Sun</affiliation>
</member>
<member>
<name>Juliane Harbarth</name>
<affiliation>Software AG</affiliation>
</member>
<member>
<name>Mickey Kimchi</name>
<affiliation>Enigma</affiliation>
</member>
<member>
<name>Chris Lilley</name>
<affiliation>W3C</affiliation>
</member>
<member>
<name>Chris Maden</name>
<affiliation>Exemplary Technologies</affiliation>
</member>
<member>
<name>Jonathan Marsh</name>
<affiliation>Microsoft</affiliation>
</member>
<member>
<name>Alex Milowski</name>
<affiliation>Lexica</affiliation>
</member>
<member>
<name>Boris Moore</name>
<affiliation>RivCom</affiliation>
</member>
<member>
<name>Steve Muench</name>
<affiliation>Oracle</affiliation>
</member>
<member>
<name>Scott Parnell</name>
<affiliation>Xerox</affiliation>
</member>
<member>
<name>Vincent Quint</name>
<affiliation>W3C</affiliation>
</member>
<member>
<name>Dan Rapp</name>
<affiliation>Novell</affiliation>
</member>
<member>
<name>Gregg Reynolds</name>
<affiliation>Datalogics</affiliation>
</member>
<member>
<name>Jonathan Robie</name>
<affiliation>Software AG</affiliation>
</member>
<member>
<name>Mark Scardina</name>
<affiliation>Oracle</affiliation>
</member>
<member>
<name>Henry Thompson</name>
<affiliation>University of Edinburgh</affiliation>
</member>
<member>
<name>Philip Wadler</name>
<affiliation>Bell Labs</affiliation>
</member>
<member>
<name>Norman Walsh</name>
<affiliation>Arbortext</affiliation>
</member>
<member>
<name>Sanjiva Weerawarana</name>
<affiliation>IBM</affiliation>
</member>
<member>
<name>Steve Zilles</name>
<affiliation>Adobe</affiliation>
<role>Co-Chair</role>
</member>
</orglist>
</inform-div1>

<inform-div1 id="changes">
<head>Önerge Adaylığından beri Değişenler</head>

<p>Önerge Adaylığından sonra şu değişiklikler oldu:</p>

<ulist>
<item><p><tt>xsl:version</tt> özniteliği, bir biçembent olarak kullanımda bir birebir hedef elemanda gereklidir (bkz, <specref
ref="result-element-stylesheet"/>).</p></item>

<item><p><code>xsl:sort</code> elemanındaki <code>data-type</code> özniteliği, XSLT tarafından tanımlanmamış bir veri türünü belirten bir önekli ismi kullanılabilir (bkz, <specref ref="sorting"/>).</p></item>
</ulist>
</inform-div1>

<inform-div1 id="future">
<head>XSLT'nin gelecek sümlerinde ele alınacak özellikler</head>

<p>XSLT'nin XSLT 1.0'dan sonraki sürümlerinde ele alınması düşünülen özellikler şunlardır:</p>

<slist>
<sitem>bir koşullu ifade;</sitem>

<sitem>XML Şema veri ve örnek türleri için destek;</sitem>

<sitem>özgün XSL sunumunda yer alan biçem kurallarının benzerleri için destek;</sitem>

<sitem>XSLT özniteliklerinde yer alan isimler için öntanımlı isim-alanını denetleyecek bir öznitelik;</sitem>

<sitem>öğe gönderimlerine destek;</sitem>

<sitem>veri modelindeki DTD'ler için destek;</sitem>

<sitem>veri modelindeki gösterimler için destek;</sitem>

<sitem>bir elemandan ona atıfta bulunan elemanlara ulaşmak için bir yol (IDREF özniteliklerinin yaptığı gibi);</sitem>

<sitem>başka bir belgedeki bir id veya anahtarı almanın kolay bir yolu;</sitem>

<sitem>eleman türü isimleri, öznitelik isimleri, öznitelik değerleri ve metin düğümlerinin tümünü veya bir kısmını aralarında eşlemek için düzenli ifade desteği;</sitem>

<sitem>harf büyüklüğüne duyarsız karşılaştırmalar;</sitem>

<sitem>karşılaştırma öncesi dizge normalleştirmesi, örneğin uyumluluk karakterleri için;</sitem>

<sitem>düğümün temel tanım-yerini kullanarak, bir mutlak tanım-yerine dönüştürmek üzere bir göreli tanım yerini değer olarak alan, <var>dizge </var><code>resolve(</code><var>düğüm-kümesi</var><code>)</code> gibi bir işlev;</sitem>

<sitem>çok sayıda hedef belge;</sitem>

<sitem><code>xsl:value-of</code> elemanının <code>select</code> özniteliği için geçerli düğümün öntanımlı olması;</sitem>

<sitem>bir öznitelik değerinin nasıl normalleştirileceğinin belirtilebileceği bir özniteliğin <code>xsl:attribute</code> elemanına atanması;</sitem>

<sitem>sıralama üzerinde daha fazla denetim (göreli sıralama yapmak gibi) sağlamak için <code>xsl:sort</code>'a yeni özniteliklerin eklenmesi;</sitem>

<sitem>bir hedef ağaca bir tanım-yeri tarafından tanımlanmış bir özkaynağın metnini koymanın bir yolu;</sitem>

<sitem>konumları birarada belirtebilmek (<code>foo/(bar|baz)</code> gibi);</sitem>

<sitem>düğüm kümeleri için mümkün olan tüm işlemlerin hedef ağaç bölümlerinde de mümkün olması;</sitem>

<sitem>altelemanların ve özniteliklerin çoğullanmasına yol açan ardışık düğümleri gruplamanın bir yolu;</sitem>

<sitem>HTML <code>style</code> özniteliğinin elde edilişine daha uygun bir yol.</sitem>
</slist>
</inform-div1>
</back>
</spec>
