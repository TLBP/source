<?xml version="1.0" encoding="UTF-8"?>
<!-- ********************************************************************
     $Id: rfc2045.xml,v 1.8 2002/12/20 22:46:09 nilgun Exp $
     ********************************************************************-->
<article xml:id="rfc2045">
  <articleinfo>
    <title>Çok Amaçlı Genel Ağ Posta Eklentileri (MIME) 1. Kısım: Genel Ağ İleti Gövdelerinin Biçimi</title>
    <subtitle>RFC 2045</subtitle>
    <titleabbrev>RFC 2045</titleabbrev>
    <authorgroup>
      <author>
        <firstname>Ned Freed</firstname>
        <contrib>Innosoft</contrib>
      </author><author>
        <firstname>Nathaniel S. Borenstein</firstname>
        <contrib>First Virtual Yazım tarihi: Kasım 1996</contrib>
      </author><author role="translator">
        <firstname>Nilgün Belma Bugüner</firstname>
        <contrib><email>&nilgun.buguner;</email> Çeviri tarihi: Kasım 2006</contrib>
      </author>
    </authorgroup>
    <releaseinfo>
Ağ Çalışma Grubu 
Açıklama İsteği: 2045 
Geçersiz kıldığı RFC'ler: 1521, 1522, 1590 
Güncelleyen RFC'ler: 2184, 2231 
Durumu: Standart Adayı
    </releaseinfo>
    <legalnotice><title>Yasal Uyarı</title><para>
RFC'lerin yazarlarının hakları <link xl:href="ftp://ftp.rfc-editor.org/in-notes/bcp/bcp78.txt">BCP 78</link> ile düzenlenmiştir. Dolayısıyla RFC çevirilerinin çevirmenlerinin haklarını da <link linkend="&bcp078;">BCP 78</link>'in düzenlediği kabul edilmiştir.
        </para><para>
Bu belge <link xl:href="http://www.ietf.org/">IETF</link> tarafından yayınlanan resmi RFC2045'in <emphasis role="bold">gayrıresmi</emphasis> çevirisidir ve aslının yerine kullanılamaz. Bu çevirinin hiçbir bağlamda ya da koşulda hükmü yoktur. Bu çeviri, anadili Türkçe olan Genel ağ kullanıcılarının bu RFC hakkında fikir edinebilmelerini sağlamak amacıyla hazırlanmıştır.
  </para>
  <para>
BU BELGE "ÜCRETSİZ" OLARAK RUHSATLANDIĞI İÇİN, İÇERDİĞİ BİLGİLER İÇİN İLGİLİ KANUNLARIN İZİN VERDİĞİ ÖLÇÜDE HERHANGİ BİR GARANTİ VERİLMEMEKTEDİR. AKSİ YAZILI OLARAK BELİRTİLMEDİĞİ MÜDDETÇE TELİF HAKKI SAHİPLERİ VE/VEYA BAŞKA ŞAHISLAR BELGEYİ "OLDUĞU GİBİ", AŞİKAR VEYA ZIMNEN, SATILABİLİRLİĞİ VEYA HERHANGİ BİR AMACA UYGUNLUĞU DA DAHİL OLMAK ÜZERE HİÇBİR GARANTİ VERMEKSİZİN DAĞITMAKTADIRLAR. BİLGİNİN KALİTESİ İLE İLGİLİ TÜM SORUNLAR SİZE AİTTİR. HERHANGİ BİR HATALI BİLGİDEN DOLAYI DOĞABİLECEK OLAN BÜTÜN SERVİS, TAMİR VEYA DÜZELTME MASRAFLARI SİZE AİTTİR.
  </para>
  <para>
İLGİLİ KANUNUN İCBAR ETTİĞİ DURUMLAR VEYA YAZILI ANLAŞMA HARİCİNDE HERHANGİ BİR ŞEKİLDE TELİF HAKKI SAHİBİ VEYA YUKARIDA İZİN VERİLDİĞİ ŞEKİLDE BELGEYİ DEĞİŞTİREN VEYA YENİDEN DAĞITAN HERHANGİ BİR KİŞİ, BİLGİNİN KULLANIMI VEYA KULLANILAMAMASI (VEYA VERİ KAYBI OLUŞMASI, VERİNİN YANLIŞ HALE GELMESİ, SİZİN VEYA ÜÇÜNCÜ ŞAHISLARIN ZARARA UĞRAMASI VEYA BİLGİLERİN BAŞKA BİLGİLERLE UYUMSUZ OLMASI) YÜZÜNDEN OLUŞAN GENEL, ÖZEL, DOĞRUDAN YA DA DOLAYLI HERHANGİ BİR ZARARDAN, BÖYLE BİR TAZMİNAT TALEBİ TELİF HAKKI SAHİBİ VEYA İLGİLİ KİŞİYE BİLDİRİLMİŞ OLSA DAHİ, SORUMLU DEĞİLDİR.
  </para>
  <para>
Tüm telif hakları aksi özellikle belirtilmediği sürece sahibine aittir. Belge içinde geçen herhangi bir terim, bir ticari isim ya da kuruma itibar kazandırma olarak algılanmamalıdır. Bir ürün ya da markanın kullanılmış olması ona onay verildiği anlamında görülmemelidir.
  </para>
    </legalnotice>
    <abstract><para>
STD 11, RFC 822 US-ASCII ileti başlıkları hakkında önemli ayrıntıları belirterek bir ileti sunum protokolü tanımlar ve ileti içeriğini veya ileti gövdesini düz US-ASCII metin olarak bırakır. Toplu halde Çok Amaçlı Genel Ağ Posta Eklentileri (Multipurpose Internet Mail Extension) veya MIME olarak bilinen bu belge silsilesi, ileti biçimini şunlara izin verecek şekilde yeniden tanımlar:
</para><orderedlist><listitem>
karakter kümesi US-ASCII'den farklı olan metinsel ileti gövdeleri,
</listitem><listitem>
metinsel olmayan ileti gövdeleri için çeşitliliği arttırılabilir biçim kümesi,
</listitem><listitem>
çok parçalı ileti gövdeleri ve
</listitem><listitem>
karakter kümesi US-ASCII'den farklı olan metinsel başlık bilgisi.
</listitem></orderedlist><para>
Bu belgeler, RFC 934, STD 11 ve RFC 1049'da belgelenmış ilk çalışmalara dayanmakla birlikte, onları elden geçirip genişletir. RFC822 ileti gövdeleri hakkında pek az şey söylediğinden, bu belgeler RFC 822 ile (elden geçirme olmaktan ziyade)  geniş ölçüde ilgisizdir.
</para><para>
Bu ilk belge MIME iletilerin yapısını açıklamakta kullanılan çeşitli başlıkları belirtir. İkinci belge, RFC 2046, MIME ortamı yazım sisteminin genel yapısı ile ilk ortam türleri kümesini tanımlar. Üçüncü belge, RFC 2047, Genel Ağ postası başlık alanlarında US-ASCII dışında metin verilere izin veren RFC 822 eklentilerini açıklar. Dördüncü eleman, RFC 2048, MIME ile ilgili oluşumların IANA sicil kayıtlarına geçirilme yordamlarını belirtir. Beşinci ve son belge, RFC 2049, MIME uyum kriterlerini açıklamaktan başka, MIME ileti biçimlerinin bazı örnekleri, teşekkür ve kaynakça bölümlerini içerir.
</para><para>
Bu belgeler, RFCs 1341 ve 1342'yi elden geçiren RFCler 1521, 1522 ve 1590'nın elden geçirimleridir. RFC 2049'un içerdiği eklerden birinde önceki sürümlerden farklar ve yapılan değişiklikler açıklanmıştır.
  </para></abstract>
  <atomEntry>
    <link rel="alternate" href="http://belgeler.org/rfc/rfc2045.html" hreflang="tr_TR" type="text/html" title="RFC 2045"/>
    <link rel="related" href="http://adsl.belgeler.org/source/rfcs/rfc2045.xml" hreflang="tr_TR" type="application/xml-external-parsed-entity" title="RFC 2045"/>
    <title type="text/html">RFC 2045 - Çok Amaçlı Genel Ağ Posta Eklentileri (MIME) 1. Kısım: Genel Ağ İleti Gövdelerinin Biçimi</title>
    <id>belgeler.org:rfc:rfc2045</id>
    <author><name>Ned Freed</name></author>
    <author><name>Nathaniel S. Borenstein</name></author>
    <author role="translator"><name>Nilgün Belma Bugüner</name></author>
    <created>2006-11</created>
    <modified>2006-11-18</modified>
    <rights type="application/xhtml+xml">
      <div xmlns="http://www.w3.org/1999/xhtml"><p>RFC'lerin yazarlarının hakları <a href="ftp://ftp.rfc-editor.org/in-notes/bcp/bcp78.txt">BCP 78</a> ile düzenlenmiştir. Dolayısıyla RFC çevirilerinin çevirmenlerinin haklarını da BCP 78'in düzenlediği kabul edilmiştir.</p></div>
    </rights>
  </atomEntry>
  </articleinfo>

<dedication><title>Bu Belgenin Durumu</title>
<para>
Bu belge Genel Ağ standardı olmak üzere standartlaşma aşamasına girmiş bir protokolü belirtir ve geliştirilmesi için Genel Ağ topluluğundan üzerinde tartışılmasını ve önerilerde bulunulmasını talep eder. Bu protokolün durumu ve standartlaşma aşamalarındaki seviyesi için lütfen "Genel Ağ Resmi Protokol Standartları" (STD 1) belgesinin şu an ki sürümüne bakınız. Bu belgenin dağıtımına sınırlama getirilmemiştir.
</para>
</dedication>

<sect1 xml:id="rfc2045-s1"><title>Giriş</title>
<para>
1982'deki yayımından beri RFC 822, Genel Ağ'da metinsel posta iletilerinin standart biçimini tanımlamaktadır. Onun başarısı kısmen veya tamamen, Genel Ağ'ın sınırları ve RFC 821 tarafından tanımlanan Genel Ağ SMTP aktarımı dahilinde RFC 822 biçiminin benimsenmesi olmuştu. Biçim geniş bir kullanım alanı bulurken tespit edilen bazı sınırlamalar kullanıcılar açısından giderek kısıtlayıcı oluyordu.
</para><para>
RFC 822, yazılı iletiler için bir biçim belirtmek için tasarlanmıştı. Hatta, ses ve görüntü içeren çoklu ortam iletileri gibi yazılı biçimde olmayan iletilerin lafı bile edilmiyordu. Dahası, US-ASCII'den daha zengin karakter kümelerinin kullanımını gerektiren dillerin posta kullanıcılarının ihtiyaçları bakımından, RFC 822 salt yazılı iletiler durumunda bile yetersizdir. RFC 822 görsel ve işitsel iletiler ile Asya ve çoğu Avrupa dilindeki yazılı iletiler içeren postalar için mekanizmalar tanımlamadığından ilave belirtimlerin ortaya konması gerekmiştir.
</para><para>
RFC 821/822'ye dayalı posta sistemlerinin başlıca sınarlamalarından biri elektronik posta iletisi içeriğinin görece kısa (1000 karaktere kadar [<xref linkend="rfc2045-RFC-821"/>]) 7 bitlik US-ASCII satırlarıyla sınırlanmış olmasıdır. Bu durum, kullanıcıların yazılı olmayan verilerini yerel posta istemcilerine teslim etmeden önce yedi bitlik baytlarla ifade edilen basılabilir US-ASCII karakterlere dönüştürmeye zorluyordu. Genel Ağ'da halen kullanılmakta olan bu tür kodlama şemalarına örnek olarak, salt onaltılık biçim, uuencode, RFC 1421'de belirtilen 64 tabanlı üç çeyrek şeması ve Andrew Araçkiti Gösterimi [<xref linkend="rfc2045-ATK"/>] verilebilir.
</para><para>
RFC 822 posta sınırlamaları bilhassa RFC 822 konakları ile X.400 konakları arasında posta alışverişini mümkün kılmak için tasarlanmış ağgeçitlerinde daha da belirgin hale gelir.  X.400 [<xref linkend="rfc2045-X400"/>] elektronik posta iletilerinin yazılı olmayan verileri de kapsaması için mekanizmalar belirtir. X.400 iletileri ile RFC 822 iletileri arası dönüşümde kullanılan mevcut standartlar X.400 yazılı olmayan verilerinin ya IA5Text biçimine dönüştürülmesini (kodlanmamasını) ya da RFC 822 kullanıcısına bildirilerek verilerin iptalini gerektirir. Kullanıcı kayıplı veri almak istemeyeceğinden bu arzu edilmeyen bir durumdur. Kullanıcının posta istemci uygulaması yazılı olmayan verileri elde edemiyor olsa bile kullanıcının bu verilerden işine yarayacak olanlarını elde etmesini sağlayacak harici araçları olabilir. Dahası, kullanıcının posta istemci uygulaması, iletinin, yazılı olmayan bilgilerin tekrar anlamlı hale gelecekleri X.400 ileti işleme sistemine geri aktarılmasını dahi mümkün kılmaz.
</para><para>
Bu belge, RFC 822 postalarının varolduğu dünya ile herhangi bir ciddi uyumsuzluğa sebep olmaksızın bu sorunları çözümleyecek çeşitli mekanizmaları açıklar. Özellikle şu mekanizmaların üzerinde durulmuştur:
</para><orderedlist><listitem><para>
Bir iletinin MIME ile uyumlu olduğunu belirten bir sürüm numarasının kullanıldığı <literal>MIME-Version</literal> başlık alanı. Bu başlık alanının varlığı sayesinde posta iletisinin eski uyumsuz yazılımlarca üretilmiş posta iletilerinden (bunlarda bu başlık alanı bulunmayacaktır) ayrılması sağlanır.
</para></listitem><listitem><para>
Bir iletinin gövdesindeki verinin alt veri türünü, ortam türünü ve dolayısıyla verinin doğal yapısını tamamen belirtmekte kullanılabilen, anahatları RFC 1049'dan alınmış <literal>Content-Type</literal> başlık alanı.
</para></listitem><listitem><para>
İleti gövdesine ve sonuca her iki yönde uygulanan kodlama dönüşümünü belirtmekte kullanılabilen <literal>Content-Transfer-Encoding</literal> başlık alanı. Özdeşlik dönüşümleri dışında kalan kodlama dönüşümleri genellikle, verinin veri ve karakter kümesi kısıtlamaları içeren posta aktarım mekanizmaları üzerinden aktarımını mümkün kılmak için uygulanır.
</para></listitem><listitem><para>
İleti gövdesindeki veriyi anlamlandırmaya yardımcı olmak üzere kullanılabilen iki ek başlık alanı: <literal>Content-ID</literal> ve <literal>Content-Description</literal> başlık alanları.
</para></listitem></orderedlist><para>
Bu belgede tanımlanmış başlık alanlarının tümü RFC 822'de belirtilmiş başlık alanlarının genel sözdizimsel kurallarına tabidir. Özellikle  <literal>Content-Disposition</literal> dışında kalan başlık alanlarının tümü, anlamlandırılabilir bir içeriği olmayan ve MIME işlemleri sırasında yoksayılması gereken RFC 822 açıklamalarını içerebilir.
</para><para>
Son olarak, RFC 2049, birlikte çalışabilirliği belirtmek ve vurgulamak için bu belge ile en düşük "uyum" düzeyini tanımlamak üzere yukarıdaki mekanizmaların bir alt kümesini içeren temel bir uygulanabilirlik bildirimi sağlar.
</para><note><title>Tarihsel Bilgi:</title><para>
Bu MIME belgelerinde açıklanan bazı mekanizmalar ilk bakışta tuhaf hatta karmaşık ve sivri (barok) görünebilir. Şuna dikkat edilmelidir ki, mevcut standartlarla uyumlu olmak ve mevcut uygulamaya karşı güçlü durmak, bu MIME belgelerini geliştiren çalışma grubunun en yüksek önceliklerinden ikisidir. Özellikle uyumluluk zarafete daima tercih edilmiştir.
</para></note><para>
Bu protokolün durumu ve standartlaşma aşamalarındaki seviyesi için lütfen, Genel Ağ Resmi Protokol Standartları'nın şu anki sürümüne bakınız. RFC 822, RFC 1123 ve STD 3 ile çelişen MIME uyumlu gerçeklenimler olmadığından bunlar ayrıca MIME için esaslı bir zemin oluşturur. Bunlara ek olarak, MIME gerçeklenimcileri için ilginç olabilecek bilgilendirici RFC belgeleri de vardır, özellikle RFC 1344, RFC 1345 ve RFC 1524 bunlar arasında yeralır.
</para>
</sect1>

<sect1 xml:id="rfc2045-s2">
<title>Tanımlar, Uzlaşımlar ve Temel BNF Dilbilgisi</title>
<para>
Bu MIME belgelerinde belirtilen mekanizmaların tamamından düzyazı olarak bahsedilmişse de çoğu ayrıca biçimsel olarak RFC 822'nin ABNF gösterimi ile de açıklanmıştır. Gerçeklenimcilerin Bu MIME belgelerini anlayabilmeleri için bu gösterime aşina olmaları gerekir. Arttırımlı BNF hakkında bilgi edinmek için RFC 822'ye bakınız<footnote><para> (Ç.N. - Belge öyle diyor ama siz <link linkend="rfc2822">RFC 2822</link> ve <link linkend="rfc4234">RFC 4234</link>'e bakarsanız daha iyi olur; hatta bu belgede RFC 822 dendikçe siz onu RFC 2822 diye anlayın. RFC 2822 varken önceli RFC 822'yi çevirmek anlamlı değildi.</para></footnote>.
</para><para>
Bu MIME belgelerindeki ABNF gösterimlerinden bazıları RFC 822'de tanımlanmış sözdizimi kurallarına isimleriyle atıf yapmaktadır. Bundan başka, tam bir biçimsel dilbilgisi bu MIME belgelerinini her birinin sonundaki eklerde bulurmaktadır. Bu dilbilgisi o belgedeki dilbilgisinin yanında RFC 822'deki BNF ile RFC 1123'teki RFC 822'dekine göne değişikliğe uğramış sözdizimlerini (özellikle `return', `date' ve `mailbox' sözdizimleri ile ilgili değişiklikleri) içermektedir.
</para><para>
Sayısal ve sekizli değerlerin tümü bu MIME belgelerinde onluk gösterimle belirtilmiştir. Tüm ortam türü değerleri, alt tür değerleri ve bağımsız değişken isimleri harf büyüklüğüne duyarsız olarak olarak tanımlanmıştır. Bununla birlikte, bağımsız değişken değerleri aksi belli bir bağımsız değişken için özellikle belirtilmedikçe harf büyüklüğüne duyarlıdır.
</para><note><title>Biçimleme Bilgisi:</title><para>
Bunun gibi ek bilgiler, önemli sayılabilecek hiçbir kayıp olmaksızın okuyucu tarafından atlanabilecek önemsiz ek bilgiler içerirler. Bunların birincil amacı bu MIME belgelerinin mantığı hakkında bilgi vermek veya bu belgeleri gelişim tarihi içinde doğru yere yerleştirmektir. Böyle bilgiler, özellikle tamamen uyumlu bir gerçeklenim ortaya koymaya odaklanmış kişilerce atlanabilirse de belli tasarım seçimlerinin yapılış sebeplerini anlamaya çalışanlar için yararlı olabilir.
</para>
</note>

<sect2 xml:id="rfc2045-s21"><title><literal>CRLF</literal></title>
<para>
Bu belgede <literal>CRLF</literal> denince, (onluk değeri 13 olan) <literal>CR</literal> ile (onluk değeri 10 olan) <literal>LF</literal> karakterleri birlikte ve burada verildikleri sırayla içerilmiş olarak, RFC 822 postasında satırı sonlandırmakta kullanılan iki ASCII karakterlik dizilim anlaşılacaktır.
</para>
</sect2>

<sect2 xml:id="rfc2045-s22"><title>Karakter kümesi</title>
<para>
MIME'de kullanıldığı şekliyle "karakter kümesi" denince sekizli dizilerini karakter dizilerine dönüştüren bir yöntem anlaşılacaktır.
   The term "character set" is used in MIME to refer to a method of
   converting a sequence of octets into a sequence of characters.  Note
   that unconditional and unambiguous conversion in the other direction
   is not required, in that not all characters may be representable by a
   given character set and a character set may provide more than one
   sequence of octets to represent a particular sequence of characters.
</para><para>
   This definition is intended to allow various kinds of character
   encodings, from simple single-table mappings such as US-ASCII to
   complex table switching methods such as those that use ISO 2022's
   techniques, to be used as character sets.  However, the definition
   associated with a MIME character set name must fully specify the
   mapping to be performed.  In particular, use of external profiling
   information to determine the exact mapping is not permitted.
</para><note><para>
   NOTE: The term "character set" was originally to describe such
   straightforward schemes as US-ASCII and ISO-8859-1 which have a
   simple one-to-one mapping from single octets to single characters.
   Multi-octet coded character sets and switching techniques make the
   situation more complex. For example, some communities use the term
   "character encoding" for what MIME calls a "character set", while
   using the phrase "coded character set" to denote an abstract mapping
   from integers (not octets) to characters.
</para>
</note>
</sect2>

<sect2 xml:id="rfc2045-s23"><title>Message</title>
<para>
   The term "message", when not further qualified, means either a
   (complete or "top-level") RFC 822 message being transferred on a
   network, or a message encapsulated in a body of type "message/rfc822"
   or "message/partial".
</para>
</sect2>

<sect2 xml:id="rfc2045-s24"><title>Entity</title>
<para>
   The term "entity", refers specifically to the MIME-defined header
   fields and contents of either a message or one of the parts in the
   body of a multipart entity.  The specification of such entities is
   the essence of MIME.  Since the contents of an entity are often
   called the "body", it makes sense to speak about the body of an
   entity.  Any sort of field may be present in the header of an entity,
   but only those fields whose names begin with "content-" actually have
   any MIME-related meaning.  Note that this does NOT imply thay they
   have no meaning at all -- an entity that is also a message has non-
   MIME header fields whose meanings are defined by RFC 822.
</para>
</sect2>

<sect2 xml:id="rfc2045-s25"><title>Body Part</title>
<para>
   The term "body part" refers to an entity inside of a multipart
   entity.
</para>
</sect2>

<sect2 xml:id="rfc2045-s26"><title>Body</title>
<para>
   The term "body", when not further qualified, means the body of an
   entity, that is, the body of either a message or of a body part.
</para><note><para>
   NOTE:  The previous four definitions are clearly circular.  This is
   unavoidable, since the overall structure of a MIME message is indeed
   recursive.
</para>
</note>
</sect2>

<sect2 xml:id="rfc2045-s27"><title>7bit Data</title>
<para>
   "7bit data" refers to data that is all represented as relatively
   short lines with 998 octets or less between CRLF line separation
   sequences [<xref linkend="rfc2045-RFC-821"/>].  No octets with decimal values greater than 127
   are allowed and neither are NULs (octets with decimal value 0).  CR
   (decimal value 13) and LF (decimal value 10) octets only occur as
   part of CRLF line separation sequences.
</para>
</sect2>

<sect2 xml:id="rfc2045-s28"><title>8bit Data</title>
<para>
   "8bit data" refers to data that is all represented as relatively
   short lines with 998 octets or less between CRLF line separation
   sequences [<xref linkend="rfc2045-RFC-821"/>]), but octets with decimal values greater than 127
   may be used.  As with "7bit data" CR and LF octets only occur as part
   of CRLF line separation sequences and no NULs are allowed.
</para>
</sect2>

<sect2 xml:id="rfc2045-s29"><title>Binary Data</title>
<para>
   "Binary data" refers to data where any sequence of octets whatsoever
   is allowed.
</para>
</sect2>

<sect2 xml:id="rfc2045-s2a"><title>Lines</title>
<para>
   "Lines" are defined as sequences of octets separated by a CRLF
   sequences.  This is consistent with both RFC 821 and RFC 822.
   "Lines" only refers to a unit of data in a message, which may or may
   not correspond to something that is actually displayed by a user
   agent.
</para>
</sect2>
</sect1>

<sect1 xml:id="rfc2045-s3"><title>MIME Header Fields</title>
<para>
   MIME defines a number of new RFC 822 header fields that are used to
   describe the content of a MIME entity.  These header fields occur in
   at least two contexts:
</para><orderedlist><listitem>
    (1)   As part of a regular RFC 822 message header.
</listitem><listitem>
    (2)   In a MIME body part header within a multipart
          construct.
</listitem></orderedlist><para>
   The formal definition of these header fields is as follows:
</para><literallayout>
    öğe-başlıkları := [ content CRLF ]
                      [ kodlama CRLF ]
                      [ id CRLF ]
                      [ description CRLF ]
                      *( MIME-extension-field CRLF )

    MIME-message-headers := öğe-başlıkları
                            fields
                            version CRLF
                            ; The ordering of the header
                            ; fields implied by this BNF
                            ; definition should be ignored.

    MIME-part-headers := öğe-başlıkları
                        [ fields ]
                        ; Any field not beginning with
                        ; "content-" can have no defined
                        ; meaning and may be ignored.
                        ; The ordering of the header
                        ; fields implied by this BNF
                        ; definition should be ignored.
</literallayout><para>
   The syntax of the various specific MIME header fields will be
   described in the following sections.
</para>
</sect1>

<sect1 xml:id="rfc2045-s4"><title><literal>MIME-Version</literal> Header Field</title>
<para>
   Since RFC 822 was published in 1982, there has really been only one
   format standard for Internet messages, and there has been little
   perceived need to declare the format standard in use.  This document
   is an independent specification that complements RFC 822.  Although
   the extensions in this document have been defined in such a way as to
   be compatible with RFC 822, there are still circumstances in which it
   might be desirable for a mail-processing agent to know whether a
   message was composed with the new standard in mind.
</para><para>
   Therefore, this document defines a new header field, "<literal>MIME-Version</literal>",
   which is to be used to declare the version of the Internet message
   body format standard in use.
</para><para>
   Messages composed in accordance with this document MUST include such
   a header field, with the following verbatim text:
</para><literallayout>
     MIME-Version: 1.0
</literallayout><para>
   The presence of this header field is an assertion that the message
   has been composed in compliance with this document.
</para><para>
   Since it is possible that a future document might extend the message
   format standard again, a formal BNF is given for the content of the
   <literal>MIME-Version</literal> field:
</para><literallayout>
     version := "MIME-Version" ":" 1*RAKAM "." 1*RAKAM
</literallayout><para>
   Thus, future format specifiers, which might replace or extend "1.0",
   are constrained to be two integer fields, separated by a period.  If
   a message is received with a MIME-version value other than "1.0", it
   cannot be assumed to conform with this document.
</para><para>
   Note that the <literal>MIME-Version</literal> header field is required at the top level
   of a message.  It is not required for each body part of a multipart
   entity.  It is required for the embedded headers of a body of type
   "message/rfc822" or "message/partial" if and only if the embedded
   message is itself claimed to be MIME-conformant.
</para><para>
   It is not possible to fully specify how a mail reader that conforms
   with MIME as defined in this document should treat a message that
   might arrive in the future with some value of <literal>MIME-Version</literal> other than
   "1.0".
</para><para>
   It is also worth noting that version control for specific media types
   is not accomplished using the <literal>MIME-Version</literal> mekanizma.  In particular,
   some formats (such as application/postscript) have version numbering
   conventions that are internal to the media format.  Where such
   conventions exist, MIME does nothing to supersede them.  Where no
   such conventions exist, a MIME media type might use a "version"
   parameter in the content-type field if necessary.
</para><note><title>NOTE TO IMPLEMENTORS:</title><para>
   When checking <literal>MIME-Version</literal> values any RFC 822
   comment strings that are present must be ignored.  In particular, the
   following four <literal>MIME-Version</literal> fields are equivalent:
</para><literallayout>
     MIME-Version: 1.0

     MIME-Version: 1.0 (produced by MetaSend Vx.x)

     MIME-Version: (produced by MetaSend Vx.x) 1.0

     MIME-Version: 1.(produced by MetaSend Vx.x)0
</literallayout><para>
   In the absence of a <literal>MIME-Version</literal> field, a receiving mail user agent
   (whether conforming to MIME requirements or not) may optionally
   choose to interpret the body of the message according to local
   conventions.  Many such conventions are currently in use and it
   should be noted that in practice non-MIME messages can contain just
   about anything.
</para><para>
   It is impossible to be certain that a non-MIME mail message is
   actually plain text in the US-ASCII character set since it might well
   be a message that, using some set of nonstandard local conventions
   that predate MIME, includes text in another character set or non-
   textual data presented in a manner that cannot be automatically
   recognized (e.g., a uuencoded compressed UNIX tar file).
</para>
</note>
</sect1>

<sect1 xml:id="rfc2045-s5"><title><literal>Content-Type</literal> Header Field</title>
<para>
   The purpose of the <literal>Content-Type</literal> field is to describe the data
   contained in the body fully enough that the receiving user agent can
   pick an appropriate agent or mekanizma to present the data to the
   user, or otherwise deal with the data in an appropriate manner. The
   value in this field is called a media type.
</para><note><title>HISTORICAL NOTE:</title><para>
   The <literal>Content-Type</literal> header field was first defined in
   RFC 1049.  RFC 1049 used a simpler and less powerful syntax, but one
   that is largely compatible with the mekanizma given here.
</para></note><para>
   The <literal>Content-Type</literal> header field specifies the nature of the data in the
   body of an entity by giving media type and alttür identifiers, and
   by providing auxiliary information that may be required for certain
   media types.  After the media type and alttür names, the remainder
   of the header field is simply a set of parameters, specified in an
   attribute=value notation.  The ordering of parameters is not
   significant.
</para><para>
   In general, the top-level media type is used to declare the general
   type of data, while the alttür specifies a specific format for that
   type of data.  Thus, a media type of "image/xyz" is enough to tell a
   user agent that the data is an image, even if the user agent has no
   knowledge of the specific image format "xyz".  Such information can
   be used, for example, to decide whether or not to show a user the raw
   data from an unrecognized alttür -- such an action might be
   reasonable for unrecognized alttürs of text, but not for
   unrecognized alttürs of image or audio.  For this reason, registered
   alttürs of text, image, audio, and video should not contain embedded
   information that is really of a different type.  Such compound
   formats should be represented using the "multipart" or "application"
   types.
</para><para>
   Parameters are modifiers of the media alttür, and as such do not
   fundamentally affect the nature of the content.  The set of
   meaningful parameters depends on the media type and alttür.  Most
   parameters are associated with a single specific alttür.  However, a
   given top-level media type may define parameters which are applicable
   to any alttür of that type.  Parameters may be required by their
   defining content type or alttür or they may be optional. MIME
   implementations must ignore any parameters whose names they do not
   recognize.
</para><para>
   For example, the "charset" parameter is applicable to any alttür of
   "text", while the "boundary" parameter is required for any alttür of
   the "multipart" media type.
</para><para>
   There are NO globally-meaningful parameters that apply to all media
   types.  Truly global mekanizmas are best addressed, in the MIME
   model, by the definition of additional Content-* header fields.
</para><para>
   An initial set of seven top-level media types is defined in RFC 2046.
   Five of these are discrete types whose content is essentially opaque
   as far as MIME processing is concerned.  The remaining two are
   composite types whose contents require additional handling by MIME
   processors.
</para><para>
   This set of top-level media types is intended to be substantially
   complete.  It is expected that additions to the larger set of
   supported types can generally be accomplished by the creation of new
   alttürs of these initial types.  In the future, more top-level types
   may be defined only by a standards-track extension to this standard.
   If another top-level type is to be used for any reason, it must be
   given a name starting with "X-" to indicate its non-standard status
   and to avoid a potential conflict with a future official name.
</para>

<sect2 xml:id="rfc2045-s51">
<title>Syntax of the <literal>Content-Type</literal> Header Field</title>
<para>
   In the Augmented BNF notation of RFC 822, a <literal>Content-Type</literal> header field
   value is defined as follows:
</para><literallayout>
     içerik := "Content-Type" ":" tür "/" alttür
                *(";" bağımsız değişken)
                ; Matching of media type and alttür
                ; is ALWAYS case-insensitive.

     tür := ayrık-tür / bileşik-tür

     ayrık-tür := "text" / "image" / "audio" / "video" /
                      "application" / eklenti-dizgeciği

     bileşik-tür := "message" / "multipart" / eklenti-dizgeciği

     eklenti-dizgeciği := ietf-dizgeciği / x-dizgeciği

     ietf-dizgeciği := &lt;An extension dizgecik defined by a
                    standards-track RFC and registered
                    with IANA.>

     x-dizgeciği := &lt;The two characters "X-" or "x-" followed, with
                 no intervening white space, by any dizgecik>

     alttür := eklenti-dizgeciği / iana-dizgeciği

     iana-dizgeciği := &lt;A publicly-defined extension dizgecik. Tokens
                    of this form must be registered with IANA
                    as specified in RFC 2048.>

     bağımsız değişken := öznitelik "=" değer

     öznitelik := dizgecik
                  ; Matching of özniteliks
                  ; is ALWAYS case-insensitive.

     değer := dizgecik / tırnaklı-dizge

     dizgecik := 1*&lt;any (US-ASCII) KRK except BOŞKRK, DNTs,
                 or mime-imleri>

     mime-imleri :=  "(" / ")" / "&lt;" / ">" / "@" /
                   "," / ";" / ":" / "\" / ÇTIRNAK
                   "/" / "[" / "]" / "?" / "="
                   ; Must be in tırnaklı-dizge,
                   ; to use within parameter değers
</literallayout><para>
   Note that the definition of "mime-imleri" is the same as the RFC 822
   definition of "imler" with the addition of the three characters
   "/", "?", and "=", and the removal of ".".
</para><para>
   Note also that a alttür specification is MANDATORY -- it may not be
   omitted from a <literal>Content-Type</literal> header field.  As such, there are no
   default alttürs.
</para><para>
   The type, alttür, and parameter names are not case sensitive.  For
   example, TEXT, Text, and TeXt are all equivalent top-level media
   types.  Parameter values are normally case sensitive, but sometimes
   are interpreted in a case-insensitive fashion, depending on the
   intended use.  (For example, multipart boundaries are case-sensitive,
   but the "access-type" parameter for message/External-body is not
   case-sensitive.)
</para><para>
   Note that the value of a quoted string parameter does not include the
   quotes.  That is, the quotation marks in a tırnaklı-dizge are not a
   part of the value of the parameter, but are merely used to delimit
   that parameter value.  In addition, comments are allowed in
   accordance with RFC 822 rules for structured header fields.  Thus the
   following two forms
</para><literallayout>
     Content-type: text/plain; charset=us-ascii (Plain text)

     Content-type: text/plain; charset="us-ascii"
</literallayout><para>
   are completely equivalent.
</para><para>
   Beyond this syntax, the only syntactic constraint on the definition
   of alttür names is the desire that their uses must not conflict.
   That is, it would be undesirable to have two different communities
   using "<literal>Content-Type</literal>: application/foobar" to mean two different
   things.  The process of defining new media alttürs, then, is not
   intended to be a mekanizma for imposing restrictions, but simply a
   mekanizma for publicizing their definition and usage.  There are,
   therefore, two acceptable mekanizmas for defining new media alttürs:
</para><orderedlist><listitem><para>
    (1)   Private values (starting with "X-") may be defined
          bilaterally between two cooperating agents without
          outside registration or standardization. Such values
          cannot be registered or standardized.
</para></listitem><listitem><para>
    (2)   New standard values should be registered with IANA as
          described in RFC 2048.
</para></listitem></orderedlist><para>
   The second document in this set, RFC 2046, defines the initial set of
   media types for MIME.
</para>
</sect2>

<sect2 xml:id="rfc2045-s52"><title><literal>Content-Type</literal> Defaults</title>
<para>
   Default RFC 822 messages without a MIME <literal>Content-Type</literal> header are taken
   by this protocol to be plain text in the US-ASCII character set,
   which can be explicitly specified as:
</para><literallayout>
     Content-type: text/plain; charset=us-ascii
</literallayout><para>
   This default is assumed if no <literal>Content-Type</literal> header field is specified.
   It is also recommend that this default be assumed when a
   syntactically invalid <literal>Content-Type</literal> header field is encountered. In
   the presence of a <literal>MIME-Version</literal> header field and the absence of any
   <literal>Content-Type</literal> header field, a receiving User Agent can also assume
   that plain US-ASCII text was the sender's intent.  Plain US-ASCII
   text may still be assumed in the absence of a <literal>MIME-Version</literal> or the
   presence of an syntactically invalid <literal>Content-Type</literal> header field, but
   the sender's intent might have been otherwise.
</para>
</sect2>
</sect1>

<sect1 xml:id="rfc2045-s6">
<title><literal>Content-Transfer-Encoding</literal> Header Field</title>
<para>
   Many media types which could be usefully transported via email are
   represented, in their "natural" format, as 8bit character or binary
   data.  Such data cannot be transmitted over some transfer protocols.
   For example, RFC 821 (SMTP) restricts mail messages to 7bit US-ASCII
   data with lines no longer than 1000 characters including any trailing
   CRLF line separator.
</para><para>
   It is necessary, therefore, to define a standard mekanizma for
   encoding such data into a 7bit short line format.  Proper labelling
   of unencoded material in less restrictive formats for direct use over
   less restrictive transports is also desireable.  This document
   specifies that such encodings will be indicated by a new "Content-
   Transfer-Encoding" header field.  This field has not been defined by
   any previous standard.
</para>

<sect2 xml:id="rfc2045-s61">
<title><literal>Content-Transfer-Encoding</literal> Syntax</title>
<para>
   The <literal>Content-Transfer-Encoding</literal> field's value is a single token
   specifying the type of encoding, as enumerated below.  Formally:
</para><literallayout>
     kodlama := "Content-Transfer-Encoding" ":" mekanizma

     mekanizma := "7bit" / "8bit" / "binary" /
                  "quoted-printable" / "base64" /
                  ietf-dizgeciği / x-dizgeciği
</literallayout><para>
   These values are not case sensitive -- Base64 and BASE64 and bAsE64
   are all equivalent.  An kodlama type of 7BIT requires that the body
   is already in a 7bit mail-ready representation.  This is the default
   value -- that is, "<literal>Content-Transfer-Encoding</literal>: 7BIT" is assumed if the
   <literal>Content-Transfer-Encoding</literal> header field is not present.
</para>
</sect2>

<sect2 xml:id="rfc2045-s62">
<title><literal>Content-Transfer-Encoding</literal>s Semantics</title>
<para>
   This single <literal>Content-Transfer-Encoding</literal> token actually provides two
   pieces of information.  It specifies what sort of kodlama
   transformation the body was subjected to and hence what decoding
   operation must be used to restore it to its original form, and it
   specifies what the domain of the result is.
</para><para>
   The transformation part of any <literal>Content-Transfer-Encoding</literal>s specifies,
   either explicitly or implicitly, a single, well-defined decoding
   algorithm, which for any sequence of encoded octets either transforms
   it to the original sequence of octets which was encoded, or shows
   that it is illegal as an encoded sequence.  Content-Transfer-
   Encodings transformations never depend on any additional external
   profile information for proper operation. Note that while decoders
   must produce a single, well-defined output for a valid kodlama no
   such restrictions exist for encoders: Encoding a given sequence of
   octets to different, equivalent encoded sequences is perfectly legal.
</para><para>
   Three transformations are currently defined: identity, the "quoted-
   printable" kodlama, and the "base64" kodlama.  The domains are
   "binary", "8bit" and "7bit".
</para><para>
   The <literal>Content-Transfer-Encoding</literal> values "7bit", "8bit", and "binary" all
   mean that the identity (i.e. NO) kodlama transformation has been
   performed.  As such, they serve simply as indicators of the domain of
   the body data, and provide useful information about the sort of
   kodlama that might be needed for transmission in a given transport
   system.  The terms "7bit data", "8bit data", and "binary data" are
   all defined in Section 2.
</para><para>
   The quoted-printable and base64 kodlamas transform their input from
   an arbitrary domain into material in the "7bit" range, thus making it
   safe to carry over restricted transports.  The specific definition of
   the transformations are given below.
</para><para>
   The proper <literal>Content-Transfer-Encoding</literal> label must always be used.
   Labelling unencoded data containing 8bit characters as "7bit" is not
   allowed, nor is labelling unencoded non-line-oriented data as
   anything other than "binary" allowed.
</para><para>
   Unlike media alttürs, a proliferation of <literal>Content-Transfer-Encoding</literal>
   values is both undesirable and unnecessary.  However, establishing
   only a single transformation into the "7bit" domain does not seem
   possible.  There is a tradeoff between the desire for a compact and
   efficient kodlama of largely- binary data and the desire for a
   somewhat readable kodlama of data that is mostly, but not entirely,
   7bit.  For this reason, at least two kodlama mekanizmas are
   necessary: a more or less readable kodlama (quoted-printable) and a
   "dense" or "uniform" kodlama (base64).
</para><para>
   Mail transport for unencoded 8bit data is defined in RFC 1652.  As of
   the initial publication of this document, there are no standardized
   Internet mail transports for which it is legitimate to include
   unencoded binary data in mail bodies.  Thus there are no
   circumstances in which the "binary" <literal>Content-Transfer-Encoding</literal> is
   actually valid in Internet mail.  However, in the event that binary
   mail transport becomes a reality in Internet mail, or when MIME is
   used in conjunction with any other binary-capable mail transport
   mekanizma, binary bodies must be labelled as such using this
   mekanizma.
</para><note><para>
   NOTE: The five values defined for the <literal>Content-Transfer-Encoding</literal> field
   imply nothing about the media type other than the algorithm by which
   it was encoded or the transport system requirements if unencoded.
</para>
</note>
</sect2>

<sect2 xml:id="rfc2045-s63">
<title>New <literal>Content-Transfer-Encoding</literal>s</title>
<para>
   Implementors may, if necessary, define private Content-Transfer-
   Encoding values, but must use an x-dizgeciği, which is a name prefixed by
   "X-", to indicate its non-standard status, e.g., "Content-Transfer-
   Encoding: x-my-new-kodlama".  Additional standardized Content-
   Transfer-Encoding values must be specified by a standards-track RFC.
   The requirements such specifications must meet are given in RFC 2048.
   As such, all content-transfer-encoding namespace except that
   beginning with "X-" is explicitly reserved to the IETF for future
   use.
</para><para>
   Unlike media types and alttürs, the creation of new Content-
   Transfer-Encoding values is STRONGLY discouraged, as it seems likely
   to hinder interoperability with little potential benefit
</para>
</sect2>

<sect2 xml:id="rfc2045-s64">
<title>Interpretation and Use</title>
<para>
   If a <literal>Content-Transfer-Encoding</literal> header field appears as part of a
   message header, it applies to the entire body of that message.  If a
   <literal>Content-Transfer-Encoding</literal> header field appears as part of an entity's
   headers, it applies only to the body of that entity.  If an entity is
   of type "multipart" the <literal>Content-Transfer-Encoding</literal> is not permitted to
   have any value other than "7bit", "8bit" or "binary".  Even more
   severe restrictions apply to some alttürs of the "message" type.
</para><para>
   It should be noted that most media types are defined in terms of
   octets rather than bits, so that the mekanizmas described here are
   mekanizmas for encoding arbitrary octet streams, not bit streams.  If
   a bit stream is to be encoded via one of these mekanizmas, it must
   first be converted to an 8bit byte stream using the network standard
   bit order ("big-endian"), in which the earlier bits in a stream
   become the higher-order bits in a 8bit byte.  A bit stream not ending
   at an 8bit boundary must be padded with zeroes. RFC 2046 provides a
   mekanizma for noting the addition of such padding in the case of the
   application/octet-stream media type, which has a "padding" parameter.
</para><para>
   The encoding mekanizmas defined here explicitly encode all data in
   US-ASCII.  Thus, for example, suppose an entity has header fields
   such as:
</para><literallayout>
     Content-Type: text/plain; charset=ISO-8859-1
     Content-transfer-encoding: base64
</literallayout><para>
   This must be interpreted to mean that the body is a base64 US-ASCII
   encoding of data that was originally in ISO-8859-1, and will be in
   that character set again after decoding.
</para><para>
   Certain <literal>Content-Transfer-Encoding</literal> values may only be used on certain
   media types.  In particular, it is EXPRESSLY FORBIDDEN to use any
   encodings other than "7bit", "8bit", or "binary" with any composite
   media type, i.e. one that recursively includes other <literal>Content-Type</literal>
   fields.  Currently the only composite media types are "multipart" and
   "message".  All encodings that are desired for bodies of type
   multipart or message must be done at the innermost level, by encoding
   the actual body that needs to be encoded.
</para><para>
   It should also be noted that, by definition, if a composite entity
   has a transfer-encoding value such as "7bit", but one of the enclosed
   entities has a less restrictive value such as "8bit", then either the
   outer "7bit" labelling is in error, because 8bit data are included,
   or the inner "8bit" labelling placed an unnecessarily high demand on
   the transport system because the actual included data were actually
   7bit-safe.
</para><note><title>NOTE ON ENCODING RESTRICTIONS:</title><para>
   Though the prohibition against using
   content-transfer-encodings on composite body data may seem overly
   restrictive, it is necessary to prevent nested encodings, in which
   data are passed through an encoding algorithm multiple times, and
   must be decoded multiple times in order to be properly viewed.
   Nested encodings add considerable complexity to user agents:  Aside
   from the obvious efficiency problems with such multiple encodings,
   they can obscure the basic structure of a message.  In particular,
   they can imply that several decoding operations are necessary simply
   to find out what types of bodies a message contains.  Banning nested
   encodings may complicate the job of certain mail gateways, but this
   seems less of a problem than the effect of nested encodings on user
   agents.
</para></note><para>
   Any entity with an unrecognized <literal>Content-Transfer-Encoding</literal> must be
   treated as if it has a <literal>Content-Type</literal> of "application/octet-stream",
   regardless of what the <literal>Content-Type</literal> header field actually says.
</para><note>
<title>NOTE ON THE RELATIONSHIP BETWEEN CONTENT-TYPE AND CONTENT-TRANSFER-ENCODING:</title><para>
  It may seem that the <literal>Content-Transfer-Encoding</literal> could be
   inferred from the characteristics of the media that is to be encoded,
   or, at the very least, that certain <literal>Content-Transfer-Encoding</literal>s could
   be mandated for use with specific media types.  There are several
   reasons why this is not the case. First, given the varying types of
   transports used for mail, some encodings may be appropriate for some
   combinations of media types and transports but not for others.  (For
   example, in an 8bit transport, no encoding would be required for text
   in certain character sets, while such encodings are clearly required
   for 7bit SMTP.)
</para></note><para>
   Second, certain media types may require different types of transfer
   encoding under different circumstances.  For example, many PostScript
   bodies might consist entirely of short lines of 7bit data and hence
   require no encoding at all.  Other PostScript bodies (especially
   those using Level 2 PostScript's binary encoding mekanizma) may only
   be reasonably represented using a binary transport encoding.
   Finally, since the <literal>Content-Type</literal> field is intended to be an open-ended
   specification mekanizma, strict specification of an association
   between media types and encodings effectively couples the
   specification of an application protocol with a specific lower-level
   transport.  This is not desirable since the developers of a media
   type should not have to be aware of all the transports in use and
   what their limitations are.
</para>
</sect2>

<sect2 xml:id="rfc2045-s65"><title>Translating Encodings</title>
<para>
   The quoted-printable and base64 encodings are designed so that
   conversion between them is possible.  The only issue that arises in
   such a conversion is the handling of hard line breaks in quoted-
   printable encoding output. When converting from quoted-printable to
   base64 a hard line break in the quoted-printable form represents a
   CRLF sequence in the canonical form of the data. It must therefore be
   converted to a corresponding encoded CRLF in the base64 form of the
   data.  Similarly, a CRLF sequence in the canonical form of the data
   obtained after base64 decoding must be converted to a quoted-
   printable hard line break, but ONLY when converting text data.
</para><para>
   There was some confusion, in the previous versions of this RFC,
   regarding the model for when email data was to be converted to
   canonical form and encoded, and in particular how this process would
   affect the treatment of CRLFs, given that the representation of
   newlines varies greatly from system to system, and the relationship
   between content-transfer-encodings and character sets.  A canonical
   model for encoding is presented in RFC 2049 for this reason.
</para>
</sect2>

<sect2 xml:id="rfc2045-s67">
<title>Quoted-Printable <literal>Content-Transfer-Encoding</literal></title>
<para>
   The Quoted-Printable encoding is intended to represent data that
   largely consists of octets that correspond to printable characters in
   the US-ASCII character set.  It encodes the data in such a way that
   the resulting octets are unlikely to be modified by mail transport.
   If the data being encoded are mostly US-ASCII text, the encoded form
   of the data remains largely recognizable by humans.  A body which is
   entirely US-ASCII may also be encoded in Quoted-Printable to ensure
   the integrity of the data should the message pass through a
   character-translating, and/or line-wrapping gateway.
</para><para>
   In this encoding, octets are to be represented as determined by the
   following rules:
</para><orderedlist><listitem><para>
    (1)   (General 8bit representation) Any octet, except a CR or
          LF that is part of a CRLF line break of the canonical
          (standard) form of the data being encoded, may be
          represented by an "=" followed by a two digit
          hexadecimal representation of the octet's value.  The
          digits of the hexadecimal alphabet, for this purpose,
          are "0123456789ABCDEF".  Uppercase letters must be
          used; lowercase letters are not allowed.  Thus, for
          example, the decimal value 12 (US-ASCII form feed) can
          be represented by "=0C", and the decimal value 61 (US-
          ASCII EQUAL SIGN) can be represented by "=3D".  This
          rule must be followed except when the following rules
          allow an alternative encoding.
</para></listitem><listitem><para>
    (2)   (Literal representation) Octets with decimal values of
          33 through 60 inclusive, and 62 through 126, inclusive,
          MAY be represented as the US-ASCII characters which
          correspond to those octets (EXCLAMATION POINT through
          LESS THAN, and GREATER THAN through TILDE,
          respectively).
</para></listitem><listitem><para>
    (3)   (White Space) Octets with values of 9 and 32 MAY be
          represented as US-ASCII TAB (HT) and BOŞKRK characters,
          respectively, but MUST NOT be so represented at the end
          of an encoded line.  Any TAB (HT) or BOŞKRK characters
          on an encoded line MUST thus be followed on that line
          by a printable character.  In particular, an "=" at the
          end of an encoded line, indicating a soft line break
          (see rule #5) may follow one or more TAB (HT) or BOŞKRK
          characters.  It follows that an octet with decimal
          value 9 or 32 appearing at the end of an encoded line
          must be represented according to Rule #1.  This rule is
          necessary because some MTAs (Message Transport Agents,
          programs which transport messages from one user to
          another, or perform a portion of such transfers) are
          known to pad lines of text with BOŞKRKs, and others are
          known to remove "white space" characters from the end
          of a line.  Therefore, when decoding a Quoted-Printable
          body, any trailing white space on a line must be
          deleted, as it will necessarily have been added by
          intermediate transport agents.
</para></listitem><listitem><para>
    (4)   (Line Breaks) A line break in a text body, represented
          as a CRLF sequence in the text canonical form, must be
          represented by a (RFC 822) line break, which is also a
          CRLF sequence, in the Quoted-Printable encoding.  Since
          the canonical representation of media types other than
          text do not generally include the representation of
          line breaks as CRLF sequences, no hard line breaks
          (i.e. line breaks that are intended to be meaningful
          and to be displayed to the user) can occur in the
          quoted-printable encoding of such types.  Sequences
          like "=0D", "=0A", "=0A=0D" and "=0D=0A" will routinely
          appear in non-text data represented in quoted-
          printable, of course.
</para><para>
          Note that many implementations may elect to encode the
          local representation of various content types directly
          rather than converting to canonical form first,
          encoding, and then converting back to local
          representation.  In particular, this may apply to plain
          text material on systems that use newline conventions
          other than a CRLF terminator sequence.  Such an
          implementation optimization is permissible, but only
          when the combined canonicalization-encoding step is
          equivalent to performing the three steps separately.
</para></listitem><listitem><para>
    (5)   (Soft Line Breaks) The Quoted-Printable encoding
          REQUIRES that encoded lines be no more than 76
          characters long.  If longer lines are to be encoded
          with the Quoted-Printable encoding, "soft" line breaks
          must be used.  An equal sign as the last character on a
          encoded line indicates such a non-significant ("soft")
          line break in the encoded text.
</para></listitem></orderedlist><para>
   Thus if the "raw" form of the line is a single unencoded line that
   says:
</para><literallayout>
     Now's the time for all folk to come to the aid of their country.
</literallayout><para>
   This can be represented, in the Quoted-Printable encoding, as:
</para><literallayout>
     Now's the time =
     for all folk to come=
      to the aid of their country.
</literallayout><para>
   This provides a mekanizma with which long lines are encoded in such a
   way as to be restored by the user agent.  The 76 character limit does
   not count the trailing CRLF, but counts all other characters,
   including any equal signs.
</para><para>
   Since the hyphen character ("-") may be represented as itself in the
   Quoted-Printable encoding, care must be taken, when encapsulating a
   quoted-printable encoded body inside one or more multipart entities,
   to ensure that the boundary delimiter does not appear anywhere in the
   encoded body.  (A good strategy is to choose a boundary that includes
   a character sequence such as "=_" which can never appear in a
   quoted-printable body.  See the definition of multipart messages in
   RFC 2046.)
</para><note><para>
   NOTE: The quoted-printable encoding represents something of a
   compromise between readability and reliability in transport.  Bodies
   encoded with the quoted-printable encoding will work reliably over
   most mail gateways, but may not work perfectly over a few gateways,
   notably those involving translation into EBCDIC.  A higher level of
   confidence is offered by the base64 <literal>Content-Transfer-Encoding</literal>.  A way
   to get reasonably reliable transport through EBCDIC gateways is to
   also quote the US-ASCII characters
</para><literallayout>
     !"#$@[\]^`{|}~
</literallayout><para>
   according to rule #1.
</para></note><para>
   Because quoted-printable data is generally assumed to be line-
   oriented, it is to be expected that the representation of the breaks
   between the lines of quoted-printable data may be altered in
   transport, in the same manner that plain text mail has always been
   altered in Internet mail when passing between systems with differing
   newline conventions.  If such alterations are likely to constitute a
   corruption of the data, it is probably more sensible to use the
   base64 encoding rather than the quoted-printable encoding.
</para><note><para>
   NOTE: Several kinds of substrings cannot be generated according to
   the encoding rules for the quoted-printable content-transfer-
   encoding, and hence are formally illegal if they appear in the output
   of a quoted-printable encoder. This note enumerates these cases and
   suggests ways to handle such illegal substrings if any are
   encountered in quoted-printable data that is to be decoded.
</para></note><orderedlist><listitem><para>
    (1)   An "=" followed by two hexadecimal digits, one or both
          of which are lowercase letters in "abcdef", is formally
          illegal. A robust implementation might choose to
          recognize them as the corresponding uppercase letters.
</para></listitem><listitem><para>
    (2)   An "=" followed by a character that is neither a
          hexadecimal digit (including "abcdef") nor the CR
          character of a CRLF pair is illegal.  This case can be
          the result of US-ASCII text having been included in a
          quoted-printable part of a message without itself
          having been subjected to quoted-printable encoding.  A
          reasonable approach by a robust implementation might be
          to include the "=" character and the following
          character in the decoded data without any
          transformation and, if possible, indicate to the user
          that proper decoding was not possible at this point in
          the data.
</para></listitem><listitem><para>
    (3)   An "=" cannot be the ultimate or penultimate character
          in an encoded object.  This could be handled as in case
          (2) above.
</para></listitem><listitem><para>
    (4)   Control characters other than TAB, or CR and LF as
          parts of CRLF pairs, must not appear. The same is true
          for octets with decimal values greater than 126.  If
          found in incoming quoted-printable data by a decoder, a
          robust implementation might exclude them from the
          decoded data and warn the user that illegal characters
          were discovered.
</para></listitem><listitem><para>
    (5)   Encoded lines must not be longer than 76 characters,
          not counting the trailing CRLF. If longer lines are
          found in incoming, encoded data, a robust
          implementation might nevertheless decode the lines, and
          might report the erroneous encoding to the user.
</para></listitem></orderedlist>
<warning><title>WARNING TO IMPLEMENTORS:</title><para>
  If binary data is encoded in quoted-
   printable, care must be taken to encode CR and LF characters as "=0D"
   and "=0A", respectively.  In particular, a CRLF sequence in binary
   data should be encoded as "=0D=0A".  Otherwise, if CRLF were
   represented as a hard line break, it might be incorrectly decoded on
   platforms with different line break conventions.
</para></warning><para>
   For formalists, the syntax of quoted-printable data is described by
   the following grammar:
</para><literallayout>
     quoted-printable := qp-line *(CRLF qp-line)

     qp-line := *(qp-segment aktarım-dolgusu CRLF)
                qp-part aktarım-dolgusu

     qp-part := qp-section
                ; Maximum length of 76 characters

     qp-segment := qp-section *(BOŞKRK / TAB) "="
                   ; Maximum length of 76 characters

     qp-section := [*(ptext / BOŞKRK / TAB) ptext]

     ptext := hex-octet / safe-char

     safe-char := &lt;any octet with decimal value of 33 through
                  60 inclusive, and 62 through 126>
                  ; Characters not listed as "mail-safe" in
                  ; RFC 2049 are also not recommended.

     hex-octet := "=" 2(RAKAM / "A" / "B" / "C" / "D" / "E" / "F")
                  ; Octet must be used for characters > 127, =,
                  ; BOŞKRKs or TABs at the ends of lines, and is
                  ; recommended for any character not listed in
                  ; RFC 2049 as "mail-safe".

     aktarım-dolgusu := *BOŞLUK-krk
                          ; Composers MUST NOT generate
                          ; non-zero length transport
                          ; padding, but receivers MUST
                          ; be able to handle padding
                          ; added by message transports.
</literallayout>
<important><para>
   The addition of LWSP between the elements shown in this
   BNF is NOT allowed since this BNF does not specify a structured
   header field.
</para>
</important>
</sect2>

<sect2 xml:id="rfc2045-s68">
<title>Base64 <literal>Content-Transfer-Encoding</literal></title>
<para>
   The Base64 <literal>Content-Transfer-Encoding</literal> is designed to represent
   arbitrary sequences of octets in a form that need not be humanly
   readable.  The encoding and decoding algorithms are simple, but the
   encoded data are consistently only about 33 percent larger than the
   unencoded data.  This encoding is virtually identical to the one used
   in Privacy Enhanced Mail (PEM) applications, as defined in RFC 1421.
</para><para>
   A 65-character subset of US-ASCII is used, enabling 6 bits to be
   represented per printable character. (The extra 65th character, "=",
   is used to signify a special processing function.)
</para><note><para>
   NOTE:  This subset has the important property that it is represented
   identically in all versions of ISO 646, including US-ASCII, and all
   characters in the subset are also represented identically in all
   versions of EBCDIC. Other popular encodings, such as the encoding
   used by the uuencode utility, Macintosh binhex 4.0 [<xref linkend="rfc2045-RFC-1741"/>], and
   the base85 encoding specified as part of Level 2 PostScript, do not
   share these properties, and thus do not fulfill the portability
   requirements a binary transport encoding for mail must meet.
</para></note><para>
   The encoding process represents 24-bit groups of input bits as output
   strings of 4 encoded characters.  Proceeding from left to right, a
   24-bit input group is formed by concatenating 3 8bit input groups.
   These 24 bits are then treated as 4 concatenated 6-bit groups, each
   of which is translated into a single digit in the base64 alphabet.
   When encoding a bit stream via the base64 encoding, the bit stream
   must be presumed to be ordered with the most-significant-bit first.
   That is, the first bit in the stream will be the high-order bit in
   the first 8bit byte, and the eighth bit will be the low-order bit in
   the first 8bit byte, and so on.
</para><para>
   Each 6-bit group is used as an index into an array of 64 printable
   characters.  The character referenced by the index is placed in the
   output string.  These characters, identified in Table 1, below, are
   selected so as to be universally representable, and the set excludes
   characters with particular significance to SMTP (e.g., ".", CR, LF)
   and to the multipart boundary delimiters defined in RFC 2046 (e.g.,
   "-").
</para><literallayout>
                Table 1: The Base64 Alphabet

  Value Encoding  Value Encoding  Value Encoding  Value Encoding
      0 A            17 R            34 i            51 z
      1 B            18 S            35 j            52 0
      2 C            19 T            36 k            53 1
      3 D            20 U            37 l            54 2
      4 E            21 V            38 m            55 3
      5 F            22 W            39 n            56 4
      6 G            23 X            40 o            57 5
      7 H            24 Y            41 p            58 6
      8 I            25 Z            42 q            59 7
      9 J            26 a            43 r            60 8
     10 K            27 b            44 s            61 9
     11 L            28 c            45 t            62 +
     12 M            29 d            46 u            63 /
     13 N            30 e            47 v
     14 O            31 f            48 w        (dolgu) =
     15 P            32 g            49 x
     16 Q            33 h            50 y
</literallayout><para>
   The encoded output stream must be represented in lines of no more
   than 76 characters each.  All line breaks or other characters not
   found in Table 1 must be ignored by decoding software.  In base64
   data, characters other than those in Table 1, line breaks, and other
   white space probably indicate a transmission error, about which a
   warning message or even a message rejection might be appropriate
   under some circumstances.
</para><para>
   Special processing is performed if fewer than 24 bits are available
   at the end of the data being encoded.  A full encoding quantum is
   always completed at the end of a body.  When fewer than 24 input bits
   are available in an input group, zero bits are added (on the right)
   to form an integral number of 6-bit groups.  Padding at the end of
   the data is performed using the "=" character.  Since all base64
   input is an integral number of octets, only the following cases can
   arise: (1) the final quantum of encoding input is an integral
   multiple of 24 bits; here, the final unit of encoded output will be
   an integral multiple of 4 characters with no "=" padding, (2) the
   final quantum of encoding input is exactly 8 bits; here, the final
   unit of encoded output will be two characters followed by two "="
   padding characters, or (3) the final quantum of encoding input is
   exactly 16 bits; here, the final unit of encoded output will be three
   characters followed by one "=" padding character.
</para><para>
   Because it is used only for padding at the end of the data, the
   occurrence of any "=" characters may be taken as evidence that the
   end of the data has been reached (without truncation in transit).  No
   such assurance is possible, however, when the number of octets
   transmitted was a multiple of three and no "=" characters are
   present.
</para><para>
   Any characters outside of the base64 alphabet are to be ignored in
   base64-encoded data.
</para><para>
   Care must be taken to use the proper octets for line breaks if base64
   encoding is applied directly to text material that has not been
   converted to canonical form.  In particular, text line breaks must be
   converted into CRLF sequences prior to base64 encoding.  The
   important thing to note is that this may be done directly by the
   encoder rather than in a prior canonicalization step in some
   implementations.
</para><note><para>
   NOTE: There is no need to worry about quoting potential boundary
   delimiters within base64-encoded bodies within multipart entities
   because no hyphen characters are used in the base64 encoding.
</para>
</note>
</sect2>
</sect1>

<sect1 xml:id="rfc2045-s7"><title><literal>Content-ID</literal> Header Field</title>
<para>
   In constructing a high-level user agent, it may be desirable to allow
   one body to make reference to another.  Accordingly, bodies may be
   labelled using the "<literal>Content-ID</literal>" header field, which is syntactically
   identical to the "Message-ID" header field:
</para><literallayout>
     id := "Content-ID" ":" ileti-id
</literallayout><para>
   Like the Message-ID values, <literal>Content-ID</literal> values must be generated to be
   world-unique.
</para><para>
   The <literal>Content-ID</literal> value may be used for uniquely identifying MIME
   entities in several contexts, particularly for caching data
   referenced by the message/external-body mekanizma.  Although the
   <literal>Content-ID</literal> header is generally optional, its use is MANDATORY in
   implementations which generate data of the optional MIME media type
   "message/external-body".  That is, each message/external-body entity
   must have a <literal>Content-ID</literal> field to permit caching of such data.
</para><para>
   It is also worth noting that the <literal>Content-ID</literal> value has special
   semantics in the case of the multipart/alternative media type.  This
   is explained in the section of RFC 2046 dealing with
   multipart/alternative.
</para>
</sect1>

<sect1 xml:id="rfc2045-s8"><title><literal>Content-Description</literal> Header Field</title>
<para>
   The ability to associate some descriptive information with a given
   body is often desirable.  For example, it may be useful to mark an
   "image" body as "a picture of the Space Shuttle Endeavor."  Such text
   may be placed in the <literal>Content-Description</literal> header field.  This header
   field is always optional.
</para><literallayout>
     description := "Content-Description" ":" *text
</literallayout><para>
   The description is presumed to be given in the US-ASCII character
   set, although the mekanizma specified in RFC 2047 may be used for
   non-US-ASCII <literal>Content-Description</literal> values.
</para>
</sect1>

<sect1 xml:id="rfc2045-s9"><title>Additional MIME Header Fields</title>
<para>
   Future documents may elect to define additional MIME header fields
   for various purposes.  Any new header field that further describes
   the content of a message should begin with the string "Content-" to
   allow such fields which appear in a message header to be
   distinguished from ordinary RFC 822 message header fields.
</para><literallayout>
     MIME-extension-field := &lt;Any RFC 822 header field which
                              begins with the string
                              "Content-">
</literallayout>
</sect1>

<sect1 xml:id="rfc2045-sa"><title>Summary</title>
<para>
   Using the <literal>MIME-Version</literal>, <literal>Content-Type</literal>, and <literal>Content-Transfer-Encoding</literal>
   header fields, it is possible to include, in a standardized way,
   arbitrary types of data with RFC 822 conformant mail messages.  No
   restrictions imposed by either RFC 821 or RFC 822 are violated, and
   care has been taken to avoid problems caused by additional
   restrictions imposed by the characteristics of some Internet mail
   transport mekanizmas (see RFC 2049).
</para><para>
   The next document in this set, RFC 2046, specifies the initial set of
   media types that can be labelled and transported using these headers.
</para>
</sect1>

<sect1 xml:id="rfc2045-sb"><title>Security Considerations</title>
<para>
   Security issues are discussed in the second document in this set, RFC
   2046.
</para>
</sect1>

<sect1 xml:id="rfc2045-sc"><title>Authors' Addresses</title>
<para>
   For more information, the authors of this document are best contacted
   via Internet mail:
</para><literallayout>
   Ned Freed
   Innosoft International, Inc.
   1050 East Garvey Avenue South
   West Covina, CA 91790
   USA

   Phone: +1 818 919 3600
   Fax:   +1 818 919 3614
   EMail: ned@innosoft.com


   Nathaniel S. Borenstein
   First Virtual Holdings
   25 Washington Avenue
   Morristown, NJ 07960
   USA

   Phone: +1 201 540 8967
   Fax:   +1 201 993 3032
   EMail: nsb@nsb.fv.com
</literallayout><para>
   MIME is a result of the work of the Internet Engineering Task Force
   Working Group on RFC 822 Extensions.  The chairman of that group,
   Greg Vaudreuil, may be reached at:
</para><literallayout>
   Gregory M. Vaudreuil
   Octel Network Services
   17080 Dallas Parkway
   Dallas, TX 75248-1905
   USA

   EMail: Greg.Vaudreuil@Octel.Com
</literallayout>
</sect1>

<appendix xml:id="rfc2045-appa"><title>Collected Grammar</title>
<para>
   This appendix contains the complete BNF grammar for all the syntax
   specified by this document.
</para><para>
   By itself, however, this grammar is incomplete.  It refers by name to
   several syntax rules that are defined by RFC 822.  Rather than
   reproduce those definitions here, and risk unintentional differences
   between the two, this document simply refers the reader to RFC 822
   for the remaining definitions. Wherever a term is undefined, it
   refers to the RFC 822 definition.
</para><literallayout>
  öznitelik := dizgecik
               ; Matching of özniteliks
               ; is ALWAYS case-insensitive.

  bileşik-tür := "message" / "multipart" / eklenti-dizgeciği

  içerik := "Content-Type" ":" tür "/" alttür
             *(";" bağımsız değişken)
             ; Matching of media type and alttür
             ; is ALWAYS case-insensitive.

  izahat := "Content-Description" ":" *metin

  ayrık-tür := "text" / "image" / "audio" / "video" /
                   "application" / eklenti-dizgeciği

  kodlama := "Content-Transfer-Encoding" ":" mekanizma

  öğe-başlıkları := [ içerik CRLF ]
                    [ kodlama CRLF ]
                    [ id CRLF ]
                    [ izahat CRLF ]
                    *( MIME-eklenti-alanı CRLF )

  eklenti-dizgeciği := ietf-dizgeciği / x-dizgeciği

  hex-octet := "=" 2(RAKAM / "A" / "B" / "C" / "D" / "E" / "F")
               ; Octet must be used for characters > 127, =,
               ; BOŞKRKs or YSEKs at the ends of lines, and is
               ; recommended for any character not listed in
               ; RFC 2049 as "mail-safe".

  iana-dizgeciği := &lt;A publicly-defined extension dizgecik. Tokens
                 of this form must be registered with IANA
                 as specified in RFC 2048.>

  ietf-dizgeciği := &lt;An extension dizgecik defined by a
                 standards-track RFC and registered
                 with IANA.>

  id := "Content-ID" ":" ileti-id

  mekanizma := "7bit" / "8bit" / "binary" /
               "quoted-printable" / "base64" /
               ietf-dizgeciği / x-dizgeciği

  MIME-extension-field := &lt;Any RFC 822 header field which
                           begins with the string
                           "Content-">

  MIME-message-headers := öğe-başlıkları
                          fields
                          version CRLF
                          ; The ordering of the header
                          ; fields implied by this BNF
                          ; definition should be ignored.

  MIME-part-headers := öğe-başlıkları
                       [fields]
                       ; Any field not beginning with
                       ; "content-" can have no defined
                       ; meaning and may be ignored.
                       ; The ordering of the header
                       ; fields implied by this BNF
                       ; definition should be ignored.

  bağımsız değişken := öznitelik "=" değer

  ptext := hex-octet / safe-char

  qp-line := *(qp-segment aktarım-dolgusu CRLF)
             qp-part aktarım-dolgusu

  qp-part := qp-section
             ; Maximum length of 76 characters

  qp-section := [*(ptext / BOŞKRK / TAB) ptext]

  qp-segment := qp-section *(BOŞKRK / TAB) "="
                ; Maximum length of 76 characters

  quoted-printable := qp-line *(CRLF qp-line)

  safe-char := &lt;any octet with decimal value of 33 through
               60 inclusive, and 62 through 126>
               ; Characters not listed as "mail-safe" in
               ; RFC 2049 are also not recommended.

  alttür := eklenti-dizgeciği / iana-dizgeciği

  dizgecik := 1*&lt;any (US-ASCII) KRK except BOŞKRK, DNTs,
              or mime-imleri>

  aktarım-dolgusu := *BOŞLUK-krk
                       ; Composers MUST NOT generate
                       ; non-zero length transport
                       ; padding, but receivers MUST
                       ; be able to handle padding
                       ; added by message transports.

  mime-imleri :=  "(" / ")" / "&lt;" / ">" / "@" /
                "," / ";" / ":" / "\" / ÇTIRNAK
                "/" / "[" / "]" / "?" / "="
                ; Must be in tırnaklı-dizge,
                ; to use within parameter values

  type := ayrık-tür / bileşik-tür

  değer := dizgecik / tırnaklı-dizge

  version := "MIME-Version" ":" 1*RAKAM "." 1*RAKAM

  x-dizgeciği := &lt;The two characters "X-" or "x-" followed, with
              no  intervening white space, by any dizgecik>
</literallayout>
</appendix>
</article>


