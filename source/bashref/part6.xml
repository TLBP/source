<?xml version="1.0" encoding="UTF-8"?>
<!-- ********************************************************************
     $Id: part6.xml,v 1.12 2002/12/20 23:23:58 nilgun Exp $
     ********************************************************************-->
<part id="bashref_bash.features">
  <title>Bash'in Özellikleri</title>
  <titleabbrev>Sadece Bash'de bulunan özellikler.</titleabbrev>
  <partintro><para>
Bu oylumda sadece Bash'de bulunan özellikler açıklanmıştır.
  </para></partintro>

  <chapter id="bashref_invoking.bash" label="1">
  <title>Bash'in Çağrılması</title>
  <titleabbrev>Bash'e verebileceğiniz komut satırı seçenekleri.</titleabbrev>
<indexterm scope="bashref_concept.index">
<primary>etkileşimli</primary><secondary>kabuk</secondary></indexterm>
<indexterm scope="bashref_concept.index">
<primary>kabuk</primary><secondary>etkileşimli</secondary></indexterm>
<indexterm scope="bashref_concept.index">
<primary>giriş kabuğu</primary></indexterm>
  <para>
<synopsis><command>bash </command>[<emphasis>uzun-sçn</emphasis>] [<command>-ir</command>] <command>[-abefhkmnptuvxdBCDHP</command>] [<command>-o </command><emphasis>sçn</emphasis>] [<command>-O</command> <emphasis>shopt_sçn</emphasis>] [<emphasis>argüman</emphasis> ...]
<command>bash </command>[<emphasis>uzun-sçn</emphasis>] [<command>-abefhkmnptuvxdBCDHP</command>] [<command>-o </command><emphasis>sçn</emphasis>] [<command>-O </command><emphasis>shopt_sçn</emphasis>] <command>-c </command><emphasis>dizge</emphasis> [<emphasis>argüman</emphasis> ...]
<command>bash </command>[<emphasis>uzun-sçn</emphasis>] <command>-s </command>[<command>-abefhkmnptuvxdBCDHP</command>] [<command>-o </command><emphasis>sçn</emphasis>] [<command>-O </command><emphasis>shopt_sçn</emphasis>] [<emphasis>argüman</emphasis> ...]
</synopsis>
  </para><para>
Tek karakterlik kabuk <link linkend="bashref_set.builtin">komut satırı seçenekleri</link> yanında kullanabileceğiniz çok karakterli seçenekler de vardır.Bu seçenekler tanınabilmeleri için komut satırında tek karakterli seçeneklerden önce verilmelidir.
  </para><glosslist><glossentry>
<glossterm><option>--debugger</option></glossterm>
<glossdef><para>
Kabuk başlatılmadan önce çalıştırılacak hata ayıklama profili için düzenleme yapar. Ek <link linkend="bashref_shopt-extdebug">hata ayıklama kipini</link> ve <link linkend="bashref_set-functrace">kabuk işlevi izlemeyi</link> etkinleştirir.
</para></glossdef></glossentry>
<glossentry><glossterm><option>--dump-po-strings</option></glossterm>
<glossdef><para>
<literal>$</literal> ile öncelenmiş tüm çift tırnaklı dizgelerin bir listesi GNU <command>gettext</command> PO (portable object - uyarlanabilir nesne) dosya biçeminde standart çıktıya basılır. Çıktı biçemi dışında <option>-D</option> seçeneğine eşdeğerdir.
</para></glossdef></glossentry>
<glossentry><glossterm><option>--dump-strings</option></glossterm>
<glossdef><para>
<option>-D</option> seçeneğine eşdeğerdir.
</para></glossdef></glossentry>
<glossentry><glossterm><option>--help</option></glossterm>
<glossdef><para>
Standart çıktıda bir kullanım iletisi gösterir ve başarıyla çıkar.
</para></glossdef></glossentry>
<glossentry><glossterm><option>--init-file</option> <replaceable>dosyaismi</replaceable></glossterm>
<glossterm><option>--rcfile</option> <replaceable>dosyaismi</replaceable></glossterm>
<glossdef><para>
Bir etkileşimli kabukta <replaceable>dosyaismi</replaceable> dosyasındaki komutları çalıştırır (<filename>~/.bashrc</filename> yerine).
</para></glossdef></glossentry>
<glossentry><glossterm><option>--login</option></glossterm>
<glossdef><para>
<option>-l</option> seçeneğine eşdeğerdir.
</para></glossdef></glossentry>
<glossentry><glossterm><option>--noediting</option></glossterm>
<glossdef><para>
Kabuk etkileşimliyken komut satırlarını okuyacak GNU Readline kütüphanesi kullanılmaz (<xref linkend="bashref_command.line.editing"/> bölümüne bakınız).
</para></glossdef></glossentry>
<glossentry><glossterm><option>--noprofile</option></glossterm>
<glossdef><para>
Bash bir giriş kabuğu olarak çağrıldığında sistem çapında başlatma dosyası olan <filename>/etc/profile</filename> veya <filename>~/.bash_profile</filename>, <filename>~/.bash_login</filename> ve <filename>~/.profile</filename> kişisel ilklendirme dosyalarından herhangi birini yüklemez.
</para></glossdef></glossentry>
<glossentry><glossterm><option>--norc</option></glossterm>
<glossdef><para>
Bir etkileşimli kabukta <filename>~/.bashrc</filename> ilklendirme dosyasını okumaz. Kabuk <command>sh</command> olarak çağrılmışsa bu seçenek öntanımlı olarak etkindir.
</para></glossdef></glossentry>
<glossentry><glossterm><option>--posix</option></glossterm>
<glossdef><para>
Öntanımlı işlemin POSIX standardından farklı olduğu yerde standarda uyum için Bash'in davranışını değiştirir. Bash POSIX kipinin açıklaması için <xref linkend="bashref_posix.mode"/> bölümüne bakınız.
</para></glossdef></glossentry>
<glossentry><glossterm><option>--restricted</option></glossterm>
<glossdef><para>
Kabuğu bir <link linkend="bashref_restricted.shell">sınırlı kabuk</link> yapar.
</para></glossdef></glossentry>
<glossentry><glossterm><option>--verbose</option></glossterm>
<glossdef><para>
<option>-v</option> seçeneğine eşdeğerdir. Kabuk girdi satırlarını okunduğu gibi basar.
</para></glossdef></glossentry>
<glossentry><glossterm><option>--version</option></glossterm>
<glossdef><para>
Bash'in bu kopyası için sürüm bilgilerini gösterir ve çıkar.
</para></glossdef></glossentry>
  </glosslist><para>
<command>set</command> yerleşiği ile kullanılamayan, çağrı
sırasında verilebilen tek karakterlik  seçenekler de vardır.
  </para><glosslist>
<glossentry><glossterm><option>-c</option> <replaceable>dizge</replaceable></glossterm>
<glossdef><para>
Seçenekleri işledikten sonra <replaceable>dizge</replaceable>den komutları okuyup çalıştırır ve çıkar. Kalan argümanlar <literal>$0</literal> ile başlayan konumsal parametrelere atanır.
</para></glossdef></glossentry>
<glossentry><glossterm><option>-i</option></glossterm>
<glossdef><para>
Kabuk etkileşimli çalışmaya zorlanır. Etkileşimli kabuklar <xref linkend="bashref_interactive.shells"/> bölümünde açıklanmıştır.
</para></glossdef></glossentry>
<glossentry><glossterm><option>-l</option></glossterm>
<glossdef><para>
Bu kabuğu <command>login</command> tarafından doğrudan çağrılmışçasına etkin yapar. Kabuk etkileşimli ise bu, <command>exec -l bash</command> komutu ile bir giriş kabuğu başlatmakla eşdeğerdir. Kabuk etkileşimsiz ise, giriş kabuğu başlatma dosyaları çalıştırılacaktır. <command>exec bash --login</command> komutu o anki kabuğu bir Bash giriş kabuğu ile değiştirecektir. Bir giriş kabuğunun özel davranışlarının açıklamaları için <xref linkend="bashref_startup.files"/> bölümüne bakınız.
</para></glossdef></glossentry>
<glossentry><glossterm><option>-r</option></glossterm>
<glossdef><para>
Kabuğu <link linkend="bashref_restricted.shell">sınırlı kabuk</link> yapar.
</para></glossdef></glossentry>
<glossentry><glossterm><option>-s</option></glossterm>
<glossdef><para>
Bu seçenek verilmişse veya seçenek işlemlerinden geriye argüman kalmıyorsa, komutlar standart girdiden okunur. Bu seçenek bir etkileşimli kabuk çağrılırken konumsal parametrelerin atanmasına izin verir.
</para></glossdef></glossentry>
<glossentry><glossterm><option>-D</option></glossterm>
<glossdef><para>
<literal>$</literal> ile öncelenmiş çift tırnak içine alınmış bütün dizgelerin bir listesi standart çıktıya basılır. Bunlar yerel C ya da POSIX değilken yerel dile çeviriye konu dizgelerdir (<xref linkend="bashref_shell.quoting-translations"/> bölümüne bakınız). Bu seçenek hiçbir komutun çalıştırılmamasına sebep olan <option>-n</option> seçeneğini uygular.
</para></glossdef></glossentry>
<glossentry><glossterm><literal>[-+]</literal><option>O</option> <literal>[</literal><replaceable>shopt_seçeneği</replaceable><literal>]</literal></glossterm>
<glossdef><para>
<replaceable>shopt_seçeneği</replaceable>, <link linkend="bashref_bash.builtins-shopt"><command>shopt</command></link> yerleşiği tarafından kabul edilen kabuk seçeneklerinden biridir. <replaceable>shopt_seçeneği</replaceable> verilmişse, <option>-O</option> seçeneği etkinleştirir; <option>+O</option> ise seçeneği kaldırır. <replaceable>shopt_seçeneği</replaceable> verilmezse <command>shopt</command> tarafından kabul edilen kabuk seçeneklerinin isimleri ve değerlerinin tümü standart çıktıya basılır. Çağrı seçeneği <literal>+O</literal> ise çıktı, girdi olarak yeniden kullanılabilmesini sağlayacak biçemde basılır.
</para></glossdef></glossentry>
<glossentry><glossterm><option>--</option></glossterm>
<glossdef><para>
<option>--</option> seçeneklerin sonunu gösterir ve bundan sonra verilen seçenekler yoksayılır. <option>--</option> den sonraki argümanlar ise dosyaisimleri ve argümanlar olarak ele alınır.
</para></glossdef></glossentry>
</glosslist><para>
Bir giriş kabuğu, sıfırıncı argümanının ilk karakteri <literal>-</literal> olan veya <option>--login</option> seçeneği ile çağrılan bir kabuktur.
  </para><para>
Bir etkileşimli kabuk <option>-c</option>  seçeneği belirtilmeksizin, <option>-s</option> verilmedikçe seçenek olmayan argümanlar olmaksızın başlatılan ve hem girdisi hem de çıktısı uçbirimlere bağlı olan (<command>isatty</command>(3) ile saptanır) veya <option>-i</option> seçeneği ile başlatılan bir kabuktur. Daha fazla bilgi için <xref linkend="bashref_interactive.shells"/> bölümüne bakınız.
  </para><para>
Seçeneklerin işlenmesinden sonra argümanlar kalıyorsa ve ne <option>-c</option> ne de <option>-s</option> seçenekleri verilmişse, ilk argüman kabuk komutlarını içeren bir dosya ismi olarak kabul edilir (<xref linkend="bashref_shell.scripts"/> bölümüne bakınız). Bu durumda, <literal>$0</literal> dosyanın ismi ve kalan argümanlar da konumsal parametreleridir. Bash komutları bu dosyadan okur, çalıştırır ve çıkar. Bash'in çıkış durumu betikte son çalıştırılan komutun çıkış durumudur. Hiçbir komut çalıştırılmamışsa çıkış durumu sıfırdır.
  </para>
</chapter>

<chapter id="bashref_startup.files" label="2">
  <title>Bash Başlatma Dosyaları</title>
  <titleabbrev>Bash betikleri ne zaman ve nasıl çalıştırır.</titleabbrev>
<indexterm scope="bashref_concept.index"><primary>başlatma dosyaları</primary></indexterm>
  <para>
Bu bölümde Bash'in kendi başlatma dosyalarını nasıl çalıştırdığı açıklanmıştır. Herhangi bir dosya varsa ama okunamıyorsa Bash bir hata raporlar. Yaklaşık karakterleri dosya isimlerinde <xref linkend="bashref_shell.expansions-tilde"/> bölümünde açıklandığı gibi yorumlanır.
  </para><para>
Etkileşimli kabuklar <xref linkend="bashref_interactive.shells"/> bölümünde açıklanmıştır.
  </para><variablelist>
<varlistentry><term>
Bir etkileşimli giriş kabuğu olarak veya <option>--login</option>
seçeneği ile çağrıldığında
</term><listitem><para>
Bash bir etkileşimli giriş kabuğu olarak veya <option>--login</option> seçeneği ile bir etkileşimsiz kabuk olarak çağrıldığında, <filename>/etc/profile</filename> dosyası varsa dosyayı okur ve komutlarını çalıştırır. Bu dosya okunduktan sonra sırayla <filename>~/.bash_profile</filename>, <filename>~/.bash_login</filename>, ve <filename>~/.profile</filename> dosyalarının varlığına bakar, var ve okunabilir olanlarını okur ve komutlarını çalıştırır. <option>--noprofile</option> seçeneği ile başlatarak Bash'in bu davranışı engellenebilir.
        </para><para>
Bir giriş kabuğu çıkarken, <filename>~/.bash_logout</filename> dosyasına bakar, varsa ve okunabilirse dosyayı okur ve komutlarını çalıştırır.
</para></listitem></varlistentry>
<varlistentry><term>
Etkileşimli ancak giriş kabuğu olmayan bir kabuk olarak çağrıldığında
</term><listitem><para>
Giriş kabuğu olmayan bir etkileşimli kabuk başlatıldığında Bash, varsa <filename>~/.bashrc</filename> dosyasını okur ve komutlarını çalıştırır. Bu işlem <option>--norc</option> seçeneği ile engellenebilir. <option>--rcfile </option><replaceable>dosyaismi</replaceable> seçeneği ile <filename>~/.bashrc</filename> dosyası yerine <replaceable>dosyaismi</replaceable> dosyasının okunması ve komutlarının çalıştırılması sağlanabilir.
        </para><para>
Öyleyse, her girişe özel ilklendirme sonrası (ya da öncesi) için
        </para><para>
<screen>if [ -f ~/.bashrc ]; then . ~/.bashrc; fi
</screen>
        </para><para>
satırı <filename>~/.bash_profile</filename> dosyanızda bulunmalıdır.
</para></listitem></varlistentry>
<varlistentry><term>Etkileşimsiz olarak çağrıldığında</term>
<listitem><para>
Bash, örneğin bir betiği çalıştırmak için etkileşimsiz olarak başlatıldığında, ortamdaki <literal>BASH_ENV</literal> değişkenine bakar, varsa değerini okunup çalıştırılacak bir dosya ismi olarak yorumlar. Bash burada,
        </para><para>
<screen>if [ -n "$BASH_ENV" ]; then . "$BASH_ENV"; fi
</screen>
        </para><para>
satırı çalıştırılmış gibi davranır, ancak <literal>PATH</literal> değişkeninin değeri dosyayı aramak için kullanılmaz.
        </para><para>
Yukarıda da bahsedildiği gibi, <option>--login</option> seçeneği ile başlatılan bir etkileşimsiz kabuk, komutları giriş kabuğunun başlatma dosyalarından okuyup çalıştırmaya uğraşır.
</para></listitem></varlistentry>
<varlistentry><term><literal>sh</literal> ismiyle çağrıldığında</term>
<listitem><para>
Bash, <command>sh</command> ismiyle çağrılırsa, <command>sh</command>'ın tarihsel sürümlerinin başlatma davranışlarını POSIX standardına da uydurmaya çalışarak mümkün olduğunca taklit etmeyi dener.
        </para><para>
Bir etkileşimli giriş kabuğu olarak veya <option>--login</option> seçeneği ile bir etkileşimsiz kabuk olarak çağrıldığında, komutları önce <filename>/etc/profile</filename> dosyasından okumayı ve çalıştırmayı dener ve sırasıyla <filename>~/.bash_profile</filename>, <filename>~/.bash_login</filename>, ve <filename>~/.profile</filename> dosyalarının varlığına bakar, var ve okunabilir olanlarını okur ve komutlarını çalıştırır. <option>--noprofile</option> seçeneği ile başlatarak bu davranış engellenebilir. Bir etkileşimli kabuk olarak <command>sh</command> ismiyle çağrıldığında Bash, ortamdaki <literal>ENV</literal> değişkenine bakar, varsa değerini okunup çalıştırılacak bir dosya ismi olarak yorumlar.
        </para><para>
<command>sh</command> olarak çağrılan bir kabuk başka bir başlatma dosyasını okuyup komutlarını çalıştırmayı denemez, zaten <option>--rcfile</option> seçeneğinin de bir etkisi yoktur.
        </para><para>
<command>sh</command> olarak çağrıldığında, Bash başlangıç dosyalarını okuduktan sonra POSIX kipine girer.
</para></listitem></varlistentry>
<varlistentry><term>POSIX kipinde çağrıldığında</term>
<listitem><para>
Bash <option>--posix</option> komut satırı seçeneği ile POSIX kipinde başlatıldığında, başlangıç dosyaları için POSIX standardını izler. Bu kipte etkileşimli kabuklar <literal>ENV</literal> değişkenini yorumlayarak bir dosya ismi elde eder ve komutları bu dosyadan okuyup çalıştırır. Bundan başka başlatma dosyasına bakılmaz.
</para></listitem></varlistentry>
<varlistentry><term>Uzaktan erişilebilir kabuk süreci olarak çağrıldığında</term>
<listitem><para>
Bash <command>rshd</command> gibi bir uzak kabuk süreci tarafından mı çalıştırılmak istendiğini saptamaya çalışır. Bash, <command>rshd</command> tarafından çalıştırılmak istendiğini saptadığında, komutları <filename>~/.bashrc</filename> dosyası var ve okunabilirse oradan okuyup çalıştırır. <command>sh</command> olarak çağrıldığında bunu yapmaz. <option>--norc</option> seçeneği bu davranışı engellemekte kullanılabilir ve <option>--rcfile</option> seçeneği ile başka bir dosyadan komutların okunup çalıştırılması sağlanabilir, ancak <command>rshd</command> genellikle kabuğu bu seçeneklerle çağırmaz.
</para></listitem></varlistentry>
<varlistentry><term>Farklı Etkin ve Gerçek UID/GID ile çağrıldığında</term>
<listitem><para>
Bash başlatıldığında etkin kullanıcı (grup) kimliği ile gerçek kullanıcı (grup) kimliği aynı değilse, hiçbir başlatma dosyası okunmaz, kabuk işlevleri ortamdan miras alınmaz, ortamda görünse bile <literal>SHELLOPTS</literal> değişkeni yoksayılır ve etkin kullanıcı kimliğine gerçek kullanıcı kimliği atanır. Çağrı sırasında <option>-p</option> seçeneği verilmişse etkin kullanıcı kimliğinin gerçek kullanıcı kimliğine ayarlanması dışında başlatma davranışı aynıdır.
</para></listitem></varlistentry></variablelist>
</chapter>

<chapter id="bashref_interactive.shells" label="3">
  <title>Etkileşimli Kabuklar</title>
  <titleabbrev>Bir etkileşimli kabuk nedir.</titleabbrev>
<indexterm scope="bashref_concept.index">
<primary>etkileşimli</primary><secondary>kabuk</secondary></indexterm>
<indexterm scope="bashref_concept.index">
<primary>kabuk</primary><secondary>etkileşimli</secondary></indexterm>
  <sect1 id="bashref_interactive.shells-whatis">
    <title>Etkileşimli Kabuk Nedir?</title>
    <titleabbrev>Bir kabuğun etkileşimli olup olmadığının saptanması.</titleabbrev>
    <para>
Bir etkileşimli kabuk <option>-c</option> seçeneği belirtilmeksizin, <option>-s</option> verilmedikçe seçenek olmayan argümanlar olmaksızın başlatılan ve hem girdisi hem de hata çıktısı uçbirimlere bağlı olan (<command>isatty</command>(3) ile saptanır) veya <option>-i</option> seçeneği ile başlatılan bir kabuktur.
    </para><para>
Bir etkileşimli kabuk genellikle kulanıcının uçbirimini okur ve oraya yazar.
    </para><para>
Bir etkileşimli kabuk başlatılırken, konumsal parametrelerin atanması <option>-s</option> çağrı seçeneği kullanılarak sağlanabilir.
    </para>
  </sect1>
  <sect1 id="bashref_interactive.shells-is">
    <title>Bu Kabuk Etkileşimli mi?</title>
    <titleabbrev>Bir kabuk etkileşimli olduğunu nasıl belli eder.</titleabbrev>
    <para>
Bash'in etkileşimli olup olmadığını bir başlatma betiği içinde saptamak için <literal>-</literal> özel parametresinin değerine bakılır. <literal>$-</literal> <command>i</command> harfini içeriyorsa kabuk etkileşimlidir. Örneğin:
    </para><para>
<screen>case "$-" in
*i*)    echo Bu kabuk etkileşimli ;;
*)      echo Bu kabuk etkileşimli değil ;;
esac
</screen>
    </para><para>
Ayrıca, başlatma betiklerinde <literal>PS1</literal> değişkeninin varlığına bakarak da bu saptama yapılabilir. <literal>PS1</literal> atanmamışsa kabuk etkileşimsizdir, atanmışsa etkileşimlidir. Örnek:
    </para><para>
<screen>if [ -z "$PS1" ]; then
        echo Bu kabuk etkileşimli değil
else
        echo Bu kabuk etkileşimli
fi
</screen>
    </para>
  </sect1>
  <sect1 id="bashref_interactive.shells-behavior">
    <title>Etkileşimli Kabuk Davranışı</title>
    <titleabbrev>Bir etkileşimli kabukta ne değişir?</titleabbrev>
    <para>
Bir kabuk etkileşimli çalışıyorsa davranışını bir kaç yolla değiştirir.
    </para><orderedlist>
<listitem>
Başlatma dosyaları <xref linkend="bashref_startup.files"/> bölümünde açıklandığı gibi okunur ve çalıştırılır.
</listitem><listitem>
<link linkend="bashref_job.control">İş denetimi</link> öntanımlı olarak etkinleştirilir. İş denetimi etkin olduğunda, Bash klavyeden üretilen <literal>SIGTTIN</literal>, <literal>SIGTTOU</literal> ve <literal>SIGTSTP</literal> sinyallerini yoksayar.
        </listitem><listitem>
Bash bir komutun ilk satırını okumadan önce <literal>PS1</literal> değişkenini yorumlar ve gösterir. Çok satırlı komutlarda, ikinci ve müteakip satırları okumadan önce <literal>PS2</literal> değişkenini yorumlar ve gösterir.
        </listitem><listitem>
Bash birincil komut istemi <link linkend="bashref-PS1"><literal>$PS1</literal></link>i göstermeden önce <link linkend="bashref-PROMPT_COMMAND"><literal>PROMPT_COMMAND</literal></link> değişkenini bir komut olarak  yorumlar ve çalıştırır.
        </listitem><listitem>
Kullanıcının uçbiriminde komutları okumak için <link linkend="bashref_command.line.editing">Readline</link> kullanılır.
        </listitem><listitem>
Bash bir komutu okurken standart girdisinden bir <literal>EOF</literal> aldığında, çıkmak yerine <link linkend="bashref_set.builtin"><command>set</command></link> yerleşiğinin <option>-o</option> seçeneği ile etkinleştirilen <option>ignoreeof</option> seçeneğinin değerine bakar.
        </listitem><listitem>
<link linkend="bashref_bash.history.facilities">Komut geçmişi</link> ve <link linkend="bashref_bash.hist.exp">geçmiş yorumlaması</link> öntanımlı olarak etkindir. Bir etkileşimli kabuk çıkarken, Bash komut geçmişini <literal>$HISTFILE</literal> değişkenindeki dosyaya kaydeder.
        </listitem><listitem>
<link linkend="bashref_aliases">Takma ad yorumlaması</link> öntanımlı olarak uygulanır.
        </listitem><listitem>
Bir <link linkend="bashref_shell.exec-signals">sinyal kapanının</link> yokluğunda, Bash <literal>SIGTERM</literal> sinyalini yoksayar.
        </listitem><listitem>
Bir <link linkend="bashref_shell.exec-signals">sinyal kapanının</link> yokluğunda <literal>SIGINT</literal> yakalanır ve gereği yapılır.  <literal>SIGINT</literal> bazı kabuk yerleşiklerine <link linkend="bashref_sinyal-kapani">kesme uygular</link>.
        </listitem><listitem>
<option>hupoxexit</option> kabuk seçeneği etkinse, bir etkileşimli kabuk çıkarken tüm işlere bir <literal>SIGHUP </literal> <link linkend="bashref_shell.exec-signals">sinyali gönderir</link>.
        </listitem><listitem>
<option>-n</option> çağrı seçeneği yoksayılır yani <link linkend="bashref_set.builtin"><command>set </command><option> -n</option></link> etkisizdir.
        </listitem><listitem>
Bash postayı <link linkend="bashref-MAIL"><literal>MAIL</literal>, <literal>MAILPATH</literal></link> ve <link  linkend="bashref-MAILCHECK"><literal>MAILCHECK</literal></link> değişkenlerinin değerlerine bağlı olarak belli aralıklarla kontrol eder.
        </listitem><listitem>
<link linkend="bashref_set.builtin"><command>set</command><option> -u</option></link> etkinleştirildikten sonra atanmamış kabuk değişkenlerinden dolayı oluşan yorumlama hataları kabuğun çıkmasına sebep olmaz.
        </listitem><listitem>
<link linkend="bashref_shell.expansions-param"><literal>${</literal><replaceable>parametre</replaceable><literal>:?</literal><replaceable>sözcük</replaceable><literal>}</literal></link> yorumlaması  içindeki <replaceable>parametre</replaceable>'nin atanmamış ya da boş olmasından dolayı oluşan yorumlama hatalarında kabuk çıkmayacaktır.
        </listitem><listitem>
Kabuk değişkenleri tarafından saptanan <link linkend="bashref_shell.redirections">yönlendirme</link> hataları kabuğun çıkmasına sebep olmaz.
        </listitem><listitem>
<link linkend="bashref_posix.mode">POSIX kipinde</link> çalışırken bir <link linkend="bashref_special.builtins">özel yerleşiğin</link> bir hata durumu döndürmesi kabuğun çıkmasına sebep olmayacaktır.
        </listitem><listitem>
Bir başarısız <link linkend="bashref_bourne.shell.builtins-exec"><command>exec</command></link> kabuğun çıkmasına sebep olmayacaktır.
        </listitem><listitem>
Çözümleyici sözdizimi hataları kabuğun çıkmasına sebep olmayacaktır.
        </listitem><listitem>
<command>cd</command> yerleşiğine verilen dizinler için <link linkend="bashref_shopt-cdspell">basit yazım düzeltmeleri</link> öntanımlı olarak etkindir.
        </listitem><listitem>
Kabuk <literal>$PS1</literal> komut istemini bastıktan sonra <link linkend="bashref-TMOUT"><literal>TMOUT</literal></link> değişkenin değerinde belirtilen süre kadar  komut bekler, bu süre sonunda bir komut okunmamışsa çıkar.
        </listitem>
      </orderedlist>
  </sect1>
</chapter>

<chapter id="bashref_conditionals" label="4">
  <title>Bash Koşullu İfadeleri</title>
  <titleabbrev><literal>test</literal> yerleşiğindeki ifadeleri oluşturan ilkeller.</titleabbrev>
<indexterm scope="bashref_concept.index">
<primary>ifadeler</primary><secondary>koşullu</secondary></indexterm>
  <para>
Koşulu ifadeler <link linkend="bashref_conditionals.2bracket"><command>[[</command> birleşik deyimi</link> ile <link linkend="bashref_bourne.shell.builtins-test"><command>test</command> ve <command>[</command> yerleşikleri</link> tarafından kullanılır.
  </para><para>
İfadeler tek terimli ya da iki terimli olabilir. Tek terimli ifadeler çoğunlukla bir dosyanın durumunu saptamakta kullanılır. Dizge işleçleri ve sayısal karşılaştırma işleçleri de vardır. Dosya argümanı ilklerden birine <filename>/dev/fd/</filename><replaceable>N</replaceable> biçeminde verilmişse <replaceable>N</replaceable> dosya tanıtıcısı kontrol edilir, <filename>/dev/stdin</filename>, <filename>/dev/stdout</filename> veya <filename>/dev/stderr</filename> olarak verilmişse dosya tanıtıcı olarak sırayla 0, 1, 2 kontrol edilir.
  </para><para>
Aksi belirtilmedikçe, dosyalar üzerinde işlem yapan ilkler sembolik bağları izler ve bağın kendisinde değil hedefi üzerinde işlem yapar.
  </para><glosslist>
<glossentry><glossterm><option>-a</option> <replaceable>dosya</replaceable></glossterm>
<glossdef><para>
<replaceable>dosya</replaceable> varsa doğrudur.
</para></glossdef></glossentry><glossentry>
<glossterm><option>-b </option> <replaceable>dosya</replaceable></glossterm>
<glossdef><para>
<replaceable>dosya</replaceable> varsa ve bloka özelse doğrudur.
</para></glossdef></glossentry><glossentry>
<glossterm><option>-c </option> <replaceable>dosya</replaceable></glossterm>
<glossdef><para>
<replaceable>dosya</replaceable> varsa ve karaktere özelse doğrudur.
</para></glossdef></glossentry><glossentry>
<glossterm><option>-d </option> <replaceable>dosya</replaceable></glossterm>
<glossdef><para>
<replaceable>dosya</replaceable> varsa ve bir dizinse doğrudur..
</para></glossdef></glossentry><glossentry>
<glossterm><option>-e </option> <replaceable>dosya</replaceable></glossterm>
<glossdef><para>
<replaceable>dosya</replaceable> varsa doğrudur.
</para></glossdef></glossentry><glossentry>
<glossterm><option>-f </option> <replaceable>dosya</replaceable></glossterm>
<glossdef><para>
<replaceable>dosya</replaceable> varsa ve normal bir dosyaysa doğrudur.
</para></glossdef></glossentry><glossentry>
<glossterm><option>-g </option> <replaceable>dosya</replaceable></glossterm>
<glossdef><para>
<replaceable>dosya</replaceable> varsa ve grup kimliği biti 1 ise doğrudur.
</para></glossdef></glossentry><glossentry>
<glossterm><option>-h </option> <replaceable>dosya</replaceable></glossterm>
<glossdef><para>
<replaceable>dosya</replaceable> varsa ve bir sembolik bağ ise doğrudur.
</para></glossdef></glossentry><glossentry>
<glossterm><option>-k </option> <replaceable>dosya</replaceable></glossterm>
<glossdef><para>
<replaceable>dosya</replaceable> varsa ve yapışkan biti 1 ise doğrudur.
</para></glossdef></glossentry><glossentry>
<glossterm><option>-p </option> <replaceable>dosya</replaceable></glossterm>
<glossdef><para>
<replaceable>dosya</replaceable> varsa ve bir isimli boruhattı (FIFO) ise doğrudur.
</para></glossdef></glossentry><glossentry>
<glossterm><option>-r </option> <replaceable>dosya</replaceable></glossterm>
<glossdef><para>
<replaceable>dosya</replaceable> varsa ve okunabilir ise doğrudur.
</para></glossdef></glossentry><glossentry>
<glossterm><option>-s </option> <replaceable>dosya</replaceable></glossterm>
<glossdef><para>
<replaceable>dosya</replaceable> varsa ve uzunluğu sıfırdan büyükse doğrudur.
</para></glossdef></glossentry><glossentry>
<glossterm><option>-t </option> <replaceable>fd</replaceable></glossterm>
<glossdef><para>
<replaceable>fd</replaceable> dosya tanıtıcısı açık ve bir uçbirime karşılıksa doğrudur.
</para></glossdef></glossentry><glossentry>
<glossterm><option>-u </option> <replaceable>dosya</replaceable></glossterm>
<glossdef><para>
<replaceable>dosya</replaceable> varsa ve kullanıcı kimliği biti 1 ise doğrudur.
</para></glossdef></glossentry><glossentry>
<glossterm><option>-w </option> <replaceable>dosya</replaceable></glossterm>
<glossdef><para>
<replaceable>dosya</replaceable> varsa ve yazılabilir ise doğrudur.
</para></glossdef></glossentry><glossentry>
<glossterm><option>-x </option> <replaceable>dosya</replaceable></glossterm>
<glossdef><para>
<replaceable>dosya</replaceable> varsa ve çalıştırılabilir ise doğrudur.
</para></glossdef></glossentry><glossentry>
<glossterm><option>-O </option> <replaceable>dosya</replaceable></glossterm>
<glossdef><para>
 <replaceable>dosya</replaceable> varsa ve sahibi etkin kullanıcı kimlik ise doğrudur.
</para></glossdef></glossentry><glossentry>
<glossterm><option>-G </option> <replaceable>dosya</replaceable></glossterm>
<glossdef><para>
<replaceable>dosya</replaceable> varsa ve sahibi etkin grup kimlik ise doğrudur.
</para></glossdef></glossentry><glossentry>
<glossterm><option>-L </option> <replaceable>dosya</replaceable></glossterm>
<glossdef><para>
<replaceable>dosya</replaceable> varsa ve bir sembolik bağ ise doğrudur.
</para></glossdef></glossentry><glossentry>
<glossterm><option>-S </option> <replaceable>dosya</replaceable></glossterm>
<glossdef><para>
<replaceable>dosya</replaceable> varsa ve bir soket ise doğrudur.
</para></glossdef></glossentry><glossentry>
<glossterm><option>-N </option> <replaceable>dosya</replaceable></glossterm>
<glossdef><para>
<replaceable>dosya</replaceable> varsa ve son okunduğundan beri değiştirilmişse doğrudur.
</para></glossdef></glossentry><glossentry>
<glossterm><replaceable>dosya1</replaceable> <option>-nt </option> <replaceable>dosya2</replaceable></glossterm>
<glossdef><para>
<replaceable>dosya1</replaceable>, <replaceable>dosya2</replaceable> den değişiklik tarihine göre daha yeni ise ya da <replaceable>dosya1</replaceable> mevcutken <replaceable>dosya2</replaceable> yoksa doğrudur.
</para></glossdef></glossentry><glossentry>
<glossterm><replaceable>dosya1</replaceable> <option>-ot </option> <replaceable>dosya2</replaceable></glossterm>
<glossdef><para>
<replaceable>dosya1</replaceable>, <replaceable>dosya2</replaceable> den daha eski ise ya da <replaceable>dosya2</replaceable> mevcutken <replaceable>dosya1</replaceable> yoksa doğrudur.
</para></glossdef></glossentry><glossentry>
<glossterm><replaceable>dosya1</replaceable> <option>-ef </option> <replaceable>dosya2</replaceable></glossterm>
<glossdef><para>
<replaceable>dosya1</replaceable> ile <replaceable>dosya2</replaceable> aynı aygıt ve aynı dosya düğümünü gösteriyorsa doğrudur.
</para></glossdef></glossentry><glossentry>
<glossterm><option>-o </option> <replaceable>sçn-ismi</replaceable></glossterm>
<glossdef><para>
<link linkend="bashref_set.builtin">Kabuk seçeneği</link> <replaceable>sçn-ismi</replaceable> etkinse doğrudur.
</para></glossdef></glossentry><glossentry>
<glossterm><option>-z </option> <replaceable>dizge</replaceable></glossterm>
<glossdef><para>
<replaceable>dizge</replaceable> uzunluğu sıfırsa doğrudur.
</para></glossdef></glossentry><glossentry>
<glossterm><option>-n </option> <replaceable>dizge</replaceable></glossterm>
<glossterm><replaceable>dizge</replaceable></glossterm>
<glossdef><para>
<replaceable>dizge</replaceable> sıfırdan farklıysa doğrudur.
</para></glossdef></glossentry><glossentry>
<glossterm><replaceable>dizge1</replaceable> <option>== </option> <replaceable>dizge2</replaceable></glossterm>
<glossdef><para>
<replaceable>dizge</replaceable>'ler eşitse  doğrudur.
Katı POSIX uyumluluğu için <literal>==</literal> yerine <literal>=</literal> kullanılabilir.
</para></glossdef></glossentry><glossentry>
<glossterm><replaceable>dizge1</replaceable> <option>!= </option> <replaceable>dizge2</replaceable></glossterm>
<glossdef><para>
<replaceable>dizge</replaceable>'ler aynı değilse doğrudur.
</para></glossdef></glossentry><glossentry>
<glossterm><replaceable>dizge1</replaceable> <option>&lt; </option> <replaceable>dizge2</replaceable></glossterm>
<glossdef><para>
<replaceable>dizge1</replaceable> yerele göre sıralamada
<replaceable>dizge2</replaceable> den önceyse doğrudur.
</para></glossdef></glossentry><glossentry>
<glossterm><replaceable>dizge1</replaceable> <option>> </option> <replaceable>dizge2</replaceable></glossterm>
<glossdef><para>
<replaceable>dizge1</replaceable> yerele göre sıralamada
<replaceable>dizge2</replaceable> den sonraysa doğrudur.
</para></glossdef></glossentry><glossentry>
<glossterm><replaceable>arg1</replaceable> <option>-eq </option> <replaceable>arg2</replaceable></glossterm>
<glossdef><para>
<replaceable>arg1</replaceable> ile <replaceable>arg2</replaceable>
eşitse doğrudur. Argümanlar tamsayı olmalıdır.
</para></glossdef></glossentry><glossentry>
<glossterm><replaceable>arg1</replaceable> <option>-ne </option> <replaceable>arg2</replaceable></glossterm>
<glossdef><para>
<replaceable>arg1</replaceable> ile <replaceable>arg2</replaceable>
farklıysa doğrudur. Argümanlar tamsayı olmalıdır.
</para></glossdef></glossentry><glossentry>
<glossterm><replaceable>arg1</replaceable> <option>-lt </option> <replaceable>arg2</replaceable></glossterm>
<glossdef><para>
<replaceable>arg1</replaceable>, <replaceable>arg2</replaceable> den
küçükse doğrudur. Argümanlar tamsayı olmalıdır.
</para></glossdef></glossentry><glossentry>
<glossterm><replaceable>arg1</replaceable> <option>-le </option> <replaceable>arg2</replaceable></glossterm>
<glossdef><para>
<replaceable>arg1</replaceable>, <replaceable>arg2</replaceable> den
küçük ya da ona eşitse doğrudur. Argümanlar tamsayı olmalıdır.
</para></glossdef></glossentry><glossentry>
<glossterm><replaceable>arg1</replaceable> <option>-gt </option> <replaceable>arg2</replaceable></glossterm>
<glossdef><para>
<replaceable>arg1</replaceable>, <replaceable>arg2</replaceable> den
büyükse doğrudur. Argümanlar tamsayı olmalıdır.
</para></glossdef></glossentry><glossentry>
<glossterm><replaceable>arg1</replaceable> <option>-ge </option> <replaceable>arg2</replaceable></glossterm>
<glossdef><para>
<replaceable>arg1</replaceable>, <replaceable>arg2</replaceable> den
büyük ya da ona eşitse doğrudur. Argümanlar tamsayı olmalıdır.
</para></glossdef></glossentry>
</glosslist>
</chapter>

<chapter id="bashref_shell.arithmetic" label="5">
  <title>Kabuk Aritmetiği</title>
  <titleabbrev>Kabuk değişkenlerinde aritmetik işlemler.</titleabbrev>
<indexterm scope="bashref_concept.index"><primary>aritmetik</primary><secondary>işlemler</secondary></indexterm>
<indexterm scope="bashref_concept.index"><primary>aritmetik</primary><secondary>kabuk değişkenleriyle</secondary></indexterm>
<indexterm scope="bashref_concept.index">
<primary>işlemler</primary><secondary>aritmetik</secondary></indexterm>
<indexterm scope="bashref_concept.index">
<primary>ifadeler</primary><secondary>aritmetik</secondary></indexterm>
<indexterm scope="bashref_concept.index">
<primary>kabuk</primary><secondary>aritmetik</secondary></indexterm>
  <para>
Kabuk, <link linkend="bashref_shell.expansions">kabuk yorumlarından biri olarak</link> veya <link linkend="bashref_bash.builtins-let"><command>let</command></link> yerleşiğinde ve <command>declare</command> yerleşiğinin <command>-i</command> seçeneğiyle aritmetik ifadelerin değerlendirilmesini mümkün kılar.
  </para><para>
Değerlendirme sabit genişlikli tamsayılarla, taşma denetimi uygulanmaksızın yapılır, sıfırla bölme bir hata olarak bayraklanır ve onun için bir sinyal kapanı vardır. İşleçler için öncelikler ve çağrışımsallık ve değerler C dilindeki ile aynıdır. Aşağıdaki işleçlerin listesi eşit öncelikli işleç düzeylerine göre öbeklenmiştir.
  </para><glosslist>
<glossentry><glossterm><literal>id++ id--</literal></glossterm>
<glossdef><para>
değişken son-arttırma ve son-eksiltme
</para></glossdef></glossentry><glossentry>
<glossterm><literal>++id --id</literal></glossterm>
<glossdef><para>değişken ön-arttırma ve ön-eksiltme
</para></glossdef></glossentry><glossentry>
<glossterm><literal>- +</literal></glossterm>
<glossdef><para>tek terimli eksi ve artı
</para></glossdef></glossentry><glossentry>
<glossterm><literal>! ~</literal></glossterm>
<glossdef><para>mantıksal ve bitdüzeyi zıtlık
</para></glossdef></glossentry><glossentry>
<glossterm><literal>**</literal></glossterm>
<glossdef><para>üstel
</para></glossdef></glossentry><glossentry>
<glossterm><literal>* / %</literal></glossterm>
<glossdef><para>çarpma, bölme, kalan
</para></glossdef></glossentry><glossentry>
<glossterm><literal>+ -</literal></glossterm>
<glossdef><para>toplama, çıkartma
</para></glossdef></glossentry><glossentry>
<glossterm><literal>&lt;&lt; >></literal></glossterm>
<glossdef><para>sol ve sağ bitdüzeyi kaydırmalar
</para></glossdef></glossentry><glossentry>
<glossterm><literal>&lt;= >= &lt; ></literal></glossterm>
<glossdef><para>karşılaştırma
</para></glossdef></glossentry><glossentry>
<glossterm><literal>== !=</literal></glossterm>
<glossdef><para>eşitlik ve farklılık
</para></glossdef></glossentry><glossentry>
<glossterm><literal>&amp;</literal></glossterm>
<glossdef><para>bitdüzeyi VE
</para></glossdef></glossentry><glossentry>
<glossterm><literal>^</literal></glossterm>
<glossdef><para>bitdüzeyi ayrıcalıklı VEYA (XOR)
</para></glossdef></glossentry><glossentry>
<glossterm><literal>|</literal></glossterm>
<glossdef><para>bitdüzeyi VEYA
</para></glossdef></glossentry><glossentry>
<glossterm><literal>&amp;&amp;</literal></glossterm>
<glossdef><para>mantıksal VE
</para></glossdef></glossentry><glossentry>
<glossterm><literal>||</literal></glossterm>
<glossdef><para>mantıksal VEYA
</para></glossdef></glossentry><glossentry>
<glossterm><literal>ifade ? ifade : ifade</literal></glossterm>
<glossdef><para>koşullu değerlendirme
</para></glossdef></glossentry><glossentry>
<glossterm><literal>= *= /= %= += -= &lt;&lt;= >>= &amp;= ^= |= </literal></glossterm>
<glossdef><para>atama
</para></glossdef></glossentry><glossentry>
<glossterm><literal>ifade1 , ifade2</literal></glossterm>
<glossdef><para>virgül
</para></glossdef></glossentry>
</glosslist><para>
Kabuk değişkenlerinin terimler olarak kullanılması sağlanmıştır. Parametre yorumlaması ifade değerlendirilmeden önce uygulanır. Bir ifade içinde, kabuk değişkenleri parametre yorumlamasının sözdizimini kullanmaksızın doğrudan ismiyle yer alabilir. boş değerli ya da <command>unset</command> ile kaldırılmış bir kabuk değişkenine parametre yorumlamasının sözdizimini kullanmaksızın doğrudan ismiyle başvurulduğunda değeri 0 olarak değerlendirmeye sokulur. Başvurulduğunda bir değişkenin değeri bir aritmetik ifade olarak değerlendirilir ya da tamsayı niteliği verilmiş bir değişkene <command>declare -i</command> kullanılarak  bir değer atanır. Boş değer 0 olarak değerlendirilir. Bir kabuk değişkeni
ifade içinde kullanılırken tamsayı niteliğinin etkinleştirilmesini gerektirmez.
  </para><para>
0 ile başlayan sabitler sekizlik sayılar olarak, <literal>0x</literal> veya <literal>0X</literal> ile başlayanlar onaltılık sayılar olarak ele alınır. Bunlar dışında kalan sayılar tabanları ile birlikte <literal>[</literal><replaceable>taban</replaceable><literal>#]</literal><replaceable>n</replaceable> biçeminde gösterilebilir. Burada <replaceable>taban</replaceable> 0 ile 64 arasında bir tamsayı olabilir. <replaceable>n</replaceable> ise tabandaki sayıdır. 10 tabanındaki sayılar için <replaceable>base#</replaceable> kısmı verilmeyebilir. 9 dan büyük sayılar için sırasıyla küçük harfler, büyük harfler, <literal>@</literal> ve <literal>_</literal> kullanılır. Eğer <replaceable>taban</replaceable> küçük ya da eşit 36 ise küçük ve büyük harfler 10 ile 35 arasındaki rakamlar için birbirinin yerine kullanılabilir.
  </para><para>
İşleçler öncelik sırasına göre değerlendirilir. Parantez içine alınmış alt ifadeler öncelikle değerlendirilir. Bu nedenle parantez içine alma işleçlerin önceliklerini arttırmak amacıyla kullanılabilir.
  </para>
</chapter>

<chapter id="bashref_aliases" label="6">
  <title>Takma Adlar</title>
  <titleabbrev>Komutların isimlerinin değiştirilmesi.</titleabbrev>
<indexterm scope="bashref_concept.index"><primary>takma ad</primary><secondary>yorumlama</secondary></indexterm>
<indexterm scope="bashref_concept.index"><primary>yorumlama</primary><secondary>takma ad</secondary></indexterm>
  <para>
<emphasis>Takma adlar</emphasis> bir basit komutun ilk sözcüğü olarak kullanıldığında, bir sözcüğün yerini bir dizgenin almasını mümkün kılar. Kabuk, <link linkend="bashref_bash.builtins-alias"><command>alias</command></link> ve <link linkend="bashref_bash.builtins-unalias"><command>unalias</command></link> yerleşikleri ile atanan ve kaldırılan takma adları bir listede tutar.
  </para><para>
Her basit komutun ilk sözcüğü, tırnak içine alınmamışsa, bir takma ada sahip mi diye bakılır. Sahipse, bu sözcük takma adın değeri ile değiştirilir. <command>/</command>, <command>$</command>, <command></command>, <command>=</command>, kabuk meta karakterleri veya tırnak karakterleri, önceleme karakteri bir takma adın isim parçasında bulunamaz. Değer parçasında ise kabuk meta karakterleri dahil kabuk girdisi olarak geçerli tüm karakterler bulunabilir. Değerin ilk sözcüğü takma adlar için denenir, ama yorumlanacak bir takma isimle aynı olan bir sözcük ikinci kez yorumlanmaz. Bunu bir örnekle açıklayacak olursak,
  </para><para>
<literallayout indent="0">
    <command>ls</command>='<command>ls</command> -F'
</literallayout>
  </para><para>
<command>ls</command> hem bir takma ad ismi hem de takma adın değerindeki ilk sözcüktür. Değerin ilk sözcüğü ikinci kez bir takma ad ismi olarak tekrar yorumlanmaz, yani takma adlar iç içe olamazlar. Takma ad değerinin son karakteri bir boşluk ya da sekme karakteri ise, sonraki komut sözcüğünü izleyen takma ad ayrıca takma ad yorumlaması için kontrol edilir.
  </para><para>
Takma adlar <command>alias</command> komutu ile oluşturulur ve listelenir; <command>unalias</command> komutu ile kaldırılır.
  </para><para>
<command>csh</command>'daki gibi takma ad değerinde argümanları kullanmak için bir mekanizma yoktur. Argümanlar gerekliyse bir <link linkend="bashref_shell.functions">kabuk işlevi</link> kullanılmalıdır.
  </para><para>
Kabuk etkileşimsizken <link linkend="bashref_shopt-expand_aliases"><option>expand_aliases</option></link> kabuk seçeneği etkin olmadıkça takma adlar yorumlanmaz.
  </para><para>
Takma adların tanımlanması ve kullanımı ile ilgili kurallar bir parça kafa karıştırıcıdır. Bash komut satırındaki bir komutu çalıştırmadan önce daima en azından bir tam satır okur. Takma adlar bir komut çalıştırıldığı zaman değil, okunduğu zaman yorumlanır. Öte yandan, diğer komut olarak aynı satırda görünen bir takma ad tanımı girdinin sonraki satırı okunana kadar etkisizdir. Bu satırdaki komutlardan sonraki takma ad tanımları yeni takma addan etkilenmez. Bu davranış ayrıca işlevler çalıştırılırken de görülür. Takma adlar bir işlev çalıştırıldığı zaman değil, okunduğu zaman yorumlanır, çünkü bir işlev tanımının kendisi bir birleşik komuttur. Bir sonuç olarak, bir işlev içinde tanımlanmış olan takma adlar işlevin çalıştırılmasının sonrasına kadar kullanışsızdır. Emin olmak için, daima takma ad tanımlarını ayrı bir satıra koyun ve <command>alias</command>'ı birleşik komut içinde kullanmayın.
  </para><para>
Hemen her maksat için, kabuk işlevleri takma adlara tercih edilir.
  </para>
</chapter>

<chapter id="bashref_arrays" label="7">
  <title>Diziler</title>
  <titleabbrev>Dizi Değişkenleri.</titleabbrev>
  <indexterm scope="bashref_concept.index"><primary>diziler</primary></indexterm>
  <para>
Bash tek boyutlu dizi değişkenleri sağlar. Her değişken dizi olarak kullanılabilir; <link linkend="bashref_bash.builtins-declare"><command>declare</command></link> yerleşiği bir diziyi doğrudan bildirecektir. Bir dizi için ne bir azami boyut vardır ne de üyelerinin indislenmesi ya da peşpeşe atanması gereklidir. Dizilerin ilk indisi sıfırdır.
  </para><para>
Bir değişken aşağıdaki sözdizimi kullanılarak atanırsa, bir dizi otomatikman oluşturulmuş olur:
  </para><para>
<literallayout indent="0">
    <emphasis>isim</emphasis>[<emphasis>indis</emphasis>]=<emphasis>değer</emphasis>
</literallayout>
  </para><para>
<replaceable>indis</replaceable> değerlendirildiğinde sıfıra eşit ya da büyük bir sayı olması gereken bir aritmetik ifade olarak ele alınır. Bir dizi doğrudan aşağıdaki gibi bildirilebilir:
  </para><para>
<literallayout indent="0">
    <command>declare</command> -a <emphasis>isim</emphasis>
</literallayout>
      </para><para>Ayrıca bu söz dizimi de kabul edilir:</para><para>
<literallayout indent="0">
    <command>declare</command> -a <emphasis>isim</emphasis>[<emphasis>indis</emphasis>]
</literallayout>
  </para><para>
<replaceable>indis</replaceable> yoksayılır. Bir dizi değişkeni için öznitelikler <command>declare</command> ve <link linkend="bashref_bourne.shell.builtins-readonly"><command>readonly</command></link> yerleşikleri ile belirtilebilir. Her öznitelik dizinin tüm üyelerine uygulanır.
  </para><para>
Diziler aşağıdaki gibi birleşik atamalar kullanılarak atanabilir.
  </para><para>
<literallayout indent="0">
    <emphasis>isim</emphasis>=(<emphasis>değer1 ... değerN</emphasis>)
</literallayout>
  </para><para>
Burada her <replaceable>değer</replaceable>, <literal>[[</literal><replaceable>indis</replaceable><literal>]=]</literal><replaceable>dizge</replaceable> biçemindedir. İsteğe bağlı olan <replaceable>indis</replaceable> verilirse, indis atanmış olur; aksi takdirde atanan elemanın indisi deyim tarafından atanan son indis artı birdir. İndisleme sıfırdan başlar. Bu sözdizimi ayrıca <command>declare</command> yerleşiği tarafından da kabul edilir. Tek tek dizi elemanları <replaceable>isim</replaceable><literal>[</literal><replaceable>indis</replaceable><literal>]=</literal><emphasis>değer</emphasis> sözdizimi kullanılarak atanabilir.
  </para><para>
Dizideki her eleman <literal>${</literal><replaceable>isim</replaceable><literal>[</literal><replaceable>indis</replaceable><literal>]}</literal> biçeminde bir ifade içinde kullanılabilir. Kaşlı ayraçlar, kabuğun dosyaismi yorumlama işleci ile çelişmemesi için gereklidir. <replaceable>indis</replaceable> olarak <literal>@</literal> veya <literal>*</literal> verilirse, dizinin tüm üyeleri anlamındadır. Bu indisler sadece çift tırnak içine alındığında farklıdır. Sözcük çift tırnaklar arasındaysa, <literal>${</literal><replaceable>isim</replaceable><literal>[*]}</literal> sözcüğü, her dizi üyesi <literal>IFS</literal> değişkeninin ilk karakteri ile ayrılarak tek sözcük olarak yorumlanır. <literal>${</literal><replaceable>isim</replaceable><literal>[@]}</literal> sözcüğünde ise dizinin her elemanı ayrı bir sözcük olarak yorumlanır. Dizinin hiç elemanı yoksa, <literal>${</literal><replaceable>isim</replaceable><literal>[@]}</literal> hiçbir şey olarak yorumlanır. Bir sözcük içinde çift tırnaklı yorumlama olursa ilk parametrenin yorumu özgün sözcüğün başlangıç parçası ile birleşir ve son parametrenin yorumu da özgün sözcüğün son parçası ile birleşir. Bu, <literal>@</literal> ve <literal>*</literal> özel parametrelerinin yorumlanmasına benzerdir. <literal>${#</literal><replaceable>isim</replaceable><literal>[</literal><replaceable>indis</replaceable><literal>]}</literal>, <literal>${</literal><replaceable>isim</replaceable><literal>[</literal><replaceable>indis</replaceable><literal>]}</literal> dizisinin uzunluğu olarak yorumlanır. <replaceable>indis</replaceable>, <literal>@</literal> veya <literal>*</literal> ise yorumlama dizideki elemanların sayısıdır. Bir dizi değişkeni bir ifade içinde kullanılırken bir indis belirtilmezse sıfırıncı elemana karşılıktır.
  </para><para>
Dizileri kaldırmak için <link linkend="bashref_bourne.shell.builtins-unset"><command>unset</command></link>  yerleşiği kullanılır. <command>unset </command><replaceable>isim</replaceable><literal>[</literal><replaceable>indis</replaceable><literal>]</literal> komutu <replaceable>indis</replaceable> indisli elemanı diziden kaldırır. Dosyaismi üretiminin sebep olacağı istenmeyen yan etkilerden kaçınılmaya çalışılmalıdır. <command>unset </command><replaceable>isim</replaceable> komutunda <replaceable>isim</replaceable> bir dizi ismi ise dizinin tamamı kaldırılır. Ayrıca <replaceable>indis</replaceable> olarak <literal>*</literal> veya <literal>@</literal> verildiğinde de dizinin tamamı kaldırılır.
  </para><para>
<link linkend="bashref_bash.builtins-declare"><command>declare</command></link>,
<link linkend="bashref_bash.builtins-local"><command>local</command></link> ve
<link linkend="bashref_bourne.shell.builtins-readonly"><command>readonly</command></link> yerleşiklerinin herbirinde bir dizi belirtmek için <option>-a</option> seçeneği bulunur. <command>read</command> yerleşiğinin <option>-a</option> seçeneği ile standart girdiden okunan sözcüklerin bir listesi bir diziye atanabilir ve değerler standart girdiden okunup tek tek dizi elemanlarına atanabilir. <link linkend="bashref_set.builtin"><command>set</command></link> ve <link linkend="bashref_bash.builtins-declare"><command>declare</command></link> yerleşikleri girdi olarak yeniden kullanılabilir şekilde dizi değerlerini gösterebilir.
  </para>
</chapter>

  <chapter id="bashref_directory-builtins" label="8">
    <title>Dizin Yığını Yerleşikleri</title>
    <titleabbrev>Dizin yığınını yönetmek için Bash yerleşik komutları.</titleabbrev>
<indexterm scope="bashref_concept.index">
<primary>yerleşik komutlar</primary><secondary>dizin yığını</secondary></indexterm>
<indexterm scope="bashref_concept.index"><primary>dizin yığını</primary></indexterm>
    <para/><para>
Dizin yığını son ziyaret edilen dizinlerin bir listesidir. Dizinleri yığına eklemek için <command>pushd</command> yerleşiği kullanılır ve eklenen dizine geçilmesini sağlar. Dizinleri yığından kaldırmak için <command>popd</command> yerleşiği kullanılır ve yığının tepesindeki dizine geçilmesini sağlar. Dizin yığınındaki dizinleri göstermek için de <command>dirs</command> yerleşiği kullanılır.
    </para><para>
Dizin yığınının içeriğine ayrıca bir dizi değişkeni olan <literal>DIRSTACK</literal> kabuk değişkeninden de erişilebilir.
    </para>
    <sect1 id="bashref_directory-builtins-dirs">
      <title>Dirs Yerleşiği</title>
      <indexterm scope="bashref_commands.index"><primary>dirs</primary></indexterm>
      <para>
<synopsis><command>dirs</command> [<command>+</command><emphasis>N</emphasis> | <command>-</command><emphasis>N</emphasis>] [<command>-clpv</command>]
</synopsis>
      </para><para>
O an hatırlanan dizinlerin listesini gösterir. Dizinler <command>pushd</command> komutu ile listeye eklenir ve <command>popd</command> komutu ile listeden kaldırılır.
      </para><glosslist>
<glossentry><glossterm><option>+</option><replaceable>N</replaceable></glossterm>
<glossdef><para>
Seçeneksiz çağrılan <command>dirs</command> tarafından basılan listenin solundaki kayıt 0 kabul edilerek <replaceable>N.</replaceable> dizini gösterir.
</para></glossdef></glossentry><glossentry>
<glossterm><option>-</option><replaceable>N</replaceable></glossterm>
<glossdef><para>
Seçeneksiz çağrılan <command>dirs</command> tarafından basılan listenin sağındaki kayıt 0 kabul edilerek <replaceable>N.</replaceable> dizini gösterir
</para></glossdef></glossentry><glossentry>
<glossterm><option>-c </option></glossterm>
<glossdef><para>
Tüm elemanlarını silerek dizin yığınını temizler.
</para></glossdef></glossentry><glossentry>
<glossterm><option>-l </option></glossterm>
<glossdef><para>
Daha uzun liste üretir; öntanımlı liste biçeminde ev dizini bir yaklaşık karakteri ile gösterilir.
</para></glossdef></glossentry><glossentry>
<glossterm><option>-p </option></glossterm>
<glossdef><para>
Dizin yığınını her satırda tek girdiyle gösterir.
</para></glossdef></glossentry><glossentry>
<glossterm><option>-v </option></glossterm>
<glossdef><para>
<literal>-p</literal> gibidir, farklı olarak her satırın başına girdinin yığındaki indisi konur.
</para></glossdef></glossentry>
</glosslist>
    </sect1>
    <sect1 id="bashref_directory-builtins-popd">
      <title>Popd Yerleşiği</title>
      <indexterm scope="bashref_commands.index"><primary>popd</primary></indexterm>
      <para>
<synopsis><command>popd</command> [<command>+</command><emphasis>N</emphasis> | <command>-</command><emphasis>N</emphasis>] [<command>-n</command>]
</synopsis>
      </para><para>
Argümansız verildiğinde dizin yığınının tepesindeki girdiyi kaldırdıktan sonra yığının tepesindeki dizine <command>cd</command> uygular. <command>dirs</command> ile listelenen ilk dizin 0 olmak üzere tüm elemanlar 0 dan başlayarak numaralanır. Bu durumda, <command>popd</command> komutu <command>popd</command> <literal>+0</literal> komutuna eşdeğerdir.
      </para><glosslist>
<glossentry><glossterm><option>+</option><replaceable>N</replaceable></glossterm>
<glossdef><para>
Seçeneksiz çağrılan <command>dirs</command> tarafından basılan listenin solundaki kayıt 0 kabul edilerek <replaceable>N.</replaceable> dizini siler.
</para></glossdef></glossentry><glossentry>
<glossterm><option>-</option><replaceable>N</replaceable></glossterm>
<glossdef><para>
Seçeneksiz çağrılan <command>dirs</command> tarafından basılan listenin sağındaki kayıt 0 kabul edilerek <replaceable>N.</replaceable> dizini siler.
</para></glossdef></glossentry><glossentry>
<glossterm><option>-n</option></glossterm>
<glossdef><para>
Dizinler yığından kaldırılırken, dizin değiştirilmesini engeller. Böylece sadece yığın değişmiş olur.
</para></glossdef></glossentry></glosslist>
    </sect1>
    <sect1 id="bashref_directory-builtins-pushd">
      <title>Pushd Yerleşiği</title>
      <indexterm scope="bashref_commands.index"><primary>pushd</primary></indexterm>
      <para>
<synopsis><command>pushd</command> [<emphasis>dizin</emphasis> | <command>+</command><emphasis>N</emphasis> | <command>-</command><emphasis>N</emphasis>] [<command>-n</command>]
</synopsis>
      </para><para>
İçinde bulunulan dizini dizin yığınının tepesine kaydettikten sonra belirtilen <replaceable>dizin</replaceable>'e geçilir. Argümansız kullanıldığında yığının tepesindeki iki dizin yer değiştirir.
      </para><glosslist>
<glossentry><glossterm><option>+</option><replaceable>N</replaceable></glossterm>
<glossdef><para>
Seçeneksiz çağrılan <command>dirs</command> tarafından basılan listenin solundaki kayıt 0 kabul edilerek <replaceable>N.</replaceable> dizini, listeyi döndürerek yığının tepesine getirir.
</para></glossdef></glossentry><glossentry>
<glossterm><option>-</option><replaceable>N</replaceable></glossterm>
<glossdef><para>
Seçeneksiz çağrılan <command>dirs</command> tarafından basılan listenin sağındaki kayıt 0 kabul edilerek <replaceable>N.</replaceable> dizini, listeyi döndürerek yığının tepesine getirir.
</para></glossdef> </glossentry><glossentry>
<glossterm><option>-n</option></glossterm>
<glossdef><para>
Dizinler yığına eklerken, dizin değiştirilmesini engeller. Böylece sadece yığın değişmiş olur.
</para></glossdef> </glossentry><glossentry>
<glossterm><replaceable>dizin</replaceable></glossterm>
<glossdef><para>
İçinde bulunulan dizini yığının tepesi yapar ve <command>cd</command> <replaceable>dizin</replaceable> komutuna eşdeğer bir işlemle <replaceable>dizin</replaceable>'e geçilmesini sağlar.
</para></glossdef></glossentry></glosslist>
    </sect1>
  </chapter>

  <chapter id="bashref_prompts" label="9">
    <title>Komut İsteminin Kontrol Edilmesi</title>
    <titleabbrev>PS1 dizgesinin kontrolü.</titleabbrev>
<indexterm scope="bashref_concept.index"><primary>komut istemi</primary></indexterm>
    <para>
<literal>PROMPT_COMMAND</literal> değişkeninin değeri Bash birincil komut istemini basmadan hemen önce saptanır. <literal>PROMPT_COMMAND</literal> atanmış ve boş olmayan bir değere sahipse, bu değeri, komut satırında yazıldığı gibi çalıştırılır.
    </para><para>
Komut istemi değişkenlerinde görünen özel karakterler:
    </para><glosslist>
<glossentry>
<glossterm><literal>\a</literal></glossterm>
<glossdef><para>Sesli uyarı (bell) karakteri.
</para></glossdef></glossentry><glossentry>
<glossterm><literal>\d</literal></glossterm>
<glossdef><para>
Tarih, İng. olarak "Günismi Ayismi AyınGünü" biçemindedir
(örn, "Thu Apr 24").
</para></glossdef></glossentry><glossentry>
<glossterm><literal>\D{</literal><varname>biçim</varname><literal>} </literal></glossterm>
<glossdef><para>
<varname>biçim</varname> <command>strftime</command>(3)'a aktarılır ve sonuç istem dizgesine yerleştirilir; <varname>biçim</varname> boş ise sonuç yerele özel zaman gösteriminde olacaktır. <varname>biçim</varname> boş bile olsa kaşlı ayraçlar gereklidir.
</para></glossdef></glossentry><glossentry>
<glossterm><literal>\e</literal></glossterm>
<glossdef><para>Önceleme (esc) karakteri.
</para></glossdef></glossentry><glossentry>
<glossterm><literal>\h</literal></glossterm>
<glossdef><para>
İlk <literal>.</literal> ya kadar, konak ismi.
</para></glossdef></glossentry><glossentry>
<glossterm><literal>\H</literal></glossterm>
<glossdef><para>Tam konak ismi.
</para></glossdef></glossentry><glossentry>
<glossterm><literal>\j</literal></glossterm>
<glossdef><para>
Kabuk tarafından o an yönetilmekte olan işlerin sayısı.
</para></glossdef></glossentry><glossentry>
<glossterm><literal>\l</literal></glossterm>
<glossdef><para>
Kabuğun uçbirim aygıtının dosya ismi (örn,
<literal>/dev/tty2</literal> için <literal>tty2</literal>).
</para></glossdef></glossentry><glossentry>
<glossterm><literal>\n</literal></glossterm>
<glossdef><para>Satırsonu (LF) karakteri.
</para></glossdef></glossentry><glossentry>
<glossterm><literal>\r</literal></glossterm>
<glossdef><para>Satırbaşı (CR) karakteri.
</para></glossdef></glossentry><glossentry>
<glossterm><literal>\s</literal></glossterm>
<glossdef><para>
Kabuğun ismi ya da başka bir deyişle <literal>$0</literal>'ın değeri
(son <literal>/ </literal>den sonraki kısım).
</para></glossdef></glossentry><glossentry>
<glossterm><literal>\t</literal></glossterm>
<glossdef><para>
24 saatlik gösterimle SS:MM:ss biçeminde saat.
</para></glossdef></glossentry><glossentry>
<glossterm><literal>\T</literal></glossterm>
<glossdef><para>
12 saatlik gösterimle SS:MM:ss biçeminde saat.
</para></glossdef></glossentry><glossentry>
<glossterm><literal>\@</literal></glossterm>
<glossdef><para>
12 saatlik gösterimle öö/ös biçeminde saat.
</para></glossdef></glossentry><glossentry>
<glossterm><literal>\A</literal></glossterm>
<glossdef><para>
24 saatlik gösterimle SS:MM biçeminde saat.
</para></glossdef></glossentry><glossentry>
<glossterm><literal>\u</literal></glossterm>
<glossdef><para>
O anki kullanıcının kullanıcı ismi.
</para></glossdef></glossentry><glossentry>
<glossterm><literal>\v</literal></glossterm>
<glossdef><para>
Bash'in sürümü (örn, 2.00)
</para></glossdef></glossentry><glossentry>
<glossterm><literal>\V</literal></glossterm>
<glossdef><para>
Bash'in "dağıtım.sürüm.yamaseviyesi" olarak sürümü (örn, 2.05.9)
</para></glossdef></glossentry><glossentry>
<glossterm><literal>\w</literal></glossterm>
<glossdef><para>
O anki dizin; <literal>$HOME</literal> kısaltılmış olarak ~ ile gösterilir.
</para></glossdef></glossentry><glossentry>
<glossterm><literal>\W</literal></glossterm>
<glossdef><para>
<literal>$PWD</literal> değişkenindeki dizinin son / dan sonraki kısmı; <literal>$HOME</literal> kısaltılmış olarak ~ ile gösterilir.
</para></glossdef></glossentry><glossentry>
<glossterm><literal>\!</literal></glossterm>
<glossdef><para>
Bu komutun geçmiş numarası.
</para></glossdef></glossentry><glossentry>
<glossterm><literal>\#</literal></glossterm>
<glossdef><para>
Bu komutun komut numarası.
</para></glossdef></glossentry><glossentry>
<glossterm><literal>\$</literal></glossterm>
<glossdef><para>
Etkin kullanıcı kimliği 0 ise <literal>#</literal>, değilse <literal>$</literal>.
</para></glossdef></glossentry><glossentry>
<glossterm><literal>\<emphasis>nnn</emphasis></literal></glossterm>
<glossdef><para>
Sekizlik ASCII değeri <replaceable>nnn</replaceable> olan karakter.
</para></glossdef></glossentry><glossentry>
<glossterm><literal>\\</literal></glossterm>
<glossdef><para>Tersbölü.
</para></glossdef></glossentry><glossentry>
<glossterm><literal>\[</literal></glossterm>
<glossdef><para>
Basılamayan karakterler dizisi başlatır. Bu, komut istemine bir uçbirim denetim dizgesi girmek için yararlıdır.
</para></glossdef></glossentry><glossentry>
<glossterm><literal>\]</literal></glossterm>
<glossdef><para>
Basılamayan karakterler dizisini sonlandırır. (Örneğin <literal>PS1=$'\[\\033[1;31m\]\\w$ '</literal> kırmızı renkte bir komut satırı ayarlar)
</para></glossdef></glossentry>
</glosslist><para>
Komut numarası ile geçmiş numarası farklı kavramlardır: Bir komutun geçmiş numarası onun geçmiş listesindeki konumudur (<xref linkend="bashref_bash.history.facilities"/> bölümüne bakınız). Komut numarası ise o anki kabuk oturumunun başlangıcından itibaren çalıştırılan komut sayısıdır.
    </para><para>
Dizgenin kodu çözüldükten sonra <link linkend="bashref_shopt-promptvars"><option>promptvars</option></link> kabuk seçeneğinin değerine konu,
<link linkend="bashref_shell.expansions-param">parametre yorumlaması</link>,
<link linkend="bashref_shell.expansions-cmd.subs">komut ikamesi</link>,
<link linkend="bashref_shell.expansions-arith">aritmetik yorumlama</link> ve
<link linkend="bashref_shell.expansions-unquoting">tırnak kaldırma</link> uygulanır.
    </para>
  </chapter>

  <chapter id="bashref_restricted.shell" label="10">
    <title>Sınırlı Kabuk</title>
    <titleabbrev>Kabuk çalıştırmanın daha kontrollü bir kipi.</titleabbrev>
<indexterm scope="bashref_concept.index"><primary>sınırlı kabuk</primary></indexterm>
    <para>
Bash <command>rbash</command> ile başlatılırsa ya da çağrı sırasında <option>--restricted</option> veya <option>-r</option> seçeneği verilirse, kabuk sınırlı duruma gelir. Bir sınırlı kabuk, standart kabuktan daha kontrollü bir ortam sağlamak için kullanılır. Bir sınırlı kabuk aşağıdaki <emphasis role="bold">yasaklar</emphasis> (belirtilse de uygulanmazlar) dışında <command>bash</command>'e özdeş davranır:
    </para><itemizedlist>
        <listitem>
<command>cd</command> yerleşiği ile dizin değiştirmek.
        </listitem><listitem>
<literal>SHELL</literal>, <literal>PATH</literal>, <literal>ENV</literal> veya <literal>BASH_ENV</literal> değişkenlerini kaldırmak ya da değer atamak.
        </listitem><listitem>
<literal>/ </literal> içeren komut isimleri yazmak.
        </listitem><listitem>
<command>.</command> yerleşiğine bir argüman olarak <literal>/ </literal> içeren bir dosya ismi belirtmek.
        </listitem><listitem>
<command>hash</command> yerleşiğine <option>-p</option> seçeneğinin argümanı olarak <literal>/ </literal> içeren bir dosya ismi belirtmek.
        </listitem><listitem>
Başlangıçta kabuk ortamından işlev tanımlarını alıntılamak.
        </listitem><listitem>
Başlangıçta kabuk ortamındaki <literal>SHELLOPTS</literal> değişkeninin değerini çözümlemek.
        </listitem><listitem>
Çıktıyı <literal>></literal>, <literal>>|</literal>, <literal>&lt;></literal>,
<literal>>&amp;</literal>, <literal>&amp;></literal> ve <literal>>></literal> yönlendirme işleçleri ile yönlendirmek.
        </listitem><listitem>
<command>exec</command> yerleşiğini kullanarak kabuğu başka bir komutla değiştirmek.
        </listitem><listitem>
<command>enable</command> yerleşiğinin <option>-f</option> ve <option>-d</option> seçenekleri ile yerleşik komutları eklemek ya da silmek.
        </listitem><listitem>
Etkisiz olan kabuk yerleşiklerini <command>enable</command> yerleşiği ile etkinleştirmek.
        </listitem><listitem>
<command>command</command> yerleşiğini <option>-p</option> seçeneği ile çalıştırmak.
        </listitem><listitem>
<command>set</command> <option>+r</option> veya <command>set</command> <option>+o restricted</option> komutları ile sınırlı kipi kapatmak.
        </listitem>
      </itemizedlist><para>
Bu sınırlamalar başlangıç dosyalarından herhangi biri okunur okunmaz etkin olur.
    </para><para>
Bir komut <link linkend="bashref_shell.scripts">kabuk betiği</link> olarak varsa çalıştırılır, <command>rbash</command> bir kabuk betiğini çalıştırmak üzere kabuğu çatalladığında sınırlamaları kapatır.
    </para>
  </chapter>

  <chapter id="bashref_posix.mode" label="11">
    <title>Bash POSIX Kipi</title>
    <titleabbrev>
Bash'i POSIX standardının belirtimine daha yakın davranmasının sağlanması.
    </titleabbrev>
<indexterm scope="bashref_concept.index"><primary>POSIX Kipi</primary></indexterm>
    <para>
Bash'i <option>--posix</option> komut satırı seçeneği ile başlatarak ya da Bash çalışırken <command>set</command> <option>-o posix</option> komutunu çalıştırarak, Bash'in POSIX standardındakinden farklı olan öntanımlı davranışlarını değiştirerek standarda daha yakın davranması sağlanır.
    </para><para>
<command>sh</command> olarak çağrıldığında, Bash başlangıç dosyalarını okuduktan sonra POSIX kipine girer
    </para><para>
Aşağıdaki liste `POSIX kipi' etkinleştirildiğinde değişenleri gösterir:
    </para><orderedlist>
        <listitem>
Bir komut komut tablosunda artık yoksa, Bash komutun yeni yerini bulmak için <literal>$PATH</literal> dizinlerini tekrar arar. Bu ayrıca <command>shopt</command><option> -s checkhash</option> ile etkinleştirilebilir.
        </listitem><listitem>
Bir iş sıfırdan farklı bir durumla çıktığında iş denetim kodu ve yerleşikleri `Bitti(durum)' benzeri bir ileti basar.
        </listitem><listitem>
Bir iş durduğunda iş denetim kodu ve yerleşikleri `Durdu(sinyalismi)' benzeri bir ileti basar. Burada geçen <replaceable>sinyalismi</replaceable> örneğin <literal>SIGTSTP</literal> olabilir.
        </listitem><listitem>
<command>bg</command> yerleşiği artalana yerleştirilmeyi açıklamayı gerektiren ama işin o anki mi önceki mi olduğunun belirtilmesini içermeyen bir biçim kullanır.
        </listitem><listitem>
Anahtar sözcüklere takma ad verilemez.
        </listitem><listitem>
POSIX <literal>PS1</literal> ve <literal>PS2</literal> geçmiş numarasına <literal>!</literal> yorumlaması ve <literal>!!</literal> için de <literal>!</literal> etkinleştirilir ve <option>promptvars</option> kabuk seçeneğinin durumuna aldırmayıp <literal>PS1</literal> ve <literal>PS2</literal> değişkenlerinin değerlerine parametre yorumlaması uygulanır.
        </listitem><listitem>
Etkileşimli açıklamalar öntanımlı olarak etkinleştirilir (Bash zaten onları öntanımlı olarak etkin yapar).
        </listitem><listitem>
Normal Bash dosyaları yerine POSIX başlatma dosyaları çalıştırılır (<literal>$ENV</literal>).
        </listitem><listitem>
Yaklaşık yorumlaması satırdaki tüm atama deyimleri yerine bir komut ismini önceleyen atamalar üzerinde uygulanır.
        </listitem><listitem>
Öntanımlı geçmiş dosyası <filename>~/.sh_history</filename>'dir (bu, <literal>$HISTFILE</literal> değişkeninin öntanımlı değeridir).
        </listitem><listitem>
<command>kill</command><option> -l</option> çıktısı tüm sinyal isimlerini boşluklarla ayırarak ve <literal>SIG</literal> önekini kullanılmaksızın tek satıra basar.
        </listitem><listitem>
<command>kill</command> yerleşiği <literal>SIG</literal> önekli sinyal isimlerini kabul etmez.
        </listitem><listitem>
<literal>. </literal><replaceable>dosyaismi</replaceable> komutundaki <replaceable>dosyaismi</replaceable> bulunamazsa, etkileşimsiz kabuklar çıkar.
        </listitem><listitem>
Bir aritmetik yorumlamasının içindeki bir sözdizimi hatası, bir geçersiz ifadenin içinde sonuçlanıyorsa etkileşimsiz kabuklar çıkar.
        </listitem><listitem>
Yönlendirme işleçleri, kabuk etkileşimli olmadıkça yönlendirmedeki sözcük üstünde dosyaismi yorumlaması uygulamaz.
        </listitem><listitem>
Yönlendirme işleçleri, yönlendirmedeki sözcük üstünde sözcük ayrımlaması uygulamaz.
        </listitem><listitem>
İşlev isimleri geçerli kabuk isimleri olmalıdır. Böylece bu isimler, bir rakam ile başlayamaz ve harfler, rakamlar ile altçizgi karakteri dışında karakterleri içeremez. Bir işlev isminin bir geçersiz isimle bildirilmesi etkileşimsiz kabuklarda bir ölümcül sözdizimi hatası oluşturur.
        </listitem><listitem>
<link linkend="bashref_special.builtins">POSIX'e özel yerleşiklere</link> komut araması sırasında kabuk işlevlerinden önce bakılır.
        </listitem><listitem>
Bir POSIX özel yerleşiği bir hata durumu ile dönerse bir etkileşimsiz kabuk çıkar. Ölümcül hataların da listelendiği POSIX standardı yanlış seçeneklerin aktarılması gibi şeyler, yönlendirme hataları, komut ismini önceleyen atamalar için değişken atama hataları ve benzerlerini içerir.
        </listitem><listitem>
<literal>CDPATH</literal> atanmışsa, <command>cd</command> yerleşiği bulunulan dizini ona doğrudan eklemeyecektir. Bunun anlamı: <command>cd</command> yerleşiğine bir argüman olarak verilen isimle aynı isimdeki bir dizin bulunulan dizinde mevcut olsa bile, <literal>$CDPATH</literal> içindeki girdilerden birinden oluşturulabilen geçerli dizin ismi yoksa <command>cd</command> yerleşiği başarısız olacaktır.
        </listitem><listitem>
Atama deyimlerinden sonra gelen komut ismi olmadığında, bir değişken atama hatası oluşursa, bir etkileşimsiz kabuk bir hata durumu ile çıkar. Örneğin, bir salt-okunur değişkene bir değer atanmaya çalışılırsa, bir değişken atama hatası oluşur.
        </listitem><listitem>
Bir <command>for</command> deyiminin yineleme değişkeni veya bir <command>select</command> deyiminin seçim değişkeni bir salt-okunur değişkense bir etkileşimsiz kabuk bir hata durumu ile çıkar.
        </listitem><listitem>
Süreç ikamesi yoktur.
        </listitem><listitem>
POSIX özel yerleşiklerinden önce verilen atama deyimleri komut işini tamamladıktan sonra da kabukta etkin olarak kalır.
        </listitem><listitem>
Kabuk işlevi çağrılarından önce verilen atama deyimleri işlev döndükten sonra da bir önceki maddede olduğu gibi kabukta etkin olarak kalır.
        </listitem><listitem>
<command>export</command> ve <command>readonly</command> yerleşik komutları çıktılarını POSIX'in gerektirdiği biçemde gösterir.
        </listitem><listitem>
<command>trap</command> yerleşiği sinyal isimlerini <literal>SIG</literal> ile öncelemeden gösterir.
        </listitem><listitem>
<command>trap</command> yerleşiği ilk argümanına olası bir sinyal belirtimi var mı acaba diye bakmaz ve eğer varsa argüman yalnızca rakamlardan oluşmadıkça ve geçerli bir sinyal numarası olmadıkça sinyal işlemeyi özgün mecrasına geri döndürür. Eğer kullanıcı sinyal işlemeyi özgün mecrasına geri döndürmek isterse ilk argüman olarak <command>-</command> kullanmalıdır.
        </listitem><listitem>
<command>.</command> ve <command>source</command> yerleşikleri bir dosyaismi argümanınını, <literal>PATH</literal> aramasında bulamazlarsa, bulunulan dizinde aramazlar.
        </listitem><listitem>
Komut ikamelerini çalıştırmak için çatallanan altkabuklar <option>-e</option> seçeneğinin değerini kendilerini çalıştıran kabuktan miras alırlar. POSIX kipinde değilken, Bash <option>-e</option> seçeneğinin değerini bu altkabuklarda temizler.
        </listitem><listitem>
Etkileşimsiz kabuklarda bile takma ad yorumlaması daima etkindir.
        </listitem><listitem>
<command>alias</command> yerleşiği takma ad tanımlarını listelemek amacıyla kullanıldığında <option>-p</option> seçeneği belirtilmedikçe tanımların başlarında '<command>alias </command> gösterilmez.
        </listitem><listitem>
<command>set</command> yerleşiği seçeneksiz olarak çağrıldığında, kabuk işlevlerinin isimlerini ve tanımlarını göstermez.
        </listitem><listitem>
<command>set</command> yerleşiği seçeneksiz olarak çağrıldığında, sonuçlar basılamayan karakterleri içerse bile, kabuk metakarakterlerini içermedikçe, değişken değerlerini tırnaksız olarak gösterir.
        </listitem><listitem>
<command>cd</command> yerleşiği mantıksal kipte çağrıldığında ve dosya yolu <literal>$PWD</literal>'den oluştuğunda ve de bir argüman olarak verilen dizin ismi içinde bulununlan dizini göstermediğinde <command>cd</command> fiziksel kipe dönmek yerine başarısız olacaktır.
        </listitem><listitem>
<command>pwd</command> yerleşiği <option>-P</option> seçeneği ile çağrıldığında <literal>$PWD</literal>'nin içeriğini sembolik bağ içermeyen dizinlerle yazar.
        </listitem><listitem>
<command>pwd</command> yerleşiği <option>-P</option> seçeneği belirtmek suretiyle dosya sistemini sınaması istenmese bile bastığı değerin, içinde bulunulan dizin ile aynı olup olmadığına bakacaktır.
        </listitem><listitem>
Geçmiş listelenirken <command>fc</command> yerleşiği geçmiş girdisinin değiştirilmiş olup olmadığına dair bir belirti içermez.
        </listitem><listitem>
<command>fc</command>  tarafından öntanımlı metin düzenleyici olarak <command>ed</command> kullanılır.
        </listitem><listitem>
<command>type</command> ve <command>command</command> yerleşikleri çalıştırılabilir olmayan bir dosyayı kabuk çalıştırmaya çalışacak olsa hatta <literal>$PATH</literal> içinde bu isimde sadece bu dosya varsa bile böyle birşey bulduk diye raporlamazlar.
       </listitem><listitem>
<command>v</command> komutu (<emphasis>Ç.N.:v değil vi olacaktı sanırım</emphasis>) çalıştırılmak istendiğinde <emphasis role="bold">vi</emphasis> kipindeyken <literal>$FCEDIT</literal> ve <literal>$EDITOR</literal> değişkenlerinin içeriklerine bakılmaksızın doğrudan <command>vi</command> metin düzenleyici çalıştırılır.
        </listitem><listitem>
<option>xpg_echo</option> seçeneği etkinken Bash argümanları <command>echo</command> seçenekeri olarak yorumlamaya çalışmaz. Her argüman gösterildikten sonra öncelenmiş karakterler dönüştürülür.
        </listitem>
      </orderedlist><para>
POSIX kipindeyken öntanımlı olan ancak Bash'in gerçeklemediği bazı POSIX davranışları vardır. Özellikle:
    </para><orderedlist><listitem>
<command>fc</command> yerleşiği, geçmiş girdileri düzenleneceği zaman <command>FCEDIT</command> ortamda tanımlı değilken öntanımlı metin düzenleyici olarak <command>ed</command>'i kullanacağına  gidip <literal>$EDITOR</literal> değişkeninin içeriğine bakar; <literal>$EDITOR</literal> tanımlı değilse <command>ed</command>'i kullanır.
        </listitem><listitem>
Yukarıda dikkat çekildiği gibi, Bash, <command>echo</command> yerleşiğinin tam uyumlu olabilmesi için <option>xpg_echo</option> seçeneğinin etkin olmasını gerektirir.
        </listitem><listitem>
Bash kurulum sırasında <command>configure</command> betiğine <option>--enable-strict-posix-default</option> seçeneği verilmek suretiyle öntanımlı olarak POSIX uyumlu olmak üzere yapılandırılabilir (bkz, <xref linkend="bashref_installing-options"/>).
        </listitem>
      </orderedlist>
  </chapter>
</part>
