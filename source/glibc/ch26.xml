<?xml version="1.0" encoding="UTF-8"?>
<!-- ********************************************************************
     $Id: ch26.xml,v 1.2 2002/12/20 22:29:48 nilgun Exp $
******************************************************************** -->
<part xml:id="glibc-Processes">
  <title>Süreçler</title>
  <titleabbrev>Süreçler nasıl oluşturulur ve diğer yazılımlar nasıl çalıştırılır.</titleabbrev>
  <partintro><para><indexterm scope="glibc-cp"><primary>süreçler</primary></indexterm>
  <wordasword>Süreçler</wordasword> sistem kaynaklarının ayrılmasını sağlayan temel birimlerdir. Her süreç kendi adres alanına ve (genellikle) bir kontrol evresine sahiptir. Bir süreç bir yazılımı çalıştırır; aynı yazılımı çalıştıran farklı süreçleriniz olabilir, fakat her süreç kendi adres alanında yazılımın kendi kopyasına sahiptir ve bunu diğer kopyalardan bağımsız olarak çalıştırır.
  </para><para>
<indexterm scope="glibc-cp"><primary>süreçler</primary><secondary>alt süreç</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>süreçler</primary><secondary>üst süreç</secondary></indexterm>
Süreçler hiyerarşik olarak düzenlenmiştir. Her süreç, kendisini yaratan bir <wordasword>üst süreç</wordasword>e sahiptir. Üst bir süreç tarafından yaratılan süreçler <wordasword>alt süreçler</wordasword> olarak anılırlar. Bir alt süreç bir çok özelliğini üst sürecinden alır.
  </para><para>
Bu kısım bir yazılımın alt süreçleri nasıl yaratabileceğini, sonlandırabileceğini ve kontrol edebileceğini anlatır. Aslında, üç farklı işlem içerilmiştir: yeni bir alt sürecin oluşturulması, yeni sürecin bir yazılımı çalıştırmasına neden olmak ve alt sürecin tamamlanmasını ana yazılımla eşgüdümlemek.
  </para><para>
<command>system</command> işlevi başka bir yazılımın çalıştırılması için basit, taşınabilir bir mekanizma sunmaktadır; üç adımı da özdevinimli olarak yapar. Bunun yapılışı ile ilgili ayrıntılar üzerinde daha fazla denetim sahibi olmak istiyorsanız, temel işlevleri kullanarak her adımı tek tek gerçekleştirebilirsiniz.
  </para></partintro>
  <chapter xml:id="glibc-Running-a-Command">
    <title>Bir Komutun Çalıştırması</title>
    <titleabbrev>Başka bir yazılımı çalıştırmanın kolay yolu.</titleabbrev>
    <para>
<indexterm scope="glibc-cp"><primary>süreçler</primary><secondary>bir komutun çalıştırılması</secondary></indexterm>
Başka bir yazılımı çalıştırmanın kolay yolu <command>system</command> işlevinin kullanılmasıdır.  Bu işlev bir alt yazılımı çalıştırmak için gerekli bütün işi yapar, fakat ayrıntılar üzerindeki denetimi size fazla vermez: başka bir şey yapmadan önce alt yazılım sonlanıncaya kadar beklemeniz gerekir.
   </para><para xml:id="glibc-system">
<indexterm scope="glibc-fn"><primary>system</primary></indexterm>
<indexterm scope="glibc-pg"><primary>sh</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>system</command></funcdef>
<paramdef>(const char *<varname>komut</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev  <varname>komut</varname> komutunu bir kabuk komutu olarak çalıştırır. GNU C kütüphanesinde, bir komutu çalıştırmak için her zaman öntanımlı kabuk olan <command>sh</command> kullanılır. Özellikle <command>PATH</command> içinde belirtilen dizinleri arayarak çalıştırılacak yazılımı bulmaya çalışır. Kabuk sürecini oluşturamadıysa dönüş değeri <command>-1</command>, aksi takdirde kabuk sürecinin durumudur. Bu durum kodunun nasıl yorumlanacağı konusunda ayrıntılı bilgi için bkz. <xref linkend="glibc-Process-Completion"/>.
   </para><para>
Eğer <varname>komut</varname> argümanı boş gösterici olarak verilirse, dönüş değerinin sıfır olması bir komut işlemcisi olmadığını belirtir.
   </para><para>
Bu işlev çok evreli yazılımlar için iptal noktasıdır. Eğer <command>system</command> çağrıldığında bir evre bazı kaynakları (bellek, dosya tanımlayıcısı, semafor veya her hangi başka bir kaynak) ayırırsa bu sorun olur. Evre iptal edilirse bu kaynaklar yazılım sonlanıncaya kadar ayrılmış durumda kalırlar. Bundan kaçınmak için <command>system</command>e yapılan çağrılar iptal işleyicilerini kullanarak korunmalıdır.
   </para><para>
<indexterm scope="glibc-pg"><primary>stdlib.h</primary></indexterm>
<command>system</command> işlevi <filename>stdlib.h</filename> başlık dosyası içinde tanımlıdır.
      </para></funcdescr></funcsynopsis></para><para>
<note><title>Uyumluluk Bilgisi</title><para>
Bazı C gerçeklemeleri başka yazılımları çalıştıran bir komut işlemcisine sahip olmayabilir.
Komut işlemcisinin olup olmadığını <command>system (NULL)</command> çalıştırarak anlayabilirsiniz; eğer dönüş değeri sıfır değilse, bir komut işlemcisi vardır.
</para></note>
   </para><para>
<command>popen</command> ve <command>pclose</command> işlevleri (<xref linkend="glibc-Pipe-to-a-Subprocess"/>) <command>system</command> işleviyle yakından ilgilidir. Bunlar üst sürecin, çalıştırılan komutun standart girdi ve çıktı kanallarıyla haberleşmesini sağlarlar.
   </para></chapter>
  <chapter xml:id="glibc-Process-Creation-Concepts">
    <title>Süreç Oluşturma Kavramları</title>
    <titleabbrev>Zor yoldan yapılışına genel bakış.</titleabbrev>
    <para>
Bu bölüm süreçlere genel bakış, adım adım süreç oluşturma ve süreçlerin başka bir yazılımı çalıştırmasını içermektedir.
   </para><para>
<indexterm scope="glibc-cp"><primary>süreçler</primary><secondary>süreç kimliği (PID)</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>süreçler</primary><secondary>süreç ömrü</secondary></indexterm>
Her süreç bir <wordasword>süreç kimliği</wordasword> numarasıyla adlandırılır. Süreçler oluşturulurken her birine tek bir süreç kimliği ayrılır.
Bir sürecin <wordasword>ömrü</wordasword> üst sürecine sonlandırıldığı bildirildiğinde biter;
o zaman, süreç kimliği dahil bütün süreç kaynakları serbest bırakılır.
   </para><para>
<indexterm scope="glibc-cp"><primary>süreçler</primary><secondary>oluşturulması</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>süreçler</primary><secondary>çatallama</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>süreçler</primary><secondary>alt süreç</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>süreçler</primary><secondary>üst süreç</secondary></indexterm>
Süreçler <command>fork</command> sistem çağrısı ile oluşturulurlar (bu nedenle yeni süreç oluşturma bazen süreci <wordasword>çatallamak</wordasword> olarak anılır.)
<command>fork</command> ile yaratılan bir<wordasword>alt süreç</wordasword> orjinal <wordasword>üst süreç</wordasword>in bir kopyasıdır, sadece kendisine ait süreç kimliği farklıdır.
   </para><para>
Bir alt süreci çatalladıktan sonra, üst ve alt süreçler normal çalışmalarına devam ederler. Eğer yazılımınızın devam etmeden önce alt süreçleri çalışmalarını bitirinceye kadar beklemesini istiyorsanız, bunu çatallanma işleminden hemen sonra <command>wait</command> veya <command>waitpid</command> işlevlerini çağırarak açıkça yapmanız gerekir(<xref linkend="glibc-Process-Completion"/>). Bu işlevler alt sürecin neden sonlandırıldığı hakkında sınırlı bilgi verirler--örneğin, çıkış durum kodu gibi.
   </para><para>
Yeni çatallanan bir alt süreç aynı yazılımı, <command>fork</command> çağrısının döndüğü noktada, üst süreci olarak çalıştırmaya devam eder. <command>fork</command> işlevinin dönüş değerini yazılımın üst süreçte mi yoksa alt süreçte mi çalıştığını söylemek için kullanabilirsiniz.
   </para><para>
<indexterm scope="glibc-cp"><primary>süreçler</primary><secondary>süreç görüntüsü</secondary></indexterm>
Aynı yazılımı çalıştıran çeşitli süreçlerin olması ara sıra kullanışlıdır. Fakat alt süreç  <command>exec</command> işlevlerinden birini kullanarak bir başka yazılımı da çalıştırabilir; bkz. <xref linkend="glibc-Executing-a-File"/>. Sürecin çalıştırdığı yazılıma
<wordasword>süreç görüntüsü</wordasword> denir. Yeni yazılımın çalıştırılmasının başlatılması, sürecin, önceki süreç görüntüsü hakkındaki herşeyi unutmasına sebep olur; yeni yazılım sonlandığında, önceki süreç görüntüsüne dönülmez, süreç de sonlanır.
   </para></chapter>
  <chapter xml:id="glibc-Process-Identification">
    <title>Süreç Kimliği</title>
    <titleabbrev>Bir sürecin süreç kimliği nasıl elde edilir.</titleabbrev>
    <para>
<command>pid_t</command> veri türü süreç kimlikleri için kullanılır. Bir sürecin süreç kimliğini <command>getpid</command> işlevini çağırarak alabilirsiniz.  <command>getppid</command> işlevi geçerli sürecin üst sürecinin süreç kimliğini döndürür (aynı zamanda <wordasword>üst süreç kimliği</wordasword> olarak da bilinir). Bu işlevleri kullanmak için yazılımınız <filename>unistd.h</filename> ve <filename>sys/types.h</filename> başlık dosyalarını içermelidir.
<indexterm scope="glibc-pg"><primary>sys/types.h</primary></indexterm>
<indexterm scope="glibc-pg"><primary>unistd.h</primary></indexterm>
   </para><para>
<indexterm scope="glibc-tp"><primary>pid_t</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü" xml:id="glibc-pid_t">
<funcdef><command>pid_t</command></funcdef>
<paramdef/>
</funcprototype><funcdescr><para>
<command>pid_t</command> veri türü süreç kimliğini gösterebilen bir işaretli tamsayıdır. GNU kütüphanesinde, bu bir <command>int</command>'tir.
   </para></funcdescr></funcsynopsis>
   </para><para>
<indexterm scope="glibc-fn"><primary>getpid</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-getpid">
<funcdef>pid_t <command>getpid</command></funcdef>
<paramdef>(void)</paramdef>
</funcprototype><funcdescr><para>
<command>getpid</command> işlevi geçerli sürecin süreç kimliğini döndürür.
   </para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>getppid</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-getppid">
<funcdef>pid_t <command>getppid</command></funcdef>
<paramdef>(void)</paramdef>
</funcprototype><funcdescr><para>
<command>getppid</command> işlevi geçerli sürecin üst süreç kimliğini döndürür.
    </para></funcdescr></funcsynopsis></para>
  </chapter>
  <chapter xml:id="glibc-Creating-a-Process">
    <title>Bir Sürecin Oluşturulması</title>
    <titleabbrev>Bir alt süreç nasıl çatallanır.</titleabbrev>
    <para>
<command>fork</command> işlevi süreç oluşturmanın temelidir ve <filename>unistd.h</filename> başlık dosyası içinde bildirilmiştir.
<indexterm scope="glibc-pg"><primary>unistd.h</primary></indexterm>
   </para><para>
<indexterm scope="glibc-fn"><primary>fork</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-fork">
<funcdef>pid_t <command>fork</command></funcdef>
<paramdef>(void)</paramdef>
</funcprototype><funcdescr><para>
<command>fork</command> işlevi yeni bir süreç oluşturur.
   </para><para>
Süreç oluşturma başarılıysa, hem üst hem de alt süreçler çalışır ve her ikisi de <command>fork</command> işlevinin dönüş değerini görür, ancak bu değerler farklıdır: <command>fork</command> işlevi, alt süreçte <command>0</command> değerini ve üst süreçte alt sürecinin süreç kimliğini döndürür.
   </para><para>
Süreç oluşturma başarısızsa, <command>fork</command> işlevi üst süreçte <command>-1</command> değerini döndürür. Aşağıdaki <command>errno</command> hata durumları <command>fork</command> işlevi için tanımlanmıştır:
   </para><para><variablelist><varlistentry>
   <term><literal>EAGAIN</literal></term><listitem><para>
Başka süreç oluşturmak için yeterli sistem kaynağı yok ya da kullanıcının zaten çok fazla süreci çalışmakta. Bu <command>RLIMIT_NPROC</command> kaynak sınırının aşılmakta olduğu anlamına gelir, bu genellikle artırılabilir; bkz. <xref linkend="glibc-Limits-on-Resources"/>.
   </para></listitem></varlistentry><varlistentry>
   <term><literal>ENOMEM</literal></term><listitem><para>
Süreç sistemin sağlayabileceğinden fazla yere ihtiyaç duymaktadır.
    </para></listitem></varlistentry></variablelist>
    </para></funcdescr></funcsynopsis></para><para>
Alt süreci üstünden farklılaştıran özellikleri:
   </para><para><itemizedlist><listitem>
Alt sürecin kendi süreç kimliği vardır.
   </listitem><listitem>
Alt sürecin üst süreç kimliği üst sürecinin süreç kimliğidir.
   </listitem><listitem>
Alt süreç, üst sürecin açık dosya tanımlayıcılarının kendine ait kopyalarını alır. Böylece üst süreçteki dosya tanımlayıcısının özelliklerinin değiştirilmesi alttaki dosya tanımlayıcıları etkilemez, bu tersi için de geçerlidir.  Bkz. <xref linkend="glibc-Control-Operations"/>. Ancak, her tanımlayıcıyla ilişkilendirilmiş olan dosya konumu her iki süreç tarafından paylaşılır; bkz. <xref linkend="glibc-File-Position"/>.
     </listitem><listitem>
Alt süreçler için biten işlemci süreleri sıfırlanır; bkz. <xref linkend="glibc-Processor-Time"/>.
     </listitem><listitem>
Alt süreç üstü tarafından kurulmuş dosya kilitlerini miras almaz.<xref linkend="glibc-Control-Operations"/>.
    </listitem><listitem>
Alt süreç üstü tarafından kurulmuş uyarıları miras almaz.<xref linkend="glibc-Setting-an-Alarm"/>.
    </listitem><listitem>
Alt süreç için bekleyen sinyal kümesi  (<xref linkend="glibc-Delivery-of-Signal"/>) temizlenir. (Alt süreç baskılanmış sinyallerin maskesini ve sinyal hareketlerini üst sürecinden miras alır.)
     </listitem></itemizedlist>
     </para><para>
<indexterm scope="glibc-fn"><primary>vfork</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-vfork">
<funcdef>pid_t <command>vfork</command></funcdef>
<paramdef>(void)</paramdef>
</funcprototype><funcdescr><para>
<command>vfork</command> işlevi <command>fork</command> gibidir fakat bazı sistemlerde daha verimlidir; fakat, güvenli kullanımı için bazı kısıtlar vardır.
   </para><para>
<command>fork</command>çağıran sürecin adres alanının tam bir kopyasını alıp hem alt hem de üst sürecin bağımsız olarak çalışmasını sağlarken, <command>vfork</command> bu kopyayı yapmaz. Bunun yerine <command>vfork</command> ile oluşturulan alt süreç <command>_exit</command> veya <command>exec</command> işlevleri çağrılana kadar üst sürecin adres alanını paylaşır. Bu arada, üst süreç çalışmayı askıya alır.
   </para><para>
<command>vfork</command> ile oluşturulan alt sürecin evrensel (global) verileri, hatta üstüyle paylaştığı yerel değişkenleri bile değiştirmesine izin vermemek konusunda dikkatli olmalısınız. Bundan başka, alt süreç <command>vfork</command>'u çağıran işlevden dönemez! Bu üst sürecin kontrol bilgisini karıştırabilir. Kuşkunuz varsa, <command>fork</command> kullanın.
   </para><para>
Bazı işletim sistemleri gerçek anlamda <command>vfork</command>'u uygulamazlar.  GNU C kütüphanesi <command>vfork</command>'u bütün sistemlerde kullanmanıza izin verir, ancak aslında <command>vfork</command> yoksa <command>fork</command> çalıştırır. Eğer  <command>vfork</command> kullanımında önlemlerinizi alırsanız, yazılımınız, sistem onun yerine <command>fork</command>'u kullansa da çalışır.
      </para></funcdescr></funcsynopsis></para></chapter>
  <chapter xml:id="glibc-Executing-a-File">
    <title>Bir Dosyanın Çalıştırılması</title>
    <titleabbrev>Bir süreç başka bir yazılımı nasıl çalıştırır.</titleabbrev>
    <para>
<indexterm scope="glibc-cp"><primary>süreçler</primary><secondary>bir dosyanın çalıştırılması</secondary></indexterm>
<indexterm scope="glibc-cp"><primary><command>exec</command> işlevleri</primary></indexterm>
Bu bölüm bir dosyayı bir süreç görüntüsü olarak çalıştırmak için kullanılan <command>exec</command> ailesi işlevlerini anlatmaktadır. Bu işlevler bir alt sürecin çatallandıktan sonra yeni bir yazılımı çalıştırmasını sağlamak için kullanılabilir.
   </para><para>
<command>exec</command> işlevinin etkilerini çağrılan yazılımın bakış açısıyla görmek için, bkz. <xref linkend="glibc-Program-Basics"/>.
   </para><para>
<indexterm scope="glibc-pg"><primary>unistd.h</primary></indexterm>
Bu ailedeki işlevler argümanlarının belirtiliş şekillerine göre farklılıklar gösterir,
aksi takdirde hepsi aynı işi yapar. Bunlar <filename>unistd.h</filename> başlık dosyası içinde bildirimlidir.
   </para><para>
<indexterm scope="glibc-fn"><primary>execv</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-execv">
<funcdef>int <command>execv</command></funcdef>
<paramdef>(const char *<varname>dosyaismi</varname>,
 char *const <varname>argv</varname>[])</paramdef>
</funcprototype><funcdescr><para>
<command>execv</command>işlevi <varname>dosyaismi</varname> adındaki dosyayı yeni bir süreç görüntüsü olarak çalıştırır.
   </para><para>
<varname>argv</varname> argümanı boş karakter sonlandırmalı dizgelerden oluşan bir dizidir ve bu çalıştırılan yazılımın <command>main</command> işlevinin <command>argv</command> argümanına değer sağlamak için kullanılır.
Bu dizinin son elemanı bir boş gösterici olmalıdır. Kural olarak, bu dizinin ilk elemanı yazılımın dosya ismidir (dizinsiz hali). Yazılımların bu argümanlara nasıl eriştiğini bütün ayrıntılarıyla incelemek için, bkz. <xref linkend="glibc-Program-Arguments"/>,
   </para><para>
Yeni süreç görüntüsünün ortamı geçerli süreç görüntüsünün <command>environ</command> değişkeninden alınır; ortam değişkenleri hakkında bilgi için <xref linkend="glibc-Environment-Variables"/> bölümüne bakınız.
   </para></funcdescr></funcsynopsis></para><para xml:id="glibc-execl">
<indexterm scope="glibc-fn"><primary>execl</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>execl</command></funcdef>
<paramdef>(const char *<varname>dosyaismi</varname>,
 const char *<varname>arg0</varname>,
 …)</paramdef>
</funcprototype><funcdescr><para>
Bu da <command>execv</command> gibidir, fakat <varname>argv</varname> dizgeleri bir dizi yerine tek tek belirtilir. Son argüman bir boş gösterici olmalıdır.
   </para></funcdescr></funcsynopsis></para><para xml:id="glibc-execve">
<indexterm scope="glibc-fn"><primary>execve</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>execve</command></funcdef>
<paramdef>(const char *<varname>dosyaismi</varname>,
 char *const <varname>argv</varname>[],
 char *const <varname>ortam</varname>[])</paramdef>
</funcprototype><funcdescr><para>
Bu da <command>execv</command> gibidir, fakat yeni yazılım için ortamı açıkça belirtmenize <varname>ortam</varname> argümanıyla izin verir. Bu <command>environ</command> değişkeniyle aynı biçimde, dizgelerden oluşan bir dizi olmalıdır; bkz. <xref linkend="glibc-Environment-Access"/>.
   </para></funcdescr></funcsynopsis></para><para xml:id="glibc-execle">
<indexterm scope="glibc-fn"><primary>execle</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>execle</command></funcdef>
<paramdef>(const char *<varname>dosyaismi</varname>,
 const char *<varname>arg0</varname>,
 char *const <varname>ortam</varname>[],
 …)</paramdef>
</funcprototype><funcdescr><para>
Bu da <command>execl</command> gibidir, fakat yeni yazılım için ortamı açıkça belirtmenize izin verir. <varname>ortam</varname> argümanı son <varname>argv</varname> argümanını olan boş göstericiden sonra gelmeli ve <command>environ</command> değişkeniyle aynı biçimde, dizgelerden oluşan bir dizi olmalıdır.
   </para></funcdescr></funcsynopsis></para><para xml:id="glibc-execvp">
<indexterm scope="glibc-fn"><primary>execvp</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>execvp</command></funcdef>
<paramdef>(const char *<varname>dosyaismi</varname>,
 char *const <varname>argv</varname>[])</paramdef>
</funcprototype><funcdescr><para>
<command>execvp</command> işlevi <command>execv</command> gibidir, ancak eğer <varname>dosyaismi</varname> bir <command>/</command> içermiyorsa <varname>dosyaismi</varname> isimli dosyanın tam ismini bulmak için <command>PATH</command> ortam değişkeninde  (<xref linkend="glibc-Standard-Environment"/>) listelenen dizinleri de arar.
   </para><para>
Bu işlev sisteme yardımcı yazılımların çalıştırılmasında kullanışlı olabilir, çünkü bu yazılımları bulmak için kullanıcının seçtiği yerlere bakar. Kabuklar bunu kullanıcının yazdığı komutları çalıştırmak için kullanırlar.
   </para></funcdescr></funcsynopsis></para><para xml:id="glibc-execlp">
<indexterm scope="glibc-fn"><primary>execlp</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>execlp</command></funcdef>
<paramdef>(const char *<varname>dosyaismi</varname>,
 const char *<varname>arg0</varname>,
 …)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev <command>execl</command> gibidir, ancak <command>execvp</command> işlevi gibi dosya ismi arama işlemi uygular.
      </para></funcdescr></funcsynopsis></para><para>
Argüman listesinin ve ortam değişkenleri listesinin toplam boyutu <command>ARG_MAX</command> bayttan büyük olmamalıdır. Bkz. <xref linkend="glibc-General-Limits"/>. GNU sisteminde, her dizge için bu boyut (<command>ARG_MAX</command> ile karşılaştırıldığında), "dizge içerisindeki karakter sayısı, artı <command>char *</command> türünün boyutu, artı bir" değerinin <command>char *</command> boyutunun katlarına yuvarlanması ile elde edilir. Diğer sistemler biraz farklı sayım kuralları uygulayabilir.
   </para><para>
Bu işlevler normalde değer döndürmezler, çünkü yeni bir yazılımın çalıştırılması halen çalışan yazılımın tamamen terk edilmesine neden olur. Hata durumunda <command>-1</command> döndürülür. Olağan <link linkend="glibc-File-Name-Errors">dosya ismi hatalarına</link> ek olarak, aşağıdaki <command>errno</command> hata durumları bu işlevler için tanımlanmıştır:
   </para><para><variablelist><varlistentry>
   <term><literal>E2BIG</literal></term><listitem><para>
Yeni yazılımın argüman listesinin uzunluğuyla ortam değişkenleri listesinin birleştirilmiş büyüklüğü <command>ARG_MAX</command> bayttan büyüktür. GNU sisteminde argüman listesi büyüklüğü için belirtilmiş bir sınır yoktur, böylece bu hata kodu oluşamaz, ancak eğer argümanlar kullanılabilir bellek için çok büyük ise bunun yerine <command>ENOMEM</command> alabilirsiniz.
      </para></listitem></varlistentry><varlistentry>
      <term><command>ENOEXEC</command></term><listitem><para>
Belirtilen dosya doğru biçimde olmadığı için çalıştırılamamaktadır.
      </para></listitem></varlistentry><varlistentry>
      <term><command>ENOMEM</command></term><listitem><para>
Belirtilen dosyanın çalıştırılması mevcut olandan daha fazla depolama alanı gerektirmektedir.
      </para></listitem></varlistentry></variablelist></para><para>
Yeni dosyanın çalıştırılması başarılı olursa, okumada olduğu gibi dosyanın erişim zamanı alanını günceller. Dosyaların erişim zamanları hakkında daha fazla bilgi için <xref linkend="glibc-File-Times"/> bölümüne bakınız.
   </para><para>
Dosyanın tekrar kapandığı nokta belirtilmemiştir, ancak süreçten çıkmadan önceki bir nokta veya başka bir süreç görüntüsü çalıştırılmadan önceki nokta belirtilmiş olabilir.
   </para><para>
Yeni bir süreç görüntüsünün çalıştırılması, sadece argüman ve ortam dizgelerini yeni yerlerine kopyalayarak bellek içeriğini tamamen değiştirir. Fakat sürecin diğer bir çok özelliği değişmez:
   </para><para><itemizedlist><listitem>
Süreç kimliği ve üst süreç kimliği. Bkz. <xref linkend="glibc-Process-Creation-Concepts"/>.
     </listitem><listitem>
Oturum ve süreç grubu üyeliği. Bkz. <xref linkend="glibc-Concepts-of-Job-Control"/>.
     </listitem><listitem>
Gerçek kullanıcı kimliği ve grup kimliği ile ek grup kimlikleri.  Bkz. <xref linkend="glibc-Process-Persona"/>.
     </listitem><listitem>
Bekleyen uyarılar. Bkz. <xref linkend="glibc-Setting-an-Alarm"/>.
     </listitem><listitem>
Geçerli çalışma dizini ve kök dizini. Bkz. <xref linkend="glibc-Working-Directory"/>. GNU sisteminde, kök dizini bir setuid yazılımı çalıştırılırken kopyalanmaz; bunun yerine yeni yazılım için sistemin öntanımlı kök dizini kullanılır.
     </listitem><listitem>
Dosya kipi oluşturma maskesi. Bkz. <xref linkend="glibc-Setting-Permissions"/>.
     </listitem><listitem>
Süreç sinyal maskesi; bkz.<xref linkend="glibc-Process-Signal-Mask"/>.
     </listitem><listitem>
Bekleyen sinyaller; bkz. <xref linkend="glibc-Blocking-Signals"/>.
     </listitem><listitem>
Sürece ilişkin biten işlemci süresi; bkz. <xref linkend="glibc-Processor-Time"/>.
     </listitem></itemizedlist>
   </para><para>
Eğer süreç görüntü dosyasının set-user-ID ve set-group-ID kip bitleri işaretlenmişse, bu sürecin etkin kullanıcı kimliği ve grup kimliği (sırasıyla) değerlerini etkiler. Bu kavramlara ayrıntılı bir şekilde <xref linkend="glibc-Process-Persona"/> içinde değinilmiştir.
   </para><para>
Geçerli süreçte görmezden gelinecek sinyaller yeni süreçte de dikkate alınmayacak şekilde ayarlanmalıdır. Diğer bütün sinyaller yeni süreç görüntüsünde öntanımlı hareketlerine ayarlanırlar. Sinyaller hakkında daha fazla bilgi için, bkz.  <xref linkend="glibc-Signal-Handling"/>.
   </para><para>
Varolan süreç görüntüsünde açık kalan dosya tanımlayıcıları yeni süreç görüntüsünde de <command>FD_CLOEXEC</command> (close-on-exec) bayrak kümesine sahip değillerse açık kalırlar. Açık kalan dosyalar varolan süreç görüntüsünden açık dosya tanımlayıcısının dosya kilitleri dahil bütün özelliklerini miras alırlar. dosya tanımlayıcıları <xref linkend="glibc-Low-Level-I-O"/> içinde incelenmiştir.
   </para><para>
Akımlar, buna karşın, <command>exec</command> işlevleriyle varlıklarını sürdüremezler, çünkü bunlar sürecin kendi bellek alanına yerleşmektedirler. Yeni süreç görüntüsünün kendisinin yeniden oluşturdukları dışında akımları yoktur. <command>exec</command> öncesi süreç görüntüsünün içindeki akımların her birinin içinde bir tanımlayıcı vardır ve bunlar <command>exec</command> ile varlıklarını sürdürürler (<command>FD_CLOEXEC</command> kümesinin olmaması halinde). Yeni süreç görüntüsü bu yeni akımlara <command>fdopen</command> kullanarak tekrar bağlanabilir (bkz. <xref linkend="glibc-Descriptors-and-Streams"/>).
   </para></chapter>
  <chapter xml:id="glibc-Process-Completion">
    <title>Süreç Tamamlama</title>
    <titleabbrev>Bir alt sürecin tamamlandığını nasıl söyleriz.</titleabbrev>
    <para>
<indexterm scope="glibc-cp"><primary>süreçler</primary><secondary>süreç tamamlama</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>süreçler</primary><secondary>bir alt sürecin tamamlanmasının beklenmesi</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>süreçler</primary><secondary>bir alt sürecin çıkış durumunun sınanması</secondary></indexterm>
Bu bölümde anlatılan işlevler bir alt sürecin sonlanmasını veya durmasını beklemek ve durumunu algılamak için kullanılırlar.
Bu işlevler <filename>sys/wait.h</filename> başlık dosyası içinde bildirimlidir.
<indexterm scope="glibc-pg"><primary>sys/wait.h</primary></indexterm>
   </para><para xml:id="glibc-waitpid">
<indexterm scope="glibc-fn"><primary>waitpid</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>pid_t <command>waitpid</command></funcdef>
<paramdef>(pid_t <varname>pid</varname>,
 int  *<varname>durum-gstr</varname>,
 int   <varname>seçenekler</varname>)
</paramdef>
</funcprototype><funcdescr><para>
   <variablelist><varlistentry><listitem><para>
<command>waitpid</command> işlevi, süreç kimliği <varname>pid</varname> olan alt sürecin durum bilgisini istemek için kullanılır. Normalde, çağıran süreç, alt süreç sonlanarak durum bilgisini verene kadar askıda kalır.
   </para><para>
<varname>pid</varname> argümanı için verilecek diğer değerler farklı yorumlanır. <command>-1</command> veya <command>WAIT_ANY</command> değeri her hangi bir alt süreç için durum bilgisi ister; <command>0</command> veya <command>WAIT_MYPGRP</command> değeri çağıran süreçle aynı süreç grubundaki her hangi bir alt süreç için bilgi ister; ve -<varname>sgkim</varname> gibi başka herhangi bir negatif değer, süreç grup kimliği <varname>sgkim</varname> olan herhangi bir alt süreç için bilgi ister.
   </para><para>
Eğer alt süreç durum bilgisi hemen mevcutsa, bu işlev beklemeden hemen döner. Eğer birden fazla seçilebilir alt sürecin durum bilgisi mevcutsa, rastgele birisi seçilir ve durum bilgisi hemen döndürülür. Diğer seçilebilir alt süreçlerden birinin durum bilgisini almak için, <command>waitpid</command> işlevini tekrar çağırmanız gerekir.
   </para><para>
<varname>seçenekler</varname> argümanı bir bit maskesidir. Değeri sıfır veya daha çok sayıda <command>WNOHANG</command> ve <command>WUNTRACED</command> bayrağının bit bit VEYAlanmış (<command>|</command> işleci) hali olmalıdır. <command>WNOHANG</command> bayrağı üst sürecin beklememesi gerektiğini belirtmek için; ve <command>WUNTRACED</command> bayrağı duran ve hatta sonlanan süreçlerden durum bilgisi istemek için kullanılır.
   </para><para>
Alt süreçten alınan durum bilgisi, <varname>durum-gstr</varname> boş gösterici değilse, <varname>durum-gstr</varname> 'nin gösterdiği nesnede saklanır.
   </para><para>
Bu işlev çok-evreli yazılımlar için iptal noktasıdır. Eğer <command>waitpid</command> çağrıldığında bir evre bazı kaynakları (bellek, dosya tanımlayıcısı, semafor veya her hangi başka bir kaynak) ayırırsa bu sorun olur. Evre iptal edilirse bu kaynaklar yazılım sonlanıncaya kadar ayrılmış durumda kalırlar. Bundan kaçınmak için <command>waitpid</command>'e yapılan çağrılar iptal işleyicileri kullanılarak korunmalıdır.
   </para><para>
Dönüş değeri normalde durumu bildirilen alt sürecin süreç kimliğidir. Eğer alt süreçler var ancak hiçbiri uyarım için beklemiyorsa, <command>waitpid</command> birisi uyarılana kadar baskılanır. Fakat, <command>WNOHANG</command> seçeneği belirtildiyse, <command>waitpid</command> baskılanmadan sıfır döndürür.
   </para><para>
Eğer <command>waitpid</command> belirli bir süreç kimliği için bekleyecekse, diğer hiçbir alt süreci (varsa) dikkate almaz. Bu nedenle eğer uyarım için bekleyen alt süreçler varsa, fakat beklenmesi için belirtilen süreç kimliğine sahip alt süreç bunlardan biri değilse, <command>waitpid</command> yukarıda açıklandığı gibi ya baskılanır ya da  sıfır döndürür.
   </para><para>
<command>-1</command> değeri hata halinde döndürülür. Aşağıdaki <command>errno</command> hata durumları bu işlev için tanımlanmıştır:
   </para><para><variablelist><varlistentry>
   <term><command>EINTR</command></term><listitem><para>
Çağıran sürece bir sinyal gelmesi nedeniyle işlev kesintiye uğradı. Bkz  <xref linkend="glibc-Interrupted-Primitives"/>.
      </para></listitem></varlistentry><varlistentry>
      <term><command>ECHILD</command></term><listitem><para>
Bekleyen alt süreç yok veya belirtilen <varname>pid</varname> çağıran sürecin bir alt süreci değil.
      </para></listitem></varlistentry><varlistentry>
      <term><command>EINVAL</command></term><listitem><para>
<varname>seçenekler</varname> argümanı için geçersiz bir değer verildi.
      </para></listitem></varlistentry></variablelist></para><para>
Bu sembolik sabitler <command>waitpid</command> işlevinin <varname>pid</varname> argümanının değerleri olarak tanımlanmıştır.
   </para><para><variablelist><varlistentry>
   <term><command>WAIT_ANY</command></term><listitem><para>
Bu sabit makro (değeri <command>-1</command>dir) <command>waitpid</command>'nin herhangi bir alt sürecin durum bilgisini döndürmesi için belirtilirr.
      </para></listitem></varlistentry><varlistentry>
      <term><command>WAIT_MYPGRP</command></term><listitem><para>
Bu sabit (<command>0</command> değerli) <command>waitpid</command>'in çağıran süreçle aynı süreç grubundaki herhangi bir alt sürecin durum bilgisini döndürmesi için belirtilir.
      </para></listitem></varlistentry></variablelist></para><para>
Bu sembolik sabitler <command>waitpid</command> işlevinin <varname>seçenekler</varname> argümanı için bayrak olarak tanımlanmıştır. Bayrakları bit bit VEYAlayarak argümana değer olarak kullanabilirsiniz.
   </para><para><variablelist><varlistentry>
   <term><command>WNOHANG</command></term><listitem><para>
Bu bayrak, eğer uyarım için bekleyen alt süreç yoksa, <command>waitpid</command> işlevinin beklemeden hemen dönmesi gerektiğini belirtir.
      </para></listitem></varlistentry><varlistentry>
      <term><command>WUNTRACED</command></term><listitem><para>
Bu bayrak, <command>waitpid</command> işlevinin durmuş veya sonlandırılmış alt süreçlerinin durumlarını bildirmesini belirtir.
      </para></listitem></varlistentry></variablelist></para><para>
    </para></listitem></varlistentry></variablelist></para>
  </funcdescr></funcsynopsis>
  </para><para xml:id="glibc-wait">
<indexterm scope="glibc-fn"><primary>wait</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>pid_t <command>wait</command></funcdef>
<paramdef>(int  *<varname>durum-gstr</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu <command>waitpid</command>'in basitleştirilmiş halidir ve herhangi bir alt süreç sonlanıncaya kadar beklemek için kullanılır. Aşağıdaki çağrı şekli:
   </para><para>
<screen>wait (status)</screen>
   </para><para>
aşağıdaki ile tamamen aynıdır:
   </para><para>
<screen>waitpid (-1, status, 0)</screen>
   </para><para>
Bu işlev çok-evreli yazılımlar için iptal noktasıdır. Eğer <command>wait</command> çağrıldığında bir evre bazı kaynakları (bellek, dosya tanımlayıcısı, semafor veya her hangi başka bir kaynak) ayırırsa bu sorun olur. Evre iptal edilirse bu kaynaklar yazılım sonlanıncaya kadar ayrılmış durumda kalırlar. Bundan kaçınmak için <command>wait</command>'e yapılan çağrılar iptal işleyicileri kullanılarak korunmalıdır.
   </para></funcdescr></funcsynopsis></para><para xml:id="glibc-wait4">
<indexterm scope="glibc-fn"><primary>wait4</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>pid_t <command>wait4</command></funcdef>
<paramdef>(pid_t          <varname>pid</varname>,
 int           *<varname>durum-gstr</varname>,
 int            <varname>seçenekler</varname>,
 struct rusage *<varname>kullanım</varname>)
</paramdef>
</funcprototype><funcdescr><para>
Eğer <varname>kullanım</varname> bir boş gösterici ise, <command>wait4</command> işlevi <command>waitpid (<varname>pid</varname>, <varname>durum-gstr</varname>, <varname>seçenekler</varname>)</command>  ile eşdeğerdir.
   </para><para>
Eğer <varname>kullanım</varname> bir boş gösterici değilse, <command>wait4</command> işlevi <command>*</command><varname>kullanım</varname> içinde alt sürecin kullanım şekillerini saklar (alt süreç durduysa değil, yalnızca sonlandıysa).  Bkz. <xref linkend="glibc-Resource-Usage"/>.
   </para><para>
Bu işlev bir BSD oluşumudur.
      </para></funcdescr></funcsynopsis></para><para>
Burada sonlandırılmış bütün alt süreçlerin durumunu beklemeden almak için <command>waitpid</command> işlevinin kullanımını gösteren bir örnek görüyoruz. Bu işlev, en azından bir alt sürecin sonlandırılması gerektiğini belirten bir sinyal olan, <command>SIGCHLD</command> için bir işleyici olarak tasarlanmıştır.
   </para><para>
<screen>
void
sigchld_handler (int signum)
{
  int pid, status, serrno;
  serrno = errno;
  while (1)
    {
      pid = waitpid (WAIT_ANY, &amp;status, WNOHANG);
      if (pid &lt; 0)
        {
          perror ("waitpid");
          break;
        }
      if (pid == 0)
        break;
      notice_termination (pid, status);
    }
  errno = serrno;
}
     </screen></para></chapter>
  <chapter xml:id="glibc-Process-Completion-Status">
    <title>Süreç Tamamlanma Durumu</title>
    <titleabbrev>Alt süreçten dönen durum değeri nasıl yorumlanır.</titleabbrev>
    <para>
Eğer alt sürecin <link linkend="glibc-Program-Termination">çıkış durum değeri</link>
sıfırsa, o zaman <command>waitpid</command> veya <command>wait</command> ile bildirilen durum değeri de sıfırdır. Aşağıdaki makroları kullanarak dönen durum değerlerinde kodlanmış diğer türlerdeki bilgileri sınayabilirsiniz.
Bu makrolar <filename>sys/wait.h</filename> başlık dosyası içinde tanımlıdır.
<indexterm scope="glibc-pg"><primary>sys/wait.h</primary></indexterm>
    </para><para xml:id="glibc-WIFEXITED">
<indexterm scope="glibc-fn"><primary>WIFEXITED</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>int <command>WIFEXITED</command></funcdef>
<paramdef>(int <varname>durum</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu makro alt süreç normal olarak <command>exit</command> veya <command>_exit</command> ile sonlandırıldıysa sıfırdan farklı bir değer döndürür.
      </para></funcdescr></funcsynopsis>
      </para><para xml:id="glibc-WEXITSTATUS">
<indexterm scope="glibc-fn"><primary>WEXITSTATUS</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>int <command>WEXITSTATUS</command></funcdef>
<paramdef>(int <varname>durum</varname>)</paramdef>
</funcprototype><funcdescr><para>
Eğer <command>WIFEXITED</command> <varname>durum</varname> için doğruysa, bu makro, alt süreçten <link linkend="glibc-Exit-Status">çıkış değerinin</link> düşük-sıralı 8 bitini döndürür.
      </para></funcdescr></funcsynopsis>
      </para><para xml:id="glibc-WIFSIGNALED">
<indexterm scope="glibc-fn"><primary>WIFSIGNALED</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>int <command>WIFSIGNALED</command></funcdef>
<paramdef>(int <varname>durum</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu makro alt süreç işlenemeyen bir sinyal aldıysa ve sonlandıysa sıfırdan farklı bir değer döndürür. Bkz. <xref linkend="glibc-Signal-Handling"/>.
      </para></funcdescr></funcsynopsis>
      </para><para xml:id="glibc-WTERMSIG">
<indexterm scope="glibc-fn"><primary>WTERMSIG</primary></indexterm> <funcsynopsis><funcprototype role="makro">
<funcdef>int <command>WTERMSIG</command></funcdef>
<paramdef>(int <varname>durum</varname>)</paramdef>
</funcprototype><funcdescr><para>
Eğer <command>WIFSIGNALED</command> <varname>durum</varname> için doğruysa, bu makro alt süreci sonlandıran sinyalin sinyal numarasını döndürür.
      </para></funcdescr></funcsynopsis>
      </para><para xml:id="glibc-WCOREDUMP">
<indexterm scope="glibc-fn"><primary>WCOREDUMP</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>int <command>WCOREDUMP</command></funcdef>
<paramdef>(int <varname>durum</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu makro alt süreç sonlandıysa ve bir çekirdek dökümü ürettiyse sıfırdan farklı bir değer döndürür.
      </para></funcdescr></funcsynopsis>
      </para><para xml:id="glibc-WIFSTOPPED">
<indexterm scope="glibc-fn"><primary>WIFSTOPPED</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>int <command>WIFSTOPPED</command></funcdef>
<paramdef>(int <varname>durum</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu makro alt süreç durduysa sıfırdan farklı bir değer döndürür.
      </para></funcdescr></funcsynopsis>
      </para><para xml:id="glibc-WSTOPSIG">
<indexterm scope="glibc-fn"><primary>WSTOPSIG</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>int <command>WSTOPSIG</command></funcdef>
<paramdef>(int <varname>durum</varname>)</paramdef>
</funcprototype><funcdescr><para>
Eğer <command>WIFSTOPPED</command> <varname>durum</varname> için doğruysa, bu makro alt sürecin durmasına neden olan sinyalin sinyal numarasını döndürür.
      </para></funcdescr></funcsynopsis>
    </para>
  </chapter>
  <chapter xml:id="glibc-BSD-Wait-Functions">
    <title>BSD Süreç Bekleme İşlevleri</title>
    <titleabbrev>Geriye dönük uyumluluk için bazı işlevler.</titleabbrev>
    <para>
GNU kütüphanesi aynı zamanda BSD Unix ile uyumluluk sağlayan bu oluşumları da sağlamaktadır. BSD, durum değerlerini göstermek için <command>int</command> yerine <command>union wait</command> veri türünü kullanmaktadır. İki gösterim bir birinin yerine kullanılabilir; aynı bit kalıplarını açıklamaktadırlar. GNU C Kütüphanesi <command>WEXITSTATUS</command> gibi makrolar tanımlar, böylece her iki türdeki projelerde de çalışır, ayrıca <command>wait</command> işlevi kendisinin <varname>durum-gstr</varname> argümanına her iki türde gösterici kabul etmek için tanımlanmıştır.
   </para><para>
Bu işlevler <filename>sys/wait.h</filename>içinde tanımlıdır.
<indexterm scope="glibc-pg"><primary>sys/wait.h</primary></indexterm>
      </para><para xml:id="glibc-union-wait">
<indexterm scope="glibc-tp"><primary sortas="wait">union wait</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü">
<funcdef>union <command>wait</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu veri türü yazılım sonlandırma durum değerini gösterir. Aşağıdaki üyelere sahiptir:
   </para><glosslist><glossentry>
     <glossterm><literal>int <command>w_termsig</command></literal>
   </glossterm><glossdef><para>
Bu üyenin değeri <command>WTERMSIG</command> makrosunun değeriyle aynıdır.
    </para></glossdef></glossentry><glossentry>
     <glossterm><literal>int <command>w_coredump</command></literal>
    </glossterm><glossdef><para>
Bu üyenin değeri <command>WCOREDUMP</command> makrosunun değeriyle aynıdır.
    </para></glossdef></glossentry><glossentry>
     <glossterm><literal>int <command>w_retcode</command></literal>
    </glossterm><glossdef><para>
Bu üyenin değeri <command>WEXITSTATUS</command> makrosunun değeriyle aynıdır.
     </para></glossdef></glossentry><glossentry>
      <glossterm><literal>int <command>w_stopsig</command></literal>
     </glossterm><glossdef><para>
Bu üyenin değeri <command>WSTOPSIG</command> makrosunun değeriyle aynıdır.
     </para></glossdef></glossentry></glosslist></funcdescr></funcsynopsis>
   </para><para>
Bu üyelere doğrudan erişmektense, eşdeğer makrolarını kullanmalısınız.
   </para><para>
<command>wait3</command> işlevi daha esnek olan <command>wait4</command> işlevinin atasıdır. <command>wait3</command> artık atıldır.
   </para><para xml:id="glibc-wait3">
<indexterm scope="glibc-fn"><primary>wait3</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>pid_t <command>wait3</command></funcdef>
<paramdef>(union wait    *<varname>durum-gstr</varname>,
 int            <varname>seçenekler</varname>,
 struct rusage *<varname>kullanım</varname>)</paramdef>
</funcprototype><funcdescr><para>
Eğer <varname>kullanım</varname> bir boş gösterici ise, <command>wait3</command> işlevi <command>waitpid (-1, <varname>durum-gstr</varname>, <varname>seçenekler</varname>)</command> işlevinin eşdeğeridir.
   </para><para>
Eğer <varname>kullanım</varname> boş gösterici değilse, <command>wait3</command> alt sürecin kullanım şekillerini <command>*</command><varname>kullanım</varname> içinde saklar (eğer alt süreç sonlandıysa; durduysa değil).  <xref linkend="glibc-Resource-Usage"/>.
      </para></funcdescr></funcsynopsis>
    </para>
  </chapter>
  <chapter xml:id="glibc-Process-Creation-Example">
    <title>Süreç Oluşturma Örneği</title>
    <titleabbrev>Tam Örnek.</titleabbrev>
    <para>
Burada yerleşik <command>system</command> işlevine benzer örnek bir yazılım görüyoruz. Kendi <varname>komut</varname> argümanını <command>sh -c <varname>komut</varname></command> 'ın eşdeğerini kullanarak çalıştırır.
   </para><para>
<screen>#include stddef.h
#include stdlib.h
#include unistd.h
#include sys/types.h
#include sys/wait.h

/* Komutu bu kabuk yazılımını kullanarak çalıştır.  */
#define SHELL &quot;/bin/sh&quot;

int
my_system (const char *komut)
{
  int status;
  pid_t pid;

  pid = fork ();
  if (pid == 0)
    {
      /* Bu alt süreçtir.  Kabuk komutunu çalıştırır. */
      execl (SHELL, SHELL, &quot;-c&quot;, komut, NULL);
      _exit (EXIT_FAILURE);
    }
  else if (pid &lt; 0)
    /* Çatallama başarılamadı.  Başarısızlığı bildir.  */
    status = -1;
  else
    /* Bu üst süreçtir.  Bitirmek için alt süreci bekle.  */
    if (waitpid (pid, &amp;status, 0) != pid)
      status = -1;
  return status;
}
</screen></para><para>
Bu örnekte dikkat etmeniz gereken bir kaç nokta var.
   </para><para>
Unutmayınız ki yazılıma sağlanan ilk <command>argv</command> argümanı çalıştırılan yazılımın adıdır. Bu nedenle, <command>execl</command>'ye yapılan çağrıda, <command>SHELL</command> bir kere çalıştırılacak yazılım ismini sağlamak için, bir kere de <command>argv[0]</command>'a değer sağlamak için kullanılmıştır.
   </para><para>
Alt süreçteki <command>execl</command> çağrısı başarılıysa değer döndürmez. Başarısız olursa, alt sürecin sonlanması için birşeyler yapmanız gerekir. Sadece <command>return</command> ile kötü durum kodu döndürülmesi, orjinal yazılımı çalıştıran iki süreci bırakabilir. Bunun yerine, doğru davranış üst sürece alt süreç ile ilgili başarısızlığın bildirilmesidir.
   </para><para>
Bunu başarmak için <command>_exit</command> işlevini çağırın. <command>_exit</command> işlevini <command>exit</command> yerine kullanma nedeni <command>stdout</command> gibi tamamen tamponlanmış akımları boşaltmanın önüne geçmektir. Bu akımların tamponları büyük olasılıkla üst süreçten <command>fork</command> ile kopyalanmış veri içerir, sonunda bu veri üst süreç tarafından çıktı alınır. Alt süreçte <command>exit</command> çağrısı verinin iki kez çıktı vermesine neden olabilir. Bkz <xref linkend="glibc-Termination-Internals"/>.
   </para></chapter>

 <chapter xml:id="glibc-POSIX-Threads">
  <title>POSIX Evreleri</title>
  <para>
Bu bölümde pthreads (POSIX evreleri) kütüphanesi anlatılmaktadır. Bu kütüphane çok-evreli programlar için destek işlevleri sağlamaktadır: evre ilkelleri, eşzamanlama nesneleri, vb. Aynı zamanda POSIX 1003.1b semaforlarını (System V semaforlarıyla karıştırılmamalıdır) gerçekler.
  </para><para>
Evre işlemleri (<command>pthread_*</command>) <varname>errno</varname> kullanmazlar.
Bunun yerine hata kodunu doğrudan döndürürler. Semafor işlemleri ise <varname>errno</varname> kullanır.
  </para>
  <sect1 xml:id="glibc-Basic-Thread-Operations">
   <title>Basit Evre İşlemleri</title>
   <titleabbrev>Evrelerin oluşturulması, sonlandırılması ve beklenmesi.</titleabbrev>
   <para>
Bu işlevler <command>fork</command>, <command>exit</command> ve <command>wait</command> işlevlerinin evre eşdeğerleridir.
   </para><para>
<indexterm scope="glibc-fn"><primary>pthread_create</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-pthread_create">
<funcdef>int <command>pthread_create</command></funcdef>
<paramdef>(pthread_t      *<varname>evre</varname>,
 pthread_attr_t *<varname>öznitelik</varname>,
 void         *(*<varname>başlatma_işlevi</varname>)(void *),
 void           *<varname>arg</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>pthread_create</command> çağıran evre ile aynı zamanda çalışan yeni bir kontrol evresi yaratır. Yeni evre ilk argümanına <varname>arg</varname> geçirerek <varname>başlatma_işlevi</varname> işlevini çağırır. Yeni evre <command>pthread_exit</command> işlevini çağırarak her ikisini de açıkça sonlandırır,
veya <varname>başlatma_işlevi</varname> işlevinden dönerek örtük olarak sonlandırır.
İkinci yaklaşım <varname>başlatma_işlevi</varname> işlevinin çıkış kodu olarak dönen sonuçla <command>pthread_exit</command> işlevinin çağrılmasına eşdeğerdir.
   </para><para>
<varname>öznitelik</varname> argümanı yeni evreye uygulanacak evre özelliklerini belirler. Ayrıntılar için bkz. <xref linkend="glibc-Thread-Attributes"/>. <varname>öznitelik</varname> argümanı <command>NULL</command> da olabilir, bu durumda öntanımlı özellikler kullanılır: oluşturulan evre birleşimcidir (ayrık değildir) ve sıradan (gerçek zamanlı değil) bir zamanlama ilkesine sahiptir.
   </para><para>
Başarı halinde, yeni oluşturulan evrenin tanıtıcısı <varname>evre</varname> argümanıyla gösterilen yerde saklanır ve bir 0 döndürülür. Hata halinde, sıfırdan farklı bir hata kodu döndürülür.
   </para><para>
İşlev aşağıdaki hataları döndürebilir:
   </para><para>
   <variablelist>
    <varlistentry>
     <term><literal>EAGAIN</literal></term>
     <listitem><para>
Yeni evre için süreç oluşturacak yeterli sistem kaynağı yok veya <command>PTHREAD_THREADS_MAX</command> den fazla sayıda evre rtkin.
      </para></listitem></varlistentry></variablelist>
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>pthread_exit</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-pthread_exit">
<funcdef>void <command>pthread_exit</command></funcdef>
<paramdef>(void *<varname>dönüş_değeri</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>pthread_exit</command> çağrılan evrenin çalıştırılmasını sonlandırır.
Çağrılan evre için <command>pthread_cleanup_push</command> ile atanmış bütün <link linkend="glibc-Cleanup-Handlers">temizlik işleyicileri</link> ters sırayla çalıştırılır (son eklenen işleyici ilk çalıştırılır). Ardından evreye özgü veriler için kullanılan sonlandırma işlevleri, <command>NULL</command> olmayan değere sahip, çağıran evreyle ilişkili bütün anahtarlar için çağrılır (<xref linkend="glibc-Thread-Specific-Data"/>).  Son olarak, çağıran evrenin çalıştırılması durdurulur.
   </para><para>
<varname>dönüş_değeri</varname> argümanı evrenin dönüş değeridir. <command>pthread_join</command> kullanarak başka bir evreden elde edilebilir.
   </para> <para>
<command>pthread_exit</command> işlevi hiç bir zaman dönmez.
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>pthread_cancel</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-pthread_cancel">
<funcdef>int <command>pthread_cancel</command></funcdef>
<paramdef>(pthread_t <varname>evre</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>pthread_cancel</command> işlevi <varname>evre</varname> argümanıyla belirtilen evreye bir iptal isteği gönderir.
Eğer böyle bir evre yoksa, <command>pthread_cancel</command> başarısız olur ve <command>ESRCH</command> döndürür.
Aksi takdirde 0 döndürür. Ayrıntılar için bkz. <xref linkend="glibc-Cancellation"/>.
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>pthread_join</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-pthread_join">
<funcdef>int <command>pthread_join</command></funcdef>
<paramdef>(pthread_t <varname>evre</varname>,
 void    **<varname>evre_dönüş</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>pthread_join</command> <varname>evre</varname> ile tanımlanan evre sonlanıncaya kadar çağıran evrenin çalıştırılmasını <command>pthread_exit</command> işlevini çağırarak veya iptal edilerek askıya alır.
   </para><para>
Eğer <varname>evre_dönüş</varname> <command>NULL</command> değilse, <varname>evre</varname>nin dönüş değeri <varname>evre_dönüş</varname> ile gösterilen yerde saklanır. <varname>evre</varname>nin dönüş değeri ya <command>pthread_exit</command>e verdiği argümandır ya da eğer <varname>evre</varname> iptal edildiyse <command>PTHREAD_CANCELED</command> değeridir.
   </para><para>
Birleşmiş evre <varname>evre</varname> birleşebilir durumda olmalıdır: <command>pthread_detach</command> ile ayrılmış olmamalıdır veya
 <command>PTHREAD_CREATE_DETACHED</command> özelliği <command>pthread_create</command> işlevine verilmemiş olmalıdır.
   </para><para>
Birleşebilir bir evre sonlandığında, onun bellek özkaynakları (evre tanımlayıcısı ve yığıt) başka bir evre üzerinde <command>pthread_join</command> uygulayıncaya kadar serbest bırakılmazlar. Bu nedenle, bellek kaçağını önlemek için <command>pthread_join</command> işlevinin her birleşebilir evre için çağrılması gerekir.
   </para><para>
Verilen bir evrenin sonlanması için en çok bir evre bekleyebilir.
Üzerinde başka bir evrenin sonlanması için beklemekte olduğu, bir <varname>evre</varname> evresi üzerinde, <command>pthread_join</command> çağrısı hata döndürür.
   </para><para>
<command>pthread_join</command> bir iptal noktasıdır. <command>pthread_join</command>de askıya alınmış bir evre iptal edilirse, evre hemen işletmeyi sürdürür ve <varname>evre</varname> evresinin sonlanması beklenmeden iptal işletilir. Eğer <command>pthread_join</command> süresince iptal yaşanırsa, <varname>evre</varname> evresi birleşmemiş kalır.
   </para><para>
Başarı halinde, <varname>evre</varname>nin dönüş değeri  <varname>evre_dönüş</varname> ile gösterilen yerde saklanır ve 0 döndürülür. Hata halinde, aşağıdaki değerlerden biri döndürülür:
   </para><para><variablelist>
    <varlistentry><term><literal>ESRCH</literal></term>
     <listitem><para>
<varname>evre</varname> ile belirtilene uygun bir evre bulunamadı.
     </para></listitem></varlistentry><varlistentry>
     <term><literal>EINVAL</literal></term>
     <listitem><para>
<varname>evre</varname> evresi ayrılmış veya başka bir evre <varname>evre</varname>nin sonlanmasını beklemektedir.
    </para></listitem></varlistentry><varlistentry>
     <term><literal>EDEADLK</literal></term>
     <listitem><para>
<varname>evre</varname> argümanı çağıran evreyi belirtmektedir.
      </para></listitem></varlistentry></variablelist>
    </para></funcdescr></funcsynopsis></para>
  </sect1>
  <sect1 xml:id="glibc-Thread-Attributes">
   <title>Evre Öznitelikleri</title>
   <titleabbrev>Evre zamanlama ayarı.</titleabbrev>
   <para>
Evreler oluşturulmaları sırasında aldıkları bir miktar özelliğe sahip olabilir.
Bu, <command>pthread_attr_t</command> türündeki bir <varname>öznitelik</varname> evre öznitelik nesnesinin doldurulması, ardından da <command>pthread_create</command> işlevine ikinci argüman olarak aktarılmasıyla olur. <command>NULL</command> aktarmak bütün özniteliklerine öntanımlı değerler atanmış bir evre öznitelik nesnesi aktarmakla eşdeğerdir.
   </para><para>
Öznitelik nesnelerine sadece yeni bir evre oluşturulacağı zaman başvurulur.
Aynı öznitelik nesnesi bir çok evrenin oluşturulmasında kullanılabilir.
<command>pthread_create</command> çağrıldıktan sonra bir öznitelik nesnesinin değiştirilmesi önceden oluşturulan bir evrenin özniteliklerini değiştirmez.
   </para><para>
<indexterm scope="glibc-fn"><primary>pthread_attr_init</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-pthread_attr_init">
<funcdef>int <command>pthread_attr_init</command></funcdef>
<paramdef>(pthread_attr_t *<varname>öznitelik</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>pthread_attr_init</command> <varname>öznitelik</varname> evre öznitelik nesnesini hazırlar ve özniteliklerini öntanımlı değerlerle doldurur.
(Öntanımlı değerler her öznitelik için aşağıda listelenmiştir.)
   </para><para>
Her <varname>isim</varname> özniteliği (bütün özniteliklerin listesi için aşağı bakınız) <command>pthread_attr_set<varname>isim</varname></command>  işlevi ile tek tek belirlenebilir ve <command>pthread_attr_get<varname>isim</varname></command> işlevi ile değeri alınabilir.
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>pthread_attr_destroy</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-pthread_attr_destroy">
<funcdef>int <command>pthread_attr_destroy</command></funcdef>
<paramdef>(pthread_attr_t *<varname>öznitelik</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>pthread_attr_destroy</command> <varname>öznitelik</varname> ile gösterilen özellik nesnesini ilişkili bütün kaynakları serbest bırakarak yok edebilir.
<varname>öznitelik</varname> tanımlanmamış bir durumda bırakılır ve tekrar hazırlanıncaya kadar herhangi bir POSIX evre işlevi ile kullanmamanız gerekir.
<indexterm scope="glibc-fn"><primary>pthread_attr_setdetachstate</primary></indexterm>
<indexterm scope="glibc-fn"><primary>pthread_attr_setguardsize</primary></indexterm>
<indexterm scope="glibc-fn"><primary>pthread_attr_setinheritsched</primary></indexterm>
<indexterm scope="glibc-fn"><primary>pthread_attr_setschedparam</primary></indexterm>
<indexterm scope="glibc-fn"><primary>pthread_attr_setschedpolicy</primary></indexterm>
<indexterm scope="glibc-fn"><primary>pthread_attr_setscope</primary></indexterm>
<indexterm scope="glibc-fn"><primary>pthread_attr_setstack</primary></indexterm>
<indexterm scope="glibc-fn"><primary>pthread_attr_setstackaddr</primary></indexterm>
<indexterm scope="glibc-fn"><primary>pthread_attr_setstacksize</primary></indexterm>
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>pthread_attr_setattr</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-pthread_attr_setattr">
<funcdef>int <command>pthread_attr_setattr</command></funcdef>
<paramdef>(pthread_attr_t *<varname>nesne</varname>,
 int             <varname>değer</varname>)</paramdef>
</funcprototype><funcdescr><para>
<varname>nesne</varname> ile gösterilen öznitelik nesnesinin içindeki <varname>öznitelik</varname> özelliğine <varname>değer</varname> değerini verir.
Olası öznitelikler ve alabilecekleri değerler listesi için aşağıya bakınız.
   </para><para>
Başarı halinde, bu işlevler 0 döndürür. Eğer <varname>değer</varname> değiştirilen <varname>öznitelik</varname> için anlamlı değilse, <command>EINVAL</command> hata kodunu döndürürler. Bazı işlevlerin başka hata kipleri vardır; aşağıya bakınız.
<indexterm scope="glibc-fn"><primary>pthread_attr_getdetachstate</primary></indexterm>
<indexterm scope="glibc-fn"><primary>pthread_attr_getguardsize</primary></indexterm>
<indexterm scope="glibc-fn"><primary>pthread_attr_getinheritsched</primary></indexterm>
<indexterm scope="glibc-fn"><primary>pthread_attr_getschedparam</primary></indexterm>
<indexterm scope="glibc-fn"><primary>pthread_attr_getschedpolicy</primary></indexterm>
<indexterm scope="glibc-fn"><primary>pthread_attr_getscope</primary></indexterm>
<indexterm scope="glibc-fn"><primary>pthread_attr_getstack</primary></indexterm>
<indexterm scope="glibc-fn"><primary>pthread_attr_getstackaddr</primary></indexterm>
<indexterm scope="glibc-fn"><primary>pthread_attr_getstacksize</primary></indexterm>
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>pthread_attr_getattr</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-pthread_attr_getattr">
<funcdef>int <command>pthread_attr_getattr</command></funcdef>
<paramdef>(pthread_attr_t *<varname>nesne</varname>,
 int            *<varname>değer</varname>)</paramdef>
</funcprototype><funcdescr><para>
<varname>nesne</varname> içindeki <varname>öznitelik</varname> özelliğinin geçerli ayarlarını <varname>değer</varname> ile gösterilen değişken içinde saklar.
   </para><para>
Bu işlevler her zaman 0 döndürür.
</para></funcdescr></funcsynopsis></para><para>
Aşağıdaki evre öznitelikleri desteklenmektedir:
   </para><para>
   <variablelist><varlistentry>
     <term><literal>detachstate</literal></term>
     <listitem><para>
Evrenin birleşimci bir durumda mı (<command>PTHREAD_CREATE_JOINABLE</command> değeri)
yoksa ayrık durumda mı (<command>PTHREAD_CREATE_DETACHED</command>) oluşturulacağını seçer. Öntanımlı olan <command>PTHREAD_CREATE_JOINABLE</command> değeridir.
      </para><para>
Birleşimci durumunda, başka bir evre, evrenin sonlanışıyla eşzamanlanabilir ve <command>pthread_join</command> kullanarak kendi sonlanma kodunu kurtarabilir,
fakat bazı evre özkaynakları evre sonlandıktan sonra ayrılmış kalır ve ancak başka bir evre o evre üzerinde <command>pthread_join</command> uygularsa geri alınabilir.
      </para><para>
Ayrık durumda, evre sonlandığında özkaynakları anında serbest bırakılır,
fakat evrenin sonlandırılışında eşzamanlamak için <command>pthread_join</command> kullanılamaz.
      </para><para>
Birleşimci durumda oluşturulan bir evre daha sonra <command>pthread_detach</command> ile ayrık evreye konulabilir.
      </para></listitem></varlistentry><varlistentry>
     <term><literal>schedpolicy</literal></term>
     <listitem>
      <para>
Evre için zamanlama ilkesini seçilir: <command>SCHED_OTHER</command> (normal, gerçek zamanlı olmayan zamanlama), <command>SCHED_RR</command> (gerçek zamanlı, döner turnuva) veya <command>SCHED_FIFO</command> (gerçek zamanlı, ilk giren ilk çıkar).
Öntanımlı olan <command>SCHED_OTHER</command> ilkesidir.
      </para><para>
Gerçek zamanlı zamanlama ilkeleri olan <command>SCHED_RR</command> ve <command>SCHED_FIFO</command> ilkeleri sadece süper kullanıcı haklarına sahip süreçler için mevcuttur. Eğer yetkisizken gerçek zamanlı bir ilke kurmayı denerseniz <command>pthread_attr_setschedparam</command> işlevi başarısız olur ve <command>ENOTSUP</command> hatasını döndürür.
      </para><para>
Bir evre oluşturulduktan sonra, zamanlama ilkesi  <command>pthread_setschedparam</command> ile değiştirilebilir.
      </para></listitem></varlistentry><varlistentry>
     <term><literal>schedparam</literal></term>
     <listitem><para>
Evre için zamanlama parametresini (zamanlama önceliği) değiştirir. Öntanımlı değeri 0'dır.
      </para><para>
Bu özellik zamanlama ilkesi <command>SCHED_OTHER</command> ise anlamlı değildir; bu sadece gerçek zamanlı <command>SCHED_RR</command> ve <command>SCHED_FIFO</command> ilkelerini ilgilendirir.
      </para><para>
Bir evre oluşturulduktan sonra, zamanlama önceliği <command>pthread_setschedparam</command> ile değiştirilebilir.
      </para></listitem></varlistentry><varlistentry>
     <term><literal>inheritsched</literal></term>
     <listitem><para>
Yeni oluşturlan evre için zamanlama ilkesinin ve parametresinin         <varname>schedpolicy</varname> ve <varname>schedparam</varname> özelliklerinin
değerleriyle mi (<command>PTHREAD_EXPLICIT_SCHED</command> değeri) yoksa üst evreden miras alınarak mı (<command>PTHREAD_INHERIT_SCHED</command> değeri) belirleneceğini seçer. Öntanımlı değer <command>PTHREAD_EXPLICIT_SCHED</command> değeridir.
      </para></listitem></varlistentry><varlistentry>
     <term><literal>scope</literal></term>
     <listitem><para>
Oluşturulan evre için zamanlama çekişme kapsamını seçer.
Öntanımlı değeri <command>PTHREAD_SCOPE_SYSTEM</command>'dir ve bu, evrelerin işlemci zamanı için makinede çalışan bütün süreçlerle çekişmesi anlamına gelir. Evre öncelikleri makinede çalışan diğer bütün süreçlere göre yorumlanır. Diğer bir olasılık, <command>PTHREAD_SCOPE_PROCESS</command> olup bu, evrelerin zamanlama çekişmesinin sadece çalışan sürecin evreleri arasında gerçekleştiği anlamına gelir: evre öncelikleri sürecin diğer evrelerine göre yorumlanır, diğer süreçlerin önceliklerine bakılmaz.
      </para><para>
<command>PTHREAD_SCOPE_PROCESS</command> LinuxThreads'de desteklenmemektedir.
Eğer kapsamı bu değer olarak ayarlamaya çalışırsanız, <command>pthread_attr_setscope</command> başarısız olur ve <command>ENOTSUP</command> döndürür.
      </para></listitem></varlistentry><varlistentry>
     <term><literal>stackaddr</literal></term>
     <listitem><para>
Uygulama yönetimli yığıt için adres sağlar. Yığıtın büyüklüğü en az <command>PTHREAD_STACK_MIN</command> olmalıdır.
      </para></listitem></varlistentry><varlistentry>
     <term><literal>stacksize</literal></term>
     <listitem><para>
Evre için oluşturulan yığıtın büyüklüğünü değiştirir. Değer yığıt için asgari büyüklüğü bayt cinsinden tanımlar.
      </para><para>
Eğer değer sistemin azami yığıt büyüklüğünü aşarsa veya <command>PTHREAD_STACK_MIN</command> değerinden küçükse,
<command>pthread_attr_setstacksize</command> başarısız olur ve <command>EINVAL</command> döndürür.
      </para></listitem></varlistentry><varlistentry>
     <term><literal>stack</literal></term>
     <listitem><para>
Yeni evreye, kullanmak için uygulama yönetimli yığıta hem adresi hem de büyüklüğü sağlar.
Bellek alanının tabanı, bayt cinsinden <varname>stacksize</varname> büyüklüğündeki <varname>stackaddr</varname>dir.
      </para><para>
Eğer <varname>stacksize</varname> değeri <command>PTHREAD_STACK_MIN</command> değerinden az ise veya sistemin azami yığın büyüklüğünden büyükse veya <varname>stackaddr</varname> değeri uygun hizalamadan yoksunsa, <command>pthread_attr_setstack</command> başarısız olur ve <command>EINVAL</command> döndürür.
      </para></listitem></varlistentry><varlistentry>
     <term><literal>guardsize</literal></term>
     <listitem><para>
Evre yığıtının koruma alanının asgari büyüklüğünü bayt cinsinden değiştirir. Varsayılan büyüklük tek sayfadır. Eğer bu değer belirtilirse, en yakın sayfa büyüklüğüne yuvarlanır.
Değer 0'a eşitlenirse, bu evre için koruma alanı oluşturulmaz. Koruma alanı için ayrılan yer yığıt taşmalarını yakalamak için kullanılır. Bu nedenle, yığıt üzerinde büyük yapılar ayrılacağında, yığıt taşmalarını yakalamak için daha büyük koruma alanı gerekebilir.
      </para><para>
Çağrıcı kendi yığıtlarını yönetiyorsa (eğer <command>stackaddr</command> özelliği belirtildiyse), o zaman <command>guardsize</command> özelliği dikkate alınmaz.
      </para><para>
Eğer değer <command>stacksize</command> değerini aşarsa,
<command>pthread_atrr_setguardsize</command> başarısız olur ve <command>EINVAL</command> döndürür.
      </para></listitem></varlistentry></variablelist>
    </para>
  </sect1>
  <sect1 xml:id="glibc-Cancellation">
   <title>İptaletme</title>
   <titleabbrev>Evre bitmeden durdurmak.</titleabbrev>
   <para>
İptaletme bir evrenin başka bir evrenin işletilmesini sonlandırabildiği bir mekanizmadır. Daha kesin bir deyişle, bir evre başka bir evreye bir iptal isteği gönderebilir. Ayarlarına bağlı olarak, hedef evre isteği reddedebilir veya bir iptal noktasına ulaşana kadar erteleyebilir. Evreler <command>pthread_create</command> ile ilk oluşturulduklarında, daima iptal isteklerini ertelerler.
   </para><para>
Bir evre iptal isteğine cevap verirken aslında, <command>pthread_exit(PTHREAD_CANCELED)</command> çağrılmış gibi davranır. Bütün temizlik işleyicileri ters sıraya işletilirler, evrelere özgü veri sonlandırma işlevleri çağrılır ve son olarak evre işletilmeyi durdurur. İptal edilen evre birleşimciyse,
<command>PTHREAD_CANCELED</command> dönüş değeri bu evre üzerinde <varname>pthread_join</varname> işlevini çağıran evreye gönderilir.
Daha fazla bilgi için bkz. <link linkend="glibc-pthread_exit"><command>pthread_exit</command></link>.
   </para><para>
İptal noktaları evrelerin bekleyen iptal isteklerini kontrol ettikleri ve uyguladıkları noktalardır.  POSIX evre işlevleri <command>pthread_join</command>, <command>pthread_cond_wait</command>,
 <command>pthread_cond_timedwait</command>,  <command>pthread_testcancel</command>,
 <command>sem_wait</command> ve <command>sigwait</command> iptal noktalarıdır. Ek olarak, bu sistem çağrıları da iptal noktalarıdır:
   </para><para>
   <informaltable frame="none" style="background:#999999;">
    <tgroup cols="3">
     <colspec colwidth="24*"/>
     <colspec colwidth="24*"/>
     <colspec colwidth="24*"/>
     <tbody>
      <row style="background:#ffffee;">
       <entry><command>accept</command></entry>
       <entry><command>open</command></entry>
       <entry><command>sendmsg</command>
</entry></row>
      <row style="background:#ffffee;">
       <entry><command>close</command></entry>
       <entry><command>pause</command></entry>
       <entry><command>sendto</command>
</entry></row>
      <row style="background:#ffffee;">
       <entry><command>connect</command></entry>
       <entry><command>read</command></entry>
       <entry><command>system</command>
</entry></row>
      <row style="background:#ffffee;">
       <entry><command>fcntl</command></entry>
       <entry><command>recv</command></entry>
       <entry><command>tcdrain</command>
</entry></row>
      <row style="background:#ffffee;">
       <entry><command>fsync</command></entry>
       <entry><command>recvfrom</command></entry>
       <entry><command>wait</command>
</entry></row>
      <row style="background:#ffffee;">
       <entry><command>lseek</command></entry>
       <entry><command>recvmsg</command></entry>
       <entry><command>waitpid</command>
</entry></row>
      <row style="background:#ffffee;">
       <entry><command>msync</command></entry>
       <entry><command>send</command></entry>
       <entry><command>write</command></entry></row>
      <row style="background:#ffffee;">
       <entry><command>nanosleep</command></entry>
       <entry/><entry/></row>
      </tbody></tgroup></informaltable>

   </para><para>
Bu işlevleri çağıran bütün kütüphane işlevleri de (<command>printf</command> gibi) iptal noktalarıdır.
   </para><para>
<indexterm scope="glibc-fn"><primary>pthread_setcancelstate</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-pthread_setcancelstate">
<funcdef>int <command>pthread_setcancelstate</command></funcdef>
<paramdef>(int  <varname>durum</varname>,
 int *<varname>eskidurum</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>pthread_setcancelstate</command> çağıran evre için iptal durumunu değiştirir - bu iptal isteklerinin dikkate alınıp alınmayacağıdır. <varname>durum</varname> argümanı yeni iptal durumudur: <command>PTHREAD_CANCEL_ENABLE</command> iptali etkinleştirir veya <command>PTHREAD_CANCEL_DISABLE</command> iptali etkisiz kılar (iptal istekleri dikkate alınmaz).
   </para><para>
Eğer <varname>eskidurum</varname> <command>NULL</command> değilse, önceki iptal durumu <varname>eskidurum</varname> ile gösterilen yerde saklanır, böylece daha sonra <command>pthread_setcancelstate</command> işlevine yapılacak başka bir çağrıyla geri yüklenebilir.
   </para><para>
Eğer <varname>durum</varname> argümanı <command>PTHREAD_CANCEL_ENABLE</command> veya <command>PTHREAD_CANCEL_DISABLE</command> değilse,
 <command>pthread_setcancelstate</command> başarısız olur ve <command>EINVAL</command> döndürür. Aksi takdirde 0 döndürür.
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>pthread_setcanceltype</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-pthread_setcanceltype">
<funcdef>int <command>pthread_setcanceltype</command></funcdef>
<paramdef>(int  <varname>tür</varname>,
 int *<varname>eskitür</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>pthread_setcanceltype</command> çağıran evre için gelen iptal isteklerine verilen cevap türünü değiştirir: zamanuyumsuz (anında) veya ertelenmiş. <varname>tür</varname> argümanı yeni iptal türüdür: Bunlar ya çağıran evre iptal isteğini alır almaz iptal etmek için <command>PTHREAD_CANCEL_ASYNCHRONOUS</command> ya da
diğer iptal noktasına kadar iptal isteğini bekletmek için <command>PTHREAD_CANCEL_DEFERRED</command>dir.
Eğer <varname>eskitür</varname> <command>NULL</command> değilse, önceki iptal durumu <varname>eskitür</varname> ile gösterilen yerde saklanır, böylece daha sonra <command>pthread_setcanceltype</command> işlevine yapılacak başka bir çağrıyla geri yüklenebilir.
   </para><para>
Eğer <varname>tür</varname> argümanı <command>PTHREAD_CANCEL_DEFERRED</command> veya <command>PTHREAD_CANCEL_ASYNCHRONOUS</command> değilse,
<command>pthread_setcanceltype</command> başarısız olur ve <command>EINVAL</command> döndürür.  Aksi takdirde 0 döndürür.
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>pthread_testcancel</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-pthread_testcancel">
<funcdef>void <command>pthread_testcancel</command></funcdef>
<paramdef>(void)</paramdef>
</funcprototype><funcdescr><para>
<command>pthread_testcancel</command> bekleyen istekleri sınamak ve onları işletmekten başka birşey yapmaz. Amacı uzun kod yığını içerisinde iptal için açık kontroller ortaya koymaktır. Aksi takdirde bu kodlar iptal noktası işlevlerini çağırmazlar.
      </para></funcdescr></funcsynopsis></para>
  </sect1>
  <sect1 xml:id="glibc-Cleanup-Handlers">
   <title>Temizlik İşleyicileri</title>
   <titleabbrev>Bir evre iptal edildiğinde kaynakların serbest bırakılması.</titleabbrev>
   <para>
Temizlik işleyicileri, <command>pthread_exit</command> çağrılarak veya iptal nedeniyle bir evre sonlandığında çağrılan işlevlerdir. Temizlik işleyicileri yığıta benzer bir disiplinde kurulurlar ve kaldırılırlar.
   </para><para>
Temizlik işleyicilerinin amacı bir evrenin tuttuğu kaynakları evre sonlandığı zaman serbest bırakmaktır. Eğer bir evre kilitli bir karşılıklı red nesnesine (mutex)<footnote><para>[Ç.N.] mutex (mutual exclusion'dan kısaltma): Bir karşılıklı red (muteks) nesnesi paylaşımlı özkaynaklara erişimi eşzamanlayan çoklu evreleri mümkün kılar. Bir muteks iki durumda olabilir: kilitli, kilitsiz. Bir muteks bir evre tarafından bir kere kilitlendi mi onu kilitlemeye çalışan diğer evreler engellenir. Kilitli evre muteksi bıraktığında (kilidini kaldırdığında) engellenen bloklardan biri onu kilitler ve işlem böyle sürüp gider.</para></footnote> sahipken çıkarsa veya iptal edilirse, nesne sonsuza kadar kilitli kalır ve diğer evrelerin normal işletilmesini engeller.
Bundan kaçınmanın en iyi yolu, karşılıklı red nesnesini kilitlemeden az önce, nesnenin kilidini kaldıracak bir temizlik işleyicisinin kurulmasıdır. Temizlik işleyicileri <command>malloc</command> ile ayrılmış blokların serbest bırakılmasında veya evre sonlandırıldığında dosya tanımlayıcılarının kapatılmasında da kullanılabilir.
   </para><para>
Burada <varname>mut</varname> kilitliyken evre iptal edilirse, kilidinin kaldırılmasında gerektiği gibi bir <varname>mut</varname> nesnesinin nasıl kilitlenebileceğini görüyoruz.
   </para><para>
<screen>
pthread_cleanup_push(pthread_mutex_unlock, (void *) &amp;mut);
pthread_mutex_lock(&amp;mut);
/* biraz çalış */
pthread_mutex_unlock(&amp;mut);
pthread_cleanup_pop(0);
</screen>
   </para><para>Son iki satır</para><para>
<screen>
pthread_cleanup_pop(1);
</screen></para><para>ile değiştirilebilir.
   </para><para>
Unutmayınız ki yukarıdaki kod sadece ertelenmiş iptal kipinde güvenlidir (bkz. <link linkend="glibc-pthread_setcanceltype"><command>pthread_setcanceltype</command></link>). Zamanuyumsuz iptal kipinde, bir iptal <command>pthread_cleanup_push</command> ve <command>pthread_mutex_lock</command> arasında veya <command>pthread_mutex_unlock</command> ve <command>pthread_cleanup_pop</command> arasında oluşur, evrenin her iki durumunda muteksin kilidini açmayı deneyen geçerli evre tarafından kilitlenmez. Bu zamanuyumsuz iptalin kullanımının neden zor olduğunun ana sebebidir.
   </para><para>
Eğer yukarıdaki kodun zamanuyumsuz iptal kipinde de çalışması gerekiyorsa,
muteksi kilitlemek ve kilidi açmak için ertelenmiş iptal kipine çevrilmelidir:
   </para><para>
<screen>
pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, &amp;oldtype);
pthread_cleanup_push(pthread_mutex_unlock, (void *) &amp;mut);
pthread_mutex_lock(&amp;mut);
/* Birşeyler yap */
pthread_cleanup_pop(1);
pthread_setcanceltype(oldtype, NULL);
</screen>
   </para><para>
Yukarıdaki kod taşınabilir değildir. <command>pthread_cleanup_push_defer_np</command> ve <command>pthread_cleanup_pop_restore_np</command> işlevlerinin kullanılmasıyla daha kısa ve verimli bir şekilde tekrar yazılabilir:
   </para><para>
<screen>
pthread_cleanup_push_defer_np(pthread_mutex_unlock, (void *) &amp;mut);
pthread_mutex_lock(&amp;mut);
/* Birşeyler yap */
pthread_cleanup_pop_restore_np(1);
</screen>
      </para><para>
<indexterm scope="glibc-fn"><primary>pthread_cleanup_push</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-pthread_cleanup_push">
<funcdef>void <command>pthread_cleanup_push</command></funcdef>
<paramdef>(void (*<varname>işlev</varname>) (void *),
 void  *<varname>arg</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>pthread_cleanup_push</command> <varname>işlev</varname> işlevini <varname>arg</varname> argümanıyla bir temizlik işleyicisi olarak yükler. Bu noktadan itibaren <command>pthread_cleanup_pop</command> ile ilişkili <varname>işlev</varname> işlevi, ne zaman evre <command>pthread_exit</command> veya iptal ile sonlansa, <varname>arg</varname> argümanlarıyla çağrılacaktır. Eğer bu noktada çok sayıda temizlik işleyicileri etkinse, LIFO sırasıyla çağrılırlar: en son yüklenen ilk çağrılır.
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>pthread_cleanup_pop</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-pthread_cleanup_pop">
<funcdef>void <command>pthread_cleanup_pop</command></funcdef>
<paramdef>(int <varname>çalıştır</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>pthread_cleanup_pop</command> en son yüklenen temizlik işleyicisini kaldırır. Eğer <varname>çalıştır</varname> argümanı 0 değilse, aynı zamanda <varname>işlev</varname> işlevini <varname>arg</varname> argümanlarıyla çağırarak işleyiciyi de işletir. Eğer <varname>çalıştır</varname> argümanı 0 ise, işleyici sadece kaldırılır, işletilmez.
      </para></funcdescr></funcsynopsis></para><para>
<command>pthread_cleanup_push</command> ve <command>pthread_cleanup_pop</command> işlevlerinin eşleşen çiftleri aynı işlev içinde aynı blok yuvalama seviyesinde gerçekleşmelidir. Aslında, <command>pthread_cleanup_push</command> ve <command>pthread_cleanup_pop</command> birer makrodur,
ve <command>pthread_cleanup_push</command> bir bloğu başlatan kaşlı ayraca <command>{</command>, <command>pthread_cleanup_pop</command> ise bunun kapatan kaşlı ayraca <command>}</command> karşılık gelir.
   </para><para>
<indexterm scope="glibc-fn"><primary>pthread_cleanup_push_defer_np</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-pthread_cleanup_push_defer_np">
<funcdef>void <command>pthread_cleanup_push_defer_np</command></funcdef>
<paramdef>(void (*<varname>işlev</varname>) (void *),
 void  *<varname>arg</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>pthread_cleanup_push_defer_np</command>,  <command>pthread_cleanup_push</command> ile <command>pthread_setcanceltype</command>'ı birleştiren taşınabilir olmayan bir oluşumdur. Sadece <command>pthread_cleanup_push</command>'un yaptığı gibi bir temizlik işleyicisi iter, fakat aynı zamanda geçerli iptal türünü kaydeder ve onu ertelenmiş iptale ayarlar. Bu temizleme mekanizmasının ilk başta zamanuyumsuz iptal kipinde olsa bile verimli olduğunu temin eder.
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>pthread_cleanup_pop_restore_np</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-pthread_cleanup_pop_restore_np">
<funcdef>void <command>pthread_cleanup_pop_restore_np</command></funcdef>
<paramdef>(int <varname>çalıştır</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>pthread_cleanup_pop_restore_np</command>, <command>pthread_cleanup_push_defer_np</command> ile tanıştırılan bir temizlik işleyicisini çeker ve iptal türünü <command>pthread_cleanup_push_defer_np</command> çağrıldığında olan değerine geri yükler.
      </para></funcdescr></funcsynopsis></para><para>
<command>pthread_cleanup_push_defer_np</command> ve <command>pthread_cleanup_pop_restore_np</command> eşleşen çiftlerde aynı blok yuvalama seviyesinde gerçekleşmelidir.
   </para><para>
<screen>
pthread_cleanup_push_defer_np(routine, arg);
...
pthread_cleanup_pop_defer_np(execute);
</screen>
   </para><para>sıralaması</para><para>
<screen>
{
  int oldtype;
  pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, &amp;oldtype);
  pthread_cleanup_push(routine, arg);
  ...
  pthread_cleanup_pop(execute);
  pthread_setcanceltype(oldtype, NULL);
}
</screen>
  ile işlevsel olarak denktir.(fakat daha kısa ve verimlidir)
    </para>
  </sect1>
  <sect1 xml:id="glibc-Mutexes">
   <title>Muteksler</title>
   <titleabbrev>Evreleri eşzamanlamanın tek yolu.</titleabbrev>
   <para>
Bir mutek bir Karşılıklı Dışlama (MUTual EXclusion) aygıtıdır ve paylaşılan veri yapılarını eşzamanlı değişikliklerden korumak için ve kritik bölümler ve görüntüleme birimlerini uygulamak için kullanışlıdır.
   </para><para>
Bir muteksin iki durumu vardır: kilitsiz (herhangi bir evre tarafından sahiplenilmemiş) ve kilitli (bir evre tarafından sahiplenilmiş). Bir muteks hiçbir zaman aynı anda iki farklı evre tarafından sahiplenilemez. Kilitli bir muteksi kilitlemeye teşebbüs eden bir evre sahiplenen evre o muteksin kilidini açana kadar askıya alınır.
   </para><para>
Muteks işlevlerinden hiçbiri bir iptal noktası değildir, hatta bir evreyi belirli aralılarla askıya alabilen <command>pthread_mutex_lock</command> bile. Evre işletilmeyi durdurmadan önce kilidinin açılması gereken muteksleri, iptal işleyicilerinin açmalarını sağlayarak, mutekslerin iptal noktalarındaki durumları önceden tahmin edilebilir. Sonuç olarak, ertelenmiş iptal kullanan evreler hiçbir zaman bir muteksi genişletilmiş zaman aralıklarıyla tutmamalıdırlar.
   </para><para>
Muteks işlevlerini tek bir sinyal işleyiciden çağırmak güvenli değildir. Özellikle, tek bir sinyal işleyiciden <command>pthread_mutex_lock</command> veya <command>pthread_mutex_unlock</command> çağırmak, çağıran evreyi kısır döngüye sokabilir.
   </para><para>
<indexterm scope="glibc-fn"><primary>pthread_mutex_init</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-pthread_mutex_init">
<funcdef>int <command>pthread_mutex_init</command></funcdef>
<paramdef>(pthread_mutex_t            *<varname>muteks</varname>,
 const pthread_mutexattr_t *<varname>muteks_özelliği</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>pthread_mutex_init</command> <varname>muteks_özelliği</varname> ile mutex özellikleri belirtilen <varname>muteks</varname> ile gösterilen muteks nesnesini hazırlar. Eğer <varname>muteks_özelliği</varname>  <command>NULL</command> ise, öntanımlı özellikler kullanılır.
   </para><para>
LinuxThreads gerçeklemesi sadece bir muteks özelliğini desteklemektedir, bu "hızlı", "özyinelemeli" veya "hata denetimli" olan <varname>muteks türü</varname>dür.
Mutex tipi, sahiplenildiği evre tarafından tekrar kilitlenebilirliğini belirler. Varsayılan "hızlı"dır.
   </para><para>
<command>pthread_mutex_t</command> türündeki değişkenler de <command>PTHREAD_MUTEX_INITIALIZER</command> (zamanlı muteksler için), <command>PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP</command> (özyinelemeli muteksler için), <command>PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP</command> (hızlı muteksler için) ve <command>PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP</command> (hata denetimli muteksler için) sabitleri kullanılarak ilk değerleri statik olarak alabilirler.
   </para><para>
<command>pthread_mutex_init</command> daima 0 ile döner.
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>pthread_mutex_lock</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-pthread_mutex_lock">
<funcdef>int <command>pthread_mutex_lock</command></funcdef>
<paramdef>(pthread_mutex_t *<varname>muteks</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>pthread_mutex_lock</command> verilen muteksi kilitler. Muteks kilitli değilse, kilitlenir, çağıran evre tarafından sahiplenilir ve <command>pthread_mutex_lock</command> hemen döner. Eğer muteks zaten başka bir evre tarafından kilitlendiyse, <command>pthread_mutex_lock</command> muteksin kilidi açılana kadar çağıran evreyi askıya alır.
   </para><para>
Eğer muteks çağıran evre tarafından önceden kilitlenmişse, <command>pthread_mutex_lock</command> davranışı muteks türüne bağlıdır. Eğer muteks "hızlı" türdeyse, çağıran evre askıya alınır. Sonsuza kadar askıda kalır, çünkü başka hiçbir evre muteksin kilidini açamaz. Eğer muteks "hata kontrollü" türdeyse, <command>pthread_mutex_lock</command> <command>EDEADLK</command> hata koduyla hemen döner. Mutex "özyinelemeli" türdeyse, <command>pthread_mutex_lock</command> başarılı olur ve çağıran evrenin muteksi kaç kez kilitlediğini kaydederek hemen döner.
Muteksi kilitsiz hale düşürmek için eşit sayıda <command>pthread_mutex_unlock</command> işlemi uygulanmalıdır.
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>pthread_mutex_trylock</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-pthread_mutex_trylock">
<funcdef>int <command>pthread_mutex_trylock</command></funcdef>
<paramdef>(pthread_mutex_t *<varname>muteks</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>pthread_mutex_trylock</command> işlevi <command>pthread_mutex_lock</command> ile aynı davranır, farklı olarak eğer muteks başka bir evre tarafından (veya "hızlı" muteks türünde çağıran evre tarafından) önceden kilitlenmişse, çağıran evreyi askıya almaz. Bunun yerine, <command>pthread_mutex_trylock</command> hemen <command>EBUSY</command> hata koduyla döner.
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>pthread_mutex_timedlock</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-pthread_mutex_timedlock">
<funcdef>int <command>pthread_mutex_timedlock</command></funcdef>
<paramdef>(pthread_mutex_t       *<varname>muteks</varname>,
 const struct timespec *<varname>mutlak_zaman</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>pthread_mutex_timedlock</command> işlevi <command>pthread_mutex_lock</command> işlevi ile aynıdır, fakat muteks başka bir evre tarafından kilitlendiğinde, sonsuza kadar askıya almaktansa <varname>mutlak_zaman</varname> ile belirtilen zamana erişildiğinde döner.
   </para><para>
Bu işlev sadece standart ("zamanlı") ve "hata denetimli" mutekslerde kullanılabilir. Diğer bütün türler için <command>pthread_mutex_lock</command> gibi davranır.
   </para><para>
Eğer muteks başarıyla kilitlendiyse, işlev sıfır döndürür. Eğer muteks kilitlenmeden <varname>mutlak_zaman</varname> süresi dolarsa, <command>ETIMEDOUT</command> döndürülür.
   </para><para>
Bu işlev POSIX standartlarının POSIX.1d uyarlamasıyla tanıtılmıştır.
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>pthread_mutex_unlock</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-pthread_mutex_unlock">
<funcdef>int <command>pthread_mutex_unlock</command></funcdef>
<paramdef>(pthread_mutex_t *<varname>muteks</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>pthread_mutex_unlock</command> verilen muteksin kilidini açar.
<command>pthread_mutex_unlock</command> işlevinin girişinde muteks kilitlenmiş ve çağıran evre tarafından sahiplenilmiş olarak kabul edilir.
Eğer muteks "hızlı" türdeyse, <command>pthread_mutex_unlock</command> kilitsiz durumuna döndürür. Eğer "özyinelemeli" türdeyse, muteksin kilit sayısını azaltır (çağıran evre tarafından uygulanan <command>pthread_mutex_lock</command> işlemi sayısı),
ve ancak bu sayı sıfıra ulaştığında muteks kilidi açılmış olur.
   </para><para>
"Hata denetimli" mutekslerde, <command>pthread_mutex_unlock</command> aslında çalışma-anında muteksin kilitli olup olmadığını girişte kontol eder,
ve o an <command>pthread_mutex_unlock</command> çağıranın kilitleyen evre olup olmadığına bakar. Eğer bu koşullar karşılanmadıysa, <command>pthread_mutex_unlock</command> işlevi <command>EPERM</command> döndürür,
ve muteks değişmez. "Hızlı" ve "özyinelemeli" muteksler bu tür kontroller uygulamazlar,
bu nedenle kilitli bir muteksin sahibinden başka bir evre tarafından kilidinin açılmasına izin verirler. Bu taşınabilir olmayan bir davranıştır ve güvenilemez.
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>pthread_mutex_destroy</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-pthread_mutex_destroy">
<funcdef>int <command>pthread_mutex_destroy</command></funcdef>
<paramdef>(pthread_mutex_t *<varname>muteks</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>pthread_mutex_destroy</command> bir muteks nesnesini, sahip olabileceği kaynakları serbest bırakarak yok eder. Girişte muteksin kilitlenmemiş olması gerekir. LinuxThreads gerçeklemesinde, muteks nesneleriyle hiçbir kaynak ilişkilendirilmemiştir,
bu nedenle <command>pthread_mutex_destroy</command> aslında muteksin kilitli olup olmadığını kontrol etmekten başka bir şey yapmaz.
   </para><para>
Eğer muteks bir evre tarafından kilitlendiyse, <command>pthread_mutex_destroy</command> işlevi <command>EBUSY</command> döndürür. Aksi takdirde 0 döndürür.
      </para></funcdescr></funcsynopsis>
    </para><para>
Eğer yukarıdaki işlevlerden herhangi biri (<command>pthread_mutex_init</command> dışında) hazırlanmamış bir mutekse uygulanırsa, sadece <command>EINVAL</command> döndürürler ve başka birşey yapmazlar.
   </para><para>
Paylaşılan global bir <varname>x</varname> değişkeni bir muteks tarafından aşağıdaki gibi korunabilir:
   </para><para>
<screen>
int x;
pthread_mutex_t mut = PTHREAD_MUTEX_INITIALIZER;
</screen>
   </para><para>
<varname>x</varname>'e yapılan bütün erişim ve değişiklikler <command>pthread_mutex_lock</command> ve <command>pthread_mutex_unlock</command> arasına aşağıdaki gibi alınmalıdır.
   </para><para>
<screen>
pthread_mutex_lock(&amp;mut);
/* x üzerindeki işlemler*/
pthread_mutex_unlock(&amp;mut);
</screen>
   </para><para>
Muteks özellikleri muteksin oluşturulması sırasında <command>pthread_mutex_init</command>'e ikinci parametre olarak muteks özellik nesnesinin aktarılması ile belirtilebilirler. <command>NULL</command> aktarmak, bütün özellikleri öntanımlı değer verilmiş bir muteks özellik nesnesi aktarmakla eşdeğerdir.
   </para><para>
<indexterm scope="glibc-fn"><primary>pthread_mutexattr_init</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-pthread_mutexattr_init">
<funcdef>int <command>pthread_mutexattr_init</command></funcdef>
<paramdef>(pthread_mutexattr_t *<varname>öznitelik</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>pthread_mutexattr_init</command> işlevi <varname>öznitelik</varname> muteks özellik nesnesini hazırlar ve özelliklerini öntanımlı değerlerle doldurur.
   </para><para>
Bu işlev her zaman 0 döndürür.
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>pthread_mutexattr_destroy</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-pthread_mutexattr_destroy">
<funcdef>int <command>pthread_mutexattr_destroy</command></funcdef>
<paramdef>(pthread_mutexattr_t *<varname>öznitelik</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>pthread_mutexattr_destroy</command> bir muteks özellik nesnesini yok eder, bu nesne tekrar hazırlanıncaya kadar tekrar kullanılmamalıdır. <command>pthread_mutexattr_destroy</command> LinuxThreads gerçeklemesinde birşey yapmaz.
   </para><para>
Bu işlev her zaman 0 döndürür.
      </para></funcdescr></funcsynopsis>
    </para><para>
LinuxThreads sadece bir muteks özelliğini destekler: muteks türü.
"hızlı" muteksler için <command>PTHREAD_MUTEX_ADAPTIVE_NP</command>,
"özyinelemeli" muteksler için <command>PTHREAD_MUTEX_RECURSIVE_NP</command>,
"zamanlı" muteksler için <command>PTHREAD_MUTEX_TIMED_NP</command> , veya
"hata denetimli" muteksler için <command>PTHREAD_MUTEX_ERRORCHECK_NP</command> olabilir.
<command>NP</command> ekinin de gösterdiği gibi, POSIX standardının taşınabilir olmayan bir oluşumudur ve taşınabilir yazılımlarda kullanılmamalıdır.
   </para><para>
Muteks türü bir evre zaten sahip olduğu bir muteksi <command>pthread_mutex_lock</command> ile kilitlemeye çalıştığında ne olacağını belirler. Eğer muteks "hızlı" türdeyse, <command>pthread_mutex_lock</command> sadece çağıran evreyi sonsuza kadar askıya alır. Eğer muteks "hata denetimli" türdeyse, <command>pthread_mutex_lock</command> hemen <command>EDEADLK</command> hata koduyla döner. Eğer muteks "özyinelemeli" türdeyse, <command>pthread_mutex_lock</command>'a yapılan çağrı hemen bir başarı dönüş koduyla döner. Evrenin mutekse kaç kez sahip olduğu muteks içinde kayıtlanır. Muteksin kilitsiz duruma dönmesi için, sahip olan evre <command>pthread_mutex_unlock</command> işlevini aynı sayıda çağırmalıdır.
   </para><para>
Varsayılan muteks türü <command>PTHREAD_MUTEX_TIMED_NP</command> olan "zamanlı"dır.
   </para><para>
<indexterm scope="glibc-fn"><primary>pthread_mutexattr_settype</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-pthread_mutexattr_settype">
<funcdef>int <command>pthread_mutexattr_settype</command></funcdef>
<paramdef>(pthread_mutexattr_t *<varname>öznitelik</varname>,
 int                  <varname>tür</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>pthread_mutexattr_settype</command> işlevi <varname>öznitelik</varname> içindeki muteks türü özelliğini <varname>tür</varname> ile belirtilen değere ayarlar.
   </para><para>
Eğer <varname>tür</varname> <command>PTHREAD_MUTEX_ADAPTIVE_NP</command>,
<command>PTHREAD_MUTEX_RECURSIVE_NP</command>, <command>PTHREAD_MUTEX_TIMED_NP</command>, veya
<command>PTHREAD_MUTEX_ERRORCHECK_NP</command> değilse, bu işlev <command>EINVAL</command>  döndürür ve <varname>öznitelik</varname> değerini değiştirmez.
   </para><para>
Standart Unix98 tanıtıcıları olan
<command>PTHREAD_MUTEX_DEFAULT</command>, <command>PTHREAD_MUTEX_NORMAL</command>,
<command>PTHREAD_MUTEX_RECURSIVE</command> ve <command>PTHREAD_MUTEX_ERRORCHECK</command> değerlerine de izin verilmiştir.
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>pthread_mutexattr_gettype</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-pthread_mutexattr_gettype">
<funcdef>int <command>pthread_mutexattr_gettype</command></funcdef>
<paramdef>(const pthread_mutexattr_t *<varname>öznitelik</varname>,
 int                       *<varname>tür</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>pthread_mutexattr_gettype</command> işlevi <varname>öznitelik</varname> içindeki geçerli muteks türü özelliğini alır ve <varname>tür</varname> ile gösterilen yerde saklar.
   </para><para>
Bu işlev her zaman 0 döndürür.
   </para></funcdescr></funcsynopsis></para>
  </sect1>
  <sect1 xml:id="glibc-Condition-Variables">
   <title>Koşul Değişkenleri</title>
   <titleabbrev>Başka bir yol.</titleabbrev>
   <para>
Bir koşul ("koşul değişkeni" yerine), evrelerin işletilmeyi paylaşılan veride bir karara varıncaya kadar askıya almasına olanak veren bir eşzamanlama aracıdır.  Koşullar üzerindeki temel işlemler: koşula sinyal göndermek (Karar doğru çıkınca) ve başka bir evre koşula sinyal gönderene kadar evrenin işletilmesini askıya alarak koşul için beklemek.
   </para><para>
Yarış koşulundan (race condition) kaçınmak için bir koşul değişkeni herzaman bir muteks ile ilişkilendirilmelidir. Öyle ki yarış koşulunda bir evre bir koşul değişkeni için beklemeye hazırlanırken başka bir evre ilk evre tam beklemeye başlayacakken koşula sinyal gönderir.
   </para><para>
<indexterm scope="glibc-fn"><primary>pthread_cond_init</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-pthread_cond_init">
<funcdef>int <command>pthread_cond_init</command></funcdef>
<paramdef>(pthread_cond_t           *<varname>koşul</varname>,
 pthread_condattr_t *<varname>koşul_özelliği</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>pthread_cond_init</command> işlevi <varname>koşul</varname> koşul değişkenini, <varname>koşul_özelliği</varname> içinde belirtilen koşul özelliklerini kullanarak ya da eğer <varname>koşul_özelliği</varname> <command>NULL</command> ise öntanımlı özellikleri kullanarak hazırlar. LinuxThreads gerçeklemesi koşullar için özellikleri desteklemez, bu yüzden <varname>koşul_özelliği</varname> parametresi dikkate alınmaz.
   </para><para>
<command>pthread_cond_t</command> türündeki değişkenler de <command>PTHREAD_COND_INITIALIZER</command> sabitini kullanarak durağan olarak hazırlanabilirler.
   </para><para>
Bu işlev her zaman 0 döndürür.
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>pthread_cond_signal</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-pthread_cond_signal">
<funcdef>int <command>pthread_cond_signal</command></funcdef>
<paramdef>(pthread_cond_t *<varname>koşul</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>pthread_cond_signal</command> işlevi <varname>koşul</varname> koşul değişkeni için bekleyen evrelerden birini yeniden başlatır. Eğer hiçbir evre <varname>koşul</varname> için beklemiyorsa, bir şey olmaz. Eğer <varname>koşul</varname> için birçok evre bekliyorsa, araların biri yeniden başlatılır.
   </para><para>
Bu işlev her zaman 0 döndürür.
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>pthread_cond_broadcast</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-pthread_cond_broadcast">
<funcdef>int <command>pthread_cond_broadcast</command></funcdef>
<paramdef>(pthread_cond_t *<varname>koşul</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>pthread_cond_broadcast</command> işlevi <varname>koşul</varname> koşul değişkeni için bekleyen bütün evreleri yeniden başlatır. <varname>koşul</varname> için bekleyen hiç evre yoksa birşey olmaz.
   </para><para>
Bu işlev her zaman 0 döndürür.
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>pthread_cond_wait</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-pthread_cond_wait">
<funcdef>int <command>pthread_cond_wait</command></funcdef>
<paramdef>(pthread_cond_t  *<varname>koşul</varname>,
 pthread_mutex_t *<varname>muteks</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>pthread_cond_wait</command> işlevi <varname>muteks</varname>'in kilidini atomik olarak açar (<command>pthread_unlock_mutex</command> gibi) ve <varname>koşul</varname> koşul değişkeninin sinyal alması için bekler. Evre işletimi askıya alınır ve koşul değişkeni sinyal alana kadar işlemci zamanı harcamaz.
<command>pthread_cond_wait</command> girişinde, <varname>muteks</varname> çağıran evre tarafından kilitlenmelidir.
Çağıran evreye geri dönmeden önce, <command>pthread_cond_wait</command>  <varname>muteks</varname>'i tekrar elde eder (<command>pthread_lock_mutex</command> gibi).
   </para><para>
Muteks kilidini açmak ve koşul değişkeni üzerine askıya almak atomik olarak gerçekleşir.
Bu nedenle, eğer bütün evreler koşula sinyal göndermeden önce hep muteksi elde etseler,
bu evrenin muteksi kilitlemesiyle koşul değişkeni için bekleyeceği zaman aralığında koşula sinyal gönderilemeyeceğini temin eder.
   </para><para>
Bu işlev her zaman 0 döndürür.
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>pthread_cond_timedwait</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-pthread_cond_timedwait">
<funcdef>int <command>pthread_cond_timedwait</command></funcdef>
<paramdef>(pthread_cond_t        *<varname>koşul</varname>,
 pthread_mutex_t       *<varname>muteks</varname>,
 const struct timespec *<varname>mutlak_zaman</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>pthread_cond_timedwait</command> işlevi <varname>muteks</varname> kilidini atomik olarak açar ve <command>pthread_cond_wait</command>'in yaptığı gibi <varname>koşul</varname> için bekler, fakat aynı zamanda bekleme süresini sınırlar.
Eğer <varname>koşul</varname> <varname>mutlak_zaman</varname> süresinden önce sinyal almadıysa, <varname>muteks</varname> muteksi tekrar elde edilir ve <command>pthread_cond_timedwait</command> <command>ETIMEDOUT</command> hata kodunu döndürür. Bekleme de bir sinyal ile kesilebilir; bu durumda <command>pthread_cond_timedwait</command> işlevi <command>EINTR</command> döndürür.
   </para><para>
<varname>mutlak_zaman</varname> parametresi, <command>time</command> ve <command>gettimeofday</command> ile aynı kökende kesin bir süre belirler:
<varname>mutlak_zaman</varname> için 0 değeri 00:00:00 GMT, January 1, 1970 anlamına gelir.
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>pthread_cond_destroy</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-pthread_cond_destroy">
<funcdef>int <command>pthread_cond_destroy</command></funcdef>
<paramdef>(pthread_cond_t *<varname>koşul</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>pthread_cond_destroy</command> işlevi <varname>koşul</varname> koşul değişkenini sahip olabileceği kaynakları serbest bırakarak yok eder. Eğer herhangi bir evre koşul değişkeni için bekliyorsa, <command>pthread_cond_destroy</command>
<varname>koşul</varname> koşulunu değiştirmeden bırakır ve <command>EBUSY</command> döndürür. Aksi takdirde 0 döndürür ve <varname>koşul</varname> tekrar hazırlanana kadar kullanılmamalıdır.
   </para><para>
LinuxThreads gerçeklemesinde, koşul değişkenleriyle hiçbir kaynak ilişkilendirilmemiştir, bu yüzden <command>pthread_cond_destroy</command> aslında hiçbir şey yapmaz.
   </para></funcdescr></funcsynopsis></para><para>
<command>pthread_cond_wait</command> ve <command>pthread_cond_timedwait</command> iptal noktalarıdır. Eğer bir evre bu işlevlerden biri tarafından askıya alındığında iptal edildiyse, evre çalışmaya geri döner, <varname>muteks</varname> ile belirtilen muteksi tekrar kilitler ve son olarak iptali işletir. Sonuç olarak, temizlik işleyicileri <varname>muteks</varname>'in çağrıldığında kilitli olduğuna emin olurlar.
   </para><para>
Bir sinyal işleyicisinden koşul değişken işlevlerinin çağrılması güvenli değildir. Özellikle, bir sinyal işleyicisinden <command>pthread_cond_signal</command> veya <command>pthread_cond_broadcast</command> çağırmak çağıran evreyi kısır döngüye sokabilir.
   </para><para>
<varname>mut</varname> muteksi tarafından korunan, paylaşılan iki <varname>x</varname> ve <varname>y</varname> değişkeni ve ne zaman <varname>x</varname> <varname>y</varname>'den büyük olsa sinyal alan bir <varname>cond</varname> koşul değişkeni düşünün.
   </para><para>
<screen>
int x,y;
pthread_mutex_t mut = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
</screen>
   </para><para>
<varname>x</varname> <varname>y</varname>'den büyük olana kadar beklemek aşağıdaki gibi yapılır:
   </para><para>
<screen>
pthread_mutex_lock(&amp;mut);
while (x &lt;= y) {
        pthread_cond_wait(&amp;cond, &amp;mut);
}
/* x ve y üzerinde işle*/
pthread_mutex_unlock(&amp;mut);
</screen>
   </para><para>
<varname>x</varname>'in <varname>y</varname>'den büyük olmasına neden olabilecek <varname>x</varname> ve <varname>y</varname> üzerindeki değişiklikler gerektiğinde koşula sinyal göndermeli:
   </para><para>
<screen>
pthread_mutex_lock(&amp;mut);
/*  x ve y'yi değiştir*/
if (x &gt; y) pthread_cond_broadcast(&amp;cond);
pthread_mutex_unlock(&amp;mut);
</screen>
   </para><para>
Eğer en çok bir evrenin uyanması gerektiği kanıtlanabilirse (örneğin, <varname>x</varname> ve <varname>y</varname> üzerinden haberleşen sadece iki evre varsa),
<command>pthread_cond_signal</command> işlevi <command>pthread_cond_broadcast</command>'in daha verimli bir alternatifi olarak kullanılabilir. Şüpheliyseniz <command>pthread_cond_broadcast</command> kullanın.
   </para><para>
<varname>x</varname>'in <varname>y</varname>'den büyük oluncaya kadar 5 saniye beklenmesi için:
   </para><para>
<screen>
struct timeval now;
struct timespec timeout;
int retcode;

pthread_mutex_lock(&amp;mut);
gettimeofday(&amp;now);
timeout.tv_sec = now.tv_sec + 5;
timeout.tv_nsec = now.tv_usec * 1000;
retcode = 0;
while (x &lt;= y &amp;&amp; retcode != ETIMEDOUT) {
        retcode = pthread_cond_timedwait(&amp;cond, &amp;mut, &amp;timeout);
}
if (retcode == ETIMEDOUT) {
        /* zaman aşımı oluştu */
} else {
        /* x ve y üzerinde işlem yap*/
}
pthread_mutex_unlock(&amp;mut);
</screen>
   </para><para>
Koşul özellikleri,<command>pthread_cond_init</command> işlevinin ikinci argümanı olarak koşul özellik nesnesi geçirilerek, koşul oluşturulması esnasında belirtilebilir. <command>NULL</command> geçirmek, bütün özellikleri öntanımlı değer verilmiş bir koşul özellik nesnesi geçirmekle eşdeğerdir.
   </para><para>
LinuxThreads gerçeklemesi koşullar için hiçbir özellik desteklememektedir. Koşul özellikleriyle ilgili işlevler sadece POSIX standardıyla uyum için içerilmektedir.
   </para><para>
<indexterm scope="glibc-fn"><primary>pthread_condattr_init</primary></indexterm>
<indexterm scope="glibc-fn"><primary>pthread_condattr_destroy</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-pthread_condattr_init">
<funcdef>int <command>pthread_condattr_init</command></funcdef>
<paramdef>(pthread_condattr_t *<varname>öznitelik</varname>)</paramdef>
</funcprototype><funcprototype role="işlev" xml:id="glibc-pthread_condattr_destroy">
<funcdef>int <command>pthread_condattr_destroy</command></funcdef>
<paramdef>(pthread_condattr_t *<varname>öznitelik</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>pthread_condattr_init</command> işlevi <varname>öznitelik</varname> koşul özellik nesnesini hazırlar ve özelliklerini öntanımlı değerlerle doldurur. <command>pthread_condattr_destroy</command> işlevi ise <varname>öznitelik</varname> koşul özellik nesnesini yok eder.
   </para><para>
Her iki işlev de LinuxThreads gerçeklemesinde bir şey yapmaz.
   </para><para>
<command>pthread_condattr_init</command> ve <command>pthread_condattr_destroy</command> herzaman 0 döndürr.
      </para></funcdescr></funcsynopsis></para>
  </sect1>
  <sect1 xml:id="glibc-POSIX-Semaphores">
   <title>POSIX Semaforları</title>
   <titleabbrev>Ve bir üçüncü yol.</titleabbrev>
   <para>
<indexterm scope="glibc-vr"><primary>SEM_VALUE_MAX</primary></indexterm>
Semaforlar evreler arasında paylaşılan kaynaklar için sayaçtırlar. Semaforlar üzerindeki temel işlemler: sayacı atomik olarak artırmak ve sayaç sıfırdan farklı oluncaya kadar beklemek ve atomik olarak azaltmak.
   </para><para>
Semaforların azami bir değeri vardır ve bunu geçemezler. <command>SEM_VALUE_MAX</command> makrosu bu azami değer olmak için tanımlanmıştır.

GNU C kütüphanesinde, <command>SEM_VALUE_MAX</command> ile <command>INT_MAX</command> eşittir. (Bkz. <xref linkend="glibc-Range-of-Type"/>), fakat diğer sistemlerde oldukça küçük olabilir.
   </para><para>
POSIX evreleri kütüphanesi POSIX 1003.1b semaforlarını gerçeklemektedir. Bunlar System V semaforlarıyla (<command>ipc</command>, <command>semctl</command> ve <command>semop</command>) karıştırılmamalıdır.
   </para><para>
Bütün semafor işlevleri ve makroları <filename>semaphore.h</filename> içinde tanımlıdır.
   </para><para>
<indexterm scope="glibc-fn"><primary>sem_init</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-sem_init">
<funcdef>int <command>sem_init</command></funcdef>
<paramdef>(sem_t       *<varname>sem</varname>,
 int          <varname>paylaşımlı</varname>,
 unsigned int <varname>değer</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>sem_init</command> <varname>sem</varname> ile gösterilen semafor nesnesini hazırlar. Semafor ile ilişkili sayı ilk değer olarak <varname>değer</varname> alır.
<varname>paylaşımlı</varname> argümanı semaforun geçerli sürece yerel (sıfır ise) veya süreçler arasında paylaşımlı (sıfırdan farklı ise) olduğunu belirtir.
   </para><para>
Başarı halinde <command>sem_init</command> 0 döndürür. Başarısızlık halinde -1 döndürür ve <varname>errno</varname> değerini aşağıdakilerden biri yapar:
   </para><para>
   <variablelist><varlistentry>
     <term><literal>EINVAL</literal></term>
     <listitem><para><varname>değer</varname> azami sayaç değeri <command>SEM_VALUE_MAX</command> değerini aşmaktadır.
     </para></listitem></varlistentry><varlistentry>
     <term><literal>ENOSYS</literal></term>
     <listitem><para><varname>paylaşımlı</varname> sıfır değildir. LinuxThreads henüz süreç-paylaşımlı semaforları desteklememektedir.
         (Bu aslında değişecek.)
     </para></listitem></varlistentry></variablelist>
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>sem_destroy</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-sem_destroy">
<funcdef>int <command>sem_destroy</command></funcdef>
<paramdef>(sem_t * <varname>sem</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>sem_destroy</command> semafor nesnesini sahip olabileceği kaynakları serbest bırakarak yok eder. Eğer herhangi bir evre <command>sem_destroy</command> çağrıldığında semaforda bekliyorsa, başarısız olur ve <varname>errno</varname> değerini <command>EBUSY</command> yapar.
   </para><para>
LinuxThreads gerçeklemesinde, semafor nesneleriyle hiçbir kaynak ilişkilendirilmemiştir, bu nedenle <command>sem_destroy</command> aslında semaforda hiçbir evrenin beklemekte olmadığını sınamaktan başka birşey yapmaz. Bu süreç-paylaşımlı semaforlar gerçeklendiğinde değişecektir.
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>sem_wait</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-sem_wait">
<funcdef>int <command>sem_wait</command></funcdef>
<paramdef>(sem_t * <varname>sem</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>sem_wait</command> <varname>sem</varname> ile gösterilen semafor sıfır olmayan sayıya sahip oluncaya kadar çağıran evreyi askıya alır. Ardından atomik olarak semafor sayısını bir azaltır.
   </para><para>
<command>sem_wait</command> bir iptal noktasıdır. Herzaman 0 döndürür.
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>sem_trywait</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-sem_trywait">
<funcdef>int <command>sem_trywait</command></funcdef>
<paramdef>(sem_t * <varname>sem</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>sem_trywait</command> işlevi <command>sem_wait</command>'in durdurmayan bir türevidir. Eğer <varname>sem</varname> ile gösterilen semafor sıfırdan farklı bir sayıya sahipse, sayı atomik olarak azaltılır ve <command>sem_trywait</command> hemen 0 döndürür. Eğer semafor sayısı sıfırsa, <command>sem_trywait</command> hemen -1 döndürür ve hata kodunu <command>EAGAIN</command> yapar.
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>sem_post</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-sem_post">
<funcdef>int <command>sem_post</command></funcdef>
<paramdef>(sem_t * <varname>sem</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>sem_post</command> işlevi <varname>sem</varname> ile gösterilen semafor sayısını atomik olarak artırır. Bu işlev hiçbir zaman durdurmaz.
   </para><para>
Atomik karşılaştırma-ve-değiştirme destekleyen işlemcilerde (Intel 486, Pentium ve sonrası, Alpha, PowerPC, MIPS II, Motorola 68k, Ultrasparc), <command>sem_post</command> işlevi sinyal işleyicilerden güvenle çağrılabilir. Bu POSIX evreleri tarafından desteklenen zamanuyumsuz-sinyal güvenli tek evre eşzamanlama işlevidir. Intel 386 ve eski Sparc kıymıklarında, <command>sem_post</command>'un geçerli LinuxThreads gerçeklemesi zamanuyumsuz-sinyal güvenli değildir, çünkü donanım gerekli olan atomik işlemleri desteklememektedir.
   </para><para>
<command>sem_post</command> semafor sayısı artırıldıktan sonra <command>SEM_VALUE_MAX</command> aşılmadığı sürece hep başarılı olur ve 0 döndürür. Bu durumda <command>sem_post</command> -1 döndürür ve <varname>errno</varname> hata kodunu <command>EINVAL</command> yapar. Semafor sayısı değiştirilmeden bırakılır.
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>sem_getvalue</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-sem_getvalue">
<funcdef>int <command>sem_getvalue</command></funcdef>
<paramdef>(sem_t * <varname>sem</varname>,
 int   * <varname>semdeg</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>sem_getvalue</command> işlevi <varname>sem</varname> semaforunun geçerli sayısını <varname>semdeg</varname> ile gösterilen yerde saklar. Hep 0 döndürür.
      </para></funcdescr></funcsynopsis></para>
  </sect1>
  <sect1 xml:id="glibc-Thread-Specific-Data">
   <title>Evreye Özgü Veri</title>
   <titleabbrev>Farklı evrelerde farklı değerlerle değişkenler.</titleabbrev>
   <para>
Yazılımlarda farklı evrelerde farklı değerlere sahip olan global veya statik değişkenlere sıklıkla ihtiyaç duyulur. Evreler bir bellek alanını paylaştıkları için, bu sıradan değişkenlerle başarılamamaktadır. Evreye özgü veri bu ihtiyaca POSIX evrelerinin cevabıdır.
   </para><para>
Her evre bir özel bellek bloğunu, evreye özgü veri alanını veya kısaca EÖV alanını zapteder. Bu alan EÖV anahtarlarıyla indekslenir. EÖV alanı <command>void *</command> türündeki değerleri EÖV anahtarlarıyla ilişkilendirir. EÖV anahtarları bütün evreler için ortaktır, fakat verilen bir EÖV anahtarına ilişkin değer her evre içinde farklı olabilir.
   </para><para>
Somut olarak belirtmek gerekirse, EÖV alanları <command>void *</command> göstericilerden oluşan diziler olarak gösterilebilirler, EÖV anahtarları bu diziler için birer tamsayı indisi ve EÖV anahtarının değeri de çağıran evre içindeki ilişkili dizi elemanının değeridir.
   </para><para>
Bir evre oluşturulduğunda, onun EÖV alanı ilk başta bütün anahtarlarıyla <command>NULL</command> değerini ilişkilendirir.
   </para><para>
<indexterm scope="glibc-fn"><primary>pthread_key_create</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-pthread_key_create">
<funcdef>int <command>pthread_key_create</command></funcdef>
<paramdef>((pthread_key_t *<varname>anahtar</varname>,
 void         (*<varname>yıkıcı_işlev</varname>) (void *))</paramdef>
</funcprototype><funcdescr><para>
<command>pthread_key_create</command> yeni bir EÖV anahtarı ayırır. Anahtar <varname>anahtar</varname> ile gösterilen yerde saklanır. Belirli bir süre içinde ayrılabilecek anahtar sayısı <command>PTHREAD_KEYS_MAX</command> ile sınırlandırılmıştır. Döndürülen anahtarla ilişkilendirilmiş değer ilk başta <command>NULL</command>dur.
   </para><para>
<varname>yıkıcı_işlev</varname> argümanı, eğer <command>NULL</command> değilse anahtarla ilişkili bir yıkıcı işlev belirtir. Bir evre <command>pthread_exit</command> ile veya iptal edilerek sonlandığında, evre içindeki anahtarla ilişkili değer üzerine <varname>yıkıcı_işlev</varname>  işlevi çağrılır. Eğer anahtar <command>pthread_key_delete</command> ile silindiyse veya bir değer <command>pthread_setspecific</command> ile değiştirildiyse <varname>yıkıcı_işlev</varname> çağrılmaz. Yıkıcı işlevin evre sonlandırılma esnasındaki çağrılma sırası belirtilmemiştir.
   </para><para>
Yıkıcı işlev çağrılmadan önce, <command>NULL</command> değeri geçerli evre içindeki anahtar ile ilişkilendirilir. Bir yıkıcı işlev <command>NULL</command> olmayan değerleri bu veya başka bir anahtarla tekrar ilişkilendirebilir. Bununla ilgilenmek için, eğer bütün <command>NULL</command> olmayan değerler için bütün yıkıcılar çağrıldıktan sonra, hala <command>NULL</command> olmayan yıkıcılarla ilişkilendirilmiş bazı değerler varsa, süreç tekrarlanır. LinuxThreads gerçeklemesi <command>PTHREAD_DESTRUCTOR_ITERATIONS</command> tekrarlamadan sonra, <command>NULL</command> olmayan tanımlayıcılarla ilişkilendirilmiş değer kalsa bile, süreci durdurur. Diğer uygulamalar sonsuza kadar tekrarlayabilir.
   </para><para>
<command>pthread_key_create</command> 0 döndürür, ancak <command>PTHREAD_KEYS_MAX</command> anahtar zaten ayrılmışsa başarısız olur ve <command>EAGAIN</command> döndürür.
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>pthread_key_delete</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-pthread_key_delete">
<funcdef>int <command>pthread_key_delete</command></funcdef>
<paramdef>(pthread_key_t <varname>anahtar</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>pthread_key_delete</command> bir EÖV anahtarını serbest bırakır. Geçerli süreçteki anahtarla <command>NULL</command> olmayan değerler ilişkilendirilmiş mi kontrol etmediği gibi, anahtarla ilişkili yıkıcı işlevi de çağırmaz.
   </para><para>
Eğer <varname>anahtar</varname> diye bir anahtar yoksa, <command>EINVAL</command> döndürür. Aksi takdirde 0 döndürür.
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>pthread_setspecific</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-pthread_setspecific">
<funcdef>int <command>pthread_setspecific</command></funcdef>
<paramdef>(pthread_key_t <varname>anahtar</varname>,
 const void   *<varname>gösterici</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>pthread_setspecific</command> çağıran süreçteki <varname>anahtar</varname> ile ilişkili değeri verilen <varname>gösterici</varname> değeri ile değiştirir.
   </para><para>
Eğer <varname>anahtar</varname> diye bir anahtar yoksa, <command>EINVAL</command> döndürür. Aksi takdirde 0 döndürür.
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>pthread_getspecific</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-pthread_getspecific">
<funcdef>void *<command>pthread_getspecific</command></funcdef>
<paramdef>(pthread_key_t <varname>anahtar</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>pthread_getspecific</command>  çağıran süreçteki <varname>anahtar</varname> ile ilişkili geçerli değeri döndürür.
   </para><para>
Eğer <varname>anahtar</varname> diye bir anahtar yoksa, <command>EINVAL</command> döndürür. Aksi takdirde 0 döndürür.
   </para></funcdescr></funcsynopsis>
   </para><para>
Aşağıdaki kod parçası 100 karakterlik bir evreye özgü dizi ayırır. Evre çıkışında da otomatik geri alır:
   </para><para>
<screen>
/* Evreye özgü tampon için anahtar */
static pthread_key_t buffer_key;

/* Anahtar bir kerelik hazırlanıyor */
static pthread_once_t buffer_key_once = PTHREAD_ONCE_INIT;

/* Evreye özgü tampon ayrılıyor */
void buffer_alloc(void)
{
  pthread_once(&amp;buffer_key_once, buffer_key_alloc);
  pthread_setspecific(buffer_key, malloc(100));
}

/* Evreye özgü tampon döndürülüyor */
char * get_buffer(void)
{
  return (char *) pthread_getspecific(buffer_key);
}

/* Anahtarı ayır */
static void buffer_key_alloc()
{
  pthread_key_create(&amp;buffer_key, buffer_destroy);
}

/* Evreye özgü tamponu serbest bırak */
static void buffer_destroy(void * buf)
{
  free(buf);
}
</screen>
     </para>
  </sect1>
  <sect1 xml:id="glibc-Threads-and-Signal-Handling">
   <title>Evreler ve Sinyal İşleme</title>
   <titleabbrev>İkisini karıştırmaktan neden kaçınmalısınız ve ihtiyacınız olduğunda nasıl kaçınırsınız.</titleabbrev>
   <para>
<indexterm scope="glibc-fn"><primary>pthread_sigmask</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-pthread_sigmask">
<funcdef>int <command>pthread_sigmask</command></funcdef>
<paramdef>(int             <varname>nasıl</varname>,
 const sigset_t *<varname>yenimaske</varname>,
 sigset_t       *<varname>eskimaske</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>pthread_sigmask</command> çağıran süreç için sinyal maskesini <varname>nasıl</varname> ve <varname>yenimaske</varname> argümanlarıyla belirtildiği şekilde değiştirir. Eğer <varname>eskimaske</varname> <command>NULL</command> değilse, önceki sinyal maskesi <varname>eskimaske</varname> ile gösterilen yerde saklanır.
   </para><para>
<varname>nasıl</varname> ve <varname>yenimaske</varname> argümanlarının anlamı <command>sigprocmask</command> ile aynıdır. Eğer <varname>nasıl</varname> <command>SIG_SETMASK</command> ise, sinyal maskesi <varname>yenimaske</varname> yapılır. Eğer <varname>nasıl</varname> <command>SIG_BLOCK</command> ise, <varname>yenimaske</varname> için belirtilen sinyaller geçerli sinyal maskesine eklenir. Eğer <varname>nasıl</varname> <command>SIG_UNBLOCK</command> ise, <varname>yenimaske</varname> için belirtilen sinyaller geçerli sinyal maskesinden kaldırılır.
   </para><para>
Sinyal maskeleri her evre başına ayarlanır, fakat sinyal hareketleri ve sinyal işleyicileri <command>sigaction</command> ile ayarlanır ve bütün evrelerce paylaşılır.
   </para><para>
<command>pthread_sigmask</command> işlevi başarı halinde 0 döndürür, hata halinde de aşağıdaki hata kodlarından birini döndürür:
   </para><para>
   <variablelist><varlistentry>
     <term><literal>EINVAL</literal></term>
     <listitem><para><varname>nasıl</varname> <command>SIG_SETMASK</command>, <command>SIG_BLOCK</command> veya <command>SIG_UNBLOCK</command> değerlerinden biri değildir.
     </para></listitem></varlistentry><varlistentry>
     <term><literal>EFAULT</literal></term>
     <listitem><para><varname>yenimaske</varname> veya <varname>eskimaske</varname> geçersiz bir adresi göstermektedir.
     </para></listitem></varlistentry></variablelist>
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>pthread_kill</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-pthread_kill">
<funcdef>int <command>pthread_kill</command></funcdef>
<paramdef>(pthread_t <varname>evre</varname>,
 int       <varname>sinyalnum</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>pthread_kill</command>  <varname>sinyalnum</varname> sinyal numarasını  <varname>evre</varname> evresine gönderir.  Sinyal <xref linkend="glibc-Signal-Handling"/> içinde anlatıldığı gibi teslim edilir ve işlenir.
   </para><para>
<command>pthread_kill</command> başarı halinde 0 , hata halinde aşağıdaki hata kodlarından birini döndürür:
   </para><para>
   <variablelist><varlistentry>
     <term><literal>EINVAL</literal></term>
     <listitem><para><varname>sinyalnum</varname> geçerli bir sinyal numarası değildir.
     </para></listitem></varlistentry><varlistentry>
     <term><literal>ESRCH</literal></term>
     <listitem><para><varname>evre</varname> evresi mevcut değildir (örn. sonlandırılmış olabilir)
     </para></listitem></varlistentry></variablelist>
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>sigwait</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-sigwait">
<funcdef>int <command>sigwait</command></funcdef>
<paramdef>(const sigset_t *<varname>küme</varname>,
 int            *<varname>sinyal</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>sigwait</command> <varname>küme</varname> içindeki sinyallerden biri çağıran evreye ulaştırılıncaya kadar çağıran evreyi askıya alır. Ardından, alınan sinyal numarasını <varname>sinyal</varname> ile gösterilen yerde saklar ve döner. <varname>küme</varname> içindeki sinyaller durdurulmalıdır ve <command>sigwait</command> girişinde dikkate alınmalıdırlar. Eğer ulaştırılan sinyal yanında sinyal işleyici işlevine sahipse, bu işlev çağrılmaz.
   </para><para>
<command>sigwait</command> bir iptal noktasıdır. Her zaman 0 döndürür.
   </para></funcdescr></funcsynopsis>
   </para><para>
<command>sigwait</command>'in güvenilir çalışması için, beklenen sinyaller sadece çağıran evrede değil bütün evrelerde durdurulmalıdır, aksi takdirde sinyal ulaştırmanın POSIX mantığı, sinyali alacak olan <command>sigwait</command>'in o evre olduğunu garanti etmez. Bunu başarmanın en iyi yolu, herhangi bir evre oluşturulmadan önce bu sinyalleri durdurmak ve onları yazılım içinde  <command>sigwait</command> çağırmak haricinde serbest bırakmamaktır.
   </para><para>
LinuxThreads'deki sinyal işleme POSIX standardındakiyle oldukça farklıdır. Standarda göre, "zamanuyumsuz" (dış) sinyaller bütün sürece (evrelerin toplamına) adreslenirler, ardından süreç bunları belirli bir evreye teslim eder. Sinyali alan evre sinyali o anda durdurmayan evrelerden herhangi biridir.
   </para><para>
LinuxThreads'de, her evre aslında kendi süreç kimliği ile bir çekirdek sürecidir, bu nedenle dış sinyaller her zaman belirli bir evreye yönlendirilirler. Eğer, örneğin, başka bir evre o sinyalde <command>sigwait</command> içinde durdurulduysa, yeniden başlatılmaz.
   </para><para>
<command>sigwait</command>'in LinuxThreads gerçeklemesi <varname>küme</varname> içindeki sinyaller için bekleme süresince kukla sinyal işleyicileri kurar. Sinyal işleyicileri bütün evrelerce paylaşıldığı için, diğer evreler bu sinyallere kendi sinyal işleyicilerini eklememeli veya bir seçenek olarak bütün hepsi sinyalleri durdurmalıdırlar (bu daima önerilmektedir).
   </para>
  </sect1>
  <sect1 xml:id="glibc-Threads-and-Fork">
   <title>Evreler ve Çatallaşmak</title>
   <titleabbrev>Evrelerle <command>fork</command> işlevi arasındaki etkileşim.</titleabbrev>
   <para>
Bir çok evreli POSIX süreci <command>fork</command> işlevinin çağırdığında ne olması gerektiği kesin değildir. Çatallaşma sırasında doğru çalışan ancak <command>fork</command> işlevini kullanmayan kodlar yazmanız gerekebilir.
<command>fork</command> ve <command>pthread_once</command> gibi bazı kütüphane oluşumları ile standart G/Ç akımları arasındaki etkileşime dikkat etmelisiniz.
   </para><para>
<command>fork</command> süreçteki bir evre tarafından çağrıldığında, çağıran sürecin bir kopyası olan yeni bir süreç oluşturur. Belirli sistem nesnelerinin kopyalanmasına ek olarak, üst sürecin bellek alanlarının anlık görünümünü alır ve alt süreçte özdeş alanlar oluşturur. Olayı biraz daha karmaşıklaştırmak için, iki veya daha fazla evre kendi içlerinde de çatallaşarak iki veya daha fazla alt süreç oluşturabilirler.
   </para><para>
Alt süreç üst sürecinin adres alanının bir kopyasına sahiptir, fakat evrelerinden hiçbirini miras almaz. Alt sürecin işletilmesi <command>fork</command> işlevinden 0 değeriyle dönen bir evre ile sağlanır; öyle ki bu alt süreçteki tek evredir. Çatallaşma sırasında evreler miras alınmadığı için bazı sorunlar ortaya çıkar. <command>fork</command>'un çağrılması sırasında, üst süreçteki <command>fork</command>'u çağıran evre dışındaki evreler kodun kritik bölgelerini işletiyor olabilirler. Sonuç olarak, alt süreç iyi tanımlanmış durumda olmayan nesnelerin kopyasını alabilir. Bu potansiyel sorun yazılımın bütün bileşenlerini etkiler.
   </para><para>
Alt süreçte kullanılmaya devam edecek herhangi bir yazılım bileşeni  <command>fork</command> süresince durumunu doğru bir şekilde ele almalıdır.  Bu amaçla, POSIX arayüzü özel bir işlev olan <command>pthread_atfork</command>'u, <command>fork</command> içinden çağrılan işleyici işlevlere göstericiler kurmak için sağlar.
   </para><para>
<indexterm scope="glibc-fn"><primary>pthread_atfork</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-pthread_atfork">
<funcdef>int <command>pthread_atfork</command></funcdef>
<paramdef>(void (*<varname>hazırla</varname>)(void),
 void (*<varname>üstsüreç</varname>)(void),
 void (*<varname>altsüreç</varname>)(void))</paramdef>
</funcprototype><funcdescr><para>
<command>pthread_atfork</command> işlevi <command>fork</command> ile yeni bir süreç oluşturmadan hemen önce ve oluşturulduktan hemen sonra çağrılan işleyici işlevleri kaydeder. <varname>hazırla</varname> işleyicisi yeni bir süreç oluşturulmadan önce üst süreçten çağrılacaktır. <varname>üstsüreç</varname> işleyicisi <command>fork</command> dönmeden az önce üst süreçten çağrılacaktır.
<varname>altsüreç</varname> işleyicisi <command>fork</command> dönmeden az önce alt süreçten çağrılacaktır.
   </para><para>
<command>pthread_atfork</command> başarı halinde 0, hata halinde sıfırdan farklı bir hata kodu döndürür.
   </para><para>
<varname>hazırla</varname>, <varname>üstsüreç</varname> ve <varname>altsüreç</varname> işleyicilerinden bir veya daha fazlası <command>NULL</command> olarak verilebilirler,
bu o noktada bir işleyiciye ihtiyaç olmadığı anlamına gelir.
   </para><para>
<command>pthread_atfork</command> birçok işleyici kümesi kurmak için birçok kez çağrılabilir.  <command>fork</command>  anında, <varname>üstsüreç</varname> ve <varname>altsüreç</varname> işleyicileri FIFO sırasıyla çağrılırken (ilk eklenen, ilk çağrılır), <varname>hazırla</varname> işleyicileri LIFO sırasında çağrılırlar (<command>pthread_atfork</command> ile son eklenen, <command>fork</command>'tan önce ilk çağrılır).
   </para><para>
Eğer bu işleyicileri kaydetmek için yeterli bellek mevcut değilse, <command>pthread_atfork</command> başarısız olur ve <command>ENOMEM</command> döndürür. Aksi takdirde 0 döndürür.
   </para><para>
<command>fork</command> ve <command>pthread_atfork</command> işlevlerine işleyiciler bağlamında çok katılışlı işlev gözüyle bakılmamalıdır.
Eğer <command>fork</command> içinden çağrılan <command>pthread_atfork</command> işleyicisi <command>pthread_atfork</command> veya <command>fork</command> çağırırsa, davranışı bilinemez.
   </para><para>
Çatallaşmada üçlü işleyicilerin kaydı atomik bir işlemdir. Eğer çatallaşma ile aynı zamanda yeni işleyiciler kaydedildiyse ya her üç işleyici de çağrılacaktır ya da hiçbiri.
   </para><para>
İşleyiciler alt süreçler tarafından miras alınır ve <command>exec</command> ile yeni bir süreç görüntüsü yüklemekten başka onları kaldırmanın hiçbir yolu yoktur.
   </para></funcdescr></funcsynopsis></para><para>
<command>pthread_atfork</command>'un amacını anlamak için, <command>fork</command>'un geçerli kilit durumlarıyla muteksler dahil bütün bellek alanının kopyasını çıkardığını hatırlayınız, fakat sadece çağıran evreyi: diğer evreler alt süreçte çalışmıyordu.  <command>fork</command>'tan sonra muteksler kullanılamaz ve alt süreçte <command>pthread_mutex_init</command> ile tekrar hazırlanmaları gerekir. Bu geçerli gerçeklemenin bir kısıtıdır ve gelecek sürümlerde olabilir de olmayabilir de.
   </para><para>
Bundan kaçınmak için, <command>pthread_atfork</command> ile şu şekilde işleyiciler kurun:
<varname>hazırla</varname> işleyicisi muteksleri kilitler (sırayla) ve <varname>üstsüreç</varname> işleyicisi muteks kilitlerini açar.
<varname>altsüreç</varname> işleyicisi muteksleri ve koşul değişkenleri gibi diğer eşzamanlama nesnelerini <command>pthread_mutex_init</command> kullanarak sıfırlamalıdır.
   </para><para>
Çatallaşmadan önce global mutekslerin kilitlenmesi, bu mutekslerce korunan diğer bütün evrelerin kodun kritik bölgesindeki kilitlerinden kurtulduğundan emin olunmasını sağlar.
Bu nedenle ne zaman <command>fork</command> üst sürecin adres alanının anlık görüntüsünü alsa, o görüntü geçerli, tutarlı veri içerir. Alt süreçteki eşzamanlama nesnelerinin sıfırlanması, üst sürecin evrelenme alt sistemindeki yapıların temizlendiğini temin eder. Örneğin, bir muteks, kilit için bekleyen bir evre bekleme sırası miras almıştır; bu bekleme sırası alt süreçte bir şey ifade etmez. Muteksin ilklendirilmesi buna dikkat ister.
  </para></sect1>
  <sect1 xml:id="glibc-Streams-and-Fork">
   <title>Akımlar ve Çatallaşma</title>
   <titleabbrev><command>fork</command> ile standart G/Ç akımları arasındaki etkileşim.</titleabbrev>
   <para>
GNU standart G/Ç kütüphanesi, bütün standart C FILE nesnelerinin içteki bağlı listesini koruyan bir iç mutekse sahiptir.  <command>fork</command> sırasında bu mutekse dikkat edilerek, alt süreç listenin sağlam bir kopyasını alabilir. Bu <command>fopen</command> işlevi ve ilgili akım oluşturma işlevlerinin alt süreçte doğru çalışmasına imkan verir, çünkü bu işlevler listeye ekleme ihtiyacı duyarlar.
   </para><para>
Tek tek akım kilitleri tam olarak dikkate alınmazlar. Bu yüzden çok evreli uygulamalarda <command>fork</command> kullanımında  özel önlemler alınmadığı sürece, alt süreç üst süreçten miras aldığı akımları güvenle kullanma imkanı bulamayabilirler. Genellikle, üst süreçte verilen ve alt süreçte kullanılacak herhangi bir akım için, uygulamada <command>fork</command> çağrıldığında akımın başka bir evre tarafından kullanılmamasının temin edilmesi gerekir. Aksi takdirde akım nesnesinin tutarsız bir kopyası üretilmiş olur. Bunu garantilemenin kolay yolu <command>fork</command> çağırmadan önce <command>flockfile</command>'ı akımı kilitlemek için kullanmak ve
üst süreçte <command>funlockfile</command> ile kilidini açmaktır. Alt süreçte başka özel birşey yapılmasına gerek yoktur, çünkü kütüphane içte bütün akım kilitlerini sıfırlamaktadır.
   </para><para>
Unutmayınız ki akım kilitleri üst ve alt süreçler arasında paylaşılmazlar. Örneğin,
<command>stdout</command> akımının uygun bir şekilde ele alındığını ve alt süreçte güvenle kullanılabileceğini temin etseniz de akım kilitleri üst ve alt süreçler arasında bir dışlama yöntemi sağlamazlar. Eğer her iki süreç  <command>stdout</command>'a yazıyorsa, <command>flockfile</command> veya örtük kilitler uygulanmazsa karmakarışık bir çıktı ortaya çıkabilir.
   </para><para>
Ayrıca bu hazırlıklar bir GNU uzantısıdır; diğer sistemler bir çok-evreli sürecin alt sürecinde kullanılacak akımlar için bunları sağlayamayabilirler. POSIX sadece standart G/Ç dahil kütüphanenin büyük kısmını dışlayan zamanuyumsuz güvenli işlevleri kullanarak kendini sınırlayan böyle bir alt sürece ihtiyaç duyar.
   </para></sect1>
  <sect1 xml:id="glibc-Miscellaneous-Thread-Functions">
   <title>Çeşitli Evre İşlevleri</title>
   <titleabbrev>Bir dizi yardımcı yordam.</titleabbrev>
   <para>
<indexterm scope="glibc-fn"><primary>pthread_self</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-pthread_self">
<funcdef>pthread_t <command>pthread_self</command></funcdef>
<paramdef>(void)</paramdef>
</funcprototype><funcdescr><para>
<command>pthread_self</command> çağıran süreç için evre tanıtıcısını döndürür.
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>pthread_equal</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-pthread_equal">
<funcdef>int <command>pthread_equal</command></funcdef>
<paramdef>(pthread_t <varname>evre1</varname>,
 pthread_t <varname>evre2</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>pthread_equal</command> iki evre tanıtıcısının aynı evreye belirtip belirtmediğini saptar.
   </para><para>
Eğer <varname>evre1</varname> ve <varname>evre2</varname> aynı evreyi belirtiyorsa sıfırdan farklı bir değer döndürülür. Aksi takdirde 0 döndürülür.
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>pthread_detach</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-pthread_detach">
<funcdef>int <command>pthread_detach</command></funcdef>
<paramdef>(pthread_t <varname>evre</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>pthread_detach</command> işlevi <varname>evre</varname> evresini ayrık duruma koyar. Bu, <varname>evre</varname> tarafından harcanan bellek kaynaklarının <varname>evre</varname> sonlandığında hemen serbest bırakılacağını garantiler. Ancak, bu diğer evrelerin <varname>evre</varname>'nin sonlanmasında <command>pthread_join</command> kullanarak eşzamanlanmalarını engeller.
   </para><para>
Bir evre <command>detachstate</command> özelliği <command>pthread_create</command> işlevine verilerek ilk başta ayrık oluşturulabilir. Buna karşın <command>pthread_detach</command> evrelerin birleşimci durumda oluşturulmalarını sağlar ve daha sonra ayrık duruma konulması gerekir.
   </para><para>
<command>pthread_detach</command> tamamlandıktan sonra <varname>evre</varname> üzerinde <command>pthread_join</command> uygulama teşebbüsleri başarısız olur.
Eğer <command>pthread_detach</command> çağrıldığında diğer bir evre <varname>evre</varname> evresiyle birleşiyorsa, <command>pthread_detach</command> birşey yapmaz ve <varname>evre</varname>'yi birleşimci durumda bırakır.
   </para><para>
Başarı halinde 0 döndürülür. Hata halinde, aşağıdaki hata kodlarından biri döndürülür:
   </para><para>
   <variablelist><varlistentry>
     <term><literal>ESRCH</literal></term>
     <listitem><para>
Belirtilen <varname>evre</varname> evresi bulunamadı
     </para></listitem></varlistentry><varlistentry>
     <term><literal>EINVAL</literal></term>
     <listitem><para>
<varname>evre</varname> evresi zaten ayrık durumda
      </para></listitem></varlistentry></variablelist>
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>pthread_kill_other_threads_np</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-pthread_kill_other_threads_np">
<funcdef>void <command>pthread_kill_other_threads_np</command></funcdef>
<paramdef>(void)</paramdef>
</funcprototype><funcdescr><para>
<command>pthread_kill_other_threads_np</command> taşınabilir olmayan bir LinuxThreads oluşumudur. Yazılım içindeki çağıran evre hariç bütün evrelerin hemen sonlanmasına neden olur. Bir evre <command>exec</command> işlevlerinden birini, örneğin <command>execve</command> çağırmadan az önce çağrılmak üzere tasarlanmıştır.
   </para><para>
Diğer evrelerin sonlandırılması <command>pthread_cancel</command> ile yapılmaz ve iptal mekanizması tamamen atlanır. Bu yüzden geçerli iptal durumu ve iptal türü ayarları dikkate alınmaz ve temizlik işleyicileri sonlandırılan evrelerde işletilmez.
   </para><para>
POSIX 1003.1c'ye göre, evrelerden birindeki başarılı bir <command>exec*</command> yazılımdaki diğer bütün evreleri otomatik olarak sonlandırmalıdır. Bu davranış henüz LinuxThreads içinde uygulanmamıştır. <command>pthread_kill_other_threads_np</command>'in <command>exec*</command>'den önce çağrılması neredeyse aynı davranışı gösterir, tabii ki eğer <command>exec*</command> sonunda başarısız olmadıysa, o zaman zaten diğer bütün evreler sonlandırılmıştır.
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>pthread_once</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-pthread_once">
<funcdef>int <command>pthread_once</command></funcdef>
<paramdef>(pthread_once_t *<varname>birkerelik</varname>,
 void          (*<varname>ilklendirme_yordamı</varname>) (void))</paramdef>
</funcprototype><funcdescr><para>
<command>pthread_once</command>'ın amacı ilklendirme kodunun en çok bir kere işletilmesini temin etmektir.  <varname>birkerelik</varname> argümanı <command>PTHREAD_ONCE_INIT</command> ile durağan olarak ilklendirilmiş
bir statik ya da extern değişkeni gösterir.
   </para><para>
<varname>birkerelik</varname> argümanıyla <command>pthread_once</command> ilk çağrıldığında, <varname>ilklendirme_yordamı</varname> yordamını argümansız çağırır ve <varname>once_control</varname> değişkeninin değerini ilklendirmenin yapıldığını belirtmek için değiştirir. <command>pthread_once</command>'a aynı <command>birkerelik</command> argümanıyla yapılacak tekrarlanan çağrılar birşey yapmazlar.
   </para><para>
Eğer bir evre <varname>ilklendirme_yordamı</varname> işletilirken iptal edilirse <varname>birkerelik</varname> değişkeninin durumu sıfırlanır, böylece <command>pthread_once</command>'a yapılacak sonraki çağrılar yordamı tekrar çağıracaktır.
   </para><para>
Eğer bir veya daha fazla evre, süreç tarafından <command>pthread_once</command> ilklendirme yordamlarını işletirken çatallaşırsa, kendi <varname>birkerelik</varname> değişkenlerinin durumları alt süreçte sıfırlanmış olarak görünürler, böylece
eğer alt süreç  <command>pthread_once</command> çağırırsa, yordamlar işletilir.
   </para><para>
<command>pthread_once</command> hep 0 döndürür.
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>pthread_setschedparam</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-pthread_setschedparam">
<funcdef>int <command>pthread_setschedparam</command></funcdef>
<paramdef>(pthread_t                 <varname>hedef_evre</varname>,
 int                       <varname>ilke</varname>,
 const struct sched_param *<varname>param</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>pthread_setschedparam</command> işlevi <varname>hedef_evre</varname> için <varname>ilke</varname> ve <varname>param</varname> ile belirtildiği gibi zamanlama parametrelerini ayarlar. <varname>ilke</varname>,
<command>SCHED_OTHER</command> (düzenli, gerçek zamanlı olmayan zamanlama),
<command>SCHED_RR</command> (gerçek zamanlı, döner turnuva) veya
<command>SCHED_FIFO</command> (gerçek zamanlı, ilk giren ilk çıkar) olabilir.
<varname>param</varname> gerçek zamanlı ilkeler için zamanlama önceliğini belirtir.
Zamanlama ilkeleri hakkında daha fazla bilgi için bkz. <xref linkend="glibc-Priority"/>
   </para><para>
Gerçek zamanlı zamanlama ilkeleri <command>SCHED_RR</command> ve <command>SCHED_FIFO</command> sadece süper kullanıcı haklarına sahip süreçler için kullanılabilir.
   </para><para>
Başarı halinde, <command>pthread_setschedparam</command> 0 döndürür. Hata halinde aşağıdaki hata kodlarından birini döndürür:
   </para><para>
   <variablelist><varlistentry>
     <term><literal>EINVAL</literal></term>
     <listitem><para><varname>ilke</varname> <command>SCHED_OTHER</command>, <command>SCHED_RR</command>, <command>SCHED_FIFO</command>'dan biri değil veya <varname>param</varname> ile belirtilen öncelik değeri belirtilen ilkeye göre geçerli değil
     </para></listitem></varlistentry><varlistentry>
     <term><literal>EPERM</literal></term>
     <listitem><para>
Gerçek zamanlı zamanlama istendi ancak çağıran süreç yeterli izinlere sahip değil
     </para></listitem></varlistentry><varlistentry>
     <term><literal>ESRCH</literal></term>
     <listitem><para>
<varname>hedef_evre</varname> geçersiz veya sonlandırılmış
     </para></listitem></varlistentry><varlistentry>
     <term><literal>EFAULT</literal></term>
     <listitem><para><varname>param</varname> süreç belleği dışında bir yeri gösteriyor
     </para></listitem></varlistentry></variablelist>
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>pthread_getschedparam</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-pthread_getschedparam">
<funcdef>int <command>pthread_getschedparam</command></funcdef>
<paramdef>(pthread_t           <varname>hedef_evre</varname>,
 int                *<varname>ilke</varname>,
 struct sched_param *<varname>param</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>pthread_getschedparam</command>
<varname>hedef_evre</varname> evresi için zamanlama ilkesini ve parametrelerini elde eder,
<varname>ilke</varname> ve <varname>param</varname> ile gösterilen yerlerde saklar.
   </para><para>
<command>pthread_getschedparam</command> başarı halinde 0 döndürür, hata halinde aşağıdaki hata kodlarından birini döndürür:
   </para><para>
   <variablelist><varlistentry>
     <term><literal>ESRCH</literal></term>
     <listitem><para><varname>hedef_evre</varname> geçersiz veya sonlandırılmış
     </para></listitem></varlistentry><varlistentry>
     <term><literal>EFAULT</literal></term>
     <listitem><para><varname>ilke</varname> veya <varname>param</varname> süreç bellek alanı dışında bir yeri gösteriyor
     </para></listitem></varlistentry></variablelist>
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>pthread_setconcurrency</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-pthread_setconcurrency">
<funcdef>int <command>pthread_setconcurrency</command></funcdef>
<paramdef>(int <varname>seviye</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>pthread_setconcurrency</command> kullanıcı evrelerinin çekirdek evrelerine eşleştirme konusundaki eksiklerden dolayı LinuxThreads'de kullanılmaz.
Kaynak uyumluluğu için bulunmaktadır. <varname>seviye</varname> değerini saklar, böylece sonraki <command>pthread_getconcurrency</command> çağrılarında döndürülebilir.
Başka bir hareket yapmaz.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>pthread_getconcurrency</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-pthread_getconcurrency">
<funcdef>int <command>pthread_getconcurrency</command></funcdef>
<paramdef>()</paramdef>
</funcprototype><funcdescr><para>
<command>pthread_getconcurrency</command> kullanıcı evrelerinin çekirdek evrelerine eşleştirme konusundaki eksiklerden dolayı LinuxThreads'de kullanılmaz. Kaynak uyumluluğu için bulunmaktadır.  Ancak, <command>pthread_setconcurrency</command>'e yapılan son çağrıda belirlenen değeri döndürür.
      </para></funcdescr></funcsynopsis></para>
    </sect1>
  </chapter>
</part>
