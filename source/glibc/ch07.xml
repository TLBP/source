<?xml version="1.0" encoding="UTF-8"?>

<!-- ********************************************************************
     $Id: ch07.xml,v 1.2 2002/12/20 22:29:48 nilgun Exp $
******************************************************************** -->
<part xml:id="glibc-Locales">
  <title>Yereller ve Uluslararasılaştırma</title>
  <titleabbrev>Ülke ve dil kütüphane işlevlerinin davranışlarını etkileyebilir.</titleabbrev>
  <partintro><para>
Farklı ülkeler ve kültürlerin kendi içlerinde iletişim kurma konusunda farklı uzlaşımları vardır. Bu uzlaşımlar tarih ve zaman gösterimleri gibi basit uzlaşımlardan konuşulan dil gibi karmaşık uzlaşımlara kadar değişiklik gösterir.
  </para><para>
<indexterm scope="glibc-cp"><primary>uluslararasılaştırma</primary></indexterm>
<indexterm scope="glibc-cp"><primary>yereller</primary></indexterm>
Yazılımın <firstterm>uluslararasılaştırma</firstterm>sı denince yazılımın kullanıcının tercih ettiği uzlaşımlara uyarlanması anlaşılır. ISO C'de, uluslararasılaştırma yerini <firstterm>yereller</firstterm>e bırakır. Her yerel her bir uzlaşımın başka bir amaca yönelik olduğu bir uzlaşımlar bütünüdür. Kullanıcı uzlaşım kümesini bir yerel belirterek (ortam değişkenleri üzerinden) seçer.
  </para><para>
Bütün yazılımlar seçili yereli kendi ortamlarının bir parçası olarak miras alırlar. Bu yazılımlar yerel seçimine riayet edecek şekilde yazıldıklarında kullanıcı tarafından tercih edilen uzlaşımlara uyacaklardır.
  </para></partintro>
  <chapter xml:id="glibc-Effects-of-Locale">
  <title>Yerelin Etkisi</title>
  <titleabbrev>Yerel seçiminden etkilenen eylemler.</titleabbrev>
  <para>
Her yerel çeşitli amaçlara yönelik uzlaşımlar içerir:
   </para><para><itemizedlist><listitem>
Geçerli çokbaytlı karakter dizilimleri ve bunların yorumlanması (<xref linkend="glibc-Character-Set-Handling"/>).
     </listitem><listitem>
Yerel karakter kümesindeki karakterlerin sınıflandırılması; alfabetik, büyük ve küçük harfler ile bunlar arasındaki dönüşümlerle ilgili uzlaşımlar (<xref linkend="glibc-Character-Handling"/>).
     </listitem><listitem>
Yerel dil ve karakter kümesi için karşılaştırma dizilimi (<xref linkend="glibc-Collation-Functions"/>).
     </listitem><listitem>
Sayıların ve parasal büyüklüklerin biçimlenmesi (<xref linkend="glibc-General-Numeric"/>).
     </listitem><listitem>
Tarih ve zamanın biçimlenmesi (<xref linkend="glibc-Formatting-Calendar-Time"/>).
     </listitem><listitem>
Çıktı ve hata iletileri için kullanılacak dil (<xref linkend="glibc-Message-Translation"/>).
     </listitem><listitem>
Evet/Hayır yanıtları verilecek sorularda kullanılacak dil (<xref linkend="glibc-Yes-or-No-Questions"/>).
     </listitem><listitem>
Daha karmaşık kullanıcı girdilerinde kullanılacak dil (C kütüphanesi bunun gerçekleştirilmesinde şimdilik size yardımcı olamaz).
     </listitem></itemizedlist></para><para>
Belirtilen yerele uyarlanma ile ilgili bazı şeyler kütüphane yordamlarınca kendiliğinden gerçekleştirilir. Örneğin, yazılımınızda metin karşılaştırmalarının seçili yerele göre yapılması gerekliyse dizgeleri karşılaştırmak için <command>strcoll</command> veya <command>strxfrm</command> işlevi kullanılmalıdır.
   </para><para>
Bazı şeyler de kütüphanenin kapsamı dışında bırakılmıştır. Örneğin, kütüphane, yazılımınızın çıktıladığı iletileri kendiliğinden çeviremez. Bunu yapmanın tek yolu çıktının kullanıcının diline çevrilmesinin az ya da çok elle yapılmasıdır. C kütüphanesi farklı dillerdeki çevirilerin çıktıya uygulanabilmesini kolaylaştıran işlevlere sahiptir.
   </para><para>
Bu kısımda kullanımdaki yerelin değiştirilebilmesi için kullanılan mekanizmalardan bahsedilecektir. Yerelin bazı kütüphane işlevlerine etkilerine yeri geldikçe bu işlevlerin açıklamalarında ayrıntılı olarak yer verilmiştir.
   </para></chapter><chapter xml:id="glibc-Choosing-Locale">
   <title>Yerelin Seçimi</title>
   <titleabbrev>Kullanıcı bir yereli nasıl belirtir.</titleabbrev>
   <para>
Kullanıcının yerel seçimini belirtmesinin en basit yolu <command>LANG</command> ortam değişkeninde bunu belirtmesidir. Bu değişken tüm amaçlar için tek bir yerel belirtir. Örneğin, kullanıcı İspanya'nın çoğunluğunun standart uzlaşımlarını kapsayan <command>espana-castellano</command> isimli bir varsayımsal yereli belirtebilirdi.
   </para><para>
Desteklenen yereller kullandığınız işletim sistemine bağlıdır ve bu sistemdeki isimlerle seçim yapılır. Biz bir tek  <command>C</command> veya <command>POSIX</command> olarak adlandırılan standart yerel dışında hangi yerellerin bulunacağına ilişkin herhangi bir taahhüde giremeyiz. Yerellerin nasıl oluşturulacağına daha sonra değineceğiz.
   </para><para>
<indexterm scope="glibc-cp"><primary>yerellerin birleştirilmesi</primary></indexterm>
Ayrıca, bir kullanıcı farklı amaçlar için farklı yereller belirtebilme (çok sayıda yerelin bir karışımı olarak) seçeneğine de sahiptir.
   </para><para>
Örneğin, kullanıcı İspanya'da çalışan, para birimi olarak dolar kullanan ve İspanyolca konuşan bir Amerikalı olabilirdi. Bu kullanıcı paraların biçimlenmesi için <command>usa-english</command> yerelini diğer tüm amaçlar için <command>espana-castellano</command> yerelini belirtebilirdi.
   </para><para>
<command>espana-castellano</command> ve <command>usa-english</command> yerellerinin her ikisi de tüm yereller gibi her amaca uygun uzlaşımları içerir. Bu bakımdan, kullanıcı kendi amaçlarına uygun olan yerelleri karışık olarak seçebilir.
   </para></chapter><chapter xml:id="glibc-Locale-Categories">
   <title>Yerellerin Etkilediği Eylemlerin Sınıflandırılması</title>
   <titleabbrev>Bir yereli seçme amaçları.</titleabbrev>
   <para>
<indexterm scope="glibc-cp"><primary>yerel kategorileri</primary></indexterm>
Yereller, kullanım amaçlarına göre <wordasword>kategoriler</wordasword> halinde gruplanmıştır. Böylece kullanıcı veya yazılım yereli bu kategorilere bağlı olarak seçebilir. Aşağıda bu kategoriler listelenmiştir. Her kategori ismi kullanıcının bir değer atayabileceği bir ortam değişkeni ismi ve <command>setlocale</command> işlevinde bir makro ismi olarak kullanılabilir.
   </para><para><variablelist><varlistentry>
   <term><literal>LC_COLLATE</literal></term><listitem><para>
Bu kategori dizgelerin karşılaştırılmasında kullanılan uzlaşımları içerir. <command>strcoll</command> ve <command>strxfrm</command> işlevleri bu amaçla kullanılır; bkz. <xref linkend="glibc-Collation-Functions"/>.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>LC_CTYPE</literal></term><listitem><para>
Bu kategori çokbaytlı ve geniş karakterlerin sınıflandırılması ve dönüşümleri ile ilgili uzlaşımları içerir; bkz. <xref linkend="glibc-Character-Handling"/> ve <xref linkend="glibc-Character-Set-Handling"/>.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>LC_MONETARY</literal></term><listitem><para>
Bu kategori parasal gösterimlerin biçimlenmesi ile ilgili uzlaşımı içerir; bkz. <xref linkend="glibc-General-Numeric"/>.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>LC_NUMERIC</literal></term><listitem><para>
Bu kategori parasal değil, sayısal gösterimlerin biçimlenmesi ile ilgili uzlaşımı içerir; bkz. <xref linkend="glibc-General-Numeric"/>.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>LC_TIME</literal></term><listitem><para>
Bu kategori tarih ve zaman gösterimlerin biçimlenmesi ile ilgili uzlaşımı içerir; bkz. <xref linkend="glibc-Formatting-Calendar-Time"/>.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>LC_MESSAGES</literal></term><listitem><para>
Bu kategori kullanıcı arayüzünü oluşturan iletilerin çevirilerine ve düzenli ifadelere uygulanacak dilin seçimi için kullanılır. Bkz. <xref linkend="glibc-The-Uniforum-approach"/> ve <xref linkend="glibc-Message-catalogs-a-la-X-Open"/>
      </para></listitem></varlistentry><varlistentry>
      <term><literal>LC_ALL</literal></term><listitem><para>
Bu bir ortam değişkeni değildir; sadece <command>setlocale</command> işlevinde tüm uzlaşımlar için tek bir yerelin belirtilmesi amacıyla kullanılabilen bir makrodur. Bu makroya atanan değer, tüm <command>LC_*</command> ortam değişkenleri ile <command>LANG</command> ortam değişkenine atanmış olur.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>LANG</literal></term><listitem><para>
Bu ortam değişkeni tanımlıysa, yukarıda belirtilen ortam değişkenleri ile sonradan değiştirilmedikçe tüm uzlaşımlar için kullanılacak yereli belirtir.
      </para></listitem></varlistentry></variablelist>
      </para><para>
<indexterm scope="glibc-vr"><primary>LANGUAGE</primary></indexterm>
İleti çevirileri ile ilgili işlevler geliştirilirken yukarıdaki değişkenlerce sağlanan işlevselliğin yetersizliği hissedildi. Örneğin, birden fazla yerel ismi belirtilebilmeliydi. İngilizce’yi Almanca’dan daha iyi konuşan bir İsviçreli ve yazılımların öntanımlı olarak iletileri İngilizce çıktıladığını varsayalım. İleti çıktılama dili olarak, ilk seçim İsviçrece, ikinci Almanca, bunların başarısızlığı halinde İngilizce belirtilebilmesi mümkün olmalıydı. Bu <command>LANGUAGE</command> değişkeni ile mümkündür. Bu GNU oluşumu ile ilgili daha fazla bilgi edinmek için <xref linkend="glibc-Using-gettextized-software"/> bölümüne bakınız.
   </para></chapter><chapter xml:id="glibc-Setting-the-Locale">
   <title>Yazılımlarda Yerelin Belirtilmesi</title>
   <titleabbrev>Bir yazılım kütüphane işlevlerinde kullanılacak yereli nasıl belirtir.</titleabbrev>
   <para>
Bir C yazılımı yerele ilişkin ortam değişkenlerini başlatıldığında miras alır. Bu işlem kendiliğinden gerçekleşir. Ancak bu değişkenler işlevlerde kullanılan yereli belirtmezler. Çünkü ISO C tüm yazılımların öntanımlı olarak standart <command>C</command> yereli ile başlatılması gerektiğinden bahseder. Ortam tarafından belirtilen yerelleri kullanmak için şöyle bir <command>setlocale</command> çağrısı yapmanız gerekir:
   </para><para>
<screen>setlocale (LC_ALL, &quot;&quot;);
</screen></para><para>
Bu çağrı ilgili ortam değişkenleri ile kullanıcı tarafından belirtilen uzlaşımların kütüphane tarafından gözönüne alınmasını sağlar.
   </para><para>
<indexterm scope="glibc-cp"><primary>yereller</primary><secondary>değiştirilmesi</secondary></indexterm>
<command>setlocale</command> işlevini belli bir kategoriyi ya da genel amaçlı olarak belli bir yereli belirtmek için de kullanabilirsiniz.
   </para><para>
<indexterm scope="glibc-pg"><primary>locale.h</primary></indexterm>
Bu bölümde bahsedilen tüm semboller <filename>locale.h</filename> başlık dosyasında tanımlanmıştır.
   </para><para xml:id="glibc-setlocale">
<indexterm scope="glibc-fn"><primary>setlocale</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>char *<command>setlocale</command></funcdef>
<paramdef>(int         <varname>kategori</varname>,
 const char *<varname>yerel</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>setlocale</command> işlevi yerel <varname>kategori</varname> katgorisini  <varname>yerel</varname> yereline ayarlar.  Sistem tarafından desteklenen tüm yerellerin listesini kabukta
<indexterm scope="glibc-pg"><primary>locale</primary></indexterm>
   </para><para>
<screen>  locale -a</screen></para><para>
komutunu vererek alabilirsiniz.</para><para>
<varname>kategori</varname> için <command>LC_ALL</command> belirtilmişse,  tüm uzlaşımlar için tek bir yerelin belirtilmesini sağlar. Diğer  <varname>kategori</varname>  değerleri tek bir amaca uygun uzlaşımı belirtir  (bkz. <xref linkend="glibc-Locale-Categories"/>).
   </para><para>
Bu işlevi ayrıca, <varname>yerel</varname> argümanında boş gösterici aktararak belirtilen kategoriye atanmış değeri öğrenmek için de kullanabilirsiniz. Bu durumda <command>setlocale</command> işlevi, <varname>kategori</varname> kategorisi için seçilmiş olan yerel ismini içeren bir dizge döndürür.
   </para><para>
<command>setlocale</command> işlevi ile döndürülen bu dizge işlevin sonraki çağrıları ile değiştirilen yerel kategorisinin bu ilk duruma getirilmesinde kullanmak üzere saklanabilir (<xref linkend="glibc-Copying-and-Concatenation"/>). (Kütüphanede kendiliğinden bir <command>setlocale</command> çağrısının asla yapılmayacağı garanti edilmiştir.)
   </para><para>
<command>setlocale</command> ile döndürülen dizgede değişiklik yapmamalısınız. İlk duruma getirmek için yapacağınız çağrıda kullanacağınız dizge işlev tarafından döndürülen dizgenin aynısı olmak zorundadır. Ayrıca bu işlemi yaparken yerel dizgesinin alındığı kategoriye atanmasına da dikkat etmelisiniz.
   </para><para>
Bu sorguyu <command>LC_ALL</command> kategorisi için yaparsanız, dönen değer, tüm kategoriler için seçilmiş yerellerin birleşimi olacaktır. Bu durumda dönen değer tek bir yerel ismi içermeyebilir. Aslında değerin nasıl görüneceği ile ilgili bir varsayım yapmadık. Ancak işlevin sonraki çağrısında <command>LC_ALL</command> makrosu için aynı değeri aktarırsanız, aynı yerel birleşimi elde edilecektir.
   </para><para>
Dönen dizgenin sonradan kullanmak istediğinizde aynı kodlamada kalmasını istiyorsanız dizgenin bir kopyasını saklamalısınız. Dönen göstericinin daima geçerli kalacağı garanti edilmemiştir.
   </para><para>
<varname>yerel</varname> argümanı bir boş gösterici değilse, <command>setlocale</command> tarafından döndürülen dizge kategoriye atanan yeni yerele ilişkin dizge olacaktır.
   </para><para>
<varname>yerel</varname> argümanında bir boş dizge belirtirseniz, ilgili ortam değişkeni okunacak ve değeri belirtilen <varname>kategori</varname> kategoroisine atanacaktır.
   </para><para>
<varname>yerel</varname> argümanına boş olmayan bir dizge belirtirseniz, mümkünse bu ismin yereli kullanılacaktır.
   </para><para>
Geçersiz bir yerel ismi belirtirseniz, işlev bir boş gösterici döndürür ve o anki yereli değiştirmez.
</para></funcdescr></funcsynopsis></para><para>
Bu örnekte <command>setlocale</command> işlevinin başka bir yereli geçici olarak etkin kılmak için kullanılması gösterilmiştir:
   </para><para>
<screen>
#include &lt;stddef.h>
#include &lt;locale.h>
#include &lt;stdlib.h>
#include &lt;string.h>

void
with_other_locale (char *new_locale,
                    void (*subroutine) (int),
                    int argument)
{
  char *old_locale, *saved_locale;

  /* O anki yerelin ismini alalım.  */
  old_locale = setlocale (LC_ALL, NULL);

  /* setlocale çağrılarıyla bozulmadan önce ismi kopyalayalım. */
  saved_locale = strdup (old_locale);
  if (saved_locale == NULL)
    fatal ("Bellek yetersiz");

  /* Şimdi yereli değiştirelim ve onunla ilgili işlemleri yapalım. */
  setlocale (LC_ALL, new_locale);
  (*subroutine) (argument);

  /* Yereli eski değerine getirelim. */
  setlocale (LC_ALL, saved_locale);
  free (saved_locale);
}</screen>
   </para><para>
   <note><title>Taşınabilirlik Bilgisi</title>
   <para>Bazı C sistemleri ek yerel kategorileri tanımlayabilir; kütüphanenin ileri sürümlerinde bu yapılabilir. Dolayısıyla <command>LC_</command> ile başlayan bu ek sembollerin <filename>locale.h</filename> başlık dosyasında tanımlanabileceği varsayılmalıdır.</para></note>
   </para></chapter><chapter xml:id="glibc-Standard-Locales">
   <title>Standart Yereller</title>
   <titleabbrev>Tüm sistemlerde kullanılabilen yerel isimleri.</titleabbrev>
   <para>
Tüm işletim sistemlerinde bulabileceğiniz standart yerel isimleri sadece üç tanedir:
   </para><para><variablelist><varlistentry>
   <term><literal>&quot;C&quot;</literal></term><listitem><para>
Bu standart C yerelidir. Öznitelikleri ve davranışları ISO C standardı ile belirlenmiştir. Yazılımınız çalıştırıldığında, kendi içinde öntanımlı olarak bu yereli kullanır.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>&quot;POSIX&quot;</literal></term><listitem><para>
Bu standart POSIX yerelidir.  Şimdilik standart C yereli için bir takma addır.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>&quot;&quot;</literal></term><listitem><para>
Boş isim yerel seçiminin ortam değişkenlerine bakarak yapılacağını belirtir. Bkz. <xref linkend="glibc-Locale-Categories"/>.
      </para></listitem></varlistentry></variablelist></para><para>
İsimli yerellerin tanımlanması ve kurulması normalde sistem yöneticisinin (veya GNU C kütüphanesini kuran kişinin) işidir. Bundan başka her kullanıcının kendine özgü yerellerini belirtmesi de mümkündür. Tüm bunlar araçları tanıtırken daha sonra açıklanacaktır.
   </para><para>
Yazılımınız <command>C</command> yerelinden farklı birşeylere ihtiyaç duyarsa, standart olabileceği tartışmalı bir isim yerine, taşınabilirlik açısından kullanıcının ortam değişkenleri ile belirttiği yerelin kullanılması daha iyidir. Farklı makinelerin aynı yerel için farklı yerel isimleri içerebileceğini aklınızdan çıkarmayın.
   </para></chapter><chapter xml:id="glibc-Locale-Information">
   <title>Yerel Bilgisine Erişim</title>
   <titleabbrev>Yerelle ilgili bilgilere nasıl erişilir.</titleabbrev>
   <para>
Yerel bilgisine erişmenin çeşitli yolları vardır. En basiti C kütüphanesinin kendisinden istemektir. Bu kütüphanedeki çeşitli işlevlerle yerel bilgisine doğrudan erişilebilir ve o an seçili olan yerelle sağlanan bilgiler kullanılabilir. Burada yerel modelinin normalde nasıl anlamlandırıldığından bahsedilecektir.
   </para><para>
Bir örnek olarak tarih ve zaman gösterimlerini biçimlendiren (<xref linkend="glibc-Formatting-Calendar-Time"/>) <command>strftime</command> işlevini ele alalım. <command>LC_TIME</command> kategorisinin standart içeriğinin bir kısmı ay isimlerinden oluşur. Yazılımcı her ay ismi için çevrilmek üzere bir ay isimleri listesi yapmak yerine bu işi zaten yapan <command>strftime</command> işlevini kullanabilir. Biçim dizgesindeki <command>%A</command>,  <command>LC_TIME</command> tarafından seçilen yerele özgü gün ismi ile değiştirilir. Bu basit bir örnekti, bu tür işleri yapan başka işlevlerde benzer bir yöntem kullanır.
   </para><para>
Fakat çoğunlukla, bir görevi kendiliğinden yerine getirecek bir işlev bulunmaz. Bu durmlarda yerel bilgisine doğrudan erişebilmek önem kazanır. Bunun için C kütüphanesi iki işlev içerir: <command>localeconv</command> ve <command>nl_langinfo</command>.  İlki ISO C standardının bir parçasıdır ve taşınabilirdir, ancak kafa karıştırıcı bir arayüzü vardır. İkincisi ise Unix arayüzünün bir parçasıdır ve Unix standardına uyumlu sistemlerde taşınabilirdir.
   </para><sect1 xml:id="glibc-The-Lame-Way-to-Locale-Data">
   <title><literal>localeconv</literal>: Taşınabilirdir ama …</title>
   <titleabbrev>Yerel verisine giden toprak yol:  ISO C'nin <command>localeconv</command> işlevi.</titleabbrev><para>
ISO C topluluğu <command>localeconv</command> işlevini <command>setlocale</command> işlevi ile birlikte anar. <command>localeconv</command> işlevi, biçare tasarımın ana parçasıdır. Genişletilebilir olmaması ve <command>LC_MONETARY</command> ve <command>LC_NUMERIC</command> kategorileri ile ilgili bilgileri sağlamanın dışında bir bilginin gerekmediği durumlarda kullanımı tercih edilir. Buna rağmen, çok taşınabilir olduğundan sadece bu durumda özellikle kullanılmalıdır. <command>strfmon</command> işlevi seçili yerele göre bu bilgiyi parasal gösterimleri biçimlemekte kullanılır.
<indexterm scope="glibc-pg"><primary>locale.h</primary></indexterm>
<indexterm scope="glibc-cp"><primary>parasal değerlerin biçimlenmesi</primary></indexterm>
<indexterm scope="glibc-cp"><primary>sayısal değerlerin biçimlenmesi</primary></indexterm>
   </para><para xml:id="glibc-struct-localeconv">
<indexterm scope="glibc-fn"><primary>localeconv</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>struct lconv *<command>localeconv</command></funcdef>
<paramdef>(void)</paramdef>
</funcprototype><funcdescr><para>
<command>localeconv</command> işlevi sayısal ve parasal değerlerin o anki yerele göre biçimlenmesi için gereken bilgiyi içeren elemanlardan oluşan bir yapının göstericisi ile döner.
    </para><para>
Yapıda ve yapının içeriğinde değişiklik yapmamalısınız. Yapı <command>localeconv</command> veya <command>setlocale</command> işlevlerinin sonraki çağrıları ile tekrar düzeltilir. Fakat bunlar dışında kütüphanede bu yapıyı düzelten başka işlev yoktur.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-struct-lconv">
<indexterm scope="glibc-tp"><primary sortas="lconv">struct lconv</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü">
<funcdef>struct <command>lconv</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu, <command>localeconv</command> işlevinin dönüş değerinin türüdür.  Elemanları bundan sonraki alt bölümlerde açıklanmıştır.
       </para><para>
<command>struct lconv</command> yapısının <command>char</command> türünde bir elemanı varsa ve değeri <command>CHAR_MAX</command> ise, bu, yerelin bu parametre ile ilgili bir değer içermediği anlamına gelir.
    </para></funcdescr></funcsynopsis></para>
    <sect2 xml:id="glibc-General-Numeric">
    <title>Soysal Sayısal Biçimleme Parametreleri</title>
    <titleabbrev>Sayıları ve para miktarlarını biçimleyen parametreler.</titleabbrev><para>
Bunlar <command>struct lconv</command> yapısının standart elemanlarıdır; başkaları da olabilir:
     </para><para><glosslist><glossentry><glossterm>
     <literal>char *</literal><command>decimal_point</command>
     </glossterm></glossentry><glossentry><glossterm>
     <literal>char *</literal><command>mon_decimal_point</command>
     </glossterm><glossdef><para>
Bunlar sayısal ve parasal gösterimler için ondalık ayraçlardır. <command>C</command> yerelinde <command>decimal_point</command> değeri <command>&quot;.&quot;</command> iken <command>mon_decimal_point</command> değeri <command>&quot;&quot;</command>'dir.
<indexterm scope="glibc-cp"><primary>ondalık ayraç</primary></indexterm>
     </para></glossdef></glossentry><glossentry><glossterm>
     <literal>char *</literal><command>thousands_sep</command>
     </glossterm></glossentry><glossentry><glossterm>
     <literal>char *</literal><command>mon_thousands_sep</command>
     </glossterm><glossdef><para>
Bunlar sayısal ve parasal gösterimlerde ondalık ayracın solundaki sayının genellikle binlik gruplara ayrılmasında kullanılan ayraçlardır. <command>C</command> yerelinde her iki üyeninde değeri <command>&quot;&quot;</command>’dir (boş dizge).
     </para></glossdef></glossentry><glossentry><glossterm>
     <literal>char *</literal><command>grouping</command>
     </glossterm></glossentry><glossentry><glossterm>
     <literal>char *</literal><command>mon_grouping</command>
     </glossterm><glossdef><para>
Bunlar sayısal ve parasal gösterimlerde ondalık ayracın solundaki sayının kaç rakamlık gruplara ayrılacağını belirtmekte kullanılır. <command>grouping</command> sayısal, <command>mon_grouping</command> ise parasal gösterimlere uygulanır.
<indexterm scope="glibc-cp"><primary>rakamların gruplanması</primary></indexterm>
     </para><para>
Bu dizgelerin içindeki ayrı ayrı <command>char</command> türünde tanımlanabilecek her sayı <command>char</command> türünde bir tamsayı olarak yorumlanır. Dizgenin içindeki her sayı (soldan sağa) grupların (ondalık ayraçtan itibaren sağdan sola) rakam sayısını verir. Son sayı <command>0</command> ise kalan gruplar önceki sayıya göre gruplanır; <command>CHAR_MAX</command> ise kalan sayıya gruplama uygulanmaz, başka bir deyişle kalan sayı ayraçsız olabildiğince geniş bir grup olur.
        </para><para>
Örneğin, <command>grouping</command> için <command>&quot;\04\03\02&quot;</command> değeri belirtilmişse, <command>123456787654321</command> sayısı <command>12</command>, <command>34</command>, <command>56</command>, <command>78</command>, <command>765</command>, <command>4321</command> şeklinde gruplanır.  Yani sondaki 4'lü bir grup, ondan önceki 3'lü bir grup, ondan öncekiler de 2'li gruplar halinde ayrılır. Gruplama ayracı olarak <command>,</command> belirilmişse sayı <command>12,34,56,78,765,4321</command> olarak basılır.
        </para><para>
<command>&quot;\03&quot;</command> değeri tekrarlanan 3'lü gruplarla gruplama yapılacağını belirtir. Normalde ABD'de böyle bir gruplama kullanılır.
        </para><para>
Standart <command>C</command> yerelinde <command>grouping</command> ve <command>mon_grouping</command> için her ikisine de gruplama yapılmayacağı anlamına gelen <command>&quot;&quot;</command> değeri belirtilmiştir.
     </para></glossdef></glossentry><glossentry><glossterm>
     <literal>char </literal><command>int_frac_digits</command>
     </glossterm></glossentry><glossentry><glossterm>
     <literal>char </literal><command>frac_digits</command>
     </glossterm><glossdef><para>
Bunlar parasal gösterimin sırayla uluslararası ve yerel biçimlendirmesinde ondalık ayracın sağında kaç rakamın gösterileceğini belirtmekte kullanılır. (Çoğunlukla ikisine de aynı değer atanır.)
        </para><para>
Standart <command>C</command> yerelinde, her iki üye de "belirtilmemiş" anlamına gelen <command>CHAR_MAX</command> değerini içerir. ISO C standardı bu değere rastlandığında ne yapılacağını belirlememiştir; bizim tavsiyemiz ondalık ayraçtan sonra hiçbir rakam gösterilmeyeceği şeklinde yorumlanmasıdır. (C yerelinin <command>mon_decimal_point</command> değeri olarak boş dizge belirttiğini gözönüne alırsanız bir rakamın gösterilmesi sayının değerinin değişmesi demektir!)
        </para></glossdef></glossentry></glosslist></para></sect2>
        <sect2 xml:id="glibc-Currency-Symbol">
        <title>Para sembolünün Basılması</title>
        <titleabbrev>Para birimi sembolü (örn, $) nasıl basılacak.</titleabbrev>
        <para>
<indexterm scope="glibc-cp"><primary>para sembolü</primary></indexterm>
<command>struct lconv</command>  yapısının para sembolü ile ilgili üyeleri para birimini tanımlayan sembolü basmak için kullanılır. Amerikan doları için uluslararası ve yerel sembol aynıdır ve bu sembol $'dır.
     </para><para>
Her ülkenin iki standart para birimi sembolü vardır. <wordasword>Yerel para sembolü</wordasword> ülke içinde, <wordasword>uluslararası para sembolü</wordasword> ise uluslararası kullanımda yerel sembolün kullanımının sorun yaratmaması için kullanılan para sembolüdür.
     </para><para>
Örneğin, birçok ülke kendi para birimi olarak dolar kullanır. Yerel kullanımda sorun çıkarmayan bu sembol, uluslararası kullanımda Amerikan dolarından ve diğer dolarlardan ayrılması gerekir. Kanada ve Avustralya için böyledir.
     </para><para><glosslist><glossentry><glossterm>
     <literal>char *</literal><command>currency_symbol</command>
     </glossterm><glossdef><para>
Yerelin yerel para birimi sembolüdür.
        </para><para>
Standart <command>C</command> yerelinde, bu üyenin değeri "belirtilmemiş" anlamına gelen <command>&quot;&quot;</command> boş dizgesidir. ISO C standardı bu değerin nasıl yorunlanacağını belirlememiştir; bizim tavsiyemiz boş dizge olarak yorumlanmasıdır.
     </para></glossdef></glossentry><glossentry><glossterm>
     <literal>char *</literal><command>int_curr_symbol</command>
     </glossterm><glossdef><para>
Yerelin uluslararası para birimi sembolüdür.
        </para><para>
<command>int_curr_symbol</command> değeri normalde uluslarası standart tarafından belirlenen üç harfli bir kısaltmadır <citation>ISO 4217 Codes for the Representation of Currency and Funds</citation> (Para ve Fonların gösterimi için ISO 4217 kodları) ve bu kısaltmadan sonra tek karakterlik bir ayraç gelir (çoğunlukla boşluk).
        </para><para>
Standart <command>C</command> yerelinde, bu üyenin değeri "belirtilmemiş" anlamına gelen <command>&quot;&quot;</command> boş dizgesidir; bizim tavsiyemiz boş dizge olarak yorumlanmasıdır.
     </para></glossdef></glossentry><glossentry><glossterm>
     <literal>char </literal><command>p_cs_precedes</command>
     </glossterm></glossentry><glossentry><glossterm>
     <literal>char </literal><command>n_cs_precedes</command>
     </glossterm></glossentry><glossentry><glossterm>
     <literal>char </literal><command>int_p_cs_precedes</command>
     </glossterm></glossentry><glossentry><glossterm>
     <literal>char </literal><command>int_n_cs_precedes</command>
     </glossterm><glossdef><para>
Bu üyelerin değeri <command>1</command> ise, para sembolleri para değerinin önüne, <command>0</command> ise para değerinin sonuna konur. <command>p_cs_precedes</command> ve <command>int_p_cs_precedes</command>
 değerleri pozitif miktarlara, <command>n_cs_precedes</command> ve <command>int_n_cs_precedes</command> değerleri ise negatif miktarlara uygulanır.
        </para><para>
Standart <command>C</command> yerelinde bu üyelerin hepsine "belirtilmemiş" anlamına gelen <command>CHAR_MAX</command> değeri atanmıştır. ISO C standardı bu değerin nasıl yorumlanacağını belirtmemiştir. Bizim tavsiyemiz çoğu ülkede para sembolünün para miktarının önüne konulmasından hareketle para sembolünün önce basılacağı biçimde yorumlanmasıdır. Başka yönden bakarsak değerin sıfırdan farklı bir değer olarak (1 olarak) yorumlanması önerilir.
        </para><para>
İsimleri <command>int_</command> ile başlayan üyeler <command>int_curr_symbol</command>'e, diğerleri <command>currency_symbol</command>'e uygulanır.
     </para></glossdef></glossentry><glossentry><glossterm>
     <literal>char </literal><command>p_sep_by_space</command>
     </glossterm></glossentry><glossentry><glossterm>
     <literal>char </literal><command>n_sep_by_space</command>
     </glossterm></glossentry><glossentry><glossterm>
     <literal>char </literal><command>int_p_sep_by_space</command>
     </glossterm></glossentry><glossentry><glossterm>
     <literal>char </literal><command>int_n_sep_by_space</command>
     </glossterm><glossdef><para>
Bu üyelerin değeri <command>1</command> ise, para sembolü ile para miktarı arasına bir boşluk konur, <command>0</command> ise boşluk konmaz. <command>p_sep_by_space</command> ve <command>int_p_sep_by_space</command> üyeleri pozitif (veya sıfır) para miktarlarına, <command>n_sep_by_space</command> ve <command>int_n_sep_by_space</command> üyeleri ise negatif para miktarlarına uygulanır.
        </para><para>
Standart <command>C</command> yerelinde, bu üyelerin hepsine "belirtilmemiş" anlamına gelen <command>CHAR_MAX</command> değeri atanmıştır. ISO C standardı bu değerin nasıl yorumlanacağını belirtmemiştir. Tavsiyemiz değerin sıfırdan farklı bir değer olarak (1 olarak) yorumlanmasıdır (yani boşluk konması).
        </para><para>
İsimleri <command>int_</command> ile başlayan üyeler <command>int_curr_symbol</command>'e, diğerleri <command>currency_symbol</command>'e uygulanır.
<command>int_curr_symbol</command> için özel bir durum vardır. Standart uluslararası değerler sembolden sonra bir boşluk içerir (Para sembolünün para miktarından önce kullanılması ve arada boşluk bırakılması için). Bu durumda bu boşluğun basılmasının önlenmesine (bilhassa para sembolünün para miktarından sonra basıldığı durumda) dikkat edilmelidir.
        </para></glossdef></glossentry></glosslist></para></sect2>
        <sect2 xml:id="glibc-Sign-of-Money-Amount">
        <title>Para Miktarına İşaret Basılması</title>
        <titleabbrev>Para miktarlarında pozitif ve negatif işaretler varsa, nasıl basılır.</titleabbrev>
        <para>
<command>struct lconv</command> yapısının bu üyelerinde parasal gösterimde (varsa) işaretin nasıl basılacağını belirtilir.
     </para><para><glosslist><glossentry><glossterm>
     <literal>char *</literal><command>positive_sign</command>
     </glossterm></glossentry><glossentry><glossterm>
     <literal>char *</literal><command>negative_sign</command>
     </glossterm><glossdef><para>
Bunlar pozitif (veya sıfır) ve negatif para miktarlarını belirtmekte kullanılacak işaretleri içeren dizgelerdir.
        </para><para>
Standart <command>C</command> yerelinde, bu üyelerin her ikisine de "belirtilmemiş" anlamına gelen <command>&quot;&quot;</command> boş dizgesi atanmıştır.
        </para><para>
ISO C standardı bu değerlerin nasıl yorumlanacağını belirtmemiştir. Tavsiyemiz pozitif işareti <command>positive_sign</command> boş dizge olarak belirtilse dahi bulduğunuz gibi, negatif işareti de <command>negative_sign</command> boş dizge olarak belirtilse bile <command>-</command> olarak basılmasıdır.
     </para></glossdef></glossentry><glossentry><glossterm>
     <literal>char </literal><command>p_sign_posn</command>
     </glossterm></glossentry><glossentry><glossterm>
     <literal>char </literal><command>n_sign_posn</command>
     </glossterm></glossentry><glossentry><glossterm>
     <literal>char </literal><command>int_p_sign_posn</command>
     </glossterm></glossentry><glossentry><glossterm>
     <literal>char </literal><command>int_n_sign_posn</command>
     </glossterm><glossdef><para>
Bu üyeler pozitif ve negatif miktarların işaretlerinin yerini belirtmede kullanılan küçük tamsayılar içerir. Olası değerler şunlardır:
        </para><para><variablelist><varlistentry>
        <term><literal>0</literal></term><listitem><para>
Para sembolü ve miktar parantez içine alınır.
           </para></listitem></varlistentry><varlistentry>
           <term><literal>1</literal></term><listitem><para>
İşaret, para sembolü ve para miktarından önce basılır.
           </para></listitem></varlistentry><varlistentry>
           <term><literal>2</literal></term><listitem><para>
İşaret, para sembolü ve para miktarından sonra basılır.
           </para></listitem></varlistentry><varlistentry>
           <term><literal>3</literal></term><listitem><para>
İşaret, para sembolünden hemen önce basılır.
           </para></listitem></varlistentry><varlistentry>
           <term><literal>4</literal></term><listitem><para>
İşaret, para sembolünden hemen sonra basılır.
           </para></listitem></varlistentry><varlistentry>
           <term><literal>CHAR_MAX</literal></term><listitem><para>
&quot;Belirsiz&quot;.  Standart <command>C</command> yerelinde her iki üye de bu değere sahiptir.
           </para></listitem></varlistentry></variablelist>
        </para><para>
ISO standardı değerin <command>CHAR_MAX</command> olması halinde ne yapılacağını belirlememiştir. Tavsiyemiz, işaretin para sembolünden sonra basılmasıdır.
        </para><para>
İsimleri <command>int_</command> ile başlayan üyeler <command>int_curr_symbol</command> ile diğerleri <command>currency_symbol</command> ile uygulanır.
        </para></glossdef></glossentry></glosslist>
      </para></sect2></sect1>
        <sect1 xml:id="glibc-The-Elegant-and-Fast-Way">
        <title>Yerel Verisine Noktasal Erişim</title>
        <titleabbrev>Yerel verisine giden asfalt yol: X/Open'ın <command>nl_langinfo</command> işlevi.</titleabbrev>
        <para>
X/Open Taşınabilirlik Kılavuzu yazılırken yazarlar yerele özgü bilgilere erişmek anlamında <command>localeconv</command> işlevinin yetersizliğinde anlaştılar. Yerelde kullanılabilir bilgilere (daha sonra POSIX.1 standardında belirtildiği gibi) daha çok yoldan erişmek gerekir.  <command>nl_langinfo</command> işlevi bunun için tasarlanmıştır.
    </para><para xml:id="glibc-nl_langinfo">
<indexterm scope="glibc-fn"><primary>nl_langinfo</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>char *<command>nl_langinfo</command></funcdef>
<paramdef>(nl_item <varname>öğe</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>nl_langinfo</command> işlevi yerel kategorilerindeki her elemana tek tek erişmek için kullanılabilir. Tüm bilgiyi döndüren <command>localeconv</command>  işlevinin tersine, <command>nl_langinfo</command> işlevi çağrıcının istediği bilgiyi belirtebilmesini sağlar. Bu çok hızlı yapıldığından işlevin defalarca çağrılması bir soruna yol açmaz.
    </para><para>
İkinci bir getirisi de sayısal ve parasal gösterim bilgilerine ek olarak <command>LC_TIME</command> ve <command>LC_MESSAGES</command> kategorileriyle ilgili bilgilerin de istenebilmesidir.
    </para><para>
<indexterm scope="glibc-pg"><primary>langinfo.h</primary></indexterm>
<command>nl_type</command> türü <filename>nl_types.h</filename> dosyasında tanımlanmıştır.  <varname>öğe</varname> argümanı <command>langinfo.h</command> dosyasında tanımlı sayısal değerlerden biri olmalıdır. X/Open standardı şu değerleri tanımlar:
    </para><para><variablelist><varlistentry>
    <term><command>CODESET</command></term><listitem><para>
<command>nl_langinfo</command> seçili yerelin karakter kodlaması için kullanılan karakter kümesinin ismini içeren bir dizge ile döner.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>ABDAY_1</literal></term>
       </varlistentry><varlistentry><term><literal>ABDAY_2</literal></term>
       </varlistentry><varlistentry><term><literal>ABDAY_3</literal></term>
       </varlistentry><varlistentry><term><literal>ABDAY_4</literal></term>
       </varlistentry><varlistentry><term><literal>ABDAY_5</literal></term>
       </varlistentry><varlistentry><term><literal>ABDAY_6</literal></term>
       </varlistentry><varlistentry><term><literal>ABDAY_7</literal></term>
       <listitem><para>
<command>nl_langinfo</command> kısaltılmış gün ismi ile döner.  <command>ABDAY_1</command> Pazar gününe karşılıktır.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>DAY_1</literal></term>
       </varlistentry><varlistentry><term><literal>DAY_2</literal></term>
       </varlistentry><varlistentry><term><literal>DAY_3</literal></term>
       </varlistentry><varlistentry><term><literal>DAY_4</literal></term>
       </varlistentry><varlistentry><term><literal>DAY_5</literal></term>
       </varlistentry><varlistentry><term><literal>DAY_6</literal></term>
       </varlistentry><varlistentry><term><literal>DAY_7</literal></term>
       <listitem><para>
<command>ABDAY_1</command> ve benzerleri gibidir, farklı olarak kısaltılmamış gün ismi ile döner.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>ABMON_1</literal></term>
       </varlistentry><varlistentry><term><literal>ABMON_2</literal></term>
       </varlistentry><varlistentry><term><literal>ABMON_3</literal></term>
       </varlistentry><varlistentry><term><literal>ABMON_4</literal></term>
       </varlistentry><varlistentry><term><literal>ABMON_5</literal></term>
       </varlistentry><varlistentry><term><literal>ABMON_6</literal></term>
       </varlistentry><varlistentry><term><literal>ABMON_7</literal></term>
       </varlistentry><varlistentry><term><literal>ABMON_8</literal></term>
       </varlistentry><varlistentry><term><literal>ABMON_9</literal></term>
       </varlistentry><varlistentry><term><literal>ABMON_10</literal></term>
       </varlistentry><varlistentry><term><literal>ABMON_11</literal></term>
       </varlistentry><varlistentry><term><literal>ABMON_12</literal></term>
       <listitem><para>
İşlev kısaltılmış ay ismi ile döner. <command>ABMON_1</command> Ocak ayına karşılıktır.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>MON_1</literal></term>
       </varlistentry><varlistentry><term><literal>MON_2</literal></term>
       </varlistentry><varlistentry><term><literal>MON_3</literal></term>
       </varlistentry><varlistentry><term><literal>MON_4</literal></term>
       </varlistentry><varlistentry><term><literal>MON_5</literal></term>
       </varlistentry><varlistentry><term><literal>MON_6</literal></term>
       </varlistentry><varlistentry><term><literal>MON_7</literal></term>
       </varlistentry><varlistentry><term><literal>MON_8</literal></term>
       </varlistentry><varlistentry><term><literal>MON_9</literal></term>
       </varlistentry><varlistentry><term><literal>MON_10</literal></term>
       </varlistentry><varlistentry><term><literal>MON_11</literal></term>
       </varlistentry><varlistentry><term><literal>MON_12</literal></term>
       <listitem><para>
<command>ABMON_1</command> ve benzerleri gibidir, farklı olarak kısaltılmamış ay ismi ile döner.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>AM_STR</literal></term>
       </varlistentry><varlistentry><term><literal>PM_STR</literal></term>
       <listitem><para>
İşlev, 12 saatlik zaman gösteriminde kullanılan (sırayla) öğleden önce ve öğleden sonra  kısaltmaları (öö/ös) olarak belirtilmiş dizge ile döner.
       </para><para>
12 saatlik zaman gösterimi kullanılmayan yerellerde bu dizgeler boş olabilir, bu takdirde 12 saatlik gösterim seçilse bile bu kısaltmalar gösterilmeyecektir.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>D_T_FMT</literal></term><listitem><para>
Yerele özgü tarih ve zaman gösterimi olarak <command>strftime</command> işlevinde  kullanılabilecek biçim dizgesi ile döner.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>D_FMT</literal></term><listitem><para>
Yerele özgü tarih gösterimi olarak <command>strftime</command> işlevinde  kullanılabilecek biçim dizgesi ile döner.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>T_FMT</literal></term><listitem><para>
Yerele özgü zaman gösterimi olarak <command>strftime</command> işlevinde  kullanılabilecek biçim dizgesi ile döner.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>T_FMT_AMPM</literal></term><listitem><para>
Yerele özgü öö/ös gösterimi olarak <command>strftime</command> işlevinde  kullanılabilecek biçim dizgesi ile döner.
       </para><para>
öö/ös biçimi seçilmiş yerelde belirlenmemişse dönen değer <command>T_FMT</command> için dönen değer ile aynı olabilir.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>ERA</literal></term><listitem><para>
İşlev seçili yerelde kullanılan çağ ile döner.
       </para><para>
Çoğu yerelde bu değer atanmamıştır. Bu değerin atandığı yarellerden biri olarak japonca gösterilebilir. Japonya'da geleneksel tarih gösterimleri imparatorun saltanat dönemine karşı düşen çağ ismini de içerir.
       </para><para>
Normalde bu değeri doğrudan kullanmak gerekmez. <command>strftime</command> işlevinin biçim dizgesinde <command>E</command> değiştiricisini belirterek bu bilginin kullanılması sağlanabilir. Dönen dizgenin biçimi belirlenmemiştir, bu bakımdan başka sistemlerde aynı dizgenin elde edileceği varsayımında bulunmayın.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>ERA_YEAR</literal></term><listitem><para>
Yerelde belirtilen çağa göre belirtilen yol döner. <command>ERA</command> gibi bu değeri de doğrudan kullanmak gerekmez.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>ERA_D_T_FMT</literal></term><listitem><para>
Yerele özgü çağa göre tarih ve zaman gösterimi olarak <command>strftime</command> işlevinde  kullanılabilecek biçim dizgesi ile döner.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>ERA_D_FMT</literal></term><listitem><para>
Yerele özgü çağa göre tarih gösterimi olarak <command>strftime</command> işlevinde  kullanılabilecek biçim dizgesi ile döner.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>ERA_T_FMT</literal></term><listitem><para>
Yerele özgü çağa göre zaman gösterimi olarak <command>strftime</command> işlevinde  kullanılabilecek biçim dizgesi ile döner.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>ALT_DIGITS</literal></term><listitem><para>
0-99 arasındaki sayıların gösterimi için kullanılan 100 değerle döner. Bu değer de <command>ERA</command> gibi doğrudan  kullanmak için tasarlanmamıştır. <command>strftime</command> işlevinde <command>O</command> değiştiricisi belirtilerek kullanılır. Bu takdirde biçim dizgesindeki saat, dakika, saniye, ayın günü, aylar ve haftalar gibi sayısal değerler buna göre gösterilir.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>INT_CURR_SYMBOL</literal></term><listitem><para>
<command>localeconv</command> işlevi ile dönen <command>struct lconv</command> yapısının  <command>int_curr_symbol</command> elemanındaki değer ile döner.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>CURRENCY_SYMBOL</literal></term>
       </varlistentry><varlistentry><term><literal>CRNCYSTR</literal></term>
       <listitem><para>
<command>localeconv</command> işlevi ile dönen <command>struct lconv</command> yapısının  <command>currency_symbol</command> elemanındaki değer ile döner.
       </para><para>
<command>CRNCYSTR</command>,  Unix98 tarafından hala ihtiyaç duyulan artık kullanılmayan bir takma addır.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>MON_DECIMAL_POINT</literal></term><listitem><para>
<command>localeconv</command> işlevi ile dönen <command>struct lconv</command> yapısının  <command>mon_decimal_point</command> elemanındaki değer ile döner.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>MON_THOUSANDS_SEP</literal></term><listitem><para>
<command>localeconv</command> işlevi ile dönen <command>struct lconv</command> yapısının  <command>mon_thousands_sep</command> elemanındaki değer ile döner.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>MON_GROUPING</literal></term><listitem><para>
<command>localeconv</command> işlevi ile dönen <command>struct lconv</command> yapısının  <command>mon_grouping</command> elemanındaki değer ile döner.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>POSITIVE_SIGN</literal></term><listitem><para>
<command>localeconv</command> işlevi ile dönen <command>struct lconv</command> yapısının  <command>positive_sign</command> elemanındaki değer ile döner.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>NEGATIVE_SIGN</literal></term><listitem><para>
<command>localeconv</command> işlevi ile dönen <command>struct lconv</command> yapısının  <command>negative_sign</command> elemanındaki değer ile döner.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>INT_FRAC_DIGITS</literal></term><listitem><para>
<command>localeconv</command> işlevi ile dönen <command>struct lconv</command> yapısının  <command>int_frac_digits</command> elemanındaki değer ile döner.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>FRAC_DIGITS</literal></term><listitem><para>
<command>localeconv</command> işlevi ile dönen <command>struct lconv</command> yapısının  <command>frac_digits</command> elemanındaki değer ile döner.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>P_CS_PRECEDES</literal></term><listitem><para>
<command>localeconv</command> işlevi ile dönen <command>struct lconv</command> yapısının  <command>p_cs_precedes</command> elemanındaki değer ile döner.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>P_SEP_BY_SPACE</literal></term><listitem><para>
<command>localeconv</command> işlevi ile dönen <command>struct lconv</command> yapısının  <command>p_sep_by_space</command> elemanındaki değer ile döner.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>N_CS_PRECEDES</literal></term><listitem><para>
<command>localeconv</command> işlevi ile dönen <command>struct lconv</command> yapısının  <command>n_cs_precedes</command> elemanındaki değer ile döner.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>N_SEP_BY_SPACE</literal></term><listitem><para>
<command>localeconv</command> işlevi ile dönen <command>struct lconv</command> yapısının  <command>n_sep_by_space</command> elemanındaki değer ile döner.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>P_SIGN_POSN</literal></term><listitem><para>
<command>localeconv</command> işlevi ile dönen <command>struct lconv</command> yapısının  <command>p_sign_posn</command> elemanındaki değer ile döner.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>N_SIGN_POSN</literal></term><listitem><para>
<command>localeconv</command> işlevi ile dönen <command>struct lconv</command> yapısının  <command>n_sign_posn</command> elemanındaki değer ile döner.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>INT_P_CS_PRECEDES</literal></term><listitem><para>
<command>localeconv</command> işlevi ile dönen <command>struct lconv</command> yapısının  <command>int_p_cs_precedes</command> elemanındaki değer ile döner.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>INT_P_SEP_BY_SPACE</literal></term><listitem><para>
<command>localeconv</command> işlevi ile dönen <command>struct lconv</command> yapısının  <command>int_p_sep_by_space</command> elemanındaki değer ile döner.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>INT_N_CS_PRECEDES</literal></term><listitem><para>
<command>localeconv</command> işlevi ile dönen <command>struct lconv</command> yapısının  <command>int_n_cs_precedes</command> elemanındaki değer ile döner.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>INT_N_SEP_BY_SPACE</literal></term><listitem><para>
<command>localeconv</command> işlevi ile dönen <command>struct lconv</command> yapısının  <command>int_n_sep_by_space</command> elemanındaki değer ile döner.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>INT_P_SIGN_POSN</literal></term><listitem><para>
<command>localeconv</command> işlevi ile dönen <command>struct lconv</command> yapısının  <command>int_p_sign_posn</command> elemanındaki değer ile döner.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>INT_N_SIGN_POSN</literal></term><listitem><para>
<command>localeconv</command> işlevi ile dönen <command>struct lconv</command> yapısının  <command>int_n_sign_posn</command> elemanındaki değer ile döner.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>DECIMAL_POINT</literal></term>
       </varlistentry><varlistentry><term><literal>RADIXCHAR</literal></term>
       <listitem><para>
<command>localeconv</command> işlevi ile dönen <command>struct lconv</command> yapısının  <command>decimal_point</command> elemanındaki değer ile döner.
       </para><para>
<command>RADIXCHAR</command> Unix98 tarafından hala ihtiyaç duyulan artık kullanılmayan bir takma addır.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>THOUSANDS_SEP</literal></term>
       </varlistentry><varlistentry><term><literal>THOUSEP</literal></term>
       <listitem><para>
<command>localeconv</command> işlevi ile dönen <command>struct lconv</command> yapısının  <command>thousands_sep</command> elemanındaki değer ile döner.
       </para><para>
<command>THOUSEP</command> Unix98 tarafından hala ihtiyaç duyulan artık kullanılmayan bir takma addır.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>GROUPING</literal></term><listitem><para>
<command>localeconv</command> işlevi ile dönen <command>struct lconv</command> yapısının  <command>grouping</command> elemanındaki değer ile döner.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>YESEXPR</literal></term><listitem><para>
Dönen değer, evet/hayır sorusuna olumlu yanıt olarak <command>regex</command> işlevinde kullanılabilen bir düzenli ifadedir. GNU C kütüphanesi uygulamalarda bunu daha da kolaylaştıran <command>rpmatch</command> işlevini içerir.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>NOEXPR</literal></term><listitem><para>
Dönen değer, evet/hayır sorusuna olumsuz yanıt olarak <command>regex</command> işlevinde kullanılabilen bir düzenli ifadedir.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>YESSTR</literal></term><listitem><para>
Evet/hayır sorusuna olumlu yanıt olarak yerel özgü dizge ile döner.
       </para><para>
İleti çevirilerinde çok özel bir durum olduğundan bu değer artık kullanılmamaktadır. İleti çeviri işlevleri ile elde edilmesi daha iyidir (bkz. <xref linkend="glibc-Message-Translation"/>).
       </para><para>
Bu sembol artık kullanılmamaktadır. Onun yerine ileti çevirileri kullanılmalıdır.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>NOSTR</literal></term><listitem><para>
Evet/hayır sorusuna olumsuz yanıt olarak yerel özgü dizge ile döner.   <command>YESSTR</command> için bahsedilen herşey bunun için de geçerlidir.
       </para><para>
Bu sembol artık kullanılmamaktadır. Onun yerine ileti çevirileri kullanılmalıdır.
       </para></listitem></varlistentry></variablelist>
     </para><para>
<command>langinfo.h</command> dosyası bunlardan başka semboller de içerir ama bunların pek kullanım alanı yoktur. Onların kullanılması taşınabilirliği ortadan kaldırır. Bu nedenle kullanılmaları tavsiye edilmez.
    </para><para>
Her geçerli argüman için dönen değer tüm durumlarda kullanılabilir (öö/ös biçim kodlarının olası olağandışılığı dahil). Eğer kullanıcı ilgili kategori için bir yerel seçimi yapmamışsa <command>nl_langinfo</command> işlevi <command>&quot;C&quot;</command> yerelindeki bilgi ile döner. Bundan dolayı işlevi aşağıdaki örnekte gösterildiği gibi kullanmak mümkündür.
    </para><para>
<varname>öğe</varname> argümanı geçersizse, boş dizge içeren bir gösterici döner.
</para></funcdescr></funcsynopsis></para><para>
Bir <command>nl_langinfo</command> kullanım örneği olarak bir işlev tarih ve zamanı yerele özgü biçimde basmak için kullanılmıştır. Burada, dikkat ederseniz, <command>strftime</command> işlevi yerel bilgisini zaten dahili olarak kullandığından biçim dizgesinde yeteri kadar değiştirici kullanılmıştır.
    </para><para><screen>
size_t
i18n_time_n_data (char *s, size_t len, const struct tm *tp)
{
  return strftime (s, len, &quot;%X %D&quot;, tp);
}
</screen></para><para>
Biçim ne haftanın günü ne de ay ismi içerir, bu nedenle uluslararası olarak kullanılabilir. Yanlış! Çıktı <command>&quot;hh:mm:ss AA/GG/YY&quot;</command> biçiminde üretilir. Bu biçim sadece ABD'de geçerlidir. Diğer ülkeler farklı biçim kullanır. Bu nedenle işlev şöyle yazılmalıydı:
    </para><para>
<screen>
size_t
i18n_time_n_data (char *s, size_t len, const struct tm *tp)
{
  return strftime (s, len, nl_langinfo (D_T_FMT), tp);
}
</screen></para><para>
Artık yazılım çalıştırıldığında seçili yerelin tarih ve zaman biçimi kullanılacaktır. Kullanıcı doğru yereli seçmişse tarih ve zaman ile ilgili yanlış anlamalar olmayacakır.
    </para></sect1></chapter><chapter xml:id="glibc-Formatting-Numbers">
    <title>Sayıların Biçimlenmesi</title>
    <titleabbrev>Sayıları biçimlemeye adanmış bir işlev.</titleabbrev>
    <para>
Gerek <command>localeconv</command> ile dönen yapı ile gerekse <command>nl_langinfo</command> işlevine sembol belirterek sayısal ve parasal gösterimleri biçimlemekte kullanılan yerele özgü bilgilerin çeşitli parçalarının elde edilebileceğini görmüştük. Ayrıca temel kuralların oldukça karmaşık olduğunu da görmüştük.
   </para><para>
Bu nedenle, X/Open standartları bu tür yerel bilgisini kullanan ve sayıları bu kurallara göre biçimlemeyi kullanıcı açısından kolaylaştıran bir işlev tanımlamıştır.
   </para><para xml:id="glibc-strfmon">
<indexterm scope="glibc-fn"><primary>strfmon</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>ssize_t <command>strfmon</command></funcdef>
<paramdef>(char       *<varname>tampon</varname>,
 size_t      <varname>azamiboyut</varname>,
 const char *<varname>biçim</varname>,
 …)</paramdef>
</funcprototype><funcdescr><para>
<command>strfmon</command> işlevi <command>strftime</command> işlevine benzer. İşlev bir tampon, tampon boyu ve biçim dizgesi alır ve çıktı biçim dizgesi ile belirtildiği gibi biçimlenerek metin olarak tampona yazılır. İşlev, <command>strftime</command> gibi tampona yazılan baytların sayısı ile döner.
   </para><para>
İki fark vardır: <command>strfmon</command> birden fazla argüman alır ve şüphesiz biçim belirtimi farklıdır. <command>strftime</command>'a benzer olarak, biçim dizgesi çıktıda olduğu gibi normal metindir ve biçim belirteçleri <command>%</command> işareti ile belirtilir. <command>printf</command> işlevinde olduğu gibi, <command>%</command> işaretinin ardından, biçim karakterinden önce isteğe bağlı olarak çeşitli seçenekler ve biçimleme bilgileri belirtilebilir:
   </para><para><itemizedlist><listitem><para>
<command>%</command> işaretinin hemen ardından bu seçeneklerden biri veya birkaçı belirtilebilir:
     </para><para><variablelist><varlistentry>
     <term><literal>=<emphasis>f</emphasis></literal></term><listitem><para>
<varname>f</varname> karakteri, sayısal dolgu karakteri olarak bu alanda kullanılacak tek baytlık karakterdir. Bu karakterin öntanımlı değeri boşluk karakteridir. Bu karakterin dolgu karakteri olarak kullanılabilmesi için ondalık ayracın solundaki bölüm için genişlik belirtilmiş olmalıdır. Belirtilen alan genişliği dolgu karakteri sayısı değildir.
        </para></listitem></varlistentry><varlistentry>
        <term><literal>^</literal></term><listitem><para>
Seçili yerelin kurallarına bağlı rakam gruplaması yapılmaz. Öntanımlı olarak yerelde belirtilmiş gruplama yapılır.
        </para></listitem></varlistentry><varlistentry>
        <term><literal>+</literal></term></varlistentry><varlistentry>
        <term><literal>(</literal></term><listitem><para>
Bu seçeneklerden sadece biri kullanılabilir. Para miktarında işaretin nasıl belirtileceğini belirlerler. Öntanımlı olarak ve <command>+</command> belirtilmişse +/- için yerelde belirtilen kullanılır. <command>(</command> belirtilmişse, negatif miktarlar parantez içine alınır. Tam biçim yazılımın çalışması sırasında seçili yerelin <command>LC_MONETARY</command> kategorisindeki değerlere göre saptanır.
        </para></listitem></varlistentry><varlistentry>
        <term><literal>!</literal></term><listitem><para>
Çıktı para sembolünü içermeyecektir.
        </para></listitem></varlistentry><varlistentry>
        <term><literal>-</literal></term><listitem><para>
Çıktı eğer alan genişliğinde doldurma yapılacağı belirtilmemişse sağa değil sola yanaşık biçimlenecektir.
        </para></listitem></varlistentry></variablelist>
      </para></listitem></itemizedlist>
    </para><para>
Belirtimin sonraki parçası isteğe bağlı olan alan genişliğidir. Bir genişlik belirtilmemişse 0 verilmiş kabul edilir. Çıktılama sırasında, işlev önce ne kadar alan gerektiğini saptar. Eğer gerektiği kadar genişlik belirtilmişse çıktı bu alanı kullanır. Aksi takdirde, belirtilen genişlik dolgu karakteri ile doldurularak çıktılama yapılır. <command>-</command> iminin varlığına vaya yokluğuna bağlı olarak işaretin bulunduğu tarafın boşluğu saptanır. Varsa, çıktı sola yanaşık yapılarak boşluk sağa eklenir ya da tersi yapılır.
   </para><para>
Şimdiye kadar <command>printf</command> ve <command>strftime</command> biçimlerine benzerliğinden dolayı biçim oldukça bildik göründü. Ancak sonraki iki alan biraz yeni. İlki <command>#</command> karakteri ile başlayan bir ondalık sayı dizgesidir. Bu dizge ondalık ayracın solunda kalan rakam (karakter sayısını değil) sayısını belirtir. Bu miktara gruplama karakterleri dahil değildir. Basılacak sayının rakamları bu genişliği dolduramazsa, boş kalan alan <command>=</command> imi ile belirtilmişse o karakterle aksi takdirde boşluk karakteri ile doldurulur. Örneğin alan genişliği 6 ve dolgu karakteri <command>*</command> olarak verilmişse, 123 sayısı, <command>***123</command> olarak biçimlenecektir.
   </para><para>
İsteğe bağlı ikinci alan ise <command>.</command> karakteri ile başlayan bir ondalık sayı dizgesidir. Bu dizge ondalık ayracın sağındaki rakam sayısını belirtir. Öntanımlı değer yerelin <command>frac_digits</command> ve <command>int_frac_digits</command> değerleridir (bkz. <xref linkend="glibc-General-Numeric"/>). Eğer belirtilen genişlik bütün haneleri göstermek için yeterli değilse, yuvarlama yapılır. Alan genişliği sıfır olarak belirtilmişse ondalık ayraç basılmaz.
   </para><para>
Bir GNU oluşumu olarak GNU C kütüphanesindeki <command>strfmon</command> gerçeklemesi bu seçeneklerden sonra isteğe bağlı <command>L</command> biçim belirtecini kabul eder. Eğer bu belirteç varsa, belirtilen argüman bir <command>double</command> değer değil <command>long double</command> değer kabul edilir.
   </para><para>
Son eleman bir biçim belirtecidir. Üç belirteç belirtilebilir:
   </para><para><variablelist><varlistentry>
   <term><command>i</command></term><listitem><para>
Bir uluslararası parasal değerin biçimlenmesi için yerelin kuralları kullanılır.
      </para></listitem></varlistentry><varlistentry>
      <term><command>n</command></term><listitem><para>
Bir ulusal parasal değerin biçimlenmesi için yerelin kuralları kullanılır.
      </para></listitem></varlistentry><varlistentry>
      <term><command>%</command></term><listitem><para>
Çıktıya <command>%</command> işareti basılır. Sadece  <command>%%</command> belirtilebilir, bir im, seçenek ya da belirteç belirtilmesine izin verilmemiştir.
      </para></listitem></varlistentry></variablelist></para><para>
<command>printf</command> işlevinin yaptığı gibi, işlev biçim dizgesini soldan sağa okur ve biçim dizgesinden sonra verilmiş olan değerleri bu dizgeye göre biçimlendirir. Değerler <command>L</command> belirteci varsa  <command>long double</command>, aksi takdirde <command>double</command> türünde kabul edilir. Sonuç, <varname>tampon</varname> ile gösterilen tamponda en fazla <varname>azamiboyut</varname> karakterlik saklanır.
   </para><para>
İşlevin dönüş değeri <varname>tampon</varname>'da saklanan boş karakter sonlandırmalı dizgenin karakter sayısıdır. Eğer <varname>tampon</varname> içinde saklanacak karakterlerin sayısı <varname>azamiboyut</varname>'tan büyükse tamponun yetersiz kaldığını belirtmek için işlev -1 ile döner. Bu durumda <command>errno</command> değişkenine <command>E2BIG</command> değeri atanır.
</para></funcdescr></funcsynopsis></para><para>
Küçük bir kaç örnekle işlevin nasıl çalıştığını gösterebiliriz. Örneklerin ABD yerelinde (<command>en_US</command>) çalıştırıldığı varsayılmıştır. En basit biçim:
   </para><para>
<screen>
strfmon (buf, 100, &quot;@%n@%n@%n@&quot;, 123.45, -567.89, 12345.678);
</screen></para><para>
için şu çıktı üretilir:</para><para>
<screen>
&quot;@$123.45@-$567.89@$12,345.68@&quot;
</screen></para><para>
Burada birkaç şeyden bahsedebiliriz. İlki çıktılanan sayılardaki genişlik farklarıdır. Biçim dizgesinde bir genişlik belirtmedik, yani bunun önemi yok. İkincisi, üçüncü sayı binlik gruplama ayracı ile çıktılandı. Binlik gruplama ayracı <command>en_US</command> yereli için virgüldür. Bundan başka sayının yuvarlatıldığını görüyoruz. Biz ondalık ayracın sağındaki hane sayısını belirtmedik ama yerel bunu 2 olarak belirlediğinden .678 -> .68 olarak yuvarlandı. Son olarak <command>i</command> değil <command>n</command> belirtttiğimizden ulusal para sembolü görüntülendi.
   </para><para>
Bu örnekte çıktının nasıl hizalandığı gösterilmiştir:
   </para><para>
<screen>
strfmon (buf, 100, &quot;@%=*11n@%=*11n@%=*11n@&quot;, 123.45, -567.89, 12345.678);
</screen></para><para>
Çıktısı şöyle olur (@ karakterlerine dikkat):
</para><para>
<screen>
&quot;@    $123.45@   -$567.89@ $12,345.68@&quot;
</screen></para><para>
Burada iki şeyden söz edilebilir: İlki, biçim dizgesinde alan genişliği belirtildiğinden ve bu genişlikten daha geniş bir sayı olmadığından tüm alanlar aynı genişlikte çıktılandı (onbir karakter). İkinci önemli nokta ise dolgu karakteri belirtildiği halde çıktıda kullanılmamış olmasıdır. Bunun sebebi, <command>#</command> karakteri ile ondalık noktanın solundaki alan genişliğinin verilmemiş olmasıdır; bu nedenle öntanımlı olarak boşluk kullanılmıştır. Aşağıdaki örnekte bu genişlik belirtilmiştir:
   </para><para>
<screen>
strfmon (buf, 100, &quot;@%=*11#5n@%=*11#5n@%=*11#5n@&quot;,
         123.45, -567.89, 12345.678);
</screen></para><para>
Çıktısı:
</para><para>
<screen>
&quot;@ $***123.45@-$***567.89@ $12,456.68@&quot;
</screen></para><para>
Görüldüğü üzere para sembolleri hizalandı ve para sembolü ile sayı arasındaki alan dolgu karakteri ile dolduruldu. Genişlik 5 seçildiğinden 123.45 için ondalik ayracın solundaki rakam sayısı bu değerden küçük olduğundan (5 e değil 11 karaktere tamamlanacak şekilde) artan alan yıldızlarla doldurulmuştur. Son sayıda ise binler ayracının genişliğe dahil olmadığı kanıtlanmaktadır. Son bir örnekle kalan işlevselliği açıklayalım:
   </para><para>
<screen>
strfmon (buf, 100, &quot;@%=0(16#5.3i@%=0(16#5.3i@%=0(16#5.3i@&quot;,
         123.45, -567.89, 12345.678);
</screen></para><para>
Bu karmaşık biçim dizgesi şu çıktıyı üretir:
   </para><para>
<screen>
&quot;@ USD 000123,450 @(USD 000567.890)@ USD 12,345.678 @&quot;
</screen></para><para>
Burada en önemli değişiklik negatif sayıları göstermekte kullanılan yöntemdir. Finansal çevrelerde bu çoğunlukla parantezler kullanılarak yapılır ve bu <command>(</command> imi ile seçilir. <command>0</command> karakterleri burada sayı için anlamlı haneler olmadıklarından bunlar arasında binler ayracı kullanılmamıştır. Biçim belirteci olarak <command>n</command> değil, <command>i</command> kullandığımızdan uluslararası para sembolü görüntülendi. Bu dört karakterlik (<command>&quot;USD &quot;</command>) bir dizgedir. Son nokta ise, ondalik ayracın sağındaki hane sayısı 3 olarak belirtildiğinden ilk iki sayıda sağa birer sıfır eklenirken, 3. sayıda yuvarlama yapılmamıştır.
   </para></chapter><chapter xml:id="glibc-Yes-or-No-Questions">
   <title>Evet/Hayır Yanıtları</title>
   <titleabbrev>Yanıtların yerele göre alınması.</titleabbrev>
   <para>
Grafiksel arayüzü olmayan bazı uygulamalarda evet ya da hayır olarak yanıtlanması gereken sorular olur. Eğer iletiler yabacı dillere çevriliyorsa, yanıtlarında yerelleştirilmesi gerekir. Soruyu bir dilde sorup, başka bir dilde (genellikle ingilizce) yanıt istemek tuhaf kaçar.
   </para><para>
GNU C kütüphanesi uygulamaların ilgili yerel tanımına kolayca erişebilmesini mümkün kılan <command>rpmatch</command> işlevini içerir.
  </para><para xml:id="glibc-rpmatch">
<indexterm scope="glibc-fn"><primary>rpmatch</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>rpmatch</command></funcdef>
<paramdef>(const char *<varname>yanıt</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>rpmatch</command> işlevi <varname>yanıt</varname> dizgesinde evet ya da hayır dizgelerinden birinin varlığını arar. Bu işlem seçili yerelin <command>LC_MESSAGES</command> kategorisindeki <command>YESEXPR</command> ve <command>NOEXPR</command> düzenli ifadeleri ile <varname>yanıt</varname> dizgesi karşılaştırılarak yapılır. İşlev şu değerlerden biri ile döner:
   </para><para><variablelist><varlistentry>
   <term><command>1</command></term><listitem><para>
Kullanıcı olumlu yanıt verdi.
      </para></listitem></varlistentry><varlistentry>
      <term><command>0</command></term><listitem><para>
Kullanıcı olumsuz yanıt verdi.
      </para></listitem></varlistentry><varlistentry>
      <term><command>-1</command></term><listitem><para>
Yanıt ne <command>YESEXPR</command> ne de <command>NOEXPR</command> düzenli ifadesine uyuyor.
      </para></listitem></varlistentry></variablelist>
    </para><para>
Bu işlev standartlaşmamıştır ama GNU C kütüphanesinde ve IBM AIX kütüphanesinde bulunmaktadır.
   </para><para>
Bu işlev normalde şöyle kullanılabilir:
   </para><para>
<screen>
...
/* Öntanımlı bir değerimiz olsun.  */
_Bool doit = false;

fputs (gettext ("Do you really want to do this? "), stdout);
fflush (stdout);
/* getline çağrısını hazırlayalım.  */
line = NULL;
len = 0;
while (getline (&amp;line, &amp;len, stdout) >= 0)
  {
    /* Yanıta bakalım.  */
    int res = rpmatch (line);
    if (res >= 0)
      {
        /* Yanıt olumluysa.  */
        if (res > 0)
          doit = true;
        break;
      }
  }
/* Yanıtı aldığımız diziyi serbest bırakalım.  */
free (line);
</screen></para><para>
Döngünün bir hata ya da olumlu veya olumsuz bir yanıt alınıncaya kadar sürdürüldüğüne dikkat edin.
   </para></funcdescr></funcsynopsis></para>
 </chapter>
</part>

