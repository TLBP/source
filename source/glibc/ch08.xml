<?xml version="1.0" encoding="UTF-8"?>

<!-- ********************************************************************
     $Id: ch08.xml,v 1.2 2002/12/20 22:29:48 nilgun Exp $
******************************************************************** -->
<part xml:id="glibc-Message-Translation">
  <title>İleti Çevirileri</title>
  <titleabbrev>Yazılım kullanıcının dilinde nasıl konuşturulur?</titleabbrev>
  <partintro><para>
Bir yazılımın kullanıcı arayüzü kullanıcının işini yapmasını kolaylaştıracak şekide tasarlanmalıdır. Arayüzü oluşturan iletilerin kullanıcının tercih ettiği dilde olması da bu kolaylıklardan biridir.
  </para><para>
İletilerin farklı dillerde gösterilmesi farklı yollarla gerçekleştirilebilir. Bunlardan biri tüm dilleri ve her iletinin bu dillerdeki çevirilerini yazılıma eklemektir. Bu pek de iyi bir çözüm değildir, çünkü dil kümesini genişletmek gerektiğinde işler zorlaşır (kodun değişmesi gerekir). Kodun kendisi ileti kümeleri arttıkça aşırı büyür.
  </para><para>
Daha iyi bir çözüm ileti kümelerini her dil için ayrı dosyalarda tutmak, kullanıcının seçimine bağlı olarak yazılımın çalışması esnasında iletileri bu dosyalardan yüklemektir.
  </para><para>
GNU C Kütüphanesi ileti çevirilerini destekleyen iki işlev ailesi içerir. Sorun bu amaca uygun bir arayüzün POSIX standardında resmen tanımlanmamış olmasıdır. <command>catgets</command> ailesi işlevler X/Open standardında tanımlanmış, ancak bu endüstriyel kararlarla oluşturulmuş ve bu bakımdan kabul edilebilir kararlara dayanması gerekmemiştir.
  </para><para>
Yukarıda kısaca bahsedildiği gibi ileti çevirilerini içeren harici veri dosyaları kullanılarak ileti kataloglarının kolayca genişletilebilmesi sağlanmıştır. Yani, bu dosyalar yazılımdaki her ileti için ilgili olduğu dilde birer çeviri içerir. Bu yapıya göre ileti işleme işlevlerinin görevleri:
  </para><para><itemizedlist><listitem>
Uygun çevirileri içeren harici dosyayı bulmak.
    </listitem><listitem>
Veriyi yüklemek ve çevirilerin adreslenebilmesini sağlamak.
    </listitem><listitem>
Belirtilen bir anahtarı çevrilmiş iletiye eşlemek.
    </listitem></itemizedlist>
Son adımın gerçeklenmesi açısından iki yaklaşım farklı davranır. Kalan her şey için tasarım kararları bunun etkisinde verilmiştir.
  </para></partintro>
  <chapter xml:id="glibc-Message-catalogs-a-la-X-Open">
  <title>X/Open İleti Kataloglarının İşlenmesi</title>
  <titleabbrev><command>catgets</command> işlev ailesi.</titleabbrev>
  <para>
<command>catgets</command> işlevleri basit bir şemaya dayanır:
   </para><blockquote><para>
Kaynak koddaki her ileti eşsiz bir belirteç kullanılarak çeviriyle ilişkilendirilir. İletinin katalog dosyasından alınmasında sadece bu belirteç kullanılır.
    </para></blockquote><para>
Bunun yazılımın geliştiricisi açısından anlamı, yazılımın kodunda ve ileti kataloğunda aynı olan her belirtecin anlamını bilmek zorunda kalmaktır.
   </para><para>
Bir ileti çevrilmeden önce katalog dosyası yüklenmiş olmalıdır. Yazılımın kullanıcısının işlevin kullanıcının istediği kataloğu bulmasına yardımcı olması gerekir. Bu yazılımcının yapması gereken işlerden değildir.
   </para><para>
<command>catgets</command> işlevleri ile ilgili veri türleri, sabitler ve işlevler <filename>nl_types.h</filename> başlık dosyasında tanımlanmış ya da bildirilmiştir.
   </para>
   <sect1 xml:id="glibc-The-catgets-Functions">
   <title><literal>catgets</literal> İşlevleri</title>
   <titleabbrev><command>catgets</command> işlev ailesi.</titleabbrev>
   <para xml:id="glibc-catopen">
<indexterm scope="glibc-fn"><primary>catopen</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>nl_catd <command>catopen</command></funcdef>
<paramdef>(const char *<varname>katalog</varname>,
 int         <varname>seçenek</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>catopen</command> işlevi <varname>katalog</varname> ile belirtilen ileti dosyalarını bulmaya çaılışır ve bulduğunda yükler.  Dönüş değeri geçirimsiz türdedir ve diğer işlev çağrılarında yüklü kataloğu belirtmek için kullanılabilir.
    </para><para>
İşlev başarısız olursa katalog yüklenmemiş demektir ve dönüş değeri<command>(nl_catd) -1</command>'dir. <varname>errno</varname> genel değişkeni başarısızlığın sebebini belirten bir hata kodu içerir. İşlev çağrısının başarılı olması katalogdaki tüm iletilerin çevrilmiş olduğu anlamına gelmez.
    </para><para>
Katalog dosyasının yeri yazılımın kullanıcısının kararını açıklaması sağlanarak belirlenir.  Kullanılacak dile karar vermek kullanıcıya bırakılır ve kimi zaman başka bir katalog dosyaları kullanmak yararlı olur. Bunun tamamı kullanıcı tarafından bazı ortam değişkenleri kullanılarak belirtilebilir.
    </para><para>
İlk sorun ileti kataloglarının bulunduğu yeri bulmaktır. Her yazılımın farklı dosyalar  için kendi yeri olabileceği gibi, katalog dosyaları dillere göre gruplanarak tüm yazılımlar için aynı bir yerde de tutulabilir.
    </para><para>
<indexterm scope="glibc-cp"><primary><command>NLSPATH</command> ortam değişkeni</primary></indexterm>
<command>catopen</command> işlevine yazılımın katalog dosyalarının nerede bulacağı kullanıcı tarafından <command>NLSPATH</command> ortam değişkenine yazılarak belirtilebilir. Bu değerin farklı dil ve yereller için kullanılabilir olması gerektiğinden, değer basit bir dizge olamayacaktır. Dizgenin kendine özgü bir biçimi vardır (<command>printf</command>'in biçim dizgesi gibi). Bir örnek:
    </para><para>
<literallayout indent="0">
    /usr/share/locale/%L/%N:/usr/share/locale/%L/LC_MESSAGES/%N
</literallayout></para><para>
Görüleceği üzere, iki nokta imleri ile ayırarak birden fazla dizin belirtilebilir. Biçim dizgesinde dikkati çeken ikinci durum <command>%L</command> ve <command>%N</command> belirteçleridir. <command>catopen</command> işlevi bunların çeşitlerini ve yerlerine neleri yerleştireceğini bilir.
    </para><para><variablelist><varlistentry>
    <term><command>%N</command></term><listitem><para>
Bu biçim elemanı katalog dosyasının isminin yerine geçer. Değeri, <command>catopen</command> işlevine belirtilen <varname>katalog</varname> argümanının değeridir.
       </para></listitem></varlistentry><varlistentry>
       <term><command>%L</command></term><listitem><para>
Bu biçim elemanı ileti çevirileri için seçili yerelin isminin yerine geçer. Bunun nasıl saptanacağı aşağıda anlatılmıştır.
       </para></listitem></varlistentry><varlistentry>
       <term><command>%l</command></term><listitem><para>
(Küçük L harfi.) Bu biçim elemanı yerel isminin dil elemanının yerine geçer. Seçili yereli betimleyen bu dizgenin şu biçimde olması beklenir:
</para><para>
<literallayout>
<varname>dil</varname>[_<varname>ülke</varname>[.<varname>karakter_kümesi</varname>]]
</literallayout>
</para><para>
Bu biçim elemanı bu dizgenin <varname>dil</varname> parçasını ifade eder.
       </para></listitem></varlistentry><varlistentry>
       <term><command>%t</command></term><listitem><para>
Bu biçim elemanı yerel isminin <varname>ülke</varname> elemanının yerine geçer. Yerel isminin biçimi yukarda verilmişti.
       </para></listitem></varlistentry><varlistentry>
       <term><command>%c</command></term><listitem><para>
Bu biçim elemanı yerel isminin <varname>karakter_kümesi</varname> elemanının yerine geçer. Yerel isminin biçimi yukarda verilmişti.
       </para></listitem></varlistentry><varlistentry>
       <term><command>%%</command></term><listitem><para>
<command>%</command> karakteri bir önceleme karakteri gibi kullanıldığından kendisini de öncelemesi gerekir. <command>%%</command> belirteci aynen <command>printf</command> işlevindeki gibi çalışır.
       </para></listitem></varlistentry></variablelist>
     </para><para>
<command>NLSPATH</command> kullanılarak, kullanılacak farklı dillerin ileti kataloglarının aranacağı dizinler keyfi olarak belirlenebilir. Eğer <command>NLSPATH</command> ortam değişkeni ortamda mevcut değilse, öntanımlı değeri:
    </para><para>
<literallayout> <varname>önek</varname>/share/locale/%L/%N:<varname>önek</varname>/share/locale/%L/LC_MESSAGES/%N
</literallayout></para><para>
Burada <varname>önek</varname>, GNU C kütüphanesi derlenirken <command>configure</command> betiğine <command>--prefix</command> seçeneğinde belirtilen dizindir (bu dizin çoğu zaman ya <command>/usr</command> ya da boş dizgedir).
    </para><para>
Sorun artık hangisinin kullanılacağına karar vermektir. Karar, yukarıda bahsedilen biçim elemanlarının nelerle ikame edileceğidir. Herşeyden önce, ileti kataloğunun ismi içinde bir dosya yolu belirtebilir (yani dosya ismi bölü işaretleri içerir). Bu durumda <command>NLSPATH</command> ortam değişkeni kullanılmaz. Katalog yazılımda belirtildiği gibi mevcut olmalıdır; şüphesiz, bu çalışma dizinine görelidir. Bu istenen bir durum değildir ve katalog isimleri bu yöntemle yazılmamalıdır. Bununla beraber, <command>catgets</command> arayüzünü kullanan platformlar bakımından bu davranış taşınabilir olmayacaktır.
    </para><para>
<indexterm scope="glibc-cp"><primary><command>LC_ALL</command> ortam değişkeni</primary></indexterm>
<indexterm scope="glibc-cp"><primary><command>LC_MESSAGES</command> ortam değişkeni</primary></indexterm>
<indexterm scope="glibc-cp"><primary><command>LANG</command> ortam değişkeni</primary></indexterm>
Aksi takdirde, <link linkend="glibc-Standard-Environment">standart ortamdaki</link> ortam değişkenlerinin değerlerine bakılır. Hangi değişkenlere bakılacağına <command>catopen</command> işlevinin <varname>seçenek</varname> parametresine bakarak karar verilir. Eğer bu değer <command>NL_CAT_LOCALE</command> (<filename>nl_types.h</filename> dosyasında tanımlıdır) ise, <command>catopen</command> işlevi <command>LC_MESSAGES</command> kategorisi için seçili yerelin ismini kullanır.
    </para><para>
Eğer <varname>seçenek</varname> sıfırsa <command>LANG</command> ortam değişkenine bakılır. Bu davranış, yerel kavramının POSIX yerelleri seviyesinde henüz aşılamadığı erken dönemlerden günümüze ulaşmıştır.
    </para><para>
Ortam değişkeninin içerdiği yerel ismi yukarıda açıklandığı gibi <literal><emphasis>dil</emphasis>[_<emphasis>ülke</emphasis>[.<emphasis>karakter_kümesi</emphasis>]]</literal>biçiminde olmalıdır. Hiç ortam değişkeni bulunamazsa, çevirilerin kullanılmayacağı anlamına gelen <command>&quot;C&quot;</command> yereli kullanılır.
    </para><para>
Bir hata oluştuğunda <varname>errno</varname> genel değişkenine şunlar atanabilir:
    </para><para><variablelist><varlistentry>
    <term><literal>EBADF</literal></term><listitem><para>
Katalog mevcut değil.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>ENOMSG</literal></term><listitem><para>
Set/ileti demeti ileti kataloğundaki mevcut bir elemanın ismi değil.
       </para></listitem></varlistentry></variablelist></para><para>
Kimi zaman hatalara karşı sınama yapmak faydalı olduğu halde yazılımlar normalde herhangi bir sınamadan kaçınacaktır. Bir çevirinin yokluğu özgün ileti varsa sorun olmaz, çevrilmemiş ileti basılır. Bu durumu kullanıcı ya olduğu gibi kabul eder ya da iletinin neden çevrilmediğini araştırır.
</para></funcdescr></funcsynopsis></para><para>
Lütfen dikkat edin, o an seçili yerelin saptanması ve çeviri kataloğunun bulunması için  <command>setlocale</command> çağrısı yapmak gerekmez. <command>catopen</command> işlevi bu değerleri ortam değişkenlerinden doğrudan kendisi okur.
    </para><para xml:id="glibc-catgets">
<indexterm scope="glibc-fn"><primary>catgets</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>char *<command>catgets</command></funcdef>
<paramdef>(nl_catd     <varname>katalogtanıtıcı</varname>,
 int         <varname>set</varname>,
 int         <varname>ileti</varname>,
 const char *<varname>dizge</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>catgets</command> işlevi önceki bir <command>catopen</command> çağrısı ile açılmış ileti kataloğuna erişmekte kullanılır. <varname>katalogtanıtıcı</varname> parametresi önceki bir <command>catopen</command> çağrısının dönüş değeri olmalıdır.
    </para><para>
Sonraki iki parametre, <varname>set</varname> ve <varname>ileti</varname>, ileti kataloğu dosyalarının iç düzeni ile ilgilidir. Bu aşağıda ayrıntılı olarak açıklanmıştır. Şimdilik, kataloğun çeşitli set ve iletiler içeren herbiri numaralanmış evrelerden oluştuğunu bilmemiz yeterli olacaktır. Ne set numarasının ne de ileti numarasının bir önemi vardır. Keyfi olarak seçilmiş olabilirler. Fakat her iletinin (başka biriyle aynı olmadıkça) kendine özel eşsiz bir set/ileti çifti ve ileti numarası olmalıdır.
    </para><para>
Kullanıcı tarafından seçilen dil için ileti kataloğunun bulunacağı garanti olmadığından son parametre olan <varname>dizge</varname> ile bu duruma bir çözüm getirilmiştir. Eğer ileti ile eşleşen bir dizge bulunamazsa <varname>dizge</varname> döndürülür.  Bunu yazılımcı açısından anlamı:
    </para><para><itemizedlist><listitem>
<varname>dizge</varname> parametresi kabul edilebilir bir metin içermelidir (bu ayrıca umulan dizge dönmediğinde bu duruma dair bir ipucu elde edilmesini sağlayabilmelidir).
      </listitem><listitem>
tüm <varname>dizge</varname> argümanları aynı dilde yazılmış olmalıdır.
      </listitem></itemizedlist></para><para>
<command>catgets</command> işlevinin dönüş değeri her durumda geçerli bir dizgedir. Ya ileti kataloğundaki bir çeviridir ya da <varname>dizge</varname> parametresi ile belirtilendir. Çevirinin kullanılıp kullanılmayacağına karar veren kod şöyledir:
    </para><para>
<screen>
{
  char *trans = catgets (desc, set, msg, input_string);
  if (trans == input_string)
    {
      /* Birşeyler yanlış gitmiş.  */
    }
}
</screen>
</para></funcdescr></funcsynopsis></para><para>
Destekleyici bir işlevsellik olmadıkça <command>catgets</command> işlevlerini kullanarak  yazılım geliştirmek biraz tatsız olur. Her set/ileti numarası demetinin eşsiz olması gerektiğinden yazılımcı kodu yazarken aynı zamanda iletilerin listesini de tutmalı ve aynı proje üzerinde çalışan yazılımcılar arasında koordinasyon sağlanmış olmalıdır. Bunun nasıl biraz daha esnetilebileceğini <xref linkend="glibc-Common-Usage"/> bölümünde göreceğiz.
    </para><para xml:id="glibc-catclose">
<indexterm scope="glibc-fn"><primary>catclose</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>catclose</command></funcdef>
<paramdef>(nl_catd <varname>katalogtanıtıcı</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>catclose</command> işlevi önceki bir <command>catopen</command> çağrısı ile açılmış bir ileti kataloğu ile ilgili özkaynakları serbest bırakmakta kullanılır. Eğer özkaynaklar başarıyla serbest bırakılmışsa işlev <command>0</command> ile aksi takdirde <command>-1</command> ile döner ve <varname>errno</varname> değişkenine hata durumu atanır.  Eğer <varname>katalogtanıtıcı</varname> ile belirtilen katalog tanıtıcı geçersizse, <varname>errno</varname> değişkenine <command>EBADF</command> atanır.
       </para></funcdescr></funcsynopsis></para></sect1>
       <sect1 xml:id="glibc-The-message-catalog-files">
       <title>İleti Kataloğu Dosyalarının Biçimi</title>
       <para>
Bir yazılımın tüm iletilerinin çevrilmesinin kabul edilebilir tek yolu, iletileri bir ileti kataloğu dosyasında toplamak ve bunu çevirmenin çevirmesini sağlamaktır. Yani, belli bir çeviri ile set/ileti çiftini ilişkilendiren girdilerden oluşan bir dosyamız olmalıdır. Bu dosyanın biçimi X/Open standardında şöyle belirlenmiştir:
    </para><para><itemizedlist><listitem><para>
Boş satırlar ve sadece boşluk karakterleri içeren satırlar yoksayılır.
      </para></listitem><listitem><para>
Satırın başında bir <command>$</command> karakterinden sonra boşluk geldiğinde satırın kalanının bir açıklama içerdiği varsayılır ve bu satırlar da yoksayılır.
      </para></listitem><listitem><para>
Satır <command>$set</command> ile başlıyorsa bunu bir boşluk karakteri ile bir argüman izlemelidir. Bu argüman şunlardan biri olabilir:
      </para><para><itemizedlist><listitem><para>
Bir sayı.  Bu sayının değeri altındaki iletiler bir küme oluşturur.
        </para></listitem><listitem><para>
Alfanümerik karakterlerle alt çizgi karakterinden oluşabilen bir belirteç. Bu durumda ileti kümesinin numarası özdevinimli olarak atanır. Bu değer o kümeye kadar belirtilenlerden büyük bir sayı olmalıdır.
        </para><para>
Sembolik isimlerin nasıl kullanıldığı <xref linkend="glibc-Common-Usage"/> bölümünde açıklanmıştır.
        </para><para>
Bir sembol ismi birden fazla varsa bu bir hatadır. Bir kümenin içerdiği tüm iletiler bu numara altında toplanır.
        </para></listitem></itemizedlist>
      </para></listitem><listitem><para>
Satır <command>$delset</command> ile başlıyorsa bunu bir boşluk karakteri ile bir argüman izlemelidir. Bu argüman şunlardan biri olabilir:
      </para><para><itemizedlist><listitem><para>
Bir sayı.  Bu sayının değeri altındaki iletilerin oluşturduğu kümenin silineceğini belirtir.
        </para></listitem><listitem><para>
Alfanümerik karakterlerle alt çizgi karakterinden oluşabilen bir belirteç. Bu sembolik belirteç evvelce tanımlanmış bir küme ismi olmalıdır. İsim bilinmiyorsa bu bir hatadır.
        </para></listitem></itemizedlist>
      </para><para>
Her iki durumda da belirtilen kümelerdeki tüm iletiler silinir ve çıktıda görünmezler. Fakat bu küme daha sonra tekrar <command>$set</command> komutu ile seçilerek içerdiği iletilerin tekrar çıktılanması sağlanabilir.
      </para></listitem><listitem><para>
Satır <command>$quote</command> ile başlıyorsa bunu bir boşluk karakteri ile girdi dosyasında tırnak karakteri olarak kullanılacak karakter izlemelidir. Satır boşluktan farklı bir karakter ile bitmiyorsa dosyada tırnaklar iptal edilir.
      </para><para>
Öntanımlı olarak bir tırnak karakteri yoktur. Bu kipte dizgeler öncelenmemiş ilk satırsonu karakterinde biter. Eğer bir <command>$quote</command> belirtimi varsa satırsonu karakterlerinin öncelenmesi gerekmez. Bu durumda dizge öncelenmemiş ilk tırnak karakterinde biter.
      </para><para>
Bu özelliğin çok kullanılan bir kullanımı  tırnak karakteri olarak <command>&quot;</command> belirtmektir.  Dizge içinde bir <command>&quot;</command> karakteri kullanmak gerekirse <command>\&quot;</command>  şeklinde tırnak işareti tersbölü ile öncelenmelidir.
      </para></listitem><listitem><para>
Bunların dışında satırlar bir sayı veya bir alfanümerik sözcük (alt çizgi dahil) ile başlayabilir. İlk boşluk karakterinden hemen sonra ileti dizgesi gelir. Satırın başındaki sözcük ya da sayı iletinin numarasını ifade eder.
      </para><para>
Eğer satır bir sayı ile başlıyorsa bu açıkça iletinin numarasıdır. İleti kümesi içinde aynı numaralı ileti birden fazla varsa bu bir hatadır.
      </para><para>
Eğer satır bir sözcük ile başlıyorsa ileti numarası özdevinimli olarak atanır. Değeri iletiyi içeren kümedeki en büyük numaralı iletinin numararasının bir fazlasıdır. Bir ileti kümesi içinde aynı sözcük birden fazla ileti için kullanılmışsa bu bir hatadır. Ama aynı sözcük başka bir küme içinde kullanılabilir. Sembolik belirteçlerin nasıl kullanıldığı <xref linkend="glibc-Common-Usage"/> bölümünde anlatılmıştır.  Belirteç ile ilgili bir sınırlama vardır: Bu, <command>Set</command> olmamalıdır.  Bunun sebebi ilerde açıklanacaktır.
      </para><para>
İleti metni öncelenmiş karakterleri içerebilir. Bunlar ISO C dilinde tanınan karakterlerdir (<command>\n</command>, <command>\t</command>, <command>\v</command>, <command>\b</command>, <command>\r</command>, <command>\f</command>, <command>\\</command> ve <command>\<varname>nnn</varname></command>, burada <varname>nnn</varname> karakterin sekizlik kodudur).
      </para></listitem></itemizedlist>
    </para><para>
<important><para>Set ve iletiler için sayılar yerine belirteçlerin belirtilebilmesi bir GNU oluşumudur. X/Open standardına sıkı sıkıya bağlı sistemlerde bu özellik yoktur. Bir ileti kataloğu dosyası örneği:
    </para><para>
<screen linenumbering="numbered">
$ Bu bir açıklamadır.
$quote &quot;

$set SetOne
1 Numarası 1 olan ileti.
two &quot;   Kimliği \&quot;two\&quot; olan ileti, buna 2 değeri atanacaktır&quot;

$set SetTwo
$ Önceki Set'in numarası 1 oldu, bununki 2 olacaktır.
4000 &quot;Numaralar keyfidir, 1'den başlamaları gerekmez.&quot;
</screen></para><para>
Bu küçük örnekte görünenler:
    </para><para><itemizedlist><listitem>
1. ve 9. satır <command>$</command> işaretinden sonra bir boşluk içerdiğinden birer açıklamadır.
      </listitem><listitem>
Tırnak karakteri olarak <command>&quot;</command> atanmıştır.  Aksi takdirde ileti tırnak içine alınamayacağından <command>two</command> kimlikli iletinin başındaki boşluklar gösterilemeyecekti.
      </listitem><listitem>
Numaralı iletilerle sembolik isimli iletilerin karışık kullanılması bir sorun oluşturmaz, numaralama özdevinimli olarak yapılacaktır.
      </listitem></itemizedlist></para></important>
    </para><para>
Bu dosya biçimi çok kolay görünmesine rağmen bir çalışan yazılımda kullanmak için yeterli değildir. <command>catopen</command> işlevi dosyayı çözümlemeli ve sözdizimsel hataları en iyi şekilde elde etmelidir. Bu öyle kolay değildir ve işlem oldukça yavaştır. Bu bakımdan <command>catgets</command> işlevleri verinin daha bütünleşik ve kullanıma hazır bir dosya biçiminde olmasını umar. Bunun için ayrıntıları sonraki bölümde açıklanacak olan özel bir uygulama,  <command>gencat</command> vardır.
    </para><para>
Bu biçimdeki dosyalar insanlarca okunabilir değildir. Yazılımlar tarafından kolayca kullanılabilmeleri için ikilik biçimdedirler. Fakat biçimin bayt sıralaması dosyaların bulunduğu sisteme bağlıdır.
    </para><para>
İkilik dosyanın biçimi hakkında ayrıntıya girmeyeceğiz, çünkü bu dosyalar daima <command>gencat</command> uygulaması tarafından oluşturulurlar. GNU C Kütüphanesinin kaynak kodunda <command>gencat</command> uygulamasının kaynak kodu da bulunduğundan, çok meraklıysanız, dosyanın biçimi hakkında fikir edinmek için kaynak kodunu inceleyebilirsiniz.
    </para></sect1>
    <sect1 xml:id="glibc-The-gencat-program">
    <title>İleti Kataloğu Dosyalarının Üretilmesi</title>
    <titleabbrev>İşlevler tarafından kullanılmak üzere ileti katalogları nasıl üretilir?</titleabbrev>
    <para>
<indexterm scope="glibc-cp"><primary><command>gencat</command> uygulaması</primary></indexterm>
<command>gencat</command> uygulaması X/Open standardında belirtilmiştir ve GNU gerçeklemesi bu belirtime uygundur. Fazladan, <command>catgets</command>  işlevlerinin daha makul şekilde çalışmasına yardımcı olacak ek oluşumlarla gerçeklenmiştir.
    </para><para>
<command>gencat</command> yazılımı iki yolla çalıştırılabilir:
    </para><para>
<literallayout indent="0">
    `<command>gencat </command>[<varname>seçenek</varname>]… [<varname>çıktı-dosyası</varname> [<varname>girdi-dosyası</varname>]…]`
</literallayout></para><para>
Bu, X/Open standardında tanımlı arayüzdür. <varname>çıktı-dosyası</varname> parametresi verilmezse girdi standart girdiden okunur. Çok sayıda girdi dosyası belirtilebilir. Eğer <varname>çıktı-dosyası</varname> verilmemişse çıktılama için standart çıktı kullanılır. Başka yazılımlardan kullanmak için ikinci bir arayüz sağlanmıştır.
    </para><para>
<literallayout indent="0">
    `<command>gencat </command>[<varname>seçenek</varname>]… <command>-o</command> <varname>çıktı-dosyası</varname> [<varname>girdi-dosyası</varname>]…`
</literallayout></para><para>
<command>-o</command> seçeneği çıktı dosyasını belirtmek için kullanılır ve belirtilen diğer bütün dosyalar girdi dosyası olarak kullanılır.
    </para><para>
Bunlardan başka, <varname>girdi-dosyası</varname> olarak <command>-</command> veya <command>/dev/stdin</command> belirtilirse, girdi standart girdiden alınır. Aynı şekilde, <varname>çıktı-dosyası</varname> olarak <command>-</command> veya <command>/dev/stdout</command> belirtilirse, çıktılama standart çıktıya yapılır. <command>-</command> kullanımı X/Open standardında bir dosya ismi olarak ele alındığı halde, aygıt ismi olarak kullanımı bir GNU oluşumudur.
    </para><para>
<command>gencat</command> uygulaması tüm girdi dosyalarını bibirine ekleyerek çalışır ve bu iletileri çıktı dosyasındakilerle biraraya getirir. Bu işlem çıktı dosyasında zaten mevcut olan Set/ileti demetlerini silip, olmayanları çıktıya ekleyerek yapılır.  Bu işlem, eski eşleşen Set/ileti demetleri kaldırılarak yapıldığından çıktı dosyasının tamamen boşalmasına bile sebep olabilir. Çıktılama standart çıktıya yapılıyosa bu biraraya getirme işlemi yapılmaz.
    </para><para>
Burada <command>gencat</command> uygulamasının tanıdığı seçeneklere yer verilmiştir. X/Open standardında uygulama için herhangi bir seçenek tanımlanmadığından bu seçeneklerin hepsi GNU oluşumudur.
    </para><para><glosslist><glossentry>
    <glossterm><command>-V</command></glossterm>
    <glossterm><command>--version</command></glossterm>
    <glossdef><para>
Sürüm bilgilerini basar ve çıkar.
    </para></glossdef></glossentry><glossentry>
    <glossterm><command>-h</command></glossterm>
    <glossterm><command>--help</command></glossterm>
    <glossdef><para>
Bir kullanım iletisi basar ve çıkar.
    </para></glossdef></glossentry><glossentry>
    <glossterm><command>--new</command></glossterm>
    <glossdef><para>
Girdi dosyalarındaki yeni iletileri çıktı dosyasındaki eski iletilerle birleştirmez. Çıktı dosyasının eski içeriği silinir.
    </para></glossdef></glossentry><glossentry>
    <glossterm><command>-H </command><varname>name</varname> </glossterm><glossterm>
    <literal><command>--header</command>=<emphasis>isim</emphasis></literal>
    </glossterm><glossdef><para>
Bu seçenekle, yazılımda kullanmak için girdi dosyalarındaki Set'lerin ve iletilerin sembolik isimleri çıktılanır. Bu isimlerin nasıl kullanıldığı sonraki bölümde açıklanmıştır. Seçenekte <varname>name</varname> parametresi ile çıktı dosyasının ismi belirtilir. Çıktı dosyasında isimleri numaralarla eşleyen <command>#define</command> yönergeleri bulunur.
       </para><para>
Üretilen dosyanın sadece girdi dosyalarındaki sembolleri içereceğine dikkat edin. Eğer, çıktı dosyası önceki çıktı dosyasındakilerle katıştırılarak elde ediliyorsa, hem girdi dosyalarında hem de eski çıktı dosyasında bulunan iletilerin sembolleri üretilen başlık dosyasında bulunmayacaktır.
       </para></glossdef></glossentry></glosslist></para></sect1>
       <sect1 xml:id="glibc-Common-Usage">
       <title><literal>catgets</literal> Kullanımı</title>
       <titleabbrev><command>catgets</command> arayüzü nasıl kullanılır?</titleabbrev>
       <para>
<command>catgets</command> işlevleri iki farklı yolla kullanılabilir: X/Open belirtiminden hiç sapmadan ve GNU oluşumlarını kullanarak. Önce ilk yöntemin nasıl kullanıldığına bakacağız, böylece ikinci yöntemin yani GNU oluşumlarının getirilerini daha iyi anlayabileceğiz.
    </para>
    <sect2><title>Sembolik isimleri kullanmadan</title><para>
İleti X/Open biçimi katalog dosyalarında sembolik isimlere izin verilmediğinden bu seferlik sadece numaralarla çalışacağız. Yazılımı geliştirmeye başlarken çevrilebilir dizgelerin hepsini şu biçimde bir kodla değiştirmelisiniz:
     </para><para>
<screen>catgets (catdesc, set, msg, &quot;dizge&quot;)</screen>
     </para><para>
<varname>catdesc</varname> parametresi, yazılım başında normalde bir kere yapılan bir <command>catopen</command> çağrısından alınır. <varname>"dizge"</varname> çevirlecek dizgedir. Set ve ileti numaralarının başlatılması sorun olur.
     </para><para>
Büyükçe bir yazılımda aynı anda çok sayıda geliştirici çalışırsa numara ayırma işleminin eşgüdümü önem kazanır. Aynı demet numarası ile iki farklı dizge indislenemediğinden, birbirinin aynı dizgeler ile birbirinin aynı çeviriler için numaraların yeniden kullanılması tercih edilir. (Bir dilde aynı olan dizgeler başka bir dilde bağlama bağlı olarak farklı dizgeler olabilir; bir de bu var...)
     </para><para>
Numara ayırma işlemi yazılımın farklı parçalarında farklı Set numaraları kullanılarak biraz olsun rahatlatılabilir. Böylece eşgüdümlenecek geliştirici sayısı düşürülebilir. Yine de ayırma ile ilgili listeler tutulabilir ve hataların giderilmesi kolaylaştırılabilir. Bu hatalar derleyici ya da <command>catgets</command> işlevleri tarafından saptanamaz. Sadece yazılımın kullanıcısı yanlış iletinin basıldığını görür. En kötü durumda, yanlış olarak tanımlanamayan iletiler çok sinir bozucu olabilir. Doğrularla yanlışlar birbirine karışır ve bu bir felaketle sonuçlanır.
     </para></sect2>
     <sect2><title>Sembolik isimleri kullanarak</title><para>
Önceki bölümde bahsedilen sorunlardan şu sonuçları çıkarabiliriz:
     </para><para><orderedlist><listitem><para>
Numaralar bir kere ayrıldıktan sonra onları değiştirmek gerekirse bu çok zor olur.
       </para></listitem><listitem><para>
Numaralar dizgenin içeriği hakkında hiçbir fikir vermediğinden karışıklıklar olabilir.
       </para></listitem></orderedlist>
     </para><para>
Sürekli olarak sembolik isimleri kullanarak ve dizge içeriğini bir sembolik isimle eşleyen bir yöntem sağlanarak bu iki sorundan kurtulmak mümkündür. Bu yöntemim yazılımcıya maliyeti yazılımı geliştirirken bir yandan da ileti kataloğunu yazmasıdır.
     </para><para>
Yazılım derlenmeden önce sembolik isimlerin numaralarla eşleştirilmesi gerektiğinden bunun böyle olması gerekir. Önceki bölümde <command>gencat</command> uygulaması tanıtılırken isimlerle eşleşmeleri içeren bir başlık dosyasının nasıl üretileceğinden bahsedilmişti. Örneğin, önceki örnekteki katalog dosyasının isminin <filename>ex.msg</filename> olduğu kabul ederek,
     </para><para>
<screen>gencat -H ex.h -o ex.cat ex.msg</screen>
     </para><para>
komutuyla şu içeriğe sahip bir başlık dosyası üretilir:
     </para><para>
<screen>
#define SetTwoSet 0x2   /* ex.msg:8 */

#define SetOneSet 0x1   /* ex.msg:4 */
#define SetOnetwo 0x2   /* ex.msg:6 */
</screen></para><para>
Görüldüğü gibi, kaynak dosyasında verilen sembollerden eşsiz belirteçler üretmek için yeni semboller elde edilmiş ve bunlar numaralara atanmıştır. Kaynak dosyayı okuyarak ve kuralları bilerek başlık dosyasının içeriğini tahmin etmek mümkündür ama bu gerekli değildir. <command>gencat</command> uygulaması herşeyi dikkatlice yapabilir. Bütün geliştiriciler, projenin kaynak dosyalarının bağımlılık listesine üretilen başlık dosyasını koymalı ve girdi dosyaları değiştiğinde başlığı üretecek kuralları eklemelidir.
     </para><para>
Sembollerden makro isimlerinin elde edilmesi ile ilgili olarak da bir kaç laf etmek lazım. Her makro ismi iki parçadan oluşur: İleti kümesinin ismi artı iletinin ismi ya da özel bir dizge olarak <command>Set</command>. Yani, <command>SetOnetwo</command> makrosu ile ileti katalog dosyasındaki <command>SetOne</command> ileti kümesinin <command>two</command> isimli iletisine erişilir.
     </para><para>
Diğer isimler ileti kümelerinin isimlerini belirtir. Özel <command>Set</command> dizgesi ileti belirtecinin yerine kullanılır.
     </para><para>
Eğer koddaki <command>SetOne</command> kümesinin ikinci dizgesi C kodunda kullanılmak istenirse şöyle yapılırdı:
     </para><para>
<screen>
catgets (catdesc, SetOneSet, SetOnetwo,
         "   Kimliği \"two\" olan ileti, buna 2 değeri atanacaktır")
</screen></para><para>
İşlevin bu yöntemle yazılması C kaynak kodunda herhangi bir değişiklik gerekmeksizin ileti numarasını hatta Set numarasını değiştirmek mümkün olacaktır. (Dizgenin metni normalde aynı görünür; bu sadece bu örnek içindir.)
     </para></sect2>
     <sect2><title>Bunları yazılım geliştirirken nasıl kullanacağız?</title><para>
Sembolik sürüm numaraları ile çalışma yöntemini göstermek için burada küçük bir örneğe yer verdik. Çok karmaşık ve ünlü bir selamlama yazılımını yazmak istediğimizi varsayalım. Koda şöyle başlardık:
     </para><para>
<screen>
#include &lt;stdio.h>
int
main (void)
{
  printf ("Hello, world!\n");
  return 0;
}
</screen></para><para>
Şimdi iletileri uluslararasılaştıralım ve böylece kullanıcı iletiyi kendi diline çevirebilsin.
     </para><para>
<screen>
#include &lt;nl_types.h>
#include &lt;stdio.h>
#include "msgnrs.h"
int
main (void)
{
  nl_catd catdesc = catopen ("hello.cat", NL_CAT_LOCALE);
  printf (catgets (catdesc, SetMainSet, SetMainHello,
                    "Hello, world!\n"));
  catclose (catdesc);
  return 0;
}
</screen></para><para>
Katalog nesnesinin nasıl açıldığını ve diğer işlev çağrılarında kullanılacak tanımlayıcının nasıl döndürüldüğünü görüyoruz. Buradaki işlevler makul davranacağından işlevlerde herhangi bir başarısızlık sınaması yapmamız aslında gerekmiyor. Sadece bir çeviri döndürecekler.
     </para><para>
Burada <command>SetMainSet</command> ve <command>SetMainHello</command> sabitleri belirsiz kaldı. Bunlar iletiyi tanımlayan sembolik isimlerdir. Katalog dosyasındaki bilgiyle eşleşen gerçek tanımlarını elde etmek için ileti kataloğunu oluşturup onu <command>gencat</command> uygulaması ile işlemeliyiz.
     </para><para>
<screen>
$ Turkish messages for the famous greeting program.
$quote &quot;

$set Main
Hello &quot;Merhaba Dünyalı!\n&quot;
</screen></para><para>
Yazılımımızı artık derleyebiliriz. Katalog kaynak dosyasının isminin <filename>hello.msg</filename> ve yazılım kaynak dosyasının isminin <filename>hello.c</filename> olduğunu varsayıyoruz:
     </para><para>
<screen>
$ <command>gencat -H msgnrs.h -o hello.cat hello.msg</command>
$ <command>cat msgnrs.h</command>
#define MainSet 0x1     /* hello.msg:4 */
#define MainHello 0x1   /* hello.msg:5 */
$ <command>gcc -o hello hello.c -I.</command>
$ <command>cp hello.cat /usr/share/locale/tr/LC_MESSAGES</command>
$ <command>echo $LC_ALL</command>
tr
$ <command>./hello</command>
Merhaba Dünyalı!
$
</screen></para><para>
<command>gencat</command> çağrısı ile ileti kataloğunun ikilik biçimi ile birlikte <filename>msgnrs.h</filename> başlık dosyasını da elde ettik. İlk olarak <filename>hello.c</filename>'yi derledik, sonra da <filename>hello.cat</filename>'i <command>catopen</command> işlevinin bulabileceği yere yerleştirdik. Katalog dosyasını doğru yere yerleştirip yerleştirmediğimizi <command>LC_ALL</command> ortam değişkeninin değerine bakarak sınamayı unutmuyoruz. (Ç.N. -- Özgün metinde "tr" değil "de" var ama "de" değerli bir "LC_ALL" ne kadar mümkün?; yazar burada biraz dikkatsizmiş sanırım. Değişken LC_ALL değil LANGUAGE olmalıydı, çünkü LC_ALL ortam değişkeninin değeri normalde bir boş dizgedir; ortam değişkeni olarak anlamlı değildir ama bir C makrosu olarak anlamlıdır.)
     </para></sect2></sect1>
   </chapter>
   <chapter xml:id="glibc-The-Uniforum-approach">
     <title>İleti Çevirilerinde Uniforum Yaklaşımı</title>
     <titleabbrev><command>gettext</command> işlev ailesi.</titleabbrev>
     <para>
Sun Microsystems, Uniforum grubunda ileti çevirilerine farklı bir yaklaşımı standarlaştırmaya çalıştı. Gerçek bir standart hiç tanımlanmamıştı, ama bu arayüz hala Sun'ın işletim sistemlerinde kullanılıyordu. Açık kaynak kod geliştirenlere bu yaklaşım daha iyi bir geliştirme ortamı sağladığı için GNU projelerinde kullanılmaya başlandı ve GNU C kütüphanesi dışında buna destek olmak için GNU <command>gettext</command> paketi oluşturuldu.
   </para><para>
GNU <command>gettext</command>'teki <command>libintl</command> kodu, GNU C kütüphanesindeki kod ile aynıdır. Bu bakımdan GNU <command>gettext</command> kılavuzundaki bilgiler ayrıca buradaki işlevsellik için de geçerlidir. Bu kısımda kütüphane işlevlerini ayrıntılı olarak açıklayacağız, ama çok sayıdaki yardımcı uygulamayı bu kılavuzda açıklamayacağız. Ayrıntılarla ilgilenenlerin  GNU <command>gettext</command> kılavuzuna bakmalarını öneririz. Burada bunların sadece kısa bir tanıtımını yapacağız.
   </para><para>
<command>catgets</command> işlevleri çoğu sistemde öntanımlı olarak bulunmasına rağmen <command>gettext</command> arayüzü de en azından onun kadar taşınabilirdir. İşlevlerin bulunmadığı yerlerde GNU <command>gettext</command> paketi kullanılabilir.
   </para>
   <sect1 xml:id="glibc-Message-catalogs-with-gettext">
   <title><literal>gettext</literal> İleti Katalogları</title>
   <titleabbrev><command>gettext</command> işlev ailesi</titleabbrev>
   <para/><para>
İleti çevirilerine <command>gettext</command> yaklaşımının altında yatan paradigmalar, temel işlevsellik bakımından eşdeğeri olan <command>catgets</command> işlevlerinden farklıdır.
    </para><sect2 xml:id="glibc-Translation-with-gettext" chunkthis="1">
    <title><literal>gettext</literal> ile Çeviri</title>
    <titleabbrev>Bir iletiyi çevirmek için ne yapılmalı?</titleabbrev><para>
<command>gettext</command> işlevlerinin çok basit bir arayüzü vardır. En temel işlev argüman olarak sadece çevrilecek dizgeyi alır ve onun çevirisi ile döner. Bu, özgün dizgenin sadece hata durumunda kullanıldığı, normalde ek bir anahtar gerektiren <command>catgets</command> yaklaşımından en temel farktır.
     </para><para>
Çevrilecek dizgenin tek argüman olması şüphesiz dizgenin kendisinin bir anahtar olduğu anlamına gelir. Bundan dolayı ileti kataloglarının hem özgün dizgeyi hem de çeviriyi içermesi gerekir. <command>gettext</command> işlevinin görevi argüman olarak verilen dizgeyi ileti kataloğundaki dizgelerle karşılaştırıp o dizgeye ait çeviriyi döndürmektir. Şüphesiz bu işlem eniyilenmiştir, dolayısıyla bu işlem <command>catgets</command>'deki gibi bir atomik anahtarla erişim sağlamaktan daha pahalıya malolmaz.
     </para><para>
<command>gettext</command> yaklaşımının getirileri olduğu gibi götürüleri de vardır. Bu konuda daha fazla ayrıntı için  GNU <command>gettext</command> kılavuzuna bakınız.
     </para><para>
<command>gettext</command> ile ilgili tüm tanım ve bildirimler <command>libintl.h</command> başlık dosyasında bulunabilir. Bu işlevlerin C kütüphanesinin bir parçası olmayan sistemlerde <command>libintl.a</command> isimli ayrı bir kütüphane olarak (ya da paylaşımlı bir kütüphane olarak) bulunabilir.
     </para><para xml:id="glibc-gettext">
<indexterm scope="glibc-fn"><primary>gettext</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>char *<command>gettext</command></funcdef>
<paramdef>(const char *<varname>msgid</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>gettext</command> işlevi o an seçili olan ileti kataloglarında <varname>msgid</varname> ile belirtilen dizgeye eşdeğer çeviriyi arar. Eğer böyle bir dizge varsa onunla döner. Aksi takdirde, <varname>msgid</varname> ile belirtilen dizgeyi döndürür.
     </para><para>
Dönüş değeri <command>char *</command> türünde olduğundan dönen dizgenin değiştirilmemesi gerektiğine dikkat edin. Bu bozuk türdeki sonuçlar işlevin geçmişinden kaynaklanır ve işlevin kullandığı yöntemi yansıtmaz.
     </para><para>
Dikkar ederseniz, yukarıda ileti katalogları (çoğul) yazdık. Bu, bu işlevlerin GNU gerçeklemesinin bir özelliğidir ve ileti kataloglarının seçim yöntemlerindan bahsederken bundan daha ayrıntılı sözedeceğiz (bkz. <xref linkend="glibc-Locating-gettext-catalog"/>).
     </para><para>
<command>gettext</command> işlevi <varname>errno</varname> genel değişkeninin değerini değiştirmez. Şöyle bir kodu yazabilmek için bu gereklidir:
     </para><para>
<screen>  printf (gettext (&quot;Operation failed: %m\n&quot;));</screen>
     </para><para>
Burada <varname>errno</varname> değeri, <command>%m</command> biçim belirtimiyle işlenerek <command>printf</command> işlevinde kullanılmıştır. Eğer <command>gettext</command> işlevi bu değeri değiştirmiş olsaydı, (<command>printf</command> işlevinden önce çağrılacağından) biz yanlış ileti alacaktık.
     </para><para>
Bu durumda, bir ileti kataloğunun mevcut olup olmadığını saptamanın bir yolu yoktur. Normalde katalogların bulunmasını sağlamak kullanıcının görevidir. Çünkü yazılım çalışması için normalde kullanıcının dilinde bir ileti kataloğuna ihtiyaç duymaz, bu bakımdan ileti kataloğunun bulunması için kullanıcıya yardımcı olması beklenmez.
</para></funcdescr></funcsynopsis></para><para>
İleti kataloğuna erişmekte kullanılan diğer iki işlev öntanımlı olmayan bir ileti kataloğunun seçilmesine yardımcı olur. Eğer yazılım birbirinden bağımsız olarak geliştirilmiş parçalardan oluşuyorsa, her parçanın kendi ileti kataloğu olabilir ve bunlar aynı anda kullanılabilir. C kütüphanesinin kendisi buna iyi bir örnektir: Anlamı belirsiz bilgileri belirtmesi ama o an seçili bir öntanımlı ileti kataloğuna da bağımlı olmaması gerektiğinden, <command>gettext</command> işlevlerini dahili olarak kullanır.
     </para><para xml:id="glibc-dgettext">
<indexterm scope="glibc-fn"><primary>dgettext</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>char *<command>dgettext</command></funcdef>
<paramdef>(const char *<varname>alanadı</varname>,
 const char *<varname>msgid</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>dgettext</command> işlevi <command>gettext</command> işlevi gibi davranır.  Farklı olarak ilk argümanında çevirinin aranacağı ileti kataloğu belirtilir. Eğer <varname>alanadı</varname> ile bir boş gösterici belirtilmişse, katalog olarak öntanımlı katalog kullanıldığından <command>dgettext</command> işlevi tamamen  <command>gettext</command> işlevi gibi davranır.
     </para><para>
<command>gettext</command> işlevinde olduğu gibi geçmişten gelen bir özellik olarak dönüş türü <command>char *</command>'dır ve dönen dizgenin asla değiştirilmemesi gerekir.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-dcgettext">
<indexterm scope="glibc-fn"><primary>dcgettext</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>char *<command>dcgettext</command></funcdef>
<paramdef>(const char *<varname>alanadı</varname>,
 const char *<varname>msgid</varname>,
 int         <varname>kategori</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>dcgettext</command> işlevi <command>dgettext</command> işlevinin argümanlarına ek olarak üçüncü bir argüman alır. Bu argüman <varname>kategori</varname> argümanıdır ve ileti kataloğunun yerelini belirtmek için kullanılır. Yani, yerel kategorisi ve alanadı birlikte, kullanılacak kataloğun yerini tespit ederler (aşağıya bakınız).
     </para><para>
<command>dgettext</command> işlevi <command>dcgettext</command> işlevi kullanılarak şöyle ifade edilebilir:
     </para><para>
<screen>dgettext (domain, string)</screen>
     </para><para>yerine</para><para>
<screen>dcgettext (domain, string, LC_MESSAGES)</screen>
     </para><para>yazılırsa sonuç aynı olur.</para><para>
Bu, üçüncü parametre için umulan değerin hangisi olduğunu da gösterir. <command>locale.h</command> başlık dosyasında bulunan kategorilerden biri kullanılabilir. Normalde kullanılabilecek değerler: <command>LC_CTYPE</command>, <command>LC_COLLATE</command>, <command>LC_MESSAGES</command>, <command>LC_MONETARY</command>, <command>LC_NUMERIC</command> ve <command>LC_TIME</command>.  <command>LC_ALL</command> değerinin kullanılmadığına dikkat edin. Bu isimle ortam değişkenlerinin değeri arasında bir ilişki yoktur.
     </para><para>
<command>dcgettext</command> işlevi, <command>gettext</command> işlevlerine sahip diğer sistemlerle uyumluluk adına gerçeklenmiştir. Aslında <varname>kategori</varname> parametresinde <command>LC_MESSAGES</command> dışında bir değeri kullanmanın gerekli olduğu bir durum yoktur. Bunun dışında bir seçim sadece sinir bozucu olabilir.
     </para><para>
<command>gettext</command> işlevinde olduğu gibi geçmişten gelen bir özellik olarak dönüş türü <command>char *</command>'dır ve dönen dizgenin asla değiştirilmemesi gerekir.
</para></funcdescr></funcsynopsis></para><para>
Yukarıdaki üç işlevi bir yazılımda kullanırken sıklıkla karşılaşılan durum <varname>msgid</varname> argümanının  bir dizge sabiti olmasıdır. Yani bu duruma göre bir eniyileme yapmak gerekir. Bunun hakkında biraz düşününce, yeni bir ileti kataloğunun yüklenmesi mümkün olmadıkça bir iletinin çevirisinin değiştirilemeyeceği şeklinde gerçekleşmesi gerekir. Bu eniyileme <command>gettext</command>, <command>dgettext</command> ve <command>dcgettext</command> işlevleriyle gerçeklenmiştir.
     </para></sect2><sect2 xml:id="glibc-Locating-gettext-catalog" chunkthis="1">
     <title><literal>gettext</literal> kataloğunun yeri</title>
     <titleabbrev>Hangi kataloğun kullanılacağı nasıl saptanır?</titleabbrev>
     <para>
Belirtilen bir iletinin çevirisini elde eden işlevler olağanüstü basit bir arayüze sahiptir. Fakat yazılımın kullanıcısına istediği çeviriyi seçme fırsatı vermek ve yazılımcıya da katalog dosyalarının aranacağı yerler bakımından bir hakimiyet sağlamak gerekir. Tüm bunları denetim altına alacak mekanizma yani kod oldukça karmaşıktır ama kullanımı kolaydır.
     </para><para>
<command>catgets</command> işlevleri tarafından da uygulanan iki temel görevin yerine getirilmesi gerekir:
     </para><para><orderedlist numeration="arabic"><listitem><para>
İleti kataloglarının yeri. Hepsi aynı pakete karşılık gelen farklı dillerde bir miktar dosya vardır. Genellikle, bunlar dosya sistemi üzerinde belli bir dizin altında bulunurlar.
       </para><para>
Kurulmuş çok sayıda keyfi paket olabilir ve bunlar dosyalarını bulmak için farklı kuralları izleyebilir.
       </para></listitem><listitem><para>
Kullanıcının isteklerine uyarlanmış çeviri dosyalarının aranması paket tarafından belirtilen konuma göreli olmalıdır. Yani, kullanıcı paketi seçerek her dil ile ilgili dosyayı konumlayabilmelidir.
       </para></listitem></orderedlist></para><para>
Bu, <command>gettext</command> belirtimi tarafından gerek duyulan işlevsellik olduğu kadar <command>catgets</command> işlevlerinin de yapabildiği bir şeydir. Ancak, çözümlenmesi gereken bazı sorunlar vardır:
     </para><para><itemizedlist><listitem><para>
Kullanılacak dil farklı yollarla belirtilebilir. Bunun için genel bir standart kabul edilmiş değildir ve kullanıcı yazılımdan ne anlatmak istediğini anlamasını bekler. Örneğin, Almanca çeviriyi seçmek için kullanıcı <command>de</command>, <command>german</command> ya da <command>deutsch</command> yazabilir ve yazılımın daima buna bir tepki vermesini bekler.
       </para></listitem><listitem><para>
Kimi zaman kullanıcının belirtimi çok ayrıntılı olabilir. Eğer kullanıcı kendini, Almanya'da, Almanca konuşan ve ISO 8859-1 karakter kodlamasını kullanan biri olarak tarif etmek için <literal>de_DE.ISO-8859-1</literal> belirtimini kullanırsa bu belirtimle tam olarak eşleşen bir ileti kataloğu bulamayacaktır. Ama <command>de</command> ile eşleşen bir katalog olabilir. Ayrıca, makinede kullanılan karakter kümesi daima ISO 8859-1 ise, ileti kataloğunun bunu kullanmaması için bir sebep yoktur. (Buna <firstterm>ileti kalıtımı</firstterm> diyoruz.)
       </para></listitem><listitem><para>
Eğer istenen dilde bir katalog yoksa, son çare yazılımcının dili olmamalıdır. Kullanıcı iletileri daha iyi anlayacağı başka diller ve hatta bunlara bir öncelik sırası belirtebilmelidir.
       </para></listitem></itemizedlist></para><para>
Yapılandırma eylemlerini iki parçaya ayırıyoruz: Biri yazılımcı tarafından uygulanan, diğeri kullanıcı tarafından uygulanan. Kullanıcının eylemlerine temel teşkil edeceğinden burada önce yazılımcının kullanabileceği işlevlerden bahsedeceğiz.
     </para><para>
Önceki bölümde açıklanan işlevlerde iletilerin bir <firstterm>alan adı</firstterm>na göre seçilebildiğini görmüştük. Bu, ayrı bir alan kullanan her yazılım parçası için eşsiz olması gereken basit bir dizgedir. Bu isim sayesinde aynı anda çok sayıda keyfi alana sahip bir yazılım kullanmak mümkün olur. Örneğin, C kütüphanesini kullanan bir yazılım <command>foo</command> alan adını kullanırken, GNU C kütüphanesinin kendisi <command>libc</command> alan adını kullanır. Burada önemli olan aynı anda sadece bir alanın etkin olduğudur. Bu aşağıdaki işlevle denetlenir.
     </para><para xml:id="glibc-textdomain">
<indexterm scope="glibc-fn"><primary>textdomain</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>char *<command>textdomain</command></funcdef>
<paramdef>(const char *<varname>alanadı</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>textdomain</command> işlevi ilerde <command>gettext</command> çağrılarında öntanımlı alan olarak <varname>alanadı</varname> ile belirtilen alanı etkinleştirir. <command>dgettext</command> ve <command>dcgettext</command> çağrılarında <varname>alanadı</varname> parametresi ile bir boş gösterici belirtilmedikçe bu alanın etkin olmayacağını unutmayın.
     </para><para>
İlk <command>textdomain</command> çağrısından önceki öntanımlı alan adı <command>messages</command>'dir.  Bu, <command>gettext</command> arayüzünün belirtiminde belirtilen isimdir. Herhangi bir başka isimden çok daha iyidir. Sorunlarla karşılaşmak istenmiyorsa, hiçbir yazılım bu ismi kullanmamalıdır.
     </para><para>
İşlev etkinleştirilen öntanımlı alan adı ile döner. Eğer işlev dönüş değeri için yer ayıramamışsa <command>NULL</command> döndürür ve <varname>errno</varname> genel değişkenine <command>ENOMEM</command> değerini atar. İşlevin dönüş türü <command>char *</command> olduğundan dönen dizge değiştirilmemelidir.  Dönüş değeri için yer ayırma işlemi işlev tarafından dahili olarak yapılır.
     </para><para>
Eğer <varname>alanadı</varname> bir boş gösterici ise hiçbir alan adı etkinleştirilmez. Sadece geçerli öntanımlı alan adı döner.
     </para><para>
Eğer <varname>alanadı</varname> ile bir boş dizge belirtilmişse, öntanımlı alan adı ilk değer olan <command>messages</command> yapılır. <command>messages</command> alanının asla kullanılmaması gerektiğinden dönüş değeri bu değerle sorgulanabilir.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-bindtextdomain">
<indexterm scope="glibc-fn"><primary>bindtextdomain</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>char *<command>bindtextdomain</command></funcdef>
<paramdef>(const char *<varname>alanadı</varname>,
 const char *<varname>dizinadı</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>bindtextdomain</command> işlevi farklı diller için <varname>alanadı</varname> alanının ileti kataloglarını içeren dizini belirtmekte kullanılır. Doğru olması bakımından, bu dizinin dizin hiyerarşisi içinde olması beklenir. Aşağıda buna daha ayrıntılı değinilmiştir.
     </para><para>
Yazılımla gelen çevirilerin <command>/foo/bar</command> gibi bir dizin hiyerarşisine yerleştirilmiş olması yazılımcı açısından önemlidir. Yazılım bundan sonra bu dizinle bir <command>bindtextdomain</command>  çağrısı yaparak alanı bağlar. Böylece katalogların bulunması kesin olarak sağlanır. Düzgün çalışan bir yazılım kullanıcının bir ortam değişkeni belirtmesine ihtiyaç duymaz.
     </para><para>
<command>bindtextdomain</command> çağrısı, eğer önceki bağlanan alanların üzerine yazılmaması için farklı <varname>alanadı</varname> argümanları gerekliyse, defalarca yapılabilir.
     </para><para>
Eğer yazılım bir <command>chdir</command> çağrısı ile çalışma dizinini değiştirdiği bir sırada <command>bindtextdomain</command> çağrısının yapılabilmesi için <varname>dizinadı</varname> argümanının mutlak bir dosyayolu olması önem kazanır. Asi takdirde argümanda belirtilen dizin bu sırada değişebilir.
     </para><para>
Eğer <varname>dizinadı</varname> parametresi bir boş gösterci ise, <command>bindtextdomain</command> <varname>alanadı</varname> alanı için o an seçili dizin ile döner.
     </para><para>
<command>bindtextdomain</command> işlevi normalde seçilen dizinin ismini içeren bir dizgeye gösterici ile döner. Dizge işlev tarafından dahili olarak ayrıldığından yazılımcı bu dizgenin içeriğini değiştirmemelidir. Eğer sistem <command>bindtextdomain</command> çalışırken bir bellek çıktısı (core dosyası) çıktılarsa, işlev  <command>NULL</command> ile döner ve <varname>errno</varname> genel değişkenine ilgili hata durumu atanır.
        </para></funcdescr></funcsynopsis></para></sect2>
      <sect2 xml:id="glibc-Advanced-gettext-functions" chunkthis="1">
        <title>Gelişkin <literal>gettext</literal> işlevleri</title>
        <titleabbrev>Daha karmaşık durumlar için ek işlevler.</titleabbrev>
        <para>
Şimdiye kadar bahsedilen <command>gettext</command> işlevleriyle ilgili tüm mevcut yaklaşımlarda (ve <command>catgets</command> işlevlerinin de tamamında) tamamen gözardı edilmiş gerçek dünyaya özgü bir sorun vardır. Burada çoğul biçimlerin nasıl elde edildiğinden bahsedeceğiz. (Ç.N: Türkçe için sorun değil ama diğer diller için başlı başına bir sorun olduğunu birazdan farkedeceksiniz.)
     </para><para>
Kimsenin uluslararasılaştırma ile fazla ilgilenmediği zamanlarda (hatta, sonrasında da) Unix kaynak koduna baktığınızda şuna benzer kodlar görürdünüz<footnote><para>Ç.N. -- Böyle bir dizgeyi Türkçe'ye çevirirken şöyle yapardık:
    </para><para>
<screen>"%d dosya silindi. %s"</screen>
     </para><para>
Ve siz iletiyi genellikle şöyle görürdünüz: "5 dosya silindi. s"
     </para></footnote>:
     </para><para>
<screen>   printf (&quot;%d file%s deleted&quot;, n, n == 1 ? &quot;&quot; : &quot;s&quot;);
</screen></para><para>
Kodu uluslararsılaştırmaya çalışan kişlerden gelen ilk tepkilerden sonra ya böyle formülasyonlardan vazgeçildi ya da şöyle dizgeler kullanılmaya başlandı:
     </para><para>
<screen>
   if (n == 1)
     printf (&quot;%d file deleted&quot;, n);
   else
     printf (&quot;%d files deleted&quot;, n);
</screen></para><para>
Ancak bu da soruna çözüm olmadı. Miktarlı nesne isimlerine sadece `s' gibi tek bir ek alan dillere çözüm olurken, tamamına bir çözüm sağlayamadı. Çünkü çoğul biçimlerin elde edilmesi her dil ailesinde farklıydı. Bunların arasında (hatta dil ailesindeki diller içinde bile) farklı olabilen iki şey vardır:
     </para><para><itemizedlist><listitem><para>
Çoğul biçimlerin kurgulanışı farklıdır. Bu bazı düzensizlikler içeren dillerle ilgili bir sorundur. Örneğin, Almanca'da bu çok belirgindir. İngilizce ve Almanca aynı dil ailesine (Germen) mensup oldukları halde çoğul isim biçiminin (`s' ekleme) kurgulanışında farklılıklar vardır.
       </para></listitem><listitem><para>
Çoğul biçimlerin sayısı farklıdır. Bir tekil, bir de çoğul biçim bulunan Romen ve Germen dillerine aşina olanlar için bu biraz şaşırtıcıdır (Türkçe'den başka dil bilmeyene daha da şaşırtıcı, çünkü Türkçe'de böyle bir olgu *hiç* yok; 1 elma, 5 armut deriz; 1 elma, 5 armutlar demeyiz).
       </para><para>
Ancak, diğer dil ailelerine bir biçimden çok sayıda biçime kadar değişik biçimler sözkonusudur. Bu konuda daha ayrıntılı bilgi ayrı bir bölümde verilmiştir.
       </para></listitem></itemizedlist></para><para>
Bunun sonucu olarak, uygulama yazarları kodlarında bu sorunu çözümlemekle uğraşmak istemezler. Bu sadece kendi dillerinde yerelleştirme yapanların sorunu gibi görünse de <command>gettext</command>'in genişletilmiş arayüzü buna bir çözüm içerir.
     </para><para>
Bu ek işlevler bir anahtar dizge yerine iki anahtar dizge ve bir sayısal argüman alırlar. Sayısal argümanı ve ilk dizgeyi bir anahtar olarak kullanarak, gerçeklenim, çevirmen tarafından belirlenen doğru çoğul biçim kurallarını seçer. Normal <command>gettext</command> davranışına benzer şekilde, bir ileti kataloğu bulunamadığı zaman bu iki dizge dönüş değerini oluştururlar. Germen dili kuralları gereğince, ilk dizgenin tekil biçimde, ikinci dizgenin çoğul biçimde olduğu varsayılır.
     </para><para>
Bunun sonucu olarak, dil katalogları olmayan yazılımlar iletileri Germen dili kullanılıyormuş gibi basarlar. Bu bir sınırlama olarak görülebilir ancak, GNU C Kütüphanesi (keza GNU <command>gettext</command>) GNU paketinin bir parçası olarak yazılmıştır ve GNU projelerinin kodlama standartları yazılımın İngilizce yazılmasını gerektirdiğinden, kaçınılmaz olarak bu böyle olacaktır.
     </para><para xml:id="glibc-ngettext">
<indexterm scope="glibc-fn"><primary>ngettext</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>char *<command>ngettext</command></funcdef>
<paramdef>(const char       *<varname>msgid1</varname>,
 const char       *<varname>msgid2</varname>,
 unsigned long int <varname>n</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>ngettext</command> işlevi ileti kataloğunun bulunması bakımından <command>gettext</command> işlevi gibidir. Ancak, iki ek argüman alır. <varname>msgid1</varname> ile belirtilen dizge tekil biçimli ileti üretir. Ayrıca katalogdaki iletiyi aramak için anahtar olarak kullanılır. <varname>msgid2</varname> ile belirtilen dizge ise çoğul biçimli girdi/girdiler üretir. <varname>n</varname> parametresi çoğul biçimlerin sayısını belirler. Bir ileti kataloğu bulunamamışsa, işlev, <command>n == 1</command> ise <varname>msgid1</varname> ile, aksi takdirde <varname>msgid2</varname> ile döner.
     </para><para>
İşlevin kullanımına bir örnek:
     </para><para>
<screen>
printf (ngettext (&quot;%d file removed&quot;, &quot;%d files removed&quot;, n), n);
</screen></para><para>
<varname>n</varname> değerinin <command>printf</command> işlevinde de kullanıldığına dikkat edin. Sadece <command>ngettext</command> işlevinin argümanı olması yeterli değildir.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-dngettext">
<indexterm scope="glibc-fn"><primary>dngettext</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>char *<command>dngettext</command></funcdef>
<paramdef>(const char       *<varname>alanadı</varname>,
 const char       *<varname>msgid1</varname>,
 const char       *<varname>msgid2</varname>,
 unsigned long int <varname>n</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>dngettext</command> işlevi ileti kataloğunun seçilmesi bakımından <command>dgettext</command> işlevi gibidir. Ancak, iki ek argüman alır. Tekil/Çoğul dizgelerin elde edilmesi bakımından da <command>ngettext</command> işlevi gibidir.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-dcngettext">
<indexterm scope="glibc-fn"><primary>dcngettext</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>char *<command>dcngettext</command></funcdef>
<paramdef>(const char       *<varname>alanadı</varname>,
 const char       *<varname>msgid1</varname>,
 const char       *<varname>msgid2</varname>,
 unsigned long int <varname>n</varname>,
 int               <varname>kategori</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>dcngettext</command> işlevi ileti kataloğunun seçilmesi bakımından <command>dcgettext</command> işlevi gibidir. Ancak, iki ek argüman alır. Tekil/Çoğul dizgelerin elde edilmesi bakımından da <command>ngettext</command> işlevi gibidir.
        </para></funcdescr></funcsynopsis></para></sect2>
        <sect2 xml:id="glibc-gettext-plural-forms" chunkthis="1">
        <title>Çoğul Biçimler Sorunu</title><para>
Bir önceki bölümde sorun ile ilgili bir açıklama yapılmıştı. Şimdi burada sorunun nasıl çözümlendiğini açıklayacağız. Dilbilimciler olmaksızın, desteklenen her dil için çoğul biçimlerin neye göre şekillendiği, kaç çoğul biçim olduğu gibi bilgileri elde etmek mümkün olmazdı.
     </para><para>
Bu bakımdan, çoğul biçimlerin seçim kurallarını belirlemeleri çevirmenlere bırakılarak çözüme ulaşıldı. Formül her dil için değişiklik gösterdiğinden, bilgiyi kodun içine yerleştirerek bu mümkün oldu (yeni dillerin kullanımını engellememek için hala bazı genişletmeler gerekiyor).  Bu konu  GNU <command>gettext</command> kılavuzunda daha ayrıntılı bulunabilir. Burada daha az bilgi vermekle yetineceğiz.
     </para><para>
Çoğul biçimin seçimi hakkındaki bilgi ileti kataloğunun başlık kısmında (Başlık, boş bir <command>msgid</command> dizgesidir) şuna benzer bir girdi olarak bulunur:
     </para><para>
<screen>
Plural-Forms: nplurals=2; plural=n == 1 ? 0 : 1;
</screen></para><para>
<command>nplurals</command> değeri bu dilde kaç çoğul biçim olduğunu belirten bir tamsayı olmalıdır. <command>plural</command> ise C dilinin sözdizimine uygun bir ifade olmalıdır. Ancak bu ifadede, negatif sayılar bulunmamalı, sayılar onluk tabanda olmalı ve değişken olarak sadece <command>n</command> bulunmalıdır. Bu ifade <command>ngettext</command>, <command>dngettext</command> veya <command>dcngettext</command>işlevlerinden biri ile değerlendirilecektir. Bu işlevlere aktarılan <command>n</command> değeri bu ifadede yerine konarak değerlendirilir. Sonuç, <command>nplurals</command> değerinden küçük, eşit veya büyük olmalıdır.
     </para><para>
Bu noktada bilinen kurallar aşağıda dil ailelerine göre sınıflandırılarak listelenmiştir. Fakat, listeden de görüleceği gibi kurallar bir dil ailesinin tamamına genelleştirilememektedir.<footnote><para>Bu listeye eklenmesini istediğiniz bilgileri <email>bug-glibc-manual@gnu.org</email> adresine bekliyoruz.</para></footnote>
     </para><para><variablelist><varlistentry>
     <term>Sadece bir biçim:</term><listitem><para>
Bazı dillerde tekil/çoğul biçim farkı yoktur. Böyle bir dil için ileti kataloğunun başlığında şu satır bulunur:
        </para><para>
<screen>
Plural-Forms: nplurals=1; plural=0;</screen>
        </para><para>
Bu özellikteki diller:
        </para><para>
         <variablelist><varlistentry>
         <term>Uralca/Fin-Uygur Dil Ailesi</term><listitem><para>
Macarca
         </para></listitem></varlistentry><varlistentry>
         <term>Asya Dilleri</term><listitem><para>
Japonca, Korece
         </para></listitem></varlistentry><varlistentry>
         <term>Altay/Türkçe Dil Ailesi</term><listitem><para>
Türkçe<footnote><para>Çevirenin Notu: Her ne kadar Türkçe'de miktar belirtirken  tekil/çoğul farkı yoksa da bir uygulama nedeniyle tekil ve çoğul biçimler için ayrı iletiler gerekli olmaktadır. Ben (NBB) GNU <command>gettext</command> paketinin ileti kataloğu dosyasının da çevirmeni olduğumdan o dosyadaki bir örneği vererek ne demek istediğimi açıklamaya çalışayım.
    </para><para>
<screen>
#: src/msgfmt.c:1095
#, c-format
msgid "...but some messages have one plural form"
msgid_plural "...but some messages have %lu plural forms"
msgstr[0] "...ama bazı iletiler tek çoğul biçim içeriyor"
msgstr[1] "...ama bazı iletiler %lu çoğul biçim içeriyor"
</screen>
    </para><para>
Burada dikkat ederseniz tekil biçimli ileti içinde miktar <literal>%lu</literal> belirtimi ile değil, yazıyla, <command>one</command> yazılmış. Bu kılavuzun İngilizce’sinde belirtildiği gibi tek çoğul biçim kullanma şansımız böyle bir örnek karşısında kalmıyor. Çünkü Türkçe iletiye, İngilizce iletide bulunmayan <literal>%lu</literal> belirtecini koyarsak ve dosyayı <command>msgfmt</command> ile derlemeye çalışırsak bunun bir hata olduğunu görürüz. Böyle bir durumda her iki ileti için birer çeviri olmak zorunda, dolayısıyla bir tekil ve bir çoğul biçim belirtmek zorundayız:
        </para><para>
<screen>Plural-Forms: nplurals=2; plural=n != 1;</screen>
        </para><para>
Bunun bize bir zararı yok, en kötü durumda çoğul biçimli iletilerde birbirinin aynı iki ileti olur. Ama dosya böyle özel bir duruma sahip tek bir ileti dahi içermedikçe tekil biçim de kullanılabilir.
    </para></footnote>
         </para></listitem></varlistentry></variablelist>
         </para></listitem></varlistentry><varlistentry>
         <term>Biri tekil biçim olmak üzere iki biçim</term><listitem><para>
Yazılımların çoğu İngilizce olduğundan bu biçimi kullanır. Böyle bir dil için ileti kataloğunun başlığında şu satır bulunur:
        </para><para>
<screen>Plural-Forms: nplurals=2; plural=n != 1;</screen>
        </para><para>
(Not: Burada sıfır ya da bir ile sonuçlanan mantıksal C ifadesi kullanılmıştır.)
        </para><para>
Bu özellikteki diller:
        </para><para><variablelist><varlistentry>
        <term>Germen Dil Ailesi</term><listitem><para>
Danca, Felemenkçe, İngilizce, Almanca, Norveççe, İsveççe
         </para></listitem></varlistentry><varlistentry>
         <term>Uralca/Fin-Uygur Dil Ailesi</term><listitem><para>
Estonca, Fince
         </para></listitem></varlistentry><varlistentry>
         <term>Helen Dil Ailesi</term><listitem><para>
Yunanca
         </para></listitem></varlistentry><varlistentry>
         <term>Batı Samî/Kenan Dil Ailesi</term><listitem><para>
İbranice
         </para></listitem></varlistentry><varlistentry>
         <term>İtalik/Latin Dil Ailesi</term><listitem><para>
İtalyanca, Portekizce, İspanyolca
         </para></listitem></varlistentry><varlistentry>
         <term>Hint-Arî Dil Ailesi</term><listitem><para>
Esperanto
         </para></listitem></varlistentry></variablelist>
         </para></listitem></varlistentry><varlistentry>
         <term>Biri 0 ve 1 için tekil biçim olmak üzere 2 biçim</term><listitem><para>
Dil ailesindeki olağandışı durum.  Böyle bir dil için ileti kataloğunun başlığında şu satır bulunur:
        </para><para>
<screen>Plural-Forms: nplurals=2; plural=n>1;</screen>
        </para><para>
Bu özellikteki diller:
        </para><para><variablelist><varlistentry>
        <term>İtalik/Latin Dil Ailesi</term><listitem><para>
Fransızca, Brezilya Portekizcesi
        </para></listitem></varlistentry></variablelist>
        </para></listitem></varlistentry><varlistentry>
        <term>Sıfır için özel bir durum ile üç biçim</term>
        <listitem><para>
Böyle bir dil için ileti kataloğunun başlığında şu satır bulunur:
        </para><para>
<screen>Plural-Forms: nplurals=3; plural=n%10==1 &amp;&amp; n%100!=11 ? 0 : n != 0 ? 1 : 2;
</screen>
        </para><para>
Bu özellikteki diller:
        </para><para><variablelist><varlistentry>
          <term>Baltık Dil Ailesi</term>
          <listitem><para>
Latviya dili
        </para></listitem></varlistentry></variablelist>
        </para></listitem></varlistentry><varlistentry>
        <term>1 ve 2 için özel bir durum ile üç biçim</term><listitem><para>
Böyle bir dil için ileti kataloğunun başlığında şu satır bulunur:
        </para><para>
<screen>Plural-Forms: nplurals=3; plural=n==1 ? 0 : n==2 ? 1 : 2;</screen>
        </para><para>
Bu özellikteki diller:
        </para><para><variablelist><varlistentry>
        <term>Keltçe Dil Ailesi</term><listitem><para>
İrlanda Dili
         </para></listitem></varlistentry></variablelist>
         </para></listitem></varlistentry><varlistentry>
         <term>1[2-9] ile biten sayılar için özel bir durum ile üç biçim</term>
         <listitem><para>
Böyle bir dil için ileti kataloğunun başlığında şu satır bulunur:
         </para><para>
<screen>
Plural-Forms: nplurals=3; \
    plural=n%10==1 &amp;&amp; n%100!=11 ? 0 : \
           n%10&gt;=2 &amp;&amp; (n%100&lt;10 || n%100&gt;=20) ? 1 : 2;
</screen>
         </para><para>
Bu özellikteki diller:
         </para><para><variablelist><varlistentry>
         <term>Baltık Dil Ailesi</term>
         <listitem><para>
Litvanya dili
         </para></listitem></varlistentry></variablelist>
         </para></listitem></varlistentry><varlistentry>
         <term>1[1-4] ile bitenler hariç; 1, 2, 3, 4 ile biten sayılar için özel bir durum ile üç biçim</term><listitem><para>
Böyle bir dil için ileti kataloğunun başlığında şu satır bulunur:
        </para><para>
<screen>
Plural-Forms: nplurals=3; \
    plural=n%100/10==1 ? 2 : n%10==1 ? 0 : (n+9)%103 ? 2 : 1;
</screen></para><para>
Bu özellikteki diller:
        </para><para><variablelist><varlistentry>
        <term>İslav Dil Ailesi</term><listitem><para>
Hırvatça, Çekçe, Rusça, Ukrayna dili
        </para></listitem></varlistentry></variablelist>
        </para></listitem></varlistentry><varlistentry>
        <term>1, 2, 3, 4 için özel bir durum ile üç biçim</term><listitem><para>
Böyle bir dil için ileti kataloğunun başlığında şu satır bulunur:
        </para><para>
<screen>
Plural-Forms: nplurals=3; \
     plural=(n==1) ? 1 : (n>=2 &amp;&amp; n&lt;=4) ? 2 : 0;
</screen></para><para>
Bu özellikteki diller:
        </para><para><variablelist><varlistentry>
        <term>İslav Dil Ailesi</term><listitem><para>
Slovakça
        </para></listitem></varlistentry></variablelist>
        </para></listitem></varlistentry><varlistentry>
        <term>1 için ve 2, 3 veya 4 ile biten bazı sayılar için özel bir durum ile üç biçim</term><listitem><para>
Böyle bir dil için ileti kataloğunun başlığında şu satır bulunur:
        </para><para>
<screen>
Plural-Forms: nplurals=3; \
    plural=n==1 ? 0 : \
           n%10>=2 &amp;&amp; n%10&lt;=4 &amp;&amp; (n%100&lt;10 || n%100>=20) ? 1 : 2;
</screen></para><para>
Bu özellikteki diller:
        </para><para><variablelist><varlistentry>
        <term>İslav Dil Ailesi</term><listitem><para>
Lehçe
        </para></listitem></varlistentry></variablelist>
        </para></listitem></varlistentry><varlistentry>
        <term>1 için ve 02, 03 veya 04 ile biten tüm sayılar için özel bir durum ile dört biçim</term><listitem><para>
Böyle bir dil için ileti kataloğunun başlığında şu satır bulunur:
        </para><para>
<screen>
Plural-Forms: nplurals=4; \
    plural=n%100==1 ? 0 : n%100==2 ? 1 : n%100==3 || n%100==4 ? 2 : 3;
</screen></para><para>
Bu özellikteki diller:
        </para><para><variablelist><varlistentry>
        <term>İslav Dil Ailesi</term><listitem><para>
Slovence
        </para></listitem></varlistentry></variablelist>
        </para></listitem></varlistentry></variablelist>
      </para></sect2>
      <sect2 xml:id="glibc-Charset-conversion-in-gettext" chunkthis="1">
        <title><literal>gettext</literal>'te karakter kümesi dönüşümü</title>
        <titleabbrev><command>gettext</command>'in çıktı karakter kümesi olarak neyi kullanacağı nasıl belirtilir?</titleabbrev>
        <para>
<command>gettext</command> sadece bir ileti kataloğunda çeviri aramaz, ayrıca çeviriyi çıktı karakter kümesine anında dönüştürür. Kullanıcı, ileti kataloğunda kullanılan karakter kümesinden farklı bir karakter kümesi kullanıyorsa, bu faydalı bir özelliktir.
     </para><para>
Çıktı karakter kümesi öntanımlı olarak, geçerli yerelin <command>LC_CTYPE</command> kategorisine bağımlı <command>nl_langinfo (CODESET)</command> değeridir. Ancak, bir yazılımın iletileri yerelden bağımsız bir kodlama (UTF-8) ile saklanıyorsa, <command>gettext</command> ailesindeki işlevler çevirinin kodlamasını <command>bind_textdomain_codeset</command> işlevini kullanarak bu kodlamaya dönüştürür.
     </para><para>
<command>gettext</command> işlevinin <varname>msgid</varname> argümanında verilen dizgenin karakter dönüşümüne konu olmadığını unutmayın. Eğer <command>gettext</command>, <varname>msgid</varname>'nin karşılığı olan çeviriyi bulamazsa <varname>msgid</varname> dizgesini dönüştürmeksizin döndürür. Bu bakımdan tüm <varname>msgid</varname> dizgelerinin US-ASCII dizgeler olması tercih edilmelidir.
     </para><para xml:id="glibc-bind_textdomain_codeset">
<indexterm scope="glibc-fn"><primary>bind_textdomain_codeset</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>char *<command>bind_textdomain_codeset</command></funcdef>
<paramdef>(const char *<varname>alanadı</varname>,
 const char *<varname>karakter_kümesi</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>bind_textdomain_codeset</command> işlevi <varname>alanadı</varname> ileti kataloglarının çıktı karakter kümesini belirtmek için kullanılabilir. <varname>karakter_kümesi</varname> argümanı ya <command>iconv_open</command> işlevinde kullanılabilen geçerli bir karakter kümesi dizgesine bir gösterici ya da bir boş gösterici olmalıdır.
     </para><para>
<varname>karakter_kümesi</varname> olarak boş gösterici belirtilmişse, işlev <varname>alanadı</varname> isimli alanın o an seçilmiş karakter kümesi ile döner. <command>NULL</command> dönmüşse, henüz seçilmiş bir karakter kümesi yok demektir.
     </para><para>
<command>bind_textdomain_codeset</command> işlevi defalarca kullanılabilir. Aynı <varname>alanadı</varname> ile yapılan her çağrı bir önceki kodlamayı değiştirir.
     </para><para>
<command>bind_textdomain_codeset</command> işlevi seçilen karakter kümesininin ismini içeren bir dizgeye bir gösterici döndürür. Dizge işlev tarafından dahili olarak ayrıldığından yazılımcı tarafından değiştirilmemelidir. Eğer sistem <command>bind_textdomain_codeset</command> çalışırken bir bellek çıktısı (core dosyası) çıktılarsa, işlev  <command>NULL</command> ile döner ve <varname>errno</varname> genel değişkenine ilgili hata durumu atanır.
     </para></funcdescr></funcsynopsis></para>
   </sect2><sect2 xml:id="glibc-GUI-program-problems" chunkthis="1">
     <title>GUI Yazılımlarının Sorunları</title>
     <titleabbrev><command>gettext</command> GUI yazılımlarda nasıl kullanılır?</titleabbrev>
     <para>
<command>gettext</command> işlevlerinin büyük sorunlara yol açtığı kullanım yerlerinden biri görsel arayüzlü (GUI) yazılımlardır. Burada sorun çevrilecek iletilerin çoğunun çok kısa olması gerekliliğinden kaynaklanır. Bunlara genellikle menülerde rastlanır. Bu dizgeler tam bir cümle içeremedikleri gibi bir dilde aynı olan dizgelerin diğer dillerde farklı olabilmesi sorun oluşturur. Bu tek sözcüklük dizgelerde iyice belirginleşir.
     </para><para>
Çoğu kimse, <command>gettext</command> yaklaşımı yerine bu sorunun görülmediği <command>catgets</command> işlevlerinin kullanılması gerektiğini söyler.  Ancak, bu sorunları <command>gettext</command> işlevleri kullanıldığında aşmanın çok basit ve oldukça güçlü bir yöntemi vardır.
     </para><para>
Görsel arayüzlü bir yazılımın şöyle bir menüsü olduğunu varsayalım:
     </para><para>
<literallayout>
+------------+------------+--------------------------------------+
| File       | Printer    |                                      |
+------------+------------+--------------------------------------+
| Open     | | Select   |
| New      | | Open     |
+----------+ | Connect  |
             +----------+
</literallayout></para><para>
Kodun bazı yerlerinde <command>gettext</command> ailesinden işlevlerde <command>File</command>, <command>Printer</command>, <command>Open</command>, <command>New</command>, <command>Select</command> ve <command>Connect</command> dizgelerinin çevirilerine erişildiğini varsayalım. Ancak dikkat ederseniz iki yerde işleve aktarılan dizge  <command>Open</command> olacaktır.  Yukarıda açıklanan açmazdan dolayı bu dizgenin çevirileri aynı olmayabilecektir.
     </para><para>
Bu sorunun çözümlerinden biri belirsizliği ortadan kaldırmak için dizgeyi yapay olarak uzatmak ama çevirmenden sadece asıl dizgeyi çevirmesini istemektir. Fakat bir çeviri bulunamadığında yazılım ne yapacak? Uzatılan dizge basılamaz. O halde işlevin biraz değiştirilmiş bir sürümünü kullanmamız gerekir.
     </para><para>
Dizgenin uzatılmasında tektip bir yönteme ihtiyaç vardır. Örneğin, yukarıdaki örnek için uzatılmış dizgeler şöyle seçilebilir:
     </para><para>
<screen>
Menu|File
Menu|Printer
Menu|File|Open
Menu|File|New
Menu|Printer|Select
Menu|Printer|Open
Menu|Printer|Connect
</screen></para><para>
Böylece dizgelerin hepsi farklı oldu. Eğer <command>gettext</command> işlevini aşağıdaki işlevle kullanırsak herşey istendiği gibi olacaktır:
     </para><para>
<indexterm scope="glibc-cp"><primary>sgettext</primary></indexterm>
<screen>
  char *
  sgettext (const char *msgid)
  {
    char *msgval = gettext (msgid);
    if (msgval == msgid)
      msgval = strrchr (msgid, '|') + 1;
    return msgval;
  }
</screen></para><para>
Bu küçük işlevin tek yaptığı bir çevirinin bulunmadığı zaman uzatılmış dizgeden özgün dizgeyi elde etmektir. Dönen değer girdi değeri olduğundan bu işlem doğrudan bir gösterici karşılaştırması olarak yapıldığında daha verimli olur. Bir çevirinin bulunmaması halinde girdi dizgesinin <command>|</command> karakterini içereceğini bildiğimize göre dizge içinde bu karakterin son görüldüğü yeri bulup bu noktaya bir gösterici döndürmek yeterli olacaktır.
     </para><para>
Eğer uzatılmış dizgeleri tutarlı şekilde kullanır ve <command>gettext</command> çağrılarını <command>sgettext</command> çağrıları ile değiştirirsek (bunu sadece görsel yazılımda gerektiği yerde yapmak yeterlidir), uluslarasılaştırılabilen bir yazılım üretebiliriz.
     </para><para>
GNU C gibi ileri düzey derleyicilerle <command>sgettext</command> işlevi bir satıriçi işlev veya bunun gibi bir makro olarak gerçeklenebilir:
     </para><para>
<indexterm scope="glibc-cp"><primary>sgettext</primary></indexterm>
<screen>
#define sgettext(msgid) \
  ({ const char *__msgid = (msgid);            \
     char *__msgstr = gettext (__msgid);       \
     if (__msgval == __msgid)                  \
       __msgval = strrchr (__msgid, '|') + 1;  \
     __msgval; })
</screen></para><para>
Diğer <command>gettext</command> işlevleri de (<command>dgettext</command>, <command>dcgettext</command> ve <command>ngettext</command>) benzer şekilde bir sarmalayıcı işlevle kullanılabilir.
     </para><para>
Şimdi bir soru gelecek akıllara: GNU C kütüphanesinde neden böyle işlevler yok? Bu sorunun iki şıklı bir yanıtı var:
     </para><para><itemizedlist><listitem><para>
Yazılması kolaydır, bu bakımdan kullanıldıkları projenin içinde yazılabilirler. Bu bir yanıt değil derseniz, ikinci şık ile birlikte değerlendirildiğinde birşey ifade eder:
       </para></listitem><listitem><para>
C kütüphanesinde heryerde çalışabilecek bir sürümün bulunmasını sağlayacak bir yöntem yok. Sorun, uzatılmış dizgede asıl dizgenin başına eklenen dizgeleri arasındaki karakterin seçiminden kaynaklanıyor. Yukarıdaki örnekte kullanılan <command>|</command> karakteri bu tür bağlamlarda sıkça kullanılan bir ayraç karakteri olarak iyi bir seçimdir ama ileti dizgelerinde de sık kullanılan bir karakterdir.
       </para><para>
Eğer bu ayraç karakteri ileti dizgesinde de kullanılmışsa ne olacak? Ya da ayraç karakteri kodun derlendiği makinede yoksa ne olacak (örneğini ISO C için <command>|</command> karakteri gerekli değildir; bu nedenle ISO C yazılım geliştirme ortamında ayrıca bir <filename>iso646.h</filename> dosyası vardır).
       </para></listitem></itemizedlist>
     </para><para>
Sadece bir açıklama daha kaldı. Yukarıdaki sarmalayıcı işlev uzatılmış dizgenin tamamının çevrilmeyeceği esasına dayandırılmıştır. Mantık bunu gerektirdiği için böyle yapılmıştır. Çeviri, arama için bir anahtar olarak kullanılmadığından neyi nasıl içerdiğinin bir önemi yoktur, hem gereksiz bellek harcamanın da alemi yok.
     </para></sect2><sect2 xml:id="glibc-Using-gettextized-software" chunkthis="1">
     <title><literal>gettext</literal> kullanan yazılımların kullanımı</title>
     <titleabbrev><command>gettext</command>'in neleri kullanacağını kullanıcı nasıl belirtmeli?</titleabbrev>
     <para>
Geçtiğimiz bölümde yazılımcının yazılımının iletilerini uluslararasılaştırmak için ne yapabileceği açıklandı. Ancak, sonuçta görmek istediği iletiyi kullanıcı seçecektir. Kullanıcı onları anlayabilmelidir.
     </para><para>
POSIX yerel modeli, kullanılan yereli seçmede <command>LC_COLLATE</command>, <command>LC_CTYPE</command>, <command>LC_MESSAGES</command>, <command>LC_MONETARY</command>, <command>LC_NUMERIC</command> ve <command>LC_TIME</command> ortam değişkenlerini kullanır. Evvelce açıklandığı gibi <command>gettext</command> ayrıca bunları da kullanır.
     </para><para>
Bunun nasıl olduğunu anlayabilmek için bir ileti kataloğunun yerini bulmakta kullanılan dosya isminin hangi bileşenlerden oluştuğuna bakalım:
     </para><para>
<literallayout>
<emphasis>dizin_ismi</emphasis>/<emphasis>yerel_dil</emphasis>/LC_<emphasis>kategori</emphasis>/<emphasis>alan_ismi</emphasis>.mo
</literallayout></para><para>
<varname>dizin_ismi</varname> için öntanımlı değer sisteme özeldir. C kütüphanesi yapılandırılırken <option>--prefix</option> seçeneği ile belirtilen dizine göre hesaplanır. <option>--prefix</option> değeri normalde <command>/usr</command> ya da <command>/</command> dizinidir. <varname>dizin_ismi</varname> ise genellikle:
     </para><para>
<filename>/usr/share/locale</filename>
     </para><para>
dizinidir. İleti kataloglarını içeren <filename>.mo</filename> dosyaları sistemden bağımsız dosyalar olduklarından <command>/usr/share</command> öneki tercih edilmiştir. <command>bindtextdomain</command> işlevinin ikinci parametresinde sadece <varname>dizin_ismi</varname> ile belirtilen parça verilir. İşlev dosya yolunun geri kalanını aşağıda açıklandığı gibi oluşturur.
     </para><para>
<varname>kategori</varname> yerel kategorisinin ismidir. <command>gettext</command> ve <command>dgettext</command> için bu daima <command>LC_MESSAGES</command>'dır. <command>dcgettext</command> işlevinde ise bu değer üçünci argümanda belirtilir. Ancak evvelce da açıklandığı gibi  <command>LC_MESSAGES</command> kategorsinden başka bir kategori belirtmekten kaçınılmalıdır.
     </para><para>
<varname>yerel_dil</varname> elemanı kategoriyi içeren dildir. Bu değer <command>setlocale</command> işlevindeki gibi kullanıcının dil seçimine bağlı olarak belirlenir. Bazı ortam değişkenlerine belli bir öncelik sırasına göre bakarak bu değer belirlenir. Bu sıra şöyledir:
     </para><para>
<literallayout indent="0">
    LANGUAGE
    LC_ALL
    LC_xxx
    LANG
</literallayout></para><para>
Çok bildik görünüyor. Bu sıralama <command>LANGUAGE</command> ortam değişkeni dışında <command>setlocale</command> işlevinin kullandığı sıralama ile aynıdır. Peki ama neden <command>LANGUAGE</command> değişkenine bakıyoruz?
     </para><para>
Bunun sebebi bu değişkenlerin değerlerinden elde edilecek sözdiziminin <command>setlocale</command> işlevinden farklı olmasıdır. Eğer <command>LC_ALL</command> değişkenine aşağıdaki genişletilmiş sözdizimine uygun bir değer atarsak, <command>setlocale</command> işlevi bu değeri asla kullanamayacaktır. Bir ek değişkenle bu sorun aşıldığı gibi, bu değişken sayesinde kullanıcının ileti dilini yerel ayarlarından bağımsız olarak belirleyebilme imkanı vardır.
     </para><para>
<command>LC_xxx</command> değişkenlerinin değerleri sadece bir yerele ait belirtimi içerebilirken <command>LANGUAGE</command> değişkeninin değerinde çok sayıda dil iki nokta imleriyle ayrılarak belirtilebilir. Böylece kullanıcı tercih ettiği dilleri bu değişken sayesinde bir öncelik sırasıyla belirtebilir.
     </para><para>
Dosya ismini oluşturan son parça olan <varname>alan_ismi</varname> ya <command>textdomain</command> işlevi ile etkinleştirilen ya da <command>dgettext</command> veya <command>dcgettext</command> işlevinde ilk parametre olarak blirtilen yazılım kodunun alan ismidir; başka bir deyişle yazılımcının pakete verdiği isimdir. Örneğin GNU C kütüphanesi için alan ismi <command>libc</command>'dir.
     </para><para>
Yazılımcının bu işlemi nasıl yapacağını gösteren bir örnek kod parçası:
     </para><para>
<screen>
{
  setlocale (LC_ALL, &quot;&quot;);
  textdomain (&quot;test-package&quot;);
  bindtextdomain (&quot;test-package&quot;, &quot;/usr/local/share/locale&quot;);
  puts (gettext (&quot;Hello, world!&quot;));
}
</screen></para><para>
Yazılım ilk çalıştırıldığında öntanımlı alan <command>messages</command>, öntanımlı yerel &quot;C&quot;dir.  <command>setlocale</command> çağrısı yereli kullanıcının atadığı ortam değişkenlerine bağlı olarak değiştirir. Yukarıda bahsedildiği gibi ileti kataloglarının yerini bulmak için <command>gettext</command> işlevleri <command>LC_MESSAGES</command> kategorisini, karakter kümesi dönüşümü için <command>LC_CTYPE</command> kategorisini kullanıyordu. <command>setlocale</command> çağrısı ile bunlar kullanıcının seçimlerine göre belirlenmiş oluyor. <command>textdomain</command> çağrısı ile <command>test-package</command> alan isimli ileti kataloğunun kullanılacağını, <command>bindtextdomain</command> çağrısı ile de bu kataloğun bulunacağı yeri <command>/usr/local/share/locale</command> olarak belirtmiş oluyoruz.
     </para><para>
Kullanıcı <command>LANGUAGE</command> ortam değişkenine <command>tr</command> değerini atarsa <command>gettext</command> işlevi
     </para><para>
<filename>/usr/local/share/locale/tr/LC_MESSAGES/test-package.mo</filename>
     </para><para>
iletiği kataloğunu kullanacaktır.
     </para><para>
Bu örnekte <command>LANGUAGE</command> ortam değişkenine <command>tr</command> değerini atadığımızı varsaydık. Eğer kullanıcı bunun yerine değeri <literal>tr_TR.UTF-8</literal> olan <command>LC_ALL</command> ortam değişkenini kullanmak isteseydi ne olacaktı? Yukarıda bu gibi durumlara pek sık rastlanmadığından  bahsetmiştik. Örneğin, kullanıcının tercih ettiği dil olarak son çare resmi dil değilse kullanıcı kendi lehçesini tercih edebilir.
     </para><para>
<command>gettext</command> bu gibi duramlara da hazırlıklıdır. İşlevler bu değişkenin değerinin biçimini tanır. Değeri parçalarına ayırarak içinden kendi kullanacağı değeri alır. Bu işlem şüphesiz bir önkabule dayanır. Ortam değişkeninin değerini oluşturan biçim az ya da çok standarttır. X/Open belirtimi şöyledir:
     </para><para>
<command>dil[_ülke[.karakterkümesi]][@değiştirici]</command></para><para>
Yerel ismi şu sıraya göre ayıklanır:
     </para><para><orderedlist numeration="arabic">
     <listitem><para><command>karakterkümesi</command>
     </para></listitem><listitem><para><command>normalleştirilmiş karakterkümesi</command>
     </para></listitem><listitem><para><command>ülke</command>
     </para></listitem><listitem><para><command>değiştirici</command>
     </para></listitem></orderedlist></para><para>
<command>dil</command> alanı bilinen sebeplerle asla kaldırılmayacaktır.
     </para><para>
Burada yeni olan <command>normalleştirilmiş karakterkümesi</command> girdisidir. Çoğu kişi standart haline gelmiş isimleri yanlış hatırlar ve örneğin ISO-8859-9 yerine iso8859-9, iso_8859-9, 88599, 8859-9 gibi değerler yazabilirler. <command>normalleştirilmiş karakterkümesi</command> değeri şu kurallar izlenerek oluşturulur:
     </para><para><orderedlist><listitem><para>
Sayılar ve harfler dışında tüm karakterler kaldırılır.
       </para></listitem><listitem><para>
Harflerin tamamı küçük harfe dönüştürülür.
       </para></listitem><listitem><para>
Rakamlar <command>"iso"</command> dizgesi ile öncelenmemişse öncelenir.
       </para></listitem></orderedlist>
     </para><para>
Örneğimizdeki isim <command>iso88599</command> olarak normalleştirilir. Böylece kullanıcıya yerel ismini belirtirken daha fazla serbestlik sağlanmış olur.
     </para><para>
Ancak bu kadar genişletilmiş işlevsellik bile aynı dili belirtirken kullanılabilen farklı isimler için bir çözüm sağlamaz (örneğin, <command>tr</command> ve <command>turkish</command>). Hem yerel gerçeklemesi hem de <command>gettext</command> bu gibi durumlarda yardımseverdir.
     </para><para>
<command>/usr/share/locale/locale.alias</command> dosyası (C kütüphanesini derlerken <command>/usr</command> yerine ne belirttiyseniz, <command>/usr</command> yerine onu yazın) dil isimleriyle yerel isimlerini eşleştiren bir liste içerir. Sistem yöneticisi bu listeye yeni girdiler eklemekte özgürdür. Ortam değişkenleri ile seçilmiş isim bu listedekilerle karşılaştırılır. Bir eşleşme bulunursa ikinci sütundaki değer kullanılır.
     </para></sect2></sect1>
     <sect1 xml:id="glibc-Helper-programs-for-gettext">
     <title><literal>gettext</literal> için Yardımcı Uygulamalar</title>
     <titleabbrev><command>gettext</command> için ileti kataloglarını elde eden uygulamalar</titleabbrev>
     <para>
GNU C kütüphanesi <command>gettext</command> işlevleri için yazılımın kaynak kodundan ileti kataloğunu oluşturacak yazılımları içermez. GNU projesinin bir parçası olarak GNU gettext paketi geliştiricinin ihtiyaç duyabileceği herşeyi içerir. Bu paketle sağlanmış araçlar, <command>catgets</command> işlevlerinin ileti kataloğunu elde eden <command>gencat</command> uygulamasından daha fazla yetenekli olmayı gerektirir.
    </para><para>
<command>gencat</command> uygulamasına eşdeğer olarak <command>msgfmt</command> uygulaması gösterilebilir. Metin biçimindeki ileti kataloglarından <command>gettext</command> işlevlerinin kullanabileceği ikilik biçimdeki ileti kataloglarını elde etmekte kulanılır. Ama sırf bu değil, pakette daha pek çok uygulama vardır.
    </para><para>
<command>xgettext</command> uygulaması bir kaynak dosyasından çevrilebilir dizgeleri toplamakta kullanılır. Yani yazılımcı geliştirme sırasında ileti kataloğunu elle oluşturmak zorunda değildir. Bu uygulama girdinin daha iyi anlaşılabilmesini ve çıktının özelleştirilebilmesini sağlayan seçenekler içerir.
    </para><para>
Paket, sadece yazılımın geliştiricisinin değil çevirmenlerin de kullanabileceği araçları içerir. GNU <command>gettext</command> kılavuzunda bunlar hakkında ayrıntılı bilgi bulabilirsiniz.
    </para></sect1>
  </chapter>
</part>

