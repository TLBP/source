<?xml version="1.0" encoding="UTF-8"?>
<!-- ********************************************************************
     $Id: ch14.xml,v 1.2 2002/12/20 22:29:48 nilgun Exp $
******************************************************************** -->
<part xml:id="glibc-File-System-Interface">
  <title>Dosya Sistemi Arayüzü</title>
  <titleabbrev>Dosyalarla çalışmak için işlevler.</titleabbrev>
  <partintro><para>
Bu oylumda dosyalarla çalışmak için kullanılan GNU C kütüphanesi işlevleri açıklanmıştır. Girdi ve çıktı işlevlerinin tersine (<xref linkend="glibc-I-O-on-Streams"/>; <xref linkend="glibc-Low-Level-I-O"/>), bu işlevler dosyaların içerikleri ile değil dosyaların kendileriyle ilgili işlemleri yaparlar.
  </para><para>
Bu oylumda açıklanan oluşumlar arasında, dizinleri değiştiren veya inceleyen işlevler, dosyaları silen ya da ismini değiştiren işlevler ve erişim yetkileri ve değişiklik zamanları gibi dosya özniteliklerini incelemek ve değiştirmek için kullanılan işlevler sayılabilir.
  </para></partintro>
  <chapter xml:id="glibc-Working-Directory">
    <title>Çalışma dizini</title>
    <titleabbrev>Göreli dosya isimlerini çözümlemede kullanılır.</titleabbrev>
    <para>
<indexterm scope="glibc-cp"><primary>dosyalar</primary><secondary>çalışma dizini</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>çalışma dizini</primary></indexterm>
<indexterm scope="glibc-cp"><primary>dizinler</primary><secondary>çalışma dizini</secondary></indexterm>
Her sürecin kendisiyle ilişkili bir dizini vardır. Bu dizine <wordasword>çalışma dizini</wordasword> denir ve göreli dosya isimlerinin çözümlenmesinde kullanılır (bkz. <xref linkend="glibc-File-Name-Resolution"/>).
   </para><para>
Sisteme oturum açtığınızda, sistem veritabanındaki kullanıcı hesabınızla ilişkili ev dizininiz çalışma dizininiz yapılır. Bir kullanıcının ev dizinini <command>getpwuid</command> veya <command>getpwnam</command> işleviyle bulabilirsiniz; bkz. <xref linkend="glibc-User-Database"/>.
   </para><para>
Kullanıcılar çalışma dizinlerini <command>cd</command> gibi kabuk komutlarını kullanarak değiştirebilirler. Bu bölümde açıklanan işlevler bu komutlarda ve çalışma dizinini değiştirmek ve incelemek için başka yazılımlarda kullanılan ilkellerdir.
<indexterm scope="glibc-pg"><primary>cd</primary></indexterm>
Bu işlevlerin prototipleri <filename>unistd.h</filename> başlık dosyasında bildirilmiştir.
<indexterm scope="glibc-pg"><primary>unistd.h</primary></indexterm>
   </para><para xml:id="glibc-getcwd">
<indexterm scope="glibc-fn"><primary>getcwd</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>char *<command>getcwd</command></funcdef>
<paramdef>(char  *<varname>tampon</varname>,
 size_t <varname>boyut</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>getcwd</command> işlevi sizin tarafınızdan sağlanan <varname>tampon</varname> karakter dizisine o anki çalışma dizinini ifade eden mutlak dosya ismini kaydederek döner. <varname>boyut</varname> argümanı ile sisteme <varname>tampon</varname> için ayrılan boyut bildirilir.
   </para><para>
Bu işlevin GNU kütüphanesindeki sürümü <varname>tampon</varname> argümanı olarak bir boş gösterici belirtebilmenizi mümkün kılar. Bu durumda <command>getcwd</command> işlevi <command>malloc</command> ile tamponu kendisi ayırır (bkz. <xref linkend="glibc-Unconstrained-Allocation"/>).  Eğer <varname>boyut</varname> sıfırdan büyükse, tampon bu kadar daha büyük olur, aksi takdirde tampon sonucu tutmaya yetecek büyüklükte olur.
   </para><para>
İşlevin normal dönüş değeri <varname>tampon</varname>'dur. Başarısızlık halinde boş gösterici döner. Aşağıdaki <command>errno</command> hata durumları bu işlev için tanımlanmıştır:
   </para><para><variablelist><varlistentry>
   <term><literal>EINVAL</literal></term><listitem><para>
<varname>boyut</varname> argümanı sıfır ve <varname>tampon</varname> boş gösterici değil.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>ERANGE</literal></term><listitem><para>
<varname>boyut</varname> argümanı ile belirtilen uzunluk çalışma dizini isminden daha kısa. Daha büyük dizi ayırarak yeniden deneyin.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>EACCES</literal></term><listitem><para>
Dosya isminin bir elemanını aramak ya da okumak için izin verilmedi.
      </para></listitem></varlistentry></variablelist>
    </para><para>
GNU'nun <command>getcwd (NULL, 0)</command> davranışını sadece <command>getcwd</command> işlevinin standart davranışını kullanarak gerçekleştirebilirdiniz:
   </para><para>
<screen>char *
gnu_getcwd ()
{
  size_t size = 100;

  while (1)
    {
      char *buffer = (char *) xmalloc (size);
      if (getcwd (buffer, size) == buffer)
        return buffer;
      free (buffer);
      if (errno != ERANGE)
        return 0;
      size *= 2;
    }
}
</screen></para><para>
Bir kütüphane işlevi olmayan ama çoğu GNU yazılımında kullanılan bir özelleştirilmiş isim olan <command>xmalloc</command> hakkında daha fazla bilgi için <xref linkend="glibc-Malloc-Examples"/> bölümüne bakınız.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-getwd">
<indexterm scope="glibc-fn"><primary>getwd</primary></indexterm>
<funcsynopsis><funcprototype role="önerilmeyen işlev">
<funcdef>char *<command>getwd</command></funcdef>
<paramdef>(char *<varname>tampon</varname>)</paramdef>
</funcprototype><funcdescr><para>
Tampon için boyut belirtilmemesi dışında <command>getcwd</command> işlevinin benzeridir. <command>getwd</command> işlevi sadece BSD uyumluluğu için GNU kütüphanesine dahil edilmiştir.
   </para><para>
<varname>tampon</varname> argümanı en azından  <command>PATH_MAX</command> bayt uzunluktaki bir tampona gösterici olmalıdır (bkz. <xref linkend="glibc-Limits-for-Files"/>).  GNU sisteminde dosya ismi için bir sınırlama yoktur, yani dizin ismini içerecek yeterli alan için bu gereksizdir. Bu, bu işlevin kullanılmasının önerilmeme sebebidir.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-get_current_dir_name">
<indexterm scope="glibc-fn"><primary>get_current_dir_name</primary></indexterm>
<indexterm scope="glibc-vr"><primary>PWD</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>char *<command>get_current_dir_name</command></funcdef>
<paramdef>(void)</paramdef>
</funcprototype><funcdescr><para>
<command>get_current_dir_name</command> işlevi aslında <command>getcwd (NULL, 0)</command> çağrısının eşdeğeridir.  Tek fark, <command>PWD</command> değişkeninin değerinin (eğer doğruysa) dönmesidir. Bu anlaşılması zor bir farktır.
Eğer <command>PWD</command> değeri ile açıklanan dosya yolu bir ya da daha fazla sembolik bağ kullanıyorsa, değerin <command>getcwd</command> tarafından döndürülmesi durumunda sembolik bağlar çözümlenebilir ve bu bakımdan farklı bir sonuç ortaya çıkabilir.
   </para><para>
Bu işlev bir GNU oluşumudur.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-chdir">
<indexterm scope="glibc-fn"><primary>chdir</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>chdir</command></funcdef>
<paramdef>(const char *<varname>dosyaismi</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev sürecin çalışma dizinini <varname>dosyaismi</varname> yapar.
   </para><para>
İşlevin normal dönüş değeri <command>0</command>'dır.  <command>-1</command> değeri dönmüşse bir hata oluşmuş demektir. Bu işlev için tanımlanmış <command>errno</command> hata durumları <link linkend="glibc-File-Name-Errors">dosya ismi sözdizimi hataları</link> ile <varname>dosyaismi</varname> ismi bir dizin değilse <command>ENOTDIR</command>'dır.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-fchdir">
<indexterm scope="glibc-fn"><primary>fchdir</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>fchdir</command></funcdef>
<paramdef>(int <varname>dosyatanıtıcı</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev sürecin çalışma dizinini <varname>dosyatanıtıcı</varname> ile ilişkili dizin yapar.
   </para><para>
İşlevin normal dönüş değeri <command>0</command>'dır.  <command>-1</command> değeri dönmüşse bir hata oluşmuş demektir. Bu işlev için tanımlanmış <command>errno</command> hata durumları:
   </para><para><variablelist><varlistentry>
   <term><literal>EACCES</literal></term><listitem><para>
<command>dirname</command> tarafından döndürülen dizin için okuma izni verilmedi.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>EBADF</literal></term><listitem><para>
<varname>dosyatanıtıcı</varname> geçerli bir dosya tanıtıcı değil.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>ENOTDIR</literal></term><listitem><para>
<varname>dosyatanıtıcı</varname> bir dizin ile ilişkili değil.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>EINTR</literal></term><listitem><para>
İşlev çağrısı bir sinyal ile engellendi.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>EIO</literal></term><listitem><para>
Bir G/Ç hatası oluştu.
      </para></listitem></varlistentry></variablelist>
  </para></funcdescr></funcsynopsis></para></chapter>
  <chapter xml:id="glibc-Accessing-Directories">
    <title>Dizinlere Erişim</title>
    <titleabbrev>Bir dizindeki dosyaların bulunması.</titleabbrev>
    <para>
<indexterm scope="glibc-cp"><primary>dosyalar</primary><secondary>dizinlere erişim</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>dosyalar</primary><secondary>bir dizinden okunması</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>dizinler</primary><secondary>erişim</secondary></indexterm>
Bu kısımda açıklanan oluşumlar bir dizin dosyasının içeriğini okumanızı sağlar. Eğer yazılımınızın bir dizindeki tüm dosyaları listelemesini isterseniz bu kullanışlıdır.
   </para><para>
<indexterm scope="glibc-cp"><primary>dizin akımı</primary></indexterm>
<command>opendir</command> işlevi elemanları dizin girdileri olan bir <wordasword>dizin akımı</wordasword> açar. Yazılımın okumak için açılmış dizin üzerinde daha fazla denetim sağlayabilmesi gibi getirileri için bunun yerine <command>fdopendir</command> işlevi de kullanılabilir. Bu, örneğin, <command>open</command> işlevine <command>O_NOATIME</command> seçeneğinin aktarılmasını mümkün kılar.
   </para><para>
Bu girdileri <command>struct dirent</command> nesneleri olarak almak için dizin akımı üzerinde <command>readdir</command> işlevini kullanabilirsiniz. Her girdinin dosya ismi bu yapının <command>d_name</command> üyesinde saklanır. Burada sıradan dosyaların <link linkend="glibc-I-O-on-Streams">akım oluşumları</link> ile açıkça paralellikler vardır.
   </para>
    <sect1 xml:id="glibc-Directory-Entries">
      <title>Dizin Girdileri</title>
      <titleabbrev>Bir dizin girdisinin biçimi</titleabbrev>
      <para>
<indexterm scope="glibc-pg"><primary>dirent.h</primary></indexterm>
Bu bölümde bir dizin akımından sağlanan tek bir dizin girdisinde bulacaklarınız açıklanacaktır. Bu bölümdeki tüm semboller <filename>dirent.h</filename> başlık dosyasında bildirilmiştir.
    </para><para xml:id="glibc-dirent">
<indexterm scope="glibc-tp"><primary sortas="dirent">struct dirent</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü">
<funcdef>struct <command>dirent</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Dizin girdileri hakkında bilgi döndürmekte kullanılan yapıdır. Şu üyelere sahiptir:
    </para><para><glosslist><glossentry><glossterm>
    <literal>char <command>d_name</command>[]</literal>
    </glossterm><glossdef><para>
Boş karakter sonlandırmalı dosya ismi elemanıdır. Bu yapının üyesi olarak tüm POSIX sistemlerinde bulabileceğiniz tek üyedir.
    </para></glossdef></glossentry><glossentry><glossterm>
    <literal>ino_t <command>d_fileno</command></literal>
    </glossterm><glossdef><para>
Dosyanın seri numarasıdır. BSD uyumluluğu için bu üyeye <command>d_ino</command> ismiyle de erişebilirsiniz. GNU siteminde ve çoğu POSIX sisteminde, bu üye, çoğu dosya için <command>stat</command> çağrısından dönen <command>st_ino</command> üyesi ile aynıdır. Bkz. <xref linkend="glibc-File-Attributes"/>.
    </para></glossdef></glossentry><glossentry><glossterm>
    <literal>unsigned char <command>d_namlen</command></literal>
    </glossterm><glossdef><para>
Dosya isminin sonlandırıcı boş karakter içermeyen <command>unsigned char</command> türünden uzunluğudur. Eğer bu üye varsa, sembolü  <command>_DIRENT_HAVE_D_NAMLEN</command> tanımlıdır.
    </para></glossdef></glossentry><glossentry><glossterm>
    <literal>unsigned char <command>d_type</command></literal>
    </glossterm><glossdef><para>
Dosyanın türüdür. Değeri için tanımlanmış sabitler:
       </para><para><variablelist><varlistentry>
       <term><literal>DT_UNKNOWN</literal></term><listitem><para>
Dosya türü bilinmiyor. Bazı sistemlerde dönen tek değerdir.
          </para></listitem></varlistentry><varlistentry>
          <term><literal>DT_REG</literal></term><listitem><para>
Normal bir dosya.
          </para></listitem></varlistentry><varlistentry>
          <term><literal>DT_DIR</literal></term><listitem><para>
Bir dizin.
          </para></listitem></varlistentry><varlistentry>
          <term><literal>DT_FIFO</literal></term><listitem><para>
Bir isimli boru ya da FIFO. Bkz. <xref linkend="glibc-FIFO-Special-Files"/>.
          </para></listitem></varlistentry><varlistentry>
          <term><literal>DT_SOCK</literal></term><listitem><para>
Bir yerel alan soketi.
          </para></listitem></varlistentry><varlistentry>
          <term><literal>DT_CHR</literal></term><listitem><para>
Bir karakter aygıtı.
          </para></listitem></varlistentry><varlistentry>
          <term><literal>DT_BLK</literal></term><listitem><para>
Bir blok aygıtı.
          </para></listitem></varlistentry></variablelist></para><para>
Bu üye bir GNU oluşumudur. Eğer bu üye varsa, sembolü  <command>_DIRENT_HAVE_D_TYPE</command> tanımlıdır. Kullanıldığı sistemlerde <command>struct statbuf</command> yapısının <command>st_mode</command> üyesindeki dosya türü bitlerine karşı düşer. Eğer değer saptanamazsa üyenin değeri <command>DT_UNKNOWN</command> olur. Şu iki makro <command>d_type</command> ile <command>st_mode</command> değerleri arasında dönüşüm yapar:
</para><para xml:id="glibc-IFTODT">
<indexterm scope="glibc-fn"><primary>IFTODT</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>int <command>IFTODT</command></funcdef>
<paramdef>(mode_t <varname>st_mode</varname>)</paramdef>
</funcprototype><funcdescr><para>
Belirtilen <command>st_mode</command> değerine karşı düşen <command>d_type</command> değeri ile döner.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-DTTOIF">
<indexterm scope="glibc-fn"><primary>DTTOIF</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>mode_t <command>DTTOIF</command></funcdef>
<paramdef>(int <varname>d_type</varname>)</paramdef>
</funcprototype><funcdescr><para>
Belirtilen <command>d_type</command> değerine karşı düşen <command>st_mode</command> değeri ile döner.
</para></funcdescr></funcsynopsis></para><para>
</para></glossdef></glossentry></glosslist>
</para></funcdescr></funcsynopsis></para><para>
Bu yapı ileride ek üyeler içerebilir. Yeni üyeler olduğunda derleme ortamında daima <command>_DIRENT_HAVE_D_<varname>xxx</varname></command> biçiminde bir makro ismiyle görünecektir. Burada <varname>xxx</varname> yeni üyenin ismidir. Örneğin, bazı sistemlerde <command>d_reclen</command> diye bir üye vardır ve bu sistemlerde <command>_DIRENT_HAVE_D_RECLEN</command> makrosu tanımlıdır.
    </para><para>
Bir dosyanın çok sayıda ismi varsa, her ismin kendi dizin girdisi olur.  Böyle dosya isimlerinin tek bir dosyaya ait olup olmadığı <command>d_fileno</command> alanındaki değere bakarak anlaşılır. Bu üyenin değeri bu tür girdilerde aynıdır.
    </para><para>
Boyut, değişiklik zamanı gibi dosya öznitelikleri dosyanın kendisinde bulunur, bir dizin girdisinin elemenları değillerdir. Bkz. <xref linkend="glibc-File-Attributes"/>.
    </para></sect1>
  <sect1 xml:id="glibc-Opening-a-Directory">
    <title>Bir Dizin Akımının Açılması</title>
    <titleabbrev>Bir dizin akımı nasıl açılır?</titleabbrev>
    <para>
<indexterm scope="glibc-pg"><primary>dirent.h</primary></indexterm>
Bu bölümde bir dizin akımının nasıl açılacağından bahsedilecektir. Bu bölümdeki tüm semboller  <filename>dirent.h</filename> başlık dosyasında bildirilmiştir.
    </para><para xml:id="glibc-DIR">
<indexterm scope="glibc-tp"><primary>DIR</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü">
<funcdef><command>DIR</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
<command>DIR</command> bir dizin akımını ifade eden veri türüdür.
</para></funcdescr></funcsynopsis></para><para>
Dizin erişim işlevleri sizin yerinize bu işi yaptığından, <command>struct dirent</command> veya <command>DIR</command> türünde nesneler ayırmamalısınız. Bu nesnelere gösterici döndüren işlevleri kullanarak bu nesnelere erişebilirsiniz.
    </para><para xml:id="glibc-opendir">
<indexterm scope="glibc-fn"><primary>opendir</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>DIR *<command>opendir</command></funcdef>
<paramdef>(const char *<varname>dizinismi</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>opendir</command> işlevi ismi <varname>dizinismi</varname> olan dizini okumak için bir dizin akımı döndürür. Akım  <command>DIR *</command> türündedir.
    </para><para>
İşlev başarısız olursa boş gösterici döndürür. <link linkend="glibc-File-Name-Errors">Dosya ismi hatalarına</link> ek olarak aşağıdaki <command>errno</command> hata durumları bu işlev için tanımlanmıştır:
    </para><para><variablelist><varlistentry>
    <term><literal>EACCES</literal></term><listitem><para>
<command>dirname</command> ile döndürülen dizini okuma izni verilmedi.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>EMFILE</literal></term><listitem><para>
Süreç çok fazla dosya açmış.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>ENFILE</literal></term><listitem><para>
Dizini içeren sistem ya da dosya sistemi şu anda daha fazla dosya açılmasını desteklemiyor. (GNU sisteminde böyle bir sorun asla olmaz.)
       </para></listitem></varlistentry><varlistentry>
       <term><literal>ENOMEM</literal></term><listitem><para>
Yeterli bellek yok.
       </para></listitem></varlistentry></variablelist>
     </para><para>
<command>DIR</command> türü genellikle bir dosya tanıtıcı kullanılarak gerçeklenir ve  <command>opendir</command> işlevi de <command>open</command> ilkelini kullanır. Bkz. <xref linkend="glibc-Low-Level-I-O"/>.  Dizin akımları ve daha alt seviyede dosya tanıtıcıları bir <command>exec</command> (<xref linkend="glibc-Executing-a-File"/>) çağrısı yapıldığında kapatılırlar.
</para></funcdescr></funcsynopsis></para><para>
<command>opendir</command> tarafından okumak için açılan dizin ismiyle tanınır. Bazı durumlarda bu kafi değildir. Ya da <command>opendir</command> yoluyla dizin için örtük olarak oluşturulan bir dosya tanıtıcı yazılımda istenen yol değildir. Bu gibi durumlarda başka bir arayüz kullanılabilir.
    </para><para>
<indexterm scope="glibc-fn"><primary>opendir</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>DIR *<command>fopendir</command></funcdef>
<paramdef>(int <varname>dosyatanıtıcı</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>fdopendir</command> işlevi bir dosya ismi almak ve dizin için bir dosya tanıtıcı açmak yerine dosya tanıtıcının çağrı sırasında belirtilmesini gerektirmesi dışında <command>opendir</command> gibi çalışır. Bu dosya tanıtıcı dönen dizin akımı nesnesinin daha sonraki kullanımlarında kullanılır.
    </para><para>
İşlev çağrılırken kullanılan dosya tanıtıcının bir dizin ile ilişkili olduğundan ve okumaya izin verdiğinden emin olunmalıdır.
    </para><para>
<command>fdopendir</command> çağrısı başarılı olursa dosya tanıtıcı sitemin denetimi altına girer. <command>opendir</command> tarafından örtük olarak oluşturulan tanıtıcının kullanıldığı gibi kullanılabilir fakat yazılım tanıtıcıyı kapatmamalıdır.
    </para><para>
İşlev başarısız olduğu durumlarda bir boş gösterici döndürür ve dosya tanıtıcı yazılım tarafından kullanılabilir olarak kalır. Aşağıdaki <command>errno</command>  hata durumları bu işlev için tanımlanmıştır:
    </para><para><variablelist><varlistentry>
      <term><literal>EBADF</literal></term><listitem><para>
Dosya tanıtıcı geçersiz.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>ENOTDIR</literal></term><listitem><para>
Dosya tanıtıcı dizinle ilgili değil
      </para></listitem></varlistentry><varlistentry>
      <term><literal>EINVAL</literal></term><listitem><para>
Dosya tanıtıcı dizin içeriğinin okunmasına izin vermiyor.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>ENOMEM</literal></term><listitem><para>
Yeterli bellek yok.
       </para></listitem></varlistentry></variablelist>
     </para></funcdescr></funcsynopsis></para><para>
Bazı durumlarda <command>opendir</command> çağrısı ile oluşturulan dosya tanıtıcıya erişmek istenebilir. Örneğin, çalışma dizinini bir dosya tanıtıcı kullanarak değiştiren <command>fchdir</command> işlevi için bu gerekli olabilirdi. Tarihsel olarak <command>DIR</command> türü ile fazla uğraşıldığından yazılımlar alanlarına erişemezler. Ancak GNU kütüphanesinde bu böyle değildir. Erişimi sağlamak için ayrı bir işlev vardır.
    </para><para xml:id="glibc-dirfd">
<indexterm scope="glibc-fn"><primary>dirfd</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>dirfd</command></funcdef>
<paramdef>(DIR *<varname>dizinakımı</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>dirfd</command> işlevi <varname>dizinakımı</varname> ile ilişkili dosya tanıtıcı ile döner. Dizin tanıtıcı dizin akımı <command>closedir</command> ile kapatılıncaya kadar geçerli kalır. Eğer dizin akımı gerçeklemesi dosya tanıtıcılarını kullanmıyorsa işlev <command>-1</command> ile döner.
  </para></funcdescr></funcsynopsis></para></sect1>
  <sect1 xml:id="glibc-Reading-Closing-Directory">
    <title>Dizin Akımlarının Okunması ve Kapatılması</title>
    <titleabbrev>Akımdaki dizin girdileri nasıl okunur?</titleabbrev>
    <para>
<indexterm scope="glibc-pg"><primary>dirent.h</primary></indexterm>
Bu bölümde bir dizin akımından girdilerin nasıl okunacağı ve akımla işiniz bittiğinde onu nasıl kapatacağınız anlatılacaktır. Bu bölümdeki tüm semboller <filename>dirent.h</filename> başlık dosyasında bildirilmiştir.
    </para><para xml:id="glibc-readdir">
<indexterm scope="glibc-fn"><primary>readdir</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>struct dirent *<command>readdir</command></funcdef>
<paramdef>(DIR *<varname>dizinakımı</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev dizindeki sonraki girdiyi okur. Normalde dosya hakkında bilgi içeren bir yapıya gösterici ile döner. Bu yapı durağan olarak ayrıldığından işlevin sonraki çağrıları üzerine yazabilir.
    </para><para>
<note><title>Taşınabilirlik Bilgisi</title><para>Bazı sistemlerde <command>readdir</command> işlevi <command>.</command> ve <command>..</command> için, bunlar her dizinde daima geçerli dosya isimleri oldukları halde, girdi döndürmez. Bkz. <xref linkend="glibc-File-Name-Resolution"/>.</para></note>
    </para><para>
Eğer dizinde başka girdi kalmamışsa ya da bir hata saptanmışsa işlev bir boş gösterici ile döner. Aşağıdaki <command>errno</command> hata durumu bu işlev için tanımlanmıştır:
    </para><para><variablelist><varlistentry>
    <term><literal>EBADF</literal></term><listitem><para>
<varname>dizinakımı</varname> argümanı geçersiz.
       </para></listitem></varlistentry></variablelist>
</para></funcdescr></funcsynopsis></para><para>
<command>readdir</command> işlevi evresel değildir. Çok evreli yazılımlarda aynı <varname>dizinakımı</varname> ile <command>readdir</command> kullanımı dönüş değerinin üzerine yazar. Bu durum sorun oluyorsa bu işlev yerine <command>readdir_r</command> işlevini kullanın.
</para><para xml:id="glibc-readdir_r">
<indexterm scope="glibc-fn"><primary>readdir_r</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>readdir_r</command></funcdef>
<paramdef>(DIR            *<varname>dizinakımı</varname>,
 struct dirent  *<varname>girdi</varname>,
 struct dirent **<varname>sonuç</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev <command>readdir</command> işlevinin evresel sürümüdür. <command>readdir</command> işlevi gibi dizindeki sonraki girdiyi okur. Fakat sonuç durağan ayrılmış bellekte saklanmadığından aynı anda çalışan evreler arasında bir soruna yol açmaz. Sonuç <varname>girdi</varname> ile gösterilen nesne içinde döner.
    </para><para>
Normalde, <command>readdir_r</command> işlevi sıfırla döner ve <varname>girdi</varname> <varname>*sonuç</varname>'a atanır.  Okunacak başka girdi kalmamışsa ya da bir hata saptanmışsa <command>readdir_r</command>  <varname>*sonuç</varname>'a bir boş gösterici atar ve sıfırdan farklı bir hata kodu ile döner. Ayrıca bu hata kodunu <command>errno</command> değişkenine atar. Bu işlev için tanımlanmış hata kodları <command>readdir</command> ile aynıdır.
    </para><para>
<note><title>Taşınabilirlik Bilgisi</title><para>Bazı sistemlerde <command>struct dirent</command> yapısının <command>d_reclen</command> diye bir üyesi olmasa ve dosya isminin izin verilen en büyük boyutta olabilmesine izin verilse bile <command>readdir_r</command> dosya ismi için boş karakter sonlandırmalı dizge döndürmeyebilir. Günümüzdeki sistemlerin tamamı <command>d_reclen</command> alanına sahiptir ve eski sistemlerde çok evrelilik pek sorun oluşturmaz. Her durumda <command>readdir</command> ile ilgili böyle bir sorun yoktur, yani <command>d_reclen</command> üyesine sahip olmayan sistemlerde bile harici kilitleme ile çok evrelilik mümkün olur.</para></note>
    </para><para>
Ayrıca, <command>struct dirent</command> türünün tanımlanması da önem kazanır. <command>readdir_r</command> işlevinin ikinci parametresinde bu türde bir nesneye basitçe gösterici atanması yeterli olmayabilir. Bazı sistemler <command>d_name</command> elemanını yeterli uzunlukta tanımlamazlar. Bu durumda kullanıcının ek alan sağlaması gerekir. <command>d_name</command> dizisinde en azından <command>NAME_MAX + 1</command> karakterlik alan bulunmalıdır. <command>readdir_r</command> çağrısı şöyle yapılabilir:
    </para><para>
<screen>  union
  {
    struct dirent d;
    char b[offsetof (struct dirent, d_name) + NAME_MAX + 1];
  } u;

  if (readdir_r (dir, &amp;u.d, &amp;res) == 0)
    …
</screen>
</para></funcdescr></funcsynopsis></para><para>
32 bitlik makineler üzerinde büyük dosyasistemlerini desteklemek için son iki işlevin LFS sürümleri de vardır.
    </para><para xml:id="glibc-readdir64">
<indexterm scope="glibc-fn"><primary>readdir64</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>struct dirent64 *<command>readdir64</command></funcdef>
<paramdef>(DIR *<varname>dizinakımı</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>readdir64</command> işlevi <command>struct dirent64</command> türünde bir gösterici döndürmesi dışında <command>readdir</command> işlevi gibidir. Bu veri türünün bazı üyeleri (özellikle <command>d_ino</command> üyesi) büyük dosyasistemlerini desteklemek üzere farklı boyutta olabilir.
    </para><para>
Diğer bakımlardan bu işlev <command>readdir</command> işleviyle eşdeğerdedir.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-readdir64_r">
<indexterm scope="glibc-fn"><primary>readdir64_r</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>readdir64_r</command></funcdef>
<paramdef>(DIR              *<varname>dizinakımı</varname>,
 struct dirent64  *<varname>girdi</varname>,
 struct dirent64 **<varname>sonuç</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>readdir64_r</command> işlevi 2. ve 3. parametrelerini <command>struct dirent64</command> türünde alması dışında  <command>readdir_r</command> işlevi gibidir. <command>readdir_r</command> işlevinin açıklamalarında dikkat çekilen hususlar bu işlev için de geçerlidir.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-closedir">
<indexterm scope="glibc-fn"><primary>closedir</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>closedir</command></funcdef>
<paramdef>(DIR *<varname>dizinakımı</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev <varname>dizinakımı</varname> ile belirtilen dizin akımını kapatır. Başarılıysa <command>0</command>, değilse  <command>-1</command> döndürür.
    </para><para>
Aşağıdaki <command>errno</command> hata durumu bu işlev için tanımlanmıştır:
    </para><para><variablelist><varlistentry>
    <term><literal>EBADF</literal></term><listitem><para>
<varname>dizinakımı</varname> argümanı geçersiz.
    </para></listitem></varlistentry></variablelist>
    </para></funcdescr></funcsynopsis></para>
  </sect1>
  <sect1 xml:id="glibc-Simple-Directory-Lister">
    <title>Bir Dizinin İçeriğini Listeleyen Bir Örnek</title>
    <titleabbrev>Çok basit bir dizin listeleme yazılımı.</titleabbrev>
    <para>
Burada verilen örnek kod çalışma dizini içindeki dosyaların isimlerini listelemektedir:
    </para><para>
<screen>#include &lt;stdio.h>
#include &lt;sys/types.h>
#include &lt;dirent.h>

int
main (void)
{
  DIR *dp;
  struct dirent *ep;

  dp = opendir (&quot;./&quot;);
  if (dp != NULL)
    {
      while (ep = readdir (dp))
        puts (ep->d_name);
      (void) closedir (dp);
    }
  else
    perror (&quot;Dizin açılamadı&quot;);

  return 0;
}
</screen></para><para>
Çıktılanan listede dosyaların sırası hemen hemen rasgeledir. Daha kullanışlı bir yazılım girdileri basmadan önce sıraya sokardı; bkz. <xref linkend="glibc-Scanning-Directory-Content"/> ve <xref linkend="glibc-Array-Sort-Function"/>.
    </para></sect1>
  <sect1 xml:id="glibc-Random-Access-Directory">
    <title>Dizin Akımında Rasgele Erişim</title>
    <titleabbrev>Aynı akımla zaten okunmuş olan dizin içeriğinin bir kısmının yeniden okunması</titleabbrev>
    <para>
<indexterm scope="glibc-pg"><primary>dirent.h</primary></indexterm>
Bu bölümde açık bir dizin akımından zaten okunmuş olan bir dizin parçasının yeniden nasıl okunacağından bahsedilecektir. Bu bölümdeki tüm semboller <filename>dirent.h</filename> başlık dosyasında bildirilmiştir.
    </para><para xml:id="glibc-rewinddir">
<indexterm scope="glibc-fn"><primary>rewinddir</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>void <command>rewinddir</command></funcdef>
<paramdef>(DIR *<varname>dizinakımı</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>rewinddir</command> işlevi <varname>dizinakımı</varname> ile belirtilen dizin akımını yeniden ilklendirmekte kullanılır. Böylece bir <command>readdir</command>  çağrısı ile dizindeki ilk girdi ile ilgili bilgiyi tekrar döndürebilirsiniz. Dizin daha önce <command>opendir</command> ile açılmış olduğundan bu arada silinmiş ya da eklenmiş dosyalar varsa onları farketmenizi de sağlar. Yani son <command>opendir</command> veya <command>rewinddir</command> çağrısından sonra yapılan <command>readdir</command> çağrılarıyla eklenmiş dosyalar varsa bunlarla ilgili bilgiler dönerken silinmiş dosyalarla ilgili bilgi dönmeyecekir.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-telldir">
<indexterm scope="glibc-fn"><primary>telldir</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>long int <command>telldir</command></funcdef>
<paramdef>(DIR *<varname>dizinakımı</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>telldir</command> işlevi <varname>dizinakımı</varname> ile belirtilen dizin akımının dosya konumunu döndürür. Dizin akımının dosya konumunu tekrar bu noktaya getirmek için <command>seekdir</command> işlevini bu değerle kullanabilirsiniz.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-seekdir">
<indexterm scope="glibc-fn"><primary>seekdir</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>void <command>seekdir</command></funcdef>
<paramdef>(DIR     *<varname>dizinakımı</varname>,
 long int <varname>konum</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>seekdir</command> işlevi <varname>dizinakımı</varname> ile belirtilen dizin akımının dosya konumunu <varname>konum</varname> konumuna ayarlar. <varname>konum</varname> değeri bu akım için daha önceki bir <command>telldir</command> çağrısından dönen değer olmalıdır. Ancak arada akım kapatılıp yeniden açılmışsa bu değer geçersiz olmuş olabilir.
  </para></funcdescr></funcsynopsis></para></sect1>
  <sect1 xml:id="glibc-Scanning-Directory-Content">
    <title>Dizin İçeriğinin Taranması</title>
    <titleabbrev>Br dizinin kullanıcı tarafından seçilmiş bir parçasının girdilerinin alınması.</titleabbrev>
    <para>
Dizinlerle çalışan işlevlerin daha yüksek seviyedeki bir arayüzü de  <command>scandir</command> işlevidir. Onun yardımıyla, bir dizin içindeki girdilerin bir kısmı seçilebilir, sıralanabilir ve bir isim listesi alınabilir.
    </para><para xml:id="glibc-scandir">
<indexterm scope="glibc-fn"><primary>scandir</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>scandir</command></funcdef>
<paramdef>(const char      *<varname>dizin</varname>,
 struct dirent ***<varname>isimlistesi</varname>,
 int            (*<varname>seçici</varname>) (const struct dirent *),
 int            (*<varname>sıralayıcı</varname>) (const void *, const void *))</paramdef>
</funcprototype><funcdescr><para>
<command>scandir</command> işlevi <varname>dizin</varname> ile belirtilen dizinin içeriğini tarar. Sonucu döndüren <varname>*isimlistesi</varname> seçilen dizin girdilerini içeren <command>struct dirent</command> türündeki göstericilerin dizisidir ve <command>malloc</command> kullanılarak ayrılır. Dizindeki tüm girdilerin değilde sadece seçilen girdilerin döndürülmesi için işlev kullanıcı tarafından sağlanan <varname>seçici</varname> işlevi çağırır. Sadece <varname>seçici</varname> işlevin sıfırdan farklı bir değer döndürdüğü girdiler seçilir.
    </para><para>
Son olarak, <varname>*isimlistesi</varname> içindeki girdiler kullanıcı tarafından sağlanan <varname>sıralayıcı</varname> işlevi çağrılarak sıraya sokulur. <varname>sıralayıcı</varname> işlevine aktarılan argümanlar <command>struct dirent **</command> türündedir, bu bakımdan <command>strcmp</command> veya <command>strcoll</command> işlevleri doğrudan kullanılamaz. Kullanılabilecek işlevler için aşağıya <command>alphasort</command> ve <command>versionsort</command> işlevlerine bakınız.
    </para><para>
İşlevin normal dönüş değeri <varname>*isimlistesi</varname>'ne yerleştirilen girdilerin sayısıdır. <command>-1</command> dönmüşse bir hata saptanmış demektir (ya dizin okumak için açılamamıştır ya da malloc başarısız olmuştur). Bu durumda <command>errno</command> değişkenine hata durumu atanır.
</para></funcdescr></funcsynopsis></para><para>
Yukarıda açıklanan <command>scandir</command> işlevinin dördüncü argümanı bir sıralama işlevine bir göstericidir. Yazılımcıya kolaylık olarak GNU C kütüphanesi bu amaca uygun olarak gerçeklenmiş işlevler içerir.
    </para><para xml:id="glibc-alphasort">
<indexterm scope="glibc-fn"><primary>alphasort</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>alphasort</command></funcdef>
<paramdef>(const void *<varname>a</varname>,
 const void *<varname>b</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>alphasort</command> işlevi <command>strcoll</command> işlevi gibi davranır (bkz. <xref linkend="glibc-String-Array-Comparison"/>).  Aradaki fark, argümanların dizge göstericisi değil <command>struct dirent **</command> türünde olmasıdır.
    </para><para>
<command>alphasort</command> işlevinin dönüş değeri <varname>a</varname> ve <varname>b</varname> girdilerinin karşılaştırılmasına bağlı olarak sıfırdan küçük bir değer, sıfır ya da sıfırdan büyük bir değer olur.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-versionsort">
<indexterm scope="glibc-fn"><primary>versionsort</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>versionsort</command></funcdef>
<paramdef>(const void *<varname>a</varname>,
 const void *<varname>b</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>versionsort</command> işlevi dahili olarak <command>strverscmp</command> işlevini kullanması dışında <command>alphasort</command> işlevi gibidir.
</para></funcdescr></funcsynopsis></para><para>
Eğer dosya sistemi büyük dosyaları destekliyorsa, <command>dirent</command> yapısının tüm bilgiyi içermesi mümkün olmadığından <command>scandir</command> işlevi kullanılamaz. LFS sistemi için yeni bir tür, <command>struct dirent64</command>, bunu kullanmak için de yeni bir işlev vardır.
    </para><para xml:id="glibc-scandir64">
<indexterm scope="glibc-fn"><primary>scandir64</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>scandir64</command></funcdef>
<paramdef>(const char        *<varname>dizin</varname>,
 struct dirent64 ***<varname>isimlistesi</varname>,
 int              (*<varname>seçici</varname>) (const struct dirent64 *),
 int              (*<varname>sıralayıcı</varname>) (const void *, const void *))</paramdef>
</funcprototype><funcdescr><para>
<command>scandir64</command> işlevi dizin girdilerini <command>struct dirent64</command> türünde döndürmesi dışında <command>scandir</command> işlevi gibidir. <varname>seçici</varname> ile gösterilen işlev yine, istenen girdileri seçmek için kullanılır, ama işlev bu sefer <command>struct dirent64 *</command> türünde bir parametre alır.
    </para><para>
Benzer şekilde, <varname>sıralayıcı</varname> işlevi de <command>struct dirent64 **</command> türünde iki parametre alır.
</para></funcdescr></funcsynopsis></para><para>
<varname>sıralayıcı</varname> bu sefer farklı türde argümanlar aldığından ve <command>alphasort</command> ve <command>versionsort</command> işlevleri bu türde argüman almadıklarından burada kullanılamazlar. Bu bakımdan iki işlev daha tanımlanmıştır.
    </para><para xml:id="glibc-alphasort64">
<indexterm scope="glibc-fn"><primary>alphasort64</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>alphasort64</command></funcdef>
<paramdef>(const void *<varname>a</varname>,
 const void *<varname>b</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>alphasort64</command> işlevi <command>strcoll</command> işlevi gibi davranır (bkz. <xref linkend="glibc-String-Array-Comparison"/>).  Aradaki fark, argümanların dizge göstericisi değil <command>struct dirent64 **</command> türünde olmasıdır.
    </para><para>
<command>alphasort64</command> işlevinin dönüş değeri <varname>a</varname> ve <varname>b</varname> girdilerinin karşılaştırılmasına bağlı olarak sıfırdan küçük bir değer, sıfır ya da sıfırdan büyük bir değer olur.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-versionsort64">
<indexterm scope="glibc-fn"><primary>versionsort64</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>versionsort64</command></funcdef>
<paramdef>(const void *<varname>a</varname>,
 const void *<varname>b</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>versionsort64</command> işlevi dahili olarak <command>strverscmp</command> işlevini kullanması dışında <command>alphasort64</command> işlevi gibidir.
</para></funcdescr></funcsynopsis></para><para>
<command>scandir</command> kullanırken 64 bitlik karşılaştıma işlevlerini kullanmamak (ya da tam tersi) önemlidir. Bunun çalıştığı sistemler varsa da diğerleri ümitsizce başarısız olacaktır.
    </para></sect1>
  <sect1 xml:id="glibc-Simple-Directory-Lister-Mark-II">
    <title>Bir Dizinin İçeriğini Listeleyen İkinci Örnek</title>
    <titleabbrev>Önceki örneğin daha gelişmiş bir sürümü.</titleabbrev>
    <para>
Burada, <xref linkend="glibc-Simple-Directory-Lister"/> bölümündeki küçük yazılımın biraz daha gelişirilmiş bir sürümü vardır. Dizin içeriğini sıralamak için uğraşmaktansa <command>scandir</command> kullanmayı tercih ettik. Çağrı döndükten sonra girdiler hemen kullanıma hazır hale gelir.
    </para><para>
<screen>#include &lt;stdio.h>
#include &lt;dirent.h>

static int
one (const struct dirent *unused)
{
  return 1;
}

int
main (void)
{
  struct dirent **eps;
  int n;

  n = scandir (&quot;./&quot;, &amp;eps, one, alphasort);
  if (n >= 0)
    {
      int cnt;
      for (cnt = 0; cnt &lt; n; ++cnt)
        puts (eps[cnt]->d_name);
    }
  else
    perror (&quot;Dizin açılamadı&quot;);

  return 0;
}
</screen></para><para>
Bu örnekteki seçici işlevin basitliğine dikkat edin. Dizindeki tüm girdileri listelemek istediğimizden hep <command>1</command> döndürdük.
    </para></sect1></chapter>
  <chapter xml:id="glibc-Working-with-Directory-Trees">
    <title>Dizin Ağaçlarıyla Çalışma</title>
    <titleabbrev>Eylemleri tüm dosyalara ya da seçilen bir alt dizin kümesine uygulanması.</titleabbrev>
    <para>
<indexterm scope="glibc-cp"><primary>dizinler</primary><secondary>hiyerarşik</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>dizinler</primary><secondary>dizin ağacı</secondary></indexterm>
Buraya kadar açıklanan işlevler ya bilgiyi bit bit aldılar ya da tüm dosyaları grup halinde işleme soktular (bkz. <link linkend="glibc-scandir"><command>scandir</command></link>). Kimi zaman alt dizinler ve içerdikleri dosyalarla çalışmak gerekir. X/Open belirtimi bunu yapmak için iki işlev tanımlamıştır. Daha basit hali System V sistemlerindeki ilk tanımından türetilmiştir ve bu bakımdan bu işlev SVID'den türetilmiş sistemlerde bulunur. Prototipler ve gerekli tanımlar <filename>ftw.h</filename> başlık dosyasında bulunabilir.
   </para><para>
Bu ailenin dört işlevi vardır: <command>ftw</command>, <command>nftw</command> ile  64 bitlik olanları <command>ftw64</command> ve <command>nftw64</command>.  Bu işlevlerin argümanlarından biri uygun türde bir eylemci işleve göstericidir.
   </para><para xml:id="glibc__ftw_func_t">
<indexterm scope="glibc-tp"><primary sortas="ftw_func_t">__ftw_func_t</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü">
<funcdef><command>__ftw_func_t</command></funcdef>
<paramdef>
int (*) (const char *, const struct stat *, int)</paramdef>
</funcprototype><funcdescr><para>
<command>ftw</command> işlevine belirtilen eylemci işlevin türüdür. İlk parametre dosya ismine bir gösterici, ikinci parametre ise ilk parametrede ismi belirtilen dosya için doldurulan <command>struct stat</command> türünde bir nesnedir.
   </para><para>
Son parametre o anki dosya hakkında daha fazla bilgi veren bir değerdir. Son parametre şu değerleri içerebilir:
   </para><para><variablelist><varlistentry>
   <term><literal>FTW_F</literal></term><listitem><para>
Öğe ya normal bir dosya ya da diğer kategorilerle eşleşmeyen (özel dosyalar, soketler gibi) bir dosyadır.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>FTW_D</literal></term><listitem><para>
Öğe bir dizindir.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>FTW_NS</literal></term><listitem><para>
<command>stat</command> çağrısı başarısız olduğundan ikinci parametrenin gösterdiği bilgi geçersizdir.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>FTW_DNR</literal></term><listitem><para>
Öğe okunamayan bir dizindir.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>FTW_SL</literal></term><listitem><para>
Öğe bir sembolik bağdır. Sembolik bağlar normalde izlendiğinden, bu değerin bir <command>ftw</command> eylemci işlevinde görünmesi sembolik bağın hedefindeki dosyanın mevcut olmadığı anlamına gelir. <command>nftw</command> işlevinde durum daha farklıdır.
      </para><para>
Bu değer sadece, ilk başlık dosyasından önce <command>_BSD_SOURCE</command> veya <command>_XOPEN_EXTENDED</command> tanımlanarak derlenmiş bir yazılımda kullanılabilir. Özgün SVID sistemlerinde sembolik bağlar yoktur.
      </para></listitem></varlistentry></variablelist>
    </para><para>
Eğer kaynaklar <command>_FILE_OFFSET_BITS == 64</command> ile derlenmişse, bu tür aslında <command>__ftw64_func_t</command> türü olur. Aynı sebeple <command>struct stat</command> da <command>struct stat64</command> olur.
</para></funcdescr></funcsynopsis></para><para>
LFS arayüzü ve <command>ftw64</command> işlevinde kullanmak üzere <command>__ftw64_func_t</command> türü <filename>ftw.h</filename> dosyasında tanımlanmştır.
   </para><para xml:id="glibc__ftw64_func_t">
<indexterm scope="glibc-tp"><primary sortas="ftw64_func_t">__ftw64_func_t</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü">
<funcdef><command>__ftw64_func_t</command></funcdef>
<paramdef>
int (*) (const char *, const struct stat64 *, int)</paramdef>
</funcprototype><funcdescr><para>
Bu tür <command>ftw64</command> işlevine belirtilen eylemci işlevin türü olmak dışında <command>__ftw_func_t</command> türünün benzeridir.  Eylemci işlevin ikinci parametresi daha geniş değerleri mümkün kılmak için <command>struct stat64</command> türünde bir değişkene göstericidir.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc__nftw_func_t">
<indexterm scope="glibc-tp"><primary sortas="nftw_func_t">__nftw_func_t</primary></indexterm>
<indexterm scope="glibc-vr"><primary>FTW_DP</primary></indexterm>
<indexterm scope="glibc-vr"><primary>FTW_SLN</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü">
<funcdef><command>__nftw_func_t</command></funcdef>
<paramdef>
int (*) (const char *, const struct stat *, int, struct FTW *)</paramdef>
</funcprototype><funcdescr><para>
İlk üç parametresi <command>__ftw_func_t</command> türü ile aynıdır.  Ancak üçüncü argüman için daha hassas bir farklılaşmayı sağlamak için bazı ek değerler içerebilir:
   </para><para><variablelist><varlistentry>
   <term><literal>FTW_DP</literal></term><listitem><para>
Öğe bir dizindir ve tüm alt dizinlerine girilmiş ve raporlanmıştır. Eğer <command>nftw</command> işlevi <command>FTW_DEPTH</command> seçeneği ile çağrılmışsa <command>FTW_D</command> yerine bu değer döner (aşağıya bakınız).
      </para></listitem></varlistentry><varlistentry>
      <term><literal>FTW_SLN</literal></term><listitem><para>
Öğe geçerliğini yitirmiş bir sembolik bağ. Yani gösterdiği dosya ortada yok.
      </para></listitem></varlistentry></variablelist>
    </para><para>
Eylemci işlevin son parametresi aldığı ek değerler aşağıda açıklanan bir yapıya göstericidir.
   </para><para>
Eğer kaynaklar <command>_FILE_OFFSET_BITS == 64</command> ile derlenmişse, bu tür aslında <command>__nftw64_func_t</command> türü olur. Aynı sebeple <command>struct stat</command> da <command>struct stat64</command> olur.
</para></funcdescr></funcsynopsis></para><para>
LFS arayüzü ve <command>ftw64</command> işlevinde kullanmak üzere <command>__nftw64_func_t</command> türü <filename>ftw.h</filename> dosyasında tanımlanmştır.
   </para><para xml:id="glibc__nftw64_func_t">
<indexterm scope="glibc-tp"><primary sortas="nftw64_func_t">__nftw64_func_t</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü">
<funcdef><command>__nftw64_func_t</command></funcdef>
<paramdef>
int (*) (const char *, const struct stat64 *, int, struct FTW *)</paramdef>
</funcprototype><funcdescr><para>
Bu tür <command>nftw64</command> işlevine belirtilen eylemci işlevin türü olmak dışında <command>__nftw_func_t</command> türünün benzeridir.  Eylemci işlevin ikinci parametresi daha geniş değerleri mümkün kılmak için <command>struct stat64</command> türünde bir değişkene göstericidir.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-struct-FTW">
<indexterm scope="glibc-tp"><primary>struct FTW</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü">
<funcdef>struct <command>FTW</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu yapının içerdiği bilgi isim parametresinin yorumlanmasına ve dizin hiyerarşisinin zikzaklı durumu hakkında bazı bilgiler verilmesine yardımcı olur.
   </para><para><glosslist><glossentry><glossterm>
   <literal>int <command>base</command></literal>
   </glossterm><glossdef><para>
Değeri eylemci işlevin ilk parametresinde aktarılan dizgedeki dosya isminin dizgenin başlangıcına göre başlangıç konumudur. Dizgenin başlangıcında kalan bölüm dosyanın dosya yoludur. Çalışma dizini o an bulunan öğelerden biri olduğundan, <command>nftw</command> çağrısı <command>FTW_CHDIR</command> seçeneği ile yapıldığında bu bilgi önem kazanır.
   </para></glossdef></glossentry><glossentry><glossterm>
   <literal>int <command>level</command></literal>
   </glossterm><glossdef><para>
İşlem sırasında, dosyayı bulmak için kaç dizin içeri gidileceğini gösterir. İlk dizinin seviyesi 0'dır.
   </para></glossdef></glossentry></glosslist>
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-ftw">
<indexterm scope="glibc-fn"><primary>ftw</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>ftw</command></funcdef>
<paramdef>(const char  *<varname>dosyaismi</varname>,
 __ftw_func_t <varname>eylemci-işlev</varname>,
 int          <varname>tanıtıcı-sayısı</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev, <varname>dosyaismi</varname> ile belirtilen dizin ve alt dizinlerinde bulunan her öğe için <varname>eylemci-işlev</varname> parametresi ile belirtilen işlevi çağırır. İşlev gerekirse sembolik bağları da izler ama öğeyi iki defa işleme sokmaz. Eğer <varname>dosyaismi</varname> ile bir dizin belirtilmemişse eylemci işlev sadece bu öğe için çağrılır.
   </para><para>
Eylemci işleve aktarılan dosya ismi <varname>dosyaismi</varname> parametresinden alınarak ve aktarılan tüm dizin isimleri ve yerel dosya ismi eklenerek oluşturulur. Böylece eylemci işlev dosyaya erişmek için bu parametreyi kullanabilir.  <command>ftw</command> ayrıca dosya için <command>stat</command> çağrısı da yapar ve bu bilgiyi eylemci işleve aktarır. Eğer bu <command>stat</command> çağrısı başarısız olursa bu durum eylemci işlevin üçüncü argümanına <command>FTW_NS</command> aktarılarak belirtilir. Aksi takdirde, üçüncü argümana yukarıda <command>__ftw_func_t</command> açıklamasında belirtildiği gibi aktarım yapılır.
   </para><para>
Bir hata oluşmadığını ve işlemin devam edebileceğini belirtmek üzere eylemci işlevin 0 döndürmesi beklenir. Eğer bir hata oluşmuşsa ya da <command>ftw</command> işlevinin işlemi hemen sonlandırması isteniyorsa sıfırdan farklı bir değer döndürülmelidir. Bu işlevi sonlandırmanın tek yoludur. Eylemci işlevin içinde işleme başka bir yerde devam etmek için <command>setjmp</command> veya benzeri bir işlev kullanılmamalıdır. Bu, <command>ftw</command> işlevinin ayırdığı özkaynakların ayrılmış olarak kalmasına sebep olur.
   </para><para>
<varname>tanıtıcı-sayısı</varname> parametresi ile <command>ftw</command> işlevinin toplam kaç dosya tanıtıcısı kullanacağı belirtilir. Ne kadar çok dosya tanıtıcısı kullanmasına izin veririrse işlev o kadar hızlı çalışır. Dizin hiyerarşisindeki her alt dizin için en fazla bir dosya tanıtıcısı kullanılır, fakat çok derinlere inildiğinde açık dosya tanıtıcılarının sayısı süreç ya da sistem için belirlenmiş sınırları aşabilir. Dahası, çok evreli yazılımlarda bu katlanarak artar. Bu bakımdan açık dosya tanıtıcılarının sayısına kabul edilebilir bir sınır belirtmek gerekir.
   </para><para>
Eğer tüm eylemci işlev çağrıları 0 ile dönmüşse ve <command>ftw</command> tüm eylemleri uygulayabilmişse, <command>ftw</command> 0 ile döner. Eğer bir işlev çağrısı başarısız olmuşsa (<command>stat</command> çağrıları hariç) -1 ile döner. Eğer eylemci işlev çağrılarından biri sıfırdan farklı bir değerle dönmüşse <command>ftw</command> işlevi bu dönüş değerini döndürür.
   </para><para>
Kaynakların 32 bitlik bir sistemde <command>_FILE_OFFSET_BITS == 64</command> ile derlendiği durumda bu işlev aslında <command>ftw64</command> işlevidir, yani LFS arayüzü eski arayüzün yerine geçer.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-ftw64">
<indexterm scope="glibc-fn"><primary>ftw64</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>ftw64</command></funcdef>
<paramdef>(const char    *<varname>dosyaismi</varname>,
 __ftw64_func_t <varname>eylemci-işlev</varname>,
 int            <varname>tanıtıcı-sayısı</varname>)</paramdef>
</funcprototype><funcdescr><para>
Büyük dosyalı dosya sistemleri ile çalışması dışında bu işlev <command>ftw</command> işlevinin benzeridir. Eylemci işleve dosya bilgisi aktarılırken <command>struct stat64</command> türünde bir değişken kullanılır.
   </para><para>
32 bitlik bir sistemde, kaynakların <command>_FILE_OFFSET_BITS == 64</command> ile derlendiği durumda bu işlev <command>ftw</command> ismiyle bulunur ve eski gerçekleme tamamen LFS'ye uygun olarak değiştirilir.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-nftw">
<indexterm scope="glibc-fn"><primary>nftw</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>nftw</command></funcdef>
<paramdef>(const char   *<varname>dosyaismi</varname>,
 __nftw_func_t <varname>eylemci-işlev</varname>,
 int           <varname>tanıtıcı-sayısı</varname>,
 int           <varname>seçenek</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>nftw</command> işlevi <command>ftw</command> işlevi gibi çalışır. <varname>dosyaismi</varname> ile belirtilen dizin ve alt dizinlerinde ve aşağıda açıklandığı gibi bulunan her öğe için <varname>eylemci-işlev</varname> parametresi ile belirtilen işlevi çağırır. <varname>tanıtıcı-sayısı</varname> parametresi ile <command>nftw</command> işlevinin toplam kaç dosya tanıtıcısı kullanacağı belirtilir.
   </para><para>
Birinci fark eylemci işlevin türüdür. Yukarıda açıklandığı gibi <command>struct FTW *</command> türündeki eylemci işleve ek bilgi aktarılabilir.
   </para><para>
İkinci fark, <command>nftw</command> işlevinin dördüncü bir argüman almasıdır. Bu argümana 0 veya aşağıdaki değerlerin bit seviyesinde VEYAlanmış değeri aktarılabilir:
   </para><para><variablelist><varlistentry>
   <term><literal>FTW_PHYS</literal></term><listitem><para>
Dizin taranırken sembolik bağlar izlenmez. Bunun yerine sembolik bağlar eylemci işlevin tür parametresinde <command>FTW_SL</command> değeri kullanılarak belirtilir. Eğer sembolik bağın hedefindeki dosya mevcut değilse, bunun yerine <command>FTW_SLN</command> döner.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>FTW_MOUNT</literal></term><listitem><para>
Eylemci işlevden <varname>dosyaismi</varname> ile belirtilen dizinin bulunduğu dosya sistemine bağlı diğer dosya sistemlerindeki alt dizinlerle ilgili bilgi istenmez.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>FTW_CHDIR</literal></term><listitem><para>
Bu seçenek verilmişse eylemci işlev çağrılmadan önce çalışma dizininden raporlanan dizine geçilir. <command>ntfw</command> işlevi eylemci işlev döndükten sonra tekrar eski çalışma dizinine geçer.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>FTW_DEPTH</literal></term><listitem><para>
Bu seçenek verilmişse ana dizin içeriği işlenmeden önce alt dizinler ve onların dosyaları üzerinde işlem yapılır (önce derinlik kipi). Bu durum ayrıca eylemci işleve <command>FTW_D</command> değil <command>FTW_DP</command> değeri aktarılarak belirtilir.
     </para></listitem></varlistentry><varlistentry>
     <term><literal>FTW_ACTIONRETVAL</literal></term>
     <listitem><para>
Bu seçenek belirtilmişse eylemci işlevin dönüş değeri farklı işlem görür. Eğer eylemci işlev <command>FTW_CONTINUE</command> ile dönerse işlem normal olarak devam eder. <command>FTW_STOP</command> işlemi durdur ve işlev bu değerle döner. Eğer <command>FTW_D</command> argümanı ile çağrılmış eylemci işlev <command>FTW_SKIP_SUBTREE</command> değeri ile dönerse, alt ağaç atlanır ve sonraki kardeş dizinden devam edilir;  <command>FTW_SKIP_SIBLINGS</command> değeri dönerse, o anki girdinin tüm kardeş dizinleri atlanır ve işlem bir üst dizinden devam eder. Bu seçeneğin belirtildiği durumda eylemci işlev bu değerlerin dışında bir değer döndürmemelidir. Bu seçenek bir GNU oluşumudur.
      </para></listitem></varlistentry></variablelist>
    </para><para>
İşlevin dönüş değeri <command>ftw</command> işlevindeki gibi değerlendirilir. Eğer tüm eylemci işlev çağrıları <command>0</command> ile dönmüşse ve <command>nftw</command> tüm eylemleri uygulayabilmişse, <command>nftw</command> işlevi <command>0</command> ile döner. Bellek sorunu gibi bir dahili bir hata oluşmuşsa işlev <command>-1</command> ile döner ve hata durumu <varname>errno</varname> değişkenine atanır. Eğer eylemci işlev çağrılarından biri sıfırdan farklı bir değerle dönmüşse <command>nftw</command> işlevi bu dönüş değerini döndürür.
   </para><para>
Kaynakların 32 bitlik bir sistemde <command>_FILE_OFFSET_BITS == 64</command> ile derlendiği durumda bu işlev aslında <command>nftw64</command> işlevidir, yani LFS arayüzü eski arayüzün yerine geçer.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-nftw64">
<indexterm scope="glibc-fn"><primary>nftw64</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>nftw64</command></funcdef>
<paramdef>(const char     *<varname>dosyaismi</varname>,
 __nftw64_func_t <varname>eylemci-işlev</varname>,
 int             <varname>tanıtıcı-sayısı</varname>,
 int             <varname>seçenek</varname>)</paramdef>
</funcprototype><funcdescr><para>
Büyük dosyalı dosya sistemleri ile çalışması dışında bu işlev <command>nftw</command> işlevinin benzeridir. Eylemci işleve dosya bilgisi aktarılırken <command>struct stat64</command> türünde bir değişken kullanılır.
   </para><para>
32 bitlik bir sistemde, kaynakların <command>_FILE_OFFSET_BITS == 64</command> ile derlendiği durumda bu işlev <command>nftw</command> ismiyle bulunur ve eski gerçekleme tamamen LFS'ye uygun olarak değiştirilir.
  </para></funcdescr></funcsynopsis></para></chapter>
  <chapter xml:id="glibc-Hard-Links">
    <title>Sabit Bağlar</title>
    <titleabbrev>Bir dosyaya başka bir isim daha verilmesi.</titleabbrev>
    <para>
<indexterm scope="glibc-cp"><primary>dosyalar</primary><secondary>sabit bağlar</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>dosyalar</primary><secondary>çok isimli</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>dizinler</primary><secondary>sabit bağlar</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>bağlar</primary><secondary>sabit</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>sabit bağlar</primary></indexterm>
POSIX sistemlerinde bir dosyanın aynı anda çok sayıda ismi olabilir. İsimlerin her biri aynı değerdedir ve biri diğerine tercih edilmez.
   </para><para>
Bir dosyaya isim eklemek için <command>link</command> işlevi kullanılır.  (Bu yeni isme ayrıca dosyaya <wordasword>sabit bağ</wordasword> da denir.)  Bir dosyaya yeni bir isim atanması dosya içeriğinin kopyalanmasına sebep olmaz; sadece dosyanın isimlerine yeni bir isim eklenmiş olur.
   </para><para>
Bir dosya çeşitli dizinlerde isimlere sahip olabilir, böyle bir dosya sisteminin düzeni kesin bir hiyerarşi ya da ağaç olmaz.
   </para><para>
Çoğu gerçeklemelerde, aynı dosyanın farklı dosya sistemlerinde sabit bağlarının olmasına izin verilmez. <command>link</command> işlevini böyle bir işlem yapmak için kullanmaya çalışırsanız, diğer dosya sistemi için bu işlemin yapılamayacağını belirten bir hata raporu alırsınız.
   </para><para>
<command>link</command> işlevinin prototipi <filename>unistd.h</filename> başlık dosysında bildirilmiştir.
<indexterm scope="glibc-pg"><primary>unistd.h</primary></indexterm>
   </para><para xml:id="glibc-link">
<indexterm scope="glibc-fn"><primary>link</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>link</command></funcdef>
<paramdef>(const char *<varname>eski-isim</varname>,
 const char *<varname>yeni-isim</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>link</command> işlevi <varname>eski-isim</varname> isimli dosyaya <varname>yeni-isim</varname> isimli bir sabit bağ yapar.
   </para><para>
İşlev başarılı olduğunda <command>0</command>, aksi takdirde <command>-1</command> ile döner. <link linkend="glibc-File-Name-Errors">Dosya ismi hatalarına</link> ek olarak aşağıdaki <command>errno</command> hata durumları bu işlev için tanımlanmıştır:
   </para><para><variablelist><varlistentry>
   <term><literal>EACCES</literal></term><listitem><para>
Yeni bağın yazılacağı dizine yazma izni verilmedi.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>EEXIST</literal></term><listitem><para>
<varname>yeni-isim</varname> isminde bir dosya zaten var.  Bu ismi yeni bağ ismi olarak kullanmak istiyorsanız önce mevcut ismi değiştirmelisiniz.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>EMLINK</literal></term><listitem><para>
<varname>eski-isim</varname> isimli dosya için zaten çok fazla ek isim var. (Bir dosyaya verilecek bağ sayısı <command>LINK_MAX</command> ile sınırlıdır; bkz. <xref linkend="glibc-Limits-for-Files"/>.)
      </para></listitem></varlistentry><varlistentry>
      <term><literal>ENOENT</literal></term><listitem><para>
<varname>eski-isim</varname> isminde bir dosya yok.  Olmayan bir dosyaya bağ oluşturamazsınız.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>ENOSPC</literal></term><listitem><para>
Yeni bağı içerecek dizin ya da dosya sisteminde yer yok ve genişletilemiyor.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>EPERM</literal></term><listitem><para>
GNU sisteminde ve bazı sistemlerde dizinlere sabit bağ yapamazsınız. Bir çok sistem bu izni sadece ayrıcalıklı kullanıcılara verir. Bu hata sorunu raporlamakta kullanılır.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>EROFS</literal></term><listitem><para>
Yeni bağı içerecek dizine dosya sistemi salt-okunur bağlı olduğundan yazılamıyor.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>EXDEV</literal></term><listitem><para>
<varname>yeni-isim</varname> ile belirtilen dizin mevcut dosyadan farklı bir dosya sisteminde.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>EIO</literal></term><listitem><para>
Diske okuma ya da yazma denemesi sırasında bir donanım hatası oluştu.
      </para></listitem></varlistentry></variablelist>
  </para></funcdescr></funcsynopsis></para></chapter>
  <chapter xml:id="glibc-Symbolic-Links">
    <title>Sembolik Bağlar</title>
    <titleabbrev>Bir dosya ismini gösteren dosyalar.</titleabbrev>
    <para>
<indexterm scope="glibc-cp"><primary>dosyalar</primary><secondary>sembolik bağlar</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>dizinler</primary><secondary>sembolik bağlar</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>bağlar</primary><secondary>sembolik</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>sembolik bağlar</primary></indexterm>
GNU sistemi <wordasword>sembolik bağlar</wordasword>ı destekler. Bu aslında bir dosya ismine gösterici olan bir dosya çeşididir. Sabit bağların tersine, dizinlere ve diğer sosya sistemlerindeki dosyalara ve dizinlere sembolik bağlar yapılabilir. Ayrıca, olmayan bir dosyaya da bir sembolik bağ yapılabilir.  Tersine sembolik bağın hedefindeki dosyanın silinmesi sembolik bağı sadece geçersiz hale getirir. Hedef dosya oluşturulana kadar bağ dosyası başarısız olarak kalır.
   </para><para>
Sembolik bağların tercih edilmesinin bir başka sebebi de bağı açmaya çalıştığınızda bazı özel şeylerin yapılmasıdır. <command>open</command> işlevine dosya ismi olarak bir sembolik bağ ismi vererek bir bağı açmaya çalışırsanız, bağın içerdiği dosya ismini okur ve onun yerine bu dosyayı açar. <command>stat</command> işlevi ise tersine sembolik bağın kendisi ile değil, gösterdiği dosya ile çalışır.
   </para><para>
Ayrıca, dosya silme ve isim değiştirme gibi bazı işlemler bağın kendisi üzerinde yapılır. <command>readlink</command> ve <command>lstat</command> işlevleri ayrıca sembolik bağları izlemekten kaçınır, çünkü onların amacı bağ hakkında bilgi sağlamaktır. Sabit bağ yapan <command>link</command> işlevi sembolik bağlara da sabit bağ yapar.
   </para><para>
Bazı sistemlerde, dosyalarla çalışan bazı işlevlerin bir dosya yolu çözümlenirken kaç tane sembolik bağın izleneceğine ilişkin bir sınırlama vardır. Bu sınır sistemde eğer varsa <filename>sys/param.h</filename> başlık dosyasında tanımlıdır.
   </para><para xml:id="glibc-MAXSYMLINKS">
<indexterm scope="glibc-vr"><primary>MAXSYMLINKS</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>int <command>MAXSYMLINKS</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
<command>MAXSYMLINKS</command> makrosu bazı işlevlerin <command>ELOOP</command> değerini döndürmeden kaç tane sembolik bağ izleyebileceğini belirtir. Tüm işlevler böyle davranmaz ve bu değer <command>sysconf</command> işlevinin <command>_SC_SYMLOOP</command> için döndürdüğü değerle aynı değildir. Aslında, <command>sysconf</command> böyle bir sınır olmadığını belirten bir değer döndürür.
</para></funcdescr></funcsynopsis></para><para>
Bu bölümdeki işlevlerin çoğu  <filename>unistd.h</filename> başlık dosyasında bildirilmiştir.
<indexterm scope="glibc-pg"><primary>unistd.h</primary></indexterm>
   </para><para xml:id="glibc-symlink">
<indexterm scope="glibc-fn"><primary>symlink</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>symlink</command></funcdef>
<paramdef>(const char *<varname>eski-isim</varname>,
 const char *<varname>yeni-isim</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>symlink</command> işlevi <varname>eski-isim</varname> isimli dosyaya <varname>yeni-isim</varname> isimli bir sembolik bağ yapar.
   </para><para>
İşlev başarılı olduğunda <command>0</command>, aksi takdirde <command>-1</command> ile döner. <link linkend="glibc-File-Name-Errors">Dosya ismi hatalarına</link> ek olarak aşağıdaki <command>errno</command> hata durumları bu işlev için tanımlanmıştır:
   </para><para><variablelist><varlistentry>
   <term><literal>EEXIST</literal></term><listitem><para>
<varname>yeni-isim</varname> isminde bir dosya zaten var.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>EROFS</literal></term><listitem><para>
Yeni bağı içerecek dizine dosya sistemi salt-okunur bağlı olduğundan yazılamıyor.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>ENOSPC</literal></term><listitem><para>
Yeni bağı içerecek dizin ya da dosya sisteminde yer yok ve genişletilemiyor.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>EIO</literal></term><listitem><para>
Diske okuma ya da yazma denemesi sırasında bir donanım hatası oluştu.
      </para></listitem></varlistentry></variablelist>
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-readlink">
<indexterm scope="glibc-fn"><primary>readlink</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>readlink</command></funcdef>
<paramdef>(const char *<varname>dosyaismi</varname>,
 char       *<varname>tampon</varname>,
 size_t      <varname>boyut</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>readlink</command> işlevi sembolik bağın ismini <varname>dosyaismi</varname> ile alır ve sembolik bağın hedefindeki dosyanın ismini <varname>*tampon</varname>'a yerleştirir.  Dosya ismi dizgesi boş karakter sonlandırmalı <emphasis>değildir</emphasis>; işlev <varname>tampon</varname> ile gösterilen dizgeye yerleştirilen karakterlerin sayısı ile döner, dolayısıyla <varname>boyut</varname> argümanı en azından bu değerde olmalıdır.
   </para><para>
Eğer işlev <varname>boyut</varname> değerine eşit bir değerle dönmüşse, dosya ismi için yeterli yerin olup olmadığı hakkında bir fikir vermez. Bu durumda tamponu büyütüp tekrar denemelisiniz. Bir örnek:
   </para><para>
<screen>char *
readlink_malloc (const char *filename)
{
  int size = 100;
  char *buffer = NULL;

  while (1)
    {
      buffer = (char *) xrealloc (buffer, size);
      int nchars = readlink (filename, buffer, size);
      if (nchars &lt; 0)
        {
          free (buffer);
          return NULL;
        }
      if (nchars &lt; size)
        return buffer;
      size *= 2;
    }
}
</screen></para><para>
İşlevin dönüş değeri <command>-1</command> ise bir hata oluşmuş demektir.<link linkend="glibc-File-Name-Errors">Dosya ismi hatalarına</link> ek olarak aşağıdaki <command>errno</command> hata durumları bu işlev için tanımlanmıştır:
   </para><para><variablelist><varlistentry>
   <term><literal>EINVAL</literal></term><listitem><para>
İsmi belirtilen dosya bir sembolik bağ değil.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>EIO</literal></term><listitem><para>
Diske okuma ya da yazma denemesi sırasında bir donanım hatası oluştu.
      </para></listitem></varlistentry></variablelist>
</para></funcdescr></funcsynopsis></para><para>
Bazı durumlarda sembolik bağların hedefindeki gerçek dosya isminin başka hiçbir sembolik bağ, önek ve dosya yolunda <command>.</command> veya <command>..</command> olmaksızın çözümlenmesi istenebilir. Bu isteğe bir örnek, aynı dosya düğümüne erişen farklı dosya isimlerinin karşılaştırılmasıdır.
   </para><para xml:id="glibc-canonicalize_file_name">
<indexterm scope="glibc-fn"><primary>canonicalize_file_name</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>char *<command>canonicalize_file_name</command></funcdef>
<paramdef>(const char *<varname>isim</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>canonicalize_file_name</command> işlevi <varname>isim</varname> ile belirtilen dosya isminin  ne <command>.</command>, <command>..</command> elemanları ne herhangi bir dosya yolu ayracı (<command>/</command>) ne de sembolik bağ içeren mutlak ismini döndürür. İşlev dönüş değerini <command>malloc</command> ile ayrılmış bellek bloğunda döndürür. Eğer dönen sonuç artık kullanılmayacaksa <command>free</command> çağrısı ile serbest bırakılmalıdır.
   </para><para>
Bir dosya yolu elemanı yoksa işlev bir boş gösterici ile döner. Bu ayrıca, dosya yolunun uzunluğu <command>PATH_MAX</command> karakteri aşarsa da döndürülür. Her durumda <command>errno</command> değişkenine hata durumu atanır.
   </para><para><variablelist><varlistentry>
   <term><literal>ENAMETOOLONG</literal></term><listitem><para>
Sonuçlanan dosya yolu çok uzun. Bu hata dosya isimlerinde uzunluk sınırı olan dosya sistemlerinde oluşur.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>EACCES</literal></term><listitem><para>
Dosya yolunu oluşturan elemanlardan en az biri okunamıyor.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>ENOENT</literal></term><listitem><para>
Girdi dosya ismi boş.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>ENOENT</literal></term><listitem><para>
Dosya yolunu oluşturan elemanlardan en az biri mevcut değil.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>ELOOP</literal></term><listitem><para>
<command>MAXSYMLINKS</command>'den fazla sembolik bağ izlendi.
      </para></listitem></varlistentry></variablelist>
    </para><para>
Bu işlev bir GNU oluşumudur ve <filename>stdlib.h</filename> başlık dosyasında bildirilmiştir.
</para></funcdescr></funcsynopsis></para><para>
Unix standardı <command>canonicalize_file_name</command> işlevinin bir benzeri olarak sonucun yerleştirileceği tamponu kullanıcının belirteceği bir işlev tanımlamıştır.
   </para><para xml:id="glibc-realpath">
<indexterm scope="glibc-fn"><primary>realpath</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>char *<command>realpath</command></funcdef>
<paramdef>(const char *restrict <varname>isim</varname>,
 char *restrict       <varname>sonuç</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>realpath</command> işlevi <varname>sonuç</varname> parametresinde boş gösterici belirtildiğinde tamamen <command>canonicalize_file_name</command> gibi davranır.  İşlev bir tampon ayırır ve ona bir gösterici ile döner. Eğer <varname>sonuç</varname> <command>NULL</command> değilse, sonuç onun gösterdiği tampona kopyalanır. Çağrıcıya yanıtı yeterince büyük bir tampon ayırmaktır. <command>PATH_MAX</command>'ın tanımlı olduğu sistemlerde tampon bu uzunlukta olmalıdır. Dosya yolu uzunluğu için bir sınırlama bulunmayan sistemlerde uzunluk tahmin edilemeyeceğinden <command>realpath</command> işlevi ikinci parameresinde <command>NULL</command> dışında bir değer belirterek çağrılmamalıdır.
   </para><para>
Bir diğer fark da, işlev <command>NULL</command> ile döndüğünde <varname>sonuç</varname> tamponunun (sıfırdan farklıysa) mevcut olmayan ya da okunamayan dosya yolu parçaları içereceğidir. Bu durumda <command>errno</command> değişkenine <command>EACCES</command> ya da <command>ENOENT</command> atanır.
   </para><para>
Bu işlev <filename>stdlib.h</filename> dosyasında bildirilmiştir.
</para></funcdescr></funcsynopsis></para><para>
Bu işlevi kullanmanın bir faydası da geniş çapta kullanım alanı olmasıdır. Sakıncası ise uzun dosya isimleri için sınırlama olmayan sistemlerde uzun dosya yolu başarısızlıkları raporlamasıdır.
   </para></chapter>
  <chapter xml:id="glibc-Deleting-Files">
    <title>Dosyaların Silinmesi</title>
    <titleabbrev>Bir dosya nasıl silinir ve bu ne anlama gelir?</titleabbrev>
    <para>
<indexterm scope="glibc-cp"><primary>dosyalar</primary><secondary>silinmesi</secondary></indexterm>
Bir dosyayı <command>unlink</command> veya <command>remove</command> ile silebilirsiniz.
   </para><para>
Silme işleminde aslında sadece dosyanın ismi silinir. Eğer dosya sadece isimden ibaretse dosyanın kendisi de silinmiş olur. Eğer dosyanın başka isimleri de varsa onlar bu isimler altında hala erişilebilir olur (bkz. <xref linkend="glibc-Hard-Links"/>).
   </para><para xml:id="glibc-unlink">
<indexterm scope="glibc-fn"><primary>unlink</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>unlink</command></funcdef>
<paramdef>(const char *<varname>dosyaismi</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>unlink</command> işlevi <varname>dosyaismi</varname> ile belirtilen dosya ismini siler.  Eğer dosya sadece isimden ibaretse dosyanın kendisi de silinir. (Aslında, eğer herhangi bir süreç dosyayı açmışsa silme işlemi süreçler dosyayı kapatıncaya kadar ertelenir.)
   </para><para>
<indexterm scope="glibc-pg"><primary>unistd.h</primary></indexterm>
<command>unlink</command> işlevi <filename>unistd.h</filename> başlık dosyasında bildirilmiştir.
   </para><para>
İşlev başarılı olduğunda <command>0</command>, aksi takdirde <command>-1</command> ile döner. <link linkend="glibc-File-Name-Errors">Dosya ismi hatalarına</link> ek olarak aşağıdaki <command>errno</command> hata durumları bu işlev için tanımlanmıştır:
   </para><para><variablelist><varlistentry>
   <term><literal>EACCES</literal></term><listitem><para>
Silinecek dosyanın bulunduğu dizinde yazma izniniz yok ya da dizinde yapışkan bit var ve dosya size ait değil.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>EBUSY</literal></term><listitem><para>
Bu hata dosyanın sistem tarafından kullanıldığından silinemeyeceğini belirtir. Örneğin, dosya ismi kök dizini ya da bir dosya sisteminin bağlı olduğu dizini belirtiyorsa bu hata oluşur.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>ENOENT</literal></term><listitem><para>
Silinmek istenen dosya mevcut değil.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>EPERM</literal></term><listitem><para>
Bazı sistemlerde <command>unlink</command> bir dizini silmek için kullanılamaz ya da en azından sadece ayrıcalıklı kullanıcı bunu yapabilir. Böyle sorunlarla karşılaşmamak için dizinleri silerken <command>rmdir</command> kullanın. (GNU sisteminde <command>unlink</command> kesinlikle bir dizin ismini silemez.)
      </para></listitem></varlistentry><varlistentry>
      <term><literal>EROFS</literal></term><listitem><para>
Silinecek dosya bir salt-okunur bağlı dosya sisteminde ve bu değiştirilemez.
      </para></listitem></varlistentry></variablelist>
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-rmdir">
<indexterm scope="glibc-fn"><primary>rmdir</primary></indexterm>
<indexterm scope="glibc-cp"><primary>dizinler</primary><secondary>silinmesi</secondary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>rmdir</command></funcdef>
<paramdef>(const char *<varname>dosyaismi</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>rmdir</command> işlevi bir dizini siler. Silinecek dizin boş olmalıdır; başka bir deyişle, sadece <command>.</command> ve <command>..</command> girdilerini içermelidir.
   </para><para>
Birçok bakımdan, <command>rmdir</command> işlevi <command>unlink</command> gibi davranır.  Bu işlev için iki hata durumu daha tanımlanmıştır:
   </para><para><variablelist><varlistentry>
   <term><literal>ENOTEMPTY</literal></term>
   </varlistentry><varlistentry>
   <term><literal>EEXIST</literal></term><listitem><para>
Silinecek dizin boş değil.
    </para></listitem></varlistentry></variablelist>
   </para><para>
Bu iki hata kodu bir diğerinin eşanlamlısıdır, bazı sistemlerde biri, bazılarında öbürü kullanılır. GNU sisteminde daima <command>ENOTEMPTY</command> kullanılır.
   </para><para>
<command>rmdir</command> işlevi <filename>unistd.h</filename> başlık dosyasında bildirilmiştir.
<indexterm scope="glibc-pg"><primary>unistd.h</primary></indexterm>
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-remove">
<indexterm scope="glibc-fn"><primary>remove</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>remove</command></funcdef>
<paramdef>(const char *<varname>dosyaismi</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu bir dosyayı silmek için kullanılan bir ISO C işlevidir. Dosyalarla  <command>unlink</command> gibi, dizinlerle <command>rmdir</command> gibi çalışır. <command>remove</command> işlevi <filename>stdio.h</filename> başlık dosyasında bildirilmiştir.
<indexterm scope="glibc-pg"><primary>stdio.h</primary></indexterm>
</para></funcdescr></funcsynopsis></para></chapter>
  <chapter xml:id="glibc-Renaming-Files">
    <title>Dosya İsimlerinin Değiştirilmesi</title>
    <titleabbrev><command>rename</command> işlevi.</titleabbrev>
    <para>
Bir dosyanın ismini değiştirmek için <command>rename</command> işlevi kullanılır.
   </para><para xml:id="glibc-rename">
<indexterm scope="glibc-cp"><primary>dosyalar</primary><secondary>isim değişikliği</secondary></indexterm>
<indexterm scope="glibc-fn"><primary>rename</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>rename</command></funcdef>
<paramdef>(const char *<varname>eski-isim</varname>,
 const char *<varname>yeni-isim</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>rename</command> işlevi ismi <varname>eski-isim</varname> ile belirtilen dosyanın ismini <varname>yeni-isim</varname> yapar. Evvelce <varname>eski-isim</varname> ile erişilen dosyaya artık <varname>yeni-isim</varname> ile erişilebilecektir.  (Eğer dosyanın başka isimleri de varsa, onlar hala geçerli olacaktır.)
   </para><para>
<varname>yeni-isim</varname> ile belirtilen dosya, <varname>eski-isim</varname> ile belirtilen dosya ile aynı dosya sisteminde olmalıdır.
   </para><para>
<command>rename</command> için özel bir durum, <varname>eski-isim</varname> ve <varname>yeni-isim</varname>  ile belirtilen isimlerin aynı dosyanın iki ismi olmasıdır (çok isimli dosya). Bu durumda yapılacak tek şey  <varname>eski-isim</varname> ile belirtilen dosya ismini silmektir.  Ancak, POSIX bu durumda işlevin hiçbir şey yapmamasını ve başarı raporlamasını gerektirir. Sizin sisteminizin nasıl davranacağını bilemeyiz.
   </para><para>
<varname>eski-isim</varname> bir dizin değilse ve <varname>yeni-isim</varname> diye bir dosya mevcutsa isim değiştirme işlemi sırasında bu dosya silinir. Bu bakımdan, <varname>yeni-isim</varname> ile bir dizin belirtilmişse, bu durumda <command>rename</command> başarısız olur.
   </para><para>
<varname>eski-isim</varname> bir dizinse, <varname>yeni-isim</varname>  mevcut olmamalı ya da boş bir dizin ismi olmalıdır.  İkinci durumda <varname>yeni-isim</varname> isimli dizin önce silinecektir.   <varname>yeni-isim</varname> ile ismi değiştirlecek <varname>eski-isim</varname> isimli dizinin bir alt dizini belirtilmemelidir.
   </para><para>
<command>rename</command> işlevinin kullanışlı bir özelliği, eski isim yeni isim ile değiştirilirken, dosyaya önce yeni ismin eklenmesi, sonra eski ismin silinmesi şeklinde değiştirme işleminin atomik yapılmasıdır. Yani, eğer işlem sırasında bir sistem çökmesi yaşanırsa, her iki ismin hala mevcut olması olasıdır.
   </para><para>
İşlevin dönüş değeri <command>-1</command> ise bir hata oluşmuş demektir. <link linkend="glibc-File-Name-Errors">Dosya ismi hatalarına</link> ek olarak aşağıdaki <command>errno</command> hata durumları bu işlev için tanımlanmıştır:
   </para><para><variablelist><varlistentry>
   <term><literal>EACCES</literal></term><listitem><para>
Dizinlerden biri <varname>yeni-isim</varname>'i içeriyor ya da <varname>eski-isim</varname> yazmaya izin vermiyor; veya <varname>yeni-isim</varname> ve <varname>eski-isim</varname> birer dizin ve onlardan birine yazma izniniz yok.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>EBUSY</literal></term><listitem><para>
<varname>eski-isim</varname> veya <varname>yeni-isim</varname> ile belirtilen dizinlerden biri sistem tarafından kullanılıyor ve sistem bunları isim değişikliğine karşı engelliyor. Bu hata bir dosya sisteminin bağlı olduğu dizin için ve onun dizinleri süreçlerin çalışma dizinlerini içeriyorsa oluşur.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>ENOTEMPTY</literal></term>
      </varlistentry><varlistentry>
      <term><literal>EEXIST</literal></term><listitem><para>
<varname>yeni-isim</varname> isimli dizin boş değil. GNU sistemi bu hata için daima <command>ENOTEMPTY</command> döndürür, diğer sistemler  <command>EEXIST</command> döndürebilir. </para></listitem></varlistentry><varlistentry>
      <term><literal>EINVAL</literal></term><listitem><para>
<varname>eski-isim</varname>,  <varname>yeni-isim</varname> isimli dizini içeriyor.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>EISDIR</literal></term><listitem><para>
<varname>yeni-isim</varname> bir dizin ama <varname>eski-isim</varname> değil.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>EMLINK</literal></term><listitem><para>
<varname>yeni-isim</varname>'in üst dizini çok fazla bağ (girdi) içerecekti.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>ENOENT</literal></term><listitem><para>
<varname>eski-isim</varname> isimli bir dosya yok.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>ENOSPC</literal></term><listitem><para>
<varname>yeni-isim</varname>'i içerecek dizinde ve dosya sisteminde yer yok.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>EROFS</literal></term><listitem><para>
İşlem salt-okunur bağlı bir dosya sisteminde yapılmaya çalışılıyor.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>EXDEV</literal></term><listitem><para>
<varname>yeni-isim</varname> ve <varname>eski-isim</varname> farklı dosya sistemleri üzerinde.
      </para></listitem></varlistentry></variablelist>
    </para></funcdescr></funcsynopsis></para></chapter>

<chapter xml:id="glibc-Creating-Directories">
  <title>Dizinlerin Oluşturulması</title>
  <titleabbrev>Sadece dizin oluşturan bir sistem çağrısı.</titleabbrev>
  <para><indexterm scope="glibc-cp"><primary>dizinler</primary><secondary>oluşturulması</secondary></indexterm>
<indexterm scope="glibc-pg"><primary>mkdir</primary></indexterm>
Dizinler <command>mkdir</command> işlevi ile oluşturulur.  (Ayrıca, aynı şeyi yapan <command>mkdir</command> adında bir kabuk komutu vardır.)
   </para><para xml:id="glibc-mkdir">
<indexterm scope="glibc-fn"><primary>mkdir</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>mkdir</command></funcdef>
<paramdef>(const char *<varname>dosyaismi</varname>,
 mode_t      <varname>kip</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>mkdir</command> işlevi <varname>dosyaismi</varname> isimli bir yeni ve boş bir dizin oluşturur.
   </para><para>
<varname>kip</varname> argümanı ile yeni dizin dosyasının izinleri belirtilir. Bunun hakkında daha fazla bilgi için <xref linkend="glibc-Permission-Bits"/> bölümüne bakınız.
   </para><para>
<command>0</command> dönüş değeri işlevin başarılı olduğunu, <command>-1</command> ise bir hata oluştuğunu gösterir. <link linkend="glibc-File-Name-Errors">Dosya ismi hatalarına</link> ek olarak aşağıdaki <command>errno</command> hata durumları bu işlev için tanımlanmıştır:
   </para><para><variablelist><varlistentry>
   <term><literal>EACCES</literal></term><listitem><para>
Yeni dizinin ekleneceği dizin için yazma izniniz yok.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>EEXIST</literal></term><listitem><para>
<varname>dosyaismi</varname> isminde bir dosya zaten var.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>EMLINK</literal></term><listitem><para>
Yeni dizinin ekleneceği dizin çok fazla girdi içeriyor.
      </para><para>
İyi tasarlanmış dosya sistemleri bu hatayı asla döndürmez, çünkü onlar diskinizin tutabileceğinden çok daha fazla girdiye izin verirler. Ancak yine de bu hatayı alabileceğinizi hesaba katmalısınız, çünkü sonuç ağ üzerinden erişilen başka bir makineden gelebilir.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>ENOSPC</literal></term><listitem><para>
Yeni dizini oluşturmak için dosya sisteminde yer yok.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>EROFS</literal></term><listitem><para>
Yeni dizinin ekleneceği dizin bir salt-okunur bağlı dosya sisteminde ve bu değiştirilemez.
      </para></listitem></varlistentry></variablelist>
    </para><para>
Bu işlevi kullanmak için yazılımınıza <filename>sys/stat.h</filename> başlık dosyasını dahil etmelisiniz.
<indexterm scope="glibc-pg"><primary>sys/stat.h</primary></indexterm>
</para></funcdescr></funcsynopsis></para></chapter>

<chapter xml:id="glibc-File-Attributes">
  <title>Dosya Öznitelikleri</title>
  <titleabbrev>Tek tek dosyaların öznitelikleri.</titleabbrev>
  <para>
<indexterm scope="glibc-pg"><primary>ls</primary></indexterm>
Bir dosya üzerinde <command>ls -l</command> kabuk komutunu verirseniz, komut size dosyanın uzunluğu, kime ait olduğu, son değişklik tarihi, vs. hakkında bilgi verir. Bunlara <wordasword>dosya öznitelikleri</wordasword> denir ve dosyanın ismiyle değil dosyanın kendisiyle ilgilidirler.
   </para><para>
Bu kısım bir dosyanın özniteliklerinin değiştirilmesi ve sorgulanması hakkında bilgi içerir.
   </para>
  <sect1 xml:id="glibc-Attribute-Meanings">
    <title>Dosya Özniteliklerinin Anlamları</title>
    <titleabbrev>Dosya özniteliklerinin isimleri ve ne anlama geldikleri.</titleabbrev>
    <para>
<indexterm scope="glibc-cp"><primary>dosyalar</primary><secondary>öznitelikleri</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>dosyalar</primary><secondary>durumları</secondary></indexterm>
Bir dosyanın özniteliklerini okuduğunuzda, onlar <command>struct stat</command> denilen bir yapıda gelirler. Bu bölümde özniteliklerin isimleri, veri türleri ve anlamları açıklanacaktır. Bir dosyanın özniteliklerini okuyan işlevleri <xref linkend="glibc-Reading-Attributes"/> bölümünde bulabilirsiniz.
    </para><para>
Bu bölümdeki bütün semboller <filename>sys/stat.h</filename> başlık dosyasında bildirilmiştir.
<indexterm scope="glibc-pg"><primary>sys/stat.h</primary></indexterm>
    </para><para xml:id="glibc-struct-stat">
<indexterm scope="glibc-tp"><primary sortas="stat">struct stat</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü">
<funcdef>struct <command>stat</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
<command>stat</command> yapısı bir dosyanın öznitelikleri hakkında bilgi döndürmekte kullanılır. En azından şu üyeleri içerir:
    </para><para><glosslist><glossentry><glossterm>
    <literal>mode_t <command>st_mode</command></literal>
    </glossterm><glossdef><para>
Dosya kipini belirtir. Bu <link linkend="glibc-Testing-File-Type">dosya türü bilgisi</link> ile <link linkend="glibc-Permission-Bits">dosya izinlerinin bitlerini</link> içerir.
    </para></glossdef></glossentry><glossentry><glossterm>
    <literal>ino_t <command>st_ino</command></literal>
    </glossterm><glossdef><para>
Dosyanın seri numarası. Bu dosyayı aynı aygıttaki diğer dosyalardan ayırır.
    </para></glossdef></glossentry><glossentry><glossterm>
    <literal>dev_t <command>st_dev</command></literal>
    </glossterm><glossdef><para>
Dosyayı içeren aygıt. <command>st_ino</command> ve <command>st_dev</command> birlikte alındığında dosyayı eşsiz olarak kimliklendirir.
    </para></glossdef></glossentry><glossentry><glossterm>
    <literal>nlink_t <command>st_nlink</command></literal>
    </glossterm><glossdef><para>
Dosyaya sabit bağların sayısı. Bu sayı bu dosya için kaç dizinin girdi içerdiğini gösterir. Sayı hep azalıyorsa, dosyayı açık tutan süreç kalmadığı anda dosya kendisini iptal eder.  If the count is ever decremented to zero, then the file itself is discarded as soon as no process still holds it open.  Sembolik bağlar toplama dahil değildir.
    </para></glossdef></glossentry><glossentry><glossterm>
    <literal>uid_t <command>st_uid</command></literal>
    </glossterm><glossdef><para>
Dosyanın ait olduğu kullanıcının kullanıcı kimliği. Bkz. <xref linkend="glibc-File-Owner"/>.
    </para></glossdef></glossentry><glossentry><glossterm>
    <literal>gid_t <command>st_gid</command></literal>
    </glossterm><glossdef><para>
Dosyanın ait olduğu grubun grup kimliği. Bkz. <xref linkend="glibc-File-Owner"/>.
    </para></glossdef></glossentry><glossentry><glossterm>
    <literal>off_t <command>st_size</command></literal>
    </glossterm><glossdef><para>
Normal bir dosya için bayt cinsinden dosya uzunluğu. Aygıt dosyaları için bu alandaki değer anlamlı değildir. Sembolik bağlarda hedef dosya isminin uzunluğudur.
    </para></glossdef></glossentry><glossentry><glossterm>
    <literal>time_t <command>st_atime</command></literal>
    </glossterm><glossdef><para>
Dosyaya son erişim zamanı. Bkz.  <xref linkend="glibc-File-Times"/>.
    </para></glossdef></glossentry><glossentry><glossterm>
    <literal>unsigned long int <command>st_atime_usec</command></literal>
    </glossterm><glossdef><para>
Dosyaya son erişim zamanının ondalık kısmı. Bkz. <xref linkend="glibc-File-Times"/>.
    </para></glossdef></glossentry><glossentry><glossterm>
    <literal>time_t <command>st_mtime</command></literal>
    </glossterm><glossdef><para>
Dosya içeriğinin son değişiklik zamanı. Bkz. <xref linkend="glibc-File-Times"/>.
    </para></glossdef></glossentry><glossentry><glossterm>
    <literal>unsigned long int <command>st_mtime_usec</command></literal>
    </glossterm><glossdef><para>
Dosya içeriğinin son değişiklik zamanının ondalık kısmı. Bkz.  <xref linkend="glibc-File-Times"/>.
    </para></glossdef></glossentry><glossentry><glossterm>
    <literal>time_t <command>st_ctime</command></literal>
    </glossterm><glossdef><para>
Dosya özniteliklerinin son değişiklik zamanı. Bkz. <xref linkend="glibc-File-Times"/>.
    </para></glossdef></glossentry><glossentry><glossterm>
    <literal>unsigned long int <command>st_ctime_usec</command></literal>
    </glossterm><glossdef><para>
Dosya özniteliklerinin son değişiklik zamanının ondalık kısmı. Bkz. <xref linkend="glibc-File-Times"/>.
    </para></glossdef></glossentry><glossentry><glossterm>
    <literal>blkcnt_t <command>st_blocks</command></literal>
    </glossterm><glossdef><para>
Dosyanın diskte kapladığı alanın 512 baytlık bloklar cinsinden miktarı.
       </para><para>
Disk bloklarının sayısı dosya boyutu ile birebir orantılı değildir, bunun iki sebebi vardır: Dosya sistemi bazı blokları dahili kayıtlarını tutmak için kullanabilir; dosya seyrek olabilir--dosya sıfırlarla doldurulmuş "delikler" içerebilir ama bunlar aslında diskte yer kaplamaz.
       </para><para>
Bir dosyanın seyrek olup olmadığı bu değeri <command>st_size</command> ile karşılaştırarak yaklaşık olarak söylemek mümkündür:
       </para><para>
<screen>(st.st_blocks * 512 &lt; st.st_size)</screen>
       </para><para>
Bu sınama mükemmel değildir çünkü gerçekten seyrek olan bir dosyanın seyrek olduğu bu yöntemle saptanamayabilir. Ama pratik uygulamalar için bu bir sorun değildir.
    </para></glossdef></glossentry><glossentry><glossterm>
    <literal>unsigned int <command>st_blksize</command></literal>
    </glossterm><glossdef><para>
Dosyayı okumak ya da dosyaya yazmak için bayt cinsinden en uygun blok boyu. Bu değeri dosya ile yapacağınız okuma ve yazma işlemleri için ne kadar tampon ayıracağınızı belirlemek için kullanabilirsiniz. (Bu değerin <command>st_blocks</command> ile ilgisi yoktur.)
       </para></glossdef></glossentry></glosslist>
</para></funcdescr></funcsynopsis></para><para>
Dosya boyutlarının  2^63 bayta ulaştığı büyük dosya destekli (LFS) sistemler için bu yapının genişletilmesi gerekir.
    </para><para xml:id="glibc-struct-stat64">
<indexterm scope="glibc-tp"><primary sortas="stat64">struct stat64</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü">
<funcdef>struct <command>stat64</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu yapının üyeleri de üye isimleri de <command>struct stat</command> ile aynıdır. Tek fark <command>st_ino</command>, <command>st_size</command> ve <command>st_blocks</command> üyelerinin daha büyük değerleri tutabilmesi için faklı türde olmasıdır.
    </para><para><glosslist><glossentry><glossterm>
    <literal>mode_t <command>st_mode</command></literal>
    </glossterm><glossdef><para>
Dosya kipini belirtir. Bu <link linkend="glibc-Testing-File-Type">dosya türü bilgisi</link> ile <link linkend="glibc-Permission-Bits">dosya izinlerinin bitlerini</link> içerir.
    </para></glossdef></glossentry><glossentry><glossterm>
    <literal>ino64_t <command>st_ino</command></literal>
    </glossterm><glossdef><para>
Dosyanın seri numarası. Bu dosyayı aynı aygıttaki diğer dosyalardan ayırır.
    </para></glossdef></glossentry><glossentry><glossterm>
    <literal>dev_t <command>st_dev</command></literal>
    </glossterm><glossdef><para>
Dosyayı içeren aygıt. <command>st_ino</command> ve <command>st_dev</command> birlikte alındığında dosyayı eşsiz olarak kimliklendirir.
    </para></glossdef></glossentry><glossentry><glossterm>
    <literal>nlink_t <command>st_nlink</command></literal>
    </glossterm><glossdef><para>
Dosyaya sabit bağların sayısı. Bu sayı bu dosya için kaç dizinin girdi içerdiğini gösterir. Sayı hep azalıyorsa, dosyayı açık tutan süreç kalmadığı anda dosya kendisini iptal eder.  If the count is ever decremented to zero, then the file itself is discarded as soon as no process still holds it open.  Sembolik bağlar toplama dahil değildir.
    </para></glossdef></glossentry><glossentry><glossterm>
    <literal>uid_t <command>st_uid</command></literal>
    </glossterm><glossdef><para>
Dosyanın ait olduğu kullanıcının kullanıcı kimliği. Bkz. <xref linkend="glibc-File-Owner"/>.
    </para></glossdef></glossentry><glossentry><glossterm>
    <literal>gid_t <command>st_gid</command></literal>
    </glossterm><glossdef><para>
Dosyanın ait olduğu grubun grup kimliği. Bkz. <xref linkend="glibc-File-Owner"/>.
    </para></glossdef></glossentry><glossentry><glossterm>
    <literal>off64_t <command>st_size</command></literal>
    </glossterm><glossdef><para>
Normal bir dosya için bayt cinsinden dosya uzunluğu. Aygıt dosyaları için bu alandaki değer anlamlı değildir. Sembolik bağlarda hedef dosya isminin uzunluğudur.
    </para></glossdef></glossentry><glossentry><glossterm>
    <literal>time_t <command>st_atime</command></literal>
    </glossterm><glossdef><para>
Dosyaya son erişim zamanı. Bkz. <xref linkend="glibc-File-Times"/>.
    </para></glossdef></glossentry><glossentry><glossterm>
    <literal>unsigned long int <command>st_atime_usec</command></literal>
    </glossterm><glossdef><para>
Dosyaya son erişim zamanının ondalık kısmı. Bkz. <xref linkend="glibc-File-Times"/>.
    </para></glossdef></glossentry><glossentry><glossterm>
    <literal>time_t <command>st_mtime</command></literal>
    </glossterm><glossdef><para>
Dosya içeriğinin son değişiklik zamanı. Bkz. <xref linkend="glibc-File-Times"/>.
    </para></glossdef></glossentry><glossentry><glossterm>
    <literal>unsigned long int <command>st_mtime_usec</command></literal>
    </glossterm><glossdef><para>
Dosya içeriğinin son değişiklik zamanının ondalık kısmı. Bkz. <xref linkend="glibc-File-Times"/>.
    </para></glossdef></glossentry><glossentry><glossterm>
    <literal>time_t <command>st_ctime</command></literal>
    </glossterm><glossdef><para>
Dosya özniteliklerinin son değişiklik zamanı. Bkz. <xref linkend="glibc-File-Times"/>.
    </para></glossdef></glossentry><glossentry><glossterm>
    <literal>unsigned long int <command>st_ctime_usec</command></literal>
    </glossterm><glossdef><para>
Dosya özniteliklerinin son değişiklik zamanının ondalık kısmı. Bkz. <xref linkend="glibc-File-Times"/>.
    </para></glossdef></glossentry><glossentry><glossterm>
    <literal>blkcnt64_t <command>st_blocks</command></literal>
    </glossterm><glossdef><para>
Dosyanın diskte kapladığı alanın 512 baytlık bloklar cinsinden miktarı.
    </para></glossdef></glossentry><glossentry><glossterm>
    <literal>unsigned int <command>st_blksize</command></literal>
    </glossterm><glossdef><para>
Dosyayı okumak ya da dosyaya yazmak için bayt cinsinden en uygun blok boyu. Bu değeri dosya ile yapacağınız okuma ve yazma işlemleri için ne kadar tampon ayıracağınızı belirlemek için kullanabilirsiniz. (Bu değerin <command>st_blocks</command> ile ilgisi yoktur.)
     </para></glossdef></glossentry></glosslist>
</para></funcdescr></funcsynopsis></para><para>
Bazı dosya özniteliklerinin kendilerine özel veri türleri vardır. (Aslında hepsi bildiğiniz tamsayı veri türlerinin karşılığıdır.) Bu veri türleri  <filename>sys/types.h</filename> ve <filename>sys/stat.h</filename> başlık dosyalarında tanımlanmıştır. Aşağıda bunların bir listesini bulacaksınız.
    </para><para xml:id="glibc-mode_t">
<indexterm scope="glibc-tp"><primary>mode_t</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü">
<funcdef><command>mode_t</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Dosya kiplerini göstermekte kullanılan tamsayı veri türü. GNU sisteminde <command>unsigned int</command>'e eşdeğerdir.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-ino_t">
<indexterm scope="glibc-cp"><primary>inode number</primary></indexterm>
<indexterm scope="glibc-tp"><primary>ino_t</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü">
<funcdef><command>ino_t</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Dosya seri numarasını (Bunlara kimi zaman <wordasword>dosya indisi</wordasword> dendiği de olur) göstermekte kullanılan tamsayı veri türü. GNU sisteminde <command>unsigned long int</command>'e eşdeğerdir.
    </para><para>
Kaynakların <command>_FILE_OFFSET_BITS == 64</command> ile derlendiği sistemlerde bu tür <command>ino64_t</command> ile eşdeğerdir.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-ino64_t">
<indexterm scope="glibc-tp"><primary>ino64_t</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü">
<funcdef><command>ino64_t</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
LFS desteği olan sistemlerde dosya seri numarasını göstermekte kullanılan tamsayı veri türü. GNU sisteminde <command>unsigned long long int</command>'e eşdeğerdir.
    </para><para>
Kaynakların <command>_FILE_OFFSET_BITS == 64</command> ile derlendiği sistemlerde bu tür <command>ino_t</command> ismiyle bulunur.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-dev_t">
<indexterm scope="glibc-tp"><primary>dev_t</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü">
<funcdef><command>dev_t</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Dosyayı içeren aygıtı göstermekte kullanılan tamsayı veri türü. GNU sisteminde <command>int</command>'e eşdeğerdir.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-nlink_t">
<indexterm scope="glibc-tp"><primary>nlink_t</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü">
<funcdef><command>nlink_t</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Dosya bağlarının sayısını göstermekte kullanılan tamsayı veri türü. GNU sisteminde <command>unsigned short int</command>'e eşdeğerdir.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-blkcnt_t">
<indexterm scope="glibc-tp"><primary>blkcnt_t</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü">
<funcdef><command>blkcnt_t</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Blok sayısını göstermekte kullanılan tamsayı veri türü. GNU sisteminde <command>unsigned long int</command>'e eşdeğerdir.
    </para><para>
Kaynakların <command>_FILE_OFFSET_BITS == 64</command> ile derlendiği sistemlerde bu tür <command>blkcnt64_t</command> ile eşdeğerdir.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-blkcnt64_t">
<indexterm scope="glibc-tp"><primary>blkcnt64_t</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü">
<funcdef><command>blkcnt64_t</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
LFS desteği olan sistemlerde blok sayısını göstermekte kullanılan tamsayı veri türü. GNU sisteminde <command>unsigned long long int</command>'e eşdeğerdir.
    </para><para>
Kaynakların <command>_FILE_OFFSET_BITS == 64</command> ile derlendiği sistemlerde bu tür <command>blkcnt_t</command> ismiyle bulunur.
  </para></funcdescr></funcsynopsis></para></sect1>
  <sect1 xml:id="glibc-Reading-Attributes">
    <title>Bir Dosyanın Özniteliklerinin Okunması</title>
    <titleabbrev>Bir dosyanın öznitelikleri nasıl okunur?</titleabbrev>
    <para>
Bir dosyanın özniteliklerini öğrenmek için <command>stat</command>, <command>fstat</command> ve <command>lstat</command> işlevleri kullanılır. Öznitelikleri bir <command>struct stat</command> nesnesinde döndürürler.  Bu işlevler <command>sys/stat.h</command> başlık dosyasında bildirilmiştir.
    </para><para xml:id="glibc-stat">
<indexterm scope="glibc-fn"><primary>stat</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>stat</command></funcdef>
<paramdef>(const char  *<varname>dosyaismi</varname>,
 struct stat *<varname>tampon</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>stat</command> işlevi ismi <varname>dosyaismi</varname> ile belirtilen dosyanın özniteliklerini <varname>tampon</varname> ile gösterilen yapı içinde döndürür.
    </para><para>
<varname>dosyaismi</varname> bir sembolik bağın ismiyse, bağın hedefindeki dosyanın öznitelikleri döndürülür. Sembolik bağın hedefindeki dosya mevcut değilse işlev dosyanın mevcut olmadığını bildirerek başarısız olur.
    </para><para>
İşlem sorunsuz yerine getirilmişse <command>0</command>, aksi takdirde <command>-1</command> döner. <link linkend="glibc-File-Name-Errors">Dosya ismi hatalarına</link> ek olarak aşağıdaki <command>errno</command> hata durumu bu işlev için tanımlanmıştır:
    </para><para><variablelist><varlistentry>
    <term><literal>ENOENT</literal></term><listitem><para>
<varname>dosyaismi</varname> isminde bir dosya yok.
       </para></listitem></varlistentry></variablelist>
     </para><para>
Kaynakların <command>_FILE_OFFSET_BITS == 64</command> ile derlendiği sistemlerde bu işlev <command>stat64</command> ile aynıdır.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-stat64">
<indexterm scope="glibc-fn"><primary>stat64</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>stat64</command></funcdef>
<paramdef>(const char    *<varname>dosyaismi</varname>,
 struct stat64 *<varname>tampon</varname>)</paramdef>
</funcprototype><funcdescr><para>
2^31 bayttan daha büyük dosyalarla çalışmanın mümkün olduğu 32 bitlik sistemlerde bu işlev <command>stat</command> işlevine eşdeğerdir. Bunu mümkün kılmak için sonucu döndüren <varname>tampon</varname>, <command>struct stat64</command> türünde bir yapıya göstericidir.
    </para><para>
Kaynakların <command>_FILE_OFFSET_BITS == 64</command> ile derlendiği sistemlerde bu işlev <command>stat</command> ismiyle bulunur.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-fstat">
<indexterm scope="glibc-fn"><primary>fstat</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>fstat</command></funcdef>
<paramdef>(int          <varname>dosyatanıtıcı</varname>,
 struct stat *<varname>tampon</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>fstat</command> işlevi argüman olarak dosya ismi yerine bir <link linkend="glibc-Low-Level-I-O">açık dosya tanıtıcı</link> alması dışında <command>stat</command> işlevinin benzeridir.
    </para><para>
<command>stat</command> gibi, <command>fstat</command> işlevi de başarı durumunda <command>0</command> ve hata oluşmuşsa <command>-1</command> ile döner. Aşağıdaki <command>errno</command> hata durumları bu işlev için tanımlanmıştır:
    </para><para><variablelist><varlistentry>
    <term><literal>EBADF</literal></term><listitem><para>
<varname>dosyatanıtıcı</varname> argümanı geçerli bir dosya tanıtıcı değil.
       </para></listitem></varlistentry></variablelist>
     </para><para>
Kaynakların <command>_FILE_OFFSET_BITS == 64</command> ile derlendiği sistemlerde bu işlev <command>fstat64</command> ile aynıdır.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-fstat64">
<indexterm scope="glibc-fn"><primary>fstat64</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>fstat64</command></funcdef>
<paramdef>(int            <varname>dosyatanıtıcı</varname>,
 struct stat64 *<varname>tampon</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev <command>fstat</command> işlevine benzer fakat 32 bitlik platformlarda büyük dosyalarla çalışır.  Büyük dosyalarla çalışmak için <varname>dosyatanıtıcı</varname> dosya tanıtıcısı <command>open64</command> veya <command>creat64</command> ile sağlanmış olmalıdır.  <varname>tampon</varname> ile gösterilen değişken büyük değerleri tutabilen <command>struct stat64</command> türünde olmalıdır.
    </para><para>
Kaynakların <command>_FILE_OFFSET_BITS == 64</command> ile derlendiği sistemlerde bu işlev <command>fstat</command> ismiyle bulunur.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-lstat">
<indexterm scope="glibc-fn"><primary>lstat</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>lstat</command></funcdef>
<paramdef>(const char  *<varname>dosyaismi</varname>,
 struct stat *<varname>tampon</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>lstat</command> işlevi <command>stat</command> işlevi gibidir fakat <link linkend="glibc-Symbolic-Links">sembolik bağlara</link> izin vermez. Eğer <varname>dosyaismi</varname> bir sembolik bağ ismi ise, <command>lstat</command> bağın hedefi ile değil bağ dosyasının kendisi ile ilgili bilgi döndürür; bunun dışında <command>lstat</command> işlevi <command>stat</command> gibi çalışır.
    </para><para>
Kaynakların <command>_FILE_OFFSET_BITS == 64</command> ile derlendiği sistemlerde bu işlev <command>lstat64</command> ile aynıdır.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-lstat64">
<indexterm scope="glibc-fn"><primary>lstat64</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>lstat64</command></funcdef>
<paramdef>(const char    *<varname>dosyaismi</varname>,
 struct stat64 *<varname>tampon</varname>)</paramdef>
</funcprototype><funcdescr><para>
2^31 bayttan daha büyük dosyalarla çalışmanın mümkün olduğu 32 bitlik sistemlerde bu işlev <command>lstat</command> işlevine eşdeğerdir. Bunu mümkün kılmak için sonucu döndüren <varname>tampon</varname>, <command>struct stat64</command> türünde bir yapıya göstericidir.
    </para><para>
Kaynakların <command>_FILE_OFFSET_BITS == 64</command> ile derlendiği sistemlerde bu işlev <command>lstat</command> ismiyle bulunur.
  </para></funcdescr></funcsynopsis></para></sect1>
  <sect1 xml:id="glibc-Testing-File-Type">
    <title>Bir Dosyanın Türünün Sınanması</title>
    <titleabbrev>Normal dosyalar, dizinler, bağlar, vs. arasında ayrım yapmak.</titleabbrev>
    <para>
<wordasword>Dosya kipi</wordasword>, dosya özniteliklerinin  <command>st_mode</command> alanında saklanır ve iki çeşit bilgi içerebilir: dosya türü kodu ve erişim izin bitleri.  Bu bölümde sadece bir dosyanın dizin mi, soket mi, sembolik bağ mı her ne haltsa belirlenmesine yarayan tür kodları açıklanacaktır. Erişim izinleri <xref linkend="glibc-Permission-Bits"/> bölümünde açıklanmıştır.
    </para><para>
Dosya kipi içindeki dosya türü bilgisine erişmenin iki yolu vardır. İlkinde,  belirtilen dosya kipini okuyup dosya türünün kendinin ifade etttiği türde olup olmadığı hakkında bilgi veren <wordasword>isnat makroları</wordasword> vardır. İkinci yolla ise, dosya kipini bir mask ile süzüp sadece dosya türü kodunu bıraktıktan sonra bunu desteklenen dosya türü sabitleriyle karşılaştırarak dosya türü saptanır.
    </para><para>
Bu bölümdeki tüm semboller  <filename>sys/stat.h</filename> başlık dosyasında bildirilmiştir.
<indexterm scope="glibc-pg"><primary>sys/stat.h</primary></indexterm>
Aşağıdaki isnat makroları, bakılacak dosya için <command>stat</command> tarafından döndürülen <command>st_mode</command> alanındaki değer olan <varname>m</varname> değerine göre dosya türünü sınar:
    </para><para xml:id="glibc-S_ISDIR">
<indexterm scope="glibc-fn"><primary>S_ISDIR</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>int <command>S_ISDIR</command></funcdef>
<paramdef>(mode_t <varname>m</varname>)</paramdef>
</funcprototype><funcdescr><para>
Dosya bir dizin ise bu makro sıfırdan farklı bir değer döndürür.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-S_ISCHR">
<indexterm scope="glibc-fn"><primary>S_ISCHR</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>int <command>S_ISCHR</command></funcdef>
<paramdef>(mode_t <varname>m</varname>)</paramdef>
</funcprototype><funcdescr><para>
Dosya bir karakter aygıtı dosyası (örn, uçbirim aygıtı) ise bu makro sıfırdan farklı bir değer döndürür.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-S_ISBLK">
<indexterm scope="glibc-fn"><primary>S_ISBLK</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>int <command>S_ISBLK</command></funcdef>
<paramdef>(mode_t <varname>m</varname>)</paramdef>
</funcprototype><funcdescr><para>
Dosya bir blok aygıtı dosyası (örn, bir disk bölümü) ise bu makro sıfırdan farklı bir değer döndürür.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-S_ISREG">
<indexterm scope="glibc-fn"><primary>S_ISREG</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>int <command>S_ISREG</command></funcdef>
<paramdef>(mode_t <varname>m</varname>)</paramdef>
</funcprototype><funcdescr><para>
Dosya bir normal dosya ise bu makro sıfırdan farklı bir değer döndürür.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-S_ISFIFO">
<indexterm scope="glibc-fn"><primary>S_ISFIFO</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>int <command>S_ISFIFO</command></funcdef>
<paramdef>(mode_t <varname>m</varname>)</paramdef>
</funcprototype><funcdescr><para>
Dosya bir FIFO ya da boru ise bu makro sıfırdan farklı bir değer döndürür. Bkz.  <xref linkend="glibc-Pipes-and-FIFOs"/>.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-S_ISLNK">
<indexterm scope="glibc-fn"><primary>S_ISLNK</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>int <command>S_ISLNK</command></funcdef>
<paramdef>(mode_t <varname>m</varname>)</paramdef>
</funcprototype><funcdescr><para>
Dosya bir sembolik bağ ise bu makro sıfırdan farklı bir değer döndürür. Bkz. <xref linkend="glibc-Symbolic-Links"/>.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-S_ISSOCK">
<indexterm scope="glibc-fn"><primary>S_ISSOCK</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>int <command>S_ISSOCK</command></funcdef>
<paramdef>(mode_t <varname>m</varname>)</paramdef>
</funcprototype><funcdescr><para>
Dosya bir soket ise bu makro sıfırdan farklı bir değer döndürür. Bkz. <xref linkend="glibc-Sockets"/>.
</para></funcdescr></funcsynopsis></para><para>
BSD uyumluluğu için, desteklenen dosya türünü sınayan ve POSIX olmayan bir yöntem daha vardır. Dosya türü kodunu elde etmek için kip <command>S_IFMT</command> ile bit seviyesinde VE'lenir ve ilgili sabitle karşılaştırılır. Örneğin,
    </para><para>
<screen>S_ISCHR (<varname>kip</varname>)
</screen></para><para>ifadesi ile </para><para>
<screen>((<varname>kip</varname>  S_IFMT) == S_IFCHR)
</screen></para><para>ifadesi eşdeğerdir.
</para><para xml:id="glibc-S_IFMT">
<indexterm scope="glibc-vr"><primary>S_IFMT</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>int <command>S_IFMT</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bir kip değerinden dosya türünü çıkarmak için kullanılan bir bit maskesidir.
</para></funcdescr></funcsynopsis></para><para>
Dosya türü kodlarının sembolik isimleri:
    </para><para><variablelist><varlistentry>
    <term><literal>S_IFDIR</literal></term><listitem><para>
<indexterm scope="glibc-vr"><primary>S_IFDIR</primary></indexterm>
Bir dizin dosyasının dosya türü sabitidir.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>S_IFCHR</literal></term><listitem><para>
<indexterm scope="glibc-vr"><primary>S_IFCHR</primary></indexterm>
Bir karakter aygıtı dosyasının dosya türü sabitidir.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>S_IFBLK</literal></term><listitem><para>
<indexterm scope="glibc-vr"><primary>S_IFBLK</primary></indexterm>
Bir blok aygıtı dosyasının dosya türü sabitidir.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>S_IFREG</literal></term><listitem><para>
<indexterm scope="glibc-vr"><primary>S_IFREG</primary></indexterm>
Bir normal dosyanın dosya türü sabitidir.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>S_IFLNK</literal></term><listitem><para>
<indexterm scope="glibc-vr"><primary>S_IFLNK</primary></indexterm>
Bir sembolik bağın dosya türü sabitidir.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>S_IFSOCK</literal></term><listitem><para>
<indexterm scope="glibc-vr"><primary>S_IFSOCK</primary></indexterm>
Bir soketin dosya türü sabitidir.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>S_IFIFO</literal></term><listitem><para>
<indexterm scope="glibc-vr"><primary>S_IFIFO</primary></indexterm>
Bir FIFO veya borunun dosya türü sabitidir.
       </para></listitem></varlistentry></variablelist>
     </para><para>
POSIX.1b standardı, dosya sisteminde nesne olarak gerçeklenebilmesi olası bir kaç nesneden daha bahseder. Bunlar ileti kuyrukları, semaforlar ve paylaşımlı bellek nesneleridir. Bu nesnelerin diğer dosyalardan ayrımsanmasını mümkün kılmak için POSIX standardı üç yeni makrodan bahseder. Fakat diğer makroların aksine, parametre olarak <command>st_mode</command> alanının değerini almazlar. Bunun yerine <command>struct stat</command> yapısının tamamı için bir gösterici alırlar.
</para><para xml:id="glibc-S_TYPEISMQ">
<indexterm scope="glibc-fn"><primary>S_TYPEISMQ</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>int <command>S_TYPEISMQ</command></funcdef>
<paramdef>(struct stat *<varname>s</varname>)</paramdef>
</funcprototype><funcdescr><para>
Eğer sistem, POSIX ileti kuyruklarını ayrı nesneler olarak gerçekleştiriyorsa ve dosya bir ileti kuyruğu nesnesi ise, bu makro sıfırdan farklı bir değerle döner. Tüm diğer durumlarda sonuç sıfırdır.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-S_TYPEISSEM">
<indexterm scope="glibc-fn"><primary>S_TYPEISSEM</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>int <command>S_TYPEISSEM</command></funcdef>
<paramdef>(struct stat *<varname>s</varname>)</paramdef>
</funcprototype><funcdescr><para>
Eğer sistem, POSIX semaforlarını ayrı nesneler olarak gerçekleştiriyorsa ve dosya bir semafor nesnesi ise, bu makro sıfırdan farklı bir değerle döner. Tüm diğer durumlarda sonuç sıfırdır.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-S_TYPEISSHM">
<indexterm scope="glibc-fn"><primary>S_TYPEISSHM</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>int <command>S_TYPEISSHM</command></funcdef>
<paramdef>(struct stat *<varname>s</varname>)</paramdef>
</funcprototype><funcdescr><para>
Eğer sistem, POSIX paylaşımlı bellek nesnelerini ayrı nesneler olarak gerçekleştiriyorsa ve dosya bir paylaşımlı bellek nesnesi ise, bu makro sıfırdan farklı bir değerle döner. Tüm diğer durumlarda sonuç sıfırdır.
  </para></funcdescr></funcsynopsis></para></sect1>
  <sect1 xml:id="glibc-File-Owner">
    <title>Dosya İyeliği</title>
    <titleabbrev>Yeni dosyaların iyeliği nasıl belirlenir ve nasıl değiştirilir?</titleabbrev>
    <para>
<indexterm scope="glibc-cp"><primary>dosyalar</primary><secondary>sahiplik</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>dosyalar</primary><secondary>bir gruba aidiyeti</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>dosyalar</primary><secondary>bir kullanıcıya ait olmak</secondary></indexterm>
Her dosyanın sistemde kayıtlı kullanıcı olarak tanımlı bir <firstterm>sahibi</firstterm> ve sistemde tanımlı gruplardan biri olarak bir <firstterm>grubu</firstterm> vardır. Dosya sahibi çoğunlukla bir dosyayı düzenleyebilen kullanıcı olarak ele alınırsa da asıl amaç erişim denetimidir.
    </para><para>
Dosya sahibi ve grubu erişimi saptamakta kullanılır. Bunlar için her dosyada erişim izin bitleri tanımlanmıştır; bir bit kümesi dosyanın sahibinin yetkilerini, ikinci bir bit kümesi dosyaya erişim yetkisi olan gruba tanınan yetkileri, üçüncüsü bir bit kümesi ise diğerlerine tanınan yetkileri belirlemekte kullanılır. Bu veriye dayalı olarak erişime nasıl karar verildiği <xref linkend="glibc-Access-Permission"/> bölümünde ayrıntılı olarak açıklanmıştır.
    </para><para>
Bir dosya oluşturulurken, sahibi, <link linkend="glibc-Process-Persona">sürecin etkin kullanıcı kimliği</link> yapılarak dosya oluşturulur. Dosyanın grup kimliği dosyayı içerecek dosya sistemine bağlı olarak ya sürecin etkin grup kimliği ya da dosyayı içeren dizinin grup kimliği yapılır. Uzak bir dosya sistemine eriştiğinizde uygulanan kurallar sizin dosya sisteminizin değil uzak dosya sisteminin kuralları olacaktır. Bu bakımdan yazılımınız üzerinde çalıştığı sistemin davranış çeşidine bakmaksızın her davranış çeşidine uyum sağlamaya hazır olmalıdır.
    </para><para>
<indexterm scope="glibc-pg"><primary>chown</primary></indexterm>
<indexterm scope="glibc-pg"><primary>chgrp</primary></indexterm>
Mevcut bir dosyanın sahibini ve/veya grubunu <command>chown</command> işlevini kullanarak değiştirebilirsiniz. Bu işlev <command>chown</command> ve <command>chgrp</command> kabuk komutlarının ilkelidir.
    </para><para>
<indexterm scope="glibc-pg"><primary>unistd.h</primary></indexterm>
Bu işlevin prototipi <filename>unistd.h</filename> başlık dosyasında bildirilmiştir.
    </para><para xml:id="glibc-chown">
<indexterm scope="glibc-fn"><primary>chown</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>chown</command></funcdef>
<paramdef>(const char *<varname>dosyaismi</varname>,
 uid_t       <varname>kullanıcı</varname>,
 gid_t       <varname>grup</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>chown</command> işlevi ismi <varname>dosyaismi</varname> ile belirtilen dosyanın sahibini <varname>kullanıcı</varname> ve grubunu <varname>grup</varname> olarak değiştirir.
    </para><para>
Bazı sistemlerde bir dosyanın iyeliğinin değiştirilmesi set-user-ID ve set-group-ID bitlerinin temizlenmesine yol açar (Bu bitlerin dosyanın yeni sahipleri ile ilgisi olmadığından bu böyledir.) Diğerleri ile ilişkili izin bitleri değişmez.
    </para><para>
İşlev başarılı olduğunda <command>0</command>, aksi takdirde <command>-1</command> ile döner. <link linkend="glibc-File-Name-Errors">Dosya ismi hatalarına</link> ek olarak aşağıdaki <command>errno</command> hata durumları bu işlev için tanımlanmıştır:
    </para><para><variablelist><varlistentry>
    <term><literal>EPERM</literal></term><listitem><para>
Bu sürecin yetkileri istenen değişikliği yapmak için yetersiz.
       </para><para>
Sadece ayrıcalıklı kullanıcı ve dosyanın sahibi dosyanın grubunu değiştirebilir. Çoğu sistemde dosyanın sahibini sadece ayrıcalıklı kullanıcı değiştirebilirken bazı sistemlerde ise dosya sahibini değiştirmenize o dosyanın sahibi olarak görünüyorsanız izin verilir. Uzak bir dosya sistemine eriştiğinizde uygulanan kurallar sizin dosya sisteminizin değil uzak dosya sisteminin kuralları olacaktır.
       </para><para>
<command>_POSIX_CHOWN_RESTRICTED</command> makrosu hakkında bilgi edinmek için <xref linkend="glibc-Options-for-Files"/> bölümüne bakınız.       </para></listitem></varlistentry><varlistentry>
       <term><literal>EROFS</literal></term><listitem><para>
Dosya, salt-okunur bağlı bir dosya sisteminde.
       </para></listitem></varlistentry></variablelist>
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-fchown">
<indexterm scope="glibc-fn"><primary>fchown</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>fchown</command></funcdef>
<paramdef>(int <varname>dosyatanıtıcı</varname>,
 int <varname>kullanıcı</varname>,
 int <varname>grup</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev bir dosya ismi değil <varname>dosyatanıtıcı</varname> ile belirtilen bir açık dosya tanıtıcı alması dışında <command>chown</command> işlevi gibidir.
    </para><para>
İşlev başarılı olduğunda <command>0</command>, aksi takdirde <command>-1</command> ile döner. Aşağıdaki <command>errno</command> hata durumları bu işlev için tanımlanmıştır:
    </para><para><variablelist><varlistentry>
    <term><literal>EBADF</literal></term><listitem><para>
<varname>dosyatanıtıcı</varname> argümanı geçerli bir dosya tanıtıcı değil.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>EINVAL</literal></term><listitem><para>
<varname>dosyatanıtıcı</varname> argümanı normal bir dosyayla değil, bir boru ya da soket ile ilişkili.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>EPERM</literal></term><listitem><para>
Bu sürecin yetkileri istenen değişikliği yapmak için yetersiz. Ayrıntılar için yukarı, <command>chmod</command> işlevine bakınız.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>EROFS</literal></term><listitem><para>
Dosya, salt-okunur bağlı bir dosya sisteminde.
       </para></listitem></varlistentry></variablelist>
  </para></funcdescr></funcsynopsis></para></sect1>
  <sect1 xml:id="glibc-Permission-Bits">
    <title>Erişim İzinleri için Kip Bitleri</title>
    <titleabbrev>Bir dosyanın erişim kipi nasıl belirlenir.</titleabbrev>
    <para>
<wordasword>Dosya kipi</wordasword>, dosya özniteliklerinin  <command>st_mode</command> alanınada saklanır ve iki çeşit bilgi içerebilir: dosya türü kodu ve erişim izin bitleri.  Bu bölümde sadece bir dosyayı kimlerin okuyabileceği veya yazabileceğini denetleyen erişim izni bitleri açıklanacaktır. Dosya türü kodları <xref linkend="glibc-Permission-Bits"/> bölümünde açıklanmıştır.
    </para><para>
Bu bölümdeki sembollerin hepsi  <filename>sys/stat.h</filename> başlık dosyasında tanımlanmıştır.
<indexterm scope="glibc-pg"><primary>sys/stat.h</primary></indexterm>
<indexterm scope="glibc-cp"><primary>dosyalar</primary><secondary>erişim bitleri</secondary></indexterm>
Bir dosyanın erişim izinlerini denetleyen dosya kipi bitleri için tanımlanmış sabitler:
    </para><para><variablelist><varlistentry>
    <term><literal>S_IRUSR</literal></term>
    </varlistentry><varlistentry>
    <term><literal>S_IREAD</literal></term><listitem><para>
<indexterm scope="glibc-vr"><primary>S_IRUSR</primary></indexterm>
<indexterm scope="glibc-vr"><primary>S_IREAD</primary></indexterm>
Dosyanın sahibi için okuma yetkisi biti. Bir çok sistemde bu bit 0400'dür.  <command>S_IREAD</command> sabiti bu sabitin BSD uyumluluğu için sağlanmış artık atıl olmuş bir eşanlamlısıdır.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>S_IWUSR</literal></term>
       </varlistentry><varlistentry>
       <term><literal>S_IWRITE</literal></term><listitem><para>
<indexterm scope="glibc-vr"><primary>S_IWUSR</primary></indexterm>
<indexterm scope="glibc-vr"><primary>S_IWRITE</primary></indexterm>
Dosyanın sahibi için yazma yetkisi biti. Bir çok sistemde bu bit 0200'dür.  <command>S_IWRITE</command> sabiti bu sabitin BSD uyumluluğu için sağlanmış artık atıl olmuş bir eşanlamlısıdır.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>S_IXUSR</literal></term>
       </varlistentry><varlistentry>
       <term><literal>S_IEXEC</literal></term><listitem><para>
<indexterm scope="glibc-vr"><primary>S_IXUSR</primary></indexterm>
<indexterm scope="glibc-vr"><primary>S_IEXEC</primary></indexterm>
Dosyanın sahibi için normal dosyalarda çalıştırma, dizinlerde arama yetkisi biti. Bir çok sistemde bu bit 0100'dür.  <command>S_IEXEC</command> sabiti bu sabitin BSD uyumluluğu için sağlanmış artık atıl olmuş bir eşanlamlısıdır.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>S_IRWXU</literal></term><listitem><para>
<indexterm scope="glibc-vr"><primary>S_IRWXU</primary></indexterm>
<command>(S_IRUSR | S_IWUSR | S_IXUSR)</command> ifadesinin eşdeğeridir.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>S_IRGRP</literal></term><listitem><para>
<indexterm scope="glibc-vr"><primary>S_IRGRP</primary></indexterm>
Dosyanın grubu için okuma yetkisi biti. Bir çok sistemde bu bit 040'tır.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>S_IWGRP</literal></term><listitem><para>
<indexterm scope="glibc-vr"><primary>S_IWGRP</primary></indexterm>
Dosyanın grubu için yazma yetkisi bitleri. Bir çok sistemde bu bit 020'dir.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>S_IXGRP</literal></term><listitem><para>
<indexterm scope="glibc-vr"><primary>S_IXGRP</primary></indexterm>
Dosyanın grubu için çalıştırma ve arama yetkisi biti. Bir çok sistemde bu bit 010'dur.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>S_IRWXG</literal></term><listitem><para>
<indexterm scope="glibc-vr"><primary>S_IRWXG</primary></indexterm>
<command>(S_IRGRP | S_IWGRP | S_IXGRP)</command> ifadesinin eşdeğeridir.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>S_IROTH</literal></term><listitem><para>
<indexterm scope="glibc-vr"><primary>S_IROTH</primary></indexterm>
Diğer kullanıcılar için okuma yetkisi biti. Bir çok sistemde bu bit 04'tür.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>S_IWOTH</literal></term><listitem><para>
<indexterm scope="glibc-vr"><primary>S_IWOTH</primary></indexterm>
Diğer kullanıcılar için yazma yetkisi biti. Bir çok sistemde bu bit 02'dir.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>S_IXOTH</literal></term><listitem><para>
<indexterm scope="glibc-vr"><primary>S_IXOTH</primary></indexterm>
Diğer kullanıcılar için çalıştırma ve arama yetkisi biti. Bir çok sistemde bu bit 01'dir.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>S_IRWXO</literal></term><listitem><para>
<indexterm scope="glibc-vr"><primary>S_IRWXO</primary></indexterm>
<command>(S_IROTH | S_IWOTH | S_IXOTH)</command> ifadesinin eşdeğeridir.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>S_ISUID</literal></term><listitem><para>
<indexterm scope="glibc-vr"><primary>S_ISUID</primary></indexterm>
Çalıştırma biti üzerinde etkili set-user-ID bitidir. Bir çok sistemde bu bit 04000'dir. Bkz. <xref linkend="glibc-How-Change-Persona"/>.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>S_ISGID</literal></term><listitem><para>
<indexterm scope="glibc-vr"><primary>S_ISGID</primary></indexterm>
Çalıştırma biti üzerinde etkili set-group-ID bitidir. Bir çok sistemde bu bit 02000'dir. Bkz. <xref linkend="glibc-How-Change-Persona"/>.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>S_ISVTX</literal></term><listitem><para>
<indexterm scope="glibc-vr"><primary>S_ISVTX</primary></indexterm>
<indexterm scope="glibc-cp"><primary>dosyalar</primary><secondary>yapışkan bit</secondary></indexterm>
<wordasword>yapışkan bit</wordasword>. Bir çok sistemde bu bit 01000'dir.
       </para><para>
Bu bit, bir dizin için bu dizindeki bir dosyayı silme iznini sadece dosyanın sahibine verir. Normalde bir kullanıcı ya bir dizindeki tüm dosyaları silebilir ya da hiçbirini silemez (kullanıcının dizine yazma izni olup olmamasına bağlı olarak). Bu sınırlamalar uygulandığında bir dosyayı silebilmek için hem dosya sizin dosyanız olmalı hem de onun bulunduğu dizine yazma izniniz olmalıdır. Buna bir istisna, dizinin sahibi olmaktır. Dizinin sahibi olan kullanıcı dizin içindeki dosyaların hepsini dosyaların sahiplerinin kim olduğuna bakılmaksızın silme yetkisine sahiptir. Bu bit <command>/tmp</command> dizininde faydalı bir amaç için kullanılır; bu dizinde herkes dosya oluşturabilir ama kimse diğerinin dosyasını silemez.
       </para><para>
Evvelce, bir çalıştırılabilir dosyada yapışkan bit etkin olduğunda sistemin takaslama kurallarında bu yazılım için değişiklik yapılırdı.  Normalde, bir yazılım sonlandığında onun bellekteki sayfaları serbest bırakılır ve yeniden kullanıma hazır tutulurdu. Eğer çalıştırılabilir dosyanın yapışkan biti etkinse, yazılım sonlandığında bellekteki sayfaları serbest bırakılmaz, yazılım hala çalışıyormuş gibi bellekte tutulurdu. Bu durum aynı yazılım defalarca çalıştırıldığında bu yazılım için bir ayrıcalık oluştururdu. Bu kullanım artık günümüzde atıl olmuştur. Artık, bir yazılım sonlandığında bellekteki sayfaları bir ihtiyaç hasıl olana kadar serbest bırakılmamaktadır. Aynı yazılım tekrar çalıştırıldığında eski sayfaları hala bellekte duruyorsa onlar kullanılabilmekte, bir ihtiyaçtan dolayı kullanılmışsa yazılım tekrar belleğe yüklenmektedir.
       </para><para>
Günümüzdeki bazı sistemlerde bir çalıştırılabilir dosya açısından yapışkan bit anlamlı değildir, böyle sistemlerde bu bit dizinler dışında etkinleştirilemez. Eğer bunu denerseniz, <command>chmod</command> işlevi <command>EFTYPE</command> hatasıyla başarısız olur; bkz. <xref linkend="glibc-Setting-Permissions"/>.
       </para><para>
Bazı sistemler (özellikle SunOS) yapışkan bit kullanımı ile ilgili olarak farklı bir uygulama yapar. Eğer yapışkan bit bir çalıştırılabilir <emphasis>olmayan</emphasis> dosya için etkinleştirilirse, tamamen zıt bir uygulama olarak, o dosyanın sayfaları belleğe alınmaz. Bunun kullanım alanı, bir NFS sunucusu üzerinde, disksiz istemcilerin takas alanı olarak kullanmak üzere ayrılmış dosyalardır. Bu dosyalar istemci makinenin belleğinde sayfalandığından, bunların bir de sunucu makinenin belleğinde sayfalanması anlamsız olacağından bu yönteme başvurulmuştur. Bu kullanımda yapışkan bit ayrıca dosya sisteminin disk üzerinde düzenli olarak dosyanın değişiklik zamanını kaydetmesinin başarısız olmasını sağlar (bir takas dosyasıyla nasılsa kimse ilgilenmez, denerek).
       </para><para>
Bu bit sadece BSD sistemlerinde geçerlidir (ve ondan türetilmiş sistemlerde). Bu bakımdan bu biti kullanmak için <command>_BSD_SOURCE</command> özellik seçim makrosunu tanımlı yapmalısınız (bkz. <xref linkend="glibc-Feature-Test-Macros"/>).
       </para></listitem></varlistentry></variablelist>
     </para><para>
Yukarıda listelenen sembollerin bit değerlerini kullanarak yazılımınızda hata ayıklarken dosya kip değerlerini çözümleyebilirsiniz. Bu bit değerleri çoğu sistemde geçerlidir ama hepsinin olacağı garanti değildir.
    </para><para>
<warning><para>Dosya izinleri için doğrudan sayıları kullanmak iyi bir uygulama olmaz. Taşınabilir olmayacağından başka, bitlerin anlamlarını hatırlamak için yazılımınızın koduna bakmak gerekir. Temiz bir yazılım sembol isimleri kullanır.</para></warning>
    </para></sect1>
  <sect1 xml:id="glibc-Access-Permission">
    <title>Erişim İzinleri</title>
    <titleabbrev>Bir dosyaya kimin erişeceğine sistem nasıl karar verir?</titleabbrev>
    <para>
<indexterm scope="glibc-cp"><primary>dosyalar</primary><secondary>erişim izinleri</secondary></indexterm>
İşletim sistemi normalde bir dosyanın erişim izinlerine, sürecin etkin kullanıcı ve grup kimlikleri ve ek grup kimlikleri ile dosyanın sahibi, grubu ve izin bitlerine birlikte bakarak karar verir. Bu kavramlar ayrıntılı olarak <xref linkend="glibc-Process-Persona"/> bölümünde anlatılmıştır.
    </para><para>
Eğer sürecin etkin kullanıcı kimliği ile dosyanın sahibinin kullanıcı kimliği aynı ise, bu kullanıcının okuma, yazma ve çalıştırma/arama izinleri geçerli olur. Benzer şekilde, eğer, sürecin etkin veya ek grup kimliklerinden biri dosyanın grup kimliği ile aynıysa, bu grubun izinleri geçerli olur. Aksi takdirde, diğerlerinin izinlerine bakılır.
    </para><para>
<command>root</command> gibi ayrıcalıklı kullanıcılar, izin bitlerine bakılmaksızın her dosyaya erişebilirler. Özel bir durum olarak, çalıştırılabilir bir dosyayı ayrıcalıklı kullanıcının dahi çalıştırabilmesi için dosyanın çalıştırma biti etkin olmalıdır.
    </para></sect1>
  <sect1 xml:id="glibc-Setting-Permissions">
    <title>Dosya İzinlerinin Atanması</title>
    <titleabbrev>İzinler yeni dosyalara nasıl atanır ve nasıl değiştirilir?</titleabbrev>
    <para>
<indexterm scope="glibc-cp"><primary>dosyalar</primary><secondary>oluşturma maskesi</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>umask</primary></indexterm>
Dosyaları oluşturmakta kullanılan <command>open</command> veya <command>mkdir</command> gibi ilkel işlevler yeni oluşturulacak dosyaya atanacak dosya izinlerini belirleyen bir <varname>kip</varname> argümanı alırlar. Bu kip kullanılmadan önce sürecin <firstterm>dosya oluşturma maskesi</firstterm> ya da <firstterm>umask</firstterm> ile değişikliğe uğratılır.
    </para><para>
Dosya oluşturma maskesinde izinleri ifade eden bitler yeni oluşturulan dosyalar için iptal edilecek izinleri belirtir. Örneğin, maskede diğerlerine bütün erişim izinleri verilmişse, diğer kategorisindeki hiçbir süreç bu dosyaya erişemeyecektir; dosyayı oluşturan işlevin <varname>kip</varname> argümanında diğerlerine tüm erişim izinleri verilimiş olsa bile! Başka bir deyişle dosya oluşturma maskesi vermek istediğiniz erişim izinlerinin tümleyenidir.
    </para><para>
Dosya oluşturan yazılımlar genellikle <varname>kip</varname> argümanında herkese tüm izinleri veren bir değer belirtirler. Normal bir dosya için bu herkese okuma ve yazma izinleri vermek şeklindedir. Daha sonra dosya oluşturulurken bu izinler kullanıcının dosya oluşturma maskesi kullanılarak sınırlanır.
    </para><para>
<indexterm scope="glibc-fn"><primary>chmod</primary></indexterm>
İsmini belirterek mevcut bir dosyanın izinlerini değiştirmek için  <command>chmod</command> işlevi kullanılır. Bu işlev belirtilen izinleri kullanırken dosya oluşturma maskesini yoksayar.
    </para><para>
<indexterm scope="glibc-pg"><primary>umask</primary></indexterm>
Normal kullanımda, dosya oluşturma maskesi kullanıcının oturum açma kabuğu tarafından (<command>umask</command> kabuk komutu ile) ilklendirilir ve tüm alt süreçler tarafından miras alınır. Uygulama yazılımları dosya oluşturma maskesi için normalde endişelenmezler. Onun özdevinimli oluşturulduğu kabul edilir.
    </para><para>
Yazılımınızın, bir dosyanın, dosya oluşturma maskesini yoksayarak erişim izinlerini belirlemesini istiyorsanız bunun en kolay yolu dosyayı açtıktan sonra dosya oluşturma maskesini değiştirmek yerine, <command>fchmod</command> işlevini kullanmaktır. Aslında, dosya oluşturma maskesini değiştirme işlemi sadece kabuk tarafından yapılır. Kabuk bunu <command>umask</command> işlevini kullanarak yapar.
    </para><para>
Bu bölümdeki işlevler <filename>sys/stat.h</filename> başlık dosyasında bildirilmiştir.
<indexterm scope="glibc-pg"><primary>sys/stat.h</primary></indexterm>
    </para><para xml:id="glibc-umask">
<indexterm scope="glibc-fn"><primary>umask</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>mode_t <command>umask</command></funcdef>
<paramdef>(mode_t <varname>maske</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>umask</command> işlevi çağrıldığı sürecin dosya oluşturma maskesini <varname>maske</varname> yapar ve önceki dosya oluşturma maskesi ile döner.
    </para><para>
Bu örnekte, dosya oluşturma maskesinin kalıcı olarak değiştirilmeksizin <command>umask</command> ile nasıl okunacağı gösterilmiştir:
    </para><para>
<screen>mode_t
read_umask (void)
{
  mode_t mask = umask (0);
  umask (mask);
  return mask;
}
</screen></para><para>
Ancak, maske değerini sadece okumak istiyorsanız <command>getumask</command> işlevini kullanmak daha iyidir, çünkü bu işlev evreseldir (en azından GNU sisteminde).
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-getumask">
<indexterm scope="glibc-fn"><primary>getumask</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>mode_t <command>getumask</command></funcdef>
<paramdef>(void)</paramdef>
</funcprototype><funcdescr><para>
Çağrıldığı sürecin dosya oluşturma maskesi ile döner. Bu işlev bir GNU oluşumudur
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-chmod">
<indexterm scope="glibc-fn"><primary>chmod</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>chmod</command></funcdef>
<paramdef>(const char *<varname>dosyaismi</varname>,
 mode_t      <varname>kip</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>chmod</command> işlevi, ismi <varname>dosyaismi</varname> ile belirtilen dosyanın erişim izinlerini <varname>kip</varname> ile belirtilen değere ayarlar.
    </para><para>
<varname>dosyaismi</varname> bir sembolik bağ ise, <command>chmod</command> bağın değil, bağın hedefindeki dosyanın izinlerini değiştirir.
    </para><para>
İşlev başarılı olduğunda <command>0</command>, aksi takdirde <command>-1</command> ile döner. <link linkend="glibc-File-Name-Errors">Dosya ismi hatalarına</link> ek olarak aşağıdaki <command>errno</command> hata durumları bu işlev için tanımlanmıştır:
    </para><para><variablelist><varlistentry>
    <term><literal>ENOENT</literal></term><listitem><para>
Belirtilen dosya yok.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>EPERM</literal></term><listitem><para>
Bu sürecin, bu dosyanın erişim izinlerini değiştirme izni yok. Sadece dosyanın sahibi (sürecin etkin kullanıcı kimliğinden saptanır) ya da ayrıcalıklı kullanıcı onları değiştirebilir.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>EROFS</literal></term><listitem><para>
Dosya salt-okunur bağlı bir dosya sistemi üzerinde.
       </para></listitem></varlistentry><varlistentry><term>
       <literal>EFTYPE</literal></term><listitem><para>
<varname>kip</varname> argümanı <command>S_ISVTX</command> bitini (&quot;yapışkan bit&quot;) içeriyor ama ismi belirtilen dosya bir dizin değil. Bazı dosya sistemlerinde yapışkan bitin dosyalara verilmesine izin verilirken bazılarında da verilmez (sadece dizinlerde izin verilir).
       </para><para>
<command>EFTYPE</command> hatasını sadece yapışkan bitin dizinler dışında anlamlı olmadığı dosya sistemlerinde alırsınız. Bu olduğu takdirde, yapışkan biti içermeyen bir <varname>kip</varname> değeri ile tekrar <command>chmod</command> çağrısı yapın. Yapışkan bit ile ilgili daha ayrıntılı bilgi edinmek için <xref linkend="glibc-Permission-Bits"/> bölümüne bakınız.
       </para></listitem></varlistentry></variablelist>
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-fchmod">
<indexterm scope="glibc-fn"><primary>fchmod</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>fchmod</command></funcdef>
<paramdef>(int <varname>dosyatanıtıcı</varname>,
 int <varname>kip</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev argüman olarak dosya ismi yerine bir <link linkend="glibc-Low-Level-I-O">açık dosya tanıtıcı</link> alması dışında <command>chmod</command> işlevinin benzeridir.
    </para><para>
İşlev başarılıysa <command>0</command> ile değilse <command>-1</command> ile döner.  Aşağıdaki <command>errno</command> hata durumları bu işlev için tanımlanmıştır:
    </para><para><variablelist><varlistentry>
    <term><literal>EBADF</literal></term><listitem><para>
<varname>dosyatanıtıcı</varname> argümanı geçerli bir dosya tanıtıcı değil.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>EINVAL</literal></term><listitem><para>
<varname>dosyatanıtıcı</varname> argümanı bir boru veya soket ya da erişim izinlerine konu olmayan bir şeye ait.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>EPERM</literal></term><listitem><para>
Bu sürecin dosyanın izinlerini değiştirme yetkisi yok. Sadece dosyanın sahibi (sürecin etkin kullanıcı kimliğinden saptanır) ya da ayrıcalıklı kullanıcı izinleri değiştirebilir.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>EROFS</literal></term><listitem><para>
Dosya salt-okunur bağlı bir dosya sisteminde bulunuyor.
       </para></listitem></varlistentry></variablelist>
  </para></funcdescr></funcsynopsis></para></sect1>
  <sect1 xml:id="glibc-Testing-File-Access">
    <title>Dosya Erişim İzinlerinin Sınanması</title>
    <titleabbrev>Sürecinizin bir dosyaya erişimi olup olmadığını nasıl öğrenirsiniz?</titleabbrev>
    <para>
<indexterm scope="glibc-cp"><primary>dosyalar</primary><secondary>erişim izinleri</secondary><tertiary>sınanması</tertiary></indexterm>
<indexterm scope="glibc-cp"><primary>dosyalar</primary><secondary>erişim izinleri</secondary><tertiary>setuid yazılımlar</tertiary></indexterm>
Bazı durumlarda kullanıcının erişim yetkisi olmayan bazı dosyalara ya da aygıtlara yazılım üzerinden erişebilmesi istenir. Olası bir çözüm yazılımın setuid bitini etkinleştirmektir. Böyle bir yazılım çalıştırılırsa, sürecin etkin kullanıcı kimliği yazılım dosyasının sahibi olarak değiştirilir. Böylece, yazılımın sahibi <command>root</command> yapılıp setuid biti de etkinleştirilerek, normalde sadece ayrıcalıklı kullanıcı tarafından erişilebilen <filename>/etc/passwd</filename> gibi dosyalara,  yazma erişimi sağlanabilir.
    </para><para>
Bunun yanında bir kullanıcının erişim izni olmayan dosyalara erişmesine izin vermeyecek bir düzenleme de düşünülebilir. Bu durumda yazılım, bir dosyayı okumadan ya da ona yazmadan önce <emphasis>kullanıcının</emphasis> gerekli erişim izinlerine sahip olup olmadığını sınamalıdır.
    </para><para>
Bunu yapmak için, sürecin etkin kullanıcı kimliğine değil gerçek kullanıcı kimliğine dayalı erişim izinlerini sınayan <command>access</command> işlevi kullanılır. (Setuid özelliği gerçek kullanıcı kimliği değiştirmez, böylece yazılımı gerçekte kimin çalıştırdığı saptanır.)
    </para><para>
Bu erişimi sınamanın  daha kolay açıklanabilen bir yolu daha vardır, ama onun da kullanımı zordur. Bu yöntemde işlem dosya kip bitlerini öğrenerek ve sistemin kendi erişim hesaplaması taklit edilerek yapılır. Bu yöntemin kullanılması pek tercih edilmez, çünkü bir çok sistem ek erişim denetim özelliklerine sahiptir ve yazılımınız farklı sistemlerin farklı erişim özelliklerini taşınabilir olarak taklit etmek zorunda kalacaktır. <command>access</command> işlevi bu işlemleri sizin yerinize yapar.
    </para><para>
<command>access</command> işlevi <emphasis>sadece</emphasis> ve sadece setuid yazılımlarda kullanmak için değildir. Setuid olmayan bir yazılım daima gerçek kimlik yerine etkin kimliği kullanır.
    </para><para>
<indexterm scope="glibc-pg"><primary>unistd.h</primary></indexterm>
Bu bölümdeki semboller <filename>unistd.h</filename> başlık dosyasında bildirilmiştir.
    </para><para xml:id="glibc-access">
<indexterm scope="glibc-fn"><primary>access</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>access</command></funcdef>
<paramdef>(const char *<varname>dosyaismi</varname>,
 int         <varname>nasıl</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>access</command> işlevi ismi <varname>dosyaismi</varname> ile belirtilen dosyaya <varname>nasıl</varname> ile belirtilen yolla erişilip erişilemeyeceğini sınar. <varname>nasıl</varname> argümanında belirtilebilecek değer ya <command>R_OK</command>, <command>W_OK</command> ve <command>X_OK</command> seçeneklerinin bit seviyesinde VEYA'lanmışı ya da <command>F_OK</command> varlık sınaması olabilir.
    </para><para>
Bu işlev erişim izinlerini sınamak için sürecin etkin kullanıcı ve grup kimliklerini değil, gerçek kullanıcı ve grup kimliklerini kullanır. Sonuç olarak, bu işlevi bir <command>setuid</command> veya <command>setgid</command> yazılımda (<xref linkend="glibc-How-Change-Persona"/>) kullanıyorsanız, işlev yazılımı gerçekte hangi kullanıcı çalıştırıyorsa o kullanıcıya göre bilgi verir.
    </para><para>
Erişime izin verilmişse işlev <command>0</command> ile, aksi takdirde <command>-1</command> ile döner.  (Başka bir deyişle, eğer istenen erişime <emphasis>izin verilmezse</emphasis>, <command>access</command> işlevi, bir isnat işlevi gibi düşünülerek doğru ile döner.)
    </para><para>
<link linkend="glibc-File-Name-Errors">Dosya ismi hatalarına</link> ek olarak aşağıdaki <command>errno</command> hata durumları bu işlev için tanımlanmıştır:
    </para><para><variablelist><varlistentry>
    <term><literal>EACCES</literal></term><listitem><para>
<varname>nasıl</varname> ile belirtilen erişime izin verilmiyor.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>ENOENT</literal></term><listitem><para>
Dosya mevcut değil.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>EROFS</literal></term><listitem><para>
Salt-okunur bağlı bir dosya sistemi üzerindeki bir dosya için yazma izni istendi.
       </para></listitem></varlistentry></variablelist>
</para></funcdescr></funcsynopsis></para><para>
<command>access</command> işlevinin <varname>nasıl</varname> argümanında kullanmak için tasarlanmış olan bu makrolar tamsayı sabitler olarak <filename>unistd.h</filename> başlık dosyasında tanımlanmıştır:
<indexterm scope="glibc-pg"><primary>unistd.h</primary></indexterm>
     </para><para xml:id="glibc-R_OK">
<indexterm scope="glibc-vr"><primary>R_OK</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>int <command>R_OK</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Okuma izni için sınama seçeneği.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-W_OK">
<indexterm scope="glibc-vr"><primary>W_OK</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>int <command>W_OK</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Yazma izni için sınama seçeneği.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-X_OK">
<indexterm scope="glibc-vr"><primary>X_OK</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>int <command>X_OK</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
çalıştırma/arama izni için sınama seçeneği.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-F_OK">
<indexterm scope="glibc-vr"><primary>F_OK</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>int <command>F_OK</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Dosyanın mevcut olup olmadığını sınama seçeneği.
  </para></funcdescr></funcsynopsis></para></sect1>
  <sect1 xml:id="glibc-File-Times">
    <title>Dosya Zamanları</title>
    <titleabbrev>Bir dosyanın zaman öznitelikleri hakkında.</titleabbrev>
    <para>
<indexterm scope="glibc-cp"><primary>dosyalar</primary><secondary>erişim zamanı</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>dosyalar</primary><secondary>değişiklik zamanı</secondary><tertiary>dosya içeriği için</tertiary></indexterm>
<indexterm scope="glibc-cp"><primary>dosyalar</primary><secondary>değişiklik zamanı</secondary><tertiary>dosya öznitelikleri için</tertiary></indexterm>
Her dosyanın kendisiyle ilgili üç zaman damgası vardır: erişim zamanı, değişiklik zamanı ve öznitelik değişiklik zamanı; bkz.  <xref linkend="glibc-File-Attributes"/>.
    </para><para>
Bu zamanların hepsi mutlak zaman biçiminde gösterilen <command>time_t</command> türünde nesnelerdir. Bu veri türü  <command>time.h</command> başlık dosyasında tanımlanmıştır. Zaman değerlerinin gösterilmesi ve değiştirilmesi hakkında daha fazla bilgi için <xref linkend="glibc-Calendar-Time"/> bölümüne bakınız.
<indexterm scope="glibc-pg"><primary>time.h</primary></indexterm>
    </para><para>
Bir dosyanın okunması erişim zamanını güncellerken, yazılması değişiklik zamanını günceller. Dosya oluşturulduğu zaman, üç zaman damgasına da dosyanın oluşturulduğu zaman değeri atanır. Ek olarak, yeni girdiyi içeren dizinin erişim ve değişiklik zamanı da güncellenir.
    </para><para>
<command>link</command> ile bir dosyaya yeni isim eklenmesi, isim eklenen dosyanın öznitelik değişiklik zamanını günceller ve bu yeni ismi içeren dizinin öznitelik ve içerik değişiklik zamanları da güncellenir. <command>unlink</command>, <command>remove</command> veya <command>rmdir</command> ile dosya isminin silinmesi de aynı alanları etkiler. Bir dosyanın isminin <command>rename</command> ile değiştirilmesi  sadece bu değişiklikten etkilenen iki dizinin içerik ve öznitelik değişiklik zamanlarını günceller, ismi değiştirilen dosyada zaman güncellemesi yapılmaz.
    </para><para>
Bir dosyanın özniteliklerinin değiştirilmesi (örn, <command>chmod</command> ile), öznitelik değişiklik zamanını günceller.
    </para><para>
Öznitelik değişiklik zamanı dışında bir dosyanın değişiklik zamanlarını <command>utime</command> işleviyle doğrudan değiştirebilirsiniz. Bu oluşumu yazılımınızda kullanmak için yazılımınıza <filename>utime.h</filename> başlık dosyasını dahil etmelisiniz.
<indexterm scope="glibc-pg"><primary>utime.h</primary></indexterm>
    </para><para xml:id="glibc-struct-utimbuf">
<indexterm scope="glibc-tp"><primary sortas="utimbuf">struct utimbuf</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü">
<funcdef>struct <command>utimbuf</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
<command>utimbuf</command> yapısı bir dosyaya yeni erişim ve değişiklik zamanlarını belirtmek için <command>utime</command> işlevi ile kullanılır. Şu üyeleri içerir:
    </para><para><glosslist><glossentry><glossterm>
    <literal>time_t <command>actime</command></literal>
    </glossterm><glossdef><para>Dosyanın erişim zamanı.
    </para></glossdef></glossentry><glossentry><glossterm>
    <literal>time_t <command>modtime</command></literal>
    </glossterm><glossdef><para>Dosyanın (içerik) değişiklik zamanı.
    </para></glossdef></glossentry></glosslist>
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-utime">
<indexterm scope="glibc-fn"><primary>utime</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>utime</command></funcdef>
<paramdef>(const char           *<varname>dosyaismi</varname>,
 const struct utimbuf *<varname>zamanlar</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev ismi <varname>dosyaismi</varname> ile belirtilen dosyanın dosya zamanlarını değiştirir.
    </para><para>
Eğer <varname>zamanlar</varname> bir boş gösterici ise, dosyanın erişim ve değişiklik zamanları güncellenir. Aksi takdirde, zaman damgalarına <varname>zamanlar</varname> ile gösterilen <command>utimbuf</command> yapısının <command>actime</command> ve <command>modtime</command> üyelerindeki değerler atanır.
    </para><para>
Her durumda dosyanın öznitelik değişiklik zamanı güncellenir (çünkü dosyanın zaman ile ilgili öznitelikleri değişmiştir).
    </para><para>
İşlev başarılı olduğunda <command>0</command>, aksi takdirde <command>-1</command> ile döner. <link linkend="glibc-File-Name-Errors">Dosya ismi hatalarına</link> ek olarak aşağıdaki <command>errno</command> hata durumları bu işlev için tanımlanmıştır:
    </para><para><variablelist><varlistentry>
    <term><literal>EACCES</literal></term><listitem><para>
<varname>zamanlar</varname> argümanında boş gösterici aktarıldığı durumda bir izin sorunu var. Dosya zaman damgalarını güncelleyebilmek için ya dosyanın sahibi ya da ayrıcalıklı kullanıcı olmalısınız.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>ENOENT</literal></term><listitem><para>
Dosya mevcut değil.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>EPERM</literal></term><listitem><para>
Eğer <varname>zamanlar</varname> argümanı boş gösterci değilse  ya dosyanın sahibi ya da ayrıcalıklı kullanıcı olmalısınız.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>EROFS</literal></term><listitem><para>
Dosya salt-okunur bağlı bir dosya sisteminde bulunuyor.
       </para></listitem></varlistentry></variablelist>
</para></funcdescr></funcsynopsis></para><para>
Her üç zaman damgasınında çözünürlüğü arttıran mikrosaniyelik bir parçası vardır. Bu alanlar 0 ile 999,999 mikrosaniye arasında değer alabilen üç alanla ifade edilir: <command>st_atime_usec</command>, <command>st_mtime_usec</command> ve <command>st_ctime_usec</command>.  Bu alanlar bir <command>timeval</command> yapısının <command>tv_usec</command> üyesine karşılıktır; bkz. <xref linkend="glibc-High-Resolution-Calendar"/>.
    </para><para>
<command>utimes</command> işlevi <command>utime</command> işlevi gibidir, ancak dosya zamanlarının ondalık kısımlarını da belirtebilmenizi sağlar. Bu işlevin prototipi  <filename>sys/time.h</filename> başlık dosyasında bulunur.
<indexterm scope="glibc-pg"><primary>sys/time.h</primary></indexterm>
    </para><para xml:id="glibc-utimes">
<indexterm scope="glibc-fn"><primary>utimes</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>utimes</command></funcdef>
<paramdef>(const char    *<varname>dosyaismi</varname>,
 struct timeval <varname>zaman</varname>[2])</paramdef>
</funcprototype><funcdescr><para>
Bu işlev ismi <varname>dosyaismi</varname> ile belirtilen dosyanın erişim ve değişiklik zamanlarını değiştirir. Yeni dosya erişim zamanı <varname>zaman</varname><literal>[0]</literal> ile ve yeni değişiklik zamanı <varname>zaman</varname><literal>[1]</literal> ile belirtilir.  <varname>zaman</varname> olarak bir boş gösterici belirtilirse  <command>utime</command> işlevi gibi dosyanın erişim ve değişiklik zamanlarını günceller. Bu işlev BSD'den gelmektedir.
    </para><para>
İşlevin dönüş değerleri ve hata durumları  <command>utime</command> işlevininkilerle aynıdır.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-lutimes">
<indexterm scope="glibc-fn"><primary>lutimes</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>lutimes</command></funcdef>
<paramdef>(const char    *<varname>dosyaismi</varname>,
 struct timeval <varname>zaman</varname>[2])</paramdef>
</funcprototype><funcdescr><para>
Bu işlev <command>utimes</command> gibi olmakla birlikte sembolik bağları izlemez. <command>utimes</command> işlevi bir sembolik bağın hedefindeki dosyanın erişim ve değişiklik zamanlarını değiştirdiği halde, <command>lutimes</command> işlevi (<command>lstat</command> gibi; <xref linkend="glibc-Symbolic-Links"/>) sembolik bağ dosyasının kendi erişim ve değişiklik zamanlarını değiştirir. Bu işlev BSD'den gelmektedir ve tüm platformlarca desteklenmemektedir (desteklenmiyorsa, işlev <command>ENOSYS</command> hatasıyla başarısız olur).
    </para><para>
İşlevin dönüş değerleri ve hata durumları  <command>utime</command> işlevininkilerle aynıdır.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-futimes">
<indexterm scope="glibc-fn"><primary>futimes</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>futimes</command></funcdef>
<paramdef>(int            <varname>dosyatanıtıcı</varname>,
 struct timeval <varname>zaman</varname>[2])</paramdef>
</funcprototype><funcdescr><para>
Bu işlev <command>utimes</command> gibidir, ancak argüman olarak dosya ismi yerine bir <link linkend="glibc-Low-Level-I-O">açık dosya tanıtıcısı</link> alır. Bu işlev BSD'den gelmektedir ve tüm platformlarca desteklenmemektedir (desteklenmiyorsa, işlev <command>ENOSYS</command> hatasıyla başarısız olur).
    </para><para>
<command>utimes</command> gibi, <command>futimes</command> işlevi de başarılı olduğunda <command>0</command> ile aksi takdirde  <command>-1</command> ile döner. Aşağıdaki <command>errno</command> hata durumları bu işlev için tanımlanmıştır:
    </para><para><variablelist><varlistentry>
    <term><literal>EACCES</literal></term><listitem><para>
<varname>zamanlar</varname> argümanındaa boş gösterici aktarıldığı durumda bir izin sorunu var. Dosya zaman damgalarını güncelleyebilmek için ya dosyanın sahibi ya da ayrıcalıklı kullanıcı olmalısınız.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>EBADF</literal></term><listitem><para>
<varname>dosyatanıtıcı</varname> argümanı geçerli bir dosya tanıtıcı değil.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>EPERM</literal></term><listitem><para>
Eğer <varname>zamanlar</varname> argümanı boş gösterci değilse  ya dosyanın sahibi ya da ayrıcalıklı kullanıcı olmalısınız.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>EROFS</literal></term><listitem><para>
Dosya salt-okunur bağlı bir dosya sisteminde bulunuyor.
       </para></listitem></varlistentry></variablelist>
  </para></funcdescr></funcsynopsis></para></sect1>
  <sect1 xml:id="glibc-File-Size">
    <title>Dosya Boyu</title>
    <titleabbrev>Bir dosyanın boyu elle nasıl değiştirilir?</titleabbrev>
    <para>
Normalde dosya boyu özdevinimli olarak belirlenir. Bir dosya 0 boyda başlar ve veri yazıldıkça özdevinimli olarak uzar. Ayrıca, bir <command>open</command> ya da <command>fopen</command> çağrısı ile bir dosyanın içeriğini silmek ve boş duruma getirmek mümkündür.
    </para><para>
Yine de, kimi zaman bir dosyanın boyunu küçültmek gerekebilir. Bu işlem <command>truncate</command> ve <command>ftruncate</command> işlevleri ile yapılır. Bunlar BSD Unix'den gelir.  <command>ftruncate</command> işlevi daha sonra POSIX.1'e eklenmiştir.
    </para><para>
Bazı sistemler bu işlevlerle bir dosyayı uzatmaya da (delikler oluşturarak) izin verir. Dosyalar özdevinimli uzatılamadığında <link linkend="glibc-Memory-mapped-I-O">bellek eşlemli G/Ç</link> kullanılırken yararlı olur. Ancak, bu taşınabilir olmadığından, dosyaların eşlenmesine izin veriyorsa <command>mmap</command> ile gerçeklenmelidir (<command>_POSIX_MAPPED_FILES</command> tanımlıysa izin verir).
    </para><para>
Bu işlevlerin normal dosyalar dışında kullanılması <emphasis>tanımlanmamış</emphasis> sonuçlara yol açabilir. Çoğu sistemde böyle bir çağrı, aslında hiçbir işlem yapmakszın başarılı görünecektir.
    </para><para xml:id="glibc-truncate">
<indexterm scope="glibc-fn"><primary>truncate</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>truncate</command></funcdef>
<paramdef>(const char *<varname>dosyaismi</varname>,
 off_t       <varname>uzunluk</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>truncate</command> işlevi ismi <varname>dosyaismi</varname> ile belirtilen dosyanın uzunluğunu <varname>uzunluk</varname> yapar. Eğer <varname>uzunluk</varname> önceki uzunluktan küçükse dosyanın sonundaki veri kaybedilecektir. Bu işlemin gerçekleşebilmesi için kullanıcının dosyaya yazma izni olmalıdır.
    </para><para>
Eğer <varname>uzunluk</varname> önceki uzunluktan daha büyükse dosyanın sonuna delikler eklenir. Ancak, bazı sistemler bu işlemi desteklemez ve dosya değişmeden kalır.
    </para><para>
Kaynakların 32 bitlik bir sistemde <command>_FILE_OFFSET_BITS == 64</command> ile derlendiği durumda bu işlev aslında <command>truncate64</command> işlevidir ve <command>off_t</command> türü 2^63 bayt uzunluğa kadar dosyaları mümkün kılan 64 bitlik bir türdür.
    </para><para>
İşlev başarılı olduğunda <command>0</command>, aksi takdirde <command>-1</command> ile döner. <link linkend="glibc-File-Name-Errors">Dosya ismi hatalarına</link> ek olarak aşağıdaki <command>errno</command> hata durumları bu işlev için tanımlanmıştır:
    </para><para><variablelist><varlistentry>
    <term><literal>EACCES</literal></term><listitem><para>
Dosya ya bir dizin ya da yazılabilir değil.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>EINVAL</literal></term><listitem><para>
<varname>uzunluk</varname> negatif.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>EFBIG</literal></term><listitem><para>
Dosya boyu, işletim sisteminin sınırlarından fazlasına genişletiliyor.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>EIO</literal></term><listitem><para>
Bir donamım G/Ç hatası oluştu.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>EPERM</literal></term><listitem><para>
Dosya ya sona eklemeli ya da değiştirilemez türde.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>EINTR</literal></term><listitem><para>
İşlem bir sinyal ile engellendi.
       </para></listitem></varlistentry></variablelist>
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-truncate64">
<indexterm scope="glibc-fn"><primary>truncate64</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>truncate64</command></funcdef>
<paramdef>(const char *<varname>isim</varname>,
 off64_t     <varname>uzunluk</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev <command>truncate</command> işlevinin benzeridir.  Farkı, <varname>uzunluk</varname> argümanının 32 bitlik makinelerde bile 64 bitlik genişlikte olmasıdır. Böylece 2^63 bayta kadar dosya uzunlukları belirtilebilir.
    </para><para>
32 bitlik bir sistemde, kaynakların <command>_FILE_OFFSET_BITS == 64</command> ile derlendiği durumda bu işlev <command>truncate</command> ismiyle bulunur ve eski gerçekleme tamamen LFS'ye uygun olarak değiştirilir.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-ftruncate">
<indexterm scope="glibc-fn"><primary>ftruncate</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>ftruncate</command></funcdef>
<paramdef>(int   <varname>dosyatanıtıcı</varname>,
 off_t <varname>uzunluk</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev <command>truncate</command> gibidir, ancak bir açık dosya tanıtıcı ile çalışır. Dosya yazma amacıyla açılmış olmalıdır.
    </para><para>
POSIX standardı, dosyanın yeni <varname>uzunluk</varname> değerinin özgün dosya boyundan daha büyük olduğu durumda ne yapılacağını gerçeklemeye bırakmıştır. <command>ftruncate</command> işlevi ya dosyayı hiçbir şey yapmadan bırakır ya da istenen boya arttırır. İkinci durumda uzatılan bölge sıfırlarla doldurulur. <command>ftruncate</command> işlevi ile dosya boyunun arttırılması pek güvenilir olmasa da eğer uzatilabiliyorsa bu olası en hızlı yöntemdir. Bu işlev ayrıca eğer sistem tarafından gerçeklenmişse POSIX paylaşımlı bellek bölütleri üzerinde de çalışır.
    </para><para>
<command>ftruncate</command> işlevi özellikle <command>mmap</command> ile birlikte kullanıldığında yararlıdır. Dosya ile eşlenen bellek bölgeleri  sabit uzunlukta olduğundan son eşlenen sayfaya daha fazla bilgi yazarak dosya boyu büyütülemez. Dosya boyunu büyütmek için dosya yeni boyutla yeniden belleğe eşlenmelidir. Bunun nasıl yapıldığı aşağıda bir örnekle gösterilmiştir.
    </para><para>
Kaynakların 32 bitlik bir sistemde <command>_FILE_OFFSET_BITS == 64</command> ile derlendiği durumda bu işlev aslında <command>ftruncate64</command> işlevidir ve <command>off_t</command> türü 2^63 bayt uzunluğa kadar dosyaları mümkün kılan 64 bitlik bir türdür.
    </para><para>
İşlev başarılı olduğunda <command>0</command>, aksi takdirde <command>-1</command> ile döner. Aşağıdaki <command>errno</command> hata durumları bu işlev için tanımlanmıştır:
    </para><para><variablelist><varlistentry>
    <term><literal>EBADF</literal></term><listitem><para>
<varname>dosyatanıtıcı</varname> bir açık dosya ile ilgili değil.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>EACCES</literal></term><listitem><para>
<varname>dosyatanıtıcı</varname> ya bir dizin ya da yazmak için açılmamış.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>EINVAL</literal></term><listitem><para>
<varname>uzunluk</varname> negatif.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>EFBIG</literal></term><listitem><para>
Dosya boyu, işletim sisteminin sınırlarından fazlasına genişletiliyor.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>EIO</literal></term><listitem><para>
Bir donamım G/Ç hatası oluştu.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>EPERM</literal></term><listitem><para>
Dosya ya sona eklemeli ya da değiştirilemez türde.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>EINTR</literal></term><listitem><para>
İşlem bir sinyal ile engellendi.
       </para></listitem></varlistentry></variablelist>
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-ftruncate64">
<indexterm scope="glibc-fn"><primary>ftruncate64</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>ftruncate64</command></funcdef>
<paramdef>(int     <varname>id</varname>,
 off64_t <varname>uzunluk</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev <command>ftruncate</command> işlevinin benzeridir.  Farkı, <varname>uzunluk</varname> argümanının 32 bitlik makinelerde bile 64 bitlik genişlikte olmasıdır. Böylece 2^63 bayta kadar dosya uzunlukları belirtilebilir.
    </para><para>
32 bitlik bir sistemde, kaynakların <command>_FILE_OFFSET_BITS == 64</command> ile derlendiği durumda bu işlev <command>ftruncate</command> ismiyle bulunur ve eski gerçekleme tamamen LFS'ye uygun olarak değiştirilir.
</para></funcdescr></funcsynopsis></para><para>
Yukarıda bahsedildiği gibi burada <command>ftruncate</command> işlevinin <command>mmap</command> ile birlikte kullanılışına küçük bir örnek vardır::
    </para><para>
<screen>int fd;
void *start;
size_t len;

int
add (off_t at, void *block, size_t size)
{
  if (at + size > len)
    {
      /* Dosyanın boyunu değiştir ve belleğe eşle.  */
      size_t ps = sysconf (_SC_PAGESIZE);
      size_t ns = (at + size + ps - 1) &amp; ~(ps - 1);
      void *np;
      if (ftruncate (fd, ns) &lt; 0)
        return -1;
      np = mmap (NULL, ns, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
      if (np == MAP_FAILED)
        return -1;
      start = np;
      len = ns;
    }
  memcpy ((char *) start + at, block, size);
  return 0;
}
</screen></para><para>
<command>add</command> işlevi dosyada keyfi bir konuma bir bellek bloğunu yazar. Eğer dosyanın mevcut uzunluğu yetersizse dosya uzatılır. Uzatmanın sayfa sayısına yuvarlandığına dikkat edin. Bu <command>mmap</command>'in bir gereksinimidir. Yazılım gerçek boyutu daima izler ve işlem bittiğinde son bir <command>ftruncate</command> çağrısıyla dosyanın gerçek boyunu belirler.
    </para></sect1></chapter>
<chapter xml:id="glibc-Making-Special-Files">
  <title>Özel Dosyaların Oluşturulması</title>
  <titleabbrev>Özel dosyalar (aygıt dosyaları) nasıl oluşturulur?</titleabbrev>
  <para>
<indexterm scope="glibc-cp"><primary>dosyalar</primary><secondary>özel dosyalar</secondary><tertiary>oluşturulması</tertiary></indexterm>
<indexterm scope="glibc-cp"><primary>özel dosyalar</primary></indexterm>
<command>mknod</command> işlevi aygıt dosyaları gibi özel dosyaları oluşturmakta kullanılan bir ilkeldir. GNU kütüphanesi bu işlevi BSD uyumluluğu adına içerir.
   </para><para>
<command>mknod</command> işlevi <filename>sys/stat.h</filename> başlık dosyasında bildirilmiştir.
<indexterm scope="glibc-pg"><primary>sys/stat.h</primary></indexterm>
   </para><para xml:id="glibc-mknod">
<indexterm scope="glibc-fn"><primary>mknod</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>mknod</command></funcdef>
<paramdef>(const char *<varname>dosyaismi</varname>,
 int         <varname>kip</varname>,
 int         <varname>aygıt</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>mknod</command> işlevi ismi <varname>dosyaismi</varname> ile belirtilen özel dosyayı oluşturur. <varname>kip</varname> argümanı ile özel dosyalarla ilgili çeşitli bitleri içeren kip belirtilir. Örneğin karakter aygıtı dosyaları için <command>S_IFCHR</command> veya blok aygıtı dosyaları için <command>S_IFBLK</command>. Bkz. <xref linkend="glibc-Testing-File-Type"/>.
   </para><para>
<varname>aygıt</varname> argümanı ile dosyanın hangi aygıt ile ilişkilendirileceği belirtilir. En doğru yorumu, oluşturulan özel dosyanın çeşidine bağlıdır.
   </para><para>
İşlev başarılı olduğunda <command>0</command>, aksi takdirde <command>-1</command> ile döner. <link linkend="glibc-File-Name-Errors">Dosya ismi hatalarına</link> ek olarak aşağıdaki <command>errno</command> hata durumları bu işlev için tanımlanmıştır:
   </para><para><variablelist><varlistentry>
   <term><literal>EPERM</literal></term><listitem><para>
İşlevi çağıran süreç ayrıcalıklı değil. Sadece ayrıcalıklı kullanıcı özel dosyaları oluşturabilir.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>ENOSPC</literal></term><listitem><para>
Yeni dosyayı içerecek dizin ya da dosya sistemi dolu ve genişletilemiyor.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>EROFS</literal></term><listitem><para>
Yeni dosyayı içerecek dizin salt-okunur bağlı bir dosya sistemi üzerinde.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>EEXIST</literal></term><listitem><para>
Zaten <varname>dosyaismi</varname> isminde bir dosya var.  Bu dosyayı değiştirmek istiyorsanız önce eskisini silmelisiniz.
      </para></listitem></varlistentry></variablelist>
</para></funcdescr></funcsynopsis></para></chapter>
<chapter xml:id="glibc-Temporary-Files">
  <title>Geçici Dosyalar</title>
  <titleabbrev>Geçici dosyaların isimlendirilmesi ve oluşturulması.</titleabbrev>
  <para>
Yazılımınızda bir geçici dosya kullanmanız gerekiyorsa, onu açmak için  <command>tmpfile</command> işlevini ya da geçici dosyaya bir isim vermek ve onu sonradan <command>fopen</command> ile açmak istiyorsanız <command>tmpnam</command> (daha iyisi: <command>tmpnam_r</command>) işlevini kullanabilirsiniz.
   </para><para>
<command>tempnam</command> işlevi <command>tmpnam</command> gibidir, ancak geçici dosyaların gideceği dizini belirtebilirsiniz, bunun dışında dosya isimlendirmesi aynı yöntemle yapılır. Çok evreli yazılımlar açısından <command>tempnam</command> işlevinin evresel olması ama <command>tmpnam</command> işlevinin bir durağan tampona gösterici döndürmesiyle evresel olmaması önemli bir farktır.
   </para><para>
Bu oluşumlar <filename>stdio.h</filename> balık dosyasında bildirilmiştir.
<indexterm scope="glibc-pg"><primary>stdio.h</primary></indexterm>
   </para><para xml:id="glibc-tmpfile">
<indexterm scope="glibc-fn"><primary>tmpfile</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>FILE *<command>tmpfile</command></funcdef>
<paramdef>(void)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev,  <command>&quot;wb+&quot;</command> kipinde (güncelleme kipi) <command>fopen</command> çağrısı ile açılmış gibi bir geçici ikilik dosya oluşturur. Bu dosya kapatıldığında ya da yazılım sonlandığında dosya özdevinimli olarak silinir. (Bazı diğer ISO C sistemlerinde eğer yazılım anormal şekilde sonlanırsa dosya silinmeyebilir.)
   </para><para>
Bu işlev evreseldir.
   </para><para>
Kaynakların 32 bitlik bir sistemde <command>_FILE_OFFSET_BITS == 64</command> ile derlendiği durumda bu işlev aslında <command>tmpfile64</command> işlevidir, yani LFS arayüzü eski arayüzün yerine geçer.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-tmpfile64">
<indexterm scope="glibc-fn"><primary>tmpfile64</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>FILE *<command>tmpfile64</command></funcdef>
<paramdef>(void)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev <command>tmpfile</command> işlevine benzer, ancak dönen akım 32 bitlik makinelerde 2^31 bayttan daha büyük dosyalar için kullanılabilir.
   </para><para>
Dönüş türünün hala <command>FILE *</command> olduğunu, LFS arayüzüne özel bir <command>FILE</command> türü olmadığına lütfen dikkat edin.
   </para><para>
32 bitlik bir sistemde, kaynakların <command>_FILE_OFFSET_BITS == 64</command> ile derlendiği durumda bu işlev <command>tmpfile</command> ismiyle bulunur ve eski gerçekleme tamamen LFS'ye uygun olarak değiştirilir.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-tmpnam">
<indexterm scope="glibc-fn"><primary>tmpnam</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>char *<command>tmpnam</command></funcdef>
<paramdef>(char *<varname>sonuç</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev herhangi bir mevcut dosyaya ait olmayan bir geçerli dosya ismi oluşturur ve bunu döndürür. Eğer <varname>sonuç</varname> argümanı bir boş gösterici ise dönüş değeri bir dahili durağan dizgeye bir gösterici olup, işlevin daha sonraki çağrıları ile üzerine yazılabilir, dolayısıyla bu durumda işlev evresel olmayacaktır. Aksi takdirde, <varname>sonuç</varname> argümanı en az <command>L_tmpnam</command> karakterlik bir diziye gösterici olmalıdır. Bu durumda sonuç bu diziye yazılacak ve işlev evresel olacaktır.
   </para><para>
Önceden oluşturulmuş dosyaları silmeden defalarca <command>tmpnam</command> çağrısı yaparsanız işlevin başarısız olma olasılığı vardır. Bu, geçici dosya isimlerine ayrılan uzunluğun sınırlı olması nedeniyle işlevin sadece sonlu sayıda farklı isme imkan vermesindendir. Eğer işlev başarısız olursa bir boş gösterici döndürür.
   </para><para>
<warning><para>Dosya isminin oluşturulması sırasında, başka bir süreç daha <command>tmpnam</command> kullanarak aynı isimde bir dosya oluşturursa, bu bir güvenlik açığına yol açabilir. Gerçekleme tahmini zor isimler üretir, fakat yine de dosyayı açarken <command>O_EXCL</command> seçeneğini kullanmalısınız. Bu sorunla karşılaşmamak için en iyi yöntem <command>tmpfile</command> veya <command>mkstemp</command> kullanmaktır.</para></warning>
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-tmpnam_r">
<indexterm scope="glibc-fn"><primary>tmpnam_r</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>char *<command>tmpnam_r</command></funcdef>
<paramdef>(char *<varname>sonuç</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev, eğer <varname>sonuç</varname> bir boş gösterici ise boş gösterici döndürmesi dışında <command>tmpnam</command> işlevininin hemen hemen aynısıdır.
   </para><para>
<command>tmpnam</command> işlevinin evresel olmayan kullanımına karşı bir önlem içermesiyle bu işlevin evresel olması garanti edilmiştir.
   </para><para>
<warning><para>Bu işlev de <command>tmpnam</command> işlevinin oluşturabildiği güvenlik açığı sorunundan muzdariptir.</para></warning>
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-L_tmpnam">
<indexterm scope="glibc-vr"><primary>L_tmpnam</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>int <command>L_tmpnam</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu makronun değeri <command>tmpnam</command> işlevi ile üretilen dosya ismini tutacak yeterli büyüklükteki dizge için en küçük uzunluğu veren bir tamsayı sabit ifadesidir.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-TMP_MAX">
<indexterm scope="glibc-vr"><primary>TMP_MAX</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>int <command>TMP_MAX</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
<command>TMP_MAX</command> makrosunun değeri <command>tmpnam</command> ile oluşturulabilecek geçici dosya isimlerinin sayısının alt sınırıdır. <command>tmpnam</command> işlevini, çok fazla geçici dosyaya sahip olduğunuzu belirterek başarısız olmadan en azından bu kadar defa çağırabilirsiniz.
   </para><para>
GNU kütüphanesi ile çok büyük sayıda geçici dosya ismi oluşturabilirsiniz. Eğer bu isimlerle gerçekten dosya oluşturmaya çalışırsanız daha isimler tükenmeden disk üzerindeki yeriniz tükenebilir. Diğer sistemlerde sabit ve daha az sayıda geçici dosya ismi oluşturulabilir ve bu sınır asla <command>25</command>'i aşmaz.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-tempnam">
<indexterm scope="glibc-fn"><primary>tempnam</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>char *<command>tempnam</command></funcdef>
<paramdef>(const char *<varname>dizin</varname>,
 const char *<varname>önek</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev tamamen eşsiz bir geçici dosya ismi oluşturur. Eğer <varname>önek</varname> bir boş gösterici değilse, bu dizgenin ilk beş karakteri dosya isminde önek olarak kullanılır. İşlevin dönüş değeri <command>malloc</command> ile ayrılmış bir dizgedir. Dolayısıyla bu alanla işiniz bittiğinde, artık kullanmayacaksanız <command>free</command> ile serbest bırakmalısınız.
   </para><para>
Dönen dizge özdevimli olarak ayrıldığından bu işlev evreseldir.
   </para><para>
Geçici dosya isminin dizin öneki aşağıdaki listedeki maddeler sırayla uygulanarak saptanır. Dizin mevcut ve yazılabilir olmalıdır.
   </para><para><itemizedlist><listitem><para>
Eğer tanımlıysa, <command>TMPDIR</command> ortam değişkeni. Güvenlik kaygılarıyla bu sadece yazılım SUID ya da SGID etkin değilse uygulanır.
     </para></listitem><listitem><para>
Bir boş gösterici değilse, <varname>dizin</varname> argümanı.
     </para></listitem><listitem><para>
<command>P_tmpdir</command> makrosunun değeri.
     </para></listitem><listitem><para>
<command>/tmp</command> dizini.
     </para></listitem></itemizedlist></para><para>
Bu işlev SVID uyumluluğu için tanımlanmıştır.
   </para><para>
<warning><para>Dosya isminin oluşturulması sırasında, başka bir süreç daha <command>tmpnam</command> kullanarak aynı isimde bir dosya oluşturursa, bu bir güvenlik açığına yol açabilir. Gerçekleme tahmini zor isimler üretir, fakat yine de dosyayı açarken <command>O_EXCL</command> seçeneğini kullanmalısınız. Bu sorunla karşılaşmamak için en iyi yöntem <command>tmpfile</command> veya <command>mkstemp</command> kullanmaktır.</para></warning>
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-P_tmpdir">
<indexterm scope="glibc-cp"><primary><literal>TMPDIR</literal> ortam değişkeni</primary></indexterm>
<indexterm scope="glibc-vr"><primary>P_tmpdir</primary></indexterm>
<funcsynopsis><funcprototype role="SVID makrosu">
<funcdef>char *<command>P_tmpdir</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu makro geçici dosyalar için öntanımlı dizin ismidir.
</para></funcdescr></funcsynopsis></para><para>
Daha eski Unix sistemleri burya kadar bahsedilen işlevlere sahip değildi. Bunların yerine <command>mktemp</command> ve <command>mkstemp</command> işlevleri kullanılırdı.  Bu işlevlerin her ikisi de belirttiğiniz bir dosya ismi şablon dizgesini değiştirerek çalışır. Bu dizgenin son altı karakteri <literal>XXXXXX</literal> olmalıdır.  Bu altı <literal>X</literal> dizgenin eşsiz olmasını sağlamak üzere altı karakterle değiştirilir. Kullanılan şablon dizgesi şuna benzer:
    </para><para>
<literallayout indent="0">
    /tmp/<varname>önek</varname>XXXXXX
</literallayout>
   </para><para>
Burada <varname>önek</varname> yazılım tarafından belirlenen eşsiz bir dizgedir.
   </para><para>
<note><para><command>mktemp</command> ve <command>mkstemp</command> şablon dizgesini değiştirdiklerinde dolayı, dizgeyi bir sabit olarak aktarmamalısınız. Dizge sabitler normalde salt-okunur saklama alanına sahiptir. Bu bakımdan <command>mktemp</command> veya <command>mkstemp</command> dizge sabitini değiştirmeye çalışırsa yazılımınız çökebilir.</para></note>
</para><para>
Bu işlevler <filename>stdlib.h</filename> başlık dosyasında bildirilmiştir.
<indexterm role="pg"><primary>stdlib.h</primary></indexterm>
</para><para xml:id="glibc-mktemp">
<indexterm scope="glibc-fn"><primary>mktemp</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>char *<command>mktemp</command></funcdef>
<paramdef>(char *<varname>şablon</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>mktemp</command> işlevi, yukarıda açıklandığı gibi <varname>şablon</varname> dizgesini değiştirerek eşsiz bir dosya ismi üretir. İşlev başarılı olduğunda değiştirilen <varname>şablon</varname> ile döner. Eğer işlev eşsiz bir isim bulamazsa <varname>şablon</varname>'u boş dizge haline getirip döner. Eğer <varname>şablon</varname>'un son altı karakteri <literal>XXXXXX</literal> değilse işlev bir boş gösterici döndürür.
   </para><para>
<warning><para>Dosya isminin oluşturulması sırasında, başka bir süreç daha <command>mktemp</command> kullanarak aynı isimde bir dosya oluşturursa, bu bir güvenlik açığına yol açabilir. Gerçekleme tahmini zor isimler üretir, fakat yine de dosyayı açarken <command>O_EXCL</command> seçeneğini kullanmalısınız. Bu sorunla karşılaşmamak için en iyi yöntem <command>mkstemp</command> kullanmaktır.</para></warning>
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-mkstemp">
<indexterm scope="glibc-fn"><primary>mkstemp</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>mkstemp</command></funcdef>
<paramdef>(char *<varname>şablon</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>mkstemp</command> işlevi <command>mktemp</command>'in yaptığı gibi bir eşsiz dosya ismi oluşturur, fakat ayrıca dosyayı sizin için <command>open</command> (<xref linkend="glibc-Opening-and-Closing-Files"/>) ile açar.  İşlev başarılı olursa, <varname>şablon</varname>  dizgesini yerinde değiştirir ve dosyayı okuma ve yazma için açarak bir dosya tanıtıcı ile döner. Eğer işlev bir eşsiz dosya ismi oluşturamazsa, <command>-1</command> ile döner. Eğer <varname>şablon</varname> dizgesi <literal>XXXXXX</literal> ile bitmiyorsa, işlev <command>-1</command> ile döner ve  <varname>şablon</varname> dizgesini değiştirmez.
   </para><para>
Dosya <command>0600</command> kipi ile açılır. Eğer dosyaya diğer kullanıcılarında erişebilmesi isteniyorsa bu kip ayrıca değiştirilmelidir.
      </para><para>
<command>mktemp</command>'in aksine, <command>mkstemp</command> işlevi bir geçici dosya oluşturmaya çalışan başka yazılımlarla çatışmadan eşsiz bir dosya oluşturmayı garanti eder. Bu, <command>open</command> işlevinin <command>O_EXCL</command> seçeneği ile kullanmasından dolayıdır (bu seçenek sayesinde, dosyayı oluşturmak isterseniz ve böyle bir dosya mevcutsa bir hata alırsınız).
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-mkdtemp">
<indexterm scope="glibc-fn"><primary>mkdtemp</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>char *<command>mkdtemp</command></funcdef>
<paramdef>(char *<varname>şablon</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>mkdtemp</command> işlevi, ismi eşsiz bir dizin oluşturur. Başarılı olursa dizinin ismini <varname>şablon</varname>'a yazar ve <varname>şablon</varname> ile döner. <command>mktemp</command> ve <command>mkstemp</command> gibi <varname>şablon</varname> dizgesi <literal>XXXXXX</literal> ile bitmelidir.
   </para><para>
Eğer <command>mkdtemp</command> bir eşsiz isimli dizin oluşturamazsa, boş gösterici ile döner ve <varname>errno</varname> değişkenine ilgili hata durumını atar. Eğer <varname>şablon</varname> dizgesi <literal>XXXXXX</literal> ile bitmiyorsa, <command>mkdtemp</command> işlevi <command>NULL</command> ile döner ve <varname>şablon</varname>'u değiştirmez.  Bu durumda <varname>errno</varname> değişkenine <command>EINVAL</command> atanır.
   </para><para>
Dizin <command>0700</command> kipiyle oluşturulur.
</para></funcdescr></funcsynopsis></para><para>
<command>mkdtemp</command> işlevi bir geçici dizin oluşturmaya çalışan başka yazılımlarla çatışmadan eşsiz bir dizin oluşturmayı garanti eder. Bu, <command>open</command> işlevini <command>O_EXCL</command> seçeneği ile kullanmasından dolayıdır. Bkz. <xref linkend="glibc-Creating-Directories"/>.
   </para><para>
<command>mkdtemp</command> işlevi OpenBSD'den gelir.
   </para>
 </chapter>
</part>


