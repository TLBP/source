<?xml version="1.0" encoding="UTF-8"?>

<!-- ********************************************************************
     $Id: ch12.xml,v 1.2 2002/12/20 22:29:48 nilgun Exp $
******************************************************************** -->
<part xml:id="glibc-I-O-on-Streams">
  <title>Akımlar Üzerinde Giriş/Çıkış</title>
  <titleabbrev>Yüksek seviyeli, taşınabilir G/Ç oluşumları.</titleabbrev>
  <partintro><para>
Bu oylumda akımları oluşturmak ve üzerlerinde giriş ve çıkış işlemleri yapmak için kullanılan işlevler anlatılmıştır. <xref linkend="glibc-I-O-Overview"/> oylumunda değinildiği gibi, bir akım bir dosya, aygıt ya da sürece bir iletişim kanalı sağlayan yüksek seviyeli ve  tamamen soyut bir kavramdır.
  </para></partintro>
  <chapter xml:id="glibc-Streams">
    <title>Akımlar (Streams)</title>
    <titleabbrev>Bir akımı ifade eden veri türleri hakkında.</titleabbrev>
    <para>
Tarihsel sebeplerle, bir akımı ifade eden C veri yapısının türü &quot;stream&quot; değil <command>FILE</command>'dır. Kütüphane işlevlerinin çoğu <command>FILE*</command> türü nesnelerle ilgilendiğinden kimi zaman <wordasword>dosya göstericisi</wordasword> deyimi "akım" anlamında kullanılmıştır. Bu, birçok C kitabında terminoloji bakımından talihsiz sayılabilecek karışıklıklara yol açmıştır. Bu kılavuzda "dosya" ve "akım" terimleri teknik duyarlılıkla ve dikkatle kullanılmıştır.
<indexterm scope="glibc-cp"><primary>dosyalar</primary><secondary>dosya göstericisi</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>dosyalar</primary><secondary>akımlar</secondary></indexterm>
<indexterm scope="glibc-pg"><primary>stdio.h</primary></indexterm>
<command>FILE</command> türü <filename>stdio.h</filename> başlık dosyasında bildirilmiştir.
    </para><para xml:id="glibc-FILE">
<indexterm scope="glibc-tp"><primary>FILE</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü">
<funcdef><command>FILE</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Akım nesneleri için kullanılan veri türüdür. Bir <command>FILE</command> türünden nesne, ilişkilendirildiği dosyayla yapılan bağlantı hakkında dosya konum belirteci ve tamponlama bilgisi gibi şeyleri içeren dahili durum bilgisinin tamamını tutar. Her akım ayrıca <command>ferror</command> ve <command>feof</command> işlevleri ile sınanabilen hata ve dosyasonu durum belirteçlerine de sahiptir. Bkz.  <xref linkend="glibc-EOF-and-Errors"/>.
      </para></funcdescr></funcsynopsis>
    </para><para>
<command>FILE</command> türünden nesneler dahili olarak giriş/çıkış kütüphanesi işlevleri tarafından ayrılır ve yönetilir. <command>FILE</command> türünden kendi nesnenizi oluşturmaya çalışmayın. Bunu yaparsanız bu nesnelerin kendileri ile değil sadece göstericileri (<command>FILE *</command> değerleri) ile çalışabilirsiniz. Bu nedenle kütüphaneyi kullanmalısınız.
    </para>
  </chapter>
  <chapter xml:id="glibc-Standard-Streams">
    <title>Standart Akımlar</title>
    <titleabbrev>Standart girdi ve çıktı aygıtlarına akımlar sizin için oluşturulur.</titleabbrev>
    <para>
<indexterm scope="glibc-cp"><primary>standart akımlar</primary></indexterm>
<indexterm scope="glibc-cp"><primary>akımlar</primary><secondary>standart</secondary></indexterm>
Yazılımınızda, <command>main</command> işlevi çağrıldığı anda üç tane önceden tanımlanmış ve kullanıma hazır akıma sahip olur. Bunlar süreç için oluşturulmuş "standart" giriş ve çıkış kanallarıdır.
    </para><para>
Bu akımlar <filename>stdio.h</filename> başlık dosyasında bildirilmiştir.
<indexterm scope="glibc-pg"><primary>stdio.h</primary></indexterm>
    </para><para xml:id="glibc-stdin">
<dicterm><english>stdin</english><turkish>standart girdi</turkish></dicterm>
<dicterm><english>stdout</english><turkish>standart çıktı</turkish></dicterm>
<indexterm scope="glibc-vr"><primary>stdin</primary></indexterm>
<indexterm scope="glibc-cp"><primary>standart girdi</primary></indexterm>
<indexterm scope="glibc-cp"><primary>akımlar</primary><secondary>standart girdi</secondary></indexterm>
<funcsynopsis><funcprototype role="değişken">
<funcdef>FILE *<command>stdin</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Yazılım için normal giriş kaynağı olan <wordasword>standart girdi</wordasword> akımıdır.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-stdout">
<indexterm scope="glibc-vr"><primary>stdout</primary></indexterm>
<indexterm scope="glibc-cp"><primary>standart çıktı</primary></indexterm>
<indexterm scope="glibc-cp"><primary>akımlar</primary><secondary>standart çıktı</secondary></indexterm>
<funcsynopsis><funcprototype role="değişken">
<funcdef>FILE *<command>stdout</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Yazılımın normal çıktısı için kullanılan <wordasword>standart çıktı</wordasword> akımıdır.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-stderr">
<indexterm scope="glibc-vr"><primary>stderr</primary></indexterm>
<indexterm scope="glibc-cp"><primary>standart hata</primary></indexterm>
<indexterm scope="glibc-cp"><primary>akımlar</primary><secondary>standart hata</secondary></indexterm>
<funcsynopsis><funcprototype role="değişken">
<funcdef>FILE *<command>stderr</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Yazılım tarafından hata iletileri ve tanı amaçlı kullanılan <wordasword>standart hata</wordasword> akımıdır.
      </para></funcdescr></funcsynopsis>
    </para><para>
GNU sisteminde kabuk tarafından sağlanan boruhattı ve yönlendirme oluşumlarını kullanarak bu akımlara uygun süreçleri ve dosyaları belirtebilirsiniz. (Kabuklarda bu oluşumları gerçekleştirmekte kullanılan ilkeller <xref linkend="glibc-File-System-Interface"/> bölümünde açıklanmıştır.) Diğer işletim sistemlerinin çoğu benzer mekanizmaları sağlar ancak kullanımı ile ilgili ayrıntılar değişiklik gösterir.
    </para><para>
GNU C kütüphanesinde <command>stdin</command>, <command>stdout</command> ve <command>stderr</command> normal değişkenlerdir ve diğer değişkenler gibi onlara da değer atanabilir. Örneğin, bir dosyayı standart çıktıya yönlendirmek isterseniz şöyle yapmalısınız:
    </para><para>
<screen>
fclose (stdout);
stdout = fopen (&quot;standart-cikti-dosyasi&quot;, &quot;w&quot;);
</screen></para><para>
<note><para>Diğer sistemlerde <command>stdin</command>,  <command>stdout</command> ve <command>stderr</command>  normal yoldan birşeyler atayamayacağınız  makrolardır. Ancak <command>freopen</command> işlevini onların kapatılması ve yeniden açılması etkilerini elde etmek için kullanabilirsiniz. Bkz. <xref linkend="glibc-Opening-Streams"/>.</para></note>
    </para><para>
Üç akım; <command>stdin</command>, <command>stdout</command> ve <command>stderr</command> sürecin başlangıcında yönlenimsiz değildir (Bkz. <xref linkend="glibc-Streams-and-I18N"/>).
   </para></chapter>
  <chapter xml:id="glibc-Opening-Streams">
    <title>Akımların Açılması</title>
    <titleabbrev>Bir dosyayla konuşmak için akım nasıl oluşturulur.</titleabbrev>
    <para>
<indexterm scope="glibc-cp"><primary>akımlar</primary><secondary>açılması</secondary></indexterm>
Bir dosyanın <command>fopen</command> işlevi ile açılması bir yeni akım ve bu akım ile dosya arasında bir bağlantı oluşturur. Bu bir yeni dosya oluşturulmasına sebep olabilir.
    </para><para>
<indexterm scope="glibc-pg"><primary>stdio.h</primary></indexterm>
Bu kısımda açıklanan herşey <filename>stdio.h</filename> başlık dosyasında  bildirilmiştir.
    </para><para xml:id="glibc-fopen">
<indexterm scope="glibc-fn"><primary>fopen</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>FILE *<command>fopen</command></funcdef>
<paramdef>(const char *<varname>dosyaismi</varname>,
 const char *<varname>açıştürü</varname>)</paramdef>
</funcprototype><funcdescr><para>
<varname>dosyaismi</varname> dosyasına G/Ç için bir akım açar ve bu akıma bir gösterici ile döner.
      </para><para>
<varname>açıştürü</varname> argümanı dosyanın nasıl açılacağını ve sonuçlanan akımın özniteliklerini belirtmekte kullanılan bir dizgedir. Aşağıdaki dizgelerden biri ile başlamalıdır:
      </para><para>
        <variablelist><varlistentry><term><literal>r</literal></term>
          <listitem><para>Mevcut bir dosyayı salt-okunur olarak açar.</para></listitem>
        </varlistentry><varlistentry><term><command>w</command></term>
          <listitem><para>
Dosyayı sadece yazmak için açar. Dosya zaten varsa içeriği silinir. Aksi takdirde yeni bir dosya oluşturulur.
          </para></listitem>
        </varlistentry><varlistentry><term><command>a</command></term>
          <listitem><para>
Bir dosyayı sadece sonuna yazmak için açar. Dosya zaten varsa, içeriği değiştirilmez ve akıma yapılan çıktı dosyanın sonuna eklenir. Aksi takdirde bir yeni, boş dosya oluşturulur.
          </para></listitem>
        </varlistentry><varlistentry><term><command>r+</command></term>
          <listitem><para>
Bir dosyayı oku-yaz olarak açar. Dosyanın içeriği değiştirilmez ve konumlayıcı dosyanın başına yerleştirilir.
          </para></listitem>
        </varlistentry><varlistentry><term><command>w+</command></term>
          <listitem><para>
Bir dosyayı oku-yaz olarak açar. Dosya zaten varsa içeriği silinir. Aksi takdirde yeni bir dosya oluşturulur.
          </para></listitem>
        </varlistentry><varlistentry><term><command>a+</command></term>
          <listitem><para>
Dosyayı hem okumak hem de eklemek için açar ya da oluşturur. Dosya zaten varsa içeriği değiştirilmez. Aksi takdirde yeni bir dosya oluşturulur. Dosya konumlayıcı okumak için dosyanın başına konumlansa da çıktı daima dosyanın sonuna eklenir.
          </para></listitem>
        </varlistentry></variablelist>
      </para></funcdescr></funcsynopsis>
    </para><para>
Gördüğünüz gibi, <command>+</command> işareti bir akımın hem girdi hem de çıktı yapabilmesini ister. ISO standardına göre böyle bir akımı kullanırken <command>fflush</command> çağrısı (Bkz. <xref linkend="glibc-Stream-Buffering"/>) yapmalı ya da okumadan yazmaya veya yazmadan okumaya geçerken <command>fseek</command> (Bkz. <xref linkend="glibc-File-Positioning"/>) gibi bir dosya konumlama işlevine çağrı yapmalısınız. Aksi takdirde, dahili tamponlar olması gerektiği gibi boşaltılamaz. GNU C kütüphanesi için böyle bir sınırlama yoktur; bir akım üzerinde okuma ve yazma işlemlerini istediğiniz sırada yapabilirsiniz.
    </para><para>
Bunlardan sonra çağrı için bayrakları belirtmek için ek karakterler kullanılabilir. Daima önce kipi (<command>r</command>, <command>w+</command>, vs.) yerleştirin; bu tüm sistemler tarafından anlaşılacağı garantili olan tek parçadır.
    </para><para>
GNU C kütüphanesi <varname>açıştürü</varname> argümanında kullanmak için bir ek karakter tanımlar: <command>x</command> karakteri yeni bir dosya oluşturmaya zorlar -- eğer <varname>dosyaismi</varname> diye bir dosya varsa, <command>fopen</command> onu açmak yerine başarısız olur. <command>x</command> kullanırsanız bir mevcut dosyanın bilmeden üzerine yazmamayı garantilemiş olursunuz. Bu, <command>open</command> işlevinin <option>O_EXCL</option> seçeneğine eşdeğerdir (Bkz. <xref linkend="glibc-Opening-and-Closing-Files"/>).
    </para><para>
<varname>açıştürü</varname> argümanındaki <command>b</command> karakteri bir standart anlama sahiptir; bir metin akımı yerine bir ikilik akım isteğinde bulunur.  Fakat POSIX sistemlerinde (GNU dahil) bu bir fark oluşturmaz. <command>+</command> ve <command>b</command> birlikte belirtilirse, herhangi bir sırada yazılabilirler. Bkz. <xref linkend="glibc-Binary-Streams"/>.
    </para><para>
<indexterm scope="glibc-cp"><primary>akım yönlenimi</primary></indexterm>
<indexterm scope="glibc-cp"><primary>akımlar</primary><secondary>yönlenim</secondary></indexterm>
<varname>açıştürü</varname> argümanı <command>,ccs=</command><varname>DİZGE</varname> içeriyorsa, buradaki <varname>DİZGE</varname> bir kodlu karakter kümesinin ismi olarak alınır ve <command>fopen</command> akımı geniş-yönlenimli olarak imler, yani <varname>DİZGE</varname> karakter kümesi ile ilgili dönüşümlere uygun dönüşüm işlevleri yerleştirilir. Başka bir akım dahili olarak yönlenimsiz açılır ve yönlenime ilk dosya işleminde karar verilir. Eğer ilk işlem bir geniş karakter işlemiyse, akım sadece geniş yönlenimli olarak imlenmez ayrıca yerelin kodlu karakter kümesine dönüşüm işlevleri yüklenir. Bu artık bu noktadan sonra yerelin seçildiği <command>LC_CTYPE</command> kategorisi değiştirilse bile değişmeyecektir.
    </para><para>
<varname>açıştürü</varname> argümanında başka karakterler varsa bunlar yoksayılır. Bunlar diğer sistemler için anlamlı olabilir.
    </para><para>
Açma işlemi başarısız olursa <command>fopen</command> bir boş gösterici ile döner.
    </para><para>
Kaynak dosyalar bir 32 bitlik makinede <command>_FILE_OFFSET_BITS == 64</command> ile derlendiğinde LFS arayüzü eski arayüzle şeffaf olarak değiştirildiğinden bu işlev için <command>fopen64</command> tanımı kullanılır.
    </para><para>
Aynı dosya için aynı anda açılmış çok sayıda akıma (ya da dosya tanıtıcı) sahip olabilirsiniz. Sadece girdi yapacaksanız bu doğru dürüst çalışır ama çıktı akımları da varsa dikkatli olmalısınız. Bkz. <xref  linkend="glibc-Stream-Descriptor-Precautions"/>. Bu durum, akımlar tek süreç tarafından da açılsa, çok sayıda süreç tarafından da açılsa hemen hemen aynıdır. Aynı anda erişimden kaçınmak için dosya kilitleme oluşumları yararlı olabilir. Bkz. <xref linkend="glibc-File-Locks"/>.
    </para><para xml:id="glibc-fopen64">
<indexterm scope="glibc-fn"><primary>fopen64</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>FILE *<command>fopen64</command></funcdef>
<paramdef>(const char *<varname>dosyaismi</varname>,
 const char *<varname>açıştürü</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev <command>fopen</command> işlevine benzer ama, akıma  <command>open64</command> işlevi kullanılarak açılan dosya için bir  gösterici döner. Diğer yandan bu akım 32 bitlik makineler üzerinde  <literal>2</literal><superscript>31</superscript> bayttan büyük dosyalar üzerinde bile çalışır.
      </para><para>
<note><para>Dönen gösterici yine <command>FILE *</command> türünde olacaktır. Çünkü LFS arayüzü için özel bir <command>FILE</command> türü yoktur.</para></note>
      </para><para>
Kaynak dosyaları bir 32 bitlik makine üzerinde <command>_FILE_OFFSET_BITS == 64</command> ile derlenirse bu işlev <command>fopen</command> ismi ile kullanılabilir yani eski arayüz ile şeffaf olarak yer değiştirilir.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-FOPEN_MAX">
<indexterm scope="glibc-vr"><primary>FOPEN_MAX</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>int <command>FOPEN_MAX</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu makronun değeri gerçeklemenin garanti edebildiği aynı anda açılabilecek
 en büyük akım sayısına karşılık olan bir sabit ifadesidir. Bu değerden
 daha fazla sayıda akım açılabilir ama garantili değildir. Bu sabitin değeri
 üç standart akımı da (<command>stdin</command>, <command>stdout</command>
 ve <command>stderr</command>) içererek en azı sekizdir.
      </para><para>
POSIX.1 sistemlerde  bu değer <command>OPEN_MAX</command> parametresi
 tarafından belirlenir. Bkz. <xref linkend="glibc-General-Limits"/>.
      </para><para>
BSD ve GNU'da <command>RLIMIT_NOFILE</command> özkaynak sınırı tarafından belirlenir. Bkz. <xref linkend="glibc-Limits-on-Resources"/>.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-freopen">
<indexterm scope="glibc-fn"><primary>freopen</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>FILE *<command>freopen</command></funcdef>
<paramdef>(const char *<varname>dosyaismi</varname>,
 const char *<varname>açıştürü</varname>,
 FILE       *<varname>akım</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev, <command>fclose</command> ve <command>fopen</command> işlevlerinin bir birleşimi gibidir. Önce <varname>akım</varname> ile gösterilen akımı kapatır, kapatırken oluşan hatalar yoksayılır. (Hataların yoksayılmasından dolayı, akıma bir çıktılama yaptıysanız bir çıktı akımı üzerinde <command>freopen</command> kullanmamalısınız.) Sonra da <varname>dosyaismi</varname> isimli dosyayı <command>fopen</command> işlevindeki türlerden biri olarak <varname>açıştürü</varname> kipinde açar ve aynı <varname>akım</varname> nesnesi ile ilişkilendirir.
      </para><para>
İşlem başarısız olursa bir boş gösterici döner; aksi takdirde  <command>freopen</command> işlevi <varname>akım</varname> ile döner.
      </para><para>
<command>freopen</command> işlevi geleneksel olarak <command>stdin</command> gibi standart akımlara kendi seçtiğiniz bir dosyayla bağlanmak için kullanılır. Bu, bir standart akıma belirli amaçlar için doğrudan yazarak kullanmak için yararlıdır. GNU C kütüphanesinde standart akımları basitçe kapatabilir ve yeni birini <command>fopen</command> ile açabilirsiniz. Ancak bazı sistemler bu tarz çalışmayı desteklemez, bu nedenle <command>freopen</command> kullanımı daha taşınabilir olacaktır.
      </para><para>
Kaynak dosyalar bir 32 bitlik makinede <command>_FILE_OFFSET_BITS == 64</command> ile derlendiğinde LFS arayüzü eski arayüzle şeffaf olarak değiştirildiğinden bu işlev için <command>freopen64</command> tanımı kullanılır.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-freopen64">
<indexterm scope="glibc-fn"><primary>freopen64</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>FILE *<command>freopen64</command></funcdef>
<paramdef>(const char *<varname>dosyaismi</varname>,
 const char *<varname>açıştürü</varname>,
 FILE       *<varname>akım</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev <command>freopen</command> işlevine benzer. Tek fark, bu akım 32 bitlik makineler üzerinde <literal>2</literal><superscript>31</superscript> bayttan büyük dosyalar üzerinde bile çalışır. <varname>akım</varname> tarafından gösterilen akımın kipi bu işlev için önemli olmadığından, akımın <command>fopen64</command> veya <command>freopen64</command> kullanarak açılmış olmaması gerekir.
      </para><para>
Kaynak dosyaları bir 32 bitlik makine üzerinde <command>_FILE_OFFSET_BITS == 64</command> ile derlenirse bu işlev <command>freopen</command> ismi ile kullanılabilir yani eski arayüz ile şeffaf olarak yer değiştirilir.
      </para></funcdescr></funcsynopsis>
    </para><para>
Bazı durumlarda, verilen akımın okuma ve yazma için kullanılabilir olup olmadığını bilmek kullanışlıdır. Bu bilgi normalde kullanılabilir değildir ve ayrıca hatırlanması gerekir. Solaris, akım tanımlayıcıdan bu bilgiyi alacak bir kaç işlev içerir ve bu işlevler GNU C kütüphanesinde de vardır.
    </para><para xml:id="glibc__freadable">
<indexterm scope="glibc-fn"><primary sortas="freadable">__freadable</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>__freadable</command></funcdef>
<paramdef>(FILE *<varname>akım</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>__freadable</command> işlevi <varname>akım</varname>’ın okuma iznine sahip olup olmadığını saptar. Okuma izni varsa sıfırdan farklı bir değer ile döner. Sadece yazma izni olan akımlarda işlev sıfır ile döner.
      </para><para>
Bu işlev <filename>stdio_ext.h</filename> başlık dosyasında bildirilmiştir.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc__fwritable">
<indexterm scope="glibc-fn"><primary sortas="fwritable">__fwritable</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>__fwritable</command></funcdef>
<paramdef>(FILE *<varname>akım</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>__fwritable</command> işlevi <varname>akım</varname>’ın yazma iznine sahip olup olmadığını saptar. Yazma izni varsa sıfırdan farklı bir değer ile döner. Sadece okuma izni olan akımlarda işlev sıfır ile döner.
      </para><para>
Bu işlev <filename>stdio_ext.h</filename> başlık dosyasında bildirilmiştir.
      </para></funcdescr></funcsynopsis>
    </para><para>
Biraz daha farklı çeşitte sorunlar için iki işlev daha vardır. Bunlar biraz daha hassas bilgiler sağlar.
    </para><para xml:id="glibc__freading">
<indexterm scope="glibc-fn"><primary sortas="freading">__freading</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>__freading</command></funcdef>
<paramdef>(FILE *<varname>akım</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>__freading</command> işlevi <varname>akım</varname>’dan son olarak okuma işlemi yapılmışsa ya da akım salt okunur olarak açılmışsa sıfırdan farklı bir değerle döner, aksi takdirde sıfır ile döner. Bir akımın okuma ve yazma için açılıp açılmadığının saptanması işlemi son yazma sırasında kullanılmışsa içerik, tampon ve diğer başka şeyler arasında sonuçların yazılmasına izin verilir.
      </para><para>
Bu işlev <filename>stdio_ext.h</filename> başlık dosyasında bildirilmiştir.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc__fwriting">
<indexterm scope="glibc-fn"><primary sortas="fwriting">__fwriting</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>__fwriting</command></funcdef>
<paramdef>(FILE *<varname>akım</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>__fwriting</command> işlevi <varname>akım</varname>’a son olarak yazma işlemi yapılmışsa ya da akım salt yazılır olarak açılmışsa sıfırdan farklı bir değerle döner, aksi takdirde sıfır ile döner.
      </para><para>
Bu işlev <filename>stdio_ext.h</filename> başlık dosyasında bildirilmiştir.
      </para></funcdescr></funcsynopsis>
    </para>
  </chapter>

  <chapter xml:id="glibc-Closing-Streams">
    <title>Akımların Kapatılması</title>
    <titleabbrev>İşiniz bittiğinde akımı kapatın.</titleabbrev>
    <para>
<indexterm scope="glibc-cp"><primary>akımlar</primary><secondary>kapatılması</secondary></indexterm>
Bir akım <command>fclose</command> ile kapatıldığında akım ile dosya arasındaki bağlantı kesilir. Bir akım kapatıldıktan sonra artık onun üzerinde bir işlem yapılamaz.
    </para><para xml:id="glibc-fclose">
<indexterm scope="glibc-fn"><primary>fclose</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>fclose</command></funcdef>
<paramdef>(FILE *<varname>akım</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev <varname>akım</varname>’ın kapatılmasına ve dosya ile bağlantısının kesilmesine sebep olur. Tamponlanmış çıktılar yazılır, tamponlanmış girdiler ise iptal edilir. Dosya başarıyla kapatılırsa işlev sıfırla döner, aksi takdirde <command>EOF</command> ile döner.
      </para><para>
Bir çıkış akımını kapatmak için <command>fclose</command> çağrısı yapıldığında hataların saptanması önem kazanır, çünkü gerçek hayatta hergün aldığınız hatalar bu sırada oluşabilir. Örneğin, <command>fclose</command> tampondaki çıktıyı yazarken disk doluverirse bir hata alabilirsiniz. Hatta tamponun boş olduğunu bildiğiniz durumda bile eğer NFS kullanıyorsanız dosya kapatılırken hata alabilirsiniz.
      </para><para>
Bu işlev <filename>stdio.h</filename> başlık dosyasında bildirilmiştir.
      </para></funcdescr></funcsynopsis>
    </para><para>
GNU C kütüphanesinde tüm akımları kapatmak için ayrı bir işlev vardır.
    </para><para xml:id="glibc-fcloseall">
<indexterm scope="glibc-fn"><primary>fcloseall</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>fcloseall</command></funcdef>
<paramdef>(void)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev sürecin açık olan tüm akımlarını kapatır ve bunlarla bağlantılı dosyalara olan bağlantılar kesilir. Tüm tamponlanmış veri yazılır, tamponlanmış girdiler ise iptal edilir. İşlev, tüm dosyalar hatasız kapatılırsa sıfır ile, hata oluşursa <command>EOF</command> ile döner.
      </para><para>
Bu işlev çok özel durumlarda örneğin bir hata oluşup sürecin sonlandırılması  gerektiğinde kullanılmalıdır. Normalde her akım sorunlarının tanımlanabilmesi için ayrı ayrı kapatılmalıdır. Ayrıca bu işlev <link linkend="glibc-Standard-Streams">standart akımları</link> da kapatacağından sorunlar çıkarır.
      </para><para>
Bu işlev <filename>stdio.h</filename> başlık dosyasında bildirilmiştir.
      </para></funcdescr></funcsynopsis>
    </para><para>
Yazılımınız <command>main</command> işlevinden normal çıkış yaparsa ya da bir <link linkend="glibc-Normal-Termination"><command>exit</command></link> çağrısı ile çıkarsa tüm açık akımlar özdevinimli olarak düzgünce kapatılır. Yazılımınız başka bir şekilde (örneğin bir  <link linkend="glibc-Aborting-a-Program"><command>abort</command></link> çağrısı ile ya da bir <link linkend="glibc-Signal-Handling">ölümcül sinyal</link> ile) sonlandırılırsa açık akımlar düzgünce kapatılamayabilir. Tamponlanmış çıktılar dosyalara yazılamayabilir ve dosyalar eksik ya da boş kalabilir. Akımların tamponlanması ile ilgili daha ayrıntılı bilgi <xref linkend="glibc-Stream-Buffering"/> bölümünde bulunabilir.
    </para>
  </chapter>

  <chapter xml:id="glibc-Streams-and-Threads">
    <title>Akımlar ve Evreler</title>
    <titleabbrev>Evreli yazılımlarda akımlarla ilgili işlemler.</titleabbrev>
    <para>
<indexterm scope="glibc-cp"><primary>evreler</primary></indexterm>
<indexterm scope="glibc-cp"><primary>çok evreli yazılımlar</primary></indexterm>
Akımlar çok evreli yazılımlarda tek evreli yazılımlardaki gibi kullanılır. Ancak yazılımcı olası karışıklıkların farkında olmalıdır. Birçok akım işlevinin tasarımı ve gerçeklenmesi çok evreli yazılım geliştirmeyle ilgili ek gereksinimlerden oldukça etkileneceğinden yazılımın birinin evreleri asla kullanamayabileceğininin bilinmesi ayrıca önemlidir.
    </para><para>
POSIX standardı öntanımlı olarak akım işlemlerinin atomik olmasını gerektirir. Örneğin iki akım işleminin iki evre halinde aynı anda bir akıma uygulanması işlemler sırayla yapılıyormuş gibi yapılmasına sebep olacaktır. Okuma ve yazma sırasında uygulanan tampon işlemleri aynı akımı kullanan diğerlerinden korunur. Bu, her akımın yapılacak bir çalışma öncesi (dolaylı olarak) elde edilen bir dahili kilitleme nesnesine sahip olması ile sağlanır.
    </para><para>
Ancak bunun yeterli olmadığı ya da bunun istenmediği durumlar da vardır. Eğer yazılım birden fazla akım işlevi çağrısının atomik olarak yapılmasını gerektiriyorsa dolaylı kilitleme mekanizması yetersiz kalır. Bir yazılımın üretmek istediği bir satırı çeşitli işlev çağrılarıyla oluşturması buna bir örnek olarak verilebilir. Atomlara ayırma işi tüm işlev çağrıları üzerinde değil, işlevlerin kendileri tarafından kendi işlemlerini atomlarına ayırarak yapılmalıdır. Bunun olabilmesi için de akım kilitleme işleminin yazılım kodunda yapılması gerekir.
    </para><para xml:id="glibc-flockfile">
<indexterm scope="glibc-fn"><primary>flockfile</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>void <command>flockfile</command></funcdef>
<paramdef>(FILE *<varname>akım</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>flockfile</command> işlevi <varname>akım</varname> ile ilişkili dahili kilitleme nesnesi elde etmekte kullanılır. İşlev, başka hiçbir evrenin doğrudan <command>flockfile</command>/<command>ftrylockfile</command> üzerinden veya dolaylı olarak bir akım işlevi çağrısı üzerinden akımı kilitleyememesini sağlar. Kilit elde edilinceye kadar evre engellenecektir. <command>funlockfile</command> işlevine yapılacak bir doğrudan çağrı kilit nesnesini serbest bırakacaktır.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-ftrylockfile">
<indexterm scope="glibc-fn"><primary>ftrylockfile</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>ftrylockfile</command></funcdef>
<paramdef>(FILE *<varname>akım</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>ftrylockfile</command> işlevi <command>flockfile</command>  işlevi gibi <varname>akım</varname> ile ilişkili dahili kilitleme nesnesi elde etmeye çalışır. <command>flockfile</command> işevinin aksine bu işlev kilit kullanılabilir değilse engelleme yapmaz. Kilit başarıyla elde edilirse işlev sıfırla döner, aksi takdirde akımı başka bir evre kilitlemiştir.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-funlockfile">
<indexterm scope="glibc-fn"><primary>funlockfile</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>void <command>funlockfile</command></funcdef>
<paramdef>(FILE *<varname>akım</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>funlockfile</command> işlevi <varname>akım</varname>’ın kilitleme nesnesini serbest bırakır. Akım bir <command>flockfile</command> çağrısı ya da başarılı bir <command>ftrylockfile</command> çağrısı tarafından önceden kilitlenmiş olmalıdır. Akım işlemleri tarafından uygulanan dolaylı kilitlemeler sayılmaz. <command>funlockfile</command> işlevi bir hata durumu döndürmez ve o anki evre tarafından kilitlenmemiş bir akım için yapılan bir çağrının davranışı tanımsızdır.
      </para></funcdescr></funcsynopsis>
    </para><para>
Yukarıdaki işlevlerin nasıl kullanılacağını gösteren ve çok evreli yazılımlarda  bile kullanılabilecek aşağıdaki örnekte bir çıktı satırı atomik olarak üretilmektedir (evet, aynı iş tek bir <command>fprintf</command> çağrısı ile yapılabilirdi ama kimi zaman bu mümkün olmaz):
   </para><para>
<screen>
FILE *fp;
{
   …
   flockfile (fp);
   fputs (&quot;This is test number &quot;, fp);
   fprintf (fp, &quot;%d\n&quot;, test);
   funlockfile (fp)
}
</screen></para><para>
Doğrudan kilitleme olmaksızın <command>fputs</command> çağrısı döndükten  sonra ve <command>fprintf</command> işlevinin <literal>number</literal>  sözcüğünden sonra numarayı basmasından önce başka bir evrenin <varname>fp</varname> akımını kullanması mümkün olabilir.
    </para><para>
Bu açıklamalardan sonra akımlardaki kilitleme nesnelerinin basit karşılıklı red nesneleri (mutexes - mutual exclusion objects) olmadığı anlaşılmış olmalıdır. Aynı akımın aynı evre içinde iki kere kilitlenmesi mümkün olduğundan kilitleme nesneleri, ardışık karşılıklı red nesnelerine eşdeğer olmalıdır. Bu karşılıklı red nesneleri sahibinin izini takibeder ve kendi sayısınca kilit elde eder. Akımdaki kilitleme nesnelerini tamamen serbest bırakmak için aynı evreler tarafından aynı sayıda <command>funlockfile</command> çağrısı gereklidir. Örneğin:
    </para><para>
<screen>
void
foo (FILE *fp)
{
  ftrylockfile (fp);
  fputs (&quot;in foo\n&quot;, fp);
  /* Bu çok yanlış!!!  */
  funlockfile (fp);
}
</screen></para><para>
Burada önemli olan, <command>funlockfile</command> işlevinin "sadece" <command>ftrylockfile</command> işlevinin akımı başarıyla kilitlediği anlaşıldığı takdirde kullanılabileceğidir. Örnekte <command>ftrylockfile</command> işlevinin sonucu gözardı edildiğinden yapılan işlem yanlıştır. <command>flockfile</command> kullanılsaydı bu yanlış olmayacaktı. Yukarıdaki gibi bir kodun sonucunda ya <command>funlockfile</command> o anki evre tarafından kilitlenmeyen bir akımı serbest bırakmaya çalışacak ya da akımı vakitsiz olarak serbest bırakacaktır. Kod aşağıdaki gibi olmalıydı:
   </para><para>
<screen>
void
foo (FILE *fp)
{
  if (ftrylockfile (fp) == 0)
    {
      fputs (&quot;in foo\n&quot;, fp);
      funlockfile (fp);
    }
}
</screen></para><para>
Kilitlemenin niçin gerekli olduğu konusunu hallettiğimize göre artık kilitlemenin ne zaman istenmediği ve bu durumda ne yapılabileceği üzerinde duralım. Kilitleme işlemleri (doğrudan ya da dolaylı) bedavaya gelmez. Bir kilit alınmasa bile maliyeti sıfır değildir. Uygulanan işlemler çok işlemcili ortamlardaki güvenli bellek işlemlerini gerektirir. Böyle sistemlerdeki çok sayıda yerel önbellekle bu oldukça maliyetlidir.
 Yani, en iyisi çok gerekli değilse (bir akımın iki veya daha fazla evre  tarafından kullanılamayacağı bağlamlarda) kilitlemeden tamamen kaçınmaktır. Bu çoğu zaman uygulama kodu için ugulanabilir; çok sayıda bağlam içinde kullanılabilen kütüphane kodu için bir bağlam kilitleme kullanımı ve tutuculuk anlamında öntanımlı olacaktır.
    </para><para>
Kilitlemeden kaçınmada iki temel mekanizma vardır. İlki akım işlemlerinin <command>_unlocked</command> sonekli biçimlerini kullanmaktır. POSIX standardı bunların pek azını tanımlar ve GNU kütüphanesi birkaç tane daha ekler. İşlevlerin bu biçimleri isimlerine <command>_unlocked</command> soneki getirilen işlevlerle benzer davranışı gösterir; tek farkla, akımları kilitlemezler. Bu işlevler potansiyel olarak çok daha hızlı olduğundan daha çok tercih edilirler. Bu sadece kilitleme işlemlerinden kendilerini korumalarından dolayı değildir. Daha önemli olarak,
 <command>putc</command> ve <command>getc</command> işlevleri çok basittir ve geleneksel olarak (evrelere girişten önce) tampon boş değilse çok hızlı olan makrolar halinde gerçeklenmişlerdir. Kilitleme gereksinimlerinin eklenmesiyle bu işlevlerin kodu çok büyüdüğünden artık makrolar halinde gerçeklenememektedirler. Ancak bu makrolar aynı işlevsellikle yeni isimler altında (<command>putc_unlocked</command> ve
 <command>getc_unlocked</command>) hala kullanılabilmektedir. Hızlarındaki bu dev farktan dolayı <command>_unlocked</command> sonekli işlevlerin kullanılması kilitleme gerekli olduğu durumlarda bile tercih edilmesine sebep olmaktadır. Kilitleme ile birlikte kullanıma bir örnek:
   </para><para>
<screen>
void
foo (FILE *fp, char *buf)
{
  flockfile (fp);
  while (*buf != '/')
    putc_unlocked (*buf++, fp);
  funlockfile (fp);
}
</screen></para><para>
Bu örnekte <command>putc</command> işlevi kullanılsaydı ve doğrudan kilitleme olmasaydı, <command>putc</command> işlevi döngü sonlanana kadar her çağrıda bir olmak üzere kilidi defalarca elde edecekti. Yukarıdaki örnek <command>putc_unlocked</command> makrosu akım tamponunun kilitleme olmaksızın doğrudan değiştirilmesi anlamında kullanılarak yazılmıştır.
    </para><para>
Kilitlemeden kaçınmak için ikinci yol Solaris’te bulunan ve GNU C kütüphanesinde de kullanılabilir olan standart dışı bir işlevi kullanmaktır.
    </para><para xml:id="glibc__fsetlocking">
<indexterm scope="glibc-fn"><primary sortas="fsetlocking">__fsetlocking</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>__fsetlocking</command></funcdef>
<paramdef>(FILE *<varname>akım</varname>,
 int   <varname>tür</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>__fsetlocking</command> işlevi, akım işlemlerinin  <varname>akım</varname>’ın kilitleme nesnesini dolaylı elde edip etmeyeceğini seçmekte kullanılır. Öntanımlı olarak kilit dolaylı elde edilir ancak bu işlev kullanılarak kilidin alınması iptal edilebilir ya da tekrar yerleştirilebilir. <varname>tür</varname> parametresi olarak kullanılabilecek üç değer vardır:
      </para><para>
        <variablelist><varlistentry><term>
<literal>FSETLOCKING_INTERNAL</literal></term><listitem><para> <varname>akım</varname> öntanımlı dahili kilitlemeyi hemen kullanmaya başlayacaktır. <command>_unlocked</command> sonekli biçim hariç her akım işlemi akımı dolaylı olarak kilitleyecektir.
        </para></listitem></varlistentry><varlistentry>
          <term><literal>FSETLOCKING_BYCALLER</literal></term><listitem><para>
<command>__fsetlocking</command> işlevi döndükten sonra akım kilitleme için kullanıcı sorumlu olur. Durum <command>FSETLOCKING_INTERNAL</command> ile öntanımlı duruma döndürülünceye kadar bunu dolaylı olarak yapacak bir akım işlemi yoktur.
        </para></listitem></varlistentry><varlistentry>
          <term><literal>FSETLOCKING_QUERY</literal></term><listitem><para>
<command>__fsetlocking</command> işlevi sadece akımın o anki kilitleme durumunu sorgular. Dönen değer duruma bağlı olarak ya <command>FSETLOCKING_INTERNAL</command> ya da <command>FSETLOCKING_BYCALLER</command> olacaktır.
        </para></listitem></varlistentry></variablelist>
      </para><para>
<command>__fsetlocking</command> işlevinin dönüş değeri akımın çağrı öncesi durumunu belirtmek üzere ya <command>FSETLOCKING_INTERNAL</command> ya da <command>FSETLOCKING_BYCALLER</command> olacaktır.
      </para><para>
İşlev ve <varname>tür</varname> parametresinin değerleri <filename>stdio_ext.h</filename> başlık dosyasında bildirilmiştir.
      </para></funcdescr></funcsynopsis>
    </para><para>
Bu işlev özellikle yazılım kodu  <command>_unlocked</command> işlevleri hakkında yeterli bilgiye sahip olunmadan yazılmışsa (ya da yazılımcı onları çok delice kullanmışsa) yararlıdır.
    </para>
  </chapter>
  <chapter xml:id="glibc-Streams-and-I18N">
    <title>Akımlar ve Uluslararasılaştırma</title>
    <titleabbrev>Uluslararasılaştırılmış uygulamalarda akımlar.</titleabbrev>
    <para>
ISO C90 geniş karakter kümeleriyle çalışmak için <command>wchar_t</command> isimli yeni bir veri türü tanımladı. <command>wchar_t</command> dizgelerini doğrudan doğruya çıktılayacak bir olasılıktı eksik olan. Biri onları çok baytlı dizgelere <command>mbstowcs</command> kullanarak çevirdi (hala bir <command>mbsrtowcs</command> yok) ve sonra normal akım işlevlerini kullandı. Bu yapılabilir olurken anlamsız olmayan dönüşümler uyguladığından ve yazılımın karmaşıklığını ve  boyutlarını fazlaca arttırdığından çok hantal oldu.
    </para><para>
Unix standardı daha erken olarak (XPG4.2'de sanırım) <command>printf</command> ve <command>scanf</command> işlevleri için iki ek biçim belirteci tanımladı. Tek geniş karakterin okunması ve basılması <command>%C</command> belirteci ile geniş karakterli dizgelerinki ise <command>%S</command> belirteci kullanılarak mümkün hale getirildi. Bu belirteçler geniş karakter türü kullanmak dışında tıpkı <command>%c</command> ve <command>%s</command> belirteçleri gibi çalışıyordu. Ancak geniş karakterler ve dizgeler kullanılmadan önce çok baytlı dizgelere ya da tersine çevriliyordu.
    </para><para>
Bu bir başlangıçtı ama hala yeterince iyi değildi. <command>printf</command>  ve <command>scanf</command> kullanımı hep tercih edilen birşey değildi. Daha küçük ve daha hızlı diğer işlevler geniş karakterlerle çalışamıyordu. İkincisi, <command>printf</command> ve <command>scanf</command> işlevleri için geniş karakterleri oluşturulmasını sağlayacak bir biçim dizgesine sahip değildi. Biçim dizgesi temel olmayan karakterlere sahipse sonuçta biçim dizgesi üretilmiş gibi olurdu.
    </para><para>
<indexterm scope="glibc-cp"><primary>C++ akımları</primary></indexterm>
<indexterm scope="glibc-cp"><primary>akımlar</primary><secondary>C++</secondary></indexterm>
ISO C 90'ın 1. düzeltmesinde sorunu çözümlemek için yeni bir işlevler kümesi eklendi. Akım işlevlerinin çoğu bir karakter veya dizge yerine bir geniş karakter veya bir geniş karakterli dizge alır hale getirildi. Yeni işlevler aynı akımlar (<command>stdout</command> gibi) üzerinde işlem yapmaktadır. Bu normal ve geniş karakterler G/Ç işlemleri için ayrı akım işlevleri kullanılan C++ çalışma anı kütüphanesindeki modelden farklıdır.
    </para><para>
<indexterm scope="glibc-cp"><primary>akımlar</primary><secondary>yönlenim</secondary></indexterm>
Aynı akımın hem normal hem de geniş karakterlerle kullanılabilmesi bir sınırlama ile mümkün olur: Bir akım ya normal karakterleri kullanır ya da geniş karakterleri, ikisi birden olmaz. Bir kere karar verildikten sonra dönüşü yoktur. Sadece <command>freopen</command> ya da <command>freopen64</command> işlevleri yönlenimi sıfırlayabilir. Yönlenime üç yolla karar verilebilir:
    </para><para>
      <itemizedlist><listitem><para>
Normak karakter işlevlerinden biri kullanılmışsa (<command>fread</command> ve <command>fwrite</command> işlevleri dahil) akım "geniş yönlenimli değildir" olarak imlenir.
      </para></listitem><listitem><para>
Geniş karakter işlevlerinden biri kullanılmışsa akım "geniş yönlenimli" olarak imlenir.
      </para></listitem><listitem><para>
Yönlenimi belirlemek için <command>fwide</command> işlevi kullanılır.
      </para></listitem></itemizedlist>
      </para><para>
Geniş ve geniş olmayan işlemlerin aynı akım üzerinde asla karıştırılmaması gerekliliği önemlidir. Bunun için tasarlanmış bir tanılama yolu yoktur. Uygulama basitçe tuhaflaşır hatta daha basitçe çökebilir. <command>fwide</command> işlevi bundan kaçınmanıza yardımcı olabilir.
    </para><para xml:id="glibc-fwide">
<indexterm scope="glibc-fn"><primary>fwide</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>fwide</command></funcdef>
<paramdef>(FILE *<varname>akım</varname>,
 int   <varname>kip</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>fwide</command> işlevi <varname>akım</varname> yönleniminin belirlenmesinde ve sorgulanmasında kullanılabilir. <varname>kip</varname> parametresi bir pozitif değer belirtiyorsa  akım geniş yönlenimli, negatif bir değer belirtiyorsa dar yönlenimlidir. <command>fwide</command> ile önceki yönlenimi değiştirmek mümkün değildir. <varname>akım</varname> zaten yönlenimli ise çağrı hiçbir şey yapmaz.
      </para><para>
<varname>kip</varname> sıfırsa, o anki yönlenim durumu sorgulanır ve hiçbir değişiklik yapılmaz.
      </para><para>
<command>fwide</command> işlevi yönlenimin durumuna bağlı olarak, dar, hiçbiri veya geniş yönlenimli olmasına göre sırayla bir negatif değer, sıfır veya bir pozitif değerle döner.
      </para><para>
Bu işlev ISO C09'ın 1. düzeltmesinde tanımlanmış ve  <filename>wchar.h</filename> başlık dosyasında bildirilmiştir.
      </para></funcdescr></funcsynopsis>
    </para><para>
Genel olarak bir akımın yönlenimini mümkün olduğu kadar erken belirlemek daha iyidir. Bu özellikle <command>stdin</command>, <command>stdout</command> ve <command>stderr</command> standart akımlarında ortaya çıkacak bazı sürprizlerden sizi koruyabilir. Bu akımlardan birini kullanan bazı kütüphane işlevleri bazı durumlarda akımın yönlenimini uygulamanın kalanında, sonlanma ve hata üretilmesi
 dışında farklı bir yolla kullanır. Akımların yönleniminin yanlış kullanımında hata üretilmediğini unutmayın. Bir akımın oluşturulduktan sonra yönlenimsiz bırakılması normalde, sadece akımları farklı bağlamlarda kullanmak üzere oluşturan kütüphane işlevleri için gereklidir.
    </para><para>
Akımların kullanıldığı ve bu akımarın farklı bağlamlarda kullanılabildiği bir kodu yazarken bir akımı kullanmadan önce akımın yönlenimini (kütüphane arayüzünün kuralları belli bir yönlenimi talep etmedikçe) sorgulamak önemlidir. Aşağıdaki küçük işlev bunu örneklemektedir:
   </para><para>
<screen>
void
print_f (FILE *fp)
{
  if (fwide (fp, 0) > 0)
    /* Dönen pozitif değer geniş yönlenimi gösterir.  */
    fputwc (L'f', fp);
  else
    fputc ('f', fp);
}
</screen></para><para>
Burada <command>print_f</command> işlevi, akım önceden yönlenimsiz olsa da akımın yönlenimine karar vermektedir (yukarıdaki bilgileri iyi özümlediyseniz olumsuz birşey olmayacağını görürsünüz).
    </para><para>
<command>wchar_t</command> değerleri için kullanılan karakter kodlaması belirtilmemiştir ve yazılımcı onun hakkında herhangi bir kabulde bulunmamalıdır. <command>wchar_t</command> değerlerinin G/Ç işlemleri için bunun anlamı, bu değerlerin akıma doğrudan doğruya yazılmasının imkansızlığıdır. Bu ISO C yerel modelinde izlenen yol da değildir. Baytların alttaki ortamdan okunması ve oraya yazılması yerine yapılacak olan önce <command>wchar_t</command> için gerçekleme tarafından seçilen dahili yerele dönüşümdür. Harici karakter kodlaması o anki yerelin <literal>LC_CTYPE</literal> kategorisi tarafından ya da <command>fopen</command>, <command>fopen64</command>, <command>freopen</command> veya <command>freopen64</command> işlevlerine verilen kip belirtiminin parçası olan <command>ccs</command> değeri tarafından dönüşümün ne zaman ve nasıl olacağı belirsizdir ve kullanıcıya görünür değildir.
    </para><para>
Bir akım yönlenimsiz durumda oluşturulduğunda bu noktada onunla ilişkili bir dönüşüm yapılmaz. Kullanılacak dönüşüm akım yönlenimlendiği sırada <command>LC_CTYPE</command> kategorisi tarafından saptanmış olacaktır. Dikkatli olunmazsa, yerel çalışma anında değiştirilirse sürprizli durumlarla karşılaşabilirsiniz. Bu da, akımın yönleniminin mümkün olduğunca erken belirlenmesinin önemini gösteren iyi bir sebeptir. Şüphesiz bu işlemi bir <command>fwide</command> çağrısı ile yapmalısınız.
    </para>
  </chapter>
  <chapter xml:id="glibc-Simple-Output">
    <title>Karakterlerin ve Satırların Basit Çıktılanması</title>
    <titleabbrev>Karakterlerin ve satırların biçimlenmeden çıktılanması.</titleabbrev>
    <para>
<indexterm scope="glibc-cp"><primary>akımlar</primary><secondary>yazma</secondary><tertiary>tek karakter</tertiary></indexterm>
Bu kısımda karakter ve satır yönlenimli çıktılama işlemleri için kullanılan işlevler açıklanmıştır.
    </para><para>
Bu kısımdaki dar yönlenimli akım işlevleri <filename>stdio.h</filename> başlık dosyasında, geniş yönlenimli akım işlevleri ise <filename>wchar.h</filename> başlık dosyasında bildirilmiştir.
<indexterm scope="glibc-pg"><primary>stdio.h</primary></indexterm>
<indexterm scope="glibc-pg"><primary>wchar.h</primary></indexterm>
    </para><para xml:id="glibc-fputc">
<indexterm scope="glibc-fn"><primary>fputc</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>fputc</command></funcdef>
<paramdef>(int   <varname>c</varname>,
 FILE *<varname>akım</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>fputc</command> işlevi <varname>c</varname> karakterini <command>unsigned char</command> türüne çevirir ve onu <varname>akım</varname>’a yazar. Bir hata oluşursa <literal>EOF</literal> döner, aksi takdirde <varname>c</varname> karakteri döner.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-fputwc">
<indexterm scope="glibc-fn"><primary>fputwc</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>wint_t <command>fputwc</command></funcdef>
<paramdef>(wchar_t <varname>wc</varname>,
 FILE   *<varname>akım</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>fputwc</command> işlevi <varname>wc</varname> geniş karakterini <varname>akım</varname>’a yazar. Bir yazma hatası oluşursa <literal>WEOF</literal> döner, aksi takdirde <varname>wc</varname> karakteri döner.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-fputc_unlocked">
<indexterm scope="glibc-fn"><primary>fputc_unlocked</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>fputc_unlocked</command></funcdef>
<paramdef>(int   <varname>c</varname>,
 FILE *<varname>akım</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>fputc_unlocked</command> işlevi akımı dolaylı olarak kilitlememesi dışında <command>fputc</command> işlevine eşdeğerdir.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-fputwc_unlocked">
<indexterm scope="glibc-fn"><primary>fputwc_unlocked</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>wint_t <command>fputwc_unlocked</command></funcdef>
<paramdef>(wint_t <varname>wc</varname>,
 FILE  *<varname>akım</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>fputwc_unlocked</command> işlevi akımı dolaylı olarak kilitlememesi dışında <command>fputwc</command> işlevine eşdeğerdir.
      </para><para>
Bu işlev bir GNU oluşumudur.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-putc">
<indexterm scope="glibc-fn"><primary>putc</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>putc</command></funcdef>
<paramdef>(int   <varname>c</varname>,
 FILE *<varname>akım</varname>)</paramdef>
</funcprototype><funcdescr><para>
Birçok sistemin daha hızlı olması için onu bir makro olarak gerçekleştirmesi dışında tamamen <command>fputc</command> gibidir. Makrolar için genel kurala bir istisna olarak <varname>akım</varname> argümanını bir kereden fazla değerlendirebilmesi ona önem kazandırır. Genellikle <command>putc</command> işlevi tek bir karakterin yazılması için kullanılacak en iyi işlevdir.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-putwc">
<indexterm scope="glibc-fn"><primary>putwc</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>wint_t <command>putwc</command></funcdef>
<paramdef>(wchar_t <varname>wc</varname>,
 FILE   *<varname>akım</varname>)</paramdef>
</funcprototype><funcdescr><para>
Birçok sistemin daha hızlı olması için onu bir makro olarak gerçekleştirmesi dışında tamamen <command>fputwc</command> gibidir. Makrolar için genel kurala bir istisna olarak <varname>akım</varname> argümanını bir kereden fazla değerlendirebilmesi ona önem kazandırır. Genellikle <command>putwc</command> işlevi tek bir geniş karakterin yazılması için kullanılacak en iyi işlevdir.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-putc_unlocked">
<indexterm scope="glibc-fn"><primary>putc_unlocked</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>putc_unlocked</command></funcdef>
<paramdef>(int   <varname>c</varname>,
 FILE *<varname>akım</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>putc_unlocked</command> işlevi akımı dolaylı olarak kilitlememesi dışında <command>putc</command> işlevine eşdeğerdir.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-putwc_unlocked">
<indexterm scope="glibc-fn"><primary>putwc_unlocked</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>wint_t <command>putwc_unlocked</command></funcdef>
<paramdef>(wchar_t <varname>wc</varname>,
 FILE   *<varname>akım</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>putwc_unlocked</command> işlevi akımı dolaylı olarak kilitlememesi dışında <command>putwc</command> işlevine eşdeğerdir.
      </para><para>
Bu işlev bir GNU oluşumudur.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-putchar">
<indexterm scope="glibc-fn"><primary>putchar</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>putchar</command></funcdef>
<paramdef>(int <varname>c</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>putchar</command> işlevi <command>putc</command> işlevinin <varname>akım</varname> argümanına değer olarak <command>stdout</command> belirtilerek çağrılması ile eşdeğerdir. Yani bu işlev bir karakteri doğrudan standart çıktıya basar.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-putwchar">
<indexterm scope="glibc-fn"><primary>putwchar</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>wint_t <command>putwchar</command></funcdef>
<paramdef>(wchar_t <varname>wc</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>putwchar</command> işlevi <command>putwc</command> işlevinin <varname>akım</varname> argümanına değer olarak <command>stdout</command> belirtilerek çağrılması ile eşdeğerdir. Yani bu işlev bir geniş karakteri doğrudan standart çıktıya basar.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-putchar_unlocked">
<indexterm scope="glibc-fn"><primary>putchar_unlocked</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>putchar_unlocked</command></funcdef>
<paramdef>(int <varname>c</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>putchar_unlocked</command> işlevi akımı dolaylı olarak kilitlememesi dışında <command>putchar</command> işlevine eşdeğerdir.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-putwchar_unlocked">
<indexterm scope="glibc-fn"><primary>putwchar_unlocked</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>wint_t <command>putwchar_unlocked</command></funcdef>
<paramdef>(wchar_t <varname>wc</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>putwchar_unlocked</command> işlevi akımı dolaylı olarak kilitlememesi dışında <command>putwchar</command> işlevine eşdeğerdir.
      </para><para>
Bu işlev bir GNU oluşumudur.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-fputs">
<indexterm scope="glibc-fn"><primary>fputs</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>fputs</command></funcdef>
<paramdef>(const char *<varname>s</varname>,
 FILE       *<varname>akım</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>fputs</command> işlevi <varname>s</varname> dizgesini <varname>akım</varname>’a yazar.  Dizgeyi sonlandıran boş karakter yazılmadığı gibi sonuna bir satırsonu karakteri de eklemez. Sadece dizge içindeki karakterleri çıktılar.
      </para><para>
Bir yazma hatası oluşursa işlev <literal>EOF</literal> ile döner, aksi takdirde negatif olmayan bir değerle döner. Örneğin:
      </para><para>
<screen>
fputs (&quot;Burada &quot;, stdout);
fputs (&quot;hava &quot;, stdout);
fputs (&quot;serin\n&quot;, stdout);
</screen></para><para>
kodu <literal>Burada hava serin</literal> dizgesini sonuna bir satırsonu karakteri ekleyerek çıktılar.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-fputws">
<indexterm scope="glibc-fn"><primary>fputws</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>fputws</command></funcdef>
<paramdef>(const wchar_t *<varname>ws</varname>,
 FILE          *<varname>akım</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>fputws</command> işlevi <varname>s</varname> geniş karakterli dizgesini <varname>akım</varname>’a yazar.  Dizgeyi sonlandıran boş karakter yazılmadığı gibi sonuna bir satırsonu karakteri de eklemez. Sadece dizge içindeki karakterleri çıktılar.
      </para><para>
Bir yazma hatası oluşursa işlev <literal>WEOF</literal> ile döner, aksi takdirde negatif olmayan br değerle döner.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-fputs_unlocked">
<indexterm scope="glibc-fn"><primary>fputs_unlocked</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>fputs_unlocked</command></funcdef>
<paramdef>(const char *<varname>s</varname>,
 FILE       *<varname>akım</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>fputs_unlocked</command> işlevi akımı dolaylı olarak kilitlememesi dışında <command>fputs</command> işlevine eşdeğerdir.
      </para><para>
Bu işlev bir GNU oluşumudur.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-fputws_unlocked">
<indexterm scope="glibc-fn"><primary>fputws_unlocked</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>fputws_unlocked</command></funcdef>
<paramdef>(const wchar_t *<varname>ws</varname>,
 FILE          *<varname>akım</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>fputws_unlocked</command> işlevi akımı dolaylı olarak kilitlememesi dışında <command>fputws</command> işlevine eşdeğerdir.
      </para><para>
Bu işlev bir GNU oluşumudur.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-puts">
<indexterm scope="glibc-fn"><primary>puts</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>puts</command></funcdef>
<paramdef>(const char *<varname>s</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>puts</command> işlevi <varname>s</varname> dizgesini sonuna bir satırsonu karakteri ekleyerek standart çıktıya basar. Dizgeyi sonlandıran boş karakter çıktılanmaz. (<command>fputs</command> işlevi bu işlevden farklı olarak dizgenin sonuna satırsonu karakteri eklemez.)
      </para><para>
<command>puts</command> basit iletileri basmak için oldukça kullanışlı bir işlevdir. Örneğin:
      </para><para>
<screen>puts (&quot;Bu bir ileti.&quot;);</screen>
      </para><para>
deyimi sonuna bir satırsonu karakteri ekleyerek <literal>Bu bir ileti.</literal> metnini çıktılar.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-putw">
<indexterm scope="glibc-fn"><primary>putw</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>putw</command></funcdef>
<paramdef>(int   <varname>sözcük</varname>,
 FILE *<varname>akım</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev <varname>sözcük</varname> sözcüğünü (<command>int</command> türündedir) <varname>akım</varname>’a yazar. SVID ile uyumluluk için vardır, ancak bunun yerine <command>fwrite</command> kullanmanız önerilir. Bkz. <xref linkend="glibc-Block-Input-Output"/>.
      </para></funcdescr></funcsynopsis>
    </para>
  </chapter>

  <chapter xml:id="glibc-Character-Input">
    <title>Karakter Girdilerinin Alınması</title>
    <titleabbrev>Biçimlenmemiş karakterlerin ve sözcüklerin girdi olarak alınması.</titleabbrev>
    <para>
<indexterm scope="glibc-cp"><primary>akımlar</primary><secondary>okuma</secondary><tertiary>tek karakter</tertiary></indexterm>
Bu kısımda girdi olarak karakter alan işlevler açıklanmıştır. Bu kısımdaki dar yönlenimli akım işlevleri <filename>stdio.h</filename>  başlık dosyasında, geniş yönlenimli akım işlevleri ise  <filename>wchar.h</filename> başlık dosyasında bildirilmiştir.
<indexterm scope="glibc-pg"><primary>stdio.h</primary></indexterm>
<indexterm scope="glibc-pg"><primary>wchar.h</primary></indexterm>
    </para><para>
Bu işlevler bir karakter girdisinde, dar yönlenimli ise bir <command>int</command> türünden değerle, geniş yönlenimli ise bir <command>wint_t</command> türünden bir değerle ya da <command>EOF</command>/<command>WEOF</command> özel değeri (genellikle -1) ile döner.
    </para><para>
Dar yönlenimli akım işlevleri için, işlev sonucunu bir karakter olarak kullanmayı tasarlıyorsanız bile, bu işlevlerin sonucunun <command>char</command> türü yerine <command>int</command> türünden bir değişkene atanması önemlidir. <command>EOF</command> değerinin <command>char</command> türünden bir değişkene atanması onun bir karakterlik boyuta indirilmesine sebep olur ki bu durumda artık geçerli bir karakterden (<literal>(char) -1</literal>) farkı kalmaz. Öyleyse, <command>getc</command> ve arkadaşlarını daima <command>int</command> türünden bir değişkene atayarak çağırmalı ve dönen değerin <command>EOF</command> olup olmadığına bakmalısınız. Dönen değer <command>EOF</command> değilse  artık onu bir <command>char</command> türünden değişkene bilgi kaybı olmadan atayabilirsiniz.
    </para><para xml:id="glibc-fgetc">
<indexterm scope="glibc-fn"><primary>fgetc</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>fgetc</command></funcdef>
<paramdef>(FILE *<varname>akım</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev <varname>akım</varname>’daki sonraki karakteri bir <command>unsigned char</command> olarak okur ve değerini <command>int</command> türüne dönüştürerek döndürür. Bir dosya sonu durumunda ya da bir hata oluştuğunda hata yerine
 <command>EOF</command> ile döner.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-fgetwc">
<indexterm scope="glibc-fn"><primary>fgetwc</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>wint_t <command>fgetwc</command></funcdef>
<paramdef>(FILE *<varname>akım</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev <varname>akım</varname>’daki sonraki geniş karakteri okur ve değerini döndürür. Bir dosya sonu durumunda ya da bir hata oluştuğunda hata yerine <command>WEOF</command>  ile döner.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-fgetc_unlocked">
<indexterm scope="glibc-fn"><primary>fgetc_unlocked</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>fgetc_unlocked</command></funcdef>
<paramdef>(FILE *<varname>akım</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>fgetc_unlocked</command> işlevi akımı dolaylı olarak kilitlememesi dışında <command>fgetc</command> işlevine eşdeğerdir.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-fgetwc_unlocked">
<indexterm scope="glibc-fn"><primary>fgetwc_unlocked</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>wint_t <command>fgetwc_unlocked</command></funcdef>
<paramdef>(FILE *<varname>akım</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>fgetwc_unlocked</command> işlevi akımı dolaylı olarak kilitlememesi dışında <command>fgetwc</command> işlevine eşdeğerdir.
      </para><para>
Bu işlev bir GNU oluşumudur.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-getc">
<indexterm scope="glibc-fn"><primary>getc</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>getc</command></funcdef>
<paramdef>(FILE *<varname>akım</varname>)</paramdef>
</funcprototype><funcdescr><para>
Birçok sistemin daha hızlı olması için onu bir makro olarak gerçekleştirmesi dışında tamamen <command>fgetc</command> gibidir. Makrolar için genel kurala bir istisna olarak <varname>akım</varname> argümanını bir kereden fazla değerlendirebilmesi ona önem kazandırır. Genellikle <command>getc</command> işlevi tek bir karakterin okunması için kullanılacak en iyi işlevdir.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-getwc">
<indexterm scope="glibc-fn"><primary>getwc</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>wint_t <command>getwc</command></funcdef>
<paramdef>(FILE *<varname>akım</varname>)</paramdef>
</funcprototype><funcdescr><para>
Birçok sistemin daha hızlı olması için onu bir makro olarak gerçekleştirmesi dışında tamamen <command>fgetwc</command> gibidir. Makrolar için genel kurala bir istisna olarak <varname>akım</varname> argümanını bir kereden fazla değerlendirebilmesi ona önem kazandırır. Genellikle <command>getwc</command> işlevi tek bir geniş karakterin okunması için kullanılacak en iyi işlevdir.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-getc_unlocked">
<indexterm scope="glibc-fn"><primary>getc_unlocked</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>getc_unlocked</command></funcdef>
<paramdef>(FILE *<varname>akım</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>getc_unlocked</command> işlevi akımı dolaylı olarak kilitlememesi dışında <command>getc</command> işlevine eşdeğerdir.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-getwc_unlocked">
<indexterm scope="glibc-fn"><primary>getwc_unlocked</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>wint_t <command>getwc_unlocked</command></funcdef>
<paramdef>(FILE *<varname>akım</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>gewtc_unlocked</command> işlevi akımı dolaylı olarak kilitlememesi dışında <command>getwc</command> işlevine eşdeğerdir.
      </para><para>
Bu işlev bir GNU oluşumudur.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-getchar">
<indexterm scope="glibc-fn"><primary>getchar</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>getchar</command></funcdef>
<paramdef>(void)</paramdef>
</funcprototype><funcdescr><para>
<command>getchar</command> işlevi <command>getc</command> işlevinin <varname>akım</varname> argümanına değer olarak <command>stdin</command> belirtilerek çağrılması ile eşdeğerdir. Yani bu işlev bir karakteri doğrudan standart girdiden okur.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-getwchar">
<indexterm scope="glibc-fn"><primary>getwchar</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>wint_t <command>getwchar</command></funcdef>
<paramdef>(void)</paramdef>
</funcprototype><funcdescr><para>
<command>getwchar</command> işlevi <command>getwc</command> işlevinin <varname>akım</varname> argümanına değer olarak <command>stdin</command> belirtilerek çağrılması ile eşdeğerdir. Yani bu işlev bir geniş karakteri doğrudan standart girdiden okur.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-getchar_unlocked">
<indexterm scope="glibc-fn"><primary>getchar_unlocked</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>getchar_unlocked</command></funcdef>
<paramdef>(void)</paramdef>
</funcprototype><funcdescr><para>
<command>getchar_unlocked</command> işlevi akımı dolaylı olarak kilitlememesi dışında <command>getchar</command> işlevine eşdeğerdir.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-getwchar_unlocked">
<indexterm scope="glibc-fn"><primary>getwchar_unlocked</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>wint_t <command>getwchar_unlocked</command></funcdef>
<paramdef>(void)</paramdef>
</funcprototype><funcdescr><para>
<command>getwchar_unlocked</command> işlevi akımı dolaylı olarak kilitlememesi dışında <command>getwchar</command> işlevine eşdeğerdir.
      </para><para>
Bu işlev bir GNU oluşumudur.
      </para></funcdescr></funcsynopsis>
    </para><para>
Aşağıda <command>fgetc</command> kullanarak girdi alan bir işlev örneği vardır. İşlev  <command>fgetc (stdin)</command> yerine <command>getc</command> ya da <command>getchar</command> kullanarak da çalışırdı. Kod ayrıca geniş yönlenimli akım işlevleri için de aynı şekilde çalışırdı.
    </para><para>
<screen>
int
evet_mi_hayir_mi (const char *soru)
{
  fputs (soru, stdout);
  while (1)
    {
      int c, cevap;
      /* Bir boşluk yazarak cevabı sorudan ayıralım. */
      fputc (' ', stdout);
      /* Satırdaki ilk karakteri okuyalım.
         Bu cevap karakteri olmalı ama olmayabilir. */
      c = tolower (fgetc (stdin));
      answer = c;
      /* Satırın kalanını iptal edelim. */
      while (c != '\n' &amp;&amp; c != EOF)
        c = fgetc (stdin);
      /* Yanıt geçerliyse uygun dönüşü yapalım. */
      if (cevap == 'y')
        return 1;
      if (cevap == 'n')
        return 0;
      /* Cevap geçersiz: Geçerli cevabı almaya çalışalım. */
      fputs (&quot;Cevabınız e ya da h olmalı: &quot;, stdout);
    }
}
</screen></para><para xml:id="glibc-getw">
<indexterm scope="glibc-fn"><primary>getw</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>getw</command></funcdef>
<paramdef>(FILE *<varname>akım</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev bir sözcüğü (<command>int</command> türünde) <varname>akım</varname>’dan okur. SVID ile uyumluluk için vardır, ancak bunun yerine <command>fread</command> kullanmanız önerilir. Bkz. <xref linkend="glibc-Block-Input-Output"/>. <command>getc</command> işlevinin tersine herhangi bir <command>int</command> türünden değer geçerli bir sonuç olmalıydı. İşlev bir hata oluştuğunda ya da dosya sonu saptandığında <command>EOF</command> ile döner, ancak -1 değerini bir geçerli sözcükten ayırmak için bir yol yoktur.
      </para></funcdescr></funcsynopsis>
    </para>
  </chapter>
  <chapter xml:id="glibc-Line-Input">
     <title>Satır Yönlenimli Girdi</title>
     <titleabbrev>Bir akımdan bir kaydın ya da bir satırın okunması.</titleabbrev>
     <para>
Birçok yazılım girdiyi satır temelinde yorumladığından bir akımdan bir metin satırını okuyacak işlevlerin de bulunması yararlıdır.
    </para><para>
Standart C bunu yapacak işlevlere sahiptir ama onlar çok güvenilir değildir: Boş karakterler ve hatta uzun satırlar (<command>gets</command> için) onları şaşırtabilir. Bu nedenle GNU kütüphanesi satırları güvenilir bir şekilde kolayca okumak için standart olmayan <command>getline</command> işlevini içerir.
    </para><para>
Diğer bir GNU oluşumu olan <command>getdelim</command> işlevi, <command>getline</command> işlevini genelleştirir. İşlev belirtilmiş bir ayraç karakteriyle ayrılmış kayıtlardan bir kaydı okur.
    </para><para>
Bu işlevlerin tümü <filename>stdio.h</filename> başlık dosyasında bildirilmiştir.
    </para><para xml:id="glibc-getline">
<indexterm scope="glibc-fn"><primary>getline</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>ssize_t <command>getline</command></funcdef>
<paramdef>(char  **<varname>satır-gstr</varname>,
 size_t *<varname>n</varname>,
 FILE   *<varname>akım</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev <varname>akım</varname>’daki bir tam satırı okur, metni satırsonu karakteri ve bir sonlandırıcı boş karakterle bir tampona yazar ve bu tamponun adresini <command>*</command><varname>satır-gstr</varname> içinde saklar.
      </para><para>
<command>getline</command> çağrısından önce, <command>*</command><varname>n</varname> bayt uzunluğundaki <command>malloc</command> ile ayrılmış bir tamponun adresi  <command>*</command><varname>satır-gstr</varname> içine yerleştirilmelidir. Bu tampon yeterli uzunluktaysa, <command>getline</command> okuduğu satırı bu tampona yazar. Aksi takdirde <command>getline</command> işlevi <command>realloc</command> kullanarak tamponu büyütür ve yeni tampon adresini <command>*</command><varname>satır-gstr</varname> argümanı ile ve arttırdığı uzunluğu <command>*</command><varname>n</varname> argümanı ile geri döndürür. Bkz. <xref linkend="glibc-Unconstrained-Allocation"/>.
      </para><para>
<command>*</command><varname>satır-gstr</varname> olarak bir boş gösterici ve <command>*<varname>n</varname></command> için 0 değerini vererek çağrı yaparsanız, <command>getline</command> işlevi <command>malloc</command> işlevini kullanarak tamponu sizin için ayırır.
      </para><para>
Her iki durumda, <command>getline</command> döndüğünde,  <command>*</command><varname>satır-gstr</varname> satırın metnini gösteren  bir <command>char *</command>’dır.
      </para><para>
<command>getline</command> başarılı olduğunda okunan karakterlerin sayısı (satırsonu karakteri ve bir boş karakter dahil) ile döner. Bu değer satırın parçası olan boş karakterleri sonlandırıcı olarak eklenen boş karakterden ayırabilmenizi sağlar.
      </para><para>
Bu işlev bir GNU oluşumudur ve bir akımdan satırları okumak için önerilen bir yoldur. Aynı amaçlı diğer standart işlevler güvenilir değildir.
      </para><para>
Bir hata oluşursa ya da herhangi bir bayt okunmadan dosya sonuna gelinirse <command>getline</command> işlevi <command>-1</command> ile döner.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-getdelim">
<indexterm scope="glibc-fn"><primary>getdelim</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>ssize_t <command>getdelim</command></funcdef>
<paramdef>(char  **<varname>satır-gstr</varname>,
 size_t *<varname>n</varname>,
 int     <varname>ayraç</varname>,
 FILE   *<varname>akım</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev okumayı sonlandıran karakterin belirtilebilmesi dışında <command>getline</command> gibidir. <varname>ayraç</varname> argümanı ile ayraç karakteri belirtilir. İşlev bu karakteri görene kadar ya da bu karakter yoksa dosya sonunu görene kadar metni okur.
      </para><para>
<varname>satır-gstr</varname> içinde saklanan metin ayraç karakterini ve  sonlandırıcı olarak bir boş karakter içerir. <command>getline</command> gibi <command>getdelim</command> işlevi de gerekirse <varname>satır-gstr</varname> tamponunu büyütür.
      </para><para>
<command>getline</command> bir <command>getdelim</command> işlevi ile aşağıdaki gibi gerçeklenebilir:
      </para><para>
<screen>
ssize_t
getline (char **lineptr, size_t *n, FILE *stream)
{
  return getdelim (lineptr, n, '\n', stream);
}
</screen></para><para>
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-fgets">
<indexterm scope="glibc-fn"><primary>fgets</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>char *<command>fgets</command></funcdef>
<paramdef>(char *<varname>s</varname>,
 int   <varname>kar-sayısı</varname>,
 FILE *<varname>akım</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>fgets</command> işlevi <varname>akım</varname>’dan bir satırı satırsonu karakterine kadar bu karakter de dahil olmak üzere okur ve <varname>s</varname> dizgesine sonuna bir boş karakter ekleyerek yerleştirir. <varname>s</varname> dizgesindeki alanı <varname>kar-sayısı</varname> karakterlik olarak belirtebilirsiniz, ancak okunan karakterlerin sayısı <varname>kar-sayısı</varname> - 1 olacaktır. Kalan son yer, dizgenin sonunu gösteren boş karakter için kullanılacaktır.
      </para><para>
<command>fgets</command> çağrısı yaptığınızda sistem zaten dosyanın sonundaysa <varname>s</varname> dizisinin içeriği değiştirilmez ve bir boş gösterici döner. Bir okuma hatası olduğunda da boş gösterici döner. Aksi takdirde dönen değer <varname>s</varname> göstericisidir.
      </para><para>
<warning><para>Girdi verisi bir boş karakter içeriyorsa bunu belirtemezsiniz. Bu nedenle, sadece verinin bir boş karakter içermediğini biliyorsanız <command>fgets</command> işlevini kullanın, yoksa kullanmayın. Kullanıcı tarafından düzenlenmiş dosyaları okumak için <command>fgets</command> kullanmayın, çünkü kullanıcı bir boş karakter girmişse ya onu olması gerektiği gibi okumanız ya da bir hata iletisi basmanız gerekir. Daha iyisi, <command>fgets</command> yerine <command>getline</command> kullanmanızı öneririz.</para></warning>
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-fgetws">
<indexterm scope="glibc-fn"><primary>fgetws</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>wchar_t *<command>fgetws</command></funcdef>
<paramdef>(wchar_t *<varname>ws</varname>,
 int      <varname>kar-sayısı</varname>,
 FILE    *<varname>akım</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>fgetws</command> işlevi <varname>akım</varname>’dan geniş karakterleri satırsonu karakterine kadar bu karakter de dahil olmak üzere okur ve <varname>ws</varname> dizgesine sonuna bir boş karakter ekleyerek yerleştirir. <varname>ws</varname> dizgesindeki alanı <varname>kar-sayısı</varname> karakterlik olarak belirtebilirsiniz, ancak okunan geniş karakterlerin sayısı <varname>kar-sayısı</varname> - 1 olacaktır. Kalan son yer, dizgenin sonunu gösteren boş karakter için kullanılacaktır.
      </para><para>
<command>fgetws</command> çağrısı yaptığınızda sistem zaten dosyanın sonundaysa <varname>ws</varname> dizisinin içeriği değiştirilmez ve bir boş gösterici döner. Bir okuma hatası olduğunda da boş gösterici döner. Aksi takdirde dönen değer <varname>ws</varname> göstericisidir.
      </para><para>
<warning><para>Girdi verisi bir boş karakter içeriyorsa bunu belirtemezsiniz. Bu nedenle, sadece verinin bir boş karakter içermediğini biliyorsanız <command>fgetws</command> işlevini kullanın, yoksa kullanmayın. Kullanıcı tarafından düzenlenmiş dosyaları okumak için <command>fgetws</command> kullanmayın, çünkü kullanıcı bir boş karakter girmişse ya onu olması gerektiği gibi okumanız ya da bir hata iletisi basmanız gerekir.</para></warning>
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-fgets_unlocked">
<indexterm scope="glibc-fn"><primary>fgets_unlocked</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>char *<command>fgets_unlocked</command></funcdef>
<paramdef>(char *<varname>s</varname>,
 int   <varname>kar-sayısı</varname>,
 FILE *<varname>akım</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>fgets_unlocked</command> işlevi akımı dolaylı olarak kilitlememesi dışında <command>fgets</command> işlevine eşdeğerdir.
      </para><para>
Bu işlev bir GNU oluşumudur.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-fgetws_unlocked">
<indexterm scope="glibc-fn"><primary>fgetws_unlocked</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>wchar_t *<command>fgetws_unlocked</command></funcdef>
<paramdef>(wchar_t *<varname>ws</varname>,
 int      <varname>kar-sayısı</varname>,
 FILE    *<varname>akım</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>fgetws_unlocked</command> işlevi akımı dolaylı olarak kilitlememesi dışında <command>fgetws</command> işlevine eşdeğerdir.
      </para><para>
Bu işlev bir GNU oluşumudur.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-gets">
<indexterm scope="glibc-fn"><primary>gets</primary></indexterm>
<funcsynopsis><funcprototype role="önerilmeyen işlev">
<funcdef>char *<command>gets</command></funcdef>
<paramdef>(char *<varname>s</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>gets</command> işlevi standart girdiden bir satırı satırsonu karakterine kadar okur ve <varname>s</varname> dizgesine yerleştirir. Satırsonu karakteri iptal edilir. (İşlev bu davranışı ile  satırsonu karakterini de dizgeye yerleştiren <command>fgets</command>  işlevinden faklıdır.) Bir okuma hatası olduğunda ya da dosya sonu saptandığında boş gösterici döner. Aksi takdirde dönen değer <varname>s</varname> göstericisidir.
      </para><para>
<warning><para><command>gets</command> işlevi <command>çok tehlikelidir</command>. Çünkü <varname>s</varname> dizgesinin taşmasına karşı bir korumaya sahip değildir. GNU kütüphanesi işlevi sadece uyumluluk adına içerir. Bunun yerine daima ya <command>fgets</command> ya da <command>getline</command> işlevini kullanmalısınız. Bunu hatırlatmak için ilintileyici (GNU <command>ld</command> kullanıyorsanız) <command>gets</command> kullanırsanız sizi uyaracaktır.
      </para></warning></para></funcdescr></funcsynopsis>
    </para>
  </chapter>
  <chapter xml:id="glibc-Unreading">
    <title>Okunmamış Yapmak</title>
    <titleabbrev>Girdinin okunmasından sonra akımın girdi okunmamış gibi bırakılması.</titleabbrev>
    <para>
<indexterm scope="glibc-cp"><primary>girdiye öncesinden bakış</primary></indexterm>
<indexterm scope="glibc-cp"><primary>karakterlerin okunmamış yapılması</primary></indexterm>
<indexterm scope="glibc-cp"><primary>girdiyi geri itme</primary></indexterm>
Çözümleyici yazılımlarda akımdaki sonraki karakterin ne olduğuna bakmak ama onu akımdan silmeksizin okumak çoğunlukla kullanışlıdır. Buna girdiye "önceden bakış" denir, çünkü yazılımınız daha sonra okuyacağı girdinin anlık bir görüntüsünü alır.
   </para><para>
Akım G/Ç işlemlerini kullanarak, girdiyi önce akımdan okuyup sonra da okunmamış yaparak (buna girdiyi "geri itme" de denir) girdiye öncesinden bakabilirsiniz. Bir karakterin okunmamış yapılması onu akımdan tekrar okunabilmesi için kullanılabilir yapar. Sonraki bir <command>fgetc</command> çağrısı ya da diğer bir girdi işlevi ile onu akımdan okuyabilirsiniz.
   </para>
    <sect1 xml:id="glibc-Unreading-Idea">
      <title>Okunmamış Yapmak Ne Demek</title>
      <titleabbrev>Okunmamış yapmanın resimli anlatımı.</titleabbrev>
      <para>
Okunmamış yapma işlemi burada resimsel örneklerle açıklanmaya çalışılmıştır. Bir dosyayı okuyan bir akımınız olduğunu ve dosyanın altı karakter içerdiğini varsayalım. Bu harfler <literal>foobar</literal> olsun. İlk üç karakteri okumuş olalım. Durum bunun gibi olacaktır:
      </para><para>
<screen>
f  o  o  b  a  r
         ^
</screen></para><para>
Yani sonraki girdi karakteri <command>b</command> olacaktır.
      </para><para>
<command>b</command>’yi okumak yerine <command>o</command> harfini okunmamış yapalım. Durum şöyle olur:
    </para><para>
<screen>
f  o  o  b  a  r
         |
      o--
      ^
</screen></para><para>
Böylece sonraki girdi karakterleri <command>o</command> ve <command>b</command> olacaktır.
      </para><para>
<command>o</command> harfi yerine <command>9</command> karakterini de okunmamış yapabiliriz. Bu durumu şöyle gösterebiliriz:
    </para><para><screen>
f  o  o  b  a  r
         |
      9--
      ^
</screen></para><para>
Burada sonraki girdi karakterleri <command>9</command> ve <command>b</command> olacaktır.
      </para>
    </sect1>
    <sect1 xml:id="glibc-How-Unread">
      <title>Okunmamış Nasıl Yapılır</title>
      <titleabbrev>Yanıt: <command>ungetc</command> kullanarak.</titleabbrev>
      <para>
Bir karakteri okumamış yapan işlev <command>ungetc</command>'dir, çünkü <command>getc</command> işlevinin tersini yapar.
      </para><para xml:id="glibc-ungetc">
<indexterm scope="glibc-fn"><primary>ungetc</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>ungetc</command></funcdef>
<paramdef>(int   <varname>c</varname>,
 FILE *<varname>akım</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>ungetc</command> işlevi, <varname>akım</varname> akımına sıradaki karakterden önce okunacak ilk girdi olarak <varname>c</varname> karakterini yerleştirir.
        </para><para>
<varname>c</varname> karakteri olarak <command>EOF</command> verilirse işlev hiçbir işlem yapmaz ve <command>EOF</command> ile döner. Bu özelliğini kullanrak, <varname>c</varname> karakteri olarak <command>getc</command> işlevinin dönüş değerini vererek <command>getc</command>’den dönen değer üzerinde hata denetimi
 yapmanız gerekmez.
        </para><para>
Akıma gönderdiğiniz karakterin son okuduğunuz karakter olması gerekmez. Hatta <command>ungetc</command> kullanmak için akımdan son karakteri okumanız da gerekmez. Ancak bir akımdan hiçbir okuma yapmadan bir karakteri akıma geri itmenin de bir anlamı yoktur. GNU C kütüphanesi ikilik kipte açılmış dosyalar için de bu oluşum için destek verir, diğer sistemlerde bu yoktur.
        </para><para>
GNU C kütüphanesi akıma sadece tek karakterin geri itilmesini destekler. Hiçbir okuma yapmadan işlevi peşpeşe iki defa kullanamazsınız. Diğer sistemlerde çok sayıda karakteri akıma geri itebilir ve akıma ittiğiniz karakterleri ters sırada okuyabilirsiniz; yani, son ittiğiniz karakteri ilk olarak okursunuz.
        </para><para>
Karakterlerin akıma geri itilmesi dosyada bir değişiklik yapmaz, sadece dahili tampon etkilenir. Bir dosya konumlama işlevi (<command>fseek</command>, <command>fseeko</command> ve <command>rewind</command> işlevlerinden biri; bkz.
 <xref linkend="glibc-File-Positioning"/>) çağrılırsa geri itilmiş olarak bekleyen karakterler iptal edilir.
        </para><para>
Okunmamış karakter olarak bir akıma itilen karakter dosya sonuna denk gelirse, akımın dosyasonu belirteci temizlenir, çünkü artık akımda okunacak bir karakter vardır. Karakteri okuduktan sonra tekrar dosyasonu saptanacaktır.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-ungetwc">
<indexterm scope="glibc-fn"><primary>ungetwc</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>wint_t <command>ungetwc</command></funcdef>
<paramdef>(wint_t <varname>wc</varname>,
 FILE  *<varname>akım</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>ungetwc</command> işlevi <command>ungetc</command> işlevi ile bir geniş karakterle çalışması dışında tamamen aynıdır.
        </para></funcdescr></funcsynopsis>
      </para><para>
Aşağıdaki örnekte <command>getc</command> ve <command>ungetc</command>  işlevleri akımdaki boşluk karakterlerini ayıklamakta kullanılmıştır. İşlev rastladığı boşluk olmayan her karakteri akıma geri iter. Böylece akım daha sonra okunduğunda bu karakterler okunmamış olarak yeniden okunabilir.
    </para><para><screen>
#include &lt;stdio.h>
#include &lt;ctype.h>

void
skip_whitespace (FILE *stream)
{
  int c;
  do
    /* EOF için bir sınama yapmaya gerek yoktur,
       çünkü <command>ungetc</command> EOF'u yoksayar.  */
    c = getc (stream);
  while (isspace (c));
  ungetc (c, stream);
}
</screen></para>
    </sect1>
  </chapter>

<chapter xml:id="glibc-Block-Input-Output">
  <title>Blok Girişi ve Çıkışı</title>
  <titleabbrev>Veri blokları üzerinde G/Ç işlemleri.</titleabbrev>
  <para>
Bu kısımda veri blokları üzerinde giriş ve çıkış işlemlerinin nasıl yapıldığı  anlatılmıştır. Bu işlevleri kullarak ikilik verilerin giriş ve çıkış işlemlerini  yapabileceğiniz gibi satırlar ve karakterler yerine sabit uzunluktaki metinler üzerinde de giriş ve çıkış işlemleri yapabilirsiniz.
<indexterm scope="glibc-cp"><primary>akımlar</primary><secondary>ikilik G/Ç</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>akımlar</primary><secondary>blok G/Ç</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>akımlar</primary><secondary>okuma</secondary><tertiary>bloklar</tertiary></indexterm>
<indexterm scope="glibc-cp"><primary>akımlar</primary><secondary>yazma</secondary><tertiary>bloklar</tertiary></indexterm>
  </para><para>
İkilik dosyalar, genellikle, bir çalışan yazılımın içeriği ile aynı biçimdeki veri bloklarının okunması ve yazılmasında kullanılır. Başka bir deyişle, istenen bellek blokları (sadece karakter ya da dizge nesneleri değil) bir ikilik dosyaya kaydedilir ve aynı yazılım tarafından anlamlı olarak tekrar okunur.
  </para><para>
Verinin ikilik biçimde saklanması biçimli G/Ç işlemlerini kullanmaktan çok daha verimlidir. Ayrıca gerçek sayıların ikilik biçimde okunması dönüşüm sırasında olası hassasiyet kayıplarının önüne geçer. Diğer taraftan, ikilik dosyalar birçok standart dosya araçları (örn., metin düzenleyiciler) ile düzenlenemez ve dilin farklı gerçeklemeleri ya da farklı bilgisayarlar arasında taşınabilir değildir.
  </para><para>
Bu işlevler <filename>stdio.h</filename> başlık dosyasında bildirilmiştir.
<indexterm scope="glibc-pg"><primary>stdio.h</primary></indexterm>
  </para><para xml:id="glibc-fread">
<indexterm scope="glibc-fn"><primary>fread</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>size_t <command>fread</command></funcdef>
<paramdef>(void  *<varname>veri</varname>,
 size_t <varname>boyut</varname>,
 size_t <varname>miktar</varname>,
 FILE  *<varname>akım</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev, <varname>boyut</varname> uzunluktaki <varname>miktar</varname> sayıda nesneyi <varname>akım</varname> akımından okur ve <varname>veri</varname> dizisine yazar. Bir hata oluşur veya dosya sonuna ulaşılırsa, okunan nesnelerin sayısı olan ve belirtilen <varname>miktar</varname>’dan daha küçük bir sayı ile döner. <varname>boyut</varname> ya da <varname>miktar</varname> sıfır değeriyle verilmişse işlev hiçbir işlem yapmaz ve sıfır ile döner.
    </para><para>
İşlev bir nesnenin ortasında dosya sonu saptarsa tamamı okunabilen nesnelerin sayısı ile döner ve kısmen okunan nesneyi iptal eder. Bu nedenle gerçek dosya sonu akımda kalır.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-fread_unlocked">
<indexterm scope="glibc-fn"><primary>fread_unlocked</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>size_t <command>fread_unlocked</command></funcdef>
<paramdef>(void  *<varname>veri</varname>,
 size_t <varname>boyut</varname>,
 size_t <varname>miktar</varname>,
 FILE  *<varname>akım</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>fread_unlocked</command> işlevi akımı dolaylı olarak kilitlememesi dışında <command>fread</command> işlevine eşdeğerdir.
    </para><para>
Bu işlev bir GNU oluşumudur.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-fwrite">
<indexterm scope="glibc-fn"><primary>fwrite</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>size_t <command>fwrite</command></funcdef>
<paramdef>(const void *<varname>veri</varname>,
 size_t      <varname>boyut</varname>,
 size_t      <varname>miktar</varname>,
 FILE       *<varname>akım</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev, <varname>boyut</varname> uzunluktaki <varname>miktar</varname> sayıda nesneyi <varname>veri</varname> dizisinden okur ve <varname>akım</varname> akımına yazar. İşlev başarılı olursa <varname>miktar</varname> ile döner. Farklı bir değer dönmüşse bu, alan yetersiz gibi bazı hataları belirtir.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-fwrite_unlocked">
<indexterm scope="glibc-fn"><primary>fwrite_unlocked</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>size_t <command>fwrite_unlocked</command></funcdef>
<paramdef>(const void *<varname>veri</varname>,
 size_t      <varname>boyut</varname>,
 size_t      <varname>miktar</varname>,
 FILE       *<varname>akım</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>fwrite_unlocked</command> işlevi akımı dolaylı olarak kilitlememesi dışında <command>fwrite</command> işlevine eşdeğerdir.
    </para><para>
Bu işlev bir GNU oluşumudur.
    </para></funcdescr></funcsynopsis>
  </para>
</chapter>
<chapter xml:id="glibc-Formatted-Output">
  <title>Biçimli Çıktı</title>
  <titleabbrev><command>printf</command> ve ilgili işlevler.</titleabbrev>
  <para>
<indexterm scope="glibc-cp"><primary>biçimli çıktı</primary><secondary>biçim dizgesi</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>biçimli çıktı</primary><secondary>şablon dizge</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>akımlar</primary><secondary>yazma</secondary><tertiary>biçimli</tertiary></indexterm>
Bu kısımda açıklanan işlevler (<command>printf</command> ve ilgili işlevler) biçimli çıktılama için kullanışlı bir yol sağlar. <command>printf</command> işlevi kalan argümanların değerlerinin nasıl biçimlendirileceğini belirten bir <wordasword>biçim dizgesi</wordasword> veya bir <wordasword>şablon dizgesi</wordasword> ile çağrılır.
  </para><para>
Yazılımınız satır ya da karakter yönlenimli işlemler uygulayan bir süzme aracı değilse, bu kısımda açıklanan <command>printf</command> veya diğer bir benzer işlevle veriyi biçimli olarak kolayca çıktılayabilirsiniz. Bu işlevler özellikle hata iletilerini, tabloları ve benzerlerini basmak için kullanışlıdır.
  </para>
  <sect1 xml:id="glibc-Formatted-Output-Basics">
    <title>Biçimli Çıktılamanın Temelleri</title>
    <titleabbrev>Başlangıç olarak bilinmesi gerekenler.</titleabbrev>
<indexterm scope="glibc-cp"><primary>biçimli çıktı</primary><secondary>dönüşüm belirtimleri</secondary></indexterm>
    <para>
<command>printf</command> işlevi istenen sayıda argümanı basmak için  kullanılabilir. İşlevi çağırırken belirteceğiniz şablon dizge içinde sadece ek argümanların sayısına ilişkin bilgi değil onların türleri ve nasıl biçimlenerek çıktılanacağına ilişkin bilgileri de verebilirsiniz.
    </para><para>
Şablon dizge içindeki bir özellik içermeyen karakterler oldukları gibi akıma  çıktılanırken şablon dizge içindeki bir <command>%</command> karakteri ile vurgulanan <wordasword>dönüşüm belirtimleri</wordasword> altbileşen argümanların biçimlenerek akıma çıktılanmasını sağlar. Örneğin,
    </para><para>
<screen>
int pct = 37;
char filename[] = &quot;foo.txt&quot;;
printf (&quot;`%s' dosyasının %%%d'lik kısmı işlendi.\nLütfen sabırlı olun.\n&quot;,
        filename, pct);
</screen>
    </para><para>kodu şöyle bir çıktı üretir:</para><para>
<screen>
`foo.txt' dosyasının %37'lik kısmı işlendi.
Lütfen sabırlı olun.
</screen></para><para>
Bu örnekteki <command>%d</command> biçimleyeceği ikinci artbileşen argümanın <command>int</command> türünden olduğunu ve bir onluk tamsayı olarak basılacağını belirtir. <command>%s</command> ise ilk artbileşen argümanın bir dizge olduğunu belirtir. <command>%d</command> belirtimini önceleyen <command>%%</command> karakterleri <command>%</command> işareti olarak yorumlanır.
    </para><para>
Bir tamsayı argümanın bir işaretsiz sekizlik, onluk ya da onaltılık tabanda bir sayı olarak (sırasıyla <command>%o</command>, <command>%u</command>, <command>%x</command>) ya da bir karakter <command>%c</command>) olarak yorumlanmasını sağlanabilir.
    </para><para>
Bir gerçek sayı <command>%f</command> ile ondalık gösterimde <command>%e</command> ile üstel gösterimde basılabilir. <command>%g</command> dönüşümü ile gerçek sayıya, sayının büyüklüğüne bağlı olarak  <command>%f</command> veya <command>%g</command> dönüşümü uygulanır.
    </para><para>
Biçimlemeyi <command>%</command> ile dönüşüm karakteri arasına <wordasword>değiştiriciler</wordasword> yerleştirerek daha hassas olarak ayarlayabilirsiniz. Bunlar kimi zaman normal dönüşüm davranışını oldukça değiştirebilir. Örneğin, çoğu dönüşüm belirtimleri bir en küçük alan genişliği ile alanın sağa mı yoksa sola mı yanaştırılarak yazılacağını belirleyen imlerin kullanılmasına izin verir.
    </para><para>
Bu tür değiştirici ve imler dönüşüm türüne bağlı olarak farklı yorumlanabilir. Bunlar size başta oldukça karmaşık görünebilir, endişelenmeyin; bir değiştirici ya da im kullanmadan da serbest biçimde gayet anlamlı çıktılar üretebilirsiniz. Bu değiştirici ve imler özellikle ve çoğunlukla tablo benzeri çıktılarda daha hoş görünümler elde etmek amacıyla kullanılır.
    </para>
  </sect1>
  <sect1 xml:id="glibc-Output-Conversion-Syntax">
    <title>Çıktı Dönüşüm Sözdizimi</title>
    <titleabbrev>Dönüşüm belirtimlerinin genel sözdizimi.</titleabbrev>
    <para>
Bu bölümde bir <command>printf</command> şablon dizgesindeki dönüşüm belirtimlerinin tam sözdizimi ayrıntılarıyla açıklanmıştır.
    </para><para>
Şablon dizgesindeki bir dönüşüm belirtiminin parçası olmayan karakterler oldukları gibi akıma çıktılanır. Şablon dizgesinde çok baytlı karakter dizileri de kullanılabilir (Bkz. <xref linkend="glibc-Character-Set-Handling"/>).
    </para><para>
Bir <command>printf</command> şablon dizgesindeki dönüşüm belirtimlerinin genel sözdizimi:
    </para><para>
<literallayout>
% [ <varname>konum-num</varname> $] <varname>imler</varname> <varname>genişlik</varname> [ . <varname>hassasiyet</varname> ] <varname>tür</varname> <varname>dönüşüm</varname>
</literallayout></para><para>veya</para><para>
<literallayout>
% [ <varname>konum-num</varname> $] <varname>imler</varname> <varname>genişlik</varname> . * [ <varname>param-no</varname> $] <varname>tür</varname><varname>dönüşüm</varname>
</literallayout></para><para>
<dicterm><english>conversion specification</english><turkish> dönüşüm belirteci (biçimleme için)</turkish></dicterm>
Örneğin, <command>%-10.8ld</command> dönüşüm belirtecinde, <command>-</command> imi, <command>10</command> alan genişliğini, <command>8</command> hassasiyeti, <command>l</command> veri türünü, <command>d</command> ise dönüşüm tarzını belirtir. (Bu dönüşüm belirteci artbileşen argümanının en az 10 karakter genişlikteki bir alana onluk tabanda 8 basamaklı bir <command>long int</command> türündeki değerinin sola yanaşık olarak basılacağını belirtir.)
    </para><para>
Çıktı dönüşüm belirtimlerinde <command>%</command> işaretini izleyen  belirteçler sırayla aşağıda açıklanmıştır:
    </para><para>
      <itemizedlist><listitem><para>
İsteğe bağlı bir konumlama parametresi. Normalde <command>printf</command> şablon dizgesini izleyen argümanları verildikleri sıraya göre basar. Ancak bazı durumlarda (örneğin çevirilerde) bu sıra uygun düşmez ve bunların sırasını değiştirmek gerekir. Bu sıra değişikliğini belirtmek için ayrı bir parametre kullanılır.
      </para><para>
Sözdizimindeki <varname>konum-num</varname> parçası 1’den çağrıdaki artbileşen argümanlarının sayısına kadar bir aralıkta bir tamsayı olmalıdır. Bazı gerçeklemeler belirtilebilecek artbileşen argümanlarının sayısına bir üst sınır koyar. Bu sınır değer aşağıdaki sabit ile belirlenir.
      </para><para xml:id="glibc-NL_ARGMAX">
<indexterm scope="glibc-vr"><primary>NL_ARGMAX</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef><command>NL_ARGMAX</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
<command>NL_ARGMAX</command> sabitinin değeri bir <command>printf</command> çağrısında belirtilebilecek artbileşen argümanların sayısının üst sınırıdır. Çalışma anında etkin olan bu değer <command>sysconf</command>'u <command>_SC_NL_ARGMAX</command> parametresi ile kullanarak alınabilir. Bkz.  <xref linkend="glibc-Sysconf-Definition"/>.
        </para><para>
Bazı sistemler oldukça düşük değerlere sahiptir, örneğin System V için bu değer 9'dur. GNU C kütüphanesinde böyle bir sınır yoktur.
        </para></funcdescr></funcsynopsis>
      </para><para>
Şablon dizgesindeki dönüşüm belirtimlerinden birinde bu parametre gerekliyse hepsinde olmalıdır. Aksi takdirde, işlevin davranışı tanımlanmamıştır.
      </para></listitem><listitem><para>
<indexterm scope="glibc-cp"><primary>biçimli çıktı</primary><secondary>im karakteri</secondary></indexterm>
Dönüşüm belirtiminin normal davranışını değiştiren sıfır veya daha fazla  <wordasword>im karakteri</wordasword>.
      </para></listitem><listitem><para>
<indexterm scope="glibc-cp"><primary>biçimli çıktı</primary><secondary>en küçük alan genişliği</secondary></indexterm>
<wordasword>En küçük alan genişliği</wordasword>ni belirten isteğe bağlı bir onluk tamsayı. Normal dönüşüm bundan daha az karakter üretiyorsa eksik karakterlerin yeri boşluklarla doldurulur. Bu bir <varname>en küçük</varname> değerdir; normal dönüşüm bundan daha fazla karakter üretiyorsa, değer alan genişliği ile sınırlanmaz.  Normalde çıktı alan içinde sağa yanaştırılır.
      </para><para>
Alan genişliğini <command>*</command> ile de belirtebilirsiniz. Bu durumda argünman listesindeki sonraki argüman alan genişliği olarak kullanılır. Değer <command>int</command> türünden olmalıdır. Değer negatifse  <command>-</command> işareti im karakteri olarak, mutlak değer ise alan genişliği olarak kullanılır.
      </para></listitem><listitem><para>
<dicterm><english>precision</english><turkish>hassasiyet</turkish></dicterm>
<indexterm scope="glibc-cp"><primary>biçimli çıktı</primary><secondary>hassasiyet</secondary></indexterm>
Sayısal dönüşümlerde basamak sayısını belirtmek için isteğe bağlı bir <wordasword>hassasiyet</wordasword> değeri. Hassasiyet belirtilmişse, bir noktadan (<command>.</command>) sonra gelen bir onluk tamsayıdır (verilmezse öntanımlı değeri sıfırdır).
      </para><para>
Hassasiyeti <command>*</command> ile de belirtebilirsiniz. Bu durumda argünman listesindeki sonraki argüman hassasiyet olarak kullanılır. Değer <command>int</command> türünden olmalıdır. Negatifse yoksayılır. Hem alan genişliğini hem de hassasiyeti <command>*</command> ile belirtirseniz, alan genişliği argümanı hassaiyet argümanından önce olmalıdır. Diğer C kütüphanesi sürümleri bu sözdizimini tanıyamayabilir.
      </para></listitem><listitem><para>
<indexterm scope="glibc-cp"><primary>biçimli çıktı</primary><secondary>tür değiştirme karakteri</secondary></indexterm>
İsteğe bağlı bir <wordasword>tür değiştirme karakteri</wordasword>; artbileşen argümanın türünden farklı bir tür belirtmek için kullanılır. (Örneğin tamsayı dönüşümleri <command>int</command> türünde varsayılır, ama <command>h</command>, <command>l</command> veya <command>L</command> harfi ile başka bir tür belirtebilirsiniz.)
      </para></listitem><listitem><para>
<indexterm scope="glibc-cp"><primary>biçimli çıktı</primary><secondary>dönüşüm belirteci</secondary></indexterm>
Uygulanacak dönüşümü belirten bir karakter  (<wordasword>dönüşüm belirteci</wordasword>).
      </para></listitem></itemizedlist>
    </para><para>
İzin verilen seçenekler ve onların yorumlanışı farklı dönüşüm belirteçleri için aynı değildir. Bir seçeneğin kullanıldığı bir dönüşümdeki yorumlanışı ile ilgili bilgileri, o dönüşümün açıklamalarında bulabilirsiniz.
    </para><para>
<command>-Wformat</command> seçeneği ile GNU C derleyicisi <command>printf</command> ve ilgili işlevleri denetler. Biçim dizgesine bakarak doğru sayı ve türde argüman belirtilip belirtilmediğini denetler. Yazdığınız bir <command>printf</command> tarzı biçim dizgesini denetlemek için GNU C sözdizimini derleyiciye söyleyecek bir işlev de vardır. (GCC info'sundaki "İşlev Özniteliklerinin Bildirilmesi" [Declaring Attributes  of Functions] bölümüne bakınız.)
    </para>
  </sect1>
  <sect1 xml:id="glibc-Table-of-Output-Conversions">
    <title>Çıktı Dönüşüm Belirteçlerinin Listesi</title>
    <titleabbrev>Çıktı dönüşümleri ve ne yaptıklarının bir özeti.</titleabbrev>
    <para>
<indexterm scope="glibc-cp"><primary>biçimli çıktı</primary><secondary>çıktı dönüşüm belirteçleri</secondary></indexterm>
Aşağıda tüm farklı dönüşümler özetlenmiştir:
    </para><para>
      <variablelist><varlistentry><term><literal>%d, %i</literal></term>
        <listitem><para>
Bir tamsayıyı işaretli onluk sayı olarak basar. Ayrıntılar için <xref linkend="glibc-Integer-Conversions"/> bölümüne bakınız. <command>%d</command> ve <command>%i</command> çıktı için eşanlamlıdır ama <command>scanf</command> ile girdi için kullanıldıklarında farklıdırlar (Bkz. <xref linkend="glibc-Table-of-Input-Conversions"/>).
        </para></listitem>
      </varlistentry><varlistentry><term><literal>%o</literal></term>
        <listitem><para>
Bir tamsayıyı bir işaretsiz sekizlik sayı olarak basar. Ayrıntılar için <xref linkend="glibc-Integer-Conversions"/> bölümüne bakınız.
        </para></listitem>
      </varlistentry><varlistentry><term><literal>%u</literal></term>
        <listitem><para>
Bir tamsayıyı bir işaretsiz onluk sayı olarak basar. Ayrıntılar için <xref linkend="glibc-Integer-Conversions"/> bölümüne bakınız.
        </para></listitem>
      </varlistentry><varlistentry><term><literal>%x, %X</literal></term>
        <listitem><para>
Bir tamsayıyı bir işaretsiz onaltılık sayı olarak basar.  <command>%x</command> küçük harfleri, <command>%X</command> büyük harfleri kullanır. Ayrıntılar için
 <xref linkend="glibc-Integer-Conversions"/> bölümüne bakınız.
        </para></listitem>
      </varlistentry><varlistentry><term><literal>%f</literal></term>
        <listitem><para>
Bir gerçek sayıyı ondalık gösterimle basar. Ayrıntılar için <xref linkend="glibc-Floating-Point-Conversions"/> bölümüne bakınız.
        </para></listitem>
      </varlistentry><varlistentry><term><literal>%e, %E</literal></term>
        <listitem><para>
Bir gerçek sayıyı üstel gösterimle basar. <command>%e</command> küçük harf, <command>%E</command> büyük harf kullanır. Ayrıntılar için <xref linkend="glibc-Floating-Point-Conversions"/> bölümüne bakınız.
        </para></listitem>
      </varlistentry><varlistentry><term><literal>%g, %G</literal></term>
        <listitem><para>
Bir gerçek sayıyı büyüklüğüne bağlı olarak ya ondalık ya da üstel gösterimle basar. <command>%g</command> küçük harf, <command>%G</command> büyük harf kullanır. Ayrıntılar için <xref linkend="glibc-Floating-Point-Conversions"/> bölümüne bakınız.
        </para></listitem>
      </varlistentry><varlistentry><term><literal>%a, %A</literal></term>
        <listitem><para>
Bir gerçek sayıyı 2 tabanındaki üstel kısmını onluk sayı, kesir kısmını onaltılık sayı olarak basar. <command>%a</command> küçük harf, <command>%A</command> büyük harf kullanır. Ayrıntılar için <xref linkend="glibc-Floating-Point-Conversions"/> bölümüne bakınız.
        </para></listitem>
      </varlistentry><varlistentry><term><literal>%c</literal></term>
        <listitem><para>
Tek karakter basar. Ayrıntılar için <xref linkend="glibc-Other-Output-Conversions"/> bölümüne bakınız.
        </para></listitem>
      </varlistentry><varlistentry><term><literal>%C</literal></term>
        <listitem><para>
Unix standardına destek amacıyla vardır ve <command>%lc</command> yerine  kullanılmak içindir.
        </para></listitem>
      </varlistentry><varlistentry><term><literal>%s</literal></term>
        <listitem><para>
Bir dizge basar. Ayrıntılar için  <xref linkend="glibc-Other-Output-Conversions"/> bölümüne bakınız.
        </para></listitem>
      </varlistentry><varlistentry><term><literal>%S</literal></term>
        <listitem><para>
Unix standardına destek amacıyla vardır ve <command>%ls</command> yerine  kullanılmak içindir.
        </para></listitem>
      </varlistentry><varlistentry><term><literal>%p</literal></term>
        <listitem><para>
Bir gösterici değeri basar. Ayrıntılar için  <xref linkend="glibc-Other-Output-Conversions"/> bölümüne bakınız.
        </para></listitem>
      </varlistentry><varlistentry><term><literal>%n</literal></term>
        <listitem><para>
O ana kadar basılan karakterlerin sayısını alır. Bu belirteç bir çıktı üretmez. Ayrıntılar için <xref linkend="glibc-Other-Output-Conversions"/> bölümüne bakınız.
        </para></listitem>
      </varlistentry><varlistentry><term><literal>%m</literal></term>
        <listitem><para>
<command>errno</command> değerine karşılık olan hata iletisini basar. Bu bir GNU oluşumudur. Ayrıntılar için <xref linkend="glibc-Other-Output-Conversions"/> bölümüne bakınız.
        </para></listitem>
      </varlistentry><varlistentry><term><literal>%%</literal></term>
        <listitem><para>
Sadece <command>%</command> işareti basar. Ayrıntılar için  <xref linkend="glibc-Other-Output-Conversions"/> bölümüne bakınız.
      </para></listitem></varlistentry></variablelist>
    </para><para>
Bir dönüşüm belirtiminin sözdizimi geçersizse beklenmeyen şeyler olabilir, yani bunu yapmamaya çalışın. Şablon dizgesinde belirtilenden daha az sayıda artbileşen argüman varsa ya da artbileşen argümanların türleri ile dönüşüm belirtimleri uyumsuzsa sonucun ne olacağı belli olmaz. Şablon dizgesinde belirtilenden daha çok sayıda artbileşen argüman varsa fazla argümanlar basitçe yoksayılır; bu kimi zaman kullanışlıdır.
    </para>
  </sect1>
  <sect1 xml:id="glibc-Integer-Conversions">
    <title>Tamsayı Dönüşümleri</title>
    <titleabbrev>Tamsayıların biçimlendirilmesi ile ilgili ayrıntılar.</titleabbrev>
    <para>
Bu bölümde <command>%d</command>, <command>%i</command>, <command>%o</command>, <command>%u</command>, <command>%x</command> ve <command>%X</command> dönüşüm belirteçleri ile kullanılan seçenekler açıklanmıştır. Bu dönüşümler tamsayıları çeşitli biçimlerde basmak için kullanılır.
    </para><para>
<command>%d</command> ve <command>%i</command> belirteçlerinin herikisi de bir işaretsiz ondalık sayı olarak; <command>%o</command>, <command>%u</command> ve <command>%x</command> belirteçleri sırasıyla işaretsiz sekizlik, onluk ve onaltılık sayı olarak basılır. <command>%X</command> belirteci <command>%x</command> belirteci ile aynı olmakla beraber, <command>abcdef</command> karakterleri yerine <command>ABCDEF</command> karakterlerini kullanır.
    </para><para>
Aşağıdaki im karakterleri anlamlıdır:
    </para><para>
      <variablelist><varlistentry><term><literal>-</literal></term>
        <listitem><para>
Alan içinde sonucu sola yanaştırır (normalde sağa yanaştırılır).
        </para></listitem>
      </varlistentry><varlistentry><term><literal>+</literal></term>
        <listitem><para>
İşaretli <command>%d</command> ve <command>%i</command> belirteçleri için değer pozitifse artı işareti basar.
        </para></listitem>
      </varlistentry><varlistentry><term>(boşluk karakteri)</term>
        <listitem><para>
İşaretli <command>%d</command> ve <command>%i</command> belirteçleri için sonuç bir artı ya da eksi işareti içermiyorsa işaret yerine bir boşluk basar. <command>+</command> im karakteri belirtilmişse sonuç mutlaka bir işaret içerir. Hem <command>+</command> hem de boşluk karakteri belirtilmişse boşluk yoksayılır.
        </para></listitem>
      </varlistentry><varlistentry><term><literal>#</literal></term>
        <listitem><para>
<command>%o</command> belirteci için sayının hassasiyeti arttırılmış gibi <command>0</command> ile öncelenmesini sağlar. <command>%x</command> veya <command>%X</command> için sırasıyla <command>0x</command> veya <command>0X</command> ile öncelenmesini sağlar. <command>%d</command>, <command>%i</command> veya <command>%u</command> için kullanışlı hiçbir şey yapmaz. Bu imin kullanılması <command>strtoul</command> (<xref linkend="glibc-Parsing-of-Integers"/>) tarafından ve <command>scanf</command> işlevinin <command>%i</command> dönüşümü (<xref linkend="glibc-Numeric-Input-Conversions"/>) ile çözümlenen çıktıyı üretir.
        </para></listitem>
      </varlistentry><varlistentry><term><literal>'</literal></term>
        <listitem><para>
<command>LC_NUMERIC</command> kategorisi için yerel tarafından belirtildiği gibi sayıyı gruplara ayırır. Bu im bir GNU oluşumudur. Bkz. <xref linkend="glibc-General-Numeric"/>.
        </para></listitem>
      </varlistentry><varlistentry><term><literal>0</literal></term>
        <listitem><para>
Alanda boş kalan yerleri boşluk yerine sıfırlarla doldurur. Sıfırlar işaretten ya da taban belirtecinden sonra konur. Bu imle birlikte <command>-</command> imi ya da hassasiyet belirtilmişse bu im yoksayılır.
      </para></listitem></varlistentry></variablelist>
    </para><para>
Bir hassasiyet belirtilmişse, görüntülenecek hane sayısıdır ve gerekliyse baştaki sıfırlar üretilir. Hassasiyet belirtilmişse sayı olduğu gibi basılır. Açıkça belirterek sıfır hassasiyetle bir sıfır değeri dönüştürmek isterseniz hiçbir karakter üretilmez.
    </para><para>
Bir tür değiştirici olmaksızın, karşı düşen argüman bir <command>int</command> (işaretli <command>%i</command> ve <command>%d</command> dönüşümleri için)
 ya da <command>unsigned int</command> (işaretsiz <command>%o</command>,  <command>%u</command>, <command>%x</command> ve <command>%X</command> dönüşümleri için) olarak ele alınır. <command>printf</command> ve arkadaşları değişkin işlevler olduklarından <command>char</command> ve <command>short</command> argümanlar öntanımlı argüman terfileri tarafından özdevinimli olarak <command>int</command> türüne dönüştürülür. Diğer tamsayı türleri için aşağıdaki tür değiştiricilerini kullanabilirsiniz:
    </para><para>
      <variablelist><varlistentry><term><literal>hh</literal></term>
        <listitem><para>
Argümanın duruma göre <command>signed char</command> veya <command>unsigned char</command> olarak yorumlanacağını belirtir. Öntanımlı argüman terfileri çerçevesinde <command>char</command> türünden bir değer <command>int</command> veya <command>unsigned int</command> türüne terfi ettirilir. Ancak <command>hh</command> tür değiştiricisi onu tekrar <command>char</command> türüne çevirir.
        </para><para>
Bu değiştirici ISO C99'da tanımlanmıştır.
        </para></listitem>
      </varlistentry><varlistentry><term><literal>h</literal></term>
        <listitem><para>
Argümanın duruma göre <command>short int</command> veya <command>unsigned short int</command> olarak yorumlanacağını belirtir. Öntanımlı argüman terfileri çerçevesinde <command>short</command> türünden bir değer <command>int</command> veya <command>unsigned int</command> türüne terfi ettirilir. Ancak <command>h</command> tür değiştiricisi onu tekrar <command>short</command> türüne çevirir.
        </para></listitem>
      </varlistentry><varlistentry><term><literal>j</literal></term>
        <listitem><para>
Argümanın duruma göre <command>intmax_t</command> veya  <command>uintmax_t</command> olarak yorumlanacağını belirtir.
        </para><para>
Bu değiştirici ISO C99'da tanımlanmıştır.
        </para></listitem>
      </varlistentry><varlistentry><term><literal>l</literal></term>
        <listitem><para>
Argümanın duruma göre <command>long int</command> veya <command>unsigned long int</command> olarak yorumlanacağını belirtir. İki <command>l</command> karakteri biraz aşağıda açıklanan <command>L</command> değiştiricisine benzer.
        </para><para>
Bir <command>%c</command> veya <command>%s</command> belirteci ile birlikte kullanılmışsa argüman bir geniş karakter veya bir geniş karakter dizgesi olarak yorumlanır. <command>l</command> değiştiricisinin bu kullanımı ISO C90 1. düzeltmesinde tanımlanmıştır.
        </para></listitem>
      </varlistentry><varlistentry><term><literal>L, ll, q</literal></term>
        <listitem><para>
Argümanın <command>long long int</command> türünde yorumlanacağını belirtirler. (Bu tür GNU C derleyicisi tarafından desteklenen bir oluşumdur. Fazla uzun tamsayıları desteklemeyen sistemlerde bu değiştirici <command>long int</command> olarak değerlendirilir.)
        </para><para>
<command>q</command> değiştiricisi 4.4 BSD’den gelmektedir. Bir <command>long long int</command> kimi zaman &quot;quad&quot; <command>int</command> olarak da isimlendirilir.
        </para></listitem>
      </varlistentry><varlistentry><term><literal>t</literal></term>
        <listitem><para>
Argümanın <command>ptrdiff_t</command> türünde yorumlanacağını belirtir.
        </para><para>
Bu değiştirici ISO C99'da tanımlanmıştır.
        </para></listitem>
      </varlistentry><varlistentry><term><literal>z, Z</literal></term>
        <listitem><para>
Argümanın <command>size_t</command> türünde yorumlanacağını belirtirler.
        </para><para>
<command>z</command> değiştiricisi ISO C99'da tanımlanmıştır. <command>Z</command> ise bu eklemeden önceki bir GNU oluşumudur ve yeni kodlarda kullanılmamalıdır.
        </para></listitem>
      </varlistentry></variablelist>
    </para><para>
Aşağıda bir şablon dizgesi örneği vardır:
    </para><para>
<screen>&quot;|%5d|%-5d|%+5d|%+-5d|% 5d|%05d|%5.0d|%5.2d|%d|\n&quot;</screen>
    </para><para>
<command>%d</command> için farklı seçeneklerin kullanıldığı bu dizge aşağıdaki sonuçları verir:
    </para><para>
<screen>
|    0|0    |   +0|+0   |    0|00000|     |   00|0|
|    1|1    |   +1|+1   |    1|00001|    1|   01|1|
|   -1|-1   |   -1|-1   |   -1|-0001|   -1|  -01|-1|
|100000|100000|+100000|+100000| 100000|100000|100000|100000|100000|
</screen></para><para>
Son satırda en küçük alan genişliğine sığmayan bir sayı belirtilmiş olduğuna dikkat ediniz.
    </para><para>
Aşağıda ise işaretsiz tamsayılar çeşitli biçim seçenekleri ile kullanılmıştır:
    </para><para>
      <screen>&quot;|%5u|%5o|%5x|%5X|%#5o|%#5x|%#5X|%#10.8x|\n&quot;</screen>
    </para><para>
<screen>
|    0|    0|    0|    0|    0|    0|    0|  00000000|
|    1|    1|    1|    1|   01|  0x1|  0X1|0x00000001|
|100000|303240|186a0|186A0|0303240|0x186a0|0X186A0|0x000186a0|
</screen></para>
  </sect1>
  <sect1 xml:id="glibc-Floating-Point-Conversions">
    <title>Gerçek Sayı Dönüşümleri</title>
    <titleabbrev>Gerçek sayıların biçimlendirilmesi ile ilgili ayrıntılar.</titleabbrev>
    <para>
Bu bölümde gerçek sayıların dönüşüm belirtimlerine yer verilmiştir. Bunlar <command>%f</command>, <command>%e</command>, <command>%E</command>,  <command>%g</command> ve <command>%G</command> dönüşümleridir.
    </para><para>
<command>%f</command> dönüşümü argümanını ondalık gösterimle aşağıdaki biçimde çıktılar:
    </para><para>
<literallayout>
[<command>-</command>]<varname>ddd</varname><command>.</command><varname>ddd</varname>
</literallayout>
    </para><para>
Buradaki ondalık noktayı izleyen basamakların sayısını hassasiyet parametresi ile belirtebilirsiniz.
    </para><para>
<command>%e</command> dönüşümü argümanını üstel gösterimle aşağıdaki biçimde çıktılar:
    </para><para>
<literallayout>
[<command>-</command>]<varname>d</varname><command>.</command><varname>ddd</varname><command>e</command>[<command>+</command>|<command>-</command>]<varname>dd</varname>
</literallayout>
    </para><para>
Burada da ondalık noktayı izleyen basamakların sayısını hassasiyet parametresi ile belirtebilirsiniz. Üs daima son iki hanede bulunur. <command>%E</command> dönüşümü de aynı biçimi  üretir tek farkla <command>e</command> yerine <command>E</command> harfi kullanılır.
    </para><para>
Üs -4’ten küçükse ya da hassasiyete eşit veya daha büyükse <command>%g</command> ve <command>%G</command> dönüşümleri argümanı <command>%e</command> veya <command>%E</command> (sırasıyla) ile eşdeğerdir. Aksi takdirde, <command>%f</command> ile eşdeğerdir. <command>0</command> hassasiyet <command>1</command> olarak değerlendirilir. Sonucun ondalık kısmının sağındaki sıfırlar kaldırılır ve nokta sadece sağında bir sayı varsa gösterilir.
    </para><para>
<command>%a</command> ve <command>%A</command> dönüşümleri gerçek sayıyı metin biçiminde çıktılar. Bu çıktı farklı yazılım ve/veya makineler arasında metin verisi olarak aktarılabilir. Sayılar aşağıdaki biçimde gösterilir:
    </para><para>
<literallayout>
[<command>-</command>]<command>0x</command><varname>h</varname><command>.</command><varname>hhh</varname><command>p</command>[<command>+</command>|<command>-</command>]<varname>dd</varname>
</literallayout>
    </para><para>
Ondalık noktanın solunda sadece bir rakam bulunur. Sayı normalleştirilmemişse bu rakam <command>0</command>'dır. Aksi takdirde gerçeklemede kaç bit ayrıldığına bağlı olarak herhangi bir rakam olabilir. Ondalık noktanın sağındaki basamakların sayısı hassasiyet için belirtilen değerle sınırlıdır. Hassasiyet olarak sıfır verilmişse sayının en doğru gösterilebileceği yeterlikteki (veya <link linkend="glibc-Floating-Point-Parameters"><command>FLT_RADIX</command></link> değeri 2'nin kuvvetlerindeki bir değer değilse yanyana iki değerin iki ayrı  değer olarak seçilebileceği yeterlikte) basamak sayısı kullanılır. <command>%a</command> dönüşümü için onaltılık sayı, <command>0x</command> ve <command>p</command> ile gösterilen önek ve üstel değer için küçük harfler kullanılır. <command>%A</command> dönüşümünde bunlar için büyük harfler kullanılır. Üstel kısım iki tabanına göre onluk bir sayı olarak en az bir rakamla ifade edilir, ancak değer gerektiriyorsa daha fazla rakam da kullanılabilir.
    </para><para>
Basılan değer sonsuzluk ya da sayı olmayan bir değerse ve dönüşüm belirteçleri <command>%a</command>, <command>%e</command>, <command>%f</command> veya <command>%g</command> ise çıktı [<command>-</command>]<command>inf</command> ya da <command>nan</command>’dır; dönüşüm belirteçleri <command>%A</command>, <command>%E</command> veya <command>%G</command> ise çıktı [<command>-</command>]<command>INF</command> veya <command>NAN</command>’dır.
    </para><para>
Davranışı değiştirmek için kullanılan imler şunlardır:
    </para><para>
      <variablelist><varlistentry><term><literal>-</literal></term>
        <listitem><para>
Alan içinde sonucu sola yanaştırır (normalde sağa yanaştırılır).
        </para></listitem>
      </varlistentry><varlistentry><term><literal>+</literal></term>
        <listitem><para>
Sonuç daima bir artı ya da eksi işareti içerir.
        </para></listitem>
      </varlistentry><varlistentry><term>(boşluk karakteri)</term>
        <listitem><para>
Sonuç bir artı ya da eksi işareti içermiyorsa işaret yerine bir boşluk basar. <command>+</command> im karakteri belirtilmişse sonuç mutlaka bir işaret içerir. Hem <command>+</command> hem de boşluk karakteri belirtilmişse boşluk yoksayılır.
        </para></listitem>
      </varlistentry><varlistentry><term><literal>#</literal></term>
        <listitem><para>
Sonuç ondalık noktanın sağında hiçbir sayı olmasa bile ondalık nokta gösterilir. <command>%g</command> ve <command>%G</command> dönüşümleri için noktanın sağı, konmaması belirtilmemişse, sıfırlarla doldurulur.
        </para></listitem>
      </varlistentry><varlistentry><term><literal>'</literal></term>
        <listitem><para>
<command>LC_NUMERIC</command> kategorisi için yerel tarafından belirtildiği gibi tamsayı kısmı gruplara ayırır. Bu im bir GNU oluşumudur. Bkz. <xref linkend="glibc-General-Numeric"/>.
        </para></listitem>
      </varlistentry><varlistentry><term><literal>0</literal></term>
        <listitem><para>
Alanda boş kalan yerleri boşluk yerine sıfırlarla doldurur. Sıfırlar işaretten sonra konur. Bu imle birlikte <command>-</command> imi belirtilmişse bu im yoksayılır.
        </para></listitem>
      </varlistentry></variablelist>
    </para><para>
Bir hassasiyet belirtilmişse, <command>%f</command>, <command>%e</command> ve <command>%E</command> dönüşümleri için ondalık noktadan sonraki basamakların sayısıdır. Bu dönüşümler için öntanımlı hassasiyet 6'dır. Hassasiyet olarak <command>0</command> değeri belirtilmişse ondalık nokta basılmaz.
    </para><para>
<command>%g</command> ve <command>%G</command> dönüşümleri için hassasiyet kıymetli hanelerin sayısıdır. Kıymetli haneler noktanın solundaki tek hane ile noktanın sağındakilerin tamamıdır. Hassasiyet <command>0</command> ise ya da belirtilmemişse <command>1</command> belirtilmiş varsayılır. Basılacak değer belirtilen hane sayısı ile doğru olarak gösterilemeyecekse gösterilebilecek en yakın sayıya yuvarlanır.
    </para><para>
Tür değiştirici belirtilmeksizin tüm gerçek sayı dönüşüm belirteçleri argümanı <command>double</command> türünde yorumlar. (Öntanımlı argüman terfileri çerçevesinde <command>float</command> türünden argümanlar özdevinimli olarak <command>double</command> türüne dönüştürülür.) Desteklenen tür değiştirici:
    </para><para>
      <variablelist><varlistentry><term><literal>L</literal></term>
        <listitem><para>
Argümanın <command>long double</command> türünde yorumlanacağını belirtir.
        </para></listitem>
      </varlistentry></variablelist>
    </para><para>
Aşağıdaki örneklerde gerçek sayı dönüşümleri kullanılarak sayıların nasıl basılacağı gösterilmiştir:
    </para><para>
<screen>&quot;|%13.4a|%13.4f|%13.4e|%13.4g|\n&quot;</screen>
    </para><para>
Bu şablon dizgesi için çıktı:
    </para><para>
<screen>
|  0x0.0000p+0|       0.0000|   0.0000e+00|            0|
|  0x1.0000p-1|       0.5000|   5.0000e-01|          0.5|
|  0x1.0000p+0|       1.0000|   1.0000e+00|            1|
| -0x1.0000p+0|      -1.0000|  -1.0000e+00|           -1|
|  0x1.9000p+6|     100.0000|   1.0000e+02|          100|
|  0x1.f400p+9|    1000.0000|   1.0000e+03|         1000|
| 0x1.3880p+13|   10000.0000|   1.0000e+04|        1e+04|
| 0x1.81c8p+13|   12345.0000|   1.2345e+04|    1.234e+04|
| 0x1.86a0p+16|  100000.0000|   1.0000e+05|        1e+05|
| 0x1.e240p+16|  123456.0000|   1.2346e+05|    1.235e+05|
</screen></para><para>
<command>%g</command> dönüşümünde sağdaki sıfırların kaldırıldığına dikkat edin.
    </para>
  </sect1>
  <sect1 xml:id="glibc-Other-Output-Conversions">
    <title>Diğer Çıktı Dönüşümleri</title>
    <titleabbrev>Dizgelerin, karakterlerin, göstericilerin vb. biçimlenmesi.</titleabbrev>
    <para>
Bu bölümde <command>printf</command> için çeşitli dönüşümlerden bahsedilmiştir.
    </para><para>
 <command>%c</command> dönüşümü tek bir karakter basar.  <command>l</command> değiştiricisinin olmadığı durumda  <command>int</command> türündeki argüman önce <command>unsigned char</command> türüne dönüştürülür.  Bundan sonra, bir geniş yönlenimli akım işlevi kullanılmışsa karakter karşı düşen geniş karaktere dönüştürülür. <command>-</command> imi kullanılmış, başka bir im tanımlanmamış, tür ve hassasiyet belirtilmemişse karakter alanda sola yanaştırılır. Örneğin:
    </para><para>
<screen>printf (&quot;%c%c%c%c%c&quot;, 'h', 'e', 'l', 'l', 'o');</screen>
    </para><para>
deyimi <command>hello</command> basar.
    </para><para>
Bir <command>l</command> değiştiricisi varsa argümanın <command>wint_t</command> türünde olacağı umulur. Bir çokbaytlı işlev içinde kullanılmışsa geniş karakter çıktıya eklenmeden önce bir çok baytlı karaktere dönüştürülür. Bu durumda birden fazla bayt içeren çıktı üretilebilir.
    </para><para>
<command>%s</command> dönüşümü bir dizge basar. Bir <command>l</command> değiştiricisi yoksa karşı düşen argüman <command>char *</command> (ya da <command>const char *</command>) türünde olmalıdır. Bir geniş yönlenimli akım işlevi kullanılmışsa, dizge bir geniş karakter dizgesine dönüştürülür. Yazılacak karakterlerin sayısı hassasiyet parametresi ile belirtilebilir; aksi takdirde, sonlandıran boş karaktere kadar boş karakter hariç dizge akıma çıktılanır. <command>-</command> imi kullanılmış ama başka bir im tanımlanmamış, tür ve hassasiyet belirtilmemişse dizge alanda sola yanaştırılır. Örneğin:
    </para><para>
<screen>printf (&quot;%3s%-6s&quot;, &quot;no&quot;, &quot;where&quot;);</screen>
    </para><para>
deyimi <command> nowhere </command> basar.
    </para><para>
Bir <command>l</command> değiştiricisi varsa argümanın <command>wchar_t</command> (ya da <command>const wchar_t *</command>) türünde olacağı umulur.
    </para><para>
<command>%s</command> dönüşümüne istemeyerek argüman olarak bir boş gösterici  aktarırsanız, GNU kütüphanesi onu <command>(null)</command> olarak basar. Bunun çökmekten daha iyi olduğunu düşünüyoruz. Ancak bir boş göstericiyi bile bile aktarmak iyi bir uygulama olmayacaktır.
    </para><para>
<command>%m</command> dönüşümü <command>errno</command> hata kodunun karşılığı olan dizgeyi basar. Bkz. <xref linkend="glibc-Error-Messages"/>. Burada:
    </para><para>
<screen>
fprintf (stderr, &quot;`%s' açılamıyor: %m\n&quot;, filename);
</screen></para><para>deyimi ile</para><para>
<screen>
fprintf (stderr, &quot;`%s' açılamıyor: %s\n&quot;, filename, strerror (errno));
</screen></para><para>
deyimi eşdeğerdir. <command>%m</command> dönüşümü bir GNU oluşumudur.
    </para><para>
<command>%p</command> dönüşümü bir gösterici değeri basar. Karşı düşen argüman <command>void *</command> türünde olmalıdır. Uygulamada herhangi bir türden gösterici kullanabilirsiniz.
    </para><para>
<dicterm><english>signed integer</english><turkish>işaretli tamsayı</turkish></dicterm>
<dicterm><english>unsigned integer</english><turkish>işaretsiz tamsayı</turkish></dicterm>
GNU sisteminde boş olmayan göstericiler bir <command>%#x</command> dönüşümü kullanılmış gibi işaretsiz tamsayılar olarak basılır. Boş göstericiler <command>(nil)</command> olarak basılır. (Diğer sistemlerde göstericiler farklı basılabilir.) Örneğin:
    </para><para>
<screen>printf (&quot;%p&quot;, &quot;testing&quot;);</screen>
   </para><para>
deyimi <command>0x</command>’ten sonra <command>&quot;testing&quot;</command> dizge sabitinin adresini bir onaltılık sayı olarak basar; <command>testing</command> sözcüğünü basmaz.
    </para><para>
<command>-</command> imi kullanılmış ama başka bir im tanımlanmamış, tür ve  hassasiyet belirtilmemişse gösterici değeri alanda sola yanaştırılır.
    </para><para>
<command>%n</command> belirteci diğer dönüşüm belirteçlerine benzemez. Bir <command>int</command> türüne gösterici olan bir argüman kullanır, ama birşey çıktılamaz, onun yerine o çağrı ile çıktılanan karakterlerin sayısını kaydeder. <command>h</command> ve <command>l</command> tür değiştiricileri kullanılarak (birim, hassasiyet veya alan genişliği belirtilemez) argümanın türü <command>int *</command> yerine <command>short int *</command> veya <command>long int *</command> türünde belirtilebilir. Örneğin:
    </para><para>
<screen>
int nchar;
printf (&quot;%d %s%n\n&quot;, 3, &quot;bears&quot;, &amp;nchar);
</screen></para><para>kod parçası</para><para>
<screen>3 bears</screen>
    </para><para>
basar ve <command>nchar</command>'a 7 değerini atar, çünkü basılan karakterlerin sayısı 7'dir.
    </para><para>
<command>%%</command> belirteci bir <command>%</command> işareti basar. Bu belirteç bir argüman kullanmaz ve im, alan genişliği, hassasiyet veya tür değiştirici belirtilemez.
    </para>
  </sect1>
  <sect1 xml:id="glibc-Formatted-Output-Functions">
    <title>Biçimli Çıktı İşlevleri</title>
    <titleabbrev>Biçimli çıktı üreten işlevlerin açıklamaları.</titleabbrev>
    <para>
Bu bölümde <command>printf</command> ve ilgili işlevlerin nasıl çağrıldığı anlatılmıştır. Bu işlevlerin prototipleri <filename>stdio.h</filename> başlık dosyasındadır. Bu işlevlerin değişken sayıda argüman almalarından dolayı, onları kullanmadan önce prototipleri ile bildirmelisiniz. Şüphesiz bunu yapmanın en kolay yolu onları içeren <filename>stdio.h</filename> başlık dosyasının kaynak dosyasında içerilmesidir.
<indexterm scope="glibc-pg"><primary>stdio.h</primary></indexterm>
    </para><para xml:id="glibc-printf">
<indexterm scope="glibc-fn"><primary>printf</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>printf</command></funcdef>
<paramdef>(const char *<varname>şablon</varname>, …)</paramdef>
</funcprototype><funcdescr><para>
<command>printf</command> işlevi <varname>şablon</varname> biçim dizgesinin denetimi altında isteğe bağlı argümanları standart çıktıya basar ve basılan karakterlerin sayısı ile döner; bir hata oluşursa bir negatif değerle döner.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-wprintf">
<indexterm scope="glibc-fn"><primary>wprintf</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>wprintf</command></funcdef>
<paramdef>(const wchar_t *<varname>şablon</varname>, …)</paramdef>
</funcprototype><funcdescr><para>
<command>wprintf</command> işlevi <varname>şablon</varname> geniş biçim  dizgesinin denetimi altında isteğe bağlı argümanları standart çıktıya basar ve basılan geniş karakterlerin sayısı ile döner; bir hata oluşursa bir negatif değerle döner.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-fprintf">
<indexterm scope="glibc-fn"><primary>fprintf</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>fprintf</command></funcdef>
<paramdef>(FILE       *<varname>akım</varname>,
 const char *<varname>şablon</varname>,
 …)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev <command>printf</command> gibidir, tek farkla, çıktıyı standart çıktıya değil <varname>akım</varname>’a yazar.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-fwprintf">
<indexterm scope="glibc-fn"><primary>fwprintf</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>fwprintf</command></funcdef>
<paramdef>(FILE          *<varname>akım</varname>,
 const wchar_t *<varname>şablon</varname>,
 …)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev <command>wprintf</command> gibidir, tek farkla, çıktıyı standart çıktıya değil <varname>akım</varname>’a yazar.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-sprintf">
<indexterm scope="glibc-fn"><primary>sprintf</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>sprintf</command></funcdef>
<paramdef>(char       *<varname>s</varname>,
 const char *<varname>şablon</varname>,
 …)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev <command>printf</command> gibidir, tek farkla, çıktıyı standart çıktıya değil <varname>s</varname> dizisine yazar. Dizge bir boş karakterle sonlandırılır.
      </para><para>
<command>sprintf</command> işlevi sonlandırıcı boş karakter hariç <varname>s</varname> dizisine yazılan karakterlerin sayısı ile döner.
      </para><para>
Bu işlevin davranışı, birbirini kapsayan nesneler arasında kopyalama yapılırsa, örneğin, <command>%s</command> belirtecinin argümanı olarak <varname>s</varname> dizgesi verilmişse, tanımsızdır. Bkz. <xref linkend="glibc-Copying-and-Concatenation"/>.
      </para><para>
<warning><para><command>sprintf</command> işlevi <varname>tehlikeli</varname> olabilir. Potansiyel olarak <varname>s</varname> dizgesi için ayrılan yer biçim dizgesinin ürettiği dizge için yetersiz olabilir. Alan genişliği parametresinin en küçük alan genişliğini belirttiğini ve kimi zaman bu genişliğin aşılabildiğini hatırlayın.</para><para>Bu sorundan kaçımak için aşağıda açıklanacak olan <command>snprintf</command> veya <command>asprintf</command> işlevlerini kullanabilirsiniz.</para></warning>
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-swprintf">
<indexterm scope="glibc-fn"><primary>swprintf</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>swprintf</command></funcdef>
<paramdef>(wchar_t       *<varname>s</varname>,
 size_t         <varname>boyut</varname>,
 const wchar_t *<varname>şablon</varname>,
 …)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev <command>printf</command> gibidir, tek farkla, çıktıyı standart çıktıya değil <varname>ws</varname> geniş karakter dizisine yazar. Dizge bir boş geniş karakterle sonlandırılır. <varname>boyut</varname> argümanı ile üretilecek en büyük karakter sayısı belirtilir. Sonlandırıcı boş karakter de bu sınırın içinde olduğundan <varname>ws</varname> dizgesi için en az <varname>boyut</varname> geniş karakterlik yer ayrılmalıdır.
      </para><para>
<command>swprintf</command> işlevi sonlandırıcı boş geniş karakter hariç <varname>ws</varname> geniş dizisine yazılan karakterlerin sayısı ile döner. Çıktı belirtilen tampona sığmazsa bir negatif sayı ile döner. Bu davranışı ile işlev <command>snprintf</command> işlevinden farklıdır.
      </para><para>
<note><para>Benzeri olan dar yönlenimli akım işlevleri daha az parametre alır. <command>swprintf</command> işlevi aslında <command>snprintf</command> işlevinin karşılığıdır. <command>sprintf</command> işlevi tehlikeli olabildiğinden, ISO C komitesi aynı yanlışı tekrar yapmaktan kaçınmalı ve <command>sprintf</command> işlevinin tam karşılığı olan bir işlevi tanımlamama kararı almalıdır.</para></note>
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-snprintf">
<indexterm scope="glibc-fn"><primary>snprintf</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>snprintf</command></funcdef>
<paramdef>(char       *<varname>s</varname>,
 size_t      <varname>boyut</varname>,
 const char *<varname>şablon</varname>,
 …)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev <command>sprintf</command> gibidir, tek farkla, <varname>boyut</varname> argümanı ile üretilecek en büyük karakter sayısı belirtilir. Sonlandırıcı boş karakter de bu sınırın içinde olduğundan <varname>s</varname> dizgesi için en az <varname>boyut</varname> karakterlik yer ayrılmalıdır.
      </para><para>
<command>snprintf</command> işlevi sonlandırıcı boş geniş karakter hariç <varname>s</varname> dizisine yazılan karakterlerin sayısı ile döner. Bu değer <varname>boyut</varname>'a eşit ya da ondan büyükse sonucun tüm karakterleri <varname>s</varname> dizisine yazılamamış demektir. Bu durumda daha büyük çıktı dizisi ile çağrıyı yinelemelisiniz. Aşağıda bunun yapıldığı bir örnek vardır:
      </para><para>
<screen>
/*  <varname>isim</varname> isminde ve <varname>deger</varname> değerinde
    bir değişkenin değerini açıklayan bir ileti oluşturalım. */
char *
ileti_yap (char *isim, char *deger)
{
  /* Nasılsa 100 karakterlikten daha fazla yere ihtiyaç olmaz. */
  int boyut = 100;
  char *tampon = (char *) xmalloc (boyut);
  int nkar;
  if (tampon == NULL)
    return NULL;

  /* Ayrılan alana iletiyi yazmaya çalışalım. */
  nkar = snprintf (tampon, boyut, &quot;%s değişkeninin değeri %s'dir&quot;,
                   isim, deger);
  if (nkar >= boyut)
    {
      /* Artık ne kadar yere ihtiyaç olduğunu
         bildiğimize göre tamponu yeniden ayıralım. */
      tampon = (char *) xrealloc (tampon, nkar + 1);
      boyut = nkar + 1;
      buffer = (char *) xrealloc (tampon, boyut);

      if (tampon != NULL)
        /* Tekrar deniyoruz. */
        snprintf (tampon, boyut, &quot;%s değişkeninin değeri %s'dir&quot;,
                  isim, deger);
    }
  /* Son çağrı çalıştığından dizge ile dönüyoruz. */
  return tampon;
}
</screen></para><para>
Uygulamada, <command>asprintf</command> işlevini kullanmak çok daha kolaydır.
      </para><para>
<caution><para>GNU C kütüphanesinin 2.1 öncesi sürümlerinde dönüş değeri sonlandırıcı boş karakter hariç saklanan karakterlerin sayısıydı. <varname>s</varname> dizisinde yeterli yer yoksa <command>-1</command> dönüyordu. Bu, ISO C99 standardına uyum sırasında değiştirildi.
 </para></caution>
      </para></funcdescr></funcsynopsis>
    </para>
  </sect1>
  <sect1 xml:id="glibc-Dynamic-Output">
    <title>Biçimli Çıktıyı Özdevimli Ayırma</title>
    <titleabbrev>Çıktı için belleği özdevimli ayıran işlevler.</titleabbrev>
    <para>
Bu bölümdeki işlevler biçimli çıktı oluşturur ve sonucu özdevimli ayrılan belleğe yazar.
    </para><para xml:id="glibc-asprintf">
<indexterm scope="glibc-fn"><primary>asprintf</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>asprintf</command></funcdef>
<paramdef>(char      **<varname>gstr</varname>,
 const char *<varname>şablon</varname>,
 …)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev, çıktıyı sizin ayırdığınız bir tampona değil, özdevimli ayrılmış (<command>malloc</command> ile; Bkz. <xref linkend="glibc-Unconstrained-Allocation"/>) bir dizgeye yazması dışında <command>sprintf</command> işlevi gibidir.
<varname>gstr</varname> argümanı, bir <command>char *</command> nesnesinin adresi olmalıdır. <command>asprintf</command> bu konumda yeni ayrılmış dizgeye bir gösterici saklayacaktır.
      </para><para>
Dönen değer ayrılan dizgenin karakter sayısıdır; dizge için yer ayrılamadığı durumlarda ve hata durumunda sıfırdan küçük bir değerle döner.
      </para><para>
Aşağıdaki örnekte, <command>snprintf</command> örneğindeki sonucun <command>asprintf</command> kullanarak nasıl elde edildiği gösterilmektedir:
    </para><para>
<screen>
/*  <varname>isim</varname> isminde ve <varname>deger</varname> değerinde
    bir değişkenin değerini açıklayan bir ileti oluşturalım. */
char *
ileti_yap (char *isim, char *deger)
{
  char *sonuc;
  if (asprintf (&amp;sonuc, &quot;%s değişkeninin değeri %s'dir&quot;, isim, deger) &lt; 0)
    return NULL;
  return sonuc;
}
</screen>
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-obstack_printf">
<indexterm scope="glibc-fn"><primary>obstack_printf</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>obstack_printf</command></funcdef>
<paramdef>(struct obstack *<varname>yığınak</varname>,
 const char     *<varname>şablon</varname>,
 …)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev, alan ayırmak için <varname>yığınak</varname> yığınağını kullanması dışında <command>asprintf</command> işlevinin benzeridir. Yığınaklarla ilgili bilgi için <xref linkend="glibc-Obstacks"/> bölümüne bakınız.
      </para><para>
Karakterler nesnenin sonuna yazılır. Onları almak için nesneyi <command>obstack_finish</command> ile bitirmelisiniz. Bkz. <xref linkend="glibc-Growing-Objects"/>.
      </para></funcdescr></funcsynopsis>
    </para>
  </sect1>
  <sect1 xml:id="glibc-Variable-Arguments-Output">
    <title>Değişkin Çıktı İşlevleri</title>
    <titleabbrev><command>vprintf</command> ve arkadaşları.</titleabbrev>
    <para>
Yerleşik biçimli çıktı işlevleri olarak <command>printf</command> oluşumunu kullanarak kendi değişkin <command>printf</command> benzeri işlevlerinizi tanımlayabilmeniz için <command>vprintf</command> işlevi ve arkadaşları oluşturulmuştur.
    </para><para>
Bu tür işlevleri tanımlamanın en doğal yolu, "<command>printf</command> işlevini çağır ve bu şablonla birlikte ilk 5 argümandan sonra benim argümanlarımı aktar" diyecek bir dil yapısı kullanmak olurdu. Fakat C'de bunu yapmanın bir yolu yoktur. Ayrıca üçüncü düzey C dilinde işlevinizin kaç argüman aldığını söyleyecek bir yol olmadığından, bir yol üretmek de zor olurdu.
    </para><para>
Bu yöntemle mümkün olmadığından "ilk 5 argümandan sonra benim argümanlarımı aktar" diyebileceğiniz bir <command>va_list</command>'i aktaracağınız bir seri işlev, <command>vprintf</command> serisini ürettik.
    </para><para>
Gerçek bir işlev yerine bir makro tanımlamak yeterli olduğundan, GNU C derleyicisi bunu makrolarla çok daha kolay yapacak bir yol sağlar. Örneğin:
    </para><para>
<screen>
#define myprintf(a, b, c, d, e, rest...) \
         printf (mytemplate , ## rest)
</screen></para><para>
Değişken sayıda argümanlı makrolar hakkında ayrıntılı bilgi edinmek için GCC info'sundaki "Macros with Variable Numbers of Arguments" (Değişken sayıda argümanlı makrolar) bölümüne bakınız. Bu yol sadece makrolara ayrılmıştır, gerçek işlevlere uygulanmaz.
    </para><para>
<command>vprintf</command> veya bu bölümde listelenmiş diğer işlevleri çağırmadan önce değişken sayıdaki argümanı ilklendirmek için bir <command>va_start</command> çağrısı (<xref linkend="glibc-Variadic-Functions"/>) yapmalısınız. Sonra da kendinizin elde etmek istediğiniz argümanları almak için <command>va_arg</command> çağrıları yapmalısınız.
    </para><para>
<command>va_list</command> göstericinize seçtiğiniz ilk argümanı gösterdikten sonra bir <command>vprintf</command> çağrısı yapmaya hazırsınız demektir. İşlevinizle aktardığınız bu argüman ve artbileşen argümanlar ile belirttiğiniz şablon dizgesi <command>vprintf</command> işlevi tarafından kullanılacaktır.
    </para><para>
Diğer sistemlerde <command>vprintf</command> çağrısından sonra <command>va_list</command> göstericisi geçersiz duruma gelebilir ve <command>vprintf</command> çağrısından sonra <command>va_arg</command> işlevini kullanamayabilirsiniz. Bu durumda bir <command>va_end</command> çağrısından sonra <command>va_start</command> ile göstericiyi yeniden almalısınız. <command>vprintf</command> işlevi işlevinizin argüman listesini ortadan kaldırmaz.
    </para><para>
GNU C böyle sınırlamalara sahip değildir. <command>va_list</command> göstericisini <command>vprintf</command> çağrısına aktardıktan sonra bu göstericiyi kullanarak argümanları almaya devam edebilirsiniz ve <command>va_end</command> çağrısı da hiçbir işlem yapmaz. (<command>vprintf</command> çağrısından sonra yaptığınız <command>va_arg</command> çağrıları ile alınan argümanlar <command>vprintf</command> çağrısındaki argümanlarla aynıdır.)
    </para><para>
Bu işlevlerin prototipleri <filename>stdio.h</filename> başlık dosyasında bildirilmiştir.
<indexterm scope="glibc-pg"><primary>stdio.h</primary></indexterm>
    </para><para xml:id="glibc-vprintf">
<indexterm scope="glibc-fn"><primary>vprintf</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>vprintf</command></funcdef>
<paramdef>(const char *<varname>şablon</varname>,
 va_list     <varname>arglist-gstr</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev değişken sayıdaki argümanlarını doğrudan almak yerine <varname>arglist-gstr</varname> argüman listesi göstericisinden alması dışında <command>printf</command> ile aynıdır.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-vwprintf">
<indexterm scope="glibc-fn"><primary>vwprintf</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>vwprintf</command></funcdef>
<paramdef>(const wchar_t *<varname>şablon</varname>,
 va_list        <varname>arglist-gstr</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev değişken sayıdaki argümanlarını doğrudan almak yerine <varname>arglist-gstr</varname> argüman listesi göstericisinden alması dışında <command>wprintf</command> ile aynıdır.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-vfprintf">
<indexterm scope="glibc-fn"><primary>vfprintf</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>vfprintf</command></funcdef>
<paramdef>(FILE       *<varname>akım</varname>,
 const char *<varname>şablon</varname>,
 va_list     <varname>arglist-gstr</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev değişken sayıdaki argümanlarını doğrudan almak yerine <varname>arglist-gstr</varname> argüman listesi göstericisinden alması dışında <command>vprintf</command> ile aynıdır.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-vfwprintf">
<indexterm scope="glibc-fn"><primary>vfwprintf</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>vfwprintf</command></funcdef>
<paramdef>(FILE          *<varname>akım</varname>,
 const wchar_t *<varname>şablon</varname>,
 va_list        <varname>arglist-gstr</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev değişken sayıdaki argümanlarını doğrudan almak yerine <varname>arglist-gstr</varname> argüman listesi göstericisinden alması dışında <command>vwprintf</command> ile aynıdır.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-vsprintf">
<indexterm scope="glibc-fn"><primary>vsprintf</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>vsprintf</command></funcdef>
<paramdef>(char       *<varname>s</varname>,
 const char *<varname>şablon</varname>,
 va_list     <varname>arglist-gstr</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev değişken sayıdaki argümanlarını doğrudan almak yerine <varname>arglist-gstr</varname> argüman listesi göstericisinden alması dışında <command>sprintf</command> ile aynıdır.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-vswprintf">
<indexterm scope="glibc-fn"><primary>vswprintf</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>vswprintf</command></funcdef>
<paramdef>(wchar_t       *<varname>s</varname>,
 size_t         <varname>boyut</varname>,
 const wchar_t *<varname>şablon</varname>,
 va_list        <varname>arglist-gstr</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev değişken sayıdaki argümanlarını doğrudan almak yerine <varname>arglist-gstr</varname> argüman listesi göstericisinden alması dışında <command>swrintf</command> ile aynıdır.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-vsnprintf">
<indexterm scope="glibc-fn"><primary>vsnprintf</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>vsnprintf</command></funcdef>
<paramdef>(char       *<varname>s</varname>,
 size_t      <varname>boyut</varname>,
 const char *<varname>şablon</varname>,
 va_list     <varname>arglist-gstr</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev değişken sayıdaki argümanlarını doğrudan almak yerine <varname>arglist-gstr</varname> argüman listesi göstericisinden alması dışında <command>snprintf</command> ile aynıdır.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-vasprintf">
<indexterm scope="glibc-fn"><primary>vasprintf</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>vasprintf</command></funcdef>
<paramdef>(char      **<varname>gstr</varname>,
 const char *<varname>şablon</varname>,
 va_list     <varname>arglist-gstr</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev değişken sayıdaki argümanlarını doğrudan almak yerine <varname>arglist-gstr</varname> argüman listesi göstericisinden alması dışında <command>vasprintf</command> ile aynıdır.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-obstack_vprintf">
<indexterm scope="glibc-fn"><primary>obstack_vprintf</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>obstack_vprintf</command></funcdef>
<paramdef>(struct obstack *<varname>yığınak</varname>,
 const char     *<varname>şablon</varname>,
 va_list         <varname>arglist-gstr</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev değişken sayıdaki argümanlarını doğrudan almak yerine <varname>arglist-gstr</varname> argüman listesi göstericisinden alması dışında <command>obstack_vprintf</command> ile aynıdır.
      </para></funcdescr></funcsynopsis>
    </para><para>
Aşağıda <command>vfprintf</command> kullanılan bir örnek vardır. Örnekteki işlev yazılımın ismi ile önceleyerek standart hataya bir ileti basmaktadır. (<command>program_invocation_short_name</command> değişkeninin açıklamaları için <xref linkend="glibc-Error-Messages"/> bölümüne bakınız.)
    </para><para><screen>
#include &lt;stdio.h>
#include &lt;stdarg.h>

void
eprintf (const char *sablon, ...)
{
  va_list ap;
  extern char *program_invocation_short_name;

  fprintf (stderr, &quot;%s: &quot;, program_invocation_short_name);
  va_start (ap, sablon);
  vfprintf (stderr, sablon, ap);
  va_end (ap);
}
     </screen></para><para>
       <command>eprintf</command> işlevi şöyle çağrılabilir:
    </para><para>
<screen>
eprintf (&quot;`%s' diye bir dosya yok\n&quot;, filename);
</screen></para><para>
GNU C'de <command>printf</command> tarzı biçim dizgesi kullanan bir işlevi derleyiciye bildirebileceğiniz özel bir yapı vardır. Bu yapı kullanıldığında işlevin her çağrısı için kullanılan argümanların türleri ve sayısı denetlenir ve biçim dizgesiyle eşleşmeyenler için sizi uyarır. Örneğin, bu yapıyı <command>eprintf</command> için şöyle kullanabilirsiniz:
    </para><para>
<screen>
void eprintf (const char *sablon, ...)
        __attribute__ ((format (printf, 1, 2)));
</screen></para><para>
Bu kod parçası derleyiciye <command>eprintf</command> işlevinin ilk argümanının <command>printf</command> biçim dizgesi olarak, biçim dizgesini oluşturan diğer argümanların başlangıcının ikinci argüman olarak kullanıldığını söyler. İşlev özniteliklerinin bildirilmesi ile ilgili ayrıntılı bilgi edinmek için GCC kılavuzunun (info) "Declaring Attributes of Functions" (İşlevlerin Özniteliklerinin Bildirilmesi) bölümüne bakınız.
    </para>
  </sect1>
  <sect1 xml:id="glibc-Parsing-a-Template-String">
    <title>Bir Şablon Dizgesinin Çözümlenmesi</title>
    <titleabbrev>Bir şablon dizgesinde çeşitli argümanlar neler yapar?</titleabbrev>
<indexterm scope="glibc-cp"><primary>biçimli çıktı</primary><secondary>şablon dizgesinin çözümlenmesi</secondary></indexterm>
    <para>
<command>parse_printf_format</command> işlevini kullanarak bir şablon dizgesindeki dönüşüm belireteçlerinin karşılığı olan argümanların sayısı ve türü hakkında bilgi alabilirsiniz. Bu işlevi kullanarak kullanıcının uygulamadan geçersiz argümanlar girerek bir çökmeye sebep olmasından kaçınmak için <command>printf</command>'e bir arayüz oluşturabilirsiniz.
    </para><para>
Bu bölümde açıklanan tüm işlevler <filename>printf.h</filename> başlık dosyasında bildirilmiştir.
    </para><para xml:id="glibc-parse_printf_format">
<indexterm scope="glibc-fn"><primary>parse_printf_format</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>size_t <command>parse_printf_format</command></funcdef>
<paramdef>(const char *<varname>şablon</varname>,
 size_t      <varname>n</varname>,
 int        *<varname>argtürleri</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev <varname>şablon</varname> biçim dizgesi tarafından kullanılacak  argümanların sayısı ve türleri hakkında bilgi ile döner. Bu bilgi her elemanı bir argüman için olmak üzere <varname>argtürleri</varname> dizisine kaydedilir. Bu bilgi aşağıda listelenen çeşitli <command>PA_</command> makroları kullanılarak kodlanır.
      </para><para>
<varname>n</varname> argümanı ile <varname>argtürleri</varname> dizisindeki eleman sayısı belirtilir. Bu sayı, <command>parse_printf_format</command> işlevinin yazmayı deneyeceği en çok eleman sayısıdır.
      </para><para>
<command>parse_printf_format</command> işlevi <varname>şablon</varname> dizgesinin gerektirdiği argüman sayısı ile döner. Bu sayı <varname>n</varname> ile belirtilenden büyükse dönen bilgi sadece ilk <varname>n</varname> argüman içindir. Tüm argümanlar için bilgi almak isterseniz, daha büyük bir dizi ayırıp işlevi tekrar çağırmayı denemelisiniz.
      </para></funcdescr></funcsynopsis>
    </para><para>
Argüman türleri temel türlerin ve tür değiştirici parametrelerinin bir birleşimi olarak kodlanır.
    </para><para xml:id="glibc-PA_FLAG_MASK">
<indexterm scope="glibc-vr"><primary>PA_FLAG_MASK</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>int <command>PA_FLAG_MASK</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu makro tür değiştirici seçenek bitleri için bir bit maskesidir. Bir argümanın seçenek bitlerini çıkarmak için <command>(argturleri[i]  PA_FLAG_MASK)</command> ifadesini, temel tür kodunu çıkarmak için <command>(argturleri[i]  ~PA_FLAG_MASK)</command> ifadesini yazabilirsiniz.
      </para><para>
Tamsayı değerler olarak temel türleri ifade eden sembolik sabitler:
      </para><para>
        <variablelist><varlistentry><term><literal>PA_INT</literal></term>
          <listitem><para>
<command>int</command> temel türünü belirtir.
          </para></listitem>
        </varlistentry><varlistentry><term><literal>PA_CHAR</literal></term>
          <listitem><para>
<command>char</command> türüne dönüşen <command>int</command> temel türünü belirtir.
          </para></listitem>
        </varlistentry><varlistentry><term><literal>PA_STRING</literal></term>
          <listitem><para>
Bir boş karakter sonlandırmalı dizge gösteren <command>char *</command> temel türünü belirtir.
          </para></listitem>
        </varlistentry><varlistentry><term><literal>PA_POINTER</literal></term>
          <listitem><para>
Herhangi bir gösterici olarak <command>void *</command> temel türünü belirtir.
          </para></listitem>
        </varlistentry><varlistentry><term><literal>PA_FLOAT</literal></term>
          <listitem><para>
<command>float</command> temel türünü belirtir.
          </para></listitem>
        </varlistentry><varlistentry><term><literal>PA_DOUBLE</literal></term>
          <listitem><para>
<command>double</command> temel türünü belirtir.
          </para></listitem>
        </varlistentry><varlistentry><term><literal>PA_LAST</literal></term>
          <listitem><para>
Kendi yazılımınız için <command>PA_LAST</command>'ın artan değerleri olarak ek temel türler tanımlayabilirsiniz. Örneğin, <command>foo</command> ve <command>bar</command> veri türlerinin kodlamasını kendi özelleştirilmiş <command>printf</command> dönüşümleri ile şöyle tanımlamalısınız:
          </para><para>
<screen>
#define PA_FOO  PA_LAST
#define PA_BAR  (PA_LAST + 1)
</screen></para></listitem>
        </varlistentry></variablelist>
      </para><para>
Aşağıdaki bir temel türü değiştiren seçenek bitleri listelenmiştir. Bunları temel türlerle VEYA'lanarak birleştirilebilir.
      </para><para>
        <variablelist><varlistentry><term><literal>PA_FLAG_PTR</literal></term>
          <listitem><para>
Bu bit 1 ise kodlanan türün bir değere değil temel türe bir gösterici olduğunu belirtir. Örneğin, <command>PA_INT|PA_FLAG_PTR</command> ifadesi <command>int *</command> türü içindir.
          </para></listitem>
        </varlistentry><varlistentry><term><literal>PA_FLAG_SHORT</literal></term>
          <listitem><para>
Bu bit 1 ise temel türün <command>short</command> ile değiştirildiğini belirtir. (Bu <command>h</command> tür değiştiricisine karşılıktır.)
          </para></listitem>
        </varlistentry><varlistentry><term><literal>PA_FLAG_LONG</literal></term>
          <listitem><para>
Bu bit 1 ise temel türün <command>long</command> ile değiştirildiğini belirtir. (Bu <command>l</command> tür değiştiricisine karşılıktır.)
          </para></listitem>
        </varlistentry><varlistentry><term><literal>PA_FLAG_LONG_LONG</literal></term>
          <listitem><para>
Bu bit 1 ise temel türün <command>long long</command> ile değiştirildiğini belirtir. (Bu <command>L</command> tür değiştiricisine karşılıktır.)
          </para></listitem>
        </varlistentry><varlistentry><term><literal>PA_FLAG_LONG_DOUBLE</literal></term>
          <listitem><para>
Bu <command>PA_FLAG_LONG_LONG</command> ile eşanlamlıdır ve teamülen <command>long double</command> türü belirten <command>PA_DOUBLE</command> temel türü ile kullanılır.
          </para></listitem>
        </varlistentry></variablelist>
      </para></funcdescr></funcsynopsis>
    </para>
  </sect1>
  <sect1 xml:id="glibc-Example-of-Parsing">
    <title>Bir Şablon Dizgesinin Çözümlenmesi Örneği</title>
    <titleabbrev><command>parse_printf_format</command> kullanılan bir örnek.</titleabbrev>
    <para>
Bu örnekte bir biçim dizgesi için gereken argüman türleri çözümlenmektedir. Bu örneğe özel olarak argüman türlerini <command>NUMBER</command>, <command>CHAR</command>, <command>STRING</command> ve <command>STRUCTURE</command> isimleri ile sınıflandırdık (başka türlerde var tabii ama bu sadece bir örnek).
    </para><para>
<screen>
/* Belirtilen narg adet nesne şablon dizgesi için
   geçerli mi, değil mi?
   Geçerliyse 1,
   değilse 0 dönsün ve bir hata iletisi bassın.  */

int
validate_args (char *sablon, int nargs, OBJECT *args)
{
  int *argturleri;
  int ngereken;

  /* Argümanlar hakkında bilgi alalım.
     Her dönüşüm belirtimi en az iki karakterlik olmalı,
     o halde dizgenin yarı uzunluğundan daha fazla sayıda
     belirtim olamaz.  */

  argturleri = (int *) alloca (strlen (sablon) / 2 * sizeof (int));
  ngereken = parse_printf_format (sablon, nargs, argturleri);

  /* Argüman sayısına bakalım.  */
  if (ngereken > nargs)
  {
    error ("argüman sayısı çok az (en az %d argüman gerekiyor)", ngereken);
    return 0;
  }

  /* Her argüman için istenen C türüne bakalım
     ve verilen nesne uygun mu görelim.  */
  for (i = 0; i &lt; ngereken; i++)
  {
    int istenen;

    if (argturleri[i] &amp; PA_FLAG_PTR)
      istenen = STRUCTURE;
    else
      switch (argturleri[i] &amp; ~PA_FLAG_MASK)
      {
        case PA_INT:
        case PA_FLOAT:
        case PA_DOUBLE:
          istenen = NUMBER;
          break;
        case PA_CHAR:
          istenen = CHAR;
          break;
        case PA_STRING:
          istenen = STRING;
          break;
        case PA_POINTER:
          istenen = STRUCTURE;
          break;
      }
    if (TYPE (args[i]) != istenen)
    {
      error ("%d. argümanın türü uygun değil", i);
      return 0;
    }
  }
  return 1;
}
</screen></para></sect1></chapter>

<chapter xml:id="glibc-Customizing-Printf">
  <title><literal>printf</literal> İşlevinin Özelleştirilmesi</title>
  <titleabbrev><command>printf</command> ve arkadaşları için yeni dönüşüm belirtimleri
  tanımlayabilirsiniz.</titleabbrev>
  <para>
<indexterm scope="glibc-cp"><primary>biçimli çıktı</primary><secondary>özelleştirilmesi</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>biçimli çıktı</primary><secondary>dönüşüm belirtimleri</secondary><tertiary>yenisini tanımlama</tertiary></indexterm>
GNU C kütüphanesi uygulamanızın önemli veri yapılarını basacak becerikli yöntemleri <command>printf</command>'e öğretecek özelleştirilmiş dönüşüm belirteçleri tanımlamanızı mümkün kılar.
  </para><para>
Bunu yapmanın yolu <command>register_printf_function</command> işlevini kullanarak dönüşümleri kaydetmektir; Bkz. <xref linkend="glibc-Registering-New-Conversions"/>. Bu işleve aktaracağınız argümanlardan biri asıl çıktılamayı yapacak olan işleve bir gösterici olacaktır; bu işlevin nasıl yazılacağı  <xref linkend="glibc-Defining-the-Output-Handler"/> bölümünde anlatılmıştır.
  </para><para>
Ayrıca tanımladığınız dönüşüm belirteçleri tarafından kullanılacak argümanların sayısı ve türü hakkında bilgi veren bir işlev de yazabilirsiniz; bu konu için <xref linkend="glibc-Parsing-a-Template-String"/> bölümüne bakınız.
  </para><para>
Bu kısımda sözü edilen oluşumlar <filename>printf.h</filename> başlık dosyasında tanımlanmıştır.
  </para><para>
<note><title>Taşınabilirlik Bilgisi:</title><para>
<command>printf</command> şablon dizgesi sözdiziminin geliştirilebilirlik özelliği bir GNU oluşumudur. ISO C standardında buna benzer birşey yoktur.
</para></note>
  </para>
  <sect1 xml:id="glibc-Registering-New-Conversions">
    <title>Yeni Dönüşümlerin Kaydı</title>
    <titleabbrev><command>register_printf_function</command> ile yeni dönüşüm belirteçlerinizi kaydedin.</titleabbrev>
    <para>
<dicterm><english>register</english><turkish>yazmaç</turkish></dicterm>
<command>register_printf_function</command> işlevi <filename>printf.h</filename>  başlık dosyasında bildirilmiştir ve yeni tanımladığınız bir dönüşüm belirtecini kaydetmek için kullanılır.
<indexterm scope="glibc-pg"><primary>printf.h</primary></indexterm>
    </para><para xml:id="glibc-register_printf_function">
<indexterm scope="glibc-fn"><primary>register_printf_function</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>register_printf_function</command></funcdef>
<paramdef>(int                     <varname>belirteç</varname>,
 printf_function         <varname>kotarıcı-işlev</varname>,
 printf_arginfo_function <varname>argtürleri-işlevi</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev <varname>belirteç</varname> dönüşüm belirteç karakterini tanımlar. Eğer <varname>belirteç</varname> <command>'Y'</command> ise dönüşüm belirteci <command>%Y</command> olacaktır. <command>%s</command> gibi yerleşik dönüşüm belirteçlerini de tanımlayabilirsiniz ama <command>#</command> gibi im karakterlerini <command>l</command> gibi tür değiştiricileri dönüşüm karakteri olarak tanımlayamazsınız. İşlevi bu karakterlerden biri ile çağırırsanız hiçbir etkisi olmaz. Küçük harfleri dönüşüm karakteri olarak tanımlamasanız iyi olur, çünkü ISO C standardı, standardın gelecekteki iyileştirmelerinde başka küçük harflerin de standarda dahil edebileceği konusunda uyarıyor.
      </para><para>
<varname>kotarıcı-işlev</varname>, bir şablon dizgesinde tanımladığınız  karakterlerlerden birine rastlarsa <command>printf</command> ve arkadaşları tarafından çağrılacak işlevdir. İşleve argüman olarak atanan böyle bir işlevin nasıl tanımlanacağı <xref linkend="glibc-Defining-the-Output-Handler"/> bölümünde açıklanmıştır. Bu argüman bir boş gösterici belirtirseniz, <varname>belirteç</varname> için atanan kotarıcı işlevi kaldırılacaktır.
      </para><para>
<varname>argtürleri-işlevi</varname> ise, bu dönüşüm belirteci bir şablon dizgesinde kullanıldığında <command>parse_printf_format</command> işlevi tarafından çağrılır. Bu konu hakkında daha ayrıntılı bilgi almak için <xref linkend="glibc-Parsing-a-Template-String"/> bölümüne bakınız.
      </para><para>
<caution><para>GNU C kütüphanesinin 2.0 öncesi sürümlerinde <varname>argtürleri-işlevi</varname> işlevinin <command>parse_printf_format</command> işlevi çağrılmadıkça tanımlanması gerekmiyordu. Bu şimdi değişti. Artık, dönüşüm belirteci şablon dizgesinde kullanılmışsa her <command>printf</command> çağrısında bu işlev çağrılmaktadır.</para></caution>
      </para><para>
İşlev başarı durumunda <command>0</command> ile döner. Hata oluşması halinde (<varname>belirteç</varname> aralık dışındaysa) <command>-1</command> ile döner.
      </para><para>
Standart dönüşüm belirteçlerini de yeniden tanımlayabilirseniz de, karışıklığa yol açma olasılığından dolayı iyi bir fikir olmayacaktır. Başkaları tarafından yazılış kütüphane işlevleri bunu yaparsanız hata verebilir.
      </para></funcdescr></funcsynopsis>
    </para>
  </sect1>
  <sect1 xml:id="glibc-Conversion-Specifier-Options">
    <title>Dönüşüm Belirteci Seçenekleri</title>
    <titleabbrev>Bir şablonda belirtilmiş seçenekler için bir yapı olabilir.</titleabbrev>
    <para>
Bir dönüşüm belirteci olarak <command>%A</command> tanımladınız diyelim, bir şablon örneğin, <command>%+23A</command> veya <command>%-#A</command> içeriyorsa ne olacak? Dönüşüm belirteçleri ile birlikte verilen seçenekleri tanımlayacağınız bir yapı olabilir.
    </para><para>
Hem <varname>kotarıcı-işlev</varname> hem de <varname>argtürleri-işlevi</varname> bir dönüşüm belirtecinde görülen seçenekler hakkında bilgi içeren bir <command>struct printf_info</command> yapısına gösterici alır. Bu veri türü <filename>printf.h</filename> başlık dosyasında bildirilmiştir.
<indexterm scope="glibc-pg"><primary>printf.h</primary></indexterm>
    </para><para xml:id="glibc-struct-printf_info">
<indexterm scope="glibc-tp"><primary sortas="printf_info">struct printf_info</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü">
<funcdef>struct <command>printf_info</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu yapı bir şablon dizgesindeki dönüşüm belirteçleri için kullanılan argüman türleri ve sayıları hakkında bilgi veren ve bu belirteçleri çıktılayan işlevlere bilgi aktarmak için kullanılır. Yapı üyeleri şunlardır:
      </para><para>
        <glosslist><glossentry>
          <glossterm><literal>int </literal> <command>prec</command></glossterm>
          <glossdef><para>
Belirtilen hassasiyettir. Hassasiyet belirtilmemişse değeri <command>-1</command>’dir. Hassasiyet <command>*</command> olarak verilmişse, kotarıcı işleve aktarılan <command>printf_info</command> yapısı argüman listesinden alınan değeri içerir. Ancak argüman türleri ve sayısı için bilgi veren işleve aktarılan yapı, değer bilinmediğinden bir <command>INT_MIN</command> değeri içerir.
          </para></glossdef></glossentry><glossentry>
          <glossterm><literal>int </literal> <command>width</command></glossterm>
          <glossdef><para>
Belirtilen en küçük alan genişliğidir. <command>0</command> değeri bir genişlik belirtilmediği anlamına gelir. Alan genişliği <command>*</command> olarak verilmişse, kotarıcı işleve aktarılan <command>printf_info</command> yapısı argüman listesinden alınan değeri içerir. Ancak argüman türleri ve sayısı için bilgi veren işleve aktarılan yapı, değer bilinmediğinden bir <command>INT_MIN</command> değeri içerir.
          </para></glossdef></glossentry><glossentry>
          <glossterm><literal>wchar_t </literal> <command>spec</command></glossterm>
          <glossdef><para>
Belirtilen dönüşüm belirteci karakteridir. Bunun yapı içinde bulunmasının sebebi çok sayıda karaktere aynı kotarıcı işlevi kaydedebilmenizi sağlamaktır, ancak bu olmasa bile kotarıcı işlevi çağırdığınızda onları ayıracak bir yol vardır.
          </para></glossdef></glossentry><glossentry>
          <glossterm><literal>unsigned int </literal> <command>is_long_double</command></glossterm>
          <glossdef><para>
<command>L</command>, <command>ll</command> veya <command>q</command> tür değiştiricileri belirtilmişse değeri mantıksal değer olarak doğrudur. Gerçek sayı dönüşümlerinde bu <command>long double</command> iken tamsayı dönüşümlerinde bir <command>long long int</command>’tir.
          </para></glossdef></glossentry><glossentry>
          <glossterm><literal>unsigned int </literal> <command>is_char</command></glossterm>
          <glossdef><para>
<command>hh</command> tür değiştiricisi belirtilmişse değeri mantıksal değer olarak doğrudur.
          </para></glossdef></glossentry><glossentry>
          <glossterm><literal>unsigned int </literal> <command>is_short</command></glossterm>
          <glossdef><para>
<command>h</command> tür değiştiricisi belirtilmişse değeri mantıksal değer olarak doğrudur.
          </para></glossdef></glossentry><glossentry>
          <glossterm><literal>unsigned int </literal> <command>is_long</command></glossterm>
          <glossdef><para>
<command>l</command> tür değiştiricisi belirtilmişse değeri mantıksal değer olarak doğrudur.
          </para></glossdef></glossentry><glossentry>
          <glossterm><literal>unsigned int </literal> <command>alt</command></glossterm>
          <glossdef><para>
<command>#</command> imi belirtilmişse değeri mantıksal değer olarak doğrudur.
          </para></glossdef></glossentry><glossentry>
          <glossterm><literal>unsigned int </literal> <command>space</command></glossterm>
          <glossdef><para>
<command>(boşluk karakteri)</command> imi belirtilmişse değeri mantıksal değer olarak doğrudur.
          </para></glossdef></glossentry><glossentry>
          <glossterm><literal>unsigned int </literal> <command>left</command></glossterm>
          <glossdef><para>
<command>-</command> imi belirtilmişse değeri mantıksal değer olarak doğrudur.
          </para></glossdef></glossentry><glossentry>
          <glossterm><literal>unsigned int </literal> <command>showsign</command></glossterm>
          <glossdef><para>
<command>+</command> imi belirtilmişse değeri mantıksal değer olarak doğrudur.
          </para></glossdef></glossentry><glossentry>
          <glossterm><literal>unsigned int </literal> <command>group</command></glossterm>
          <glossdef><para>
<command>'</command> imi belirtilmişse değeri mantıksal değer olarak doğrudur.
          </para></glossdef></glossentry><glossentry>
          <glossterm><literal>unsigned int </literal> <command>extra</command></glossterm>
          <glossdef><para>
Bu üyenin değerinin bağlama özgü bir anlamı vardır. Yapı <command>printf</command> işlevi tarafından kullanılmışsa değeri <command>0</command>’dır. Kullanıcı tarafından tanımlanmış bir işlev tarafından kullanıldığında ise herhangi bir değer içerebilir.
          </para></glossdef></glossentry><glossentry>
          <glossterm><literal>unsigned int </literal> <command>wide</command></glossterm>
          <glossdef><para>
Akım geniş yönlenimli ise bu üyenin değeri <command>1</command>’dir.
          </para></glossdef></glossentry><glossentry>
          <glossterm><literal>wchar_t </literal> <command>pad</command></glossterm>
          <glossdef><para>
Çıktıda en küçük alan genişliğinde boş kalan yerlere yerleştirilecek karakterdir. Boş kalan yerler sıfırlarla doldurulursa bu üyenin değeri <command>'0'</command>’dır, aksi takdirde boşluktur (<command>' '</command>).
          </para></glossdef>
        </glossentry></glosslist>
      </para></funcdescr></funcsynopsis>
    </para>
  </sect1>
  <sect1 xml:id="glibc-Defining-the-Output-Handler">
    <title>Kotarıcı İşlevin Tanımlanması</title>
    <titleabbrev><command>register_printf_function</command> işlevine aktarılacak kotarıcı işlev ile argüman bilgileri işlevinin tanımlanması.</titleabbrev>
    <para>
Şimdi <literal>register_printf_function</literal> işlevine aktarılacak kotarıcı işlev ile argüman bilgileri işlevinin nasıl tanımlanacağına bakalım.
    </para><para>
<note><title>Uyumluluk Bilgisi:</title><para>Arayüz GNU libc 2.0 sürümünde değiştirilmiştir. Bundan önce üçüncü argümanın türü <command>va_list *</command> idi.</para></note>
    </para><para>
Kotarıcı işlevi bu prototipin benzeri olarak bildirebilirsiniz.:
    </para><para>
<literallayout>
int <varname>işlev-ismi</varname> (FILE                     *<varname>akım</varname>,
             const struct printf_info *<varname>bilgi</varname>,
             const void *const        *<varname>args</varname>)
</literallayout></para><para>
<varname>akım</varname> argümanı, kotarıcı işlevin çıktıyı yazacağı akımdır.
    </para><para>
<varname>bilgi</varname> argümanı, şablon dizgesindeki belirteç ile birlikte belirtilen çeşitli seçenekler hakkında bilgi içeren bir yapının göstericisidir. Bu veri yapısını kotarıcı işlevin içinde değiştirmemelisiniz. Bu veri yapısının açıklamaları için <xref linkend="glibc-Conversion-Specifier-Options"/> bölümüne bakınız.
    </para><para>
<varname>args</varname> argüman sayısının atanacağı göstericidir. Argüman sayısı, yazılımcı tarafından tanımlanan argüman bilgileri işlevi çağrılarak elde edilir.
    </para><para>
Sizin kotarıcı işleviniz de tıpkı <command>printf</command> işlevi gibi değer döndürmelidir: Ya çıktılanan karakterlerin sayısı ile dönmeli ya da hata durumunda hatayı ifade eden negatif bir değer ile dönmelidir.
    </para><para xml:id="glibc-type-printf_function">
<indexterm scope="glibc-tp"><primary>printf_function</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü">
<funcdef><command>printf_function</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu, kotarıcı işlevin türüdür.
      </para></funcdescr></funcsynopsis>
    </para><para>
Yazılımınızda <command>parse_printf_format</command> işlevini kullanacaksanız, <command>register_printf_function</command> ile tanımlayacağınız her dönüşüm belirteci için <varname>argtürleri-işlevi</varname> argümanı ile aktaracağınız işlevi de tanımlamalısınız.
    </para><para>
Bu işlevleri buna benzer bir prototiple bildirebilirsiniz:
    </para><para>
<literallayout>
int <varname>işlev-ismi</varname> (const struct printf_info *<varname>bilgi</varname>,
             size_t                    <varname>n</varname>,
             int                      *<varname>argtürleri</varname>)
</literallayout></para><para>
İşlevden dönen değer, dönüşümü umulan argümanların sayısı olmalıdır. İşlev ayrıca bu argümanların herbiri için tür bilgisini içeren en çok <varname>n</varname> elemanlı <varname>argtürleri</varname>  dizisini de doldurmalıdır. Bu bilgi <command>PA_</command> makroları kullanılarak kodlanır. (Bu, <command>parse_printf_format</command> işlevinin kullandığı çağrı ile aynı yapıdaysa uyarılacaksınız.)
    </para><para xml:id="printf_arginfo_function">
<indexterm scope="glibc-tp"><primary>printf_arginfo_function</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü">
<funcdef><command>printf_arginfo_function</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Dönüşüm belirteçleri tarafından kullanılan argümanların türleri, seçenekleri ve sayıları hakkında bilgi döndüren işlevin türüdür.
      </para></funcdescr></funcsynopsis>
    </para>
  </sect1>
  <sect1 xml:id="glibc-Printf-Extension-Example">
    <title><literal>printf</literal> Genişletme Örneği</title>
    <titleabbrev>Bir <command>printf</command> kotarıcı işlevi nasıl tanımlanır.</titleabbrev>
    <para>
Burada bir <literal>printf</literal> kotarıcı işlevinin nasıl tanımlandığı örneklenmiştir. Bu yazılım <command>Kitap</command> isimli bir veri yapısı ve <command>Kitap *</command> argümanları hakkında bilgi basacak <command>%K</command> dönüşüm belirtecini tanımlar. <command>%K</command> dönüşüm belirteci en küçük alan genişliği ile sola yanaştırma imini desteklemekte diğer herşeyi yoksaymaktadır.
    </para><para>
<screen>
#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;printf.h>

typedef struct
{
  char *isim;
}
Kitap;

int
kitap_bas (FILE *akim,
              const struct printf_info *bilgi,
              const void *const *args)
{
  const Kitap *k;
  char *tampon;
  int uzunluk;

  /* Bir dizgeye çıktılanacak biçim. */
  k = *((const Kitap **) (args[0]));
  uzunluk = asprintf (&amp;tampon, &quot;&lt;Kitap %p: %s>&quot;, k, k->isim);
  if (uzunluk == -1)
    return -1;

  /* En küçük alan genişliğini doldurup akıma basalım. */
  uzunluk = fprintf (akim, &quot;%*s&quot;,
                 (info->left ? -info->width : info->width),
                 tampon);

  /* Ortalığı temizle ve dön. */
  free (tampon);
  return uzunluk;
}


int
kitap_bas_argbilgi (const struct printf_info *bilgi, size_t n,
                      int *argturleri)
{
  /* Daima tek bir argüman alıyoruz ve bu yapı için bir gösterici
     oluyor.. */
  if (n > 0)
    argturleri[0] = PA_POINTER;
  return 1;
}


int
main (void)
{
  /* Basılacak Kitabı oluşturalım. */
  Kitap kitabim;
  kitabim.isim = &quot;Kitabım&quot;;

  /* Kitap için kotarıcı işlevi kaydedelim. */
  register_printf_function ('K', kitap_bas, kitap_bas_argbilgi);

  /* Şimdi kitabimi basalım. */
  printf (&quot;|%K|\n&quot;, &amp;kitabim);
  printf (&quot;|%35K|\n&quot;, &amp;kitabim);
  printf (&quot;|%-35K|\n&quot;, &amp;kitabim);

  return 0;
}
</screen></para><para>
Yazılımın çıktısı şöyle olacaktır:
    </para><para>
<screen>
|&lt;Kitap 0xffeffb7c: Kitabım>|
|        &lt;Kitap 0xffeffb7c: Kitabım>|
|&lt;Kitap 0xffeffb7c: Kitabım>        |
</screen></para>
  </sect1>
  <sect1 xml:id="glibc-Predefined-Printf-Handlers">
    <title>Yerleşik Kotarıcı İşlevler</title>
    <titleabbrev>Önceden tanımlanmış kotarıcı işlevler.</titleabbrev>
    <para>
GNU libc ayrıca <command>printf</command> kotarıcı oluşumunun somut ve kullanışlı bir uygulamasını içerir. Gerçek sayıları özel bir yolla basmak üzere iki işlev vardır.
    </para><para xml:id="glibc-printf_size">
<indexterm scope="glibc-fn"><primary>printf_size</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>printf_size</command></funcdef>
<paramdef>(FILE                     *<varname>akım</varname>,
 const struct printf_info *<varname>bilgi</varname>,
 const void *const        *<varname>args</varname>)</paramdef>
</funcprototype><funcdescr><para>
Verilen bir gerçek sayıyı <command>%f</command> dönüşüm belirtecini kullanarak özel bir şekilde basar. Sayıyı 1000’den daha küçük bir sayı olarak ifade eden bir birim karakteri kullanılır. Bu birim karakteri bir bölene karşılıktır. Mümkün iki bölen vardır; biri 1000'in kuvvetleri diğeri 1024'ün kuvvetleri. Birim, küçük harf ise 1024'ün kuvvetleri, büyük harf ise 1000'in kuvvetleri kullanılır.
      </para><para>
Birim bayt, kilobayt, megabayt, gigabayt, vs. karşılığı bir karakterdir. Tamamı tablo olarak:
      </para><para>
        <informaltable frame="none" style=";background:#999999;">
          <tgroup cols="5"><thead>
            <row style="background:#eeeedd;">
<entry align="center">Birim</entry>
<entry align="center"></entry>
<entry align="center">Birim</entry>
<entry align="center">Birim</entry>
<entry align="center"></entry>
            </row><row style="background:#eeeedd;">
<entry align="center">harfi</entry>
<entry align="center">Çarpan</entry>
<entry align="center">ismi</entry>
<entry align="center">harfi</entry>
<entry align="center">Çarpan</entry>
            </row>
          </thead><tbody>
            <row style="background:#ffffee;">
<entry align="center">' '</entry>
<entry align="right">1</entry>
<entry/>
<entry align="center">' '</entry>
<entry align="right">1</entry></row>
            <row style="background:#ffffee;">
<entry align="center">k</entry>
<entry align="right">2<superscript>10</superscript> (1024)</entry>
<entry align="center">kilo</entry>
<entry align="center">K</entry>
<entry align="right">10<superscript>3</superscript> (1000)</entry></row>
            <row style="background:#ffffee;">
<entry align="center">m</entry>
<entry align="right">2<superscript>20</superscript></entry>
<entry align="center">mega</entry>
<entry align="center">M</entry>
<entry align="right">10<superscript>6</superscript></entry></row>
            <row style="background:#ffffee;">
<entry align="center">g</entry>
<entry align="right">2<superscript>30</superscript></entry>
<entry align="center">giga</entry>
<entry align="center">G</entry>
<entry align="right">10<superscript>9</superscript></entry></row>
            <row style="background:#ffffee;">
<entry align="center">t</entry>
<entry align="right">2<superscript>40</superscript></entry>
<entry align="center">tera</entry>
<entry align="center">T</entry>
<entry align="right">10<superscript>12</superscript></entry></row>
            <row style="background:#ffffee;">
<entry align="center">p</entry>
<entry align="right">2<superscript>50</superscript></entry>
<entry align="center">peta</entry>
<entry align="center">P</entry>
<entry align="right">10<superscript>15</superscript></entry></row>
            <row style="background:#ffffee;">
<entry align="center">e</entry>
<entry align="right">2<superscript>60</superscript></entry>
<entry align="center">egza</entry>
<entry align="center">E</entry>
<entry align="right">10<superscript>18</superscript></entry></row>
            <row style="background:#ffffee;">
<entry align="center">z</entry>
<entry align="right">2<superscript>70</superscript></entry>
<entry align="center">zeta</entry>
<entry align="center">Z</entry>
<entry align="right">10<superscript>21</superscript></entry></row>
            <row style="background:#ffffee;">
<entry align="center">y</entry>
<entry align="right">2<superscript>80</superscript></entry>
<entry align="center">yotta</entry>
<entry align="center">Y</entry>
<entry align="right">10<superscript>24</superscript></entry></row>
          </tbody></tgroup>
        </informaltable>
      </para><para>
Öntanımlı hassasiyet 3’tür, örneğin 1024  sayısı için dönüşüm belirtimi küçük birim harfi ile <command>%.3fk</command> olarak yazılır ve bunun çıktısı <command>1.000k</command> olur.
      </para></funcdescr></funcsynopsis>
    </para><para>
<command>register_printf_function</command> işlevinin gereksinimlerinden dolayı argümanlar hakkında bilgi döndüren bir işlev daha üretmeliyiz.
    </para><para xml:id="glibc-printf_size_info">
<indexterm scope="glibc-fn"><primary>printf_size_info</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>printf_size_info</command></funcdef>
<paramdef>(const struct printf_info *<varname>akım</varname>,
 size_t                    <varname>n</varname>,
 int                      *<varname>argtürleri</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev şablon dizgesindeki belirteçlere karşılık olacak argümanların türleri hakkında bilgiyi <varname>argtürleri</varname> içinde döndürür. Bu işlev için tek argüman vardır.
      </para></funcdescr></funcsynopsis>
    </para><para>
Bu iki işlevi kullanırken aşağıdakine benzer bir çağrı ile kaydedilmelidir:
    </para><para>
<screen>
register_printf_function ('B', printf_size, printf_size_info);
</screen></para><para>
Burada <command>'B'</command> belirteç karakteri bütük harf olduğundan sayıları 1000'in kuvveti olarak basacak bir işlevi kaydetmiş olduk. Buna ek olarak <command>'b'</command> harfini de kullanmak için bir çağrı daha yapılmalıdır:
    </para><para>
<screen>
register_printf_function ('b', printf_size, printf_size_info);
</screen></para><para>
Böylece 1024'ün kuvvetini de basabileceğiz. Burada dikkat ettiyseniz iki işlevde dönüşüm belirteçleri farklıdır. <command>printf_size</command> işlevi sadece büyük ve küçük harfler arasındaki farkı bilir.
    </para><para>
<command>'B'</command> ve <command>'b'</command> kullanımı hiç de tesadüf değildir. Hatta bunları biçim belirteci olarak kullanan bazı sistemler de olduğundan bu harfleri kullanmanız önerilir.
    </para>
  </sect1>
</chapter>

<chapter xml:id="glibc-Formatted-Input">
  <title>Biçimli Girdi</title>
  <titleabbrev><command>scanf</command> ve ilgili işlevler.</titleabbrev>
  <para>
<indexterm scope="glibc-cp"><primary>biçimli girdi</primary><secondary>biçim dizgesi</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>biçimli girdi</primary><secondary>şablon dizge</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>akımlar</primary><secondary>okuma</secondary><tertiary>biçimli</tertiary></indexterm>
Bu kısımda açıklanan işlevler (<command>scanf</command> ve ilgili işlevler) biçimli çıktı oluşumlarına benzer olarak biçimli girdi için kullanılır. Bu işlevler bir <wordasword>biçim dizgesi</wordasword> veya bir <wordasword>şablon dizgesi</wordasword>nin denetimi altında değer okumak için bir mekanizma sağlar.
  </para>
  <sect1 xml:id="glibc-Formatted-Input-Basics">
    <title>Biçimli Girdi Okumanın Temelleri</title>
    <titleabbrev>Başlangıç olarak bilinmesi gerekenler.</titleabbrev>
<indexterm scope="glibc-cp"><primary>biçimli girdi</primary><secondary>dönüşüm belirtimleri</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>biçimli girdi</primary><secondary>eşleşme hatası</secondary></indexterm>
    <para>
<command>scanf</command> çağrıları argümanları bir şablon dizgenin denetimi altında okumasından dolayı yüzeysel olarak <command>printf</command> çağrılarına benzer. Şablon dizgedeki dönüşüm belirtimlerinin sözdizimleri <command>printf</command> işlevininkilere çok benzese de, şablonun yorumlanması sabit alanlı biçimlemeden ziyade daha bir serbest biçimli ve basit kalıp eşleştirme yönündedir. Örneğin, çoğu <command>scanf</command> dönüşümü dosyadaki boş alanları (boşluk, sekme, satırsonu) atlar ve çıktı dönüşümlerindekinin aksine sayısal girdi dönüşümleri için hassasiyet diye bir kavrama sahip değildir. Ekseriyetle, şablondaki boşluk olmayan karakterlerin girdi akımındaki karakterlerle eşleşeceği umulur, ancak bir eşleşmenin bulunamaması     akım üzerindeki bir girdi hatası ile karıştırılmaz.
    </para><para>
<command>scanf</command> ile <command>printf</command> arasındaki diğer bir farklı alan, <command>scanf</command> işlevinin isteğe bağlı argümanlarının doğrudan değer olarak değil göstericiler sağlayarak alındığını unutmamanız gerektiğidir; okunan değerler göstericilerin gösterdiği nesnelerde saklanır. Deneyimli yazılımcılar bile kimi zaman bunu unutur, eğer yazılımınız <command>scanf</command> ile ilgili olarak tuhaf hatalar veriyorsa bu özelliği için çifte kontrol yapmalısınız.
    </para><para>
Bir <wordasword>eşleşme hatası</wordasword> oluştuğunda, <command>scanf</command> işlevi ilk eşleşmeyen karakteri akımdan okunacak sonraki karakter olarak bırakarak hemen döner. Normalde <command>scanf</command> işlevinden dönen değer atanmış değerlerin sayısıdır. Bu değere bakarak bir okunmamış karakter varsa eşleşme hatasının oluştuğu yeri bulabilirsiniz.
    </para><para>
<command>scanf</command> işlevi genellikle, tabloların içeriklerini okumak gibi şeyler için kullanılır. Örneğin, buradaki işlev bir <command>double</command> dizisini ilklendirmek için <command>scanf</command> işlevini kullanmaktadır:
    </para><para>
<screen>
void
diziyioku (double *dizi, int n)
{
  int i;
  for (i = 0; i &lt; n; i++)
    if (scanf (" %lf", &amp;(dizi[i])) != 1)
      invalid_input_error ();
}
</screen></para><para>
Biçimli girdi işlevleri, biçimli çıktı işlevleri kadar sık kullanılmazlar. Kısmen, onları düzgün olarak kullanmak biraz dikkat gerektirdiğindendir. Diğer bir sebep, bir eşleşme hatasından kurtulmanın zorluğudur.
    </para><para>
Bir tek başına, sabit bir kalıpla eşleşmeyecek bir girdiyi okumaya çalışacaksanız, <command>scanf</command> kullanmaktansa, bir sözel tarayıcı üretmede Flex ya da bir çözümleyici üretmede Bison gibi bir araç kullanmak sizin için daha iyi olabilir. Bu araçlar hakkında bilgi almak için Bison.info ve Flex.info'ya bakabilirsiniz.
    </para>
  </sect1>
  <sect1 xml:id="glibc-Input-Conversion-Syntax">
    <title>Girdi Dönüşüm Sözdizimi</title>
    <titleabbrev>Dönüşüm belirtimlerinin sözdizimi.</titleabbrev>
    <para>
Bir <command>scanf</command> sablon dizgesi, sıradan çok baytlı karakterler arasına serpiştirilmiş <command>%</command> ile başlayan dönüşüm belirtimleri içeren bir dizgedir.
    </para><para>
Şablondaki boşluk karakterleri (<command>isspace</command> işlevinin tanıdıkları, bkz. <xref linkend="glibc-Classification-of-Characters"/>) girdi akımından boşluk karakterlerini okutur ve bunlar iptal edilir. Eşleşmesi istenen boşluk karakterleri ile okunacak boşluk karakterlerinin aynı karakterler olması gerekmez. Örneğin şablona`<command> , </command>' yazarsanız bir virgül ve virgülün önünde ve/veya ardında isteğe bağlı boşluk karakterleri ile eşleşir.
    </para><para>
Dönüşüm belirtimlerinin parçası olmayan tüm karakterler girdidekilerle aynen eşleşmelidir; bu eşleşme olmazsa bir eşleşme hatası oluşur.
    </para><para>
Bir <command>scanf</command> şablon dizgesindeki dönüşüm belirtimlerinin genel şekli:
    </para><para>
<screen>
    % <varname>imler genişlik tür dönüşüm</varname>
</screen></para><para>
Ayrıntıya girersek, dönüşüm belirtimi bir <command>%</command> işaretini izleyen aşağıdaki parçalardan oluşur:
    </para><para>
      <itemizedlist><listitem><para>
<indexterm scope="glibc-cp"><primary>biçimli girdi</primary><secondary>im karakteri</secondary><tertiary>*</tertiary></indexterm>
İsteğe bağlı <command>*</command> <firstterm>im karakteri</firstterm>, belirtim için okunan metni yoksaymasını söyler. <command>scanf</command> bu imi kullanan bir belirtim bulduğunda, dönüşüm belirtiminin kalanı tarafından yönlendirildiği girdiyi okur, ama bu girdiyi iptal eder, bir gösterici kullanılmaz ve başarılı atamalar sayacı arttırılmaz.
      </para></listitem><listitem><para>
<indexterm scope="glibc-cp"><primary>biçimli girdi</primary><secondary>im karakteri</secondary><tertiary>a</tertiary></indexterm>
İsteğe bağlı <command>a</command> <firstterm>im karakteri</firstterm> (sadece dizge dönüşümlerinde geçerli) dizgeyi saklamak için yeterli uzulukta bir tampon ayrılmasını söyler. (Bu im bir GNU oluşumudur.) Bkz. <xref linkend="glibc-Dynamic-String-Input"/>.
      </para></listitem><listitem><para>
<indexterm scope="glibc-cp"><primary>biçimli girdi</primary><secondary>en büyük alan genişliği</secondary></indexterm>
İsteğe bağlı bir <firstterm>en büyük alan genişliği</firstterm>. Bir onluk tamsayıdır. En büyük genişlik aşıldığında ya da bir eşleşmeyen karaktere rastlandığında hangisi önce oluşursa girdi akımından karakterlerin okunması durdurulur. Çoğu dönüşümler okunan boşluk karakterlerini (bunlar açıkça belgelendirilmiş değildir) iptal eder ve bu iptal edilen karakterler en büyük alan genişliğinden sayılmaz. Dizge girdi dönüşümleri girdinin sonuna bir boş karakter ekler, bu karakter de en büyük alan genişliğine dahil edilmez.
      </para></listitem><listitem><para>
<indexterm scope="glibc-cp"><primary>biçimli girdi</primary><secondary>tür değiştirici karakter</secondary></indexterm>
İsteğe bağlı bir <firstterm>tür değiştirici karakter</firstterm>. Örneğin, bir <command>int</command> türünden gösterici argümanı belirten <command>%d</command> dönüşüm belirteci ile <command>l</command> tür değiştiricisini tamsayı dönüşümü için belirterek gösterici türünü <command>long int</command> olarak değiştirebilirsiniz.
      </para></listitem><listitem><para>
Uygulanacak dönüşümü belirten bir karakter.
      </para></listitem></itemizedlist>
    </para><para>
İzin verilen seçenekler ve onların yorumlanışı farklı dönüşüm belirteçleri hep aynı değildir. Bir seçeneğin kullanıldığı bir dönüşümdeki yorumlanışı ile ilgili bilgileri, o dönüşümün açıklamalarında bulabilirsiniz.
    </para><para>
<command>-Wformat</command> seçeneği ile GNU C derleyicisi <command>scanf</command> ve ilgili işlevleri denetler. Biçim dizgesine bakarak doğru sayı ve türde argüman belirtilip belirtilmediğini denetler. Yazdığınız bir <command>scanf</command> tarzı biçim dizgesini denetlemek için GNU C sözdizimini derleyiciye söyleyecek bir sözdizimi de vardır. (GCC info'sundaki "İşlev Özniteliklerinin Bildirilmesi" [Declaring Attributes of Functions] bölümüne bakınız.)
    </para>
  </sect1>
  <sect1 xml:id="glibc-Table-of-Input-Conversions">
    <title>Girdi Dönüşüm Belirteçlerinin Listesi</title>
    <titleabbrev>Girdi dönüşümleri ve ne yaptıklarının bir özeti.</titleabbrev>
    <para>
 <indexterm scope="glibc-cp"><primary>biçimli girdi</primary><secondary>girdi dönüşüm belirteçleri</secondary></indexterm>
Aşağıda tüm farklı dönüşümler özetlenmiştir:
    </para><para>
      <variablelist><varlistentry><term><literal>%d</literal></term>
        <listitem><para>
Seçmeli olarak onluk tabanda yazılmış bir işaretli tamsayı ile eşleşir. Bkz.  <xref linkend="glibc-Numeric-Input-Conversions"/>.
        </para></listitem>
      </varlistentry><varlistentry><term><literal>%i</literal></term>
        <listitem><para>
Bir tamsayı sabit için C dilinde tanımlı herhangi bir biçimdeki bir işaretli tamsayı ile seçmeli olarak eşleşir. Bkz. <xref linkend="glibc-Numeric-Input-Conversions"/>.
        </para></listitem>
      </varlistentry><varlistentry><term><literal>%o</literal></term>
        <listitem><para>
Sekizlik tabanda yazılmış bir işaretli tamsayı ile eşleşir. Bkz. <xref linkend="glibc-Numeric-Input-Conversions"/>.
        </para></listitem>
      </varlistentry><varlistentry><term><literal>%u</literal></term>
        <listitem><para>
Onluk tabanda yazılmış bir işaretsiz tamsayı ile eşleşir. Bkz. <xref linkend="glibc-Numeric-Input-Conversions"/>.
        </para></listitem>
      </varlistentry><varlistentry><term><literal>%x, %X</literal></term>
        <listitem><para>
Onaltılık tabanda yazılmış bir işaretsiz tamsayı ile eşleşir. Bkz. <xref linkend="glibc-Numeric-Input-Conversions"/>.
        </para></listitem>
      </varlistentry><varlistentry><term><literal>%e, %f, %g, %E, %G</literal></term>
        <listitem><para>
Bir gerçek sayı ile eşleşir. Bkz.  <xref linkend="glibc-Numeric-Input-Conversions"/>.
        </para></listitem>
      </varlistentry><varlistentry><term><literal>%s</literal></term>
        <listitem><para>
Boşluk içermeyen bir dizge ile eşleşir. Bkz. <xref linkend="glibc-String-Input-Conversions"/>. <command>l</command> tür değiştiricisinin varlığı dizgenin geniş karakterli ya da çok baytlı dizge olarak ele alınmasını sağlar. <command>%s</command> bir geniş karakter işlevinde kullanılmışsa dizge çoklu <command>wcrtomb</command> çağrılarıyla çok baytlı dizgeye dönüştürülür. Bu, tamponda, okunan her karakter için <command>MB_CUR_MAX</command> baytlık yer ayrılması gerektiği anlamına gelir. <command>%ls</command> bir çok baytlı işlevde kullanıldığında ise sonuç yazılımcının sağladığı tampona yazılmadan önce çoklu <command>mbrtowc</command> çağrılarıyla geniş karakterlere dönüştürülür.
        </para></listitem>
      </varlistentry><varlistentry><term><literal>%S</literal></term>
        <listitem><para>
Unix standardı ile uyumluluk için <command>%ls</command> yerine kullanılmak üzere desteklenmiştir.
        </para></listitem>
      </varlistentry><varlistentry><term><literal>%[</literal></term>
        <listitem><para>
Belirtilmiş bir kümeye ait olan karakterlerin bir dizgesi ile eşleşir. Bkz. <xref linkend="glibc-String-Input-Conversions"/>. <command>l</command> tür değiştiricisinin varlığı dizgenin geniş karakterli ya da çok baytlı dizge olarak ele alınmasını sağlar. <command>%[</command> bir geniş karakter işlevinde kullanılmışsa dizge çoklu <command>wcrtomb</command> çağrılarıyla çok baytlı dizgeye dönüştürülür. Bu, tamponda, okunan her karakter için <command>MB_CUR_MAX</command> baytlık yer ayrılması gerektiği anlamına gelir. <command>%l[</command> bir çok baytlı işlevde kullanıldığında ise sonuç yazılımcının sağladığı tampona yazılmadan önce çoklu <command>mbrtowc</command> çağrılarıyla geniş karakterlere dönüştürülür.
        </para></listitem>
      </varlistentry><varlistentry><term><literal>%c</literal></term>
        <listitem><para>
Bir ya da daha fazla karakterden oluşan bir dizge ile eşleşir. Okunacak karakterlerin sayısı dönüşüm belirtiminde belirtilmiş olan en büyük karakter genişliğindedir. Bkz. <xref linkend="glibc-String-Input-Conversions"/>.
        </para><para>
<command>%c</command> bir geniş yönlenimli akım işlevinde kullanılırsa okunan bir geniş karakter karşılığı olan çokbaytlı karaktere dönüştürüldükten sonra saklanır. Bu dönüşüm birden fazla karakter üretebilir, bundan dolayı tamponda her karakter için <command>MB_CUR_MAX</command> baytlık yer sağlanmalıdır. <command>%lc</command> bir çok baytlı işlevde kullanılırsa, bir çokbaytlı dizi (bayt değil) olarak ele alınır ve sonuç <command>mbrtowc</command> çağrılarıyla dönüştürülür.
        </para></listitem>
      </varlistentry><varlistentry><term><literal>%C</literal></term>
        <listitem><para>
Unix standardı ile uyumluluk için <command>%lc</command> yerine kullanılmak üzere desteklenmiştir.
        </para></listitem>
      </varlistentry><varlistentry><term><literal>%p</literal></term>
        <listitem><para>
<command>printf</command> için <command>%p</command> çıktı dönüşüm belirteci tarafından kullanılan biçimle aynı gerçekleme tanımlı biçimde bir gösterici değeri ile eşleşir. Bkz. <xref linkend="glibc-Other-Input-Conversions"/>.
        </para></listitem>
      </varlistentry><varlistentry><term><literal>%n</literal></term>
        <listitem><para>
Bu belirteç herhangi bir karakter okumaz; çağrı tarafından o ana kadar okunan karakterlerin sayısını kaydeder. Bkz. <xref linkend="glibc-Other-Input-Conversions"/>.
        </para></listitem>
      </varlistentry><varlistentry><term><literal>%%</literal></term>
        <listitem><para>
Girdi akımındaki bir <command>%</command> karakteri ile eşleşir. Karşılık olarak bir argüman belirtilmez. Bkz. <xref linkend="glibc-Other-Input-Conversions"/>.
        </para></listitem>
      </varlistentry></variablelist>
    </para><para>
Bir dönüşüm belirtiminin sözdizimi geçersizse, davranış tanımlanmamıştır. Yani bunu yapmamaya çalışın. Şablon dizgesinde belirtilenden daha az sayıda artbileşen argüman varsa ya da artbileşen argümanların türleri ile dönüşüm belirtimleri uyumsuzsa sonucun ne olacağı belli olmaz. Şablon dizgesinde belirtilenden daha çok sayıda artbileşen argüman varsa fazla argümanlar basitçe yoksayılır.
    </para>
  </sect1>
  <sect1 xml:id="glibc-Numeric-Input-Conversions">
    <title>Sayısal Girdi Dönüşümleri</title>
    <titleabbrev>Sayıların okunması sırasındaki dönüşümlerin ayrıntıları.</titleabbrev>
    <para>
Bu bölümde, sayısal değerlerin okunması sırasındaki <command>scanf</command> dönüşümleri açıklanmıştır.
    </para><para>
<command>%d</command> dönüşümü seçmeli olarak onluk tabanda bir işaretli tamsayı ile eşleşir. Sözdizimi <command>strtol</command>  işlevinin <varname>taban</varname> argümanının <command>10</command> değerli çağrısıyla aynı şekilde tanınır. (Bkz. <xref linkend="glibc-Parsing-of-Integers"/>.)
    </para><para>
<command>%i</command> dönüşümü bir tamsayı sabit için C dilinde tanımlı herhangi bir biçimdeki bir işaretli tamsayı ile seçmeli olarak eşleşir. Sözdizimi <command>strtol</command>  işlevinin <varname>taban</varname> argümanının <command>0</command> değerli çağrısıyla aynı şekilde tanınır. (Bkz. <xref linkend="glibc-Parsing-of-Integers"/>.) (Bu sözdizimindeki tamsayıları <command>printf</command> işlevini <command>#</command> im karakteri ve <command>%x</command>, <command>%o</command> veya <command>%d</command> dönüşümlerinden biri birlikte kullanarak çıktılayabilirsiniz. Bkz. <xref linkend="glibc-Integer-Conversions"/>.)
    </para><para>
Örneğin, <command>10</command>, <command>0xa</command>, <command>012</command> dizgelerinin her birini <command>%i</command> dönüşümü altında birer tamsayı olarak okumalısınız. Bu dizgelerin her biri onluk tabanda <command>10</command> sayısıdır.
    </para><para>
<command>%o</command>, <command>%u</command> ve <command>%x</command> dönüşümleri sırayla sekizlik, onluk ve onaltılık tabandaki işaretsiz tamsayılarla eşleşir. Sözdizimi <command>strtol</command>  işlevinin <varname>taban</varname>  argümanının sırasıyla <command>8</command>, <command>10</command> veya <command>16</command> değerli çağrısıyla aynı şekilde tanınır. (Bkz. <xref linkend="glibc-Parsing-of-Integers"/>.)
    </para><para>
<command>%X</command> ve <command>%x</command> dönüşümleri eşanlamlıdır. Her ikisi de rakam olarak büyük ya da küçük harfleri tanır.
    </para><para>
Öntanımlı tür, <command>%d</command> ve <command>%i</command> dönüşümleri için <command>int *</command>, diğer tamsayı dönüşümleri için <command>unsigned int *</command>’tir. Tamsayıların türleri için aşağıdaki tür değiştiricileri kullanabilirsiniz:
    </para><para>
      <variablelist><varlistentry><term><literal>hh</literal></term>
        <listitem><para>
Argümanın <command>signed char *</command> veya <command>unsigned char *</command> türünde olduğunu belirtir.
        </para><para>
Bu değiştirici ISO C99'da tanımlanmıştır.
        </para></listitem>
      </varlistentry><varlistentry><term><literal>h</literal></term>
        <listitem><para>
Argümanın <command>short int *</command> veya <command>unsigned short int *</command> türünde olduğunu belirtir.
        </para></listitem>
      </varlistentry><varlistentry><term><literal>j</literal></term>
        <listitem><para>
Argümanın <command>intmax_t *</command> veya <command>uintmax_t *</command> türünde olduğunu belirtir.
        </para><para>
Bu değiştirici ISO C99'da tanımlanmıştır.
        </para></listitem>
      </varlistentry><varlistentry><term><literal>l</literal></term>
        <listitem><para>
Argümanın <command>long int *</command> veya <command>unsigned long int *</command> türünde olduğunu belirtir. İki <command>l</command> karakteri aşağıda açıklanan <command>L</command> karakteri gibidir.
        </para><para>
Bu karakter <command>%c</command> veya <command>%s</command> dönüşümü ile birlikte kullanıldığında argümanın sırasıyla bir geniş karakter veya bir geniş karakterli dizgeye bir gösterici olduğunu belirtir. <command>l</command> değiştiricisinin bu kullanımı ISO C90 1. düzeltmesinde tanımlanmıştır.
        </para></listitem>
      </varlistentry><varlistentry><term><literal>ll, L, q</literal></term>
        <listitem><para>
Argümanın <command>long long int *</command> veya <command>unsigned long long int *</command> türünde olduğunu belirtir. (Bu tür GNU C derleyicisi tarafından desteklenen bir oluşumdur. Fazla uzun tamsayıları desteklemeyen sistemlerde bu değiştirici <command>long int</command> olarak değerlendirilir.)
        </para><para>
<command>q</command> değiştiricisi 4.4 BSD’den gelmektedir. Bir <command>long long int</command> kimi zaman &quot;quad&quot; <command>int</command> olarak da isimlendirilir.
        </para></listitem>
      </varlistentry><varlistentry><term><literal>t</literal></term>
        <listitem><para>
Argümanın <command>ptrdiff_t *</command> türünde olduğunu belirtir.
        </para><para>
Bu değiştirici ISO C99'da tanımlanmıştır.
        </para></listitem>
      </varlistentry><varlistentry><term><literal>z</literal></term>
        <listitem><para>
Argümanın <command>size_t *</command> türünde olduğunu belirtir.
        </para><para>
Bu değiştirici ISO C99'da tanımlanmıştır.
        </para></listitem>
      </varlistentry></variablelist>
    </para><para>
<command>%e</command>, <command>%f</command>, <command>%g</command>,  <command>%E</command> ve <command>%G</command> girdi dönüşümlerinin tümü birbirinin yerine kullanılabilir. Bunların tümü <command>strtod</command>  işlevindeki sözdizimi ile aynı sözdiziminde, seçimli olarak bir gerçek sayı ile eşleşir (Bkz. <xref linkend="glibc-Parsing-of-Floats"/>).
    </para><para>
Gerçek sayı girdi dönüşümleri için öntanımlı argüman türü <command>float *</command>’dır. (Çıktı dönüşümlerinde öntanımlı tür <command>double</command>’dır ve öntanımlı argüman terfileri çerçevesinde bir <command>float</command> argüman <command>double</command> türe terfi ettirilir. Ama girdi dönüşümlerinde bu terfi uygulanmaz.) Gerçek sayıların türleri için aşağıdaki tür değiştiricileri kullanabilirsiniz:
    </para><para>
      <variablelist><varlistentry><term><literal>l</literal></term>
        <listitem><para>
Argümanın <command>double *</command> türünde olduğunu belirtir.
        </para></listitem>
      </varlistentry><varlistentry><term><literal>L</literal></term>
        <listitem><para>
Argümanın <command>long double *</command> türünde olduğunu belirtir.
        </para></listitem>
      </varlistentry></variablelist>
    </para><para>
Yukarıdaki sayı çözümleme biçimlerinin tümü için isteğe bağlı bir ek <command>'</command> imi vardır. Bu im kullanıldığında <command>scanf</command> işlevi girdi dizgesinin o an geçerli yerelin sayı gruplama kurallarına uygun olacağını umar (Bkz. <xref linkend="glibc-General-Numeric"/>).
    </para><para>
<command>&quot;C&quot;</command> veya <command>&quot;POSIX&quot;</command> yereli geçerli yerelse bir fark olmaz. Fakat diğer yerellerde bu dizge yerele özgü biçime uygun verilmiş olmalıdır. Aksi takdirde doğru biçimli en uzun önek işlenir.
    </para>
  </sect1>
  <sect1 xml:id="glibc-String-Input-Conversions">
    <title>Dizgeler için Girdi Dönüşümleri</title>
    <titleabbrev>Dizgelerin okunması sırasındaki dönüşümlerin ayrıntıları.</titleabbrev>
    <para>
Bu bölümde dizge ve karakterlerin okunması için <command>%s</command>,  <command>%S</command>, <command>%[</command>, <command>%c</command> ve <command>%C</command> girdi dönüşüm belirteçleri açıklanmıştır.
    </para><para>
Bu dönüşümlerden girdilerin alınması için iki seçeneğiniz vardır:
    </para><para>
      <itemizedlist><listitem><para>
Onu saklamak için bir tampon sağlayın. Bu öntanımlıdır. Bu tampona <command>char *</command> veya <command>wchar_t *</command> türünde bir argüman sağlayın (ikincisi için <command>l</command> değiştiricisi olmalı).
      </para><para>
<warning><para>Sağlam bir yazılım için girdi (sonlandırıcı boş karakter dahil), sağladığınız tamponun boyunu aşmamalıdır. Genelde, bunu yapmanın tek yolu, en büyük alan genişliğini tampon boyunun bir eksiği olarak vermektir. <varname>Bir tampon oluşturuyorsanız taşmalardan kaçınmak için uzunluğunu daima en büyük alan genişliğine eşit uzunlukta seçmelisiniz.
 </varname></para></warning>
      </para></listitem><listitem><para>
Ne kadar büyüklükte bir tampon gerektiğini <command>a</command> im karakterini belirterek <command>scanf</command> işlevine sorun. Bu bir GNU oluşumudur. Tampon adresi için <command>char **</command> türünde bir argüman belirtmelisiniz. Bkz. <xref linkend="glibc-Dynamic-String-Input"/>.
      </para></listitem></itemizedlist>
    </para><para>
<command>%c</command> dönüşümü en basitidir: Daima sabit sayıda karakterle eşleşir. En büyük alan genişliği kaç karakter okunacağını söyler; en büyük alan genişliğini belirtmezseniz öntanımlı olarak 1 değeri kullanılır. Bu dönüşüm okuduğu metnin sonuna bir sonlandırıcı boş karakter eklemez. Ayrıca metnin içindeki boşluk karakterlerini atlar. Özellikle sonraki <varname>n</varname> karakteri okur, bu kadar karakter bulamazsa başarısız olur. <command>%c</command> dönüşümü daima sabit uzunlukta okuma yaptığından taşmadan kaçınmak için tamponu yeterli uzunlukta yapmalısınız.
    </para><para>
<command>%lc</command> veya <command>%C</command> dönüşümleri akımın, harici bayt akımından açıldığı sırada saptanan dönüşüm kullanılarak çevrilen geniş karakterlerin saklanmasını sağlar. Ortamdan okunan baytların sayısı <command>MB_CUR_LEN * </command><varname>n</varname> ile sınırlıdır ve çıktı dizgesinde saklanan en çok <varname>n</varname> geniş karakter alınır.
    </para><para>
<command>%s</command> dönüşümü boşluk karakterleri olmayan karakterlerden oluşan bir dizge ile eşleşir. Dahili boşlukları atlar ve iptal eder, fakat biraz okuma yaptıktan sonra çok fazla boşluk karakterine rastlarsa durur. Okuduğu metnin sonuna bir boş karakter ekler.
    </para><para>
Örneğin, okunacak girdi,
    </para><para>
<screen> hello, world</screen>
    </para><para>
ise, <command>%10c</command> dönüşümü <literal>" hello, wo"</literal> üretir. Aynı girdi için <command>%10s</command> dönüşümü kullanılırsa, <literal>"hello,"</literal> üretilir.
    </para><para>
<warning><para><command>%s</command> için bir alan genişliği belirtirseniz, okunan karakter sayısı boşluk karakterine rastlanan yer ile sınırlıdır. Bu hemen hemen kaçınılmaz olarak geçersiz bir girdinin yazılımınızın çökmesine sebep olacağı anlamına gelir ki bu bir yazılım hatasıdır.</para></warning>
    </para><para>
<command>%ls</command> ve <command>%S</command> dönüşümleri <command>%s</command> gibi kotarılır, bir farkla, dış bayt dizisi, kendi karakter kodlaması ile geniş karakterlere akım ile ilişkili dönüşüm kullanılarak çevrilir. Belirteç ile birlikte genişlik belirtilirse, bunlar geniş karakterleri öçtüğünden, akımdan kaç bayt okunacağı doğrudan doğruya saptanmaz. Fakat bir üst sınır, genişlik değeri ile <command>MB_CUR_MAX</command> çarpılarak hesaplanabilir.
    </para><para>
Belli kriterlere göre sizin seçiminize bağlı olarak karakterlerin okunmasını sağlamak isterseniz <command>%[</command> dönüşümünü kullanın. <command>[</command> ve <command>]</command> ayraçlarının arasını düzenli ifadelerdeki sözdizimini kullanarak yazabilirsiniz. Özel durumlar olarak:
    </para><para>
      <itemizedlist><listitem><para>
<command>]</command>  karakteri ifadenin ilk karakteri olarak belirtilebilir.
      </para></listitem><listitem><para>
Bir gömülü <command>-</command> karakteri (ifadenin ilk veya son karakteri olamaz) bir karakter aralığını belirtmek için kullanılabilir.
      </para></listitem><listitem><para>
Bir <command>^</command> karakteri <command>[</command> ayracından sonra kullanılırsa, girdi karakterleri burada listelenen karakterlerin dışındakilerdir.
      </para></listitem></itemizedlist>
    </para><para>
<command>%[</command> dönüşümü dahili boşluk karakterlerini atlamaz.
    </para><para>
Aşağıda bazı <command>%[</command> dönüşüm örnekleri ve anlamları vardır:
    </para><para>
      <variablelist><varlistentry><term><literal>%25[1234567890]</literal></term>
        <listitem><para>
25 haneye kadar bir sayı ile eşleşir.
        </para></listitem>
      </varlistentry><varlistentry><term><literal>%25[][]</literal></term>
        <listitem><para>
25 köşeli ayraca kadar bir dizge ile eşleşir.
        </para></listitem>
      </varlistentry><varlistentry><term><literal>%25[^ \f\n\r\t\v]</literal></term>
        <listitem><para>
Hiçbir boşluk karakteri içermeyen 25 karaktere kadar bir dizge ile eşleşir. Bu <command>%s</command>’den tamamen farklıdır, çünkü girdi, boşluk karakterlerinden biri ile başlarsa bu <command>%[</command> dönüşümü bir eşleşme hatası bildirir ama <command>%s</command> dönüşümü onu basitçe iptal eder.
        </para></listitem>
      </varlistentry><varlistentry><term><literal>%25[a-z]</literal></term>
        <listitem><para>
25 karaktere kadar küçük harflerle eşleşir.
        </para></listitem>
      </varlistentry></variablelist>
    </para><para>
<command>%c</command> ve <command>%s</command> gibi <command>%[</command> belirteci de <command>l</command> tür değiştiricisi varsa geniş karakterleri üretebilir. Yukarıda bu konu ile ilgili bahsedilen herşey <command>%l[</command> için de geçerlidir.
    </para><para>
<important><title>Bir hatırlatma daha</title><para> Bir en büyük genişlik belirtmezseniz ya da <command>a</command> imini kullanmazsanız <command>%s</command> ve  <command>%[</command> belirteçleri <varname>tehlikelidir</varname>, çünkü girdi çok uzun olursa tampon taşar. Tamponun ne kadar uzunlukta olduğunun önemi yoktur, bir kullanıcı onu da taşıracak bir girdi yapabilir. İyi geliştirilmiş bir yazılım geçersiz bir girdiyi kapsamlı bir hata iletisi ile bildirir, çökerek değil.</para></important>
    </para>
  </sect1>
  <sect1 xml:id="glibc-Dynamic-String-Input">
    <title>Dizge Dönüşümlerinde Özdevimli Ayırma</title>
    <titleabbrev><command>malloc</command> tamponlu dizge dönüşümleri.</titleabbrev>
    <para>
Bir GNU oluşumu biçimli girdi olarak bir uzunluk sınırı olmaksızın bir dizgeyi güvenli olarak okur. Bu özelliği kullandığınızda bir tampon ayırmanız gerekmez. <command>scanf</command> veriyi tutacak kadar büyüklükte tamponu kendi ayırır ve size onun adresini verir. Bu özelliği kullanmak için bir im karakteri olarak <command>a</command> karakterini <command>%as</command> olarak ya da <command>%a[0-9a-z]</command> olarak yazın.
    </para><para>
Girdinin saklanacağı tamponun adresini tutacak gösterici argümanını <command>char **</command> türünde sağlamalısınız. <command>scanf</command> işlevi bir tampon ayırır ve onun adresini bu argümanın gösterdiği yere kaydeder. Tampona ihtiyacınız kalmadığında <command>free</command> ile serbest bırakmalısınız.
    </para><para>
Bu örnekte <command>%[…]</command> belirteci <command>a</command> imi ile birlikte kullanılarak <varname>değişken</varname><literal> = </literal><varname>değer</varname> çifti halinde bir "değişken ataması" okunmaktadır.
    </para><para>
<screen>
{
  char *degisken, *deger;

  if (2 > scanf ("%a[a-zA-Z0-9] = %a[^\n]\n",
                      &amp;degisken, &amp;deger))
  {
    invalid_input_error ();
    return 0;
  }

  …
}
</screen></para>
  </sect1>
  <sect1 xml:id="glibc-Other-Input-Conversions">
    <title>Diğer Girdi Dönüşümleri</title>
    <titleabbrev>Diğer dönüşümlerin ayrıntıları.</titleabbrev>
    <para>
Bu bölümde çeşitli girdi dönüşümlerine yer verilmiştir.
    </para><para>
<command>%p</command> belirteci bir gösterici değeri okumakta kullanılır. <command>printf</command> (<xref linkend="glibc-Other-Output-Conversions"/>) için kullanılan <command>%p</command> çıktı dönüşüm belirteci ile aynı sözdizimini tanır; şöyleki, <command>%x</command> belirtecinin yaptığı gibi bir onaltılık sayı kabul eder. Karşılığı olan argüman <command>void **</command> türünde olmalıdır; yani göstericide bir yerin adresi saklanır.
    </para><para>
Eğer değer okunduğu yazılımın icrası sırasında özgün olarak yazılmamışsa sonuçlanan gösterici değerinin geçerli olacağı garanti edilmez.
    </para><para>
<command>%n</command> belirteci işlevin çağrısı sırasında o ana kadar okunan karakterlerin sayısını üretir.  Belirtece kaşılık olan argüman <command>int *</command> türünde olmalıdır. Bu dönüşüm belirteci, <command>printf</command> için kullanılan <command>%n</command> ile aynı şekilde çalışır. <xref linkend="glibc-Other-Output-Conversions"/> bölümündeki örneğe bakınız.
    </para><para>
<command>%n</command> dönüşümü sadece başarılı eşleşmeler veya bastırılmış atamalı dönüşümleri saptamak için bir mekanizmadır. <command>%n</command>'den önce bir eşleşme hatası oluşursa, <command>scanf</command>, <command>%n</command>'i işlemeden döndüğünden, argümanına bir değer atanmaz. <command>scanf</command> işlevini çağırmadan önce argüman yuvasına <command>-1</command> değerini yerleştirirseniz, çağrıdan sonra da bu değer hala duruyorsa, bu, <command>%n</command> işlenmeden önce bir hata oluştuğunu gösterir.
    </para><para>
Son olarak, <command>%%</command> belirteci akımdaki bir <command>%</command> işareti ile eşleşir, bu belirteç için bir argüman kullanılmaz. Bu belirteç ile birlikte bir im, alan genişliği ya da tür değiştirici belirtilmesine izin verilmez.
    </para>
  </sect1>
  <sect1 xml:id="glibc-Formatted-Input-Functions">
    <title>Biçimli Girdi İşlevleri</title>
    <titleabbrev>İşlevlerin açıklamaları.</titleabbrev>
    <para>
Bu bölümde biçimli girdi uygulamak için kullanılan işlevler açıklanmıştır. Bu işlevlerin prototipleri <filename>stdio.h</filename> başlık dosyasında bildirilmiştir.
<indexterm scope="glibc-pg"><primary>stdio.h</primary></indexterm>
    </para><para xml:id="glibc-scanf">
<indexterm scope="glibc-fn"><primary>scanf</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>scanf</command></funcdef>
<paramdef>(const char *<varname>şablon</varname>, …)</paramdef>
</funcprototype><funcdescr><para>
<command>scanf</command> işlevi <varname>şablon</varname> biçim dizgesinin denetimi altında biçimli girdiyi standart girdiden okur. İsteğe bağlı argümanlar sonuçlanan değerlerin alındığı yerlere göstericilerdir.
      </para><para>
Dönen değer normalde başarılı atamaların sayısıdır. Herhangi bir eşleşme bulunmadan önce bir dosya sonu durumu saptanırsa, şablondaki tek karakterler ve boşluk karakterleri içerilerek <command>EOF</command> ile döner.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-wscanf">
<indexterm scope="glibc-fn"><primary>wscanf</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>wscanf</command></funcdef>
<paramdef>(const wchar_t *<varname>şablon</varname>, …)</paramdef>
</funcprototype><funcdescr><para>
<command>wscanf</command> işlevi <varname>şablon</varname> biçim dizgesinin denetimi altında biçimli girdiyi standart girdiden okur. İsteğe bağlı argümanlar sonuçlanan değerlerin alındığı yerlere göstericilerdir.
      </para><para>
Dönen değer normalde başarılı atamaların sayısıdır. Herhangi bir eşleşme bulunmadan önce bir dosya sonu durumu saptanırsa, şablondaki tek karakterler ve boşluk karakterleri içerilerek <command>WEOF</command> ile döner.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-fscanf">
<indexterm scope="glibc-fn"><primary>fscanf</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>fscanf</command></funcdef>
<paramdef>(FILE       *<varname>akım</varname>,
 const char *<varname>şablon</varname>,
 …)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev, girdinin standart girdi yerine <varname>akım</varname> akımından okunması dışında <command>scanf</command> gibidir.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-fwscanf">
<indexterm scope="glibc-fn"><primary>fwscanf</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>fwscanf</command></funcdef>
<paramdef>(FILE          *<varname>akım</varname>,
 const wchar_t *<varname>şablon</varname>,
 …)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev, girdinin standart girdi yerine <varname>akım</varname> akımından okunması dışında <command>wscanf</command> gibidir.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-sscanf">
<indexterm scope="glibc-fn"><primary>sscanf</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>sscanf</command></funcdef>
<paramdef>(const char *<varname>s</varname>,
 const char *<varname>şablon</varname>,
 …)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev, girdinin standart girdi yerine boş karakter sonlandırmalı <varname>s</varname> dizgesinden alınması dışında <command>scanf</command> gibidir. Dizge sonunun aşılması bir dosya sonu durumu olarak ele alınır.
      </para><para>
Bu işlevin davranışı, birbirini kapsayan nesneler arasında kopyalama yapılırsa, örneğin, <command>%s</command>, <command>%S</command> veya <command>%[</command> belirtecinin denetimi altında okunacak bir dizgeyi alacak argüman olarak <varname>s</varname> dizgesi verilmişse, tanımsızdır.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-swscanf">
<indexterm scope="glibc-fn"><primary>swscanf</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>swscanf</command></funcdef>
<paramdef>(const wchar_t *<varname>ws</varname>,
 const char    *<varname>şablon</varname>,
 …)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev, girdinin standart girdi yerine boş karakter sonlandırmalı <varname>s</varname> dizgesinden alınması dışında <command>wscanf</command> gibidir. Dizge sonunun aşılması bir dosya sonu durumu olarak ele alınır.
      </para><para>
Bu işlevin davranışı, birbirini kapsayan nesneler arasında kopyalama yapılırsa, örneğin, <command>%s</command>, <command>%S</command> veya <command>%[</command> belirtecinin denetimi altında okunacak bir dizgeyi alacak argüman olarak <varname>ws</varname> dizgesi verilmişse, tanımsızdır.
      </para></funcdescr></funcsynopsis>
    </para>
  </sect1>
  <sect1 xml:id="glibc-Variable-Arguments-Input">
    <title>Değişkin Girdi İşlevleri</title>
    <titleabbrev><command>vscanf</command> ve arkadaşları.</titleabbrev>
    <para>
Yerleşik biçimli çıktı işlevleri olarak <command>scanf</command> oluşumunu kullanarak kendi değişkin <command>scanf</command> benzeri işlevlerinizi tanımlayabilmeniz için <command>vscanf</command> işlevi ve arkadaşları oluşturulmuştur. Bu işlevler <command>vprintf</command> serisi biçimli çıktı işlevlerini andırır. Nasıl kullanıldıkları ile ilgili önemli bilgileri <xref linkend="glibc-Variable-Arguments-Output"/> bölümünde bulabilirsiniz.
    </para><para>
<warning><title>Taşınabilirlik Bilgisi</title><para>Bu bölümdeki işlevler ISO C99'da tanımlanmıştı ve daha önce GNU oluşumları olarak vardı.</para></warning>
    </para><para xml:id="glibc-vscanf">
<indexterm scope="glibc-fn"><primary>vscanf</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>vscanf</command></funcdef>
<paramdef>(const char *<varname>şablon</varname>,
 va_list     <varname>arglist-gstr</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev değişken sayıdaki argümanlarını doğrudan almak yerine <command>va_list</command> türündeki <varname>arglist-gstr</varname> argüman listesi göstericisinden alması dışında <command>scanf</command> ile aynıdır (<xref linkend="glibc-Variadic-Functions"/>).
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-vwscanf">
<indexterm scope="glibc-fn"><primary>vwscanf</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>vwscanf</command></funcdef>
<paramdef>(const wchar_t *<varname>şablon</varname>,
 va_list        <varname>arglist-gstr</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev değişken sayıdaki argümanlarını doğrudan almak yerine <command>va_list</command> türündeki <varname>arglist-gstr</varname> argüman listesi göstericisinden alması dışında <command>wscanf</command> ile aynıdır (<xref linkend="glibc-Variadic-Functions"/>).
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-vfscanf">
<indexterm scope="glibc-fn"><primary>vfscanf</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>vfscanf</command></funcdef>
<paramdef>(FILE       *<varname>akım</varname>,
 const char *<varname>şablon</varname>,
 va_list     <varname>arglist-gstr</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev değişken sayıdaki argümanlarını doğrudan almak yerine <command>va_list</command> türündeki <varname>arglist-gstr</varname>  argüman listesi göstericisinden alması dışında <command>fscanf</command> ile aynıdır.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-vfwscanf">
<indexterm scope="glibc-fn"><primary>vfwscanf</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>vfwscanf</command></funcdef>
<paramdef>(FILE          *<varname>akım</varname>,
 const wchar_t *<varname>şablon</varname>,
 va_list        <varname>arglist-gstr</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev değişken sayıdaki argümanlarını doğrudan almak yerine <command>va_list</command> türündeki <varname>arglist-gstr</varname> argüman listesi göstericisinden alması dışında <command>fwscanf</command> ile aynıdır.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-vsscanf">
<indexterm scope="glibc-fn"><primary>vsscanf</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>vsscanf</command></funcdef>
<paramdef>(const char *<varname>s</varname>,
 const char *<varname>şablon</varname>,
 va_list     <varname>arglist-gstr</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev değişken sayıdaki argümanlarını doğrudan almak yerine <command>va_list</command> türündeki <varname>arglist-gstr</varname> argüman listesi göstericisinden alması dışında <command>sscanf</command> ile aynıdır.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-vswscanf">
<indexterm scope="glibc-fn"><primary>vswscanf</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>vswscanf</command></funcdef>
<paramdef>(const wchar_t *<varname>s</varname>,
 const wchar_t *<varname>şablon</varname>,
 va_list        <varname>arglist-gstr</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev değişken sayıdaki argümanlarını doğrudan almak yerine <command>va_list</command> türündeki <varname>arglist-gstr</varname> argüman listesi göstericisinden alması dışında <command>swscanf</command> ile aynıdır.
      </para></funcdescr></funcsynopsis>
    </para><para>
GNU C'de <command>scanf</command> tarzı biçim dizgesi kullanan bir işlevi derleyiciye bildirebileceğiniz özel bir yapı vardır. Bu yapı kullanıldığında işlevin her çağrısı için kullanılan argümanların türleri ve sayısı denetlenir ve biçim dizgesiyle eşleşmeyenler için sizi uyarır. İşlev özniteliklerinin bildirilmesi ile ilgili ayrıntılı bilgi edinmek için GCC kılavuzunun (info) "Declaring Attributes of Functions" (İşlevlerin Özniteliklerinin Bildirilmesi) bölümüne bakınız.
    </para>
  </sect1>
</chapter>

<chapter xml:id="glibc-EOF-and-Errors">
  <title>Dosya Sonu ve Hatalar</title>
  <titleabbrev>Bir G/Ç hatası oluşursa bunu nasıl belirtebilirsiniz.</titleabbrev>
  <para>
<indexterm scope="glibc-cp"><primary>akımlar</primary><secondary>dosya sonu</secondary></indexterm>
Bu kısımda açıklanan işlevlerin bir çoğu işlemin başarısızlıkla tamamlandığını belirten <command>EOF</command> makrosunun değerini döndürürler. <command>EOF</command> hem dosya sonunu hem de bir takım hataların olduğunu belirttiğinden, dosya sonu için <command>feof</command>, hatalar için de <command>ferror</command> işlevleri sağlanmıştır. Bunları kullanarak dosya sonu ile ilgili hataları ayrı ayrı elde edebilirsiniz. Bu işlevler akım nesnesinin dahili durumunun bir parçası olan göstergelere bakarlar, bu göstergeler akım üzerindeki önceki G/Ç işlemleri tarafından oluşturulan durumu gösterirler.
  </para><para xml:id="glibc-EOF">
<indexterm scope="glibc-vr"><primary>EOF</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>int <command>EOF</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu makro dosya sonu veya bazı hata durumlarını gösteren ve dar yönlenimli akım işlevleri tarafından döndürülen bir tamsayı değerdir. Diğer kütüphanelerde değeri herhangi bir negatif değer olabilirse de GNU kütüphanesinde değeri <command>-1</command>’dir.
    </para><para>
Bu sembol <filename>stdio.h</filename> başlık dosyasında bildirilmiştir.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-WEOF2">
<indexterm scope="glibc-vr"><primary>WEOF</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>int <command>WEOF</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu makro dosya sonu veya bazı hata durumlarını gösteren ve geniş yönlenimli akım işlevleri tarafından döndürülen bir tamsayı değerdir. Diğer kütüphanelerde değeri herhangi bir negatif değer olabilirse de GNU kütüphanesinde değeri <command>-1</command>’dir.
    </para><para>
Bu sembol <filename>wchar.h</filename> başlık dosyasında bildirilmiştir.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-feof">
<indexterm scope="glibc-fn"><primary>feof</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>feof</command></funcdef>
<paramdef>(FILE *<varname>akım</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>feof</command> işlevi, <varname>akım</varname> akımında sadece ve sadece dosya sonu göstergesi etkin ise sıfırdan farklı bir değerle döner.
    </para><para>
Bu sembol <filename>stdio.h</filename> başlık dosyasında bildirilmiştir.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-feof_unlocked">
<indexterm scope="glibc-fn"><primary>feof_unlocked</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>feof_unlocked</command></funcdef>
<paramdef>(FILE *<varname>akım</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>feof_unlocked</command> işlevi akımı dolaylı olarak kilitlememesi dışında <command>feof</command> işlevi ile aynıdır.
    </para><para>
Bu işlev bir GNU oluşumudur.
    </para><para>
Bu sembol <filename>stdio.h</filename> başlık dosyasında bildirilmiştir.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-ferror">
<indexterm scope="glibc-fn"><primary>ferror</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>ferror</command></funcdef>
<paramdef>(FILE *<varname>akım</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>ferror</command> işlevi, <varname>akım</varname> akımında sadece ve sadece hata göstergesi etkin ise sıfırdan farklı bir değerle döner. Hata göstergesi, akımda bir önceki işlem sırasında bir hatanın oluştuğunu gösterir.
    </para><para>
Bu sembol <filename>stdio.h</filename> başlık dosyasında bildirilmiştir.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-ferror_unlocked">
<indexterm scope="glibc-fn"><primary>ferror_unlocked</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>ferror_unlocked</command></funcdef>
<paramdef>(FILE *<varname>akım</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>ferror_unlocked</command> işlevi akımı dolaylı olarak kilitlememesi dışında <command>ferror</command> işlevi ile aynıdır.
    </para><para>
Bu işlev bir GNU oluşumudur.
    </para><para>
Bu sembol <filename>stdio.h</filename> başlık dosyasında bildirilmiştir.
    </para></funcdescr></funcsynopsis>
  </para><para>
Akım ile ilşkili hata göstergesi ayarlarına ek olarak, akımlar üzerinde işlem yapan işlevler, dosya tanıtıcılar üzerinde düşük seviyeli işlemler yapan eşdeğerleri ile aynı şekilde <command>errno</command> değerini ayarlarlar. Örneğin, <command>fputc</command>, <command>printf</command> ve <command>fflush</command> gibi bir akıma çıktılama yapan tüm işlevler <varname>yazma</varname> üzerine gerçeklendiklerinden bunlar için <varname>yazma</varname> ile ilgili <command>errno</command> hataları anlamlı olmaktadır. Dosya tanıtıcı seviyesi G/Ç işlemleri ile ilgili daha fazla bilgi edinmek için <xref linkend="glibc-Low-Level-I-O"/> kısmına bakınız.
  </para>
</chapter>

<chapter xml:id="glibc-Error-Recovery">
  <title>Hatalardan Kurtulma</title>
  <titleabbrev>Hatalar hakkında neler yapılabilir.</titleabbrev>
  <para>
Bir hatayı ya da dosya sonu durumunu <command>clearerr</command> işlevi ile doğrudan temizleyebilirsiniz.
  </para><para xml:id="glibc-clearerr">
<indexterm scope="glibc-fn"><primary>clearerr</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>void <command>clearerr</command></funcdef>
<paramdef>(FILE *<varname>akım</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev <varname>akım</varname> akımı ile ilgili dosya sonu ve hata göstergelerini temizler.
    </para><para>
Ayrıca dosya konumlama işlevleri de (<xref linkend="glibc-File-Positioning"/>) akım ile ilgili dosya sonu göstergesini temizler.
</para></funcdescr></funcsynopsis></para><para xml:id="clearerr_unlocked">
<indexterm scope="glibc-fn"><primary>clearerr_unlocked</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>void <command>clearerr_unlocked</command></funcdef>
<paramdef>(FILE *<varname>akım</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>clearerr_unlocked</command> işlevi akımı dolaylı olarak kilitlememesi dışında <command>clearerr</command> işlevi ile aynıdır.
    </para><para>
Bu işlev bir GNU oluşumudur.
    </para></funcdescr></funcsynopsis>
  </para><para>
<note><para>Hata göstergesinin temizlenmesi ve başarısız akım işlevinin yinelenmesi <emphasis>doğru olmaz</emphasis>. Başarısız bir yama işleminden sonra, tamponda olup da dosyaya gönderilmesi gereken verinin bir kısmı iptal olabilir. Bir kere yinelense bile verinin kaybına ya da tekrarına sebep olabilir.</para></note>
   </para><para>
Başarısız bir okuma ise ikinci deneme için dosya göstericisini ilgisiz bir konumda bırakabilir. Her iki durumda da işlemi yinelemeden önce bilinen konuma ilerlemeniz gerekir.
   </para><para>
Hataların çoğu kurtarılabilir değildir; ikinci bir deneme daima aynı şekilde başarısız olur. En iyisi karmaşık hata kurtarma kodları yazmak yerine, hatayı kullanıcıya raporlayarak işlemi kesmektir.
   </para><para>
Bir önemli hata durumu da <command>EINTR</command>’dir (<xref linkend="glibc-Interrupted-Primitives"/>). Çoğu akım G/Ç gerçeklemesi onu az çok sakıncalı sıradan bir hata olarak ele alır. Tüm sinyalleri <command>SA_RESTART</command> bayrağıyla kurarak bu rahatsız edici durumdan kaçınabilirsiniz.
   </para><para>
Benzer sebeplerle, bir akımın dosya tanıtıcısının bloklamayan G/Ç olarak ayarlanması genellikle tavsiye edilmez.
   </para>
</chapter>

<chapter xml:id="glibc-Binary-Streams">
  <title>İkilik ve Metin Akımları</title>
  <titleabbrev>Bazı sistemler metin dosyaları ile ikilik dosyaları farklı ele alır.</titleabbrev>
  <para>
GNU sistemleri ve diğer POSIX uyumlu işletim sistemleri tüm dosyaları karakterlerin tektip dizisi olarak tanır. Diğer yandan, başka bazı sistemler metin içeren dosyalarla ikilik veri içeren dosyalar arasında ayrım yapar; ISO C giriş ve çıkış oluşumları da bu ayrıma göredir. Bu kısımda böyle sistemler arasında taşınabilir yazılımların nasıl geliştirileceğinden bahsedilmiştir.
  </para><para>
<indexterm scope="glibc-cp"><primary>akımlar</primary><secondary>metin</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>akımlar</primary><secondary>ikilik</secondary></indexterm>
Bir akımı açarken ya bir <wordasword>metin akımı</wordasword> ya da bir <wordasword>ikilik akım</wordasword> belirtebilirsiniz. Bir ikilik akımı, <command>fopen</command> işlevinin <varname>açıştürü</varname> argümanına <command>b</command> değiştiricisini belirterek açabilirsiniz; bkz. <xref linkend="glibc-Opening-Streams"/>. Bu seçenek olmaksızın bir dosya bir metin akımı olarak açılır.
  </para><para>
Metin akımları ile ikilik akımlar çeşitli bakımlardan ayrılır:
  </para><para>
    <itemizedlist><listitem><para>
Veri, bir ikilik akımdan basitçe karakterlerin uzun bir serisi olarak, bir metin akımından ise satırsonu (<command>'\n'</command>) karakterleri ile sonlandırılmış satırlara bölünerek okunur. Bazı sistemler, 254 karakterden (satırsonu karakteri dahil) uzun satırlar içeren metin akımlarında başarısız olabilir.
<indexterm scope="glibc-cp"><primary>satır (bir metin dosyasında)</primary></indexterm>
      </para></listitem><listitem><para>
Bazı sistemlerde, metin dosyaları sadece basılabilen karakterleri, yatay sekme karekterlerini ve satırsonu karakterlerini içerebilir ve diğer karakterler desteklenmeyebilir. Buna karşın, ikilik akımlar her türlü karakteri içerebilir.
     </para></listitem><listitem><para>
Bir metin akımı içinde bir satırsonu karakteri ile öncelenmiş boşluk karakterleri, dosya tekrar okunduğunda görünmeyebilir.
     </para></listitem><listitem><para>
Daha genel olarak, bir metin akımından okunan veya metin akımına yazılan karakterler arasında birebir eşleşme gerekli olmayabilir.
     </para></listitem></itemizedlist></para><para>
Bir ikilik akım, bir metin akımına göre daha tahmin edilebilir ve daha yetenekli olduğuna göre metin akımlarının ne amaçla sunulduğunu düşünebilirsiniz. Niçin basitçe sadece ikili akımlar kullanılmaz? Yanıtı, bu işletim sistemlerinde, metin ve ikilik akımların farklı dosya biçimlerini kullanması ve diğer metin yönlenimli uygulamalarla birlikte çalışırken sıradan bir metin dosyasının okumanın ve ona yazmanın tek yolunun bir metin akımı kullanmak olmasıdır.
   </para><para>
GNU kütüphanesinde ve tüm POSIX sistemlerde, ikilik akımlar ile metin akımları arasında bir fark yoktur. Bir akımı açtığınızda ikilik bir akım isteyip istemediğinize bakılmaksızın aynı çeşit akım alırsınız. Bu akım, metin akımlarının sahip olduğu bazı kısıtlamalar olmaksızın her türlü dosya içeriği ile kullanılabilir.
   </para></chapter>
<chapter xml:id="glibc-File-Positioning">
  <title>Dosyalarda Konumlama</title>
  <titleabbrev>Rasgele erişimli akımlar.</titleabbrev>
  <para>
<indexterm scope="glibc-cp"><primary>akımlar</primary><secondary>dosyalarda konumlama</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>akımlar</primary><secondary>konumlama</secondary></indexterm>
Bir akım üzerinde <wordasword>dosya konumlama</wordasword>, akımın dosyanın neresinde okuma veya yazma yaptığı ile ilgilidir. Akım üzerinde G/Ç, dosya üzerinde dosya konumlamayı ilerletir. GNU sisteminde, dosya konumu bir tamsayı ile ifade edilir ve dosyanın başlangıcından itibaren bayt sayısını gösterir. Bkz.  <xref linkend="glibc-File-Position"/>.
   </para><para>
Sıradan bir disk dosyasında yapılan G/Ç işlemlerinde, dosyanın istediğiniz bir bölümüne okuma veya yazma amacıyla dosya konumunu istediğiniz gibi değiştirebilirsiniz. Diğer bazı dosya çeşitlerinde de buna izin verilebilmektedir. Dosya konumu değiştirmeyi destekleyen dosyalara kimi zaman <wordasword>rasgele erişimli</wordasword> dosyalar da denir.
  </para><para>
Bu bölümdeki işlevleri bir akım ile ilişkilendirilmiş dosya konumlayıcıyı değiştirmek ya da durumunu saptamak amacıyla kullanabilirsiniz. Aşağıda listelenen semboller <filename>stdio.h</filename> başlık dosyasında bildirilmiştir.
<indexterm scope="glibc-pg"><primary>stdio.h</primary></indexterm>
  </para><para xml:id="glibc-ftell">
<indexterm scope="glibc-fn"><primary>ftell</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>long int <command>ftell</command></funcdef>
<paramdef>(FILE *<varname>akım</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev <varname>akım</varname> akımının o andaki dosya konumu ile döner.
   </para><para>
Bu işlev, eğer akım dosya konumlamayı desteklemiyorsa veya dosya konumu bir  <command>long int</command> ile ifade edilemiyorsa ve olası diğer sebeplerle başarısız olabilir. Bir başarısızlık durumunda <command>-1</command> ile döner.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-ftello">
<indexterm scope="glibc-fn"><primary>ftello</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>off_t <command>ftello</command></funcdef>
<paramdef>(FILE *<varname>akım</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>ftello</command> işlevi <command>off_t</command> türünden bir dosya konumu ile dönmesi dışında <command>ftell</command> işlevi gibidir. POSIX belirtimi tarafından kullanılan <command>long int</command>'in aksine, bu veri türünü destekleyen sistemler, tüm dosya konumlarını açıklamakta onu kullanırlar. Bu ikisinin aynı boyutta olması gerekli değildir.  Bu nedenle, gerçekleme, tepede POSIX uyumlu düşük seviyeli bir G/Ç gerçeklemesi olarak yazılmışsa <command>ftell</command> kullanımı bazı sorunlara yolaçabilir, bu durumda mümkün olduğunca <command>ftello</command> kullanımı tercih edilir.
   </para><para>
Bu işlev başarısız olduğunda <command>(off_t) -1</command> ile döner. Bu, dosya konumlama desteği olmamasından ya da bir dahili hatanın sonucu olabilir. Aksi takdirde, dönüş değeri o anki dosya konumudur.
   </para><para>
Bu işlev Tek Unix Belirtiminin 2. sürümünde tanımlı bir genişletmedir.
   </para><para>
Kaynaklar, 32 bitlik sistemlerde <command>_FILE_OFFSET_BITS == 64</command> ile derlendiğinde bu işlev <command>ftello64</command> olarak davranır. Yani büyük dosya desteği arayüzü şeffaf olarak eski arayüzle yer değiştirir.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-ftello64">
<indexterm scope="glibc-fn"><primary>ftello64</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>off64_t <command>ftello64</command></funcdef>
<paramdef>(FILE *<varname>akım</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev dönüş değerinin <command>off64_t</command> türünde olması dışında
<command>ftello</command> gibidir.  Bu ayrıca, <varname>akım</varname> akımının, <literal>2</literal><superscript>31</superscript> baytlık sınırın üzerindeki dosya konumlarına konumlayan dosya işlemlerinin  başarılı olabildiği <command>fopen64</command>, <command>freopen64</command> veya <command>tmpfile64</command> işlevlerinin kullanılarak açılmasını gerektirir.
   </para><para>
Kaynaklar, 32 bitlik sistemlerde <command>_FILE_OFFSET_BITS == 64</command> ile derlendiğinde bu işlev <command>ftello</command> ismiyle de kullanılabilir. Yani büyük dosya desteği arayüzü şeffaf olarak eski arayüzle yer değiştirir.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-fseek">
<indexterm scope="glibc-fn"><primary>fseek</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>fseek</command></funcdef>
<paramdef>(FILE    *<varname>akım</varname>,
 long int <varname>konum</varname>,
 int      <varname>nereden</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>fseek</command> işlevi <varname>akım</varname> akımının dosya konumunu değiştirmekte kullanılır. <varname>nereden</varname> parametresinin değeri, <varname>konum</varname> değerinin dosyanın başlangıcına mı, o anki dosya konumuna göre mi yoksa dosyanın sonuna göre mi konumlanacağına bağlı olarak sırasıyla <command>SEEK_SET</command>, <command>SEEK_CUR</command> ya da <command>SEEK_END</command> sabitlerinden biri olmalıdır.
   </para><para>
Eğer işlem başarılı olursa dönüş değeri sıfırdır. Sıfırdan farklı bir dönüş değeri işlemin başarısız olduğunu gösterir. Bir başarılı çağrı ayrıca <varname>akım</varname> akımının dosyasonu göstergesini temizler ve <command>ungetc</command> kullanımıyla "geriye basılan" karakterleri iptal eder.
    </para><para>
<command>fseek</command> dosya konumunu değiştirmeden önce tamponlanmış çıktıyı ya boşaltır ya da aksine daha sonra dosyadaki yerine yazılmak üzere onu hatırlar.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-fseeko">
<indexterm scope="glibc-fn"><primary>fseeko</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>fseeko</command></funcdef>
<paramdef>(FILE *<varname>akım</varname>,
 off_t <varname>konum</varname>,
 int   <varname>nerden</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev <command>fseek</command> işlevi gibidir, ancak POSIX türleri kullanılan sistemlerde <command>fseek</command> kullanımından kaynaklanan bir sorunu düzeltir. Konum için <command>long int</command> türünde bir değerin kullanılması POSIX ile uyumlu değildir. <command>fseeko</command> işlevi <varname>konum</varname> parametresi için doğru tür olan <command>off_t</command> türünü kullanır.
   </para><para>
Bu sebeple, işlevselliği ilgili tanımlamaya daha yakın olduğundan (tamamen farklı bile olsa) mümkünse <command>ftello</command> kullanımı tercih edilmelidir.
   </para><para>
İşlevsellik ve dönüş değeri <command>fseek</command> ile aynıdır.
   </para><para>
Bu işlev Tek Unix Belirtiminin 2. sürümünde tanımlı bir genişletmedir.
   </para><para>
Kaynaklar, 32 bitlik sistemlerde <command>_FILE_OFFSET_BITS == 64</command> ile derlendiğinde bu işlev <command>fseeko64</command> olarak davranır. Yani büyük dosya desteği arayüzü şeffaf olarak eski arayüzle yer değiştirir.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-fseeko64">
<indexterm scope="glibc-fn"><primary>fseeko64</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>fseeko64</command></funcdef>
<paramdef>(FILE   *<varname>akım</varname>,
 off64_t <varname>konum</varname>,
 int     <varname>nereden</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev dönüş değerinin <command>off64_t</command> türünde olması dışında
<command>fseeko</command> gibidir.  Bu ayrıca, <varname>akım</varname> akımının, <literal>2</literal><superscript>31</superscript> baytlık sınırın üzerindeki dosya konumlarına konumlayan dosya işlemlerinin  başarılı olabildiği <command>fopen64</command>, <command>freopen64</command> veya <command>tmpfile64</command> işlevlerinin kullanılarak açılmasını gerektirir.
   </para><para>
Kaynaklar, 32 bitlik sistemlerde <command>_FILE_OFFSET_BITS == 64</command> ile derlendiğinde bu işlev <command>fseeko</command> ismiyle de kullanılabilir. Yani büyük dosya desteği arayüzü şeffaf olarak eski arayüzle yer değiştirir.
    </para></funcdescr></funcsynopsis>
  </para><para>
<note><title>Uyumluluk Bilgisi:</title><para>POSIX dışı sistemlerde <command>ftell</command>, <command>ftello</command>, <command>fseek</command> ve <command>fseeko</command> işlevleri sadece ikilik akımlarla düzgün çalışabilir. Bkz. <xref linkend="glibc-Binary-Streams"/>.
     </para></note>
   </para><para>
Aşağıdaki sembolik sabitler <command>fseek</command>. işlevinin <varname>nereden</varname> argümanında kullanmak için tanımlanmışır. Bunlar ayrıca, <command>lseek</command> işleviyle kullanmak (<xref linkend="glibc-I-O-Primitives"/>) ve dosya kilitleri için konum belirtmek (<xref linkend="glibc-Control-Operations"/>) için de kullanılır.
   </para><para xml:id="glibc-SEEK_SET">
<indexterm scope="glibc-vr"><primary>SEEK_SET</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>int <command>SEEK_SET</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu tamsayı sabit, <command>fseek</command> veya <command>fseeko</command> işlevinin <varname>nereden</varname> argümanında dosyanın başlangıcına göre konum belirtmek için kullanılır.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-SEEK_CUR">
<indexterm scope="glibc-vr"><primary>SEEK_CUR</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>int <command>SEEK_CUR</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu tamsayı sabit, <command>fseek</command> veya <command>fseeko</command> işlevinin <varname>nereden</varname> argümanında dosyanın o anki dosya konumuna göre konum belirtmek için kullanılır.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-SEEK_END">
<indexterm scope="glibc-vr"><primary>SEEK_END</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>int <command>SEEK_END</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu tamsayı sabit, <command>fseek</command> veya <command>fseeko</command> işlevinin <varname>nereden</varname> argümanında dosyanın sonuna göre konum belirtmek için kullanılır.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-rewind">
<indexterm scope="glibc-fn"><primary>rewind</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>void <command>rewind</command></funcdef>
<paramdef>(FILE *<varname>akım</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>rewind</command> işlevi <varname>akım</varname> akımını dosyanın başlangıcına konumlar. <command>fseek</command> veya <command>fseeko</command> işlevinin <varname>nereden</varname> argümanında <command>SEEK_SET</command> ve <varname>konum</varname> argümanında <command>0L</command> belirtilerek çağrılmasına eşdeğerdedir. Bu işlevlerin aksine dönüş değeri yoktur ve akımın hata göstergesi de sıfırlanır.
    </para></funcdescr></funcsynopsis>
  </para><para>
Eski BSD sistemleri ile uyumluluk adına <command>SEEK_…</command> sabitlerine karşılık olarak aşağıdaki sabitler de desteklenmektedir. Bu sabitler iki farklı başlık dosyasında tanımlıdır: <filename>fcntl.h</filename> ve <filename>sys/file.h</filename>.
  </para><para>
    <variablelist><varlistentry><term><literal>L_SET</literal>
<indexterm scope="glibc-vr"><primary>L_SET</primary></indexterm>
    </term><listitem><para><literal>SEEK_SET</literal> ile aynıdır.
    </para></listitem></varlistentry><varlistentry><term><literal>L_INCR</literal>
<indexterm scope="glibc-vr"><primary>L_INCR</primary></indexterm>
    </term><listitem><para><literal>SEEK_CUR</literal> ile aynıdır.
    </para></listitem></varlistentry><varlistentry><term><literal>L_XTND</literal>
<indexterm scope="glibc-vr"><primary>L_XTND</primary></indexterm>
    </term><listitem><para><literal>SEEK_END</literal> ile aynıdır.
    </para></listitem></varlistentry></variablelist>
  </para>
</chapter>
<chapter xml:id="glibc-Portable-Positioning">
  <title>Taşınabilir Dosya Konumlama İşlevleri</title>
  <titleabbrev>Özel ISO C sistemlerde rasgele erişim.</titleabbrev>
  <para>
GNU sistemlerinde dosya konumlaması tamamen karakter sayısıdır. <command>fseek</command> veya <command>fseeko</command> işlevine konumu karakter sayısı olarak belirtebilir ve herhangi bir rasgele erişimli dosyada düzgün sonuçlar alabilirsiniz. Ancak ISO C sistemlerinde dosya konumlaması bu şekilde değildir.
   </para><para>
Bazı sistemlerde metin akımları ikilik akımlardan tamamen farklıdır ve bir metin akımının dosya konumunu dosyanın başlangıcından itibaren karakterlerin sayısı olarak belirtmek mümkün değildir. Örneğin bazı sistemlerde önce dosya içindeki kaydın konumuna oradan da kayıt içindeki karakter konumuna erişilir.
   </para><para>
Sonuç olarak, eğer yazılımınızın bu sistemlere taşınabilir olmasını isterseniz bazı kurallara uymanız gerekir:
  </para><para>
    <itemizedlist><listitem><para>
Bir metin akımında <command>ftell</command> işlevinden dönen değer, o ana kadar okunan karakterlerin sayısıyla bire bir ilişkili değildir. Tek bir şeyden emin olunabilir: <command>fseek</command> veya <command>fseeko</command> işlevinin <varname>konum</varname> argümanına aynı değerleri ardışık kullanarak geriye aynı dosya konumuna gidebilirsiniz.
     </para></listitem><listitem><para>
Bir metin akımında bir <command>fseek</command> veya <command>fseeko</command> çağrısında ya <varname>konum</varname> sıfır olmalı ya da <varname>nereden</varname> argümanının değeri <command>SEEK_SET</command> olmalı ve <varname>konum</varname> aynı akım üzerinde bir önceki <command>ftell</command> çağrısının sonucu olmalıdır.
     </para></listitem><listitem><para>
Bir metin akımının dosya konumlayıcı değeri, bu karakterler, onları okunmamış ya da iptal edilmemiş yapan <command>ungetc</command> ile geriye basılmışsa tanımsızdır. Bkz.  <xref linkend="glibc-Unreading"/>.
    </para></listitem></itemizedlist>
  </para><para>
Bu kurallara uysanız bile uzun dosyalarda hala bazı sorunlarınız olabilir, çünkü <command>ftell</command> ve <command>fseek</command> dosya konumu için <command>long int</command> değer kullanır. Bu tür, büyükçe bir dosyadaki tüm dosya konumlarına erişmek için yeterli olmayabilir. <command>ftello</command> ve <command>fseeko</command> işlevlerinin kullanımı <command>off_t</command> türünü kullanmalarından ötürü tüm dosya konumlarına erişmeya yardımcı olabileceği umulsa bile hala, bir dosya konumu ile ilişkili ek bilgileri elde etmekte yardımı olmayacaktır.
   </para><para>
Bu durumda, dosya konumu için özel kodlamalar kullanılan sistemlere destek vermek isterseniz, bunlar yerine <command>fgetpos</command> ve <command>fsetpos</command> işlevlerini kullanmanız daha iyi olur. Bu işlevler dosya konumunu belirtmek için dahili genişliği sistemden sisteme değişiklik gösteren <command>fpos_t</command> veri türünü kullanırlar.
   </para><para>
Bu semboller <filename>stdio.h</filename> başlık dosyasında bildirilmiştir.
<indexterm scope="glibc-pg"><primary>stdio.h</primary></indexterm>
   </para><para xml:id="glibc-fpos_t">
<indexterm scope="glibc-tp"><primary>fpos_t</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü">
<funcdef><command>fpos_t</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
<command>fgetpos</command> ve <command>fsetpos</command> işlevlerinde kullanmak üzere, bir akımın dosya konumu hakkındaki bilgileri kodlayan bir nesnenin türüdür.
   </para><para>
GNU sisteminde, <command>fpos_t</command>, dosya konumunu içeren dahili veriyi ve dönüşüm durum bilgilerini tutan bir veri yapısıdır. Diğer sistemlerdeki görüntüsü farklı olabilir.
   </para><para>
Kaynaklar, 32 bitlik sistemlerde <command>_FILE_OFFSET_BITS == 64</command> ile derlendiğinde büyük dosya desteği arayüzü eski arayüzün yerine geçtiğinden bu veri türü <command>fpos64_t</command> türüne eşdeğer olur.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-fpos64_t">
<indexterm scope="glibc-tp"><primary>fpos64_t</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü">
<funcdef><command>fpos64_t</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
<command>fgetpos64</command> ve <command>fsetpos64</command> işlevlerinde kullanmak üzere, bir akımın dosya konumu hakkındaki bilgileri kodlayan bir nesnenin türüdür.
   </para><para>
GNU sisteminde, <command>fpos64_t</command>, dosya konumunu içeren dahili veriyi ve dönüşüm durum bilgilerini tutan bir veri yapısıdır. Diğer sistemlerdeki görüntüsü farklı olabilir.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-fgetpos">
<indexterm scope="glibc-fn"><primary>fgetpos</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>fgetpos</command></funcdef>
<paramdef>(FILE   *<varname>akım</varname>,
 fpos_t *<varname>konum</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev <varname>akım</varname> akımının dosya konum değerini <varname>konum</varname> ile gösterilen <command>fpos_t</command> nesnesinde saklar. Başarı durumunda <command>fgetpos</command> sıfır ile döner, aksi halde gerçeklemeye bağlı bir pozitif değeri <command>errno</command> değişkeninde saklayarak sıfırdan farklı bir değerle döner.
   </para><para>
Kaynaklar, 32 bitlik sistemlerde <command>_FILE_OFFSET_BITS == 64</command> ile derlendiğinde büyük dosya desteği arayüzü eski arayüzün yerine geçtiğinden bu işlev <command>fgetpos64</command> işlevine eşdeğer olur.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-fgetpos64">
<indexterm scope="glibc-fn"><primary>fgetpos64</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>fgetpos64</command></funcdef>
<paramdef>(FILE     *<varname>akım</varname>,
 fpos64_t *<varname>konum</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev dosya konumunu <varname>konum</varname> ile gösterilen <command>fpos64_t</command> türünde bir değişken içinde döndürmesi dışında <command>fgetpos</command> işlevi gibidir.
   </para><para>
Kaynaklar, 32 bitlik sistemlerde <command>_FILE_OFFSET_BITS == 64</command> ile derlendiğinde büyük dosya desteği arayüzü eski arayüzün yerine geçtiğinden bu işlev <command>fgetpos</command> ismiyle de kullanılabilir.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-fsetpos">
<indexterm scope="glibc-fn"><primary>fsetpos</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>fsetpos</command></funcdef>
<paramdef>(FILE         *<varname>akım</varname>,
 const fpos_t *<varname>konum</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev, aynı akım üzerinde bir önceki <command>fgetpos</command> işlevinden dönen <varname>konum</varname> değeriyle <varname>akım</varname> akımının dosya göstericisini konumlandırır. Başarı durumunda <command>fsetpos</command> akım üzerindeki dosyasonu göstergesini temizler, <command>ungetc</command> kullanımıyla geriye basılan karakterleri iptal eder ve sıfır değeriyle döner. Aksi takdirde, gerçeklemeye göre <command>errno</command> değişkenine bir pozitif değer atar ve sıfırdan farklı bir değerle döner.
   </para><para>
Kaynaklar, 32 bitlik sistemlerde <command>_FILE_OFFSET_BITS == 64</command> ile derlendiğinde büyük dosya desteği arayüzü eski arayüzün yerine geçtiğinden bu işlev <command>fsetpos64</command> işlevine eşdeğer olur.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-fsetpos64">
<indexterm scope="glibc-fn"><primary>fsetpos64</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>fsetpos64</command></funcdef>
<paramdef>(FILE           *<varname>akım</varname>,
 const fpos64_t *<varname>konum</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev dosya konumlamasında kullanılacak <varname>konum</varname> parametresinin <command>fpos64_t</command> türünde bir değişken olarak verilmesi dışında <command>fsetpos</command> ile aynıdır.
   </para><para>
Kaynaklar, 32 bitlik sistemlerde <command>_FILE_OFFSET_BITS == 64</command> ile derlendiğinde büyük dosya desteği arayüzü eski arayüzün yerine geçtiğinden bu işlev <command>fsetpos</command> ismiyle de kullanılabilir.
    </para></funcdescr></funcsynopsis>
  </para>
</chapter>

<chapter xml:id="glibc-Stream-Buffering">
  <title>Akım Tamponlama</title>
  <titleabbrev>Akımların tamponları nasıl kontrol edilir.</titleabbrev>
  <para>
<indexterm scope="glibc-cp"><primary>akımlar</primary><secondary>tamponlama</secondary></indexterm>
Bir akıma yazılan karakterler normalde bir araya getirilir ve uygulama tarafından bir çıktı olarak gösterilmeden bir blok olarak dosyaya eşzamansız olarak aktarılır. Benzer olarak, akımlar çoğunlukla girdiyi karakter karakter değil bir blok olarak konak ortamından alırlar. Bu işleme <wordasword>tamponlama</wordasword> adı verilir.
   </para><para>
Girdi ve çıktıyı akımları kullanarak etkileşimli yapan uygulamalar yazıyorsanız, uygulamanızın kullanıcı arayüzünü tasarlayabilmek için tamponlamanın nasıl çalıştığını bilmek zorundasınız. Aksi takdirde, karşınızda ummadığınız bir çıktı ya da umulmadık bir takım davranışlar görebilirsiniz.
   </para><para>
Bu bölümde sadece karakterler, akımlarla yankılama ve akış denetimi gibi ve aygıtların belirli sınıflarında elde edilen şeyler arasında değil dosya ya da aygıtlar arasında nasıl aktarılacağı konusu işlenecektir. Uçbirimler üzerindeki denetim işlemleri ile ilgili bilgiler için <xref linkend="glibc-Low-Level-Terminal-Interface"/> bölümüne bakınız.
   </para><para>
Akım tamponlama oluşumlarını kullanmak yerine dosya tanımlayıcıları ile çalışan düşük seviye girdi ve çıktı işlevlerini birlikte kullanabilirsiniz. Bkz.  <xref linkend="glibc-Low-Level-I-O"/>.
   </para>
  <sect1 xml:id="glibc-Buffering-Concepts">
    <title>Tamponlama Kavramları</title>
    <titleabbrev>Terminoloji.</titleabbrev>
    <para>
Tamponlama stratejilerinin üç türü vardır:
    </para><para>
      <itemizedlist><listitem><para>
<firstterm>Tamponlanmamış</firstterm> bir akıma yazılan veya okunan karakterler dosyaya mümkün olduğunca tek tek aktarılır.
<indexterm scope="glibc-cp"><primary>akımlar</primary><secondary>tamponlanmamış</secondary></indexterm>
      </para></listitem><listitem><para>
Bir <firstterm>satır tamponlu</firstterm> akıma yazılan karakterler bir satırsonu karakterine rastlandığında dosyaya blok olarak aktarılır.
<indexterm scope="glibc-cp"><primary>akımlar</primary><secondary>satır tamponlu</secondary></indexterm>
      </para></listitem><listitem><para>
<firstterm>Tamamı tamponlu</firstterm> olarak bir akıma yazılan ya da okunan karakterler bir dosyaya keyfi uzunlukta bloklar halinde yazılır ya da okunur.
<indexterm scope="glibc-cp"><primary>akımlar</primary><secondary>tamamen tamponlu</secondary></indexterm>
      </para></listitem></itemizedlist>
    </para><para>
Yeni açılmış akımların normalde tamamı tamponludur, bir şey dışında: Bir uçbirim gibi bir etkileşimli aygıtla bağlantılı akımlar dahili olarak satır tamponludur. Tamponlama türünün seçimi hakkında daha ayrıntılı bilgi için <xref linkend="glibc-Controlling-Buffering"/> bölümüne bakınız. Genellikle, özdevinimli seçim açtığınız dosya ya da aygıt için tamponlamanın en uygun çeşidini sağlar.
    </para><para>
Etkileşimli aygıtlar için satır tamponlaması çıktılanan iletilerin sonuna (tam da istediğiniz şey) hemen bir satırsonu karakteri ekler. Bir satırsonu karakteri ile bitmeyen çıktılar hemen gösterilebileceği gibi gösterilmeyebilir de. Hemen görüntülenmesini isterseniz, <xref linkend="glibc-Flushing-Buffers"/> bölümünde açıklandığı gibi <command>fflush</command> ile tamponlu çıktıyı doğrudan doğruya aygıta boşaltabilirsiniz.
    </para></sect1>
  <sect1 xml:id="glibc-Flushing-Buffers">
    <title>Tamponların Boşaltılması</title>
    <titleabbrev>Çıktı tamponunun boşaltıldığını bilmek.</titleabbrev>
    <para>
<indexterm scope="glibc-cp"><primary>akımlar</primary><secondary>boşaltma</secondary></indexterm>
<wordasword>Boşaltma</wordasword>, bir tamponlu akımın biriken karakterleri bir dosyaya çıktılamasıdır. Bir akım üzerindeki tamponlu çıktının özdevinimli olarak boşaltılması çeşitli durumlarda ortaya çıkar:
    </para><para>
      <itemizedlist><listitem>
Çıktı tamponu doludur ve çıktılama yapmayı deniyorsunuzdur.
      </listitem><listitem>
Akım kapatılırken. Bkz.  <xref linkend="glibc-Closing-Streams"/>.
      </listitem><listitem>
<command>exit</command> çağrısı ile uygulamayı sonlandırırken. Bkz. <xref linkend="glibc-Normal-Termination"/>.
      </listitem><listitem>
Akım satır tamponludur ve bir satırsonu karakteri yazılmıştır.
      </listitem><listitem>
Bir akımın bir veriyi dosyadan okurken bir girdi işleminin varlığında.
      </listitem></itemizedlist>
    </para><para>
Bunların dışında bir tamponlu çıktıyı boşaltmak isterseniz <filename>stdio.h</filename> başlık dosyasında bildirilmiş olan <command>fflush</command> işlevi çağrılır.
<indexterm scope="glibc-pg"><primary>stdio.h</primary></indexterm>
    </para><para xml:id="glibc-fflush">
<indexterm scope="glibc-fn"><primary>fflush</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>fflush</command></funcdef>
<paramdef>(FILE *<varname>akım</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev <varname>akım</varname> üzerindeki herhangi bir tamponlu çıktının dosyaya boşaltılmasına sebep olur. Eğer <varname>akım</varname> bir boş gösterici ise <command>fflush</command>, tamponlu çıktının tüm açık çıktı akımlarına boşaltılmasına sebep olur.
      </para><para>
Bir yazma hatası oluşursa, bu işlev <command>EOF</command> döndürür. Aksi takdirde sıfır döner.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-fflush_unlocked">
<indexterm scope="glibc-fn"><primary>fflush_unlocked</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>fflush_unlocked</command></funcdef>
<paramdef>(FILE *<varname>akım</varname>)</paramdef>
</funcprototype><funcdescr><para>
Akımı kilitlememesi dışında <command>fflush</command> işlevi ile aynıdır.
      </para><para>
<command>fflush</command> işlevi o an açık olan tüm akımları boşaltmak için kullanılabilir. Bu bazı durumlarda kullanışlıdır ama bazı durumlarda da gereklidir. Örneğin, uçbirimden girdi bekleyen bir uygulama için, uçbirimde tüm çıktının görünür olması istenir. Fakat bu sadece satır tamponlu akımlar için anlamlıdır. Solaris özellikle bu durum için bir işlev içerir. Bu işlev GNU C kütüphanesinde bir takım şekillerde hep vardı ama hiçbir zaman resmen var denilmedi.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc_flushlbf">
<indexterm scope="glibc-fn"><primary sortas="flushlbf">_flushlbf</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>void <command>_flushlbf</command></funcdef>
<paramdef>(void)</paramdef>
</funcprototype><funcdescr><para>
<command>_flushlbf</command> işlevi o an açık bulunan tüm satır tamponlu akımları boşaltır.
      </para><para>
Bu işlev <filename>stdio_ext.h</filename> başlık dosyasında bildirilmiştir.
      </para></funcdescr></funcsynopsis>
    </para><para>
<note><title>Uyumluluk Bilgisi</title><para>Satır yönlenimli girdi ve çıktıya saplantılı olduğu bilinen kafa travması geçirmiş bazı işletim sistemlerinde satır tamponlu çıktının boşaltılması bir satır sonu karakterinin de yazılmasına sebep olur. Bereket versin ki bu "özellik" giderek daha az kullanılır olmaya doğru gidiyor. GNU sistemlerinde bundan dolayı kaygılanmanıza gerek yok.</para></note>
    </para><para>
Bazı durumlarda bekleyen çıktının boşaltılmak yerine unutulması daha kullanışlı olabilir. Eğer aktarımın bedeli yüksekse ve geçerli bir sebep yoksa çıktılama gerekmez. Bu gibi durumlar için Solaris’te standart dışı bir işlev vardır ve GNU kütüphanesinde de bulunmaktadır.
      </para><para xml:id="glibc__fpurge">
<indexterm scope="glibc-fn"><primary sortas="fpurge">__fpurge</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>void <command>__fpurge</command></funcdef>
<paramdef>(FILE *<varname>akım</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>__fpurge</command> işlevi <varname>akım</varname> akımının tamponunun temizlenmesini sağlar. Akım zaten okuma kipindeyse tampondaki tüm girdi kaybolur. Çıktılama kipindeyse tamponlu çıktı aygıta (veya igili saklama alanına) yazılmaz ve tampon temizlenir.
      </para><para>
Bu işlev <filename>stdio_ext.h</filename> başlık dosyasında bildirilmiştir.
      </para></funcdescr></funcsynopsis>
    </para>
  </sect1>
  <sect1 xml:id="glibc-Controlling-Buffering">
    <title>Tamponlama Çeşidinin Seçimi</title>
    <titleabbrev>Hangi tamponlama çeşidinin kullanılacağının belirtilmesi.</titleabbrev>
    <para>
Bir akım açıldıktan sonra (ancak henüz başka hiçbir işlem yapılmadan), hangi tamponlama çeşidini kullanacağınızı <command>setvbuf</command> işlevini kullanarak belirtebilirsiniz.
<indexterm scope="glibc-cp"><primary>akımlar</primary><secondary>tamponlama</secondary><tertiary>seçimi</tertiary></indexterm>
Bu bölümde sözü edilen oluşumlar <filename>stdio.h</filename> başlık dosyasında bildirilmiştir.
<indexterm scope="glibc-pg"><primary>stdio.h</primary></indexterm>
    </para><para xml:id="glibc-setvbuf">
<indexterm scope="glibc-fn"><primary>setvbuf</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>setvbuf</command></funcdef>
<paramdef>(FILE  *<varname>akım</varname>,
 char  *<varname>tampon</varname>,
 int    <varname>kip</varname>,
 size_t <varname>boyut</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev ile <varname>akım</varname> akımının hangi tamponlama kipini kullanacağı belirtilir. <varname>kip</varname> parametresinde, akımın tümünün tamponlanması isteniyorsa <command>_IOFBF</command>, satır tamponlu olması isteniyorsa <command>_IOLBF</command>, girdi/çıktının tamponlanması istenmiyorsa <command>_IONBF</command> sabiti kullanılır.
    </para><para>
<varname>tampon</varname> argümanına boş gösterici belirtilirse, işlev <command>malloc</command> kullanarak tamponu kendisi ayırır. Akımı serbest bıraktığınızda bu tamponu da serbest bırakmış olacaksınız.
    </para><para>
Aksi takdirde, <varname>tampon</varname> en az <varname>boyut</varname> karakterlik bir karakter dizisini tutacak büyüklükte seçilmelidir. Akım açık olduğu sürece ve bu dizi akım tamponunda kaldığı sürece, dizi akım tarafından kullanılıyor olacağından diziye ayrılan alanı bu süre zarfında serbest bırakmamalısınız. Tamponu ya durağan olarak ya da <command>malloc</command> (<xref linkend="glibc-Unconstrained-Allocation"/>) kullanarak ayırmalısınız. Dizinin bildirildiği blok çıkmadan önce dosyayı kapatmadıkça özdevinimli bir dizinin kullanılması önerilmez.
    </para><para>
Dizi bir akım tamponu olarak kaldığı sürece, akım G/Ç işlevleri dahili amaçları için tamponu kullanacaklardır. Akım diziyi tamponlama amacıyla kullanırken dizinin içeriğine doğrudan erişmeyi denememelisiniz.
    </para><para>
<command>setvbuf</command> işlevi başarılı olduğunda sıfır ile döner. <varname>kip</varname> değeri geçersizse ya da istek yerine getirilememişse sıfırdan farklı bir değerle döner.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc_IOFBF">
<indexterm scope="glibc-vr"><primary sortas="IOFBF">_IOFBF</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>int <command>_IOFBF</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu makronun değeri <command>setvbuf</command> işlevinin <varname>kip</varname> argümanında kullanılarak akımın tamamen tamponlanacağının belirtilmesini sağlayan bir tamsayı sabit ifadesidir.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc_IOLBF">
<indexterm scope="glibc-vr"><primary sortas="IOLBF">_IOLBF</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>int <command>_IOLBF</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu makronun değeri <command>setvbuf</command> işlevinin <varname>kip</varname> argümanında kullanılarak akımın satır tamponlu olacağının belirtilmesini sağlayan bir tamsayı sabit ifadesidir.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc_IONBF">
<indexterm scope="glibc-vr"><primary sortas="IONBF">_IONBF</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>int <command>_IONBF</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu makronun değeri <command>setvbuf</command> işlevinin <varname>kip</varname> argümanında kullanılarak akımın tamponlanmayacağının belirtilmesini sağlayan bir tamsayı sabit ifadesidir.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-BUFSIZ">
<indexterm scope="glibc-vr"><primary>BUFSIZ</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>int <command>BUFSIZ</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu makronun değeri <command>setvbuf</command> işlevinin <varname>boyut</varname> argümanında kullanılmasının iyi olacağı bir tamsayı sabit ifadesidir. Bu değer en azından <command>256</command> değerini garantiler.
      </para><para>
<command>BUFSIZ</command> değeri her sistemde akımın G/Ç verimliliğine uygun olarak seçilir. Bu bakımdan <command>setvbuf</command> çağrısında tampon boyu olarak <command>BUFSIZ</command> kullanmak iyi bir fikirdir.
      </para><para>
Aslında, <command>fstat</command> sistem çağrısından elde edilen bir değerin tampon boyu olarak kullanılması daha da iyi olacaktır: Dosya özniteliklerinin <command>st_blksize</command> alanı bu değeri içerir. Bkz.  <xref linkend="glibc-Attribute-Meanings"/>.
      </para><para>
Bazıları <command>fgets</command> (<xref linkend="glibc-Character-Input"/>) ile girdi alınması gibi durumlarda tamponların ayırma boyu olarak ayrıca <command>BUFSIZ</command> değerini de kullanırlar. G/Ç işlemlerinin verimli olmasını sağlamak dışında herhangi bir tamsayı değer yerine <command>BUFSIZ</command> kullanmanın geçerli bir sebebi yoktur.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-setbuf">
<indexterm scope="glibc-fn"><primary>setbuf</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>void <command>setbuf</command></funcdef>
<paramdef>(FILE *<varname>akım</varname>,
 char *<varname>tampon</varname>)</paramdef>
</funcprototype><funcdescr><para>
<varname>tampon</varname> argümanı bir boş gösterici olduğunda, bu işlev, <command>setvbuf</command> işlevinin <varname>kip</varname> argümanına <command>_IONBF</command> belirtilerek çağrılmasına eşdeğerdedir. Aksi takdirde <command>setvbuf</command> işlevinin <varname>boyut</varname> argümanında <command>BUFSIZ</command> ve <varname>kip</varname> argümanında <command>_IOFBF</command> kullanılarak <varname>tampon</varname> istendiği duruma eşdeğerdir.
      </para><para>
<command>setbuf</command> işlevi eski kod ile uyumluluk için vardır. Yeni yazılımlarda <command>setvbuf</command> işlevini kullanmalısınız.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-setbuffer">
<indexterm scope="glibc-fn"><primary>setbuffer</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>void <command>setbuffer</command></funcdef>
<paramdef>(FILE  *<varname>akım</varname>,
 char  *<varname>tampon</varname>,
 size_t <varname>boyut</varname>)</paramdef>
</funcprototype><funcdescr><para>
<varname>tampon</varname> bir boş gösterici ise bu işlev, <varname>akım</varname> akımını tamponsuz yapar. Aksi takdirde, <varname>akım</varname> akımı <varname>tampon</varname> tamponuna tamamen tamponlanacaktır. <varname>boyut</varname> argümanı <varname>tampon</varname> tamponunun boyunu belirtmekte kullanılır.
    </para><para>
Bu işlev eski BSD kodu ile uyumluluk için vardır. Yeni yazılımlarda <command>setvbuf</command> işlevini kullanmalısınız.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-setlinebuf">
<indexterm scope="glibc-fn"><primary>setlinebuf</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>void <command>setlinebuf</command></funcdef>
<paramdef>(FILE *<varname>akım</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev <varname>akım</varname> akımını satır tamponlu yapar ve tamponu sizin için ayırır.
    </para><para>
Bu işlev eski BSD kodu ile uyumluluk için vardır. Yeni yazılımlarda <command>setvbuf</command> işlevini kullanmalısınız.
      </para></funcdescr></funcsynopsis>
    </para><para>
Verilen bir akımın satır tamponlu mu yoksa Solaris’te standart-dışı ama GNU C kütüphanesinde mevcut işlevin kullanılmamış mı olduğu sorgulanabilir.
    </para><para xml:id="glibc__flbf">
<indexterm scope="glibc-fn"><primary sortas="flbf">__flbf</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>__flbf</command></funcdef>
<paramdef>(FILE *<varname>akım</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>__flbf</command> işlevi, <varname>akım</varname> akımı satır tamponlu ise sıfırdan farklı bir değerle döner. Aksi takdirde sıfır ile döner.
      </para><para>
Bu işlev <command>stdio_ext.h</command> başlık dosyasında bildirilmiştir.
      </para></funcdescr></funcsynopsis>
    </para><para>
Tampon boyunu ve ne kadarının kullanılmş olsuğunu sorgulayan iki işlev daha vardır ve bunlar Solaris’te de vardır.
    </para><para xml:id="glibc__fbufsize">
<indexterm scope="glibc-fn"><primary sortas="fbufsize">__fbufsize</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>size_t <command>__fbufsize</command></funcdef>
<paramdef>(FILE *<varname>akım</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>__fbufsize</command> işlevi, <varname>akım</varname> akımının tampon boyu ile döner. Bu değer akım kullanımını eniyilemek için kullanılabilir.
      </para><para>
Bu işlev <command>stdio_ext.h</command> başlık dosyasında bildirilmiştir.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc__fpending">
<indexterm scope="glibc-fn"><primary sortas="fpending">__fpending</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>size_t <command>__fpending</command></funcdef>
<paramdef>(FILE *<varname>akım</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>__fpending</command> işlevi, çıktı tamponunda o an bulunan karakterlerin sayısı ile döner. Geniş karakterli tamponlar için bu boyut geniş karakter cinsindendir. Bu işlev okuma kipindeki ya da salt okunur açılmış tamponlarda kulllanılmamalıdır.
      </para><para>
Bu işlev <command>stdio_ext.h</command> başlık dosyasında bildirilmiştir.
      </para></funcdescr></funcsynopsis>
    </para>
  </sect1>
</chapter>
<chapter xml:id="glibc-Other-Kinds-of-Streams">
  <title>Diğer Akım Çeşitleri</title>
  <titleabbrev>Açık bir dosyanın karşılığı olmayan akımlar.</titleabbrev>
  <para>
GNU kütüphanesinde bir açık dosyanın karşılığı olması gerekli olmayan  akım çeşitleri tanımlayabilme imkanı da vardır.
  </para><para>
Bu tür bir akım bir girdiyi bir dizgeden alabilir veya bir dizgeye yazabilir. Bu çeşit akımlar dahili olarak <command>sprintf</command> ve <command>sscanf</command> işlevlerinin gerçeklemelerinde kullanılmaktadır. Siz <xref linkend="glibc-String-Streams"/> bölümünde açıklanan işlevleri kullanarak bu çeşit akımları kendiniz de oluşturabilirsiniz.
  </para><para>
Daha genel olarak keyfi nesnelerde giriş/çıkış işlemi yapmakta kullanılan akımlar da tanımlanabilir. Bu protokol <xref linkend="glibc-Custom-Streams"/> bölümünde anlatılmıştır.
  </para><para>
<note><title>Taşınabilirlik Bilgisi</title><para>Bu bölümde açıklanan oluşumlar GNU'ya özeldir. Diğer sistemler ve diğer C gerçeklemeleri bunlara eşdeğer işlevleri sağlıyor/sağlamıyor olabilir.</para></note>
  </para>
  <sect1 xml:id="glibc-String-Streams">
    <title>Dizge Akımları</title>
    <titleabbrev>Dizge ya da bellek tamponu ile veri alışverişi için kullanılan akımlar.</titleabbrev>
    <para>
<indexterm scope="glibc-cp"><primary>akımlar</primary><secondary>dizgelerle G/Ç için</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>dizge akımı</primary></indexterm>
Bir dizge ya da bellek tamponu ile veri alışverişini mümkün kılan <command>fmemopen</command> ve <command>open_memstream</command> işlevleri <filename>stdio.h</filename> başlık dosyasında bildirilmiştir.
<indexterm scope="glibc-pg"><primary>stdio.h</primary></indexterm>
  </para><para xml:id="glibc-fmemopen">
<indexterm scope="glibc-fn"><primary>fmemopen</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>FILE *<command>fmemopen</command></funcdef>
<paramdef>(void       *<varname>tampon</varname>,
 size_t      <varname>boyut</varname>,
 const char *<varname>açıştürü</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev <varname>tampon</varname> tamponu ile belirtilen tamponu kullanan ve <varname>açıştürü</varname> argümanında belirtilen erişimi mümkün kılan bir akım açar. <varname>tampon</varname> olarak belirtilen dizi en az <varname>boyut</varname> bayt uzunlukta olmalıdır.
    </para><para>
<varname>tampon</varname> olarak bir boş gösterici belirtirseniz <command>fmemopen</command> işlevi <varname>boyut</varname> bayt uzunlukta bir diziyi (<command>malloc</command> kullanarak; bkz. <xref linkend="glibc-Unconstrained-Allocation"/>) özdevimli ayırırır. Bu genelikle sadece tampona bazı şeyleri yazdıktan hemen sonra okumak isterseniz kullanışlıdır. Çünkü aslında tampona bir gösterici almanın bir yolu yoktur (bunun için aşağıdaki <command>open_memstream</command> işlevini deneyin). Tampon, akım kapatıldığında serbest bırakılır.
    </para><para>
<varname>açıştürü</varname> argümanı <command>fopen</command> işlevindeki gibi belirtilir (bkz. <xref linkend="glibc-Opening-Streams"/>). <varname>açıştürü</varname> ekleme kipinde belirtilirse, ilk dosya konumu tampondaki ilk boş karaktere ayarlanır. Aksi takdirde ilk dosya konumu tamponun başlangıcıdır.
    </para><para>
Bir akım yazmak için açılırken boşaltılır ve kapatılır, bir boş karakter (sıfır baytı) yer varsa tamponun sonuna yazılır. Bunun için <varname>boyut</varname> argümanını tasarlarken bir ek baytı gözönüne almalısınız. Tampona <varname>boyut</varname> bayttan daha fazlası yazılmak istendiğinde bir hata oluşacaktır.
    </para><para>
Okumak için açılan bir akım için tampondaki boş karakterler (sıfır baytları) dosyanın sonu olarak ele alınmaz. Okuma işlemlerinde sadece dosya konumu <varname>boyut</varname> bayt ilerlediğinde dosya sonu olarak değerlendirilir. Bu durumda karakterleri bir boş karakter sonlandırmalı dizgeden okumak isterseniz <varname>boyut</varname> baytlık bir dizge sağlamanız gerekir.
    </para></funcdescr></funcsynopsis>
  </para><para>
Aşağıdaki örnekte bir dizgeden okuma yapmak için <command>fmemopen</command> kullanarak bir akım açılmaktadır:
    </para><para>
<screen>
#include &lt;stdio.h>

static char tampon[] = "deneme";

int
main (void)
{
  int ch;
  FILE *akim;

  akim = fmemopen (tampon, strlen (tampon), "r");
  while ((ch = fgetc (akim)) != EOF)
    printf ("%c okundu\n", ch);
  fclose (akim);

  return 0;
}
</screen></para><para>
Bu kod parçası aşağıdaki çıktıyı üretir:
    </para><para>
<screen>
d okundu
e okundu
n okundu
e okundu
m okundu
e okundu
</screen>
    </para><para xml:id="glibc-open_memstream">
<indexterm scope="glibc-fn"><primary>open_memstream</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>FILE *<command>open_memstream</command></funcdef>
<paramdef>(char  **<varname>gstr</varname>,
 size_t *<varname>boyut</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev bir tampona yazmak için bir akım açar. Tampon (<command>malloc</command> kullanılarak özdevimli ayrılır ve gerektikçe büyütülür.  Akımı kapattıktan sonra bu tamponun <command>free</command> veya <command>realloc</command> kullanarak temizlenmesi sizin sorumluluğunuzdadır. Bkz. <xref linkend="glibc-Unconstrained-Allocation"/>.
    </para><para>
Akım <command>fclose</command> ile kapatıldığında ya da <command>fflush</command> ile boşaltıldığında, <varname>gstr</varname> tampona bir gösterici olarak ve boyutu da <varname>boyut</varname> değişkenine güncellenir. Buralarda saklanmış olan değerler akımda başka bir değer yer alıncaya kadar geçerli kalır. Başka çıktılar almak için kullanmadan önce akımı boşaltmalısınız.
    </para><para>
Tamponun sonuna bir boş karakter yazılır. Bu boş karakter <varname>boyut</varname> değerine dahil edilmez.
    </para><para>
Akımın dosya konumunu <command>fseek</command> veya <command>fseeko</command> (<xref linkend="glibc-File-Positioning"/>) işlevlerini kullanarak değiştirebilirsiniz. Dosya konumunun yazılmış verinin sonrasına taşınması halinde arada kalan boşluklar sıfırlarla doldurulur.
      </para></funcdescr></funcsynopsis>
    </para><para>
Aşağıda <command>open_memstream</command> işlevi kullanılan bir örnek görüyorsunuz:
    </para><para>
<screen>
#include &lt;stdio.h>

int
main (void)
{
  char *bp;
  size_t size;
  FILE *stream;

  stream = open_memstream (&amp;bp, &amp;size);
  fprintf (stream, "merhaba");
  fflush (stream);
  printf ("buf = `%s', size = %d\n", bp, size);
  fprintf (stream, ", dostlar");
  fclose (stream);
  printf ("buf = `%s', size = %d\n", bp, size);

  return 0;
}
</screen></para><para>
Bu kod parçası aşağıdaki çıktıyı üretir:
    </para><para><screen>
buf = `merhaba', size = 7
buf = `merhaba, dostlar', size = 16
</screen></para></sect1>
  <sect1 xml:id="glibc-Obstack-Streams">
    <title>Yığınak Akımları</title>
    <titleabbrev>Veriyi bir yığınakta saklayan akımlar.</titleabbrev>
    <para>
<dicterm><english>obstack (object stack kısaltması)</english><turkish>yığınak</turkish></dicterm>
Bir çıkış akımı açabilir ve verisini bir yığınağa koyabilirsiniz. Bkz. <xref linkend="glibc-Obstacks"/>.
    </para><para xml:id="glibc-open_obstack_stream">
<indexterm scope="glibc-fn"><primary>open_obstack_stream</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>FILE *<command>open_obstack_stream</command></funcdef>
<paramdef>(struct obstack *<varname>yığınak</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev <varname>yığınak</varname> yığınağına veri yazmak için bir akım açar. Bu yığınakta bir nesne başlatır ve onu veri yazıldıkça büyütür (bkz. <xref linkend="glibc-Growing-Objects"/>).
    </para><para>
Bu akım üzerinde yapılan bir <command>fflush</command> çağrısı nesnenin o anki boyunu yazılmış olan veriye eşitler. Bir <command>fflush</command> çağrısından sonra nesneyi geçici olarak inceleyebilirsiniz.
    </para><para>
Bir yığınak akımının dosya konumunu <command>fseek</command> veya <command>fseeko</command> (<xref linkend="glibc-File-Positioning"/>) işlevlerini kullanarak değiştirebilirsiniz. Dosya konumunun yazılmış olan verinin sonrasına taşınması arada kalan boşlukların sıfırlarla doldurulmasına sebep olur.
    </para><para>
Nesneyi kalıcı yapmak için yığınağı <command>fflush</command> ile güncelleyin ve <command>obstack_finish</command> ile nesneyi bitirip adresini alın. Bunun ardından akıma yazma işlemleri yığınakta yeni bir nesne başlatır ve sonraki <command>fflush</command> ve <command>obstack_finish</command> çağrılarına kadar bu nesne kullanılır.
    </para><para>
Fakat ne uzunlukta bir nesne kullanıldığını nasıl bulacaksınız? Nesne uzunluğunu <command>obstack_object_size</command> (<xref linkend="glibc-Status-of-an-Obstack"/>) çağrısı ile alabileceğiniz gibi nesneyi aşağıdaki gibi boş karakterle sonlandırabilirsiniz:
    </para><para>
<screen>obstack_1grow (<varname>yığınak</varname>, 0);
</screen></para><para>
Hangi yöntemi kullanırsanız kullanın, bunu <command>obstack_finish</command> çağrısından <command>önce</command> yapmalısınız (isterseniz ikisini de yapabilirsiniz).
      </para></funcdescr></funcsynopsis>
    </para><para>
Örnekte <command>obstack_finish</command> işlevinin kullanımı görülmektedir:
    </para><para><screen>
char *
ileti_dizgesi_yap (const char *a, int b)
{
  FILE *akim = open_obstack_stream (&amp;ileti_yigini);
  output_task (akim);
  fprintf (akim, ": ");
  fprintf (akim, a, b);
  fprintf (akim, "\n");
  fclose (akim);
  obstack_1grow (&amp;ileti_yigini, 0);
  return obstack_finish (&amp;ileti_yigini);
}
</screen></para></sect1>
  <sect1 xml:id="glibc-Custom-Streams">
    <title>Kendi Özel Akımlarınızı Oluşturun</title>
    <titleabbrev>Bir keyfi veri kaynağı ile bir veri alıcısı arasında kendi akımlarınızı tanımlayabilirsiniz.</titleabbrev>
    <para>
<indexterm scope="glibc-cp"><primary>akımlar</primary><secondary>özel</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>özel akımlar</primary></indexterm>
Bu bölümde girdiyi bir keyfi veri kaynağından alan ve sizin tarafınızdan tasarlanan bir veri alıcısına çıktılayan bir akımı nasıl oluşturabileceğiniz açıklanmaktadır. Buna <wordasword>özel akımlar</wordasword> diyoruz. Burada açıklanan işlev ve veri türlerinin hepsi GNU oluşumudur.
    </para><sect2 xml:id="glibc-Streams-and-Cookies">
    <title>Özel Akımlar ve Çerezler</title><para>
<indexterm scope="glibc-cp"><primary>çerezler</primary><secondary>özel akımlarda</secondary></indexterm>
Her özel akımın içeriği <wordasword>çerez</wordasword> adı verilen özel bir nesnedir. Bu nesne sizin tarafınızdan sağlanır ve okunan veya yazılan verinin nereden alınacağı ve nereye yazılacağının kayıtlarından oluşur. Kütüphanedeki akım işlevleri doğrudan bu akımların içeriği ile çalışamaz ve hatta veri türünü bile bilmez; bunların adresleri <command>void *</command> türünde kaydedilir.
     </para><para>
Bir özel akımı gerçekleştirmek için, verinin belirtilen yerden <emphasis>nasıl</emphasis> alınacağı veya nerede saklanacağını belirtmelisiniz. Bunu, akıma yazan, onu okuyan, dosya konumunu değiştiren ve kapatan <firstterm>kanca işlevleri</firstterm> tanımlayarak yaparsınız. Bu dirt işlev akımın çerezine aktarılacak, böylece onlar verinin nereden alınıp nerede saklanacağını söyleyebilecektir. Kütüphane işlevleri çerezin içinde neler olduğunu bilmez, ama sizin işlevleriniz bilmelidir.
     </para><para>
Bir özel akımı oluştururken bir çerez göstericisi ve ayrıca <command>cookie_io_functions_t</command> yapısının kayıtlarında saklanan dört kanca işlevi belirtmelisiniz.
    </para><para>
Burada sözü edilen oluşumlar <filename>stdio.h</filename> başlık dosyasında bildirilmiştir.
<indexterm scope="glibc-pg"><primary>stdio.h</primary></indexterm>
    </para><para xml:id="glibc-cookie_io_functions_t">
<indexterm scope="glibc-tp"><primary>cookie_io_functions_t</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü">
<funcdef><command>cookie_io_functions_t</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu veri yapısı, akım ile onun çerezi arasındaki iletişim protokolünü tanımlayan işlevleri saklar. Aşağıdaki üyelere sahiptir:
      </para><para>
        <glosslist><glossentry><glossterm>
          <literal>cookie_read_function_t *<command>read</command></literal>
          </glossterm><glossdef><para>
Bu, çerezden veriyi okuyan işlevdir. Değeri bir işlev değil de bir boş gösterici ise bu akımdan yapılan okuma işlemleri daima <command>EOF</command> döndürür.
          </para></glossdef>
        </glossentry><glossentry><glossterm>
          <literal>cookie_write_function_t *<command>write</command></literal>
          </glossterm><glossdef><para>
Bu, çereze veriyi yazan işlevdir. Değeri bir işlev değil de bir boş gösterici ise bu akıma yazılan veriler iptal edilir.
          </para></glossdef>
        </glossentry><glossentry><glossterm>
          <literal>cookie_seek_function_t *<command>seek</command></literal>
          </glossterm><glossdef><para>
Bu, çerez üzerindeki dosya konumlamasına eşdeğer işlemleri uygulayan işlevdir. Değeri bir işlev değil de bir boş gösterici ise bu akım üzerinde yapılan <command>fseek</command> veya <command>fseeko</command> çağrıları sadece tampon içinde konumlama yapar; tamponun dışına çıkan tüm konumlama istekleri bir <command>ESPIPE</command> hatası ile sonuçlanacaktır.
          </para></glossdef>
        </glossentry><glossentry><glossterm>
          <literal>cookie_close_function_t *<command>close</command></literal>
          </glossterm><glossdef><para>
Bu, akım kapatılırken çerez üzerinde temizlik yapan işlevdir. Değeri bir işlev değil de bir boş gösterici ise bu akım kapatılırken çerezi kapatacak hiçbir özel işlem yapılmaz.
          </para></glossdef>
        </glossentry></glosslist>
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-fopencookie">
<indexterm scope="glibc-fn"><primary>fopencookie</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>FILE *<command>fopencookie</command></funcdef>
<paramdef>(void                 *<varname>çerez</varname>,
 const char           *<varname>açıştürü</varname>,
 cookie_io_functions_t <varname>gç-işlevleri</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev, <varname>gç-işlevleri</varname> argümanında belirtilen işlevleri kullanarak <varname>çerez</varname> ile haberleşen bir akım oluşturur. <varname>açıştürü</varname> argümanı <command>fopen</command> işlevindeki gibi kullanılır; bkz. <xref linkend="glibc-Opening-Streams"/>.  (Fakat "açılışta kırp" seçeneği gözardı edilir.) Oluşturulan akımın tamamı tamponlanır.
     </para><para>
<command>fopencookie</command> işlevi ya yeni oluşturulan akım ile ya da bir hata durumunda bir boş gösterici ile döner.
        </para></funcdescr></funcsynopsis>
      </para>
    </sect2><sect2 xml:id="glibc-Hook-Functions">
      <title>Özel Akım Kanca İşlevleri</title>
      <para>
<indexterm scope="glibc-cp"><primary>akımlar</primary><secondary>özel</secondary><tertiary>kanca işlevler</tertiary></indexterm>
Bu bölümde bir özel akımın gerektirdiği dört kanca işlevin tanımlanması ayrıntılı olarak incelenmiştir.
     </para><para>
Çerezden veri okuyan işlevi şöyle tanımlamalısınız:
     </para><para>
<literallayout>
ssize_t <varname>okuyucu</varname> (void *<varname>çerez</varname>, char *<varname>tampon</varname>, size_t <varname>boyut</varname>)
</literallayout></para><para>
Bu işlev <command>read</command> işlevine çok benzer; bkz. <xref linkend="glibc-I-O-Primitives"/>.  İşleviniz <varname>tampon</varname> tamponuna <varname>boyut</varname> bayt aktarmalı ve okunan bayt sayısı ile ya da dosyasonunu belirtmek üzere sıfır ile dönmelidir. Hata durumunu belirtmek için  <command>-1</command> de döndürebilirsiniz.
     </para><para>
Çereze veri yazan işlevi şöyle tanımlamalısınız:
     </para><para>
<literallayout>
ssize_t <varname>yazıcı</varname> (void *<varname>çerez</varname>, const char *<varname>tampon</varname>, size_t <varname>boyut</varname>)
</literallayout></para><para>
Bu işlev <command>write</command> işlevine çok benzer; bkz. <xref linkend="glibc-I-O-Primitives"/>. İşleviniz <varname>tampon</varname> tamponundan <varname>boyut</varname> bayt aktarmalı ve yazılan bayt sayısı ile dönmelidir. Hata durumunu belirtmek için  <command>-1</command> de döndürebilirsiniz.
     </para><para>
Çerez üzerinde konumlama yapan işlevi şöyle tanımlamalısınız:
     </para><para>
<literallayout>
int <varname>konumlayıcı</varname> (void *<varname>çerez</varname>, off64_t *<varname>konum</varname>, int <varname>nereden</varname>)
</literallayout></para><para>
Bu işlev için <varname>konum</varname> ve <varname>nereden</varname> argümanları <command>fgetpos</command> işlevindeki gibi yorumlanır; bkz. <xref linkend="glibc-Portable-Positioning"/>.
     </para><para>
Konumlama işleminden sonra, işleviniz sonuçlanan dosya konumunu dosyanın başlangıcına göre <varname>konum</varname> argümanında saklamalıdır. İşleviniz başarı durumunda <command>0</command> ve hata durumunda <command>-1</command> ile dönmelidir.
     </para><para>
Akımı kapatırken çerez üzerinde uygulanacak temizlik işlemlerini yapacak işlevi şöyle tanımlamalısınız:
     </para><para>
<literallayout>
int <varname>temizleyici</varname> (void *<varname>çerez</varname>)
</literallayout></para><para>
İşleviniz başarı durumunda <command>0</command> ve hata durumunda <command>-1</command> ile dönmelidir.
      </para><para xml:id="glibc-cookie_read_function">
<indexterm scope="glibc-tp"><primary>cookie_read_function</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü">
<funcdef><command>cookie_read_function</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu, bir özel akımın gerektirdiği okuyucu işlevin veri türüdür. İşlevi yukarıdaki gibi tanımlarsanız, bu, o işlevin veri türü olacaktır.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-cookie_write_function">
<indexterm scope="glibc-tp"><primary>cookie_write_function</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü">
<funcdef><command>cookie_write_function</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu, bir özel akımın gerektirdiği yazıcı işlevin veri türüdür. İşlevi yukarıdaki gibi tanımlarsanız, bu, o işlevin veri türü olacaktır.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-cookie_seek_function">
<indexterm scope="glibc-tp"><primary>cookie_seek_function</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü">
<funcdef><command>cookie_seek_function</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu, bir özel akımın gerektirdiği konumlayıcı işlevin veri türüdür.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-cookie_close_function">
<indexterm scope="glibc-tp"><primary>cookie_close_function</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü">
<funcdef><command>cookie_close_function</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu, bir özel akımın gerektirdiği kapatma işlevin veri türüdür.
        </para></funcdescr></funcsynopsis>
      </para>
    </sect2>
  </sect1>
</chapter>

<chapter xml:id="glibc-Formatted-Messages">
  <title>Biçimli İletiler</title>
  <titleabbrev>Tamamen biçimlenmiş iletilerin basılması.</titleabbrev>
  <para>
<indexterm scope="glibc-cp"><primary>biçimli iletiler</primary></indexterm>
System V tabanlı sistemlerde uygulamalar (özellikle sistem araçları)
<command>fmtmsg</command> işlevini kullanarak iletilerini daima belli bir biçimde basar. Bu tek biçimlilik kimi zaman iletileri yorumlayan kullanıcılara yardımcı olur ve <command>fmtmsg</command> işlevinin belirli biçimine bağlı sınamalarla yazılımcıyı daha az sayıda gereksinimi karşılamak zorunda bırakır.
  </para>
  <sect1 xml:id="glibc-Printing-Formatted-Messages">
    <title>Biçimli İletilerin Basılması</title>
    <titleabbrev><command>fmtmsg</command> işlevi.</titleabbrev>
    <para>
İletiler standart hataya ve/veya konsola basılabilir. Hedefi seçerken yazılımcı <command>fmtmsg</command> işlevinin <varname>sınıflama</varname> argümanında aşağıdaki iki değeri kullanabilir, isterse bit bit VEYAlayarak bunları birleştirebilir:
    </para><para>
      <variablelist><varlistentry><term><literal>MM_PRINT</literal></term>
        <listitem><para>
İleti standart hatada gösterilir.
        </para></listitem>
      </varlistentry><varlistentry><term><literal>MM_CONSOLE</literal></term>
        <listitem><para>
İleti sistem konsolunda gösterilir.
        </para></listitem>
      </varlistentry></variablelist>
    </para><para>
Sistemdeki hata kaynakları <command>fmtmsg</command> işlevinin <varname>sınıflama</varname> argümanında aşağıdaki değerler bit bit VEYAlanarak
belirtilebilir:
    </para><para>
      <variablelist><varlistentry><term><literal>MM_HARD</literal></term>
        <listitem><para>
Hata kaynağı bazı donanımlardır.
        </para></listitem>
      </varlistentry><varlistentry><term><literal>MM_SOFT</literal></term>
        <listitem><para>
Hata kaynağı bazı yazılımlardır.
        </para></listitem>
      </varlistentry><varlistentry><term><literal>MM_FIRM</literal></term>
        <listitem><para>
Hata kaynağı bazı donanımlara gömülü yazılımlardır.
        </para></listitem>
      </varlistentry></variablelist>
    </para><para>
<command>fmtmsg</command> işlevinin <varname>sınıflama</varname> argümanında belirtilebilecek üçüncü eleman sorunun saptandığı sistem parçalarını açıklamakta kullanılır. Bu aşağıdaki değerlerden sadece birini kullanarak yapılır:
    </para><para>
      <variablelist><varlistentry><term><literal>MM_APPL</literal></term>
        <listitem><para>
Sorun uygulama tarafından saptanmıştır.
        </para></listitem>
      </varlistentry><varlistentry><term><literal>MM_UTIL</literal></term>
        <listitem><para>
Sorun başka bir uygulama tarafından saptanmıştır.
        </para></listitem>
      </varlistentry><varlistentry><term><literal>MM_OPSYS</literal></term>
        <listitem><para>
Sorun işletim sistemi tarafından saptanmıştır.
        </para></listitem>
      </varlistentry></variablelist>
    </para><para>
<command>fmtmsg</command> işlevinin <varname>sınıflama</varname> argümanında belirtilebilecek son eleman bu iletinin sonucunu gösterir. Aşağıdaki değerlerden sadece biri kullanılabilir:
    </para><para>
      <variablelist><varlistentry><term><literal>MM_RECOVER</literal></term>
        <listitem><para>
Kurtarılabilir bir hata.
        </para></listitem>
      </varlistentry><varlistentry><term><literal>MM_NRECOV</literal></term>
        <listitem><para>
Kurtarılamayacak bir hata.
        </para></listitem>
      </varlistentry></variablelist>
    </para><para xml:id="glibc-fmtmsg">
<indexterm scope="glibc-fn"><primary>fmtmsg</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>fmtmsg</command></funcdef>
<paramdef>(long int    <varname>sınıflama</varname>,
 const char *<varname>isim</varname>,
 int         <varname>önem</varname>,
 const char *<varname>metin</varname>,
 const char *<varname>eylem</varname>,
 const char *<varname>etiket</varname>)</paramdef>
</funcprototype><funcdescr><para>
Parametreleriyle açıklanan bir iletiyi <varname>sınıflama</varname> parametresinde belirtilen aygıt(lar) üzerinde görüntüler. <varname>isim</varname> parametresi ileti kaynağını betimler. Dizge iki sütunu oluşturan iki parçadan oluşur. Birinci parça 10 karakterden, ikinci parça ise 14 karakterden uzun olamaz.  <varname>metin</varname> parametresi hata durumunu, <varname>eylem</varname> parametresi hatadan kurtulmak için olası adımları açıklar,  <varname>etiket</varname> parametresi ise daha fazla bilgi edinilebilecek belgeyi gösterir.  <varname>etiket</varname> parametresi <varname>isim</varname> değerini ve eşsiz bir kimlik numarası içermelidir.
    </para><para>
Parametreleri her biri istenirse yok sayılabilecek özel bir değer olabilir. Bu değerler için kullanılabilecek sembolik isimler:
   </para><para><variablelist><varlistentry>
   <term><literal>MM_NULLLBL</literal></term><listitem><para>
<varname>isim</varname> parametresi yoksayılır.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>MM_NULLSEV</literal></term><listitem><para>
<varname>önem</varname> parametresi yoksayılır.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>MM_NULLMC</literal></term><listitem><para>
<varname>sınıflama</varname> parametresi yoksayılır.  Bu hiçbir şey basılmamasına sebep olur.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>MM_NULLTXT</literal></term><listitem><para>
<varname>metin</varname> parametresi yoksayılır.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>MM_NULLACT</literal></term><listitem><para>
<varname>eylem</varname> parametresi yoksayılır.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>MM_NULLTAG</literal></term><listitem><para>
<varname>etiket</varname> parametresi yoksayılır.
       </para></listitem></varlistentry></variablelist></para><para>
Bu alanların yoksayılması için başka bir yöntem de çıktının standart hataya gönderilmesinde kullanılabilir. Bu yöntemde davranışı aşağıda açıkalanan ortam değişkenleri belirler.
    </para><para>
<varname>önem</varname> parametresi aşağıdaki değerlerden biri olabilir:
<indexterm scope="glibc-cp"><primary>önem derecesi</primary></indexterm>
    </para><para><variablelist><varlistentry>
    <term><literal>MM_NOSEV</literal></term><listitem><para>
Hiçbir şey basılmaz, <command>MM_NULLSEV</command> ile aynıdır.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>MM_HALT</literal></term><listitem><para>
Değer <command>ÇÖKME</command> (HALT) anlamında basılır.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>MM_ERROR</literal></term><listitem><para>
Değer <command>HATA</command> (ERROR) olarak basılır.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>MM_WARNING</literal></term><listitem><para>
Değer <command>UYARI</command> (WARNING) olarak basılır.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>MM_INFO</literal></term><listitem><para>
Değer <command>BİLGİ</command> (INFO) olarak basılır.
       </para></listitem></varlistentry></variablelist></para><para>
Bu beş makronun değeri <command>0</command> ile <command>4</command> arasındadır.  <literal>SEV_LEVEL</literal> ortam değişkenini kullanarak ya da <command>addseverity</command> işleviyle basılacak dizgeye karşılık olarak başka önem dereceleri de belirlenebilir. Bu konu <xref linkend="glibc-Adding-Severity-Classes"/> bölümünde açıklanmıştır.
    </para><para>
Hiçbir parametre yoksayılmadığında çıktı şuna benzer:
    </para><para>
<screen><varname>isim</varname>: <varname>önem-dizgesi</varname>: <varname>metin</varname>
TO FIX: <varname>eylem </varname><varname>etiket</varname>
</screen></para><para>
İkinokta üstüste, satırsonu ve <command>TO FIX</command> (DÜZELTMEK İÇİN)
dizgesi üretilmesini sağlayan parametreler yoksayılarak görüntülenmeyebilir.
    </para><para>
Bu işlev X/Open Taşınabilirlik Kılavuzunda belirtilmiştir. Ayrıca System V'den türetilmiş tüm sistemlerde bulunur.
    </para><para>
Bir hata oluşmazsa işlev <command>MM_OK</command> değeri ile döner. Başarısızlık standart hataya basma ile ilgiliyse, <command>MM_NOMSG</command> ile döner. Çıktılama konsolda başarısız olursa, <command>MM_NOCON</command> ile döner.  Hiçbirine çıktılama yapılamıyorsa, <command>MM_NOTOK</command> ile döner.  Tüm çıktılamanın başarısız olduğu son durumda ayrıca bir parametrenin değeri yanlışsa bu da döner.
      </para></funcdescr></funcsynopsis>
    </para><para>
<command>fmtmsg</command> işlevinin davranışını açıklayan iki ortam değişkeni vardır. İlki olan <command>MSGVERB</command> çıktının gerçekte standart hataya (konsola değil) gönderilmesinde kullanılır. Beş alanın herbiri açıkça etkinleştirilir. Bunu yapmak için, işlev çağrılmadan önce ortam değişkeni aşağıdaki gibi düzenlenir:
    </para><para>
<screen>MSGVERB=<varname>anahtar-sözcük</varname>[:<varname>anahtar-sözcük</varname>[:…]]
</screen></para><para>
Geçerli <varname>anahtar-sözcük</varname>ler <command>label</command> (isim), <command>severity</command> (önem), <command>text</command> (metin), <command>action</command> (eylem) ve <command>tag</command> (etiket) sözcükleridir. Ortam değişkeni yoksa veya boşsa, desteklenmeyen bir anahtar sözcük kullanılmışsa ya da değer iletinin bir parçası olarak geçersizse o alan(lar) çıktılanmaz.
    </para><para>
<command>fmtmsg</command> işlevinin davranışını açıklayan ikinci ortam değişkeni <command>SEV_LEVEL</command> değişkenidir.  Bu değişken ve <command>fmtmsg</command> işlevinin davranış değiştirmesi X/Open Taşınabilirlik Kılavuzunda belirtilmemiştir.  Yine de System V sistemlerinde bulunmaktadır. Yeni önem derecelerini belirtmekte kullanılır.  Öntanımlı olarak yukarıda açıklanan beş önem derecesi vardır. Diğer sayısal değerlerler <command>fmtmsg</command> işlevinin bir şey basmasını sağlamaz.
    </para><para>
Kullanıcı <command>SEV_LEVEL</command> değişkenini <command>fmtmsg</command> işlevini çağırmadan önce şöyle tanımlayabilir:
</para><para><screen>SEV_LEVEL=[<varname>açıklama</varname>[:<varname>açıklama</varname>[:…]]]
</screen></para><para>
Buradaki <varname>açıklama</varname> alanları aşağıdaki değerleri alabilir:
    </para><para>
<screen><varname>önem-sözcüğü</varname>, <varname>seviye</varname>, <varname>basılacak-dizge</varname>
</screen></para><para>
<varname>önem-sözcüğü</varname> parçası <command>fmtmsg</command> tarafından kıllanılmaz ama yine de vardır. <varname>seviye</varname> bir numarayı ifade eden bir dizgedir. Sayısal değer 4’ten büyük olmalıdır. Bu değer, <command>fmtmsg</command> işlevinin bu sınıfı seçmesini sağlayan <varname>önem</varname> parametresinde kullanılır. Öntanımlı önem derecelerinin yerini alacak bir değer mümkün değildir. <varname>basılacak-dizge</varname> parçası ise <command>fmtmsg</command> tarafından bu sınıf işleme alındığında gösterilecek iletidir (yukarıya bakarsanız, <command>fmtsmg</command> işlevinin sayısal değeri değil, onun dizge karşılığını bastığını görürsünüz).
    </para></sect1>
  <sect1 xml:id="glibc-Adding-Severity-Classes">
    <title>Önem Derecelerinin Eklenmesi</title>
    <titleabbrev>Yeni önem sınıflarının eklenmesi.</titleabbrev>
    <para>
<indexterm scope="glibc-cp"><primary>önem derecesi</primary></indexterm>
<command>SEV_LEVEL</command> ortam değişkenini kullanmanın yanında yeni önem derecelerini belirlemek için bir olasılık daha vardır. Bu yöntem çalışan bir yazılım içinde başka önem derecelerinden bahsedilebilmesini kolaylaştırır.
<command>setenv</command> veya <command>putenv</command> işlevleri ortam değişkenlerini ayarlamakta kullanılabilir ama bu zahmetlidir.
  </para><para xml:id="glibc-addseverity">
<indexterm scope="glibc-fn"><primary>addseverity</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>addseverity</command></funcdef>
<paramdef>(int         <varname>önem</varname>,
 const char *<varname>dizge</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev, <command>fmtmsg</command> işlevinin <varname>önem</varname> parametresi tarafından adreslenebilecek yeni önem derecesini belirlemekte kullanılır. <command>addseverity</command> işlevinin <varname>önem</varname> parametresi <command>fmtmsg</command> işlevinin <varname>önem</varname> parametresinin değeri ile eşleşmeli ve <varname>dizge</varname> de asıl iletide sayısal değer yerine gösterilecek dizge olmalıdır.
    </para><para>
<varname>dizge</varname>'nin değeri <command>NULL</command> ise <varname>önem</varname>'e karşılık olan sayısal değerle ilgili önem derecesi kaldırılır.
    </para><para>
Öntanımlı önem derecelerini kaldırmak ya da değiştirmek mümkün değildir. <varname>önem</varname> parametresinde bu değerlerlerden biri kullanılarak yapılan <command>addseverity</command> çağrıları başarısız olacaktır.
    </para><para>

Görev yerine getirilmişse işlev <command>MM_OK</command> ile döner. <command>MM_NOTOK</command> dönmüşse birşeyler yanlış gitmiş demektir. Bu durumda  ya yeterli bellek ya da kaldırılmak istenen sınıf yoktur.
    </para><para>
<command>fmtsmg</command> olduğu halde bu işlev X/Open Taşınabilirlik Kılavuzunda yoktur. System V sistemlerinde bulunur.
      </para></funcdescr></funcsynopsis>
    </para>
  </sect1>
  <sect1 xml:id="glibc-Example">
    <title>Örnek</title>
    <titleabbrev><command>fmtmsg</command> ve <command>addseverity</command> kullanımı.</titleabbrev>
    <para>
Burada bu kısımda bahsedilmiş olan <command>fmtmsg</command> ve <command>addseverity</command> işlevlerinin kullanımı örneklenmiştir. (Ç.N.: Parametre değerleri değişmez alanları göstermesi açısından Türkçe’ye çevrilmiştir.).
    </para><para>
<screen>#include &lt;fmtmsg.h>

int
main (void)
{
  addseverity (5, "BİLGİ-2");
  fmtmsg (MM_PRINT, "tek1alan", MM_INFO, "metin-2", "eylem-2", "etiket-2");
  fmtmsg (MM_PRINT, "UX:cat", 5, "sözdizimi geçersiz", "belgelere bakınız",
          "UX:cat:001");
  fmtmsg (MM_PRINT, "isim:foo", 6, "metin", "eylem", "etiket");
  return 0;
}
</screen></para><para>
<command>fmtmsg</command> işlevinin ikinci çağrısı genelde bu işlevin ağırlıkla kullanıldığı System V sistemlerinde görülen kullanımını örneklemektedir. Bu sistemin System V üzerinde nasıl çalıştığına burada kısaca değinmek iyi olacaktır. <varname>isim</varname> alanındaki <command>UX:cat</command>, bir Unix uygulaması olan <command>cat</command>'in bir hata verdiğini belirtir. Devamında hatanın açıklaması ile <varname>eylem</varname> parametresi olarak <command>"belgeye bakınız"</command> değeri yer alır. Gerekiyorsa daha özel birşeyler yazılabilirdi. <varname>etiket</varname> alanı evvelce de bahsedildiği gibi <varname>isim</varname> parametresinin değerine ek olarak bir eşsiz kimlik (burada <command>001</command>) dizgesinden oluşur. GNU ortamında bu dizge uygulamanın info belgesindeki bu konuya karşılık düşen düğümü içermeliydi.
    </para><para>
<command>MSGVERB</command> ve <command>SEV_LEVEL</command> değişkenleri ayarlanmadan yazılım çalıştırılırsa aşağıdaki çıktı üretilir:
    </para><para>
<screen>UX:cat: BİLGİ-2: sözdizimi geçersiz
TO FIX: belgelere bakınız UX:cat:001
</screen></para><para>
Burada iletinin farklı alanlarının iki nokta üstüste ve <command>TO FIX</command> dizgesi ile birlikte nasıl basıldığını görüyoruz. Ama üç <command>fmtmsg</command> çağrısından yalnız biri bu çıktıyı üretti. İlk çağrı <varname>isim</varname> parametresi doğru biçimde olmadığından hiçbir çıktı üretmedi. Dizge iki nokta üstüste ile ayrılmış iki alan içermeliydi (<xref linkend="glibc-Printing-Formatted-Messages"/>). Üçüncü <command>fmtmsg</command> çağrısı da sayısal değeri <command>6</command> olan sınıf tanımlanmadığı için çıktı üretmedi. Sayısal değeri <command>5</command> olan bir sınıf ayrıca öntanımlı olarak tanımlanmadığı halde <command>addseverity</command> çağrısı ile tanımlanmış ve ikinci <command>fmtmsg</command> çağrısı yukarıdaki çıktıyı üretmiştir.
    </para><para>
Uygulamamız çalışırken ortamı <command>SEV_LEVEL=XXX,6,BİLGİ</command> ile değiştirirsek aşağıdaki sonucu alırız:
    </para><para>
<screen>UX:cat: BİLGİ-2: sözdizimi geçersiz
TO FIX: belgelere bakınız UX:cat:001
isim:foo: BİLGİ: metin
TO FIX: eylem etiket
</screen></para><para>
Şimdi üçüncü <command>fmtmsg</command> çağrısı çıktı üretti. Böylece ortam değişkenindeki <command>NOTE</command> dizgesinin ileti içinde nasıl kullanıldığını görmüş olduk.
    </para><para>
Şimdi sadece bize gerekli alanlarla bir çıktı üretelim. Eğer, <command>MSGVERB</command> ortam değişkenine <command>severity:label:action</command> (önem:isim:eylem) değerini atarsak aşağıdaki çıktıyı alırız:
    </para><para>
<screen>UX:cat: BİLGİ-2
TO FIX: belgelere bakınız
isim:foo: BİLGİ
TO FIX: eylem
</screen></para><para>
Böylece, I.e., <command>fmtmsg</command> işlevinin <varname>metin</varname> ve <varname>etiket</varname> parametreleri kullanılmamış oldu. Dikkat ederseniz <command>BİLGİ</command> ve <command>BİLGİ-2</command> dizgelerinden sonra iki nokta üstüste kullanılmadı. Bu satırlarda bu dizgelerden sonra gösterilecek metin çıktılanmayacağından bu karakter kullanılmamıştır.
    </para></sect1></chapter>

</part>

