<?xml version="1.0" encoding="UTF-8"?>
<!-- ********************************************************************
         ch17.xml
     ******************************************************************** -->
<part xml:id="glibc-Low-Level-Terminal-Interface"
      xmlns="http://docbook.org/ns/docbook" version="5.0" xml:lang="tr">
 <info>
  <title>Düşük Seviyeli Uçbirim Arayüzü</title>
  <titleabbrev>Bir uçbirim aygıtının karakteristikleri nasıl değiştirilir.</titleabbrev>
 </info>
 <partintro>
  <para>
Bu oylumda açıklanan işlevler uçbirim aygıtlarına özeldir. Bu işlevleri kullanarak girdilerin yansılanmasını engelleyebilir, hat hızı ve akış denetimi gibi seri hat karakteristiklerini değiştirebilir, dosyasonu karakteri olarak kullanılacak karakteri, komut satırı düzenlemeyi, sinyal gönderimini, v.s. değiştirebilirsiniz.
  </para>
  <para>
Bu oylumdaki işlevlerin çoğu dosya tanıtıcılarla çalışır. Dosya tanıtıcıların ne olduğu ve bir dosya tanıtıcısının bir uçbirim olarak nasıl açıldığı gibi konuları <xref linkend="glibc-Low-Level-I-O"/> bölümünde bulabilirsiniz.
  </para>
 </partintro>
 <chapter xml:id="glibc-Is-It-a-Terminal">
  <info>
   <title>Uçbirimlerin Tanımlanması</title>
   <titleabbrev>Bir dosyanın bir uçbirim olup olmadığının ve isminin saptanması.</titleabbrev>
  </info>
  <para><indexterm scope="glibc-cp"><primary>uçbirimler</primary></indexterm>
Bu kısımda bahsedilen işlevler sadece uçbirim aygıtlarına karşılık olan dosyalarla çalışır. Bir dosyanın bir uçbirimle ilişkili olup olmadığını <command>isatty</command> işlevini kullanarak öğrenebilirsiniz.
   </para>
  <para><indexterm scope="glibc-pg"><primary>unistd.h</primary></indexterm>
Bu kısımdaki işlevlerin prototipleri <filename>unistd.h</filename> başlık dosyasında bildirilmiştir.
   </para>
  <para xml:id="glibc-isatty">
   <indexterm scope="glibc-fn">
    <primary>isatty</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>int <command>isatty</command></funcdef>
     <paramdef>(int <varname>dosyatanıtıcı</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para>
Bu işlev, <varname>dosyatanıtıcı</varname> bir uçbirimle ilişkili bir dosya tanıtıcı ise <command>1</command> ile değilse <command>0</command> ile döner.
      </para>
     <para>
Bir dosya tanıtıcı bir uçbirimle ilişkili ise ilişkili dosya ismini <command>ttyname</command> işlevini kullanarak öğrenebilirsiniz.  Ayrıca <xref linkend="glibc-Identifying-the-Terminal"/> bölümünde açıklanan <command>ctermid</command> işlevine de bakınız.
</para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para xml:id="glibc-ttyname">
   <indexterm scope="glibc-fn">
    <primary>ttyname</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>char *<command>ttyname</command></funcdef>
     <paramdef>(int <varname>dosyatanıtıcı</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para><varname>dosyatanıtıcı</varname> bir uçbirimle ilişkili bir dosya tanıtıcı ise, <command>ttyname</command> işlevi uçbirim dosyasının ismini içeren durağan ayrılmış boş karakter sonlandırmalı bir dizgeye bir gösterici ile döner. Dosya tanıtıcısı bir uçbirime karşılık değilse ya da dosya ismi saptanamamışsa işlev boş gösterici ile döner.
</para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para xml:id="glibc-ttyname_r">
   <indexterm scope="glibc-fn">
    <primary>ttyname_r</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>int <command>ttyname_r</command></funcdef>
     <paramdef>(int    <varname>dosyatanıtıcı</varname>,
 char  *<varname>tampon</varname>,
 size_t <varname>uzunluk</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para>
Sonucun kullanıcı tarafından belirtilen <varname>uzunluk</varname> uzunluktaki <varname>tampon</varname> tamponu ile döndürülmesi dışında  <command>ttyname</command> işlevi gibidir.
   </para>
     <para><command>ttyname_r</command> işlevinin normal dönüş değeri sıfırdır. Aksi takdirde hatayı belirten bir hata numarası ile döner. Aşağıdaki <command>errno</command> hata durumları bu işlev için tanımlanmıştır:
   </para>
     <para>
      <variablelist>
       <varlistentry>
        <term>
         <literal>EBADF</literal>
        </term>
        <listitem>
         <para><varname>dosyatanıtıcı</varname> argümanı geçerli bir dosya tanıtıcısı değil
      </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         <literal>ENOTTY</literal>
        </term>
        <listitem>
         <para><varname>dosyatanıtıcı</varname> bir uçbirimle ilişkili değil
      </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         <literal>ERANGE</literal>
        </term>
        <listitem>
         <para>
Tampon uzunluğu olarak <varname>uzunluk</varname>, döndürülecek dizgeyi saklamak için çok küçük
      </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>
    </funcdescr>
   </funcsynopsis>
  </para>
 </chapter>
 <chapter xml:id="glibc-I-O-Queues">
  <info>
   <title>G/Ç Kuyrukları</title>
   <titleabbrev>Akış denetimi ve uçbirim girdi kuyruğu hakkında.</titleabbrev>
  </info>
  <para>
Bu kısımdaki işlevler bir uçbirim aygıtının girdi ve çıktı kuyrukları ile ilgilidir. Bu kuyruklar, <link linkend="glibc-I-O-on-Streams">G/Ç akımlarına</link> göre gerçeklenmiş tamponlamadan bağımsız olarak <emphasis>çekirdek içindeki</emphasis> bir tamponlama şeklinde gerçeklenmiştir.
   </para>
  <para><indexterm scope="glibc-cp"><primary>uçbirimler</primary><secondary>girdi kuyruğu</secondary></indexterm><indexterm scope="glibc-cp"><primary>uçbirimler</primary><secondary>sürekli yazma (typeahead) tamponu</secondary></indexterm><wordasword>Uçbirim girdi kuyruğu</wordasword> çoğunlukla kullandığı tamponun ismiyle <firstterm>sürekli yazma (typeahead) tamponu</firstterm> olarak da anılır. Bir uçbirim tarafından alınmış ancak henüz bir süreç tarafından okunmamış karakterleri içerir.
   </para>
  <para>
Girdi kuyruğunun uzunluğunu <command>MAX_INPUT</command> ve <command>_POSIX_MAX_INPUT</command> parametreleri belirler; bkz. <xref linkend="glibc-Limits-for-Files"/>.  Kuyruk uzunluğunun en azından <command>MAX_INPUT</command> karakterlik olacağını düşünebilirsiniz, ancak kuyruk daha büyük olabilir ve hatta uzunluğu özdevimli olarak değişebilir. Eğer <command>IXOFF</command> girdi kipi biti (bkz. <xref linkend="glibc-Input-Modes"/>) atanarak akış denetimi etkinleştirilmişse, kuyruğu taşmadan korumak gerektiğinde uçbirim sürücüsü uçbirime STOP ve START karakterlerini aktarır. Aksi takdirde, girdi uçbirimin kabul edebildiğinden hızlı gelirse bir kısım girdi kaybolabilir. Kurallı kipte, bir satırsonu karakteri alınıncaya kadar girdi kuyrukta kalır, dolayısıyla çok uzun bir satır yazdığınızda uçbirim girdi kuyruğu dolabilir. Bakınız: <xref linkend="glibc-Canonical-or-Not"/>.
   </para>
  <para><indexterm scope="glibc-cp"><primary>uçbirimler</primary><secondary>çıktı kuyruğu</secondary></indexterm><wordasword>Uçbirim çıktı kuyruğu</wordasword> girdi kuyruğu gibidir, ancak çıktı içindir. Süreçler tarafından yazılmış fakat henüz uçbirime aktarılmamış karakterleri içerir. Eğer <command>IXON</command> girdi kipi biti (bkz. <xref linkend="glibc-Input-Modes"/>) atanarak akış denetimi etkinleştirilmişse, uçbirim sürücüsü, çıktı aktarımını durdurmak ve yeniden başlatmak için uçbirim tarafından gönderilen STOP ve START karakterlerine uymaya çalışır.
   </para>
  <para><wordasword>Temizleme</wordasword> uçbirim girdi kuyruğundaki alınmış ancak henüz okunmamış karakterlerin iptal edilmesi anlamına gelir. Benzer olarak, uçbirim çıktı kuyruğuna yazılmış ancak henüz aktarılmamış karakterlerin iptal edilmesi anlamına da gelir.
   </para>
 </chapter>
 <chapter xml:id="glibc-Canonical-or-Not">
  <info>
   <title>İki Girdi Tarzı: Kurallı veya Kuralsız</title>
   <titleabbrev>İki temel girdi işleme tarzı.</titleabbrev>
  </info>
  <para>
POSIX sistemleri iki temel girdi kipini destekler: kurallı ve kuralsız.
   </para>
  <para><indexterm scope="glibc-cp"><primary>uçbirimler</primary><secondary>girdi işleme</secondary><tertiary>kurallı</tertiary></indexterm><wordasword>Kurallı girdi işleme</wordasword> kipinde girdi, satırsonu (<command>'\n'</command>), EOF veya EOL karakterleri ile sonlandırılmış satırlar halinde işlenir. Kullanıcı tarafından satırın tamamı yazılana kadar hiçbir girdi okunmaz. Girdi alındıktan sonra, kaç bayt istendiğine bakılmaksızın <command>read</command> (<xref linkend="glibc-I-O-Primitives"/>) işlevi tek satırlık bir girdi ile döner.
   </para>
  <para>
Kurallı girdi kipinde, girdi düzenleme oluşumlarını işletim sistemi sağlar: o anki metin satırı içindeki bazı karakterler metin düzenleme işlemlerini gerçekleştiren ERASE ve KILL gibi özel karakterler olarak yorumlanır. Bkz. <xref linkend="glibc-Editing-Characters"/>.
   </para>
  <para><command>_POSIX_MAX_CANON</command> ve <command>MAX_CANON</command> sabitleri, kurallı kipte tek bir satırda bulunabilecek karakterlerin sayısının üst sınırını belirleyen parametrelerdir. Bkz. <xref linkend="glibc-Limits-for-Files"/>.  Satır uzunluğunun en azından <command>MAX_INPUT</command> karakterlik olacağını düşünebilirsiniz, ancak satır daha uzun olabilir ve hatta uzunluğu özdevimli olarak değişebilir.
   </para>
  <para><indexterm scope="glibc-cp"><primary>uçbirimler</primary><secondary>girdi işleme</secondary><tertiary>kuralsız</tertiary></indexterm><wordasword>Kuralsız girdi işleme</wordasword> kipinde karakterler satırlar halinde gruplanmaz ve ERASE veya KILL gibi metin düzenleme karakterleri dikkate alınmaz. Girdinin baytlar halinde okunduğu kuralsız girdi kipi  MIN ve TIME ayarları ile denetlenir. Bkz. <xref linkend="glibc-Noncanonical-Input"/>.
   </para>
  <para>
Çoğu uygulama kurallı girdi kipini kullanır, çünkü bu kip kullanıcıya metni satır satır düzenleyebilme imkanı verir. Uygulama tek karakterlik komutlar kabul edecekse ve kendi metin düzenleme oluşumları olacaksa kuralsız kip tercih edilir.
   </para>
  <para>
Kurallı ve kuralsız girdi seçimi <command>struct termios</command> yapısının <command>c_lflag</command> üyesinde <command>ICANON</command> seçeneğinin kullanılmasına bağlıdır. Bkz. <xref linkend="glibc-Local-Modes"/>.
   </para>
 </chapter>
 <chapter xml:id="glibc-Terminal-Modes">
  <info>
   <title>Uçbirim Kipleri</title>
   <titleabbrev>Uçbirimlerde G/Ç ile ilgili seçeneklere (yansılama, sinyaller, metin düzenleme) nasıl erişilir ve değiştirilir.</titleabbrev>
  </info>
  <para><indexterm scope="glibc-pg"><primary>termios.h</primary></indexterm>
Bu kısımda girdi ve çıktının denetiminde kullanılan çeşitli uçbirim öznitelikleri açıklanmıştır. Bu kısımdaki işlevler, veri yapıları ve sembolik sabitler <filename>termios.h</filename> başlık dosyasında bildirilmiştir.
   </para>
  <para>
Uçbirim öznitelikleri ile dosya özniteliklerini birbirine karıştırmayın. Bir uçbirimle ilişkilendirilmiş bir aygıt özel dosyası <xref linkend="glibc-File-Attributes"/> bölümünde anlatılan dosya özniteliklerine sahiptir ve bunlar uçbirim aygıtının bu bölümde bahsedilecek öznitelikleri ile ilgili değildir.
   </para>
  <section xml:id="glibc-Mode-Data-Types">
   <info>
    <title>Uçbirim Kipi Veri Türleri</title>
    <titleabbrev><literal>struct <command>termios</command></literal> ve ilgili diğer veri türleri.</titleabbrev>
   </info>
   <para><indexterm scope="glibc-cp"><primary>uçbirimler</primary><secondary>veri türleri</secondary></indexterm>
Bir uçbirimin özniteliklerinin tamamı <command>struct termios</command> türünde bir yapı içinde saklanır. Bu yapı, öznitelikleri okumak ve değiştirmek için <command>tcgetattr</command> ve <command>tcsetattr</command> işlevleri ile kullanılır.
    </para>
   <para xml:id="glibc-struct-termios">
    <indexterm scope="glibc-tp">
     <primary sortas="termios">struct termios</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="veri türü">
      <funcdef>struct <command>termios</command></funcdef>
      <paramdef/>
     </funcprototype>
     <funcdescr>
      <para>
Bir uçbirimin G/Ç özniteliklerinin kaydedildiği yapıdır. Yapı en azından şu üyeleri içermelidir:
    </para>
      <para>
       <glosslist>
        <glossentry>
         <glossterm>
          <literal>tcflag_t <command>c_iflag</command></literal>
         </glossterm>
         <glossdef>
          <para>
Girdi kipleri ile ilgili seçenekleri belirleyen bit maskesi; bkz. <xref linkend="glibc-Input-Modes"/>.
    </para>
         </glossdef>
        </glossentry>
        <glossentry>
         <glossterm>
          <literal>tcflag_t <command>c_oflag</command></literal>
         </glossterm>
         <glossdef>
          <para>
Çıktı kipleri ile ilgili seçenekleri belirleyen bit maskesi; bkz. <xref linkend="glibc-Output-Modes"/>.
    </para>
         </glossdef>
        </glossentry>
        <glossentry>
         <glossterm>
          <literal>tcflag_t <command>c_cflag</command></literal>
         </glossterm>
         <glossdef>
          <para>
Denetim kipleri ile ilgili seçenekleri belirleyen bit maskesi; bkz. <xref linkend="glibc-Control-Modes"/>.
    </para>
         </glossdef>
        </glossentry>
        <glossentry>
         <glossterm>
          <literal>tcflag_t <command>c_lflag</command></literal>
         </glossterm>
         <glossdef>
          <para>
Yerel kipler ile ilgili seçenekleri belirleyen bit maskesi; bkz. <xref linkend="glibc-Local-Modes"/>.
    </para>
         </glossdef>
        </glossentry>
        <glossentry>
         <glossterm>
          <literal>cc_t <command>c_cc</command>[NCCS]</literal>
         </glossterm>
         <glossdef>
          <para>
Çeşitli denetim işlevleri ile ilişkili karakterlerin belirtildiği bir dizi; bkz. <xref linkend="glibc-Special-Characters"/>.
    </para>
         </glossdef>
        </glossentry>
       </glosslist>
      </para>
      <para><command>struct termios</command> yapısı, ayrıca gidi ve çıktı iletim hızlarını kodlayan üyeler de içerir, fakat gösterim belirlenmemiştir. Hız değerlerinin nasıl öğrenileceği ve belirtileceği <xref linkend="glibc-Line-Speed"/> bölümünde açıklanmıştır.
</para>
     </funcdescr>
    </funcsynopsis>
   </para>
   <para><command>struct termios</command> yapısının üyeleri bundan sonraki bölümlerde ayrı ayrı ele alınıp açıklanacaktır.
    </para>
   <para xml:id="glibc-tcflag_t">
    <indexterm scope="glibc-tp">
     <primary>tcflag_t</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="veri türü">
      <funcdef>
       <command>tcflag_t</command>
      </funcdef>
      <paramdef/>
     </funcprototype>
     <funcdescr>
      <para>
Çeşitli uçbirim seçenekleri ile ilgili bit maskeleri için kullanılan bir işaretsiz tamsayı türüdür.
</para>
     </funcdescr>
    </funcsynopsis>
   </para>
   <para xml:id="glibc-cc_t">
    <indexterm scope="glibc-tp">
     <primary>cc_t</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="veri türü">
      <funcdef>
       <command>cc_t</command>
      </funcdef>
      <paramdef/>
     </funcprototype>
     <funcdescr>
      <para>
Çeşitli uçbirim denetim işlevleri ile ilgili karakterler için kullanılan bir işaretsiz tamsayı türüdür.
</para>
     </funcdescr>
    </funcsynopsis>
   </para>
   <para xml:id="glibc-NCCS">
    <indexterm scope="glibc-vr">
     <primary>NCCS</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="makro">
      <funcdef>int <command>NCCS</command></funcdef>
      <paramdef/>
     </funcprototype>
     <funcdescr>
      <para><command>c_cc</command> dizisinin eleman sayısını belirleyen makro.
    </para>
     </funcdescr>
    </funcsynopsis>
   </para>
  </section>
  <section xml:id="glibc-Mode-Functions">
   <info>
    <title>Uçbirim Kipi İşlevleri</title>
    <titleabbrev>Uçbirim özniteliklerini okumak ve ayarlamak için kullanılan işlevler.</titleabbrev>
   </info>
   <para>
    <indexterm scope="glibc-cp">
     <primary>uçbirimler</primary>
     <secondary>kip işlevleri</secondary>
    </indexterm>
   </para>
   <para xml:id="glibc-tcgetattr">
    <indexterm scope="glibc-fn">
     <primary>tcgetattr</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="işlev">
      <funcdef>int <command>tcgetattr</command></funcdef>
      <paramdef>(int             <varname>dosyatanıtıcı</varname>,
 struct termios *<varname>termios-p</varname>)</paramdef>
     </funcprototype>
     <funcdescr>
      <para>
Bu işlev <varname>dosyatanıtıcı</varname> dosya tanıtıcısı ile ilişkili uçbirim aygıtının özniteliklerini öğrenmek için kullanılır. Öznitelikler <varname>termios-p</varname> ile gösterilen yapı içinde döner.
    </para>
      <para><command>tcgetattr</command> başarılıysa 0 ile, değilse bir hata oluştuğunu belirtmek üzere -1 ile döner. Aşağıdaki <command>errno</command> hata durumları bu işlev için tanımlanmıştır:
    </para>
      <para>
       <variablelist>
        <varlistentry>
         <term>
          <literal>EBADF</literal>
         </term>
         <listitem>
          <para><varname>dosyatanıtıcı</varname> argümanı geçerli bir dosya tanıtıcı değil
       </para>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term>
          <literal>ENOTTY</literal>
         </term>
         <listitem>
          <para><varname>dosyatanıtıcı</varname> bir uçbirim ile ilişkili değil
       </para>
         </listitem>
        </varlistentry>
       </variablelist>
      </para>
     </funcdescr>
    </funcsynopsis>
   </para>
   <para xml:id="glibc-tcsetattr">
    <indexterm scope="glibc-fn">
     <primary>tcsetattr</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="işlev">
      <funcdef>int <command>tcsetattr</command></funcdef>
      <paramdef>(int                   <varname>dosyatanıtıcı</varname>,
 int                   <varname>nezaman</varname>,
 const struct termios *<varname>termios-p</varname>)</paramdef>
     </funcprototype>
     <funcdescr>
      <para>
Bu işlev <varname>dosyatanıtıcı</varname> dosya tanıtıcısı ile ilişkili uçbirim aygıtının özniteliklerini ayarlamak için kullanılır.  Yeni öznitelikler <varname>termios-p</varname> ile gösterilen yapı içinde alınır.
    </para>
      <para><varname>nezaman</varname> argümanı kuyruklanmış girdi ve çıktının ne zaman işleme sokulacağını belirtmek için kullanılır. Şu değerlerden birini içerebilir:
    </para>
      <para>
       <variablelist>
        <varlistentry>
         <term>
          <literal>TCSANOW</literal>
         </term>
         <listitem>
          <para><indexterm scope="glibc-vr"><primary>TCSANOW</primary></indexterm>
Değişiklik hemen yapılır.
       </para>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term>
          <literal>TCSADRAIN</literal>
         </term>
         <listitem>
          <para><indexterm scope="glibc-vr"><primary>TCSADRAIN</primary></indexterm>
Kuyruktaki tüm çıktı yazıldıktan sonra değişiklik yapılır. Bu seçeneği çıktıyı etkileyen parametreleri değiştirirken kullanmalısınız.
       </para>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term>
          <literal>TCSAFLUSH</literal>
         </term>
         <listitem>
          <para><indexterm scope="glibc-vr"><primary>TCSAFLUSH</primary></indexterm><command>TCSADRAIN</command> gibidir, ayrıca kuyruktaki tüm girdi iptal edilir.
       </para>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term>
          <literal>TCSASOFT</literal>
         </term>
         <listitem>
          <para><indexterm scope="glibc-vr"><primary>TCSASOFT</primary></indexterm>
Yukarıdaki seçeneklerin herbirini ekleyebileceğiniz bir seçenek bitidir. Uçbirim donanımının durum değiştirmesinin yasaklanması anlamına gelir. Bir BSD oluşumudur ve sadece BSD sistemleri ile GNU sisteminde desteklenir.
       </para>
          <para><command>TCSASOFT</command> kullanımı, <varname>termios-p</varname> ile gösterilen yapının <command>c_cflag</command> üyesine <command>CIGNORE</command> bitinin atanması ile tamamen aynı ayarı yapar. <command>CIGNORE</command> ile ilgili daha fazla bilgi için <xref linkend="glibc-Control-Modes"/> bölümüne bakınız.
       </para>
         </listitem>
        </varlistentry>
       </variablelist>
      </para>
      <para>
Eğer bu işlev kendi denetim uçbirimi ile ilgili olarak bir artalan sürecinden çağrılmışsa, kendi süreç grubundaki tüm süreçler, sürecin yazmaya çalıştığı yolla  bir <command>SIGTTOU</command> sinyali gönderir. Ancak, işlevi çağıran sürecin <command>SIGTTOU</command> sinyallerini engellemesi ya da yoksayması durumunda işlem yine yapılır ama sinyal gönderilmez. Bkz. <xref linkend="glibc-Job-Control"/>.
    </para>
      <para><command>tcsetattr</command> başarılıysa 0 ile döner. Aksi halde -1 ile döner. Aşağıdaki <command>errno</command> hata durumları bu işlev için tanımlanmıştır:
    </para>
      <para>
       <variablelist>
        <varlistentry>
         <term>
          <literal>EBADF</literal>
         </term>
         <listitem>
          <para><varname>dosyatanıtıcı</varname> argümanı geçerli bir dosya tanıtıcı değil
       </para>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term>
          <literal>ENOTTY</literal>
         </term>
         <listitem>
          <para><varname>dosyatanıtıcı</varname> bir uçbirimle ilişkili değil
       </para>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term>
          <literal>EINVAL</literal>
         </term>
         <listitem>
          <para>
Ya <varname>nezaman</varname> argümanı geçersiz ya da <varname>termios-p</varname> argümanındaki veride yanlış birşeyler var.
       </para>
         </listitem>
        </varlistentry>
       </variablelist>
      </para>
     </funcdescr>
    </funcsynopsis>
   </para>
   <para><command>tcgetattr</command> ve <command>tcsetattr</command> işlevleri uçbirim aygıtını bir dosya tanıtıcısı ile belirttiği halde, öznitelikler dosya tanıtıcısının değil uçbirim aygıtının kendisine aittir. Bu, uçbirim aygıtının özniteliklerindeki değişikliklerin kalıcı olduğu anlamına gelir; eğer başka bir süreç daha sonra bu uçbirimi açarsa, süreç dosya tanıtıcısını açarken sizin özniteliklerde belirttiğiniz değişikliklere ilişkin hiçbir şey yapmadığı halde değişmiş öznitelikleri görecektir.
    </para>
   <para>
Benzer şekilde, tek bir sürecin aynı uçbirim için çok sayıda veya yinelenmiş dosya tanıtıcıları varsa, uçbirim özniteliklerindeki değişiklikler tüm dosya tanıtıcılarının girdi ve çıktılarını etkileyecektir. Yani, bir uçbirimi tek karakter okunan, yansılama yapılmayan kipte kullanıyorsanız aynı uçbirimi farklı bir dosya tanıtıcı kullanarak satır tamponlu, yansılanan kipte açamazsınız. Ama uçbirimi önce istediğiniz kipe sokup açabilir işiniz bittikten sonra diğer kipe geçip uçbirimi bırakabilirsiniz.
    </para>
  </section>
  <section xml:id="glibc-Setting-Modes">
   <info>
    <title>Uçbirim Kiplerinin Doğru Dürüst Belirtilmesi</title>
    <titleabbrev>Uçbirim özniteliklerinin olması gerektiği gibi ayarlanması.</titleabbrev>
   </info>
   <para>
Bir uçbirimin kipini değiştireceğiniz zaman, önce <command>tcgetattr</command> çağrısı ile uçbirim aygıtının o anki kipini öğrenmeli, bu kipi istediğiniz özniteliklerle değiştirdikten sonra sonucu <command>tcsetattr</command> çağrısı ile uçbirime göndermelisiniz.
    </para>
   <para><command>struct termios</command> yapısını basitçe ilklendirip öznitelikleri istediğiniz gibi değiştirip sonra bunu <command>tcsetattr</command> işleviyle aktarmanız hiç iyi bir yöntem değildir. Yazılımınızın yıllar sonra bu kılavuzda belgelenmemiş üyelerin desteklendiği sistemlerde çalışabileceğini varsaymalısınız. İlgilenmediğiniz yapı üyelerini değiştirmekten kaçınmak en iyi yöntemdir.
    </para>
   <para>
Dahası, farklı uçbirim aygıtları farklı kip seçimleri gerektirebilir. Bu bakımdan öznitelikleri bir uçbirimden diğerine körü körüne kopyalamaktan da kaçınmalısınız.
    </para>
   <para><command>c_iflag</command>, <command>c_oflag</command> ve <command>c_cflag</command> üyelerinde olduğu gibi bir üye bağımsız seçeneklerin bir kolleksiyonunu içeriyorsa üyenin değerini tamamen değiştirmek de kötü olacaktır. Bunu yapmak yerine üyeyi mevcut değerlerle başlatmalı ve ilgisiz seçeneklere dokunmadan sadece yazılımınız için gerekli seçenekleri değiştirmelisiniz.
    </para>
   <para>
Bu örnekte <command>struct termios</command> yapısındaki diğer verilere dokunmadan sadece bir seçeneğin (<command>ISTRIP</command>) değiştirilmesi gösterilmiştir:
    </para>
   <para>
    <screen>int
set_istrip (int desc, int value)
{
  struct termios settings;
  int result;

  result = tcgetattr (desc, &amp;settings);
  if (result &lt; 0)
    {
      perror ("tcgetattr'de hata");
      return 0;
    }
  settings.c_iflag &amp;= ~ISTRIP;
  if (value)
    settings.c_iflag |= ISTRIP;
  result = tcsetattr (desc, TCSANOW, &amp;settings);
  if (result &lt; 0)
    {
      perror ("tcsetattr'de hata");
      return 0;
    }
  return 1;
}
</screen>
   </para>
  </section>
  <section xml:id="glibc-Input-Modes">
   <info>
    <title>Girdi Kipleri</title>
    <titleabbrev>Düşük seviyeli girdi alımını denetleyen seçenekler.</titleabbrev>
   </info>
   <para>
Bu bölümde girdi işleme ile ilgili düşük seviyeli özellikleri denetlemeye yarayan uçbirim özniteliklerinden bahsedilmiştir: eşlik hatalarının yakalanması, geçici kesme sinyalleri, akış denetimi, <literal>&lt;RET&gt;</literal> ve <literal>&lt;LFD&gt;</literal> karakterleri.
    </para>
   <para>
Bu seçeneklerin hepsi <command>struct termios</command> yapısının <command>c_iflag</command> üyesindeki bitlerdir. Üye bir tamsayıdır ve bu seçenekleri <command>&amp;</command>, <command>|</command> ve <command>^</command> işleçleri ile değiştirebilirsiniz. <command>c_iflag</command> üyesinin değerini toptan değiştirmeyi denemeyin; ilgisiz seçeneklere dokunmadan sadece sizi ilgilendiren seçenekleri değiştirin (bkz. <xref linkend="glibc-Setting-Modes"/>).
    </para>
   <para xml:id="glibc-INPCK">
    <indexterm scope="glibc-vr">
     <primary>INPCK</primary>
    </indexterm>
    <indexterm scope="glibc-cp">
     <primary>eşlik sınaması</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="makro">
      <funcdef>tcflag_t <command>INPCK</command></funcdef>
      <paramdef/>
     </funcprototype>
     <funcdescr>
      <para>
Bu bit varsa, girdi eşlik sınaması etkindir. Yoksa, girdideki eşlik hataları ile ilgili hiçbir şey yapılmaz; karakterler basitçe uygulamaya aktarılır.
    </para>
      <para>
Girdi işlemede eşik sınaması, ilgili uçbirim donanımında eşlik üretiminin ve eşlik saptanmasının etkin olup olmamasından bağımsızdır; bkz. <xref linkend="glibc-Control-Modes"/>.  Örneğin, <command>INPCK</command> girdi kipi seçeneğini temizleyip, <command>PARENB</command> denetim kipi seçeneğini etkileştirip girdideki eşlik hatalarını yoksayarken çıktıda hala eşlik üretebilirsniz.
    </para>
      <para>
Bu bit varsa, bir eşlik hatası saptanırken <command>IGNPAR</command> veya <command>PARMRK</command> bitlerinin varlığı veya yokluğu önem kazanır. Bu bitlerin hiçbiri yoksa, eşlik hatası olan bir bayt uygulamaya <command>'\0'</command> karakteri olarak aktarılır.
</para>
     </funcdescr>
    </funcsynopsis>
   </para>
   <para xml:id="glibc-IGNPAR">
    <indexterm scope="glibc-vr">
     <primary>IGNPAR</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="makro">
      <funcdef>tcflag_t <command>IGNPAR</command></funcdef>
      <paramdef/>
     </funcprototype>
     <funcdescr>
      <para>
Bu bit varsa, tertip veya eşlik hataları olan baytlar yoksayılır. Bu seçenek <command>INPCK</command> seçeneği de etkinse işe yarar.
</para>
     </funcdescr>
    </funcsynopsis>
   </para>
   <para xml:id="glibc-PARMRK">
    <indexterm scope="glibc-vr">
     <primary>PARMRK</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="makro">
      <funcdef>tcflag_t <command>PARMRK</command></funcdef>
      <paramdef/>
     </funcprototype>
     <funcdescr>
      <para>
Bu bit varsa, tertip veya eşlik hataları olan baytlar yazılıma aktarılırken imlenir. Bu bit <command>INPCK</command>'ın varlığı ve <command>IGNPAR</command>'ın yokluğu durumunda anlamlıdır.
    </para>
      <para>
Hatalı baytlar, baytlardan önce gönderilen iki baytla <command>377</command> ve <command>0</command> baytları ile imlenir. Dolaysıyla, yazılım, hatalı baytı uçbirimden alırken aslında üç bayt okur.
    </para>
      <para>
Bir geçerli bayt <command>0377</command> değerine sahipse ve <command>ISTRIP</command> seçeneği etkinse yazılım bu baytı bir eşlik hatasının imi olarak ele alabilir. Bunu önlemek, yani <command>0377</command> karakterinin kendisi olarak ele alınmasını sağlamak için bu bayt yazılıma 2 bayt olarak, <command>0377</command> <command>0377</command> olarak aktarılmalıdır.
</para>
     </funcdescr>
    </funcsynopsis>
   </para>
   <para xml:id="glibc-ISTRIP">
    <indexterm scope="glibc-vr">
     <primary>ISTRIP</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="makro">
      <funcdef>tcflag_t <command>ISTRIP</command></funcdef>
      <paramdef/>
     </funcprototype>
     <funcdescr>
      <para>
Bu bit varsa, geçerli girdi baytları yedi bit uzunlukta kabul edilir; aksi takdirde, hepsi sekiz bit kabul edilir.
</para>
     </funcdescr>
    </funcsynopsis>
   </para>
   <para xml:id="glibc-IGNBRK">
    <indexterm scope="glibc-vr">
     <primary>IGNBRK</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="makro">
      <funcdef>tcflag_t <command>IGNBRK</command></funcdef>
      <paramdef/>
     </funcprototype>
     <funcdescr>
      <para>
Bu bit varsa, geçici kesme (break) durumları yosayılır.
    </para>
      <para><indexterm scope="glibc-cp"><primary>geçici kesme durumu</primary></indexterm><firstterm>Geçici kesme durumu</firstterm>, eşzamansız seri veri iletişimi bağlamında tek bir bayttan daha uzun sıfır değerli bitler olarak tanınır.
</para>
     </funcdescr>
    </funcsynopsis>
   </para>
   <para xml:id="glibc-BRKINT">
    <indexterm scope="glibc-vr">
     <primary>BRKINT</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="makro">
      <funcdef>tcflag_t <command>BRKINT</command></funcdef>
      <paramdef/>
     </funcprototype>
     <funcdescr>
      <para>
Bu bit varsa ve <command>IGNBRK</command> yoksa bir geçici kesme durumu saptandığında uçbirim girdi ve çıktı kuyruklarını temizlenir ve uçbirimle ilişkili önalan süreç grubuna bir <command>SIGINT</command> sinyali gönderilir.
    </para>
      <para>
Ne <command>BRKINT</command> ne de <command>IGNBRK</command> varsa ve bir geçici kesme durumu saptandığında eğer <command>PARMRK</command> yoksa uygulamaya tek bir <command>'\0'</command> karakteri, <command>PARMRK</command> varsa üç karakterlik bir dizi, <command>'\377'</command>, <command>'\0'</command>, <command>'\0'</command> gönderilir.
</para>
     </funcdescr>
    </funcsynopsis>
   </para>
   <para xml:id="glibc-IGNCR">
    <indexterm scope="glibc-vr">
     <primary>IGNCR</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="makro">
      <funcdef>tcflag_t <command>IGNCR</command></funcdef>
      <paramdef/>
     </funcprototype>
     <funcdescr>
      <para>
Bu bit varsa girdideki satırbaşı (<command>'\r'</command>) karakterleri iptal edilir. Satırbaşı karakterinin iptal edilmesi <keycap>RET</keycap> tuşuna basıldığında hem satırbaşı hem de satırsonu karakteri gönderen uçbirimlerde yararlıdır.
</para>
     </funcdescr>
    </funcsynopsis>
   </para>
   <para xml:id="glibc-ICRNL">
    <indexterm scope="glibc-vr">
     <primary>ICRNL</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="makro">
      <funcdef>tcflag_t <command>ICRNL</command></funcdef>
      <paramdef/>
     </funcprototype>
     <funcdescr>
      <para>
Bu bit varsa ve <command>IGNCR</command> yoksa, girdiden alınan satırbaşı (<command>'\r'</command>) karakterleri uygulamaya satırsonu (<command>'\n'</command>) karakterleri olarak aktarılır.
</para>
     </funcdescr>
    </funcsynopsis>
   </para>
   <para xml:id="glibc-INLCR">
    <indexterm scope="glibc-vr">
     <primary>INLCR</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="makro">
      <funcdef>tcflag_t <command>INLCR</command></funcdef>
      <paramdef/>
     </funcprototype>
     <funcdescr>
      <para>
Bu bit varsa, girdiden alınan satırsonu (<command>'\n'</command>) karakterleri uygulamaya satırbaşı (<command>'\r'</command>) karakterleri olarak aktarılır.
</para>
     </funcdescr>
    </funcsynopsis>
   </para>
   <para xml:id="glibc-IXOFF">
    <indexterm scope="glibc-vr">
     <primary>IXOFF</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="makro">
      <funcdef>tcflag_t <command>IXOFF</command></funcdef>
      <paramdef/>
     </funcprototype>
     <funcdescr>
      <para>
Bu bit varsa, girdi üzerinde başlat/durdur denetimi etkinleştirilir. Başka bir deyişle, girdi uygulamanın okuyabileceğinden daha hızlı geliyorsa bilgisayar gerektiği zaman STOP ve START karakterleri gönderir. Bu fikir, gerçek uçbirim donanımının iletişimi STOP karakteri geldiğinde beklemeye alması, START karakterinde ise iletişime kaldığı yerden devam ettirmesi esasına dayanır. Bkz. <xref linkend="glibc-Start-Stop-Characters"/>.
</para>
     </funcdescr>
    </funcsynopsis>
   </para>
   <para xml:id="glibc-IXON">
    <indexterm scope="glibc-vr">
     <primary>IXON</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="makro">
      <funcdef>tcflag_t <command>IXON</command></funcdef>
      <paramdef/>
     </funcprototype>
     <funcdescr>
      <para>
Bu bit varsa, çıktı üzerinde başlat/durdur denetimi etkinleştirilir. Başka bir deyişle, bilgisayar bir  karakteri aldığında çıktıyı bir START karakteri alıncaya kadar bekletir. Bu durumda uygulamaya STOP ve START karakterleri kesinlikle aktarılmaz. Bu bit yoksa, STOP ve START karakterleri sıradan karakterler olarak okunabilir. Bkz. <xref linkend="glibc-Start-Stop-Characters"/>.
</para>
     </funcdescr>
    </funcsynopsis>
   </para>
   <para xml:id="glibc-IXANY">
    <indexterm scope="glibc-vr">
     <primary>IXANY</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="makro">
      <funcdef>tcflag_t <command>IXANY</command></funcdef>
      <paramdef/>
     </funcprototype>
     <funcdescr>
      <para>
Bu bit varsa, STOP karakteri ile bekletilen çıktıyı herhangi bir girdi karakteri başlatır. Aksi takdirde bekletilen çıktılama sadece START karakteri ile sürdürülür.
    </para>
      <para>
Bu bir BSD oluşumudur; sadece BSD sistemlerinde ve GNU sisteminde desteklenir.
</para>
     </funcdescr>
    </funcsynopsis>
   </para>
   <para xml:id="glibc-IMAXBEL">
    <indexterm scope="glibc-vr">
     <primary>IMAXBEL</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="makro">
      <funcdef>tcflag_t <command>IMAXBEL</command></funcdef>
      <paramdef/>
     </funcprototype>
     <funcdescr>
      <para>
Bu bit varsa, uçbirim girdi tamponu dolduğunda uçbirime çanı çaldırmak için bir BELL karakteri (<command>007</command>) gönderilir.
    </para>
      <para>
Bu bir BSD oluşumudur.
    </para>
     </funcdescr>
    </funcsynopsis>
   </para>
  </section>
  <section xml:id="glibc-Output-Modes">
   <info>
    <title>Çıktı Kipleri</title>
    <titleabbrev>Düşük seviyeli çıktılamayı denetleyen seçenekler.</titleabbrev>
   </info>
   <para>
Bu bölümde çıktı karakterlerinin nasıl dönüştürüleceği ve gösterilirken nasıl biçimleneceği ile ilgili seçenekler ve alanlar açıklanmıştır. Bunların tamamı <command>struct termios</command> yapısının <command>c_oflag</command> üyesindeki değerin içinde yer alır.
    </para>
   <para>
Üye bir tamsayıdır ve bu seçenekleri <command>&amp;</command>, <command>|</command> ve <command>^</command> işleçleri ile değiştirebilirsiniz. <command>c_oflag</command> üyesinin değerini toptan değiştirmeyi denemeyin; ilgisiz seçeneklere dokunmadan sadece sizi ilgilendiren seçenekleri değiştirin (bkz. <xref linkend="glibc-Setting-Modes"/>).
    </para>
   <para xml:id="glibc-OPOST">
    <indexterm scope="glibc-vr">
     <primary>OPOST</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="makro">
      <funcdef>tcflag_t <command>OPOST</command></funcdef>
      <paramdef/>
     </funcprototype>
     <funcdescr>
      <para>
Bu bit varsa, çıktı verisi ilgili uçbirim aygıtında gösterimek üzere bir takım yollarla işlenir. Bu işlem genellikle satırsonu ve satırbaşı karakterlerinin satırsonu (<command>'\n'</command>) karakteri ile değiştirilmesi şeklinde olur.
    </para>
      <para>
Bu bit yoksa, karakterler oldukları gibi aktarılırlar.
</para>
     </funcdescr>
    </funcsynopsis>
   </para>
   <para>
Aşağıdaki üç bit birer BSD oluşumudur ve sadece BSD sistemleri ile GNU sisteminde vardır. Bunlar sadece <command>OPOST</command> bitinin varlığında anlamlıdır.
    </para>
   <para xml:id="glibc-ONLCR">
    <indexterm scope="glibc-vr">
     <primary>ONLCR</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="makro">
      <funcdef>tcflag_t <command>ONLCR</command></funcdef>
      <paramdef/>
     </funcprototype>
     <funcdescr>
      <para>
Bu bit varsa, satırsonu karakterlerinin önüne birer satırbaşı karakteri yerleştirilir.
</para>
     </funcdescr>
    </funcsynopsis>
   </para>
   <para xml:id="glibc-OXTABS">
    <indexterm scope="glibc-vr">
     <primary>OXTABS</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="makro">
      <funcdef>tcflag_t <command>OXTABS</command></funcdef>
      <paramdef/>
     </funcprototype>
     <funcdescr>
      <para>
Bu bit varsa, sekme karakterleri sekizlik sütunlar oluşturacak biçimde boşluk karakteri ile değiştirilir.
</para>
     </funcdescr>
    </funcsynopsis>
   </para>
   <para xml:id="glibc-ONOEOT">
    <indexterm scope="glibc-vr">
     <primary>ONOEOT</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="makro">
      <funcdef>tcflag_t <command>ONOEOT</command></funcdef>
      <paramdef/>
     </funcprototype>
     <funcdescr>
      <para>
Bu bit varsa, çıktıdaki <command>C-d</command> karakterleri iptal edilir. Bu karakterler çoğu çevirmeli ağ uçbiriminde hattın kesilmesine yol açar.
    </para>
     </funcdescr>
    </funcsynopsis>
   </para>
  </section>
  <section xml:id="glibc-Control-Modes">
   <info>
    <title>Denetim Kipleri</title>
    <titleabbrev>Seri port davranışını denetleyen seçenekler.</titleabbrev>
   </info>
   <para>
Bu bölümde eşzamansız seri veri iletimi ile ilgili denetim parametreleri olan uçbirim seçenekleri ve alanlarından bahsedilecektir. Bu seçenekler diğer uçbirim port çeşitlerinde etkisiz olabilir (örneğin, bir ağ bağlantısı olarak uçbirimsiler). Bu seçeneklerin hepsi <command>struct termios</command> yapısının <command>c_cflag</command> üyesinin bitleridir.
    </para>
   <para><command>c_cflag</command> bir tamsayıdır ve bu seçenekleri <command>&amp;</command>, <command>|</command> ve <command>^</command> işleçleri ile değiştirebilirsiniz. <command>c_cflag</command> üyesinin değerini toptan değiştirmeyi denemeyin; ilgisiz seçeneklere dokunmadan sadece sizi ilgilendiren seçenekleri değiştirin (bkz. <xref linkend="glibc-Setting-Modes"/>).
    </para>
   <para xml:id="glibc-CLOCAL">
    <indexterm scope="glibc-vr">
     <primary>CLOCAL</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="makro">
      <funcdef>tcflag_t <command>CLOCAL</command></funcdef>
      <paramdef/>
     </funcprototype>
     <funcdescr>
      <para>
Bu bit varsa, uçbirimin "yerel olarak" bağlı olduğu ve modem durum satırlarının (örneğin, taşıyıcının saptanması) yoksayıldığı anlaşılır.
<indexterm scope="glibc-cp"><primary>modem durum satırları</primary></indexterm>
<indexterm scope="glibc-cp"><primary>taşıyıcının saptanması</primary></indexterm>
Bu bit yoksa, <command>open</command> işlevini <command>O_NONBLOCK</command> seçeneğinin yokluğunda çağırırsanız, çoğu sistemde <command>open</command> işlevi bir modem bağlantısı sağlanıncaya kadar engellenir.
    </para>
      <para>
Bu bit yoksa ve bir modem bağlantısı saptanamazsa, (eğer varsa) uçbirim için denetim süreç grubuna bir <command>SIGHUP</command> sinyali gönderilir. Bir bağlantı kesilmesinden sonraki okuma işlemleri bir dosyasonu durumuna, yazma işlemleri ise bir  <command>EIO</command> hatasının dönmesine sebep olur. Bu durumu ortadan kaldırmak için uçbirim aygıtı kapatılıp yeniden açılmalıdır.
</para>
     </funcdescr>
    </funcsynopsis>
   </para>
   <para xml:id="glibc-HUPCL">
    <indexterm scope="glibc-cp">
     <primary>modem bağlantı kesmesi</primary>
    </indexterm>
    <indexterm scope="glibc-vr">
     <primary>HUPCL</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="makro">
      <funcdef>tcflag_t <command>HUPCL</command></funcdef>
      <paramdef/>
     </funcprototype>
     <funcdescr>
      <para>
Bu bit varsa, açık uçbirim aygıtı olan tüm süreçler çıktığında ya da dosyalarını kapattıklarında bir modem bağlantı kesmesi üretilir.
</para>
     </funcdescr>
    </funcsynopsis>
   </para>
   <para xml:id="glibc-CREAD">
    <indexterm scope="glibc-vr">
     <primary>CREAD</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="makro">
      <funcdef>tcflag_t <command>CREAD</command></funcdef>
      <paramdef/>
     </funcprototype>
     <funcdescr>
      <para>
Bu bit varsa, girdi uçbirimden okunabilir. Aksi takdirde, girdi geldiği anda iptal edilir.
</para>
     </funcdescr>
    </funcsynopsis>
   </para>
   <para xml:id="glibc-CSTOPB">
    <indexterm scope="glibc-vr">
     <primary>CSTOPB</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="makro">
      <funcdef>tcflag_t <command>CSTOPB</command></funcdef>
      <paramdef/>
     </funcprototype>
     <funcdescr>
      <para>
Bu bit varsa, iki durdurma biti kullanılır. Aksi takdirde, sadece bir durdurma biti kullanılır.
</para>
     </funcdescr>
    </funcsynopsis>
   </para>
   <para xml:id="glibc-PARENB">
    <indexterm scope="glibc-vr">
     <primary>PARENB</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="makro">
      <funcdef>tcflag_t <command>PARENB</command></funcdef>
      <paramdef/>
     </funcprototype>
     <funcdescr>
      <para>
Bu bit varsa, eşlik bitinin üretimi ve saptanması etkinleştirilir. Girdideki eşlik hatalarının nasıl ele alındığı <xref linkend="glibc-Input-Modes"/> bölümünde anlatılmıştır.
    </para>
      <para>
Bu bit yoksa, çıktı karakterlerinde eşlik biti eklenmez ve girdi karakterlerinde eşlik bitlerinin doğruluğuna bakılmaz.
</para>
     </funcdescr>
    </funcsynopsis>
   </para>
   <para xml:id="glibc-PARODD">
    <indexterm scope="glibc-vr">
     <primary>PARODD</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="makro">
      <funcdef>tcflag_t <command>PARODD</command></funcdef>
      <paramdef/>
     </funcprototype>
     <funcdescr>
      <para>
Bu bit sadece <command>PARENB</command> biti varsa anlamlıdır. <command>PARODD</command> biti varsa tek eşlik kullanılır, aksi takdirde çift eşlik kullanılır.
       </para>
      <para>
Denetim kipi seçenekleri ayrıca karakter başına bit sayısı için bir alan içerir. Bu değeri çıkarmak için <command>CSIZE</command> makrosunu bir maske olarak kullanabilirsiniz: <command>settings.c_cflag &amp; CSIZE</command>
</para>
     </funcdescr>
    </funcsynopsis>
   </para>
   <para xml:id="glibc-CSIZE">
    <indexterm scope="glibc-vr">
     <primary>CSIZE</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="makro">
      <funcdef>tcflag_t <command>CSIZE</command></funcdef>
      <paramdef/>
     </funcprototype>
     <funcdescr>
      <para>
Karakter başına bit sayısı için bir maskedir.
</para>
     </funcdescr>
    </funcsynopsis>
   </para>
   <para xml:id="glibc-CS5">
    <indexterm scope="glibc-vr">
     <primary>CS5</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="makro">
      <funcdef>tcflag_t <command>CS5</command></funcdef>
      <paramdef/>
     </funcprototype>
     <funcdescr>
      <para>
Her baytın beş bit olduğunu belirtir.
</para>
     </funcdescr>
    </funcsynopsis>
   </para>
   <para xml:id="glibc-CS6">
    <indexterm scope="glibc-vr">
     <primary>CS6</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="makro">
      <funcdef>tcflag_t <command>CS6</command></funcdef>
      <paramdef/>
     </funcprototype>
     <funcdescr>
      <para>
Her baytın altı bit olduğunu belirtir.
</para>
     </funcdescr>
    </funcsynopsis>
   </para>
   <para xml:id="glibc-CS7">
    <indexterm scope="glibc-vr">
     <primary>CS7</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="makro">
      <funcdef>tcflag_t <command>CS7</command></funcdef>
      <paramdef/>
     </funcprototype>
     <funcdescr>
      <para>
Her baytın yedi bit olduğunu belirtir.
</para>
     </funcdescr>
    </funcsynopsis>
   </para>
   <para xml:id="glibc-CS8">
    <indexterm scope="glibc-vr">
     <primary>CS8</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="makro">
      <funcdef>tcflag_t <command>CS8</command></funcdef>
      <paramdef/>
     </funcprototype>
     <funcdescr>
      <para>
Her baytın sekiz bit olduğunu belirtir.
       </para>
      <para>
Aşağıdaki dört bit birer BSD oluşumudur; sadece BSD sistemlerinde ve GNU sisteminde vardır.
</para>
     </funcdescr>
    </funcsynopsis>
   </para>
   <para xml:id="glibc-CCTS_OFLOW">
    <indexterm scope="glibc-vr">
     <primary>CCTS_OFLOW</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="makro">
      <funcdef>tcflag_t <command>CCTS_OFLOW</command></funcdef>
      <paramdef/>
     </funcprototype>
     <funcdescr>
      <para>
Bu bit varsa, CTS teline (RS232 protokolü) göre çıktı akış denetimi etkin olur.
</para>
     </funcdescr>
    </funcsynopsis>
   </para>
   <para xml:id="glibc-CRTS_IFLOW">
    <indexterm scope="glibc-vr">
     <primary>CRTS_IFLOW</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="makro">
      <funcdef>tcflag_t <command>CRTS_IFLOW</command></funcdef>
      <paramdef/>
     </funcprototype>
     <funcdescr>
      <para>
Bu bit varsa, RTS teline (RS232 protokolü) göre çıktı akış denetimi etkin olur.
</para>
     </funcdescr>
    </funcsynopsis>
   </para>
   <para xml:id="glibc-MDMBUF">
    <indexterm scope="glibc-vr">
     <primary>MDMBUF</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="makro">
      <funcdef>tcflag_t <command>MDMBUF</command></funcdef>
      <paramdef/>
     </funcprototype>
     <funcdescr>
      <para>
Bu bit varsa, taşıyıcı bazlı çıktı akış denetimi etkin olur.
</para>
     </funcdescr>
    </funcsynopsis>
   </para>
   <para xml:id="glibc-CIGNORE">
    <indexterm scope="glibc-vr">
     <primary>CIGNORE</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="makro">
      <funcdef>tcflag_t <command>CIGNORE</command></funcdef>
      <paramdef/>
     </funcprototype>
     <funcdescr>
      <para>
Bu bit varsa, denetim kiplerinin ve hat hızı değerlerinin tamamen yoksayıldığı anlamına gelir. Bu sadece bir <command>tcsetattr</command> çağrısı ile anlam kazanır.
    </para>
      <para><command>cfgetispeed</command> ve <command>cfgetospeed</command> çağrılarından dönen hız değerleri ile <command>c_cflag</command> üyesi çağrı ile etkisiz olacaktır. <command>c_cflag</command> içindeki donanımla ilgili ayrıntılara dokunmadan diğer üyelerdeki yazılımsal kiplerin tamamını değiştirmek isterseniz <command>CIGNORE</command> faydalıdır. (Bu, <command>tcsettattr</command> ile <command>TCSASOFT</command> seçeneğinin atanması ile ilgilidir.)
    </para>
      <para>
Bu bit <command>tcgetattr</command> tarafından döndürülen yapıda asla bulunmaz.
    </para>
     </funcdescr>
    </funcsynopsis>
   </para>
  </section>
  <section xml:id="glibc-Local-Modes">
   <info>
    <title>Yerel Kipler</title>
    <titleabbrev>Yüksek seviyeli girdi işlemeyi denetleyen seçenekler.</titleabbrev>
   </info>
   <para>
Bu bölümde <command>struct termios</command> yapısının <command>c_lflag</command> üyesindeki seçeneklerden bahsedilecektir. Bu seçenekler genelde <xref linkend="glibc-Input-Modes"/> bölümünde bahsedilen girdi kipleri seçeneklerinden yansılama, sinyaller, kurallı ve kuralsız girdi seçimi gibi girdi işlemenin daha yüksek seviyeli işlemlerini denetler.
    </para>
   <para><command>c_lflag</command> bir tamsayıdır ve bu seçenekleri <command>&amp;</command>, <command>|</command> ve <command>^</command> işleçleri ile değiştirebilirsiniz. <command>c_lflag</command> üyesinin değerini toptan değiştirmeyi denemeyin; ilgisiz seçeneklere dokunmadan sadece sizi ilgilendiren seçenekleri değiştirin (bkz. <xref linkend="glibc-Setting-Modes"/>).
    </para>
   <para xml:id="glibc-ICANON">
    <indexterm scope="glibc-vr">
     <primary>ICANON</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="makro">
      <funcdef>tcflag_t <command>ICANON</command></funcdef>
      <paramdef/>
     </funcprototype>
     <funcdescr>
      <para>
Bu bit varsa, kurallı girdi işleme kipi etkin olur. Aksi takdirde, girdi kuralsız kipte işlenir. Bkz. <xref linkend="glibc-Canonical-or-Not"/>.
</para>
     </funcdescr>
    </funcsynopsis>
   </para>
   <para xml:id="glibc-ECHO">
    <indexterm scope="glibc-vr">
     <primary>ECHO</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="makro">
      <funcdef>tcflag_t <command>ECHO</command></funcdef>
      <paramdef/>
     </funcprototype>
     <funcdescr>
      <para>
Bu bit varsa, girdi karakterlerinin uçbirime yansılanması etkin olur.
</para>
     </funcdescr>
    </funcsynopsis>
   </para>
   <para xml:id="glibc-ECHOE">
    <indexterm scope="glibc-cp">
     <primary>uçbirimler</primary>
     <secondary>girdinin yansılanması</secondary>
    </indexterm>
    <indexterm scope="glibc-vr">
     <primary>ECHOE</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="makro">
      <funcdef>tcflag_t <command>ECHOE</command></funcdef>
      <paramdef/>
     </funcprototype>
     <funcdescr>
      <para>
Bu bit varsa, yansılama sırasında girdi ekrandaki son satırın son karakteri ERASE karakteri tarafından silinmiş olarak gösterilir. Aksi takdirde silinen karakter yansılanıp silinerek ne yapılmış olduğu gösterilir (girdinin gösterildiği uçbirimlerde yararlıdır).
    </para>
      <para>
Bu bit sadece gösterim sırasındaki davranışı denetler; ERASE karakterinin davranışını ve girdinin silinmesini, tamamen ilgisiz olan <command>ECHOE</command>'nin ne olduğuna bakılmaksızın, <command>ICANON</command> biti denetler.
</para>
     </funcdescr>
    </funcsynopsis>
   </para>
   <para xml:id="glibc-ECHOPRT">
    <indexterm scope="glibc-vr">
     <primary>ECHOPRT</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="makro">
      <funcdef>tcflag_t <command>ECHOPRT</command></funcdef>
      <paramdef/>
     </funcprototype>
     <funcdescr>
      <para>
Bu bit <command>ECHOE</command> gibidir, ERASE karakteri mekanik bir uçbirimdekine benzer bir yolla gösterilir. ERASE karakterini tuşladığınızda silinen ilk karakterin öncesine bir <command>\</command> karakteri basılır. Tekrar ERASE karakterini tuşlarsanız sonraki karakter silinir. Bunun ardından bir normal karakteri tuşlarsanız karakter basılmadan önce bir <command>/</command> karakteri basılır.
    </para>
      <para>
Bu bir BSD oluşumudur ve sadece BSD sistemleri ile GNU sisteminde vardır.
</para>
     </funcdescr>
    </funcsynopsis>
   </para>
   <para xml:id="glibc-ECHOK">
    <indexterm scope="glibc-vr">
     <primary>ECHOK</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="makro">
      <funcdef>tcflag_t <command>ECHOK</command></funcdef>
      <paramdef/>
     </funcprototype>
     <funcdescr>
      <para>
Bu bit, KILL karakteri normal olarak yansılandıktan sonra yeni satıra geçilmesini sağlayarak, KILL karakterinin özel bir gösterimini etkinleştirir. <command>ECHOKE</command> (aşağıda) davranışı bundan daha hoş görünür.
    </para>
      <para>
Bu bit yoksa, KILL karakteri yokmuşçasına yansılanır. Kullanıcı sadece KILL karakterinin önceki girdiyi sildiğini hatırlayacak, ekranda bunun belirtisini göstermeyecektir.
    </para>
      <para>
Bu bit sadece ekrandaki davranışı denetler; KILL karakterinin tanınması ve girdinin silinmesi sadece <command>ICANON</command> bitinin varlığına bağlıdır, <command>ECHOK</command> bu bakımdan etkili değildir.
</para>
     </funcdescr>
    </funcsynopsis>
   </para>
   <para xml:id="glibc-ECHOKE">
    <indexterm scope="glibc-vr">
     <primary>ECHOKE</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="makro">
      <funcdef>tcflag_t <command>ECHOKE</command></funcdef>
      <paramdef/>
     </funcprototype>
     <funcdescr>
      <para>
Bu bit <command>ECHOK</command> bitine benzer.  Ekrandan satırın tamamının kesilerek silinmesi ile kendini gösteren KILL karakterinin özel bir gösterimini etkinleştirir. Bu bir BSD oluşumudur ve sadece BSD sistemleri ile GNU sisteminde vardır.
</para>
     </funcdescr>
    </funcsynopsis>
   </para>
   <para xml:id="glibc-ECHONL">
    <indexterm scope="glibc-vr">
     <primary>ECHONL</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="makro">
      <funcdef>tcflag_t <command>ECHONL</command></funcdef>
      <paramdef/>
     </funcprototype>
     <funcdescr>
      <para>
Bu bit ve <command>ICANON</command> biti varsa, satırsonu (<command>'\n'</command>) karakteri <command>ECHO</command> biti yoksa bile yansılanır.
</para>
     </funcdescr>
    </funcsynopsis>
   </para>
   <para xml:id="glibc-ECHOCTL">
    <indexterm scope="glibc-vr">
     <primary>ECHOCTL</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="makro">
      <funcdef>tcflag_t <command>ECHOCTL</command></funcdef>
      <paramdef/>
     </funcprototype>
     <funcdescr>
      <para>
Bu bit ve <command>ECHO</command> biti varsa, denetim karakterlerine karşı düşen karakterler <command>^</command> ile öncelenerek yansılanır. Örneğin ctrl+A, <command>^A</command> olarak yansılanır. Uçbirimde denetim karakterlerinin istenmeyen etkiler oluşturmaması için kimi zaman etkileşimli girdi kipinde tercih edilir.
    </para>
      <para>
Bu bir BSD oluşumudur ve sadece BSD sistemleri ile GNU sisteminde vardır.
</para>
     </funcdescr>
    </funcsynopsis>
   </para>
   <para xml:id="glibc-ISIG">
    <indexterm scope="glibc-vr">
     <primary>ISIG</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="makro">
      <funcdef>tcflag_t <command>ISIG</command></funcdef>
      <paramdef/>
     </funcprototype>
     <funcdescr>
      <para>
Bu bit INTR, QUIT ve SUSP karakterlerinin tanınması ile ilgilidir. Bu karakterlerle ilgili işlevler sadece bu bitin varlığında ilgili işlemleri yaparlar. Girdi kipinin kurallı veya kuralsız olması bu karakterlerin yorumlanışını etkilemez.
    </para>
      <para>
Bu karakterlerin tanınmasını iptal ederken dikkatli olmalısınız. Yoksa uygulamalar kullanıcılar tarafından kolayca durdurulamazlar. Bu biti kaldırırsanız, yazılımınızda bu karakterlerin gönderdiği sinyalleri gönderecek ya da çıkmayı sağlayacak bir arayüz oluşturmanız gerekir. Bkz. <xref linkend="glibc-Signal-Characters"/>.
<indexterm scope="glibc-cp"><primary>uçbirimler</primary><secondary>etkileşimli sinyaller</secondary></indexterm>
</para>
     </funcdescr>
    </funcsynopsis>
   </para>
   <para xml:id="glibc-IIEXTEN">
    <indexterm scope="glibc-vr">
     <primary>IEXTEN</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="makro">
      <funcdef>tcflag_t <command>IEXTEN</command></funcdef>
      <paramdef/>
     </funcprototype>
     <funcdescr>
      <para>
POSIX.1, <command>IEXTEN</command>'i gerçekleme ile tanımlanmış manada verir, dolayısıyla bu bitin tüm sistemlerde böyle yorumlanacağından emin olamazsınız.
    </para>
      <para>
BSD sistemlerinde ve GNU sisteminde bu bit LNEXT ve DISCARD karakterlerini etkinleştirir. Bkz. <xref linkend="glibc-Other-Special"/>.
</para>
     </funcdescr>
    </funcsynopsis>
   </para>
   <para xml:id="glibc-NOFLSH">
    <indexterm scope="glibc-vr">
     <primary>NOFLSH</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="makro">
      <funcdef>tcflag_t <command>NOFLSH</command></funcdef>
      <paramdef/>
     </funcprototype>
     <funcdescr>
      <para>
Normalde, INTR, QUIT ve SUSP karakterleri uçbirimin girdi ve çıktı kuyruklarının temizlenmesine sebep olur. Bu bit varsa, kuyruklar temizlenmez.
</para>
     </funcdescr>
    </funcsynopsis>
   </para>
   <para xml:id="glibc-TOSTOP">
    <indexterm scope="glibc-vr">
     <primary>TOSTOP</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="makro">
      <funcdef>tcflag_t <command>TOSTOP</command></funcdef>
      <paramdef/>
     </funcprototype>
     <funcdescr>
      <para>
Bu bit varsa ve sistem iş denetimini destekliyorsa, <command>SIGTTOU</command> sinyalleri uçbirime yazmaya çalışan artalan süreçleri tarafından üretilir. Bkz. <xref linkend="glibc-Access-to-the-Terminal"/>.
       </para>
      <para>
Aşağıdaki bitler birer BSD oluşumudur ve bunlar sadece BSD sistemleri ile GNU sisteminde vardır.
</para>
     </funcdescr>
    </funcsynopsis>
   </para>
   <para xml:id="glibc-ALTWERASE">
    <indexterm scope="glibc-vr">
     <primary>ALTWERASE</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="makro">
      <funcdef>tcflag_t <command>ALTWERASE</command></funcdef>
      <paramdef/>
     </funcprototype>
     <funcdescr>
      <para>
Bu bit WERASE karakterinin silme işlemini nasıl yapacağını belirler. WERASE karakteri bir sözcüğü başlangıcına kadar geriye doğru siler. Burada sorun bu başlangıcın nasıl belirleneceğidir.
    </para>
      <para>
Bu bit yoksa, sözcüğün başlangıcı bir boşluk karakterinden sonra gelen ilk boşluk olmayan karakterdir. Bu bit varsa, sözcüğün başlangıcı, varsa bir alfanümerik karakter, yoksa hemen ardından bir karakter gelen bir alt çizgi karakteridir.
    </para>
      <para>
WERASE karakteri ile ilgili daha fazla bilgi için <xref linkend="glibc-Editing-Characters"/> bölümüne bakınız.
</para>
     </funcdescr>
    </funcsynopsis>
   </para>
   <para xml:id="glibc-FLUSHO">
    <indexterm scope="glibc-vr">
     <primary>FLUSHO</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="makro">
      <funcdef>tcflag_t <command>FLUSHO</command></funcdef>
      <paramdef/>
     </funcprototype>
     <funcdescr>
      <para>
Bu bit DISCARD karakteri tuşlandığında konum değiştirir. Bu bit birlenirken tüm çıktı iptal edilir. Bkz. <xref linkend="glibc-Other-Special"/>.
</para>
     </funcdescr>
    </funcsynopsis>
   </para>
   <para xml:id="glibc-NOKERNINFO">
    <indexterm scope="glibc-vr">
     <primary>NOKERNINFO</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="makro">
      <funcdef>tcflag_t <command>NOKERNINFO</command></funcdef>
      <paramdef/>
     </funcprototype>
     <funcdescr>
      <para>
Bu bitin varlığ STATUS karakterinin işlenmesini iptal eder. Bkz. <xref linkend="glibc-Other-Special"/>.
</para>
     </funcdescr>
    </funcsynopsis>
   </para>
   <para xml:id="glibc-PENDIN">
    <indexterm scope="glibc-vr">
     <primary>PENDIN</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="makro">
      <funcdef>tcflag_t <command>PENDIN</command></funcdef>
      <paramdef/>
     </funcprototype>
     <funcdescr>
      <para>
Bu bit varsa, yeniden basılacak bir girdi satırı var demektir. REPRINT karakterinin tuşlanması bu bitin birlenmesine ve yeniden basma işinin bitimine kadar bir olarak kalmasına sebep olur. Bkz. <xref linkend="glibc-Editing-Characters"/>.
    </para>
     </funcdescr>
    </funcsynopsis>
   </para>
  </section>
  <section xml:id="glibc-Line-Speed">
   <info>
    <title>Hat Hızı</title>
    <titleabbrev>Uçbirim hızı nasıl belirtilir ve saptanır.</titleabbrev>
   </info>
   <para><indexterm scope="glibc-cp"><primary>uçbirimler</primary><secondary>hat hızı</secondary></indexterm>
Uçbirim hat hızı, bilgisayara uçbirime ne kadar hızlı okuma ve yazma yapacağını belirtmek için kullanılır.
    </para>
   <para>
Uçbirim gerçek bir seri hatta bağlıysa, belirttiğiniz uçbirim hızı aslında hat hızını denetler (Eğer hat hızı ile uçbirimin kendi hızı eşleşmezse iletişim gerçekleşmez). Gerçek seri portlar sadece belirli standart hızları kabul ederler. Ayrıca, bazı donanımlar standart hızların tamamını desteklemeyebilir. Hızın sıfır olarak belirtilmesi bir çevirmeli ağ bağlantısının kesilmesine ve modem denetim sinyallerinin durdurulmasına sebep olur.
    </para>
   <para>
Eğer uçbirim gerçek bir seri hat değilse (örneğin, bir ağ bağlantısı), hat hızı gerçekte iletim hızını etkilemez ama bazı uygulamalar boşluk doldurma miktarını saptayabilmek için bu değeri kullanabilecektir. En iyisi bir hattın hızını, asıl uçbirimin asıl hızı ile eşleşen bir değer olarak belirtmektir, ancak boşluk doldurma miktarını değiştiren farklı değerler hakkında deneyimli olmanız gerekir.
    </para>
   <para>
Esas olarak her uçbirim için iki hat hızı vardır: girdi ve çıktı hızı. Bunları birbirinden bağımsız olarak ayarlamak mümkünse de çoğunlukla her iki yönde de aynı hızlar kullanılır.
    </para>
   <para>
Hız değerleri <command>struct termios</command> yapısında saklanır ama onlara doğrudan yapı üzerinden erişmeye kalkmayın. Bu değerleri yapı içinde değiştirmek ya da okumak için aşağıdaki işlevleri kullanın:
    </para>
   <para xml:id="glibc-cfgetospeed">
    <indexterm scope="glibc-fn">
     <primary>cfgetospeed</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="işlev">
      <funcdef>speed_t <command>cfgetospeed</command></funcdef>
      <paramdef>(const struct termios *<varname>termios-p</varname>)</paramdef>
     </funcprototype>
     <funcdescr>
      <para><varname>*termios-p</varname> yapısında saklanan çıktı hat hızı ile döner.
</para>
     </funcdescr>
    </funcsynopsis>
   </para>
   <para xml:id="glibc-cfgetispeed">
    <indexterm scope="glibc-fn">
     <primary>cfgetispeed</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="işlev">
      <funcdef>speed_t <command>cfgetispeed</command></funcdef>
      <paramdef>(const struct termios *<varname>termios-p</varname>)</paramdef>
     </funcprototype>
     <funcdescr>
      <para><varname>*termios-p</varname> yapısında saklanan girdi hat hızı ile döner.
</para>
     </funcdescr>
    </funcsynopsis>
   </para>
   <para xml:id="glibc-cfsetospeed">
    <indexterm scope="glibc-fn">
     <primary>cfsetospeed</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="işlev">
      <funcdef>int <command>cfsetospeed</command></funcdef>
      <paramdef>(struct termios *<varname>termios-p</varname>,
 speed_t         <varname>hız</varname>)</paramdef>
     </funcprototype>
     <funcdescr>
      <para>
Bu işlev <varname>hız</varname> değerini <varname>*termios-p</varname> yapısında çıktı hızı olarak saklar. Normal dönüş değeri sıfırdır, -1 değeri bir hata oluştuğunu gösterir. Eğer <varname>hız</varname> bir hız değeri belirtmiyorsa işlev -1 ile döner.
</para>
     </funcdescr>
    </funcsynopsis>
   </para>
   <para xml:id="glibc-cfsetispeed">
    <indexterm scope="glibc-fn">
     <primary>cfsetispeed</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="işlev">
      <funcdef>int <command>cfsetispeed</command></funcdef>
      <paramdef>(struct termios *<varname>termios-p</varname>,
 speed_t         <varname>hız</varname>)</paramdef>
     </funcprototype>
     <funcdescr>
      <para>
Bu işlev <varname>hız</varname> değerini <varname>*termios-p</varname> yapısında girdi hızı olarak saklar. Normal dönüş değeri sıfırdır, -1 değeri bir hata oluştuğunu gösterir. Eğer <varname>hız</varname> bir hız değeri belirtmiyorsa işlev -1 ile döner.
</para>
     </funcdescr>
    </funcsynopsis>
   </para>
   <para xml:id="glibc-cfsetspeed">
    <indexterm scope="glibc-fn">
     <primary>cfsetspeed</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="işlev">
      <funcdef>int <command>cfsetspeed</command></funcdef>
      <paramdef>(struct termios *<varname>termios-p</varname>,
 speed_t         <varname>hız</varname>)</paramdef>
     </funcprototype>
     <funcdescr>
      <para>
Bu işlev <varname>hız</varname> değerini <varname>*termios-p</varname> yapısında hem girdi hem de çıktı hızı olarak saklar. Normal dönüş değeri sıfırdır, -1 değeri bir hata oluştuğunu gösterir. Eğer <varname>hız</varname> bir hız değeri belirtmiyorsa işlev -1 ile döner. Bu işlev bir BSD oluşumudur.
</para>
     </funcdescr>
    </funcsynopsis>
   </para>
   <para xml:id="glibc-speed_t">
    <indexterm scope="glibc-tp">
     <primary>speed_t</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="veri türü">
      <funcdef>
       <command>speed_t</command>
      </funcdef>
      <paramdef/>
     </funcprototype>
     <funcdescr>
      <para><command>speed_t</command> hat hızını göstermek için kullanılan bir işaretsiz tamsayı veri türüdür.
</para>
     </funcdescr>
    </funcsynopsis>
   </para>
   <para><command>cfsetospeed</command> ve <command>cfsetispeed</command> işlevleri hataları sadece hat hızları sistem tarafından desteklenmediğinde raporlar. Eğer hat hızlarını temel olarak kabul edilebilir değerlerde belirtirseniz bu işlevler başarılı olur. Fakat işlevler belli bir donanım aygıtının bu hat hızlarını destekleyip desteklemediğine bakmaz, aslında hangi aygıtın kullanılacağını da bilmezler. Eğer <command>tcsetattr</command> işlevi ile belli bir aygıta bir hız belirtirseniz ve bu aygıt bu hızı desteklemiyorsa işlev -1 ile dönecektir.
    </para>
   <para>
    <note>
     <info>
      <title>Taşınabilirlik Bilgisi</title>
     </info>
     <para>GNU kütüphanesinde, yukarıda bahsedilen işlevler hızları saniyede bit sayısı olarak kabul eder ve saniyede bit sayısı olarak döndürürler. Diğer kütüphanelerde hızların belirli kodlarla belirtilmesi gerekir. POSIX.1 taşınabilirliği için, hızı aşağıdaki sembolleri kullanarak belirtmelisiniz, onların sayısal değerleri sisteme bağımlıdır fakat her isim belli bir anlama gelir: <command>B110</command> =&gt; 100 bps, <command>B300</command> =&gt; 300 bps, ... böyle gider. Bu hızları taşınabilir olarak belirtmenin başka bir yolu yoktur. Bunlar sadece seri hatların desteklediği, sıklıkla kullanılan hızları belirtirler.</para>
    </note>
   </para>
   <para>
    <indexterm scope="glibc-vr">
     <primary>B0</primary>
    </indexterm>
    <indexterm scope="glibc-vr">
     <primary>B50</primary>
    </indexterm>
    <indexterm scope="glibc-vr">
     <primary>B75</primary>
    </indexterm>
    <indexterm scope="glibc-vr">
     <primary>B110</primary>
    </indexterm>
    <indexterm scope="glibc-vr">
     <primary>B134</primary>
    </indexterm>
    <indexterm scope="glibc-vr">
     <primary>B150</primary>
    </indexterm>
    <indexterm scope="glibc-vr">
     <primary>B200</primary>
    </indexterm>
    <indexterm scope="glibc-vr">
     <primary>B300</primary>
    </indexterm>
    <indexterm scope="glibc-vr">
     <primary>B600</primary>
    </indexterm>
    <indexterm scope="glibc-vr">
     <primary>B1200</primary>
    </indexterm>
    <indexterm scope="glibc-vr">
     <primary>B1800</primary>
    </indexterm>
    <indexterm scope="glibc-vr">
     <primary>B2400</primary>
    </indexterm>
    <indexterm scope="glibc-vr">
     <primary>B4800</primary>
    </indexterm>
    <indexterm scope="glibc-vr">
     <primary>B9600</primary>
    </indexterm>
    <indexterm scope="glibc-vr">
     <primary>B19200</primary>
    </indexterm>
    <indexterm scope="glibc-vr">
     <primary>B38400</primary>
    </indexterm>
    <indexterm scope="glibc-vr">
     <primary>B57600</primary>
    </indexterm>
    <indexterm scope="glibc-vr">
     <primary>B115200</primary>
    </indexterm>
    <indexterm scope="glibc-vr">
     <primary>B230400</primary>
    </indexterm>
    <indexterm scope="glibc-vr">
     <primary>B460800</primary>
    </indexterm>
    <screen>
B0  B50  B75  B110  B134  B150  B200
B300  B600  B1200  B1800  B2400  B4800
B9600  B19200  B38400  B57600  B115200
B230400  B460800
</screen>
   </para>
   <para><indexterm scope="glibc-vr"><primary>EXTA</primary></indexterm><indexterm scope="glibc-vr"><primary>EXTB</primary></indexterm>
BSD bunlara ek olarak iki hız sembolünü takma ad olarak tanımlar: <command>EXTA</command> sembolü <command>B19200</command> için, <command>EXTB</command> sembolü de <command>B38400</command> için bir takma addır. Bu semboller atıl olmuştur.
    </para>
  </section>
  <section xml:id="glibc-Special-Characters">
   <info>
    <title>Özel Karakterler</title>
    <titleabbrev>Özel etkileri olan karakterler ve değiştirilmeleri.</titleabbrev>
   </info>
   <para>
Kurallı girdi kipinde uçbirim sürücüsü çeşitli denetim işlevlerini yerine getiren bir miktar özel karakter tanır. Bunlar ERASE (<keycap>DEL</keycap> tuşu) karakterinin de dahil olduğu metin düzenleme karakterleridir. <command>SIGINT</command> sinyalini gönderen INTR karakteri (normalde <command>C-c</command>) ve sinyal gönderen diğer karakterler hem kurallı hem de kuralsız kipte kullanılabilirler. Bu karakterlerin hepsi bu bölümde açıklanmıştır.
    </para>
   <para>
Kullanılacak karakterler <command>struct termios</command> yapısının <command>c_cc</command> üyesinde belirtilir. Bu üye bir dizidir; her eleman belli bir rol için bir karakter belirtir. Her eleman için elemanın indisini belirten bir sembolik sabit tanımlanmıştır. Örneğin, <command>VINTR</command> sembolü INTR karakterini belirten elemanın indisidir; <varname>termios</varname><literal>.c_cc[VINTR]</literal> içinde <command>'='</command> karakteri saklanmışsa INTR karakteri <command>'='</command> karakteri olur.
    </para>
   <para><indexterm scope="glibc-vr"><primary sortas="POSIX_VDISABLE">_POSIX_VDISABLE</primary></indexterm>
Bazı sistemlerde, özel bir karakterin işlevini, bu rol için <command>_POSIX_VDISABLE</command> değerini belirterek iptal edebilirsiniz. Bu değer herhangi bir karakter kodunun karşılığı değildir. Kullandığınız işletim sisteminin <command>_POSIX_VDISABLE</command> desteği olup olmadığının nasıl belirtildiği ile ilgili bilgileri <xref linkend="glibc-Options-for-Files"/> bölümünde bulabilirsiniz.
    </para>
   <section xml:id="glibc-Editing-Characters">
    <info>
     <title>Girdi Düzenleme Karakterleri</title>
     <titleabbrev>Satırları sonlandırma, metinleri silme ve benzeri düzenleme işlemleri ile ilgili özel karakterler.</titleabbrev>
    </info>
    <para>
Bu özel karakterler sadece kurallı girdi kipinde etkindir. Bkz. <xref linkend="glibc-Canonical-or-Not"/>.
     </para>
    <para xml:id="glibc-VEOF">
     <indexterm scope="glibc-vr">
      <primary>VEOF</primary>
     </indexterm>
     <indexterm scope="glibc-cp">
      <primary>EOF karakteri</primary>
     </indexterm>
     <funcsynopsis>
      <funcprototype role="makro">
       <funcdef>int <command>VEOF</command></funcdef>
       <paramdef/>
      </funcprototype>
      <funcdescr>
       <para>
Özel denetim karakterleri dizisinin dosyasonu (EOF) karakterini içeren elemanının indisidir.  Karakter <varname>termios</varname><literal>.c_cc[VEOF]</literal> içindedir.
     </para>
       <para>
Dosyasonu karakteri sadece kurallı girdi kipinde tanınır. Tıpkı satırsonu karakteri gibi bir satırı sonlandırmasına rağmen dosyasonu karakteri dosyadaki son satırın ilk ve son karakteridir. <command>read</command> ile yapılan okumada dosyasonunu belirrtmek üzere dönen karakter sayısı sıfır olur, dosyasonu karakterinin kendisi iptal edilir.
     </para>
       <para>
Genellikle dosyasonu karakteri <command>C-d</command> ile elde edilir.
</para>
      </funcdescr>
     </funcsynopsis>
    </para>
    <para xml:id="glibc-VEOL">
     <indexterm scope="glibc-vr">
      <primary>VEOL</primary>
     </indexterm>
     <indexterm scope="glibc-cp">
      <primary>EOL karakteri</primary>
     </indexterm>
     <funcsynopsis>
      <funcprototype role="makro">
       <funcdef>int <command>VEOL</command></funcdef>
       <paramdef/>
      </funcprototype>
      <funcdescr>
       <para>
Özel denetim karakterleri dizisinin satırsonu (EOL) karakterini içeren elemanının indisidir.  Karakter <varname>termios</varname><literal>.c_cc[VEOL]</literal> içindedir.
     </para>
       <para>
EOL karakteri sadece kurallı girdi kipinde tanınır. Tıpkı satırsonu karakteri gibi bir satırı sonlandırmakta kullanılır. EOL karakteri iptal edilmez, girdi satırındaki son karakter olarak okunur.
     </para>
       <para>
Satır sonunda <keycap>RET</keycap> tuşuna basarak EOL karakterini kullanmaya ihtiyaç yoktur. ICRNL seçeneğinin etkin olması yeterlidir. Aslında bu öntanımlı sistem işlerindendir.
</para>
      </funcdescr>
     </funcsynopsis>
    </para>
    <para xml:id="glibc-VEOL2">
     <indexterm scope="glibc-vr">
      <primary>VEOL2</primary>
     </indexterm>
     <indexterm scope="glibc-cp">
      <primary>EOL2 karakteri</primary>
     </indexterm>
     <funcsynopsis>
      <funcprototype role="makro">
       <funcdef>int <command>VEOL2</command></funcdef>
       <paramdef/>
      </funcprototype>
      <funcdescr>
       <para>
Özel denetim karakterleri dizisinin ikincil satırsonu (EOL2) karakterini içeren elemanının indisidir.  Karakter <varname>termios</varname><literal>.c_cc[VEOL2]</literal> içindedir.
     </para>
       <para>
EOL2 karakteri  EOL karakter (yukarıda) gibidir, ama farklı bir karakterdir. Bu bir satırı sonlandırmak için iki karakter gerektiği durumda belirtilebilir. Birini EOL diğerini EOL2 karakteri olarak belirtebilirsiniz.
     </para>
       <para>
EOL2 karakteri bir BSD oluşumudur; sadece BSD sistemleri ile GNU sisteminde vardır.
</para>
      </funcdescr>
     </funcsynopsis>
    </para>
    <para xml:id="glibc-VERASE">
     <indexterm scope="glibc-vr">
      <primary>VERASE</primary>
     </indexterm>
     <indexterm scope="glibc-cp">
      <primary>ERASE karakteri</primary>
     </indexterm>
     <funcsynopsis>
      <funcprototype role="makro">
       <funcdef>int <command>VERASE</command></funcdef>
       <paramdef/>
      </funcprototype>
      <funcdescr>
       <para>
Özel denetim karakterleri dizisinin silme (ERASE) karakterini içeren elemanının indisidir.  Karakter <varname>termios</varname><literal>.c_cc[VERASE]</literal> içindedir.
     </para>
       <para>
ERASE karakteri sadece kurallı girdi kipinde tanınır.  Kullanıcı silme karakterini tuşladığında önceki karakter silinir. (Uçbirim çokbaytlı karakterler üretiyorsa girdide birden fazla bayt silinebilir.) Bu karakter satırın başına kadar silme yapan karakter olarak kullanılamaz. Karakterin kendisi girdide iptal edilir.
     </para>
       <para>
Genellikle ERASE karakteri <keycap>DEL</keycap> ile elde edilir.
</para>
      </funcdescr>
     </funcsynopsis>
    </para>
    <para xml:id="glibc-VWERASE">
     <indexterm scope="glibc-vr">
      <primary>VWERASE</primary>
     </indexterm>
     <indexterm scope="glibc-cp">
      <primary>WERASE karakteri</primary>
     </indexterm>
     <funcsynopsis>
      <funcprototype role="makro">
       <funcdef>int <command>VWERASE</command></funcdef>
       <paramdef/>
      </funcprototype>
      <funcdescr>
       <para>
Özel denetim karakterleri dizisinin sözcük silme (WERASE) karakterini içeren elemanının indisidir.  Karakter <varname>termios</varname><literal>.c_cc[VWERASE]</literal> içindedir.
     </para>
       <para>
WERASE karakteri sadece kurallı girdi kipinde tanınır.  Kullanıcı bu karakteri tuşladığında önceki sözcük ve sonraki boşluklar silinir; sözcükten önceki boşluklara dokunulmaz.
     </para>
       <para>
"Sözcük" (word) tanımı <command>ALTWERASE</command> kipine bağımlıdır. Bkz. <xref linkend="glibc-Local-Modes"/>.
     </para>
       <para><command>ALTWERASE</command> kipi etkin değilse bir sözcük boşluk ve sekmeleri içeremez.
     </para>
       <para><command>ALTWERASE</command> kipi etkinse, bir sözcük harfleri rakamlar ve altçizgi karakterlerinden oluşabilir ve isteğe bağlı olarak harf, rakam veya altçizgi olmayan bir karakterle bitebilir.
     </para>
       <para>
Genellikle WERASE karakteri <command>C-w</command> ile elde edilir.
     </para>
       <para>
Bu bir BSD oluşumudur.
</para>
      </funcdescr>
     </funcsynopsis>
    </para>
    <para xml:id="glibc-VKILL">
     <indexterm scope="glibc-vr">
      <primary>VKILL</primary>
     </indexterm>
     <indexterm scope="glibc-cp">
      <primary>KILL karakteri</primary>
     </indexterm>
     <funcsynopsis>
      <funcprototype role="makro">
       <funcdef>int <command>VKILL</command></funcdef>
       <paramdef/>
      </funcprototype>
      <funcdescr>
       <para>
Özel denetim karakterleri dizisinin KILL karakterini içeren elemanının indisidir.  Karakter <varname>termios</varname><literal>.c_cc[VKILL]</literal> içindedir.
     </para>
       <para>
KILL (satır silme) karakteri sadece kurallı girdi kipinde tanınır.  Kullanıcı KILL karakterini tuşladığında etkin satırın tamamı silinir. Bu arada KILL karakterinin kendisi de silinir.
     </para>
       <para>
Genellikle KILL karakteri <command>C-u</command> ile elde edilir.
</para>
      </funcdescr>
     </funcsynopsis>
    </para>
    <para xml:id="glibc-VREPRINT">
     <indexterm scope="glibc-vr">
      <primary>VREPRINT</primary>
     </indexterm>
     <indexterm scope="glibc-cp">
      <primary>REPRINT karakteri</primary>
     </indexterm>
     <funcsynopsis>
      <funcprototype role="makro">
       <funcdef>int <command>VREPRINT</command></funcdef>
       <paramdef/>
      </funcprototype>
      <funcdescr>
       <para>
Özel denetim karakterleri dizisinin REPRINT karakterini içeren elemanının indisidir.  Karakter <varname>termios</varname><literal>.c_cc[VREPRINT]</literal> içindedir.
     </para>
       <para>
REPRINT karakteri sadece kurallı girdi kipinde tanınır.  O anki girdi satırının tekrarlanmasını sağlar. Bu karakteri tuşlarken bir yandan da eşzamansız çıktı geliyorsa bu karakter yazdığınız satırı temiz olarak yeniden görmenizi sağlar.
     </para>
       <para>
Genellikle REPRINT karakteri <command>C-r</command> ile elde edilir.
     </para>
       <para>
Bu bir BSD oluşumudur.
      </para>
      </funcdescr>
     </funcsynopsis>
    </para>
   </section>
   <section xml:id="glibc-Signal-Characters">
    <info>
     <title>Sinyal Gönderen Karakterler</title>
     <titleabbrev>Sinyallerin gönderilmesine sebep olan özel karakterler.</titleabbrev>
    </info>
    <para>
Bu özel karakterler hem kurallı hem de kuralsız girdi kipinde etkin olabilir ancak sadece <command>ISIG</command> seçeneği etkinse bu mümkündür (Bkz. <xref linkend="glibc-Local-Modes"/>).
     </para>
    <para xml:id="glibc-VINTR">
     <indexterm scope="glibc-vr">
      <primary>VINTR</primary>
     </indexterm>
     <indexterm scope="glibc-cp">
      <primary>INTR karakteri</primary>
     </indexterm>
     <indexterm scope="glibc-cp">
      <primary>durdurma karakteri</primary>
     </indexterm>
     <funcsynopsis>
      <funcprototype role="makro">
       <funcdef>int <command>VINTR</command></funcdef>
       <paramdef/>
      </funcprototype>
      <funcdescr>
       <para>
Özel denetim karakterleri dizisinin INTR karakterini içeren elemanının indisidir.  Karakter <varname>termios</varname><literal>.c_cc[VINTR]</literal> içindedir.
     </para>
       <para>
INTR (interrupt - kesme) karakteri, uçbirimle ilişkili önalan işindeki tüm süreçler için <command>SIGINT</command> sinyalinin yayınlanmasına sebep olur. Bu arada INTR karakterinin kendisi silinir. Sinyaller ile ilgili daha fazla bilgi için <xref linkend="glibc-Signal-Handling"/> bölümüne bakınız.
     </para>
       <para>
Genellikle INTR karakteri <command>C-c</command> ile elde edilir.
</para>
      </funcdescr>
     </funcsynopsis>
    </para>
    <para xml:id="glibc-VQUIT">
     <indexterm scope="glibc-vr">
      <primary>VQUIT</primary>
     </indexterm>
     <indexterm scope="glibc-cp">
      <primary>QUIT karakteri</primary>
     </indexterm>
     <funcsynopsis>
      <funcprototype role="makro">
       <funcdef>int <command>VQUIT</command></funcdef>
       <paramdef/>
      </funcprototype>
      <funcdescr>
       <para>
Özel denetim karakterleri dizisinin QUIT karakterini içeren elemanının indisidir.  Karakter <varname>termios</varname><literal>.c_cc[VQUIT]</literal> içindedir.
     </para>
       <para>
QUIT karakteri, uçbirimle ilişkili önalan işindeki tüm süreçler için <command>SIGQUIT</command> sinyalinin yayınlanmasına sebep olur. Bu arada QUIT karakterinin kendisi silinir. Sinyaller ile ilgili daha fazla bilgi için <xref linkend="glibc-Signal-Handling"/> bölümüne bakınız.
     </para>
       <para>
Genellikle QUIT karakteri <command>C-\</command> ile elde edilir.
</para>
      </funcdescr>
     </funcsynopsis>
    </para>
    <para xml:id="glibc-VSUSP">
     <indexterm scope="glibc-vr">
      <primary>VSUSP</primary>
     </indexterm>
     <indexterm scope="glibc-cp">
      <primary>SUSP karakter</primary>
     </indexterm>
     <indexterm scope="glibc-cp">
      <primary>bekletme karakteri</primary>
     </indexterm>
     <funcsynopsis>
      <funcprototype role="makro">
       <funcdef>int <command>VSUSP</command></funcdef>
       <paramdef/>
      </funcprototype>
      <funcdescr>
       <para>
Özel denetim karakterleri dizisinin SUSP karakterini içeren elemanının indisidir.  Karakter <varname>termios</varname><literal>.c_cc[VSUSP]</literal> içindedir.
     </para>
       <para>
SUSP (suspend - bekletme, askıya alma, süreci artalana atma) karakteri sadece gerçekleme <link linkend="glibc-Job-Control">iş denetimini</link> destekliyorsa tanınır. SUSP karakteri, uçbirimle ilişkili önalan işindeki tüm süreçler için <command>SIGTSTP</command> sinyalinin yayınlanmasına sebep olur. Bu arada SUSP karakterinin kendisi silinir. Sinyaller ile ilgili daha fazla bilgi için <xref linkend="glibc-Signal-Handling"/> bölümüne bakınız.
     </para>
       <para>
Genellikle SUSP karakteri <command>C-z</command> ile elde edilir.
        </para>
       <para>
Bazı uygulamalar SUSP karakterinin normal yorumunu iptal eder. Sizin yazılımınız da bunu yapıyorsa, kullanıcının işi durdurabilmesini sağlayacak mekanizmaları sağlamanız gerekir. Kullanıcı bu mekanizmayı devreye soktuğunda yazılım sadece kendi sürecine değil, süreç grubundaki tüm süreçlere <command>SIGTSTP</command> sinyalini göndermelidir (Bkz. <xref linkend="glibc-Signaling-Another-Process"/>).
</para>
      </funcdescr>
     </funcsynopsis>
    </para>
    <para xml:id="glibc-VDSUSP">
     <indexterm scope="glibc-vr">
      <primary>VDSUSP</primary>
     </indexterm>
     <indexterm scope="glibc-cp">
      <primary>DSUSP karakter</primary>
     </indexterm>
     <indexterm scope="glibc-cp">
      <primary>gecikmeli bekletme karakteri</primary>
     </indexterm>
     <funcsynopsis>
      <funcprototype role="makro">
       <funcdef>int <command>VDSUSP</command></funcdef>
       <paramdef/>
      </funcprototype>
      <funcdescr>
       <para>
Özel denetim karakterleri dizisinin DSUSP karakterini içeren elemanının indisidir.  Karakter <varname>termios</varname><literal>.c_cc[VDSUSP]</literal> içindedir.
     </para>
       <para>
DSUSP (suspend - bekletme, askıya alma, süreci artalana atma) karakteri sadece gerçekleme <link linkend="glibc-Job-Control">iş denetimini</link> destekliyorsa tanınır. SUSP karakteri gibi <command>SIGTSTP</command> sinyalini gönderir ama bunu doğrudan göndererek yapmaz, yazılım onu bir girdi olarak okumaya çalışıyorsa bu gerçekleşir. Bütün sistemlerin iş denetimleri DSUSP karakterini desteklemez; sadece BSD uyumlu sistemler ile GNU sisteminde desteklenir.
     </para>
       <para>
Sinyaller ile ilgili daha fazla bilgi için <xref linkend="glibc-Signal-Handling"/> bölümüne bakınız.
     </para>
       <para>
Genellikle DSUSP karakteri <command>C-y</command> ile elde edilir.
      </para>
      </funcdescr>
     </funcsynopsis>
    </para>
   </section>
   <section xml:id="glibc-Start-Stop-Characters">
    <info>
     <title>Akış Denetimi için Özel Karakterler</title>
     <titleabbrev>Çıktıyı bekleten veya sürdüren özel karakterler.</titleabbrev>
    </info>
    <para>
Bu karakterler hem kurallı hem de kuralsız girdi kipinde etkili olabilir, fakat kullanımları <command>IXON</command> ve <command>IXOFF</command> seçenekleri ile denetlenir (Bkz. <xref linkend="glibc-Input-Modes"/>).
     </para>
    <para xml:id="glibc-VSTART">
     <indexterm scope="glibc-vr">
      <primary>VSTART</primary>
     </indexterm>
     <indexterm scope="glibc-cp">
      <primary>START karakteri</primary>
     </indexterm>
     <funcsynopsis>
      <funcprototype role="makro">
       <funcdef>int <command>VSTART</command></funcdef>
       <paramdef/>
      </funcprototype>
      <funcdescr>
       <para>
Özel denetim karakterleri dizisinin START karakterini içeren elemanının indisidir.  Karakter <varname>termios</varname><literal>.c_cc[VSTART]</literal> içindedir.
     </para>
       <para>
START karakteri <command>IXON</command> ve <command>IXOFF</command> girdi kiplerini desteklemek için kullanılır. <command>IXON</command> varsa, START karakteri alındığında çıktı bekleme durumundan çıkarılır ve START karakterinin kendisi iptal edilir. <command>IXANY</command> varsa, herhangi bir karakter alındığında çıktı bekleme durumundan çıkarılır. <command>IXOFF</command> varsa, START karakterini sistem ayrıca uçbirime de iletebilir.
     </para>
       <para>
Genellikle START karakteri <command>C-q</command> ile elde edilir. Bu değeri değiştirmeniz mümkün değildir, çünkü donanım ne belirttiğinize bakmaksızın <command>C-q</command> kullanacağınızı varsayacakır.
</para>
      </funcdescr>
     </funcsynopsis>
    </para>
    <para xml:id="glibc-VSTOP">
     <indexterm scope="glibc-vr">
      <primary>VSTOP</primary>
     </indexterm>
     <indexterm scope="glibc-cp">
      <primary>STOP karakteri</primary>
     </indexterm>
     <funcsynopsis>
      <funcprototype role="makro">
       <funcdef>int <command>VSTOP</command></funcdef>
       <paramdef/>
      </funcprototype>
      <funcdescr>
       <para>
Özel denetim karakterleri dizisinin STOP karakterini içeren elemanının indisidir.  Karakter <varname>termios</varname><literal>.c_cc[VSTOP]</literal> içindedir.
     </para>
       <para>
STOP karakteri <command>IXON</command> ve <command>IXOFF</command> girdi kiplerini desteklemek için kullanılır. <command>IXON</command> varsa, bir STOP karakterinin alınması çıktının bekletilmesine sebep olur ve STOP karakteri iptal edilir. <command>IXOFF</command> varsa, sistem girdi kuyruğunun taşmasını önlemek için STOP karakterini uçbirime de iletir .
     </para>
       <para>
Genellikle STOP karakteri <command>C-s</command> ile elde edilir. Bu değeri değiştirmeniz mümkün değildir, çünkü donanım ne belirttiğinize bakmaksızın <command>C-s</command> kullanacağınızı varsayacakır.
      </para>
      </funcdescr>
     </funcsynopsis>
    </para>
   </section>
   <section xml:id="glibc-Other-Special">
    <info>
     <title>Diğer Özel Karakterler</title>
     <titleabbrev>BSD sistemlerindeki diğer özel karakterler: çıktılama ve yazdırmayı iptal edebilirler.</titleabbrev>
    </info>
    <para>
Bu özel karakterler sadece BSD sistemlerinde ve GNU sisteminde mevcuttur.
     </para>
    <para xml:id="glibc-VLNEXT">
     <indexterm scope="glibc-vr">
      <primary>VLNEXT</primary>
     </indexterm>
     <indexterm scope="glibc-cp">
      <primary>LNEXT karakteri</primary>
     </indexterm>
     <funcsynopsis>
      <funcprototype role="makro">
       <funcdef>int <command>VLNEXT</command></funcdef>
       <paramdef/>
      </funcprototype>
      <funcdescr>
       <para>
Özel denetim karakterleri dizisinin LNEXT karakterini içeren elemanının indisidir.  Karakter <varname>termios</varname><literal>.c_cc[VLNEXT]</literal> içindedir.
     </para>
       <para>
LNEXT karakteri hem kurallı hem de kuralsız girdi kipinde sadece <command>IEXTEN</command> seçeneği etkin olduğunda anlamlıdır. Kullanıcının bu karakterden sonra tuşladığı özel bir karakterin kıymeti harbiyesini yokeder. Karakter normalde bazı düzenleme işlemlerini yapma ya da sinyal gönderme yeteneğine sahip olsa bile sıradan bir karakter olarak okunur. Bu Emacs'ın <command>C-q</command> komutuna eşdeğerdir ve "LNEXT" "literal next" kısaltmasıdır.
     </para>
       <para>
Genellikle LNEXT karakteri <command>C-v</command> ile elde edilir.
</para>
      </funcdescr>
     </funcsynopsis>
    </para>
    <para xml:id="glibc-VDISCARD">
     <indexterm scope="glibc-vr">
      <primary>VDISCARD</primary>
     </indexterm>
     <indexterm scope="glibc-cp">
      <primary>DISCARD karakteri</primary>
     </indexterm>
     <funcsynopsis>
      <funcprototype role="makro">
       <funcdef>int <command>VDISCARD</command></funcdef>
       <paramdef/>
      </funcprototype>
      <funcdescr>
       <para>
Özel denetim karakterleri dizisinin DISCARD karakterini içeren elemanının indisidir.  Karakter <varname>termios</varname><literal>.c_cc[VDISCARD]</literal> içindedir.
     </para>
       <para>
DISCARD karakteri hem kurallı hem de kuralsız girdi kipinde sadece <command>IEXTEN</command> seçeneği etkin olduğunda anlamlıdır. Çıktı iptal seçeneğinin durumunu değiştirir. Seçenek varsa, tüm yazılım çıktısı iptal edilir. Seçeneğin varlığı ayrıca o an çıktı tamponundaki tüm çıktının iptal edilmesine sebep olur. Herhangi bir başka karakterin tuşlanması seçeneği sıfırlar.
</para>
      </funcdescr>
     </funcsynopsis>
    </para>
    <para xml:id="glibc-VSTATUS">
     <indexterm scope="glibc-vr">
      <primary>VSTATUS</primary>
     </indexterm>
     <indexterm scope="glibc-cp">
      <primary>STATUS karakteri</primary>
     </indexterm>
     <funcsynopsis>
      <funcprototype role="makro">
       <funcdef>int <command>VSTATUS</command></funcdef>
       <paramdef/>
      </funcprototype>
      <funcdescr>
       <para>
Özel denetim karakterleri dizisinin STATUS karakterini içeren elemanının indisidir.  Karakter <varname>termios</varname><literal>.c_cc[VSTATUS]</literal> içindedir.
     </para>
       <para>
STATUS karakterinin etkisi, çalışan süreç hakkında o anki durum iletisinin basılmasıdır.
     </para>
       <para>
STATUS karakteri sadece kurallı girdi kipinde ve sadece <command>NOKERNINFO</command> yoksa tanınır.
    </para>
      </funcdescr>
     </funcsynopsis>
    </para>
   </section>
  </section>
  <section xml:id="glibc-Noncanonical-Input">
   <info>
    <title>Kuralsız Girdi</title>
    <titleabbrev>Girdi için ne kadar bekleneceğinin denetlenmesi.</titleabbrev>
   </info>
   <para>
Kuralsız girdi kipinde ERASE ve KILL gibi metin düzenleme karakterleri yoksayılır. Kullanıcının girdiyi düzenleyebildiği sistem oluşumları kuralsız kipte iptal edilir. Sinyal gönderme ve akış denetimi hariç tüm girdi karakterleri uygulamaya oldukları gibi yazıldıkları şekilde aktarılırlar. Metin düzenleme ile ilgili girdilerin alınması gerekliyse bunlar yazılım içinde gerçeklenmelidir.
    </para>
   <para>
Kuralsız kipte kaç girdinin ne kadar süre bekleneceğini denetleyen MIN ve TIME parametreleri vardır. Bunları kullanarak girdi yapıldıkça hiç beklemeden girdileri hemen işleme sokabilirsiniz.
    </para>
   <para>
MIN ve TIME <command>struct termios</command> yapısının üyesi olan <command>c_cc</command> dizisinde saklanır. Bu dizinin her elemanı belli bir role sahiptir ve her elemana rolü ifade eden bir sembolik sabit indis olarak kullanılarak erişilir. MIN ve TIME için bu indisler <command>VMIN</command> ve <command>VMAX</command>'tır.
    </para>
   <para xml:id="glibc-VMIN">
    <indexterm scope="glibc-vr">
     <primary>VMIN</primary>
    </indexterm>
    <indexterm scope="glibc-cp">
     <primary>MIN termios değeri</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="makro">
      <funcdef>int <command>VMIN</command></funcdef>
      <paramdef/>
     </funcprototype>
     <funcdescr>
      <para><command>c_cc</command> dizisinin MIN değerini içeren elemanının indisidir.  Değer <varname>termios</varname><literal>.c_cc[VMIN]</literal> içindedir.
    </para>
      <para>
MIN değeri sadece kuralsız girdi kipinde anlamlıdır; girdi kuyruğundan <command>read</command> ile okuma yapabilmek için en az kaç karakter gerektiğini belirleyen bir sayıdır.
</para>
     </funcdescr>
    </funcsynopsis>
   </para>
   <para xml:id="glibc-VTIME">
int <command>VTIME</command>
<indexterm scope="glibc-vr"><primary>VTIME</primary></indexterm>
<indexterm scope="glibc-cp"><primary>TIME termios değeri</primary></indexterm>
<funcsynopsis><funcprototype role="makro"><funcdef>int <command>VTIME</command></funcdef><paramdef/></funcprototype><funcdescr><para><command>c_cc</command> dizisinin TIME değerini içeren elemanının indisidir.  Değer <varname>termios</varname><literal>.c_cc[VTIME]</literal> içindedir.
    </para><para>
TIME değeri sadece kuralsız girdi kipinde anlamlıdır; girdi kuyruğundan <command>read</command> ile okuma yapabilmek için ne kadar süreyle bekleme yapılacağını belirler; 0.1 saniyelik katları ifade eden bir tamsayı değerdir.
</para></funcdescr></funcsynopsis></para>
   <para>
MIN ve TIME değerleri <command>read</command> işlevinin değer döndürmesi için gerekli kriterleri oluşturur. Sıfır ve sıfırdan farklı değerler ayrıca anlamlıdır. Bu bakımdan dört olası durum vardır:
    </para>
   <itemizedlist>
    <listitem>
     <para>
TIME ve MIN, ikisi de sıfırdan farklı olabilir.
      </para>
     <para>
Bu durumda TIME, girdi yapılırken her girdi karakterinden sonra ne kadar süre bekleneceğini belirtir. İlk karakter alındıktan sonra MIN bayt alınıncaya kadar her karakter için TIME kadar süre beklenir, hangisi önce dolarsa <command>read</command> okunan karakterlerle döner.
      </para>
     <para><command>read</command> ilk karakter alınıncaya kadar TIME süresi dolsa bile daima bekler, ancak kuyrukta MIN karakterden fazlası varsa işlevden istenen karakter sayısına göre MIN karakterden fazlası dönebilir.
      </para>
    </listitem>
    <listitem>
     <para>
TIME ve MIN, ikisi de sıfır olabilir.
      </para>
     <para>
Bu durumda <command>read</command> kuyrukta kaç karakter varsa hepsini istek sayısı uzunlukta anında döndürür. Bir girdi yoksa <command>read</command> sıfır değeriyle döner.
      </para>
    </listitem>
    <listitem>
     <para>
MIN sıfır, TIME sıfırdan farklı olabilir.
      </para>
     <para>
Bu durumda, <command>read</command> ilk girdi için TIME kadar süreyle bekler ve kuyrukta kaç karakter varsa hepsini istek sayısı uzunlukta anında döndürür, bir girdi yoksa <command>read</command> sıfır değeriyle döner.
      </para>
    </listitem>
    <listitem>
     <para>
TIME sıfır, MIN sıfırdan farklı olabilir.
      </para>
     <para>
Bu durumda <command>read</command> kuyruğa MIN bayt yazılıncaya kadar bekler ve istenen sayıda karakterle döner. Eğer kuyrukta MIN karakterden fazla karakter varsa MIN karakterden fazlası ile dönebilir.
      </para>
    </listitem>
   </itemizedlist>
   <para>
MIN için 50 belirtirken işlevden 10 karakter okumasını istersek ne olacak? Normalde, <command>read</command> tamponda 50 karakter birikene kadar (ya da yukarıda açıklanan kurallar neyi gerektiriyorsa) bekler ve ilk 10 karakterle döner. Kalan 40 karakter sonraki <command>read</command> çağrıları ile okunmak üzere tamponda bırakılır.
    </para>
   <para>
    <note>
     <info>
      <title>Taşınabilirlik Bilgisi</title>
     </info>
     <para>Bazı sistemlerde  MIN ve TIME alanları EOF ve EOL alanları ile aynıdır. MIN ve TIME değerleri sadece kuralsız kipte anlamlı iken EOF ve EOL sadece kurallı kipte anlamlı olduğundan bu durum çeşitli sorunlara yol açar. GNU kütüphanesinde bu alanlar ayrıdır.</para>
    </note>
   </para>
   <para xml:id="glibc-cfmakeraw">
    <indexterm scope="glibc-fn">
     <primary>cfmakeraw</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="işlev">
      <funcdef>void <command>cfmakeraw</command></funcdef>
      <paramdef>(struct termios *<varname>termios-p</varname>)</paramdef>
     </funcprototype>
     <funcdescr>
      <para>
Bu işlev, uçbirimi BSD'de "temel kip" (raw mode) denilen kipe sokmak için kolay bir yol olarak kullanılır. Bu aslında bir kuralsız girdi kipidir ve uçbirimi çoğu işlem bakımından işlevsiz bir kanal haline getirir.
    </para>
      <para>
İşlev tam olarak şunları yapar:
    </para>
      <para>
       <screen><varname>termios-p</varname>-&gt;c_iflag &amp;= ~(IGNBRK|BRKINT|PARMRK|ISTRIP
                                |INLCR|IGNCR|ICRNL|IXON);
  <varname>termios-p</varname>-&gt;c_oflag &amp;= ~OPOST;
  <varname>termios-p</varname>-&gt;c_lflag &amp;= ~(ECHO|ECHONL|ICANON|ISIG|IEXTEN);
  <varname>termios-p</varname>-&gt;c_cflag &amp;= ~(CSIZE|PARENB);
  <varname>termios-p</varname>-&gt;c_cflag |= CS8;
</screen>
      </para>
     </funcdescr>
    </funcsynopsis>
   </para>
  </section>
 </chapter>
 <chapter xml:id="glibc-BSD-Terminal-Modes">
  <info>
   <title>BSD Uçbirim Kipleri</title>
   <titleabbrev>BSD uyumlu uçbirim kipleri ile ilgili ayarlar</titleabbrev>
  </info>
  <para><indexterm scope="glibc-cp"><primary>uçbirimler</primary><secondary>BSD kipleri</secondary></indexterm>
Uçbirim kiplerini okumak ve belirlemek için genelde <xref linkend="glibc-Terminal-Modes"/> bölümünde açıklanan işlevler yararlıdır. Bununla birlikte, bazı sistemlerde bazı şeyleri yapabilmek için bu bölümde anlatılan ve BSD sisteminden alınmış işlevleri kullanabilirsiniz. Çoğu sistemde bu işlevler mevcut değildir. Hatta GNU C kütüphanesinde bu işlevler, içlerinde Linux'un da bulunduğu çoğu çekirdek ile <command>errno</command> = <command>ENOSYS</command> hatasını vererek başarısız olacaktır.
   </para>
  <para>
Bu bölümde bahsedilen semboller <filename>sgtty.h</filename> başlık dosyasında bildirilmiştir.
   </para>
  <para xml:id="glibc-struct-sgttyb">
   <indexterm scope="glibc-tp">
    <primary sortas="sgttyb">struct sgttyb</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="veri türü">
     <funcdef>struct <command>sgttyb</command></funcdef>
     <paramdef/>
    </funcprototype>
    <funcdescr>
     <para>
Bu yapı <command>gtty</command> ve <command>stty</command> için girdi ve çıktı parametreleri listesidir.
   </para>
     <para>
      <glosslist>
       <glossentry>
        <glossterm>
         <literal>char <command>sg_ispeed</command></literal>
        </glossterm>
        <glossdef>
         <para>Girdi için hat hızı
   </para>
        </glossdef>
       </glossentry>
       <glossentry>
        <glossterm>
         <literal>char <command>sg_ospeed</command></literal>
        </glossterm>
        <glossdef>
         <para>Çıktı için hat hızı
   </para>
        </glossdef>
       </glossentry>
       <glossentry>
        <glossterm>
         <literal>char <command>sg_erase</command></literal>
        </glossterm>
        <glossdef>
         <para>Silme karakteri
   </para>
        </glossdef>
       </glossentry>
       <glossentry>
        <glossterm>
         <literal>char <command>sg_kill</command></literal>
        </glossterm>
        <glossdef>
         <para>Satır silme karakteri
   </para>
        </glossdef>
       </glossentry>
       <glossentry>
        <glossterm>
         <literal>int <command>sg_flags</command></literal>
        </glossterm>
        <glossdef>
         <para>Çeşitli seçenekler
   </para>
        </glossdef>
       </glossentry>
      </glosslist>
     </para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para xml:id="glibc-gtty">
   <indexterm scope="glibc-fn">
    <primary>gtty</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>int <command>gtty</command></funcdef>
     <paramdef>(int            <varname>dosyatanıtıcı</varname>,
 struct sgttyb *<varname>öznitelikler</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para>
Uçbirimin özniteliklerini okur.
   </para>
     <para><command>gtty</command> işlevi <varname>dosyatanıtıcı</varname> dosya tanıtıcısı ile açılan uçbirimin özniteliklerini <varname>*öznitelikler</varname> ile gösterilen yapı içinde döndürür.
</para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para xml:id="glibc-stty">
   <indexterm scope="glibc-fn">
    <primary>stty</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>int <command>stty</command></funcdef>
     <paramdef>(int            <varname>dosyatanıtıcı</varname>,
 struct sgttyb *<varname>öznitelikler</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para>
Uçbirimin özniteliklerini değiştirir.
   </para>
     <para><command>stty</command> işlevi <varname>dosyatanıtıcı</varname> dosya tanıtıcısı ile açılan uçbirimi <varname>*öznitelikler</varname> ile belirtilen özniteliklerle ayarlar.
  </para>
    </funcdescr>
   </funcsynopsis>
  </para>
 </chapter>
 <chapter xml:id="glibc-Line-Control">
  <info>
   <title>Hat Denetim İşlevleri</title>
   <titleabbrev>Geçici kesme gönderme, uçbirim tamponunu temizleme, v.s.</titleabbrev>
  </info>
  <para><indexterm scope="glibc-cp"><primary>uçbirimler</primary><secondary>hat denetim işlevleri</secondary></indexterm>
Bu işlevleri uçbirim aygıtı üzerinde çeşitli denetim eylemlerini gerçekleştirir. Uçbirim erişimi ile ilgili olarak, bunlar çıktıda şöyle birşeyler yapıyor gibi ele alınır: Bir artalan süreci kendi denetim uçbirimi üzerinde bu işlevlerden birini kullandığında, normalde süreç grubundaki tüm süreçler bir <command>SIGTTOU</command> sinyali gönderir. Çağıran süreç <command>SIGTTOU</command> sinyallerini engelliyor ya da yoksayıyorsa, bu durumda  işlem yine yapılır ama sinyal gönderilmez. Bkz.  <xref linkend="glibc-Job-Control"/>.
   </para>
  <para xml:id="glibc-tcsendbreak">
   <indexterm scope="glibc-cp">
    <primary>uçbirimler</primary>
    <secondary>geçici kesme durumu</secondary>
    <tertiary>üretimi</tertiary>
   </indexterm>
   <indexterm scope="glibc-fn">
    <primary>tcsendbreak</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>int <command>tcsendbreak</command></funcdef>
     <paramdef>(int <varname>dosyatanıtıcı</varname>,
 int <varname>süre</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para>
Bu işlev, <varname>dosyatanıtıcı</varname> dosya tanıtıcısı ile ilişkili uçbirim üzerinde sıfır bitlerinden oluşan bir akımı ileterek bir geçici kesme durumu (break condition)  oluşturur. Geçici kesme durumunu süresi <varname>süre</varname> argümanınca denetlenir. Sıfırsa süre 0.25 ile 0.5 saniye arasında olur. Bu, sıfırdan farklı değerlerin sisteme bağlı olduğu anlamına gelir.
   </para>
     <para>
Bu işlev, eğer uçbirim bir eşzamasız seri veri portu değilse hiçbir şey yapmaz.
   </para>
     <para>
Normalde dönüş değeri sıfırdır. Bir hata oluştuğunda -1 döner. Aşağıdaki <command>errno</command> hata durumları bu işlev için tanımlanmıştır:
   </para>
     <para>
      <variablelist>
       <varlistentry>
        <term>
         <literal>EBADF</literal>
        </term>
        <listitem>
         <para><varname>dosyatanıtıcı</varname> geçerli bir dosya tanıtıcı değil
      </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         <literal>ENOTTY</literal>
        </term>
        <listitem>
         <para><varname>dosyatanıtıcı</varname> bir uçbirimle ilişkili değil
      </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para xml:id="glibc-tcdrain">
   <indexterm scope="glibc-cp">
    <primary>uçbirimler</primary>
    <secondary>çıktı kuyruğunun boşaltılması</secondary>
   </indexterm>
   <indexterm scope="glibc-fn">
    <primary>tcdrain</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>int <command>tcdrain</command></funcdef>
     <paramdef>(int <varname>dosyatanıtıcı</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para><command>tcdrain</command> işlevi kuyruktaki çıktı <varname>dosyatanıtıcı</varname> uçbirimine iletilinceye kadar bekler.
   </para>
     <para>
Bu işlev çok evreli yazılımlarda bir iptal noktasıdır. <command>tcdrain</command> çağrısı sırasında evre bazı özkaynakları (bellek, dosya tanıtıcı, semafor, vb.) ayırdığında bu bir sorun olur. Evre tam bu anda bir iptal alırsa ayrılan özkaynaklar yazılım sonlanana kadar ayrılmış olarak kalır. Bu tür <command>tcdrain</command> çağrılarından kaçınmak için iptal eylemcileri kullanılarak korunulmalıdır.
   </para>
     <para>
Normalde dönüş değeri sıfırdır. Bir hata oluştuğunda -1 döner. Aşağıdaki <command>errno</command> hata durumları bu işlev için tanımlanmıştır:
   </para>
     <para>
      <variablelist>
       <varlistentry>
        <term>
         <literal>EBADF</literal>
        </term>
        <listitem>
         <para><varname>dosyatanıtıcı</varname> geçerli bir dosya tanıtıcı değil
      </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         <literal>ENOTTY</literal>
        </term>
        <listitem>
         <para><varname>dosyatanıtıcı</varname> bir uçbirimle ilişkili değil
      </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         <literal>EINTR</literal>
        </term>
        <listitem>
         <para>
İşlem bir sinyalle durduruldu. Bkz. <xref linkend="glibc-Interrupted-Primitives"/>.
      </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para xml:id="glibc-tcflush">
   <indexterm scope="glibc-cp">
    <primary>uçbirimler</primary>
    <secondary>girdi kuyruğunun temizlenmesi</secondary>
   </indexterm>
   <indexterm scope="glibc-fn">
    <primary>tcflush</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>int <command>tcflush</command></funcdef>
     <paramdef>(int <varname>dosyatanıtıcı</varname>,
 int <varname>kuyruk</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para><command>tcflush</command> işlevi <varname>dosyatanıtıcı</varname> dosya tanıtıcısı ile ilişkili uçbirimin girdi ya da çıktı kuyruğundaki veriyi temizlemek için kullanılır. <varname>kuyruk</varname> argümanı temizlenecek kuyruğu belirtmek için kullanılır ve şu değerlerden biri olabilir:
   </para>
     <para>
      <variablelist>
       <varlistentry>
        <term>
         <literal>TCIFLUSH</literal>
        </term>
        <listitem>
         <para><indexterm scope="glibc-vr"><primary>TCIFLUSH</primary></indexterm>
Alınmış ama henüz okunmamış veri temizlenir.
<indexterm scope="glibc-vr"><primary>TCOFLUSH</primary></indexterm>
   </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         <literal>TCOFLUSH</literal>
        </term>
        <listitem>
         <para>
Yazılmış ama henüz iletilmemiş veri temizlenir.
<indexterm scope="glibc-vr"><primary>TCIOFLUSH</primary></indexterm>
   </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         <literal>TCIOFLUSH</literal>
        </term>
        <listitem>
         <para>
Girdi ve çıktı kuyruklarının ikisi de temizlenir.
      </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>
     <para>
Normalde dönüş değeri sıfırdır. Bir hata oluştuğunda -1 döner. Aşağıdaki <command>errno</command> hata durumları bu işlev için tanımlanmıştır:
   </para>
     <para>
      <variablelist>
       <varlistentry>
        <term>
         <literal>EBADF</literal>
        </term>
        <listitem>
         <para><varname>dosyatanıtıcı</varname> geçerli bir dosya tanıtıcı değil
      </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         <literal>ENOTTY</literal>
        </term>
        <listitem>
         <para><varname>dosyatanıtıcı</varname> bir uçbirimle ilişkili değil
      </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         <literal>EINVAL</literal>
        </term>
        <listitem>
         <para><varname>kuyruk</varname> argümanı olarak belirtilen değer geçersiz
      </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>
     <para>
Bu işlevin ismine bakarak hatırlamak zor olacaktır, çünkü "flush" (boşaltma) işlemi normalde önceki işlev için kullanılır ve girdi ve çıktının iptal edimesi ile çelişir. <command>tcflush</command> işlevi POSIX standardında belirtildiğinden maalesef ismini değiştiremiyoruz.
</para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para xml:id="glibc-tcflow">
   <indexterm scope="glibc-cp">
    <primary>uçbirimler</primary>
    <secondary>akış denetimi</secondary>
   </indexterm>
   <indexterm scope="glibc-fn">
    <primary>tcflow</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>int <command>tcflow</command></funcdef>
     <paramdef>(int <varname>dosyatanıtıcı</varname>,
 int <varname>eylem</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para><command>tcflow</command> işlevi <varname>dosyatanıtıcı</varname> dosya tanıtıcısı ile ilişkili uçbirim üzerinde XON/XOFF akış denetimi ile ilgili işlemleri gerçekleştirmekte kullanılır.
   </para>
     <para><varname>eylem</varname> argümanı gerçekleştirilecek eylemi belirtmek için kullanılır ve aşağıdaki değerlerden biri olabilir:
   </para>
     <para>
      <variablelist>
       <varlistentry>
        <term>
         <literal>TCOOFF</literal>
        </term>
        <listitem>
         <para><indexterm scope="glibc-vr"><primary>TCOOFF</primary></indexterm>
Çıktı iletimi beklemeye alınır.
      </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         <literal>TCOON</literal>
        </term>
        <listitem>
         <para><indexterm scope="glibc-vr"><primary>TCOON</primary></indexterm>
Çıktı iletimi yeniden başlatılır.
      </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         <literal>TCIOFF</literal>
        </term>
        <listitem>
         <para><indexterm scope="glibc-vr"><primary>TCIOFF</primary></indexterm>
STOP karakteri iletilir.
      </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         <literal>TCION</literal>
        </term>
        <listitem>
         <para><indexterm scope="glibc-vr"><primary>TCION</primary></indexterm>
START karakteri iletilir.
      </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>
     <para>
STOP ve START karakterleri hakkında daha ayrıntılı bilgiyi <xref linkend="glibc-Special-Characters"/> bölümünde bulabilirsiniz.
   </para>
     <para>
Normalde dönüş değeri sıfırdır. Bir hata oluştuğunda -1 döner. Aşağıdaki <command>errno</command> hata durumları bu işlev için tanımlanmıştır:
   </para>
     <para>
      <variablelist>
       <varlistentry>
        <term>
         <literal>EBADF</literal>
        </term>
        <listitem>
         <para><indexterm scope="glibc-vr"><primary>EBADF</primary></indexterm><varname>dosyatanıtıcı</varname> geçerli bir dosya tanıtıcı değil
      </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         <literal>ENOTTY</literal>
        </term>
        <listitem>
         <para><indexterm scope="glibc-vr"><primary>ENOTTY</primary></indexterm><varname>dosyatanıtıcı</varname> bir uçbirimle ilişkili değil
      </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>
         <literal>EINVAL</literal>
        </term>
        <listitem>
         <para><indexterm scope="glibc-vr"><primary>EINVAL</primary></indexterm><varname>eylem</varname> argümanı ile belirtilen değer geçersiz
      </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>
    </funcdescr>
   </funcsynopsis>
  </para>
 </chapter>
 <chapter xml:id="glibc-Noncanon-Example">
  <info>
   <title>Kuralsız Kip Örneği</title>
   <titleabbrev>Uçbirimden tek bir karakter nasıl okunur.</titleabbrev>
  </info>
  <para>
Bu örnekte, kuralsız kipte tek bir karakteri bir uçbirimden okumak için ne yapılması gerektiği gösterilmiştir:
   </para>
  <para>
   <screen>#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;termios.h&gt;

/* Uçbirim özniteliklerini bir değişkende saklayalım. */

struct termios saved_attributes;

void
reset_input_mode (void)
{
  tcsetattr (STDIN_FILENO, TCSANOW, &amp;saved_attributes);
}

void
set_input_mode (void)
{
  struct termios tattr;
  char *name;

  /* stdin bir uçbirim mi. */
  if (!isatty (STDIN_FILENO))
    {
      fprintf (stderr, "Bir uçbirim değil.\n");
      exit (EXIT_FAILURE);
    }

  /* Uçbirim özniteliklerini daha sonra yerine koymak için saklayalım. */
  tcgetattr (STDIN_FILENO, &amp;saved_attributes);
  atexit (reset_input_mode);

  /* Şimdi uçbirimi kuralsız kipe sokalım.
     Girdinin tekrar yansılanmaması için yansılamayı da kapatacağız. */
  tcgetattr (STDIN_FILENO, &amp;tattr);
  tattr.c_lflag &amp;= ~(ICANON|ECHO); /* ICANON ve ECHO temizlendi. */
  tattr.c_cc[VMIN] = 1;                /* Girdi tek karakterlik okunsun. */
  tattr.c_cc[VTIME] = 0;               /* Okuma için beklenmesin. */
  tcsetattr (STDIN_FILENO, TCSAFLUSH, &amp;tattr);
}

int
main (void)
{
  char c;

  set_input_m
  char c;

  set_input_mode ();

  while (1)
    {
      read (STDIN_FILENO, &amp;c, 1);
      if (c == '\004')          /* C-d */
        break;
      else
        write (STDOUT_FILENO, &amp;c, 1);
    }

  return EXIT_SUCCESS;
}
</screen>
  </para>
  <para>
Bu yazılım, bir sinyalle sonlandırıldığında ya da çıkarken özgün uçbirim kiplerini tekrar yerine koyar. <command>exit</command> ile çıkılırken <command>atexit</command> işlevi ile bunu yapar (bkz. <xref linkend="glibc-Cleanups-on-Exit"/>).
   </para>
  <para>
Kabuğun süreç durdurulurken ve başlatılırken uçbirim kiplerini sıfırladığı varsayılmıştır; bkz. <xref linkend="glibc-Job-Control"/>.  Fakat bazı kabuklar bunu  yapmaz, bu durumda uçbirim kiplerini sıfırlamak için iş  denetim sinyallerine eylemci oluşturmanız gerekebilir.
   </para>
 </chapter>
 <chapter xml:id="glibc-Pseudo-Terminals">
  <info>
   <title>Uçbirimsiler</title>
   <titleabbrev>Bir uçbirimsi nasıl açılır.</titleabbrev>
  </info>
  <para><indexterm scope="glibc-cp"><primary>uçbirimsiler</primary></indexterm>
Bir <wordasword>uçbirimsi</wordasword> (pseudo terminal), bir uçbirim gibi davranan özel bir süreçlerarası iletişim kanalıdır. Kanalın bir ucu <firstterm>ana</firstterm> uç ya da <firstterm>ana uçbirimsi aygıt</firstterm> olarak adlandırılırken diğer uç <firstterm>yardımcı</firstterm> uç adını alır. Ana uca yazılan veri yardımcı uç tarafından sıradan bir uçbirime kullanıcı tarafından yazılmış gibi alınır ve yardımcı uca yazılan veri ana uca sıradan bir terminale yazılmış gibi gönderilir.
   </para>
  <para>
Uçbirimsiler genellikle <command>xterm</command> ve <command>emacs</command> gibi uygulamalar tarafından uçbirim benzetimi amacıyla kullanılırlar.
   </para>
  <section xml:id="glibc-Allocation">
   <info>
    <title>Uçbirimsilerin Ayrılması</title>
   </info>
   <para><indexterm scope="glibc-cp"><primary>allocating pseudo-terminals</primary></indexterm><indexterm scope="glibc-pg"><primary>stdlib.h</primary></indexterm>
Bu bölümde bir uçbirim ayırmak için kullanılan işlevlerden sözedilecektir. Bu işlevler <filename>stdlib.h</filename> başlık dosyasında bildirilmiştir.
    </para>
   <para xml:id="glibc-getpt">
    <indexterm scope="glibc-fn">
     <primary>getpt</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="işlev">
      <funcdef>int <command>getpt</command></funcdef>
      <paramdef>(void)</paramdef>
     </funcprototype>
     <funcdescr>
      <para><command>getpt</command> işlevi kullanılabilir ilk ana uçbirimsi için yeni bir dosya tanıtıcı ile döner. İşlevin normal dönüş değeri negatif olmayan bir tamsayı olarak dosya tanıtıcıdır. Bir hata oluşması durumunda -1 ile döner. Aşağıdaki <command>errno</command> hata durumları bu işlev için tanımlanmıştır:
    </para>
      <para>
       <variablelist>
        <varlistentry>
         <term>
          <literal>ENOENT</literal>
         </term>
         <listitem>
          <para>
Serbest bir ana uçbirimsi yok
       </para>
         </listitem>
        </varlistentry>
       </variablelist>
      </para>
      <para>
Bu işlev bir GNU oluşumudur.
</para>
     </funcdescr>
    </funcsynopsis>
   </para>
   <para xml:id="glibc-grantpt">
    <indexterm scope="glibc-fn">
     <primary>grantpt</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="işlev">
      <funcdef>int <command>grantpt</command></funcdef>
      <paramdef>(int <varname>dosyatanıtıcı</varname>)</paramdef>
     </funcprototype>
     <funcdescr>
      <para><command>grantpt</command> işlevi <varname>dosyatanıtıcı</varname> dosya tanıtıcısı ile ilişkili ana uçbirimsi aygıtının diğer ucu olan yardımcı uçbirimsinin sahipliğini ve erişim izinlerini değiştirir. Sahiplik, işlevi çağıran sürecin gerçek kullanıcı kimliği olur (bkz. <xref linkend="glibc-Process-Persona"/>). Erişim yetkileri ise sahibi tarafından yazılabilir/okunabilir ve sadece grubu tarafından okunabilir olarak ayarlanır.
    </para>
      <para>
Bazı sistemlerde bu işlev özel bir <command>setuid</command> root yazılım çağrılarak gerçeklenir (bkz. <xref linkend="glibc-How-Change-Persona"/>). Dolayısıyla, <command>SIGCHLD</command> sinyali için bir sinyal eylemci oluşturulması bir <command>grantpt</command> çağrısı ile çelişebilir (bkz. <xref linkend="glibc-Job-Control-Signals"/>).
    </para>
      <para>
İşlevin normal dönüş değeri sıfırdır. Bir hata oluşması durumunda -1 ile döner. Aşağıdaki <command>errno</command> hata durumları bu işlev için tanımlanmıştır:
    </para>
      <para>
       <variablelist>
        <varlistentry>
         <term>
          <literal>EBADF</literal>
         </term>
         <listitem>
          <para><varname>dosyatanıtıcı</varname> geçerli bir dosya tanıtıcı değil
       </para>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term>
          <literal>EINVAL</literal>
         </term>
         <listitem>
          <para><varname>dosyatanıtıcı</varname> bir ana uçbirimsi ile ilişkili değil
       </para>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term>
          <literal>EACCES</literal>
         </term>
         <listitem>
          <para><varname>dosyatanıtıcı</varname> ile ilişkili olan ana uçbirimsinin karşı ucu olan yardımcı uçbirimsiye erişilemiyor.
       </para>
         </listitem>
        </varlistentry>
       </variablelist>
      </para>
     </funcdescr>
    </funcsynopsis>
   </para>
   <para xml:id="glibc-unlockpt">
    <indexterm scope="glibc-fn">
     <primary>unlockpt</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="işlev">
      <funcdef>int <command>unlockpt</command></funcdef>
      <paramdef>(int <varname>dosyatanıtıcı</varname>)</paramdef>
     </funcprototype>
     <funcdescr>
      <para><command>unlockpt</command> işlevi <varname>dosyatanıtıcı</varname> dosya tanıtıcısı ile ilişkili ana uçbirimsi aygıtının diğer ucu olan yardımcı uçbirimsinin kilidini kaldırır. Bazı sistemlerde, yardımcı uçbirimsi sadece kilidi kaldırıldığında açılabilir, bu nedenle taşınabilir uygulamalar yardımcı uçbirimsiyi açarken daima bir <command>unlockpt</command> çağrısı yapmalıdır.
    </para>
      <para>
İşlevin normal dönüş değeri sıfırdır. Bir hata oluşması durumunda -1 ile döner. Aşağıdaki <command>errno</command> hata durumları bu işlev için tanımlanmıştır:
    </para>
      <para>
       <variablelist>
        <varlistentry>
         <term>
          <literal>EBADF</literal>
         </term>
         <listitem>
          <para><varname>dosyatanıtıcı</varname> geçerli bir dosya tanıtıcı değil
       </para>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term>
          <literal>EINVAL</literal>
         </term>
         <listitem>
          <para><varname>dosyatanıtıcı</varname> bir ana uçbirimsi ile ilişkili değil
       </para>
         </listitem>
        </varlistentry>
       </variablelist>
      </para>
     </funcdescr>
    </funcsynopsis>
   </para>
   <para xml:id="glibc-ptsname">
    <indexterm scope="glibc-fn">
     <primary>ptsname</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="işlev">
      <funcdef>char *<command>ptsname</command></funcdef>
      <paramdef>(int <varname>dosyatanıtıcı</varname>)</paramdef>
     </funcprototype>
     <funcdescr>
      <para><varname>dosyatanıtıcı</varname> dosya tanıtıcısı bir ana uçbirimsi aygıtı ile ilişkili ise, <command>ptsname</command> işlevi ilişkili yardımcı uçbirimsinin dosya ismini, boş karakter sonlandırmalı durağan ayrılmış bir dizgeye gösterici ile döndürür. Bu dizge daha sonraki <command>ptsname</command> çağrıları ile değişebilir.
</para>
     </funcdescr>
    </funcsynopsis>
   </para>
   <para xml:id="glibc-ptsname_r">
    <indexterm scope="glibc-fn">
     <primary>ptsname_r</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="işlev">
      <funcdef>int <command>ptsname_r</command></funcdef>
      <paramdef>(int    <varname>dosyatanıtıcı</varname>,
 char  *<varname>tampon</varname>,
 size_t <varname>uzunluk</varname>)</paramdef>
     </funcprototype>
     <funcdescr>
      <para><command>ptsname_r</command> işlevi <command>ptsname</command> işlevine benzemekle birlikte, sonucu kullanıcı tarafından belirtilen <varname>uzunluk</varname> uzunluktaki <varname>tampon</varname> içinde döndürmesi ile farklıdır.
    </para>
      <para>
Bu işlev bir GNU oluşumudur.
</para>
     </funcdescr>
    </funcsynopsis>
   </para>
   <para>
    <note>
     <info>
      <title>Taşınabilirlik Bilgisi</title>
     </info>
     <para>System V^den türetilmiş sistemlerde, <command>ptsname</command> ve <command>ptsname_r</command> işlevleri akım temelli olabilir ve bu nedenle onları açtıktan sonra, kullanmadan önce bir uçbirimsi olarak davranmaları için ek işlemler gerekebilir.</para>
    </note>
   </para>
   <para>
Bu işlevlerin genel kullanım biçimi örnekte gösterilmiştir:
    </para>
   <para>
    <screen>int
open_pty_pair (int *amaster, int *aslave)
{
  int master, slave;
  char *name;

  master = getpt ();
  if (master &lt; 0)
    return 0;

  if (grantpt (master) &lt; 0 || unlockpt (master) &lt; 0)
    goto close_master;
  name = ptsname (master);
  if (name == NULL)
    goto close_master;

  slave = open (name, O_RDWR);
  if (slave == -1)
    goto close_master;

  if (isastream (slave))
    {
      if (ioctl (slave, I_PUSH, "ptem") &lt; 0
          || ioctl (slave, I_PUSH, "ldterm") &lt; 0)
        goto close_slave;
    }

  *amaster = master;
  *aslave = slave;
  return 1;

close_slave:
  close (slave);

close_master:
  close (master);
  return 0;
}
</screen>
   </para>
  </section>
  <section xml:id="glibc-Pseudo-Terminal-Pairs">
   <info>
    <title>Bir Uçbirimsi Çiftinin Açılması</title>
   </info>
   <para><indexterm scope="glibc-cp"><primary>uçbirimsiler</primary><secondary>bir uçbirimsi çiftinin açılması</secondary></indexterm>
Bu işlevler BSD'den alınmıştır, ayrı bir kütüphane olarak <command>libutil</command> kütüphanesinde bulunur ve <filename>pty.h</filename> başlık dosyasında bildirilmişlerdir.
    </para>
   <para xml:id="glibc-openpty">
    <indexterm scope="glibc-fn">
     <primary>openpty</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="işlev">
      <funcdef>int <command>openpty</command></funcdef>
      <paramdef>(int            *<varname>ana</varname>,
 int            *<varname>yardımcı</varname>,
 char           *<varname>isim</varname>,
 struct termios *<varname>termp</varname>,
 struct winsize *<varname>winp</varname>)</paramdef>
     </funcprototype>
     <funcdescr>
      <para>
Bu işlev bir uçbirimsi çiftini ayırdıktan sonra açar ve ana uçbirimsinin dosya tanıtıcısını <varname>*ana</varname> göstericisinde, yardımcı uçbitimsinin dosya tanıtıcısını <varname>*yardımcı</varname> göstericisinde döndürür. <varname>isim</varname> argümanı bir boş gösterici değilse, yardımcı uçbirimsi aygıtının dosya ismi <varname>*isim</varname> içinde saklanır. <varname>termp</varname>  bir boş gösterici değilse, yardımcı uçbirimsinin uçbirim öznitelikleri <varname>termp</varname>  ile gösterilen yapıdan ayarlanır (bkz. <xref linkend="glibc-Terminal-Modes"/>). Benzer şekilde,  <varname>winp</varname> bir boş gösterici değilse, uçbirimsinin ekran boyutları <varname>winp</varname> ile gösterilen yapıdan ayarlanır.
    </para>
      <para>
İşlevin normal dönüş değeri sıfırdır. Bir hata oluşması durumunda -1 ile döner. Aşağıdaki <command>errno</command> hata durumları bu işlev için tanımlanmıştır:
    </para>
      <para>
       <variablelist>
        <varlistentry>
         <term>
          <literal>ENOENT</literal>
         </term>
         <listitem>
          <para>
Serbest uçbirimsi çifti yok
       </para>
         </listitem>
        </varlistentry>
       </variablelist>
      </para>
      <para>
       <warning>
        <para><command>openpty</command> işlevinin <varname>isim</varname> argümanının <command>NULL</command> olması <emphasis>çok tehlikelidir</emphasis>, çünkü işlev <varname>isim</varname> dizgesinin taşmasına karşı korunmamıştır.  Yardımcı uçbirimsi aygıtının ismini bulmak için işlevdeki argüman yerine <command>ttyname</command> işlevini <command>openpty</command> tarafından döndürülen <varname>*yardımcı</varname> dosya tanıtıcısı ile kullanmalısınız.</para>
       </warning>
      </para>
     </funcdescr>
    </funcsynopsis>
   </para>
   <para xml:id="glibc-forkpty">
    <indexterm scope="glibc-fn">
     <primary>forkpty</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="işlev">
      <funcdef>int <command>forkpty</command></funcdef>
      <paramdef>(int            *<varname>ana</varname>,
 char           *<varname>isim</varname>,
 struct termios *<varname>termp</varname>,
 struct winsize *<varname>winp</varname>)</paramdef>
     </funcprototype>
     <funcdescr>
      <para>
Bu işlev <command>openpty</command> işlevine benzer, ek olarak <link linkend="glibc-Creating-a-Process">yeni bir süreç çatallar</link> ve yeni açılan yardımcı uçbirimsi aygıtını <link linkend="glibc-Controlling-Terminal">alt sürecin denetim uçbirimi yapar</link>.
    </para>
      <para>
İşlem başarılı olursa hem çağıran hem de alt süreç işlevin döndüğünü görür fakat işlev farklı değerlerle döner: alt süreçte 0 değeriyle dönerken, çağıran sürece alt sürecin süreç kimliğini döndürür.
    </para>
      <para>
Uçbirimsi çifti ayrılamamışsa ya da alt süreç oluşturulamamışsa işlev başarısız olmuş demektir, bu durumda işlev çağrıldığı sürece -1 değerini döndürür.
    </para>
      <para>
       <warning>
        <para><command>forkpty</command> işlevinde de <command>openpty</command> gibi <varname>isim</varname> argümanı sorunu vardır.</para>
       </warning>
      </para>
     </funcdescr>
    </funcsynopsis>
   </para>
  </section>
 </chapter>
</part>
