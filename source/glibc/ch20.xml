<?xml version="1.0" encoding="UTF-8"?>

<!-- ********************************************************************
     $Id: ch20.xml,v 1.2 2002/12/20 22:29:48 nilgun Exp $
******************************************************************** -->
<part xml:id="glibc-Arithmetic">
  <title>Aritmetik İşlevleri</title>
  <titleabbrev>Düşük seviyeli aritmetik işlevleri.</titleabbrev>
  <partintro><para>
Bu kısımda, bir gerçek sayıyı tamsayı ve ondalık bileşenlerine ayırma, bir karmaşık sayının sanal bileşenini alma, vb. temel aritmetik işlemleri yapmak için kullanılan işlevlere yer verilmiştir. Bu işlevler <filename>math.h</filename> ve <filename>complex.h</filename> başlık dosyalarında bildirilmiştir.
  </para></partintro>
  <chapter xml:id="glibc-Integers">
    <title>Tamsayılar</title>
    <titleabbrev>Temel tamsayı türleri ve bunlarla ilgili kavramlar</titleabbrev>
    <para>
<indexterm scope="glibc-cp"><primary>sayılar</primary><secondary>tamsayı</secondary></indexterm>
C dilinde çeşitli tamsayı veri türleri tanımlanmıştır: tamsayı, küçük tamsayı, büyük tamsayı ve karakter; bunların her birinin işaretli ve işaretsiz türleri vardır. GNU C derleyici dili bunlara çok büyük tamsayıları da katarak kapsamı genişletir.
   </para><para>
<indexterm scope="glibc-cp"><primary>sayılar</primary><secondary>işaretlilik</secondary></indexterm>
C tamsayı türleri, yapısal bakımdan farklı veri genişliklerine (sözcük genişlikleri) sahip makineler arasında kodun taşınabilirliğini mümkün kılmak amacıyla tasarlanmıştır. Bu sorun, yazılımların hangi makinede çalışacağından bağımsız olarak, çoğunlukla belli tamsayı aralıklarına ihtiyaç duyacak şekilde, kimi zaman da belli bir saklama alanı gerektirecek şekilde geliştirilmesi gerekliliğinden kaynaklanır.
   </para><para>
Bu soruna yanıt olarak, GNU C kütüphanesi ihtiyaçlarınıza uygun olarak bildirebileceğiniz C tür tanımları içerir. Çünkü GNU C kütüphanesinin başlık dosyaları belli bir makineye özel duruma getirilebilir, böylece yazılımınızın kaynak kodunda bunları bulundurmak zorunda kalmazsınız.
   </para><para>
Bu tür tanımları, yani <command>typedef</command>'ler <filename>stdint.h</filename> başlık dosyasında bildirilmiştir.
<indexterm scope="glibc-pg"><primary>stdint.h</primary></indexterm>
   </para><para>
Tam olarak N bitlik genişliğe sahip bir tamsayıya ihtiyacınız varsa, bit sayısı bakımından belli genişliklere ve işaretliliğe sahip aşağıdaki türlerden size uygun olan birini kullanın:
   </para><para><itemizedlist>
     <listitem>int8_t
     </listitem><listitem>int16_t
     </listitem><listitem>int32_t
     </listitem><listitem>int64_t
     </listitem><listitem>uint8_t
     </listitem><listitem>uint16_t
     </listitem><listitem>uint32_t
     </listitem><listitem>uint64_t
     </listitem></itemizedlist>
   </para><para>
Eğer C derleyiciniz ya da hedef makine bu tamsayı genişliklerinden bazılarına izin vermiyorsa bunların eşdeğeri olan veri türleri bulunmayacaktır.
   </para><para>
Eğer, belirli bir saklama alanına ihtiyacınız varsa ama en küçük veri yapısının <emphasis>en azından</emphasis> (at least) N bitlik olmasını istiyorsanız bunlardan birini kullanın:
   </para><para><itemizedlist>
     <listitem>int_least8_t
     </listitem><listitem>int_least16_t
     </listitem><listitem>int_least32_t
     </listitem><listitem>int_least64_t
     </listitem><listitem>uint_least8_t
     </listitem><listitem>uint_least16_t
     </listitem><listitem>uint_least32_t
     </listitem><listitem>uint_least64_t
     </listitem></itemizedlist>
   </para><para>
Eğer belirli bir saklama alanından ziyade en azından N bitlik genişlik yanında en hızlı (fast) erişime sahip (ya da daha küçük olanı ile aynı erişim hızına sahip) veri yapılarına ihtiyacınız varsa bunlardan birini kullanın:
   </para><para><itemizedlist>
     <listitem>int_fast8_t
     </listitem><listitem>int_fast16_t
     </listitem><listitem>int_fast32_t
     </listitem><listitem>int_fast64_t
     </listitem><listitem>uint_fast8_t
     </listitem><listitem>uint_fast16_t
     </listitem><listitem>uint_fast32_t
     </listitem><listitem>uint_fast64_t
     </listitem></itemizedlist>
   </para><para>
Eğer, platformun destekleyebildiği en büyük tamsayı genişliğini istiyorsanız, aşağıdakilerden birini kullanın. Bunları kullandığınız takdirde yazılımınızdaki değişken boyutlarında ve tamsayı aralıklarında bunları hesaba katmalısınız.
   </para><para><itemizedlist>
     <listitem>intmax_t
     </listitem><listitem>uintmax_t
     </listitem></itemizedlist>
   </para><para>
GNU C kütüphanesi ayrıca, her tamsayı veri türü için olası asgari ve azami değerleri içeren makrolar içerir. Bu makro isimlerine bazı örnekler: <command>INT32_MAX</command>, <command>UINT8_MAX</command>, <command>INT_FAST32_MIN</command>, <command>INT_LEAST64_MIN</command>, <command>UINTMAX_MAX</command>, <command>INTMAX_MAX</command>, <command>INTMAX_MIN</command>.  İşaretsiz tamsayı türlerin olası en küçük değerleri daima sıfır olduğundan bunlar için makrolar tanımlanmamıştır.
   </para><para>
<indexterm scope="glibc-cp"><primary>sayılar</primary><secondary>olası en küçük tamsayı</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>sayılar</primary><secondary>olası en büyük tamsayı</secondary></indexterm>
C'nin yerleşik tamsayı türleri ile kullanmak için C derleyiciniz ile gelen benzer makrolar vardır. Bunlardan <xref linkend="glibc-Data-Type-Measurements"/> bölümünde bahsedilmiştir.
   </para><para>
Bu veri türlerinin saklandığı alanı bayt cinsinden öğrenmek için C'nin <command>sizeof</command> işlevini kullanabileceğinizi unutmayın.
   </para></chapter>
  <chapter xml:id="glibc-Integer-Division">
    <title>Tamsayı Bölme</title>
    <titleabbrev>Yuvarlatma yönünü bilerek tamsayılarla bölme.</titleabbrev>
    <para>
<indexterm scope="glibc-cp"><primary>sayılar</primary><secondary>tamsayı bölme işlevleri</secondary></indexterm>
Bu kısımda tamsayı bölme işlemleri yapan işlevlere yer verilmiştir. Bu işlevler GNU C derleyicisi kullanıldığında gereksizdir, çünkü GNU C <command>/</command> işleci daima sıfıra doğru yuvarlar (pozitif değerleri alta, negatif değerleri üste). Fakat diğer C gerçeklemeleri <command>/</command> işleci ile yapılan işlemleri negatif argümanlar kullanıldığında farklı yönlerde yuvarlarlar. Bu durumda, yuvarlama yönü belli (daima sıfıra doğru) olan <command>div</command> ve <command>ldiv</command> işlevleri kullanışlı olur. Bölme işleminden kalan bölünen ile aynı işaretlidir.
   </para><para>
Bu işlevler, <command><varname>r</varname>.quot * <varname>bölen</varname> + <varname>r</varname>.rem</command> eşittir <varname>bölünen</varname> (bölüm çarpı bölen artı kalan eşittir bölünen) şeklinde ifadesini bulan bir <varname>r</varname> değeri ile döner.
   </para><para>
<indexterm scope="glibc-pg"><primary>stdlib.h</primary></indexterm>
Bu oluşumları yazılımınızda kullanmak için <filename>stdlib.h</filename> başlık dosyasını yazılımınıza dahil etmelisiniz.
   </para><para>
<indexterm scope="glibc-tp"><primary>div_t</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü" xml:id="glibc-div_t">
<funcdef><command>div_t</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu yapı <command>div</command> işlevinden dönen sonucu tutan veri türüdür. Şu üyelere sahiptir:
   </para><para><glosslist><glossentry><glossterm>
   <literal>int <command>quot</command></literal>
   </glossterm><glossdef><para>Bölüm.
   </para></glossdef></glossentry><glossentry><glossterm>
   <literal>int <command>rem</command></literal>
   </glossterm><glossdef><para>Kalan.
   </para></glossdef></glossentry></glosslist>
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>div</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-div">
<funcdef>div_t <command>div</command></funcdef>
<paramdef>(int <varname>bölünen</varname>,
 int <varname>bölen</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>div</command> işlevi <varname>bölünen</varname>'ın <varname>bölen</varname>'e bölünmesinden kalanı ve bölümü <command>div_t</command> türündeki yapı içinde döndürür.
   </para><para>
Sonuç ifade edilemiyorsa (sıfırla bölme gibi) işlevin davranışı belirsizdir.
   </para><para>
Çok kullanışlı olmasa da bir örnek:
   </para><para>
<screen>div_t sonuc;
sonuc = div (20, -6);
</screen></para><para>
Burada <command>sonuc.quot</command> değeri <command>-3</command> ve <command>sonuc.rem</command> değeri <command>2</command>'dir.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-tp"><primary>ldiv_t</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü" xml:id="glibc-ldiv_t">
<funcdef><command>ldiv_t</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu yapı <command>ldiv</command> işlevinden dönen sonucu tutan veri türüdür. Şu üyelere sahiptir:
   </para><para><glosslist><glossentry><glossterm>
   <literal>long int <command>quot</command></literal>
   </glossterm><glossdef><para>Bölüm.
   </para></glossdef></glossentry><glossentry><glossterm>
   <literal>long int <command>rem</command></literal>
   </glossterm><glossdef><para>Kalan.
   </para></glossdef></glossentry></glosslist></para><para>
(Bu yapı elemanlarının <command>int</command> yerine <command>long int</command> türünde olması dışında <command>div_t</command> ile aynıdır.)
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>ldiv</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-ldiv">
<funcdef>ldiv_t <command>ldiv</command></funcdef>
<paramdef>(long int <varname>bölünen</varname>,
 long int <varname>bölen</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>ldiv</command> işlevi argümanlarının <command>long int</command> türünde olması ve sonucu <command>ldiv_t</command> türünde bir yapı içinde döndürmesi dışında <command>div</command> işlevinin benzeridir.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-tp"><primary>lldiv_t</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü" xml:id="glibc-lldiv_t">
<funcdef><command>lldiv_t</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu yapı <command>lldiv</command> işlevinden dönen sonucu tutan veri türüdür. Şu üyelere sahiptir:
   </para><para><glosslist><glossentry><glossterm>
   <literal>long long int <command>quot</command></literal>
   </glossterm><glossdef><para>Bölüm.
   </para></glossdef></glossentry><glossentry><glossterm>
   <literal>long long int <command>rem</command></literal>
   </glossterm><glossdef><para>Kalan.
   </para></glossdef></glossentry></glosslist></para><para>
(Bu yapı elemanlarının <command>int</command> yerine <command>long long int</command> türünde olması dışında <command>div_t</command> ile aynıdır.)
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>lldiv</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-lldiv">
<funcdef>lldiv_t <command>lldiv</command></funcdef>
<paramdef>(long long int <varname>bölünen</varname>,
 long long int <varname>bölen</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>lldiv</command> işlevi argümanlarının <command>long long int</command> türünde olması ve sonucu <command>lldiv_t</command> türünde bir yapı içinde döndürmesi dışında <command>div</command> işlevinin benzeridir.
   </para><para>
<command>lldiv</command> işlevi ISO C99 ile eklendi.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-tp"><primary>imaxdiv_t</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü" xml:id="glibc-imaxdiv_t">
<funcdef><command>imaxdiv_t</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu yapı <command>imaxdiv</command> işlevinden dönen sonucu tutan veri türüdür. Şu üyelere sahiptir:
   </para><para><glosslist><glossentry><glossterm>
   <literal>intmax_t <command>quot</command></literal>
   </glossterm><glossdef><para>Bölüm.
   </para></glossdef></glossentry><glossentry><glossterm>
   <literal>intmax_t <command>rem</command></literal>
   </glossterm><glossdef><para>Kalan.
   </para></glossdef></glossentry></glosslist></para><para>
(Bu yapı elemanlarının <command>int</command> yerine <command>intmax_t</command> türünde olması dışında <command>div_t</command> ile aynıdır.)
   </para><para>
<command>intmax_t</command> türü hakkında daha fazla bilgi için <xref linkend="glibc-Integers"/> bölümüne bakınız.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>imaxdiv</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-imaxdiv">
<funcdef>imaxdiv_t <command>imaxdiv</command></funcdef>
<paramdef>(intmax_t <varname>bölünen</varname>,
 intmax_t <varname>bölen</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>imaxdiv</command> işlevi argümanlarının <command>intmax_t</command> türünde olması ve sonucu <command>imaxdiv_t</command> türünde bir yapı içinde döndürmesi dışında <command>div</command> işlevinin benzeridir.
   </para><para>
<command>intmax_t</command> türü hakkında daha fazla bilgi için <xref linkend="glibc-Integers"/> bölümüne bakınız.
   </para><para>
<command>imaxdiv</command> işlevi ISO C99 ile eklendi.
  </para></funcdescr></funcsynopsis></para></chapter>
  <chapter xml:id="glibc-Floating-Point-Numbers">
    <title>Gerçek Sayılar</title>
    <titleabbrev>Nam-ı diğer kayan noktalı sayılar. IEEE 754.</titleabbrev>
    <para>
<indexterm scope="glibc-cp"><primary>sayılar</primary><secondary>kayan noktalı</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>IEEE 754</primary></indexterm>
<indexterm scope="glibc-cp"><primary>sayılar</primary><secondary>IEEE kayan noktalı</secondary></indexterm>
Çoğu bilgisayar donanımı iki çeşit sayıyı destekler: tamsayılar (…-3, -2, -1, 0, 1, 2, 3…) ve gerçek sayılar. Bir gerçek sayı üç parçadan oluşur: <wordasword>ondalık kısım</wordasword> (İng: mantissa),  <wordasword>üstel kısım</wordasword> (İng: exponent) ve <wordasword>işaret biti</wordasword> (İng: sign bit). Bir gerçek sayı <literal>(s ? -1 : 1) * 2^e * M</literal> ifadesiyle belirtilen bir kayan noktalı sayı ile ifade edilir (ifadedeki <literal>s</literal> işaret biti, <literal>e</literal> üstel kısım, <literal>M</literal> ise ondalık kısımdır). Daha ayrıntılı bilgi için <xref linkend="glibc-Floating-Point-Concepts"/> bölümüne bakınız. (Üstel kısım için farklı <wordasword>taban</wordasword>lar mümkündür ama günümüzdeki hemen bütün donanımlar taban olarak 2 kullanır.)
   </para><para>
Kayan noktalı sayıların gerçek sayıların sonlu bir alt kümesi olduğundan bahsedilebilir. Bu alt küme çoğu amaç için yeterince genişken, bir gerçek sayının sadece ondalık kısmının ikilik tabanda sınırlı bir bitsel açılımından daha dar yer kaplayan rasyonel sayılar olarak ifade edilirler. Hatta 1/5 gibi basit bir bölmenin sonucu bile kayan noktalı olarak yaklaşık bir değer olarabilir.
   </para><para>
Matematiksel işlemler ve işlevler çoğunlukla gösterilemeyen değerler üretir. Bu değerler genellikle uygulamaya dönük olarak yeterli yaklaşıklıkta olur, fakat kimi zaman bu bile mümkün olmaz. Tarihsel olarak, hesaplama sonuçlarının yeterince hassas olmadığını söylemenin bir yolu yoktur. Günümüz bilgisayarlarında sayısal hesaplamalar IEE 754 standardına uygun yapılır. Standart, hesaplama sonuçları güvenilir olmadığında yazılıma bunu belirten bir çerçeve tanımlar. Bu çerçeve sonucun neden gösterilemediğini belirten bir <wordasword>olağandışılıklar</wordasword> kümesinden oluşur. Bunlar <wordasword>sonsuzluk</wordasword> ve <wordasword>bir sayı değil</wordasword> (NaN -- Not a Number) gibi özel değerlerdir.
   </para></chapter>
  <chapter xml:id="glibc-Floating-Point-Classes">
    <title>Gerçek Sayı Sınıflama İşlevleri</title>
    <titleabbrev>Kayan noktalı sayıların beş çeşidi vardır.</titleabbrev>
    <para>
<indexterm scope="glibc-cp"><primary>sayılar</primary><secondary>kayan noktalı sınıflar</secondary></indexterm>
<indexterm scope="glibc-pg"><primary>math.h</primary></indexterm>
ISO C99 bir değişkendeki bir gerçek sayının çeşidini saptamanıza yardımcı olacak makrolar tanımlamıştır.
   </para><para>
<indexterm scope="glibc-fn"><primary>fpclassify</primary></indexterm>
<funcsynopsis><funcprototype role="makro" xml:id="glibc-fpclassify">
<funcdef>int <command>fpclassify</command></funcdef>
<paramdef>(<varname>float-type x</varname>)</paramdef>
</funcprototype><funcdescr><para>
Tüm gerçek sayı türleri ile çalışan ve <command>int</command> türünde bir değer ile dönen bir soysal makrodur. Olası dönüş değerleri:
   </para><para><variablelist><varlistentry>
   <term><literal>FP_NAN</literal></term><listitem><para>
<varname>x</varname> sayısı normal bir sayı değil. (Bkz. <xref linkend="glibc-Infinity-and-NaN"/>)
      </para></listitem></varlistentry><varlistentry>
      <term><literal>FP_INFINITE</literal></term><listitem><para>
<varname>x</varname> sayısı ya artı ya da eksi sonsuz. (Bkz. <xref linkend="glibc-Infinity-and-NaN"/>)
      </para></listitem></varlistentry><varlistentry>
      <term><literal>FP_ZERO</literal></term><listitem><para>
<varname>x</varname> sayısı sıfır. IEEE 754 benzeri kayan noktalı biçimlerde sıfırlar işaretli olabilir, dolayısıyla bu değer eksi sıfır için de döner.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>FP_SUBNORMAL</literal></term><listitem><para>
Mutlak değeri çok küçük olduğundan normal biçimde gösterilemeyen sayılar <wordasword>normalleştirilmemiş</wordasword> biçim denilen biçimde gösterilebilir (bkz. <xref linkend="glibc-Floating-Point-Concepts"/>).  Bu biçim pek hassas olmamakla birlikte sıfıra çok yakın değerleri gösterebilir. <command>fpclassify</command> işlevi bu diğer biçimle gösterilmekten başka çare olmayan <varname>x</varname> değerleri için bu makronun değerini döndürür.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>FP_NORMAL</literal></term><listitem><para>
<varname>x</varname> sayısına özel hiçbir durum olmadığını gösterir, yani sayı sıradan, normal bir sayıdır.
      </para></listitem></varlistentry></variablelist>
    </para><para>
<command>fpclassify</command> işlevi bir sayının birden fazla özelliği olması durumunda çok kullanışlıdır. Bir defada bir özelliği sınayan daha özel makrolar da vardır. Bunlar için özel donanım desteği olduğundan bu makrolar <command>fpclassify</command> işlevinden daha hızlıdırlar. Bu bakımdan, mümkün olduğunca bu özel makroları kullanmalısınız.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>isfinite</primary></indexterm>
<funcsynopsis><funcprototype role="makro" xml:id="glibc-isfinite">
<funcdef>int <command>isfinite</command></funcdef>
<paramdef>(<varname>bir-float-tür x</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu makro <varname>x</varname> değeri bir sonlu değerse sıfırdan farklı bir değerle döner (sonlu değer: eksi ya da artı sonsuz ve NaN olmayan). İşlem,
   </para><para>
<screen>(fpclassify (x) != FP_NAN &amp;&amp; fpclassify (x) != FP_INFINITE)</screen>
   </para><para>
ifadesine eşdeğerdir. <command>isfinite</command> herhangi bir gerçek sayı türünü kabul eden bir makro olarak gerçeklenmiştir.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>isnormal</primary></indexterm>
<funcsynopsis><funcprototype role="makro" xml:id="glibc-isnormal">
<funcdef>int <command>isnormal</command></funcdef>
<paramdef>(<varname>bir-float-tür x</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu makro <varname>x</varname> değeri bir sonlu ve normalleştirilmiş değerse sıfırdan farklı bir değerle döner. Eşdeğer ifade:
   </para><para>
<screen>(fpclassify (x) == FP_NORMAL)</screen>
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>isnan</primary></indexterm>
<funcsynopsis><funcprototype role="makro" xml:id="glibc-isnan">
<funcdef>int <command>isnan</command></funcdef>
<paramdef>(<varname>float-type x</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu makro <varname>x</varname> değeri normal bir sayı değilse (NaN ise) sıfırdan farklı bir değerle döner. Eşdeğer ifade:
   </para><para>
<screen>(fpclassify (x) == FP_NAN)</screen>
</para></funcdescr></funcsynopsis></para><para>
Gerçek sayı sınıflama işlevlerinin BSD sürümleri de vardır ve GNU C kütüphanesi bu işlevleri de destekler. Yine de yeni geliştireceğiniz yazılımlarda ISO C99 makrolarını kullanmanızı öneririz. Bunlar standarttır ve daha geniş çapta kullanılır olacaktır. Ayrıca, makro olduklarından argüman türleri bakımından endişelenmeniz gerekmez.
   </para><para>
<indexterm scope="glibc-fn"><primary>isinff</primary></indexterm>
<indexterm scope="glibc-fn"><primary>isinf</primary></indexterm>
<indexterm scope="glibc-fn"><primary>isinfl</primary></indexterm>
<funcsynopsis><funcdeflist role="işlev">
<funcprototype xml:id="glibc-isinf">
<funcdef>int <command>isinf</command></funcdef>
<paramdef>(double <varname>x</varname>)</paramdef>
</funcprototype><funcprototype xml:id="glibc-isinff">
<funcdef>int <command>isinff</command></funcdef>
<paramdef>(float <varname>x</varname>)</paramdef>
</funcprototype><funcprototype xml:id="glibc-isinfl">
<funcdef>int <command>isinfl</command></funcdef>
<paramdef>(long double <varname>x</varname>)</paramdef>
</funcprototype></funcdeflist><funcdescr><para>
Bu işlevler <varname>x</varname>'in değeri negatif sonsuz ise <command>-1</command> ile, positif sonsuz ise <command>1</command> ile aksi takdirde <command>0</command> ile döner.
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>isnan</primary></indexterm>
<indexterm scope="glibc-fn"><primary>isnanf</primary></indexterm>
<indexterm scope="glibc-fn"><primary>isnanl</primary></indexterm>
<funcsynopsis><funcdeflist role="işlev">
<funcprototype xml:id="glibc-func-isnan">
<funcdef>int <command>isnan</command></funcdef>
<paramdef>(double <varname>x</varname>)</paramdef>
</funcprototype><funcprototype xml:id="glibc-isnanf">
<funcdef>int <command>isnanf</command></funcdef>
<paramdef>(float <varname>x</varname>)</paramdef>
</funcprototype><funcprototype xml:id="glibc-isnanl">
<funcdef>int <command>isnanl</command></funcdef>
<paramdef>(long double <varname>x</varname>)</paramdef>
</funcprototype></funcdeflist><funcdescr><para>
Bu işlevler <varname>x</varname> bir sayı değilse (yani NaN ise), sıfırdan farklı bir değerle, aksi takdirde sıfır ile döner.
   </para><para>
<note><para>ISO C99 tarafından tanımlanan <command>isnan</command> makrosu BSD işlevinin yerine geçer. Bu durum normalde bir soruna yol açmaz çünkü bu ikisi birbirine eşdeğerdir. Buna rağmen, illaki BSD işlevine ihtiyacınız varsa şunu yazın:
   </para><para>
<screen>(isnan) (x)</screen></para></note>
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>finite</primary></indexterm>
<indexterm scope="glibc-fn"><primary>finitef</primary></indexterm>
<indexterm scope="glibc-fn"><primary>finitel</primary></indexterm>
<funcsynopsis><funcdeflist role="işlev">
<funcprototype xml:id="glibc-finite">
<funcdef>int <command>finite</command></funcdef>
<paramdef>(double <varname>x</varname>)</paramdef>
</funcprototype><funcprototype xml:id="glibc-finitef">
<funcdef>int <command>finitef</command></funcdef>
<paramdef>(float <varname>x</varname>)</paramdef>
</funcprototype><funcprototype xml:id="glibc-finitel">
<funcdef>int <command>finitel</command></funcdef>
<paramdef>(long double <varname>x</varname>)</paramdef>
</funcprototype></funcdeflist><funcdescr><para>
Bu işlevler <varname>x</varname> bir sayı değilse (yani NaN ise) ya da sonlu bir sayı ise, sıfırdan farklı bir değerle, aksi takdirde sıfır ile döner.
      </para><para>
<note><title>Taşınabilirlik Bilgisi</title><para>Bu bölümde listelenen işlevler BSD oluşumudur.</para></note>
  </para></funcdescr></funcsynopsis></para></chapter>
  <chapter xml:id="glibc-Floating-Point-Errors">
    <title>Gerçek Sayı Hesaplamalarında Hatalar</title>
    <titleabbrev>Hesaplama sırasında birşeyler yanlış gidebilir.</titleabbrev>
    <sect1 xml:id="glibc-FP-Exceptions">
      <title>Kayan Noktalı Sayı Olağandışılıkları</title>
      <titleabbrev>IEEE 754 matematiğinde olağandışılıklar ve saptanması.</titleabbrev>
      <para>
<indexterm scope="glibc-cp"><primary>sayılar</primary><secondary>olağandışılık</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>sayılar</primary><secondary>sinyaller</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>sayılar</primary><secondary>sıfırla bölme</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>sayılar</primary><secondary>geçersizlik</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>sayılar</primary><secondary>kesin olmama</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>sayılar</primary><secondary>üstten taşma</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>sayılar</primary><secondary>alttan taşma</secondary></indexterm>
IEEE 754 standardı hesaplama sırasında oluşan beş tane <wordasword>olağandışılık</wordasword> tanımlar. Her biri üstten taşma gibi belli başlı bir hataya karşılıktır.
    </para><para>
Olağandışılıklar oluştuğunda (standardın dilinde, olağandışılıklar <firstterm>ortaya çıktığında</firstterm>) iki şeyden biri olur. Öntanımlı olarak olağandışılık basitçe kayan noktalı <firstterm>durum sözcüğü</firstterm>ne kaydedilir ve yazılım hiçbir şey olmamış gibi çalışmaya devam eder. İşlem olağandışılığa bağlı bir öntanımlı değer üretir (aşağıdaki tabloya bakınız). Yazılımınız durum sözcüğüne bakarak hangi olağandışılığın oluştuğunu saptar.
    </para><para>
Bundan başka, olağandışılıklar için <firstterm>kapanları</firstterm> etkinleştirebilirsiniz. Bu durumda, bir olağandışılık ortaya çıktığında, yazılımınız <command>SIGFPE</command> sinyali alacaktır. Bu sinyalin öntanımlı eylemi yazılımın sonlanmasıdır. Sinyallerin etkilerinin nasıl değiştirildiği <xref linkend="glibc-Signal-Handling"/> bölümünde anlatılmıştır.
    </para><para>
<indexterm scope="glibc-fn"><primary>matherr</primary></indexterm>
System V matematik kütüphanesinde, kütüphane işlevleri içinde bu olağandışılıklardan bir oluştuğunda kullanıcı tanımlı <command>matherr</command> işlevi çağrılır. Ancak Unix98 standardı bu arayüzün kullanılmasını önermez. Bu işlevi geçmişe uyumluluk adına destekliyoruz, ama yeni yazılımlarda kullanmamanızı öneriyoruz.
    </para><para>
IEEE 754 standardında tanımlanan olağandışılıklar:
    </para><para><variablelist><varlistentry>
    <term>Geçersiz İşlem</term><listitem><para>
Belirtilen terimler uygulanacak işlem için geçersiz ise bu olağandışılık ortaya çıkar. Örnekler (IEEE 754, bölüm 7'ye bakın):
       </para><para><orderedlist numeration="arabic"><listitem>
Toplama ve çıkarma: <literal>oo - oo</literal>.  (ama <literal>oo + oo = oo</literal>).
         </listitem><listitem>
Çarpma: <literal>0 * oo</literal>.
         </listitem><listitem>
Bölme: <literal>0/0</literal> or <literal>oo/oo</literal>.
         </listitem><listitem>
Kalan: <literal>y</literal> sıfır ya da <literal>x</literal> sonsuz olduğunda <literal>x REM y</literal>.
         </listitem><listitem>
Karekök alma işleminde terim sıfırdan küçükse. Daha genel olarak kendi işlem sahası dışında işlem yapmaya zorlanan matematiksel işlevler bu olağandışılığı üretir.
         </listitem><listitem>
Gerçek sayıların tamsayıya ya da ondalık dizgeye dönüştürülmesinde sayı hedef biçimde gösterilemiyorsa (üstten taşma, sonsuzluk ya da NaN sebebiyle).
         </listitem><listitem>
Tanınamayan bir girdi dizgesinin dönüşümü.
         </listitem><listitem>
İlişkisel işleçlerle (&lt; veya >) yapılan karşılaştırmalarda, terimlerden birinin NaN olması. Bu işleçleri kullanmak yerine düzensiz karşılaştırma işlevlerini kullanarak bu olağandışılıktan kaçınabilirsiniz; bkz. <xref linkend="glibc-FP-Comparison-Functions"/>.
         </listitem></orderedlist>
       </para><para>
Olağandışılık yakalanmazsa işlemin sonucu NaN'dır.
       </para></listitem></varlistentry><varlistentry>
       <term>Sıfırla Bölme</term><listitem><para>
Bu olağandışılık sıfırdan farklı bir sonlu sayı sıfırla bölündüğünde ortaya çıkar. Bir yakalama gerçekleşmezse sonuç terimlerin işaretine bağlı olarak ya <literal>+oo</literal> ya da <literal>-oo</literal>'dur.
       </para></listitem></varlistentry><varlistentry>
       <term>Üstten Taşma</term><listitem><para>
Bu olağandışılık sonuç hedef hassasiyet biçiminde bir sonlu değer olarak gösterilemiyorsa ortaya çıkar. Bir yakalama gerçekleşmezse sonuç ara sonucun işaretine ve geçerli yuvarlama kipine bağlıdır (IEEE 754, bölüm 7.32e bakın):
       </para><para><orderedlist numeration="arabic"><listitem>
En yakın sayıya yuvarlama tüm üstten taşmaları ara sonucun işareti ile sonsuza taşır.
         </listitem><listitem>
Sıfıra yuvarlama tüm üstten taşmaları ara sonucun işareti ile gösterilebilir en büyük sonlu sayıya taşır.
         </listitem><listitem>
Eksi sonsuza yuvarlama pozitif üstten taşmaları gösterilebilir en büyük sonlu sayıya, negatif üstten taşmaları ise eksi sonsuza taşır.
         </listitem><listitem>
Sonsuza yuvarlama negatif üstten taşmaları gösterilebilir en negatif sonlu sayıya, pozitif üstten taşmaları ise sonsuza taşır.
         </listitem></orderedlist></para><para>
Her üstten taşma olağandışılığı ayrıca kesin olmama olağandışılığının ortaya çıkmasına sebep olur.
       </para></listitem></varlistentry><varlistentry>
       <term>Alttan Taşma</term><listitem><para>
Alttan taşma olağandışılığı bir ara sonuç tam olarak hesaplanmış olarak çok küçük olduğunda ya da hedefin hassasiyetine yuvarlama işleminin sonucu normalleştirilmiş olarak çok küçük olduğunda ortaya çıkar.
       </para><para>
Alttan taşma olağandışılığı için bir kapan kurulmadığında, alttan taşma sadece küçücüklük ve doğruluk kaybı birlikte saptandığında sinyallenir (alttan taşma bayrağı üzerinden). Bir sinyal eylemci kurulu değilse, işlem bir belirsiz küçük değer ile ya da hedefin hassasiyeti tam doğru küçük sonucu tutamayacaksa sıfır ile devam eder.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>Kesin Olmama</literal></term><listitem><para>
Bu olağandışılık eğer bir yuvarlanan sonuç kesin değilse (örneğin karekök iki hesaplanırken) ya da bir sonuç bir üstten taşma kapanı olmaksızın üstten taşarsa sinyallenir.
       </para></listitem></varlistentry></variablelist></para></sect1>
    <sect1 xml:id="glibc-Infinity-and-NaN">
      <title>Sonsuzluk ve NaN</title>
      <titleabbrev>Hesaplamalardan dönen özel değerler.</titleabbrev>
      <para>
<indexterm scope="glibc-cp"><primary>sayılar</primary><secondary>sonsuzluk</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>sayılar</primary><secondary>bir sayı olmama (NaN)</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>NaN</primary></indexterm>
IEEE 754 kayan noktalı sayıları ile pozitif ve negatif sonsuz sayılar ve sayı olmama durumu (NaN) gösterilebilir. Bu üç değer hesaplamalardaki sonuç tanımsızsa ya da tam doğru olarak gösterilemiyorsa ortaya çıkar. Ayrıca bunlardan birini bir gerçek sayı değişkenine enine boyuna düşünerek faydası olacaksa atayabilirsiniz. Sonsuzluk ve NaN üreten bazı hesaplama örnekleri:
    </para><para>
<screen>1/0 = oo
log (0) = -oo
sqrt (-1) = NaN
</screen></para><para>
Bir hesaplama bu değerlerden birini ürettiğinde ayrıca bir olağandışılık oluşur; bkz. <xref linkend="glibc-FP-Exceptions"/>.
    </para><para>
Temel işlemler ve matematik işlevlerinin hepsi sonsuzluk ve NaN değerlerini kabul ederler ve uygun bir çıktı üretirler. Sonsuzluğun hesaplamalarda kullanılışına örnekler: <literal>2 + oo = oo</literal>, <literal>4/oo = 0</literal>, <literal>atan (oo) = pi/2</literal>. Ancak, NaN bulaştığı bir hesaplamayı bozar.  Hesaplama aynı sonucu üretmedikçe sonucun NaN mı olduğu yoksa gerçek sonucun yerini NaN'ın mı aldığının bir önemi yoktur.
    </para><para>
Karşılaştırma işlemlerinde pozitif sonsuz, kendisi ve NaN hariç diğer tüm değerlerden büyüktür; negatif sonsuz ise kendisi ve NaN hariç diğer tüm değerlerden küçüktür. NaN sıradışıdır: kendisi dahil ne bir şeye eşittir, ne birşeyden küçük, ne de birşeyden büyüktür. <command>x == x</command> karşılaştırması değer NaN olduğunda yanlıştır. Bu durumu bir değerin NaN olup olmadığını sınamak için kullanabilirsiniz, ancak önerilen yöntem <command>isnan</command> işlevini kullanmaktır (bkz. <xref linkend="glibc-Floating-Point-Classes"/>). Ek olarak, NaN'lara uygulandığında <command>&lt;</command>, <command>></command>, <command>&lt;=</command> ve <command>>=</command> işleçleri bir olağandışılık ortaya çıkarırlar.
    </para><para>
Bir değişkene sonsuzluk veya NaN atamayı mümkün kılan makrolar <filename>math.h</filename> dosyasında tanımlanmıştır.
    </para><para>
<indexterm scope="glibc-vr"><primary>INFINITY</primary></indexterm>
<funcsynopsis><funcprototype role="makro" xml:id="glibc-INFINITY">
<funcdef>float <command>INFINITY</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Pozitif sonsuzu gösteren bir ifade. <command>1.0 / 0.0</command> gibi matematiksel bir işlemin sonucuna eşittir. Negatif sonsuz <command>-INFINITY</command>'dir.
    </para><para>
Bir gerçek sayının sonsuz olup olmadığını bu makro ile karşılaştırarak sınayabilirsiniz. Ancaki bu önerilmez; bunun yerine <command>isfinite</command> makrosunu kullanmalısınız; bkz. <xref linkend="glibc-Floating-Point-Classes"/>.
    </para><para>
Bu makro ISO C99 standardında tanıtıldı.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-vr"><primary>NAN</primary></indexterm>
<funcsynopsis><funcprototype role="makro" xml:id="glibc-NAN">
<funcdef>float <command>NAN</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Sayı olmayan bir değeri gösteren bir ifade. Bu makro bir GNU oluşumudur ve sadece IEEE kayan noktalı sayıları destekleyen tüm makinelerde desteklenir.
    </para><para>
Bir makinede NaN desteği olup olmadığını sınamak için <command>#ifdef NAN</command> kullanabilirsiniz. (Şüphesiz, <command>_GNU_SOURCE</command> tanımlayarak ve <filename>math.h</filename> başlık dosyasını yazılımınıza dahil ederek GNU oluşumlarının görünür olmasını sağlamalısınız.)
</para></funcdescr></funcsynopsis></para><para>
IEEE 754 ayrıca başka bir faydasız değeri mümkün kılar: negatif sıfır. Bu değer, bir pozitif sayıyı negatif sonsuza böldüğünüzde ya da bir negatif sonuç gösterim sınırından daha küçükse üretilir. Negatif sıfır, işaret bitini <command>signbit</command> veya <command>copysign</command> ile doğrudan sınamadıkça tüm hesaplamalarda sıfır gibi davranır.
    </para></sect1>
    <sect1 xml:id="glibc-Status-bit-operations">
      <title>Kayan Nokta Birimi Durum Sözcüğünün İncelenmesi</title>
      <titleabbrev>Ortaya çıktıktan sonra olağandışılıkların sınanması.</titleabbrev>
      <para>
ISO C99, kayan nokta durum sözcüğünün sorgulanması ve değiştirilmesi için işlevler tanımlamıştır. Yakalanmayan olağandışılıklar nedeniyle hesaplamanın ortasında endişelenmek yerine münasip bir zamanda bunları bu işlevleri kullanarak sınayabilirsiniz.
    </para><para>
Bu sabitler çeşitli IEEE 754 olağandışılıklarını gösterir. Tüm kayan nokta birimleri tüm olağandışılık çeşitlerini raporlamaz. Her sabit yalnız ve yalnız kayan nokta birimi ilgili olağandışılık desteği verilerek derlenmişse tanımlıdır. Kayan nokta birimi desteğini <command>#ifdef</command> ile sınayabilirsiniz. Bu sabitler <filename>fenv.h</filename> başlık dosyasında tanımlıdır..
    </para><para><variablelist><varlistentry>
    <term><literal>FE_INEXACT</literal></term><listitem><para>
Kesin olmama olağandışılığı.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>FE_DIVBYZERO</literal></term><listitem><para>
Sıfırla bölme olağandışılığı.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>FE_UNDERFLOW</literal></term><listitem><para>
Üstten taşma olağandışılığı.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>FE_OVERFLOW</literal></term><listitem><para>
Alttan taşma olağandışılığı.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>FE_INVALID</literal></term><listitem><para>
Geçersizlik olağandışılığı.
       </para></listitem></varlistentry></variablelist>
     </para><para>
<command>FE_ALL_EXCEPT</command> makrosu kayan nokta gerçeklemesi tarafından desteklenen tüm olağandışılık makrolarının bit seviyesinde VEYAlanmışıdır.
    </para><para>
Bu işlevler olağandışılık bayraklarını temizlenmesini, olağandışılıkların sınanmasını ve bayraklı olağandışılık kümesinin kaydedilmesini ve eski haline getirilmesini mümkün kılar.
    </para><para>
<indexterm scope="glibc-fn"><primary>feclearexcept</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-feclearexcept">
<funcdef>int <command>feclearexcept</command></funcdef>
<paramdef>(int <varname>olağandışılıklar</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev <varname>olağandışılıklar</varname> ile belirtilenlerden desteklenen tüm olağandışılık bayraklarını temizler.
    </para><para>
İşlev başarılı olduğunda sıfırla, aksi takdirde sıfırdan farklı bir değerle döner.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>feraiseexcept</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-feraiseexcept">
<funcdef>int <command>feraiseexcept</command></funcdef>
<paramdef>(int <varname>olağandışılıklar</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev <varname>olağandışılıklar</varname> ile belirtilenlerden desteklenen olağandışılıkları oluşturur. <varname>olağandışılıklar</varname> ile birden fazla olağandışılık biti belirtilmişse, üstten (<command>FE_OVERFLOW</command>) ya da alttan (<command>FE_UNDERFLOW</command>) taşmaların kesin olmama (<command>FE_INEXACT</command>) olağandışılığından önce ortaya çıkması dışında hangi olağandışılıkların oluşturulacağı tanımsızdır. Üstten veya alttan taşma için kesin olmama olağandışılığının ayrıca ortaya çıkıp çıkmayacağı ayrıca gerçeklemeye de bağlıdır.
    </para><para>
İşlev başarılı olduğunda sıfırla, aksi takdirde sıfırdan farklı bir değerle döner.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>fetestexcept</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-fetestexcept">
<funcdef>int <command>fetestexcept</command></funcdef>
<paramdef>(int <varname>olağandışılıklar</varname>)</paramdef>
</funcprototype><funcdescr><para>
<varname>olağandışılıklar</varname> parametresi ile belirtilen olağandışılık bayraklarının o an etkin olup olmadıklarını sınar. Bunlardan biri varsa, hangi olağandışılığın varolduğunu belirten sıfırdan farklı bir değerle döner. Aksi takdirde dönüş değeri sıfırdır.
</para></funcdescr></funcsynopsis></para><para>
Bu işlevlerin yaptığı işlemleri anlayabilmek için, durum sözcüğünün <varname>durum</varname> isimli bir tamsayı değişkeni olduğunu farzedelim. <command>feclearexcept</command> işlevi <command>durum &amp;= ~olağandışılıklar</command> ifadesine, <command>fetestexcept</command> işlevi ise <command>durum &amp; olağandışılıklar</command> ifadesine eşdeğerdir. Şüphesiz, asıl gerçekleme farklı olabilir.
    </para><para>
Olağandışılık bayrakları yazılım içinden sadece doğrudan <command>feclearexcept</command> çağrısı yapılarak temizlenebilir. Bir hesaplama sırasında oluşan olağandışılıklara bakmak isterseniz, önce bayrakların hepsini temizlemelisiniz. <command>fetestexcept</command> işlevinin kullanımına basit bir örnek:
    </para><para>
<screen>{
  double f;
  int raised;
  feclearexcept (FE_ALL_EXCEPT);
  f = compute ();
  raised = fetestexcept (FE_OVERFLOW | FE_INVALID);
  if (raised &amp; FE_OVERFLOW) { /* … */ }
  if (raised &amp; FE_INVALID) { /* … */ }
  /* … */
}
</screen></para><para>
Durum sözcüğünün bitlerini doğrudan etkinleştiremezsiniz. Ancak, durum sözcüklerinin tamamını önce kaydeder ve daha sonra eski haline getirebilirsiniz. Bu işlem aşağıdaki işlevlerle yapılabilir:
    </para><para>
<indexterm scope="glibc-fn"><primary>fegetexceptflag</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-fegetexceptflag">
<funcdef>int <command>fegetexceptflag</command></funcdef>
<paramdef>(fexcept_t *<varname>bayrak</varname>,
 int        <varname>olağandışılıklar</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev <varname>olağandışılıklar</varname> ile belirtilenlerden o an geçerli gerçekleme tanımlı değerleri <varname>bayrak</varname> ile gösterilen değişkende saklar.
    </para><para>
İşlev başarılı olduğunda sıfırla, aksi takdirde sıfırdan farklı bir değerle döner.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>fesetexceptflag</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-fesetexceptflag">
<funcdef>int <command>fesetexceptflag</command></funcdef>
<paramdef>(const fexcept_t *<varname>bayrak</varname>,
 int              <varname>olağandışılıklar</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev <varname>olağandışılıklar</varname> ile belirtilen olağandışılık bayraklarını <varname>bayrak</varname> ile gösterilen değişkenin değerinden eski durumuna getirir.
    </para><para>
İşlev başarılı olduğunda sıfırla, aksi takdirde sıfırdan farklı bir değerle döner.
</para></funcdescr></funcsynopsis></para><para>
<note><para><command>fexcept_t</command> türünde saklanan değerin <command>fetestexcept</command> işlevinden dönen bit maskesine bir benzerliği sözkonusu değildir. Hatta tür bir tamsayı bile olmayabilir. <command>fexcept_t</command> türünde bir değişkeni doğrudan değiştirmeye çalışmayın.</para></note>
    </para></sect1>
    <sect1 xml:id="glibc-Math-Error-Reporting">
      <title>Hataların Matematiksel İşlevlerce Raporlanması</title>
      <titleabbrev>Matematiksel işlevler hataları nasıl raporlar.</titleabbrev>
      <para>
<indexterm scope="glibc-cp"><primary>hatalar</primary><secondary>matematiksel</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>sayılar</primary><secondary>saha hatası</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>sayılar</primary><secondary>aralık hatası</secondary></indexterm>
Matematiksel işlevlerin çoğu sadece gerçek ya da karmaşık sayıların bir alt kümesi ile ilgilidir. Matematiksel olarak tanımlı olsalar bile, sonuçları dönüş türleri ile gösterilebilen aralıktan daha büyük ya da daha küçük olabilir. Bunlar sırasıyla <wordasword>saha hataları</wordasword>, <wordasword>üstten taşmalar</wordasword> ve <wordasword>alttan taşmalar</wordasword> olarak bilinir. Bu hatalardan biri oluştuğunda matematiksel işlevler çeşitli şeyler yaparlar. Bu kılavuzda bu yanıtların hepsine birden bir saha hatasının, üstten ya da alttan taşmanın <firstterm>sinyallenmesi</firstterm> olarak bakacağız.
    </para><para>
Bir matematiksel işlev bir saha hatasına maruz kaldığında, geçersizlik olağandışılığı oluşturur ve NaN ile döner. Ayrıca, <varname>errno</varname> değişkenine <command>EDOM</command> hata durumunu atar; bu, IEEE 754 olağandışılıklarından nasibini almamış eski sistemlerle uyumluluk adına böyledir. Benzer şekilde üstten taşma oluştuğunda matematiksel işlevler üstten taşma olağandışılığı oluşturur ve duruma göre <literal>oo</literal> ya da <literal>-oo</literal> döndürür. Ayrıca, <varname>errno</varname> değişkenine <command>ERANGE</command> hata durumunu atar. Alttan taşma oluştuğunda matematiksel işlevler alttan taşma olağandışılığı oluşturur ve sıfırla (işaretli olabilir) dönerler. <varname>errno</varname> değişkenine <command>ERANGE</command> hata durumu atanmış olabilir, ama bu garanti değildir.
    </para><para>
Bazı matematiksel işlevler matematiksel olarak bir karmaşık değerle sonuçlanacak şekilde tanımlanmıştır. Çok bilinen bir örnek, negatif bir sayının karekökünün alınmasıdır. <command>csqrt</command> gibi karmaşık sayılarla ilgili matematiksel işlevler böyle bir durumda uygun bir değerle dönecektir. <command>sqrt</command> gibi gerçek sayılarla ilgili işlevler ise böyle bir durumda bir saha hatasını sinyalleyecektir.
    </para><para>
Bazı eski donanımlar sonsuzlukları desteklemez. Böyle bir donanımda üstten taşmalar gösterilebilen en büyük sayı ile ya da belli bir çok büyük sayı ile döner. <filename>math.h</filename> dosyasında tanımlanan makroları üstten taşmaları hem eski hem de yeni donanımlarda sınamak için kullanabilirsiniz.
    </para><para>
<indexterm scope="glibc-vr"><primary>HUGE_VAL</primary></indexterm>
<indexterm scope="glibc-vr"><primary>HUGE_VALF</primary></indexterm>
<indexterm scope="glibc-vr"><primary>HUGE_VALL</primary></indexterm>
<funcsynopsis><funcdeflist role="makro">
<funcprototype xml:id="glibc-HUGE_VAL">
<funcdef>double <command>HUGE_VAL</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcprototype xml:id="glibc-HUGE_VALF">
<funcdef>float <command>HUGE_VALF</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcprototype xml:id="glibc-HUGE_VALL">
<funcdef>long double <command>HUGE_VALL</command></funcdef>
<paramdef></paramdef>
</funcprototype></funcdeflist><funcdescr><para>
Belli bir çok büyük sayıyı gösteren bir ifade. IEEE 754 kayan nokta biçimi kullanılan yeni donanımlarda makronun değeri sonsuzdur. Diğer makinelerde, genellikle gösterilebilen en büyük pozitif sayıdır.
    </para><para>
Matematiksel işlevler sonucun gösterilebilenden çok büyük olması durumunda <command>HUGE_VAL</command> veya <command>-HUGE_VAL</command> makrolarının uygun türdeki sürümlerini döndürür.
  </para></funcdescr></funcsynopsis></para></sect1></chapter>
  <chapter xml:id="glibc-Rounding">
    <title>Yuvarlama Kipleri</title>
    <titleabbrev>Sonuçların yuvarlanmasının denetimi.</titleabbrev>
    <para>
Gerçek sayılarla yapılan hesaplamalarda dahili hassasiyet daha yüksektir ve hedef türe sığacak şekilde yuvarlama yapılır. Bu, sonuçların girilen veri kadar hassas olmasını sağlar. IEEE 754 dört olası yuvarlama kipi tanımlar:
   </para><para><variablelist><varlistentry>
   <term>En yakına yuvarlama</term><listitem><para>
Bu öntanımlı kiptir. Diğer kiplerden birine özellikle ihtiyaç duyulmadıkça kullanılması gereken kip budur. Bu kipte sonuçlar gösterilebilen en yakın değere yuvarlanır. Sonuç iki gösterilebilen değerin ortasındaysa çift sayı olanı seçilir. Burada "çift" en düşük seviyeli biti sıfır olan anlamındadır. Bu yuvarlama kipi istatistiksel sapmadan korur ve sayısal kararlılığı garantiler: uzunca bir hesaplamada yuvarlayamama hataları <command>FLT_EPSILON</command>'un yarısından daha küçük kalacaktır.
      </para></listitem></varlistentry><varlistentry>
      <term>Artı sonsuza yuvarlama</term><listitem><para>
Tüm sonuçlar, sonuçtan daha büyük olan gösterilebilir en küçük değere yuvarlanır.
      </para></listitem></varlistentry><varlistentry>
      <term>Eksi sonsuza yuvarlama</term><listitem><para>
Tüm sonuçlar, sonuçtan daha küçük olan gösterilebilir en büyük değere yuvarlanır.
      </para></listitem></varlistentry><varlistentry>
      <term>Sıfıra yuvarlama</term><listitem><para>
Tüm sonuçlar, sıfıra en yakın gösterilebilir en büyük değere yuvarlanır. Başka bir deyişle, negatif sonuçlar üste, pozitif sonuçlar alta yuvarlanır.
      </para></listitem></varlistentry></variablelist>
    </para><para>
<filename>fenv.h</filename> dosyasında tanımlanan sabitleri yuvarlama kiplerini belirtmek için kullanabilirsiniz. Her biri yalnız ve yalnız kayan nokta birimi ilgili yuvarlama kipini destekliyorsa tanımlıdır.
   </para><para><variablelist><varlistentry>
   <term><literal>FE_TONEAREST</literal></term><listitem><para>
<indexterm scope="glibc-vr"><primary>FE_TONEAREST</primary></indexterm>
En yakına yuvarlama.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>FE_UPWARD</literal></term><listitem><para>
<indexterm scope="glibc-vr"><primary>FE_UPWARD</primary></indexterm>
Artı sonsuza yuvarlama.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>FE_DOWNWARD</literal></term><listitem><para>
<indexterm scope="glibc-vr"><primary>FE_DOWNWARD</primary></indexterm>
Eksi sonsuza yuvarlama.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>FE_TOWARDZERO</literal></term><listitem><para>
<indexterm scope="glibc-vr"><primary>FE_TOWARDZERO</primary></indexterm>
Sıfıra yuvarlama.
      </para></listitem></varlistentry></variablelist>
    </para><para>
Alttan taşma gereksiz bir durumdur. Normalde, IEEE 754 kayan noktalı sayıları daima normalleştirilirler (bkz. <xref linkend="glibc-Floating-Point-Concepts"/>). <literal>2^r</literal>'den küçük sayılar (burada r en küçük üstür ve  <varname>float</varname> türü için <command>FLT_MIN_RADIX-1</command>'dir) normallşetirilmiş sayılar olarak gösterilemezler. Böyle sayıların sıfıra ya da <literal>2^r</literal>'ye yuvarlanması bazı algoritmaların sıfırda başarısız olmasına sebep olur. Bu bakımdan bunlar normalleştirilmemiş şekilde kalır. Ondalık kısmın bazı bitleri ondalık noktayı göstermek için kaynayıp gittiğinden bu hassasiyet kaybına sebep olur.
   </para><para>
Eğer bir sonuç bir normalleştirilmemiş sayı olarak göstremek için bile çok küçükse sıfıra yuvarlanır. Yine de, sonucun işareti korunur; eğer hesaplama negatifse sonuç eksi sıfırdır. Negatif sıfır değeri ayrıca <literal>4/-oo</literal> gibi sonsuz değeri kullanılan işlemlerinde sonucu olur. Negatif sıfır, işaret bitini <command>signbit</command> veya <command>copysign</command> ile doğrudan sınanmadıkça tüm hesaplamalarda sıfır gibi davranır.
   </para><para>
Herhangi bir anda yukarıdaki dört yuvarlama kipinden biri seçilidir. Hangi kipin seçili olduğunu şu işlevle bulabilirsiniz:
   </para><para>
<indexterm scope="glibc-fn"><primary>fegetround</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-fegetround">
<funcdef>int <command>fegetround</command></funcdef>
<paramdef>(void)</paramdef>
</funcprototype><funcdescr><para>
O an seçili olan yuvarlama kipini yuvarlama kipini tanımlayan makrolardan birinin değeri olarak döndürür.
</para></funcdescr></funcsynopsis></para><para>
Yuvarlama kipini değiştirmek için şu işlevi kullanın:
   </para><para>
<indexterm scope="glibc-fn"><primary>fesetround</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-fesetround">
<funcdef>int <command>fesetround</command></funcdef>
<paramdef>int <varname>yuvarlama</varname>)</paramdef>
</funcprototype><funcdescr><para>
O an seçili yuarlama kipini <varname>yuvarlama</varname> kipi olarak değiştirir. Eğer <varname>yuvarlama</varname> değeri desteklenen yuvarlama kiplerinden birine karşılık değilse hiçbir değişiklik yapılmaz. İşlev kipi değiştirebilmişse sıfırla, kip desteklenmiyorsa sıfırdan farklı bir değerle döner.
   </para><para>
Mümkünse, yuvarlama kipini değiştirmekten kaçınmalısınız. Masraflı bir işlem haline gelebilir; ayrıca bazı donanımlar yazılımınızın çalıştığından farklı derlenmesini gerektirebilir. Sonuçlanan kod daha yavaş çalışabilir. Daha ayrıntılı bilgi için derleyicinizin belgelerine bakınız.
  </para></funcdescr></funcsynopsis></para></chapter>
  <chapter xml:id="glibc-Control-Functions">
    <title>Kayan Nokta Denetim İşlevleri</title>
    <titleabbrev>Kayan nokta biriminin durumunu kaydetme ve eski durumuna getirme.</titleabbrev>
    <para>
IEEE 754 kayan nokta gerçeklemeleri denetim sözcüğündeki bitleri ayarlayarak oluşacak her olağandışılık için kapanlar olup olmayacağına yazılımcının karar vermesini mümkün kılar. C'de kapanlar yazılımın <command>SIGFPE</command> sinyali almasıyla sonuçlanır; bkz. <xref linkend="glibc-Signal-Handling"/>.
   </para><para>
<note><para>IEEE 754 sinyal eylemcilerin olağandışı durumların ayrıntılarının verildiği ve sonuç değerin ayarlandığı yerler olduğunu söyler. C sinyalleri bu bilginin ileri ya da geri aktarılması için herhangi bir mekanizma sağlamaz. C'de olağandışılıkların yakalanması bundan dolayı çok elverişli değildir.</para></note>
   </para><para>
Bazı hesaplamaları yaparken kayan nokta biriminin durumunun kaydedilmesi kimi zaman gerekli olur. Kütüphane, kapanları üreten olağandışılıkları ve yuvarlama kiplerini kaydetmeyi ve gerektiğinde eski durumuna getirmeyi sağlayan işlevler sağlar. Bu bilgiler <firstterm>kayan nokta ortamı</firstterm> olarak bilinir.
   </para><para>
Kayan nokta ortamını kaydeden ve eski durumuna getiren işlevlerin hepsi bilgiyi saklamak için  <command>fenv_t</command> türünde bir değişken kullanırlar. Bu veri türü <filename>fenv.h</filename> dosyasında tanımlanmıştır. Türün genişliği ve içeriği gerçeklemeye bağlıdır. Bu türdeki bir değişkenin değerini doğrudan değiştirmeye çalışmamalısınız.
   </para><para>
Kayan nokta biriminin durumunu kaydetmek için bu işlevlerden birini kullanın:
   </para><para>
<indexterm scope="glibc-fn"><primary>fegetenv</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-fegetenv">
<funcdef>int <command>fegetenv</command></funcdef>
<paramdef>(fenv_t *<varname>ortam</varname>)</paramdef>
</funcprototype><funcdescr><para>
Kayan nokta ortamını <varname>ortam</varname> ile gösterilen değişkende saklar.
   </para><para>
İşlem başarılıysa işlev sıfırla aksi takdirde sıfırdan farklı bir değerle döner.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>feholdexcept</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-feholdexcept">
<funcdef>int <command>feholdexcept</command></funcdef>
<paramdef>(fenv_t *<varname>ortam</varname>)</paramdef>
</funcprototype><funcdescr><para>
O anki kayan nokta ortamını <varname>ortam</varname> ile gösterilen nesnede saklar ve tüm olağandışılık bayraklarını temizledikten sonra kayan nokta birimini hiçbir olağandışılığı yakalamamaya ayarlar. Hiçbir olağandışılığın yakalanmamasını kayan nokta birimlerinin hepsi desteklemez; eğer <command>feholdexcept</command> bu kipi ayarlayamıyorsa, sıfırdan farklı bir değer döner. Başarırsa sıfırla döner.
</para></funcdescr></funcsynopsis></para><para>
Kayan nokta ortamını eski durumuna getiren işlevlerin alabildiği argüman çeşitleri:
   </para><para><itemizedlist><listitem>
Önceki bir <command>fegetenv</command> vaya <command>feholdexcept</command> çağrısı ile ilklendirilen <command>fenv_t</command> türündeki nesnelere göstericiler.
     </listitem><listitem>
<indexterm scope="glibc-vr"><primary>FE_DFL_ENV</primary></indexterm>
Yazılım başlangıcında kullanılabilir olarak, kayan noktalı ortamı ifade eden bir özel makro: <command>FE_DFL_ENV</command>.
     </listitem><listitem><para>
<command>fenv_t *</command> türünde isimleri <command>FE_</command> ile başlayan gerçekleme tanımlı makrolar.
     </para><para>
<indexterm scope="glibc-vr"><primary>FE_NOMASK_ENV</primary></indexterm>
Mümkünse, GNU C kütüphanesi, bir kapanın oluşmasına sebep olan her olağandışılığın ortaya çıkışında ortamı ifade eden <command>FE_NOMASK_ENV</command> makrosunu tanımlar. Bu makronun varlığını <command>#ifdef</command> kullanarak sınayabilirsiniz. Bu makro sadece <command>_GNU_SOURCE</command> tanımlıysa tanımlıdır.
     </para><para>
Bazı platformlar diğer önceden tanımlanmış ortamları tanımlayabilir.
     </para></listitem></itemizedlist></para><para>
Kayan noktalı ortamı etkin kılmak için şu işlevleri kullanabilirsiniz:
   </para><para>
<indexterm scope="glibc-fn"><primary>fesetenv</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-fesetenv">
<funcdef>int <command>fesetenv</command></funcdef>
<paramdef>(const fenv_t *<varname>ortam</varname>)</paramdef>
</funcprototype><funcdescr><para>
<varname>ortam</varname> ile açıklanan kayan noktalı ortamı etkin kılar.
   </para><para>
İşlev başarılı olduğunda sıfırla, aksi takdirde sıfırdan farklı bir değerle döner.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>feupdateenv</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-feupdateenv">
<funcdef>int <command>feupdateenv</command></funcdef>
<paramdef>(const fenv_t *<varname>ortam</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>fesetenv</command> gibi bu işlev de <varname>ortam</varname> ile açıklanan kayan noktalı ortamı etkin kılar. Ancak, bu işlevin çağrısından önce durum sözcüğü bayraklı herhangi bir olağandışılık varsa çağrıdan sonra da bayraklı olarak kalır. Başka bir deyişle, bu işlevin çağrısından sonra önceki durum sözcüğü ile <varname>ortam</varname> içinde kayıtlı olan bit seviyesinde VEYAlanır.
   </para><para>
İşlev başarılı olduğunda sıfırla, aksi takdirde sıfırdan farklı bir değerle döner.
</para></funcdescr></funcsynopsis></para><para>
Olağandışılıklar ortaya çıktığında bir kapanın oluşmasına sebep oluyorsa, bu olağandışılıkları tek tek aşağıdaki iki işlevle denetim altında tutabilirsiniz.
   </para><para>
<note><title>Taşınabilirlik Bilgisi</title><para>Bu işlevlerin hepsi GNU oluşumudur.</para></note>
   </para><para>
<indexterm scope="glibc-fn"><primary>feenableexcept</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-feenableexcept">
<funcdef>int <command>feenableexcept</command></funcdef>
<paramdef>(int <varname>olağandışılıklar</varname>)</paramdef>
</funcprototype><funcdescr><para>
<varname>olağandışılıklar</varname> parametresi ile belirtilen olağandışılıkların her biri için kapanları etkinleştirir. Olağandışılıklar tek tek <xref linkend="glibc-Status-bit-operations"/> bölümünde açıklanmıştır.  Sadece belirtilen olağandışılıklar etkinleştirilir, diğer olağandışılıkların durumu değiştirilmez.
   </para><para>
İşlev başarılı olduğunda evvelce etkinleştirilmiş olağandışılıklarla döner, aksi takdirde <command>-1</command> ile döner.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>fedisableexcept</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-fedisableexcept">
<funcdef>int <command>fedisableexcept</command></funcdef>
<paramdef>(int <varname>olağandışılıklar</varname>)</paramdef>
</funcprototype><funcdescr><para>
<varname>olağandışılıklar</varname> parametresi ile belirtilen olağandışılıkların her biri için kapanları iptal eder. Olağandışılıklar tek tek <xref linkend="glibc-Status-bit-operations"/> bölümünde açıklanmıştır.  Sadece belirtilen olağandışılıklar iptal edilir, diğer olağandışılıkların durumu değiştirilmez.
   </para><para>
İşlev başarılı olduğunda evvelce etkinleştirilmiş olağandışılıklarla döner, aksi takdirde <command>-1</command> ile döner.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>fegetexcept</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-fegetexcept">
<funcdef>int <command>fegetexcept</command></funcdef>
<paramdef>(int <varname>olağandışılıklar</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev o an etkin olan olağandışılıklar ile döner. <command>-1</command> dönmüşse bir hata oluşmuş demektir.
  </para></funcdescr></funcsynopsis></para></chapter>
  <chapter xml:id="glibc-Arithmetic-Functions">
    <title>Aritmetik İşlevleri</title>
    <titleabbrev>Kütüphanece sağlanmış temel işlemler.</titleabbrev>
    <para>
C kütüphanesi gerçek sayılar üzerinde temel işlemleri yapan işlevler içerir.  Bunlar arasında mutlak değer, en küçük ve en büyük değer, normalleştirme, bit değiştirme ve yuvarlama işlemleri sayılabilir.
   </para>
    <sect1 xml:id="glibc-Absolute-Value">
      <title>Mutlak Değer</title>
      <titleabbrev>Tamsayıların ve gerçek sayıların mutlak değerleri.</titleabbrev>
      <para>
<indexterm scope="glibc-cp"><primary>sayılar</primary><secondary>mutlak değer işlevleri</secondary></indexterm>
Bu işlevler <wordasword>mutlak değerler</wordasword>i (ya da <firstterm>genlik</firstterm>leri) elde etmek için kullanılır. <varname>x</varname> gerçek sayısının mutlak değeri, <varname>x</varname> pozitifse <varname>x</varname>, negatifse -<varname>x</varname>'tir. <varname>z</varname>, gerçek kısmı <varname>x</varname>, sanal kısmı <varname>y</varname> olan bir karmaşık sayı ise, <varname>z</varname>'nin mutlak değeri <varname>x</varname>'in karesi ile <varname>y</varname>'nin karesinin toplamının kareköküdür.
    </para><para>
<indexterm scope="glibc-pg"><primary>math.h</primary></indexterm>
<indexterm scope="glibc-pg"><primary>stdlib.h</primary></indexterm>
<command>abs</command>, <command>labs</command> ve <command>llabs</command> işlevleri <filename>stdlib.h</filename> başlık dosyasında bildirilmiştir. <command>imaxabs</command> işlevi <filename>inttypes.h</filename> dosyasında, <command>fabs</command>, <command>fabsf</command> ve <command>fabsl</command> işlevleri <filename>math.h</filename> dosyasında, <command>cabs</command>, <command>cabsf</command> ve <command>cabsl</command> işlevleri ise <filename>complex.h</filename> dosyasında bildirilmiştir.
    </para><para>
<indexterm scope="glibc-fn"><primary>abs</primary></indexterm>
<indexterm scope="glibc-fn"><primary>labs</primary></indexterm>
<indexterm scope="glibc-fn"><primary>llabs</primary></indexterm>
<indexterm scope="glibc-fn"><primary>imaxabs</primary></indexterm>
<funcsynopsis><funcdeflist role="işlev">
<funcprototype xml:id="glibc-abs">
<funcdef>int <command>abs</command></funcdef>
<paramdef>(int <varname>sayı</varname>)</paramdef>
</funcprototype><funcprototype xml:id="glibc-labs">
<funcdef>long int <command>labs</command></funcdef>
<paramdef>(long int <varname>sayı</varname>)</paramdef>
</funcprototype><funcprototype xml:id="glibc-llabs">
<funcdef>long long int <command>llabs</command></funcdef>
<paramdef>(long long int <varname>sayı</varname>)</paramdef>
</funcprototype><funcprototype xml:id="glibc-imaxabs">
<funcdef>intmax_t <command>imaxabs</command></funcdef>
<paramdef>(intmax_t <varname>sayı</varname>)</paramdef>
</funcprototype></funcdeflist><funcdescr><para>
Bu işlevler <varname>sayı</varname> tamsayısının mutlak değeri ile döner.
    </para><para>
<command>INT_MIN</command> (olası en küçük <command>int</command>) değerinin mutlak değerinin gösterilemediği bazı bilgisayarlarda tamsayı gösterimleri ikinin tümleyenini kullanırlar; böyle bir durumda <command>abs (INT_MIN)</command> tanımsızdır.
    </para><para>
<command>llabs</command> ve <command>imaxdiv</command> işlevleri ISO C99 ile tanımlanmış daha yeni işlevlerdir.
    </para><para>
<command>intmax_t</command> türü hakkında daha fazla bilgi için <xref linkend="glibc-Integers"/> bölümüne bakınız.
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>fabsl</primary></indexterm>
<indexterm scope="glibc-fn"><primary>fabsf</primary></indexterm>
<indexterm scope="glibc-fn"><primary>fabs</primary></indexterm>
<funcsynopsis><funcdeflist role="işlev">
<funcprototype xml:id="glibc-fabs">
<funcdef>double <command>fabs</command></funcdef>
<paramdef>(double <varname>sayı</varname>)</paramdef>
</funcprototype><funcprototype xml:id="glibc-fabsf">
<funcdef>float <command>fabsf</command></funcdef>
<paramdef>(float <varname>sayı</varname>)</paramdef>
</funcprototype><funcprototype xml:id="glibc-fabsl">
<funcdef>long double <command>fabsl</command></funcdef>
<paramdef>(long double <varname>sayı</varname>)</paramdef>
</funcprototype></funcdeflist><funcdescr><para>
Bu işlevler <varname>sayı</varname> gerçek sayısnın mutlak değeri ile döner.
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>cabs</primary></indexterm>
<indexterm scope="glibc-fn"><primary>cabsf</primary></indexterm>
<indexterm scope="glibc-fn"><primary>cabsl</primary></indexterm>
<funcsynopsis><funcdeflist role="işlev">
<funcprototype xml:id="glibc-cabs">
<funcdef>double <command>cabs</command></funcdef>
<paramdef>(complex double <varname>z</varname>)</paramdef>
</funcprototype><funcprototype xml:id="glibc-cabsf">
<funcdef>float <command>cabsf</command></funcdef>
<paramdef>(complex float <varname>z</varname>)</paramdef>
</funcprototype><funcprototype xml:id="glibc-cabsl">
<funcdef>long double <command>cabsl</command></funcdef>
<paramdef>(complex long double <varname>z</varname>)</paramdef>
</funcprototype></funcdeflist><funcdescr><para>
Bu işlevler <varname>z</varname> karmaşık sayısnın mutlak değeri ile döner (bkz. <xref linkend="glibc-Complex-Numbers"/>).  Bir karmaşık sayının mutlak değeri şöyle hesaplanır:
    </para><para>
<literallayout indent="0">
    sqrt (creal (<varname>z</varname>) * creal (<varname>z</varname>) + cimag (<varname>z</varname>) * cimag (<varname>z</varname>))
</literallayout></para><para>
Hassasiyet kayıplarından kaçınmak için doğrudan formülü kullanmak yerine bu işlevin kullanılması gerekir. Bu işlem ayrıca donanım desteği avantajına da sahiptir. <xref linkend="glibc-Exponents-and-Logarithms"/> bölümündeki <command>hypot</command>'a bakınız.
    </para></funcdescr></funcsynopsis></para></sect1>
    <sect1 xml:id="glibc-Normalization-Functions">
      <title>Normalleştirme İşlevleri</title>
      <titleabbrev>Üslü duruma getirme ve geri alma.</titleabbrev>
      <para>
<indexterm scope="glibc-cp"><primary>sayılar</primary><secondary>normalleştirme işlevleri (gerçek sayılarda)</secondary></indexterm>
Bu bölümde, dahili olarak bir ikilik üs değeri kullanarak gösterilen kayan noktalı sayıların düşük seviyeli işlemlerini verimli bir yöntem olarak sağlayan işlevlere öncelikle yer verilmiştir; bkz. <xref linkend="glibc-Floating-Point-Concepts"/>. Bu işlevlerin, gösterim ikilik üs kullanmıyorsa bile  eşdeğer davranış göstermeleri gerekir, fakat şüphesiz bunlar bu durumların tersi durumlarda kısmen bile verimli olmaz.
    </para><para>
<indexterm scope="glibc-pg"><primary>math.h</primary></indexterm>
Bu bölümdeki işlevlerin hepsi <filename>math.h</filename> dosyasında bildirilmiştir.
    </para><para>
<indexterm scope="glibc-fn"><primary>frexp</primary></indexterm>
<indexterm scope="glibc-fn"><primary>frexpf</primary></indexterm>
<indexterm scope="glibc-fn"><primary>frexpl</primary></indexterm>
<funcsynopsis><funcdeflist role="işlev">
<funcprototype xml:id="glibc-frexp">
<funcdef>double <command>frexp</command></funcdef>
<paramdef>(double <varname>değer</varname>,
 int   *<varname>üs</varname>)</paramdef>
</funcprototype><funcprototype xml:id="glibc-frexpf">
<funcdef>float <command>frexpf</command></funcdef>
<paramdef>(float <varname>değer</varname>,
 int  *<varname>üs</varname>)</paramdef>
</funcprototype><funcprototype xml:id="glibc-frexpl">
<funcdef>long double <command>frexpl</command></funcdef>
<paramdef>(long double <varname>değer</varname>,
 int        *<varname>üs</varname>)</paramdef>
</funcprototype></funcdeflist><funcdescr><para>
Bu işlevler <varname>değer</varname> ile belirtilen sayıyı normalleştirilmiş ondalık kısım ile üstel kısıma ayırır.
    </para><para>
Eğer <varname>değer</varname> argümanı sıfır değilse, 2 üssü <varname>*üs</varname> ile işlevin dönüş değerinin çarpımı,  <varname>değer</varname>'i verir. İşlevin dönüş değeri daima 1/2 (dahil) ile 1 (hariç) arasındadır. Üstel kısım <varname>*üs</varname> içinde saklanır.
    </para><para>
Örneğin, <command>frexp (12.8, &amp;exponent)</command> çağrısı <command>0.8</command> ile döner ve <varname>exponent</varname> içinde <command>4</command> değerini saklar.
    </para><para>
<varname>değer</varname> sıfır ise işlev sıfırla döner ve <varname>*üs</varname> içinde sıfır saklanır.
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>ldexp</primary></indexterm>
<indexterm scope="glibc-fn"><primary>ldexpf</primary></indexterm>
<indexterm scope="glibc-fn"><primary>ldexpl</primary></indexterm>
<funcsynopsis><funcdeflist role="işlev">
<funcprototype xml:id="glibc-ldexp">
<funcdef>double <command>ldexp</command></funcdef>
<paramdef>(double <varname>değer</varname>,
 int   *<varname>üs</varname>)</paramdef>
</funcprototype><funcprototype xml:id="glibc-ldexpf">
<funcdef>float <command>ldexpf</command></funcdef>
<paramdef>(float <varname>değer</varname>,
 int  *<varname>üs</varname>)</paramdef>
</funcprototype><funcprototype xml:id="glibc-ldexpl">
<funcdef>long double <command>ldexpl</command></funcdef>
<paramdef>(long double <varname>değer</varname>,
 int        *<varname>üs</varname>)</paramdef>
</funcprototype></funcdeflist><funcdescr><para>
Bu işlev, <varname>değer</varname> gerçek sayısının 2 üssü <varname>üs</varname> ile çarpımını döndürür. (Bu işlev, <command>frexp</command> işlevinden dönen parçalarla gerçek sayıları yeniden elde etmek amacıyla kullanılabilir.)
    </para><para>
Örneğin, <command>ldexp (0.8, 4)</command> çağrısı <command>12.8</command> ile döner.
</para></funcdescr></funcsynopsis></para><para>
Aşağıdaki işlevler BSD'den gelir ve <command>ldexp</command> ve <command>frexp</command> işlevlerinin eşdeğeri oluşumlardır. Ayrıca, ISO C işlevi olan, aynı zamanda da orjinal olarak bir BSD işlevi olan <command>logb</command> işlevine de bakınız.
    </para><para>
<indexterm scope="glibc-fn"><primary>scalb</primary></indexterm>
<indexterm scope="glibc-fn"><primary>scalbf</primary></indexterm>
<indexterm scope="glibc-fn"><primary>scalbl</primary></indexterm>
<funcsynopsis><funcdeflist role="işlev">
<funcprototype xml:id="glibc-scalb">
<funcdef>double <command>scalb</command></funcdef>
<paramdef>(double <varname>değer</varname>,
 int   *<varname>üs</varname>)</paramdef>
</funcprototype><funcprototype xml:id="glibc-scalbf">
<funcdef>float <command>scalbf</command></funcdef>
<paramdef>(float <varname>değer</varname>,
 int  *<varname>üs</varname>)</paramdef>
</funcprototype><funcprototype xml:id="glibc-scalbl">
<funcdef>long double <command>scalbl</command></funcdef>
<paramdef>(long double <varname>değer</varname>,
 int        *<varname>üs</varname>)</paramdef>
</funcprototype></funcdeflist><funcdescr><para>
<command>scalb</command> işlevi <command>ldexp</command> işlevinin BSD ismidir.
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>scalbn</primary></indexterm>
<indexterm scope="glibc-fn"><primary>scalbnf</primary></indexterm>
<indexterm scope="glibc-fn"><primary>scalbnl</primary></indexterm>
<funcsynopsis><funcdeflist role="işlev">
<funcprototype xml:id="glibc-scalbn">
<funcdef>long long int <command>scalbn</command></funcdef>
<paramdef>(double   <varname>x</varname>,
 long int <varname>n</varname>)</paramdef>
</funcprototype><funcprototype xml:id="glibc-scalbnf">
<funcdef>long long int <command>scalbnf</command></funcdef>
<paramdef>(float    <varname>x</varname>,
 long int <varname>n</varname>)</paramdef>
</funcprototype><funcprototype xml:id="glibc-scalbnl">
<funcdef>long long int <command>scalbnl</command></funcdef>
<paramdef>(long double <varname>x</varname>,
 long int    <varname>n</varname>)</paramdef>
</funcprototype></funcdeflist><funcdescr><para>
<command>scalbn</command> işlevi, <varname>n</varname> üssünün bir gerçek sayı değil <command>int</command> türünde bir değer olması dışında <command>scalb</command> işlevinin benzeridir.
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>scalbln</primary></indexterm>
<indexterm scope="glibc-fn"><primary>scalblnf</primary></indexterm>
<indexterm scope="glibc-fn"><primary>scalblnl</primary></indexterm>
<funcsynopsis><funcdeflist role="işlev">
<funcprototype xml:id="glibc-scalbln">
<funcdef>long long int <command>scalbln</command></funcdef>
<paramdef>(double <varname>x</varname>,
 int    <varname>n</varname>)</paramdef>
</funcprototype><funcprototype xml:id="glibc-scalblnf">
<funcdef>long long int <command>scalblnf</command></funcdef>
<paramdef>(float <varname>x</varname>,
 int   <varname>n</varname>)</paramdef>
</funcprototype><funcprototype xml:id="glibc-scalblnl">
<funcdef>long long int <command>scalblnl</command></funcdef>
<paramdef>(long double <varname>x</varname>,
 int         <varname>n</varname>)</paramdef>
</funcprototype></funcdeflist><funcdescr><para>
<command>scalbln</command> işlevi, <varname>n</varname> üssünün bir gerçek sayı değil <command>long int</command> türünde bir değer olması dışında <command>scalb</command> işlevinin benzeridir.
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>significandl</primary></indexterm>
<indexterm scope="glibc-fn"><primary>significandf</primary></indexterm>
<indexterm scope="glibc-fn"><primary>significand</primary></indexterm>
<funcsynopsis><funcdeflist role="işlev">
<funcprototype xml:id="glibc-significand">
<funcdef>long long int<command>significand</command></funcdef>
<paramdef>(double <varname>x</varname>)</paramdef>
</funcprototype><funcprototype xml:id="glibc-significandf">
<funcdef>long long int <command>significandf</command></funcdef>
<paramdef>(float <varname>x</varname>)</paramdef>
</funcprototype><funcprototype xml:id="glibc-significandl">
<funcdef>long long int<command>significandl</command></funcdef>
<paramdef>(long double <varname>x</varname>)</paramdef>
</funcprototype></funcdeflist><funcdescr><para>
<command>significand</command> işlevi <varname>x</varname>'in ondalık kısmını [1, 2] aralığında oranlayarak döndürür. <command>scalb (<varname>x</varname>, (double) -ilogb (<varname>x</varname>))</command> çağrısına denktir.
    </para><para>
Bu işlev esas olarak IEEE 754 uyumlu standartlaştırılmış belli sınamalarda kullanmak için vardır.
    </para></funcdescr></funcsynopsis></para></sect1>
    <sect1 xml:id="glibc-Rounding-Functions">
      <title>Yuvarlama İşlevleri</title>
      <titleabbrev>Gerçek sayıların tamsayılara yuvarlanması.</titleabbrev>
      <para>
<indexterm scope="glibc-cp"><primary>sayılar</primary><secondary>gerçek sayıların tamsayılara dönüştürülmesi</secondary></indexterm>
<indexterm scope="glibc-pg"><primary>math.h</primary></indexterm>
Burada listelenen işlevler gerçek sayıları yuvarlamak ya da ondalık kısmını kırpmak gibi işlemleri gerçekleştirirler. Bu işlevlerden bazıları gerçek sayıları tamsayılara dönüştürmek için kullanılır. Bu işlevler <filename>math.h</filename><footnote><para>Ç.N.: Bu işlevleri içeren bir kodu <command>gcc</command> ile derlerken <option>-lm</option> seçeneğini vermeyi unutmayın.</para></footnote> başlık dosyasında bildirilmiştir.
    </para><para>
Gerçek sayıları tamsayılara dönüştürmek için ayrıca <command>int</command> türüne tür dönüşümü yapabilirsiniz. Bu gerçek sayının ondalık kısmını iptal eder, daha doğrusu sıfıra yuvarlar. Ancak, sonuç gerçekte <command>int</command> türünde gösterilebiliyorsa bu çalışır--çok büyük sayılarda bu mümkün olmaz. Burada listelenen işlevler bu sorunun çevresinden dolaşmak için sonucu <command>double</command> türünde döndürüler.
    </para><para>
<indexterm scope="glibc-fn"><primary>ceill</primary></indexterm>
<indexterm scope="glibc-fn"><primary>ceil</primary></indexterm>
<indexterm scope="glibc-fn"><primary>ceilf</primary></indexterm>
<funcsynopsis><funcdeflist role="işlev">
<funcprototype xml:id="glibc-ceil">
<funcdef>double <command>ceil</command></funcdef>
<paramdef>(double <varname>x</varname>)</paramdef>
</funcprototype><funcprototype xml:id="glibc-ceilf">
<funcdef>float <command>ceilf</command></funcdef>
<paramdef>(float <varname>x</varname>)</paramdef>
</funcprototype><funcprototype xml:id="glibc-ceill">
<funcdef>long double <command>ceill</command></funcdef>
<paramdef>(long double <varname>x</varname>)</paramdef>
</funcprototype></funcdeflist><funcdescr><para>
Bu işlevler <varname>x</varname> sayısını en yakın büyük tamsayıya yuvarlar ve sonucu gerçek sayı türünde döndürür. <command>ceil (1.5)</command> çağrısı <command>2.0</command> değerini döndürür.
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>floorl</primary></indexterm>
<indexterm scope="glibc-fn"><primary>floor</primary></indexterm>
<indexterm scope="glibc-fn"><primary>floorf</primary></indexterm>
<funcsynopsis><funcdeflist role="işlev">
<funcprototype xml:id="glibc-floor">
<funcdef>double <command>floor</command></funcdef>
<paramdef>(double <varname>x</varname>)</paramdef>
</funcprototype><funcprototype xml:id="glibc-floorf">
<funcdef>float <command>floorf</command></funcdef>
<paramdef>(float <varname>x</varname>)</paramdef>
</funcprototype><funcprototype xml:id="glibc-floorl">
<funcdef>long double <command>floorl</command></funcdef>
<paramdef>(long double <varname>x</varname>)</paramdef>
</funcprototype></funcdeflist><funcdescr><para>
Bu işlevler <varname>x</varname> sayısını en yakın küçük tamsayıya yuvarlar ve sonucu gerçek sayı türünde döndürür. <command>floor (1.5)</command> çağrısı <command>1.0</command> ile ve <command>floor (-1.5)</command> çağrısı <command>-2.0</command> ile döner.
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>trunc</primary></indexterm>
<indexterm scope="glibc-fn"><primary>truncf</primary></indexterm>
<indexterm scope="glibc-fn"><primary>truncl</primary></indexterm>
<funcsynopsis><funcdeflist role="işlev">
<funcprototype xml:id="glibc-trunc">
<funcdef>double <command>trunc</command></funcdef>
<paramdef>(double <varname>x</varname>)</paramdef>
</funcprototype><funcprototype xml:id="glibc-truncf">
<funcdef>float <command>truncf</command></funcdef>
<paramdef>(float <varname>x</varname>)</paramdef>
</funcprototype><funcprototype xml:id="glibc-truncl">
<funcdef>long double <command>truncl</command></funcdef>
<paramdef>(long double <varname>x</varname>)</paramdef>
</funcprototype></funcdeflist><funcdescr><para>
Bu işlevler <varname>x</varname> sayısını sıfıra doğru en yakın tamsayıya yuvarlar ve sonucu gerçek sayı türünde döndürür. <command>trunc (1.5)</command> çağrısı <command>1.0</command> ile ve <command>trunc (-1.5)</command> çağrısı <command>-1.0</command> ile döner.
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>rint</primary></indexterm>
<indexterm scope="glibc-fn"><primary>rintf</primary></indexterm>
<indexterm scope="glibc-fn"><primary>rintl</primary></indexterm>
<funcsynopsis><funcdeflist role="işlev">
<funcprototype xml:id="glibc-rint">
<funcdef>double <command>rint</command></funcdef>
<paramdef>(double <varname>x</varname>)</paramdef>
</funcprototype><funcprototype xml:id="glibc-rintf">
<funcdef>float <command>rintf</command></funcdef>
<paramdef>(float <varname>x</varname>)</paramdef>
</funcprototype><funcprototype xml:id="glibc-rintl">
<funcdef>long double <command>rintl</command></funcdef>
<paramdef>(long double <varname>x</varname>)</paramdef>
</funcprototype></funcdeflist><funcdescr><para>
Bu işlevler <varname>x</varname> sayısını o anki yuvarlama kipine uygun olarak bir tamsayıya yuvarlar. Çeşitli yuvarlama kipleri hakkında bilgi almak için <xref linkend="glibc-Floating-Point-Parameters"/> bölümüne bakınız. Öntanımlı yuvarlama kipi en yakın tamsayıya yuvarlamadır; bazı makineler diğer kipleri destekleyebilir ama açıkça başka bir kip belirtilmedikçe daima en yakına yuvarlama kipi kullanılır.
    </para><para>
<varname>x</varname> sayısının baş tarafı bir tamsayı değilse, bu işlevler kesin olmama olağandışılığı oluşturur.
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>nearbyint</primary></indexterm>
<indexterm scope="glibc-fn"><primary>nearbyintf</primary></indexterm>
<indexterm scope="glibc-fn"><primary>nearbyintl</primary></indexterm>
<funcsynopsis><funcdeflist role="işlev">
<funcprototype xml:id="glibc-nearbyint">
<funcdef>double <command>nearbyint</command></funcdef>
<paramdef>(double <varname>x</varname>)</paramdef>
</funcprototype><funcprototype xml:id="glibc-nearbyintf">
<funcdef>float <command>nearbyintf</command></funcdef>
<paramdef>(float <varname>x</varname>)</paramdef>
</funcprototype><funcprototype xml:id="glibc-nearbyintl">
<funcdef>long double <command>nearbyintl</command></funcdef>
<paramdef>(long double <varname>x</varname>)</paramdef>
</funcprototype></funcdeflist><funcdescr><para>
Bu işlevler <command>rint</command> işlevleri ile aynı değeri döndürür ama <varname>x</varname>'in baş tarafı bir tamsayı değilse, kesin olmama olağandışılığını oluşturmaz.
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>round</primary></indexterm>
<indexterm scope="glibc-fn"><primary>roundf</primary></indexterm>
<indexterm scope="glibc-fn"><primary>roundl</primary></indexterm>
<funcsynopsis><funcdeflist role="işlev">
<funcprototype xml:id="glibc-round">
<funcdef>double <command>round</command></funcdef>
<paramdef>(double <varname>x</varname>)</paramdef>
</funcprototype><funcprototype xml:id="glibc-roundf">
<funcdef>float <command>roundf</command></funcdef>
<paramdef>(float <varname>x</varname>)</paramdef>
</funcprototype><funcprototype xml:id="glibc-roundl">
<funcdef>long double <command>roundl</command></funcdef>
<paramdef>(long double <varname>x</varname>)</paramdef>
</funcprototype></funcdeflist><funcdescr><para>
Bu işlevler <command>rint</command> işlevlerine benzer, farklı olarak <varname>x</varname>'in işaretiyle, ondalık kısmın 1/2'den (dahil) büyük değerlerini en yakın büyük mutlak tamsayıya, 1/2'den küçük değerlerini en yakın küçük mutlak tamsayıya yuvarlar.
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>lrint</primary></indexterm>
<indexterm scope="glibc-fn"><primary>lrintf</primary></indexterm>
<indexterm scope="glibc-fn"><primary>lrintl</primary></indexterm>
<funcsynopsis><funcdeflist role="işlev">
<funcprototype xml:id="glibc-lrint">
<funcdef>long int <command>lrint</command></funcdef>
<paramdef>(double <varname>x</varname>)</paramdef>
</funcprototype><funcprototype xml:id="glibc-lrintf">
<funcdef>long int <command>lrintf</command></funcdef>
<paramdef>(float <varname>x</varname>)</paramdef>
</funcprototype><funcprototype xml:id="glibc-lrintl">
<funcdef>long int <command>lrintl</command></funcdef>
<paramdef>(long double <varname>x</varname>)</paramdef>
</funcprototype></funcdeflist><funcdescr><para>
Bu işlevler <command>rint</command> işlevlerine benzer, fakat bir gerçek sayı yerine bir <command>long int</command> türünde değerle döner.
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>llrint</primary></indexterm>
<indexterm scope="glibc-fn"><primary>llrintf</primary></indexterm>
<indexterm scope="glibc-fn"><primary>llrintl</primary></indexterm>
<funcsynopsis><funcdeflist role="işlev">
<funcprototype xml:id="glibc-llrint">
<funcdef>long long int <command>llrint</command></funcdef>
<paramdef>(double <varname>x</varname>)</paramdef>
</funcprototype><funcprototype xml:id="glibc-llrintf">
<funcdef>long long int <command>llrintf</command></funcdef>
<paramdef>(float <varname>x</varname>)</paramdef>
</funcprototype><funcprototype xml:id="glibc-llrintl">
<funcdef>long long int <command>llrintl</command></funcdef>
<paramdef>(long double <varname>x</varname>)</paramdef>
</funcprototype></funcdeflist><funcdescr><para>
Bu işlevler <command>rint</command> işlevlerine benzer, fakat bir gerçek sayı yerine bir <command>long long int</command> türünde değerle döner.
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>lround</primary></indexterm>
<indexterm scope="glibc-fn"><primary>lroundf</primary></indexterm>
<indexterm scope="glibc-fn"><primary>lroundl</primary></indexterm>
<funcsynopsis><funcdeflist role="işlev">
<funcprototype xml:id="glibc-lround">
<funcdef>long int <command>lround</command></funcdef>
<paramdef>(double <varname>x</varname>)</paramdef>
</funcprototype><funcprototype xml:id="glibc-lroundf">
<funcdef>long int <command>lroundf</command></funcdef>
<paramdef>(float <varname>x</varname>)</paramdef>
</funcprototype><funcprototype xml:id="glibc-lroundl">
<funcdef>long int <command>lroundl</command></funcdef>
<paramdef>(long double <varname>x</varname>)</paramdef>
</funcprototype></funcdeflist><funcdescr><para>
Bu işlevler <command>round</command> işlevlerine benzer, fakat bir gerçek sayı yerine bir <command>long int</command> türünde değerle döner.
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>llround</primary></indexterm>
<indexterm scope="glibc-fn"><primary>llroundf</primary></indexterm>
<indexterm scope="glibc-fn"><primary>llroundl</primary></indexterm>
<funcsynopsis><funcdeflist role="işlev">
<funcprototype xml:id="glibc-llround">
<funcdef>long long int <command>llround</command></funcdef>
<paramdef>(double <varname>x</varname>)</paramdef>
</funcprototype><funcprototype xml:id="glibc-llroundf">
<funcdef>long long int <command>llroundf</command></funcdef>
<paramdef>(float <varname>x</varname>)</paramdef>
</funcprototype><funcprototype xml:id="glibc-llroundl">
<funcdef>long long int <command>llroundl</command></funcdef>
<paramdef>(long double <varname>x</varname>)</paramdef>
</funcprototype></funcdeflist><funcdescr><para>
Bu işlevler <command>round</command> işlevlerine benzer, fakat bir gerçek sayı yerine bir <command>long long int</command> türünde değerle döner.
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>modf</primary></indexterm>
<indexterm scope="glibc-fn"><primary>modff</primary></indexterm>
<indexterm scope="glibc-fn"><primary>modfl</primary></indexterm>
<funcsynopsis><funcdeflist role="işlev">
<funcprototype xml:id="glibc-modf">
<funcdef>double <command>modf</command></funcdef>
<paramdef>(double  <varname>değer</varname>,
 double *<varname>tamkısım</varname>)</paramdef>
</funcprototype><funcprototype xml:id="glibc-modff">
<funcdef>float <command>modff</command></funcdef>
<paramdef>(float  <varname>değer</varname>,
 float *<varname>tamkısım</varname>)</paramdef>
</funcprototype><funcprototype xml:id="glibc-modfl">
<funcdef>long double <command>modfl</command></funcdef>
<paramdef>(long double  <varname>değer</varname>,
 long double *<varname>tamkısım</varname>)</paramdef>
</funcprototype></funcdeflist><funcdescr><para>
Bu işlevler <varname>değer</varname> gerçek sayısını tam ve ondalık kısımlarına (<command>-1</command> ile <command>1</command> arasında) ayırır. Toplamları <varname>değer</varname>'e eşittir. Her iki kısmın işareti de <varname>değer</varname>'in işareti ile aynıdır. Tam kısım daima sıfıra yuvarlanır.
    </para><para>
<command>modf</command> sayının tamsayı kısmını <varname>*tamkısım</varname> içinde saklayıp ondalık kısım ile döner. Örneğin, <command>modf (2.5, &amp;intpart)</command> çağrısı <command>0.5</command> ile dönerken <varname>intpart</varname> içine <command>2.0</command> değerini yerleştirir.
    </para></funcdescr></funcsynopsis></para></sect1>
    <sect1 xml:id="glibc-Remainder-Functions">
      <title>Kalan İşlevleri</title>
      <titleabbrev>Bölme işleminde kalan.</titleabbrev>
      <para>
Bu bölümdeki işlevler iki gerçek sayının birbirine bölünmesinden kalanı hesaplar. Her biri biraz farklıdır; sorunlarınıza çözüm olacak biri vardır.
    </para><para>
<indexterm scope="glibc-fn"><primary>fmod</primary></indexterm>
<indexterm scope="glibc-fn"><primary>fmodf</primary></indexterm>
<indexterm scope="glibc-fn"><primary>fmodl</primary></indexterm>
<funcsynopsis><funcdeflist role="işlev">
<funcprototype xml:id="glibc-fmod">
<funcdef>double <command>fmod</command></funcdef>
<paramdef>(double <varname>bölünen</varname>,
 double <varname>bölen</varname>)</paramdef>
</funcprototype><funcprototype xml:id="glibc-fmodf">
<funcdef>float <command>fmodf</command></funcdef>
<paramdef>(float <varname>bölünen</varname>,
 float <varname>bölen</varname>)</paramdef>
</funcprototype><funcprototype xml:id="glibc-fmodl">
<funcdef>long double <command>fmodl</command></funcdef>
<paramdef>(long double <varname>bölünen</varname>,
 long double <varname>bölen</varname>)</paramdef>
</funcprototype></funcdeflist><funcdescr><para>
Bu işlevler <varname>bölünen</varname>'in <varname>bölen</varname>'e bölünmesinden kalanı verir.  Yani, dönüş değeri <literal><emphasis>bölünen</emphasis> - <emphasis>bölüm</emphasis> * <emphasis>bölen</emphasis></literal> işleminin sonucudur. Örneğin, <command>fmod (6.5, 2.3)</command> çağrısı <command>1.9</command> ile döner. Bu işlev <emphasis>bölüm</emphasis>'ü sıfıra en yakın tamsayıya yuvarlayarak işlem yapar.
    </para><para>
İşlevin dönüş değeri <varname>bölünen</varname> ile aynı işaretlidir ve  <varname>bölen</varname>'den küçüktür.
    </para><para>
Eğer <varname>bölen</varname> sıfırsa, <command>fmod</command> bir saha hatası sinyaller.
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>drem</primary></indexterm>
<indexterm scope="glibc-fn"><primary>dremf</primary></indexterm>
<indexterm scope="glibc-fn"><primary>dreml</primary></indexterm>
<funcsynopsis><funcdeflist role="işlev">
<funcprototype xml:id="glibc-drem">
<funcdef>double <command>drem</command></funcdef>
<paramdef>(double <varname>bölünen</varname>,
 double <varname>bölen</varname>)</paramdef>
</funcprototype><funcprototype xml:id="glibc-dremf">
<funcdef>float <command>dremf</command></funcdef>
<paramdef>(float <varname>bölünen</varname>,
 float <varname>bölen</varname>)</paramdef>
</funcprototype><funcprototype xml:id="glibc-dreml">
<funcdef>long double <command>dreml</command></funcdef>
<paramdef>(long double <varname>bölünen</varname>,
 long double <varname>bölen</varname>)</paramdef>
</funcprototype></funcdeflist><funcdescr><para>
Bu işlevler <command>fmod</command> gibidir, farklı olarak <emphasis>bölüm</emphasis>'ü sıfıra en yakın tamsayıya değil, en yakın tamsayıya yuvarlayarak işlem yapar. Örneğin, <command>drem (6.5, 2.3)</command> çağrısı <command>-0.4</command> ile döner; burada yapılan işlem, <command>6.5</command> eksi <command>6.9</command>'dur.
    </para><para>
Sonucun mutlak değeri <varname>bölen</varname>'in mutlak değerine eşit ya da küçüktür. <command>fmod (<varname>bölünen</varname>, <varname>bölen</varname>) - drem (<varname>bölünen</varname>, <varname>bölen</varname>)</command> işleminin sonucu daima <varname>bölen</varname> veya eksi <varname>bölen</varname> ya da sıfırdır.
    </para><para>
Eğer <varname>bölen</varname> sıfırsa, <command>drem</command> bir saha hatası sinyaller.
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>remainder</primary></indexterm>
<indexterm scope="glibc-fn"><primary>remainderf</primary></indexterm>
<indexterm scope="glibc-fn"><primary>remainderl</primary></indexterm>
<funcsynopsis><funcdeflist role="işlev">
<funcprototype xml:id="glibc-remainder">
<funcdef>double <command>remainder</command></funcdef>
<paramdef>(double <varname>bölünen</varname>,
 double <varname>bölen</varname>)</paramdef>
</funcprototype><funcprototype xml:id="glibc-remainderf">
<funcdef>float <command>remainderf</command></funcdef>
<paramdef>(float <varname>bölünen</varname>,
 float <varname>bölen</varname>)</paramdef>
</funcprototype><funcprototype xml:id="glibc-remainderl">
<funcdef>long double <command>remainderl</command></funcdef>
<paramdef>(long double <varname>bölünen</varname>,
 long double <varname>bölen</varname>)</paramdef>
</funcprototype></funcdeflist><funcdescr><para>
<command>drem</command> işlevlerinin diğer isimleridir.
    </para></funcdescr></funcsynopsis></para></sect1>
    <sect1 xml:id="glibc-FP-Bit-Twiddling">
      <title>Kayan Noktalı Sayılarda İşaret Bitinin Ayarlanması</title>
      <titleabbrev>İşaret bitinin ayarlanması. Epsilon ekleme.</titleabbrev>
      <para>
<indexterm scope="glibc-cp"><primary>sayılar</primary><secondary>kayan noktalı aritmetik</secondary></indexterm>
Kayan noktalı sayılarda elle yapılamayacak kadar karmaşık ve zahmetli bazı işlemler vardır. ISO C99 bu işlemleri yapmak için işlevler tanımlamıştır. Bu işlevler çoğunlukla tek bitlik değişiklikler yaparlar.
    </para><para>
<indexterm scope="glibc-fn"><primary>copysign</primary></indexterm>
<indexterm scope="glibc-fn"><primary>copysignf</primary></indexterm>
<indexterm scope="glibc-fn"><primary>copysignl</primary></indexterm>
<funcsynopsis><funcdeflist role="işlev">
<funcprototype xml:id="glibc-copysign">
<funcdef>double <command>copysign</command></funcdef>
<paramdef>(double <varname>x</varname>,
 double <varname>y</varname>)</paramdef>
</funcprototype><funcprototype xml:id="glibc-copysignf">
<funcdef>float <command>copysignf</command></funcdef>
<paramdef>(float <varname>x</varname>,
 float <varname>y</varname>)</paramdef>
</funcprototype><funcprototype xml:id="glibc-copysignl">
<funcdef>long double <command>copysignl</command></funcdef>
<paramdef>(long double <varname>x</varname>,
 long double <varname>y</varname>)</paramdef>
</funcprototype></funcdeflist><funcdescr><para>
Bu işlevler <varname>x</varname> değerini <varname>y</varname>'nin işareti ile döndürür. <varname>x</varname> ya da <varname>y</varname> NaN ya da sıfır olsa bile bu işlevler çalışır, ayrıca her ikisinin de işareti olabilir (tüm gerçeklemeler bunu desteklemese de). Bu, farklı olduğu söylenebilecek bir kaç işlemden biridir.
    </para><para>
<command>copysign</command> hiçbir zaman bir olağandışılığa sebep olmaz.
    </para><para>
Bu işlev IEC 559'da tanımlanmıştır (ve IEEE 754/IEEE 854'de, eklerde, önerilen işlevlerden biri olarak).
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>signbit</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-signbit">
<funcdef>int <command>signbit</command></funcdef>
<paramdef>(<varname>bir-float-türü x</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>signbit</command> tüm gerçek sayı türleri ile çalışabilen soysal bir makrodur. <varname>x</varname> değerinin işaret biti birse işlev sıfırdan farklı bir değerle döner.
    </para><para>
Bu, <command>x &lt; 0.0</command> olacak anlamına gelmez, çünkü IEEE 754 kayan noktalılarında sıfırın işaretli olması mümkündür. <command>-0.0 &lt; 0.0</command> karşılaştırmasının sonucu yanlıştır, fakat <command>signbit (-0.0)</command> çağrısı daima sıfırdan farklı bir değerle döner.
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>nextafter</primary></indexterm>
<indexterm scope="glibc-fn"><primary>nextafterf</primary></indexterm>
<indexterm scope="glibc-fn"><primary>nextafterl</primary></indexterm>
<funcsynopsis><funcdeflist role="işlev">
<funcprototype xml:id="glibc-nextafter">
<funcdef>double <command>nextafter</command></funcdef>
<paramdef>(double <varname>x</varname>,
 double <varname>y</varname>)</paramdef>
</funcprototype><funcprototype xml:id="glibc-nextafterf">
<funcdef>float <command>nextafterf</command></funcdef>
<paramdef>(float <varname>x</varname>,
 float <varname>y</varname>)</paramdef>
</funcprototype><funcprototype xml:id="glibc-nextafterl">
<funcdef>long double <command>nextafterl</command></funcdef>
<paramdef>(long double <varname>x</varname>,
 long double <varname>y</varname>)</paramdef>
</funcprototype></funcdeflist><funcdescr><para>
<command>nextafter</command> işlevi <varname>x</varname>'in <varname>y</varname> değerine doğru gösterilebilir en yakın komşusu ile döner. Sonuç ile <varname>x</varname> arasındaki adım boyu sonucun türüne bağlıdır. Eğer <varname>x </varname><literal>= </literal><varname>y</varname> ise işlev basitçe <varname>y</varname> ile döner. Eğer ikisinden biri <command>NaN</command> ise <command>NaN</command> döner. Aksi takdirde ondalık kısım içindeki en kıymetli bitin değerine karşı düşen bir değer yöne bağlı olarak eklenir ya da çıkarılır. Eğer sonuç normalleştirilmiş sayılar aralığının dışına çıkarsa işlev üstten ya da alttan taşma olağandışılığını sinyaller.
    </para><para>
Bu işlev IEC 559'da tanımlanmıştır (ve IEEE 754/IEEE 854'de, eklerde, önerilen işlevlerden biri olarak).
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>nexttoward</primary></indexterm>
<indexterm scope="glibc-fn"><primary>nexttowardf</primary></indexterm>
<indexterm scope="glibc-fn"><primary>nexttowardl</primary></indexterm>
<funcsynopsis><funcdeflist role="işlev">
<funcprototype xml:id="glibc-nexttoward">
<funcdef>double <command>nexttoward</command></funcdef>
<paramdef>(double      <varname>x</varname>,
 long double <varname>y</varname>)</paramdef>
</funcprototype><funcprototype xml:id="glibc-nexttowardf">
<funcdef>float <command>nexttowardf</command></funcdef>
<paramdef>(float       <varname>x</varname>,
 long double <varname>y</varname>)</paramdef>
</funcprototype><funcprototype xml:id="glibc-nexttowardl">
<funcdef>long double <command>nexttowardl</command></funcdef>
<paramdef>(long double <varname>x</varname>,
 long double <varname>y</varname>)</paramdef>
</funcprototype></funcdeflist><funcdescr><para>
Bu işlevler <command>nextafter</command> ailesi işlevlere benzer, farklı olarak ikinci argüman <command>long
double</command> türünde bir değerdir.
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-cp"><primary>NaN</primary></indexterm>
<indexterm scope="glibc-fn"><primary>nan</primary></indexterm>
<indexterm scope="glibc-fn"><primary>nanf</primary></indexterm>
<indexterm scope="glibc-fn"><primary>nanl</primary></indexterm>
<funcsynopsis><funcdeflist role="işlev">
<funcprototype xml:id="glibc-nan">
<funcdef>double <command>nan</command></funcdef>
<paramdef>(const char *<varname>tagp</varname>)</paramdef>
</funcprototype><funcprototype xml:id="glibc-nanf">
<funcdef>float <command>nanf</command></funcdef>
<paramdef>(const char *<varname>tagp</varname>)</paramdef>
</funcprototype><funcprototype xml:id="glibc-nanl">
<funcdef>long double <command>nanl</command></funcdef>
<paramdef>(const char *<varname>tagp</varname>)</paramdef>
</funcprototype></funcdeflist><funcdescr><para>
<command>nan</command> işlevi hedef platform tarafından desteklenen NaN gösterimi ile döner. <command>nan (&quot;<varname>karakterler</varname>&quot;)</command> ile <command>strtod (&quot;NAN(<varname>karakterler</varname>)&quot;)</command> eşdeğerdir.
    </para><para>
<varname>tagp</varname> argümanı olarak belirtilebilecekler belirlenmemiştir denebilir. IEEE 754 sistemlerde bir çok NaN gösterimi vardır ve <varname>tagp</varname> ile bunlardan biri seçilir. Diğer sistemlerde işlev hiçbir şey yapmaz.
    </para></funcdescr></funcsynopsis></para></sect1>
    <sect1 xml:id="glibc-FP-Comparison-Functions">
      <title>Gerçek Sayı Karşılaştırma İşlevleri</title>
      <titleabbrev>Bir olağandışılık oluşturmadan nasıl karşılaştıma yapılır.</titleabbrev>
      <para>
<indexterm scope="glibc-cp"><primary>sayılar</primary><secondary>düzensiz karşılaştırma</secondary></indexterm>
Standart C karşılaştırma işlevleri terimlerden biri NaN olduğunda bir olağandışılık tetikler. örneğin,
    </para><para>
<screen>int v = a &lt; 1.0;</screen>
    </para><para>
ifadesinde <varname>a</varname> bir sayı değilse bir olağandışılık oluşur. (Olağandışılık,  karşılaştıma <command>==</command> ve <command>!=</command> işleçleriyle yapıldığında oluşmaz; sadece sırasıyla yanlış ve doğru döner.) Çoğunlukla bu olağandışılığın oluşması istenmez. Bu bakımdan, ISO C99 NaN saptandığında olağandışılık oluşturmayan karşılaştıma işlevleri tanımlamıştır. Tüm işlevler argümanları herhangi bir gerçek sayı veri türünde olabilen makrolar olarak gerçeklenmiştir. Makrolar argümanlarının sadece bir kere değerlendirileceğini garanti eder (yani aradeğer yuvarlaması yapılmaz).
    </para><para>
<indexterm scope="glibc-fn"><primary>isgreater</primary></indexterm>
<funcsynopsis><funcprototype role="makro" xml:id="glibc-isgreater">
<funcdef>int <command>isgreater</command></funcdef>
<paramdef>(<varname>bir-float-tür x</varname>,
 <varname>bir-float-tür y</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu makro <varname>x</varname> argümanının <varname>y</varname> argümanından büyük olup olmadığına bakar. <command>(<varname>x</varname>) > (<varname>y</varname>)</command> ifadesine eşdeğerdir, fakat argümanlarından birinin bir sayı olmaması durumunda bir olağandışılık oluşturmaz.
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>isgreaterequal</primary></indexterm>
<funcsynopsis><funcprototype role="makro" xml:id="glibc-isgreaterequal">
<funcdef>int <command>isgreaterequal</command></funcdef>
<paramdef>(<varname>bir-float-tür x</varname>,
 <varname>bir-float-tür y</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu makro <varname>x</varname> argümanının <varname>y</varname> argümanından büyük ya da eşit olup olmadığına bakar. <command>(<varname>x</varname>) >= (<varname>y</varname>)</command> ifadesine eşdeğerdir, fakat argümanlarından birinin bir sayı olmaması durumunda bir olağandışılık oluşturmaz.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>isless</primary></indexterm>
<funcsynopsis><funcprototype role="makro" xml:id="glibc-isless">
<funcdef>int <command>isless</command></funcdef>
<paramdef>(<varname>bir-float-tür x</varname>,
 <varname>bir-float-tür y</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu makro <varname>x</varname> argümanının <varname>y</varname> argümanından küçük olup olmadığına bakar. <command>(<varname>x</varname>) &lt; (<varname>y</varname>)</command> ifadesine eşdeğerdir, fakat argümanlarından birinin bir sayı olmaması durumunda bir olağandışılık oluşturmaz.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>islessequal</primary></indexterm>
<funcsynopsis><funcprototype role="makro" xml:id="glibc-islessequal">
<funcdef>int <command>islessequal</command></funcdef>
<paramdef>(<varname>bir-float-tür x</varname>,
 <varname>bir-float-tür y</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu makro <varname>x</varname> argümanının <varname>y</varname> argümanından küçük ya da eşit olup olmadığına bakar. <command>(<varname>x</varname>) &lt;= (<varname>y</varname>)</command> ifadesine eşdeğerdir, fakat argümanlarından birinin bir sayı olmaması durumunda bir olağandışılık oluşturmaz.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>islessgreater</primary></indexterm>
<funcsynopsis><funcprototype role="makro" xml:id="glibc-islessgreater">
<funcdef>int <command>islessgreater</command></funcdef>
<paramdef>(<varname>bir-float-tür x</varname>,
 <varname>bir-float-tür y</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu makro <varname>x</varname> argümanının <varname>y</varname> argümanından küçük ya da büyük olup olmadığına bakar. <command>(<varname>x</varname>) &lt; (<varname>y</varname>) || (<varname>x</varname>) > (<varname>y</varname>)</command> ifadesine eşdeğerdir (ama makroda <varname>x</varname> ve <varname>y</varname> sadece bir kere işleme sokulur), fakat argümanlarından birinin bir sayı olmaması durumunda bir olağandışılık oluşturmaz.
    </para><para>
Bu makro <command><varname>x</varname> != <varname>y</varname></command> ifadesine eşdeğerdir, çünkü terimlerden biri bir sayı değilse ifadenin sonucu doğru olacaktır.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>isunordered</primary></indexterm>
<funcsynopsis><funcprototype role="makro" xml:id="glibc-isunordered">
<funcdef>int <command>isunordered</command></funcdef>
<paramdef>(<varname>bir-float-tür x</varname>,
 <varname>bir-float-tür y</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu makro argümanlarının NaN olup olmadığına bakar. <varname>x</varname> ya da <varname>x</varname> bir sayı değilse doğru, aksi takdirde yanlış döner.
</para></funcdescr></funcsynopsis></para><para>
Tüm makineler bu işlemlere donanım desteği sağlamaz. Bu bakımdan, NaN ile işiniz yoksa bu işlevleri kullanmamalısınız.
    </para><para>
<note><para><command>isequal</command> veya <command>isunequal</command> makroları yoktur. Çünkü <command>==</command> ve <command>!=</command> işleçleri terimlerden birinin bir sayı olmaması durumunda bir olağandışılık oluşturmadıklarından bunlar için birer makro gereksizdir.</para></note>
    </para></sect1>
    <sect1 xml:id="glibc-Misc-FP-Arithmetic">
      <title>Çeşitli Gerçek Sayı Aritmetik İşlevleri</title>
      <titleabbrev>En büyük, en küçük, pozitif fark, çarpıp toplama.</titleabbrev>
      <para>
<indexterm scope="glibc-cp"><primary>sayılar</primary><secondary>en küçük</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>sayılar</primary><secondary>en büyük</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>sayılar</primary><secondary>pozitif fark</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>sayılar</primary><secondary>çarpıp toplama</secondary></indexterm>
Bu bölümdeki işlevler C işleçleriyle yapıldığında kullanışsız olan bazı işlemleri yaparlar. Bazı işlemcilerde bu işlevlerin yaptığı işlemleri eşdeğer C kodundan daha hızlı yapan özel makine komutları vardır ve bu işlevler onları kullanabilmektedir.
    </para><para>
<indexterm scope="glibc-fn"><primary>fmin</primary></indexterm>
<indexterm scope="glibc-fn"><primary>fminf</primary></indexterm>
<indexterm scope="glibc-fn"><primary>fminl</primary></indexterm>
<funcsynopsis><funcdeflist role="işlev">
<funcprototype xml:id="glibc-fmin">
<funcdef>double <command>fmin</command></funcdef>
<paramdef>(double <varname>x</varname>,
 double <varname>y</varname>)</paramdef>
</funcprototype><funcprototype xml:id="glibc-fminf">
<funcdef>float <command>fminf</command></funcdef>
<paramdef>(float <varname>x</varname>,
 float <varname>y</varname>)</paramdef>
</funcprototype><funcprototype xml:id="glibc-fminl">
<funcdef>long double <command>fminl</command></funcdef>
<paramdef>(long double <varname>x</varname>,
 long double <varname>y</varname>)</paramdef>
</funcprototype></funcdeflist><funcdescr><para>
<command>fmin</command> işlevi <varname>x</varname> ve <varname>y</varname> değerlerinden daha küçük olanla döner.
    </para><para>
<literallayout indent="0">
    ((x) &lt; (y) ? (x) : (y))
</literallayout>
     </para><para>
ifadesine benzer bir işlem yapar ama <varname>x</varname> ve <varname>y</varname> sadece bir kere işleme sokulur.
    </para><para>
Eğer argümanlardan biri bir sayı değilse, diğer argüman döner. Her iki argüman da NaN ise NaN döner.
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>fmax</primary></indexterm>
<indexterm scope="glibc-fn"><primary>fmaxf</primary></indexterm>
<indexterm scope="glibc-fn"><primary>fmaxl</primary></indexterm>
<funcsynopsis><funcdeflist role="işlev">
<funcprototype xml:id="glibc-fmax">
<funcdef>double <command>fmax</command></funcdef>
<paramdef>(double <varname>x</varname>,
 double <varname>y</varname>)</paramdef>
</funcprototype><funcprototype xml:id="glibc-fmaxf">
<funcdef>float <command>fmaxf</command></funcdef>
<paramdef>(float <varname>x</varname>,
 float <varname>y</varname>)</paramdef>
</funcprototype><funcprototype xml:id="glibc-fmaxl">
<funcdef>long double <command>fmaxl</command></funcdef>
<paramdef>(long double <varname>x</varname>,
 long double <varname>y</varname>)</paramdef>
</funcprototype></funcdeflist><funcdescr><para>
<command>fmax</command> işlevi <varname>x</varname> ve <varname>y</varname> değerlerinden daha büyük olanla döner.
    </para><para>
Eğer argümanlardan biri bir sayı değilse, diğer argüman döner. Her iki argüman da NaN ise NaN döner.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>fdimf</primary></indexterm>
<indexterm scope="glibc-fn"><primary>fdim</primary></indexterm>
<indexterm scope="glibc-fn"><primary>fdiml</primary></indexterm>
<funcsynopsis><funcdeflist role="işlev">
<funcprototype xml:id="glibc-fdim">
<funcdef>double <command>fdim</command></funcdef>
<paramdef>(double <varname>x</varname>,
 double <varname>y</varname>)</paramdef>
</funcprototype><funcprototype xml:id="glibc-fdimf">
<funcdef>float <command>fdimf</command></funcdef>
<paramdef>(float <varname>x</varname>,
 float <varname>y</varname>)</paramdef>
</funcprototype><funcprototype xml:id="glibc-fdiml">
<funcdef>long double <command>fdiml</command></funcdef>
<paramdef>(long double <varname>x</varname>,
 long double <varname>y</varname>)</paramdef>
</funcprototype></funcdeflist><funcdescr><para>
<command>fdim</command> işlevi <varname>x</varname> ve <varname>y</varname> arasındaki pozitif farkla döner. <varname>x</varname> - <varname>y</varname> işleminde <varname>x </varname><literal>> </literal><varname>y</varname> ise işlemin sonucu olan pozitif fark döner, değilse 0 döner.
    </para><para>
Eğer argümanlardan biri ya da her ikisi de NaN ise NaN döner.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-cp"><primary>butterfly</primary></indexterm>
<indexterm scope="glibc-fn"><primary>fma</primary></indexterm>
<indexterm scope="glibc-fn"><primary>fmaf</primary></indexterm>
<indexterm scope="glibc-fn"><primary>fmal</primary></indexterm>
<funcsynopsis><funcdeflist role="işlev">
<funcprototype xml:id="glibc-fma">
<funcdef>double <command>fma</command></funcdef>
<paramdef>(double <varname>x</varname>,
 double <varname>y</varname>,
 double <varname>z</varname>)</paramdef>
</funcprototype><funcprototype xml:id="glibc-fmaf">
<funcdef>float <command>fmaf</command></funcdef>
<paramdef>(float <varname>x</varname>,
 float <varname>y</varname>,
 float <varname>z</varname>)</paramdef>
</funcprototype><funcprototype xml:id="glibc-fmal">
<funcdef>long double <command>fmal</command></funcdef>
<paramdef>(long double <varname>x</varname>,
 long double <varname>y</varname>,
 long double <varname>z</varname>)</paramdef>
</funcprototype></funcdeflist><funcdescr><para>
<command>fma</command> işlevi gerçek sayılarla çarpıp toplama işlemi yapar. İşlev, (<varname>x</varname> * <varname>y</varname>) + <varname>z</varname> işlemini yapar ama ara sonuç hedef türe yuvarlanmaz.
    </para><para>
Bazı işlemciler bu işlemi gerçekleştiren özel komutlara sahip olduğundan bu işlev tasarlanmıştır. C derleyicisi bu işlemi bir defada yapamaz, çünkü <command>x*y + z</command> ifadesinde ara sonuç yuvarlanır. İşlemin bir defada ve hassasiyet kaybı olmadan yapılmasını istiyorsanız <command>fma</command> işlevini seçin.
    </para><para>
<indexterm scope="glibc-vr"><primary>FP_FAST_FMA</primary></indexterm>
Çarpıp toplama işleminin donanımda gerçeklenmediği işlemcilerde, <command>fma</command> işlevi ara sonuç yuvarlamasından kaçınmak zorunda olduğundan çok yavaş çalışacaktır. <filename>math.h</filename> dosyasında <command>x*y + z</command> ifadesinden daha yavaş olmayan <command>fma</command> işlevinin sonuç türüne bağlı olarak <command>FP_FAST_FMA</command>, <command>FP_FAST_FMAF</command> ve <command>FP_FAST_FMAL</command> sembolleri tanımlanmıştır. GNU C kütüphanesinde bu, işlemin daima donanımda gerçeklendiği anlamına gelir.
      </para></funcdescr></funcsynopsis></para>
    </sect1>
  </chapter>

<chapter xml:id="glibc-Complex-Numbers">
  <title>Karmaşık Sayılar</title>
  <titleabbrev>Türler. Karmaşık sabitlerin yazılması.</titleabbrev>
  <para>
<indexterm scope="glibc-pg"><primary>complex.h</primary></indexterm>
<indexterm scope="glibc-cp"><primary>sayılar</primary><secondary>karmaşık sayılar</secondary></indexterm>
ISO C99 standardı ile C'de karmaşık sayılar için destek geldi. Bu yeni bir tür, <command>complex</command> ile sağlandı.  Sadece <filename>complex.h</filename> dosyası yazılıma dahil edildiğinde geçerli olan bir anahtar sözcüktür. Karmaşık sayı türleri üç tanedir ve üç gerçek sayı türüne karşılıktır: <command>float complex</command>, <command>double complex</command>, and <command>long double complex</command>.
   </para><para>
Karmaşık sayıları oluşturabilmek için sayının sanal kısmını belirtecek bir yöntem gerekir. Sanal gerçek sayı sabitler için standart bir sembolleştirme yöntemi yoktur. Bunun yerine, <filename>complex.h</filename> dosyasında karmaşık sayıları oluşturmakta kullanılabilen iki makro tanımlanmıştır.
   </para><para>
<indexterm scope="glibc-vr"><primary sortas="Complex_I">_Complex_I</primary></indexterm>
<funcsynopsis><funcprototype role="makro" xml:id="glibc_Complex_I">
<funcdef>const float complex <command>_Complex_I</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu makro <literal>0 + 1i</literal> karmaşık sayısının bir gösterimidir. Bir gerçek sayının <command>_Complex_I</command> ile çarpılması tamamen sanal kısımdan oluşan bir karmaşık sayı verir.  Bunu karmaşık sabitleri oluşturmakta kullanabilirsiniz:
   </para><para>
<screen>3.0 + 4.0i = 3.0 + 4.0 * _Complex_I</screen>
   </para><para>
<command>_Complex_I * _Complex_I</command> çarpımının <command>-1</command> değerini vereceğine ama bu değerin <command>complex</command> türünde olacağına dikkat edin.
</para></funcdescr></funcsynopsis></para><para>
<command>_Complex_I</command> söylenmesi de yazılması da biraz zor bir sözcüktür.  <filename>complex.h</filename> dosyasında aynı sabit için bir de daha kısa bir isim tanımlanmıştır.
   </para><para>
<indexterm scope="glibc-vr"><primary>I</primary></indexterm>
<funcsynopsis><funcprototype role="makro" xml:id="glibc-I">
<funcdef>const float complex <command>I</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu makro <command>_Complex_I</command> ile tamamen aynı değerdedir. Çoğu zaman tercih edilir. Ancak, yazılımın herhangi bir yerinde <command>I</command>'yi bir belirteç olarak kullanırsanız sorun çıkar. <command>I</command>'yi kendi amaçlarınız için kullanmak isterseniz basitçe şunu yazabilirsiniz:
   </para><para>
<screen>#include &lt;complex.h>
#undef I
</screen></para><para>
Böyle bir durumda, <command>_Complex_I</command> için başka bir kısa isim (örneğin, <command>J</command>) tanımlamanız önerilir.
  </para></funcdescr></funcsynopsis></para></chapter>
  <chapter xml:id="glibc-Operations-on-Complex">
    <title>Karmaşık Sayıların İzdüşümleri, Eşlenikleri ve Analizi</title>
    <para>
<indexterm scope="glibc-cp"><primary>sayılar</primary><secondary>karmaşık sayılar</secondary><tertiary>izdüşümleri</tertiary></indexterm>
<indexterm scope="glibc-cp"><primary>sayılar</primary><secondary>karmaşık sayılar</secondary><tertiary>eşlenikleri</tertiary></indexterm>
<indexterm scope="glibc-cp"><primary>sayılar</primary><secondary>karmaşık sayılar</secondary><tertiary>analizi</tertiary></indexterm>
<indexterm scope="glibc-pg"><primary>complex.h</primary></indexterm>
<indexterm scope="glibc-cp"><primary>karmaşık sayılar</primary><secondary>izdüşümleri</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>karmaşık sayılar</primary><secondary>eşlenikleri</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>karmaşık sayılar</primary><secondary>analizi</secondary></indexterm>
<indexterm scope="glibc-pg"><primary>complex.h</primary></indexterm>
ISO C99 ayrıca, karmaşık sayıların temel işlemlerini (kısımlarına ayırmak, eşleniğini almak gibi) yapmak için işlevler de tanımlamıştır. Bu işlevler <filename>complex.h</filename> dosyasında bildirilmiştir.  Tüm işlevlerin 3 karmaşık sayı türünün herbiri için bir eşdeğeri vardır.
   </para><para>
<indexterm scope="glibc-fn"><primary>creal</primary></indexterm>
<indexterm scope="glibc-fn"><primary>crealf</primary></indexterm>
<indexterm scope="glibc-fn"><primary>creall</primary></indexterm>
<funcsynopsis><funcdeflist role="işlev">
<funcprototype xml:id="glibc-creal">
<funcdef>double <command>creal</command></funcdef>
<paramdef>(complex double <varname>z</varname>)</paramdef>
</funcprototype><funcprototype xml:id="glibc-crealf">
<funcdef>float <command>crealf</command></funcdef>
<paramdef>(complex float <varname>z</varname>)</paramdef>
</funcprototype><funcprototype xml:id="glibc-creall">
<funcdef>long double <command>creall</command></funcdef>
<paramdef>(complex long double <varname>z</varname>)</paramdef>
</funcprototype></funcdeflist><funcdescr><para>
Bu işlevler <varname>z</varname> karmaşık sayısının gerçel kısmı ile döner.
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>cimag</primary></indexterm>
<indexterm scope="glibc-fn"><primary>cimagf</primary></indexterm>
<indexterm scope="glibc-fn"><primary>cimagl</primary></indexterm>
<funcsynopsis><funcdeflist role="işlev">
<funcprototype xml:id="glibc-cimag">
<funcdef>double <command>cimag</command></funcdef>
<paramdef>(complex double <varname>z</varname>)</paramdef>
</funcprototype><funcprototype xml:id="glibc-cimagf">
<funcdef>float <command>cimagf</command></funcdef>
<paramdef>(complex float <varname>z</varname>)</paramdef>
</funcprototype><funcprototype xml:id="glibc-cimagl">
<funcdef>long double <command>cimagl</command></funcdef>
<paramdef>(complex long double <varname>z</varname>)</paramdef>
</funcprototype></funcdeflist><funcdescr><para>
Bu işlevler <varname>z</varname> karmaşık sayısının sanal kısmı ile döner.
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>conj</primary></indexterm>
<indexterm scope="glibc-fn"><primary>conjf</primary></indexterm>
<indexterm scope="glibc-fn"><primary>conjl</primary></indexterm>
<funcsynopsis><funcdeflist role="işlev">
<funcprototype xml:id="glibc-conj">
<funcdef>complex double <command>conj</command></funcdef>
<paramdef>(complex double <varname>z</varname>)</paramdef>
</funcprototype><funcprototype xml:id="glibc-conjf">
<funcdef>complex float <command>conjf</command></funcdef>
<paramdef>(complex float <varname>z</varname>)</paramdef>
</funcprototype><funcprototype xml:id="glibc-conjl">
<funcdef>complex long double <command>conjl</command></funcdef>
<paramdef>(complex long double <varname>z</varname>)</paramdef>
</funcprototype></funcdeflist><funcdescr><para>
Bu işlevler <varname>z</varname> karmaşık sayısının eşleniği ile döner. Eşlenik karmaşık sayılar, gerçel kısımları aynı, sanal kısımları ise ters işaretli olarak aynı olan birer karmaşık sayıdır. Başka bir deyişle, eşlenik karmaşık sayılar karmaşık düzlemde gerçel eksene göre simetriktir. Yani, <command>conj(a + bi) = a - bi</command>'dir.
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>carg</primary></indexterm>
<indexterm scope="glibc-fn"><primary>cargf</primary></indexterm>
<indexterm scope="glibc-fn"><primary>cargl</primary></indexterm>
<funcsynopsis><funcdeflist role="işlev">
<funcprototype xml:id="glibc-carg">
<funcdef>double <command>carg</command></funcdef>
<paramdef>(complex double <varname>z</varname>)</paramdef>
</funcprototype><funcprototype xml:id="glibc-cargf">
<funcdef>float <command>cargf</command></funcdef>
<paramdef>(complex float <varname>z</varname>)</paramdef>
</funcprototype><funcprototype xml:id="glibc-cargl">
<funcdef>long double <command>cargl</command></funcdef>
<paramdef>(complex long double <varname>z</varname>)</paramdef>
</funcprototype></funcdeflist><funcdescr><para>
Bu işlev <varname>z</varname> karmaşık sayısının kutupsal koordinatlardaki argümanı ile döner. Argüman, karmaşık düzlemde karmaşık sayının oluşturduğu vektörün pozitif gerçel eksenle oluşturduğu açıdır. Bu açı radyan cinsinden 0 ile 2pi arasındadır.
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>cproj</primary></indexterm>
<indexterm scope="glibc-fn"><primary>cprojf</primary></indexterm>
<indexterm scope="glibc-fn"><primary>cprojl</primary></indexterm>
<funcsynopsis><funcdeflist role="işlev">
<funcprototype xml:id="glibc-cproj">
<funcdef>complex double <command>cproj</command></funcdef>
<paramdef>(complex double <varname>z</varname>)</paramdef>
</funcprototype><funcprototype xml:id="glibc-cprojf">
<funcdef>complex float <command>cprojf</command></funcdef>
<paramdef>(complex float <varname>z</varname>)</paramdef>
</funcprototype><funcprototype xml:id="glibc-cprojl">
<funcdef>complex long double <command>cprojl</command></funcdef>
<paramdef>(complex long double <varname>z</varname>)</paramdef>
</funcprototype></funcdeflist><funcdescr><para>
Bu işlevler <varname>z</varname> karmaşık sayısının Riemann küresindeki izdüşümü ile döner. Sonsuz sanal kısımlı değerlerin gerçel eksende (gerçel kısım NaN olsa bile) pozitif sonsuza izdüşümü alınır. Eğer gerçel kısım sonsuzsa sonuç şuna eşdeğerdir:
   </para><para>
<screen>INFINITY + I * copysign (0.0, cimag (z))</screen>
</para></funcdescr></funcsynopsis></para></chapter>
<chapter xml:id="glibc-Parsing-of-Numbers">
  <title>Dizgelerdeki Sayıların Çözümlenmesi</title>
  <titleabbrev>Dizgelerin sayılara dönüştürülmesi.</titleabbrev>
  <para>
<indexterm scope="glibc-cp"><primary>sayılar</primary><secondary>biçimli girdi</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>sayılar</primary><secondary>dizgelerden dönüştürme</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>sayılar</primary><secondary>sözdizimi</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>sayılar</primary><secondary>okunması</secondary></indexterm>
Bu bölümdeki işlevler tamsayıların ya da gerçek sayıların dizgelerden okunması için kullanılır. Bu işlem için <command>sscanf</command> veya ilgili işlevler kullanmak daha iyi olabilir; bkz. <xref linkend="glibc-Formatted-Input"/>.  Fakat dizge içindeki dizgecikleri elle bulup onları tek tek sayılara dönüştürmek yazılımı daha güçü yapabilirr.
   </para>
  <sect1 xml:id="glibc-Parsing-of-Integers">
    <title>Tamsayıların Çözümlenmesi</title>
    <titleabbrev>Tamsayı dönüşüm işlevleri.</titleabbrev>
    <para>
<indexterm scope="glibc-pg"><primary>stdlib.h</primary></indexterm>
<indexterm scope="glibc-pg"><primary>wchar.h</primary></indexterm>
<command>str</command> işlevleri <filename>stdlib.h</filename> dosyasında, <command>wcs</command> ile başlayanlar ise <filename>wchar.h</filename> dosyasında bildirilmiştir.  Bu bölümdeki işlevlerin prototiplerinde <command>restrict</command> kullanımı şaşırtıcı olabilir. Kullanışsız görünür ama ISO C standardı onu kullandığı için (burada tanımlı işlevler için) biz de kullandık.
    </para><para>
<indexterm scope="glibc-fn"><primary>strtol</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-strtol">
<funcdef>long int <command>strtol</command></funcdef>
<paramdef>(const char *restrict <varname>dizge</varname>,
 char **restrict      <varname>kalan-dizge</varname>,
 int                  <varname>taban</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>strtol</command> (&quot;string-to-long&quot; kısaltması) işlevi <varname>dizge</varname> dizgesinin baştarafını bir işaretli tamsayıya dönüştürür ve sonucu <command>long int</command> türünde bir değer olarak döndürür.
    </para><para>
İşlev <varname>dizge</varname>'yi şu şekilde analiz etmeye çalışır:
    </para><itemizedlist><listitem><para>
Boşluk karakterlerinden oluşan bir dizge (muhtemelen boş). Boşluk karakterleri <command>isspace</command> işlevi ile saptanır ve bunlar iptal edilir (bkz. <xref linkend="glibc-Classification-of-Characters"/>).
      </para></listitem><listitem><para>
İsteğe bağlı artı ya da eksi işareti (<command>+</command> veya <command>-</command>).
      </para></listitem><listitem><para>
Tabanı <varname>taban</varname> ile belirtilen aralarında boşluk olmayan rakamlar.
      </para><para>
<varname>taban</varname> sıfırsa, rakam dizgesi <command>0</command> (sekizlik taban belirtir) ile ya da <command>0x</command> veya <command>0X</command> (onaltılık taban belirtir)ile başlamıyorsa rakamların onluk tabanda verildiği varsayılır; yani C'deki tamsayı sabit sözdizimi kullanılır.
      </para><para>
Aksi takdirde <varname>taban</varname>, <command>2</command> ile <command>36</command> arasında olmalıdır. Eğer <varname>taban</varname> olarak <command>16</command> verilmişse, rakam dizgesi isteğe bağlı olarak <command>0x</command> veya <command>0X</command> ile başlayabilir.  Eğer taban olarak kuraldışı bir değer belirtilmişse <command>0l</command> değeri dömer ve <command>errno</command> değişkenine <command>EINVAL</command> atanır.
      </para></listitem><listitem><para>
Dizgede kalan karakterler. Eğer <varname>kalan-dizge</varname> bir boş gösterici değilse işlev bu artıkları <varname>*kalan-dizge</varname> içine yerleştirir.
      </para></listitem></itemizedlist><para>
Eğer dizge boşsa, sadece boşluk karakterleri içeriyorsa ya da başlangıçtaki altdizge <varname>taban</varname> ile belirtilen bir tamsayı için umulan sözdizimine sahip değilse hiçbir dönüşüm yapılmaz. Bu durumda, işlev sıfırla döner ve <varname>dizge</varname> değeri <varname>*kalan-dizge</varname> içine yerleştirir.
    </para><para>
Yerel, standart <command>&quot;C&quot;</command> yerelinden farklıysa, bu işlev gerçeklemeye bağlı olarak ek sözdizimini tanıyabilir.
    </para><para>
Eğer dizge geçerli sözdizimine sahip olduğu halde taşmadan dolayı değer gösterilemiyorsa, değerin işaretine bağlı olarak <command>LONG_MAX</command> ya da <command>LONG_MIN</command> döner (bkz. <xref linkend="glibc-Range-of-Type"/>).  Ayrıca taşmayı belirtmek üzere <command>errno</command> değişkenine <command>ERANGE</command> atanır.
    </para><para>
<command>strtol</command> işlevinin döndürdüğü değere bakarak hata sınaması yapmayın, çünkü dizge  <command>0l</command>, <command>LONG_MAX</command> veya <command>LONG_MIN</command> gibi sözdizimsel olarak geçerli bir sayı olabilir. Bunun yerine <varname>kalan-dizge</varname>'nin gösterdiği dizgenin sayıdan sonra umduğunuz dizgeyi içerip içermediğine bakın. Örneğin dizge sayıdan sonra başka bir karakter içermiyorsa dönüş değerinde <command>'\0'</command> varlığına bakarsınız. Ayrıca çağrı öncesi <varname>errno</varname> değişkenine sıfır atayıp çağrıdan sonra değişkenin değerine bakarak taşma durumu olup olmadığını saptayabilirsiniz.
    </para><para>
Bu bölümün sonunda bir örnek bulacaksınız.
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>wcstol</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-wcstol">
<funcdef>long int <command>wcstol</command></funcdef>
<paramdef>(const wchar_t *restrict <varname>dizge</varname>,
 wchar_t **restrict      <varname>kalan-dizge</varname>,
 int                     <varname>taban</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>wcstol</command> işlevi geniş karakter kabul etmesi dışında hemen herşeyiyle <command>strtol</command> işlevine benzer.
    </para><para>
<command>wcstol</command> işlevi ISO C90'ın 1. düzeltmesinde vardı.
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>strtoul</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-strtoul">
<funcdef>unsigned long int <command>strtoul</command></funcdef>
<paramdef>(const char *retrict <varname>dizge</varname>,
 char **restrict     <varname>kalan-dizge</varname>,
 int                 <varname>taban</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>strtoul</command> (&quot;string-to-unsigned-long&quot; kısaltması) işlevi sonucu bir <command>unsigned long int</command> değer olarak döndürmesi dışında  <command>strtol</command> işlevi gibidir. Sözdizimi <command>strtol</command> işlevindeki gibidir.  Taşma durumunda dönüş değeri <command>ULONG_MAX</command>'tır (bkz. <xref linkend="glibc-Range-of-Type"/>).
    </para><para>
<varname>dizge</varname> içinde bir negatif sayı varsa, <command>strtoul</command> işlevi <varname>strtol</varname> işlevi gibi davranır ama sonucu bir işaretsiz tamsayıya dönüştürür. Örneğin, işlev <command>&quot;-1&quot;</command> dizgesi için <command>ULONG_MAX</command> ile, girdi <command>LONG_MIN</command>'den daha negatifse (<command>ULONG_MAX</command> + 1) / 2 ile döner.
    </para><para>
Eğer <varname>taban</varname> kapsamdışı ise işlev <varname>errno</varname> değişkenine <command>EINVAL</command> değerini, taşma durumunda ise <command>ERANGE</command> değerini atar.
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>wcstoul</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-wcstoul">
<funcdef>unsigned long int <command>wcstoul</command></funcdef>
<paramdef>(const wchar_t *restrict <varname>dizge</varname>,
 wchar_t **restrict      <varname>kalan-dizge</varname>,
 int                     <varname>taban</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>wcstoul</command> işlevi geniş karakteleri kabul etmesi dışında hemen herşeyiyle <command>strtoul</command> işlevinin benzeridir.
    </para><para>
<command>wcstoul</command> işlevi ISO C90'ın 1. düzeltmesinde vardı.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>strtoll</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-strtoll">
<funcdef>long long int <command>strtoll</command></funcdef>
<paramdef>(const char *restrict <varname>dizge</varname>,
 char **restrict      <varname>kalan-dizge</varname>,
 int                  <varname>taban</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>strtoll</command> işlevi daha büyük değer kabul ederek sonucu <command>long long int</command> türünde bir değer olarak döndürmesi dışında <command>strtol</command> gibidir.
    </para><para>
Eğer dizge geçerli sözdizimine sahip olduğu halde taşmadan dolayı değer gösterilemiyorsa, değerin işaretine bağlı olarak <command>LONG_LONG_MAX</command> ya da <command>LONG_LONG_MIN</command> döner (bkz. <xref linkend="glibc-Range-of-Type"/>).  Ayrıca taşmayı belirtmek üzere <command>errno</command> değişkenine <command>ERANGE</command> atanır.
    </para><para>
<command>strtoll</command> işlevi ISO C99'da tanıtıldı.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>wcstoll</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-wcstoll">
<funcdef>long long int <command>wcstoll</command></funcdef>
<paramdef>(const wchar_t *restrict <varname>dizge</varname>,
 wchar_t **restrict      <varname>kalan-dizge</varname>,
 int                     <varname>taban</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>wcstoll</command> işlevi geniş karakter kabul etmesi dışında hemen herşeyiyle <command>strtoll</command> işlevine benzer.
    </para><para>
<command>wcstoll</command> işlevi ISO C90'ın 1. düzeltmesinde vardı.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>strtoq</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-strtoq">
<funcdef>long long int <command>strtoq</command></funcdef>
<paramdef>(const char *restrict <varname>dizge</varname>,
 char **restrict      <varname>kalan-dizge</varname>,
 int                  <varname>taban</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>strtoq</command> (&quot;string-to-quad-word&quot; kısaltması) işlevi<command>strtoll</command> işlevinin BSD ismidir.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>wcstoq</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-wcstoq">
<funcdef>long long int <command>wcstoq</command></funcdef>
<paramdef>(const wchar_t *restrict <varname>dizge</varname>,
 wchar_t **restrict      <varname>kalan-dizge</varname>,
 int                     <varname>taban</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>wcstoq</command> işlevi geniş karakter kabul etmesi dışında hemen herşeyiyle <command>strtoq</command> işlevine benzer.
    </para><para>
<command>wcstoq</command> işlevi bir GNU oluşumdur.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>strtoull</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-strtoull">
<funcdef>unsigned long long int <command>strtoull</command></funcdef>
<paramdef>(const char *restrict <varname>dizge</varname>,
 char **restrict      <varname>kalan-dizge</varname>,
 int                  <varname>taban</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>strtoul</command> işlevinin <command>strtol</command> işlevine ilgisi gibi <command>strtoull</command> işlevi de <command>strtoll</command> işleviyle benzer ilgiye sahiptır.
    </para><para>
<command>strtoull</command> işlevi ISO C99'da tanıtıldı.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>wcstoull</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-wcstoull">
<funcdef>unsigned long long int <command>wcstoull</command></funcdef>
<paramdef>(const wchar_t *restrict <varname>dizge</varname>,
 wchar_t **restrict      <varname>kalan-dizge</varname>,
 int                     <varname>taban</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>wcstoull</command> işlevi geniş karakter kabul etmesi dışında hemen herşeyiyle <command>strtoull</command> işlevine benzer.
    </para><para>
<command>wcstoull</command> işlevi ISO C90'ın 1. düzeltmesinde vardı.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>strtouq</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-strtouq">
<funcdef>unsigned long long int <command>strtouq</command></funcdef>
<paramdef>(const char *restrict <varname>dizge</varname>,
 char **restrict      <varname>kalan-dizge</varname>,
 int                  <varname>taban</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>strtouq</command> işlevi <command>strtoull</command> işlevinin BSD ismidir.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>wcstouq</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-wcstouq">
<funcdef>unsigned long long int <command>wcstouq</command></funcdef>
<paramdef>(const wchar_t *restrict <varname>dizge</varname>,
 wchar_t **restrict      <varname>kalan-dizge</varname>,
 int                     <varname>taban</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>wcstouq</command> işlevi geniş karakter kabul etmesi dışında hemen herşeyiyle <command>strtouq</command> işlevine benzer.
    </para><para>
<command>wcstouq</command> işlevi bir GNU oluşumdur.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>strtoimax</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-strtoimax">
<funcdef>intmax_t <command>strtoimax</command></funcdef>
<paramdef>(const char *restrict <varname>dizge</varname>,
 char **restrict      <varname>kalan-dizge</varname>,
 int                  <varname>taban</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>strtoimax</command> işlevi daha büyük değerler kabul ederek sonucu <command>intmax_t</command> türünde döndürmesi dışında <command>strtol</command> gibidir.
    </para><para>
Eğer dizge geçerli sözdizimine sahip olduğu halde taşmadan dolayı değer gösterilemiyorsa, değerin işaretine bağlı olarak <command>INTMAX_MAX</command> ya da <command>INTMAX_MIN</command> döner (bkz. <xref linkend="glibc-Range-of-Type"/>).  Ayrıca taşmayı belirtmek üzere <command>errno</command> değişkenine <command>ERANGE</command> atanır.
    </para><para>
<command>intmax_t</command> türü hakkında daha fazla bilgi için <xref linkend="glibc-Integers"/> bölümüne bakınız. <command>strtoimax</command> işlevi ISO C99'da tanıtıldı.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>wcstoimax</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-wcstoimax">
<funcdef>intmax_t <command>wcstoimax</command></funcdef>
<paramdef>(const wchar_t *restrict <varname>dizge</varname>,
 wchar_t **restrict      <varname>kalan-dizge</varname>,
 int                     <varname>taban</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>wcstoimax</command> işlevi geniş karakter kabul etmesi dışında hemen herşeyiyle <command>strtoimax</command> işlevine benzer.
    </para><para>
<command>wcstoimax</command> işlevi ISO C99'da tanıtıldı.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>strtoumax</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-strtoumax">
<funcdef>uintmax_t <command>strtoumax</command></funcdef>
<paramdef>(const char *restrict <varname>dizge</varname>,
 char **restrict      <varname>kalan-dizge</varname>,
 int                  <varname>taban</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>strtoul</command> işlevinin <command>strtol</command> işlevine ilgisi gibi <command>strtoul</command> işlevi  <command>strtoumax</command> işleviyle de benzer ilgiye sahiptır.
    </para><para>
<command>intmax_t</command> türü hakkında daha fazla bilgi için <xref linkend="glibc-Integers"/> bölümüne bakınız. <command>strtoumax</command> işlevi ISO C99'da tanıtıldı.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>wcstoumax</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-wcstoumax">
<funcdef>uintmax_t <command>wcstoumax</command></funcdef>
<paramdef>(const wchar_t *restrict <varname>dizge</varname>,
 wchar_t **restrict      <varname>kalan-dizge</varname>,
 int                     <varname>taban</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>wcstoumax</command> işlevi geniş karakter kabul etmesi dışında hemen herşeyiyle <command>strtoumax</command> işlevine benzer.
    </para><para>
<command>wcstoumax</command> işlevi ISO C99'da tanıtıldı.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>atol</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-atol">
<funcdef>long int <command>atol</command></funcdef>
<paramdef>(const char *<varname>dizge</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev <varname>taban</varname> argümanı <command>10</command> olarak belirtilen <command>strtol</command> işlevine benzer, ancak taşma hatalarının saptanmasını gerektirmez. <command>atol</command> işlevi mevcut kodla uyumluluk adına vardır; <command>strtol</command> kullanım bakımından daha güçlüdür.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>atoi</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-atoi">
<funcdef>int <command>atoi</command></funcdef>
<paramdef>(const char *<varname>dizge</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev <command>int</command> türünde bir değer döndürmesi dışında <command>atol</command> işlevi gbidir. Ayrıca, <command>atoi</command> işlevinin atıl olduğu varsayılır; yerine <command>strtol</command> kullanın.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>atoll</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-atoll">
<funcdef>long long int <command>atoll</command></funcdef>
<paramdef>(const char *<varname>dizge</varname>)</paramdef>
</funcprototype><funcdescr><para>
Sonucu <command>long long int</command> türünde döndürmesi dışında <command>atol</command> işlevine benzer.
    </para><para>
<command>atoll</command> işlevi ISO C99'da tanıtıldı.  Tamamen atıldır; yerine <command>strtoll</command> kullanın.
</para></funcdescr></funcsynopsis></para><para>
Buraya kadar bahsedilen işlevler artık yerel veride tanımlanan diğer gösterimleri tanımamaktadır. Bazı yereller çok büyük sayıların daha rahat okunabilmesi için binler ayracı kullanmaktadır. Böyle sayıları okutmak için <command>scanf</command> işlevini <command>'</command> imi ile kullanın.
    </para><para>
Bu örnekte bir işlev bir dizgeyi çözümleyip elde ettiği tamsayıların toplamı ile dönmektedir:
    </para><para><screen>
int
sum_ints_from_string (char *string)
{
  int sum = 0;

  while (1) {
    char *tail;
    int next;

    /* Baştaki boşlukları atlayalım.  */
    while (isspace (*string)) string++;
    if (*string == 0)
      break;

    /* Artık boşluk karakeri kalmadı,  */
    /* rakamlara bakabiliriz.  */
    errno = 0;
    /* Çözümle.  */
    next = strtol (string, &amp;tail, 0);
    /* Taşmamışsa, ekle.  */
    if (errno)
      printf ("Taştı\n");
    else
      sum += next;
    /* Kalan dizgeyi tekrar işleme sokalım.  */
    string = tail;
  }

  return sum;
}</screen></para></sect1>
  <sect1 xml:id="glibc-Parsing-of-Floats">
    <title>Gerçek Sayıların Çözümlenmesi</title>
    <titleabbrev>Gerçek sayı dönüşüm işlevleri.</titleabbrev>
    <para>
<indexterm scope="glibc-pg"><primary>stdlib.h</primary></indexterm>
<command>str</command> işlevleri <filename>stdlib.h</filename> dosyasında, <command>wcs</command> ile başlayan işlevler <filename>wchar.h</filename> dosyasında bildirilmiştir.  Bu bölümdeki işlevlerin prototiplerinde <command>restrict</command> kullanımı şaşırtıcı olabilir. Kullanışsız görünür ama ISO C standardı onu kullandığı için (burada tanımlı işlevler için) biz de kullandık.
    </para><para>
<indexterm scope="glibc-fn"><primary>strtod</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-strtod">
<funcdef>double <command>strtod</command></funcdef>
<paramdef>(const char *restrict <varname>dizge</varname>,
 char **restrict      <varname>kalan-dizge</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>strtod</command> (&quot;string-to-double&quot; kısaltması) işlevi <varname>dizge</varname> dizgesinin baştarafını bir gerçek sayıya dönüştürür ve sonucu <command>double</command> türünde bir değer olarak döndürür.
    </para><para>
İşlev <varname>dizge</varname>'yi şu şekilde analiz etmeye çalışır:
    </para><para><itemizedlist><listitem><para>
Boşluk karakterlerinden oluşan bir dizge (muhtemelen boş). Boşluk karakterleri <command>isspace</command> işlevi ile saptanır ve bunlar iptal edilir (bkz. <xref linkend="glibc-Classification-of-Characters"/>).
      </para></listitem><listitem><para>
İsteğe bağlı artı ya da eksi işareti (<command>+</command> veya <command>-</command>).
      </para></listitem><listitem><para>
Onluk ya da onaltılık biçimde bir gerçek sayı. Onluk biçim şöyle çözümlenmeye çalışılır:
      </para><para><itemizedlist><listitem><para>
İsteğe bağlı olarak gösterimi yerele bağlı bir ondalık nokta (normalde <command>.</command>) içeren ve aralarında boşluk bulunmayan rakamlar. (Bkz. <xref linkend="glibc-General-Numeric"/>).
        </para></listitem><listitem><para>
İsteğe bağlı üstel kısım. <command>e</command> veya <command>E</command> karakteri ile isteğe bağlı bir işaret ve rakamlardan oluşur.
        </para></listitem></itemizedlist></para><para>
Onaltılık biçim şöyle çözümlenmeye çalışılır:
      </para><para><itemizedlist><listitem><para>
0x veya 0X ile başlayan, isteğe bağlı olarak gösterimi yerele bağlı bir ondalık nokta (normalde <command>.</command>) içeren ve aralarında boşluk bulunmayan rakamlar. (Bkz. <xref linkend="glibc-General-Numeric"/>).
        </para></listitem><listitem><para>
İsteğe bağlı ikilik üstel kısım. <command>p</command> veya <command>P</command> karakteri ile isteğe bağlı bir işaret ve rakamlardan oluşur.
        </para></listitem></itemizedlist>
      </para></listitem><listitem><para>
Dizgede kalan karakterler. Eğer <varname>kalan-dizge</varname> bir boş gösterici değilse işlev bu artıkları <varname>*kalan-dizge</varname> içine yerleştirir.
      </para></listitem></itemizedlist></para><para>
Eğer dizge boşsa, sadece boşluk karakterleri içeriyorsa ya da başlangıçtaki altdizge bir gerçek sayı için umulan sözdizimine sahip değilse hiçbir dönüşüm yapılmaz. Bu durumda, işlev sıfırla döner ve <varname>dizge</varname> değeri <varname>*kalan-dizge</varname> içine yerleştirir.
</para></funcdescr></funcsynopsis></para><para>
Yerel, standart <command>&quot;C&quot;</command> ya da <command>&quot;POSIX&quot;</command> yerellerinden farklıysa, bu işlev gerçeklemeye bağlı olarak ek sözdizimini tanıyabilir.
    </para><para>
Eğer dizge bir gerçek sayı için geçerli sözdizimine sahip olduğu halde değer <command>double</command> türün kapsamı dışındaysa, <command>strtod</command> işlevi <xref linkend="glibc-Math-Error-Reporting"/> bölümünde açıklandığı gibi üstten ya da alttan taşma sinyalleyecektir.
    </para><para>
<command>strtod</command> işlevi dört özel girdi dizgesi tanır. Bu dizgelerden <command>&quot;inf&quot;</command> ve <command>&quot;infinity&quot;</command> ya <literal>oo</literal>'a ya da gerçek sayı biçimi sonsuzlukları desteklemiyorsa gösterilebilir en büyük sayıya dönüştürülür. Önlerine işareti belirtmek için bir  <command>&quot;+&quot;</command> veya <command>&quot;-&quot;</command> konulabilir. Bu dizgelerde harf büyüklüğünün önemi yoktur.
    </para><para>
<command>&quot;nan&quot;</command> ve <command>&quot;nan(<varname>karakterler</varname>)&quot;</command> dizgeleri ise NaN'a dönüştürülür. Yine harf büyüklüğünün önemi yoktur. Eğer <varname>karakterler</varname> belirtilmişse, NaN'ın kısmi bir gösterimine (herşey olabilir) karşılık olarak kullanılır.
    </para><para>
Sıfır geçerli bir sonuç olduğu kadar hata oluştuğunu da belirtebilir. Hatayı sınamak için <varname>errno</varname> ve <varname>kalan-dizge</varname>'yi <command>strtol</command> işlevinin açıklamasında anlatıldığı gibi  kullanmalısınız.
    </para><para>
<indexterm scope="glibc-fn"><primary>strtof</primary></indexterm>
<indexterm scope="glibc-fn"><primary>strtold</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-strtof">
<funcdef>float <command>strtof</command></funcdef>
<paramdef>(const char *<varname>dizge</varname>,
 char      **<varname>kalan-dizge</varname>)</paramdef>
</funcprototype><funcprototype role="işlev" xml:id="glibc-strtold">
<funcdef>long double<command>strtold</command></funcdef>
<paramdef>(const char *<varname>dizge</varname>,
 char      **<varname>kalan-dizge</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlevler <command>strtod</command> işlevinin benzeri olmakla birlikte, sırayla <command>float</command> ve <command>long double</command> değerle dönerler.  Hataları <command>strtod</command> gibi raporlarlar. Hassasiyeti daha düşük olduğundan <command>strtof</command> işlevi <command>strtod</command> işlevinden daha hızlı olabilir; tersine, hassasiyeti daha yüksek olduğundan <command>strtold</command> daha yavaş olabilir (<command>long double</command> türünün ayrı bir tür olduğu sistemlerde).
    </para><para>
Bu işlevler ISO C99'da yeni olmasına rağmen evvelce GNU oluşumuydular.
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>wcstod</primary></indexterm>
<indexterm scope="glibc-fn"><primary>wcstof</primary></indexterm>
<indexterm scope="glibc-fn"><primary>wcstold</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-wcstod">
<funcdef>double <command>wcstod</command></funcdef>
<paramdef>(const wchar_t *restrict <varname>dizge</varname>,
wchar_t **restrict       <varname>kalan-dizge</varname>)</paramdef>
</funcprototype><funcprototype role="işlev" xml:id="glibc-wcstof">
<funcdef>float <command>wcstof</command></funcdef>
<paramdef>(const wchar_t *<varname>dizge</varname>,
 wchar_t      **<varname>kalan-dizge</varname>)</paramdef>
</funcprototype><funcprototype role="işlev" xml:id="glibc-wcstold">
<funcdef>long double <command>wcstold</command></funcdef>
<paramdef>(const wchar_t *<varname>dizge</varname>,
 wchar_t      **<varname>kalan-dizge</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>wcstod</command>, <command>wcstof</command> ve <command>wcstol</command> işlevleri sırayla <command>strtod</command>, <command>strtof</command> ve <command>strtold</command> işlevleriyle geniş arakterleri kabul etmeleri dışında hemen herşeyleriyle benzerdirler.
    </para><para>
<command>wcstod</command> işlevi ISO C90'ın 1. düzeltmesinde vardı.   <command>wcstof</command> ve <command>wcstold</command> işlevleri ise ISO C99'da tanıtıldı.
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>atof</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-atof">
<funcdef>double <command>atof</command></funcdef>
<paramdef>(const char *<varname>dizge</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev alttan ve üstten taşma hatalarının saptanmasını gerektirmemesi dışında <command>strtod</command> işlevine benzer. <command>atof</command> işlevi mevcut kodla uyumluluk adına vardır; <command>strtod</command> kullanım bakımından daha güçlüdür.
</para></funcdescr></funcsynopsis></para><para>
GNU C kütüphanesi ayrıca bu işlevlerin dönüşümde yerel kullanmak için bir ek argüman alan <command>_l</command> sürümlerini de içerir. Bkz. <xref linkend="glibc-Parsing-of-Integers"/>.
    </para></sect1></chapter>
<chapter xml:id="glibc-System-V-Number-Conversion">
  <title>Eski Moda System V Sayıdan Dizgeye Dönüşüm İşlevleri</title>
  <titleabbrev>Sayıları dizgelere dönüştürmenin çok eski bir yolu.</titleabbrev>
  <para>
Eski System V C kütüphanesi sayıları dizgelere çeviren, kullanımı zor ve kullanışsız üç işlev içerir. GNU C kütüphanesi bu işlevleri bazı doğal oluşumlarla birlikte içerir.
   </para><para>
Bu işlevler sadece glibc'de ve AT&amp;T Unix soyundan gelen sistemlerde vardır. Bu bakımdan, bunlara özellikle ihtiyaç duymuyorsanız bunların yerine standart olan <command>sprintf</command>'i kullanmak daha iyidir.
   </para><para>
Bu işlevlerin tamamı <filename>stdlib.h</filename> dosyasında bildirilmiştir.
   </para><para>
<indexterm scope="glibc-fn"><primary>ecvt</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-ecvt">
<funcdef>char *<command>ecvt</command></funcdef>
<paramdef>(double <varname>değer</varname>,
 int    <varname>hane-sayısı</varname>,
 int   *<varname>ondalık-nokta</varname>,
 int   *<varname>negatif</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>ecvt</command> işlevi <varname>değer</varname> gerçek sayısını en fazla <varname>hane-sayısı</varname> onluk rakama dönüştürür. Dönen dizge ondalık noktayı ve işareti içermez. Dizgenin ilk rakamı sıfırdan farklıdır (<varname>değer</varname> sıfır olmadıkça) ve son rakan en yakına yuvarlanır. <varname>*ondalık-nokta</varname>'ya ondalık noktadan sonraki ilk hanenin indisi yerleşir. <varname>değer</varname> negatifse <varname>*negatif</varname>'e sıfırdan farklı bir değer, değilse sıfır yerleşir.
   </para><para>
Eğer <varname>hane-sayısı</varname> rakam <command>double</command> türünün hassasiyetini aşarsa sisteme özel değere düşürülür.
   </para><para>
Dönen dizge durağan olarak ayrıldığından işlevin sonraki çağrıları bunun üzerine yazar.
   </para><para>
Eğer <varname>değer</varname> sıfırsa, <varname>*ondalık-nokta</varname>'nın <command>0</command> mı yoksa <command>1</command> mi olacağı gerçeklemeye bağlıdır.
   </para><para>
Örnek: <command>ecvt (12.3, 5, &amp;d, &amp;n)</command> çağrısı <command>&quot;12300&quot;</command> ile döner ve <varname>d</varname>'ye <command>2</command>, <varname>n</varname>'ye <command>0</command> atanır.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>fcvt</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-fcvt">
<funcdef>char *<command>fcvt</command></funcdef>
<paramdef>(double <varname>değer</varname>,
 int    <varname>hane-sayısı</varname>,
 int   *<varname>ondalık-nokta</varname>,
 int   *<varname>negatif</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>fcvt</command> işlevi <varname>hane-sayısı</varname>'nın ondalık noktadan sonraki hane sayısını göstermesi dışında <command>ecvt</command> gibidir. Eğer <varname>hane-sayısı</varname> sıfırdan küçükse, <varname>değer</varname> ondalık noktanın solundaki  <varname>hane-sayısı</varname>+1'inci haneye yuvarlanır.  Örneğin,  <varname>hane-sayısı</varname>  <command>-1</command> ise, <varname>değer</varname> en yakın 10'a yuvarlanır. Eğer <varname>hane-sayısı</varname> negatifse ve  <varname>değer</varname>'deki ondalık noktanın solundaki hane sayısından daha büyükse, <varname>değer</varname> bir en kıymetli rakama yuvarlanacaktır.
   </para><para>
Eğer <varname>hane-sayısı</varname> rakam <command>double</command> türünün hassasiyetini aşarsa sisteme özel değere düşürülür.
   </para><para>
Dönen dizge durağan olarak ayrıldığından işlevin sonraki çağrıları bunun üzerine yazar.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>gcvt</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-gcvt">
<funcdef>char *<command>fcvt</command></funcdef>
<paramdef>(double <varname>değer</varname>,
 int    <varname>hane-sayısı</varname>,
 char  *<varname>tampon</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>gcvt</command> işlevi <command>sprintf(tampon, &quot;%*g&quot;, hanesayisi, deger</command> çağrısına eşdeğerdir. Sadece uyumluluk adına vardır. <varname>tampon</varname> ile döner.
   </para><para>
Eğer <varname>hane-sayısı</varname> rakam <command>double</command> türünün hassasiyetini aşarsa sisteme özel değere düşürülür.
</para></funcdescr></funcsynopsis></para><para>
Bu üç işleve ek olarak, GNU C kütüphanesi bu işlevlerin <command>long double</command> argüman alan sürümlerini de içerir.
   </para><para>
<indexterm scope="glibc-fn"><primary>qecvt</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-qecvt">
<funcdef>char *<command>qecvt</command></funcdef>
<paramdef>(long double <varname>değer</varname>,
 int         <varname>hane-sayısı</varname>,
 int        *<varname>ondalık-nokta</varname>,
 int        *<varname>negatif</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev ilk parametresinde <command>long double</command> argüman alması ve <varname>hane-sayısı</varname>'nı <command>long double</command> hassasiyeti ile sınırlaması dışında <command>ecvt</command> işlevinin benzeridir.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>qfcvt</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-qfcvt">
<funcdef>char *<command>qfcvt</command></funcdef>
<paramdef>(long double <varname>değer</varname>,
 int         <varname>hane-sayısı</varname>,
 int        *<varname>ondalık-nokta</varname>,
 int        *<varname>negatif</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev ilk parametresinde <command>long double</command> argüman alması ve <varname>hane-sayısı</varname>'nı <command>long double</command> hassasiyeti ile sınırlaması dışında <command>fcvt</command> işlevinin benzeridir.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>qgcvt</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-qgcvt">
<funcdef>char *<command>qgcvt</command></funcdef>
<paramdef>(long double <varname>değer</varname>,
 int         <varname>hane-sayısı</varname>,
 char       *<varname>tampon</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev ilk parametresinde <command>long double</command> argüman alması ve <varname>hane-sayısı</varname>'nı <command>long double</command> hassasiyeti ile sınırlaması dışında <command>gcvt</command> işlevinin benzeridir.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-cp"><primary>gcvt_r</primary></indexterm>
<command>ecvt</command> ve <command>fcvt</command> işlevleri ve onların <command>long double</command> eşdeğerlerinde, dönen dizge durağan olarak ayrıldığından işlevin sonraki çağrıları bunun üzerine yazar. GNU C kütüphanesi ek işlevlerin dönen dizgeyi kullanıcı tanımlı tampona yazarak döndüğü sürümlerini de içerir. Bunların isimleri teamüen <command>_r</command> soneki alır.
   </para><para>
<command>gcvt</command> işlevi zaten kullanıcı tanımlı tampon kullandığından onun için bir <command>gcvt_r</command> işlevi yoktur.
   </para><para>
<indexterm scope="glibc-fn"><primary>ecvt_r</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-ecvt_r">
<funcdef>int <command>ecvt_r</command></funcdef>
<paramdef>(double <varname>değer</varname>,
 int    <varname>hane-sayısı</varname>,
 int   *<varname>ondalık-nokta</varname>,
 int   *<varname>negatif</varname>,
 char  *<varname>tampon</varname>,
 size_t <varname>uzunluk</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>ecvt_r</command> işlevi, sonucu <varname>uzunluk</varname> uzunluktaki kullanıcı tanımlı <varname>tampon</varname>'a yerleştirmesi dışında <command>ecvt</command> işlevi ile aynıdır. Bir hata durumunda dönüş değeri <command>-1</command>, aksi takdirde sıfırdır.
   </para><para>
Bu işlev bir GNU oluşumudur.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>fcvt_r</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-fcvt_r">
<funcdef>int <command>fcvt_r</command></funcdef>
<paramdef>(double <varname>değer</varname>,
 int    <varname>hane-sayısı</varname>,
 int   *<varname>ondalık-nokta</varname>,
 int   *<varname>negatif</varname>,
 char  *<varname>tampon</varname>,
 size_t <varname>uzunluk</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>fcvt_r</command> işlevi, sonucu <varname>uzunluk</varname> uzunluktaki kullanıcı tanımlı <varname>tampon</varname>'a yerleştirmesi dışında <command>fcvt</command> işlevi ile aynıdır. Bir hata durumunda dönüş değeri <command>-1</command>, aksi takdirde sıfırdır.
   </para><para>
Bu işlev bir GNU oluşumudur.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>qecvt_r</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-qecvt_r">
<funcdef>int <command>qecvt_r</command></funcdef>
<paramdef>(long double <varname>değer</varname>,
 int         <varname>hane-sayısı</varname>,
 int        *<varname>ondalık-nokta</varname>,
 int        *<varname>negatif</varname>,
 char       *<varname>tampon</varname>,
 size_t      <varname>uzunluk</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>qecvt_r</command> işlevi, sonucu <varname>uzunluk</varname> uzunluktaki kullanıcı tanımlı <varname>tampon</varname>'a yerleştirmesi dışında <command>qecvt</command> işlevi ile aynıdır. Bir hata durumunda dönüş değeri <command>-1</command>, aksi takdirde sıfırdır.
   </para><para>
Bu işlev bir GNU oluşumudur.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>qfcvt_r</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" xml:id="glibc-qfcvt_r">
<funcdef>int <command>qfcvt_r</command></funcdef>
<paramdef>(long double <varname>değer</varname>,
 int         <varname>hane-sayısı</varname>,
 int        *<varname>ondalık-nokta</varname>,
 int        *<varname>negatif</varname>,
 char       *<varname>tampon</varname>,
 size_t      <varname>uzunluk</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>qfcvt_r</command> işlevi, sonucu <varname>uzunluk</varname> uzunluktaki kullanıcı tanımlı <varname>tampon</varname>'a yerleştirmesi dışında <command>qfcvt</command> işlevi ile aynıdır.Bir hata durumunda dönüş değeri <command>-1</command>, aksi takdirde sıfırdır.
   </para><para>
Bu işlev bir GNU oluşumudur.
   </para></funcdescr></funcsynopsis></para>
</chapter>
</part>

