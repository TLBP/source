<?xml version="1.0" encoding="UTF-8"?>
<!-- ********************************************************************
         ch05.xml
     ******************************************************************** -->
<part xml:id="glibc-String-and-Array-Utilities"
      xmlns="http://docbook.org/ns/docbook"
      version="5.0" xml:lang="tr">
 <info>
  <title>Diziler ve Dizgeler</title>
  <titleabbrev>Dizileri ve dizgeleri karşılaşırma ve kopyalama araçları.</titleabbrev>
 </info>
 <partintro>
  <para>
Dizge (karakter dizisi) işlemleri birçok uygulamanın önemli bir parçasını oluşturur. GNU C kütüphanesi kopyalama ve birleştirme işlevleri de dahil olmak üzere geniş bir dizge işleme işlevleri kümesine sahiptir. Bu işlevlerin çoğu bellek erişimi ile ilgili olarak da çalışır; örneğin <command>memcpy</command> işlevi her çeşit dizi içeriğinin kopyalanmasında kullanılabilir.
  </para>
  <para>
C yazılımcılığına yeni başlayanlar genelde bu işlevlerin benzerlerini yazarak "tekerleği yeniden icadederler". Halbuki bu zamanı kütüphane işlevlerini öğrenmeye ayırsalar ve bunları kullansalar verimlilik ve taşınabilirlik adına bir çok kazanç elde edeceklerdir.
  </para>
  <para>
Örneğin bir dizgeyi diğeriyle iki satır C kodu yazarak kolayca karşılaştırabilirsiniz, fakat yerleşik <command>strcmp</command> işlevini kullanırsanız daha az yanlış yapmış olacaksınız. Ve bu kütüphane işlevleri yüksek derecede  eniyilendiklerinden yazılımınız daha hızlı çalışacaktır.
  </para>
 </partintro>
 <chapter xml:id="glibc-Representation-of-Strings">
  <info>
   <title>Dizgelerle İlgili Kavramlar</title>
   <titleabbrev>Temel kavramlarla giriş.</titleabbrev>
  </info>
  <para><indexterm scope="glibc-cp"><primary>dizgeler</primary><secondary>görünümleri</secondary></indexterm>
Bu kısım, C yazılımcılığına yeni başlayanlar için dizge kavramlarının kısa bir özetini barındırır. Karakter dizgelerinin C'de nasıl temsil edildiği ve bilinen bazı tuzaklar hakkında bilgi verilecektir. Bu bilgilere zaten sahipseniz bu bölümü atlayabilirsiniz.
    </para>
  <para><indexterm scope="glibc-cp"><primary>dizgeler</primary></indexterm><indexterm scope="glibc-cp"><primary>dizgeler</primary><secondary>çokbaytlı karakter dizgeleri</secondary></indexterm>
Bir <wordasword>dizge</wordasword>, <command>char</command> türünden nesnelerden oluşan bir dizidir. Fakat dizge değerli değişkenler genellikle <command>char *</command> türünden bir gösterici olarak bildirilirler. Bu tür değişkenler dizgenin metni için alan içermezler. Dizge bir dizi değişkeninde, bir dizge sabitinde ya da <link linkend="glibc-Memory-Allocation">özdevimli ayrılmış bir bellek bölgesinde</link> olabilir. Gösterici değişkeninde seçilen bellek bölgesinin adresini saklarsınız. Ayrıca gösterici değişkeninde bir boş gösterici de saklayabilirsiniz. Boş gösterici hiçbir yeri göstermediğinden onu bir dizge olarak gösterirseniz bir hata alırsınız.
    </para>
  <para><indexterm scope="glibc-cp"><primary>dizgeler</primary><secondary>geniş karakterli</secondary></indexterm>
Bir dizge normalde geniş karakterli dizgenin tersine bir çokbaytlı karakter dizisidir. Geniş karakterli dizgeler <command>wchar_t</command> türünden dizilerdir ve çok baytlı karakter dizileri gibi genellikle <command>wchar_t *</command> türünden göstericilerle kullanılırlar.
    </para>
  <para><indexterm scope="glibc-cp"><primary>dizgeler</primary><secondary>boş karakter</secondary></indexterm><indexterm scope="glibc-cp"><primary>dizgeler</primary><secondary>boş geniş karakter</secondary></indexterm>
Teamülen, bir <wordasword>boş karakter</wordasword>, <command>'\0'</command> karakteridir ve bir çokbaytlı karakter dizisinin sonuna konur, <wordasword>boş geniş karakter</wordasword> ise <command>L'\0'</command> karakteridir ve bir geniş karakterli dizgenin sonuna konur. Örneğin, <command>char *</command>  türünden <varname>p</varname> değişkeninin gösterdiği dizgenin sonunda bir boş karakter olup olmadığını <command>!*</command><varname>p</varname> veya <command>*<varname>p</varname> == '\0'</command> yazarak sınayabilirsiniz.
    </para>
  <para>
Bir boş karakter ile bir boş gösterici arasında sadece kavramsal fark vardır, her ikisi de <command>0</command> tamsayısı tarafından temsil edilir.
    </para>
  <para><indexterm scope="glibc-cp"><primary>dizgeler</primary><secondary>dizge sabitler</secondary></indexterm><wordasword>Dizge sabitler</wordasword> C yazılımlarında çift tırnak içine alınmış karakterlerin büyük harf L ile öncelenmesi ile oluşurlar, <command>L"foo"</command> gibi. ISO C'de dizge sabitler kendiliğinden <wordasword>birleşik dizge</wordasword> oluştururlar, örneğin <command>"a" "b"</command> ile <command>"ab"</command> aynıdır. Geniş karakterli dizgeler için bu gösterimler <command>L"a" L"b"</command> veya  <command>L"a" "b"</command> biçiminde olabilir. GNU C derleyicisi dizge sabitler üzerinde değişiklik yapılmasına izin vermez, çünkü sabitler salt-okunur bölgede tutulurlar.
    </para>
  <para>
Ayrıca <command>const</command> ile bildirilen karakter dizileri de değiştirilemezler. C derleyicisi <command>const char *</command> türünden bir değişiklik yapılamayan bir dizge göstericisi kullanıldığında istemdışı değişiklikleri saptayabildiğinden en iyisi dizge sabitleri <command>const char *</command> türünde bildirmektir.
    </para>
  <para>
Karakter dizisi için ayrılan belleğin miktarı dizgenin sonunu belirleyen boş karaktere kadar uzayabilir. Bu belgede <wordasword>ayrılan boyut</wordasword> denilince daima dizge için ayrılan belleğin toplam miktarından, <wordasword>uzunluk</wordasword> denilince dizgeyi sonlandıran boş karakter hariç dizgedeki toplam karakter sayısından bahsetmiş olacağız.
<indexterm scope="glibc-cp"><primary>dizgeler</primary><secondary>uzunluğu</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>dizgeler</primary><secondary>ayrılan boyut</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>dizgeler</primary><secondary>boyutu</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>dizgeler</primary><secondary>dizge uzunluğu</secondary></indexterm>
    </para>
  <para>
Namlı yazılım hatalarından biri bir dizgeye ayrılan yere sığacağından daha fazla karakter girilmeye çalışılmasıdır. Kodu yazarken, önceden ayrılmış bir dizi içine dizge veya karakterler taşınırken metnin uzunluğunu sürekli denetlemeli dizinin taşmamasına dikkat etmelisiniz. Bir çok kütüphane işlevi bu işlemi sizin yerinize <emphasis>yapmaz</emphasis>. Dizgenin sonunu belirtecek olan boş karakter için de yer ayırmayı unutmayın.
    </para>
  <para><indexterm scope="glibc-cp"><primary>dizgeler</primary><secondary>tek baytlı - çok baytlı</secondary></indexterm>
Genellikle, dizgeler, her baytı bir karakteri ifade eden bayt dizileridir. Bu özellik eğer dizge tek baytlık karakter kodlaması ile yazılmışsa geçerlidir. Eğer çok baytlı karakter kodlaması kullanılmışsa bu değişir. (Karakter kodlamaları için <xref linkend="glibc-Extended-Char-Intro"/> bölümüne bakınız.) Yazılım geliştirme arayüzü bakımından bu iki dizge çeşidi bir fark oluşturmaz; yeterki yazılımcı bu farka dikkat ederek dizgeleri uygun yorumlasın.
    </para>
  <para>
Ancak arayüz için bir farklılık oluşturmayan bayt temelli işlevlerin kullanımı kimi zaman zor olur. Bu işlevlerin baytları belirleyen sayaç parametreleri <command>strncpy</command> işlevini çağırarak bir çokbaytlı karakteri ortasından bölüp bir eksik (dolayısıyla kullanışsız) bayt dizisi olarak hedef tampona yerleştirir.
    </para>
  <para><indexterm scope="glibc-cp"><primary>dizgeler</primary><secondary>geniş karakterli</secondary></indexterm>
Bu sorunlardan kurtulmak için ISO C standardının daha sonraki sürümlerinde <wordasword>geniş karakterler</wordasword> (<xref linkend="glibc-Extended-Char-Intro"/>) ile çalışan ikinci bir işlev kümesi tanımlandı. Her geniş karakter kurallara uygun ve yorumlanabilir olduğundan bu işlevlerle tek baytlık karakter dizileriyle çalışmada karşılaşılan sorunlar ortadan kalktı. Bu geniş karakterli dizgelerde kesme işleminin uygunsuz bir yerden yapılmayacağı anlamına gelmez. Normalde alfabe temelli diller (normalleştirilmemiş metinler hariç) için sorun yoktur, ancak hece temelli dillerde (Çince gibi) mantıksal birimleri çok sayıda geniş karakter oluşturduğundan bu sorun hala devam etmektedir. Bu kadarı bile yine de iyidir, çünkü en azından geçersiz bayt dizileri oluşmamaktadır. Ayrıca, daha yüksek seviyeli işlevler geniş karakterli dizgelerle çok baytlı karakter dizilerinden daha kolay çalışır. Bu bakımdan geniş karakterli dizgelerin kullanılması tercih edilmelidir.
    </para>
  <para>
Bu kısmın kalanında geniş karakterli dizgelerle çalışan işlevlere paralal olarak çokbaytlı karakter dizilerini de tartışacağız, çünkü onlar arasında hemen hemen bir tam eşdeğer kullanılabilirlik vardır.
    </para>
 </chapter>
 <chapter xml:id="glibc-String-Array-Conventions">
  <info>
   <title>Dizi ve Dizge Teamülleri</title>
   <titleabbrev>Bir dizge işlevini mi yoksa bir dizi işlevini mi kullanmalı.</titleabbrev>
  </info>
  <para>
Bu kısımda diziler veya bellek blokları üzerinde çalışan işlevlerle normal karakterlerin ve geniş karakterlerin özellikle boş karakter sonlandırmalı dizileriyle çalışan işlevler açıklanmıştır.
    </para>
  <para>
Bellek blokları ile çalışan işlevlerin isimleri <command>mem</command> ve  <command>wmem</command> ile başlar ve üzerinde çalışacakları bellek blokunun boyutunu (sırasıyla bayt ve geniş karakter sayısı olarak) belirten bir argüman alırlar. Bu işlevlerin dizi argümanları ve dönüş değerleri <command>void *</command> veya <command>wchar_t</command> türündendir. <command>mem</command> ile başlayan işlev isimlerine sahip işlevler için dizi elemanlarına konu olan baytlardır ve bu işlevlere her çeşit gösterici aktarabileceğiniz gibi, boyut argümanının değerini hesaplarken <command>sizeof</command> işlecini kullanabilirsiniz. <command>wmem</command> işlevlerinin parametreleri <command>wchar_t *</command> türünde olmalıdır. Bu işlevlerde bu tür haricinde bir gösterici kullanamazsınız.
    </para>
  <para>
Özellikle normal dizgeler ve geniş karakterli dizgelerle çalışan işlevlerin isimleri sırasıyla <command>str</command> ve <command>wcs</command>  ile başlar (<command>strcpy</command> ve <command>wcscpy</command> gibi) ve bir uzunluk argümanı almak yerine dizgeyi sonlandıran boş karaktere bakarlar. (Bu işlevlerin bazıları bir en büyük uzunluk değeri alırlar ve ayrıca bir boş karakterle vaktinden önce sonlandırma olup olmadığını sınarlar.) Bu işlevlerin dizi argümanları ve dönüş değerleri <command>char *</command> ve <command>wchar_t *</command> türünde olmalı ve dizi elemanları sırasıyla normal karakterlerden veya geniş karakterlerden oluşmalıdır.
    </para>
  <para>
Birçok durumda bir işlevin hem <command>mem</command> hem de <command>str</command>/<command>wcs</command> sürümleri vardır. Duruma bağlı olarak herbirinin kullanılması gerekebilir. Yazılımınız dizileri veya bellek bloklarını değiştiriyorsa daima <command>mem</command> işlevlerini kullanmalısınız. Diğer taraftan, boş karakter sonlandırmalı dizgelerde değişiklik yapacağınız zaman da, dizgenin uzunluğunu biliyor olmadıkça, <command>str</command>/<command>wcs</command> işlevlerini kullanmak daha uygun olur. Bilinen boyutlarla geniş karakter dizilerinde <command>wmem</command> işlevleri kullanılmalıdır.
    </para>
  <para><indexterm scope="glibc-cp"><primary>wint_t</primary></indexterm><indexterm scope="glibc-cp"><primary>parametre terfileri</primary></indexterm>
Bellek ve dizge işlevlerinin bazıları argüman olarak tek karakter alır. İşlevdeki parametre <command>int</command> türüyle bildirildiğinden, <command>char</command> türünden bir değer parametre olarak kullanıldığında özdevinimli olarak <command>int</command> türünden bir değere terfi ettirilir. Geniş karakterli dizge işlevleri için de benzer bir durum sözkonusudur; tek geniş karakter için parametre <command>wchar_t</command> değil <command>wint_t</command> türündedir. Ancak bir çok gerçekleme <command>wchar_t</command> türü yeterince geniş olduğundan özdevinimli terfiye gerek duymaz. ISO C standardı belli türün seçilmesini gerektirmediğinden <command>wint_t</command> türü kullanılmıştır.
    </para>
 </chapter>
 <chapter xml:id="glibc-String-Length">
  <info>
   <title>Dizge Uzunluğu</title>
   <titleabbrev>Bir dizgenin uzunluğunun saptanması.</titleabbrev>
  </info>
  <para>
Bir dizgenin uzunluğunu <command>strlen</command> işlevini kullanarak alabilirsiniz. Bu işlev <filename>string.h</filename> başlık dosyasında bildirilmiştir.
<indexterm scope="glibc-pg"><primary>string.h</primary></indexterm>
    </para>
  <para xml:id="glibc-strlen">
   <indexterm scope="glibc-fn">
    <primary>strlen</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>size_t <command>strlen</command></funcdef>
     <paramdef>(const char *<varname>s</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para><command>strlen</command> işlevi boş karakter sonlandırmalı <varname>s</varname> dizgesinin bayt cinsinden uzunluğu ile döner. (Başka bir deyişle dizi içindeki boş karakterin indisi ile döner.) Örneğin,
      </para>
     <para>
      <screen>
strlen ("hello, world")
    =&gt; 12
</screen>
     </para>
     <para>
Bir karakter dizisine uygulandığında <command>strlen</command> işlevi burada saklanan dizgenin uzunluğu ile döner, dizi için ayrılan boyutla değil. Dizi için ayrılan boyutu <command>sizeof</command> işleci ile öğrenebilirsiniz:
      </para>
     <para>
      <screen>
char dizge[32] = "hello, world";
sizeof (dizge)
    =&gt; 32
strlen (dizge)
    =&gt; 12
</screen>
     </para>
     <para>
Yalnız dikkatli olun, <varname>dizge</varname> bir karakter dizisi değil de bir gösterici ise bu çalışmaz. Örneğin,
      </para>
     <para>
      <screen>
char dizge[32] = "hello, world";
char *ptr = dizge;
sizeof (dizge)
    =&gt; 32
sizeof (ptr)
    =&gt; 4  /* (göstericilerin 4 bayt olduğu bir makine üzerinde) */
</screen>
     </para>
     <para>
Dizge argüman alan işlevlerle çalışırken bu yanlışı yapmak çok kolaydır; çünkü bu işlevlerin argümanları daima göstericidir, dizi değildir.
     </para>
     <para>
Ayrıca belirtmek gerekir ki, çokbaytlı kodlanmış dizgeler için dönen değer dizgedeki karakterlerin sayısı değildir. Bu değeri almak isterseniz dizge önce geniş karakterli bir dizgeye dönüştürülmeli ve  <command>wcslen</command> işlevi kullanılmalı ya da aşağıdakine benzer bir kod kullanılmalıdır:
   </para>
     <para>
      <screen>
/* Girdi <command>string</command> içinde.
   Uzunluk ise <command>n</command> karakter umuluyor.  */
{
  mbstate_t t;
  char *scopy = string;
  /* dahili durum.  */
  memset (&amp;t, '\0', sizeof (t));
  /* Karakter sayısını alalım.  */
  n = mbsrtowcs (NULL, &amp;scopy, strlen (scopy), &amp;t);
}
</screen>
     </para>
     <para>
Bunun böyle yapılması kullanışsızdır. Karakter sayısına (bayt sayısı değil) ihtiyacınız varsa geniş karakterleri kullanmak en iyisidir.
      </para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para>
İşlevin geniş karakterli eşdeğeri <filename>wchar.h</filename> başlık dosyasında bildirilmiştir.
    </para>
  <para xml:id="glibc-wcslen">
   <indexterm scope="glibc-fn">
    <primary>wcslen</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>size_t <command>wcslen</command></funcdef>
     <paramdef>(const wchar_t *<varname>ws</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para><command>wcslen</command> işlevi, <command>strlen</command> işlevinin geniş karakterli eşdeğeridir. Dönen değer, <varname>ws</varname> ile gösterilen geniş karakter dizgesinin geniş karakter sayısıdır. (Bu değer aynı zamanda boş geniş karakter sonlandırmalı <varname>ws</varname> dizisinin boş geniş karakteri içeren elemanının indisidir.)
      </para>
     <para>
Bir karakteri oluşturmak için çoklu geniş karakter sıraları olmadığından dönen değer sadece dizideki bir indis değil, ayrıca geniş karakterlerin de sayısıdır.
      </para>
     <para>
Bu işlev ISO C99 standardının 1. düzeltmesinde tanımlıdır.
</para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para xml:id="glibc-strnlen">
   <indexterm scope="glibc-fn">
    <primary>strnlen</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>size_t <command>strnlen</command></funcdef>
     <paramdef>(const char *<varname>s</varname>,
 size_t      <varname>enbüyük-uzunluk</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para><command>strnlen</command> işlevi, <varname>s</varname> dizgesinin uzunluğu <varname>enbüyük-uzunluk</varname> bayttan kısa ise bayt cinsinden  uzunluğu ile döner. Aksi takdirde <varname>enbüyük-uzunluk</varname> ile döner. Diğer taraftan bu işlev aşağıdaki ifadeye eşdeğerdir:
</para>
     <para>
      <literallayout class="normal">
(<command>strlen</command> (<varname>s</varname>) &lt; n ? strlen (<varname>s</varname>) : <varname>enbüyük-uzunluk</varname>)
</literallayout>
     </para>
     <para>
Bu daha etkilidir ve <varname>s</varname> dizgesi boş karakter sonlandırmalı değilse bile çalışır.
      </para>
     <para>
      <screen>
char dizge[32] = "hello, world";
strnlen (dizge, 32)
    =&gt; 12
strnlen (dizge, 5)
    =&gt; 5
</screen>
     </para>
     <para>
Bu işlev bir GNU oluşumudur ve <filename>string.h</filename> başlık dosyasında bildirilmiştir.
</para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para xml:id="glibc-wcsnlen">
   <indexterm scope="glibc-fn">
    <primary>wcsnlen</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>size_t <command>wcsnlen</command></funcdef>
     <paramdef>(const wchar_t *<varname>ws</varname>,
 size_t         <varname>enbüyük-uzunluk</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para><command>wcsnlen</command> işlevi, <command>strnlen</command> işlevinin geniş karakterli eşdeğeridir. <varname>enbüyük-uzunluk</varname> parametresi dizgenin içerebileceği en çok geniş karakterler sayısıdır.
      </para>
     <para>
Bu işlev bir GNU oluşumudur ve <filename>wchar.h</filename> başlık dosyasında bildirilmiştir.
      </para>
    </funcdescr>
   </funcsynopsis>
  </para>
 </chapter>
 <chapter xml:id="glibc-Copying-and-Concatenation">
  <info>
   <title>Kopyalama ve Birleştirme</title>
   <titleabbrev>Dizilerin ve dizgelerin içeriğini kopyalayan işlevler.</titleabbrev>
  </info>
  <para>
Bu kısımda açıklanan işlevleri dizi ve dizgelerin içeriğini kopyalamakta veya bir dizinin içeriğini diğerine eklemekte kullanabilirsiniz. <command>str</command> ve <command>mem</command> işlevleri <filename>string.h</filename> başlık dosyasında, <command>wstr</command> ve <command>wmem</command> işlevleri ise <filename>wchar.h</filename> başlık dosyasında bildirilmiştir.
<indexterm scope="glibc-pg"><primary>string.h</primary></indexterm>
<indexterm scope="glibc-pg"><primary>wchar.h</primary></indexterm>
<indexterm scope="glibc-cp"><primary>dizgeler</primary><secondary>kopyalama</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>dizgeler</primary><secondary>ekleme</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>diziler</primary><secondary>kopyalama</secondary></indexterm>
Bu kısımdaki işlevlerin argümanlarının sırası hedef, kaynak şeklindedir ve işlevler daima hedef dizinin adresi ile dönerler.
   </para>
  <para>
Bu işlevlerin çoğu kaynak ve hedef dizilerinin birbirinin üstüne binmesi durumunda düzgün çalışmaz. Örneğin, kaynak dizisinin sonu, hedef dizisinin başlangıcını aşarsa, kaynak dizisinin başlangıcı, kendi sonunun üzerine yazılır ve bu durumda kaynak dizisini sonlandıran boş karakter kaybolur. Sonlandırıcı boş karakter olmadığından kopyalama işlemi tüm belleğin ayrılmasına kadar gidebilir.
   </para>
  <para>
Dizilerin kopyalanmasında birbirinin üzerine binmesi sorunu olan tüm işlevler bu  kılavuzda  açıkça belirtilmiştir. Bu kısımdaki işlevlere ek olarak  <command>sprintf</command> (<xref linkend="glibc-Formatted-Output-Functions"/>) ve <command>scanf</command> (<xref linkend="glibc-Formatted-Input-Functions"/>) gibi başka işlevler de vardır.
   </para>
  <para xml:id="glibc-memcpy">
   <indexterm scope="glibc-fn">
    <primary>memcpy</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>void *<command>memcpy</command></funcdef>
     <paramdef>(void *restrict       <varname>hedef</varname>,
 const void *restrict <varname>kaynak</varname>,
 size_t               <varname>boyut</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para><command>memcpy</command> işlevi <varname>boyut</varname> baytı <varname>kaynak</varname> adresinden başlayan nesneden <varname>hedef</varname> adresinden başlayan nesneye kopyalar. Bu işlevde <varname>kaynak</varname> dizisinin <varname>hedef</varname> dizisinin üzerine binmesi durumundaki davranışı tanımsızdır; üstüste binme olasılığı varsa <command>memmove</command> kullanın.
      </para>
     <para>
İşlev, <varname>hedef</varname>'in değeri ile döner.
      </para>
     <para>
Bu örnekte bir dizinin içeriğini kopyalamak için <command>memcpy</command> işlevinin nasıl kullanılacağı gösterilmiştir:
      </para>
     <para>
      <screen>
struct foo *eskidizi, *yenidizi;
int diziboyu;
…
memcpy (yeni, eski, diziboyu * sizeof (struct foo));
</screen>
     </para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para xml:id="glibc-wmemcpy">
   <indexterm scope="glibc-fn">
    <primary>wmemcpy</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>wchar_t *<command>wmemcpy</command></funcdef>
     <paramdef>(wchar_t *restrict       <varname>hedef-geniş</varname>,
 const wchar_t *restrict <varname>kaynak-geniş</varname>,
 size_t                  <varname>boyut</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para><command>wmemcpy</command> işlevi <varname>boyut</varname> geniş karakteri <varname>kaynak-geniş</varname> adresinden başlayan nesneden <varname>hedef-geniş</varname> adresinden başlayan nesneye kopyalar. Bu işlevde <varname>kaynak-geniş</varname> dizisinin <varname>hedef-geniş</varname> dizisinin üzerine binmesi durumundaki davranışı tanımsızdır; üstüste binme olasılığı varsa <command>wmemmove</command> kullanın.
      </para>
     <para>
Aşağıda <command>wmemcpy</command> işlevinin olası bir gerçeklemesi vardır. Başka olası eniyilemeleri de vardır.
      </para>
     <para>
      <screen>
wchar_t *
wmemcpy (wchar_t *restrict hedefg, const wchar_t *restrict kaynakg,
         size_t boyut)
{
  return (wchar_t *) memcpy (hedefg, kaynakg, boyut * sizeof (wchar_t));
}
</screen>
     </para>
     <para>
İşlev, <varname>hedef-geniş</varname>'in değeri ile döner.
      </para>
     <para>
Bu işlev ISO C90 standardının 1. düzeltmesinde tanımlanmıştır.
</para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para xml:id="glibc-mempcpy">
   <indexterm scope="glibc-fn">
    <primary>mempcpy</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>void *<command>mempcpy</command></funcdef>
     <paramdef>(void *restrict       <varname>hedef</varname>,
 const void *restrict <varname>kaynak</varname>,
 size_t               <varname>boyut</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para><command>mempcpy</command> işlevi <command>memcpy</command> işlevi ile hemen hemen eşdeğerdir. İşlev, <varname>boyut</varname> baytı <varname>kaynak</varname> adresinden başlayan nesneden <varname>hedef</varname> adresine kopyalar. Fakat dönen değer <varname>hedef</varname>'in değeri değildir. <varname>hedef</varname> başlangıcından itibaren yazılan son baytı izleyen baytın adresi ile döner. Yani, dönen değer:
      </para>
     <para>
      <literallayout indent="0" class="normal">
  ((void *) ((char *) <varname>hedef</varname> + <varname>boyut</varname>))
</literallayout>
     </para>
     <para>
Bu işlev çok sayıda nesnenin ardışık bellek konumlarına kopyalanması durumunda kullanışlıdır.
      </para>
     <para>
      <screen>
void *
combine (void *o1, size_t s1, void *o2, size_t s2)
{
  void *result = malloc (s1 + s2);
  if (result != NULL)
    mempcpy (mempcpy (result, o1, s1), o2, s2);
  return result;
}
</screen>
     </para>
     <para>Bu işlev bir GNU oluşumudur.
</para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para xml:id="glibc-wmempcpy">
   <indexterm scope="glibc-fn">
    <primary>wmempcpy</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>wchar_t *<command>wmempcpy</command></funcdef>
     <paramdef>(wchar_t *restrict       <varname>hedef-geniş</varname>,
 const wchar_t *restrict <varname>kaynak-geniş</varname>,
 size_t                  <varname>boyut</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para><command>wmempcpy</command> işlevi <command>wmemcpy</command> işlevi ile hemen hemen eşdeğerdir. İşlev, <varname>boyut</varname> geniş karakteri <varname>kaynak-geniş</varname> adresinden başlayan nesneden <varname>hedef-geniş</varname> adresine kopyalar. Fakat dönen değer <varname>hedef-geniş</varname>'in değeri değildir. <varname>hedef-geniş</varname> başlangıcından itibaren yazılan son geniş karakteri izleyen geniş karakterin adresi ile döner. Yani, dönen değer:
      </para>
     <para>
      <literallayout indent="0" class="normal"><varname>hedef-geniş</varname> + <varname>boyut</varname>
</literallayout>
     </para>
     <para>
Bu işlev çok sayıda nesnenin ardışık bellek konumlarına kopyalanması durumunda kullanışlıdır.
      </para>
     <para>
Aşağıda <command>wmempcpy</command> işlevinin olası bir gerçeklemesi vardır. Başka olası eniyilemeleri de vardır.
   </para>
     <para>
      <screen>
wchar_t *
wmempcpy (wchar_t *restrict hedefg, const wchar_t *restrict kaynakg,
         size_t boyut)
{
  return (wchar_t *) mempcpy (hedefg, kaynakg, boyut * sizeof (wchar_t));
}
</screen>
     </para>
     <para>Bu işlev bir GNU oluşumudur.
</para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para xml:id="glibc-memmove">
   <indexterm scope="glibc-fn">
    <primary>memmove</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>void *<command>memmove</command></funcdef>
     <paramdef>(void       *<varname>hedef</varname>,
 const void *<varname>kaynak</varname>,
 size_t      <varname>boyut</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para><command>memmove</command> işlevi <varname>boyut</varname> baytı <varname>kaynak</varname>’tan <varname>hedef</varname>’e birbirlerinin üstüne binseler bile kopyalar. Üstüste binme durumunda, işlev, <varname>kaynak</varname> bloğundaki baytları <varname>hedef</varname> bloğuna dikkatle kopyalar.
      </para>
     <para>
İşlev, <varname>hedef</varname>'in değeri ile döner.
</para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para xml:id="glibc-wmemmove">
   <indexterm scope="glibc-fn">
    <primary>wmemmove</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>wchar_t *<command>wmemmove</command></funcdef>
     <paramdef>(wchar         *<varname>hedef-geniş</varname>,
 const wchar_t *<varname>kaynak-geniş</varname>,
 size_t         <varname>boyut</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para><command>memmove</command> işlevi <varname>boyut</varname> geniş karakteri <varname>kaynak-geniş</varname>’ten <varname>hedef-geniş</varname>’e birbirlerinin üstüne binseler bile kopyalar. Üstüste bime durumunda, işlev, <varname>kaynak-geniş</varname> bloğundaki geniş karakterleri <varname>hedef-geniş</varname> bloğuna dikkatle kopyalar.
      </para>
     <para>
İşlev, <varname>hedef-geniş</varname>'in değeri ile döner.
      </para>
     <para>Bu işlev bir GNU oluşumudur.
</para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para xml:id="glibc-memccpy">
   <indexterm scope="glibc-fn">
    <primary>memccpy</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>void *<command>memccpy</command></funcdef>
     <paramdef>(void *restrict       <varname>hedef</varname>,
 const void *restrict <varname>kaynak</varname>,
 int                  <varname>c</varname>,
 size_t               <varname>boyut</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para>
Bu işlev <varname>boyut</varname> baytlık dizinin içindeki <varname>c</varname>  karakterine kadar olan kısmı <varname>kaynak</varname>’tan <varname>hedef</varname>’e kopyalar. Dönen değer, <varname>hedef</varname>’e kopyalanan kısmın <varname>c</varname> karakterini izleyen baytının adresidir, eğer  <varname>boyut</varname> bayt içinde <varname>c</varname> karakteri bulunamamışsa işlev boş gösterici ile döner.
</para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para xml:id="glibc-memset">
   <indexterm scope="glibc-fn">
    <primary>memset</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>void *<command>memset</command></funcdef>
     <paramdef>(void  *<varname>blok</varname>,
 int    <varname>c</varname>,
 size_t <varname>boyut</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para>
Bu işlev, <varname>c</varname> değerini (<command>unsigned char</command> türüne dönüştürerek) <varname>blok</varname> adresinden başlayan nesnenin ilk <varname>boyut</varname> baytının her birine kopyalar ve <varname>blok</varname>’un değeri ile döner.
</para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para xml:id="glibc-wmemset">
   <indexterm scope="glibc-fn">
    <primary>wmemset</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>wchar_t *<command>wmemset</command></funcdef>
     <paramdef>(wchar_t *<varname>blok</varname>,
 wchar_t  <varname>wc</varname>,
 size_t   <varname>boyut</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para>
Bu işlev, <varname>wc</varname> değerini <varname>blok</varname> adresinden başlayan nesnenin ilk <varname>boyut</varname> geniş karakterinin her birine kopyalar ve <varname>blok</varname>’un değeri ile döner.
</para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para xml:id="glibc-strcpy">
   <indexterm scope="glibc-fn">
    <primary>strcpy</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>char *<command>strcpy</command></funcdef>
     <paramdef>(char *restrict       <varname>hedef</varname>,
 const char *restrict <varname>kaynak</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para><command>strcpy</command> işlevi <varname>kaynak</varname> dizgesini (sonlandırıcı boş karaktere kadar) <varname>hedef</varname> dizgesine kopyalar. Bu işlevde <varname>kaynak</varname> dizgesinin <varname>hedef</varname> dizgesinin üzerine binmesi durumundaki davranışı tanımsızdır. İşlev, <varname>hedef</varname>’in değeri ile döner.
</para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para xml:id="glibc-wcscpy">
   <indexterm scope="glibc-fn">
    <primary>wcscpy</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>wchar_t *<command>wcscpy</command></funcdef>
     <paramdef>(wchar_t *restrict       <varname>hedef-geniş</varname>,
 const wchar_t *restrict <varname>kaynak-geniş</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para><command>wcscpy</command> işlevi <varname>kaynak-geniş</varname> dizgesini (sonlandırıcı boş geniş karaktere kadar) <varname>hedef-geniş</varname> dizgesine kopyalar. Bu işlevde <varname>kaynak-geniş</varname> dizgesinin  <varname>hedef-geniş</varname> dizgesinin üzerine binmesi durumundaki davranışı tanımsızdır. İşlev, <varname>hedef-geniş</varname>’in değeri ile döner.
</para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para xml:id="glibc-strncpy">
   <indexterm scope="glibc-fn">
    <primary>strncpy</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>char *<command>strncpy</command></funcdef>
     <paramdef>(char *restrict       <varname>hedef</varname>,
 const char *restrict <varname>kaynak</varname>,
 size_t               <varname>boyut</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para>
Bu işlev <varname>boyut</varname> sayıda karakteri <varname>hedef</varname> dizgesine kopyalamak dışında <command>strcpy</command> işlevi gibidir.
      </para>
     <para><varname>kaynak</varname> dizgesinin uzunluğu <varname>boyut</varname> bayttan uzunsa işlev, ilk <varname>boyut</varname> karakteri kopyalar. Bu durumda <varname>hedef</varname> dizgesi boş karakteri içermez.
      </para>
     <para><varname>kaynak</varname> dizgesinin uzunluğu <varname>boyut</varname> bayttan kısaysa <varname>kaynak</varname> dizgesi ile boş karakterden sonraki <varname>boyut</varname> bayta kadar olan baytlar boş karakterlerle doldurularak <varname>hedef</varname> dizgesine kopyalanır. Bu işlev az kullanışlıdır ama ISO C standardında belirtilmiştir.
      </para>
     <para>
Üstüste binme durumunda <command>strncpy</command> işlevinin davranışı tanımsızdır.
      </para>
     <para><command>strncpy</command> işlevinin kullanımı <command>strcpy</command> işlevinin aksine <varname>hedef</varname> için ayrılan alanın dışına taşan yazma ile ilgili yazılım hatalarından kaçınmak için bir yöntem sunar. Ancak, yazılımı yavaşlatır, çünkü büyük ihtimalle nispeten küçük bir dizgenin, oldukça büyük bir alana kopyalanması sözkonusu olacak ve dizgeden artan boş alanın boş karakterlerle doldurulması için boşuna zaman harcanacaktır.
</para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para xml:id="glibc-wcsncpy">
   <indexterm scope="glibc-fn">
    <primary>wcsncpy</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>wchar_t *<command>wcsncpy</command></funcdef>
     <paramdef>(wchar_t *restrict       <varname>hedef-geniş</varname>,
 const wchar_t *restrict <varname>kaynak-geniş</varname>,
 size_t                  <varname>boyut</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para>
Bu işlev <varname>boyut</varname> sayıda geniş karakteri <varname>hedef-geniş</varname> dizgesine kopyalamak dışında <command>wcscpy</command> işlevi gibidir.
      </para>
     <para><varname>kaynak-geniş</varname> dizgesinin uzunluğu <varname>boyut</varname> geniş karakterden uzunsa işlev, ilk <varname>boyut</varname> geniş karakteri kopyalar. Bu durumda <varname>hedef-geniş</varname> dizgesi boş geniş karakteri içermez.
      </para>
     <para><varname>kaynak-geniş</varname> dizgesinin uzunluğu <varname>boyut</varname> geniş karakterden kısaysa <varname>kaynak-geniş</varname> dizgesi ile boş geniş karakterden sonraki <varname>boyut</varname> geniş karaktere kadar olan kısım boş geniş karakterlerle doldurularak <varname>hedef-geniş</varname> dizgesine kopyalanır. Bu işlev az kullanışlıdır ama ISO C standardında belirtilmiştir.
      </para>
     <para>
Üstüste binme durumunda <command>wcsncpy</command> işlevinin davranışı tanımsızdır.
      </para>
     <para><command>wcsncpy</command> işlevinin kullanımı <command>wcscpy</command> işlevinin aksine <varname>hedef-geniş</varname> için ayrılan alanın dışına taşan yazma ile ilgili yazılım hatalarından kaçınmak için bir yöntem sunar. Ancak, yazılımı yavaşlatır, çünkü büyük ihtimalle nispeten küçük bir dizgenin, oldukça büyük bir alana kopyalanması sözkonusu olacak ve dizgeden artan boş alanın boş geniş karakterlerle doldurulması için boşuna zaman harcanacaktır.
</para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para xml:id="glibc-strdup">
   <indexterm scope="glibc-fn">
    <primary>strdup</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>char *<command>strdup</command></funcdef>
     <paramdef>(const char *<varname>s</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para>
Bu işlev boş karakter sonlandırmalı <varname>s</varname> dizgesini yeni bir bellek alanına kopyalar. Yeni dizge için yer ayırma işlemi <command>malloc</command> ile yapılır; bkz. <xref linkend="glibc-Unconstrained-Allocation"/>. <command>malloc</command> yeni dizge için yer ayıramazsa işlev boş gösterici ile döner, aksi takdirde yeni dizge için bir gösterici ile döner.
</para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para xml:id="glibc-wcsdup">
   <indexterm scope="glibc-fn">
    <primary>wcsdup</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>wchar_t *<command>wcsdup</command></funcdef>
     <paramdef>(const wchar_t *<varname>ws</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para>
Bu işlev boş geniş karakter sonlandırmalı <varname>ws</varname> dizgesini yeni bir bellek alanına kopyalar. Yeni geniş karakterli dizge için yer ayırma işlemi <command>malloc</command> ile yapılır; bkz. <xref linkend="glibc-Unconstrained-Allocation"/>. <command>malloc</command> yeni geniş karakterli dizge için yer ayıramazsa işlev boş gösterici ile döner, aksi takdirde yeni geniş karakterli dizge için bir gösterici ile döner.
      </para>
     <para>
Bu işlev bir GNU oluşumudur.
</para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para xml:id="glibc-strndup">
   <indexterm scope="glibc-fn">
    <primary>strndup</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>char *<command>strndup</command></funcdef>
     <paramdef>(const char *<varname>s</varname>,
 size_t      <varname>boyut</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para>
Bu işlev en fazla <varname>boyut</varname> karakteri kopyalamak dışında <command>strdup</command> işlevi gibidir.
      </para>
     <para><varname>s</varname> dizgesinin uzunluğu <varname>boyut</varname> bayttan uzun ise işlev ilk <varname>boyut</varname> baytı kopyalar ve sonuna bir boş karakter ekler, aksi takdirde tüm karakterler kopyalanır ve dizge sonlandırılır.
      </para>
     <para>
Bu işlev hedef dizgeyi daima bir boş karakter ile sonlandırması bakımından da <command>strncpy</command> işlevinden farklıdır.
      </para>
     <para><command>strndup</command> işlevi bir GNU oluşumudur.
</para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para xml:id="glibc-stpcpy">
   <indexterm scope="glibc-fn">
    <primary>stpcpy</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>char *<command>stpcpy</command></funcdef>
     <paramdef>(char *restrict       <varname>hedef</varname>,
 const char *restrict <varname>kaynak</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para>
Bu işlev <varname>hedef</varname> dizgesinin sonunu gösteren bir gösterici ile dönmesi dışında <command>strcpy</command> işlevi gibidir.
      </para>
     <para>
Örneğin, bu yazılımda <literal>foo</literal> ve <literal>bar</literal> birleştirilerek <literal>foobar</literal> üretilmekte ve çıktılanmaktadır:
   </para>
     <para>
      <screen>
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;

int
main (void)
{
  char tampon[10];
  char *hedef = tampon;
  hedef = stpcpy (hedef, "foo");
  hedef = stpcpy (hedef, "bar");
  puts (tampon);
  return 0;
}
</screen>
     </para>
     <para>
Bu işlev ISO ya da POSIX standardının parçası değildir ve Unix sistemleri ile ilgili bir özel işlev de değildir. Tabii ki MS-DOS'dan geliyor.
      </para>
     <para>
Dizgelerin birbirinin üstüne binmesi durumundaki davranış tanımsızdır. İşlev <filename>string.h</filename> başlık dosyasında bildirilmiştir.
</para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para xml:id="glibc-wcpcpy">
   <indexterm scope="glibc-fn">
    <primary>wcpcpy</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>wchar_t *<command>wcpcpy</command></funcdef>
     <paramdef>(wchar_t *restrict       <varname>hedef-geniş</varname>,
 const wchar_t *restrict <varname>kaynak-geniş</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para>
Bu işlev <varname>hedef-geniş</varname> dizgesinin sonunu gösteren bir gösterici ile dönmesi dışında <command>wcscpy</command> işlevi gibidir. İşlev kopyalanan dizgenin başlangıç adresi ile değil, dizgeyi sonlandıran boş geniş karakterin adresi ile döner.
      </para>
     <para>
Bu işlev bir ISO veya POSIX oluşumu değildir, ancak GNU C kütüphanesi geliştirilirken kullanışlı bulunmuştur.
      </para>
     <para>
Üstüste binme durumunda <command>wcpcpy</command> işlevinin davranışı tanımsızdır.
      </para>
     <para><command>wcpcpy</command> bir GNU oluşumudur ve  <filename>wchar.h</filename> başlık dosyasında bildirilmiştir.
</para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para xml:id="glibc-stpncpy">
   <indexterm scope="glibc-fn">
    <primary>stpncpy</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>char *<command>stpncpy</command></funcdef>
     <paramdef>(char *restrict       <varname>hedef</varname>,
 const char *restrict <varname>kaynak</varname>,
 size_t               <varname>boyut</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para>
Bu işlev, <varname>hedef</varname>’e ilk <varname>boyut</varname> karakteri kopyalaması dışında <command>stpcpy</command> gibidir.
      </para>
     <para><varname>kaynak</varname> dizgesinin uzunluğu <varname>boyut</varname> bayttan uzunsa işlev, ilk <varname>boyut</varname> karakteri kopyalar ve kopyalanan son karakterden sonraki baytın adresi ile döner. Bu durumda <varname>hedef</varname> dizgesi boş karakteri içermez.
      </para>
     <para><varname>kaynak</varname> dizgesinin uzunluğu <varname>boyut</varname> bayttan kısaysa <varname>kaynak</varname> dizgesinin boş karakterinden sonraki <varname>boyut</varname> bayta kadar olan baytlar boş karakterlerle doldurularak <varname>hedef</varname> dizgesine kopyalanır ve yazılan <emphasis>ilk</emphasis> boş karakterin adresi ile döner.  Bu işlev az kullanışlıdır ama  <command>strncpy</command> işlevinin davranışı kullanışlı bulunduğundan gerçeklenmiştir.
      </para>
     <para>
Bu işlev bir ISO veya POSIX oluşumu değildir, ancak GNU C kütüphanesi geliştirilirken kullanışlı bulunmuştur.
      </para>
     <para>
Dizgelerin birbirinin üstüne binmesi durumundaki davranış tanımsızdır. İşlev <filename>string.h</filename> başlık dosyasında bildirilmiştir.
</para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para xml:id="glibc-wcpncpy">
   <indexterm scope="glibc-fn">
    <primary>wcpncpy</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>wchar_t *<command>wcpncpy</command></funcdef>
     <paramdef>(wchar_t *restrict       <varname>hedef-geniş</varname>,
 const wchar_t *restrict <varname>kaynak-geniş</varname>,
 size_t                  <varname>boyut</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para>
Bu işlev, <varname>hedef-geniş</varname>’e ilk <varname>boyut</varname> karakteri kopyalaması dışında <command>wcpcpy</command> gibidir.
      </para>
     <para><varname>kaynak-geniş</varname> dizgesinin uzunluğu <varname>boyut</varname> bayttan uzunsa işlev, ilk <varname>boyut</varname> geniş karakteri kopyalar ve kopyalanan son boş olmayan geniş karakterden sonraki geniş karaktere bir gösterici ile döner. Bu durumda <varname>hedef-geniş</varname> dizgesi boş geniş karakteri içermez.
      </para>
     <para><varname>kaynak-geniş</varname> dizgesinin uzunluğu <varname>boyut</varname> bayttan kısaysa <varname>kaynak-geniş</varname> dizgesinin boş geniş karakterinden sonraki <varname>boyut</varname> bayta kadar olan alanlar boş geniş karakterlerle doldurularak <varname>hedef-geniş</varname> dizgesine kopyalanır ve yazılan <emphasis>ilk</emphasis> boş geniş karakterin adresi ile döner.  Bu işlev az kullanışlıdır ama  <command>wcsncpy</command> işlevinin davranışı kullanışlı bulunduğundan gerçeklenmiştir.
      </para>
     <para>
Bu işlev bir ISO veya POSIX oluşumu değildir, ancak GNU C kütüphanesi geliştirilirken kullanışlı bulunmuştur.
      </para>
     <para>
Üstüste binme durumunda <command>wcpncpy</command> işlevinin davranışı tanımsızdır.
      </para>
     <para><command>wcpncpy</command> bir GNU oluşumudur ve <filename>wchar.h</filename> başlık dosyasında bildirilmiştir.
</para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para xml:id="glibc-strdupa">
   <indexterm scope="glibc-fn">
    <primary>strdupa</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="makro">
     <funcdef>char *<command>strdupa</command></funcdef>
     <paramdef>(const char *<varname>s</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para>
Bu makro, <command>malloc</command> (<xref linkend="glibc-Variable-Size-Automatic"/>) yerine <command>alloca</command> kullanarak yeni bir dizge ayırmak dışında <command>strdup</command> gibidir. Yani, <command>alloca</command> kullanarak ayrılan bellek blokları ile aynı sınırlamalara sahip bir dizi döner.
      </para>
     <para>
Çeşitli sebeplerle <command>strdupa</command> sadece bir makro olarak gerçeklenmiştir; yani bir işlev gibi adresini alamazsınız. Bu sınırlama dışında bir işlev olarak kullanışlıdır. Aşağıdaki kodda <command>malloc</command>        kullanıldığında işlemin ne kadar pahalıya malolduğu gösterilmiştir.
      </para>
     <para>
      <screen>
#include &lt;paths.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;

const char path[] = _PATH_STDPATH;

int
main (void)
{
  char *wr_path = strdupa (path);
  char *cp = strtok (wr_path, ":");

  while (cp != NULL)
    {
      puts (cp);
      cp = strtok (NULL, ":");
    }
  return 0;
}
</screen>
     </para>
     <para><command>strtok</command>'un doğrudan <varname>path</varname> kullanılarak çağrılmasının geçersiz olduğuna dikkat edin. Ayrıca, <command>strdupa</command>
 parametre aktarımında girişime sebep olabilen <command>alloca</command>'yı  (<xref linkend="glibc-Variable-Size-Automatic"/>) kullandığından  <command>strtok</command>'un argüman listesinde  <command>strdupa</command> kullanımına izin verilmez.
      </para>
     <para>
Bu işlev sadece GCC ile kullanılabilir.
</para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para xml:id="glibc-strndupa">
   <indexterm scope="glibc-fn">
    <primary>strndupa</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="makro">
     <funcdef>char *<command>strndupa</command></funcdef>
     <paramdef>(const char *<varname>s</varname>,
 size_t      <varname>boyut</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para>
Bu işlev, <link linkend="glibc-Variable-Size-Automatic"><command>alloca</command></link> kullanarak yeni bir dizge ayırmak dışında  <command>strndup</command> gibidir. <command>strdupa</command> için geçerli olan yararlar ve sınırlamalar, <command>strndupa</command> için de geçerlidir.
      </para>
     <para>
Bu işlev de <command>strdupa</command> gibi sadece makro olarak gerçeklenmiştir. <command>strdupa</command> gibi bu makro da bir işlev çağrısının argüman listesinde kullanılamaz.
      </para>
     <para>
Bu işlev sadece GCC ile kullanılabilir.
</para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para xml:id="glibc-strcat">
   <indexterm scope="glibc-fn">
    <primary>strcat</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>char *<command>strcat</command></funcdef>
     <paramdef>(char *restrict       <varname>hedef</varname>,
 const char *restrict <varname>kaynak</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para><varname>kaynak</varname> dizgesini <varname>hedef</varname> dizgesinin üzerine yazmak yerine  <varname>hedef</varname> dizgesinin sonuna ekleyerek onunla birleştirmesi dışında <command>strcpy</command> işlevine benzer. <varname>kaynak</varname> dizgesinin ilk karakteri <varname>hedef</varname> dizgesini sonlandıran boş karakterin üzerine yazılır.
      </para>
     <para><command>strcat</command> işlevinin tanımı aşağıdakine eşdeğerdir:
      </para>
     <para>
      <screen>
char *
strcat (char *restrict hedef, const char *restrict kaynak)
{
  strcpy (hedef + strlen (hedef), kaynak);
  return hedef;
}
</screen>
     </para>
     <para>
Dizgelerin üstüste binmesi durumu için bu işlevin davranışı tanımlanmamıştır.
</para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para xml:id="glibc-wcscat">
   <indexterm scope="glibc-fn">
    <primary>wcscat</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>wchar_t *<command>wcscat</command></funcdef>
     <paramdef>(wchar_t *restrict       <varname>hedef-geniş</varname>,
 const wchar_t *restrict <varname>kaynak-geniş</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para><varname>kaynak-geniş</varname> dizgesini <varname>hedef-geniş</varname> dizgesinin üzerine yazmak yerine  <varname>hedef-geniş</varname> dizgesinin sonuna ekleyerek onunla birleştirmesi dışında <command>wcscpy</command> işlevine benzer. <varname>kaynak-geniş</varname> dizgesinin ilk geniş karakteri<varname>hedef-geniş</varname> dizgesini sonlandıran boş geniş karakterin üzerine yazılır.
      </para>
     <para><command>wcscat</command> işlevinin tanımı aşağıdakine eşdeğerdir:
      </para>
     <para>
      <screen>
wchar_t *
wcscat (wchar_t *hedefg, const wchar_t *kaynakg)
{
  wcscpy (hedefg + wcslen (hedefg), kaynakg);
  return hedefg;
}
</screen>
     </para>
     <para>
Dizgelerin üstüste binmesi durumu için bu işlevin davranışı tanımlanmamıştır.
      </para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para><command>strcat</command> ya da <command>wcscat</command> (ardından da  <command>strncat</command> ya da <command>wcsncar</command>) işlevlerini kullanan yazılımcılar kolayca ihtiyatsız ve hatta deli olarak tanımlanabilir. Hemen hemen her durumda, ortak dizge uzunlukları bilinir (hem, tampon boyutunun yeterli olacağını kim bilebilir ki?). Veya en azından, çeşitli işlev çağrılarının sonuçları izlenerek bilinir. Ama yine de <command>strcat</command>/<command>wcscat</command> işlevleri yetersizdir. Kopyalama başladığında hedef dizgenin sonunu bulmak için gereksiz zaman harcanacaktır. Aşağıdaki örneğe bakınız:
   </para>
  <para>
   <indexterm scope="glibc-cp">
    <primary sortas="va_copy">__va_copy</primary>
   </indexterm>
   <indexterm scope="glibc-cp">
    <primary>va_copy</primary>
   </indexterm>
   <screen>
/* Bu işlev birçok dizgeyi birleştirir.
   Son parametre <command>NULL</command> olmalıdır.  */
char *
concat (const char *dizge, …)
{
  va_list ap, ap2;
  size_t toplam = 1;
  const char *s;
  char *sonuc;

  va_start (ap, dizge);
  /* Aslında <command>va_copy</command>, ama geç dönem gcc sürümleri
     bu ismi tanır.
  __va_copy (ap2, ap);

  /* Bakalım, ne kadar yer lazımmış.  */
  for (s = dizge; s != NULL; s = va_arg (ap, const char *))
    toplam += strlen (s);

  va_end (ap);

  sonuc = (char *) malloc (toplam);
  if (sonuc != NULL)
    {
      sonuc[0] = '\0';

      /* Dizgeleri kopyalayalım.  */
      for (s = dizge; s != NULL; s = va_arg (ap2, const char *))
        strcat (sonuc, s);
    }

  va_end (ap2);

  return sonuc;
}
</screen>
  </para>
  <para>
Basit gibi görünüyor, özellikle dizgelerin kopyalandığı ikinci döngü. Her biri 100 baytlık on dizgenin birleştirildiğini varsayalım. Aradığımız ikinci dizge için dizgenin sonunda zaten 100 bayt ayrıldığından sonraki dizgeyi ekleyebiliriz. Toplamda tüm dizgeler için ara sonuçlarla birlikte uzunluk 5500! olur. Bellek ayırma için yapılan arama ile kopyalamayı birleştirisek bu işlevi daha verimli kılabiliriz:
   </para>
  <para>
   <screen>
char *
concat (const char *dizge, …)
{
  va_list ap;
  size_t tutulan = 100;
  char *sonuc = (char *) malloc (tutulan);

  if (sonuc != NULL)
    {
      char *yeniwp;
      char *wp;

      va_start (ap, dizge);

      wp = sonuc;
      for (s = dizge; s != NULL; s = va_arg (ap, const char *))
        {
          size_t uzunluk = strlen (s);

          /* Gerekiyorsa, tutulan belleği arttıralım.  */
          if (wp + uzunluk + 1 &gt; sonuc + tutulan)
            {
              tutulan = (tutulan + uzunluk) * 2;
              yeniwp = (char *) realloc (sonuc, tutulan);
              if (newp == NULL)
                {
                  free (sonuc);
                  return NULL;
                }
              wp = yeniwp + (wp - sonuc);
              sonuc = yeniwp;
            }

          wp = mempcpy (wp, s, uzunluk);
        }

      /* sonuclanan dizgeyi sonlandıralım.  */
      *wp++ = '\0';

      /* Belleği tam istenen boyuta ayarlayalım.  */
      yeniwp = realloc (sonuc, wp - sonuc);
      if (yeniwp != NULL)
        sonuc = yeniwp;

      va_end (ap);
    }

  return sonuc;
}
</screen>
  </para>
  <para>
Girdi dizgeleri hakkına biraz daha fazla bilgi birikimi kullanarak bellek ayırma işlemi daha hassas yapılabilirdi. Burada farklı olarak <command>strcat</command> işlevini asla kullanmadık. Ara sonuçların izini sürerek dizge sonlarının bulunmasını güvenceye aldık ve <command>mempcpy</command> işlevini kullandık. Ayrıca, dizgeleri elde etmek
 bakımından daha doğal görünen <command>stpcpy</command> işlevini de kullanmadık. Ama zaten, dizge uzunluğunu bildiğimizden bu gerekli değildi ve bu sebeple daha hızlı bellek kopyalaması yapabildik. Örneğimiz geniş karakterler için de aynı şekilde çalışırdı.
   </para>
  <para>
Bir yazılımcı <command>strcat</command> kullanmaya karar vermeden önce iki kere düşünmeli ve hesaplanmış sonuçların getirilerinden yararlanmak için kod tekrar yazılamaz mı acaba diye bakmalıdır. Tekrarlayalım:  <command>strcat</command> işlevinin kullanılması hemen hemen daima gereksizdir.
    </para>
  <para xml:id="glibc-strncat">
   <indexterm scope="glibc-fn">
    <primary>strncat</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>char *<command>strncat</command></funcdef>
     <paramdef>(char *restrict       <varname>hedef</varname>,
 const char *restrict <varname>kaynak</varname>,
 size_t               <varname>boyut</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para>
Bu işlev, <varname>kaynak</varname> dizgesinin ilk <varname>boyut</varname> karakterini <varname>hedef</varname> dizgesinin sonuna eklemek dışında <command>strcat</command> gibidir.  <varname>hedef</varname> dizgesinin sonuna daima bir boş karakter eklendiğinden <varname>hedef</varname> için ayrılan yer en azından <command><varname>boyut</varname> + 1</command> bayt olmalıdır.
      </para>
     <para><command>strncat</command> işlevi aşağıdaki gibi de gerçekleştirilebilirdi:
      </para>
     <para>
      <screen>
char *
strncat (char *hedef, const char *kaynak, size_t boyut)
{
  hedef[strlen (hedef) + boyut] = '\0';
  strncpy (hedef + strlen (hedef), kaynak, boyut);
  return hedef;
}
</screen>
     </para>
     <para>
Dizgelerin üstüste binmesi durumu için bu işlevin davranışı tanımlanmamıştır.
</para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para xml:id="glibc-wcsncat">
   <indexterm scope="glibc-fn">
    <primary>wcsncat</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>wchar_t *<command>wcsncat</command></funcdef>
     <paramdef>(wchar_t *restrict       <varname>hedef-geniş</varname>,
 const wchar_t *restrict <varname>kaynak-geniş</varname>,
 size_t                  <varname>boyut</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para>
Bu işlev, <varname>kaynak-geniş</varname> dizgesinin ilk <varname>boyut</varname> geniş karakterini <varname>hedef-geniş</varname> dizgesinin sonuna eklemek dışında  <command>wcscat</command> gibidir.  <varname>hedef-geniş</varname> dizgesinin sonuna daima bir boş geniş karakter eklendiğinden <varname>hedef-geniş</varname> için ayrılan yer en azından <command><varname>boyut</varname> + 1</command> bayt olmalıdır.
      </para>
     <para><command>wcscat</command> işlevi aşağıdaki gibi de gerçekleştirilebilirdi:
      </para>
     <para>
      <screen>
wchar_t *
wcsncat (wchar_t *restrict hedefg, const wchar_t *restrict kaynakg,
         size_t boyut)
{
  hedefg[wcslen (hedefg) + boyut] = L'\0';
  wcsncpy (hedefg + wcslen (hedefg), kaynakg, boyut);
  return hedefg;
}
</screen>
     </para>
     <para>
Dizgelerin üstüste binmesi durumu için bu işlevin davranışı tanımlanmamıştır.
      </para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para>
Aşağıdaki örnekte <command>strncpy</command> ve <command>strncat</command> kullanımı gösterilmiştir (Geniş karakterli olarak benzeri yazılabilir). <command>strncat</command> çağrısına dikkat edin, <varname>boyut</varname> parametresi <command>tampon</command> karakter dizisinin üste binmesine karşı korunarak hesaplanmıştır.
   </para>
  <para>
   <screen>
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;

#define BOYUT 12

static char tampon[BOYUT];

main ()
{
  strncpy (tampon, "herkese", BOYUT);
  puts (tampon);
  strncat (tampon, " merhaba", BOYUT - strlen (tampon) - 1);
  puts (tampon);
}
</screen>
  </para>
  <para>
      Kod aşağıdaki gibi bir çıktı üretir:
   </para>
  <para>
   <screen>
herkese
herkese mer
</screen>
  </para>
  <para xml:id="glibc-bcopy">
   <indexterm scope="glibc-fn">
    <primary>bcopy</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>void <command>bcopy</command></funcdef>
     <paramdef>(const void *<varname>kaynak</varname>,
 void       *<varname>hedef</varname>,
 size_t      <varname>boyut</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para>
Bu işlev, BSD'den türetilen, <command>memmove</command>'un kısmen eskimiş bir alternafidir.  Ancak <command>memmove</command> ile eşdeğer değildir, çünkü argümanları aynı sırada değildir ve dönen bir değer yoktur.
</para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para xml:id="glibc-bzero">
   <indexterm scope="glibc-fn">
    <primary>bzero</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>void <command>bzero</command></funcdef>
     <paramdef>(void  *<varname>blok</varname>,
 size_t <varname>boyut</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para>
Bu işlev, BSD'den türetilen, <command>memset</command>'in kısmen eskimiş bir alternafidir.  Ancak <command>memset</command> ile eşdeğer değildir, çünkü sakladığı tek değer sıfırdır.
      </para>
    </funcdescr>
   </funcsynopsis>
  </para>
 </chapter>
 <chapter xml:id="glibc-String-Array-Comparison">
  <info>
   <title>Dizi/Dizge Karşılaştırması</title>
   <titleabbrev>Bayt seviyesi ile karakter seviyesi işlevlerin kıyaslanması.</titleabbrev>
  </info>
  <para/>
  <para><indexterm scope="glibc-cp"><primary>dizi ve dizgelerin karşılaştırması</primary></indexterm><indexterm scope="glibc-cp"><primary>dizge karşılaştırma işlevleri</primary></indexterm><indexterm scope="glibc-cp"><primary>dizi karşılaştırma işlevleri</primary></indexterm><indexterm scope="glibc-cp"><primary>predicates on strings</primary></indexterm><indexterm scope="glibc-cp"><primary>predicates on arrays</primary></indexterm>
Bu kısımdaki işlevleri dizi ve dizge içerikleri üzerinde karşılaştımalar yapmak için kullanabilirsiniz. Eşitliğin denetlenmesi kadar, ayrıca sıralama işlemleri için sıralama işlevleri olarak da kullanılabilirler. Bunun bir örneği olarak <xref linkend="glibc-Searching-and-Sorting"/> bölümüne bakınız.
    </para>
  <para>
C'deki çoğu karşılaştırma işleminin aksine, dizge karşılaştırma işlevleri dizgelerin eşitliğinin varlığında değil <varname>yokluğunda</varname> sıfırdan farklı bir değer ile dönerler. İşaretin değeri eşdeğer olmayan dizgelerin ilk karakterlerinin birbirine göre sırasına bağlıdır: Bir negatif değer ilk dizgenin ikincisinden "küçük", pozitif bir değer ise "büyük" olduğunu gösterir.
    </para>
  <para>
Bu işlevler çoğunlukla sadece eşitlik denetiminde kullanılırlar. Bu, ifade yazım kurallarına uygun olarak <command>! strcmp (s1, s2)</command> gibi bir ifade ile yapılır.
    </para>
  <para>
Bu işlevlerin tümü <filename>string.h</filename> başlık dosyasında bildirilmiştir.
<indexterm scope="glibc-pg"><primary>string.h</primary></indexterm>
    </para>
  <para xml:id="glibc-memcmp">
   <indexterm scope="glibc-fn">
    <primary>memcmp</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>int <command>memcmp</command></funcdef>
     <paramdef>(const void *<varname>a1</varname>,
 const void *<varname>a2</varname>,
 size_t      <varname>boyut</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para><command>memcmp</command> işlevi belleğin <varname>a1</varname> de başlayan <varname>boyut</varname> baytı ile <varname>a2</varname> de başlayan <varname>boyut</varname> baytını karşılaştırır. Dönen değer, ilk farklı bayt çiftleri arasındaki farkın işaretine bağlıdır (önce <command>unsigned char</command> türünden nesneler olarak yorumlanır, sonra da <command>int</command> türüne terfi ettirilirler).
      </para>
     <para>
İki bloğun içeriği aynı ise <command>memcmp</command> sıfır ile döner.
</para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para xml:id="glibc-wmemcmp">
   <indexterm scope="glibc-fn">
    <primary>wmemcmp</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>int <command>wmemcmp</command></funcdef>
     <paramdef>(const wchar_t *<varname>a1</varname>,
 const wchar_t *<varname>a2</varname>,
 size_t         <varname>boyut</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para><command>wmemcmp</command> işlevi başlangıcı <varname>a1</varname>’de olan geniş karakterlerle başlangıcı <varname>a2</varname>’de olan geniş karakterleri karşılaştırır. <varname>a1</varname>’deki <varname>a2</varname>’dekinden farklı ilk geniş karakterin <varname>a2</varname>’dekinden küçük ya da büyük olmasına bağlı olarak sıfırdan küçük ya da büyük bir değerle döner.
      </para>
     <para>
İki bloğun içeriği aynı ise <command>wmemcmp</command> sıfır ile döner.
      </para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para>
Keyfi değerli dizilerde <command>memcmp</command> işlevi çoğunlukla eşitlik denetiminde kullanılır. Genellikle, bayt dizileri dışındaki dizilerde bayt seviyesinde bir karşılaştırma anlamı değildir. Örneğin gerçek sayılardan oluşan dizilerin bayt seviyesinde karşılaştırılması gerçek sayıların değerleri arasındaki ilişki hakkında hiçbir şey söyleyemez.
    </para>
  <para><command>wmemcmp</command> işlevi, bir defada <command>sizeof (wchar_t)</command> bayta baktığından ve bunların sayısı sistem bağımlı olduğundan aslında sadece <command>wchar_t</command> türünde dizilerde kullanışlıdır.
    </para>
  <para>
Ayrıca <command>memcmp</command> işlevini, hizalama gereksinimlerinden dolayı aralarında boşluk bırakılmış yapı nesneleri, sonlarında fazladan boşluk bulunan birleşik yapılar ve ayrılan yere göre küçük olduklarından sonunda fazladan boşluk bulunan dizgeler gibi  "delikler" içeren nesneleri karşılaştırırken dikkatli olmalısınız. Bu "delikler"in içerikleri düzensizdir ve bayt seviyesinden karşılaştırmalar tuhaf sonuçlara sebep olabilir.
    </para>
  <para>
Örneğin, aşağıdaki gibi bir yapı türü tanımında:
   </para>
  <para>
   <screen>
struct foo
  {
    unsigned char tag;
    union
      {
        double f;
        long i;
        char *p;
      } value;
  };
</screen>
  </para>
  <para><command>struct foo</command> türündeki gibi nesneleri <command>memcmp</command> ile karşılaştırmak yerine özelleştirilmiş karşılaştırma işlevlerinin yazılmasını tercih etmelisiniz.
    </para>
  <para xml:id="glibc-strcmp">
   <indexterm scope="glibc-fn">
    <primary>strcmp</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>int <command>strcmp</command></funcdef>
     <paramdef>(const char *<varname>s1</varname>,
 const char *<varname>s2</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para><command>strcmp</command> işlevi <varname>s1</varname> ve <varname>s2</varname> dizgelerini karşılaştırır. Dönen değer, ilk farklı karakter çiftleri arasındaki farkın işaretine bağlıdır (önce <command>unsigned char</command> türünden nesneler olarak yorumlanır, sonra da <command>int</command> türüne terfi ettirilirler).
      </para>
     <para>
İki dizgenin içeriği aynı ise <command>strcmp</command> sıfır ile döner.
      </para>
     <para><command>strcmp</command> işlevi tarafından kullanılan sıralamanın bir sonucu olarak, eğer <varname>s1</varname> dizgesi <varname>s2</varname> dizgesinin bir alt dizgesi ise <varname>s1</varname> dizgesi, <varname>s2</varname>’den "küçük" kabul edilir.
      </para>
     <para><command>strcmp</command> işlevi dizgelerin yazıldıkları dilin sıralama teamüllerini almaz. Bunlardan birini almak için <command>strcoll</command> kullanın.
</para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para xml:id="glibc-wcscmp">
   <indexterm scope="glibc-fn">
    <primary>wcscmp</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>int <command>wcscmp</command></funcdef>
     <paramdef>(const wchar_t *<varname>ws1</varname>,
 const wchar_t *<varname>ws2</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para><command>wcscmp</command> işlevi <varname>ws1</varname> ve <varname>ws2</varname> dizgelerini karşılaştırır. <varname>ws1</varname>’deki <varname>ws2</varname>’dekinden farklı ilk geniş karakterin <varname>ws2</varname>’dekinden küçük ya da büyük olmasına bağlı olarak sıfırdan küçük ya da büyük bir değerle döner.
      </para>
     <para>
İki dizgenin içeriği aynı ise <command>strcmp</command> sıfır ile döner.
      </para>
     <para><command>wcscmp</command> işlevi tarafından kullanılan sıralamanın bir sonucu olarak, eğer <varname>ws1</varname> dizgesi <varname>ws2</varname> dizgesinin bir alt dizgesi ise <varname>ws1</varname> dizgesi, <varname>ws2</varname>’den "küçük" kabul edilir.
      </para>
     <para><command>wcscmp</command> işlevi dizgelerin yazıldıkları dilin sıralama teamüllerini almaz. Bunlardan birini almak için <command>wcscoll</command> kullanın.
</para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para xml:id="glibc-strcasecmp">
   <indexterm scope="glibc-fn">
    <primary>strcasecmp</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>int <command>strcasecmp</command></funcdef>
     <paramdef>(const char *<varname>s1</varname>,
 const char *<varname>s2</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para>
Bu işlev harf büyüklükleri arasındaki farkları yok sayması dışında <command>strcmp</command> gibidir. Küçük ve büyük harfler arasındaki ilişki o an seçilmiş olan yerele bağlıdır. Standart <command>"C"</command> yerelinde Ä ve ä karakterleri eşleşmez ama, bu karakterleri alfabelerinde kullanan yerellerde eşleşirler.
      </para>
     <para><command>strcasecmp</command> BSD'den alınmıştır.
</para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para xml:id="glibc-wcscasecmp">
   <indexterm scope="glibc-fn">
    <primary>wcscasecmp</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>int <command>wcscasecmp</command></funcdef>
     <paramdef>(const wchar_t *<varname>ws1</varname>,
 const wchar_T *<varname>ws2</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para>
Bu işlev harf büyüklükleri arasındaki farkları yok sayması dışında <command>&gt;wcscmp</command> gibidir. Küçük ve büyük harfler arasındaki ilişki o an seçilmiş olan yerele bağlıdır. Standart <command>"C"</command> yerelinde Ä ve ä karakterleri eşleşmez ama, bu karakterleri alfabelerinde kullanan yerellerde eşleşirler.
      </para>
     <para><command>wcscasecmp</command> işlevi bir GNU oluşumudur.
</para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para xml:id="glibc-strncmp">
   <indexterm scope="glibc-fn">
    <primary>strncmp</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>int <command>strncmp</command></funcdef>
     <paramdef>(const char *<varname>s1</varname>,
 const char *<varname>s2</varname>,
 size_t      <varname>boyut</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para>
Bu işlev ilk <varname>boyut</varname> karakterin karşılaştırılması dışında <command>strcmp</command> gibidir. Başka bir deyişle, iki dizgenin ilk <varname>boyut</varname> karakteri aynıysa işlev sıfırla döner.
</para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para xml:id="glibc-wcsncmp">
   <indexterm scope="glibc-fn">
    <primary>wcsncmp</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>int <command>wcsncmp</command></funcdef>
     <paramdef>(const wchar_t *<varname>ws1</varname>,
 const wchar_t *<varname>ws2</varname>,
 size_t         <varname>boyut</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para>
Bu işlev ilk <varname>boyut</varname> geniş karakterin karşılaştırılması dışında <command>wcscmp</command> gibidir. Başka bir deyişle, iki dizgenin ilk <varname>boyut</varname> geniş karakteri aynıysa işlev sıfırla döner.
</para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para xml:id="glibc-strncasecmp">
   <indexterm scope="glibc-fn">
    <primary>strncasecmp</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>int <command>strncasecmp</command></funcdef>
     <paramdef>(const char *<varname>s1</varname>,
 const char *<varname>s2</varname>,
 size_t      <varname>n</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para>
Bu işlev harf büyüklükleri arasındaki farkları yok sayması dışında <command>strncmp</command> gibidir. <command>strcasecmp</command> gibi küçük ve büyük harfler arasındaki ilişki o an seçilmiş olan yerele bağlıdır.
      </para>
     <para><command>strncasecmp</command> işlevi bir GNU oluşumudur.
</para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para xml:id="glibc-wcsncasecmp">
   <indexterm scope="glibc-fn">
    <primary>wcsncasecmp</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>int <command>wcsncasecmp</command></funcdef>
     <paramdef>(const wchar_t *<varname>ws1</varname>,
 const wchar_t *<varname>s2</varname>,
 size_t         <varname>n</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para>
Bu işlev harf büyüklükleri arasındaki farkları yok sayması dışında <command>wcsncmp</command> gibidir. <command>wcscasecmp</command> gibi küçük ve büyük harfler arasındaki ilişki o an seçilmiş olan yerele bağlıdır.
      </para>
     <para><command>wcsncasecmp</command> işlevi bir GNU oluşumudur.
      </para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para>
Aşağıdaki örnkelerde  <command>strcmp</command> ve <command>strncmp</command> kullanımı gösterilmiştir. Bu örneklerin benzerleri geniş karakterler için de yazılabilir. Bu örneklerde ASCII karakter ümesinin kullanıldığı varsayılmıştır. (Diğer karakter kümeleri -- EBCDIC diyelim -- kullanılırsa, harfler farklı sayısal değerlerle
 ilişkilendirileceğinden dönen değerler ve sıralama farklı olacaktır.)
   </para>
  <para>
   <screen>
strcmp ("hello", "hello";)
    =&gt; 0    /* Bu iki dizge aynıdır. */
strcmp ("hello", "Hello")
    =&gt; 32   /* Karşılaştırma harf büyüklüklerine duyarlıdır. */
strcmp ("hello", "world")
    =&gt; -15  /* <command>'h'</command> karakteri <command>'w'</command>’den öncedir. */
strcmp ("hello", "hello, world")
    =&gt; -44  /* Bir boş karaktere karşılık virgül. */
strncmp ("hello", "hello, world", 5)
    =&gt; 0    /* İlk 5 karakter aynıdır. */
strncmp ("hello, world", "hello, stupid world!!!", 5)
    =&gt; 0    /* İlk 5 karakter aynıdır. */
</screen>
  </para>
  <para xml:id="glibc-strverscmp">
   <indexterm scope="glibc-fn">
    <primary>strverscmp</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>int <command>strverscmp</command></funcdef>
     <paramdef>(const char *<varname>s1</varname>,
 const char *<varname>s2</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para><command>strverscmp</command> işlevi <varname>s1</varname> ve <varname>s2</varname> dizgelerini indis/sürüm numarası içerdiğini varsayarak karşılaştırır. Dönen değer <command>strcmp</command> işlevindeki gibidir. Aslında, dizgeler bir rakam içermiyorsa işlev, <command>strcmp</command> işlevi gibi davranır.
      </para>
     <para>
Temel olarak, dizgeler için normal karşılaştırma (karakter karakter) uygulanır, dizgelerden birinde bir rakama rastlandığı anda özel karşılaştırma kipine girilir ve birbirini izleyen rakamlar bir bütün olarak ele alınır, sayılar arasında bir fark tespit edilemezse tekrar normal karşılaştırma kipine dönülür. İki tür sayılar vardır: "tamsayı" ve "ondalık kısım" (bunlar '0' ile başlar). Bu sayı türleri sıralamayı aşağıdaki sırada etkiler:
      </para>
     <itemizedlist>
      <listitem>
       <para>
tamsayı/tamsayı: Bildik şekilde karşılaştırılır.
        </para>
      </listitem>
      <listitem>
       <para>
ondalık/tamsayı: Ondalık sayı tamsayıdan küçüktür.  Burada da bir sürpriz yok.
        </para>
      </listitem>
      <listitem>
       <para>
ondalık/ondalık: Burası biraz karışık. Ondalık kısımların baştan en uzun sıfırlı olanı diğerinden küçüktür; aksi takdirde normal karşılaştırma yapılır.
       </para>
      </listitem>
     </itemizedlist>
     <para>
      <screen>
strverscmp ("rakam yok", "rakam yok")
    =&gt; 0    /* strcmp ile aynı davranış. */
strverscmp ("item#99", "item#100")
    =&gt; &lt;0   /* önekleri aynı, ama 99 &lt; 100. */
strverscmp ("alpha1", "alpha001")
    =&gt; &gt;0   /* ondalık kısım tamsayıdan küçüktür. */
strverscmp ("part1_f012", "part1_f01")
    =&gt; &gt;0   /* iki ondalık kısım. */
strverscmp ("foo.009", "foo.0")
    =&gt; &lt;0   /* keza, ama sıfır sayısı öncelikli. */
</screen>
     </para>
     <para>
Bu işlev özellikle dosya ismi sıralamasında kullanılır, çünkü dosya isimleri genellikle indis/sürüm numaraları içerir.
      </para>
     <para><command>strverscmp</command> işlevi bir GNU oluşumudur.
</para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para xml:id="glibc-bcmp">
   <indexterm scope="glibc-fn">
    <primary>bcmp</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>int <command>bcmp</command></funcdef>
     <paramdef>(const void *<varname>a1</varname>,
 const void *<varname>a2</varname>,
 size_t      <varname>boyut</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para>
Bu işlev BSD'den alınmıştır ve <command>memcmp</command> için eskimiş bir isimdir.
      </para>
    </funcdescr>
   </funcsynopsis>
  </para>
 </chapter>
 <chapter xml:id="glibc-Collation-Functions">
  <info>
   <title>Dizgeleri Yerele Özgü Karşılaştırma İşlevleri</title>
   <titleabbrev>Yerele özgü karakter sıralamasına uygun dizge karşılaştırma işlevleri.</titleabbrev>
  </info>
  <para><indexterm scope="glibc-cp"><primary>yerele özgü dizge karşılaştırma</primary></indexterm><indexterm scope="glibc-cp"><primary>dizgeleri yerele özgü karşılaştırma işlevleri</primary></indexterm>
Bazı yerellerde alfabetik sıralama karakter kodlarının sıralamasından farklıdır.<footnote><para>Ç.N. - Örneğin, Türkçedeki I ve İ harfleri gibi,
 I harfinin karakter numarası <literal>U+0049</literal> iken İ harfininki  <literal>U+0130</literal> J hafinin karakter kodu ise <literal>U+004A</literal>'dır. Yani IİJ alfabetik sıralaması ile <literal>U+0049, U+0130, U+004A</literal> karakter kodu sıralaması farklıdır. O kadar ki, bazı karakterlerimizi sırf karakter kodlamasına göre sıralasaydık, sıralamada sona kalacaklardır ki bu sorunlar geçmişte yazılımcıları çok uğraştırmıştı. GNU C kütüphanesi bu sorunları kökten çözmüştür.</para></footnote>
    </para>
  <para><command>strcoll</command>, <command>strxfrm</command>, (<filename>string.h</filename> dosyasında bildirilmişlerdir) <command>wcscoll</command> ve <command>wcsxfrm</command> (<filename>wchar.h</filename> dosyasında bildirilmişlerdir) işlevlerini yerele özgü karakter sıralamasına uygun dizge karşılaştırmalarında kullanabilirsiniz. Bu işlevlerin kullanacağı yereli <command>LC_COLLATE</command> yerel kategorisine gerekli değeri atayarak belirtebilirsiniz. Daha ayrıntılı bilgi edinmek için <xref linkend="glibc-Locales"/> kısmına bakınız.
<indexterm scope="glibc-pg"><primary>string.h</primary></indexterm>
<indexterm scope="glibc-pg"><primary>wchar.h</primary></indexterm>
    </para>
  <para>
Standart C yerelinde karakter sıralaması bakımından <command>strcoll</command> ile <command>strcmp</command> işlevlerinin davranışlarında bir fark yoktur. Benzer olarak  <command>wcscoll</command> ve <command>wcscmp</command> işlevleri de bu bakımdan aynıdır.
    </para>
  <para>
Bu işlevleri etkin olarak çalıştırmanın yolu bir dizgenin içindeki karakterleri yerelin karakter sıralamasına uygun bir konumlamayla bir bayt sıralamasına dönüştürmektir. Böyle oluşturulmuş bayt sıralamaları ile yerelin karakter sıralamasına uygun olarak dizgeleri karşılaştırmak artık kolaydır.
    </para>
  <para><command>strcoll</command> ve <command>wcscoll</command> işlevleri bu dönüşümü
karşılaştırma sırasından dolaylı olarak uygularlar. <command>strxfrm</command> ve <command>wcsxfrm</command> işlevleri ise tam aksine doğrudan doğruya karakter sıralaması/alfabetik sıralama eşleştirmesi yaparlar. Bir dizge kümesi üzerinde çok sayıda karşılaştırma yapacaksanız önce <command>strxfrm</command> veya <command>wcsxfrm</command> işlevlerini kullararak dizgeleri bir kerede dönüştürüp ardından <command>strcmp</command> veya <command>wcscmp</command> ile dönüştürülmüş dizgeleri karşılaştırmak daha verimli bir yöntemdir.
    </para>
  <para>
   <indexterm scope="glibc-fn">
    <primary>strcoll</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev" xml:id="glibc-strcoll">
     <funcdef>int <command>strcoll</command></funcdef>
     <paramdef>(const char *<varname>s1</varname>,
 const char *<varname>s2</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para>
Bu işlev, karakter sıralaması için yerelin (<command>LC_COLLATE</command> yereli) karakter sıralamasını kullanması dışında <command>strcmp</command> işlevine benzer.
</para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para xml:id="glibc-wcscoll">
   <indexterm scope="glibc-fn">
    <primary>wcscoll</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>int <command>wcscoll</command></funcdef>
     <paramdef>(const wchar_t *<varname>ws1</varname>,
 const wchar_t *<varname>ws2</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para>
Bu işlev, karakter sıralaması için yerelin (<command>LC_COLLATE</command> yereli) karakter sıralamasını kullanması dışında <command>wcscmp</command> işlevine benzer.
      </para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para>
Aşağıdaki örnekte bir dizge dizisi <command>strcoll</command> ile karşılaştırılarak
sıralanmaktadır. Burada gerçek sıralama algoritması yazılmamıştır; bunun için <command>qsort</command> (<xref linkend="glibc-Array-Sort-Function"/>) kullanılmıştır. Buradaki kodun yaptığı iş dizgeler sıralanırken nasıl karşılaştırılacağını göstermektir. (Bu bölümün devamında <command>strxfrm</command> kullanarak bunun daha verimli olarak nasıl yapılacağından bahsedilecektir.)
   </para>
  <para>
   <screen>
/* Bu, <command>qsort</command> ile kullanılan bir karşılaştırma işlevidir. */

int
elemanlari_karsilastir (char **p1, char **p2)
{
  return strcoll (*p1, *p2);
}

/* Burası giriş noktası---yerelin karakter sıralaması
   kullanılarak dizgeleri sıralayan işlev. */

void
sort_strings (char **dizi, int dizge_sayisi)
{
  /* Dizgeleri karşılaştırarak diziyi sırala. */
  qsort (dizi, dizge_sayisi,
         sizeof (char *), elemanlari_karsilastir);
}
</screen>
  </para>
  <para xml:id="glibc-strxfrm">
   <indexterm scope="glibc-cp">
    <primary>dizgeyi yerelin karakter sıralamasına dönüştürme</primary>
   </indexterm>
   <indexterm scope="glibc-fn">
    <primary>strxfrm</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>size_t <command>strxfrm</command></funcdef>
     <paramdef>(char *restrict       <varname>hedef</varname>,
 const char *restrict <varname>kaynak</varname>,
 size_t               <varname>boyut</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para><command>strxfrm</command> işlevi, harf sıralaması için seçilmiş olan yerele göre saptanan karakter dönüşümünü kullanarak <varname>kaynak</varname> dizgesini dönüştürür ve dönüştürülen <varname>boyut</varname> karakterlik dizgeyi (sonlandırıcı boş karakter dahil) <varname>hedef</varname> dizisine kaydeder.
   </para>
     <para><varname>hedef</varname> ve <varname>kaynak</varname> birbirini eziyorsa işlevin davranışı tanımsızdır. Daha fazla bilgi için <xref linkend="glibc-Copying-and-Concatenation"/> bölümüne bakınız.
   </para>
     <para>
Dönen değer dönüştürülen dizgenin uzunluğudur. Bu değer <varname>boyut</varname> değerinden etkilenmez, ancak <varname>boyut</varname>'tan büyük ya da eşitse, dönüştürülen dizge <varname>hedef</varname> dizisine sığmamış demektir. Bu durumda, diziye sığdığı kadarıyla dizge kaydedilmiştir. Dönüştürülen dizgenin tamamını almak için işlevi daha büyük bir dizi ile tekrar çağırmalısınız.
   </para>
     <para>
Dönüştürülmüş dizge verilen dizgeden daha uzun olabileceği gibi daha kısa da olabilir.
   </para>
     <para><varname>boyut</varname> sıfırsa, <varname>hedef</varname> dizisine herhangi bir değer kaydedilmez.  Bu durumda,  <command>strxfrm</command> işlevi sadece dönüştürülmüş dizgenin uzunluğu ile döner. Bu ayrılacak dizinin boyunun ne olacağını saptamak açısından yararlıdır. <varname>boyut</varname> sıfır olduğunda <varname>hedef</varname>'in önemi yoktur, bir boş dizge bile olabilir.
</para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para xml:id="glibc-wcsxfrm">
   <indexterm scope="glibc-fn">
    <primary>wcsxfrm</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>size_t <command>wcsxfrm</command></funcdef>
     <paramdef>(wchar_t *restrict <varname>hedef-geniş</varname>,
 const wchar_t    *<varname>kaynak-geniş</varname>,
 size_t            <varname>boyut</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para><command>wcsxfrm</command> işlevi, harf sıralaması için seçilmiş olan yerele göre saptanan karakter dönüşümünü kullanarak <varname>kaynak-geniş</varname> dizgesini dönüştürür ve dönüştürülen <varname>boyut</varname> geniş karakterlik dizgeyi (sonlandırıcı boş karakter dahil) <varname>hedef-geniş</varname> dizisine kaydeder.
   </para>
     <para><varname>hedef-geniş</varname> ve <varname>kaynak-geniş</varname> birbirini eziyorsa işlevin davranışı tanımsızdır. Daha fazla bilgi için <xref linkend="glibc-Copying-and-Concatenation"/> bölümüne bakınız.
   </para>
     <para>
Dönen değer dönüştürülen deniş karakterli dizgenin uzunluğudur. Bu değer <varname>boyut</varname> değerinden etkilenmez, ancak <varname>boyut</varname>'tan büyük ya da eşitse, dönüştürülen geniş karakterli dizge <varname>hedef-geniş</varname> dizisine sığmamış demektir. Bu durumda, geniş karakterli dizge, diziye sığdığı kadarıyla kaydedilmiştir. Dönüştürülen geniş karakterli dizgenin tamamını almak için işlevi daha büyük bir dizi ile tekrar çağırmalısınız.
   </para>
     <para>
Dönüştürülmüş geniş karakterli dizge verilen geniş karakterli dizgeden daha uzun olabileceği gibi daha kısa da olabilir.
   </para>
     <para><varname>boyut</varname> sıfırsa, <varname>hedef-geniş</varname> dizisine herhangi bir değer kaydedilmez.  Bu durumda,  <command>wcsxfrm</command> işlevi sadece dönüştürülmüş geniş karakterli dizgenin uzunluğu ile döner. Bu ayrılacak dizinin boyunun ne olacağını saptamak açısından yararlıdır (değeri <command>sizeof (wchar_t)</command> ile çarpmayı unutmayın). <varname>boyut</varname> sıfır olduğunda <varname>hedef-geniş</varname>'in önemi yoktur, bir boş dizge bile olabilir.
    </para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para>
Buradaki örnekte, çok sayıda karşılaştırma yapmayı planladığınızda <command>strxfrm</command> işlevini nasıl kullanacağınız gösterilmiştir. Önceki örnekle aynı şeyi yapsa da daha hızlıdır, çünkü her dizgeye sadece bir kere dönüşüm uygular, diğer dizgelerle kaç defa karşılaştırma yapıldığının önemi yoktur. Çok sayıda dizge olduğunda kazanılan zaman, bellek ayırmak ve serbest bırakmak için harcanan zamandan bile daha büyüktür.
   </para>
  <para>
   <screen>
struct siralayici { char *girdi; char *donusmus; };

/* Bu karşılaştırma işlevi, <command>struct siralayici</command>
   dizisini sıralamak için <command>qsort</command> ile birlikte
   kullanılmıştır. */

int
elemanlari_karsilastir (struct sorter *p1, struct sorter *p2)
{
  return strcmp (p1-&gt;donusmus, p2-&gt;donusmus);
}

/* Burası giriş noktası---yerelin karakter sıralaması
   kullanılarak dizgeleri sıralayan işlev. */

void
dizgeleri_hizli_sirala (char **dizi, int dizge_sayisi)
{
  struct siralayici gecici_dizi[dizge_sayisi];
  int i;

  /* <command>gecici_dizi</command>yi ilklendirelim.
     Her eleman bir girdi dizgesi ve onun dönüştürülmüşünü
     içersin. */
  for (i = 0; i &lt; dizge_sayisi; i++)
    {
      size_t uzunluk = strlen (dizi[i]) * 2;
      char *donusmus;
      size_t donusmus_uzunluk;

      gecici_dizi[i].girdi = dizi[i];

      /* Yeterince büyük bir tamponla önce deneyelim.  */
      donusmus = (char *) xmalloc (uzunluk);

      /* <command>dizi[i]</command>'yi dönüştürelim.  */
      donusmus_uzunluk = strxfrm (donusmus, dizi[i], uzunluk);

      /* Tampon yetersizse yeniden boyutlandırıp tekrar deneyelim.  */
      if (donusmus_uzunluk &lt;= uzunluk)
        {
          /* Gerekli alanı ayıralım. sonlandırıcı boş karakter
             için +1'i unutmayalım.  */
          donusmus = (char *) xrealloc (donusmus,
                                        donusmus_uzunluk + 1);

          /* Dönen değerin önemi yok çünkü dönüşmüş dizgenin
             uzunluğunu biliyoruz.  */
          (void) strxfrm (donusmus, dizi[i],
                          donusmus_uzunluk + 1);
        }

      gecici_dizi[i].donusmus = donusmus;
    }

  /* Dönüştürülmüş dizgeleri karşılaştırarak gecici_dizi diziyi sıralayalım. */
  qsort (gecici_dizi, sizeof (struct siralayici),
         dizge_sayisi, elemanlari_karsilastir);

  /* Elemanları geri, geçici diziye sıralı olarak yerleştirelim. */
  for (i = 0; i &lt; dizge_sayisi; i++)
    dizi[i] = gecici_dizi[i].girdi;

  /* Ayrılan dizgeleri serbest bırakalım. */
  for (i = 0; i &lt; dizge_sayisi; i++)
    free (gecici_dizi[i].donusmus);
}
</screen>
  </para>
  <para>
Bu kodun geniş karakterli sürümünü ilgilendiren parçası şöyle olurdu:
   </para>
  <para>
   <screen>
void
dizgeleri_hizli_sirala (wchar_t **dizi, int dizge_sayisi)
{
  …
      /* <command>dizi[i]</command>'yi dönüştürelim.  */
      donusmus_uzunluk = wcsxfrm (donusmus, dizi[i], uzunluk);

      /* Tampon yetersizse yeniden boyutlandırıp tekrar deneyelim.  */
      if (donusmus_uzunluk &lt;= uzunluk)
        {
          /* Gerekli alanı ayıralım. sonlandırıcı boş karakter
             için +1'i unutmayalım.  */
          donusmus = (wchar_t *) xrealloc (donusmus,
                                              (donusmus_uzunluk + 1)
                                              * sizeof (wchar_t));

          /* Dönen değerin önemi yok çünkü dönüşmüş dizgenin
             uzunluğunu biliyoruz.  */
          (void) wcsxfrm (donusmus, dizi[i],
                          donusmus_uzunluk + 1);
        }
  …
</screen>
  </para>
  <para><command>realloc</command> çağrısındaki ek olarak yapılan <command>sizeof (wchar_t)</command> ile çarpma işlemine dikkat edin.
   </para>
  <para>
   <note>
    <info>
     <title>Uyumluluk Bilgisi</title>
    </info>
    <para>
Dizgelerin yerele özgü harf sıralama işlevleri ISO C90'nın yeni bir özelliğidir. Daha eski C oluşumlarında buna eşdeğer bir özellik yoktur. Geniş karakteri sürümü ise ISO C90'nın 1. düzeltmesinde yer almıştır.</para>
   </note>
  </para>
 </chapter>
 <chapter xml:id="glibc-Search-Functions">
  <info>
   <title>Arama İşlevleri</title>
   <titleabbrev>Belli bir elemanın veya bir alt dizgenin aranması.</titleabbrev>
  </info>
  <para>
Bu kısımda dizgeler ve diziler üzerinde çeşitli aramalar yapan kütüphane işlevleri açıklanmıştır. Bu işlevler <filename>string.h</filename> başlık dosyasında bildirilmiştir.
<indexterm scope="glibc-pg"><primary>string.h</primary></indexterm>
<indexterm scope="glibc-cp"><primary>arama işlevleri</primary><secondary>dizgelerde</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>dizge arama işlevleri</primary></indexterm>
  </para>
  <para xml:id="glibc-memchr">
   <indexterm scope="glibc-fn">
    <primary>memchr</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>void *<command>memchr</command></funcdef>
     <paramdef>(const void *<varname>blok</varname>,
 int         <varname>c</varname>,
 size_t      <varname>boyut</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para>
Bu işlev <varname>blok</varname> adresinden başlayan nesnenin ilk <varname>boyut</varname> baytı içindeki ilk <varname>c</varname> (bir <command>unsigned char</command>'a dönüştürülmüş) baytını bulur. Dönen değer baytın konumunu içeren bir göstericidir. <varname>c</varname> baytı bulunamazsa bir boş gösterici döner.
</para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para xml:id="glibc-wmemchr">
   <indexterm scope="glibc-fn">
    <primary>wmemchr</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>wchar_t *<command>wmemchr</command></funcdef>
     <paramdef>(const wchar_t *<varname>blok</varname>,
 wchar_t        <varname>wc</varname>,
 size_t         <varname>boyut</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para>
Bu işlev <varname>blok</varname> adresinden başlayan nesnenin ilk <varname>boyut</varname> geniş karakteri içindeki ilk <varname>wc</varname> geniş karakterini bulur. Dönen değer geniş karakterin konumunu içeren bir göstericidir. <varname>wc</varname> baytı bulunamazsa bir boş gösterici döner.
</para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para xml:id="glibc-rawmemchr">
   <indexterm scope="glibc-fn">
    <primary>rawmemchr</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>void *<command>rawmemchr</command></funcdef>
     <paramdef>(const void *<varname>blok</varname>,
 int         <varname>c</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para><command>memchr</command> işlevi çoğunlukla, parametrelerle belirtilen bellek bloğunda bir <varname>c</varname> baytının bulunduğu bilinerek kullanılır. Ancak bu, <varname>boyut</varname> parametresinin gerçekte gerekmediği anlamına gelir ve bu işlevle uygulanan testler çalışma anında yapıldığından (blok sonunun aşılıp aşılmadığına bakılması gibi) gerekli değildir.
   </para>
     <para><command>rawmemchr</command> işlevi şaşırtıcı sıklıkla karşılaşılan bu durum için vardır. Arayüzü, <varname>boyut</varname> parametresinin bulunmayışı dışında <command>memchr</command> işlevine benzer. Yazılımcı, <varname>c</varname> karakterinin <varname>blok</varname> içinde mevcut olduğu kabulünde bir hataya düşerse, işlev bloğun sonunu aşacaktır. Bu durum için sonuç belirsizdir. Aksi takdirde bayt konumuna bir gösterici döner.
   </para>
     <para>
Bu işlev özellikle bir dizgenin sonuna bakılmak istendiğinde kullanılır. Tüm dizgeler bir boş karakterle sonlandırılmış olduğundan,
   </para>
     <para>
      <screen>rawmemchr (str, '\0')</screen>
     </para>
     <para>
gibi bir çağrı dizgenin sonunu asla aşmayacaktır.
   </para>
     <para>
Bu işlev bir GNU oluşumudur.
</para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para xml:id="glibc-memrchr">
   <indexterm scope="glibc-fn">
    <primary>memrchr</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>void *<command>memrchr</command></funcdef>
     <paramdef>(const void *<varname>blok</varname>,
 int         <varname>c</varname>,
 size_t      <varname>boyut</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para>
Bu işlev, <varname>blok</varname> ve <varname>boyut</varname> ile belirtilen bloğu sondan başa doğru araması dışında, aramayı baştan sona doğru yapan <command>memrchr</command> gibidir.
</para>
     <para>
Bu işlev bir GNU oluşumudur.
</para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para xml:id="glibc-strchr">
   <indexterm scope="glibc-fn">
    <primary>strchr</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>char *<command>strchr</command></funcdef>
     <paramdef>(const char *<varname>dizge</varname>,
 int         <varname>c</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para><command>strchr</command> işlevi, boş karakter sonlandırmalı <varname>dizge</varname> dizgesi içinde <varname>c</varname> karakterini (<command>char</command> türüne çevirerek) bulursa ilk bulduğu karakter için bir gösterici ile döner, bulamazsa boş gösterici ile döner.
   </para>
     <para>Örnek:</para>
     <para>
      <screen>
strchr ("hello, world", 'l')
    =&gt; "llo, world"
strchr ("hello, world", '?')
    =&gt; NULL
</screen>
     </para>
     <para>
Sonlandırıcı boş karakter dizgenin bir parçası olarak ele alındığından, <varname>c</varname> argümanı olarak boş karakter vererek dizgenin sonuna bir gösterici alabilirsiniz. Böyle durumlarda <command>strchrnul</command> kullanmak daha iyi olur (ama daha az taşınabilirdir).
</para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para xml:id="glibc-wcschr">
   <indexterm scope="glibc-fn">
    <primary>wcschr</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>wchar_t *<command>wcschr</command></funcdef>
     <paramdef>(const wchar_t *<varname>dizge-geniş</varname>,
 int            <varname>wc</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para><command>wcschr</command> işlevi, <varname>dizge-geniş</varname> dizgesi içinde <varname>wc</varname> geniş karakterini bulursa ilk bulduğu karakter için bir gösterici ile döner, bulamazsa boş gösterici ile döner.
   </para>
     <para>
Sonlandırıcı boş karakter dizgenin bir parçası olarak ele alındığından, <varname>wc</varname> argümanı olarak boş karakter vererek dizgenin sonuna bir gösterici alabilirsiniz. Böyle durumlarda <command>wcschrnul</command> kullanmak daha iyi olur (ama daha az taşınabilirdir).
</para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para xml:id="glibc-strchrnul">
   <indexterm scope="glibc-fn">
    <primary>strchrnul</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>char *<command>strchrnul</command></funcdef>
     <paramdef>(const char *<varname>dizge</varname>,
 int         <varname>c</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para><command>strchrnul</command> işlevi, karakteri bulamadığı takdirde dizgeyi sonlandıran boş karaktere bir gösterici döndürmesi dışında <command>strchr</command> ile aynıdır.
   </para>
     <para>
Bu işlev bir GNU oluşumudur.
</para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para xml:id="glibc-wcschrnul">
   <indexterm scope="glibc-fn">
    <primary>wcschrnul</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>wchar_t *<command>wcschrnul</command></funcdef>
     <paramdef>(const wchar_t *<varname>dizge-geniş</varname>,
 wchar_t        <varname>wc</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para><command>wcschrnul</command> işlevi, geniş karakteri bulamadığı takdirde dizgeyi sonlandıran boş karaktere bir gösterici döndürmesi dışında <command>wcschr</command> ile aynıdır.
   </para>
     <para>
Bu işlev bir GNU oluşumudur.
      </para>
     <para><command>strchr</command> işlevinin kullanışlı ama anlamsız bir kullanımı da dizgeyi sonlandıran boş karaktere bir gösterici istenmesi durumudur. Bunu yapmanın kolay bir yolu vardır:
   </para>
     <para>
      <screen>s += strlen (s);</screen>
     </para>
     <para>
Bu oldukça iyi bir çözüm gibi görünürse de toplama işlemi, <command>strlen</command> ile zaten yapılan işlemin tekrarlanmasını sağlar. Daha iyi bir çözüm şöyle olurdu:
   </para>
     <para>
      <screen>s = strchr (s, '\0');</screen>
     </para>
     <para><command>strchr</command> işlevinin ikinci parametresi için bir sınırlama olmadığından burada bir boş karakter belirtilebilir. Şimdi düşüneceksiniz; <command>strchr</command> çıkışta iki kritere baktığından <command>strlen</command> işlevine göre daha çok işlem yapacak. Bu doğru. Ama GNU C kütüphanesinde <command>strchr</command> işlevi özel olarak daha hızlı olması için eniyilenerek gerçekleştirilmiştir.
</para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para xml:id="glibc-strrchr">
   <indexterm scope="glibc-fn">
    <primary>strrchr</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>char *<command>strrchr</command></funcdef>
     <paramdef>(const char *<varname>dizge</varname>,
 int         <varname>c</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para><command>strrchr</command> işlevi, <varname>dizge</varname> dizgesini sondan başa doğru araması dışında <command>strchr</command> işlevine benzer.
   </para>
     <para>Örnek:</para>
     <para>
      <screen>
strrchr ("hello, world", 'l')
    =&gt; "ld"
</screen>
     </para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para xml:id="glibc-wcsrchr">
   <indexterm scope="glibc-fn">
    <primary>wcsrchr</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>wchar_t *<command>wcsrchr</command></funcdef>
     <paramdef>(const wchar_t *<varname>dizge-geniş</varname>,
 wchar_t        <varname>c</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para><command>wcsrchr</command> işlevi, <varname>dizge-geniş</varname> dizgesini sondan başa doğru araması dışında <command>wcschr</command> işlevi gibidir.
</para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para xml:id="glibc-strstr">
   <indexterm scope="glibc-fn">
    <primary>strstr</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>char *<command>strstr</command></funcdef>
     <paramdef>(const char *<varname>dizge</varname>,
 const char *<varname>altdizge</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para>
Bu işlev, <varname>dizge</varname> içinde bir karakter yerine <varname>altdizge</varname> dizgesini araması dışında <command>strchr</command> gibidir. <varname>dizge</varname> dizgesi içinde <varname>altdizge</varname> dizgesinin, bulduğunda ilk karakterine bir gösterici ile döner, bulamazsa boş gösterici ile döner. <varname>altdizge</varname> bir boş dizge olarak verilirse işlev <varname>dizge</varname> ile döner.
   </para>
     <para>Örnek:</para>
     <para>
      <screen>
strstr ("hello, world", "l")
    =&gt; "llo, world"
strstr ("hello, world", "wo")
    =&gt; "world"
</screen>
     </para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para xml:id="glibc-wcsstr">
   <indexterm scope="glibc-fn">
    <primary>wcsstr</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>wchar_t *<command>wcsstr</command></funcdef>
     <paramdef>(const wchar_t *<varname>dizge</varname>,
 const wchar_t *<varname>altdizge</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para>
Bu işlev, <varname>dizge</varname> içinde bir geniş karakter yerine <varname>altdizge</varname> dizgesini araması dışında <command>wcschr</command> gibidir. <varname>dizge</varname> dizgesi içinde <varname>altdizge</varname> dizgesinin, bulduğunda ilk geniş karakterine bir gösterici ile döner, bulamazsa boş gösterici ile döner. <varname>altdizge</varname> bir boş dizge olarak verilirse işlev <varname>dizge</varname> ile döner.
</para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para xml:id="glibc-wcswcs">
   <indexterm scope="glibc-fn">
    <primary>wcswcs</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>wchar_t *<command>wcswcs</command></funcdef>
     <paramdef>(const wchar_t *<varname>dizge</varname>,
 const wchar_t *<varname>altdizge</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para><command>wcswcs</command> işlevi, <command>wcsstr</command> işlevinin eski ve artık kullanılmayan bir benzeridir. İşlevin ismi ilk olarak, ISO C90 1. düzeltmesinden önce X/Open Taşınabilirlik Kılavuzunda kullanılmıştı.
</para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para xml:id="glibc-strcasestr">
   <indexterm scope="glibc-fn">
    <primary>strcasestr</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>char *<command>strcasestr</command></funcdef>
     <paramdef>(const char *<varname>dizge</varname>,
 const char *<varname>altdizge</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para>
Arama yaparken harf büyüklüğünü gözardı etmesi dışında <command>strstr</command> işlevi gibidir. <command>strcasecmp</command> işlevindeki gibi büyük ve küçük harflerin birbirleriyle ilişkileri yerele bağlıdır.
   </para>
     <para>Örnek:</para>
     <para>
      <screen>strcasestr ("hello, world", "L")
    =&gt; "llo, world"
strcasestr ("hello, World", "wo")
    =&gt; "World"
</screen>
     </para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para xml:id="glibc-memmem">
   <indexterm scope="glibc-fn">
    <primary>memmem</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>void *<command>memmem</command></funcdef>
     <paramdef>(const void *<varname>dizge</varname>,
 size_t      <varname>dizge-uzunluğu</varname>,
 const void *<varname>altdizge</varname>,
 size_t      <varname>altdizge-uzunluğu</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para>
Bu işlev <command>strstr</command> işlevi gibidir, ama <varname>altdizge</varname> ve <varname>dizge</varname> birer boş  karakter sonlandırmalı dizge değil birer bayt dizisidir, <varname>dizge-uzunluğu</varname> ve <varname>altdizge-uzunluğu</varname> da
bunların uzunluklarıdır.
   </para>
     <para>
Bu işlev bir GNU oluşumudur.
</para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para xml:id="glibc-strspn">
   <indexterm scope="glibc-fn">
    <primary>strspn</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>size_t <command>strspn</command></funcdef>
     <paramdef>(const char *<varname>dizge</varname>,
 const char *<varname>arananlar</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para><command>strspn</command> ("string span" kısaltması) işlevi, <varname>dizge</varname> içinde <varname>arananlar</varname> dizgesi ile belirtilen karakterlerden birinin bulunması durumunda, bulunan karakterin <varname>arananlar</varname> içinde, bulunduğu ilk altdizgenin uzunluğu ile döner. <varname>arananlar</varname> dizgesindeki karakterlerin sırasının önemi yoktur.
   </para>
     <para>Örnek:</para>
     <para>
      <screen>strspn ("hello, world", "abcdefghijklmnopqrstuvwxyz")
    =&gt; 5
</screen>
     </para>
     <para>
Burada karakter bayt anlamındadır. Çok baytlı karakter kodlaması kullanılan dizgelerde bir karakter birden fazla bayttan oluştuğundan bu işlevde her bayt ayrı ayrı değerlendirilir. Bu işlev yerele bağımlı değildir.
</para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para xml:id="glibc-wcsspn">
   <indexterm scope="glibc-fn">
    <primary>wcsspn</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>size_t <command>wcsspn</command></funcdef>
     <paramdef>(const wchar_t *<varname>dizge-geniş</varname>,
 const wchar_t *<varname>arananlar</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para><command>wcsspn</command> ("wide character string span" kısaltması) işlevi, <varname>dizge-geniş</varname> içinde <varname>arananlar</varname> dizgesi ile belirtilen geniş karakterlerden birinin bulunması durumunda, bulunan geniş karakterin <varname>arananlar</varname> içinde, bulunduğu ilk altdizgenin uzunluğu döner. <varname>arananlar</varname> dizgesindeki geniş karakterlerin sırasının önemi yoktur.
</para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para xml:id="glibc-strcspn">
   <indexterm scope="glibc-fn">
    <primary>strcspn</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>size_t <command>strcspn</command></funcdef>
     <paramdef>(const char *<varname>dizge</varname>,
 const char *<varname>arananlar</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para><command>strcspn</command> ("string complement span" kısaltması) işlevi,
<varname>dizge</varname> içinde <varname>arananlar</varname> dizgesi ile belirtilen karakterlerden birinin bulunması durumunda, <varname>dizge</varname> içinde, bulunan karakteri içermeyen ilk alt dizgenin uzunluğu ile döner.
   </para>
     <para>Örnek:</para>
     <para>
      <screen>
strcspn ("hello, world", " \t\n,.;!?")
    =&gt; 5
</screen>
     </para>
     <para>
Burada karakter bayt anlamındadır. Çok baytlı karakter kodlaması kullanılan dizgelerde bir karakter birden fazla bayttan oluştuğundan bu işlevde her bayt ayrı ayrı değerlendirilir. Bu işlev yerele bağımlı değildir.
</para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para xml:id="glibc-wcscspn">
   <indexterm scope="glibc-fn">
    <primary>wcscspn</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>size_t <command>wcscspn</command></funcdef>
     <paramdef>(const wchar_t *<varname>dizge-geniş</varname>,
 const wchar_t *<varname>arananlar</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para><command>wcscspn</command> ("wide character string complement span" kısaltması) işlevi, <varname>dizge-geniş</varname> içinde <varname>arananlar</varname> dizgesi ile belirtilen geniş karakterlerden birinin bulunması durumunda, <varname>dizge-geniş</varname> içinde, bulunan karakteri içermeyen ilk alt dizgenin uzunluğu ile döner.
</para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para xml:id="glibc-strpbrk">
   <indexterm scope="glibc-fn">
    <primary>strpbrk</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>char *<command>strpbrk</command></funcdef>
     <paramdef>(const char *<varname>dizge</varname>,
 const char *<varname>arananlar</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para><command>strpbrk</command> ("string pointer break" kısaltması) işlevi,
<command>strcspn</command> işlevine benzer, farklı olarak, <varname>dizge</varname> içinde, bulunan karakterle başlayan dizgeye bir gösterici ile döner. <varname>arananlar</varname> içindeki karakterlerden biri bulunamazsa boş gösterici döner.
   </para>
     <para>Örnek:</para>
     <para>
      <screen>
strpbrk ("hello, world", " \t\n,.;!?")
    =&gt; ", world"
</screen>
     </para>
     <para>
Burada karakter bayt anlamındadır. Çok baytlı karakter kodlaması kullanılan dizgelerde bir karakter birden fazla bayttan oluştuğundan bu işlevde her bayt ayrı ayrı değerlendirilir. Bu işlev yerele bağımlı değildir.
</para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para xml:id="glibc-wcspbrk">
   <indexterm scope="glibc-fn">
    <primary>wcspbrk</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>wchar_t *<command>wcspbrk</command></funcdef>
     <paramdef>(const wchar_t *<varname>dizge-geniş</varname>,
 const wchar_t *<varname>arananlar</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para><command>wcspbrk</command> ("wide character string pointer break" kısaltması) işlevi,  <command>wcscspn</command> işlevine benzer, farklı olarak, <varname>dizge-geniş</varname> içinde, bulunan geniş karakterle başlayan dizgeye bir gösterici ile döner. <varname>arananlar</varname> içindeki geniş karakterlerden biri bulunamazsa boş gösterici döner.
    </para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <section xml:id="glibc-Search-Functions-Compatibility">
   <info>
    <title>Uyumluluk için Varolan Dizge Arama İşlevleri</title>
   </info>
   <para xml:id="glibc-index">
    <indexterm scope="glibc-fn">
     <primary>index</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="işlev">
      <funcdef>char *<command>index</command></funcdef>
      <paramdef>(const char *<varname>dizge</varname>,
 int         <varname>c</varname>)</paramdef>
     </funcprototype>
     <funcdescr>
      <para><command>index</command> işlevi <command>strchr</command> işlevinin diğer ismidir; yani ikisi de aynıdır. <command>index</command> işlevi BSD'dan gelir ve System V'den türetilmiş sistemlede hiç kullanılmamıştır. ISO C bu isim yerine <command>strchr</command> ismini içerdiğinden daima yeni ismi kullanmalısınız.
</para>
     </funcdescr>
    </funcsynopsis>
   </para>
   <para xml:id="glibc-rindex">
    <indexterm scope="glibc-fn">
     <primary>rindex</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="işlev">
      <funcdef>char *<command>rindex</command></funcdef>
      <paramdef>(const char *<varname>dizge</varname>,
 int         <varname>c</varname>)</paramdef>
     </funcprototype>
     <funcdescr>
      <para><command>rindex</command> işlevi <command>strrchr</command> işlevinin diğer ismidir; yani ikisi de aynıdır. <command>rindex</command> işlevi BSD'dan gelir ve System V'den türetilmiş sistemlede hiç kullanılmamıştır. ISO C bu isim yerine <command>strrchr</command> ismini içerdiğinden daima yeni ismi kullanmalısınız.
</para>
     </funcdescr>
    </funcsynopsis>
   </para>
  </section>
 </chapter>
 <chapter xml:id="glibc-Finding-Tokens-in-a-String">
  <info>
   <title>Bir Dizgeyi Dizgeciklere Ayırma</title>
   <titleabbrev>Bir dizgeyi içerdiği ayraçlara göre bölme.</titleabbrev>
  </info>
  <para><indexterm scope="glibc-cp"><primary>dizgeler</primary><secondary>dizgeciklere bölme</secondary></indexterm>
Hemen tüm uygulamalarda, bir komut dizgesini dizgeciklere ayırmak gibi bazı basit ayrıştırma işlemlerine ihtiyaç  duyulur. Bunu  <filename>string.h</filename> başlık dosyasında bildirilmiş olan <command>strtok</command> işlevi ile yapabilirsiniz.
<indexterm scope="glibc-pg"><primary>string.h</primary></indexterm>
       </para>
  <para xml:id="glibc-strtok">
   <indexterm scope="glibc-fn">
    <primary>strtok</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>char *<command>strtok</command></funcdef>
     <paramdef>(char *restrict       <varname>yeni-dizge</varname>,
 const char *restrict <varname>ayraçlar</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para>
Bir dizge <command>strtok</command> işlevini peşpeşe çağırarak dizgeciklerine bölünebilir.
   </para>
     <para>
Bölünecek dizge ilk çağrıda <varname>yeni-dizge</varname> argümanı ile işleve aktarılır. <command>strtok</command> işlevi bunu bazı dahili durum bilgilerini ayarlamakta kullanır. Sonraki çağrılarda, <varname>yeni-dizge</varname> argümanında bir boş gösterici aktarılması aynı dizgeden başka dizgeciklerin alınacağını belirtir. <varname>yeni-dizge</varname> argümanında boş gösterici olmayan bir gösterici belirterek yapılan her <command>strtok</command> çağrısı durum bilgilerini yeniden ilklendirir. Hiçbir kütüphane işlevinin sizin haberiniz olmadan (bu dahili durum bilgisini karıştıran) <command>strtok</command> çağrısı yapmayacağı garanti edilmiştir.
   </para>
     <para><varname>ayraçlar</varname> argümanı çıkarılacak dizgecikleri belirlemede kullanılan ayraçlardan oluşan bir dizgedir. Bu ayraçlardan birine rastlandığında bu karakter bir boş karakterle değiştirilir ve dizgenin başlangıcı <varname>yeni-dizge</varname> argümanında döndürülür. Dizgecikler daima dizgeciğin sonunda bir ayracın varlığına göre ayrılır.
   </para>
     <para>
Sonraki <command>strtok</command> çağrılarında arama önceki dizgeciği sonlandıran boş karakterden sonraki karakterden başlar. Sonraki <command>strtok</command> çağrılarında hep aynı <varname>ayraçlar</varname> dizgesini kullanmak zorunluluğu yoktur.
   </para>
     <para><varname>yeni-dizge</varname> dizgesinin sonuna gelindiğinde ya da kalan dizge sadece ayraç karakterlerinden oluşuyorsa işlev boş gösterici ile döner.
   </para>
     <para>
Burada karakter bayt anlamındadır. Çok baytlı karakter kodlaması kullanılan dizgelerde bir karakter birden fazla bayttan oluştuğundan bu işlevde her bayt ayrı ayrı değerlendirilir. Bu işlev yerele bağımlı değildir.
</para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para xml:id="glibc-wcstok">
   <indexterm scope="glibc-fn">
    <primary>wcstok</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>wchar_t *<command>wcstok</command></funcdef>
     <paramdef>(wchar_t    *<varname>yeni-dizge</varname>,
 const char *<varname>ayraçlar</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para>
Bir dizge <command>wcstok</command> işlevini peşpeşe çağırarak dizgeciklerine bölünebilir.
   </para>
     <para>
Bölünecek dizge ilk çağrıda <varname>yeni-dizge</varname> argümanı ile işleve aktarılır. <command>wcstok</command> işlevi bunu bazı dahili durum bilgilerini ayarlamakta kullanır. Sonraki çağrılarda, <varname>yeni-dizge</varname> argümanında bir boş gösterici aktarılması aynı dizgeden başka dizgeciklerin alınacağını belirtir. <varname>yeni-dizge</varname> argümanında boş gösterici olmayan bir gösterici belirterek yapılan her <command>wcstok</command> çağrısı durum bilgilerini yeniden ilklendirir. Hiçbir kütüphane işlevinin sizin haberiniz olmadan (bu dahili durum bilgisini karıştıran) <command>wcstok</command> çağrısı yapmayacağı garanti edilmiştir.
   </para>
     <para><varname>ayraçlar</varname> argümanı çıkarılacak geniş karakterli dizgecikleri belirlemede kullanılan ayraçlardan oluşan bir geniş karakterli dizgedir. Bu ayraçlardan birine rastlandığında bu geniş karakter bir boş karakterle değiştirilir ve dizgenin başlangıcı <varname>yeni-dizge</varname> argümanında döndürülür. Dizgecikler daima dizgeciğin sonunda bir ayracın varlığına göre ayrılır.
   </para>
     <para>
Sonraki <command>wcstok</command> çağrılarında arama önceki dizgeciği sonlandıran boş karakterden sonraki geniş karakterden başlar. Sonraki <command>wcstok</command> çağrılarında hep aynı <varname>ayraçlar</varname> dizgesini kullanmak zorunluluğu yoktur.
   </para>
     <para><varname>yeni-dizge</varname> geniş karakterli dizgesinin sonuna gelindiğinde ya da kalan geniş karakterli dizge sadece ayraç karakterlerinden oluşuyorsa işlev boş gösterici ile döner.
</para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para>
   <warning>
    <para><command>strtok</command> ve <command>wcstok</command> işlevleri ayrıştırma sırasında dizgeyi değiştirdiğinden,  <command>strtok</command>/<command>wcstok</command> çağrısından önce dizgeyi daima geçici bir tampona kaydetmelisiniz (Bkz. <xref linkend="glibc-Copying-and-Concatenation"/>). <command>strtok</command> veya <command>wcstok</command> işlevinin yazılımınızın başka bir parçasından gelen bir dizgeyi değiştirmesine izin verirseniz, <command>strtok</command> veya <command>wcstok</command> çağrısından sonra dizge değişmiş olacağından dizgenin başka amaçlar için kullanılması gerektiğinde umduğunuz değerde olmayacağından sorunlarla karşılaşabilirsiniz.</para>
   </warning>
  </para>
  <para>
İşleme soktuğunuz dizge bir sabit olduğu takdirde, <command>strtok</command> veya <command>wcstok</command> işlevi onu değiştirmeye kalktığında yazılımınız salt-okunur belleğe yazacağından bir ölümcül hata alacaktır Bkz. <xref linkend="glibc-Program-Error-Signals"/>. <command>strtok</command> veya <command>wcstok</command> işlevinin yaptığı işlemin dizgeyi değiştirmeyeceğini (mesela sadece bir dizgecik vardır) düşünseniz bile dizge değiştirilebilir (GNU libc değiştirecektir).
   </para>
  <para>
Bu, bir genel prensibin özel durumudur: Eğer bir yazılım parçası belli bir veri yapısını güncelleme ile görevlendirilmemişse sözkonusu veri yapısının bu yazılım tarafından geçici olarak güncellenmesi hatalara yol açabilir.
   </para>
  <para><command>strtok</command> ve <command>wcstok</command> işlevleri evresel değildir. Evreselliğin nerede ve niçin önemli olduğu <xref linkend="glibc-Nonreentrancy"/> bölümünde açıklanmıştır.
   </para>
  <para><command>strtok</command> işlevinin kullanımına bir örnek:
   </para>
  <para>
   <screen>#include &lt;string.h&gt;
#include &lt;stddef.h&gt;

…

const char
  dizge[] = "noktalama isaretleri -- ve bosluklarla ayrilmis kelimeler!";
const char ayraclar[] = " .,;:!-";
char *dizgecik, *kopya;

…

kopya = strdupa (dizge);             /* Yazılabilir kopya.  */
dizgecik = strtok (kopya, ayraclar); /* dizgecik =&gt; "noktalama" */
dizgecik = strtok (NULL, ayraclar);  /* dizgecik =&gt; "isaretleri" */
dizgecik = strtok (NULL, ayraclar);  /* dizgecik =&gt; "ve" */
dizgecik = strtok (NULL, ayraclar);  /* dizgecik =&gt; "bosluklarla" */
dizgecik = strtok (NULL, ayraclar);  /* dizgecik =&gt; "ayrilmis" */
dizgecik = strtok (NULL, ayraclar);  /* dizgecik =&gt; "kelimeler" */
dizgecik = strtok (NULL, ayraclar);  /* dizgecik =&gt; NULL */
</screen>
  </para>
  <para>
GNU C kütüphanesi bir dizgeyi dizgeciklerine bölmek için, tek katılışlı olmanın sınırlamalarını aşan iki işlev daha içerir. Bu işlevler sadece çok karakterli karakter dizgeleri için kullanılabilir.
      </para>
  <para xml:id="glibc-strtok_r">
   <indexterm scope="glibc-fn">
    <primary>strtok_r</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>char *<command>strtok_r</command></funcdef>
     <paramdef>(char       *<varname>yeni-dizge</varname>,
 const char *<varname>ayraçlar</varname>,
 char      **<varname>sonraki</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para>
Bu işlev, <command>strtok</command> gibi, ardışık olarak çağrılarak bir dizgeyi dizgeciklerine ayırmakta kullanılır. Farkı, sonraki dizgecik hakkındaki bilgilerin, bir dizge göstericisine gösterici olan <varname>sonraki</varname> argümanı ile gösterilen alanda saklanmasıdır. İşlevin, <varname>yeni-dizge</varname> argümanının boş gösterici ile ve çağrılar arasında <varname>sonraki</varname> argümanının değişmeden bırakılarak çağrılması, çok katılışlılığı engellemeksizin işlemin yapılmasını sağlar.
   </para>
     <para>
Bu işlev POSIX.1 içinde tanımlıdır ve çok evreliliği destekleyen çoğu sistemde bulunur.
</para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para xml:id="glibc-strsep">
   <indexterm scope="glibc-fn">
    <primary>strsep</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>char *<command>strsep</command></funcdef>
     <paramdef>(char      **<varname>sonraki</varname>,
 const char *<varname>ayraç</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para>
Bu işlev, <command>strtok_r</command> işlevinden <varname>yeni-dizge</varname> argümanının yerini <varname>sonraki</varname> argümanını alması dışında <command>strtok_r</command> işlevine benzer. Taşıyıcı göstericinin ilklendirilmesi yazılımcı tarafından yapılır. Ardışık çağrılarla <varname>ayraç</varname> ile ayrılan dizgeciğin adresi ile dönerken, sonraki dizgeciğin başlangıcını gösteren <varname>sonraki</varname> argümanını günceller.
   </para>
     <para><command>strsep</command> ile <command>strtok_r</command> arasındaki bir diğer fark da, eğer girdi dizgesi içinde <varname>ayraç</varname> karakterlerinden biri birden fazla içeriliyorsa, her <varname>ayraç</varname> karakteri çifti için bir boş dizge döndürmesidir. Bu demektir ki, bir yazılım normalde işlevi çalıştırmadan önce bir boş dizge döndürüp döndürmediğini sınamalıdır.
   </para>
     <para>
Bu işlev 4.3 BSD içinde tanımlıdır ve genişçe bir kullanım alanı vardır.
</para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para>
Yukarıdaki örneği <command>strsep</command> için uyarlarsak:
   </para>
  <para>
   <screen>#include &lt;string.h&gt;
#include &lt;stddef.h&gt;

…

const char
  dizge[] = "noktalama isaretleri -- ve bosluklarla ayrilmis kelimeler!";
const char ayraclar[] = " .,;:!-";
char *dizgecik, *kopya;

…

kopya = strdupa (dizge);
dizgecik = strsep (&amp;kopya, ayraclar);    /* dizgecik =&gt; "noktalama" */
dizgecik = strsep (&amp;kopya, ayraclar);    /* dizgecik =&gt; "isaretleri" */
dizgecik = strsep (&amp;kopya, ayraclar);    /* dizgecik =&gt; "" */
dizgecik = strsep (&amp;kopya, ayraclar);    /* dizgecik =&gt; "" */
dizgecik = strsep (&amp;kopya, ayraclar);    /* dizgecik =&gt; "" */
dizgecik = strsep (&amp;kopya, ayraclar);    /* dizgecik =&gt; "isaretleri" */
dizgecik = strsep (&amp;kopya, ayraclar);    /* dizgecik =&gt; "ve" */
dizgecik = strsep (&amp;kopya, ayraclar);    /* dizgecik =&gt; "bosluklarla" */
dizgecik = strsep (&amp;kopya, ayraclar);    /* dizgecik =&gt; "ayrilmis" */
dizgecik = strsep (&amp;kopya, ayraclar);    /* dizgecik =&gt; "kelimeler" */
dizgecik = strsep (&amp;kopya, ayraclar);    /* dizgecik =&gt; "" */
dizgecik = strsep (&amp;kopya, ayraclar);    /* dizgecik =&gt; NULL */
</screen>
  </para>
  <para xml:id="glibc-basename">
   <indexterm scope="glibc-fn">
    <primary>basename</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>char *<command>basename</command></funcdef>
     <paramdef>(const char *<varname>dosyaismi</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para><command>basename</command> işlevinin GNU sürümü, <varname>dosyaismi</varname> ile belirtilen dosya yolunun son elemanı ile döner. <varname>dosyaismi</varname> argümanını içerdiği bölü çizgileri bakımından değiştirmediğinden kullanımı tercih edilir. İşlevi prototipi <filename>string.h</filename> dosyasında bulunabilir. Eğer <filename>libgen.h</filename> dosyası da içerilmişse bu işlevin XPG sürümü ile değiştirileceğini aklınızdan çıkarmayın.
   </para>
     <para>
GNU <command>basename</command> işlevinin kullanım örneği:
   </para>
     <para>
      <screen>#include &lt;string.h&gt;

int
main (int argc, char *argv[])
{
  char *prog = basename (argv[0]);

  if (argc &lt; 2)
    {
      fprintf (stderr, "Kullanimi: %s &lt;arg&gt;\n", prog);
      exit (1);
    }

  …
}
</screen>
     </para>
     <para>
      <note>
       <info>
        <title>Taşınabilirlik Bilgisi</title>
       </info>
       <para>Bu işlev, farklı sistemlerde farklı sonuçlar üretebilir.</para>
      </note>
     </para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para xml:id="glibc-xpg-basename">
   <indexterm scope="glibc-fn">
    <primary>basename</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>char *<command>basename</command></funcdef>
     <paramdef>(char *<varname>dosyayolu</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para><command>basename</command> işlevinin XPG sürümüdür ve ruhen GNU sürümüne benzer. Fakat, <varname>dosyayolu</varname>  içindeki '/' karakterleri silinerek değişikliğe uğratılır. Eğer argüman sadece '/' karakterinden oluşuyorsa '/' karakteri döner. Ayrıca, <command>NULL</command> ise ya da bir boş dizge ise "." döner. İşlevin prototipi <filename>libgen.h</filename> dosyasında bulunabilir.
   </para>
     <para>
XPG <command>basename</command> kullanım örneği:
   </para>
     <para>
      <screen>#include &lt;libgen.h&gt;

int
main (int argc, char *argv[])
{
  char *prog;
  char *path = strdupa (argv[0]);

  prog = basename (path);

  if (argc &lt; 2)
    {
      fprintf (stderr, "Kullanimi: %s &lt;arg&gt;\n", prog);
      exit (1);
    }

  …

}
</screen>
     </para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para xml:id="glibc-dirname">
   <indexterm scope="glibc-fn">
    <primary>dirname</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>char *<command>dirname</command></funcdef>
     <paramdef>(char *<varname>dosyayolu</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para><command>dirname</command> işlevi, <command>basename</command> işlevinin XPG sürümünün tümleyenidir. <varname>dosyayolu</varname> ile belrtilen dosyayı içeren dizin ile döner. Argümanın değeri <command>NULL</command> ise veya bir boş dizge ise ya da hiç '/' karakteri içermiyorsa, "." döner. İşlevin prototipi <filename>libgen.h</filename> dosyasında bulunabilir.
</para>
    </funcdescr>
   </funcsynopsis>
  </para>
 </chapter>
 <chapter xml:id="glibc-strfry">
  <info>
   <title>strfry</title>
   <titleabbrev>Dizge kızartması nasıl yapılır.</titleabbrev>
  </info>
  <para>
Aşağıdaki işlev yazılım geliştirmenin uzun süredir devam eden bir ikilemine karşılıktır: "Veriyi doğru olarak dizge biçiminde nasıl alırım ve daha sonra onu nasıl kolayca bozabilirim?" Bu, GNU C kütüphanesini kullanmayan yazılımcılar için oldukça basittir. GNU C kütüphanesini kullanan yazılımlarda dizge verisinin yok edilmesi için tercih edilen yöntem <command>strfry</command> işlevinin kullanılmasıdır.
   </para>
  <para>
İşlevin prototip <filename>string.h</filename> başlık dosyasındadır.
   </para>
  <para>
   <indexterm scope="glibc-fn">
    <primary>strfry</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>char *<command>strfry</command></funcdef>
     <paramdef>(char *<varname>dizge</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para><command>strfry</command> işlevi bir dizgeyi rasgele evirmece ile dönüştürür. İşlev dizgenin içeriğini kendi içinde rasgele konumlar arasında takaslar. Bunu yaparken bu iki konum aynı olabilir.
   </para>
     <para>
İşlev daima <varname>dizge</varname> ile döner.
   </para>
     <para>
      <note>
       <info>
        <title>Taşınabilirlik Bilgisi</title>
       </info>
       <para>İşlev GNU C kütüphanesine özeldir.</para>
      </note>
     </para>
    </funcdescr>
   </funcsynopsis>
  </para>
 </chapter>
 <chapter xml:id="glibc-Trivial-Encryption">
  <info>
   <title>Bayağı Şifreleme</title>
   <titleabbrev>Verinin karartılması.</titleabbrev>
  </info>
  <para><indexterm scope="glibc-cp"><primary>şifreleme</primary></indexterm><command>memfrob</command> işlevi bir veri dizisini tanınmayacak hale getirmek daha sonra tekrar eski haline getirmek için kullanılır. Şifrelenmiş veri herkes tarafından kolayca normal veriye dönüştürülebildiğinden tam bir şifreleme sayılmaz. Dönüşüm, eşek şakasından hoşlananlara karşı kullanılan Usenet'in "Rot13" şifreleme yöntemine eşdeğerdir. Rot13'ün aksine <command>memfrob</command> işlevi sadece metin üzerinde değil ikilik verilerle de çalışır.
<indexterm scope="glibc-cp"><primary>Rot13</primary></indexterm>
Gerçek şifrelemeyle iligileniyorsanız, <xref linkend="glibc-Cryptographic-Functions"/> bölümüne bakınız.
İşlev <filename>string.h</filename> başlık dosyasında bildirilmiştir.
<indexterm scope="glibc-pg"><primary>string.h</primary></indexterm>
   </para>
  <para xml:id="glibc-memfrob">
   <indexterm scope="glibc-fn">
    <primary>memfrob</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>void *<command>memfrob</command></funcdef>
     <paramdef>(void  *<varname>bellek</varname>,
 size_t <varname>uzunluk</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para><command>memfrob</command> işlevi, <varname>uzunluk</varname> baytlık <varname>bellek</varname> veri yapısını her baytla oynayarak dönüştürür (her bayta ikilik 00101010 ile bit bit ayrıcalıklı VEYA uygulanarak). İşlev, dönüşüm için ayrı bir bellek alanı kullanmaz ve daima <varname>bellek</varname> ile döner.
   </para>
     <para><command>memfrob</command> işlevini aynı veri ile tekrar çağırdığınızda veriyi eski özgün haliyle alırsınız.
   </para>
     <para>
Verinin bazıları tarafından görülmesi istenmiyorsa ya da veriye erişimin zorlaşması isteniyorsa, bu işlev bilgiyi gizlemek için yararlıdır. Bilginin başkaları tarafından görülmesi gerçekten istenmiyorsa, <xref linkend="glibc-Cryptographic-Functions"/> bölümüne bakınız.
   </para>
     <para>
      <note>
       <info>
        <title>Taşınabilirlik Bilgisi</title>
       </info>
       <para>İşlev GNU C kütüphanesine özeldir.</para>
      </note>
     </para>
    </funcdescr>
   </funcsynopsis>
  </para>
 </chapter>
 <chapter xml:id="glibc-Encode-Binary-Data">
  <info>
   <title>İkilik Verinin Kodlanması</title>
   <titleabbrev>İkilik verinin kodlanması ve çözülmesi.</titleabbrev>
  </info>
  <para>
Sadece metin türü verilerin saklanabildiği ya da aktarılabildiği ortamlarda saklama ya da aktarma öncesi ikilik verinin baytlarının karakterlere dönüştürülmesi gerekir. SVID sistemleri (ve günümüzde XPG uyumlu sistemler) bu işlem için çok az destek sağlar.
   </para>
  <para xml:id="glibc-l64a">
   <indexterm scope="glibc-fn">
    <primary>l64a</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>char *<command>l64a</command></funcdef>
     <paramdef>(long int <varname>n</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para>
Bu işlev, temel karakter kümesindeki karakterleri kullanarak  32 bitlik girdiyi kodlar. İşlev <varname>n</varname> sayısının kodlanmış halini içeren 7 karakterlik bir tampona gösterici ile döner. Yazılımcı bir sayı dizisini kodlamak istiyorsa, ikinci bir tampona dönen veriyi kopyalamalıdır. <varname>n</varname> sıfırsa boş dizge döner, biraz tuhaf ama standart böyle.
  </para>
     <para>
      <warning>
       <para>Tamponu durağan olduğundan işlev çok evreli yazılımlarda kullanılmamalıdır. Bu işlevin evreli yazılımlarca kullanılabilecek bir eşdeğeri C kütüphanesinde yoktur.</para>
      </warning>
      <note>
       <info>
        <title>Uyumluluk Bilgisi</title>
       </info>
       <para>XPG standardında negatif <varname>n</varname> değerleri için <command>l64a</command> işlevinin dönüş değeri anlamlı değildir. GNU gerçeklemesinde, işlev argümanını işaretsiz olarak ele alır, böylece sıfırdan farklı <varname>n</varname> değerleri negatif olsalar bile anlamlı bir değer döner. Taşınabilir yazılımlar geliştiriyorsanız bu durumu dikkate almalısınız.</para>
      </note>
     </para>
     <para>
Büyük bir tamponu kodlamak isterseniz, her seferinde 32 bitlik bir tamponu dönüştürecek şekilde bir döngü kullanmalısınız. Örnek:
   </para>
     <para>
      <screen>char *
encode (const void *buf, size_t len)
{
  /* Ne kadar uzunlukta bir tampon gerektiğini biliyoruz */
  unsigned char *in = (unsigned char *) buf;
  char *out = malloc (6 + ((len + 3) / 4) * 6 + 1);
  char *cp = out, *p;

  /* Uzunluğu kodlayalım. */
  /* `htonl' kullanarak farklı bayt sıralaması kullanan makinelerde
      bile doğru çözümleme yapılmasını garanti edelim.
      `l64a' b bayttan daha kısa bir dizge döndürebilir,
      bu durumda genişliği tamamlamak için boşluğu 0
      karakterleriyle dolduralım.  */

  p = stpcpy (cp, l64a (htonl (len)));
  cp = mempcpy (p, "......", 6 - (p - cp));

  while (len &gt; 3)
    {
      unsigned long int n = *in++;
      n = (n &lt;&lt; 8) | *in++;
      n = (n &lt;&lt; 8) | *in++;
      n = (n &lt;&lt; 8) | *in++;
      len -= 4;
      p = stpcpy (cp, l64a (htonl (n)));
      cp = mempcpy (p, "......", 6 - (p - cp));
    }
  if (len &gt; 0)
    {
      unsigned long int n = *in++;
      if (--len &gt; 0)
        {
          n = (n &lt;&lt; 8) | *in++;
          if (--len &gt; 0)
            n = (n &lt;&lt; 8) | *in;
        }
      cp = stpcpy (cp, l64a (htonl (n)));
    }
  *cp = '\0';
  return out;
}
</screen>
     </para>
     <para>
Kütüphanenin gereken tam işlevselliği sağlamaması garip ama elden ne gelir.
</para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para><command>l64a</command> ile kodlanmış veri aşağıdaki işlev kullanılarak eski haline getirilebilir.
   </para>
  <para xml:id="glibc-a64l">
   <indexterm scope="glibc-fn">
    <primary>a64l</primary>
   </indexterm>
   <funcsynopsis>
    <funcprototype role="işlev">
     <funcdef>long int <command>a64l</command></funcdef>
     <paramdef>(const char *<varname>dizge</varname>)</paramdef>
    </funcprototype>
    <funcdescr>
     <para><varname>dizge</varname> parametresi, <command>l64a</command> çağrısı ile elde edilmiş en az 6 karakterlik bir dizge olmalıdır. İşlev karakterleri aşağıdaki tabloya göre çözümler. Tabloda bulunmayan bir karaktere rastlanırsa işlev, <command>atoi</command> işlevinin tersine çözümlemeyi durdurur. Satırlara ayrılmış bir tampon kullanıyorsanız, satırsonu karakterlerine dikkat etmelisiniz.
   </para>
     <para>
Kodu çözülen sayı bir <command>long int</command> değer olarak döndürülür.
</para>
    </funcdescr>
   </funcsynopsis>
  </para>
  <para><command>l64a</command> ve <command>a64l</command> işlevleri base 64 kodlaması kullanır. Yani bir kodlanmış dizgenin her karakteri bir girdi sözcüğünün (16 bitlik alan) altı biti ile ifade edilir. Base 64 sayılar için kullanılan semboller:
  </para>
  <para>
   <informaltable frame="none" style="background:#999999;">
    <tgroup cols="9">
     <colspec colwidth="7*"/>
     <colspec colwidth="5*"/>
     <colspec colwidth="5*"/>
     <colspec colwidth="5*"/>
     <colspec colwidth="5*"/>
     <colspec colwidth="5*"/>
     <colspec colwidth="5*"/>
     <colspec colwidth="5*"/>
     <colspec colwidth="5*"/>
     <tbody>
      <row style="background:#ffffee;">
       <entry/>
       <entry>0</entry>
       <entry>1</entry>
       <entry>2 </entry>
       <entry>3 </entry>
       <entry>4 </entry>
       <entry>5</entry>
       <entry>6</entry>
       <entry>7
</entry>
      </row>
      <row style="background:#ffffee;">
       <entry>0</entry>
       <entry>
        <command>.</command>
       </entry>
       <entry>
        <command>/</command>
       </entry>
       <entry>
        <command>0</command>
       </entry>
       <entry>
        <command>1</command>
       </entry>
       <entry>
        <command>2</command>
       </entry>
       <entry>
        <command>3</command>
       </entry>
       <entry>
        <command>4</command>
       </entry>
       <entry>
        <command>5</command>
       </entry>
      </row>
      <row style="background:#ffffee;">
       <entry>8</entry>
       <entry>
        <command>6</command>
       </entry>
       <entry>
        <command>7</command>
       </entry>
       <entry>
        <command>8</command>
       </entry>
       <entry>
        <command>9</command>
       </entry>
       <entry>
        <command>A</command>
       </entry>
       <entry>
        <command>B</command>
       </entry>
       <entry>
        <command>C</command>
       </entry>
       <entry>
        <command>D</command>
       </entry>
      </row>
      <row style="background:#ffffee;">
       <entry>16</entry>
       <entry>
        <command>E</command>
       </entry>
       <entry>
        <command>F</command>
       </entry>
       <entry>
        <command>G</command>
       </entry>
       <entry>
        <command>H</command>
       </entry>
       <entry>
        <command>I</command>
       </entry>
       <entry>
        <command>J</command>
       </entry>
       <entry>
        <command>K</command>
       </entry>
       <entry>
        <command>L</command>
       </entry>
      </row>
      <row style="background:#ffffee;">
       <entry>24</entry>
       <entry>
        <command>M</command>
       </entry>
       <entry>
        <command>N</command>
       </entry>
       <entry>
        <command>O</command>
       </entry>
       <entry>
        <command>P</command>
       </entry>
       <entry>
        <command>Q</command>
       </entry>
       <entry>
        <command>R</command>
       </entry>
       <entry>
        <command>S</command>
       </entry>
       <entry>
        <command>T</command>
       </entry>
      </row>
      <row style="background:#ffffee;">
       <entry>32</entry>
       <entry>
        <command>U</command>
       </entry>
       <entry>
        <command>V</command>
       </entry>
       <entry>
        <command>W</command>
       </entry>
       <entry>
        <command>X</command>
       </entry>
       <entry>
        <command>Y</command>
       </entry>
       <entry>
        <command>Z</command>
       </entry>
       <entry>
        <command>a</command>
       </entry>
       <entry>
        <command>b</command>
       </entry>
      </row>
      <row style="background:#ffffee;">
       <entry>40</entry>
       <entry>
        <command>c</command>
       </entry>
       <entry>
        <command>d</command>
       </entry>
       <entry>
        <command>e</command>
       </entry>
       <entry>
        <command>f</command>
       </entry>
       <entry>
        <command>g</command>
       </entry>
       <entry>
        <command>h</command>
       </entry>
       <entry>
        <command>i</command>
       </entry>
       <entry>
        <command>j</command>
       </entry>
      </row>
      <row style="background:#ffffee;">
       <entry>48</entry>
       <entry>
        <command>k</command>
       </entry>
       <entry>
        <command>l</command>
       </entry>
       <entry>
        <command>m</command>
       </entry>
       <entry>
        <command>n</command>
       </entry>
       <entry>
        <command>o</command>
       </entry>
       <entry>
        <command>p</command>
       </entry>
       <entry>
        <command>q</command>
       </entry>
       <entry>
        <command>r</command>
       </entry>
      </row>
      <row style="background:#ffffee;">
       <entry>56</entry>
       <entry>
        <command>s</command>
       </entry>
       <entry>
        <command>t</command>
       </entry>
       <entry>
        <command>u</command>
       </entry>
       <entry>
        <command>v</command>
       </entry>
       <entry>
        <command>w</command>
       </entry>
       <entry>
        <command>x</command>
       </entry>
       <entry>
        <command>y</command>
       </entry>
       <entry>
        <command>z</command>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </informaltable>
  </para>
  <para>
Bı kodlama şeması standart değildir. Daha geniş çapta kullanılan başka kodlama yöntemleri de (UU kodlaması, MIME kodlaması gibi) vardır. Genelde bu kodlamalardan birini kullanmak daha iyidir.
   </para>
 </chapter>
 <chapter xml:id="glibc-Argz-and-Envz-Vectors">
  <info>
   <title>Argz ve Envz Vektörleri</title>
   <titleabbrev>Boş karakter sonlandırmalı karakter dizisi dizileri.</titleabbrev>
  </info>
  <para>
Bir <wordasword>vektör</wordasword> boş gösterici ile sonlandırılmış gösterici dizisidir.
<indexterm scope="glibc-cp"><primary>vektör</primary></indexterm>
   </para>
  <para><indexterm scope="glibc-cp"><primary>argz vektörleri</primary></indexterm><indexterm scope="glibc-cp"><primary>dizge dizileri</primary><secondary>boş karakter ayraçlı</secondary></indexterm><indexterm scope="glibc-cp"><primary>argüman vektörleri</primary></indexterm>
Bir <wordasword>argz vektörleri</wordasword>, her elemanı boş karakter (<command>'\0'</command>) ile ayrılmış kesintisiz bir bellek bloğu içindeki dizgeler dizisidir.
   </para>
  <para><indexterm scope="glibc-cp"><primary>envz vektörleri (ortam dizgeleri dizisi)</primary></indexterm><indexterm scope="glibc-cp"><primary>ortam vektörleri</primary><secondary>boş karakter ayraçlı</secondary></indexterm>
Bir <wordasword>envz vektörü</wordasword> her elemanı bir isim-değer çifti olan ve bu çiftlerin <command>'='</command> karakteri ile ayrıldığı (en azından Unix ortamında) bir argz vektörüdür.
   </para>
  <section xml:id="glibc-Argz-Functions">
   <info>
    <title>Argz İşlevleri</title>
    <titleabbrev>Argz vektörleri üzerindeki işlemler.</titleabbrev>
   </info>
   <para>
Her argz vektörü ilk elemanı gösteren <command>char *</command> türünde bir gösterici ve dizi boyutunu belirten <command>size_t</command> türünde bir gösterici ile temsil edilir. Her ikisi de bir boş argz vektörünü gösteren <command>0</command> ile ilklendirilir. Tüm argz işlevleri ya bir gösterici ile bir boyut argümanı ya da her ikisinin de değişebileceği öngörüldüğü durumlarda her ikisi de bir gösterici olan argümanlar alırlar.
    </para>
   <para>
Argz işlevleri dizge dizilerini ayırmak ya da büyütmek için <command>malloc</command>/<command>realloc</command> işlevlerini kullanır. Böylece bu işlevler tarafından oluşturulan tüm argz vektörleri <command>free</command> işlevi ile serbest bırakılabilir. Buna karşın, bir dizgeyi büyütebilen argz işlevlerinin dizgeyi <command>malloc</command> kullanarak ayırdığı umulur (bu tür argz işlevleri, bellek sıralaması ne olursa olsun, sadece kendi argümanlarını saptar ve onları değiştirmek için aynı alanı kullanır). Bakınız: <xref linkend="glibc-Unconstrained-Allocation"/>.
    </para>
   <para>
Bellek ayırma işlemi de yapan tüm argz işlevleri <command>error_t</command> türünde bir değer ile döner. Başarı durumunda bu değer <command>0</command>’dır. Aksi takdirde, bir ayırma hatası oluşursa <command>ENOMEM</command> ile döner.
    </para>
   <para><indexterm scope="glibc-pg"><primary>argz.h</primary></indexterm>
Bu işlevler standart bir başlık dosyası olan <filename>argz.h</filename> içinde bildirilmiştir.
   </para>
   <para xml:id="glibc-argz_create">
    <indexterm scope="glibc-fn">
     <primary>argz_create</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="işlev">
      <funcdef>error_t <command>argz_create</command></funcdef>
      <paramdef>(char *const <varname>argv</varname>[],
 char      **<varname>argz</varname>,
 size_t     *<varname>argz_boyu</varname>)</paramdef>
     </funcprototype>
     <funcdescr>
      <para><command>argz_create</command> işlevi <varname>argv</varname> Unix tarzı argüman vektörünü (normal C dizgelerine göstericilerden oluşmuş, <command>(char *)0</command> ile sonlandırılmış bir diziye gösterici; bkz, <xref linkend="glibc-Program-Arguments"/>) aynı elemanlarla argz vektörüne dönüştürür ve <varname>argz</varname> ve <varname>argz_boyu</varname> ile döndürür.
</para>
     </funcdescr>
    </funcsynopsis>
   </para>
   <para xml:id="glibc-argz_create_sep">
    <indexterm scope="glibc-fn">
     <primary>argz_create_sep</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="işlev">
      <funcdef>error_t <command>argz_create_sep</command></funcdef>
      <paramdef>(const char *<varname>dizge</varname>,
 int         <varname>ayraç</varname>,
 char      **<varname>argz</varname>,
 size_t     *<varname>argz_boyu</varname>)</paramdef>
     </funcprototype>
     <funcdescr>
      <para><command>argz_create_sep</command> işlevi, boş karakter sonlandırmalı <varname>dizge</varname> dizgesini her <varname>ayraç</varname> karakteri için bir eleman olmak üzere bir argz vektörüne (<varname>argz</varname> ve <varname>argz_boyu</varname> içinde döndürerek) dönüştürür.
</para>
     </funcdescr>
    </funcsynopsis>
   </para>
   <para xml:id="glibc-argz_count">
    <indexterm scope="glibc-fn">
     <primary>argz_count</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="işlev">
      <funcdef>size_t <command>argz_count</command></funcdef>
      <paramdef>(const char *<varname>argz</varname>,
 size_t      <varname>argz_boyu</varname>)</paramdef>
     </funcprototype>
     <funcdescr>
      <para><varname>argz</varname> ve <varname>argz_boyu</varname> ile belirtilen argz vektörünün eleman sayısı ile döner.
</para>
     </funcdescr>
    </funcsynopsis>
   </para>
   <para xml:id="glibc-argz_extract">
    <indexterm scope="glibc-fn">
     <primary>argz_extract</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="işlev">
      <funcdef>void <command>argz_extract</command></funcdef>
      <paramdef>(char  *<varname>argz</varname>,
 size_t <varname>argz_boyu</varname>,
 char **<varname>argv</varname>)</paramdef>
     </funcprototype>
     <funcdescr>
      <para><command>argz_extract</command> işlevi, <varname>argz</varname> ve <varname>argz_boyu</varname> ile belirtilen argz vektörünü, (<varname>argz</varname> içindeki her elemana bir göstericiyi <command>0</command> ile sonladırılmış olarak <varname>argv</varname> içindeki kendi konumuna yerleştirerek) <varname>argv</varname> içinde saklanan Unix tarzı argüman vektörüne dönüştürür. <varname>argv</varname>, <varname>argz</varname> dizisinin tüm elemanları artı sonlandırıcı <command>(char *)0</command> için yeterince yer bulunan önceden ayrılmış bir alanı göstermelidir (<command>(argz_count (<varname>argz</varname>, <varname>argz_boyu</varname>) + 1) * sizeof (char *)</command> bayt yeterlidir). <varname>argv</varname> içindeki dizge göstericileri, <varname>argz</varname> içindeki alanları gösterdiğinden (kopyalama yapılmaz), <varname>argz</varname>'nin <varname>argv</varname> etkinken değişmemesi isteniyorsa ayrıca kopyalanmalıdır. Bu işlev <varname>argz</varname> içindeki elemanların bir <link linkend="glibc-Executing-a-File">exec işlevine</link> aktarılması için kullanışlıdır.
</para>
     </funcdescr>
    </funcsynopsis>
   </para>
   <para xml:id="glibc-argz_stringify">
    <indexterm scope="glibc-fn">
     <primary>argz_stringify</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="işlev">
      <funcdef>void <command>argz_stringify</command></funcdef>
      <paramdef>(char  *<varname>argz</varname>,
 size_t <varname>uzunluk</varname>,
 int    <varname>ayraç</varname>)</paramdef>
     </funcprototype>
     <funcdescr>
      <para><command>argz_stringify</command> işlevi, <varname>argz</varname> içindeki <command>'\0'</command> karakterlerini <varname>ayraç</varname> karakteri ile değiştirerek (dizgeyi sonlandıracak olan sonuncu boş karakter hariç) elemanları birleştirip normal bir dizgeye çevirir. Bu işlev, <varname>argz</varname>'nin okunabilir olarak basılması gibi işlemler için faydalıdır.
</para>
     </funcdescr>
    </funcsynopsis>
   </para>
   <para xml:id="glibc-argz_add">
    <indexterm scope="glibc-fn">
     <primary>argz_add</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="işlev">
      <funcdef>error_t <command>argz_add</command></funcdef>
      <paramdef>(char      **<varname>argz</varname>,
 size_t     *<varname>argz_boyu</varname>,
 const char *<varname>dizge</varname>)</paramdef>
     </funcprototype>
     <funcdescr>
      <para><command>argz_add</command> işlevi, <varname>dizge</varname> dizisini *<varname>argz</varname> argz vektörünün sonuna ekler ve *<varname>argz</varname> ile *<varname>argz_boyu</varname> argümalarını yeni duruma uygun olarak günceller.
</para>
     </funcdescr>
    </funcsynopsis>
   </para>
   <para xml:id="glibc-argz_add_sep">
    <indexterm scope="glibc-fn">
     <primary>argz_add_sep</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="işlev">
      <funcdef>error_t <command>argz_add_sep</command></funcdef>
      <paramdef>(char      **<varname>argz</varname>,
 size_t     *<varname>argz_boyu</varname>,
 const char *<varname>dizge</varname>,
 int         <varname>ayraç</varname>)</paramdef>
     </funcprototype>
     <funcdescr>
      <para><command>argz_add_sep</command> işlevi <command>argz_add</command> işlevine benzer. Farklı olarak, <varname>dizge</varname> dizisini  <varname>ayraç</varname> karakterlerine göre alt dizgelerine ayırarak ekler. Bu işlev, PATH değişkeni gibi bir değişkenin değerini oluşturan tüm elamanların ayrı birer dizge olarak eklenmek istenmesi durumunda yararlıdır (<varname>ayraç</varname> karakteri olarak <command>':'</command> verilerek).
</para>
     </funcdescr>
    </funcsynopsis>
   </para>
   <para xml:id="glibc-argz_append">
    <indexterm scope="glibc-fn">
     <primary>argz_append</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="işlev">
      <funcdef>error_t <command>argz_append</command></funcdef>
      <paramdef>(char      **<varname>argz</varname>,
 size_t     *<varname>argz_boyu</varname>,
 const char *<varname>tampon</varname>,
 size_t      <varname>tampon_boyu</varname>)</paramdef>
     </funcprototype>
     <funcdescr>
      <para><command>argz_append</command> işlevi, <varname>tampon_boyu</varname>’nu *<varname>argz_boyu</varname>’na ve <varname>tampon</varname>  ile başlayan dizgeyi *<varname>argz</varname> vektörüne ekler ve bunları bir arada tutan yeni bir *<varname>argz</varname> alanına yerleştirir (eskisi serbest bırakılır).
</para>
     </funcdescr>
    </funcsynopsis>
   </para>
   <para xml:id="glibc-argz_delete">
    <indexterm scope="glibc-fn">
     <primary>argz_delete</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="işlev">
      <funcdef>void <command>argz_delete</command></funcdef>
      <paramdef>(char  **<varname>argz</varname>,
 size_t *<varname>argz_boyu</varname>,
 char   *<varname>girdi</varname>)</paramdef>
     </funcprototype>
     <funcdescr>
      <para>
Eğer <varname>girdi</varname>, *<varname>argz</varname> vektörünün elemanlarından birinin başlangıcını gösteriyorsa,  <command>argz_delete</command> işlevi bu girdiyi kaldıracak ve *<varname>argz</varname> ile *<varname>argz_boyu</varname>’nu güncelleyerek *<varname>argz</varname> vektörüne yeniden yer ayıracaktır. Eleman silen <varname>argz</varname> işlevleri genelde <varname>argz</varname> argümanları için bellekte yeniden yer ayırdıklarından buradaki <varname>girdi</varname> gibi kaldırılan elemanın göstericisi geçersiz olur.
</para>
     </funcdescr>
    </funcsynopsis>
   </para>
   <para xml:id="glibc-argz_insert">
    <indexterm scope="glibc-fn">
     <primary>argz_insert</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="işlev">
      <funcdef>error_t <command>argz_insert</command></funcdef>
      <paramdef>(char      **<varname>argz</varname>,
 size_t     *<varname>argz_boyu</varname>,
 char       *<varname>önce</varname>,
 const char *<varname>girdi</varname>)</paramdef>
     </funcprototype>
     <funcdescr>
      <para><command>argz_insert</command> işlevi, <varname>girdi</varname> dizgesini *<varname>argz</varname> vektörünün <varname>önce</varname> ile gösterilen elemanının öncesine ekler ve *<varname>argz</varname> ile  *<varname>argz_boyu</varname>’nu güncelleyerek *<varname>argz</varname> için yeniden yer ayırır. Eğer <varname>önce</varname> <command>0</command> ise işlev <command>argz_add</command> işlevinin yaptığı gibi elemanı sona ekler.
İlk eleman *<varname>argz</varname> ile aynı olduğundan <varname>önce</varname> için *<varname>argz</varname> verilirse, <varname>girdi</varname> dizgesi başa eklenir.
</para>
     </funcdescr>
    </funcsynopsis>
   </para>
   <para xml:id="glibc-argz_next">
    <indexterm scope="glibc-fn">
     <primary>argz_next</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="işlev">
      <funcdef>char *<command>argz_next</command></funcdef>
      <paramdef>(char       *<varname>argz</varname>,
 size_t      <varname>argz_boyu</varname>,
 const char *<varname>girdi</varname>)</paramdef>
     </funcprototype>
     <funcdescr>
      <para><command>argz_next</command> işlevi <varname>argz</varname> vektöründeki elemanları yinelemek için uygun bir yol sağlar. <varname>argz</varname> vektöründe <varname>girdi</varname> elemanından sonraki elemana ya bir gösterici ile döner ya da <varname>girdi</varname> elemanını izleyen bir eleman yoksa <command>0</command> ile döner. <varname>girdi</varname> olarak <command>0</command> verilirse, <varname>argz</varname> vektörünün ilk elemanı döner.
    </para>
      <para>
Bu davranış iki yineleme tarzı akla getirir:
    </para>
      <para>
       <screen>
    char *girdi = 0;
    while ((girdi = argz_next (<varname>argz</varname>, <varname>argz_boyu</varname>, girdi)))
      <varname>eylem</varname>;
</screen>
      </para>
      <para>
(çift parantez kullanımı bazı C derleyicileri için gereklidir) ve:
    </para>
      <para>
       <screen>
char *girdi;
for (girdi = <varname>argz</varname>;
     girdi;
     girdi = argz_next (<varname>argz</varname>, <varname>argz_boyu</varname>, girdi))
  <varname>eylem</varname>;
</screen>
      </para>
      <para>
İkincisi <varname>argz</varname> vektörünün boş olması durumunda bir boş bellek bloğuna gösterici değil, <command>0</command> değerinde olması gerekliliğine bağlıdır; bu sabit, buradaki işlevler tarafından oluşturulan argz işlevleri için sağlanmıştır.
</para>
     </funcdescr>
    </funcsynopsis>
   </para>
   <para xml:id="glibc-argz_replace">
    <indexterm scope="glibc-fn">
     <primary>argz_replace</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="işlev">
      <funcdef>error_t <command>argz_replace</command></funcdef>
      <paramdef>(char      **<varname>argz</varname>,
 size_t     *<varname>argz_boyu</varname>,
 const char *<varname>dizge</varname>,
 const char *<varname>ile</varname>,
 unsigned   *<varname>yineleme_sayısı</varname>)</paramdef>
     </funcprototype>
     <funcdescr>
      <para><varname>argz</varname> içindeki <varname>dizge</varname> dizgelerini <varname>ile</varname> dizgesi ile değiştirir ve <varname>argz</varname> için gerekliyse yeniden yer ayırır. <varname>yineleme_sayısı</varname> sıfırdan farklı ise *<varname>yineleme_sayısı</varname> uygulanan yer değiştirmenin sayısı kadar arttırılır.
       </para>
     </funcdescr>
    </funcsynopsis>
   </para>
  </section>
  <section xml:id="glibc-Envz-Functions">
   <info>
    <title>Envz İşlevleri</title>
    <titleabbrev>Ortam vektörlerine uygulanan diğer işlemler.</titleabbrev>
   </info>
   <para>
Envz vektörleri her elemanının üzerindeki ek kısıtlamalar dışında argz vektörleri gibidir; örneğin, gerekirse, üzerlerinde argz işlevleri de kullanılabilir.
    </para>
   <para>
Envz vektörünün her elemanı <command>'='</command> işareti ile ayrılmış bir isim-değer çiftidir; eğer bir eleman içinde birden fazla <command>'='</command> karakteri varsa bu karakterlerden ilkinden sonraki dizge değer olarak kabul edilir ve hepsi <command>'\0'</command>’dan farklı bir karakter olarak ele alınır.
    </para>
   <para>
Eleman bir <command>'='</command> karakteri içermiyorsa, eleman bir "null" girdinin ismi kabul edilir. Bu girdiyi bir boş değerli girdiden ayırmak için:
<command>envz_get</command> işlevi isim bir null girdinin ismi ise <command>0</command> ile döner, aksine girdi bir boş değer içeriyor <command>""</command> döner; <command>envz_entry</command> işlevi bu tür girdileri nasıl olursa olsun bulacaktır. Null girdiler <command>envz_strip</command> işlevi ile kaldırılabilir.
    </para>
   <para>
Argz işlevlerindeki gibi, envz işlevlerinin de bellek ayırabildiğinden <command>error_t</command> türünde dönüş değeri vardır ve ya <command>0</command> ya da <command>ENOMEM</command> ile döner.
    </para>
   <para><indexterm scope="glibc-pg"><primary>envz.h</primary></indexterm>
Bu işlevler standat bir başlık dosyası olan <filename>envz.h</filename> dosyasında bildirilmiştir.
    </para>
   <para xml:id="glibc-envz_entry">
    <indexterm scope="glibc-fn">
     <primary>envz_entry</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="işlev">
      <funcdef>char *<command>envz_entry</command></funcdef>
      <paramdef>(const char *<varname>envz</varname>,
 size_t      <varname>envz_boyu</varname>,
 const char *<varname>isim</varname>)</paramdef>
     </funcprototype>
     <funcdescr>
      <para><command>envz_entry</command> işlevi <varname>envz</varname> içinde <varname>isim</varname> isimli girdiyi bulur ve bu elemana (eleman <varname>isim</varname> ile başlar ve <command>'='</command> karakteri ile devam eder) bir gösterici ile döner. Belirtilen ismi içeren bir eleman yoksa <command>0</command> döner.
</para>
     </funcdescr>
    </funcsynopsis>
   </para>
   <para xml:id="glibc-envz_get">
    <indexterm scope="glibc-fn">
     <primary>envz_get</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="işlev">
      <funcdef>char *<command>envz_get</command></funcdef>
      <paramdef>(const char *<varname>envz</varname>,
 size_t      <varname>envz_boyu</varname>,
 const char *<varname>isim</varname>)</paramdef>
     </funcprototype>
     <funcdescr>
      <para><command>envz_get</command> işlevi <varname>envz</varname> içinde <varname>isim</varname> isimli girdiyi bulur ve bu elemanın değer parçasına (<command>'='</command> karakterinden sonrası) bir gösterici ile döner. Eğer bu ismi içeren bir eleman yoksa ya da eleman sadece isim parçasından oluşuyorsa (null girdi), <command>0</command> döner.
</para>
     </funcdescr>
    </funcsynopsis>
   </para>
   <para xml:id="glibc-envz_add">
    <indexterm scope="glibc-fn">
     <primary>envz_add</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="işlev">
      <funcdef>error_t <command>envz_add</command></funcdef>
      <paramdef>(char      **<varname>envz</varname>,
 size_t     *<varname>envz_boyu</varname>,
 const char *<varname>isim</varname>,
 const char *<varname>değer</varname>)</paramdef>
     </funcprototype>
     <funcdescr>
      <para><command>envz_add</command> işlevi, <varname>isim</varname> isimli ve <varname>değer</varname> değerli bir girdiyi *<varname>envz</varname> vektörüne ekler ve *<varname>envz</varname> ile *<varname>envz_boyu</varname>’nu güncelleyerek *<varname>envz</varname> için tekrar yer ayırır. <varname>envz</varname> içinde aynı isimli bir girdi varsa önce bu girdi kaldırılır. Eğer <varname>değer</varname> <command>0</command> ise, yeni girdi özel null türü girdi (yukarıda bahsedilmişti) olacaktır.
</para>
     </funcdescr>
    </funcsynopsis>
   </para>
   <para xml:id="glibc-envz_merge">
    <indexterm scope="glibc-fn">
     <primary>envz_merge</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="işlev">
      <funcdef>error_t <command>envz_merge</command></funcdef>
      <paramdef>(char      **<varname>envz</varname>,
 size_t     *<varname>envz_boyu</varname>,
 const char *<varname>envz2</varname>,
 size_t      <varname>envz2_boyu</varname>,
 int         <varname>üsteyaz</varname>)</paramdef>
     </funcprototype>
     <funcdescr>
      <para><command>envz_merge</command> işlevi, <varname>envz2</varname> içindeki girdileri <varname>envz</varname> vektörüne ekler ve <command>envz_add</command> işlevindeki gibi *<varname>envz</varname> ve *<varname>envz_boyu</varname>’nu günceller. Eğer <varname>üsteyaz</varname> doğru ise, <varname>envz2</varname> içindeki girdilerden <varname>envz</varname> içinde olanlar varsa <varname>envz2</varname> içindekiler <varname>envz</varname> içindekilerin üstüne yazılır, değilse üste yazılmaz.
    </para>
      <para>
Null girdiler de diğer girdiler gibi ele alınır. Yani, her iki vektörde de aynı isimde iki girdi varsa, <varname>envz</varname> içindeki bir null girdi ise ve <varname>üsteyaz</varname> yanlışsa, <varname>envz2</varname> içindeki girdi <varname>envz</varname> vektörüne eklenmez.
</para>
     </funcdescr>
    </funcsynopsis>
   </para>
   <para xml:id="glibc-envz_strip">
    <indexterm scope="glibc-fn">
     <primary>envz_strip</primary>
    </indexterm>
    <funcsynopsis>
     <funcprototype role="işlev">
      <funcdef>void <command>envz_strip</command></funcdef>
      <paramdef>(char  **<varname>envz</varname>,
 size_t *<varname>envz_boyu</varname>)</paramdef>
     </funcprototype>
     <funcdescr>
      <para><command>envz_strip</command> işlevi <varname>envz</varname> içindeki null girdileri *<varname>envz</varname> ve *<varname>envz_boyu</varname>’nu güncelleyerek kaldırır.
    </para>
     </funcdescr>
    </funcsynopsis>
   </para>
  </section>
 </chapter>
</part>
