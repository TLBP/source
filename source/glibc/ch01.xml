<?xml version="1.0" encoding="UTF-8"?>

<!-- ********************************************************************
     $Id: ch01.xml,v 1.2 2002/12/20 22:29:48 nilgun Exp $
******************************************************************** -->
<part xml:id="glibc-Introduction">
  <title>Giriş</title>
  <titleabbrev>GNU C Kütüphanesinin özellikleri</titleabbrev>
  <partintro>
    <para>
<indexterm scope="glibc-cp"><primary>kütüphane</primary></indexterm>
<dicterm><english>library</english><turkish>kütüphane</turkish></dicterm>
C dili, girdi/çıktı işlemleri, bellek yönetimi, metin düzenleme ve benzeri işlemlerin uygulanabilmesi için hiçbir yerleşik çözüm sağlamaz. Bu çözümler yazılımlarınızla ilintileyip derleyebileceğiniz bir standart <wordasword>kütüphane</wordasword> içinde tanımlanır. Bu belgenin konusu olan GNU C kütüphanesi, ISO C standardında belirtilmiş olan tüm kütüphane işlevlerine ek olarak Unix işletim sisteminin diğer türevleri ile POSIX'e özgü olan kütüphane işlevlerini ve GNU sistemine özel oluşumları tanımlar.
    </para><para>
Bu kılavuz, GNU C kütüphanesinin özelliklerini nasıl kullanacağınızı size anlatmayı amaçlar. Diğer sistemlere taşınamayacak şeylerin neler olduğuna, hangi özelliklerin hangi standartlara uyduğuna ayrıca yeri geldikçe değinilmiştir. Ancak bu kılavuzdaki bilgiler tam bir taşınabilirlik sağlamak amacında değildir.
    </para>
  </partintro>
  <chapter xml:id="glibc-Getting-Started">
    <title>Başlarken</title>
    <titleabbrev>Bu kılavuz ne içindir ve nasıl kullanılır.</titleabbrev>
    <para/><para>
Bu kılavuz, sizin en azından, biraz da olsa C yazılım geliştirme diline ve temel yazılım geliştirme kavramlarına aşina olduğunuz varsayımıyla hazırlanmıştır. Özellikle, "geleneksel" ISO C öncesi dilden ziyade ISO standardı olan C ile bir aşinalık olduğu varsayılmıştır.
    </para><para>
<dicterm><english>obsolete</english><turkish>atıl</turkish></dicterm>
<dicterm><english>tab</english><turkish>sekme</turkish></dicterm>
<dicterm><english>backspace</english><turkish>gerisilme</turkish></dicterm>
<dicterm><english>compiler</english><turkish>derleyici</turkish></dicterm>
<dicterm><english>interpreter</english><turkish>yorumlayıcı</turkish></dicterm>
<dicterm><english>linker</english><turkish>ilintileyici</turkish></dicterm>
GNU C kütüphanesi, herbiri birbirleriyle yakın ilişkili özelliklere göre gruplanmış bildirimleri ve tanımları içeren, yazılımınızı işlerken C derleyicisi tarafından kullanılan çeşitli <wordasword>başlık dosyaları</wordasword> içerir. Örneğin <filename>stdio.h</filename> başlık dosyasında girdi ve çıktı işlemleri ile ilgili özellikler, <filename>string.h</filename> dosyasında ise dizge işleme araçları bildirilmiştir. Bu kılavuzdaki konular genelde başlık dosyalarının içeriğine bağlı olarak bölümlenmiştir.
    </para><para>
Bu kılavuzu ilk kez okuyorsanız, giriş bölümünü tamamen okumalı, diğer bölümlere de bir göz gezdirmelisiniz. GNU C kütüphanesi <emphasis>epeyce</emphasis> çok işlev barındırır ve onların nasıl kullanıldığını hatırlamanızı beklemek pek gerçekçi olmaz. Yazılımınızı geliştirirken kütüphane işlevlerini ne zaman kullanacağınızı ve onların akılda kalmayan özelliklerini bu kılavuzun neresinde bulacağınız bilmek için bu kılavuza bir göz gezdirmeniz gerekir.
    </para>
  </chapter>
  <chapter xml:id="glibc-Standards-and-Portability">
    <title>Standartlar ve Taşınabilirlik</title>
    <titleabbrev>GNU C kütüphanesinin üzerine inşa edildiği standartlar ve kaynaklar.</titleabbrev>
    <para/><para>
<indexterm scope="glibc-cp"><primary>standartlar</primary></indexterm>
Bu bölüm GNU C kütüphanesinin üzerine inşa edildiği çeşitli standartlar ve kaynaklar hakkındadır. Bu standartlar ve kaynaklar, ISO C ve POSIX standartları ile Sistem V ve Berkeley Unix gerçeklemelerinden oluşur.
    </para><para>
Bu kılavuzun birincil hedefi GNU kütüphanesinin içerdiklerini daha verimli nasıl kullanacağınızı anlatmaktır. Ancak, yazılımlarınızı bu standartlarla uyumlu yapmak ya da GNU dışındaki işletim sistemlerine de taşınabilir kılmakla ilgileniyorsanız, bu, kütüphaneyi nasıl kullanacağınızı etkiler. Bu bölümde bu standartlara kısaca değinilecek, böylece kılavuzun içinde bunlara rastladıkça onların ne olduğunu bileceksiniz.
    </para><para>
<xref linkend="glibc-Library-Summary"/> bölümünde kütüphanenin içerdiği tüm işlevlerin ve sembollerin bir alfabetik listesini bulabilirsiniz. Bu liste ayrıca her işlev ve sembolün hangi standartlara uyduğu bilgisini de içerir.
    </para><sect1 xml:id="glibc-ISO-C"><title>ISO C</title>
      <titleabbrev>C yazılım geliştirme dili için uluslararası standart.</titleabbrev>
      <para>
<indexterm scope="glibc-cp"><primary>ISO C</primary></indexterm>
GNU C kütüphanesi Amerikan Ulusal Standartları Enstitüsü (ANSI) tarafından yayınlanmış <citation>American National Standard X3.159-1989--&quot;ANSI C&quot;</citation> ve daha sonra Uluslararası Standartlar Teşkilatı (ISO) tarafından kabul edilmiş <citation>ISO/IEC 9899:1990, &quot;Programming languages--C&quot;</citation>  C standardı ile uyumludur. Daha genel bir kabul gördüğünden dolayı biz ISO C standardını referans alıyoruz. GNU kütüphanesini oluşturan içerik ve başlık dosyaları, ISO C standardı tarafından belirtilenlerin bir üst kümesidir.
      </para><para>
<indexterm scope="glibc-pg"><primary>gcc</primary></indexterm>
ISO C standardına tamamen bağlı kalmak istiyorsanız, yazılımınızı GNU C derleyicisi ile derlerken <option>-ansi</option> seçeneğini kullanmalısınız. Bu seçenek derleyiciye ek özellikler açıkça istenmediği sürece kütüphane başlık  dosyalarından <emphasis>sadece</emphasis> ISO C standardı olan şeyleri tanımlamasını söyler. Bu konuda daha fazla bilgi <xref linkend="glibc-Feature-Test-Macros"/> bölümünde bulunabilir.
      </para><para>
Kütüphaneye sadece ISO C özelliklerini içerecek şekilde sınırlama getirilebilmesi önemlidir, çünkü ISO C, kütüphane gerçeklemelerinde tanımlanan isimlere sınırlama  getirir ve GNU genişletmesi bu sınırların dışına çıkar. Bu sınırlamalar hakkında daha fazla bilgi edinmek için <xref linkend="glibc-Reserved-Names"/> bölümüne bakınız.
      </para><para>
Bu kılavuzda ISO C ile diğer kabuller arasındaki farkların tüm ayrıntıları verilmeye çalışılmamıştır. Sadece farklı platformlarda çalışan yazılımlar geliştirebilmeniz için bir fikir verir.
      </para>
    </sect1><sect1 xml:id="glibc-POSIX">
      <title>POSIX (Taşınabilir İşletim Sistemi Arayüzü)</title>
      <subtitle>POSIX (The Portable Operating System Interface)</subtitle>
      <titleabbrev>İşletim sistemleri için ISO/IEC 9945 (nam-ı diğer IEEE 1003) standartları.</titleabbrev>
<indexterm scope="glibc-cp"><primary>POSIX</primary></indexterm>
<indexterm scope="glibc-cp"><primary>POSIX.1</primary></indexterm>
<indexterm scope="glibc-cp"><primary>IEEE Std 1003.1</primary></indexterm>
<indexterm scope="glibc-cp"><primary>ISO/IEC 9945-1</primary></indexterm>
<indexterm scope="glibc-cp"><primary>POSIX.2</primary></indexterm>
<indexterm scope="glibc-cp"><primary>IEEE Std 1003.2</primary></indexterm>
<indexterm scope="glibc-cp"><primary>ISO/IEC 9945-2</primary></indexterm>
      <para>
GNU kütüphanesi ayrıca, <wordasword>Bilgisayar Ortamları için Taşınabilir İşletim Sistemi Arayüzü</wordasword> olarak da bilinen ISO  <firstterm>POSIX</firstterm> ailesi standartlarla da (ISO/IEC 9945) uyumludur.  Bunlar ayrıca ANSI/IEEE Std 1003 olarak da yayınlanmıştır. POSIX genellikle Unix işletim sisteminin çeşitli sürümlerinden türetilmişitir.
      </para><para>
<dicterm><english>library facilities</english><turkish>kütüphane oluşumları</turkish></dicterm>
<dicterm><english>superset</english><turkish>üst küme</turkish></dicterm>
        <dicterm><english>functionality</english><turkish>işlevsellik</turkish></dicterm>
<dicterm><english>lower-level</english><turkish>düşük seviyede</turkish></dicterm>
POSIX standartları ile belirtilen kütüphane oluşumları ISO C ile belirlenenlerin
bir üst kümesidir. POSIX, yeni ek işlevler ya da ISO C işlevlerine eklenen bazı özellikleri belirtir. Genellikle POSIX standartları tarafından tanımlanan ek gereksinimler ve işlevsellik, farklı işletim sistemi ortamlarında çalışabilen genel yazılım geliştirme dilinden ziyade işletim sistemlerinin belli çeşitlerine düşük seviyede destek sağlamak amacındadır.
      </para><para>
GNU C kütüphanesi <citation>ISO/IEC 9945-1:1996, the POSIX System Application  Program Interface</citation> tarafından belirlenen işlevlerin tümünü gerçekler. Kılavuzda bu standart bahis konusu olduğunda POSIX.1 nitelemesi kullanılacaktır. Bu standart tarafından ISO C oluşumlarına ek birincil genişletmeler dosya sistemi arayüzü ilkelleri (<xref linkend="glibc-File-System-Interface"/>), aygıta özel uçbirim denetim işlevleri (<xref linkend="glibc-Low-Level-Terminal-Interface"/>) ile süreç denetim işlevlerini (<xref linkend="glibc-Processes"/>) içerir.
      </para><para>
<dicterm><english>regular expression</english><turkish>düzenli ifade</turkish></dicterm>
<dicterm><english>regexp</english><turkish>düzifd</turkish></dicterm>
<dicterm><english>pattern matching</english><turkish>kalıp eşleştirme</turkish></dicterm>
<citation>ISO/IEC 9945-2:1993, the POSIX Shell and Utilities standard</citation> (POSIX.2) içindeki bazı oluşumlara da GNU kütüphanesinde yer verilmiştir. Bunlar kalıp eşleştirme uygulamaları ile düzenli ifadeleri kullanan uygulamalardır         (Bkz. <xref linkend="glibc-Pattern-Matching"/>).
      </para>
    </sect1><sect1 xml:id="glibc-Berkeley-Unix">
      <title>Berkeley Unix</title>

<indexterm scope="glibc-cp"><primary>BSD Unix</primary></indexterm>
<indexterm scope="glibc-cp"><primary>4.<varname>n</varname> BSD Unix</primary></indexterm>
<indexterm scope="glibc-cp"><primary>Berkeley Unix</primary></indexterm>
<indexterm scope="glibc-cp"><primary>SunOS</primary></indexterm>
<indexterm scope="glibc-cp"><primary>Unix</primary><secondary>Berkeley</secondary></indexterm>
      <para>
GNU C kütüphanesi özellikle 4.2 BSD, 4.3 BSD, 4.4 BSD Unix sistemleri  (<firstterm>Berkeley Unix</firstterm> olarak da bilinir) ile <firstterm>SunOS</firstterm> (biraz Unix Sistem V işlevselliği de içeren bir 4.2 BSD türevi) gibi bazı Unix sürümlerindeki, yazılı standart haline gelmemiş oluşumları da tanımlar. Bu sistemler ISO C ve POSIX oluşumlarının çoğunu destekler. 4.4 BSD ve SunOS'un yeni dağıtımları hepsini destekler.
      </para><para>
<dicterm><english>symbolic link</english><turkish>sembolik bağ</turkish></dicterm>
<dicterm><english>signal handling</english><turkish>sinyal işleme</turkish></dicterm>
BSD oluşumları, <link linkend="glibc-Symbolic-Links">sembolik bağları</link>, <link linkend="glibc-Waiting-for-I-O"><command>select</command> işlevini</link>, <link linkend="glibc-BSD-Signal-Handling">BSD sinyal işlevlerini</link> ve <link linkend="glibc-Sockets">soketleri</link> içerir.
      </para>
    </sect1><sect1 xml:id="glibc-SVID">
      <title>SVID (Sistem V Arayüzü Tanımlaması)</title>
      <titleabbrev>The System V Interface Description.</titleabbrev>
<dicterm><english>interface</english><turkish>arayüz</turkish></dicterm>
<indexterm scope="glibc-cp"><primary>SVID</primary></indexterm>
<indexterm scope="glibc-cp"><primary>System V Unix</primary></indexterm>
<indexterm scope="glibc-cp"><primary>Unix</primary><secondary>System V</secondary></indexterm>
      <para>
<wordasword>Sistem V Arayüzü Tanımlaması</wordasword> (SVID - The System V Interface Description) AT&amp;T Unix System V işletim sistemini tanımlayan bir belgedir. <link linkend="glibc-POSIX">POSIX standardına</link> ek bazı özellikler içeren bir üst küme tanımlar.
      </para><para>        <dicterm><english>compatibility</english><turkish>uyumluluk</turkish></dicterm>
GNU C kütüphanesi, ISO C ve POSIX standartları tarafından gerekli görülmeyen ancak SVID tarafından gerekli görülen özellikleri içeren System V Unix ve diğer Unix sistemleri (SunOS gibi) ile uyumluluk için gerekli oluşumları tanımlar. Diğer yandan, SVID tarafından gerekli görülen ancak genelde az kullanışlı ve daha zor anlaşılır olan oluşumları içermez. (Aslında Unix System V'in kendisi de onların hepsini sağlamaz.)
      </para><para>
<dicterm><english>shared memory</english><turkish>paylaşımlı bellek</turkish></dicterm>
<dicterm><english>function</english><turkish>işlev</turkish></dicterm>
<dicterm><english>process</english><turkish>süreç</turkish></dicterm>
<dicterm><english>inter-process communication (IPC)</english><turkish>süreçler arası iletişim</turkish></dicterm>
Sistem V desteği sağlayan oluşumlar, paylaşımlı bellek ve süreçler arası iletişim için yöntemler, <command>hsearch</command> ve <command>drand48</command> ailesi işlevler, <command>fmtmsg</command> ile çeşitli matematik işlevleri içerir.
      </para>
    </sect1><sect1 xml:id="glibc-XPG">
      <title>XPG (X/Open Taşınabilirlik Kılavuzu)</title>
      <titleabbrev>The X/Open Portability Guide.</titleabbrev>
      <para>        <dicterm><english>portability</english><turkish>taşınabilirlik</turkish></dicterm>
X/Open Taşınabilirlik Kılavuzu, X/Open Company, Ltd. şirketi tarafından yayınlanmış POSIX'den daha bir genel standarttır. X/Open, Unix telif hakkına sahiptir ve XPG de bir Unix sistemi olarak kabul edilen sistemler için gereksinimleri belirtir.
      </para><para>
GNU C kütüphanesi X/Open Taşınabilirlik Kılavuzunun 4.2 sürümü ile tüm X/Open Unix genişletmelerine ve XSI (X/Open Sistem Arayüzü) uyumlu sistemlerde ortak olan tüm genişletmelere uyar.
      </para><para>
POSIX'in üstüne yapılan eklemeler esas olarak Sistem V ve BSD sistemlerinde bulunan işlevsellikten türetilmiştir. Sistem V sistemlerindeki bazı berbat yanlışlıklar da düzeltilmiştir.
      </para>
    </sect1>
  </chapter><chapter xml:id="glibc-Using-the-Library">
    <title>Kütüphanenin Kullanımı</title>
    <titleabbrev>Kütüphanenin pratikte kullanımı.</titleabbrev>
    <para/><para>
Bu bölümde GNU C kütüphanesinin kullanımıyla ilgili bazı pratik çözümlere yer verilmiştir.
    </para><sect1 xml:id="glibc-Header-Files">
      <title>Başlık Dosyaları</title>
      <titleabbrev>Başlık dosyalarını yazılımlarınıza nasıl dahil edersiniz.</titleabbrev>
<indexterm scope="glibc-cp"><primary>başlık dosyaları</primary></indexterm>
<dicterm><english>data type</english><turkish>veri türü</turkish></dicterm>
<dicterm><english>macro</english><turkish>makro</turkish></dicterm>
      <para>
C yazılımları tarafından kullanılan kütüphaneler gerçekte iki ana parçadan oluşur: veri türlerinin ve makroların tanımlandığı, değişkenlerin ve işlevlerin bildirildiği <wordasword>başlık dosyaları</wordasword> ile değişken ve işlev tanımlarının bulunduğu <wordasword>arşiv</wordasword>, yani asıl kitaplık.
      </para><para>
<dicterm><english>declaration</english><turkish>bildirim</turkish></dicterm>
<dicterm><english>variable</english><turkish>değişken</turkish></dicterm>
<dicterm><english>definition</english><turkish>tanımlama</turkish></dicterm>
<dicterm><english>preprocessor</english><turkish>önişlemci</turkish></dicterm>
<dicterm><english>directive</english><turkish>yönerge</turkish></dicterm>
<indexterm scope="glibc-cp"><primary>tanımlama (bildirimle karşılaştırmalı olarak)</primary></indexterm>
<indexterm scope="glibc-cp"><primary>bildirim (tanımlama karşılaştırmalı olarak)</primary></indexterm>
(C ile ilgili bilgileri hatırlayalım: Bir <wordasword>bildirim</wordasword> bir işlev ya da bir değişkenin varlığı ve türü hakkında bilgi verir. İşlev bildirimi ayrıca argümanlarının türleri hakkında da bilgi verir. Bildirim işlemi yoluyla, derleyiciler nesnelerin hangi özelliklere sahip olduklarını anlarlar. <wordasword>Tanımlama</wordasword> ise derleyiciye değişken için bellekte yer ayırmasını ya da işlevin ne yaptığını belirtmek içindir. Yani tanımlama ile  derleyici bellekte bir yer açarken, bildirim de bunu yapmaz.) GNU C kütüphanesindeki oluşumları kullanırken, yazılımınızın kaynak koduna ilgili başlık dosyalarını dahil etmeniz gerekir. Böylece derleyici bu oluşumların bildirimlerini edinir ve onları doğru olarak işler. Yazılımınız önişlemci tarafından işlendikten sonra ilintileyici bunların sağladığı bilgilerle arşiv dosyasındaki tanımlamalara ulaşır.
      </para><para>
Başlık dosyaları bir yazılımın kaynak koduna <command>#include</command> önişlemci deyimi ile dahil edilir. C dili bu deyimi iki şekilde kabul eder; Birinci kullanım,
      </para><para>
<screen>#include &quot;<varname>başlık</varname>&quot;</screen>
      </para><para>
şeklindedir ve bununla kendi yazdığınız, yazılımınızın farklı parçaları arasındaki arayüzleri açıklayan bildirim ve tanımları içeren <varname>başlık</varname> isimli bir başlık dosyasını kaynak kodunuza dahil edersiniz. İkinci kullanımı ise,
      </para><para>
<screen>#include &lt;dosya.h></screen>
      </para><para>
şeklindedir ve bununla bir standart kütüphanenin bildirim ve tanımlarının bulunduğu <filename>dosya.h</filename> başlık dosyasını kaynak kodunuza dahil edersiniz. Bu dosya normalde sistem yöneticiniz tarafından standart bir yere konmuştur. C kütüphanesinin başlık dosyalarını kaynak kodunuza dahil etmek istediğinizde bu ikincisini kullanmalısınız.
      </para><para>
<dicterm><english>comment</english><turkish>açıklama</turkish></dicterm>
<dicterm><english>feature test macros</english><turkish>özellik sınama makroları</turkish></dicterm>
Genellikle, <command>#include</command> önişlemci deyimleri C kaynak kodunun ilk satırlarında bulunur. Kaynak dosyalarınızın başına bu kodun ne yaptığına ilişkin bazı açıklamalar koyuyorsanız, <link linkend="glibc-Feature-Test-Macros">özellik sınama makrolarının</link> tanımlarını hemen altındaki satırlara koyun ve ardından da <command>#include</command> önişlemci deyimlerini yerleştirin.
      </para><para>
GNU C kütüphanesindeki başlık dosyaları birbiriyle ilgili oluşumların tür ve makro tanımları ile değişken ve işlev bildirimleri şeklinde gruplanarak oluşturulmuştur. Bu nedenle kullanmak istediğiniz özellikler ile örtüşen çok sayıda başlık dosyasını kaynak kodunuza dahil etmeniz gerekebilir.
      </para><para>
Bazı kütüphane başlık dosyaları başka bir kütüphanenin başlık dosyalarını da içerebilir. Bu bir yazılım geliştirme tarzı ile ilgilidir ve siz buna pek bel bağlamayın; en iyisi kullandığınız kütüphane oluşumları için gerekli başlık dosyalarını kendiniz yine de kodunuza dahil edin. Kaynak koduna aynı başlık dosyasının defalarca dahil edilmiş olmasının bir önemi yoktur. İlk dahil edilenden sonrakiler etkisizdir.
      </para><para>
        <note><title>Uyumluluk bilgisi</title><para>
<dicterm><english>specification</english><turkish>belirtim</turkish></dicterm>
ISO C gerçeklemelerinin hepsi başlık dosyalarının sıralaması ve defalarca içerilmesi durumlarında bu şekilde davranır. Ancak, çok eski C gerçeklemelerinde bu geleneksel bir durum haline gelmemişti.</para></note>
      </para><para>
Belirtmek gerekir ki, bir işlevin bildirildiği bir başlık dosyasını kodunuza dahil etmek zorunda değilsiniz. Bu kılavuzdaki belirtimlere uyarak, o işlevi kendiniz de bildirebilirsiniz. Ancak bu önerilmez, çünkü başlık dosyası o işlevi bir makro tanımı olarak içeriyor olabilir.
      </para>
    </sect1><sect1 xml:id="glibc-Macro-Definitions">
      <title>Makro Olarak Tanımlanmış İşlevler</title>
      <titleabbrev>Kütüphanedeki bazı işlevler aslında bir makro olarak tanımlanmış olabilir.</titleabbrev>
<indexterm scope="glibc-cp"><primary>hayalet işlevler</primary><secondary>makro olarak tanımlama</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>hayalet işlevler</primary><secondary>makroların kaldırılması</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>hayalet işlevler</primary><secondary>makroların silinmesi</secondary></indexterm>
<dicterm><english>equivalent</english><turkish>eşdeğer</turkish></dicterm>
<dicterm><english>evaluate</english><turkish>değerlendirme</turkish></dicterm>
<dicterm><english>context</english><turkish>bağlam</turkish></dicterm>
      <para>
Bu kılavuzda bir işlev olarak bahsettiğimiz bazı şeyler aslında bir makro tanımı olabilir.  Bu durum makro tanımı da işlevin yaptığını yaptığından yazılımın çalışması açısından bir sorun çıkmaz. Kütüphane işlevlerinin makro eşdeğerlerinin argümanları işlev çağrılarındaki gibi değerlendirilir. İşlev tanımları yerine bu makro tanımlarının yapılmasının sebebi, makrolar satıriçi sembolik dile özgü yorumlar şeklinde üretebildiğinden, bir işlevden daha hızlı çalışabilmeleridir.
      </para><para>
Bir kitaplık işlevinin adresini almak, bu bir makro olarak tanımlanmış olsa bile  çalışır. Bu bağlam içerisinde çalışmasının sebebi, işlevin adından sonra, bir  makro çağrısını tanımak için gereken sol parantezin olmamasıdır.
      </para><para>
Kimi zaman bir makro tanımının bir işlev olarak kullanılmasını istemeyebilirsiniz. Bu, yazılımınızda hata ayıklamayı kolaylaştırır.  Bunu yapmanın iki yolu vardır:
      </para><para><itemizedlist><listitem><para>
<dicterm><english>syntactically</english><turkish>sözdizimsel olarak</turkish></dicterm>
<dicterm><english>syntactic context</english><turkish>sözdizimsel bağlam</turkish></dicterm>
Makro çağrılarına özel olarak, işlev ismini parantez içine alarak bir makro  tanımından kurtulabilirsiniz.  Bunun çalışmasının sebebi işlev isminin sözdizimsel olarak artık bir makro çağrısı olarak algılanmamasıdır.
      </para></listitem><listitem><para>
Makro tanımını kaynak kodunuzun içinde <command>#undef</command> önişlemci deyimi ile (oluşumun açıklamasında aksi belirtilmediği sürece) devredışı bırakabilirsiniz.
      </para></listitem></itemizedlist></para><para>
Örneğin, <filename>stdlib.h</filename> başlık dosyasında <command>abs</command> isimli bir işlevin bildirimi olduğunu kabul edelim:
      </para><para>
<screen>extern int abs (int);</screen>
      </para><para>
Ve, <command>abs</command> için bir makro tanımı olsun:
      </para><para>
<screen>
#include stdlib.h
int f (int *i) { return abs (++*i); }
</screen>
      </para><para>
Burada <command>abs</command>, hem bir makro hem de bir işlevdir. Aşağıdaki örneklerde ise <command>abs</command> sadece bir işlevdir, bir makro değildir.
      </para><para>
<screen>
#include stdlib.h
int g (int *i) { return (abs) (++*i); }
</screen></para><para><screen>
#undef abs
int h (int *i) { return abs (++*i); }
</screen>
      </para><para>
Makro tanımları, asıl işlevin yaptığını yapmaktan başka bir makro da tanımladığından bu yöntemlere gerçekte hiç ihtiyaç yoktur. Ayrıca, bir makro tanımının kaldırılması yazılımınızın daha yavaş çalışmasına sebep olacaktır.
      </para>
    </sect1><sect1 xml:id="glibc-Reserved-Names">
      <title>Anahtar Sözcükler</title>
      <titleabbrev>C standardı, bazı isimleri kullanıcılara bazılarını da kütüphane için ayırır.</titleabbrev>
      <para>
<indexterm scope="glibc-cp"><primary>anahtar sözcükler</primary></indexterm>
<indexterm scope="glibc-cp"><primary>isim alanı</primary></indexterm>
Kütüphanedeki veri türü, makro, değişken ve işlevlerin isimlerinden ISO C standardında belirtilenler koşulsuz olarak rezerve edilmiştir. Yazılımınızda bu  isimleri yeniden tanımlayamazsınız. Kütüphanedeki diğer isimler ise, onların bildirildiği veya tanımlandığı başlık dosyalarını içerdiği taktirde onlar da bu gruba dahil olur. Bu sınırlamaların çeşitli nedenleri vardır:
      </para><para><itemizedlist><listitem><para>
<dicterm><english>modularity</english><turkish>modülerlik</turkish></dicterm>
<dicterm><english>maintainability</english><turkish>yeniden düzenlenebilirlik</turkish></dicterm>
Örneğin, standart <function>exit</function> işlevinin yaptığından farklı işler yapan bir <function>exit</function> işleviniz varsa, kodunuzu okuyan başkaları, kodunuzu anlamakta çok zorluk çekecektir. Bu durumlardan kaçınırsanız, yazılımınız hem daha kolay anlaşılır olur, hem de modülerliği ve yeniden düzenlenebilirliği artar.
      </para></listitem><listitem><para>
Yeniden tanımlanan bir işlev onu kullanan başka kütüphane işlevlerinin hatalı çalışmasına sebep olabilir. Yani, yeniden tanımlama mümkün olsaydı diğer işlevler düzgün çalışamayabilecekti.
      </para></listitem><listitem><para>
<dicterm><english>redefine</english><turkish>yeniden tanımlama</turkish></dicterm>
<dicterm><english>optimization</english><turkish>eniyileme</turkish></dicterm>
<dicterm><english>variadic</english><turkish>değişkin</turkish></dicterm>
<dicterm><english>built-in</english><turkish>yerleşik</turkish></dicterm>
<dicterm><english>identifier</english><turkish>isim</turkish></dicterm>
<dicterm><english>identifier</english><turkish>belirteç</turkish></dicterm>
        <dicterm><english>implementation</english><turkish>gerçekleme</turkish></dicterm>
Derleyiciden eniyileme yapması istendiğinde, bir işlevin kullanıcı tarafından yeniden tanımlanması mümkün olmadığında, derleyici bu işlevlere eniyileme yapıp yapmayacağına daha iyi karar verebilecektir. Bazı kütüphane oluşumlarında örneğin <link linkend="glibc-Variadic-Functions">argüman sayısı değişken işlevler</link> ile çalışmada ve <link linkend="glibc-Non-Local-Exits">yerel olmayan çıkışlarda</link> C derleyicisinin bir bölümünün bu işlevlerle bir bütünlük içinde çalışması gerekir. Ayrıca gerçeklenme açısından, derleyici dilin yerleşik parçaları olarak bunlarla daha kolay çalışabilir.
      </para></listitem></itemizedlist></para><para>
Bu kılavuzda belgelenmiş olan isimlere ek olarak, tek altçizgi (<command>_</command>) ile başlayan tüm harici isimler (genel işlevler ve değişkenler) ile nerede ve nasıl kullanılmış olurlarsa olsunlar iki altçizgi ile veya bir altçizgiden sonra bir büyük harfle başlayan tüm isimler rezerve sözcüklerdir. Kütüphane ve başlık dosyalarında tanımlanan işlevler, değişkenler ve makroların dahili kullanım amaçlı olanları, yazılımcının isim kullanım alanını daraltmamak ve yazılımcının kullanacağı olası isimlerle çakışma olmaması için bu yöntemle seçilmektedir.
      </para><para>
Bazı isim sınıfları, C dilinin ve POSIX.1 ortamının gelecekteki geliştirmelerinde kullanılmak üzere ayrılmıştır. Bu isimleri şimdi kullandığınızda bir sorun çıkmayacak olsa da gelecekte C ve POSIX standartları ile çelişebilecektir. Bu nedenle onları şimdiden kullanmamaya başlamanız önerilir.
      </para><para><itemizedlist><listitem>
Bir büyük <command>E</command> harfi ile başlayan, bir sayı veya büyük harf ile  devam eden tüm isimler hata kodlarının isimleri olarak ayrılmıştır. Bkz. <xref linkend="glibc-Error-Reporting"/>.
      </listitem><listitem>
<command>is</command> veya <command>to</command> ile başlayan ve küçük harf ile devam eden isimler karakter sınama ve dönüşüm işlevleri için kullanılmak üzere ayrılmıştır. Bkz. <xref linkend="glibc-Character-Handling"/>.
      </listitem><listitem>
<command>LC_</command> ile başlayan ve büyük harflerden oluşan isimler yerel nitelikleri belirleyen makroların isimleri olarak kullanılabilir diye ayrılmıştır. Bkz. <xref linkend="glibc-Locales"/>.
      </listitem><listitem>
Tüm bilinen matematik işlevlerinin isimleri, <command>f</command> veya  <command>l</command> harfi ile sonlandırılmış olarak <command>float</command> ve <command>long double</command> argümanlarla kullanılmak üzere işlev isimleri olarak ayrılmıştır. Bkz. <xref linkend="glibc-Mathematics"/>.
      </listitem><listitem>
<command>SIG</command> ile başlayan ve büyük harflerden oluşan tüm isimler sinyal isimleri olarak ayrılmıştır. Bkz. <xref linkend="glibc-Standard-Signals"/>.
      </listitem><listitem>
<command>SIG_</command> ile başlayan ve büyük harflerden oluşan tüm isimler sinyal eylemlerinin isimleri olarak ayrılmıştır. Bkz.  <xref linkend="glibc-Basic-Signal-Handling"/>.
      </listitem><listitem>
<command>str</command>, <command>mem</command> veya <command>wcs</command> ile başlayan ve küçük harflerden oluşan isimler dizi ve dizge işlevlerinin isimleri olarak ayrılmıştır. Bkz. <xref linkend="glibc-String-and-Array-Utilities"/>.
      </listitem><listitem>
<command>_t</command> ile biten isimler veri türlerinin isimleri için ayrılmıştır.
      </listitem></itemizedlist></para><para>
Bunlara ek olarak bazı başlık dosyalarının kullanımına bağlı olarak o başlık dosyasına özel bazı isimler rezerve edilmştir. Bu başlık dosyalarını kullandığınızda bu isimleri kullanmamaya çalışmalısınız.
      </para><para><itemizedlist>
      <listitem>
<command>d_</command> ile başlayan isimler <command>dirent.h</command> başlık dosyası ile rezervedir.
<indexterm scope="glibc-pg"><primary>dirent.h</primary></indexterm>
      </listitem><listitem>
<command>l_</command>, <command>F_</command>, <command>O_</command> ve <command>S_</command> ile başlayan isimler <command>fcntl.h</command> başlık dosyası ile rezervedir.
<indexterm scope="glibc-pg"><primary>fcntl.h</primary></indexterm>
      </listitem><listitem>
<command>gr_</command> ile başlayan isimler <command>grp.h</command> başlık dosyası ile rezervedir.
<indexterm scope="glibc-pg"><primary>grp.h</primary></indexterm>
      </listitem><listitem>
<command>_MAX</command> ile biten isimler <command>limits.h</command> başlık dosyası ile rezervedir.
<indexterm scope="glibc-pg"><primary>limits.h</primary></indexterm>
      </listitem><listitem>
<command>pw_</command> ile başlayan isimler <command>pwd.h</command> başlık dosyası ile rezervedir.
<indexterm scope="glibc-pg"><primary>pwd.h</primary></indexterm>
      </listitem><listitem>
<command>sa_</command> ve <command>SA_</command> ile başlayan isimler <command>signal.h</command> başlık dosyası ile rezervedir.
<indexterm scope="glibc-pg"><primary>signal.h</primary></indexterm>
      </listitem><listitem>
<command>st_</command> ve <command>S_</command> ile başlayan isimler <command>sys/stat.h</command> başlık dosyası ile rezervedir.
<indexterm scope="glibc-pg"><primary>sys/stat.h</primary></indexterm>
      </listitem><listitem>
<command>tms_</command> ile başlayan isimler <command>sys/times.h</command> başlık dosyası ile rezervedir.
<indexterm scope="glibc-pg"><primary>sys/times.h</primary></indexterm>
      </listitem><listitem>
<command>c_</command>, <command>V</command>, <command>I</command>,  <command>O</command> ve <command>TC</command> ile başlayan isimler ile  <command>B</command> ile başlayıp bir rakam ile devam eden isimler <command>termios.h</command> başlık dosyası ile rezervedir.
<indexterm scope="glibc-pg"><primary>termios.h</primary></indexterm>
     </listitem></itemizedlist></para>
   </sect1><sect1 xml:id="glibc-Feature-Test-Macros">
     <title>Özellik Sınama Makroları</title>
     <para>
<indexterm scope="glibc-cp"><primary>özellik sınama makroları</primary></indexterm>
Bir kaynak dosyasını derlerken kullanabileceğiniz özelliklerden istediklerinizi <wordasword>özellik sınama makroları</wordasword>nı tanımlayarak kontrol edebilirsiniz.
      </para><para>
<dicterm><english>option</english><turkish>seçenek</turkish></dicterm>
Yazılımınızı <command>gcc -ansi</command><footnote><para>GCC seçeneklerinin bir listesini <command>gcc  --help</command> ile görebilirsiniz.</para></footnote> kullanarak derlediğinizde, bir veya birkaç özellik  makrosu tanımlamamışsanız sadece ISO C kütüphanesinin özelliklerini elde edebilirsiniz.
      </para><para>
Bu makroları kaynak kod dosyalarınızın en tepesinde <command>#define</command>
 önişlemci deyimini kullanarak tanımlayabilirsiniz. Bu deyimler, <command>#include</command> deyimlerinden de <emphasis>önce olmalıdır</emphasis>. Daha iyi açıklamak için bu deyimlerden önce sadece açıklamalar bulunabilir diyebiliriz. Bundan başka GCC'nin <option>-D</option> seçeneği ile de bu makrolar kullanılabilirse de makroların kaynak dosyaların kendisinde tanımlanması daha iyidir.
      </para><para>
Bu sistem çok sayıda standardı destekleyen kütüphane oluşturmayı mümkün kılar. Farklı standartlar çoğunlukla bir başka standardın üzerine birşeyler ekler ve birbirileriyle de uyumsuzlardır. Geniş kapsamlı standartların gerektirdiği işlev isimleri kullanıcıya kalan isim alanını da küçültür. Bu ukalalıktan öte, pratikte sorunlar oluşturur. Örneğin, bazı GNU dışı yazılımlar, bu kütüphanede bulunan <function>getline</function> işlevinin yaptığından tamamen farklı işlemler yürüten bir <function>getline</function> işlevi içerebilir ve bunlar eğer tüm özellikleriyle ayrım yapmaksızın etkin kılınırsa uyumluluk sağlanamaz.
      </para><para>
Bu durumdan, bir yazılım ancak sınırlı sayıda standarda uygun olabilir sonucu çıkarılmamalıdır. Üzerinde ayrım yapılamayan geniş standartlar uyumluluk için yetersizdir. Standart dışı başlık dosyalarının içerilmesinden ya da standart içinde tanımlanmamış özelliklerin katıştırılmasından sizi koruyamaz.
      </para><para>
<indexterm scope="glibc-vr"><primary sortas="POSIX_SOURCE">_POSIX_SOURCE</primary></indexterm>
<funcsynopsis><funcprototype role="makro" xml:id="glibc_POSIX_SOURCE">
<funcdef><command>_POSIX_SOURCE</command></funcdef>
</funcprototype><funcdescr><para>
Bu makroyu <command>#define</command> ile belirtirseniz, ISO C özelliklerine ek olarak POSIX.1 standardının (IEEE Standard 1003.1) işlevselliğine de sahip olunur.
        </para><para>
Bir pozitif tamsayıyı <command>_POSIX_C_SOURCE</command> makrosuna atarsanız <command>_POSIX_SOURCE</command> etkisiz olacaktır.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-vr"><primary sortas="POSIX_C_SOURCE">_POSIX_C_SOURCE</primary></indexterm>
<funcsynopsis><funcprototype role="makro" xml:id="glibc_POSIX_C_SOURCE">
<funcdef><command>_POSIX_C_SOURCE</command></funcdef>
</funcprototype><funcdescr><para>
Bu makroya atayacağınız pozitif tamsayılarla hangi POSIX özelliklerinin etkin olacağını belirleyebilirsiniz. Daha büyük değerler daha büyük işlevsellik sağlar.
        </para><para>
Bu makroya <command>1</command> ya da daha büyük bir tamsayı atarsanız, POSIX.1 standardının 1990 sürümündeki (IEEE Standard 1003.1-1990) işlevselliği elde edersiniz.
        </para><para>
Bu makroya <command>2</command> ya da daha büyük bir tamsayı atarsanız, POSIX.2 standardının 1992 sürümündeki (IEEE Standard 1003.2-1992) işlevselliği elde edersiniz.
        </para><para>
Bu makroya <command>199309L</command> ya da daha büyük bir tamsayı atarsanız, POSIX.1b standardının 1993 sürümündeki (IEEE Standard 1003.1b-1993) işlevselliği elde edersiniz.
        </para><para>
Daha büyük değerler ise geleceğe yönelik genişletmeleri etkin kılacaktır. POSIX standardının gelişim sürecinde bu değerler tanımlandıkça, GNU C kütüphanesi onlar standart haline geldikçe destekleyecektir. <command>_POSIX_C_SOURCE</command>'a <command>199506L</command> ya da daha büyük bir tamsayı atarsanız, POSIX.1 standardının 1996 sürümündeki (ISO/IEC 9945-1: 1996) işlevselliği elde edersiniz.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-vr"><primary sortas="BSD_SOURCE">_BSD_SOURCE</primary></indexterm>
<funcsynopsis><funcprototype role="makro" xml:id="glibc_BSD_SOURCE">
<funcdef><command>_BSD_SOURCE</command></funcdef>
</funcprototype><funcdescr><para>
Bu makro belirtilirse, 4.3 BSD Unix'den türetilmiş işlevselliğe ek olarak ISO C, POSIX.1 ve POSIX.2 işlevselliği elde edilir.
        </para><para>
4.3 BSD Unix'den türetilmiş bazı oluşumlar POSIX.1 standardındaki bazı özelliklerle çelişir. Bu makro kullanıldığında 4.3 BSD tanımlamaları POSIX.1 tanımlamalarına göre öncelikli olur.
        </para><para>
4.3 BSD ile POSIX.1 arasındaki bazı çakışmalardan dolayı, BSD uyumluluğu ile derlediğiniz yazılımlarınızı ilintilerken özel <wordasword>BSD uyumluluk kütüphanesi</wordasword> kullanmanız gerekebilir. Bu farkları giderebilmek için bazı işlevlerin iki farklı yolla tanımlanmaları gerekir. Biri normal C kütüphanesi, diğeri uyumluluk kütüphanesidir. Yazılımınızda <command>_BSD_SOURCE</command> makrosunu kullanıyorsanız, <option>-lbsd-compat</option> seçeneği ile derlemelisiniz. Bu derleyici veya ilintileyiciye, işlevleri normal C kütüphanesinde değil, uyumluluk  kütüphanesinde araması gerektiğini söyler.
<indexterm scope="glibc-pg"><primary sortas="lbsd-compat">-lbsd-compat</primary></indexterm>
<indexterm scope="glibc-pg"><primary>bsd-compat</primary></indexterm>
<indexterm scope="glibc-cp"><primary>BSD uyumluluk kütüphanesi</primary></indexterm>
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-vr"><primary sortas="SVID_SOURCE">_SVID_SOURCE</primary></indexterm>
<funcsynopsis><funcprototype role="makro" xml:id="glibc_SVID_SOURCE">
<funcdef><command>_SVID_SOURCE</command></funcdef>
</funcprototype><funcdescr><para>
Bu makro belirtilirse, SVID'den türetilmiş işlevselliğe ek olarak ISO C, POSIX.1, POSIX.2 ve X/Open işlevselliği de elde edilir.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-vr"><primary sortas="XOPEN_SOURCE">_XOPEN_SOURCE</primary></indexterm>
<indexterm scope="glibc-vr"><primary sortas="XOPEN_SOURCE_EXTENDED">_XOPEN_SOURCE_EXTENDED</primary></indexterm>
<funcsynopsis><funcprototype role="makro" xml:id="glibc_XOPEN_SOURCE">
<funcdef><command>_XOPEN_SOURCE</command></funcdef>
</funcprototype><funcprototype role="makro" xml:id="glibc_XOPEN_SOURCE_EXTENDED">
<funcdef><command>_XOPEN_SOURCE_EXTENDED</command></funcdef>
</funcprototype><funcdescr><para>
Bu makro belirtilirse, X/Open Taşınabilirlik Kılavuzunda açıklanan işlevsellik elde edilir. Bu POSIX.1 ve POSIX.2 işlevselliğinin üstünde bir genişletme içerdiğinden <command>_POSIX_SOURCE</command> ve<command>_POSIX_C_SOURCE</command> kendiliğinden tanımlanmış olur.
        </para><para>
Tüm Unixlerin aynı olması ilkesinden hareketle, sadece BSD ve SVID'de geçerli işlevselliği de içerir.
        </para><para>
Eğer <command>_XOPEN_SOURCE_EXTENDED</command> makrosu da ayrıca belirtilmişse, fazladan bir işlevsellik eklenir. Bu fazladan işlevler, X/Open Unix ticari sürümünün gerektirdiği tüm işlevleri sağlayacaktır.
        </para><para>
<command>_XOPEN_SOURCE</command> makrosuna 500 değeri atanırsa, mevcut işlevselliğe ek olarak Single Unix Specification, version 2 içindeki yeni tanımlar da içerilecektir.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-vr"><primary sortas="LARGEFILE_SOURCE">_LARGEFILE_SOURCE</primary></indexterm>
<funcsynopsis><funcprototype role="makro" xml:id="glibc_LARGEFILE_SOURCE">
<funcdef><command>_LARGEFILE_SOURCE</command></funcdef>
</funcprototype><funcdescr><para>
<dicterm><english>shortcomings</english><turkish>yetersizlikler</turkish></dicterm>
<dicterm><english>caveat</english><turkish>yetersizlik</turkish></dicterm>
Bu makro belirtilirse tüm önceki standarlardaki bazı yetersizlikleri düzelten ek işlevler tanımlanmış olur. Özellikle, <command>fseeko</command> ve  <command>ftello</command> işlevlerini kullanmak içindir. Bu işlevler olmaksızın ISO C arayüzü (<command>fseek</command>, <command>ftell</command>) ile düşük seviyeli POSIX arayüzü (<command>lseek</command>) arasında bazı sorunlar çıkacaktır.
        </para><para>
Bu makro, Büyük Dosya Desteğinin (LFS - Large File Support) bir parçası olarak kütüphaneye dahil edilmiştir.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-vr"><primary sortas="LARGEFILE64_SOURCE">_LARGEFILE64_SOURCE</primary></indexterm>
<funcsynopsis><funcprototype role="makro" xml:id="glibc_LARGEFILE64_SOURCE">
<funcdef><command>_LARGEFILE64_SOURCE</command></funcdef>
</funcprototype><funcdescr><para>
Bu makroyu belirtirseniz, içerdiği ek işlevlerle 32 bitlik sistemlerdeki 2GB'lık dosya büyüklüğü sınırı aşılabilir. Bu arayüz, büyük dosyaları desteklemeyen sistemlerde kullanılamaz. Doğal dosya büyüklüğü 2GB'dan büyük olan sistemlerde (örn, 64 bitlik sistemler) ise yeni işlevler, mevcutlarla eşdeğerdedir.
        </para><para>
Bu yeni işlevsellik mevcut olan türler ve işlevlerle yer değiştirilerek kullanılır. Bu yeni nesnelerin isimlerinde maksadını ifade edecek şekilde  <command>64</command> bulunur. Örneğin, <function>off_t</function> yerine <function>off64_t</function>, <function>fseeko</function> yerine  <function>fseeko64</function> gibi.
        </para><para>
<dicterm><english>Large File Support (LFS)</english><turkish>Büyük Dosya Desteği</turkish></dicterm>
Bu makro, Büyük Dosya Desteğinin (LFS - Large File Support) bir parçası olarak kütüphaneye dahil edilmiştir. 64 bitlik kullanım halen genele yansımadığından bu bir geçiş dönemi arayüzüdür. (Aşağıdaki <command>_FILE_OFFSET_BITS</command> makrosunun açıklamalarına bakınız).
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-vr"><primary sortas="FILE_OFFSET_BITS">_FILE_OFFSET_BITS</primary></indexterm>
<funcsynopsis><funcprototype role="makro" xml:id="glibc_FILE_OFFSET_BITS">
<funcdef><command>_FILE_OFFSET_BITS</command></funcdef>
</funcprototype><funcdescr><para>
Bu makro sistemde hangi dosya sistemi arayüzünün kullanılacağını belirlemekte kullanılır. <command>_LARGEFILE64_SOURCE</command>, bir ek arayüz olarak 64 bitlik arayüzü etkin kılar. <command>_FILE_OFFSET_BITS</command> ise 64 bitlik arayüzün eski arayüzle değiştirilmesini mümkün kılar.
        </para><para>
<command>_FILE_OFFSET_BITS</command> belirtilmemişse veya <command>32</command> değeri ile belirtilmişse hiçbir etkisi olmaz. 32 bitlik arayüz, 32 bitlik sistemlerde 32 bitlik <function>off_t</function> türü ile kullanılmaya devam eder.
        </para><para>
Makro, <command>64</command> değeri ile belirtilmişse, büyük dosya arayüzü eski arayüzle değiştirilir. Yani işlevler farklı isimler altında olmaz, eski işlev isimleri yenileri için geçerli olur. Siz <function>fseeko</function> işlevini çağırdığınızda aslında <function>fseeko64</function> işlevini kullanmış olursunuz.
        </para><para>
Bu makro sadece, sistem büyük dosyalarla çalışabileceğiniz bir mekanizma sağlıyorsa belirtilebilir. 64 bitlik sistemlerde bu makro etkisizdir. <command>*64</command> isimli işlevler normal işlevlerle eşdeğerdir.
        </para><para>
Bu makro, Büyük Dosya Desteğinin (LFS - Large File Support) bir parçası olarak kütüphaneye dahil edilmiştir.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-vr"><primary sortas="ISOC99_SOURCE">_ISOC99_SOURCE</primary></indexterm>
<funcsynopsis><funcprototype role="makro" xml:id="glibc_ISOC99_SOURCE">
<funcdef><command>_ISOC99_SOURCE</command></funcdef>
</funcprototype><funcdescr><para>
ISO C standardı yeniden gözden geçirilip düzeltilinceye kadar yeni özellikler geniş uygulama alanı bulsalar bile özdevinimli olarak etkinleştirilmez. Buna rağmen GNU libc yeni standardın tam bir gerçeklemesine sahiptir ve bu yeni özellikler <command>_ISOC99_SOURCE</command> makrosu ile etkinleştirilebilir.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-vr"><primary sortas="GNU_SOURCE">_GNU_SOURCE</primary></indexterm>
<funcsynopsis><funcprototype role="makro" xml:id="glibc_GNU_SOURCE">
<funcdef><command>_GNU_SOURCE</command></funcdef>
</funcprototype><funcdescr><para>
Bu makro belirtildiğinde herşey etkin olur: SO C89, ISO C99, POSIX.1, POSIX.2, BSD, SVID, X/Open, LFS ve GNU oluşumları. Bu durumda POSIX.1 ile BSD arasındaki çakışmalar için öncelik POSIX.1'dedir.
        </para><para>
<command>_GNU_SOURCE</command> makrosunun tam etkili ancak BSD'nin öncelik almasını isterseniz, bunu makroların belirtilme sırasını aşağıdaki gibi düzenleyerek yapmalısınız:
        </para><para>
<screen>#define _GNU_SOURCE
#define _BSD_SOURCE
#define _SVID_SOURCE
</screen></para><para>
Bunu yaparsanız, derleyici ya da ilintileyiciye <command>-lbsd-compat</command> seçeneğini vererek yazılımınızın BSD uyumluluk kütüphanesi ile ilintilenmesini sağlamalısınız.
        </para><para>
<note><para>Bunu yapmayı unutursanız, yazılımın çalışması sırasında çok tuhaf hatalarla karşılaşabilirsiniz.</para></note>
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-vr"><primary sortas="REENTRANT">_REENTRANT</primary></indexterm>
<indexterm scope="glibc-vr"><primary sortas="THREAD_SAFE">_THREAD_SAFE</primary></indexterm>
<funcsynopsis><funcprototype role="makro" xml:id="glibc_REENTRANT">
<funcdef><command>_REENTRANT</command></funcdef>
</funcprototype><funcprototype role="makro" xml:id="glibc_THREAD_SAFE">
<funcdef><command>_THREAD_SAFE</command></funcdef>
</funcprototype><funcdescr><para>
<dicterm><english>reentrant</english><turkish>evresel</turkish></dicterm>
<dicterm><english>non-reentrant</english><turkish>evresel olmayan</turkish></dicterm>
Bu makroları belirttiğinizde bazı işlevlerin <wordasword>evresel</wordasword> (<literal>reentrant</literal>) sürümleri bildirilmiş olur. Bu işlevlerin bazıları POSIX.1c içinde belirtilmişse de bir çoğu GNU libc'ye özeldir, bir kısmı da diğer bazı sistemlerde kullanılmaktadır. Sorun standartlaştırmadaki gecikmeden kaynaklanmaktadır.
        </para><para>
Birtakım başka sistemlede ise C kütüphanesinin buna özel bir sürümü yoktur. Sadece tek bir sürüm vardır ancak derleme sırasında bu durumun belirtilmesi gerekir.
</para></funcdescr></funcsynopsis></para><para>
Yeni yazacağınız yazılımlarda <command>_GNU_SOURCE</command> kullanmanızı öneririz. GCC'ye <option>-ansi</option> seçeneğini belirtmez ve bu makrolardan hiçbirini kaynak kodunuzda belirtmezseniz bunun etkisi <command>_POSIX_C_SOURCE</command> makrosunun 2 ile, <command>_POSIX_SOURCE</command>, <command>_SVID_SOURCE</command> ve <command>_BSD_SOURCE</command> makrolarını 1 ile atamakla eşdeğerdedir.
      </para><para>
Daha geniş özellikler içeren bir özellik sınama makrosu ile birlikte bu makronun kapsamında olan makrolardan birini ayrıca belirtmenin bir etkisi yoktur. Örneğin, <command>_POSIX_C_SOURCE</command> makrosundan sonra <command>_POSIX_SOURCE</command> makrosunun belirtilmesinin bir etkisi olmayacaktır. Benzer şekilde <command>_GNU_SOURCE</command> makrosundan sonra belirtilen <command>_POSIX_SOURCE</command> veya  <command>_POSIX_C_SOURCE</command> ya da <command>_SVID_SOURCE</command> makrolarının bir etkisi olmaz.
      </para><para>
Yalnız, <command>_BSD_SOURCE</command> makrosu hiçbir makronun kapsamında değildir. Bu, BSD ile POSIX arasındaki bazı çakışmalardan dolayı hangisinin öncelik alacağını belirleyebilmek bakımından böyledir. Diğer özellik sınama makrolarına ek olarak belirtilen <command>_BSD_SOURCE</command> bir etki oluşturacaktır: POSIX ile çakışan özellikler için BSD özellikleri öncelikli olacaktır.
      </para>
    </sect1>
  </chapter><chapter xml:id="glibc-Roadmap-to-the-Manual">
    <title>Kılavuzun Yol Haritası</title>
    <titleabbrev>Bu kılavuzdaki diğer kısımlarda acaba neler var.</titleabbrev>
    <para/><para>
Bu bölümde bu kılavuzun devamındaki kısımların içeriği hakkında kısaca bilgi verilmiştir.
    </para><itemizedlist><listitem>
<xref linkend="glibc-Error-Reporting"/> kısmında kütüphane tarafından raporlanan  hataların nasıl saptandığı açıklanmıştır.
    </listitem><listitem>
<xref linkend="glibc-Language-Features"/> kısmında C dilinin standart parçaları için kütüphanedeki destek hakkında bilgiler bulunmaktadır. Bunlar,  <command>sizeof</command> işleci, <command>NULL</command> sembolik sabiti gibi şeyler ile argüman sayısı değişken işlevlerin nasıl yazıldığı, sayısal türlerin aralıkları ve çeşitli özellikleri gibi konulardır. Ayrıca kodunuza basit tuzaklar koyarak, sınama sonucuna göre uyarı iletileri alabileceğiniz basit bir hata ayıklama mekanizmasından da bahsedilmiştir.
    </listitem><listitem>
<dicterm><english>dynamically</english><turkish>özdevimli olarak</turkish></dicterm>
<dicterm><english>automatically</english><turkish>özdevinimli olarak</turkish></dicterm>
<xref linkend="glibc-Memory"/> kısmında sanal belleğin özdevimli ayrılması da dahil  sanal ve gerçek belleğin kullanımı ve yönetimi anlatılmıştır. Yazılımınızın baştan  ne kadar belleğe ihtiyacı olacağını bilemiyorsanız belleği gerektikçe özdevimli ayırabilir ve göstericiler üzerinden yönetebilirsiniz.
    </listitem><listitem>
<dicterm><english>string</english><turkish>dizge</turkish></dicterm>
<dicterm><english>string</english><turkish>karakter dizisi</turkish></dicterm>
<dicterm><english>string</english><turkish>boş karakter sonlandırmalı karakter dizisi</turkish></dicterm>
<dicterm><english>array</english><turkish>dizi</turkish></dicterm>
<dicterm><english>null-terminated character arrays</english><turkish>boş karakter sonlandırmalı diziler</turkish></dicterm>
<dicterm><english>case conversion</english><turkish>harf büyüklüğü dönüşümü</turkish></dicterm>
<xref linkend="glibc-Character-Handling"/> kısmı karakter sınıflandırma işlevleri (<function>isspace</function> gibi) ile harf büyüklüğü dönüşümü yapan işlevler hakkında bilgi içerir.
    </listitem><listitem>
<xref linkend="glibc-String-and-Array-Utilities"/> kısmında, dizgeler (boş sonlandırmalı karakter dizileri), genel amaçlı bayt dizileri işlevleri ile  kopyalama ve karşılaştıma gibi amaçlara uygun işlevler hakkında bilgi verilmiştir.
    </listitem><listitem>
<xref linkend="glibc-I-O-Overview"/> kısmı kütüphanedeki girdi ve çıktı oluşumlarına kapsamlı bir bakış ile dosya isimleri gibi genel kavramlar hakkında bilgiler içermektedir.
    </listitem><listitem>
<dicterm><english>stream</english><turkish>akım</turkish></dicterm>
<dicterm><english>I/O</english><turkish>G/Ç</turkish></dicterm>
<xref linkend="glibc-I-O-on-Streams"/> kısmında akımlarla (veya <command>FILE *</command> nesneleri) ilgili giriş/çıkış işlemleri anlatılmıştır. Bunlar <filename>stdio.h</filename> dosyasındaki normal C kütüphanesi işlevleridir.
    </listitem><listitem>
<dicterm><english>file descriptor</english><turkish>dosya tanımlayıcı</turkish></dicterm>
<dicterm><english>directory</english><turkish>dizin</turkish></dicterm>
<dicterm><english>file</english><turkish>dosya</turkish></dicterm>
<dicterm><english>attribute</english><turkish>öznitelik</turkish></dicterm>
<xref linkend="glibc-Low-Level-I-O"/> kısmı dosya tanımlayıcılar üzerindeki  giriş/çıkış işlemleri hakkında bilgi içerir. Dosya tanıtıcılar Unix ailesi işletim  sistemlerine özel bir düşük seviyeli mekanizmadır.
    </listitem><listitem>
<xref linkend="glibc-File-System-Interface"/> kısmında dosyaların silinmesi, isimlerinin değiştirilmesi, yeni dizin oluturulması gibi dosyalar üzerindeki işlemler anlatılmıştır. Bu kısım ayrıca dosyaların sahipleri, dosya koruma kipleri gibi dosya özelliklerine nasıl erişildiği hakkında bilgileri de içerir.
    </listitem><listitem>
<dicterm><english>pipe</english><turkish>boruhattı</turkish></dicterm>
<dicterm><english>stack</english><turkish>yığıt</turkish></dicterm>
<dicterm><english>FIFO (First In First Out)</english><turkish>FIFO (ilk giren ilk çıkar - bir yığıt işlemidir)</turkish></dicterm>
<xref linkend="glibc-Pipes-and-FIFOs"/> kısmı süreçler arası basit iletişim mekanizması hakkında bilgiler içerir. Boruhatları, biri diğerinin çocuğu olan iki süreç arasındaki iletişim için kullanılırken FIFO'lar aynı makine üzerindeki ortak bir dosya sistemi paylaşan süreçler arasındaki iletişim için kullanılır.
    </listitem><listitem>
<dicterm><english>socket</english><turkish>soket</turkish></dicterm>
<dicterm><english>host</english><turkish>konak</turkish></dicterm>
<dicterm><english>network</english><turkish>ağ</turkish></dicterm>
<xref linkend="glibc-Sockets"/> kısmı bir ağ üzerinden haberleşen farklı makineler üzerinde çalışan süreçler arasındaki daha karmaşık bir süreçler arası iletişim mekanizması hakkında bilgiler içerir. Bu kısımda ayrıca internet konak adreslemesi ile sistemin ağ veritabanının nasıl kullanıldığı da anlatılmıştır.
    </listitem><listitem>
<dicterm><english>terminal</english><turkish>uçbirim</turkish></dicterm>
<xref linkend="glibc-Low-Level-Terminal-Interface"/> kısmında bir uçbirim aygıtının özniteliklerini nasıl değiştirebileceğiniz anlatılmıştır. Örneğin bir kullanıcının yazdığı karakterlerin görüntülenmesini engellemek isterseniz bu kısmı okuyun.
    </listitem><listitem>
<dicterm><english>random-number generator</english><turkish>rasgele sayı üreteci</turkish></dicterm>
<dicterm><english>exponential functions</english><turkish>üstel işlevler</turkish></dicterm>
<dicterm><english>remainder functions</english><turkish>kalan işlevleri</turkish></dicterm>
<dicterm><english>floating-point numbers</english><turkish>gerçek sayılar</turkish></dicterm>
<dicterm><english>complex numbers</english><turkish>karmaşık sayılar</turkish></dicterm>
<dicterm><english>integer</english><turkish>tamsayı</turkish></dicterm>
<xref linkend="glibc-Mathematics"/> kısmı matematik işlevleri kütüphanesi  hakkındadır. Gerçek sayılarla trigonometrik veya üstel işlevler, tamsayılarda bölümden kalan işlevleri ve rasgele sayı üreteçleri gibi konulara değinilmiştir.
    </listitem><listitem>
<xref linkend="glibc-Arithmetic"/> kısmında basit aritmetik işlemler, gerçek sayılarla analiz ve dizgelerdeki sayıların okunması için işlevler anlatılmıştır.
    </listitem><listitem>
<xref linkend="glibc-Searching-and-Sorting"/> kısmı, dizilerdeki değerlerin  sıralanması ve aranması için karşılaştırma işlevleri hakkında bilgi içerir.
    </listitem><listitem>
<dicterm><english>shell</english><turkish>kabuk</turkish></dicterm>
<xref linkend="glibc-Pattern-Matching"/> kısmında düzenli ifadeler ve kabuk dosya isim kalıpları ile kabukta olduğu gibi sözcüklerin yorumlanması için işlevlere yer verilmiştir.
    </listitem><listitem>
<dicterm><english>timer</english><turkish>zamanlayıcı</turkish></dicterm>
<dicterm><english>schedule</english><turkish>zaman çizelgesi</turkish></dicterm>
<xref linkend="glibc-Date-and-Time"/> kısmında, takvim ve işlemci zamanının ölçümleri ile zamanlayıcıların ayarlanması ile ilgili işlevler anlatılmıştır.
    </listitem><listitem>
<xref linkend="glibc-Character-Set-Handling"/> kısmında, <command>char</command> veri türü ile ifade edilemeyen karakter kümelerini kullanarak karakterler ve dizgeler üzerinde nasıl işlem yapılacağı açıklanmıştır.
    </listitem><listitem>
<xref linkend="glibc-Locales"/> kısmında, kütüphanenin davranışını etkileyen  ülke ve dil seçimi ile ilgili bilgiler bulunmaktadır.  Örneğin harflerin sırası hangi karakter hangisinin büyüğü ya da küçüğüdür, parasal değerler ve tarih dizgeleri nasıl biçimlenir gibi bilgiler bu kısımdadır.
    </listitem><listitem>
<xref linkend="glibc-Non-Local-Exits"/> kısmında, <function>setjmp</function> ve <function>longjmp</function> işlevleri anlatılmıştır. Bu işlevlerle  <command>goto</command> deyiminin yaptığı gibi bir işlevden diğerine atlamak için kullanılan atlama işlevleridir.
    </listitem><listitem>
<xref linkend="glibc-Signal-Handling"/> kısmı sinyallar hakkındadır. Sinyal nedir, bir sinyal alındığında neler yapılabilir ve yazılımınızın önemli bir bölümü çalışırken alınan sinyallerin engellenmesi gibi bilgiler içerir.
    </listitem><listitem>
<dicterm><english>program</english><turkish>yazılım</turkish></dicterm>
<dicterm><english>program</english><turkish>uygulama</turkish></dicterm>
<dicterm><english>programming</english><turkish>yazılım geliştirme</turkish></dicterm>
<dicterm><english>command-line</english><turkish>komut satırı</turkish></dicterm>
<dicterm><english>environment variables</english><turkish>ortam değişkenleri</turkish></dicterm>
<xref linkend="glibc-Program-Basics"/> kısmında yazılımınızın komut satırı seçeneklerine ve ortam değişkenlerine nasıl erişebileceğiniz anlatılmıştır.
    </listitem><listitem>
<xref linkend="glibc-Processes"/> kısmı,  yeni süreçlerin başlatılması ve uygulamaların çalıştırılması hakkında bilgi içerir.
    </listitem><listitem>
<dicterm><english>job control</english><turkish>iş denetimi</turkish></dicterm>
<dicterm><english>hardware</english><turkish>hırdavat</turkish></dicterm>
<dicterm><english>hardware</english><turkish>donanım</turkish></dicterm>
<xref linkend="glibc-Job-Control"/> kısmında, uçbirimin denetimi ve süreç grupları üzerindeki işlemler için işlevler açıklanmıştır. Bu işlevler, kabuk yazmakla ilgileniyorsanız özellikle iş denetimi konusundadır.
    </listitem><listitem>
<xref linkend="glibc-Name-Service-Switch"/> kısmı, sistem veritabanındaki isimlerde arama, hangi veritabanı için hangi hizmetin kullanıldığının saptanması ve bu hizmetlerin nasıl gerçekleştirildiği gibi bilgiler içerir. Böylece kendi hizmet yordamlarınızı oluşturabilirsiniz.
    </listitem><listitem>
<xref linkend="glibc-User-Database"/> ve <xref linkend="glibc-Group-Database"/>, kısımlarında kullanıcı ve grup veritabanlarına nasıl erişebileceğiniz anlatılmıştır.
    </listitem><listitem>
<xref linkend="glibc-System-Management"/> kısmında, yazılımınızın altında çalıştığı donanım ve yazılımlar hakkındaki bilgilerin alınması ve denetimini sağlayan işlevler anlatılmıştır.
    </listitem><listitem>
<xref linkend="glibc-System-Configuration"/> kısmında, çeşitli işletim sistemlerinin sınırları hakkında nasıl bilgi edinileceği anlatılmıştır. Bu parametrelerin çoğu POSIX ile uyumluluk içindir.
    </listitem><listitem>
<xref linkend="glibc-Library-Summary"/> kısmında kütüphanenin içerdiği tüm işlevler, değişkenler ve makrolar ile veri türleri ve işlev prototipleri hakkında bunların hangi standarda uyumlu olduğu ve hangi sistemden türetildiği gibi bilgiler özet halinde verilmiştir.
    </listitem><listitem>
<xref linkend="glibc-Maintenance"/> kısmında,  GNU C kütüphanesinin sisteminize kurulması açıklanmıştır. Ayrıca bulduğunuz hataların nasıl raporlanacağı, yeni bir sisteme kütüphanenin nasıl taşınacağı, kütüphaneye yeni işlevlerin nasıl ekleneceği gibi bilgilere de yer verilmiştir.
    </listitem></itemizedlist><para>
Kullanmak istediğiniz kütüphane oluşumunun ismini biliyorsanız doğrudan <xref linkend="glibc-Library-Summary"/> kısmına bakın. Bu kısım oluşum hakkında özet bir bilgi verdiği gibi oluşum hakkında daha ayrıntılı bilgiyi nerede bulabileceğiniz bilgisini de içerir. Bu ek bölüm ayrıca, örneğin, bir işlevin argümanlarının türleri ve sırasını bilmek istediğinizde faydalıdır. Ayrıca her işlev, değişken veya makronun türetildiği sistem veya standardın ne olduğunu da bu kısımdan öğrenebilirsiniz.
    </para>
  </chapter>
</part>
