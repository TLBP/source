<?xml version="1.0" encoding="UTF-8"?>

<!-- ********************************************************************
     $Id: ch10.xml,v 1.2 2002/12/20 22:29:48 nilgun Exp $
******************************************************************** -->
<part xml:id="glibc-Pattern-Matching">
  <title>Şablon Eşleme</title>
  <titleabbrev>Kabuk yorumları ve düzenli ifadeler.</titleabbrev>
  <partintro><para>
GNU C kütüphanesi iki çeşit kalıp için şablon eşleme oluşumu içerir: Düzenli ifadeler ve dosya isimleri için özel kalıplar. Kütüphane ayrıca, kabuğun yaptığı değişken yorumlama, komut kullanımı ve metnin sözcüklere ayrılması için oluşumlar da içerir.
  </para><para>
Kabuk yorumları ile ilgili daha ayrıntılı bilgi için <xref linkend="bashref"/> kitabına bakabilirsiniz.
  </para><para>
Düzenli ifadeler ile ilgili daha ayrıntılı bilgi için <xref linkend="regexinfo"/> kitabına bakabilirsiniz.
  </para></partintro>
  <chapter xml:id="glibc-Wildcard-Matching">
    <title>Dosya İsmi Kalıpları</title>
    <titleabbrev>Bir dizgenin bir kalıp ile eşleşmesi.</titleabbrev>
    <para>
<indexterm scope="glibc-pg"><primary>fnmatch.h</primary></indexterm>
Bu bölümde belli bir dizgenin bir kalıp ile nasıl eşleştirildiği anlatılacaktır. Sonuç bir evet ya da hayır yanıtıdır: Dizge bir kalıpla ya eşleşir ya da eşleşmez.
Bu bölümde bahsedilen sembollerin hepsi <filename>fnmatch.h</filename> başlık dosyasında bildirilmiştir.
   </para><para xml:id="glibc-fnmatch">
<indexterm scope="glibc-fn"><primary>fnmatch</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>fnmatch</command></funcdef>
<paramdef>(const char *<varname>kalıp</varname>,
 const char *<varname>dizge</varname>,
 int         <varname>seçenekler</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev <varname>dizge</varname> dizgesi ile <varname>kalıp</varname> kalıbının eşleşip eşleşmediğine bakar. Eğer eşleşiyorlarsa <command>0</command> ile döner, aksi takdirde sıfırdan farklı <command>FNM_NOMATCH</command> değeri ile döner. <varname>kalıp</varname> ve <varname>dizge</varname> argümanlarının her ikisi de dizgedir.
   </para><para>
<varname>seçenekler</varname> ile eşleşme ile ilgili ayrıntıları değiştiren seçenek bitleri belirtilir. Belirtilebilecek seçeneklerin listesi için aşağıya bakınız.
    </para><para>
GNU C Kütüphanesinde, <command>fnmatch</command> işlevinin hata deneyimi yoktur. Daima eşleşme olup olmadığına ilişkin bir yanıt döndürür. Ancak, işlevin diğer gerçeklenimleri kimi zaman hata raporlayabilir. Bu durumda dönen değerleri <command>FNM_NOMATCH</command> değerinden farklı olacaktır.
      </para><para>
<varname>seçenekler</varname> argümanında belirtilebilecek seçenekler:
   </para><para><variablelist><varlistentry>
   <term><literal>FNM_FILE_NAME</literal></term><listitem><para>
<command>/</command> karakteri dosya isimlerinde özel olarak ele alınır. Bu seçenek etkinse, <varname>kalıp</varname>, <varname>dizge</varname> içindeki <command>/</command> karakteri ile eşleşemez. Eşleştirmenin tek yolu <varname>kalıp</varname> dizgesinin <command>/</command> karakterini içermesidir.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>FNM_PATHNAME</literal></term><listitem><para>
Bu POSIX.2 ile gelen bir <command>FNM_FILE_NAME</command> takma ismidir. Biz dosya ismi yerine dosya yolu demediğimizden bu ismin kullanımını önermiyoruz.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>FNM_PERIOD</literal></term><listitem><para>
<command>.</command> karakteri dosya isimlerinin başında ise özel olarak ele alınır. Bu seçenek etkinse ve <command>.</command> karakteri <varname>dizge</varname> dizgesinin ilk karakteri ise <varname>kalıp</varname> ile eşleşemez.
      </para><para>
<command>FNM_PERIOD</command> ve <command>FNM_FILE_NAME</command> birlikte belirtilmişse, <command>.</command> karakterinin <varname>dizge</varname> dizgesinin başında olmasının yanında <command>/</command> karakterini izlediği durumda da eşleşme seğlanır. (Kabuk <command>FNM_PERIOD</command> ve <command>FNM_FILE_NAME</command> seçeneklerini dosya isimleriyle eşleşme ararken birlikte kullanır.)
      </para></listitem></varlistentry><varlistentry>
      <term><literal>FNM_NOESCAPE</literal></term><listitem><para>
<command>\</command> karakteri kalıplarda özel olarak ele alınmaz. Normalde, <command>\</command> kendinden sonraki karakteri önceler; bu seçenek etkinse bu özellik kapatılır, böylece sadece kendisiyle eşleşebilir. Önceleme etkin olduğunda, <command>\?</command> kalıbı sadece <command>?</command> karakteri ile eşleşir, çünkü kalıp içindeki soru işareti sıradan bir karakter gibi işlem görür.
      </para><para>
Eğer <command>FNM_NOESCAPE</command> seçeneği etkinse, <command>\</command> bir sıradan karakterdir.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>FNM_LEADING_DIR</literal></term><listitem><para>
<varname>dizge</varname> içinde <command>/</command> karakterini izleyen karakterler yoksayır; başka bir deyişle <varname>kalıp</varname> dizgesi <varname>dizge</varname> dizisinin başındaki bir dizin ismi mi diye bakılır.
      </para><para>
Bu seçenek etkinse, <command>foo*</command> ya da <command>foobar</command> bir kalıp olarak <command>foobar/frobozz</command> dizgesi ile eşleşir.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>FNM_CASEFOLD</literal></term><listitem><para>
<varname>dizge</varname> ile <varname>kalıp</varname> karşılaştırılırken harf büyüklüğüne bakılmaz.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>FNM_EXTMATCH</literal></term><listitem><para>
<indexterm scope="glibc-cp"><primary>Korn Kabuğu</primary></indexterm>
<indexterm scope="glibc-pg"><primary>ksh</primary></indexterm>
Normal kalıplardan başka <command>ksh</command>'da bahsedilen ek kalıplar da tanınır. Aşağıdaki listedeki <varname>kalıp-listesi</varname>, <command>|</command> karakterinin ayraç olarak kullanıldığı bir kalıp listesidir.
      </para><para>
        <glosslist><glossentry><glossterm>
        <literal>?(<emphasis>kalıp-listesi</emphasis>)</literal>
        </glossterm><glossdef><para>
<varname>kalıp-listesi</varname> ile belirtilen kalıplar girdi dizgesiyle hiç eşleşmeyebilir ya da bir kere eşleşebilir.
         </para></glossdef></glossentry><glossentry><glossterm>
         <literal>*(<emphasis>kalıp-listesi</emphasis>)</literal>
         </glossterm><glossdef><para>
<varname>kalıp-listesi</varname> ile belirtilen kalıplar girdi dizgesiyle hiç eşleşmeyebilir ya da defalarca eşleşebilir.
         </para></glossdef></glossentry><glossentry><glossterm>
         <literal>+(<emphasis>kalıp-listesi</emphasis>)</literal>
         </glossterm><glossdef><para>
<varname>kalıp-listesi</varname> ile belirtilen kalıplar girdi dizgesiyle ya en azından bir kere ya da defalarca eşleşebilir.
         </para></glossdef></glossentry><glossentry><glossterm>
         <literal>@(<emphasis>kalıp-listesi</emphasis>)</literal>
         </glossterm><glossdef><para>
<varname>kalıp-listesi</varname> ile belirtilen kalıplar girdi dizgesiyle sadece bir kere eşleşebilir.
         </para></glossdef></glossentry><glossentry><glossterm>
         <literal>!(<emphasis>kalıp-listesi</emphasis>)</literal>
         </glossterm><glossdef><para>
<varname>kalıp-listesi</varname> ile belirtilen kalıplar girdi dizgesiyle hiç eşleşmiyorsa eşleşme sağlanmış demektir.
         </para></glossdef></glossentry></glosslist>
         </para></listitem></varlistentry></variablelist>
       </para></funcdescr></funcsynopsis>
     </para>
  </chapter>
  <chapter xml:id="glibc-Globbing">
    <title>Genelleme</title>
    <titleabbrev>Bir dosya ismi kalıbı ile eşleşen dosyaların bulunması.</titleabbrev>
    <para>
<indexterm scope="glibc-cp"><primary>genelleme</primary></indexterm>
Kalıpların ana örnek kullanımı bir dizindeki dosyalarda eşleşme aramak ve eşleşenleri listelemektir. Bu işleme <wordasword>genelleme</wordasword> denir.
   </para><para>
Bu işlemi bir dizindeki dosya isimlerini tek tek <command>fnmatch</command> ile sınayarak da yapabilirdiniz ama yavaş olurdu (alt dizinleri de kendiniz okumak zorunda kalacağınız için).
   </para><para>
Kütüphane özellikle bu işi yapan bir işlev içerir: <command>glob</command>.
    </para><para>
<command>glob</command> ve bu kısımdaki diğer semboller <filename>glob.h</filename> başlık dosyasında bildirilmiştir.
   </para><sect1 xml:id="glibc-Calling-Glob">
   <title><literal>glob</literal> çağrısı</title>
   <titleabbrev><command>glob</command> işlevinin temel kullanımı.</titleabbrev>
   <para>
Genelleme işleminin sonucu bir dosya isimleri göstericileri dizisidir. Bu diziyi döndürmek için  <command>glob</command> işlevi aslında bir yapı olan özel bir veri türü, <command>glob_t</command> kullanır.  <command>glob</command> işlevine yapının adresini aktarırsanız, işlev, sonucu yapının alanlarına yazar.
    </para><para xml:id="glibc-glob_t">
<indexterm scope="glibc-tp"><primary>glob_t</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü">
<funcdef><command>glob_t</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu veri türü bir dizge göstericileri dizisine bir gösterici tutar. Daha açıkçası, bu dizinin adresini ve boyutunu kaydeder. GNU gerçeklenimi standartdışı olarak biraz daha fazla alan içerir.
    </para><para><variablelist><varlistentry>
    <term><literal>gl_pathc</literal></term><listitem><para>
Gösterici dizisindeki eleman sayısı; <command>GLOB_DOOFFS</command> seçeneği kullanılmışsa baştaki boş girdiler hariç (aşağıdaki <literal>gl_offs</literal>'a bakınız).
       </para></listitem></varlistentry><varlistentry>
       <term><literal>gl_pathv</literal></term><listitem><para>
Gösterici dizisinin adresi; bu alan <command>char ** </command> türündedir.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>gl_offs</literal></term><listitem><para>
<command>gl_pathv</command> alanındaki adresten itibaren ilk gerçek elemanın konumu. Diğer alanların tersine bu alan <command>glob</command> işlevi için daima bir girdidir (diğer alanları işlev doldurur).
       </para><para>
Eğer konuma sıfırdan farklı bir değer belirtirseniz, gösterici dizisinin başlangıcından itibaren bazı elemanlar boş kalacaktır. (<command>glob</command> işlevi oraları boş göstericilerle doldurur.)
       </para><para>
<command>gl_offs</command> alanı sadece <command>GLOB_DOOFFS</command> seçeneği etkinse anlamlıdır.  Aksi takdirde bu alanın ne içerdiğine bakılmaksızın konumun sıfır olduğu varsayılır, yani ilk eleman gösterici dizisinin başına konur.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>gl_closedir</literal></term><listitem><para>
<command>closedir</command> işlevinin başka bir gerçekleniminin adresi. <command>GLOB_ALTDIRFUNC</command> seçeneği etkinse kullanılır. Bu alan <command>void (*) (void *)</command> türündedir.
       </para><para>Bu alan bir GNU oluşumudur.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>gl_readdir</literal></term><listitem><para>
Bir dizinin içeriğini okumakta kullanılan <command>readdir</command> işlevinin başka bir gerçekleniminin adresi. <command>GLOB_ALTDIRFUNC</command> seçeneği etkinse kullanılır. Bu alan <command>struct dirent *(*) (void *)</command> türündedir.
       </para><para>Bu alan bir GNU oluşumudur.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>gl_opendir</literal></term><listitem><para>
<command>opendir</command>  işlevinin başka bir gerçekleniminin adresi. <command>GLOB_ALTDIRFUNC</command> seçeneği etkinse kullanılır. Bu alan <command>void *(*) (const char *)</command> türündedir.
       </para><para>Bu alan bir GNU oluşumudur.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>gl_stat</literal></term><listitem><para>
Dosya sistemindeki bir nesne hakkında bilgi döndüren <command>stat</command> işlevinin başka bir gerçekleniminin adresi.  <command>GLOB_ALTDIRFUNC</command> seçeneği etkinse kullanılır. Bu alan <command>int (*) (const char *, struct stat *)</command> türündedir.
       </para><para>Bu alan bir GNU oluşumudur.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>gl_lstat</literal></term><listitem><para>
Dosya sistemindeki bir nesne hakkında bilgi döndüren, ancak sembolik bağları izlemeyen <command>lstat</command> işlevinin başka bir gerçekleniminin adresi. <command>GLOB_ALTDIRFUNC</command> seçeneği etkinse kullanılır. Bu alan <command>int (*) (const char *, struct stat *)</command> türündedir.
       </para><para>Bu alan bir GNU oluşumudur.
       </para></listitem></varlistentry></variablelist>
</para></funcdescr></funcsynopsis></para><para>
<command>glob64</command> işlevinde kullanmak üzere <filename>glob.h</filename> başlık dosyası bu türe çok benzer bir başka tanım içerir.  <command>glob64_t</command> türü <command>glob_t</command> türünden sadece  <command>gl_readdir</command>, <command>gl_stat</command> ve <command>gl_lstat</command> elemanlarının farklı türde olması ile farklıdır.
    </para><para xml:id="glibc-glob64_t">
<indexterm scope="glibc-tp"><primary>glob64_t</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü">
<funcdef><command>glob64_t</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu veri türü bir dizge göstercileri dizisine bir gösterici tutar. Daha açıkçası, dizinin adresini ve boyutunu kaydeder. GNU gerçeklenimi standartdışı olarak biraz daha fazla alan içerir.
    </para><para><variablelist><varlistentry>
    <term><literal>gl_pathc</literal></term><listitem><para>
Gösterici dizisindeki eleman sayısı; <command>GLOB_DOOFFS</command> seçeneği kullanılmışsa baştaki boş girdiler hariç (aşağıdaki <command>gl_offs</command>'a bakınız).
       </para></listitem></varlistentry><varlistentry>
       <term><literal>gl_pathv</literal></term><listitem><para>
Gösterici dizisinin adresi; bu alan <command>char ** </command> türündedir.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>gl_offs</literal></term><listitem><para>
<command>gl_pathv</command> alanındaki adresten itibaren ilk gerçek elemanın konumu. Diğer alanların tersine bu alan <command>glob</command> işlevi için daima bir girdidir (diğer alanları işlev doldurur).
       </para><para>
Eğer konuma sıfırdan farklı bir değer belirtirseniz, gösterici dizisinin başlangıcından itibaren bazı elemanlar boş kalacaktır. (<command>glob</command> işlevi oraları boş göstericilerle doldurur.)
       </para><para>
<command>gl_offs</command> alanı sadece <command>GLOB_DOOFFS</command> seçeneği etkinse anlamlıdır.  Aksi takdirde bu alanın ne içerdiğine bakılmaksızın konumun sıfır olduğu varsayılır, yani ilk eleman gösterici dizisinin başına konur.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>gl_closedir</literal></term><listitem><para>
<command>closedir</command> işlevinin başka bir gerçekleniminin adresi. <command>GLOB_ALTDIRFUNC</command> seçeneği etkinse kullanılır. Bu alan <command>void (*) (void *)</command> türündedir.
       </para><para>Bu alan bir GNU oluşumudur.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>gl_readdir</literal></term><listitem><para>
<command>readdir64</command> işlevinin başka bir gerçekleniminin adresi. <command>GLOB_ALTDIRFUNC</command> seçeneği etkinse kullanılır. Bu alan <command>struct dirent64 *(*) (void *)</command> türündedir.
       </para><para>Bu alan bir GNU oluşumudur.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>gl_opendir</literal></term><listitem><para>
<command>opendir</command>  işlevinin başka bir gerçekleniminin adresi. <command>GLOB_ALTDIRFUNC</command> seçeneği etkinse kullanılır. Bu alan <command>void *(*) (const char *)</command> türündedir.
       </para><para>Bu alan bir GNU oluşumudur.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>gl_stat</literal></term><listitem><para>
Dosya sistemindeki bir nesne hakkında bilgi döndüren <command>stat64</command> işlevinin başka bir gerçekleniminin adresi.  <command>GLOB_ALTDIRFUNC</command> seçeneği etkinse kullanılır. Bu alan <command>int (*) (const char *, struct stat64 *)</command> türündedir.
       </para><para>Bu alan bir GNU oluşumudur.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>gl_lstat</literal></term><listitem><para>
Dosya sistemindeki bir nesne hakkında bilgi döndüren, ancak sembolik bağları izlemeyen <command>lstat64</command> işlevinin başka bir gerçekleniminin adresi. <command>GLOB_ALTDIRFUNC</command> seçeneği etkinse kullanılır. Bu alan <command>int (*) (const char *, struct stat64 *)</command> türündedir.
       </para><para>Bu alan bir GNU oluşumudur.
       </para></listitem></varlistentry></variablelist>
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-glob">
<indexterm scope="glibc-fn"><primary>glob</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>glob</command></funcdef>
<paramdef>(const char *<varname>kalıp</varname>,
 int         <varname>seçenekler</varname>,
 int       (*<varname>hata-işlevi</varname>) (const char *<varname>dosyaismi</varname>, int <varname>hatakodu</varname>),
 glob_t     *<varname>dizi-gst</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>glob</command> işlevi <varname>kalıp</varname> kalıbını kullanarak geçerli dizin içinde genelleme yapar. Sonuçları yeni ayırdığı gösterici dizisine yerleştirir ve bu dizinin adresi ile boyutunu  <varname>*dizi-gst</varname> içine koyar.  <varname>seçenekler</varname> argümanı seçenek bitlerinin bir birleşimidir; bu seçenekler hakkında ayrıntılı bilgiyi <xref linkend="glibc-Flags-for-Globbing"/> bölümünde bulabilirsiniz.
    </para><para>
Genellemenin sonucu dosya isimleri dizisidir. <command>glob</command> işlevi her sonuç dizgesi için bir dizge ve bu dizgelerin adreslerini saklamak için <command>char ** </command> türünde bir gösterici dizisi ayırır. Dizinin son elemanı bir boş göstericidir. Bu gösterici dizisine <firstterm>dizge göstericileri dizisi</firstterm> denir.
    </para><para>
Bu diziyi döndürmek için <command>glob</command> adresini ve uzunluğunu (sonlandırıcı boş gösterici dışında dizge gösterici sayısı)  <varname>*dizi-gst</varname> içinde saklar.
    </para><para>
Normalde, <command>glob</command> işlevi dosya isimlerini döndürmeden önce alfabetik sıraya sokar. Bunu <command>GLOB_NOSORT</command> seçeneğini kullanarak yaptırmayabilir ve sonucu daha çabuk alabilirsiniz. Genellikle, sıralamayı  <command>glob</command>'a yaptırmak daha iyidir. Eğer dosyaları alfabetik sırayla görüntülerseniz, kullanıcı işlemin hızının sizin yazılımınızdan kaynaklandığını sanacaktır.
    </para><para>
<command>glob</command> başarılı olursa 0 ile döner.  Aksi takdirde şu hata kodlarından biri ile döner:
    </para><para><variablelist><varlistentry>
    <term><literal>GLOB_ABORTED</literal></term><listitem><para>
Bir dizini açarken bir hata oluştu ya <command>GLOB_ERR</command> seçeneğini kullanmışsınız ya da <varname>hata-işlevi</varname>'nin sıfırdan farklı bir değer döndürmesini sağlamışsınız. <command>GLOB_ERR</command> seçeneği ve <varname>hata-işlevi</varname> ile ilgili açıklamalar için <xref linkend="glibc-Flags-for-Globbing"/> bölümüne bakınız.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>GLOB_NOMATCH</literal></term><listitem><para>
Kalıp mevcut dosyaların hiçbiriyle eşleşmedi. <command>GLOB_NOCHECK</command> seçeneğini belirtirseniz bu hatayı asla almazsınız, çünkü bu seçenek <command>glob</command>'a en azından bir dosya eşleşmiş <emphasis>gibi</emphasis> davranmasını söyler.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>GLOB_NOSPACE</literal></term><listitem><para>
Sonuçlar için ayrılacak bellek yok.
       </para></listitem></varlistentry></variablelist>
</para></funcdescr></funcsynopsis></para><para>
Bir hata sırasında, <command>glob</command> o ana kadar bulduğu tüm sonuçlara ilişkin bilgiyi <varname>*dizi-gst</varname> ile döndürür.
    </para><para>
<important><para><command>glob</command> işlevi LFS arayüzleri olmaksızın elde edilemeyen dizin ya da dosyalar saptarsa başarısız olmaz. <command>glob</command>  bu işlevlerin dahili olarak kullanılacağı kabulüyle gerçeklenmiştir. Bu en azından Unix standardında yapılmış bir kabullerden biridir. GNU oluşumu kullanıcıya kendi dizin elde etme yöntemini sağlayarak ve <command>stat</command> işlevleriyle bunu biraz daha karmaşıklaştırır. Eğer bunlar kullanıcı tanımlı işlevler olsalardı büyük bir dosyaya ya da dizine rastlandığında <command>glob</command> başarısız <emphasis>olabilecekti</emphasis>.</para></important>
    </para><para xml:id="glibc-glob64">
<indexterm scope="glibc-fn"><primary>glob64</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>glob64</command></funcdef>
<paramdef>(const char *<varname>kalıp</varname>,
 int         <varname>seçenekler</varname>,
 int       (*<varname>hata-işlevi</varname>) (const char *<varname>dosyaismi</varname>, int <varname>hatakodu</varname>),
 glob64_t   *<varname>dizi-gst</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>glob64</command> işlevi büyük dosya arayüzünün parçası olarak eklenmiştir, ancak kullanılan arayüz orjinal LFS arayüzü değildir. Bunun sebebi basittir: Gereksizdir.  <command>glob64</command> işlevi için gerekli olan herşey GNU oluşumunun kullanıcıya kendi dizin elde etme yöntemini sağlaması ve <command>stat</command> işlevleriyle eklenmiştir. <command>struct dirent</command> ve <command>struct stat</command> veri türleri <command>_FILE_OFFSET_BITS</command> seçimine bağlı olduğundan <command>readdir</command> ve <command>stat</command> işlevleri bu seçime bağlı olarak çalışır.
    </para><para>
Bu farkların dışında <command>glob64</command> tamamen <command>glob</command> gibi çalışır.
    </para><para>Bu işlev bir GNU oluşumudur.
       </para></funcdescr></funcsynopsis></para>
     </sect1><sect1 xml:id="glibc-Flags-for-Globbing">
       <title>Genelleme Seçenekleri</title>
       <titleabbrev><command>glob</command> işlevinin davranışını etkileyen seçenekler.</titleabbrev>
       <para>
Bu bölümde <command>glob</command> işlevinin <varname>seçenekler</varname> argümanında belirtilebilecek seçenekler açıklanmıştır. Seçtiğiniz seçenekleri C'nin bit seviyesi VEYA işleci olan <command>|</command> işlecini kullanarak birlikte belirtebilirsiniz.
    </para><para><variablelist><varlistentry>
    <term><command>GLOB_APPEND</command></term><listitem><para>
Önceki bir <command>glob</command> çağrısı ile üretilen dizge göstericileri dizisine bu genişletmeden dizgeler eklenir. İşlem bir dizgeye aralarında boşluklar bırakarak yeni sözcükler eklenmesi gibidir.
       </para><para>
Ekleme işlemi sırasında, <command>glob</command> çağrısından önce dizge göstericileri dizisine ilişkin bilgileri içeren yapının içeriğinde değişiklik yapmamalısınız. Eğer ilk çağrıda <command>GLOB_DOOFFS</command> seçeneğini kullanmışsanız, ekleme amacıyla yaptığınız çağrıda da bu seçeneği kullanmalısınız.
       </para><para>
Yapının <command>gl_pathv</command> üyesindeki gösterici ikinci <command>glob</command> çağrısından sonra artık geçerli olmayacaktır, çünkü <command>glob</command> işlevi diziyi yeniden ayırır. Böylece her <command>glob</command> çağrısından sonra <command>glob_t</command> yapısının <command>gl_pathv</command> üyesinden doğru gösterici elde edilir; çağrılar arasında gösterici asla saklanmamalıdır.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>GLOB_DOOFFS</literal></term><listitem><para>
Gösterici dizisinin başlangıcında boş göstericiler bırakır. <command>gl_offs</command> alanında bunun sayısı belirtilir.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>GLOB_ERR</literal></term><listitem><para>
Eğer <varname>kalıp</varname>'ın eşleştirilmesi sırasında okunması gereken dizinlerin okunmasında zorluk varsa, bir hata raporlanır ve hemen çıkılır. Okunmak istenen dizinin erişim izinlerinin yetersizliği bu zorluklardan biridir.
       </para><para>
<command>glob</command> çağrısında hataları elde edebilen bir <varname>hata-işlevi</varname> belirterek bu hatalar üzerinde daha fazla denetim sağlayabilirsiniz. <varname>hata-işlevi</varname> olarak bir boş gösterici belirtmemişseniz, <command>glob</command> bir dizini okuyamadığında hemen çıkmaz, iki argümanla şuna benzer biçimde <varname>hata-işlevi</varname> işlevini çağırır:
       </para><para>
<literallayout>
(*<varname>hata-işlevi</varname>) (<varname>dosyaismi</varname>, <varname>hatakodu</varname>)
</literallayout></para><para>
<varname>dosyaismi</varname> argümanı <command>glob</command> işlevinin açamadığı ya da okuyamadığı dizinin ismidir, <varname>hatakodu</varname> ise <command>glob</command> tarafından raporlanan <command>errno</command> değeridir.
       </para><para>
Hata eylemci işlev sıfırdan farklı bir değerle dönerse <command>glob</command> hemen döner, aksi takdirde işleme devam eder.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>GLOB_MARK</literal></term><listitem><para>
Kalıp dizin ismiyle eşleşirse, dizin ismi döndürülürken ismine <command>/</command> eklenir.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>GLOB_NOCHECK</literal></term><listitem><para>
Eğer kalıp hiçbir dosya ismiyle eşleşmezse, işlev sanki bir eşleşme bulunmuş gibi döner. (Normalde, kalıp hiçbirşeyle eşleşmemişse <command>glob</command> eşleşme bulunmadığını belirtecek şekilde döner.)
       </para></listitem></varlistentry><varlistentry>
       <term><literal>GLOB_NOSORT</literal></term><listitem><para>
Dosya isimleri alfabetik olarak sıralanmaz; okundukları sırada döndürülürler. (Pratikte sıralama, dosyaların dizine giriş sırasına bağlıdır.) Sıralama yapılmak istenmemesinin tek sebebi zaman kazanmak olabilir.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>GLOB_NOESCAPE</literal></term><listitem><para>
Kalıpta <command>\</command> karakteri özel olarak değil kendisi olarak ele alınır. Normalde, <command>\</command> başka bir karakteri öncelemek için kullanılır. Bu seçenek bu şekilde yorumlanmasını engeller. Önceleme etkinse, <command>\?</command> kalıbı sadece <command>?</command> dizgesiyle eşleşir, çünkü bu biçimde belirtilen soru işareti kalıpta sıradan bir karakter olarak işlem görür.
       </para><para>
<command>GLOB_NOESCAPE</command> seçeneği etkinse,<command>\</command> bir sıradan karakterdir.
       </para><para>
<command>glob</command> işlevi <command>fnmatch</command> işlevini defalarca çağırarak çalışır.  <command>GLOB_NOESCAPE</command> seçeneğini <command>fnmatch</command> çağrılarında <command>FNM_NOESCAPE</command> seçeneğini etkinleştirmek için kullanır.
       </para></listitem></varlistentry></variablelist></para></sect1>
     <sect1 xml:id="glibc-More-Flags-for-Globbing">
       <title>Diğer Genelleme Seçenekleri</title>
       <titleabbrev>GNU <command>glob</command> seçenekleri.</titleabbrev>
       <para>
Önceki bölümde açıklanan seçeneklerin yanında <command>glob</command> işlevinin GNU gerçeklemesinde geçerli başka seçenekler de vardır. Bu seçenekler <filename>glob.h</filename> başlık dosyasında tanımlanmıştır.  Bu seçeneklerin bazıları günümüzdeki kabuk gerçeklenimlerinde kullanılan işlevselliği sağlar.
    </para><para><variablelist><varlistentry>
    <term><literal>GLOB_PERIOD</literal></term><listitem><para>
<command>.</command> (nokta) karakteri özel karakter olarak ele alınır. Bu durumda özel kalıp karakteri olarak eşleştirilmez. <xref linkend="glibc-Wildcard-Matching"/> bölümündeki <command>FNM_PERIOD</command> seçeneğine de bakınız.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>GLOB_MAGCHAR</literal></term><listitem><para>
<command>GLOB_MAGCHAR</command> seçeneği <command>glob</command> işlevinin <varname>seçenekler</varname> parametresinde kullanmak için değildir.  <command>glob</command> işlevi bu seçeneği, eğer kalıp, özel kalıp karakterleri içeriyorsa sonucun bu yolla elde edileceğini belirtmek için <command>glob_t</command> yapısının <varname>gl_flags</varname> üyesinde kullanır.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>GLOB_ALTDIRFUNC</literal></term><listitem><para>
Bu seçenek etkinse, <command>glob</command> gerçeklemesi dosya sistemine erişmek için kütüphanedeki işlevleri değil, kullanıcı tarafından <varname>dizi-gst</varname> ile gösterilen yapı içinde belirtilen işlevleri kullanır. Dizinlere erişim için kullanılan işlevler <xref linkend="glibc-Accessing-Directories"/> ve <xref linkend="glibc-Reading-Attributes"/> bölümlerinde açıklanmıştır.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>GLOB_BRACE</literal></term><listitem><para>
Bu seçenek etkinse kaşlı ayraçlar özel olarak ele alınır. Bu durumda kaşlı ayraçların doğru gruplanması gerekir. Yani kaşlı ayraçlar çiftler halinde olmalıdır. İç içe gruplamalar yapılabilir. Böylece bir gruplama bir diğerini tanımlamakta kullanılabilir. Bir kaşlı ayraç ifadesi, başka bir kaşlı ayraç ifadesinin içinde tanımlanmışsa onun dışına çıkmaması gerektiğine dikkat etmelisiniz.
       </para><para>
Bir kaşlı ayraç grubundaki dizgeler, virgüllerle ayrılarak ayrı ifadeler haline getirilebilir. Bu durumda virgüllerin bu amaçla kullanıldıkları ve dizgelerin virgül içermedikleri varsayılır. Virgül kullanılarak ayrılan ifadeler aynı seviyede olmalıdır. Alt ifadeler kaşlı ayraç içine alınmışsa bunların içindeki virgüller eşleştirilmez.  Kaşlı ayraçlı alt gruplarda daha derin seviyeleri elde etmede kullanılır. Bir kullanım örneği:
       </para><para>
<screen>glob (&quot;{foo/{,bar,biz},baz}&quot;, GLOB_BRACE, NULL, &amp;result)
</screen></para><para>
Eğer hataları gözönüne almazsak, şuna eşdeğerdir:
       </para><para>
<screen>
glob (&quot;foo/&quot;, GLOB_BRACE, NULL, result)
glob (&quot;foo/bar&quot;, GLOB_BRACE|GLOB_APPEND, NULL, &amp;result)
glob (&quot;foo/biz&quot;, GLOB_BRACE|GLOB_APPEND, NULL, &amp;result)
glob (&quot;baz&quot;, GLOB_BRACE|GLOB_APPEND, NULL, &amp;result)
</screen></para></listitem></varlistentry><varlistentry>
       <term><literal>GLOB_NOMAGIC</literal></term><listitem><para>
Eğer kalıp herhangi bir özel kalıp karakteri içermiyorsa (doğrudan dosya ismi verilmişse), bu isimde bir dosya yoksa bile bu kalıp dizgesi döndürülür.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>GLOB_TILDE</literal></term><listitem><para>
Bu seçenek etkinse ve kalıp yaklaşık işareti (<command>~</command>) ile başlıyorsa, bu karakter özel olarak ele alınır. Bu durumda yaklaşık işaretinin bir kullanıcının ev dizinini gösterdiği varsayılır.
       </para><para>
Eğer <command>~</command> kalıptaki tek karakterse ya da onu bir <command>/</command> (bölü çizgisi) izliyorsa, bu kalıp sürecin sahibinin ev dizini ile eşleştirilir. Bilgi, <command>getlogin</command> ve <command>getpwnam</command> işlevleri kullanılarak sistem veritabanlarından okunur. Örneğin, ev dizini <filename>/home/bart</filename> olan  <command>bart</command> kullanıcısı için çağrı şöyle olurdu:
       </para><para>
<screen>
glob (&quot;~/bin/*&quot;, GLOB_TILDE, NULL, &amp;result)
</screen></para><para>
Bu çağrıdan <filename>/home/bart/bin</filename> döner. Burada başka bir kullanıcının ev dizini de belirtilebilirdi. Bunun için yaklaşık işaretinden sonra kullanıcının ismini belirtmek yeterlidir. <command>homer</command>'in <filename>bin</filename> dizinini almak istersek:
       </para><para>
<screen>
glob (&quot;~homer/bin/*&quot;, GLOB_TILDE, NULL, &amp;result)
</screen></para><para>
Eğer kullanıcı ismi geçersizse ya da ev dizini bir nedenle saptanamamışsa kalıba dokunulmaksızın kalıp dizgesi sonuç olarak döndürülür. Son örnekte, <command>homer</command> isminde bir kullanıcı yoksa işlev <filename>~homer</filename> dizinini aramaz ve sonuç olarak <command>&quot;~homer/bin/*&quot;</command> dizgesini döndürür.
       </para><para>
Bu işlevsellik C kabuklarında <command>nonomatch</command> seçeneğinin etkin olduğu duruma eşdeğerdir.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>GLOB_TILDE_CHECK</literal></term><listitem><para>
Bu seçenek belirtilmişse <command>glob</command> işlevi <command>GLOB_TILDE</command> seçeneği verilmiş gibi davranır. Tek fark, belirtilen kullanıcı yoksa ya da bir ev dizini saptanamamışsa kalıp dizgesi döndürülmez ve işlem bir hata ile sonuçlanır.
       </para><para>
Bu işlevsellik C kabuklarında <command>nonomatch</command> seçeneğinin etkin olmadığı duruma eşdeğerdir.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>GLOB_ONLYDIR</literal></term><listitem><para>
Bu seçenek belirtilmişse, bu, çağrıcının sadece kalıpla eşleşen dizinle ilgilendiğine dair bir <emphasis>ipucu</emphasis> olarak değerlendirilir. Eğer dosya hakkında saptanan bilgi onun bir dizin olmadığını belirtiyorsa bunlar reddedilir ama bunların türünü saptamak için ek bir çalışma yapılmaz. Yani çağrıcı hala bir süzme çalışması yapabilir.
       </para><para>
Bu işlevsellik sadece GNU <command>glob</command> gerçeklemesi ile kullanılabilir. Aslında dahili kullanım için düşünülmüşse de kullanıcı için de yararlı olabileceğinden burada belgelenmiştir.
       </para></listitem></varlistentry></variablelist></para><para>
<command>glob</command> çağrısı çoğu durumda döndürdüğü sonucu saklamak için özkaynak ayırır. <command>glob</command> işlevi hep aynı <command>glob_t</command> nesnesi ile çağrılsa bile her çağrıda özkaynaklar önce serbest bırakılıp sonra tekrar ayrıldığından bir kaçak oluşmaz. Fakat bu işlem her çağrıda hep aynı süre içinde olmaz.
    </para><para xml:id="glibc-globfree">
<indexterm scope="glibc-fn"><primary>globfree</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>void <command>globfree</command></funcdef>
<paramdef>(glob_t *<varname>dizi-gst</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>globfree</command> işlevi önceki <command>glob</command> çağrılarında <varname>dizi-gst</varname> ile gösterilen nesne için ayrılan yeri serbest bırakır. Bu <command>glob_t</command> türündeki nesne artık kullanılmayacaksa bu işlev çağrılarak bu alan serbest bırakılmalıdır.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-globfree64">
<indexterm scope="glibc-fn"><primary>globfree64</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>void <command>globfree64</command></funcdef>
<paramdef>(glob64_t *<varname>dizi-gst</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev <command>globfree</command> işlevinin benzeridir, farklı olarak <command>glob64</command> işlevi ile ayrılan bir <command>glob64_t</command> nesnesini serbest bırakmak için kullanılır.
</para></funcdescr></funcsynopsis></para></sect1>
  </chapter>
  <chapter xml:id="glibc-Regular-Expressions">
    <title>Düzenli İfade Eşleştirme</title>
    <titleabbrev>Düzenli ifadelerin dizgelerle eşleştirilmesi.</titleabbrev>
    <para>
GNU C kütüphanesi düzenli ifade eşleştirmesi için iki arayüz içerir. Biri standart POSIX.2 arayüzü diğeri ise yıllardır GNU sistemlerinde kullanılan arayüzdür.
   </para><para>
Her iki arayüz de <filename>regex.h</filename> başlık dosyasında bildirilmiştir. Eğer <command>_POSIX_C_SOURCE</command> makrosunu tanımlarsanız, sadece POSIX.2 işlevleri, yapıları ve sabitleri bildirilir.
   </para><para>
Düzenli ifadeler ile ilgili daha ayrıntılı bilgi için <xref linkend="regexinfo"/> kitabına bakabilirsiniz.
   </para><sect1 xml:id="glibc-POSIX-Regexp-Compilation">
   <title>POSIX Düzenli İfadelerinin Derlenmesi</title>
   <titleabbrev>Eşlemeye hazırlamak için <command>regcomp</command> kullanımı.</titleabbrev>
   <para>
Bir düzenli ifadeyi eşleştirme amacıyla kulanmadan önce onu <emphasis>derlemeniz</emphasis> gerekir. Bu tam anlamıyla bir derleme işlemi değildir. Derleme sonucunda bir takım makine kodları değil, özel bir veri yapısı üretilir. Fakat derlemenin amacı aynı kalır, amaç daha hızlı işlem yapmaktır. (Derlenmiş düzenli ifadelerin nasıl eşleştirildiği <xref linkend="glibc-Matching-POSIX-Regexps"/> bölümünde anlatılmıştır.)
    </para><para>
Derlenmiş düzenli ifadeler için özel bir veri türü vardır:
    </para><para xml:id="glibc-regex_t">
<indexterm scope="glibc-tp"><primary>regex_t</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü">
<funcdef><command>regex_t</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bir derlenmiş düzenli ifadeyi barındıran nesnenin türüdür. Aslında bir yapıdır. Sadece bir üyesinden bahsedeceğiz:
    </para><para><variablelist><varlistentry>
    <term><literal>re_nsub</literal></term><listitem><para>
Derlenmiş düzenli ifade içindeki parantezli alt ifadelerin sayısını belirtir.
       </para></listitem></varlistentry></variablelist>
     </para><para>
Yapının başka alanları da vardır, sadece kütüphane içindeki işlevler tarafından kullanıldığından onlardan burada bahsetmeyeceğiz.
</para></funcdescr></funcsynopsis></para><para>
Bir <command>regex_t</command> nesnesini oluşturduktan sonra bir düzenli ifadeyi bir <command>regcomp</command> çağrısı ile derlemelisiniz.
    </para><para xml:id="glibc-regcomp">
<indexterm scope="glibc-fn"><primary>regcomp</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>regcomp</command></funcdef>
<paramdef>(regex_t *restrict    <varname>şablon</varname>,
 const char *restrict <varname>düzenli_ifade</varname>,
 int                  <varname>derleme-seçenekleri</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>regcomp</command> işlevi, bir dizgeyle eşleştirmek üzere <command>regexec</command> işlevinde kullanmak için bir düzenli ifadeyi bir veri yapısına derler. Derlenmiş düzenli ifadenin biçimi verimli bir eşleştirmeyi mümkün kılacak şekilde tasarlanmıştır. Derlenen düzenli ifadeyi işlev <varname>*şablon</varname> nesnesine yerleştirir.
    </para><para>
<command>regex_t</command> türünde bir nesne ayırıp bunun adresini <command>regcomp</command> işlevine aktarmalısınız.
    </para><para>
<varname>derleme-seçenekleri</varname> argümanı düzenli ifadelerin sözdizimini ve anlamsal bütünlüğünü denetleyen bazı seçenekleri belirtmek için kullanılır. Bkz. <xref linkend="glibc-Flags-for-POSIX-Regexps"/>.
    </para><para>
<command>REG_NOSUB</command> seçeneği belirtilmişse, <command>regcomp</command> işlevi derlenen düzenli ifadeye alt ifadelerin nasıl eşleştirileceği bilgisini yerleştirmez. Bu durumda,  <command>regexec</command> çağrısında <varname>eşleşenler</varname> ve <varname>eşleşen-sayısı</varname> argümanlarına  <command>0</command> değerini aktarmalısınız.
    </para><para>
Eğer <command>REG_NOSUB</command> seçeneğini belirtmezseniz, derlenen düzenli ifade alt ifadelerin nasıl eşleştirileceği bilgisini de içerir. Ayrıca,  <command>regcomp</command> işlevi <varname>şablon</varname>'un kaç alt ifade içerdiğini <varname>şablon</varname><literal>->re_nsub</literal> üyesine yazar. Bu bilgiyi alt ifade eşleştirmesinde tutulacak bilgi için ayrılacak dizinin uzunluğuna karar vermek için kullanabilirsiniz.
    </para><para>
<command>regcomp</command> işlevi düzenli ifadeyi başarıyla derleyebilmişse <command>0</command> ile döner; aksi takdirde, sıfırdan farklı bir hata kodu ile döner (aşağıya bakınız). Dönen hata kodundan hata dizgesini üretmek için  <command>regerror</command> işlevini kullanabilirsiniz; bkz. <xref linkend="glibc-Regexp-Cleanup"/>.
    </para><para>
<command>regcomp</command> işlevinin döndürdüğü sıfırdan farklı değerler:
    </para><para><variablelist><varlistentry>
    <term><literal>REG_BADBR</literal></term><listitem><para>
Düzenli ifade içinde geçersiz bir <command>\{…\}</command> yapısı vardır. Geçerli bir <command>\{…\}</command> yapısı ya tek bir sayı ya da virgülle ayrılmış iki sayı içermelidir.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>REG_BADPAT</literal></term><listitem><para>
Düzenli ifade içinde bir sözdizimi hatası var.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>REG_BADRPT</literal></term><listitem><para>
<command>?</command> veya <command>*</command> gibi yineleme işleçleri yanlış yerde (bu işleçlerden önce üzerinde işlem yapılacak bir alt ifade olmalıdır).
       </para></listitem></varlistentry><varlistentry>
       <term><literal>REG_ECOLLATE</literal></term><listitem><para>
Düzenli ifade geçersiz bir karakter karşılaştırma elemanı içeriyor (geçerli yerelde tanımlı olanlardan biri değil). Bkz.  <xref linkend="glibc-Locale-Categories"/>.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>REG_ECTYPE</literal></term><listitem><para>
Düzenli ifade geçersiz bir karakter sınıfı ismi içeriyor.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>REG_EESCAPE</literal></term><listitem><para>
Düzenli ifade <command>\</command> ile bitiyor.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>REG_ESUBREG</literal></term><listitem><para>
Geçersiz sayıda <command>\<varname>rakam</varname></command> yapısı var.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>REG_EBRACK</literal></term><listitem><para>
Düzenli ifade gruplanmamış köşeli ayraçlar içeriyor.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>REG_EPAREN</literal></term><listitem><para>
Düzenli ifade gruplanmamış parantezler içeriyor ya da <command>\(</command> ve <command>\)</command> arasında olması gereken bir temel düzenli ifadenin sarmalayıcılarından biri eksik.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>REG_EBRACE</literal></term><listitem><para>
Düzenli ifadede <command>\{</command> ve <command>\}</command> sarmalayıcılardan biri eksik.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>REG_ERANGE</literal></term><listitem><para>
Bir aralık ifadesindeki sonlandırıcılardan biri geçersiz.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>REG_ESPACE</literal></term>
       <listitem><para><command>regcomp</command> için bellek yetersiz.
       </para></listitem></varlistentry></variablelist></para>
     </funcdescr></funcsynopsis></para></sect1>
    <sect1 xml:id="glibc-Flags-for-POSIX-Regexps">
      <title>POSIX Düzenli İfade Seçenekleri</title>
      <titleabbrev><literal>regcomp</literal> için sözdizimi çeşitleri.</titleabbrev>
      <para>
Bunlar bir düzenli ifadeyi <command>regcomp</command> ile derlerken <varname>derleme-seçenekleri</varname> argümanında belirtilebilecek bit değerli seçeneklerdir.
    </para><para><variablelist><varlistentry>
    <term><literal>REG_EXTENDED</literal></term><listitem><para>
Şablon temel bir düzenli ifadenin değil, gelişmiş bir düzenli ifadenin karşılığı olarak oluşturulur.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>REG_ICASE</literal></term><listitem><para>
Harfler eşleştirilirken harf büyüklüğüne bakılmaz.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>REG_NOSUB</literal></term><listitem><para>
<varname>eşleşenler</varname> dizisinin içeriği için birşey yapılmaz.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>REG_NEWLINE</literal></term><listitem><para>
<varname>dizge</varname> içindeki satırsonu karakterleri dizgeyi satırlara bölmek için kullanılır. Böylece bir satırsonu karakterinden önceki bir <command>$</command> karakteri ve satırsonu karakterinden sonraki bir <command>^</command> karakteri eşleştirilebilir. Ayrıca, <command>.</command> (nokta) veya <command>[^…]</command> ifadesinin bir satırsonu karakteri ile eşleşmesine izin verilmez.
       </para><para>
Aksi takdirde satırsonu karakteri sıradan bir karakter olarak işlem görür.
       </para></listitem></varlistentry></variablelist></para></sect1>
    <sect1 xml:id="glibc-Matching-POSIX-Regexps">
      <title>Derlenmiş POSIX Düzenli İfadelerinin Eşleştirilmesi</title>
      <titleabbrev><command>regcomp</command> ile elde edilen şablonun eşleşme için <command>regexec</command> ile kullanımı.</titleabbrev>
      <para>
Bir düzenli ifadeyi <xref linkend="glibc-POSIX-Regexp-Compilation"/> bölümünde açıklandığı gibi derledikten sonra <command>regexec</command> işlevinde dizgelerle karşılaştırarak eşleşmeleri arayabilirsiniz. Bir düzenli ifade demirleme işleçlerini (<command>^</command> veya <command>$</command>) içermedikçe bir dizge içinde bulunan her eşleşme başarılı sayılır.
    </para><para xml:id="glibc-regexec">
<indexterm scope="glibc-fn"><primary>regexec</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>regexec</command></funcdef>
<paramdef>(const regex_t *restrict <varname>şablon</varname>,
 const char *restrict    <varname>dizge</varname>,
 size_t                  <varname>eşleşen-sayısı</varname>,
 regmatch_t              <varname>eşleşenler</varname>[restrict],
 int                     <varname>icra-seçenekleri</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev derlenmiş düzenli ifadeyi içeren <varname>*şablon</varname> ile  <varname>dizge</varname>'yi eşlemeye çalışır.
    </para><para>
<command>regexec</command> işlevi düzenli ifade eşleştirilebilmişse <command>0</command> ile aksi takdirde sıfırdan farklı bir değerle döner. Sıfırdan farklı dönüş değerlerinin listesi aşağıdadır. Sıfırdan farklı değerler için hata iletilerini üretmek için <command>regerror</command> işlevini kullanabilirsiniz; bkz. <xref linkend="glibc-Regexp-Cleanup"/>.
    </para><para>
<varname>icra-seçenekleri</varname> argümanı ile bit değerli seçeneklerden birini veya bir kaçını belirtebilirsiniz.
    </para><para>
Düzenli ifade ya da alt düzenli ifadelerle eşleşen <varname>dizge</varname> parçaları hakkında bilgi edinmek için <varname>eşleşenler</varname> ve <varname>eşleşen-sayısı</varname> argümanlarını kullanabilirsiniz.  Aksi takdirde <varname>eşleşen-sayısı</varname> için <command>0</command>, <varname>eşleşenler</varname> için <command>NULL</command> değeri belirtmelisiniz. Bkz. <xref linkend="glibc-Regexp-Subexpressions"/>.
    </para><para>
Eşleşme aramak için kullanılan derlenmiş düzenli ifadeyi hangi yerel için derlemişseniz, arama işlemini aynı yereli kullanarak yapmalısınız.
    </para><para>
<command>regexec</command> işlevinin <varname>icra-seçenekleri</varname> argümanında kullanılabilecek seçenekler:
    </para><para><variablelist><varlistentry>
    <term><literal>REG_NOTBOL</literal></term><listitem><para>
Belirtilen dizgenin başlangıcı bir satırın başlangıcı sayılmaz; daha genel olarak, dizgeden önce bir metin bulunduğu kabulü yapılmaz.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>REG_NOTEOL</literal></term><listitem><para>
Belirtilen dizgenin sonu bir satırın sonu sayılmaz; daha genel olarak, dizgeden sonra bir metin bulunduğu kabulü yapılmaz.
       </para></listitem></varlistentry></variablelist>
     </para><para>
<command>regexec</command> işlevinden dönebilecek sıfırdan farklı değerler:
    </para><para><variablelist><varlistentry>
    <term><literal>REG_NOMATCH</literal></term><listitem><para>
Şablon dizge ile eşleşmedi. Bu aslında bir hata değildir.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>REG_ESPACE</literal></term><listitem><para>
<command>regexec</command> için bellek yetersiz.
       </para></listitem></varlistentry></variablelist>
     </para></funcdescr></funcsynopsis></para></sect1>
    <sect1 xml:id="glibc-Regexp-Subexpressions">
      <title>Alt İfadelerle Eşleşmeler</title>
      <titleabbrev>Dizgenin eşleşen parçalarının bulunması.</titleabbrev>
      <para>
<command>regexec</command> işlevi <varname>şablon</varname> içindeki parantezli alt-ifadeleri eşleştirmek amacıyla kullanıldığına eşleşen <varname>dizge</varname> parçalarını kaydeder. Sonuçları <command>regmatch_t</command> türündeki yapı dizgesi ile döndürür. Dizinin ilk elemanı (indisi <command>0</command> olan eleman) düzenli ifadenin tamamıyla eşleşen dizge parçasını içerir. Dizinin diğer elemanlarının herbirine tek bir parantezli alt-ifade ile eşleşen dizge parçasının başlangıcı ve sonu kaydedilir.
    </para><para xml:id="glibc-regmatch_t">
<indexterm scope="glibc-tp"><primary>regmatch_t</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü">
<funcdef><command>regmatch_t</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
<command>regexec</command> işlevine aktarılan <varname>eşleşenler</varname> dizisinin veri türüdür. İki yapı üyesi içerir:
    </para><para><variablelist><varlistentry>
    <term><literal>rm_so</literal></term><listitem><para>
Alt dizgenin <varname>dizge</varname> içindeki başlangıç konumu. Bu değeri <varname>dizge</varname>'ye ekleyerek alt dizgenin adresini bulabilirsiniz.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>rm_eo</literal></term><listitem><para>
Alt dizgenin <varname>dizge</varname> içindeki bitiş konumu.
       </para></listitem></varlistentry></variablelist>
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-regoff_t">
<indexterm scope="glibc-tp"><primary>regoff_t</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü">
<funcdef><command>regoff_t</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
<command>regoff_t</command> bir işaretli tamsayı tür için bir takma isimdir. <command>regmatch_t</command> alanları <command>regoff_t</command> türündedir.
       </para><para>
<command>regmatch_t</command> elemanları konumsal alt-ifadelere karşılıktır; ilk elemanda (indisi <command>1</command> olan eleman) eşleşen ilk alt-ifade, ikincisinde ikinci alt-ifade,... kayıtlıdır.  Alt-ifadelerin sırası ifadede bulundukları sıraya göredir.
    </para><para>
<command>regexec</command> işlevine <varname>eşleşenler</varname> dizisinde kaç eşleşme saklanacağını <varname>eşleşen-sayısı</varname> ile belirtebilirsiniz. Eğer asıl ifade  <varname>eşleşen-sayısı</varname> ile belirtilenden fazla alt-ifade içeriyorsa, kalan alt-ifadelerin konumları hakkında bilgi edinemezsiniz. Fakat bu şablonun belli bir dizge ile eşleşip eşleşmemesini etkilemez.
    </para><para>
<command>regexec</command> işlevinin eşleşen alt-ifadenin yeri hakkında bilgi döndürmesini istemiyorsanız ya <varname>eşleşen-sayısı</varname> ile <command>0</command> değerini aktarın ya da düzenli ifadeyi derlerken <command>regcomp</command> işlevini <command>REG_NOSUB</command> seçeneği ile kullanın.
    </para></funcdescr></funcsynopsis></para></sect1>
    <sect1 xml:id="glibc-Subexpression-Complications">
      <title>Alt-ifade Eşlemesindeki Sorunlar</title>
      <titleabbrev>Eşleşen parçaların yerlerinin bulunması.</titleabbrev>
      <para>
Kimi zaman bir alt-ifade hiçbir karakter içermeyen bir altdizge ile eşleşebilir. Bu durum örneğin <command>fum</command> dizgesi <command>f\(o*\)</command> ifadesiyle eşleştiğinde ortaya çıkar. (Aslında sadece <command>f</command> eşleşir.) Bu durumda, konumların her ikisi de bulunan boş altdizgeleri gösterir. Bu örnekte her iki konum da <command>1</command>'dir.
    </para><para>
Kimi zaman bir düzenli ifade, alt-ifadeler hiç kullanılmadan eşleşir; örneğin, <command>ba\(na\)*</command> ifadesi <command>ba</command> dizgesiyle eşleşirken parantezli alt-ifade kullanılmaz. Bu durumda bu alt-ifadenin elemanındaki her iki alan da <command>-1</command> içerir.
    </para><para>
Kimi zaman düzenli ifadenin tamamının eşleştirilmesinde belli bir alt-ifade defalarca eşleşebilir; örneğin, <command>ba\(na\)*</command> ifadesi <command>bananana</command> dizgesi ile eşleştirilirken parantezli alt-ifade üç kere eşleştirilmiştir. Bu durumda <command>regexec</command> çağrısı alt-ifade ile eşleşen son dizge parçasının konumlarını kaydeder; <command>bananana</command> için bu komumlar <command>6</command> ve <command>8</command>'dir.
    </para><para>
Fakat son eşleşme daima seçilenlerden biri olmaz. Eşleşme için en elverişli olanın öncelikli olanlardan biri olduğu söylenebilir. Yani, bir alt-ifade bir diğerinin içinde görünüyorsa sonuçlar son eşleşen dış alt-ifadedeki eşleşmeyi ifade eden içteki alt-ifade için raporlanır. Örneğin, <command>\(ba\(na\)*s \)*</command> ifadesinin <command>"bananas bas "</command> dizgesi ile eşleştiğini varsayalım.
Son defasında içteki ifade aslında ilk sözcüğün sonuna doğru eşlenir. Ancak ikinci sözcüğün tekrar eşleşeceği varsayıldığında eşleme başarısız olur. <command>regexec</command>, &quot;na&quot; alt-ifadesinin kullanılmadığını raporlar.
    </para><para>
Bu kuralın uygulandığı başka bir örnek:
    </para><para>
<screen>\(ba\(na\)*s \|nefer\(ti\)* \)*</screen>
    </para><para>
Bu ifade <command>bananas nefertiti</command> ile eşleşir.  İlk sözcükte &quot;na&quot; alt-ifadesi eşleşir, ama ikinci sözcükte bu alt-ifade değil, onun alternatifi olan alt-ifade eşleşir. Bir kere daha, dış alt-ifadenin ikinci yinelemesi birincinin üzerine yazar ve bu ikinci yinelemede &quot;na&quot; alt ifadesi kullanılmaz. Bu durumda, <command>regexec</command>, &quot;na&quot; alt-ifadesinin kullanılmadığını raporlar.
    </para></sect1>
    <sect1 xml:id="glibc-Regexp-Cleanup">
    <title>POSIX Şablonunun Temizlenmesi</title>
    <titleabbrev>Derlenmiş düzenli ifade için ayrılan yerin serbest bırakılması ve hataların raporlanması.</titleabbrev>
    <para>
Bir derlenmiş düzenli ifadeyi artık kullanmayacaksanız, bir <command>regfree</command> çağrısı ile ona ayrılan belleği serbest bırakabilirsiniz.
    </para><para xml:id="glibc-regfree">
<indexterm scope="glibc-fn"><primary>regfree</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>void <command>regfree</command></funcdef>
<paramdef>(regex_t *<varname>şablon</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>regfree</command> çağrısı <varname>*şablon</varname> ile gösterilen derlenmiş düzenli ifadeye ayrılan belleği serbest bırakır. Bu alan, bu kılavuzda üyelerinin hepsini açıklamadığımız <command>regex_t</command> yapısının çeşitli iç alanlarını içerir.
    </para><para>
<command>regfree</command> işlevi <varname>*şablon</varname> nesnesinin kendisini serbest bırakmaz.
</para></funcdescr></funcsynopsis></para><para>
Başka bir düzenli ifadeyi <command>regex_t</command> yapısında derlemeden önce bu yapı için ayrlan alanı <command>regfree</command> ile serbest bırakmalısınız.
    </para><para>
<command>regcomp</command> veya <command>regexec</command> işlevi bir hata raporladığında, bunu bir hata dizgesine dönüştürmek için <command>regerror</command> işlevini kullanabilirsiniz.
    </para><para xml:id="glibc-regerror">
<indexterm scope="glibc-fn"><primary>regerror</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>size_t <command>regerror</command></funcdef>
<paramdef>(int                     <varname>hatakodu</varname>,
 const regex_t *restrict <varname>şablon</varname>,
 char *restrict          <varname>tampon</varname>,
 size_t                  <varname>uzunluk</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev <varname>hatakodu</varname> ile belirtilen hata kodu için bir hata iletisi üretir ve bunu <varname>tampon</varname> adresinden başlayan <varname>uzunluk</varname> baytlık dizgeye yerleştirir. <varname>şablon</varname> argümanı ile belirtilen derlenmiş düzenli ifade hatanın oluştuğu <command>regcomp</command> veya <command>regexec</command> işlevinde kullanılmış olan nesne olmalıdır. <varname>şablon</varname> argümanında değer olarak <command>NULL</command>'da belirtebilirsiniz ve anlamlı bir hata iletisi alabilirsiniz, ama alacağınız hata iletisi ayrıntılı olmayacaktır.
    </para><para>
Hata iletisi belirttiğiniz <varname>uzunluk</varname> bayta sığmazsa, <command>regerror</command> hata iletisinin sığdığı kadarını yerleştirir. İşlev, ister tam dizgeyi ister kırpılmış dizgeyi döndürsün, daima dizgeyi boş karakterle sonlandırır.
    </para><para>
İşlevin dönüş değeri hata iletisinin tamamının uzunluğudur. Bu değer <varname>uzunluk</varname>'tan küçükse dizge kırpılmamış demektir, bu dizgeyi kullanabilirsiniz, aksi takdirde işlevi daha büyük bir tamponla yeniden çağırmalısınız.
    </para><para>
Bu örnekte kullanılan <command>regerror</command> çağrısında hata iletisi için gereken alan özdevimli olarak ayrılmaktadır:
    </para><para>
<screen>char *get_regerror (int errcode, regex_t *compiled)
{
  size_t length = regerror (errcode, compiled, NULL, 0);
  char *buffer = xmalloc (length);
  (void) regerror (errcode, compiled, buffer, length);
  return buffer;
}
</screen></para></funcdescr></funcsynopsis></para></sect1>
  </chapter>
  <chapter xml:id="glibc-Word-Expansion">
    <title>Kabuk Usulü Sözcük Yorumlama</title>
    <titleabbrev>Kabuk değişkenlerinin, iç içe komutların, aritmetik ifadelerin ve dosya ismi kalıplarının yorumlanması.</titleabbrev>
    <para>
<indexterm scope="glibc-cp"><primary>sözcük yorumlama</primary></indexterm>
<indexterm scope="glibc-cp"><primary>kabukta sözcük yorumlama</primary></indexterm>
<wordasword>Sözcük yorumlama</wordasword>, kabuğun yaptığı gibi değişkenleri, komutları ve dosya ismi kalıplarını sözcüklerine ayırma ve bunların yerine bazı ikameler yapma işlemlerini ifade eder.
   </para><para>
Örneğin, <command>ls -l foo.c</command> yazarsanız bu dizgeyi kabuk üç sözcüğe ayırır: <command>ls</command>, <command>-l</command> ve <command>foo.c</command>. Bu sözcük yorumlamanın en temel işlemidir.
   </para><para>
<command>ls *.c</command> yazarsanız, bu dizge çok sayıda sözcüğe ayrışır, çünkü <command>*.c</command> sözcüğü çok sayıda dosya ismiyle değiştirilecektir. Bu işleme <wordasword>dosyaismi yorumlaması</wordasword> denir ve sözcük yorumlamanın bir parçasıdır.
   </para><para>
<command>echo $PATH</command> kullanırsanız, dosya yolunuz basılır. Burada sözcük yorumlamanın başka bir parçası olan <wordasword>değişken ikamesi</wordasword>'nden yararlanılır.
   </para><para>
Sıradan yazılımlar kabuğun uyguladığı gibi sözcük yorumlaması uygulamak için bir kütüphane işlevi olan <command>wordexp</command> işlevini kullanabilirler.
   </para>
    <sect1 xml:id="glibc-Expansion-Stages">
      <title>Sözcük Yorumlama Katmanları</title>
      <titleabbrev>Sözcük yorumlamada bir dizgeye neler yapılır?</titleabbrev>
      <para>
Bir sözcük dizilimine sözcük yorumlaması uygulandığında, sırasıyla aşağıdaki dönüşümler yapılır:
    </para><para>
      <orderedlist numeration="arabic"><listitem><para>
<indexterm scope="glibc-cp"><primary>yaklaşık (~) yorumlaması</primary></indexterm>
<wordasword>Yaklaşık yorumlaması</wordasword>: <command>~foo</command> dizgesinin <command>foo</command> kullanıcısının ev dizini ismi ile değiştirilmesi.
      </para></listitem><listitem><para>
Bundan sonra, aynı adımda soldan sağa 3 adımda şu dönüşümler uygulanır:
      </para><para><itemizedlist><listitem><para>
<indexterm scope="glibc-cp"><primary>değişken ikamesi</primary></indexterm>
<indexterm scope="glibc-cp"><primary>komut ikamesi</primary></indexterm>
<wordasword>Değişken ikamesi</wordasword>: <command>$foo</command> gibi başvurular için ortam değişkenleri ikame edilir.
        </para></listitem><listitem><para>
<indexterm scope="glibc-cp"><primary>komut ikamesi</primary></indexterm>
<wordasword>Komut İkamesi</wordasword>: <command>`cat foo`</command> gibi bir dizge ya da eşdeğeri olan <command>$(cat foo)</command> dizgesi kullanıldığında kabuk içteki dizgeyi komut olarak çalıştırır ve bu dizgeyi komutun çıktısı ile değiştirir.
        </para></listitem><listitem><para>
<indexterm scope="glibc-cp"><primary>aritmetik yorumlama</primary></indexterm>
<wordasword>Aritmetik yorumlama</wordasword>: <command>$(($x-1))</command> gibi bir dizge, ifadenin sonucu ile değiştirilir.
        </para></listitem></itemizedlist>
        </para></listitem><listitem><para>
<indexterm scope="glibc-cp"><primary>sözcüklere ayırma</primary></indexterm>
<wordasword>Sözcüklere ayırma</wordasword>: Dizgenin sözcüklerine ayrılması.
      </para></listitem><listitem><para>
<indexterm scope="glibc-cp"><primary>dosyaismi yorumlaması</primary></indexterm>
<wordasword>Dosyaismi yorumlaması</wordasword>: <command>*.c</command> gibi bir sözcük, uzantısı <filename>.c</filename> olan dosyaların listesi ile değiştirilir. Dosyaismi yorumlaması sözcüğün tamamına bir defada uygulanır ve sözcük kendisiyle eşleşen sıfır ya da daha fazla dosya ismiyle değiştirilir.
      </para></listitem><listitem><para>
<indexterm scope="glibc-cp"><primary>tırnak kaldırma</primary></indexterm>
<wordasword>Tırnak kaldırma</wordasword>: Dizgeyi sarmalayan tırnakları kaldırılması; yukarıdaki yorumlamalar uygulandıktan sonra yukarıdaki yorumlamaların sonucu olmayan ve öncelenmemiş tüm <command>\</command>, <command>'</command> ve <command>"</command> karakterleri kaldırılır.
      </para></listitem></orderedlist></para><para>
Bu dönüşümler hakkında daha ayrıntılı bilgiyi GNU Bash Başvuru Kılavuzu'nun <xref linkend="bashref_shell.expansions"/> kısmında bulabilirsiniz.
    </para></sect1>
    <sect1 xml:id="glibc-Calling-Wordexp">
      <title><literal>wordexp</literal> çağrısı</title>
      <titleabbrev><command>wordexp</command> çağrısı nasıl yapılır?</titleabbrev>
      <para>
Sözcük yorumlaması ile ilgili tüm işlevler, sabitler ve veri türleri <filename>wordexp.h</filename> başlık dosyasında bulunur.
    </para><para>
Sözcük yorumlaması sonuç olarak bir dizge göstericileri dizisi üretir. Bu dizgeyi döndürmek için <command>wordexp</command> işlevi bir yapı olan özel bir veri türü, <command>wordexp_t</command> kullanır.  <command>wordexp</command> işlevine bu yapının adresini aktarırsanız, işlev sonuç hakkında bilgiyi, bu yapının elemanlarına kaydederek döndürür.
    </para><para xml:id="glibc-wordexp_t">
<indexterm scope="glibc-tp"><primary>wordexp_t</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü">
<funcdef><command>wordexp_t</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu veri türü, bir sözcük göstericileri dizisine bir gösterici tutar. Daha açık ifade etmek gerekirse, sözcük göstericileri dizisinin adresini ve eleman sayısının kaydını tutar.
    </para><para><variablelist><varlistentry>
    <term><literal>we_wordc</literal></term><listitem><para>
Gösterici dizisinin eleman sayısı.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>we_wordv</literal></term><listitem><para>
Gösterici dizisinin adresi. Bu alan <command>char ** </command> türündedir.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>we_offs</literal></term><listitem><para>
Gösterici dizisindeki ilk gerçek elemanın konumu veya ilk gerçek elemana erişmek için <command>we_wordv</command> alanındaki adrese eklenecek sayı. Diğer alanların aksine bu alan işlev için bir girdidir; işlev diğer alanları çıktıyı döndürmek için kullanır.
       </para><para>
Konum olarak sıfırdan farklı bir değer belirtirseniz, dizinin bu elemanından önceki elemanları boş kalır (işlev, bu konumları boş göstericilerle doldurur).
       </para><para>
<command>we_offs</command> alanı sadece <command>WRDE_DOOFFS</command> seçeneği etkinse anlamlıdır. Aksi takdirde bu alanın içerdiği değere bakılmaksızın gösterici dizisinin ilk elemanının sıfırıncı eleman olduğu varsayılır.
       </para></listitem></varlistentry></variablelist>
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-wordexp">
<indexterm scope="glibc-fn"><primary>wordexp</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>wordexp</command></funcdef>
<paramdef>(const char *<varname>sözcükler</varname>,
 wordexp_t  *<varname>gst-dizisi</varname>,
 int         <varname>derleme-seçenekleri</varname>)</paramdef>
</funcprototype><funcdescr><para>
İşlev, <varname>sözcükler</varname> dizgesine sözcük yorumlaması uygular ve sonucu ayırdığı bir gösterici dizisinde saklayarak bu dizinin adresini ve eleman sayısını <varname>*gst-dizisi</varname> içinde döndürür.  <varname>derleme-seçenekleri</varname> argümanını bit değerli seçenekleri belirtmek için kullanabilirsiniz; bu seçenekler için <xref linkend="glibc-Flags-for-Wordexp"/> bölümüne bakınız.
    </para><para>
<varname>sözcükler</varname> dizgesinde <command>|;</command> karakterlerini tersbölü karakteri ile öncelemeden kullanmamalısınız. Aksi takdirde <command>WRDE_BADCHAR</command> hata kodunu alırsınız. Bir sözcük yorumlama oluşumunu sarmalamak dışında parantez ve kaşlı ayraç kullanmayın. Eğer tırnak karakteri olarak <command>&quot;</command> karakterini kullanıyorsanız, bir ikincisi ile kapatmalısınız.
    </para><para>
Sözcük yorumlamasının sonucu bir sözcük dizisidir. <command>wordexp</command> işlevi sonuçlanan her sözcük için bir dizge ve bu dizgelerin göstericilerinden oluşan <command>char **</command> türünde bir dizi ayırır. Gösterici dizisinin son elemanı bir boş göstericidir. Bu diziye <firstterm>dizge göstericileri dizisi</firstterm> denir.
    </para><para>
<command>wordexp</command> dizinin adresini ve eleman sayısını (sonlandırıcı boş gösterici hariç) <varname>gst-dizisi</varname> ile gösterilen yapı içinde döndürür.
    </para><para>
<command>wordexp</command> başarılı olduğu takdirde 0 ile aksi takdirde şu hata kodlarından biri ile döner:
    </para><para><variablelist><varlistentry>
    <term><literal>WRDE_BADCHAR</literal></term><listitem><para>
<varname>sözcükler</varname> girdi dizgesi <command>|</command> gibi öncelenmemiş geçersiz karakter içeriyor.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>WRDE_BADVAL</literal></term><listitem><para>
Girdi dizgesi tanımlanmamış bir kabuk değişkenini ifade ediyor ve bu tür ifadeleri yasaklayan <command>WRDE_UNDEF</command> seçeneğini belirtmişsiniz.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>WRDE_CMDSUB</literal></term><listitem><para>
Girdi dizgesi komut ikamesi içeriyor ve siz bunların kullanımını  <command>WRDE_NOCMD</command> seçeneğini kullanarak yasaklamışsınız.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>WRDE_NOSPACE</literal></term><listitem><para>
Sonucu yerleştirmek için bellek ayrılamıyor. Bu durumda işlev yer ayırabildiği kadar sonuçla döner.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>WRDE_SYNTAX</literal></term><listitem><para>
Girdi dizgesinde bir sözdizimi hatası var. Örneğin, tırnak karakterinin eşi yoksa bu bir sözdizimi hatasıdır.
       </para></listitem></varlistentry></variablelist>
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-wordfree">
<indexterm scope="glibc-fn"><primary>wordfree</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>void <command>wordfree</command></funcdef>
<paramdef>(wordexp_t *<varname>gst-dizisi</varname>)</paramdef>
</funcprototype><funcdescr><para>
<varname>*gst-dizisi</varname> yapısında adresi belirtilen gösterici dizisini serbest bırakır. İşlev <varname>*gst-dizisi</varname>'nin kendisini serbest bırakmaz.
</para></funcdescr></funcsynopsis></para></sect1>
    <sect1 xml:id="glibc-Flags-for-Wordexp">
      <title>Sözcük Yorumlama Seçenekleri</title>
      <titleabbrev><command>wordexp</command> işlevinde belirtilebilecek seçenekler.</titleabbrev>
      <para>
Bu bölümde <command>wordexp</command> işlevinin <varname>derleme-seçenekleri</varname> argümanında belirtebileceğiniz seçenekler açıklanacaktır. Seçtiğiniz seçenekleri bir C işleci olan <command>|</command> ile birleştirerek kullanabilirsiniz.
    </para><para><variablelist><varlistentry>
    <term><literal>WRDE_APPEND</literal></term><listitem><para>
Önceki bir <command>wordexp</command> çağrısı ile üretilmiş sözcük göstericileri dizisine bu yorumlamadan sözcükler eklenir. Bu yolla bir dizgenin sonuna aralarında boşluk bırakarak sözcük ekler gibi diziye sözcük ekleyebilirsiniz.
       </para><para>
Ekleme işlemi sırasında, <command>wordexp</command> çağrıları arasında sözcük göstericileri dizisinde değişiklik yapmamalısınız. Ayrıca ilk <command>wordexp</command> çağrısında <command>WRDE_DOOFFS</command> seçeneğini belirtmişseniz, ekleme işlemi için yaptığınız çağrıda da bu seçeneği belirtmelisiniz.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>WRDE_DOOFFS</literal></term><listitem><para>
Sözcük gösterici dizisinin başlangıcındaki elemanların boş kalmasını sağlar. Kaç elemanın boş kalacağı <command>we_offs</command> üyesinde belirtilir. Boş elemanlar boş gösterici içerir.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>WRDE_NOCMD</literal></term><listitem><para>
Komut ikamesi yapılmaz; eğer girdi komut ikamesini gerektiriyorsa, bir hata raporlanır.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>WRDE_REUSE</literal></term><listitem><para>
Önceki bir <command>wordexp</command> çağrısı ile üretilmiş sözcük göstericileri dizisini yeniden kullanılabilir yapar. Bu seçeneğin kullanıldığı bir <command>wordexp</command> çağrısında yeni bir gösterici dizisi ayrılmaz, mevcut olan (gerekirse genişletilerek) kullanılır.
       </para><para>
Bu işlem sırasında dizi başka bir bellek bölgesine taşınabileceğinden eski göstericiyi saklayıp bu çağrıdan sonra onu kullanmamamalısınız. Her çağrıdan sonra göstericiyi <command>we_pathv</command> üyesinden öğrenebilirsiniz.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>WRDE_SHOWERR</literal></term><listitem><para>
Komut ikamesinde çalıştırılan komutlardan dönen hata iletileri gösterilir. Yani, bu komutların sürecin standart hata akımını kullanması sağlanır. Öntanımlı olarak, <command>wordexp</command> bu komutlara hata iletilerinin gösterilmediği bir standart hata akımı atar.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>WRDE_UNDEF</literal></term><listitem><para>
Eğer girdi tanımsız bir kabuk değişkeni içeriyorsa bir hata raporlanır.
       </para></listitem></varlistentry></variablelist>
     </para></sect1>
    <sect1 xml:id="glibc-Wordexp-Example">
    <title><literal>wordexp</literal> Örneği</title>
    <titleabbrev>Sözcük yorumlaması yapılan bir kod örneği.</titleabbrev>
    <para>
Bu örnekte <command>wordexp</command> işlevi muhtelif dizgeleri yorumlayıp sonuçlarını birer kabuk komutu olarak kullanmaktadır. Ayrıca, <command>WRDE_APPEND</command> seçeneği ile <command>wordfree</command> işlevinin kullanımı da gösterilmiştir.
    </para><para>
<screen>int
yorumla_ve_calistir (const char *komut, const char **secenekler)
{
  wordexp_t sonuc;
  pid_t pid
  int durum, i;

  /* Çalıştırılacak komut için dizgeyi yorumlayalım.  */
  switch (wordexp (komut, &amp;sonuc, 0))
    {
    case 0:                     /* Başarılı.  */
      break;
    case WRDE_NOSPACE:
      /* WRDE_NOSPACE hatası varsa, sonuç kısmende olsa
         ayrılmıştır. Onu serbest bırakalım.  */
      wordfree (&amp;sonuc);
    default:                    /* Bazı başka hatalar.  */
      return -1;
    }

  /* Argümanları elde etmek için dizgeyi yorumlayalım.  */
  for (i = 0; secenekler[i] != NULL; i++)
    {
      if (wordexp (secenekler[i], &amp;sonuc, WRDE_APPEND))
        {
          wordfree (&amp;sonuc);
          return -1;
        }
    }

  pid = fork ();
  if (pid == 0)
    {
      /* Burada bir alt süreç oluşturup komutu çalıştırıyoruz. */
      execv (sonuc.we_wordv[0], sonuc.we_wordv);
      exit (EXIT_FAILURE);
    }
  else if (pid &lt; 0)
    /* Çatallama başarısız oldu, durumu raporlayalım.  */
    durum = -1;
  else
    /* Bu üst süreç, alt sürecin bitmesini bekleyecek.  */
    if (waitpid (pid, &amp;status, 0) != pid)
      durum = -1;

  wordfree (&amp;sonuc);
  return durum;
}
</screen></para></sect1>
    <sect1 xml:id="glibc-Tilde-Expansion">
      <title>Yaklaşık (~) Yorumlaması Hakkında</title>
      <titleabbrev>Yaklaşık yorumlaması ile ilgili ayrıntılar.</titleabbrev>
      <para>
Kendi ev dizininizi belirtmek için bir dosya isminin başında kullandığınız <command>~</command> işareti kabuk sözdiziminin standart parçalarından biridir. Bir <varname>kullanıcı</varname>'nın ev dizinini belirtmek için ise   <command>~</command><varname>kullanıcı</varname> yazabilirsiniz.
    </para><para>
<wordasword>Yaklaşık (~) yorumlaması</wordasword>, <command>~</command> işaretini ev dizini ismine dönüştürme işlemidir.
    </para><para>
Yaklaşık (~) yorumlaması <command>~</command> karakteri ile başlayan, ilk boşluk ya da bölü çizgisi karakterine kadar tüm karakterlere uygulanır. <command>~</command> karakteri sadece bir sözcüğün başındaysa anlamlıdır; tek başına olsa bile yorumlama yapılır (kabukta <command>echo ~</command> yazın).
    </para><para>
Tek başına <command>~</command> işareti için <literal>HOME</literal> ortam değişkeninin değeri kullanılır. <command>~</command> karakterinden sonra gelen sözcük kullanıcı veritabanında <command>getpwname</command> ile aranır ve veritabanında kayıtlı ev dizini kullanılır. Bu durumda, <command>~</command> karakterinden sonra kendi kullanıcı isminizi yazarsanız ve <literal>HOME</literal> ortam değişkenindeki değer, veritabanında kayıtlı değerden farklıysa, tek başına <command>~</command> kullanarak yapılan yorumlamadan farklı bir sonuç dönebilir.
    </para></sect1>
    <sect1 xml:id="glibc-Variable-Substitution">
      <title>Değişken İkamesi Hakkında</title>
      <titleabbrev>Değişken ikamesinin türleri.</titleabbrev>
      <para>
Kabuk sözdiziminin bir parçası da bir kabuk değişkeninin değerini bir komutta kullanırken <command>$</command><varname>değişken</varname> şeklinde kullanmaktır. Buna <wordasword>değişken ikamesi</wordasword> denir ve yapılan sözcük yorumlamanın bir parçasıdır.
    </para><para>
Bir ikame yapmak için bir değişken iki yöntemle kullanılabilir:
    </para><para><glosslist><glossentry>
    <glossterm><command>${</command><varname>değişken</varname><command>}</command></glossterm>
    <glossdef><para>
Eğer değişken ismi kaşlı ayraçlar içine alınırsa, değişken isminin bittiği yerin belirsizliği tamamen ortadan kalkar. Böylece değişken ismine sözcük eklenebilir. Örneğin, <literal>${foo}</literal> değişkeninin değeri <literal>traktör</literal> ise <literal>${foo}ler</literal> ifadesinin sonucu <literal>traktörler</literal> olur.
       </para></glossdef></glossentry><glossentry>
    <glossterm><command>$</command><varname>değişken</varname></glossterm>
    <glossdef><para>
Değişken ismi kaşlı ayraçlar içine alınmazsa, değişken ismi <command>$</command> ile başlar ve alfanümerik karakterler ve altçizgi karakterinden oluşabilir. İsimden sonra gelen herhangi bir noktalama işareti değişken ismini sonlandırır. Örneğin,
<literal>$foo-pulluk</literal> ifadesinin sonucu <literal>traktör-pulluk</literal> olur.
       </para></glossdef></glossentry></glosslist></para><para>
Kaşlı ayraçlar kullanıldığında değeri değiştirmek için çeşitli oluşumları kullanmak ya da bazı sınamalar yapmak mümkün olur.
    </para><para><glosslist><glossentry><glossterm>
    <command>${</command><varname>değişken</varname><command>:-</command><varname>öntanımlı</varname><command>}</command>
    </glossterm><glossdef><para>
<varname>değişken</varname>'e değer atanmamışsa ya da tanımsızsa değer olarak <varname>öntanımlı</varname> kullanılır, aksi takdirde <varname>değişken</varname>'in değeri kullanılır.
       </para></glossdef></glossentry><glossentry><glossterm>
       <command>${</command><varname>değişken</varname><command>:=</command><varname>öntanımlı</varname><command>}</command>
       </glossterm><glossdef><para>
<varname>değişken</varname>'e değer atanmamışsa ya da tanımsızsa değer olarak <varname>öntanımlı</varname> kullanılır ve <varname>değişken</varname>'e <varname>öntanımlı</varname> değeri atanır.
       </para></glossdef></glossentry><glossentry><glossterm>
       <command>${</command><varname>değişken</varname><command>:?</command><varname>ileti</varname><command>}</command>
       </glossterm><glossdef><para>
<varname>değişken</varname>'e değer atanmışsa ya da tanımlıysa, değeri kullanılır. Aksi takdirde, sözcük ikamesinin başarısız olduğu kabulüyle standart hata akımına bir hata iletisi olarak <varname>ileti</varname> basılır.
       </para></glossdef></glossentry><glossentry><glossterm>
       <command>${</command><varname>değişken</varname><command>:+</command><varname>sözcük</varname><command>}</command>
       </glossterm><glossdef><para>
Sadece, <varname>değişken</varname>'e değer atanmışsa ya da tanımlıysa, değeri kullanılır. Aksi takdirde sonuç hiçbir şey olur.
       </para></glossdef></glossentry><glossentry><glossterm>
       <command>${#</command><varname>değişken</varname><command>}</command>
       </glossterm><glossdef><para>
Bu ifadenin değeri, değişkenin değerindeki karakter sayısıdır. Sonuç onluk tabandadır. Örneğin, <literal>${#foo}</literal> ifadesinin sonucu 7'dir, çünkü <literal>traktör</literal> 7 karakter uzunluktadır.
       </para></glossdef></glossentry></glosslist></para><para>
Aşağıdaki değişken ikamelerinde, değişkene bir değer ikame etmeden önce değeri kısmen kaldırılır. <varname>önek</varname> ve <varname>sonek</varname> basitçe birer dizge olmayabilir; dosyaismi kalıpları kullanılabilir. Ancak bu bağlamda bu kalıplar dosya isimleri ile değil, değişkenin değerinin parçaları ile eşleştirilirler.
    </para><para><glosslist><glossentry><glossterm>
    <command>${</command><varname>değişken</varname><command>%%</command><varname>sonek</varname><command>}</command>
    </glossterm><glossdef><para>
<varname>değişken</varname>'in değeri, değerin sonunda <varname>sonek</varname> kalıbı ile eşleşen kısmı iptal edilerek kullanılır.
       </para><para>
<varname>sonek</varname> ile eşleşen çok sayıda parça varsa en uzun eşleşme iptal edilir.
       </para><para>
Örneğin, <literal>${foo%%r*}</literal> ifadesinin sonucu <literal>t</literal> olur, çünkü <command>r*</command> kalıbı ile değerin sonunda eşleşen en uzun parça <literal>raktör</literal>'dür.
       </para></glossdef></glossentry><glossentry><glossterm>
       <command>${</command><varname>değişken</varname><command>%</command><varname>sonek</varname><command>}</command>
       </glossterm><glossdef><para>
<varname>değişken</varname>'in değeri, değerin sonunda <varname>sonek</varname> kalıbı ile eşleşen kısmı iptal edilerek kullanılır.
        </para><para>
<varname>sonek</varname> ile eşleşen çok sayıda parça varsa en kısa eşleşme iptal edilir.
       </para><para>
Örneğin, <literal>${foo%r*}</literal> ifadesinin sonucu <literal>traktö</literal> olur, çünkü <command>r*</command> kalıbı ile değerin sonunda eşleşen en kısa parça <literal>r</literal>'dir.
       </para></glossdef></glossentry><glossentry><glossterm>
       <command>${</command><varname>değişken</varname><command>##</command><varname>önek</varname><command>}</command>
       </glossterm><glossdef><para>
<varname>değişken</varname>'in değeri, değerin başlangıcında <varname>önek</varname> kalıbı ile eşleşen kısmı iptal edilerek kullanılır.
       </para><para>
<varname>önek</varname> ile eşleşen çok sayıda parça varsa en uzun eşleşme iptal edilir.
       </para><para>
Örneğin, <literal>${foo##*t}</literal> ifadesinin sonucu <literal>ör</literal> olur, çünkü <command>*t</command> kalıbı ile değerin başlangıcında eşleşen en uzun parça <literal>trakt</literal>'tır.
       </para></glossdef></glossentry><glossentry><glossterm>
       <command>${</command><varname>değişken</varname><command>#</command><varname>önek</varname><command>}</command>
       </glossterm><glossdef><para>
<varname>değişken</varname>'in değeri, değerin başlangıcında <varname>önek</varname> kalıbı ile eşleşen kısmı iptal edilerek kullanılır.
       </para><para>
<varname>önek</varname> ile eşleşen çok sayıda parça varsa en kısa eşleşme iptal edilir.
       </para><para>
Örneğin, <literal>${foo#*t}</literal> ifadesinin sonucu <literal>raktör</literal> olur, çünkü <command>*t</command> kalıbı ile değerin başlangıcında eşleşen en kısa parça <literal>t</literal>'dir.
       </para></glossdef></glossentry></glosslist></para>
     </sect1>
  </chapter>
</part>






