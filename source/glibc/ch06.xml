<?xml version="1.0" encoding="UTF-8"?>

<!-- ********************************************************************
     $Id: ch06.xml,v 1.2 2002/12/20 22:29:48 nilgun Exp $
******************************************************************** -->
<part xml:id="glibc-Character-Set-Handling">
  <title>Karakter Kümeleriyle Çalışma</title>
  <titleabbrev>Genişletilmiş karakter kümeleri desteği.</titleabbrev>
  <partintro><para>
Bilgisayarların ilk görüldüğü zamanlarda karakter kümelerinde her karakter için altı, yedi ya da sekiz bit kullanılmıştı: Sekiz bitten (bir bayt) daha geniş bir karakter hiç yoktu. Bu yaklaşımın sınırlamaları latin karakter kümelerini kullanmayanlar nezdinde daha belirgin hale geldi, bunlarda dilin karakter kümesindeki karakter sayısı için genellikle 2^8 yeterli değildir. Bu kısımda çokbaytlı karakter kümelerini desteklemek üzere C kütüphanesine eklenmiş işlevsellikten söz edilecektir.
  </para></partintro>
  <chapter xml:id="glibc-Extended-Char-Intro">
  <title>Genişletilmiş Karakterlere Giriş</title>
  <para>
Karakterlerle baytlar arasında 1:1 ilişki olan karakter kümeleri ile 1:2 den 1:4
oranlarına kadar ilişki olan karakter kümeleri arasındaki farkları aşacak çok çeşitli çözümler vardır. Bu bölümün devamında C kütüphanesinin işlevselliğini geliştirirken verilen tasarım kararlarını anlamaya yardımcı olacak bir kaç örneğe yer verilmiştir.
   </para><para>
<indexterm scope="glibc-cp"><primary>dahili gösterim</primary></indexterm>
Önce dahili ve harici gösterimler arasında bir ayrım yapmalıyız. <wordasword>Dahili gösterim</wordasword> deyince bir yazılım tarafından bellekte tutulan metnin gösterimini anlıyoruz. <wordasword>Harici gösterim</wordasword> deyince ise bazı iletişim kanalları üzerinden aktarımda ya da bunlar üzerinde saklanacak metinlerin gösterimlerini anlıyoruz. Harici gösterime örnek vermek gerekirse, bir dizinde bulunan ve okunacak ya da çözümlenecek dosyaları gösterebiliriz.
   </para><para>
Geleneksel olarak iki gösterim arasında bir fark yoktur. Tek baytlık dahili ve harici gösterim aynıdır ve eşit kullanılabilirliktedir. Bu kullanılabilirlik karakter kümeleri genişledikçe ve sayıları arttıkça azalır.
   </para><para>
Dahili gösterimle ilgili aşılacak sorunlardan biri farklı karakter kümeleriyle harici olarak kodlanmış metinlerin elde edilmesidir. İki metni okuyup bazı ölçütleri kullanarak karşılaştıran bir yazılım varsayalım. Karşılaştırma sadece metinler dahili olarak bir ortak biçimde tutulabiliyorsa yapılabilir.
   </para><para>
<indexterm scope="glibc-cp"><primary>geniş karakter</primary></indexterm>
Böyle bir ortak biçim (= karakter kümesi) için sekiz bit elbette artık yeterli değildir. Öyleyse en küçük öğe büyütülmelidir: Artık <wordasword>geniş karakterler</wordasword> kullanılmalıdır. Karakter başına bir bayt yerine iki hatta dört bayt kullanılması sözkonusu olacaktır. (Üç, bellek adreslemesi açısından iyi bir değer değildir ve dört bayttan fazlası da gerekmemektedir).
   </para><para>
<indexterm scope="glibc-cp"><primary>Unicode</primary></indexterm>
<indexterm scope="glibc-cp"><primary>ISO 10646</primary></indexterm>
Bu kılavuzun bazı bölümlerinde görüleceği gibi bellekte geniş karakterli metinlerle çalışabilen işlevlerle tamamen yeni bir işlev ailesi oluşturulmuştur. Bu tür geniş karakter gösterimleri için kullanılan karakter kümelerinin çoğu Unicode ve ISO 10646 (UCS olarak da bilinir. UCS: Universal Character Set - Evrensel Karakter Kümesi) kullanır. Unicode (yunikod diye okunur) bir 16 bitlik karakter kümesi olarak tasarlandı; ISO 10646 ise 31 bitlik dev bir kod uzayı olarak tasarlandı. Uygulamada her iki standart eşdeğerdir. Aynı karakter listesini ve aynı kod tablosunu kullanırlar. Fakat Unicode ek anlamsallık belirtir. Bu noktada, sadece ilk <command>0x10000</command> kodluk karakter (BMP: Basic Multilingual Plane - "Temel Çokdilli Seviye" olarak da bilinir) atanmıştır. Unicode ve ISO 10646 karakterleri için tanımlanmış kodlamalardan bazıları:
<indexterm scope="glibc-cp"><primary>UCS-2</primary></indexterm>
<indexterm scope="glibc-cp"><primary>UCS-4</primary></indexterm>
<indexterm scope="glibc-cp"><primary>UTF-8</primary></indexterm>
<indexterm scope="glibc-cp"><primary>UTF-16</primary></indexterm>
UCS-2 16 bitliktir ve sadece BMP'deki karakterleri içerir. UCS-4 32 bitliktir ve Unicode ve ISO 10646 karakterlerini içerir. UTF-8 tek baytla gösterilen ASCII karakter kümesine ek olarak  ASCII olmayan 2 ilâ 6 karakterlik dizilimlerle ifade edilen karakterleri içerir. Son olarak UTF-16, UCS-2'nin içerdiklerine ek olarak <command>0x10ffff</command> e kadar BMP olmayan karakterleri içerir.
   </para><para>
Geniş karakterleri göstermek için <command>char</command> türü yeterli değildir. Bu sebeple ISO C standardı bir geniş karakterli dizgenin bir karakterini tutmak için tasarlanmış yeni bir veri türünden bahseder. Benzerliği sağlamak için tek bir geniş karakter alan işlevlerde kullanılacak ve <command>int</command> türüne karşı düşen bir tür de vardır.
   </para><para xml:id="glibc-wchar_t">
<indexterm scope="glibc-tp"><primary>wchar_t</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü">
<funcdef><command>wchar_t</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu veri türü geniş karakterli dizgelerin temel türü olarak kullanılır. Başka bir deyişle, bu tür nesne dizileri, çokbaytlı karakterlerin <command>char[]</command> dizisine eşdeğerdir. Tür, <filename>stddef.h</filename> başlık dosyasında tanımlanmıştır.
   </para><para>
ISO C90 standardı, <command>wchar_t</command>'den bahsederken gösterimi hakkında belirgin hiçbir şey söylemez. Sadece temel karakter kümesinin tüm elemanlarını saklama yeteneğinde olması gerektiğini belirtir. Diğer taraftan, gömülü sistemlere uyarlanabilirlik bakımından <command>wchar_t</command> türünün <command>char</command> olarak tanımlanması meşru olmalıdır.
   </para><para>
Fakat GNU sistemleri için <command>wchar_t</command> daima 32 bit genişliktedir ve tüm USC-4 değerleri gösterebilme yeteneğine sahiptir, böylece ISO 10646'nın tümü kapsama dahil olur. Bazı Unix sistemlerinde <command>wchar_t</command> 16 bitlik olarak tanımlanır ve sadece Unicode'u kapsar. Bu tanımlama standart açısından geçerli olmakla birlikte ISO 10646 ve UCS-2 deki karakterlerinin tümü ile UTF-16'nın 16 biti
aşan karakterlerini fiilen çoklu geniş karakter kodlaması olarak gösterebilir. Fakat çoklu geniş karakterli kodlamaya başvurulması <command>wchar_t</command> türünün kullanım amacıyla çelişir.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-wint_t">
<indexterm scope="glibc-tp"><primary>wint_t</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü">
<funcdef><command>wint_t</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
<command>wint_t</command>, tek bir geniş karakter içeren değişkenler ve parametreler için kullanılan bir veri türüdür. Normal <command>char</command> dizgeler kullanılırken isim olarak <command>int</command> türüne eşdeğer olan bu türün kullanılması önerilir. <command>wchar_t</command> ve <command>wint_t</command> türleri 32 bit genişlikte olduklarında çoğunlukla aynı gösterime sahiptir ancak, <command>wchar_t</command> <command>char</command> olarak tanımlanmışsa, parametre terfilerinden dolayı <command>wint_t</command> de <command>int</command> olarak tanımlanmalıdır.
   </para><para>
<indexterm scope="glibc-pg"><primary>wchar.h</primary></indexterm>
Bu veri türü <filename>wchar.h</filename> başlık dosyasında tanımlanmış ve ISO C90'ın 1. düzeltmesinde bahsedilmiştir.
      </para></funcdescr></funcsynopsis>
    </para><para>
<command>char</command> veri türü için var olan makrolar gibi <command>wchar_t</command> türündeki bir nesnenin gösterebileceği azami ve asgari değerleri belirten makrolar da vardır.
   </para><para xml:id="glibc-WCHAR_MIN">
<indexterm scope="glibc-vr"><primary>WCHAR_MIN</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>wint_t <command>WCHAR_MIN</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
<command>wint_t</command> türünde bir nesne tarafından tutulabilecek en küçük değerdir.
       </para><para>
Bu makro ISO C90 standardının 1. düzeltmesinde bulunur.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-WCHAR_MAX">
<indexterm scope="glibc-vr"><primary>WCHAR_MAX</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>wint_t <command>WCHAR_MAX</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
<command>wint_t</command> türünde bir nesne tarafından tutulabilecek en büyük değerdir.
       </para><para>
Bu makro ISO C90 standardının 1. düzeltmesinde bulunur.
</para></funcdescr></funcsynopsis>
    </para><para>
Diğer bir geniş karakterlere özel değer <command>EOF</command>'a eşdeğerdir.
   </para><para xml:id="glibc-WEOF">
<indexterm scope="glibc-vr"><primary>WEOF</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>wint_t <command>WEOF</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
<command>WEOF</command> makrosu genişletilmiş karakter kümesindeki herhangi bir üyeden farklı olan <command>wint_t</command> türünde bir değer olarak değerlendirilir.
   </para><para>
<command>WEOF</command>, <command>EOF</command> ile aynı değerde olmakla birlikte onun aksine negatif olmaması gereklidir.  Başka bir deyişle, aşağıdaki küçük kod,
    </para><para>
<screen>
{
  int c;
  …
  while ((c = getc (fp)) &lt; 0)
    …
}
</screen>
    </para><para>
geniş karakterler için doğrudan <command>WEOF</command>  kullanılarak aşağıdaki gibi yazılır:
   </para><para>
<screen>
{
  wint_t c;
  …
  while ((c = wgetc (fp)) != WEOF)
    …
}
</screen>
    </para><para>
<indexterm scope="glibc-pg"><primary>wchar.h</primary></indexterm>
Bu makro <filename>wchar.h</filename> başlık dosyasında tanımlanmıştır ve ISO C90'ın 1. düzeltmesinde bulunur.
</para></funcdescr></funcsynopsis>
    </para><para>
<dicterm><english>endianess</english><turkish>bayt sıralaması</turkish></dicterm>
Bu dahili gösterimler saklama ve aktarım sırasına sorunlara yol açarlar. Çünkü her geniş karakter çok sayıda bayttan oluşur ve bunlar bayt sıralamasından etkilenirler. Makinelerin farklı bayt sıralamasına (endianess) sahip olmaları aynı verinin farklı değerlendirilmesine sebep olur. Bu bayt sıralaması ayrıca tamamı bayt temelli olan iletişim protokollerinden de etkilenir. Çoğunlukla gönderici geniş karakterleri baytlarına ayırmak konusunda bir karar vermek durumunda kalır. Bir son (ama en az önemli) husus da geniş karaktelerin, özelleştirilmiş tek baytlı karakter kümelerine göre daha fazla saklama alanı gerektirmesidir.
   </para><para>
<indexterm scope="glibc-cp"><primary>çokbaytlı karakter</primary></indexterm>
<indexterm scope="glibc-cp"><primary>EBCDIC</primary></indexterm>
Yukarıdaki sebeplerden dolayı, dahili kodlama UCS-2 ya da UCS-4 ise çoğunlukla bir harici kodlama dahili kodlamadan farklı olur. Harici kodlama bayt temellidir ve ortama ve elde edilecek metine uygun olarak seçilebilir. Bu harici kodlama için farklı karakter kümeleri kullanılabilir. ASCII temelli tüm karakter kümeleri bir gereksinimi tamamen karşılar: Dosyasistemi bakımından yeterlilik (filesystem safe); yani <command>'/'</command> karakteri kodlama içinde sadece kendi olarak kullanılır.
Bazı şeyler EBCDIC (Extended Binary Coded Decimal Interchange Code - Genişletilmiş İkilik kodlu Ondalık Değişim Kodu; IBM tarafından kullanılan bir karakter kümesi ailesidir) gibi karakter setleri için biraz farklıdır, ama işletim sistemi EBCDIC'i doğrudan anlayamıyorsa sistem çağrılarının parametrelerinde kullanmadan önce işletim sisteminin anlayabileceği kodlamaya dönüştürülmüş olmalıdır.
   </para><itemizedlist><listitem><para>
En basit karakter kümeleri tek baytlık karakter kümeleridir. Sadece 256 karakter içerebilir ve tüm dilleri kapsamak açısından yetersizdir. 8 bitlik karakter kümeleri ile çalışmak basittir. Daha sonra gösterileceği gibi bu doğru değildir, uygulamalar 8 bitlik karakter kümelerini kullanmaları gerektiği için kullanırlar.
    </para></listitem><listitem><para>
<indexterm scope="glibc-cp"><primary>ISO 2022</primary></indexterm>
ISO 2022 standardı, bir baytttan daha fazla baytla gösterilebilen karakterlerin olduğu genişletilmiş karakter kümeleri için bir mekanizma tanımlar. Bu, bir metni bir durumla ilişkilendirerek yapılır.  Karakterler, metin içinde bulunabildikleri durumu değiştirmekte kullanılabilirler. Metindeki her bayt, her durum için farklı yorumlanmalıdır. Bir baytın kendisi olarak mı yoksa bir karakteri oluşturan çok sayıda bayttan biri olarak mı yorumlanacağı duruma bağlıdır.
     </para><para>
<indexterm scope="glibc-cp"><primary>EUC</primary></indexterm>
<indexterm scope="glibc-cp"><primary>Shift_JIS</primary></indexterm>
<indexterm scope="glibc-cp"><primary>SJIS</primary></indexterm>
ISO 2022'nin çoğu kullanımlarında tanımlı karakter kümeleri bir sonraki karakterden fazlasını kapsayan durum değişikliklerine izin vermez. Bir karakterin bayt sırasının başlangıcı bulunduktan sonra metin doğru olalak yorumlanabildiğinden bu büyük yarar sağlar. Bu kuralı kullanan karakter kümelerine örnek olarak çeşitli EUC karakter kümeleri (Sun'ın işletim sistemlerinde kullanılan, EUC-JP, EUC-KR, EUC-TW ve EUC-CN) veya Shift_JIS (SJIS, bir Japonca kodlama) verilebilir.
     </para><para>
Ancak bir karakterden daha fazlası için geçerli olan ve diğer bir bayt sıralaması tarafından değiştirilen bir durumu kullanan karakter kümeleri de vardır. Bunlara örnek olarak  ISO-2022-JP, ISO-2022-KR ve ISO-2022-CN verilebilir.
     </para></listitem><listitem><para>
<indexterm scope="glibc-cp"><primary>ISO 6937</primary></indexterm>
Latin alfabesini kullanan dillerin 8 bitlik karakter kümelerini düzeltmek için başlatılan çalışmalar ISO 6937 benzeri karakter kümeleri ile sonuçlandı. Burada <command>±</command> gibi karakterleri oluşturan baytlar kendileri olarak bir çıktı üretmez: İstenen sonucu üretmek için birtakım karakterler birlikte kullanılır. Örneğin <command>0xc3 0xbc</command> bayt sıralaması (8 bitlik <command>Ã¼</command> karakterleri)  <command>ü</command> karakterini oluşturur. <command>±</command> karakterini elde etmek için ise <command>0xc2 0xb1</command> bayt sıralaması (8 bitlik <command>Â±</command> karakterleri) kullanılır.
     </para><para>
ISO 6937 benzeri karakter kümeleri teletex gibi bazı gömülü sistemlerde kullanılır.
     </para></listitem><listitem><para>
<indexterm scope="glibc-cp"><primary>UTF-8</primary></indexterm>
Dahili olarak kullanılan Unicode veya ISO 10646 metinlerini dönüştürmek yerine UCS-2/UCS-4 den farklı bir kodlamanın kullanılması çoğunlukla yeterli olur. Unicode ve ISO 10646 nın her ikisi de böyle bir kodlamayı belirtirler: UTF-8. Bu kodlama, 1 bayttan 6 bayta kadar uzunluklarda bayt dizgelerini 31 bit genişlikle, ISO 10646 daki tüm karakterleri gösterebilmektedir.
     </para><para>
<indexterm scope="glibc-cp"><primary>UTF-7</primary></indexterm>
ISO 10646'yı UTF-7 olarak kodlamak üzere bazı çalışmalarda yapılmıştır, ancak günümüzde kullanılması gereken tek kodlama UTF-8 dir. Aslında, UTF-8 gelecekte desteklenen tek harici kodlama olacaktır. Evrensel olarak kullanılabilirliği anlaşılmıştır. Tek olumsuz yanı, bazı dillerin karakterlerini oluştururken kullanılan bayt dizgelerinin uzunluğu bu diller için kullanılan özel kodlamalara göre daha büyük yer harcanmasına sebep olmasıdır. Ancak Unicode sıkıştırma şeması gibi yönemlerle bu sorunlar da giderilecektir.
     </para></listitem></itemizedlist><para>
Sona kalan soru şudur: Kullanılacak kodlama ya da karakter kümesi nasıl seçilecektir?
Yanıt: Buna siz kendi kendinize karar veremezsiniz, bunu sistem geliştiricileri ile kullanıcıların çoğunluğunun yaptığı tercih belirler. Amaç birlikte çalışabilirlik olunca birinin kullandığını bir diğeri birlikte çalışabilmek için kullanacaktır. Bir kısıtlama yoksa seçim kullanıcıların ortak gereksinimlerine göre şekillenecektir.
Başka bir deyişle örneğin, bir projenin sadece Rusya'da kullanılacağı düşünülüyorsa KOI8-R ya da benzeri bir karakter kümesi kullanmak gerekir. Ama aynı proje örneğin Yunanistan'da da kullanılabilecekse, karakter kümesi seçimi herkesin gereksinimlerine yanıt verebilecek şekilde seçilmelidir.
   </para><para>
En geniş çözümü sağlayan, en genel karakter kümesi hangisi diye baktığımızda bunun ISO 10646 olduğunu görürüz.  Harici kodlama olarak UTF-8 kullanılır ve geçmişte kendi dillerini kullanmakta sorunları olan kullanıcıların sorunları kalmaz.
   </para><para>
Geniş karakter gösteriminin seçilmesi ile ilgili olarak son bir açıklama daha yapmak gerekir. Yukarıdaki açıklamaların ışığında doğal seçim Unicode veya ISO 10646 kullanmaktır dedik. Bu gerekli değildir ama en azından ISO C standardı tarafından cesaretlendiriliyoruz. Standart en azından <command>__STDC_ISO_10646__</command>
diye bir makro tanımlar ve bu makro sadece <command>wchar_t</command> türünün kodladığı ISO 10646 karakterlerinin kullanıldığı sistemlerde tanımlıdır. Bu sembolü tanımlamayarak geniş karakterli gösterimlerle ilgili kabuller yapılmasından kaçınılmalıdır. Yazılımcılar sadece C kütüphanesi tarafından sağlanan bu işlevleri kullandıklarında geniş karakterle ilgili olarak diğer sistemlerle bir uyumluluk sorunu yaşamazlar.
   </para>
  </chapter>

  <chapter xml:id="glibc-Charset-Function-Overview">
    <title>Karakter Kümesi İşlevlerine Bakış</title>
    <titleabbrev>Karakterlerle çalışmak için kullanılan işlevlere bir bakış</titleabbrev>
    <para>
Bir Unix C kütüphanesi karakter kümesi dönüşümleri için iki aile içinde toplanan üç farklı işlev kümesi içerir. İlk aile (en çok kullanılanı) ISO C90 standardında belirtilmiştir ve bundan dolayı Unix dünyasında taşınabilirdir. Maalesef bu aile en az kullanışlı olanıdır. Özellikle kütüphane geliştirirken (uygulamaların aksine) bu işlevlerden mümkün olduğunca kaçınılmalıdır.
   </para><para>
İkinci işlev ailesi, erken dönem Unix standartlarında (XPG2) görülür ve hala en son ve en büyük Unix standardı olan Unix 98'in de parçasıdır. Ayrıca en güçlü ve en kullanışlı işlevler kümesidir. Fakat biz, ISO C90 1. düzeltmesinde tanımlanan işlevlerle başlayacağız.
   </para>
  </chapter>

  <chapter xml:id="glibc-Restartable-multibyte-conversion">
    <title>Geridönüşümlü Çok Baytlı Dönüşüm</title>
    <titleabbrev>Geridönüşümlü çokbaytlı dönüşüm işlevleri</titleabbrev>
    <para>
ISO C standardı dizgeleri çokbaytlı gösterimden geniş karakterli dizgelere dönüştürecek işlevler tanımlar. Bunların bir takım tuhaf özellikleri vardır:
   </para><para><itemizedlist><listitem><para>
Çok baytlı kodlama için varsayılan karakter kümesi işlevlere argüman olarak belirtilmez. Bunun yerine yerelin <command>LC_CTYPE</command>
kategorisi tarafından belirtilen karakter kümesi kullanılır; bkz. <xref linkend="glibc-Locale-Categories"/>.
     </para></listitem><listitem><para>
Bir defada bir karakterden fazlası ile çalışan işlevler argüman olarak boş karakter sonlandırmalı dizgeleri gerektirirler (örneğin, metin bloklarının dönüşümü uygun bir yere bir boş karakter eklenmedikçe yapılmaz). GNU C kütüphanesi bir boyut belirtmeye imkan veren oluşumları içeriyor olsa da bunlar yine de genellikle sonlandırılmış dizgeler beklerler.
     </para></listitem></itemizedlist></para><para>
Bu sınırlamalara rağmen ISO C işlevleri çoğu bağlamda kullanılabilir. Grafik kullanıcı arayüzlerinde örneğin, metin basit ASCII değilse bir geniş karakterli dizge olarak gösterilmesinin gerektiği durumlar için kullanılacak işlevlerin bulunması gerekir.
Metin, çevirileri içeren bir dosyadan gelmeli, kullanıcı çeviriyi kullanabileceği yerele ve dolayısıyla ayrıca kullanacağı harici kodlamaya karar vermelidir. Böyle bir durumda (ve birçok başka durumda), burada açıklanan işlevler çok uygundur. Dönüşümleri uygularken daha özgür olmak isterseniz  <command>iconv</command> işlevlerine de bir bakın: <xref linkend="glibc-Generic-Charset-Conversion"/>.
   </para>
    <sect1 xml:id="glibc-Selecting-the-Conversion">
      <title>Dönüşüm Seçimi</title>
      <titleabbrev>Dönüşüm ve özelliklerinin seçimi</titleabbrev>
<indexterm scope="glibc-pg"><primary>limits.h</primary></indexterm>
<indexterm scope="glibc-pg"><primary>stdlib.h</primary></indexterm>
      <para>
Burada açıklayacağımız işlevler tarafından uygulanan dönüşümlerde önceki bölümde bahsettiğimiz gibi seçilen yerelin <command>LC_CTYPE</command> kategorisi tarafından belirlenen karakter kümesi kullanılır. Her yerelin (<command>localedef</command>'e argüman olarak verilen) kendi karakter kümesi vardır ve bunun harici çokbaytlı kodlamalardan biri olduğu kabul edilir. Geniş karakterli karakter kümesi daima UCS-4'tür, en azından GNU sistemlerinde böyledir.
    </para><para>
Her çokbaytlı karakter kümesinin karakteristik özelliklerinden biri, bir karakteri göstermek için gereken en fazla bayt sayısıdır. Bu, dönüşüm işlevlerinin kullanıldığı bir kodu yazarken oldukça önemli bir bilgidir (örnekleri aşağıda görülebilir). Bu bilgiyi sağlamak için ISO C standardı iki makro tanımlar.
    </para><para xml:id="glibc-MB_LEN_MAX">
<indexterm scope="glibc-vr"><primary>MB_LEN_MAX</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>int <command>MB_LEN_MAX</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
<command>MB_LEN_MAX</command> desteklenen yerellerin hepsi için tek bir karakterin çokbaytlı gösteriminde olabilecek en fazla bayt sayısını belirtir. Bir derleme zamanı sabitidir ve <filename>limits.h</filename> başlık dosyasında tanımlanmıştır.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-MB_CUR_MAX">
<indexterm scope="glibc-vr"><primary>MB_CUR_MAX</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>int <command>MB_CUR_MAX</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
<command>MB_CUR_MAX</command> o an geçerli olan yereldeki bir çokbaytlı karakterde olabilecek en fazla bayt sayısı olan bir pozitif tamsayı ifadeye genişletilir. Değeri hiçbir zaman <command>MB_LEN_MAX</command>'dan büyük olamaz. <command>MB_LEN_MAX</command>'ın tersine bu makronun bir derleme zamanı sabiti olması gerekmez ve GNU C kütüphanesinde de değildir.
    </para><para>
<command>MB_CUR_MAX</command> <filename>stdlib.h</filename> başlık dosyasında tanımlanmıştır.
      </para></funcdescr></funcsynopsis>
    </para><para>
ISO C derleyicileri değişken uzunluklu dizi tanımlarına kesinlikle izin vermediğinden iki farklı makro gereklidir, ancak yine de özdevimli bellek ayırmadan kaçınılması istenir. Kodun bu eksik parçası aşağıdaki soruna yol açar.
    </para><para><screen>
{
  char tampon[MB_LEN_MAX];
  ssize_t uzunluk = 0;

  while (! feof (fp))
    {
      fread (tampon[uzunluk], 1, MB_CUR_MAX - uzunluk, fp);
      /* … tamponu işle */
      uzunluk -= kullanilan;
    }
}
</screen></para><para>
İç döngüdeki kod tek bir çokbaytlı karaktere çevrilmesi için <varname>tampon</varname> dizisinde daima yeterli bayt bulunduğu varsayımına dayanır. Çoğu derleyici değişken uzunluktaki dizilere izin vermediğinden <varname>tampon</varname> dizisi sabit uzunluktadır. <command>fread</command> çağrısı <varname>tampon</varname> dizisinde daima <command>MB_CUR_MAX</command> bayt olduğundan emin olarak yapılır. Burada <command>MB_CUR_MAX</command> bir derleme zamanı sabiti değilse bir sorun çıkmaz.
      </para>
    </sect1><sect1 xml:id="glibc-Keeping-the-state">
      <title>Durumun saklanması</title>
      <titleabbrev>Dönüşüm durumunun gösterimi</titleabbrev>
      <para>
<indexterm scope="glibc-cp"><primary>durumsal</primary></indexterm>
Bu kısmın başlarında <wordasword>durumsal</wordasword> kodlama kullanılan karakter kümelerinden bahsedilmişti. Bunların metnin içindeki kodlanmış değerleri öncekilere bir şekilde bağımlıdır.
    </para><para>
Dönüşüm işlevleri bir metni birden fazla adımda dönüştürebildiklerinden bu bilgiyi işlevlerin bir çağrısından diğerine aktarmamız gerekir.
    </para><para xml:id="glibc-mbstate_t">
<indexterm scope="glibc-tp"><primary>mbstate_t</primary></indexterm>
<indexterm scope="glibc-cp"><primary>öteleme durumu</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü">
<funcdef><command>mbstate_t</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
<command>mbstate_t</command> türünde bir değişken bir dönüşüm işlevi çağrısından diğerine aktarılması gerekli olan <wordasword>öteleme durumu</wordasword> hakkında tüm bilgiyi içerir.
    </para><para>
<indexterm scope="glibc-pg"><primary>wchar.h</primary></indexterm>
<command>mbstate_t</command> türü <filename>wchar.h</filename> başlık dosyasında tanımlanmıştır ve ISO C90 standardının 1. düzeltmesinde bulunur.
      </para></funcdescr></funcsynopsis>
     </para><para>
<command>mbstate_t</command> türünde nesneleri kullanırken yazılımcı bu nesneleri tanımlamalı (normalde yığıt üzerinde yerel değişkenler olarak) ve dönüşüm işlevine göstericisi ile aktarmalıdır. O anki çokbaytlı karakter durumsal ise dönüşüm işlevi bu yolla nesneyi güncelleyebilir.
    </para><para>
Durum nesnesini belirli bir duruma koyacak bir ilklendirici ya da bu işleme özel bir işlev yoktur. Kurallar gereğince nesne daima ilk kullanımdan önce ilk durumu göstermeli ve bu aşağıdaki gibi bir kodla değişkeni tamamen temizleyerek yapılmalıdır:
    </para><para>
<screen>
{
  mbstate_t durum;
  memset (&amp;durum, '\0', sizeof (durum));
  /* bundan sonra <varname>durum</varname> kullanılabilir.  */
  …
}
</screen></para><para>
Çıktıyı üretecek dönüşüm işlevlerini kullanırken çoğunlukla o anki durumun ilk durum olup olmadığına bakılması gerekir. Örneğin, dizilimin bir noktasında durumu ilk duruma ayarlayacak önceleme dizilimlerinin kullanılıp kullanılmayacağına karar vermek için bu gereklidir. İletişim protokolleri genellikle bunu gerektirir.
    </para><para xml:id="glibc-mbsinit">
<indexterm scope="glibc-fn"><primary>mbsinit</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>mbsinit</command></funcdef>
<paramdef>(const mbstate_t *<emphasis>ps</emphasis>)</paramdef>
</funcprototype><funcdescr><para>
<command>mbsinit</command> işlevi göstericisi <varname>ps</varname> olan nesnenin ilk durumda olup olmadığını saptamakta kullanılır. <varname>ps</varname> bir boş göstericiyse ya da nesne ilk durumdaysa dönen değer sıfırdan farklı olur. Aksi takdirde sıfır döner.
    </para><para>
<command>mbsinit</command> işlevi <filename>wchar.h</filename> başlık dosyasında tanımlanmıştır ve ISO C90 standardının 1. düzeltmesinde bulunur.
       </para></funcdescr></funcsynopsis>
       </para><para>
<command>mbsinit</command> işlevi kullanılan bir kod çoğunlukla aşağıdakine benzer:
    </para><para>
<screen>
{
  mbstate_t durum;
  memset (&amp;durum, '\0', sizeof (durum));
  /* Burada <varname>durum</varname> kullanılır.  */
  …
  if (! mbsinit (&amp;durum))
    {
      /* ilk duruma döndürecek kod.  */
      const wchar_t bos[] = L"";
      const wchar_t *kaynak = bos;
      wcsrtombs (cikistamponu, &amp;kaynak, ciktampuzun, &amp;durum);
    }
  …
}
</screen></para><para>
<dicterm><english>escape sequence</english><turkish>önceleme dizilimi</turkish></dicterm>
İlk duruma geri dönmeyi sağlayacak olan önceleme dizilimini çıktılayacak kod ilginçtir. <command>wcsrtombs</command> işlevi gerekli çıktılama kodunu (bkz. <xref linkend="glibc-Converting-Strings"/>) saptamakta kullanılabilir.
</para><para><note><para>Geniş karakterli kodlama durumsal olmadığından GNU sistemlerinde çokbaytlı metni geniş karakterli metne dönüştürmek için bu ek eylemin uygulanması gerekli değildir. Ancak bir durumsal kodlama kullanarak <command>wchar_t</command> yapılmasının yasaklanmasına hiçbir standartta değinilmemiştir.</para></note>
      </para>
    </sect1><sect1 xml:id="glibc-Converting-a-Character">
      <title>Bir Karakterin Dönüştürülmesi</title>
      <titleabbrev>Karakterlerin tek tek dönüştürülmesi</titleabbrev>
      <para>
Çok temel dönüşüm işlevlerinin çoğu tek karakter ile çalışır. Lütfen aklınızdan çıkarmayın, tek karakter her zaman tek bayt anlamına gelmez. Ancak çoğunlukla çokbaytlı karakter kümeleri tek baytlık karakterler içerdiğinden, baytları dönüştürmeye yarayan işlevler vardır. Sıklıkla, ASCII çokbaytlı karakter kümesinin bir alt kümesidir. Böyle bir senaryoda, her ASCII karakter kendini temsil eder, tüm diğer karakterlerin en azından ilk baytı  0 ile 127 arasındaki karakterlerden biri olur.
    </para><para xml:id="glibc-btowc">
<indexterm scope="glibc-fn"><primary>btowc</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>wint_t <command>btowc</command></funcdef>
<paramdef>(int <varname>c</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>btowc</command> ("byte to wide character" kısaltması) işlevi,
ilk öteleme durumundaki tek baytlık geçerli bir <varname>c</varname> karakterini o an geçerli olan <command>LC_CTYPE</command> yerelindeki dönüşüm kurallarına uygun olarak geniş karakter eşdeğerine dönüştürür.
    </para><para>
Eğer <literal>(unsigned char) </literal><varname>c</varname> geçerli olmayan tek baytlık bir çokbaytlı karakter ise ya da <varname>c</varname> karakteri <command>EOF</command> ise işlev <command>WEOF</command> ile döner.
    </para><para>
<varname>c</varname> karakterinin geçerliliğinin sadece ilk öteleme durumu için sınandığını lütfen unutmayın. Durum bilgisinin alınmasında kullanılacak bir <command>mbstate_t</command> nesnesi yoktur ve ayrıca işlev herhangi bir sabit durum kullanmaz.
    </para><para>
<indexterm scope="glibc-pg"><primary>wchar.h</primary></indexterm>
<command>btowc</command> işlevi ISO C90 standardının 1. düzeltmesinde tanımlanmış ve <filename>wchar.h</filename> başlık dosyasına bildirilmiştir.
</para></funcdescr></funcsynopsis></para><para>
Tek baytlık değerlerin daima ilk durumuna göre yorumlanması sınırlamasına rağmen bu işlev aslında çoğu zaman oldukça kullanışlıdır. Karakterlerin çoğu ya tamamen tek baytlık karakter kümelerindendir ya da ASCII'ye göre bir genişletmedir. Bu bilgilerden sonra aşağıdaki gibi bir kod yazmak mümkündür (bu özel örnek çok kullanışlıdır):
    </para><para>
<screen>wchar_t *
itow (unsigned long int val)
{
  static wchar_t buf[30];
  wchar_t *wcp = &amp;buf[29];
  *wcp = L'\0';
  while (val != 0)
    {
      *--wcp = btowc ('0' + val % 10);
      val /= 10;
    }
  if (wcp == &amp;buf[29])
    *--wcp = L'0';
  return wcp;
}
</screen></para><para>
Böylesine karmaşık bir gerçeklemeyi kullanmak neden gerekli ve neden basitçe <command>'0' + val % 10</command> bir geniş karaktere dönüştürülmüyor? Yanıtı, <command>wchar_t</command> türünde karakterler üzerinde bu çeşit aritmetik işlemler uygulandığında sonuç garanti değildir de ondan. Diğer durumlarda ise baytlar derleme zamanında sabit değildir, bu nedenle derleyici işlem yapamaz. Bu gibi durumlarda <command>btowc</command> kullanmak gereklidir.
    </para><para>
Aksi yönde dönüşüm için de bir işlev vardır.
    </para><para xml:id="glibc-wctob">
<indexterm scope="glibc-fn"><primary>wctob</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>wctob</command></funcdef>
<paramdef>(wint_t <varname>wc</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>wctob</command> ("wide character to byte" kısaltması) işlevi parametre olarak geçerli bir geniş karakter alır. Bu karakterin ilk durumu bir bayt uzunlukta ise işlevin dönüş değeri karakterin kendisi olacaktır. Aksi takdirde <command>EOF</command> döner.
    </para><para>
<indexterm scope="glibc-pg"><primary>wchar.h</primary></indexterm>
<command>wctob</command> işlevi ISO C90 standardının 1. düzeltmesinde tanımlanmış ve <filename>wchar.h</filename> başlık dosyasına bildirilmiştir.
</para></funcdescr></funcsynopsis></para><para>
Karakterleri tek tek çokbaytlı gösterimden geniş karakterli gösterime ya da tersine dönüştürecek daha genel amaçlı işlevler de vardır. Bu işlevler çokbaytlı gösterimin uzunluğu ile ilgili bir sınırlamaya sahip değillerdir ve ayrıca ilk durumda olmayı gerektirmez.
    </para><para xml:id="glibc-mbrtowc">
<indexterm scope="glibc-fn"><primary>mbrtowc</primary></indexterm>
<indexterm scope="glibc-cp"><primary>stateful</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>size_t <command>mbrtowc</command></funcdef>
<paramdef>(wchar_t *restrict    <varname>pwc</varname>,
 const char *restrict <varname>dizge</varname>,
 size_t               <varname>n</varname>,
 mbstate_t *restrict  <varname>ps</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>mbrtowc</command> ("multibyte restartable to wide character" kısaltması) işlevi, <varname>dizge</varname> ile gösterilen dizgedeki sonraki çokbaytlı karakteri geniş karaktere dönüştürür ve <varname>pwc</varname> ile gösterilen geniş karakterli dizge içinde saklar. Dönüşüm o an geçerli olan <command>LC_CTYPE</command> ile belirtilen yerele bağlı olarak gerçekleşir. Yerelde kullanılan karakter kümesi dönüşüm için bir durum bilgisi gerektiriyorsa, bu bilgi  <varname>ps</varname> ile gösterilen nesne ile belirtilebilir. <varname>ps</varname> bir boş gösterici ise, işlev tarafından bir durağan dahili durum değişkeni kullanılır.
    </para><para>
Sonraki çokbaytlı karakter bir boş geniş karakter ise, işlevin dönüş değeri sıfırdır ve durum nesnesi sonrasında ilk durumdadır. Eğer sonraki <varname>n</varname> veya daha az bayt doğru çokbaytlı karakter biçimindeyse, dönüş değeri, çokbaytlı karakter biçimindeki <varname>dizge</varname>’den başlayan baytların sayısıdır. Dönüşüm durumu dönüşümde tüketilen baytlara göre güncellenir. Her iki durumda da geniş karakter (ya <command>L'\0'</command> ya da dönüşümde bulunan)  <varname>pwc</varname> bir boş gösterici değilse, <varname>pwc</varname> ile gösterilen dizgede saklanır.
    </para><para>
Çok baytlı dizgenin ilk <varname>n</varname> baytının geçerli bir çokbaytlı karakter olduğu varsayılmış ama dönüşüm için <varname>n</varname>’den daha fazla bayt gerekiyorsa işlevin dönüş değeri <command>(size_t) -2</command>’dir ve hiçbir değer saklanmaz. Girdi gereğinden fazla öteleme durumu içerebildiğinden <varname>n</varname>, <command>MB_CUR_MAX</command>'dan büyük ya da ona eşit bir değer içerdiğinde bile bu durumun oluşabileceğini unutmayınız.
    </para><para>
Çokbaytlı dizgenin ilk <varname>n</varname> baytının geçerli bir çokbaytlı karakter olduğu varsayılmamışsa, hiçbir değer saklanmaz, <command>errno</command> genel değişkenine <command>EILSEQ</command> değeri atanır ve işlev  <command>(size_t) -1</command> ile döner. Dönüşüm durumu bundan sonra tanımsızdır.
    </para><para>
<indexterm scope="glibc-pg"><primary>wchar.h</primary></indexterm>
<command>mbrtowc</command> işlevi ISO C90 standardının 1. düzeltmesinde tanımlanmış ve <filename>wchar.h</filename> başlık dosyasına bildirilmiştir.
</para></funcdescr></funcsynopsis></para><para>
<command>mbrtowc</command> işlevinin kullanımı basittir. Bir çokbaytlı dizgeyi bir geniş karakterli dizgeye kopyalarken küçük harfleri büyük harfe çeviren bir işlev şöyle olur (bu tam bir uygulama değildir; sadece örnektir; hata denetimi yapılmaz ve bellek kaçağı olabilir):
    </para><para>
<screen>
wchar_t *
mbstouwcs (const char *s)
{
  size_t uzunluk = strlen (s);
  wchar_t *sonuc = malloc ((uzunluk + 1) * sizeof (wchar_t));
  wchar_t *wcp = sonuc;
  wchar_t tmp[1];
  mbstate_t durum;
  size_t bayt_sayisi;

  memset (&amp;durum, '\0', sizeof (durum));
  while ((bayt_sayisi = mbrtowc (tmp, s, uzunluk, &amp;durum)) > 0)
    {
      if (bayt_sayisi >= (size_t) -2)
        /* Geçersiz girdi dizgesi.  */
        return NULL;
      *wcp++ = towupper (tmp[0]);
      uzunluk -= bayt_sayisi;
      s += bayt_sayisi;
    }
  return souc;
}
</screen></para><para>
<command>mbrtowc</command> kullanımı temizdir.  Tek bir geniş karakter <varname>tmp</varname><literal>[0]</literal> içinde saklanır ve tüketilen baytların sayısı <varname>bayt_sayisi</varname> değişkeninde saklanır. Eğer dönüşüm başarılı olursa, geniş karakterin büyük harf karşılığı <varname>sonuc</varname> dizisinde saklanır ve girdi dizgesinin göstericisi ile kullanılabilir baytların sayısı ayarlanır.
    </para><para>
<command>mbrtowc</command> hakkında belirsiz kalan tek şey sonuç için belleği ayırmakta kullanılan yöntem olabilir. Yukarıdaki kod, çokbaytlı girdi dizgesindeki baytların dönüşüm sonrası elde edilen geniş karakterli dizgenin bayt sayısından büyük ya da eşit olduğu varsayımına dayandırılmıştır. Bu yöntem sonucun uzunluğu hakkında iyimserdir ve çok sayıda geniş karakterli dizge ya da çok uzun bir dizge bu yöntemle oluşturulmaya çalışılırsa ek bellek ayrılması gerekebilecektir. Ayrılan bellek bloğu döndürülmeden önce doğru boyuta ayarlanabilir, fakat en doğrusu sonucun gerektirdiği kadar belleği baştan ayırmaktır. Umulanın aksine, elde edilecek geniş karakterli dizgenin boyunu çokbaytlı dizgenin boyutlarına bakarak elde edebilecek bir işlev yoktur. Yine de, işlemin bir parçası olabilecek bir işlev vardır.
    </para><para xml:id="glibc-mbrlen">
<indexterm scope="glibc-fn"><primary>mbrlen</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>size_t <command>mbrlen</command></funcdef>
<paramdef>(const char *restrict <varname>dizge</varname>,
 size_t               <varname>n</varname>,
 mbstate_t           *<varname>ps</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>mbrlen</command> ("multibyte restartable length" kısaltması) işlevi, <varname>dizge</varname> ile başlayan en fazla <varname>n</varname> baytlık sonraki geçerli ve çokbaytlı tam karakterin bayt sayısını hesaplar.
    </para><para>
Sonraki çokbaytlı karakter boş geniş karaktere karşılıksa, dönüş değeri sıfırdır. Sonraki <varname>n</varname> bayt, geçerli bir çokbaytlı karakter biçimindeyse, bu çokbaytlı karakteri oluşturan baytların sayısı ile döner.
    </para><para>
Eğer ilk <varname>n</varname> geçerli bir çokbaytlı karakter için yetersizse, dönüş değeri <command>(size_t) -2</command>’dir. Aksi halde, çokbaytlı karakter dizilimi geçersizdir ve dönüş değeri <command>(size_t) -1</command>’dir.
    </para><para>
Çokbaytlı dizilim <varname>ps</varname> ile gösterilen nesne ile belirtilen duruma göre yorumlanır. <varname>ps</varname> bir boş gösterici ise <command>mbrlen</command>'e özgü bir dahili durum nesnesi kullanılır.
    </para><para>
<indexterm scope="glibc-pg"><primary>wchar.h</primary></indexterm>
<command>mbrlen</command> işlevi ISO C90 standardının 1. düzeltmesinde tanımlanmış ve <filename>wchar.h</filename> başlık dosyasına bildirilmiştir.
</para></funcdescr></funcsynopsis></para><para>
Dikkatli okuyucular <command>mbrlen</command> işlevinin şöyle gerçeklenebileceğini farkedecektir:
    </para><para>
<screen>
mbrtowc (NULL, s, n, ps != NULL ? ps : &amp;dahili)
</screen></para><para>
Bu doğrudur ve aslında resmi belirtimde bahsedilendir. Şimdi, bir çokbaytlı karakter dizisinden bir geniş karakterli dizgenin uzunluğunun nasıl saptanabileceğine bakalım. İşlev doğrudan kullanılabilir değildir, fakat <command>mbslen</command> isimli bir işlevi onu kullanarak tanımlayabiliriz:
    </para><para>
<screen>
size_t
mbslen (const char *s)
{
  mbstate_t durum;
  size_t sonuc = 0;
  size_t bayt_sayisi;
  memset (&amp;durum, '\0', sizeof (durum));
  while ((bayt_sayisi = mbrlen (s, MB_LEN_MAX, &amp;durum)) > 0)
    {
      if (bayt_sayisi >= (size_t) -2)
        /* Birşeyler yanlış.  */
        return (size_t) -1;
      s += bayt_sayisi;
      ++sonuc;
    }
  return sonuc;
}</screen></para><para>
Bu işlev, dizgedeki her çokbaytlı karakter için basitçe <command>mbrlen</command> çağrısı yapar ve işlev çağrılarını sayar. Burada <command>MB_LEN_MAX</command>'ı <command>mbrlen</command>'in boyut argümanı olarak kullandığımıza dikkat edin. Bu kabul edilebilir, çünkü;
   </para><para><orderedlist numeration="loweralpha"><listitem>
Bu değer en uzun çokbaytlı karakter diziliminden büyüktür.
   </listitem><listitem>
<varname>dizge</varname> dizgesinin boş bayt ile bittiğini biliyoruz. Bu sonlandırıcı bayt başka bir çokbaytlı karakter diziliminin parçası olamaz ama bir geniş boş karakteri temsil edebilir.
   </listitem></orderedlist></para><para>
Diğer taraftan, <command>mbrlen</command> işlevi geçersiz belleği asla okumaz.
    </para><para>
Şimdi bu işlev kullanılabilir (daha temiz olarak, bu işlev GNU C kütüphanesinin bir parçası <emphasis>değildir</emphasis>). Çok baytlı karakterli <varname>dizge</varname> dizgesinden dönüştürülerek elde edilecek geniş karakterli dizgenin saklanacağı alanın genişliğini hesaplayabiliriz:
    </para><para>
<screen>
wcs_bytes = (mbslen (s) + 1) * sizeof (wchar_t);
</screen></para><para>
<command>mbslen</command> işlevinin verimsiz olduğunu unutmayın. <command>mbstouwcs</command>'nin <command>mbslen</command> ile gerçeklenmesi çokbaytlı karakterli girdi dizgesine iki defa dönüşüm uyguladığından bu dönüşüm masraflıdır. Bu durumda, kullanımı daha kolay ama işlemi iki defa yapmayan bir yöntem düşünmek gerekir.
    </para><para xml:id="glibc-wcrtomb">
<indexterm scope="glibc-fn"><primary>wcrtomb</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>size_t <command>wcrtomb</command></funcdef>
<paramdef>(char *restrict      <varname>dizge</varname>,
 wchar_t             <varname>wc</varname>,
 mbstate_t *restrict <varname>ps</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>wcrtomb</command> ("wide character restartable to multibyte" kısaltması) işlevi tek bir geniş karakteri, bunun karşılığı olan çokbaytlı karakter dizgesine dönüştürür.
    </para><para>
<varname>dizge</varname> bir boş gösterici ise, işlev, <varname>ps</varname> ile gösterilen nesnedeki durum bilgisini (ya da işlevin dahili durum bilgisini) başlangıç durumuna sıfırlar. <varname>dizge</varname> boş bir gösterici olduğundan, bu aşağıdaki gibi bir çağrı ile  aşılabilir:
    </para><para>
<screen>wcrtombs (temp_buf, L'\0', ps)</screen>
    </para><para>
<command>wcrtomb</command> yeterince büyük olduğu garanti edilen bir dahili tampona yazabiliyorsa bunu yapar.
    </para><para>
Eğer <varname>wc</varname> bir boş geniş karakter ise, <command>wcrtomb</command> bunu yoksayar, eğer gerekliyse, <varname>ps</varname> durumunu ilk duruma getirecek bir öteleme diziliminin ardından tek bir boş karakter gelir ve  <varname>dizge</varname> dizgesinde saklanır.
    </para><para>
Aksi takdirde, bir bayt dizilimi (öteleme dizilimlerini de içerebilir) <varname>dizge</varname> dizgesine yazılır. Bu sadece <varname>wc</varname> geçerli bir geniş karakterse mümkündür (örneğin, yereli <command>LC_CTYPE</command> kategorisine göre seçilen karakter kümesindeki bir çokbaytlı gösterim). <varname>wc</varname> geçerli bir geniş karakter değilse, <varname>dizge</varname> dizgeside hiçbir şey saklanmaz, <command>(size_t) -1</command> döner.
    </para><para>
Bir hata oluşmazsa, işlev <varname>dizge</varname> dizgesinde saklanan baytların sayısı ile döner. Bu, öteleme durumlarını gösteren bütün baytları içerir.
    </para><para>
İşlevin arayüzünden biraz bahsetmek gerekirse: <varname>dizge</varname> dizgesinin uzunluğunu belirten bir parametre yoktur. Bunun yerine, işlev en azından <command>MB_CUR_MAX</command> baytın varlığını kabul eder. Çünkü tek bir karakterin ifade edilebileceği azami bayt sayısı budur. Bu durumda, çağrıcı yeterli yerin mevcut olduğuna emindir, aksi takdirde tampon taşması oluşabilirdi.
    </para><para>
<indexterm scope="glibc-pg"><primary>wchar.h</primary></indexterm>
<command>wcrtomb</command> işlevi ISO C90 standardının 1. düzeltmesinde tanımlanmış ve <filename>wchar.h</filename> başlık dosyasına bildirilmiştir.
</para></funcdescr></funcsynopsis></para><para>
<command>wcrtomb</command> işlevinin kullanımı <command>mbrtowc</command> işlevinin kullanımına göre daha kolaydır. Aşağıdaki örnekte, bir geniş karakterli dizge bir çokbaytlı dizgeye eklenmektedir. Tekrar belirtelim; kod kullanılabilir (veya doğru) değildir, bazı sorunlara ve kullanıma bir örnektir.
    </para><para>
<screen>
char *
mbscatwcs (char *s, size_t len, const wchar_t *ws)
{
  mbstate_t state;
  /* Mevcut dizgenin uzunluğunu bulalım.  */
  char *wp = strchr (s, '\0');
  len -= wp - s;
  memset (&amp;state, '\0', sizeof (state));
  do
    {
      size_t nbytes;
      if (len &lt; MB_CUR_LEN)
        {
          /* Sonraki karakterin tampona sığacağını garanti etmiyoruz.
             Bu durumda bir hata dönebilir.  */
          errno = E2BIG;
          return NULL;
        }
      nbytes = wcrtomb (wp, *ws, &amp;state);
      if (nbytes == (size_t) -1)
        /* Dönüşümde hata.  */
        return NULL;
      len -= nbytes;
      wp += nbytes;
    }
  while (*ws++ != L'\0');
  return s;
}</screen></para><para>
İlk işlevde <varname>s</varname> dizisi içindeki dizgenin sonu bulunmaktadır. <command>strchr</command> işlevi bunu çok iyi yapar, çünkü çokbaytlı karakter gösterimlerinde bir gereklilik olarak boş bayt kendisini temsil etmesi (bu bağlamda dizgenin sonu) dışında bir amaçla asla kullanılmaz.
    </para><para>
Durum nesnesini ilklendirip döngüye girilince ilk iş olarak <varname>s</varname> dizisinde yeterince yer olup olmadığına bakıyoruz. <command>MB_CUR_LEN</command> bayttan daha az yer varsa işlevden çıkıyoruz. Bu daima en iyi seçim olmasa da bizim başka bir şansımız yok. <command>MB_CUR_LEN</command> bayttan daha az yer olabilir ve sonraki çokbaytlı karakter sadece bir bayt uzunlukta olabilirdi. Bu durumda tamponda yeterince yerin varlığına karar verecek ek kod nedeniyle işlev çok geç dönerdi. Bu çözüm pek kullanışlı değildir, daha doğru ama çok yavaş bir çözüm olurdu.
    </para><para>
<screen>
...
if (len &lt; MB_CUR_LEN)
{
  mbstate_t temp_state;
  memcpy (&amp;temp_state, &amp;state, sizeof (state));
  if (wcrtomb (NULL, *ws, &amp;temp_state) > len)
  {
    /* Sonraki karakterin tampona sığacağını garanti etmiyoruz.
             Bu durumda bir hata dönebilir.  */
    errno = E2BIG;
    return NULL;
  }
}
...
</screen></para><para>
Burada tamponun taşabileceği bir dönüşüm uyguluyoruz, yani tamponun boyutu hakkındaki kararı işlemi yaptıktan sonra veriyoruz. <command>wcrtomb</command> çağrısındaki hedef tampon için <command>NULL</command> argümanına dikkat edin; bu noktada dönüştürülen metinle ilgilenmediğimizden, bu, bu sorunu aşmak için iyi bir yöntemdir. Bu kod parçasındaki en lüzumsuz şey dönüşüm durum nesnesinin yinelenmesidir; ancak eğer sonraki çokbaytlı karakteri yoksayacak bir değişiklik gerekliyse gerçek dönüşümde aynı öteleme durum değişikliğinin uygulanmasını isteriz. Bunun yanında, ilk öteleme durum bilgisini korumak zorundayız.
    </para><para>
Bu soruna çok sayıda  ve çok daha iyi çözümler vardır. Bu örnek sadece öğrenim amacıyla hazırlanmıştır.
      </para>
    </sect1><sect1 xml:id="glibc-Converting-Strings">
      <title>Dizge Dönüşümleri</title>
      <titleabbrev>Çokbaytlı karakterlerle geniş karakterler arasındaki dönüşümler.</titleabbrev>
      <para>
Önceki bölümde bahsedilen işlevler bir defada sadece tek bir karakteri dönüştürmek içindi. Gerçekte uygulanan çoğu işlem dizgeler üzerinde yapılır ve ISO C standardı dizgelerin tamamının dönüşümlerini de tanımlamıştır. Bununla birlikte, tanımlı işlevler bazı sınırlamalara sahiptir; ancak, GNU C kütüphanesi bazı önemli durumlarda yardımcı olabilecek bazı genişletmeler içerir.
    </para><para xml:id="glibc-mbsrtowcs">
<indexterm scope="glibc-fn"><primary>mbsrtowcs</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>size_t <command>mbsrtowcs</command></funcdef>
<paramdef>(wchar_t *restrict     <varname>hedef</varname>,
 const char **restrict <varname>kaynak</varname>,
 size_t                <varname>uzunluk</varname>,
 mbstate_t *restrict   <varname>ps</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>mbsrtowcs</command> işlevi ("multibyte string restartable to wide character string" kısaltması) <varname>*kaynak</varname> içindeki boş karakter sonlandırmalı çokbaytlı karakter dizgesini eşdeğer geniş karakter dizgesine dönüştürür. Dönüşüm, <varname>ps</varname> ile gösterilen nesnedeki  ya da <varname>ps</varname> bir boş gösterici ise <command>mbsrtowcs</command> içindeki dahili durum bilgisi kullanılarak başlatılır. İşlev dönmeden önce, durum nesnesi son karakter dönüştürüldükten sonraki durumla güncellenir. Sonlandırıcı boş karakter işlenmişse durum, ilk durum olur.
    </para><para>
<varname>hedef</varname> bir boş gösterici değilse, sonuç <command>mbsrtowcs</command> ile gösterilen dizide saklanır; aksi takdirde, dönüşüm sonucu bir iç tamponda saklanmış olacağından sonuç kullanılabilir olmayacaktır.
    </para><para>
<varname>hedef</varname> dizgesi <varname>uzunluk</varname> geniş karakterlik olarak belirlenmişse, girdi dizgesinin dönüştürülen kısmı <varname>uzunluk</varname> geniş karakterlik olduğunda dönüşüm durdurulur ve <varname>uzunluk</varname> döner. <varname>hedef</varname> bir boş dizge ise <varname>uzunluk</varname> anlamlı değildir.
    </para><para>
Eksik dönüşümlü bir dönüşün sebeplerinden biri de girdi dizgesinin geçersiz çokbaytlı dizilim içermesidir. Bu durumda <command>errno</command> genel değişkenine  <command>EILSEQ</command> değeri atanarak işlev, <command>(size_t) -1</command> ile döner.
    </para><para>
Tüm diğer durumlarda işlev, bu çağrı ile dönüştürülmüş geniş karakterlerin sayısı ile döner. <varname>hedef</varname> boş değilse, <command>mbsrtowcs</command> işlevi <varname>kaynak</varname> ile ya bir boş gösterici (girdi dizgesinde boş karaktere erişilmişse) ya da son dönüştürülen çokbaytlı karakterden sonraki baytın adresini döndürür.
    </para><para>
<indexterm scope="glibc-pg"><primary>wchar.h</primary></indexterm>
<command>mbsrtowcs</command> işlevi ISO C90 standardının 1. düzeltmesinde tanımlanmış ve <filename>wchar.h</filename> başlık dosyasında bildirilmiştir.
</para></funcdescr></funcsynopsis></para><para>
<command>mbsrtowcs</command> işlevinin tanımı önemli bir sınırlama içerir. <varname>hedef</varname>'in bir boş karakter sonlandırmalı dizge içermesi gereksinimi metin içeren tamponlarda dönüştürme yapmak isterseniz sorunlara sebep olur. Bir tampon normalde, boş karakter sonlandırmalı dizgeler değil, herbiri satırsonu karakteri ile biten satırlar içerir. Şimdi bir işlevin tampon içindeki satırlardan birini dönüştürmesini istediğimizi varsayalım. Satır boş karakterle bitmediğinden kaynak gösterici değiştirilmemiş metin tamponunu doğrudan gösteremez. Bunun anlamı: Ya <command>mbsrtowcs</command> çağrısı sırasında uygun bir yere boş karakter yerleştirilmeli (bu, salt okunur tamponlarda ve çok evreli uygulamalarda yapılamaz) ya da satır, boş karakterle sonlandırılmış olarak başka bir tampona kopyalanmalıdır. <varname>uzunluk</varname> parametresine belli bir değer atayarak dönüştürülecek karakterlerin sayısını sınırlamak genellikle mümkün değildir. Her çokbaytlı karakterin kaç bayttan oluştuğu bilinemediğinden sadece tahmin yapılabilir.
    </para><para>
<indexterm scope="glibc-cp"><primary>durumsal</primary></indexterm>
Satırsonu karakterinden sonra bir boş karakter koyarak satırın sonlandırılması ile ilgili olarak çok tuhaf sonuçlara sebep olan bir sorun hala mevcuttur. Yukarıda <command>mbsrtowcs</command> işlevinin açıklamasında bahsedildiği gibi girdi dizgesinin sonundaki boş karakter işlendikten sonra durumun ilk öteleme durumu olacağı garanti edilmiştir. Fakat bu boş karakter gerçekte metnin bir parçası değildir (yani, orjinal metinde satırsonu karakterinden sonraki dönüşüm durumu ilk öteleme durumundan farklı olacaktı ve sonraki satırın ilk karakteri bu durum kullanarak kodlanacaktı). Diğer taraftan, dönüşüm boş baytta duracağından (öteleme durumu sıfırlanacağından) gerçekte olması gereken durum bilgisi kaybolacaktır. Günümüzdeki çoğu karakter kümesi bir satırsonu karakterinden sonraki öteleme durumunun ilk durum olmasını gerektirse de bu kesin bir garanti değildir. Basitçe, metnin üzerinde çalışılan parçasının boş karakterle sonlandırılması her zaman uygun bir çözüm değildir ve genellikle hiç kullanılmaz.
    </para><para>
Soysal dönüşüm arayüzü (<xref linkend="glibc-Generic-Charset-Conversion"/>) bu sınırlamaya sahip değildir (basitçe tamponlarla çalışır, dizgelerle değil) ve GNU C kütüphanesi girdi dizgesinde işlenecek baytların azami sayısının belirtilebildiği ek parametreler alan işlevler içerir. Bu yolla, <command>mbsrtowcs</command> işlevinin yukarıdaki örneğindeki sorun, satır uzunluğu saptanıp bu uzunluk işleve aktarılarak çözülebilir.
    </para><para xml:id="glibc-wcsrtombs">
<indexterm scope="glibc-fn"><primary>wcsrtombs</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>size_t <command>wcsrtombs</command></funcdef>
<paramdef>(char *restrict           <varname>hedef</varname>,
 const wchar_t **restrict <varname>kaynak</varname>,
 size_t                   <varname>uzunluk</varname>,
 mbstate_t *restrict      <varname>ps</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>wcsrtombs</command> işlevi ("wide character string restartable to multibyte string" kısaltması) boş karakter sonlandırmalı bir geniş karakter dizgesi olan <varname>*kaynak</varname>'ı eşdeğeri olan çokbaytlı karaktere dönüştürür ve sonucu <varname>hedef</varname> ile gösterilen dizide saklar. Boş geniş karakter ayrıca dönüştürülür. Dönüşüm, <varname>ps</varname> ile gösterilen nesnedeki  ya da <varname>ps</varname> bir boş gösterici ise <command>wcsrtombs</command> içindeki dahili durum bilgisi kullanılarak başlatılır. <varname>hedef</varname> bir boş gösterici ise dönüşüm yine yapılır ama sonuç döndürülmez. Girdi dizgesindeki tüm karakterler dönüşütürülmüşse ve <varname>hedef</varname> bir boş gösterici değilse <varname>kaynak</varname> göstericisi bir boş gösterici olarak döner.
    </para><para>
Geniş karakterlerden birinin geçerli bir çokbaytlı karakter eşdeğeri yoksa dönüşüm durdurulur ve <command>errno</command> genel değişkenine <command>EILSEQ</command> değeri atanarak işlev <command>(size_t) -1</command> ile döner.
    </para><para>
İşlemin eksik kalmasına başka bir sebep de <varname>hedef</varname>'in bir boş karakter olmadığı durumda dönüştürülecek karakterin <varname>uzunluk</varname> bayttan fazlasını gerektirmesidir. Bu durumda <varname>kaynak</varname> başarıyla dönüştürülmüş son karakterden sonraki karakteri gösterecek bir gösterici olarak döner.
    </para><para>
Bir kodlama hatası dışında <command>wcsrtombs</command> işlevinin dönüş değeri <varname>hedef</varname> içinde saklanan çokbaytlı karakterlerin toplam bayt sayısıdır. İşlev dönmeden önce, durum nesnesi son karakter dönüştürüldükten sonraki durumla güncellenir. Sonlandırıcı boş geniş karakter işlenmişse durum, ilk durum olur.
    </para><para>
<indexterm scope="glibc-pg"><primary>wchar.h</primary></indexterm>
The <command>wcsrtombs</command> işlevi ISO C90 standardının 1. düzeltmesinde tanımlanmış ve <filename>wchar.h</filename> başlık dosyasına bildirilmiştir.
</para></funcdescr></funcsynopsis></para><para>
Yukarıda <command>mbsrtowcs</command> işlevi ile ilgili sınırlama bu işlevde de geçerlidir. Girdi karakterlerinin sayısını doğrudan belirlemek mümkün değildir. Ya doğru yere bir boş geniş karakter yerleştirilmeli ya da girdi uzunluğu dolaylı olarak çıktı dizgesinin uzunluğu (<varname>uzunluk</varname> parametresi) sınanarak saptanmalıdır.
    </para><para xml:id="glibc-mbsnrtowcs">
<indexterm scope="glibc-fn"><primary>mbsnrtowcs</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>size_t <command>mbsnrtowcs</command></funcdef>
<paramdef>(wchar_t *restrict     <varname>hedef</varname>,
 const char **restrict <varname>kaynak</varname>,
 size_t                <varname>nmc</varname>,
 size_t                <varname>uzunluk</varname>,
 mbstate_t *restrict   <varname>ps</varname>)</paramdef>
</funcprototype><funcdescr><para>
İşlev, <command>mbsrtowcs</command> işlevine çok benzer.  <varname>nmc</varname> parametresi dışında tüm parametreler ve işlevin dönüş durumu aynıdır.
    </para><para>
<varname>nmc</varname> parametresi ile çokbaytlı karakter dizgesinin en çok kaç baytının kullanılacağı belirtilir. Başka bir deyişle, <varname>*kaynak</varname> çokbaytlı karakter dizisinin boş karakter sonlandırmalı olması gerekli değildir. Fakat dizge içinde ilk <varname>nmc</varname> karakter içinde bir boş karaktere rastlanırsa dönüşüm orada durur.
    </para><para>
Bu işlev bir GNU oluşumudur. Amacı yukarıda belirtilen sorunun etrafından dolanmaktır. Böylece çokbaytlı karakterler içeren bir tamponun dönüştürülmesi boş karakter yerleştirmeden ve boş karakter dönüşüm durumunu etkilemeksizin mümkün olur.
       </para><para>
Bir çokbaytlı karakter dizgesini bir geniş karakter dizgesine dönüştürecek ve gösterecek bir işlev şöyle yazılabilir (bu kullanılabilir bir örnek değildir):
    </para><para>
<screen>
void
showmbs (const char *src, FILE *fp)
{
  mbstate_t state;
  int cnt = 0;
  memset (&amp;state, '\0', sizeof (state));
  while (1)
  {
    wchar_t linebuf[100];
    const char *endp = strchr (src, '\n');
    size_t n;

    /* Başka satır yoksa çık.  */
    if (endp == NULL)
      break;

    n = mbsnrtowcs (linebuf, &amp;src, endp - src, 99, &amp;state);
    linebuf[n] = L'\0';
    fprintf (fp, "line %d: \"%S\"\n", linebuf);
  }
}
</screen></para><para>
<command>mbsnrtowcs</command> çağrısından sonra durumla ilgili bir sorun çıkmaz. Dizgelere dışarıdan bir karakter yerleştirmediğimizden <varname>state</varname> durumunu sadece verilen tamponu dönüştürmek için kullandık. Durumun değişmesiyle ilgili bir sorun yaşamadık.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-wcsnrtombs">
<indexterm scope="glibc-fn"><primary>wcsnrtombs</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>size_t <command>wcsnrtombs</command></funcdef>
<paramdef>(char *restrict           <varname>hedef</varname>,
 const wchar_t **restrict <varname>kaynak</varname>,
 size_t                   <varname>nwc</varname>,
 size_t                   <varname>uzunluk</varname>,
 mbstate_t *restrict      <varname>ps</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>wcsnrtombs</command> işlevi geniş karakter dizgesini çokbaytlı karakter dizgesine dönüştürmekte kullanılır. <command>wcsrtombs</command> işlevine benzemekle birlikte <command>mbsnrtowcs</command> işlevi gibi girdi dizgesinin uzunluğunun belirtilebildiği bir ek parametre alır.
    </para><para>
<varname>*kaynak</varname> dizgesinin sadece ilk <varname>nwc</varname> geniş karakteri dönüştürülür. Bu parça içinde bir boş karaktere rastlanırsa dönüşüm bu karakterde durdurulur.
    </para><para>
<command>wcsnrtombs</command> işlevi bir GNU oluşumudur ve <command>mbsnrtowcs</command> işlevi gibi boş karakter içermeyen dizgelerin dönüştürülmesinde yararlı olur.
       </para></funcdescr></funcsynopsis></para>
    </sect1><sect1 xml:id="glibc-Multibyte-Conversion-Example">
      <title>Çokbaytlı Dönüşüm Örneği</title>
      <titleabbrev>Eksiksiz bir çokbaytlı dönüşüm örneği</titleabbrev>
      <para>
Bundan önceki bölümlerde verilen örnekler birer özetti ve hata denetimlerini içermiyordu. Burada tam ve belgelemesi yapılmış bir örneğe yer verilmiştir. <command>mbrtowc</command> işlevi kullanılmışsa da diğer sürümleri başka işlevlerin yardımıyla gerçeklenmiştir.
    </para><para>
<screen>
int
file_mbsrtowcs (int input, int output)
{
  /* MB_LEN_MAX kullanmalıyız.
      MB_CUR_MAX urada taşınabilir değildir.  */
  char buffer[BUFSIZ + MB_LEN_MAX];
  mbstate_t state;
  int filled = 0;
  int eof = 0;

  /* state'i ilklendirelim.  */
  memset (&amp;state, '\0', sizeof (state));

  while (!eof)
    {
      ssize_t nread;
      ssize_t nwrite;
      char *inp = buffer;
      wchar_t outbuf[BUFSIZ];
      wchar_t *outp = outbuf;

      /* buffer'ı girdi dosyasından dolduralım.  */
      nread = read (input, buffer + filled, BUFSIZ);
      if (nread &lt; 0)
        {
          perror ("read");
          return 0;
        }
      /* Dosya sonuna geldiğimizde bunu belirleyelim. */
      if (nread == 0)
        eof = 1;

      /* tampona aktarılan baytları sayalım */
      filled += nread;

      /* Bu baytları mümkün olduğunda geniş karakterlere dönüştürelim. */
      while (1)
        {
          size_t thislen = mbrtowc (outp, inp, filled, &amp;state);
          /* Geçersiz karaktere rastlandığında dur;
             böylece son geçerli karaktere kadar olan parçayı okumuş olacağız  */
          if (thislen == (size_t) -1)
            break;
          /* Dizge içinde boş karakter bulursak 0 değeri ile döneceğiz.
             Bu bir düzeltme gerektirir.  */
          if (thislen == 0)
            thislen = 1;
          /* Bu karakterle işimiz bitti, sonrakine geçelim. */
          inp += thislen;
          filled -= thislen;
          ++outp;
        }

      /* Dönüştürülen geniş karakterleri yazalım.  */
      nwrite = write (output, outbuf,
                      (outp - outbuf) * sizeof (wchar_t));
      if (nwrite &lt; 0)
        {
          perror ("write");
          return 0;
        }

      /* Gerçekten bir geçersiz karakterimiz var mı bakalım. */
      if ((eof &amp;&amp; filled > 0) || filled >= MB_CUR_MAX)
        {
          error (0, 0, "cokbaytli karakter gecersiz");
          return 0;
        }

      /* karakterleri tamponun başından itibaren yerleştirelim. */
      if (filled > 0)
        memmove (inp, buffer, filled);
    }

  return 1;
}
</screen></para></sect1>
  </chapter>

  <chapter xml:id="glibc-Non-reentrant-Conversion">
    <title>Evresel Olmayan Dönüşümler</title>
    <titleabbrev>Evresel olmayan dönüşüm işlevi</titleabbrev>
    <para>
Önceki kısımda bahsedilen dönüşüm işlevler ISO C90'ın 1. düzeltmesinde tanımlanmış işlevlerdi. Fakat ISO C90 standardı da karakter kümesi dönüşümlerini yapmak için işlevler içermektedir. Önce bu orjinal işlevleri açıklamadık, çünkü hemen hemen tamamen kullanışsızdırlar.
   </para><para>
ISO C90'da tanımlanan dönüşüm işlevlerinin tümü sadece işlev içindeki durumu kullanırlar. Bu dahili durum kullanılarak çoklu dönüşümler aynı anda (sadece evreler kullanıldığında değil) yapılamaz ve dönüşüm işlevlerine hangi durumu kullanacakları belirtilemediğinden tek karakter ve dolayısıyla dizge dönüşümleri yapılamaz.
   </para><para>
Bu orjinal işlevler sadece çok sınırlı durumlarda kullanılabilir. Yeni bir dizgenin dönüştürülmesine başlamadan önce mevcut dizge tamamen dönüştürülmüş olmalı ve her dizge aynı işlevle dönüştürülmelidir (bu noktada kütüphanenin kendisi ile ilgili bir sorun yoktur; bir işlevin kullandığı durumun başka bir işlev tarafından değiştirilmeyeceği garanti edilmiştir). <emphasis>Bu sebeplerle, evresel olmayan dönüşüm işlevleri yerine önceki kısımda bahsedilen işlevlerin kullanılması tercih edilmelidir.</emphasis>
    </para>
    <sect1 xml:id="glibc-Non-reentrant-Character-Conversion">
      <title>Evresel Olmayan Karakter Dönüşümleri</title>
      <titleabbrev>Tek bir karakterin evresel olmayan dönüşümü</titleabbrev>
      <para xml:id="glibc-mbtowc">
<indexterm scope="glibc-fn"><primary>mbtowc</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>mbtowc</command></funcdef>
<paramdef>(wchar_t *restrict    <varname>sonuç</varname>,
 const char *restrict <varname>dizge</varname>,
 size_t               <varname>boyut</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>mbtowc</command> ("multibyte to wide character" kısaltması) işlevi boş olmayan <varname>dizge</varname> ile çağrıldığında <varname>dizge</varname> dizgesinin ilk çokbaytlı karakteri karşılığı olan geniş karakter koduna dönüştürülür ve sonuç <varname>*sonuç</varname>'da saklanır.
    </para><para>
<command>mbtowc</command> işlevi <varname>boyut</varname> bayttan fazlasına bakmaz.
    </para><para>
<command>mbtowc</command> işlevi boş olmayan <varname>dizge</varname> için üç olasılığı ayrımsar: <varname>dizge</varname>'nin ilk <varname>boyut</varname> baytı geçerli çokbaytlı karakterlerle başlar, geçersiz bir bayt dizilimi ile ya da bir karakterin parçası olarak başlar; ya da <varname>dizge</varname> bir boş dizgeyi (bir boş karakter) gösterir.
    </para><para>
Geçerli bir çokbaytlı karakteri <command>mbtowc</command> bir geniş karaktere dönüştürüp <varname>*sonuç</varname>'da saklar ve bu karakterin bayt sayısı ile döner (daima en az 1 dir ve asla <varname>boyut</varname> bayttan büyük değildir).
    </para><para>
Geçersiz bir bayt diziliminde <command>mbtowc</command> -1 ile döner.  Boş bir dizge için 0 ile döner ve <varname>*sonuç</varname> içinde <command>'\0'</command> saklanır.
    </para><para>
Çokbaytlı karakter kodu ötelenmiş karakterleri kullanıyorsa, <command>mbtowc</command> bunu düzeltir ve bir öteleme durumuna günceller. <command>mbtowc</command> boş gösterici içeren <varname>dizge</varname> ile çağrılırsa öteleme durumunu kendi standart ilk durumuyla ilklendirir. Ayrıca kullanılan çokbaytlı karakter kodu için bir öteleme durumu varsa sıfırdan farklı bir değerle döner. Bkz. <xref linkend="glibc-Shift-State"/>.
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-wctomb">
<indexterm scope="glibc-fn"><primary>wctomb</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>wctomb</command></funcdef>
<paramdef>(char   *<varname>dizge</varname>,
 wchar_t <varname>wchar</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>wctomb</command> ("wide character to multibyte" kısaltması) işlevi <varname>wchar</varname> geniş karakter kodunu karşılığı olan çokbaytlı karaktere dönüştürür ve sonucu bayt cinsinden <varname>dizge</varname> içinde saklar. En çok <command>MB_CUR_MAX</command> karakter saklanır.
    </para><para>
<command>wctomb</command> işlevi boş olmayan <varname>dizge</varname> ile çağrılırsa <varname>wchar</varname> için üç olasılığı ayrımsar:  Geçerli bir geniş karakter kodu, geçersiz bir kod ve <command>L'\0'</command>.
    </para><para>
Geçerli bir kod verilmişse, <command>wctomb</command> bunu çokbaytlı karaktere dönüştürüp sonucu <varname>dizge</varname> içinde saklar ve karakterdeki bayt sayısı ile döner (daima en az 1'dir ve <command>MB_CUR_MAX</command>'dan büyük değildir).
    </para><para>
<varname>wchar</varname> geçersiz bir geniş karakter kodu ise <command>wctomb</command> -1 ile döner. <command>L'\0'</command> ise <command>0</command> ile döner, ayrıca *<varname>dizge</varname> içinde <command>'\0'</command> saklar.
    </para><para>
Çokbaytlı karakter kodu ötelenmiş karakterler içeriyorsa <command>wctomb</command> bunu düzeltir ve bir öteleme durumuna günceller. Ayrıca kullanılan çokbaytlı karakter kodu bir öteleme durumuna sahipse sıfırdan farklı bir değerle döner. Bkz. <xref linkend="glibc-Shift-State"/>.
    </para><para>
Bu işlev <varname>wchar</varname> argümanı ile sıfır aktarılarak çağrılması <varname>dizge</varname>'in boş olmaması halinde hem saklanmış öteleme durumunun yeniden ilklendirilmesi hem de <command>'\0'</command> çokbaytlı karakterinin saklanması ve işlevin 0 ile dönmesi ile ilgili bir yan etkiye sahiptir.
</para></funcdescr></funcsynopsis></para><para>
<command>mbrlen</command>'e benzer olarak bir çokbaytlı karakterin uzunluğunu hesaplayan ve evresel olmayan bir işlev de vardır.  <command>mbtowc</command> kurallarıyla tanımlanabilir.
    </para><para xml:id="glibc-mblen">
<indexterm scope="glibc-fn"><primary>mblen</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>mblen</command></funcdef>
<paramdef>(const char *<varname>dizge</varname>,
 size_t      <varname>boyut</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>mblen</command> işlevi boş olmayan <varname>dizge</varname> argümanı ile çağrıldığında <varname>dizge</varname>'nin başındaki çokbaytlı karakterin <varname>boyut</varname> bayttan daha fazla karakterine bakmaksızın bayt sayısı ile döner.
    </para><para>
<command>mblen</command>'in dönüş değeri üç olasılığa bağlıdır: <varname>dizge</varname>'nin ilk <varname>boyut</varname> baytı geçerli çokbaytlı karakterlerle başlar, geçersiz bir bayt dizilimi ile ya da bir karakterin parçası olarak başlar; ya da <varname>dizge</varname> bir boş dizgeyi (bir boş karakter) gösterir.
    </para><para>
Geçerli bir çokbaytlı karakter için <command>mblen</command> karakterin bayt sayısı ile döner (en az 1, en çok <varname>boyut</varname> bayt). Geçersiz bir bayt dizilimi için -1 ile döner. Bir boş dizge için ise sıfır ile döner.
    </para><para>
Çokbaytlı karakter kodu ötelenmiş karakterleri kullanıyorsa, <command>mblen</command> bunu düzeltir ve bir öteleme durumuna günceller. <command>mblen</command> boş gösterici içeren <varname>dizge</varname> ile çağrılırsa öteleme durumunu kendi standart ilk durumuyla ilklendirir. Ayrıca kullanılan çokbaytlı karakter kodu için bir öteleme durumu varsa sıfırdan farklı bir değerle döner. Bkz. <xref linkend="glibc-Shift-State"/>.
    </para><para>
<indexterm scope="glibc-pg"><primary>stdlib.h</primary></indexterm>
<command>mblen</command> işlevi <filename>stdlib.h</filename> dosyasında bildirilmiştir.
       </para></funcdescr></funcsynopsis></para>
    </sect1><sect1 xml:id="glibc-Non-reentrant-String-Conversion">
      <title>Evresel Olmayan Dizge Dönüşümleri</title>
      <titleabbrev>Dizgelerin evresel olmayan dönüşümleri</titleabbrev>
      <para>
ISO C90 standardında tek karakterlerden başka dizgeleri dönüştürecek işlevler de tanımlanmıştır. Bu işlevler ISO C90 standardınının 1. düzeltmesinde tanımlanmış olan benzerleriyle aynı sorunlardan muzdariptir; bkz. <xref linkend="glibc-Converting-Strings"/>.
    </para><para xml:id="glibc-mbstowcs">
<indexterm scope="glibc-fn"><primary>mbstowcs</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>size_t <command>mbstowcs</command></funcdef>
<paramdef>(wchar_t    *<varname>gdizge</varname>,
 const char *<varname>dizge</varname>,
 size_t      <varname>boyut</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>mbstowcs</command> ("multibyte string to wide character string" kısaltması) işlevi <varname>dizge</varname> boş karakter sonlandırmalı çokbaytlı karakter dizgesini geniş karakter kodlu bir diziye dönüştürür ve sonucun ilk <varname>boyut</varname> geniş karakterini <varname>gdizge</varname> içinde saklar. Sonlandıran boş karakter boyuta dahildir. Bu durumda <varname>dizge</varname>'den elde edilen geniş karakterlerin sayısı <varname>boyut</varname>'tan fazla ise sonuç sonlandırıcı boş karakteri içermeyecektir.
    </para><para>
<varname>dizge</varname>'deki karakterlerin dönüşümü ilk öteleme durumuyla başlar.
    </para><para>
Eğer geçersiz bir çokbaytlı karakter dizgesi bulunursa, <command>mbstowcs</command> işlevi -1 değeri ile döner. Aksi takdirde <varname>gdizge</varname> dizisi içinde saklanan geniş karakterlerin sayısı ile döner. Bu sayı <varname>boyut</varname>'tan küçükse sonlandırıcı boş karakter dahil değildir.
    </para><para>
Aşağıdaki örnekte bir çokbaytlı karakter dizisinin dönüşümü ve elde edilen sonuç için nasıl yer ayrılacağı gösterilmiştir.
    </para><para>
<screen>
wchar_t *
mbstowcs_alloc (const char *string)
{
  size_t size = strlen (string) + 1;
  wchar_t *buf = xmalloc (size * sizeof (wchar_t));

  size = mbstowcs (buf, string, size);
  if (size == (size_t) -1)
    return NULL;
  buf = xrealloc (buf, (size + 1) * sizeof (wchar_t));
  return buf;
}
</screen>
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-wcstombs">
<indexterm scope="glibc-fn"><primary>wcstombs</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>size_t <command>wcstombs</command></funcdef>
<paramdef>(char          *<varname>dizge</varname>,
 const wchar_t *<varname>gdizge</varname>,
 size_t         <varname>boyut</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>wcstombs</command> ("wide character string to multibyte string" kısaltması) işlevi boş karakter sonlandırmalı <varname>gdizge</varname> geniş karakter dizgesini çokbayktlı karakter dizgesine dönüştürür ve sonucun <varname>boyut</varname> baytını <varname>dizge</varname> içinde saklar. Yeterince yer yoksa sonuç sonlandırıcı boş karakteri içermez. Karakter dönüşümü ilk öteleme durumuyla başlar.
    </para><para>
Sonlandırıcı boş karakter boyuta dahildir. Bu bakımdan <varname>boyut</varname>, <varname>gdizge</varname> içindeki baytların sayısına eşit ya da daha küçükse sonlandırıcı boş karakter saklanmaz.
    </para><para>
Bir kod için geçerli bir çokbaytlı karakter bulunamazsa işlev -1 ile döner. Aksi takdirde, <varname>dizge</varname> dizisi içinde saklanan baytların sayısı ile döner. Bu sayı <varname>boyut</varname>'tan küçükse sonlandırıcı boş karakter dahil değildir.
      </para></funcdescr></funcsynopsis></para>
    </sect1><sect1 xml:id="glibc-Shift-State">
      <title>Öteleme Durumu</title>
      <titleabbrev>Evresel olmayan işlevlerde durumlar</titleabbrev>
      <para>
Bazı çokbaytlı karakterlerin bayt dizilimleri tek başlarına anlamlı değildir; dizge içindeki kendilerinden önce gelen karakterlere bağlı olarak değerlendirilir. Kendinden sonraki dizilimlerin anlamını değiştiren belli başlı birkaç dizilim vardır. Bu dizilimlere <wordasword>öteleme dizilimleri</wordasword> ve bunların hepsine birden <wordasword>öteleme durumu</wordasword> denir.
    </para><para>
Öteleme dizilimlerini ve öteleme durumunu bir örnekle açıklayalım. <command>0200</command> dizilimi (bir baytlık) Japonca kipini başlatır ve bu dizilimden sonra gelen <command>0240</command> ile <command>0377</command> arasındaki bayt çiftleri birer karakter olarak yorumlanır. Aynı şeklide, <command>0201</command> ile Latin-1 kipine girilir ve <command>0240</command> ile <command>0377</command> arasındaki karakterler Latin-1 karakter kümesindeki karakterler olarak yorumlanır.  Burada iki öteleme durumu (Japonca ve Latin-1 kipi) olan bir çokbaytlı kod ile  belli öteleme durumlarını belirten iki öteleme diziliminden bahsetmiş olduk.
    </para><para>
Kullanımdaki çokbaytlı karakter kodu için öteleme durumları varsa, <command>mblen</command>, <command>mbtowc</command> ve <command>wctomb</command> işlevleri taradıkları dizgenin mevcut öteleme durumlarını düzenlemeli ve güncellemelidir. Bunun olması için bu kurallara uymalısınız:
    </para><para><itemizedlist><listitem><para>
Bir dizgeyi taramaya başlamadan önce, çokbaytlı karakter adresi için işlevi <command>mblen (NULL, 0)</command> gibi bir boş gösterici ile çağırın. Bu öteleme durumunu işlevin kendi standart ilk değeriyle ilklendirecektir. </para></listitem><listitem><para>
Dizgeyi sırayla bir defada bir karakter işlenecek şekilde tarayın. Taradığınız karakterleri yedeklemeyin ve yeniden taramayın ve bu arada başka dizgeleri işleme sokmayın.
      </para></listitem></itemizedlist></para><para>
<command>mblen</command> işlevinin bu kurallara uygun olarak kullanımına bir örnek:
    </para><para>
<screen>
void
scan_string (char *s)
{
  int length = strlen (s);

  /* Öteleme durumunu ilklendirelim.  */
  mblen (NULL, 0);

  while (1)
    {
      int thischar = mblen (s, length);
      /* Dizge sonunu ve geçersiz bir karakteri yakalayalım.  */
      if (thischar == 0)
        break;
      if (thischar == -1)
        {
          error ("çokbaytli karakter gecersiz");
          break;
        }
      /* Sonraki karaktere geçelim.  */
      s += thischar;
      length -= thischar;
    }
}
</screen></para><para>
<command>mblen</command>, <command>mbtowc</command> ve <command>wctomb</command> işlevleri öteleme durumu kullanan bir çokbaytlı kod için evresel değildir. Bununla birlikte, bu işlevleri çağıran bir kütüphane işlevi olmadığından öteleme durumunun bilginiz dışında değişmesi mümkün değildir.
      </para>
    </sect1>
  </chapter>

<chapter xml:id="glibc-Generic-Charset-Conversion">
  <title>Soysal Karakter Kümesi Dönüşümü</title>
  <para>
Bu kısma kadar bahsedilen dönüşüm işlevlerinin hepsi işlem yaptıkları karakter kümelerinin işlevin bir argümanı olarak belirtilmediği tüm karakter kümeleri için kullanılabilen işlevlerdi. Çokbaytlı kodlama <command>LC_CTYPE</command> kategorisi için seçilmiş yerel tarafından belirtilen karakter kümesini kullanır. Geniş karakter kümesi gerçeklemeyle sabittir (GNU C kütüphanesi için daima ISO 10646 kodlu UCS-4'tür.).
   </para><para>
Bu, genel karakter dönüşümlerinde bir takım sorunlar içerir:
   </para><para><itemizedlist><listitem><para>
Her dönüşüm için karakter kümesi ne kaynağın ne de hedefin <command>LC_CTYPE</command> kategorisinde belirtilmiş yerel karakter kümesidir. <command>LC_CTYPE</command> yereli <command>setlocale</command> işlevi kullanılarak değiştirilebilir.
     </para><para>
<command>LC_TYPE</command> yerelinin değiştirilmesi, <command>LC_CTYPE</command> kategorisini kullanan işlevlerden (örn, <link linkend="glibc-Classification-of-Characters">karakter sınıflandırma işlevleri</link>) dolayı yazılımın kalanında büyük sorunlara yol açar.
     </para></listitem><listitem><para>
<command>LC_CTYPE</command> seçimi genel ve tüm evreler tarafından paylaşılan bir seçim olduğundan farklı karakter kümeleri arasındaki dönüşümler mümkün olmaz.
     </para></listitem><listitem><para>
<command>wchar_t</command> gösterimi için kaynağın ve hedefin karakter kümesi kullanılamadığına göre önceki işlevleri kullanarak bir metni dönüştürmek istersek iki kademeli bir işlem gerekir. Birinci adımda çokbaytlı kodlama için kaynak karakter kümesi seçilip metin <command>wchar_t</command> metnine dönüştürülecek, ikinci adımda ise hedefin karakter kümesi seçilip geniş karakterli metin bu karakter kümesindeki çok baytlı karakterlere dönüştürülecektir.
     </para><para>
Bu mümkün olsa bile (garanti değildir) çok yorucu bir çalışmadır. Bundan başka, yerelin iki defa değişmesine bağlı olarak bazı sorunlara yol açabilecektir.
     </para></listitem></itemizedlist></para><para>
XPG2 standardı bu sınırlamaları olmayan tamamen yeni bir işlev ailesi tanımlar. Bunlar seçili yerele bağlı olmadıkları gibi kaynak ve hedef için seçilmiş karakter kümeleriyle ilgili bir sınırlama da getirmezler. Tek sınır dönüşüm için kullanılabilecek karakter kümeleridir. Böyle bir kullanışlılık gerçeklemenin kalitesinin bir ölçüsüdür.
   </para><para>
Bundan sonraki bölümlerde önce <command>iconv</command> arayüzünden ve dönüşüm işlevinden söz edilecektir. Son olarak gelişkin dönüşüm yeteneklerinden yararlanmak isteyen ileri düzey yazılımcıları ilgilendireceği umularak gerçeklemeden bahsedilecektir.
   </para><sect1 xml:id="glibc-Generic-Conversion-Interface">
   <title>Soysal Dönüşüm Arayüzü</title>
   <titleabbrev>Soysal karakter kümesi dönüşüm arayüzü</titleabbrev>
   <para>
Bu işlev ailesi bir özkaynağın geleneksel kullanım yöntemini kullanır: aç-kullan-kapa. Arayüz her biri bir adımı gerçekleştiren üç işlevden oluşur.
    </para><para>
Arayüzün açıklanmasına geçmeden önce bir veri türünden bahsetmemiz gerekiyor.
Diğer aç-kullan-kapa arayüzler gibi burada bahsedilen işlevler de tanımlayıcıları kullanarak çalışır. Bu tanımlayıcıların kullandığı özel veri türü <filename>iconv.h</filename> başlık dosyasında tanımlanmıştır.
    </para><para xml:id="glibc-iconv_t">
<indexterm scope="glibc-tp"><primary>iconv_t</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü">
<funcdef><command>iconv_t</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu veri türü <filename>iconv.h</filename> dosyasında tanımlanmış bir soyut türdür. Yazılımcı bu veri türünün tanımıyla ilgili hiçbir kabul yapmamalıdır; şeffaf olmayan bir türdür.
    </para><para>
Bu türdeki nesneler <command>iconv</command> işlevleri kullanılan dönüşümler için atanmış tanımlayıcıları alabilir.  Tanımlayıcıyı kullanan dönüşümlerin nesneyi serbest bırakması gerektiğinden nesnelerin kendi kendilerini serbest bırakmaması gerekir.
</para></funcdescr></funcsynopsis></para><para>
İlk adım bir eylemci oluşturan işlevdir.
    </para><para xml:id="glibc-iconv_open">
<indexterm scope="glibc-fn"><primary>iconv_open</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>iconv_t <command>iconv_open</command></funcdef>
<paramdef>(const char *<varname>hedef_kod</varname>,
 const char *<varname>kaynak_kod</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>iconv_open</command> işlevi bir dönüşüm başlatmadan önce kullanılması gereken işlevdir. İşlev, dönüşüm için kullanılacak karakter kümelerinin belirtildiği iki argüman alır. Gerçekleme böyle bir dönüşümü yapabilecek yeterlilikteyse işlev bir tanımlayıcı ile döner.
    </para><para>
İstenen dönüşüm mümkün değilse işlev, <command>(iconv_t) -1</command> ile döner. Bu durumda <command>errno</command> genel değişkenine şu değerlerden biri atanır:
    </para><para><variablelist><varlistentry>
    <term><literal>EMFILE</literal></term><listitem><para>
Süreç zaten <command>OPEN_MAX</command> dosya tanımlayıcı açmış.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>ENFILE</literal></term><listitem><para>
Sisemin açık dosya sayısı ile ilgili sınırı aşıldı.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>ENOMEM</literal></term><listitem><para>
İşlemi gerçekleştirecek kadar bellek yok.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>EINVAL</literal></term><listitem><para>
<varname>kaynak_kod</varname> ile <varname>hedef_kod</varname> arasında dönüşüm desteklenmiyor.
       </para></listitem></varlistentry></variablelist></para><para>
Bağımsız dönüşümleri yapacak farklı evrelerde aynı tanımlayıcıyı kullanmak mümkün değildir. Tanımlayıcı ile ilişkili veri yapıları dönüşüm durumu hakkında bilgi içerir. Bu farklı dönüşümlerde kullanılarak altüst edilmemelidir.
    </para><para>
Bir <command>iconv</command> tanımlayıcı bir dosya tanımlayıcı gibi her kullanım için yeniden oluşturulmalıdır. Tanımlayıcı <varname>kaynak_kod</varname> ile <varname>hedef_kod</varname> arasındaki tüm dönüşümler içindir şeklinde düşünülmemelidir.
    </para><para>
GNU C kütüphanesinin <command>iconv_open</command> gerçeklemesi diğer gerçeklemelerden farklı olarak önemli bir özelliğe sahiptir. Dönüşüm için desteklenen tüm karakter kümeleri ile ilgili verileri ve kodları içeren dosyalar belli başlı dizinlerde tutulur. Bu özelliğin nasıl gerçeklendiği <xref linkend="glibc-glibc-iconv-Implementation"/> bölümünde açıklanmıştır. Burada üstünde duracağımız tek şey, <filename>GCONV_PATH</filename> ortam değişkeninde ismi bulunan dizinlerin sadece bir <filename>gconv-modules</filename> dosyası içermesi halinde geçerli olduğudur. Bu dizinlerin sistem yönetici tarafından oluşturulması şart değildir. Aslında bu özellik kullanıcıların kendilerine özel dönüşümleri yazabilmelerine ve kullanabilmelerine imkan vermek için tasarlanmıştır. Şüphesiz, güvenlik kaygıları nedeniyle SUID çalıştırılabilirlerle bu çalışmaz; bu durumda sadece sistem dizinlerine bakılır. Bunun yeri de normalde <filename><emphasis>önek</emphasis>/lib/gconv</filename> dizinidir. <filename>GCONV_PATH</filename> ortam değişkenine sadece <command>iconv_open</command> işlevi ilk çağrıldığında bakılır. Değişkende sonradan yapılan bir değişikliğin etkisi yoktur.
    </para><para>
<indexterm scope="glibc-pg"><primary>iconv.h</primary></indexterm>
<command>iconv_open</command> işlevi ilk olarak  X/Open Portability Guide, 2. sürümünde kullanıldı. Daha sonra tüm ticari Unix'ler tarafından desteklendi. Bununla birlikte, gerçeklemenin kalitesi ve bütünlüğü aynı değildir.  <command>iconv_open</command> işlevi <filename>iconv.h</filename> dosyasında bildirilmiştir.
</para></funcdescr></funcsynopsis></para><para>
<command>iconv</command> gerçeklemesinin geniş veri yapısı <command>iconv_open</command> tarafından döndürülen tanımlayıcı ile ilişkilendirilebilir. Diğer taraftan, tüm dönüşümler yapıldıktan sonra ve başka dönüşüm kalmamışsa tüm özkaynakların hemen serbest bırakılması önemlidir.
    </para><para xml:id="glibc-iconv_close">
<indexterm scope="glibc-fn"><primary>iconv_close</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>iconv_close</command></funcdef>
<paramdef>(iconv_t <varname>dt</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>iconv_close</command> işlevi önceki bir <command>iconv_open</command> çağrısından dönen  <varname>dt</varname> tanımlayıcısı ile ilişkili tüm özkaynakları serbest bırakır.
    </para><para>
İşlev hatasız bir işlem yürütmüşse 0 ile döner, aksi takdirde <command>errno</command> değişkenine hata durumunu kaydederek -1 ile döner. İşlev için tanımlı hatalar:
    </para><para><variablelist><varlistentry>
    <term><literal>EBADF</literal></term><listitem><para>
Dönüşüm tanımlayıcı geçersiz.
       </para></listitem></varlistentry></variablelist></para><para>
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-pg"><primary>iconv.h</primary></indexterm>
<command>iconv_close</command> işlevi diğer <command>iconv</command> işlevleri ile birlikte XPG2 içinde tanımlanmış ve <filename>iconv.h</filename> dosyasında bildirilmiştir.
    </para><para>
Standart aslında tek bir dönüşüm işlevi tanımlar. Bu çok genel bir arayüz tanımlandığı için böyledir: Dönüşümün bir tampondan diğerine yapılacağı öngörülmüştür. Bir dosyadan tampona ve tersi ya da dosyadan dosyaya dönüşümler standarttaki bu tanımı genişleterek gerçekleştirilebilir.
    </para><para xml:id="glibc-iconv">
<indexterm scope="glibc-fn"><primary>iconv</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>size_t <command>iconv</command></funcdef>
<paramdef>(iconv_t <varname>dt</varname>,
 char  **<varname>girdi_tamponu</varname>,
 size_t *<varname>girdi_uzunluğu</varname>,
 char  **<varname>çıktı_tamponu</varname>,
 size_t *<varname>çıktı_uzunluğu</varname>)</paramdef>
</funcprototype><funcdescr><para>
<indexterm scope="glibc-cp"><primary>durumsal</primary></indexterm>
<command>iconv</command> işlevi <varname>dt</varname> dönüşüm tanımlayıcısı ile ilişkilendirilmiş kurallara uygun olarak girdi tamponundaki metni dönüştürerek sonucu çıktı tamponunda saklar. Gerekli durum bilgisi tanımlayıcı ile ilişkilendirilmiş veri yapıları içinde tutulduğundan aynı metin için işlev defalarca çağrılabilir.
    </para><para>
<varname>*girdi_tamponu</varname> ile belirtilen girdi tamponu <varname>*girdi_uzunluğu</varname> bayt içerir. Kullanılan girdinin çağrıcı ile iletişimi için ek olarak bir dolaylı işlem gerekir. Tampon göstericisinin <command>char</command> türünde olduğuna dikkat edin. Uzunluk, tampondaki karakterler geniş karakterler olsa bile bayt cinsindendir.
    </para><para>
Çıktı tamponu da benzer şekilde sonucun saklanacağı <varname>*çıktı_tamponu</varname> göstericisinin belirtiği adresten başlayan en az <varname>*çıktı_uzunluğu</varname> baytlık bir alan olarak belirtilir. Yine benzer şekilde tampon göstericisi <command>char</command> türündedir ve tampon uzunluğu bayt cinsindendir. <varname>çıktı_tamponu</varname> veya <varname>*çıktı_tamponu</varname> bir boş gösterici ise dönüşüm yine yapılır ama bir çıktı üretilmez.
    </para><para>
<varname>girdi_tamponu</varname> bir boş gösterici ise, dönüşüm durumunu ilk duruma getiren bir eylem gerçekleştirilir. Bu, durumsal olmayan kodlamalarda bir eylemle sonuçlanmaz, ama eğer, kodlama bir duruma sahipse böyle bir işlev çağrısı gerekli durum değişikliklerini gerçekleştirecek bazı bayt dizilimlerini çıktı tamponuna koyar. Normal bir <varname>girdi_tamponu</varname> ile yapılan bir sonraki işlev çağrısında dönüşüm ilk durumdan başlar. Yazılımcının dönüşümün durumsallığı ile ilgili bir önkabul yapmaktan kaçınması gerekir. Girdi ve çıktı karakterleri durumsal olmasa bile gerçekleme yine de durumları tutmak zorunda olabilir. Aşağıda açıklanan sebeplerden dolayı GNU C kütüphanesinde bu böyledir. Bu nedenle, durumu sıfırlayacak bir <command>iconv</command> çağrısı, bir protokol, çıktı metni için bunu gerektiriyorsa daima bunu yapacaktır.
    </para><para>
Dönüşüm üç sebepten birine bağlı olarak durabilir. İlki girdi tamponundaki tüm karakterlerin dönüştürüldüğü durumdur. Bu aslında iki farklı anlama gelir: Ya girdi tamponundaki tüm karakterler tüketilmiştir ya da tamponun sonunda girdide eksik ama tamponda tam biçimde olan bazı baytlar bulunmuştur. Durmanın ikinci sebebi çıktı tamponunun dolmasıdır. Üçüncüsü ise girdinin geçersiz karakterler içermesidir.
    </para><para>
Bu durumların hepsinde sorunsuz yapılan son dönüşümün ardından girdi ve çıktı tamponları <varname>girdi_tamponu</varname> ve <varname>çıktı_tamponu</varname>'nda ve her tamponun uzunluğu sırayla <varname>girdi_uzunluğu</varname> ve <varname>çıktı_uzunluğu</varname> göstericileriyle döndürülür.
    </para><para>
<command>iconv_open</command> çağrısında seçilen karakter kümeleri hemen hemen tamamen isteğe bağlı olduğundan girdi karakter kümesinde, çıktı karakter kümesinde karşılığı olmayan karakterler bulunabilir. Bu durumda işlevin davranışı tanımsızdır. GNU C kütüphanesinin bu durum karşısında <command>şimdiki</command> davranışı bir hata durumu ile dönmektir. Bu olması gereken bir çözüm değildir; bu nedenle, daha iyi bir çözüm için çalışmalar sürmektedir ve kütüphanenin gelecek sürümlerinde daha iyi bir çözüm sunulacaktır.
    </para><para>
Girdi tamponundaki karakterlerin tümü değiştirilip sonuç çıktı tamponunda saklanmışsa, işlev tersinir olmayan dönüşümlerin sayısı ile döner. Bunun dışındaki tüm durumlarda işlev <command>(size_t) -1</command> ile döner ve <command>errno</command> değişkenine hata durumunu kaydeder. Böyle durumlarda <varname>girdi_uzunluğu</varname> ile gösterilen değer sıfırdan farklıdır.
    </para><para><variablelist><varlistentry>
    <term><literal>EILSEQ</literal></term><listitem><para>
Girdi geçersiz bir bayt dizilimi içerdiğinden dönüşüm durdu. Çağrıdan sonra, <varname>*girdi_tamponu</varname> geçerli bayt dizilimlerinin ilk baytını gösterir.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>E2BIG</literal></term><listitem><para>
Çıktı tamponu yetersiz olduğundan dönüşüm durdu.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>EINVAL</literal></term><listitem><para>
Girdi tamponunun sonundaki bayt dizilimi eksik olduğundan dönüşüm durdu.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>EBADF</literal></term><listitem><para>
<varname>dt</varname> argümanı geçersiz.
       </para></listitem></varlistentry></variablelist></para><para>
<indexterm scope="glibc-pg"><primary>iconv.h</primary></indexterm>
<command>iconv</command> işlevinden XPG2 standardında bahsedilmiş ve işlev <filename>iconv.h</filename> başlık dosyasında bildirilmiştir.
</para></funcdescr></funcsynopsis></para><para>
<command>iconv</command> işlevi, benzerlerinden daha iyi gerçeklenmiştir. Daha esnek bir işlevsellik sunar. Sorunlu kısımlar, geçersiz girdi ve girdi tamponunun sonundaki geçersiz bayt dizilimlerinin olduğu durumlardır. Üçüncü bir sorun varsa da, bu bir tasarım sorunu değildir, dönüşümlerin seçimi ile ilgilidir. Standart meşru isimler hakkında birşey içermez. Bunun diğer gerçeklemeleri nasıl olumsuz etkilediğini sonraki bölümde bir örnekle göstereceğiz.
    </para></sect1><sect1 xml:id="glibc-iconv-Examples">
    <title><literal>iconv</literal> Örnekleri</title>
    <titleabbrev>Tam bir <command>iconv</command> örneği</titleabbrev>
    <para>
Aşağıdaki örnekte ortak bir soruna bir çözüm sunulmaktadır. <command>wchar_t</command> dizgeleri için sistem tarafından bilinen kodlamalar verilmiştir. Metin bir dosyadan okunmakta ve geniş karakter tamponunda saklanmaktadır. Dönüşüm <command>mbsrtowcs</command> kullanılarak da yapılabilirdi fakat evvelce basettiğimiz sorunlar oluşurdu.
    </para><para>
<screen>int
file2wcs (int fd, const char *charset, wchar_t *outbuf, size_t avail)
{
  char inbuf[BUFSIZ];
  size_t insize = 0;
  char *wrptr = (char *) outbuf;
  int result = 0;
  iconv_t cd;

  cd = iconv_open ("WCHAR_T", charset);
  if (cd == (iconv_t) -1)
    {
      /* Yanlış giden birşeyler olabilir.  */
      if (errno == EINVAL)
        error (0, 0, "'%s' için wchar_t cinsinden bir karşılık yok",
                charset);
      else
        perror ("iconv_open");

      /* Çıktı dizgesini sonlandıralım.  */
      *outbuf = L'\0';

      return -1;
    }

  while (avail > 0)
    {
      size_t nread;
      size_t nconv;
      char *inptr = inbuf;

      /* Girdinin kalanını okuyalım.  */
      nread = read (fd, inbuf + insize, sizeof (inbuf) - insize);
      if (nread == 0)
        {
          /* Buraya gelimişsek okuma tamamlanmıştır. Ama hala
             <varname>inbuf</varname> içinde kullanılmamış
             karakterler kalmış olabilir. Onları geri koyalım.  */
          if (lseek (fd, -insize, SEEK_CUR) == -1)
            result = -1;

          /* Gerekliyse, ilk duruma girecek bayt dizilimini yazalım. */
          iconv (cd, NULL, NULL, &amp;wrptr, &amp;avail);

          break;
        }
      insize += nread;

      /* Dönüşümü yapalım.  */
      nconv = iconv (cd, &amp;inptr, &amp;insize, &amp;wrptr, &amp;avail);
      if (nconv == (size_t) -1)
        {
          /* Herşey yolunda gitmez. Tamponun sonunda bitmemiş
             bir bayt dizilimi olabilir. Kimi zaman da gerçekten
             önemli bir sorun olabilir.
          if (errno == EINVAL)
            /* Bu zararsız. Kullanılmayan baytları tamponun başına
               taşıyalım ki, sonraki adımda onlar kullanılabilsin.  */
            memmove (inbuf, inptr, insize);
          else
            {
              /* Bu gerçekten bir sorun. Ya çıktı tamponu yetersiz
                 ya da girdi geçersizdir. Her durumda, dosya
                 göstericisini işlenen son baytın konumuna
                 ayarlayacağız.  */
              lseek (fd, -insize, SEEK_CUR);
              result = -1;
              break;
            }
        }
    }

  /* Çıktı dizgesini sonlandıralım.  */
  if (avail >= sizeof (wchar_t))
    *((wchar_t *) wrptr) = L'\0';

  if (iconv_close (cd) != 0)
    perror ("iconv_close");

  return (wchar_t *) wrptr - outbuf;
}

</screen></para><para>
<indexterm scope="glibc-cp"><primary>stateful</primary></indexterm>
Bu örnek, <command>iconv</command> işlevlerinin en önemli kullanım şekillerini göstemektedir. Büyük boyutta bir metnin <command>iconv</command> çağrılarıyla nasıl dönüştürülebileceği gösterilmiştir. Kullanıcı durumsal kodlamalar hakkında birşey bilmek zorunda değildir.
    </para><para>
<command>iconv</command> işlevinin <command>errno</command> değişkenine <command>EINVAL</command> değerini atayarak döndüğü durum ilginçtir. Bu gerçekte dönüşümdeki bir hata değildir. Girdi karakter kümesinin tek parça olarak işlenemeyen metinler ve bir bayttan uzun bayt dizilimleri içermesine bağlı olarak oluşur. Bu durumda çokbaytlı dizilimin bölünmesi olasılığı vardır. Çağrıcı basitçe bu sorunlu baytları atlayıp girdiden kalan baytları okuyup <command>iconv</command>'ye aktararak dönüşümü devam ettirebilir. ISO C standardında böyle bir olay sonrasındaki duruma bağlı olarak dönüşüm işlevlerinin tanımlayıcıda tutulan dahili durum bilgisinin ne olacağı belirtilmemiştir.
    </para><para>
Ayrıca, örnekte <command>iconv</command> işlevinde geniş karakterli dizgelerin kullanımına bağlı sorunlar da gösterilmiştir. <command>iconv</command> işlevinin açıklamasında belirtildiği gibi, işlev daima bir <command>char</command> dizisi alır, dolayısıyla bu dizinin boyutu bayt cinsindendir. Örnekte ise çıktı tamponu bir geniş karakter tamponudur; bu nedenle <command>iconv</command> çağrısında <command>char*</command> türünde olan <varname>wrptr</varname> yerel değişkenini kullandık.
    </para><para>
Bu oldukça masum görünür ama hizalama konusunda sıkı sınırlamaları olan platformlarda sorunlara yol açabilir. Bu nedenle bu tür <command>iconv</command> çağrılarında ilgili karakter kümesindeki karakterlere erişmek için uygun bir gösterici kullanılmalıdır. İşlevin girdi parametresi bir <command>wchar_t</command> göstericisi olduğundan bu sağlanmıştır (aksi takdirde parametre hesaplanırken hizalama bozulacaktı). Fakat diğer bir durumda, özellikle kullanılan karakter kümesi türünün bilinmediği soysal işlevler yazılırken metinler bayt dizilimleri olarak ele alındığından bu çok zor olabilir.
    </para></sect1><sect1 xml:id="glibc-Other-iconv-Implementations">
    <title>Diğer <literal>iconv</literal> Gerçeklemeleri</title>
    <titleabbrev>Diğer <command>iconv</command> gerçeklemeleri hakkında.</titleabbrev>
    <para>
Burada diğer sistemlerdeki <command>iconv</command> gerçeklemelerini tartışmayacağız, ancak taşınabilir uygulamalar yazılırken onlar hakkında biraz birşeyler bilmek gerekir. Önceki bölümlerde <command>iconv</command> işlevinin belirtimi ile ilgili olarak taşınabilirlik sorunlarından bahsetmiştik.
    </para><para>
İlk uyarı, kullanılabilecek karakter kümesi sayısının çokluğu ile ilgilidir. Dönüşümlerin doğrudan C kütüphanesinde kodlanması elbette uygulanabilir değildir. Bu nedenle, dönüşüm bilgisi C kütüphanesi dışından bazı dosyalarla sağlanmalıdır. Bu, aşağıdaki yöntemlerden biri ya da her ikisi birden kullanılarak yapılır:
    </para><itemizedlist><listitem><para>
C kütüphanesi gerekli dönüşüm tablolarını ve diğer bilgileri veri dosyalarından okuyabilen işlevler ailesi içerir. Bu dosyalar gerektikçe yüklenir.
      </para><para>
Bu çözüm tüm karakter kümelerine (teorik olarak sonsuz sayıda) uygulanması büyük bir çaba gerektirdiğinden oldukça sorunludur. Farklı karakter kümelerinin yapısal farkları çok çeşitli tablo işleme işlevlerinin geliştirilmesini gerektirir.Bu işlevler doğaları gereğince özellikle gerçekleştirilmiş işlevlerden daha yavaştırlar.
      </para></listitem><listitem><para>
C kütüphanesi özdevimli yüklenebilen nesne dosyaları içerir ve dönüşüm işlevleri bu nesnelerin içeriğini icra eder.
      </para><para>
Bu çözüm çok büyük esneklik sağlar. C kütüphanesinin kendisi çok az kod içerir ve bu nedenle genel bellek ihtiyacı çok azalır. Ayrıca, C kütüphanesi ile yüklenebilir modüller arasındaki belgelemesi yapılmış bir arayüz ile kullanılabilecek dönüşüm modüllerinin üçüncü parti modüllerle genişletilebilmesi mümkündür. Bu çözümün uygulanabilir olması için özdevimli yükleme mümkün olmalıdır.
      </para></listitem></itemizedlist><para>
Ticari Unix'lerdeki bazı gerçeklemeler bu yöntemlerin bir karışımını kullanırken çoğunluğu ikinci çözümü kullanır. Yüklenebilir modüllerin kullanımı kodu kütüphanenin dışına taşır ve genişletmeler ve eklentiler için kapıyı açık tutar. Ancak, durağan olarak ilintilenmiş yazılımlarda özdevimli yükleme desteği olmayan bazı platformda bu tasarım bir sınırlama haline gelebilmektedir. Bu yeteneği olmayan platformlarda bu arayüzün durağan olarak ilintilenmiş yazılımlarda kullanılması bu nedenle mümkün değildir. GNU C kütüphanesinin, ELF platformlarında, bu gibi durumlarda özdevimli yükleme ile ilgili sorunları yoktur; bu nedenle bu konu tartışma götürür. Tehlike bu durumla ilgili bilgi sahibi olunduğu halde diğer sistemlerin sınırlamalarını unutmaktır.
    </para><para>
Diğer <command>iconv</command> gerçeklemeleri hakkında bilmemiz gereken ikinci şey kullanılabilecek dönüşümlerin genellikle çok sınırlı kalmasıyla ilgilidir. Bazı gerçeklemeler standart dağıtımlarında (geliştirici ve özel uluslararası dağıtımlar değil) en fazla 100 bilemedin 200 dönüşüm olasılığı sağlar. Bu 200 farklı karakter kümesinin desteklendiği anlamına gelse iyi; örneğin, bir karakter kümesinin on farklı karakter kümesine dönşümünü on olarak sayarlar. Bununla birlikte bu karakter kümesinin diğer yöndeki dönüşümü de eklenerek bu sayı 20 yapılır. Bu platformlarda yapılan ince hesabı varın siz düşünün. Bazı Unix şirketleri ise sadece bir dönüşümü diğer dönüşümleri kullanışsız olsa bile türetmek için kullanır.
    </para><para>
Bu doğrudan üçüncü ve oldukça büyük bir soruna yol açar. Bu yolla gerçeklenmiş <command>iconv</command> dönüşüm işlevlerini kullanan Unix sistemlerinde A kümesinden B kümesine ve B kümesinden C kümesine dönüşüm yapılabilmesi A kümesinden C kümesine dönüşüm yapılabileceği anlamına gelmez.
    </para><para>
İlk bakışta bir sorun yokmuş gibi görünse de basit bir uygulama sorunun farkedilmesini sağlar. Sorunu göstermek için A karakter kümesinden C karakter kümesine dönüşüm yapacak bir kod yazdığımızı varsayalım.
    </para><para>
<screen>
cd = iconv_open (&quot;C&quot;, &quot;A&quot;);
</screen></para><para>
çağrısı yukarıda belirttiğimiz nedenle başarısız olacaktır. Şimdi yazılımımızın geleceği ne olacak? Bu dönüşüm gerekli...
    </para><para>
Tam baş belası. <command>iconv</command> işlevi bunu yapmalıydı. Kodu nasıl yazmalı? Önce B karakter kümesine dönüşüm yapmayı deneyebiliriz:
    </para><para>
<screen>cd1 = iconv_open (&quot;B&quot;, &quot;A&quot;);</screen>
    </para><para>ve</para><para>
<screen>cd2 = iconv_open (&quot;C&quot;, &quot;B&quot;);</screen>
    </para><para>
Bu çalışacaktır, ama B'nin hangi karakter kümesi olacağını nasıl bileceğiz?
    </para><para>
Yanıtı ne yazık ki, genel bir çözümün olmadığıdır. Yine de bazı sistemler bize yardımcı olabilir. Bu sistemlerde çoğu karakter kümesi UTF-8 kodlu ISO-10646 veya Unicode metinlere ve tersine dönüştürülebilir. Bundan başka sisteme çok bağlı bir yöntem de yardımcı olabilir. Bu sistemlerde, dönüşüm işlevleri yüklenebilir modüllerde gelir ve bu modüller dosya sisteminde belirli bir yerde bulunurlar. Bu dosyalara bakarak A kümesinden C kümesine dönüşüm yaparken kullanılacak ortak ara dönüşüm kümesi saptanabilir.
    </para><para>
Bu örnek, yukarıda bahsedilen <command>iconv</command> tasarım hatalarından birinin örneğidir. Kullanılabilecek dönüşümlerin listesini yazılımsal olarak elde etmek en azından mümkün olmalıdır. <command>iconv_open</command> işlevi böyle bir dönüşümün olamayacağını söylerse bu yolla bu liste bulunabilir.
    </para></sect1><sect1 xml:id="glibc-glibc-iconv-Implementation">
    <title>glibc <literal>iconv</literal> Gerçeklemesi</title>
    <titleabbrev>GNU C kütüphanesindeki  <command>iconv</command> gerçeklemesi.</titleabbrev><para>
Bir önceki bölümde <command>iconv</command> gerçeklemelerinin sorunlarını okuduktan sonra GNU C kütüphanesindeki gerçeklemenin bu sorunlardan hiçbirine yol açmadığını söylemek elbette iyi olacaktır. Geliştirme şimdiki durumuna göre (Ocak 1999) genişletilerek sürdürülmektedir. <command>iconv</command> işlevlerinin geliştirmesi henüz bitmemiş olmakla birlikte temel işlevsellik değişmeyecektir.
    </para><para>
GNU C kütüphanesinin <command>iconv</command> gerçeklemesi dönüşümleri gerçekleştirmek için paylaşımlı yüklenebilir modülleri kullanır. Kütüphanenin kendi içinde yerleşik olan dönüşümlerin sayısı çok azdır fakat bunlar oldukça önemsiz dönüşümlerdir.
    </para><para>
Yüklenebilir modüllerin tüm faydalarından GNU C kütüphanesindeki gerçeklemede yararlanılmıştır. Arayüz iyi belgelendiğinden (aşağıya bakınız), bu özellikle cezbedicidir ve bundan dolayı yeni dönüşüm modüllerini yazmak kolaydır. Yüklenebilir modüllerin kullanımından kaynaklanan sakıncalar GNU C kütüphanesinde en azından ELF sistemlerde sorun çıkarmaz. Durağan olarak ilintili çalıştırılabilir nesneler olsalar bile, kütüphane, paylaşımlı nesneleri yükleyebildiğinden, durağan ilintilemenin <command>iconv</command> kullanılmak istendiğinde yasak olmaması gerekir.
    </para><para>
Bahsi geçen sorunlardan ikicisi desteklenen dönüşümlerin sayısı ile ilgiliydi. Şu anda GNU C kütüphanesi yüzelliden fazla karakter kümesini desteklemektedir. Bu karakter kümeleri arasında deteklenen dönüşümlerin sayısı ise 22350'den (150 çarpı 149) fazladır. Bir karakter kümesinden diğerinde dönüşüm eksikse kolayca eklenebilir.
    </para><para>
Bu yüksek sayıdan dolayı kısmen etkileyici olmakla birlikte GNU C kütüphanesindeki <command>iconv</command> gerçeklemesi önceki bölümde bahsedilen üçüncü sorundan da muaftır (A’dan B’ye ve B’den C’ye dönüşüm mümkünse A’dan C’ye doğrudan dönüşüm de daima mümkün olmalıdır da mümkün mü acaba sorunu). <command>iconv_open</command> işlevi bir hata ile dönerse ve <command>errno</command> değişkenine <command>EINVAL</command> değerini atarsa bu, istenen dönüşümün doğrudan ya da dolaylı olarak mümkün olmadığı anlamına gelir.
    </para><para>
<indexterm scope="glibc-cp"><primary>üçgenlere bölme</primary></indexterm>
Üçgenlere bölme her karakter kümesinin diğerine dönüşümü arada UCS-4 kodlu ISO-10646 dönüşümü kullanılarak gerçekleştirilir. Ara dönüşüm için ISO 10646 karakter kümesinin kullanılmasıyla üçgenlere bölmek mümkün olur.
    </para><para>
Yeni bir karakter kümesi için ISO 10646 kümesinde dönüşümün gerekliliğinden bahsetmek mümkün olmadığı gibi diğer karakter kümelerine dönüşümde ISO 10646'nın ne kaynak ne de hedef karakter kümesi olarak kullanılmasının gerekliliğinden bahsetmek mümkündür. Mevcut dönüşümlerin tamamı basitçe birbiriyle alakalı dönüşümlerdir.
    </para><para>
<indexterm scope="glibc-cp"><primary>ISO-2022-JP</primary></indexterm>
<indexterm scope="glibc-cp"><primary>EUC-JP</primary></indexterm>
Şu an mevcut olan tüm dönüşümler dönüşümü gereksiz yere yavaşlatan yukarıda bahsedilen üçgenlere bölme yöntemini kullanırlar. Eğer örneğin, ISO-2022-JP ve EUC-JP gibi bazı karakter kümeleri arasındaki dönüşümün hızlı olması istenirse aradan ISO 10646 çıkarılıp iki karakter kümesi arasında doğrudan bir dönüşüm yaptırılabilir. Bu iki karakter kümesi ISO 10646 ya nazaran birbirine daha benzer karakter kümeleridir.
    </para><para>
Böyle bir durumda yeni bir dönüşümü yazmak ve daha iyi bir seçenek üretmek kolaydır. GNU C kütüphanesinin <command>iconv</command> gerçeklemesi eğer daha verimli olacağı belirtilirse dönüşümü gerçekleştiren modülü özdevinimli olarak kullanacaktır.
    </para><sect2>
      <title> <command>gconv-modules</command> dosyalarının biçimi</title>
      <para>
Kullanılabilir dönüşümler hakkındaki bilgilerin tamamı <command>gconv-modules</command> adı verilen bir dosyanın içinde yeralır. Bu dosyanın yeri <command>GCONV_PATH</command> ortam değişkeninde kayıtlıdır. <command>gconv-modules</command> dosyaları satırlardan oluşan metin dosyalarıdır. Dosyadaki her satır şöyle yorumlanır:
     </para><itemizedlist><listitem><para>
Bir satırdaki boşluk olmayan ilk karakter bir <command>#</command> karakteri ise bu satırın sadece açıklamaları içerdiği varsayılır ve içeriği yorumlanmaz.
       </para></listitem><listitem><para>
<command>alias</command> ile başlayan satırlar karakter kümesi için bir takma ad tanımlar. Bu satırlar üzerinde iki sözcük olması beklenir. İlk sözcük takma adı, ikinci sözcük ise karakter kümesinin gerçek adını belirtir. Bu satırlarda belirtilen takma adları <command>iconv_open</command> işlevinin <varname>kaynak_kod</varname> veya <varname>hedef_kod</varname> parametrelerinde kullanırsanız gerçek karakter kümesi ismi kullanılmış gibi işlem yapılır.
       </para><para>
Bir karakter kümesinin birçok farklı isim aldığı duruma sıkça rastlanır. Genelde karakter kümesinin resmi ismi yerine halk dilindeki ismi kullanılır. Bundan başka bir karakter kümesinin çeşitli nedenlerle oluşturulmuş özel isimleri de olabilir. Örneğin ISO tarafından belirtilen tüm karakter kümeleri <varname>nnn</varname> kayıt numarası olmak üzere <command>ISO-IR-<varname>nnn</varname></command> biçiminde bir takma isme sahiptir. Bu, yazılımlarca karakter kümesi isimlerini oluşturan kayıt numaralarının bilinmesini ve bunların <command>iconv_open</command> çağrılarında kullanılabilmesini mümkün kılar. Bir karakter kümesi ile ilintili tüm takma isimler altalta ayrı satırlarda belirtilebilir.
       </para></listitem><listitem><para>
<command>module</command> ile başlayan satırlar mevcut dönüşüm modüllerini içerir. Bu satırlar üç veya dört sözcük içermelidir.
       </para><para>
İlk sözcük kaynak karakter kümesini, ikincisi hedef karakter kümesini, üçüncüsü ise bu dönüşümde yüklenecek olan modülün dosya ismini belirtir. Dosya ismi paylaşımlı nesne dosyalarının uzantısını (normalde <command>.so</command>) içermemelidir. Bu dosyaların <command>gconv-modules</command> dosyasının bulunduğu dizinde olduğu varsaylır. Satırdaki son sözcük isteğe bağlıdır. Dönüşüm bedelini gösteren bir tamsayıdır ve belirtilmemişse öntanımlı değeri olan 1 olduğu varsayılır. Dönüşümü gerçekletirecek alt dönüşümlerin sayısını belirtir. Bedel değerinin kullanımını bir örnekle açıklayalım.
       </para></listitem></itemizedlist><para>
Yukarıdaki örneğe dönersek, ISO-2022-JP ile EUC-JP karakter kümeleri arasında doğrudan dönüşüm için bir modülün varlığından sözetmiştik. Her iki yönde de dönüşüm tek bir modül tarafından yapılır ve bu modülün dosya ismi ISO2022JP-EUCJP.so'dur. Dosyanın bulunduğu dizindeki <command>gconv-modules</command> dosyasının içeriğinde bu modülün tanımı şöyle olurdu:
     </para><para>
<screen>
module  ISO-2022-JP//   EUC-JP//        ISO2022JP-EUCJP    1
module  EUC-JP//        ISO-2022-JP//   ISO2022JP-EUCJP    1
</screen></para><para>
Bu iki satırın neden yeterli olduğunu anlamak için <command>iconv</command> tarafından bunların nasıl kullanıldığını anlamak gerekir. Bu soruna yaklaşım oldukça basittir.
     </para><para>
<command>iconv_open</command> işlevinin ilk çağrısında yazılım tüm <command>gconv-modules</command> dosyalarını okur ve iki tablo oluşturur: Biri bilinen takma adları diğeri dönüşümler ve bunları gerçekleştiren paylaşımlı nesneyi içerir.
     </para></sect2><sect2>
       <title><command>iconv</command>'de dönüşüm yolunun bulunması</title>
       <para>
Olası dönüşümlerin listesi önemli kenarların oluşturduğu bir çizge şeklinde tarif edilebilir. Kenarların önemini <command>gconv-modules</command> dosyalarında belirtilen bedeller belirler. <command>iconv_open</command> işlevi kaynak ve hedef karakter kümeleri arasındaki en kısa yolu bulmak için böyle bir çizgeyle çalışan bir algoritma kullanır.
     </para><para>
<command>iconv</command> gerçeklemesinin neden örneğin ISO-2022-JP ve EUC-JP karakter kümeleri arasındaki dönüşümlerde kütüphane ile gelen dönüşümler yerine <command>gconv-modules</command> dosyalarında belirtilen dönüşüm modülünü kullandığını açıklamak artık kolaydır. Kütüphane ile gelen dönüşümler, dönüşümü iki adımda gerçekleştirir (ISO-2022-JP -> ISO 10646 ve ISO 10646 -> EUC-JP). Bu durumda bedel = 1 + 1 = 2 olur. Yukarıda ise <command>gconv-modules</command> dosyasında bu dönüşümün bedeli 1 olan bir dönüşüm modülü ile gerçekleştirilebileceği belirtilmiştir.
     </para><para>
Yukarıdaki (ve ayrıca GNU C kütüphanesi ile gelen) <command>gconv-modules</command> dosyası ile ilgili gizemli bir öğe <command>module</command> satırlarında belirtilmiş karakter kümesi isimleridir. Bu isimlerin bazıları neden <command>//</command> ile biter? Bu şekilde biten isimler birer düzenli ifade olduklarından öyle biterler. Heceleme ile ilgilenmiyorsanız bu size bir şey ifade etmeyecektir. Kusura bakmayın! <emphasis>Gerçeklenimin bu kısmı henüz bitmedi. Şimdilik sadece örnekleri izlemekle yetinin, lütfen. Gerçeklenim tamamlanınca herşey daha iyi olacak. -drepper</emphasis>
     </para><para>
<command>gconv-modules</command> hakkındaki son düşünceler <command>//</command> ile bitmeyen isimlerle ilgilidir. <command>INTERNAL</command>  diye bir karakter kümesi ismi sık sık geçer. Bu karakter kümesi ismi yukarıdaki dönüşüm tartışmasında üçlemenin ara adımını oluşturan karakter kümesini nitelemek için seçilmiştir. Bunun aslında UCS-4 olduğundan bahsetmişsek de bu tamamen doğru değildir. UCS-4 belirtimi, kendi içinde bayt sıralaması için kullanılan bir belirtim daha içerir. Bir UCS-4 değeri 4 bayttan oluştuğundan saklanan değer bayt sıralamasından etkilenir. Eğer işlemcinin (en azından çalışan sürecin) bayt sıralaması UCS-4 için gerekenle aynı değilse, değerin dahili gösterimi UCS-4’teki ile aynı olmayacaktır. Dönüşüm sırasında ara dönüşüm ürününün durumu ile ilgilenmeyen biri için bayt takaslama işlemlerine zaman harcamanın gereği yoktur. Bayt sıralama sorunlarından kaçınmak için, en kıymetli baytın en düşük adrese yerleştirildiği bayt sıralamasını kullanan sistemlerle aynı bayt sıralamasına sahip dahili karakter kümesine <command>INTERNAL</command> ismi verilmiştir.
     </para></sect2><sect2>
       <title><literal>iconv</literal> modülü veri yapıları</title>
       <para>
Bu bölüme kadar modüllerin yerlerinin kullanımı açıklandı. Burada yeni bir modül yazmak için kullanılacak arayüz açıklanacaktır. Bu bölümde açıklanacak arayüz Ocak 1999'dan beri kullanılmaktadır. Arayüz gelecekte biraz değişecekse de bu değişiklik uyumluluk korunarak yapılacaktır.
     </para><para>
Yeni bir modülü yazmak için gerekli tanımlar standartdışı bir başlık dosyası olan <filename>gconv.h</filename> içindedir. Aşağıda, bu dosyada bulunan tanımlar şimdilik sadece bir önbilgi verecek kadar açıklanmıştır.
     </para><para>
<command>iconv</command> kullanıcısının bakış açısından arayüz basittir: <command>iconv_open</command> işlevi <command>iconv</command> çağrılarında kullanılabilen bir tanıtıcı ile döner. Bu tanıtıcının görevi sona erdiğinde  bir <command>iconv_close</command> çağrısı ile tanıtıcı serbest bırakılır. Burada sorun, tanıtıcı <command>iconv</command> işlevine aktarılan herşey olduğundan tanıtıcının tüm dönüşüm adımlarını ve ayrıca her dönüşümün durum bilgisini tutması zorunluluğudur. Bu nedenle, gerçeklemeyi anlamak için en önemi elemanlar aslında bu veri yapılarıdır.
     </para><para>
İki farklı veri yapısına ihtiyacımız var. İlki dönüşümü, ikincisi da durumu, v.s. yi açıklamak için. Aslında <filename>gconv.h</filename> dosyasında bunun gibi iki tanım vardır.
<indexterm scope="glibc-pg"><primary>gconv.h</primary></indexterm>
    </para><para xml:id="glibc-struct__gconv_step">
<indexterm scope="glibc-tp"><primary sortas="gconv_step">struct __gconv_step</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü">
<funcdef>struct <command>__gconv_step</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu veri yapısı bir modülün gerçekleştirdiği bir dönüşümü açıklar. Dönüşüm işlevleri ile yüklenen bir modüldeki her işlev için bu türde tek bir nesne vardır (bu nesne asıl dönüşüme ilişkin bir bilgi içermez, sadece dönüşümün kendisini tanımlar).
     </para><para>
       <glosslist><glossentry><glossterm>
         <literal>struct __gconv_loaded_object *</literal><command>__shlib_handle</command>
       </glossterm></glossentry><glossentry><glossterm>
         <literal>const char *</literal><command>__modname</command>
       </glossterm></glossentry><glossentry><glossterm>
         <literal>int </literal><command>__counter</command>
       </glossterm><glossdef><para>
Yapının bu elemanları C kütüphanesi tarafından dahili olarak kullanılır ve paylaşımın yüklenmesini ve kaldırılmasını yönetirler.  Birinin kullanılmış olması diğerlerinin kullanılmasını ya da ilklendirilmesini gerektirmez.
       </para></glossdef></glossentry><glossentry><glossterm>
         <literal>const char *</literal><command>__from_name</command>
       </glossterm></glossentry><glossentry><glossterm>
         <literal>const char *</literal><command>__to_name</command>
       </glossterm><glossdef><para>
<command>__from_name</command> ve <command>__to_name</command> alanları kaynak ve hedef karakter kümelerinin isimlerini içerir. Bir modül birden fazla karakter kümesi ve yönde dönüşüm için kullanılabildiğinden asıl dönüşümü tanımlamakta kullanılır.
       </para></glossdef></glossentry><glossentry><glossterm>
         <literal>gconv_fct </literal><command>__fct</command>
       </glossterm></glossentry><glossentry><glossterm>
         <literal>gconv_init_fct </literal><command>__init_fct</command>
       </glossterm></glossentry><glossentry><glossterm>
         <literal>gconv_end_fct </literal><command>__end_fct</command>
       </glossterm><glossdef><para>
Bu alanlar yüklenebilir modüldeki işlevlere göstericileri içerir. Arayüz aşağıda açıklanacaktır.
       </para></glossdef></glossentry><glossentry><glossterm>
         <literal>int </literal><command>__min_needed_from</command>
       </glossterm></glossentry><glossentry><glossterm>
         <literal>int </literal><command>__max_needed_from</command>
       </glossterm></glossentry><glossentry><glossterm>
         <literal>int </literal><command>__min_needed_to</command>
       </glossterm></glossentry><glossentry><glossterm>
         <literal>int </literal><command>__max_needed_to;</command>
       </glossterm><glossdef><para>
Bu değerler modülün ilklendirme işleviyle atanmalıdır. <command>__min_needed_from</command> değeri kaynak karakter kümesinin en az kaç bayt gerektirdiğini belirtir. <command>__max_needed_from</command> değeri azami değer ile ayrıca olası öteleme dizilimlerini belirtir.
        </para><para>
The <command>__min_needed_to</command> ve <command>__max_needed_to</command> ise benzer değerleri hedef karakter kümesi için içerir.
        </para><para>
Bu değerlerin doğruluğu son derece önemlidir, çünkü aksi takdirde dönüşüm işlevleri sorun çıkaracak ve bekleneni yapmayacaktır.
       </para></glossdef></glossentry><glossentry><glossterm>
         <literal>int </literal><command>__stateful</command>
       </glossterm><glossdef><para>
Bu eleman da ilklendirme işlevi ile ilklendirilmelidir. Kaynak karakter kümesi durumsal ise bu elemanın değeri sıfırdan farklı olacaktır.
       </para></glossdef></glossentry><glossentry><glossterm>
         <literal>void *</literal><command>__data</command>
       </glossterm><glossdef><para>
Bu eleman modüldeki dönüşüm işlevleri tarafından serbestçe kullanılabilir. <command>void *__data</command> bir çağrıdan diğerine fazladan bilgi aktarmak için kullanılabilir. Gerekmedikçe ilklendirilmesi gerekmez. Elemana özdevimli ayrılmış bir bellek alanının göstericisi atanmışsa (büyük ihtimalle ilklendirme işlevi tarafından), kullanılacak son işlevin bu alanı serbest bırakması sağlanmalıdır. Aksi takdirde uygulama bellek kaçağına sebep olur.
        </para><para>
Bu veri yapısının bu belirtim dönüşümünün tüm kullanıcıları tarafından paylaşılmasının sağlanması önemlidir. Bu nedenle, <command>__data</command> elemanının, dönüşüm işlevinin belli bir kullanımına özgü veri içermemesi gerekir.
       </para></glossdef></glossentry></glosslist>
</para></funcdescr></funcsynopsis></para><para xml:id="glibc-struct__gconv_step_data">
<indexterm scope="glibc-tp"><primary sortas="gconv_step_data">struct __gconv_step_data</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü">
<funcdef>struct <command>__gconv_step_data</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu veri türü dönüşüm işlevlerinin kullanımına özel bilgileri içerir.
   </para><para>
     <glosslist><glossentry><glossterm>
       <literal>char *</literal><command>__outbuf</command>
     </glossterm></glossentry><glossentry><glossterm>
       <literal>char *</literal><command>__outbufend</command>
     </glossterm><glossdef><para>
Bu elemanlar dönüşüm adımında kullanılan çıktı tamponuna ilişkin veriyi içerir. <command>__outbuf</command> elemanı tamponun başlangıcını, <command>__outbufend</command> elemanı ise  tamponun son baytını belirtir. Dönüşüm işlevi tamponun boyutunun herşeye yeterli olduğunu varsaymamalı, ancak en azından tam bir karakter için tamponda yeterli yer olduğunu varsaymalıdır.
        </para><para>
Dönüşüm bittikten sonra, eğer dönüşüm son adımdaysa, son bayt tampona yazıldıktan sonra ne kadar mevcut çıktı olduğunu belirtmek için <command>__outbuf</command> elemanı değiştirilmelidir, <command>__outbufend</command> elemanı değiştirilmemelidir.
     </para></glossdef></glossentry><glossentry><glossterm>
       <literal>int </literal><command>__is_last</command>
     </glossterm><glossdef><para>
Dönüşüm işlemi son adımdaysa bu elemanın değeri sıfırdan farklıdır. Bu bilgi yineleme için gereklidir. Aşağıdaki dönüşüm işlevlerinin iç yapıları ile ilgili açıklamalara bakınız. Bu eleman asla değiştirilmemelidir.
     </para></glossdef></glossentry><glossentry><glossterm>
       <literal>int </literal><command>__invocation_counter</command>
     </glossterm><glossdef><para>
Dönüşüm işlevi bu elemanı kaç defa çağrıldığı bilgisini tutmak için kullanabilir. Bazı karakter kümeleri dönüşüm işlevinin ilk adımında bazı çıktılar üretirler. Bu alan bu ilk adımın belirlenmesi için kullanılabilir. Bu eleman asla değiştirilmemelidir.
     </para></glossdef></glossentry><glossentry><glossterm>
       <literal>int </literal><command>__internal_use</command>
     </glossterm><glossdef><para>
Bu eleman belli bazı durumlar için kullanılabilen alanlardan biridir. Dönüşüm işlevleri <command>mbsrtowcs</command> işlevini gerçeklemekte kullanılmışsa (yani, işlev <command>iconv</command> gerçeklemesi üzerinden doğrudan kullanılmamışsa) bu alana sıfırdan farklı bir değer atanır.
        </para><para>
<command>mbsrtowcs</command> işlevlerinin normalde bütün metni dönüştürmek için tek tek dizgeleri dönüştürmek üzere defalarca çağrılmasına karşın <command>iconv</command> işlevlerinin metnin tamamını dönüştürmekte kullanılması gibi bir fark oluşur.
        </para><para>
Fakat bu durumda karakter kümesinin belirtimindeki bazı kuralların yerine getirilmesiyle ilgili bazı sorunlarla karşılaşılır. Bazı karakter kümeleri metnin tamamı için bir defalığına ilk adımda bir çıktı verilmesini gerektirir. Eğer metni dönüştürme işlemi <command>mbsrtowcs</command> işlevinin defalarca çağrılmasını gerektiriyorsa, ilk çağrıda bu çıktı verilmelidir. Bununla birlikte, <command>mbsrtowcs</command> işlevinin çağrıları arasında iletişim olmadığından dönüşüm işlevlerinin bu çıktıyı vermesi mümkün olmaz. Bu durum tanıtıcı sayesinde bu bilgiye erişebilen <command>iconv</command> çağrılarından farklı bir durumdur.
        </para><para>
<command>int __internal_use</command> elemanı çoğunlukla <command>__invocation_counter</command> elemanı ile birlikte ağağıdaki gibi kullanılır:
        </para><para>
<screen>
if (!data->__internal_use
      &amp;&amp; data->__invocation_counter == 0)
  /* İlk adım çıktısını bas.  */
  …
</screen>
        </para><para>
Bu elemanın değeri asla değiştirilmemelidir.
     </para></glossdef></glossentry><glossentry><glossterm>
       <literal>mbstate_t *</literal><command>__statep</command>
     </glossterm><glossdef><para>
<command>__statep</command> elemanı  <command>mbstate_t</command> (bkz. <xref linkend="glibc-Keeping-the-state"/>) türünde bir nesneye göstericidir. Durumsal bir karakter kümesi dönüşüm durumu hakkındaki bilgileri saklamak için <command>__statep</command> ile gösterilen alanı kullanmalıdır. <command>__statep</command> elemanı kendini asla değiştirmemelidir.
     </para></glossdef></glossentry><glossentry><glossterm>
       <literal>mbstate_t </literal><command>__state</command>
     </glossterm><glossdef><para>
Bu eleman <emphasis>asla</emphasis> doğrudan değiştirilmemelidir.  Yapının kullandığı alanın belirtildiği bir elemandır.
     </para></glossdef></glossentry></glosslist>
   </para></funcdescr></funcsynopsis></para>
   </sect2><sect2><title><literal>iconv</literal> modül arayüzleri</title>
     <para>
Veri yapıları hakkında bilgi edindikten sonra dönüşüm işlevlerinin açıklamalarına girebiliriz. Arayüzü anlayabilmek için dönüşüm nesnelerini yükleyen C kütüphanesindeki işlevsellik hakkında biraz önbilgi vermek gerekir.
     </para><para>
Bir dönüşümün defalarca kullanıldığı duruma sıklıkla rastlanır (yazılımın çalışması esnasında aynı karakter kümesi için çok sayıda <command>iconv_open</command> çağrısı yapılması). GNU C kütüphanesindeki <command>mbsrtowcs</command> ve benzeri işlevler de aynı işlevin kullanım sayısını arttıran <command>iconv</command> işlevselliğini kullanırlar.
     </para><para>
Dönüşümlerin böyle defalarca kullanılabilmesinden dolayı modüller her dönüşüm için tekrar yüklenmezler. Modül bir kere yüklendikten sonra aynı <command>iconv</command> veya <command>mbsrtowcs</command> çağrıları defalarca yapılabilir. Bilgilerin işleve özel dönüşüm bilgileri ve dönüşüm verisi bilgileri olarak ayrılabilmesi sayesinde bu mümkün olur. Bunun yapılmasını sağlayan iki veri yapısından bir önceki bölümde bahsedilmişti.
     </para><para>
Bu ayrıca, modül tarafından sağlanan işlevlerin sözdiziminde ve arayüzün kendisinde de yansıtılır. Aşağıdaki isimlere sahip olması zorunlu üç işlev vardır:
     </para><variablelist><varlistentry>
     <term><literal>gconv_init</literal></term><listitem><para>
<command>gconv_init</command> işlevi, dönüşüm işlevine özel veri yapısını ilklendirir. Bu nesne bu dönüşümü kullanan tüm dönüşümlerce paylaşılır ve bu nedenle, dönüşümün kendisi ile ilgili durum bilgisi burada saklanmaz. Bir modül birden fazla dönüşümü gerçekleştirebiliyorsa <command>gconv_init</command> işlevi defalarca çağrılabilir.
        </para></listitem></varlistentry><varlistentry>
        <term><literal>gconv_end</literal></term><listitem><para>
<command>gconv_end</command> işlevi, <command>gconv_init</command> işlevi ile ayrılan tüm özkaynakları serbest bırakmak için kullanılır. Böle bir işlem gerekmiyorsa bu işlev tanımlanmayabilir. Modül birden fazla dönüşümü gerçekleştirebiliyorsa ve <command>gconv_init</command> işlevi her dönüşüm için aynı özkaynakları ayırmıyorsa bu işlevi tanımlarken dikkatli olunmalıdır.
        </para></listitem></varlistentry><varlistentry>
        <term><literal>gconv</literal></term><listitem><para>
Asıl dönüşüm işlevidir. Bir metin bloğunu dönüştürmekte kullanılır. Dönüşüm işlevlerinin bu amaca yönelik dönüşüm verisi ve <command>gconv_init</command> ile ilklendirilen dönüşüm adım bilgisi işleve aktarılmalıdır.
        </para></listitem></varlistentry></variablelist><para>
Bu üç modül arayüz işlevi için tanımlanmış üç veri türü vardır ve bunlar arayüzü tanımlar:
     </para><para xml:id="glibc__gconv_init_fct">
<indexterm scope="glibc-fn"><primary sortas="gconv_init_fct">(*__gconv_init_fct)</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>(*__gconv_init_fct)</command></funcdef>
<paramdef>(struct __gconv_step *)</paramdef>
</funcprototype><funcdescr><para>
Modülün gerçekleştirdiği her dönüşüm için sadece bir kere çağrılan ilklendirme işlevinin arayüzünü belirler.
     </para><para>
<command>struct __gconv_step</command> veri yapısının açıklamasında değinildiği gibi ilklendirme işlevi bu veri yapısının elemanlarını ilklendirir.
     </para><para>
     <variablelist><varlistentry>
     <term><literal>__min_needed_from</literal></term>
     <term><literal>__max_needed_from</literal></term>
     <term><literal>__min_needed_to</literal></term>
     <term><literal>__max_needed_to</literal></term><listitem><para>
Bu elemanlar kaynak ve hedef karakter kümelerindeki bir karakteri oluşturan bayt sayısının azami ve asgari değerleri ile ilklendirilmelidir. Karakaterlerin hepsi aynı bayt sayısı ile ifade ediliyorsa azami ve asgari değerler aynı olacaktır.
     </para></listitem></varlistentry><varlistentry>
     <term><literal>__stateful</literal></term><listitem><para>
Bu eleman kaynak karaker kümesinin durumsal olması halinde sıfırdan farklı, aksi takdirde sıfır olmalıdır.
     </para></listitem></varlistentry></variablelist>
     </para><para>
İlklendirme işlevinin dönüşüm işlevi ile bilgi alışverişi yapması gerekliyse, bu iletişim <command>__gconv_step</command> yapısının <command>__data</command> elemanı kullanılarak yapılabilir. Ancak, bu veri tüm dönüşümlerce paylaşılacağından dönüşüm işlevleri bu veriyi değiştirmemelidir. Bunun yapılışına bir örnek:
     </para><para>
<screen>
#define MIN_NEEDED_FROM         1
#define MAX_NEEDED_FROM         4
#define MIN_NEEDED_TO           4
#define MAX_NEEDED_TO           4

int
gconv_init (struct __gconv_step *step)
{
  /* Dönüşüm yönünü belirleyelim.  */
  struct iso2022jp_data *new_data;
  enum direction dir = illegal_dir;
  enum variant var = illegal_var;
  int result;

  if (__strcasecmp (step->__from_name, "ISO-2022-JP//") == 0)
    {
      dir = from_iso2022jp;
      var = iso2022jp;
    }
  else if (__strcasecmp (step->__to_name, "ISO-2022-JP//") == 0)
    {
      dir = to_iso2022jp;
      var = iso2022jp;
    }
  else if (__strcasecmp (step->__from_name, "ISO-2022-JP-2//") == 0)
    {
      dir = from_iso2022jp;
      var = iso2022jp2;
    }
  else if (__strcasecmp (step->__to_name, "ISO-2022-JP-2//") == 0)
    {
      dir = to_iso2022jp;
      var = iso2022jp2;
    }

  result = __GCONV_NOCONV;
  if (dir != illegal_dir)
    {
      new_data = (struct iso2022jp_data *)
        malloc (sizeof (struct iso2022jp_data));

      result = __GCONV_NOMEM;
      if (new_data != NULL)
        {
          new_data->dir = dir;
          new_data->var = var;
          step->__data = new_data;

          if (dir == from_iso2022jp)
            {
              step->__min_needed_from = MIN_NEEDED_FROM;
              step->__max_needed_from = MAX_NEEDED_FROM;
              step->__min_needed_to = MIN_NEEDED_TO;
              step->__max_needed_to = MAX_NEEDED_TO;
            }
          else
            {
              step->__min_needed_from = MIN_NEEDED_TO;
              step->__max_needed_from = MAX_NEEDED_TO;
              step->__min_needed_to = MIN_NEEDED_FROM;
              step->__max_needed_to = MAX_NEEDED_FROM + 2;
            }

          /* Evet, bu durumsal bir kodlama.  */
          step->__stateful = 1;

          result = __GCONV_OK;
        }
    }

  return result;
}
</screen></para><para>
İşlev önce hangi dönüşümün istendiğine bakar. Bu işlev ile ele alınan modül dört farklı dönüşümü gerçekleştirmektedir; hangisinin kullanılmak istendiği isimlere bakarak saptanabilir. Karşılaştırma daima harf büyüklüğünden bağımsız olarak yapılmalıdır.
     </para><para>
Sonra, seçilen dönüşüm için gerekli bilgileri içeren veri yapısına sıra geliyor ve buna yer ayrılıyor. <command>struct iso2022jp_data</command> yerel olarak modülün dışında tanımlandığından bu veri işlev dışında kullanılamaz. Eğer modülün desteklediği dört dönüşümün tamamı için dönüşüm istenseydi, dört veri bloğu olacaktı.
     </para><para>
İlginç olan veri nesnesinin <command>__min_</command> ve <command>__max_</command> elemanlarının ilklendirme adımıdır. Tek bir ISO-2022-JP karakteri bir bayttan dört bayta kadar uzunlukta olabilir. Bundan dolayı burada <command>MIN_NEEDED_FROM</command> ve <command>MAX_NEEDED_FROM</command> makroları kullanılmıştır. Çıktı daima dahili karakter kümesi (UCS-4) olacağından her karakter daima dört bayt uzunlukta olacaktır. Dahili karakter kümesinden ISO-2022-JP karakter kümesine dönüşüm için önceleme dizilimlerinin karakter kümeleri arasında geçiş yapmak için gerekli olduğunu hesaba katmak zorundayız. Bu nedenle, bu yön için <command>__max_needed_to</command> elemanına <command>MAX_NEEDED_FROM + 2</command> değeri atanmaktadır. Böylece diğer karakter kümesine geçiş için gekeli olan önceleme dizilimleri hesaba katılmış olur.  İki yöndeki azami değerler arasındaki dengesizlik kolayca açıklanabilir: ISO-2022-JP metin okunurken önceleme dizilimleri tek başlarına elde edilebilir (yani, önceleme diziliminin etkisi durum bilgisi içinde kaydedilmiş olacağından önceleme dizilimi bir gerçek karakterin işlenmesinde gerekli değildir).  Diğer yönde durum farklıdır.  Hangi karakter kümesinin sonra geleceği genelde bilinmediğinden durumu değiştirecek önceleme dizilimleri ileriye dönük hesaba katılamaz. Bu, önceleme dizilimlerinin sonraki karakter ile birlikte ele alınması zorunluluğu demektir. Bu nedenle karakterin gerektirdiğinden daha fazla alan gereklidir.
     </para><para>
İlklendirme işlevinin olası dönüş değerleri şunlardır:
     </para><para><variablelist><varlistentry>
     <term><command>__GCONV_OK</command></term><listitem><para>
İlklendirme başarılı.
        </para></listitem></varlistentry><varlistentry>
        <term><literal>__GCONV_NOCONV</literal></term><listitem><para>
İstenen dönüşümü bu modül desteklemiyor. Bu durum, <command>gconv-modules</command> dosyası hatalıysa oluşabilir.
        </para></listitem></varlistentry><varlistentry>
        <term><literal>__GCONV_NOMEM</literal></term><listitem><para>
Ek bilginin saklanacağı bellek ayrılamadı.
        </para></listitem></varlistentry></variablelist>
</para></funcdescr></funcsynopsis></para><para>
Modül yüklenmeden işlevin çağrılması önemce daha kolaydır. Çoğunlukla hiçbir şeye sebep olmaz; tamamen ihmal edilebilir.
    </para><para xml:id="glibc__gconv_end_fct">
<indexterm scope="glibc-fn"><primary sortas="gconv_end_fct">(*__gconv_end_fct)</primary></indexterm>
<funcsynopsis><funcprototype role="işlav">
<funcdef>void <command>(*__gconv_end_fct)</command></funcdef>
<paramdef>(struct gconv_step *)</paramdef>
</funcprototype><funcdescr><para>
Bu işlevin görevi ilklendirme işlevinin ayırdığı tüm özkaynakları serbest bırakmaktır. Bu nedenle argüman olarak nesnenin sadece <command>__data</command> elemanını kullanır. İlklendirme işlevi ile ilgili örneğe devam edersek dönüşümü sonlandıran işlev şöyle olurdu:
     </para><para>
<screen>
void
gconv_end (struct __gconv_step *data)
{
  free (data->__data);
}
</screen>
</para></funcdescr></funcsynopsis></para><para>
En önemli işlev, karmaşık karakter kümeleri için oldukça karışık olabilen dönüşüm işlevinin kendisidir. Daha fazlası gerekli olmadığından burada işlevin sadece iskeletinden bahsedilecektir.
     </para><para xml:id="glibc__gconv_fct">
<indexterm scope="glibc-fn"><primary sortas="gconv_fct">(*__gconv_fct)</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>(*__gconv_fct)</command></funcdef>
<paramdef>
(struct __gconv_step *,
 struct __gconv_step_data *,
 const char **,
 const char *,
 size_t *,
 int)</paramdef>
</funcprototype><funcdescr><para>
Dönüşüm işlevinin çağrılmasını gerektiren iki sebep olabilir: Metni dönüştürmek ya da durumu sıfırlamak. <command>iconv</command> işlevinin açıklamasına bakılırsa boşaltma kipinin neden gerekli olduğu görülebilir. Hangi kipin seçilmiş olduğu bir tamsayı olan altıncı argümana bakılarak saptanır. Boşaltma kipi seçilmişse bu argümanın değeri sıfırdan farklı olacaktır.
     </para><para>
Çıktı tamponunun yerinin her iki kip için ortak olduğu görülür. Bu tampon hakkındaki bilgi dönüşüm adım verisinde saklanır. Bu bilgiye ilişkin gösterici işleve ikinci argüman olarak aktarılır. <command>struct __gconv_step_data</command> yapısının açıklaması dönüşüm adım verisi hakkında daha fazla bilgi içerir.
     </para><para>
<indexterm scope="glibc-cp"><primary>durumsal</primary></indexterm>
Boşaltma için ne yapılacağı kaynak karakter kümesine bağlıdır. Eğer kaynak karakter kümesi durumsal değilse birşey yapmak gerekmez. Aksi takdirde, işlev durum nesnesini ilk duruma getirecek bir bayt dizilimini göndermek zorundadır. Bu yapıldıktan sonra dönüşüm zincirindeki diğer dönüşüm işlevlerine de bu imkan tanınmalıdır. Bu işlevi başka bir adımın izleyip izlemeyeceği ilk argümana adım verisinin <command>__is_last</command> elemanındaki bilgi aktarılarak saptanabilir.
     </para><para>
Metnin dönüştürüldüğü kip daha ilginçtir. Bu kipteki ilk adımda girdi tamponundaki metnin olabildiğince büyük bir kısmı dönüştürülür ve sonuç çıktı tamponunda saklanır. Girdi tamponunun başlangıcı, tamponun başlangıcını gösteren bir göstericiye gösterici olan üçüncü argümandan saptanır. Dördüncü argüman tampondaki son bayttan sonraki bayta bir göstericidir.
     </para><para>
Dönüşüm, eğer karakter kümesi durumsal ise mevcut duruma bağlı olarak uygulanır. Durum bilgisi adım verisinin <command>__statep</command> elemanı tarafından gösterilen bir nesnede saklanır (ikinci argüman). Girdi tamponu boşsa ya da çıktı tamponu dolmuşsa dönüşüm durdurulur. Bu durumda üçüncü parametredeki gösterici değişkeni son işlenen bayttan sonraki baytı göstermelidir (eğer tüm girdi tüketilmişse, bu gösterici ve dördüncü parametre aynı değerde olur).
     </para><para>
Sonra ne yapılacağı bu adımın son adım olup olmamasına bağlıdır. Eğer bu adım son adımsa yapılacak tek şey, adım verisi yapısının <command>__outbuf</command> elemanının son yazılan bayttan sonraki baytı gösterecek şekilde güncellenmesidir. Ek olarak, beşinci parametre tarafından gösterilen <command>size_t</command> türündeki değişken geri dönüşümsüz olarak dönüştürülen karakter sayısı (bayt sayısı değil) kadar arttırılmalıdır. Bundan sonra işlev dönebilir.
     </para><para>
Eğer bu adım son adım değilse, sonraki dönüşüm işlevlerine kendi görevlerini yerine getirebilmeleri imkanı sağlanmalıdır. Bu nedenle uygun dönüşüm işlevi çağrısı yapılmalıdır. İşlevler hakkındaki bilgiler dönüşüm veri yapılarında saklanır ve ilk parametre olarak aktarılır. Bu bilgi ve adım verisi dizilerde saklanır, bu durumda sonraki eleman her iki halde de basit olarak gösterici aritmetiği ile bulunabilir:
     </para><para>
<screen>
int
gconv (struct __gconv_step *step, struct __gconv_step_data *data,
       const char **inbuf, const char *inbufend, size_t *written,
       int do_flush)
{
  struct __gconv_step *next_step = step + 1;
  struct __gconv_step_data *next_data = data + 1;
  …
</screen></para><para>
<command>next_step</command> göstericisi sonraki adım bilgisini içerirken, <command>next_data</command> sonraki veri kaydını içerir. Sonraki işlev çağrısı bu nedenle şöyle görünecektir:
     </para><para>
<screen>
  next_step->__fct (next_step, next_data, outerr, outbuf,
                    written, 0)
</screen></para><para>
Fakat henüz bu yeterli değildir. İşlev çağrısı döndükten sonra dönüşüm işlevi biraz daha işlem yapmak zorunda kalabilir. İşlevin dönüş değeri <command>__GCONV_EMPTY_INPUT</command> ise, çıktı tamponunda hala yer var demektir. Girdi tamponu boş olmadıkça dönüşüm, işlevi girdi tamponunun kalanını işlemek üzere tekrar çağırır. Eğer dönüş değeri <command>__GCONV_EMPTY_INPUT</command> değilse bazı şeyler yanlış gitmiştir ve bunun kurtarılması gerekir.
     </para><para>
Dönüşüm işlevi için bir gereklilik de, girdi tamponu göstericisinin (üçüncü argüman) daima çıktı tamponuna konulan dönüştürülmüş son karakteri göstermesidir. Dönüşümün uygulandığı adımda eğer daha alt adımları gerçekleştiren dönüşüm işlevleri hata verip durmazsa, çıktı tamponundaki karakterlerin tümü tüketilmemişse ve bu nedenle girdi tamponu göstericileri doğru konumu gösterecek duruma getirilmemişse bu zaten gerçekleşir.
     </para><para>
Girdi tamponunun düzeltilmesi, eğer girdi ve çıktı karakter kümelerindeki tüm karakterler sabit genişlikteyse kolaydır. Bu durumda, çıktı tamponunda kaç karakter kaldığını hesaplayabilir ve bu sonuçtan hareketle girdi tampon göstericisini benzer bir hesaplamayla elde edebiliriz. Zor olan, karakter kümelerinin değişken genişlikte karakterler içermesi ve dönüşüm bir de durumsal ise işlemin daha da karmaşıklaşmasıdır. Bu durumlarda dönüşüm, ilk dönüşümden önceki bilinen durumdan bir daha başlatılır (gerekliyse, dönüşüm durumu sıfırlanmalı ve dönüşüm döngüsü tekrar çalıştırılmalıdır). Burada farklı olan ne kadar girdi oluşturulması gerektiğinin bilinmesi ve dönüşümün ilk işe yaramaz karakterden önce durdurulabilmesidir. Bu yapıldıktan sonra girdi tamponu göstericileri tekrar güncellenmelidir. Bundan sonra işlev dönebilir.
     </para><para>
Üstünde durulması gereken son bir şey daha var. Dönüşümün ilk çağrısında bir iletinin çıktılanması gerektiği durumlar için çağrının ilk çağrı olup olmadığının bilinmesi için dönüşüm işlevi adım verisi yapısının <command>__invocation_counter</command> elmanının değerini çağrıcıya dönmeden önce arttırmalıdır. Bunun nasıl kullanıldığı hakkında daha fazla bilgi edinmek isterseniz <command>struct __gconv_step_data</command> yapısının açıklamasına bakınız.
     </para><para>
Dönüş değeri şunlardan biri olmalıdır:
     </para><para><variablelist><varlistentry>
     <term><literal>__GCONV_EMPTY_INPUT</literal></term><listitem><para>
Tüm girdi tüketildi ve çıktı taponunda yer kaldı.
        </para></listitem></varlistentry><varlistentry>
        <term><literal>__GCONV_FULL_OUTPUT</literal></term><listitem><para>
Çıktı tamponunda yer kalmadı. Bu değer son adımda alınmamışsa zincirdeki sonraki işlev çağrısında bu değere uygun işlem yapılmalıdır.
        </para></listitem></varlistentry><varlistentry>
        <term><literal>__GCONV_INCOMPLETE_INPUT</literal></term><listitem><para>
Bozuk bir karakter dizilimi içerdiğinden girdi tamponu tüketilememiştir.
        </para></listitem></varlistentry></variablelist></para><para>
Aşağıda bir dönüşüm işlevinin çerçevesi çizilmeye çalışılmıştır. Yeni bir dönüşüm işlevi yazılacaksa, burada boş bırakılmış yerler doldurulmalıdır.
</para><para>
<screen>
int
gconv (struct __gconv_step *step, struct __gconv_step_data *data,
      const char **inbuf, const char *inbufend, size_t *written,
      int do_flush)
{
  struct __gconv_step *next_step = step + 1;
  struct __gconv_step_data *next_data = data + 1;
  gconv_fct fct = next_step->__fct;
  int status;

  /* İşlev girdisiz çağrılmışsa bu ilk duruma getirme anlamındadır.
     Girdinin bir kısmı işlendikten sonra bu yapılmışsa girdi atlanır. */
  if (do_flush)
    {
      status = __GCONV_OK;

      /* Durum nesnesini ilk duruma getiren bayt dizilimi gerekebilir. */

      /* Call the steps down the chain if there are any but only
        if we successfully emitted the escape sequence.  */
      if (status == __GCONV_OK &amp;&amp; ! data->__is_last)
        status = fct (next_step, next_data, NULL, NULL,
                      written, 1);
    }
  else
    {
      /* Gösterici değişkenlerinin ilk değerlerini saklayalım.  */
      const char *inptr = *inbuf;
      char *outbuf = data->__outbuf;
      char *outend = data->__outbufend;
      char *outptr;

      do
        {
          /* Bu adımın başlangıç değerini hatırlayalım.  */
          inptr = *inbuf;
          /* The outbuf buffer is empty.  */
          outptr = outbuf;

          /* Durumsal kodlamalar için durum burada güvenceye alınmalı.  */

          /* Dönüşüm döngüsü çalıştır ve durumu uygun değere ayarla.  */

          /* Bu son adımsa, döngüden çık. Yapacak birşey kalmamış.  */
          if (data->__is_last)
            {
              /* Kullanılabilir kaç bayt kaldı bilgisini sakla.  */
              data->__outbuf = outbuf;

            /* geri dönüşümsüz dönüşüm yapılmışsa numarasını
               *written'a ekle.  */

            break;
          }

          /* Üretilen tüm çıktıyı yaz.  */
          if (outbuf > outptr)
            {
              const char *outerr = data->__outbuf;
              int result;

              result = fct (next_step, next_data, &amp;outerr,
                            outbuf, written, 0);

              if (result != __GCONV_EMPTY_INPUT)
                {
                  if (outerr != outbuf)
                    {
                      /* Girdi tampon göstericisini sıfırla.
                         Burada karmaşık durumu belgeleyelim.  */
                      size_t nstatus;

                      /* Göstericileri yeniden yükle.  */
                      *inbuf = inptr;
                      outbuf = outptr;

                      /* Durum sıfırlanacaksa sıfırla.  */

                      /* Dönüşümü tekrar yap, ama bu sefer çıktı
                         tamponunun sonu outerr de.  */
                    }

                  /* urumu değiştir.  */
                  status = result;
                }
              else
                /* Çıktı tamamlandı, herşey tamamsa
                   sonraki adıma geçelim.  */
                if (status == __GCONV_FULL_OUTPUT)
                  status = __GCONV_OK;
          }
        }
      while (status == __GCONV_OK);

      /* Bu adımdaki işimiz bitti.  */
      ++data->__invocation_counter;
    }

  return status;
}
</screen>
</para></funcdescr></funcsynopsis></para><para>
Yeni modül yazmak için bu kadar bilgi yeterlidir. Bunu yapmak isteyenler GNU C kütüphanesinin kaynak koduna da bakabilirler. Pek çok çalışan ve eniyilenmiş örnek bulunmaktadır.
     </para></sect2></sect1>
  </chapter>
</part>

