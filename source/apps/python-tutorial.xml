<?xml version="1.0" encoding="UTF-8"?>
<!-- ********************************************************************
         python-tutorial.xml
     ******************************************************************** -->
<part xml:id="python-tutorial" xmlns="http://docbook.org/ns/docbook"
      xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:lang="tr"
      userlevel="longtoc">
 <info>
  <title>Python Kılavuzu</title>
  <subtitle>(Python Tutorial)</subtitle>
  <authorgroup>
   <author role="translator">
    <personname>
     <firstname>Dinçer Aydın</firstname>
    </personname>
    <affiliation>
     <address>
      <email>dinceraydin@gmx.net</email>
     </address>
    </affiliation>
   </author>
   <author>
    <personname>
     <firstname>Guido van Rossum</firstname>
    </personname>
    <affiliation>
     <address>
      <email>python-docs@python.org</email>
     </address>
    </affiliation>
   </author>
   <author>
    <personname>
     <firstname>Fred L. Drake, Jr.</firstname>
    </personname>
    <affiliation>
     <address>
      <email>python-docs@python.org</email>
     </address>
    </affiliation>
   </author>
  </authorgroup>
  <pubdate>22 Nisan 2003</pubdate>
  <revhistory>
   <revision>
    <revnumber>2.2.2</revnumber>
    <date>14 Ekim 2002</date>
    <authorinitials>Özgün belge: PythonLabs, Çeviri: DA</authorinitials>
    <revremark>
     Çevirinin özgün sürümünü
     <uri xlink:href="http://www.geocities.com/dinceraydin/">http://www.geocities.com/dinceraydin/</uri>
     adresinde bulabilirsiniz.
    </revremark>
   </revision>
   <revision>
    <revnumber>2.1.1</revnumber>
    <date>11 Kasım 2001</date>
    <authorinitials>Özgün belge: PythonLabs, Çeviri: DA</authorinitials>
    <revremark><uri xlink:href="http://www.geocities.com/dinceraydin/python/indextr.html">http://www.geocities.com/dinceraydin/python/indextr.html</uri> adresindeki Windows sürümünden çevrilmiş Python Kılavuzu'nun Linux için uyarlamasıdır.
   </revremark>
   </revision>
  </revhistory>
 </info>
 <chapter xml:id="python-tutorial_giris">
  <info>
   <title>Giriş</title>
  </info>
  <para>Telif Hakkı © 2001 Python Software Foundation. Tüm hakları saklıdır.</para>
  <para>Telif Hakkı © 2000 BeOpen.com. Tüm hakları saklıdır.</para>
  <para>Telif Hakkı © 1995-2000 Corporation for National Research Initiatives. Tüm hakları saklıdır.</para>
  <para>Telif Hakkı © 1991-1995 Stichting Mathematisch Centrum. Tüm hakları saklıdır.</para>
  <para>Telif Hakkı © 2001 Dinçer Aydın, tercüme. Tüm hakları saklıdır.</para>
  <para>Lisans bilgileri için <uri xlink:href="http://www.python.org/2.2/license.html">http://www.python.org/2.2/license.html</uri>
      adresine bakınız.
    </para>
  <para>
   Python kolay öğrenilen güçlü bir programlama dilidir. Verimli yüksek seviyeli
   veri türlerine sahiptir ve nesne tabanlı programlamaya yaklaşımı basit ve
   etkilidir. Python'un şık sözdizimi, dinamik veri türleri ve yorumlanan bir
   dil oluşu onu çoğu alan ve platformda hızlı yazılım geliştirme için ideal yapar.
  </para>
  <para>
      Python yorumlayıcısı ve geniş standart kütüphanesi kaynak ya da çalıştırılabilir
      paket olarak <link xlink:href="http://www.python.org/">Python Web sitesi</link>nden
      alınabilir ve dağıtılabilir.  Aynı sitede farklı Python dağıtımları, modüller,
      programlar ve belgeler bulunabilir. Günümüzde yaygın olarak kullanılan işletim
      sistemlerinin çoğu için bir Python dağıtımı mevcuttur.
    </para>
  <para>
      Python yorumlayıcısı C veya C++ (ya da C dilinden çağırılabilen başka bir dil)
      ile yazılmış veri türleri ve işlevler ile genişletilebilir. Diğer dillerde
      yazdığınız programlarınıza da Python yorumlayıcısını bağlayabilir ve Python
      ile ek özellikler eklenebilen programlar yazabilirsiniz.
    </para>
  <para>
      Bu kılavuz okuyucuya Python dilinin temel özelliklerini, kavramlarını ve
      sistemini tanıtmaktadır. Örnekleri denemek için el altında bir Python
      yorumlayıcısı bulundurmak yararlı olur.
    </para>
  <para>
      Bu kılavuz Python'un bütün özeliklerini ya da yaygın olarak kullanılan her
      özelliğini açıklamak amacında değildir. Bunun yerine Python'un kayda değer
      özelliklerinin çoğu tanıtılmaktadır ve dilin tarzı ile ilgili iyi bir fikir
      verilmektedir. Bunu okuduktan sonra Python modülleri ve programlarını
      okuyup yazabileceğiniz gibi Python ile gelen geniş kütüphane ile ilgili daha
      çok şey öğrenmeye hazır olacaksınız.
    </para>
 </chapter>
 <chapter xml:id="python-tutorial_kolay">
  <info>
   <title>İştahınızı Kabartalım</title>
  </info>
  <para>
      Eğer büyük bir kabuk betiği yazdıysanız neler olduğunu bilirsiniz. Bir
      özellik daha eklemek istersiniz; ancak program yeterince büyük ve yavaş
      olmuştur ya da istediğiniz özelliğe sadece C aracılığıyla erişilebilir...
      Genellikle program C ile baştan yazılmaya değecek önemde değildir ya da
      kabukta kolay olduğu halde C'de zor elde edilen özellikleri vardır. Belki
      de C ile yeterince iyi değilsiniz.
    </para>
  <para>
      Bir diğer durum düşünün: birkaç C kütüphanesi ile çalışmanız gerekiyor ve
      normal yaz/derle/dene/tekrar derle döngüsü çok yavaş geliyor ve daha hızlı
      program yazmaya ihtiyacınız var. Belki de genişletilebilir bir program
      yazacaksınız; ancak bunun için yeni bir dil tasarlayıp bunun için gerekli
      yorumlayıcıyı yazıp programınıza ekleyeceksiniz.
    </para>
  <para>
      Bu gibi durumlarda Python tam aradığınız dil olabilir. Python kullanımı
      basit fakat gerçek bir dildir. Büyük programlar için kabuktan daha uygundur
      ve C'den çok daha fazla hata denetimi yapar. Python <emphasis>çok yüksek seviyeli bir
      dil</emphasis> olup C ile verimli şekilde yazılması günler alabilecek yüksek seviyeli
      veri türlerine sahiptir (sözlükler ve listeler gibi). Daha genel veri türleri
      sayesinde Python <userinput>Awk</userinput> hatta <userinput>Perl</userinput>'den
      çok daha geniş bir yelpazede uygulama
      alanı bulabilir. Ayrıca Python'da pek çok şey en az o dillerdeki kadar
      kolaydır.
    </para>
  <para>
      Python ile programlarınızı daha sonra diğer Python programlarınızda tekrar
      kullanabileceğiniz modüllere ayırabilirsiniz. Python geniş bir standart
      modül kolleksiyonu ile size gelmektedir. Dosya giriş/çıkışı, ses, resim,
      matematiksel işlemler vs. ile ilgili modüller de vardır.
    </para>
  <para>
      Python yorumlanan bir dil olduğu için program geliştirme sırasında size
      önemli miktarda zaman kazandırabilir. Çünkü derleme ve ilintileme gerekmemektedir.
      Yorumlayıcıyı etkileşimli olarak da kullanabilirsiniz; böylece dilin
      özelliklerini kolayca deneyebilir, hızlı bir şekilde küçük programlar yazabilir,
      ya da aşağıdan-yukarı program geliştirme sırasında işlevlerinizi test
      edebilirsiniz. Yorumlayıcı bir hesap makinesi olarak da kullanılabilir.
    </para>
  <para>
      Python ile son derece sıkı ve okunabilir programlar yazabilirsiniz. Birkaç
      nedenden Python programları eşdeğer C veya C++ programlarından çok daha
      kısadırlar:
    </para>
  <itemizedlist>
   <listitem>
          Yüksek seviyeli veri türleri ile karmaşık işlemler tek bir ifade ile
          yazılabilir.
        </listitem>
   <listitem>
          Deyimlerin gruplanması, başlama/bitme deyimleri (begin, end veya {}
          gibi) yerine blokların girintili yazılması ile sağlanır.
        </listitem>
   <listitem>
          Değişken veya argüman bildirimlerinin yapılması gerekmez.
        </listitem>
  </itemizedlist>
  <para>
      Python <emphasis>genişletilebilir</emphasis>: Eğer C programlamayı
      biliyorsanız Python'a kolayca yeni modüller ekleyebilir ya da programınızın
      hızlı çalışması gereken kısımlarını C ile yazabilirsiniz. C programlarınıza
      da Python yorumlayıcısını bağlayabilir ve Python ile ek özellikler
      eklenebilen programlar yazabilirsiniz.
    </para>
  <para>
      Python programlama dili adını korkunç bir sürüngenden değil,
      `Monty Python's Flying Circus'' adlı bir BBC komedi dizisinden almıştır.
    </para>
  <section xml:id="python-tutorial_learn">
   <info>
    <title>Öğrenmek İçin...</title>
   </info>
   <para>
        Artık Python konusunda heyecanlandınız ve daha ayrıntılı olarak incelemek
        istiyorsunuz. Bir dili öğrenmenin en iyi yolu onu kullanmak olduğundan
        sizi Python kullanmaya davet ediyoruz.
      </para>
   <para>
        Bir sonraki bölümde yorumlayıcıyı kullanmayı öğreteceğiz. Bu çok basit
        bir şey; ancak daha sonraki bölümlerin anlaşılması için önemli.
      </para>
   <para>
        Kılavuzun devamında basit ifadeler, deyimler ve veri türleri ile başlayıp,
        işlevler ve modüllerden kullanıcı tanımlı sınıflar gibi gelişmiş konulara
        kadar Python'un çeşitli özellikleri örnekler ile anlatılmaktadır.
      </para>
  </section>
 </chapter>
 <chapter xml:id="python-tutorial_yorumlayici">
  <info>
   <title>Yorumlayıcının Kullanımı</title>
  </info>
  <section xml:id="python-tutorial_yorumlayici-run">
   <info>
    <title>Yorumlayıcının Çalıştırılması</title>
   </info>
   <para>
        Python yorumlayıcısını Linux Konsolunda ya da xterm'de <literal>python</literal>
        komutunu girerek çalıştırabilirsiniz. Python yorumlayıcısının konsolda
        çalışanı olduğu gibi X Pencere Sisteminde çalışanı da vardır. X pencere sisteminde
        çalışan yorumlayıcı <literal>idle</literal> komutu ile çalıştırılabilir.
        Menüleriyle kolay kullanılabilen bir Python düzenleyicisidir
        ve konsolda çalışan <literal>python</literal> gibi "Python Kabuğu"
        penceresinde doğrudan komut icra edilebilir.
      </para>
   <para><literal>python</literal> çalıştırıldığında yorumlayıcı konsolda
        etkileşimli kipte çalışır. Yorumlayıcı çalıştırılacak olan Python
        programının dosya adı parametre şeklinde verilerek de kullanılabilir.
        Örneğin <literal>python deneme.py</literal> gibi.
      </para>
  </section>
  <section xml:id="python-tutorial_int">
   <info>
    <title>Etkileşimli Kip</title>
   </info>
   <para>
        Komutların yorumlayıcıya satır satır girildiği duruma etkileşimli kip
        denir. Bu kipte birincil komut satırı <literal>&gt;&gt;&gt;</literal>
        şeklindeyken ikincil komut satırı <literal>...</literal> şeklinde
        görülür. Örneğin:
      </para>
   <para>
    <screen><prompt>bash-2.05$ </prompt><userinput>python</userinput>
Python 2.2.2 (#1, Feb 24 2003, 19:13:11)
[GCC 3.2.2 20030222 (Red Hat Linux 3.2.2-4)] on linux2
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt;
</screen>
   </para>
   <para>
        Birden fazla satırlık bloklar girildiğinde satırlar ikincil komut
        satırında girintili yazılır:
      </para>
   <para>
    <screen>
&gt;&gt;&gt; dunya_duzdur=1
&gt;&gt;&gt; if dunya_duzdur:
...     print "Düşmemeye dikkat et!"
...
Düşmemeye dikkat et!
&gt;&gt;&gt;
</screen>
   </para>
   <para>
        Yorumlayıcıdan çıkmak için <literal>ctrl+D</literal> tuşlayın.
        Etkileşimli kipte çalıştırılan programlarda bir hata bulunması halinde
        yorumlayıcı bir hata mesajı basar ve birincil komut satırına döner:
      </para>
   <para>
    <screen>
&gt;&gt;&gt; if dunya_duzdur:
... print "Düşmemeye dikkat et!"
  File "&lt;stdin&gt;", line 2
    print "Düşmemeye dikkat et!"
        ^
IndentationError: expected an indented block
&gt;&gt;&gt;
</screen>
   </para>
   <para>
        Burada 2. satırın girintili yazılması gerektiği hatırlatılıyor.
      </para>
   <para>
        Ayrıca etkileşimli kipte ya da Python programlarınızı yazarken komut
        satırı yerine daha rahat bir ortamda calışmak isteyebilirsiniz.
        Bunun için Python ile birlikte gelen <literal>idle</literal>'ı
        deneyebilirsiniz. <literal>idle</literal> Python ile yazılmış bir
        uygulama. Bazı <literal>idle</literal> komutları şöyledir:
      </para>
   <para>
    <itemizedlist>
     <listitem><command>Alt+p</command> Yazdığınız bir önceki komutu getirir.
          </listitem>
     <listitem><command>Alt+n</command> Yazdığınız bir sonraki komutu getirir.
          </listitem>
     <listitem><command>enter</command> Yazdığınız komutları çalıştırır.
          </listitem>
    </itemizedlist>
   </para>
  </section>
  <section xml:id="python-tutorial_yorumlayici-scripts">
   <info>
    <title>Python Betikleri</title>
   </info>
   <para>
        Kabuk betiklerine benzer şekilde Python betikleri de, dosyanın ilk
        satırına
      </para>
   <para>
    <screen>#! /usr/bin/env python</screen>
   </para>
   <para>
        yazılarak ve dosyaya çalıştırma izni verilerek
        (<literal>chmod +x dosya.py</literal>) doğrudan kabuktan
        çalıştırılabilirler.
      </para>
  </section>
  <section xml:id="python-tutorial_yorumlayici-errors">
   <info>
    <title>Hataların Yakalanması</title>
   </info>
   <para>
        Bir hata oluştuğunda yorumlayıcı bir hata mesajı ve hatalı noktaya
        gelmeden önce işletilen işlev çağrılarının listesini basar.
      </para>
  </section>
 </chapter>
 <chapter xml:id="python-tutorial_basliyoruz">
  <info>
   <title>Python'a Giriş</title>
  </info>
  <para>
      Aşağıdaki örneklerde giriş ve çıkış, komut satırının varlığına veya
      yokluğuna (<literal>&gt;&gt;&gt; </literal> veya <literal>... </literal>)
      bağlıdır. Örnekleri tekrar etmek için komut satırında görünen her şeyi
      yazmalısınız. <literal>&gt;&gt;&gt; </literal> veya <literal>... </literal>
      ile başlamayan bütün satırlar yorumlayıcı çıktısını temsil ederler.
      İkincil komut satırındaki boş bir satır (sadece "... ")) olan yerlerde
      bir şey yazmanıza gerek yok. O satırlar boş olup bir deyimler öbeğinin
      bitirilmesi için kullanılırlar. Bu kılavuzdaki alıştırmaların çoğu,
      etkileşimli komut satırına yazılanlar dahil, açıklamalar içerirler.
      Python dilinde açıklamalar "#" ile başlarlar ve bulundukları satır
      sonuna kadar devam ederler. Bir dizge içinde bulunan "#"
      işareti bir açıklama başlatmaz. Bu sadece bir "#" karakteridir. Örnekler:
    </para>
  <para>
   <screen>
# Bu bir açıklama.
SAYI = 1 # ve bu ikinci açıklama
# ... bu da üçüncü!
DIZGE = "# Bu bir açıklama değil."
</screen>
  </para>
  <section xml:id="python-tutorial_calc">
   <info>
    <title>Python'u Hesap Makinesi Olarak Kullanmak</title>
   </info>
   <section>
    <info>
     <title>Sayılar</title>
    </info>
    <para>
          Şimdi bazı basit komutlar deneyelim. Yorumlayıcıyı çalıştırın ve birincil
          komut satırının gelmesini bekleyin.
        </para>
    <para>
          Yorumlayıcı basit bir hesap makinesi olarak iş görürebilir: istediğiniz
          herhangi bir ifadeyi yazın ve yorumlayıcı sonucu verecektir. İşleçler
          ( +,-,*,/ ) çoğu programlama dillerindekine benzer çalışır (Pascal ve C de
          olduğu gibi mesela). İfadeleri gruplamak için parantezler de kullanılabilir.
          Örnekler:
        </para>
    <para>
     <screen>
&gt;&gt;&gt; 2+2
4
&gt;&gt;&gt; # Bu bir açıklama
... 2+2
4
&gt;&gt;&gt; 2+2 # bu da komutlarla aynı satırda bir açıklama
4
&gt;&gt;&gt; (50-5*6)/4
5
&gt;&gt;&gt; # Tam sayı bölme işlemlerinde ise:
... 7/3
2
&gt;&gt;&gt; 7/-3
-3
</screen>
    </para>
    <para>
          C'de olduğu gibi eşit işareti ( <literal>=</literal> ) bir değişkene değer atamak için
          kullanılır. Atamanın değeri çıkışta yazılmaz:
</para>
    <para>
     <screen>
&gt;&gt;&gt; genislik = 20
&gt;&gt;&gt; yukseklik = 5*9
&gt;&gt;&gt; genislik * yukseklik
900
</screen>
    </para>
    <para>
          Bir değer aynı anda birden fazla değişkene atanabilir:
</para>
    <para>
     <screen>
&gt;&gt;&gt; x = y = z = 5 # x, y ve z beş değerini alır
&gt;&gt;&gt; x
5
&gt;&gt;&gt; y
5
&gt;&gt;&gt; z
5
</screen>
    </para>
    <para>
          Tam gerçel sayı desteği vardır. Farklı türdeki değerlerin olduğu
          işlemlerde sonuç gerçel sayıya dönüştürülür:
</para>
    <para>
     <screen>
&gt;&gt;&gt; 3 * 3.75 / 1.5
7.5
&gt;&gt;&gt; 7.0 / 2
3.5
</screen>
    </para>
    <para>
          Karmaşık sayılar da desteklenmektedir. Sayıların sanal kısımları
          <literal>j</literal> veya <literal>J</literal> soneki ile yazılır.
          Gerçek kısmı sıfır olmayan karmaşık sayılar <literal>(gerçek +
          sanalj)</literal> şeklinde yazılırlar ya da
          <literal>complex(gerçek, sanal)</literal> işlevi ile kullanılırlar.
</para>
    <para>
     <screen>
&gt;&gt;&gt; 1j * 1J
(-1+0j)
&gt;&gt;&gt; 1j * complex(0,1)
(-1+0j)
&gt;&gt;&gt; 3+1j*3
(3+3j)
&gt;&gt;&gt; (3+1j)*3
(9+3j)
&gt;&gt;&gt; (1+2j)/(1+1j)
(1.5+0.5j)
</screen>
    </para>
    <para>
          Karmaşık sayılar daima iki gerçel sayı ile ifade edilirler; biri
          gerçek diğer sanal kısım için. <literal>Z</literal> gibi bir karmaşık
          sayının gerçek ya da sanal kısımlarına erişmek için <literal>Z.real</literal>
          ve <literal>Z.imag</literal> kullanılır.
</para>
    <para>
     <screen>
a=1.5+0.5j
&gt;&gt;&gt; a.real
1.5
&gt;&gt;&gt; a.imag
0.5
</screen>
    </para>
    <para>
          Tamsayı veya gerçel sayıya dönüştürme işlevleri (<literal>float()</literal>,
          <literal>int()</literal> ve <literal>long()</literal>) karmaşık sayılar için
          çalışmazlar; bir karmaşık sayıyı gerçek bir sayıya dönüştürmenin doğru
          bir yolu mevcut değildir. <literal>abs(z)</literal> ile karmaşık sayının
          büyüklüğünü ve <literal>z.real</literal> ile gerçek kısmını elde edebilirsiniz.
</para>
    <para>
     <screen>
&gt;&gt;&gt; a=3.0+4.0j
&gt;&gt;&gt; float(a)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
TypeError: can't convert complex to float; use e.g. abs(z)
&gt;&gt;&gt; a.real
3.0
&gt;&gt;&gt; a.imag
4.0
&gt;&gt;&gt; abs(a)  # sqrt(a.real**2 + a.imag**2)
5.0
&gt;&gt;&gt;
</screen>
    </para>
    <para>
          Etkileşimli kipte son yazdırılan değer <literal>_</literal> değişkenine
          atanır. Yani Python'u hesap makinesi olarak kullanırken bazen işlemlere
          şu şekilde devam etmek daha kolaydır :
</para>
    <para>
     <screen>
vergi= 17.5 / 100
&gt;&gt;&gt; fiyat= 3.50
&gt;&gt;&gt; fiyat * vergi
0.61249999999999993
&gt;&gt;&gt; fiyat + _
4.1124999999999998
&gt;&gt;&gt; round(_, 2)
4.1100000000000003
&gt;&gt;&gt;
</screen>
    </para>
    <para>
          Bu değişken ( <literal>_</literal> ) kullanıcı tarafından salt okunur
          olarak kabul edilmelidir. Buna kasıtlı olarak değer atamayın. Bu aynı
          isimli bir yerel değişken yaratır.
        </para>
   </section>
   <section>
    <info>
     <title>Dizgeler</title>
    </info>
    <para>
          Sayılara ek olarak, Python dizgeler üzerinde de işlemler yapabilir.
          Dizgeler farklı şekillerde ifade edilebilir. Tek veya çift tırnak
          işareti içine alınabilirler:
</para>
    <para>
     <screen>
 &gt;&gt;&gt; 'dizge'
'dizge'
&gt;&gt;&gt; "Python\'un gücü"
"Python'un gücü"
&gt;&gt;&gt; "doesn't"
"doesn't"
&gt;&gt;&gt; '"Yes," he said.'
'"Yes," he said.'
&gt;&gt;&gt; "\"Yes,\" he said."
'"Yes," he said.'
&gt;&gt;&gt; '"Isn\'t," she said.'
'"Isn\'t," she said.'
</screen>
    </para>
    <para>
          Dizgeler birkaç şekilde birden fazla satıra yayılabilirler. Yeni
          satırlar ters eğik çizgi ile şöyle gösterilebilirler:
</para>
    <para>
     <screen>
&gt;&gt;&gt; merhaba = "Bu C de de kullandığınıza benzer\n\
... birkaç satır kaplayan bir dizge.\n\
...     Bu satırın başındaki \
... girintinin belirgin olduğuna \
... dikkat edin\n"
&gt;&gt;&gt; print merhaba
</screen>
    </para>
    <para>
          ve bu şu çıktıyı verir:
</para>
    <para>
     <screen>
Bu C de de kullandığınıza benzer
birkaç satır kaplayan bir dizge.
        Bu satırın başındaki girintinin belirgin olduğuna dikkat edin

&gt;&gt;&gt;
</screen>
    </para>
    <para>
          Karakter dizisini <literal>r</literal> ile imleyerek <emphasis>ham
          dizge</emphasis> yapacak olursak, <literal>\n\</literal> karakterleri
          yorumlanmaz, dizgenin bir parçası haline gelirler. Örneğin:
</para>
    <para>
     <screen>
merhaba = r"Bu C de de kullandığınıza benzer\n\
birkaç satır kaplayan bir karakter dizisi."

print merhaba
</screen>
    </para>
    <para>şu çıktıyı verir:
</para>
    <para>
     <screen>
Bu C de de kullandığınıza benzer\n\
birkaç satır kaplayan bir karakter dizisi.
</screen>
    </para>
    <para>
          Karakter dizileri bir çift üçlü tırnak içinde de gösterilebilirler:
          Dizgeler bir çift üçlü tırnak içinde de gösterilebilirler:
          <literal>"""</literal> veya <literal>'''</literal>. Bu
          gösterim şeklinde satır sonlarının <literal>\n</literal>
          ile gösterilmesine gerek yoktur ve onlar olmadan da yeni
          satırlar doğru şekilde görünürler. Örnek:
</para>
    <para>
     <screen>
print """
Kullanım şekli : seninprog [SEÇENEKLER]
     -y     Bu yardım mesajını görüntüler
     -S     bağlanılacak sunucu adı
"""
</screen>
    </para>
    <para>
          ifadesi şu çıktıyı verir :
</para>
    <para>
     <screen>
Kullanım şekli : seninprog [SEÇENEKLER]
     -y     Bu yardım mesajını görüntüler
     -S     bağlanılacak sunucu adı
</screen>
    </para>
    <para>
          Yorumlayıcı dizge işlemlerinin sonucunu girişine yazıldığı şekli
          ile çıkışa yazar. Dizgeler <literal>+</literal> işleçi
          ile birleştirilip, <literal>*</literal> ile tekrarlanabilirler:
</para>
    <para>
     <screen>
kelime = 'Alo' + 'ooo'
&gt;&gt;&gt; kelime
'Aloooo'
&gt;&gt;&gt; '&lt;' + kelime*5 + '&gt;'
'&lt;AlooooAlooooAlooooAlooooAloooo&gt;'
</screen>
    </para>
    <para>
          Yan yana iki dizge değişkeni otomatik olarak birleştirilir yani
          yukarıdaki örnekteki ilk satır <literal>kelime = 'Alo' 'ooo'</literal>
          şeklinde de yazılabilirdi. Bu sadece iki dizge değişkeni ile olur.
          Keyfî dizgeler arasında olamaz:
</para>
    <para>
     <screen>
import string
&gt;&gt;&gt; 'str' 'ing' # &lt;- Bu doğru
'string'
&gt;&gt;&gt; string.strip('str') + 'ing' # &lt;- Bu da doğru
'string'
&gt;&gt;&gt; string.strip('str') 'ing' # &lt;- Bu geçersız !!!
File "&lt;stdin&gt;", line 1, in ?
string.strip('str') 'ing'
                        ^
SyntaxError: invalid syntax
</screen>
    </para>
    <para>
          C'de olduğu gibi, Python'da da dizgeler indislenebilirler.
          Dizgenin ilk karakterinin indisi sıfırdır. Python'da ayrı bir karakter
          veri türü yoktur. Bir karakter tek karakterli bir dizgedir. Icon
          dilinde (70'li yıllarda Ralph ve Marge Griswold'ün geliştirdiği Pascal
          benzeri bir SNOBOL4 türevi) olduğu gibi dizgelerin bölümleri
          dilim gösterimi <literal>[ : ]</literal> ile ifade edilebilirler.
</para>
    <para>
     <screen>
&gt;&gt;&gt; kelime[4]
'o'
&gt;&gt;&gt; kelime[0:2]
'Al'
&gt;&gt;&gt; kelime[2:4]
'oo'
</screen>
    </para>
    <para>
          C dilinden farklı olarak, Python'da dizgeler değiştirilemezler.
          Bir dizgenin indislenen bir konumuna değer atamaya çalışmak hatadır:
</para>
    <para>
     <screen>
&gt;&gt;&gt; kelime[0] = 'x'
Traceback (most recent call last):
File "&lt;stdin&gt;", line 1, in ?
TypeError: object doesn't support item assignment
&gt;&gt;&gt; kelime[:1] = 'Splat'
Traceback (most recent call last):
File "&lt;stdin&gt;", line 1, in ?
TypeError: object doesn't support slice assignment
</screen>
    </para>
    <para>
          Yukarıdaki soruna elde edilmek istenen dizge için yeni bir karakter
          dizisi oluşturularak çözüm bulunabilir. Bu kolay ve etkilidir:
</para>
    <para>
     <screen>
'x' + kelime[1:]
'xloooo'
&gt;&gt;&gt; 'Splat' + kelime[4]
'Splato'
</screen>
    </para>
    <para>
          Dilimlerin varsayılan başlangıç ve bitiş değerleri oldukça kullanışlıdır.
          Başlangıç değeri yoksa sıfır kabul edilir ve eğer bitiş değeri yoksa
          dilimlenen dizgenin boyu kadar olduğu kabul edilir. Örnekler :
</para>
    <para>
     <screen>
&gt;&gt;&gt; kelime[:2] # İlk iki karakter
'Al'
&gt;&gt;&gt; kelime[2:] # İlk iki karakter dışındaki karakterler
'oooo'
</screen>
    </para>
    <para><literal>s[:i] + s[i:] = s</literal> olup dilimleme işlemlerinin
          kullanışlı bir şeklidir. Örnek:
</para>
    <para>
     <screen>
&gt;&gt;&gt; kelime[:2] + kelime[2:]
'Aloooo'
&gt;&gt;&gt; kelime[:3] + kelime[3:]
'Aloooo'
</screen>
    </para>
    <para>
          Çok büyük veya küçük dilim aralıkları akıllıca ele alınır. Bitiş değeri
          büyük ise bunun boyu dizgenin boyuna eşit olur. Başlangıç
          değeri bitişten büyük ise boş bir dizge elde edilir.
</para>
    <para>
     <screen>
&gt;&gt;&gt; kelime[1:100]
'loooo'
&gt;&gt;&gt; kelime[10:]
''
&gt;&gt;&gt; kelime[2:1]
''
</screen>
    </para>
    <para>
          İndisler negatif sayılar da olabilirler. Bu durumda saymaya sağ
          taraftan başlanır.
</para>
    <para>
     <screen>
&gt;&gt;&gt; kelime[-1] # Son karakter
'o'
&gt;&gt;&gt; kelime[-2] # Sondan ikinci
'o'
&gt;&gt;&gt; kelime[-2:] # Son iki karakter
'oo'
&gt;&gt;&gt; kelime[:-2] # Son iki karakter dışındaki karakterler
'Aloo'
</screen>
    </para>
    <para>
          -0 ın 0 ile aynı olduğuna dikkat edin; yani yine soldan sayar!
</para>
    <para>
     <screen>
&gt;&gt;&gt; kelime[-0] # (-0 = 0 olduğundan)
'A'
</screen>
    </para>
    <para>
          Sınır dışındaki negatif dilim indisleri küçültülürler; fakat bunu
          dilim olmayan tek bir indis ile denemeyin:
</para>
    <para>
     <screen>
&gt;&gt;&gt; kelime[-100:]
'Aloooo'
&gt;&gt;&gt; kelime[-10] # hata !
Traceback (most recent call last):
File "&lt;stdin&gt;", line 1
IndexError: string index out of range
</screen>
    </para>
    <para>
          Dilimlerin nasıl çalıştığını hatırlamanın en iyi yolu indislerin
          karakterler arasını işaret ettiğini düşünmektir; şu şekilde bu daha
          iyi görülebilir:
</para>
    <para>
     <screen>
 +---+---+---+---+---+
 | H | e | l | p | A |
 +---+---+---+---+---+
 0   1   2   3   4   5
-5  -4  -3  -2  -1
</screen>
    </para>
    <para>
          Negatif olmayan indisler için dilim boyu indisler arası fark kadardır.
          Örneğin kelime[1:3] diliminin boyu 2 dir.
        </para>
    <para>
          Yerleşik işlev <literal>len()</literal> bir dizgenin boyunu verir.
</para>
    <para>
     <screen>
&gt;&gt;&gt; s = 'ArrestedDevelopmentZingalamaduni'
&gt;&gt;&gt; len(s)
32
</screen>
    </para>
   </section>
   <section>
    <info>
     <title>Listeler</title>
    </info>
    <para>
          Python'da diğer veri türlerini bir gruba almayı sağlayan birkaç bileşik veri
          türü vardır. Bunların en kullanışlı olanlarından biri listelerdir. Listeler
          kare parantez içinde virgül ile birbirinden ayrılmış değerlerden (eleman)
          oluşurlar. Liste elemanlarının aynı türden olması gerekmez.
</para>
    <para>
     <screen>
&gt;&gt;&gt;a = ['salam', 'zeytin', 100, 1234]
&gt;&gt;&gt; a
['salam', 'zeytin', 100, 1234]
</screen>
    </para>
    <para>
          Listeler de dizgeler gibi indislenebilir. İndisler sıfırdan başlar.
          Listeler dilimlenebilir, birleştirilebilir vs...
</para>
    <para>
     <screen>
&gt;&gt;&gt; a[0]
'salam'
&gt;&gt;&gt; a[3]
1234
&gt;&gt;&gt; a[-2]
100
&gt;&gt;&gt; a[1:-1]
['zeytin',100]
&gt;&gt;&gt; a[:2] + ['yumurta', 2*2]
['salam','zeytin', 'yumurta', 4]
&gt;&gt;&gt; 3*a[:3] + ['Oley!']
['salam', 'zeytin', 100, 'salam', 'zeytin', 100, 'salam', 'zeytin', 100, 'Oley!']
</screen>
    </para>
    <para>
          Değiştirilemez (mutable) olan dizgelerin aksine, listelerin her bir
          elemanı değiştirilebilir:
</para>
    <para>
     <screen>
&gt;&gt;&gt; a
['salam', 'zeytin', 100, 1234]
&gt;&gt;&gt; a[2] = a[2] + 23
&gt;&gt;&gt; a
['salam', 'zeytin', 123, 1234]
</screen>
    </para>
    <para>
          Liste dilimlerine de atama yapılabilir ve bu listenin boyunu da
          değiştirilebilir.
</para>
    <para>
     <screen>
&gt;&gt;&gt;
# Bazı elemanları değiştir:
... a[0:2] = [1, 12]
&gt;&gt;&gt; a
[1, 12, 123, 1234]
&gt;&gt;&gt; # Bazı elemanları sil:
... a[0:2] = []
&gt;&gt;&gt; a
[123, 1234]
&gt;&gt;&gt; # Listenin içine elemanlar ekle:
... a[1:1] = ['bletch', 'xyzzy']
&gt;&gt;&gt; a
[123, 'qwerty', 'xyzzy', 1234]
&gt;&gt;&gt; a[:0] = a # Listenin kopyasını listenin başına ekle
&gt;&gt;&gt; a
[123, 'qwerty', 'xyzzy', 1234, 123, 'qwerty', 'xyzzy', 1234]
</screen>
    </para>
    <para>
          Yerleşik işlev <literal>len()</literal> listeler ile de çalışır:
</para>
    <para>
     <screen>
&gt;&gt;&gt; len(a)
8
</screen>
    </para>
    <para>
          İç içe listeler yaratılabilir. Örnek:
</para>
    <para>
     <screen>
&gt;&gt;&gt; q = [2, 3]
&gt;&gt;&gt; p = [1, q, 4] # buradaki q üst satırda tanımlanan listedir
&gt;&gt;&gt; len(p)
3
&gt;&gt;&gt; p[1]
[2, 3]
&gt;&gt;&gt; p[1][0]
2
&gt;&gt;&gt; p[1].append('xtra')     # append daha sonra açıklanacak
&gt;&gt;&gt; p
[1, [2, 3, 'xtra'], 4]
&gt;&gt;&gt; q
[2, 3, 'xtra']
</screen>
    </para>
    <para>
          Üstteki örnekte <literal>p[1]</literal> ve <literal>q</literal>'nun
          aynı nesne olduğuna dikkat edin!
        </para>
   </section>
  </section>
  <section xml:id="python-tutorial_ilkler">
   <info>
    <title>Programlamaya Doğru İlk Adımlar</title>
   </info>
   <para>
        Tabii ki Python kullanarak iki ile ikiyi toplamaktan daha karmaşık işler
        yapabiliriz. Mesela bir Fibonacci serisini şöyle yazabiliriz:
</para>
   <para>
    <screen>
&gt;&gt;&gt; # Fibonacci serisi:
... # iki elemanın toplamı bir sonraki elemanı verir
... a, b = 0, 1
&gt;&gt;&gt; while b &lt; 10:
...     print b
...     a, b = b, a+b
...
1
1
2
3
5
8
</screen>
   </para>
   <para>
        Bu örnekte birkaç yeni özellik gösterilmektedir:
      </para>
   <para>
    <itemizedlist>
     <listitem>
      <para>
              İlk satırda bir <emphasis>çoklu değer atama</emphasis> var; a ve b değişkenleri bir
              anda 0 ve 1 değerlerini alırlar. Bu özellik son satırda da
              kullanılmaktadır. Son satırda dikkat çeken bir diğer olay da
              ifadenin sağ kısmının soldan sağa doğru atama işlemlerinden
              önce hesaplandığıdır.
            </para>
     </listitem>
     <listitem>
      <para><literal>while</literal> döngüsü, verilen koşul (burada: b &lt; 10)
              doğru olduğu sürece tekrarlanır. Python'da, C'de olduğu gibi,
              sıfır dışındaki herhangi bir değer doğru ve sıfır yanlış kabul
              edilir. Koşul bir dizge veya liste de olabilir. Boyu sıfır olmayan
              her şey doğru iken, boş listeler, dizgeler, vs yanlış kabul edilirler.
            </para>
      <para>
              Üstteki örnekte basit bir kıyaslama işlemi var. Standart kıyaslama
              işlemleri C'de olduğu gibi yazılır: &lt; (küçük), &gt; (büyük), ==
              (eşit), &lt;= (küçük eşit), &gt;= (büyük eşit), != (eşit değil).
            </para>
     </listitem>
     <listitem>
      <para>
              Döngü bloğu girinitli yazılmıştır. Girintili yazma Python'un ifadeleri
              gruplama yoludur. Etkileşimli kipte girintili bir öbek yazıldığı zaman
              boş bir satır ile sonlandırılmalıdır (çünkü yorumlayıcı yazmayı ne zaman
              bıraktığınızı bilemez). Grintili bir öbek içindeki her satırın aynı
              girinti miktarına sahip olması gerektiğine dikkat ediniz. Girintiler
              için boşluk veya sekme karakterleri kullanılabilir.
            </para>
     </listitem>
     <listitem>
      <para><literal>print</literal> deyimi kendisine verilen ifadenin veya
              ifadelerin değerini yazar. Birden fazla ifade verilmesi durumunda
              bunlar aralarında boşluk ile yazılırlar:
</para>
      <para>
       <screen>
&gt;&gt;&gt;i = 256*256
&gt;&gt;&gt; print 'İşlemin sonucu:', i
İşlemin sonucu: 65536
</screen>
      </para>
      <para>
              Sona eklenen bir virgül ise çıktı satırından sonra yeni satıra
              geçilmesini engeller:
</para>
      <para>
       <screen>
&gt;&gt;&gt; a, b = 0, 1
&gt;&gt;&gt; while b &lt; 1000:
...     print b,
...     a, b = b, a+b
...
1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987
</screen>
      </para>
     </listitem>
    </itemizedlist>
   </para>
  </section>
 </chapter>
 <chapter xml:id="python-tutorial_akis-denetimi">
  <info>
   <title>Akış Denetimi</title>
  </info>
  <para>
      Bir önceki bölümde tanıtılan <literal>while</literal> deyiminin yanısıra
      Python'da diğer programlama dillerinde de bulunan genel akış denetim
      deyimleri (bazı farklarla birlikte) vardır.
    </para>
  <section xml:id="python-tutorial_if">
   <info>
    <title><literal>if</literal> Deyimi</title>
   </info>
   <para>
        Belki de en iyi bilinen deyim türü <literal>if</literal> deyimidir. Örnek:
</para>
   <para>
    <screen>
&gt;&gt;&gt; x = int(raw_input("Lütfen bir sayı girin: "))
&gt;&gt;&gt; if x &lt; 0:
...      x = 0
...      print 'Negatif sayı sıfırlandı'
... elif x == 0:
...      print 'Sıfır'
... elif x == 1:
...      print 'Bir'
... else:
...      print 'Birden büyük'
...
</screen>
   </para>
   <para>
        Sıfır veya daha fazla <literal>elif</literal> deyimi olabilir, ve
        <literal>else</literal> deyimi seçimliktir. <literal>elif</literal>
        deyimi <literal>else if</literal> deyiminin kısaltılmışıdır ve aşırı
        girintileri engellemesi açısından faydalıdır. Bir <literal>if ... elif
        ... elif ...</literal> deyimleri dizisi diğer dillerde bulunan
        <literal>switch</literal> veya <literal>case</literal> deyimlerinin
        yerine kullanılabilir.
      </para>
  </section>
  <section xml:id="python-tutorial_for">
   <info>
    <title><literal>for</literal> Deyimi</title>
   </info>
   <para><literal>for</literal> deyimi Pascal veya C dillerinde görülenden biraz
        farklıdır. Python'daki <literal>for</literal> deyimi herhangi bir sıranın
        (liste, dizge, vs.) elemanları üzerinde sırayla yinelenir. Örnek:
</para>
   <para>
    <screen>
&gt;&gt;&gt; # Bazı dizgelerin boylarını ölçelim:
... a = ['kedi', 'pencere', 'kertenkele']
&gt;&gt;&gt; for x in a:
...     print x, len(x)
...
kedi 4
pencere 7
kertenkele 10
</screen>
   </para>
   <para>
        Üzerinde yinelenilen sırada değişiklik yapmak güvenli değildir
        (bu sadece listelerde olabilir). Eğer böyle bir şey yapacaksanız
        bu iş için dilim gösterimi ile listenin bir kopyasını
        kullanabilirsiniz:
</para>
   <para>
    <screen>
&gt;&gt;&gt; for x in a[:]: # tüm listenin bir kopyasını oluştur
... if len(x) &gt; 8: a.insert(0, x)
...
&gt;&gt;&gt; a
['kertenkele', 'kedi', 'pencere', 'kertenkele']
</screen>
   </para>
  </section>
  <section xml:id="python-tutorial_range">
   <info>
    <title><literal>range()</literal> işlevi</title>
   </info>
   <para>
        Eğer bir sayı sırası üzerinde tekrarlamalar yapmak isterseniz, belirli
        bir sıraya göre üretilen sayılardan oluşan bir liste oluşturan
        <literal>range()</literal> yerleşik işlevini kullanabilirsiniz.
        Örnek:
</para>
   <para>
    <screen>
&gt;&gt;&gt; range(10)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</screen>
   </para>
   <para>
        Verilen bitiş noktası asla üretilen listenin bir parçası olmaz;
        <literal>range(10)</literal> ifadesi 10 elemanı olan bir liste oluşturur.
        Listenin başlayacağı sayıyı ve artış miktarını da belirlemek mümkündür.
        Artış miktarı negatif de olabilir.
</para>
   <para>
    <screen>
&gt;&gt;&gt; range(5, 10)
[5, 6, 7, 8, 9]
&gt;&gt;&gt; range(0, 10, 3)
[0, 3, 6, 9]
&gt;&gt;&gt; range(-10, -100, -30)
[-10, -40, -70]
</screen>
   </para>
   <para><literal>range()</literal> ve <literal>len()</literal> işlevlerini bir
        arada kullanarak da bir listenin elemanları üzerinde döngüler
        kurabilirsiniz:
</para>
   <para>
    <screen>
&gt;&gt;&gt; a = ['Python', 'programlama', 'öğrenmek', 'çok', 'kolay !']
&gt;&gt;&gt; for i in range(len(a)):
...     print i, a[i]
...
0 Python
1 programlama
2 öğrenmek
3 çok
4 kolay
</screen>
   </para>
  </section>
  <section xml:id="python-tutorial_break">
   <info>
    <title>
        Döngülerde <literal>break</literal>, <literal>continue</literal>
        ve <literal>else</literal> Deyimleri
      </title>
   </info>
   <para><literal>break</literal> deyimi, C'de olduğu gibi, içinde kaldığı en küçük
        <literal>for</literal> veya <literal>while</literal> döngüsünden
        çıkılmasına ve döngü deyiminin tamamen sona ermesine neden olur.
      </para>
   <para><literal>continue</literal> deyimi döngü içindeki diğer deyimlerin
        atlanıp bir sonraki yineleme işleminin başlamasına sebep olur.
      </para>
   <para>
        Döngülerde <literal>else</literal> ifadesi de kullanılabilir;
        <literal>else</literal> bloğu döngü bittiğinde (<literal>for</literal>
        için) veya devamlılık koşulu geçersiz olduğunda (<literal>while</literal>
        için) işletilir; fakat döngü <literal>break</literal> deyimi ile sona
        erdiyse işletilmez. Bunu asal sayılar bulan aşağıdaki örnekte görebilirsiniz:
</para>
   <para>
    <screen>
&gt;&gt;&gt; for n in range(2, 10):
...     for x in range(2, n):
...         if n % x == 0:
...            print n, 'asal sayı değil. çarpanlar:', x, '*', n/x
...            break
...     else:
...          # çarpan bulunmadan döngü biter ise
...          print n, 'asal sayıdır'
...
2 asal sayıdır
3 asal sayıdır
4 asal sayı değil. çarpanlar: 2 * 2
5 asal sayıdır
6 asal sayı değil. çarpanlar: 2 * 3
7 asal sayıdır
8 asal sayı değil. çarpanlar: 2 * 4
9 asal sayı değil. çarpanlar: 3 * 3
</screen>
   </para>
  </section>
  <section xml:id="python-tutorial_pass">
   <info>
    <title><literal>pass</literal> Deyimi</title>
   </info>
   <para><literal>pass</literal> deyimi hiçbir şey yapmaz. Python sözdizim
        kurallarına göre bir ifadenin gerekli olduğu, fakat programın bir
        şey yapması gerekmediği zaman kullanılabilir:
</para>
   <para>
    <screen>
&gt;&gt;&gt; while 1:
...       pass # klavyeden CTRL+C ile kesilene kadar sürer
...
</screen>
   </para>
  </section>
  <section xml:id="python-tutorial_func">
   <info>
    <title>İşlev Tanımlama</title>
   </info>
   <para>
        Herhangi bir değere kadar Fibonacci serisi yazan bir işlev yazalım:
</para>
   <para>
    <screen>
&gt;&gt;&gt; def fib(n):     # n'e kadar Fibonacci serisini yazdır
...     "n'e kadar Fibonacci serisini yazdır"
...     a, b = 0, 1
...     while b &lt; n:
...         print b,
...         a, b = b, a+b
...
&gt;&gt;&gt; # Tanımladığımız işlevi çağıralım:
... fib(2000)
1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597
</screen>
   </para>
   <para><literal>def</literal> anahtar kelimesi bir işlev tanımını başlatır.
        Bu deyimden sonra bir işlev adı ve parantez içinde parametreler yazılır.
        İşlevin gövdesini oluşturan program satırları sonraki satırdan itibaren
        girintili olarak yazılırlar. İşlev gövdesinin ilk satırı bir dizge de
        olabilir; bu dizge işlevin belgelenmesinde kullanılır (docstring).
      </para>
   <para>
        İşlevlerin belgelenmesinde kullanılan dizgeleri (docstring) otomatik
        olarak çevrim içi ya da basılı belgeler oluşturmak için kullanan
        yazılımlar vardır. Ayrıca bazı geliştirme ortamları bunları program
        yazarken kolaylık sağlaması için etkileşimli olarak programcıya
        sunarlar. Yazdığınız işlevlere bunları eklemeyi bir alışkanlık haline
        getirmeniz faydalı olur.
      </para>
   <para>
        Bir işlevin çağrılması (çalıştırılması) bu işlevdeki yerel değişkenlerin
        olduğu bir simge tablosu oluşturur. İşlev içerisinde bütün değer atama
        işlemlerinde değerler yerel simge tablosuna kaydedilir. Bir değişkene
        başvuru durumunda ise önce yerel (local), sonra genel (global) ve en son
        yerleşik (built-in) simge tablosunda arama yapılır. Bu yüzden genel
        değişkenlere doğrudan değer atama yapılamaz (eğer <literal>global</literal>
        ifadesi içinde kullanılmamışlar ise); ancak bunlara başvuru yapılabilir
        (reference).
      </para>
   <para>
        İşlev çağırıldığında işlevin parametreleri yerel simge tablosuna eklenirler;
        yani parametreler işleve değeri ile çağrı (call by value) kullanılarak
        iletilirler (yani parametreye yapılan değişiklikler yereldir, çağıran
        işlevdeki argümanlarda bir değişme olmaz).
        <footnote><para>
            Aslında nesne başvurusu ile çağrı daha iyi bir tanım olur, çünkü
            işleve değiştirilebilir bir nesne aktarılırsa çağıran çağrılanın o
            nesneye uyguladığı tüm değişiklikleri görür (listeye eklenen
            elemanlar gibi).
          </para></footnote>
      </para>
   <para>
        Bir işlev başka bir işlevi çağırdığında bu çağrı için yeni bir yerel simge
        tablosu oluşturulur.
      </para>
   <para>
        Bir işlev tanımı işlev adının yürürlükte olan simge tablosuna eklenmesine
        sebep olur. İşlevin adı yorurumlayıcı tarafından kullanıcı tanımlı işlev
        veri türü olarak tanınır. Bu değer başka bir isime atanabilir ve bu da bir
        işlev olarak kullanılabilir. Bu genel bir isim değiştirme yolu olabilir:
</para>
   <para>
    <screen>
&gt;&gt;&gt; fib
&lt;function object at 10042ed0&gt;
&gt;&gt;&gt; f = fib # f de fib işlevi olur
&gt;&gt;&gt; f(100)
1 1 2 3 5 8 13 21 34 55 89
</screen>
   </para>
   <para><literal>fib</literal>'in bir işlev olmayıp bir yordam (procedure)
        olduğunu düşünebilirsiniz. Python'da yordamlar, çağıran işleve
        değer geri döndürmeyen işlevlerdir. Aslında yordamlar da bir değer
        geri döndürürler, ama bu sıkıcı bir konudur. Bu değere
        <literal>None</literal> denir ve yerleşik bir değişkendir.
        Yorumlayıcı yazılacak tek değer bu ise normalde <literal>None</literal>
        yazmaz. Bunu görmeyi çok istiyorsanız şunu deneyin:
</para>
   <para>
    <screen>
&gt;&gt;&gt; print fib(0)
None
</screen>
   </para>
   <para>
        Fibonacci serisini yazdırmak yerine, bunu bir liste şeklinde geri
        döndüren işlev yazmak basittir:
</para>
   <para>
    <screen>
&gt;&gt;&gt; def fib2(n): # n e kadar fibonacci serisi geri döndürür
...     " n e kadar fibonacci serisi içeren liste geri döndürür"
...     sonuc = []
...     a, b = 0, 1
...     while b &lt; n:
...         sonuc.append(b)    # değeri listeye ekle
...         a, b = b, a+b
...     return sonuc
...
&gt;&gt;&gt; f100 = fib2(100)    # işlevi çağır
&gt;&gt;&gt; f100                # sonucu yazdır
[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
</screen>
   </para>
   <para>
        Bu örnekte de bazı yeni Python özelliklerini görüyoruz:
      </para>
   <para>
    <itemizedlist>
     <listitem>
      <para><literal>return</literal> deyimi bir işlevden değer geri döndürür.
              Parametresi olmayan bir <literal>return</literal> deyimi
              <literal>None</literal> geri döndürür. Sona eren bir yordam
              (procedure) da <literal>None</literal> geri döndürür.
            </para>
     </listitem>
     <listitem>
      <para><literal>sonuc.append(b)</literal> ifadesi sonuç liste nesnesinin
              bir yöntemini çağırmaktadır. Bir yöntem bir nesneye `ait olan' ve
              <literal>nesne.yöntemAdı</literal> şeklinde adlandırılan bir
              işlevdir. <literal>nesne.yöntemAdı</literal> ifadesinde nesne
              herhangi bir nesne (bir ifade de olabilir) ve <literal>yöntemAdı</literal>
              da nesnenin türüne bağlı bir yöntemdir. Farklı veri türleri farklı
              yöntemlere sahiptirler. Farklı veri türlerinin ayni isimli
              yöntemleri olabilir. Sonraki bölümlerde anlatılacağı gibi, kendi
              veri türlerinizi ve yöntemlerinizi oluşturmanız mümkündür.
              Yukarıdaki örnekte görülen <literal>append()</literal> yöntemi
              liste nesneleri için tanımlıdır ve bir listenin sonuna yeni
              elemanlar ekler. Bu örnekte bu <literal>sonuc = sonuc + [b]</literal>
              ifadesinin yaptığını yapar; ancak daha verimlidir.
            </para>
     </listitem>
    </itemizedlist>
   </para>
  </section>
  <section xml:id="python-tutorial_func-more">
   <info>
    <title>İşlev Tanımları Üzerine Daha Fazla Bilgi</title>
   </info>
   <para>
        Değişken sayıda argüman alan işlevler tanımlamak da mümkündür. Bunun için
        kullanılan üç yöntem olup bunlar birleştirilerek kullanılabilir.
      </para>
   <section>
    <info>
     <title>Argüman Değerlerini Önceden Belirleme</title>
    </info>
    <para>
          İşlev argümanlarına öntanımlı değerler atamak da mümkündür. Böylece
          çağıran işlev bu argümanları sağlamazsa bunlar önceden belirlenmiş
          öntanımlı değerlerini alırlar. Örnek:
</para>
    <para>
     <screen>
def onay_al(prompt, denemeler=4, sikayet='Evet veya hayır, lütfen !'):
    while True:
        ok = raw_input(prompt)
        if ok in ('e', 'evet'): return 1
        if ok in ('h', 'hayır'): return 0
        denemeler = denemeler - 1
        if denemeler &lt; 0: raise IOError, 'kararsız kullanıcı'
        print sikayet
</screen>
    </para>
    <para>
          Bu işlev <literal>onay_al('Programdan çıkmak istiyor musunuz?')</literal>
          ya da <literal>onay_al('Dosyayı silmek istiyor musunuz?', 2)</literal>
          şeklinde çağırılabilir.
        </para>
    <para>
          İşlevin öntanımlı parametreleri işlevin tanımlandığı anda, o an yürürlükte
          olan etki alanı (scope) içinde değerlendirilirler. Yani:
</para>
    <para>
     <screen>
i = 7
def f(arg = i):
    print arg

i = 6
f()
7
</screen>
    </para>
    <para>
     <warning>
      <para>
              İşlevin öntanımlı parametreleri sadece bir defa değerlendirilirler.
              Bu durum parametrenin liste gibi değiştirilebilir bir nesne olduğu
              durumlarda farklılık yaratır. Örneğin aşağıdaki işlev ard arda
              çağırıldığında argümanlarını biriktirir:
</para>
      <para>
       <screen>
def f(a, L = []):
    L.append(a)
    return L
print f(1)
print f(2)
print f(3)
</screen>
      </para>
      <para>
              Bu şu çıktıyı verir:
</para>
      <para>
       <screen>
[1]
[1, 2]
[1, 2, 3]
</screen>
      </para>
     </warning>
    </para>
    <para>
          Eğer öntanımlı parametre değerlerinin birbirini izleyen çağrılarla
          paylaşılmasını istemiyorsanız yukarıdaki işlevi şu şekilde
          yazabilirsiniz:
</para>
    <para>
     <screen>
def f(a, L = None):
    if L is None:
        L = []
    L.append(a)
    return L
</screen>
    </para>
   </section>
   <section>
    <info>
     <title>Anahtar Kelime Argümanlar</title>
    </info>
    <para>
          İşlevler <literal>anahtar kelime = değer</literal> şeklindeki anahtar
          kelimelerle de çağırılabililer. Örneğin şu işlev:
</para>
    <para>
     <screen>
def otomobil(yakit,  hareket=' uçar', model='Anadol'):
    print "Eğer", yakit, "koyarsan bu", model, hareket
</screen>
    </para>
    <para>
          aşağıdaki gibi çağırılabilir:
</para>
    <para>
     <screen>
otomobil('roket yakıtı')
otomobil(hareket = 'dans eder', yakıt = 'zeytin yağı' )
otomobil('ispirto', model = 'Kartal')
otomobil('su','bozulur','Şahin')
</screen>
    </para>
    <para>
          Şu çağrılar ise hatalıdır:
</para>
    <para>
     <screen>
otomobil()                           # gerekli argüman eksik
otomobil(yakıt = 'su','zeytin yağı') # anahtar kelimeden sonra gelen
                                     # anahtar kelime olmayan argüman
otomobil('mazot', yakit = 'benzin')  # aynı argüman için iki değer
otomobil(sehir = 'İzmir')            # bilinmeyen anahtar kelime
</screen>
    </para>
    <para>
          Genel olarak, argüman listesinin başında konuma bağlı argümanlar
          bulunur ve anahtar kelime argümanlar onları izler; anahtar kelime
          adları da işlevin parametrelerinden seçilir. Parametrenin öntanımlı
          değerlerinin olup olmaması önemli değildir. Bir argüman birden
          fazla değer alamaz; konuma bağlı parametre isimleri aynı çağrıda
          anahtar kelime olarak kullanılamazlar. İşte bundan dolayı hatalı
          olan bir örnek:
</para>
    <para>
     <screen>
&gt;&gt;&gt; def function(a):
...     pass
...
&gt;&gt;&gt; function(0, a=0)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
TypeError: keyword parameter redefined
</screen>
    </para>
    <para>
          Eğer işlev tanımındaki son parametre <literal>**isim</literal> şeklinde
          ise bu parametre adları herhangi bir parametre olmayan anahtar kelime
          şeklindeki argümanların bulunduğu bir sözlük olur.
          Bu <literal>*isim</literal> (bu konu <xref linkend="python-tutorial_sozlukler"/>
          bölümünde anlatılacaktır.) şeklindeki bir parametre ile de kullanılabilir, ki
          bu parametre listesi içinde bulunmayan konuma bağlı argümanları içeren
          bir demet (daha sonra <xref linkend="python-tutorial_demetler"/> bölümünde
          incelenecek bir veri türüdür) olur. <literal>*isim</literal> parametresi
          <literal>**isim</literal> parametresinden önce gelmelidir. Buna örnek işlev:
</para>
    <para>
     <screen>
def kasapdukkani(etCinsi,*argumanlar, **anahtarKelimeler):
    print "--", etCinsi, "var mi ?"
    print "-- Maalesef", etCinsi, "kalmadı."
    for arg in argumanlar:
        print arg
    print '-'*40
    anahtarlar = anahtarKelimeler.keys()
    anahtarlar.sort()
    for ak in anahtarlar:
        print ak, ':', anahtarKelimeler[ak]
</screen>
    </para>
    <para>
          Şu şekilde çağrılabilir:
</para>
    <para>
     <screen>
kasapdukkani('martı eti',"Çok lezzetli.",
           "Çok satılıyor.",
           musteri = 'Martı Murat',
           kasap = 'Dev İsmail')
</screen>
    </para>
    <para>
          ve doğal olarak şu çıktıyı verir:
</para>
    <para>
     <screen>
-- martı eti var mi ?
-- Maalesef martı eti kalmadı.
Çok lezzetli.
Çok satılıyor.
----------------------------------------
kasap : Dev İsmail
musteri : Martı Murat
</screen>
    </para>
    <para><literal>anahtarKelimeler</literal> isimli sözlüğün içeriği yazdırılmadan
          önce anahtar kelime isimleri listesinin <literal>sort()</literal>
          yönteminin çağırıldığına dikkat edin; bu yapılmaz ise argümanların hangi
          sıra ile yazılacağı tanımlanmamış olur.
        </para>
   </section>
   <section>
    <info>
     <title>Keyfî Argüman Listeleri</title>
    </info>
    <para>
          Son olarak, en ender kullanılan seçenek de keyfî sayıdaki argümanla
          çağrılabilen bir işlev tanımlamaktır. Bu argümanlar bir demet
          (değişmez liste [tuple]) içine alınırlar. Keyfî argüman listesinden
          önce sıfır ya da daha fazla normal argüman bulunabilir. Örnek:
</para>
    <para>
     <screen>
def fprintf(file, format, *args):
    file.write(format % args)
</screen>
    </para>
   </section>
   <section>
    <info>
     <title>Lambda Biçemli İşlevler</title>
    </info>
    <para>
          Yoğun istek üzerine işlevsel dillerde ve Lisp'te bulunan bazı
          özellikler Python'a eklenmiştir. <literal>lambda</literal> anahtar
          kelimesi ile küçük anonim işlevler yazılabilir. İşte iki
          argümanının toplamını geri döndüren bir işlev:
          <literal>lambda a, b: a+b</literal>.
        </para>
    <para>
          Lambda işlevleri bir işlev
          nesnesine ihtiyaç duyulan her yerde kullanılabilirler.
          Sözdizim (syntax) açısından bunlar tek bir ifade ile
          sınırlandırılmışlardır. Anlambilim (semantics) açısından ise normal
          işlev tanımlamasına getirilen bir sözdizim güzelliğidir. İç içe
          tanımlanmış işlevlerde olduğu gibi lambda işlevleri de kendilerini kapsayan
          etki alanindaki değişkenlere erişebilirler:
</para>
    <para>
     <screen>
&gt;&gt;&gt; def artirici_yap(n):
...     return lambda x: x + n
...
&gt;&gt;&gt; f = artirici_yap(42)
&gt;&gt;&gt; f(0)
42
&gt;&gt;&gt; f(1)
43
</screen>
    </para>
   </section>
   <section>
    <info>
     <title>Belgelendirme Dizgeleri</title>
    </info>
    <para>
          Belgelendirmede kullanılan dizgelerin şekli ve içeriği ile ilgili
          şartlar yeni yeni oluşmaktadır.
        </para>
    <para>
          İlk satır daima nesnenin amacının kısa ve öz tanımı olmalıdır. Kısa
          olması için, nesnenin adından ve türünden bahsedilmemeli; zira bunlar
          başka yollarla da öğrenilebilir. Bu satır büyük harf ile başlayıp
          nokta ile bitmelidir.
        </para>
    <para>
          Eğer belgelendirme dizgesinde birden fazla satır var ise ikinci satır
          boş olup özet ile açıklamamın devamını birbirinden ayırmalıdır. Diğer
          satırlar bir ya da daha fazla satır olabilir. Bunlarla nesnenin
          özellikleri, çağrı şekilleri, yan etkileri vs. açıklanabilir.
        </para>
    <para>
          Python çözümleyicisi (parser) çok satırlı dizgelerdeki
          girintileri yok etmez; yani belgeleri işleyen programlar gerekirse
          bunları atabilirler. İlk satırdan sonra gelen ve boş olmayan ilk satırdaki
          girinti miktarı belgelendirme dizgesinin devamındaki girinti miktarını
          belirler. Bu girinti miktarına ``eşdeğer'' boşluk diğer satırların
          başından atılır. Daha az girintili satırlar olmamalı; ama olursa da
          bunların önündeki boşluğun tamamı atılmalı. Boşluğun eşdeğerliği
          sekmelerin genişletilmesinden (1 sekme = 8 boşluk) sonra sınanmalıdır.
        </para>
    <para>
          İşte çok satırlı bir belgelendirme dizgesi örneği:
</para>
    <para>
     <screen>
&gt;&gt;&gt; def benimFonksiyon():
...     """Sadece belgeler.
...
...     Başka birşey yapmaz. Gerçekten !.
...     """
...     pass
...
&gt;&gt;&gt; print benimFonksiyon.__doc__
Sadece belgeler.

   Başka birşey yapmaz. Gerçekten !
</screen>
    </para>
   </section>
  </section>
 </chapter>
 <chapter xml:id="python-tutorial_veri-yapilari">
  <info>
   <title>Veri Yapıları</title>
  </info>
  <para>
      Bu bölümde öğrendiğiniz bazı şeyler daha ayrıntılı açıklanmakta ve
      bazı yeni konulara da değinilmektedir.
    </para>
  <section xml:id="python-tutorial_listeler">
   <info>
    <title>Listeler Üzerine Daha Fazla Bilgi</title>
   </info>
   <para>
        Liste veri türünün birkaç yöntemi daha var. İşte liste nesnelerinin
        bütün yöntemleri:
      </para>
   <para>
    <variablelist>
     <varlistentry>
      <term>append(x)</term>
      <listitem>
       <para>
                Listenin sonuna bir eleman ekler; <literal>a[len(a):] = [x]</literal>
                ifadesine denktir.
              </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>extend(L)</term>
      <listitem>
       <para>
                Listeyi verilen listedeki tüm elemanarı ekleyerek genişletir;
                <literal>a[len(a):] = L</literal> ifadesine denktir.
              </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>insert(i, x)</term>
      <listitem>
       <para>
                Belirtilen konuma bir eleman yerleştirir. İlk argüman elemanın
                yerleştirileceği indistir. <literal>a.insert(0, x)</literal>
                ifadesi <literal>x</literal>'i listenin başına yerleştirir, ve
                <literal>a.insert(len(a), x)</literal> ifadesi
                <literal>a.append(x)</literal> ifadesine denktir.
              </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>remove(x)</term>
      <listitem>
       <para>
                Liste içinde değeri <literal>x</literal> olan ilk elemanı listeden
                siler. Böyle bir öğe yok ise bu hatadır.
              </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>pop([i])</term>
      <listitem>
       <para>
                Belirtilen konumdaki elemanı listeden siler ve bunu geri döndürür.
                Eğer bir indis belirtilmediyse, <literal>a.pop()</literal>
                listedeki son elemanı siler ve geri döndürür. (<literal>i</literal>
                etrafındaki köşeli ayraçlar bu parametreanin seçimlik olduğunu belirtir.
                Bu yazım biçimini Python belgelerinde sıkça görebilirsiniz.)
              </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>index(x)</term>
      <listitem>
       <para>
                Değeri <literal>x</literal> olan elemanın indisini geri döndürür.
                Böyle bir eleman yok ise bu hatadır.
              </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>count(x)</term>
      <listitem>
       <para><literal>x</literal>'in listede kaç adet bulunduğunu bulur ve bu
                değeri geri döndürür.
              </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>sort()</term>
      <listitem>
       <para>Listenin elemanlarını sıralar - yerinde.</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>reverse()</term>
      <listitem>
       <para>Listenin sırasını tersine çevirir - yerinde.</para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
   <para>
        Liste yöntemlerinin çoğunu kullanan bir örnek:
</para>
   <para>
    <screen>
&gt;&gt;&gt; a = [66.6, 333, 333, 1, 1234.5]
&gt;&gt;&gt; print a.count(333), a.count(66.6), a.count('x')
2 1 0
&gt;&gt;&gt; a.insert(2, -1)
&gt;&gt;&gt; a.append(333)
&gt;&gt;&gt; a
[66.6, 333, -1, 333, 1, 1234.5, 333]
&gt;&gt;&gt; a.index(333)
1
&gt;&gt;&gt; a.remove(333)
&gt;&gt;&gt; a
[66.6, -1, 333, 1, 1234.5, 333]
&gt;&gt;&gt; a.reverse()
&gt;&gt;&gt; a
[333, 1234.5, 1, 333, -1, 66.6]
&gt;&gt;&gt; a.sort()
&gt;&gt;&gt; a
[-1, 1, 66.6, 333, 333, 1234.5]
</screen>
   </para>
   <section>
    <info>
     <title>Listelerin Yığın Olarak Kullanılması</title>
    </info>
    <para>
          Liste yöntemleri listelerin kolayca yığın olarak kullanılmasını
          sağlarlar. Yığına son giren eleman ilk çıkar. Yığının üzerine
          eleman eklemek için <literal>append()</literal> ve en üstteki
          elemanı almak için indis belirtmeden <literal>pop()</literal>
          kullanılır. Örnek:
</para>
    <para>
     <screen>
&gt;&gt;&gt; yigin = [3, 4, 5]
&gt;&gt;&gt; yigin.append(6)
&gt;&gt;&gt; yigin.append(7)
&gt;&gt;&gt; yigin
[3, 4, 5, 6, 7]
&gt;&gt;&gt; yigin.pop()
7
&gt;&gt;&gt; yigin
[3, 4, 5, 6]
&gt;&gt;&gt; yigin.pop()
6
&gt;&gt;&gt; yigin.pop()
5
&gt;&gt;&gt; yigin
[3, 4]
</screen>
    </para>
   </section>
   <section>
    <info>
     <title>Listelerin Kuyruk Olarak Kullanılması</title>
    </info>
    <para>
          Listeleri kuyruk olarak da kullanmak mümkün. Bir kuyrukta ilk eklenen
          eleman ilk alınan elemandır (ilk giren ilk çıkar). Kuyruğun sonuna
          bir eleman eklemek için <literal>append()</literal> kullanılır.
          Sıranın başından bir eleman almak için ise 0 indisi ile
          <literal>pop()</literal> kullanılır. Örnek:
</para>
    <para>
     <screen>
&gt;&gt;&gt; kuyruk = ["Ali", "Veli", "Deli"]
&gt;&gt;&gt; kuyruk.append("Küpeli")           # Küpeli kuyrukta
&gt;&gt;&gt; kuyruk.append("Aylin")            # Aylin kuyrukta
&gt;&gt;&gt; kuyruk.pop(0)
'Ali'
&gt;&gt;&gt; kuyruk.pop(0)
'Veli'
&gt;&gt;&gt; kuyruk
['Deli', 'Küpeli', 'Aylin']
</screen>
    </para>
   </section>
   <section>
    <info>
     <title>İşlevsel Yazılım Geliştirme Araçları</title>
    </info>
    <para>
          Listelerle kullanıldığında çok faydalı olan yerleşik işlevler vardır:
          <literal>filter()</literal>, <literal>map()</literal>, ve
          <literal>reduce()</literal>.
        </para>
    <para><literal>filter(işlev, sıra)</literal> sıra içerisinden
          <literal>işlev(eleman)</literal>'ın doğru sonuç verdiği elemanların
          bulunduğu (mümkünse aynı türden) bir sıra geri döndürür. Örneğin,
          bazı asal sayıları hesaplamak için şöyle yapılabilir:
</para>
    <para>
     <screen>
&gt;&gt;&gt; def f(x): return x % 2 != 0 and x % 3 != 0
...
&gt;&gt;&gt; filter(f, range(2, 25))
[5, 7, 11, 13, 17, 19, 23]
</screen>
    </para>
    <para><literal>map(işlev, sıra)</literal> sıranın her elemanı için
          <literal>işlev(sıra)</literal> çağırır ve geri döndürülen değerlerin
          oluşturduğu listeyi geri döndürür. Örneğin bazı sayıların küplerini
          hesaplamak için şu yol izlenebilir:
</para>
    <para>
     <screen>
&gt;&gt;&gt; def cube(x): return x*x*x
...
&gt;&gt;&gt; map(cube, range(1, 11))
[1, 8, 27, 64, 125, 216, 343, 512, 729, 1000]
</screen>
    </para>
    <para><literal>map(işlev, sıra)</literal> ifadesinde birden fazla sıra da
          kullanılabilir; ancak bu durumda işlev sıra sayısı kadar argümana
          sahip olmalıdır. <literal>işlev</literal> her sıranın uygun elemanını
          bir argüman olarak alır; ancak sıralardan biri kısa ise eksik elemanlar
          için işleve <literal>None</literal> argümanı geçirilir. Eğer işlev adı
          için de <literal>None</literal> kullanılırsa argümanlarını geri
          döndüren bir işlev etkisi yaratılır.
        </para>
    <para>
          Bu iki özel durumu birleştirerek <literal>map(None, list1, list2)</literal>
          ifadesi ile bir çift diziyi çiftlerden oluşan bir diziye çevirebiliriz.
          Örnek:
</para>
    <para>
     <screen>
&gt;&gt;&gt; sira = range(8)
&gt;&gt;&gt; def kare(x): return x*x
...
&gt;&gt;&gt; map(None, sira, map(kare, sira))
[(0, 0), (1, 1), (2, 4), (3, 9), (4, 16), (5, 25), (6, 36), (7, 49)]
</screen>
    </para>
    <para><literal>reduce(işlev, sıra)</literal> ifadesi tek bir değer geri
          döndürür. Bu değer şöyle elde edilir: iki argümanlı işleve sıranın
          ilk iki elemanı argüman olarak verilir, sonra da elde edilen sonuç
          ile sıranın sonraki elemanı argüman olarak verilir, daha sonra yine
          elde edilen sonuç ile bir sonraki eleman işleve verilir ve bu işlem
          bütün elemanlar için tekrarlanır. Örneğin 1'den 10'a kadar olanlar
          böyle toplanabilir:
</para>
    <para>
     <screen>
&gt;&gt;&gt; def topla(x,y): return x+y
...
&gt;&gt;&gt; reduce(topla, range(1, 11))
55
</screen>
    </para>
    <para>
          Sırada sadece bir eleman var ise bunun değeri geri döndürülür;
          sıra boş ise bir istisna oluşur (exception).
        </para>
    <para>
          Başlangıç değerini bildirmek için üçüncü bir argüman kullanılabilir.
          Bu durumda işleve ilk olarak başlangıç değeri ve sıranın ilk elemanına
          uygulanır ve diğer elemanlar ile devam eder. Örnek:
</para>
    <para>
     <screen>
&gt;&gt;&gt; def sonuc(sira):
...     def topla(x,y): return x+y
...     return reduce(topla, sira, 0)
...
&gt;&gt;&gt; sonuc(range(1, 11))
55
&gt;&gt;&gt; sonuc([])
0
</screen>
    </para>
   </section>
   <section>
    <info>
     <title>Liste Üreteçleri</title>
    </info>
    <para>
          Liste üreteçleri <literal>map()</literal>, <literal>filter()</literal>
          ve/veya <literal>lambda</literal> işlevlerini kullanmadan liste
          yaratmanın kısa bir yoludur. Bu yolla yaratılan liste tanımı genellikle
          daha kolay anlaşılır olur. Bir liste üreteci bir ifade ve bir
          <literal>for</literal> döngüsü ile bunları izleyen sıfır ya da daha
          fazla <literal>for</literal> veya <literal>if</literal> ifadelerinden
          oluşur. Sonuç kendisini izleyen <literal>for</literal> ve
          <literal>if</literal> bağlamında değerlendirilen ifadeden oluşan bir
          listedir. Eğer ifade bir demete (değişmez liste [tuple]) dönüşecekse
          parantez içinde yazılmalıdır.
</para>
    <para>
     <screen>
&gt;&gt;&gt; freshfruit = ['  banana', '  loganberry ', 'passion fruit  ']
&gt;&gt;&gt; [weapon.strip() for weapon in freshfruit] # elemanları saran
boşlukların atıldığı yeni bir liste
['banana', 'loganberry', 'passion fruit']
&gt;&gt;&gt; vec = [2, 4, 6]
&gt;&gt;&gt; [3*x for x in vec]
[6, 12, 18]
&gt;&gt;&gt; [3*x for x in vec if x &gt; 3]
[12, 18]
&gt;&gt;&gt; [3*x for x in vec if x &lt; 2]
[]
&gt;&gt;&gt; [{x: x**2} for x in vec]   # sözlüklerden oluşan bir liste
[{2: 4}, {4: 16}, {6: 36}]
&gt;&gt;&gt; [[x,x**2] for x in vec]
[[2, 4], [4, 16], [6, 36]]
&gt;&gt;&gt; [x, x**2 for x in vec]   # hata - demet için parantez gerekir
  File "&lt;stdin&gt;", line 1, in ?
    [x, x**2 for x in vec]
               ^
SyntaxError: invalid syntax
&gt;&gt;&gt; [(x, x**2) for x in vec]
[(2, 4), (4, 16), (6, 36)]
&gt;&gt;&gt; vec1 = [2, 4, 6]
&gt;&gt;&gt; vec2 = [4, 3, -9]
&gt;&gt;&gt; [x*y for x in vec1 for y in vec2]
[8, 6, -18, 16, 12, -36, 24, 18, -54]
&gt;&gt;&gt; [x+y for x in vec1 for y in vec2]
[6, 5, -7, 8, 7, -5, 10, 9, -3]
&gt;&gt;&gt; [vec1[i]*vec2[i] for i in range(len(vec1))]
[8, 12, -54]
</screen>
    </para>
    <para>
          Liste üreteçlerinin <literal>for</literal> döngülerine benzer davranması için,
          döngü değişkenine yapılan atamalar üreteç dışında da görünürler:
</para>
    <para>
     <screen>
&gt;&gt;&gt; x = 100                     # bu değişecek
&gt;&gt;&gt; [x**3 for x in range(5)]
[0, 1, 8, 27, 64]
&gt;&gt;&gt; x
4                               # range(5) için son değer
&gt;&gt;
</screen>
    </para>
   </section>
  </section>
  <section xml:id="python-tutorial_del">
   <info>
    <title><literal>del</literal> Deyimi</title>
   </info>
   <para><literal>del</literal> deyimi ile bir listeden indisi verilen bir
        eleman silinebilir. Bu deyim ile bir listeden dilimler de silinebilir
        (bunu daha önce dilimlere boş bir liste atayarak yapmıştık). Örnek:
</para>
   <para>
    <screen>
&gt;&gt;&gt; a
[-1, 1, 66.6, 333, 333, 1234.5]
&gt;&gt;&gt; del a[0]
&gt;&gt;&gt; a
[1, 66.6, 333, 333, 1234.5]
&gt;&gt;&gt; del a[2:4]
&gt;&gt;&gt; a
[1, 66.6, 1234.5]
</screen>
   </para>
   <para><literal>del</literal> deyimi tamamen silmek için de kullanılabilir:
</para>
   <para>
    <screen>
&gt;&gt;&gt; del a
</screen>
   </para>
   <para>
        Bu aşamadan sonra <literal>a</literal> ismine başvuru bir hatadır
        (aynı isme başka bir değer atanana kadar). Daha sonra <literal>del</literal>
        için başka kullanım alanları da göreceğiz.
      </para>
  </section>
  <section xml:id="python-tutorial_demetler">
   <info>
    <title>Demetler (tuples)</title>
   </info>
   <para>
        Listelerin ve dizgelerin indisleme ve dilimleme gibi pek çok ortak
        özellikleri olduğunu grdük. Bunlar sıra şeklindeki iki veri türüdürler.
        Python gelişmekte olan bir dil; diğer sıra şeklindeki veri türleri de
        Python'a eklenebilir. Demet de başka bir sıra şekilli standart veri türüdür.
      </para>
   <para>
        Bir demet virgül ile ayrılmış bir kaç değerden oluşur.
</para>
   <para>
    <screen>
&gt;&gt;&gt; t = 12345, 54321, 'merhaba!'
&gt;&gt;&gt; t[0]
12345
&gt;&gt;&gt; t
(12345, 54321, 'merhaba!')
&gt;&gt;&gt; # demetler iç içe kullanılabilirler :
... u = t, (1, 2, 3, 4, 5)
&gt;&gt;&gt; u
((12345, 54321, 'merhaba!'), (1, 2, 3, 4, 5))
</screen>
   </para>
   <para>
        Gördüğünüz gibi çıktıda demetler daima parantez içinde görünürler; ki
        iç içe geçmiş demetler belli olsun. Demetler parantezli veya parantezsiz
        olarak yazılabilirler; ancak parantezler genelikle gereklidirler
        (özellikle de demet daha büyük bir ifadenin içinde geçiyorsa).
      </para>
   <para>
        Demetlerin pekçok kullanım alanı var: <literal>(x, y)</literal> koordinat
        çifti, veri tabanındaki işçi kayıtları vb. gibi. Demetler de dizgeler
        gibi değerleri değiştirilemez veri türleridir; bunların elemanlarına
        atama yapılamaz (fakat dilimleme ve birleştirme aracılığı ile bu etki
        sağlanabilir). Ayrıca değiştirilebilen elemanlardan oluşan demetler
        oluşturmak da mümkündür (örnek: listelerden oluşan bir demet).
      </para>
   <para>
        Sıfır veya bir elemanlı demetlerin oluşturulması ile ilgili özel bir
        problem var: bunların ifade edilmesini sağlayan sözdizim biraz acayip.
        Boş demetler bir çift boş parantez ile ifade edilir. Tek elemanı olan
        bir demet için ise elemandan sonra bir virgül kullanılır (tek bir
        değeri parantez içine almak yeterli değildir). Çirkin ama etkili.
        Örnek:
</para>
   <para>
    <screen>
&gt;&gt;&gt; bos = ()
&gt;&gt;&gt; tekOge = 'merhaba', # &lt;--satır sonundaki virgüle dikkat
&gt;&gt;&gt; len(bos)
0
&gt;&gt;&gt; len(tekOge)
1
&gt;&gt;&gt; tekOge
('merhaba',)
</screen>
   </para>
   <para><literal>t = 12345, 54321, 'merhaba!'</literal> ifadesi demetleme
        (tuple packing) işlemine bir örnektir: <literal>12345, 54321</literal> ve
        <literal>'merhaba!'</literal> değerleri bir demet içinde toplanmışlardır.
        Bu işlemin tersi de mümkün:
</para>
   <para>
    <screen>
&gt;&gt;&gt; x, y, z = t
</screen>
   </para>
   <para>
        Doğal olarak, buna demet açma (sequence unpacking) deniyor. Demet açma
        sol taraftaki değişken sayısının sıra içindeki öğe sayısına eşit
        olmasını gerektirir. Çoklu değer atama işleminin aslında demetleme ve
        demet açmanın bir bileşimi olduğuna dikkat edin.
      </para>
   <para>
        Burada küçük bir asimetri var: birden fazla değeri demetleme her zaman
        bir demet oluşturur ve demet açma herhangi bir sıra için yapılabilir.
        Örnek:
</para>
   <para>
    <screen>
&gt;&gt;&gt; paket = 'xyz' # bir dizge
&gt;&gt;&gt; a,b,c = paket
&gt;&gt;&gt; a
'x'
&gt;&gt;&gt; b
'y'
&gt;&gt;&gt; c
'z'
</screen>
   </para>
  </section>
  <section xml:id="python-tutorial_sozlukler">
   <info>
    <title>Sözlükler (Çağrışımlı Listeler)</title>
   </info>
   <para>
        Python'da bulunan bir diğer faydalı veri türü de sözlüktür. Sözlükler
        diğer programlama dillerinde ``çağrışımlı bellek'' (associative memory)
        veya ``çağrışımlı dizi'' (associative array) olarak bilinirler.
        Sayılarla indislenen sıralardan farklı olarak, sözlükler anahtarlar
        (key) ile indislenirler. Anahtar değiştirilemeyen türdeki herhangi bir
        veri türünde olabilir. Sayılar ve dizgeler her zaman anahtar olabilirler.
        Demetler de sayılar, dizgeler veya demetler içerdikleri sürece
        anahtar olabilirler. Bir demet doğrudan ya da dolaylı olarak değiştirilebilir
        bir nesne içeriyorsa anahtar olarak kullanılamaz. Listeler anahtar
        olamazlar, çünkü <literal>append()</literal> ile <literal>extend()</literal>
        yöntemleri, dilimleme ve indise değer atama ile değiştirilebilirler.
      </para>
   <para>
        Bir sözlük <literal>anahtar : değer</literal> çiftlerinden oluşur. Bir
        anahtar sözlükte sadece bir defa bulunabilir. Bir çift çengelli parantez
        boş bir sözlük yaratır : <literal>{}</literal>. Çengelli parantezlerin
        içine virgülle ayrılmış <literal>anahtar : değer</literal> çiftleri
        koymak anahtar ve değer çiftlerine ilk değerlerini verir. Çıktıya da
        sözlükler aynı şekilde yazılırlar.
      </para>
   <para>
        Sözlüklerle ilgili ana işlemler bir değerin bir anahtar ile saklanması
        ve anahtar verildiğinde değerin bulunmasıdır. <literal>del</literal>
        kullanarak bir <literal>anahtar : değer</literal> çiftini silmek mümkündür.
        Zaten mevcut olan bir anahtar kullanarak bir değer eklerseniz bu anahtarla
        bağlantılı eski değer unutulur. Mevcut olmayan bir anahtar ile değer
        istemek hatalıdır.
      </para>
   <para>
        Sözlük nesnesinin <literal>keys()</literal> yöntemi listedeki bütün
        anahtarların listesini rasgele sıralı olarak geri döndürür (sıralamak
        isterseniz listenin <literal>sort()</literal> yönteminden faydalanabilirsiniz).
        Bir anahtarın sözlükte olup olmadığını görmek için sözlüğün
        <literal>has_key()</literal> yöntemi kullanılır.
      </para>
   <para>
        İşte sözlük kullanan küçük bir örnek:
</para>
   <para>
    <screen>
&gt;&gt;&gt; tel = {'jack': 4098, 'sape': 4139}
&gt;&gt;&gt; tel['guido'] = 4127
&gt;&gt;&gt; tel
{'sape': 4139, 'guido': 4127, 'jack': 4098}
&gt;&gt;&gt; tel['jack']
4098
&gt;&gt;&gt; del tel['sape']
&gt;&gt;&gt; tel['irv'] = 4127
&gt;&gt;&gt; tel
{'guido': 4127, 'irv': 4127, 'jack': 4098}
&gt;&gt;&gt; tel.keys()
['guido', 'irv', 'jack']
&gt;&gt;&gt; tel.has_key('guido')
1
</screen>
   </para>
   <para><literal>dict()</literal> işlevi anahtar-değer çiftlerinden oluşan demetlerden
        sözlükler üretir. Çiftlerin bir kalıba uyduğu durumlarda, liste üreteçleri
        ile anahtar-değer çiftleri kısaca ifade edilebilir.
</para>
   <para>
    <screen>
&gt;&gt;&gt; dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])
{'sape': 4139, 'jack': 4098, 'guido': 4127}
&gt;&gt;&gt; dict([(x, x**2) for x in vec])     # liste üreteci kullanarak
{2: 4, 4: 16, 6: 36}
</screen>
   </para>
  </section>
  <section xml:id="python-tutorial_dongu">
   <info>
    <title>Döngü Teknikleri</title>
   </info>
   <para>
        Sözlükler üzerinde döngüler kurarken o anki değer <literal>items()</literal>
        yöntemi ile aynı anda elde edilebilir.
</para>
   <para>
    <screen>
&gt;&gt;&gt; knights = {'gallahad': 'the pure', 'robin': 'the brave'}
&gt;&gt;&gt; for k, v in knights.items():
...     print k, v
...
gallahad the pure
robin the brave
</screen>
   </para>
   <para>
        Bir sıra üzerinde dönerken konum indisi ve ona karşılık gelen değer de
        <literal>enumerate()</literal> işlevini kullanarak aynı anda elde edilebilir.
</para>
   <para>
    <screen>
&gt;&gt;&gt; for i, v in enumerate(['tic', 'tac', 'toe']):
...     print i, v
...
0 tic
1 tac
2 toe
</screen>
   </para>
   <para>
        Aynı anda iki sıra üzerinde ilerlemek için ise <literal>zip()</literal>
        işlevi ile bunlar çiftler haline getirilebilir.
</para>
   <para>
    <screen>
&gt;&gt;&gt; sorular = ['adın', 'görevin', 'favori rengin']
&gt;&gt;&gt; cevaplar = ['Adnan', 'Uyumak', 'Mavi']
&gt;&gt;&gt; for s, c in zip(sorular, cevaplar):
...     print 'Senin %s ne? %s.' % (s, c)
...
Senin adın ne? Adnan.
Senin görevin ne? Uyumak.
Senin favori rengin ne? Mavi.
</screen>
   </para>
  </section>
  <section xml:id="python-tutorial_kosullu">
   <info>
    <title>Koşullu İfadeler Üzerine Daha Fazla Bilgi</title>
   </info>
   <para><literal>while</literal> ve <literal>if</literal> deyimlerinde kıyaslama
        dışında da işleçler kullanılabilir.
      </para>
   <para><literal>in</literal> ve <literal>not</literal> kıyaslama işleçleri bir
        değerin bir sıra içinde olup olmadığını sınarlar.
      </para>
   <para><literal>is</literal> ve <literal>is not</literal> işleçleri iki nesnenin
        tamamen aynı nesne olup olmadıklarını sınarlar (bu sadece liste gibi
        değiştirilebilir nesnelerde önemlidir).
      </para>
   <para>
        Bütün kıyaslama işleçleri aynı önceliğe sahiptirler ve bu sayısal
        işleçlerinkinden düşüktür.
      </para>
   <para>
        Kıyaslamalar zincirlenebilir: <literal>a &lt; b == c</literal> gibi.
      </para>
   <para>
        Kıyaslamalar mantıksal işleçler <literal>and</literal> ve
        <literal>or</literal> ile birleştirilebilirler ve kıyaslamanın sonucu
        (ya da herhangi bir mantıksal ifade) <literal>not</literal> ile
        değillenebilirler. Bunların hepsi de kıyaslama işleçlerinden düşük
        önceliğe sahiptirler ve aralarında en yüksek öncelikli olan
        <literal>not</literal> ve en düşük öncelikli olan <literal>or</literal>
        işleçidir. Örneğin <literal>A and not B or C</literal> ifadesi
        <literal>(A and (not B)) or C</literal> ifadesine eştir. İstenen bileşimi
        elde etmek için parantezler kullanılabilir.
      </para>
   <para><literal>and</literal> ve <literal>or</literal> mantıksal işleçlerine
        kısa devre işleç de denir. Bunların argümanları soldan sağa
        değerlendirilir ve sonuç belli olur olmaz değerlendirme işlemi kesilir.
        Örneğin A ve C doğru, fakat B yanlış olsun. <literal>A and B and C</literal>
        ifadesinde C ifadesi değerlendirilmez (çünkü C'nin değeri sonucu değiştirmez).
        Genel olarak bir kısa devre işleçi <literal>Bool</literal> değil de genel
        bir değer gibi kullanıldığında en son değerlendirilen argümanın değeri geri
        döndürülür.
      </para>
   <para>
        Bir kıyaslamanın ya da mantıksal ifadenin sonucunu bir değişkene atamak
        mümkündür:
</para>
   <para>
    <screen>
&gt;&gt;&gt; string1, string2, string3 = '', 'Trondheim', 'Hammer Dance'
&gt;&gt;&gt; non_null = string1 or string2 or string3
&gt;&gt;&gt; non_null
'Trondheim'
</screen>
   </para>
   <para>
        C dilinin tersine, Python'da ifadelerin içinde atama olamayacağına
        dikkat edin. C programcıları bundan şikayetçi olabilirler; ancak bu C
        programlarında sık karşılaşılan bazı hataları engellemektedir
        (== yerine = yazmak gibi).
      </para>
  </section>
  <section xml:id="python-tutorial_dizge-demet">
   <info>
    <title>Listeler, Dizgeler ve Demetler Arasında Kıyaslama</title>
   </info>
   <para>
        Sıra nesneleri yine sıra şeklindeki diğer nesnelerle kıyaslanabilirler.
        Önce ilk iki eleman kıyaslanır. Bunlar farklı ise sonuç belli olmuştur;
        eşit olmaları halinde sonraki iki eleman kıyaslanır ve sıralardan biri
        tükenene kadar bu işlem tekrarlanır. Eğer kıyaslanan iki öğe de sıra
        ise bunlar da kendi aralarında kıyaslanırlar. İki sıranın bütün öğeleri
        aynı bulunursa bu sıralar eşit kabul edilir. Eğer bir sıra diğerinin
        başından bir kısmı ile aynı ise kısa olan sıra küçük kabul edilir.
        Karakterlerin kıyaslanmasında ASCII karakter sırası kullanılır.
        Aynı türden sıraların kıyaslanmasına bazı örnekler :
</para>
   <para>
    <screen>
(1, 2, 3)              &lt; (1, 2, 4)
[1, 2, 3]              &lt; [1, 2, 4]
'ABC' &lt; 'C' &lt; 'Pascal' &lt; 'Python'
(1, 2, 3, 4)           &lt; (1, 2, 4)
(1, 2)                 &lt; (1, 2, -1)
(1, 2, 3)             == (1.0, 2.0, 3.0)
(1, 2, ('aa', 'ab'))   &lt; (1, 2, ('abc', 'a'), 4)
</screen>
   </para>
   <para>
        Farklı türden nesnelerin kıyaslanmasının yasal olduğuna dikkat edin.
        Türler alfabetik sırayla dizilmiştir (ingilizce isimlerine göre).
        Yani: liste &lt; dizge &lt; demet (list &lt; string &lt; tuple).
        <footnote><para>
            Değişik türlerin kıyaslanmasına ilişkin kurallara güvenilmemeli;
            gelecek Python sürümlerinde bu kurallar değişebilir!
          </para></footnote>
      </para>
  </section>
 </chapter>
 <chapter xml:id="python-tutorial_moduller">
  <info>
   <title>Modüller</title>
  </info>
  <para>
      Python yorumlayıcısını kapatıp tekrar açarsanız yaptığınız tanımlar
      (işlevler ve değişkenler) kaybolur. Uzunca bir program yazmak isterseniz
      bunun için programınızı bir metin düzenleyici ile hazırlayıp yazdığınız
      dosyayı yorumlayıcı girişi olarak kullanırsanız daha iyi olur. Bu işleme
      betik yazmak denir. Programınız uzadıkça bunu daha kolay idare etmek için
      birkaç dosyaya bölmek isteyebilirsiniz. Yazdığınız bir işlev tanımını
      kopyalamaya ihtiyaç duymaksızın birkaç programda kullanmayı da
      isteyebilirsiniz.
    </para>
  <para>
      Bu iş için Python'da modül denen dosyalar var. Bunlara yazılan tanımlar
      diğer modüllere ya da etkileşimli kipteki yorumlayıcıya <literal>import</literal>
      deyimi ile yüklenebilirler.
    </para>
  <para>
      Modüller <literal>.py</literal> uzantılı metin dosyalarıdır ve içlerinde
      Python deyimleri ve tanımları bulur. Bir modül içerisinde
      <literal>__name__ </literal> global değişkeninin değeri (bir dizge) o
      modülün adını verir. Örneğin, favori metin düzenleyiciniz ile
      <literal>fibo.py</literal> adlı bir dosya yaratıp Python yorumlayıcısının
      bulabileceği bir dizine kaydedin. Dosyanın içeriği de şu olsun:
</para>
  <para>
   <screen>
# Fibonacci sayıları modülü

def fib(n):    # n e kadar Fibonacci serisini yazdır
    a, b = 0, 1
    while b &lt; n:
        print b,
        a, b = b, a+b

def fib2(n): # n e kadar Fibonacci serisi geri döndürür
    sonuc = []
    a, b = 0, 1
    while b &lt; n:
        sonuc.append(b)
        a, b = b, a+b
    return sonuc
</screen>
  </para>
  <para>
      Yorumlayıcıyı açıp bu modülü şu komut ile yükleyin:
</para>
  <para>
   <screen>
&gt;&gt;&gt; import fibo
</screen>
  </para>
  <para>
      Bu fibo içindeki işlev tanımlarını yürürlükte olan simge tablosuna
      eklemez; sadece modül adı fibo tabloya eklenir. İşlevlere modül adı
      kullanarak erişilebilir:
</para>
  <para>
   <screen>
&gt;&gt;&gt; fibo.fib(1000)
1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987
&gt;&gt;&gt; fibo.fib2(100)
[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
&gt;&gt;&gt; fibo.__name__
'fibo'
</screen>
  </para>
  <para>
      Bir işlevi sık sık kullanmak isterseniz bunu yerel bir isme
      atayabilirsiniz:
</para>
  <para>
   <screen>
&gt;&gt;&gt; fib = fibo.fib
&gt;&gt;&gt; fib(500)
1 1 2 3 5 8 13 21 34 55 89 144 233 377
</screen>
  </para>
  <section xml:id="python-tutorial_moduller-daha">
   <info>
    <title>Modüller Üzerine Daha Fazla Bilgi</title>
   </info>
   <para>
        İşlev tanımlarının yanısıra modül içinde çalıştırılabilir ifadeler de
        olabilir. Bu ifadeler modülün ilk kullanıma hazırlanması için
        kullanılabilirler ve sadece modülün ilk yüklenişinde çalışırlar.
        <footnote><para>
            Aslında işlev tanımları da `çalıştırılan' ifadelerdir; işlev adını
            modülün global simge tablosuna eklerler.
          </para></footnote>
      </para>
   <para>
        Her modülün o modül içindeki bütün işlevler tarafından global simge
        tablosu olarak kullanılan kendi simge tablosu vardır. Bu özellik
        sayesinde modülü yazan kişi rahatlıkla modül içnde global değişkenler
        kullanabilir. Modülü kullanan diğer kişilerin global değişkenleri ile
        isim çakışması olmaz. Modül içindeki global değişkenlere de
        <literal>modulAdi.degiskenAdi</literal> şeklinde ulaşmak ve istenirse
        bunları değiştirmek mümkündür.
      </para>
   <para>
        Modüller diğer modülleri yükleyebilirler. Bütün <literal>import</literal>
        ifadelerinin modülün (ya da betiğin) başına konması gelenektendir; ancak
        şart değildir. Yüklenen modüller kendilerini yükleyen modülün global simge
        tablosuna ekleniriler.
      </para>
   <para><literal>import</literal> deyiminin bir modüldeki isimleri doğrudan
        yükleyen modülün simge tablosuna ekleyen kullanım şekli var. Örnek:
</para>
   <para>
    <screen>
&gt;&gt;&gt; from fibo import fib, fib2
&gt;&gt;&gt; fib(500)
1 1 2 3 5 8 13 21 34 55 89 144 233 377
</screen>
   </para>
   <para>
        Bu kullanım şeklinde yüklemenin yapıldığı modül adı yerel simge tablosuna
        eklenmez (yani örnekteki fibo tanımlı değildir).
      </para>
   <para>
        Bir modülde tanımlanmış bütün isimleri de yüklemek şu şekilde mümkündür:
</para>
   <para>
    <screen>
&gt;&gt;&gt; from fibo import *
&gt;&gt;&gt; fib(500)
1 1 2 3 5 8 13 21 34 55 89 144 233 377
</screen>
   </para>
   <para>
        Bu altçizgi ( <literal>_</literal> ) ile başlayanlar dışındaki bütün
        isimleri yükler.
      </para>
   <section>
    <info>
     <title>Modül Arama Yolu</title>
    </info>
    <para><literal>spam</literal> isimli bir modül yüklenmek istendiğinde
          yorumlayıcı önce çalıştırıldığı dizinde ve sonra
          <literal>PYTHONPATH</literal> ortam değişkenince tanımlanan dizinler
          içinde <literal>spam.py</literal> isimli bir dosya arar.
          <literal>PYTHONPATH</literal> dizin isimlerinden oluşan bir listedir
          (PATH gibi). Aranan dosya bulunmazsa arama, kuruluma bağlı başka bir
          yolda da aranabilir. Genelde bu <literal>/usr/local/lib/python</literal>
          dizinidir.
        </para>
    <para>
          Aslında modüller <literal>sys.path</literal> değişkeninde bulunan dizin
          listesinde aranırlar. Bu değişken değerini betiğin alıştırıldığı dizin,
          <literal>PYTHONPATH</literal> ve kuruluma bağlı diğer dizinlerden alır.
          <literal>sys.path</literal> değişkeni sayesinde Python programları modül
          arama yolunu değiştirebilirler.
        </para>
   </section>
   <section>
    <info>
     <title>"Derlenmiş" Python Dosyaları</title>
    </info>
    <para>
          Derlenmiş Python dosyaları programların çalışmaya başlaması için
          gereken süreyi kısaltırlar. Örneğin <literal>spam.py</literal> adlı
          dosyanın bulunduğu dizinde <literal>spam.pyc</literal> adlı bir dosya
          varsa bu modul, <literal>spam</literal> modülünün ikilik derlenmiş
          halidir. <literal>spam.py</literal> dosyasının son değiştirilme
          tarihi <literal>spam.pyc</literal> dosyasının içinde de kayıtlıdır ve
          bu tarihler aynı değil ise <literal>.pyc</literal> dosyası dikkate
          alınmaz.
        </para>
    <para><literal>spam.pyc</literal> dosyasının oluşması için bir şey yapmanız
          gerekmez. <literal>spam.py</literal> her ne zaman başarılı olarak
          derlenirse programın derlenmiş hali <literal>spam.pyc</literal>
          dosyasına kaydedilir. Bunun yapılamaması bir hata değildir; herhangi
          bir nedenle <literal>.pyc</literal> dosyası tam olarak yazılamazsa
          geçersiz sayılır ve dikkate alınmaz. <literal>.pyc</literal>
          dosyalarının içeriği platformdan bağımsızdır. Bu sayede bir Python
          modülü dizini farklı mimarideki makineler tarafından paylaşılabilir.
        </para>
    <para>
          Uzmanlar için birkaç ip ucu:
        </para>
    <para>
     <itemizedlist>
      <listitem>
       <para>
                Python yorumlayıcısı <literal>-O</literal> parametresi ile
                çalıştırıldığında eniyileştirilmiş (optimized) kod üretilir
                ve <literal>.pyo</literal> uzantılı dosyalarda saklanır.
                Eniyileştircinin (optimizer) şu anda pek bir yararı olmuyor;
                sadece <literal>assert</literal> deyimlerini siliyor.
                <literal>-O</literal> parametresi kullanıldığında tüm ikilik
                kod eniyileştirilir, <literal>.pyc</literal> dosyaları göz ardı
                edilir ve <literal>.py</literal> dosyaları eniyileştirilmiş
                ikilik kod olarak derlenir.
              </para>
      </listitem>
      <listitem>
       <para>
                Yorumlayıcıya iki tane <literal>-O</literal> parametresi
                (<literal>-OO</literal>) vermek derleyicinin bazı ender durumlarda
                doğru çalışmayan programlara neden olan eniyileştirmeler yapmasına
                neden olur. Şu anda sadece <literal>__doc__</literal> dizgeleri
                silinerek daha küçük <literal>.pyo</literal> dosyaları üretilmektedir.
                Bazı programların çalışması bunların varlığına bağımlı olabileceğinden
                bu parametreyi kullanırken dikkatli olun.
              </para>
      </listitem>
      <listitem>
       <para>
                Bir program <literal>.pyc</literal> ya da <literal>.pyo</literal>
                dosyasından okunduğunda <literal>.py</literal> dosyasından okunan
                halinden daha hızlı çalışmaz; sadece yüklenme süresi kısalır.
              </para>
      </listitem>
      <listitem>
       <para>
                Bir betik komut satırından ismi verilerek çalıştırıldığında bunun
                ikilik kodu asla bir <literal>.pyc</literal> ya da
                <literal>.pyo</literal> dosyasına yazılmaz. Bu yüzden betiğin başlama
                süresini kısaltmak için bunun bir kısmı bir modüle aktarılarak ve bu
                modülü yükleyen küçük bir başlatıcı betik kullanılarak kısaltılabilir.
                Komut satırından bir <literal>.pyc</literal> ya da <literal>.pyo</literal>
                dosyası da ismi verilerek doğrudan çalıştırılabilir.
              </para>
      </listitem>
      <listitem>
       <para><literal>spam.py</literal> dosyası olmadan da <literal>spam.pyc</literal>
                (ya da <literal>-O</literal> kullanıldığında <literal>spam.pyo</literal>)
                dosyası kullanılabilir. Bunlar bir Python kodu kütüphanesinin
                tersine mühendisliği zorlaştıran şekilde dağıtılmasında
                kullanılabilir.
              </para>
      </listitem>
      <listitem>
       <para><literal>compileall</literal> modülü bir dizindeki bütün dosyalar
                için <literal>spam.pyc</literal> (ya da <literal>-O</literal>
                kullanıldığında <literal>spam.pyo</literal>) dosyaları yaratabilir.
              </para>
      </listitem>
     </itemizedlist>
    </para>
   </section>
  </section>
  <section xml:id="python-tutorial_moduller-std">
   <info>
    <title>Standart Modüller</title>
   </info>
   <para>
        Python zengin bir standart modül kütüphanesine sahiptir. Bazı modüller
        yorumlayıcı ile bütünleşiktir. Bu modüller dilin parçası olmadıkları
        halde verimlerini artırmak ya da sistem çağrıları gibi işletim sistemine
        ait özelliklere erişim için yorumlayıcı içine dahil edilmişlerdir.
        Bunlara iyi bir örnek her Python yorumlayıcısına dahil edilen
        <literal>sys</literal> modülüdür. <literal>sys.ps1</literal> ve
        <literal>sys.ps2</literal> değişkenleri de birincil ve ikincil komut
        satırı olarak kullanılan dizgeleri belirlerler:
</para>
   <para>
    <screen>
&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.ps1
'&gt;&gt;&gt; '
&gt;&gt;&gt; sys.ps2
'... '
&gt;&gt;&gt; sys.ps1 = 'C&gt; '
C&gt; print 'Böö !'
Böö !
C&gt;
</screen>
   </para>
   <para>
        Bu iki değişken yorumlayıcı sadece etkileşimli kipte iken tanımlıdırlar.
      </para>
   <para><literal>sys.path</literal> değişkeni de yorumlayıcının modül arama yolunu
        belirler. Bu değerini ortam değişkeni <literal>PYTHONPATH</literal> belirler.
        <literal>PYTHONPATH</literal> değişkenine değer atanmadıysa
        <literal>sys.path</literal> öntanımlı değerini alır. Bunun değeri listelere
        uygulana işlemler ile değiştirilebilir:
</para>
   <para>
    <screen>
&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.path.append('/ufs/guido/lib/python')
</screen>
   </para>
  </section>
  <section xml:id="python-tutorial_dir">
   <info>
    <title><literal>dir()</literal> İşlevi</title>
   </info>
   <para>
        Yerleşik işlev <literal>dir()</literal> bir modülün hangi isimleri
        tanımladığını bulmak içik kullanılır. Bu işlev dizgelerden oluşan bir
        liste geri döndürür:
</para>
   <para>
    <screen>
&gt;&gt;&gt; import fibo, sys
&gt;&gt;&gt; dir(fibo)
['__name__', 'fib', 'fib2']
&gt;&gt;&gt; dir(sys)
['__displayhook__', '__doc__', '__excepthook__', '__name__', '__stderr__',
 '__stdin__', '__stdout__', '_getframe', 'argv', 'builtin_module_names',
 'byteorder', 'copyright', 'displayhook', 'exc_info', 'exc_type',
 'excepthook', 'exec_prefix', 'executable', 'exit', 'getdefaultencoding',
 'getdlopenflags', 'getrecursionlimit', 'getrefcount', 'hexversion',
 'maxint', 'maxunicode', 'modules', 'path', 'platform', 'prefix', 'ps1',
 'ps2', 'setcheckinterval', 'setdlopenflags', 'setprofile',
 'setrecursionlimit', 'settrace', 'stderr', 'stdin', 'stdout', 'version',
 'version_info', 'warnoptions']
</screen>
   </para>
   <para>
        Argüman kullanmadan çağırılan <literal>dir()</literal> işlevi o anda
        tanımlamış olduğunuz isimleri geri döndürür:
</para>
   <para>
    <screen>
&gt;&gt;&gt; a = [1, 2, 3, 4, 5]
&gt;&gt;&gt; import fibo, sys
&gt;&gt;&gt; fib = fibo.fib
&gt;&gt;&gt; dir()
['__name__', 'a', 'fib', 'fibo', 'sys']
</screen>
   </para>
   <para>
        Bunun değişken, modül, işlev vs. gibi her tür ismini listelediğine
        dikkat ediniz.
      </para>
   <para><literal>dir()</literal> yerleşik işlev ve değişkenlerin isimlerini
        listelemez. Bunların bir listesini isterseniz, standart modül
        <literal>__builtin__</literal> içinde bulabilirsiniz:
</para>
   <para>
    <screen>
&gt;&gt;&gt; import __builtin__
&gt;&gt;&gt; dir(__builtin__)
['ArithmeticError', 'AssertionError', 'AttributeError',
 'DeprecationWarning', 'EOFError', 'Ellipsis', 'EnvironmentError',
 'Exception', 'False', 'FloatingPointError', 'IOError', 'ImportError',
 'IndentationError', 'IndexError', 'KeyError', 'KeyboardInterrupt',
 'LookupError', 'MemoryError', 'NameError', 'None', 'NotImplemented',
 'NotImplementedError', 'OSError', 'OverflowError', 'OverflowWarning',
 'PendingDeprecationWarning', 'ReferenceError',
 'RuntimeError', 'RuntimeWarning', 'StandardError', 'StopIteration',
 'SyntaxError', 'SyntaxWarning', 'SystemError', 'SystemExit', 'TabError',
 'True', 'TypeError', 'UnboundLocalError', 'UnicodeError', 'UserWarning',
 'ValueError', 'Warning', 'ZeroDivisionError', '__debug__', '__doc__',
 '__import__', '__name__', 'abs', 'apply', 'bool', 'buffer',
 'callable', 'chr', 'classmethod', 'cmp', 'coerce', 'compile', 'complex',
 'copyright', 'credits', 'delattr', 'dict', 'dir', 'divmod',
 'enumerate', 'eval', 'execfile', 'exit', 'file', 'filter', 'float',
 'getattr', 'globals', 'hasattr', 'hash', 'help', 'hex', 'id',
 'input', 'int', 'intern', 'isinstance', 'issubclass', 'iter',
 'len', 'license', 'list', 'locals', 'long', 'map', 'max', 'min',
 'object', 'oct', 'open', 'ord', 'pow', 'property', 'quit',
 'range', 'raw_input', 'reduce', 'reload', 'repr', 'round',
 'setattr', 'slice', 'staticmethod', 'str', 'string', 'super',
 'tuple', 'type', 'unichr', 'unicode', 'vars', 'xrange', 'zip']
</screen>
   </para>
  </section>
  <section xml:id="python-tutorial_paketler">
   <info>
    <title>Paketler</title>
   </info>
   <para>
        Paketler "noktalı modül isimleri" kullanarak Python'un modül isim
        alanının düzenlenmesinde kullanılırlar. Örneğin modül adı
        <literal>A.B</literal> adı <literal>A</literal> olan bir paket
        içindeki <literal>B</literal> adlı alt modülü gösterir. Nasıl modüller
        farklı modül yazarlarını birbirlerinin kullandığı global değişkenleri
        dert etmekten kurtarıyorsa, paketler de <literal>NumPy</literal> ya da
        <literal>PyOpenGL</literal> gibi çok sayıda modül içeren paketlerin
        birbirlerinin modül isimlerinin çakışması tehlikesinden kurtarır.
      </para>
   <para>
        Ses dosyaları ve ses verisi üzerinde işlem yapacak bir modül kolleksiyonu
        (bir "paket") geliştirmek istediğinizi düşünelim. Farklı biçemlerdeki ses
        dosyalarını (<literal>.wav</literal>, <literal>.aiff</literal>,
        <literal>.au</literal> gibi dosya uzantıları olan) birbirine dönüştürmek,
        seslere efektler uygulamak veya sesleri filtrelemek için pek çok modüle
        ihtiyacınız olacak. Paketinizin muhtemel dizin yapısı şöyle olabilir:
</para>
   <para>
    <screen>
Sound/                          Paketin en üst seviyesi
      __init__.py               paketi ilk kullanıma hazırlama
      Formats/                  Farklı dosya biçemleri için alt paket
              __init__.py
              wavread.py
              wavwrite.py
              aiffread.py
              aiffwrite.py
              auread.py
              auwrite.py
              ...
      Effects/                  ses efektleri alt paketi
              __init__.py
              echo.py
              surround.py
              reverse.py
              ...
      Filters/                  filtre alt paketi
              __init__.py
              equalizer.py
              vocoder.py
              karaoke.py
              ...
</screen>
   </para>
   <para><literal>__init__.py</literal> dosyaları Python'un bu dizinleri paket
        içeren dizinler olarak algılaması için gereklidirler. Bunlar aynı isimli
        dizinlerin modül arama yolunda bulunacak diğer geçerli modülleri istemdışı
        saklamasını engeller. <literal>__init__.py</literal> boş bir dosya
        olabileceği gibi paketi ilk çalışmaya hazırlayabilir ya da daha sonra
        açıklanacak olan <literal>__all__</literal> değişkenine değer atıyor olabilir.
      </para>
   <para>
        Paketin kullanıcısı paketten dilediği bir modülü yükleyebilir.
</para>
   <para>
    <screen>
import Sound.Effects.echo
</screen>
   </para>
   <para>
        Bu <literal>Sound.Effects.echo</literal> modülünü yükler. Modüle tüm
        ismi ile atıfta bulunulmalı:
</para>
   <para>
    <screen>
Sound.Effects.echo.echofilter(input, output, delay=0.7, atten=4)
</screen>
   </para>
   <para>
        Aynı modülü yüklemenin bir diğer yolu:
</para>
   <para>
    <screen>
from Sound.Effects import echo
</screen>
   </para>
   <para>
        Bu da <literal>echo</literal> alt modülünü yükler; ancak bunu paket adı
        verilmeden erişilebilir kılar ve modül şu şekilde kullanılabilir:
</para>
   <para>
    <screen>
echo.echofilter(input, output, delay=0.7, atten=4)
</screen>
   </para>
   <para>
        Bir diğer yol da istenen işlev ya da değişkeni doğrudan yüklemektir:
</para>
   <para>
    <screen>
from Sound.Effects.echo import echofilter
</screen>
   </para>
   <para>
        Bu da <literal>echo</literal> modülünü yükler; ancak
        <literal>echofilter()</literal> işlevini doğrudan erişilebilir kılar:
</para>
   <para>
    <screen>
echofilter(input, output, delay=0.7, atten=4)
</screen>
   </para>
   <para><literal>from PAKET import İSİM</literal> kullanılırken İSİM bir alt
        modül, alt paket ya da paket içinde tanımlı bir işlev, sınıf veya
        değişken ifade eden herhangi bir isim olabilir. <literal>import</literal>
        deyimi önce ismin pakette tanımlı olup olmadığına bakar; tanımlı değil
        ise bunun bir modül olduğunu varsayar ve bunu yüklemeye teşebbüs eder.
        Modülü bulamaz ise <literal>ImportError</literal> istisnası oluşur.
      </para>
   <para><literal>import ÖĞE.ALTÖĞE.ALTALTÖĞE</literal> ifadesinde ise son
        ismin dışındaki isimler paket olmalıdır. Son isim bir modül veya paket
        olabilir; ancak bir önceki ismin içinde tanımlanan bir işlev ya da
        değişken olamaz.
      </para>
   <section>
    <info>
     <title>Bir paketten * yüklemek</title>
    </info>
    <para>
          Kullanıcı <literal>from Sound.Effects import *</literal> yazdığında ne olur?
          Dosya sistemine ulaşılıp paketin içinde hangi alt paketlerin olduğunun
          bulunması ve hepsinin yüklenmesi beklenir. Ne yazık ki bu işlem küçük/büyük
          harf ayrımının olmadığı Windows ve Mac işletim sistemlerinde pek iyi çalışmaz.
          Bu işletim sistemlerinde <literal>ECHO.PY</literal> gibi bir dosyanın
          <literal>echo</literal>, <literal>Echo</literal> veya <literal>ECHO</literal>
          isimlerinden hangisi ile yüklenmesi gerektiğini belirlemenin garantili bir
          yolu yoktur. Örneğin, Windows 95 dosya adlarının ilk harfini daima büyük harf
          ile gösterir. DOS'un 8+3 harflik dosya adı uzunluğu kısıtlaması da uzun modül
          isimleri için sorun olmaktadır.
        </para>
    <para>
          Tek çözüm paket yazarının açık bir paket indeksi hazırlamasıdır. Bir
          paketin <literal>__init__.py</literal> dosyası <literal>__all__</literal>
          adlı bir liste tanımlıyorsa bu liste <literal>from PAKET import *</literal>
          ifadesi kullanıldığında yüklenecek modül isimlerinin listesi olarak kullanılır.
          Paketin yeni bir sürümü hazırlandığında bu listenin uygun şekilde
          güncellenmesi paket yazarının sorumluğundadır. Eğer paketten <literal>*</literal>
          yüklemeye ihtiyaç duyulmayacağına karar verilirse bu özellik kullanılmayabilir.
          Örneğin <literal>Sounds/Effects/__init__.py</literal> dosyasının içeriği
          şöyle olabilir:
</para>
    <para>
     <screen>
__all__ = ["echo", "surround", "reverse"]
</screen>
    </para>
    <para>
          Bu <literal>from Sound.Effects import *</literal> ifadesinin <literal>Sound</literal>
          paketinden isimleri <literal>__all__</literal> içinde geçen üç modülün
          yüklemesini sağlar.
        </para>
    <para><literal>__all__</literal> tanımlanmamış ise
          <literal>from Sound.Effects import *</literal> ifadesi <literal>Sound.Effects</literal>
          paketindeki bütün alt modülleri yürürlükte olan isim alanına yüklemez;
          sadece <literal>Sound.Effects</literal> paketinin ve içindeki isimlerin
          yüklenmesini sağlar (muhtemelen <literal>__init__.py</literal>) dosyasını
          çalıştırdıktan sonra). Bundan önceki <literal>import</literal> deyimlerince
          yüklenen alt paketler de yüklenir. Şu koda bir bakalım:
</para>
    <para>
     <screen>
import Sound.Effects.echo
import Sound.Effects.surround
from Sound.Effects import *
</screen>
    </para>
    <para>
          Bu örnekte <literal>echo</literal> ve <literal>surround</literal>
          modülleri <literal>from...import...</literal> ifadesi çalıştırıldığında
          <literal>Sound.Effects</literal> paketinde tanımlı oldukları için
          yürürlükte olan isim alanına yüklenirler. Bu <literal>__all__</literal>
          tanımlı olduğunda da bu çalışır.
        </para>
    <para>
          Genel olarak bir modül ya da paketten <literal>*</literal> yüklemek
          hoş karşılanmaz; çünkü çoğunlukla zor okunan koda neden olur. Bunun
          etkileşimli kipte kullanılmasının bir sakıncası yoktur. Ayrıca bazı
          modüller sadece belirli bir kalıba uyan isimleri verecek şekilde
          tasarlanmışlardır.
        </para>
    <para><literal>from PAKET import GEREKLİ_ALTMODÜL</literal> ifadesini
          kullanmanın hiç bir kötü tarafı yoktur. Yükleyen modül farklı
          paketlerden aynı isimli modüller yüklemeye gereksinim duymadığı
          sürece tavsiye edilen kullanım şekli de budur.
        </para>
   </section>
   <section>
    <info>
     <title>Birbirlerini Yükleyen Modüller</title>
    </info>
    <para>
          Alt modüller çoğu kez birbirlerine atıfta bulunurlar. Örneğin
          surround modülü echo modülüne ihtiyaç duyabilir. Aslında bu
          türden atıflar öyle yaygındır ki <literal>import</literal>
          deyimi standart modül arama yoluna bakmadan önce çağrıldığı
          paketin içinde arama yapar. Bu şekilde surround modülü
          <literal>import echo</literal> veya
          <literal>from echo import echofilter</literal> ifadeleri ile
          kolayca echo modülüne kavuşabilir. Yüklenmek istenen modül içinde
          bulunan pakette (yükleme yapmaya çalışan modülün bulunduğu paket)
          bulunamaz ise <literal>import</literal> deyimi aynı isimli üst
          seviyeli bir modül arar.
        </para>
    <para>
          Paketler Sound paketindeki gibi alt paketler şeklinde düzenlenmişler
          ise farklı alt paketler içindeki modüllerin birbirilerine atıfta
          bulunmasının kısa bir yolu yoktur; paketin tam adı kullanılmalıdır.
          Örneğin, Sound.Filters.vocoder modülünün echo modülünü kullanması
          gerekiyor ise <literal>from Sound.Effects import echo</literal>
          ifadesi ile buna erişebilir.
        </para>
   </section>
  </section>
 </chapter>
 <chapter xml:id="python-tutorial_io">
  <info>
   <title>Giriş ve Çıkış</title>
  </info>
  <para>
      Bir programın çıktısını sunmanın birkaç yolu vardır; veri yazdırılabilir
      ya da gelecekte kullanılabilecek şekilde bir dosyaya kaydedilebilir.
      Bu bölümde giriş ve çıkış ile ilgili olanakların bazılarına değineceğiz.
    </para>
  <section xml:id="python-tutorial_write">
   <info>
    <title>Daha Güzel Çıkış Biçemi</title>
   </info>
   <para>
        Buraya kadar değerleri yazdırmanın iki yolunu gördük: deyim ifadeleri ve
        print deyimi. Üçüncü bir yol da dosya nesnelerinin <literal>write()</literal>
        yöntemidir. Standart çıktıya <literal>sys.stdout</literal> şeklinde atıfta
        bulunulabilir.
      </para>
   <para>
        Çoğu zaman boşluklar ile birbirinden ayrılmış değerlerden daha iyi
        biçimlendirilimiş bir çıktıya ihtiyaç duyulur. Çıktınızı biçimlendirmenin
        iki yolu var. İlki bütün dizge işlemlerini dilimleme ve birleştirme ile
        yapıp istediğiniz herhangi bir biçimi elde etmek. <literal>string</literal>
        standart modülü dizgelerin istenen sütun genişliğine kadar
        boşluklar ile doldurulmasını sağlayan, daha sonra değineceğimiz, bazı
        faydalı işlevlere sahiptir. İkinci yol ise sol argümanı bir dizge olan
        <literal>%</literal> işlecini kullanmaktır. <literal>%</literal> işleci
        sol argümanını sağdaki argümanına uygulanacak <literal>sprintf()</literal>
        tarzı biçim dizgesi olarak yorumlar ve biçimleme işleminden sonra bir
        dizge geri döndürür.
      </para>
   <para>
        Sayısal değerleri dizgeye çevirmek için ise değer <literal>repr()</literal>
        veya <literal>str()</literal> işlevine geçirilebilir ya da ters tırnak işareti
        (<userinput>``</userinput>) içine alınabilir (<literal>repr()</literal> ile
        aynı etkiye sahiptir).
      </para>
   <para><literal>str()</literal> işlevi değerlerin insan tarafından okunabilir
        gösterimini geri döndürürken, <literal>repr()</literal> işlevi yorumlayıcı
        tarafından okunabilir gösterimini geri döndürür (veya uygun sözdizim yok
        ise <literal>SyntaxError</literal> istisnası oluşturur). İnsan için anlam
        ifade edecek bir gösterimi bulunmayan nesneler için <literal>str()</literal>
        işlevi <literal>repr()</literal> ile aynı değeri döndürür. Rakamlar, listeler
        ve sözlükler gibi yapılar ile daha pek çok değer için her iki işlev de aynı
        sonucu verir. Dizgeler ve gerçel sayılar ise iki farklı gösterime sahiptir.
      </para>
   <para>
        İşte birkaç örnek:
</para>
   <para>
    <screen>
&gt;&gt;&gt; s = 'Hello, world.'
&gt;&gt;&gt; str(s)
'Hello, world.'
&gt;&gt;&gt; `s`
"'Hello, world.'"
&gt;&gt;&gt; str(0.1)
'0.1'
&gt;&gt;&gt; `0.1`
'0.10000000000000001'
&gt;&gt;&gt; x = 10 * 3.25
&gt;&gt;&gt; y = 200 * 200
&gt;&gt;&gt; s = 'The value of x is ' + `x` + ', and y is ' + `y` + '...'
&gt;&gt;&gt; print s
The value of x is 32.5, and y is 40000...
&gt;&gt;&gt; # Ters tırnaklar sayılar dışındaki tipler ile de çalışır:
... p = [x, y]
&gt;&gt;&gt; ps = repr(p)
&gt;&gt;&gt; ps
'[32.5, 40000]'
&gt;&gt;&gt; # Karakter dizisinde ise tırnaklar ve ters bölü işareti eklenir:
... hello = 'hello, world\n'
&gt;&gt;&gt; hellos = `hello`
&gt;&gt;&gt; print hellos
'hello, world\n'
&gt;&gt;&gt; # Ters tırnakların argümanı bir demet de olabilir:
... `x, y, ('spam', 'eggs')`
"(32.5, 40000, ('spam', 'eggs'))"
</screen>
   </para>
   <para>
        Sayıların kare ve küplerinden oluşan bir tablo yazdırmanın iki yolu
        vardır:
</para>
   <para>
    <screen>
&gt;&gt;&gt; import string
&gt;&gt;&gt; for x in range(1, 11):
...     print string.rjust(`x`, 2), string.rjust(`x*x`, 3),
...     # Üst satırın sonundaki virgüle dikkat edin.
...     print string.rjust(`x*x*x`, 4)
...
 1   1    1
 2   4    8
 3   9   27
 4  16   64
 5  25  125
 6  36  216
 7  49  343
 8  64  512
 9  81  729
10 100 1000
&gt;&gt;&gt; for x in range(1,11):
...     print '%2d %3d %4d' % (x, x*x, x*x*x)
...
 1   1    1
 2   4    8
 3   9   27
 4  16   64
 5  25  125
 6  36  216
 7  49  343
 8  64  512
 9  81  729
10 100 1000
</screen>
   </para>
   <para>
        Sütunların arasındaki bir karakterlik boşluk <literal>print</literal>
        tarafından eklenir; argümanların arasına daima bir boşluk karakteri
        eklenir.
      </para>
   <para>
        Bu örnek dizgelerin başını boşluklar ile doldurup bunları sağ tarafa
        dayayan <literal>string.rjust()</literal> işlevini kullanmaktadır.
        Buna benzer <literal>string.ljust()</literal> ve
        <literal>string.center()</literal> işlevleri de vardır. Bunlar bir şey
        yazdırmaz; sadece yeni bir dizge geri döndürürler. Verilen
        dizge uzun ise kırpılmaz ve aynen geri döndürülür; bu
        sütunlarınızın bozulmasına sebep olmasına rağmen hatalı bir değer
        göstermekten iyidir. Büyük bir değeri kırpmayı gerçekten istiyorsanız
        dilimleme ile bunu yapabilirsiniz (<literal>string.ljust(x, n)[0:n]</literal>
        gibi).
      </para>
   <para><literal>string.zfill()</literal> işlevi ise rakamlar içeren dizgelerin
        başını sıfırlar ile doldurur. Bu işlev artı ve eksi işaretlerini de
        dikkate alır:
</para>
   <para>
    <screen>
&gt;&gt;&gt; import string
&gt;&gt;&gt; string.zfill('12', 5)
'00012'
&gt;&gt;&gt; string.zfill('-3.14', 7)
'-003.14'
&gt;&gt;&gt; string.zfill('3.14159265359', 5)
'3.14159265359'
</screen>
   </para>
   <para><literal>%</literal> işleçi şu şekilde kullanılır:
</para>
   <para>
    <screen>
&gt;&gt;&gt; import math
&gt;&gt;&gt; print 'PI sayısının yaklaşık değeri: %5.3f' % math.pi
PI sayısının yaklaşık değeri: 3.142
</screen>
   </para>
   <para>
        Dizgenin içinde birden fazla biçem varsa sağ terim olarak bir demet
        kullanmak gerekir:
</para>
   <para>
    <screen>
&gt;&gt;&gt; table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 7678}
&gt;&gt;&gt; for name, phone in table.items():
...     print '%-10s ==&gt; %10d' % (name, phone)
...
Jack       ==&gt;       4098
Dcab       ==&gt;       7678
Sjoerd     ==&gt;       4127
</screen>
   </para>
   <para>
        Çoğu biçim aynı C dilindeki gibi çalışır ve doğru veri türünün
        geçirilmesi gerekir; bu yapılamaz ise bir istisna oluşur.
        <literal>%s</literal> biçiminin kullanımı daha rahattır; verilen
        argüman dizge değilse yerleşik işlev <literal>str()</literal> ile
        dizgeye dönüştürülür. Genişlik ya da hassasiyeti belirtmek için
        <literal>*</literal> ile bir tamsayı argüman kullanılabilir. C dilindeki
        <literal>%n</literal> ve <literal>%p</literal> biçimler ise
        desteklenmemektedir.
      </para>
   <para>
        Eğer bölmek istemediğiniz gerçekten uzun bir biçim dizgeniz varsa
        biçimlendirmek istediğiniz argümanlara konumu yerine ismiyle atıfta
        bulunabilmeniz güzel olur. Bu aşağıda gösterildiği gibi
        <literal>%(isim)biçim</literal> şeklinde yapılabilir:
</para>
   <para>
    <screen>
&gt;&gt;&gt; table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 8637678}
&gt;&gt;&gt; print 'Jack: %(Jack)d; Sjoerd: %(Sjoerd)d; Dcab: %(Dcab)d' % table
Jack: 4098; Sjoerd: 4127; Dcab: 8637678
</screen>
   </para>
   <para>
        Bu özellik bütün yerel değişkenlerin bulunduğu bir sözlük geri döndüren
        yerleşik işlev <literal>vars()</literal> ile beraber kullanıldığında
        faydalı olur.
      </para>
  </section>
  <section xml:id="python-tutorial_dosyalar">
   <info>
    <title>Dosya Okuma ve Yazma</title>
   </info>
   <para><literal>open()</literal> işlevi bir dosya nesnesi geri döndürür ve
        genellikle iki argüman ile kullanılır: <literal>open(dosya_adı, kip)</literal>
      </para>
   <para>
    <screen>
&gt;&gt;&gt; f=open('/tmp/workfile', 'w')
&gt;&gt;&gt; print f
&lt;open file '/tmp/workfile', mode 'w' at 80a0960&gt;
</screen>
   </para>
   <para>
        İlk argüman dosya adını içeren bir dizgedir. İkincisi ise dosyanın
        nasıl kullanılacağını belirten karakterlerden oluşur. Erişim kipi
        dosyadan sadece okuma yapılacak ise <literal>'r'</literal>, sadece yazma
        için <literal>'w'</literal> (aynı isimli bir dosya zaten var ise üzerine
        yazılır) ve dosyanın sonuna eklemeler yapmak için <literal>'a'</literal>
        olur. <literal>'r+'</literal> kipi dosyayı hem okuma hem de yazma yapmak
        için açar. <literal>kip</literal> argümanı seçimliktir; kullanılamaması
        halinde <literal>'r'</literal> olduğu varsayılır.
      </para>
   <para>
        Windows ve Macintosh üzerinde kipe eklenen <literal>'b'</literal> harfi
        dosyayı ikilik kipte açar; yani <literal>'rb'</literal>,
        <literal>'wb'</literal> ve <literal>'r+b'</literal> gibi kipler de vardır.
        Windows metin ve ikilik dosyaları arasında ayrım yapmaktadır; metin
        dosyalarında okuma veya yazma işlemlerinde satır sonu karakterleri otomatik
        olarak biraz değişir. Bu görünmez değişiklik ASCII metin dosyaları için
        iyidir; anacak JPEG resimler veya .EXE dosyalar gibi iklik verileri bozar.
      </para>
   <section>
    <info>
     <title>Dosya Nesnelerinin Yöntemleri</title>
    </info>
    <para>
          Bundan sonraki örneklerde <literal>f</literal> adlı bir dosya nesnesinin
          önceden oluşturulmuş olduğunu varsayacağız.
        </para>
    <para>
          Dosyanın içeriğini okumak için belirli miktarda veriyi okuyup bunu
          dizge olarak geri döndüren <literal>f.read(boy)</literal>yöntemi
          kullanılabilir. <literal>boy</literal> okunacak bayt sayısını
          belirleyen seçimlik bir argümandır; kullanılmaması halinde dosyanın
          tamamı okunur. Dosyanın sonuna gelindiğinde <literal>f.read()</literal>
          boş bir dizge ("") geri döndürür.
</para>
    <para>
     <screen>
&gt;&gt;&gt; f.read()
'Dosyanın tamamı bu satırdan oluşuyor.\n'
&gt;&gt;&gt; f.read()
''
</screen>
    </para>
    <para><literal>f.readline()</literal> dosyadan tek bir satır okur. Satırın
          sonundaki satırsonu karakteri (<literal>\n</literal>) korunur; ancak
          dosya bir satırsonu karakteri ile bitmiyor ise son satırda bu karakter
          silinir. Bu özellik geri döndürülen değerin birden fazla anlama gelmesini
          engeller; <literal>f.readline()</literal> boş bir dizge geri
          döndürdüğünde dosyanın sonuna ulaşılırken boş bir satır tek bir
          <literal>'\n'</literal> karakteri ile ifade edilir.
</para>
    <para>
     <screen>
&gt;&gt;&gt; f.readline()
'Bu dosyanın ilk satırı.\n'
&gt;&gt;&gt; f.readline()
'Dosyanın ikinci satırı\n'
&gt;&gt;&gt; f.readline()
''
</screen>
    </para>
    <para><literal>f.readlines()</literal> dosya içindeki bütün satırların
          bulunduğu bir liste geri döndürür. Seçimlik parametre
          <literal>boy_ipucu</literal> kullanılması durumunda ise dosyadan
          <literal>boy_ipucu</literal> kadar ve bundan bir satır tamamlamaya
          yetecek kadar fazla bayt okunur ve bunlar yine satırlar listesi
          şeklinde geri döndürülür.
</para>
    <para>
     <screen>
&gt;&gt;&gt; f.readlines()
['Bu dosyanın ilk satırı.\n', 'Dosyanın ikinci satırı\n']
</screen>
    </para>
    <para><literal>f.write(dizge)</literal> yöntemi <literal>dizge</literal>
          içeriğini dosyaya yazar ve <literal>None</literal> geri döndürür.
</para>
    <para>
     <screen>
&gt;&gt;&gt; f.write('Bu bir deneme satırıdır.\n')
</screen>
    </para>
    <para><literal>f.tell()</literal> dosya nesnesinin dosya içindeki konumunu
          belirten bir tamsayı geri döndürür (dosyanın başından bayt cinsinden
          ölçülür). <literal>f.seek(uzaklık, nereden)</literal> ile de dosyanın
          içinde istenen konuma gidilebilir. Konum, <literal>uzaklık</literal>
          ile başvuru noktası <literal>nereden</literal> değerlerinin toplanması
          ile bulunur. <literal>nereden</literal> 0 olursa dosyanın başını,
          1 o andaki konumu, 2 ise dosyanın sonunu belirtir. <literal>nereden</literal>
          kullanılmaz ise 0 olduğu varsayılır ve başvuru noktası olarak dosyanın
          başı alınır.
</para>
    <para>
     <screen>
&gt;&gt;&gt; f=open('/tmp/workfile', 'r+')
&gt;&gt;&gt; f.write('0123456789abcdef')
&gt;&gt;&gt; f.seek(5)     # Dosyadaki 5'inci bayta git
&gt;&gt;&gt; f.read(1)
'5'
&gt;&gt;&gt; f.seek(-3, 2) # Sondan 3'üncü bayta git
&gt;&gt;&gt; f.read(1)
'd'
</screen>
    </para>
    <para>
          Dosya ile işiniz bittiğinde <literal>f.close()</literal> yöntemini
          çağırarak dosyayı kapatabilir ve dosyanın işgal ettiği sistem
          kaynaklarını serbest bırakabilirsiziz. <literal>f.close()</literal>
          çağrıldıktan sonra dosya üzerinde başka işlem yapmaya devam etmek
          mümkün değildir:
</para>
    <para>
     <screen>
&gt;&gt;&gt; f.close()
&gt;&gt;&gt; f.read()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
ValueError: I/O operation on closed file
</screen>
    </para>
    <para>
          Dosya nesnelerinin <literal>isatty()</literal> ve
          <literal>truncate()</literal> gibi pek sık kullanılmayan başka
          yöntemleri de vardır.
        </para>
   </section>
   <section>
    <info>
     <title><literal>pickle</literal> Modülü</title>
    </info>
    <para>
          Dizgeler kolayca dosyalara yazılıp dosyalardan okunabilirler. Sayılar biraz
          zahmetlidir; çünkü <literal>read()</literal> yöntemi sadece dizgeleri geri
          döndürür ve bunların '123' gibi bir değeri alıp sayısal değeri 123'ü geri
          döndüren <literal>string.atoi()</literal> işlevinden geçirilmeleri gerekir.
          Listeler, sözlükler ve sınıf gerçeklemeleri (class instances) gibi daha
          karmaşık veri türlerini dosyalara kaydetmek isterseniz işler oldukça zorlaşır.
        </para>
    <para>
          Programcıları karmaşık veri türlerini saklamak için kodlamak ve hata
          ayıklamak ile uğraştırmak yerine Python bu iş için <literal>pickle</literal>
          adlı standart modülü sağlar. Bu hayret verici modül neredeyse herhangi
          bir Python nesnesini (bazı Python kodu biçimlerini bile!) dizge ile ifade
          edilebilecek hale getirebilir ve bu halinden geri alabilir. Bu dönüşüm ve
          geri kazanım işlemleri arasında nesne bir dosyaya kaydedilebilir ya da ağ
          bağlantısı ile uzaktaki başka bir makineye gönderilebilir.
        </para>
    <para><literal>x</literal> gibi bir nesneniz ve yazma işlemi için açılmış
          <literal>f</literal> gibi bir dosya nesneniz varsa bu nesneyi dosyaya
          aktarmanız için tek satırlık kod yeterli olur:
</para>
    <para>
     <screen>
pickle.dump(x, f)
</screen>
    </para>
    <para>
          Nesneyi geri almak için ise <literal>f</literal> okumak için açılmış
          bir dosya nesnesi olsun:
</para>
    <para>
     <screen>
x = pickle.load(f)
</screen>
    </para>
    <para>
          Birden fazla nesnenin dönüştürülmesi gerekiyor ya da dönüştürülmüş
          olan nesnelerin dosyaya yazılması istenmiyor ise <literal>pickle</literal>
          farklı şekilde kullanılır. Bunları <literal>pickle</literal> modülünün
          belgelerinden öğrenmek mümkündür.
        </para>
    <para><literal>pickle</literal> modülü saklanabilen ve başka programlar
          tarafından ya da aynı programın farklı çalışma zamanlarında
          kullanılabilecek Python nesneleri yapmanın standart yoludur.
          <literal>pickle</literal> modülü çok yaygın kullanıldığından Python
          genişletme modülleri yazan çoğu programcı matrisler gibi yeni veri
          türlerinin doğru olarak dönüştürülebilir ve geri alınabilir olmasına
          özen gösterirler.
        </para>
   </section>
  </section>
 </chapter>
 <chapter xml:id="python-tutorial_hatalar">
  <info>
   <title>Hatalar ve İstisnalar</title>
  </info>
  <para>
      Şu ana kadar hata mesajlarından pek bahsedilmedi; ancak örnekleri
      denediyseniz muhtemelen birkaç tane görmüşsünüzdür. Birbirinden ayırt
      edilebilen en az iki tür hata mevcuttur: sözdizim hataları ve istisnalar.
    </para>
  <section xml:id="python-tutorial_sozdizimi">
   <info>
    <title>Sözdizim Hataları</title>
   </info>
   <para>
        Sözdizim hataları ayrıştırma (parsing) hataları olarak da bilinirler
        ve Python öğrenirken en çok bunlar ile karşılaşırsınız:
</para>
   <para>
    <screen>
&gt;&gt;&gt; while 1 print 'Merhaba'
  File "&lt;stdin&gt;", line 1, in ?
    while 1 print 'Merhaba'
                ^
SyntaxError: invalid syntax
</screen>
   </para>
   <para>
        Ayrıştırıcı sorun olan satırı basar ve satır içinde hatanın algılandığı
        ilk noktayı küçük bir `ok' ile gösterir. Hata oktan önce gelen kısımdan
        kaynaklanmaktadır. Örnekte hata <literal>print</literal> anahtar
        kelimesinde fark edilmektedir; çünkü ondan önce bir iki nokta üst üste
        (":") karakteri eksiktir. Dosya adı ve satır numarası da yazdırılmaktadır
        ki yorumlayıcı girişinin bir dosyadan gelmesi durumunda hatanın nereden
        kaynaklandığını bilesiniz.
      </para>
  </section>
  <section xml:id="python-tutorial_istisnalar">
   <info>
    <title>İstisnalar</title>
   </info>
   <para>
        Bir deyim ya da ifade sözdizimsel olarak doğru olsa da yürütülmek istendiğinde
        bir hataya sebep olabilir. İcra sırasında meydana gelen hatalara istisna denir.
        İstisnaları nasıl ele alabileceğinizi yakında öğreneceksiniz. Çoğu istisnalar
        programlar tarafından ele alınmaz ve aşağıdakiler gibi hata mesajları ile
        sonuçlanırlar:
</para>
   <para>
    <screen>
&gt;&gt;&gt; 10 * (1/0)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
ZeroDivisionError: integer division or modulo
&gt;&gt;&gt; 4 + spam*3
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
NameError: spam
&gt;&gt;&gt; '2' + 2
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
TypeError: illegal argument type for built-in operation
</screen>
   </para>
   <para>
        Hata mesajının son satırı sorunun ne olduğunu belirtir. İstisnaların
        farklı türleri vardır ve istisnanın türü hata mesajının bir bölümü olarak
        yazdırılır. Örneklerdeki istisna türleri: <literal>ZeroDivisionError</literal>,
        <literal>NameError</literal> ve <literal>TypeError</literal>. İstisna türü
        olarak yazdırılan dizge meydana gelen istisnanın yerleşik ismidir.
        Bu bütün yerleşik istisnalar için geçerlidir; ancak kullanıcı tanımlı
        istisnalar için böyle olmayabilir. Standart istisna isimleri yerleşik
        belirteçlerdir; ayrılmış anahtar kelimeler değil.
      </para>
   <para>
        Satırın devamı istisna türüne bağlı ayrıntılardan oluşur ve anlamı
        istisna türüne bağlıdır.
      </para>
   <para>
        Hata mesajının baş kısmında istisnanın meydana geldiği yer yığın dökümü
        şeklinde görülür. Bu genellikle istisnanın gerçekleştiği noktaya gelene
        kadar işletilen kaynak kodu şeklinde olur; ancak standart girdiden
        okunan satırlar gösterilmez.
      </para>
   <para>
        Yerleşik istisnalar ve bunların anlamları için Python ile gelen
        belgelerden yararlanılabilir.
      </para>
  </section>
  <section xml:id="python-tutorial_istisnalar-daha">
   <info>
    <title>İstisnaların Ele Alınması</title>
   </info>
   <para>
        Belirli istisnaları ele alan programlar yazmak mümkündür. Aşağıdaki örnek,
        kullanıcıdan geçerli bir tamsayı girilene kadar kullanıcıdan giriş yapması
        istenir. Control-C tuş kombinasyonu (ya da işletim sisteminin desteklediği
        başka bir kombinasyon) ile kullanıcı programdan çıkabilir. Kullanıcın sebep
        olduğu bu olay ise <literal>KeyboardInterrupt</literal> istisnasının
        oluşmasına neden olur.
</para>
   <para>
    <screen>
&gt;&gt;&gt; while True:
...     try:
...         x = int(raw_input("Lütfen bir rakam giriniz: "))
...         break
...     except ValueError:
...         print "Bu geçerli bir giriş değil.  Tekrar deneyin..."
...
</screen>
   </para>
   <para><literal>try</literal> deyimi aşağıdaki gibi çalışır:
      </para>
   <para>
    <itemizedlist>
     <listitem>
      <para>
              Önce <literal>try</literal> bloğu (<literal>try</literal> ve
              <literal>except</literal> arasındaki ifade(ler)) işletilir.
            </para>
     </listitem>
     <listitem>
      <para>
              Hiçbir istisna oluşmaz ise <literal>except</literal> bloğu atlanır
              ve <literal>try</literal> deyimin icrası son bulur.
            </para>
     </listitem>
     <listitem>
      <para>
              Eğer <literal>try</literal> bloğu içinde bir istisna oluşur ise
              bloğun geri kalanı atlanır. İstisnanın türü <literal>except</literal>
              anahtar kelimesinden sonra kullanılan ile aynı ise <literal>try</literal>
              bloğunun kalan kısmı atlanır ve <literal>except</literal> bloğu
              yürütülür. Programın akışı <literal>try ... except</literal> kısmından
              sonra gelen ilk satırdan devam eder.
            </para>
     </listitem>
     <listitem>
      <para>
              Adı <literal>except</literal> bloğunda geçmeyen bir istisna oluşur
              ise üst seviyedeki <literal>try</literal> ifadelerine geçirilir; ancak
              bunu ele alan bir şey bulunmaz ise bu bir ele alınmamış istisna olur ve
              yürütme işlemi yukarıda da görüldüğü gibi bir hata mesajı ile son bulur.
            </para>
     </listitem>
    </itemizedlist>
   </para>
   <para>
        Bir <literal>try</literal> deyimi farklı istisnaları yakalayabilmek için
        birden fazla <literal>except</literal> bloğuna sahip olabilir. Bir
        <literal>except</literal> bloğu parantez içine alınmış bir liste ile birden
        fazla istisna adı belirtebilir. Örnek:
</para>
   <para>
    <screen>
... except (RuntimeError, TypeError, NameError):
...     pass
</screen>
   </para>
   <para>
        Son <literal>except</literal> bloğu istisna adı belirtilmeden de
        kullanılıp herhangi bir istisnayı yakalayabilir. Bunu çok dikkatli
        kullanın, çünkü çok ciddi bir programlama hatasını bu şekilde gözden
        kaçırabilirsiniz! Bu özellik bir hata mesajı bastırıp ve tekrar bir
        istisna oluşturarak çağıranın istisnayı ele almasını da sağlamak için
        kullanılabilir:
</para>
   <para>
    <screen>
import string, sys

try:
    f = open('myfile.txt')
    s = f.readline()
    i = int(string.strip(s))
except IOError, (errno, strerror):
    print "I/O error(%s): %s" % (errno, strerror)
except ValueError:
    print "Could not convert data to an integer."
except:
    print "Unexpected error:", sys.exc_info()[0]
    raise
</screen>
   </para>
   <para><literal>try ... except</literal> ifadesinin seçimlik <literal>else</literal>
        bloğu da vardır. Bu her <literal>except</literal> bloğunun ardına yazılır ve
        <literal>try</literal> bloğunun istisna oluşturmadığı durumlarda icra
        edilmesi gereken kod bulunduğu zaman kullanılır. Örnek:
</para>
   <para>
    <screen>
for arg in sys.argv[1:]:
    try:
        f = open(arg, 'r')
    except IOError:
        print 'cannot open', arg
    else:
        print arg, 'has', len(f.readlines()), 'lines'
        f.close()
</screen>
   </para>
   <para><literal>else</literal> bloğu kullanmak <literal>try</literal> bloğuna
        ek satırlar eklemekten iyidir çünkü bu <literal>try ... except</literal>
        ifadesi tarafından korunan kodun oluşturmadığı bir istisnanın kazara
        yakalanmasını engeller.
      </para>
   <para>
        Bir istisna meydana geldiğinde istisna argümanı olarak bilinen bir değer
        de bulunabilir. Argümanın varlığı ve türü istisnanın türüne bağlıdır.
        Argümanı olan istisna türleri için <literal>except</literal> bloğunda
        istisna adından (ya da listesinden) sonra argüman değerini alacak bir
        değişken belirtilebilir:
</para>
   <para>
    <screen>
&gt;&gt;&gt; try:
...     spam()
... except NameError, x:
...     print 'name', x, 'undefined'
...
name spam undefined
</screen>
   </para>
   <para>
        Bir istisnanın argümanı var ise ele alınmayan istisna mesajının son
        kısmında (`ayrıntı') basılır.
      </para>
   <para>
        İstisna işleyiciler (exception handlers) sadece <literal>try</literal>
        bloğu içinde meydana gelen istisnaları değil <literal>try</literal>
        bloğundan çağırılan (dolaylı olarak bile olsa) işlevlerdeki istisnaları
        da ele alırlar. Örnek:
</para>
   <para>
    <screen>
&gt;&gt;&gt; def this_fails():
...     x = 1/0
...
&gt;&gt;&gt; try:
...     this_fails()
... except ZeroDivisionError, detail:
...     print 'Handling run-time error:', detail
...
Handling run-time error: integer division or modulo
</screen>
   </para>
  </section>
  <section xml:id="python-tutorial_istisna-olusturma">
   <info>
    <title>İstisna Oluşturma</title>
   </info>
   <para><literal>raise</literal> deyimi programcının kasıtlı olarak bir istisna
        oluşturmasını sağlar. Örnek:
</para>
   <para>
    <screen>
&gt;&gt;&gt; raise NameError, 'Merhaba'
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
NameError: Merhaba
</screen>
   </para>
   <para><literal>raise</literal> için ilk argüman oluşturulacak istisnanın
        adıdır ve ikinci argüman ise istisnanın argümanıdır.
      </para>
   <para>
        Eğer bir istisnanın oluşup oluşmadığını öğrenmek istiyor; fakat bunu ele almak
        istemiyorsanız, <literal>raise</literal> ifadesinin istisnayı tekrar oluşturmanıza
        imkan veren daha basit bir biçimi var:
</para>
   <para>
    <screen>
&gt;&gt;&gt; try:
...     raise NameError, 'Merhaba'
... except NameError:
...     print 'Bir istisna gelip geçti!'
...     raise
...
Bir istisna gelip geçti!
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 2, in ?
NameError: Merhaba
</screen>
   </para>
  </section>
  <section xml:id="python-tutorial_istisna-kull">
   <info>
    <title>Kullanıcı Tanımlı İstisnalar</title>
   </info>
   <para>
        Programlar yeni bir istisna sınıfı yaratarak kendi istisnalarını
        isimlendirebilirler. İstisnalar genellikle, doğrudan veya dolaylı olarak,
        <literal>Exception</literal> sınıfından türetilirler. Örnek:
</para>
   <para>
    <screen>
&gt;&gt;&gt; class bizimHata(Exception):
...     def __init__(self, deger):
...         self.deger = deger
...     def __str__(self):
...         return `self.deger`
...
&gt;&gt;&gt; try:
...     raise bizimHata(2*2)
... except bizimHata, e:
...     print 'İstisnamız oluştu, deger:', e.deger
...
İstisnamız oluştu, deger: 4
&gt;&gt;&gt; raise bizimHata, 'aaah!'
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
__main__.bizimHata: 'aaah!'
</screen>
   </para>
   <para>
        İstisna sınıfları diğer sınıfların yapabildiği her şeyi yapabilecek şekilde
        tanımlanabilirler, fakat genellikle basit tutulurlar ve sıklıkla sadece
        istisnayı işleyenlerin hata hakkında bilgi almasını sağlayacak birkaç
        özellik sunarlar. Birkaç farklı istisna oluşturabilen bir modül yaratırken,
        yaygın bir uygulama da bu modül tarafından tanımlanan istisnalar için bir
        temel sınıf yaratıp ve farklı hata durumları için bundan başka istisna
        sınıfları türetmektir:
</para>
   <para>
    <screen>
class Error(Exception):
    """Bu modüldeki istisnalar için temel sınıf."""
    pass

class GirisHatasi(Error):
    """Giriş hataları için oluşacak istisna.

    Özellikler:
        ifade -- hatanın oluştuğu giriş ifadesi
        mesaj -- explanation of the error
    """

    def __init__(self, ifade, mesaj):
        self.ifade = ifade
        self.mesaj = mesaj

class GecisHatasi(Error):
    """İzin verilmeyen bir durum geçişine teşebbüs edildiğinde oluşacak istisna.

    Özellikler:
        onceki -- geçiş başlangıcındaki durum
        sonraki -- istenen yeni durum
        mesaj -- durum geçişine izin verilmemesinin sebebi
    """

    def __init__(self, onceki, sonraki, mesaj):
        self.onceki = onceki
        self.sonraki = sonraki
        self.mesaj = mesaj
</screen>
   </para>
   <para>
        Çoğu standart modül kendi tanımladıkları işlevlerde meydana gelen hataları
        rapor etmek için kendi istisnalarını tanımlarlar.
      </para>
   <para>
        Sınıflar üzerine daha fazla bilgi sonraki bölümünde sunulacaktır.
      </para>
  </section>
  <section xml:id="python-tutorial_try">
   <info>
    <title>Son İşlemlerin Belirlenmesi</title>
   </info>
   <para><literal>try</literal> deyiminin her durumda yürütülecek işlemleri
        belirten seçimlik bir bloğu da vardır. Örnek:
</para>
   <para>
    <screen>
&gt;&gt;&gt; try:
...     raise KeyboardInterrupt
... finally:
...     print 'Goodbye, world!'
...
Goodbye, world!
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 2
KeyboardInterrupt
</screen>
   </para>
   <para><literal>finally</literal> bloğu <literal>try</literal> bloğu içinde
        bir istisna oluşsa da oluşmasa da yürütülür. Bir istisna oluşursa
        <literal>finally</literal> bloğu icra edildikten sonra istisna tekrar
        oluşturulur. <literal>Finally</literal> bloğu <literal>try</literal>
        deyimi <literal>break</literal> veya <literal>return</literal> ile
        sonlanırsa da icra edilir.
      </para>
   <para><literal>try</literal> deyiminin bir ya da daha fazla
        <literal>except</literal> bloğu veya bir <literal>finally</literal>
        bloğu olmalıdır; ancak her ikisi bir arada olamaz.
      </para>
  </section>
 </chapter>
 <chapter xml:id="python-tutorial_siniflar">
  <info>
   <title>Sınıflar</title>
  </info>
  <para>
      Python'un sınıf mekanizması sınıfları çok az bir sözdizimi ve
      kavramsallıkla dile ekler. Sınıf mekanizması C++ ile Modula-3 karışımıdır
      denebilir. Python'da sınıflar modüllerdeki gibi kullanıcı ile tanımlar
      arasına somut engeller koymaz. Python'da sınıflara gücünü veren başlıca
      özelliklerini şöyle sıralayabiliriz: sınıflar çok sayıda sınıfı miras
      alabilir. Bu türetilmiş sınıflar, atalarının yöntemlerini değiştirerek
      kullanabilirler; ataları ile aynı isme sahip yöntemlerle, atasındaki
      yöntemleri çağırabilirler. Nesneler özel verilere sahip olabilir.
    </para>
  <para>
      C++ terminolojisinde, tüm sınıf üyeleri (veri üyeleri dahil)
      <literal>public</literal> ve tüm üye işlevler <literal>virtual</literal>'dir.
      Özel bir kurucu ya da yıkıcı yoktur. Modula-3'deki gibi, bir nesnenin
      yöntemlerinden üyelerine başvuru için bir kestirme yol yoktur: bir üye
      yöntem, dolaylı olarak çağrı ile sağlanan ve doğrudan nesneyi ifade eden
      bir ilk argüman ile bildirilir. Smalltalk'daki gibi, sınıfların kendileri
      nesnelerdir (sınıfların ve nesnelerin kavramsal özelliklerine uymasa da
      böyledir). Python'da tüm veri türleri birer nesnedir. Bu onların yeniden
      isimlendirilebilmesi ve başka veri türlerine dahil edilmesi için bir yol
      sağlar. Ancak kullanıcı bunları genişletmek için temel sınıf olarak
      kullanamaz. Ayrıca Modula-3'de olmayan ama C++'da olan, özel yazımlı bir çok
      yerleşik işleç (aritmetik işleçler, alt indisleme, vs), sınıf gerçeklemeleri
      için yeniden tanımlanabilir.
    </para>
  <section xml:id="python-tutorial_terminoloji">
   <info>
    <title>Terminoloji hakkında...</title>
   </info>
   <para>
        Sınıflar hakkında konuşurken, evrensel olarak kabul edilmiş bir
        terminolojinin olmayışından dolayı arasıra Smalltalk ve C++ terimlerini
        kullanacağım. (Aslında, nesne yönelimi açısından Python'a daha çok benzeyen
        Modula-3 dili terimlerini kullanırdım; fakat bu dilden haberdar olan
        okuyucuların azınlıkta olduğunu sanıyorum.)
      </para>
   <para>
        Ayrıca nesne yönelim kavramını bilenleri bir terminoloji tuzağına karşı
        uyarmalıyım: "Nesne" sözcüğü, Python'da "bir sınıfın gerçeklenmesi"
        anlamına gelmez.
        Smalltalk'da olmayan ancak C++ ve Modula-3'dekine
        benzer şekilde Python'daki veri türlerinin hepsi birer sınıf değildir:
        tamsayılar ve listeler gibi yerleşik veri türleri ile dosyalar sınıf
        değildirler. Yine de tüm Python veri türleri için ortak bir kavramı
        paylaşmaları adına nesnelerdir demek yanlış olmaz.
      </para>
   <para>
        Nesneler tek tek ve çoklu isimlerle (çoklu etki alanları içinde), aynı
        nesneye bağlı olabilir. Bu diğer dillerde kod isimlendirme (aliasing)
        olarak bilinir. Bu genellikle Python'da ilk bakışta anlaşılmaz ve
        değişmez temel türler (sayılar, dizgeler, demetler) ile çalışırken
        yoksayılabilir. Yine de kod isimlendirme, listeler sözlükler gibi
        değiştirilebilen nesneler ve program dışındaki öğeler (dosyalar,
        pencereler, vs) için kullanılan bazı türlerinde katılımıyla Python kodunun
        kavramsallaştırılmasında (kasıtlı!) bir etkiye sahiptir. Bazı yönleriyle
        kod isimlendirme göstergelere benzer bir davranış sergilediğinden
        genellikle, program yararına kullanılmıştır. Örneğin, sadece göstergesi
        aktarıldığından bir nesnenin aktarılması kolaydır; eğer bir işlev,
        bir argüman olarak aktarılan bir nesneyi değiştirirse, işlevi çağıran
        değişikliği görecektir - bu, Pascal'daki gibi iki farklı argüman aktarma
        gereksinimini ortadan kaldırır.
      </para>
  </section>
  <section xml:id="python-tutorial_isimalani">
   <info>
    <title>Python Etki ve İsim Alanları</title>
   </info>
   <para>
        Sizi sınıflar ile tanışmadan önce, biraz da Python'un etki alanı kurallarından
        bahsetmem gerek. Sınıf tanımlamalarını tam olarak anlamak için etki ve isim
        alanlarının nasıl çalıştığını bilmeniz gerek. Bu konudaki bilgiler ileri
        seviyedeki her Python programcısı için yaralıdır.
      </para>
   <para>Birkaç tanım ile işe koyulalım.
      </para>
   <para>
        Bir <emphasis>isim alanı</emphasis> isimler ile nesnelerin eşleşmesidir.
        Çoğu isim alanı şu anda Python sözlükleri olarak kodlanmışlardır, fakat bu
        hiçbir şekilde fark edilmez ve gelecekte değiştirilebilir. İsim alanlarına
        örnekler: yerleşik isimler kümesi (<literal>abs()</literal> gibi işlevler
        ve yerleşik istisna isimleri vs.), bir modül içindeki global isimler ve
        bir işlev çağrısındaki yerel isimler. Bir nesnenin özellikler kümesi de
        bir isim alanıdır. İsim alanlarına ilişkin bilinecek önemli şey farklı
        isim alanlarındaki isimlerin birbirileri ile hiçbir ilişkisi olmadığıdır.
        Örneğin, iki farklı modül karışıklık yaratmadan “maksimize” adlı birer
        işlev tanımlayabilir; kullanıcılar bu işlevleri önlerine modül adını
        ekleyerek kullanırlar.
      </para>
   <para>
        Bu arada, bir noktadan sonra yazılan her herhangi bir isim için <emphasis>öznitelik</emphasis>
        sözcüğünü kullanıyorum. Örneğin, <literal>z.real</literal> ifadesinde
        <literal>real</literal>, <literal>z</literal> nesnesinin bir özniteliğidir.
        Modül içindeki isimlere atıflar da öznitelik atıflarıdır:
        <literal>modulAdi.fonkAdi</literal> ifadesinde <literal>modulAdi</literal>
        bir modül nesnesidir ve <literal>fonkAdi</literal> bunun bir özniteliğidir.
        Bir modülün öznitelikleri ile içinde tanımlı global değişkenler aynı isim
        alanını paylaşırlar.<footnote><para>Buna bir istisna: modül nesnelerinin,
        modülün isim alanını oluşturmada kullanılan sözlüğü oluşturan
        <literal>__dict__</literal>isimli salt okunur ve gizli bir özniteliği vardır.
        <literal>__dict__</literal> bir özniteliktir fakat global bir isim değildir.
        </para></footnote>
      </para>
   <para>
        öznitelikler salt okunur veya yazılabilir olabilirler. Yazılabilir oldukları
        durumda özniteliklere atama yapmak mümkündür. Modül öznitelikleri yazılabilirdir:
        <literal>modulAdi.sonuc = 42</literal> gibi bir ifade kullanabilirsiniz.
        Yazılabilir öznitelikleri <literal>del</literal> deyimini kullanarak silmek de
        mümkündür. Örneğin <literal>del modulAdi.sonuc</literal> ifadesi
        <literal>modulAdi</literal> nesnesinden sonuc isimli özniteliği siler.
      </para>
   <para>
        Farklı anlarda yaratılan isim alanlarının farklı ömürleri olur. Yerleşik
        isimleri içeren isim alanı Python yorumlayıcısı çalıştırıldığında yaratılır
        ve asla silinmez. Bir modüle ait global isim alanı modül tanımı okunduğunda
        yaratılır ve genellikle yorumlayıcı çalıştığı sürece silinmez. Yorumlayıcının
        bir dosyadan veya etkileşimli olarak çalıştırdığı deyimler de
        <literal>__main__</literal> isimli bir modüle ait kabul edilir ve bunların
        da kendi global isim alanı vardır. Yerleşik isimler de <literal>__builtin__</literal>
        isimli bir modülde bulunurlar.
      </para>
   <para>
        Bir işleve ait yerel isim alanı işlev çağırıldığında yaratılır ve işlevden
        dönüldüğünde veya işlev içinde ele alınmamış bir istisna gerçekleştiğinde
        silinir. Tabii ki özyinelemeli çağrıların herbiri kendi yerel isim alanına
        sahiptir.
      </para>
   <para>
        Bir <emphasis>etki alanı</emphasis> bir isim alanının doğrudan erişilebildiği bir
        metin bölgesidir. Burada “doğrudan erişilebilir” ifadesinin anlamı, yetersiz bir
        isim atfının isim alanında isim bulmaya teşebbüs etmesidir.
      </para>
   <para>
        Etki alanları statik olarak belirlenmelerine rağmen, dinamik olarak
        kullanılırlar. İcranın herhangi bir anında isim alanlarına doğrudan
        erişilebilen iç içe geçmiş en az üç etki alanı vardır: ilk aranan ve yerel
        isimleri içeren en iç etki alanı; en yakın olanından başlanarak aranan
        çevreleyen işlevlerin isim alanları; daha sonra aranan ve o andaki modülün
        global değişkenlerini içeren orta etki alanı; ve yerleşik isimlerin bulunduğu
        isim alanı olan en dış etki alanı (en son aranır).
      </para>
   <para>
        Eğer bir isim global olarak tanımlanmış ise tüm atıflar ve atamalar doğrudan
        modülün global isimlerini barındıran orta etki alanına giderler. Zaten,
        en iç etki alanının dışındaki tüm isimler salt okunurdur.
      </para>
   <para>
        Genellikle yerel etki alanı o an içinde bulunulan (program metninde) işlevin
        yerel isimlerine atıfta bulunur. İşlevlerin dışında yerel etki alanı global
        etki alanı ile aynı isim alanıdır: modülün isim alanı. Sınıf tanımlamaları
        ayrıca yerel etki alanı içerisine bir başka isim alanı daha eklerler.
      </para>
   <para>
        Etki alanlarının metne bağlı olarak belirlendiğini anlamak önemlidir. Bir
        modül içinde tanımlı bir işlevin global etki alanı o modülün isim alanıdır;
        nereden çağırıldığı ya da hangi farklı isim ile çağırıldığı bir fark yaratmaz.
        Diğer yandan, asıl isim araması icra anında dinamik olarak yapılır; ancak
        dilin tanımı “derleme” sırasında yapılan statik isim çözümlemeye doğru
        değişmektedir ve dinamik isim çözümlemeye güvenmemelisiniz! Örneğin, yerel
        değişkenler şu anda statik olarak belirlenmektedir.
      </para>
   <para>
        Python'a özgü bir tuhaflık da atamaların her zaman en iç etki alanına gitmesidir.
        Atamalar veri kopyalamaz; sadece nesnelere isimler bağlarlar. Aynı şey silme
        işlemleri için de geçerlidir: <literal>del x </literal> ifadesi <literal>x</literal>'in
        yerel etki alanı tarafından atfedilen isim alanındaki bağını kaldırır.
        Aslında, yeni isimler yaratan tüm işlemler yerel etki alanını kullanırlar.
        İşlev tanımları ve <literal>import</literal> deyimleri modül veya işlev adını
        yerel etki alanına bağlarlar. Bir değişkenin global etki alanında bulunduğunu
        belirtmek için <literal>global</literal> deyimi kullanılabilir.
      </para>
  </section>
  <section xml:id="python-tutorial_siniflar-ilk">
   <info>
    <title>Sınıflara İlk Bakış</title>
   </info>
   <para>
        Sınıflar ile bir miktar yeni sözdizim ve kavram ile üç yeni nesne türü
        tanıtacağız.
      </para>
   <section>
    <info>
     <title>Sınıf Tanımlama</title>
    </info>
    <para>
          Sınıf tanımlamanın en basit şekli şöyledir:
</para>
    <para>
     <screen>
class SinifAdi:
    &lt;deyim-1&gt;
    .
    .
    .
    &lt;deyim-N&gt;
</screen>
    </para>
    <para>
          Sınıf tanımlamaları, işlev tanımlamalarında (<literal>def</literal> deyimleri)
          olduğu gibi etkin olmaları için önce işletilmeleri gerekir. (Yanlışlıkla sınıf
          tanımlarını <literal>if</literal> deyimleri veya işlev içlerine koymamaya
          dikkat edin.)
        </para>
    <para>
          Pratikte bir sınıf tanımının içindeki deyimler genellikle
          işlev tanımları olur; fakat başka deyimler de kullanmak mümkün ve yararlıdır
          (buna daha sonra yine değineceğiz). Sınıf içindeki işlev tanımlarının argüman
          listesi kendilerine özgü bir şekle sahiptir; ancak buna da daha sonra
          değineceğiz.
        </para>
    <para>
          Bir sınıf tanımına girildiğinde yeni bir isim alanı (name space)
          oluşturulur ve bu yerel etki alanı (scope) olarak kullanılır. Yerel
          değişkenlere yapılan bütün atamalar bu yeni isim alanına gider. Yeni
          tanımlanan işlevlerin isimleri de buraya eklenir.
        </para>
    <para>
          Bir sınıf tanımı normal olarak tamamlandığında bir <emphasis>sınıf
          nesnesi</emphasis> yaratılmış olur. Bu, temel olarak, sınıf tanımının
          oluşturduğu isim alanı etrafında bir örtüdür. Sınıf nesnelerini bir
          sonraki bölümde daha yakından tanıyacağız. Orjinal etki alanı
          (sınıf tanımına girilmeden önce etkin olan) yine eski yerini alır ve
          sınıf nesnesi de buna sınıf tanımında kullanılan isim (örnekteki
          <literal>SinifAdi</literal>) ile dahil olur.
        </para>
   </section>
   <section>
    <info>
     <title>Sınıf Nesneleri</title>
    </info>
    <para>
          Sınıf nesneleri iki tür işlemi destekler: özniteliklere başvuru (attribute
          reference) ve sınıfın gerçeklenmesi (instantiation).
        </para>
    <para><emphasis>Özniteliklere başvuru</emphasis> için Python'da bütün
          özniteliklere erişmek için kullanılan standart sözdizim kullanılır:
          <literal>nesne.isim</literal>. Kullanılabilecek öznitelik isimleri sınıf
          nesnesi yaratılırken sınıfın isim alanında bulunan bütün isimlerdir.
          Sınıf tanımımız aşağıdaki gibi ise:
</para>
    <para>
     <screen>
class benimSinif:
    "Basit bir sınıf örneği."
    i = 12345
    def f(self):
        return 'Merhaba'
</screen>
    </para>
    <para><literal>benimSinif.i</literal> ve <literal>benimSinif.f</literal>
          bir tamsayı ve bir yöntem nesnesi geri döndüren geçerli öznitelik
          başvurularıdır. Sınıf özniteliklerine atama yapmak da mümkündür.
          Örneğin atama yoluyla <literal>benimSinif.i</literal> değeri
          değiştirilebilir. Ayrıca, <literal>__doc__</literal> da geçerli
          bir öznitelik olup sınıfa ait belgeleme dizgesini geri döndürür:
          "Basit bir sınıf örneği.".
        </para>
    <para><emphasis>Sınıfın gerçeklenmesi</emphasis>, işlev sözdizimini
          kullanır. Sınıf nesnesini yeni bir sınıf gerçeklemesi geri döndüren
          parametresiz bir işlevmiş gibi düşünebilirsiniz. Örneğin yukarıda
          tanımladığımız sınıf için:
        </para>
    <para>
     <screen>x = benimSinif()</screen>
    </para>
    <para>
          Yeni bir sınıf gerçeklemesidir ve sınıf <literal>x</literal> yerel
          değişkenine atanarak bir nesne oluşur.
        </para>
    <para>
          Gerçeklenme işlemi (bir sınıf nesnesini ``çağırmak'') boş bir nesne
          yaratır. Pek çok sınıf nesnesinin bilinen bir ilk durumda oluşturulması
          istenir. Bu yüzden bir sınıfta <literal>__init__()</literal> adlı
          özel yöntem şu şekilde tanımlanabilir:
</para>
    <para>
     <screen>
def __init__(self):
    self.data = []
</screen>
    </para>
    <para>
          Bir sınıfın <literal>__init__()</literal> yöntemi tanımlanmış ise sınıf
          gerçeklenmesi işlemi, yeni sınıf gerçeklemesi sırasında bu yöntemi otomatik
          olarak çağırır.
        </para>
    <para>
          Daha fazla esneklik için <literal>__init__()</literal> yönteminin
          argümanları da olabilir. Bu durumda sınıfın gerçeklenmesinde
          kullanılan argümanlar <literal>__init__()</literal> yöntemine aktarılır.
          <footnote><para>
              [Ç.N.]: Diğer nesne yönelimli programlama dillerinde bu işleme
              "nesnenin ilklendirilmesi" denir.
            </para></footnote>
          Örnek:
</para>
    <para>
     <screen>
&gt;&gt;&gt; class karmasikSayi:
...     def __init__(self, gercekKsm, sanalKsm):
...         self.g = gercekKsm
...         self.s = sanalKsm
...
&gt;&gt;&gt; x = karmasikSayi(3.0, -4.5)
&gt;&gt;&gt; x.g, x.s
(3.0, -4.5)
</screen>
    </para>
    <para>
        </para>
   </section>
   <section>
    <info>
     <title>Nesneler (Gerçeklenen Sınıflar)</title>
    </info>
    <para>
          Nesnelerle ne yapabiliriz? Bunlar ile yapabileceğimiz
          tek şey öznitelikleri ile uğraşmaktır. Nesnelerin iki tür özniteliği
          vardır. Bunların ilki veri öznitelikleridir. Veri özniteliklerinin
          tanımlanmış olması gerekmez; yerel değişkenlerde olduğu gibi bunlar
          da kendilerine ilk atama yapıldığında var olurlar. Örneğin
          <literal>x</literal>'in yukarıda tanımlanan <literal>benimSinif</literal>
          sınıfının bir gerçeklemesi olduğunu düşünürsek aşağıdaki program parçası
          16 değerini geride bir iz bırakmadan yazdırır:
</para>
    <para>
     <screen>
x.sayac = 1
while x.sayac &lt; 10:
    x.sayac = x.sayac * 2
print x.sayac
del x.sayac
</screen>
    </para>
    <para>
          Nesnelerin ikinci tür öznitelikleri de yöntemlerdir.
          Yöntem bir sınıfa “ait olan” bir işlevdir. Python dilinde yöntemler
          sınıf gerçeklemelerine özgü değildir; diğer nesne türlerinin de
          yöntemleri vardır (listeler, sözlükler vs.). Aşağıda yöntem terimini,
          aksi belirtilmediği sürece, sadece nesnelerin yöntemleri anlamında
          kullanacağız.
        </para>
    <para>
          Bir nesneye ilişkin geçerli öznitelik isimleri bunun
          sınıfına bağlıdır. Tanıma göre işlev olan tüm sınıf öznitelikleri o
          nesnenin yöntemleri olur. Bu yüzden örnek sınıfımız için
          <literal>x.f</literal> geçerli bir yöntem başvurusudur, çünkü
          <literal>benimSinif.f</literal> bir işlevdir, fakat
          <literal>x.i</literal> bir yöntem değildir, çünkü
          <literal>benimSinif.i</literal> bir işlev değildir.
          Burada şuna dikkat edelim: <literal>x.f</literal> ile
          <literal>benimSinif.f</literal> aynı şey değildir.
        </para>
   </section>
   <section>
    <info>
     <title>Yöntem Nesneleri</title>
    </info>
    <para>
          Genellikle bir yöntem şu şekilde doğrudan çağırılır:
        </para>
    <para>
     <screen>x.f()</screen>
    </para>
    <para>
          Bizim örneğimizde bu 'Merhaba' dizgesini geri döndürür.
          Bir yöntemi doğrudan çağırmak şart değildir: <literal>x.f</literal>
          bir yöntemdir ve bir değişkene saklanıp daha sonra çağırılabilir.
          Örneğin:
</para>
    <para>
     <screen>
xf = x.f
while 1:
    print xf()
</screen>
    </para>
    <para>
          Sonsuza kadar "'Merhaba'" yazdırır.
        </para>
    <para>Bir yöntem çağrıldığında tam
          olarak ne olur? <literal>x.f()</literal> çağrılırken bir argüman
          kullanılmadığı halde <literal>f</literal> işlev tanımında bir argüman
          kullanıldığını (<literal>self</literal>)fark etmişsinizdir. Argümana
          ne oldu acaba? Şüphesiz Python, argüman gerektiren bir işlev argümansız
          çağırıldığında bir istisna oluşturur. Cevabı belki de tahmin ettiniz:
          yöntemler, işlevin ilk argümanı olarak nesneyi alırlar. Başka bir deyişle
          Python'da yöntemler, kendi içinde, tanımlı olduğu nesneyi barındıran
          nesnelerdir. Örneğimizdeki <literal>x.f()</literal> çağrısı aslında
          <literal>benimSinif.f(x)</literal> ile aynıdır. Genel olarak, bir
          yöntemi <literal>n</literal> elemanlı bir argüman listesi ile çağırmak,
          aynı işlevi başına nesnenin de eklendiği bir argüman listesi kullanarak
          çağırmak ile aynı şeydir.
        </para>
   </section>
  </section>
  <section xml:id="python-tutorial_siniflar-aciklamalar">
   <info>
    <title>Bazı Açıklamalar</title>
   </info>
   <para>
        Veri öznitelikleri aynı isimli yöntem özniteliklerini bastırırlar. Büyük
        programlardaki zor fark edilen isim çakışması hatalarından kaçınmak
        için çakışmaları en aza indirecek bir isimlendirme yöntemi kullanmak
        akıllıca olur. Yöntem isimlerini büyük harf ile başlatılırken, veri
        isimleri özel bir karakter (alt çizgi gibi) ile başlatılabilir.
        Yöntemler için fiil ve veri yapıları için isim olan kelimeler
        kullanılabilir.
      </para>
   <para>
        Veri özniteliklerine o nesnenin kullanıcıları (“istemcileri”)
        başvuru yapabileceği gibi, yöntemler de bunlara başvuruda bulunabilirler.
        Başka bir deyişle, sınıflar tamamen soyut veri türleri oluşturmak için
        kullanılamazlar. Aslında, Python'da hiçbir şey veri saklamayı zorlamayı
        mümkün kılmaz.
      </para>
   <para>
        Kullanıcılar nesnelerin veri özniteliklerini dikkatli kullanmalılar; çünkü
        istemciler yöntemler tarafından kullanılan önemli değişkenlere atama yaparak
        istenmeyen hatalara sebep olabilirler. İstemcilerin, isim çakışmalarından
        kaçındıkları sürece, bir nesneye yöntemlerinin geçerliliğini etkilemeden
        kendi veri özniteliklerini ekleyebileceklerine dikkat edin.
      </para>
   <para>
        Yöntem içinden veri özniteliklerine (ya da diğer yöntemlere!) başvuruda
        bulunmanın kestirme bir yolu yoktur. Bunun aslında yöntemlerin
        okunabilirliğini artırdığını düşünüyorum; bir yönteme göz attığınızda
        yerel değişkenler ile nesne değişkenlerini birbirilerine karıştırma şansı
        yoktur.
      </para>
   <para>
        Usul olarak yöntemlerin ilk argümanına <literal>self</literal>
        adı verilir. Bu tamamen usule dayanır; <literal>self</literal> isminin
        Python için kesinlikle hiç bir özel anlamı yoktur. Bu usule uymazsanız
        programınız diğer Python programcıları tarafından daha zor okunur ve
        sınıf tarayıcısı (class browser) programları da bu usule dayanıyor
        olabilirler.
      </para>
   <para>
        Sınıf özniteliği olan her işlev, o sınıfın nesneleri için bir
        yöntem tanımlar. İşlev tanımının sınıf tanımı içerisinde olması şart
        değildir; işlevi, sınıf içindeki yerel bir değişkene atamak da mümkündür.
        Örneğin:
</para>
   <para>
    <screen>
# Sınıf dışında tanımlanmış işlev
def f1(self, x, y):
    return min(x, x+y)

class C:
    f = f1
    def g(self):
        return 'Merhaba'
    h = g
</screen>
   </para>
   <para>
        Şimdi <literal>f</literal>, <literal>g</literal> ve <literal>h</literal>'ın
        hepsi <literal>C</literal> sınıfının özellikleri oldular ve aynı anda
        <literal>C</literal> sınıfının nesnelerinin de
        yöntemleridirler (<literal>g</literal> ve <literal>h</literal> birbirinin
        tamamen aynısıdır). Bu tür uygulamanın genellikle sadece okuyucunun
        kafasını karıştırmaya yaradığına dikkat edin. Yöntemler <literal>self</literal>
        argümanının yöntem olan özelliğini kullanarak diğer yöntemleri
        çağırabilirler:
</para>
   <para>
    <screen>
class Bag:
    def __init__(self):
        self.data = []
    def add(self, x):
        self.data.append(x)
    def addtwice(self, x):
        self.add(x)
        self.add(x)
</screen>
   </para>
   <para>
        Yöntemler sıradan işlevlerin yaptığı şekilde global değişkenlere
        başvuru yapabilirler. Bir yönteme ilişkin global etki alanı sınıf
        tanımının bulunduğu modüldür. Sınıfın kendisi asla global etki alanı
        olarak kullanılmaz. Bir yöntem içinde global veri kullanmak için ender
        olarak iyi bir sebep olduğu halde, global etki alanı kullanımın pek çok
        mantıklı sebebi vardır. Örneğin, global etki alanına yüklenmiş işlev ve
        modülleri, yöntemler ve bunun içinde tanımlanmış diğer işlev ve sınıflar
        kullanılabilir. Genellikle yöntemi içeren sınıfın kendisi bu global etki
        alanı içinde tanımlanmıştır ve bir sonraki kısımda bir yöntemin kendi
        sınıfına başvurmak istemesi için birkaç iyi sebep bulacağız!
      </para>
  </section>
  <section xml:id="python-tutorial_miras">
   <info>
    <title>Miras</title>
   </info>
   <para>
        Tabii ki, miras alma desteği olmayan bir “sınıf” adına layık olmaz.
        Türetilmiş sınıf tanımının sözdizimi aşağıdaki gibidir:
</para>
   <para>
    <screen>
class turemisSinifAdi(TemelSinifAdi):
    &lt;deyim-1&gt;
    .
    .
    .
    &lt;deyim-N&gt;
</screen>
   </para>
   <para><literal>TemelSinifAdi</literal> ismi türetilmiş sınıfın tanımının
        bulunduğu etki alanında tanımlı olmalıdır. Temel sınıf adı yerine bir
        ifade kullanmak da mümkündür. Bu temel sınıf adı başka bir modül
        içinde tanımlı olduğunda yararlıdır:
      </para>
   <para>
    <screen>class turemisSinifAdi(modulAdi.TemelSinifAdi):</screen>
   </para>
   <para>
        Bir türetilmiş sınıf tanımının işletilmesi bir temel sınıf ile aynıdır.
        Bir sınıf nesnesi yaratıldığında temel sınıf hatırlanır. Bu özellik
        başvurularını çözümlemede kullanılır; başvuruda bulunulan öznitelik o
        sınıfta yok ise temel sınıfta aranır. Bu kural temel sınıfın kendisi
        de başka bir sınıftan türetildiyse ardışık olarak çağırılır.
      </para>
   <para>
        Türetilmiş sınıftan nesne oluşturmanın özel bir tarafı yoktur:
        <literal>turetilmisSinifAdi()</literal> o sınıfın yeni bir
        nesnesini yaratır. Yöntem başvuruları şu şekilde çözümlenirler: ilgili
        sınıf özelliği, gerekirse temel sınıflar zinciri taranarak, aranır ve
        yöntem başvurusu geçerli ise bu bir işlev verir.
      </para>
   <para>
        Türetilmiş sınıflar
        temel sınıflarının yöntemlerini bastırabilirler. Yöntemler aynı nesnenin
        diğer yöntemlerini çağırırken özel önceliklere sahip olmadıkları için
        aynı temel sınıfta tanımlı bir yöntemi çağıran temel sınıf yöntemi bunu
        bastıran bir türetilmiş sınıf yöntemini çağırmış olabilir.
        C++ programcıları için not: Tüm Python yöntemleri sanaldır (virtual).
      </para>
   <para>
        Türetilmiş sınıftaki bir bastıran yöntem aslında temel sınıftaki
        yöntemin yerini almak yerine onu geliştirmek isteyebilir. Temel sınıf
        yöntemini doğrudan çağırmanın basit bir yolu vardır:
        <literal>temelSinifadi.yontemAdi(self, argumanlar)</literal>. Bu bazen
        istemciler için de faydalıdır. Bunun sadece, temel sınıf, global etki
        alanı içine doğrudan yüklendiyse çalıştığına dikkat edin.
      </para>
   <section>
    <info>
     <title>Çoklu Miras</title>
    </info>
    <para>
          Python çoklu miras almanın kıstlı bir şeklini destekler. Birçok temel
          sınıfı olan bir sınıf tanımı aşağıdaki gibidir:
</para>
    <para>
     <screen>
class turemisSinifAdi(temel1, temel2, temel3):
    &lt;ifade-1&gt;
    .
    .
    .
    &lt;ifade-N&gt;
</screen>
    </para>
    <para>
          Burada sınıf özniteliği başvurularını çözümlemede kullanılan kuralı
          açıklamamız gerekiyor. Bir öznitelik <literal>turemisSinifAdi</literal>
          içinde bulunamazsa <literal>temel1</literal> içinde sonra
          <literal>temel1</literal>'in temel sınıfları içerisinde ve burada da
          bulunamazsa <literal>temel2</literal> içinde aranır vs.
        </para>
    <para>
          Bazı kişilere
          <literal>temel1</literal>'den önce <literal>temel2</literal> ve
          <literal>temel3</literal> içinde arama yapmak daha doğal gelir. Bu
          <literal>temel1</literal>'in herhangi bir özniteliğinin
          <literal>temel1</literal> içinde veya bunun temel sınıflarında
          tanımlanmış olup olmadığını bilmenizi gerektir ki <literal>temel2</literal>
          içindeki isimler ile çakışmalardan kaçınabilesiniz.
        </para>
    <para>
          Python'un kazara
          oluşan isim çakışmalarına karşı usule dayanması çoklu kalıtımın rasgele
          kullanımı programın bakımını yapan için bir kabus olduğu açıktır.
          Çoklu kalıtımın iyi bilinen bir problemi aynı temel sınıfa sahip iki
          sınıftan türetme yapmaktır. Bu durumda ne olduğunu anlamak kolaydır;
          ancak bunun ne işe yarayacağı pek açık değildir.
        </para>
   </section>
  </section>
  <section xml:id="python-tutorial_ozel-deg">
   <info>
    <title>Özel Değişkenler</title>
   </info>
   <para>
        Sınıfa özel belirteçler (identifier) için sınırlı destek vardır.
        <literal>__spam</literal> formundaki (en az iki alt çizgilik bir önek ve
        en fazla bir alt çizgilik sonek) bir belirteç
        <literal>_sinifadi__spam</literal> şeklini alır. Burada
        <literal>sinifadi</literal> o anki sınıf adının sonek alt çizgileri
        atılmış olan halidir. Bu değişiklik belirtecin sözdizimsel konumuna
        bakılmaksızın yapılır ki bu sınıf üyesine özel değişkenler yaratılabilsin.
        Değiştirilen belirteç 255 karakteri aşarsa kırpılabilir. Sınıflar dışında
        veya sınıf adı sadece alt çizgilerden oluşuyorsa kırpma olmaz.
      </para>
   <para>
        İsim değiştirmenin amacı sınıflara, türemiş sınıflarca tanımlanan nesne
        değişkenlerini dert etmeden veya sınıf dışındaki nesne değişkenleri ile
        uğraşmadan, kolayca özel nesne değişkenleri ve yöntemleri tanımlama yolu
        sağlamaktır. Değiştirme kurallarının genelde kazaları önlemeye yönelik
        olduğuna dikkat edin; ancak yine de buna niyet eden kişi özel değişkenlere
        ulaşıp bunları değiştirebilir. Bu bazı özel durumlarda kullanışlı da olabilir.
      </para>
   <para><literal>exec()</literal>, <literal>eval()</literal> veya <literal>evalfile()</literal>
        işlevlerine aktarılacak kod, çağıran sınıf adının o anki sınıf adı olduğunu düşünmez;
        bu da “ikilik derlenmiş” kod ile sınırlı global deyiminin etkisine benzer. Aynı
        kısıtlama <literal>getattr()</literal>, <literal>setattr()</literal> ve
        <literal>delattr()</literal> işlevleri için ve doğrudan başvurulduğunda
        <literal>__dict__</literal> için de mevcuttur.
      </para>
  </section>
  <section xml:id="python-tutorial_son1">
   <info>
    <title>Sona Kalanlar</title>
   </info>
   <para>
        Bazan isimli veri öğelerini bir arada paketlemek, Pascal kayıtları ya da
        C veri yapılarına benzer bir veri türü oluşturmak kullanışlı olabilir.
        Bir boş sınıf ile bu yapılabilir:
</para>
   <para>
    <screen>
class Eleman:
    pass

ali = Eleman() # Boş bir eleman kaydı yarat

# Kaydın alanlarını doldur
ali.isim = 'Ali Veli'
ali.bolum = 'Muhasebe'
ali.maas = 1000000
</screen>
   </para>
   <para>
        Soyut bir veri türü bekleyen Python koduna o veri türünün yöntemlerini taklit
        eden bir sınıf geçirilebilir. Örneğin bir dosya nesnesinden bir miktar veriyi
        biçimleyen bir işleviniz varsa, <literal>read()</literal> ve <literal>readline()</literal>
        yöntemleri olan ve veriyi bir dizgeden alan bir sınıfı o işleve argüman olarak
        aktarabilirsiniz.
      </para>
   <para>
        Yöntem nesnelerinin de öznitelikleri vardır: <literal>m.im_self</literal>
        kendinin tanımlı olduğu nesneyi çağıran bir yöntem nesnesidir ve
        <literal>m.im_func</literal> ise kendini oluşturan işlevi çağıran bir
        yöntem nesnesidir.
      </para>
  </section>
  <section xml:id="python-tutorial_son2">
   <info>
    <title>İstisnalar Sınıf Olabilir</title>
   </info>
   <para>
        Kullanıcı tanımlı istisnalar artık dizge olmakla sınırlı değiller; sınıf da
        olabilirler. Bu mekanizmayı kullanarak genişletilebilir istisna hiyerarşileri
        yaratılabilir.
      </para>
   <para><literal>raise</literal> deyimi için iki yeni biçem mevcut:
</para>
   <para>
    <screen>
raise Sinif, gercekleme

raise gercekleme
</screen>
   </para>
   <para>
        İlk biçemde <literal>gercekleme Sinif</literal>a ait bir gerçekleme
        olmalıdır. İkinci biçem ise şunun kısaltmasıdır:
</para>
   <para>
    <screen>
raise gercekleme.__class__, gercekleme
</screen>
   </para>
   <para>
        Bir <literal>except</literal> bloğu hem sınıflar hem de dizgeleri içerebilir.
        Bir <literal>except</literal> bloğu içindeki sınıf eğer aynı sınıf veya bir
        temel sınıf ise istisna ile uyumludur. Türetilmiş sınıf içeren bir
        <literal>except</literal> bloğu temel sınıf ile uyumlu değildir. Örneğin
        aşağıdaki program <literal>B</literal>, <literal>C</literal>, <literal>D</literal>
        çıktısını o sırayla verir:
</para>
   <para>
    <screen>
class B:
    pass
class C(B):
    pass
class D(C):
    pass
for c in [B, C, D]:
    try:
        raise c()
    except D:
        print "D"
    except C:
        print "C"
    except B:
        print "B"
</screen>
   </para>
   <para>
        Eğer <literal>except</literal> blokları ters sırayla yazılmış olsalardı
        (<literal>except B </literal> başta olacak şekilde) çıktı
        <literal>B, B, B</literal> olacaktı; çünkü uyan ilk <literal>except B </literal>
        bloğu tetiklenecekti.
      </para>
   <para>
        Ele alınmamış sınıf istisnası için bir ileti yazılacağı zaman, önce sınıf
        adı yazılır, ardından iki nokta üst üste ve bir boşluk ve son olarak da
        gerçeklemenin yerleşik <literal>str()</literal> işlevinden geri döndürülen
        dizgenin karşılığı yazılır.
      </para>
  </section>
 </chapter>
 <chapter xml:id="python-tutorial_son">
  <info>
   <title>Ya bundan sonra?</title>
  </info>
  <para>
      Bu kılavuzu okumak muhtemelen Python kullanmaya olan ilginizi artırmıştır.
      Peki şimdi ne yapmalısınız?
    </para>
  <para>
      Standart Python dağıtımı çok zengin bir modül kitaplığı ile gelmektedir.
      Python programları yazarken zamandan büyük tasarruf sağlayacak modüllerin
      nasıl kullanıldığını öğrenmek için bunlar ile ilgili belgelere başvurun.
    </para>
  <para>
      Resmi Python sanalyöresi <uri xlink:href="http://www.python.org/">http://www.python.org/</uri> olup; programlar,
      belgeler ve internetteki Python ile ilgili diğer sanalyörelere bağlantılar içerir.
      Daha az resmi bir sanalyöre ise <uri xlink:href="http://starship.python.net/">http://starship.python.net/</uri> olup;
      burada, çoğunda indirilebilir programlar bulunan, Python ile ilgili kişisel
      sanalyöreler mevcuttur.
    </para>
  <para>
      Python ile ilgili sorular ve problem raporları için <uri xlink:href="news:comp.lang.python">news:comp.lang.python</uri> haber grubunu veya <email>python-list@python.org</email>
      e-posta listesini kullanabilirsiniz. Haber grubu ile e-posta listesi birbirine
      bağlıdır; yani birine göndereceğiniz bir ileti diğerine de iletilir. Eposta
      atmadan önce <uri xlink:href="http://www.python.org/doc/FAQ.html">http://www.python.org/doc/FAQ.html</uri> adresindeki
      SSS listesini kontrol etmeyi unutmayın. Bu listeyi Python kaynak dağıtımının
      <literal>misc</literal> dizininde de bulabilirsiniz. E-posta listesi arşivleri
      ise <uri xlink:href="http://www.python.org/pipermail/">http://www.python.org/pipermail/</uri> adresinde bulunabilir.
    </para>
 </chapter>
</part>
