<?xml version="1.0" encoding="UTF-8"?>
<!-- ********************************************************************
         apps/python-tutorial.xml
     ******************************************************************** -->
<book xml:id="python-tutorial" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:lang="tr"
      userlevel="longtoc">
 <?dbhtml dir="../uygulamalar"?>
 <info>
  <title>Python Eğitmeni</title>
  <subtitle>(Python Tutorial)</subtitle>
  <authorgroup>
   <author role="editor">
    <personname>
     <firstname>Nilgün Belma Bugüner</firstname>
    </personname>
     <address>
      <link xlink:href="https://github.com/nilgun"/>
     </address>
   </author>
   <author role="translator">
    <personname>
     <firstname>Dinçer Aydın</firstname>
    </personname>
     <address>
      <link xlink:href="http://dinceraydin.com/"/>
     </address>
   </author>
   <author>
    <personname>
     <firstname>Guido van Rossum</firstname>
    </personname>
    <affiliation>
     <address>
      <link xlink:href="https://github.com/gvanrossum"/>
     </address>
    </affiliation>
   </author>
   <author>
    <personname>
     <firstname>Fred L. Drake, Jr.</firstname>
    </personname>
    <affiliation>
     <address>
      <link xlink:href="https://github.com/freddrake"/>
     </address>
    </affiliation>
   </author>
  </authorgroup>
  <pubdate>1 Aralık 2022</pubdate>
  <revhistory>
   <revision>
    <revnumber>2.3</revnumber>
    <date>Aralık 2022</date>
    <authorinitials>Özgün belge: PythonLabs, Çeviri: DA, Düzenleme: NBB</authorinitials>
    <revremark>
     Örnekler Python3 kullanılacağı varsayımıyla yeniden düzenlendi.
   </revremark>
   </revision>
   <revision>
    <revnumber>2.2.2</revnumber>
    <date>14 Ekim 2002</date>
    <authorinitials>Özgün belge: PythonLabs, Çeviri: DA</authorinitials>
    <revremark><link xlink:href="http://dinceraydin.com/python/tut/tut.html"/> adresindeki Windows sürümünden çevrilmiş Python Kılavuzu'nun Linux için uyarlamasıdır.
   </revremark>
   </revision>
   <revision>
    <revnumber>2.1.1</revnumber>
    <date>11 Kasım 2001</date>
    <authorinitials>Özgün belge: PythonLabs, Çeviri: DA</authorinitials>
    <revremark><link xlink:href="http://dinceraydin.com/python/tut/tut.html"/> adresindeki Windows sürümünden çevrilmiş Python Kılavuzu'nun Linux için uyarlamasıdır.
   </revremark>
   </revision>
  </revhistory>
  <abstract>
   <para>
    Bu belge Python2 Eğitmeninin çevirisi olup Python3 Eğitmeninin kapsamı biraz daha geniş olmakla birlikte bu çeviri hala yararlı bilgiler içermektedir. Örnekler Python3 kullanılacağı varsayılarak yeniden düzenlenmiştir.
   </para>
  </abstract>
 </info>
 <chapter xml:id="python-tutorial_giris">
  <?dbhtml stop-chunking?>
  <title>Giriş</title>
  <simpara>
   Telif Hakkı © 2001 Python Software Foundation. Tüm hakları saklıdır.
  </simpara>
  <simpara>
   Telif Hakkı © 2000 BeOpen.com. Tüm hakları saklıdır.
  </simpara>
  <simpara>
   Telif Hakkı © 1995-2000 Corporation for National Research Initiatives. Tüm hakları saklıdır.
  </simpara>
  <simpara>
   Telif Hakkı © 1991-1995 Stichting Mathematisch Centrum. Tüm hakları saklıdır.
  </simpara>
  <simpara>
   Telif Hakkı © 2001 Dinçer Aydın, tercüme. Tüm hakları saklıdır.
  </simpara>
  <simpara>
   Lisans bilgileri için <link xlink:href="https://docs.python.org/3/license.html"/> adresine bakınız.
  </simpara>
  <para>
   Python kolay öğrenilen güçlü bir yazılımlama dilidir. Verimli yüksek seviyeli veri türlerine sahiptir ve nesne tabanlı yazılımlamaya yaklaşımı basit ve etkilidir. Python'un şık sözdizimi, dinamik veri türleri ve yorumlanan bir dil oluşu onu çoğu alan ve platformda hızlı yazılım geliştirme için ideal yapar.
  </para>
  <para>
   Python yorumlayıcısı ve geniş standart kütüphanesi kaynak ya da çalıştırılabilir paket olarak <link xlink:href="http://www.python.org/">Python Sitesi</link>nden alınabilir ve dağıtılabilir.  Aynı sitede farklı Python dağıtımları, modüller, yazılımlar ve belgeler bulunabilir. Günümüzde yaygın olarak kullanılan işletim sistemlerinin çoğu için bir Python dağıtımı mevcuttur.
  </para>
  <para>
   Python yorumlayıcısı C veya C++ (ya da C dilinden çağırılabilen başka bir dil) ile yazılmış veri türleri ve işlevler ile genişletilebilir. Diğer dillerde yazdığınız yazılımlarınıza da Python yorumlayıcısını bağlayabilir ve Python ile ek özellikler eklenebilen yazılımlar geliştirebilirsiniz.
  </para>
  <para>
   Bu kılavuz okuyucuya Python dilinin temel özelliklerini, kavramlarını ve sistemini tanıtmaktadır. Örnekleri denemek için el altında bir Python yorumlayıcısı bulundurmak yararlı olur.
  </para>
  <para>
   Bu kılavuz Python'un bütün özeliklerini ya da yaygın olarak kullanılan her özelliğini açıklamak amacında değildir. Bunun yerine Python'un kayda değer özelliklerinin çoğu tanıtılmaktadır ve dilin tarzı ile ilgili iyi bir fikir verilmektedir. Bunu okuduktan sonra Python modülleri ve yazılımlarını okuyup yazabileceğiniz gibi Python ile gelen geniş kütüphane ile ilgili daha çok şey öğrenmeye hazır olacaksınız.
  </para>
  <sect1 xml:id="python-tutorial_kolay">
   <title>İştahınızı Kabartalım</title>
   <para>
    Eğer büyük bir kabuk betiği yazdıysanız neler olduğunu bilirsiniz. Bir
    özellik daha eklemek istersiniz; ancak yazılım yeterince büyük ve yavaş
    olmuştur ya da istediğiniz özelliğe sadece C aracılığıyla erişilebilir...
    Genellikle yazılım C ile baştan yazılmaya değecek önemde değildir ya da
    kabukta kolay olduğu halde C'de zor elde edilen özellikleri vardır. Belki
    de C ile yeterince iyi değilsiniz.
   </para>
   <para>
    Bir diğer durum düşünün: birkaç C kütüphanesi ile çalışmanız gerekiyor ve
    normal yaz/derle/dene/tekrar derle döngüsü çok yavaş geliyor ve daha hızlı
    yazılım geliştirmeye ihtiyacınız var. Belki de genişletilebilir bir yazılım
    yazacaksınız; ancak bunun için yeni bir dil tasarlayıp bunun için gerekli
    yorumlayıcıyı yazıp yazılımınıza ekleyeceksiniz.
   </para>
   <para>
    Bu gibi durumlarda Python tam aradığınız dil olabilir. Python kullanımı
    basit fakat gerçek bir dildir. Büyük yazılımlar için kabuktan daha uygundur
    ve C'den çok daha fazla hata denetimi yapar. Python <emphasis>çok yüksek
    seviyeli bir dil</emphasis> olup C ile verimli şekilde yazılması günler
    alabilecek yüksek seviyeli veri türlerine sahiptir (sözlükler ve listeler
    gibi). Daha genel veri türleri sayesinde Python <userinput>Awk</userinput>
    hatta <userinput>Perl</userinput>'den çok daha geniş bir yelpazede uygulama
    alanı bulabilir. Ayrıca Python'da pek çok şey en az o dillerdeki kadar
    kolaydır.
   </para>
   <para>
    Python ile yazılımlarınızı daha sonra diğer Python yazılımlarınızda tekrar
    kullanabileceğiniz modüllere ayırabilirsiniz. Python geniş bir standart
    modül kolleksiyonu ile size gelmektedir. Dosya giriş/çıkışı, ses, resim,
    matematiksel işlemler vs. ile ilgili modüller de vardır.
   </para>
   <para>
    Python yorumlanan bir dil olduğu için yazılım geliştirme sırasında size
    önemli miktarda zaman kazandırabilir. Çünkü derleme ve ilintileme gerekmemektedir.
    Yorumlayıcıyı etkileşimli olarak da kullanabilirsiniz; böylece dilin
    özelliklerini kolayca deneyebilir, hızlı bir şekilde küçük yazılımlar geliştirebilir,
    ya da aşağıdan-yukarı yazılım geliştirme sırasında işlevlerinizi test
    edebilirsiniz. Yorumlayıcı bir hesap makinesi olarak da kullanılabilir.
   </para>
   <para>
    Python ile son derece sıkı ve okunabilir yazılımlar geliştirebilirsiniz.
    Birkaç nedenden Python yazılımları eşdeğer C veya C++ yazılımlarından çok
    daha kısadır:
   </para>
   <itemizedlist>
    <listitem>
     <para>
      Yüksek seviyeli veri türleri ile karmaşık işlemler tek bir ifade ile yazılabilir.
     </para>
    </listitem>
    <listitem>
     <para>
      Deyimlerin gruplanması, başlama/bitme deyimleri (begin, end veya {} gibi) yerine blokların girintili yazılması ile sağlanır.
     </para>
    </listitem>
    <listitem>
     <para>
      Değişken veya bağımsız değişken bildirimlerinin yapılması gerekmez.
     </para>
    </listitem>
   </itemizedlist>
   <para>
    Python <emphasis>genişletilebilir</emphasis>: Eğer C yazılımlamayı
    biliyorsanız Python'a kolayca yeni modüller ekleyebilir ya da yazılımınızın
    hızlı çalışması gereken kısımlarını C ile yazabilirsiniz. C yazılımlarınıza
    da Python yorumlayıcısını bağlayabilir ve Python ile ek özellikler
    eklenebilen yazılımlar geliştirebilirsiniz.
   </para>
   <para>
    Python yazılımlama dili adını korkunç bir sürüngenden değil,
    `Monty Python's Flying Circus'' adlı bir BBC komedi dizisinden almıştır.
   </para>
   <para>
    Artık Python konusunda heyecanlandınız ve daha ayrıntılı olarak incelemek
    istiyorsunuz. Bir dili öğrenmenin en iyi yolu onu kullanmak olduğundan
    sizi Python kullanmaya davet ediyoruz.
   </para>
   <para>
    Bir sonraki bölümde yorumlayıcıyı kullanmayı öğreteceğiz. Bu çok basit
    bir şey; ancak daha sonraki bölümlerin anlaşılması için önemli.
   </para>
   <para>
    Kılavuzun devamında basit ifadeler, deyimler ve veri türleri ile başlayıp,
    işlevler ve modüllerden kullanıcı tanımlı sınıflar gibi gelişmiş konulara
    kadar Python'un çeşitli özellikleri örnekler ile anlatılmaktadır.
   </para>
  </sect1>
 </chapter>
 <chapter xml:id="python-tutorial_yorumlayici">
  <?dbhtml stop-chunking?>
  <title>Yorumlayıcının Kullanımı</title>
  <sect1 xml:id="python-tutorial_yorumlayici-run">
   <title>Yorumlayıcının Çalıştırılması</title>
   <para>
    Python yorumlayıcısını Linux Konsolunda ya da xterm'de <literal>python3</literal> komutunu girerek çalıştırabilirsiniz. Python yorumlayıcısının konsolda çalışanı olduğu gibi X Pencere Sisteminde çalışanı da vardır. X pencere sisteminde çalışan yorumlayıcı <literal>idle</literal> komutu ile çalıştırılabilir. Menüleriyle kolay kullanılabilen bir Python düzenleyicisidir ve konsolda çalışan <literal>python3</literal> gibi "Python Kabuğu" penceresinde doğrudan komut icra edilebilir.
  </para>
   <para>
    <literal>python3</literal> çalıştırıldığında yorumlayıcı konsolda etkileşimli kipte çalışır. Yorumlayıcı çalıştırılacak olan Python yazılımının dosya adı bağımsız değişken şeklinde verilerek de kullanılabilir. Örneğin <literal>python3 deneme.py</literal> gibi.
   </para>
   <sect2 xml:id="python-tutorial_int">
    <title>Etkileşimli Kip</title>
    <para>
     Komutların yorumlayıcıya satır satır girildiği duruma etkileşimli kip
     denir. Bu kipte birincil komut satırı <prompt>>>></prompt>
     şeklindeyken ikincil komut satırı <prompt>...</prompt> şeklinde
     görülür. Örneğin:
    </para>
    <screen>
<prompt>$</prompt> <userinput>python3</userinput>
Python 3.9.2 (default, Feb 28 2021, 17:03:44)
[GCC 10.2.1 20210110] on linux
Type "help", "copyright", "credits" or "license" for more information.
<prompt>>>></prompt>
</screen>
    <para>
     Birden fazla satırlık bloklar girildiğinde satırlar ikincil komut
     satırında girintili yazılır:
    </para>
    <screen>
<prompt>&gt;&gt;&gt;</prompt> dunya_duzdur = True
<prompt>&gt;&gt;&gt;</prompt> if dunya_duzdur:
<prompt>...</prompt>     print("Düşmemeye dikkat et!")
<prompt>...</prompt>
Düşmemeye dikkat et!
<prompt>&gt;&gt;&gt;</prompt>
</screen>
    <para>
     Yorumlayıcıdan çıkmak için <literal>ctrl+D</literal> tuşlayın.
     Etkileşimli kipte çalıştırılan yazılımlarda bir hata bulunması halinde
     yorumlayıcı bir hata mesajı basar ve birincil komut satırına döner:
    </para>
    <screen>
<prompt>&gt;&gt;&gt;</prompt> if dunya_duzdur:
<prompt>...</prompt> print("Düşmemeye dikkat et!")
  File "&lt;stdin&gt;", line 2
    print("Düşmemeye dikkat et!")
    ^
IndentationError: expected an indented block
<prompt>&gt;&gt;&gt;</prompt>
</screen>
    <para>
     Burada 2. satırın girintili yazılması gerektiği hatırlatılıyor.
    </para>
    <para>
     Ayrıca etkileşimli kipte ya da Python yazılımlarınızı yazarken komut
     satırı yerine daha rahat bir ortamda calışmak isteyebilirsiniz.
     Bunun için Python ile birlikte gelen <literal>idle</literal>'ı
     deneyebilirsiniz. <literal>idle</literal> Python ile yazılmış bir
     uygulama. Bazı <literal>idle</literal> komutları şöyledir:
    </para>
    <simplelist>
     <member>
      <command>Alt+p</command> Yazdığınız bir önceki komutu getirir.
     </member>
     <member>
      <command>Alt+n</command> Yazdığınız bir sonraki komutu getirir.
     </member>
     <member>
      <command>enter</command> Yazdığınız komutları çalıştırır.
     </member>
    </simplelist>
   </sect2>
   <sect2 xml:id="python-tutorial_yorumlayici-scripts">
    <title>Python Betikleri</title>
    <para>
     Kabuk betiklerine benzer şekilde Python betikleri de, dosyanın ilk
     satırına
    </para>
    <screen>#! /usr/bin/env python3</screen>
    <para>
     yazılarak ve dosyaya çalıştırma izni verilerek (<literal>chmod +x dosya.py</literal>) doğrudan kabuktan çalıştırılabilir.
    </para>
   </sect2>
   <sect2 xml:id="python-tutorial_yorumlayici-errors">
    <title>Hataların Yakalanması</title>
    <para>
     Bir hata oluştuğunda yorumlayıcı bir hata iletisi ve hatalı noktaya
     gelmeden önce yapılan işlev çağrılarının listesini basar.
    </para>
   </sect2>
  </sect1>
 </chapter>

 <chapter xml:id="python-tutorial_basliyoruz">
  <?dbhtml stop-chunking?>
  <title>Python'a Giriş</title>
  <para>
   Aşağıdaki örneklerde giriş ve çıkış, komut satırının varlığına veya
   yokluğuna (<literal>&gt;&gt;&gt; </literal> veya <literal>... </literal>)
   bağlıdır. Örnekleri tekrar etmek için komut satırında görünen her şeyi
   yazmalısınız. <literal>&gt;&gt;&gt; </literal> veya <literal>... </literal>
   ile başlamayan bütün satırlar yorumlayıcı çıktısını temsil eder.
   İkincil komut satırındaki boş bir satır (sadece "... ")) olan yerlerde
   bir şey yazmanıza gerek yok. O satırlar boş olup bir deyimler öbeğinin
   bitirilmesi için kullanılır. Bu kılavuzdaki alıştırmaların çoğu,
   etkileşimli komut satırına yazılanlar dahil, açıklamalar içerir.
   Python dilinde açıklamalar "#" ile başlarlar ve bulundukları satır
   sonuna kadar devam eder. Bir dizge içinde bulunan "#"
   işareti bir açıklama başlatmaz. Bu sadece bir "#" karakteridir. Örnekler:
  </para>
  <screen>
# Bu bir açıklama.
SAYI = 1 # ve bu ikinci açıklama
# ... bu da üçüncü!
DIZGE = "# Bu bir açıklama değil."
</screen>
  <sect1 xml:id="python-tutorial_calc">
   <title>Python'u Hesap Makinesi Olarak Kullanmak</title>
   <sect2><title>Sayılar</title>
    <para>
     Şimdi bazı basit komutlar deneyelim. Yorumlayıcıyı çalıştırın ve birincil
     komut satırının gelmesini bekleyin.
    </para>
    <para>
     Yorumlayıcı basit bir hesap makinesi olarak iş görürebilir: istediğiniz
     herhangi bir ifadeyi yazın ve yorumlayıcı sonucu verecektir. İşleçler
     ( +,-,*,/ ) çoğu yazılımlama dillerindekine benzer çalışır (Pascal ve
     C de olduğu gibi mesela). İfadeleri gruplamak için parantezler de
     kullanılabilir. Örnekler:
    </para>
    <screen>
<prompt>&gt;&gt;&gt;</prompt> 2+2
4
<prompt>&gt;&gt;&gt;</prompt> # Bu bir açıklama
<prompt>...</prompt> 2+2
4
<prompt>&gt;&gt;&gt;</prompt> 2+2 # bu da komutlarla aynı satırda bir açıklama
4
<prompt>&gt;&gt;&gt;</prompt> (50-5*6)/4
5
<prompt>&gt;&gt;&gt;</prompt> # Tam sayı bölme işlemlerinde ise:
<prompt>...</prompt> 7/3
2
<prompt>&gt;&gt;&gt;</prompt> 7/-3
-3
</screen>
    <para>
     C'de olduğu gibi eşit işareti ( <literal>=</literal> ) bir değişkene
     değer atamak için kullanılır. Atamanın değeri çıkışta yazılmaz:
    </para>
    <screen>
<prompt>&gt;&gt;&gt;</prompt> genislik = 20
<prompt>&gt;&gt;&gt;</prompt> yukseklik = 5*9
<prompt>&gt;&gt;&gt;</prompt> genislik * yukseklik
900
</screen>
    <para>
     Bir değer aynı anda birden fazla değişkene atanabilir:
    </para>
    <screen>
<prompt>&gt;&gt;&gt;</prompt> x = y = z = 5 # x, y ve z beş değerini alır
<prompt>&gt;&gt;&gt;</prompt> x
5
<prompt>&gt;&gt;&gt;</prompt> y
5
<prompt>&gt;&gt;&gt;</prompt> z
5
</screen>
    <para>
     Tam gerçel sayı desteği vardır. Farklı türdeki değerlerin olduğu
     işlemlerde sonuç gerçel sayıya dönüştürülür:
    </para>
    <screen>
<prompt>&gt;&gt;&gt;</prompt> 3 * 3.75 / 1.5
7.5
<prompt>&gt;&gt;&gt;</prompt> 7.0 / 2
3.5
</screen>
    <para>
     Karmaşık sayılar da desteklenmektedir. Sayıların sanal kısımları
     <literal>j</literal> veya <literal>J</literal> soneki ile yazılır.
     Gerçek kısmı sıfır olmayan karmaşık sayılar <literal>(gerçek +
     sanalj)</literal> şeklinde yazılırlar ya da
     <literal>complex(gerçek, sanal)</literal> işlevi ile kullanılır.
    </para>
    <screen>
<prompt>&gt;&gt;&gt;</prompt> 1j * 1J
(-1+0j)
<prompt>&gt;&gt;&gt;</prompt> 1j * complex(0,1)
(-1+0j)
<prompt>&gt;&gt;&gt;</prompt> 3+1j*3
(3+3j)
<prompt>&gt;&gt;&gt;</prompt> (3+1j)*3
(9+3j)
<prompt>&gt;&gt;&gt;</prompt> (1+2j)/(1+1j)
(1.5+0.5j)
</screen>
    <para>
     Karmaşık sayılar daima iki gerçel sayı ile ifade edilirler; biri
     gerçek diğer sanal kısım için. <literal>Z</literal> gibi bir karmaşık
     sayının gerçek ya da sanal kısımlarına erişmek için
     <literal>Z.real</literal> ve <literal>Z.imag</literal> kullanılır.
    </para>
    <screen>
<prompt>&gt;&gt;&gt;</prompt> a=1.5+0.5j
<prompt>&gt;&gt;&gt;</prompt> a.real
1.5
<prompt>&gt;&gt;&gt;</prompt> a.imag
0.5
</screen>
    <para>
     Tamsayı veya gerçel sayıya dönüştürme işlevleri (<literal>float()</literal>, <literal>int()</literal> ve <literal>long()</literal>) karmaşık sayılar için çalışmazlar; bir karmaşık sayıyı gerçek bir sayıya dönüştürmenin doğru bir yolu mevcut değildir. <literal>abs(z)</literal> ile karmaşık sayının büyüklüğünü ve <literal>z.real</literal> ile gerçek kısmını elde edebilirsiniz.
    </para>
    <screen>
<prompt>&gt;&gt;&gt;</prompt> a=3.0+4.0j
<prompt>&gt;&gt;&gt;</prompt> float(a)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
TypeError: can't convert complex to float; use e.g. abs(z)
<prompt>&gt;&gt;&gt;</prompt> a.real
3.0
<prompt>&gt;&gt;&gt;</prompt> a.imag
4.0
<prompt>&gt;&gt;&gt;</prompt> abs(a)  # sqrt(a.real**2 + a.imag**2)
5.0
<prompt>&gt;&gt;&gt;</prompt>
</screen>
    <para>
     Etkileşimli kipte son yazdırılan değer <literal>_</literal> değişkenine
     atanır. Yani Python'u hesap makinesi olarak kullanırken bazen işlemlere
     şu şekilde devam etmek daha kolaydır:
    </para>
    <screen>
<prompt>&gt;&gt;&gt;</prompt> vergi= 17.5 / 100
<prompt>&gt;&gt;&gt;</prompt> fiyat= 3.50
<prompt>&gt;&gt;&gt;</prompt> fiyat * vergi
0.61249999999999993
<prompt>&gt;&gt;&gt;</prompt> fiyat + _
4.1124999999999998
<prompt>&gt;&gt;&gt;</prompt> round(_, 2)
4.1100000000000003
<prompt>&gt;&gt;&gt;</prompt>
</screen>
    <para>
     Bu değişken ( <literal>_</literal> ) kullanıcı tarafından salt okunur
     olarak kabul edilmelidir. Buna kasıtlı olarak değer atamayın. Bu aynı
     isimli bir yerel değişken yaratır.
    </para>
   </sect2>
   <sect2><title>Dizgeler</title>
    <para>
     Sayılara ek olarak, Python dizgeler üzerinde de işlemler yapabilir.
     Dizgeler farklı şekillerde ifade edilebilir. Tek veya çift tırnak
     işareti içine alınabilirler:
    </para>
    <screen>
<prompt>&gt;&gt;&gt;</prompt> 'dizge'
'dizge'
<prompt>&gt;&gt;&gt;</prompt> "Python\'un gücü"
"Python'un gücü"
<prompt>&gt;&gt;&gt;</prompt> "doesn't"
"doesn't"
<prompt>&gt;&gt;&gt;</prompt> '"Yes," he said.'
'"Yes," he said.'
<prompt>&gt;&gt;&gt;</prompt> "\"Yes,\" he said."
'"Yes," he said.'
<prompt>&gt;&gt;&gt;</prompt> '"Isn\'t," she said.'
'"Isn\'t," she said.'
</screen>
    <para>
     Dizgeler birkaç şekilde birden fazla satıra yayılabilir. Yeni
     satırlar ters eğik çizgi ile şöyle gösterilebilirler:
    </para>
    <screen>
<prompt>&gt;&gt;&gt;</prompt> merhaba = "Bu C de de kullandığınıza benzer\n\
<prompt>...</prompt> birkaç satır kaplayan bir dizge.\n\
<prompt>...</prompt>     Bu satırın başındaki \
<prompt>...</prompt> girintinin belirgin olduğuna \
<prompt>...</prompt> dikkat edin\n"
<prompt>&gt;&gt;&gt;</prompt> print merhaba
</screen>
    <para>ve bu şu çıktıyı verir:</para>
    <screen>
Bu C de de kullandığınıza benzer
birkaç satır kaplayan bir dizge.
        Bu satırın başındaki girintinin belirgin olduğuna dikkat edin

<prompt>&gt;&gt;&gt;</prompt>
</screen>
    <para>
     Karakter dizisini <literal>r</literal> ile imleyerek <emphasis>ham
     dizge</emphasis> yapacak olursak, <literal>\n\</literal> karakterleri
     yorumlanmaz, dizgenin bir parçası haline gelir. Örneğin:
    </para>
    <screen>
merhaba = r"Bu C de de kullandığınıza benzer\n\
birkaç satır kaplayan bir karakter dizisi."

print merhaba
</screen>
    <para>şu çıktıyı verir:</para>
    <screen>
Bu C de de kullandığınıza benzer\n\
birkaç satır kaplayan bir karakter dizisi.
</screen>
    <para>
     Karakter dizileri bir çift üçlü tırnak içinde de gösterilebilirler:
     Dizgeler bir çift üçlü tırnak içinde de gösterilebilirler:
     <literal>"""</literal> veya <literal>'''</literal>. Bu
     gösterim şeklinde satır sonlarının <literal>\n</literal>
     ile gösterilmesine gerek yoktur ve onlar olmadan da yeni
     satırlar doğru şekilde görünür. Örnek:
    </para>
    <screen>
print """
Kullanım şekli : seninprog [SEÇENEKLER]
     -y     Bu yardım mesajını görüntüler
     -S     bağlanılacak sunucu adı
"""
</screen>
    <para>ifadesi şu çıktıyı verir:</para>
    <screen>Kullanım şekli : seninprog [SEÇENEKLER]
     -y     Bu yardım mesajını görüntüler
     -S     bağlanılacak sunucu adı
</screen>
    <para>
     Yorumlayıcı dizge işlemlerinin sonucunu girişine yazıldığı şekli
     ile çıkışa yazar. Dizgeler <literal>+</literal> işleçi
     ile birleştirilip, <literal>*</literal> ile tekrarlanabilir:
    </para>
    <screen>
kelime = 'Alo' + 'ooo'
<prompt>&gt;&gt;&gt;</prompt> kelime
'Aloooo'
<prompt>&gt;&gt;&gt;</prompt> '&lt;' + kelime*5 + '&gt;'
'&lt;AlooooAlooooAlooooAlooooAloooo&gt;'
</screen>
    <para>
     Yan yana iki dizge değişkeni otomatik olarak birleştirilir yani
     yukarıdaki örnekteki ilk satır <literal>kelime = 'Alo' 'ooo'</literal>
     şeklinde de yazılabilirdi. Bu sadece iki dizge değişkeni ile olur.
     Keyfî dizgeler arasında olamaz:
    </para>
    <screen>
import string
<prompt>&gt;&gt;&gt;</prompt> 'str' 'ing' # &lt;- Bu doğru
'string'
<prompt>&gt;&gt;&gt;</prompt> string.strip('str') + 'ing' # &lt;- Bu da doğru
'string'
<prompt>&gt;&gt;&gt;</prompt> string.strip('str') 'ing' # &lt;- Bu geçersız !!!
File "&lt;stdin&gt;", line 1, in ?
string.strip('str') 'ing'
                        ^
SyntaxError: invalid syntax
</screen>
    <para>
     C'de olduğu gibi, Python'da da dizgeler indislenebilir.
     Dizgenin ilk karakterinin indisi sıfırdır. Python'da ayrı bir karakter
     veri türü yoktur. Bir karakter tek karakterli bir dizgedir. Icon
     dilinde (70'li yıllarda Ralph ve Marge Griswold'ün geliştirdiği Pascal
     benzeri bir SNOBOL4 türevi) olduğu gibi dizgelerin bölümleri
     dilim gösterimi <literal>[ : ]</literal> ile ifade edilebilir.
    </para>
    <screen>
<prompt>&gt;&gt;&gt;</prompt> kelime[4]
'o'
<prompt>&gt;&gt;&gt;</prompt> kelime[0:2]
'Al'
<prompt>&gt;&gt;&gt;</prompt> kelime[2:4]
'oo'
</screen>
    <para>
     C dilinden farklı olarak, Python'da dizgeler değiştirilemez.
     Bir dizgenin indislenen bir konumuna değer atamaya çalışmak hatadır:
    </para>
    <screen>
<prompt>&gt;&gt;&gt;</prompt> kelime[0] = 'x'
Traceback (most recent call last):
File "&lt;stdin&gt;", line 1, in ?
TypeError: object doesn't support item assignment
<prompt>&gt;&gt;&gt;</prompt> kelime[:1] = 'Splat'
Traceback (most recent call last):
File "&lt;stdin&gt;", line 1, in ?
TypeError: object doesn't support slice assignment
</screen>
    <para>
     Yukarıdaki soruna elde edilmek istenen dizge için yeni bir karakter
     dizisi oluşturularak çözüm bulunabilir. Bu kolay ve etkilidir:
    </para>
    <screen>
'x' + kelime[1:]
'xloooo'
<prompt>&gt;&gt;&gt;</prompt> 'Splat' + kelime[4]
'Splato'
</screen>
    <para>
     Dilimlerin varsayılan başlangıç ve bitiş değerleri oldukça kullanışlıdır.
     Başlangıç değeri yoksa sıfır kabul edilir ve eğer bitiş değeri yoksa
     dilimlenen dizgenin boyu kadar olduğu kabul edilir. Örnekler:
    </para>
    <screen>
<prompt>&gt;&gt;&gt;</prompt> kelime[:2] # İlk iki karakter
'Al'
<prompt>&gt;&gt;&gt;</prompt> kelime[2:] # İlk iki karakter dışındaki karakterler
'oooo'
</screen>
    <para>
     <literal>s[:i] + s[i:] = s</literal> olup dilimleme işlemlerinin
     kullanışlı bir şeklidir. Örnek:
    </para>
    <screen>
<prompt>&gt;&gt;&gt;</prompt> kelime[:2] + kelime[2:]
'Aloooo'
<prompt>&gt;&gt;&gt;</prompt> kelime[:3] + kelime[3:]
'Aloooo'
</screen>
    <para>
     Çok büyük veya küçük dilim aralıkları akıllıca ele alınır. Bitiş değeri
     büyük ise bunun boyu dizgenin boyuna eşit olur. Başlangıç
     değeri bitişten büyük ise boş bir dizge elde edilir.
    </para>
    <screen>
<prompt>&gt;&gt;&gt;</prompt> kelime[1:100]
'loooo'
<prompt>&gt;&gt;&gt;</prompt> kelime[10:]
''
<prompt>&gt;&gt;&gt;</prompt> kelime[2:1]
''
</screen>
    <para>
     İndisler negatif sayılar da olabilir. Bu durumda saymaya sağ
     taraftan başlanır.
    </para>
    <screen>
<prompt>&gt;&gt;&gt;</prompt> kelime[-1] # Son karakter
'o'
<prompt>&gt;&gt;&gt;</prompt> kelime[-2] # Sondan ikinci
'o'
<prompt>&gt;&gt;&gt;</prompt> kelime[-2:] # Son iki karakter
'oo'
<prompt>&gt;&gt;&gt;</prompt> kelime[:-2] # Son iki karakter dışındaki karakterler
'Aloo'
</screen>
    <para>
     -0 ın 0 ile aynı olduğuna dikkat edin; yani yine soldan sayar!
    </para>
    <screen>
<prompt>&gt;&gt;&gt;</prompt> kelime[-0] # (-0 = 0 olduğundan)
'A'
</screen>
    <para>
     Sınır dışındaki negatif dilim indisleri küçültülürler; fakat bunu
     dilim olmayan tek bir indis ile denemeyin:
    </para>
    <screen>
<prompt>&gt;&gt;&gt;</prompt> kelime[-100:]
'Aloooo'
<prompt>&gt;&gt;&gt;</prompt>; kelime[-10] # hata !
Traceback (most recent call last):
File "&lt;stdin&gt;", line 1
IndexError: string index out of range
</screen>
    <para>
     Dilimlerin nasıl çalıştığını hatırlamanın en iyi yolu indislerin
     karakterler arasını işaret ettiğini düşünmektir; şu şekilde bu daha
     iyi görülebilir:
    </para>
    <screen>
 +---+---+---+---+---+
 | H | e | l | p | A |
 +---+---+---+---+---+
 0   1   2   3   4   5
-5  -4  -3  -2  -1
</screen>
    <para>
     Negatif olmayan indisler için dilim boyu indisler arası fark kadardır.
     Örneğin kelime[1:3] diliminin boyu 2 dir.
    </para>
    <para>
     Yerleşik işlev <literal>len()</literal> bir dizgenin boyunu verir.
    </para>
    <screen>
<prompt>&gt;&gt;&gt;</prompt> s = 'ArrestedDevelopmentZingalamaduni'
<prompt>&gt;&gt;&gt;</prompt> len(s)
32
</screen>
   </sect2>
   <sect2><title>Listeler</title>
    <para>
     Python'da diğer veri türlerini bir gruba almayı sağlayan birkaç bileşik veri
     türü vardır. Bunların en kullanışlı olanlarından biri listelerdir. Listeler
     kare parantez içinde virgül ile birbirinden ayrılmış değerlerden (eleman)
     oluşur. Liste elemanlarının aynı türden olması gerekmez.
    </para>
    <screen>
<prompt>&gt;&gt;&gt;</prompt> a = ['salam', 'zeytin', 100, 1234]
<prompt>&gt;&gt;&gt;</prompt> a
['salam', 'zeytin', 100, 1234]
</screen>
    <para>
     Listeler de dizgeler gibi indislenebilir. İndisler sıfırdan başlar.
     Listeler dilimlenebilir, birleştirilebilir vs...
    </para>
    <screen><prompt>&gt;&gt;&gt;</prompt> a[0]
'salam'
<prompt>&gt;&gt;&gt;</prompt> a[3]
1234
<prompt>&gt;&gt;&gt;</prompt> a[-2]
100
<prompt>&gt;&gt;&gt;</prompt> a[1:-1]
['zeytin',100]
<prompt>&gt;&gt;&gt;</prompt> a[:2] + ['yumurta', 2*2]
['salam','zeytin', 'yumurta', 4]
<prompt>&gt;&gt;&gt;</prompt> 3*a[:3] + ['Oley!']
['salam', 'zeytin', 100, 'salam', 'zeytin', 100, 'salam', 'zeytin', 100, 'Oley!']
</screen>
    <para>
     Değiştirilemez (mutable) olan dizgelerin aksine, listelerin her bir
     elemanı değiştirilebilir:
    </para>
    <screen>
<prompt>&gt;&gt;&gt;</prompt> a
['salam', 'zeytin', 100, 1234]
<prompt>&gt;&gt;&gt;</prompt> a[2] = a[2] + 23
<prompt>&gt;&gt;&gt;</prompt> a
['salam', 'zeytin', 123, 1234]
</screen>
    <para>
     Liste dilimlerine de atama yapılabilir ve bu listenin boyunu da
     değiştirilebilir.
    </para>
    <screen>
<prompt>&gt;&gt;&gt;</prompt>
# Bazı elemanları değiştir:
<prompt>...</prompt> a[0:2] = [1, 12]
<prompt>&gt;&gt;&gt;</prompt> a
[1, 12, 123, 1234]
<prompt>&gt;&gt;&gt;</prompt> # Bazı elemanları sil:
<prompt>...</prompt> a[0:2] = []
<prompt>&gt;&gt;&gt;</prompt> a
[123, 1234]
&gt;&gt;&gt; # Listenin içine elemanlar ekle:
<prompt>...</prompt> a[1:1] = ['bletch', 'xyzzy']
<prompt>&gt;&gt;&gt;</prompt> a
[123, 'qwerty', 'xyzzy', 1234]
<prompt>&gt;&gt;&gt;</prompt> a[:0] = a # Listenin kopyasını listenin başına ekle
<prompt>&gt;&gt;&gt;</prompt> a
[123, 'qwerty', 'xyzzy', 1234, 123, 'qwerty', 'xyzzy', 1234]
</screen>
    <para>
     Yerleşik işlev <literal>len()</literal> listeler ile de çalışır:
    </para>
    <screen>
<prompt>&gt;&gt;&gt;</prompt> len(a)
8
</screen>
    <para>İç içe listeler yaratılabilir. Örnek:</para>
    <screen>
<prompt>&gt;&gt;&gt;</prompt> q = [2, 3]
<prompt>&gt;&gt;&gt;</prompt> p = [1, q, 4] # buradaki q üst satırda tanımlanan listedir
<prompt>&gt;&gt;&gt;</prompt> len(p)
3
<prompt>&gt;&gt;&gt;</prompt> p[1]
[2, 3]
<prompt>&gt;&gt;&gt;</prompt> p[1][0]
2
<prompt>&gt;&gt;&gt;</prompt> p[1].append('xtra')     # append daha sonra açıklanacak
<prompt>&gt;&gt;&gt;</prompt> p
[1, [2, 3, 'xtra'], 4]
<prompt>&gt;&gt;&gt;</prompt> q
[2, 3, 'xtra']
</screen>
    <para>
     Üstteki örnekte <literal>p[1]</literal> ve <literal>q</literal>'nun
     aynı nesne olduğuna dikkat edin!
    </para>
   </sect2>
  </sect1>
  <sect1 xml:id="python-tutorial_ilkler">
   <title>Programlamaya Doğru İlk Adımlar</title>
   <para>
    Tabii ki Python kullanarak iki ile ikiyi toplamaktan daha karmaşık işler
    yapabiliriz. Mesela bir Fibonacci serisini şöyle yazabiliriz:
   </para>
   <screen>
<prompt>&gt;&gt;&gt;</prompt> # Fibonacci serisi:
<prompt>...</prompt> # iki elemanın toplamı bir sonraki elemanı verir
<prompt>...</prompt> a, b = 0, 1
<prompt>&gt;&gt;&gt;</prompt> while b &lt; 10:
<prompt>...</prompt>     print b
<prompt>...</prompt>     a, b = b, a+b
<prompt>...</prompt>
1
1
2
3
5
8
</screen>
   <para>
    Bu örnekte birkaç yeni özellik gösterilmektedir:
   </para>
   <itemizedlist>
    <listitem>
     <para>
      İlk satırda bir <emphasis>çoklu değer atama</emphasis> var; a ve b
      değişkenleri bir anda 0 ve 1 değerlerini alır. Bu özellik son
      satırda da kullanılmaktadır. Son satırda dikkat çeken bir diğer
      olay da ifadenin sağ kısmının soldan sağa doğru atama işlemlerinden
      önce hesaplandığıdır.
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>while</literal> döngüsü, verilen koşul (burada: b &lt; 10)
      doğru olduğu sürece tekrarlanır. Python'da, C'de olduğu gibi,
      sıfır dışındaki herhangi bir değer doğru ve sıfır yanlış kabul
      edilir. Koşul bir dizge veya liste de olabilir. Boyu sıfır olmayan
      her şey doğru iken, boş listeler, dizgeler, vs yanlış kabul edilir.
     </para>
     <para>
      Üstteki örnekte basit bir kıyaslama işlemi var. Standart kıyaslama
      işlemleri C'de olduğu gibi yazılır: &lt; (küçük), &gt; (büyük), ==
      (eşit), &lt;= (küçük eşit), &gt;= (büyük eşit), != (eşit değil).
     </para>
    </listitem>
    <listitem>
     <para>
      Döngü bloğu girinitli yazılmıştır. Girintili yazma Python'un ifadeleri
      gruplama yoludur. Etkileşimli kipte girintili bir öbek yazıldığı zaman
      boş bir satır ile sonlandırılmalıdır (çünkü yorumlayıcı yazmayı ne zaman
      bıraktığınızı bilemez). Grintili bir öbek içindeki her satırın aynı
      girinti miktarına sahip olması gerektiğine dikkat ediniz. Girintiler
      için boşluk veya sekme karakterleri kullanılabilir.
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>print</literal> deyimi kendisine verilen ifadenin veya
       ifadelerin değerini yazar. Birden fazla ifade verilmesi durumunda
       bunlar aralarında boşluk ile yazılır:
      </para>
      <screen>
<prompt>&gt;&gt;&gt;</prompt> i = 256*256
<prompt>&gt;&gt;&gt;</prompt> print 'İşlemin sonucu:', i
İşlemin sonucu: 65536
</screen>
     <para>
      Sona eklenen bir virgül ise çıktı satırından sonra yeni satıra
      geçilmesini engeller:
     </para>
     <screen>
<prompt>&gt;&gt;&gt;</prompt> a, b = 0, 1
<prompt>&gt;&gt;&gt;</prompt> while b &lt; 1000:
<prompt>...</prompt>     print b,
<prompt>...</prompt>     a, b = b, a+b
<prompt>...</prompt>
1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987
</screen>
    </listitem>
   </itemizedlist>
  </sect1>
 </chapter>

  <chapter xml:id="python-tutorial_akis-denetimi">
  <?dbhtml stop-chunking?>
  <title>Akış Denetimi</title>
  <para>
   Bir önceki bölümde tanıtılan <literal>while</literal> deyiminin yanısıra
   Python'da diğer yazılımlama dillerinde de bulunan genel akış denetim
   deyimleri (bazı farklarla birlikte) vardır.
  </para>
  <sect1 xml:id="python-tutorial_if">
   <title><literal>if</literal> Deyimi</title>
   <para>
    Belki de en iyi bilinen deyim türü <literal>if</literal> deyimidir. Örnek:
   </para>
   <screen>
<prompt>&gt;&gt;&gt;</prompt> x = int(raw_input("Lütfen bir sayı girin: "))
<prompt>&gt;&gt;&gt;</prompt> if x &lt; 0:
<prompt>...</prompt>      x = 0
<prompt>...</prompt>      print 'Negatif sayı sıfırlandı'
<prompt>...</prompt> elif x == 0:
<prompt>...</prompt>      print 'Sıfır'
<prompt>...</prompt> elif x == 1:
<prompt>...</prompt>      print 'Bir'
<prompt>...</prompt> else:
<prompt>...</prompt>      print 'Birden büyük'
<prompt>...</prompt>
</screen>
   <para>
    Sıfır veya daha fazla <literal>elif</literal> deyimi olabilir, ve
    <literal>else</literal> deyimi seçimliktir. <literal>elif</literal>
    deyimi <literal>else if</literal> deyiminin kısaltılmışıdır ve aşırı
    girintileri engellemesi açısından faydalıdır. Bir <literal>if ... elif
    ... elif ...</literal> deyimleri dizisi diğer dillerde bulunan
    <literal>switch</literal> veya <literal>case</literal> deyimlerinin
    yerine kullanılabilir.
   </para>
  </sect1>
  <sect1 xml:id="python-tutorial_for">
   <title><literal>for</literal> Deyimi</title>
   <para>
    <literal>for</literal> deyimi Pascal veya C dillerinde görülenden biraz
    farklıdır. Python'daki <literal>for</literal> deyimi herhangi bir sıranın
    (liste, dizge, vs.) elemanları üzerinde sırayla yinelenir. Örnek:
   </para>
   <screen>
<prompt>&gt;&gt;&gt;</prompt> # Bazı dizgelerin boylarını ölçelim:
<prompt>...</prompt> a = ['kedi', 'pencere', 'kertenkele']
<prompt>&gt;&gt;&gt;</prompt> for x in a:
<prompt>...</prompt>     print x, len(x)
<prompt>...</prompt>
kedi 4
pencere 7
kertenkele 10
</screen>
   <para>
    Üzerinde yinelenilen sırada değişiklik yapmak güvenli değildir
    (bu sadece listelerde olabilir). Eğer böyle bir şey yapacaksanız
    bu iş için dilim gösterimi ile listenin bir kopyasını
    kullanabilirsiniz:
   </para>
   <screen>
<prompt>&gt;&gt;&gt;</prompt> for x in a[:]: # tüm listenin bir kopyasını oluştur
<prompt>...</prompt> if len(x) &gt; 8: a.insert(0, x)
<prompt>...</prompt>
<prompt>&gt;&gt;&gt;</prompt> a
['kertenkele', 'kedi', 'pencere', 'kertenkele']
</screen>
  </sect1>
  <sect1 xml:id="python-tutorial_range">
   <title><literal>range()</literal> işlevi</title>
   <para>
    Eğer bir sayı sırası üzerinde tekrarlamalar yapmak isterseniz, belirli
    bir sıraya göre üretilen sayılardan oluşan bir liste oluşturan
    <literal>range()</literal> yerleşik işlevini kullanabilirsiniz.
    Örnek:
   </para>
   <screen>
<prompt>&gt;&gt;&gt;</prompt> range(10)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</screen>
   <para>
    Verilen bitiş noktası asla üretilen listenin bir parçası olmaz;
    <literal>range(10)</literal> ifadesi 10 elemanı olan bir liste oluşturur.
    Listenin başlayacağı sayıyı ve artış miktarını da belirlemek mümkündür.
    Artış miktarı negatif de olabilir.
   </para>
   <screen>
<prompt>&gt;&gt;&gt;</prompt> range(5, 10)
[5, 6, 7, 8, 9]
<prompt>&gt;&gt;&gt;</prompt> range(0, 10, 3)
[0, 3, 6, 9]
<prompt>&gt;&gt;&gt;</prompt> range(-10, -100, -30)
[-10, -40, -70]
</screen>
   <para>
    <literal>range()</literal> ve <literal>len()</literal> işlevlerini bir
    arada kullanarak da bir listenin elemanları üzerinde döngüler
    kurabilirsiniz:
   </para>
   <screen>
<prompt>&gt;&gt;&gt;</prompt> a = ['Python', 'yazılımlama', 'öğrenmek', 'çok', 'kolay !']
<prompt>&gt;&gt;&gt;</prompt> for i in range(len(a)):
<prompt>...</prompt>     print i, a[i]
<prompt>...</prompt>
0 Python
1 yazılımlama
2 öğrenmek
3 çok
4 kolay
</screen>
  </sect1>
  <sect1 xml:id="python-tutorial_break">
   <title>Döngülerde <literal>break</literal>, <literal>continue</literal>
    ve <literal>else</literal> Deyimleri</title>
   <para>
    <literal>break</literal> deyimi, C'de olduğu gibi, içinde kaldığı en küçük
    <literal>for</literal> veya <literal>while</literal> döngüsünden
    çıkılmasına ve döngü deyiminin tamamen sona ermesine neden olur.
   </para>
   <para>
    <literal>continue</literal> deyimi döngü içindeki diğer deyimlerin
    atlanıp bir sonraki yineleme işleminin başlamasına sebep olur.
   </para>
   <para>
    Döngülerde <literal>else</literal> ifadesi de kullanılabilir;
    <literal>else</literal> bloğu döngü bittiğinde (<literal>for</literal>
    için) veya devamlılık koşulu geçersiz olduğunda (<literal>while</literal>
    için) işletilir; fakat döngü <literal>break</literal> deyimi ile sona
    erdiyse işletilmez. Bunu asal sayılar bulan aşağıdaki örnekte görebilirsiniz:
   </para>
   <screen>
<prompt>&gt;&gt;&gt;</prompt> for n in range(2, 10):
<prompt>...</prompt>     for x in range(2, n):
<prompt>...</prompt>         if n % x == 0:
<prompt>...</prompt>            print n, 'asal sayı değil. çarpanlar:', x, '*', n/x
<prompt>...</prompt>            break
<prompt>...</prompt>     else:
<prompt>...</prompt>          # çarpan bulunmadan döngü biter ise
<prompt>...</prompt>          print n, 'asal sayıdır'
<prompt>...</prompt>
2 asal sayıdır
3 asal sayıdır
4 asal sayı değil. çarpanlar: 2 * 2
5 asal sayıdır
6 asal sayı değil. çarpanlar: 2 * 3
7 asal sayıdır
8 asal sayı değil. çarpanlar: 2 * 4
9 asal sayı değil. çarpanlar: 3 * 3
</screen>
  </sect1>
  <sect1 xml:id="python-tutorial_pass">
   <title><literal>pass</literal> Deyimi</title>
   <para>
    <literal>pass</literal> deyimi hiçbir şey yapmaz. Python sözdizim
    kurallarına göre bir ifadenin gerekli olduğu, fakat yazılımın bir
    şey yapması gerekmediği zaman kullanılabilir:
   </para>
   <screen>
<prompt>&gt;&gt;&gt;</prompt> while 1:
<prompt>...</prompt>       pass # klavyeden CTRL+C ile kesilene kadar sürer
<prompt>...</prompt>
</screen>
  </sect1>
  <sect1 xml:id="python-tutorial_func">
   <title>İşlev Tanımlama</title>
   <para>
    Herhangi bir değere kadar Fibonacci serisi yazan bir işlev yazalım:
   </para>
   <screen>
<prompt>&gt;&gt;&gt;</prompt> def fib(n):     # n'e kadar Fibonacci serisini yazdır
<prompt>...</prompt>     "n'e kadar Fibonacci serisini yazdır"
<prompt>...</prompt>     a, b = 0, 1
<prompt>...</prompt>     while b &lt; n:
<prompt>...</prompt>         print b,
<prompt>...</prompt>         a, b = b, a+b
<prompt>...</prompt>
<prompt>&gt;&gt;&gt;</prompt> # Tanımladığımız işlevi çağıralım:
<prompt>...</prompt> fib(2000)
1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597
</screen>
   <para>
    <literal>def</literal> anahtar kelimesi bir işlev tanımını başlatır.
    Bu deyimden sonra bir işlev adı ve parantez içinde bağımsız değişkenler yazılır.
    İşlevin gövdesini oluşturan yazılım satırları sonraki satırdan itibaren
    girintili olarak yazılır. İşlev gövdesinin ilk satırı bir dizge de
    olabilir; bu dizge işlevin belgelenmesinde kullanılır (docstring).
   </para>
   <para>
    İşlevlerin belgelenmesinde kullanılan dizgeleri (docstring) otomatik
    olarak çevrim içi ya da basılı belgeler oluşturmak için kullanan
    yazılımlar vardır. Ayrıca bazı geliştirme ortamları bunları yazılım
    yazarken kolaylık sağlaması için etkileşimli olarak yazılımcıya
    sunar. Yazdığınız işlevlere bunları eklemeyi bir alışkanlık haline
    getirmeniz faydalı olur.
   </para>
   <para>
    Bir işlevin çağrılması (çalıştırılması) bu işlevdeki yerel değişkenlerin
    olduğu bir simge tablosu oluşturur. İşlev içerisinde bütün değer atama
    işlemlerinde değerler yerel simge tablosuna kaydedilir. Bir değişkene
    başvuru durumunda ise önce yerel (local), sonra genel (global) ve en son
    yerleşik (built-in) simge tablosunda arama yapılır. Bu yüzden genel
    değişkenlere doğrudan değer atama yapılamaz (eğer
    <literal>global</literal> ifadesi içinde kullanılmamışlar ise); ancak
    bunlara başvuru yapılabilir (reference).
   </para>
   <para>
    İşlev çağırıldığında işlevin bağımsız değişkenleri yerel simge tablosuna
    eklenir; yani bağımsız değişkenler işleve değeri ile çağrı (call by value)
    kullanılarak iletilir (yani bağımsız değişkene yapılan değişiklikler
    yereldir, çağıran işlevdeki bağımsız değişkenlerde bir değişme
    olmaz).<footnote>
    <para>
     Aslında nesne başvurusu ile çağrı daha iyi bir tanım olur, çünkü
     işleve değiştirilebilir bir nesne aktarılırsa çağıran çağrılanın o
     nesneye uyguladığı tüm değişiklikleri görür (listeye eklenen
     elemanlar gibi).
    </para></footnote>
   </para>
   <para>
    Bir işlev başka bir işlevi çağırdığında bu çağrı için yeni bir yerel simge
    tablosu oluşturulur.
   </para>
   <para>
    Bir işlev tanımı işlev adının yürürlükte olan simge tablosuna eklenmesine
    sebep olur. İşlevin adı yorurumlayıcı tarafından kullanıcı tanımlı işlev
    veri türü olarak tanınır. Bu değer başka bir isime atanabilir ve bu da bir
    işlev olarak kullanılabilir. Bu genel bir isim değiştirme yolu olabilir:
   </para>
   <screen>
<prompt>&gt;&gt;&gt;</prompt> fib
&lt;function object at 10042ed0&gt;
<prompt>&gt;&gt;&gt;</prompt> f = fib # f de fib işlevi olur
<prompt>&gt;&gt;&gt;</prompt> f(100)
1 1 2 3 5 8 13 21 34 55 89
</screen>
   <para>
    <literal>fib</literal>'in bir işlev olmayıp bir yordam (procedure)
    olduğunu düşünebilirsiniz. Python'da yordamlar, çağıran işleve
    değer geri döndürmeyen işlevlerdir. Aslında yordamlar da bir değer
    geri döndürürler, ama bu sıkıcı bir konudur. Bu değere
    <literal>None</literal> denir ve yerleşik bir değişkendir.
    Yorumlayıcı yazılacak tek değer bu ise normalde <literal>None</literal>
    yazmaz. Bunu görmeyi çok istiyorsanız şunu deneyin:
   </para>
   <screen>
<prompt>&gt;&gt;&gt;</prompt> print fib(0)
None
</screen>
   <para>
    Fibonacci serisini yazdırmak yerine, bunu bir liste şeklinde geri
    döndüren işlev yazmak basittir:
   </para>
   <screen>
<prompt>&gt;&gt;&gt;</prompt> def fib2(n): # n e kadar fibonacci serisi geri döndürür
<prompt>...</prompt>     " n e kadar fibonacci serisi içeren liste geri döndürür"
<prompt>...</prompt>     sonuc = []
<prompt>...</prompt>     a, b = 0, 1
<prompt>...</prompt>     while b &lt; n:
<prompt>...</prompt>         sonuc.append(b)    # değeri listeye ekle
<prompt>...</prompt>         a, b = b, a+b
<prompt>...</prompt>     return sonuc
<prompt>...</prompt>
<prompt>&gt;&gt;&gt;</prompt> f100 = fib2(100)    # işlevi çağır
<prompt>&gt;&gt;&gt;</prompt> f100                # sonucu yazdır
[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
</screen>
   <para>
    Bu örnekte de bazı yeni Python özelliklerini görüyoruz:
   </para>
   <itemizedlist>
    <listitem>
     <para>
      <literal>return</literal> deyimi bir işlevden değer geri döndürür.
      Bağımsız değişkeni olmayan bir <literal>return</literal> deyimi
      <literal>None</literal> geri döndürür. Sona eren bir yordam
      (procedure) da <literal>None</literal> geri döndürür.
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>sonuc.append(b)</literal> ifadesi sonuç liste nesnesinin
      bir yöntemini çağırmaktadır. Bir yöntem bir nesneye `ait olan' ve
      <literal>nesne.yöntemAdı</literal> şeklinde adlandırılan bir
      işlevdir. <literal>nesne.yöntemAdı</literal> ifadesinde nesne
      herhangi bir nesne (bir ifade de olabilir) ve <literal>yöntemAdı</literal>
      da nesnenin türüne bağlı bir yöntemdir. Farklı veri türleri farklı
      yöntemlere sahiptir. Farklı veri türlerinin ayni isimli
      yöntemleri olabilir. Sonraki bölümlerde anlatılacağı gibi, kendi
      veri türlerinizi ve yöntemlerinizi oluşturmanız mümkündür.
      Yukarıdaki örnekte görülen <literal>append()</literal> yöntemi
      liste nesneleri için tanımlıdır ve bir listenin sonuna yeni
      elemanlar ekler. Bu örnekte bu <literal>sonuc = sonuc + [b]</literal>
      ifadesinin yaptığını yapar; ancak daha verimlidir.
     </para>
    </listitem>
   </itemizedlist>
  </sect1>
  <sect1 xml:id="python-tutorial_func-more">
   <title>İşlev Tanımları Üzerine Daha Fazla Bilgi</title>
   <para>
    Değişken sayıda bağımsız değişken alan işlevler tanımlamak da mümkündür.
    Bunun için kullanılan üç yöntem olup bunlar birleştirilerek
    kullanılabilir.
   </para>
   <sect2>
    <title>Bağımsız Değişken Değerlerini Önceden Belirleme</title>
    <para>
     İşlev bağımsız değişkenlerine öntanımlı değerler atamak da mümkündür.
     Böylece çağıran işlev bu bağımsız değişkenleri sağlamazsa bunlar önceden
     belirlenmiş öntanımlı değerlerini alır. Örnek:
    </para>
    <screen>
def onay_al(prompt, denemeler=4, sikayet='Evet veya hayır, lütfen !'):
    while True:
        ok = raw_input(prompt)
        if ok in ('e', 'evet'): return 1
        if ok in ('h', 'hayır'): return 0
        denemeler = denemeler - 1
        if denemeler &lt; 0: raise IOError, 'kararsız kullanıcı'
        print sikayet
</screen>
    <para>
     Bu işlev <literal>onay_al('Programdan çıkmak istiyor musunuz?')</literal>
     ya da <literal>onay_al('Dosyayı silmek istiyor musunuz?', 2)</literal>
     şeklinde çağırılabilir.
    </para>
    <para>
     İşlevin öntanımlı bağımsız değişkenleri işlevin tanımlandığı anda, o an
     yürürlükte olan etki alanı içinde değerlendirilir. Yani:
    </para>
    <screen>
i = 7
def f(arg = i):
    print arg

i = 6
f()
7
</screen>
    <warning>
     <para>
      İşlevin öntanımlı bağımsız değişkenleri sadece bir defa değerlendirilir.
      Bu durum bağımsız değişkenin liste gibi değiştirilebilir bir nesne olduğu durumlarda farklılık yaratır. Örneğin aşağıdaki işlev ardarda
      çağırıldığında bağımsız değişkenlerinin değerlerini biriktirir:
     </para>
     <screen>
def f(a, L = []):
    L.append(a)
    return L
print f(1)
print f(2)
print f(3)
</screen>
     <para>Bu şu çıktıyı verir:</para>
     <screen>
[1]
[1, 2]
[1, 2, 3]
</screen>
    </warning>
    <para>
     Eğer öntanımlı bağımsız değişken değerlerinin birbirini izleyen
     çağrılarla paylaşılmasını istemiyorsanız yukarıdaki işlevi şu şekilde
     yazabilirsiniz:
    </para>
    <screen>
def f(a, L = None):
    if L is None:
        L = []
    L.append(a)
    return L
</screen>
   </sect2>
   <sect2><title>Bağımız değişken olarak anahtar kelime</title>
    <para>
     İşlevler <literal>anahtar kelime = değer</literal> şeklindeki anahtar
     kelimelerle de çağırılabilir. Örneğin şu işlev:
    </para>
    <screen>
def otomobil(yakit,  hareket=' uçar', model='Anadol'):
    print "Eğer", yakit, "koyarsan bu", model, hareket
</screen>
    <para>
     aşağıdaki gibi çağırılabilir:
    </para>
    <screen>
otomobil('roket yakıtı')
otomobil(hareket = 'dans eder', yakıt = 'zeytin yağı' )
otomobil('ispirto', model = 'Kartal')
otomobil('su','bozulur','Şahin')
</screen>
    <para>
     Şu çağrılar ise hatalıdır:
    </para>
    <screen>
otomobil()                           # gerekli bağımsız değişken eksik
otomobil(yakıt = 'su','zeytin yağı') # anahtar kelimeden sonra gelen
                                     # anahtar kelime olmayan bağımsız değişken
otomobil('mazot', yakit = 'benzin')  # aynı bağımsız değişken için iki değer
otomobil(sehir = 'İzmir')            # bilinmeyen anahtar kelime
</screen>
    <para>
     Genel olarak, bağımsız değişken listesinin başında konuma bağlı bağımsız
     değişkenler bulunur ve anahtar kelime bağımsız değişkenler onları izler;
     anahtar kelime adları da işlevin bağımsız değişkenlerinden seçilir.
     Bağımsız değişkenin öntanımlı değerlerinin olup olmaması önemli değildir.
     Bir bağımsız değişken birden fazla değer alamaz; konuma bağlı bağımsız
     değişken isimleri aynı çağrıda anahtar kelime olarak kullanılamaz.
     İşte bundan dolayı hatalı olan bir örnek:
    </para>
    <screen>
<prompt>&gt;&gt;&gt;</prompt> def function(a):
<prompt>...</prompt>     pass
<prompt>...</prompt>
<prompt>&gt;&gt;&gt;</prompt> function(0, a=0)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
TypeError: keyword parameter redefined
</screen>
    <para>
     Eğer işlev tanımındaki son bağımsız değişken <literal>**isim</literal>
     şeklinde ise bu bağımsız değişken adları herhangi bir bağımsız değişken
     olmayan anahtar kelime şeklindeki bağımsız değişkenlerin bulunduğu bir
     sözlük olur. Bu <literal>*isim</literal> (bu konu <xref
      linkend="python-tutorial_sozlukler"/> bölümünde anlatılacaktır.)
     şeklindeki bir bağımsız değişken ile de kullanılabilir, ki bu bağımsız
     değişken listesi içinde bulunmayan konuma bağlı bağımsız değişkenleri
     içeren bir demet (daha sonra <xref linkend="python-tutorial_demetler"/>
     bölümünde incelenecek bir veri türüdür) olur. <literal>*isim</literal>
     bağımsız değişkeni <literal>**isim</literal> bağımsız değişkeninden önce
     gelmelidir. Buna örnek işlev:
    </para>
    <screen>
def kasapdukkani(etCinsi,*argumanlar, **anahtarKelimeler):
    print "--", etCinsi, "var mi ?"
    print "-- Maalesef", etCinsi, "kalmadı."
    for arg in argumanlar:
        print arg
    print '-'*40
    anahtarlar = anahtarKelimeler.keys()
    anahtarlar.sort()
    for ak in anahtarlar:
        print ak, ':', anahtarKelimeler[ak]
</screen>
    <para>Şu şekilde çağrılabilir:</para>
     <screen>
kasapdukkani('martı eti',"Çok lezzetli.",
           "Çok satılıyor.",
           musteri = 'Martı Murat',
           kasap = 'Dev İsmail')
</screen>
    <para>ve doğal olarak şu çıktıyı verir:</para>
     <screen>
-- martı eti var mi ?
-- Maalesef martı eti kalmadı.
Çok lezzetli.
Çok satılıyor.
----------------------------------------
kasap : Dev İsmail
musteri : Martı Murat
</screen>
    <para>
     <literal>anahtarKelimeler</literal> isimli sözlüğün içeriği yazdırılmadan
     önce anahtar kelime isimleri listesinin <literal>sort()</literal>
     yönteminin çağırıldığına dikkat edin; bu yapılmaz ise bağımsız
     değişkenlerin hangi sıra ile yazılacağı tanımlanmamış olur.
    </para>
   </sect2>
   <sect2><title>Keyfî Bağımsız Değişken Listeleri</title>
    <para>
     Son olarak, en ender kullanılan seçenek de keyfî sayıdaki bağımsız
     değişken ile çağrılabilen bir işlev tanımlamaktır. Bu bağımsız
     değişkenler bir demet (değişmez liste [tuple]) içine alınır. Keyfî
     bağımsız değişken listesinden önce sıfır ya da daha fazla normal bağımsız
     değişken bulunabilir. Örnek:
    </para>
    <screen>
def fprintf(file, format, *args):
    file.write(format % args)
</screen>
   </sect2>
   <sect2><title>Lambda Biçemli İşlevler</title>
    <para>
     Yoğun istek üzerine işlevsel dillerde ve Lisp'te bulunan bazı
     özellikler Python'a eklenmiştir. <literal>lambda</literal> anahtar
     kelimesi ile küçük anonim işlevler yazılabilir. İşte iki
     bağımsız değişkeninin toplamını geri döndüren bir işlev:
     <literal>lambda a, b: a+b</literal>.
    </para>
    <para>
     Lambda işlevleri bir işlev nesnesine ihtiyaç duyulan her yerde
     kullanılabilir. Sözdizim (syntax) açısından bunlar tek bir ifade ile
     sınırlandırılmıştır. Anlambilim (semantics) açısından ise normal
     işlev tanımlamasına getirilen bir sözdizim güzelliğidir. İç içe
     tanımlanmış işlevlerde olduğu gibi lambda işlevleri de kendilerini
     kapsayan etki alanindaki değişkenlere erişebilir:
    </para>
     <screen>
<prompt>&gt;&gt;&gt;</prompt> def artirici_yap(n):
<prompt>...</prompt>     return lambda x: x + n
<prompt>...</prompt>
<prompt>&gt;&gt;&gt;</prompt> f = artirici_yap(42)
<prompt>&gt;&gt;&gt;</prompt> f(0)
42
<prompt>&gt;&gt;&gt;</prompt> f(1)
43
</screen>
   </sect2>
   <sect2><title>Belgelendirme Dizgeleri</title>
    <para>
     Belgelendirmede kullanılan dizgelerin şekli ve içeriği ile ilgili
     şartlar yeni yeni oluşmaktadır.
    </para>
    <para>
     İlk satır daima nesnenin amacının kısa ve öz tanımı olmalıdır. Kısa
     olması için, nesnenin adından ve türünden bahsedilmemeli; zira bunlar
     başka yollarla da öğrenilebilir. Bu satır büyük harf ile başlayıp
     nokta ile bitmelidir.
    </para>
    <para>
     Eğer belgelendirme dizgesinde birden fazla satır var ise ikinci satır
     boş olup özet ile açıklamamın devamını birbirinden ayırmalıdır. Diğer
     satırlar bir ya da daha fazla satır olabilir. Bunlarla nesnenin
     özellikleri, çağrı şekilleri, yan etkileri vs. açıklanabilir.
    </para>
    <para>
     Python çözümleyicisi (parser) çok satırlı dizgelerdeki
     girintileri yok etmez; yani belgeleri işleyen yazılımlar gerekirse
     bunları atabilir. İlk satırdan sonra gelen ve boş olmayan ilk satırdaki
     girinti miktarı belgelendirme dizgesinin devamındaki girinti miktarını
     belirler. Bu girinti miktarına ``eşdeğer'' boşluk diğer satırların
     başından atılır. Daha az girintili satırlar olmamalı; ama olursa da
     bunların önündeki boşluğun tamamı atılmalı. Boşluğun eşdeğerliği
     sekmelerin genişletilmesinden (1 sekme = 8 boşluk) sonra sınanmalıdır.
    </para>
    <para>
     İşte çok satırlı bir belgelendirme dizgesi örneği:
    </para>
    <screen>
<prompt>&gt;&gt;&gt;</prompt> def benimFonksiyon():
<prompt>...</prompt>     """Sadece belgeler.
<prompt>...</prompt>
<prompt>...</prompt>     Başka birşey yapmaz. Gerçekten !.
<prompt>...</prompt>     """
<prompt>...</prompt>     pass
<prompt>...</prompt>
<prompt>&gt;&gt;&gt;</prompt> print benimFonksiyon.__doc__
Sadece belgeler.

   Başka birşey yapmaz. Gerçekten !
</screen>
   </sect2>
  </sect1>
 </chapter>

 <chapter xml:id="python-tutorial_veri-yapilari">
  <?dbhtml stop-chunking?>
  <title>Veri Yapıları</title>
  <para>
   Bu bölümde öğrendiğiniz bazı şeyler daha ayrıntılı açıklanmakta ve
   bazı yeni konulara da değinilmektedir.
  </para>
  <sect1 xml:id="python-tutorial_listeler">
   <title>Listeler Üzerine Daha Fazla Bilgi</title>
   <para>
    Liste veri türünün birkaç yöntemi daha var. İşte liste nesnelerinin
    bütün yöntemleri:
   </para>
   <variablelist>
    <varlistentry>
     <term>
      <literal>list.</literal><function>append</function>(<parameter>x</parameter>)
     </term>
     <listitem>
      <para>
       Listenin sonuna bir eleman ekler; <literal>a[len(a):] = [x]</literal>
       ifadesine denktir.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>
      <literal>list.</literal><function>extend</function>(<parameter>L</parameter>)
      </term>
     <listitem>
      <para>
       Listeyi verilen listedeki tüm elemanları ekleyerek genişletir;
       <literal>a[len(a):] = L</literal> ifadesine denktir.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>
      <literal>list.</literal><function>insert</function>(<parameter>i, x</parameter>)
      </term>
     <listitem>
      <para>
       Belirtilen konuma bir eleman yerleştirir. İlk bağımsız değişken elemanın
       yerleştirileceği indistir. <literal>a.insert(0, x)</literal>
       ifadesi <literal>x</literal>'i listenin başına yerleştirir, ve
       <literal>a.insert(len(a), x)</literal> ifadesi
       <literal>a.append(x)</literal> ifadesine denktir.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>
      <literal>list.</literal><function>remove</function>(<parameter>x</parameter>)
     </term>
     <listitem>
      <para>
       Liste içinde değeri <parameter>x</parameter> olan ilk elemanı listeden siler. Böyle bir öğe yok ise <classname xlink:href="https://docs.python.org/3/library/exceptions.html#ValueError">ValueError</classname> istisnası oluşur.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>
      <literal>list.</literal><function>pop</function>([<parameter>i</parameter>])
     </term>
     <listitem>
      <para>
       Belirtilen konumdaki elemanı listeden siler ve bunu geri döndürür.
       Eğer bir indis belirtilmezse, <literal>a.pop()</literal>
       listedeki son elemanı siler ve döndürür. (<literal>i</literal>
       etrafındaki köşeli ayraçlar bu bağımsız değişkenin seçimlik olduğunu
       belirtir. Bu yazım biçimini Python belgelerinde sıkça görebilirsiniz.)
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>
      <literal>list.</literal><function>clear</function>()
     </term>
     <listitem>
      <para>
       Listenin tüm elemanlarını siler. <code>del a[:]</code> işlemine denktir.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>
      <literal>list.</literal><function>index</function>(<parameter>x</parameter>[, <parameter>ilk</parameter>[, <parameter>son</parameter>]])
     </term>
     <listitem>
      <para>
       Değeri <parameter>x</parameter> olan ilk elemanın indisini döndürür.
       Böyle bir öğe yok ise <classname xlink:href="https://docs.python.org/3/library/exceptions.html#ValueError">ValueError</classname> istisnası oluşur.
      </para>
      <para>
       İsteğe bağlı bağımsız değişkenler <parameter>ilk</parameter> ve <parameter>son</parameter>, dilim gösterimindeki gibi yorumlanır ve aramayı belirli bir aralıkla sınırlamak için kullanılır. Döndürülen indis, <parameter>ilk</parameter>'e göre değil listenin başlangıcına göre hesaplanır.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>
      <literal>list.</literal><function>count</function>(<parameter>x</parameter>)
     </term>
     <listitem>
      <para>
       <parameter>x</parameter>'in listedeki miktarını bulur ve bu değeri geri döndürür.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>
      <literal>list.</literal><function>sort</function>(*[, <parameter>key=None</parameter>, <parameter>reverse=False</parameter>])
     </term>
     <listitem>
      <para>
       Listeyi kendi içinde sıralar. İsteğe bağlı bağımsız değişkenler anahtar kelime olarak belirtilebilir ve sıralamayı özelleştirmek için kullabılabilir.
      </para>
      <para>
       <parameter>key</parameter> ile yinelemedeki her öğeden bir karşılaştırma anahtarı çıkarmak için kullanılan tek bağımsız değişkenli bir işlev belirtilir (örneğin, <code>key=str.lower</code>). <code>None</code> öntanımlıdır (öğeler doğrudan karşılaştırılır).
      </para>
      <para>
       <parameter>reverse</parameter> mantıksal bir değerdir. <code>True</code> belirtilirse liste elemanları tersine sıralanır.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>
      <literal>list.</literal><function>reverse</function>()
     </term>
     <listitem>
      <para>
       Listenin sırasını kendi içinde tersine çevirir.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>
      <literal>list.</literal><function>copy</function>()
     </term>
     <listitem>
      <para>
       Listenin sığ bir kopyasını döndürür. <literal>a[:]</literal> ifadesine denktir.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    Liste yöntemlerinin çoğunu kullanan bir örnek:
   </para>
   <screen>
<prompt>&gt;&gt;&gt;</prompt> meyveler = ['portakal', 'elma', 'armut', 'muz', 'kivi', 'elma', 'muz']
<prompt>&gt;&gt;&gt;</prompt> meyveler.count('elma')
2
<prompt>&gt;&gt;&gt;</prompt> meyveler.count('mandalina')
0
<prompt>&gt;&gt;&gt;</prompt> meyveler.index('muz')
3
<prompt>&gt;&gt;&gt;</prompt> meyveler.index('muz', 4)  # 4. konumdan sonraki muzun konumunu bul
6
<prompt>&gt;&gt;&gt;</prompt> meyveler.reverse()
<prompt>&gt;&gt;&gt;</prompt> meyveler
['muz', 'elma', 'kivi', 'muz', 'armut', 'elma', 'portakal']
<prompt>&gt;&gt;&gt;</prompt> meyveler.append('üzüm')
<prompt>&gt;&gt;&gt;</prompt> meyveler
['muz', 'elma', 'kivi', 'muz', 'armut', 'elma', 'portakal', 'üzüm']
<prompt>&gt;&gt;&gt;</prompt> meyveler.sort()
<prompt>&gt;&gt;&gt;</prompt> meyveler
['armut', 'elma', 'elma', 'kivi', 'muz', 'muz', 'portakal', 'üzüm']
<prompt>&gt;&gt;&gt;</prompt> meyveler.pop()
'üzüm'
</screen>
   <sect2><title>Listelerin Yığın Olarak Kullanılması</title>
    <para>
     Liste yöntemleri listelerin kolayca yığın olarak kullanılmasını
     sağlar. Yığına son giren eleman ilk çıkar. Yığının üzerine
     eleman eklemek için <literal>append()</literal> ve en üstteki
     elemanı almak için indis belirtmeden <literal>pop()</literal>
     kullanılır. Örnek:
    </para>
    <screen>
<prompt>&gt;&gt;&gt;</prompt> yigin = [3, 4, 5]
<prompt>&gt;&gt;&gt;</prompt> yigin.append(6)
<prompt>&gt;&gt;&gt;</prompt> yigin.append(7)
<prompt>&gt;&gt;&gt;</prompt> yigin
[3, 4, 5, 6, 7]
<prompt>&gt;&gt;&gt;</prompt> yigin.pop()
7
<prompt>&gt;&gt;&gt;</prompt> yigin
[3, 4, 5, 6]
<prompt>&gt;&gt;&gt;</prompt> yigin.pop()
6
<prompt>&gt;&gt;&gt;</prompt> yigin.pop()
5
<prompt>&gt;&gt;&gt;</prompt> yigin
[3, 4]
</screen>
   </sect2>
   <sect2><title>Listelerin Kuyruk Olarak Kullanılması</title>
    <para>
     Listeleri kuyruk olarak da kullanmak mümkün. Bir kuyrukta ilk eklenen
     eleman ilk alınan elemandır (ilk giren ilk çıkar). Kuyruğun sonuna
     bir eleman eklemek için <literal>append()</literal> kullanılır.
     Sıranın başından bir eleman almak için ise 0 indisi ile
     <literal>pop()</literal> kullanılır. Örnek:
    </para>
     <screen>
<prompt>&gt;&gt;&gt;</prompt> kuyruk = ["Ali", "Veli", "Deli"]
<prompt>&gt;&gt;&gt;</prompt> kuyruk.append("Küpeli")           # Küpeli kuyrukta
<prompt>&gt;&gt;&gt;</prompt> kuyruk.append("Aylin")            # Aylin kuyrukta
<prompt>&gt;&gt;&gt;</prompt> kuyruk.pop(0)
'Ali'
<prompt>&gt;&gt;&gt;</prompt> kuyruk.pop(0)
'Veli'
<prompt>&gt;&gt;&gt;</prompt> kuyruk
['Deli', 'Küpeli', 'Aylin']
</screen>
   </sect2>
   <sect2><title>İşlevsel Yazılım Geliştirme Araçları</title>
    <para>
     Listelerle kullanıldığında çok faydalı olan yerleşik işlevler vardır:
     <literal>filter()</literal>, <literal>map()</literal>, ve
     <literal>reduce()</literal>.
    </para>
    <para>
     <literal>filter(işlev, sıra)</literal> sıra içerisinden
     <literal>işlev(eleman)</literal>'ın doğru sonuç verdiği elemanların
     bulunduğu (mümkünse aynı türden) bir sıra geri döndürür. Örneğin,
     bazı asal sayıları hesaplamak için şöyle yapılabilir:
    </para>
    <screen>
<prompt>&gt;&gt;&gt;</prompt> def f(x): return x % 2 != 0 and x % 3 != 0
<prompt>...</prompt>
<prompt>&gt;&gt;&gt;</prompt> filter(f, range(2, 25))
[5, 7, 11, 13, 17, 19, 23]
</screen>
    <para>
     <literal>map(işlev, sıra)</literal> sıranın her elemanı için
     <literal>işlev(sıra)</literal> çağırır ve geri döndürülen değerlerin
     oluşturduğu listeyi geri döndürür. Örneğin bazı sayıların küplerini
     hesaplamak için şu yol izlenebilir:
    </para>
    <screen>
<prompt>&gt;&gt;&gt;</prompt> def cube(x): return x*x*x
<prompt>...</prompt>
<prompt>&gt;&gt;&gt;</prompt> map(cube, range(1, 11))
[1, 8, 27, 64, 125, 216, 343, 512, 729, 1000]
</screen>
    <para>
     <literal>map(işlev, sıra)</literal> ifadesinde birden fazla sıra da
     kullanılabilir; ancak bu durumda işlev sıra sayısı kadar bağımsız
     değişkene sahip olmalıdır. <literal>işlev</literal> her sıranın uygun
     elemanını bir bağımsız değişken olarak alır; ancak sıralardan biri kısa
     ise eksik elemanlar için işleve <literal>None</literal> bağımsız
     değişkeni aktarılır. Eğer işlev adı için de <literal>None</literal>
     kullanılırsa bağımsız değişkenlerini döndüren bir işlev etkisi yaratılır.
   </para>
    <para>
     Bu iki özel durumu birleştirerek
     <literal>map(None, list1, list2)</literal> ifadesi ile bir çift diziyi
     çiftlerden oluşan bir diziye çevirebiliriz. Örnek:
    </para>
    <screen>
<prompt>&gt;&gt;&gt;</prompt> sira = range(8)
<prompt>&gt;&gt;&gt;</prompt> def kare(x): return x*x
<prompt>...</prompt>
<prompt>&gt;&gt;&gt;</prompt> map(None, sira, map(kare, sira))
[(0, 0), (1, 1), (2, 4), (3, 9), (4, 16), (5, 25), (6, 36), (7, 49)]
</screen>
    <para>
     <literal>reduce(işlev, sıra)</literal> ifadesi tek bir değer geri
     döndürür. Bu değer şöyle elde edilir: iki bağımsız değişkenli işleve
     sıranın ilk iki elemanı bağımsız değişken olarak verilir, sonra da elde
     edilen sonuç ile sıranın sonraki elemanı bağımsız değişken olarak
     verilir, daha sonra yine elde edilen sonuç ile bir sonraki eleman işleve
     verilir ve bu işlem bütün elemanlar için tekrarlanır. Örneğin 1'den 10'a
     kadar olanlar böyle toplanabilir:
    </para>
    <screen>
<prompt>&gt;&gt;&gt;</prompt> def topla(x,y): return x+y
<prompt>...</prompt>
<prompt>&gt;&gt;&gt;</prompt> reduce(topla, range(1, 11))
55
</screen>
    <para>
     Sırada sadece bir eleman var ise bunun değeri geri döndürülür;
     sıra boş ise bir istisna oluşur (exception).
    </para>
    <para>
     Başlangıç değerini bildirmek için üçüncü bir bağımsız değişken kullanılabilir.
     Bu durumda işleve ilk olarak başlangıç değeri ve sıranın ilk elemanına
     uygulanır ve diğer elemanlar ile devam eder. Örnek:
    </para>
    <screen>
<prompt>&gt;&gt;&gt;</prompt> def sonuc(sira):
<prompt>...</prompt>     def topla(x,y): return x+y
<prompt>...</prompt>     return reduce(topla, sira, 0)
<prompt>...</prompt>
<prompt>&gt;&gt;&gt;</prompt> sonuc(range(1, 11))
55
<prompt>&gt;&gt;&gt;</prompt> sonuc([])
0
</screen>
   </sect2>
   <sect2><title>Liste Üreteçleri</title>
    <para>
     Liste üreteçleri <literal>map()</literal>, <literal>filter()</literal>
     ve/veya <literal>lambda</literal> işlevlerini kullanmadan liste
     yaratmanın kısa bir yoludur. Bu yolla yaratılan liste tanımı genellikle
     daha kolay anlaşılır olur. Bir liste üreteci bir ifade ve bir
     <literal>for</literal> döngüsü ile bunları izleyen sıfır ya da daha
     fazla <literal>for</literal> veya <literal>if</literal> ifadelerinden
     oluşur. Sonuç kendisini izleyen <literal>for</literal> ve
     <literal>if</literal> bağlamında değerlendirilen ifadeden oluşan bir
     listedir. Eğer ifade bir demete (değişmez liste [tuple]) dönüşecekse
     parantez içinde yazılmalıdır.
    </para>
     <screen>
<prompt>&gt;&gt;&gt;</prompt> freshfruit = ['  muz', '  loganberry ', 'passion fruit  ']
<prompt>&gt;&gt;&gt;</prompt> [weapon.strip() for weapon in freshfruit] # elemanları saran
boşlukların atıldığı yeni bir liste
['muz', 'loganberry', 'passion fruit']
<prompt>&gt;&gt;&gt;</prompt> vec = [2, 4, 6]
<prompt>&gt;&gt;&gt;</prompt> [3*x for x in vec]
[6, 12, 18]
<prompt>&gt;&gt;&gt;</prompt> [3*x for x in vec if x &gt; 3]
[12, 18]
<prompt>&gt;&gt;&gt;</prompt> [3*x for x in vec if x &lt; 2]
[]
<prompt>&gt;&gt;&gt;</prompt> [{x: x**2} for x in vec]   # sözlüklerden oluşan bir liste
[{2: 4}, {4: 16}, {6: 36}]
<prompt>&gt;&gt;&gt;</prompt> [[x,x**2] for x in vec]
[[2, 4], [4, 16], [6, 36]]
<prompt>&gt;&gt;&gt;</prompt> [x, x**2 for x in vec]   # hata - demet için parantez gerekir
  File "&lt;stdin&gt;", line 1, in ?
    [x, x**2 for x in vec]
               ^
SyntaxError: invalid syntax
<prompt>&gt;&gt;&gt;</prompt> [(x, x**2) for x in vec]
[(2, 4), (4, 16), (6, 36)]
<prompt>&gt;&gt;&gt;</prompt> vec1 = [2, 4, 6]
<prompt>&gt;&gt;&gt;</prompt> vec2 = [4, 3, -9]
<prompt>&gt;&gt;&gt;</prompt> [x*y for x in vec1 for y in vec2]
[8, 6, -18, 16, 12, -36, 24, 18, -54]
<prompt>&gt;&gt;&gt;</prompt> [x+y for x in vec1 for y in vec2]
[6, 5, -7, 8, 7, -5, 10, 9, -3]
<prompt>&gt;&gt;&gt;</prompt> [vec1[i]*vec2[i] for i in range(len(vec1))]
[8, 12, -54]
</screen>
    <para>
     Liste üreteçlerinin <literal>for</literal> döngülerine benzer davranması
     için, döngü değişkenine yapılan atamalar üreteç dışında da görünürler:
    </para>
    <screen>
<prompt>&gt;&gt;&gt;</prompt> x = 100                     # bu değişecek
<prompt>&gt;&gt;&gt;</prompt> [x**3 for x in range(5)]
[0, 1, 8, 27, 64]
<prompt>&gt;&gt;&gt;</prompt> x
4                               # range(5) için son değer
&gt;&gt;
</screen>
   </sect2>
  </sect1>
  <sect1 xml:id="python-tutorial_del">
   <title><literal>del</literal> Deyimi</title>
   <para>
    <literal>del</literal> deyimi ile bir listeden indisi verilen bir
    eleman silinebilir. Bu deyim ile bir listeden dilimler de silinebilir
    (bunu daha önce dilimlere boş bir liste atayarak yapmıştık). Örnek:
   </para>
   <screen>
<prompt>&gt;&gt;&gt;</prompt> a
[-1, 1, 66.6, 333, 333, 1234.5]
<prompt>&gt;&gt;&gt;</prompt> del a[0]
<prompt>&gt;&gt;&gt;</prompt> a
[1, 66.6, 333, 333, 1234.5]
<prompt>&gt;&gt;&gt;</prompt> del a[2:4]
<prompt>&gt;&gt;&gt;</prompt> a
[1, 66.6, 1234.5]
</screen>
   <para>
    <literal>del</literal> deyimi tamamen silmek için de kullanılabilir:
   </para>
   <screen>
<prompt>&gt;&gt;&gt;</prompt> del a
</screen>
   <para>
    Bu aşamadan sonra <literal>a</literal> ismine başvuru bir hatadır
    (aynı isme başka bir değer atanana kadar). Daha sonra <literal>del</literal>
    için başka kullanım alanları da göreceğiz.
   </para>
  </sect1>
  <sect1 xml:id="python-tutorial_demetler">
   <title>Demetler (tuples)</title>
   <para>
    Listelerin ve dizgelerin indisleme ve dilimleme gibi pek çok ortak
    özellikleri olduğunu grdük. Bunlar sıra şeklindeki iki veri türüdür.
    Python gelişmekte olan bir dil; diğer sıra şeklindeki veri türleri de
    Python'a eklenebilir. Demet de başka bir sıra şekilli standart veri türüdür.
   </para>
   <para>
    Bir demet virgül ile ayrılmış bir kaç değerden oluşur.
   </para>
   <screen>
<prompt>&gt;&gt;&gt;</prompt> t = 12345, 54321, 'merhaba!'
<prompt>&gt;&gt;&gt;</prompt> t[0]
12345
<prompt>&gt;&gt;&gt;</prompt> t
(12345, 54321, 'merhaba!')
<prompt>&gt;&gt;&gt;</prompt> # demetler iç içe kullanılabilirler :
<prompt>...</prompt> u = t, (1, 2, 3, 4, 5)
<prompt>&gt;&gt;&gt;</prompt> u
((12345, 54321, 'merhaba!'), (1, 2, 3, 4, 5))
</screen>
   <para>
    Gördüğünüz gibi çıktıda demetler daima parantez içinde görünürler; ki
    iç içe geçmiş demetler belli olsun. Demetler parantezli veya parantezsiz
    olarak yazılabilirler; ancak parantezler genelikle gereklidirler
    (özellikle de demet daha büyük bir ifadenin içinde geçiyorsa).
   </para>
   <para>
    Demetlerin pekçok kullanım alanı var: <literal>(x, y)</literal> koordinat
    çifti, veri tabanındaki işçi kayıtları vb. gibi. Demetler de dizgeler
    gibi değerleri değiştirilemez veri türleridir; bunların elemanlarına
    atama yapılamaz (fakat dilimleme ve birleştirme aracılığı ile bu etki
    sağlanabilir). Ayrıca değiştirilebilen elemanlardan oluşan demetler
    oluşturmak da mümkündür (örnek: listelerden oluşan bir demet).
   </para>
   <para>
    Sıfır veya bir elemanlı demetlerin oluşturulması ile ilgili özel bir
    problem var: bunların ifade edilmesini sağlayan sözdizim biraz acayip.
    Boş demetler bir çift boş parantez ile ifade edilir. Tek elemanı olan
    bir demet için ise elemandan sonra bir virgül kullanılır (tek bir
    değeri parantez içine almak yeterli değildir). Çirkin ama etkili.
    Örnek:
   </para>
   <screen>
<prompt>&gt;&gt;&gt;</prompt> bos = ()
<prompt>&gt;&gt;&gt;</prompt> tekOge = 'merhaba', # &lt;--satır sonundaki virgüle dikkat
<prompt>&gt;&gt;&gt;</prompt> len(bos)
0
<prompt>&gt;&gt;&gt;</prompt> len(tekOge)
1
<prompt>&gt;&gt;&gt;</prompt> tekOge
('merhaba',)
</screen>
   <para>
    <literal>t = 12345, 54321, 'merhaba!'</literal> ifadesi demetleme
    (tuple packing) işlemine bir örnektir: <literal>12345, 54321</literal> ve
    <literal>'merhaba!'</literal> değerleri bir demet içinde toplanmışlardır.
    Bu işlemin tersi de mümkün:
   </para>
   <screen>
<prompt>&gt;&gt;&gt;</prompt> x, y, z = t
</screen>
   <para>
    Doğal olarak, buna demet açma (sequence unpacking) deniyor. Demet açma
    sol taraftaki değişken sayısının sıra içindeki öğe sayısına eşit
    olmasını gerektirir. Çoklu değer atama işleminin aslında demetleme ve
    demet açmanın bir bileşimi olduğuna dikkat edin.
   </para>
   <para>
    Burada küçük bir asimetri var: birden fazla değeri demetleme her zaman
    bir demet oluşturur ve demet açma herhangi bir sıra için yapılabilir.
    Örnek:
   </para>
   <screen>
<prompt>&gt;&gt;&gt;</prompt> paket = 'xyz' # bir dizge
<prompt>&gt;&gt;&gt;</prompt> a,b,c = paket
<prompt>&gt;&gt;&gt;</prompt> a
'x'
<prompt>&gt;&gt;&gt;</prompt> b
'y'
<prompt>&gt;&gt;&gt;</prompt> c
'z'
</screen>
  </sect1>
  <!-- Setler - Python3 eğitmeninde burada setler konusu var-->
  <sect1 xml:id="python-tutorial_sozlukler">
   <title>Sözlükler (Çağrışımlı Listeler)</title>
   <para>
    Python'da bulunan bir diğer faydalı veri türü de sözlüktür. Sözlükler
    diğer yazılımlama dillerinde ``çağrışımlı bellek'' (associative memory)
    veya ``çağrışımlı dizi'' (associative array) olarak bilinir.
    Sayılarla indislenen sıralardan farklı olarak, sözlükler anahtarlar
    (key) ile indislenir. Anahtar değiştirilemeyen türdeki herhangi bir
    veri türünde olabilir. Sayılar ve dizgeler her zaman anahtar olabilir.
    Demetler de sayılar, dizgeler veya demetler içerdikleri sürece
    anahtar olabilir. Bir demet doğrudan ya da dolaylı olarak değiştirilebilir
    bir nesne içeriyorsa anahtar olarak kullanılamaz. Listeler anahtar
    olamazlar, çünkü <literal>append()</literal> ile <literal>extend()</literal>
    yöntemleri, dilimleme ve indise değer atama ile değiştirilebilir.
   </para>
   <para>
    Bir sözlük <literal>anahtar : değer</literal> çiftlerinden oluşur. Bir
    anahtar sözlükte sadece bir defa bulunabilir. Bir çift çengelli parantez
    boş bir sözlük yaratır : <literal>{}</literal>. Çengelli parantezlerin
    içine virgülle ayrılmış <literal>anahtar : değer</literal> çiftleri
    koymak anahtar ve değer çiftlerine ilk değerlerini verir. Çıktıya da
    sözlükler aynı şekilde yazılır.
   </para>
   <para>
    Sözlüklerle ilgili ana işlemler bir değerin bir anahtar ile saklanması
    ve anahtar verildiğinde değerin bulunmasıdır. <literal>del</literal>
    kullanarak bir <literal>anahtar : değer</literal> çiftini silmek mümkündür.
    Zaten mevcut olan bir anahtar kullanarak bir değer eklerseniz bu anahtarla
    bağlantılı eski değer unutulur. Mevcut olmayan bir anahtar ile değer
    istemek hatalıdır.
   </para>
   <para>
    Sözlük nesnesinin <literal>keys()</literal> yöntemi listedeki bütün
    anahtarların listesini rasgele sıralı olarak geri döndürür (sıralamak
    isterseniz listenin <literal>sort()</literal> yönteminden faydalanabilirsiniz).
    Bir anahtarın sözlükte olup olmadığını görmek için sözlüğün
    <literal>has_key()</literal> yöntemi kullanılır.
   </para>
   <para>
    İşte sözlük kullanan küçük bir örnek:
   </para>
   <screen>
<prompt>&gt;&gt;&gt;</prompt> tel = {'jack': 4098, 'sape': 4139}
<prompt>&gt;&gt;&gt;</prompt> tel['guido'] = 4127
<prompt>&gt;&gt;&gt;</prompt> tel
{'sape': 4139, 'guido': 4127, 'jack': 4098}
<prompt>&gt;&gt;&gt;</prompt> tel['jack']
4098
<prompt>&gt;&gt;&gt;</prompt> del tel['sape']
<prompt>&gt;&gt;&gt;</prompt> tel['irv'] = 4127
<prompt>&gt;&gt;&gt;</prompt> tel
{'guido': 4127, 'irv': 4127, 'jack': 4098}
<prompt>&gt;&gt;&gt;</prompt> tel.keys()
['guido', 'irv', 'jack']
<prompt>&gt;&gt;&gt;</prompt> tel.has_key('guido')
1
</screen>
   <para>
    <literal>dict()</literal> işlevi anahtar-değer çiftlerinden oluşan demetlerden sözlükler üretir. Çiftlerin bir kalıba uyduğu durumlarda, liste üreteçleri ile anahtar-değer çiftleri kısaca ifade edilebilir.
   </para>
   <screen>
<prompt>&gt;&gt;&gt;</prompt> dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])
{'sape': 4139, 'jack': 4098, 'guido': 4127}
<prompt>&gt;&gt;&gt;</prompt> dict([(x, x**2) for x in vec])     # liste üreteci kullanarak
{2: 4, 4: 16, 6: 36}
</screen>
  </sect1>
  <sect1 xml:id="python-tutorial_dongu">
   <title>Döngü Teknikleri</title>
   <para>
    Sözlükler üzerinde döngüler kurarken o anki değer
    <literal>items()</literal> yöntemi ile aynı anda elde edilebilir.
   </para>
   <screen>
<prompt>&gt;&gt;&gt;</prompt> knights = {'gallahad': 'the pure', 'robin': 'the brave'}
<prompt>&gt;&gt;&gt;</prompt> for k, v in knights.items():
<prompt>...</prompt>     print k, v
<prompt>...</prompt>
gallahad the pure
robin the brave
</screen>
   <para>
    Bir sıra üzerinde dönerken konum indisi ve ona karşılık gelen değer de
    <literal>enumerate()</literal> işlevini kullanarak aynı anda elde edilebilir.
   </para>
   <screen>
<prompt>&gt;&gt;&gt;</prompt> for i, v in enumerate(['tic', 'tac', 'toe']):
<prompt>...</prompt>     print i, v
<prompt>...</prompt>
0 tic
1 tac
2 toe
</screen>
   <para>
    Aynı anda iki sıra üzerinde ilerlemek için ise <literal>zip()</literal>
    işlevi ile bunlar çiftler haline getirilebilir.
   </para>
   <screen>
<prompt>&gt;&gt;&gt;</prompt> sorular = ['adın', 'görevin', 'favori rengin']
<prompt>&gt;&gt;&gt;</prompt> cevaplar = ['Adnan', 'Uyumak', 'Mavi']
<prompt>&gt;&gt;&gt;</prompt> for s, c in zip(sorular, cevaplar):
<prompt>...</prompt>     print 'Senin %s ne? %s.' % (s, c)
<prompt>...</prompt>
Senin adın ne? Adnan.
Senin görevin ne? Uyumak.
Senin favori rengin ne? Mavi.
</screen>
  </sect1>
  <sect1 xml:id="python-tutorial_kosullu">
   <title>Koşullu İfadeler Üzerine Daha Fazla Bilgi</title>
   <para>
    <literal>while</literal> ve <literal>if</literal> deyimlerinde kıyaslama
    dışında da işleçler kullanılabilir.
   </para>
   <para>
    <literal>in</literal> ve <literal>not</literal> kıyaslama işleçleri bir
    değerin bir sıra içinde olup olmadığını sınar.
   </para>
   <para>
    <literal>is</literal> ve <literal>is not</literal> işleçleri iki nesnenin
    tamamen aynı nesne olup olmadıklarını sınarlar (bu sadece liste gibi
    değiştirilebilir nesnelerde önemlidir).
   </para>
   <para>
    Bütün kıyaslama işleçleri aynı önceliğe sahiptirler ve bu sayısal
    işleçlerinkinden düşüktür.
   </para>
   <para>
    Kıyaslamalar zincirlenebilir: <literal>a &lt; b == c</literal> gibi.
   </para>
   <para>
    Kıyaslamalar mantıksal işleçler <literal>and</literal> ve
    <literal>or</literal> ile birleştirilebilirler ve kıyaslamanın sonucu
    (ya da herhangi bir mantıksal ifade) <literal>not</literal> ile
    değillenebilir. Bunların hepsi de kıyaslama işleçlerinden düşük
    önceliğe sahiptirler ve aralarında en yüksek öncelikli olan
    <literal>not</literal> ve en düşük öncelikli olan <literal>or</literal>
    işleçidir. Örneğin <literal>A and not B or C</literal> ifadesi
    <literal>(A and (not B)) or C</literal> ifadesine eştir. İstenen bileşimi
    elde etmek için parantezler kullanılabilir.
   </para>
   <para>
    <literal>and</literal> ve <literal>or</literal> mantıksal işleçlerine
    kısa devre işleç de denir. Bunların bağımsız değişkenleri soldan sağa
    değerlendirilir ve sonuç belli olur olmaz değerlendirme işlemi kesilir.
    Örneğin A ve C doğru, fakat B yanlış olsun.
    <literal>A and B and C</literal> ifadesinde C ifadesi değerlendirilmez
    (çünkü C'nin değeri sonucu değiştirmez). Genel olarak bir kısa devre
    işleçi <literal>Bool</literal> değil de genel bir değer gibi
    kullanıldığında en son değerlendirilen bağımsız değişkenin değeri geri
    döndürülür.
  </para>
   <para>
    Bir kıyaslamanın ya da mantıksal ifadenin sonucunu bir değişkene atamak
    mümkündür:
   </para>
   <screen>
<prompt>&gt;&gt;&gt;</prompt> string1, string2, string3 = '', 'Trondheim', 'Hammer Dance'
<prompt>&gt;&gt;&gt;</prompt> non_null = string1 or string2 or string3
<prompt>&gt;&gt;&gt;</prompt> non_null
'Trondheim'
</screen>
   <para>
    C dilinin tersine, Python'da ifadelerin içinde atama olamayacağına
    dikkat edin. C yazılımcıları bundan şikayetçi olabilirler; ancak bu C
    yazılımlarında sık karşılaşılan bazı hataları engellemektedir
    (== yerine = yazmak gibi).
   </para>
  </sect1>
  <sect1 xml:id="python-tutorial_dizge-demet">
   <title>Listeler, Dizgeler ve Demetler Arasında Kıyaslama</title>
   <para>
    Sıra nesneleri yine sıra şeklindeki diğer nesnelerle kıyaslanabilir.
    Önce ilk iki eleman kıyaslanır. Bunlar farklı ise sonuç belli olmuştur;
    eşit olmaları halinde sonraki iki eleman kıyaslanır ve sıralardan biri
    tükenene kadar bu işlem tekrarlanır. Eğer kıyaslanan iki öğe de sıra
    ise bunlar da kendi aralarında kıyaslanır. İki sıranın bütün öğeleri
    aynı bulunursa bu sıralar eşit kabul edilir. Eğer bir sıra diğerinin
    başından bir kısmı ile aynı ise kısa olan sıra küçük kabul edilir.
    Karakterlerin kıyaslanmasında ASCII karakter sırası kullanılır.
    Aynı türden sıraların kıyaslanmasına bazı örnekler :
   </para>
   <screen>
(1, 2, 3)              &lt; (1, 2, 4)
[1, 2, 3]              &lt; [1, 2, 4]
'ABC' &lt; 'C' &lt; 'Pascal' &lt; 'Python'
(1, 2, 3, 4)           &lt; (1, 2, 4)
(1, 2)                 &lt; (1, 2, -1)
(1, 2, 3)             == (1.0, 2.0, 3.0)
(1, 2, ('aa', 'ab'))   &lt; (1, 2, ('abc', 'a'), 4)
</screen>
   <para>
    Farklı türden nesnelerin kıyaslanmasının yasal olduğuna dikkat edin.
    Türler alfabetik sırayla dizilmiştir (ingilizce isimlerine göre).
    Yani: liste &lt; dizge &lt; demet (list &lt; string &lt; tuple).<footnote>
    <para>
     Değişik türlerin kıyaslanmasına ilişkin kurallara güvenilmemeli;
     gelecek Python sürümlerinde bu kurallar değişebilir!
    </para></footnote>
   </para>
  </sect1>
 </chapter>

 <chapter xml:id="python-tutorial_moduller">
  <?dbhtml stop-chunking?>
  <title>Modüller</title>
  <para>
   Python yorumlayıcısını kapatıp tekrar açarsanız yaptığınız tanımlar
   (işlevler ve değişkenler) kaybolur. Uzunca bir yazılım yazmak isterseniz
   bunun için yazılımınızı bir metin düzenleyici ile hazırlayıp yazdığınız
   dosyayı yorumlayıcı girişi olarak kullanırsanız daha iyi olur. Bu işleme
   betik yazmak denir. Programınız uzadıkça bunu daha kolay idare etmek için
   birkaç dosyaya bölmek isteyebilirsiniz. Yazdığınız bir işlev tanımını
   kopyalamaya ihtiyaç duymaksızın birkaç yazılımda kullanmayı da
   isteyebilirsiniz.
  </para>
  <para>
   Bu iş için Python'da modül denen dosyalar var. Bunlara yazılan tanımlar
   diğer modüllere ya da etkileşimli kipteki yorumlayıcıya <literal>import</literal>
   deyimi ile yüklenebilir.
  </para>
  <para>
   Modüller <literal>.py</literal> uzantılı metin dosyalarıdır ve içlerinde
   Python deyimleri ve tanımları bulur. Bir modül içerisinde
   <literal>__name__ </literal> global değişkeninin değeri (bir dizge) o
   modülün adını verir. Örneğin, favori metin düzenleyiciniz ile
   <literal>fibo.py</literal> adlı bir dosya yaratıp Python yorumlayıcısının
   bulabileceği bir dizine kaydedin. Dosyanın içeriği de şu olsun:
  </para>
  <screen>
# Fibonacci sayıları modülü

def fib(n):    # n e kadar Fibonacci serisini yazdır
    a, b = 0, 1
    while b &lt; n:
        print b,
        a, b = b, a+b

def fib2(n): # n e kadar Fibonacci serisi geri döndürür
    sonuc = []
    a, b = 0, 1
    while b &lt; n:
        sonuc.append(b)
        a, b = b, a+b
    return sonuc
</screen>
  <para>
   Yorumlayıcıyı açıp bu modülü şu komut ile yükleyin:
  </para>
  <screen>
<prompt>&gt;&gt;&gt;</prompt> import fibo
</screen>
  <para>
   Bu fibo içindeki işlev tanımlarını yürürlükte olan simge tablosuna
   eklemez; sadece modül adı fibo tabloya eklenir. İşlevlere modül adı
   kullanarak erişilebilir:
  </para>
  <screen>
<prompt>&gt;&gt;&gt;</prompt> fibo.fib(1000)
1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987
<prompt>&gt;&gt;&gt;</prompt> fibo.fib2(100)
[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
<prompt>&gt;&gt;&gt;</prompt> fibo.__name__
'fibo'
</screen>
  <para>
   Bir işlevi sık sık kullanmak isterseniz bunu yerel bir isme
   atayabilirsiniz:
  </para>
  <screen>
<prompt>&gt;&gt;&gt;</prompt> fib = fibo.fib
<prompt>&gt;&gt;&gt;</prompt> fib(500)
1 1 2 3 5 8 13 21 34 55 89 144 233 377
</screen>
  <sect1 xml:id="python-tutorial_moduller-daha">
   <title>Modüller Üzerine Daha Fazla Bilgi</title>
   <para>
    İşlev tanımlarının yanısıra modül içinde çalıştırılabilir ifadeler de
    olabilir. Bu ifadeler modülün ilk kullanıma hazırlanması için
    kullanılabilirler ve sadece modülün ilk yüklenişinde çalışır.<footnote>
    <para>
     Aslında işlev tanımları da `çalıştırılan' ifadelerdir; işlev adını
     modülün global simge tablosuna ekler.
    </para></footnote>
   </para>
   <para>
    Her modülün o modül içindeki bütün işlevler tarafından global simge
    tablosu olarak kullanılan kendi simge tablosu vardır. Bu özellik
    sayesinde modülü yazan kişi rahatlıkla modül içnde global değişkenler
    kullanabilir. Modülü kullanan diğer kişilerin global değişkenleri ile
    isim çakışması olmaz. Modül içindeki global değişkenlere de
    <literal>modulAdi.degiskenAdi</literal> şeklinde ulaşmak ve istenirse
    bunları değiştirmek mümkündür.
   </para>
   <para>
    Modüller diğer modülleri yükleyebilir. Bütün <literal>import</literal>
    ifadelerinin modülün (ya da betiğin) başına konması gelenektendir; ancak
    şart değildir. Yüklenen modüller kendilerini yükleyen modülün global simge
    tablosuna eklenir.
   </para>
   <para>
    <literal>import</literal> deyiminin bir modüldeki isimleri doğrudan
    yükleyen modülün simge tablosuna ekleyen kullanım şekli var. Örnek:
   </para>
   <screen>
<prompt>&gt;&gt;&gt;</prompt> from fibo import fib, fib2
<prompt>&gt;&gt;&gt;</prompt> fib(500)
1 1 2 3 5 8 13 21 34 55 89 144 233 377
</screen>
   <para>
    Bu kullanım şeklinde yüklemenin yapıldığı modül adı yerel simge tablosuna
    eklenmez (yani örnekteki fibo tanımlı değildir).
   </para>
   <para>
    Bir modülde tanımlanmış bütün isimleri de yüklemek şu şekilde mümkündür:
   </para>
   <screen>
<prompt>&gt;&gt;&gt;</prompt> from fibo import *
<prompt>&gt;&gt;&gt;</prompt> fib(500)
1 1 2 3 5 8 13 21 34 55 89 144 233 377
</screen>
   <para>
    Bu altçizgi ( <literal>_</literal> ) ile başlayanlar dışındaki bütün
    isimleri yükler.
   </para>
   <sect2><title>Modül Arama Yolu</title>
    <para>
     <literal>spam</literal> isimli bir modül yüklenmek istendiğinde
     yorumlayıcı önce çalıştırıldığı dizinde ve sonra
     <literal>PYTHONPATH</literal> ortam değişkenince tanımlanan dizinler
     içinde <literal>spam.py</literal> isimli bir dosya arar.
     <literal>PYTHONPATH</literal> dizin isimlerinden oluşan bir listedir
     (PATH gibi). Aranan dosya bulunmazsa arama, kuruluma bağlı başka bir
     yolda da aranabilir. Genelde bu <literal>/usr/local/lib/python</literal>
     dizinidir.
    </para>
    <para>
     Aslında modüller <literal>sys.path</literal> değişkeninde bulunan dizin
     listesinde aranır. Bu değişken değerini betiğin alıştırıldığı dizin,
     <literal>PYTHONPATH</literal> ve kuruluma bağlı diğer dizinlerden alır.
     <literal>sys.path</literal> değişkeni sayesinde Python yazılımları modül
     arama yolunu değiştirebilir.
    </para>
   </sect2>
   <sect2><title>"Derlenmiş" Python Dosyaları</title>
    <para>
     Derlenmiş Python dosyaları yazılımların çalışmaya başlaması için
     gereken süreyi kısaltır. Örneğin <literal>spam.py</literal> adlı
     dosyanın bulunduğu dizinde <literal>spam.pyc</literal> adlı bir dosya
     varsa bu modul, <literal>spam</literal> modülünün ikilik derlenmiş
     halidir. <literal>spam.py</literal> dosyasının son değiştirilme
     tarihi <literal>spam.pyc</literal> dosyasının içinde de kayıtlıdır ve
     bu tarihler aynı değil ise <literal>.pyc</literal> dosyası dikkate
     alınmaz.
    </para>
    <para>
     <literal>spam.pyc</literal> dosyasının oluşması için bir şey yapmanız
     gerekmez. <literal>spam.py</literal> her ne zaman başarılı olarak
     derlenirse yazılımın derlenmiş hali <literal>spam.pyc</literal>
     dosyasına kaydedilir. Bunun yapılamaması bir hata değildir; herhangi
     bir nedenle <literal>.pyc</literal> dosyası tam olarak yazılamazsa
     geçersiz sayılır ve dikkate alınmaz. <literal>.pyc</literal>
     dosyalarının içeriği platformdan bağımsızdır. Bu sayede bir Python
     modülü dizini farklı mimarideki makineler tarafından paylaşılabilir.
    </para>
    <para>
     Uzmanlar için birkaç ip ucu:
    </para>
    <itemizedlist>
     <listitem>
      <para>
       Python yorumlayıcısı <literal>-O</literal> bağımsız değişkeni ile
       çalıştırıldığında eniyileştirilmiş (optimized) kod üretilir
       ve <literal>.pyo</literal> uzantılı dosyalarda saklanır.
       Eniyileştircinin (optimizer) şu anda pek bir yararı olmuyor;
       sadece <literal>assert</literal> deyimlerini siliyor.
       <literal>-O</literal> bağımsız değişkeni kullanıldığında tüm ikilik
       kod eniyileştirilir, <literal>.pyc</literal> dosyaları göz ardı
       edilir ve <literal>.py</literal> dosyaları eniyileştirilmiş
       ikilik kod olarak derlenir.
      </para>
     </listitem>
     <listitem>
      <para>
       Yorumlayıcıya iki tane <literal>-O</literal> bağımsız değişkeni
       (<literal>-OO</literal>) vermek derleyicinin bazı ender durumlarda
       doğru çalışmayan yazılımlara neden olan eniyileştirmeler yapmasına
       neden olur. Şu anda sadece <literal>__doc__</literal> dizgeleri
       silinerek daha küçük <literal>.pyo</literal> dosyaları üretilmektedir.
       Bazı yazılımların çalışması bunların varlığına bağımlı olabileceğinden
       bu bağımsız değişkeni kullanırken dikkatli olun.
      </para>
     </listitem>
     <listitem>
      <para>
       Bir yazılım <literal>.pyc</literal> ya da <literal>.pyo</literal>
       dosyasından okunduğunda <literal>.py</literal> dosyasından okunan
       halinden daha hızlı çalışmaz; sadece yüklenme süresi kısalır.
      </para>
     </listitem>
     <listitem>
      <para>
       Bir betik komut satırından ismi verilerek çalıştırıldığında bunun
       ikilik kodu asla bir <literal>.pyc</literal> ya da
       <literal>.pyo</literal> dosyasına yazılmaz. Bu yüzden betiğin başlama
       süresini kısaltmak için bunun bir kısmı bir modüle aktarılarak ve bu
       modülü yükleyen küçük bir başlatıcı betik kullanılarak kısaltılabilir.
       Komut satırından bir <literal>.pyc</literal> ya da <literal>.pyo</literal>
       dosyası da ismi verilerek doğrudan çalıştırılabilir.
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>spam.py</literal> dosyası olmadan da <literal>spam.pyc</literal>
       (ya da <literal>-O</literal> kullanıldığında <literal>spam.pyo</literal>)
       dosyası kullanılabilir. Bunlar bir Python kodu kütüphanesinin
       tersine mühendisliği zorlaştıran şekilde dağıtılmasında
       kullanılabilir.
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>compileall</literal> modülü bir dizindeki bütün dosyalar
       için <literal>spam.pyc</literal> (ya da <literal>-O</literal>
       kullanıldığında <literal>spam.pyo</literal>) dosyaları yaratabilir.
      </para>
     </listitem>
    </itemizedlist>
   </sect2>
  </sect1>
  <sect1 xml:id="python-tutorial_moduller-std">
   <title>Standart Modüller</title>
   <para>
    Python zengin bir standart modül kütüphanesine sahiptir. Bazı modüller
    yorumlayıcı ile bütünleşiktir. Bu modüller dilin parçası olmadıkları
    halde verimlerini artırmak ya da sistem çağrıları gibi işletim sistemine
    ait özelliklere erişim için yorumlayıcı içine dahil edilmişlerdir.
    Bunlara iyi bir örnek her Python yorumlayıcısına dahil edilen
    <literal>sys</literal> modülüdür. <literal>sys.ps1</literal> ve
    <literal>sys.ps2</literal> değişkenleri de birincil ve ikincil komut
    satırı olarak kullanılan dizgeleri belirlerler:
   </para>
   <screen>
<prompt>&gt;&gt;&gt;</prompt> import sys
<prompt>&gt;&gt;&gt;</prompt> sys.ps1
'<prompt>&gt;&gt;&gt;</prompt> '
<prompt>&gt;&gt;&gt;</prompt> sys.ps2
'<prompt>...</prompt> '
<prompt>&gt;&gt;&gt;</prompt> sys.ps1 = 'C&gt; '
C&gt; print 'Böö !'
Böö !
C&gt;
</screen>
   <para>
    Bu iki değişken yorumlayıcı sadece etkileşimli kipte iken tanımlıdır.
   </para>
   <para>
    <literal>sys.path</literal> değişkeni de yorumlayıcının modül arama yolunu
    belirler. Bu değerini ortam değişkeni <literal>PYTHONPATH</literal>
    belirler. <literal>PYTHONPATH</literal> değişkenine değer atanmadıysa
    <literal>sys.path</literal> öntanımlı değerini alır. Bunun değeri
    listelere uygulana işlemler ile değiştirilebilir:
   </para>
   <screen>
<prompt>&gt;&gt;&gt;</prompt> import sys
<prompt>&gt;&gt;&gt;</prompt> sys.path.append('/ufs/guido/lib/python')
</screen>
  </sect1>
  <sect1 xml:id="python-tutorial_dir">
   <title><literal>dir()</literal> İşlevi</title>
   <para>
    Yerleşik işlev <literal>dir()</literal> bir modülün hangi isimleri
    tanımladığını bulmak içik kullanılır. Bu işlev dizgelerden oluşan bir
    liste geri döndürür:
   </para>
   <screen>
<prompt>&gt;&gt;&gt;</prompt> import fibo, sys
<prompt>&gt;&gt;&gt;</prompt> dir(fibo)
['__name__', 'fib', 'fib2']
<prompt>&gt;&gt;&gt;</prompt> dir(sys)
['__displayhook__', '__doc__', '__excepthook__', '__name__', '__stderr__',
 '__stdin__', '__stdout__', '_getframe', 'argv', 'builtin_module_names',
 'byteorder', 'copyright', 'displayhook', 'exc_info', 'exc_type',
 'excepthook', 'exec_prefix', 'executable', 'exit', 'getdefaultencoding',
 'getdlopenflags', 'getrecursionlimit', 'getrefcount', 'hexversion',
 'maxint', 'maxunicode', 'modules', 'path', 'platform', 'prefix', 'ps1',
 'ps2', 'setcheckinterval', 'setdlopenflags', 'setprofile',
 'setrecursionlimit', 'settrace', 'stderr', 'stdin', 'stdout', 'version',
 'version_info', 'warnoptions']
</screen>
   <para>
    Bağımsız değişken kullanmadan çağırılan <literal>dir()</literal>
    işlevi o anda tanımlamış olduğunuz isimleri geri döndürür:
   </para>
   <screen>
<prompt>&gt;&gt;&gt;</prompt> a = [1, 2, 3, 4, 5]
<prompt>&gt;&gt;&gt;</prompt> import fibo, sys
<prompt>&gt;&gt;&gt;</prompt> fib = fibo.fib
<prompt>&gt;&gt;&gt;</prompt> dir()
['__name__', 'a', 'fib', 'fibo', 'sys']
</screen>
   <para>
    Bunun değişken, modül, işlev vs. gibi her tür ismini listelediğine
    dikkat ediniz.
   </para>
   <para>
    <literal>dir()</literal> yerleşik işlev ve değişkenlerin isimlerini
    listelemez. Bunların bir listesini isterseniz, standart modül
    <literal>__builtin__</literal> içinde bulabilirsiniz:
   </para>
   <screen>
<prompt>&gt;&gt;&gt;</prompt> import __builtin__
<prompt>&gt;&gt;&gt;</prompt> dir(__builtin__)
['ArithmeticError', 'AssertionError', 'AttributeError',
 'DeprecationWarning', 'EOFError', 'Ellipsis', 'EnvironmentError',
 'Exception', 'False', 'FloatingPointError', 'IOError', 'ImportError',
 'IndentationError', 'IndexError', 'KeyError', 'KeyboardInterrupt',
 'LookupError', 'MemoryError', 'NameError', 'None', 'NotImplemented',
 'NotImplementedError', 'OSError', 'OverflowError', 'OverflowWarning',
 'PendingDeprecationWarning', 'ReferenceError',
 'RuntimeError', 'RuntimeWarning', 'StandardError', 'StopIteration',
 'SyntaxError', 'SyntaxWarning', 'SystemError', 'SystemExit', 'TabError',
 'True', 'TypeError', 'UnboundLocalError', 'UnicodeError', 'UserWarning',
 'ValueError', 'Warning', 'ZeroDivisionError', '__debug__', '__doc__',
 '__import__', '__name__', 'abs', 'apply', 'bool', 'buffer',
 'callable', 'chr', 'classmethod', 'cmp', 'coerce', 'compile', 'complex',
 'copyright', 'credits', 'delattr', 'dict', 'dir', 'divmod',
 'enumerate', 'eval', 'execfile', 'exit', 'file', 'filter', 'float',
 'getattr', 'globals', 'hasattr', 'hash', 'help', 'hex', 'id',
 'input', 'int', 'intern', 'isinstance', 'issubclass', 'iter',
 'len', 'license', 'list', 'locals', 'long', 'map', 'max', 'min',
 'object', 'oct', 'open', 'ord', 'pow', 'property', 'quit',
 'range', 'raw_input', 'reduce', 'reload', 'repr', 'round',
 'setattr', 'slice', 'staticmethod', 'str', 'string', 'super',
 'tuple', 'type', 'unichr', 'unicode', 'vars', 'xrange', 'zip']
</screen>
  </sect1>
  <sect1 xml:id="python-tutorial_paketler">
   <title>Paketler</title>
   <para>
    Paketler "noktalı modül isimleri" kullanarak Python'un modül isim
    alanının düzenlenmesinde kullanılır. Örneğin modül adı
    <literal>A.B</literal> adı <literal>A</literal> olan bir paket
    içindeki <literal>B</literal> adlı alt modülü gösterir. Nasıl modüller
    farklı modül yazarlarını birbirlerinin kullandığı global değişkenleri
    dert etmekten kurtarıyorsa, paketler de <literal>NumPy</literal> ya da
    <literal>PyOpenGL</literal> gibi çok sayıda modül içeren paketlerin
    birbirlerinin modül isimlerinin çakışması tehlikesinden kurtarır.
   </para>
   <para>
    Ses dosyaları ve ses verisi üzerinde işlem yapacak bir modül kolleksiyonu
    (bir "paket") geliştirmek istediğinizi düşünelim. Farklı biçemlerdeki ses
    dosyalarını (<literal>.wav</literal>, <literal>.aiff</literal>,
    <literal>.au</literal> gibi dosya uzantıları olan) birbirine dönüştürmek,
    seslere efektler uygulamak veya sesleri filtrelemek için pek çok modüle
    ihtiyacınız olacak. Paketinizin muhtemel dizin yapısı şöyle olabilir:
   </para>
   <screen>
Sound/                          Paketin en üst seviyesi
      __init__.py               paketi ilk kullanıma hazırlama
      Formats/                  Farklı dosya biçemleri için alt paket
              __init__.py
              wavread.py
              wavwrite.py
              aiffread.py
              aiffwrite.py
              auread.py
              auwrite.py
              ...
      Effects/                  ses efektleri alt paketi
              __init__.py
              echo.py
              surround.py
              reverse.py
              ...
      Filters/                  filtre alt paketi
              __init__.py
              equalizer.py
              vocoder.py
              karaoke.py
              ...
</screen>
   <para>
    <literal>__init__.py</literal> dosyaları Python'un bu dizinleri paket
    içeren dizinler olarak algılaması için gereklidir. Bunlar aynı isimli
    dizinlerin modül arama yolunda bulunacak diğer geçerli modülleri istemdışı
    saklamasını engeller. <literal>__init__.py</literal> boş bir dosya
    olabileceği gibi paketi ilk çalışmaya hazırlayabilir ya da daha sonra
    açıklanacak olan <literal>__all__</literal> değişkenine değer atıyor olabilir.
   </para>
   <para>
    Paketin kullanıcısı paketten dilediği bir modülü yükleyebilir.
   </para>
   <screen>
import Sound.Effects.echo
</screen>
   <para>
    Bu <literal>Sound.Effects.echo</literal> modülünü yükler. Modüle tüm
    ismi ile atıfta bulunulmalı:
   </para>
   <screen>
Sound.Effects.echo.echofilter(input, output, delay=0.7, atten=4)
</screen>
   <para>
    Aynı modülü yüklemenin bir diğer yolu:
   </para>
   <screen>
from Sound.Effects import echo
</screen>
   <para>
    Bu da <literal>echo</literal> alt modülünü yükler; ancak bunu paket adı
    verilmeden erişilebilir kılar ve modül şu şekilde kullanılabilir:
   </para>
   <screen>
echo.echofilter(input, output, delay=0.7, atten=4)
</screen>
   <para>
    Bir diğer yol da istenen işlev ya da değişkeni doğrudan yüklemektir:
   </para>
   <screen>
from Sound.Effects.echo import echofilter
</screen>
   <para>
    Bu da <literal>echo</literal> modülünü yükler; ancak
    <literal>echofilter()</literal> işlevini doğrudan erişilebilir kılar:
   </para>
   <screen>
echofilter(input, output, delay=0.7, atten=4)
</screen>
   <para>
    <literal>from PAKET import İSİM</literal> kullanılırken İSİM bir alt
    modül, alt paket ya da paket içinde tanımlı bir işlev, sınıf veya
    değişken ifade eden herhangi bir isim olabilir. <literal>import</literal>
    deyimi önce ismin pakette tanımlı olup olmadığına bakar; tanımlı değil
    ise bunun bir modül olduğunu varsayar ve bunu yüklemeye teşebbüs eder.
    Modülü bulamaz ise <literal>ImportError</literal> istisnası oluşur.
   </para>
   <para>
    <literal>import ÖĞE.ALTÖĞE.ALTALTÖĞE</literal> ifadesinde ise son
    ismin dışındaki isimler paket olmalıdır. Son isim bir modül veya paket
    olabilir; ancak bir önceki ismin içinde tanımlanan bir işlev ya da
    değişken olamaz.
   </para>
   <sect2><title>Bir paketten * yüklemek</title>
    <para>
     Kullanıcı <literal>from Sound.Effects import *</literal> yazdığında ne
     olur? Dosya sistemine ulaşılıp paketin içinde hangi alt paketlerin
     olduğunun bulunması ve hepsinin yüklenmesi beklenir. Bu uzun zaman alabilir ve alt modüllerin içe aktarılmasının, yalnızca alt modül açıkça içe aktarıldığında ortaya çıkan istenmeyen yan etkileri olabilir.
    </para>
    <para>
     Tek çözüm paket yazarının açık bir paket indeksi hazırlamasıdır. Bir
     paketin <literal>__init__.py</literal> dosyası <literal>__all__</literal>
     adlı bir liste tanımlıyorsa bu liste
     <literal>from PAKET import *</literal> ifadesi kullanıldığında
     yüklenecek modül isimlerinin listesi olarak kullanılır. Paketin yeni
     bir sürümü hazırlandığında bu listenin uygun şekilde güncellenmesi
     paket yazarının sorumluğundadır. Eğer paketten <literal>*</literal>
     yüklemeye ihtiyaç duyulmayacağına karar verilirse bu özellik
     kullanılmayabilir. Örneğin <literal>Sounds/Effects/__init__.py</literal>
     dosyasının içeriği şöyle olabilir:
    </para>
    <screen>
__all__ = ["echo", "surround", "reverse"]
</screen>
    <para>
     Bu <literal>from Sound.Effects import *</literal> ifadesinin <literal>Sound</literal>
     paketinden isimleri <literal>__all__</literal> içinde geçen üç modülün
     yüklemesini sağlar.
    </para>
    <para>
     <literal>__all__</literal> tanımlanmamış ise
     <literal>from Sound.Effects import *</literal> ifadesi <literal>Sound.Effects</literal>
     paketindeki bütün alt modülleri yürürlükte olan isim alanına yüklemez;
     sadece <literal>Sound.Effects</literal> paketinin ve içindeki isimlerin
     yüklenmesini sağlar (muhtemelen <literal>__init__.py</literal>) dosyasını
     çalıştırdıktan sonra). Bundan önceki <literal>import</literal> deyimlerince
     yüklenen alt paketler de yüklenir. Şu koda bir bakalım:
    </para>
    <screen>
import Sound.Effects.echo
import Sound.Effects.surround
from Sound.Effects import *
</screen>
    <para>
     Bu örnekte <literal>echo</literal> ve <literal>surround</literal>
     modülleri <literal>from...import...</literal> ifadesi çalıştırıldığında
     <literal>Sound.Effects</literal> paketinde tanımlı oldukları için
     yürürlükte olan isim alanına yüklenir. Bu <literal>__all__</literal>
     tanımlı olduğunda da bu çalışır.
    </para>
    <para>
     Genel olarak bir modül ya da paketten <literal>*</literal> yüklemek
     hoş karşılanmaz; çünkü çoğunlukla zor okunan koda neden olur. Bunun
     etkileşimli kipte kullanılmasının bir sakıncası yoktur. Ayrıca bazı
     modüller sadece belirli bir kalıba uyan isimleri verecek şekilde
     tasarlanmışlardır.
    </para>
    <para>
     <literal>from PAKET import GEREKLİ_ALTMODÜL</literal> ifadesini
     kullanmanın hiç bir kötü tarafı yoktur. Yükleyen modül farklı
     paketlerden aynı isimli modüller yüklemeye gereksinim duymadığı
     sürece tavsiye edilen kullanım şekli de budur.
    </para>
   </sect2>
   <sect2><title>Birbirlerini Yükleyen Modüller</title>
    <para>
     Alt modüller çoğu kez birbirlerine atıfta bulunur. Örneğin
     surround modülü echo modülüne ihtiyaç duyabilir. Aslında bu
     türden atıflar öyle yaygındır ki <literal>import</literal>
     deyimi standart modül arama yoluna bakmadan önce çağrıldığı
     paketin içinde arama yapar. Bu şekilde surround modülü
     <literal>import echo</literal> veya
     <literal>from echo import echofilter</literal> ifadeleri ile
     kolayca echo modülüne kavuşabilir. Yüklenmek istenen modül içinde
     bulunan pakette (yükleme yapmaya çalışan modülün bulunduğu paket)
     bulunamaz ise <literal>import</literal> deyimi aynı isimli üst
     seviyeli bir modül arar.
    </para>
    <para>
     Paketler Sound paketindeki gibi alt paketler şeklinde düzenlenmişler
     ise farklı alt paketler içindeki modüllerin birbirilerine atıfta
     bulunmasının kısa bir yolu yoktur; paketin tam adı kullanılmalıdır.
     Örneğin, Sound.Filters.vocoder modülünün echo modülünü kullanması
     gerekiyor ise <literal>from Sound.Effects import echo</literal>
     ifadesi ile buna erişebilir.
    </para>
   </sect2>
   <!--
   <sect2><title>Dizinlere göre paketler</title>
    <para>
     Packages support one more special attribute, <filename>__path__</filename>. This is initialized to be a list containing the name of the directory holding the package’s <filename>__init__.py</filename> before the code in that file is executed. This variable can be modified; doing so affects future searches for modules and subpackages contained in the package.
    </para>
    <para>
     While this feature is not often needed, it can be used to extend the set of modules found in a package.
    </para>
   </sect2>
   -->
  </sect1>
 </chapter>

 <chapter xml:id="python-tutorial_io">
  <?dbhtml stop-chunking?>
  <title>Giriş ve Çıkış</title>
  <para>
   Bir yazılımın çıktısını sunmanın birkaç yolu vardır; veri yazdırılabilir
   ya da gelecekte kullanılabilecek şekilde bir dosyaya kaydedilebilir.
   Bu bölümde giriş ve çıkış ile ilgili olanakların bazılarına değineceğiz.
  </para>
  <sect1 xml:id="python-tutorial_write">
   <title>Daha Güzel Çıkış Biçemi</title>
   <para>
    Buraya kadar değerleri yazdırmanın iki yolunu gördük: deyim ifadeleri ve
    print deyimi. Üçüncü bir yol da dosya nesnelerinin <literal>write()</literal>
    yöntemidir. Standart çıktıya <literal>sys.stdout</literal> şeklinde atıfta
    bulunulabilir.
   </para>
   <para>
    Çoğu zaman boşluklar ile birbirinden ayrılmış değerlerden daha iyi
    biçimlendirilimiş bir çıktıya ihtiyaç duyulur. Çıktınızı biçimlendirmenin
    iki yolu var. İlki bütün dizge işlemlerini dilimleme ve birleştirme ile
    yapıp istediğiniz herhangi bir biçimi elde etmek.
    <literal>string</literal> standart modülü dizgelerin istenen sütun
    genişliğine kadar boşluklar ile doldurulmasını sağlayan, daha sonra
    değineceğimiz, bazı faydalı işlevlere sahiptir. İkinci yol ise sol
    bağımsız değişkeni bir dizge olan <literal>%</literal> işlecini
    kullanmaktır. <literal>%</literal> işleci sol bağımsız değişkeni sağdaki
    bağımsız değişkenine uygulanacak <literal>sprintf()</literal>
    tarzı biçim dizgesi olarak yorumlar ve biçimleme işleminden sonra bir
    dizge geri döndürür.
   </para>
   <para>
    Sayısal değerleri dizgeye çevirmek için ise değer
    <literal>repr()</literal> veya <literal>str()</literal> işlevine
    geçirilebilir ya da ters tırnak işareti (<userinput>``</userinput>)
    içine alınabilir (<literal>repr()</literal> ile aynı etkiye sahiptir).
   </para>
   <para>
    <literal>str()</literal> işlevi değerlerin insan tarafından okunabilir
    gösterimini geri döndürürken, <literal>repr()</literal> işlevi yorumlayıcı
    tarafından okunabilir gösterimini geri döndürür (veya uygun sözdizim yok
    ise <literal>SyntaxError</literal> istisnası oluşturur). İnsan için anlam
    ifade edecek bir gösterimi bulunmayan nesneler için
    <literal>str()</literal> işlevi <literal>repr()</literal> ile aynı değeri
    döndürür. Rakamlar, listeler ve sözlükler gibi yapılar ile daha pek çok
    değer için her iki işlev de aynı sonucu verir. Dizgeler ve gerçel sayılar
    ise iki farklı gösterime sahiptir.
   </para>
   <para>İşte birkaç örnek:</para>
   <screen>
<prompt>&gt;&gt;&gt;</prompt> s = 'Hello, world.'
<prompt>&gt;&gt;&gt;</prompt> str(s)
'Hello, world.'
<prompt>&gt;&gt;&gt;</prompt> `s`
"'Hello, world.'"
<prompt>&gt;&gt;&gt;</prompt> str(0.1)
'0.1'
<prompt>&gt;&gt;&gt;</prompt> `0.1`
'0.10000000000000001'
<prompt>&gt;&gt;&gt;</prompt> x = 10 * 3.25
<prompt>&gt;&gt;&gt;</prompt> y = 200 * 200
<prompt>&gt;&gt;&gt;</prompt> s = 'The value of x is ' + `x` + ', and y is ' + `y` + '...'
<prompt>&gt;&gt;&gt;</prompt> print s
The value of x is 32.5, and y is 40000...
<prompt>&gt;&gt;&gt;</prompt> # Ters tırnaklar sayılar dışındaki tipler ile de çalışır:
<prompt>...</prompt> p = [x, y]
<prompt>&gt;&gt;&gt;</prompt> ps = repr(p)
<prompt>&gt;&gt;&gt;</prompt> ps
'[32.5, 40000]'
<prompt>&gt;&gt;&gt;</prompt> # Karakter dizisinde ise tırnaklar ve ters bölü işareti eklenir:
<prompt>...</prompt> hello = 'hello, world\n'
<prompt>&gt;&gt;&gt;</prompt> hellos = `hello`
<prompt>&gt;&gt;&gt;</prompt> print hellos
'hello, world\n'
<prompt>&gt;&gt;&gt;</prompt> # Ters tırnakların bağımsız değişkeni bir demet de olabilir:
<prompt>...</prompt> `x, y, ('spam', 'eggs')`
"(32.5, 40000, ('spam', 'eggs'))"
</screen>
   <para>
    Sayıların kare ve küplerinden oluşan bir tablo yazdırmanın iki yolu
    vardır:
   </para>
   <screen>
<prompt>&gt;&gt;&gt;</prompt> import string
<prompt>&gt;&gt;&gt;</prompt> for x in range(1, 11):
<prompt>...</prompt>     print string.rjust(`x`, 2), string.rjust(`x*x`, 3),
<prompt>...</prompt>     # Üst satırın sonundaki virgüle dikkat edin.
<prompt>...</prompt>     print string.rjust(`x*x*x`, 4)
<prompt>...</prompt>
 1   1    1
 2   4    8
 3   9   27
 4  16   64
 5  25  125
 6  36  216
 7  49  343
 8  64  512
 9  81  729
10 100 1000
<prompt>&gt;&gt;&gt;</prompt> for x in range(1,11):
<prompt>...</prompt>     print '%2d %3d %4d' % (x, x*x, x*x*x)
<prompt>...</prompt>
 1   1    1
 2   4    8
 3   9   27
 4  16   64
 5  25  125
 6  36  216
 7  49  343
 8  64  512
 9  81  729
10 100 1000
</screen>
   <para>
    Sütunların arasındaki bir karakterlik boşluk <literal>print</literal>
    tarafından eklenir; bağımsız değişkenlerin arasına daima bir boşluk
    karakteri eklenir.
   </para>
   <para>
    Bu örnek dizgelerin başını boşluklar ile doldurup bunları sağ tarafa
    dayayan <literal>string.rjust()</literal> işlevini kullanmaktadır.
    Buna benzer <literal>string.ljust()</literal> ve
    <literal>string.center()</literal> işlevleri de vardır. Bunlar bir şey
    yazdırmaz; sadece yeni bir dizge geri döndürür. Verilen
    dizge uzun ise kırpılmaz ve aynen geri döndürülür; bu
    sütunlarınızın bozulmasına sebep olmasına rağmen hatalı bir değer
    göstermekten iyidir. Büyük bir değeri kırpmayı gerçekten istiyorsanız
    dilimleme ile bunu yapabilirsiniz
    (<literal>string.ljust(x, n)[0:n]</literal> gibi).
   </para>
   <para>
    <literal>string.zfill()</literal> işlevi ise rakamlar içeren dizgelerin
    başını sıfırlar ile doldurur. Bu işlev artı ve eksi işaretlerini de
    dikkate alır:
   </para>
   <screen>
<prompt>&gt;&gt;&gt;</prompt> import string
<prompt>&gt;&gt;&gt;</prompt> string.zfill('12', 5)
'00012'
<prompt>&gt;&gt;&gt;</prompt> string.zfill('-3.14', 7)
'-003.14'
<prompt>&gt;&gt;&gt;</prompt> string.zfill('3.14159265359', 5)
'3.14159265359'
</screen>
   <para>
    <literal>%</literal> işleçi şu şekilde kullanılır:
   </para>
   <screen>
<prompt>&gt;&gt;&gt;</prompt> import math
<prompt>&gt;&gt;&gt;</prompt> print 'PI sayısının yaklaşık değeri: %5.3f' % math.pi
PI sayısının yaklaşık değeri: 3.142
</screen>
   <para>
    Dizgenin içinde birden fazla biçem varsa sağ terim olarak bir demet
    kullanmak gerekir:
   </para>
   <screen>
<prompt>&gt;&gt;&gt;</prompt> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 7678}
<prompt>&gt;&gt;&gt;</prompt> for name, phone in table.items():
<prompt>...</prompt>     print '%-10s ==&gt; %10d' % (name, phone)
<prompt>...</prompt>
Jack       ==&gt;       4098
Dcab       ==&gt;       7678
Sjoerd     ==&gt;       4127
</screen>
   <para>
    Çoğu biçim aynı C dilindeki gibi çalışır ve doğru veri türünün
    geçirilmesi gerekir; bu yapılamaz ise bir istisna oluşur.
    <literal>%s</literal> biçiminin kullanımı daha rahattır; verilen
    bağımsız değişken dizge değilse yerleşik işlev <literal>str()</literal> ile
    dizgeye dönüştürülür. Genişlik ya da hassasiyeti belirtmek için
    <literal>*</literal> ile bir tamsayı bağımsız değişken kullanılabilir. C dilindeki
    <literal>%n</literal> ve <literal>%p</literal> biçimler ise
    desteklenmemektedir.
   </para>
   <para>
    Eğer bölmek istemediğiniz gerçekten uzun bir biçim dizgeniz varsa
    biçimlendirmek istediğiniz bağımsız değişkenlere konumu yerine ismiyle atıfta
    bulunabilmeniz güzel olur. Bu aşağıda gösterildiği gibi
    <literal>%(isim)biçim</literal> şeklinde yapılabilir:
   </para>
   <screen>
<prompt>&gt;&gt;&gt;</prompt> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 8637678}
<prompt>&gt;&gt;&gt;</prompt> print 'Jack: %(Jack)d; Sjoerd: %(Sjoerd)d; Dcab: %(Dcab)d' % table
Jack: 4098; Sjoerd: 4127; Dcab: 8637678
</screen>
   <para>
    Bu özellik bütün yerel değişkenlerin bulunduğu bir sözlük geri döndüren
    yerleşik işlev <literal>vars()</literal> ile beraber kullanıldığında
    faydalı olur.
   </para>
  </sect1>
  <sect1 xml:id="python-tutorial_dosyalar">
   <title>Dosya Okuma ve Yazma</title>
   <para>
    <literal>open()</literal> işlevi bir dosya nesnesi geri döndürür ve
    genellikle iki bağımsız değişken ile kullanılır: <literal>open(dosya_adı, kip)</literal>
   </para>
   <screen>
<prompt>&gt;&gt;&gt;</prompt> f=open('/tmp/workfile', 'w')
<prompt>&gt;&gt;&gt;</prompt> print f
&lt;open file '/tmp/workfile', mode 'w' at 80a0960&gt;
</screen>
   <para>
    İlk bağımsız değişken dosya adını içeren bir dizgedir. İkincisi ise
    dosyanın nasıl kullanılacağını belirten karakterlerden oluşur. Erişim kipi
    dosyadan sadece okuma yapılacak ise <literal>'r'</literal>, sadece yazma
    için <literal>'w'</literal> (aynı isimli bir dosya zaten var ise üzerine
    yazılır) ve dosyanın sonuna eklemeler yapmak için <literal>'a'</literal>
    olur. <literal>'r+'</literal> kipi dosyayı hem okuma hem de yazma yapmak
    için açar. <literal>kip</literal> bağımsız değişkeni seçimliktir; kullanılamaması halinde <literal>'r'</literal> olduğu varsayılır.
  </para>
   <para>
    Windows ve Macintosh üzerinde kipe eklenen <literal>'b'</literal> harfi
    dosyayı ikilik kipte açar; yani <literal>'rb'</literal>,
    <literal>'wb'</literal> ve <literal>'r+b'</literal> gibi kipler de vardır.
    Windows metin ve ikilik dosyaları arasında ayrım yapmaktadır; metin
    dosyalarında okuma veya yazma işlemlerinde satır sonu karakterleri
    otomatik olarak biraz değişir. Bu görünmez değişiklik ASCII metin
    dosyaları için iyidir; anacak JPEG resimler veya .EXE dosyalar gibi iklik
    verileri bozar.
   </para>
   <sect2><title>Dosya Nesnelerinin Yöntemleri</title>
    <para>
     Bundan sonraki örneklerde <literal>f</literal> adlı bir dosya nesnesinin
     önceden oluşturulmuş olduğunu varsayacağız.
    </para>
    <para>
     Dosyanın içeriğini okumak için belirli miktarda veriyi okuyup bunu
     dizge olarak geri döndüren <literal>f.read(boy)</literal>yöntemi
     kullanılabilir. <literal>boy</literal> okunacak bayt sayısını
     belirleyen seçimlik bir bağımsız değişkendir; kullanılmaması halinde dosyanın
     tamamı okunur. Dosyanın sonuna gelindiğinde <literal>f.read()</literal>
     boş bir dizge ("") geri döndürür.
    </para>
    <screen>
<prompt>&gt;&gt;&gt;</prompt> f.read()
'Dosyanın tamamı bu satırdan oluşuyor.\n'
<prompt>&gt;&gt;&gt;</prompt> f.read()
''
</screen>
    <para>
     <literal>f.readline()</literal> dosyadan tek bir satır okur. Satırın
     sonundaki satırsonu karakteri (<literal>\n</literal>) korunur; ancak
     dosya bir satırsonu karakteri ile bitmiyor ise son satırda bu karakter
     silinir. Bu özellik geri döndürülen değerin birden fazla anlama gelmesini
     engeller; <literal>f.readline()</literal> boş bir dizge geri
     döndürdüğünde dosyanın sonuna ulaşılırken boş bir satır tek bir
     <literal>'\n'</literal> karakteri ile ifade edilir.
    </para>
    <screen>
<prompt>&gt;&gt;&gt;</prompt> f.readline()
'Bu dosyanın ilk satırı.\n'
<prompt>&gt;&gt;&gt;</prompt> f.readline()
'Dosyanın ikinci satırı\n'
<prompt>&gt;&gt;&gt;</prompt> f.readline()
''
</screen>
    <para>
     <literal>f.readlines()</literal> dosya içindeki bütün satırların
     bulunduğu bir liste geri döndürür. Seçimlik bağımsız değişken
     <literal>boy_ipucu</literal> kullanılması durumunda ise dosyadan
     <literal>boy_ipucu</literal> kadar ve bundan bir satır tamamlamaya
     yetecek kadar fazla bayt okunur ve bunlar yine satırlar listesi
     şeklinde geri döndürülür.
    </para>
    <screen>
<prompt>&gt;&gt;&gt;</prompt> f.readlines()
['Bu dosyanın ilk satırı.\n', 'Dosyanın ikinci satırı\n']
</screen>
    <para>
     <literal>f.write(dizge)</literal> yöntemi <literal>dizge</literal>
     içeriğini dosyaya yazar ve <literal>None</literal> geri döndürür.
    </para>
    <screen>
<prompt>&gt;&gt;&gt;</prompt> f.write('Bu bir deneme satırıdır.\n')
</screen>
    <para>
     <literal>f.tell()</literal> dosya nesnesinin dosya içindeki konumunu
     belirten bir tamsayı geri döndürür (dosyanın başından bayt cinsinden
     ölçülür). <literal>f.seek(uzaklık, nereden)</literal> ile de dosyanın
     içinde istenen konuma gidilebilir. Konum, <literal>uzaklık</literal>
     ile başvuru noktası <literal>nereden</literal> değerlerinin toplanması
     ile bulunur. <literal>nereden</literal> 0 olursa dosyanın başını,
     1 o andaki konumu, 2 ise dosyanın sonunu belirtir. <literal>nereden</literal>
     kullanılmaz ise 0 olduğu varsayılır ve başvuru noktası olarak dosyanın
     başı alınır.
    </para>
     <screen>
<prompt>&gt;&gt;&gt;</prompt> f=open('/tmp/workfile', 'r+')
<prompt>&gt;&gt;&gt;</prompt> f.write('0123456789abcdef')
<prompt>&gt;&gt;&gt;</prompt> f.seek(5)     # Dosyadaki 5'inci bayta git
<prompt>&gt;&gt;&gt;</prompt> f.read(1)
'5'
<prompt>&gt;&gt;&gt;</prompt> f.seek(-3, 2) # Sondan 3'üncü bayta git
<prompt>&gt;&gt;&gt;</prompt> f.read(1)
'd'
</screen>
    <para>
     Dosya ile işiniz bittiğinde <literal>f.close()</literal> yöntemini
     çağırarak dosyayı kapatabilir ve dosyanın işgal ettiği sistem
     kaynaklarını serbest bırakabilirsiziz. <literal>f.close()</literal>
     çağrıldıktan sonra dosya üzerinde başka işlem yapmaya devam etmek
     mümkün değildir:
    </para>
    <screen>
<prompt>&gt;&gt;&gt;</prompt> f.close()
<prompt>&gt;&gt;&gt;</prompt> f.read()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
ValueError: I/O operation on closed file
</screen>
    <para>
     Dosya nesnelerinin <literal>isatty()</literal> ve
     <literal>truncate()</literal> gibi pek sık kullanılmayan başka
     yöntemleri de vardır.
    </para>
   </sect2>
   <sect2><title><literal>pickle</literal> Modülü</title>
    <!-- pickle is obsolete and also insecure. Burada
    "JSON ile yapılandırılmış verinin saklanması" başlıklı konu olacak -->
    <para>
     Dizgeler kolayca dosyalara yazılıp dosyalardan okunabilir. Sayılar
     biraz zahmetlidir; çünkü <literal>read()</literal> yöntemi sadece
     dizgeleri geri döndürür ve bunların '123' gibi bir değeri alıp sayısal
     değeri 123'ü geri döndüren <literal>string.atoi()</literal> işlevinden
     geçirilmeleri gerekir. Listeler, sözlükler ve sınıf örnekleri gibi daha
     karmaşık veri türlerini dosyalara kaydetmek isterseniz işler oldukça
     zorlaşır.
    </para>
    <para>
     Yazılımcıları karmaşık veri türlerini saklamak için kodlamak ve hata
     ayıklamak ile uğraştırmak yerine Python bu iş için <literal>pickle</literal>
     adlı standart modülü sağlar. Bu hayret verici modül neredeyse herhangi
     bir Python nesnesini (bazı Python kodu biçimlerini bile!) dizge ile ifade
     edilebilecek hale getirebilir ve bu halinden geri alabilir. Bu dönüşüm ve
     geri kazanım işlemleri arasında nesne bir dosyaya kaydedilebilir ya da ağ
     bağlantısı ile uzaktaki başka bir makineye gönderilebilir.
   </para>
    <para>
     <literal>x</literal> gibi bir nesneniz ve yazma işlemi için açılmış
     <literal>f</literal> gibi bir dosya nesneniz varsa bu nesneyi dosyaya
     aktarmanız için tek satırlık kod yeterli olur:
    </para>
    <screen>
pickle.dump(x, f)
</screen>
    <para>
     Nesneyi geri almak için ise <literal>f</literal> okumak için açılmış
     bir dosya nesnesi olsun:
    </para>
     <screen>
x = pickle.load(f)
</screen>
    <para>
     Birden fazla nesnenin dönüştürülmesi gerekiyor ya da dönüştürülmüş
     olan nesnelerin dosyaya yazılması istenmiyor ise <literal>pickle</literal>
     farklı şekilde kullanılır. Bunları <literal>pickle</literal> modülünün
     belgelerinden öğrenmek mümkündür.
    </para>
    <para>
     <literal>pickle</literal> modülü saklanabilen ve başka yazılımlar
     tarafından ya da aynı yazılımın farklı çalışma zamanlarında
     kullanılabilecek Python nesneleri yapmanın standart yoludur.
     <literal>pickle</literal> modülü çok yaygın kullanıldığından Python
     genişletme modülleri yazan çoğu yazılımcı matrisler gibi yeni veri
     türlerinin doğru olarak dönüştürülebilir ve geri alınabilir olmasına
     özen gösterir.
    </para>
   </sect2>
  </sect1>
 </chapter>

 <chapter xml:id="python-tutorial_hatalar">
  <?dbhtml stop-chunking?>
  <title>Hatalar ve İstisnalar</title>
  <para>
   Şu ana kadar hata mesajlarından pek bahsedilmedi; ancak örnekleri
   denediyseniz muhtemelen birkaç tane görmüşsünüzdür. Birbirinden ayırt
   edilebilen en az iki tür hata mevcuttur: sözdizim hataları ve istisnalar.
  </para>
  <sect1 xml:id="python-tutorial_sozdizimi">
   <title>Sözdizim Hataları</title>
   <para>
    Sözdizim hataları ayrıştırma (parsing) hataları olarak da bilinirler
    ve Python öğrenirken en çok bunlar ile karşılaşırsınız:
   </para>
   <screen>
<prompt>&gt;&gt;&gt;</prompt> while 1 print 'Merhaba'
  File "&lt;stdin&gt;", line 1, in ?
    while 1 print 'Merhaba'
                ^
SyntaxError: invalid syntax
</screen>
   <para>
    Ayrıştırıcı sorun olan satırı basar ve satır içinde hatanın algılandığı
    ilk noktayı küçük bir `ok' ile gösterir. Hata oktan önce gelen kısımdan
    kaynaklanmaktadır. Örnekte hata <literal>print</literal> anahtar
    kelimesinde fark edilmektedir; çünkü ondan önce bir iki nokta üst üste
    (":") karakteri eksiktir. Dosya adı ve satır numarası da yazdırılmaktadır
    ki yorumlayıcı girişinin bir dosyadan gelmesi durumunda hatanın nereden
    kaynaklandığını bilesiniz.
   </para>
  </sect1>
  <sect1 xml:id="python-tutorial_istisnalar">
   <title>İstisnalar</title>
   <para>
    Bir deyim ya da ifade sözdizimsel olarak doğru olsa da yürütülmek
    istendiğinde bir hataya sebep olabilir. İcra sırasında meydana gelen
    hatalara istisna denir. İstisnaları nasıl ele alabileceğinizi yakında
    öğreneceksiniz. Çoğu istisnalar yazılımlar tarafından ele alınmaz ve
    aşağıdakiler gibi hata mesajları ile sonuçlanırlar:
   </para>
   <screen>
<prompt>&gt;&gt;&gt;</prompt> 10 * (1/0)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
ZeroDivisionError: integer division or modulo
<prompt>&gt;&gt;&gt;</prompt> 4 + spam*3
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
NameError: spam
<prompt>&gt;&gt;&gt;</prompt> '2' + 2
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
TypeError: illegal argument type for built-in operation
</screen>
   <para>
    Hata mesajının son satırı sorunun ne olduğunu belirtir. İstisnaların
    farklı türleri vardır ve istisnanın türü hata mesajının bir bölümü olarak
    yazdırılır. Örneklerdeki istisna türleri: <literal>ZeroDivisionError</literal>,
    <literal>NameError</literal> ve <literal>TypeError</literal>. İstisna türü
    olarak yazdırılan dizge meydana gelen istisnanın yerleşik ismidir.
    Bu bütün yerleşik istisnalar için geçerlidir; ancak kullanıcı tanımlı
    istisnalar için böyle olmayabilir. Standart istisna isimleri yerleşik
    belirteçlerdir; ayrılmış anahtar kelimeler değil.
   </para>
   <para>
    Satırın devamı istisna türüne bağlı ayrıntılardan oluşur ve anlamı
    istisna türüne bağlıdır.
   </para>
   <para>
    Hata mesajının baş kısmında istisnanın meydana geldiği yer yığın dökümü
    şeklinde görülür. Bu genellikle istisnanın gerçekleştiği noktaya gelene
    kadar işletilen kaynak kodu şeklinde olur; ancak standart girdiden
    okunan satırlar gösterilmez.
   </para>
   <para>
    Yerleşik istisnalar ve bunların anlamları için Python ile gelen
    belgelerden yararlanılabilir.
   </para>
  </sect1>
  <sect1 xml:id="python-tutorial_istisnalar-daha">
   <title>İstisnaların Ele Alınması</title>
   <para>
    Belirli istisnaları ele alan yazılımlar yazmak mümkündür. Aşağıdaki örnek,
    kullanıcıdan geçerli bir tamsayı girilene kadar kullanıcıdan giriş yapması
    istenir. Control-C tuş kombinasyonu (ya da işletim sisteminin desteklediği
    başka bir kombinasyon) ile kullanıcı yazılımdan çıkabilir. Kullanıcın
    sebep olduğu bu olay ise <literal>KeyboardInterrupt</literal> istisnasının
    oluşmasına neden olur.
   </para>
   <screen>
<prompt>&gt;&gt;&gt;</prompt> while True:
<prompt>...</prompt>     try:
<prompt>...</prompt>         x = int(raw_input("Lütfen bir rakam giriniz: "))
<prompt>...</prompt>         break
<prompt>...</prompt>     except ValueError:
<prompt>...</prompt>         print "Bu geçerli bir giriş değil.  Tekrar deneyin..."
<prompt>...</prompt>
</screen>
   <para>
    <literal>try</literal> deyimi aşağıdaki gibi çalışır:
   </para>
   <itemizedlist>
    <listitem>
     <para>
      Önce <literal>try</literal> bloğu (<literal>try</literal> ve
      <literal>except</literal> arasındaki ifade(ler)) işletilir.
     </para>
    </listitem>
    <listitem>
     <para>
      Hiçbir istisna oluşmaz ise <literal>except</literal> bloğu atlanır
      ve <literal>try</literal> deyimin icrası son bulur.
     </para>
    </listitem>
    <listitem>
     <para>
      Eğer <literal>try</literal> bloğu içinde bir istisna oluşur ise
      bloğun geri kalanı atlanır. İstisnanın türü <literal>except</literal>
      anahtar kelimesinden sonra kullanılan ile aynı ise <literal>try</literal>
      bloğunun kalan kısmı atlanır ve <literal>except</literal> bloğu
      yürütülür. Programın akışı <literal>try ... except</literal> kısmından
      sonra gelen ilk satırdan devam eder.
     </para>
    </listitem>
    <listitem>
     <para>
      Adı <literal>except</literal> bloğunda geçmeyen bir istisna oluşur
      ise üst seviyedeki <literal>try</literal> ifadelerine geçirilir; ancak
      bunu ele alan bir şey bulunmaz ise bu bir ele alınmamış istisna olur ve
      yürütme işlemi yukarıda da görüldüğü gibi bir hata mesajı ile son bulur.
     </para>
    </listitem>
   </itemizedlist>
   <para>
    Bir <literal>try</literal> deyimi farklı istisnaları yakalayabilmek için
    birden fazla <literal>except</literal> bloğuna sahip olabilir. Bir
    <literal>except</literal> bloğu parantez içine alınmış bir liste ile
    birden fazla istisna adı belirtebilir. Örnek:
   </para>
   <screen>
<prompt>...</prompt> except (RuntimeError, TypeError, NameError):
<prompt>...</prompt>     pass
</screen>
   <para>
    Son <literal>except</literal> bloğu istisna adı belirtilmeden de
    kullanılıp herhangi bir istisnayı yakalayabilir. Bunu çok dikkatli
    kullanın, çünkü çok ciddi bir yazılımlama hatasını bu şekilde gözden
    kaçırabilirsiniz! Bu özellik bir hata mesajı bastırıp ve tekrar bir
    istisna oluşturarak çağıranın istisnayı ele almasını da sağlamak için
    kullanılabilir:
   </para>
   <screen>
import string, sys

try:
    f = open('myfile.txt')
    s = f.readline()
    i = int(string.strip(s))
except IOError, (errno, strerror):
    print "I/O error(%s): %s" % (errno, strerror)
except ValueError:
    print "Could not convert data to an integer."
except:
    print "Unexpected error:", sys.exc_info()[0]
    raise
</screen>
   <para>
    <literal>try ... except</literal> ifadesinin seçimlik
    <literal>else</literal> bloğu da vardır. Bu her
    <literal>except</literal> bloğunun ardına yazılır ve
    <literal>try</literal> bloğunun istisna oluşturmadığı durumlarda
    icra edilmesi gereken kod bulunduğu zaman kullanılır. Örnek:
   </para>
   <screen>
for arg in sys.argv[1:]:
    try:
        f = open(arg, 'r')
    except IOError:
        print 'cannot open', arg
    else:
        print arg, 'has', len(f.readlines()), 'lines'
        f.close()
</screen>
   <para>
    <literal>else</literal> bloğu kullanmak <literal>try</literal> bloğuna
    ek satırlar eklemekten iyidir çünkü bu <literal>try ... except</literal>
    ifadesi tarafından korunan kodun oluşturmadığı bir istisnanın kazara
    yakalanmasını engeller.
   </para>
   <para>
    Bir istisna meydana geldiğinde istisna bağımsız değişkeni olarak bilinen
    bir değer de bulunabilir. Bağımsız değişkennin varlığı ve türü istisnanın
    türüne bağlıdır. Bağımsız değişkeni olan istisna türleri için
    <literal>except</literal> bloğunda istisna adından (ya da listesinden)
    sonra bağımsız değişken değerini alacak bir değişken belirtilebilir:
   </para>
   <screen>
<prompt>&gt;&gt;&gt;</prompt> try:
<prompt>...</prompt>     spam()
<prompt>...</prompt> except NameError, x:
<prompt>...</prompt>     print 'name', x, 'undefined'
<prompt>...</prompt>
name spam undefined
</screen>
   <para>
    Bir istisnanın bağımsız değişkeni var ise ele alınmayan istisna mesajının
    son kısmında (`ayrıntı') basılır.
   </para>
   <para>
    İstisna işleyiciler (exception handlers) sadece <literal>try</literal>
    bloğu içinde meydana gelen istisnaları değil <literal>try</literal>
    bloğundan çağırılan (dolaylı olarak bile olsa) işlevlerdeki istisnaları
    da ele alır. Örnek:
   </para>
   <screen>
<prompt>&gt;&gt;&gt;</prompt> def this_fails():
<prompt>...</prompt>     x = 1/0
<prompt>...</prompt>
<prompt>&gt;&gt;&gt;</prompt> try:
<prompt>...</prompt>     this_fails()
<prompt>...</prompt> except ZeroDivisionError, detail:
<prompt>...</prompt>     print 'Handling run-time error:', detail
<prompt>...</prompt>
Handling run-time error: integer division or modulo
</screen>
  </sect1>
  <sect1 xml:id="python-tutorial_istisna-olusturma">
   <title>İstisna Oluşturma</title>
   <para>
    <literal>raise</literal> deyimi yazılımcının kasıtlı olarak bir istisna
    oluşturmasını sağlar. Örnek:
   </para>
   <screen>
<prompt>&gt;&gt;&gt;</prompt> raise NameError, 'Merhaba'
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
NameError: Merhaba
</screen>
   <para>
    <literal>raise</literal> için ilk bağımsız değişken oluşturulacak
    istisnanın adıdır ve ikinci bağımsız değişken ise istisnanın bağımsız
    değişkenidir.
   </para>
   <para>
    Eğer bir istisnanın oluşup oluşmadığını öğrenmek istiyor; fakat bunu
    ele almak istemiyorsanız, <literal>raise</literal> ifadesinin istisnayı
    tekrar oluşturmanıza mkan veren daha basit bir biçimi var:
   </para>
   <screen>
<prompt>&gt;&gt;&gt;</prompt> try:
<prompt>...</prompt>     raise NameError, 'Merhaba'
<prompt>...</prompt> except NameError:
<prompt>...</prompt>     print 'Bir istisna gelip geçti!'
<prompt>...</prompt>     raise
<prompt>...</prompt>
Bir istisna gelip geçti!
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 2, in ?
NameError: Merhaba
</screen>
  </sect1>
  <sect1 xml:id="python-tutorial_istisna-kull">
   <title>Kullanıcı Tanımlı İstisnalar</title>
   <para>
    Programlar yeni bir istisna sınıfı yaratarak kendi istisnalarını
    isimlendirebilir. İstisnalar genellikle, doğrudan veya dolaylı olarak,
    <literal>Exception</literal> sınıfından türetilir. Örnek:
   </para>
   <screen>
<prompt>&gt;&gt;&gt;</prompt> class bizimHata(Exception):
<prompt>...</prompt>     def __init__(self, deger):
<prompt>...</prompt>         self.deger = deger
<prompt>...</prompt>     def __str__(self):
<prompt>...</prompt>         return `self.deger`
<prompt>...</prompt>
<prompt>&gt;&gt;&gt;</prompt> try:
<prompt>...</prompt>     raise bizimHata(2*2)
<prompt>...</prompt> except bizimHata, e:
<prompt>...</prompt>     print 'İstisnamız oluştu, deger:', e.deger
<prompt>...</prompt>
İstisnamız oluştu, deger: 4
<prompt>&gt;&gt;&gt;</prompt> raise bizimHata, 'aaah!'
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
__main__.bizimHata: 'aaah!'
</screen>
   <para>
    İstisna sınıfları diğer sınıfların yapabildiği her şeyi yapabilecek şekilde
    tanımlanabilirler, fakat genellikle basit tutulurlar ve sıklıkla sadece
    istisnayı işleyenlerin hata hakkında bilgi almasını sağlayacak birkaç
    özellik sunar. Birkaç farklı istisna oluşturabilen bir modül yaratırken,
    yaygın bir uygulama da bu modül tarafından tanımlanan istisnalar için bir
    temel sınıf yaratıp ve farklı hata durumları için bundan başka istisna
    sınıfları türetmektir:
   </para>
   <screen>
class Error(Exception):
    """Bu modüldeki istisnalar için temel sınıf."""
    pass

class GirisHatasi(Error):
    """Giriş hataları için oluşacak istisna.

    Özellikler:
        ifade -- hatanın oluştuğu giriş ifadesi
        mesaj -- explanation of the error
    """

    def __init__(self, ifade, mesaj):
        self.ifade = ifade
        self.mesaj = mesaj

class GecisHatasi(Error):
    """İzin verilmeyen bir durum geçişine teşebbüs edildiğinde oluşacak istisna.

    Özellikler:
        onceki -- geçiş başlangıcındaki durum
        sonraki -- istenen yeni durum
        mesaj -- durum geçişine izin verilmemesinin sebebi
    """

    def __init__(self, onceki, sonraki, mesaj):
        self.onceki = onceki
        self.sonraki = sonraki
        self.mesaj = mesaj
</screen>
   <para>
    Çoğu standart modül kendi tanımladıkları işlevlerde meydana gelen hataları
    rapor etmek için kendi istisnalarını tanımlar.
   </para>
   <para>
    Sınıflar üzerine daha fazla bilgi sonraki bölümünde sunulacaktır.
   </para>
  </sect1>
  <sect1 xml:id="python-tutorial_try">
   <title>Son İşlemlerin Belirlenmesi</title>
   <para>
    <literal>try</literal> deyiminin her durumda yürütülecek işlemleri
    belirten seçimlik bir bloğu da vardır. Örnek:
   </para>
   <screen>
<prompt>&gt;&gt;&gt;</prompt> try:
<prompt>...</prompt>     raise KeyboardInterrupt
<prompt>...</prompt> finally:
<prompt>...</prompt>     print 'Goodbye, world!'
<prompt>...</prompt>
Goodbye, world!
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 2
KeyboardInterrupt
</screen>
   <para>
    <literal>finally</literal> bloğu <literal>try</literal> bloğu içinde
    bir istisna oluşsa da oluşmasa da yürütülür. Bir istisna oluşursa
    <literal>finally</literal> bloğu icra edildikten sonra istisna tekrar
    oluşturulur. <literal>Finally</literal> bloğu <literal>try</literal>
    deyimi <literal>break</literal> veya <literal>return</literal> ile
    sonlanırsa da icra edilir.
   </para>
   <para>
    <literal>try</literal> deyiminin bir ya da daha fazla
    <literal>except</literal> bloğu veya bir <literal>finally</literal>
    bloğu olmalıdır; ancak her ikisi bir arada olamaz.
   </para>
  </sect1>
 </chapter>
 <chapter xml:id="python-tutorial_siniflar">
  <?dbhtml stop-chunking?>
  <title>Sınıflar</title>
  <para>
   Python'un sınıf mekanizması sınıfları çok az bir sözdizimi ve
   kavramsallıkla dile ekler. Sınıf mekanizması C++ ile Modula-3 karışımıdır
   denebilir. Python'da sınıflar modüllerdeki gibi kullanıcı ile tanımlar
   arasına somut engeller koymaz. Python'da sınıflara gücünü veren başlıca
   özelliklerini şöyle sıralayabiliriz: sınıflar çok sayıda sınıfı miras
   alabilir. Bu türetilmiş sınıflar, atalarının yöntemlerini değiştirerek
   kullanabilirler; ataları ile aynı isme sahip yöntemlerle, atasındaki
   yöntemleri çağırabilir. Nesneler özel verilere sahip olabilir.
  </para>
  <para>
   C++ terminolojisinde, tüm sınıf üyeleri (veri üyeleri dahil)
   <literal>public</literal> ve tüm üye işlevler <literal>virtual</literal>'dir.
   Özel bir kurucu ya da yıkıcı yoktur. Modula-3'deki gibi, bir nesnenin
   yöntemlerinden üyelerine başvuru için bir kestirme yol yoktur: bir üye
   yöntem, dolaylı olarak çağrı ile sağlanan ve doğrudan nesneyi ifade eden
   bir ilk bağımsız değişken ile bildirilir. Smalltalk'daki gibi, sınıfların kendileri
   nesnelerdir (sınıfların ve nesnelerin kavramsal özelliklerine uymasa da
   böyledir). Python'da tüm veri türleri birer nesnedir. Bu onların yeniden
   isimlendirilebilmesi ve başka veri türlerine dahil edilmesi için bir yol
   sağlar. Ancak kullanıcı bunları genişletmek için temel sınıf olarak
   kullanamaz. Ayrıca Modula-3'de olmayan ama C++'da olan, özel yazımlı bir
   çok yerleşik işleç (aritmetik işleçler, alt indisleme, vs), sınıf
   gerçeklemeleri için yeniden tanımlanabilir.
  </para>
  <sect1 xml:id="python-tutorial_terminoloji">
   <title>Terminoloji hakkında...</title>
   <para>
    Sınıflar hakkında konuşurken, evrensel olarak kabul edilmiş bir
    terminolojinin olmayışından dolayı arasıra Smalltalk ve C++ terimlerini
    kullanacağım. (Aslında, nesne yönelimi açısından Python'a daha çok benzeyen
    Modula-3 dili terimlerini kullanırdım; fakat bu dilden haberdar olan
    okuyucuların azınlıkta olduğunu sanıyorum.)
   </para>
   <para>
    Ayrıca nesne yönelim kavramını bilenleri bir terminoloji tuzağına karşı
    uyarmalıyım: "Nesne" sözcüğü, Python'da "bir sınıfın gerçeklenmesi"
    anlamına gelmez.
    Smalltalk'da olmayan ancak C++ ve Modula-3'dekine
    benzer şekilde Python'daki veri türlerinin hepsi birer sınıf değildir:
    tamsayılar ve listeler gibi yerleşik veri türleri ile dosyalar sınıf
    değildir. Yine de tüm Python veri türleri için ortak bir kavramı
    paylaşmaları adına nesnelerdir demek yanlış olmaz.
   </para>
   <para>
    Nesneler tek tek ve çoklu isimlerle (çoklu etki alanları içinde), aynı
    nesneye bağlı olabilir. Bu diğer dillerde kod isimlendirme (aliasing)
    olarak bilinir. Bu genellikle Python'da ilk bakışta anlaşılmaz ve
    değişmez temel türler (sayılar, dizgeler, demetler) ile çalışırken
    yoksayılabilir. Yine de kod isimlendirme, listeler sözlükler gibi
    değiştirilebilen nesneler ve yazılım dışındaki öğeler (dosyalar,
    pencereler, vs) için kullanılan bazı türlerinde katılımıyla Python kodunun
    kavramsallaştırılmasında (kasıtlı!) bir etkiye sahiptir. Bazı yönleriyle
    kod isimlendirme göstergelere benzer bir davranış sergilediğinden
    genellikle, yazılım yararına kullanılmıştır. Örneğin, sadece göstergesi
    aktarıldığından bir nesnenin aktarılması kolaydır; eğer bir işlev,
    bir bağımsız değişken olarak aktarılan bir nesneyi değiştirirse, işlevi
    çağıran değişikliği görecektir - bu, Pascal'daki gibi iki farklı bağımsız
    değişken aktarma gereksinimini ortadan kaldırır.
   </para>
  </sect1>
  <sect1 xml:id="python-tutorial_isimalani">
   <title>Python Etki ve İsim Alanları</title>
   <para>
    Sizi sınıflar ile tanışmadan önce, biraz da Python'un etki alanı kurallarından
    bahsetmem gerek. Sınıf tanımlamalarını tam olarak anlamak için etki ve isim
    alanlarının nasıl çalıştığını bilmeniz gerek. Bu konudaki bilgiler ileri
    seviyedeki her Python yazılımcısı için yaralıdır.
   </para>
   <para>Birkaç tanım ile işe koyulalım.</para>
   <para>
    Bir <emphasis>isim alanı</emphasis> isimler ile nesnelerin eşleşmesidir.
    Çoğu isim alanı şu anda Python sözlükleri olarak kodlanmışlardır, fakat bu
    hiçbir şekilde fark edilmez ve gelecekte değiştirilebilir. İsim alanlarına
    örnekler: yerleşik isimler kümesi (<literal>abs()</literal> gibi işlevler
    ve yerleşik istisna isimleri vs.), bir modül içindeki global isimler ve
    bir işlev çağrısındaki yerel isimler. Bir nesnenin özellikler kümesi de
    bir isim alanıdır. İsim alanlarına ilişkin bilinecek önemli şey farklı
    isim alanlarındaki isimlerin birbirileri ile hiçbir ilişkisi olmadığıdır.
    Örneğin, iki farklı modül karışıklık yaratmadan “maksimize” adlı birer
    işlev tanımlayabilir; kullanıcılar bu işlevleri önlerine modül adını
    ekleyerek kullanır.
   </para>
   <para>
    Bu arada, bir noktadan sonra yazılan her herhangi bir isim için
    <emphasis>öznitelik</emphasis> sözcüğünü kullanıyorum. Örneğin,
    <literal>z.real</literal> ifadesinde <literal>real</literal>,
    <literal>z</literal> nesnesinin bir özniteliğidir. Modül içindeki
    isimlere atıflar da öznitelik atıflarıdır:
    <literal>modulAdi.fonkAdi</literal> ifadesinde
    <literal>modulAdi</literal> bir modül nesnesidir ve
    <literal>fonkAdi</literal> bunun bir özniteliğidir. Bir modülün
    öznitelikleri ile içinde tanımlı global değişkenler aynı isim alanını
    paylaşır. <footnote>
    <para>
     Buna bir istisna: modül nesnelerinin, modülün isim alanını oluşturmada
     kullanılan sözlüğü oluşturan <literal>__dict__</literal> isimli salt
     okunur ve gizli bir özniteliği vardır. <literal>__dict__</literal> bir
     özniteliktir fakat global bir isim değildir.
    </para></footnote>
   </para>
   <para>
    öznitelikler salt okunur veya yazılabilir olabilir. Yazılabilir
    oldukları durumda özniteliklere atama yapmak mümkündür. Modül
    öznitelikleri yazılabilirdir: <literal>modulAdi.sonuc = 42</literal>
    gibi bir ifade kullanabilirsiniz. Yazılabilir öznitelikleri
    <literal>del</literal> deyimini kullanarak silmek de mümkündür.
    Örneğin <literal>del modulAdi.sonuc</literal> ifadesi
    <literal>modulAdi</literal> nesnesinden sonuc isimli özniteliği siler.
   </para>
   <para>
    Farklı anlarda yaratılan isim alanlarının farklı ömürleri olur. Yerleşik
    isimleri içeren isim alanı Python yorumlayıcısı çalıştırıldığında
    yaratılır ve asla silinmez. Bir modüle ait global isim alanı modül tanımı
    okunduğunda yaratılır ve genellikle yorumlayıcı çalıştığı sürece
    silinmez. Yorumlayıcının bir dosyadan veya etkileşimli olarak
    çalıştırdığı deyimler de <literal>__main__</literal> isimli bir modüle
    ait kabul edilir ve bunların da kendi global isim alanı vardır. Yerleşik
    isimler de <literal>__builtin__</literal> isimli bir modülde bulunur.
   </para>
   <para>
    Bir işleve ait yerel isim alanı işlev çağırıldığında yaratılır ve işlevden
    dönüldüğünde veya işlev içinde ele alınmamış bir istisna gerçekleştiğinde
    silinir. Tabii ki özyinelemeli çağrıların herbiri kendi yerel isim alanına
    sahiptir.
   </para>
   <para>
    Bir <emphasis>etki alanı</emphasis> bir isim alanının doğrudan erişilebildiği bir
    metin bölgesidir. Burada “doğrudan erişilebilir” ifadesinin anlamı, yetersiz bir
    isim atfının isim alanında isim bulmaya teşebbüs etmesidir.
   </para>
   <para>
    Etki alanları statik olarak belirlenmelerine rağmen, dinamik olarak
    kullanılır. İcranın herhangi bir anında isim alanlarına doğrudan
    erişilebilen iç içe geçmiş en az üç etki alanı vardır: ilk aranan ve
    yerel isimleri içeren en iç etki alanı; en yakın olanından başlanarak
    aranan çevreleyen işlevlerin isim alanları; daha sonra aranan ve o andaki
    modülün global değişkenlerini içeren orta etki alanı; ve yerleşik
    isimlerin bulunduğu isim alanı olan en dış etki alanı (en son aranır).
   </para>
   <para>
    Eğer bir isim global olarak tanımlanmış ise tüm atıflar ve atamalar
    doğrudan modülün global isimlerini barındıran orta etki alanına gider.
    Zaten, en iç etki alanının dışındaki tüm isimler salt okunurdur.
   </para>
   <para>
    Genellikle yerel etki alanı o an içinde bulunulan (yazılım metninde)
    işlevin yerel isimlerine atıfta bulunur. İşlevlerin dışında yerel etki
    alanı global etki alanı ile aynı isim alanıdır: modülün isim alanı. Sınıf
    tanımlamaları ayrıca yerel etki alanı içerisine bir başka isim alanı daha
    ekler.
   </para>
   <para>
    Etki alanlarının metne bağlı olarak belirlendiğini anlamak önemlidir. Bir
    modül içinde tanımlı bir işlevin global etki alanı o modülün isim
    alanıdır; nereden çağırıldığı ya da hangi farklı isim ile çağırıldığı bir
    fark yaratmaz. Diğer yandan, asıl isim araması icra anında dinamik olarak
    yapılır; ancak dilin tanımı “derleme” sırasında yapılan statik isim
    çözümlemeye doğru değişmektedir ve dinamik isim çözümlemeye
    güvenmemelisiniz! Örneğin, yerel değişkenler şu anda statik olarak
    belirlenmektedir.
   </para>
   <para>
    Python'a özgü bir tuhaflık da atamaların her zaman en iç etki alanına
    gitmesidir. Atamalar veri kopyalamaz; sadece nesnelere isimler bağlar.
    Aynı şey silme işlemleri için de geçerlidir: <literal>del x </literal>
    ifadesi <literal>x</literal>'in yerel etki alanı tarafından atfedilen
    isim alanındaki bağını kaldırır. Aslında, yeni isimler yaratan tüm
    işlemler yerel etki alanını kullanır. İşlev tanımları ve
    <literal>import</literal> deyimleri modül veya işlev adını
    yerel etki alanına bağlar. Bir değişkenin global etki alanında
    bulunduğunu belirtmek için <literal>global</literal> deyimi
    kullanılabilir.
  </para>
  </sect1>
  <sect1 xml:id="python-tutorial_siniflar-ilk">
   <title>Sınıflara İlk Bakış</title>
   <para>
    Sınıflar ile bir miktar yeni sözdizim ve kavram ile üç yeni nesne türü
    tanıtacağız.
   </para>
   <sect2><title>Sınıf Tanımlama</title>
    <para>
     Sınıf tanımlamanın en basit şekli şöyledir:
    </para>
    <screen>
class SinifAdi:
    &lt;deyim-1&gt;
    .
    .
    .
    &lt;deyim-N&gt;
</screen>
    <para>
     Sınıf tanımlamaları, işlev tanımlamalarında (<literal>def</literal>
     deyimleri) olduğu gibi etkin olmaları için önce işletilmeleri gerekir.
     (Yanlışlıkla sınıf tanımlarını <literal>if</literal> deyimleri veya
     işlev içlerine koymamaya dikkat edin.)
   </para>
    <para>
     Pratikte bir sınıf tanımının içindeki deyimler genellikle
     işlev tanımları olur; fakat başka deyimler de kullanmak mümkün ve
     yararlıdır (buna daha sonra yine değineceğiz). Sınıf içindeki işlev
     tanımlarının bağımsız değişken listesi kendilerine özgü bir şekle
     sahiptir; ancak buna da daha sonra değineceğiz.
    </para>
    <para>
     Bir sınıf tanımına girildiğinde yeni bir isim alanı (name space)
     oluşturulur ve bu yerel etki alanı (scope) olarak kullanılır. Yerel
     değişkenlere yapılan bütün atamalar bu yeni isim alanına gider. Yeni
     tanımlanan işlevlerin isimleri de buraya eklenir.
    </para>
    <para>
     Bir sınıf tanımı normal olarak tamamlandığında bir <emphasis>sınıf
     nesnesi</emphasis> yaratılmış olur. Bu, temel olarak, sınıf tanımının
     oluşturduğu isim alanı etrafında bir örtüdür. Sınıf nesnelerini bir
     sonraki bölümde daha yakından tanıyacağız. Orjinal etki alanı
     (sınıf tanımına girilmeden önce etkin olan) yine eski yerini alır ve
     sınıf nesnesi de buna sınıf tanımında kullanılan isim (örnekteki
     <literal>SinifAdi</literal>) ile dahil olur.
    </para>
   </sect2>
   <sect2><title>Sınıf Nesneleri</title>
    <para>
     Sınıf nesneleri iki tür işlemi destekler: özniteliklere başvuru ve sınıfın örneklenmesi.
    </para>
    <para>
     <emphasis>Özniteliklere başvuru</emphasis> için Python'da bütün
      özniteliklere erişmek için kullanılan standart sözdizim kullanılır:
      <literal>nesne.isim</literal>. Kullanılabilecek öznitelik isimleri sınıfın nesnesi oluşturulurken sınıfın isim alanında bulunan bütün isimlerdir. Sınıf tanımımız aşağıdaki gibi ise:
     </para>
     <screen>
class benimSinif:
    "Basit bir sınıf örneği."
    i = 12345
    def f(self):
        return 'Merhaba'
</screen>
    <para>
     <literal>benimSinif.i</literal> ve <literal>benimSinif.f</literal>
     bir tamsayı ve bir yöntem nesnesi geri döndüren geçerli öznitelik
     başvurularıdır. Sınıf özniteliklerine atama yapmak da mümkündür.
     Örneğin atama yoluyla <literal>benimSinif.i</literal> değeri
     değiştirilebilir. Ayrıca, <literal>__doc__</literal> da geçerli
     bir öznitelik olup sınıfa ait belgeleme dizgesini geri döndürür:
     "Basit bir sınıf örneği.".
    </para>
    <para>
     <emphasis>Sınıfın gerçeklenmesi</emphasis>, işlev sözdizimini
     kullanır. Sınıf nesnesini yeni bir sınıf gerçeklemesi geri döndüren
     bağımsız değişkeniz bir işlevmiş gibi düşünebilirsiniz. Örneğin yukarıda
     tanımladığımız sınıf için:
    </para>
    <screen>x = benimSinif()</screen>
    <para>
     Yeni bir sınıf gerçeklemesidir ve sınıf <literal>x</literal> yerel
     değişkenine atanarak bir nesne oluşur.
    </para>
    <para>
     Gerçeklenme işlemi (bir sınıf nesnesini ``çağırmak'') boş bir nesne
     yaratır. Pek çok sınıf nesnesinin bilinen bir ilk durumda oluşturulması
     istenir. Bu yüzden bir sınıfta <literal>__init__()</literal> adlı
     özel yöntem şu şekilde tanımlanabilir:
    </para>
    <screen>
def __init__(self):
    self.data = []
</screen>
    <para>
     Bir sınıfın <literal>__init__()</literal> yöntemi tanımlanmış ise sınıf
     gerçeklenmesi işlemi, yeni sınıf gerçeklemesi sırasında bu yöntemi otomatik olarak çağırır.
    </para>
    <para>
     Daha fazla esneklik için <literal>__init__()</literal> yönteminin
     bağımsız değişkenleri da olabilir. Bu durumda sınıfın gerçeklenmesinde
     kullanılan bağımsız değişkenler <literal>__init__()</literal> yöntemine aktarılır.<footnote>
     <para>
      [Ç.N.]: Diğer nesne yönelimli yazılımlama dillerinde bu işleme
      "nesnenin ilklendirilmesi" denir.
     </para></footnote> Örnek:
    </para>
    <screen>
<prompt>&gt;&gt;&gt;</prompt> class karmasikSayi:
<prompt>...</prompt>     def __init__(self, gercekKsm, sanalKsm):
<prompt>...</prompt>         self.g = gercekKsm
<prompt>...</prompt>         self.s = sanalKsm
<prompt>...</prompt>
<prompt>&gt;&gt;&gt;</prompt> x = karmasikSayi(3.0, -4.5)
<prompt>&gt;&gt;&gt;</prompt> x.g, x.s
(3.0, -4.5)
</screen>
   </sect2>
   <sect2><title>Örnek Nesneler</title>
    <para>
     Nesnelerle ne yapabiliriz? Bunlar ile yapabileceğimiz
     tek şey öznitelikleri ile uğraşmaktır. Nesnelerin iki tür özniteliği
     vardır. Bunların ilki veri öznitelikleridir. Veri özniteliklerinin
     tanımlanmış olması gerekmez; yerel değişkenlerde olduğu gibi bunlar
     da kendilerine ilk atama yapıldığında var olur. Örneğin
     <literal>x</literal>'in yukarıda tanımlanan <literal>benimSinif</literal>
     sınıfının bir örneği olduğunu düşünürsek aşağıdaki yazılım parçası
     16 değerini geride bir iz bırakmadan yazdırır:
    </para>
    <screen>
x.sayac = 1
while x.sayac &lt; 10:
    x.sayac = x.sayac * 2
print x.sayac
del x.sayac
</screen>
    <para>
     Nesnelerin ikinci tür öznitelikleri de yöntemlerdir.
     Yöntem bir sınıfa “ait olan” bir işlevdir. Python dilinde yöntemler
     sınıf örneklerine özgü değildir; diğer nesne türlerinin de
     yöntemleri olabilir. Örneğin liste nesnelerinin append, insert, remove, sort gibi yöntemleri vardır. Aşağıda yöntem terimini,
     aksi belirtilmediği sürece, sadece sınıflardan örneklenen nesnelerin yöntemleri anlamında kullanacağız.
    </para>
    <para>
     Bir nesneye ilişkin geçerli öznitelik isimleri bunun
     sınıfına bağlıdır. Tanıma göre işlev olan tüm sınıf öznitelikleri o
     nesnenin yöntemleri olur. Bu yüzden örnek sınıfımız için
     <literal>x.f</literal> geçerli bir yöntem başvurusudur, çünkü
     <literal>benimSinif.f</literal> bir işlevdir, fakat
     <literal>x.i</literal> bir yöntem değildir, çünkü
     <literal>benimSinif.i</literal> bir işlev değildir.
     Burada şuna dikkat edelim: <literal>x.f</literal> ile
     <literal>benimSinif.f</literal> aynı şey değildir.
    </para>
   </sect2>
   <sect2><title>Yöntem Nesneleri</title>
    <para>
     Genellikle bir yöntem şu şekilde doğrudan çağırılır:
    </para>
    <screen>x.f()</screen>
    <para>
     Bizim örneğimizde bu 'Merhaba' dizgesini geri döndürür.
     Bir yöntemi doğrudan çağırmak şart değildir: <literal>x.f</literal>
     bir yöntemdir ve bir değişkene saklanıp daha sonra çağırılabilir.
     Örneğin:
    </para>
    <screen>
xf = x.f
while 1:
    print xf()
</screen>
    <para>Sonsuza kadar "'Merhaba'" yazdırır.</para>
    <para>
     Bir yöntem çağrıldığında tam
     olarak ne olur? <literal>x.f()</literal> çağrılırken bir bağımsız
     değişken kullanılmadığı halde <literal>f</literal> işlev tanımında bir
     bağımsız değişken kullanıldığını (<literal>self</literal>)fark
     etmişsinizdir. Bağımsız değişkene ne oldu acaba? Şüphesiz Python,
     bağımsız değişken gerektiren bir işlev bağımsız değişkeniz
     çağırıldığında bir istisna oluşturur. Cevabı belki de tahmin ettiniz:
     yöntemler, işlevin ilk bağımsız değişkeni olarak nesneyi alır. Başka bir deyişle
     Python'da yöntemler, kendi içinde, tanımlı olduğu nesneyi barındıran
     nesnelerdir. Örneğimizdeki <literal>x.f()</literal> çağrısı aslında
     <literal>benimSinif.f(x)</literal> ile aynıdır. Genel olarak, bir
     yöntemi <literal>n</literal> elemanlı bir bağımsız değişken listesi ile
     çağırmak, aynı işlevi başına nesnenin de eklendiği bir bağımsız değişken
     listesi kullanarak çağırmak ile aynı şeydir.
    </para>
   </sect2>
  </sect1>
  <sect1 xml:id="python-tutorial_siniflar-aciklamalar">
   <title>Bazı Açıklamalar</title>
   <para>
    Veri öznitelikleri aynı isimli yöntem özniteliklerini bastırır. Büyük
    yazılımlardaki zor fark edilen isim çakışması hatalarından kaçınmak
    için çakışmaları en aza indirecek bir isimlendirme yöntemi kullanmak
    akıllıca olur. Yöntem isimlerini büyük harf ile başlatılırken, veri
    isimleri özel bir karakter (alt çizgi gibi) ile başlatılabilir.
    Yöntemler için fiil ve veri yapıları için isim olan kelimeler
    kullanılabilir.
   </para>
   <para>
    Veri özniteliklerine o nesnenin kullanıcıları (“istemcileri”)
    başvuru yapabileceği gibi, yöntemler de bunlara başvuruda bulunabilir.
    Başka bir deyişle, sınıflar tamamen soyut veri türleri oluşturmak için
    kullanılamaz. Aslında, Python'da hiçbir şey veri saklamayı zorlamayı
    mümkün kılmaz.
   </para>
   <para>
    Kullanıcılar nesnelerin veri özniteliklerini dikkatli kullanmalılar;
    çünkü istemciler yöntemler tarafından kullanılan önemli değişkenlere
    atama yaparak istenmeyen hatalara sebep olabilir. İstemcilerin, isim
    çakışmalarından kaçındıkları sürece, bir nesneye yöntemlerinin
    geçerliliğini etkilemeden kendi veri özniteliklerini ekleyebileceklerine
    dikkat edin.
   </para>
   <para>
    Yöntem içinden veri özniteliklerine (ya da diğer yöntemlere!) başvuruda
    bulunmanın kestirme bir yolu yoktur. Bunun aslında yöntemlerin
    okunabilirliğini artırdığını düşünüyorum; bir yönteme göz attığınızda
    yerel değişkenler ile nesne değişkenlerini birbirilerine karıştırma şansı
    yoktur.
   </para>
   <para>
    Usul olarak yöntemlerin ilk özniteliğine <literal>self</literal>
    adı verilir. Bu tamamen usule dayanır; <literal>self</literal> isminin
    Python için kesinlikle hiç bir özel anlamı yoktur. Bu usule uymazsanız
    yazılımınız diğer Python yazılımcıları tarafından daha zor okunur ve
    sınıf tarayıcısı (class browser) yazılımları da bu usule dayanıyor
    olabilir.
   </para>
   <para>
    Sınıf özniteliği olan her işlev, o sınıfın nesneleri için bir
    yöntem tanımlar. İşlev tanımının sınıf tanımı içerisinde olması şart
    değildir; işlevi, sınıf içindeki yerel bir değişkene atamak da mümkündür.
    Örneğin:
   </para>
   <screen>
# Sınıf dışında tanımlanmış işlev
def f1(self, x, y):
    return min(x, x+y)

class C:
    f = f1
    def g(self):
        return 'Merhaba'
    h = g
</screen>
   <para>
    Şimdi <literal>f</literal>, <literal>g</literal> ve
    <literal>h</literal>'nın hepsi <literal>C</literal> sınıfının özellikleri
    oldular ve aynı anda <literal>C</literal> sınıfının nesnelerinin de
    yöntemleridirler (<literal>g</literal> ve <literal>h</literal> birbirinin
    tamamen aynısıdır). Bu tür uygulamanın genellikle sadece okuyucunun
    kafasını karıştırmaya yaradığına dikkat edin. Yöntemler
    <literal>self</literal> öğesinin yöntem özelliğini kullanarak diğer yöntemleri çağırabilir:
</para>
    <screen>
class Bag:
    def __init__(self):
        self.data = []
    def add(self, x):
        self.data.append(x)
    def addtwice(self, x):
        self.add(x)
        self.add(x)
</screen>
   <para>
    Yöntemler sıradan işlevlerin yaptığı şekilde global değişkenlere
    başvuru yapabilir. Bir yönteme ilişkin global etki alanı sınıf
    tanımının bulunduğu modüldür. Sınıfın kendisi asla global etki alanı
    olarak kullanılmaz. Bir yöntem içinde global veri kullanmak için ender
    olarak iyi bir sebep olduğu halde, global etki alanı kullanımın pek çok
    mantıklı sebebi vardır. Örneğin, global etki alanına yüklenmiş işlev ve
    modülleri, yöntemler ve bunun içinde tanımlanmış diğer işlev ve sınıflar
    kullanılabilir. Genellikle yöntemi içeren sınıfın kendisi bu global etki
    alanı içinde tanımlanmıştır ve bir sonraki kısımda bir yöntemin kendi
    sınıfına başvurmak istemesi için birkaç iyi sebep bulacağız!
   </para>
  </sect1>
  <sect1 xml:id="python-tutorial_miras">
   <title>Kalıtım</title>
   <para>
   Tabii ki, kalıtım desteği olmayan bir “sınıf” adına layık olmaz.
   Türetilmiş sınıf tanımının sözdizimi aşağıdaki gibidir:
  </para>
  <screen>
class turemisSinifAdi(TemelSinifAdi):
    &lt;deyim-1&gt;
    .
    .
    .
    &lt;deyim-N&gt;
</screen>
   <para>,
    <literal>TemelSinifAdi</literal> ismi türetilmiş sınıfın tanımının
    bulunduğu etki alanında tanımlı olmalıdır. Temel sınıf adı yerine bir
    ifade kullanmak da mümkündür. Bu temel sınıf adı başka bir modül
    içinde tanımlı olduğunda yararlıdır:
   </para>
   <screen>class turemisSinifAdi(modulAdi.TemelSinifAdi):</screen>
   <para>
    Bir türetilmiş sınıf tanımının işletilmesi bir temel sınıf ile aynıdır.
    Bir sınıf nesnesi yaratıldığında temel sınıf hatırlanır. Bu özellik
    başvurularını çözümlemede kullanılır; başvuruda bulunulan öznitelik o
    sınıfta yok ise temel sınıfta aranır. Bu kural temel sınıfın kendisi
    de başka bir sınıftan türetildiyse ardışık olarak çağırılır.
   </para>
   <para>
    Türetilmiş sınıftan nesne oluşturmanın özel bir tarafı yoktur:
    <literal>turetilmisSinifAdi()</literal> o sınıfın yeni bir
    nesnesini yaratır. Yöntem başvuruları şu şekilde çözümlenirler: ilgili
    sınıf özelliği, gerekirse temel sınıflar zinciri taranarak, aranır ve
    yöntem başvurusu geçerli ise bu bir işlev verir.
   </para>
   <para>
    Türetilmiş sınıflar
    temel sınıflarının yöntemlerini bastırabilir. Yöntemler aynı nesnenin
    diğer yöntemlerini çağırırken özel önceliklere sahip olmadıkları için
    aynı temel sınıfta tanımlı bir yöntemi çağıran temel sınıf yöntemi bunu
    bastıran bir türetilmiş sınıf yöntemini çağırmış olabilir.
    C++ yazılımcıları için not: Tüm Python yöntemleri sanaldır (virtual).
   </para>
   <para>
    Türetilmiş sınıftaki bir bastıran yöntem aslında temel sınıftaki
    yöntemin yerini almak yerine onu geliştirmek isteyebilir. Temel sınıf
    yöntemini doğrudan çağırmanın basit bir yolu vardır:
    <literal>temelSinifadi.yontemAdi(self, argumanlar)</literal>. Bu bazen
    istemciler için de faydalıdır. Bunun sadece, temel sınıf, global etki
    alanı içine doğrudan yüklendiyse çalıştığına dikkat edin.
   </para>
   <sect2><title>Çoklu Kalıtım</title>
    <para>
     Python çoklu kalıtımın kısıtlı bir şeklini destekler. Birçok temel
     sınıfı olan bir sınıf tanımı aşağıdaki gibidir:
    </para>
    <screen>
class turemisSinifAdi(temel1, temel2, temel3):
    &lt;ifade-1&gt;
    .
    .
    .
    &lt;ifade-N&gt;
</screen>
    <para>
     Burada sınıf özniteliği başvurularını çözümlemede kullanılan kuralı
     açıklamamız gerekiyor. Bir öznitelik <literal>turemisSinifAdi</literal>
     içinde bulunamazsa <literal>temel1</literal> içinde sonra
     <literal>temel1</literal>'in temel sınıfları içerisinde ve burada da
     bulunamazsa <literal>temel2</literal> içinde aranır vs.
    </para>
    <para>
     Bazı kişilere
     <literal>temel1</literal>'den önce <literal>temel2</literal> ve
     <literal>temel3</literal> içinde arama yapmak daha doğal gelir. Bu
     <literal>temel1</literal>'in herhangi bir özniteliğinin
     <literal>temel1</literal> içinde veya bunun temel sınıflarında
     tanımlanmış olup olmadığını bilmenizi gerektir ki <literal>temel2</literal>
     içindeki isimler ile çakışmalardan kaçınabilesiniz.
    </para>
    <para>
     Python'un kazara
     oluşan isim çakışmalarına karşı usule dayanması çoklu kalıtımın rasgele
     kullanımı yazılımın bakımını yapan için bir kabus olduğu açıktır.
     Çoklu kalıtımın iyi bilinen bir problemi aynı temel sınıfa sahip iki
     sınıftan türetme yapmaktır. Bu durumda ne olduğunu anlamak kolaydır;
     ancak bunun ne işe yarayacağı pek açık değildir.
    </para>
   </sect2>
  </sect1>
  <sect1 xml:id="python-tutorial_ozel-deg">
   <title>Özel Değişkenler</title>
   <para>
    Sınıfa özel belirteçler (identifier) için sınırlı destek vardır.
    <literal>__spam</literal> formundaki (en az iki alt çizgilik bir önek ve
    en fazla bir alt çizgilik sonek) bir belirteç
    <literal>_sinifadi__spam</literal> şeklini alır. Burada
    <literal>sinifadi</literal> o anki sınıf adının sonek alt çizgileri
    atılmış olan halidir. Bu değişiklik belirtecin sözdizimsel konumuna
    bakılmaksızın yapılır ki bu sınıf üyesine özel değişkenler yaratılabilsin.
    Değiştirilen belirteç 255 karakteri aşarsa kırpılabilir. Sınıflar dışında
    veya sınıf adı sadece alt çizgilerden oluşuyorsa kırpma olmaz.
   </para>
   <para>
    İsim değiştirmenin amacı sınıflara, türemiş sınıflarca tanımlanan nesne
    değişkenlerini dert etmeden veya sınıf dışındaki nesne değişkenleri ile
    uğraşmadan, kolayca özel nesne değişkenleri ve yöntemleri tanımlama yolu
    sağlamaktır. Değiştirme kurallarının genelde kazaları önlemeye yönelik
    olduğuna dikkat edin; ancak yine de buna niyet eden kişi özel değişkenlere
    ulaşıp bunları değiştirebilir. Bu bazı özel durumlarda kullanışlı da olabilir.
  </para>
   <para>
    <literal>exec()</literal>, <literal>eval()</literal> veya <literal>evalfile()</literal>
    işlevlerine aktarılacak kod, çağıran sınıf adının o anki sınıf adı olduğunu düşünmez;
    bu da “ikilik derlenmiş” kod ile sınırlı global deyiminin etkisine benzer. Aynı
    kısıtlama <literal>getattr()</literal>, <literal>setattr()</literal> ve
    <literal>delattr()</literal> işlevleri için ve doğrudan başvurulduğunda
    <literal>__dict__</literal> için de mevcuttur.
   </para>
  </sect1>
  <sect1 xml:id="python-tutorial_son1">
   <title>Sona Kalanlar</title>
   <para>
    Bazan isimli veri öğelerini bir arada paketlemek, Pascal kayıtları ya da
    C veri yapılarına benzer bir veri türü oluşturmak kullanışlı olabilir.
    Bir boş sınıf ile bu yapılabilir:
   </para>
   <screen>
class Eleman:
    pass

ali = Eleman() # Boş bir eleman kaydı yarat

# Kaydın alanlarını doldur
ali.isim = 'Ali Veli'
ali.bolum = 'Muhasebe'
ali.maas = 1000000
</screen>
   <para>
    Soyut bir veri türü bekleyen Python koduna o veri türünün yöntemlerini
    taklit eden bir sınıf geçirilebilir. Örneğin bir dosya nesnesinden bir
    miktar veriyi biçimleyen bir işleviniz varsa, <literal>read()</literal>
    ve <literal>readline()</literal> yöntemleri olan ve veriyi bir dizgeden
    alan bir sınıfı o işleve bağımsız değişken olarak aktarabilirsiniz.
   </para>
   <para>
    Yöntem nesnelerinin de öznitelikleri vardır: <literal>m.im_self</literal>
    kendinin tanımlı olduğu nesneyi çağıran bir yöntem nesnesidir ve
    <literal>m.im_func</literal> ise kendini oluşturan işlevi çağıran bir
    yöntem nesnesidir.
   </para>
  </sect1>
  <sect1 xml:id="python-tutorial_son2">
   <title>İstisnalar Sınıf Olabilir</title>
   <para>
    Kullanıcı tanımlı istisnalar artık dizge olmakla sınırlı değiller;
    sınıf da olabilir. Bu mekanizmayı kullanarak genişletilebilir istisna
    hiyerarşileri yaratılabilir.
   </para>
   <para>
    <literal>raise</literal> deyimi için iki yeni biçem mevcut:
   </para>
   <screen>
raise Sinif, gercekleme

raise gercekleme
</screen>
   <para>
    İlk biçemde <literal>gercekleme Sinif</literal>a ait bir gerçekleme
    olmalıdır. İkinci biçem ise şunun kısaltmasıdır:
   </para>
   <screen>
raise gercekleme.__class__, gercekleme
</screen>
   <para>
    Bir <literal>except</literal> bloğu hem sınıflar hem de dizgeleri
    içerebilir. Bir <literal>except</literal> bloğu içindeki sınıf eğer aynı
    sınıf veya bir temel sınıf ise istisna ile uyumludur. Türetilmiş sınıf
    içeren bir <literal>except</literal> bloğu temel sınıf ile uyumlu
    değildir. Örneğin aşağıdaki yazılım <literal>B</literal>,
    <literal>C</literal>, <literal>D</literal> çıktısını o sırayla verir:
   </para>
   <screen>
class B:
    pass
class C(B):
    pass
class D(C):
    pass
for c in [B, C, D]:
    try:
        raise c()
    except D:
        print "D"
    except C:
        print "C"
    except B:
        print "B"
</screen>
   <para>
    Eğer <literal>except</literal> blokları ters sırayla yazılmış olsalardı
    (<literal>except B </literal> başta olacak şekilde) çıktı
    <literal>B, B, B</literal> olacaktı; çünkü uyan ilk
    <literal>except B </literal> bloğu tetiklenecekti.
   </para>
   <para>
    Ele alınmamış sınıf istisnası için bir ileti yazılacağı zaman, önce sınıf
    adı yazılır, ardından iki nokta üst üste ve bir boşluk ve son olarak da
    gerçeklemenin yerleşik <literal>str()</literal> işlevinden geri
    döndürülen dizgenin karşılığı yazılır.
   </para>
  </sect1>
 </chapter>
 <chapter xml:id="python-tutorial_son">
  <?dbhtml stop-chunking?>
  <title>Ya bundan sonra?</title>
  <para>
   Bu kılavuzu okumak muhtemelen Python kullanmaya olan ilginizi artırmıştır.
   Peki şimdi ne yapmalısınız?
 </para>
  <para>
   Standart Python dağıtımı çok zengin bir modül kitaplığı ile gelmektedir.
   Python yazılımları yazarken zamandan büyük tasarruf sağlayacak modüllerin
   nasıl kullanıldığını öğrenmek için bunlar ile ilgili belgelere başvurun.
  </para>
  <para>
   Resmi Python sanalyöresi <link xlink:href="http://www.python.org/"/>
   olup; yazılımlar, belgeler ve internetteki Python ile ilgili diğer
   sanalyörelere bağlantılar içerir.
 </para>
  <para>
   Python ile ilgili sorular ve hata raporları için
   <email>python-list@python.org</email> e-posta listesini kullanabilirsiniz.
   Eposta atmadan önce <link
   xlink:href="https://docs.python.org/3/faq/index.html#faq-index"/>
   adresindeki SSS listesine bakmayı ihmal etmeyin.  E-posta listesi
   arşivleri ise <link xlink:href="https://mail.python.org/pipermail/"/>
   adresinde bulunabilir.
  </para>
 </chapter>
</book>
