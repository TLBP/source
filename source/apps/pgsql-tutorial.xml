<?xml version="1.0" encoding="UTF-8"?>
<!-- ********************************************************************
         pgsql-tutorial.xml
     ******************************************************************** -->
<part xml:id="pgsql-tutorial" xmlns="http://docbook.org/ns/docbook"
      xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:lang="tr"
      userlevel="longtoc">
 <?dbhtml dir="../uygulamalar/pgsql"?>
 <info>
  <authorgroup>
   <author role="translator">
    <personname>
     <firstname>Nilgün Belma Bugüner</firstname>
    </personname>
   </author>
   <author role="translator">
    <personname>
     <firstname>Volkan "knt" Yazıcı</firstname>
    </personname>
   </author>
  </authorgroup>
  <pubdate>Mart 2005</pubdate>
  <!-- Most recent revision goes at the top; list in descending order -->
  <revhistory>
   <revision>
    <revnumber>8.0.1</revnumber>
    <date>Mart 2005</date>
    <authorinitials>NBB</authorinitials>
    <revremark>
PostgreSQL 8.0.1 ile gelen belgelerden güncelleme yapıldı.
          </revremark>
   </revision>
   <revision>
    <revnumber>7.3.2</revnumber>
    <date>Temmuz 2003</date>
    <authorinitials>knt</authorinitials>
    <revremark>
PostgreSQL 7.3.2 ile gelen belgelerden çevrildi.
          </revremark>
   </revision>
  </revhistory>
  <copyright>
   <year>2005</year>
   <holder>Nilgün Belma Bugüner</holder>
  </copyright>
  <sbr/>
  <copyright>
   <year>2003</year>
   <holder>Volkan Yazıcı</holder>
  </copyright>
  <legalnotice>
   <para>
Bu çeviriyi, çevirisinin yapıldığı özgün belgeye ilişkin aşağıdaki yasal uyarı, çeviriye ait yukarıdaki telif hakkı bilgileri ve aşağıdaki iki paragrafı tüm kopyalarının başlangıcında içermesi şartıyla, ücretsiz olarak kullanabilir, kopyalayabilir, değiştirebilir ve dağıtabilirsiniz.
 </para>
   <para>
BU BELGE "ÜCRETSİZ" OLARAK RUHSATLANDIĞI İÇİN, İÇERDİĞİ BİLGİLER İÇİN İLGİLİ KANUNLARIN
İZİN VERDİĞİ ÖLÇÜDE HERHANGİ BİR GARANTİ VERİLMEMEKTEDİR. AKSİ YAZILI OLARAK BELİRTİLMEDİĞİ
MÜDDETÇE TELİF HAKKI SAHİPLERİ VE/VEYA BAŞKA ŞAHISLAR BELGEYİ "OLDUĞU GİBİ", AŞİKAR VEYA
ZIMNEN, SATILABİLİRLİĞİ VEYA HERHANGİ BİR AMACA UYGUNLUĞU DA DAHİL OLMAK ÜZERE HİÇBİR
GARANTİ VERMEKSİZİN DAĞITMAKTADIRLAR. BİLGİNİN KALİTESİ İLE İLGİLİ TÜM SORUNLAR SİZE AİTTİR.
HERHANGİ BİR HATALI BİLGİDEN DOLAYI DOĞABİLECEK OLAN BÜTÜN SERVİS, TAMİR VEYA DÜZELTME
MASRAFLARI SİZE AİTTİR.
    </para>
   <para>
İLGİLİ KANUNUN İCBAR ETTİĞİ DURUMLAR VEYA YAZILI ANLAŞMA HARİCİNDE HERHANGİ BİR ŞEKİLDE
TELİF HAKKI SAHİBİ VEYA YUKARIDA İZİN VERİLDİĞİ ŞEKİLDE BELGEYİ DEĞİŞTİREN VEYA YENİDEN
DAĞITAN HERHANGİ BİR KİŞİ, BİLGİNİN KULLANIMI VEYA KULLANILAMAMASI (VEYA VERİ KAYBI OLUŞMASI,
VERİNİN YANLIŞ HALE GELMESİ, SİZİN VEYA ÜÇÜNCÜ ŞAHISLARIN ZARARA UĞRAMASI VEYA BİLGİLERİN
BAŞKA BİLGİLERLE UYUMSUZ OLMASI) YÜZÜNDEN OLUŞAN GENEL, ÖZEL, DOĞRUDAN YA DA DOLAYLI HERHANGİ
BİR ZARARDAN, BÖYLE BİR TAZMİNAT TALEBİ TELİF HAKKI SAHİBİ VEYA İLGİLİ KİŞİYE BİLDİRİLMİŞ
OLSA DAHİ, SORUMLU DEĞİLDİR.
    </para>
   <para>
Tüm telif hakları aksi özellikle belirtilmediği sürece sahibine aittir. Belge içinde geçen herhangi bir terim, bir ticari isim ya da kuruma itibar kazandırma olarak algılanmamalıdır. Bir ürün ya da markanın kullanılmış olması ona onay verildiği anlamında görülmemelidir.
</para>
  </legalnotice>
  <copyright>
   <year>1996-2005</year>
   <holder>The PostgreSQL Global Development Group</holder>
  </copyright>
  <legalnotice xml:id="pgsql-legalnotice">
   <para><productname>PostgreSQL</productname> is Copyright © 1996-2005
  by the PostgreSQL Global Development Group and is distributed under
  the terms of the license of the University of California below.
 </para>
   <para><productname>Postgres95</productname> is Copyright © 1994-5
  by the Regents of the University of California.
 </para>
   <para>
  Permission to use, copy, modify, and distribute this software and
  its documentation for any purpose, without fee, and without a
  written agreement is hereby granted, provided that the above
  copyright notice and this paragraph and the following two paragraphs
  appear in all copies.
 </para>
   <para>
  IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY
  PARTY FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
  DAMAGES, INCLUDING LOST PROFITS, ARISING OUT OF THE USE OF THIS
  SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE UNIVERSITY OF CALIFORNIA
  HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 </para>
   <para>
  THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE
  PROVIDED HEREUNDER IS ON AN <quote>AS-IS</quote> BASIS, AND THE UNIVERSITY OF
  CALIFORNIA HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE, SUPPORT,
  UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 </para>
  </legalnotice>
 </info>
 <chapter xml:id="pgsql-tutorial-intro">
  <info>
   <title>Giriş</title>
  </info>
  <para><productname>PostgreSQL</productname> Eğitmenine hoşgeldiniz. Sonraki kısımlarda PostgreSQL'e, ilişkisel veritabanı kavramlarına ve SQL dilinin kavramlarına yabancı olanlar için SQL diline basit bir giriş yapılacaktır.  Sadece nasıl bilgisayar kullanılacağı üzerine bilginizin olduğu varsayılacaktır. Belli bir Unix veya yazılım geliştirme deneyimi gerekmiyor. Bu belge size genel hatlarıyla <productname>PostgreSQL</productname> üzerinde denetim kurabileceğiniz kadar deneyim kazandırmayı amaçlamaktadır. Konuları ve kapsamı itibariyle kesinlikle tam bir rehber görevi görmeyecektir.
   </para>
  <para>
Bu belgeyi bitirdikten sonra SQL dili üzerine daha ayrıntılı bilgi için <productname>PostgreSQL</productname> 8.0 belgelerindeki <link xlink:href="http://www.postgresql.org/docs/8.0/static/sql.html">SQL Dili</link> oylumuna ya da <productname>PostgreSQL</productname> üzerine geliştireceğiniz uygulamalarda daha geniş bilgi için <productname>PostgreSQL</productname> 8.0 belgelerindeki <link xlink:href="http://www.postgresql.org/docs/8.0/static/client-interfaces.html">İstemci Arayüzleri</link> oylumuna bakabilirsiniz. Kendi sunucularını kurup üzerinde yönetimi gerçekleştirecek kişiler ayrıca <productname>PostgreSQL</productname> 8.0 belgelerindeki <link xlink:href="http://www.postgresql.org/docs/8.0/static/admin.html">Sistem Yönetimi</link> oylumuna başvurabilirler.
   </para>
 </chapter>
 <chapter xml:id="pgsql-tutorial-start">
  <info>
   <title>Başlangıç</title>
  </info>
  <bridgehead renderas="sect1">Kurulum</bridgehead>
  <para><productname>PostgreSQL</productname> kullanmadan önce kurulumu gerçekleştirmeniz gerekmekte. <productname>PostgreSQL</productname>, işletim sisteminizin önkurulumu esnasında yüklenmiş olabileceği gibi, sistem yöneticisi tarafından da önceden kurulmuş olabilir. Böyle bir durumda dağıtımınızın belgelerinden ya da sistem yöneticinizden PostgreSQL'e nasıl ulaşabileceğinize dair bilgileri edinebilirsiniz.
   </para>
  <para>
PostgreSQL'in kurulu olduğu ya da onu kullanabileceğiniz konusunda emin değilseniz, PostgreSQL'i kendiniz kurabilirsiniz. Kurulum işlemi zor olmamakla birlikte sizin için de iyi bir alıştırma niteliği taşır. <productname>PostgreSQL</productname> her kullanıcı tarafından kurulabilir; ayrıcalıklı kullanıcı (<systemitem>root</systemitem>) hakları gerekmemektedir.
   </para>
  <para>
Eğer PostgreSQL'i kendiniz kuracaksanız bu konuda PostgreSQL 8.0 kitabının <link xlink:href="http://www.postgresql.org/docs/8.0/static/installation.html">Sunucu Yönetimi</link> oylumunda yer alan kurulum bölümüne bakıp, kurulum tamamlandığında buraya dönebilirsiniz. Ortam değişkenlerinin belirlenmesinin anlatıldığı bölüme bakmayı unutmayın.
   </para>
  <para>
Eğer sistem yöneticiniz kurulum işlemlerini öntanımlı yoldan yapmadıysa biraz daha yapacak işiniz var demektir. Örneğin eğer sunucu makineniz uzakta bir sistem ise, <envar>PGHOST</envar> ortam değişkenine veritabanı sunucusunun ismini atamalısınız. Ayrıca, <envar>PGPORT</envar> ortam değişkenine de atama yapmanız gerekebilir. Son olarak, eğer çalıştırmayı denediğiniz bir uygulama veritabanına bağlanamadığını belirten bir hata iletisi veriyorsa; sistem yöneticiniz ile bağlantı kurmayı deneyin, eğer yönetici siz iseniz, belgeleri tekrar gözden geçirip çalışma ortamını doğru ayarlayıp ayarlamadığınıza bir kez daha bakın. Eğer bir önceki paragrafı anlamadıysanız, bir sonraki bölümü okuyun.
   </para>
  <section xml:id="pgsql-tutorial-arch">
   <info>
    <title>Mimarinin Temelleri</title>
   </info>
   <para>
Daha ileri bölümleri okumadan önce, PostgreSQL'in temel sistem mimarisini anlamanızda yarar var. <productname>PostgreSQL</productname> bölümlerinin birbirleri ile nasıl ilişki içinde olduğunu anlamanız yönünde bu kısım bir derece de olsa yararlı olacaktır.
   </para>
   <para><productname>PostgreSQL</productname>, veritabanı dilinde sunucu/istemci temeline dayanan bir sistem kullanmaktadır. Bir <productname>PostgreSQL</productname> oturumu birbirleriyle ilişkili çalışan şu süreçlerden oluşur:
   </para>
   <itemizedlist>
    <listitem>
     <para>
Veritabanı dosyalarını yöneten bir sunucu süreci istemci uygulamalarından gelen bağlantıları kabul eder ve istenilen işlemleri onlar adına gerçekleştirir. Veritabanı sunucu uygulamasının ismi <userinput>postmaster</userinput>'dır.
      </para>
    </listitem>
    <listitem>
     <para>
Kullanıcının istemci uygulaması veritabanında sorgulamanın gerçekleşmesini isteyen uygulamadır. İstemci uygulamaları çok çeşitlidir: salt metin (text) tabanlı bir istemci aracı, grafiksel arayüzlü bir uygulama, veritabanına bağlanıp ilgili HTML sayfaları olarak göstercek bir web sunucusu veya özelleşmiş bir veritabanı onarım aracı. Bazı istemci uygulamaları <productname>PostgreSQL</productname> dağıtımları ile sağlanmakta olup çoğu da kullanıcılar tarafından geliştirilmektedir.
      </para>
    </listitem>
   </itemizedlist>
   <para>
Genellikle, sunucu/istemci uygulamalarında, sunucu ve istemci ayrı makinelerde olurlar. Böyle bir durumda birbileri ile TCP/IP ağ bağlantısı üzerinden haberleşirler. Bir istemci makinenin erişebildiği dosyaların veritabanı sunucusu olan makine üzerinde erişilebilir olamayabileceğini (ya da farklı bir dosya ismi ile erişilebilineceğini) aklınızdan çıkarmayın.
   </para>
   <para>
PostgreSQL sunucusu çoklu istemci bağlantılarına izin verebilmektedir. Bu amaçla her yeni bağlantı için yeni bir süreç başlatır (<quote>fork</quote>). Bu noktada, istemci ve yeni sunucu süreci özgün <userinput>postmaster</userinput> süreciyle etkileşime girmeden haberleşebilirler. Bu arada, <userinput>postmaster</userinput> istemci bağlantılarını bekler, istemcileri ilgili sunucu süreci ile ilişkilendirmeye çalışır. (Tabii ki, bunların hepsi kullanıcıdan habersiz olarak artalanda gerçekleşir. İşlemin nasıl gerçekleştiğini bilin istedik.)
   </para>
  </section>
  <section xml:id="pgsql-tutorial-createdb">
   <info>
    <title>Bir Veritabanının Oluşturulması</title>
   </info>
   <para>
Veritabanına sunucusuna erişiminiz olup olmadığını görmek için yapılacak ilk sınama bir veritabanı oluşturmaya çalışmaktır. Çalışan bir <productname>PostgreSQL</productname> sunucusu çok sayıda veritabanını yönetebilir. Genellikle, her proje ya da her kullanıcı için ayrı bir veritabanı kullanılır.
   </para>
   <para>
Muhtemelen, sistem yöneticiniz sizin için bir veritabanını zaten oluşturmuştur ve size oluşturduğu veritabanı ismini de söylemiştir. Böyle bir durumda bu adımı geçerek bir sonraki bölüme bakabilirsiniz.
   </para>
   <para>
Bu örnekte, yeni bir veritabanını <literal>mydb</literal> ismiyle şöyle oluşturabilirsiniz:
   </para>
   <para>
    <screen>
     <prompt>$</prompt>
     <userinput>createdb mydb</userinput>
    </screen>
   </para>
   <para>
Çıktısının şöyle olması lazım:
   </para>
   <para>
    <screen>CREATE DATABASE</screen>
   </para>
   <para>
Bu çıktıyı alıyorsanız, bu adım tamamlanmış demektir.
   </para>
   <para>
Ama, <userinput>createdb</userinput> komutunun bulunamadığına ilişkin, şöyle bir çıktı alıyorsanız,
   </para>
   <para>
    <screen>createdb: command not found</screen>
   </para>
   <para><productname>PostgreSQL</productname> olması gerektiği gibi kurulmamış demektir. Ya hiç kurulum yapılmamıştır ya da dosya arama yolları (<envar>$PATH</envar>) doğru yapılandırılmamıştır. Komutu dosya yolunu belirterek kullanmayı deneyin:
   </para>
   <para>
    <screen>
     <prompt>$</prompt>
     <userinput>/usr/local/pgsql/bin/createdb mydb</userinput>
    </screen>
   </para>
   <para>
Bu dosya yolu sisteminizde farklı olabilir. Böyle bir durumda sistem yöneticisi ile bağlantı kurmayı deneyin ya da kurulum adımlarını tekrar gözden geçirip sorunu tespit etmeye çalışın.
   </para>
   <para>
Çıktı şöyle de olabilirdi:
   </para>
   <para>
    <screen>createdb: could not connect to database template1: could not connect to server:
No such file or directory
        Is the server running locally and accepting
        connections on Unix domain socket "/tmp/.s.PGSQL.5432"?
</screen>
   </para>
   <para>
Böyle bir hatanın anlamı ya sunucu başlatılmamıştır ya da <userinput>createdb</userinput> sunucunun aradığı yerde değildir. Kurulum adımlarını yeniden gözden geçirin ya da sistem yöneticisi ile temasa geçin.
   </para>
   <para>
Yanıt şöyle de olabilirdi:
<screen>
createdb: could not connect to database template1: FATAL:  user "nilgun" does not
exist
</screen>
   </para>
   <para>
Burada "nilgun" yerine sizin kullanıcı isminiz görünecektir. Bu, sistem yöneticinizin sizin için bir  <productname>PostgreSQL</productname> kullanıcısı hesabı açmadığı anlamına gelir. (<productname>PostgreSQL</productname> kullanıcı hesapları, sistem kullanıcı hesaplarından ayrıdır.) Eğer sistem yöneticisi sizseniz, hesapların oluşturulması ile ilgili bilgi edinmek için PostgreSQL 8.0 belgelerindeki <link xlink:href="http://www.postgresql.org/docs/8.0/static/user-manag.html">Veritabanı Kullanıcıları ve Grupları</link> kısmına bakın. İlk kullanıcı hesabını oluşturmak için PostgreSQL'i kuran işletim sistemi kullanıcısı (genellikle bu kullanıcı <literal>postgres</literal>'dir) olmanız gerekecektir. İsterseniz, bu amaçla, bir sistem kullanıcı isminden farklı bir <productname>PostgreSQL</productname> kullanıcı ismini de kullanabilirsiniz; <productname>PostgreSQL</productname> kullanıcı isminini belirtmek için ya  <option>-U</option> seçeneğini kullanmalı ya da bu ismi <envar>PGUSER</envar> ortam değişkenine atamalısınız.
   </para>
   <para>
Eğer bir kullanıcı hesabınız varsa, ama bir veritabanı oluşturma izniniz yoksa, şöyle bir çıktı alacaksınız:
   </para>
   <para>
    <screen>
createdb: database creation failed: ERROR:  permission denied to create database
</screen>
   </para>
   <para>
Her kullanıcının yeni bir veritabanı oluşturma yetkisi yoktur.  Eğer <productname>PostgreSQL</productname> sizin veritabanı oluşturma isteğinizi geri çeviriyorsa, sistem yöneticisinin size gerekli izinleri vermesi gerekmektedir. Böyle bir durumda sistem yöneticisi ile temasa geçin. Eğer sistem yöneticisi siz iseniz böyle bir izin işlemi için sunucuyu hangi kullanıcı ile başlatmışsanız onun ile sisteme giriş yapın ve bu eğiticiyi okuyup uygulamak isteyenlere gerekli hakları tanıyın.<footnote><para>
Bunun neden böyle çalıştığına dair açıklama: <productname>PostgreSQL</productname> kullanıcı isimleri sistem kullanıcı isimlerinden bağımsızdır. Eğer bir veritabanına bağlanıyorsanız, hangi <productname>PostgreSQL</productname> kullanıcı adı ile bağlanacağınızı belirtebilirsiniz; bunu yapmazsanız, sistem kullanıcısı isminiz öntanımlı <productname>PostgreSQL</productname> kullanıcı isminiz olarak kullanacaktır. Böyle bir durumda veritabanı sunucusunu başlatan kullanıcı ile aynı isme sahip bir <productname>PostgreSQL</productname> kullanıcısı olacaktır ve böyle bir durumda bu kullanıcı her zaman veritabanı oluşturma izinlerine sahip olacaktır. Her seferinde o kullanıcı ile sisteme girmektense <option>-U</option> seçeneği ile PostgreSQL'e bağlanmak istediğiniz kullanıcı adını belirtebilirsiniz.</para></footnote>
   </para>
   <para>
İsterseniz başka isimler ile de veritabanları oluşturabilirsiniz. <productname>PostgreSQL</productname> istediğiniz sayıda veritabanı oluşturma imkanını sunmaktadır. Veritabanı isminin ilk karakteri bir harf olmalı ve isim 63 karakterden daha uzun olmamalıdır. Tercihen kullanıcı adınız ile aynı ismi taşıyan veritabanları oluşturulması tavsiye olunur. Çoğu araç, böyle bir veritabanı ismini öntanımlı olarak kabul eder ve bu sizi az da olsa yazmaktan kurtarır. Yeni bir veritabanı oluşturmak için, basitçe şunu yazın:
   </para>
   <para>
    <screen>
     <prompt>$</prompt>
     <userinput>createdb</userinput>
    </screen>
   </para>
   <para>
Eğer veritabanınızı artık kullanmak istemiyorsanız onu kaldırabilirsiniz. Örnek olarak, eğer siz <literal>mydb</literal> adlı veritabanının sahibi iseniz, bunu şöyle silebilirsiniz:
   </para>
   <para>
    <screen>
     <prompt>$</prompt>
     <userinput>dropdb mydb</userinput>
    </screen>
   </para>
   <para>
(Bu komut için, veritabanı ismi öntanımlı olarak kullanıcı ismi değildir. Daima bu ismi belirtmeniz gerekir.) Bu işlem sonucunda fiziksel olarak veritabanınız ile ilgili bütün dosyalar silinecektir ve veritabanınızı geri alamayacaksınız. Bu yüzden bu komutu uygulamadan önce kararınızı tekrar gözden geçirmeniz tavsiye olunur.
   </para>
   <para><userinput>createdb</userinput> ve <userinput>dropdb</userinput> hakkında daha fazla bilgi edinmek için PostgreSQL 8.0 belgelerindeki <link xlink:href="http://www.postgresql.org/docs/8.0/static/app-createdb.html">createdb</link> ve <link xlink:href="http://www.postgresql.org/docs/8.0/static/app-dropdb.html">dropdb</link> komutlarının açıklamalarına bakınız.
   </para>
  </section>
  <section xml:id="pgsql-tutorial-accessdb">
   <info>
    <title>Bir Veritabanına Erişim</title>
   </info>
   <para>
Veritabanını oluşturduktan sonra, ona şöyle erişebilirsiniz:
   </para>
   <itemizedlist>
    <listitem>
     <para><userinput>psql</userinput> adlı etkileşimli <productname>PostgreSQL</productname> uçbirim uygulaması ile veritabanına giriş yapıp, istediğiniz işlemleri gerçekleştirir ve SQL komutlarınızı çalıştırabilirsiniz.
      </para>
    </listitem>
    <listitem>
     <para><application>PgAccess</application> gibi çizgesel arayüzlü bir uygulama ya da ODBC destekli ofis yazılımlarını kullanarak veritabanı oluşturabilir ve üzerinde işlem yapabilirsiniz. Bu tür uygulamalar ve kullanımları bu eğitmenin kapsamı dışındadır.
      </para>
    </listitem>
    <listitem>
     <para>
Uygun yazılım geliştirme dilleri ile kendi uygulamalarınızı da yazabilirsiniz. Bu konu hakkında ayrıntılı bilgiyi <productname>PostgreSQL</productname> 8.0 belgelerindeki <link xlink:href="http://www.postgresql.org/docs/8.0/static/client-interfaces.html">İstemci Arayüzleri</link> oylumunda bulabilirsiniz.
      </para>
    </listitem>
   </itemizedlist>
   <para>
Bu belgedeki alıştırmaları denemek için muhtemelen <userinput>psql</userinput>'i kullanmak isteyeceksiniz. <userinput>psql</userinput>'i <literal>mydb</literal> adlı veritabanına erişmek için şu şekilde başlatabilirsiniz:
    </para>
   <para>
    <screen>
     <prompt>$</prompt>
     <userinput>psql mydb</userinput>
    </screen>
   </para>
   <para>
Eğer bir veritabanı ismi belirtmezseniz öntanımlı olarak kullanıcı adınız ile aynı ismi taşıyan  veritabanına erişilmeye çalışılacaktır. Bu konudan önceki bölümde bahsetmiştik.
   </para>
   <para><userinput>psql</userinput> sizi aşağıdaki gibi bir çıktı ile karşılayacaktır:
   </para>
   <para>
    <screen>
Welcome to psql 8.0.1, the PostgreSQL interactive terminal.

Type:  \copyright for distribution terms
       \h for help with SQL commands
       \? for help with psql commands
       \g or terminate with semicolon to execute query
       \q to quit

mydb=&gt;
</screen>
   </para>
   <para>
Son satır şu şekilde de olabilir:
   </para>
   <para>
    <screen>mydb=#</screen>
   </para>
   <para>
Bunun anlamı, çoğunlukla olduğu gibi eğer PostgreSQL'i kendiniz kurduysanız, veritabanının en yetkili kullanıcısı olduğunuz anlamına gelir. En yetkili kullanıcı olmak, hiçbir izin işlemine tabi tutulmayacağınız anlamına gelir. Fakat bu konu bu eğitmenin kapsamında değildir.
   </para>
   <para>
Eğer <userinput>psql</userinput>'i çalıştırmakta sorun yaşarsanız önceki bölüme dönün.  <userinput>psql</userinput> ile  <userinput>createdb</userinput> arasında çalıştırma sorunlarına tanı konulması bakımından fark yoktur. Eğer <userinput>createdb</userinput> çalışıyorsa, <userinput>psql</userinput>'in de çalışması gerekir.
   </para>
   <para>
Son satırda yer alan <literal>mydb=&gt;</literal> komut satırı <userinput>psql</userinput>'in kendi çalışma alanı içine <acronym>SQL</acronym> sorguları yazmanızı beklediği anlamına gelir. Şu komutları deneyiniz:
   </para>
   <para>
    <screen><prompt>mydb=&gt;</prompt><userinput>SELECT version();</userinput>
                            version
----------------------------------------------------------------
 PostgreSQL 8.0.1 on i586-pc-linux-gnu, compiled by GCC 2.96
(1 row)

<prompt>mydb=&gt;</prompt> <userinput>SELECT current_date;</userinput>
    date
------------
 2002-08-31
(1 row)

<prompt>mydb=&gt;</prompt> <userinput>SELECT 2 + 2;</userinput>
 ?column?
----------
        4
(1 row)
</screen>
   </para>
   <para>
Bunun dışında <userinput>psql</userinput> kendine ait, standart <acronym>SQL</acronym> komutu olmayan, bir kaç dahili komuta daha sahiptir. Bu tür komutlar bir tersbölü karakteri (<userinput>\</userinput>) ile başlar. Bu komutların birkaçı karşılama ekranında listelenmişti. Örnek olarak, çeşitli <productname>PostgreSQL</productname> <acronym>SQL</acronym> komutları hakkında yardım almak için şunu yazabilirsiniz:
   </para>
   <para>
    <screen>
     <prompt>mydb=&gt;</prompt>
     <userinput>\h</userinput>
    </screen>
   </para>
   <para><userinput>psql</userinput>'den çıkmak için şunu kullanabilirsiniz:
   </para>
   <para>
    <screen>
     <prompt>mydb=&gt;</prompt>
     <userinput>\q</userinput>
    </screen>
   </para>
   <para>
Böylece <userinput>psql</userinput>'den çıkıp sistemin komut satırına geri döneceksiniz. (Daha fazla dahili komut için psql satırında <userinput>\?</userinput> komutunu kullanabilirsiniz.) <userinput>psql</userinput>'in tam olarak ne yapabildiği hakkında ayrıntılı bilgiyi <productname>PostgreSQL</productname> 8.0 belgelerindeki <link xlink:href="http://www.postgresql.org/docs/8.0/static/app-psql.html">psql komut açıklamasında</link> bulabilirsiniz. Eğer PostgreSQL kurulumunu tam olarak gerçekleştirdiyseniz sistemin komut satırında <userinput>man psql</userinput> yazarak da bu bilgilere ulaşabilirsiniz. Bu eğitmende bu özelliklerin hepsine değinmeyeceğiz ama kendiniz hepsini deneyebilirsiniz.
   </para>
  </section>
 </chapter>
 <chapter xml:id="pgsql-tutorial-sql">
  <info>
   <title><acronym>SQL</acronym> Dili</title>
  </info>
  <para>
Bu kısımda basit işlemleri uygulamak için <acronym>SQL</acronym> kullanımına kısaca değineceğiz. Verilecek <acronym>SQL</acronym> bilgisi bir başlangıç niteliği taşımaktadır, kesinlikle tam bir <acronym>SQL</acronym> eğitmeni değildir. <acronym>SQL</acronym> dili üzerine sayısız kitap yazılmıştır, bunlar içinde <link xlink:href="http://www.postgresql.org/docs/8.0/static/biblio.html#MELT93">Yeni SQL Dilinin Anlaşılması</link> ve <link xlink:href="http://www.postgresql.org/docs/8.0/static/biblio.html#DATE97">SQL Standartları Kılavuzu</link>'nu örnek gösterebiliriz. Bazı PostgreSQL dil özelliklerinin standarttan fazlasını içerdiğini bilmenizde yarar var.
   </para>
  <para>
Bu kısımdaki örneklerde, önceki bölümde <userinput>psql</userinput>'i başlatırken kullandığınız, <literal>mydb</literal> isimli veritabanının oluşturmuş olduğunuz varsayılmıştır.
   </para>
  <para>
Bu belgedeki örnekleri ayrıca PostgreSQL kaynak paketinde yer alan <filename>src/tutorial/</filename> dizininde de bulabilirsiniz. Bu dosyaları kullanmaya başlamadan önce dizine girip <userinput>make</userinput> komutunu vermelisiniz:
   </para>
  <para>
   <screen>
    <prompt>$</prompt>
    <userinput>cd </userinput>
    <replaceable>....</replaceable>
    <userinput>/src/tutorial</userinput>
    <prompt>$</prompt>
    <userinput>make</userinput>
   </screen>
  </para>
  <para>
Böylece, kullanıcı tanımlı işlevlerle türleri içeren C dosyaları derlenmiş ve betikler oluşturulmuş olur. (Bu işlem için GNU <userinput>make</userinput> kullanılmalıdır. Sisteminizdeki ismi farklı, belki de <userinput>gmake</userinput> olabilir.) Eğitmeni şöyle başlatabilirsiniz:
   </para>
  <para>
   <screen>
    <prompt>$</prompt>
    <userinput>cd </userinput>
    <replaceable>....</replaceable>
    <userinput>/src/tutorial</userinput>
    <prompt>$</prompt>
    <userinput>psql -s mydb</userinput>
    <computeroutput>
...
</computeroutput>
    <prompt>mydb=&gt;</prompt>
    <userinput>\i basics.sql</userinput>
   </screen>
  </para>
  <para>
Buradaki <userinput>\i</userinput> komutu, komutları belirtilen dosyadan okur. <literal>-s</literal> seçeneği sizi, her komutu sunucuya göndermeden önce bekleyen tek adımlık kipe sokar. Bu bölümde kullanılmış olan komutları <filename>basics.sql</filename> dosyasında bulabilirsiniz.
   </para>
  <section xml:id="pgsql-tutorial-concepts">
   <info>
    <title>Kavramlar</title>
   </info>
   <para><productname>PostgreSQL</productname> bir ilişkisel veritabanı yönetim sistemidir (RDBMS - Relational Database Management System). Bunun anlamı, PostgreSQL'in ilişkilerin içerdiği verileri yöneten bir sistem olduğudur. Burada bahsedilen <wordasword>ilişki</wordasword> (relation) aslında <wordasword>tablo</wordasword> karşılığı bir matematik terimidir. Verinin tablolarda saklanması olayı günümüzde gayet olağan gibi görünürse de veritabanlarının organize edilmesi için daha pek çok yol vardır. Unix türevi işletim sistemlerindeki dosya/dizin yapısı hiyerarşik veritabanlarına güzel bir örnektir. Günümüzde daha gelişmiş bir veritabanı türü de nesne yönelimli veritabanlarıdır.
   </para>
   <para>
Her tablo satırlardan oluşur. Ve her <wordasword>satır</wordasword> kendi içinde, belli veri türlerine özel <wordasword>sütun</wordasword>lara ayrılmıştır. Sütunlar her satırda aynı sayıda ve sırada olmasına karşın, SQL aynı şeyi satır sıralaması için garanti etmez (yine de çıktı alırken isteğe bağlı olarak sıralandırılabilirler).
   </para>
   <para>
Tablolar veritabanları halinde gruplanır ve tek bir <productname>PostgreSQL</productname> sunucu süreci tarafından yönetilen veritabanları bir veritabanı <wordasword>küme</wordasword>si oluştururlar.
   </para>
  </section>
  <section xml:id="pgsql-tutorial-table">
   <info>
    <title>Yeni bir Tablonun Oluşturulması</title>
   </info>
   <para>
Yeni bir tabloyu, tablo ismini ve içerdiği sütün isimlerini veri türleri ile birlikte belirterek oluşturabilirsiniz:
   </para>
   <para>
    <programlisting>
CREATE TABLE weather (
    city           varchar(80),
    tmp_lo         int,           -- en düşük sıcaklık
    tmp_hi         int,           -- en yüksek sıcaklık
    prcp           real,          -- yağış miktarı
    date           date
);
</programlisting>
   </para>
   <para>
Bu komut listesini <userinput>psql</userinput> komut satırına aynen buradaki gibi girebilirsiniz (alt satıra geçmek için &lt;enter&gt;'a basmanız yeterli olacaktır). <userinput>psql</userinput> en sonda yer alan noktalı virgülü görene kadar komutun bitmediğini anlayacaktır.
   </para>
   <para>
SQL komutları içinde boşluklar (boşluk karakteri, sekme ve satırsonu karakteri) özgürce kullanılabilir. Yani, yukarıdaki komut listesini siz istediğiniz gibi yazabilirsiniz; hatta hepsini tek bir satıra dahi girebilirsiniz. Yanyana gelen iki tire ("<literal>--</literal>") açıklama satırları için kullanılır. Bu işaretten sonra yazılan her şey o satırın sonuna kadar ihmal edilecektir. SQL komutlarının normalde büyük-küçük harf duyarlılığı yoktur. Duruma bağlı olarak değişkenlerin çift tırnak içine alınması onların büyük-küçük harf duyarlı olduğunu gösterir (Yukarıda bu yöntem kullanılmamıştır).
   </para>
   <para><literal>varchar(80)</literal> 80 karakter uzunluğundaki bir dizgeyi tutabilecek bir veri türü belirtir. <literal>int</literal> normal bir tamsayıyı niteler. <literal>real</literal> tek hassasiyetli (single precision) gerçel sayılar için kullanılır. <literal>date</literal> alanı da adından anlaşılacağı üzere tarih saklamak için kullanılır.
   </para>
   <para><productname>PostgreSQL</productname> standart <acronym>SQL</acronym> veri türlerinden <literal>int, smallint, real, double, char(<replaceable>N</replaceable>), varchar(<replaceable>N</replaceable>), date, time, timestamp</literal> ve  <literal>interval</literal> ile birlikte diğer genel araç türleriyle zengin bir geometrik tür ailesini destekler. <productname>PostgreSQL</productname> sınırsız sayıda kullanıcı tanımlı veri türleri ile özelleştirilebilir. Dolayısla, tür isimleri <acronym>SQL</acronym> standardındaki özel durumların desteklenmesinin gerektiği yerler dışında sözdizimsel anahtar sözcükler değildir.
   </para>
   <para>
İkinci örnek, şehir isimlerini ve bulundukları coğrafik bölgeleri saklayacaktır:
   </para>
   <para>
    <programlisting>
CREATE TABLE cities (
    name            varchar(80),
    location        point
);
</programlisting>
   </para>
   <para>
Buradaki <literal>point</literal>, PostgreSQL'e özel veri türüne bir örnektir.
   </para>
   <para>
Son olarak, eğer bir tabloya artık ihtiyacınız kalmadıysa ya da onu baştan oluşturmak istiyorsanız şu komutu kullanabilirsiniz:
   </para>
   <para>
    <synopsis format="linespecific">
DROP TABLE <replaceable>tabloismi</replaceable>;
</synopsis>
   </para>
  </section>
  <section xml:id="pgsql-tutorial-populate">
   <info>
    <title>Tablolara Satırların Girilmesi</title>
   </info>
   <para><userinput>INSERT</userinput> cümlesi tablolara veri girişi için kullanılır:
   </para>
   <para>
    <programlisting>
INSERT INTO weather VALUES ('San Francisco', 46, 50, 0.25, '1994-11-27');
</programlisting>
   </para>
   <para>
Veri giriş işlemlerinde tüm verilerin açıkça belirtilmesi gerekir. Sabitler sadece basit rakamsal değerler değillerdir, örnekte görüldüğü gibi tek tırnak içine alınıp belirtilmeleri şarttır. <literal>date</literal> türü esnek bir çeşit olduğundan neredeyse girilen tüm tarih çeşitlerini kabul eder. Fakat biz bu belgede belirsizlik yaratmaması açısından bu örnekteki biçimi kullanacağız.
   </para>
   <para><literal>point</literal> veri türü için bir koordinat çiftine ihtiyacımız olacak:
   </para>
   <para>
    <programlisting>
INSERT INTO sehirler VALUES ('San Francisco', '(-194.0, 53.0)');
</programlisting>
   </para>
   <para>
Çok sayıda sütun olduğunda bilginin hangi sırada girileceğini hatırlamanız zorlaşır. Sütun isimlerinin de belirtilebileceği bir sözdizimi bunu kolaylaştırır:
   </para>
   <para>
    <programlisting>
INSERT INTO weather (city, tmp_lo, tmp_hi, prcp, date)
    VALUES ('San Francisco', 43, 57, 0.0, '1994-11-29');
</programlisting>
   </para>
   <para>
İsterseniz, yukarıda bahsedilen yöntemi kullanarak verileri gireceğiniz sütunların yerlerini değiştirebilir ya da hiç yokmuş gibi farzedebilirsiniz, örneğin yağış miktarını yoksayalım:
   </para>
   <para>
    <programlisting>
INSERT INTO weather (date, city, tmp_hi, tmp_lo)
    VALUES ('1994-11-29', 'Hayward', 54, 37);
</programlisting>
   </para>
   <para>
Birçok geliştirici mevcut sütun sırasına göre veri girmektense sıralamayı açıkça belirtmeyi tercih eder.
   </para>
   <para>
Lütfen yukarıdaki komutların hepsini girin ki, ileride üzerinde alıştırma yapabileceğimiz bir kaç verimiz olsun.
   </para>
   <para>
Çok fazla komutu teker teker girmek yerine bunların hepsini tek bir metin dosyasından <userinput>COPY</userinput> cümlesi ile okutabilirsiniz. <userinput>COPY</userinput> cümlesi sırf bu amaç için tasarlandığından <userinput>INSERT</userinput> cümlesine göre daha hızlı çalışmasına karşın, onun kadar esnek değildir. Bir örnek:
   </para>
   <para>
    <programlisting>
COPY weather FROM '/home/user/weather.txt';
</programlisting>
   </para>
   <para>
Belirtilen dosya sunucunun erişebileceği bir yerde olmalıdır, istemcinin değil. <userinput>COPY</userinput> cümlesi hakkında daha fazla bilgi için <productname>PostgreSQL</productname> 8.0 belgelerindeki <link xlink:href="http://www.postgresql.org/docs/8.0/static/sql-copy.html"><userinput>COPY</userinput> cümlesinin açıklamasına</link> bakınız.
   </para>
  </section>
  <section xml:id="pgsql-tutorial-select">
   <info>
    <title>Bir Tablonun Sorgulanması</title>
   </info>
   <para>
Bir tablodan verileri almak için tablo <wordasword>sorgulanır</wordasword>. Bunun için bir <acronym>SQL</acronym> cümlesi olan <userinput>SELECT</userinput> kullanılır. Cümle, bir seçim listesi (istenen sütunları içeren bir liste), bir tablo listesi (verilerin alınacağı tabloların listesi) ve isteğe bağlı bir niteleme (sınırlamaların belirtildiği kısım) içerir. Örneğin, <literal>weather</literal> tablosundaki satırların tamamını almak için şunu yazın:
   </para>
   <para>
    <programlisting>SELECT * FROM weather;</programlisting>
   </para>
   <para>
Burada <literal>*</literal>, "tüm sütunlar" anlamına gelen bir kısayoldur.<footnote><para><literal>SELECT *</literal> kolay bir sorgulama olarak kullanışlı gibi görünse de, tabloya bir sütun eklemek sonuçları değiştireceğinden uygulamada çoğunlukla kötü bir tarz olarak kabul edilir.  </para></footnote>
   </para>
   <para>
Yani, aynı sonuç böyle de alınacaktır:
   </para>
   <para>
    <programlisting>
SELECT city, tmp_lo, tmp_hi, prcp, date FROM weather;
</programlisting>
   </para>
   <para>
Çıktı şöyle olmalıdır:
   </para>
   <para>
    <screen>
     city      | tmp_lo | tmp_hi | prcp |    date
---------------+--------+--------+------+------------
 San Francisco |     46 |     50 | 0.25 | 1994-11-27
 San Francisco |     43 |     57 |    0 | 1994-11-29
 Hayward       |     37 |     54 |      | 1994-11-29
(3 rows)
</screen>
   </para>
   <para>
Seçim listesinde sadece sütun isimlerini değil, ifadeleri de kullanabilirsiniz. Örnek:
   </para>
   <para>
    <programlisting>SELECT city, (tmp_hi+tmp_lo)/2 AS tmp_avg, date FROM weather;
</programlisting>
   </para>
   <para>
Bunun çıktısı şöyle olacaktır:
   </para>
   <para>
    <screen>
     city      | tmp_avg |    date
---------------+---------+------------
 San Francisco |      48 | 1994-11-27
 San Francisco |      50 | 1994-11-29
 Hayward       |      45 | 1994-11-29
(3 rows)
</screen>
   </para>
   <para><literal>AS</literal> deyiminin çıktılanacak sütunu yeniden isimlendirmekte nasıl kullanıldığına dikkat edin. (<literal>AS</literal> deyimi isteğe bağlıdır.)
   </para>
   <para>
Bir sorgu, istenen satırların yerini belirtmek üzere bir <literal>WHERE</literal> deyimi eklenerek nitelikli yapılabilir. <literal>WHERE</literal> deyimi bir mantıksal ifade içerir ve sadece mantıksal ifadeyi doğrulayan satırlar döndürülür. Niteleme amacıyla mantıksal işleçlere (<literal>AND</literal>, <literal>OR</literal> ve <literal>NOT</literal>) izin verilir. Örneğin, San Francisco'nun yağışlı olduğu günleri bulalım:
   </para>
   <para>
    <programlisting>
SELECT * FROM weather
    WHERE city = 'San Francisco' AND prcp &gt; 0.0;
</programlisting>
   </para>
   <para>
Sonuç:
   </para>
   <para>
    <screen>
     city      | tmp_lo | tmp_hi | prcp |    date
---------------+--------+--------+------+------------
 San Francisco |     46 |     50 | 0.25 | 1994-11-27
(1 row)
</screen>
   </para>
   <para>
Sorgu sonucunun sıralanmış olmasını da isteyebilirsiniz:
   </para>
   <para>
    <programlisting>
SELECT * FROM weather
    ORDER BY city;
</programlisting>
   </para>
   <para>Sonuç:</para>
   <para>
    <screen>
     city      | tmp_lo | tmp_hi | prcp |    date
---------------+--------+--------+------+------------
 Hayward       |     37 |     54 |      | 1994-11-29
 San Francisco |     43 |     57 |    0 | 1994-11-29
 San Francisco |     46 |     50 | 0.25 | 1994-11-27
</screen>
   </para>
   <para>
Bu örnekte, sıralamanın nasıl yapılacağı tam olarak belirtilmemiştir, dolayısıyla hangi San Fransisco satırının önce geleceği belli olmaz. Fakat aşağıdaki sorgu daima bu sıralamayla dönecektir.
   </para>
   <para>
    <programlisting>
SELECT * FROM weather
    ORDER BY city, tmp_lo;
</programlisting>
   </para>
   <para>
Bir sorgunun sonucundan yinelenmiş satırların kaldırılmasını isteyebilirsiniz:
   </para>
   <para>
    <programlisting>
SELECT DISTINCT city
    FROM weather;
</programlisting>
   </para>
   <para>
    <screen>
     city
---------------
 Hayward
 San Francisco
(2 rows)
</screen>
   </para>
   <para>
Burada da yine satırların sırası her sorguda farklı olabilir. Sonucun istediğimiz sırada olmasını <literal>DISTINCT</literal> ve  <literal>ORDER BY</literal> deyimlerini birlikte kullanarak sağlayabilirsiniz<footnote><para>
Bazı veritabanı sistemlerinde ve PostgreSQL'in eski sürümlerinde <literal>DISTINCT</literal> gerçeklenimi sıralamayı özdevimli yaptığından <literal>ORDER BY</literal> gereksizdir. Fakat bunun böyle olması SQL standardının bir zorlaması değildir ve şimdiki <productname>PostgreSQL</productname> <literal>DISTINCT</literal> deyiminin satırları sıralayacağını garanti etmemektedir.</para></footnote>:
   </para>
   <para>
    <programlisting>SELECT DISTINCT city
    FROM weather
    ORDER BY city;
</programlisting>
   </para>
  </section>
  <section xml:id="pgsql-tutorial-join">
   <info>
    <title>Tablolar Arası Katılım</title>
   </info>
   <para>
Buraya kadar, yaptığımız sorgulamalarda her seferinde sadece bir tabloya erişildi. Oysa sorgulamalar aynı andan birden çok tabloya erişebildiği gibi, aynı tabloya birden fazla kez erişerek satırlara daha çeşitli yaptırımlar uygulayabilir. Aynı anda birden fazla satır ya da birden fazla tabloya erişen sorgulara <wordasword>katılımlı sorgu</wordasword> denir. Sözgelimi (daha önce oluşturduğumuz tablolardaki) tüm şehirlerin hava durumlarını ve konumlarını aynı anda listelemek istiyoruz. Bunun için <literal>weather</literal> tablosundaki tüm <literal>city</literal> sütunları ile <literal>cities</literal> tablosundaki tüm <literal>name</literal> sütunlarını karşılaştırıp, aynı olan satır çiftlerini seçmek gerekir.
   </para>
   <note>
    <para>
Bu sadece kavramsal bir modeldir. Katılımlı sorgular, aslında, her olası satır çiftini karşılaştırmaktan biraz daha verimli bir anlamda uygulanır ama bu işlemi kullanıcı görmez.
   </para>
   </note>
   <para>
Yukarıda bahsedilen işlemi şu sorgu ile elde edebiliriz:
   </para>
   <para>
    <programlisting>
SELECT *
    FROM weather, cities
    WHERE city = name;
</programlisting>
   </para>
   <para>
    <screen>
     city      | tmp_lo | tmp_hi | prcp |    date    |     name      | location
---------------+--------+--------+------+------------+---------------+-----------
 San Francisco |     46 |     50 | 0.25 | 1994-11-27 | San Francisco | (-194,53)
 San Francisco |     43 |     57 |    0 | 1994-11-29 | San Francisco | (-194,53)
(2 rows)
</screen>
   </para>
   <para>
Çıktıda dikkat edilmesi gereken iki nokta bulunmakta:
   </para>
   <para>
    <itemizedlist>
     <listitem>
      <para>
Haywrad şehri için hiçbir çıktı alınmadı dikkat edildiyse. Bunun nedeni ise <literal>cities</literal>  tablosunda Hayward adlı bir şehir olmaması ve dolayısıyla <literal>JOIN</literal> bu şehri eledi. İleride bunun nasıl düzeltilebileceği üzerinde durulacak.
      </para>
     </listitem>
     <listitem>
      <para>
Bir diğer dikkat çeken nokta ise, şehirlerin adını yazan iki tane sütun olması. Bunun sebebi <literal>weather</literal> ve <literal>cities</literal> tablosunun birleştirilmesidir. Pratikte bu istenmeyen bir sonuçtur. Böyle bir durumda buna neden olan <literal>*</literal> ifadesi yerine açıkça listelenmesini istediğimiz sütunları yazarak bu işi halledebiliriz:
   </para>
      <para>
       <programlisting>
SELECT city, tmp_lo, tmp_hi, prcp, date, location
    FROM weather, cities
    WHERE city = name;
</programlisting>
      </para>
     </listitem>
    </itemizedlist>
   </para>
   <formalpara>
    <info>
     <title>Alıştırma:</title>
    </info>
    <para><literal>WHERE</literal> deyimi kalktığında ortaya çıkan sonucun nedenini bulmaya çalışın.
    </para>
   </formalpara>
   <para>
Tablolardaki tüm sütun isimleri farklı olduğundan çözümleyici hangi ismin hangi tabloya ait olduğunu bulur. Ama bunu daha da açıkça belirtmek isimler aynı olduğunda dahi sorun çıkmasını önler ve tavsiye edilen de budur:
   </para>
   <para>
    <programlisting>
SELECT weather.city, weather.tmp_lo, weather.tmp_hi,
       weather.prcp, weather.date, cities.location
    FROM weather, cities
    WHERE cities.name = weather.city;
</programlisting>
   </para>
   <para>
Şimdiye kadar gördüğümüz katılım sorguları ayrıca şu şekilde de yazılabilir:
   </para>
   <para>
    <programlisting>
SELECT *
    FROM weather INNER JOIN cities ON (weather.city = cities.name);
</programlisting>
   </para>
   <para>
Bu sözdizimi yukarıdaki örneklerden biri için çok kullanılan bir sözdizimi değildir, ama bundan sonraki konuları anlayabilmek için yardımcı olacağından burada gösterdik.
   </para>
   <para>
Şimdi Hayward kayıtlarına nasıl kavuşacağımızı işleyeceğiz. İstediğimiz şey <literal>weather</literal> tablosu üzerinde tarama yapıp, <literal>cities</literal> tablosunda bunlarla eşleşen satırları bulmak. Eğer <literal>cities</literal> tablosunda herhangi bir eşleşme bulamazsak, o sütun <literal>cities</literal> tablosu alanında boş gözükecek. Bu tür sorgulama işlemleri <wordasword>haricen katılım</wordasword> (outer join) olarak bilinir. (Şimdiye kadar gördüğümüz katılım sorgularında ise hep <wordasword>dahilen katılım</wordasword> (inner join) kullanmıştık.) Komut şöyle görünür:
   </para>
   <para>
    <programlisting>
SELECT *
    FROM weather LEFT OUTER JOIN cities ON (weather.city = cities.name);

     city      | tmp_lo | tmp_hi | prcp |    date    |     name      | location
---------------+--------+--------+------+------------+---------------+-----------
 Hayward       |     37 |     54 |      | 1994-11-29 |               |
 San Francisco |     46 |     50 | 0.25 | 1994-11-27 | San Francisco | (-194,53)
 San Francisco |     43 |     57 |    0 | 1994-11-29 | San Francisco | (-194,53)
(3 rows)
</programlisting>
   </para>
   <para>
Bu sorguya <wordasword>sola haricen katılımlı</wordasword> (left outer join) sorgu denir. Böyle adlandırılmasının sebebi soldaki tablonun tüm satırları en az bir kere listelenirken, sağda yer alan tablonun sadece soldaki tablonun satırlarıyla eşleşen satırlarının listelenmesidir. Bir sol-tablo satırı çıktılanırken sağ-tabloda bu satırla eşleşen bir satır yoksa, sağ-tablonun sütunları boş kalır.
   </para>
   <formalpara>
    <info>
     <title>Alıştırma:</title>
    </info>
    <para>
Ayrıca, <wordasword>sağa haricen katılımlı</wordasword> (right outer join) ve <wordasword>iki yönlü haricen katılımlı</wordasword> (full outer join) sorgu türleri de var.  Bunların ne yaptığını da siz bulmayı deneyin.
    </para>
   </formalpara>
   <para>
Ayrıca, bir tabloyu kendine katılımlı olarak da sorgulayabiliriz ve buna  <wordasword>kendine katılımlı</wordasword> sorgu denir. Bir örnek olarak, diğer hava durumu kayıtlarının sıcaklık aralığı içinde kalan hava durumu kayıtlarını bulmak isteyelim. Yani, her <literal>weather</literal> satırının <literal>tmp_lo</literal> ve <literal>tmp_hi</literal> sütununu diğer <literal>weather</literal> satırlarının <literal>tmp_lo</literal> ve <literal>tmp_hi</literal> sütunu ile karşılaştıracağız. Bunu şu sorgu ile yapabiliriz:
   </para>
   <para>
    <programlisting>
SELECT W1.city, W1.tmp_lo AS low, W1.tmp_hi AS high,
    W2.city, W2.tmp_lo AS low, W2.tmp_hi AS high
    FROM weather W1, weather W2
    WHERE W1.tmp_lo &lt; W2.tmp_lo
    AND W1.tmp_hi &gt; W2.tmp_hi;

     city      | low | high |     city      | low | high
---------------+-----+------+---------------+-----+------
 San Francisco |  43 |   57 | San Francisco |  46 |   50
 Hayward       |  37 |   54 | San Francisco |  46 |   50
(2 rows)
</programlisting>
   </para>
   <para>
Burada katılımın sol ve sağ taraflarını ayırabilmek için <literal>weather</literal> tablosunu <literal>W1</literal> ve <literal>W2</literal> olarak yeniden isimlendirdik. Ayrıca, bu çeşit isimlendirmeleri aynı şeyleri uzun uzadıya yazmaktan kaçınmak için diğer sorgularda da kullanabilirsiniz. Örnek:
   </para>
   <para>
    <programlisting>SELECT *
    FROM weather w, cities c
    WHERE w.city = c.name;
</programlisting>
   </para>
   <para>
Bu tarz kısaltmalarla sıkça karşılaşacaksınız.
   </para>
  </section>
  <section xml:id="pgsql-tutorial-agg">
   <info>
    <title>Ortak Değer İşlevleri</title>
   </info>
   <para>
Çoğu ilişkisel veritabanı ürünü gibi PostgreSQL'de ortak değer işlevlerini destekler. Bir ortak değer işlevi çok sayıda satırı girdi olarak alır ve bunlardan tek bir sonuç elde eder. Belli bir satır grubu üzerinde işlem yaparak, bunların sayısını bulan <function>count</function>, değerlerinin toplamını bulan <function>sum</function>, değerlerinin ortalamasını hesaplayan <function>avg</function>, en büyük ve en küçük değerleri bulan <function>max</function> ve <function>min</function> işlevleri bunlara birer örnektir.
   </para>
   <para>
Örnek olarak, düşük sıcaklık değerlerinin en yükseğini bulalım:
   </para>
   <para>
    <screen>
SELECT max(tmp_lo) FROM weather;
 max
-----
  46
(1 row)
</screen>
   </para>
   <para>
Eğer bu sıcaklığın hangi şehir (veya şehirlerde) ortaya çıktığını bulmak istersek,
   </para>
   <para>
    <programlisting>
SELECT city FROM weather WHERE tmp_lo = max(tmp_lo);     <lineannotation>YANLIŞ</lineannotation>
</programlisting>
   </para>
   <para>
bu çalışmaz, çünkü <function>max</function> işlevi <literal>WHERE</literal> deyiminde kullanılamaz. (Böyle bir sınırlamanın olmasının sebebi, <literal>WHERE</literal> deyiminin ortak değeri bulunacak satırların belirlenmesinde kullanılmak zorunda olmasıdır; yani, deyim, işlevden önce değerlendirilmiş olmalıdır.) Bu durumda böyle bir sorunu gidermek için sorgunun yeniden durumlanabilmesini sağlayan aşağıdaki gibi bir <wordasword>altsorgu</wordasword> (subquery) kullanılır:
   </para>
   <para>
    <programlisting>
SELECT city FROM weather
    WHERE tmp_lo = (SELECT max(tmp_lo) FROM weather);
</programlisting>
   </para>
   <para>
    <screen>
     city
---------------
 San Francisco
(1 row)
</screen>
   </para>
   <para>
Şimdi her şey yolunda. Çünkü ortak değer bulma bir altsorgu ile yapıldıktan sonra sonuç dış sorguda karşılaştırma değeri olarak kullanıldı.
   </para>
   <para>
Ortak değer işlevleri <literal>GROUP BY</literal> deyimi ile kullanıldığında oldukça yararlıdır. Örneğin her şehrin en yüksek düşük sıcaklığını bulmak için şunu yazabiliriz:
   </para>
   <para>
    <programlisting>
SELECT city, max(tmp_lo)
    FROM weather
    GROUP BY city;
</programlisting>
   </para>
   <para>Bu bize her şehir için bir değer verecektir:</para>
   <para>
    <screen>
     city      | max
---------------+-----
 Hayward       |  37
 San Francisco |  46
(2 rows)
</screen>
   </para>
   <para>
Burada, satırlar şehirlere göre gruplanmakta, her gruptaki satırlar üzerinde <literal>max</literal> işlevi hesaplanmakta ve sonuçlar listelenmektedir. Hesaplamaya dahil olacak satırları <literal>HAVING</literal> deyimini kullanarak gruplayabiliriz:
   </para>
   <para>
    <programlisting>
SELECT city, max(tmp_lo)
    FROM weather
    GROUP BY city
    HAVING max(tmp_lo) &lt; 40;
</programlisting>
   </para>
   <para>
    <screen>
  city   | max
---------+-----
 Hayward |  37
(1 row)
</screen>
   </para>
   <para>
Sadece <literal>tmp_lo</literal> değeri 40'ın altında olan şehirleri listelelemsi dışında bu cümle de aynı sonucu verir.  Eğer bir de bu işi abartıp sadece "S" ile başlayan şehir isimlerini istersek:
   </para>
   <para>
    <programlisting>
SELECT city, max(tmp_lo)
    FROM weather
    WHERE city LIKE 'S%'  <co xml:id="pgsql-co.tutorial-agg-like"/>
    GROUP BY city
    HAVING max(tmp_lo) &lt; 40;
</programlisting>
   </para>
   <para>
    <calloutlist>
     <callout arearefs="pgsql-co.tutorial-agg-like">
      <para><literal>LIKE</literal> işleci kalıp eşleştirmesi yapar ve <productname>PostgreSQL</productname> 8.0 belgelerindeki <link xlink:href="http://www.postgresql.org/docs/8.0/static/functions-matching.html">Kalıp Eşleme</link> bölümünde açıklanmıştır.
     </para>
     </callout>
    </calloutlist>
   </para>
   <para><acronym>SQL</acronym> dilinde <literal>WHERE</literal> ve <literal>HAVING</literal> deyimlerinin ortak değer işlevleri ile nasıl etkileşime girdiğinin anlaşılması önemlidir. <literal>WHERE</literal> ve <literal>HAVING</literal> deyimleri arasındaki temel fark şudur: <literal>WHERE</literal> satırları, gruplar ve ortak değerler hesaplanmadan önce seçer (ortak değer hesaplamasında kullanılacak satırları seçer), <literal>HAVING</literal> deyimi ise ortak değerler hesaplandıktan ve gruplamalar yapıldıktan sonra işleme sokulur. Sonuç olarak, <literal>WHERE</literal> ifadelerinde (altsorgu dışında) ortak değer bulma işlemleri kullanılmazken, <literal>HAVING</literal> deyimlerinde kaçınılmazdır. (Aslında <literal>HAVING</literal> deyimleri içinde ortak değer işlevleri dışında ifadeler de kullanmanıza izin verilmiştir ama, bu biraz savurganlık olur; böyle bir koşulu <literal>WHERE</literal> deyiminde kullanmak daha verimlidir.)
   </para>
   <para>
Önceki örnekte,  <literal>WHERE</literal> deyiminde bir ortak değer bulma işlemine ihtiyaç duyulmadığından, şehir isimlerine kısıtlama uygulamıştık. Bu, kısıtlamanın <literal>HAVING</literal> ile sağlanmasından daha uygundur; çünkü gruplamanın ve ortak değer hesaplamasının <literal>WHERE</literal> sınamasından geçemeyen satırlar için yapılması gereksizdir.
   </para>
  </section>
  <section xml:id="pgsql-tutorial-update">
   <info>
    <title>Verilerin Güncellenmesi</title>
   </info>
   <para>
Mevcut satırları <literal>UPDATE</literal> cümlesini kullanarak güncelleyebilirsiniz.  Farzedelim ki, ayın 28'inden sonraki tüm sıcaklıkların 2 derece daha az olması gerektiğini fark ettiniz. Bu güncelleme işlemini şöyle yapabilirsiniz:
   </para>
   <para>
    <programlisting>
UPDATE weather
    SET tmp_hi = tmp_hi - 2,  tmp_lo = tmp_lo - 2
    WHERE date &gt; '1994-11-28';
</programlisting>
   </para>
   <para>
Verinin yeni durumuna bakalım:
   </para>
   <para>
    <programlisting>
SELECT * FROM weather;

     city      | tmp_lo | tmp_hi | prcp |    date
---------------+--------+--------+------+------------
 San Francisco |     46 |     50 | 0.25 | 1994-11-27
 San Francisco |     41 |     55 |    0 | 1994-11-29
 Hayward       |     35 |     52 |      | 1994-11-29
(3 rows)
</programlisting>
   </para>
  </section>
  <section xml:id="pgsql-tutorial-delete">
   <info>
    <title>Veri Silme</title>
   </info>
   <para>
Bir tablodan satırları silmek için <literal>DELETE</literal> cümlesini kullanabilirsiniz. Hayward'ın hava durumuyla artık ilgilenmediğinizi varsayalım. Tablodan bu satırları silmek için şunu yazabilirsiniz:
   </para>
   <para>
    <programlisting>DELETE FROM weather WHERE city = 'Hayward';
</programlisting>
   </para>
   <para>
Böylece, <literal>weather</literal> tablosundan Hayward ile ilgili kayıtlar silinir.
   </para>
   <para>
    <programlisting>SELECT * FROM weather;
</programlisting>
   </para>
   <para>
    <screen>
     city      | tmp_lo | tmp_hi | prcp |    date
---------------+--------+--------+------+------------
 San Francisco |     46 |     50 | 0.25 | 1994-11-27
 San Francisco |     41 |     55 |    0 | 1994-11-29
(2 rows)
</screen>
   </para>
   <para>
Özellikle sakınılması gereken şöyle bir sorgulama da var:
   </para>
   <para>
    <synopsis format="linespecific">DELETE FROM <replaceable>tabloismi</replaceable>;
</synopsis>
   </para>
   <para>
Bir niteleme olmaksızın, <literal>DELETE</literal> cümlesi belirtilen tablodaki <emphasis>bütün</emphasis> satırları silecek, tabloyu boşaltacaktır. Üstelik, sistem bunu yapmadan önce sizden bir doğrulama da istemeyecektir!
   </para>
  </section>
 </chapter>
 <chapter xml:id="pgsql-tutorial-advanced">
  <info>
   <title>Gelişmiş Özellikler</title>
  </info>
  <para>
Bundan önceki bölümlerde bir <productname>PostgreSQL</productname> veritabanına nasıl veri girilip, onlara nasıl erişileceğini işledik. Bu bölümde ise PostgreSQL'in daha gelişmiş özellikleri olan verileri nasıl daha kolay idare edilebileceği ve veri kaybına ya da bozulma riskine karşı alınacak önlemlerden bahsedeceğiz. En sonunda, PostgreSQL'in bir kaç ek özelliğine göz atma şansımız olacak.
   </para>
  <para>
Bu kısımda <xref linkend="pgsql-tutorial-sql"/> kısmında gördüğünüz örnekleri çoğaltma ve geliştirme şansınız olacak, ki bu yüzden bu kısmın da dikkatle okunması sizin lehinize olur. Bu bölümden sonraki alıştırmaları ise <filename>tutorial/advanced.sql</filename> dosyasında bulabilirsiniz. Bu dosya ek olarak burada tekrar belirtmeyeceğimiz ama yüklenmesi gereken örnek veriler içermektedir. (<xref linkend="pgsql-tutorial-sql"/> sayfasında dosya kullanımı açıklanmıştır.)
  </para>
  <section xml:id="pgsql-tutorial-views">
   <info>
    <title>Sanal Tablolar</title>
   </info>
   <para>
Bu bölümü okumadan önce <xref linkend="pgsql-tutorial-join"/> bölümünü okumanızı öneririz. Diyelim ki, uygulamanızda hava durumu kayıtları ile şehirlerin yerlerinin birarada listelenmesi ile çok ilgileniyorsunuz. Bunun için bir sorgu oluşturup bu sorguya isim verebilir ve bu sorguya herhangi bir tabloya erişir gibi erişebilirsiniz.
   </para>
   <para>
    <programlisting>
CREATE VIEW myview AS
    SELECT city, tmp_lo, tmp_hi, prcp, date, location
        FROM weather, cities
        WHERE city = name;

SELECT * FROM myview;
</programlisting>
   </para>
   <para>
Sanal tablo kullanımı iyi SQL veritabanı tasarımında önemli bir rol oynar. Sanal tablolar, tablolarınızdaki yapının ayrıntılarını toparlamanızı mümkün kılarak, arkasında kararlı bir arayüz olarak uygulamanızın gelişimini değiştirebilir.
   </para>
   <para>
Sanal tablolar, gerçek bir tablonun kullanılabildiği hemen her yerde kullanılabilir. Fakat, sanal tabloları başka sanal tabloları oluşturmak için kullanmak pek iyi bir yöntem değildir.
   </para>
  </section>
  <section xml:id="pgsql-tutorial-fk">
   <info>
    <title>Anahtarlar</title>
   </info>
   <para><xref linkend="pgsql-tutorial-sql"/> kısmındaki <literal>weather</literal> ve <literal>cities</literal> tablolarını tekrar ele alalım ve <literal>weather</literal> tablosuna girilecek kayıtlardan <literal>cities</literal> tablosundaki kayıtlarla eşleşmeyecek olanlarının tabloya girilmeyeceğinden emin olmak istediğinizi varsayalım. Buna <wordasword>verilerin göreli bütünlüğünün sağlanaması</wordasword> diyoruz. Basitleştirmeli veritabanı sistemlerinde bu şöyle gerçeklenir: Önce <literal>cities</literal> tablosunda eşleşen bir kaydın olup olmadığına bakılır ve yeni <literal>weather</literal> kaydının tabloya girilip girilmeyeceğine karar verilir. Bu yaklaşım çok sakıncalı sorunlar içerir, ancak <productname>PostgreSQL</productname> bunu sizin için yapabilir.
   </para>
   <para>
Tabloların yeni bildirimleri şöyle olurdu:
   </para>
   <para>
    <programlisting>
CREATE TABLE cities (
        city     varchar(80) primary key,
        location point
);

CREATE TABLE weather (
        city     varchar(80) references cities(city),
        tmp_lo   int,
        tmp_hi   int,
        prcp     real,
        date     date
);
</programlisting>
   </para>
   <para>
Şimdi geçersiz bir kaydı girmeye çalışalım:
   </para>
   <para>
    <programlisting>
INSERT INTO weather VALUES ('Berkeley', 45, 53, 0.0, '1994-11-28');
</programlisting>
   </para>
   <para>
    <screen>
ERROR:  insert or update on table "weather" violates foreign key constraint
"weather_city_fkey"
DETAIL:  Key (city)=(Berkeley) is not present in table "cities".
</screen>
   </para>
   <para>
Anahtarların davranışları uygulamanıza en iyi şekilde uyarlanabilir. Bu eğitmende bu basit örnekten daha ileri gitmeyeceğiz, fakat daha fazla bilgi edinmek isterseniz, <productname>PostgreSQL</productname> 8.0 belgelerindeki <link xlink:href="http://www.postgresql.org/docs/8.0/static/ddl.html">Veri Tanımlama</link> kısmına bakabilirsiniz. Anahtarları doğru şekilde kullanarak veritabanı uygulamalarınızın kalitesini oldukça arttırabilirsiniz, dolayısıyla anahtar kullanımını iyi öğrenmenizi öneririz.
   </para>
  </section>
  <section xml:id="pgsql-tutorial-transactions">
   <info>
    <title>Hareketler</title>
   </info>
   <para><wordasword>Hareketler</wordasword> tüm veritabanı sistemlerinin en temel konularından biridir. Bir hareketin başlıca özelliği ya hep ya hiç şeklinde uygulanmak üzere çok sayıda adımın tek bir adım haline getirilmesidir. Hareketi oluşturan adımlar arasındaki işlemler onunla işbirliği yapan diğer hareketlere görünür değildir ve hareketin tamamlanmasını engelleyen bazı olumsuzluklar olduğunda hareketi oluşturan adımların hiçbiri veritabanını etkilemez.
   </para>
   <para>
Örneğin, bir bankanın şube hesapları (branches) olsun ve bu hesaplarda çeşitli müşteri hesapları (accounts) ve bu hesaplarda da bir miktar nakit (balance) bulunsun. Alice'in hesabından 100.00 doları Bob'ın hesabına geçirmek istediğimizi kabul edelim. Son derece basitleştirerek, SQL komutları şöyle olurdu:
   </para>
   <para>
    <programlisting>
UPDATE accounts SET balance = balance - 100.00
    WHERE name = 'Alice';
UPDATE branches SET balance = balance - 100.00
    WHERE name = (SELECT branch_name FROM accounts WHERE name = 'Alice');
UPDATE accounts SET balance = balance + 100.00
    WHERE name = 'Bob';
UPDATE branches SET balance = balance + 100.00
    WHERE name = (SELECT branch_name FROM accounts WHERE name = 'Bob');
</programlisting>
   </para>
   <para>
Bu komutların ayrıntılarının burada bir önemi yoktur; önemli olan bunun basit işlemler olarak değil, ayrı ayrı güncellemelerin hepsinin birden yapılmasıdır. Bankamızın memurları bu işlemlerin ya hepsinin yapılmasını ya da hiçbirinin yapılmamasını ister. Eğer Bob, Alice'in hesabından yeterli miktarı alamazsa ya da Alice'in hesabından gerekli miktar alındığı halde Bob'un hesabına geçmezse sistemin hata vermesinden başka her iki müşteri de memnun olmayacaktır. Yani, eğer işlemlerden biri gerçekleşmezse bu adımların hiçbirinin veritabanını etkilemeyeceğini garantilemeliyiz. Yapılacak işlemlerin bir <wordasword>hareket</wordasword> içinde gruplanması bize bu garantiyi sağlar.  Bir hareket <wordasword>atomik</wordasword> olmalıdır, denir: diğer hareketler açısından ya tüm adımların hepsi gerçekleşmeli ya da hiçbiri gerçekleşmemelidir.
   </para>
   <para>
Kesinlikle emin olmamız gereken bir nokta ise bir hareket başarı ile işlemi yürütmüş olsa bile, bilginin tamam olarak veritabanına geçip geçmediğidir, son anda bir sistem kaynaklı hata olsa bile. Örneğin, Bob'un hesabından para çekmeye çalıştığımızda, o daha bankanın kapısında çıkmadan, paranın bir hata sonucu onun hesabında çekilmiş olarak gözükmemesi gibi bir şansı göze alamayız. Tam bu noktada bir veritabanı, bir hareketle ilgili tüm işlemler yapılıp kayıtlar sabit disk gibi bir saklama alanına aktarılmadan 'tamam' sonucunu göndermez.
   </para>
   <para>
Bir diğer önemli nokta ise çok sayıda hareket aynı anda çalışırken birbirlerinin tamamlanmamış sonuçlarını görmemesi gerektiğidir. Örneğin bir hareket tüm şubelerdeki (branches) hesap miktarlarını toplarken başka bir hareket Alice ya da Bob'un hesabı üzerinde işlem yapamayacaktır. Kısaca bir hareket tamam benim işim bitti demeden, diğer bir hareket bir işlem başlatamayacaktır.
   </para>
   <para>
PostgreSQL'de bir hareket, <userinput>BEGIN</userinput> ve <userinput>COMMIT</userinput> SQL komutları ile sarmalanmış adımlardan oluşur. Bu durumda, banka işlemlerimiz aslında şöyle görünecektir:
   </para>
   <para>
    <programlisting>BEGIN;
UPDATE accounts SET balance = balance - 100.00
    WHERE name = 'Alice';
-- vesaire vesaire
COMMIT;
</programlisting>
   </para>
   <para>
Hareketin de belli bir noktasında işlemin iptal edilmesi gerekebilir (Mesela Alice'in hesabı aktarılacak miktar için yetmeyip negatife düşerse), bunun için <userinput>COMMIT</userinput> yerine <userinput>ROLLBACK</userinput> kullanabiliriz ve böyle bir durumda tüm güncellemeler iptal edilir.
   </para>
   <para><productname>PostgreSQL</productname> aslında her SQL cümlesini sanki bir hareket gerçekleştiriyormuş gibi ele alır. Bir <userinput>BEGIN</userinput> komutu kullanmazsanız, her cümlenin başına örtük bir <userinput>BEGIN</userinput> ve cümle başarılı ise sonuna da örtük bir <userinput>COMMIT</userinput> getirilir. Bu nedenle, <userinput>BEGIN</userinput> ve <userinput>COMMIT</userinput> komutları ile sarmalanmış cümlelere bazan <wordasword>hareket kümesi</wordasword> de dendiği olur.
   </para>
   <note>
    <para>
Bazı istemci kütüphaneleri <userinput>BEGIN</userinput> ve <userinput>COMMIT</userinput> komutlarını kendiliğinden koyar, böylece istemeden hareket kümelerinin etkileriyle karşılaşırsınız. Bu bakımdan kullandığınız arayüzün belgelerine bakmayı unutmayın.
    </para>
   </note>
   <para>
Bir hareketi içinde kayıt noktaları belirterek cümle cümle  denetlemek de mümkündür. Kayıt noktaları bir hareketin belli parçalarını seçerek iptal etmeyi mümkün kılar. Bir kayıt noktasını <userinput>SAVEPOINT</userinput> ile tanımladıktan sonra ihtiyaç duyarsanız, <userinput>ROLLBACK TO</userinput> ile bu kayıt noktasına kadar olan kısmı geri sarabilirsiniz. Bir hareketin bu iki komut arasında kalan veritabanı değişiklikleri iptal edilir, fakat, bu bölümden önce yapılanlar veritabanında kalır.
   </para>
   <para>
Bir kayıt noktasına kadar geri sarıldıktan sonra, işlem bu noktadan devam eder, öyle ki, bu defalarca yapılabilir. Tersine, belli bir kayıt noktasına geri sarmaya artık ihtiyaç duymayacağınızdan emin olduğunuzda, onu serbest bırakabilirsiniz, böylece sistem bazı özkaynakları serbest bırakabilir. Serbest bırakmanın da, bir kayıt noktasına geridönmenin de tanımlanmasının ardından tüm kayıt noktalarının özdevimli olarak serbest bırakılacağını unutmayın.
   </para>
   <para>
Bunların hepsi hareket kümesinin içinde gerçekleşir, dolayısıyla, bu işlemlerin hiçbiri diğer veritabanı oturumlarına görünür değildir. Bir hareket kümesini işleme sokulduğunda, geriye sarma işlemleri diğer oturumlara asla görünür olmazken, işleme sokulan diğer eylemler bir birim olarak diğer oturumlara görünür hale gelir.
   </para>
   <para>
Bankanın veritabanını hatırlarsanız, Alice'in hesabından Bob'un hesabına 100 dolar aktarmıştık ama daha sonra baktığımızda, paranın Wally'nin hesabına geçmesi gerektiğini keşfetmiş olalım. Bunun  için kayıt noktalarını şöyle kullanabiliriz:
   </para>
   <para>
    <programlisting>
BEGIN;
UPDATE accounts SET balance = balance - 100.00
    WHERE name = 'Alice';
SAVEPOINT my_savepoint;
UPDATE accounts SET balance = balance + 100.00
    WHERE name = 'Bob';
-- dur bakalım ... Wally'nin hesabını kullanacağız
ROLLBACK TO my_savepoint;
UPDATE accounts SET balance = balance + 100.00
    WHERE name = 'Wally';
COMMIT;
</programlisting>
   </para>
   <para>
Bu örnek, şüphesiz fazla basit, fakat bir hareket bloğu üzerinde kayıt noktalarınını kullanımı ile ilgili yeterince denetim var. Dahası, sistem tarafından bir hatadan dolayı çıkış istendiğinde, <userinput>ROLLBACK TO</userinput> bir hareket kümesinin denetimini yeniden kazanmanın tek yoludur, tamamen gerisarma yapılıp tekrar başlanabilir.
   </para>
  </section>
  <section xml:id="pgsql-tutorial-inheritance">
   <info>
    <title>Kalıtım</title>
   </info>
   <para>
Kalıtım (miras alma), nesne yönelimli veritabanlarından kaynaklanan bir kavramdır. Bu sayede veritabanı tasarımında ilginç ve yeni olasılıkların yolu açılmıştır.
   </para>
   <para>
İki tablo oluşturalım: Bir <literal>cities</literal> tablosu ile bir <literal>capitals</literal> tablosu. Doğal olarak, başkentler aynı zamanda şehirdirler, dolayısıyla şehirleri listelerken dolaylı olarak başkentleri de bir şekilde göstermek isteriz. Biraz akıllıca hareket ederek, şöyle bir şema kullanabilirsiniz:
   </para>
   <para>
    <programlisting>
CREATE TABLE capitals (
  name       text,
  population real,
  altitude   int,    -- (feet cinsinden)
  state      char(2)
);

CREATE TABLE non_capitals (
  name       text,
  population real,
  altitude   int     -- (feet cinsinden)
);

CREATE VIEW cities AS
  SELECT name, population, altitude FROM capitals
    UNION
  SELECT name, population, altitude FROM non_capitals;
</programlisting>
   </para>
   <para>
Çok fazla sorgulamadan bu doğru çalışır, fakat, bazı satırları güncellemek istediğinizde tuhaf şeyler olur.
   </para>
   <para>
Bu daha iyi bir çözümdür:
   </para>
   <para>
    <programlisting>
CREATE TABLE cities (
  name       text,
  population real,
  altitude   int     -- (feet cinsinden)
);

CREATE TABLE capitals (
  state      char(2)
) INHERITS (cities);
</programlisting>
   </para>
   <para>
Bu durumda <literal>capitals</literal> tablosu, <literal>cities</literal> tablosundaki bütün sütunları (<literal>name</literal>, <literal>population</literal> ve <literal>altitude</literal>) miras alacaktır. <literal>name</literal> sütununun türü <literal>text</literal> olup, değişken uzunlukta dizge kabul eden bir PostgreSQL türüdür. Eyalet başkentleri ek bir sütuna, eyalet sütununa sahiptir ve hangi eyaletin başkenti olduğu bu sütunda belirtilir. PostgreSQL'de bir tablo, sıfır ya da daha fazla tablo miras alabilir.
   </para>
   <para>
Örneğin, ağağıdaki sorgu, tüm şehirlerin isimleri arasından başkentler de dahil 500 feet'ten daha yüksekteki şehirleri bulmaktadır:
   </para>
   <para>
    <programlisting>
SELECT name, altitude
  FROM cities
  WHERE altitude &gt; 500;
</programlisting>
   </para>
   <para>
Sorgu şöyle dönecektir:
   </para>
   <para>
    <screen>
   name    | altitude
-----------+----------
 Las Vegas |     2174
 Mariposa  |     1953
 Madison   |      845
(3 rows)
</screen>
   </para>
   <para>
Aşağıdaki sorgu ise, eyalet başkenti olmayan şehirlerden 500 feet ve daha yüksekte olan şehirleri bulmaktadır:
   </para>
   <para>
    <programlisting>
SELECT name, altitude
    FROM ONLY cities
    WHERE altitude &gt; 500;
</programlisting>
   </para>
   <para>
    <screen>
   name    | altitude
-----------+----------
 Las Vegas |     2174
 Mariposa  |     1953
(2 rows)
</screen>
   </para>
   <para>
Buradaki <literal>ONLY</literal> deyimi sorgunun sadece <literal>cities</literal> tablosunda yapılacağını <literal>cities</literal> tablosunu miras alan tablolarda yapılmayacağını belirtir. Daha önce bahsettiğimiz <userinput>SELECT</userinput>, <userinput>UPDATE</userinput> ve <userinput>DELETE</userinput> cümleleri de dahil olmak üzere pek çok SQL cümlesi <literal>ONLY</literal> deyimini destekler.
   </para>
   <note>
    <para>
Kalıtım yeterince kullanışlı olduğundan, kullanışlılığını sınırlayan tekil kısıtlar ve anahtarlar ile bütünleştirilmemiştir. Daha fazla bilgi için <productname>PostgreSQL</productname> 8.0 belgelerindeki <link xlink:href="http://www.postgresql.org/docs/8.0/static/ddl-inherit.html">Kalıtım</link> bölümüne bakınız.
    </para>
   </note>
  </section>
  <section xml:id="pgsql-tutorial-conclusion">
   <info>
    <title>Sonuç</title>
   </info>
   <para>
PostgreSQL'in bu eğitmende yeni SQL kullanıcılarına yönelik olanlar dışında, bahsedilmeyen daha bir çok özelliği mevcuttur. Bu özellikler hakkında daha ayrıntılı bilgiyi bu eğitmeni de içeren <link xlink:href="http://www.postgresql.org/docs/8.0/static/index.html"><productname>PostgreSQL</productname> 8.0 belgelerinde</link> bulabilirsiniz.
   </para>
   <para>
Daha fazla bilgiye ihtiyaç duyarsanız, <link xlink:href="http://www.postgresql.org">PostgreSQL web site</link>sinde yeterince kaynak bulabilirsiniz.
   </para>
  </section>
 </chapter>
</part>
