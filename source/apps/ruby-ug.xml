<?xml version="1.0" encoding="UTF-8"?>
<!-- ********************************************************************
         apps/ruby-ug.xml
     ******************************************************************** -->
<book xml:id="ruby-ug" xmlns="http://docbook.org/ns/docbook"
 xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:lang="tr">
 <?dbhtml dir="../uygulamalar/ruby"?>
 <info>
  <title>Ruby Kullanıcı Kılavuzu</title>
  <authorgroup>
   <author role="translator">
    <personname>
     <firstname>Pınar Yanardağ</firstname>
    </personname>
     <address>
      <link xlink:href="https://github.com/pinguar"/>
     </address>
   </author>
   <author>
    <personname>
     <firstname>Mark Slagell</firstname>
    </personname>
   </author>
  </authorgroup>
  <pubdate>22 Nisan 2003</pubdate>
  <revhistory>
   <revision>
    <revnumber>2.0</revnumber>
    <date>Aralık 2022</date>
    <authorinitials>TLBP</authorinitials>
    <revremark>Örnekler ve bağlantılar güncellendi.</revremark>
   </revision>
   <revision>
    <revnumber>1.0</revnumber>
    <date>Temmuz 2005</date>
    <authorinitials>PY</authorinitials>
    <revremark>Çevirinin ilk sürümü.</revremark>
   </revision>
   <revision>
    <revnumber>-</revnumber>
    <date>30 Mart 2003</date>
    <authorinitials>MS</authorinitials>
    <revremark>
     Özgün belge Japonca'dır. İngilizce sürümünü <link xlink:href="https://ruby-doc.org/docs/ruby-doc-bundle/UsersGuide/rg/"/> adresinde bulabilirsiniz.
    </revremark>
   </revision>
  </revhistory>
  <copyright>
   <year>2003</year>
   <holder>Mark Slagel - Özgün belge</holder>
  </copyright>
  <copyright>
   <year>2005</year>
   <holder>Pınar Yanardağ - Türkçe çeviri</holder>
  </copyright>
  <abstract>
   <para>
    Ruby, nesneye yönelik, kolay bir dildir. İlk başta tuhaf bir dil gibi görünse de, kolayca yazılıp okunmak için tasarlanmıştır. Bu kullanıcı kılavuzu, ruby'yi ilk defa kullanacaklara ruby'nin doğası hakkında fikir vermek amacıyla yazılmıştır, kesinlikle bir dil başvuru kılavuzu değildir.
   </para>
  </abstract>
  <legalnotice>
   <para>
    Bu belgenin, <emphasis>Ruby Kullanıcı Kılavuzu</emphasis> çevirisinin 1.0 sürümünün <emphasis role="bold">telif hakkı © 2005 <emphasis>Pınar Yanardağ</emphasis>'a</emphasis>, özgün İngilizce sürümünün  <emphasis role="bold">telif hakkı © 2003 <emphasis>Mark Slagel</emphasis>'a</emphasis> aittir. Bu belgeyi, Free Software Foundation tarafından yayınlanmış bulunan GNU Özgür Belgeleme Lisansının 1.2 ya da daha sonraki sürümünün koşullarına bağlı kalarak kopyalayabilir, dağıtabilir ve/veya değiştirebilirsiniz. Bu Lisansın bir kopyasını <link xlink:href="/licenses/gfdl.html">GNU Free Documentation License</link> başlığı altında bulabilirsiniz.
   </para>
   &notice.disc;
  </legalnotice>
 </info>
 <chapter xml:id="ruby-ug-whatis">
  <?dbhtml stop-chunking?>
  <title>Ruby Nedir?</title>
  <para>
   Ruby 'hızlı ve kolay', nesneye dayalı, yazılım geliştirmeye yarayan yorumlanan bir betik dilidir.
  </para>
  <para>
   Peki bu ne anlama gelmektedir?
  </para>
  <para>Yorumlanan bir betik dili:</para>
  <simplelist>
   <member>İşletim sistemi çağrılarını doğrudan yapabilme yeteneği</member>
   <member>Güçlü dizge işlemleri ve düzenli ifadeler</member>
   <member>Geliştirme sırasına anında geribesleme</member>
  </simplelist>
  <para>Kolay ve hızlı:</para>
  <simplelist>
   <member>Değişken bildirimleri gerekmez</member>
   <member>Değişken türleri yoktur</member>
   <member>Sözdizimi basit ve tutarlıdır</member>
   <member>Bellek yönetimi otomatiktir</member>
  </simplelist>
  <para>Nesneye dayalı:</para>
  <simplelist>
   <member>Herşey birer nesnedir</member>
   <member>Sınıflar, kalıtım, yöntemler, vs.</member>
   <member>Tekil yöntemler</member>
   <member>Modüllerle çalışılabilir</member>
   <member>Yineleyiciler ve Kapsayıcılar</member>
  </simplelist>
  <para>Ayrıca:</para>
  <simplelist>
   <member>Çok hassasiyetli tamsayılar</member>
   <member>İstisna işleme modeli</member>
   <member>Dinamik yükleme</member>
   <member>Evreler</member>
  </simplelist>
  <para>
   Yukardaki kavramların bazıları yabancıysanız, endişelenmeyin, okumaya devam edin. Ruby dili çabuk ve kolay öğrenilir.
  </para>
 </chapter>
 <chapter xml:id="ruby-ug-intro">
  <?dbhtml stop-chunking?>
  <title>Giriş</title>
  <para>
   Öncelikle sisteminizde Ruby'nin kurulu olup olmadığına bakalım.
   Kabuk istemcisinden (burada "<prompt>$</prompt>" ile temsil edilmiştir o yüzden <prompt>$</prompt> işaretini yazmanıza gerek yok) aşağıdaki kodu yazalım:
  </para>
   <screen><prompt>$</prompt> <command>ruby -v</command>
</screen>
  <para>
   (<command>-v</command> ruby'nin sürüm bilgilerini yazmasını sağlar) ve sonra da <literal>Enter</literal> tuşuna basalım.  Eğer sisteminizde Ruby kuruluysa aşağıdakine benzer bir satır görmeniz gerekecek:
  </para>
   <screen>
ruby 2.7.4p191 (2021-07-07 revision a21a3b7d23) [x86_64-linux-gnu]
</screen>
  <para>
   Eğer Ruby yüklü değilse, sistem yöneticinizle görüşebilir ya da kendiniz kurabilirsiniz.
  </para>
  <para>
   Artık Ruby ile oynamaya başlayabiliriz. <command>-e</command> seçeneği ile Ruby yazılımlarını doğrudan komut satırına yerleştirebilirsiniz:
  </para>
   <screen>
<prompt>$</prompt> <command>ruby -e 'print "merhaba dunya\n"'</command>
merhaba dunya
</screen>
  <para>
   Daha uzlaşımsal olarak bir Ruby yazılımı bir dosyada saklanabilir.
  </para>
   <screen>
<prompt>$</prompt> <command>cat &gt; test.rb</command>
print "merhaba dunya\n"
^D
<prompt>$</prompt> <command>cat test.rb</command>
print "merhaba dunya\n"
<prompt>$</prompt> <command>ruby test.rb</command>
merhaba dunya
</screen>
  <para>
   <command>^D</command>, <literal>control-D</literal>'yi ifade eder. Yukarıdakiler sadece UNIX ve türevleri için geçerlidir. Eğer DOS kullanıyorsanız şunu deneyin:
  </para>
  <screen>
C:\ruby&gt; copy con: test.rb
print "merhaba dunya\n"
^Z
C:\ruby&gt; type test.rb
print "merhaba dunya\n"
C:\ruby&gt; ruby test.rb
merhaba dunya
</screen>
  <para>
   Daha kapsamlı yazılımlar geliştirirken, muhtemelen gerçek bir metin düzenleyiciye ihtiyaç duyacaksınız!
  </para>
  <para>
   Bazen şaşırtıcı biçimde karmaşık ve kullanışlı yazılımlar komut satırına sığabilecek minyatür yazılımlarla yapılabilmektedir. Örneğin aşağıdaki yazılım, çalışılan dizindeki tüm C kaynak ve başlık dosyalarında bulunan <command>foo</command>'ları <command>bar</command> ile değiştirir ve orjinal dosyaların <filename>.bak</filename> uzantısıyla yedeklerini alır.
  </para>
  <screen>
% <command>ruby -i.bak -pe 'sub "foo", "bar"' *.[ch]</command>
</screen>
  <para>
   Bu yazılım UNIX'in <command>cat</command> komutu gibi çalışır (ama <command>cat</command>'ten daha yavaş çalışır):
  </para>
  <screen>
<prompt>$</prompt> <command>ruby -pe 0 &lt;dosya&gt;</command>
</screen>
 </chapter>

 <chapter xml:id="ruby-ug-examples">
  <?dbhtml stop-chunking?>
  <title>Basit Örnekler</title>
  <para>
   Şimdi faktöriyel hesabı yapan basit bir işlev yazalım. <command>Faktöriyel</command>'in matematiksel tanımı şöyledir:
  </para>
   <literallayout class="monospaced">
    n! = 1                (n==0 ise)
       = n * (n-1)!       (aksi taktirde)
</literallayout>
  <para>
   Ruby'de bunu aşağıdaki gibi yazabiliriz:
  </para>
   <screen>
def fact(n)
  if n == 0
    1
  else
    n * fact(n-1)
  end
end
</screen>
  <para>
   Tekrarlanan <command>end</command> deyiminin varlığını fark etmiş olmalısınız. Sırf bu yüzden Ruby "Algol benzeri" olarak anılır. (Aslında Ruby'nin sözdizimi Eiffel dilini daha çok andırmaktadır.) Ayrıca <command>return</command> deyiminin eksikliğini de hissetmiş olmalısınız. Bu deyim Ruby için gereksizdir çünkü bir Ruby işlevde değerlendirdiği en son şeyi döndürür. <command>return</command> deyimi kullanılabilir ancak gereksizdir.
   </para>
  <para>
   Şimdi faktöriyel işlevimizi deneyelim. Ekleyeceğimiz satır, bize çalışan bir yazılım sunacaktır:
  </para>
   <screen>
# Sayının faktöriyelini bulan yazılım
# fact.rb olarak kaydedin

def fact(n)
  if n == 0
    1
  else
    n * fact(n-1)
  end
end

print fact(ARGV[0].to_i), "\n"
</screen>
  <para>
   Burada <command>ARGV</command> komut satırı girdilerini içeren bir dizidir ve <command>to_i</command> alınan bir dizgeyi tamsayıya çevirmeye yarar.
  </para>
  <screen>
<prompt>$</prompt> <command>ruby fact.rb 1</command>
1
<prompt>$</prompt> <command>ruby fact.rb 5</command>
120
</screen>
  <para>
   Acaba girdi olarak 40 versek çalışır mı? Muhtemelen hesap makineniz taşma hatası verecektir...
  </para>
   <screen>
<prompt>$</prompt> <command>ruby fact.rb 40</command>
815915283247897734345611269596115894272000000000
</screen>
  <para>
   Bu çalışır, üstelik Ruby makinenizin belleğinin izin verdiği kadar büyük tamsayıyla da çalışabilir. 400 için aşağıdaki gibi bir çıktı alacaksınız:
  </para>
  <screen>
<prompt>$</prompt> <command>ruby fact.rb 400</command>
64034522846623895262347970319503005850702583026002959458684
44594280239716918683143627847864746326467629435057503585681
08482981628835174352289619886468029979373416541508381624264
61942352307046244325015114448670890662773914918117331955996
44070954967134529047702032243491121079759328079510154537266
72516278778900093497637657103263503315339653498683868313393
52024373788157786791506311858702618270169819740062983025308
59129834616227230455833952075961150530223608681043329725519
48526744322324386699484224042325998055516106359423769613992
31917134063858996537970147827206606320217379472010321356624
61380907794230459736069956759583609615871512991382228657857
95493616176544804532220078258184008484364155912294542753848
03558374518022675900061399560145595206127211192918105032491
00800000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000
</screen>
  <para>
   Sonucun doğruluğunu sınayamayız ama öyle olması gerekiyor <literal>:)</literal>.
  </para>
  <sect1><title>Girdi/Değerlendirme döngüsü</title>
   <para>
    Eğer Ruby'yi hiçbir girdi yazmadan çağırırsanız, komutları standart girdiden alır ve girdinin bitiminde komutları çalıştırır:
   </para>
   <screen>
<prompt>$</prompt> <command>ruby</command>
print "merhaba dunya\n"
print "hoscakal dunya\n"
^D
merhaba dunya
hoscakal dunya
</screen>
   <para>
    Ruby, <filename>eval.rb</filename> adında bir araç ile gelir. Bu, ruby kodunuzu etkileşimli olarak klavyeden alan ve yazdıklarınızı gösteren bir araçtır. Bu öğreticinin devamında sıkça kullanacağız.
   </para>
   <para>
    Eğer ANSI uyumlu bir uçbirimle çalışıyorsanız<footnote><para>Unix altında çalışıyorsanız zaten uçbirim ANSI uyumludur. Uçbirim artalan rengini siyah seçerseniz <filename>eval.rb</filename> renklendirmesi ile sorun yaşamazsınız. DOS altında bunu sağlamak için ANSI.SYS veya ANSI.COM yüklemelisiniz.</para></footnote>, ek olarak girintileme yapabilen, kodu renklendirebilen ve uyarılar veren <link xlink:href="http://www.ruby-doc.org/docs/UsersGuide/rg/eval.rb">gelişmiş eval.rb</link>'yi kullanmalısınız. Aksi takdirde, ruby dağıtımının <filename>sample</filename> dizininde bulunan ve ANSI uyumluluğu gerektirmeyen sürümünü kullanabilirsiniz. Kısa bir <filename>eval.rb</filename> oturumu:
   </para>
   <screen class="eval">
$ ruby eval.rb
ruby&gt; <emphasis class="evalinput">puts "Merhaba dünya.\n"</emphasis>
Merhaba dünya.
   <emphasis class="evaloutput">nil</emphasis>
ruby&gt; <emphasis class="evalinput">exit</emphasis>
</screen>
   <para>
    <literal>Merhaba dünya</literal>, <literal>puts</literal> ile çıktılandı. Sonraki satırdaki <literal>nil</literal> ise son değerlemenin sonucunu göstermektedir; ruby, deyimlerle ifadeler arasında bir ayrım yapmaz, yani kod parçalarının değerlendirilmesi temel olarak kodun icra edilmesidir. Burada <literal>nil</literal>, <literal>print</literal>'in anlamlı bir değer döndürmediğini ifade etmektedir. Son olarak, <literal>exit</literal> yazarak yorumlayıcı döngüsünü sonlandırıyoruz.
   </para>
   <para>
    Bu kılavuzun devamında <prompt>ruby&gt;</prompt> bir <filename>eval.rb</filename> oturumunun girdi istemi olarak kullanılmış olacaktır.
   </para>
  </sect1>
 </chapter>
 <chapter xml:id="ruby-ug-strings">
  <?dbhtml stop-chunking?>
  <title>Dizgeler</title>
  <para>
   Ruby'de dizgelerle sayısal bir veriymiş gibi işlem yapabilirsiniz. Bir dizge çift ("...") ya da tek ('...') tırnaklı olabilir.
  </para>
  <screen class="eval">
ruby&gt; <emphasis class="evalinput">"abc"</emphasis>
   <emphasis class="evaloutput">"abc"</emphasis>
ruby&gt; <emphasis class="evalinput">'abc'</emphasis>
   <emphasis class="evaloutput">"abc"</emphasis>
</screen>
  <para>
   Bazı durumlarda çift ve tek tırnak farklı işlevler görür. Çift tırnaklı bir dizge tersbölü öncelemeli karakterleri kullanmayı ve <command>#{}</command> kullanan gömülü ifadeleri çalıştırmayı mümkün kılar. Halbuki, tek tırnaklı dizgelerle bunlar yapılamaz: ne görürseniz onu alırsınız. Örneğin:
  </para>
   <screen class="eval">
ruby&gt; <emphasis class="evalinput">print "a\nb\nc","\n"</emphasis>
a
b
c
   <emphasis class="evaloutput">nil</emphasis>
ruby&gt; <emphasis class="evalinput">print 'a\nb\n',"\n"</emphasis>
a\nb\nc
   <emphasis class="evaloutput">nil</emphasis>
ruby&gt; <emphasis class="evalinput">"\n"</emphasis>
   <emphasis class="evaloutput">"\n"</emphasis>
ruby&gt; <emphasis class="evalinput">'\n'</emphasis>
   <emphasis class="evaloutput">"\\n"</emphasis>
ruby&gt; <emphasis class="evalinput">"\001"</emphasis>
   <emphasis class="evaloutput">"\001"</emphasis>
ruby&gt; <emphasis class="evalinput">'\001'</emphasis>
   <emphasis class="evaloutput">"\\001"</emphasis>
ruby&gt; <emphasis class="evalinput">"abcd #{5*3} efg"</emphasis>
   <emphasis class="evaloutput">"abcd 15 efg"</emphasis>
ruby&gt; <emphasis class="evalinput">var = " abc "</emphasis>
   <emphasis class="evaloutput">" abc "</emphasis>
ruby&gt; <emphasis class="evalinput">"1234#{var}5678"</emphasis>
   <emphasis class="evaloutput">"1234 abc 5678"</emphasis>
</screen>
  <para>
   Ruby'nin dizge işlemleri C'ye kıyasla daha esnek ve şıktır.Örneğin <command>+</command> ile iki dizgeyi birleştirebilirsiniz ya da <command>*</command> ile bir dizgeyi birçok kez tekrar ettirebirsiniz:
  </para>
   <screen class="eval">
ruby&gt; <emphasis class="evalinput">"foo" + "bar"</emphasis>
   <emphasis class="evaloutput">"foobar"</emphasis>
ruby&gt; <emphasis class="evalinput">"foo" * 2</emphasis>
   <emphasis class="evaloutput">"foofoo"</emphasis>
</screen>
  <para>
   Dizgeleri birleştirme işi C'de, doğrudan bellek yönetimi nedeniyle oldukça yakışıksızdır:
  </para>
  <screen>
char *s = malloc(strlen(s1)+strlen(s2)+1);
strcpy(s, s1);
strcat(s, s2);
/* ... */
free(s);
</screen>
  <para>
   Ruby kullandığımız için dizgelere herhangi bir alan ayırmamıza gerek yok. Bellek yönetimi açısından tamamen özgürüz.
  </para>
  <para>
   Aşağıda dizgelerle yapabileceğiniz birkaç örnek var:
  </para>
  <example><title>Birleştirme</title>
   <screen class="eval">
ruby&gt; <emphasis class="evalinput">word = "fo" + "o"</emphasis>
   <emphasis class="evaloutput">"foo"</emphasis>
</screen>
  </example>
  <example><title>Tekrarlatma</title>
   <screen class="eval">
ruby&gt; <emphasis class="evalinput">word = word * 2</emphasis>
   <emphasis class="evaloutput">"foofoo"</emphasis>
</screen>
  </example>
  <example><title>Karakterler seçimi</title>
   <para>
    Ruby'de karakterlerin tamsayı olduğuna dikkat edelim:
   </para>
   <screen class="eval">
ruby&gt; <emphasis class="evalinput">word[0]</emphasis>
   <emphasis class="evaloutput">102</emphasis>            # 102, `f' harfinin ASCII kodudur.
ruby&gt; <emphasis class="evalinput">word[-1]</emphasis>
   <emphasis class="evaloutput">111</emphasis>            # 111 `o' harfinin ASCII kodudur.
</screen>
   <para>
    (Negatif indisler dizgenin başlangıcı yerine sonundan itibaren konumlanır.)
   </para>
  </example>
  <example><title>Altdizge seçimi</title>
  <screen class="eval">
ruby&gt; <emphasis class="evalinput">herb = "parsley"</emphasis>
   <emphasis class="evaloutput">"parsley"</emphasis>
ruby&gt; <emphasis class="evalinput">herb[0,1]</emphasis>
   <emphasis class="evaloutput">"p"</emphasis>
ruby&gt; <emphasis class="evalinput">herb[-2,2]</emphasis>
   <emphasis class="evaloutput">"ey"</emphasis>
ruby&gt; <emphasis class="evalinput">herb[0..3]</emphasis>
   <emphasis class="evaloutput">"pars"</emphasis>
ruby&gt; <emphasis class="evalinput">herb[-5..-2]</emphasis>
   <emphasis class="evaloutput">"rsle"</emphasis>
</screen>
  </example>
  <example><title>Aynılığın sınanması</title>
   <screen class="eval">
ruby&gt; <emphasis class="evalinput">"foo" == "foo"</emphasis>
   <emphasis class="evaloutput">true</emphasis>
ruby&gt; <emphasis class="evalinput">"foo" == "bar"</emphasis>
   <emphasis class="evaloutput">false</emphasis>
</screen>
   <note>
    <para>
     ruby-1.0 sürümünde yukarıdaki sonuçlar büyük harflidir (TRUE gibi).
    </para>
   </note>
  </example>
  <para>
   Şimdi bu özelliklerin bazılarını hayata geçirelim: Bulmacamız bir "kelimeyi bil" bulmacası ama sanırım "bulmaca" kelimesi fazla mütevazi oldu <command>;)</command>
  </para>
  <screen>
# guess.rb olarak kaydedin
words = ['kestane', 'gurgen', 'palamut']
secret = words[rand(3)]

print "tahmin et? "
while guess = STDIN.gets
  guess.chop!
  if guess == secret
    print "Bildin!\n"
    break
  else
    print "Üzgünüm kaybettin.\n"
  end
  print "tahmin et? "
end
print "Kelime ", secret, ".\n"
</screen>
  <para>
   Şimdilik kodun ayrıntıları hakkında fazla kafa yormayalım. Aşağıda yazılımın nasıl çalışması gerektiği görülüyor:
  </para>
   <screen>
<prompt>$</prompt> <command>ruby guess.rb</command>
tahmin et? kestane
Üzgünüm kaybettin.
tahmin et? gurgen
Üzgünüm kaybettin.
tahmin et? ^D
Kelime palamut.
</screen>
  <para>
   (1/3 olasılığa karşı biraz daha iyi yapmalıydım...)
  </para>
 </chapter>
 <chapter xml:id="ruby-ug-regex">
  <?dbhtml stop-chunking?>
  <title>Düzenli İfadeler</title>
  <para>
   Şimdi daha ilginç bir yazılım geliştirelim. Bu sefer bir dizgenin verilen bir <wordasword>şablona</wordasword> uyup uymadığını araştıralım:
  </para>
  <para>
   Bu şablonlar özel anlamları olan bazı karakterler ve karakter birleşimlerinden oluşur:
  </para>
  <table>
   <title>Düzenli ifade işleçleri ve anlamları</title>
   <tgroup cols="2" align="left" colsep="1" rowsep="1">
    <colspec colwidth=".1"/>
    <colspec colwidth=".9"/>
    <tbody>
     <row>
      <entry><command>[]</command></entry>
      <entry>
       aralık belirtimi (Örn, <literal>[a-z]</literal>, <literal>a</literal> ile <literal>z</literal> arasındaki bir harfi belirtir.)
      </entry>
     </row>
     <row>
      <entry><command>\w</command></entry>
      <entry>
       harf ya da rakam; <literal>[0-9A-Za-z]</literal> ile aynı
      </entry>
     </row>
     <row>
      <entry><command>\W</command></entry>
      <entry>ne harf ne de rakam</entry>
     </row>
     <row>
      <entry><command>\s</command></entry>
      <entry>
       boşluk karakteri; <literal>[ \t\n\r\f]</literal> ile aynı
      </entry>
     </row>
     <row>
      <entry><command>\S</command></entry>
      <entry>boşluklar dışında herhangi bir karakter</entry>
     </row>
     <row>
      <entry><command>\d</command></entry>
      <entry>rakam;  <literal>[0-9]</literal> ile aynı</entry>
     </row>
     <row>
      <entry><command>\D</command></entry>
      <entry>rakamlar dışında herhangi bir karakter</entry>
     </row>
     <row>
      <entry><command>\b</command></entry>
      <entry>
       tersbölü (0x08) (sadece herhangi bir aralık belirtilmişse)
      </entry>
     </row>
     <row>
      <entry><command>\b</command></entry>
      <entry>
       kelime içi sınır belirtimi (aralık belirtiminin dışındayken)
      </entry>
     </row>
     <row>
      <entry><command>\B</command></entry>
      <entry>kelime dışı sınır belirtimi</entry>
     </row>
     <row>
      <entry><command>*</command></entry>
      <entry>
       öncelediği ifadeyi sıfır ya da daha fazla tekrarlar
      </entry>
     </row>
     <row>
      <entry><command>+</command></entry>
      <entry>
       öncelediği ifadeyi bir ya da daha fazla tekrarlar
      </entry>
     </row>
     <row>
      <entry><command>{m,n}</command></entry>
      <entry>
       öncelediği ifadeyi en az m en çok n kez tekrarlar
      </entry>
     </row>
     <row>
      <entry><command>?</command></entry>
      <entry>
       öncelediği ifadeyi en fazla bir kere tekrarlar; <literal>{0,1}</literal> ile aynı
      </entry>
     </row>
     <row>
      <entry><command>|</command></entry>
      <entry>önündeki veya ardındaki ifade eşleşebilir</entry>
     </row>
     <row>
      <entry><command>()</command></entry>
      <entry>gruplama işleci</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  <para>
   Bu ilginç lügat genelde <wordasword>düzenli ifadeler</wordasword> olarak anılır. Ruby'de, Perl'de de olduğu gibi çift tırnak koymak yerine ters bölü işareti kullanılır. Eğer daha önce düzenli ifadelerle karşılaşmadıysanız muhtemelen <emphasis>düzenli</emphasis> hiçbir şey göremeyeceksiniz ancak alışmak için biraz zamana ihtiyacınız olduğunu unutmayın. Düzenli ifadeler, metin dizgeleri üzerinde arama, eşleştirme ve bu gibi diğer işlerle uğraşırken sizi baş ağrısından (ve satırlarca koddan) kurtaran gözle görülür bir güce sahiptir.
  </para>
  <para>
   Örneğin aşağıdaki tanıma uyan bir dizge aradığımızı farzedelim:
   "Küçük f harfiyle başlayan, ardından bir büyük harf gelen bundan sonra küçük harf haricinde herhangi bir karakterle devam eden" bir dizge.
   Eğer deneyimli bir C yazılımcısıysanız muhtemelen şimdiden kafanızca binlerce satır kod yazmıştınız, öyle değil mi? Kabul edin, kendinize güçlükle yardım edebilirsiniz. Ancak Ruby'de dizgeyi sadece  şu düzenli ifadeyle sınamanız yeterli olacaktır: <command>/^f[A-Z](^[a-z])*$/</command>.
  </para>
  <para>
   Açılı ayraçlar arasında onaltılık sayıya ne dersiniz? Hiç sorun değil.
  </para>
   <screen class="eval">
ruby&gt;<emphasis class="evalinput">def chab(s)</emphasis>   # "açılı ayraçlar onaltılık sayı içerir"
    |    <emphasis class="evalinput">(s =~ /&lt;0(x|X)(\d|[a-f]|[A-F])+&gt;/) != nil</emphasis>
    | <emphasis class="evalinput">end</emphasis>
   <emphasis class="evaloutput">nil</emphasis>
ruby&gt; <emphasis class="evalinput"> chab "Bu değil."</emphasis>
   <emphasis class="evaloutput">false</emphasis>
ruby&gt; <emphasis class="evalinput"> chab "Belki bu? {0x35}"</emphasis>    # kaşlı ayraçlar kullanılmamalıydı
   <emphasis class="evaloutput">false</emphasis>
ruby&gt; <emphasis class="evalinput"> chab "Ya da bu? &lt;0x38z7e&gt;"</emphasis>    # onaltılık sayı değil
   <emphasis class="evaloutput">false</emphasis>
ruby&gt; <emphasis class="evalinput"> chab "Tamam, bu: &lt;0xfc0004&gt;."</emphasis>
   <emphasis class="evaloutput">true</emphasis>
</screen>
  <para>
   Düzenli ifadeler başlangıçta alengirli gibi gözükse de kısa süre içinde istediğinizi yapabilme konusunda yol katedeceksiniz.
  </para>
  <para>
   Aşağıda düzenli ifadeleri anlamanıza yarayacak küçük bir yazılım bulunuyor. <filename>regx.rb</filename> olarak kaydedin ve komut satırına <command>ruby regx.rb</command> yazarak çalıştırın.
  </para>
   <screen>
#ANSI uçbirim gerektirir!

st = "\033[7m"
en = "\033[m"

while TRUE
  print "str&gt; "
  STDOUT.flush
  str = gets
  break if not str
  str.chop!
  print "pat&gt; "
  STDOUT.flush
  re = gets
  break if not re
  re.chop!
  str.gsub! re, "#{st}\\&amp;#{en}"
  print str, "\n"
end
print "\n"
</screen>
  <para>
   Yazılım bir tanesi dizge diğeri de düzenli ifade olmak üzere iki girdi alır. Dizge verilen düzenli ifade ile sınanır ve bütün uyuşan sonuçlar listelenir. Şu an ayrıntılara ilgilenmeyin, bu kodun analizini daha sonra yapacağız.
  </para>
   <screen class="eval">
str&gt; foobar
pat&gt; ^fo+
<emphasis class="regxoutput">foo</emphasis>bar
~~~
</screen>
  <para>
   Programın çıktısında gördüğünüz <literal>~~~</literal> ile işaretli parça çıktıda artalan ve önalan renkleri yer değiştirmiş olarak çıktılanır.
  </para>
  <para>
   Bir kaç girdi daha deneyelim.
  </para>
   <screen class="eval">
str&gt; abc012dbcd555
pat&gt; \d
abc<emphasis class="regxoutput">012</emphasis>dbcd<emphasis class="regxoutput">555</emphasis>
   ~~~    ~~~
</screen>
  <para>
   Eğer şaşırdıysanız sayfanın başındaki tabloya tekrar göz atabilirsiniz: <command>\d</command>'nin <command>d</command> karakteriyle hiçbir bağlantısı yoktur, sadece bir rakamı eşleştirmekte kullanılır.
  </para>
  <para>
   Eğer istediğimiz kriterlere uygun birden fazla yol varsa ne olur?
  </para>
   <screen class="eval">
str&gt; foozboozer
pat&gt; f.*z
<emphasis class="regxoutput">foozbooz</emphasis>er
~~~~~~~~
</screen>
  <para>
   Düzenli ifadeler olabilecek en uzun dizgeyi döndürdüğü için <command>fooz</command>'un yerine <command>foozbooz</command> eşleştirildi.
  </para>
  <para>
   Aşağıda iki nokta üstüste işaretiyle sınırlandırılmış bir zaman alanı bulunuyor:
  </para>
   <screen class="eval">
str&gt; Wed Feb  7 08:58:04 JST 1996
pat&gt; [0-9]+:[0-9]+(:[0-9]+)?
Wed Feb  7 <emphasis class="regxoutput">08:58:04</emphasis>  JST 1996
           ~~~~~~~~
</screen>
  <para>
   "<command>=~</command>" işleci bulduğu dizgenin konumunu döndüren, aksi halde <command>nil</command> döndüren düzenli ifadedir.
  </para>
   <screen class="eval">
ruby&gt; <emphasis class="evalinput">"abcdef" =~ /d/</emphasis>
   <emphasis class="evaloutput">3</emphasis>
ruby&gt; <emphasis class="evalinput">"aaaaaa" =~ /d/</emphasis>
   <emphasis class="evaloutput">nil</emphasis>
</screen>
 </chapter>
 <chapter xml:id="ruby-ug-arrays">
  <?dbhtml stop-chunking?>
  <title>Diziler</title>
  <para>
   Ruby'de köşeli ayraçlar <command>[]</command> arasına elemanları yazarak ve virgüller yardımıyla ayırarak bir dizi oluşturabilirsiniz. Ruby'de diziler farklı nesne türlerini ayırdedebilecek niteliktedir.
  </para>
   <screen class="eval">
ruby&gt; <emphasis class="evalinput">ary = [1, 2, "3"]</emphasis>
   <emphasis class="evaloutput">[1, 2, "3"]</emphasis>
</screen>
  <para>
   Diziler de aynı dizgeler gibi birleştirilebilir ya da tekrar edilebilir.
  </para>
   <screen class="eval">
ruby&gt; <emphasis class="evalinput">ary + ["foo", "bar"]</emphasis>
   <emphasis class="evaloutput">[1, 2, "3", "foo", "bar"]</emphasis>
ruby&gt; <emphasis class="evalinput">ary * 2</emphasis>
   <emphasis class="evaloutput">[1, 2, "3", 1, 2, "3"]</emphasis>
</screen>
  <para>
   Dizinin herhangi bir elemanına ulaşmak için indisleri kullanabiliriz.
  </para>
  <screen class="eval">
ruby&gt; <emphasis class="evalinput">ary[0]</emphasis>
   <emphasis class="evaloutput">1</emphasis>
ruby&gt; <emphasis class="evalinput">ary[0,2]</emphasis>
   <emphasis class="evaloutput">[1, 2]</emphasis>
ruby&gt; <emphasis class="evalinput">ary[0..1]</emphasis>
   <emphasis class="evaloutput">[1, 2]</emphasis>
ruby&gt; <emphasis class="evalinput">ary[-2]</emphasis>
   <emphasis class="evaloutput">2</emphasis>
ruby&gt; <emphasis class="evalinput">ary[-2,2]</emphasis>
   <emphasis class="evaloutput">[2, "3"]</emphasis>
ruby&gt; <emphasis class="evalinput">ary[-2..-1]</emphasis>
   <emphasis class="evaloutput">[2, "3"]</emphasis>
</screen>
  <para>
   (Negatif indisler dizinin sonundan başlanmasını sağlar.)
  </para>
  <para>
   Diziler <command>join</command>  kullanılarak dizgelere ve dizgeler <command>split</command> kullanılarak dizilere dönüştürülebilirler.
  </para>
  <screen class="eval">
ruby&gt; <emphasis class="evalinput">str = ary.join(":")</emphasis>
   <emphasis class="evaloutput">"1:2:3"</emphasis>
ruby&gt; <emphasis class="evalinput">str.split(":")</emphasis>
   <emphasis class="evaloutput">["1", "2", "3"]</emphasis>
</screen>
  <sect1 xml:id="ruby-ug-hashs">
   <title>Aşlar</title>
  <para>
   Aş (hash), elemanlarına indisler yerine herhangi bir değer olabilen  <literal>anahtarlar</literal> yardımıyla erişilebilen özelleştirilmiş dizilerdir. Böyle dizilere <wordasword>aş</wordasword> dendiği gibi <wordasword>ilişkisel dizi</wordasword> de denir; biz ruby dünyasında aş deyimini tercih ederiz. Bir aş kaşlı ayraçlar arasına yazılarak oluşturulabilir. Dizilerde herhangi bir elemana ulaşmak için indisleri kullandığımız gibi, aşlarda elemana ulaşmak için anahtarları kullanırız.
  </para>
  <screen class="eval">
ruby&gt; <emphasis class="evalinput"> h = {1 =&gt; 2, "2" =&gt; "4"}</emphasis>
   <emphasis class="evaloutput">{1=&gt;2, "2"=&gt;"4"}</emphasis>
ruby&gt; <emphasis class="evalinput">h[1]</emphasis>
   <emphasis class="evaloutput">2</emphasis>
ruby&gt; <emphasis class="evalinput">h["2"]</emphasis>
   <emphasis class="evaloutput">"4"</emphasis>
ruby&gt; <emphasis class="evalinput">h[5]</emphasis>
   <emphasis class="evaloutput">nil</emphasis>
ruby&gt; <emphasis class="evalinput">h[5] = 10</emphasis>     # değer ekleme
   <emphasis class="evaloutput">10</emphasis>
ruby&gt; <emphasis class="evalinput">h</emphasis>
   <emphasis class="evaloutput">{5=&gt;10, 1=&gt;2, "2"=&gt;"4"}</emphasis>
ruby&gt; <emphasis class="evalinput">h.delete 1</emphasis>   # değer silme
   <emphasis class="evaloutput">2</emphasis>
ruby&gt; <emphasis class="evalinput">h[1]</emphasis>
   <emphasis class="evaloutput">nil</emphasis>
ruby&gt; <emphasis class="evalinput">h</emphasis>
   <emphasis class="evaloutput">{5=&gt;10, "2"=&gt;"4"}</emphasis>
</screen>
  </sect1>
 </chapter>
 <chapter xml:id="ruby-ug-b2examples">
  <?dbhtml stop-chunking?>
  <title>Örneklere Dönüş</title>
  <para>
   Şimdi eski örneklere tekrar göz atalım.
  </para>
  <para>
   Aşağıdakini daha önce  <xref linkend="ruby-ug-examples"/> kısmında görmüştük.
  </para>
   <screen>
def fact(n)
  if n == 0
    1
  else
    n * fact(n-1)
  end
end
print fact(ARGV[0].to_i), "\n"
</screen>
  <para>
   Bu bizim ilk örneğimiz olduğu için her satırı teker teker açıklayalım.
  </para>
  <sect1 xml:id="ruby-ug-factorials">
   <title>Faktöriyeller</title>
   <screen>def fact(n)</screen>
   <para>
    İlk satırda bir işlev (ya da daha özel olarak bir <wordasword>yöntem</wordasword>; yöntemin ne olduğunu ileriki kısımlarda göreceğiz) tanımlamak için <command>def</command> deyimini kullanıyoruz. Burada işlevimiz <function>fact</function>'ın <literal>n</literal> adında tek bir bağımsız değişken aldığını görüyoruz.
   </para>
   <screen>if n == 0</screen>
   <para>
    <command>if</command> bir denetim deyimidir. Eğer koşul sağlanıyorsa onu takip eden kod değerlendirilir, aksi taktide <command>else</command> kısmına geçilir.
   </para>
   <screen>1</screen>
   <para>
    Eğer koşul sağlandıysa <command>if</command>'in değeri 1 olacaktr.
   </para>
   <screen>else</screen>
   <para>
    Sağlanmadıysa, bu deyimle başlayan <command>end</command> ile biten kod parçası değerlendirilir.
   </para>
   <screen>n * fact(n-1)</screen>
   <para>
    Yani, eğer koşul sağlanmamışsa sonuç <command>n</command> kere <command>fact(n-1)</command> olacaktır.
   </para>
   <screen>end</screen>
   <para>
    İlk <command>end</command>, <command>if</command> deyimini kapatmak için kullanılır.
   </para>
   <screen>end</screen>
   <para>
    İkinci <command>end</command> <command>def</command> ifadesini kapatmak için kullanılır.
   </para>
   <screen>print fact(ARGV[0].to_i), "\n"</screen>
   <para>
    Bu bizim komut satırından <function>fact()</function> işlevini çalıştırmamızı ve sonuçları ekranda görmemizi sağlar.
   </para>
   <para>
    <command>ARGV</command> komut satırı girdilerini içeren özel bir dizidir. <command>ARGV</command> dizisinin tüm elemanları dizgeler olduğu için, <command>to_i</command> yöntemiyle tamsayıya dönüştürmek zorundayız. Ruby Perl'deki gibi dizgeleri tamsayılara kendiliğinden dönüştürmez.
   </para>
   <para>
    Hmmm... Eğer bu yazılıma negatif bir sayı girersek ne olur? Sorunu görebildiniz mi? Peki düzeltebilir misiniz?
   </para>
  </sect1>
  <sect1><title>Dizgeler</title>
   <para>
    <xref linkend="ruby-ug-strings"/> bölümündeki bulmaca örneğimizi tekrar inceleyelim. Bu sefer biraz daha uzun, kolaylık açısından satırları numaralandırdık.
   </para>
   <screen>
1   words = ['kestane', 'gurgen', 'palamut']
2   secret = words[rand(3)]
3
4   print "tahmin et? "
5   while guess = STDIN.gets
6     guess.chop!
7     if guess == secret
8       print "Bildin!\n"
9       break
10    else
11      puts "Üzgünüm kaybettin.\n"
12    end
13    print "tahmin et? "
14  end
15  puts "Kelime ", secret, ".\n"
</screen>
   <para>
    Bu yazılımda yeni bir denetim yapısı gördük: <command>while</command>.
    Verilen koşul doğru olduğu sürece <command>while</command> ve <command>end</command> arasındaki kod tekrar tekrar çalıştırılacaktır.
   </para>
   <para>
    2. satırdaki <function>rand(3)</function> işlevi 0 ile 2 arasında rastgele sayı üretir. Bu rastgele sayı <literal>words</literal> dizisinin elemanlarından birini çıkarmak için kullanılır.
   </para>
   <para>
    5. satırda <function>STDIN.gets</function> yöntemiyle standart girdiden bir satır okuduk. Eğer satırı alırken <literal>EOF</literal> (end of file) karakterine rastlanırsa <function>gets</function> işlevi <command>nil</command> değerini döndürecektir. <command>while</command> ile ilişkilendirilmiş kod <literal>^D</literal> (ya da DOS altında ^Z) görene kadar tekrarlanacaktır.
   </para>
   <para>
    6. satırdaki <function>guess.chop!</function> işlevi <literal>guess</literal> değişkeninin sonundaki satırsonu karakterini temizlemeye yarar.
   </para>
   <para>
    15. satırda gizli kelimeyi yazdırıyoruz. Bunu üç bağımsız değişken ile birlikte bir yazdırma deyimi olarak kullandık (birbiri ardına yazdırılarak) ancak bunu daha verimli hale getirmek için <function>secret</function> yerine bir tek bağımsız değişken alan <function>#(secret)</function> yöntemini tanımlayabilirdik:
   </para>
   <screen>puts "Kelime #{secret}.\n"   </screen>
   <para>
    Birçok yazılımcı, bu yolun çıktı vermek için daha açık olduğunu düşünürler. Tek bir dizge oluşturur ve bu dizgeyi <command>puts</command>'a tek bir bağımsız değişken gibi sunar.
   </para>
   <para>
    Standart betik çıktısında <command>puts</command> kullanma düşüncesini işledik, ancak bu betik 4. ve 13. satırlarda <command>print</command>'i de kullanır. Bu ikisi aynı şey değildir. <command>print</command> dizgeyi kendisine verildiği gibi çıktılarken, <command>puts</command>; aynı zamanda çıktı satırının sonlanmasını sağlar. 4. ve 13. satırlarda <command>print</command> kullanıldığı için, işleç bir sonraki satırın başlangıcına geçeceği yerde, işleci ekrana çıktılanan dizgenin yanında bırakır. Bu durum kullanıcı girdisi için tanınabilir bir durumdur. Aşağıdaki dört çıktı çağrısı da aynı sonucu verir:
   </para>
   <screen>
#satırsonu karakteri yoksa, puts tarafından eklenir:
puts  "Tasi delen suyun kuvveti degil, damlalarin sürekliligidir."

#satırsonu karakteri print komutuna verilmelidir:
print "Tasi delen suyun kuvveti degil, damlalarin sürekliligidir.\n"

#çıktıyı + ile birleştirebilirsiniz:
print 'Tasi delen suyun kuvveti degil, damlalarin sürekliligidir.'+"\n"

# ya da birden fazla dizge vererek birleştirebilirsiniz:
print 'Tasi delen suyun kuvveti degil, damlalarin sürekliligidir.', "\n"
</screen>
  </sect1>
  <sect1><title>Düzenli İfadeler</title>
   <para>
    Son olarak <xref linkend="ruby-ug-regex"/> bölümündeki yazılımı inceleyeceğiz.
   </para>
   <screen>
1   st = "\033[7m"
2   en = "\033[m"
3
4   while TRUE
5     print "str&gt; "
6     STDOUT.flush
7     str = gets
8     break if not str
9     str.chop!
12    print "pat&gt; "
13    STDOUT.flush
14    re = gets
15    break if not re
16    re.chop!
17    str.gsub! re, "#{st}\\&amp;#{en}"
18    print str, "\n"
19  end
20  print "\n"
</screen>
   <para>
    4. satırda <command>while</command>'ın koşulu sonsuz döngüyü sağlamak için <command>true</command> yapılmıştır. Ancak döngüden çıkabilmek için 8. ve 13. satırlarda <command>break</command> kullandık. Bu iki <command>break</command> aynı zamanda <command>if</command> deyiminin niteleyicilerinden biridir. Bir <emphasis>if niteleyicisi</emphasis> sadece ve sadece koşul sağlandığı zaman sol yandaki terimini çalıştırır.
   </para>
   <para>
    <function>chop!</function> için (9. ve 14 satıra bakın) hakkında söylenecek çok şey var. Ruby'de geleneksel olarak yöntem isimlerinin sonuna '<command>!</command>' ya da '<command>?</command>' ekleriz. Ünlem işareti (<command>!</command> bazen "bang!" diye söylenir) potansiyel olarak yıkıcı bir görev görür, daha da açmak gerekirse; dokunduğu değeri değiştiren bir işleçtir. <function>chop!</function> bir dizgeye doğrudan etki eder ancak ünlem işareti olmayan bir <function>chop</function> bir kopya üzerinde çalışır. Aşağıda ikisi arasındaki fark görülüyor:
   </para>
   <screen class="eval">
ruby&gt; <emphasis class="evalinput">s1 = "forth"</emphasis>
   <emphasis class="evaloutput">"forth"</emphasis>
ruby&gt; <emphasis class="evalinput">s1.chop!</emphasis>       # Bu s1'in değerini değiştirir.
   <emphasis class="evaloutput">"fort"</emphasis>
ruby&gt; <emphasis class="evalinput">s2 = s1.chop</emphasis>   # s2'ye değiştirilmiş bir kopyasını koyar.
   <emphasis class="evaloutput">"for"</emphasis>
ruby&gt; <emphasis class="evalinput">s1</emphasis>             # ... s1'e dokunmaz.
   <emphasis class="evaloutput">"fort"</emphasis>
</screen>
   <para>
    İlerde sonunda soru işareti olan yöntem isimleriyle karşılaşacaksınız (<command>?</command> genelde "huh?" şeklinde telaffuz edilir). Bu <command>true</command> ya da <command>false</command> döndüren bir 'doğrulama' yöntemidir.
   </para>
   <para>
    15. satırda dikkat edilmesi gereken önemli bir uyarı yer almaktadır. Öncelikle <function>gsub!</function>'in başka bir sözde 'yıkıcı' yöntem olduğuna dikkat edelim. <literal>re</literal>'ye uyan her ne varsa <literal>str</literal>'nin yerine koyar (<command>sub</command> ikame etmekten (substitute), <command>g</command> ise globalden gelir);  sadece ilk bulunanı değil, dizgedeki <literal>tüm</literal> eşleşen kısımları değiştirir. Çok iyi, çok güzel; fakat eşleştirilen kısımları neyle değiştireceğiz? 1. ve 2 satırda önalan ve artalan renklerini peşpeşe değiştiren <literal>st</literal> ve <literal>en</literal> adlı iki dizge tanımladık.  15. satırdaysa bunları, olduğu gibi yorumlandıklarından emin olmak için <command>#{}</command> arasına yazdık (<emphasis>değişken isimlerinin yazdırıldığını görmeyiz</emphasis>).  Bunların arasında da "<command>\\&amp;</command>" kodunu görüyoruz. Bu küçük bir hiledir. Yer değiştirilen dizge çift tırnak arasında olduğu için  bir çift ters bölü işareti tek bir taneymiş gibi yorumlanır. Böylece <function>gsub!</function>'in göreceği şey "<command>\&amp;</command>" olur ve  bu da ilk konumda ne eşleştirildiyse onu gösteren özel bir koda dönüştürülür. Yani yeni dizge eşleşen parçaları farklı renkte gösterilen eski dizge olur.
   </para>
  </sect1>
 </chapter>
 <chapter xml:id="ruby-ug-control">
  <?dbhtml stop-chunking?>
  <title>Denetim Yapıları</title>
  <para>
   Bu bölümde Ruby'nin denetim yapılarını açıklayacağız.
  </para>
  <variablelist>
   <varlistentry>
    <term><command>case</command></term>
    <listitem>
     <para>
      <command>case</command> deyimini bir dizi koşulu test etmek için kullanırız. Bu yapı, C ve Java 'daki <command>switch</command>'e çok benzer ancak birazdan da göreceğiniz gibi ondan biraz daha güçlüdür.
     </para>
     <screen class="eval">
ruby&gt; <emphasis class="evalinput">i=8</emphasis>
ruby&gt; <emphasis class="evalinput">case i</emphasis>
    | <emphasis class="evalinput">when 1, 2..5</emphasis>
    |   <emphasis class="evalinput">print "1..5\n"</emphasis>
    | <emphasis class="evalinput">when 6..10</emphasis>
    |   <emphasis class="evalinput">print "6..10\n"</emphasis>
    | <emphasis class="evalinput">end</emphasis>
6..10
   <emphasis class="evaloutput">nil</emphasis>
</screen>
     <para>
      <command>2..5</command>, 2 ile 5 arasındaki sayı aralığını ifade eder. Sonraki ifade, <command>i</command> değişkeninin bu aralığa düşüp düşmediğini sınar:
     </para>
      <screen>(2..5) === i</screen>
     <para>
      <command>case</command> aynı anda birden çok koşulu sınamak için <code>===</code> ilişki işleçini kullanır. Ruby'nin nesneye yönelik yapısını korumak için <code>===</code> işleci nesneye uygun olarak yorumlanır. Örneğin aşağıdaki kodda ilk <command>when</command>'de dizgelerin eşitliği sınanırken ikinci <command>when</command>'de düzenli ifadenin eşleşmesi sınanıyor.
     </para>
     <screen class="eval">
ruby&gt; <emphasis class="evalinput">case 'abcdef'</emphasis>
    | <emphasis class="evalinput">when 'aaa', 'bbb'</emphasis>
    |   <emphasis class="evalinput">print "aaa or bbb\n"</emphasis>
    | <emphasis class="evalinput">when /def/</emphasis>
    |   <emphasis class="evalinput">print "/def/ icerir\n"</emphasis>
    | <emphasis class="evalinput">end</emphasis>
/def/ icerir
   <emphasis class="evaloutput">nil</emphasis>
</screen>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><command>while</command></term>
    <listitem>
     <para>
      Ruby döngü oluşturmak için bir çok yola sahiptir, bununla birlikte ileriki bölümde doğrudan döngü kurmanıza yarayan <emphasis>yineleyici</emphasis>leri göreceksiniz.
     </para>
     <para>
      <command>while</command> bir tekrarlanmış <command>if</command>'ten başka birşey değildir. <command>while</command>'ı daha önce kelime-tahmin oyunumuzda ve düzenli ifadeler yazılımımızda kullanmıştık (<xref linkend="ruby-ug-regex"/> bölümüne göz atın); <command>while </command><varname>koşul</varname><command> ... end</command> ile çevrilmiş bir kod bloğu koşul doğru olduğu sürece tekrarlanmaktaydı. Ancak <command>while</command> ve <command>if</command> ayrı ifadeler olarak da kullanılabilir:
     </para>
     <screen class="eval">
ruby&gt; <emphasis class="evalinput">i = 0</emphasis>
   <emphasis class="evaloutput">0</emphasis>
ruby&gt; <emphasis class="evalinput">print "Sıfır.\n" if i==0</emphasis>
Sıfır.
   <emphasis class="evaloutput">nil</emphasis>
ruby&gt; <emphasis class="evalinput">print "Negatif.\n" if i&lt;0</emphasis>
   <emphasis class="evaloutput">nil</emphasis>
ruby&gt; <emphasis class="evalinput">print "#{i+=1}\n" while i&lt;3</emphasis>
1
2
3
   <emphasis class="evaloutput">nil</emphasis>
</screen>
     <para>
      Bazen bir sınama koşulunu olumsuzlamak istersiniz. <command>unless</command> bir olumsuzlandırılmış <command>if</command>, <command>until</command> ise olumsuzlandırılmış bir <command>while</command>'dır. Bunları deneyip tecrübe etmeyi size bırakıyoruz.
     </para>
     <para>
      Bir döngüyü içerden kesmek için dört yol vardır. İlki C'deki gibi, döngüden tamamen çıkmamızı sağlayan <command>break</command>'tir. İkincisi (C'deki <command>continue</command>'ya benzeyen) döngünün başına atlayan <command>next</command>'tir. Üçüncüsü o anki yinelemeyi tekrar çalıştıran <command>redo</command>'dur. Aşağıda <command>break</command>, <command>next</command> ve  <command>redo</command> arasındaki farkı açıklayan bir C kodu bulunuyor:
     </para>
     <screen>
while (koşul) {
 label_redo:
   goto label_next;        /* ruby'nin "next"'i */
   goto label_break;       /* ruby'nin "break"'i */
   goto label_redo;        /* ruby'nin "redo"'su */
   ...
   ...
 label_next:
}
label_break:
...
</screen>
     <para>
      Bir döngünün içinden çıkmak için dördüncü yol, <command>return</command>'dür. <command>return</command> sadece döngüden değil, döngüyü içeren yöntemden de çıkmamızı sağlar. Eğer bir bağımsız değişken verildiyse, yöntem çağrısına dönecektir; aksi halde <command>nil</command> döndürecektir.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><command>for</command></term>
    <listitem>
     <para>
      C yazılımcıları <command>for</command> döngüsünün nasıl yapıldığını merak edeceklerdir. Ruby'nin <command>for</command>'u tahmin ettiğinizden biraz daha ilginçtir. Aşağıdaki döngü, her eleman için bir kere döner:
     </para>
     <screen>
for eleman in dizi
  ...
end
</screen>
     <para>
      Elemanlar bir değer aralığı olabilir (bu, döngü denildiğinde çoğu insanın anladığı şeydir):
     </para>
     <screen class="eval">
ruby&gt; <emphasis class="evalinput">for num in (4..6)</emphasis>
    | <emphasis class="evalinput">   print num,"\n"</emphasis>
    | <emphasis class="evalinput">end</emphasis>
4
5
6
   <emphasis class="evaloutput">4..6</emphasis>
</screen>
     <para>
      Elemanlar dizi gibi başka bir türden değerler olabilir:
     </para>
      <screen class="eval">
ruby&gt; <emphasis class="evalinput">for elt in [100,-9.6,"pickle"]</emphasis>
    |    <emphasis class="evalinput">print "#{elt}\t(#{elt.type})\n"</emphasis>
    | <emphasis class="evalinput">end</emphasis>
100    (Fixnum)
-9.6   (Float)
pickle (String)
   <emphasis class="evaloutput">[100, -9.6, "pickle"]</emphasis>
</screen>
     <para>
      Ancak ilerleme kaydediyoruz. <command>for</command> aslında <command>each</command>'i kullanmanın başka bir yoludur. Aşağıdaki iki biçim de aynı görevi görür:
     </para>
      <screen>
# Eğer daha önce C ya da Java kullandıysanız aşağıdaki gibi
# birşey tercih edersiniz:
for i in collection
  ...
end

#  Smalltalk yazılımcısıysanız aşağıdaki gibi birşeyi tercih edersiniz:
collection.each {|i|
  ...
}
</screen>
     <para>
      Yineleyiciler sık sık geleneksel döngülere tercih edilir; bir kere onları kullanmaya alıştığınızda ne kadar kolay olduklarını göreceksiniz.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </chapter>
 <chapter xml:id="ruby-ug-iterators">
  <?dbhtml stop-chunking?>
  <title>Yineleyiciler</title>
  <para>
   Yineleyiciler sadece Ruby'ye özgü bir kavram değildir. Genel olarak çoğu nesneye yönelik yazılım geliştirme dilinde kullanılmaktadır. Lisp'te de yineleyiciler olarak adlandırılmasalar da  kullanılmaktadır. Ancak yineleyici kavramı neredeyse her dilde değişik bir anlam kazandığı için önce bu kavramı daha ayrıntılı anlatmaya çalışalım:
  </para>
  <para>
   <emphasis>Yinelemek</emphasis> sözcüğü aynı şeyi birçok kez tekrarlamak anlamına gelir.
  </para>
  <para>
   Kod yazarken değişik durumlarda döngülere ihtiyacımız olur. C'de <command>for</command> ya da <command>while</command> kullanarak işimizi hallederiz. Örneğin,
  </para>
   <screen>
char *str;
for (str = "abcdefg"; *str != '\0'; str++) {
  /* her karakter için işlemler burada */
}
</screen>
  <para>
   C'nin <command> for(...) </command> sözdizimi döngünün oluşturulmasında soyutlama sağlayarak yardımcı olsa da <literal>*str</literal>'nin boş bir karakterle sınanması yazılımcının dizge yapısı hakkında daha ayrıntılı bilgi edinmesini gerektirir. Bu C'ye düşük-seviyeli hissi veren nedenlerden biridir. Yüksek seviyeli diller yineleyicilere uyumluluklarıyla ün kazanmışlardır. Aşağıdaki <command>sh</command> kabuk betiğini göz önünde alalım:
  </para>
   <screen>
#!/bin/sh

for i in *.[ch]; do
  # ... her dosya icin yapilacak birkaç işlem
done
</screen>
  <para>
   Bulunulan dizindeki tüm C kaynak ve başlık dosyaları çalıştırıldı ve komut satırı ayrıntıları tuttu.  C'den daha yüksek seviyeli olduğunu düşünüyorum, öyle değil mi?
  </para>
  <para>
   Ancak göz önüne alınması gereken başka bir nokta daha var: bir dilin gömülü veri yapıları için yineleyicileri desteklemesi güzel birşey olsa da, geri dönüp kendi veri yapılarımızı tekrarlatacak düşük seviyeli döngüler yazmak hayal kırıklığı yaratacaktır. Nesneye yönelik yazılım geliştirmede, kullanıcılar çoğu kez ardı ardına veri türleri tanımlar ve bu ciddi bir sorun olabilir.
  </para>
  <para>
   Her nesneye yönelik yazılım geliştirme dili yineleyiciler için kolaylıklar içerir. Bazı diller bu iş için özel sınıflar tanımlarken, Ruby yineleyicileri doğrudan tanımlamayı tercih eder.
  </para>
  <para>
   Ruby'nin <command>String</command> türü bazı yararlı yineleyicilere sahiptir.
  </para>
   <screen class="eval">
ruby&gt; <emphasis class="evalinput">"abc".each_byte{|c| printf "&lt;%c&gt;", c}; print "\n"</emphasis>
&lt;a&gt;&lt;b&gt;&lt;c&gt;
   <emphasis class="evaloutput">nil</emphasis>
</screen>
  <para>
   <function>each_byte</function>, dizgedeki her karakter için bir yineleyicidir. Her bir karakter yerel bir değişken olan <literal>c</literal>'ye yerleştirilir. Bu daha çok C koduna benzeyen bir şeyle açıklanabilir...
  </para>
   <screen class="eval">
ruby&gt; <emphasis class="evalinput">s="abc";i=0</emphasis>
   <emphasis class="evaloutput">0</emphasis>
ruby&gt; <emphasis class="evalinput">while i&lt;s.length</emphasis>
    |    <emphasis class="evalinput">printf "&lt;%c&gt;", s[i]; i+=1</emphasis>
    | <emphasis class="evalinput">end; print "\n"</emphasis>
&lt;a&gt;&lt;b&gt;&lt;c&gt;
   <emphasis class="evaloutput">nil</emphasis>
</screen>
  <para>
   Buna rağmen <function>each_byte</function> yineleyicisi hem kabul edilebilir bir basitliktedir hem de <command>String</command> sınıfı radikal bir değişikliğe uğrasa da çalışmaya devam eder. Yineleyicilerin başka bir yararı da değişiklere karşı sağlam durmasıdır ki bu da iyi bir kodun karakteristik özelliklerinden biridir (evet, sabırlı olun, <emphasis>sınıflar</emphasis> hakkında da konuşacağız.).
  </para>
  <para>
   <command>String</command>'in başka bir yineleyicisi de <command>each_line</command>'dır.
  </para>
   <screen class="eval">
ruby&gt; <emphasis class="evalinput">"a\nb\nc\n".each_line{|l| print l}</emphasis>
a
b
c
   <emphasis class="evaloutput">nil</emphasis>
</screen>
  <para>
   C'de satır sınırlayıcıları bulmak, alt dizgeler üretmek gibi güç işlerin yineleyicilerle kolayca üstesinden gelinebilir.
  </para>
  <para>
   Geçen bölümdeki <command>for</command> döngüsü, <command>each</command> işlecini kullanarak tekrarlamayı sağlamaktaydı. <command>String</command>'in <command>each</command>'i aynı <command>each_line</command> gibi görev görür, o yüzden yukarıdaki örneği <command>for</command> ile tekrar yazalım:
  </para>
   <screen class="eval">
ruby&gt; <emphasis class="evalinput">for l in "a\nb\nc\n"</emphasis>
    |   <emphasis class="evalinput">print l </emphasis>
    | <emphasis class="evalinput">end</emphasis>
a
b
c
   <emphasis class="evaloutput">nil</emphasis>
</screen>
  <para>
   Bulunan yineleyiciyi döngünün başından itibaren tekrar ettirmek için <command>retry</command> denetim yapısını kullanabiliriz.
  </para>
   <screen class="eval">
ruby&gt; <emphasis class="evalinput"> c=0</emphasis>
   <emphasis class="evaloutput">0</emphasis>
ruby&gt; <emphasis class="evalinput">for i in 0..4</emphasis>
    |   <emphasis class="evalinput">print i</emphasis>
    |   <emphasis class="evalinput">if i == 2 and c == 0</emphasis>
    |     <emphasis class="evalinput">c = 1</emphasis>
    |     <emphasis class="evalinput">print "\n"</emphasis>
    |     <emphasis class="evalinput">retry</emphasis>
    |   <emphasis class="evalinput">end</emphasis>
    | <emphasis class="evalinput">end; print "\n"</emphasis>
012
01234
   <emphasis class="evaloutput">nil</emphasis>
</screen>
  <para>
   Yineleyici tanımlamasında bazen <command>yield</command>'le karşılaşırız.  <command>yield</command>, denetimi yineleyiciye bağımsız değişken olarak geçilen kod bloğuna verir (bu konu <xref linkend="ruby-ug-pobjects"/> bölümünde daha ayrıntılı anlatılacaktır).
  </para>
  <para>
   Aşağıdaki örnekte, bağımsız değişkende verilen sayı kadar bir kod bloğunu tekrarlayan <command>repeat</command> yineleyicisi tanımlanmıştır.
  </para>
   <screen class="eval">
ruby&gt; <emphasis class="evalinput">def repeat(num)</emphasis>
    |   <emphasis class="evalinput">while num &gt; 0</emphasis>
    |     <emphasis class="evalinput">yield</emphasis>
    |     <emphasis class="evalinput">num -= 1</emphasis>
    |   <emphasis class="evalinput">end</emphasis>
    | <emphasis class="evalinput">end</emphasis>
   <emphasis class="evaloutput">nil</emphasis>
ruby&gt; <emphasis class="evalinput">repeat(3) { print "foo\n" }</emphasis>
foo
foo
foo
   <emphasis class="evaloutput">nil</emphasis>
</screen>
  <para>
   <command>retry</command> ile <command>while</command> gibi çalışan ancak hız açısından pek de pratik olmayan bir yineleyici tanımlayabiliriz.
  </para>
   <screen class="eval">
ruby&gt; <emphasis class="evalinput">def WHILE(cond)</emphasis>
    |   <emphasis class="evalinput">return if not cond</emphasis>
    |   <emphasis class="evalinput">yield</emphasis>
    |   <emphasis class="evalinput">retry</emphasis>
    | <emphasis class="evalinput">end</emphasis>
   <emphasis class="evaloutput">nil</emphasis>
ruby&gt; <emphasis class="evalinput">i=0; WHILE(i&lt;3) { print i; i+=1 }</emphasis>
012  nil
</screen>
  <para>
   Yineleyicinin ne olduğunu anladınız mı? Bir kaç kısıtlama hariç, kendi yineleyicinızı yazabilirsiniz, aslında yeni bir veri türü tanımladığınız zaman ona uygun bir yineleyici tanımlamanız da uygun olacaktır. Yukarıdaki örnekler pek de kullanışlı örnekler sayılmazlar. Sınıfları daha iyi anladığımızda daha uygulanabilir yineleyiciler hakkında konuşabiliriz.
  </para>
 </chapter>
 <chapter xml:id="ruby-ug-oothinking">
  <?dbhtml stop-chunking?>
  <title>Nesne Yönelimli Düşünme</title>
  <para>
   Nesne yönelimlilik kavramı çekici bir kavramdır. Herşeyi nesneye yönelik olarak çağırmak kulağınıza hoş gelebilir. Ruby nesne yönelimli bir betik dili olarak adlandırılır, ancak gerçekte bu "nesne yönelimlilik" kavramı nedir?
  </para>
  <para>
   Bu soruya aşağı yukarı hepsi aynı kapıya çıkan bir sürü cevap bulunabilir. Çabukça toparlamak yerine, isterseniz öncelikle geleneksel yazılım kavramı üzerinde duralım.
  </para>
  <para>
   Geleneksel olarak, bir yazılım geliştirme sorunu bazı verilerin gösterimleri ile bu veriler üzerinde çalışan yordamlar olarak karşımıza çıkar. Bu model altında, veri hareketsiz, edilgen ve beceriksizdir; tamamen etkin, mantıksal ve güçlü bir yordamın merhametine kalmıştır.
  </para>
  <para>
   Bu yaklaşımdaki sorun, yazılımları geliştiren yazılımcıların sadece insan olması ve dolayısıyla bir çok ayrıntıyı sadece bir sefer kafalarında net olarak tutabilmeleridir. Proje genişledikçe, yordamsal öz daha karmaşık ve hatırlaması zor bir noktaya gelir.
  </para>
  <para>
   Küçük düşünce kusurları ve yazım yanlışlarıyla sonuçta elinizde iyi-gizlenmiş yazılım hataları kalır.
  </para>
  <para>
   Zamanla yordam çekirdeğinde istenmeyen etkileşimler doğabilir; bu iş dokunaçlarının yüzünüze değmesine izin vermeden sinirli bir mürekkep balığı taşımaya benzer.
  </para>
  <para>
   Bu geleneksel zorlamalarla yazılım geliştirirken hataları azaltmak ve sınırlamak için kılavuzlar bulunmaktadır, ancak yöntemi kökten değiştirmek daha iyi bir çözüm olacaktır.
  </para>
  <para>
   Peki nesneye yönelik yazılım geliştirme, mantıksal işin sıradan ve tekrarlayan yönünü verinin kendisine emanet etmemizi mümkün kılmak ve veriyi edilgen durumdan etkin duruma sokmamız için ne yapar? Başka bir açıdan,
  </para>
  <itemizedlist>
   <listitem>
    <para>
     Her veri parçasına, erişip içindekileri etrafa fırlatmamıza izin veren kapağı açık bir kutu gibi davranmayı bıraktık.
    </para>
   </listitem>
   <listitem>
    <para>
     Her veri parçasına kapağı kapalı ve iyi işaretlenmiş düğmeleri bulunan çalışan bir makine gibi davranmaya başladık.
    </para>
   </listitem>
  </itemizedlist>
  <para>
   "Makine" olarak tanımladığımız şey çok basit ya da çok karmaşık olabilir ancak bunu dışarıdan bakarak söyleyemeyiz ve makineyi açmayı (tasarımıyla ilgili bir sorun olduğunu düşünmedikçe) istemeyiz. Bu yüzden veriyle etkileşimde bulunmak için düğme çeviriyor gibi işlem yapmamız gerekir. Makine bir kere kurulduğu zaman  nasıl çalıştığı hakkında düşünmemize gerek yoktur.
  </para>
  <para>
   Kendimize iş çıkardığımızı düşünebilirsiniz ancak bu yaklaşımla bazı şeylerin yanlış gitmesini önleyebiliriz.
  </para>
  <para>
   Şimdi açıklayıcı olması açısından basit ve küçük bir örnek görelim: Arabanızın bir yolmetresi olsun. Görevi yeniden başlatma düğmesine son basıldığından itibaren ne kadar yol katedildiği ölçmektir. Bu durumu bir yazılım geliştirme dilinde nasıl tasarlayabiliriz? C'de yolmetre sadece sayısal bir değişken olmalıdır, muthemelen bir <command>float</command>. Yazılım bu değişkenin değerini küçük aralıklarla arttıracak, uygun gördüğü zamansa sıfır yapıp yeniden başlatacaktır. Burada yanlış olan nedir?  Yazılımdaki bir hata bu değişkene uydurma bir değer atayabilir ve beklenmedik sonuçlar ortaya çıkabilir.   C'de yazılım geliştirmiş herhangi biri böylesine küçük ve basit bir hatayı bulmak için saatler ya da günler harcamanın ne demek olduğunu bilir (hatanın bulunma sinyali genelde alında şaklayan bir tokattır).
  </para>
  <para>
   Aynı sorun nesneye yönelik bağlamda da karşımıza çıkabilirdi. Yolmetreyi tasarlayan bir yazılımcının soracağı ilk şeylerden biri tabii ki "hangi veri yapısı bu durum için daha uygundur?" olmayacaktır. Ama "Bunun tam olarak nasıl çalışması gerekiyor?" şeklinde bir soru daha uygun olacaktır. Aradaki fark daha malumatlı olmaktır. Bir kilometre sayacının gerçekte ne işe yaradığına ve dış dünyanın onunla nasıl etkileşimde bulunmayı beklediğine karar vermek için biraz zaman ayırmamız gereklidir. Şimdi arttırabileceğimiz, yeniden başlatabileceğimiz ve değerini okuyabileceğimiz ve başka bir şey yapmayan küçük bir makine yapmaya karar verdik.
  </para>
  <para>
   Yolmetremize keyfi bir değer atamak için bir yol tanımlamadık; neden? Çünkü yolmetrelerin bu şekilde çalışmadığını biliyoruz. Yolmetreyle yapabileceğiniz pek az şey var, ki bunların hepsini yapmaya izin verdik. Bu şekilde eğer yazılımda herhangi birşey yolmetrenin değerinin yerine geçmeye çalışırsa (örneğin arabanın klimasının derecesi) işlerin yanlış gittiğine dair uyarı alırsınız. Koşan yazılımın (dilin doğasına göre muhtemelen derleme sırasında) yolmetre nesnelerine keyfi değerler atamaya izni olmadığını söyledik. Mesaj tam olarak bu olmayabilir ama buna yakın birşeydir. Ancak hatayı engellemiyor, değil mi? Ancak hatanın yerini kolayca gösterir. Bu nesneye yönelik yazılım geliştirmenin zamanımızı boşa harcamaktan kurtaran birkaç yolundan biridir.
  </para>
  <para>
   Yukarıda soyutlamanın yalnızca bir adımını yaptık, artık makinelerden oluşan bir fabrika yapmak kolaylaştı. Tek bir yolmetreyi doğrudan oluşturmak yerine, basit bir kalıptan istediğimiz sayıda yolmetre yapmayı tercih etmeliyiz. Kalıp (ya da isterseniz yolmetre fabrikası) "sınıf" olarak adlandırdığımız kavrama, oluşturduğumuz yolmetre de "nesne" olarak tanımladığımız kavrama karşılık gelmektedir. Bir çok nesneye yönelik yazılım geliştirme dili, herhangi bir nesne oluşturmdan önce bir sınıfın tanımlı olmasını gerekli kılar, ancak Ruby'de böyle bir durum sözkonusu değildir.
  </para>
  <para>
   Bu kullanımın nesneye yönelik tasarımı kuvvetlendirmediğini de bir kenara yazalım. Elbette her dilde, anlaşılamayan, hatalı, yarım yamalak kod yazmak mümkündür. Ruby'nin sizin için yaptığı şey (özellikle C++'nın aksine) nesneye yönelik yazılım geliştirme kavramını sindirmenizi sağlayarak, daha küçük bir ölçekte çalışırken çirkin bir kod yazmamak için çaba sarfetmenizi önler. İleriki bölümlerde Ruby'nin takdire şayan diğer özelliklerini açıklayacağız. Hala bizimle misiniz?
 </para>
 </chapter>
 <chapter xml:id="ruby-ug-methots">
  <?dbhtml stop-chunking?>
  <title>Yöntemler</title>
  <para>
   Yöntem nedir? Nesneye yönelik yazılım geliştirmede, nesnenin dışından doğrudan veri üzerinde işlem yapmak yerine (<emphasis>eğer nazikçe böyle yapmalarını söylerseniz</emphasis>) nesnelerin kendilerini nasıl çalıştıracakları hakkında bilgiye sahip olması tercih edilir. Nesnelere iletiler gönderdiğimizi ve bunların genelde bir olay tarafından gerçekleştirildiğini ya da anlamlı bir cevapla karşılandığını söyleyebilirsiniz. Bu muhtemelen bizim özellikle bilmemizi gerektiren ya da nesnenin kendi içinde nasıl çalıştığına dikkat etmemizi gerektirmeyen bir olaydır. Bir nesneye gerçekleştirmesi için (<emphasis>ya da anlayacağı iletiler göndermemiz için</emphasis>) vereceğimiz görevlere, <wordasword>nesnenin yöntemleri</wordasword> denir.
  </para>
  <para>
   Ruby'de bir nesnenin yöntemini nokta gösterimi ile çağırırız (C++ ya da Java'da olduğu gibi).
  </para>
   <screen class="eval">
ruby&gt; <emphasis class="evalinput"> "abcdef".length</emphasis>
    <emphasis class="evaloutput">6</emphasis>
</screen>
  <para>
   Muhtemelen bu dizgenin <emphasis>uzunluğunun ne kadar olduğu</emphasis> soruluyor.
  </para>
  <para>
   Teknik olarak,<command>"abcdef"</command> nesnesi için <command>length</command> yöntemini çağırıyoruz.
  </para>
  <para>
   Diğer nesnelerin <command>length</command> yöntemi için biraz farklılıkları olabilir ya da hiç olmayabilir de. İletilere nasıl yanıt verileceği kararı yazılımın çalıştırılması sırasında verilir ve hangi nesneye başvurduğuna bağlı olarak olay değişebilir.
  </para>
   <screen class="eval">
ruby&gt; <emphasis class="evalinput">foo = "abc"</emphasis>
   <emphasis class="evaloutput">"abc"</emphasis>
ruby&gt; <emphasis class="evalinput">foo.length</emphasis>
   <emphasis class="evaloutput">3</emphasis>
ruby&gt; <emphasis class="evalinput">foo = ["abcde", "fghij"]</emphasis>
   <emphasis class="evaloutput">["abcde", "fghij"]</emphasis>
ruby&gt; <emphasis class="evalinput">foo.length</emphasis>
   <emphasis class="evaloutput">2</emphasis>
</screen>
  <para>
   <literal>length</literal> yönteminin, nesneye göre değişebilmesiyle neyi kastediyoruz?
  </para>
  <para>
   Yukarıdaki örnekte ilk önce <command>foo</command>'nun uzunluğunu soruyoruz, basit bir dizgeye başvuruyor ve sadece tek bir mantıklı yanıt olabilir. İkinci sefer <command>foo</command> bir diziye başvuruyor ve uzunluğunun 2, 5 ya da 10 olduğunu düşünebilirsiniz ama genelde en kabul edilebilir yanıt tabii ki 2 olacaktır.
  </para>
   <screen class="eval">
ruby&gt; <emphasis class="evalinput"> foo[0].length</emphasis>
   <emphasis class="evaloutput">5</emphasis>
ruby&gt; <emphasis class="evalinput"> foo[0].length + foo[1].length</emphasis>
   <emphasis class="evaloutput">10</emphasis>
</screen>
  <para>
   Burada dikkat edilmesi gereken nokta bir dizinin, dizi olmanın ne demek olduğunu bilmesidir. Ruby'de veri parçaları beraberlerinde bilgi taşıdıkları için talepler otomatik olarak  algılanabilir ve bir çok yolla gerçekleştirilebilir.
  </para>
  <para>
   Bu yazılımcıyı belli işlev adlarını hatırlamaktan kurtarır, değişik veri türlerine uygulanabilir ve sonuç istediğimiz gibi olur. Nesneye yönelik yazılım geliştirmenin bu özelliği <literal>çok biçimlilik</literal> olarak adlandırılır.
  </para>
  <para>
   Bir nesne anlamadığı bir ileti aldığında bir hata ortaya çıkar:
  </para>
   <screen class="eval">
ruby&gt; <emphasis class="evalinput"> foo = 5</emphasis>
   <emphasis class="evaloutput">5</emphasis>
ruby&gt; <emphasis class="evalinput"> foo.length</emphasis>
<emphasis class="evaloutput">ERR: (eval):1: undefined method `length' for 5(Fixnum)</emphasis>
</screen>
  <para>
   Sonuçta bir nesne için hangi yöntemlerın kabul edilebilir olduğunu bilmemiz gerektiği halde, yöntemlerin nasıl işlediğini bilmek zorunda değiliz.
  </para>
  <para>
   Eğer bağımsız değişkenler bir yönteme verilecekse genelde yaylı ayraçlar arasına alınır.
  </para>
  <para>
   <literal><replaceable>nesne.yöntem</replaceable>(<replaceable>dğş1</replaceable>, <replaceable>dğş2</replaceable>)</literal>
  </para>
  <para>
   Ancak belirsizliğe yol açmadıkları sürece kullanılmayabilirler de.
  </para>
  <para>
   <replaceable>nesne.yöntem dğş1, dğş2</replaceable>
  </para>
  <para>
   Ruby, <command>self</command> adında bir nesnenin bir yöntemini çağırırken  başvurulan özel bir değişkene sahiptir. Rahatlık için "<command>self.</command>"  genelde yöntem çağrılırken kullanılmayabilir:
  </para>
  <para>
   <command>self.</command><replaceable>yöntem_adı</replaceable><literal>(<replaceable>dğş</replaceable>...)</literal>
  </para>
  <para>
   yukarıdaki ifadeyle aşağıdaki aynıdır:
  </para>
  <para>
   <replaceable>yöntem_adı</replaceable><literal>(<replaceable>dğş</replaceable>...)</literal>
  </para>
  <para>
   Bir <wordasword>işlev çağrısı</wordasword> sadece <command>self</command>'le yöntem çağrımının kısaltılmış şeklidir. Bu da Ruby'yi saf bir nesneye yönelik yazılım geliştirme dili yapan şeydir.  Hala işlevsel yöntemler diğer dillerdeki işlevlere çok benzese de aslında işlev çağrılarının Ruby'de gerçek nesne yöntemlerinden başka birşey olmadığını görmeniz gerekir. İstersek hala gerçek nesne yöntemleri değilmiş gibi kabul ederek <literal>işlev</literal>lerden bahsedebiliriz.
  </para>
 </chapter>
 <chapter xml:id="ruby-ug-classes">
  <?dbhtml stop-chunking?>
  <title>Sınıflar</title>
  <para>
   Gerçek dünya sınıflandırabileceğimiz nesnelerle doludur. Örneğin küçük bir çocuk bir köpek gördüğünde, cinsine bakmaksızın "hav hav" demesi gibi biz de dünyadaki nesneleri kategorize ederiz.
  </para>
  <para>
   Nesneye yönelik terminolojide, "köpek" gibi nesnelerin kategorize edilmiş haline <wordasword>sınıf</wordasword>, sınıfın özelleştirilmiş nesnelerinde <wordasword>örnek</wordasword> (instance) denir.
  </para>
  <para>
   Genelde Ruby'de ya da herhangi başka bir nesneye yönelik yazılım geliştirme dilinde nesne yapmak için önce sınıfın karakteristikleri tanımlanır sonra da bir örnek tanımlanır. Bu süreci görebilmek için <command>Köpek</command> adında ilk basit sınıfımızı tanımlıyoruz:
  </para>
   <screen class="eval">
ruby&gt;<emphasis class="evalinput">class Köpek</emphasis>
    |    <emphasis class="evalinput">def konuş</emphasis>
    |       <emphasis class="evalinput">print "Hav Hav\n"</emphasis>
    |    <emphasis class="evalinput">end</emphasis>
    | <emphasis class="evalinput">end</emphasis>
   <emphasis class="evaloutput">:konuş</emphasis>
</screen>
  <para>
   Sınıf tanımlaması <command>class</command> ile <command>end</command> arasında yapılmaktadır. Bu alanda bulunan <command>def</command>, önceki bölümlerde açıkladığımız gibi sınıfa bazı özel davranışlar kazandıran <wordasword>yöntem</wordasword>leri tanımlamak için kullanılır.
  </para>
  <para>
   Artık bir <command>Köpek</command> sınıfı tanımladık, öyleyse şimdi bir köpek yapabiliriz:
  </para>
   <screen class="eval">
ruby&gt; <emphasis class="evalinput">kuçu = Köpek.new</emphasis>
   <emphasis class="evaloutput">#&lt;Kopek:0x00005587446da620></emphasis>
</screen>
  <para>
   <command>Köpek</command> sınıfından yeni bir örnek yarattık ve <command>kuçu</command> adını verdik. <command>new</command> yöntemi her sınıf için yeni bir örnek yapmaya yarar. <command>kuçu</command> sınıf tanımımıza göre bir <command>Köpek</command> olduğu için, bir köpekte olmasına karar verdiğimiz tüm özellikleri taşır. <command>Köpek</command> sınıfımız çok basit olduğu için <command>kuçu</command>'dan yapmasını istediğimiz küçük bir hile var.
  </para>
   <screen class="eval">
ruby&gt; <emphasis class="evalinput">kuçu.konuş</emphasis>
Hav Hav
   <emphasis class="evaloutput">nil</emphasis>
</screen>
  <para>
   Bir sınıftan yeni bir örnek yaratmak bazen <wordasword>örnekleme</wordasword> olarak adlandırılır. Köpeğimizin havlamasını sınamak için öncelikle bir köpeğimizin olması lazım, <command>Köpek</command> sınıfından bizim için havlamasını isteyemeyiz.
  </para>
   <screen class="eval">
ruby&gt; <emphasis class="evalinput">Köpek.konuş</emphasis>
<emphasis class="evaloutput">ERR: undefined method `konuş' for Köpek:Class</emphasis>
</screen>
  <para>
   Diğer taraftan, duygusal olarak bağlanmamış bir köpeğin sesini duymak istersek, geçici bir köpek yaratabilir ve kaybolmadan önce bizim için küçük bir ses çıkarmasını isteyebiliriz.
  </para>
   <screen class="eval">
ruby&gt; <emphasis class="evalinput">(Köpek.new).konuş</emphasis>   # ya da daha genel olarak, Köpek.new.konuş
Hav Hav
   <emphasis class="evaloutput">nil</emphasis>
</screen>
  <para>
   "Bekle" diyebilirsiniz, "bu kerata nereye kayboldu böyle?" Bu doğru: eğer ona bir isim vermezseniz (<command>kuçu</command>'da yaptığımız gibi) Ruby'nin otomatik çöp toplama mekanizması devreye girer ve bunun istenmeyen aylak bir köpek olduğuna karar verir ve merhametsizce yok eder. Gerçekten, sorun yok; biliyorsunuz ki tüm köpekleri istediğimizi söyleyebiliriz.
  </para>
 </chapter>
 <chapter xml:id="ruby-ug-inheritance">
  <?dbhtml stop-chunking?>
  <title>Kalıtım</title>
  <para>
   Gerçek hayatta yaptığımız sınıflandırmalar son derece hiyerarşiktir. Örneğin bütün kedilerin memeli olduğunu ve bütün memelilerin hayvan olduğunu biliriz. Küçük sınıflar mensup oldukları büyük sınıfların karakteristik özelliklerini miras alırlar. Eğer bütün memeliler nefes alabiliyorsa, bütün kediler de nefes alabiliyor demektir.
  </para>
  <para>
   Bu durumu Ruby'de aşağıdaki gibi açıklayabiliriz:
  </para>
   <screen class="eval">
ruby&gt; <emphasis class="evalinput">class Memeli</emphasis>
    |    <emphasis class="evalinput">def nefeslen</emphasis>
    |       <emphasis class="evalinput">print "nefes al, nefes ver\n"</emphasis>
    |    <emphasis class="evalinput">end</emphasis>
    | <emphasis class="evalinput"> end</emphasis>
   <emphasis class="evaloutput">:nefeslen</emphasis>
ruby&gt; <emphasis class="evalinput">class Kedi &lt; Memeli</emphasis>
    |    <emphasis class="evalinput">def konuş</emphasis>
    |       <emphasis class="evalinput">print "Miyauvvvv\n"</emphasis>
    |    <emphasis class="evalinput">end</emphasis>
    | <emphasis class="evalinput"> end</emphasis>
   <emphasis class="evaloutput">:konuş</emphasis>
</screen>
  <para>
   Örneğin bir <command>Kedi</command>'nin nasıl nefes alması gerektiğini belirtmediğimizi farz edelim. Bu durumda her kedi <command>Kedi</command> sınıfı <command>Memeli</command> sınıfının bir alt sınıfı olarak tanımlanmışsa, bu davranışı <command>Memeli</command> sınıfından miras olarak alacaktır. (Nesneye yönelik terminolojide küçük sınıf <wordasword>alt sınıf</wordasword> , büyük sınıfsa <wordasword>süper sınıf</wordasword> olarak isimlendirilir.) Yazılımcının bakış açısına göre, kediler nefes alma yeteneğini bağımsız olarak almıştır, eğer bir <command>konuş</command> yöntemi de eklersek, artık kedilerimiz hem nefes alabilme hem de konuşabilme yeteneğine sahip olur.
  </para>
   <screen class="eval">
ruby&gt; <emphasis class="evalinput">pisi = Kedi.new</emphasis>
   <emphasis class="evaloutput">#&lt;Kedi:0x0000558744912cd0&gt;</emphasis>
ruby&gt; <emphasis class="evalinput">pisi.nefeslen</emphasis>
nefes al, nefes ver
   <emphasis class="evaloutput">nil</emphasis>
ruby&gt; <emphasis class="evalinput"> pisi.konuş</emphasis>
Miyauvvvv
   <emphasis class="evaloutput">nil</emphasis>
</screen>
  <para>
   Bazen süper sınıfta olması gereken ancak alt sınıf tarafından miras alınması istenmeyen bir özellik olabilir. Örneğin genel olarak kuşların uçmayı bildiğini ancak penguenlerin, kuşların uçamayan bir alt sınıfı olduğunu kabul edelim.
  </para>
   <screen class="eval">
ruby&gt; <emphasis class="evalinput">class Kuş</emphasis>
    |    <emphasis class="evalinput">def gagala</emphasis>
    |       <emphasis class="evalinput">print "Tüylerimi temizliyorum.\n"</emphasis>
    |    <emphasis class="evalinput">end</emphasis>
    |    <emphasis class="evalinput">def uç</emphasis>
    |       <emphasis class="evalinput">print "Uçuyorum.\n"</emphasis>
    |    <emphasis class="evalinput">end</emphasis>
    | <emphasis class="evalinput">end</emphasis>
   <emphasis class="evaloutput">:uç</emphasis>
ruby&gt; <emphasis class="evalinput">class Penguen &lt; Kuş</emphasis>
    |    <emphasis class="evalinput">def uç</emphasis>
    |       <emphasis class="evalinput">fail "Üzgünüm, yüzmeyi tercih ederim.\n"</emphasis>
    |    <emphasis class="evalinput">end</emphasis>
    | <emphasis class="evalinput">end</emphasis>
   <emphasis class="evaloutput">:uç</emphasis>
</screen>
  <para>
   Her yeni sınıfın her özelliğini ayrı ayrı tanımlamak yerine, sadece her alt sınıfla onun süper sınıfı arasındaki farklılıkları eklemek ya da yaniden tanımlamak daha iyidir. Kalıtımın bu kullanımına bazen <wordasword>farksal yazılım geliştirme</wordasword> denir. Bu nesneye yönelik yazılım geliştirmenin en yararlı özelliklerinden biridir.
  </para>
 </chapter>
 <chapter xml:id="ruby-ug-redefinemethods">
  <?dbhtml stop-chunking?>
  <title>Yöntemleri Yeniden Tanımlama</title>
  <para>
   Bir alt sınıfın davranışlarını, süper sınıfın yöntemlerini yeniden tanımlayarak değiştirebiliriz.
  </para>
   <screen class="eval">
ruby&gt; <emphasis class="evalinput">class İnsan</emphasis>
    |    <emphasis class="evalinput">def tanımla</emphasis>
    |       <emphasis class="evalinput">print "Ben insanım.\n"</emphasis>
    |    <emphasis class="evalinput">end</emphasis>
    |    <emphasis class="evalinput">def tren_bileti(yaş)</emphasis>
    |       <emphasis class="evalinput">if yaş &lt; 12</emphasis>
    |          <emphasis class="evalinput">print "İndirimli ücret.\n"</emphasis>
    |       <emphasis class="evalinput">else</emphasis>
    |          <emphasis class="evalinput">print "Normal ücret.\n"</emphasis>
    |       <emphasis class="evalinput">end</emphasis>
    |    <emphasis class="evalinput">end</emphasis>
    | <emphasis class="evalinput">end</emphasis>
  <emphasis class="evaloutput">:tren_bileti</emphasis>
ruby&gt; <emphasis class="evalinput">İnsan.new.tanımla</emphasis>
Ben insanım.
  <emphasis class="evaloutput">nil</emphasis>
ruby&gt; <emphasis class="evalinput">class Öğrenci1 &lt; İnsan</emphasis>
    |    <emphasis class="evalinput">def tanımla</emphasis>
    |       <emphasis class="evalinput">print "Ben öğrenciyim.\n"</emphasis>
    |    <emphasis class="evalinput">end</emphasis>
    | <emphasis class="evalinput">end</emphasis>
  <emphasis class="evaloutput">:tanımla</emphasis>
ruby&gt; <emphasis class="evalinput">Öğrenci1.new.tanımla</emphasis>
Ben öğrenciyim.
  <emphasis class="evaloutput">nil</emphasis>
</screen>
  <para>
   Örneğin süper sınıfın <command>tanımla</command> yöntemini tamamen yeniden tanımlamak yerine geliştirmek istediğimizi düşünelim. Bunun için <command>super</command>'i kullanıyoruz.
  </para>
   <screen class="eval">
ruby&gt; <emphasis class="evalinput">class Öğrenci2 &lt; İnsan</emphasis>
    |    <emphasis class="evalinput">def tanımla</emphasis>
    |       <emphasis class="evalinput">super</emphasis>
    |       <emphasis class="evalinput">print "Ben öğrenciyim, aynı zamanda.\n"</emphasis>
    |    <emphasis class="evalinput">end</emphasis>
    | <emphasis class="evalinput">end</emphasis>
  <emphasis class="evaloutput">:tanımla</emphasis>
ruby&gt; <emphasis class="evalinput"> Öğrenci2.new.tanımla</emphasis>
Ben insanım.
Ben öğrenciyim, aynı zamanda.
  <emphasis class="evaloutput">nil</emphasis>
</screen>
  <para>
   <command>super</command> özgün yöntemin ilgili özelliğinin miras alınmasını sağlar. Bazen iki tür insan olduğunu söylerler...
  </para>
   <screen class="eval">
ruby&gt; <emphasis class="evalinput">class Sahtekar &lt; İnsan</emphasis>
    |    <emphasis class="evalinput">def tren_bileti(yaş)</emphasis>
    |       <emphasis class="evalinput">super(11) # ucuz tarife istiyoruz.</emphasis>
    |    <emphasis class="evalinput">end</emphasis>
    | <emphasis class="evalinput">end</emphasis>
  <emphasis class="evaloutput">:tren_bileti</emphasis>
ruby&gt;<emphasis class="evalinput">Sahtekar.new.tren_bileti(25)</emphasis>
İndirimli ücret.
  <emphasis class="evaloutput">nil</emphasis>
ruby&gt; <emphasis class="evalinput">class Dürüst &lt; İnsan</emphasis>
    |    <emphasis class="evalinput">def tren_bileti(yaş)</emphasis>
    |       <emphasis class="evalinput">super(yaş) # verilen bağımsız değişkeni aktaralım</emphasis>
    |    <emphasis class="evalinput">end</emphasis>
    | <emphasis class="evalinput">end</emphasis>
  <emphasis class="evaloutput">:tren_bileti</emphasis>
ruby&gt;<emphasis class="evalinput">Dürüst.new.tren_bileti(25)</emphasis>
Normal ücret.
  <emphasis class="evaloutput">nil</emphasis>
</screen>
 </chapter>
 <chapter xml:id="ruby-ug-accesscontrol">
  <?dbhtml stop-chunking?>
  <title>Erişim Denetimi</title>
  <para>
   Daha önce Ruby'nin işlevlere değil sadece yöntemlere sahip olduğunu söylemiştik. Ancak sadece tek bir tür yöntem yoktur. Bu bölümde <wordasword>erişim yöntemleri</wordasword>'nden bahsedeceğiz.
  </para>
  <para>
   Yöntemi, sınıf tanımlamasının içinde değil de, en üstte tanımladığımızı farz edelim. Bunun C gibi daha geleneksel bir dildeki <wordasword>işlev</wordasword>lerle aynı işi yapan bir yöntem olduğunu düşünürüz.
  </para>
   <screen class="eval">
ruby&gt; <emphasis class="evalinput">def kare(n)</emphasis>
    |    <emphasis class="evalinput">n * n</emphasis>
    | <emphasis class="evalinput">end</emphasis>
   <emphasis class="evaloutput">:kare</emphasis>
ruby&gt; <emphasis class="evalinput">kare (5)</emphasis>
 <emphasis class="evaloutput">25</emphasis>
</screen>
  <para>
   Yeni yöntemimiz hiç bir sınıfa bağlı değil gibi gözüküyor, ama aslında Ruby bu yöntemi tüm sınıfların süper sınıfı olan <command>Object</command> sınıfına verir. Sonuç olarak her nesne bu yöntemi nasıl kullanacağını bilir. Bu durum doğru gibi gözükebilir ama burada küçük bir nokta vardır: bu yöntem her sınıfın <command>private</command> (özel) yöntemdir. Bunun ne anlama geldiğinden bahsedeceğiz fakat bu durumun sonuçlarından bir tanesi de aşağıdaki gibi sadece işlev tarzında çağırabilmemizdir:
  </para>
   <screen class="eval">
ruby&gt; <emphasis class="evalinput">class Foo</emphasis>
    |   <emphasis class="evalinput">def dördüncü_kuvvet(x)</emphasis>
    |     <emphasis class="evalinput">kare(x) * kare(x)</emphasis>
    |   <emphasis class="evalinput">end</emphasis>
    | <emphasis class="evalinput">end</emphasis>
   <emphasis class="evaloutput">:dördüncü_kuvvet</emphasis>
ruby&gt; <emphasis class="evalinput">Foo.new.dördüncü_kuvvet 10</emphasis>
   <emphasis class="evaloutput">10000</emphasis>
</screen>
  <para>
   Bir nesnenin, yöntemini açıkça çağırmasına izin verilmez:
  </para>
   <screen class="eval">
ruby&gt; <emphasis class="evalinput">"Balık".kare(5)</emphasis>
<emphasis class="evaloutput">ERR: private method `kare' called for "Balık":String</emphasis>
</screen>
  <para>
   Bu durum daha geleneksel bir dildeki gibi işlev yazmamızı sağlarken, Ruby'nin saf 'nesneye yönelik' yapısını korumasına yardımcı olur (işlevler halen nesnelerin yöntemleridir, sadece alıcı üstü kapalı olarak <command>self</command>'tir.)
  </para>
  <para>
   Önceki bölümlerde de vurguladığımız gibi nesneye yönelik yazılım geliştirmenin genel mantığı, <emphasis>belirtim</emphasis> ile  <emphasis>gerçeklenimi</emphasis> birbirinden ayırmak ya da bir nesneden hangi görevleri yapması istendiği ve onun bunların nasıl yapabileceğiyle ilgilenmektir.
  </para>
  <para>
   Bir nesnenin dahili işleri genelde kullanıcıdan saklanmalı, kullanıcı yalnızca neyin gidip geldiğiyle ilgilenmeli ve nesnenin kendi içinde neyi nasıl yaptığını bildiğine güvenmelidir.
  </para>
  <para>
   Genelde nesnenin dış dünya tarafından görülmeyen ancak dahili olarak kullandığı yöntemlere sahip olması yararlı bir şeydir (ve bu durum kullacının nesneleri görme biçimi değiştirilmeksizin yazılımcının isteğine göre değiştirebilir).
  </para>
  <para>
   Aşağıdaki basit örnekte <command>motor</command> sınıfının görünmediğini ama dahili olarak çalıştığını varsayalım.
  </para>
   <screen class="eval">
ruby&gt; <emphasis class="evalinput">class Deneme</emphasis>
    |    <emphasis class="evalinput">def iki_katı(a)</emphasis>
    |       <emphasis class="evalinput">print a," kere iki ",motor(a),"\n"</emphasis>
    |    <emphasis class="evalinput">end</emphasis>
    |    <emphasis class="evalinput">def motor(b)</emphasis>
    |       <emphasis class="evalinput">b * 2</emphasis>
    |    <emphasis class="evalinput">end</emphasis>
    |    <emphasis class="evalinput">private:motor  # motoru kullanıcılardan saklar</emphasis>
    | <emphasis class="evalinput">end</emphasis>
 <emphasis class="evalinput">Deneme</emphasis>
ruby&gt; <emphasis class="evalinput">deneme = Deneme.new</emphasis>
   <emphasis class="evaloutput">#&lt;Deneme:0x000055e097e4f368&gt;</emphasis>
ruby&gt; <emphasis class="evalinput">deneme.motor(6)</emphasis>
<emphasis class="evaloutput">ERR: private method `motor' called for #&lt;Deneme:0x000055e097e4f368&gt;</emphasis>
ruby&gt; <emphasis class="evalinput">deneme.iki_katı(6)</emphasis>
6 kere iki 12.
   <emphasis class="evaloutput">nil</emphasis>
</screen>
  <para>
   <command>deneme.motor(6)</command>'nın 12 değerini döndürmesini umuyorduk ancak bir <command>Deneme</command> nesnesi gibi davrandığımızda <command>motor</command>'un erişilemez olduğunu gördük. Yalnızca <command>iki_katı</command> gibi diğer <command>Deneme</command> yöntemleri <command>motor</command>'a ulaşma hakkına sahiptir. Böylece öncelikle <command>iki_katı</command> yöntemini içeren genel arayüze gitmek zorunda bırakıldık. Yazılımcı, kullancının <command>Deneme</command> nesnelerinin birbirini nasıl etkilediğine bakmaksızın <command>motor</command> yöntemini (bu örnekte muhtemelen başarım açısından <literal>b*2</literal>'yi <literal>b+b</literal> ile) değiştirebilir. Bu örnek erişim denetimlerini anlatmak için tabii ki çok basit bir örnektir ancak daha karmaşık ve ilginç sınıflar üretmeye başlayınca erişim denetiminin ne kadar yararlı bir kavram olduğunu anlayacaksınız.
  </para>
 </chapter>
 <chapter xml:id="ruby-ug-smethots">
  <?dbhtml stop-chunking?>
  <title>Tekil Yöntemler</title>
  <para>
   Bir örneğin davranışı ait olduğu sınıf tarafından belirlenir. Ancak bazen belirli bir örneğin özel bir davranışı olmasını isteyebiliriz. Çoğu yazılım geliştirme dilinde, sadece bir kere kullanacağımız bir sınıf tanımlamak gibi karmaşık bir yol seçebiliriz. Ruby'de her nesneye kendine ait yöntemler verebiliriz.
  </para>
   <screen class="eval">
ruby&gt; <emphasis class="evalinput">class TekilDeneme</emphasis>
    |    <emphasis class="evalinput">def boyut</emphasis>
    |       <emphasis class="evalinput">print "25\n"</emphasis>
    |    <emphasis class="evalinput">end</emphasis>
    | <emphasis class="evalinput">end</emphasis>
   <emphasis class="evaloutput">:boyut</emphasis>
ruby&gt; <emphasis class="evalinput">dnm1 = TekilDeneme.new</emphasis>
   <emphasis class="evaloutput">#&lt;TekilDeneme:0x000055e097dc8f48&gt;</emphasis>
ruby&gt; <emphasis class="evalinput">dnm2 = TekilDeneme.new</emphasis>
   <emphasis class="evaloutput">#&lt;TekilDeneme:0x000055e097e6faa0&gt;</emphasis>
ruby&gt; <emphasis class="evalinput">def dnm2.boyut</emphasis>
    | <emphasis class="evalinput">print "10\n"</emphasis>
    | <emphasis class="evalinput">end</emphasis>
   <emphasis class="evaloutput">:boyut</emphasis>
ruby&gt; <emphasis class="evalinput">dnm1.boyut</emphasis>
25
   <emphasis class="evaloutput">nil</emphasis>
ruby&gt; <emphasis class="evalinput">dnm2.boyut</emphasis>
10
   <emphasis class="evaloutput">nil</emphasis>
</screen>
  <para>
   Yukarıdaki örnekte, <command>dnm1</command> ve <command>dnm2</command> aynı sınıfa mensup olmalarına rağmen, <command>dnm2</command>'nin <command>boyut</command> yöntemi yeniden tanımlandığı için farklı davranır. Sadece tekil bir nesneye verilen yönteme <wordasword>tekil yöntem</wordasword> (<emphasis>singleton method</emphasis>) denir.
  </para>
  <para>
   Tekil yöntemler genelde grafik arayüzü elemanlarında (GUI) değişik düğmelerin değişik eylemler yapması gerektiğinde kullanılır.
  </para>
  <para>
   Tekil yöntemler CLOS, Dylan vb. yazılım geliştirme dillerinde olduğu üzere Ruby'ye özgü değildir. Self ve NewtonScript gibi bazı diller ise sadece tekil yöntemlerden oluşmuştur. Bu tür diller <wordasword>prototip tabanlı</wordasword> diller olarak anılırlar.
  </para>
 </chapter>
 <chapter xml:id="ruby-ug-modules">
  <?dbhtml stop-chunking?>
  <title>Modüller</title>
  <para>
   Ruby'de modüller sınıflara benzer özellikler gösterirler:
  </para>
  <simplelist>
   <member>Modülün örneği yoktur.</member>
   <member>Modülün alt sınıfı yoktur.</member>
   <member>Modül <command>module ... end</command> şeklinde tanımlanır.</member>
  </simplelist>
  <para>
   Aslında modülün "Module" sınıfı, sınıfın "Class" sınıfının süper sınıfıdır. Anladınız mı? Hayır? O zaman devam edelim.
  </para>
  <para>
   Modüller iki türlü kullanılır. Bir tanesi ilişkili yöntemleri ve sabitleri merkezi bir yerde toplar. Ruby'nin standart kitaplığındaki <command>Math</command> modülü böyle bir rol oynar:
  </para>
   <screen class="eval">
ruby&gt; <emphasis class="evalinput">Math.sqrt(2)</emphasis>
   <emphasis class="evaloutput">1.4142135623730951</emphasis>
ruby&gt; <emphasis class="evalinput">Math::PI</emphasis>
   <emphasis class="evaloutput">3.141592653589793</emphasis>
</screen>
  <para>
   <command>::</command> işleci Ruby yorumlayıcısına bir sabit için hangi modülü yükleyeceğini söyler. (örneğin <command>Math</command> için bir anlam ihtiva eden birşey <command>PI</command> için başka bir anlama gelebilir). Eğer bir yöntem ya da sabitin, <command>::</command> kullanmadan doğrudan modüle başvurmasını istiyorsak bu modülü <command>include</command> ile ekleyebiliriz.
  </para>
   <screen class="eval">
ruby&gt; <emphasis class="evalinput">include Math</emphasis>
   <emphasis class="evaloutput">Object</emphasis>
ruby&gt; <emphasis class="evalinput">sqrt(2)</emphasis>
   <emphasis class="evaloutput">1.4142135623730951</emphasis>
ruby&gt; <emphasis class="evalinput">PI</emphasis>
   <emphasis class="evaloutput">3.141592653589793</emphasis>
</screen>
  <para>
   Diğer bir kullanım da <wordasword>karışım</wordasword> (mixin) olarak adlandırılır. Bazı nesneye yönelik yazılım geliştirme dili, C++ da dahil, birden fazla süper sınıftan miras almamızı sağlayan <wordasword>çoklu miras</wordasword> kavramına izin verir. Bunun gerçek dünyadaki örneği çalar saatler olabilir. Çalar saatleri hem <literal>saat</literal> sınıfına hem de <literal>alarm</literal> sınıfına sokabilirsiniz.
  </para>
  <para>
   Ruby gerçek çoklu mirası doğrudan desteklemez ancak <wordasword>karışım</wordasword> tekniği iyi bir seçenektir. Modüllerin örneklenemeyeceğini ve alt sınıflanamayacağını hatırlayın, ancak bir modülü  bir sınıf tanımlamasının içine <command>include</command> ile eklersek bu yöntemi sınıfa 'karıştırmış' ya da eklemiş oluruz.
  </para>
  <para>
   Karışım stratejisi, ek olarak sınıfımıza hangi özellikleri istediğimizi belirtmenin başka bir yoludur. Örneğin eğer bir sınıfın çalışan bir <command>each</command> yöntemi varsa- bunu <literal>Enumerable</literal> standart kütüphanesine eklemek size <command>sort</command> ve <command>find</command> yöntemlerini bedavaya getirir.
  </para>
  <para>
   Modüllerin bu kullanımı işlevel bir çoklu miras kullanımı sağlarken, aynı zamanda basit bir ağaç yapısıyla sınıf akrabalıklarını temsil eder, böylece dil gerçeklenimini basitleştirir (benzer bir dil gerçeklenimi Java tasarımcıları tarafından da yapılmıştı).
  </para>
 </chapter>
 <chapter xml:id="ruby-ug-pobjects">
  <?dbhtml stop-chunking?>
  <title>Yordam Nesneleri</title>
  <para>
   Beklenmeyen durumlara cevap verebilme genelde istenen bir durumdur. Eğer diğer yöntemlere kod bloklarını bağımsız değişken olarak geçebilirsek yani koda bir veriymiş gibi davranabilirsek bu işi oldukça kolaylaştırmış oluruz.
  </para>
  <para>
   Yeni bir <wordasword>yordam nesnesi</wordasword>, <command>proc</command> kullanılarak oluşturulur:
  </para>
   <screen class="eval">
ruby&gt;<emphasis class="evalinput">guguk = proc {</emphasis>
    |    <emphasis class="evalinput">print "GUGUKGUGUKGUGUK!!!\n"</emphasis>
    | <emphasis class="evalinput">}</emphasis>
   <emphasis class="evaloutput">#&lt;Proc:0x000055e097ea42c8 &lt;main&gt;:0&gt;</emphasis>
</screen>
  <para>
   Artık <command>guguk</command> bir nesne belirtiyor ve onun da diğer nesneler gibi istenebilir davranışları vardır. <command>call</command> yöntemi sayesinde bu davranışları talep edebiliriz:
  </para>
   <screen class="eval">
ruby&gt; <emphasis class="evalinput">guguk.call</emphasis>
GUGUKGUGUKGUGUK!!!
   <emphasis class="evaloutput">nil</emphasis>
</screen>
  <para>
   Peki tüm bunlardan sonra, <command>guguk</command> yöntem bağımsız değişkeni gibi kullanılabilir mi? Tabii ki.
   </para>
   <screen class="eval">
ruby&gt; <emphasis class="evalinput">def run( p )</emphasis>
    |    <emphasis class="evalinput">print "Bir yordamı çağırıyoruz...\n"</emphasis>
    |    <emphasis class="evalinput">p.call</emphasis>
    |    <emphasis class="evalinput">print "Bitti.\n"</emphasis>
    | <emphasis class="evalinput">end</emphasis>
   <emphasis class="evaloutput">run</emphasis>
ruby&gt; <emphasis class="evalinput">run guguk</emphasis>
Bir yordamı çağırıyoruz...
GUGUKGUGUKGUGUK!!!
Bitti.
   <emphasis class="evaloutput">nil</emphasis>
</screen>
  <para>
   <command>trap</command> yöntemi aldığımız cevabı tercihimize göre istediğimiz sistem sinyaline atamamıza izin verir.
  </para>
   <screen class="eval">
ruby&gt; <emphasis class="evalinput">kesmeişleyici = proc { print "^C basıldı.\n" }</emphasis>
    <emphasis class="evaloutput">#&lt;Proc:0x000055e097eab208 &lt;main&gt;0&gt;</emphasis>
ruby&gt; <emphasis class="evalinput">trap "SIGINT", kesmeişleyici</emphasis>
    <emphasis class="evaloutput">"DEFAULT"</emphasis>
</screen>
  <para>
   Normalde <literal>^C</literal>'ye basmak yorumlayıcıdan çıkmamızı sağlar. Ancak şimdi bir ileti yazıldı ve yorumlayıcı hala çalışmaya devam ediyor, böylece yaptığınız işi kaybetmemiş oluyorsunuz. (Yorumlayıcıda sonsuza dek kapana kısılmadınız, hala <command>exit</command> yazarak ya da <literal>^D</literal>'ye basarak çıkabilirsiniz.)
  </para>
  <para>
   Başka konulara geçmeden önce son bir bilgi: bir yordamı bir sinyale bağlamadan önce ona illa ki isim vermek gerekli değildir. <emphasis>Anonim</emphasis> bir yordam nesnesi aşağıdaki gibi olabilir:
  </para>
   <screen class="eval">
ruby&gt; <emphasis class="evalinput">trap "SIGINT", proc { print "^C basıldı.\n" }</emphasis>
    <emphasis class="evaloutput">#&lt;Proc:0x000055e097eab208 &lt;main&gt;0&gt;</emphasis>
</screen>
  <para>daha kısa şekilde,</para>
   <screen class="eval">
ruby&gt;n<emphasis class="evalinput">trap "SIGINT", 'print "^C basıldı.\n"'</emphasis>
    <emphasis class="evaloutput">#&lt;Proc:0x000055e097eaa678 &lt;main&gt;0&gt;</emphasis>
</screen>
  <para>
   Bu kısaltılmış biçim, küçük anonim yordamlar yazdığınızda okunabilirlik sağlar.
  </para>
 </chapter>
 <chapter xml:id="ruby-ug-vars">
  <?dbhtml stop-chunking?>
  <title>Değişkenler</title>
  <para>
   Ruby biri sabit, ikisi de yarı-değişken olmak üzere üç çeşit değişkene sahiptir. Değişkenlerin ve sabitlerin türü yoktur. Türü olmayan değişkenler sakıncalı olsa bile, Ruby'nin <literal>kolay ve hızlı</literal> felsefesine uygun olarak bir çok getirisi vardır.
  </para>
  <para>
   Bir çok yazılım geliştirme dilinde değiştirilebilirliğini sağlamak (sabit olsalar bile) ve etki alanını belirlemek için değişkenlerin türü belirtilerek bildirilmesi gerekir. Ancak değişken türleri önemli olmadığından ve aşikar çözüm göreceğiniz gibi değişken isminden elde edilebileceğinden, Ruby'de değişken bildirimlerine ihtiyacımız kalmaz.
  </para>
  <para>
   Değişken isminin ilk karakteri sayesinde bir bakışta türünü anlamak mümkündür:
  </para>
  <informaltable>
   <tgroup cols="2" colsep="1" rowsep="1">
    <colspec colwidth="30%"/>
    <colspec colwidth="70%"/>
    <tbody>
     <row>
      <entry><command>$</command></entry>
      <entry>genel değişken</entry>
     </row>
     <row>
      <entry><command>@</command></entry>
      <entry>örnek değişken</entry>
     </row>
     <row>
      <entry><command>[a-z]</command> ya da <command>_</command></entry>
      <entry>yerel değişken</entry>
     </row>
     <row>
      <entry><command>[A-Z]</command></entry>
      <entry>sabit</entry>
     </row>
    </tbody>
   </tgroup>
  </informaltable>
  <para>
   Bunların dışında tek istisna Ruby'nin yarı-değişkenleridir: daima o an çalışmakta olan nesneyi ifade eden <command>self</command> ve ilklendirilmemiş değişkenlere atanan anlamsız değer olan <command>nil</command>. Her ikisi de yerel değişkenler gibi tanımlanmış olsalar da, <command>self</command> yorumlayıcı tarafından saklanan bir genel değişken ve <command>nil</command> de gerçekte bir sabittir. Bunlar sadece iki istisna olduğu için üzerlerinde fazla durmayacağız.
  </para>
  <para>
   <command>self</command>'e ya da <command>nil</command>'e değer atamamalıyız. <command>main</command>, bir <command>self</command> değeri olarak üst nesneyi ifade eder:
  </para>
   <screen class="eval">
ruby&gt; <emphasis class="evalinput">self</emphasis>
   <emphasis class="evaloutput">main</emphasis>
ruby&gt; <emphasis class="evalinput">nil</emphasis>
   <emphasis class="evaloutput">nil</emphasis>
</screen>
 </chapter>
 <chapter xml:id="ruby-ug-globalvars">
  <?dbhtml stop-chunking?>
  <title>Genel Değişkenler</title>
  <para>
   Genel değişkenler isimlerinin başında birer <command>$</command> işareti bulunur. Genel değişkenlere yazılımın her hangi bir yerinden başvurulabilir ve ilklendirilmeden önce <command>nil</command> değerine sahiptir.
  </para>
   <screen class="eval">
ruby&gt; <emphasis class="evalinput">$foo</emphasis>
   <emphasis class="evaloutput">nil</emphasis>
ruby&gt; <emphasis class="evalinput">$foo = 5</emphasis>
   <emphasis class="evaloutput">5</emphasis>
ruby&gt; <emphasis class="evalinput">$foo</emphasis>
   <emphasis class="evaloutput">5</emphasis>
</screen>
  <para>
   Genel değişkenler dikkatli kullanılmalıdır. Her yerden yazılabildikleri için tehlikelidir. Genel değişkenlerin aşırı kullanılması yanlışları izole etmede zorluk çıkarabildiği gibi yazılımın iyice düşünülmeden tasarlandığına dikkat çeker. Genel değişken kullanmayı uygun gördüğünüz zaman, onlara anlaşılabilir isimler verdiğinizden emin olun ( <command>$foo</command> gibi birşeyi çağırmak oldukça kötü bir fikir değil mi?).
  </para>
  <para>
   Genel değişkenlerin güzel bir özelliği de izlenebilir olmalarıdır; bir değişkenin değeri ne zaman değişirse o zaman çağrılan bir yordam belirleyebilirsiniz.
  </para>
   <screen class="eval">
ruby&gt; <emphasis class="evalinput">trace_var :$x, proc{ print "$x şimdi ", $x, "\n" }</emphasis>
   <emphasis class="evaloutput">nil</emphasis>
ruby&gt; <emphasis class="evalinput">$x = 5</emphasis>
$x şimdi 5
   <emphasis class="evaloutput">5</emphasis>
</screen>
  <para>
   Bir küresel değişken, değiştiği zaman bir yordamı çalıştırmak için kullanılıyorsa, <wordasword>etkin değişken</wordasword> olarak da anılır.
  </para>
  <para>
   Aşağıda <command>$</command> işaretini takiben tek bir karakter daha içeren bir dizi özel değişken bulunuyor. Örneğin <command>$$</command> Ruby yorumcusunun süreç numarasını içerir ve salt okunabilirdir. Aşağıda önemli sistem değişkenleri ve anlamları bulunuyor: (ayrıntılar için <link xlink:href="http://www.ruby-lang.org/en/man-1.4/">Ruby Başvuru Kılavuzu</link>na bakınız):
  </para>
  <informaltable>
   <tgroup cols="2" colsep="1" rowsep="1">
    <colspec colwidth="10%"/>
    <colspec colwidth="90%"/>
    <tbody>
     <row>
      <entry><command>$!</command></entry>
      <entry>son hata iletisi</entry>
     </row>
     <row>
      <entry><command>$@</command></entry>
      <entry>hatanın konumu</entry>
     </row>
     <row>
      <entry><command>$_</command></entry>
      <entry><command>gets</command> tarafından okunan son dizge</entry>
     </row>
     <row>
      <entry><command>$.</command></entry>
      <entry>yorumlayıcı tarafından son okunan satır numarası</entry>
     </row>
     <row>
      <entry><command>$&amp;</command></entry>
      <entry>regexp tarafından son bulunan dizge</entry>
     </row>
     <row>
      <entry><command>$~</command></entry>
      <entry>alt ifade (<emphasis>subexpression</emphasis>) dizisi olarak regexp tarafından bulunan son ifade</entry>
     </row>
     <row>
      <entry><command>$</command> <literal>n</literal></entry>
      <entry>son bulunan <literal>n</literal>'inci alt ifade (<command>$~[</command><literal>n</literal><command>]</command> ile aynı)</entry>
     </row>
     <row>
      <entry><command>$=</command></entry>
      <entry>büyük-küçük harfe duyarsız bayrak</entry>
     </row>
     <row>
      <entry><command>$/</command></entry>
      <entry>girdi kaydı ayracı (<emphasis>input record separator</emphasis>)</entry>
     </row>
     <row>
      <entry><command>$\</command></entry>
      <entry>çıktı kaydı ayracı (<emphasis>output record separator</emphasis>)</entry>
     </row>
     <row>
      <entry><command>$0</command></entry>
      <entry>ruby betik dosyasının adı</entry>
     </row>
     <row>
      <entry><command>$*</command></entry>
      <entry>komut satırı girdileri</entry>
     </row>
     <row>
      <entry><command>$$</command></entry>
      <entry>yorumcunun süreç numarası (PID)</entry>
     </row>
     <row>
      <entry><command>$?</command></entry>
      <entry>son işletilen çocuk sürecin çıkış durumu</entry>
     </row>
    </tbody>
   </tgroup>
  </informaltable>
  <para>
   <command>$_</command> ve <command>$~</command> için etki alanı yereldir. Her ne kadar isimleri gereği genel değişkenler olmaları gerekiyorsa da böyle daha kullanışlıdır.
  </para>
 </chapter>
 <chapter xml:id="ruby-ug-instancevars">
  <?dbhtml stop-chunking?>
  <title>Örnek Değişkenler</title>
  <para>
   Örnek değişken <command>@</command> ile başlayan bir ada sahiptir ve etki alanı <command>self</command> nesnesi ile sınırlıdır. Aynı sınıfa dahil olan aynı iki nesne için iki değişik örnek değişken tanımlamak mümkündür.
  </para>
  <para>
   Örnek değişkenler, yazılımcı hangi yöntemi tanımlarsa tanımlasın bir nesnenin dışından değiştirilemez (Ruby'nin örnek değişkenleri hiçbir zaman <emphasis>genel</emphasis> olamaz). Genel değişkenlerde olduğu gibi, örnek değişkenler de başlangıç değeri atanmazsa <command>nil</command> değerine sahip olurlar.
  </para>
  <para>
   Ruby'de örnek değişkenleri bildirmeye gerek yoktur. Bu durum nesnelerin yapısına esneklik kazandırır. Aslında, her örnek değişken, nesnedeki ilk kullanımında kendiliğinden oluşturulur.
  </para>
   <screen class="eval">
ruby&gt;<emphasis class="evalinput">class ÖrnekDeneme</emphasis>
    |    <emphasis class="evalinput">def set_foo(n)</emphasis>
    |       <emphasis class="evalinput">@foo = n</emphasis>
    |    <emphasis class="evalinput">end</emphasis>
    |    <emphasis class="evalinput">def set_bar(n)</emphasis>
    |       <emphasis class="evalinput">@bar = n</emphasis>
    |    <emphasis class="evalinput">end</emphasis>
    | <emphasis class="evalinput">end</emphasis>
   <emphasis class="evaloutput">:set_bar</emphasis>
ruby&gt; <emphasis class="evalinput">i = ÖrnekDeneme.new</emphasis>
   <emphasis class="evaloutput">#&lt;ÖrnekDeneme:0x000055e097eaf768&gt;</emphasis>
ruby&gt; <emphasis class="evalinput">i.set_foo(2)</emphasis>
   <emphasis class="evaloutput">2</emphasis>
ruby&gt; <emphasis class="evalinput">i</emphasis>
   <emphasis class="evaloutput">#&lt;ÖrnekDeneme:0x000055e097eaf768 @foo=2&gt;</emphasis>
ruby&gt; <emphasis class="evalinput">i.set_bar(4)</emphasis>
   <emphasis class="evaloutput">4</emphasis>
ruby&gt; <emphasis class="evalinput">i</emphasis>
   <emphasis class="evaloutput">#&lt;ÖrnekDeneme:0x000055e097eaf768 @foo=2, @bar=4&gt;</emphasis>
</screen>
  <para>
   <command>i</command>'nin <command>set_bar</command> yöntemi çağrılmadan <command>@bar</command>'ın  hiçbir değer belirtmediğine dikkat edin.
  </para>
 </chapter>
 <chapter xml:id="ruby-ug-localvars">
  <?dbhtml stop-chunking?>
  <title>Yerel Değişkenler</title>
  <para>
   Yerel değişkenler küçük harfle ya da <command>_</command> karakteriyle başlayan isimlere sahiptir. Yerel değişkenler genel ya da örnek değişkenlerde olduğu gibi, başlangıçta <command>nil</command> değerine sahip değildir.
  </para>
   <screen class="eval">
ruby&gt; <emphasis class="evalinput">$foo</emphasis>
   <emphasis class="evaloutput">nil</emphasis>
ruby&gt; <emphasis class="evalinput">@foo</emphasis>
   <emphasis class="evaloutput">nil</emphasis>
ruby&gt; <emphasis class="evalinput">foo</emphasis>
   <emphasis class="evaloutput">ERR: undefined local variable or method `foo' for main:Object</emphasis>
</screen>
  <para>
   Yerel bir değişkene yaptığınız ilk atama onu bildirmekle aynı şeydir. Eğer başlangıç değeri olmayan bir yerel değişkene başvurursanız, Ruby yorumlayıcısı bunun bir yöntemi çalıştırma girişimi olduğunu düşünür ve aşağıdaki gibi bir hata verir.
  </para>
  <para>
   Genelde yerel bir değişkenin etki alanı aşağıdakilerden biridir:
  </para>
  <simplelist>
   <member><command>proc{</command> <replaceable>...</replaceable> <command>}</command></member>
   <member><command>loop{</command> <replaceable>...</replaceable> <command>}</command></member>
   <member><command>def</command> <replaceable>...</replaceable> <command>end</command></member>
   <member><command>class</command> <replaceable>...</replaceable> <command>end</command></member>
   <member><command>module</command> <replaceable>...</replaceable> <command>end</command></member>
   <member>yazılımın tamamı (yukarıdakilerden herhangi biri yoksa)</member>
  </simplelist>
  <para>
   Aşağıdaki örnekte görülen <command>defined?</command> işleci bir belirtecin tanımlanıp tanımlanmadığına bakar. Eğer tanımlanmışsa bir açıklama döndürür; tanımlanmamış ise <command>nil</command> değerini döndürür. Gördüğünüz gibi <command>bar</command> döngüde yerel, döngüden çıkınca tanımsızdır.
  </para>
   <screen class="eval">
ruby&gt; <emphasis class="evalinput">foo = 44; print foo, "\n"; defined? foo</emphasis>
44
   <emphasis class="evaloutput">"local-variable"</emphasis>
ruby&gt; <emphasis class="evalinput">loop{bar=45; print bar, "\n"; break}; defined? bar</emphasis>
45
   <emphasis class="evaloutput">nil</emphasis>
</screen>
  <para>
   Yordam nesneleri aynı etki alanındaki yerel değişkenleri paylaşırlar. Örnekte yerel değişken <command>bar</command>, <command>main</command> ve yordam nesneleri <command>p1</command> ve <command>p2</command> tarafından paylaşılmaktadır:
  </para>
   <screen class="eval">
ruby&gt; <emphasis class="evalinput">bar=nil</emphasis>
   <emphasis class="evaloutput">nil</emphasis>
ruby&gt; <emphasis class="evalinput">p1 = proc{ |n| bar=n }</emphasis>
   <emphasis class="evaloutput">#&lt;Proc:0x000055e097eb6950 &lt;main&gt;:0&gt;</emphasis>
ruby&gt; <emphasis class="evalinput">p2 = proc{ bar }</emphasis>
   <emphasis class="evaloutput">#&lt;Proc:0x000055e097eb6338 &lt;main&gt;</emphasis>
ruby&gt; <emphasis class="evalinput">p1.call(5)</emphasis>
   <emphasis class="evaloutput">5</emphasis>
ruby&gt; <emphasis class="evalinput">bar</emphasis>
   <emphasis class="evaloutput">5</emphasis>
ruby&gt; <emphasis class="evalinput">p2.call</emphasis>
   <emphasis class="evaloutput">5</emphasis>
</screen>
  <para>
   Baştaki "<literal>bar=nil</literal>"'ın çıkarılamayacağına dikkat edin; bu atama <command>bar</command>'ın <command>p1</command> ve <command>p2</command> tarafından kuşatılacağını garanti eder. Öteki türlü <command>p1</command> ve <command>p2</command> kendi yerel <command>bar</command> değişkenlerini sonlandırır ve <command>p2</command>'yi çağırmak "undefined local variable or method" hatasına neden olabilir.
  </para>
  <para>
   Yordam nesnelerinin güçlü bir özelliği de bağımsız değişken olarak aktarılabilme yetenekleridir: paylaşımlı yerel değişkenler özgün etki alanının dışından değer aktarıldığında bile geçerli kalırlar.
  </para>
   <screen class="eval">
ruby&gt;<emphasis class="evalinput">def kutu</emphasis>
    |    <emphasis class="evalinput">içerik = 15</emphasis>
    |    <emphasis class="evalinput">getir = proc{ içerik }</emphasis>
    |    <emphasis class="evalinput">ata = proc{ |n| içerik = n }</emphasis>
    |    <emphasis class="evalinput">return getir, ata</emphasis>
    | <emphasis class="evalinput">end</emphasis>
   <emphasis class="evaloutput">:kutu</emphasis>
ruby&gt; <emphasis class="evalinput">okur, yazar = kutu</emphasis>
   <emphasis class="evaloutput">[#&lt;Proc:0x000055e097e472d0 &lt;main&gt;:2&gt;, #&lt;Proc:0x000055e097e47230 &lt;main&gt;:3&gt;]</emphasis>
ruby&gt; <emphasis class="evalinput">okur.call</emphasis>
   <emphasis class="evaloutput">15</emphasis>
ruby&gt; <emphasis class="evalinput">yazar.call(2)</emphasis>
   <emphasis class="evaloutput">2</emphasis>
ruby&gt; <emphasis class="evalinput">okur.call</emphasis>
   <emphasis class="evaloutput">2</emphasis>
</screen>
  <para>
   Ruby etki alanı konusunda bir parça akıllıca davranır. Örneğimizde <command>içerik</command> değişkeni <command>okur</command> ve <command>yazar</command> tarafından paylaşılıyordu. Aynı zamanda yukarıda tanımladığımız kutumuzdan birden çok okur-yazar çifti oluşturabilir ve her çiftin aynı sabiti paylaşmasını sağlayabiliriz.
  </para>
   <screen class="eval">
ruby&gt; <emphasis class="evalinput">okur_1, yazar_1 = kutu</emphasis>
   <emphasis class="evaloutput">[#&lt;Proc:0x000055e097e449e0 &lt;main&gt;:2&gt;, #&lt;Proc:0x000055e097e449b8 &lt;main&gt;:3&gt;]</emphasis>
ruby&gt; <emphasis class="evalinput">okur_2, yazar_2 = kutu</emphasis>
   <emphasis class="evaloutput">[#&lt;Proc:0x000055e097e44c88 &lt;main&gt;:2&gt;, #&lt;Proc:0x000055e097e44e40 &lt;main&gt;:3&gt;]</emphasis>
ruby&gt; <emphasis class="evalinput">yazar_1.call(99)</emphasis>
   <emphasis class="evaloutput">99</emphasis>
ruby&gt; <emphasis class="evalinput">okur_1.call</emphasis>
   <emphasis class="evaloutput">99</emphasis>
ruby&gt; <emphasis class="evalinput">okur_2.call</emphasis>
   <emphasis class="evaloutput">15</emphasis>
</screen>
 </chapter>
 <chapter xml:id="ruby-ug-constants">
  <?dbhtml stop-chunking?>
  <title>Sınıf Sabitleri</title>
  <para>
   Bir sabit büyük harfle başlayan bir ada sahiptir. Sabitlere bir kere değer ataması yapılmalıdır. Ruby'nin şu anki uygulamasına göre, sabitlere yeniden değer ataması yapmak hata değil uyarı ile sonuçlanır (<filename>eval.rb</filename>'nin ANSI olmayan sürümü uyarı değil hata raporlar):
  </para>
   <screen class="eval">
ruby&gt; <emphasis class="evalinput">fluid=30</emphasis>
    <emphasis class="evaloutput">30</emphasis>
ruby&gt; <emphasis class="evalinput">fluid=31</emphasis>
    <emphasis class="evaloutput">31</emphasis>
ruby&gt; <emphasis class="evalinput">Solid=32</emphasis>
    <emphasis class="evaloutput">32</emphasis>
ruby&gt; <emphasis class="evalinput">Solid=33</emphasis>
&lt;main&gt;: warning: already initialized constant Solid
   <emphasis class="evaloutput">33</emphasis>
</screen>
  <para>
   Sabitler sınıflarla beraber tanımlanabilir ancak örnek değişkenlerin aksine sınıfın dışından da erişilebilir durumdadır.
  </para>
   <screen class="eval">
ruby&gt; <emphasis class="evalinput">class SabitSınıfı</emphasis>
    |    <emphasis class="evalinput">C1=101</emphasis>
    |    <emphasis class="evalinput">C2=102</emphasis>
    |    <emphasis class="evalinput">C3=103</emphasis>
    |    <emphasis class="evalinput">def göster</emphasis>
    |       <emphasis class="evalinput">print C1," ",C2," ",C3,"\n"</emphasis>
    |    <emphasis class="evalinput">end</emphasis>
    | <emphasis class="evalinput">end</emphasis>
   <emphasis class="evaloutput">:göster</emphasis>
ruby&gt; <emphasis class="evalinput">C1</emphasis>
<emphasis class="evaloutput">ERR: uninitialized constant C1</emphasis>
ruby&gt; <emphasis class="evalinput">SabitSınıfı::C1</emphasis>
   <emphasis class="evaloutput">101</emphasis>
ruby&gt; <emphasis class="evalinput">SabitSınıfı.new.göster</emphasis>
101 102 103
   <emphasis class="evaloutput">nil</emphasis>
</screen>
  <para>
   Sabitler aynı zamanda modül içinde de tanımlanabilirler.
  </para>
   <screen class="eval">
ruby&gt;<emphasis class="evalinput">module SabitModülü</emphasis>
    |    <emphasis class="evalinput">C1=101</emphasis>
    |    <emphasis class="evalinput">C2=102</emphasis>
    |    <emphasis class="evalinput">C3=103</emphasis>
    |    <emphasis class="evalinput">def sabitleriGöster</emphasis>
    |       <emphasis class="evalinput">print C1," ",C2," ",C3,"\n"</emphasis>
    |    <emphasis class="evalinput">end</emphasis>
    | <emphasis class="evalinput">end</emphasis>
   <emphasis class="evaloutput">:sabitleriGöster</emphasis>
ruby&gt; <emphasis class="evalinput">C1</emphasis>
<emphasis class="evaloutput">ERR: uninitialized constant C1</emphasis>
ruby&gt; <emphasis class="evalinput">include SabitModülü</emphasis>
   <emphasis class="evaloutput">Object</emphasis>
ruby&gt; <emphasis class="evalinput">C1</emphasis>
   <emphasis class="evaloutput">101</emphasis>
ruby&gt; <emphasis class="evalinput">sabitleriGöster</emphasis>
101 102 103
   <emphasis class="evaloutput">nil</emphasis>
ruby&gt; <emphasis class="evalinput">C1=99</emphasis>  # pek iyi bir fikir değil
   <emphasis class="evaloutput">99</emphasis>
ruby&gt; <emphasis class="evalinput">C1</emphasis>
   <emphasis class="evaloutput">99</emphasis>
ruby&gt; <emphasis class="evalinput">SabitModülü::C1</emphasis>  # modülün sabiti rahatsız edilmemiş...
   <emphasis class="evaloutput">101</emphasis>
ruby&gt; <emphasis class="evalinput">SabitModülü::C1=99</emphasis>  # önceki sürümlerde buna izin verilmez
&lt;main&gt;: warning: already initialized constant SabitModülü::C1
&lt;main&gt;:1: warning: previous definition of C1 was here
   <emphasis class="evaloutput">99</emphasis>
ruby&gt; <emphasis class="evalinput">SabitModülü::C1</emphasis>  # sen iste yeter ki...
   <emphasis class="evaloutput">99</emphasis>
</screen>
 </chapter>
 <chapter xml:id="ruby-ug-rescue">
  <?dbhtml stop-chunking?>
  <title>Hata İşleme: <literal>rescue</literal> deyimi</title>
  <para>
   Çalıştırılan bir yazılım beklenmeyen sorunlar doğurabilir. Okunmaya çalışılan bir dosya mevcut olmayabilir ya da veri kaydetmemek istediğimiz disk dolu olabilir yada kullanıcı beklenmeyen bir girdi yapabilir.
  </para>
   <screen class="eval">
ruby&gt; <emphasis class="evalinput">file = open("bir_dosya")</emphasis>
<emphasis class="evaloutput">ERR: No such file or directory @ rb_sysopen - bir_dosya</emphasis>
</screen>
  <para>
   Güçlü bir yazılım bu gibi durumları hassasiyetle yakalayacaktır. C yazılımcılarından, hata doğurabilecek her sistem çağrısının sonucunu kontrol etmeleri ve anında ne yapılacağına ilişkin karar vermeleri beklenir:
  </para>
   <screen>
FILE *file = fopen("bir_dosya", "r");
if (file == NULL) {
  fprintf( stderr, "Dosya mevcut değil.\n" );
  exit(1);
}
bytes_read = fread( buf, 1, bytes_desired, file );
if (bytes_read != bytes_desired ) {
  /* hata giderme işlemleri... */
}
...
</screen>
  <para>
   Bu yazılımcıları dikkatsizliğe ve ihmalciliğe iten, üstelik hataları tam olarak yakalayamayan bir yazılım geliştirmenize yol açan sıkıcı bir uygulamadır. Öte yandan, işi doğru düzgün yapmak, yakalanabilecek bir çok hata olduğu için yazılımın okunabilirliğini oldukça zorlaştıracaktır.
  </para>
  <para>
   Güncel bir çok dilde olduğu gibi Ruby'de de, yazılımcıyı ya da sonradan kodumuzu okuyan kişileri sıkıntıya sokmadan, sürprizleri kod bloklarından soyutlayan bir yolla yakalayabiliriz.
  </para>
  <para>
   <command>begin</command> ile işaretlenmiş kod bloğu bir istisnayla karşılaşana dek çalıştırılır, hata durumunda denetimi <command>rescue</command> ile işaretlenmiş kod bloğuna verir. Eğer hiçbir istisnayla karşılaşılmazsa <command>rescue</command> kodu kullanılmaz. Aşağıdaki yöntem bir metin dosyasının ilk satırını, bir istisna ile karşılaşırsa <command>nil</command> döndürür:
  </para>
   <screen>
def first_line( filename )
  begin
    file = open("bir_dosya")
    info = file.gets
    file.close
    info  # Değerlendirmeye alınan son şey dönüş değeri
  rescue
    nil   # Dosyayı okuyamıyor musunuz? O zaman bir ileti dönmez.
  end
end
</screen>
  <para>
   Bir sorunla yaratıcı bir biçimde ilgilenmek istediğimiz zamanlar olacaktır. Örneğin dosyaya erişmek mümkün değilse standart girdi yerine başka bir şey kullanmak isteyebiliriz:
  </para>
   <screen>
begin
  file = open("bir_dosya")
rescue
  file = STDIN
end

begin
  # ... girdiyi değerlendir ...
rescue
  # ... burada diğer istisnalarla uğraş.
end
</screen>
  <para>
   <command>begin</command> kodunu tekrar çalıştırmak için <command>rescue</command>'nun içinde <command>retry</command> kullanabiliriz. Bu bize önceki örneğimizi daha kısa şekilde yazmamıza izin verir:
  </para>
   <screen>
fname = "bir_dosya"
begin
  file = open(fname)
  # ... girdiyi degerlendir ...
rescue
  fname = "STDIN"
  retry
end
</screen>
  <para>
   Ancak burada bir kusur bulunmaktadır. Hiç olmayan bir dosya bu kodun sonsuz bir döngüde kendisini tekrar etmesini sağlayacaktır. <command>retry</command> kullanırken bu tür durumlara dikkat etmelisiniz.
  </para>
  <para>
   Her Ruby kütüphanesi, sizin de kendi kodunuzda yapabileceğiniz gibi, herhangi bir hata karşısında bir istisna oluşturur. Bir istisnayı ortaya çıkarmak için <command>raise</command> kullanılır. <command>raise</command> tek değer olarak istisnayı açıklayan bir dizge alır. Bu değer isteğe bağlıdır ancak atlanmaması gereken bir husustur. Özel değişkenlerden olan <command>$!</command> ile sonradan ulaşılabilir.
  </para>
   <screen class="eval">
ruby&gt; <emphasis class="evalinput">raise "deneme hatası"</emphasis>
<emphasis class="evaloutput">ERR: deneme hatası</emphasis>
ruby&gt; <emphasis class="evalinput">begin</emphasis>
    |    <emphasis class="evalinput">raise "dnm2"</emphasis>
    | <emphasis class="evalinput">rescue</emphasis>
    |    <emphasis class="evalinput">print "Bir hata meydana geldi: ",$!, "\n"</emphasis>
    | <emphasis class="evalinput">end</emphasis>
Bir hata meydana geldi: dnm2
   <emphasis class="evaloutput">nil</emphasis>
</screen>
 </chapter>
 <chapter xml:id="ruby-ug-ensure">
  <?dbhtml stop-chunking?>
  <title>Hata İşleme: <literal>ensure</literal> deyimi</title>
  <para>
   Bazen bir yöntem işini bitirdikten sonra temizlik yapılması gerekebilir. Örneğin açılmış olan bir dosyanın kapatılması ya da bir veri için ayrılan bellek gözesinin boşaltılması gerekebilir. Eğer her yöntem için her zaman tek bir çıkış noktası olsaydı temizleme kodumuzu tek bir yere koyardık ve çalıştırılacağından emin olurduk. Ancak yöntem bir çok yere geri dönebilir ve temizlik kodumuz beklenmeyen istisnalardan dolayı atlanabilir.
  </para>
   <screen>
begin
  file = open("/tmp/bir_dosya", "w")
  # ... dosyaya yaziliyor...
  file.close
end
</screen>
  <para>
   Ayrıca eğer kodun dosyaya yazdığımız kısmında bir istisna meydana gelirse o zaman dosya açık bırakılabilir. Ve böyle bir fazlalığa gitmek istemeyiz:
  </para>
   <screen>
begin
  file = open("/tmp/bir_dosya", "w")
  # ... dosyaya yazılıyor ...
  file.close
rescue
  file.close
  fail # istisna yakalanıyor
end
</screen>
  <para>
   Bu hantal bir yöntemdir; her <command>return</command> ve <command>break</command> ile ilgilenmek zorunda kalınca işler çığrından çıkar.
  </para>
  <para>
   Bu yüzden "<command>begin...rescue...end</command>" şemasına <command>ensure</command> adında başka bir anahtar kelime daha ekleriz. <command>ensure</command> kodu <command>begin</command> kodunun başarılı olup olmadığına bakmaksızın çalıştırılır.
  </para>
   <screen>
begin
  file = open("/tmp/bir_dosya", "w")
  # ... dosyaya yazılıyor ...
rescue
  # ... istisnalar yakalanıyor...
ensure
  file.close   # ...her zaman yapılması gerekir
end
</screen>
  <para>
   <command>ensure</command> kodunu <command>rescue</command> olmadan da kullanmak mümkündür ya da tam tersi; ancak aynı <command>begin...end </command> bloğunda birlikte kullanılıyorlarsa <command>rescue</command>, <command>ensure</command>'den önce gelmelidir.
  </para>
 </chapter>
 <chapter xml:id="ruby-ug-accessors">
  <?dbhtml stop-chunking?>
  <title>Erişim Yöntemleri</title>
  <para>
   Geçtiğimiz bölümlerde örnek değişkenlerden kısaca bahsettik ancak henüz işimiz bitmedi. Bir nesnenin örnek değişkenleri onun kendisine ait olan ve aynı sınıfa ait diğer nesnelerden ayıran öznitelikleridir.
  </para>
  <para>
   Bu öznitelikleri okuyabilmek ve yazabilmek önemlidir; bu yüzden <wordasword>özniteliğe erişim yöntemleri</wordasword>ni kullanırız. Bir kaç dakika sonra erişim yöntemlerini her zaman açıkça yazmak zorunda olmadığımızı göreceksiniz ancak şimdilik tüm hareketlere bakalım. Erişim yöntemleri iki çeşittir: <emphasis>yazıcılar</emphasis> ve <emphasis>okuyucular</emphasis>.
  </para>
   <screen class="eval">
ruby&gt;<emphasis class="evalinput">class Meyve</emphasis>
    |    <emphasis class="evalinput">def çesit_ata(k)  # bir yazıcı</emphasis>
    |       <emphasis class="evalinput">@çeşidi = k</emphasis>
    |    <emphasis class="evalinput">end</emphasis>
    |    <emphasis class="evalinput">def ne_çesit     # bir okuyucu</emphasis>
    |       <emphasis class="evalinput">@çeşidi</emphasis>
    |    <emphasis class="evalinput">end</emphasis>
    | <emphasis class="evalinput">end</emphasis>
   <emphasis class="evaloutput">:ne_çesit</emphasis>
ruby&gt; <emphasis class="evalinput">f1 = Meyve.new</emphasis>
   <emphasis class="evaloutput">#&lt;Meyve:0x000055f8e47a11c8&gt;</emphasis>
ruby&gt; <emphasis class="evalinput">f1.çesit_ata("şeftali")</emphasis>  # yazıcıyı kullan
   <emphasis class="evaloutput">"şeftali"</emphasis>
ruby&gt; <emphasis class="evalinput">f1.ne_çesit</emphasis>           # okuyucuyu kullan
   <emphasis class="evaloutput">"seftali"</emphasis>
ruby&gt; <emphasis class="evalinput">f1</emphasis>                    # nesneyi yokla
   <emphasis class="evaloutput">#&lt;Meyve:0x000055f8e47a11c8 @çeşit="şeftali"&gt;</emphasis>
</screen>
  <para>
   Yeterince basit; baktığımız meyve hakkında istediğimiz bilgiyi yerleştirebilir ya da erişebiliriz. Ama yöntem isimlerimiz biraz uzun. Aşağıdaki daha kısa ve daha bilindik:
  </para>
   <screen class="eval">
ruby&gt;<emphasis class="evalinput">class Meyve</emphasis>
    |    <emphasis class="evalinput">def çeşidi=(k)</emphasis>
    |       <emphasis class="evalinput">@çeşidi = k</emphasis>
    |    <emphasis class="evalinput">end</emphasis>
    |    <emphasis class="evalinput">def çeşidi</emphasis>
    |       <emphasis class="evalinput">@çeşidi</emphasis>
    |    <emphasis class="evalinput">end</emphasis>
    | <emphasis class="evalinput">end</emphasis>
   <emphasis class="evaloutput">:çeşidi</emphasis>
ruby&gt; <emphasis class="evalinput">f2 = Meyve.new</emphasis>
   <emphasis class="evaloutput">#&lt;Meyve:0x000055f8e44c28a8&gt;</emphasis>
ruby&gt; <emphasis class="evalinput">f2.çeşidi = "üzüm"</emphasis>
   <emphasis class="evaloutput">"üzüm"</emphasis>
ruby&gt; <emphasis class="evalinput">f2.çeşidi</emphasis>
   <emphasis class="evaloutput">"üzüm"</emphasis>
</screen>
  <sect1 xml:id="ruby-ug-inspect">
   <title><literal>inspect</literal> yöntemi</title>
   <para>
    Küçük bir uzlaşma sağlanmıştır. Bir nesneye doğrudan ulaşmak istediğimizde <command>#&lt;birNesne:0x83678&gt;</command> gibi şifreye benzer birşeyle karşılaştığımıza dikkat edin. Bu öntanımlı bir davranıştır ve istediğiniz gibi değiştirebilirsiniz. Yapmanız gerek tek şey <command>inspect</command> yöntemini eklemektir. <command>inspect</command> yöntemi, nesneyi birkaç ya da bütün örnek değişkenleri de içeren ve mantıklı bir şekilde tanıtan bir yöntemdir.
  </para>
   <screen class="eval">
ruby&gt;<emphasis class="evalinput">class Meyve</emphasis>
    |    <emphasis class="evalinput">def inspect</emphasis>
    |       <emphasis class="evalinput">@çeşidi + " bir meyve çeşididir"</emphasis>
    |    <emphasis class="evalinput">end</emphasis>
    | <emphasis class="evalinput">end</emphasis>
   <emphasis class="evaloutput">:inspect</emphasis>
ruby&gt; <emphasis class="evalinput">f2</emphasis>
   <emphasis class="evaloutput">üzüm bir meyve çeşididir</emphasis>
</screen>
  <para>
   Benzer bir yöntem de ekrana bir nesne yazdıracağımız zaman kullandığımız <command>to_s</command> (dizgeye dönüştürür) yöntemidir. Genel olarak <command>inspect</command> yöntemini yazılım geliştirirken ve hata ayıklarken kullandığınız bir araç olarak, <command>to_s</command>'yi de  yazılımın çıktısını düzeltmek için kullandığımız  bir yol düşünebilirsiniz.
  </para>
  <para>
   <filename>eval.rb</filename> sonuçları görüntülemek için her zaman <command>inspect</command> yöntemini kullanır.
  </para>
  <para>
   <command>p</command> yöntemini, yazılımlarınızdan hata ayıklama çıktısı almak için kullanabilirsiniz.
  </para>
   <screen>
# Bu iki satır eşdeğerdir:
p birNesne
print birNesne.inspect, "\n"
</screen>
  </sect1>
  <sect1><title>Erişim yöntemlerini kolay hale getirmek</title>
  <para>
   Her örneğin bir erişim yöntemine ihtiyacı olmasına rağmen, Ruby standart tarzlar için daha elverişli bir yol sunar.
  </para>
  <informaltable>
   <tgroup cols="2" colsep='1' rowsep='1'>
    <colspec colwidth="40%"/>
    <colspec colwidth="60%"/>
    <thead align="left">
     <row>
      <entry>Kısayol</entry>
      <entry>Etkisi</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>
       <command>attr_reader :v</command>
      </entry>
      <entry>
       <command>def v; @v; end</command>
      </entry>
     </row>
     <row>
      <entry>
       <command>attr_writer :v</command>
      </entry>
      <entry>
       <command>def v=(value); @v=value; end</command>
      </entry>
     </row>
     <row>
      <entry>
       <command>attr_accessor :v</command>
      </entry>
      <entry>
       <command>attr_reader :v; attr_writer :v</command>
      </entry>
     </row>
     <row>
      <entry>
       <command>attr_accessor :v, :w</command>
      </entry>
      <entry>
       <command>attr_accessor :v; attr_accessor :w</command>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </informaltable>
  <para>
   Şimdi bunun getirilerinden faydalanalım ve bilgimizi tazeleyelim. Öncelikle otomatik olarak oluşturulmuş bir okuyucu ve yazıcı olup olmadığına bakarız ve yeni bilgiyi <command>inspect</command>'in içine dahil ederiz:
  </para>
   <screen class="eval">
ruby&gt; <emphasis class="evalinput">class Meyve</emphasis>
    |    <emphasis class="evalinput">attr_accessor :nitelik</emphasis>
    |    <emphasis class="evalinput">def inspect</emphasis>
    |       <emphasis class="evalinput">"#{@nitelik} #{@çeşidi}"</emphasis>
    |    <emphasis class="evalinput">end</emphasis>
    | <emphasis class="evalinput">end</emphasis>
   <emphasis class="evaloutput">:inspect</emphasis>
ruby&gt; <emphasis class="evalinput">f2.nitelik = "olgun"</emphasis>
   <emphasis class="evaloutput">"olgun"</emphasis>
ruby&gt; <emphasis class="evalinput">f2</emphasis>
   <emphasis class="evaloutput">olgun üzüm</emphasis>
</screen>
  </sect1>
  <sect1><title>Meyveyle biraz daha eğlence</title>
  <para>
   Eğer kimse olgunlaşmamış meyvemizi yemezse, parasını almak için beklemeliyiz.
  </para>
   <screen class="eval">
ruby&gt;<emphasis class="evalinput">class Meyve</emphasis>
    |    <emphasis class="evalinput">def durumu</emphasis>
    |       <emphasis class="evalinput">@nitelik = "koruk"</emphasis>
    |    <emphasis class="evalinput">end</emphasis>
    | <emphasis class="evalinput">end</emphasis>
   <emphasis class="evaloutput">:durumu</emphasis>
ruby&gt; <emphasis class="evalinput">f2.durumu</emphasis>
   <emphasis class="evaloutput">"koruk"</emphasis>
ruby&gt; <emphasis class="evalinput">f2</emphasis>
   <emphasis class="evaloutput">"koruk üzüm"</emphasis>
</screen>
  <para>
   Ancak buralarda oynarken, küçük bir sorunla karşılaştık. Üçüncü bir meyve yaratmaya çalıştığımızda ne olur? Örnek değişkenlerin onlara değer atanmadan var olmadıklarını hatırlayın.
  </para>
   <screen class="eval">
ruby&gt; <emphasis class="evalinput">f3 = Meyve.new</emphasis>

ruby&gt;
</screen>
  <para>
   Burada yakınılan <command>inspect</command> yöntemidir ve geçerli bir sebebimiz var. <command>f3</command>'e özellik atamadan bir meyvenin çeşidi ve niteliği hakkında bir rapor istedik. Eğer istersek,  <command>inspect</command> yönteminin <command>defined?</command> yöntemini de kullanarak sadece tanımlanmış meyveleri rapor etmesini sağlayabiliriz ancak bu iş hala kullanışsız olur, çünkü her meyvenin bir çeşidi ve niteliği olduğuna göre bu ikisinin her zaman tanımlı olduğundan emin olmamız gerekir. Bu ileriki bölümün konusudur.
  </para>
  </sect1>
 </chapter>
 <chapter xml:id="ruby-ug-oinit">
  <?dbhtml stop-chunking?>
  <title>Nesnenin İlklendirilmesi</title>
  <para>
   Geçen bölümdeki Meyve sınıfı, biri meyvenin çeşidini diğeri de niteliğini açıklayan iki örnek değişkene sahipti. Bunu yapmamızın nedeni bir kaç meyve için karakteristiğin önemli olmamasıydı ve amacımız genel bir <command>inspect</command> yöntemi oluşturmaktı. Ruby örnek değişkenlerin her zaman hazırlanmış olduğunu garanti eden bir yol sunuyor.
  </para>
  <sect1><title><literal>initialize</literal> yöntemi</title>
  <para>
   Ruby yeni bir nesne örneklendiği zaman <command>initialize</command> denen bir yöntem arar ve çalıştırır. Yapabileceğimiz basit şeylerden biri her örnek değişkene öntanımlı bir <command>initialize</command> yöntemi koymak ve böylece <command>inspect</command> yöntemine söyleyebilecek bir şeyler sağlamaktır.
  </para>
   <screen class="eval">
ruby&gt;<emphasis class="evalinput">class Meyve</emphasis>
    |    <emphasis class="evalinput">def initialize</emphasis>
    |       <emphasis class="evalinput">@çeşidi = "elma"</emphasis>
    |       <emphasis class="evalinput">@nitelik = "olgun"</emphasis>
    |    <emphasis class="evalinput">end</emphasis>
    | <emphasis class="evalinput">end</emphasis>
   <emphasis class="evaloutput">:initialize</emphasis>
ruby&gt; <emphasis class="evalinput">f4 = Meyve.new</emphasis>
   <emphasis class="evaloutput">"olgun elma"</emphasis>
</screen>
  </sect1>
  <sect1><title>Öntanımlı değerlerin değiştirilmesi</title>
  <para>
   Bazen öntanımlı değerlerin pek de anlamlı olmadığı zamanlar olabilir. Öntanımlı bir meyve çeşidi gibi birşey olabilir mi? Her meyvenin yaratıldığı zaman kendi çeşidini belirlemesi daha tercih edilebilir bir durumdur. Bunu yapmak için <command>initialize</command> yöntemine bir bağımsız değişken ekleriz. Burada bahsetmeyeceğimiz nedenlerden dolayı <command>new</command>'e verdiğiniz her bağımsız değişken <command>initialize</command> yöntemi tarafından alınmış olur.
  </para>
   <screen class="eval">
ruby&gt; <emphasis class="evalinput">class Meyve</emphasis>
    |    <emphasis class="evalinput">def initialize( k )</emphasis>
    |       <emphasis class="evalinput">@çeşidi = k</emphasis>
    |       <emphasis class="evalinput">@nitelik = "olgun"</emphasis>
    |    <emphasis class="evalinput">end</emphasis>
    | <emphasis class="evalinput">end</emphasis>
   <emphasis class="evaloutput">:initialize</emphasis>
ruby&gt; <emphasis class="evalinput">f5 = Meyve.new "mango"</emphasis>
   <emphasis class="evaloutput">"olgun mango"</emphasis>
ruby&gt; <emphasis class="evalinput">f6 = Meyve.new</emphasis>
<emphasis class="evaloutput">ERR: wrong number of arguments (given 0, expected 1)</emphasis>
</screen>
  </sect1>
  <sect1><title>Esnek ilklendirme</title>
  <para>
   Yukarıda gördüğümüz gibi bir bağımsız değişkeni <command>initialize</command> yöntemi ile ilişkilendirirseniz boş değer vermeniz durumunda hatayla karşılaşırsınız. Daha düşünceli davranmak istersek, değer verildiği zaman o değeri kullanabilir, verilmediği zamansa öntanımlı bir değer atayabiliriz.
  </para>
   <screen class="eval">
ruby&gt; <emphasis class="evalinput">class Meyve</emphasis>
    | <emphasis class="evalinput">def initialize( k="elma" )</emphasis>
    |       <emphasis class="evalinput">@çeşidi = k</emphasis>
    |       <emphasis class="evalinput">@nitelik = "olgun"</emphasis>
    |    <emphasis class="evalinput">end</emphasis>
    | <emphasis class="evalinput">end</emphasis>
   <emphasis class="evaloutput">:initialize</emphasis>
ruby&gt; <emphasis class="evalinput"> f5 = Meyve.new "mango"</emphasis>
   <emphasis class="evaloutput">"olgun mango"</emphasis>
ruby&gt; <emphasis class="evalinput"> f6 = Meyve.new</emphasis>
   <emphasis class="evaloutput">"olgun elma"</emphasis>
</screen>
  <para>
   Öntanımlı değerleri sadece <command>initialize</command> için değil tüm yöntemler için uygulayabilirsiniz.
  </para>
  <para>
   Bazen bir nesneyi hazırlamak için birçok yol hazırlamak yararlı olabilir. Bu kılavuzun kapsamının dışında olmasına rağmen Ruby, yöntemleri aşırı yüklemeyi sağlayan nesne yansıtmaya (<emphasis>object reflection</emphasis>) ve değişken uzunluklu bağımsız değişken listesine izin verir.
  </para>
  </sect1>
 </chapter>
 <chapter xml:id="ruby-ug-misc">
  <?dbhtml stop-chunking?>
  <title>Sona Kalanlar</title>
  <para>
   Bu bölüm pratik bir kaç konuyu kapsar.
  </para>
  <sect1><title>Deyim sınırlayıcılar</title>
  <para>
   Bazı diller deyimleri sonlandırmak için, noktalı virgül <command>;</command> gibi  noktalama işaretleri gerektirir. Ruby bunun yerine <command>sh</command> ve <command>csh</command>'ın geleneğini takip eder. Birden fazla deyim noktalı virgülle ayrılmalıdır ancak bir satırın sonuna noktalı virgül koymanız gerekmez, satır sonu karakteri bir noktalı virgülmüş gibi davranır. Eğer bir satır tersbölü (<command>\</command>) ile biterse o zaman onu takip eden satır sonu karakteri dikkate alınmaz, bu da çok sayıda satıra bölünmüş tek bir satır oluşturmanızı sağlar.
  </para>
  </sect1>
  <sect1><title>Yorum Satırları</title>
  <para>
   Niçin yorum yazmalıyız? İyi yazılmış bir kodun kendi kendini belgelemesi yanında başkalarının da çiziktirdiğimiz koda bakabileceği ihtimalini göz ardı etmemeliyiz. Öte yandan siz ve kendiziniz iki gün önceki sizle farklı kişilersiniz; hangimiz uzun bir süre sonra bakıp, "bunu yazdığımı hatırlıyorum, ama ne cehennemi kastettim!" dememişizdir ki?
  </para>
  <para>
   Bazı deneyimli yazılımcılar, güncelliğini yitirmiş ve tutarsız yorumların hiç yorum yazmamaktan daha kötü olduğuna dikkat çeker. Tabii ki yorumlar okunabilir bir kodun vekili olmamalıdır; eğer kodunuz yeterince açık değilse muhtemelen yanlışlarla doludur. Ruby'yi öğrenirken yorum yazmaya sık sık ihtiyacınız olacak, ancak daha iyi duruma geldiğiniz zaman basit, şık ve okunabilir kodlar yazmaya başladığınızda  daha az yorum satırına ihtiyaç duyacaksınız.
  </para>
  <para>
   Ruby yorum satırını belirtmek için <command>#</command> işareti kullanarak betik dillerinin izlediği geleneksel yolu izler. <command>#</command> ile başlayan her satır yorumlayıcı tarafından gözardı edilir.
  </para>
  <para>
   Ayrıca büyük yorum bloklarını mümkün kılmak için Ruby yorumlayıcısı "<command>=begin</command>" ve "<command>=end</command>" arasındaki satırları da gözardı eder.
  </para>
   <screen>
#!/usr/bin/env ruby

=begin
**********************************************************************
  Bu bir yorum öbeği. Daha sonra kodunuzu okuyanların (kendiniz de dahil)
  rahatlıla kodunuzu anlayabilmeleri için bir şeyler yazabilirsiniz.
  Yorumlayıcı bu öbeği görmezden gelir. Her satır başında '#' işaretine
  ihtiyacımız yok.
**********************************************************************
=end
</screen>
 </sect1>
 <sect1><title>Kodunuzu düzenlemek</title>
  <para>
   Ruby yorumlayıcısı kodları okuduğu gibi işletir. Derleme aşaması gibi bir şey söz konusu değildir; eğer birşey henüz okunmamışsa basitçe <emphasis>tanımsızdır</emphasis>.
  </para>
   <screen>
#sonuç bir tanımsız yöntem ("undefined method") hatası olacaktır:

print successor(3),"\n"

def successor(x)
  x + 1
end
</screen>
  <para>
   Bu, ilk bakışta öyle gibi gözükse de, kodunuzu baştan aşağı bir tasarım harikasına dönüştürmeniz için zorlamaz. Yorumlayıcı, bir yöntem tanımlamasıyla karşılaştığında tanımlanmamış  başvuruları da rahatlıkla ekleyebilir ve yöntem çağrıldığında tanımlı olabileceğinden emin olabilirsiniz:
  </para>
   <screen>
# fahrenhaytı santigrata çevirir,
# iki adımdan olusur.

def f_to_c(f)
  scale(f - 32.0)
end

def scale(x)
  x * 5.0 / 9.0
end

printf "%.1f iyi bir sıcaklık.\n", f_to_c(72.3)
</screen>
  <para>
   Perl ya da Java'da alıştığınızdan daha az elverişli olsa da prototip yazmadan C yazmaktan daha az kısıtlayıcıdır. Bir kaynak kodunun altındaki kodu en üste koymak her zaman çalışır. Üstelik başlangıçta göründüğünden daha az can sıkıcıdır. Tanımlamak istediğiniz davranışı yaptırmak için en ağrısız ve uygun yol dosyanın başında bir <command>main</command> işlevi tanımlamak ve en altta çağırmaktır.
  </para>
   <screen>
#!/usr/bin/env ruby

def main
  # Ana mantığı burada açıklayın...
end

# ... destek kodunu buraya koyun ...

main # ... burada çalıştırmaya başlayın.
</screen>
  <para>
   Bu yöntem ayrıca Ruby'nin karmaşık yazılımları, okunabilir, tekrar kullanılabilir ve mantıksal ilişkilendirilmiş parçalara bölünmesini desteklemesine yardımcı olur. Daha önce modüllere ulaşmak için <command>include</command> özelliğinin kullanımını görmüştük. Ayrıca <command>load</command> ve <command>require</command> özellikleri de yararlı olabilir. <command>load</command> başvurduğu dosya kopyalanıp yapıştırılmış gibi işlev görür (C'deki #include ön işlemcisine benzer). <command>require</command> biraz daha yetenekli bir özelliktir: kodun bir kere ve ihtiyaç duyulduğu zaman yüklenmesini sağlar. <command>load</command> ve <command>require</command> arasındaki diğer farklılıklar için Ruby SSS'a bakın.
 </para>
 </sect1>
 <sect1><title>İşte bu kadar!</title>
  <para>
   Bu kılavuz Ruby'de yazılım geliştirmeye başlamanıza yetecek kadar bilgi içerir. Eğer başka sorularınız olursa  <link xlink:href="http://www.ruby-lang.org/">Ruby sitesine</link> göz atabilirsiniz. <link xlink:href="http://www.ruby-lang.org/en/documentation/faq/">Ruby SSS</link> ve <link xlink:href="http://www.ruby-lang.org/en/libraries/">Ruby Başvuru Kütüphanesi</link> de yararlı kaynaklardan bir kaç tanesidir.
  </para>
  <para>
   Şansınız bol olsun, iyi kodlamalar!
  </para>
  </sect1>
 </chapter>
 <chapter xml:id="ruby-ug-about">
  <?dbhtml stop-chunking?>
  <title>Kılavuz Hakkında</title>
  <para>
   Bu kılavuz çeşitli yerlerde yayınlanmış ve bir çok da çevirisi vardır. Güncel ingilizce sürüm <link xlink:href="https://ruby-doc.org/docs/ruby-doc-bundle/UsersGuide/rg/index.html"/> adresinde bulunur. Eğer güncelliğini kaybetmiş bir sürümle karşılaşırsanız, yansının yöneticisini lütfen uyarın.
 </para>
 <itemizedlist><title>Belge Geçmişi</title>
   <listitem>
    <para>
     Özgün Japonca sürüm <link xlink:href="https://github.com/matz">Yukihiro Matsumoto</link> tarafından yazılmıştır.
    </para>
   </listitem>
   <listitem>
    <para>
     <link xlink:href="http://w.math.sci.hokudai.ac.jp/~gotoken/ruby/ruby-uguide/">İlk İngilizce çeviri</link> GOTO Kentaro ve Julian Fondren tarafından yapıldı.
    </para>
   </listitem>
   <listitem>
    <para>
     Mark Slagell tarafından belge yeniden çevrildi ve bazı eklemeler yapıldı.
    </para>
   </listitem>
  </itemizedlist>
 </chapter>
</book>
