<?xml version="1.0" encoding="UTF-8"?>
<!-- ********************************************************************
         ruby-ug.xml
     ******************************************************************** -->
<part xml:id="ruby-ug" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:lang="tr">
 <?dbhtml dir="../uygulamalar/ruby"?>
 <info>
  <title>Ruby Kullanıcı Kılavuzu</title>
  <authorgroup>
   <author role="translator">
    <personname>
     <firstname>Pınar Yanardağ</firstname>
    </personname>
   </author>
   <author>
    <personname>
     <firstname>Mark Slagell</firstname>
    </personname>
   </author>
  </authorgroup>
  <pubdate>22 Nisan 2003</pubdate>
  <revhistory>
   <revision>
    <revnumber>1.0</revnumber>
    <date>Temmuz 2005</date>
    <authorinitials>PY</authorinitials>
    <revremark>Çevirinin ilk sürümü.
         </revremark>
   </revision>
   <revision>
    <revnumber>-</revnumber>
    <date>30 Mart 2003</date>
    <authorinitials>MS</authorinitials>
    <revremark>Özgün belge Japonca'dır. İngilizce sürümünü <uri xlink:href="http://www.rubyist.net/~slagell/ruby/">http://www.rubyist.net/~slagell/ruby/</uri> adresinde bulabilirsiniz.
         </revremark>
   </revision>
  </revhistory>
  <copyright>
   <year>2003</year>
   <holder>Mark Slagel - Özgün belge</holder>
  </copyright>
  <sbr/>
  <copyright>
   <year>2005</year>
   <holder>Pınar Yanardağ - Türkçe çeviri</holder>
  </copyright>
  <legalnotice>
   <para>
Bu belgenin, <emphasis>Ruby Kullanıcı Kılavuzu</emphasis> çevirisinin 1.0 sürümünün <emphasis role="bold">telif hakkı © 2005 <emphasis>Pınar Yanardağ</emphasis>'a</emphasis>, özgün İngilizce sürümünün  <emphasis role="bold">telif hakkı © 2003 <emphasis>Mark Slagel</emphasis>'a</emphasis> aittir. Bu belgeyi, Free Software Foundation tarafından yayınlanmış bulunan GNU Özgür Belgeleme Lisansının 1.2 ya da daha sonraki sürümünün koşullarına bağlı kalarak kopyalayabilir, dağıtabilir ve/veya değiştirebilirsiniz. Bu Lisansın bir kopyasını <link xlink:href="fdl.html">GNU Free Documentation License</link> başlıklı bölümde bulabilirsiniz.
  </para>
   <para>
BU BELGE "ÜCRETSİZ" OLARAK RUHSATLANDIĞI İÇİN, İÇERDİĞİ BİLGİLER İÇİN İLGİLİ KANUNLARIN İZİN VERDİĞİ ÖLÇÜDE HERHANGİ BİR GARANTİ VERİLMEMEKTEDİR. AKSİ YAZILI OLARAK BELİRTİLMEDİĞİ MÜDDETÇE TELİF HAKKI SAHİPLERİ VE/VEYA BAŞKA ŞAHISLAR BELGEYİ "OLDUĞU GİBİ", AŞİKAR VEYA ZIMNEN, SATILABİLİRLİĞİ VEYA HERHANGİ BİR AMACA UYGUNLUĞU DA DAHİL OLMAK ÜZERE HİÇBİR GARANTİ VERMEKSİZİN DAĞITMAKTADIRLAR. BİLGİNİN KALİTESİ İLE İLGİLİ TÜM SORUNLAR SİZE AİTTİR. HERHANGİ BİR HATALI BİLGİDEN DOLAYI DOĞABİLECEK OLAN BÜTÜN SERVİS, TAMİR VEYA DÜZELTME MASRAFLARI SİZE AİTTİR.
  </para>
   <para>
İLGİLİ KANUNUN İCBAR ETTİĞİ DURUMLAR VEYA YAZILI ANLAŞMA HARİCİNDE HERHANGİ BİR ŞEKİLDE TELİF HAKKI SAHİBİ VEYA YUKARIDA İZİN VERİLDİĞİ ŞEKİLDE BELGEYİ DEĞİŞTİREN VEYA YENİDEN DAĞITAN HERHANGİ BİR KİŞİ, BİLGİNİN KULLANIMI VEYA KULLANILAMAMASI (VEYA VERİ KAYBI OLUŞMASI, VERİNİN YANLIŞ HALE GELMESİ, SİZİN VEYA ÜÇÜNCÜ ŞAHISLARIN ZARARA UĞRAMASI VEYA BİLGİLERİN BAŞKA BİLGİLERLE UYUMSUZ OLMASI) YÜZÜNDEN OLUŞAN GENEL, ÖZEL, DOĞRUDAN YA DA DOLAYLI HERHANGİ BİR ZARARDAN, BÖYLE BİR TAZMİNAT TALEBİ TELİF HAKKI SAHİBİ VEYA İLGİLİ KİŞİYE BİLDİRİLMİŞ OLSA DAHİ, SORUMLU DEĞİLDİR.
  </para>
   <para>
Tüm telif hakları aksi özellikle belirtilmediği sürece sahibine aittir. Belge içinde geçen herhangi bir terim, bir ticari isim ya da kuruma itibar kazandırma olarak algılanmamalıdır. Bir ürün ya da markanın kullanılmış olması ona onay verildiği anlamında görülmemelidir.
  </para>
  </legalnotice>
 </info>
 <para role="only.html">Ek - <link xlink:href="fdl.html">GNU Free Documentation License</link></para>
 <chapter xml:id="ruby-ug-whatis">
  <info>
   <title>Ruby Nedir?</title>
  </info>
  <para>
Ruby 'hızlı ve kolay', nesneye yönelik yazılım geliştirmeye yarayan yorumlanan bir betik dilidir.
    </para>
  <para>
Peki bu ne anlama gelmektedir?
    </para>
  <para>
Yorumlanan betik dili:
    </para>
  <para>
   <itemizedlist>
    <listitem>Doğrudan işletim sistemi çağrılarını yapabilme yeteneği</listitem>
    <listitem>Güçlü dizge işlemleri ve düzenli ifadeler</listitem>
    <listitem>Geliştirme sırasına anında geribesleme</listitem>
   </itemizedlist>
  </para>
  <para>
Kolay ve hızlı:
    </para>
  <para>
   <itemizedlist>
    <listitem>Değişken bildirimleri gerekmez</listitem>
    <listitem>Değişken türleri yoktur</listitem>
    <listitem>Sözdizimi basit ve tutarlıdır</listitem>
    <listitem>Bellek yönetimi özdevinimlidir</listitem>
   </itemizedlist>
  </para>
  <para>
Nesneye dayalı olmak:
    </para>
  <para>
   <itemizedlist>
    <listitem>Herşey birer nesnedir</listitem>
    <listitem>Sınıflar, kalıtım, yöntemler, vs.</listitem>
    <listitem>Tekil yöntemler</listitem>
    <listitem>Modüllerle çalışılabilir</listitem>
    <listitem>Yineleyiciler ve sonlandırıcılar</listitem>
   </itemizedlist>
  </para>
  <para>
Ayrıca:
    </para>
  <para>
   <itemizedlist>
    <listitem>Çoklu duyarlıklı tamsayılar</listitem>
    <listitem>Olağandışılık işleme modeli</listitem>
    <listitem>Özdevimli yükleme</listitem>
    <listitem>Evreler</listitem>
   </itemizedlist>
  </para>
  <para>
Yukardaki kavramların bazılarına yabancıysanız, endişelenmeyin, okumaya devam edin. Ruby dili çabuk ve kolay öğrenilir.
  </para>
 </chapter>
 <chapter xml:id="ruby-ug-intro">
  <info>
   <title>Giriş</title>
  </info>
  <para>
Öncelikle sisteminizde Ruby'nin kurulu olup olmadığına bakalım.
Kabuk istemcisinden (burada "<command>$</command>" ile temsil edilmiştir o yüzden <command>$</command> işaretini yazmanıza gerek yok) aşağıdaki kodu yazalım:
    </para>
  <para>
   <screen>$ <command>ruby -v</command>
</screen>
  </para>
  <para>
(<command>-v</command> ruby'nin sürüm bilgilerini yazmasını sağlar),
ve sonra da <literal>Enter</literal> tuşuna basalım.  Eğer sisteminizde Ruby kuruluysa aşağıdakine benzer bir satır görmeniz gerekecek:
  </para>
  <para>
   <screen>ruby 1.6.6 (2001-12-26) [i586-linux]
</screen>
  </para>
  <para>
Eğer Ruby yüklü değilse, sistem yöneticinizle görüşebilir ya da kendiniz kurabilirsiniz.
  </para>
  <para>
Artık Ruby ile oynamaya başlayabiliriz. <command>-e</command> seçeneği ile Ruby yazılımlarını doğrudan komut satırına yerleştirebilirsiniz:
  </para>
  <para>
   <screen>$ <command>ruby -e 'print "merhaba dunya\n"'</command>
merhaba dunya
</screen>
  </para>
  <para>
Daha uzlaşımsal olarak bir Ruby yazılımı bir dosyada saklanabilir.
  </para>
  <para>
   <screen>$ <command>cat &gt; test.rb</command>
print "merhaba dunya\n"
^D
$ <command>cat test.rb</command>
print "merhaba dunya\n"
$ <command>ruby test.rb</command>
merhaba dunya
</screen>
  </para>
  <para><command>^D</command>, <literal>control-D</literal>'yi ifade eder. Yukarıdakiler sadece UNIX ve türevleri için geçerlidir. Eğer DOS kullanıyorsanız şunu deneyin:
  </para>
  <para>
   <screen>C:\<prompt>ruby&gt; </prompt> copy con: test.rb
print "merhaba dunya\n"
^Z
C:\<prompt>ruby&gt; </prompt> type test.rb
print "merhaba dunya\n"
C:\<prompt>ruby&gt; </prompt> ruby test.rb
merhaba dunya
</screen>
  </para>
  <para>
Daha kapsamlı yazılımlar geliştirirken, muhtemelen gerçek bir metin düzenleyiciye ihtiyaç duyacaksınız!
  </para>
  <para>
Bazen şaşırtıcı biçimde karmaşık ve kullanışlı yazılımlar komut satırına sığabilecek minyatür yazılımlarla yapılabilmektedir. Örneğin aşağıdaki yazılım, çalışılan dizindeki tüm C kaynak ve başlık dosyalarında bulunan <command>foo</command>'ları <command>bar</command> ile değiştirir ve orjinal dosyaların <filename>.bak</filename> uzantısıyla yedeklerini alır.
  </para>
  <para>
   <screen>% <command>ruby -i.bak -pe 'sub "foo", "bar"' *.[ch]</command>
</screen>
  </para>
  <para>
Bu yazılım UNIX'in <command>cat</command> komutu gibi çalışır (ama <command>cat</command>'ten daha yavaş çalışır):
  </para>
  <para>
   <screen>$ <command>ruby -pe 0 file</command>
</screen>
  </para>
 </chapter>
 <chapter xml:id="ruby-ug-examples">
  <info>
   <title>Basit Örnekler</title>
  </info>
  <para>
Şimdi faktöriyel hesabı yapan basit bir işlev yazalım. <command>Faktöriyel</command>'in matematiksel tanımı şöyledir:
  </para>
  <para>
   <literallayout class="normal">
    n! = 1                (n==0 ise)
       = n * (n-1)!       (aksi taktirde)
</literallayout>
  </para>
  <para>
Ruby'de bunu aşağıdaki gibi yazabiliriz:
    </para>
  <para>
   <screen>
def fact(n)
  if n == 0
    1
  else
    n * fact(n-1)
  end
end
</screen>
  </para>
  <para>
Tekrarlanan <command>end</command> deyiminin varlığını fark etmiş olmalısınız. Sırf bu yüzden Ruby "Algol benzeri" olarak anılır. (Aslında Ruby'nin sözdizimi Eiffel dilini daha çok andırmaktadır.) Ayrıca <command>return</command> deyiminin eksikliğini de hissetmiş olmalısınız. Bu deyim Ruby için gereksizdir çünkü bir Ruby işlevi değerlendirdiği en son şeyi geri döndürür. <command>return</command> deyimi kullanılabilir ancak gereksizdir.
   </para>
  <para>
Şimdi faktöriyel işlevimizi deneyelim. Ekleyeceğimiz bir satır, bize çalışan bir yazılım sunacaktır:
    </para>
  <para>
   <screen># Sayının faktöriyelini bulan yazılım
# fact.rb olarak kaydedin

def fact(n)
  if n == 0
    1
  else
    n * fact(n-1)
  end
end

print fact(ARGV[0].to_i), "\n"
</screen>
  </para>
  <para>
Burada <command>ARGV</command> komut satırı argümanlarını içeren bir dizidir ve <command>to_i</command> alınan bir dizgeyi tamsayıya çevirmeye yarar.
  </para>
  <para>
   <screen>
$ <command>ruby fact.rb 1</command>
1
$ <command>ruby fact.rb 5</command>
120
</screen>
  </para>
  <para>
Acaba argüman olarak 40 versek çalışır mı? Muhtemelen hesap makineniz taşma hatası verecektir...
    </para>
  <para>
   <screen>
$ <command>ruby fact.rb 40</command>
815915283247897734345611269596115894272000000000
</screen>
  </para>
  <para>
Bu çalışır, üstelik Ruby makinenizin belleğinin izin verdiği kadar tamsayıyla da çalışabilir. 400 için aşağıdaki gibi bir çıktı alacaksınız:
    </para>
  <para>
   <screen>$ <command>ruby fact.rb 400</command>
64034522846623895262347970319503005850702583026002959458684
44594280239716918683143627847864746326467629435057503585681
08482981628835174352289619886468029979373416541508381624264
61942352307046244325015114448670890662773914918117331955996
44070954967134529047702032243491121079759328079510154537266
72516278778900093497637657103263503315339653498683868313393
52024373788157786791506311858702618270169819740062983025308
59129834616227230455833952075961150530223608681043329725519
48526744322324386699484224042325998055516106359423769613992
31917134063858996537970147827206606320217379472010321356624
61380907794230459736069956759583609615871512991382228657857
95493616176544804532220078258184008484364155912294542753848
03558374518022675900061399560145595206127211192918105032491
00800000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000
</screen>
  </para>
  <para>
Sonucun doğruluğunu kontrol edemeyiz ama öyle olması gerekiyor <literal>:)</literal>.
  </para>
  <bridgehead renderas="sect3">Girdi/Değerlendirme döngüsü</bridgehead>
  <para>
Eğer Ruby'yi hiçbir argüman olmadan çağırırsanız, komutları standart girdi olarak alır ve girdinin bitiminde komutları çalıştırır:
  </para>
  <para>
   <screen>
$ <command>ruby</command>
print "merhaba dunya\n"
print "hoscakal dunya\n"
^D
merhaba dunya
hoscakal dunya
</screen>
  </para>
  <para>
Ruby, <command>eval.rb</command> adında bir araç ile gelir. Bu, ruby kodunuzu etkileşimli olarak klavyeden alan ve yazdıklarınızı gösteren bir araçtır. Bu öğreticinin devamında sıkça kullanacağız.
  </para>
  <para>
Eğer ANSI uyumlu bir uçbirimle çalışıyorsanız<footnote><para>Unix altında çalışıyorsanız zaten uçbirim ANSI uyumludur; DOS altında bunu sağlamak için ANSI.SYS veya ANSI.COM yüklemelisiniz.</para></footnote>, ek olarak girintileme yapabilen, kodu renklendirebilen ve uyarılar veren <link xlink:href="http://www.ruby-doc.org/docs/UsersGuide/rg/eval.rb">gelişmiş eval.rb</link>'yi kullanmalısınız. Aksi takdirde, ruby dağıtımının <filename>sample</filename> dizininde bulunan ve ANSI uyumluluğu gerektirmeyen sürümünü kullanabilirsiniz. Kısa bir <command>eval.rb</command> oturumu:
  </para>
  <para>
   <screen>$ <command>ruby eval.rb</command>
<prompt>ruby&gt; </prompt><emphasis role="input">puts "Merhaba dünya.\n"</emphasis>
Merhaba dünya.
   <emphasis role="output">nil</emphasis>
<prompt>ruby&gt; </prompt><emphasis role="input">exit</emphasis>
</screen>
  </para>
  <para><literal>Merhaba dünya</literal>, <literal>puts</literal> ile çıktılandı. Sonraki satırdaki <emphasis role="output">nil</emphasis> ise son değerlemenin sonucunu göstermektedir; ruby, deyimlerle ifadeler arasında bir ayrım yapmaz, yani kod parçalarının değerlendirilmesi temel olarak kodun icra edilmesidir. Burada <emphasis role="output">nil</emphasis>, <literal>print</literal>'in anlamlı bir değer döndürmediğini ifade etmektedir. Son olarak, <emphasis role="input">exit</emphasis> yazarak yorumlayıcı döngüsünü sonlandırıyoruz.
  </para>
  <para>
Bu kılavuzun devamında <prompt>ruby&gt; </prompt> bir <command>eval.rb</command> oturumunun girdi istemi olarak kullanılmış olacaktır.
  </para>
 </chapter>
 <chapter xml:id="ruby-ug-strings">
  <info>
   <title>Dizgeler</title>
  </info>
  <para>
Ruby'de dizgelerle sayısal bir veriymiş gibi işlem yapabilirsiniz. Bir dizge çift ("...") ya da tek ('...') tırnaklı olabilir.
  </para>
  <para>
   <screen>
    <prompt>ruby&gt; </prompt>
    <emphasis role="input">"abc"</emphasis>
    <emphasis role="output">"abc"</emphasis>
    <prompt>ruby&gt; </prompt>
    <emphasis role="input"> 'abc'</emphasis>
    <emphasis role="output">"abc"</emphasis>
   </screen>
  </para>
  <para>
Bazı durumlarda çift ve tek tırnak farklı işlevler görür. Çift tırnaklı bir dizge tersbölü öncelemeli karakterleri kullanmayı ve <command>#{}</command> kullanan gömülü ifadeleri çalıştırmayı mümkün kılar. Halbuki, tek tırnaklı dizgelerle bunlar yapılamaz: ne görürseniz onu alırsınız. Örneğin:
  </para>
  <para>
   <screen><prompt>ruby&gt; </prompt><emphasis role="input"> print "a\nb\nc","\n"</emphasis>
a
b
c
  <emphasis role="output">nil</emphasis>
<prompt>ruby&gt; </prompt><emphasis role="input">print 'a\nb\n',"\n"</emphasis>
a\nb\nc
  <emphasis role="output">nil</emphasis>
<prompt>ruby&gt; </prompt><emphasis role="input">"\n"</emphasis>
  <emphasis role="output">"\n"</emphasis>
<prompt>ruby&gt; </prompt><emphasis role="input">'\n'</emphasis>
  <emphasis role="output">"\\n"</emphasis>
<prompt>ruby&gt; </prompt><emphasis role="input">"\001"</emphasis>
  <emphasis role="output">"\001"</emphasis>
<prompt>ruby&gt; </prompt><emphasis role="input">'\001'</emphasis>
  <emphasis role="output">"\\001"</emphasis>
<prompt>ruby&gt; </prompt><emphasis role="input">"abcd #{5*3} efg"</emphasis>
  <emphasis role="output">"abcd 15 efg"</emphasis>
<prompt>ruby&gt; </prompt><emphasis role="input">var = " abc "</emphasis>
  <emphasis role="output">" abc "</emphasis>
<prompt>ruby&gt; </prompt><emphasis role="input">"1234#{var}5678"</emphasis>
  <emphasis role="output">"1234 abc 5678"</emphasis>
</screen>
  </para>
  <para>
Ruby'nin dizge işlemleri C'ye kıyasla daha esnek ve şıktır.Örneğin <command>+</command> ile iki dizgeyi birleştirebilirsiniz ya da <command>*</command> ile bir dizgeyi birçok kez tekrar ettirebirsiniz:
  </para>
  <para>
   <screen>
    <prompt>ruby&gt; </prompt>
    <emphasis role="input">"foo" + "bar"</emphasis>
    <emphasis role="output">"foobar"</emphasis>
    <prompt>ruby&gt; </prompt>
    <emphasis role="input">"foo" * 2</emphasis>
    <emphasis role="output">"foofoo"</emphasis>
   </screen>
  </para>
  <para>
Dizgeleri birleştirme işi C'de, doğrudan bellek yönetimi nedeniyle oldukça yakışıksızdır:
  </para>
  <para>
   <screen>char *s = malloc(strlen(s1)+strlen(s2)+1);
strcpy(s, s1);
strcat(s, s2);
/* ... */
free(s);
</screen>
  </para>
  <para>
Ruby kullandığımız için dizgelere herhangi bir alan ayırmamıza gerek yok. Bellek yönetimi açısından tamamen özgürüz.
  </para>
  <para>
Aşağıda dizgelerle yapabileceğiniz birkaç örnek var:
  </para>
  <example>
   <info>
    <title>Birleştirme</title>
   </info>
   <para>
    <screen>
     <prompt>ruby&gt; </prompt>
     <emphasis role="input">word = "fo" + "o"</emphasis>
     <emphasis role="output">"foo"</emphasis>
    </screen>
   </para>
  </example>
  <example>
   <info>
    <title>Tekrarlatma</title>
   </info>
   <para>
    <screen>
     <prompt>ruby&gt; </prompt>
     <emphasis role="input">word = word * 2</emphasis>
     <emphasis role="output">"foofoo"</emphasis>
    </screen>
   </para>
  </example>
  <example>
   <info>
    <title>Karakterler seçimi</title>
   </info>
   <para>
Ruby'de karakterlerin tamsayı olduğuna dikkat edelim:
  </para>
   <para>
    <screen><prompt>ruby&gt; </prompt><emphasis role="input">word[0]</emphasis><emphasis role="output">102</emphasis>            # 102, `f' harfinin ASCII kodudur.
<prompt>ruby&gt; </prompt><emphasis role="input">word[-1]</emphasis>
  <emphasis role="output">111</emphasis>            # 111 `o' harfinin ASCII kodudur.
</screen>
   </para>
   <para>
(Negatif indisler dizgenin başlangıcı yerine sonundan itibaren konumlanır.)
  </para>
  </example>
  <example>
   <info>
    <title>Altdizge seçimi</title>
   </info>
   <para>
    <screen>
     <prompt>ruby&gt; </prompt>
     <emphasis role="input">herb = "parsley"</emphasis>
     <emphasis role="output">"parsley"</emphasis>
     <prompt>ruby&gt; </prompt>
     <emphasis role="input">herb[0,1]</emphasis>
     <emphasis role="output">"p"</emphasis>
     <prompt>ruby&gt; </prompt>
     <emphasis role="input">herb[-2,2]</emphasis>
     <emphasis role="output">"ey"</emphasis>
     <prompt>ruby&gt; </prompt>
     <emphasis role="input">herb[0..3]</emphasis>
     <emphasis role="output">"pars"</emphasis>
     <prompt>ruby&gt; </prompt>
     <emphasis role="input">herb[-5..-2]</emphasis>
     <emphasis role="output">"rsle"</emphasis>
    </screen>
   </para>
  </example>
  <example>
   <info>
    <title>Aynılığın sınanması</title>
   </info>
   <para>
    <screen>
     <prompt>ruby&gt; </prompt>
     <emphasis role="input">"foo" == "foo"</emphasis>
     <emphasis role="output">true</emphasis>
     <prompt>ruby&gt; </prompt>
     <emphasis role="input">"foo" == "bar"</emphasis>
     <emphasis role="output">false</emphasis>
    </screen>
   </para>
   <note>
    <para>ruby-1.0 sürümünde yukarıdaki sonuçlar büyük harflidir (TRUE gibi).</para>
   </note>
  </example>
  <para>
Şimdi bu özelliklerin bazılarını hayata geçirelim: Bulmacamız bir "kelimeyi bil" bulmacası ama sanırım "bulmaca" kelimesi fazla mütevazi oldu <command>;)</command>
  </para>
  <para>
   <screen># guess.rb olarak kaydedin
words = ['kestane', 'gurgen', 'palamut']
secret = words[rand(3)]

print "tahmin et? "
while guess = STDIN.gets
  guess.chop!
  if guess == secret
    print "Bildin!\n"
    break
  else
    print "Üzgünüm kaybettin.\n"
  end
  print "tahmin et? "
end
print "Kelime ", secret, ".\n"
</screen>
  </para>
  <para>
Şimdilik kodun ayrıntıları hakkında fazla kafa yormayalım. Aşağıda yazılımın nasıl çalışması gerektiği görülüyor:
  </para>
  <para>
   <screen>$ <command>ruby guess.rb</command>
tahmin et? kestane
Üzgünüm kaybettin.
tahmin et? gurgen
Üzgünüm kaybettin.
tahmin et? ^D
Kelime palamut.
</screen>
  </para>
  <para>(1/3 olasılığa karşı biraz daha iyi yapmalıydım...)
  </para>
 </chapter>
 <chapter xml:id="ruby-ug-regex">
  <info>
   <title>Düzenli İfadeler</title>
  </info>
  <para>
Şimdi daha ilginç bir yazılım geliştirelim. Bu sefer bir dizgenin verilen bir <wordasword>şablona</wordasword> uyup uymadığını araştıralım:
  </para>
  <para>
Bu şablonlar özel anlamları olan bazı karakterler ve karakter birleşimlerinden oluşur:
  </para>
  <table pgwide="1">
   <info>
    <title>Düzenli ifade işleçleri ve anlamları</title>
   </info>
   <tgroup cols="2" align="left" colsep="1" rowsep="1">
    <colspec colwidth=".1"/>
    <colspec colwidth=".9"/>
    <tbody>
     <row>
      <entry>
       <command>[]</command>
      </entry>
      <entry>
aralık belirtimi (Örn, <literal>[a-z]</literal>, <literal>a</literal> ile <literal>z</literal> arasındaki bir harfi belirtir.)
</entry>
     </row>
     <row>
      <entry>
       <command>\w</command>
      </entry>
      <entry>
harf ya da rakam; <literal>[0-9A-Za-z]</literal> ile aynı
</entry>
     </row>
     <row>
      <entry>
       <command>\W</command>
      </entry>
      <entry>
ne harf ne de rakam
</entry>
     </row>
     <row>
      <entry>
       <command>\s</command>
      </entry>
      <entry>
boşluk karakteri; <literal>[ \t\n\r\f]</literal> ile aynı
</entry>
     </row>
     <row>
      <entry>
       <command>\S</command>
      </entry>
      <entry>
boşluklar dışında herhangi bir karakter
</entry>
     </row>
     <row>
      <entry>
       <command>\d</command>
      </entry>
      <entry>
rakam;  <literal>[0-9]</literal> ile aynı
</entry>
     </row>
     <row>
      <entry>
       <command>\D</command>
      </entry>
      <entry>
rakamlar dışında herhangi bir karakter
</entry>
     </row>
     <row>
      <entry>
       <command>\b</command>
      </entry>
      <entry>
tersbölü (0x08) (sadece herhangi bir aralık belirtilmişse)
</entry>
     </row>
     <row>
      <entry>
       <command>\b</command>
      </entry>
      <entry>
kelime içi sınır belirtimi (aralık belirtiminin dışındayken)
</entry>
     </row>
     <row>
      <entry>
       <command>\B</command>
      </entry>
      <entry>
kelime dışı sınır belirtimi
</entry>
     </row>
     <row>
      <entry>
       <command>*</command>
      </entry>
      <entry>
öncelediği ifadeyi sıfır ya da daha fazla tekrarlar
</entry>
     </row>
     <row>
      <entry>
       <command>+</command>
      </entry>
      <entry>
öncelediği ifadeyi bir ya da daha fazla tekrarlar
</entry>
     </row>
     <row>
      <entry>
       <command>{m,n}</command>
      </entry>
      <entry>
öncelediği ifadeyi en az m en çok n kez tekrarlar
</entry>
     </row>
     <row>
      <entry>
       <command>?</command>
      </entry>
      <entry>
öncelediği ifadeyi en fazla bir kere tekrarlar; <literal>{0,1}</literal> ile aynı
</entry>
     </row>
     <row>
      <entry>
       <command>|</command>
      </entry>
      <entry>
önündeki veya ardındaki ifade eşleşebilir
</entry>
     </row>
     <row>
      <entry>
       <command>()</command>
      </entry>
      <entry>
gruplama işleci
</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  <para>
Bu ilginç lügat genelde <wordasword>düzenli ifadeler</wordasword> olarak anılır. Ruby'de, Perl'de de olduğu gibi çift tırnak koymak yerine ters bölü işareti kullanılır. Eğer daha önce düzenli ifadelerle karşılaşmadıysanız muhtemelen <emphasis>düzenli</emphasis> hiç birşey göremeyeceksiniz ancak alışmak için biraz zamana ihtiyacınız olduğunu unutmayın. Düzenli ifadeler, metin dizgeleri üzerinde arama, eşleştirme ve bu gibi diğer işlerle uğraşırken sizi baş ağrısından (ve satırlarca koddan) kurtaran gözle görülür bir güce sahiptir.
  </para>
  <para>
Örneğin aşağıdaki tanıma uyan bir dizge aradığımızı farzedelim:
"Küçük f harfiyle başlayan, ardından bir büyük harf gelen bundan sonra küçük harf haricinde herhangi bir karakterle devam eden" bir dizge.
Eğer deneyimli bir C yazılımcısıysanız muhtemelen şimdiden kafanızca binlerce satır kod yazmıştınız, öyle değil mi? Kabul edin, kendinize güçlükle yardım edebilirsiniz. Ancak Ruby'de dizgeyi sadece  şu düzenli ifadeyle sınamanız yeterli olacaktır: <command>/^f[A-Z](^[a-z])*$/</command>.
  </para>
  <para>
Köşeli parantezler içindeki bir onaltılık sayıya ne dersiniz? Hiç sorun değil.
  </para>
  <para>
   <screen><prompt>ruby&gt; </prompt><emphasis role="input">def chab(s)</emphasis>   # "parantezler içinde onaltılık içerir"
    <prompt>|   </prompt><emphasis role="input">(s =~ /&lt;0(x|X)(\d|[a-f]|[A-F])+&gt;/) != nil</emphasis>
    <prompt>| </prompt><emphasis role="input">end</emphasis>
   <emphasis role="output">nil</emphasis>
<prompt>ruby&gt; </prompt> <emphasis role="input"> chab "Bu değil."</emphasis>
   <emphasis role="output">false</emphasis>
<prompt>ruby&gt; </prompt> <emphasis role="input"> chab "Belki bu? {0x35}"</emphasis>    # kaşlı ayraçlar kullanılmamalıydı
   <emphasis role="output">false</emphasis>
<prompt>ruby&gt; </prompt> <emphasis role="input"> chab "Ya da bu? &lt;0x38z7e&gt;"</emphasis>    # onaltılık sayı değil
   <emphasis role="output">false</emphasis>
<prompt>ruby&gt; </prompt> <emphasis role="input"> chab "Tamam, bu: &lt;0xfc0004&gt;."</emphasis>
   <emphasis role="output">true</emphasis>
</screen>
  </para>
  <para>
Düzenli ifadeler başlangıçta alengirli gibi gözükse de kısa süre içinde istediğinizi yapabilme konusunda yol katedeceksiniz.
  </para>
  <para>
Aşağıda düzenli ifadeleri anlamanıza yarayacak küçük bir yazılım bulunuyor. <command>regx.rb</command> olarak kaydedin ve komut satırına <command>ruby regx.rb</command> yazarak çalıştırın.
  </para>
  <para>
   <screen>#ANSI terminal gerektirir!

st = "\033[7m"
en = "\033[m"

while TRUE
  print "str&gt; "
  STDOUT.flush
  str = gets
  break if not str
  str.chop!
  print "pat&gt; "
  STDOUT.flush
  re = gets
  break if not re
  re.chop!
  str.gsub! re, "#{st}\\&amp;#{en}"
  print str, "\n"
end
print "\n"
</screen>
  </para>
  <para>
Yazılım bir tanesi dizge diğeri de düzenli ifade olmak üzere iki girdi alır.
Dizge verilen düzenli ifade ile sınanır ve bütün uyuşan sonuçlar listelenir. Şu an ayrıntılara ilgilenmeyin, bu kodun analizini daha sonra yapacağız.
  </para>
  <para>
   <screen>str&gt; foobar
pat&gt; ^fo+
<emphasis role="input">foo</emphasis>bar
~~~
</screen>
  </para>
  <para>
Programın çıktısında gördüğünüz <literal>~~~</literal> ile işaretli parça çıktıda artalan ve önalan renkleri yerdeğiştirmiş olarak çıktılanır.
  </para>
  <para>
Bir kaç girdi daha deneyelim.
  </para>
  <para>
   <screen>str&gt; abc012dbcd555
pat&gt; \d
abc<emphasis role="input">012</emphasis>dbcd<emphasis role="input">555</emphasis>
   ~~~    ~~~
</screen>
  </para>
  <para>
Eğer şaşırdıysanız sayfanın başındaki tabloya tekrar göz atabilirsiniz: <command>\d</command>'nin <command>d</command> karakteriyle hiçbir bağlantısı yoktur, sadece bir rakamı eşleştirmekte kullanılır.
  </para>
  <para>
Eğer istediğimiz kriterlere uygun birden fazla yol varsa ne olur?
  </para>
  <para>
   <screen>str&gt; foozboozer
pat&gt; f.*z
<emphasis role="input">foozbooz</emphasis>er
~~~~~~~~
</screen>
  </para>
  <para>
Düzenli ifadeler olabilecek en uzun dizgeyi döndürdüğü için <command>fooz</command>'un yerine <command>foozbooz</command> eşleştirildi.
  </para>
  <para>
Aşağıda iki nokta üstüste işaretiyle sınırlandırılmış bir zaman alanı bulunuyor:
  </para>
  <para>
   <screen>str&gt; Wed Feb  7 08:58:04 JST 1996
pat&gt; [0-9]+:[0-9]+(:[0-9]+)?
Wed Feb  7 <emphasis role="input">08:58:04</emphasis>  JST 1996
           ~~~~~~~~
</screen>
  </para>
  <para>
"<command>=~</command>" işleci bulduğu dizgenin konumunu döndüren, aksi halde <command>nil</command> döndüren düzenli ifadedir.
  </para>
  <para>
   <screen>
    <prompt>ruby&gt; </prompt>
    <emphasis role="input">"abcdef" =~ /d/</emphasis>
    <emphasis role="output">3</emphasis>
    <prompt>ruby&gt; </prompt>
    <emphasis role="input">"aaaaaa" =~ /d/</emphasis>
    <emphasis role="output">nil</emphasis>
   </screen>
  </para>
 </chapter>
 <chapter xml:id="ruby-ug-arrays">
  <info>
   <title>Diziler</title>
  </info>
  <para>
Ruby'de köşeli parantezler <command>[]</command> arasına elemanları yazarak ve virgüller
yardımıyla ayırarak bir dizi oluşturabilirsiniz. Ruby'de diziler farklı nesne türlerini ayırdedebilecek niteliktedir.
  </para>
  <para>
   <screen>
    <prompt>ruby&gt; </prompt>
    <emphasis role="input">ary = [1, 2, "3"]</emphasis>
    <emphasis role="output">[1, 2, "3"]</emphasis>
   </screen>
  </para>
  <para>
Diziler de aynı dizgeler gibi birleştirilebilir ya da tekrar edilebilir.
  </para>
  <para>
   <screen>
    <prompt>ruby&gt; </prompt>
    <emphasis role="input">ary + ["foo", "bar"]</emphasis>
    <emphasis role="output">[1, 2, "3", "foo", "bar"]</emphasis>
    <prompt>ruby&gt; </prompt>
    <emphasis role="input">ary * 2</emphasis>
    <emphasis role="output">[1, 2, "3", 1, 2, "3"]</emphasis>
   </screen>
  </para>
  <para>
Dizinin herhangi bir elemanına ulaşmak için indisleri kullanabiliriz.
  </para>
  <para>
   <screen>
    <prompt>ruby&gt; </prompt>
    <emphasis role="input">ary[0]</emphasis>
    <emphasis role="output">1</emphasis>
    <prompt>ruby&gt; </prompt>
    <emphasis role="input">ary[0,2]</emphasis>
    <emphasis role="output">[1, 2]</emphasis>
    <prompt>ruby&gt; </prompt>
    <emphasis role="input">ary[0..1]</emphasis>
    <emphasis role="output">[1, 2]</emphasis>
    <prompt>ruby&gt; </prompt>
    <emphasis role="input">ary[-2]</emphasis>
    <emphasis role="output">2</emphasis>
    <prompt>ruby&gt; </prompt>
    <emphasis role="input">ary[-2,2]</emphasis>
    <emphasis role="output">[2, "3"]</emphasis>
    <prompt>ruby&gt; </prompt>
    <emphasis role="input">ary[-2..-1]</emphasis>
    <emphasis role="output">[2, "3"]</emphasis>
   </screen>
  </para>
  <para>
(Negatif indisler dizinin sonundan başlanmasını sağlar.)
  </para>
  <para>
Diziler <command>join</command>  kullanılarak dizgelere ve dizgeler <command>split</command> kullanılarak dizilere dönüştürülebilirler.
  </para>
  <para>
   <screen>
    <prompt>ruby&gt; </prompt>
    <emphasis role="input">str = ary.join(":")</emphasis>
    <emphasis role="output">"1:2:3"</emphasis>
    <prompt>ruby&gt; </prompt>
    <emphasis role="input">str.split(":")</emphasis>
    <emphasis role="output">["1", "2", "3"]</emphasis>
   </screen>
  </para>
  <bridgehead renderas="sect3" xml:id="ruby-ug-hashs">Çırpılar</bridgehead>
  <para>
Çırpılar (hash) elemanlarına indisler yerine herhangi bir değer olabilen  <literal>anahtarlar</literal> yardımıyla erişilebilen özelleştirilmiş dizilerdir.
Böyle dizilere <wordasword>çırpı</wordasword> dendiği gibi <wordasword>isim-değer çiftleri</wordasword> de denir; biz ruby dünyasında çırpı deyimini tercih ederiz. Bir çırpı kaşlı ayraçlar arasına yazılarak oluşturulabilir. Dizilerde herhangi bir elemana ulaşmak için indisleri kullandığımız gibi çırpılarda elemana ulaşmak için anahtarları kullanırız.
  </para>
  <para>
   <screen><prompt>ruby&gt; </prompt><emphasis role="input"> h = {1 =&gt; 2, "2" =&gt; "4"}</emphasis><emphasis role="output">{1=&gt;2, "2"=&gt;"4"}</emphasis><prompt>ruby&gt; </prompt><emphasis role="input"> h[1]</emphasis><emphasis role="output">2</emphasis><prompt>ruby&gt; </prompt><emphasis role="input">h["2"]</emphasis><emphasis role="output">"4"</emphasis><prompt>ruby&gt; </prompt><emphasis role="input">h[5]</emphasis><emphasis role="output">nil</emphasis><prompt>ruby&gt; </prompt><emphasis role="input">h[5] = 10</emphasis>     # değer ekleme
   <emphasis role="output">10</emphasis>
<prompt>ruby&gt; </prompt> <emphasis role="input">h</emphasis>
   <emphasis role="output">{5=&gt;10, 1=&gt;2, "2"=&gt;"4"}</emphasis>
<prompt>ruby&gt; </prompt> <emphasis role="input">h.delete 1</emphasis>   # değer silme
   <emphasis role="output">2</emphasis>
<prompt>ruby&gt; </prompt> <emphasis role="input">h[1]</emphasis>
   <emphasis role="output">nil</emphasis>
<prompt>ruby&gt; </prompt> <emphasis role="input">h</emphasis>
   <emphasis role="output">{5=&gt;10, "2"=&gt;"4"}</emphasis>
</screen>
  </para>
 </chapter>
 <chapter xml:id="ruby-ug-b2examples">
  <info>
   <title>Örneklere Dönüş</title>
  </info>
  <para>
Şimdi eski örneklere tekrar göz atalım.
  </para>
  <para>
Aşağıdakini daha önce  <xref linkend="ruby-ug-examples"/> kısmında görmüştük.
  </para>
  <para>
   <screen>def fact(n)
  if n == 0
    1
  else
    n * fact(n-1)
  end
end
print fact(ARGV[0].to_i), "\n"
</screen>
  </para>
  <para>
Bu bizim ilk örneğimiz olduğu için her satırı teker teker açıklayalım.
  </para>
  <bridgehead renderas="sect3" xml:id="ruby-ug-factorials">Faktöriyeller</bridgehead>
  <para>
   <screen>def fact(n)  </screen>
  </para>
  <para>
İlk satırda bir işlev (ya da daha özel olarak bir <wordasword>yöntem</wordasword>; yöntemin ne olduğunu ileriki kısımlarda göreceğiz) tanımlamak için <command>def</command> deyimini kullanıyoruz. Burada işlevimiz <function>fact</function>'ın <literal>n</literal> adında tek bir argüman aldığını görüyoruz.
    </para>
  <para>
   <screen>if n == 0</screen>
  </para>
  <para><command>if</command> bir denetim deyimidir. Eğer koşul sağlanıyorsa onu takip eden kod değerlendirilir, aksi taktide <command>else</command> kısmına geçilir.
    </para>
  <para>
   <screen>1</screen>
  </para>
  <para>
Eğer koşul sağlandıysa <command>if</command>'in değeri 1 olacaktr.
    </para>
  <para>
   <screen>else</screen>
  </para>
  <para>
Sağlanmadıysa, bu deyimle başlayan <command>end</command> ile biten kod parçası değerlendirilir.
    </para>
  <para>
   <screen>n * fact(n-1)</screen>
  </para>
  <para>
Yani, eğer koşul sağlanmamışsa sonuç <command>n</command> kere <command>fact(n-1)</command> olacaktır.
    </para>
  <para>
   <screen>end</screen>
  </para>
  <para>
İlk <command>end</command>, <command>if</command> deyimini kapatmak için kullanılır.
    </para>
  <para>
   <screen>end</screen>
  </para>
  <para>
İkinci <command>end</command> <command>def</command> ifadesini kapatmak için kullanılır.
    </para>
  <para>
   <screen>print fact(ARGV[0].to_i), "\n"  </screen>
  </para>
  <para>
Bu bizim komut satırından <function>fact()</function> işlevini çalıştırmamızı ve sonuçları ekranda görmemizi sağlar.
    </para>
  <para><command>ARGV</command> komut satırı argümanlarını içeren özel bir dizidir. <command>ARGV</command> dizisinin tüm elemanları dizgeler olduğu için, <command>to_i</command> yöntemiyle tamsayıya dönüştürmek zorundayız. Ruby Perl'deki gibi dizgeleri tamsayılara kendiliğinden dönüştürmez.
    </para>
  <para>
Hmmm... Eğer bu yazılıma negatif bir sayı girersek ne olur? Sorunu görebildiniz mi? Peki düzeltebilir misiniz?
    </para>
  <bridgehead renderas="sect3">Dizgeler</bridgehead>
  <para><xref linkend="ruby-ug-strings"/> bölümündeki bulmaca örneğimizi tekrar inceleyelim. Bu sefer biraz daha uzun, kolaylık açısından satırları numaralandırdık.
    </para>
  <para>
   <screen linenumbering="numbered">
words = ['kestane', 'gurgen', 'palamut']
secret = words[rand(3)]

print "tahmin et? "
while guess = STDIN.gets
  guess.chop!
  if guess == secret
    print "Bildin!\n"
    break
  else
    puts "Üzgünüm kaybettin.\n"
  end
  print "tahmin et? "
end
puts "Kelime ", secret, ".\n"
</screen>
  </para>
  <para>
Bu yazılımda yeni bir denetim yapısı gördük: <command>while</command>.
Verilen koşul doğru olduğu sürece <command>while</command> ve <command>end</command> arasındaki kod tekrar tekrar çalıştırılacaktır.
    </para>
  <para>
2. satırdaki <function>rand(3)</function> işlevi 0 ile 2 arasında rastgele sayı üretir. Bu rastgele sayı <literal>words</literal> dizisinin elemanlarından birini çıkarmak için kullanılır.
    </para>
  <para>
5. satırda <function>STDIN.gets</function> yöntemiyle standart girdiden bir satır okuduk. Eğer satırı alırken <literal>EOF</literal> (end of file) karakterine rastlanırsa <function>gets</function> işlevi <command>nil</command> değerini döndürecektir. <command>while</command> ile ilişkilendirilmiş kod <literal>^D</literal> (ya da DOS altında ^Z) görene kadar tekrarlanacaktır.
    </para>
  <para>
6. satırdaki <function>guess.chop!</function> işlevi <literal>guess</literal> değişkeninin sonundaki satırsonu karakterini temizlemeye yarar.
    </para>
  <para>
15. satırda gizli kelimeyi yazdırıyoruz. Bunu üç argümanla birlikte bir yazdırma deyimi olarak kullandık (birbiri ardına yazdırılarak) ancak bunu daha verimli hale getirmek için <function>secret</function> yerine bir tek argüman alan <function>#(secret)</function> yöntemini tanımlayabilirdik:
    </para>
  <para>
   <screen>puts "Kelime #{secret}.\n"   </screen>
  </para>
  <para>
Birçok yazılımcı, bu yolun çıktı vermek için daha açık olduğunu düşünürler. Tek bir dizge oluşturur ve bu dizgeyi <command>puts</command>'a tek bir argüman gibi sunar.
    </para>
  <para>
Standart betik çıktısında <command>puts</command> kullanma düşüncesini işledik, ancak bu betik 4. ve 13. satırlarda <command>print</command>'i de kullanır. Bu ikisi aynı şey değildir. <command>print</command> dizgeyi kendisine verildiği gibi çıktılarken, <command>puts</command>; aynı zamanda çıktı satırının sonlanmasını sağlar. 4. ve 13. satırlarda <command>print</command> kullanıldığı için, işleç bir sonraki satırın başlangıcına geçeceği yerde, işleci ekrana çıktılanan dizgenin yanında bırakır. Bu durum kullanıcı girdisi için tanınabilir bir durumdur. Aşağıdaki dört çıktı çağrısı da aynı sonucu verir:
    </para>
  <para>
   <screen>
#satırsonu karakteri yoksa, puts tarafından eklenir:
puts  "Tasi delen suyun kuvveti degil, damlalarin sürekliligidir."

#satırsonu karakteri print komutuna verilmelidir:
print "Tasi delen suyun kuvveti degil, damlalarin sürekliligidir.\n"

#çıktıyı + ile birleştirebilirsiniz:
print 'Tasi delen suyun kuvveti degil, damlalarin sürekliligidir.'+"\n"

# ya da birden fazla dizge vererek birleştirebilirsiniz:
print 'Tasi delen suyun kuvveti degil, damlalarin sürekliligidir.', "\n"
</screen>
  </para>
  <bridgehead renderas="sect3">Düzenli İfadeler</bridgehead>
  <para>
Son olarak <xref linkend="ruby-ug-regex"/> bölümündeki yazılımı inceleyeceğiz.
    </para>
  <para>
   <screen linenumbering="numbered">
st = "\033[7m"
en = "\033[m"

while TRUE
  print "str&gt; "
  STDOUT.flush
  str = gets
  break if not str
  str.chop!
  print "pat&gt; "
  STDOUT.flush
  re = gets
  break if not re
  re.chop!
  str.gsub! re, "#{st}\\&amp;#{en}"
  print str, "\n"
end
print "\n"
</screen>
  </para>
  <para>
4. satırda <command>while</command>'ın koşulu sonsuz döngüyü sağlamak için <command>true</command> yapılmıştır. Ancak döngüden çıkabilmek için 8. ve 13. satırlarda <command>break</command> kullandık. Bu iki <command>break</command> aynı zamanda <command>if</command> deyiminin niteleyicilerinden biridir. Bir <emphasis>if niteleyicisi</emphasis> sadece ve sadece koşul sağlandığı zaman sol yandaki terimini çalıştırır.
    </para>
  <para><function>chop!</function> için (9. ve 14 satıra bakın) hakkında söylenecek çok şey var. Ruby'de geleneksel olarak yöntem isimlerinin sonuna '<command>!</command>' ya da '<command>?</command>' ekleriz. Ünlem işareti (<command>!</command> bazen "bang!" diye söylenir) potansiyel olarak yıkıcı bir görev görür, daha da açmak gerekirse; dokunduğu değeri değiştiren bir işleçtir. <function>chop!</function> bir dizgeye doğrudan etki eder ancak ünlem işareti olmayan bir <function>chop</function> bir kopya üzerinde çalışır. Aşağıda ikisi arasındaki fark görülüyor:
    </para>
  <para>
   <screen><prompt>ruby&gt; </prompt><emphasis role="input">s1 = "forth"</emphasis><emphasis role="output">"forth"</emphasis><prompt>ruby&gt; </prompt><emphasis role="input">s1.chop!</emphasis>       # Bu s1'in değerini değiştirir.
  <emphasis role="output">"fort"</emphasis>
<prompt>ruby&gt; </prompt><emphasis role="input">s2 = s1.chop</emphasis>   # s2'ye değiştirilmiş bir kopyasını koyar.
  <emphasis role="output">"for"</emphasis>
<prompt>ruby&gt; </prompt><emphasis role="input">s1</emphasis>             # ... s1'e dokunmaz.
  <emphasis role="output">"fort"</emphasis>
</screen>
  </para>
  <para>
İlerde sonunda soru işareti olan yöntem isimleriyle karşılaşacaksınız (<command>?</command> genelde "huh?" şeklinde telaffuz edilir). Bu <command>true</command> ya da <command>false</command> döndüren bir 'doğrulama' yöntemidir.
    </para>
  <para>
15. satırda dikkat edilmesi gereken önemli bir uyarı yer almaktadır. Öncelikle <function>gsub!</function>'in başka bir sözde 'yıkıcı' yöntem olduğuna dikkat edelim. <literal>re</literal>'ye uyan her ne varsa <literal>str</literal>'nin yerine koyar (<command>sub</command> ikame etmekten (substitute), <command>g</command> ise globalden gelir);  sadece ilk bulunanı değil, dizgedeki <literal>tüm</literal> eşleşen kısımları değiştirir. Çok iyi, çok güzel; fakat eşleştirilen kısımları neyle değiştireceğiz? 1. ve 2 satırda önalan ve artalan renklerini peşpeşe değiştiren <literal>st</literal> ve <literal>en</literal> adlı iki dizge tanımladık.  15. satırdaysa bunları, olduğu gibi yorumlandıklarından emin olmak için <command>#{}</command> arasına yazdık (<emphasis>değişken isimlerinin yazdırıldığını görmeyiz</emphasis>).  Bunların arasında da "<command>\\&amp;</command>" kodunu görüyoruz. Bu küçük bir hiledir. Yer değiştirilen dizge çift tırnak arasında olduğu için  bir çift ters bölü işareti tek bir taneymiş gibi yorumlanır. Böylece <function>gsub!</function>'in göreceği şey "<command>\&amp;</command>" olur ve  bu da ilk konumda ne eşleştirildiyse onu gösteren özel bir koda dönüştürülür. Yani yeni dizge eşleşen parçaları farklı renkte gösterilen eski dizge olur.
  </para>
 </chapter>
 <chapter xml:id="ruby-ug-control">
  <info>
   <title>Denetim Yapıları</title>
  </info>
  <para>
Bu bölümde Ruby'nin denetim yapılarını açıklayacağız.
  </para>
  <variablelist>
   <varlistentry>
    <term>
     <literal>case</literal>
    </term>
    <listitem>
     <para><command>case</command> deyimini bir dizi koşulu test etmek için kullanırız. Bu yapı, C ve Java 'daki <command>switch</command>'e çok benzer ancak
birazdan da göreceğiniz gibi ondan biraz daha güçlüdür.
  </para>
     <para>
      <screen><prompt>ruby&gt; </prompt><emphasis role="input">i=8</emphasis><prompt>ruby&gt; </prompt><emphasis role="input">case i</emphasis>
    | <emphasis role="input">when 1, 2..5</emphasis>
    | <emphasis role="input">  print "1..5\n"</emphasis>
    | <emphasis role="input">when 6..10</emphasis>
    | <emphasis role="input">  print "6..10\n"</emphasis>
    | <emphasis role="input">end</emphasis>
6..10
   <emphasis role="output">nil</emphasis>
</screen>
     </para>
     <para><command>2..5</command>, 2 ile 5 arasındaki sayı aralığını ifade eder. Sonraki ifade, <command>i</command> değişkeninin bu aralığa düşüp düşmediğini sınar:
  </para>
     <para>
      <screen>(2..5) === i  </screen>
     </para>
     <para><command>case</command> aynı anda birden çok koşulu sınamak için <command>===</command> ilişki işleçini kullanır. Ruby'nin nesneye yönelik yapısını korumak için <command>===</command> işleci nesneye uygun olarak yorumlanır. Örneğin aşağıdaki kodda ilk <command>when</command>'de dizgelerin eşitliği sınanırken ikinci <command>when</command>'de düzenli ifadenin eşleşmesi sınanıyor.
  </para>
     <para>
      <screen><prompt>ruby&gt; </prompt><emphasis role="input">case 'abcdef'</emphasis>
    | <emphasis role="input">when 'aaa', 'bbb'</emphasis>
    | <emphasis role="input">  print "aaa or bbb\n"</emphasis>
    | <emphasis role="input">when /def/</emphasis>
    | <emphasis role="input">  print "/def/ icerir\n"</emphasis>
    | <emphasis role="input">end</emphasis>
/def/ icerir
   <emphasis role="output">nil</emphasis>
</screen>
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>
     <literal>while</literal>
    </term>
    <listitem>
     <para>
Ruby döngü oluşturmak için bir çok yola sahiptir, bununla birlikte ileriki bölümde doğrudan döngü kurmanıza yarayan <emphasis>yineleyici</emphasis>leri göreceksiniz.
  </para>
     <para><command>while</command> bir tekrarlanmış <command>if</command>'ten başka birşey değildir. <command>while</command>'ı daha önce kelime-tahmin oyunumuzda ve düzenli ifadeler yazılımımızda kullanmıştık (<xref linkend="ruby-ug-regex"/> bölümüne göz atın); <command>while </command><varname>koşul</varname><command> ... end</command> ile çevrilmiş bir kod bloğu koşul doğru olduğu sürece tekrarlanmaktaydı. Ancak <command>while</command> ve <command>if</command> ayrı ifadeler olarak da kullanılabilir:
  </para>
     <para>
      <screen><prompt>ruby&gt; </prompt><emphasis role="input">i = 0</emphasis><emphasis role="output">0</emphasis><prompt>ruby&gt; </prompt><emphasis role="input">print "Sıfır.\n" if i==0</emphasis>
Sıfır.
   <emphasis role="output">nil</emphasis>
<prompt>ruby&gt; </prompt><emphasis role="input">print "Negatif.\n" if i&lt;0</emphasis>
   <emphasis role="output">nil</emphasis>
<prompt>ruby&gt; </prompt><emphasis role="input">print "#{i+=1}\n" while i&lt;3</emphasis>
1
2
3
   <emphasis role="output">nil</emphasis>
</screen>
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
  <para>
Bazen bir sınama koşulunu olumsuzlamak istersiniz. <command>unless</command> bir olumsuzlandırılmış <command>if</command>, <command>until</command> ise olumsuzlandırılmış bir <command>while</command>'dır. Bunları deneyip tecrübe etmeyi size bırakıyoruz.
  </para>
  <para>
Bir döngüyü içerden kesmek için dört yol vardır. İlki C'deki gibi, döngüden tamamen çıkmamızı sağlayan <command>break</command>'tir. İkincisi (C'deki <command>continue</command>'ya benzeyen) döngünün başına atlayan <command>next</command>'tir. Üçüncüsü o anki yinelemeyi tekrar çalıştıran <command>redo</command>'dur. Aşağıda <command>break</command>, <command>next</command> ve  <command>redo</command> arasındaki farkı açıklayan bir C kodu bulunuyor:
  </para>
  <para>
   <screen>while (koşul) {
 label_redo:
   goto label_next;        /* ruby'nin "next"'i */
   goto label_break;       /* ruby'nin "break"'i */
   goto label_redo;        /* ruby'nin "redo"'su */
   ...
   ...
 label_next:
}
label_break:
...
</screen>
  </para>
  <para>
Bir döngünün içinden çıkmak için dördüncü yol, <command>return</command>'dür. <command>return</command> sadece döngüden değil, döngüyü içeren
yöntemden de çıkmamızı sağlar. Eğer bir argüman verildiyse, yöntem çağrısına dönecektir; aksi halde <command>nil</command> döndürecektir.
  </para>
  <variablelist>
   <varlistentry>
    <term>
     <literal>for</literal>
    </term>
    <listitem>
     <para>
C yazılımcıları <command>for</command> döngüsünün nasıl yapıldığını merak edeceklerdir. Ruby'nin <command>for</command>'u tahmin ettiğinizden biraz daha ilginçtir.
Aşağıdaki döngü, her eleman için bir kere döner:
  </para>
     <para>
      <screen>
for eleman in dizi
  ...
end
</screen>
     </para>
     <para>
Elemanlar bir değer aralığı olabilir (bu, döngü denildiğinde çoğu insanın anladığı şeydir):
  </para>
     <para>
      <screen><prompt>ruby&gt; </prompt><emphasis role="input">for num in (4..6)</emphasis>
    | <emphasis role="input">   print num,"\n"</emphasis>
    | <emphasis role="input">end</emphasis>
4
5
6
   <emphasis role="output">4..6</emphasis>
</screen>
     </para>
     <para>
Elemanlar dizi gibi başka bir türden değerler olabilir:
  </para>
     <para>
      <screen><prompt>ruby&gt; </prompt><emphasis role="input">for elt in [100,-9.6,"pickle"]</emphasis>
    | <emphasis role="input">   print "#{elt}\t(#{elt.type})\n"</emphasis>
    | <emphasis role="input">end</emphasis>
100    (Fixnum)
-9.6   (Float)
pickle (String)
   <emphasis role="output">[100, -9.6, "pickle"]</emphasis>
</screen>
     </para>
     <para>
Ancak ilerleme kaydediyoruz. <command>for</command> aslında <command>each</command>'i kullanmanın başka bir yoludur. Aşağıdaki iki biçim de aynı görevi görür:
  </para>
     <para>
      <screen>
# Eğer daha önce C ya da Java kullandıysanız aşağıdaki gibi
# birşey tercih edersiniz:
for i in collection
  ...
end

#  Smalltalk yazılımcısıysanız aşağıdaki gibi birşeyi tercih edersiniz:
collection.each {|i|
  ...
}
</screen>
     </para>
     <para>
Yineleyiciler sık sık geleneksel döngülere tercih edilir; bir kere onları kullanmaya alıştığınızda ne kadar kolay olduklarını göreceksiniz.
  </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </chapter>
 <chapter xml:id="ruby-ug-iterators">
  <info>
   <title>Yineleyiciler</title>
  </info>
  <para>
Yineleyiciler sadece Ruby'ye özgü bir kavram değildir. Genel olarak çoğu nesneye yönelik yazılım geliştirme dilinde kullanılmaktadır. Lisp'te de yineleyiciler olarak adlandırılmasalar da  kullanılmaktadır. Ancak yineleyici kavramı neredeyse her dilde değişik bir anlam kazandığı için önce bu kavramı daha ayrıntılı anlatmaya çalışalım:
  </para>
  <para><emphasis>Yinelemek</emphasis> sözcüğü aynı şeyi birçok kez tekrarlamak anlamına gelir.
  </para>
  <para>
Kod yazarken değişik durumlarda döngülere ihtiyacımız olur. C'de <command>for</command> ya da <command>while</command> kullanarak işimizi hallederiz. Örneğin,
 </para>
  <para>
   <screen>char *str;
for (str = "abcdefg"; *str != '\0'; str++) {
  /* her karakter için işlemler burada */
}</screen>
  </para>
  <para>
C'nin <command> for(...) </command> sözdizimi döngünün yaratılmasında soyutlama sağlayarak yardımcı olsa da <literal>*str</literal>'nin bir boş bir karakterle sınanması yazılımcının dizge yapısı hakkında daha ayrıntılı bilgi edinmesini gerektirir. Bu C'nin düşük-seviyeli olduğunu hissettiren nedenlerden biridir. Yüksek seviyeli diller yineleyicilere uyumluluklarıyla ün kazanmışlardır. Aşağıdaki <command>sh</command> kabuk betiğini göz önünde bulunduralım:
  </para>
  <para>
   <screen>
#!/bin/sh

for i in *.[ch]; do
  # ... her dosya icin yapilacak birkaç işlem
done
</screen>
  </para>
  <para>
Bulunulan dizindeki tüm C kaynak ve başlık dosyaları çalıştırıldı ve komut satırı ayrıntıları tuttu.  C'den daha yüksek seviyeli olduğunu düşünüyorum, öyle değil mi?
  </para>
  <para>
Ancak göz önüne alınması gereken başka bir nokta daha var: bir dilin
gömülü veri yapıları için yineleyicileri desteklemesi güzel birşey olsa
da, geri dönüp kendi veri yapılarımızı tekrarlatacak düşük seviyeli
döngüler yazmak hayal kırıklığı yaratacak bir iş olacaktır. Nesneye
yönelik yazılım geliştirmede, kullanıcılar çoğu kez ardı ardına veri türleri
tanımlarlar ve bu ciddi bir sorun olabilir.
  </para>
  <para>
Her nesneye yönelik yazılım geliştirme dili yineleyiciler için kolaylıklar içerir. Bazı diller bu iş için özel sınıflar tanımlarken, Ruby yineleyicileri doğrudan tanımlamayı tercih eder.
  </para>
  <para>
Ruby'nin <command>String</command> türü bazı yararlı yineleyicilere sahiptir.
  </para>
  <para>
   <screen><prompt>ruby&gt; </prompt><emphasis role="input">"abc".each_byte{|c| printf "&lt;%c&gt;", c}; print "\n"</emphasis>
&lt;a&gt;&lt;b&gt;&lt;c&gt;
   <emphasis role="output">nil</emphasis>
</screen>
  </para>
  <para><function>each_byte</function>, dizgedeki her karakter için bir yineleyicidir. Her bir karakter yerel bir değişken olan <literal>c</literal>'ye yerleştirilir. Bu daha çok C koduna benzeyen bir şeyle açıklanabilir...
  </para>
  <para>
   <screen><prompt>ruby&gt; </prompt><emphasis role="input">s="abc";i=0</emphasis><emphasis role="output">0</emphasis><prompt>ruby&gt; </prompt><emphasis role="input">while i&lt;s.length</emphasis>
    | <emphasis role="input">   printf "&lt;%c&gt;", s[i]; i+=1</emphasis>
    | <emphasis role="input">end; print "\n"</emphasis>
&lt;a&gt;&lt;b&gt;&lt;c&gt;
   <emphasis role="output">nil</emphasis>
</screen>
  </para>
  <para>
Buna rağmen <function>each_byte</function> yineleyicisi hem kabul edilebilir bir basitliktedir hem de <command>String</command> sınıfı radikal bir değişikliğe uğrasa da çalışmaya devam eder. Yineleyicilerin başka bir yararı da değişiklere karşı sağlam durmasıdır ki bu da iyi bir kodun karakteristik özelliklerinden biridir (evet, sabırlı olun, <emphasis>sınıflar</emphasis> hakkında da konuşacağız.).
  </para>
  <para><command>String</command>'in başka bir yineleyicisi de <command>each_line</command>'dır.
  </para>
  <para>
   <screen><prompt>ruby&gt; </prompt><emphasis role="input">"a\nb\nc\n".each_line{|l| print l}</emphasis>
a
b
c
   <emphasis role="output">nil</emphasis>
</screen>
  </para>
  <para>
C'de satır sınırlayıcıları bulmak, alt dizgeler üretmek gibi güç işlerin yineleyicilerle kolayca üstesinden gelinebilir.
  </para>
  <para>
Geçen bölümdeki <command>for</command> döngüsü, <command>each</command> işlecini kullanarak tekrarlamayı sağlamaktaydı. <command>String</command>'in <command>each</command>'i aynı <command>each_line</command> gibi görev görür, o yüzden yukarıdaki örneği <command>for</command> ile tekrar yazalım:
  </para>
  <para>
   <screen><prompt>ruby&gt; </prompt><emphasis role="input">for l in "a\nb\nc\n"</emphasis>
    | <emphasis role="input">  print l </emphasis>
    | <emphasis role="input">end</emphasis>
a
b
c
   <emphasis role="output">nil</emphasis>
</screen>
  </para>
  <para>
Bulunan yineleyiciyi döngünün başından itibaren tekrar ettirmek için <command>retry</command> denetim yapısını kullanabiliriz.
  </para>
  <para>
   <screen><prompt>ruby&gt; </prompt><emphasis role="input"> c=0</emphasis><emphasis role="output">0</emphasis><prompt>ruby&gt; </prompt><emphasis role="input">for i in 0..4</emphasis>
    | <emphasis role="input">  print i</emphasis>
    | <emphasis role="input">  if i == 2 and c == 0</emphasis>
    | <emphasis role="input">    c = 1</emphasis>
    | <emphasis role="input">    print "\n"</emphasis>
    | <emphasis role="input">    retry</emphasis>
    | <emphasis role="input">  end</emphasis>
    | <emphasis role="input">end; print "\n"</emphasis>
012
01234
   <emphasis role="output">nil</emphasis>
</screen>
  </para>
  <para>
Yineleyici tanımlamasında bazen <command>yield</command>'le karşılaşırız.  <command>yield</command>, denetimi yineleyiciye parametre olarak geçilen kod bloğuna verir (bu konu <xref linkend="ruby-ug-pobjects"/> bölümünde daha ayrıntılı anlatılacaktır).
  </para>
  <para>
Aşağıdaki örnekte, argümanda verilen sayı kadar bir kod bloğunu tekrarlayan <command>repeat</command> yineleyicisi tanımlanmıştır.
   </para>
  <para>
   <screen><prompt>ruby&gt; </prompt><emphasis role="input">def repeat(num)</emphasis>
    | <emphasis role="input">  while num &gt; 0</emphasis>
    | <emphasis role="input">    yield</emphasis>
    | <emphasis role="input">    num -= 1</emphasis>
    | <emphasis role="input">  end</emphasis>
    | <emphasis role="input">end</emphasis>
   <emphasis role="output">nil</emphasis>
<prompt>ruby&gt; </prompt><emphasis role="input">repeat(3) { print "foo\n" }</emphasis>
foo
foo
foo
   <emphasis role="output">nil</emphasis>
</screen>
  </para>
  <para><command>retry</command> ile <command>while</command> gibi çalışan ancak hız açısından pek de pratik olmayan bir yineleyici tanımlayabiliriz.
  </para>
  <para>
   <screen><prompt>ruby&gt; </prompt><emphasis role="input">def WHILE(cond)</emphasis>
    | <emphasis role="input">  return if not cond</emphasis>
    | <emphasis role="input">  yield</emphasis>
    | <emphasis role="input">  retry</emphasis>
    | <emphasis role="input">end</emphasis>
   <emphasis role="output">nil</emphasis>
<prompt>ruby&gt; </prompt><emphasis role="input">i=0; WHILE(i&lt;3) { print i; i+=1 }</emphasis>
012  nil
</screen>
  </para>
  <para>
Yineleyicinin ne olduğunu anladınız mı? Bir kaç kısıtlama hariç, kendi
yineleyicinızı yazabilirsiniz, aslında yeni bir veri türü
tanımladığınız zaman ona uygun bir yineleyici tanımlamanız da uygun
olacaktır. Yukarıdaki örnekler pek de kullanışlı örnekler sayılmazlar.
Sınıfları daha iyi anladığımızda daha uygulanabilir yineleyiciler hakkında
konuşabiliriz.
  </para>
 </chapter>
 <chapter xml:id="ruby-ug-oothinking">
  <info>
   <title>Nesne Yönelimli Düşünme</title>
  </info>
  <para>
Nesne yönelimlilik kavramı çekici bir kavramdır. Herşeyi nesneye yönelik olarak çağırmak kulağınıza hoş gelebilir. Ruby nesne yönelimli bir betik dili olarak adlandırılır, ancak gerçekte bu "nesne yönelimlilik" kavramı nedir?
  </para>
  <para>
Bu soruya aşağı yukarı hepsi aynı kapıya çıkan bir sürü cevap bulunabilir. Çabukça toparlamak yerine, isterseniz öncelikle geleneksel yazılım paradigması üzerinde duralım.
  </para>
  <para>
Geleneksel olarak, bir yazılım geliştirme sorunu bazı verilerin gösterimleri ile bu veriler üzerinde çalışan yordamlar olarak karşımıza çıkar. Bu model altında, veri hareketsiz, edilgen ve beceriksizdir; tamamen etkin, mantıksal ve güçlü bir yordamın merhametine kalmıştır.
  </para>
  <para>
Bu yaklaşımdaki sorun, yazılımları geliştiren yazılımcıların sadece insan olması ve dolayısıyla bir çok ayrıntıyı sadece bir sefer kafalarında net olarak tutabilmeleridir. Proje genişledikçe, yordamsal öz daha karmaşık ve hatırlaması zor bir noktaya gelir.
  </para>
  <para>
Küçük düşünce kusurları ve yazım yanlışlarıyla sonuçta elinizde iyi-gizlenmiş yazılım hataları kalır.
  </para>
  <para>
Zamanla yordam çekirdeğinde istenmeyen etkileşimler doğabilir; bu iş dokunaçlarının yüzünüze değmesine izin vermeden sinirli bir mürekkep balığı taşımaya benzer.
  </para>
  <para>
Bu geleneksel paradigmalarla yazılım geliştirirken hataları azaltmak ve sınırlamak için kılavuzlar bulunmaktadır, ancak yöntemi kökten değiştirmek daha iyi bir çözüm olacaktır.
  </para>
  <para>
Peki nesneye yönelik yazılım geliştirme, mantıksal işin sıradan ve tekrarlayan yönünü verinin kendisine emanet etmemizi mümkün kılmak ve veriyi edilgen durumdan etkin duruma sokmamız için ne yapar? Başka bir açıdan,
  </para>
  <para>
   <itemizedlist>
    <listitem>
Her veri parçasına, erişip içindekileri etrafa fırlatmamıza izin veren
kapağı açık bir kutu gibi davranmayı bıraktık.
    </listitem>
    <listitem>
Her veri parçasına kapağı kapalı ve iyi işaretlenmiş düğmeleri bulunan çalışan bir makine gibi davranmaya başladık.
    </listitem>
   </itemizedlist>
  </para>
  <para>
"Makine" olarak tanımladığımız şey çok basit ya da çok karmaşık olabilir ancak bunu dışarıdan bakarak söyleyemeyiz ve makineyi açmayı (tasarımıyla ilgili bir sorun olduğunu düşünmedikçe) istemeyiz. Bu yüzden veriyle etkileşimde bulunmak için düğme çeviriyor gibi işlem yapmamız gerekir. Makine bir kere kurulduğu zaman  nasıl çalıştığı hakkında düşünmememize gerek yoktur.
  </para>
  <para>
Kendimize iş çıkardığımızı düşünebilirsiniz ancak bu yaklaşımla bazı şeylerin yanlış gitmesini önleyebiliriz.
  </para>
  <para>
Şimdi açıklayıcı olması açısından basit ve küçük bir örnek görelim: Arabanızın bir yolmetresi olsun. Görevi yeniden başlatma düğmesine son basıldığından itibaren ne kadar yol katedildiği ölçmektir. Bu durumu bir yazılım geliştirme dilinde nasıl tasarlayabiliriz? C'de yolmetre sadece sayısal bir değişken olmalıdır, muthemelen bir <command>float</command>. Yazılım bu değişkenin değerini küçük aralıklarla arttıracak, uygun gördüğü zamansa sıfır yapıp yeniden başlatacaktır. Burada yanlış olan nedir?  Yazılımdaki bir hata bu değişkene uydurma bir değer atayabilir ve beklenmedik sonuçlar ortaya çıkabilir.   C'de yazılım geliştirmiş herhangi biri böylesine küçük ve basit bir hatayı bulmak için saatler ya da günler harcamanın ne demek olduğunu bilir (hatanın bulunma sinyali genelde alında şaklayan bir tokattır).
  </para>
  <para>
Aynı problem nesneye yönelik bağlamda da karşımıza çıkabilirdi. Yolmetreyi tasarlayan bir yazılımcının soracağı ilk şeylerden biri tabii ki "hangi veri yapısı bu durum için daha uygundur?" olmayacaktır. Ama "Bunun tam olarak nasıl çalışması gerekiyor?" şeklinde bir soru daha uygun olacaktır. Aradaki fark daha malumatlı olmaktır. Bir kilometre sayacının gerçekte ne işe yaradığına ve dış dünyanın onunla nasıl etkileşimde bulunmayı beklediğine karar vermek için biraz zaman ayırmamız gereklidir. Şimdi arttırabileceğimiz, yeniden başlatabileceğimiz ve değerini okuyabileceğimiz ve başka bir şey yapmayan küçük bir makine yapmaya karar verdik.
  </para>
  <para>
Yolmetremize keyfi bir değer atamak için bir yol tanımlamadık; neden? Çünkü yolmetrelerin bu şekilde çalışmadığını biliyoruz. Yolmetreyle yapabileceğiniz pek az şey var, ki bunların hepsini yapmaya izin verdik. Bu şekilde eğer yazılımda herhangi birşey yolmetrenin değerinin yerine geçmeye çalışırsa (örneğin arabanın klimasının derecesi) işlerin yanlış gittiğine dair uyarı alırsınız. Koşan yazılımın (dilin doğasına göre muhtemelen derleme sırasında) yolmetre nesnelerine keyfi değerler atamaya izni olmadığını söyledik. Mesaj tam olarak bu olmayabilir ama buna yakın birşeydir. Ancak hatayı engellemiyor, değil mi? Ancak hatanın yerini kolayca gösterir. Bu nesneye yönelik yazılım geliştirmenin zamanımızı boşa harcamaktan kurtaran birkaç yolundan biridir.
  </para>
  <para>
Yukarıda soyutlamanın yalnızca bir adımını yaptık, artık makinelerden oluşan bir fabrika yapmak kolaylaştı. Tek bir yolmetreyi doğrudan oluşturmak yerine, basit bir kalıptan istediğimiz sayıda yolmetre yapmayı tercih etmeliyiz. Kalıp (ya da isterseniz yolmetre fabrikası) "sınıf" olarak adlandırdığımız kavrama, oluşturduğumuz yolmetre de "nesne" olarak tanımladığımız kavrama karşılık gelmektedir. Bir çok nesneye yönelik yazılım geliştirme dili, herhangi bir nesne oluşturmdan önce bir sınıfın tanımlı olmasını gerekli kılar, ancak Ruby'de böyle bir durum sözkonusu değildir.
  </para>
  <para>
Bu kullanımın nesneye yönelik tasarımı kuvvetlendirmediğini de not düşelim. Elbette her dilde, anlaşılamayan, hatalı, yarım yamalak kod yazmak mümkündür. Ruby'nin sizin için yaptığı şey (özellikle C++'nın aksine) nesneye yönelik yazılım geliştirme kavramını sindirmenizi sağlayarak, daha küçük bir ölçekte çalışırken çirkin bir kod yazmamak için çaba sarfetmenizi önler. İleriki bölümlerde Ruby'nin takdire şayan diğer özelliklerini açıklayacağız. Hala bizimle misiniz?
 </para>
 </chapter>
 <chapter xml:id="ruby-ug-methots">
  <info>
   <title>Yöntemler</title>
  </info>
  <para>
Yöntem nedir? Nesneye yönelik yazılım geliştirmede, nesnenin dışından doğrudan veri üzerinde işlem yapmak yerine (<emphasis>eğer nazikçe böyle yapmalarını söylerseniz</emphasis>) nesnelerin kendilerini nasıl çalıştıracakları hakkında bilgiye sahip olması tercih edilir. Nesnelere mesajlar gönderdiğimizi ve bunların genelde bir olay tarafından gerçekleştirildiğini ya da anlamlı bir cevapla karşılandığını söyleyebilirsiniz. Bu muhtemelen bizim özellikle bilmemizi gerektiren ya da nesnenin kendi içinde nasıl çalıştığına dikkat etmemizi gerektirmeyen bir olaydır. Bir nesneye gerçekleştirmesi için (<emphasis>ya da anlayacağı mesajlar göndermemiz için</emphasis>) izinli olduğumuz görevlere, <wordasword>nesnenin yöntemleri</wordasword> denir.
  </para>
  <para>
Ruby'de bir nesnenin yöntemini nokta gösterimi ile çağırırız (C++ ya da Java'da olduğu gibi).
  </para>
  <para>
   <screen>
    <prompt>ruby&gt; </prompt>
    <emphasis role="input"> "abcdef".length</emphasis>
    <emphasis role="output">6</emphasis>
   </screen>
  </para>
  <para>
Muhtemelen bu dizgenin <emphasis>uzunluğunun ne kadar olduğu</emphasis> soruluyor.
  </para>
  <para>
Teknik olarak,<command>"abcdef"</command> nesnesi için <command>length</command> yöntemini çağırıyoruz.
  </para>
  <para>
Diğer nesnelerin <command>length</command> yöntemi için biraz farklılıkları olabilir ya da hiç olmayabilir de. Mesajlara nasıl cevap verileceği kararı yazılımın çalıştırılması sırasında verilir ve hangi nesneye başvurduğuna bağlı olarak olay değişebilir.
  </para>
  <para>
   <screen>
    <prompt>ruby&gt; </prompt>
    <emphasis role="input"> foo = "abc"</emphasis>
    <emphasis role="output">"abc"</emphasis>
    <prompt>ruby&gt; </prompt>
    <emphasis role="input"> foo.length</emphasis>
    <emphasis role="output">3</emphasis>
    <prompt>ruby&gt; </prompt>
    <emphasis role="input"> foo = ["abcde", "fghij"]</emphasis>
    <emphasis role="output">["abcde", "fghij"]</emphasis>
    <prompt>ruby&gt; </prompt>
    <emphasis role="input"> foo.length</emphasis>
    <emphasis role="output">2</emphasis>
   </screen>
  </para>
  <para><literal>length</literal> yönteminin, nesneye göre değişebilmesiyle neyi kastediyoruz?
Yukarıdaki örnekte ilk önce <command>foo</command>'nun uzunluğunu soruyoruz, basit bir dizgeye başvuruyor ve sadece tek bir mantıklı cevabı olabilir. İkinci sefer <command> foo</command> bir diziye başvuruyor ve uzunluğunun 2, 5 ya da 10 olduğunu düşünebilirsiniz ama genelde en kabul edilebilir cevap tabii ki 2 olacaktır.
  </para>
  <para>
   <screen>
    <prompt>ruby&gt; </prompt>
    <emphasis role="input"> foo[0].length</emphasis>
    <emphasis role="output">5</emphasis>
    <prompt>ruby&gt; </prompt>
    <emphasis role="input"> foo[0].length + foo[1].length</emphasis>
    <emphasis role="output">10</emphasis>
   </screen>
  </para>
  <para>
Burada dikkat edilmesi gereken nokta bir dizinin, dizi olmanın ne demek olduğunu bilmesidir. Ruby'de veri parçaları beraberlerinde bilgi taşıdıkları için talepler otomatik olarak  algılanabilir ve bir çok yolla gerçekleştirilebilir.
  </para>
  <para>
Bu yazılımcıyı spesifik işlev adlarını hatırlamaktan kurtarır, değişik veri türlerine uygulanabilir ve sonuç istediğimiz gibi olur. Nesneye yönelik yazılım geliştirmenin bu özelliği <literal>polimorfizm</literal> olarak adlandırılır.
  </para>
  <para>
Bir nesne anlamadığı bir mesaj aldığında bir hata uyanır:
  </para>
  <para>
   <screen>
    <prompt>ruby&gt; </prompt>
    <emphasis role="input"> foo = 5</emphasis>
    <emphasis role="output">5</emphasis>
    <prompt>ruby&gt; </prompt>
    <emphasis role="input"> foo.length</emphasis>
    <emphasis role="output">ERR: (eval):1: undefined method `length' for 5(Fixnum)</emphasis>
   </screen>
  </para>
  <para>
Sonuçta bir nesne için hangi yöntemlerın kabul edilebilir olduğunu bilmemiz geretiği halde, yöntemlerin nasıl işlendiğini bilmek zorunda değiliz.
  </para>
  <para>
Eğer argümanlar bir yönteme verilecekse genelde parantez içine alınırlar.
  </para>
  <para>
   <screen>object.method(arg1, arg2)  </screen>
  </para>
  <para>
Ancak belirsizlik ihtiva etmedikleri sürece kullanılmayabilirler de.
  </para>
  <para>
   <screen>object.method arg1, arg2  </screen>
  </para>
  <para>
Ruby, <command>self</command> adında bir nesnenin bir yöntemini çağırdığı zaman başvurulan özel bir değişkene sahiptir. Rahatlık için "<command>self.</command>"  genelde yöntem çağrılırken kullanılmayabilir:
  </para>
  <para>
   <screen>self.method_name(args...)  </screen>
  </para>
  <para>
yukarıdaki ifadeyle aşağıdaki aynıdır:
  </para>
  <para>
   <screen>method_name(args...)  </screen>
  </para>
  <para>
Bir <literal>işlev çağrısı</literal> sadece <command>self</command>'le yöntem çağrımının kısaltılmış şeklidir. Bu da Ruby'yi saf bir nesneye yönelik yazılım geliştirme dili yapan şeydir.  Hala işlevsel yöntemler diğer dillerdeki işlevlere çok benzese de aslında işlev çağrılarının Ruby'de gerçek nesne yöntemlerinden başka birşey olmadığını görmeniz gerekir. İstersek hala gerçek nesne yöntemleri değilmiş gibi kabul ederek <literal>işlev</literal>lerden bahsedebiliriz.
  </para>
 </chapter>
 <chapter xml:id="ruby-ug-classes">
  <info>
   <title>Sınıflar</title>
  </info>
  <para>
Gerçek dünya sınıflandırabileceğimiz nesnelerle doludur. Örneğin küçük bir çocuk bir köpek gördüğünde, cinsine bakmaksızın "hav hav" demesi gibi biz de dünyadaki nesneleri kategorize ederiz.
  </para>
  <para>
Nesneye yönelik terminolojide, "köpek" gibi nesnelerin kategorize edilmiş haline <command>sınıf</command>, sınıfın özelleştirilmiş nesnelerinde <command>örnek</command> (instance) denir.
  </para>
  <para>
Genelde Ruby'de ya da herhangi başka bir nesneye yönelik yazılım geliştirme dilinde nesne yapmak için önce sınıfın karakteristikleri tanımlanır sonra da bir örnek tanımlanır. Bu süreci görebilmek için <command>Kopek</command> adında ilk basit sınıfımızı tanımlıyoruz:
  </para>
  <para>
   <screen><prompt>ruby&gt; </prompt><emphasis role="input"> class Kopek</emphasis>
    | <emphasis role="input">   def speak</emphasis>
    | <emphasis role="input">     print "Hav Hav\n"</emphasis>
    | <emphasis role="input">   end</emphasis>
    | <emphasis role="input"> end</emphasis>
   <emphasis role="output">nil</emphasis>
</screen>
  </para>
  <para>
Sınıf tanımlaması <command>class</command> ile <command>end</command> arasında yapılmaktadır. Bu alanda bulunan <command>def</command>, önceki bölümlerde açıkladığımız gibi sınıfa bazı özel davranışlar kazandıran <literal>yöntem</literal>leri tanımlamak için kullanılır.
  </para>
  <para>
Artık bir <command>Kopek</command> sınıfı tanımladık, öyleyse şimdi bir köpek yapabiliriz:
    </para>
  <para>
   <screen>
    <prompt>ruby&gt; </prompt>
    <emphasis role="input"> kucu = Kopek.new</emphasis>
    <emphasis role="output">#&lt;Kopek:0xbcb90&gt;</emphasis>
   </screen>
  </para>
  <para><command>Kopek</command> sınıfından yeni bir örnek yarattık ve <command>kucu</command> adını verdik. <command>new</command> yöntemi her sınıf için yeni bir örnek yapmaya yarar. <command>kucu</command> sınıf tanımımıza göre bir <command>Kopek</command> olduğu için, bir köpekte olmasına karar verdiğimiz tüm özellikleri taşır. <command>Kopek</command> sınıfımız çok basit olduğu için <command>kucu</command>'dan yapmasını istediğimiz küçük bir hile var.
  </para>
  <para>
   <screen><prompt>ruby&gt; </prompt><emphasis role="input"> kucu.konus</emphasis>
Hav Hav
   <emphasis role="output">nil</emphasis>
</screen>
  </para>
  <para>
Bir sınıftan yeni bir örnek yaratmak bazen <literal>örnekleme</literal> olarak adlandırılır. Köpeğimizin havlamasını test etmek için öncelikle bir köpeğimizin olması lazım, <command>Kopek</command> sınıfından bizim için havlamasını isteyemeyiz.
  </para>
  <para>
   <screen>
    <prompt>ruby&gt; </prompt>
    <emphasis role="input"> Kopek.konus</emphasis>
    <emphasis role="output">ERR: (eval):1: undefined method `konus' for Kopek:class</emphasis>
   </screen>
  </para>
  <para>
Diğer taraftan, duygusal olarak bağlanmamış bir köpeğin sesini duymak istersek,
geçici bir köpek yaratabilir ve kaybolmadan önce bizim için küçük bir ses çıkarmasını isteyebiliriz.
  </para>
  <para>
   <screen><prompt>ruby&gt; </prompt><emphasis role="input"> (Kopek.new).konus</emphasis>   # ya da daha genel olarak, Kopek.new.konus
Hav Hav
   <emphasis role="output">nil</emphasis>
</screen>
  </para>
  <para>
"Bekle" diyebilirsiniz, "bu kerata nereye kayboldu böyle?" Bu doğru: eğer ona bir isim vermezseniz (<command>kucu</command>'da yaptığımız gibi) Ruby'nin otomatik çöp toplama mekanizması devreye girer ve bunun istenmeyen aylak bir köpek olduğuna karar verir ve merhametsizce yok eder. Gerçekten, sorun yok; biliyorsunuz ki tüm köpekleri istediğimizi söyleyebiliriz.
  </para>
 </chapter>
 <chapter xml:id="ruby-ug-inheritance">
  <info>
   <title>Miras</title>
  </info>
  <para>
Gerçek hayatta yaptığımız sınıflandırmalar son derece hiyerarşiktir. Örneğin bütün kedilerin memeli olduğunu ve bütün memelilerin hayvan olduğunu biliriz. Küçük sınıflar mensup oldukları büyük sınıfların karakteristik özelliklerini miras alırlar. Eğer bütün memeliler nefes alabiliyorsa, bütün kediler de nefes alabiliyor demektir.
  </para>
  <para>
Bu durumu Ruby'de aşağıdaki gibi açıklayabiliriz:
  </para>
  <para>
   <screen><prompt>ruby&gt; </prompt><emphasis role="input"> class Memeli</emphasis>
    | <emphasis role="input">   def nefes</emphasis>
    | <emphasis role="input">     print "nefes al, nefes ver\n"</emphasis>
    | <emphasis role="input">   end</emphasis>
    | <emphasis role="input"> end</emphasis>
   <emphasis role="output">nil</emphasis>
<prompt>ruby&gt; </prompt> <emphasis role="input"> class Kedi&lt;Memeli</emphasis>
    | <emphasis role="input">   def konus</emphasis>
    | <emphasis role="input">     print "Miyauvvvv\n"</emphasis>
    | <emphasis role="input">   end</emphasis>
    | <emphasis role="input"> end</emphasis>
   <emphasis role="output">nil</emphasis>
</screen>
  </para>
  <para>
Örneğin bir <command>Kedi</command>'nin nasıl nefes alması gerektiğini belirtmediğimizi farz edelim. Bu durumda her kedi <command>Kedi</command> sınıfı <command>Memeli</command> sınıfının bir alt sınıfı olarak tanımlanmışsa, bu davranışı <command>Memeli</command> sınıfından miras olarak alacaktır. (Nesneye yönelik terminolojide küçük sınıf <literal>alt sınıf</literal> , büyük sınıfsa <literal>süper sınıf</literal> olarak isimlendirilir.) Programcının bakış açısına göre, kediler nefes alma yeteneğini bağımsız olarak almıştır, eğer bir <command>konuşma</command> yöntemi de eklersek, artık kedilerimiz hem nefes alabilme hem de konuşabilme yeteneğine sahip olurlar.
  </para>
  <para>
   <screen><prompt>ruby&gt; </prompt><emphasis role="input"> pisi = Kedi.new</emphasis><emphasis role="output">#&lt;Kedi:0xbd80e8&gt;</emphasis><prompt>ruby&gt; </prompt><emphasis role="input"> pisi.nefes</emphasis>
nefes al, nefes ver
   <emphasis role="output">nil</emphasis>
<prompt>ruby&gt; </prompt> <emphasis role="input"> pisi.konus</emphasis>
Miyauvvvv
   <emphasis role="output">nil</emphasis>
</screen>
  </para>
  <para>
Bazen süper sınıfta olması gereken ancak alt sınıf tarafından miras alınması istenmeyen bir özellik olabilir. Örneğin genel olarak kuşların uçmayı bildiğini ancak penguenlerin, kuşların uçamayan bir alt sınıfı olduğunu kabul edelim.
  </para>
  <para>
   <screen><prompt>ruby&gt; </prompt><emphasis role="input"> class Kus</emphasis>
    | <emphasis role="input">   def gagala</emphasis>
    | <emphasis role="input">     print "Tüylerimi temizliyorum."</emphasis>
    | <emphasis role="input">   end</emphasis>
    | <emphasis role="input">   def uc</emphasis>
    | <emphasis role="input">     print "Uçuyorum."</emphasis>
    | <emphasis role="input">   end</emphasis>
    | <emphasis role="input"> end</emphasis>
   <emphasis role="output">nil</emphasis>
<prompt>ruby&gt; </prompt> <emphasis role="input"> class Penguen&lt;Kus</emphasis>
    | <emphasis role="input">   def uc</emphasis>
    | <emphasis role="input">     fail "Üzgünüm, yüzmeyi tercih ederim."</emphasis>
    | <emphasis role="input">   end</emphasis>
    | <emphasis role="input"> end</emphasis>
   <emphasis role="output">nil</emphasis>
</screen>
  </para>
  <para>
Her yeni sınıfın her özelliğini ayrı ayrı tanımlamak yerine, sadece her alt sınıfla
onun süper sınıfı arasındaki farklılıkları eklemek ya da yaniden tanımlamak daha iyidir.
Miras'ın bu kullanımına bazen <wordasword>farksal yazılım geliştirme</wordasword> denir. Bu nesneye yönelik yazılım geliştirmenin en yararlı özelliklerinden biridir.
  </para>
 </chapter>
 <chapter xml:id="ruby-ug-redefinemethods">
  <info>
   <title>Yöntemleri Yeniden Tanımlama</title>
  </info>
  <para>
Bir alt sınıfın davranışlarını, süper sınıfın yöntemlerini yeniden tanımlayarak değiştirebiliriz.
  </para>
  <para>
   <screen><prompt>ruby&gt; </prompt><emphasis role="input"> class Insan</emphasis>
    |<emphasis role="input">   def tanimla</emphasis>
    |<emphasis role="input">     print "Ben bir insanim.\n"</emphasis>
    |<emphasis role="input">   end</emphasis>
    |<emphasis role="input">   def tren_bileti(yas)</emphasis>
    |<emphasis role="input">     if yas &lt; 12</emphasis>
    |<emphasis role="input">       print "Indirimli ucret.\n";</emphasis>
    |<emphasis role="input">     else</emphasis>
    |<emphasis role="input">       print "Normal ucret.\n";</emphasis>
    |<emphasis role="input">     end</emphasis>
    |<emphasis role="input">   end</emphasis>
    |<emphasis role="input"> end</emphasis>
  <emphasis role="output">nil</emphasis>
<prompt>ruby&gt; </prompt><emphasis role="input"> Insan.new.tanimla</emphasis>
Ben bir insanim.
  <emphasis role="output">nil</emphasis>
<prompt>ruby&gt; </prompt><emphasis role="input"> class Ogrenci1&lt;Insan</emphasis>
    |<emphasis role="input">   def tanimla</emphasis>
    |<emphasis role="input">     print "Ben bir ogrenciyim.\n"</emphasis>
    |<emphasis role="input">   end</emphasis>
    |<emphasis role="input"> end</emphasis>
  <emphasis role="output">nil</emphasis>
<prompt>ruby&gt; </prompt><emphasis role="input"> Ogrenci1.new.tanimla</emphasis>
Ben bir ogrenciyim.
  <emphasis role="output">nil</emphasis>
</screen>
  </para>
  <para>
Örneğin süper sınıfın <command>tanimla</command> yöntemini tamamen yeniden tanımlamak yerine geliştirmek istediğimizi düşünelim.
Bunun için <command>super</command>'i kullanıyoruz.
  </para>
  <para>
   <screen><prompt>ruby&gt; </prompt><emphasis role="input"> class Ogrenci2&lt;Insan</emphasis>
    |<emphasis role="input">   def tanimla</emphasis>
    |<emphasis role="input">     super</emphasis>
    |<emphasis role="input">     print "Ben bir ogrenciyim, aynı zamanda.\n"</emphasis>
    |<emphasis role="input">   end</emphasis>
    |<emphasis role="input"> end</emphasis>
  <emphasis role="output">nil</emphasis>
<prompt>ruby&gt; </prompt><emphasis role="input"> Ogrenci2.new.tanimla</emphasis>
Ben bir insanim.
Ben bir ogrenciyim, aynı zamanda.
  <emphasis role="output">nil</emphasis>
</screen>
  </para>
  <para><command>super</command> bizim orijinal yönteme argüman geçmemize izin verir.
Bazen iki tür insan olduğunu söylerler...
  </para>
  <para>
   <screen><prompt>ruby&gt; </prompt><emphasis role="input"> class Sahtekar&lt;Insan</emphasis>
    |<emphasis role="input">   def tren_bileti(yas)</emphasis>
    |<emphasis role="input">     super(11) # ucuz tarife istiyoruz.</emphasis>
    |<emphasis role="input">   end</emphasis>
    |<emphasis role="input"> end</emphasis>
  <emphasis role="output">nil</emphasis>
<prompt>ruby&gt; </prompt><emphasis role="input"> Sahtekar.new.tren_bileti(25)</emphasis>
Indirimli ucret.
  <emphasis role="output">nil</emphasis>
<emphasis role="input"/>
<prompt>ruby&gt; </prompt><emphasis role="input"> class Durust&lt;Insan</emphasis>
    |<emphasis role="input">   def tren_bileti(yas)</emphasis>
    |<emphasis role="input">     super(yas) # verilen argümanı gecelim</emphasis>
    |<emphasis role="input">   end</emphasis>
    |<emphasis role="input"> end</emphasis>
  <emphasis role="output">nil</emphasis>
<prompt>ruby&gt; </prompt><emphasis role="input"> Durust.new.tren_bileti(25)</emphasis>
Normal ucret.
  <emphasis role="output">nil</emphasis>
</screen>
  </para>
 </chapter>
 <chapter xml:id="ruby-ug-accesscontrol">
  <info>
   <title>Erişim Denetimi</title>
  </info>
  <para>
Daha önce Ruby'nin işlevlere değil sadece yöntemlere sahip olduğunu söylemiştik.
Ancak sadece tek bir tür yöntem yoktur. Bu bölümde <wordasword>erişim yöntemleri</wordasword>'nden bahsedeceğiz.
  </para>
  <para>
Bir yöntemi, bir sınıf tanımlamasının içinde değil de, en üstte tanımladığımızı farz edelim.
Bunun C gibi daha geleneksel bir dildeki <literal>işlev</literal>lerle aynı işi yapan bir yöntem olduğunu düşünürüz.
  </para>
  <para>
   <screen><prompt>ruby&gt; </prompt><emphasis role="input"> def square(n)</emphasis>
    | <emphasis role="input">   n * n</emphasis>
    | <emphasis role="input"> end</emphasis>
   <emphasis role="output">nil</emphasis>
<prompt>ruby&gt; </prompt> <emphasis role="input"> square(5)</emphasis>
 <emphasis role="output">   25</emphasis>
</screen>
  </para>
  <para>
Yeni yöntemimiz hiç bir sınıfa bağlı değil gibi gözüküyor, ama aslında Ruby bu yöntemi tüm sınıfların süper sınıfı olan <command>Object</command> sınıfına verir. Sonuç olarak her nesne bu yöntemi nasıl kullanacağını bilir. Bu durum doğru gibi gözükebilir ama burada küçük bir nokta vardır: bu yöntem her sınıfın <literal>private</literal> yöntemidir. Bunun ne anlama geldiğinden bahsedeceğiz fakat bu durumun sonuçlarından bir tanesi de aşağıdaki gibi sadece işlev tarzında çağırabilmemizdir:
  </para>
  <para>
   <screen><prompt>ruby&gt; </prompt><emphasis role="input"> class Foo</emphasis>
    | <emphasis role="input">   def dorduncu_kuvvet(x)</emphasis>
    | <emphasis role="input">     square(x) * square(x)</emphasis>
    | <emphasis role="input">   end</emphasis>
    | <emphasis role="input"> end</emphasis>
   <emphasis role="output">nil</emphasis>
<prompt>ruby&gt; </prompt> <emphasis role="input"> Foo.new.dorduncu_kuvvet 10</emphasis>
  10000
</screen>
  </para>
  <para>
Bir nesnenin, yöntemini açıkça çağırmasına izin verilmez:
  </para>
  <para>
   <screen>
    <prompt>ruby&gt; </prompt>
    <emphasis role="input"> "fish".square(5)</emphasis>
    <emphasis role="output">ERR: (eval):1: private method `square' called for "fish":String</emphasis>
   </screen>
  </para>
  <para>
Bu durum daha geleneksel bir dildeki gibi işlev yazmamızı sağlarken, Ruby'nin saf 'nesneye yönelik' yapısını korumasına yardımcı olur (işlevler halen nesnelerin yöntemleridir, sadece alıcı üstü kapalı olarak <command>self</command>'tir.)
  </para>
  <para>
Önceki bölümlerde de vurguladığımız gibi nesneye yönelik yazılım geliştirmenin
genel mantığı, <literal>belirtim </literal> ile  <literal>gerçekleştirimi</literal> birbirinden ayırmak ya da bir nesnenin hangi görevleri yapmak istediği ve bunu nasıl yapabileceğiyle ilgilenmektir.
  </para>
  <para>
Bir nesnenin dahili işleri genelde kullanıcıdan saklanmalı, kullanıcı yalnızca
neyin gidip geldiğiyle ilgilenmeli ve nesnenin kendi içinde neyi nasıl yaptığını bildiğine dair güvenmelidir.
  </para>
  <para>
Genelde nesnenin dış dünya tarafından görülmeyen ancak dahili olarak
kullandığı yöntemlere sahip olması yararlı bir şeydir (ve bu durum kullacının nesneleri görme biçimi değiştirilmeksizin yazılımcının isteğine göre değiştirebilir).
  </para>
  <para>
Aşağıdaki basit örnekte <command>motor</command> sınıfının görünmediğini ama dahili olarak çalıştığını varsayalım.
  </para>
  <para>
   <screen><prompt>ruby&gt; </prompt><emphasis role="input"> class Deneme</emphasis>
    | <emphasis role="input">   def iki_kati(a)</emphasis>
    | <emphasis role="input">     print a," kere iki ",motor(a),"\n"</emphasis>
    | <emphasis role="input">   end</emphasis>
    | <emphasis role="input">   def motor(b)</emphasis>
    | <emphasis role="input">     b*2</emphasis>
    | <emphasis role="input">   end</emphasis>
    | <emphasis role="input">   private:motor  # motoru kullanıcılardan saklar</emphasis>
    | <emphasis role="input"> end</emphasis>
 <emphasis role="input">   Deneme</emphasis>
<prompt>ruby&gt; </prompt> <emphasis role="input"> deneme = Deneme.new</emphasis>
   <emphasis role="output">#&lt;Deneme:0x4017181c&gt;</emphasis>
<prompt>ruby&gt; </prompt> <emphasis role="input"> deneme.motor(6)</emphasis>
<emphasis role="output">ERR: (eval):1: private method motor' called for #&lt;Deneme:0x4017181c&gt;</emphasis>
<prompt>ruby&gt; </prompt> <emphasis role="input"> deneme.iki_kati(6)</emphasis>
6 kere iki 12.
   <emphasis role="output">nil</emphasis>
</screen>
  </para>
  <para><command>deneme.motor(6)</command>'nın 12 değerini döndürmesini umuyorduk ancak
bir <literal>Deneme</literal> nesnesi gibi davrandığımızda <command>motor</command>'un erişilemez olduğunu gördük. Yalnızca <command>iki_kati</command> gibi diğer <command>Deneme</command> yöntemleri <command>motor</command>'a ulaşma hakkına sahiptir. Böylece öncelikle <command>iki_kati</command> yöntemini içeren genel arayüze gitmek zorunda bırakıldık. Yazılımcı, kullancının <command>Deneme</command> nesnelerinin birbirini nasıl etkilediğine bakmaksızın <command>motor</command> yöntemini (bu örnekte muhtemelen başarım açısından
<command>b*2</command>'yi <command>b+b</command> ile) değiştirebilir.
Bu örnek erişim denetimlerini anlatmak için tabii ki çok basit bir örnektir ancak
daha karmaşık ve ilginç sınıflar üretmeye başlayınca erişim denetiminin ne
kadar yararlı bir kavram olduğunu anlayacaksınız.
  </para>
 </chapter>
 <chapter xml:id="ruby-ug-smethots">
  <info>
   <title>Tekil Yöntemler</title>
  </info>
  <para>
Bir örneğin davranışı ait olduğu sınıf tarafından belirlenir. Ancak bazen belirli bir örneğin özel bir davranışı olmasını isteyebiliriz. Çoğu yazılım geliştirme dilinde, sadece bir kere kullanacağımız bir sınıf tanımlamak gibi karmaşık bir yol seçebiliriz. Ruby'de her nesneye kendine ait yöntemler verebiliriz.
  </para>
  <para>
   <screen><prompt>ruby&gt; </prompt><emphasis role="input"> class TekilDeneme</emphasis>
    | <emphasis role="input">   def boyut</emphasis>
    | <emphasis role="input">     print "25\n"</emphasis>
    | <emphasis role="input">   end</emphasis>
    | <emphasis role="input"> end</emphasis>
   <emphasis role="output">nil</emphasis>
<prompt>ruby&gt; </prompt> <emphasis role="input"> dnm1 = TekilDeneme.new</emphasis>
   <emphasis role="output">#&lt;TekilDeneme:0xbc468&gt;</emphasis>
<prompt>ruby&gt; </prompt> <emphasis role="input"> dnm2 = TekilDeneme.new</emphasis>
   <emphasis role="output">#&lt;TekilDeneme:0xbae20&gt;</emphasis>
<prompt>ruby&gt; </prompt> <emphasis role="input"> def dnm2.boyut</emphasis>
    | <emphasis role="input">   print "10\n"</emphasis>
    | <emphasis role="input"> end</emphasis>
   <emphasis role="output">nil</emphasis>
<prompt>ruby&gt; </prompt> <emphasis role="input"> dnm1.boyut</emphasis>
   <emphasis role="output">25</emphasis>
   <emphasis role="output">nil</emphasis>
<prompt>ruby&gt; </prompt> <emphasis role="input"> dnm2.boyut</emphasis>
   <emphasis role="output">10</emphasis>
</screen>
  </para>
  <para>
Yukarıdaki örnekte, <command>dnm1</command> ve <command>dnm2</command> aynı sınıfa mensup olmalarına rağmen, <command>dnm2</command>'nin <command>boyut</command> yöntemi yeniden tanımlandığı için farklı davranır. Sadece tekil bir nesneye verilen yönteme <literal>tekil yöntem</literal> (<emphasis>singleton method</emphasis>) denir.
  </para>
  <para>
Tekil yöntemler genelde grafik arayüzü elemanlarında (GUI) değişik düğmelerin değişik
eylemler yapması gerektiğinde kullanılır.
  </para>
  <para>
Tekil yöntemler CLOS, Dylan vb. yazılım geliştirme dillerinde olduğu üzere Ruby'ye özgü değildir. Self ve NewtonScript gibi bazı diller ise sadece tekil yöntemlerden oluşmuştur. Bu tür diller <literal>prototip tabanlı</literal> diller olarak anılırlar.
  </para>
 </chapter>
 <chapter xml:id="ruby-ug-modules">
  <info>
   <title>Modüller</title>
  </info>
  <para>
Ruby'de modüller sınıflara benzer özellikler gösterirler:
  </para>
  <para>
   <itemizedlist>
    <listitem>Modülün örneği yoktur.</listitem>
    <listitem>Modülün alt sınıfı yoktur.</listitem>
    <listitem>Modül <command>module ... end</command> şeklinde tanımlanır.</listitem>
   </itemizedlist>
  </para>
  <para>
Aslında modülün Module sınıfı, sınıfın Class sınıfının bir süper sınıfıdır. Anladınız mı? Hayır? O zaman devam edelim.
  </para>
  <para>
İki tip modül kullanımı bulunur. Bir tanesi ilişkili yöntemleri ve sabitleri merkezi bir yerde toplar. Ruby'nin standart kitaplığındaki <command>Math</command> modülü böyle bir rol oynar:
  </para>
  <para>
   <screen>
    <prompt>ruby&gt; </prompt>
    <emphasis role="input"> Math.sqrt(2)</emphasis>
    <emphasis role="output">1.41421</emphasis>
    <prompt>ruby&gt; </prompt>
    <emphasis role="input"> Math::PI</emphasis>
    <emphasis role="output">3.14159</emphasis>
   </screen>
  </para>
  <para><command>::</command> işleci Ruby yorumlayıcısına bir sabit için hangi modülü yükleyeceğini söyler. (örneğin <command>Math</command> için bir anlam ihtiva eden birşey <command>PI</command> için başka bir anlama gelebilir). Eğer bir yöntem ya da sabitin, <command>::</command> kullanmadan doğrudan modüle başvurmasını istiyorsak
bu modülü <command>include</command> ile ekleyebiliriz.
  </para>
  <para>
   <screen>
    <prompt>ruby&gt; </prompt>
    <emphasis role="input"> include Math</emphasis>
    <emphasis role="output">Object</emphasis>
    <prompt>ruby&gt; </prompt>
    <emphasis role="input"> sqrt(2)</emphasis>
    <emphasis role="output">1.41421</emphasis>
    <prompt>ruby&gt; </prompt>
    <emphasis role="input"> PI</emphasis>
    <emphasis role="output">3.14159</emphasis>
   </screen>
  </para>
  <para>
Diğer bir kullanım da <wordasword>karışım</wordasword> (mixin) olarak adlandırılır. Bazı nesneye yönelik yazılım geliştirme dili, C++ da dahil, birden fazla süper sınıftan miras almamızı sağlayan <literal>çoklu miras</literal> kavramına izin verir. Bunun gerçek dünyadaki örneği çalar saatler olabilir. Çalar saatleri hem <literal>saat</literal> sınıfına hem de <literal>alarm</literal> sınıfına sokabilirsiniz.
  </para>
  <para>
Ruby direkt olarak gerçek çoklu mirası desteklemez ancak <command>karışım</command> tekniği iyi bir alternatiftir. Modüllerin örneklenemeyeceğini ve alt sınıflanamayacağını hatırlayın, ancak bir modülü  bir sınıf tanımlamasının içine <command>include</command> ile eklersek bu yöntemi sınıfa 'karıştırmış' ya da eklemiş oluruz.
  </para>
  <para>
Karışım stratejisi, ek olarak sınıfımıza hangi özellikleri istediğimizi belirtmenin başka bir yoludur. Örneğin eğer bir sınıfın çalışan bir <command>each</command> yöntemi varsa- bunu <literal>Enumerable</literal> standart kütüphanesine eklemek size <command>sort</command> ve <command>find</command> yöntemlerini bedava verir.
  </para>
  <para>
Modüllerin bu kullanımı işlevel bir çoklu miras kullanımı sağlarken- aynı zamanda
basit bir ağaç yapısıyla sınıf akrabalıklarını temsil eder, böylece dil gerçekleştirimini basitleştirir (benzer bir dil gerçekleştirimi Java tasarımcıları tarafından da yapılmıştı).
  </para>
 </chapter>
 <chapter xml:id="ruby-ug-pobjects">
  <info>
   <title>Yordam Nesneleri</title>
  </info>
  <para>
Beklenmeyen durumlara cevap verebilme genelde istenen bir durumdur.
Eğer diğer yöntemlere kod bloklarını argüman olarak geçebilirsek yani koda bir veriymiş gibi davranabilirsek bu işi oldukça kolaylaştırmış oluruz.
  </para>
  <para>
Yeni bir <wordasword>yordam nesnesi</wordasword>, <command>proc</command> kullanılarak oluşturulur:
  </para>
  <para>
   <screen><prompt>ruby&gt; </prompt><emphasis role="input"> guguk = proc {</emphasis>
    | <emphasis role="input">   print "GUGUKGUGUKGUGUK!!!\n"</emphasis>
    | <emphasis role="input"> }</emphasis>
   <emphasis role="output">#&lt;Proc:0x4017357c&gt;</emphasis>
</screen>
  </para>
  <para>
Artık <command>guguk</command> bir nesne belirtiyor ve onun da diğer nesneler gibi istenebilir davranışları vardır. <command>call</command> yöntemi sayesinde bu davranışları talep edebiliriz:
  </para>
  <para>
   <screen><prompt>ruby&gt; </prompt><emphasis role="input"> guguk.call</emphasis>
GUGUKGUGUKGUGUK!!!
   <emphasis role="output">nil</emphasis>
</screen>
  </para>
  <para>
Peki tüm bunlardan sonra, <command>guguk</command> bir yöntem argümanı gibi kullanılabilir mi? Tabii ki.
   </para>
  <para>
   <screen><prompt>ruby&gt; </prompt><emphasis role="input"> def run( p )</emphasis>
    | <emphasis role="input">   print "Bir yordamı çağırıyoruz...\n"</emphasis>
    | <emphasis role="input">   p.call</emphasis>
    | <emphasis role="input">   print "Bitti.\n"</emphasis>
    | <emphasis role="input"> end</emphasis>
   <emphasis role="output">nil</emphasis>
<prompt>ruby&gt; </prompt> <emphasis role="input"> run guguk</emphasis>
Bir yordamı çağırıyoruz...
GUGUKGUGUKGUGUK!!!
Bitti.
   <emphasis role="output">nil</emphasis>
</screen>
  </para>
  <para><command>trap</command> yöntemi aldığımız cevabı tercihimize göre istediğimiz sistem sinyaline atamamıza izin verir.
  </para>
  <para>
   <screen>
    <prompt>ruby&gt; </prompt>
    <emphasis role="input"> inthandler = proc{ print "^C basıldı.\n" }</emphasis>
    <emphasis role="output">#&lt;Proc:0x401730a4&gt;</emphasis>
    <prompt>ruby&gt; </prompt>
    <emphasis role="input"> trap "SIGINT", inthandler</emphasis>
    <emphasis role="output">#&lt;Proc:0x401735e0&gt;</emphasis>
   </screen>
  </para>
  <para>
Normalde <literal>^C</literal>'ye basmak yorumlayıcıdan çıkmamızı sağlar. Ancak şimdi bir ileti yazıldı ve yorumlayıcı hala çalışmaya devam ediyor, böylece yaptığınız işi kaybetmemiş oluyorsunuz. (Yorumlayıcıda sonsuza dek kapana kısılmadınız, hala <command>exit</command> yazarak ya da <literal>^D</literal>'ye basarak çıkabilirsiniz.)
  </para>
  <para>
Başka konulara geçmeden önce son bir not: bir yordamı bir sinyale bağlamadan önce ona illa ki isim vermek gerekli değildir. <literal>Anonim</literal> bir yordam nesnesi aşağıdaki gibi olabilir:
  </para>
  <para>
   <screen>
    <prompt>ruby&gt; </prompt>
    <emphasis role="input"> trap "SIGINT", proc{ print "^C basıldı.\n" }</emphasis>
    <emphasis role="output">nil</emphasis>
   </screen>
  </para>
  <para>daha kısa şekilde,</para>
  <para>
   <screen>
    <prompt>ruby&gt; </prompt>
    <emphasis role="input"> trap "SIGINT", 'print "^C basıldı.\n"'</emphasis>
    <emphasis role="output">nil</emphasis>
   </screen>
  </para>
  <para>
Bu kısaltılmış biçim, küçük anonim yordamlar yazdığınızda okunabilirlik sağlar.
  </para>
 </chapter>
 <chapter xml:id="ruby-ug-vars">
  <info>
   <title>Değişkenler</title>
  </info>
  <para>
Ruby biri sabit, ikisi de yarı-değişken olmak üzere üç çeşit değişkene sahiptir. Değişkenlerin ve sabitlerin türü yoktur. Türü olmayan değişkenler sakıncalı olsa bile, Ruby'nin <literal>kolay ve hızlı</literal> felsefesine uygun olarak bir çok avantaj sağlar.
  </para>
  <para>
Bir çok yazılım geliştirme dilinde değiştirilebilirliğini sağlamak (sabit olsalar bile) ve etki alanını belirlemek için değişkenlerin türü belirtilerek bildirilmesi gerekir.
Ancak değişken türleri önemli olmadığından ve aşikar çözümün göreceğiniz gibi değişken isminden halledilebilediğinden beri, Ruby'de değişken bildirimlerine ihtiyacımız yoktur.
  </para>
  <para>
Değişken isminin ilk karakteri sayesinde bir bakışta türünü anlamak mümkündür:
  </para>
  <para>
   <table pgwide="1">
    <tgroup cols="2" align="left" colsep="1" rowsep="1">
     <colspec colwidth=".3"/>
     <colspec colwidth=".7"/>
     <tbody>
      <row>
       <entry>
        <command>$</command>
       </entry>
       <entry>genel değişken</entry>
      </row>
      <row>
       <entry>
        <command>@</command>
       </entry>
       <entry>örnek  değişken</entry>
      </row>
      <row>
       <entry><command>[a-z]</command> ya da <command>_</command></entry>
       <entry>yerel değişken</entry>
      </row>
      <row>
       <entry>
        <command>[A-Z]</command>
       </entry>
       <entry>sabit</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </para>
  <para>
Bunların dışında tek istisna Ruby'nin yarı-değişkenleridir: daima o an çalışmakta olan nesneyi ifade eden <command>self</command> ve ilklendirilmemiş değişkenlere atanan anlamsız değer olan <command>nil</command>. Her ikisi de yerel değişkenler gibi tanımlanmış olsalar da, <command>self</command> yorumlayıcı tarafından saklanan bir genel değişken ve <command>nil</command> de gerçekte bir sabittir. Bunlar sadece iki istisna olduğu için üzerlerinde fazla durmayacağız.
  </para>
  <para><command>self</command>'e ya da <command>nil</command>'e değer atamamalıyız. <command>main</command>, bir <command>self</command> değeri olarak üst nesneyi ifade eder:
  </para>
  <para>
   <screen>
    <prompt>ruby&gt; </prompt>
    <emphasis role="input"> self</emphasis>
    <emphasis role="output">main</emphasis>
    <prompt>ruby&gt; </prompt>
    <emphasis role="input"> nil</emphasis>
    <emphasis role="output">nil</emphasis>
   </screen>
  </para>
 </chapter>
 <chapter xml:id="ruby-ug-globalvars">
  <info>
   <title>Genel Değişkenler</title>
  </info>
  <para>
Genel değişkenler isimlerinin başında birer <command>$</command> işareti bulundururlar.
Genel değişkenlere yazılımın her hangi bir yerinden başvurulabilir. İlklendirilmeden önce <command>nil</command> değerine sahiptirler.
  </para>
  <para>
   <screen>
    <prompt>ruby&gt; </prompt>
    <emphasis role="input"> $foo</emphasis>
    <emphasis role="output">nil</emphasis>
    <prompt>ruby&gt; </prompt>
    <emphasis role="input"> $foo = 5</emphasis>
    <emphasis role="output">5</emphasis>
    <prompt>ruby&gt; </prompt>
    <emphasis role="input"> $foo</emphasis>
    <emphasis role="output">5</emphasis>
   </screen>
  </para>
  <para>
Genel değişkenler dikkatli kullanılmalıdırlar. Her yerden yazılabildikleri için tehlikelidirler. Genel değişkenlerin aşırı kullanılması yanlışları izole etmede zorluk çıkarabildiği gibi yazılımın iyice düşünülmeden tasarlandığına dikkat çeker.
Genel değişken kullanmayı uygun gördüğünüz zaman, onlara anlaşılabilir isimler verdiğinizden emin olun ( <command>$foo</command> gibi birşeyi çağırmak oldukça kötü bir fikir değil mi?).
  </para>
  <para>
Genel değişkenlerin güzel bir özelliği de izlenebilir olmalarıdır; bir değişkenin değeri ne zaman değişirse o zaman çağrılan bir yordam belirleyebilirsiniz.
  </para>
  <para>
   <screen><prompt>ruby&gt; </prompt><emphasis role="input"> trace_var :$x, proc{print "$x şimdi ", $x, "\n"}</emphasis><emphasis role="output">nil</emphasis><prompt>ruby&gt; </prompt><emphasis role="input"> $x = 5</emphasis>
$x şimdi 5
   <emphasis role="output">5</emphasis>
</screen>
  </para>
  <para>
Bir global değişken, değiştiği zaman bir yordamı çalıştırmak için kullanılıyorsa, <wordasword>etkin değişken</wordasword> olarak da anılır.
  </para>
  <para>
Aşağıda <command>$</command> işaretini takiben tek bir karakter daha içeren bir dizi özel değişken bulunuyor. Örneğin <command>$$</command> Ruby yorumcusunun süreç numarasını içerir ve sadece okunabilirdir. Aşağıda önemli sistem değişkenleri ve anlamları bulunuyor: (ayrıntılar için <link xlink:href="http://www.ruby-lang.org/en/man-1.4/">Ruby Başvuru Kılavuzu</link>na bakınız):
  </para>
  <para>
   <table pgwide="1">
    <tgroup cols="2" align="left" colsep="1" rowsep="1">
     <colspec colwidth=".1"/>
     <colspec colwidth=".9"/>
     <tbody>
      <row>
       <entry>
        <command>$!</command>
       </entry>
       <entry>son hata iletisi</entry>
      </row>
      <row>
       <entry>
        <command>$@</command>
       </entry>
       <entry>hatanın konumu</entry>
      </row>
      <row>
       <entry>
        <command>$_</command>
       </entry>
       <entry><command>gets</command> tarafından okunan son dizge</entry>
      </row>
      <row>
       <entry>
        <command>$.</command>
       </entry>
       <entry>yorumlayıcı tarafından son okunan satır numarası</entry>
      </row>
      <row>
       <entry>
        <command>$&amp;</command>
       </entry>
       <entry>regexp tarafından son bulunan dizge</entry>
      </row>
      <row>
       <entry>
        <command>$~</command>
       </entry>
       <entry>alt ifade (<emphasis>subexpression</emphasis>) dizisi olarak regexp tarafından bulunan son ifade</entry>
      </row>
      <row>
       <entry>
        <command>$</command>
        <literal>n</literal>
       </entry>
       <entry>son bulunan <literal>n</literal>'inci alt ifade (<command>$~[</command><literal>n</literal><command>]</command> ile aynı)</entry>
      </row>
      <row>
       <entry>
        <command>$=</command>
       </entry>
       <entry>büyük-küçük harfe duyarsız bayrak</entry>
      </row>
      <row>
       <entry>
        <command>$/</command>
       </entry>
       <entry>girdi kaydı ayracı (<emphasis>input record separator</emphasis>)</entry>
      </row>
      <row>
       <entry>
        <command>$\</command>
       </entry>
       <entry>çıktı kaydı ayracı (<emphasis>output record separator</emphasis>)</entry>
      </row>
      <row>
       <entry>
        <command>$0</command>
       </entry>
       <entry>ruby betik dosyasının adı</entry>
      </row>
      <row>
       <entry>
        <command>$*</command>
       </entry>
       <entry>komut satırı argümanları</entry>
      </row>
      <row>
       <entry>
        <command>$$</command>
       </entry>
       <entry>yorumcunun süreç numarası (PID)</entry>
      </row>
      <row>
       <entry>
        <command>$?</command>
       </entry>
       <entry>son işletilen çocuk sürecin çıkış durumu</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </para>
  <para><command>$_</command> ve <command>$~</command> için etki alanı yereldir. Her ne kadar isimleri gereği genel değişkenler olmaları gerekiyorsa da böyle daha kullanışlıdırlar.
  </para>
 </chapter>
 <chapter xml:id="ruby-ug-instancevars">
  <info>
   <title>Örnek Değişkenler</title>
  </info>
  <para>
Örnek değişken <command>@</command> ile başlayan bir ada sahiptir ve etki alanı <command>self</command> nesnesi ile sınırlıdır. Aynı sınıfa dahil olan iki aynı nesne için iki değişik örnek değişken tanımlamak mümkündür.
  </para>
  <para>
Örnek değişkenler, yazılımcı hangi yöntemi tanımlarsa tanımlasın bir nesnenin dışından değiştirilemez (Ruby'nin örnek değişkenleri hiçbir zaman <emphasis>genel</emphasis> olamaz). Genel değişkenlerde olduğu gibi, örnek değişkenler de başlangıç değeri atanmazsa <command>nil</command> değerine sahip olurlar.
  </para>
  <para>
Ruby'de örnek değişkenleri bildirmeye gerek yoktur. Bu durum nesnelerin yapısına esneklik kazandırır. Aslında, her örnek değişken, nesnedeki ilk kullanımında kendiliğinden oluşturulur.
  </para>
  <para>
   <screen><prompt>ruby&gt; </prompt><emphasis role="input"> class OrnekDeneme</emphasis>
    | <emphasis role="input">   def set_foo(n)</emphasis>
    | <emphasis role="input">     @foo = n</emphasis>
    | <emphasis role="input">   end</emphasis>
    | <emphasis role="input">   def set_bar(n)</emphasis>
    | <emphasis role="input">     @bar = n</emphasis>
    | <emphasis role="input">   end</emphasis>
    | <emphasis role="input"> end</emphasis>
   <emphasis role="output">nil</emphasis>
<prompt>ruby&gt; </prompt> <emphasis role="input"> i = OrnekDeneme.new</emphasis>
   <emphasis role="output">#&lt;OrnekDeneme:0x83678&gt;</emphasis>
<prompt>ruby&gt; </prompt> <emphasis role="input"> i.set_foo(2)</emphasis>
   <emphasis role="output">2</emphasis>
<prompt>ruby&gt; </prompt> <emphasis role="input"> i</emphasis>
   <emphasis role="output">#&lt;OrnekDeneme:0x83678 @foo=2&gt;</emphasis>
<prompt>ruby&gt; </prompt> <emphasis role="input"> i.set_bar(4)</emphasis>
   <emphasis role="output">4</emphasis>
<prompt>ruby&gt; </prompt> <emphasis role="input"> i</emphasis>
   <emphasis role="output">#&lt;OrnekDeneme:0x83678 @foo=2, @bar=4&gt;</emphasis>
</screen>
  </para>
  <para><command>i</command>'nin <command>set_bar</command> yöntemi çağrılmadan <command>@bar</command>'ın  hiçbir değer belirtmediğine dikkat edin.
  </para>
 </chapter>
 <chapter xml:id="ruby-ug-localvars">
  <info>
   <title>Yerel Değişkenler</title>
  </info>
  <para>
Yerel değişkenler küçük harfle ya da <command>_</command> karakteriyle başlayan isimlere sahiptirler. Yerel değişkenler genel ya da örnek değişkenlerde olduğu gibi, başlangıçta <command>nil</command> değerine sahip değildirler.
  </para>
  <para>
   <screen>
    <prompt>ruby&gt; </prompt>
    <emphasis role="input"> $foo</emphasis>
    <emphasis role="output">nil</emphasis>
    <prompt>ruby&gt; </prompt>
    <emphasis role="input"> @foo</emphasis>
    <emphasis role="output">nil</emphasis>
    <prompt>ruby&gt; </prompt>
    <emphasis role="input"> foo</emphasis>
    <emphasis role="output">ERR: (eval):1: undefined local variable or method `foo' for main(Object)</emphasis>
   </screen>
  </para>
  <para>
Yerel bir değişkene yaptığınız ilk atama onu bildirmekle aynı şeydir.
Eğer başlangıç değeri olmayan bir yerel değişkene başvurursanız, Ruby yorumlayıcısı bunun bir yöntemi çalıştırma girişimi olduğunu düşünür ve aşağıdaki gibi bir hata verir.
  </para>
  <para>
Genelde yerel bir değişkenin etki alanı aşağıdakilerden biridir:
  </para>
  <para>
   <itemizedlist>
    <listitem><command>proc{</command> ... <command>}</command></listitem>
    <listitem><command>loop{</command> ... <command>}</command></listitem>
    <listitem><command>def</command> ... <command>end</command></listitem>
    <listitem><command>class</command> ... <command>end</command></listitem>
    <listitem><command>module</command> ... <command>end</command></listitem>
    <listitem>yazılımın tamamı (yukarıdakilerden herhangi biri yoksa)</listitem>
   </itemizedlist>
  </para>
  <para>
Aşağıdaki örnekte görülen <command>defined?</command> işleci bir belirtecin tanımlanıp tanımlanmadığına bakar. Eğer tanımlanmışsa bir açıklama döndürür; tanımlanmamış ise <command>nil</command> değerini döndürür. Gördüğünüz gibi <command>bar</command> döngüde yerel, döngüden çıkınca tanımsızdır.
  </para>
  <para>
   <screen><prompt>ruby&gt; </prompt><emphasis role="input"> foo = 44; print foo, "\n"; defined? foo</emphasis>
44
   <emphasis role="output">"local-variable"</emphasis>
<prompt>ruby&gt; </prompt> <emphasis role="input"> loop{bar=45; print bar, "\n"; break}; defined? bar</emphasis>
45
   <emphasis role="output">nil</emphasis>
</screen>
  </para>
  <para>
Yordam nesneleri yynı etki alanındaki yerel değişkenleri paylaşırlar. Örnekte yerel değişken <command>bar</command>, <command>main</command> ve yordam nesneleri <command>p1</command> ve <command>p2</command> tarafından paylaşılmaktadır:
  </para>
  <para>
   <screen>
    <prompt>ruby&gt; </prompt>
    <emphasis role="input"> bar=nil</emphasis>
    <emphasis role="output">nil</emphasis>
    <prompt>ruby&gt; </prompt>
    <emphasis role="input"> p1 = proc{|n| bar=n}</emphasis>
    <emphasis role="output">#&lt;Proc:0x8deb0&gt;</emphasis>
    <prompt>ruby&gt; </prompt>
    <emphasis role="input"> p2 = proc{bar}</emphasis>
    <emphasis role="output">#&lt;Proc:0x8dce8&gt;</emphasis>
    <prompt>ruby&gt; </prompt>
    <emphasis role="input"> p1.call(5)</emphasis>
    <emphasis role="output">5</emphasis>
    <prompt>ruby&gt; </prompt>
    <emphasis role="input"> bar</emphasis>
    <emphasis role="output">5</emphasis>
    <prompt>ruby&gt; </prompt>
    <emphasis role="input"> p2.call</emphasis>
    <emphasis role="output">5</emphasis>
   </screen>
  </para>
  <para>
Baştaki "<literal>bar=nil</literal>"'ın çıkarılamayacağına dikkat edin; bu atama <command>bar</command>'ın <command>p1</command> ve <command>p2</command> tarafından kuşatılacağını garanti eder. Öteki türlü <command>p1</command> ve <command>p2</command> kendi yerel <command>bar</command> değişkenlerini sonlandırır ve <command>p2</command>'yi çağırmak "undefined local variable or method" hatasına neden olabilir.
  </para>
  <para>
Yordam nesnelerinin güçlü bir özelliği de argüman olarak aktarılabilme yetenekleridir: paylaşımlı yerel değişkenler özgün etki alanının dışından değer aktarıldığında bile geçerli kalırlar.
  </para>
  <para>
   <screen><prompt>ruby&gt; </prompt><emphasis role="input"> def kutu</emphasis>
    | <emphasis role="input">   icerik = 15</emphasis>
    | <emphasis role="input">   getir = proc{icerik}</emphasis>
    | <emphasis role="input">   ata = proc{|n| icerik = n}</emphasis>
    | <emphasis role="input">   return getir, ata</emphasis>
    | <emphasis role="input"> end</emphasis>
   <emphasis role="output">nil</emphasis>
<prompt>ruby&gt; </prompt> <emphasis role="input"> okur, yazar = kutu</emphasis>
   <emphasis role="output">[#&lt;Proc:0x40170fc0&gt;, #&lt;Proc:0x40170fac&gt;]</emphasis>
<prompt>ruby&gt; </prompt> <emphasis role="input"> okur.call</emphasis>
   <emphasis role="output">nil</emphasis>
<prompt>ruby&gt; </prompt> <emphasis role="input"> yazar.call(2)</emphasis>
   <emphasis role="output">2</emphasis>
<prompt>ruby&gt; </prompt> <emphasis role="input"> okur.call</emphasis>
   <emphasis role="output">2</emphasis>
</screen>
  </para>
  <para>
Ruby etki alanı konusunda bir parça akıllıca davranır. Örneğimizde <command>icerik</command> değişkeni <command>okur</command> ve <command>yazar</command> tarafından paylaşılıyordu. Aynı zamanda yukarıda tanımladığımız kutumuzdan birden çok okur-yazar çifti oluşturabilir ve her çiftin aynı sabiti paylaşmasını sağlayabiliriz.
  </para>
  <para>
   <screen>
    <prompt>ruby&gt; </prompt>
    <emphasis role="input"> okur_1, yazar_1 = kutu</emphasis>
    <emphasis role="output">[#&lt;Proc:0x40172820&gt;, #&lt;Proc:0x4017280c&gt;]</emphasis>
    <prompt>ruby&gt; </prompt>
    <emphasis role="input"> okur_2, yazar_2 = kutu</emphasis>
    <emphasis role="output">[#&lt;Proc:0x40172668&gt;, #&lt;Proc:0x40172654&gt;]</emphasis>
    <prompt>ruby&gt; </prompt>
    <emphasis role="input"> yazar_1.call(99)</emphasis>
    <emphasis role="output">99</emphasis>
    <prompt>ruby&gt; </prompt>
    <emphasis role="input"> okur_1.call</emphasis>
    <emphasis role="output">99</emphasis>
    <prompt>ruby&gt; </prompt>
    <emphasis role="input"> okur_2.call</emphasis>
    <emphasis role="output">nil</emphasis>
   </screen>
  </para>
 </chapter>
 <chapter xml:id="ruby-ug-constants">
  <info>
   <title>Sınıf Sabitleri</title>
  </info>
  <para>
Bir sabit büyük harfle başlayan bir ada sahiptir. Sabitlere bir kere değer ataması yapılmalıdır. Ruby'nin şu anki uygulamasına göre, sabitlere yeniden değer ataması yapmak hata değil uyarı ile sonuçlanır (eval.rb'nin ANSI olmayan sürümü uyarı değil hata raporlar):
  </para>
  <para>
   <screen>
    <prompt>ruby&gt; </prompt>
    <emphasis role="input">fluid=30</emphasis>
    <emphasis role="output">30</emphasis>
    <prompt>ruby&gt; </prompt>
    <emphasis role="input">fluid=31</emphasis>
    <emphasis role="output">31</emphasis>
    <prompt>ruby&gt; </prompt>
    <emphasis role="input">Solid=32</emphasis>
    <emphasis role="output">32</emphasis>
    <prompt>ruby&gt; </prompt>
    <emphasis role="input">Solid=33</emphasis>
    <emphasis role="output">(eval):1: warning: already initialized constant Solid
   33</emphasis>
   </screen>
  </para>
  <para>
Sabitler sınıflarla beraber tanımlanabilirler ancak örnek değişkenlerin aksine sınıfın dışından da erişilebilir durumdadırlar.
  </para>
  <para>
   <screen><prompt>ruby&gt; </prompt><emphasis role="input"> class SabitSinifi</emphasis>
    | <emphasis role="input">   C1=101</emphasis>
    | <emphasis role="input">   C2=102</emphasis>
    | <emphasis role="input">   C3=103</emphasis>
    | <emphasis role="input">   def goster</emphasis>
    | <emphasis role="input">     print C1," ",C2," ",C3,"\n"</emphasis>
    | <emphasis role="input">   end</emphasis>
    | <emphasis role="input"> end</emphasis>
   <emphasis role="output">nil</emphasis>
<prompt>ruby&gt; </prompt> <emphasis role="input"> C1</emphasis>
<emphasis role="output">ERR: (eval):1: uninitialized constant C1</emphasis>
<prompt>ruby&gt; </prompt> <emphasis role="input"> SabitSinifi::C1</emphasis>
   <emphasis role="output">101</emphasis>
<prompt>ruby&gt; </prompt> <emphasis role="input"> SabitSinifi.new.goster</emphasis>
101 102 103
   <emphasis role="output">nil</emphasis>
</screen>
  </para>
  <para>Sabitler aynı zamanda modül içinde de tanımlanabilirler.
  </para>
  <para>
   <screen><prompt>ruby&gt; </prompt><emphasis role="input"> module SabitModulu</emphasis>
    | <emphasis role="input">   C1=101</emphasis>
    | <emphasis role="input">   C2=102</emphasis>
    | <emphasis role="input">   C3=103</emphasis>
    | <emphasis role="input">   def sabitleriGoster</emphasis>
    | <emphasis role="input">     print C1," ",C2," ",C3,"\n"</emphasis>
    | <emphasis role="input">   end</emphasis>
    | <emphasis role="input"> end</emphasis>
   <emphasis role="output">nil</emphasis>
<prompt>ruby&gt; </prompt> <emphasis role="input"> C1</emphasis>
<emphasis role="output">ERR: (eval):1: uninitialized constant C1</emphasis>
<prompt>ruby&gt; </prompt> <emphasis role="input"> include SabitModulu</emphasis>
   <emphasis role="output">Object</emphasis>
<prompt>ruby&gt; </prompt> <emphasis role="input"> C1</emphasis>
   <emphasis role="output">101</emphasis>
<prompt>ruby&gt; </prompt> <emphasis role="input"> sabitleriGoster</emphasis>
101 102 103
   <emphasis role="output">nil</emphasis>
<prompt>ruby&gt; </prompt> <emphasis role="input"> C1=99</emphasis>  # pek iyi bir fikir değil
   <emphasis role="output">99</emphasis>
<prompt>ruby&gt; </prompt> <emphasis role="input"> C1</emphasis>
   <emphasis role="output">99</emphasis>
<prompt>ruby&gt; </prompt> <emphasis role="input"> SabitModulu::C1</emphasis>  # modülün sabiti rahatsız edilmemiş...
   <emphasis role="output">101</emphasis>
<prompt>ruby&gt; </prompt> <emphasis role="input"> SabitModulu::C1=99 </emphasis>  # önceki sürümlerde buna izin verilmez
   <emphasis role="output">(eval):1: warning: already initialized constant C1
   99</emphasis>
<prompt>ruby&gt; </prompt> <emphasis role="input"> SabitModulu::C1</emphasis>  # sen iste yeter ki...
   <emphasis role="output">99</emphasis>
</screen>
  </para>
 </chapter>
 <chapter xml:id="ruby-ug-rescue">
  <info>
   <title>Hata İşleme: <literal>rescue</literal> deyimi</title>
  </info>
  <para>
Çalıştırılan bir yazılım beklenmeyen sorunlar doğurabilir. Okunmaya çalışılan bir dosya mevcut olmayabilir ya da veri kaydetmemek istediğimiz disk dolu olabilir yada kullanıcı beklenmeyen bir girdi yapabilir.
  </para>
  <para>
   <screen>
    <prompt>ruby&gt; </prompt>
    <emphasis role="input"> file = open("bir_dosya")</emphasis>
    <emphasis role="output">ERR: (eval):1:in `open': No such file or directory - bir_dosya</emphasis>
   </screen>
  </para>
  <para>
Güçlü bir yazılım bu gibi durumları hassasiyetle yakalayacaktır. C yazılımcılarından, hata doğurabilecek her sistem çağrısının sonucunu kontrol etmeleri ve anında ne yapılacağına ilişkin karar vermeleri beklenir:
  </para>
  <para>
   <screen>FILE *file = fopen("bir_dosya", "r");
if (file == NULL) {
  fprintf( stderr, "Dosya mevcut değil.\n" );
  exit(1);
}
bytes_read = fread( buf, 1, bytes_desired, file );
if (bytes_read != bytes_desired ) {
  /* hata giderme işlemleri... */
}
...
</screen>
  </para>
  <para>
Bu yazılımcıları dikkatsizliğe ve ihmalciliğe iten, üstelik hataları tam olarak yakalayamayan bir yazılım yazmanıza yol açan sıkıcı bir uygulamadır. Öte yandan, işi doğru düzgün yapmak, yakalanabilecek bir çok hata olduğu için yazılımın okunabilirliğini oldukça zorlaştıracaktır.
  </para>
  <para>
Güncel bir çok dilde olduğu gibi Ruby'de de, yazılımcıyı ya da sonradan kodumuzu okuyan kişileri sıkıntıya sokmadan, sürprizleri kod bloklarından soyutlayan bir yolla yakalayabiliriz.
  </para>
  <para><command>begin</command> ile işaretlenmiş kod bloğu bir istisnayla karşılaşana dek çalıştırılır, hata durumunda denetimi <command>rescue</command> ile işaretlenmiş kod bloğuna verir. Eğer hiçbir istisnayla karşılaşılmazsa <command>rescue</command> kodu kullanılmaz. Aşağıdaki yöntem bir metin dosyasının ilk satırını döndürür, bir istisna ile karşılaşırsa <command>nil</command> değerini:
  </para>
  <para>
   <screen>
def first_line( filename )
  begin
    file = open("bir_dosya")
    info = file.gets
    file.close
    info  # Değerlendirmeye alınan son şey dönüş değeri
  rescue
    nil   # Dosyayı okuyamıyor musunuz? O zaman bir dizge dönmez.
  end
end
</screen>
  </para>
  <para>
Bir problemle yaratıcı bir biçimde ilgilenmek istediğimiz zamanlar olacaktır. Örneğin dosyaya erişmek mümkün değilse standart girdi yerine başka bir şey kullanmak isteyebiliriz:
  </para>
  <para>
   <screen>
begin
  file = open("bir_dosya")
rescue
  file = STDIN
end

begin
  # ... girdiyi değerlendir ...
rescue
  # ... burada diğer istisnalarla uğraş.
end
</screen>
  </para>
  <para><command>begin</command> kodunu tekrar çalıştırmak için <command>rescue</command>'nun içinde <command>retry</command>'ı kullanabiliriz. Bu bize önceki örneğimizi daha kısa şekilde yazmamıza izin verir:
  </para>
  <para>
   <screen>
fname = "bir_dosya"
begin
  file = open(fname)
  # ... girdiyi degerlendir ...
rescue
  fname = "STDIN"
  retry
end
</screen>
  </para>
  <para>
Ancak burada bir kusur bulunmaktadır. Hiç olmayan bir dosya bu kodun sonsuz bir döngüde kendisini tekrar etmesini sağlayacaktır. <command>retry</command>'ı kullanırken bu tür durumlara dikkat etmelisiniz.
  </para>
  <para>
Her Ruby kütüphanesi, sizin de kendi kodunuzda yapabileceğiniz gibi, herhangi bir hata karşısında bir istisna doğurur. Bir istisnayı çıkarmak için <command>raise</command> kullanılır. <command>raise</command> tek argüman olarak istisnayı açıklayan bir dizge alır. Bu argüman isteğe bağlıdır ancak atlanmaması gereken bir husustur. Özel değişkenlerden olan <command>$!</command> ile sonradan ulaşılabilir.
  </para>
  <para>
   <screen><prompt>ruby&gt; </prompt><emphasis role="input"> raise "deneme hatası"</emphasis><emphasis role="output">deneme hatası</emphasis><prompt>ruby&gt; </prompt><emphasis role="input"> begin</emphasis>
    | <emphasis role="input">   raise "dnm2"</emphasis>
    | <emphasis role="input"> rescue</emphasis>
    | <emphasis role="input">   print "Bir hata meydana geldi: ",$!, "\n"</emphasis>
    | <emphasis role="input"> end</emphasis>
Bir hata meydana geldi: dnm2
   <emphasis role="output">nil</emphasis>
</screen>
  </para>
 </chapter>
 <chapter xml:id="ruby-ug-ensure">
  <info>
   <title>Hata İşleme: <literal>ensure</literal> deyimi</title>
  </info>
  <para>
Bazen bir yöntem işini bitirdikten sonra temizlik yapılması gerekebilir. Örneğin açılmış olan bir dosyanın kapatılması ya da bir veri için ayrılan bellek gözesinin boşaltılması gerekebilir. Eğer her yöntem için her zaman tek bir çıkış noktası olsaydı temizleme kodumuzu tek bir yere koyardık ve çalıştırılacağından emin olurduk. Ancak yöntem bir çok yere geri dönebilir ve temizlik kodumuz beklenmeyen istisnalardan dolayı atlanabilir.
  </para>
  <para>
   <screen>
begin
  file = open("/tmp/bir_dosya", "w")
  # ... dosyaya yaziliyor...
  file.close
end
</screen>
  </para>
  <para>
Ayrıca eğer kodun dosyaya yazdığımız kısmında bir istisna meydana gelirse o zaman dosya açık bırakılabilir. Ve böyle bir fazlalığa gitmek istemeyiz:
  </para>
  <para>
   <screen>
begin
  file = open("/tmp/bir_dosya", "w")
  # ... dosyaya yazılıyor ...
  file.close
rescue
  file.close
  fail # istisna yakalanıyor
end
</screen>
  </para>
  <para>
Bu hantal bir yöntemdir; her <command>return</command> ve <command>break</command> ile ilgilenmek zorunda kalınca işler çığrından çıkar.
  </para>
  <para>
Bu yüzden "<command>begin...rescue...end</command>" şemasına <command>ensure</command> adında başka bir anahtar kelime daha ekleriz. <command>ensure</command> kodu <command>begin</command> kodunun başarılı olup olmadığına bakmaksızın çalıştırılır.
  </para>
  <para>
   <screen>
begin
  file = open("/tmp/bir_dosya", "w")
  # ... dosyaya yazılıyor ...
rescue
  # ... istisnalar yakalanıyor...
ensure
  file.close   # ...her zaman yapılması gerekir
end
</screen>
  </para>
  <para><command>ensure</command> kodunu <command>rescue</command> olmadan da kullanmak mümkündür ya da tam tersi; ancak aynı <command>begin...end </command> bloğunda birlikte kullanılıyorlarsa <command>rescue</command>, <command>ensure</command>'den önce gelmelidir.
  </para>
 </chapter>
 <chapter xml:id="ruby-ug-accessors">
  <info>
   <title>Erişgeçler</title>
  </info>
  <para>
Geçtiğimiz bölümlerde örnek değişkenlerden kısaca bahsettik ancak henüz işimiz bitmedi.
Bir nesnenin örnek değişkenleri onun kendisine ait olan ve aynı sınıfa ait diğer nesnelerden ayıran öznitelikleridir.
  </para>
  <para>
Bu öznitelikleri okuyabilmek ve yazabilmek önemlidir; bu yüzden <wordasword>öznitelik erişgeçleri</wordasword> denilen yöntemi kullanırız. Bir kaç dakika sonra erişgeç yöntemlerini her zaman açıkça yazmak zorunda olmadığımızı göreceksiniz ancak şimdilik tüm devinimlere bakalım. Erişgeçler iki çeşittir: <emphasis>yazıcılar</emphasis> ve <emphasis>okuyucular</emphasis>.
  </para>
  <para>
   <screen><prompt>ruby&gt; </prompt><emphasis role="input"> class Meyve</emphasis>
    | <emphasis role="input">   def cesit_ata(k)  # bir yazıcı</emphasis>
    | <emphasis role="input">     @kind = k</emphasis>
    | <emphasis role="input">   end</emphasis>
    | <emphasis role="input">   def ne_cesit     # bir okuyucu</emphasis>
    | <emphasis role="input">     @kind</emphasis>
    | <emphasis role="input">   end</emphasis>
    | <emphasis role="input"> end</emphasis>
   <emphasis role="output">nil</emphasis>
<prompt>ruby&gt; </prompt> <emphasis role="input"> f1 = Meyve.new</emphasis>
   <emphasis role="output">#&lt;Meyve:0xfd7e7c8c&gt;</emphasis>
<prompt>ruby&gt; </prompt> <emphasis role="input"> f1.cesit_ata("seftali")</emphasis>  # yazıcıyı kullan
   <emphasis role="output">"seftali"</emphasis>
<prompt>ruby&gt; </prompt> <emphasis role="input"> f1.ne_cesit</emphasis>           # okuyucuyu kullan
   <emphasis role="output">"seftali"</emphasis>
<prompt>ruby&gt; </prompt> <emphasis role="input"> f1</emphasis>                    # nesneyi yokla
   <emphasis role="output">#&lt;Meyve:0xfd7e7c8c @kind="seftali"&gt;</emphasis>
</screen>
  </para>
  <para>
Yeterince basit; baktığımız meyve hakkında istediğimiz bilgiyi yerleştirebilir ya da erişebiliriz. Ama yöntem isimlerimiz biraz uzun. Aşağıdaki daha kısa ve daha uzlaşımsal:
  </para>
  <para>
   <screen><prompt>ruby&gt; </prompt><emphasis role="input"> class Meyve</emphasis>
    | <emphasis role="input">   def cesidi=(k)</emphasis>
    | <emphasis role="input">     @cesidi = k</emphasis>
    | <emphasis role="input">   end</emphasis>
    | <emphasis role="input">   def cesidi</emphasis>
    | <emphasis role="input">     @cesidi</emphasis>
    | <emphasis role="input">   end</emphasis>
    | <emphasis role="input"> end</emphasis>
   <emphasis role="output">nil</emphasis>
<prompt>ruby&gt; </prompt> <emphasis role="input"> meyve = Meyve.new</emphasis>
   <emphasis role="output">#&lt;Meyve:0xfd7e7c8c&gt;</emphasis>
<prompt>ruby&gt; </prompt> <emphasis role="input"> meyve.cesidi = "muz"</emphasis>
   <emphasis role="output">"muz"</emphasis>
<prompt>ruby&gt; </prompt> <emphasis role="input"> meyve.cesidi</emphasis>
   <emphasis role="output">"muz"</emphasis>
</screen>
  </para>
  <bridgehead renderas="sect3" xml:id="ruby-ug-inspect"><literal>inspect</literal> yöntemi</bridgehead>
  <para>
Küçük bir uzlaşma sağlanmıştır. Bir nesneye doğrudan ulaşmak istediğimizde <command>#&lt;birNesne:0x83678&gt;</command> gibi şifreye benzer birşeyle karşılaştığımıza dikkat edin. Bu öntanımlı bir davranıştır ve istediğiniz gibi değiştirebilirsiniz. Yapmanız gerek tek şey <command>inspect</command> yöntemini eklemektir. <command>inspect</command> yöntemi, nesneyi birkaç ya da bütün örnek değişkenleri de içeren ve mantıklı bir şekilde tanıtan bir yöntemdir.
  </para>
  <para>
   <screen><prompt>ruby&gt; </prompt><emphasis role="input"> class Meyve</emphasis>
    | <emphasis role="input">   def inspect</emphasis>
    | <emphasis role="input">     @kind + "bir meyve çeşididir"</emphasis>
    | <emphasis role="input">   end</emphasis>
    | <emphasis role="input"> end</emphasis>
   <emphasis role="output">nil</emphasis>
<prompt>ruby&gt; </prompt> <emphasis role="input">meyve</emphasis>
   <emphasis role="output">"muz bir meyve çeşididir"</emphasis>
</screen>
  </para>
  <para>
Benzer bir yöntem de ekrana bir nesne yazdıracağımız zaman kullandığımız <command>to_s</command> (dizgeye dönüştürür) yöntemidir. Genel olarak <command>inspect</command> yöntemini yazılım geliştirirken ve hata ayıklarken kullandığınız bir araç olarak, <command>to_s</command>'yi de  yazılımın çıktısını düzeltmek için kullandığımız  bir yol düşünebilirsiniz.
  </para>
  <para><command>eval.rb</command> sonuçları görüntülemek için her zaman <command>inspect</command> yöntemini kullanır.
  </para>
  <para><command>p</command> yöntemini, yazılımlarınızdan hata ayıklama çıktısı almak için kullanabilirsiniz.
  </para>
  <para>
   <screen># Bu iki satır eşdeğerdir:
p birNesne
print birNesne.inspect, "\n"
</screen>
  </para>
  <bridgehead renderas="sect2">Erişgeçleri kolay hale getirmek</bridgehead>
  <para>
Her örneğin bir erişim yöntemine ihtiyacı olmasına rağmen, Ruby standart tarzlar için daha elverişli bir yol sunar.
  </para>
  <para>
   <table pgwide="1">
    <tgroup cols="2" align="left" colsep="1" rowsep="1">
     <colspec colwidth=".4"/>
     <colspec colwidth=".6"/>
     <tbody>
      <row>
       <entry>
        <emphasis> Kısayol</emphasis>
       </entry>
       <entry>
        <emphasis> Etkisi</emphasis>
       </entry>
      </row>
      <row>
       <entry>
        <command> attr_reader :v </command>
       </entry>
       <entry>
        <command> def v; @v; end </command>
       </entry>
      </row>
      <row>
       <entry>
        <command> attr_writer :v </command>
       </entry>
       <entry>
        <command> def v=(value); @v=value; end </command>
       </entry>
      </row>
      <row>
       <entry>
        <command> attr_accessor :v </command>
       </entry>
       <entry>
        <command> attr_reader :v; attr_writer :v </command>
       </entry>
      </row>
      <row>
       <entry>
        <command> attr_accessor :v, :w </command>
       </entry>
       <entry>
        <command> attr_accessor :v; attr_accessor :w </command>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </para>
  <para>
Şimdi bunun avantajlarından faydalanalım ve bilgimizi tazeleyelim. Öncelikle otomatik olarak oluşturulmuş bir okuyucu ve yazıcı olup olmadığına bakarız ve yeni bilgiyi
<command>inspect</command>'in içine dahil ederiz:
  </para>
  <para>
   <screen><prompt>ruby&gt; </prompt><emphasis role="input"> class Meyve</emphasis>
    | <emphasis role="input">   attr_accessor :nitelik</emphasis>
    | <emphasis role="input">   def inspect</emphasis>
    | <emphasis role="input">     "#{@nitelik} bir #{@cesit}"</emphasis>
    | <emphasis role="input">   end</emphasis>
    | <emphasis role="input"> end</emphasis>
   <emphasis role="output">nil</emphasis>
<prompt>ruby&gt; </prompt> <emphasis role="input"> meyve.nitelik = "olgun"</emphasis>
   <emphasis role="output">"olgun"</emphasis>
<prompt>ruby&gt; </prompt> <emphasis role="input"> meyve</emphasis>
   <emphasis role="output">"olgun bir muz"</emphasis>
</screen>
  </para>
  <bridgehead renderas="sect3">Meyveyle biraz daha eğlence</bridgehead>
  <para>
Eğer kimse olgunlaşmış meyvemizi yemezse, parasını almak için beklemeliyiz.
  </para>
  <para>
   <screen><prompt>ruby&gt; </prompt><emphasis role="input"> class Meyve</emphasis>
    | <emphasis role="input">   def durumu</emphasis>
    | <emphasis role="input">     @nitelik = "çürük"</emphasis>
    | <emphasis role="input">   end</emphasis>
    | <emphasis role="input"> end</emphasis>
   <emphasis role="output">nil</emphasis>
<prompt>ruby&gt; </prompt> <emphasis role="input"> meyve</emphasis>
   <emphasis role="output">"olgun bir muz"</emphasis>
<prompt>ruby&gt; </prompt> <emphasis role="input"> meyve.durumu</emphasis>
   <emphasis role="output">"curuk"</emphasis>
<prompt>ruby&gt; </prompt> <emphasis role="input"> meyve</emphasis>
   <emphasis role="output">"çürük bir muz"</emphasis>
</screen>
  </para>
  <para>
Ancak buralarda oynarken, küçük bir sorunla karşılaştık. Üçüncü bir meyve yaratmaya çalıştığımızda ne olur? Örnek değişkenlerin onlara değer atanmadan var olmadıklarını hatırlayın.
  </para>
  <para>
   <screen>
    <prompt>ruby&gt; </prompt>
    <emphasis role="input"> f3 = Meyve.new</emphasis>
    <emphasis role="output">ERR: failed to convert nil into String</emphasis>
   </screen>
  </para>
  <para>
Burada yakınılan <command>inspect</command> yöntemidir ve geçerli bir sebebimiz var.
<command>f3</command>'e özellik atamadan bir meyvenin çeşidi ve niteliği hakkında bir rapor istedik. Eğer istersek,  <command>inspect</command> yönteminin <command>defined?</command> yöntemini de kullanarak sadece tanımlanmış meyveleri rapor etmesini sağlayabiliriz ancak bu iş hala kullanışsız olur, çünkü her meyvenin
bir çeşidi ve niteliği olduğuna göre bu ikisinin her zaman tanımlı olduğundan emin olmamız gerekir. Bu ileriki bölümün konusudur.
  </para>
 </chapter>
 <chapter xml:id="ruby-ug-oinit">
  <info>
   <title>Nesnenin İlklendirilmesi</title>
  </info>
  <para>
Geçen bölümdeki Meyve sınıfı, biri meyvenin çeşidini diğeri de niteliğini açıklayan iki örnek değişkene sahipti. Bunu yapmamızın nedeni bir kaç meyve için karakteristiğin önemli olmamasıydı. Genel bir <command>inspect</command> yöntemi oluşturmaktı.
Ruby örnek değişkenlerin her zaman hazırlanmış olduğunu garanti eden bir yol sunuyor.
  </para>
  <bridgehead renderas="sect3"><literal>initialize</literal> yöntemi</bridgehead>
  <para>
Ruby yeni bir nesne yaratıldığı zaman <command>initialize</command> denen bir yöntem arar ve çalıştırır. Yapabileceğimiz basit şeylerden biri her örnek değişkene öntanımlı bir <command>initialize</command> yöntemi koymak ve böylece <command>inspect</command> yöntemine söyleyebilecek bir şeyler sağlamaktır.
  </para>
  <para>
   <screen><prompt>ruby&gt; </prompt><emphasis role="input"> class Meyve</emphasis>
    | <emphasis role="input">   def initialize</emphasis>
    | <emphasis role="input">     @cesit = "elma"</emphasis>
    | <emphasis role="input">     @nitelik = "olgun"</emphasis>
    | <emphasis role="input">   end</emphasis>
    | <emphasis role="input"> end</emphasis>
   <emphasis role="output">nil</emphasis>
<prompt>ruby&gt; </prompt> <emphasis role="input"> f4 = Meyve.new</emphasis>
   <emphasis role="output">"olgun bir elma"</emphasis>
</screen>
  </para>
  <bridgehead renderas="sect3">Öntanımlı değerlerin değiştirilmesi</bridgehead>
  <para>
Bazen öntanımlı değerlerin pek de anlamlı olmadığı zamanlar olabilir. Öntanımlı bir meyve çeşidi gibi birşey olabilir mi? Her meyvenin yaratıldığı zaman kendi çeşidini belirlemesi daha tercih edilebilir bir durumdur. Bunu yapmak için <command>initialize</command> yöntemine bir argüman ekleriz. Burada bahsetmeyeceğimiz nedenlerden dolayı <command>new</command>'e verdiğiniz her argüman <command>initialize</command> yöntemi tarafından alınmış olur.
  </para>
  <para>
   <screen><prompt>ruby&gt; </prompt><emphasis role="input"> class Meyve</emphasis>
    | <emphasis role="input">   def initialize( k )</emphasis>
    | <emphasis role="input">     @cesit = k</emphasis>
    | <emphasis role="input">     @nitelik = "olgun"</emphasis>
    | <emphasis role="input">   end</emphasis>
    | <emphasis role="input"> end</emphasis>
   <emphasis role="output">nil</emphasis>
<prompt>ruby&gt; </prompt> <emphasis role="input"> f5 = Meyve.new "mango"</emphasis>
   <emphasis role="output">"olgun bir mango"</emphasis>
<prompt>ruby&gt; </prompt> <emphasis role="input"> f6 = Meyve.new</emphasis>
<emphasis role="output">ERR: (eval):1:in `initialize': wrong # of arguments(0 for 1)</emphasis>
</screen>
  </para>
  <bridgehead renderas="sect3">Esnek ilklendirme</bridgehead>
  <para>
Yukarıda gördüğümüz gibi bir argümanı <command>initialize</command> yöntemi ile ilişkilendirirseniz boş değer vermeniz durumunda hatayla karşılaşırsınız.
Daha düşünceli davranmak istersek, değer verildiği zaman o değeri kullanabilir, verilmediği zamansa öntanımlı bir değer atayabiliriz.
  </para>
  <para>
   <screen><prompt>ruby&gt; </prompt><emphasis role="input"> class Meyve</emphasis>
    | <emphasis role="input">   def initialize( k="elma" )</emphasis>
    | <emphasis role="input">     @cesit = k</emphasis>
    | <emphasis role="input">     @nitelik = "olgun"</emphasis>
    | <emphasis role="input">   end</emphasis>
    | <emphasis role="input"> end</emphasis>
   <emphasis role="output">nil</emphasis>
<prompt>ruby&gt; </prompt> <emphasis role="input"> f5 = Meyve.new "mango"</emphasis>
   <emphasis role="output">"olgun bir mango"</emphasis>
<prompt>ruby&gt; </prompt> <emphasis role="input"> f6 = Meyve.new</emphasis>
   <emphasis role="output">"olgun bir elma"</emphasis>
</screen>
  </para>
  <para>
Öntanımlı değerleri sadece <command>initialize</command> için değil tüm yöntemler için uygulayabilirsiniz.
  </para>
  <para>
Bazen bir nesneyi hazırlamak için birçok yol hazırlamak yararlı olabilir. Bu kılavuzun kapsamının dışında olmasına rağmen Ruby, yöntemleri aşırı yüklemeyi sağlayan nesne yansıtmaya (<emphasis>object reflection</emphasis>) ve değişken uzunluklu argüman listesine izin verir.
  </para>
 </chapter>
 <chapter xml:id="ruby-ug-misc">
  <info>
   <title>Ivır Zıvır</title>
  </info>
  <para>
Bu bölüm pratik bir kaç konuyu kapsar.
  </para>
  <bridgehead renderas="sect3">Deyim sınırlayıcılar</bridgehead>
  <para>
Bazı diller deyimleri sonlandırmak için, noktalı virgül <command>;</command> gibi  noktalama işaretleri gerektirir. Ruby bunun yerine <command>sh</command> ve <command>csh</command>'ın geleneğini takip eder. Birden fazla deyim noktalı virgülle ayrılmalıdır ancak bir satırın sonuna noktalı virgül koymanız gerekmez, satırsonu karakteri bir noktalı virgülmüş gibi davranır. Eğer bir satır tersbölü (<command>\</command>) ile biterse o zaman onu takip eden satırsonu karakteri dikkate alınmaz, bu da çok sayıda satıra bölünmüş tek bir satır oluşturmanızı sağlar.
  </para>
  <bridgehead renderas="sect3">Yorum Satırları</bridgehead>
  <para>
Niçin yorum yazmalıyız? İyi yazılmış bir kodun kendi kendini belgelemesi yanında başkalarının da çiziktirdiğimiz koda bakabileceği ihtimalini göz ardı etmemeliyiz. Öte yandan siz ve kendiziniz iki gün önceki sizle farklı kişilersiniz; hangimiz bir bölüm sonra durup, "bunu yazdığımı hatırlıyorum, ama ne cehennemi kastettim!" dememişizdir ki?
  </para>
  <para>
Bazı deneyimli yazılımcılar, güncelliğini yitirmiş ve tutarsız yorumların hiç yorum yazmamaktan daha kötü olduğuna dikkat çekerler. Tabii ki yorumlar okunabilir bir kodun vekili olmamalıdırlar; eğer kodunuz yeterince açık değilse muhtemelen yanlışlarla doludur. Ruby'yi öğrenirken yorum yazmaya sık sık ihtiyacınız olacak-ancak daha iyi duruma geldiğiniz zaman basit, şık ve okunabilir kodlar yazmaya başladığınızda  daha az yorum satırına ihtiyaç duyacaksınız.
  </para>
  <para>
Ruby yorum satırını belirtmek için <command>#</command> işareti kullanarak
betik dillerinin izlediği geleneksel yolu izler. <command>#</command> ile başlayan her satır yorumlayıcı tarafından gözardı edilir.
  </para>
  <para>
Ayrıca büyük yorum bloklarını mümkün kılmak için Ruby yorumlayıcısı "<command>=begin</command>" ve "<command>=end</command>" arasındaki satırları da gözardı eder.
  </para>
  <para>
   <screen>#!/usr/bin/env ruby

=begin
**********************************************************************
  Bu bir yorum öbeği. Daha sonra kodunuzu okuyanların (kendiniz de dahil)
  rahatlıla kodunuzu anlayabilmeleri için bir şeyler yazabilirsiniz.
  Yorumlayıcı bu öbeği görmezden gelir. Her satır başında '#' işaretine
  ihtiyacımız yok.
**********************************************************************
=end
</screen>
  </para>
  <bridgehead renderas="sect3">Kodunuzu düzenlemek</bridgehead>
  <para>
Ruby yorumlayıcısı kodları okuduğu gibi işletir. Derleme aşaması gibi bir şey söz konusu
değildir; eğer birşey henüz okunmamışsa basitçe <emphasis>tanımsızdır</emphasis>.
  </para>
  <para>
   <screen>
#sonuç bir tanımsız yöntem ("undefined method") hatası olacaktır:

print successor(3),"\n"

def successor(x)
  x + 1
end
</screen>
  </para>
  <para>
Bu, ilk bakışta öyle gibi gözükse de, kodunuzu baştan aşağı bir tasarım harikasına
dönüştürmeniz için zorlamaz. Yorumlayıcı, bir yöntem tanımlamasıyla karşılaştığında tanımlanmamış  başvuruları da rahatlıkla ekleyebilir ve yöntem çağrıldığında tanımlı olabileceğinden emin olabilirsiniz:
  </para>
  <para>
   <screen>
# fahrenhaytı santigrata çevirir,
# iki adımdan olusur.

def f_to_c(f)
  scale(f - 32.0)
end

def scale(x)
  x * 5.0 / 9.0
end

printf "%.1f iyi bir sıcaklık.\n", f_to_c(72.3)
</screen>
  </para>
  <para>
Perl ya da Java'da alıştığınızdan daha az elverişli olsa da prototip yazmadan C yazmaktan daha az kısıtlayıcıdır. Bir kaynak kodunun altındaki kodu en üste koymak her zaman çalışır. Üstelik başlangıçta göründüğünden daha az can sıkıcıdır. Tanımlamak istediğiniz davranışı yaptırmak için en ağrısız ve uygun yol dosyanın başında bir <command>main</command> işlevi tanımlamak ve en altta çağırmaktır.
  </para>
  <para>
   <screen>
#!/usr/bin/env ruby

def main
  # Ana mantığı burada açıklayın...
end

# ... destek kodunu buraya koyun ...

main # ... burada çalıştırmaya başlayın.
</screen>
  </para>
  <para>
Bu yöntem ayrıca Ruby'nin karmaşık yazılımları, okunabilir, tekrar kullanılabilir ve mantıksal ilişkilendirilmiş parçalara bölünmesini desteklemesine yardımcı olur.
Daha önce modüllere ulaşmak için <command>include</command> özelliğinin kullanımını görmüştük. Ayrıca <command>load</command> ve <command>require</command> özellikleri de yararlı olabilir. <command>load</command> başvurduğu dosya kopyalanıp yapıştırılmış gibi işlev görür (C'deki #include ön işlemcisine benzer). <command>require</command> biraz daha yetenekli bir özelliktir: kodun bir kere ve ihtiyaç duyulduğu zaman yüklenmesini sağlar.
<command>load</command> ve <command>require</command> arasındaki diğer farklılıklar için Ruby SSS'a bakın.
 </para>
  <bridgehead renderas="sect3">İşte bu kadar!</bridgehead>
  <para>
Bu kılavuz Ruby'de yazılım geliştirmeye başlamanıza yetecek kadar bilgi içerir. Eğer başka sorularınız olursa  <link xlink:href="http://www.ruby-lang.org/en/man-1.4/">Ruby Başvuru Kılavuzu</link>na göz atabilirsiniz. <link xlink:href="http://dev.rubycentral.com/faq/rubyfaq.html">Ruby SSS</link> ve
<link xlink:href="http://dev.rubycentral.com/ref/">Ruby Başvuru Kütüphanesi</link> de yararlı kaynaklardan bir kaç tanesidir.
  </para>
  <para>
Şansınız bol olsun, iyi kodlamalar!
   </para>
 </chapter>
 <chapter xml:id="ruby-ug-about">
  <info>
   <title>Kılavuz Hakkında</title>
  </info>
  <para>
Bu kılavuz çeşitli yerlerde yayınlanmış ve bir çok da çevirisi vardır. Güncel ingilizce sürüm <link xlink:href="http://www.rubyist.net/~slagell/ruby/">rubyist.net</link>'de bulunur. Eğer güncelliğini kaybetmiş bir sürümle karşılaşırsanız, yansının yöneticisini lütfen uyarın.
 </para>
  <bridgehead renderas="sect3">Belge Geçmişi</bridgehead>
  <para>
   <itemizedlist>
    <listitem>Özgün Japonca sürüm Yukihiro Matsumoto tarafından yazılmıştır.</listitem>
    <listitem><link xlink:href="http://www.math.sci.hokudai.ac.jp/~gotoken/ruby/ruby-uguide/">İlk İngilizce çeviri</link> GOTO Kentaro ve Julian Fondren tarafından yapıldı.</listitem>
    <listitem>Mark Slagell tarafından belge yeniden çevrildi ve bazı eklemeler yapıldı.</listitem>
   </itemizedlist>
  </para>
 </chapter>
</part>
