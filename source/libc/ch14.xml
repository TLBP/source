<?xml version="1.0" encoding="UTF-8"?>
<!-- ********************************************************************
        glibc/ch14.xml,v2.36, GFDL,LGPL, NBB, 2023
     ******************************************************************** -->
<part xml:id="glibc-File-System-Interface" userlevel="longtoc">
 <title>Dosya Sistemi Arayüzü</title>
 <titleabbrev>Dosyalarla çalışmak için işlevler.</titleabbrev>
 <preliminary>
  <para>
   Bu oylumda dosyalarla çalışmak için kullanılan &glibc; işlevleri açıklanmıştır. Girdi ve çıktı işlevlerinin tersine (bkz. <xref linkend="glibc-I-O-on-Streams"/>; <xref linkend="glibc-Low-Level-I-O"/>), bu işlevler dosyaların içerikleri ile değil dosyaların kendileriyle ilgili işlemleri yapar.
  </para>
  <para>
   Bu oylumda açıklanan oluşumlar arasında, dizinleri değiştiren veya inceleyen işlevler, dosyaları silen ya da ismini değiştiren işlevler ve erişim yetkileri ve değişiklik zamanları gibi dosya özniteliklerini incelemek ve değiştirmek için kullanılan işlevler sayılabilir.
  </para>
 </preliminary>
 <chapter xml:id="glibc-Working-Directory">
  <title>Çalışma dizini</title>
  <titleabbrev>Göreli dosya isimlerini çözümlemede kullanılır.</titleabbrev>
  <para>
   <indexterm linkend="glibc-cp"><primary>dosyalar</primary><secondary>çalışma dizini</secondary></indexterm>
   <indexterm linkend="glibc-cp"><primary>dizinler</primary><secondary>çalışma dizini</secondary></indexterm>
   Her sürecin kendisiyle ilişkili bir dizini vardır. Bu dizine <wordasword>çalışma dizini</wordasword> denir ve göreli dosya isimlerinin çözümlenmesinde kullanılır (bkz. <xref linkend="glibc-File-Name-Resolution"/>).
  </para>
  <para>
   Kullanıcı sisteme oturum açtığında, sistem veritabanındaki kullanıcı hesabıyla ilişkili ev dizini çalışma dizini yapılır. Kullanıcının ev dizini <function>getpwuid</function> veya <function>getpwnam</function> işleviyle bulunabilir; bkz. <xref linkend="glibc-User-Database"/>.
  </para>
  <para>
   <indexterm linkend="glibc-pg"><primary>cd</primary></indexterm>
   <indexterm linkend="glibc-pg"><primary>unistd.h</primary></indexterm>
   Kullanıcılar çalışma dizinlerini <code>cd</code> gibi kabuk komutlarını kullanarak değiştirebilir. Bu bölümde açıklanan işlevler bu komutlarda ve çalışma dizinini değiştirmek ve incelemek için başka yazılımlarda kullanılan ilkellerdir. Bu işlevlerin prototipleri &unistd.h; başlık dosyasında bildirilmiştir.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-getcwd"><primary>çalışma dizini</primary></indexterm>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-getcwd"><primary>getcwd</primary></indexterm>
   <csproto type="işlev">
    <csname><ptr>char</ptr><function>getcwd</function></csname>
    <csparam><ptr>char</ptr><parameter>buffer</parameter></csparam>
    <csparam><type>size_t</type><parameter>size</parameter></csparam>
   </csproto>
   <header>&unistd.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&asunsafe; &heap;</concept>
    <concept>&acunsafe; &mem; &fd;</concept>
   </conceptlist>
   <para>
    <code>getcwd</code> işlevi yazılımcı tarafınızdan sağlanan <parameter>buffer</parameter> karakter dizisine geçerli çalışma dizinini ifade eden mutlak dosya ismini kaydederek döner. <parameter>size</parameter> bağımsız değişkeni ile sisteme <parameter>buffer</parameter> için ayrılan boyut bildirilir.
   </para>
   <para>
    Bu işlevin &glibc;ndeki sürümü <parameter>buffer</parameter> bağımsız değişkeni olarak boş gösterici belirtebilmeyi mümkün kılar. Bu durumda <code>getcwd</code> işlevi <function>malloc</function> ile tamponu kendisi ayırır (bkz. <xref linkend="glibc-Unconstrained-Allocation"/>).  Eğer <parameter>size</parameter> sıfırdan büyükse, tampon belirtilen boyutta olur, aksi takdirde tampon sonucu tutmaya yetecek büyüklükte olur.
   </para>
   <para>
    İşlev başarılı olursa <parameter>buffer</parameter> tamponunu döndürür. Başarısızlık halinde boş gösterici döner. Aşağıdaki <varname>errno</varname> hata durumları bu işlev için tanımlanmıştır:
   </para>
   <variablelist>
    <varlistentry>
     <term><code>EINVAL</code></term>
     <listitem>
      <para>
       <parameter>size</parameter> bağımsız değişkeni sıfır ve <parameter>buffer</parameter> boş gösterici değil.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>ERANGE</code></term>
     <listitem>
      <para>
       <parameter>size</parameter> bağımsız değişkeni ile belirtilen uzunluk çalışma dizini isminden daha kısa. Daha büyük dizi tahsis edilerek yeniden denenmelidir.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>EACCES</code></term>
     <listitem>
      <para>
       Dosya isminin bir elemanını aramak ya da okumak için izin verilmedi.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <example>
    <para>
     GNU'nun <code>getcwd&nbsp;(NULL,&nbsp;0)</code> davranışını sadece <code>getcwd</code> işlevinin standart davranışı kullanılarak gerçeklenebilir:
    </para>
    <screen>char *
gnu_getcwd ()
{
  size_t size = 100;

  while (1)
    {
      char *buffer = (char *) xmalloc (size);
      if (getcwd (buffer, size) == buffer)
        return buffer;
      free (buffer);
      if (errno != ERANGE)
        return 0;
      size *= 2;
    }
}
</screen>
   </example>
   <para>
    Bir kütüphane işlevi olmayan ama çoğu GNU yazılımında kullanılan, özelleştirilmiş bir isim olan <function>xmalloc</function> hakkında daha fazla bilgi için bkz. <xref linkend="glibc-Malloc-Examples"/>.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-getwd"><primary>getwd</primary></indexterm>
   <csproto type="işlev">
    <csname><ptr>char</ptr><function>getwd</function></csname>
    <csparam><ptr>char</ptr><parameter>buffer</parameter></csparam>
   </csproto>
   <header>&unistd.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&asunsafe; &heap; &i18n;</concept>
    <concept>&acunsafe; &mem; &fd;</concept>
   </conceptlist>
   <para>
    Tampon için boyut belirtilmemesi dışında <function>getcwd</function> işlevinin benzeridir. <code>getwd</code> işlevi sadece BSD uyumluluğu için &glibc;ne dahil edilmiştir.
   </para>
   <para>
    <parameter>buffer</parameter> bağımsız değişkeni en azından  <varname>PATH_MAX</varname> bayt uzunluktaki bir tampona gösterici olmalıdır (bkz. <xref linkend="glibc-Limits-for-Files"/>).  GNU sisteminde dosya ismi için bir sınırlama yoktur, yani dizin ismini içerecek yeterli alan için bu gereksizdir ve bu işlevin kullanılmasının önerilmeme sebebi budur.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-vr" xml:id="glibc-fn-PWD"><primary>PWD</primary></indexterm>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-get_current_dir_name"><primary>get_current_dir_name</primary></indexterm>
   <csproto type="işlev">
    <csname><ptr>char</ptr><function>get_current_dir_name</function></csname>
    <csparam><void/></csparam>
   </csproto>
   <header>&unistd.h;</header>
   <conceptlist>
    <concept>&mtsafe; &env;</concept>
    <concept>&asunsafe; &heap;</concept>
    <concept>&acunsafe; &mem; &fd;</concept>
   </conceptlist>
   <para>
    <code>get_current_dir_name</code> işlevi temel olarak <code>getcwd&nbsp;(NULL,&nbsp;0)</code> çağrısının eşdeğeridir, ancak ilk önce <code>PWD</code> ortam değişkeninin değeri incelenir ve gerçekten geçerli dizine karşılık geliyorsa bu değer döndürülür. Bu, <code>PWD</code>'deki değer bir veya daha fazla simgesel bağ içerdiğinde görülebilen ince bir farktır; bu durumda <function>getcwd</function> tarafından döndürülen değer simgesel bağları çözümler ve bu nedenle farklı bir sonuç döner.
   </para>
   <para>
    Bu işlev GNU oluşumudur.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-chdir"><primary>chdir</primary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>chdir</function></csname>
    <csparam><ptr>const&nbsp;char</ptr><parameter>filename</parameter></csparam>
   </csproto>
   <header>&unistd.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    Bu işlev sürecin çalışma dizinini <parameter>filename</parameter> yapar.
   </para>
   <para>
    İşlevin normal dönüş değeri <code>0</code>'dır. <code>-1</code> değeri dönmüşse bir hata oluşmuş demektir. Bu işlev için tanımlanmış <varname>errno</varname> hata değerleri <link linkend="glibc-File-Name-Errors">dosya ismi sözdizimi hatalarına</link> ek olarak, <parameter>filename</parameter> ismi bir dizin değilse <varname>ENOTDIR</varname>'dır.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-fchdir"><primary>fchdir</primary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>fchdir</function></csname>
    <csparam><type>int</type><parameter>filedes</parameter></csparam>
   </csproto>
   <header>&unistd.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    Bu işlev sürecin çalışma dizinini <parameter>filedes</parameter> tanıtıcısı ile ilişkili dizin yapar.
   </para>
   <para>
    İşlevin normal dönüş değeri <code>0</code>'dır. <code>-1</code> değeri dönmüşse bir hata oluşmuş demektir. Bu işlev için tanımlanmış <varname>errno</varname> hata durumları:
   </para>
   <variablelist>
    <varlistentry>
     <term><code>EACCES</code></term>
     <listitem>
      <para>
       <parameter>dizinadı</parameter> dizini için okuma izni reddedildi.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>EBADF</code></term>
     <listitem>
      <para>
       <parameter>filedes</parameter> geçerli bir dosya tanıtıcısı değil.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>ENOTDIR</code></term>
     <listitem>
      <para>
       <parameter>filedes</parameter> dosya tanıtıcısı bir dizin ile ilişkili değil.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>EINTR</code></term>
     <listitem>
      <para>
       İşlev çağrısı bir sinyal ile engellendi.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>EIO</code></term>
     <listitem>
      <para>
       Bir G/Ç hatası oluştu.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </csynopsis>
 </chapter>

 <chapter xml:id="glibc-Accessing-Directories">
  <title>Dizinlere Erişim</title>
  <titleabbrev>Bir dizindeki dosyaların bulunması.</titleabbrev>
  <preliminary>
   <para>
    <indexterm linkend="glibc-cp"><primary>dosyalar</primary><secondary>dizinlere erişim</secondary></indexterm>
    <indexterm linkend="glibc-cp"><primary>dosyalar</primary><secondary>bir dizinden okunması</secondary></indexterm>
    <indexterm linkend="glibc-cp"><primary>dizinler</primary><secondary>erişim</secondary></indexterm>
    Bu kısımda açıklanan oluşumlar bir dizin dosyasının içeriğinin okunmasını sağlar. Yazılımın bir dizindeki tüm dosyaları listelemesi istenirse bu yararlı olur.
   </para>
   <para>
    <indexterm linkend="glibc-cp"><primary>dizin akımı</primary></indexterm>
    <function>opendir</function> işlevi, elemanları dizin girdileri olan bir <wordasword>dizin akımı</wordasword> açar. Yazılımın okumak için açılmış dizin üzerinde daha fazla denetim sağlayabilmesi gibi getirileri için bunun yerine <function>fdopendir</function> işlevi de kullanılabilir. Bu, örneğin, <function>open</function> işlevine <varname>O_NOATIME</varname> seçeneğinin aktarılmasını mümkün kılar.
   </para>
   <para>
    Bu girdileri <type>struct&nbsp;dirent</type> nesneleri olarak almak için dizin akımı üzerinde <function>readdir</function> işlevini kullanabilirsiniz. Her girdinin dosya ismi bu yapının <code>d_name</code> üyesinde saklanır. Burada, sıradan dosyaların <link linkend="glibc-I-O-on-Streams">akım oluşumları</link> ile belirgin benzerlikler vardır.
   </para>
  </preliminary>
  <sect1 xml:id="glibc-Directory-Entries">
   <title>Dizin Girdileri</title>
   <titleabbrev>Bir dizin girdisinin biçimi</titleabbrev>
   <para>
    <indexterm linkend="glibc-pg"><primary>dirent.h</primary></indexterm>
    Bu bölümde bir dizin akımından sağlanan tek bir dizin girdisinde bulunanlar açıklanacaktır. Bu bölümdeki tüm simgeler &dirent.h; başlık dosyasında bildirilmiştir.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-tp" xml:id="glibc-tp-dirent"><primary sortas="dirent">struct&#160;dirent</primary></indexterm>
    <csproto type="veri türü">
     <csname><type>struct</type><function>dirent</function></csname>
    </csproto>
    <header>&dirent.h;</header>
    <para>
     Dizin girdileri hakkında bilgi döndürmekte kullanılan yapıdır. Şu alanları içerir:
    </para>
    <glosslist>
     <glossentry>
      <glossterm>
       <type>char&nbsp;</type><structfield>d_name[]</structfield>
      </glossterm>
      <glossdef>
       <para>
        Boş karakter sonlandırmalı dosya ismi elemanıdır. Bu yapının üyesi olarak tüm POSIX sistemlerinde bulunabilecek tek üyedir.
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm>
       <type>ino_t&nbsp;</type><structfield>d_fileno</structfield>
      </glossterm>
      <glossdef>
       <para>
        Dosyanın seri numarasıdır. BSD uyumluluğu için bu üyeye
        <structfield>d_ino</structfield> ismiyle de erişilebilir. GNU/Linux ve GNU/Hurd sistemlerinde ve çoğu POSIX sisteminde, bu üye, çoğu dosya için <function>stat</function> çağrısından dönen <type>struct&nbsp;stat</type> yapısının <structfield>st_ino</structfield> üyesi ile aynıdır. Bkz. <xref linkend="glibc-Attribute-Meanings"/>.
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm>
       <type>unsigned&nbsp;char&nbsp;</type><structfield>d_namlen</structfield>
      </glossterm>
      <glossdef>
       <para>
        <indexterm linkend="glibc-vr" xml:id="glibc-vr-DIRENT_HAVE_D_NAMLEN"><primary sortas="DIRENT_HAVE_D_NAMLEN">_DIRENT_HAVE_D_NAMLEN</primary></indexterm>
        Dosya isminin sonlandırıcı boş karakter içermeyen <type>unsigned&nbsp;char</type> türünden uzunluğudur. Bu üye varsa, <code>_DIRENT_HAVE_D_NAMLEN</code> simgesi tanımlıdır.
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm>
       <type>unsigned&nbsp;char&nbsp;</type><structfield>d_type</structfield>
      </glossterm>
      <glossdef>
       <para>
        Dosyanın türüdür. Değeri için tanımlanmış sabitler:
       </para>
       <csynopsis>
        <indexterm linkend="glibc-vr" xml:id="glibc-vr-DT_UNKNOWN"><primary>DT_UNKNOWN</primary></indexterm>
        <csproto type="sabit">
         <csname><function>DT_UNKNOWN</function></csname>
        </csproto>
        <para>
         Dosya türü bilinmiyor. Yalnızca bazı dosya sistemleri, dosya türünü döndürmek için tam desteğe sahiptir, diğerleri her zaman bu değeri döndürebilir.
        </para>
       </csynopsis>
       <csynopsis>
        <indexterm linkend="glibc-vr" xml:id="glibc-vr-DT_REG"><primary>DT_REG</primary></indexterm>
        <csproto type="sabit">
         <csname><function>DT_REG</function></csname>
        </csproto>
        <para>
         Normal dosya.
        </para>
       </csynopsis>
       <csynopsis>
        <indexterm linkend="glibc-vr" xml:id="glibc-vr-DT_DIR"><primary>DT_DIR</primary></indexterm>
        <csproto type="sabit">
         <csname><function>DT_DIR</function></csname>
        </csproto>
        <para>
         Dizin.
        </para>
       </csynopsis>
       <csynopsis>
        <indexterm linkend="glibc-vr" xml:id="glibc-vr-DT_FIFO"><primary>DT_FIFO</primary></indexterm>
        <csproto type="sabit">
         <csname><function>DT_FIFO</function></csname>
        </csproto>
        <para>
         İsimli ardışık süreç. Bkz. <xref linkend="glibc-FIFO-Special-Files"/>.
        </para>
       </csynopsis>
       <csynopsis>
        <indexterm linkend="glibc-vr" xml:id="glibc-vr-DT_SOCK"><primary>DT_SOCK</primary></indexterm>
        <csproto type="sabit">
         <csname><function>DT_SOCK</function></csname>
        </csproto>
        <para>
         Yerel alan soketi.
        </para>
       </csynopsis>
       <csynopsis>
        <indexterm linkend="glibc-vr" xml:id="glibc-vr-DT_CHR"><primary>DT_CHR</primary></indexterm>
        <csproto type="sabit">
         <csname><function>DT_CHR</function></csname>
        </csproto>
        <para>
         Karakter aygıtı.
        </para>
       </csynopsis>
       <csynopsis>
        <indexterm linkend="glibc-vr" xml:id="glibc-vr-DT_BLK"><primary>DT_BLK</primary></indexterm>
        <csproto type="sabit">
         <csname><function>DT_BLK</function></csname>
        </csproto>
        <para>
         Blok aygıtı.
        </para>
       </csynopsis>
       <csynopsis>
        <indexterm linkend="glibc-vr" xml:id="glibc-vr-DT_LNK"><primary>DT_LNK</primary></indexterm>
        <csproto type="sabit">
         <csname><function>DT_LNK</function></csname>
        </csproto>
        <para>
         Simgesel bağ.
        </para>
       </csynopsis>
       <para/>
       <para>
        <indexterm linkend="glibc-vr" xml:id="glibc-vr-DIRENT_HAVE_D_TYPE"><primary sortas="DIRENT_HAVE_D_TYPE">_DIRENT_HAVE_D_TYPE</primary></indexterm>
        Bu üye bir GNU oluşumudur. Eğer bu üye varsa,   <code>_DIRENT_HAVE_D_TYPE</code> tanımlıdır. Kullanıldığı sistemlerde <type>struct&nbsp;stat</type> yapısının <code>st_mode</code> üyesindeki dosya türü bitlerine karşı düşer. Eğer değer saptanamazsa üyenin değeri <varname>DT_UNKNOWN</varname> olur. Şu iki makro <code>d_type</code> ile <code>st_mode</code> değerleri arasında dönüşüm yapar:
       </para>
       <csynopsis>
        <indexterm linkend="glibc-fn" xml:id="glibc-fn-IFTODT"><primary>IFTODT</primary></indexterm>
        <csproto type="işlev">
         <csname><type>int</type><function>IFTODT</function></csname>
         <csparam><type>mode_t</type><parameter>mode</parameter></csparam>
        </csproto>
        <header>&dirent.h;</header>
        <conceptlist>
         <concept>&mtsafe;</concept>
         <concept>&assafe;</concept>
         <concept>&acsafe;</concept>
        </conceptlist>
        <para>
         Belirtilen <code>st_mode</code> değerine karşı düşen <code>d_type</code> değeri ile döner.
        </para>
       </csynopsis>
       <csynopsis>
        <indexterm linkend="glibc-fn" xml:id="glibc-fn-DTTOIF"><primary>DTTOIF</primary></indexterm>
        <csproto type="işlev">
         <csname><type>mode_t</type><function>DTTOIF</function></csname>
         <csparam><type>int</type><parameter>dtype</parameter></csparam>
        </csproto>
        <header>&dirent.h;</header>
        <conceptlist>
         <concept>&mtsafe;</concept>
         <concept>&assafe;</concept>
         <concept>&acsafe;</concept>
        </conceptlist>
        <para>
         Belirtilen <code>dtype</code> değerine karşı düşen <code>st_mode</code> değeri ile döner.
        </para>
       </csynopsis>
      </glossdef>
     </glossentry>
    </glosslist>
    <para>
     Bu yapı ileride ek üyeler içerebilir. Yeni üyeler olduğunda derleme ortamında daima<code>_DIRENT_HAVE_D_<replaceable>xxx</replaceable></code> biçiminde bir makro ismiyle görünecektir. Burada <replaceable>xxx</replaceable> yeni üyenin ismidir. Örneğin, bazı sistemlerde <code>d_reclen</code> diye bir üye vardır ve bu sistemlerde <code>_DIRENT_HAVE_D_RECLEN</code> makrosu tanımlıdır.
    </para>
    <para>
     Bir dosyanın çok sayıda ismi varsa, her ismin kendi dizin girdisi olur.  Böyle dosya isimlerinin tek bir dosyaya ait olup olmadığı <code>d_fileno</code> alanındaki değere bakarak anlaşılır. Bu üyenin değeri bu tür girdilerde aynıdır.
    </para>
    <para>
     Boyut, değişiklik zamanı gibi dosya öznitelikleri dosyanın kendisinde bulunur, dizin girdisinin elemenları değildir. Bkz. <xref linkend="glibc-File-Attributes"/>.
    </para>
   </csynopsis>
  </sect1>
  <sect1 xml:id="glibc-Opening-a-Directory">
   <title>Dizin Akımlarının Açılması</title>
   <titleabbrev>Bir dizin akımı nasıl açılır?</titleabbrev>
   <para>
    <indexterm linkend="glibc-pg"><primary>dirent.h</primary></indexterm>
    Bu bölümde bir dizin akımının nasıl açılacağından bahsedilecektir. Bu bölümdeki tüm simgeler &dirent.h; başlık dosyasında bildirilmiştir.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-tp" xml:id="glibc-tp-DIR"><primary>DIR</primary></indexterm>
    <csproto type="veri türü">
     <csname><function>DIR</function></csname>
    </csproto>
    <header>&dirent.h;</header>
    <para>
     Dizin akımını ifade eden veri türüdür.
    </para>
   </csynopsis>
   <para>
    <type>struct&nbsp;dirent</type> veya <code>DIR</code> türünde nesneler, dizin erişim işlevleri tarafından tahsis edildiğinden, yazılımcı tarafından ayrıca tahsis edilmemesi gerekir. Bu nesnelere gösterici döndüren işlevler kullanılarak bu nesnelere erişmek mümkündür.
   </para>
   <para>
    Dizin akımları, üst düzey arayüzdür. Linux'ta, dosya tanıtıcıları kullanılarak dizinlere erişmek için başka arayüzler de mevcuttur.
    Bkz. <xref linkend="glibc-Low-level-Directory-Access"/>.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-opendir"><primary>opendir</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-opendir"><primary>dizinler</primary><secondary>açılması</secondary></indexterm>
    <csproto type="işlev">
     <csname><ptr>DIR</ptr><function>opendir</function></csname>
     <csparam><ptr>const&#160;char</ptr><parameter>dirname</parameter></csparam>
    </csproto>
    <header>&dirent.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&asunsafe; &heap;</concept>
     <concept>&acunsafe; &mem; &fd;</concept>
    </conceptlist>
    <para>
     <code>opendir</code> işlevi ismi <parameter>dirname</parameter> olan dizini okumak için bir dizin akımı döndürür. Akım <code>DIR *</code> türündedir.
    </para>
    <para>
     İşlev başarısız olursa boş gösterici döndürür. <link linkend="glibc-File-Name-Errors">Dosya ismi hatalarına</link> ek olarak aşağıdaki <varname>errno</varname> hata durumları bu işlev için tanımlanmıştır:
    </para>
    <variablelist>
     <varlistentry>
      <term><code>EACCES</code></term>
      <listitem>
       <para>
        <parameter>dirname</parameter> dizini için okuma izni reddedildi.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>EMFILE</code></term>
      <listitem>
       <para>
        Süreç çok fazla dosya açmış.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>ENFILE</code></term>
      <listitem>
       <para>
        Dizini içeren sistem ya da dosya sistemi şu anda daha fazla dosya açılmasını desteklemiyor. (GNU/Hurd sistemlerinde böyle bir sorun asla olmaz.)
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>ENOMEM</code></term>
      <listitem>
       <para>
        Yeterli bellek yok.
      </para>
      </listitem>
     </varlistentry>
    </variablelist>
    <para>
     <type>DIR</type> türü genellikle bir dosya tanıtıcı kullanılarak gerçeklenir ve <function>opendir</function> işlevi de <function>open</function> ilkelini kullanır. Bkz. <xref linkend="glibc-Low-Level-I-O"/>.  Dizin akımları ve daha alt seviyede dosya tanıtıcıları bir <function>exec</function> (<xref linkend="glibc-Executing-a-File"/>) çağrısı yapıldığında kapatılır.
    </para>
   </csynopsis>
   <para>
    <function>opendir</function> tarafından okumak için açılan dizin ismiyle ifade edilir. Bazı durumlarda bu yeterli olmaz. Ya da <function>opendir</function> yoluyla dizin için örtük olarak oluşturulan dosya tanıtıcı yazılımda istenen yol değildir. Bu gibi durumlarda başka bir arayüz kullanılabilir.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-fdopendir"><primary>fdopendir</primary></indexterm>
    <csproto type="işlev">
     <csname><ptr>DIR</ptr><function>fdopendir</function></csname>
     <csparam><type>int</type><parameter>fd</parameter></csparam>
    </csproto>
    <header>&dirent.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&asunsafe; &heap;</concept>
     <concept>&acunsafe; &mem; &fd;</concept>
    </conceptlist>
    <para>
     <code>fdopendir</code> işlevi bir dosya ismi almak ve dizin için bir dosya tanıtıcı açmak yerine dosya tanıtıcının çağrı sırasında belirtilmesini gerektirmesi dışında <function>opendir</function> gibi çalışır. Dönen dizin akımı nesnesinin daha sonraki kullanımlarında bu dosya tanıtıcı kullanılır.
    </para>
    <para>
     İşlev çağrılırken kullanılan dosya tanıtıcının bir dizin ile ilişkili olduğundan ve okumaya izin verdiğinden emin olunmalıdır.
    </para>
    <para>
     <code>fdopendir</code> çağrısı başarılı olursa dosya tanıtıcı sistemin denetimi altına girer. <function>opendir</function> tarafından örtük olarak oluşturulan tanıtıcının kullanıldığı gibi kullanılabilir fakat yazılım tanıtıcıyı kapatmamalıdır.
    </para>
    <para>
     İşlev başarısız olduğu durumlarda boş gösterici döndürür ve dosya tanıtıcı yazılım tarafından kullanılabilir olarak kalır. Aşağıdaki <varname>errno</varname> hata durumları bu işlev için tanımlanmıştır:
    </para>
    <variablelist>
     <varlistentry>
      <term><code>EBADF</code></term>
      <listitem>
       <para>
        Dosya tanıtıcı geçersiz.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>ENOTDIR</code></term>
      <listitem>
       <para>
        Dosya tanıtıcı dizinle ilişkili değil.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>EINVAL</code></term>
      <listitem>
       <para>
        Dosya tanıtıcı dizin içeriğinin okunmasına izin vermiyor.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>ENOMEM</code></term>
      <listitem>
       <para>
        Yeterli bellek yok.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </csynopsis>
   <para>
    Bazı durumlarda <function>opendir</function> çağrısı ile oluşturulan dosya tanıtıcıya erişmek istenebilir. Örneğin, çalışma dizinini bir dosya tanıtıcı kullanarak değiştiren <function>fchdir</function> işlevi için bu gerekli olabilirdi. Tarihsel olarak <type>DIR</type> türü ile fazla uğraşıldığından yazılımlar alanlarına erişemez. Ancak &glibc;nde bu böyle değildir. Erişimi sağlamak için ayrı bir işlev vardır.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-dirfd"><primary>dirfd</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>dirfd</function></csname>
     <csparam><ptr>DIR</ptr><parameter>dirstream</parameter></csparam>
    </csproto>
    <header>&dirent.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     <code>dirfd</code> işlevi <parameter>dirstream</parameter> izin akımı ile ilişkili dosya tanıtıcıyı döndürür. Dizin akımı <function>closedir</function> ile kapatılıncaya kadar bu tanıtıcı geçerli kalır. Eğer dizin akımı gerçeklenimi dosya tanıtıcıları kullanmıyorsa işlev <code>-1</code> ile döner.
    </para>
   </csynopsis>
  </sect1>
  <sect1 xml:id="glibc-Reading-Closing-Directory">
   <title>Dizin Akımlarının Okunması ve Kapatılması</title>
   <titleabbrev>Akımdaki dizin girdileri nasıl okunur?</titleabbrev>
   <para>
    <indexterm linkend="glibc-pg"><primary>dirent.h</primary></indexterm>
    Bu bölümde bir dizin akımından girdilerin nasıl okunacağı ve akımla işlemler bittiğinde nasıl kapatılacağı anlatılacaktır. Bu bölümdeki tüm simgeler &dirent.h; başlık dosyasında bildirilmiştir.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-readdir"><primary>readdir</primary></indexterm>
    <csproto type="işlev">
     <csname><ptr>struct&nbsp;dirent</ptr><function>readdir</function></csname>
     <csparam><ptr>DIR</ptr><parameter>dirstream</parameter></csparam>
    </csproto>
    <header>&dirent.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&asunsafe; &lock;</concept>
     <concept>&acunsafe; &lock;</concept>
    </conceptlist>
    <para>
     Bu işlev dizindeki sonraki girdiyi okur. Normalde dosya hakkında bilgi içeren yapıya gösterici ile döner. Bu yapı duruk olarak ayrıldığından işlevin sonraki çağrıları üzerine yazabilir.
    </para>
    <note><title>Taşınabilirlik Bilgisi</title>
     <para>
      Bazı sistemlerde <code>readdir</code> işlevi '<filename>.</filename>' ve '<filename>..</filename>' için, bunlar her dizinde daima geçerli dosya isimleri oldukları halde, girdi döndürmez. Bkz. <xref linkend="glibc-File-Name-Resolution"/>.
     </para>
    </note>
    <para>
     Eğer dizinde başka girdi kalmamışsa ya da bir hata saptanmışsa işlev boş gösterici ile döner. Aşağıdaki <varname>errno</varname> hata durumu bu işlev için tanımlanmıştır:
    </para>
    <formalpara><title><code>EBADF</code></title>
     <para>
      <parameter>dirstream</parameter> bağımsız değişkeni geçersiz.
     </para>
    </formalpara>
    <para>
     Dizin sonu durumunu ile bir hatayı ayırt etmek için, <code>readdir</code> çağrılmadan önce <varname>errno</varname> değişkenine <code>0</code> atanmalıdır. Sonsuz döngüye girmemek için ilk hatadan sonra dizinin okunması bırakılmalıdır.
    </para>
    <caution>
     <para>
      <code>readdir</code> tarafından döndürülen gösterici, <type>DIR</type> nesnesi içindeki bir tampona göstericidir. Bu tampondaki verilerin üzerine bir sonraki <code>readdir</code> çağrısı tarafından yazılacaktır. Örneğin,  <type>struct&nbsp;dirent</type> yapısının <code>d_name</code> alanının daha sonra kullanmak üzere saklanması gerekebilir.
     </para>
     <para>
      Bu nedenle, <type>DIR</type> nesnesini birden çok evre arasında paylaşmak, başka bir evre önceki aramadan gelen verileri kullanırken hiçbir evrenin <code>readdir</code> çağrısı yapmamasını sağlamak için kilitler kullanılmadıkça, güvenli değildir. &glibc;nde, her evre kendi <type>DIR</type> nesnesini kullandığı sürece birden çok evreden <code>readdir</code> çağrısı yapmak güvenlidir. POSIX.1-2008, bunun güvenli olmasını gerektirmez, ancak çalışmadığı herhangi bir işletim sistemi bilinmemektedir.
     </para>
     <para>
      <code>readdir_r</code> işlevi, yazılımcının <type>struct&nbsp;dirent</type> için tampon tahsis etmesine izin verir, ancak <code>readdir</code> işlevinden daha az taşınabilirdir ve çok uzun dosya adlarıyla ilgili sorunları vardır (aşağıya bakın). Bu nedenle, <code>readdir</code> kullanılması, ancak <type>DIR</type> nesnelerinin paylaşılmaması önerilir.
     </para>
    </caution>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-readdir_r"><primary>readdir_r</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>readdir_r</function></csname>
     <csparam><ptr>DIR</ptr><parameter>dirstream</parameter></csparam>
     <csparam><ptr>struct&nbsp;dirent</ptr><parameter>entry</parameter></csparam>
     <csparam><pptr>struct&nbsp;dirent</pptr><parameter>result</parameter></csparam>
    </csproto>
    <header>&dirent.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&asunsafe; &lock;</concept>
     <concept>&acunsafe; &lock;</concept>
    </conceptlist>
    <para>
     Bu işlev, <function>readdir</function> işlevinin dahili kilitleme gerçekleştiren sürümüdür. <function>readdir</function> gibi, dizinden bir sonraki girdiyi döndürür. Aynı anda çalışan evreler arasındaki çakışmaları önlemek için sonuç <parameter>entry</parameter> nesnesinin içinde saklanır.
    </para>
    <note><title>Taşınabilirlik Bilgisi:</title>
     <para>
      Aşağıdaki nedenlerden dolayı <code>readdir_r</code> yerine <function>readdir</function> kullanılması önerilir:
     </para>
     <itemizedlist>
      <listitem>
       <para>
        <varname>NAME_MAX</varname> sabitinin tanımlanmadığı sistemlerde, yazılımcı dizin girdisi için tampon uzunluğunu belirtemediğinden, <code>readdir_r</code> kullanımı güvenilir olmayabilir.
       </para>
      </listitem>
      <listitem>
       <para>
        Bazı sistemlerde <code>readdir_r</code>, çok uzun adlara sahip dizin girdilerini okuyamaz. Böyle bir adla karşılaşılırsa, son dizin girdisi okunduktan sonra <code>readdir_r</code> işlevinin &glibc; gerçeklenimi <varname>ENAMETOOLONG</varname> hata koduyla döner. Diğer sistemlerde <code>readdir_r</code> başarılı bir şekilde geri dönebilir, ancak <code>d_name</code> üyesi boş karakter ile sonlandırılamaz veya kırpılabilir.
       </para>
      </listitem>
      <listitem>
       <para>
        POSIX-1.2008 aynı <parameter>dirstream</parameter>'e erişim dizileştirildiğinde bile <function>readdir</function> işlevinin evresel olarak güvenilir olduğunu garanti etmez. Ancak mevcut gerçeklenimlerde (&glibc; dahil), farklı dizin akımlarında aynı anda <function>readdir</function> çağrısı güvenlidir, bu nedenle çoğu çok evreli yazılımda <code>readdir_r</code> kullanmaya gerek yoktur. Birden çok evrenin aynı dizin akımını okumasını gerektiren nadir durumlarda, yine de <function>readdir</function> ve harici eşzamanlama kullanmak daha iyidir.
       </para>
      </listitem>
      <listitem>
       <para>
        POSIX'in gelecekteki sürümlerinin <code>readdir_r</code> işlevini geçersiz kılması ve bugün &glibc; ve diğer gerçeklenimler tarafından sağlanan <function>readdir</function> için evresel güvenilirliği zorunlu kılması beklenmektedir.
       </para>
      </listitem>
     </itemizedlist>
    </note>
    <para>
     Normalde <code>readdir_r</code> sıfır döndürür ve <parameter>entry</parameter> bağımsız değişkenini *<parameter>result</parameter> göstericisine atar. Dizinde başka girdi yoksa veya bir hata algılanırsa, <code>readdir_r</code> *<parameter>result</parameter>'a boş gösterici atar ve yine <function>readdir</function> için açıklandığı gibi <varname>errno</varname> değişkeninde sıfır olmayan bir hata kodu döndürür.
    </para>
    <para>
     <type>struct&nbsp;dirent</type> yapısının tanımına bakmak da önemlidir. <code>readdir_r</code>'nin ikinci bağımsız değişkeni için bu türdeki bir nesneye basitçe bir gösterici aktarmak yeterli olmayabilir. Bazı sistemler, <code>d_name</code> ögesini yeterince uzun tanımlamaz. Bu durumda kullanıcının ek alan sağlaması gerekir. <code>d_name</code> dizisinde en az <varname>NAME_MAX</varname><code> + 1</code> karakterlik yer olmalıdır. <code>readdir_r</code> işlevini çağıracak kod şöyle görünebilir:
    </para>
    <example>
     <screen>union
{
  struct dirent d;
  char b[offsetof (struct dirent, d_name) + NAME_MAX + 1];
} u;

if (readdir_r (dir, &amp;u.d, &amp;res) == 0)
  …
</screen>
    </example>
    <para>
     32 bitlik makinelerde büyük dosya sistemlerini desteklemek için son iki işlevin LFS sürümleri de vardır.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-readdir64"><primary>readdir64</primary></indexterm>
    <csproto type="işlev">
     <csname><ptr>struct&nbsp;dirent64</ptr><function>readdir64</function></csname>
     <csparam><ptr>DIR</ptr><parameter>dirstream</parameter></csparam>
    </csproto>
    <header>&dirent.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&asunsafe; &lock;</concept>
     <concept>&acunsafe; &lock;</concept>
    </conceptlist>
    <para>
     <code>readdir64</code> işlevi <type>struct&nbsp;dirent64</type> türünde bir gösterici döndürmesi dışında <function>readdir</function> işlevi gibidir. Bu veri türünün bazı üyeleri (özellikle <code>d_ino</code> üyesi) büyük dosya sistemlerini desteklemek üzere farklı boyutta olabilir.
    </para>
    <para>
     Diğer bakımlardan bu işlev <function>readdir</function> işleviyle eşdeğerdedir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-readdir64_r"><primary>readdir64_r</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>readdir64_r</function></csname>
     <csparam><ptr>DIR</ptr><parameter>dirstream</parameter></csparam>
     <csparam><ptr>struct&nbsp;dirent64</ptr><parameter>entry</parameter></csparam>
     <csparam><pptr>struct&nbsp;dirent64</pptr><parameter>result</parameter></csparam>
    </csproto>
    <header>&dirent.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&asunsafe; &lock;</concept>
     <concept>&acunsafe; &lock;</concept>
    </conceptlist>
    <para>
     Kullanımı önerilmeyen <code>readdir64_r</code> işlevi, 2. ve 3. bağımsız değişkenlerini <type>struct&nbsp;dirent</type> yerine <code>struct&nbsp;dirent64</code> türünde alması dışında, <function>readdir_r</function> işlevine eşdeğerdir. <function>readdir</function> işlevinin açıklamalarında dikkat çekilen hususlar bu işlev için de geçerlidir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-closedir"><primary>closedir</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>closedir</function></csname>
     <csparam><ptr>DIR</ptr><parameter>dirstream</parameter></csparam>
    </csproto>
    <header>&dirent.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&asunsafe; &heap; &lock;<code linkend="glibc-safety-condition">/hurd</code></concept>
     <concept>&acunsafe; &mem; &fd; &lock;<code linkend="glibc-safety-condition">/hurd</code></concept>
    </conceptlist>
    <para>
     Bu işlev <parameter>dirstream</parameter> ile belirtilen dizin akımını kapatır. Başarılıysa <code>0</code>, değilse <code>-1</code> döndürür.
    </para>
    <para>
     Aşağıdaki <varname>errno</varname> hata durumu bu işlev için tanımlanmıştır:
    </para>
    <formalpara><title><code>EBADF</code></title>
     <para>
      <parameter>dirstream</parameter> bağımsız değişkeni geçersiz.
     </para>
    </formalpara>
   </csynopsis>
  </sect1>
  <sect1 xml:id="glibc-Simple-Directory-Lister">
   <title>Bir Dizinin İçeriğini Listeleyen Bir Örnek</title>
   <titleabbrev>Çok basit bir dizin listeleme yazılımı.</titleabbrev>
   <para>
    Burada verilen örnek kod, çalışma dizini içindeki dosyaların isimlerini listelemektedir:
   </para>
   <screen>#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;dirent.h&gt;

int
main (void)
{
  DIR *dp;
  struct dirent *ep;

  dp = opendir ("./");
  if (dp != NULL)
    {
      while (ep = readdir (dp))
        puts (ep-&gt;d_name);
      (void) closedir (dp);
    }
  else
    perror ("Dizin açılamadı");

  return 0;
}
</screen>
   <para>
    Çıktılanan listede dosyaların sırası hemen hemen rastgeledir. Daha kullanışlı bir yazılım girdileri basmadan önce sıraya dizerdi; bkz. <xref linkend="glibc-Scanning-Directory-Content"/> ve <xref linkend="glibc-Array-Sort-Function"/>.
   </para>
  </sect1>
  <sect1 xml:id="glibc-Random-Access-Directory">
   <title>Dizin Akımında Rastgele Erişim</title>
   <titleabbrev>Aynı akımla zaten okunmuş olan dizin içeriğinin bir kısmının yeniden okunması</titleabbrev>
   <para>
    <indexterm linkend="glibc-pg"><primary>dirent.h</primary></indexterm>
    Bu bölümde açık bir dizin akımından zaten okunmuş olan bir dizin parçasının yeniden nasıl okunacağından bahsedilecektir. Bu bölümdeki tüm simgeler &dirent.h; başlık dosyasında bildirilmiştir.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-rewinddir"><primary>rewinddir</primary></indexterm>
    <csproto type="işlev">
     <csname><type>void</type><function>rewinddir</function></csname>
     <csparam><ptr>DIR</ptr><parameter>dirstream</parameter></csparam>
    </csproto>
    <header>&dirent.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&asunsafe; &lock;</concept>
     <concept>&acunsafe; &lock;</concept>
    </conceptlist>
    <para>
     <code>rewinddir</code> işlevi <parameter>dirstream</parameter> ile belirtilen dizin akımını yeniden ilklendirmekte kullanılır. Böylece bir <function>readdir</function>  çağrısı ile dizindeki ilk girdi ile ilgili bilgi tekrar döndürülebilir. Dizin daha önce <function>opendir</function> ile açılmış olduğundan bu arada silinmiş ya da eklenmiş dosyalar varsa onların da farkedilmesini sağlar. Yani son <function>opendir</function> veya <code>rewinddir</code> çağrısından sonra yapılan <function>readdir</function> çağrılarıyla eklenmiş dosyalar varsa bunlarla ilgili bilgiler dönerken silinmiş dosyalarla ilgili bilgi dönmez.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-telldir"><primary>telldir</primary></indexterm>
    <csproto type="işlev">
     <csname><type>long&nbsp;int</type><function>telldir</function></csname>
     <csparam><ptr>DIR</ptr><parameter>dirstream</parameter></csparam>
    </csproto>
    <header>&dirent.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&asunsafe; &heap;<code linkend="glibc-safety-condition">/bsd</code> &lock;<code linkend="glibc-safety-condition">/bsd</code></concept>
     <concept>&acunsafe; &mem;<code linkend="glibc-safety-condition">/bsd</code> &lock;<code linkend="glibc-safety-condition">/bsd</code></concept>
    </conceptlist>
    <para>
     <code>telldir</code> işlevi <parameter>dirstream</parameter> ile belirtilen dizin akımının dosya konumunu döndürür. Dizin akımının dosya konumunu tekrar bu noktaya getirmek için <function>seekdir</function> işlevi bu değerle kullanılabilir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-seekdir"><primary>seekdir</primary></indexterm>
    <csproto type="işlev">
     <csname><type>void</type><function>seekdir</function></csname>
     <csparam><ptr>DIR</ptr><parameter>dirstream</parameter></csparam>
     <csparam><type>long&nbsp;int</type><parameter>pos</parameter></csparam>
    </csproto>
    <header>&dirent.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&asunsafe; &heap;<code linkend="glibc-safety-condition">/bsd</code> &lock;<code linkend="glibc-safety-condition">/bsd</code></concept>
     <concept>&acunsafe; &mem;<code linkend="glibc-safety-condition">/bsd</code> &lock;<code linkend="glibc-safety-condition">/bsd</code></concept>
    </conceptlist>
    <para>
     <code>seekdir</code> işlevi <parameter>dirstream</parameter> ile belirtilen dizin akımının dosya konumunu <parameter>pos</parameter> konumuna ayarlar. <parameter>pos</parameter> değeri bu akım için daha önceki bir <function>telldir</function> çağrısından dönen değer olmalıdır. Ancak arada akım kapatılıp yeniden açılmışsa bu değer geçersiz olmuş olabilir.
    </para>
   </csynopsis>
  </sect1>
  <sect1 xml:id="glibc-Scanning-Directory-Content">
   <title>Dizin İçeriğinin Taranması</title>
   <titleabbrev>Bir dizinin kullanıcı tarafından seçilmiş bir parçasından girdilerin alınması.</titleabbrev>
   <para>
    Dizinlerle çalışan işlevlerin daha yüksek seviyedeki bir arayüzü de  <function>scandir</function> işlevidir. Bu işlevin yardımıyla, bir dizin içindeki girdilerin bir kısmı seçilebilir, sıralanabilir ve bir isim listesi alınabilir.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-scandir"><primary>scandir</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>scandir</function></csname>
     <csparam><ptr>const char</ptr><parameter>dir</parameter></csparam>
     <csparam><code>struct&nbsp;dirent&nbsp;***<parameter>namelist</parameter></code></csparam>
     <csparam><code>int (*<parameter>selector</parameter>) (const&nbsp;struct&nbsp;dirent *)</code></csparam>
     <csparam><code>int (*<parameter>cmp</parameter>) (const&nbsp;struct&nbsp;dirent **, const&nbsp;struct&nbsp;dirent **)</code></csparam>
    </csproto>
    <header>&dirent.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&asunsafe; &heap;</concept>
     <concept>&acunsafe; &mem; &fd;</concept>
    </conceptlist>
    <para>
     <code>scandir</code> işlevi <parameter>dir</parameter> ile belirtilen dizinin içeriğini tarar. Sonucu döndüren *<parameter>namelist</parameter> seçilen dizin girdilerini içeren <type>struct&nbsp;dirent</type> türündeki göstericilerin dizisidir ve <function>malloc</function> kullanılarak tahsis edilir. Dizindeki tüm girdilerin değil de sadece seçilen girdilerin döndürülmesi için işlev, kullanıcı tarafından sağlanan <parameter>selector</parameter> işlevini çağırır. <parameter>selector</parameter> işlevinin yalnızca sıfırdan farklı bir değer döndürdüğü girdiler seçilir.
    </para>
    <para>
     Son olarak, *<parameter>namelist</parameter> içindeki girdiler kullanıcı tarafından sağlanan <parameter>cmp</parameter> işlevi çağrılarak sıraya dizilir. <parameter>cmp</parameter> işlevine aktarılan bağımsız değişkenler <code>struct&nbsp;dirent&nbsp;**</code> türündedir, bu bakımdan <function>strcmp</function> veya <function>strcoll</function> işlevleri doğrudan kullanılamaz. Kullanılabilecek işlevler için aşağıya <function>alphasort</function> ve <function>versionsort</function> işlevlerine bakınız.
    </para>
    <para>
     İşlevin normal dönüş değeri *<parameter>namelist</parameter> listesine yerleştirilen girdilerin sayısıdır. <code>-1</code> dönmüşse bir hata saptanmış demektir (ya dizin okumak için açılamamıştır ya da <function>malloc</function> başarısız olmuştur). Bu durumda <varname>errno</varname> değişkenine hata durumu atanır.
    </para>
   </csynopsis>
   <para>
    Yukarıda açıklanan <function>scandir</function> işlevinin dördüncü bağımsız değişkeni sıralama işlevine göstericidir. Yazılımcıya kolaylık olarak &glibc; bu amaca uygun olarak gerçeklenmiş işlevler içerir.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-alphasort"><primary>alphasort</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>alphasort</function></csname>
     <csparam><pptr>const&nbsp;struct&nbsp;dirent</pptr><parameter>a</parameter></csparam>
     <csparam><pptr>const&nbsp;struct&nbsp;dirent</pptr><parameter>b</parameter></csparam>
    </csproto>
    <header>&dirent.h;</header>
    <conceptlist>
     <concept>&mtsafe; &locale;</concept>
     <concept>&asunsafe; &heap;</concept>
     <concept>&acunsafe; &mem;</concept>
    </conceptlist>
    <para>
     <code>alphasort</code> işlevi <function>strcoll</function> işlevi gibi davranır (bkz. <xref linkend="glibc-String-Array-Comparison"/>).  Aradaki fark, bağımsız değişkenlerin dizge göstericisi değil <code>struct&nbsp;dirent&nbsp;**</code> türünde olmasıdır.
    </para>
    <para>
     <code>alphasort</code> işlevinin dönüş değeri <parameter>a</parameter> ve <parameter>b</parameter> girdilerinin karşılaştırılmasına bağlı olarak sıfırdan küçük, sıfır ya da sıfırdan büyük bir değer olur.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-versionsort"><primary>versionsort</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>versionsort</function></csname>
     <csparam><pptr>const&nbsp;struct&nbsp;dirent</pptr><parameter>a</parameter></csparam>
     <csparam><pptr>const&nbsp;struct&nbsp;dirent</pptr><parameter>b</parameter></csparam>
    </csproto>
    <header>&dirent.h;</header>
    <conceptlist>
     <concept>&mtsafe; &locale;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     <code>versionsort</code> işlevi dahili olarak <function>strverscmp</function> işlevini kullanması dışında <function>alphasort</function> işlevi gibidir.
    </para>
   </csynopsis>
   <para>
    Eğer dosya sistemi büyük dosyaları destekliyorsa, <type>struct&nbsp;dirent</type> yapısının tüm bilgiyi içermesi mümkün olmadığından <function>scandir</function> işlevi kullanılamaz. LFS sistemi için yeni bir tür, <type>struct&nbsp;dirent64</type> ve bunu kullanmak için de yeni bir işlev vardır.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-scandir64"><primary>scandir64</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>scandir64</function></csname>
     <csparam><ptr>const char</ptr><parameter>dir</parameter></csparam>
     <csparam><code>struct&nbsp;dirent64&nbsp;***<parameter>namelist</parameter></code></csparam>
     <csparam><code>int (*<parameter>selector</parameter>) (const&nbsp;struct&nbsp;dirent64 *)</code></csparam>
     <csparam><code>int (*<parameter>cmp</parameter>) (const&nbsp;struct&nbsp;dirent64 **, const&nbsp;struct&nbsp;dirent64 **)</code></csparam>
    </csproto>
    <header>&dirent.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&asunsafe; &heap;</concept>
     <concept>&acunsafe; &mem; &fd;</concept>
    </conceptlist>
    <para>
     <code>scandir64</code> işlevi dizin girdilerini <type>struct&nbsp;dirent64</type> türünde döndürmesi dışında <function>scandir</function> işlevi gibidir. <parameter>selector</parameter> ile gösterilen işlev yine, istenen girdileri seçmek için kullanılır, ama işlev bu sefer <code>struct&nbsp;dirent64&nbsp;*</code> türünde bir bağımsız değişken alır.
    </para>
    <para>
     Benzer şekilde, <parameter>cmp</parameter> işlevi de <code>struct&nbsp;dirent64&nbsp;**</code> türünde iki bağımsız değişken alır.
    </para>
   </csynopsis>
   <para>
    <parameter>cmp</parameter> bu sefer farklı türde bağımsız değişkenler aldığından ve <function>alphasort</function> ve <function>versionsort</function> işlevleri bu türde bağımsız değişken almadıklarından burada kullanılamaz. Bu bakımdan iki işlev daha tanımlanmıştır.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-alphasort64"><primary>alphasort64</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>alphasort64</function></csname>
     <csparam><pptr>const&nbsp;struct&nbsp;dirent64</pptr><parameter>a</parameter></csparam>
     <csparam><pptr>const&nbsp;struct&nbsp;dirent64</pptr><parameter>b</parameter></csparam>
    </csproto>
    <header>&dirent.h;</header>
    <conceptlist>
     <concept>&mtsafe; &locale;</concept>
     <concept>&asunsafe; &heap;</concept>
     <concept>&acunsafe; &mem;</concept>
    </conceptlist>
    <para>
     <code>alphasort64</code> işlevi <function>strcoll</function> işlevi gibi davranır (bkz. <xref linkend="glibc-String-Array-Comparison"/>).  Aradaki fark, bağımsız değişkenlerin dizge göstericisi değil <code>struct&nbsp;dirent64&nbsp;**</code> türünde olmasıdır.
    </para>
    <para>
     <code>alphasort64</code> işlevinin dönüş değeri <parameter>a</parameter> ve <parameter>b</parameter> girdilerinin karşılaştırılmasına bağlı olarak sıfırdan küçük, sıfır ya da sıfırdan büyük bir değer olur.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-versionsort64"><primary>versionsort64</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>versionsort64</function></csname>
     <csparam><pptr>const&nbsp;struct&nbsp;dirent64</pptr><parameter>a</parameter></csparam>
     <csparam><pptr>const&nbsp;struct&nbsp;dirent64</pptr><parameter>b</parameter></csparam>
    </csproto>
    <header>&dirent.h;</header>
    <conceptlist>
     <concept>&mtsafe; &locale;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     <code>versionsort64</code> işlevi dahili olarak <function>strverscmp</function> işlevini kullanması dışında <function>alphasort64</function> işlevi gibidir.
    </para>
   </csynopsis>
   <para>
    <code>scandir</code> kullanırken 64 bitlik karşılaştıma işlevlerini kullanmamak (ya da tam tersi) önemlidir. Bunun çalıştığı sistemler varsa da diğerleri ümitsizce başarısız olacaktır.
   </para>
  </sect1>
  <sect1 xml:id="glibc-Simple-Directory-Lister-Mark-II">
   <title>Bir Dizinin İçeriğini Listeleyen İkinci Örnek</title>
   <titleabbrev>Önceki örneğin daha gelişmiş bir sürümü.</titleabbrev>
   <para>
    Burada, <xref linkend="glibc-Simple-Directory-Lister"/> bölümündeki küçük yazılımın biraz daha gelişirilmiş bir sürümü vardır. Dizin içeriğini sıralamak için uğraşmaktansa <command>scandir</command> kullanımı tercih edilmiştir. Çağrı döndükten sonra girdiler hemen kullanıma hazır hale gelir.
   </para>
   <screen>#include &lt;stdio.h&gt;
#include &lt;dirent.h&gt;

static int
one (const struct dirent *unused)
{
  return 1;
}

int
main (void)
{
  struct dirent **eps;
  int n;

  n = scandir ("./", &amp;eps, one, alphasort);
  if (n &gt;= 0)
    {
      int cnt;
      for (cnt = 0; cnt &lt; n; ++cnt)
        puts (eps[cnt]-&gt;d_name);
    }
  else
    perror ("Dizin açılamadı");

  return 0;
}
</screen>
   <para>
    Bu örnekteki seçici işlevin basitliğine dikkat edilmelidir. Dizindeki tüm girdilerin listelenmesi istendiğinden hep <code>1</code> döndürülmüştür.
   </para>
  </sect1>

  <sect1 xml:id="glibc-Low-level-Directory-Access">
   <title>Düşük Seviyeli Dizin Erişimi</title>
   <titleabbrev>Dizin erişimi için &assafe; işlevler.</titleabbrev>
   <para>
    Akım tabanlı dizin işlevleri &assafe; değildir ve <function>vfork</function> işlevinden sonra kullanılamaz. Bkz. <xref linkend="glibc-POSIX-Safety-Concepts"/>. Aşağıdaki işlev, bu bağlamlarda kullanılmak üzere tasarlanmıştır.
   </para>
   <para>
    Dizin verileri, <varname>O_DIRECTORY</varname> seçeneği olsun olmasın, <function>open</function> işlevi tarafından oluşturulduğu şekliyle bir dosya tanıtıcıdan elde edilir. Bkz. <xref linkend="glibc-Opening-and-Closing-Files"/>.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-getdents64"><primary>getdents64</primary></indexterm>
    <csproto type="işlev">
     <csname><type>ssize_t</type><function>getdents64</function></csname>
     <csparam><type>int</type><parameter>fd</parameter></csparam>
     <csparam><ptr>void</ptr><parameter>buffer</parameter></csparam>
     <csparam><type>size_t</type><parameter>length</parameter></csparam>
    </csproto>
    <header>&dirent.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     <code>getdents64</code> işlevi, <parameter>fd</parameter> dosya tanıtıcısından dizin giriş verilerinin en uzun baytlarını okur ve onu <parameter>buffer</parameter> göstericisinde başlayan bayt dizisine kaydeder.
    </para>
    <para>
     İşlev başarılı olduğunda, <parameter>buffer</parameter> tamponuna yazılan bayt sayısını döndürür. <parameter>fd</parameter> zaten dizin akımının sonundaysa bu sayı sıfırdır. Hata durumunda işlev <code>-1</code> döndürür ve hata durumunu <varname>errno</varname> değişkenini atar.
    </para>
    <para>
     Veriler, <code>d_reclen</code> üyesi kullanılarak geçilebilen bir dizi <type>struct&nbsp;dirent64</type> kaydı olarak depolanır. Tampon, mümkün olan en büyük dizin girdisini tutacak kadar büyük olmalıdır. Bazı dosya sistemlerinin <varname>NAME_MAX</varname> bayttan uzun dosya adlarını desteklediği unutulmamalıdır (örneğin, 255 adede kadar Unicode karakteri destekleyenler), bu nedenle en az 1024 baytlık tampon boyutu önerilir.
    </para>
    <para>
     Bu işlev Linux'a özgüdür.
    </para>
   </csynopsis>
  </sect1>
 </chapter>

 <chapter xml:id="glibc-Working-with-Directory-Trees">
  <title>Dizin Ağaçlarıyla Çalışma</title>
  <titleabbrev>Eylemlerin tüm dosyalara ya da seçilen bir alt dizin kümesine uygulanması.</titleabbrev>
  <para>
   <indexterm linkend="glibc-cp"><primary>dizinler</primary><secondary>hiyerarşik</secondary></indexterm>
   <indexterm linkend="glibc-cp"><primary>dizinler</primary><secondary>dizin ağacı</secondary></indexterm>
   <indexterm linkend="glibc-pg"><primary>ftw.h</primary></indexterm>
   Buraya kadar açıklanan işlevler ya bilgiyi bit bit aldı ya da tüm dosyaları grup halinde işleme soktu (bkz. <function>scandir</function>). Kimi zaman alt dizinler ve içerdikleri dosyalarla çalışmak gerekir. X/Open belirtimi bunu yapmak için iki işlev tanımlamıştır. Daha basit hali System V sistemlerindeki ilk tanımından türetilmiştir ve bu bakımdan bu işlev SVID'den türetilmiş sistemlerde bulunur. İlk örnekler ve gerekli tanımlar &ftw.h; başlık dosyasında bulunabilir.
  </para>
  <para>
   Bu ailenin dört işlevi vardır: <function>ftw</function>, <function>nftw</function> ile  64 bitlik olanları <function>ftw64</function> ve <function>nftw64</function>.  Bu işlevlerin bağımsız değişkenlerinden biri uygun türde bir geri çağırım işlevine göstericidir.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-tp" xml:id="glibc-tp-ftw_func_t"><primary sortas="ftw_func_t">__ftw_func_t</primary></indexterm>
   <csproto type="veri türü">
    <csname><code>int (*<function>__ftw_func_t</function>)</code></csname>
    <csparam><ptr>const&nbsp;char</ptr><parameter>filename</parameter></csparam>
    <csparam><ptr>const&nbsp;struct&nbsp;stat</ptr><parameter>status</parameter></csparam>
    <csparam><type>int</type><parameter>flag</parameter></csparam>
   </csproto>
   <header>&ftw.h;</header>
   <para>
    <function>ftw</function> işlevine belirtilen geri çağırım işlevinin türüdür. İlk bağımsız değişken dosya ismine bir gösterici, ikinci bağımsız değişken ise ilk bağımsız değişkende ismi belirtilen dosya için doldurulan <type>struct&nbsp;stat</type> türünde bir durum nesnesidir.
   </para>
   <para>
    Son bağımsız değişken geçerli dosya hakkında bilgi veren bir değerdir. Son bağımsız değişken şu değerleri içerebilir:
   </para>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-FTW_F"><primary>FTW_F</primary></indexterm>
    <csproto type="sabit">
     <csname><function>FTW_F</function></csname>
    </csproto>
    <para>
     Öğe ya normal bir dosya ya da diğer dosya sınıflarıyla eşleşmeyen (özel dosyalar, soketler gibi) bir dosyadır.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-FTW_D"><primary>FTW_D</primary></indexterm>
    <csproto type="sabit">
     <csname><function>FTW_D</function></csname>
    </csproto>
    <para>
     Öğe bir dizindir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-FTW_NS"><primary>FTW_NS</primary></indexterm>
    <csproto type="sabit">
     <csname><function>FTW_NS</function></csname>
    </csproto>
    <para>
     <function>stat</function> çağrısı başarısız olduğundan ikinci bağımsız değişkenin gösterdiği bilgi geçersizdir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-FTW_DNR"><primary>FTW_DNR</primary></indexterm>
    <csproto type="sabit">
     <csname><function>FTW_DNR</function></csname>
    </csproto>
    <para>
     Öğe okunamayan bir dizindir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-FTW_SL"><primary>FTW_SL</primary></indexterm>
    <csproto type="sabit">
     <csname><function>FTW_SL</function></csname>
    </csproto>
    <para>
     Öğe simgesel bağdır. Simgesel bağlar normalde izlendiğinden, bu değerin bir <function>ftw</function> geri çağırım işlevinde görünmesi simgesel bağın hedefindeki dosyanın mevcut olmadığı anlamına gelir. <function>nftw</function> işlevinde durum daha farklıdır.
    </para>
    <para>
     Bu değer sadece, ilk başlık dosyasından önce <varname>_BSD_SOURCE</varname> veya <varname>_XOPEN_EXTENDED</varname> tanımlanarak derlenmiş bir yazılımda kullanılabilir. Özgün SVID sistemlerinde simgesel bağlar yoktur.
    </para>
   </csynopsis>
   <para>
    Kaynaklar <code>_FILE_OFFSET_BITS == 64</code> ile derlenmişse, bu tür aslında <type>__ftw64_func_t</type> türü olur. Aynı sebeple <type>struct&nbsp;stat</type> türü de <type>struct&nbsp;stat64</type> olur.
   </para>
  </csynopsis>
  <para>
   Büyük Dosya Sistemi Arayüzünde ve <function>ftw64</function> işlevinde kullanılmak üzere <type>__ftw64_func_t</type> türü &ftw.h; başlık dosyasında tanımlanmştır.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-tp" xml:id="glibc-tp-ftw64_func_t"><primary sortas="ftw64_func_t">__ftw64_func_t</primary></indexterm>
   <csproto type="veri türü">
    <csname><code>int (*<function>__ftw64_func_t</function>)</code></csname>
    <csparam><ptr>const&nbsp;char</ptr><parameter>filename</parameter></csparam>
    <csparam><ptr>const&nbsp;struct&nbsp;stat64</ptr><parameter>status</parameter></csparam>
    <csparam><type>int</type><parameter>flag</parameter></csparam>
   </csproto>
   <header>&ftw.h;</header>
   <para>
    Bu tür <function>ftw64</function> işlevine belirtilen geri çağırım işlevinin türü olmak dışında <type>__ftw_func_t</type> türünün benzeridir. Geri çağırım işlevinin ikinci bağımsız değişkeni daha geniş değerleri mümkün kılmak için <type>struct&nbsp;stat64</type> türünde bir değişkene göstericidir.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-tp" xml:id="glibc-tp-nftw_func_t"><primary sortas="nftw_func_t">__nftw_func_t</primary></indexterm>
   <csproto type="veri türü">
    <csname><code>int (*<function>__nftw_func_t</function>)</code></csname>
    <csparam><ptr>const&nbsp;char</ptr><parameter>filename</parameter></csparam>
    <csparam><ptr>const&nbsp;struct&nbsp;stat</ptr><parameter>status</parameter></csparam>
    <csparam><type>int</type><parameter>flag</parameter></csparam>
    <csparam><ptr>struct&nbsp;FTW</ptr><parameter>info</parameter></csparam>
   </csproto>
   <header>&ftw.h;</header>
   <para>
    İlk üç bağımsız değişkeni <type>__ftw_func_t</type> türü ile aynıdır.  Ancak üçüncü bağımsız değişken, daha hassas bir farklılaşmayı sağlamak için bazı ek değerler içerebilir:
   </para>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-FTW_DP"><primary>FTW_DP</primary></indexterm>
    <csproto type="sabit">
     <csname><function>FTW_DP</function></csname>
    </csproto>
    <para>
     Öğe bir dizindir ve tüm alt dizinlerine girilmiş ve raporlanmıştır. Eğer <function>nftw</function> işlevi <varname>FTW_DEPTH</varname> seçeneği ile çağrılmışsa <varname>FTW_D</varname> yerine bu değer döner (aşağıya bakınız).
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-FTW_SLN"><primary>FTW_SLN</primary></indexterm>
    <csproto type="sabit">
     <csname><function>FTW_SLN</function></csname>
    </csproto>
    <para>
     Öğe geçerliğini yitirmiş bir simgesel bağdır. Yani gösterdiği dosya ortada yok.
    </para>
   </csynopsis>
   <para>
    Eylemci işlevin son bağımsız değişkeninin aldığı ek değerler aşağıda açıklanan yapıya göstericidir.
   </para>
   <para>
    Eğer kaynaklar <code>_FILE_OFFSET_BITS == 64</code> ile derlenmişse, bu tür aslında <type>__nftw64_func_t</type> türü olur. Aynı sebeple <type>struct&nbsp;stat</type> türü de <type>struct&nbsp;stat64</type> olur.
   </para>
  </csynopsis>
  <para>
   Büyük Dosya Sistemi Arayüzünde ve <function>ftw64</function> işlevinde kullanmak üzere <type>__nftw64_func_t</type> türü &ftw.h; başlık dosyasında tanımlanmştır.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-tp" xml:id="glibc-tp-nftw64_func_t"><primary sortas="nftw64_func_t">__nftw64_func_t</primary></indexterm>
   <csproto type="veri türü">
    <csname><code>int (*<function>__nftw64_func_t</function>)</code></csname>
    <csparam><ptr>const&nbsp;char</ptr><parameter>filename</parameter></csparam>
    <csparam><ptr>const&nbsp;struct&nbsp;stat64</ptr><parameter>status</parameter></csparam>
    <csparam><type>int</type><parameter>flag</parameter></csparam>
    <csparam><ptr>struct&nbsp;FTW</ptr><parameter>info</parameter></csparam>
   </csproto>
   <header>&ftw.h;</header>
   <para>
    Bu tür <function>nftw64</function> işlevine belirtilen geri çağırım işlevinin türü olmak dışında <type>__nftw_func_t</type> türünün benzeridir.  Geri çağırım işlevinin ikinci bağımsız değişkeni daha geniş değerleri mümkün kılmak için <type>struct&nbsp;stat64</type> türünde bir değişkene göstericidir.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-tp" xml:id="glibc-tp-FTW"><primary sortas="FTW">struct&nbsp;FTW</primary></indexterm>
   <csproto type="veri türü">
    <csname><type>struct</type><function>FTW</function></csname>
   </csproto>
   <header>&ftw.h;</header>
   <para>
    Bu yapının içerdiği bilgi isim bağımsız değişkeninin yorumlanmasına ve dizin hiyerarşisinin geçişli durumu hakkında bazı bilgiler verilmesine yardımcı olur.
   </para>
   <glosslist>
    <glossentry>
     <glossterm>
      <type>int&nbsp;</type><structfield>base</structfield>
     </glossterm>
     <glossdef>
      <para>
       Değeri geri çağırım işlevinin ilk bağımsız değişkeninde aktarılan dizgedeki dosya isminin dizgenin başlangıcına göre başlangıç konumudur. Dizgenin başlangıcında kalan bölüm dosyanın dosya yoludur. Çalışma dizini o an bulunan ögelerden biri olduğundan, <function>nftw</function> çağrısı <varname>FTW_CHDIR</varname> seçeneği ile yapıldığında bu bilgi önem kazanır.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <type>int&nbsp;</type><structfield>level</structfield>
     </glossterm>
     <glossdef>
      <para>
       İşlem sırasında, dosyayı bulmak için kaç dizin içeri gidileceğini gösterir. İlk dizinin seviyesi <code>0</code>'dır.
      </para>
     </glossdef>
    </glossentry>
    </glosslist>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-ftw"><primary>ftw</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>ftw</function></csname>
     <csparam><ptr>const&#160;char</ptr><parameter>filename</parameter></csparam>
     <csparam><type>__ftw_func_t</type><parameter>func</parameter></csparam>
     <csparam><type>int</type><parameter>descriptors</parameter></csparam>
    </csproto>
    <header>&string.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&asunsafe; &heap;</concept>
     <concept>&acunsafe; &mem; &fd;</concept>
    </conceptlist>
    <para>
     <code>ftw</code> işlevi, <parameter>filename</parameter> ile belirtilen dizin ve alt dizinlerinde bulunan her öge için <parameter>func</parameter> bağımsız değişkeni ile belirtilen işlevi çağırır. İşlev gerekirse simgesel bağları da izler ama ögeyi iki defa işleme sokmaz. Eğer <parameter>filename</parameter> ile bir dizin belirtilmemişse <parameter>func</parameter> işlevi sadece bu öge için çağrılır.
   </para>
   <para>
    <parameter>func</parameter> işlevine aktarılan dosya ismi <parameter>filename</parameter> bağımsız değişkeninden alınarak ve aktarılan tüm dizin isimleri ve yerel dosya ismi eklenerek oluşturulur. Böylece <parameter>func</parameter> işlevi dosyaya erişmek için bu bağımsız değişkeni kullanabilir. <code>ftw</code> ayrıca dosya için <function>stat</function> çağrısı da yapar ve bu bilgiyi <parameter>func</parameter> işlevine aktarır. Eğer bu <function>stat</function> çağrısı başarısız olursa bu durum <function>stat</function> işlevinin üçüncü bağımsız değişkenine <varname>FTW_NS</varname> aktarılarak belirtilir. Aksi takdirde, üçüncü bağımsız değişkene yukarıda <type>__ftw_func_t</type> açıklamasında belirtildiği gibi aktarım yapılır.
   </para>
   <para>
    Bir hata oluşmadığını ve işlemin devam edebileceğini belirtmek üzere eylemci işlevin <code>0</code> döndürmesi beklenir. Eğer bir hata oluşmuşsa ya da <code>ftw</code> işlevinin işlemi hemen sonlandırması isteniyorsa sıfırdan farklı bir değer döndürülmelidir. Bu işlevi sonlandırmanın tek yoludur. <parameter>func</parameter> işlevinin içinde işleme başka bir yerde devam etmek için <function>setjmp</function> veya benzeri bir işlev kullanılmamalıdır. Bu, <code>ftw</code> işlevinin tahsis ettiği öz kaynakların tahsisli olarak kalmasına sebep olur.
   </para>
   <para>
    <parameter>descriptors</parameter> bağımsız değişkeni ile <code>ftw</code> işlevinin toplam kaç dosya tanıtıcısı kullanacağı belirtilir. Ne kadar çok dosya tanıtıcısı kullanmasına izin veririrse işlev o kadar hızlı çalışır. Dizin hiyerarşisindeki her alt dizin için en fazla bir dosya tanıtıcısı kullanılır, fakat çok derinlere inildiğinde açık dosya tanıtıcılarının sayısı süreç ya da sistem için belirlenmiş sınırları aşabilir. Dahası, çok evreli yazılımlarda bu katlanarak artar. Bu bakımdan açık dosya tanıtıcılarının sayısına kabul edilebilir bir sınır belirtmek gerekir.
   </para>
   <para>
    Eğer tüm <parameter>func</parameter> çağrıları <code>0</code> ile dönmüşse ve <code>ftw</code> tüm eylemleri uygulayabilmişse, <code>ftw</code> <code>0</code> ile döner. Eğer bir işlev çağrısı başarısız olmuşsa (<function>stat</function> çağrıları hariç) <code>-1</code> ile döner. Eğer eylemci işlev çağrılarından biri sıfırdan farklı bir değerle dönmüşse <code>ftw</code> işlevi bu dönüş değerini döndürür.
   </para>
   <para>
    Kaynakların 32 bitlik bir sistemde <code>_FILE_OFFSET_BITS == 64</code> ile derlendiği durumda bu işlev aslında <function>ftw64</function> işlevidir, yani LFS arayüzü eski arayüzün yerine geçer.
   </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-ftw64"><primary>ftw64</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>ftw64</function></csname>
     <csparam><ptr>const&#160;char</ptr><parameter>filename</parameter></csparam>
     <csparam><type>__ftw64_func_t</type><parameter>func</parameter></csparam>
     <csparam><type>int</type><parameter>descriptors</parameter></csparam>
    </csproto>
    <header>&string.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&asunsafe; &heap;</concept>
     <concept>&acunsafe; &mem; &fd;</concept>
    </conceptlist>
    <para>
     Büyük Dosya Sistemleri ile çalışması dışında bu işlev <function>ftw</function> işlevinin benzeridir. <parameter>func</parameter> işlevine dosya bilgisi aktarılırken <type>struct&nbsp;stat64</type> türünde bir değişken kullanılır.
    </para>
    <para>
     32 bitlik bir sistemde, kaynakların <code>_FILE_OFFSET_BITS == 64</code> ile derlendiği durumda bu işlev <function>ftw</function> ismiyle bulunur ve eski gerçekleme tamamen LFS'ye uygun olarak değiştirilir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-nftw"><primary>nftw</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>nftw</function></csname>
     <csparam><ptr>const&#160;char</ptr><parameter>filename</parameter></csparam>
     <csparam><type>__nftw_func_t</type><parameter>func</parameter></csparam>
     <csparam><type>int</type><parameter>descriptors</parameter></csparam>
     <csparam><type>int</type><parameter>flag</parameter></csparam>
    </csproto>
    <header>&string.h;</header>
    <conceptlist>
     <concept>&mtsafe; &cwd;</concept>
     <concept>&asunsafe; &heap;</concept>
     <concept>&acunsafe; &mem; &fd; &cwd;</concept>
    </conceptlist>
    <para>
     <code>nftw</code> işlevi <function>ftw</function> işlevi gibi çalışır. <parameter>filename</parameter> ile belirtilen dizin ve alt dizinlerinde ve aşağıda açıklandığı gibi bulunan her öge için <parameter>func</parameter> bağımsız değişkeni ile belirtilen işlevi çağırır. <parameter>descriptors</parameter> bağımsız değişkeni ile <code>nftw</code> işlevinin toplam kaç dosya tanıtıcısı kullanacağı belirtilir.
    </para>
    <para>
     Birinci fark geri çağırım işlevinin türüdür. Yukarıda açıklandığı gibi geri çağırım işlevine <code>struct&nbsp;FTW&nbsp;*</code> türünde ek bilgi aktarılabilir.
    </para>
    <para>
     İkinci fark, <code>nftw</code> işlevinin dördüncü bir bağımsız değişken almasıdır. Bu bağımsız değişkene <code>0</code> veya aşağıdaki değerlerin bitsel VEYAlanmış değeri aktarılabilir:
    </para>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-FTW_PHYS"><primary>FTW_PHYS</primary></indexterm>
     <csproto type="sabit">
      <csname><function>FTW_PHYS</function></csname>
     </csproto>
     <para>
      Dizin taranırken simgesel bağlar izlenmez. Bunun yerine simgesel bağlar geri çağırım işlevinin <parameter>flag</parameter> bağımsız değişkeninde <varname>FTW_SL</varname> değeri kullanılarak belirtilir. Eğer simgesel bağın hedefindeki dosya mevcut değilse, bunun yerine <varname>FTW_SLN</varname> döner.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-FTW_MOUNT"><primary>FTW_MOUNT</primary></indexterm>
     <csproto type="sabit">
      <csname><function>FTW_MOUNT</function></csname>
     </csproto>
     <para>
      Geri çağırım işlevi, <code>nftw</code> işlevine yalnızca  <parameter>filename</parameter> bağımsız değişkeniyle aktarılan dizine bağlı dosya sisteminde bulunan ögeler için çağrılır.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-FTW_CHDIR"><primary>FTW_CHDIR</primary></indexterm>
     <csproto type="sabit">
      <csname><function>FTW_CHDIR</function></csname>
     </csproto>
     <para>
      Bu seçenek verilmişse geri çağırım işlevi çağrılmadan önce çalışma dizininden raporlanan dizine geçilir. <function>ntfw</function> işlevi geri çağırım işlevi döndükten sonra tekrar eski çalışma dizinine geçer.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-FTW_DEPTH"><primary>FTW_DEPTH</primary></indexterm>
     <csproto type="sabit">
      <csname><function>FTW_DEPTH</function></csname>
     </csproto>
     <para>
      Bu seçenek verilmişse ana dizin içeriği işlenmeden önce alt dizinler ve onların dosyaları üzerinde işlem yapılır (önce derinlik kipi). Bu durum ayrıca geri çağırım işlevine <varname>FTW_D</varname> değil <varname>FTW_DP</varname> aktarılarak belirtilir.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-FTW_ACTIONRETVAL"><primary>FTW_ACTIONRETVAL</primary></indexterm>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-FTW_CONTINUE"><primary>FTW_CONTINUE</primary></indexterm>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-FTW_STOP"><primary>FTW_STOP</primary></indexterm>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-FTW_SKIP_SUBTREE"><primary>FTW_SKIP_SUBTREE</primary></indexterm>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-FTW_SKIP_SIBLINGS"><primary>FTW_SKIP_SIBLINGS</primary></indexterm>
     <csproto type="sabit">
      <csname><function>FTW_ACTIONRETVAL</function></csname>
     </csproto>
     <para>
      Bu seçenek belirtilmişse geri çağırım işlevinin dönüş değeri farklı işlem görür. Eğer geri çağırım işlevi <code>FTW_CONTINUE</code> ile dönerse işlem normal olarak devam eder. <code>FTW_STOP</code> işlemi durdur ve işlev bu değerle döner. Eğer <varname>FTW_D</varname> bağımsız değişkeni ile çağrılmış geri çağırım işlevi <code>FTW_SKIP_SUBTREE</code> değeri ile dönerse, alt ağaç atlanır ve sonraki kardeş dizinden devam edilir;  <code>FTW_SKIP_SIBLINGS</code> değeri dönerse, o anki girdinin tüm kardeş dizinleri atlanır ve işlem bir üst dizinden devam eder. Bu seçeneğin belirtildiği durumda geri çağırım işlevi bu değerlerin dışında bir değer döndürmemelidir. Bu seçenek GNU oluşumudur.
     </para>
    </csynopsis>
    <para>
     İşlevin dönüş değeri <function>ftw</function> işlevindeki gibi değerlendirilir. Eğer tüm eylemci işlev çağrıları <code>0</code> ile dönmüşse ve <code>nftw</code> tüm eylemleri uygulayabilmişse, <code>nftw</code> işlevi <code>0</code> ile döner. Bellek sorunu gibi dahili bir hata oluşmuşsa işlev <code>-1</code> ile döner ve hata durumu <varname>errno</varname> değişkenine atanır. Eğer geri çağırım işlevi çağrılarından biri sıfırdan farklı bir değerle dönmüşse <code>nftw</code> işlevi bu dönüş değerini döndürür.
    </para>
    <para>
     Kaynakların <code>_FILE_OFFSET_BITS == 64</code> ile derlendiği 32 bitlik bir sistemde bu işlev aslında <function>nftw64</function> işlevidir, yani LFS arayüzü eski arayüzün yerine geçer.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-nftw64"><primary>nftw64</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>nftw64</function></csname>
     <csparam><ptr>const&#160;char</ptr><parameter>filename</parameter></csparam>
     <csparam><type>__nftw64_func_t</type><parameter>func</parameter></csparam>
     <csparam><type>int</type><parameter>descriptors</parameter></csparam>
     <csparam><type>int</type><parameter>flag</parameter></csparam>
    </csproto>
    <header>&string.h;</header>
    <conceptlist>
     <concept>&mtsafe; &cwd;</concept>
     <concept>&asunsafe; &heap;</concept>
     <concept>&acunsafe; &mem; &fd; &cwd;</concept>
    </conceptlist>
    <para>
     Büyük dosyalı dosya sistemlerinde çalışabilmesi dışında bu işlev <function>nftw</function> işlevinin benzeridir. Geri çağırım işlevine dosya bilgisi aktarılırken <type>struct&#160;stat64</type> türünde bir değişken kullanılır.
   </para>
   <para>
    Kaynakların <code>_FILE_OFFSET_BITS == 64</code> ile derlendiği 32 bitlik bir sistemde bu işlev <function>nftw</function> ismiyle bulunur ve eski gerçekleme tamamen LFS'ye uygun olarak değiştirilir.
   </para>
  </csynopsis>
 </chapter>

 <chapter xml:id="glibc-Hard-Links">
  <title>Sabit Bağlar</title>
  <titleabbrev>Bir dosyaya başka bir isim daha verilmesi.</titleabbrev>
  <para>
   <indexterm linkend="glibc-cp"><primary>dosyalar</primary><secondary>sabit bağlar</secondary></indexterm>
   <indexterm linkend="glibc-cp"><primary>dosyalar</primary><secondary>çok isimli</secondary></indexterm>
   <indexterm linkend="glibc-cp"><primary>dizinler</primary><secondary>sabit bağlar</secondary></indexterm>
   <indexterm linkend="glibc-cp"><primary>bağlar</primary><secondary>sabit</secondary></indexterm>
   <indexterm linkend="glibc-cp"><primary>sabit bağlar</primary></indexterm>
   POSIX sistemlerinde bir dosyanın aynı anda çok sayıda ismi olabilir. İsimlerin her biri aynı değerdedir ve biri diğerine tercih edilmez.
  </para>
  <para>
   Bir dosyaya isim eklemek için <function>link</function> işlevi kullanılır.  (Bu yeni isme ayrıca dosyaya <wordasword>sabit bağ</wordasword> da denir.)  Bir dosyaya yeni bir isim atanması dosya içeriğinin kopyalanmasına sebep olmaz; sadece dosyanın isimlerine yeni bir isim eklenmiş olur.
  </para>
  <para>
   Bir dosya çeşitli dizinlerde isimlere sahip olabilir, böyle bir dosya sisteminin düzeni kesin bir hiyerarşi ya da ağaç olmaz.
  </para>
  <para>
   Çoğu gerçeklenimde, aynı dosyanın farklı dosya sistemlerinde sabit bağlarının olmasına izin verilmez. <function>link</function> işlevi böyle bir işlem yapmak için kullanılmaya çalışılırsa, diğer dosya sistemi için bu işlemin yapılamayacağını belirten bir hata alınır.
  </para>
  <para>
   <function>link</function> işlevi &unistd.h; başlık dosysında bildirilmiştir.
   <indexterm linkend="glibc-pg"><primary>unistd.h</primary></indexterm>
  </para>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-link"><primary>link</primary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>link</function></csname>
    <csparam><ptr>const&#160;char</ptr><parameter>oldname</parameter></csparam>
    <csparam><ptr>const&#160;char</ptr><parameter>newname</parameter></csparam>
   </csproto>
   <header>&unistd.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <code>link</code> işlevi <parameter>oldname</parameter> isimli dosyaya <parameter>newname</parameter> isimli sabit bir bağ yapar.
   </para>
   <para>
    İşlev başarılı olduğunda <code>0</code>, aksi takdirde <code>-1</code> ile döner. <link linkend="glibc-File-Name-Errors">Dosya ismi hatalarına</link> ek olarak aşağıdaki <varname>errno</varname> hata durumları bu işlev için tanımlanmıştır:
   </para>
   <variablelist>
    <varlistentry>
     <term><code>EACCES</code></term>
     <listitem>
      <para>
       Yeni bağın yazılacağı dizine yazma izni verilmedi.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>EEXIST</code></term>
     <listitem>
      <para>
       <parameter>newname</parameter> isminde bir dosya zaten var.  Bu ismi yeni bağ ismi olarak kullanmak için önce mevcut isim değiştirilmelidir.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>EMLINK</code></term>
     <listitem>
      <para>
       <parameter>oldname</parameter> isimli dosya için zaten çok fazla ek isim var. (Bir dosyaya verilecek bağ sayısı <varname>LINK_MAX</varname> ile sınırlıdır; bkz. <xref linkend="glibc-Limits-for-Files"/>.)
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>ENOENT</code></term>
     <listitem>
      <para>
       <parameter>oldname</parameter> isminde dosya yok.  Olmayan dosyaya bağ oluşturulamaz.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>ENOSPC</code></term>
     <listitem>
      <para>
       Yeni bağı içerecek dizin yok ya da dosya sisteminde yer yok ve genişletilemiyor.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>EPERM</code></term>
     <listitem>
      <para>
       GNU/Linux ve GNU/Hurd sistemlerinde ve bazı sistemlerde dizinlere sabit bağ oluşturulamaz. Bir çok sistem bu izni sadece ayrıcalıklı kullanıcılara verir. Bu hata sorunu raporlamakta kullanılır.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>EROFS</code></term>
     <listitem>
      <para>
       Dosya sistemi salt-okunur bağlı olduğundan yeni bağı içerecek dizine yazılamıyor.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>EXDEV</code></term>
     <listitem>
      <para>
       <parameter>newname</parameter> ile belirtilen dizin mevcut dosyadan farklı bir dosya sisteminde.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>EIO</code></term>
     <listitem>
      <para>
       Diske okuma ya da yazma denemesi sırasında bir donanım hatası oluştu.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-linkat"><primary>linkat</primary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>linkat</function></csname>
    <csparam><type>int</type><parameter>oldfd</parameter></csparam>
    <csparam><ptr>const&#160;char</ptr><parameter>oldname</parameter></csparam>
    <csparam><type>int</type><parameter>newfd</parameter></csparam>
    <csparam><ptr>const&#160;char</ptr><parameter>newname</parameter></csparam>
    <csparam><type>int</type><parameter>flags</parameter></csparam>
   </csproto>
   <header>&unistd.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-AT_FDCWD"><primary>AT_FDCWD</primary></indexterm>
    <code>linkat</code> işlevi, kaynak ve hedefini bir dosya tanıtıcı (bir dizine atıfta bulunarak) ve bir yol adının birleşimini kullanarak tanımlaması dışında, <function>link</function> işlevine benzer. Yol adı mutlak değilse, karşılık gelen dosya tanıtıcısına göre çözümlenir. <varname>AT_FDCWD</varname> özel dosya tanıtıcısı, geçerli dizini belirtir.
   </para>
   <para>
    <parameter>flags</parameter> bağımsız değişkeni, aşağıdaki seçeneklerin birleşimidir:
   </para>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-AT_SYMLINK_FOLLOW"><primary>AT_SYMLINK_FOLLOW</primary></indexterm>
    <csproto type="sabit">
     <csname><function>AT_SYMLINK_FOLLOW</function></csname>
    </csproto>
    <header>&fcntl.h;</header>
    <para>
     <parameter>oldfd</parameter> ve <parameter>oldname</parameter> tarafından tanımlanan kaynak yolu simgesel bağ ise, <code>linkat</code> bağı takip eder ve hedefine bir bağ oluşturur. Seçenek belirtilmezse, simgesel bağın kendisi için bağ oluşturulur; bu, tüm dosya sistemleri tarafından desteklenmez ve bu durumda <code>linkat</code> başarısız olabilir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-AT_EMPTY_PATH"><primary>AT_EMPTY_PATH</primary></indexterm>
    <csproto type="sabit">
     <csname><function>AT_EMPTY_PATH</function></csname>
    </csproto>
    <header>&fcntl.h;</header>
    <para>
     Bu seçenek belirtilirse, <parameter>oldname</parameter> boş dizge olabilir. Bu durumda, dosyaya, <varname>O_PATH</varname> veya <varname>O_TMPFILE</varname> ile açılabilecek, <parameter>oldfd</parameter> tanıtıcısı tarafından gösterilen yeni bir bağ oluşturulur. Bu seçenek GNU uzantısıdır.
    </para>
   </csynopsis>
  </csynopsis>
 </chapter>

 <chapter xml:id="glibc-Symbolic-Links">
  <title>Simgesel Bağlar</title>
  <titleabbrev>Bir dosyanın ismini gösteren dosyalar.</titleabbrev>
  <para>
   <indexterm linkend="glibc-cp"><primary>dosyalar</primary><secondary>simgesel bağlar</secondary></indexterm>
   <indexterm linkend="glibc-cp"><primary>dizinler</primary><secondary>simgesel bağlar</secondary></indexterm>
   <indexterm linkend="glibc-cp"><primary>bağlar</primary><secondary>simgesel</secondary></indexterm>
   <indexterm linkend="glibc-cp"><primary>simgesel bağlar</primary></indexterm>
   GNU sistemleri <wordasword>simgesel bağlar</wordasword>ı destekler. Bu aslında bir dosya ismine gösterici olan bir dosya çeşididir. Sabit bağların tersine, dizinlere ve diğer dosya sistemlerindeki dosyalara ve dizinlere simgesel bağlar yapılabilir. Ayrıca, olmayan bir dosyaya da simgesel bağ yapılabilir.  Tersi durumda simgesel bağın hedefindeki dosyanın silinmesi simgesel bağı sadece geçersiz hale getirir. Hedef dosya oluşturulana kadar bağ dosyası herhangi bir dosyayı göstermez.
  </para>
  <para>
   Simgesel bağların tercih edilmesinin bir başka sebebi de bağ açılmaya çalışıldığında bazı özel şeylerin yapılmasıdır. <function>open</function> işlevine dosya ismi olarak bir simgesel bağ ismi vererek dosya açılmaya çalışılırsa, bağın hedefindeki dosya ismini okunur ve bağ yerine bu dosya açılır. <function>stat</function> işlevi de benzer şekilde simgesel bağın kendisi ile değil, gösterdiği dosya ile çalışır.
  </para>
  <para>
   Ayrıca, dosya silme ve isim değiştirme gibi bazı işlemler bağın kendisi üzerinde yapılır. <function>readlink</function> ve <function>lstat</function> işlevleri ayrıca simgesel bağları izlemekten kaçınır, çünkü onların amacı bağ hakkında bilgi sağlamaktır. Sabit bağ yapan <function>link</function> işlevi simgesel bağlara da sabit bağ yapar.
  </para>
  <para>
   Bazı sistemlerde, dosyalarla çalışan bazı işlevlerin bir dosya yolu çözümlenirken kaç tane simgesel bağın izleneceğine ilişkin bir sınırlama vardır. Bu sınır sistemde eğer varsa &sys-param.h; başlık dosyasında tanımlıdır.
   <indexterm linkend="glibc-pg"><primary>sys/param.h</primary></indexterm>
  </para>
  <csynopsis>
   <indexterm linkend="glibc-vr" xml:id="glibc-vr-MAXSYMLINKS"><primary>MAXSYMLINKS</primary></indexterm>
   <csproto type="makro">
    <csname><type>int</type><function>MAXSYMLINKS</function></csname>
   </csproto>
   <header>&sys-param.h;</header>
   <para>
    <code>MAXSYMLINKS</code> makrosu bazı işlevlerin <varname>ELOOP</varname> değerini döndürmeden kaç tane simgesel bağ izleyebileceğini belirtir. Tüm işlevler böyle davranmaz ve bu değer <function>sysconf</function> işlevinin <varname>_SC_SYMLOOP</varname> için döndürdüğü değerle aynı değildir. Aslında, <function>sysconf</function> böyle bir sınır olmadığını, sınırın sonsuz olduğunu belirten bir değer döndürür.
   </para>
  </csynopsis>
  <para>
   Bu bölümdeki işlevlerin çoğu &unistd.h; başlık dosyasında bildirilmiştir.
   <indexterm linkend="glibc-pg"><primary>unistd.h</primary></indexterm>
  </para>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-symlink"><primary>symlink</primary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>symlink</function></csname>
    <csparam><ptr>const&#160;char</ptr><parameter>oldname</parameter></csparam>
    <csparam><ptr>const&#160;char</ptr><parameter>newname</parameter></csparam>
   </csproto>
   <header>&unistd.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <code>symlink</code> işlevi <parameter>oldname</parameter> isimli dosyaya <parameter>newname</parameter> isminde simgesel bağ oluşturur.
   </para>
   <para>
    İşlev başarılı olduğunda <code>0</code>, aksi takdirde <code>-1</code> ile döner. <link linkend="glibc-File-Name-Errors">Dosya ismi hatalarına</link> ek olarak aşağıdaki <varname>errno</varname> hata durumları bu işlev için tanımlanmıştır:
   </para>
   <variablelist>
    <varlistentry>
     <term><code>EEXIST</code></term>
     <listitem>
      <para>
       <parameter>newname</parameter> isminde bir dosya zaten var.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>EROFS</code></term>
     <listitem>
      <para>
       <parameter>newname</parameter> salt-okunur dosya sisteminde zaten var.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>ENOSPC</code></term>
     <listitem>
      <para>
       Yeni bağı içerecek dizin ya da dosya sistemi genişletilemiyor.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>EIO</code></term>
     <listitem>
      <para>
       Diske okuma ya da yazma denemesi sırasında bir donanım hatası oluştu.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-symlinkat"><primary>symlinkat</primary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>symlinkat</function></csname>
    <csparam><ptr>const&#160;char</ptr><parameter>oldname</parameter></csparam>
    <csparam><type>int</type><parameter>newfd</parameter></csparam>
    <csparam><ptr>const&#160;char</ptr><parameter>newname</parameter></csparam>
   </csproto>
   <header>&unistd.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <code>symlinkat</code> işlevi burada açıklanan farklılıklar dışında <function>symlink</function> ile aynıdır.
   </para>
   <para>
    <parameter>newname</parameter> ile verilen yol adı göreceli ise, <parameter>newfd</parameter> dosya tanıtıcısı tarafından atıfta bulunulan dizine göre (göreli bir yol adı için <function>symlink</function> tarafından yapıldığı gibi, çağrıldığı sürecin geçerli çalışma dizinine göre değil) yorumlanır.
   </para>
   <para>
    <parameter>newname</parameter> göreliyse ve <parameter>newfd</parameter> <varname>AT_FDCWD</varname> özel değeriyse, <parameter>newname</parameter> çağrıldığı sürecin geçerli çalışma dizinine göre yorumlanır (<function>symlink</function> gibi).
   </para>
   <para>
    <parameter>newname</parameter> mutlak yol adı ise <parameter>newfd</parameter> yok sayılır.
   </para>
   <para>
    <function>symlink</function> işlevindeki hatalara ek olarak bu işlevde aşağıdaki hatalar oluşur:
   </para>
   <variablelist>
    <varlistentry>
     <term><code>EBADF</code></term>
     <listitem>
      <para>
       <parameter>newfd</parameter> dosya tanıtıcısı geçersiz.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>ENOENT</code></term>
     <listitem>
      <para>
       <parameter>newname</parameter> göreli ve <parameter>newfd</parameter> dosya tanıtıcısı silinmiş bir dizine ait.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>ENOTDIR</code></term>
     <listitem>
      <para>
       <parameter>newname</parameter> göreli ve <parameter>newfd</parameter> dosya tanıtıcısı bir dizine değil bir dosyaya ait.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-readlink"><primary>readlink</primary></indexterm>
   <csproto type="işlev">
    <csname><type>ssize_t</type><function>readlink</function></csname>
    <csparam><ptr>const&#160;char</ptr><parameter>filename</parameter></csparam>
    <csparam><ptr>char</ptr><parameter>buffer</parameter></csparam>
    <csparam><type>size_t</type><parameter>size</parameter></csparam>
   </csproto>
   <header>&stdlib.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <code>readlink</code> işlevi simgesel bağın ismini <parameter>filename</parameter> ile alır ve simgesel bağın hedefindeki dosyanın ismini *<parameter>buffer</parameter>'a yerleştirir.  Dosya ismi dizgesi boş karakter sonlandırmalı <emphasis>değildir</emphasis>; işlev <parameter>buffer</parameter> ile gösterilen dizgeye yerleştirilen karakterlerin sayısı ile döner, dolayısıyla <parameter>size</parameter> bağımsız değişkeni en azından bu değerde olmalıdır.
   </para>
   <para>
    Eğer işlev <parameter>size</parameter> değerine eşit bir değerle dönmüşse, dosya ismi için yeterli yerin olup olmadığı hakkında bir fikir vermez. Bu durumda tamponu büyütüp tekrar denemek gerekir.
   </para>
   <example>
    <screen>char *
readlink_malloc (const char *filename)
{
  size_t size = 50;
  char *buffer = NULL;

  while (1)
    {
      buffer = xreallocarray (buffer, size, 2);
      size *= 2;
      ssize_t nchars = readlink (filename, buffer, size);
      if (nchars &lt; 0)
        {
          free (buffer);
          return NULL;
        }
      if (nchars &lt; size)
        return buffer;
    }
}
</screen>
   </example>
   <para>
    İşlevin dönüş değeri <code>-1</code> ise bir hata oluşmuş demektir. <link linkend="glibc-File-Name-Errors">Dosya ismi hatalarına</link> ek olarak aşağıdaki <varname>errno</varname> hata durumları bu işlev için tanımlanmıştır:
   </para>
   <variablelist>
    <varlistentry>
     <term><code>EINVAL</code></term>
     <listitem>
      <para>
       Dosya simgesel bağ değil.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>EIO</code></term>
     <listitem>
      <para>
       Diske okuma ya da yazma denemesi sırasında bir donanım hatası oluştu.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </csynopsis>
  <para>
   Bazı durumlarda simgesel bağların hedefindeki gerçek dosya isminin başka hiçbir simgesel bağ, önek ve dosya yolunda '<code>.</code>' veya '<code>..</code>' olmaksızın çözümlenmesi istenebilir. Bu örneğin, aynı dosya düğümüne erişen farklı dosya isimlerinin karşılaştırılması durumunda istenebilir.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-canonicalize_file_name"><primary>canonicalize_file_name</primary></indexterm>
   <csproto type="işlev">
    <csname><ptr>char</ptr><function>canonicalize_file_name</function></csname>
    <csparam><ptr>const&#160;char</ptr><parameter>name</parameter></csparam>
   </csproto>
   <header>&unistd.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&asunsafe; &heap;</concept>
    <concept>&acunsafe; &mem; &fd;</concept>
   </conceptlist>
   <para>
    <code>canonicalize_file_name</code> işlevi <parameter>name</parameter> ile belirtilen dosya isminin  ne '<code>.</code>' ve '<code>.</code>' elemanları ne herhangi bir dosya yolu ayracı (<command>/</command>) ne de simgesel bağ içeren mutlak ismini döndürür. İşlev dönüş değerini <function>malloc</function> ile tahsis edilmiş bellek diliminde döndürür. Eğer dönen sonuç artık kullanılmayacaksa <function>free</function> çağrısı ile serbest bırakılmalıdır.
   </para>
   <para>
    Bir dosya yolu bileşeni yoksa işlev boş gösterici ile döner. Bu ayrıca, dosya yolunun uzunluğu <varname>PATH_MAX</varname> karakteri aşarsa da döndürülür. Her durumda <varname>errno</varname> değişkenine hata durumu atanır.
   </para>
   <variablelist>
    <varlistentry>
     <term><code>ENAMETOOLONG</code></term>
     <listitem>
      <para>
       Sonuçlanan dosya yolu çok uzun. Bu hata dosya isimlerinde uzunluk sınırı olan dosya sistemlerinde oluşur.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>EACCES</code></term>
     <listitem>
      <para>
       Dosya yolunu oluşturan bileşenlerden en az biri okunamıyor.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>ENOENT</code></term>
     <listitem>
      <para>
       Girdi dosya ismi boş veya dosya yolunu oluşturan bileşenlerden en az biri mevcut değil.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>ELOOP</code></term>
     <listitem>
      <para>
       <varname>MAXSYMLINKS</varname>'den fazla simgesel bağ izlendi.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    Bu işlev GNU oluşumudur.
   </para>
  </csynopsis>
  <para>
   Unix standardı <function>canonicalize_file_name</function> işlevinin bir benzeri olarak sonucun yerleştirileceği tamponu kullanıcının belirteceği bir işlev tanımlamıştır.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-realpath"><primary>realpath</primary></indexterm>
   <csproto type="işlev">
    <csname><ptr>char</ptr><function>realpath</function></csname>
    <csparam><type>const&#160;char&#160;*restrict</type><parameter>name</parameter></csparam>
    <csparam><type>char&#160;*restrict</type><parameter>resolved</parameter></csparam>
   </csproto>
   <header>&stdlib.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&asunsafe; &heap;</concept>
    <concept>&acunsafe; &mem; &fd;</concept>
   </conceptlist>
   <para>
    <code>realpath</code> işlevi <parameter>resolved</parameter> bağımsız değişkeninde boş gösterici belirtildiğinde tamamen <function>canonicalize_file_name</function> gibi davranır.  İşlev bir tampon tahsis eder ve ona bir gösterici ile döner. Eğer <parameter>resolved</parameter> <varname>NULL</varname> değilse, sonuç onun gösterdiği tampona kopyalanır. İşlevin çağrıcıya yanıtı yeterince büyük bir tampon tahsis etmektir. <varname>PATH_MAX</varname>'ın tanımlı olduğu sistemlerde tampon bu uzunlukta olmalıdır. Dosya yolu uzunluğu için bir sınırlama bulunmayan sistemlerde uzunluk tahmin edilemeyeceğinden <code>realpath</code> işlevi <parameter>resolved</parameter> bağımsız değişkeninde <varname>NULL</varname> dışında bir değer belirtilerek çağrılMAMAlıdır.
   </para>
   <para>
    Bir diğer fark da, işlev <varname>NULL</varname> ile döndüğünde <parameter>resolved</parameter> tamponunun (sıfırdan farklıysa) mevcut olmayan ya da okunamayan dosya yolu parçaları içereceğidir. Bu durumda <varname>errno</varname> değişkenine <varname>EACCES</varname> ya da <varname>ENOENT</varname> atanır.
   </para>
  </csynopsis>
  <para>
   Bu işlevi kullanmanın bir faydası da geniş çapta kullanım alanı olmasıdır. Sakıncası ise uzun dosya isimleri için sınırlama olmayan sistemlerde uzun dosya yolu başarısızlıkları bildirmesidir.
  </para>
 </chapter>

 <chapter xml:id="glibc-Deleting-Files">
  <title>Dosyaların Silinmesi</title>
  <titleabbrev>Bir dosya nasıl silinir ve bu ne anlama gelir?</titleabbrev>
  <para>
   <indexterm linkend="glibc-cp"><primary>dosyalar</primary><secondary>silinmesi</secondary></indexterm>
   Bir dosya <function>unlink</function> veya <function>remove</function> ile silinebilir.
  </para>
  <para>
   Silme işleminde aslında sadece dosyanın ismi silinir. Eğer dosya sadece isimden ibaretse dosyanın kendisi de silinmiş olur. Eğer dosyanın başka isimleri de varsa onlar bu isimler altında hala erişilebilir olur (bkz. <xref linkend="glibc-Hard-Links"/>).
  </para>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-unlink"><primary>unlink</primary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>unlink</function></csname>
    <csparam><ptr>const&#160;char</ptr><parameter>filename</parameter></csparam>
   </csproto>
   <header>&unistd.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <code>unlink</code> işlevi <parameter>filename</parameter> ile belirtilen dosya ismini siler.  Eğer dosya sadece isimden ibaretse dosyanın kendisi de silinir. (Aslında, eğer herhangi bir süreç dosyayı açmışsa silme işlemi süreçler dosyayı kapatıncaya kadar ertelenir.)
   </para>
   <para>
    İşlev başarılı olduğunda <code>0</code>, aksi takdirde <code>-1</code> ile döner. <link linkend="glibc-File-Name-Errors">Dosya ismi hatalarına</link> ek olarak aşağıdaki <varname>errno</varname> hata durumları bu işlev için tanımlanmıştır:
   </para>
   <variablelist>
    <varlistentry>
     <term><code>EACCES</code></term>
     <listitem>
      <para>
       Silinecek dosyanın bulunduğu dizinde yazma izniniz yok ya da dizinde yapışkan bit var ve dosya size ait değil.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>EBUSY</code></term>
     <listitem>
      <para>
       Bu hata dosyanın sistem tarafından kullanıldığından silinemeyeceğini belirtir. Örneğin, dosya ismi kök dizini ya da bir dosya sisteminin bağlı olduğu dizini belirtiyorsa bu hata oluşur.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>ENOENT</code></term>
     <listitem>
      <para>
       Silinecek dosya ismi mevcut değil.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>EPERM</code></term>
     <listitem>
      <para>
       Bazı sistemlerde <code>unlink</code> bir dizini silmek için kullanılamaz ya da en azından sadece ayrıcalıklı kullanıcı bunu yapabilir. Böyle sorunlarla karşılaşmamak için dizinler silinirken <command>rmdir</command> kullanılmalıdır. (GNU sisteminde <code>unlink</code> kesinlikle dizin ismini silemez.)
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>EROFS</code></term>
     <listitem>
      <para>
       Silinecek dosya salt-okunur bağlı bir dosya sisteminde ve bu değiştirilemez.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-rmdir"><primary>rmdir</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-rmdir"><primary>dizinler</primary><secondary>silinmesi</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>rmdir</function></csname>
    <csparam><ptr>const&#160;char</ptr><parameter>filename</parameter></csparam>
   </csproto>
   <header>&unistd.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <code>rmdir</code> işlevi belirtilen dizini siler. Silinecek dizin boş olmalıdır; başka bir deyişle, sadece '<filename>.</filename>' ve '<filename>..</filename>' girdilerini içermelidir.
   </para>
   <para>
    Birçok bakımdan, <code>rmdir</code> işlevi <function>unlink</function> gibi davranır.  Bu işlev için iki hata durumu daha tanımlanmıştır:
   </para>
   <variablelist>
    <varlistentry>
     <term>
      <glossterm><code>ENOTEMPTY</code></glossterm>
      <glossterm><code>EEXIST</code></glossterm>
     </term>
     <listitem>
      <para>
       Silinecek dizin boş değil.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    Bu iki hata kodu eşanlamlıdır, bazı sistemlerde biri, bazılarında öbürü kullanılır. GNU/Linux ve GNU/Hurd sistemlerinde daima <varname>ENOTEMPTY</varname> kullanılır.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-remove"><primary>remove</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-remove"><primary>dosyalar</primary><secondary>silinmesi</secondary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-remove_"><primary>dizinler</primary><secondary>silinmesi</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>remove</function></csname>
    <csparam><ptr>const&#160;char</ptr><parameter>filename</parameter></csparam>
   </csproto>
   <header>&stdio.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    Dosya silmek için kullanılan bir &isoc; işlevidir. Dosyalarla  <function>unlink</function> gibi, dizinlerle <function>rmdir</function> gibi çalışır.
   </para>
  </csynopsis>
 </chapter>

 <chapter xml:id="glibc-Renaming-Files">
  <title>Dosya İsimlerinin Değiştirilmesi</title>
  <titleabbrev><code>rename</code> işlevi.</titleabbrev>
  <para>
   Bir dosyanın ismini değiştirmek için <function>rename</function> işlevi kullanılır.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-rename"><primary>dosyalar</primary><secondary>isim değişikliği</secondary></indexterm>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-rename"><primary>rename</primary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>rename</function></csname>
    <csparam><ptr>const&#160;char</ptr><parameter>oldname</parameter></csparam>
    <csparam><ptr>const&#160;char</ptr><parameter>newname</parameter></csparam>
   </csproto>
   <header>&stdio.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <code>rename</code> işlevi <parameter>oldname</parameter> ile belirtilen dosyanın ismini <parameter>newname</parameter> yapar. Evvelce <parameter>oldname</parameter> ile erişilen dosyaya artık <parameter>newname</parameter> ile erişilebilecektir. (Eğer dosyanın başka isimleri de varsa, onlar hala geçerli olacaktır.)
   </para>
   <para>
    <parameter>newname</parameter> ile belirtilen dosya, <parameter>oldname</parameter> ile belirtilen dosya ile aynı dosya sisteminde olmalıdır.
   </para>
   <para>
    <code>rename</code> için özel bir durum, <parameter>oldname</parameter> ve <parameter>newname</parameter>  ile belirtilen isimlerin aynı dosyanın iki ismi olmasıdır (çok isimli dosya). Bu durumda yapılacak tek şey <parameter>oldname</parameter> ile belirtilen dosya ismini silmektir.  Ancak, POSIX bu durumda işlevin hiçbir şey yapmamasını ve başarı raporlamasını gerektirir. Sistemler farklı davranabilir.
   </para>
   <para>
    <parameter>oldname</parameter> bir dizin değilse ve <parameter>newname</parameter> diye bir dosya mevcutsa isim değiştirme işlemi sırasında bu dosya silinir. Bu bakımdan, <parameter>newname</parameter> ile bir dizin belirtilmişse, bu durumda <code>rename</code> başarısız olur.
   </para>
   <para>
    <parameter>oldname</parameter> bir dizinse, <parameter>newname</parameter>  mevcut olmamalı ya da boş bir dizinin ismi olmalıdır.  İkinci durumda <parameter>newname</parameter> isimli dizin önce silinecektir.   <parameter>newname</parameter>, ismi değiştirilecek <parameter>oldname</parameter> isimli dizinin bir alt dizini olmamalıdır.
   </para>
   <para>
    <code>rename</code> işlevinin kullanışlı bir özelliği, eski isim yeni isim ile değiştirilirken, dosyaya önce yeni ismin eklenmesi, sonra eski ismin silinmesi şeklinde değiştirme işleminin bölünmez tek bir işlemde yapılmasıdır. Yani, eğer işlem sırasında bir sistem çökmesi yaşanırsa, her iki ismin hala mevcut olması olasıdır.
   </para>
   <para>
    İşlevin dönüş değeri <code>-1</code> ise bir hata oluşmuş demektir. <link linkend="glibc-File-Name-Errors">Dosya ismi hatalarına</link> ek olarak aşağıdaki <varname>errno</varname> hata durumları bu işlev için tanımlanmıştır:
   </para>
   <variablelist>
    <varlistentry>
     <term><code>EACCES</code></term>
     <listitem>
      <para>
       Dizinlerden biri <parameter>newname</parameter>'i içeriyor ya da <parameter>oldname</parameter> yazmaya izin vermiyor; veya <parameter>newname</parameter> ve <parameter>oldname</parameter> birer dizin ve onlardan birine yazma izniniz yok.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>EBUSY</code></term>
     <listitem>
      <para>
       <parameter>newname</parameter> veya <parameter>oldname</parameter> ile belirtilen dizinlerden biri sistem tarafından kullanılıyor ve sistem bunları isim değişikliğine karşı engelliyor. Bu hata bir dosya sisteminin bağlı olduğu dizin için ve onun dizinleri süreçlerin çalışma dizinlerini içeriyorsa oluşur.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>
      <glossterm><code>ENOTEMPTY</code></glossterm>
      <glossterm><code>EEXIST</code></glossterm>
     </term>
     <listitem>
      <para>
       <parameter>newname</parameter> dizini boş değil. GNU/Linux ve GNU/Hurd sistemlerinde daima <varname>ENOTEMPTY</varname> kullanılır.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>EINVAL</code></term>
     <listitem>
      <para>
       <parameter>oldname</parameter>, <parameter>newname</parameter> isimli dizini içeriyor.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>EISDIR</code></term>
     <listitem>
      <para>
       <parameter>newname</parameter> bir dizin ama <parameter>oldname</parameter> değil.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>EMLINK</code></term>
     <listitem>
      <para>
       <parameter>newname</parameter> dizininin üst dizini çok fazla bağ (girdi) içerecekti.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>ENOENT</code></term>
     <listitem>
      <para>
       <parameter>oldname</parameter> yok.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>ENOSPC</code></term>
     <listitem>
      <para>
       <parameter>newname</parameter> dizinini içerecek dizinde ve dosya sisteminde yer yok.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>EROFS</code></term>
     <listitem>
      <para>
        İşlem salt-okunur bağlı bir dosya sisteminde yapılmaya çalışılıyor.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>EXDEV</code></term>
     <listitem>
      <para>
       <parameter>oldname</parameter> ve <parameter>newname</parameter> farklı dosya sistemleri üzerinde.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </csynopsis>
 </chapter>

 <chapter xml:id="glibc-Creating-Directories">
  <title>Dizinlerin Oluşturulması</title>
  <titleabbrev>Sadece dizin oluşturan bir sistem çağrısı.</titleabbrev>
  <para>
   <indexterm linkend="glibc-cp"><primary>dizinler</primary><secondary>oluşturulması</secondary></indexterm>
   <indexterm linkend="glibc-pg"><primary>mkdir</primary></indexterm>
   Dizinler <function>mkdir</function> işlevi ile oluşturulur.  (Ayrıca, aynı şeyi yapan <uri xl:href="man1-mkdir"/> adında bir kabuk komutu vardır.)
  </para>
  <csynopsis>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-mkdir"><primary>dizinler</primary><secondary>oluşturulması</secondary></indexterm>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-mkdir"><primary>mkdir</primary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>mkdir</function></csname>
    <csparam><ptr>const&#160;char</ptr><parameter>filename</parameter></csparam>
    <csparam><type>mode_t</type><parameter>mode</parameter></csparam>
   </csproto>
   <header>&sys-stat.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <code>mkdir</code> işlevi <parameter>filename</parameter> isimli yeni ve boş bir dizin oluşturur.
   </para>
   <para>
    <parameter>mode</parameter> bağımsız değişkeni ile yeni dizin dosyasının izinleri belirtilir. Bunun hakkında daha fazla bilgi için <xref linkend="glibc-Permission-Bits"/> bölümüne bakınız.
   </para>
   <para>
    <code>0</code> dönüş değeri işlevin başarılı olduğunu, <code>-1</code> ise bir hata oluştuğunu gösterir. <link linkend="glibc-File-Name-Errors">Dosya ismi hatalarına</link> ek olarak aşağıdaki <varname>errno</varname> hata durumları bu işlev için tanımlanmıştır:
   </para>
   <variablelist>
    <varlistentry>
     <term><code>EACCES</code></term>
     <listitem>
      <para>
       Yeni dizinin ekleneceği dizin için yazma izniniz yok.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>EEXIST</code></term>
     <listitem>
      <para>
       <parameter>filename</parameter> zaten var.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>EMLINK</code></term>
     <listitem>
      <para>
       Yeni dizinin ekleneceği dizin çok fazla girdi içeriyor.
      </para>
      <para>
       İyi tasarlanmış dosya sistemleri bu hatayı asla döndürmez, çünkü onlar diskinizin tutabileceğinden çok daha fazla girdiye izin verir. Ancak yine de bu hatanın alınabileceği hesaba katılmalıdır, çünkü sonuç ağ üzerinden erişilen başka bir makineden gelebilir.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>ENOSPC</code></term>
     <listitem>
      <para>
       Yeni dizini oluşturmak için dosya sisteminde yer yok.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>EROFS</code></term>
     <listitem>
      <para>
       Yeni dizinin ekleneceği dizin bir salt-okunur bağlı dosya sisteminde ve bu değiştirilemez.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </csynopsis>
 </chapter>

 <chapter xml:id="glibc-File-Attributes">
  <title>Dosya Öznitelikleri</title>
  <titleabbrev>Tek tek dosyaların öznitelikleri.</titleabbrev>
  <preliminary>
   <para>
    <indexterm linkend="glibc-pg"><primary>ls</primary></indexterm>
    Bir dosya üzerinde <command>ls -l</command> kabuk komutunu verilirse, komut dosyanın uzunluğu, kime ait olduğu, son değişklik tarihi, vs. hakkında bilgi verir. Bunlara <wordasword>dosya öznitelikleri</wordasword> denir ve dosyanın ismiyle değil dosyanın kendisiyle ilgilidir.
   </para>
   <para>
    Bu kısım bir dosyanın özniteliklerinin değiştirilmesi ve sorgulanması hakkında bilgi içerir.
   </para>
  </preliminary>
  <sect1 xml:id="glibc-Attribute-Meanings">
   <title>Dosya Özniteliklerinin Anlamları</title>
   <titleabbrev>Dosya özniteliklerinin isimleri ve ne anlama geldikleri.</titleabbrev>
   <para>
    <indexterm linkend="glibc-cp"><primary>dosyalar</primary><secondary>öznitelikleri</secondary></indexterm>
    <indexterm linkend="glibc-cp"><primary>dosyalar</primary><secondary>durumları</secondary></indexterm>
    Bir dosyanın öznitelikleri okunduğunda, <type>struct&nbsp;stat</type> türünde yapı içersinde gelir. Bu bölümde özniteliklerin isimleri, veri türleri ve anlamları açıklanacaktır. Bir dosyanın özniteliklerini okuyan işlevler <xref linkend="glibc-Reading-Attributes"/> bölümünde bulunabilir.
   </para>
   <para>
    Bu bölümdeki bütün simgeler &sys-stat.h; başlık dosyasında bildirilmiştir.
    <indexterm linkend="glibc-pg"><primary>sys/stat.h</primary></indexterm>
   </para>
   <csynopsis>
    <indexterm linkend="glibc-tp" xml:id="glibc-tp-stat"><primary sortas="stat">struct&#160;stat</primary></indexterm>
    <csproto type="veri türü">
     <csname><type>struct</type><function>stat</function></csname>
    </csproto>
    <header>&sys-stat.h;</header>
    <para>
     <code>stat</code> yapısı bir dosyanın öznitelikleri hakkında bilgi döndürmekte kullanılır. En azından şu üyeleri içerir:
    </para>
    <glosslist>
     <glossentry>
      <glossterm>
       <type>mode_t&#160;</type><structfield>st_mode</structfield>
      </glossterm>
      <glossdef>
       <para>
        Dosya kipini belirtir. Bu <link linkend="glibc-Testing-File-Type">dosya türü bilgisi</link> ile <link linkend="glibc-Permission-Bits">dosya izinlerinin bitlerini</link> içerir.
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm>
       <type>ino_t&#160;</type><structfield>st_ino</structfield>
      </glossterm>
      <glossdef>
       <para>
        Dosyanın seri numarası. Bu dosyayı aynı aygıttaki diğer dosyalardan ayırır.
      </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm>
       <type>dev_t&#160;</type><structfield>st_dev</structfield>
      </glossterm>
      <glossdef>
       <para>
        Dosyayı içeren aygıt. <structfield>st_ino</structfield> ve <structfield>st_dev</structfield> birlikte alındığında dosyayı eşsiz olarak kimliklendirir. Bununla birlikte <structfield>st_dev</structfield>, yeniden başlatmalar veya sistem çökmeleri arasında her zaman tutarlı değildir.
      </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm>
       <type>nlink_t&#160;</type><structfield>st_nlink</structfield>
      </glossterm>
      <glossdef>
       <para>
        Dosyaya sabit bağların sayısı. Bu sayı bu dosya için kaç dizinin girdi içerdiğini gösterir. Sayı hep azalıyorsa, dosyayı açık tutan süreç kalmadığı anda dosya kendisini iptal eder. Simgesel bağlar toplama dahil değildir.
      </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm>
       <type>uid_t&#160;</type><structfield>st_uid</structfield>
      </glossterm>
      <glossdef>
       <para>
        Dosyanın ait olduğu kullanıcının kullanıcı kimliği. Bkz. <xref linkend="glibc-File-Owner"/>.
      </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm>
       <type>gid_t&#160;</type><structfield>st_gid</structfield>
      </glossterm>
      <glossdef>
       <para>
        Dosyanın ait olduğu grubun grup kimliği. Bkz. <xref linkend="glibc-File-Owner"/>.
      </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm>
       <type>off_t&#160;</type><structfield>st_size</structfield>
      </glossterm>
      <glossdef>
       <para>
        Normal bir dosya için bayt cinsinden dosya uzunluğu. Aygıt dosyaları için bu alandaki değer anlamlı değildir. Simgesel bağlarda hedef dosya isminin uzunluğudur.
      </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm>
       <type>time_t&#160;</type><structfield>st_atime</structfield>
      </glossterm>
      <glossdef>
       <para>
        Dosyaya son erişim zamanı. Bkz.  <xref linkend="glibc-File-Times"/>.
      </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm>
       <type>unsigned&#160;long&#160;int&#160;</type><structfield>st_atime_usec</structfield>
      </glossterm>
      <glossdef>
       <para>
        Dosyaya son erişim zamanının ondalık kısmı. Bkz. <xref linkend="glibc-File-Times"/>.
      </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm>
       <type>time_t&#160;</type><structfield>st_mtime</structfield>
      </glossterm>
      <glossdef>
       <para>
        Dosya içeriğinin son değişiklik zamanı. Bkz. <xref linkend="glibc-File-Times"/>.
      </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm>
       <type>unsigned&#160;long&#160;int&#160;</type><structfield>st_mtime_usec</structfield>
      </glossterm>
      <glossdef>
       <para>
        Dosya içeriğinin son değişiklik zamanının ondalık kısmı. Bkz.  <xref linkend="glibc-File-Times"/>.
      </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm>
       <type>time_t&#160;</type><structfield>st_ctime</structfield>
      </glossterm>
      <glossdef>
       <para>
        Dosya özniteliklerinin son değişiklik zamanı. Bkz. <xref linkend="glibc-File-Times"/>.
      </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm>
       <type>unsigned&#160;long&#160;int&#160;</type><structfield>st_ctime_usec</structfield>
      </glossterm>
      <glossdef>
       <para>
        Dosya özniteliklerinin son değişiklik zamanının ondalık kısmı. Bkz. <xref linkend="glibc-File-Times"/>.
      </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm>
       <type>blkcnt_t&#160;</type><structfield>st_blocks</structfield>
      </glossterm>
      <glossdef>
       <para>
        Dosyanın diskte kapladığı alanın 512 baytlık bloklar cinsinden miktarı.
       </para>
       <para>
        Disk bloklarının sayısı dosya boyutu ile birebir orantılı değildir, bunun iki sebebi vardır: Dosya sistemi bazı blokları dahili kayıtlarını tutmak için kullanabilir; dosya seyrek olabilir--dosya sıfırlarla doldurulmuş "delikler" içerebilir ama bunlar aslında diskte yer kaplamaz.
       </para>
       <para>
        Bir dosyanın seyrek olup olmadığı bu değeri <structfield>st_size</structfield> ile karşılaştırarak yaklaşık olarak söylemek mümkündür:
       </para>
       <literallayout class="monospaced"><code>(st.st_blocks * 512 &lt; st.st_size)</code>
</literallayout>
       <para>
        Bu sınama mükemmel değildir çünkü gerçekten seyrek olan bir dosyanın seyrek olduğu bu yöntemle saptanamayabilir. Ama uygulamada bu bir sorun değildir.
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm>
       <type>unsigned&#160;int&#160;</type><structfield>st_blksize</structfield>
      </glossterm>
      <glossdef>
       <para>
        Dosyayı okumak ya da dosyaya yazmak için bayt cinsinden en uygun blok boyu. Bu değer, dosya ile yapılacak okuma ve yazma işlemleri için ne kadar tampon tahsis edileceğinin saptanmasında kullanılabilir. (Bu değerin <structfield>st_blocks</structfield> ile ilgisi yoktur.)
       </para>
      </glossdef>
     </glossentry>
    </glosslist>
   </csynopsis>
   <para>
    Büyük Dosya Desteği (LFS) oluşumları, 32 bit makinelerde bile 2^63'e kadar dosya boyutlarını işleyebilen türler gerektirir. Bu nedenle, <type>struct&nbsp;stat</type> için yeni bir tanım gerekir.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-tp" xml:id="glibc-tp-stat64"><primary sortas="stat64">struct&#160;stat64</primary></indexterm>
    <csproto type="veri türü">
     <csname><type>struct</type><function>stat64</function></csname>
    </csproto>
    <header>&sys-stat.h;</header>
    <para>
     Bu yapının üyeleri de üye isimleri de <type>struct&nbsp;stat</type> ile aynıdır. Tek fark <structfield>st_ino</structfield>, <structfield>st_size</structfield> ve <structfield>st_blocks</structfield> üyelerinin daha büyük değerleri tutabilmesi için farklı türde olmasıdır.
    </para>
    <glosslist>
     <glossentry>
      <glossterm>
       <type>mode_t&#160;</type><structfield>st_mode</structfield>
      </glossterm>
      <glossdef>
       <para>
        Dosya kipini belirtir. Bu <link linkend="glibc-Testing-File-Type">dosya türü bilgisi</link> ile <link linkend="glibc-Permission-Bits">dosya izinlerinin bitlerini</link> içerir.
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm>
       <type>ino64_t&#160;</type><structfield>st_ino</structfield>
      </glossterm>
      <glossdef>
       <para>
        Dosyanın seri numarası. Bu dosyayı aynı aygıttaki diğer dosyalardan ayırır.
      </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm>
       <type>dev_t&#160;</type><structfield>st_dev</structfield>
      </glossterm>
      <glossdef>
       <para>
        Dosyayı içeren aygıt. <structfield>st_ino</structfield> ve <structfield>st_dev</structfield> birlikte alındığında dosyayı eşsiz olarak kimliklendirir. Bununla birlikte <structfield>st_dev</structfield>, yeniden başlatmalar veya sistem çökmeleri arasında her zaman tutarlı değildir.
      </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm>
       <type>nlink_t&#160;</type><structfield>st_nlink</structfield>
      </glossterm>
      <glossdef>
       <para>
        Dosyaya sabit bağların sayısı. Bu sayı bu dosya için kaç dizinin girdi içerdiğini gösterir. Sayı hep azalıyorsa, dosyayı açık tutan süreç kalmadığı anda dosya kendisini iptal eder. Simgesel bağlar toplama dahil değildir.
      </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm>
       <type>uid_t&#160;</type><structfield>st_uid</structfield>
      </glossterm>
      <glossdef>
       <para>
        Dosyanın ait olduğu kullanıcının kullanıcı kimliği. Bkz. <xref linkend="glibc-File-Owner"/>.
      </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm>
       <type>gid_t&#160;</type><structfield>st_gid</structfield>
      </glossterm>
      <glossdef>
       <para>
        Dosyanın ait olduğu grubun grup kimliği. Bkz. <xref linkend="glibc-File-Owner"/>.
      </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm>
       <type>off64_t&#160;</type><structfield>st_size</structfield>
      </glossterm>
      <glossdef>
       <para>
        Normal bir dosya için bayt cinsinden dosya uzunluğu. Aygıt dosyaları için bu alandaki değer anlamlı değildir. Simgesel bağlarda hedef dosya isminin uzunluğudur.
      </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm>
       <type>time_t&#160;</type><structfield>st_atime</structfield>
      </glossterm>
      <glossdef>
       <para>
        Dosyaya son erişim zamanı. Bkz.  <xref linkend="glibc-File-Times"/>.
      </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm>
       <type>unsigned&#160;long&#160;int&#160;</type><structfield>st_atime_usec</structfield>
      </glossterm>
      <glossdef>
       <para>
        Dosyaya son erişim zamanının ondalık kısmı. Bkz. <xref linkend="glibc-File-Times"/>.
      </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm>
       <type>time_t&#160;</type><structfield>st_mtime</structfield>
      </glossterm>
      <glossdef>
       <para>
        Dosya içeriğinin son değişiklik zamanı. Bkz. <xref linkend="glibc-File-Times"/>.
      </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm>
       <type>unsigned&#160;long&#160;int&#160;</type><structfield>st_mtime_usec</structfield>
      </glossterm>
      <glossdef>
       <para>
        Dosya içeriğinin son değişiklik zamanının ondalık kısmı. Bkz.  <xref linkend="glibc-File-Times"/>.
      </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm>
       <type>time_t&#160;</type><structfield>st_ctime</structfield>
      </glossterm>
      <glossdef>
       <para>
        Dosya özniteliklerinin son değişiklik zamanı. Bkz. <xref linkend="glibc-File-Times"/>.
      </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm>
       <type>unsigned&#160;long&#160;int&#160;</type><structfield>st_ctime_usec</structfield>
      </glossterm>
      <glossdef>
       <para>
        Dosya özniteliklerinin son değişiklik zamanının ondalık kısmı. Bkz. <xref linkend="glibc-File-Times"/>.
      </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm>
       <type>blkcnt64_t&#160;</type><structfield>st_blocks</structfield>
      </glossterm>
      <glossdef>
       <para>
        Dosyanın diskte kapladığı alanın 512 baytlık bloklar cinsinden miktarı.
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm>
       <type>unsigned&#160;int&#160;</type><structfield>st_blksize</structfield>
      </glossterm>
      <glossdef>
       <para>
        Dosyayı okumak ya da dosyaya yazmak için bayt cinsinden en uygun blok boyu. Bu değer, dosya ile yapılacak okuma ve yazma işlemleri için ne kadar tampon tahsis edileceğinin saptanmasında kullanılabilir. (Bu değerin <structfield>st_blocks</structfield> ile ilgisi yoktur.)
       </para>
      </glossdef>
     </glossentry>
    </glosslist>
   </csynopsis>
   <para>
    Bazı dosya özniteliklerinin kendilerine özel veri türleri vardır. (Aslında hepsi bildiğiniz tamsayı veri türlerinin karşılığıdır.) Bu veri türleri  &sys-types.h; ve &sys-stat.h; başlık dosyalarında tanımlanmıştır. Aşağıda bunların bir listesi bulunmaktadır.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-tp" xml:id="glibc-tp-mode_t"><primary>mode_t</primary></indexterm>
    <csproto type="veri türü">
     <csname><function>mode_t</function></csname>
    </csproto>
    <header>&sys-stat.h;</header>
    <para>
     Dosya kiplerini göstermekte kullanılan tamsayı veri türü. &glibc;nde <type>unsigned&nbsp;int</type>'den daha dar olmayan imsiz bir türdür.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-cp"><primary>dosya indisi</primary></indexterm>
    <indexterm linkend="glibc-tp" xml:id="glibc-tp-ino_t"><primary>ino_t</primary></indexterm>
    <csproto type="veri türü">
     <csname><function>ino_t</function></csname>
    </csproto>
    <header>&sys-stat.h;</header>
    <para>
     Dosya seri numarasını (Bunlara kimi zaman <wordasword>dosya indisi</wordasword> dendiği de olur) göstermekte kullanılan tamsayı veri türü. &glibc;nde <type>unsigned&nbsp;int</type>'den daha dar olmayan imsiz bir türdür.
    </para>
    <para>
     Kaynakların <code>_FILE_OFFSET_BITS == 64</code> ile derlendiği sistemlerde bu tür <type>ino64_t</type> ile eşdeğerdir.
    </para>
   </csynopsis>
   <csynopsis>
     <indexterm linkend="glibc-tp" xml:id="glibc-tp-ino64_t"><primary>ino64_t</primary></indexterm>
    <csproto type="veri türü">
     <csname><function>ino64_t</function></csname>
    </csproto>
    <header>&sys-stat.h;</header>
    <para>
     LFS desteği olan sistemlerde dosya seri numarasını göstermekte kullanılan tamsayı veri türü. &glibc;nde <type>unsigned&nbsp;int</type>'den daha dar olmayan imsiz bir türdür.
    </para>
    <para>
     Kaynakların <code>_FILE_OFFSET_BITS == 64</code> ile derlendiği sistemlerde bu tür <type>ino_t</type> ismiyle bulunur.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-tp" xml:id="glibc-tp-dev_t"><primary>dev_t</primary></indexterm>
    <csproto type="veri türü">
     <csname><function>dev_t</function></csname>
    </csproto>
    <header>&sys-stat.h;</header>
    <para>
     Dosyayı içeren aygıtı göstermekte kullanılan tamsayı veri türü. &glibc;nde <type>int</type>'den daha dar olmayan bir tamsayı türüdür.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-tp" xml:id="glibc-tp-nlink_t"><primary>nlink_t</primary></indexterm>
    <csproto type="veri türü">
     <csname><function>nlink_t</function></csname>
    </csproto>
    <header>&sys-stat.h;</header>
    <para>
     Dosya bağlarının sayısını göstermekte kullanılan tamsayı veri türü.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-tp" xml:id="glibc-tp-blkcnt_t"><primary>blkcnt_t</primary></indexterm>
    <csproto type="veri türü">
     <csname><function>blkcnt_t</function></csname>
    </csproto>
    <header>&sys-stat.h;</header>
    <para>
     Blok sayısını göstermekte kullanılan tamsayı veri türü. &glibc;nde <type>int</type>'den daha dar değildir.
    </para>
    <para>
     Kaynakların <code>_FILE_OFFSET_BITS == 64</code> ile derlendiği sistemlerde bu tür <type>blkcnt64_t</type> ile eşdeğerdir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-tp" xml:id="glibc-tp-blkcnt64_t"><primary>blkcnt64_t</primary></indexterm>
    <csproto type="veri türü">
     <csname><function>blkcnt64_t</function></csname>
    </csproto>
    <header>&sys-stat.h;</header>
    <para>
     LFS desteği olan sistemlerde blok sayısını göstermekte kullanılan tamsayı veri türü. &glibc;nde <type>int</type>'den daha dar değildir.
    </para>
    <para>
     Kaynakların <code>_FILE_OFFSET_BITS == 64</code> ile derlendiği sistemlerde bu tür <type>blkcnt_t</type> ismiyle bulunur.
    </para>
   </csynopsis>
  </sect1>
  <sect1 xml:id="glibc-Reading-Attributes">
   <title>Dosya Özniteliklerinin Okunması</title>
   <titleabbrev>Bir dosyanın öznitelikleri nasıl okunur?</titleabbrev>
   <para>
    Bir dosyanın özniteliklerini öğrenmek için <function>stat</function>, <function>fstat</function> ve <function>lstat</function> işlevleri kullanılır. Öznitelikler, <type>struct&nbsp;stat</type> türünde bir nesne içinde döndürür. Bu işlevler &sys-stat.h; başlık dosyasında bildirilmiştir.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-stat"><primary>stat</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>stat</function></csname>
     <csparam><ptr>const&#160;char</ptr><parameter>filename</parameter></csparam>
     <csparam><ptr>struct&nbsp;stat</ptr><parameter>buf</parameter></csparam>
    </csproto>
    <header>&sys-stat.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     <code>stat</code> işlevi belirtilen <parameter>filename</parameter> dosyasının özniteliklerini <parameter>buf</parameter> ile gösterilen <type>struct&nbsp;stat</type> yapısı içinde döndürür.
    </para>
    <para>
     <parameter>filename</parameter> simgesel bağ adıysa, bağın hedefindeki dosyanın öznitelikleri döndürülür. Simgesel bağın hedefindeki dosya mevcut değilse işlev dosyanın mevcut olmadığını bildirerek başarısız olur.
    </para>
    <para>
     İşlem sorunsuz yerine getirilmişse <code>0</code>, aksi takdirde <code>-1</code> döner. <link linkend="glibc-File-Name-Errors">Dosya ismi hatalarına</link> ek olarak aşağıdaki <varname>errno</varname> hata durumu bu işlev için tanımlanmıştır:
    </para>
    <formalpara><title><code>ENOENT</code></title>
     <para>
      <parameter>filename</parameter> diye bir dosya yok.
     </para>
    </formalpara>
    <para>
     Kaynakların <code>_FILE_OFFSET_BITS == 64</code> ile derlendiği sistemlerde bu işlev <function>stat64</function> ile aynıdır.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-stat64"><primary>stat64</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>stat64</function></csname>
     <csparam><ptr>const&#160;char</ptr><parameter>filename</parameter></csparam>
     <csparam><ptr>struct&#160;stat64</ptr><parameter>buf</parameter></csparam>
    </csproto>
    <header>&sys-stat.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     2^31 bayttan daha büyük dosyalarla çalışmanın mümkün olduğu 32 bitlik sistemlerde bu işlev <function>stat</function> işlevine eşdeğerdir. Bunu mümkün kılmak için sonucu döndüren <parameter>buf</parameter>, <type>struct&#160;stat64</type> türündeki yapıya göstericidir.
    </para>
    <para>
     Kaynakların <code>_FILE_OFFSET_BITS == 64</code> ile derlendiği sistemlerde bu işlev <function>stat</function> ismiyle bulunur.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-fstat"><primary>fstat</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>fstat</function></csname>
     <csparam><type>int</type><parameter>filedes</parameter></csparam>
     <csparam><ptr>struct&#160;stat</ptr><parameter>buf</parameter></csparam>
    </csproto>
    <header>&sys-stat.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     <code>fstat</code> işlevi bağımsız değişken olarak dosya ismi yerine bir <link linkend="glibc-Low-Level-I-O">açık dosya tanıtıcı</link> alması dışında <function>stat</function> işlevinin benzeridir.
    </para>
    <para>
     <function>stat</function> gibi, <code>fstat</code> işlevi de başarı durumunda <code>0</code> ve hata oluşmuşsa <code>-1</code> ile döner. Aşağıdaki <varname>errno</varname> hata durumu bu işlev için tanımlanmıştır:
    </para>
    <formalpara><title><code>EBADF</code></title>
     <para>
      <parameter>filedes</parameter> dosya tanıtıcısı geçersiz.
     </para>
    </formalpara>
    <para>
     Kaynakların <code>_FILE_OFFSET_BITS == 64</code> ile derlendiği sistemlerde bu işlev <function>fstat64</function> ile aynıdır.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-fstat64"><primary>fstat64</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>fstat64</function></csname>
     <csparam><type>int</type><parameter>filedes</parameter></csparam>
     <csparam><ptr>struct&#160;stat64</ptr><parameter>buf</parameter></csparam>
    </csproto>
    <header>&sys-stat.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     Bu işlev <function>fstat</function> işlevine benzer fakat 32 bitlik platformlarda büyük dosyalarla çalışır.  Büyük dosyalarla çalışmak için <parameter>filedes</parameter> dosya tanıtıcısı <function>open64</function> veya <function>creat64</function> ile sağlanmış olmalıdır.  <parameter>buf</parameter> ile gösterilen değişken büyük değerleri tutabilen <type>struct&#160;stat64</type> türünde olmalıdır.
    </para>
    <para>
     Kaynakların <code>_FILE_OFFSET_BITS == 64</code> ile derlendiği sistemlerde bu işlev <function>fstat</function> ismiyle bulunur.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-lstat"><primary>lstat</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>lstat</function></csname>
     <csparam><ptr>const&#160;char</ptr><parameter>filename</parameter></csparam>
     <csparam><ptr>struct&nbsp;stat</ptr><parameter>buf</parameter></csparam>
    </csproto>
    <header>&sys-stat.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     <code>lstat</code> işlevi <function>stat</function> işlevi gibidir fakat <link linkend="glibc-Symbolic-Links">simgesel bağlara</link> izin vermez. Eğer <parameter>filename</parameter> bir simgesel bağ ismi ise, <code>lstat</code> bağın hedefi ile değil bağ dosyasının kendisi ile ilgili bilgi döndürür; bunun dışında <code>lstat</code> işlevi <type>stat</type> gibi çalışır.
    </para>
    <para>
     Kaynakların <code>_FILE_OFFSET_BITS == 64</code> ile derlendiği sistemlerde bu işlev <type>lstat64</type> ile aynıdır.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-lstat64"><primary>lstat64</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>lstat64</function></csname>
     <csparam><ptr>const&#160;char</ptr><parameter>filename</parameter></csparam>
     <csparam><ptr>struct&#160;stat64</ptr><parameter>buf</parameter></csparam>
    </csproto>
    <header>&sys-stat.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     2^31 bayttan daha büyük dosyalarla çalışmanın mümkün olduğu 32 bitlik sistemlerde bu işlev <function>lstat</function> işlevine eşdeğerdir. Bunu mümkün kılmak için sonucu döndüren <parameter>buf</parameter>, <type>struct&#160;stat64</type> türünde bir yapıya göstericidir.
    </para>
    <para>
     Kaynakların <code>_FILE_OFFSET_BITS == 64</code> ile derlendiği sistemlerde bu işlev <function>lstat</function> ismiyle bulunur.
    </para>
   </csynopsis>
  </sect1>

  <sect1 xml:id="glibc-Testing-File-Type">
    <title>Dosyanın Türünün Sınanması</title>
    <titleabbrev>Normal dosyalar, dizinler, bağlar, vs. arasında ayrım yapmak.</titleabbrev>
    <para>
     <wordasword>Dosya kipi</wordasword>, dosya özniteliklerinin  (<type>struct&nbsp;stat</type> yapısının) <structfield>st_mode</structfield> alanında saklanır ve iki çeşit bilgi içerebilir: dosya türü kodu ve erişim izin bitleri.  Bu bölümde sadece bir dosyanın dizin mi, soket mi, simgesel bağ mı vb. belirlenmesine yarayan tür kodları açıklanacaktır. Erişim izinleri <xref linkend="glibc-Permission-Bits"/> bölümünde açıklanmıştır.
    </para>
    <para>
     Dosya kipi içindeki dosya türü bilgisine erişmenin iki yolu vardır. İlkinde,  belirtilen dosya kipini okuyup dosya türünün kendinin ifade etttiği türde olup olmadığı hakkında bilgi veren <wordasword>doğrulama makroları</wordasword> vardır. İkinci yolla ise, dosya kipini bir maske ile süzüp sadece dosya türü kodunu bıraktıktan sonra bunu desteklenen dosya türü sabitleriyle karşılaştırarak dosya türü saptanır.
    </para>
    <para>
     Bu bölümdeki tüm simgeler &sys-stat.h; başlık dosyasında bildirilmiştir.
     <indexterm linkend="glibc-pg"><primary>sys/stat.h</primary></indexterm>
    </para>
    <para>
     Aşağıdaki doğrulama makroları, bakılacak dosya için <function>stat</function> tarafından döndürülen <type>struct&nbsp;stat</type> yapısının <structfield>st_mode</structfield> alanındaki değer olan <parameter>mode</parameter> değerine göre dosya türünü sınar:
    </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-S_ISDIR"><primary>S_ISDIR</primary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>S_ISDIR</function></csname>
     <csparam><type>mode_t</type><parameter>mode</parameter></csparam>
    </csproto>
    <header>&sys-stat.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     Dosya bir dizin ise bu makro sıfırdan farklı bir değer döndürür.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-S_ISCHR"><primary>S_ISCHR</primary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>S_ISCHR</function></csname>
     <csparam><type>mode_t</type><parameter>mode</parameter></csparam>
    </csproto>
    <header>&sys-stat.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     Dosya bir karakter aygıtı dosyası (örn, uçbirim aygıtı) ise bu makro sıfırdan farklı bir değer döndürür.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-S_ISBLK"><primary>S_ISBLK</primary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>S_ISBLK</function></csname>
     <csparam><type>mode_t</type><parameter>mode</parameter></csparam>
    </csproto>
    <header>&sys-stat.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     Dosya bir blok aygıtı dosyası (örn, bir disk bölümü) ise bu makro sıfırdan farklı bir değer döndürür.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-S_ISREG"><primary>S_ISREG</primary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>S_ISREG</function></csname>
     <csparam><type>mode_t</type><parameter>mode</parameter></csparam>
    </csproto>
    <header>&sys-stat.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     Dosya normal bir dosya ise bu makro sıfırdan farklı bir değer döndürür.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-S_ISFIFO"><primary>S_ISFIFO</primary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>S_ISFIFO</function></csname>
     <csparam><type>mode_t</type><parameter>mode</parameter></csparam>
    </csproto>
    <header>&sys-stat.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     Dosya isimli ya da isimsiz ardışık sürece özel dosya ise bu makro sıfırdan farklı bir değer döndürür. Bkz.  <xref linkend="glibc-Pipes-and-FIFOs"/>.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-S_ISLNK"><primary>S_ISLNK</primary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>S_ISLNK</function></csname>
     <csparam><type>mode_t</type><parameter>mode</parameter></csparam>
    </csproto>
    <header>&sys-stat.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     Dosya bir simgesel bağ ise bu makro sıfırdan farklı bir değer döndürür. Bkz. <xref linkend="glibc-Symbolic-Links"/>.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-S_ISSOCK"><primary>S_ISSOCK</primary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>S_ISSOCK</function></csname>
     <csparam><type>mode_t</type><parameter>mode</parameter></csparam>
    </csproto>
    <header>&sys-stat.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     Dosya bir soket ise bu makro sıfırdan farklı bir değer döndürür. Bkz. <xref linkend="glibc-Sockets"/>.
    </para>
   </csynopsis>
   <para>
    BSD uyumluluğu için, desteklenen dosya türünü sınayan ve POSIX'te olmayan bir yöntem daha vardır. Dosya türü kodunu elde etmek için kip <varname>S_IFMT</varname> ile bit seviyesinde VE'lenir ve ilgili sabitle karşılaştırılır. Örneğin,
   </para>
   <screen>S_ISCHR (<replaceable>kip</replaceable>)
</screen>
   <para>ifadesi ile </para>
   <screen>((<replaceable>kip</replaceable>  S_IFMT) == S_IFCHR)
</screen>
   <para>ifadesi eşdeğerdir.</para>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-S_IFMT"><primary>S_IFMT</primary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>S_IFMT</function></csname>
    </csproto>
    <header>&sys-stat.h;</header>
    <para>
     Bir kip değerinden dosya türünü elde etmek için kullanılan bit maskesidir.
    </para>
   </csynopsis>
   <para>
    Dosya türü kodlarının simgesel isimleri:
   </para>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-S_IFDIR"><primary>S_IFDIR</primary></indexterm>
    <csproto type="sabit">
     <csname><function>S_IFDIR</function></csname>
    </csproto>
    <header>&sys-stat.h;</header>
    <para>
     Dizin için dosya türü sabitidir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-S_IFCHR"><primary>S_IFCHR</primary></indexterm>
    <csproto type="sabit">
     <csname><function>S_IFCHR</function></csname>
    </csproto>
    <header>&sys-stat.h;</header>
    <para>
     Karakter aygıtı dosyası için dosya türü sabitidir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-S_IFBLK"><primary>S_IFBLK</primary></indexterm>
    <csproto type="sabit">
     <csname><function>S_IFBLK</function></csname>
    </csproto>
    <header>&sys-stat.h;</header>
    <para>
     Blok aygıtı dosyası için dosya türü sabitidir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-S_IFREG"><primary>S_IFREG</primary></indexterm>
    <csproto type="sabit">
     <csname><function>S_IFREG</function></csname>
    </csproto>
    <header>&sys-stat.h;</header>
    <para>
     Sıradan bir dosya için dosya türü sabitidir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-S_IFLNK"><primary>S_IFLNK</primary></indexterm>
    <csproto type="sabit">
     <csname><function>S_IFLNK</function></csname>
    </csproto>
    <header>&sys-stat.h;</header>
    <para>
     Sıradan bir dosya için dosya türü sabitidir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-S_IFSOCK"><primary>S_IFSOCK</primary></indexterm>
    <csproto type="sabit">
     <csname><function>S_IFSOCK</function></csname>
    </csproto>
    <header>&sys-stat.h;</header>
    <para>
     Soket için dosya türü sabitidir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-S_IFIFO"><primary>S_IFIFO</primary></indexterm>
    <csproto type="sabit">
     <csname><function>S_IFIFO</function></csname>
    </csproto>
    <header>&sys-stat.h;</header>
    <para>
     İsimli veya isimsiz ardışık sürece özel dosya için dosya türü sabitidir.
    </para>
   </csynopsis>
   <para>
    POSIX.1b standardı, dosya sisteminde nesne olarak gerçeklenebilmesi olası birkaç nesneden daha bahseder. Bunlar ileti kuyrukları, semaforlar ve paylaşımlı bellek nesneleridir. Bu nesnelerin diğer dosyalardan ayrımsanmasını mümkün kılmak için POSIX standardı üç yeni makrodan bahseder. Fakat diğer makroların aksine, bağımsız değişken olarak <structfield>st_mode</structfield> alanının değerini değil, <type>struct&nbsp;stat</type> yapısının tamamına gösterici alır.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-S_TYPEISMQ"><primary>S_TYPEISMQ</primary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>S_TYPEISMQ</function></csname>
     <csparam><ptr>struct&nbsp;stat</ptr><parameter>s</parameter></csparam>
    </csproto>
    <header>&sys-stat.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     Eğer sistem, POSIX ileti kuyruklarını ayrı nesneler olarak gerçekliyorsa ve dosya bir ileti kuyruğu nesnesi ise, bu makro sıfırdan farklı bir değerle döner. Tüm diğer durumlarda sonuç sıfırdır.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-S_TYPEISSEM"><primary>S_TYPEISSEM</primary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>S_TYPEISSEM</function></csname>
     <csparam><ptr>struct&nbsp;stat</ptr><parameter>s</parameter></csparam>
    </csproto>
    <header>&sys-stat.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     Eğer sistem, POSIX <link linkend="glibc-Inter-Process-Communication">semaforlarını</link> ayrı nesneler olarak gerçekliyorsa ve dosya bir semafor nesnesi ise, bu makro sıfırdan farklı bir değerle döner. Tüm diğer durumlarda sonuç sıfırdır.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-S_TYPEISSHM"><primary>S_TYPEISSHM</primary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>S_TYPEISSHM</function></csname>
     <csparam><ptr>struct&nbsp;stat</ptr><parameter>s</parameter></csparam>
    </csproto>
    <header>&sys-stat.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     Eğer sistem, POSIX paylaşımlı bellek nesnelerini ayrı nesneler olarak gerçekliyorsa ve dosya bir paylaşımlı bellek nesnesi ise, bu makro sıfırdan farklı bir değerle döner. Tüm diğer durumlarda sonuç sıfırdır.
    </para>
   </csynopsis>
  </sect1>
  <sect1 xml:id="glibc-File-Owner">
   <title>Dosya İyeliği</title>
   <titleabbrev>Dosyaların iyeliği nasıl belirlenir ve nasıl değiştirilir?</titleabbrev>
   <para>
    <indexterm linkend="glibc-cp"><primary>dosyalar</primary><secondary>aidiyet</secondary></indexterm>
    <indexterm linkend="glibc-cp"><primary>dosyalar</primary><secondary>aidiyet</secondary><tertiary>grup</tertiary></indexterm>
    <indexterm linkend="glibc-cp"><primary>dosyalar</primary><secondary>aidiyet</secondary><tertiary>kullanıcı</tertiary></indexterm>
    Her dosyanın sistemde kayıtlı kullanıcı olarak tanımlı bir <firstterm>sahibi</firstterm> ve sistemde tanımlı gruplardan biri olarak bir <firstterm>grubu</firstterm> vardır. Dosya sahibi çoğunlukla dosyayı düzenleyebilen kullanıcı olarak ele alınırsa da asıl amaç erişim denetimidir.
    </para>
    <para>
     Dosya sahibi ve grubu erişimi saptamakta kullanılır. Bunlar için her dosyada erişim izin bitleri tanımlanmıştır; ilk bit kümesi dosyanın sahibinin yetkilerini, ikinci bit kümesi dosyaya erişim yetkisi olan gruba tanınan yetkileri, üçüncüsü bit kümesi ise diğerlerine tanınan yetkileri belirlemekte kullanılır. Bu veriye dayalı olarak erişime nasıl karar verildiği <xref linkend="glibc-Access-Permission"/> bölümünde ayrıntılı olarak açıklanmıştır.
    </para>
    <para>
     Bir dosya oluşturulurken, sahibi, <link linkend="glibc-Process-Persona">sürecin etkin kullanıcı kimliği</link> yapılarak dosya oluşturulur. Dosyanın grup kimliği dosyayı içerecek dosya sistemine bağlı olarak ya sürecin etkin grup kimliği ya da dosyayı içeren dizinin grup kimliği yapılır. Uzak bir dosya sistemine erişildiğinde uygulanan kurallar yerel dosya sisteminin değil uzak dosya sisteminin kuralları olacaktır. Bu bakımdan yazılım, üzerinde çalıştığı sistemin davranış çeşidine bakmaksızın her davranış çeşidine uyum sağlamaya hazır olmalıdır.
    </para>
    <para>
     <indexterm linkend="glibc-pg"><primary>chown</primary></indexterm>
     <indexterm linkend="glibc-pg"><primary>chgrp</primary></indexterm>
     Mevcut bir dosyanın sahibi ve/veya grubu <function>chown</function> işlevi kullanılarak değiştirilebilir. Bu işlev <uri xl:href="man1-chown"/> ve <uri xl:href="man1-chgrp"/> kabuk komutlarının ilkelidir.
    </para>
    <para>
     <indexterm linkend="glibc-pg"><primary>unistd.h</primary></indexterm>
     Bu işlev &unistd.h; başlık dosyasında bildirilmiştir.
    </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-chown"><primary>chown</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>chown</function></csname>
     <csparam><ptr>const&#160;char</ptr><parameter>filename</parameter></csparam>
     <csparam><type>uid_t</type><parameter>owner</parameter></csparam>
     <csparam><type>gid_t</type><parameter>group</parameter></csparam>
    </csproto>
    <header>&unistd.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     <code>chown</code> işlevi ismi belirtilen <parameter>filename</parameter> dosyasının sahibini <parameter>owner</parameter> ve grubunu <parameter>group</parameter> olarak değiştirir.
    </para>
    <para>
     Bazı sistemlerde dosyanın iyeliğinin değiştirilmesi suid ve sgid bitlerinin temizlenmesine yol açar (Bu bitlerin dosyanın yeni sahipleri için uygun olmayabileceğinden dolayı). Diğerleri ile ilişkili izin bitleri değişmez.
    </para>
    <para>
     İşlev başarılı olduğunda <code>0</code>, aksi takdirde <code>-1</code> ile döner. <link linkend="glibc-File-Name-Errors">Dosya ismi hatalarına</link> ek olarak aşağıdaki <varname>errno</varname> hata durumları bu işlev için tanımlanmıştır:
    </para>
    <variablelist>
     <varlistentry>
      <term><code>EPERM</code></term>
      <listitem>
       <para>
        Bu sürecin yetkileri istenen değişikliği yapmak için yetersiz.
       </para>
       <para>
        Sadece ayrıcalıklı kullanıcı ve dosyanın sahibi dosyanın grubunu değiştirebilir. Çoğu sistemde dosyanın sahibini sadece ayrıcalıklı kullanıcı değiştirebilirken bazı sistemlerde ise dosya sahibine dosya sahipliğini değiştirme izni verilebilir. Uzak dosya sistemine erişildiğinde uygulanan kurallar yerel dosya sisteminin değil uzak dosya sisteminin kuralları olacaktır.
       </para>
       <para>
        <varname>_POSIX_CHOWN_RESTRICTED</varname> makrosu hakkında bilgi edinmek için bkz. <xref linkend="glibc-Options-for-Files"/>.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>EROFS</code></term>
      <listitem>
       <para>
        Dosya, salt-okunur bağlı bir dosya sisteminde.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-fchown"><primary>fchown</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>fchown</function></csname>
     <csparam><type>int</type><parameter>filedes</parameter></csparam>
     <csparam><type>uid_t</type><parameter>owner</parameter></csparam>
     <csparam><type>gid_t</type><parameter>group</parameter></csparam>
    </csproto>
    <header>&unistd.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     Bu işlev bir dosyanın ismini değil <parameter>filedes</parameter> ile belirtilen  açık dosya tanıtıcısını alması dışında <function>chown</function> işlevi gibidir.
    </para>
    <para>
     İşlev başarılı olduğunda <code>0</code>, aksi takdirde <code>-1</code> ile döner. Aşağıdaki <varname>errno</varname> hata durumları bu işlev için tanımlanmıştır:
    </para>
    <variablelist>
     <varlistentry>
      <term><code>EBADF</code></term>
      <listitem>
       <para>
        <parameter>filedes</parameter> bağımsız değişkeni geçerli bir dosya tanıtıcı değil.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>EINVAL</code></term>
      <listitem>
       <para>
        <parameter>filedes</parameter> bağımsız değişkeni normal bir dosyayla değil, ardışık süreç ya da soket ile ilişkili.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>EPERM</code></term>
      <listitem>
       <para>
        Bu sürecin yetkileri istenen değişikliği yapmak için yetersiz. Ayrıntılar için yukarı, <function>chmod</function> işlevine bakınız.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>EROFS</code></term>
      <listitem>
       <para>
        Dosya, salt-okunur bağlı bir dosya sisteminde.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </csynopsis>
  </sect1>
  <sect1 xml:id="glibc-Permission-Bits">
   <title>Erişim İzinleri için Kip Bitleri</title>
   <titleabbrev>Bir dosyanın erişim kipi nasıl belirlenir.</titleabbrev>
   <para>
    <wordasword>Dosya kipi</wordasword>, dosya özniteliklerinin (<type>struct&nbsp;stat</type> yapısının) <structfield>st_mode</structfield> alanında saklanır ve iki çeşit bilgi içerebilir: dosya türü kodu ve erişim izin bitleri.  Bu bölümde sadece bir dosyayı kimlerin okuyabileceği veya yazabileceğini denetleyen erişim izni bitleri açıklanacaktır. Dosya türü kodları <xref linkend="glibc-Testing-File-Type"/> bölümünde açıklanmıştır.
    </para>
    <para>
     Bu bölümdeki simgelerin hepsi  &sys-stat.h; başlık dosyasında tanımlanmıştır.
     <indexterm linkend="glibc-pg"><primary>sys/stat.h</primary></indexterm>
     <indexterm linkend="glibc-cp"><primary>dosyalar</primary><secondary>erişim bitleri</secondary></indexterm>
     Bir dosyanın erişim izinlerini denetleyen dosya kipi bitleri için tanımlanmış sabitler:
    </para>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-S_IRUSR"><primary>S_IRUSR</primary></indexterm>
    <csproto type="sabit">
     <csname><function>S_IRUSR</function></csname>
    </csproto>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-S_IREAD"><primary>S_IREAD</primary></indexterm>
    <csproto type="sabit">
     <csname><function>S_IREAD</function></csname>
    </csproto>
    <header>&sys-stat.h;</header>
    <para>
     Dosyanın sahibi için okuma yetkisi biti. Bir çok sistemde bu bit <code>0400</code>'dür.  <code>S_IREAD</code> sabiti bu sabitin BSD uyumluluğu için sağlanmış artık atıl olmuş eşanlamlısıdır.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-S_IWUSR"><primary>S_IWUSR</primary></indexterm>
    <csproto type="sabit">
     <csname><function>S_IWUSR</function></csname>
    </csproto>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-S_IWRITE"><primary>S_IWRITE</primary></indexterm>
    <csproto type="sabit">
     <csname><function>S_IWRITE</function></csname>
    </csproto>
    <header>&sys-stat.h;</header>
    <para>
     Dosyanın sahibi için yazma yetkisi biti. Bir çok sistemde bu bit <code>0200</code>'dür.  <code>S_IWRITE</code> sabiti bu sabitin BSD uyumluluğu için sağlanmış artık atıl olmuş eşanlamlısıdır.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-S_IXUSR"><primary>S_IXUSR</primary></indexterm>
    <csproto type="sabit">
     <csname><function>S_IXUSR</function></csname>
    </csproto>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-S_IEXEC"><primary>S_IEXEC</primary></indexterm>
    <csproto type="sabit">
     <csname><function>S_IEXEC</function></csname>
    </csproto>
    <header>&sys-stat.h;</header>
    <para>
     Dosyanın sahibi için normal dosyalarda çalıştırma, dizinlerde arama yetkisi biti. Bir çok sistemde bu bit <code>0100</code>'dür. <code>S_IEXEC</code> sabiti bu sabitin BSD uyumluluğu için sağlanmış artık atıl olmuş eşanlamlısıdır.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-S_IRWXU"><primary>S_IRWXU</primary></indexterm>
    <csproto type="sabit">
     <csname><function>S_IRWXU</function></csname>
    </csproto>
    <header>&sys-stat.h;</header>
    <para>
     ‘<filename>(S_IRUSR | S_IWUSR | S_IXUSR)</filename>’ ifadesine eşdeğerdir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-S_IRGRP"><primary>S_IRGRP</primary></indexterm>
    <csproto type="sabit">
     <csname><function>S_IRGRP</function></csname>
    </csproto>
    <header>&sys-stat.h;</header>
    <para>
     Dosyanın grubu için okuma yetkisi biti. Bir çok sistemde bu bit <code>040</code>'tır.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-S_IWGRP"><primary>S_IWGRP</primary></indexterm>
    <csproto type="sabit">
     <csname><function>S_IWGRP</function></csname>
    </csproto>
    <header>&sys-stat.h;</header>
    <para>
     Dosyanın grubu için yazma yetkisi biti. Bir çok sistemde bu bit <code>020</code>'dir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-S_IXGRP"><primary>S_IXGRP</primary></indexterm>
    <csproto type="sabit">
     <csname><function>S_IXGRP</function></csname>
    </csproto>
    <header>&sys-stat.h;</header>
    <para>
     Dosyanın grubu için çalıştırma ve arama yetkisi biti. Bir çok sistemde bu bit <code>010</code>'dur.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-S_IRWXG"><primary>S_IRWXG</primary></indexterm>
    <csproto type="sabit">
     <csname><function>S_IRWXG</function></csname>
    </csproto>
    <header>&sys-stat.h;</header>
    <para>
     ‘<filename>(S_IRGRP | S_IWGRP | S_IXGRP)</filename>’ ifadesine eşdeğerdir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-S_IROTH"><primary>S_IROTH</primary></indexterm>
    <csproto type="sabit">
     <csname><function>S_IROTH</function></csname>
    </csproto>
    <header>&sys-stat.h;</header>
    <para>
     Diğer kullanıcılar için okuma yetkisi biti. Bir çok sistemde bu bit <code>04</code>'tür.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-S_IWOTH"><primary>S_IWOTH</primary></indexterm>
    <csproto type="sabit">
     <csname><function>S_IWOTH</function></csname>
    </csproto>
    <header>&sys-stat.h;</header>
    <para>
     Diğer kullanıcılar için yazma yetkisi biti. Bir çok sistemde bu bit <code>02</code>'dir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-S_IXOTH"><primary>S_IXOTH</primary></indexterm>
    <csproto type="sabit">
     <csname><function>S_IXOTH</function></csname>
    </csproto>
    <header>&sys-stat.h;</header>
    <para>
     Diğer kullanıcılar için çalıştırma ve arama yetkisi biti. Bir çok sistemde bu bit <code>01</code>'dir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-S_IRWXO"><primary>S_IRWXO</primary></indexterm>
    <csproto type="sabit">
     <csname><function>S_IRWXO</function></csname>
    </csproto>
    <header>&sys-stat.h;</header>
    <para>
     ‘<filename>(S_IROTH | S_IWOTH | S_IXOTH)</filename>’ ifadesine eşdeğerdir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-S_ISUID"><primary>S_ISUID</primary></indexterm>
    <csproto type="sabit">
     <csname><function>S_ISUID</function></csname>
    </csproto>
    <header>&sys-stat.h;</header>
    <para>
     Çalıştırma biti üzerinde etkili set-user-ID bitidir. Bir çok sistemde bu bit <code>04000</code>'dir. Bkz. <xref linkend="glibc-How-Change-Persona"/>.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-S_ISGID"><primary>S_ISGID</primary></indexterm>
    <csproto type="sabit">
     <csname><function>S_ISGID</function></csname>
    </csproto>
    <header>&sys-stat.h;</header>
    <para>
     Çalıştırma biti üzerinde etkili set-group-ID bitidir. Bir çok sistemde bu bit <code>02000</code>'dir. Bkz. <xref linkend="glibc-How-Change-Persona"/>.
    </para>
   </csynopsis>
   <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-S_ISVTX"><primary>dosyalar</primary><secondary>yapışkan bit</secondary></indexterm>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-S_ISVTX"><primary>S_ISVTX</primary></indexterm>
    <csproto type="sabit">
     <csname><function>S_ISVTX</function></csname>
    </csproto>
    <header>&sys-stat.h;</header>
    <para>
     <wordasword>Yapışkan bit</wordasword>. Bir çok sistemde bu bit <code>01000</code>'dir.
    </para>
    <para>
     Bu bit, bir dizin için bu dizindeki bir dosyayı silme iznini sadece dosyanın sahibine verir. Normalde kullanıcı ya dizindeki tüm dosyaları silebilir ya da hiçbirini silemez (kullanıcının dizine yazma izni olup olmamasına bağlı olarak). Bu sınırlamalar uygulandığında bir dosyayı silebilmek için hem dosyanın sahibi kullanıcı olmalı hem de dosyanın bulunduğu dizine kullanıcının yazma izni olmalıdır. Bunun istisnası, dizinin sahibi olmaktır. Dizinin sahibi olan kullanıcı dizin içindeki dosyaların hepsini dosyaların sahiplerinin kim olduğuna bakmaksızın silme yetkisine sahiptir. Bu bit <filename>/tmp</filename> dizininde faydalı bir amaç için kullanılır; bu dizinde herkes dosya oluşturabilir ama kimse diğerinin dosyasını silemez.
    </para>
    <para>
     Evvelce, çalıştırılabilir bir dosyada yapışkan bit etkin olduğunda sistemin takaslama kurallarında bu yazılım için değişiklik yapılırdı.  Normalde, bir yazılım sonlandığında onun bellekteki sayfaları serbest bırakılır ve yeniden kullanıma hazır tutulurdu. Eğer çalıştırılabilir dosyanın yapışkan biti etkinse, yazılım sonlandığında bellekteki sayfaları serbest bırakılmaz, yazılım hala çalışıyormuş gibi bellekte tutulurdu. Bu durum aynı yazılım defalarca çalıştırıldığında bu yazılım için bir ayrıcalık oluştururdu. Bu kullanım artık günümüzde atıl olmuştur. Artık, bir yazılım sonlandığında bellekteki sayfaları bir ihtiyaç hasıl olana kadar serbest bırakılmamaktadır. Aynı yazılım tekrar çalıştırıldığında eski sayfaları hala bellekte duruyorsa onlar kullanılabilmekte, bir ihtiyaçtan dolayı kullanılmışsa yazılım tekrar belleğe yüklenmektedir.
    </para>
    <para>
     Günümüzdeki bazı sistemlerde çalıştırılabilir dosya açısından yapışkan bit anlamlı değildir, böyle sistemlerde bu bit dizinler dışında etkinleştirilemez. Bunun denenmesi halinde, <function>chmod</function> işlevi <varname>EFTYPE</varname> hatasıyla başarısız olur; bkz. <xref linkend="glibc-Setting-Permissions"/>.
    </para>
    <para>
     Bazı sistemler (özellikle SunOS) yapışkan bit kullanımı ile ilgili olarak farklı bir uygulama yapar. Eğer yapışkan bit çalıştırılabilir <emphasis>olmayan</emphasis> bir dosya için etkinleştirilirse, tamamen zıt bir uygulama olarak, o dosyanın sayfaları belleğe alınmaz. Bunun kullanım alanı, bir NFS sunucusu üzerinde, disksiz istemcilerin takas alanı olarak kullanmak üzere ayrılmış dosyalardır. Bu dosyalar istemci makinenin belleğinde sayfalandığından, bunların bir de sunucu makinenin belleğinde sayfalanması anlamsız olacağından bu yönteme başvurulmuştur. Bu kullanımda yapışkan bit ayrıca dosya sisteminin disk üzerinde düzenli olarak dosyanın değişiklik zamanını kaydetmesinin başarısız olmasını sağlar (bir takas dosyasıyla nasılsa kimse ilgilenmez, denerek).
    </para>
    <para>
     Bu bit sadece BSD sistemlerinde geçerlidir (ve ondan türetilmiş sistemlerde). Bu bakımdan bu biti kullanmak için <varname>_BSD_SOURCE</varname> özellik seçim makrosu yazılıma dahil edilmelidir. (bkz. <xref linkend="glibc-Feature-Test-Macros"/>).
    </para>
   </csynopsis>
   <para>
    Yukarıda listelenen sabitlerin bit değerlerini kullanarak yazılımda hata ayıklarken dosya kip değerleri çözümlenebilir. Bu bit değerleri çoğu sistemde geçerlidir ama hepsinin olacağı garanti değildir.
   </para>
   <warning>
    <para>
     Dosya izinleri için doğrudan sayıları kullanmak iyi bir uygulama olmaz. Taşınabilir olmayacağından başka, bitlerin anlamlarını hatırlamak için yazılımınızın koduna bakmak gerekir. Temiz bir yazılım sabitlerin isimlerini kullanır.
    </para>
   </warning>
  </sect1>
  <sect1 xml:id="glibc-Access-Permission">
   <title>Erişim İzinleri</title>
   <titleabbrev>Bir dosyaya kimin erişeceğine sistem nasıl karar verir?</titleabbrev>
   <para>
    <indexterm linkend="glibc-cp"><primary>dosyalar</primary><secondary>erişim izinleri</secondary></indexterm>
    İşletim sistemi normalde bir dosyanın erişim izinlerine, sürecin etkin kullanıcı ve grup kimlikleri ve ek grup kimlikleri ile dosyanın sahibi, grubu ve izin bitlerine birlikte bakarak karar verir. Bu kavramlar ayrıntılı olarak <xref linkend="glibc-Process-Persona"/> bölümünde anlatılmıştır.
   </para>
   <para>
    Eğer sürecin etkin kullanıcı kimliği ile dosyanın sahibinin kullanıcı kimliği aynı ise, bu kullanıcının okuma, yazma ve çalıştırma/arama izinleri geçerli olur. Benzer şekilde, eğer, sürecin etkin veya ek grup kimliklerinden biri dosyanın grup kimliği ile aynıysa, bu grubun izinleri geçerli olur. Aksi takdirde, diğerlerinin izinlerine bakılır.
   </para>
   <para>
    <code>root</code> gibi ayrıcalıklı kullanıcılar, izin bitlerine bakılmaksızın her dosyaya erişebilir. Özel bir durum olarak, çalıştırılabilir bir dosyayı ayrıcalıklı kullanıcının dahi çalıştırabilmesi için dosyanın çalıştırma biti etkin olmalıdır.
   </para>
  </sect1>
  <sect1 xml:id="glibc-Setting-Permissions">
   <title>Dosya İzinlerinin Atanması</title>
   <titleabbrev>İzinler yeni dosyalara nasıl atanır ve nasıl değiştirilir?</titleabbrev>
   <para>
    <indexterm linkend="glibc-cp"><primary>dosyalar</primary><secondary>oluşturma maskesi</secondary></indexterm>
    <indexterm linkend="glibc-cp"><primary>umask</primary></indexterm>
    Dosyaları oluşturmakta kullanılan <function>open</function> veya <function>mkdir</function> gibi ilkel işlevler yeni oluşturulacak dosyaya atanacak dosya izinlerini belirleyen bir <parameter>mode</parameter> (kip) bağımsız değişkeni alır. Bu kip kullanılmadan önce sürecin <firstterm>dosya oluşturma maskesi</firstterm> ya da <firstterm>umask</firstterm> ile değişikliğe uğratılır.
   </para>
   <para>
    Dosya oluşturma maskesinde izinleri ifade eden bitler yeni oluşturulan dosyalar için iptal edilecek izinleri belirtir. Örneğin, maskede diğerlerine bütün erişim izinleri verilmişse, diğerleri arasında yer alan hiçbir süreç bu dosyaya erişemeyecektir; dosyayı oluşturan işlevin <parameter>mode</parameter> bağımsız değişkeninde diğerlerine tüm erişim izinleri verilmiş olsa bile! Başka bir deyişle dosya oluşturma maskesi, verilmek istenen erişim izinlerinin tümleyenidir.
   </para>
   <para>
    Dosya oluşturan yazılımlar genellikle <parameter>mode</parameter> bağımsız değişkeninde herkese tüm izinleri veren bir değer belirtir. Normal bir dosya için bu herkese okuma ve yazma izinleri vermek şeklindedir. Daha sonra dosya oluşturulurken bu izinler kullanıcının dosya oluşturma maskesi kullanılarak sınırlanır.
   </para>
   <para>
    İsmini belirterek mevcut bir dosyanın izinlerini değiştirmek için  <function>chmod</function> işlevi kullanılır. Bu işlev belirtilen izinleri kullanırken dosya oluşturma maskesini yok sayar.
   </para>
   <para>
    Normal kullanımda, dosya oluşturma maskesi kullanıcının oturum açma kabuğu tarafından (<code>umask</code> kabuk komutu ile) ilklendirilir ve tüm alt süreçler tarafından miras alınır. Uygulama yazılımları dosya oluşturma maskesi için normalde endişelenmez. Özdevinimli oluşturulduğu kabul edilir.
   </para>
   <para>
    Yazılımın, bir dosyanın, dosya oluşturma maskesini yok sayarak erişim izinlerini belirlemesi istenirse bunun en kolay yolu dosyayı açtıktan sonra dosya oluşturma maskesini değiştirmek yerine, <function>fchmod</function> işlevini kullanmaktır. Aslında, dosya oluşturma maskesini değiştirme işlemi sadece kabuk tarafından yapılır. Kabuk bunu <function>umask</function> işlevini kullanarak yapar.
   </para>
   <para>
    Bu bölümdeki işlevler &sys-stat.h; başlık dosyasında bildirilmiştir.
    <indexterm linkend="glibc-pg"><primary>sys/stat.h</primary></indexterm>
   </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-umask"><primary>umask</primary></indexterm>
    <csproto type="işlev">
     <csname><type>mode_t</type><function>umask</function></csname>
     <csparam><type>mode_t</type><parameter>mask</parameter></csparam>
    </csproto>
    <header>&sys-stat.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     <code>umask</code> işlevi çağrıldığı sürecin dosya oluşturma maskesini <parameter>mask</parameter> yapar ve önceki dosya oluşturma maskesi ile döner.
    </para>
    <example>
     <para>
      Bu örnekte, dosya oluşturma maskesinin kalıcı olarak değiştirilmeksizin <code>umask</code> işlevi ile nasıl okunacağı gösterilmiştir:
     </para>
     <screen>mode_t
read_umask (void)
{
  mode_t mask = umask (0);
  umask (mask);
  return mask;
}
</screen>
    </example>
    <para>
     Ancak, yalnızca maske değeri okunmak isteniyorsa, <function>getumask</function> işlevini kullanmak daha iyidir, çünkü bu işlev evreseldir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-getumask"><primary>getumask</primary></indexterm>
    <csproto type="işlev">
     <csname><type>mode_t</type><function>getumask</function></csname>
     <csparam><void/></csparam>
    </csproto>
    <header>&sys-stat.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     Çağrıldığı sürecin dosya oluşturma maskesi ile döner. Bu işlev GNU oluşumudur ve yalnızca GNU/Hurd sistemlerinde kullanılabilir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-chmod"><primary>chmod</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>chmod</function></csname>
     <csparam><ptr>const&#160;char</ptr><parameter>filename</parameter></csparam>
     <csparam><type>mode_t</type><parameter>mode</parameter></csparam>
    </csproto>
    <header>&sys-stat.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     <code>chmod</code> işlevi, ismi <parameter>filename</parameter> ile belirtilen dosyanın erişim izinlerini <parameter>mode</parameter> ile belirtilen değere ayarlar.
    </para>
    <para>
     <parameter>filename</parameter> simgesel bağ ise, <code>chmod</code> bağın değil, bağın hedefindeki dosyanın izinlerini değiştirir.
    </para>
    <para>
     İşlev başarılı olduğunda <code>0</code>, aksi takdirde <code>-1</code> ile döner. <link linkend="glibc-File-Name-Errors">Dosya ismi hatalarına</link> ek olarak aşağıdaki <varname>errno</varname> hata durumları bu işlev için tanımlanmıştır:
    </para>
    <variablelist>
     <varlistentry>
      <term><code>ENOENT</code></term>
      <listitem>
       <para>
        Belirtilen dosya yok.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>EPERM</code></term>
      <listitem>
       <para>
        Bu sürecin, bu dosyanın erişim izinlerini değiştirme izni yok. Sadece dosyanın sahibi (sürecin etkin kullanıcı kimliğinden saptanır) ya da ayrıcalıklı kullanıcı onları değiştirebilir.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>EROFS</code></term>
      <listitem>
       <para>
        Dosya, salt-okunur bağlı bir dosya sisteminde.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>EFTYPE</code></term>
      <listitem>
       <para>
        <parameter>mode</parameter> bağımsız değişkeni <varname>S_ISVTX</varname> bitini (&quot;yapışkan bit&quot;) içeriyor ama ismi belirtilen dosya bir dizin değil. Bazı dosya sistemlerinde yapışkan bitin dosyalara verilmesine izin verilirken bazılarında da verilmez (sadece dizinlerde izin verilir).
       </para>
       <para>
        <varname>EFTYPE</varname> hatası sadece yapışkan bitin dizinler dışında anlamlı olmadığı dosya sistemlerinde alınır. Bu olduğu takdirde, yapışkan biti içermeyen bir <parameter>mode</parameter> değeri ile tekrar <code>chmod</code> çağrısı yapılmalıdır. Yapışkan bit ile ilgili daha ayrıntılı bilgi edinmek için bkz. <xref linkend="glibc-Permission-Bits"/>.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-fchmod"><primary>fchmod</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>fchmod</function></csname>
     <csparam><type>int</type><parameter>filedes</parameter></csparam>
     <csparam><type>mode_t</type><parameter>mode</parameter></csparam>
    </csproto>
    <header>&sys-stat.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     Bu işlev bağımsız değişken olarak dosya ismi yerine <link linkend="glibc-Low-Level-I-O">açık dosya tanıtıcısı</link> alması dışında <function>chmod</function> işlevinin benzeridir.
    </para>
    <para>
     İşlev başarılıysa <code>0</code> ile değilse <code>-1</code> ile döner.  Aşağıdaki <varname>errno</varname> hata durumları bu işlev için tanımlanmıştır:
    </para>
    <variablelist>
     <varlistentry>
      <term><code>EBADF</code></term>
      <listitem>
       <para>
        <parameter>filedes</parameter> bağımsız değişkeni geçerli bir dosya tanıtıcı değil.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>EINVAL</code></term>
      <listitem>
       <para>
        <parameter>filedes</parameter> bağımsız değişkeni bir ardışık süreç veya soket ya da erişim izinlerine konu olmayan bir şeye ait.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>EPERM</code></term>
      <listitem>
       <para>
        Bu sürecin, bu dosyanın erişim izinlerini değiştirme izni yok. Sadece dosyanın sahibi (sürecin etkin kullanıcı kimliğinden saptanır) ya da ayrıcalıklı kullanıcı onları değiştirebilir.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>EROFS</code></term>
      <listitem>
       <para>
        Dosya, salt-okunur bağlı bir dosya sisteminde.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </csynopsis>
  </sect1>

  <sect1 xml:id="glibc-Testing-File-Access">
   <title>Dosya Erişim İzinlerinin Sınanması</title>
   <titleabbrev>Sürecin bir dosyaya erişimi olup olmadığı nasıl saptanır?</titleabbrev>
   <para>
    <indexterm linkend="glibc-cp"><primary>dosyalar</primary><secondary>erişim izinleri</secondary><tertiary>sınanması</tertiary></indexterm>
    <indexterm linkend="glibc-cp"><primary>dosyalar</primary><secondary>erişim izinleri</secondary><tertiary>setuid yazılımlar</tertiary></indexterm>
    Bazı durumlarda kullanıcının erişim yetkisi olmayan bazı dosyalara ya da aygıtlara yazılım üzerinden erişebilmesi istenir. Olası bir çözüm yazılımın setuid bitini etkinleştirmektir. Böyle bir yazılım çalıştırılırsa, sürecin etkin kullanıcı kimliği yazılım dosyasının sahibi olarak değiştirilir. Böylece,  normalde sadece ayrıcalıklı kullanıcı tarafından erişilebilen <filename>/etc/passwd</filename> gibi dosyalara, yazılımın sahibi <code>root</code> yapılıp setuid biti de etkinleştirilerek, yazma erişimi sağlanabilir.
   </para>
   <para>
    Bunun yanında bir kullanıcının erişim izni olmayan dosyalara erişmesine izin vermeyecek bir düzenleme de düşünülebilir. Bu durumda yazılım, bir dosyayı okumadan ya da ona yazmadan önce <emphasis>kullanıcının</emphasis> gerekli erişim izinlerine sahip olup olmadığını sınamalıdır.
   </para>
   <para>
    Bunu yapmak için, sürecin etkin kullanıcı kimliğine değil gerçek kullanıcı kimliğine dayalı erişim izinlerini sınayan <function>access</function> işlevi kullanılır. (Setuid özelliği gerçek kullanıcı kimliğini değiştirmez, böylece yazılımı gerçekte kimin çalıştırdığı saptanır.)
   </para>
   <para>
    Bu erişimi sınamanın  daha kolay açıklanabilen bir yolu daha vardır, ama onun da kullanımı zordur. Bu yöntemde işlem, dosya kip bitlerini öğrenerek ve sistemin kendi erişim hesaplaması taklit edilerek yapılır. Bu yöntemin kullanılması pek tercih edilmez, çünkü birçok sistem ek erişim denetim özelliklerine sahiptir ve yazılımınız farklı sistemlerin farklı erişim özelliklerini taşınabilir olarak taklit etmek zorunda kalacaktır. <function>access</function> işlevi zaten bu işlemleri yapmaktadır.
   </para>
   <para>
    <function>access</function> işlevi <emphasis>sadece</emphasis> ve sadece setuid yazılımlarda kullanmak için değildir. Setuid olmayan bir yazılım daima gerçek kimlik yerine etkin kimliği kullanır.
   </para>
   <para>
    <indexterm linkend="glibc-pg"><primary>unistd.h</primary></indexterm>
    Bu bölümdeki simgeler &unistd.h; başlık dosyasında bildirilmiştir.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-access"><primary>access</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>access</function></csname>
     <csparam><ptr>const&#160;char</ptr><parameter>filename</parameter></csparam>
     <csparam><type>int</type><parameter>how</parameter></csparam>
    </csproto>
    <header>&sys-stat.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     <code>access</code> işlevi ismi <parameter>filename</parameter> ile belirtilen dosyaya <parameter>how</parameter> ile belirtilen yolla erişilip erişilemeyeceğini sınar. <parameter>how</parameter> bağımsız değişkeninde belirtilebilecek değer ya <varname>R_OK</varname>, <varname>W_OK</varname> ve <varname>X_OK</varname> seçeneklerinin bitsel VEYA'lanmışı ya da <varname>F_OK</varname> varlık sınaması olabilir.
    </para>
    <para>
     Bu işlev erişim izinlerini sınamak için sürecin etkin kullanıcı ve grup kimliklerini değil, gerçek kullanıcı ve grup kimliklerini kullanır. Sonuç olarak, bu işlev <code>setuid</code> veya <code>setgid</code> yazılımda (<xref linkend="glibc-How-Change-Persona"/>) kullanılıyorsa, işlev yazılımı gerçekte hangi kullanıcı çalıştırıyorsa o kullanıcıya göre bilgi verir.
    </para>
    <para>
     Erişime izin verilmişse işlev <code>0</code> ile, aksi takdirde <code>-1</code> ile döner.  (Başka bir deyişle, eğer istenen erişime <emphasis>izin verilmezse</emphasis>, <code>access</code> işlevi, doğrulama işlevi gibi doğru ile döner.)
    </para>
    <para>
     <link linkend="glibc-File-Name-Errors">Dosya ismi hatalarına</link> ek olarak aşağıdaki <varname>errno</varname> hata durumları bu işlev için tanımlanmıştır:
    </para>
    <variablelist>
     <varlistentry>
      <term><code>EACCES</code></term>
      <listitem>
       <para>
        <parameter>how</parameter> ile belirtilen erişime izin verilmiyor.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>ENOENT</code></term>
      <listitem>
       <para>
        Dosya yok.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>EROFS</code></term>
      <listitem>
       <para>
        Salt-okunur bağlı dosya sistemindeki dosya için yazma erişimi istendi.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </csynopsis>
   <para>
    <command>access</command> işlevinin <parameter>how</parameter> bağımsız değişkeninde kullanmak için tasarlanmış olan bu makrolar tamsayı sabitler olarak &unistd.h; başlık dosyasında tanımlanmıştır:
   </para>
   <csynopsis>
    <indexterm linkend="glibc-pg" xml:id="glibc-pg-R_OK"><primary>unistd.h</primary></indexterm>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-R_OK"><primary>R_OK</primary></indexterm>
    <csproto type="sabit">
     <csname><function>R_OK</function></csname>
    </csproto>
    <header>&unistd.h;</header>
    <para>
     Okuma izni için sınama seçeneği.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-W_OK"><primary>W_OK</primary></indexterm>
    <csproto type="sabit">
     <csname><function>W_OK</function></csname>
    </csproto>
    <header>&unistd.h;</header>
    <para>
     Yazma  izni için sınama seçeneği.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-X_OK"><primary>X_OK</primary></indexterm>
    <csproto type="sabit">
     <csname><function>X_OK</function></csname>
    </csproto>
    <header>&unistd.h;</header>
    <para>
     Çalıştırma/arama izni için sınama seçeneği.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-F_OK"><primary>F_OK</primary></indexterm>
    <csproto type="sabit">
     <csname><function>F_OK</function></csname>
    </csproto>
    <header>&unistd.h;</header>
    <para>
     Dosyanın var olup olmadığını sınama seçeneği.
    </para>
   </csynopsis>
  </sect1>

  <sect1 xml:id="glibc-File-Times">
   <title>Dosya Zamanları</title>
   <titleabbrev>Bir dosyanın zaman öznitelikleri hakkında.</titleabbrev>
   <para>
    <indexterm linkend="glibc-cp"><primary>dosyalar</primary><secondary>erişim zamanı</secondary></indexterm>
    <indexterm linkend="glibc-cp"><primary>dosyalar</primary><secondary>dosya içeriği</secondary><tertiary>değişiklik zamanı</tertiary></indexterm>
    <indexterm linkend="glibc-cp"><primary>dosyalar</primary><secondary>dosya öznitelikleri</secondary><tertiary>değişiklik zamanı</tertiary></indexterm>
    Her dosyanın kendisiyle ilgili üç zaman damgası vardır: erişim zamanı, değişiklik zamanı ve öznitelik değişiklik zamanı; bkz.  <xref linkend="glibc-File-Attributes"/>.
   </para>
   <para>
    <indexterm linkend="glibc-pg"><primary>time.h</primary></indexterm>
    Bu zamanların hepsi mutlak zaman biçiminde gösterilen <type>time_t</type> türünde nesnelerdir. Bu veri türü &time.h; başlık dosyasında tanımlanmıştır. Zaman değerlerinin gösterilmesi ve değiştirilmesi hakkında daha fazla bilgi için bkz. <xref linkend="glibc-Calendar-Time"/>.
   </para>
   <para>
    Bir dosyanın okunması erişim zamanını güncellerken, yazılması değişiklik zamanını günceller. Dosya oluşturulduğu zaman, üç zaman damgasına da dosyanın oluşturulduğu zaman değeri atanır. Ek olarak, yeni girdiyi içeren dizinin erişim ve değişiklik zamanı da güncellenir.
   </para>
   <para>
    <function>link</function> ile bir dosyaya yeni isim eklenmesi, isim eklenen dosyanın öznitelik değişiklik zamanını günceller ve bu yeni ismi içeren dizinin öznitelik ve içerik değişiklik zamanları da güncellenir. <function>unlink</function>, <function>remove</function> veya <function>rmdir</function> ile dosya isminin silinmesi de aynı alanları etkiler. Bir dosyanın isminin <function>rename</function> ile değiştirilmesi  sadece bu değişiklikten etkilenen iki dizinin içerik ve öznitelik değişiklik zamanlarını günceller, ismi değiştirilen dosyada zaman güncellemesi yapılmaz.
   </para>
   <para>
    Bir dosyanın özniteliklerinin değiştirilmesi (örn, <function>chmod</function> ile), öznitelik değişiklik zamanını günceller.
   </para>
   <para>
    Öznitelik değişiklik zamanı dışında bir dosyanın değişiklik zamanları <function>utime</function> işleviyle doğrudan değiştirilebilir. Bu oluşumu yazılımda kullanmak için yazılıma &utime.h; başlık dosyası dahil edilmelidir.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-tp" xml:id="glibc-tp-utimbuf"><primary sortas="utimbuf">struct&nbsp;utimbuf</primary></indexterm>
    <csproto type="veri türü">
     <csname><type>struct</type><function>utimbuf</function></csname>
    </csproto>
    <header>&utime.h;</header>
    <para>
     <code>struct&nbsp;utimbuf</code> yapısı bir dosya için erişim ve değişiklik zamanlarını belirtmek için <function>utime</function> işlevi ile kullanılır. Şu üyeleri içerir:
    </para>
    <glosslist>
     <glossentry>
      <glossterm>
       <type>time_t&nbsp;</type><structfield>actime</structfield>
      </glossterm>
      <glossdef>
       <para>
        Dosya için erişim zamanı.
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm>
       <type>time_t&nbsp;</type><structfield>modtime</structfield>
      </glossterm>
      <glossdef>
       <para>
        Dosya için değişiklik zamanı.
       </para>
      </glossdef>
     </glossentry>
    </glosslist>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-utime"><primary>utime</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>utime</function></csname>
     <csparam><ptr>const&#160;char</ptr><parameter>filename</parameter></csparam>
     <csparam><ptr>const&#160;struct&#160;utimbuf</ptr><parameter>times</parameter></csparam>
    </csproto>
    <header>&utime.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     Bu işlev, belirtilen <parameter>filename</parameter> dosyasının dosya zamanlarını değiştirir.
    </para>
    <para>
     <parameter>times</parameter> boş gösterici ise, dosyanın erişim ve değişiklik zamanları güncellenir. Aksi takdirde, zaman damgalarına <parameter>times</parameter> ile gösterilen <type>struct&#160;utimbuf</type> yapısının <structfield>actime</structfield> ve <structfield>modtime</structfield> üyelerindeki değerler atanır.
    </para>
    <para>
     Her durumda dosyanın öznitelik değişiklik zamanı da güncellenir (çünkü dosyanın zaman ile ilgili öznitelikleri değişmiştir).
    </para>
    <para>
     İşlev başarılı olduğunda <code>0</code>, aksi takdirde <code>-1</code> ile döner. <link linkend="glibc-File-Name-Errors">Dosya ismi hatalarına</link> ek olarak aşağıdaki <varname>errno</varname> hata durumları bu işlev için tanımlanmıştır:
    </para>
    <variablelist>
     <varlistentry>
      <term><code>EACCES</code></term>
      <listitem>
       <para>
        <parameter>times</parameter> bağımsız değişkeninde boş gösterici aktarıldığı durumda bir izin sorunu var. Dosya zaman damgalarını güncelleyebilmek için ya dosyanın sahibi ya da ayrıcalıklı kullanıcı olmak gerekir.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>ENOENT</code></term>
      <listitem>
       <para>
        Dosya yok.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>EPERM</code></term>
      <listitem>
       <para>
        <parameter>times</parameter> bağımsız değişkeni boş gösterci değilse  ya dosyanın sahibi ya da ayrıcalıklı kullanıcı olmak gerekir.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>EROFS</code></term>
      <listitem>
       <para>
        Dosya salt-okunur bağlı dosya sisteminde.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </csynopsis>
   <para>
    Her üç zaman damgasınında çözünürlüğü artıran mikrosaniyelik bir parçası vardır. Bu alanlar 0 ile 999,999 mikrosaniye arasında değer alabilen üç alanla ifade edilir: <code>st_atime_usec</code>, <code>st_mtime_usec</code> ve <code>st_ctime_usec</code>.  Bu alanlar <type>struct&#160;timeval</type> yapısının <structfield>tv_usec</structfield> üyesine karşılıktır; bkz. <xref linkend="glibc-Time-Types"/>.
   </para>
   <para>
    <function>utimes</function> işlevi <function>utime</function> işlevi gibidir, ancak dosya zamanlarının ondalık kısımlarının da belirtilebilmesini sağlar. <function>utimes</function> işlevi &sys-time.h; başlık dosyasında bildirilmiştir.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-pg" xml:id="glibc-pg-utimes"><primary>sys/time.h</primary></indexterm>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-utimes"><primary>utimes</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>utimes</function></csname>
     <csparam><ptr>const&#160;char</ptr><parameter>filename</parameter></csparam>
     <csparam><type>const&#160;struct&#160;timeval</type><parameter>tvp[2]</parameter></csparam>
    </csproto>
    <header>&sys-time.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     Bu işlev ismi <parameter>filename</parameter> ile belirtilen dosya içn erişim ve değişiklik zamanlarını değiştirir. Dosyaya erişim zamanı <parameter>tvp[0]</parameter> ile ve dosya değişiklik zamanı <parameter>tvp[1]</parameter> ile belirtilir. <parameter>tvp</parameter> bağımsız değişkeninde boş gösterici belirtilirse <function>utime</function> işlevi gibi dosyanın erişim ve değişiklik zamanlarını günceller. Bu işlev BSD'den gelmektedir.
    </para>
    <para>
     İşlevin dönüş değerleri ve hata durumları  <function>utime</function> işlevi ile aynıdır.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-lutimes"><primary>lutimes</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>lutimes</function></csname>
     <csparam><ptr>const&#160;char</ptr><parameter>filename</parameter></csparam>
     <csparam><type>const&#160;struct&#160;timeval</type><parameter>tvp[2]</parameter></csparam>
    </csproto>
    <header>&sys-time.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     Bu işlev <function>utimes</function> gibi olmakla birlikte simgesel bağları izlemez. <function>utimes</function> işlevi bir simgesel bağın hedefindeki dosyanın erişim ve değişiklik zamanlarını değiştirdiği halde, <code>lutimes</code> işlevi (<function>lstat</function> gibi; <xref linkend="glibc-Symbolic-Links"/>) simgesel bağ dosyasının kendi erişim ve değişiklik zamanlarını değiştirir. Bu işlev BSD'den gelmektedir ve tüm platformlarda desteklenmemektedir (desteklenmiyorsa, işlev <varname>ENOSYS</varname> hatasıyla başarısız olur).
    </para>
    <para>
     İşlevin dönüş değerleri ve hata durumları  <function>utime</function> işlevi ile aynıdır.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-futimes"><primary>futimes</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>futimes</function></csname>
     <csparam><type>int</type><parameter>fd</parameter></csparam>
     <csparam><type>const&#160;struct&#160;timeval</type><parameter>tvp[2]</parameter></csparam>
    </csproto>
    <header>&sys-time.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     Bu işlev <function>utimes</function> gibidir, ancak bağımsız değişken olarak dosya ismi yerine bir <link linkend="glibc-Low-Level-I-O">açık dosya tanıtıcısı</link> alır. Bu işlev BSD'den gelmektedir ve tüm platformlarda desteklenmemektedir (desteklenmiyorsa, işlev <varname>ENOSYS</varname> hatasıyla başarısız olur).
    </para>
    <para>
     <function>utimes</function> gibi,<code>futimes</code> işlevi de başarılı olduğunda <code>0</code> ile aksi takdirde <code>-1</code> ile döner. Aşağıdaki <varname>errno</varname> hata durumları bu işlev için tanımlanmıştır:
    </para>
    <variablelist>
     <varlistentry>
      <term><code>EACCES</code></term>
      <listitem>
       <para>
        <parameter>times</parameter> bağımsız değişkeninde boş gösterici aktarıldığı durumda bir izin sorunu var. Dosya zaman damgalarını güncelleyebilmek için ya dosyanın sahibi ya da ayrıcalıklı kullanıcı olmak gerekir.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>EBADF</code></term>
      <listitem>
       <para>
        <parameter>fd</parameter> bağımsız değişkeni geçerli bir dosya tanıtıcı değil.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>EPERM</code></term>
      <listitem>
       <para>
        <parameter>times</parameter> bağımsız değişkeni boş gösterci değilse  ya dosyanın sahibi ya da ayrıcalıklı kullanıcı olmak gerekir.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>EROFS</code></term>
      <listitem>
       <para>
        Dosya salt-okunur bağlı dosya sisteminde.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </csynopsis>
  </sect1>

  <sect1 xml:id="glibc-File-Size">
   <title>Dosya Boyu</title>
   <titleabbrev>Dosya boyu elle nasıl değiştirilir?</titleabbrev>
   <para>
    Normalde dosya boyu özdevinimli olarak belirlenir. Bir dosya <code>0</code> boyda başlar ve veri yazıldıkça özdevinimli olarak uzar. Ayrıca, bir <function>open</function> ya da <function>fopen</function> çağrısı ile de bir dosyanın içeriğini silmek ve boş duruma getirmek mümkündür.
   </para>
   <para>
    Yine de, kimi zaman bir dosyanın boyunu küçültmek gerekebilir. Bu işlem <function>truncate</function> ve <function>ftruncate</function> işlevleri ile yapılır. Bunlar BSD Unix'den gelir. <function>ftruncate</function> işlevi daha sonra POSIX.1'e eklenmiştir.
   </para>
   <para>
    Bazı sistemler bu işlevlerle bir dosyayı uzatmaya da (delikler oluşturarak) izin verir. Dosyalar özdevinimli uzatılamadığında <link linkend="glibc-Memory-mapped-I-O">bellek eşlemli G/Ç</link> kullanılırken yararlı olur. Ancak, taşınabilir değildir ve <function>mmap</function> dosyaların eşlenmesine izin veriyorsa (yani, <varname>_POSIX_MAPPED_FILES</varname> tanımlıysa) gerçeklenmelidir.
   </para>
   <para>
    Bu işlevlerin normal dosyalar dışında kullanılması <emphasis>tanımlanmamış</emphasis> sonuçlara yol açabilir. Çoğu sistemde böyle bir çağrı, aslında hiçbir işlem yapmakszın başarılı görünecektir.
   </para>
   <csynopsis>
    <indexterm xml:id="glibc-cp-truncate" linkend="glibc-cp"><primary>dosyalar</primary><secondary>küçültülmesi</secondary></indexterm>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-truncate"><primary>truncate</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>truncate</function></csname>
     <csparam><ptr>const&#160;char</ptr><parameter>filename</parameter></csparam>
     <csparam><type>off_t</type><parameter>length</parameter></csparam>
    </csproto>
    <header>&unistd.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     <code>truncate</code> işlevi, <parameter>filename</parameter> ile belirtilen dosyanın uzunluğunu <parameter>length</parameter> yapar. <parameter>length</parameter> önceki uzunluktan küçükse dosyanın sonundaki veri kaybedilir. Bu işlemin uygulanabilmesi için kullanıcının dosyaya yazma izni olmalıdır.
    </para>
    <para>
     <parameter>length</parameter> önceki uzunluktan daha büyükse dosyanın sonuna delikler eklenir. Ancak, bazı sistemler bu işlemi desteklemez ve dosya değişmeden kalır.
    </para>
    <para>
     Kaynakların <code>_FILE_OFFSET_BITS == 64</code> ile derlendiği 32 bitlik bir sistemde bu işlev aslında <function>truncate64</function> işlevidir ve <type>off_t</type> türü 2^63 bayt uzunluğa kadar dosyaları mümkün kılan 64 bitlik bir türdür.
    </para>
    <para>
     İşlev başarılı olduğunda <code>0</code>, aksi takdirde <code>-1</code> ile döner. <link linkend="glibc-File-Name-Errors">Dosya ismi hatalarına</link> ek olarak aşağıdaki <varname>errno</varname> hata durumları bu işlev için tanımlanmıştır:
    </para>
    <variablelist>
     <varlistentry>
      <term><code>EACCES</code></term>
      <listitem>
       <para>
        Dosya ya bir dizin ya da yazılabilir değil.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>EINVAL</code></term>
      <listitem>
       <para>
        <parameter>length</parameter> negatif.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>EFBIG</code></term>
      <listitem>
       <para>
        Dosya boyu, işletim sisteminin sınırlarından fazlasına genişletiliyor.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>EIO</code></term>
      <listitem>
       <para>
        Donamım G/Ç hatası oluştu.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>EPERM</code></term>
      <listitem>
       <para>
        Dosya ya sona eklemeli ya da değiştirilemez türde.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>EINTR</code></term>
      <listitem>
       <para>
        İşlem bir sinyal ile engellendi.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-truncate64"><primary>truncate64</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>truncate64</function></csname>
     <csparam><ptr>const&#160;char</ptr><parameter>filename</parameter></csparam>
     <csparam><type>off64_t</type><parameter>length</parameter></csparam>
    </csproto>
    <header>&unistd.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     Bu işlev <function>truncate</function> işlevinin benzeridir.  Farkı, <parameter>length</parameter> bağımsız değişkeninin 32 bitlik makinelerde bile 64 bitlik genişlikte olmasıdır. Böylece 2^63 bayta kadar dosya uzunlukları belirtilebilir.
    </para>
    <para>
     Kaynakların <code>_FILE_OFFSET_BITS == 64</code> ile derlendiği 32 bitlik sistemlerde bu işlev <function>truncate</function> ismiyle bulunur ve eski gerçekleme tamamen LFS'ye uygun olarak değiştirilir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-ftruncate"><primary>ftruncate</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>ftruncate</function></csname>
     <csparam><type>int</type><parameter>fd</parameter></csparam>
     <csparam><type>off_t</type><parameter>length</parameter></csparam>
    </csproto>
    <header>&unistd.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     Bu işlev <function>truncate</function> gibidir, ancak açık dosya tanıtıcısı ile çalışır. Dosya yazma amacıyla açılmış olmalıdır.
    </para>
    <para>
     POSIX standardı, dosyanın yeni <parameter>length</parameter> değerinin özgün dosya boyundan daha büyük olduğu durumda ne yapılacağını gerçeklemeye bırakmıştır. <code>ftruncate</code> işlevi ya dosyayı hiçbir şey yapmadan bırakır ya da istenen boya artırır. İkinci durumda uzatılan bölge sıfırlarla doldurulur. <code>ftruncate</code> işlevi ile dosya boyunun artırılması pek güvenilir olmasa da eğer uzatılabiliyorsa bu olası en hızlı yöntemdir. Bu işlev ayrıca eğer sistem tarafından gerçeklenmişse POSIX paylaşımlı bellek bölütleri üzerinde de çalışır.
    </para>
    <para>
     <code>ftruncate</code> işlevi özellikle <function>mmap</function> ile birlikte kullanıldığında yararlıdır. Dosya ile eşlenen bellek bölgeleri sabit uzunlukta olduğundan son eşlenen sayfaya daha fazla bilgi yazarak dosya boyu büyütülemez. Dosya boyunu büyütmek için dosya yeni boyutla yeniden belleğe eşlenmelidir. Bunun nasıl yapıldığı aşağıda bir örnekle gösterilmiştir.
    </para>
    <para>
     Kaynakların <code>_FILE_OFFSET_BITS == 64</code> ile derlendiği 32 bitlik sistemlerde bu işlev aslında <function>ftruncate64</function> işlevidir ve <type>off_t</type> türü 2^63 bayt uzunluğa kadar dosyaları mümkün kılan 64 bitlik bir türdür.
    </para>
    <para>
     İşlev başarılı olduğunda <code>0</code>, aksi takdirde <code>-1</code> ile döner. Aşağıdaki <varname>errno</varname> hata durumları bu işlev için tanımlanmıştır:
    </para>
    <variablelist>
     <varlistentry>
      <term><code>EBADF</code></term>
      <listitem>
       <para>
        <parameter>fd</parameter> açık bir dosya ile ilgili değil.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>EACCES</code></term>
      <listitem>
       <para>
        <parameter>fd</parameter> ya bir dizin ya da yazımak için açılmamış.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>EINVAL</code></term>
      <listitem>
       <para>
        <parameter>length</parameter> negatif.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>EFBIG</code></term>
      <listitem>
       <para>
        Dosya boyu, işletim sisteminin sınırlarından fazlasına genişletiliyor.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>EIO</code></term>
      <listitem>
       <para>
        Donamım G/Ç hatası oluştu.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>EPERM</code></term>
      <listitem>
       <para>
        Dosya ya sona eklemeli ya da değiştirilemez türde.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>EINTR</code></term>
      <listitem>
       <para>
        İşlem bir sinyal ile engellendi.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-ftruncate64"><primary>ftruncate64</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>ftruncate64</function></csname>
     <csparam><type>int</type><parameter>fd</parameter></csparam>
     <csparam><type>off64_t</type><parameter>length</parameter></csparam>
    </csproto>
    <header>&unistd.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     Bu işlev <function>ftruncate</function> işlevinin benzeridir.  Farkı, <varname>uzunluk</varname> bağımsız değişkeninin 32 bitlik makinelerde bile 64 bitlik genişlikte olmasıdır. Böylece 2^63 bayta kadar dosya uzunlukları belirtilebilir.
    </para>
    <para>
     Kaynakların <code>_FILE_OFFSET_BITS == 64</code> ile derlendiği 32 bitlik sistemlerde bu işlev <function>ftruncate</function> ismiyle bulunur ve eski gerçekleme tamamen LFS'ye uygun olarak değiştirilir.
    </para>
   </csynopsis>
   <example>
    <para>
     Yukarıda bahsedildiği gibi burada <function>ftruncate</function> işlevinin <function>mmap</function> ile birlikte kullanılışına küçük bir örnek vardır:
    </para>
    <screen>int fd;
void *start;
size_t len;

int
add (off_t at, void *block, size_t size)
{
  if (at + size &gt; len)
    {
    /* <replaceable>Dosyayı yeniden boyutlandır ve yeniden eşle.</replaceable>  */
      size_t ps = sysconf (_SC_PAGESIZE);
      size_t ns = (at + size + ps - 1) &amp; ~(ps - 1);
      void *np;
      if (ftruncate (fd, ns) &lt; 0)
        return -1;
      np = mmap (NULL, ns, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
      if (np == MAP_FAILED)
        return -1;
      start = np;
      len = ns;
    }
  memcpy ((char *) start + at, block, size);
  return 0;
}
</screen>
    <para>
     <code>add</code> işlevi dosyada keyfi bir konuma bellek bloğunu yazar. Eğer dosyanın mevcut uzunluğu yetersizse dosya uzatılır. Uzatmanın sayfa sayısına yuvarlanacağına dikkat edilmelidir. Bu <function>mmap</function> işlevinin bir gereksinimidir. Yazılım gerçek boyutu daima izler ve işlem bittiğinde son bir <function>ftruncate</function> çağrısıyla dosyanın gerçek boyunu belirler.
    </para>
   </example>
  </sect1>

  <sect1 xml:id="glibc-Storage-Allocation">
   <title>Depolama Alanının Tahsisi</title>
   <titleabbrev>Dosyaların yedeklenmesi için depolama tahsisi.</titleabbrev>
   <para>
    Çoğu dosya sistemi, büyük dosyaları bitişik olmayan alanlar halinde tahsis etmeyi destekler: dosya, sırayla tahis edilen parçalara bölünür, ancak parçaların kendileri de diske dağılabilir. Dosya sistemleri genellikle başarımı düşürdüğü için bu tür parçalanmalardan kaçınmaya çalışır, ancak bir dosyanın boyutu kademeli olarak artarsa, parçalamaktan başka seçenek olmayabilir. Ek olarak, birçok dosya sistemi delikli seyrek dosyaları da destekler: dosya sistemi tarafından depolama alanı tahsis edilmemiş boş baytlar içeren bölgeler. Eninde sonunda, deliklerin üzerine veriler yazıldığında, parçalanma ortaya çıkabilir.
   </para>
   <para>
    Dosyanın henüz yazılmamış bölümleri için doğrudan depolama alanı tahsisi, sistemin parçalanmayı önlemesine yardımcı olabilir. Ek olarak, depolama ön tahsisi başarısız olursa, disk dolma hatasını erkenden, genellikle tüm diski doldurmadan bildirmek mümkündür. Ancak yinelenenleri kaldırma, yazma sırasında kopyalama ve dosya sıkıştırma nedeniyle, bu tür bir ön ayırma disk alanı yetersiz hatasının daha sonra oluşmasını güvenilir bir şekilde engelleyemeyebilir. Yazma hatalarının denetlenmesi hala gereklidir ve <function>mmap</function> ile oluşturulan bellek eşlemli bölgelere yazma işlemleri yine de <varname>SIGBUS</varname> ile sonuçlanabilir.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-posix_fallocate"><primary>posix_fallocate</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>posix_fallocate</function></csname>
     <csparam><type>int</type><parameter>fd</parameter></csparam>
     <csparam><type>off_t</type><parameter>offset</parameter></csparam>
     <csparam><type>off_t</type><parameter>length</parameter></csparam>
    </csproto>
    <header>&unistd.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     <parameter>fd</parameter> tanıtıcısı için dosyada <parameter>offset</parameter> baytta başlayan <parameter>length</parameter> baytlık bölge için yedekleme deposu tahsis eder. Gerekirse dosya uzunluğu '<parameter>length</parameter> + <parameter>offset</parameter>' bayta artırılır.
    </para>
    <para>
     <parameter>fd</parameter>, yazmak için açılmış normal bir dosyanın tanıtıcısı olmalıdır, yoksa <varname>EBADF</varname> döndürülür. Tahsis isteğini yerine getirmek için yeterli disk alanı yoksa, <varname>ENOSPC</varname> döndürülür.
    </para>
    <note>
     <para>
      <function>fallocate</function> kullanılabilir değilse (dosya sistemi desteklemediği için), işlevi <code>posix_fallocate</code> taklit eder. Bunun sakıncaları:
     </para>
     <itemizedlist>
      <listitem>
       <para>
        Çok verimsizdir, çünkü istenen aralıktaki tüm dosya sistemi dilimlerinin incelenmesi (daha önce tahsis edilmiş olsalar bile) ve belki de yeniden yazılması gerekir. Buna karşılık, uygun <function>fallocate</function> desteğiyle (aşağıya bakın), dosya sistemi dahili dosya tahsis veri yapılarını inceleyebilir ve delikleri doğrudan, hatta belki de diskte önceden tahsis edilmiş ancak yazılmamış kısımları kullanarak ortadan kaldırabilir.
       </para>
      </listitem>
      <listitem>
       <para>
        Tahsis edilecek alandaki dosyayı başka bir evre veya süreç değiştirirse,  yarış durumu ortaya çıkar. Veri içeren baytların üzerine boş baytlar yazılabilir.
       </para>
      </listitem>
      <listitem>
       <para>
        <parameter>fd</parameter>, <varname>O_WRONLY</varname> seçeneğiyle açılmışsa, işlev  <varname>errno</varname> değeri <varname>EBADF</varname> ile başarısız olur.
       </para>
      </listitem>
      <listitem>
       <para>
        <parameter>fd</parameter>, <varname>O_APPEND</varname> seçeneğiyle açılmışsa, işlev  <varname>errno</varname> değeri <varname>EBADF</varname> ile başarısız olur.
       </para>
      </listitem>
      <listitem>
       <para>
        <parameter>length</parameter> sıfırsa, dosya sistemi gerekli dilimleri tahsis etmeden dosya boyutunu istendiği gibi artırmak için <function>ftruncate</function> kullanılır. Dosyanın eşzamanlı olarak uzatılması durumunda, <function>ftruncate</function> işlevinin dosyayı rastlantısal olarak küçültebileceği bir yarış durumu ortaya çıkar.
       </para>
      </listitem>
     </itemizedlist>
    </note>
    <para>
     Linux'ta, bir uygulama öykünmeden fayda sağlamıyorsa veya öykünme içsel yarış koşullarından dolayı zararlıysa, uygulama, sıfır değerli <parameter>mode</parameter> bağımsız değişkeniyle Linux'a özgü <function>fallocate</function> işlevini kullanabilir. <function>fallocate</function> işlevi için, dosya sistemi alan tahsisini desteklemiyorsa, &glibc; tahsis öykünmesini uygulamaz. Bunun yerine, çağrıcıya <varname>EOPNOTSUPP</varname> hatası döndürülür.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-posix_fallocate64"><primary>posix_fallocate64</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>posix_fallocate64</function></csname>
     <csparam><type>int</type><parameter>fd</parameter></csparam>
     <csparam><type>off64_t</type><parameter>offset</parameter></csparam>
     <csparam><type>off64_t</type><parameter>length</parameter></csparam>
    </csproto>
    <header>&unistd.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     Tüm platformlarda 64 bitlik konumlar kabul etmesi dışında <code>posix_fallocate</code> işleviyle aynıdır.
    </para>
   </csynopsis>
  </sect1>
 </chapter>

 <chapter xml:id="glibc-Making-Special-Files">
  <title>Özel Dosyaların Oluşturulması</title>
  <titleabbrev>Özel dosyalar (aygıt dosyaları) nasıl oluşturulur?</titleabbrev>
  <para>
   <indexterm linkend="glibc-cp"><primary>dosyalar</primary><secondary>özel dosyalar</secondary><tertiary>oluşturulması</tertiary></indexterm>
   <indexterm linkend="glibc-cp"><primary>özel dosyalar</primary></indexterm>
   <function>mknod</function> işlevi aygıt dosyaları gibi özel dosyaları oluşturmakta kullanılan bir ilkeldir. &glibc; bu işlevi BSD ile uyumluluk için içerir.
  </para>
  <para>
   <function>mknod</function> işlevi &sys-stat.h; başlık dosyasında bildirilmiştir.
   <indexterm linkend="glibc-pg"><primary>sys/stat.h</primary></indexterm>
  </para>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-mknod"><primary>mknod</primary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>mknod</function></csname>
    <csparam><ptr>const&#160;char</ptr><parameter>filename</parameter></csparam>
    <csparam><type>mode_t</type><parameter>mode</parameter></csparam>
    <csparam><type>dev_t</type><parameter>dev</parameter></csparam>
   </csproto>
   <header>&sys-stat.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <code>mknod</code> işlevi <parameter>filename</parameter> ile belirtilen özel dosyayı oluşturur. <parameter>mode</parameter> bağımsız değişkeni ile özel dosyalarla ilgili çeşitli bitleri içeren kip belirtilir. Örneğin karakter aygıtı dosyaları için <varname>S_IFCHR</varname>, blok aygıtı dosyaları için <varname>S_IFBLK</varname> gibi. Bkz. <xref linkend="glibc-Testing-File-Type"/>.
   </para>
   <para>
    <parameter>dev</parameter> bağımsız değişkeni ile dosyanın ilişkilendirileceği aygıt belirtilir. En doğru yorumu, oluşturulan özel dosyanın çeşidine bağlıdır.
   </para>
   <para>
    İşlev başarılı olduğunda <code>0</code>, aksi takdirde <code>-1</code> ile döner. <link linkend="glibc-File-Name-Errors">Dosya ismi hatalarına</link> ek olarak aşağıdaki <varname>errno</varname> hata durumları bu işlev için tanımlanmıştır:
   </para>
   <variablelist>
    <varlistentry>
     <term><code>EPERM</code></term>
     <listitem>
      <para>
       İşlevi çağıran süreç ayrıcalıklı değil. Sadece ayrıcalıklı kullanıcı özel dosyaları oluşturabilir.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>ENOSPC</code></term>
     <listitem>
      <para>
       Yeni dosyayı içerecek dizin ya da dosya sistemi dolu ve genişletilemiyor.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>EROFS</code></term>
     <listitem>
      <para>
       Yeni dosyayı içerecek dizin salt-okunur bağlı bir dosya sistemi üzerinde.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>EEXIST</code></term>
     <listitem>
      <para>
       Zaten <parameter>filename</parameter> isminde bir dosya var.  Bu özel dosya değiştirilmek isteniyorsa önce eskisi silinmelidir.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </csynopsis>
 </chapter>

 <chapter xml:id="glibc-Temporary-Files">
  <title>Geçici Dosyalar</title>
  <titleabbrev>Geçici dosyaların isimlendirilmesi ve oluşturulması.</titleabbrev>
  <para>
   Yazılımda geçici bir dosya kullanmak gerekiyorsa, dosyayı açmak için  <function>tmpfile</function> işlevi ya da geçici dosyaya bir isim verip sonradan <function>fopen</function> ile açmak isteniyorsa <function>tmpnam</function> (daha iyisi: <function>tmpnam_r</function>) işlevi kullanılabilir.
  </para>
  <para>
   <function>tempnam</function> işlevi <function>tmpnam</function> gibidir, ancak geçici dosyaların gideceği dizin belirtilebilir, bunun dışında dosya isimlendirmesi aynı yöntemle yapılır. Çok evreli yazılımlar açısından <function>tempnam</function> işlevinin evresel olması ama <function>tmpnam</function> işlevinin duruk bir tampona gösterici döndürmesi nedeniyle evresel olmaması önemli bir farktır.
  </para>
  <para>
   Bu oluşumlar &stdio.h; başlık dosyasında bildirilmiştir.
   <indexterm linkend="glibc-pg"><primary>stdio.h</primary></indexterm>
  </para>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-tmpfile"><primary>tmpfile</primary></indexterm>
   <csproto type="işlev">
    <csname><ptr>FILE</ptr><function>tmpfile</function></csname>
    <csparam><void/></csparam>
   </csproto>
   <header>&stdio.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&asunsafe; &heap; &lock;</concept>
    <concept>&acunsafe; &mem; &fd; &lock;</concept>
   </conceptlist>
   <para>
    Bu işlev, <code>"wb+"</code> kipinde (güncelleme kipi) <function>fopen</function> çağrısı ile açılmış gibi geçici ikil bir dosya oluşturur. Bu dosya kapatıldığında ya da yazılım sonlandığında dosya özdevinimli olarak silinir. (Bazı ISO C sistemlerinde eğer yazılım anormal şekilde sonlanırsa dosya silinmeyebilir.)
   </para>
   <para>
    Bu işlev evreseldir.
   </para>
   <para>
    Kaynakların <code>_FILE_OFFSET_BITS == 64</code> ile derlendiği 32 bitlik sistemlerde bu işlev aslında <function>tmpfile64</function> işlevidir, yani LFS arayüzü eski arayüzün yerine geçer.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-tmpfile64"><primary>tmpfile64</primary></indexterm>
   <csproto type="işlev">
    <csname><ptr>FILE</ptr><function>tmpfile64</function></csname>
    <csparam><void/></csparam>
   </csproto>
   <header>&stdio.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&asunsafe; &heap; &lock;</concept>
    <concept>&acunsafe; &mem; &fd; &lock;</concept>
   </conceptlist>
   <para>
    Bu işlev <function>tmpfile</function> işlevine benzer, ancak dönen akım 32 bitlik makinelerde 2^31 bayttan daha büyük dosyalar için kullanılabilir.
   </para>
   <para>
    Dönüş türünün hala <type>FILE *</type> olduğuna, LFS arayüzüne özel bir <type>FILE</type> türünün olmayışına dikkat edilmelidir.
   </para>
   <para>
    Kaynakların <code>_FILE_OFFSET_BITS == 64</code> ile derlendiği 32 bitlik sistemlerde bu işlev <function>tmpfile</function> ismiyle bulunur ve eski gerçekleme tamamen LFS'ye uygun olarak değiştirilir.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-tmpnam"><primary>tmpnam</primary></indexterm>
   <csproto type="işlev">
    <csname><ptr>char</ptr><function>tmpnam</function></csname>
    <csparam><ptr>char</ptr><parameter>result</parameter></csparam>
   </csproto>
   <header>&stdio.h;</header>
   <conceptlist>
    <concept>&mtsafe; &race;<code linkend="glibc-safety-identifier">:tmpnam</code><code linkend="glibc-safety-condition">/!result</code></concept>
    <concept>&asunsafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    Bu işlev herhangi bir mevcut dosyaya ait olmayan geçerli bir dosya ismi oluşturur ve bunu döndürür. <parameter>result</parameter> bağımsız değişkeni boş gösterici ise dönüş değeri dahili duruk bir dizgeye gösterici olup, işlevin daha sonraki çağrıları ile üzerine yazılabilir, dolayısıyla bu durumda işlev evresel olmaz. Aksi takdirde, <parameter>result</parameter> bağımsız değişkeni en az <code>L_tmpnam</code> karakterlik bir diziye gösterici olmalıdır. Bu durumda sonuç bu diziye yazılacak ve işlev evresel olacaktır.
   </para>
   <para>
    Önceden oluşturulmuş dosyaları silmeden defalarca <code>tmpnam</code> çağrısı yapılırsa işlevin başarısız olma olasılığı vardır. Bu, geçici dosya isimlerine ayrılan uzunluğun sınırlı olması nedeniyle işlevin sadece sonlu sayıda farklı isme imkan vermesindendir. İşlev başarısız olursa boş gösterici döner.
   </para>
   <warning>
    <para>
     Dosya isminin oluşturulması sırasında, başka bir süreç daha <code>tmpnam</code> kullanarak aynı isimde bir dosya oluşturursa, bu güvenlik açığına yol açabilir. Gerçeklenim tahmini zor isimler üretir, fakat yine de dosyayı açarken <varname>O_EXCL</varname> seçeneği kullanılmalıdır. Bu sorunla karşılaşmamak için en iyi yöntem <function>tmpfile</function> veya <function>mkstemp</function> kullanmaktır.
    </para>
   </warning>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-tmpnam_r"><primary>tmpnam_r</primary></indexterm>
   <csproto type="işlev">
    <csname><ptr>char</ptr><function>tmpnam_r</function></csname>
    <csparam><ptr>char</ptr><parameter>result</parameter></csparam>
   </csproto>
   <header>&stdio.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    Bu işlev, <parameter>result</parameter> boş gösterici ise boş gösterici döndürmesi dışında <function>tmpnam</function> işlevininin hemen hemen aynısıdır.
   </para>
   <para>
    <function>tmpnam</function> işlevinin evresel olmayan kullanımına karşı bir önlem içermesiyle bu işlevin evresel olması garanti edilmiştir.
   </para>
   <warning>
    <para>
     Bu işlev de <function>tmpnam</function> işlevinin oluşturabildiği güvenlik açığı sorunundan muzdariptir.
    </para>
   </warning>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-vr" xml:id="glibc-vr-L_tmpnam"><primary>L_tmpnam</primary></indexterm>
   <csproto type="makro">
    <csname><type>int</type><function>L_tmpnam</function></csname>
   </csproto>
   <header>&stdio.h;</header>
   <para>
    Bu makronun değeri <function>tmpnam</function> işlevi ile üretilen dosya ismini tutacak yeterli büyüklükteki dizge için en küçük uzunluğu veren bir tamsayı sabit ifadesidir.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-vr" xml:id="glibc-vr-TMP_MAX"><primary>TMP_MAX</primary></indexterm>
   <csproto type="makro">
    <csname><type>int</type><function>TMP_MAX</function></csname>
   </csproto>
   <header>&stdio.h;</header>
   <para>
    <code>TMP_MAX</code> makrosunun değeri <function>tmpnam</function> işlevi ile oluşturulabilecek geçici dosya isimlerinin sayısının alt sınırıdır. <function>tmpnam</function> işlevi, çok fazla geçici dosya açıldığını belirterek başarısız olmadan en fazla bu kadar defa çağrılabilir.
   </para>
   <para>
    &glibc; ile çok büyük sayıda geçici dosya ismi oluşturulabilir. Eğer bu isimlerle gerçekten dosya oluşturmaya çalışılırsa daha isimler tükenmeden disk üzerinde yer kalmayabilir. Diğer sistemlerde sabit ve daha az sayıda geçici dosya ismi oluşturulabilir ve bu sınır asla <command>25</command>'i aşmaz.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-tempnam"><primary>tempnam</primary></indexterm>
   <csproto type="işlev">
    <csname><ptr>char</ptr><function>tempnam</function></csname>
    <csparam><ptr>const&#160;char</ptr><parameter>dir</parameter></csparam>
    <csparam><ptr>const&#160;char</ptr><parameter>prefix</parameter></csparam>
   </csproto>
   <header>&stdio.h;</header>
   <conceptlist>
    <concept>&mtsafe; &env;</concept>
    <concept>&asunsafe; &heap;</concept>
    <concept>&acunsafe; &mem;</concept>
   </conceptlist>
   <para>
    Bu işlev tamamen eşsiz geçici dosya ismi oluşturur. <parameter>prefix</parameter> boş gösterici değilse, bu dizgenin ilk beş karakteri dosya isminde önek olarak kullanılır. İşlevin dönüş değeri <function>malloc</function> ile ayrılmış bir dizgedir. Dolayısıyla tahsis edilen alan, artık kullanılmayacaksa <function>free</function> ile serbest bırakılmalıdır.
   </para>
   <para>
    Dönen dizge özdevimli olarak ayrıldığından bu işlev evreseldir.
   </para>
   <para>
    Geçici dosya isminin dizin öneki aşağıdaki listedeki maddeler sırayla uygulanarak saptanır. Dizin mevcut ve yazılabilir olmalıdır.
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-TMPDIR"><primary>TMPDIR</primary></indexterm>
   </para>
   <itemizedlist>
    <listitem>
     <para>
      Eğer tanımlıysa, <varname>TMPDIR</varname> ortam değişkeni. Güvenlik kaygılarıyla bu sadece yazılım SUID ya da SGID etkin değilse uygulanır.
     </para>
    </listitem>
    <listitem>
     <para>
      Boş gösterici değilse, <parameter>dir</parameter> bağımsız değişkeni.
     </para>
    </listitem>
    <listitem>
     <para>
      <varname>P_tmpdir</varname> makrosunun değeri.
     </para>
    </listitem>
    <listitem>
     <para>
      <filename>/tmp</filename> dizini.
     </para>
    </listitem>
   </itemizedlist>
   <para>
    Bu işlev SVID uyumluluğu için tanımlanmıştır.
   </para>
   <warning>
    <para>
     Dosya isminin oluşturulması sırasında, başka bir süreç daha <function>tmpnam</function> kullanarak aynı isimde bir dosya oluşturursa, bu bir güvenlik açığına yol açabilir. Gerçeklenim tahmini zor isimler üretir, fakat yine de dosyayı açarken <varname>O_EXCL</varname> seçeneği kullanılmalıdır. Bu sorunla karşılaşmamak için en iyi yöntem <function>tmpfile</function> veya <function>mkstemp</function> kullanmaktır.
    </para>
   </warning>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-vr" xml:id="glibc-vr-P_tmpdir"><primary>P_tmpdir</primary></indexterm>
   <csproto type="makro">
    <csname><ptr>char</ptr><function>P_tmpdir</function></csname>
   </csproto>
   <header>&stdio.h;</header>
   <para>
    Bu makro geçici dosyalar için ön tanımlı dizin ismidir.
   </para>
  </csynopsis>
  <para>
   Eski Unix sistemleri buraya kadar bahsedilen işlevlere sahip değildi. Bunların yerine <function>mktemp</function> ve <function>mkstemp</function> işlevleri kullanılırdı.  Bu işlevlerin her ikisi de aktarılan dosya ismi şablon dizgesini değiştirerek çalışır. Bu dizgenin son altı karakteri <literal>XXXXXX</literal> olmalıdır.  Bu altı <literal>X</literal> dizgenin eşsiz olmasını sağlamak üzere altı karakterle değiştirilir. Kullanılan şablon dizgesi şuna benzer:
  </para>
  <literallayout class="monospaced"><code>/tmp/<replaceable>önek</replaceable>XXXXXX</code>
</literallayout>
  <para>
   Burada <replaceable>önek</replaceable> yazılım tarafından belirlenen eşsiz bir dizgedir.
  </para>
  <note>
   <para>
    <function>mktemp</function> ve <function>mkstemp</function> işlevleri şablon dizgesini değiştirdiklerinden dolayı, dizge bir sabit olarak aktarılmamalıdır. Dizge sabitler normalde salt-okunur saklama alanına sahiptir. Bu bakımdan <function>mktemp</function> ve <function>mkstemp</function> işlevleri dizge sabitini değiştirmeye çalışırsa yazılım çökebilir.
   </para>
  </note>
  <para>
   <indexterm role="pg"><primary>stdlib.h</primary></indexterm>
   Bu işlevler &stdlib.h; başlık dosyasında bildirilmiştir.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-mktemp"><primary>mktemp</primary></indexterm>
   <csproto type="işlev">
    <csname><ptr>char</ptr><function>mktemp</function></csname>
    <csparam><ptr>char</ptr><parameter>template</parameter></csparam>
   </csproto>
   <header>&stdlib.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <code>mktemp</code> işlevi, yukarıda açıklandığı gibi <parameter>template</parameter> dizgesini değiştirerek eşsiz bir dosya ismi üretir. İşlev başarılı olduğunda değiştirilen <parameter>template</parameter> ile döner. Eğer işlev eşsiz bir isim bulamazsa <parameter>template</parameter> dizgesini boş dizge haline getirip döner. Eğer <parameter>template</parameter> dizgesinin son altı karakteri <literal>XXXXXX</literal> değilse işlev boş gösterici döndürür.
   </para>
   <warning>
    <para>
     Dosya isminin oluşturulması sırasında, başka bir süreç daha <code>mktemp</code> kullanarak aynı isimde bir dosya oluşturursa, bu güvenlik açığına yol açabilir. Gerçeklenim tahmini zor isimler üretir, fakat yine de dosyayı açarken <varname>O_EXCL</varname> seçeneği kullanılmalıdır. Bu sorunla karşılaşmamak için en iyi yöntem <function>mkstemp</function> kullanmaktır.
    </para>
   </warning>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-mkstemp"><primary>mkstemp</primary></indexterm>
   <csproto type="işlev">
    <csname><ptr>char</ptr><function>mkstemp</function></csname>
    <csparam><ptr>char</ptr><parameter>template</parameter></csparam>
   </csproto>
   <header>&stdlib.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe; &fd;</concept>
   </conceptlist>
   <para>
    <code>mkstemp</code> işlevi <function>mktemp</function> işlevinin yaptığı gibi eşsiz dosya ismi oluşturur, fakat ek olarak dosyayı <function>open</function> (<xref linkend="glibc-Opening-and-Closing-Files"/>) ile açar.  İşlev başarılı olursa, <parameter>template</parameter> dizgesini yerinde değiştirir ve dosyayı okuma ve yazma için açarak bir dosya tanıtıcı ile döner. Eğer işlev eşsiz dosya ismi oluşturamazsa, <code>-1</code> ile döner. <parameter>template</parameter> dizgesi <literal>XXXXXX</literal> ile bitmiyorsa, işlev <code>-1</code> ile döner ve <parameter>template</parameter> dizgesini değiştirmez.
   </para>
   <para>
    Dosya <code>0600</code> kipi ile açılır. Eğer dosyaya diğer kullanıcılarında erişebilmesi isteniyorsa bu kipin değiştirilmesi gerekir.
   </para>
  </csynopsis>
  <para>
   <function>mktemp</function> işlevinin aksine, <function>mkstemp</function> işlevi geçici dosya oluşturmaya çalışan başka yazılımlarla çatışmadan eşsiz bir dosya oluşturmayı garanti eder. Bu, <function>open</function> işlevinin <varname>O_EXCL</varname> seçeneği ile kullanmasından dolayıdır (bu seçenek sayesinde, dosya oluşturulmak istenirse ve böyle bir dosya mevcutsa bir hata alınır).
  </para>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-mkdtemp"><primary>mkdtemp</primary></indexterm>
   <csproto type="işlev">
    <csname><ptr>char</ptr><function>mkdtemp</function></csname>
    <csparam><ptr>char</ptr><parameter>template</parameter></csparam>
   </csproto>
   <header>&stdlib.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <code>mkdtemp</code> işlevi, ismi eşsiz bir dizin oluşturur. Başarılı olursa dizinin ismini <parameter>template</parameter> bağımsız değişkenine yazar ve <parameter>template</parameter> ile döner. <function>mktemp</function> ve <function>mkstemp</function> işlevindeki gibi <parameter>template</parameter> dizgesi <literal>XXXXXX</literal> ile bitmelidir.
   </para>
   <para>
    <code>mkdtemp</code> işlevi eşsiz isimli dizin oluşturamazsa, boş gösterici ile döner ve <varname>errno</varname> değişkenine ilgili hata durumunu atar.  <parameter>template</parameter> dizgesi <literal>XXXXXX</literal> ile bitmiyorsa, <code>mkdtemp</code> işlevi <varname>NULL</varname> ile döner ve <parameter>template</parameter> dizgesini değiştirmez.  Bu durumda <varname>errno</varname> değişkenine <varname>EINVAL</varname> atanır.
   </para>
   <para>
    Dizin <code>0700</code> kipiyle oluşturulur.
   </para>
  </csynopsis>
  <para>
   <function>mkdtemp</function> işlevi geçici dizin oluşturmaya çalışan başka yazılımlarla çatışmadan eşsiz bir dizin oluşturmayı garanti eder. Bu, <function>open</function> işlevini <varname>O_EXCL</varname> seçeneği ile kullanmasından dolayıdır. Bkz. <xref linkend="glibc-Creating-Directories"/>.
  </para>
  <para>
   <function>mkdtemp</function> işlevi OpenBSD'den gelir.
  </para>
 </chapter>
</part>
