<?xml version="1.0" encoding="UTF-8"?>
<!-- ********************************************************************
        glibc/ch22.xml,v2.36, GFDL,LGPL, NBB, 2023
     ******************************************************************** -->
<part xml:id="glibc-Resource-Usage-And-Limitation" userlevel="longtoc">
 <title>Kaynak Kullanımı ve Sınırlar</title>
 <titleabbrev>Kaynak kullanımı ve bunlarla ilgili sınırların öğrenilmesi ve belirtilmesi.</titleabbrev>
 <preliminary>
  <para>
   Bu kısımda bir sürecin çalışması esnasında kullanacağı çeşitli sistem öz kaynaklarının (İşlemci zamanı, bellek, v.s.) sınırlarını öğrenmek ve belirtmek için kullanabilecek işlevlere yer verilmiştir.
  </para>
 </preliminary>
 <chapter xml:id="glibc-Resource-Usage">
  <title>Kaynak Kullanımı</title>
  <titleabbrev>Kullanılan çeşitli öz kaynakların ölçülmesi.</titleabbrev>
  <para>
   <indexterm linkend="glibc-pg"><primary>sys/resource.h</primary></indexterm>
   <indexterm linkend="glibc-pg"><primary sortas="resource.h">sys/resource.h</primary></indexterm>
   Bir sürecin kaynak kullanımını incelemek için kullanılan <function>getrusage</function> işlevi ve <type>struct&#160;rusage</type> veri yapısı &sys-resource.h; başlık dosyasında bildirilmiştir.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-cp-getrusage"><primary>kaynak kullanımı</primary></indexterm>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-getrusage"><primary>getrusage</primary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>getrusage</function></csname>
    <csparam><type>int</type><parameter>processes</parameter></csparam>
    <csparam><ptr>struct&#160;rusage</ptr><parameter>rusage</parameter></csparam>
   </csproto>
   <header>&sys-resource.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    Bu işlev <parameter>processes</parameter> ile belirtilen süreçlerin toplam öz kaynak kullanımını <parameter>rusage</parameter> içinde saklayarak döner.
   </para>
   <para>
    Çoğu sistemde, <parameter>processes</parameter> için sadece iki geçerli değer vardır:
   </para>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-RUSAGE_SELF"><primary>RUSAGE_SELF</primary></indexterm>
    <csproto type="sabit">
     <csname><function>RUSAGE_SELF</function></csname>
    </csproto>
    <para>
     Sadece işlevi çalıştıran süreci belirtir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-RUSAGE_CHILDREN"><primary>RUSAGE_CHILDREN</primary></indexterm>
    <csproto type="sabit">
     <csname><function>RUSAGE_CHILDREN</function></csname>
    </csproto>
    <para>
     Sonlanmış olan tüm alt süreçler (doğrudan ya da dolaylı).
    </para>
   </csynopsis>
   <para>
    İşlevin normal dönüş değeri sıfırdır, <code>-1</code> dönüş değeri bir hata oluştuğunu gösterir. Bu işlev için tanımlanmış <varname>errno</varname> hata durumu:
   </para>
   <formalpara><title><code>EINVAL</code></title>
    <para>
     <parameter>processes</parameter> bağımsız değişkeni geçersiz.
    </para>
   </formalpara>
  </csynopsis>
  <para>
   Belli bir alt sürecin kaynak kullanımını sorgulamanın tek yolu, sonlandığında kullandığı öz kaynak toplamlarını döndüren <function>wait4</function> işlevidir. Bkz. <xref linkend="glibc-BSD-Wait-Functions"/>.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-tp" xml:id="glibc-tp-rusage"><primary sortas="rusage">struct&#160;rusage</primary></indexterm>
   <csproto type="veri türü">
    <csname><type>struct</type><function>rusage</function></csname>
   </csproto>
   <header>&sys-resource.h;</header>
   <para>
    Bu veri türü çeşitli öz kaynakların kullanım istatistiklerini saklar. En azından şu üyelere sahiptir:
   </para>
   <glosslist>
    <glossentry>
     <glossterm>
      <type>struct&#160;timeval&#160;</type><structfield>ru_utime</structfield>
     </glossterm>
     <glossdef>
      <para>
       Kullanıcı komutları çalıştırılırken harcanan süre.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <type>struct&#160;timeval&#160;</type><structfield>ru_stime</structfield>
     </glossterm>
     <glossdef>
      <para>
       İşletim sistemi tarafından <parameter>processes</parameter> yararına kullanılan toplam süre.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <type>long&#160;int&#160;</type><structfield>ru_maxrss</structfield>
     </glossterm>
     <glossdef>
      <para>
       <parameter>processes</parameter> tarafından aynı anda kullanılan fiziksel belleğin kilobayt cinsinden azami miktarı.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <type>long&#160;int&#160;</type><structfield>ru_ixrss</structfield>
     </glossterm>
     <glossdef>
      <para>
       Diğer süreçlerle paylaşılan metin tarafından kullanılan bellek miktarını belirten icra tiklerinin kilobayt cinsinden tamsayı değeri.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <type>long&#160;int&#160;</type><structfield>ru_idrss</structfield>
     </glossterm>
     <glossdef>
      <para>
       Veri için kullanılan paylaşımsız bellek miktarının aynı yöntemle ifade edilen tamsayı değeri.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <type>long&#160;int&#160;</type><structfield>ru_isrss</structfield>
     </glossterm>
     <glossdef>
      <para>
       Yığıt alanı için kullanılan paylaşımsız bellek miktarının aynı yöntemle ifade edilen tamsayı değeri.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <type>long&#160;int&#160;</type><structfield>ru_minflt</structfield>
     </glossterm>
     <glossdef>
      <para>
       Herhangi bir G/Ç gerektirmeksizin sunulan sayfalama hatalarının sayısı.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <type>long&#160;int&#160;</type><structfield>ru_majflt</structfield>
     </glossterm>
     <glossdef>
      <para>
       G/Ç yaparak sunulan sayfalama hatalarının sayısı.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <type>long&#160;int&#160;</type><structfield>ru_nswap</structfield>
     </glossterm>
     <glossdef>
      <para>
       Sözkonusu süreçlerin tamamen ana belleğe takaslanma sayısı.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <type>long&#160;int&#160;</type><structfield>ru_inblock</structfield>
     </glossterm>
     <glossdef>
      <para>
       Dosya sisteminin sözkonusu süreçler yararına diskten yaptığı okumaların sayısı.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <type>long&#160;int&#160;</type><structfield>ru_oublock</structfield>
     </glossterm>
     <glossdef>
      <para>
       Dosya sisteminin sözkonusu süreçler yararına diskten yaptığı yazmaların sayısı.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <type>long&#160;int&#160;</type><structfield>ru_msgsnd</structfield>
     </glossterm>
     <glossdef>
      <para>
       Gönderilen süreçler arası iletişim (IPC) iletilerinin sayısı.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <type>long&#160;int&#160;</type><structfield>ru_msgrcv</structfield>
     </glossterm>
     <glossdef>
      <para>
       Alınan süreçler arası iletişim (IPC) iletilerinin sayısı.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <type>long&#160;int&#160;</type><structfield>ru_nsignals</structfield>
     </glossterm>
     <glossdef>
      <para>
       Alınan sinyallerin sayısı.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <type>long&#160;int&#160;</type><structfield>ru_nvcsw</structfield>
     </glossterm>
     <glossdef>
      <para>
       Sözkonusu süreçlerin bir bağlamsal seçiciye kasıtlı yaptığı çağrı sayısı (genellikle bazı hizmetler beklenirken).
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <type>long&#160;int&#160;</type><structfield>ru_nivcsw</structfield>
     </glossterm>
     <glossdef>
      <para>
       İstemdışı olarak bir bağlamsal seçicide yer alma sayısı (belli bir süre geçmiş ya da daha yüksek öncelikli başka bir sürecin öne geçmiş olmasından dolayı).
      </para>
     </glossdef>
    </glossentry>
   </glosslist>
  </csynopsis>
 </chapter>
 <chapter xml:id="glibc-Limits-on-Resources">
  <title>Kaynak Kullanımın Sınırlanması</title>
  <titleabbrev>Öz kaynak kullanımında sınırların belirtilmesi.</titleabbrev>
  <para>
   <indexterm linkend="glibc-cp"><primary>öz kaynak sınırları</primary></indexterm>
   <indexterm linkend="glibc-cp"><primary>kullanım sınırları</primary></indexterm>
   Bir sürecin kaynak kullanımı için sınırlar belirtilebilir. Süreç bir sınırı aşmaya çalışırsa bir sinyal alabilir ya da öz kaynağa bağımlı bir sistem çağrısı başarısız olabilir. Her süreç kendi öz kaynak sınır değerlerini kendini çalıştıran süreçten miras alır, ancak onları üst sürecinden bağımsız olarak değiştirebilir.
  </para>
  <para>
   Bir öz kaynağın her süreç için iki sınırı vardır:
  </para>
  <formalpara><title><firstterm>geçerli sınır</firstterm></title>
   <para>
    <indexterm linkend="glibc-cp"><primary>geçerli sınır</primary></indexterm>
    <indexterm linkend="glibc-cp"><primary>sanal sınır</primary></indexterm>
    Geçerli sınır, sistemin aşılmasına izin vermediği sınırdır. "Sanal sınır" olarak da bilinir, çünkü bu sınırı sürecin kendisi belirler.
   </para>
  </formalpara>
  <formalpara><title><firstterm>üst sınır</firstterm></title>
   <para>
    <indexterm linkend="glibc-cp"><primary>üst sınır</primary></indexterm>
    <indexterm linkend="glibc-cp"><primary>kesin sınır</primary></indexterm>
    Bir sürecin geçerli sınır olarak belirleyebileceği değerin üst sınırıdır. "Kesin sınır" olarak da bilinir, çünkü sürecin bu sınırın etrafından dolanması mümkün değildir. Bir süreç geçerli sınırını bu değere kadar artırabilirken, sadece sistem yöneticisi bu üst sınırı artırabilir.
   </para>
  </formalpara>
  <para>
   <indexterm linkend="glibc-pg"><primary>sys/resource.h</primary></indexterm>
   <function>getrlimit</function>, <function>setrlimit</function>, <function>getrlimit64</function> ve <function>setrlimit64</function> işlevleri ve bunlarla kullanılan simgeler &sys-resource.h; başlık dosyasında bildirilmiştir.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-cp-getrlimit"><primary>öz kaynak sınırları</primary><secondary>okunması</secondary></indexterm>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-getrlimit"><primary>getrlimit</primary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>getrlimit</function></csname>
    <csparam><type>int</type><parameter>resource</parameter></csparam>
    <csparam><ptr>struct&#160;rlimit</ptr><parameter>rlp</parameter></csparam>
   </csproto>
   <header>&sys-resource.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <parameter>resource</parameter> öz kaynağının geçerli ve üst sınırlarını okur ve bunları *<parameter>rlp</parameter> içinde saklar.
   </para>
   <para>
    İşlev başarılı olursa <code>0</code>, aksi takdirde <code>-1</code> ile döner.  Olası tek <varname>errno</varname> hata durumu <varname>EFAULT</varname>'tur.
   </para>
   <para>
    Kaynakların <code>_FILE_OFFSET_BITS == 64</code> ile derlendiği 32 bitlik sistemlerde bu işlev aslında <function>getrlimit64</function> işlevine denktir. Yani LFS arayüzü eski arayüzün yerine geçer.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-getrlimit64"><primary>getrlimit64</primary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>getrlimit64</function></csname>
    <csparam><type>int</type><parameter>resource</parameter></csparam>
    <csparam><ptr>struct&#160;rlimit64</ptr><parameter>rlp</parameter></csparam>
   </csproto>
   <header>&sys-resource.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    Bu işlev ikinci bağımsız değişkenin <type>struct&#160;rlimit64</type> türünde olması dışında <function>getrlimit</function> işlevinin eşdeğeridir.
   </para>
   <para>
    Kaynakların <code>_FILE_OFFSET_BITS == 64</code> ile derlendiği 32 bitlik sistemlerde bu işlevin ismi <function>getrlimit</function> olur, böylece LFS arayüzü eski arayüzün yerine geçer.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-cp-setrlimit"><primary>öz kaynak sınırları</primary><secondary>atanması</secondary></indexterm>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-setrlimit"><primary>setrlimit</primary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>setrlimit</function></csname>
    <csparam><type>int</type><parameter>resource</parameter></csparam>
    <csparam><ptr>const&#160;struct&#160;rlimit</ptr><parameter>rlp</parameter></csparam>
   </csproto>
   <header>&sys-resource.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <parameter>resource</parameter> öz kaynağının geçerli ve üst sınırlarını  *<parameter>rlp</parameter> içindeki değerlere ayarlar.
   </para>
   <para>
    İşlev başarılı olursa <code>0</code>, aksi takdirde <code>-1</code> ile döner. Bu işlev için tanımlanmış <varname>errno</varname> hata durumları:
   </para>
   <formalpara><title><code>EPERM</code></title>
    <simplelist>
     <member>
      Süreç geçerli sınırı üst sınırın üstünde belirtmeyi denedi.
     </member><member>
      Süreç üst sınırı artırmayı denedi ama yetkisi yetersiz.
     </member>
    </simplelist>
   </formalpara>
   <para>
    Kaynakların <code>_FILE_OFFSET_BITS == 64</code> ile derlendiği 32 bitlik sistemlerde bu işlev aslında <function>setrlimit64</function> işlevine denktir. Yani LFS arayüzü eski arayüzün yerine geçer.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-setrlimit64"><primary>setrlimit64</primary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>setrlimit64</function></csname>
    <csparam><type>int</type><parameter>resource</parameter></csparam>
    <csparam><ptr>const&#160;struct&#160;rlimit64</ptr><parameter>rlp</parameter></csparam>
   </csproto>
   <header>&sys-resource.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    Bu işlev ikinci bağımsız değişkenin <type>struct&#160;rlimit64</type> türünde olması dışında <function>setrlimit</function> işlevinin eşdeğeridir.
   </para>
   <para>
    Kaynakların <code>_FILE_OFFSET_BITS == 64</code> ile derlendiği 32 bitlik sistemlerde bu işlevin ismi <function>setrlimit</function> olur, böylece LFS arayüzü eski arayüzün yerine geçer.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-tp" xml:id="glibc-tp-rlimit"><primary sortas="rlimit">struct&#160;rlimit</primary></indexterm>
   <csproto type="veri türü">
    <csname><type>struct</type><function>rlimit</function></csname>
   </csproto>
   <header>&sys-resource.h;</header>
   <para>
    Bu yapı <function>getrlimit</function> işlevinde kullanıldığında sınır değerlerin alınmasını sağlar, <function>setrlimit</function> işlevinde kullanıldığında ise belli bir süreç ve öz kaynak için sınır değerleri belirtir. İki üyesi vardır:
   </para>
   <glosslist>
    <glossentry>
     <glossterm>
      <type>rlim_t&#160;</type><structfield>rlim_cur</structfield>
     </glossterm>
     <glossdef>
      <para>
       Geçerli sınır.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <type>rlim_t&#160;</type><structfield>rlim_max</structfield>
     </glossterm>
     <glossdef>
      <para>
       Üst sınır.
      </para>
     </glossdef>
    </glossentry>
   </glosslist>
   <para>
    <function>getrlimit</function> işlevi açısından yapı bir çıktı alanıdır; o anki değerleri alır. <function>setrlimit</function> işlevinde ise yeni değerleri belirtir.
   </para>
  </csynopsis>
  <para>
   LFS işlevleri için benzer bir tür &sys-resource.h; başlık dosyasında tanımlanmıştır.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-tp" xml:id="glibc-tp-rlimit64"><primary sortas="rlimit64">struct&#160;rlimit64</primary></indexterm>
   <csproto type="veri türü">
    <csname><type>struct</type><function>rlimit64</function></csname>
   </csproto>
   <header>&sys-resource.h;</header>
   <para>
    Bu yapı üyelerinin daha geniş aralıklara sahip olması dışında yukarıdaki <type>struct&#160;rlimit</type> yapısının karşılığıdır. İki üyesi vardır:
   </para>
   <glosslist>
    <glossentry>
     <glossterm>
      <type>rlim_t64&#160;</type><structfield>rlim_cur</structfield>
     </glossterm>
     <glossdef>
      <para>
       <code>rlimit.rlim_cur</code> karşılığıdır, ama türü farklıdır.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <type>rlim_t64&#160;</type><structfield>rlim_max</structfield>
     </glossterm>
     <glossdef>
      <para>
       <code>rlimit.rlim_max</code> karşılığıdır, ama türü farklıdır.
      </para>
     </glossdef>
    </glossentry>
   </glosslist>
  </csynopsis>
  <para>
   Bir sınır belirtilebilecek öz kaynakların listesi aşağıda verilmiştir. Bellek ve dosyalarla ilgili sınırlar bayt cinsindendir.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-vr" xml:id="glibc-vr-RLIMIT_CPU"><primary>RLIMIT_CPU</primary></indexterm>
   <csproto type="sabit">
    <csname><function>RLIMIT_CPU</function></csname>
   </csproto>
   <header>&sys-resource.h;</header>
   <para>
    Sürecin kullanabileceği işlemci zamanının azami miktarı. Süreç bundan daha uzun süre çalışırsa, <varname>SIGXCPU</varname> sinyalini alır. Değer saniye cinsindendir. Bkz. <xref linkend="glibc-Operation-Error-Signals"/>.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-vr" xml:id="glibc-vr-RLIMIT_FSIZE"><primary>RLIMIT_FSIZE</primary></indexterm>
   <csproto type="sabit">
    <csname><function>RLIMIT_FSIZE</function></csname>
   </csproto>
   <header>&sys-resource.h;</header>
   <para>
    Sürecin oluşturabileceği azami dosya boyutu. Daha büyük bir dosya yazma denemesi <varname>SIGXFSZ</varname> sinyaline sebep olur.  Bkz. <xref linkend="glibc-Operation-Error-Signals"/>.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-vr" xml:id="glibc-vr-RLIMIT_DATA"><primary>RLIMIT_DATA</primary></indexterm>
   <csproto type="sabit">
    <csname><function>RLIMIT_DATA</function></csname>
   </csproto>
   <header>&sys-resource.h;</header>
   <para>
    Süreç için ayrılan azami veri belleği miktarı. Süreç bu miktardan daha büyük bellek ayırmaya çalışırsa bellek ayırma işlevi başarısız olur.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-vr" xml:id="glibc-vr-RLIMIT_STACK"><primary>RLIMIT_STACK</primary></indexterm>
   <csproto type="sabit">
    <csname><function>RLIMIT_STACK</function></csname>
   </csproto>
   <header>&sys-resource.h;</header>
   <para>
    Süreç için azami yığıt boyutu. Süreç yığıtını bundan fazlasına genişletmeye çaışırsa bir <varname>SIGSEGV</varname> sinyali alacaktır. Bkz. <xref linkend="glibc-Program-Error-Signals"/>.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-vr" xml:id="glibc-vr-RLIMIT_CORE"><primary>RLIMIT_CORE</primary></indexterm>
   <csproto type="sabit">
    <csname><function>RLIMIT_CORE</function></csname>
   </csproto>
   <header>&sys-resource.h;</header>
   <para>
    Bu sürecin oluşturabileceği core dosyasının azami boyutu. Eğer süreç sonlanır ve bu boyuttan daha büyük bir core dosyası dökümlemeyi denerse core dosyası oluşmaz. Bu bakımdan, bu sınır sıfıra indirilerek core dosyalarının asla oluşmaması sağlanabilir.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-vr" xml:id="glibc-vr-RLIMIT_RSS"><primary>RLIMIT_RSS</primary></indexterm>
   <csproto type="sabit">
    <csname><function>RLIMIT_RSS</function></csname>
   </csproto>
   <header>&sys-resource.h;</header>
   <para>
    Bu sürecin alabileceği fiziksel belleğin azami miktarı. Bu bağımsız değişken sistemin zamanlayıcısı ve bellek ayırıcısı için bir kılavuzdur. Sistem, sürece ihtiyaç duyduğunda bundan daha fazla bellek verebilir.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-vr" xml:id="glibc-vr-RLIMIT_MEMLOCK"><primary>RLIMIT_MEMLOCK</primary></indexterm>
   <csproto type="sabit">
    <csname><function>RLIMIT_MEMLOCK</function></csname>
   </csproto>
   <header>&sys-resource.h;</header>
   <para>
    Fiziksel bellekte kilitlenebilecek belleğin azami miktarı (böylece bu bellek takaslanmayacaktır).
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-vr" xml:id="glibc-vr-RLIMIT_NPROC"><primary>RLIMIT_NPROC</primary></indexterm>
   <csproto type="sabit">
    <csname><function>RLIMIT_NPROC</function></csname>
   </csproto>
   <header>&sys-resource.h;</header>
   <para>
    Aynı kullanıcı kimlikle oluşturulabilecek süreçlerin azami sayısı. Bu sınırı kendi kullanıcı kimliğiniz için aşmaya çalışırsanız, <function>fork</function> işlevi <varname>EAGAIN</varname> ile başarısız olacaktır. Bkz. <xref linkend="glibc-Creating-a-Process"/>.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-vr" xml:id="glibc-vr-RLIMIT_NOFILE"><primary>RLIMIT_NOFILE</primary></indexterm>
   <indexterm linkend="glibc-vr" xml:id="glibc-vr-RLIMIT_OFILE"><primary>RLIMIT_OFILE</primary></indexterm>
   <csproto type="sabit">
    <csname><function>RLIMIT_NOFILE</function></csname>
   </csproto>
   <csproto type="sabit">
    <csname><function>RLIMIT_OFILE</function></csname>
   </csproto>
   <header>&sys-resource.h;</header>
   <para>
    Sürecin açabileceği dosyaların azami sayısı. Bundan daha fazla dosya açmaya çalışırsa, işlem <varname>EMFILE</varname> hata kodu ile başarısız olur. Bu sınır tüm sistemlerde desteklenmez; GNU ve 4.4 BSD böyledir.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-vr" xml:id="glibc-vr-RLIMIT_AS"><primary>RLIMIT_AS</primary></indexterm>
   <csproto type="sabit">
    <csname><function>RLIMIT_AS</function></csname>
   </csproto>
   <header>&sys-resource.h;</header>
   <para>
    Bu sürecin alabileceği toplam belleğin azami miktarı. Eğer süreç bunu aşan miktarı örneğin, <function>brk</function>, <function>malloc</function>, <function>mmap</function> veya <function>sbrk</function> ile ayırmaya çalışırsa işlev başarısız olur.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-vr" xml:id="glibc-vr-RLIM_NLIMITS"><primary>RLIM_NLIMITS</primary></indexterm>
   <csproto type="sabit">
    <csname><function>RLIM_NLIMITS</function></csname>
   </csproto>
   <header>&sys-resource.h;</header>
   <para>
    Farklı öz kaynak sınırlarının sayısı. Geçerli <parameter>resource</parameter> terimlerinin sayısı <code>RLIM_NLIMITS</code> değerinden küçük olmalıdır.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-vr" xml:id="glibc-vr-RLIM_INFINITY"><primary>RLIM_INFINITY</primary></indexterm>
   <csproto type="sabit">
    <csname><type>rlim_t</type><function>RLIM_INFINITY</function></csname>
   </csproto>
   <header>&sys-resource.h;</header>
   <para>
    Bu sabit, <function>setrlimit</function> içinde sınır değer olarak belirtildiğinde "sonsuz" değerine karşılıktır.
   </para>
  </csynopsis>
  <para>
   Aşağıdaki tarihi işlevler şimdiye kadar bahsedilen işlevlerin yaptıklarını yaparlar. Bunların yerine yukarıda bahsedilen işlevlerin kullanılması daha iyi bir seçim olacaktır.
  </para>
  <para>
   <indexterm linkend="glibc-pg"><primary>ulimit.h</primary></indexterm>
   <function>ulimit</function> ve komut simgeleri &ulimit.h; başlık dosyasında bildirilmiştir.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-ulimit"><primary>ulimit</primary></indexterm>
   <csproto type="işlev">
    <csname><type>long&#160;int</type><function>ulimit</function></csname>
    <csparam><type>int</type><parameter>cmd</parameter></csparam>
    <varargs/>
   </csproto>
   <header>&ulimit.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <code>ulimit</code> işlevi çağrıldığı süreç ile ilgili olarak <parameter>cmd</parameter> ile belirtildiği gibi öz kaynağın ya geçerli sınırıyla döner ya da geçerli ve üst sınırını belirtir.
   </para>
   <para>
    Bir sınır değeri döndürmek için komut bağımsız değişkeninden başka bağımsız değişken gerekmez. Bir sınırı belirtmek için ise ikinci bir bağımsız değişken gerekir: <type>long&#160;int</type> <parameter>sınır</parameter>.
   </para>
   <para>
    <parameter>cmd</parameter> bağımsız değişkeninde kullanılabilecek değerler ve belirttikleri işlemler:
   </para>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-GETFSIZE"><primary>GETFSIZE</primary></indexterm>
    <csproto type="sabit">
     <csname><function>GETFSIZE</function></csname>
    </csproto>
    <para>
     Dosya boyutunun geçerli sınırını 512 baytlık birimler cinsinden döndürür.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-SETFSIZE"><primary>SETFSIZE</primary></indexterm>
    <csproto type="sabit">
     <csname><function>SETFSIZE</function></csname>
    </csproto>
    <para>
     Dosya boyutunun geçerli ve üst sınırını <parameter>sınır</parameter> * 512 bayta ayarlar.
    </para>
   </csynopsis>
   <para>
    Bazı sistemlerde başka işlemler yapan başka <parameter>cmd</parameter> değerleri de olabilir ama onlar desteklenmemektedir.
   </para>
   <para>
    Bir üst sınırı sadece sistem yöneticisi artırabilir.
   </para>
   <para>
    Bir sınır başarıyla alınmışsa işlevin dönüş değeri bu sınırın değeridir ve asla negatif değildir. Bir sınır başarıyla değiştirilmişse işlevin dönüş değeri sıfır olur. İşlev başarısız olduğunda <code>-1</code> ile döner ve olası <varname>errno</varname> hata durumu şu olabilir:
   </para>
   <formalpara><title><code>EPERM</code></title>
    <para>
     Süreç üst sınırı artırmayı denedi ama yetkisi yetersiz.
    </para>
   </formalpara>
  </csynopsis>
  <para>
   <indexterm linkend="glibc-pg"><primary>sys/vlimit.h</primary></indexterm>
   <code>vlimit</code> ve onunla ilgili öz kaynak simgeleri &sys-vlimit.h; başlık dosyasında bildirilmiştir.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-vlimit"><primary>vlimit</primary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>vlimit</function></csname>
    <csparam><type>int</type><parameter>resource</parameter></csparam>
    <csparam><type>int</type><parameter>limit</parameter></csparam>
   </csproto>
   <header>&ulimit.h;</header>
   <conceptlist>
    <concept>&mtunsafe; &race;<code linkend="glibc-safety-identifier">:setrlimit</code></concept>
    <concept>&asunsafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    Sürecin belirtilen öz kaynağı için geçerli sınırı <parameter>limit</parameter> yapar.
   </para>
   <para>
    <parameter>limit</parameter> şunlardan biri olabilir:
   </para>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-LIM_CPU"><primary>LIM_CPU</primary></indexterm>
    <csproto type="sabit">
     <csname><function>LIM_CPU</function></csname>
    </csproto>
    <para>
     Azami işlemci zamanı. <function>setrlimit</function> için <varname>RLIMIT_CPU</varname> ile aynıdır.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-LIM_FSIZE"><primary>LIM_FSIZE</primary></indexterm>
    <csproto type="sabit">
     <csname><function>LIM_FSIZE</function></csname>
    </csproto>
    <para>
     Azami işlemci zamanı. <function>setrlimit</function> için <varname>RLIMIT_FSIZE</varname> ile aynıdır.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-LIM_DATA"><primary>LIM_DATA</primary></indexterm>
    <csproto type="sabit">
     <csname><function>LIM_DATA</function></csname>
    </csproto>
    <para>
     Azami veri belleği.  <function>setrlimit</function> için <varname>RLIMIT_DATA</varname> ile aynıdır.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-LIM_STACK"><primary>LIM_STACK</primary></indexterm>
    <csproto type="sabit">
     <csname><function>LIM_STACK</function></csname>
    </csproto>
    <para>
     Azami yığıt boyutu.  <function>setrlimit</function> için <varname>RLIMIT_STACK</varname> ile aynıdır.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-LIM_CORE"><primary>LIM_CORE</primary></indexterm>
    <csproto type="sabit">
     <csname><function>LIM_CORE</function></csname>
    </csproto>
    <para>
     Azami core dosyası boyutu.  <function>setrlimit</function> için <varname>RLIMIT_COR</varname> ile aynıdır.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-LIM_MAXRSS"><primary>LIM_MAXRSS</primary></indexterm>
    <csproto type="sabit">
     <csname><function>LIM_MAXRSS</function></csname>
    </csproto>
    <para>
     Azami fiziksel bellek.  <function>setrlimit</function> için <varname>RLIMIT_RSS</varname> ile aynıdır.
    </para>
   </csynopsis>
   <para>
    İşlevin normal dönüş değeri sıfırdır, <code>-1</code> dönüş değeri bir hata oluştuğunu gösterir. Bu işlev için tanımlanmış <varname>errno</varname> hata durumu:
   </para>
   <formalpara><title><code>EPERM</code></title>
    <para>
     Süreç geçerli sınırı üst sınırın üzerine çıkarmaya çalıştı.
    </para>
   </formalpara>
  </csynopsis>
 </chapter>
 <chapter xml:id="glibc-Priority">
  <title>Sürecin İşlemci Önceliği ve Zamanlama</title>
  <titleabbrev>Sürecin çalışma önceliğinin okunması ve belirtilmesi.</titleabbrev>
  <preliminary>
   <para>
    <indexterm linkend="glibc-cp"><primary>süreç</primary><secondary>öncelik</secondary></indexterm>
    <indexterm linkend="glibc-cp"><primary>işlemci</primary><secondary>öncelik</secondary></indexterm>
    <indexterm linkend="glibc-cp"><primary>öncelik</primary><secondary>süreç önceliği</secondary></indexterm>
    <indexterm linkend="glibc-cp"><primary>öncelik</primary><secondary>işlemci önceliği</secondary></indexterm>
    Çok sayıda süreç aynı anda işlemci zamanını kullanmak isterse, sistemin zamanlama kurallarına ve sürecin işlemci önceliğine bakılarak onu hangi sürecin alacağı saptanır. Bu kısımda &glibc;nde işlevlerle bu saptamanın nasıl yapıldığından bahsedilecektir.
   </para>
   <para>
    İşlemci öz kaynağı ile ilgili olarak, işlemci zamanlamasından basitçe zamanlama ve sürecin işlemci önceliğinden ise sürecin önceliği olarak bahsetmek yaygındır. Bununla birlikte, işlemci zamanının sürecin kullandığı ya da süreçlerin kullanmak için yarıştıkları tek kaynak olduğu gibi bir anlam da çıkarılmamalıdır. Hatta bazı durumlarda özellikle önemli bile değildir. Bir sürece yüksek bir "öncelik" verilmesi bu sürecin diğer süreçlerden daha hızlı olmasına çok küçük bir etkisi olabilir. Bu bölümde öncelik deyince sadece işlemci zamanına uygulanan öncelikten bahsediliyor olacaktır.
   </para>
   <para>
    İşlemci zamanlaması karmaşık bir konudur ve farklı sistemler bunu oldukça farklı yollarla yaparlar. Yeni fikirler sürekli geliştirilmekte ve çeşitli sistemlerin zamanlama algoritmalarının karmaşıklığı içinde yollar bulunmaya çalışılmaktadır. Bu bölümde genel kavramlar, &glibc;ni kullanan sistemlerin bazı özellikleri ve standartlar üzerinde durulacaktır.
   </para>
   <para>
    Basitleştirmek için, sistemde sadece bir işlemci ve o işlemci içinde sadece bir işlem birimi varmış gibi davranacağız. Ancak bazı prensipler bir işlemci birden fazla işlem birimi içerdiğinde uygulanır ve eşit sayıda işlem birimi içeren çok sayıda işlemci olduğunda bu bilgi kolayca genelleştirilebilir.
   </para>
   <para>
    Bu bölümde bahsedilen işlevlerin hepsi POSIX.1 ve POSIX.1b standartlarında bulunur (<function>sched…</function> işlevleri, POSIX.1b'dedir). Bununla birlikte, POSIX bu işlevlerin okuduğu ya da belirlediği değerler için anlambilimsel bir tanım yapmamıştır. Bu kısımda, anlama dair kabuller POSIX standardının Linux çekirdeği gerçeklemesi üzerine oturtulmuştur. Görüleceği gibi, Linux gerçeklemesi POSIX sözdizimi yazarlarlarınınkilere göre biraz terstir.
   </para>
  </preliminary>
  <sect1 xml:id="glibc-Absolute-Priority" userlevel="notoc">
   <?dbhtml stop-chunking?>
   <title>Mutlak Öncelik</title>
   <titleabbrev>Birinci öncelik katmanı.</titleabbrev>
   <para>
    <indexterm linkend="glibc-cp"><primary>mutlak öncelik</primary></indexterm>
    <indexterm linkend="glibc-cp"><primary>öncelik</primary><secondary>mutlak</secondary></indexterm>
    Her sürecin mutlak önceliği vardır ve bir sayı ile ifade edilir. Daha yüksek sayı daha yüksek mutlak öncelik demektir.
   </para>
   <para>
    <indexterm linkend="glibc-cp"><primary>işlemci</primary><secondary>zamanlama</secondary><tertiary>gerçek zamanlı</tertiary></indexterm>
    <indexterm linkend="glibc-cp"><primary>zamanlama</primary><secondary>işlemci</secondary><tertiary>gerçek zamanlı</tertiary></indexterm>
    Geçmişteki bazı sistemlerde ve günümüzde çoğu sistemde, tüm süreçlerin mutlak önceliği 0'dır ve bu bölümün konusu dışındadır. Bu durumla ilgili olarak, bkz. <xref linkend="glibc-Traditional-Scheduling"/>.  Mutlak öncelikler, belli süreçlerin dış olaylara yanıt vermesinin hayati önemde olduğu gerçek zamanlı sistemler için tasarlanmıştır. Bu sistemlerde çalışmak <emphasis>isteyen</emphasis> süreçler işlemciyi tutarken çalışması <emphasis>gereken</emphasis> süreçleri bekletmemesi amaçlanmıştır.
   </para>
   <para>
    <indexterm linkend="glibc-cp"><primary>süreç</primary><secondary>çalışmaya hazır olmak</secondary></indexterm>
    <indexterm linkend="glibc-cp"><primary>zamanlama</primary><secondary>öncelikçi</secondary></indexterm>
    <indexterm linkend="glibc-cp"><primary>süreç</primary><secondary>çalışabilirlik</secondary></indexterm>
    İşlemciyi herhangi bir anda kullanmaya çalışacak iki süreçten daha yüksek önceliği olan işlemciyi alır. Bunlardan biri işlemciyi zaten kullanmaktaysa ve önceliği düşükse önceliği yüksek olan işlemciyi yine alacaktır (yani, zamanlama ayrıcalıklıdır). Şüphesiz, burada bahsettiğimiz süreçler zaten başlatılmış yani çalışabilir olan ya da o an komutlarını çalıştırmaya hazır olmak anlamında "çalışmaya hazır" süreçlerdir. Bir süreç G/Ç işlemi gibi bir işlem nedeniyle beklemedeyse, onun önceliği konu dışıdır.
   </para>
   <note>
    <para>
     &quot;çalışabilir olmak&quot; ile &quot;çalışmaya hazır olmak&quot; aynı anlamda kullanılmıştır.
    </para>
   </note>
   <para>
    İki süreç de çalışabilir durumdaysa ya da çalışmaya hazırsa ve ikisinin de mutlak önceliği aynıysa, bu daha ilginçtir. Bu durumda işlemciyi hangisinin alacağını zamanlama kuralları belirler. Eğer süreçlerin mutlak öncelikleri 0 ise, işlemciyi hangisinin alacağı <xref linkend="glibc-Traditional-Scheduling"/> bölümünde anlatılan geleneksel zamanlama kurallarına göre bu saptanır. Aksi takdirde <xref linkend="glibc-Realtime-Scheduling"/> bölümünde anlatılan kurallar uygulanır..
   </para>
   <para>
    Normalde 0'ın üstünde bir mutlak öncelik, işlemciyi etkisiz bırakmayacaksa verilir. Böyle süreçler kısa bir işlemci kullanımından sonra beklemeye geçmek ya da sonlanmak üzere tasarlanır.
   </para>
   <para>
    Bir süreç, kendini başlatan süreç ile aynı mutlak öncelikle oluşturulur. Bu durumu değiştirebilen işlevler <xref linkend="glibc-Basic-Scheduling-Functions"/> bölümünde açıklanmıştır.
   </para>
   <para>
    Sadece ayrıcalıklı bir süreç kendi mutlak önceliğini <code>0</code>'dan farklı bir değere ayarlayabilir. Sadece ayrıcalıklı süreç ya da hedef sürecin sahibi mutlak önceliği değiştirebilir.
   </para>
   <para>
    POSIX, gerçek zamanlı zamanlama kuralları ile kullanılan mutlak öncelik değerlerinin 32'den başlayan ve ardışık sıralanan değerler olmasını gerektirir. Linux'ta 1 ile 99 arasındadır. Taşınabilirlik açısından, <function>sched_get_priority_max</function> ve <function>sched_set_priority_min</function> işlevleri belli bir sistem üzerinde geçerli aralığın ne olduğunu söyler.
   </para>
   <sect2 xml:id="glibc-Using-Absolute-Priority">
    <title>Mutlak Önceliğin Kullanımı</title>
    <para>
     Gerçek zamanlı uygulamalar tasarlanırken unutulmaması gereken tek şey diğer süreçlerden daha yüksek bir mutlak önceliğin sürecin çalışma sürekliliğini garanti etmeyeceğidir. İşlemcinin çalışmasını kazaya uğratan iki şey vardır: kesmeler ve sayfalama hataları.
    </para>
    <para>
     Kesme işleyicileri süreçler arasındaki bu belirsizlik içinde yaşar. Komutlarını işlemci çalıştırır ama onlar sürecin parçası değildir. Bir kesme en yüksek öncelikli süreci bile durdurur. Bu durumda önemsiz derecede küçük gecikmelere izin verilmeli ve sürecin komutları arasında çok uzun gecikmelere sebep olabilecek kesme işleyicilere sahip aygıtların olmadığından da emin olunmalıdır.
    </para>
    <para>
     Benzer şekilde, bir sayfalama hatası, basit bir komut dizisinin uzun bir zaman alıyormuş gibi görünmesine sebep olur. Aslında, sayfalama hatası sırasında bundan etkilenmeyen süreçler çalışmaya devam eder, çünkü G/Ç'ların tamamlanması gerekir, ancak yüksek öncelikli süreç onları atıp tekrar çalışmaya devam eder. Esas sorun G/Ç için, öncelikli sürecin kendisinin bekleme durumuna geçmesi olurdu. Bu aşamayı etkisiz hale getirmek için <function>mlock</function> veya <function>mlockall</function> kullanılır.
    </para>
    <para>
     Bir öncelik vermeyi seçerken ve ayrıca yüksek mutlak öncelikli bir yazılım da çalıştırılıyorsa, akılda tutulması gereken şey, tek işlem birimli tek işlemcili bir sistemde bu önceliğin mutlaklığının bunlar arasında bölüneceğidir. Diğer süreçlere göre daha yüksek mutlak öncelikli bir sürecin, yazılımındaki bir hatadan dolayı sonsuz döngüye girdiğini varsayılsın. Çalışması sırasında işlemciden asla vazgeçmeyecektir. Hatalı yazılım denetimi tamamen, her yönden ele geçirir. Bir komut çalıştırmak için onu öldürmekten başka çare kalmaz.
    </para>
    <para>
     Bundan kaçınmanın iki yolu vardır: 1) bir yerlerde çalışmakta olan daha yüksek öncelikli bir kabuk bulundurmak (root'un açtığı bir kabuk örneğin). 2) yüksek öncelikli süreç grubu ile ilişkili bir denetim uçbirimi tutmak. Çalışmaya başlayan bir kesme işleyiciden kaçacak ya da <keycap>C-c</keycap> tuşlandığında sinyal alıp da durmayacak bir öncelik mevcut değildir.
    </para>
    <para>
     Bazı sistemler mutlak önceliği, işlemci zamanının belli bir yüzdesini bir sürece ayırmak manasında kullanırlar. Bunu yapmak için, süper yüksek öncelikli ve ayrıcalıklı bir süreç, süreclerin işlemci kullanımını sürekli olarak gözler, payını alamayan sürecin mutlak önceliğini yükseltir, payından fazlasını alan sürecin mutlak önceliğini düşürür.
    </para>
    <note>
     <para>
      Mutlak öncelik kimi zaman "duruk öncelik" diye de anılır; bu kılavuzda bu terim kullanılmamaktadır, çünkü mutlak önceliğin en önemli özelliği, mutlaklığı kaybolur.
     </para>
    </note>
   </sect2>
  </sect1>
  <sect1 xml:id="glibc-Realtime-Scheduling">
   <title>Anlık Zamanlama</title>
   <titleabbrev>Eş öncelikli süreçler arasında zamanlama</titleabbrev>
   <para>
    <indexterm linkend="glibc-cp"><primary>zamanlama</primary><secondary>anlık</secondary></indexterm>
    Aynı mutlak önceliğe sahip iki süreç aynı anda çalışmaya hazırsa, çekirdek bir karar vermek zorundadır, çünkü bir kerede sadece biri çalışabilir. Eğer süreçlerin mutlak öncelikleri 0 ise çekirdek bu kararı <xref linkend="glibc-Traditional-Scheduling"/> bölümünde anlatıldığı gibi verir.  Aksi takdirde vereceği karar bu bölümde anlatılacaktır.
   </para>
   <para>
    Farklı mutlak önceliklere sahip iki süreç çalışmaya hazırsa verilecek karar basittir, bu <xref linkend="glibc-Absolute-Priority"/> bölümünde açıklanmıştı.
   </para>
   <para>
    Her sürecin kendine ait zamanlama kuralları vardır. Sıfırdan farklı mutlak önceliği olan süreçler için bunlar iki tanedir:
   </para>
   <orderedlist>
    <listitem>
     <para>
      İlk gelen alır
     </para>
    </listitem>
    <listitem>
     <para>
      Döner turnuva düzenlenir
     </para>
    </listitem>
   </orderedlist>
   <para>
    En duyarlı durum, tüm süreçlerin aynı zamanlama kurallarına sahip olduğu ama mutlak önceliklerinin farklı olduğu durumdur ki, bundan daha önce söz edilmişti.
   </para>
   <para>
    Turnuvada, süreçler işlemciyi paylaşır, her biri küçük bir zaman diliminde çalışır ve döner turnuva bağlamında bunu her turda bir kere yapar. Şüphesiz, bu turnuvaya sadece aynı mutlak önceliğe sahip ve aynı anda çalışmaya hazır süreçler katılır.
   </para>
   <para>
    İlk gelen alır durumunda ise, en uzun bekleyen süreç işlemciyi alır ve işlemciyi bırakmaya gönüllü olana kadar, bırakmaktan başka çare kalmayana dek (beklemeye geçmek gibi) ya da daha yüksek öncelikli bir süreç işlemciyi alana kadar işlemciyi tutar.
   </para>
   <para>
    İlk gelen alır kuralı, en yüksek mutlak öncelik ve kesmelerle sayfalama hatalarının dikkati denetlenmesiyle, bir sürecin mutlak olarak ve olumlu manada işlemciyi tam hızda çalıştırdığı takdirde kullanılması vazgeçilmezdir; değilse anlamlı değildir.
   </para>
   <para>
    Süreçlerin <function>sched_yield</function> çağrılarında, zamanlama kuralını belirtirken turnuva ile ilk gelen alır arasında iyi bir uzlaşımın sonucu olarak ilk gelen alır kuralını kullanmak konusunda akıllıca davranmalıdır.
   </para>
   <para>
    Farklı zamanlama kuralları olan aynı mutlak önceliğe sahip süreçler açısından zamanlamanın nasıl çalıştığını anlamak için, süreçlerin çalışmaya hazır süreçler listesine nasıl dahil edildiği ve nasıl listeden çıkarıldıkları ile ilgili ayrıntılar iyi bilinmelidir:
   </para>
   <para>
    Her iki durumda da, çalışmaya hazır süreçlerin listesi gerçek bir kuyruk olarak düzenlenir. Süreç çalışmaya hazır olduğunda kuyruğun sonuna eklenir ve zamanlayıcı onu çalıştırmaya karar verdiğinde kuyruğun başına çekilir. Çalışmaya hazır olmak ile çalışıyor olmanın aynı anda olan şeyler olmadıklarına dikkat edilmelidir. Zamanlayıcı bir süreci çalıştırıyorsa o artık çalışmaya hazır bir süreç değildir ve dolayısıyla artık çalışmaya hazır süreçler listesinde değildir. Sürecin çalışması durduğunda tekrar çalışmaya hazır duruma gelir.
   </para>
   <para>
    Turnuva kuralına göre çalışacak süreç ile ilk gelen alır kuralına göre çalışacak süreç arasındaki tek fark, ilk durumdaki sürecin belli bir süre sonra işlemciyi bırakmak zorunda kalacağıdır. Bu olduğunda süreç tekrar çalışmaya hazır duruma gelir ve kuyruğa tekrar eklenir. Burada bahsedilen süre oldukça kısadır. Hem de gerçekten kısadır. Örneğin, Linux çekirdeğinde turnuva zaman dilimi, geleneksel zamanlama ile ilgili zaman diliminden bin kere daha kısadır.
   </para>
   <para>
    Bir süreç, kendini başlatan süreç ile aynı zamanlama kuralları ile oluşturulur. Bu durumu değiştirebilen işlevler <xref linkend="glibc-Basic-Scheduling-Functions"/> bölümünde açıklanmıştır.
   </para>
   <para>
    Sadece ayrıcalıklı süreç, mutlak önceliği <code>0</code>'dan farklı bir sürecin zamanlama kuralını ayarlayabilir.
   </para>
  </sect1>
  <sect1 xml:id="glibc-Basic-Scheduling-Functions">
   <title>Temel Zamanlama İşlevleri</title>
   <titleabbrev>Zamanlama kurallarını alınması/belirtilmesi, öncelik</titleabbrev>
   <para>
    Bu bölümdeki işlevler, mutlak önceliği ve bir sürecin zamanlama kuralını ayarlamakta kullanılan &glibc;ndeki işlevlerdir.
   </para>
   <note><title>Taşınabilirlik Bilgisi</title>
    <para>
     Bu işlevlere sahip sistemlerde <varname>_POSIX_PRIORITY_SCHEDULING</varname> makrosu &unistd.h; başlık dosyasında tanımlanmıştır.
    </para>
   </note>
   <para>
    Zamanlama kurallarının geleneksel zamanlama ile ilgili olduğu durumda zamanlamayı daha hassas ayarlayabilen işlevler <xref linkend="glibc-Traditional-Scheduling"/> bölümünde bulunabilir.
   </para>
   <para>
    Bu işlevlerin yapısı ve isimlendirilmesi bakımından denenecek çok fazla bir şey yoktur. Bunlar POSIX.1b tarafından tanımlanmış olduğundan bu kılavuzda bahsedilen kavramlarla uyuşmamaları normaldir. Çünkü &glibc;nin kullanıldığı sistemlerdeki gerçekleme POSIX yapısı ile ilgili kavramsallaştırmanın tersidir. POSIX şeması birincil zamanlama bağımsız değişkeninin zamanlama kuralları olduğunu ve öncelik değerinin (varsa), zamanlama kurallarının bir bağımsız değişkeni olduğunu kabul eder. Gerçeklemede ise ister istemez, öncelik değeri başattır ve zamanlama kuralları, eğer varsa, önceliği etkileyen ince bir ayardır.
   </para>
   <para>
    Bu bölümdeki simgeler &sched.h; başlık dosyasında bildirilmiştir.
   </para>
   <note><title>Taşınabilirlik Bilgisi</title>
    <para>
     POSIX'te, aşağıdaki işlevlerin <type>pid_t</type> türündeki bağımsız değişkenleri süreç kimlikleri ile ilgilidir. Linux'ta bunlar aslında evresel kimliklerdir ve tüm sistemle ilgili olarak belirli evrelerin denetlenebilmesini sağlar. Ortaya çıkan davranış, POSIX'e uymaz. Bu nedenle, aşağıdaki açıklama, süreçler ve süreç kimlikleri ile değil, görevler ve görev kimlikleri ile ilgilidir.
    </para>
   </note>
   <csynopsis>
    <indexterm linkend="glibc-tp" xml:id="glibc-tp-sched_param"><primary sortas="sched_param">struct&#160;sched_param</primary></indexterm>
    <csproto type="veri türü">
     <csname><type>struct</type><function>sched_param</function></csname>
    </csproto>
    <header>&sched.h;</header>
    <para>
     Bu yapı bir mutlak önceliği tanımlar.
    </para>
    <glosslist>
     <glossentry>
      <glossterm>
       <type>int&#160;</type><structfield>sched_priority</structfield>
      </glossterm>
      <glossdef>
       <para>
        Mutlak öncelik değeri.
       </para>
      </glossdef>
     </glossentry>
    </glosslist>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-sched_setscheduler"><primary>sched_setscheduler</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>sched_setscheduler</function></csname>
     <csparam><type>pid_t</type><parameter>pid</parameter></csparam>
     <csparam><type>int</type><parameter>policy</parameter></csparam>
     <csparam><ptr>const&#160;struct&#160;sched_param</ptr><parameter>param</parameter></csparam>
    </csproto>
    <header>&sched.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     Bu işlev bir görevin hem mutlak önceliğini hem de zamanlama kuralını ayarlar.
    </para>
    <para>
     Görev kimliği <varname>pid</varname> olan görevin ya da <varname>pid</varname> olarak sıfır verildiğinde çağrıldığı görevin mutlak önceliğini <parameter>param</parameter> ile, zamanlama kuralını <parameter>policy</parameter> ile belirtilen değere ayarlar. Eğer <parameter>policy</parameter> negatifse işlev mevcut zamanlama kuralını değiştirmez.
    </para>
    <para>
     İşlevin <parameter>policy</parameter> bağımsız değişkeninde belirtilebilecek değerler şunlardır:
    </para>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-SCHED_OTHER"><primary>SCHED_OTHER</primary></indexterm>
     <csproto type="sabit">
      <csname><function>SCHED_OTHER</function></csname>
     </csproto>
     <para>
      Geleneksel zamanlama.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-SCHED_FIFO"><primary>SCHED_FIFO</primary></indexterm>
     <csproto type="sabit">
      <csname><function>SCHED_FIFO</function></csname>
     </csproto>
     <para>
      İlk gelen alır.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-SCHED_RR"><primary>SCHED_RR</primary></indexterm>
     <csproto type="sabit">
      <csname><function>SCHED_RR</function></csname>
     </csproto>
     <para>
      Döner turnuva.
     </para>
    </csynopsis>
    <para>
     İşlevin normal dönüş değeri sıfırdır, <code>-1</code> dönüş değeri bir hata oluştuğunu gösterir. Bu işlev için tanımlanmış <varname>errno</varname> hata durumu:
    </para>
    <glosslist>
     <glossentry>
      <glossterm><code>EPERM</code></glossterm>
      <glossdef>
       <simplelist>
        <member>
         Çağıran görev <varname>CAP_SYS_NICE</varname> yetkisine sahip değil ve  <parameter>policy</parameter> değeri <varname>SCHED_OTHER</varname> değil (ya da değeri negatif ve geçerli kural <varname>SCHED_OTHER</varname> değil).
        </member>
        <member>
         Çağıran görev <varname>CAP_SYS_NICE</varname> yetkisine sahip değil ve sahibi hedef görevin sahibi değil. Yani çağıran görevin etkin kullanıcı kimliği <parameter>pid</parameter> kimlikli görevin ne etkin ne de gerçek kullanıcı kimliğidir.
        </member>
       </simplelist>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm><code>ESRCH</code></glossterm>
      <glossdef>
       <para>
        <parameter>pid</parameter> sıfırdan farklı olduğu halde <parameter>pid</parameter> kimlikli bir görev yok.
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm><code>EINVAL</code></glossterm>
      <glossdef>
       <simplelist>
        <member>
         <parameter>policy</parameter> geçerli bir zamanlama kuralını ifade etmiyor.
        </member>
        <member>
         *<parameter>param</parameter> ile belirtilen mutlak öncelik <parameter>policy</parameter> zamanlama kuralı için (ya da <parameter>policy</parameter> negatifse geçerli zamanlama kuralı için) geçerli aralığın dışında ya da <parameter>param</parameter> boş gösterici. Geçerli aralığın ne olduğu <function>sched_get_priority_max</function> ve <function>sched_get_priority_min</function> işlevleri ile öğrenilebilir.
        </member>
        <member>
         <parameter>pid</parameter> negatif.
        </member>
       </simplelist>
      </glossdef>
     </glossentry>
    </glosslist>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-sched_getscheduler"><primary>sched_getscheduler</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>sched_getscheduler</function></csname>
     <csparam><type>pid_t</type><parameter>pid</parameter></csparam>
    </csproto>
    <header>&sched.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     Görev kimliği <parameter>pid</parameter> olan görevin ya da <parameter>pid</parameter> olarak sıfır verildiğinde çağrıldığı göreve atanmış zamanlama kuralını döndürür.
    </para>
    <para>
     İşlevin normal dönüş değeri zamanlama kuralıdır. Olası değerler için bkz. <function>sched_setscheduler</function>.
    </para>
    <para>
     İşlev başarısız olursa <code>-1</code> döner ve <varname>errno</varname> değişkenine şu hata durumlarından biri atanır:
    </para>
    <variablelist>
     <varlistentry>
      <term><code>ESRCH</code></term>
      <listitem>
       <para>
        <parameter>pid</parameter> sıfırdan farklı ve böyle bir görev yok.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>EINVAL</code></term>
      <listitem>
       <para>
        <varname>pid</varname> negatif.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
    <para>
     Bu işlevin <function>sched_setscheduler</function> işlevinin tam karşılığı olmadığına dikkat edilmelidir, <function>sched_setscheduler</function> işlevi hem zamanlama kuralını hem de mutlak önceliği belirlemek için kullanılabilirken bu işlev sadece zamanlama kuralını döndürür. Mutlak önceliği öğrenmek için  <function>sched_getparam</function> işlevi kullanılabilir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-sched_setparam"><primary>sched_setparam</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>sched_setparam</function></csname>
     <csparam><type>pid_t</type><parameter>pid</parameter></csparam>
     <csparam><ptr>const&#160;struct&#160;sched_param</ptr><parameter>param</parameter></csparam>
    </csproto>
    <header>&sched.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     Bu işlev görevin mutlak önceliğini değiştirmekte kullanılır.
    </para>
    <para>
     İşlevselliği <parameter>policy</parameter> = <code>-1</code> olduğunda <function>sched_setscheduler</function> işlevindeki ile aynıdır.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-sched_getparam"><primary>sched_getparam</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>sched_getparam</function></csname>
     <csparam><type>pid_t</type><parameter>pid</parameter></csparam>
     <csparam><ptr>struct&#160;sched_param</ptr><parameter>param</parameter></csparam>
    </csproto>
    <header>&sched.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     Bu işlev görevin mutlak önceliği ile döner.
    </para>
    <para>
     <parameter>pid</parameter>, mutlak önceliği öğrenilmek istenen görevin görev kimliğidir.
    </para>
    <para>
     <parameter>param</parameter> ise görevin mutlak önceliğini içeren yapıya bir göstericidir.
    </para>
    <para>
     Başarı durumunda işlevin dönüş değeri <code>0</code>'dır. Aksi takdirde <code>-1</code> döner ve <varname>errno</varname> değişkenine şu değerler biri atanır:
    </para>
    <variablelist>
     <varlistentry>
      <term><code>ESRCH</code></term>
      <listitem>
       <para>
        <parameter>pid</parameter> sıfırdan farklı ve böyle bir görev yok.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>EINVAL</code></term>
      <listitem>
       <para>
        <parameter>pid</parameter> negatif.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-sched_get_priority_min"><primary>sched_get_priority_min</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>sched_get_priority_min</function></csname>
     <csparam><type>int</type><parameter>policy</parameter></csparam>
    </csproto>
    <header>&sched.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     Bu işlev <parameter>policy</parameter> zamanlama kuralı için bir görevin alabileceği en düşük mutlak öncelik değeri ile döner.
    </para>
    <para>
     Linux'ta, <varname>SCHED_OTHER</varname> için <code>0</code> diğerleri için <code>1</code>'dir.
    </para>
    <para>
     Başarı durumunda işlevin dönüş değeri <code>0</code>'dır. Aksi takdirde <code>-1</code> döner ve <varname>errno</varname> değişkenine şu değerler biri atanır:
    </para>
    <variablelist>
     <varlistentry>
      <term><code>EINVAL</code></term>
      <listitem>
       <para>
        <parameter>policy</parameter> mevcut bir zamanlama kuralı değil.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-sched_get_priority_max"><primary>sched_get_priority_max</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>sched_get_priority_max</function></csname>
     <csparam><type>int</type><parameter>policy</parameter></csparam>
    </csproto>
    <header>&sched.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     Bu işlev <parameter>policy</parameter> zamanlama kuralı için bir görevin alabileceği en yüksek mutlak öncelik değeri ile döner.
    </para>
    <para>
     Linux'ta, <varname>SCHED_OTHER</varname> için <code>0</code> diğerleri için <code>99</code>'dur.
    </para>
    <para>
     Başarı durumunda işlevin dönüş değeri <code>0</code>'dır. Aksi takdirde <code>-1</code> döner ve <varname>errno</varname> değişkenine şu değerler biri atanır:
    </para>
    <variablelist>
     <varlistentry>
      <term><code>EINVAL</code></term>
      <listitem>
       <para>
        <parameter>policy</parameter> mevcut bir zamanlama kuralı değil.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-sched_rr_get_interval"><primary>sched_rr_get_interval</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>sched_rr_get_interval</function></csname>
     <csparam><type>pid_t</type><parameter>pid</parameter></csparam>
     <csparam><ptr>struct&#160;timespec</ptr><parameter>interval</parameter></csparam>
    </csproto>
    <header>&sched.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     Bu işlev turnuva zamanlama kuralı kullanıldığında <parameter>pid</parameter> kimlikli görevin işlemciyi kullanabileceği süreyi döndürür.
    </para>
    <para>
     Sonuç <parameter>interval</parameter> ile döner.
    </para>
    <para>
     Linux çekirdeği için turnuva zaman dilimi daima 150 mikrosaniyedir ve  <parameter>pid</parameter> değerinin gerçek bir görev kimliği olması bile gerekmez.
    </para>
    <para>
     Başarı durumunda işlevin dönüş değeri <code>0</code>'dır. Aksi takdirde, imkansız olsa bile <code>-1</code> dönebilir. Ancak <varname>errno</varname> değişkenine atanmak üzere belirlenmiş bu işleve özgü özel bir hata durumu yoktur.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-sched_yield"><primary>sched_yield</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>sched_yield</function></csname>
     <csparam><void/></csparam>
    </csproto>
    <header>&sched.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     Bu işlev, görevin işlemci üzerindeki haklarından vazgeçilmesini sağlar.
    </para>
    <para>
     Teknik olarak, <code>sched_yield</code> işlevi görevin hemen tekrar çalışmaya hazır duruma (işlev çağrıldığında çalışmakta olmanın tersine) gelmesine sebep olur. Yani, görevin mutlak önceliği sıfırdan farklıysa, mutlak önceliği ile aynı olan görevlerin bulunduğu görev listesinin kuyruğuna çalışmaya hazır görev olarak eklenip sırasının gelmesini bekler. Mutlak önceliği sıfırsa bu işlem daha karmaşıklaşır, ancak işlemcinin başka bir göreve bırakılması yine de gerçekleşir.
    </para>
    <para>
     Eğer mutlak öncelik bakımından eşdeğerde başka bir görev yoksa bu işlev hiçbir şey yapmaz.
    </para>
    <para>
     İşlevi içeren görev açısından görev, başka bir görevin ne yaptığı ya da ne kadar hızlı çalıştığının farkında değildir, işlev bu bakımdan işlevsizdir.
    </para>
    <para>
     Başarı durumunda işlevin dönüş değeri <code>0</code>'dır. Aksi takdirde, imkansız olsa bile <code>-1</code> dönebilir. Ancak <varname>errno</varname> değişkenine atanmak üzere belirlenmiş bu işleve özgü özel bir hata durumu yoktur.
    </para>
   </csynopsis>
  </sect1>
  <sect1 xml:id="glibc-Traditional-Scheduling">
   <title>Geleneksel Zamanlama</title>
   <titleabbrev>Kaba yığınlar arasında zamanlama</titleabbrev>
   <preliminary>
    <para>
     <indexterm linkend="glibc-cp"><primary>zamanlama</primary><secondary>geleneksel</secondary></indexterm>
     Bu bölüm mutlak önceliği sıfır olan süreçlerin zamanlanması hakkındadır. Yüksek mutlak öncelikli süreçler istediklerini aldıktan sonra geriye kalan işlemci zamanı artıkları, burada tanımlanan zamanlama kuralına göre el değmemiş irice süreçler arasında paylaştırılır.
    </para>
   </preliminary>
   <sect2 xml:id="glibc-Traditional-Scheduling-Intro">
    <title>Geleneksel Zamanlamaya Giriş</title>
    <para>
     <link linkend="glibc-Absolute-Priority">Mutlak öncelikler</link> ortaya çıkmadan çok önceleri Unix sistemleri işlemci zamanlamasını bu şekilde yapıyordu. POSIX Romalılar gibi çıkagelip gerçek zamanlı işlemin gereksinimlerini karşılamak üzere Mutlak Öncelikleri ortaya attı ve yöreye özgü Sıfır Mutlak Öncelikli süreçlerin kendilerini kendi bildikleri zamanlama kurallarına göre yönetmelerine izin verdi.
    </para>
    <para>
     Gerçekten, sıfırdan büyük mutlak öncelikler, esas olarak gerçek zamanlı işlem yapmak üzere tasarlanmış bilgisayarların sistemleri dışında günümüzdeki çoğu sistemde kullanılmamaktadır. Bu bakımdan, bu bölümde sadece çoğu yazılımcının bilmek istediği zamanlamadan söz edilecektir.
    </para>
    <para>
     Bu zamanlamanın kapsamı hakkında daha temiz bir giriş olarak: Herhangi bir anda mutlak önceliği sıfır olan bir süreç ile mutlak önceliği sıfırdan büyük bir süreç aynı anda çalışmaya hazırsa, mutlak önceliği sıfır olan çalışmaz. Eğer mutlak önceliği sıfır olan bir süreç çalışmaktayken mutlak önceliği sıfırdan büyük bir süreç çalışmaya hazır olursa mutlak önceliği sıfır olanın çalışması hemen durdurulur.
    </para>
    <para>
     Mutlak önceliği sıfır olma durumuna ek olarak, sürecin çalışması esnasında değişen bir öncelik olarak <wordasword>özdevimli öncelik</wordasword> olarak bilinen bir öncelik daha vardır. Mutlak önceliği sıfırdan büyük süreçler için özdevimli öncelik anlamlı değildir.
    </para>
    <para>
     Özdevimli öncelik kimi zaman işlemciyi kimin alacağını, kimi zaman işlemciyi ne kadar süreyle kullanacağını, kimi zaman da bir sürecin başka bir süreci işlemciden kovup kovamayacağını belirler.
    </para>
    <para>
     Linux'ta, değer bunların bir karışımı olarak ortaya çıkar. Fakat çoğunlukla bu değer sürecin işlemciyi kullanma süresini belirler.   Özdevimli önceliği daha yüksek olan süreç, işlemciyi bir kere aldı mı, daha uzun süre onu kullanır. Eğer, G/Ç beklemek gibi şeyler yapmak için kendi zaman dilimi içinde işini bitiremezse, tekrar hazır olduğunda kendi zaman dilimini tamamlamak üzere işlemciyi alması için öne alınır. Bunun dışında, yeni zaman dilimleri için süreçlerin seçimi temel olarak turnuva sistemine göre yapılır. Fakat zamanlayıcı düşük öncelikli süreçlere bir kemik atar: Bir sürecin özdevimli önceliği, zamanlama işleminde her aşağılanışında yükselir. Linux'ta, oyunu hep şişko velet kazanır.
    </para>
    <para>
     Bir sürecin özdevimli önceliğinin iniş çıkışları başka bir değerle düzene sokulur: <wordasword>nezaket değeri</wordasword> (ing.si "nice value" olan değer). Nezaket değeri bir tamsayıdır ve -20 ile 20 arasında olup, bir sürecin özdevimli önceliğinin uç değerlerini ifade eder. Daha yüksek bir nezaket daha düşük bir sınır gösterir.
    </para>
    <para>
     Tipik bir Linux sisteminde, örneğin, nezaket değeri 20 olan bir süreç işlemci zamanının sadece 10 milisaniyesini alabilir, -20 olan bir süreç ise daha yüksek bir öncelikle işlemci zamanının 400 milisaniyesini alabilecektir.
    </para>
    <para>
     Nezaket değeri gerçekten bir kibarlık, saygılılık belirtir. Başlarda, Unix'in cennet bahçesinde, tüm süreçler bilgisayar sisteminin nimetlerini eşit olarak paylaşırdı. Ama tüm süreçler aynı işlemci zamanını paylaşma ihtiyacı göstermez, bu durumda nezaket değeri, diğer süreçler yararına kibar bir sürecin payına düşen işlemci süresinden feragat etmesini sağlar. Dolayısıyla, nezaket değeri daha yüksek olan süreç daha kibar süreç olur. (Bir yılan geldi ve bir sürece bir negatif nezaket değeri sundu böylece bugün kaba öz kaynak ayırma sistemi olarak bildiğimiz sistem ortaya çıktı).
    </para>
    <para>
     Özdevimli öncelikler işlemci zamanının ayrılmasını nesnel olarak pürüzsüzleştirerek ve seyrek isteklere hızlı yanıt vererek yukarı ve aşağı doğru meyleder. Fakat kendi nezaket sınırlarını asla aşmaz, böylece işlemcinin ağır yük altında olduğu durumda nezaket değeri etkin olarak bir sürecin ne kadar hızlı çalışacağını belirler.
    </para>
    <para>
     Unix süreç önceliğinin toplumcu mirasına uymak için, bir süreç kendini çalıştıran süreçle aynı nezaket değeri ile oluşur ve onu yükseltebilir. Bir süreç ayrıca sahibi aynı kullanıcı olan (ya da aynı etkin kimlikli) başka bir sürecin de nezaket değerini yükseltebilir. Fakat sadece ayrıcalıklı süreç kendi nezaket değerini düşürebilir. Bir ayrıcalıklı süreç ayrıca başka bir sürecin nezaket değerini de artırıp azaltabilir.
    </para>
    <para>
     Nezaket değerlerini öğrenmek ve belirlemek için kullanılan &glibc; işlevleri <xref linkend="glibc-Traditional-Scheduling-Functions"/> bölümünde açıklanmıştır.
    </para>
   </sect2>
   <sect2 xml:id="glibc-Traditional-Scheduling-Functions">
    <title>Geleneksel Zamanlama İşlevleri</title>
    <titleabbrev>Nezaket değerleri ile ilgili işlevler.</titleabbrev>
    <para>
     <indexterm linkend="glibc-pg"><primary>sys/resource.h</primary></indexterm>
     Bu bölümde bir sürecin nezaket değerinin nasıl okunabileceğinden ve nasıl belirtilebileceğinden bahsedilecektir. Bu simgelerin tamamı &sys-resource.h; başlık dosyasında bildirilmiştir.
    </para>
    <para>
     İşlev ve makro isimleri POSIX tarafından tanımlanmıştır. POSIX'te ve bu kılavuzda isimlendirme için "öncelik" (priority) terimi kullanılmış olmasına rağmen işlevler aslında nezaket değerleri ile işlem yaparlar.
    </para>
    <para>
     Geçerli nezaket değerleri çekirdeğe bağlı olmasına rağmen, genellikle  <code>-20</code> ile <code>20</code> arasındadır.  Daha düşük bir nezaket değeri daha yüksek önceliğe karşılıktır. Öncelik değerlerinin aralığını belirleyen sabitler şunlardır:
    </para>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-PRIO_MIN"><primary>PRIO_MIN</primary></indexterm>
     <csproto type="sabit">
      <csname><function>PRIO_MIN</function></csname>
     </csproto>
     <header>&sys-resource.h;</header>
     <para>
      Geçerli en düşük nezaket değeri.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-PRIO_MAX"><primary>PRIO_MAX</primary></indexterm>
     <csproto type="sabit">
      <csname><function>PRIO_MAX</function></csname>
     </csproto>
     <header>&sys-resource.h;</header>
     <para>
      Geçerli en yüksek nezaket değeri.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-fn" xml:id="glibc-fn-getpriority"><primary>getpriority</primary></indexterm>
     <csproto type="işlev">
      <csname><type>int</type><function>getpriority</function></csname>
      <csparam><type>int</type><parameter>class</parameter></csparam>
      <csparam><type>int</type><parameter>id</parameter></csparam>
     </csproto>
     <header>&sys-resource.h;</header>
     <conceptlist>
      <concept>&mtsafe;</concept>
      <concept>&assafe;</concept>
      <concept>&acsafe;</concept>
     </conceptlist>
     <para>
      Bir süreç kümesinin nezaket değerini döndürür; <parameter>class</parameter> ve <parameter>id</parameter> hangisi olduğunu belirtir (aşağıya bakınız). Eğer belirtilen süreçlerin hepsi aynı nezaket değerine sahip değilse, işlev bunların içinden en düşük nezaket değerini döndürür.
     </para>
     <para>
      Hata oluşmuşsa <code>-1</code> döner ve <varname>errno</varname> değişkenine hata durumu atanır, yoksa dönen değer nezaket değeridir.  Aşağıdaki <varname>errno</varname> hata durumları bu işlev için tanımlanmıştır:
     </para>
     <variablelist>
      <varlistentry>
       <term><code>ESRCH</code></term>
       <listitem>
        <para>
         <parameter>class</parameter> ve <parameter>id</parameter> birlikte  herhangi bir mevcut süreçle uyuşmuyor.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><code>EINVAL</code></term>
       <listitem>
        <para>
         <parameter>class</parameter> değeri geçersiz.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
     <para>
      Dönen değer <code>-1</code> olduğunda, bunun bir başarısızlık mı yoksa bir nezaket değeri mi olduğunu anlayabilmek için tek yol <code>getpriority</code> çağrısından önce <code>errno = 0</code> ataması yapmaktır. Çağrının ardından <code>errno != 0</code> ile başarısızlık sınaması yapılabilir.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-fn" xml:id="glibc-fn-setpriority"><primary>setpriority</primary></indexterm>
     <csproto type="işlev">
      <csname><type>int</type><function>setpriority</function></csname>
      <csparam><type>int</type><parameter>class</parameter></csparam>
      <csparam><type>int</type><parameter>id</parameter></csparam>
      <csparam><type>int</type><parameter>niceval</parameter></csparam>
     </csproto>
     <header>&sys-resource.h;</header>
     <conceptlist>
      <concept>&mtsafe;</concept>
      <concept>&assafe;</concept>
      <concept>&acsafe;</concept>
     </conceptlist>
     <para>
      Bir süreç kümesinin nezaket değerini <parameter>niceval</parameter> değerine ayarlar; <parameter>class</parameter> ve <parameter>id</parameter> hangisi olduğunu belirler (aşağıya bakınız).
     </para>
     <para>
      İşlev başarılı olursa <code>0</code> ile döner.  Hata oluşmuşsa <code>-1</code> döner ve <varname>errno</varname> değişkenine hata durumu atanır.  Aşağıdaki <varname>errno</varname> hata durumları bu işlev için tanımlanmıştır:
     </para>
     <variablelist>
      <varlistentry>
       <term><code>ESRCH</code></term>
       <listitem>
        <para>
         <parameter>class</parameter> ve <parameter>id</parameter> birlikte  herhangi bir mevcut süreçle uyuşmuyor.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><code>EINVAL</code></term>
       <listitem>
        <para>
         <parameter>class</parameter> değeri geçersiz.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><code>EPERM</code></term>
       <listitem>
        <para>
         Çağrı, sahibi çağıran süreçten farklı bir kulllanıcıya ait bir sürecin nezaket değerini değiştirmeye çalışıyor (yani, hedef sürecin gerçek ya da etkin kullanıcı kimliği, işlevi çağıran sürecin ektin kullanıcı kimliği ile aynı değil) ve işlevi çağıran süreç <varname>CAP_SYS_NICE</varname> yetkisine sahip değil.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><code>EACCES</code></term>
       <listitem>
        <para>
         Çağrı daha düşük bir nezaket değeri isteği yaptı ama sürecin <varname>CAP_SYS_NICE</varname> yetkisi yok.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </csynopsis>
    <para>
     <parameter>class</parameter> ve <parameter>id</parameter> bağımsız değişkenleri birlikte ilgilenilen süreç kümesini belirler. <parameter>class</parameter> için olası değerler şunlardır:
    </para>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-PRIO_PROCESS"><primary>PRIO_PROCESS</primary></indexterm>
     <csproto type="sabit">
      <csname><function>PRIO_PROCESS</function></csname>
     </csproto>
     <header>&sys-resource.h;</header>
     <para>
      Belirli bir süreç. <parameter>id</parameter> sürecin süreç kimliğidir.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-PRIO_PGRP"><primary>PRIO_PGRP</primary></indexterm>
     <csproto type="sabit">
      <csname><function>PRIO_PGRP</function></csname>
     </csproto>
     <header>&sys-resource.h;</header>
     <para>
      Belirli bir süreç grubundaki bütün süreçler. <parameter>id</parameter> süreç grup kimliğidir.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-PRIO_USER"><primary>PRIO_USER</primary></indexterm>
     <csproto type="sabit">
      <csname><function>PRIO_USER</function></csname>
     </csproto>
     <header>&sys-resource.h;</header>
     <para>
      Belirli bir kullanıcıya ait olan tüm süreçler (yani, gerçek kullanıcı kimliği, kullanıcı ile aynı olan süreçler). <parameter>id</parameter> kullanıcının kullanıcı kimliğidir.
     </para>
    </csynopsis>
    <para>
     <parameter>id</parameter> değeri sıfırsa, çağıran süreci belirtir, süreç grubu ya da sürecin sahibi <parameter>class</parameter> ile belirtilir.
    </para>
    <csynopsis>
     <indexterm linkend="glibc-fn" xml:id="glibc-fn-nice"><primary>nice</primary></indexterm>
     <csproto type="işlev">
      <csname><type>int</type><function>nice</function></csname>
      <csparam><type>int</type><parameter>increment</parameter></csparam>
     </csproto>
     <header>&sys-resource.h;</header>
     <conceptlist>
      <concept>&mtunsafe; &race;<code linkend="glibc-safety-identifier">:setpriority</code></concept>
      <concept>&asunsafe;</concept>
      <concept>&acsafe;</concept>
     </conceptlist>
     <para>
      Çağıran sürecin nezaket değerini <parameter>increment</parameter> kadar artırır. İşlev başarılı olursa yeni nezaket değeri ile döner. <code>-1</code> dönüş değeri ise bir hata oluştuğunu gösterir. Bu durumda <varname>errno</varname> değişkenine <function>setpriority</function> işlevindeki değerler atanır.
     </para>
     <example>
      <para>
       <code>nice</code> işlevine eşdeğer bir işlev tanımı:
      </para>
      <screen>int
nice (int increment)
{
  int result, old = getpriority (PRIO_PROCESS, 0);
  result = setpriority (PRIO_PROCESS, 0, old + increment);
  if (result != -1)
      return old + increment;
  else
      return -1;
}
</screen>
     </example>
    </csynopsis>
   </sect2>
  </sect1>
  <sect1 xml:id="glibc-CPU-Affinity">
   <title>İşlemciler Arasında İcra Sınırlaması</title>
   <para>
    Çok işlemcili bir sistemde, işletim sistemi sistemin en verimli çalışmasını mümkün kılan bir yolla farklı süreçleri mevcut işlemcilere dağıtır. Zamanlama işlevselliğini genişleterek hangi süreçlerin ve evrelerin çalışabileceği geçtiğimiz bölümlerde açıklanmıştı.  Fakat hangi işlemcinin sonuçta hangi süreç ya da evreyi çalıştıracağı incelenmemişti.
   </para>
   <para>
    Bir yazılımın sistemi bu bakımdan denetimi altına almak zorunda bırakan bazı sebepler vardır:
   </para>
   <itemizedlist>
    <listitem>
     <para>
      Mutlak olarak kritik bir işlemi yürütmekte olan bir süreç ya da evre hiçbir şart altında durdururulmamalı veya işlemci öz kaynakları kullanılarak başka süreçler tarafından engellenmemelidir. Bu durumda özel süreç için, hiçbir süreç ya da evre tarafından kullanılmasına izin verilmeyen bir işlemci tahsis edilmelidir.
     </para>
    </listitem>
    <listitem>
     <para>
      Belirli öz kaynaklara (RAM, G/Ç portları) farklı işlemcilerden erişim maliyetleri farklıdır. Böyle bir duruma NUMA (Non-Uniform Memory Architecture -- Tektip olmayan bellek mimarisi) makinelerde rastlanır. Tercihan, belleğe yerel olarak erişilmelidir fakat bu gereksinim genelde zamanlayıcıya görünür değildir. Bundan dolayı kullanılan belleğe yerel erişime sahip işlemcilerin belli bir sürece ya da evreye ayrılması başarımın belirgin biçimde artmasına yardımcı olur.
     </para>
    </listitem>
    <listitem>
     <para>
      Çalışma anında denetim altında öz kaynak ayrılması ve toparlama çalışmalarında (örn, çöp toplama) başarım işlemcilerin yerel işlem yapmasına bağlıdır. Eğer öz kaynaklar farklı işlemcilerin rasgele erişimine karşı korunmamışsa, bu, kilitleme maliyetlerini düşürmeye yardımcı olur.
     </para>
    </listitem>
   </itemizedlist>
   <para>
    Şimdiye kadar POSIX standardı bu sorunun çözümüne pek yardımcı olmadı. Linux çekirdeği, bir işlemci için <wordasword>akrabalık kümeleri</wordasword> belirtilmesini mümkün kılan bir arayüz ailesi sağlar. Zamanlayıcı süreç ya da evreyi işlemciler üzerinde belirtilen akrabalık maskesine göre zamanlar. &glibc;ndeki arayüzler Linux çekirdeğindeki arayüz biraz genişletilerek tanımlanmıştır.
   </para>
  <csynopsis>
   <indexterm linkend="glibc-tp" xml:id="glibc-tp-cpu_set_t"><primary>cpu_set_t</primary></indexterm>
   <indexterm xml:id="glibc-cp-cpu_set_t" linkend="glibc-cp"><primary>işlemciler</primary><secondary>veri yapısı</secondary></indexterm>
   <csproto type="veri türü">
    <csname><function>cpu_set_t</function></csname>
   </csproto>
   <header>&sched.h;</header>
   <para>
    Bu veri türü her biri bir işlemciyi ifade eden bit kümesidir. İşlemcilerin bit kümesinin hangi bitleriyle eşleneceği sisteme bağlıdır. Veri türünün genişliği sabittir; sistemdeki işlemcileri ifade etmek için veri türünün genişliğini yetersiz kaldığı durumda başka bir arayüz kullanılmalıdır.
   </para>
   <para>
    Bu veri türü GNU oluşumudur.
   </para>
  </csynopsis>
  <para>
   Bit kümesiyle çalışmak, bitleri belirtmek ve sıfırlamak için bazı makrolar tanımlanmıştır. Makroların bazıları bağımsız değişken olarak bir işlemci numarası alır. Burada önemli olan bit kümesi genişliğinin aşılmamasıdır. Bu makro <type>cpu_set_t</type> bit kümesindeki bitlerin sayısını belirler:
  </para>
  <csynopsis>
   <indexterm linkend="glibc-vr" xml:id="glibc-vr-CPU_SETSIZE"><primary>CPU_SETSIZE</primary></indexterm>
   <csproto type="makro">
    <csname><type>int</type><function>CPU_SETSIZE</function></csname>
   </csproto>
   <header>&sched.h;</header>
   <para>
    Bir <type>cpu_set_t</type> nesnesi ile elde edilebilecek işlemci sayısıdır.
   </para>
  </csynopsis>
  <para>
   <type>cpu_set_t</type> veri türü şeffaf olmadığından bu veri türü ile ilgili çalışmalar aşağıdaki dört makro ile yürütülmelidir.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-CPU_ZERO"><primary>CPU_ZERO</primary></indexterm>
   <csproto type="makro">
    <csname><type>void</type><function>CPU_ZERO</function></csname>
    <csparam><ptr>cpu_set_t</ptr><parameter>set</parameter></csparam>
   </csproto>
   <header>&sched.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    Bu makro <parameter>set</parameter> işlemci kümesini bir boş küme olarak ilklendirir.
   </para>
   <para>
    Bu makro GNU oluşumudur.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-CPU_SET"><primary>CPU_SET</primary></indexterm>
   <csproto type="makro">
    <csname><type>void</type><function>CPU_SET</function></csname>
    <csparam><type>int</type><parameter>cpu</parameter></csparam>
    <csparam><ptr>cpu_set_t</ptr><parameter>set</parameter></csparam>
   </csproto>
   <header>&sched.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <parameter>cpu</parameter> işlemcisini <parameter>set</parameter> işlemci kümesine ekler.
   </para>
   <para>
    Defalarca işleme sokulacağından <parameter>cpu</parameter> bağımsız değişkeninin yan etkilere sebep olmayacak şekilde belirtilmesi önemlidir.
   </para>
   <para>
    Bu makro GNU oluşumudur.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-CPU_CLR"><primary>CPU_CLR</primary></indexterm>
   <csproto type="makro">
    <csname><type>void</type><function>CPU_CLR</function></csname>
    <csparam><type>int</type><parameter>cpu</parameter></csparam>
    <csparam><ptr>cpu_set_t</ptr><parameter>set</parameter></csparam>
   </csproto>
   <header>&sched.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <parameter>cpu</parameter> işlemcisini <parameter>set</parameter> işlemci kümesinden kaldırır.
   </para>
   <para>
    Defalarca işleme sokulacağından <parameter>cpu</parameter> bağımsız değişkeninin yan etkilere sebep olmayacak şekilde belirtilmesi önemlidir.
   </para>
   <para>
    Bu makro GNU oluşumudur.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-CPU_ISSET"><primary>CPU_ISSET</primary></indexterm>
   <csproto type="makro">
    <csname><type>int</type><function>CPU_ISSET</function></csname>
    <csparam><type>int</type><parameter>cpu</parameter></csparam>
    <csparam><ptr>const&nbsp;cpu_set_t</ptr><parameter>set</parameter></csparam>
   </csproto>
   <header>&sched.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    Eğer <parameter>cpu</parameter> işlemcisi <parameter>set</parameter> işlemci kümesinin bir üyesi ise bu makro sıfırdan farklı bir değerle (doğru), değilse sıfırla (yanlış) döner.
   </para>
   <para>
    Defalarca işleme sokulacağından <parameter>cpu</parameter> bağımsız değişkeninin yan etkilere sebep olmayacak şekilde belirtilmesi önemlidir.
   </para>
   <para>
    Bu makro GNU oluşumudur.
   </para>
  </csynopsis>
  <para>
   İşlemci bit kümeleri ya sıfırdan oluşturulur ya da o an kurulu bir akrabalık maskesi olarak sistemden alınır.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-sched_getaffinity"><primary>sched_getaffinity</primary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>sched_getaffinity</function></csname>
    <csparam><type>pid_t</type><parameter>pid</parameter></csparam>
    <csparam><type>size_t</type><parameter>cpusetsize</parameter></csparam>
    <csparam><ptr>cpu_set_t</ptr><parameter>cpuset</parameter></csparam>
   </csproto>
   <header>&sched.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    Bu işlev işlemci akrabalık maskesini kimliği <parameter>pid</parameter> ile belirtilen süreç ya da evre için genişliği <parameter>cpusetsize</parameter> bayt olarak belirtilen ve <parameter>cpuset</parameter> ile gösterilen bir nesne olarak döndürür. İşlev başarılı olduğunda daima <type>cpu_set_t</type> nesnesindeki tüm bitleri ilklendirir ve sıfırla döner.
   </para>
   <para>
    <parameter>pid</parameter> bir süreç ya da evreye karşılık değilse ya da işlev bir sebeple başarısız olmuşsa <code>-1</code> ile döner ve <varname>errno</varname> değişkenine hata durumu atanır.
   </para>
   <variablelist>
     <varlistentry>
      <term><code>ESRCH</code></term>
      <listitem>
       <para>
        Belirtilen kimliğe sahip bir süreç ya da evre yok.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>EFAULT</code></term>
      <listitem>
       <para>
        <parameter>cpuset</parameter> göstericisi geçerli bir nesneyi göstermiyor.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   <para>
    Bu işlev GNU oluşumudur.
   </para>
  </csynopsis>
  <para>
   Bu bilginin, farklı POSIX evreleri ile ilgili bilgi almak amacıyla kullanılmasının büyük ihtimalle taşınabilir olmayacağına dikkat edilmelidir. Bu durum için başka bir arayüz sağlanmalıdır.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-sched_setaffinity"><primary>sched_setaffinity</primary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>sched_setaffinity</function></csname>
    <csparam><type>pid_t</type><parameter>pid</parameter></csparam>
    <csparam><type>size_t</type><parameter>cpusetsize</parameter></csparam>
    <csparam><ptr>const&nbsp;cpu_set_t</ptr><parameter>cpuset</parameter></csparam>
   </csproto>
   <header>&sched.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    Bu işlev işlemci akrabalık maskesini kimliği <parameter>pid</parameter> ile belirtilen süreç ya da evre için genişliği <parameter>cpusetsize</parameter> bayt olarak belirtilen ve <parameter>cpuset</parameter> ile gösterilen bir nesneye göre belirler. İşlev başarılı olduğunda sıfırla dönecek ve zamanlayıcı bu akrabalık bilgisini gelecekte hesaba katacaktır.
   </para>
   <para>
    İşlev bir sebeple başarısız olmuşsa <code>-1</code> ile döner ve <varname>errno</varname> değişkenine hata durumu atanır.
   </para>
   <variablelist>
     <varlistentry>
      <term><code>ESRCH</code></term>
      <listitem>
       <para>
        Belirtilen kimliğe sahip bir süreç ya da evre yok.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>EFAULT</code></term>
      <listitem>
       <para>
        <parameter>cpuset</parameter> göstericisi geçerli bir nesneyi göstermiyor.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>EINVAL</code></term>
      <listitem>
       <para>
        Bit kümesi geçersiz. Bu, akrabalık kümesindeki bir işlemcinin süreç ya da evre için bırakılmamış olabileceği anlamına gelebilir.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   <para>
    Bu işlev GNU oluşumudur.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-getcpu"><primary>getcpu</primary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>getcpu</function></csname>
    <csparam><ptr>unsigned&nbsp;int</ptr><parameter>cpu</parameter></csparam>
    <csparam><ptr>unsigned&nbsp;int</ptr><parameter>node</parameter></csparam>
   </csproto>
   <header>&sched.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <code>getcpu</code> işlevi, çağrıldığı evrenin veya sürecin o an üzerinde çalıştığı işlemciyi ve düğümü tanımlar ve bunları <parameter>cpu</parameter> ve <parameter>node</parameter> ile gösterilen tamsayılara yazar. <parameter>cpu</parameter>, bir işlemciyi tanımlayan benzersiz, negatif olmayan bir tamsayıdır. <parameter>node</parameter>, bir NUMA düğümünü tanımlayan benzersiz, negatif olmayan bir tamsayıdır. <parameter>cpu</parameter> veya <parameter>node</parameter> <varname>NULL</varname> olduğunda, ilgili göstericiye hiçbir şey yazılmaz.
   </para>
   <para>
    İşlev bir sebeple başarısız olmuşsa <code>-1</code> ile döner ve <varname>errno</varname> değişkenine hata durumu atanır.
   </para>
   <variablelist>
     <varlistentry>
      <term><code>ENOSYS</code></term>
      <listitem>
       <para>
        İşletim sistemi bu işlevi desteklemiyor.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
    <para>
     Bu işlev Linux'a özgüdür.
    </para>
   </csynopsis>
  </sect1>
 </chapter>
 <chapter xml:id="glibc-Memory-Resources" userlevel="notoc">
  <?dbhtml stop-chunking?>
  <title>Bellek Öz Kaynakları</title>
  <titleabbrev>Bellekle ilgili öz kaynakların sorgulanması</titleabbrev>
  <preliminary>
   <para>
    Sistemdeki mevcut belleğin miktarı ve belleğin düzenlenmesi sıklıkla yazılımların yapabileceklerine ve çalışabilmelerine bağlı olarak belirlenir. <function>mmap</function> gibi işlevler açısından her bir bellek sayfasının boyutunun bilinmesi ve bir yazılımın ne kadar belleği arabellekler gibi seçimler için kullanabileceğinin bilinmesi gereklidir. Bu tür ayrıntılara dalmadan önce geleneksel Unix sistemlerindeki bellek alt sisteminden biraz bahsetmek gerekir.
   </para>
  </preliminary>
  <sect1 xml:id="glibc-Memory-Subsystem">
   <title>Bellek Alt Sistemi</title>
   <titleabbrev>Geleneksel Unix bellek işlemlerine bir bakış</titleabbrev>
   <para>
    <indexterm linkend="glibc-cp"><primary>adres alanı</primary></indexterm>
    <indexterm linkend="glibc-cp"><primary>bellek</primary><secondary>fiziksel</secondary></indexterm>
    <indexterm linkend="glibc-cp"><primary>fiziksel adres</primary></indexterm>
    <indexterm linkend="glibc-cp"><primary>bellek</primary><secondary>paylaşımlı</secondary></indexterm>
    Unix sistemleri genelde süreçlere sanal adres alanları sunar. Bunun anlamı, verinin saklandığı adres alanlarının aslında fiziksel bellek adresleri değil, bunları kapsayan ama bu adreslere doğrudan erişim sağlamayan bellek bölgelerinin adresleri olduğudur. Sanal adreslerin fiziksel adreslere dönüştürüldüğü ek bir dolaylı işlem katmanı vardır ve bu işlemler normalde işlemcinin donanımı tarafından yapılır.
   </para>
   <para>
    Bir sanal adres alanı kullanmanın çeşitli yararları vardır. En önemlisi süreç yalıtımıdır. Sistemde çalışmakta olan farklı süreçlerin birbirleriyle doğrudan etkileşmemeleri gerekir. Bir sürecin adres alanına başka hiçbir süreç yazamaz (Paylaşımlı bellek kullanımı hariç. Ancak bu da isteğe bağlıdır ve denetim altında yapılır).
   </para>
   <para>
    Sanal bellek kullanımının diğer bir yararı da süreçlerin adres alanının mevcut fiziksel bellekten daha büyük bir bellek alanı olarak görünmesidir. Fiziksel bellek dış saklama ortamları ile genişletilebilir ve o an kullanılmayan bellek bölgeleri bu ortamlara aktarılabilir. Adres dönüşümü bu bellek bölgelerine erişimi engeller ve hemen bu içeriği fiziksel belleğe geri yükleyerek kullanıma hazır duruma getirir.
   </para>
   <para>
    Kullanılabilir fiziksel bellekle kullanılabilir sanal adres alanı arasındaki farkın bilindiği durumda bu işlem yazılımların belleği kullanabilmesi için gerekli hale gelir. Sistemde çalışmakta olan tüm süreçlerin çalışmalarını sürdürebilmeleri için fiziksel belleğin yetersiz kaldığı ve dış saklama ortamlarının hemen hemen dolduğu durumlarda bu iki ortam arasındaki takaslama işlemi küçük miktarlarda olmaya başlar ve bu sistemin belirgin biçimde yavaşlamasına sebep olur. Buna  <wordasword>atıştırma</wordasword> (thrashing) denir (argosu: çöplenme).
    <indexterm linkend="glibc-cp"><primary>bellek</primary><secondary>atıştırma</secondary></indexterm>
    <indexterm linkend="glibc-cp"><primary>bellek</primary><secondary>bellek sayfası</secondary></indexterm>
    <indexterm linkend="glibc-cp"><primary>sayfa</primary><secondary>bellek</secondary></indexterm>
   </para>
   <para>
    Sanal bellek hakkında söylenebilecek son şey, önceki paragrafta bahsedilen sanal belleğin takaslanma büyüklüğü ile ilgilidir. Bu takaslama işlemi bayt bayt yapılmaz. Yönetsel karar organı bunun olmasına izin vermez (işlemci donanımı naparsan yap deyip bırakılmaz). Bu işlem birkaç bin baytlık <wordasword>sayfa</wordasword> olarak nitelenen belirli miktarlarla yapılır. Her sayfanın genişliği ikinin üstel katları olarak bayt cinsinden belirlenir. Günümüzdeki en küçük sayfa genişliği 4096 bayt olup, 8192, 16384 ve 65536 baytlık sayfa genişlikleri de görülmektedir.
   </para>
  </sect1>
  <sect1 xml:id="glibc-Query-Memory-Parameters">
   <title>Bellek Bağımsız değişkenlerinin Sorgulanması</title>
   <titleabbrev>Bellek alt sistemi hakkında nasıl bilgi edinilir?</titleabbrev>
   <para>
    Sürecin sanal bellek sayfa genişliğini bilmesi bazı durumlarda zorunludur. Bazı yazılım arayüzleri (<function>mmap</function> gibi, bkz. <xref linkend="glibc-Memory-mapped-I-O"/>) kullanıcının sayfa genişliğine ayarlanmış bilgi vermesini gerektirir. <function>mmap</function>, sayfa genişliğinin katları olarak uzunluk bağımsız değişkeni gerektirir. Sayfa genişliğinin bilinmesinin faydalı olduğu diğer bir yer de bellek tahsisidir. Uygulama tarafından bölünerek kullanılmak üzere büyükçe bir tomar halinde bir tahsis yapılırsa, geniş dilimlerin boyutlarının sayfa genişliğine ayarlanması yararlı olur. Çekirdek bellekle çalışırken sadece tamamı kullanılan bellek sayfalarını tahsis etmek zorunda olduğundan, tahsisi istenen dilim boyutunun sayfa genişliğinin katlarına yakın (daha büyük değil) olması çekirdeğin bellek tahsisi ile ilgili olarak daha verimli çalışabilmesini sağlar. (Bu en iyilemeyi yapmak için her dilim için bir miktar bellek gerektirecek olan bellek tahsisçi hakkında biraz bilgi sahibi olunması ve sayfa genişliğinin katlarını aşan bir toplam boyut talep edilmemesi gerekir.)
   </para>
   <para>
    Sayfa genişliği geleneksel olarak bir derleme zamanı sabitidir. Fakat son zamanlarda geliştirilen işlemcilerle bu durum değişmiştir. İşlemciler artık farklı sayfa genişliklerini desteklemekte ve aynı sistem üzerinde farklı süreçler arasında bunun değişiklik göstermesine bile olanak verebilmektedir. Bu nedenle, çalışma anında sistem o anki sayfa genişliği hakkında sorgulanmalı ve sayfa genişliği ile ilgili hiçbir önkabul yapılmamalıdır (sayfa genişliğinin ikinin üstel katları olması gerekliliği hariç).
   </para>
   <para>
    Sayfa genişliğini sorgulamak için doğru arayüz <function>sysconf</function> olup <varname>_SC_PAGESIZE</varname> ile kullanılmalıdır. (bkz. <xref linkend="glibc-Sysconf-Definition"/>). Ayrıca daha eski bir arayüz de vardır.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-getpagesize"><primary>getpagesize</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>getpagesize</function></csname>
     <csparam><void/></csparam>
    </csproto>
    <header>&unistd.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     <code>getpagesize</code> işlevi sürecin sayfa genişliği ile döner. Bu değer sürecin çalışması süresince sabittir ama aynı yazılımın farklı süreçlerinde farklı değerler alabilir.
    </para>
   </csynopsis>
   <para>
    Sistemin fiziksel belleği hakkında System&nbsp;V'den türetilmiş sistemlerde geniş olarak kullanılan bir bilgi alma yöntemi vardır.
   </para>
   <literallayout class="monospaced"><code>sysconf (<varname>_SC_PHYS_PAGES</varname>)</code>
</literallayout>
   <para>
    çağrısı sistemin sahip olduğu belleğin fiziksel sayfalarının toplam sayısı ile döner, ancak bu belleğin tümünün kullanılabilir olduğu anlamına gelmez. Bu bilgi,
   </para>
   <literallayout class="monospaced"><code>sysconf (<varname>_SC_AVPHYS_PAGES</varname>)</code>
</literallayout>
   <para>
    çağrısı ile edinilebilir. Bu iki değer uygulamaların en iyilenmesine yardımcı olur. <varname>_SC_AVPHYS_PAGES</varname> için döndürülen değer uygulamanın başka bir süreç tarafından engellenmeksizin kullanabileceği bellek miktarıdır (başka hiçbir sürecin kendi bellek kullanımını, diğerlerinin hilafına artıramayacağını belirtir). <varname>_SC_PHYS_PAGES</varname> için dönen değer ise az ya da çok çalışma birliği için donanımsal bir sınırdır. Eğer tüm uygulamalar birlikte bundan fazlasını kullanmaya çalışırsa, sistemin bellek miktarı ile başı dertte demektir.
   </para>
   <para>
    &glibc; bu iki yönteme ek olarak bu bilgiyi almak için iki işlev daha içerir. Bu işlevler &sys-sysinfo.h; başlık dosyasında bildirilmiştir. Yazılımcılar yukarıda açıklanan <function>sysconf</function> yöntemini tercih etmelidir.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-get_phys_pages"><primary>get_phys_pages</primary></indexterm>
    <csproto type="işlev">
     <csname><type>long&nbsp;int</type><function>get_phys_pages</function></csname>
     <csparam><void/></csparam>
    </csproto>
    <header>&sys-sysinfo.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&asunsafe; &heap; &lock;</concept>
     <concept>&acunsafe; &lock; &fd; &mem;</concept>
    </conceptlist>
    <para>
     <code>get_phys_pages</code> işlevi sistemin sahip olduğu fiziksel sayfaların sayısı ile döner. Belleğin toplam miktarını bulmak için bu değer sayfa genişliği ile çarpılır.
    </para>
    <para>
     Bu işlevGNU oluşumudur.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-get_avphys_pages"><primary>get_avphys_pages</primary></indexterm>
    <csproto type="işlev">
     <csname><type>long&nbsp;int</type><function>get_avphys_pages</function></csname>
     <csparam><void/></csparam>
    </csproto>
    <header>&sys-sysinfo.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&asunsafe; &heap; &lock;</concept>
     <concept>&acunsafe; &lock; &fd; &mem;</concept>
    </conceptlist>
    <para>
     <code>get_avphys_pages</code> işlevi sistemin sahip olduğu fiziksel sayfalardan kullanılabilir olanlarının sayısı ile döner. Belleğin kullanılabilir toplam miktarını bulmak için bu değer sayfa genişliği ile çarpılır.
    </para>
    <para>
     Bu işlev GNU oluşumudur.
    </para>
   </csynopsis>
  </sect1>
 </chapter>
 <chapter xml:id="glibc-Processor-Resources">
  <title>İşlemci Öz Kaynakları</title>
  <titleabbrev>İşlemciler hakkında bilinmesi gerekenler</titleabbrev>
  <para>
   Evrelerin ve süreçlerin paylaşımlı bellekle kullanımı bir uygulamanın bir sistemin sağlayabildiği tüm işlem gücünün getirilerinden yararlanmasına imkan verir. Eğer görev paralelleştirilebiliyorsa, bir uygulama yazmanın en uygun yolu aynı anda çok sayıda işlemci varmış gibi çok sayıda sürecin çalışmasının mümkün olması ile ilgilidir. Sistemdeki mevcut işlemcilerin sayısını saptamak için şöyle bir çağrı yapılabilir:
  </para>
  <literallayout class="monospaced"><code>sysconf (<varname>_SC_NPROCESSORS_CONF</varname>)</code>
</literallayout>
  <para>
   İşletim sisteminin yapılandırıldığı işlemcilerin sayısı ile döner. Ancak işletim sisteminin bazı işlemcileri iptal etmesi mümkün olduğundan,
  </para>
  <literallayout class="monospaced"><code>sysconf (<varname>_SC_NPROCESSORS_ONLN</varname>)</code>
</literallayout>
  <para>
   çağrısı ile o an kullanılabilecek işlemcilerin sayısını öğrenilebilir.
  </para>
  <para>
   Bu ikisine ek olarak &glibc; bilgiyi doğrudan almayı mümkün kılan işlevler de içerir. Bu işlevler &sys-sysinfo.h; başlık dosyasında bildirilmiştir.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-get_nprocs_conf"><primary>get_nprocs_conf</primary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>get_nprocs_conf</function></csname>
    <csparam><void/></csparam>
   </csproto>
   <header>&sys-sysinfo.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&asunsafe; &heap; &lock;</concept>
    <concept>&acunsafe; &lock; &fd; &mem;</concept>
   </conceptlist>
   <para>
    <code>get_nprocs_conf</code> işlevi işletim sisteminin yapılandırıldığı işlemcilerin sayısı ile döner.
   </para>
   <para>
    Bu işlev GNU oluşumudur.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-get_nprocs"><primary>get_nprocs</primary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>get_nprocs</function></csname>
    <csparam><void/></csparam>
   </csproto>
   <header>&sys-sysinfo.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe; &fd;</concept>
   </conceptlist>
   <para>
    <code>get_nprocs</code> işlevi o an kullanılabilecek işlemcilerin sayısı ile döner.
   </para>
   <para>
    Bu işlev GNU oluşumudur.
   </para>
  </csynopsis>
  <para>
   Daha fazla evre başlatmadan önce işlemcilerin tamamen kullanımda olup olmadığına bakılmalıdır. Unix sistemi <wordasword>yük ortalaması</wordasword> adı verilen bir hesaplama yapar. Bu aynı anda kaç sürecin çalışmakta olduğunu gösteren bir sayıdır. Bu sayı farklı sürelerde alınan bir ortalamadır (normalde 1, 5 ve 15 dakikalık).
  </para>
  <csynopsis>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-getloadavg"><primary>yük ortalaması</primary></indexterm>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-getloadavg"><primary>getloadavg</primary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>getloadavg</function></csname>
    <csparam><type>double</type><parameter>loadavg</parameter><code>[]</code></csparam>
    <csparam><type>int</type><parameter>nelem</parameter></csparam>
   </csproto>
   <header>&stdlib.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe; &fd;</concept>
   </conceptlist>
   <para>
    İşlev sistemin yük ortalamasını 1, 5 ve 15 dakikalık ortalamalar olarak döndürür. Değerler <parameter>loadavg</parameter> dizisine yerleştirilir. Diziye kaç ortalama yerleştirileceği <parameter>nelem</parameter> bağımsız değişkenine konur, ancak bu değer üçten fazla olmaz. İşlevin normal dönüş değeri <parameter>loadavg</parameter> dizisine yazılan değerlerin sayısıdır, <code>-1</code> dönmüşse bir hata oluşmuş demektir.
   </para>
  </csynopsis>
 </chapter>
</part>
