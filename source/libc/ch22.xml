<?xml version="1.0" encoding="UTF-8"?>
<!-- ********************************************************************
     $Id: ch22.xml,v 1.2 2002/12/20 22:29:48 nilgun Exp $
******************************************************************** -->
<part id="glibc-Resource-Usage-And-Limitation">
  <title>Özkaynak Kullanımı ve Sınırlaması</title>
  <titleabbrev>Özkaynak kullanımı ile bunlarla ilgili sınırların öğrenilmesi ve belirtilmesi.</titleabbrev>
  <partintro><para>
Bu oylumda bir sürecin çalışması esnasında kullanacağı çeşitli sistem özkaynaklarının (İşlemci zamanı, bellek, v.s.) sınırlarını öğrenmek ve belirtmek için kullanabileceği işlevlere yer verilmiştir.
  </para></partintro>
  <chapter id="glibc-Resource-Usage">
    <title>Özkaynak Kullanımı</title>
    <titleabbrev>Kullanılan çeşitli özkaynakların ölçülmesi.</titleabbrev>
    <para>
<indexterm scope="glibc-pg"><primary>sys/resource.h</primary></indexterm>
Bir sürecin özkaynak kullanımını incelemek için kullanılan <command>getrusage</command> işlevi ve <command>struct rusage</command> veri yapısı <filename>sys/resource.h</filename> başlık dosyasında bildirilmiştir.
   </para><para>
<indexterm scope="glibc-fn"><primary>getrusage</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-getrusage">
<funcdef>int <command>getrusage</command></funcdef>
<paramdef>(int            <varname>süreçler</varname>,
 struct rusage *<varname>kaynakkullanımı</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev <varname>süreçler</varname> ile belirtilen süreçlerin toplam özkaynak kullanımını <varname>*kaynakkullanımı</varname> içinde saklayarak döner.
   </para><para>
Çoğu sistemde, <varname>süreçler</varname> için sadece iki geçerli değer vardır:
   </para><para><variablelist><varlistentry>
   <term><literal>RUSAGE_SELF</literal></term><listitem><para>
Sadece işlevi çalıştıran süreci belirtir.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>RUSAGE_CHILDREN</literal></term><listitem><para>
Sonlanmış olan tüm alt süreçler (Doğrudan ya da dolaylı).
      </para></listitem></varlistentry></variablelist>
    </para><para>
GNU sisteminde, belli bir alt sürecin özkaynak kullanımını süreç kimliğini belirterek sorgulayabilirsiniz.
   </para><para>
İşlevin normal dönüş değeri sıfırdır, <command>-1</command> dönüş değeri bir hata oluştuğunu gösterir. Bu işlev için tanımlanmış <command>errno</command> hata durumu:
   </para><para><variablelist><varlistentry>
   <term><literal>EINVAL</literal></term><listitem><para>
<varname>süreçler</varname> argümanı geçersiz
      </para></listitem></varlistentry></variablelist>
    </para><para>
Belli bir alt sürecin özkaynak kullanımını sorgulamanın tek yolu, sonlandığında kullandığı özkaynak toplamlarını döndüren <command>wait4</command> işlevidir. Bkz. <xref linkend="glibc-BSD-Wait-Functions"/>.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-tp"><primary sortas="rusage">struct rusage</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü" id="glibc-struct-rusage">
<funcdef>struct <command>rusage</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu veri türü çeşitli özkaynakların kullanım istatistiklerini saklar. En azından şu üyelere sahiptir:
   </para><para><glosslist><glossentry><glossterm>
   <literal>struct timeval <command>ru_utime</command></literal>
   </glossterm><glossdef><para>
Kullanıcı komutları çalıştırılırken harcanan süre.
   </para></glossdef></glossentry><glossentry><glossterm>
   <literal>struct timeval <command>ru_stime</command></literal>
   </glossterm><glossdef><para>
İşletim sistemi tarafından <varname>süreçler</varname> yararına kullanılan toplam süre.
   </para></glossdef></glossentry><glossentry><glossterm>
   <literal>long int <command>ru_maxrss</command></literal>
   </glossterm><glossdef><para>
<varname>süreçler</varname>'in aynı anda kullandığı fiziksel belleğin kilobayt cinsinden azami miktarı.
   </para></glossdef></glossentry><glossentry><glossterm>
   <literal>long int <command>ru_ixrss</command></literal>
   </glossterm><glossdef><para>
Diğer süreçlerle paylaşılan metin tarafından kullanılan bellek miktarını belirten icra tiklerini kilobayt cinsinden ifade eden bir tamsayı değer.
   </para></glossdef></glossentry><glossentry><glossterm>
   <literal>long int <command>ru_idrss</command></literal>
   </glossterm><glossdef><para>
Veri için kullanılan paylaşımsız bellek miktarının aynı yöntemle ifade edilen tamsayı değeri.
   </para></glossdef></glossentry><glossentry><glossterm>
   <literal>long int <command>ru_isrss</command></literal>
   </glossterm><glossdef><para>
Yığıt alanı için kullanılan paylaşımsız bellek miktarının aynı yöntemle ifade edilen tamsayı değeri.
   </para></glossdef></glossentry><glossentry><glossterm>
   <literal>long int <command>ru_minflt</command></literal>
   </glossterm><glossdef><para>
Herhangi bir G/Ç gerektirmeksizin sunulan sayfalama hatalarının sayısı.
   </para></glossdef></glossentry><glossentry><glossterm>
   <literal>long int <command>ru_majflt</command></literal>
   </glossterm><glossdef><para>
G/Ç yaparak sunulan sayfalama hatalarının sayısı.
   </para></glossdef></glossentry><glossentry><glossterm>
   <literal>long int <command>ru_nswap</command></literal>
   </glossterm><glossdef><para>
<varname>süreçler</varname>'in tamamen ana belleğe takaslanma sayısı.
   </para></glossdef></glossentry><glossentry><glossterm>
   <literal>long int <command>ru_inblock</command></literal>
   </glossterm><glossdef><para>
Dosya sisteminin <varname>süreçler</varname> yararına diskten yaptığı okumaların sayısı.
   </para></glossdef></glossentry><glossentry><glossterm>
   <literal>long int <command>ru_oublock</command></literal>
   </glossterm><glossdef><para>
Dosya sisteminin <varname>süreçler</varname> yararına diske yaptığı yazmaların sayısı.
   </para></glossdef></glossentry><glossentry><glossterm>
   <literal>long int <command>ru_msgsnd</command></literal>
   </glossterm><glossdef><para>
Gönderilen süreçlerararı iletişim (IPC) iletilerinin sayısı.
   </para></glossdef></glossentry><glossentry><glossterm>
   <literal>long int <command>ru_msgrcv</command></literal>
   </glossterm><glossdef><para>
Alınan süreçlerararı iletişim (IPC) iletilerinin sayısı.
   </para></glossdef></glossentry><glossentry><glossterm>
   <literal>long int <command>ru_nsignals</command></literal>
   </glossterm><glossdef><para>
Alınan sinyallerin sayısı.
   </para></glossdef></glossentry><glossentry><glossterm>
   <literal>long int <command>ru_nvcsw</command></literal>
   </glossterm><glossdef><para>
<varname>süreçler</varname>'in bir bağlamsal seçiciye kasıtlı yaptığı çağrı sayısı (genellikle bazı hizmetler beklenirken).
   </para></glossdef></glossentry><glossentry><glossterm>
   <literal>long int <command>ru_nivcsw</command></literal>
   </glossterm><glossdef><para>
İstemdışı olarak bir bağlamsal seçicide yeralma sayısı (belli bir süre geçmiş ya da daha yüksek öncelikli başka bir süreç öne geçmiş olmasından dolayı).
   </para></glossdef></glossentry></glosslist>
</para></funcdescr></funcsynopsis></para><para>
<command>vtimes</command> işlevi <command>getrusage</command> işlevinin yaptığını yapan tarihi bir işlevdir. <command>getrusage</command> işlevinin kullanımı tercih edilmelidir.
   </para><para>
<command>vtimes</command> ve onun <command>vtimes</command> veri yapısı <filename>sys/vtimes.h</filename> başlık dosyasında bildirilmiştir.
<indexterm scope="glibc-pg"><primary>sys/vtimes.h</primary></indexterm>
   </para><para>
<indexterm scope="glibc-fn"><primary>vtimes</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-vtimes">
<funcdef>int <command>vtimes</command></funcdef>
<paramdef>(struct vtimes <varname>şimdiki</varname>,
 struct vtimes <varname>altsüreç</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>vtimes</command> bir sürecin özkaynak kullanım toplamlarını raporlar.
   </para><para>
Eğer <varname>şimdiki</varname> boş gösterici değilse, işlev sadece çağıran sürecin özkaynak kullanım toplamlarını bu argümanın gösterdiği yapıda saklar. <varname>altsüreç</varname> bir boş gösterici değilse, çağıran sürecin sonlanmış alt süreçlerinin özkaynak kullanım toplamlarını bu argümanın gösterdiği yapıda saklar.
   </para><para>
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-tp"><primary sortas="vtimes">struct vtimes</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü" id="glibc-struct-vtimes">
<funcdef>struct <command>vtimes</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu veri türü çeşitli özkaynakların kullanımı ile ilgili bilgileri saklar. Bu yapının her üyesi yukarıda açıklanan <command>struct rusage</command> yapısının üyelerinin karşılığıdır.
   </para><para><variablelist><varlistentry>
   <term><literal>vm_utime</literal></term><listitem><para>
Kullanıcı işlemci zamanı.  <command>struct rusage</command> yapısının <command>ru_utime</command> üyesinin karşılığıdır.
   </para></listitem></varlistentry><varlistentry>
   <term><literal>vm_stime</literal></term><listitem><para>
Sistem işlemci zamanı.  <command>struct rusage</command> yapısının <command>ru_stime</command> üyesinin karşılığıdır.
   </para></listitem></varlistentry><varlistentry>
   <term><literal>vm_idsrss</literal></term><listitem><para>
Veri ve yığıt belleği. <command>struct rusage</command> yapısının <command>ru_idrss</command> ve <command>ru_isrss</command> üyesisinin raporladığı değerlerin toplamıdır.
   </para></listitem></varlistentry><varlistentry>
   <term><literal>vm_ixrss</literal></term><listitem><para>
Paylaşımlı bellek. <command>struct rusage</command> yapısının <command>ru_ixrss</command> üyesinin karşılığıdır.
   </para></listitem></varlistentry><varlistentry>
   <term><literal>vm_maxrss</literal></term><listitem><para>
Süreçlerin aynı anda kullandığı fiziksel belleğin kilobayt cinsinden azami miktarı. <command>struct rusage</command> yapısının <command>ru_maxrss</command>  üyesinin karşılığıdır.
   </para></listitem></varlistentry><varlistentry>
   <term><literal>vm_majflt</literal></term><listitem><para>
G/Ç'lı sayfalama hatalarının sayısı.<command>struct rusage</command> yapısının <command>ru_majflt</command> üyesinin karşılığıdır.
   </para></listitem></varlistentry><varlistentry>
   <term><literal>vm_minflt</literal></term><listitem><para>
G/Ç'sız sayfalama hatalarının sayısı. <command>struct rusage</command> yapısının <command>ru_minflt</command> üyesinin karşılığıdır.
   </para></listitem></varlistentry><varlistentry>
   <term><literal>vm_nswap</literal></term><listitem><para>
Takaslama sayısı.  <command>struct rusage</command> yapısının <command>ru_nswap</command> üyesinin karşılığıdır.
   </para></listitem></varlistentry><varlistentry>
   <term><literal>vm_inblk</literal></term><listitem><para>
Diskten okuma sayısı. <command>struct rusage</command> yapısının <command>ru_inblk</command> üyesinin karşılığıdır.
   </para></listitem></varlistentry><varlistentry>
   <term><literal>vm_oublk</literal></term><listitem><para>
Diske yazma sayısı. <command>struct rusage</command> yapısının <command>ru_oublk</command> üyesinin karşılığıdır.
   </para></listitem></varlistentry></variablelist>
   </para><para>
İşlev başarılı olursa sıfır değeri ile, aksi takdirde <command>-1</command> ile döner.
</para></funcdescr></funcsynopsis>
   </para></chapter>
  <chapter id="glibc-Limits-on-Resources">
    <title>Özkaynak Kullanımın Sınırlanması</title>
    <titleabbrev>Özkaynak kullanımında sınırların belirtilmesi.</titleabbrev>
    <para>
<indexterm scope="glibc-cp"><primary>özkaynak sınırları</primary></indexterm>
<indexterm scope="glibc-cp"><primary>kullanım sınırları</primary></indexterm>
Bir sürecin özkaynak kullanımı için sınırlar belirtebilirsiniz. Süreç bir sınırı aşmaya çalışırsa bir sinyal alabilir ya da özkaynağa bağımlı bir sistem çağrısı başarısız olabilir. Her süreç kendi özkaynak sınır değerlerini kendini çalıştıran süreçten miras alır, ancak onları üst sürecinden bağımsız olarak değiştirebilir.
   </para><para>
Bir özkaynağın her süreç için iki sınırı vardır:
<indexterm scope="glibc-cp"><primary>limit</primary></indexterm>
   </para><para><variablelist><varlistentry>
   <term><firstterm>mevcut sınır</firstterm></term><listitem><para>
Mevcut sınır sistemin aşılmasına izin vermediği sınırdır. "Sanal sınır" olarak da bilinir, çünkü bu sınırı sürecin kendisi belirler.
<indexterm scope="glibc-cp"><primary>mevcut sınır</primary></indexterm>
<indexterm scope="glibc-cp"><primary>sanal sınır</primary></indexterm>
   </para></listitem></varlistentry><varlistentry>
   <term><firstterm>üst sınır</firstterm></term><listitem><para>
Bir sürecin mevcut sınır olarak belirleyebileceği değerin üst sınırıdır. "Kesin sınır" olarak da bilinir, çünkü sürecin bu sınırın etrafından dolanması mümkün değildir. Bir süreç mevcut sınırını bu değere kadar arttırabilirken, sadece sistem yöneticisi bu üst sınırı arttırabilir.
<indexterm scope="glibc-cp"><primary>üst sınır</primary></indexterm>
<indexterm scope="glibc-cp"><primary>kesin sınır</primary></indexterm>
   </para></listitem></varlistentry></variablelist>
   </para><para>
<indexterm scope="glibc-pg"><primary>sys/resource.h</primary></indexterm>
<command>getrlimit</command>, <command>setrlimit</command>, <command>getrlimit64</command> ve <command>setrlimit64</command> işlevleri ve bunlarla kullanılan semboller <filename>sys/resource.h</filename> başlık dosyasında bildirilmiştir.
   </para><para>
<indexterm scope="glibc-fn"><primary>getrlimit</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-getrlimit">
<funcdef>int <command>getrlimit</command></funcdef>
<paramdef>(int            <varname>özkaynak</varname>,
 struct rlimit *<varname>sınır</varname>)</paramdef>
</funcprototype><funcdescr><para>
<varname>özkaynak</varname> özkaynağının mevcut ve üst sınırlarını okur ve bunları <varname>*sınır</varname> içinde saklar.
   </para><para>
İşlev başarılı olursa <command>0</command>, aksi takdirde <command>-1</command> ile döner.  Olası tek <command>errno</command> hata durumu <command>EFAULT</command>'tur.
   </para><para>
Kaynakların <command>_FILE_OFFSET_BITS == 64</command> ile derlendiği 32 bitlik bir sistemde bu işlev aslında <command>getrlimit64</command> işlevine denktir. Yani LFS arayüzü eski arayüzün yerine geçer.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>getrlimit64</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-getrlimit64">
<funcdef>int <command>getrlimit64</command></funcdef>
<paramdef>(int              <varname>özkaynak</varname>,
 struct rlimit64 *<varname>sınır</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev ikinci argümanın <command>struct rlimit64</command> türünde olması dışında <command>getrlimit</command> işlevinin eşdeğeridir.
   </para><para>
Kaynakların <command>_FILE_OFFSET_BITS == 64</command> ile derlendiği 32 bitlik bir sistemde bu işlevin ismi <command>getrlimit</command> olur, böylece LFS arayüzü eski arayüzün yerine geçer.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>setrlimit</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-setrlimit">
<funcdef>int <command>setrlimit</command></funcdef>
<paramdef>(int                  <varname>özkaynak</varname>,
 const struct rlimit *<varname>sınır</varname>)</paramdef>
</funcprototype><funcdescr><para>
<varname>özkaynak</varname> özkaynağının mevcut ve üst sınırlarını  <varname>*sınır</varname> içindeki değerlere ayarlar.
   </para><para>
İşlev başarılı olursa <command>0</command>, aksi takdirde <command>-1</command> ile döner. Bu işlev için tanımlanmış <command>errno</command> hata durumları:
   </para><para><variablelist><varlistentry>
   <term><literal>EPERM</literal></term><listitem><para>
   <itemizedlist><listitem>
Süreç mevcut sınırı üst sınırın üstünde belirtmeyi denedi
        </listitem><listitem>
Süreç üst sınırı arttırmayı denedi ama yetkisi yetersiz
        </listitem></itemizedlist>
    </para></listitem></varlistentry></variablelist>
  </para><para>
Kaynakların <command>_FILE_OFFSET_BITS == 64</command> ile derlendiği 32 bitlik bir sistemde bu işlev aslında <command>setrlimit64</command> işlevine denktir. Yani LFS arayüzü eski arayüzün yerine geçer.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>setrlimit64</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-setrlimit64">
<funcdef>int <command>setrlimit64</command></funcdef>
<paramdef>(int                    <varname>özkaynak</varname>,
 const struct rlimit64 *<varname>sınır</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev ikinci argümanın <command>struct rlimit64</command> türünde olması dışında <command>setrlimit</command> işlevinin eşdeğeridir.
   </para><para>
Kaynakların <command>_FILE_OFFSET_BITS == 64</command> ile derlendiği 32 bitlik bir sistemde bu işlevin ismi <command>setrlimit</command> olur, böylece LFS arayüzü eski arayüzün yerine geçer.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-tp"><primary sortas="rlimit">struct rlimit</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü" id="glibc-struct-rlimit">
<funcdef>struct <command>rlimit</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu yapı <command>getrlimit</command> işlevinde kullanıldığında sınır değerlerin alınmasını sağlar, <command>setrlimit</command> işlevinde kullanıldığında ise belli bir süreç ve özkaynak için sınır değerleri belirtir. İki üyesi vardır:
   </para><para><glosslist><glossentry><glossterm>
   <literal>rlim_t <command>rlim_cur</command></literal>
   </glossterm><glossdef><para>Mevcut sınır.
   </para></glossdef></glossentry><glossentry><glossterm>
   <literal>rlim_t <command>rlim_max</command></literal>
   </glossterm><glossdef><para>Üst sınır.
   </para></glossdef></glossentry></glosslist></para><para>
<command>getrlimit</command> işlevi açısından yapı bir çıktı alanıdır; o anki değerleri alır. <command>setrlimit</command> işlevinde ise yeni değerleri belirtir.
   </para><para>
LFS işlevleri için benzer bir tür <filename>sys/resource.h</filename> başlık dosyasında tanımlanmıştır.
   </para><para>
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-tp"><primary sortas="rlimit64">struct rlimit64</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü" id="glibc-struct-rlimit64">
<funcdef>struct <command>rlimit64</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu yapı üyelerinin daha geniş aralıklara sahip olması dışında yukarıdaki <command>rlimit</command> yapısının karşılığıdır. İki üyesi vardır:
   </para><para><glosslist><glossentry><glossterm>
   <literal>rlim64_t <command>rlim_cur</command></literal>
   </glossterm><glossdef><para>
<command>rlimit.rlim_cur</command> karşılığıdır, ama türü farklıdır.
   </para></glossdef></glossentry><glossentry><glossterm>
   <literal>rlim64_t <command>rlim_max</command></literal>
   </glossterm><glossdef><para>
<command>rlimit.rlim_max</command> karşılığıdır, ama türü farklıdır.
   </para></glossdef></glossentry></glosslist>
</para></funcdescr></funcsynopsis></para><para>
Bir sınır belirtilebilecek özkaynakların listesi aşağıda verilmiştir. Bellek ve dosyalarla ilgili sınırlar bayt cinsindendir.
   </para><para><variablelist><varlistentry>
   <term><literal>RLIMIT_CPU</literal></term><listitem><para>
<indexterm scope="glibc-vr"><primary>RLIMIT_CPU</primary></indexterm>
Sürecin kullanabileceği işlemci zamanının azami miktarı. Süreç bundan daha uzun süre çalışırsa, <command>SIGXCPU</command> sinyalini alacaktır. Değer saniye cinsindendir. Bkz. <xref linkend="glibc-Operation-Error-Signals"/>.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>RLIMIT_FSIZE</literal></term><listitem><para>
<indexterm scope="glibc-vr"><primary>RLIMIT_FSIZE</primary></indexterm>
Sürecin oluşturabileceği azami dosya boyutu. Daha büyük bir dosya yazma denemesi <command>SIGXFSZ</command> sinyaline sebep olur.  Bkz. <xref linkend="glibc-Operation-Error-Signals"/>.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>RLIMIT_DATA</literal></term><listitem><para>
<indexterm scope="glibc-vr"><primary>RLIMIT_DATA</primary></indexterm>
Süreç için ayrılan azami veri belleği miktarı. Süreç bu miktardan daha büyük bellek ayırmaya çalışırsa bellek ayırma işlevi başarısız olur.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>RLIMIT_STACK</literal></term><listitem><para>
<indexterm scope="glibc-vr"><primary>RLIMIT_STACK</primary></indexterm>
Süreç için azami yığıt boyutu. Süreç yığıtını bundan fazlasına genişletmeye çaışırsa bir <command>SIGSEGV</command> sinyali alacaktır. Bkz. <xref linkend="glibc-Program-Error-Signals"/>.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>RLIMIT_CORE</literal></term><listitem><para>
<indexterm scope="glibc-vr"><primary>RLIMIT_CORE</primary></indexterm>
Bu sürecin oluşturabileceği core dosyasının azami boyutu. Eğer süreç sonlanır ve bu boyuttan daha büyük bir core dosyası dökümlemeyi denerse core dosyası oluşmaz. Bu bakımdan, bu sınırı sıfıra indirerek core dosyalarının asla oluşmamasını sağlayabilirsiniz.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>RLIMIT_RSS</literal></term><listitem><para>
<indexterm scope="glibc-vr"><primary>RLIMIT_RSS</primary></indexterm>
Bu sürecin alabileceği fiziksel belleğin azami miktarı. Bu parametre sistemin zamanlayıcısı ve bellek ayırıcısı için bir kılavuzdur. Sistem, sürece ihtiyaç duyduğunda bundan daha fazla bellek verebilir.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>RLIMIT_MEMLOCK</literal></term><listitem><para>
Fiziksel bellekte kilitlenebilecek belleğin azami miktarı (böylece bu bellek takaslanmayacaktır).
      </para></listitem></varlistentry><varlistentry>
      <term><literal>RLIMIT_NPROC</literal></term><listitem><para>
Aynı kullanıcı kimlikle oluşturulabilecek süreçlerin azami sayısı. Bu sınırı kendi kullanıcı kimliğiniz için aşmaya çalışırsanız, <command>fork</command> işlevi <command>EAGAIN</command> ile başarısız olacaktır. Bkz. <xref linkend="glibc-Creating-a-Process"/>.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>RLIMIT_NOFILE</literal></term>
      </varlistentry><varlistentry>
      <term><literal>RLIMIT_OFILE</literal></term><listitem><para>
<indexterm scope="glibc-vr"><primary>RLIMIT_NOFILE</primary></indexterm>
<indexterm scope="glibc-vr"><primary>RLIMIT_OFILE</primary></indexterm>
Sürecin açabileceği dosyaların azami sayısı. Bundan daha fazla dosya açmaya çalışırsa, işlem <command>EMFILE</command> hata kodu ile başarısız olur. Bu sınır tüm sistemlerde desteklenmez; GNU ve 4.4 BSD böyledir.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>RLIMIT_AS</literal></term><listitem><para>
<indexterm scope="glibc-vr"><primary>RLIMIT_AS</primary></indexterm>
Bu sürecin alabileceği toplam belleğin azami miktarı. Eğer süreç bunu aşan miktarı örneğin,  <command>brk</command>, <command>malloc</command>, <command>mmap</command> veya <command>sbrk</command> ile ayırmaya çalışırsa işlev başarısız olur.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>RLIM_NLIMITS</literal></term><listitem><para>
<indexterm scope="glibc-vr"><primary>RLIM_NLIMITS</primary></indexterm>
Farklı özkaynak sınırlarının sayısı. Geçerli <varname>özkaynak</varname> terimlerinin sayısı <command>RLIM_NLIMITS</command> değerinden küçük olmalıdır.
      </para></listitem></varlistentry></variablelist>
    </para><para>
<indexterm scope="glibc-vr"><primary>RLIM_INFINITY</primary></indexterm>
<funcsynopsis><funcprototype role="değişken" id="glibc-RLIM_INFINITY">
<funcdef>int <command>RLIM_INFINITY</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu sabit, <command>setrlimit</command> içinde sınır değer olarak belirtildiğinde "sonsuz" değerine karşılıktır.
</para></funcdescr></funcsynopsis></para><para>
Aşağıdaki tarihi işlevler şimdiye kadar bahsedilen işlevlerin yaptıklarını yaparlar. Bunların yerine yukarıda bahsedilen işlevlerin kullanılması daha iyi bir seçim olacaktır.
   </para><para>
<command>ulimit</command> ve komut sembolleri <filename>ulimit.h</filename> başlık dosyasında bildirilmiştir.
<indexterm scope="glibc-pg"><primary>ulimit.h</primary></indexterm>
   </para><para>
<indexterm scope="glibc-fn"><primary>ulimit</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-ulimit">
<funcdef>int <command>ulimit</command></funcdef>
<paramdef>(int <varname>komut</varname>, ...)</paramdef>
</funcprototype><funcdescr><para>
<command>ulimit</command> işlevi çağrıldığı süreç ile ilgili olarak <varname>komut</varname> ile belirtildiği gibi özkaynağın ya o anki mevcut sınırıyla döner ya da mevcut ve üst sınırını belirtir.
   </para><para>
Bir sınır değeri döndürmek için komut argümanından başka argüman gerekmez. Bir sınırı belirtmek için ikinci bir argüman gerekir: <command>long int</command><varname>sınır</varname>.
   </para><para>
<varname>komut</varname> argümanında kullanılabilecek değerler ve belirttikleri işlemler:
   </para><para><variablelist><varlistentry>
   <term><literal>GETFSIZE</literal></term><listitem><para>
Bir dosya boyutunun mevcut sınırını 512 baytlık birimler cinsinden döndürür.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>SETFSIZE</literal></term><listitem><para>
Bir dosya boyutunun mevcut ve üst sınırını <varname>sınır</varname> * 512 bayta ayarlar.
      </para></listitem></varlistentry></variablelist>
    </para><para>
Bazı sistemlerde başka <varname>komut</varname> değerleri de desteklenmektedir ama onlar GNU kütüphanesinde desteklenmemektedir.
   </para><para>
Bir üst sınırı sadece sistem yöneticisi arttırabilir.
   </para><para>
Bir sınır başarıyla alınmışsa işlevin dönüş değeri bu sınırın değeridir ve asla negatif değildir. Bir sınır başarıyla değiştirilmişse işlevin dönüş değeri sıfır olur. İşlev başarısız olduğunda  <command>-1</command> ile döner ve olası <command>errno</command> hata durumu şu olabilir:
   </para><para><variablelist><varlistentry>
   <term><literal>EPERM</literal></term><listitem><para>
Süreç bir üst sınırı arttırmayı denedi ama yetkisi yetersiz
      </para></listitem></varlistentry></variablelist>
</para></funcdescr></funcsynopsis></para><para>
<command>vlimit</command> ve onunla ilgili özkaynak sembolleri <filename>sys/vlimit.h</filename> başlık dosyasında bildirilmiştir.
<indexterm scope="glibc-pg"><primary>sys/vlimit.h</primary></indexterm>
   </para><para>
<indexterm scope="glibc-fn"><primary>vlimit</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-vlimit">
<funcdef>int <command>vlimit</command></funcdef>
<paramdef>(int <varname>özkaynak</varname>,
 int <varname>sınır</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>vlimit</command> bir sürecin bir özkaynağı için mevcut sınırı değiştirir.
   </para><para><varname>özkaynak</varname> şunlardan biri olabilir:
   </para><para><variablelist><varlistentry>
   <term><literal>LIM_CPU</literal></term><listitem><para>
Azami işlemci zamanı.  <command>setrlimit</command> için <command>RLIMIT_CPU</command> ile aynıdır.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>LIM_FSIZE</literal></term><listitem><para>
Azami dosya boyutu.  <command>setrlimit</command> için <command>RLIMIT_FSIZE</command> ile aynıdır.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>LIM_DATA</literal></term><listitem><para>
Azami veri belleği. <command>setrlimit</command> için <command>RLIMIT_DATA</command> ile aynıdır.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>LIM_STACK</literal></term><listitem><para>
Azami yığıt boyutu. <command>setrlimit</command> için <command>RLIMIT_STACK</command> ile aynıdır.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>LIM_CORE</literal></term><listitem><para>
Azami core dosyası boyutu. <command>setrlimit</command> için <command>RLIMIT_COR</command> ile aynıdır.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>LIM_MAXRSS</literal></term><listitem><para>
Azami fiziksel bellek. <command>setrlimit</command> için <command>RLIMIT_RSS</command> ile aynıdır.
      </para></listitem></varlistentry></variablelist>
    </para><para>
İşlevin normal dönüş değeri sıfırdır, <command>-1</command> dönüş değeri bir hata oluştuğunu gösterir. Bu işlev için tanımlanmış <command>errno</command> hata durumu:
   </para><para><variablelist><varlistentry>
   <term><literal>EPERM</literal></term><listitem><para>
Süreç mevcut sınırı üst sınırın üzerine çıkarmaya çalıştı
      </para></listitem></varlistentry></variablelist>
  </para></funcdescr></funcsynopsis></para></chapter>
  <chapter id="glibc-Priority">
    <title>Sürecin İşlemci Önceliği ve Zamanlama</title>
    <titleabbrev>Sürecin çalışma önceliğinin okunması ve belirtilmesi.</titleabbrev>
    <para>
<indexterm scope="glibc-cp"><primary>süreç</primary><secondary>öncelik</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>işlemci</primary><secondary>öncelik</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>öncelik</primary><secondary>süreç önceliği</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>öncelik</primary><secondary>işlemci önceliği</secondary></indexterm>
Çok sayıda süreç aynı anda işlemci zamanını kullanmak isterse, sistemin zamanlama kurallarına ve sürecin işlemci önceliğine bakılarak onu hangi sürecin alacağı saptanır. Bu kısımda GNU C kütüphanesinde onu denetleyen işlevlerle bu saptamanın nasıl yapıldığından bahsedilecektir.
   </para><para>
Metin içinde bir özkaynak olarak işlemci ile ilgili olarak, işlemci zamanlamasından basitçe zamanlama ve sürecin işlemci önceliğinden ise sürecin önceliği olarak bahsedeceğiz. İşlemci zamanının sadece bir sürecin kullandığı bir özkaynak olduğu ya da süreçlerin işlemci zamanı için savaştıkları gibi bir anlam da çıkarmayın. Hatta bazı durumlarda kısmen bile önemli değildir. Bir sürece yüksek bir "öncelik" verilmesi bu sürecin diğer süreçlerden daha hızlı olmasına çok küçük bir etkisi olabilir. Bu bölümde öncelik deyince sadece işlemci zamanına uygulanan öncelikten bahsediyor olacağız.
   </para><para>
İşlemci zamanlaması karmaşık bir konudur ve farklı sistemler bunu oldukça farklı yollarla yaparlar. Yeni fikirler sürekli geliştirilmekte ve çeşitli sistemlerin zamanlama algoritmalarının griftliği içinde yollar bulunmaya çalışılmaktadır. Bu bölümde genel kavramlar, GNU C kütüphanesini kullanan sistemlerin bazı özellikleri ve standartlar üzerinde durulacaktır.
   </para><para>
Basitleştirmek için, sistemde sadece bir işlemci ve o işlemci içinde sadece bir işlem birimi varmış gibi davranacağız. Ancak bazı prensipler bir işlemci birden fazla işlem birimi içerdiğinde uygulanır ve eşit sayıda işlem birimi içeren çok sayıda işlemci olduğunda bu bilgiyi kolayca genelleştirebilirsiniz.
   </para><para>
Bu bölümde bahsedilen işlevlerin hepsi POSIX.1 ve POSIX.1b standartlarında bulunur (<command>sched…</command> işlevleri, POSIX.1b'dedir). Bununla birlikte, POSIX bu işlevlerin okuduğu ya da belirlediği değerler için anlambilimsel bir tanım yapmamıştır. Bu kısımda, anlama dair kabuller POSIX standardının Linux çekirdeği gerçeklemesi üzerine oturtulmuştur. Göreceğiniz gibi, Linux gerçeklemesi POSIX sözdizimi yazarlarlarınınkilerden biraz terstir.
   </para>
    <sect1 id="glibc-Absolute-Priority">
      <title>Mutlak Öncelik</title>
      <titleabbrev>Öncelik ile ilk bağlantı. Posix</titleabbrev>
      <para>
<indexterm scope="glibc-cp"><primary>mutlak öncelik</primary></indexterm>
<indexterm scope="glibc-cp"><primary>öncelik</primary><secondary>mutlak</secondary></indexterm>
Her sürecin bir mutlak önceliği vardır ve bir sayı ile ifade edilir. Daha yüksek sayı daha yüksek mutlak öncelik demektir.
    </para><para>
<indexterm scope="glibc-cp"><primary>işlemci</primary><secondary>zamanlama</secondary><tertiary>gerçek zamanlı</tertiary></indexterm>
<indexterm scope="glibc-cp"><primary>zamanlama</primary><secondary>işlemci</secondary><tertiary>gerçek zamanlı</tertiary></indexterm>
Geçmişteki bazı sistemlerde ve günümüzde çoğu sistemde, tüm süreçlerin mutlak önceliği 0'dır ve bu bölümün konusu dışındadır. Bu durumla ilgili olarak, <xref linkend="glibc-Traditional-Scheduling"/> bölümüne bakınız.  Mutlak öncelikler, belli süreçlerin dış olaylara yanıt vermesinin hayati önemde olduğu gerçek zamanlı sistemler için tasarlanmıştır. Bu sistemlerde çalışmak <emphasis>isteyen</emphasis> süreçler işlemciyi tutarken çalışması <emphasis>gereken</emphasis> süreçleri bekletmemesi amaçlanmıştır.
    </para><para>
<indexterm scope="glibc-cp"><primary>süreç</primary><secondary>çalışmaya hazır olmak</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>zamanlama</primary><secondary>öncelikli</secondary></indexterm>
İşlemciyi herhangi bir anda kullanmaya çalışacak iki süreçten daha yüksek önceliği olan onu alır. Bunlardan biri işlemciyi zaten kullanmaktaysa ve önceliği düşükse önceliği yüksek olan işlemciyi yine alacaktır (yani, zamanlama ayrıcalıklıdır). Şüphesiz, burada bahsettiğimiz süreçler zaten başlatılmış yani çalışabilir olan ya da o an komutlarını çalıştırmaya hazır olmak anlamında "çalışmaya hazır" süreçlerdir. Bir süreç G/Ç işlemi gibi bir işlem nedeniyle beklemedeyse, onun önceliği konumuzun dışındadır.
    </para><para>
<indexterm scope="glibc-cp"><primary>süreç</primary><secondary>çalışabilirlik</secondary></indexterm>
<note><para>&quot;çalışabilir olmak&quot; ile &quot;çalışmaya hazır olmak&quot; aynı anlamda kullanılmıştır.</para></note>
    </para><para>
İki süreç de çalışabilir durumdaysa ya da çalışmaya hazırsa ve ikisinin de mutlak önceliği aynıysa, bu daha ilginçtir. Bu durumda işlemciyi hangisinin alacağını zamanlama kuralları belirler. Eğer süreçlerin mutlak öncelikleri 0 ise, <xref linkend="glibc-Traditional-Scheduling"/> bölümünde anlatılan geleneksel zamanlama kurallarına göre bu saptanır. Aksi takdirde <xref linkend="glibc-Realtime-Scheduling"/> bölümünde anlatılan kurallar uygulanır..
    </para><para>
Normalde 0'ın üstünde bir mutlak önceliği, işlemciyi etkisiz bırakmayacağından emin olduğunuz bir sürece verirsiniz. Böyle süreçler kısa bir işlemci kullanımından sonra beklemeye geçmek ya da sonlanmak üzere tasarlanır.
    </para><para>
Bir süreç, kendini başlatan süreç ile aynı mutlak öncelikle oluşturulur. Bu durumu değiştirebilen işlevler <xref linkend="glibc-Basic-Scheduling-Functions"/> bölümünde açıklanmıştır.
    </para><para>
Sadece ayrıcalıklı bir süreç kendi mutlak önceliğini <command>0</command>'dan farklı bir değere ayarlayabilir. Sadece ayrıcalıklı bir süreç ya da hedef sürecin sahibi mutlak önceliği değiştirebilir.
    </para><para>
POSIX, gerçekzamanlı zamanlama kuralları ile kullanılan mutlak öncelik değerlerinin 32'den başlayan ve ardışık sıralanan değerler olmasını gerektirir. Linux'ta 1 ile 99 arasındadır. Taşınabilirlik açısından, <command>sched_get_priority_max</command> ve <command>sched_set_priority_min</command> işlevleri belli bir sistem üzerinde geçerli aralığın ne olduğunu söyler.
    </para>
      <sect2 id="glibc-Using-Absolute-Priority" chunkthis="1">
        <title>Mutlak Önceliğin Kullanımı</title>
        <para>
Gerçek zamanlı uygulamaları tasarlarken unutmamanız gereken tek şey diğer süreçlerden daha yüksek bir mutlak önceliğin sürecin çalışma sürekliliğini garanti etmeyeceğidir. İşlemcinin çalışmasını kazaya uğratan iki şey vardır: kesmeler ve sayfalama hataları.
     </para><para>
Kesme eylemcileri süreçler arasında unutulur gider. Komutlarını işlemci çalıştırır ama onlar bir sürecin parçası değillerdir. Bir kesme en yüksek öncelikli süreci bile durdurur. Bu durumda önemsiz derecede küçük gecikmelere izin vermelisiniz ve sürecinizin komutları arasında çok uzun gecikmelere sebep olabilecek kesme eylemcilere sahip aygıtların olmadığından da emin olmalısınız.
     </para><para>
Benzer şekilde, bir sayfalama hatası, basit bir komut dizisinin uzun bir zaman alıyormuş gibi görünmesine sebep olur. Aslında, sayfalama hatası sırasında bundan etkilenmeyen süreçler çalışmaya devam eder, çünkü G/Ç'ların tamamlanması gerekir, ancak yüksek öncelikli süreç onları atıp tekrar çalışmaya devam eder. Esas sorun G/Ç için, öncelikli sürecin kendisinin bekleme durumuna geçmesi olurdu. Bu evreyi etkisiz hale getirmek için <command>mlock</command> veya <command>mlockall</command> kullanılır.
     </para><para>
Bir öncelik vermeyi seçerken ve ayrıca yüksek mutlak öncelikli bir yazılım da çalıştırıyorsanız, aklınızda tutmanız gereken şey, tek işlem birimli tek işlemcili bir sistemde bu önceliğin mutlaklığının bunlar arasında bölüneceğidir. Diğer süreçlere göre daha yüksek mutlak öncelikli bir sürecin, yazılımındaki bir hatadan dolayı sonsuz döngüye girdiğini varsayalım. Çalışması sırasında işlemciden asla vazgeçmeyecektir. Bir komut çalıştırmak için onu öldürmekten başka çareniz kalmaz. Hatalı yazılım denetimi tamamen, her yönden ele geçirir.
     </para><para>
Bundan kaçınmanın iki yolu vardır: 1) bir yerlerde çalışmakta olan daha yüksek öncelikli bir kabuk bulundurursunuz (root'un açtığı bir kabuk örneğin). 2) yüksek öncelikli süreç grubu ile ilişkili bir denetim uçbirimi tutarsınız. Çalışmaya başlayan bir kesme eylemciden kaçacak ya da <keycap>C-c</keycap> tuşladığınızda sinyal alıp da durmayacak bir öncelik mevcut değildir.
     </para><para>
Bazı sistemler mutlak önceliği, işlemci zamanının belli bir yüzdesini bir sürece ayırmak manasında kullanırlar. Bir süper yüksek öncelikli ve ayrıcalıklı bir sürecin işlemci kullanımını sürekli gözlemesini sağlayarak, böylece paylaşıma girmeyen bir sürecin mutlak önceliğini yükselterek ve onu aşan bir sürecin mutlak önceliğini düşürerek bunu yaparlar.
     </para><para>
<note><para>Mutlak öncelik kimi zaman "durağan öncelik" diye de anılır; bu kılavuzda bu terimi kullanmıyoruz, çünkü mutlak önceliğin en önemli özelliğini, mutlaklığını kaybederiz.</para></note>
     </para></sect2></sect1>
    <sect1 id="glibc-Realtime-Scheduling">
      <title>Anlık Zamanlama</title>
      <titleabbrev>Eş öncelikli süreçler arasında zamanlama</titleabbrev>
      <para>
<indexterm scope="glibc-cp"><primary>zamanlama</primary><secondary>anlık</secondary></indexterm>
Aynı mutlak önceliğe sahip iki süreç aynı anda çalışmaya hazırsa, çekirdek bir karar vermek zorundadır, çünkü bir kerede sadece biri çalışabilir. Eğer süreçlerin mutlak öncelikleri 0 ise çekirdek bu kararı <xref linkend="glibc-Traditional-Scheduling"/> bölümünde anlatıldığı gibi verir.  Aksi takdirde vereceği kararı bu bölümde anlatacağız.
    </para><para>
Farklı mutlak önceliklere sahip iki süreç çalışmaya hazırsa verilecek karar basittir, bu <xref linkend="glibc-Absolute-Priority"/> bölümünde açıklanmıştı.
    </para><para>
Her sürecin kendine ait zamanlama kuralları vardır. Sıfırdan farklı mutlak önceliği olan süreçler için bunlar iki tanedir:
    </para><para>
<orderedlist numeration="arabic"><listitem>ilk gelen alır
      </listitem><listitem>döner turnuva düzenlenir
      </listitem></orderedlist></para><para>
En duyarlı durum, tüm süreçlerin aynı zamanlama kurallarına sahip olduğu ama farklı mutlak önceliklere sahip olduğu durumdur ki, bundan daha önce söz edilmişti.
    </para><para>
Turnuvada, süreçler işlemciyi paylaşırlar, her biri küçük bir zaman diliminde çalışırlar ve döner turnuva bağlamında bunu her turda bir kere yaparlar. Şüphesiz, bu turnuvaya sadece aynı mutlak önceliğe sahip ve aynı anda çalışmaya hazır süreçler katılırlar.
    </para><para>
İlk gelen alır durumunda ise, en uzun bekleyen süreç işlemciyi alır ve işlemciyi bırakmaya gönüllü olana kadar, bırakmaktan başka çare kalmayana dek (beklemeye geçmek gibi) ya da daha yüksek öncelikli bir süreç işlemciyi alana kadar işlemciyi tutar.
    </para><para>
İlk gelen alır kuralı, en yüksek mutlak öncelik ve kesmelerle sayfalama hatalarının dikkati denetlenmesiyle, bir sürecin mutlak olarak ve olumlu manada işlemciyi tam hızında çalıştırdığı takdirde kullanılması vazgeçilmezdir; değilse anlamlı değildir.
    </para><para>
Süreçlerin <command>sched_yield</command> çağrılarında, zamanlama kuralını belirtirken turnuva ile ilk gelen alır arasında iyi bir uzlaşımın sonucu olarak ilk gelen alır kuralını kullanmak konusunda akıllıca davranmalıdırlar.
    </para><para>
Farklı zamanlama kuralları olan aynı mutlak önceliğe sahip süreçler açısından zamanlamanın nasıl çalıştığını anlamak için, süreçlerin çalışmaya hazır süreçler listesine nasıl dahil edildiği ve nasıl listeden çıkarıldıkları ile ilgili ayrıntıları iyi bilmek zorundasınız:
    </para><para>
Her iki durumda da, çalışmaya hazır süreçlerin listesi gerçek bir kuyruk olarak düzenlenir. Süreç çalışmaya hazır olduğunda kuyruğun sonuna eklenir ve zamanlayıcı onu çalıştırmaya karar verdiğinde kuyruğun başına çekilir.Çalışmaya hazır olmak ile çalışıyor olmanın aynı anda olan şeyler olmadıklarına dikkat edin. Zamanlayıcı bir süreci çalıştırıyorsa o artık çalışmaya hazır bir süreç değildir ve dolayısıyla artık çalışmaya hazır süreçler listesinde değildir. Sürecin çalışması durduğunda tekrar çalışmaya hazır duruma gelir.
    </para><para>
Turnuva kuralına göre çalışacak bir süreç ile ilk gelen alır kuralına göre çalışacak bir süreç arasındaki tek fark, ilk durumdaki sürecin belli bir süre sonra işlemciyi bırakmak zorunda kalacağıdır. Bu olduğunda süreç tekrar çalışmaya hazır duruma gelir ve kuyruğa tekrar eklenir. Burada bahsedilen süre oldukça kısadır. Hem de gerçekten kısadır. Örneğin, Linux çekirdeğinde turnuva zaman dilimi, geleneksel zamanlama ile ilgili zaman diliminden bin kere daha kısadır.
    </para><para>
Bir süreç, kendini başlatan süreç ile aynı zamanlama kuralları ile oluşturulur. Bu durumu değiştirebilen işlevler <xref linkend="glibc-Basic-Scheduling-Functions"/> bölümünde açıklanmıştır.
    </para><para>
Sadece ayrıcalıklı bir süreç, mutlak önceliği <command>0</command>'dan farklı bir sürecin zamanlama kuralını ayarlayabilir.
    </para></sect1>
    <sect1 id="glibc-Basic-Scheduling-Functions">
      <title>Temel Zamanlama İşlevleri</title>
      <titleabbrev>Zamanlama kurallarını alınması/belirtilmesi, öncelik</titleabbrev>
      <para>
Bu bölümdeki işlevler, mutlak önceliği ve bir sürecin zamanlama kuralını ayarlamakta kullanılan GNU C kütüphanesindeki işlevlerdir.
    </para><para>
<note><title>Taşınabilirlik Bilgisi</title><para>Bu işlevlere sahip sistemlerde <command>_POSIX_PRIORITY_SCHEDULING</command> makrosu  <filename>unistd.h</filename> başlık dosyasında tanımlanmıştır.</para></note>
    </para><para>
Zamanlama kurallarının geleneksel zamanlama ile ilgili olduğu durumda zamanlamanın daha hassas ayarlanabileceği işlevleri <xref linkend="glibc-Traditional-Scheduling"/> bölümünde bulabilirsiniz.
    </para><para>
Bu işlevlerin yapısı ve isimlendirilmesi bakımından denenecek çok fazla birşey yoktur. Bunlar POSIX.1b tarafından tanımlanmış olduğundan bu kılavuzda bahsedilen kavramlarla uyuşmamaları normaldir. Çünkü GNU C kütüphanesinin kullanıldığı sistemlerdeki gerçekleme POSIX yapısı ile ilgili kavramsallaştırmanın tersidir. POSIX şeması birincil zamanlama parametresinin zamanlama kuralları olduğunu ve öncelik değerinin (varsa), zamanlama kurallarının bir parametresi olduğunu kabul eder. Gerçeklemede ise ister istemez, öncelik değeri kraldır ve zamanlama kuralları, eğer varsa, önceliği etkileyen ince bir ayardır.
    </para><para>
Bu bölümdeki semboller <filename>sched.h</filename> başlık dosyasında bildirilmiştir.
    </para><para>
<indexterm scope="glibc-tp"><primary sortas="sched_param">struct sched_param</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü" id="glibc-struct-sched_param">
<funcdef>struct <command>sched_param</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu yapı bir mutlak önceliği tanımlar.
    </para><para><glosslist><glossentry><glossterm>
    <literal>int <command>ssched_priority</command></literal>
    </glossterm><glossdef><para>mutlak öncelik değeri
    </para></glossdef></glossentry></glosslist>
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>sched_setscheduler</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-sched_setscheduler">
<funcdef>int <command>sched_setscheduler</command></funcdef>
<paramdef>(pid_t                     <varname>pid</varname>,
 int                       <varname>kural</varname>,
 const struct sched_param *<varname>öncelik</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev bir sürecin hem mutlak önceliğini hem de zamanlama kuralını ayarlar.
    </para><para>
Süreç kimliği <varname>pid</varname> olan sürecin ya da <varname>pid</varname> olarak sıfır verildiğinde çağrıldığı sürecin mutlak önceliğini <varname>öncelik</varname> ile, zamanlama kuralını <varname>kural</varname> ile belirtilen değere ayarlar. Eğer <varname>kural</varname> negatifse işlev mevcut zamanlama kuralını değiştirmez.
    </para><para>
İşlevin <varname>kural</varname> argümanında belirtilebilecek değerler şunlardır:
    </para><para><variablelist><varlistentry>
    <term><literal>SCHED_OTHER</literal></term><listitem><para>
Geleneksel zamanlama
       </para></listitem></varlistentry><varlistentry>
       <term><literal>SCHED_FIFO</literal></term><listitem><para>
İlk gelen alır
       </para></listitem></varlistentry><varlistentry>
       <term><literal>SCHED_RR</literal></term><listitem><para>
Döner turnuva
       </para></listitem></varlistentry></variablelist>
     </para><para>
İşlev başarılıysa  <command>0</command> ile döner.  <command>-1</command> ile dönmüşse bir hata oluşmuştur. Bu durumda <command>errno</command> değişkeni şu hata durumlarından birini içerir:
    </para><para><variablelist><varlistentry>
    <term><literal>EPERM</literal></term><listitem><para>
    <itemizedlist><listitem><para>
Çağıran süreç <command>CAP_SYS_NICE</command> yetkisine sahip değil ve  <varname>kural</varname> değeri <command>SCHED_OTHER</command> değil (ya da değeri negatif ve mevcut kural <command>SCHED_OTHER</command> değil).
         </para></listitem><listitem><para>
Çağıran süreç <command>CAP_SYS_NICE</command> yetkisine sahip değil ve sahibi hedef sürecin sahibi değil. Yani çağıran sürecin etkin kullanıcı kimliği <varname>pid</varname> süreç kimlikli sürecin ne etkin ne de gerçek kullanıcı kimliğidir.
         </para></listitem></itemizedlist>
         </para></listitem></varlistentry><varlistentry>
         <term><literal>ESRCH</literal></term><listitem><para>
<varname>pid</varname> sıfırdan farklı olduğu halde <varname>pid</varname> süreç kimlikli bir süreç yok.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>EINVAL</literal></term><listitem><para>
       <itemizedlist><listitem><para>
<varname>kural</varname> mevcut bir zamanlama kuralını ifade etmiyor.
         </para></listitem><listitem><para>
<varname>*öncelik</varname> ile belirtilen mutlak öncelik <varname>kural</varname> zamanlama kuralı için (ya da <varname>kural</varname> negatifse mevcut zamanlama kuralı için) geçerli aralığın dışında ya da <varname>öncelik</varname> bir boş gösterici. Geçerli aralığın ne olduğunu <command>sched_get_priority_max</command> ve <command>sched_get_priority_min</command> işlevleri ile öğrenebilirsiniz.
         </para></listitem><listitem><para>
<varname>pid</varname> negatif.
         </para></listitem></itemizedlist>
         </para></listitem></varlistentry></variablelist>
       </para><para>
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>sched_getscheduler</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-sched_getscheduler">
<funcdef>int <command>sched_getscheduler</command></funcdef>
<paramdef>(pid_t <varname>pid</varname>)</paramdef>
</funcprototype><funcdescr><para>
Süreç kimliği <varname>pid</varname> olan sürecin ya da <varname>pid</varname> olarak sıfır verildiğinde çağrıldığı sürece atanmış zamanlama kuralını döndürür.
    </para><para>
İşlevin normal dönüş değeri zamanlama kuralıdır. Olası değerler için <command>sched_setscheduler</command> işlevine bakınız.
    </para><para>
İşlev başarısız olursa <command>-1</command> döner ve  <command>errno</command> değişkenine şu hata durumlarından biri atanır:
    </para><para><variablelist><varlistentry>
    <term><literal>ESRCH</literal></term><listitem><para>
<varname>pid</varname> sıfırdan farklı ve böyle bir süreç yok.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>EINVAL</literal></term><listitem><para>
<varname>pid</varname> negatif.
       </para></listitem></varlistentry></variablelist>
     </para><para>
Bu işlevin <command>sched_setscheduler</command> işlevinin tam karşılığı olmadığına dikkat edin, <command>sched_setscheduler</command> işlevi hem zamanlama kuralını hem de mutlak önceliği belirlemek için kullanılabilirken bu işlev sadece zamanlama kuralını döndürür. Mutlak önceliği öğrenmek için  <command>sched_getparam</command> işlevini kullanabilirsiniz.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>sched_setparam</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-sched_setparam">
<funcdef>int <command>sched_setparam</command></funcdef>
<paramdef>(pid_t                     <varname>pid</varname>,
 const struct sched_param *<varname>öncelik</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev sürecin mutlak önceliğini değiştirmekte kullanılır.
    </para><para>
İşlevselliği <varname>kural</varname> = <command>-1</command> olduğunda <command>sched_setscheduler</command> işlevindeki ile aynıdır.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>sched_getparam</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-sched_getparam">
<funcdef>int <command>sched_getparam</command></funcdef>
<paramdef>(pid_t                     <varname>pid</varname>,
 const struct sched_param *<varname>öncelik</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev sürecin mutlak önceliği ile döner.
    </para><para>
<varname>pid</varname>, mutlak önceliği öğrenilmek istenen sürecin süreç kimliğidir.
    </para><para>
<varname>öncelik</varname> ise sürecin mutlak önceliğini içeren yapıya bir göstericidir.
    </para><para>
Başarı durumunda işlevin dönüş değeri <command>0</command>'dır. Aksi takdirde <command>-1</command> döner ve <command>errno</command> değişkenine şu değerler biri atanır:
    </para><para><variablelist><varlistentry>
    <term><literal>ESRCH</literal></term><listitem><para>
<varname>pid</varname> sıfırdan farklı ve böyle bir süreç yok.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>EINVAL</literal></term><listitem><para>
<varname>pid</varname> negatif.
       </para></listitem></varlistentry></variablelist>
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>sched_get_priority_min</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-sched_get_priority_min">
<funcdef>int <command>sched_get_priority_min</command></funcdef>
<paramdef>(int *<varname>kural</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev <varname>kural</varname> zamanlama kuralı için bir sürecin alabileceği en düşük mutlak öncelik değeri ile döner.
    </para><para>
Linux'ta, <command>SCHED_OTHER</command> için <command>0</command> diğerleri için <command>1</command>'dir.
    </para><para>
Başarı durumunda işlevin dönüş değeri <command>0</command>'dır. Aksi takdirde <command>-1</command> döner ve <command>errno</command> değişkenine şu değerler biri atanır:
    </para><para><variablelist><varlistentry>
    <term><literal>EINVAL</literal></term><listitem><para>
<varname>kural</varname> mevcut bir zamanlama kuralı değil.
       </para></listitem></varlistentry></variablelist>
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>sched_get_priority_max</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-sched_get_priority_max">
<funcdef>int <command>sched_get_priority_max</command></funcdef>
<paramdef>(int *<varname>kural</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev <varname>kural</varname> zamanlama kuralı için bir sürecin alabileceği en yüksek mutlak öncelik değeri ile döner.
    </para><para>
Linux'ta, <command>SCHED_OTHER</command> için <command>0</command> diğerleri için <command>99</command>'dur.
    </para><para>
Başarı durumunda işlevin dönüş değeri <command>0</command>'dır. Aksi takdirde <command>-1</command> döner ve <command>errno</command> değişkenine şu değerler biri atanır:
    </para><para><variablelist><varlistentry>
    <term><literal>EINVAL</literal></term><listitem><para>
<varname>kural</varname> mevcut bir zamanlama kuralı değil.
       </para></listitem></varlistentry></variablelist>
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>sched_rr_get_interval</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-sched_rr_get_interval">
<funcdef>int <command>sched_rr_get_interval</command></funcdef>
<paramdef>(pid_t            <varname>pid</varname>,
 struct timespec *<varname>süre</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev turnuva zamanlama kuralı kullanıldığında <varname>pid</varname> kimlikli sürecin işlemciyi kullanabileceği süreyi döndürür.
    </para><para>
Sonuç <varname>süre</varname> ile döner.
    </para><para>
Linux çekirdeği için turnuva zaman dilimi daima 150 mikrosaniyedir ve  <varname>pid</varname> değerinin gerçek bir süreç kimliği olması bile gerekmez.
    </para><para>
Başarı durumunda işlevin dönüş değeri <command>0</command>'dır. Aksi takdirde, imkansız olsa bile <command>-1</command> dönebilir. Ancak <command>errno</command> değişkenine atanmak üzere belirlenmiş bu işleve özgü özel bir hata durumu yoktur.
    </para><para>
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>sched_yield</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-sched_yield">
<funcdef>int <command>sched_yield</command></funcdef>
<paramdef>(void)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev, sürecin işlemci üzerindeki haklarından vazgeçilmesini sağlar.
    </para><para>
Teknik olarak, <command>sched_yield</command> işlevi sürecin hemen tekrar çalışmaya hazır duruma (işlev çağrıldığında çalışmakta olmanın tersine) gelmesine sebep olur. Yani, sürecin mutlak önceliği sıfırdan farklıysa, mutlak öncelikleri mutlak önceliği ile aynı olan süreçlerin bulunduğu süreç listesinin kuyruğuna çalışmaya hazır süreç olarak eklenip sırasının gelmesini bekler. Mutlak önceliği sıfırsa bu işlem daha karmaşıklaşır, ancak işlemcinin başka bir sürece bırakılması yine de gerçekleşir.
    </para><para>
Eğer mutlak öncelik bakımından eşdeğerde başka bir süreç yoksa bu işlev hiçbir şey yapmaz.
    </para><para>
İşlevi içeren süreç açısından süreç, başka bir sürecin ne yaptığı ya da ne kadar hızlı çalıştığının farkında değildir, işlev bu bakımdan işlevsizdir.
    </para><para>
Başarı durumunda işlevin dönüş değeri <command>0</command>'dır. Aksi takdirde, imkansız olsa bile <command>-1</command> dönebilir. Ancak <command>errno</command> değişkenine atanmak üzere belirlenmiş bu işleve özgü özel bir hata durumu yoktur.
    </para></funcdescr></funcsynopsis></para></sect1>
    <sect1 id="glibc-Traditional-Scheduling">
      <title>Geleneksel Zamanlama</title>
      <titleabbrev>Kaba yığınlar arasında zamanlama</titleabbrev>
      <para/><para>
<indexterm scope="glibc-cp"><primary>zamanlama</primary><secondary>geleneksel</secondary></indexterm>
Bu bölüm mutlak önceliği sıfır olan süreçlerin zamanlanması hakkındadır.
Yüksek mutlak öncelikli süreçler istediklerini aldıktan sonra geriye kalan işlemci zamanı artıkları, burada tanımlanan zamanlama kuralına göre el değmemiş irice süreçler arasında paylaştırılır.
    </para>
      <sect2 id="glibc-Traditional-Scheduling-Intro" chunkthis="1">
        <title>Geleneksel Zamanlamaya Giriş</title>
        <para>
<link linkend="glibc-Absolute-Priority">Mutlak öncelikler</link> ortaya çıkmadan çok önceleri Unix sistemleri işlemci zamanlamasını bu şekilde yapıyordu. Posix Romalılar gibi çıkagelip gerçek zamanlı işlemin gereksinimlerini karşılamak üzere mutlak öncelikleri ortaya attı ve köydeki Sıfır Mutlak Öncelikli süreçlerin kendilerini kendi bildikleri zamanlama kurallarına göre yönetmelerine izin verdi.
     </para><para>
Gerçekten, sıfırdan büyük mutlak öncelikler, esas olarak gerçek zamanlı işlem yapmak üzere tasarlanmış bilgisayarların sistemleri dışında günümüzdeki çoğu sistemde kullanılmamaktadır. Bu bakımdan, bu bölümde sadece çoğu yazılımcının bilmek istediği zamanlamadan söz edilecektir.
     </para><para>
Bu zamanlamanın kapsamı hakkında daha temiz bir giriş olarak: Herhangi bir anda mutlak önceliği sıfır olan bir süreç ile mutlak önceliği sıfırdan büyük bir süreç aynı anda çalışmaya hazırsa, mutlak önceliği sıfır olan çalışmaz. Eğer mutlak önceliği sıfır olan bir süreç çalışmaktayken mutlak önceliği sıfırdan büyük bir süreç çalışmaya hazır olursa mutlak önceliği sıfır olanın çalışması hemen durdurulur.
     </para><para>
Mutlak önceliği sıfır olma durumuna ek olarak, sürecin çalışması esnasında değişen bir öncelik olarak <wordasword>özdevimli öncelik</wordasword> olarak bilinen bir öncelik daha vardır. Mutlak önceliği sıfırdan büyük süreçler için özdevimli öncelik anlamlı değildir.
     </para><para>
Özdevimli öncelik kimi zaman işlemciyi kimin alacağını, kimi zaman işlemciyi ne kadar süreyle kullanacağını, kimi zaman da bir sürecin başka bir süreci işlemciden kovup kovamayacağını belirler.
     </para><para>
Linux'ta, değer bunların bir karışımı olarak ortaya çıkar. Fakat çoğunlukla bu değer sürecin işlemciyi kullanma süresini belirler.   Özdevimli önceliği daha yüksek olan süreç, işlemciyi bir kere aldı mı, daha uzun süre onu kullanır. Eğer, G/Ç beklemek gibi şeyler yapmak için kendi zaman dilimi içinde işini bitiremezse, tekrar hazır olduğunda kendi zaman dilimini tamamlamak üzere işlemciyi alması için öne alınır. Bunun dışında, yeni zaman dilimleri için süreçlerin seçimi temel olarak turnuva sistemine göre yapılır. Fakat zamanlayıcı düşük öncelikli süreçlere bir kemik atar: Bir sürecin özdevimli önceliği, zamanlama işleminde her aşağılanışında yükselir. Linux'ta, oyunu hep şişko velet kazanır.
     </para><para>
Bir sürecin özdevimli önceliğinin iniş çıkışları başka bir değerle düzene sokulur: <wordasword>nezaket değeri</wordasword> (ing.si "nice value" olan değer). Nezaket değeri bir tamsayıdır ve -20 ile 20 arasında olup, bir sürecin özdevimli önceliğinin uç değerlerini ifade eder. Daha yüksek bir nezaket daha düşük bir sınır gösterir.
     </para><para>
Tipik bir Linux sisteminde, örneğin, nezaket değeri 20 olan bir süreç işlemci zamanının sadece 10 milisaniyesini alabilir, -20 olan bir süreç ise daha yüksek bir öncelikle işlemci zamanının 400 milisaniyesini alabilecektir.
     </para><para>
Nezaket değeri gerçekten bir kibarlık, saygılılık belirtir. Başlarda, Unix'in cennet bahçesinde, tüm süreçler bilgisayar sisteminin nimetlerini eşit olarak paylaşırdı. Ama tüm süreçler aynı işlemci zamanını paylaşma ihtiyacı göstermez, bu durumda nezaket değeri, diğer süreçler yararına kibar bir sürecin payına düşen işlemci süresinden feragat etmesini sağlar. Dolayısıyla, nezaket değeri daha yüksek olan süreç daha kibar süreç olur. (Bir yılan geldi ve bir sürece bir negatif nezaket değeri sundu böylece bugün kaba özkaynak ayırma sistemi olarak bildiğimiz sistem ortaya çıktı).
     </para><para>
Özdevimli öncelikler işlemci zamanının ayrılmasını nesnel olarak pürüzsüzleştirerek ve seyrek isteklere hızlı yanıt vererek yukarı ve aşağı doğru meylederler. Fakat kendi nezaket sınırlarını asla aşmazlar, böylece işlemcinin ağır yük altında olduğu durumda nezaket değeri etkin olarak bir sürecin ne kadar hızlı çalışacağını belirler.
     </para><para>
Unix süreç önceliğinin toplumcu mirasına uymak için, bir süreç kendini çalıştıran süreçle aynı nezaket değeri ile oluşur ve onu yükseltebilir. Bir süreç ayrıca sahibi aynı kullanıcı olan (ya da aynı etkin kimlikli) başka bir sürecin de nezaket değerini yükseltebilir. Fakat sadece ayrıcalıklı süreç kendi nezaket değerini düşürebilir. Bir ayrıcalıklı süreç ayrıca başka bir sürecin nezaket değerini de arttırıp azaltabilir.
     </para><para>
Nezaket değerlerini öğrenmek ve belirlemek için kullanılan GNU C kütüphanesi işlevleri <xref linkend="glibc-Traditional-Scheduling-Functions"/> bölümünde açıklanmıştır.
     </para></sect2>
      <sect2 id="glibc-Traditional-Scheduling-Functions" chunkthis="1">
        <title>Geleneksel Zamanlama İşlevleri</title>
        <para>
<indexterm scope="glibc-pg"><primary>sys/resource.h</primary></indexterm>
Bu bölümde bir sürecin nezaket değerinin nasıl okunabileceğinden ve nasıl belirtilebileceğinden bahsedilecektir. Bu sembollerin tamamı <filename>sys/resource.h</filename> başlık dosyasında bildirilmiştir.
     </para><para>
İşlev ve makro isimleri POSIX tarafından tanımlanmıştır. POSIX'te ve bu kılavuzda isimlendirme için "öncelik" (priority) terimi kullanılmış olmasına rağmen işlevler aslında nezaket değerleri ile işlem yaparlar.
     </para><para>
Geçerli nezaket değerleri çekirdeğe bağlı olmasına rağmen, genellikle  <command>-20</command> ile <command>20</command> arasındadır.  Daha düşük bir nezaket değeri daha yüksek önceliğe karşılıktır. Öncelik değerlerinin aralığını belirleyen sabitler şunlardır:
     </para><para><variablelist><varlistentry>
     <term><literal>PRIO_MIN</literal></term><listitem><para>
Geçerli en düşük nezaket değeri.
        </para></listitem></varlistentry><varlistentry>
        <term><literal>PRIO_MAX</literal></term><listitem><para>
Geçerli en yüksek nezaket değeri.
        </para></listitem></varlistentry></variablelist>
      </para><para>
<indexterm scope="glibc-fn"><primary>getpriority</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-getpriority">
<funcdef>int <command>getpriority</command></funcdef>
<paramdef>(int <varname>sınıf</varname>,
 int <varname>kimlik</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bir süreç kümesinin nezaket değerini döndürür; <varname>sınıf</varname> ve <varname>kimlik</varname> hangisi olduğunu belirtir (aşağıya bakınız). Eğer belirtilen süreçlerin hepsi aynı nezaket değerine sahip değilse, işlev bunların içinden en düşük nezaket değerini döndürür.
     </para><para>
İşlev başarılı olursa <command>0</command> ile döner.  Hata oluşmuşsa <command>-1</command> döner ve <command>ERRNO</command> değişkenine hata durumu atanır.  Aşağıdaki <command>errno</command> hata durumları bu işlev için tanımlanmıştır:
     </para><para><variablelist><varlistentry>
     <term><literal>ESRCH</literal></term><listitem><para>
<varname>sınıf</varname> ve <varname>kimlik</varname> birlikte mevcut herhangi bir süreçle uyuşmuyor.
        </para></listitem></varlistentry><varlistentry>
        <term><literal>EINVAL</literal></term><listitem><para>
<varname>sınıf</varname> değeri geçersiz.
        </para></listitem></varlistentry></variablelist>
      </para><para>
Dönen değer <command>-1</command> olduğundan bunun bir başarısızlık mı yoksa bir nezaket değeri mi olduğunu anlayabilmek için tek yol  <command>getpriority</command> çağrısından önce <command>errno</command> değişkenine <command>0</command> değeri atamaktır. Çağrının ardından <command>errno != 0</command> kullanarak başarısızlık sınaması yapabilirsiniz.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>setpriority</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-setpriority">
<funcdef>int <command>setpriority</command></funcdef>
<paramdef>(int <varname>sınıf</varname>,
 int <varname>kimlik</varname>,
 int <varname>nezaket</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bir süreç kümesinin nezaket değerini <varname>nezaket</varname> değerine ayarlar;<varname>sınıf</varname> ve <varname>kimlik</varname> hangisi olduğunu belirtir (aşağıya bakınız).
     </para><para>
İşlev başarılı olursa <command>0</command> ile döner.  Hata oluşmuşsa <command>-1</command> döner.  Aşağıdaki <command>errno</command> hata durumları bu işlev için tanımlanmıştır:
     </para><para><variablelist><varlistentry>
     <term><literal>ESRCH</literal></term><listitem><para>
<varname>sınıf</varname> ve <varname>kimlik</varname> birlikte mevcut herhangi bir süreçle uyuşmuyor.
        </para></listitem></varlistentry><varlistentry>
        <term><literal>EINVAL</literal></term><listitem><para>
<varname>sınıf</varname> değeri geçersiz.
        </para></listitem></varlistentry><varlistentry>
        <term><literal>EPERM</literal></term><listitem><para>
Çağrı, sahibi çağıran süreçten farklı bir kulllanıcıya ait bir sürecin nezaket değerini değiştirmeye çalışıyor (yani, hedef sürecin gerçek ya da etkin kullanıcı kimliği işlevi çağıran sürecin ektin kullanıcı kimliği ile aynı değil) ve işlevi çağıran süreç <command>CAP_SYS_NICE</command> yetkisine sahip değil.
        </para></listitem></varlistentry><varlistentry>
        <term><literal>EACCES</literal></term><listitem><para>
Çağrı daha düşük bir nezaket değeri isteği yaptı ama sürecin <command>CAP_SYS_NICE</command> yetkisi yok.
        </para></listitem></varlistentry></variablelist>
</para></funcdescr></funcsynopsis></para><para>
<varname>sınıf</varname> ve <varname>kimlik</varname> argümanları birlikte ilgilendiğiniz süreç kümesini belirtirler. <varname>sınıf</varname> için olası değerler şunlardır:
     </para><para><variablelist><varlistentry>
     <term><literal>PRIO_PROCESS</literal></term><listitem><para>
Belirli bir süreç. <varname>kimlik</varname> sürecin süreç kimliğidir.
        </para></listitem></varlistentry><varlistentry>
        <term><literal>PRIO_PGRP</literal></term><listitem><para>
Belirli bir süreç grubundaki bütün süreçler. <varname>kimlik</varname> süreç grup kimliğidir.
        </para></listitem></varlistentry><varlistentry>
        <term><literal>PRIO_USER</literal></term><listitem><para>
Belirli bir kullanıcıya ait olan tüm süreçler (yani, gerçek kullanıcı kimliği kullanıcı ile aynı olan süreçler). <varname>kimlik</varname> kullanıcının kullanıcı kimliğidir.
        </para></listitem></varlistentry></variablelist>
      </para><para>
Eğer <varname>kimlik</varname> değeri sıfırsa, bu çağıran süreci belirtir, süreç grubu ya da sürecin sahibi <varname>sınıf</varname> ile belirtilir.
     </para><para>
<indexterm scope="glibc-fn"><primary>nice</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-nice">
<funcdef>int <command>nice</command></funcdef>
<paramdef>(int <varname>artış</varname>)</paramdef>
</funcprototype><funcdescr><para>
Çağıran sürecin nezaket değerini <varname>artış</varname> kadar arttırır. İşlev başarılı olursa yeni nezaket değeri ile döner. <command>-1</command> dönüş değeri ise bir hata oluştuğunu gösterir. Bu durumda <command>errno</command> değişkenine <command>setpriority</command> işlevindeki değerler atanır.
     </para><para>
<command>nice</command> işlevine eşdeğer bir işlev tanımı:
     </para><para>
<screen>int
nice (int artis)
{
  int sonuc, eski = getpriority (PRIO_PROCESS, 0);
  sonuc = setpriority (PRIO_PROCESS, 0, eski + artis);
  if (sonuc != -1)
      return eski + artis;
  else
      return -1;
}
</screen></para></funcdescr></funcsynopsis></para></sect2></sect1>
   <sect1 id="glibc-CPU-Affinity">
    <title>İşlemciler Arasında İcra Sınırlaması</title>
    <para>
Çok işlemcili bir sistemde, işletim sistemi sistemin en verimli çalışmasını mümkün kılan bir yolla farklı süreçleri mevcut işlemcilere dağıtır. Zamanlama işlevselliğini genişleterek hangi süreçlerin ve evrelerin çalışabileceği geçtiğimiz bölümlerde açıklanmıştı.  Fakat hangi işlemcinin sonuçta hangi süreç ya da evreyi çalıştıracağı konumuzun dışındadır.
    </para><para>
Bir yazılımın sistemi bu bakımdan denetimi altına almak zorunda bırakan bazı sebepler vardır:
    </para><para><itemizedlist>
     <listitem><para>
Mutlak olarak kritik bir işlem yürütme durumunda olan bir süreç ya da evre hiçbir şart altında durdururulmamalı veya işlemci özkaynaklarını kullanarak başka süreçler tarafından engellenmemelidir. Bu durumda özel süreç için, hiçbir süreç ya da evre tarafından kullanılmasına izin verilmeyen bir işlemci tahsis edilmelidir.
      </para></listitem><listitem><para>
Belirli özkaynaklara (RAM, G/Ç portları) farklı işlemcilerden erişim maliyetleri farklıdır. Böyle bir duruma NUMA (Non-Uniform Memory Architecture -- Tektip olmayan bellek mimarisi) makinelerde rastlanır. Tercihan, belleğe yerel olarak erişilmelidir fakat bu gereksinim genelde zamanlayıcıya görünür değildir. Bundan dolayı kullanılan belleğe yerel erişime sahip işlemcilerin bir sürece ya da evreye ayrılması başarımın belirgin biçimde artmasına yardımcı olur.
      </para></listitem><listitem><para>
Çalışma anında denetim altında özkaynak ayrılması ve toparlama çalışmalarında (örn, çöp toplama) başarım işlemcilerin yerel işlem yapmasına bağlıdır. Eğer özkaynaklar farklı işlemcilerin rasgele erişimine karşı korunmamışsa, bu, kilitleme maliyetlerini düşürmeye yardımcı olur.
      </para></listitem></itemizedlist>
    </para><para>
Şimdiye kadar POSIX standardı bu sorunun çözümüne pek yardımcı olmadı. Linux çekirdeği, bir işlemci için <wordasword>akrabalık kümeleri</wordasword> belirtilmesini mümkün kılan bir arayüz ailesi sağlar. Zamanlayıcı süreç ya da evreyi işlemciler üzerinde belirtilen akrabalık maskesine göre zamanlar. GNU C kütüphanesindeki arayüzler Linux çekirdeğindeki arayüz biraz genişletilerek tanımlanmıştır.
    </para><para>
<indexterm scope="glibc-tp"><primary>cpu_set_t</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü" id="glibc-cpu_set_t">
<funcdef><command>cpu_set_t</command></funcdef>
</funcprototype><funcdescr><para>
Bu veri türü her biri bir işlemciyi ifade eden bir bit kümesidir. İşlemcilerin bit kümesinin hangi bitleriyle eşleneceği sisteme bağlıdır. Veri türünün genişliği sabittir; sistemdeki işlemcileri ifade etmek için veri türünün genişliğini yetersiz kaldığı durumda başka bir arayüz kullanılmalıdır.
    </para><para>
Bu veri türü bir GNU oluşumudur ve <filename>sched.h</filename> dosyasında tanımlanmıştır.
    </para><para>
Bit kümesiyle çalışmak, bitleri belirtmek ve sıfırlamak için bazı makrolar tanımlanmıştır. Makroların bazıları parametre olarak bir işlemci numarası alır. Burada önemli olan bit kümesi genişliğinin aşılmamasıdır. Bu makro <command>cpu_set_t</command> bit kümesindeki bitlerin sayısını belirler:
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-vr"><primary>CPU_SETSIZE</primary></indexterm>
<funcsynopsis><funcprototype role="makro" id="glibc-CPU_SETSIZE">
<funcdef>int <command>CPU_SETSIZE</command></funcdef>
</funcprototype><funcdescr><para>
Bir <command>cpu_set_t</command> nesnesi ile elde edilebilecek işlemci sayısıdır.
</para></funcdescr></funcsynopsis></para><para>
<command>cpu_set_t</command> veri türü şeffaf olmadığından bu veri türü ile ilgili çalışmalar aşağıdaki dört makro ile yürütülmelidir.
    </para><para>
<indexterm role="glibc-fn"><primary>CPU_ZERO</primary></indexterm>
<funcsynopsis><funcprototype role="makro" id="glibc-CPU_ZERO">
<funcdef>void <command>CPU_ZERO</command></funcdef>
<paramdef>(cpu_set_t *<varname>küme</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu makro <varname>küme</varname> işlemci kümesini bir boş küme olarak ilklendirir.
    </para><para>
Bu makro bir GNU oluşumudur ve <filename>sched.h</filename> dosyasında tanımlanmıştır.
</para></funcdescr></funcsynopsis></para><para>
<indexterm role="glibc-fn"><primary>CPU_SET</primary></indexterm>
<funcsynopsis><funcprototype role="makro" id="glibc-CPU_SET">
<funcdef>void <command>CPU_SET</command></funcdef>
<paramdef>(int        <varname>işlemci</varname>,
 cpu_set_t *<varname>küme</varname>)</paramdef>
</funcprototype><funcdescr><para>
<varname>işlemci</varname> işlemcisini <varname>küme</varname> işlemci kümesine ekler.
    </para><para>
Defalarca işleme sokulacağından <varname>işlemci</varname> parametresinin yan etkilere sebep olmayacak şekilde belirtilmesi önemlidir.
    </para><para>
Bu makro bir GNU oluşumudur ve <filename>sched.h</filename> dosyasında tanımlanmıştır.
</para></funcdescr></funcsynopsis></para><para>
<indexterm role="glibc-fn"><primary>CPU_CLR</primary></indexterm>
<funcsynopsis><funcprototype role="makro" id="glibc-CPU_CLR">
<funcdef>void <command>CPU_CLR</command></funcdef>
<paramdef>(int        <varname>işlemci</varname>,
 cpu_set_t *<varname>küme</varname>)</paramdef>
</funcprototype><funcdescr><para>
<varname>işlemci</varname> işlemcisini <varname>küme</varname> işlemci kümesinden kaldırır.
    </para><para>
Defalarca işleme sokulacağından <varname>işlemci</varname> parametresinin yan etkilere sebep olmayacak şekilde belirtilmesi önemlidir.
    </para><para>
Bu makro bir GNU oluşumudur ve <filename>sched.h</filename> dosyasında tanımlanmıştır.
</para></funcdescr></funcsynopsis></para><para>
<indexterm role="glibc-fn"><primary>CPU_ISSET</primary></indexterm>
<funcsynopsis><funcprototype role="makro" id="glibc-CPU_ISSET">
<funcdef>int <command>CPU_ISSET</command></funcdef>
<paramdef>(int        <varname>işlemci</varname>,
 cpu_set_t *<varname>küme</varname>)</paramdef>
</funcprototype><funcdescr><para>
Eğer <varname>işlemci</varname> işlemcisi <varname>küme</varname> işlemci kümesinin bir üyesi ise bu makro sıfırdan farklı bir değerle (doğru), değilse sıfırla (yanlış) döner.
    </para><para>
Defalarca işleme sokulacağından <varname>işlemci</varname> parametresinin yan etkilere sebep olmayacak şekilde belirtilmesi önemlidir.
    </para><para>
Bu makro bir GNU oluşumudur ve <filename>sched.h</filename> dosyasında tanımlanmıştır.
</para></funcdescr></funcsynopsis></para><para>
İşlemci bit kümeleri ya sıfırdan oluşturulur ya da o an kurulu bir akrabalık maskesi olarak sistemden alınır.
    </para><para>
<indexterm role="glibc-fn"><primary>sched_getaffinity</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-sched_getaffinity">
<funcdef>int <command>sched_getaffinity</command></funcdef>
<paramdef>(pid_t      <varname>pid</varname>,
 size_t     <varname>kümegenişliği</varname>,
 cpu_set_t *<varname>küme</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev işlemci akrabalık maskesini kimliği <varname>pid</varname> ile belirtilen süreç ya da evre için genişliği <varname>kümegenişliği</varname> bayt olarak belirtilen ve <varname>küme</varname> ile gösterilen bir nesne olarak döndürür. İşlev başarılı olduğunda daima <command>cpu_set_t</command> nesnesindeki tüm bitleri ilklendirir ve sıfırla döner.
    </para><para>
Eğer, <varname>pid</varname> bir süreç ya da evreye karşılık değilse ya da işlev bir sebeple başarısız olmuşsa <command>-1</command> ile döner ve <command>errno</command> değişkenine hata durumu atanır.
    </para><para><variablelist><varlistentry>
      <term><command>ESRCH</command></term>
      <listitem><para>
Belirtilen kimliğe sahip bir süreç ya da evre yok.
       </para></listitem></varlistentry><varlistentry>
      <term><command>EFAULT</command></term>
      <listitem><para>
<varname>küme</varname> göstericisi geçerli bir nesneyi göstermiyor.
       </para></listitem></varlistentry></variablelist>
    </para><para>
Bu işlev bir GNU oluşumudur ve <filename>sched.h</filename> dosyasında bildirilmiştir.
    </para><para>
Bunun, farklı POSIX evreleri için bilgi almak amacıyla kullanılmasının büyük ihtimalle taşınabilir olmayacağına dikkat çekmek gerekir. Bu durum için başka bir arayüz sağlanmalıdır.
</para></funcdescr></funcsynopsis></para><para>
<indexterm role="glibc-fn"><primary>sched_setaffinity</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-sched_setaffinity">
<funcdef>int <command>sched_setaffinity</command></funcdef>
<paramdef>(pid_t            <varname>pid</varname>,
 size_t           <varname>kümegenişliği</varname>,
 const cpu_set_t *<varname>küme</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev işlemci akrabalık maskesini kimliği <varname>pid</varname> ile belirtilen süreç ya da evre için genişliği <varname>kümegenişliği</varname> bayt olarak belirtilen ve <varname>küme</varname> ile gösterilen bir nesneye göre belirler. İşlev başarılı olduğunda sıfırla dönecek ve zamanlayıcı bu akrabalık bilgisini gelecekte hesaba katacaktır.
    </para><para>
İşlev bir sebeple başarısız olmuşsa <command>-1</command> ile döner ve <command>errno</command> değişkenine hata durumu atanır.
    </para><para><variablelist><varlistentry>
      <term><command>ESRCH</command></term>
      <listitem><para>
Belirtilen kimliğe sahip bir süreç ya da evre yok.
       </para></listitem></varlistentry><varlistentry>
      <term><command>EFAULT</command></term>
      <listitem><para>
<varname>küme</varname> göstericisi geçerli bir nesneyi göstermiyor.
       </para></listitem></varlistentry><varlistentry>
      <term><command>EINVAL</command></term>
      <listitem><para>
Bit kümesi geçersiz. Bu, akrabalık kümesindeki bir işlemcinin süreç ya da evre için bırakılmamış olabileceği anlamına gelebilir.
       </para></listitem></varlistentry></variablelist>
    </para><para>
Bu işlev bir GNU oluşumudur ve <filename>sched.h</filename> dosyasında bildirilmiştir.
    </para></funcdescr></funcsynopsis></para></sect1></chapter>
  <chapter id="glibc-Memory-Resources">
    <title>Bellek Özkaynakları</title>
    <titleabbrev>Bellekle ilgili özkaynakların sorgulanması</titleabbrev>
    <para>
Sistemdeki mevcut belleğin miktarı ve belleğin düzenlenmesi sıklıkla yazılımların yapabileceklerine ve çalışabilmelerine bağlı olarak belirlenir. <command>mmap</command> gibi işlevler açısından her bir bellek sayfasının boyutunun bilinmesi ve bir yazılımın ne kadar belleği arabellekler gibi seçimler için kullanabileceğinin bilinmesi gereklidir. Bu tür ayrıntılara dalmadan önce geleneksel Unix sistemlerindeki bellek altsisteminden biraz bahsetmek gerekir.
   </para>
    <sect1 id="glibc-Memory-Subsystem">
      <title>Bellek Altsistemi</title>
      <titleabbrev>Geleneksel Unix bellek işlemlerine bir bakış</titleabbrev>
      <para>
<indexterm scope="glibc-cp"><primary>adres alanı</primary></indexterm>
<indexterm scope="glibc-cp"><primary>bellek</primary><secondary>fiziksel</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>fiziksel adres</primary></indexterm>
Unix sistemleri genelde süreçlere sanal adres alanları sunarlar. Bunun anlamı, verinin saklandığı adres alanlarının aslında fiziksel bellek adresleri değil, bunları kapsayan ama bu adreslere doğrudan erişim sağlamayan bellek bölgelerinin adresleri olduğudur. Sanal adreslerin fiziksel adreslere dönüştürüldüğü ek bir dolaylı işlem katmanı vardır ve bu işlemler normalde işlemcinin donanımı tarafından yapılır.
    </para><para>
<indexterm scope="glibc-cp"><primary>bellek</primary><secondary>paylaşımlı</secondary></indexterm>
Bir sanal adres alanı kullanmanın çeşitli yararları vardır. En önemlisi süreç yalıtımıdır. Sistemde çalışmakta olan farklı süreçlerin birbirleriyle doğrudan etkileşmemeleri gerekir. Bir sürecin adres alanına başka hiçbir süreç yazamaz (Paylaşımlı bellek kullanımı hariç. Ancak bu da isteğe bağlıdır ve denetim altında yapılır).
    </para><para>
Sanal bellek kullanımının diğer bir yararı da süreçlerin adres alanının mevcut fiziksel bellekten daha büyük bir bellek alanı olarak görünmesidir. Fiziksel bellek dış saklama ortamları ile genişletilebilir ve o an kullanılmayan bellek bölgeleri bu ortamlara aktarılabilir. Adres dönüşümü bu bellek bölgelerine erişimi engeller ve hemen bu içeriği fiziksel belleğe geri yükleyerek kullanıma hazır duruma getirir.
Kullanılabilir fiziksel bellekle kullanılabilir sanal adres alanı arasındaki farkın bilindiği durumda bu işlem yazılımların belleği kullanabilmesi için gerekli hale gelir. Sistemde çalışmakta olan tüm süreçlerin çalışmalarını sürdürebilmeleri için fiziksel belleğin yetersiz kaldığı ve dış saklama ortamlarının hemen hemen dolduğu durumlarda bu iki ortam arsındaki takaslama işlemi küçük miktarlarda olmaya başlar ve bu sistemin belirgin biçimde yavaşlamasına sebep olur. Buna  <wordasword>atıştırma</wordasword> (thrashing) denir (argosu: çöplenme).
<indexterm scope="glibc-cp"><primary>bellek</primary><secondary>atıştırma</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>bellek</primary><secondary>bellek sayfası</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>sayfa</primary><secondary>bellek</secondary></indexterm>
    </para><para>
Sanal bellek hakkında söylenebilecek son şey, önceki paragrafta bahsedilen sanal belleğin takaslanma büyüklüğü ile ilgilidir. Bu takaslama işlemi bayt bayt yapılmaz. Yönetsel karar organı bunun olmasına izin vermez (işlemci donanımı naparsan yap deyip bırakılmaz). Bunun yerine birkaç bin baytlık <wordasword>sayfa</wordasword> olarak nitelenen belirli miktarlarla bu işlem yapılır. Her sayfanın genişliği ikinin üstel katları olarak bayt cinsinden belirlenir. Günümüzdeki en küçük sayfa genişliği 4096 bayt olup, 8192, 16384 ve 65536 baytlık sayfa genişlikleri de görülmektedir.
    </para></sect1>
    <sect1 id="glibc-Query-Memory-Parameters">
      <title>Bellek Parametrelerinin Sorgulanması</title>
      <titleabbrev>Bellek altsistemi hakkında nasıl bilgi edinilir?</titleabbrev>
      <para>
Sürecin sanal bellek sayfa genişliğini bilmesi bazı durumlarda zorunludur. Bazı yazılım arayüzleri (<command>mmap</command> gibi, bkz. <xref linkend="glibc-Memory-mapped-I-O"/>) kullanıcının sayfa genişliğine ayarlanmış bilgi vermesini gerektirir. <command>mmap</command>, sayfa genişliğinin katları olarak bir uzunluk argümanı gerektirir. Sayfa genişliğinin bilinmesinin faydalı olduğu diğer bir yer de bellek ayırmadır. Uygulama tarafından bölünerek kullanılmak üzere büyükçe bir tomar halinde bir ayırma yapılırsa, geniş blokların boyutlarının sayfa genişliğine ayarlanması yararlı olur. Çekirdek bellekle çalışırken sadece tamamı kullanılan bellek sayfalarını ayırmak zorunda olduğundan, ayrılmak istenen blok boyutunun sayfa genişliğinin katlarına yakın (daha büyük değil) olması çekirdeğin bellek ayırma ile ilgili olarak daha verimli çalışabilmesini sağlar. (Bu eniyilemeyi yapmak için bellek ayırıcının her blok için belleğin bir biti için bile nasıl davrandığı hakkında biraz birşeyler bilinmesi ve sayfa genişliğinin katlarını aşan bir toplam boyut talep edilmemesi gerekir.)
    </para><para>
Sayfa genişliği geleneksel olarak bir derleme zamanı sabitidir. Fakat son zamanlarda geliştirilen işlemcilerle bu durum değişmiştir. İşlemciler artık farklı sayfa genişliklerini desteklemekte ve aynı sistem üzerinde farklı süreçler arasında bunun değişiklik göstermesine bile olanak verebilmektedirler. Bu nedenle, çalışma anında sistem o anki sayfa genişliği hakkında sorgulanmalı ve sayfa genişliği ile ilgili hiçbir önkabul yapılmamalıdır (sayfa genişliğinin ikinin üstel katları olması gerekliliği hariç).
    </para><para>
<indexterm scope="glibc-vr"><primary sortas="SC_PAGESIZE">_SC_PAGESIZE</primary></indexterm>
Sayfa genişiğini sorgulamak için kullanılacak doğru arayüz <command>_SC_PAGESIZE</command> parametresi ile <command>sysconf</command>'tur (bkz. <xref linkend="glibc-Sysconf-Definition"/>). Ayrıca daha eski bir arayüz de vardır.
    </para><para>
<indexterm scope="glibc-fn"><primary>getpagesize</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-getpagesize">
<funcdef>int <command>getpagesize</command></funcdef>
<paramdef>(void)</paramdef>
</funcprototype><funcdescr><para>
<command>getpagesize</command> işlevi sürecin sayfa genişliği ile döner. Bu değer sürecin çalışması süresince sabittir ama aynı yazılımın farklı süreçlerinde farklı değerler olabilir.
    </para><para>
Bu işlev <filename>unistd.h</filename> dosyasında bildirilmiştir.
</para></funcdescr></funcsynopsis></para><para>
Sistemin fiziksel belleği hakkında System V'den türetilmiş sistemlerde geniş olarak kullanılan bir bilgi alma yöntemi vardır.
    </para><para>
<indexterm scope="glibc-vr"><primary sortas="SC_PHYS_PAGES">_SC_PHYS_PAGES</primary></indexterm>
<indexterm scope="glibc-cp"><primary>sysconf</primary></indexterm>
<screen>  sysconf (_SC_PHYS_PAGES)</screen></para><para>
çağrısı sistemin sahip olduğu belleğin fiziksel sayfalarının toplam sayısı ile döner. Bu, bu belleğin tümünün kullanılabilir olduğu anlamına gelmez. Bu bilgi,
    </para><para>
<indexterm scope="glibc-vr"><primary sortas="SC_AVPHYS_PAGES">_SC_AVPHYS_PAGES</primary></indexterm>
<indexterm scope="glibc-cp"><primary>sysconf</primary></indexterm>
<screen>  sysconf (_SC_AVPHYS_PAGES)</screen></para><para>
çağrısı ile edinilebilir. Bu iki değer uygulamaların eniyilenmesine yardımcı olur. <command>_SC_AVPHYS_PAGES</command> için döndürülen değer uygulamanın başka bir süreç tarafından engellenmeksizin kullanabileceği bellek miktarıdır (başka hiçbir sürecin kendi bellek kullanımını, diğerlerinin hilafına arttıramayacağını belirtir). <command>_SC_PHYS_PAGES</command> için dönen değer ise az ya da çok çalışma birliği için donanımsal bir sınırdır. Eğer tüm uygulamalar birlikte bundan fazlasını kullanmaya çalışırsa, sistemin bellek miktarı ile başı dertte demektir.
    </para><para>
GNU C kütüphanesi bu iki yönteme ek olarak bu bilgiyi almak için iki işlev daha içerir. Bu işlevler <filename>sys/sysinfo.h</filename> dosyasında bildirilmiştir. Yazılımcılar yukarıda açıklanan <command>sysconf</command> yöntemini tercih etmelidir.
    </para><para>
<indexterm scope="glibc-fn"><primary>get_phys_pages</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-get_phys_pages">
<funcdef>long int <command>get_phys_pages</command></funcdef>
<paramdef>(void)</paramdef>
</funcprototype><funcdescr><para>
<command>get_phys_pages</command> işlevi sistemin sahip olduğu fiziksel sayfaların sayısı ile döner. Belleğin toplam miktarını bulmak için bu değer sayfa genişliği ile çarpılır.
    </para><para>
Bu işlev bir GNU oluşumudur.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>get_avphys_pages</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-get_avphys_pages">
<funcdef>long int <command>get_avphys_pages</command></funcdef>
<paramdef>(void)</paramdef>
</funcprototype><funcdescr><para>
<command>get_phys_pages</command> işlevi sistemin sahip olduğu fiziksel sayfalardan kullanılabilir olanlarının sayısı ile döner. Belleğin kullanılabilir toplam miktarını bulmak için bu değer sayfa genişliği ile çarpılır.
    </para><para>
Bu işlev bir GNU oluşumudur.
  </para></funcdescr></funcsynopsis></para></sect1></chapter>
  <chapter id="glibc-Processor-Resources">
    <title>İşlemci Özkaynakları</title>
    <titleabbrev>İşlemcilerin hakkında bilinmesi gerekenler</titleabbrev>
    <para>
Evrelerin ve süreçlerin paylaşımlı bellekle kullanımı bir uygulamanın bir sistemin sağlayabildiği tüm işlem gücünün getirilerinden yararlanmasına imkan verir. Eğer görev paralelleştirilebiliyorsa, bir uygulama yazmanın en uygun yolu aynı anda çok sayıda işlemci varmış gibi çok sayıda sürecin çalışmasının mümkün olması ile ilgilidir. Sistemdeki mevcut işlemcilerin sayısını saptamak için şöyle bir çağrı yapabilirsiniz:
   </para><para>
<indexterm scope="glibc-vr"><primary sortas="SC_NPROCESSORS_CONF">_SC_NPROCESSORS_CONF</primary></indexterm>
<indexterm scope="glibc-cp"><primary>sysconf</primary></indexterm>
<screen>  sysconf (_SC_NPROCESSORS_CONF)</screen>
   </para><para>
İşletim sisteminin yapılandırıldığı işlemcilerin sayısı ile döner. Ancak işletim sisteminin bazı işlemcileri iptal etmesi mümkün olduğundan,
   </para><para>
<indexterm scope="glibc-vr"><primary sortas="SC_NPROCESSORS_ONLN">_SC_NPROCESSORS_ONLN</primary></indexterm>
<indexterm scope="glibc-cp"><primary>sysconf</primary></indexterm>
<screen>  sysconf (_SC_NPROCESSORS_ONLN)
</screen></para><para>
çağrısı ile o an kullanılabilecek işlemcilerin sayısını öğrenebilirsiniz.
   </para><para>
Bu ikisine ek olarak GNU C kütüphanesi bilgiyi doğrudan almayı mümkün kılan işlevler de içerir. Bu işlevler <filename>sys/sysinfo.h</filename> dosyasında bildirilmiştir.
   </para><para>
<indexterm scope="glibc-fn"><primary>get_nprocs_conf</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-get_nprocs_conf">
<funcdef>int <command>get_nprocs_conf</command></funcdef>
<paramdef>(void)</paramdef>
</funcprototype><funcdescr><para>
<command>get_nprocs_conf</command> işlevi işletim sisteminin yapılandırıldığı işlemcilerin sayısı ile döner.
   </para><para>
Bu işlev bir GNU oluşumudur.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>get_nprocs</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-get_nprocs">
<funcdef>int <command>get_nprocs</command></funcdef>
<paramdef>(void)</paramdef>
</funcprototype><funcdescr><para>
<command>get_nprocs</command> işlevi o an kullanılabilecek işlemcilerin sayısı ile döner.
   </para><para>
Bu işlev bir GNU oluşumudur.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-cp"><primary>yük ortalaması</primary></indexterm>
Daha fazla evre başlatmadan önce işlemcilerin tamamen kullanımda olup olmadığına bakılmalıdır. Unix sistemi <wordasword>yük ortalaması</wordasword> adı verilen bir hesaplama yapar. Bu aynı anda kaç sürecin çalışmakta olduğunu gösteren bir sayıdır. Bu sayı farklı sürelerde alınan bir ortalamadır (normalde 1, 5 ve 15 dakikalık).
   </para><para>
<indexterm scope="glibc-fn"><primary>getloadavg</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-getloadavg">
<funcdef>int <command>getloadavg</command></funcdef>
<paramdef>(double <varname>yükortalamaları</varname>[],
 int    <varname>elem_sayısı</varname>)</paramdef>
</funcprototype><funcdescr><para>
İşlev sistemin yük ortalamasını 1, 5 ve 15 dakikalık ortalamalar olarak döndürür. Değerler <varname>yükortalamaları</varname> dizisine yerleştirilir. Diziye kaç ortalama yerleştirileceği <varname>elem_sayısı</varname> argümanına konur, ancak bu değer üçten fazla olmaz. İşlevin normal dönüş değeri <varname>yükortalamaları</varname> dizisine yazılan değerlerin sayısıdır, -1 dönmüşse bir hata oluşmuş demektir.
   </para><para>
Bu işlev <filename>stdlib.h</filename> dosyasında bildirilmiştir.
   </para></funcdescr></funcsynopsis></para>
 </chapter>
</part>
