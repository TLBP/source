<?xml version="1.0" encoding="UTF-8"?>
<!-- ********************************************************************
        glibc/appa.xml,v2.36, GFDL,LGPL, NBB, 2023
     ******************************************************************** -->
<part xml:id="glibc-Language-Features" label="A" userlevel="longtoc">
 <title>Kütüphanedeki C Dili Oluşumları</title>
 <titleabbrev>Kütüphane tarafından sağlanan C dili oluşumları.</titleabbrev>
 <preliminary>
  <para>
   C kütüphanesi tarafından gerçekleştirilen bazı oluşumların aslında C dilinin kendisinde bulunması gerekir. Bu oluşumlar kütüphane kılavuzunun değil C Dili Kılavuzunun bir parçası olmalıydı, ancak henüz bir GNU C dil kılavuzu olmadığı için bu oluşumlar burada belgelenmiştir.
  </para>
 </preliminary>
 <chapter xml:id="glibc-Consistency-Checking">
  <title>Dahilî Tutarlılığın Doğrudan Denetlenmesi</title>
  <titleabbrev>Bazı "imkansız" şeyler oluştuğunda çıkmak için <code>assert</code> kullanımı</titleabbrev>
  <para>
   <indexterm linkend="glibc-cp"><primary>tutarlılık denetimi</primary></indexterm>
   <indexterm linkend="glibc-cp"><primary>imkansız olaylar</primary></indexterm>
   <indexterm linkend="glibc-cp"><primary>savlar</primary></indexterm>
   Bir yazılımı geliştirirken "imkansız" hatalara ve temel kabullerdeki çatışmalara karşı bazı stratejik yerlere denetimler yerleştirmek iyi olur. Bu çeşit denetimler örneğin, yazılımın farklı parçaları arasında, arayüzlerle hata ayıklama sorunlarını gidermeye yardımcı olur.
  </para>
  <para>
   <indexterm linkend="glibc-pg"><primary>assert.h</primary></indexterm>
   <code>assert</code> makrosu &assert.h; başlık dosyasında tanımlanmıştır ve yazılımda bir hata saptandığında bir ileti basarak yazılımın çıkması için kullanışlı bir yol sağlar.
  </para>
  <csynopsis>
   <indexterm xml:id="glibc-vr-NDEBUG" linkend="glibc-vr"><primary>NDEBUG</primary></indexterm>
   <csproto type="makro">
    <csname><function>NDEBUG</function></csname>
   </csproto>
   <header>&assert.h;</header>
   <para>
    Yazılımın artık hatalardan arındığı düşünüldüğünde, <function>assert</function> makrosu tarafından uygulanan hata denetimleri, <code>NDEBUG</code> makrosu tanımlandıktan sonra yazılım yeniden derlenerek iptal edilebilir. Yani, bu denetimleri iptal etmek için yazılımın kaynak kodunu değiştirmek gerekmez.
   </para>
  </csynopsis>
  <para>
   Ancak bu tutarlılık denetimlerinin iptal edilmesi, bu denetimler yazılımınızın  çalışmasını kayda değer oranda yavaşlatmadıkça yapılmasa iyi olur. Yazılımın çalışmasına çok etki etmedikçe daha fazla hata denetimi yapılması daha iyidir. Başlangıç seviyesinde bir kullanıcı bir yazılımın çökmesi sırasında hiçbir  uyarı görmezse  herşeyi yanlış yaptığı sanısına kapılabilir.
  </para>
  <csynopsis>
   <indexterm xml:id="glibc-fn-assert" linkend="glibc-fn"><primary>assert</primary></indexterm>
   <csproto type="makro">
    <csname><type>void</type><function>assert</function></csname>
    <csparam><type>int</type><parameter>expression</parameter></csparam>
   </csproto>
   <header>&assert.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&asunsafe; &heap; &corrupt;</concept>
    <concept>&acunsafe; &corrupt; &lock; &mem;</concept>
   </conceptlist>
   <para>
    Yazılımın o noktasında <parameter>expression</parameter> sıfırdan farklıysa yazılımcının kanaatini doğrular.
   </para>
   <para>
    <varname>NDEBUG</varname> tanımlı değilse, <code>assert</code>  <parameter>expression</parameter> ifadesinin değerini sınamaya tabi tutar. Sınama sonucu yanlışsa (sıfır), <code>assert</code> aşağıdakine benzer bir hata iletisini <link linkend="glibc-Standard-Streams">standart hataya</link>  (<varname>stderr</varname>) basarak <link linkend="glibc-Aborting-a-Program">yazılımı sonlandırır</link>:
   </para>
   <literallayout class="monospaced"><replaceable>dosya</replaceable>:<replaceable>satırno</replaceable>: <replaceable>işlev</replaceable>: `<parameter>expression</parameter>' savı başarısız oldu.
</literallayout>
   <para>
    Dosya ismi ve satır numarası <varname>__FILE__ </varname> ve  <varname>__LINE__ </varname> C önişlemci makrolarıyla saptanır ve <code>assert</code> çağrısının yapıldığı yeri belirtir. GNU C derleyicisi kullanılırken, işlevin yani <code>assert</code> çağrısının işlev ismi <varname>__PRETTY_FUNCTION__</varname> yerleşik değişkeninden alınır; daha eski derleyicilerde işlev ismi ve onu izleyen iki nokta üst üste yoktur.
   </para>
   <para>
    <varname>NDEBUG</varname> önişlemci makrosu &assert.h; dosyasının içerildiği satırdan önce tanımlanmışsa, <code>assert</code> makrosu mutlak olarak hiçbir şey yapmamak üzere tanımlanmış olur.
   </para>
   <warning>
    <para>
     <varname>NDEBUG</varname> etkili ise bağımsız değişken olarak verilen <parameter>expression</parameter> değerlendirilmez. Bu yüzden, yan etkileri olan ifadeler bağımsız değişken olarak kullanılmamalıdır. Örneğin <code>assert (++i &gt; 0);</code> gibi bir çağrı asla kullanılmamalıdır, çünkü <varname>NDEBUG</varname> tanımlıysa <code>i</code> hiçbir zaman artırılmayacaktır.
    </para>
   </warning>
  </csynopsis>
  <para>
   Kimi zaman bir işletim sistemi işlevinden dönen bir hatanın denetlenmesinin istenebileceği "imkansız" durumlar olabilir. Bu durumda sadece yazılımın nerede çöktüğü değil, neden çöktüğünün de bildirilmesi faydalıdır. <function>assert_perror</function> makrosu bunu kolayca yapar.
  </para>
  <csynopsis>
   <indexterm xml:id="glibc-fn-assert_perror" linkend="glibc-fn"><primary>assert_perror</primary></indexterm>
   <csproto type="makro">
    <csname><type>void</type><function>assert_perror</function></csname>
    <csparam><type>int</type><parameter>errnum</parameter></csparam>
   </csproto>
   <header>&assert.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&asunsafe; &heap; &corrupt;</concept>
    <concept>&acunsafe; &corrupt; &lock; &mem;</concept>
   </conceptlist>
   <para>
    <parameter>errnum</parameter> değerinin sıfır olduğunu doğrulaması dışında <function>assert</function> makrosuna benzer.
   </para>
   <para>
    <varname>NDEBUG</varname> tanımlı değilse, <code>assert_perror</code> makrosu <parameter>errnum</parameter> değerine bakar. Değer sıfırdan farklıysa, <code>assert_perror</code> aşağıdaki iletiye benzer bir hata iletisini standart hataya basarak yazılımı sonlandırır:
   </para>
   <literallayout class="monospaced"><replaceable>dosya</replaceable>:<replaceable>satırno</replaceable>: <replaceable>işlev</replaceable>: <replaceable>hata-iletisi</replaceable>
</literallayout>
   <para>
    Dosya ismi, satır numarası ve işlev ismi <function>assert</function> işlevindeki gibi elde edilir. <replaceable>hata-iletisi</replaceable> ise, <code>strerror (<parameter>errnum</parameter>)</code> işlevinin sonucudur. Bkz.  <xref linkend="glibc-Error-Messages"/>.
   </para>
   <para>
    <function>assert</function> makrosunda olduğu gibi, <varname>NDEBUG</varname> önişlemci makrosu &assert.h; dosyasının içerildiği satırdan önce tanımlanmışsa, <code>assert_perror</code> makrosu mutlak olarak hiçbir şey yapmamak üzere tanımlanmış olur. Bu durumda bağımsız değişken olarak verilen <parameter>errnum</parameter> değerlendirilmez. Yani, <parameter>errnum</parameter> bir yan etki barındırmamalıdır. En iyisi <parameter>errnum</parameter> değerinin basit bir değişken başvurusu olmasıdır; doğrudan <varname>errno</varname> aktarmak daha iyi olacaktır.
   </para>
   <para>
    Bu makro bir GNU oluşumudur.
   </para>
  </csynopsis>
  <note><title>Kullanım Bilgisi:</title>
   <para>
    <function>assert</function> oluşumu <emphasis>dahili tutarsızlığın saptanması</emphasis> için tasarlanmıştır. Yazılımın <emphasis>kullanıcı</emphasis> tarafından yanlış kullanımının ya da geçersiz girdilerinin bildirilmesi için kullanışlı değildir.
   </para>
  </note>
  <para>
   <function>assert</function> ve <function>assert_perror</function> tarafından basılan tanı iletilerinden elde edilen bilgiler yazılımcıya yöneliktir. Bir yazılım hatası ile ilgilidir. Kullanıcıya girdilerinin neden geçersiz olduğunu ya da neden bir komutun gerçekleştirilemediğini bildirmek için değildir. Yazılım, kullanıcının yaptığı bir hatadan dolayı <function>assert</function> makrosunun yaptığı şekilde (bir yazılım hatası vererek) sonlanmamalı, sıfırdan farklı bir çıkış durumu ile çıkmalıdır. Bkz. <xref linkend="glibc-Exit-Status"/>.
  </para>
  <para>
   Yazılımdaki bir yazılım hatasının sonucu <emphasis>olmayan</emphasis> sorunlarda hata iletilerinin basılması ile ilgili bilgiler <xref linkend="glibc-Error-Messages"/> bölümünde bulunabilir.
  </para>
 </chapter>
 <chapter xml:id="glibc-Variadic-Functions">
  <title>Değişkin İşlevler</title>
  <titleabbrev>İşlevlerin değişen sayıda bağımsız değişken ile tanımlanması</titleabbrev>
  <preliminary>
    <para>
    <indexterm linkend="glibc-cp"><primary>işlevler</primary><secondary>bağımsız değişkenler</secondary><tertiary>değişen sayıda</tertiary></indexterm>
    <indexterm linkend="glibc-cp"><primary>işlevler</primary><secondary>bağımsız değişkenler</secondary><tertiary>isteğe bağlı</tertiary></indexterm>
    <indexterm linkend="glibc-cp"><primary>işlevler</primary><secondary>değişkin</secondary></indexterm>
    <indexterm linkend="glibc-cp"><primary>değişkin işlev</primary></indexterm>
    &isoc;, değişen sayıda bağımsız değişken alabilecek bir işlevin bildirilebilmesi için bir  sözdizimi tanımlamıştır. (Bu tür işlevlere <wordasword>değişkin işlevler</wordasword> adı verilir.) Buna rağmen, dilin kendisi bu tür işlevlerin gerekli olmayan bağımsız değişkenlerine erişim için bir düzenek sağlamaz; bu nedenle, &stdarg.h; başlık  dosyasındaki makrolarla tanımlanmış olan sayısı değişen bağımsız değişkenler makroları kullanılacaktır.
   </para>
   <para>
    Bu bölümde değişkin işlevlerin nasıl bildirildikleri, nasıl yazıldıkları ve nasıl çağrıldıkları açıklanmıştır.
   </para>
   <note><title>Uyumluluk Bilgisi:</title>
    <para>
     Birçok eski C gerçeklemesi, &stdarg.h; kullanılarak değişken sayıda bağımsız değişken ile işlevleri tanımlama düzeneğine benzeyen ama uyumlu olmayan bir düzenek sağlar.
    </para>
   </note>
  </preliminary>
  <sect1 xml:id="glibc-Why-Variadic">
   <title>Değişkin İşlevler Neden Kullanılır</title>
   <titleabbrev>Değişen sayıda bağımsız değişken alan işlevleri oluşturmak için sebepler.</titleabbrev>
   <para>
    Sıradan C işlevleri sabit sayıda bağımsız değişken alır. Bir işlevi tanımlanırken her bağımsız değişken için veri türü  de belirtilir. Her işlev çağrısında istenen sayıda bağımsız değişken verirken bağımsız değişkenleri de gerekirse tür dönüşümü yapılarak istenen türde sağlanır. Bu noktada, örneğin, <function>foo</function> işlevi <code>int&nbsp;foo&nbsp;(int,&nbsp;char&nbsp;*);</code> ifadesi ile bildirilmişse, iki bağımsız değişken ile; bir sayı ve bir dizge göstericisi ile çağrılması gerekir.
   </para>
   <para>
    Fakat bazı işlevler sınırsız sayıda bağımsız değişkeni anlamlı kabul ederek işlemler uygulayabilir.
   </para>
   <para>
    Bazı durumlarda bir işlev çok sayıda değeri bir blok olarak işleyerek elde edebilir. Örnek olarak, bir işlev belirli sayıda değeri tutmak için <function>malloc</function> ile tek boyutlu bir dizi için bellek tahsis etmiş olsun. Dizinin uzunluğuna bağlı sayıda değer üzerinde işlem yapılabileceğinden değişen sayıda bağımsız değişkenli oluşumlar olmaksızın, her olası dizi uzunluğu için ayrı bir işlev tanımlamak zorunda kalınırdı.
   </para>
   <para>
    Başka bir işlev sınıfından değişken sayıda bağımsız değişkenli işleve örnek olarak, kütüphane işlevi <function>printf</function>  (Bkz. <xref linkend="glibc-Formatted-Output"/>) verilebilir. Bu işlev (değişken sayıda ve türdeki) bağımsız değişkeni bir biçem şablonu dizgesine uygun olarak ekrana çıktılar.
   </para>
   <para>
    Bunlar, bağımsız değişken sayısı çağrı sırasında belirlenen bir <firstterm>değişkin</firstterm> işlev tanımlamak için iyi sebeplerdir.
   </para>
   <para>
    <function>open</function> gibi bazı işlevler sabit sayıda bağımsız değişken almasına rağmen ara sıra son birkaçını yok sayar. &isoc;'ye kesin bağlılık durumunda bu işlevlerin değişkin olarak tanımlanması gerekir; uygulamada ise, GNU C derleyicisi ve diğer birçok C derleyicisi böyle bir işlevi sabit sayıda bağımsız değişken ile tanımlamayı ve sadece <emphasis>bildirim</emphasis> sırasında işlevi değişkin olarak bildirerek (ya da bağımsız değişkenlerinin tümünü bildirmeyerek) yapmayı tercih eder.
   </para>
  </sect1>
  <sect1 xml:id="glibc-How-Variadic">
  <title>Değişkin İşlevler Nasıl Tanımlanır ve Kullanılır</title>
  <titleabbrev>Değişkin işlevler nasıl tanımlanır ve çağrılır.</titleabbrev>
  <preliminary>
   <para>
    Bir değişkin işlev 3 adımda tanımlanıp kullanılır:
   </para>
   <variablelist>
    <varlistentry>
     <term>Tanım</term>
     <listitem>
      <para>
       Bir işlevin değişkin olarak tanımlanması, bağımsız değişken listesinde bir üçlü nokta (<command>…</command>) kullanarak ve değişken sayıda bağımsız değişkene erişmek için özel makrolar kullanılarak yapılır. Bkz. <xref linkend="glibc-Receiving-Arguments"/>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Bildirim</term>
     <listitem>
      <para>
       Bir işlevin değişkin olarak bildirilmesi, onu çağıran tüm dosyalarda bir üçlü nokta (<command>…</command>) içeren bir örneği kullanarak yapılır. Bkz. <xref linkend="glibc-Variadic-Prototypes"/>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Çağrı</term>
     <listitem>
      <para>
       İşlev çağrısı sabit bağımsız değişkenlere ek olarak değişken sayıdaki bağımsız değişken yazılarak yapılır. Bkz.  <xref linkend="glibc-Calling-Variadics"/>.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </preliminary>
  <sect2 xml:id="glibc-Variadic-Prototypes">
   <title>Değişen Sayıda Bağımsız Değişken için Sözdizimi</title>
   <titleabbrev>Bağımsız değişken sayısı değişen işlevlerin ilk örneği nasıl yazılır.</titleabbrev>
   <para>
    <indexterm linkend="glibc-cp"><primary>değişkin işlevler</primary><secondary>sözdizimi</secondary></indexterm>
    Değişken sayıda bağımsız değişken kabul eden bir işlev şimdi açıklanana benzer bir ilk örnek kullanılarak bildirilmelidir. Önce sabit bağımsız değişkenler yazılır, ardından da başka bağımsız değişkenler de olduğunu belirtmek üzere bir üçlü nokta (<command>…</command>) gelir. &isoc; sözdizimi üçlü noktadan önce en az bir sabit bağımsız değişken gerektirir. Örnek:
   </para>
   <example>
    <screen>int
func (const char *a, int b, …)
{
  …
}
</screen>
   </example>
   <para>
    Bu örnekte, <type>int</type> türünde bir dönüş değeri olan ve biri <type>const&nbsp;char&nbsp;*</type> türünde diğeri <type>int</type> türünde iki bağımsız değişken gerektiren <code>func</code> işlevi tanımlanmıştır. Ayrıca işlevin gerekli olan iki bağımsız değişkenden başka belirsiz sayıda isimsiz bağımsız değişkeni de vardır.
   </para>
   <note><title>Uyumluluk Bilgisi:</title>
    <para>
     Bazı C derleyicileri için son gerekli bağımsız değişkenin işlev tanımında <type>register</type> olarak bildirilmemesi gereklidir. Bundan başka, bu bağımsız değişkenin türü <firstterm>kendinden terfili</firstterm> de olmalıdır: Yani, ön tanımlı terfiler türünü değiştirmemelidir. Bu kurallar dizi ve işlev türleri ile <type>float</type>, <type>char</type> (signed ya da değil) ve <type>short&nbsp;int</type> (signed ya da değil) türlerini dışarda tutar. Bu aslında bir &isoc; gerekliliğidir.
    </para>
   </note>
  </sect2>
  <sect2 xml:id="glibc-Receiving-Arguments">
   <title>Bağımsız Değişken Değerlerinin Alınması</title>
   <titleabbrev>İsteğe bağlı bağımsız değişken değerlerine erişimde izlenecek adımlar.</titleabbrev>
   <para>
    <indexterm linkend="glibc-cp"><primary>değişkin işlevler</primary><secondary>bağımsız değişkenlere erişim</secondary></indexterm>
    <indexterm linkend="glibc-cp"><primary>işlevler</primary><secondary>bağımsız değişkenler</secondary><tertiary>değişkin işlevlerde</tertiary></indexterm>
    Gerekli olan bağımsız değişkenlerin isimleri vardır ve değerlerine bu isimler kullanılarak erişilir. Ama isteğe bağlı bağımsız değişkenlerin isimleri yoktur, çünkü onlar bir üçlü nokta ile ifade edilmiştir. O halde bu bağımsız değişkenlere nasıl erişilecek?
   </para>
   <para>
    <indexterm linkend="glibc-pg"><primary>stdarg.h</primary></indexterm>
    Onlara erişmenin tek yolu yazıldıkları sırayla erişmektir. Bunun için &stdarg.h; başlık dosyasındaki özel makroların aşağıdaki üç adımlık işlemlerle kullanılması gerekir:
   </para>
   <orderedlist>
    <listitem>
     <para>
      <function>va_start</function> kullanarak <type>va_list</type> türünde bir bağımsız değişken gösterici değişkeni ilklendirilir. Bağımsız değişken gösterici, ilklendirildiğinde ilk isteğe bağlı bağımsız değişkeni gösterecektir.
     </para>
    </listitem>
    <listitem>
     <para>
      İsteğe bağlı bağımsız değişkenlere <function>va_arg</function> işlevi çağrılarak erişilir. İlk <function>va_arg</function> çağrısı ilk isteğe bağlı bağımsız değişkene erişir, ikinci çağrı ile ikincisine, böyle gider.
     </para>
     <para>
      Bu çağrı işlemi, kalan isteğe bağlı bağımsız değişkenlerden yok sayılacaklara kadar sürdürülebilir. Bir işlevin bağımsız değişkenlerinden daha azına erişmek bir sorun çıkarmaz ama daha fazla sayıda bağımsız değişkene erişmeye çalışmak bozuk değerlerle sonuçlanır.
     </para>
    </listitem>
    <listitem>
     <para>
      Bağımsız değişken göstericiye ihtiyaç kalmadığında bunun <function>va_end</function> çağrısıyla belirtilmesi gerekir.
     </para>
     <para>
      (Uygulamada, birçok C derleyicisi <function>va_end</function> çağrısında hiçbir şey yapmaz. Bu GNU C derleyicisi için de geçerlidir. Ancak, yazılımın bir gün bu çağrıyı gerektiren bir derleyici ile derlenebileceği göz önüne alınarak yine de <function>va_end</function> çağrısı yapılması iyi olur.)
     </para>
    </listitem>
   </orderedlist>
   <para>
    <function>va_start</function>, <function>va_arg</function> ve <function>va_end</function> işlevlerinin tanımları <xref linkend="glibc-Argument-Macros"/> bölümünde bulunabilir.
   </para>
   <para>
    Birden üçe kadar adımlar isteğe bağlı bağımsız değişkenleri kabul eden işlevin içinde uygulanmalıdır. Buna rağmen <type>va_list</type> türündeki değişken, bir bağımsız değişken olarak başka bir işleve aktarılarak 2. adım ya da tamamı burada uygulanabilir.
   </para>
   <para>
    Bu üç adımlık işlem, tek bir işlev defalarca çağrılarak da uygulanabilir. İsteğe bağlı bağımsız değişkenler yok sayılmak istendiğinde ise bu adımlar sıfır kere uygulanabilir.
   </para>
   <para>
    Gerekirse, birden fazla bağımsız değişken gösterici değişkeni olabilir ve bu değişkenlerin her biri gerektiği zaman <function>va_start</function> çağrılarıyla ayrı ayrı ilklendirilebilir. Her bağımsız değişken göstericisi ile gerektiği kadar isteğe bağlı bağımsız değişken alınabilir. Her bağımsız değişken gösterici değişkeni daima aynı bağımsız değişken kümesine ama kendi alanında sahip olacaktır.
   </para>
   <note><title>Taşınabilirlik Bilgisi:</title>
    <para>
     Bazı derleyicilerle, bir bağımsız değişken gösterici değerini bir alt işleve aktardıktan sonra, alt işlev döndüğünde aynı bağımsız değişken gösterici değerinin kullanımda tutulması gerekir. Tam taşınabilirlik için,   <function>va_end</function>'e aktarılmalıdır. Bu aslında bir &isoc; gerekliliği olmakla birlikte birçok ANSI C derleyicisi ile de sorunsuz çalışır.
    </para>
   </note>
  </sect2>
  <sect2 xml:id="glibc-How-Many-Arguments">
   <title>Aktarılan Bağımsız Değişkenlerin Sayısı</title>
   <titleabbrev>Daha fazla bağımsız değişken var mı diye nasıl bakmalı.</titleabbrev>
   <para>
    <indexterm linkend="glibc-cp"><primary>değişkin işlevler</primary><secondary>bağımsız değişkenlere erişim</secondary><tertiary>aktarılanların sayısı</tertiary></indexterm>
    <indexterm linkend="glibc-cp"><primary>işlevler</primary><secondary>bağımsız değişkenler</secondary><tertiary>aktarılanların sayısı</tertiary></indexterm>
    Bir işleve aktarılan isteğe bağlı bağımsız değişkenlerin sayısını ve türünü saptamak için genel bir yol yoktur. Yani işlev tasarlanırken, genellikle çağrıcı tarafından kullanılmak üzere bağımsız değişkenlerin sayısının ve türünün belirtileceği bir yol da tasarlanmalı ve her değişkin işlev için bir çağrı yöntemi tespit edilerek, çağrılar buna uygun yazılmalıdır.
   </para>
   <para>
    Çağrı yöntemlerinden biri, isteğe bağlı bağımsız değişkenlerin sayısını sabit bağımsız değişkenlerden birinde belirtmektir. Bu yöntem sadece tüm isteğe bağlı bağımsız değişkenler aynı türde ise çalışır.
   </para>
   <para>
    Bir diğer çağrı yöntemi ise, sabit bağımsız değişkenlerden birinin bir isteğe bağlı bağımsız değişkenin sağlayabileceği her olası amaç için bir bit olmak üzere bir bit maskesi içermesidir. Bu bitleri önceden tanımlanmış bir sırayla sınayarak; eğer bit bir ise sonraki bağımsız değişkenin değeri alınır, değilse bir ön tanımlı değer kullanılır.
   </para>
   <para>
    Bir sabit bağımsız değişken hem bağımsız değişken sayısını hem de türünü belirten bir kalıp olarak kullanılabilir. <function>printf</function> işlevinin biçem dizgesi bağımsız değişkeni buna bir örnektir (Bkz. <xref linkend="glibc-Formatted-Output-Functions"/>).
   </para>
   <para>
    Diğer bir olasılık da, son isteğe bağlı bağımsız değişken olarak bir "son belirten" değer aktarmaktır. Örneğin isteğe bağlı bağımsız değişkenleri göstericilerden oluşan bir işleve, sonuncu bağımsız değişken olarak bir boş gösterici verilebilir. Örneğin, <function>execl</function> işlevi bu yöntemi kullanır. Bkz. <xref linkend="glibc-Executing-a-File"/>.
   </para>
  </sect2>
  <sect2 xml:id="glibc-Calling-Variadics">
   <title>Değişkin İşlevlerin Çağrılması</title>
   <titleabbrev>Bağımsız değişken sayısı değişen işlevlerin çağrıları hakkında bilinmesi gerekenler.</titleabbrev>
   <para>
    <indexterm linkend="glibc-cp"><primary>değişkin işlevler</primary><secondary>çağrılması</secondary></indexterm>
    <indexterm linkend="glibc-cp"><primary>değişkin işlevler</primary><secondary>bildirim</secondary></indexterm>
    Bir değişkin işlev çağrısına özel hiçbir şey yoktur. Yaylı ayraçlar içine önce gerekli sonra da isteğe bağlı bağımsız değişkenler virgüllerle ayrılarak yazılır. Ama önce işlevin bildirilmesi gerekir, böylece bağımsız değişken değerlerinin nasıl dönüştürüleceği bilinir.
   </para>
   <para>
    Kural olarak, değişkin olarak <emphasis>tanımlanan işlevler</emphasis> çağrılmadan önce bir <link linkend="glibc-Variadic-Prototypes">işlev örneği</link> ile  değişkin olarak <emphasis>bildirilmelidir</emphasis>. Bazı C derleyicileri, işlevin aldığı sabit ve değişken sayıdaki bağımsız değişkene bağlı olarak bir işleve aktarılacak aynı bağımsız değişken değerleri kümesi için farklı çağrı yöntemleri kullandığı için bu böyledir.
   </para>
   <para>
    Uygulamada, GNU C derleyicisi bağımsız değişkenlerin gerekli mi, isteğe bağlı mı olduğuna bakmaksızın bir verilmiş bağımsız değişken türleri kümesini hep aynı yolla aktarır. Yani bağımsız değişken türleri kendinden terfili olduğu sürece bunların bildirilmesi rahatça ihmal edilebilir. Genellikle, değişkin işlevlerin bağımsız değişken türlerini ve hatta tüm işlevleri bildirmek iyi bir fikirdir. Ancak çok kullanışlı birkaç işlev vardır ki değişkin olarak bildirilmez; örneğin, <function>open</function> ve <function>printf</function>.
   </para>
   <para>
    <indexterm linkend="glibc-cp"><primary>ön tanımlı bağımsız değişken terfileri</primary></indexterm>
    <indexterm linkend="glibc-cp"><primary>işlevler</primary><secondary>bağımsız değişken terfisi</secondary></indexterm>
    İşlev ilk örneğinde isteğe bağlı bağımsız değişkenlerin türleri belirtilmediğinden, bir değişkin işlev çağrısında isteğe bağlı bağımsız değişken değerleri üzerinde <firstterm>ön tanımlı bağımsız değişken terfileri</firstterm> uygulanır. Yani, nesne türleri <type>char</type> veya <type>short&nbsp;int</type>  (signed ya da değil) ise ya <type>int</type> ya da  <type>unsigned&nbsp;int</type> türüne, nesne türü <type>float</type>  ise <type>double</type> türüne terfi ettirilir. Böylece örneğin, çağrı sırasına <type>char</type> türünde belirtilen bir bağımsız değişken, <type>int</type> türüne terfi ettirilerek, işlev bağımsız değişkene <code>va_arg (<parameter>ap</parameter>, int)</code> ile erişebilir.
   </para>
   <para>
    Gerekli bağımsız değişkenlerin dönüşümleri ise işlev ilk örneğinde genel bir yolla elde edilir: bağımsız değişken ifadesi, o türden bir değişkene atanıyormuş gibi, bildirilen bağımsız değişken türüne dönüştürülür.
   </para>
   </sect2>
   <sect2 xml:id="glibc-Argument-Macros">
    <title>Bağımsız Değişkene Erişim Makroları</title>
    <titleabbrev>İsteğe bağlı bağımsız değişkenlere erişmek için kullanılan makroların ayrıntılı belirtimi</titleabbrev>
    <para>
     Burada isteğe bağlı bağımsız değişkenlere erişmek için kullanılan makrolar açıklanmıştır. Bu makrolar &stdarg.h; başlık dosyasında bildirilmiştir.
     <indexterm linkend="glibc-pg"><primary>stdarg.h</primary></indexterm>
    </para>
    <csynopsis>
     <indexterm linkend="glibc-tp" xml:id="glibc-tp-va_list"><primary>va_list</primary></indexterm>
     <indexterm xml:id="glibc-cp-va_list" linkend="glibc-cp"><primary>değişkin işlevler</primary><secondary>veri türü</secondary></indexterm>
     <csproto type="veri türü">
      <csname><function>va_list</function></csname>
     </csproto>
     <header>&stdarg.h;</header>
     <para>
      <code>va_list</code> türü bağımsız değişken gösterici değişkeni için kullanılır.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-fn" xml:id="glibc-fn-va_start"><primary>va_start</primary></indexterm>
     <indexterm xml:id="glibc-cp-va_start" linkend="glibc-cp"><primary>değişkin işlevler</primary><secondary>bağımsız değişkenlerin ilklendirilmesi</secondary></indexterm>
     <csproto type="makro">
      <csname><type>void</type><function>va_start</function></csname>
      <csparam><type>va_list</type><parameter>ap</parameter></csparam>
      <csparam><parameter>last-required</parameter></csparam>
     </csproto>
     <header>&stdarg.h;</header>
     <conceptlist>
      <concept>&mtsafe;</concept>
      <concept>&assafe;</concept>
      <concept>&acsafe;</concept>
     </conceptlist>
     <para>
      Bu makro, kullanıldığı işlevin ilk isteğe bağlı bağımsız değişkenini gösterecek olan <parameter>ap</parameter> bağımsız değişken gösterici değişkenini ilklendirir. <parameter>last-required</parameter> işlevdeki gerekli son bağımsız değişken olmalıdır.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-fn" xml:id="glibc-fn-va_arg"><primary>va_arg</primary></indexterm>
     <indexterm xml:id="glibc-cp-va_arg" linkend="glibc-cp"><primary>değişkin işlevler</primary><secondary>bağımsız değişkenlerin alınması</secondary></indexterm>
     <csproto type="makro">
      <csname><type>type</type><function>va_arg</function></csname>
      <csparam><type>va_list</type><parameter>ap</parameter></csparam>
      <csparam><parameter>type</parameter></csparam>
     </csproto>
     <header>&stdarg.h;</header>
     <conceptlist>
      <concept>&mtsafe; &race;<code linkend="glibc-safety-identifier">:ap</code></concept>
      <concept>&assafe;</concept>
      <concept>&acunsafe; &corrupt;</concept>
     </conceptlist>
     <para>
      <code>va_arg</code> makrosu sonraki isteğe bağlı bağımsız değişkenin değeri ile döner ve <parameter>last-required</parameter> değişkeninin değerini sonraki bağımsız değişkeni gösterecek şekilde değiştirir. Böylece her <code>va_arg</code> kullanımında sırayla isteğe bağlı bağımsız değişkenlerden birinin değeri alınır.
     </para>
     <para>
      <code>va_arg</code> tarafından döndürülen değerin türü çağrı sırasında <parameter>type</parameter> ile belirtilir. <parameter>type</parameter> bağımsız değişkeninin türü ile eşleşen tür kendinden terfili türlerden biri olmalıdır (<type>char</type>, <type>short&nbsp;int</type> veya <type>float</type> değil).
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-fn" xml:id="glibc-fn-va_end"><primary>va_end</primary></indexterm>
     <indexterm xml:id="glibc-cp-va_end" linkend="glibc-cp"><primary>değişkin işlevler</primary><secondary>bağımsız değişkenlerin sonuncusu</secondary></indexterm>
     <csproto type="makro">
      <csname><type>void</type><function>va_end</function></csname>
      <csparam><type>va_list</type><parameter>ap</parameter></csparam>
     </csproto>
     <header>&stdarg.h;</header>
     <conceptlist>
      <concept>&mtsafe;</concept>
      <concept>&assafe;</concept>
      <concept>&acsafe;</concept>
     </conceptlist>
     <para>
      Bu makro <parameter>ap</parameter> kullanımını sonlandırır. Bir <code>va_end</code> çağrısından sonraki <function>va_arg</function> çağrıları bu <parameter>ap</parameter> ile çalışamaz. Aynı <parameter>ap</parameter> bağımsız değişkeni için bir <function>va_start</function> çağrısı yapmadan önce bir <code>va_end</code> çağrısı yapılmalıdır.
     </para>
     <para>
      &glibc;nde, <code>va_end</code> hiçbir şey yapmaz ve taşınabilirlik dışında kulanımı gerekmez.
     </para>
    </csynopsis>
    <para>
     Kimi zaman bağımsız değişken listesinin defalarca çözümlenmesi veya bağımsız değişkenlerden birinin listedeki konumunun hatırlanması gerekir. Bu durumda, o anki bağımsız değişken değerinin bir kopyasını yapılır. Ancak <type>va_list</type> şeffaf bir tür değildir ve <type>va_list</type> türünden bir değişkenin değeri başka bir değişkene atanamaz.
    </para>
    <csynopsis>
     <indexterm linkend="glibc-fn" xml:id="glibc-fn-va_copy"><primary>va_copy</primary></indexterm>
     <indexterm linkend="glibc-fn" xml:id="glibc-fn-va_copy_"><primary sortas="va_copy_">__va_copy</primary></indexterm>
     <indexterm xml:id="glibc-cp-va_copy" linkend="glibc-cp"><primary>değişkin işlevler</primary><secondary>bağımsız değişkenin kopyalanması</secondary></indexterm>
     <csproto type="makro">
      <csname><type>void</type><function>va_copy</function></csname>
      <csparam><type>va_list</type><parameter>dest</parameter></csparam>
      <csparam><type>va_list</type><parameter>src</parameter></csparam>
     </csproto>
     <csproto type="makro">
      <csname><type>void</type><function>__va_copy</function></csname>
      <csparam><type>va_list</type><parameter>dest</parameter></csparam>
      <csparam><type>va_list</type><parameter>src</parameter></csparam>
     </csproto>
     <header>&stdarg.h;</header>
     <conceptlist>
      <concept>&mtsafe;</concept>
      <concept>&assafe;</concept>
      <concept>&acsafe;</concept>
     </conceptlist>
     <para>
      <code>va_copy</code> makrosu, <type>va_list</type> türünden nesnelerin bir bütünleyen tür olmasa bile kopyalanmasını mümkün kılar. <parameter>dest</parameter> bağımsız değişken göstericisi, <parameter>src</parameter> göstericisi ile aynı bağımsız değişkeni göstermek üzere ilklendirilir.
     </para>
     <para>
      <code>va_copy</code> &isoc;99'da eklenmiştir. &isoc;90'a ('gcc -std=c90') sıkı uyumluluk durumunda kullanılamaz. GCC, herhangi bir standart kipinde bir genişletme olarak <code>__va_copy</code> sağlar; GCC 3.0'dan önce, bu işlevsellik için tek makroydu.
     </para>
     <para>
      Bu makrolar derleyici tarafından sağlandığından artık &glibc; tarafından sağlanmamaktadır.
     </para>
    </csynopsis>
    <para>
     <function>__va_copy</function> makrosu kullanılmak istenirse, bu makronun kullanılabilir olmayabileceği durumlara karşı hazırlıklı olunmalıdır. C99 öncesi taşınabilirlik konusunda endişe duyuluyorsa, basit atamanın geçersiz olduğu mimarilerde <function>__va_copy</function> makrosunun bulunmakta olduğu umularak yazılımda bu makronun daima şöyle yazılması gerekir:
    </para>
    <example>
     <screen>{
  va_list ap, save;
  …
#ifdef va_copy
  va_copy (save, ap);
#else
  save = ap;
#endif
  …
}
</screen>
    </example>
   </sect2>
  </sect1>
  <sect1 xml:id="glibc-Variadic-Example">
   <title>Değişkin İşlev Örneği</title>
   <titleabbrev>Eksiksiz bir örnek.</titleabbrev>
   <para>
    Burada değişken sayıda bağımsız değişken kabul eden bir işlevle ilgili tam bir örneğe yer verilmiştir. İşlevin ilk bağımsız değişkeni diğer bağımsız değişkenlerin sayısını içermektedir. İşlev anlamsız olsa da değişken bağımsız değişken oluşumunun kullanımı hakkında fikir vermek için yeterlidir.
   </para>
   <example>
    <screen>#include &lt;stdarg.h&gt;
#include &lt;stdio.h&gt;

int
add_em_up (int count,...)
{
  va_list ap;
  int i, sum;

  va_start (ap, count);         /* <replaceable>Bağımsız değişken listesini ilklendir.</replaceable> */

  sum = 0;
  for (i = 0; i &lt; count; i++)
    sum += va_arg (ap, int);    /* <replaceable>Sonraki bağımsız değişkenin değerini al.</replaceable> */

  va_end (ap);                  /* <replaceable>Temizlik.</replaceable> */
  return sum;
}

int
main (void)
{
  /* <replaceable>16 basar.</replaceable> */
  printf ("%d\n", add_em_up (3, 5, 5, 6));

  /* <replaceable>55 basar.</replaceable> */
  printf ("%d\n", add_em_up (10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10));

  return 0;
}
</screen>
   </example>
  </sect1>
 </chapter>

 <chapter xml:id="glibc-Null-Pointer-Constant">
  <title>Boş Gösterici Sabiti</title>
  <titleabbrev><code>NULL</code> makrosu.</titleabbrev>
  <para>
   <indexterm linkend="glibc-cp"><primary>boş gösterici sabiti (<literal>NULL</literal> makrosu)</primary></indexterm>
   Boş gösterici sabiti herhangi bir gerçek nesneyi göstermemeyi garanti eder. <type>void&nbsp;*</type> türünde olduğundan herhangi bir gösterici değişkenine atanabilir. Bir boş gösterici sabitini yazmak için tercih edilen yol <varname>NULL</varname> ile yazmaktır.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-vr" xml:id="glibc-vr-NULL"><primary>NULL</primary></indexterm>
   <csproto type="sabit">
    <csname><ptr>void</ptr><function>NULL</function></csname>
   </csproto>
   <header>&stddef.h;</header>
   <para>
    Boş gösterici sabitidir.
   </para>
  </csynopsis>
  <para>
   Ayrıca, boş gösterici sabiti olarak <code>0</code> veya <code>(void&nbsp;*)0</code> kullanılabilir, ancak <varname>NULL</varname> kullanımı daha temizdir çünkü sabitin amacını daha belirgin yapar.
  </para>
  <para>
   Boş gösterici sabiti işlev bağımsız değişkeni olarak kullanılırsa, tam taşınabilirlik açısından işlev için bir ilk örnek olduğundan emin olunmalıdır. Aksi takdirde, hedef makine iki farklı gösterici tanımına sahipse derleyici bu bağımsız değişken için hangi tanımı kullanacağını bilemeyecektir. Bu sorundan kaçınmak için açıkça bir tür dönüşümü ile sabit, doğru gösterici türüne atanmalıdır. Fakat bunu yapmak yerine çağrılan işlev için bir ilk örnek eklenmesi önerilir.
  </para>
 </chapter>
 <chapter xml:id="glibc-Important-Data-Types">
  <title>Önemli Veri Türleri</title>
  <titleabbrev>Nesne boyutları için veri türleri.</titleabbrev>
  <para>
   <indexterm linkend="glibc-pg"><primary>stddef.h</primary></indexterm>
   İki gösterici ile yapılan çıkartma işleminin sonucu C'de daima bir tamsayıdır, ancak doğru veri türü C derleyicisinden C derleyicisine değişir. Benzer şekilde, <function>sizeof</function>'un sonucunun veri türü de derleyiciler arasında değişiklik gösterir. &isoc; bu iki tür için standart isimler tanımlar, böylece bunlar kullanılarak taşınabilirlik sorunları çözülür. Bunlar &stddef.h; başlık dosyasında tanımlanmıştır.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-tp" xml:id="glibc-tp-ptrdiff_t"><primary>ptrdiff_t</primary></indexterm>
   <csproto type="veri türü">
    <csname><function>ptrdiff_t</function></csname>
   </csproto>
   <header>&stddef.h;</header>
   <para>
    Bu göstericiler arasındaki çıkartma işleminin sonucunun işaretli tamsayı türüdür. Örneğin, <code>char *p1, *p2;</code> bildirimiyle <code>p2 - p1</code> ifadesi <code>ptrdiff_t</code> türündedir. Bu muhtemelen standart işaretli tamsayı türlerinden biri (<type>short&nbsp;int</type>,  <type>int</type> veya <type>long&nbsp;int</type>) olacaktır, ancak sadece bu amaca yönelik olarak bir standart dışı tür de mevcut olabilir.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-tp" xml:id="glibc-tp-size_t"><primary>size_t</primary></indexterm>
   <csproto type="veri türü">
    <csname><function>size_t</function></csname>
   </csproto>
   <header>&stddef.h;</header>
   <para>
    Bu işaretsiz tamsayı türüdür ve nesnelerin boyutları için kullanılır. <operator>sizeof</operator> işlecinin sonucu bu türdendir ve <function>malloc</function>, <function>memcpy</function> gibi işlevler bağımsız değişkenlerinde nesne boyutlarını bu türde kabul eder. &glibc; kullanılan sistemlerde <code>size_t</code> ya <type>unsigned&nbsp;int</type> ya da <type>unsigned&nbsp;longt&nbsp;int</type> türüne eşdeğerdir.
   </para>
   <note><title>Kullanım Bilgisi:</title>
    <para>
     <code>size_t</code>, bir nesnenin boyutunu tutan herhangi bir değişken ya da bağımsız değişken bildiriminde önerilen yoldur.
    </para>
   </note>
  </csynopsis>
  <note><title>Uyumluluk Bilgisi:</title>
   <para>
    &isoc;'den önceki C gerçeklenimleri genellikle  nesne boyutları için <type>unsigned&nbsp;int</type> ve gösterici çıkartma ifadeleri için <type>int</type> türünü kullanmış, <type>size_t</type> ya da <type>ptrdiff_t</type> türünü tanımlamak gereği duymamıştı. Unix sistemleri <type>size_t</type> türünü &sys-types.h; dosyasında tanımladı ama bu tanım işaretli bir türdü.
   </para>
  </note>
 </chapter>

 <chapter xml:id="glibc-Data-Type-Measurements">
  <title>Veri Türü Ölçüleri</title>
  <titleabbrev>Veri türü bağımsız değişkenlerinin gösterimleri.</titleabbrev>
  <preliminary>
   <para>
    Çoğu zaman, yazılımlarda her nesne için uygun bir C veri türü seçilir ve nasıl gösterildiği veya kaç bit kullandığıyla ilgilenilmez. Böyle bir bilgiye ihtiyaç duyulursa C dilinin kendisi bu bilgiyi sağlamaz. &limits.h; ve &float.h; başlık dosyaları bu bilgiyi tüm ayrıntıları ile veren makrolar içerir.
   </para>
  </preliminary>
  <sect1 xml:id="glibc-Width-of-Type">
   <title>Tamsayı Veri Türünün Genişliğinin Hesaplanması</title>
   <titleabbrev>Bir tamsayı türü kaç bitle tutulur?</titleabbrev>
   <para>
    <indexterm linkend="glibc-cp"><primary>tamsayı</primary><secondary>türün genişliği</secondary></indexterm>
    <indexterm linkend="glibc-cp"><primary>veri türü ölçüleri</primary><secondary>tamsayılar</secondary></indexterm>
    TS 18661-1:2014, tamsayı türlerinin (değer sayısı ve işaret bitleri) genişliği için makrolar tanımlar. Bu makroların bir yararı, <code>#if</code> önişlemci yönergelerinde <operator>sizeof</operator> kullanılamazken bunların kullanılabilmesidir. Aşağıdaki makrolar, &limits.h; başlık dosyasında tanımlanmıştır.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-CHAR_WIDTH"><primary>CHAR_WIDTH</primary></indexterm>
    <csproto type="makro">
     <csname><function>CHAR_WIDTH</function></csname>
    </csproto>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-SCHAR_WIDTH"><primary>SCHAR_WIDTH</primary></indexterm>
    <csproto type="makro">
     <csname><function>SCHAR_WIDTH</function></csname>
    </csproto>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-UCHAR_WIDTH"><primary>UCHAR_WIDTH</primary></indexterm>
    <csproto type="makro">
     <csname><function>UCHAR_WIDTH</function></csname>
    </csproto>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-SHRT_WIDTH"><primary>SHRT_WIDTH</primary></indexterm>
    <csproto type="makro">
     <csname><function>SHRT_WIDTH</function></csname>
    </csproto>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-USHRT_WIDTH"><primary>USHRT_WIDTH</primary></indexterm>
    <csproto type="makro">
     <csname><function>USHRT_WIDTH</function></csname>
    </csproto>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-INT_WIDTH"><primary>INT_WIDTH</primary></indexterm>
    <csproto type="makro">
     <csname><function>INT_WIDTH</function></csname>
    </csproto>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-UINT_WIDTH"><primary>UINT_WIDTH</primary></indexterm>
    <csproto type="makro">
     <csname><function>UINT_WIDTH</function></csname>
    </csproto>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-LONG_WIDTH"><primary>LONG_WIDTH</primary></indexterm>
    <csproto type="makro">
     <csname><function>LONG_WIDTH</function></csname>
    </csproto>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-ULONG_WIDTH"><primary>ULONG_WIDTH</primary></indexterm>
    <csproto type="makro">
     <csname><function>ULONG_WIDTH</function></csname>
    </csproto>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-LLONG_WIDTH"><primary>LLONG_WIDTH</primary></indexterm>
    <csproto type="makro">
     <csname><function>LLONG_WIDTH</function></csname>
    </csproto>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-ULLONG_WIDTH"><primary>ULLONG_WIDTH</primary></indexterm>
    <csproto type="makro">
     <csname><function>ULLONG_WIDTH</function></csname>
    </csproto>
    <header>&limits.h;</header>
    <para>
     Bunlar sırayla <type>char</type>, <type>signed char</type>, <type>unsigned char</type>, <type>short int</type>, <type>unsigned short int</type>, <type>int</type>, <type>unsigned int</type>, <type>long int</type>, <type>unsigned long int</type>, <type>long long int</type> ve <type>unsigned long long int</type> veri türlerinin genişlikleridir.
    </para>
   </csynopsis>
   <para>
    Veri türleri ile ilgili diğer makrolar &stdint.h; başlık dosyasında tanımlanmıştır. Genişliğe göre belirtilen türlerden başka (bkz. <xref linkend="glibc-Integers"/>), aşağıdakiler de tanımlanmıştır:
   </para>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-INTPTR_WIDTH"><primary>INTPTR_WIDTH</primary></indexterm>
    <csproto type="makro">
     <csname><function>INTPTR_WIDTH</function></csname>
    </csproto>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-UINTPTR_WIDTH"><primary>UINTPTR_WIDTH</primary></indexterm>
    <csproto type="makro">
     <csname><function>UINTPTR_WIDTH</function></csname>
    </csproto>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-PTRDIFF_WIDTH"><primary>PTRDIFF_WIDTH</primary></indexterm>
    <csproto type="makro">
     <csname><function>PTRDIFF_WIDTH</function></csname>
    </csproto>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-SIG_ATOMIC_WIDTH"><primary>SIG_ATOMIC_WIDTH</primary></indexterm>
    <csproto type="makro">
     <csname><function>SIG_ATOMIC_WIDTH</function></csname>
    </csproto>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-SIZE_WIDTH"><primary>SIZE_WIDTH</primary></indexterm>
    <csproto type="makro">
     <csname><function>SIZE_WIDTH</function></csname>
    </csproto>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-WCHAR_WIDTH"><primary>WCHAR_WIDTH</primary></indexterm>
    <csproto type="makro">
     <csname><function>WCHAR_WIDTH</function></csname>
    </csproto>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-WINT_WIDTH"><primary>WINT_WIDTH</primary></indexterm>
    <csproto type="makro">
     <csname><function>WINT_WIDTH</function></csname>
    </csproto>
    <header>&stdint.h;</header>
    <para>
     Bunlar sırasıyla <type>intptr_t</type>, <type>uintptr_t</type>, <type>ptrdiff_t</type>, <type>sig_atomic_t</type>, <type>size_t</type>, <type>wchar_t</type> ve <type>wint_t</type> türlerinin genişlikleridir.
    </para>
   </csynopsis>
   <para>
    Çok bilinen sebeplerle bir yazılım bir tamsayı türünde kaç bit bulunduğunu bilmeye ihtiyaç duyabilir. Örneğin, <type>long int</type> türünde bir dizi bir bit vektörü olarak kullanılıyorsa, bitlere <replaceable>n</replaceable> indisi ile aşağıdaki gibi erişilebilir:
   </para>
   <literallayout class="monospaced">vector[<replaceable>n</replaceable> / ULONG_WIDTH] &amp; (1UL &lt;&lt; (<replaceable>n</replaceable> % ULONG_WIDTH))
</literallayout>
   <para>
    <varname>ULONG_WIDTH</varname>, C dilinin bir parçası olmadan önce, bir tamsayı veri türündeki bit sayısını hesaplamak için <varname>CHAR_BIT</varname> kullanılıyordu.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-CHAR_BIT"><primary>CHAR_BIT</primary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>CHAR_BIT</function></csname>
    </csproto>
    <header>&stdint.h;</header>
    <para>
     <type>char</type> türünün bit sayısıdır.  POSIX.1-2001 bunun 8 bit olmasını gerektirir.
    </para>
   </csynopsis>
   <para>
    Herhangi bir veri <replaceable>tür</replaceable>ünün bit sayısı şöyle hesaplanır:
   </para>
   <literallayout class="monospaced">sizeof (<replaceable>tür</replaceable>) * CHAR_BIT
</literallayout>
   <para>
    Bu ifade, dolgu bitlerinin yanı sıra değer ve işaret bitlerini içerir. &glibc; tarafından desteklenen tüm sistemlerde, <type>_Bool</type> dışındaki standart tamsayı türlerinde dolgu biti yoktur.
   </para>
   <note><title>Taşınabilirlik Bilgisi:</title>
    <para>
     Kullanılabilir bitlerin sayısı taşınabilir bir şekilde kolayca hesaplanamaz.
    </para>
   </note>
  </sect1>
  <sect1 xml:id="glibc-Range-of-Type">
   <title>Bir Tamsayı Türün Aralığı</title>
   <titleabbrev>Bir tamsayı türün tutabileceği en küçük ve en büyük değer nedir?</titleabbrev>
   <para>
    <indexterm linkend="glibc-cp"><primary>tamsayı</primary><secondary>tür aralığı</secondary></indexterm>
    <indexterm linkend="glibc-cp"><primary>sınırlar</primary><secondary>tamsayı türler</secondary></indexterm>
    "Sıfırdan bir milyona kadar bir aralıktaki tamsayı değerleri saklanmak istenirse, kullanabilecek en küçük tür hangisidir?" sorusunun yanıtı "genel bir kural yoktur" olurdu; C derleyicisine ve hedef makineye bağlıdır. Hangi tür ile çalışılacağını bulmak için &limits.h; başlık dosyasında tanımlanmış olan <varname>MIN</varname> ve <varname>MAX</varname> makroları kullanılabilir.
   </para>
   <para>
    Her işaretli tamsayı türü için, tutabileceği en küçük ve en büyük değerleri veren bir çift makro vardır. Her işaretsiz tamsayı türü için de böyle makrolar vardır; en büyük değer için, en küçük değer yani sıfır için.
   </para>
   <para>
    Bu makroların değerlerinin hepsi tamsayı sabit ifadeleridir. <type>char</type> ve <type>short&nbsp;int</type> için <varname>MAX</varname> ve <varname>MIN</varname> makroları <type>int</type> türünden değerlere sahiptir. Diğer türlerin <varname>MAX</varname> ve <varname>MIN</varname> makrolarının değerleri de makro tarafından açıklananla aynı türde değerlerdir. Örneğin, <varname>ULONG_MAX</varname> makrosunun değeri <type>unsigned&nbsp;long&nbsp;int</type> türündendir.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-SCHAR_MIN"><primary>SCHAR_MIN</primary></indexterm>
    <csproto type="makro">
     <csname><function>SCHAR_MIN</function></csname>
    </csproto>
    <header>&limits.h;</header>
    <para>
     <type>signed&nbsp;char</type> tarafından gösterilebilen en küçük değerdir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-SCHAR_MAX"><primary>SCHAR_MAX</primary></indexterm>
    <csproto type="makro">
     <csname><function>SCHAR_MAX</function></csname>
    </csproto>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-UCHAR_MAX"><primary>UCHAR_MAX</primary></indexterm>
    <csproto type="makro">
     <csname><function>UCHAR_MAX</function></csname>
    </csproto>
    <header>&limits.h;</header>
    <para>
     Sırasıyla <type>signed&nbsp;char</type> ve <type>unsigned&nbsp;char</type> tarafından gösterilebilen en büyük değerlerdir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-CHAR_MIN"><primary>CHAR_MIN</primary></indexterm>
    <csproto type="makro">
     <csname><function>CHAR_MIN</function></csname>
    </csproto>
    <header>&limits.h;</header>
    <para>
     <type>char</type> tarafından gösterilebilen en küçük değerdir. <type>char</type> işaretli ise <varname>SCHAR_MIN</varname>'e, değilse sıfıra eşittir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-CHAR_MAX"><primary>CHAR_MAX</primary></indexterm>
    <csproto type="makro">
     <csname><function>CHAR_MAX</function></csname>
    </csproto>
    <header>&limits.h;</header>
    <para>
     <type>char</type> tarafından gösterilebilen en büyük değerdir. <type>char</type> işaretli ise <varname>SCHAR_MAX</varname>'a, değilse <varname>UCHAR_MAX</varname>'a eşittir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-SHRT_MIN"><primary>SHRT_MIN</primary></indexterm>
    <csproto type="makro">
     <csname><function>SHRT_MIN</function></csname>
    </csproto>
    <header>&limits.h;</header>
    <para>
     <type>signed&nbsp;short&nbsp;int</type> tarafından gösterilebilen en küçük değerdir. &glibc;nin üzerinde çalıştığı çoğu makinede, kısa tamsayılar 16 bitlik niceliklerdir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-SHRT_MAX"><primary>SHRT_MAX</primary></indexterm>
    <csproto type="makro">
     <csname><function>SHRT_MAX</function></csname>
    </csproto>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-USHRT_MAX"><primary>USHRT_MAX</primary></indexterm>
    <csproto type="makro">
     <csname><function>USHRT_MAX</function></csname>
    </csproto>
    <header>&limits.h;</header>
    <para>
     Sırasıyla <type>signed&nbsp;short&nbsp;int</type> ve <type>unsigned&nbsp;short&nbsp;int</type> tarafından gösterilebilen en büyük değerlerdir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-INT_MIN"><primary>INT_MIN</primary></indexterm>
    <csproto type="makro">
     <csname><function>INT_MIN</function></csname>
    </csproto>
    <header>&limits.h;</header>
    <para>
     <type>signed&nbsp;int</type> tarafından gösterilebilen en küçük değerdir. &glibc;nin üzerinde çalıştığı çoğu makinede, <type>int</type> değerler 32 bitlik niceliklerdir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-INT_MAX"><primary>INT_MAX</primary></indexterm>
    <csproto type="makro">
     <csname><function>INT_MAX</function></csname>
    </csproto>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-UINT_MAX"><primary>UINT_MAX</primary></indexterm>
    <csproto type="makro">
     <csname><function>UINT_MAX</function></csname>
    </csproto>
    <header>&limits.h;</header>
    <para>
     Sırasıyla <type>signed&nbsp;int</type> ve <type>unsigned&nbsp;int</type> tarafından gösterilebilen en büyük değerlerdir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-LONG_MIN"><primary>LONG_MIN</primary></indexterm>
    <csproto type="makro">
     <csname><function>LONG_MIN</function></csname>
    </csproto>
    <header>&limits.h;</header>
    <para>
     <type>signed&nbsp;long&nbsp;int</type> tarafından gösterilebilen en küçük değerdir. &glibc;nin üzerinde çalıştığı çoğu makinede, <type>long</type> değerler <code>int</code> ile aynı boyutta 32 bitlik niceliklerdir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-LONG_MAX"><primary>LONG_MAX</primary></indexterm>
    <csproto type="makro">
     <csname><function>LONG_MAX</function></csname>
    </csproto>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-ULONG_MAX"><primary>ULONG_MAX</primary></indexterm>
    <csproto type="makro">
     <csname><function>ULONG_MAX</function></csname>
    </csproto>
    <header>&limits.h;</header>
    <para>
     Sırasıyla <type>signed&nbsp;long&nbsp;int</type> ve <type>unsigned&nbsp;long&nbsp;int</type> tarafından gösterilebilen en büyük değerlerdir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-LLONG_MIN"><primary>LLONG_MIN</primary></indexterm>
    <csproto type="makro">
     <csname><function>LLONG_MIN</function></csname>
    </csproto>
    <header>&limits.h;</header>
    <para>
     <type>signed&nbsp;long&nbsp;long&nbsp;int</type> tarafından gösterilebilen en küçük değerdir. &glibc;nin üzerinde çalıştığı çoğu makinede, <type>long&nbsp;long</type> değerler 64 bitlik niceliklerdir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-LLONG_MAX"><primary>LLONG_MAX</primary></indexterm>
    <csproto type="makro">
     <csname><function>LLONG_MAX</function></csname>
    </csproto>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-ULLONG_MAX"><primary>ULLONG_MAX</primary></indexterm>
    <csproto type="makro">
     <csname><function>ULLONG_MAX</function></csname>
    </csproto>
    <header>&limits.h;</header>
    <para>
     Sırasıyla <type>signed&nbsp;long&nbsp;long&nbsp;int</type> ve <type>unsigned&nbsp;long&nbsp;long&nbsp;int</type> tarafından gösterilebilen en büyük değerlerdir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-LONG_LONG_MIN"><primary>LONG_LONG_MIN</primary></indexterm>
    <csproto type="makro">
     <csname><function>LONG_LONG_MIN</function></csname>
    </csproto>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-LONG_LONG_MAX"><primary>LONG_LONG_MAX</primary></indexterm>
    <csproto type="makro">
     <csname><function>LONG_LONG_MAX</function></csname>
    </csproto>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-ULONG_LONG_MAX"><primary>ULONG_LONG_MAX</primary></indexterm>
    <csproto type="makro">
     <csname><function>ULONG_LONG_MAX</function></csname>
    </csproto>
    <header>&limits.h;</header>
    <para>
     <varname>LLONG_MIN</varname>, <varname>LLONG_MAX</varname> ve <varname>ULLONG_MAX</varname> makrolarının eski isimleri olup yalnızca <code>_GNU_SOURCE</code> tanımlıysa kullanılabilir. Bkz. <xref linkend="glibc-Feature-Test-Macros"/>.  GCC 3.0 öncesinde yalnızca bu isimler kullanılabiliyordu.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-WCHAR_MAX_"><primary>WCHAR_MAX</primary></indexterm>
    <csproto type="makro">
     <csname><function>WCHAR_MAX</function></csname>
    </csproto>
    <header>&limits.h;</header>
    <para>
     <type>wchar_t</type> tarafından gösterilebilen en büyük değerdir. Bkz. <xref linkend="glibc-Extended-Char-Intro"/>.
    </para>
   </csynopsis>
   <para>
    &limits.h; başlık dosyasında ayrıca işletim sistemi ve dosya sistemi sınırlarını belirleyen bazı sabitler de bulunmaktadır. Bu sabitler <xref linkend="glibc-System-Configuration"/> bölümünde açıklanmıştır.
   </para>
  </sect1>
  <sect1 xml:id="glibc-Floating-Type-Macros">
   <title>Gerçek Sayı Türü Makroları</title>
   <titleabbrev>Gerçek sayı türlerini ölçümlemede kullanılan makrolar.</titleabbrev>
   <preliminary>
    <para>
     <indexterm linkend="glibc-cp"><primary>gerçek sayılar</primary><secondary>türün genişliği</secondary></indexterm>
     <indexterm linkend="glibc-cp"><primary>veri türü olçüleri</primary><secondary>gerçek sayılar</secondary></indexterm>
     <indexterm linkend="glibc-cp"><primary>sınırlar</primary><secondary>gerçek sayı türleri</secondary></indexterm>
     Gerçek sayılara özel gösterim makineden makineye değişir. Çünkü gerçek sayılar dahili olarak yaklaşık niceliklerle gösterilir. Gerçek sayı verilerle çalışan algoritmalar çoğunlukla makinenin doğru gerçek sayı gösterim ayrıntılarına dikkat etmeyi gerektirir.
    </para>
    <para>
     C kütüphanesindeki bazı işlevlerin kendileri de bu bilgiye gereksinim duyar; örneğin, gerçek sayıları okumak ve basmak (Bkz. <xref linkend="glibc-I-O-on-Streams"/>) için ve trigonometri ve gerçel sayı işlevlerinin (Bkz. <xref linkend="glibc-Mathematics"/>)  hesaplanmasında kullanılan algoritmalar yuvarlama hatalarından ve hassasiyet kayıplarından kaçınmak için bunu kullanır. Sayısal analiz teknikleri gerçekleştiren bazı kullanıcı yazılımları da çoğunlukla hata sınırlarının küçültülmesi ya da hesaplanması sırasında bu bilgiye ihtiyaç duyar.
    </para>
    <para>
     &float.h; başlık dosyası makinenizde kullanılan biçimi açıklar.
    </para>
   </preliminary>
   <sect2 xml:id="glibc-Floating-Point-Concepts">
    <title>Gerçek Sayı Gösterimi ile İlgili Kavramlar</title>
    <titleabbrev>Terminoloji.</titleabbrev>
    <para>
     <dicterm><english>base</english><turkish>taban (sayılar)</turkish></dicterm>
     <dicterm><english>radix</english><turkish>taban (sayılar)</turkish></dicterm>
     <dicterm><english>exponent</english><turkish>üstel kısım (sayılar)</turkish></dicterm>
     <dicterm><english>mantissa</english><turkish>ondalık kısım (sayılar)</turkish></dicterm>
     <dicterm><english>significant</english><turkish>ondalık kısım (sayılar)</turkish></dicterm>
     Bu bölümde gerçek sayı gösterimleri ile ilgili terminolojiye değinilmiştir.
    </para>
    <para>
     Büyük ihtimalle gerçek sayılar için üstel gösterim veya bilimsel terimler olarak bu kavramların çoğuna zaten aşinasınızdır. Örneğin <command>123456.0</command> sayısı üstel olarak <command>1.23456e+05</command> biçiminde, <command>1.23456</command> sayısı ile  <command>10</command> üssü <command>5</command>'in çarpımı olarak gösterilir.
    </para>
    <para>
     Daha biçimsel olarak, gerçek sayıların bit gösterimi aşağıdaki terimlerle tanımlanabilir:
    </para>
    <itemizedlist>
     <listitem>
      <para>
       <indexterm linkend="glibc-cp-sign"><primary>gerçek sayıların bit gösterimi</primary><secondary>işaret biti</secondary></indexterm>
       <wordasword>İşaret</wordasword> ya <code>-1</code> ya da <code>1</code>'dir.
      </para>
     </listitem>
     <listitem>
      <para>
       <indexterm linkend="glibc-cp-base"><primary>gerçek sayıların bit gösterimi</primary><secondary>taban</secondary></indexterm>
       Üs alma için <wordasword>taban</wordasword>, <code>1</code>'den büyük bir tamsayıdır. Belirli bir gösterim için bu bir sabittir.
      </para>
     </listitem>
     <listitem>
      <para>
       <indexterm linkend="glibc-cp-exponent"><primary>gerçek sayıların bit gösterimi</primary><secondary>üstel kısım</secondary></indexterm>
       <wordasword>Üstel kısım</wordasword> tabanın kendisiyle kaç defa çarpılacağını gösterir.  Belirli bir gösterim için üs değerinin alt ve üst sınırları birer sabittir.
      </para>
      <para>
       Kimi zaman gerçek sayının bit gösteriminde üssü ifade eden kısım bir sabit eklenmesiyle daima işaretsiz bir nicelik yapılır. Bu sadece bit alanlarını ayırıp gerçek sayıyı kendiniz oluşturmak isterseniz önemli olur, ancak GNU kütüphanesinde böyle bir işlem için destek yoktur. Bu nedenle, aşağıdaki açıklamalarda bu göz ardı edilmiştir.
      </para>
     </listitem>
     <listitem>
      <para>
       <indexterm linkend="glibc-cp-mantissa"><primary>gerçek sayıların bit gösterimi</primary><secondary>ondalık kısım</secondary></indexterm>
       <wordasword>Ondalık kısım</wordasword> her gerçek sayının bir parçası olan işaretsiz bir tamsayıdır.
      </para>
     </listitem>
     <listitem>
      <para>
       <indexterm linkend="glibc-cp-precision"><primary>gerçek sayıların bit gösterimi</primary><secondary>hassasiyet</secondary></indexterm>
       Ondalık kısmın <wordasword>hassasiyet</wordasword>i. Eğer bit gösteriminde taban <replaceable>b</replaceable> ise hassasiyet, ondalık kısmın taban-<replaceable>b</replaceable> sayıda basamağıdır. Bu belirli bir gösterim için bir sabittir.
      </para>
      <para>
       <indexterm linkend="glibc-cp-hidden-bit"><primary>gerçek sayıların bit gösterimi</primary><secondary>gizli bit</secondary></indexterm>
       Birçok gerçek sayı gösterimi ondalık kısım içinde bir örtük <wordasword>gizli bit</wordasword> içerir. Bu ondalık kısım içinde olduğu varsayılan bir bittir ancak bellekte saklanmaz, çünkü normalleştirilmiş bir sayı içinde daima <code>1</code>'dir. Hassasiyet ile ilgili kısım kendi içinde çok sayıda gizli bit içerebilir.
      </para>
      <para>
       Tekrar belirtmek gerekirse, &glibc; gerçek sayıların düşük seviye (ikil tabandaki bit gösterimi) gösterimleri ile ilgili oluşumlara destek sağlamamaktadır.
      </para>
     </listitem>
    </itemizedlist>
    <para>
     <dicterm><english>fraction</english><turkish>kesir</turkish></dicterm>
     <dicterm><english>denominator</english><turkish>payda</turkish></dicterm>
     Bir gerçek sayının bit gösterimindeki ondalık kısım dolaylı olarak paydası üstel taban hassasiyetteki bir kesri ifade eder. Bu ondalık kısım ile gösterilebilecek en büyük sayı bu paydadan bir eksiği olduğundan kesrin değeri daima birden küçüktür. Bu bit gösteriminin matematiksel değeri bu kesir ile işaret ve üstel tabanın çarpımıdır.
    </para>
    <para>
     <indexterm linkend="glibc-cp-normalized"><primary>normalleştirilmiş gerçek sayı</primary></indexterm>
     Kesir en az <code>1/<replaceable>b</replaceable></code> ise, kayan noktalı sayı <replaceable>b</replaceable> tabanına göre normalleştirilmiştir denir. Başka bir deyişle, mantis tabanla çarpılırsa tahsis edilen alana sığamayacak kadar büyük olur. Normalleştirilmemiş sayılara bazen normal dışı da denir ve gösterimin normalde tutabileceğinden daha az hassasiyet içerir.
    </para>
    <para>
     Sayı normalleştirilmemişse, ondalık kısmı tabanla çarparken üstten 1 çıkarılabilir ve aynı değerde başka bir kayan noktalı sayı elde edilebilir. <emphasis>Normalleştirme</emphasis>, sayı normalleşene kadar bunu tekrar tekrar yapmaktan ibarettir. Bu süreçteki iki farklı normalleştirilmiş kayan noktalı sayı, değer olarak eşit olamaz.
    </para>
    <para>
     (Bu kuralın bir istisnası vardır: ondalik kısım sıfır ise sayı normalleştirilmiş kabul edilir. Başka bir istisna, üssün gösterimin tutabileceği kadar küçük olduğu belirli makinelerde gerçekleşir. O zaman üsten <code>1</code> çıkarmak imkansızdır, dolayısıyla kesri <code>1/<replaceable>b</replaceable></code>'den küçük olsa bile bir sayı normalleştirilebilir.)
    </para>
   </sect2>
   <sect2 xml:id="glibc-Floating-Point-Parameters">
    <title>Gerçek Sayılar ile İlgili Makrolar</title>
    <titleabbrev>Bu sayılara özgü makroların açıklamaları.</titleabbrev>
    <para>
     <indexterm linkend="glibc-pg"><primary>float.h</primary></indexterm>
     Bu makroların tanımları &float.h; başlık dosyasında bulunabilir.
    </para>
    <para>
     <dicterm><english>floating point numbers</english><turkish>gerçek sayılar</turkish></dicterm>
     <code>FLT_</code> ile başlayan makro isimleri <type>float</type> türü ile, <code>DBL_</code> ile başlayanlar <type>double</type> türü ile ve <code>LDBL_</code> ile başlayanlar da <type>long&nbsp;double</type> türü ile ilgilidir. (GCC hedef makinede bir veri türü olarak <type>long&nbsp;double</type> türünü desteklemezse, <code>LDBL_</code> ile başlayan sabitler <type>double</type> türüne karşılık olan sabitlere eşitlenir.)
    </para>
    <para>
     Bu makrolardan sadece <varname>FLT_RADIX</varname> bir sabit ifadesi olarak garantilidir. Burada listelenmiş diğer sabitler <code>#if</code> önişlemci komutu ya da durağan dizilerin boyutları gibi yerlerde sabit ifadesi olarak güvenilir olamaz.
    </para>
    <para>
     &isoc; standardı bu bağımsız değişkenlerin en küçük ve en büyük değerlerini belirtse de, GNU C gerçeklenimi hedef makinede desteklenen gerçek sayı gösterimlerini açıklayan değerleri kullanır. Yani GNU C prensip olarak &isoc; gereksinimlerini hedef makinenin yapabildiği kadarıyla karşılar. Uygulamada tüm makinelerde bu destekler zaten vardır.
    </para>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-FLT_ROUNDS"><primary>FLT_ROUNDS</primary></indexterm>
     <csproto type="makro">
      <csname><function>FLT_ROUNDS</function></csname>
     </csproto>
     <header>&float.h;</header>
     <para>
      Bu değer gerçek sayı toplamasında yuvarlama kipini belirler. Standart yuvarlama kiplerinin değerleri:
     </para>
     <variablelist>
      <varlistentry>
       <term><code>-1</code></term>
       <listitem>
        <para>
         Bu kip belirlenebilir değildir.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><code>0</code></term>
       <listitem>
        <para>
         Sıfıra yuvarlar.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><code>1</code></term>
       <listitem>
        <para>
         En yakın sayıya yuvarlar.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><code>2</code></term>
       <listitem>
        <para>
         Pozitif sonsuza yuvarlar.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><code>3</code></term>
       <listitem>
        <para>
         Negatif sonsuza yuvarlar.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
     <para>
      Diğer değerler, eğer varsa, makine bağımlı standart dışı yuvarlama kiplerini belirtir.
     </para>
     <para>
      Gerçek sayılar için IEEE standardı gereğince çoğu makinede <code>1</code> değeri kullanılır.
     </para>
     <para>
      <dicterm><english>single-precision</english><turkish>tek hassasiyetli</turkish></dicterm>
      <dicterm><english>double-precision</english><turkish>çift hassasiyetli</turkish></dicterm>
      Aşağıdaki tabloda <code>FLT_ROUNDS</code> sabitinin olası değerleri ile yuvarlamanın nasıl yapıldığı gösterilmiştir. Yuvarlama IEEE tek hassasiyetli gerçek sayılar standardına uygun olarak yapılmıştır.
     </para>
     <literallayout class="monospaced">                0      1             2             3
 1.00000003    1.0    1.0           1.00000012    1.0
 1.00000007    1.0    1.00000012    1.00000012    1.0
-1.00000003   -1.0   -1.0          -1.0          -1.00000012
-1.00000007   -1.0   -1.00000012   -1.0          -1.00000012
</literallayout>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-FLT_RADIX"><primary>FLT_RADIX</primary></indexterm>
     <csproto type="makro">
      <csname><function>FLT_RADIX</function></csname>
     </csproto>
     <header>&float.h;</header>
     <para>
      Bit gösteriminde üstel kısmın tabanına karşılık gelen değerdir. Bu bölümde açıklanan diğer makroların aksine bir sabit ifadesi olarak garantilidir. IBM 360 ve türevleri dışında bilinen tüm makineler için değeri 2 dir.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-FLT_MANT_DIG"><primary>FLT_MANT_DIG</primary></indexterm>
     <csproto type="makro">
      <csname><function>FLT_MANT_DIG</function></csname>
     </csproto>
     <header>&float.h;</header>
     <para>
      <type>float</type> veri türü için gerçek sayının ondalık kısmındaki taban-<varname>FLT_RADIX</varname> basamağın basamak sayısıdır. Aşağıdaki ifade ondalık kısım basamaklarının sınırlı olmasından dolayı <code>1.0</code>'a gider (matematiksel olarak olmasa da):
     </para>
     <screen>float radix = FLT_RADIX;

1.0f + 1.0f / radix / radix / … / radix
</screen>
     <para>
      Burada <replaceable>radix</replaceable>, <code>FLT_MANT_DIG</code> kere uygulanır.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-DBL_MANT_DIG"><primary>DBL_MANT_DIG</primary></indexterm>
     <csproto type="makro">
      <csname><function>DBL_MANT_DIG</function></csname>
     </csproto>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-LDBL_MANT_DIG"><primary>LDBL_MANT_DIG</primary></indexterm>
     <csproto type="makro">
      <csname><function>LDBL_MANT_DIG</function></csname>
     </csproto>
     <header>&float.h;</header>
     <para>
      Sırasıyla <type>double</type> ve <type>long double</type> veri türleri için gerçek sayının ondalık kısmındaki taban-<varname>FLT_RADIX</varname> basamağın basamak sayısıdır.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-FLT_DIG"><primary>FLT_DIG</primary></indexterm>
     <csproto type="makro">
      <csname><function>FLT_DIG</function></csname>
     </csproto>
     <header>&float.h;</header>
     <para>
      <type>float</type> türü için hassasiyeti belirleyen ondalık basamakların sayısıdır. Teknik olarak <replaceable>h</replaceable> ve <replaceable>t</replaceable> sırasıyla ikilik gösterimdeki hassasiyet ve taban ise onluk gösterimdeki hassasiyet <replaceable>o</replaceable> ondalık basamakların sayısıdır, örneğin, <replaceable>o</replaceable> tabanındaki 10 basamaklı bir gerçek sayı <replaceable>t</replaceable> tabanındaki <replaceable>h</replaceable> basamağa yuvarlanır ve <replaceable>o</replaceable> ondalık basamak sayısı değiştirilmeksizin korunur.
     </para>
     <para>
      Bu makronun değerinin &isoc; gereksinimlerini karşılamak üzere en azından <code>6</code> olacağı varsayılır.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-DBL_DIG"><primary>DBL_DIG</primary></indexterm>
     <csproto type="makro">
      <csname><function>DBL_DIG</function></csname>
     </csproto>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-LDBL_DIG"><primary>LDBL_DIG</primary></indexterm>
     <csproto type="makro">
      <csname><function>LDBL_DIG</function></csname>
     </csproto>
     <header>&float.h;</header>
     <para>
      <varname>FLT_DIG</varname> makrosuna benzerler ancak sırasıyla <type>double</type> ve <type>long double</type> veri türleri içindir. Bu makroların değerlerinin en azından <code>10</code> olacağı varsayılır.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-FLT_MIN_EXP"><primary>FLT_MIN_EXP</primary></indexterm>
     <csproto type="makro">
      <csname><function>FLT_MIN_EXP</function></csname>
     </csproto>
     <header>&float.h;</header>
     <para>
      <type>double</type> türü için ikil gösterimdeki mümkün en küçük üs değeridir. Daha ayrıntılı ifade etmek gerekirse, <type>double</type> türündeki normalleştirilmiş bir gerçek sayı olarak <varname>FLT_RADIX</varname> değerinin bu değerden bir eksiğinin artan kuvvetlerinden elde edilebilecek en küçük değerini sağlayacak olan en küçük negatif tamsayıdır.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-DBL_MIN_EXP"><primary>DBL_MIN_EXP</primary></indexterm>
     <csproto type="makro">
      <csname><function>DBL_MIN_EXP</function></csname>
     </csproto>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-LDBL_MIN_EXP"><primary>LDBL_MIN_EXP</primary></indexterm>
     <csproto type="makro">
      <csname><function>LDBL_MIN_EXP</function></csname>
     </csproto>
     <header>&float.h;</header>
     <para>
      <varname>FLT_MIN_EXP</varname>'ye benzerler ancak sırasıyla <type>double</type> ve <type>long double</type> veri türleri içindir.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-FLT_MIN_10_EXP"><primary>FLT_MIN_10_EXP</primary></indexterm>
     <csproto type="makro">
      <csname><function>FLT_MIN_10_EXP</function></csname>
     </csproto>
     <header>&float.h;</header>
     <para>
      <type>float</type> türü için onluk tabanda üssün en küçük negatif değeri olan bir tamsayıdır. Normalleştirilmiş gerçek sayıların mümkün en küçük değeri için <code>10</code>'un bu değerden <code>1</code> eksiği artan kuvvetindeki değerine karşılıktır. Bu değerin <code>-37</code> veya daha az olduğu varsayılır.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-DBL_MIN_10_EXP"><primary>DBL_MIN_10_EXP</primary></indexterm>
     <csproto type="makro">
      <csname><function>DBL_MIN_10_EXP</function></csname>
     </csproto>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-LDBL_MIN_10_EXP"><primary>LDBL_MIN_10_EXP</primary></indexterm>
     <csproto type="makro">
      <csname><function>LDBL_MIN_10_EXP</function></csname>
     </csproto>
     <header>&float.h;</header>
     <para>
      <varname>FLT_MIN_10_EXP</varname>'ye benzerler ancak sırasıyla <type>double</type> ve <type>long double</type> veri türleri içindir.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-FLT_MAX_EXP"><primary>FLT_MAX_EXP</primary></indexterm>
     <csproto type="makro">
      <csname><function>FLT_MAX_EXP</function></csname>
     </csproto>
     <header>&float.h;</header>
     <para>
      <type>float</type> türü için ikilik gösterimdeki mümkün en büyük üs değeridir. Daha ayrıntılı ifade etmek gerekirse, <type>float</type> türündeki normalleştirilmiş bir gerçek sayı olarak <varname>FLT_RADIX</varname> değerinin bu değerden bir eksiğinin artan kuvvetlerinden elde edilebilecek en büyük değerini sağlayacak olan en büyük pozitif tamsayıdır.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-DBL_MAX_EXP"><primary>DBL_MAX_EXP</primary></indexterm>
     <csproto type="makro">
      <csname><function>DBL_MAX_EXP</function></csname>
     </csproto>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-LDBL_MAX_EXP"><primary>LDBL_MAX_EXP</primary></indexterm>
     <csproto type="makro">
      <csname><function>LDBL_MAX_EXP</function></csname>
     </csproto>
     <header>&float.h;</header>
     <para>
      <varname>FLT_MAX_EXP</varname>'ye benzerler ancak sırasıyla <type>double</type> ve <type>long double</type> veri türleri içindir.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-FLT_MAX_10_EXP"><primary>FLT_MAX_10_EXP</primary></indexterm>
     <csproto type="makro">
      <csname><function>FLT_MAX_10_EXP</function></csname>
     </csproto>
     <header>&float.h;</header>
     <para>
      <type>float</type> türü için onluk tabanda üssün en büyük değeri olan pozitif tamsayıdır. Normalleştirilmiş gerçek sayıların mümkün en küçük değeri için <code>10</code>'un bu değerden <code>1</code> eksiği artan kuvvetindeki değerine karşılıktır. Bu değerin en azından <code>37</code> olduğu varsayılır.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-DBL_MAX_10_EXP"><primary>DBL_MAX_10_EXP</primary></indexterm>
     <csproto type="makro">
      <csname><function>DBL_MAX_10_EXP</function></csname>
     </csproto>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-LDBL_MAX_10_EXP"><primary>LDBL_MAX_10_EXP</primary></indexterm>
     <csproto type="makro">
      <csname><function>LDBL_MAX_10_EXP</function></csname>
     </csproto>
     <header>&float.h;</header>
     <para>
      <varname>FLT_MAX_10_EXP</varname>'ye benzerler ancak sırasıyla <type>double</type> ve <type>long double</type> veri türleri içindir.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-FLT_MAX"><primary>FLT_MAX</primary></indexterm>
     <csproto type="makro">
      <csname><function>FLT_MAX</function></csname>
     </csproto>
     <header>&float.h;</header>
     <para>
      Bu makronun değeri <type>float</type> türünde ifade edilebilecek en büyük gerçek sayının değeridir. Bu değerin en azından <code>1E+37</code> olacağı varsayılır ve bu değer <type>float</type> türündendir.
     </para>
     <para>
      İfade edilebilir en küçük sayı ise <code>- FLT_MAX</code>'tır.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-DBL_MAX"><primary>DBL_MAX</primary></indexterm>
     <csproto type="makro">
      <csname><function>DBL_MAX</function></csname>
     </csproto>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-LDBL_MAX"><primary>LDBL_MAX</primary></indexterm>
     <csproto type="makro">
      <csname><function>LDBL_MAX</function></csname>
     </csproto>
     <header>&float.h;</header>
     <para>
      <varname>FLT_MAX</varname>'a benzerler ancak sırasıyla <type>double</type> ve <type>long double</type> veri türleri içindir. Makro değerinin veri türü kendi türü ile aynıdır.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-FLT_MIN"><primary>FLT_MIN</primary></indexterm>
     <csproto type="makro">
      <csname><function>FLT_MIN</function></csname>
     </csproto>
     <header>&float.h;</header>
     <para>
      Bu makronun değeri <type>float</type> türünde ifade edilebilecek en küçük gerçek sayının değeridir. Bu değerin <code>1E-37</code>'den daha büyük olmayacağı varsayılır ve bu değer <type>float</type> türündendir.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-DBL_MIN"><primary>DBL_MIN</primary></indexterm>
     <csproto type="makro">
      <csname><function>DBL_MIN</function></csname>
     </csproto>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-LDBL_MIN"><primary>LDBL_MIN</primary></indexterm>
     <csproto type="makro">
      <csname><function>LDBL_MIN</function></csname>
     </csproto>
     <header>&float.h;</header>
     <para>
      <varname>FLT_MIN</varname>'a benzerler ancak sırasıyla <type>double</type> ve <type>long double</type> veri türleri içindir. Makro değerinin veri türü kendi türü ile aynıdır.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-FLT_EPSILON"><primary>FLT_EPSILON</primary></indexterm>
     <csproto type="makro">
      <csname><function>FLT_EPSILON</function></csname>
     </csproto>
     <header>&float.h;</header>
     <para>
      Bu, <code>1</code> ile <type>float</type> türünün <code>1</code>'den büyük en küçük kayan noktalı sayısı arasındaki farktır. <code>1E-5</code>'ten büyük olmayacağı varsayılır.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-DBL_EPSILON"><primary>DBL_EPSILON</primary></indexterm>
     <csproto type="makro">
      <csname><function>DBL_EPSILON</function></csname>
     </csproto>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-LDBL_EPSILON"><primary>LDBL_EPSILON</primary></indexterm>
     <csproto type="makro">
      <csname><function>LDBL_EPSILON</function></csname>
     </csproto>
     <header>&float.h;</header>
     <para>
      <varname>FLT_EPSILON</varname>'a benzerler ancak sırasıyla <type>double</type> ve <type>long double</type> veri türleri içindir. Makro değerinin veri türü kendi türü ile aynıdır. <code>1E-0</code>'dan büyük olmayacağı varsayılır.
     </para>
    </csynopsis>
   </sect2>
   <sect2 xml:id="glibc-IEEE-Floating-Point">
    <title>IEEE Gerçek Sayı Gösterimleri</title>
    <titleabbrev>Ortak gösterim için ölçüler.</titleabbrev>
    <para>
     <indexterm linkend="glibc-cp"><primary>IEEE gerçek sayı gösterimleri</primary></indexterm>
     <indexterm linkend="glibc-cp"><primary>gerçek sayıların bit gösterimi</primary><secondary>IEEE</secondary></indexterm>
     Burada, en genel gerçek sayı gösterimi olan  <citation>IEEE Standard for Binary Floating Point Arithmetic (ANSI/IEEE Std 754-1985)</citation> tarafından belirtilmiş gerçek sayı metrikleri için bir örnek gösterilmektedir. 1980'lerden sonra tasarlanan tüm bilgisayarlar bu biçimi kullanır.
    </para>
    <para>
     IEEE tek hassasiyetli gerçek sayı biçimi ikilik tabanı kullanır. Bir işaret biti, 23 bit artı bir gizli bit olmak üzere (yani toplam hassasiyet 24 taban-2 basamak) 24 bitlik ondalık kısım ile  -125 ile 128 aralığındaki üs değerleri için 8 bitlik üstel kısımdan oluşan bir gösterim sunar.
    </para>
    <para>
     Bu gösterimin <type>float</type> veri türünü gerçeklemekte kullanılan ilgili değerleri aşağıda gösterilmiştir:
    </para>
    <literallayout class="monospaced">FLT_RADIX                             2
FLT_MANT_DIG                         24
FLT_DIG                               6
FLT_MIN_EXP                        -125
FLT_MIN_10_EXP                      -37
FLT_MAX_EXP                         128
FLT_MAX_10_EXP                      +38
FLT_MIN                 1.17549435E-38F
FLT_MAX                 3.40282347E+38F
FLT_EPSILON             1.19209290E-07F
</literallayout>
    <para>
     Bu değerler de <type>double</type> veri türü içindir:
    </para>
<literallayout class="monospaced">DBL_MANT_DIG                         53
DBL_DIG                              15
DBL_MIN_EXP                       -1021
DBL_MIN_10_EXP                     -307
DBL_MAX_EXP                        1024
DBL_MAX_10_EXP                      308
DBL_MAX         1.7976931348623157E+308
DBL_MIN         2.2250738585072014E-308
DBL_EPSILON     2.2204460492503131E-016
</literallayout>
   </sect2>
  </sect1>
  <sect1 xml:id="glibc-Structure-Measurement">
   <title>Yapı Alanı Konum Ölçüleri</title>
   <titleabbrev>Yapı türleri üzerinden ölçü alınması.</titleabbrev>
   <para>
    Bir yapı içindeki bir yapı üyesinin konumunu bulmak için <function>offsetof</function> kullanılır.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-offsetof"><primary>offsetof</primary></indexterm>
    <csproto type="makro">
     <csname><type>size_t</type><function>offsetof</function></csname>
     <csparam><parameter>type</parameter></csparam>
     <csparam><parameter>member</parameter></csparam>
    </csproto>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     <parameter>type</parameter> türündeki yapının <parameter>member</parameter> isimli üyesinin konumunu bir tamsayı sabit olarak döndürür. Örneğin <code>offsetof (struct s, elem)</code> ifadesi, <code>struct s</code> içindeki <code>elem</code> üyesinin bayt cinsinden başlangıç konumunu verir.
    </para>
    <para>
     Bu makro, <parameter>member</parameter> bir bit alanı ise çalışmayacaktır. Bu durumda C derleyicisi hata verir.
    </para>
   </csynopsis>
  </sect1>
 </chapter>
</part>
