<?xml version="1.0" encoding="UTF-8"?>

<!-- ********************************************************************
     $Id: appa.xml,v 1.2 2002/12/20 22:29:48 nilgun Exp $
******************************************************************** -->
<appendix id="glibc-Language-Features">
  <title>Kütüphanedeki C Dili Oluşumları</title>
  <titleabbrev>Kütüphane tarafından sağlanan C dili oluşumları.</titleabbrev>
  <para>
C kütüphanesi tarafından gerçekleştirilen bazı oluşumların aslında C dilini kendisinde bulunması gerekir. Bu oluşumlar kütüphane kılavuzunun değil C Dili Kılavuzunun bir parçası olmalıydı, ancak henüz bir dil kılavuzumuz olmadığı için bu oluşumların belgelendirilmesi burada yapılmıştır.
  </para>
  <sect1 id="glibc-Consistency-Checking">
    <title>Dahilî Kararlılığın Doğrudan Denetlenmesi</title>
    <titleabbrev>Bazı "imkansız" şeyler oluştuğunda çıkmak için <command>assert</command> kullanımı</titleabbrev>
    <para>
<indexterm scope="glibc-cp"><primary>kararılık denetimi</primary></indexterm>
<indexterm scope="glibc-cp"><primary>imkansız olaylar</primary></indexterm>
<indexterm scope="glibc-cp"><primary>savlar</primary></indexterm>
Bir yazılımı geliştirirken "imkansız" hatalara ve temel kabullerdeki çatışmalara karşı bazı stratejik yerlere denetimler yerleştirmek iyi olur. Bu çeşit denetimler örneğin, yazılımın farklı parçaları arasında, arayüzlerle hata ayıklama sorunlarını gidermeye yardımcı olur.
    </para><para>
<indexterm scope="glibc-pg"><primary>assert.h</primary></indexterm>
<command>assert</command> makrosu <filename>assert.h</filename> başlık dosyasında tanımlanmıştır ve yazılımda bir hata saptandığında bir ileti basarak yazılımın çıkması için kullanışlı bir yol sağlar.
    </para><para>
<indexterm scope="glibc-vr"><primary>NDEBUG</primary></indexterm>
Yazılımınızın artık hatalardan arındığı düşündüğünüzde, <command>assert</command> makrosu tarafından uygulanan hata denetimlerini, <command>NDEBUG</command> makrosunu tanımladıktan sonra yazılımınızı yeniden derleyerek iptal edebilirsiniz. Yani, bu denetimleri iptal etmek için yazılımınızın kaynak kodunu değiştirmeniz gerekmez.
    </para><para>
Ancak bu kararlılık denetimlerinin iptal edilmesi, bu denetimler yazılımınızın  çalışmasını kaydadeğer oranda yavaşlatmadıkça yapılmasa iyi olur. Yazılımın çalışmasına çok etki etmedikçe daha fazla hata denetimi yapılması daha iyidir. Başlangıç seviyesinde bir kullanıcı bir yazılımın çökmesi sırasında hiçbir  uyarı görmezse  herşeyi yanlış yaptığı sanısına kapılabilir.
    </para><para>
<indexterm scope="glibc-fn"><primary>assert</primary></indexterm>
<funcsynopsis><funcprototype role="makro" id="glibc-assert">
<funcdef>void <command>assert</command></funcdef>
<paramdef>(int <varname>ifade</varname>)</paramdef>
</funcprototype><funcdescr><para>
Yazılımın o noktasında <varname>ifade</varname> sıfırdan farklıysa yazılımcının kanaatini doğrular.
      </para><para>
<command>NDEBUG</command> tanımlı değilse, <command>assert</command>  <varname>ifade</varname>nin değerini sınamaya tabi tutar. Sınama sonucu yanlışsa (sıfır), <command>assert</command> aşağıdakine benzer bir hata iletisini <link linkend="glibc-Standard-Streams">standart hataya</link>  (<command>stderr</command>) basarak <link linkend="glibc-Aborting-a-Program">yazılımı sonlandırır</link>:
      </para><para>
<screen>
<varname>dosya</varname>:<varname>satırno</varname>: <varname>işlev</varname>: `<varname>ifade</varname>' savı başarısız oldu.
</screen></para><para>
Dosya ismi ve satır numarası <command>__FILE__ </command> ve  <command>__LINE__ </command> C önişlemci makrolarıyla saptanır ve <command>assert</command> çağrısının yapıldığı yeri belirtir. GNU C derleyicisi kullanılırken, işlevin yani <command>assert</command> çağrısının işlev ismi <command>__PRETTY_FUNCTION__</command> yerleşik değişkeninden alınır; daha eski derleyicilerde işlev ismi ve onu izleyen iki nokta üstüste yoktur.
      </para><para>
<command>NDEBUG</command> önişlemci makrosu <filename>assert.h</filename> dosyasının içerildiği satırdan önce tanımlanmışsa, <command>assert</command> makrosu mutlak olarak hiçbir şey yapmamak üzere tanımlanmış olur.
      </para><para>
<warning><para><command>NDEBUG</command> etkili ise argüman olarak verilen <varname>ifade</varname> değerlendirilmez. Bu yüzden, yan etkileri olan ifadeleri argüman olarak kullanmayın. Örneğin  <command>assert (++i > 0);</command> gibi bir deyimi asla kullanmayın, çünkü <command>NDEBUG</command> tanımlıysa <command>i</command> hiçbir zaman arttırılmayacaktır.</para></warning>
      </para></funcdescr></funcsynopsis>
    </para><para>
Kimi zaman bir işletim sistemi işlevinden dönen bir hatanın denetlenmesinin istenebileceği "imkansız" durumlar olabilir. Bu durumda sadece yazılımın nerede çöktüğünü değil, neden çöktüğünün de bildirilmesi faydalıdır. <command>assert_perror</command> makrosu bunu kolayca yapar.
    </para><para>
<indexterm scope="glibc-fn"><primary>assert_perror</primary></indexterm>
<funcsynopsis><funcprototype role="makro" id="glibc-assert_perror">
<funcdef>void <command>assert_perror</command></funcdef>
<paramdef>(int <varname>hatanum</varname>)</paramdef>
</funcprototype><funcdescr><para>
<varname>hatanum</varname> değerinin sıfır olduğunu doğruladığı durumda <command>assert</command> işlevine benzer.
      </para><para>
<command>NDEBUG</command> tanımlı değilse, <command>assert_perror</command> <varname>hatanum</varname> değerine bakar. Değer sıfırdan farklıysa, <command>assert_perror</command> aşağıdaki iletiye benzer bir hata iletisini standart hataya basarak yazılımı sonlandırır:
      </para><para>
<screen>
<varname>dosya</varname>:<varname>satırno</varname>: <varname>işlev</varname>: <varname>hata iletisi</varname>
</screen></para><para>
Dosya ismi, satır numarası ve işlev ismi <command>assert</command> işlevindeki gibi elde edilir. <varname>hata iletisi</varname> ise, <command>strerror (<varname>hatanum</varname>)</command> işlevinin sonucudur. Bkz.  <xref linkend="glibc-Error-Messages"/>.
      </para><para>
<command>assert</command> işlevinde olduğu gibi, <command>NDEBUG</command> önişlemci makrosu <filename>assert.h</filename> dosyasının içerildiği satırdan önce tanımlanmışsa, <command>assert_perror</command> makrosu mutlak olarak hiçbir şey yapmamak üzere tanımlanmış olur. Bu durumda argüman olarak verilen <varname>hatanum</varname> değerlendirilmez. Yani, <varname>hatanum</varname> bir yan etki barındırmamalıdır. En iyisi <varname>hatanum</varname> değerinin basit bir değişken başvurusu olmasıdır; doğrudan <command>errno</command> vermek daha iyi olacaktır.
      </para><para>
Bu makro bir GNU oluşumudur.
      </para></funcdescr></funcsynopsis>
    </para><para>
<note><title>Kullanım Bilgisi:</title><para><command>assert</command> oluşumu <emphasis>dahili kararlılığın saptanması</emphasis> için tasarlanmıştır. Yazılımın <emphasis>kullanıcı</emphasis> tarafından yanlış kullanımının ya da geçersiz girdilerinin bildirilmesi için kullanışlı değildir.</para></note>
    </para><para>
<command>assert</command> ve <command>assert_perror</command> tarafından basılan tanı iletilerinden elde edilen bilgiler size yani yazılımcıya yöneliktir. Bir yazılım hatası ile ilgilidir. Kullanıcıya girdilerinin neden geçersiz olduğunu ya da neden bir komutun gerçekleştirilemediğini bildirmek için değildir. Neden yazılımınız, kullanıcının yaptığı bir hatadan dolayı <command>assert</command> işlevinin yaptığı şekilde (bir yazılım hatası vererek) sonlansın ki. Bkz. <xref linkend="glibc-Exit-Status"/>.
    </para><para>
Yazılımınızdaki bir yazılım hatasının sonucu <emphasis>olmayan</emphasis> sorunlarda hata iletilerinin basılması ile ilgili bilgileri <xref linkend="glibc-Error-Messages"/> bölümünde bulabilirsiniz.
    </para>
  </sect1>
  <sect1 id="glibc-Variadic-Functions">
    <title>Değişkin İşlevler</title>
    <titleabbrev>İşlevlerin değişen sayıda argümanla tanımlanması</titleabbrev>
    <para>
<indexterm scope="glibc-cp"><primary>işlevler</primary><secondary>argümanlar</secondary><tertiary>değişen sayıda</tertiary></indexterm>
<indexterm scope="glibc-cp"><primary>işlevler</primary><secondary>argümanlar</secondary><tertiary>isteğe bağlı</tertiary></indexterm>
<indexterm scope="glibc-cp"><primary>işlevler</primary><secondary>değişkin</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>değişkin işlev</primary></indexterm>
ISO C, değişen sayıda argüman alabilecek bir işlevin bildirilebilmesi için bir  sözdizimi tanımlamıştır. Buna rağmen, dilin kendisi bu tür işlevlerin gerekli olmayan argümanlarına erişim için bir mekanizma sağlamaz; bu nedenle, <ulink url="file:/usr/include/stdarg.h"><filename>stdarg.h</filename></ulink> başlık  dosyasındaki makrolarla tanımlanmış olan değişken argümanları kullanacaksınız.
    </para><para>
Bu tür işlevler, <wordasword>değişken argümanlı işlevler</wordasword> [varargs functions] ya da <wordasword>değişkin işlevler</wordasword> [variadic functions] adını alır.
    </para><para>
Bu bölümde değişkin işlevlerin nasıl bildirildikleri, nasıl yazıldıkları ve nasıl çağrıldıkları anlatılmıştır.
    </para><para>
<note><title>Uyumluluk Bilgisi:</title><para>Birçok eski C gerçeklemesi, <filename>stdarg.h</filename> kullanılarak değişken sayıda argümanla işlevleri tanımlama mekanizmasına benzeyen ama uyumlu olmayan bir mekanizma sağlar.</para></note>
    </para>
    <sect2 id="glibc-Why-Variadic">
      <title>Değişkin İşlevler Neden Kullanılır</title>
      <titleabbrev>Değişen sayıda argüman alan işlevleri oluşturmak için sebepler.</titleabbrev>
      <para>
Sıradan C işlevleri sabit sayıda argüman alır. Bir işlevi tanımlarken her argüman için veri türünü de belirtirsiniz. Her işlev çağrısında istenen sayıda argüman verirken argümanlarını da gerekirse tür dönüşümü yaparak istenen türde sağlarsınız. Bu noktada, örneğin, <function>foo</function> işlevi <command>int foo (int, char *);</command> deyimi ile bildirilmişse, onu iki argümanla; bir sayı ve bir dizge göstericisi ile çağırmalısınız.
      </para><para>
Fakat bazı işlevler sınırsız sayıda argümanı anlamlı olarak kabul ederek işlemler uygulayabilir.
      </para><para>
Bazı durumlarda bir işlev çok sayıda değeri bir blok olarak işleyerek elde edebilir. Örneğin, varsayalım ki, bir işlev belirli sayıda değeri tutmak için <command>malloc</command> ile bir tek boyutlu dizi ayırsın. Dizinin uzunluğuna bağlı sayıda değer üzerinde işlem yapılabileceğinden değişen sayıda argümanlı oluşumlar olmaksızın, her olası dizi uzunluğu için ayrı bir işlev tanımlamak zorunda kalırsınız.
      </para><para>
Kütüphane işlevi <command>printf</command>  (Bkz. <xref linkend="glibc-Formatted-Output"/>) değişken argümanlı başka bir işlev sınıfından bir örnek olarak verilebilir. Bu işlev bir biçim şablonu dizgesi altında (değişken sayıda ve türdeki) argümanlarını basar.
      </para><para>
Bunlar, argüman sayısı çağrı sırasında seçilen bir <firstterm>değişkin</firstterm> işlev tanımlamak için iyi sebeplerdir.
      </para><para>
<command>open</command> gibi bazı işlevler sabit sayıda argüman almasına rağmen arasıra son birkaçını yoksayar. ISO C'ye kesin bağlılık durumunda bu işlevlerin değişkin olarak tanımlanması gerekir; uygulamada ise, GNU C derleyicisi ve diğer bir çok C derleyicisi böyle bir işlevi sabit sayıda argümanla tanımlamayı ve sadece <varname>bildirme</varname> işlemini yaparken işlevi değişkin olarak bildirerek (ya da argümanlarının tümünü bildirmeyerek) yapmayı tercih eder.
    </para>
  </sect2>
  <sect2 id="glibc-How-Variadic">
    <title>Değişkin İşlevler Nasıl Tanımlanır ve Kullanılır</title>
    <titleabbrev>Değişkin işlevler nasıl tanımlanır ve çağrılır.</titleabbrev>
    <para>
Bir değişkin işlevin tanımlanması ve kullanılması üç adımdan oluşur:
    </para><para>
      <variablelist><varlistentry><term>Tanım</term><listitem><para>
Bir işlevin değişkin olarak tanımlanması, argüman listesinde bir üçlü nokta (<command>…</command>) kullanarak ve değişken sayıda argümana erişmek için özel makrolar kullanılarak yapılır. Bkz. <xref linkend="glibc-Receiving-Arguments"/>.
      </para></listitem></varlistentry><varlistentry><term>Bildirim</term><listitem><para>
Bir işlevin değişkin olarak bildirilmesi, onu çağıran tüm dosyalarda bir üçlü nokta (<command>…</command>) içeren bir prototip kullanarak yapılır. Bkz. <xref linkend="glibc-Variadic-Prototypes"/>.
      </para></listitem></varlistentry><varlistentry><term>Çağrı</term><listitem><para>
İşlev çağrısı sabit agümanlara ek olarak değişken sayıdaki argümanları yazarak yapılır. Bkz.  <xref linkend="glibc-Calling-Variadics"/>.
      </para></listitem></varlistentry></variablelist>
    </para>
    <sect3 id="glibc-Variadic-Prototypes">
      <title>Değişen Sayıda Argüman için Sözdizimi</title>
      <titleabbrev>Argüman sayısı değişen işlevler için bir prototip nasıl yapılır.</titleabbrev>
      <para>
<indexterm scope="glibc-cp"><primary>işlevler</primary><secondary>prototipler</secondary><tertiary>değişkin</tertiary></indexterm>
<indexterm scope="glibc-cp"><primary>değişkin işlev</primary><secondary>prototipleri</secondary></indexterm>
Değişken sayıda argüman kabul eden bir işlev şimdi açıklanacağı gibi bir prototiple bildirilmelidir. Önce sabit argümanları yazacaksınız, ardından da ek argümanlar olduğunu belirtmek üzere bir üçlü nokta (<command>…</command>) gelecek. ISO C sözdizimi üçlü noktadan önce en az bir sabit argüman gerektirir. Örnek:
     </para><para>
<screen>
int
func (const char *a, int b, …)
{
  …
}
</screen></para><para>
Bu örnekte, <command>int</command> türünde bir dönüş değeri olan ve biri <command>const char *</command> türünde diğeri <command>int</command> türünde iki argüman gerektiren <command>func</command> işlevi tanımlanmıştır. Ayrıca işlevin gerekli olan iki argümandan başka belirsiz sayıda anonim  argümanları da vardır.
      </para><para>
<note><title>Uyumluluk Bilgisi:</title><para>Bazı C derleyicileri için son gerekli argümanın işlev tanımında <command>register</command> olarak bildirilmemesi gereklidir. Bundan başka, bu argümanın türü <firstterm>kendinden terfili</firstterm> olmalıdır: Şöyleki, öntanımlı terfiler onun türünü değiştirmemelidir. Bu kurallar dizi ve işlev türleri ile <command>float</command>, <command>char</command> (signed ya da değil) ve <command>short int</command> (signed ya da değil) türleri dışarda tutar. Bu aslında bir ISO C gerekliliğidir.</para></note>
      </para>
    </sect3><sect3 id="glibc-Receiving-Arguments">
      <title>Argüman değerlerinin Alınması</title>
      <titleabbrev>İsteğe bağlı argüman değerlerine erişimde izlenecek adımlar.</titleabbrev>
      <para>
<indexterm scope="glibc-cp"><primary>değişkin işlev</primary><secondary>argümanlara erişim</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>işlevler</primary><secondary>argümanlar</secondary><tertiary>değişkin işlevlerde</tertiary></indexterm>
Gerekli olan argümanların isimleri vardır ve bu isimleri kullanarak onları değerlerine erişirsiniz. Ama isteğe bağlı argümanların isimleri yoktur, çünkü onlar bir üçlü nokta ile ifade edilmiştir. O halde bu argümanlara nasıl erişilecek?
      </para><para>
<indexterm scope="glibc-pg"><primary>stdarg.h</primary></indexterm>
Onlara erişmenin tek yolu onlara yazıldıkları sırayla erişmektir. Bunun için <filename>stdarg.h</filename> başlık dosyasındaki özel makroları aşağıdaki üç adımlık işlemlerle kullanmalısınız:
      </para><para>
        <orderedlist numeration="arabic"><listitem><para>
<command>va_start</command> kullanarak <command>va_list</command> türünde bir argüman gösterici değişkenini ilklendirin. Argüman gösterici, ilklendirildiğinde ilk isteğe bağlı argümanı gösterecektir.
        </para></listitem><listitem><para>
İsteğe bağlı argümanlara <command>va_arg</command> çağırarak erişirsiniz. İlk <command>va_arg</command> çağrısı ilk isteğe bağlı argümanı, ikinci çağrı ikincisini, böyle gider.
        </para><para>
Bu çağrı işlemini kalan isteğe bağlı argümanları yoksayacağınız yere kadar sürdürebilirsiniz. Bir işlevin argümanlarından daha azına erişmek bir sorun çıkarmaz ama daha fazla sayıda argümana erişmeye çalışırsanız bozuk değerler alırsınız.
        </para></listitem><listitem><para>
Argüman gösterici ile işiniz bittiğinde bunu <command>va_end</command> çağrısıyla belirtin.
        </para><para>
(Uygulamada, birçok C derleyicisi <command>va_end</command> çağrısında hiçbir şey yapmaz. Bu GNU C derleyicisi için de geçerlidir. Ancak, yazılımınızın bir gün bu çağrıyı gerektiren bir derleyici ile derlenebileceğini gözönüne alarak yine de <command>va_end</command> çağrısını yaparsanız iyi olur.)
        </para></listitem></orderedlist>
      </para><para>
<command>va_start</command>,<command>va_arg</command> ve  <command>va_end</command> tanımları için <xref linkend="glibc-Argument-Macros"/> bölümüne bakınız.
      </para><para>
1 den 3 e kadar adımlar isteğe bağlı argümanları kabul eden işlevin içinde uygulanmalıdır. Buna rağmen <command>va_list</command> değişkenini bir argüman olarak başka bir işleve aktararak 2. adımı ya da tamamını burada uygulayabilirsiniz.
      </para><para>
Bu üç adımlık işlemi tek bir işlevi defalarca çağırarak da uygulayabilirsiniz. İsteğe bağlı argümanları yoksaymak istediğinizde ise bu adımları sıfır kere uygulayabilirsiniz.
      </para><para>
İsterseniz, birden fazla argüman gösterici değişkeniniz olabilir ve bu değişkenlerin her birini istediğiniz zaman <command>va_start</command> çağrılarıyla ayrı ayrı ilklendirebilirsiniz. Her argüman gösterici ile istediğiniz kadar isteğe bağlı argümanı alabilirsiniz. Her argüman gösterici değişkeni daima aynı argüman kümesine ama kendi alanında sahip olacaktır.
      </para><para>
<note><title>Taşınabilirlik Bilgisi:</title><para>Bazı derleyicilerle, bir argüman gösterici değerini bir alt işleve aktardıktan sonra, alt işlev döndüğünde aynı argüman gösterici değerini kullanımda tutmamalısınız. Tam taşınabilirlik için, onu  <command>va_end</command>'e aktarmalısınız. Bu aslında bir ISO C gerekliliği olmakla birlikte birçok ANSI C derleyicisi ile de sorunsuz çalışır.</para></note>
      </para>
    </sect3><sect3 id="glibc-How-Many-Arguments">
      <title>Aktarılan Argümanların Sayısı</title>
      <titleabbrev>Daha fazla argüman var mı diye nasıl bakmalı.</titleabbrev>
      <para>
<indexterm scope="glibc-cp"><primary>değişkin işlev</primary><secondary>argümanlara erişim</secondary><tertiary>argüman sayısı</tertiary></indexterm>
<indexterm scope="glibc-cp"><primary>işlevler</primary><secondary>argümanlar</secondary><tertiary>aktarılanlar kaç tane</tertiary></indexterm>
Bir işleve aktarılan isteğe bağlı argümanların sayısını ve türünü saptamak için genel bir yol yoktur. Yani işlevi tasarlayan her kim ise, genellikle çağrıcı tarafından kullanılmak üzere argümanların sayısının ve türünün belirtileceği bir yol da tasarlamalıdır. Bu kimse siz olduğunuza göre her değişkin işlev için bir çağrı yöntemi tespit edip, çağrıları yazarken bunları uygulamalısınız.
      </para><para>
Çağrı yöntemlerinden biri, isteğe bağlı argümanların sayısını sabit argümanlardan birinde belirtmektir. Bu yöntem sadece tüm isteğe bağlı argümanlar aynı türde ise çalışır.
      </para><para>
Bir diğer çağrı yöntemi ise, sabit argümanlardan birinin bir isteğe bağlı argümanın sağlayabileceği her olası amaç için bir bit olmak üzere bir bit maskesi içermesidir. Bu bitleri önceden tanımlanmış bir sırayla sınayarak; eğer bit bir ise sonraki argümanın değerini alırsınız, değilse bir öntanımlı değer kullanırsınız.
      </para><para>
Bir sabit argüman hem argüman sayısını hem de türünü belirten bir kalıp olarak kullanılabilir. <command>printf</command> işlevinin biçim dizgesi argümanı buna bir örnektir (Bkz. <xref linkend="glibc-Formatted-Output-Functions"/>).
      </para><para>
Diğer bir olasılık da, son isteğe bağlı argüman olarak bir "son belirten" değer aktarmaktır. Örneğin isteğe bağlı argümanları göstericilerden oluşan bir işleve sonuncu argüman olarak bir boş gösterici verilebilir. Örneğin, <command>execl</command> işlevi bu yöntemi kullanır. Bkz. <xref linkend="glibc-Executing-a-File"/>.
      </para>
    </sect3><sect3 id="glibc-Calling-Variadics">
      <title>Değişkin İşlevlerin Çağrılması</title>
      <titleabbrev>Argüman sayısı değişen işlevlerin çağrıları hakkında bilmeniz gerekenler.</titleabbrev>
      <para>
<indexterm scope="glibc-cp"><primary>değişkin işlev</primary><secondary>çağırma</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>değişkin işlev</primary><secondary>bildirim</secondary></indexterm>
Bir değişkin işlev çağrısına özel hiçbir şey yoktur. Parantez içine önce gerekli sonra da isteğe bağlı argümanları virgüllerle ayırarak yazarsınız. Ama önce işlevi bir prototiple bildirmeniz gerekir, böylece argüman değerlerinin nasıl dönüştürüleceğini bilirsiniz.
      </para><para>
Prensip olarak, değişkin olarak <emphasis>tanımlanan işlevler</emphasis> çağrılmadan önce bir <link linkend="glibc-Variadic-Prototypes">işlev prototipi</link> kullanarak  değişkin olarak <emphasis>bildirilmelidir</emphasis>. Bazı C derleyicileri, işlevin aldığı sabit ve değişken sayıdaki argümanlara bağlı olarak bir işleve aktarılacak aynı argüman değerleri kümesi için farklı çağrı yöntemleri kullandığı için bu böyledir.
      </para><para>
Uygulamada, GNU C derleyici argümanların gerekli mi, isteğe bağlı mı olduğuna bakmaksızın bir verilmiş argüman türleri kümesini hep aynı yolla aktarır. Yani argüman türleri kendiden terfili olduğu sürece onların bildirilmesini rahatça ihmal edebilirsiniz. Genellikle, değişkin işlevlerin argüman türlerini ve hatta tüm işlevleri bildirmek iyi bir fikirdir. Ancak çok kullanışlı bir kaç işlev vardır ki değişkin olarak bildirilmez; örneğin, <command>open</command> ve <command>printf</command>.
      </para><para>
<indexterm scope="glibc-cp"><primary>öntanımlı argüman terfileri</primary></indexterm>
<indexterm scope="glibc-cp"><primary>işlevler</primary><secondary>argüman terfisi</secondary></indexterm>
İşlev prototipinde isteğe bağlı argümanların türleri belirtilmediğinden, bir değişkin işlev çağrısında isteğe bağlı argüman değerleri üzerinde <firstterm>öntanımlı argüman terfileri</firstterm> uygulanır. Yani, nesne türleri <command>char</command> veya <command>short int</command>  (signed ya da değil) ise ya <command>int</command> ya da  <command>unsigned int</command> türüne, nesne türü <command>float</command>  ise <command>double</command> türüne terfi ettirilir. Böylece örneğin, çağrı sırasına <command>char</command> türünde belirtilen bir argüman, <command>int</command> türüne terfi ettirilerek, işlev argümana <command>va_arg (<varname>arg_gstr</varname>, int)</command> ile erişebilir.
      </para><para>
Gerekli argümanların dönüşümleri ise işlev prototipi tarafından genel bir yolla denetlenir: argüman işlev prototipinde bildirilen türde değilse, prototipte bildirilen türe dönüştürülür.
      </para>
    </sect3><sect3 id="glibc-Argument-Macros">
        <title>Argümana Erişim Makroları</title>
        <titleabbrev>İsteğe bağlı argümanlara erişmek için kullanılan makroların ayrıntılı belirtimi</titleabbrev>
        <para>
Burada isteğe bağlı argümanlara erişmek için kullanılan makrolar açıklanmıştır. Bu makrolar
<filename>stdarg.h</filename> başlık dosyasında tanımlıdır.
<indexterm scope="glibc-pg"><primary>stdarg.h</primary></indexterm>
        </para><para>
<indexterm scope="glibc-tp"><primary>va_list</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü" id="glibc-va_list">
<funcdef><command>va_list</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
<command>va_list</command> türü argüman gösterici değişkeni için kullanılır.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>va_start</primary></indexterm>
<funcsynopsis><funcprototype role="makro" id="glibc-va_start-">
<funcdef>void <command>va_start</command></funcdef>
<paramdef>(va_list <varname>arglist-gstr</varname>, <varname>gerekli-son-arg</varname>) </paramdef>
</funcprototype><funcdescr><para>
Bu makro, kullanıldığı işlevin ilk isteğe bağlı argümanını gösterecek olan <varname>arglist_gstr</varname> argüman gösterici değişkenini ilklendirir. <varname>gerekli-son-arg</varname> işlevdeki gerekli son argüman olmalıdır.
          </para><para>
Bu makronun bir alternatifi olarak <filename>varargs.h</filename> başlık dosyasında tanımlanmış olan <command>va_start</command> makrosu için <xref linkend="glibc-Old-Varargs"/> bölümüne bakınız.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>va_arg</primary></indexterm>
<funcsynopsis><funcprototype role="makro" id="glibc-va_arg">
<funcdef><emphasis>tür </emphasis><command>va_arg</command></funcdef>
<paramdef>(va_list <varname>arglist-gstr</varname>, <varname>tür</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu makro sonraki isteğe bağlı argümanın değeri ile döner ve <varname>arglist_gstr</varname> değişkeninin değerini sonraki argümanı gösterecek şekilde değiştirir. Böylece her <command>va_arg</command> kullanımında sırayla bir isteğe bağlı argümanın değeri alınır.
          </para><para>
<command>va_arg</command> tarafından döndürülen değerin türü çağrı sırasında <varname>tür</varname> ile belirtilir. <varname>tür</varname> argümanın türü ile eşleşen kendinden terfili bir tür olmalıdır (<command>char</command>, <command>short int</command> veya <command>float</command> değil).
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>va_end</primary></indexterm>
<funcsynopsis><funcprototype role="makro" id="glibc-va_end">
<funcdef>void <command>va_end</command></funcdef>
<paramdef>(va_list <varname>arglist-gstr</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu makro <varname>arglist_gstr</varname> kullanımını sonlandırır. Bir <command>va_end</command> çağrısından sonraki <command>va_arg</command> çağrıları bu <varname>arg_gstr</varname> ile çalışamaz. Aynı <varname>arglist_gstr</varname> argümanı için bir <command>va_start</command> çağrısı yapmadan önce bir <command>va_end</command> çağrısı yapılmalıdır.
          </para><para>
GNU C kütüphanesinde, <command>va_end</command> hiçbir şey yapmaz ve taşınabilirlik sebebi dışında kulanmanız gerekmez.
          </para></funcdescr></funcsynopsis>
        </para><para>
Kimi zaman parametre listesini defalarca çözümlemeniz gerekir ya da argümanlardan birinin listedeki konumunu hatırlamak istersiniz. Bu durumda, o anki argüman değerinin bir kopyasını yaparsınız. Ancak <command>va_list</command> şeffaf bir tür değildir ve <command>va_list</command> türünden bir değişkenin değeri başka bir değişkene atanamaz (bazı türleri sadece makrolar oluşturabilir).
        </para><para>
<indexterm scope="glibc-fn"><primary sortas="va_copy">__va_copy</primary></indexterm>
<funcsynopsis><funcprototype role="makro" id="glibc__va_copy">
<funcdef>void <command>__va_copy</command></funcdef>
<paramdef>(va_list <varname>hedef</varname>,
 va_list <varname>kaynak</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu makro, <command>va_list</command> türünden nesnelerin bir bütünleyen tür olmasa bile kopyalanmasını mümkün kılar. <varname>hedef</varname> argüman göstericisi, <varname>kaynak</varname> göstericisi ile aynı argümanı göstermek üzere ilklendirilir.
          </para><para>
Bu makro bir GNU oluşumudur ve ISO C standardının gelecek güncellemesinde ayrıca kullanılabilir olacağı umulmaktadır.
</para></funcdescr></funcsynopsis></para><para>
<command>__va_copy</command> makrosunu kullanmak isterseniz, bu makronun kullanılabilir olmayabileceği durumlara karşı hazırlıklı olmalısınız. Basit atamanın geçersiz olduğu mimarilerde <command>__va_copy</command> makrosunun bulunmakta olduğunu umarak yazılımınızda bu makroyu daima şöyle yazmalısınız:
          </para><para>
<screen>
{
  va_list ap, save;
  …
#ifdef __va_copy
  __va_copy (save, ap);
#else
  save = ap;
#endif
  …
}
</screen></para></sect3></sect2>
  <sect2 id="glibc-Variadic-Example">
    <title>Bir Değişkin İşlev Örneği</title>
    <titleabbrev>Bir eksiksiz örnek.</titleabbrev>
    <para>
Burada değişken sayıda argüman kabul eden bir işlevle ilgili tam bir örneğe yer verilmiştir. İşlevin ilk argümanı diğer argümanların sayısını içermektedir. İşlev anlamsız olsa da değişken argüman oluşumunun kullanımı hakkında fikir vermek için yeterlidir.
    </para><para>
<screen>
#include &lt;stdarg.h>
#include &lt;stdio.h>

int
topla (int miktar,...)
{
  va_list ag;
  int i, toplam;

  va_start (ag, miktar);         /* Argüman listesi ilklendiriliyor. */

  toplam = 0;
  for (i = 0; i &lt; miktar; i++)
    toplam += va_arg (ag, int);    /* Sonraki argümanın değeri alınıyor. */

  va_end (ag);                  /* Temizlik. */
  return toplam;
}

int
main (void)
{
  /* Bu çağrı 16 basar. */
  printf (&quot;%d\n&quot;, topla (3, 5, 5, 6));

  /* Bu çağrı 55 basar. */
  printf (&quot;%d\n&quot;, topla (10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10));

  return 0;
}
</screen></para>
    <sect3 id="glibc-Old-Varargs">
      <title>Eski Moda Değişkin İşlevler</title>
      <titleabbrev>Değişkin işlevlerin ISO öncesi tanımlama yolu.</titleabbrev>
      <para>
<indexterm scope="glibc-pg"><primary>varargs.h</primary></indexterm>
ISO C öncesi çağlarda yazılımcılar değişkin işlevleri yazmak için az çok farklı bir oluşum kullandılar. GNU C derleyicisi hala onu desteklemektedir; şu anda, ISO C için destek hala evrensel olmadığından, ISO C oluşumundan daha taşınabilir durumdadır. Bu eski moda değişkin işlevler oluşumu <filename>varargs.h</filename> başlık dosyasında tanımlanmıştır.
      </para><para>
<filename>varargs.h</filename> kullanımı <filename>stdarg.h</filename> kullanımı ile hemen hemen aynıdır. (Bkz. <xref linkend="glibc-Calling-Variadics"/>) Değişkin işlevlerin çağrılması açısından bir fark yoktur. Tek fark onların nasıl tanımlandığı ile igilidir. Herşeyden önce, eski moda prototipsiz sözdizimini şöyle kullanmalısınız:
     </para><para>
<screen>
tree
build (va_alist)
     va_dcl
{
</screen></para><para>
İkinci olarak, <command>va_start</command>'ı tek bir argüman ile vermelisiniz, bunun gibi:
      </para><para>
<screen>
  va_list p;
  va_start (p);
</screen></para><para>
Eski moda değişkin işlevleri tanımlamak için kullanılan özel makrolar şunlardır:
      </para><para>
<indexterm scope="glibc-fn"><primary>va_alist</primary></indexterm>
<funcsynopsis><funcprototype role="makro" id="glibc-va_alist">
<funcdef><command>va_alist</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu makro bir değişkin işlevdeki gerekli argüman isimlerinin listesi için kullanılır.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>va_dcl</primary></indexterm>
<funcsynopsis><funcprototype role="makro" id="glibc-va_dcl">
<funcdef><command>va_dcl</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu makro bir değişkin işlev için dolaylı argüman ya da argümanları bildirir.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>va_start</primary></indexterm>
<funcsynopsis><funcprototype role="makro" id="glibc-va_start">
<funcdef>void <command>va_start</command></funcdef>
<paramdef>(va_list <varname>arglist-gstr</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu makro <filename>varargs.h</filename> dosyasında tanımlanmış olarak, kullanıldığı işlevin ilk argümanını gösteren <varname>arg_gstr</varname> argüman gösterici değişkenini ilklendirir.
        </para></funcdescr></funcsynopsis>
      </para><para>
Diğer argüman makroları, <command>va_arg</command> ve  <command>va_end</command> için <filename>varargs.h</filename> ile <filename>stdarg.h</filename> kullanımları arasında fark yoktur; ayrıntılar için <xref linkend="glibc-Argument-Macros"/> bölümüne bakınız.
      </para><para>
<filename>varargs.h</filename> ile <filename>stdarg.h</filename> dosyaları aynı derleme altında birlikte kullanılamazlar, çünkü <command>va_start</command> tanımları isimleri dışında birbiriyle aynı değildir.
      </para>
    </sect3>
  </sect2>
</sect1>

<sect1 id="glibc-Null-Pointer-Constant">
  <title>Boş Gösterici Sabiti</title>
  <titleabbrev><command>NULL</command> makrosu.</titleabbrev>
  <para>
<indexterm scope="glibc-cp"><primary>boş gösterici sabiti (<literal>NULL</literal> makrosu)</primary></indexterm>
Boş gösterici sabiti herhangi bir gerçek nesneyi göstermemeyi garanti eder. <command>void *</command> türünde olduğundan onu herhangi bir gösterici değişkenine atayabilirsiniz. Bir boş gösterici sabitini yazmak için önerilen yol onu <command>NULL</command> ile belirtmektir.
  </para><para>
<indexterm scope="glibc-vr"><primary>NULL</primary></indexterm>
<funcsynopsis><funcprototype role="makro" id="glibc-NULL">
<funcdef>void * <command>NULL</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu bir boş gösterici sabitidir.
    </para></funcdescr></funcsynopsis>
  </para><para>
Ayrıca, bir boş gösterici sabiti olarak <command>0</command> veya <command>(void *)0</command> kullanabilirsiniz, ancak <command>NULL</command> kullanımı daha temizdir çünkü sabitin amacını daha net ortaya koyar.
  </para><para>
Bir boş gösterici sabitini bir işlev argümanı olarak kullanırsanız, tam taşınabilirlik açısından işlevin bir prototip bildirimi olduğundan emin olmalısınız. Aksi takdirde, hedef makine iki farklı gösterici tanımına sahipse derleyici bu argüman için hangi tanımı kullanacağını bilemeyecektir. Bu sorundan kaçınmak için açıkça bir tür dönüşümü ile sabiti doğru gösterici türüne ayarlamalısınız. Fakat biz bunu yapmak yerine çağırdığınız işlev için bir prototip eklemenizi öneririz.
  </para>
</sect1>
<sect1 id="glibc-Important-Data-Types">
  <title>Önemli Veri Türleri</title>
  <titleabbrev>Nesne boyutları için veri türleri.</titleabbrev>
  <para>
İki gösterici ile yapılan çıkartma işleminin sonucu C'de daima bir tamsayıdır, ancak doğru veri türü C derleyicisinden C derleyicisine değişir. Benzer şekilde, <command>sizeof</command>'un sonucunun veri türü de derleyiciler arasında değişiklik gösterir. ISO bu iki tür için standart isimler tanımlar, böylece bunlar kullanılarak taşınabilirlik sorunları çözülür. Bunlar <filename>stddef.h</filename> başlık dosyasında tanımlanmıştır.
<indexterm scope="glibc-pg"><primary>stddef.h</primary></indexterm>
  </para><para>
<indexterm scope="glibc-tp"><primary>ptrdiff_t</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü" id="glibc-ptrdiff_t">
<funcdef><command>ptrdiff_t</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu göstericiler arasındaki çıkartma işleminin sonucunun işaretli tamsayı türüdür. Örneğin, <command>char *p1, *p2;</command> bildirimiyle <command>p2 - p1</command> ifadesi <command>ptrdiff_t</command> türündedir. Bu şüphesiz standart işaretli tamsayı türlerinden biri (<command>short int</command>,  <command>int</command> veya <command>long int</command>) olacaktır, ancak sadece bu amaca yönelik olarak bir standart dışı tür de mevcut olabilir.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-tp"><primary>size_t</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü" id="glibc-size_t">
<funcdef><command>size_t</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu bir işaretsiz tamsayı türdür ve nesnelerin boyutları için kullanılır. <command>sizeof</command> işlecinin sonucu bu türdendir ve <link linkend="glibc-Unconstrained-Allocation"><command>malloc</command></link>, <link linkend="glibc-Copying-and-Concatenation"><command>memcpy</command></link> gibi işlevler argümanlarında nesne boyutlarını bu türde kabul ederler.
    </para><para>
<note><title>Kullanım Bilgisi:</title><para><command>size_t</command>, bir nesnenin boyutunu tutan herhangi bir değişken ya da argüman bildiriminde önerilen yoldur.</para></note>
    </para></funcdescr></funcsynopsis>
  </para><para>
GNU sisteminde <command>size_t</command> ya <command>unsigned int</command> ya da <command>unsigned long int</command> türüne eşdeğerdir. Bu iki tür GNU sisteminde eşanlamlıdır ve bir çok kullanım amacına yönelik olarak biri diğerinin yerine kullanılabilir. Yine de, onlar farklı veri türleridir ve bazı bağlamlarda veri türü olarak bir fark oluşturabilir.
  </para><para>
Örneğin, bir işlev prototipinde bir işlev argümanının türünü belirtirseniz, bunlardan diğerinin kullanımı bir fark oluşturabilir. Sistem başlık dosyasında <command>malloc</command> işlevi <command>size_t</command> türünden bir argümanla bildirilmişse ve siz onu <command>unsigned int</command> türünden bir argümanla bildirirseniz, sisteminizde <command>size_t</command> türü <command>unsigned long int</command> türüne karşılıksa derleme sırasında hata alırsınız.
  </para><para>
<note><title>Uyumluluk Bilgisi:</title><para>ISO C'den önceki C  gerçeklemeleri genellikle  nesne boyutları için <command>unsigned int</command> ve gösterici çıkartma ifadeleri için <command>int</command> türünü kullandılar, <command>size_t</command> ya da <command>ptrdiff_t</command> tanımlamak gereği duymadılar. Unix sistemleri <command>size_t</command> türünü <command>sys/types.h</command> dosyasında tanımladı ama bu tanım bir işaretli türdü.</para></note>
  </para>
</sect1>
<sect1 id="glibc-Data-Type-Measurements">
  <title>Veri Türü Ölçüleri</title>
  <titleabbrev>Veri türü parametrelerinin gösterimleri.</titleabbrev>
  <para>
Çoğu zaman, yazılımınızda her nesne için uygun bir C veri türü seçersiniz ve onun nasıl gösterildiği veya kaç bit kullandığıyla ilgilenmezsiniz. Böyle bir bilgiye ihtiyaç duyarsanız C dilinin kendisi bu bilgiyi sağlamaz. <filename>limits.h</filename> ve <filename>float.h</filename> başlık dosyaları size bu bilgiyi tüm ayrıntıları ile veren makrolar içerir.
  </para>
  <sect2 id="glibc-Width-of-Type">
    <title>Bir Tamsayı Veri Türünün Genişliğinin Hesaplanması</title>
    <titleabbrev>Bir tamsayı türü kaç bitle tutulur?</titleabbrev>
    <para>
<indexterm scope="glibc-cp"><primary>tamsayı</primary><secondary>türün genişliği</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>veri türü ölçüleri</primary><secondary>tamsayılar</secondary></indexterm>
Çok bilinen sebeplerle bir yazılım bir tamsayı türünde kaç bit bulunduğunu bilmeye ihtiyaç duyabilir. Örneğin, <command>long int</command> türünde bir diziyi bir bit vektörü olarak kullanıyorsanız, bitlere <varname>n</varname> indisi ile aşağıdaki gibi erişebilirsiniz:
    </para><para>
<screen>
vector[<varname>n</varname> / LONGBITS] &amp; (1 &lt;&lt; (<varname>n</varname> % LONGBITS))
</screen></para><para>
Burada <command>LONGBITS</command>, bir <command>long int</command> içindeki bitlerin sayısı olarak tanımlanmış olmalıdır.
    </para><para>
<indexterm scope="glibc-pg"><primary>limits.h</primary></indexterm>
C dilinde bir tamsayı veri türündeki bitlerin sayısını verecek bir işleç yoktur. Fakat onu, <filename>limits.h</filename> başlık dosyasında tanımlanmış olan <command>CHAR_BIT</command> makrosuyla hesaplayabilirsiniz.
    </para><para>
      <variablelist><varlistentry><term><command>CHAR_BIT</command></term>
        <listitem><para>
Bir <command>char</command> içindeki bitlerin sayısıdır. Birçok sistemde değeri sekizdir ve bu değer <command>int</command> türündendir.
        </para><para>
<varname>tür</varname> ile belirtilecek herhangi bir veri türünün bitlerinin sayısını şöyle hesaplayabilirsiniz:
        </para><para>
<screen>sizeof (<varname>tür</varname>) * CHAR_BIT</screen>
        </para></listitem>
      </varlistentry></variablelist>
    </para>
  </sect2><sect2 id="glibc-Range-of-Type">
    <title>Bir Tamsayı Türün Aralığı</title>
    <titleabbrev>Bir tamsayı türün tutabileceği en küçük ve en büyük değer nedir?</titleabbrev>
    <para>
<indexterm scope="glibc-cp"><primary>tamsayı</primary><secondary>tür aralığı</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>sınırlar</primary><secondary>tamsayı türler</secondary></indexterm>
Varsayalım ki, sıfırdan bir milyona kadar bir aralıktaki tamsayı değerleri saklamak istiyorsunuz. Kullanabileceğiniz en küçük tür hangisidir? Bunun için genel bir kural yoktur; C derleyicisine ve hedef makineye bağlıdır. Hangi tür ile çalışacağınızı bulmak için <filename>limits.h</filename> başlık dosyasında tanımlanmış olan <command>MIN</command> ve <command>MAX</command> makrolarını kullanabilirsiniz.
    </para><para>
Her işaretli tamsayı türü için tutabileceği en küçük ve en büyük değerleri veren bir çift makro vardır. Her işaretsiz tamsayı türü içinde böyle makrolar vardır; en büyük değer için, en küçük değer yani sıfır için.
    </para><para>
Bu makroların değerlerinin hepsi tamsayı sabit ifadeleridir. <command>char</command> ve <command>short int</command> için <command>MAX</command> ve <command>MIN</command> makroları <command>int</command> türünden değerlere sahiptir. Diğer türlerin <command>MAX</command> ve <command>MIN</command> makrolarının değerleri de makro tarafından açıklanmış aynı türde değerlerdir. Örneğin, <command>ULONG_MAX</command> makrosunun değeri <command>unsigned long int</command> türündendir.
    </para><para>
      <variablelist><varlistentry><term id="glibc-SCHAR_MIN">
<command>SCHAR_MIN</command>
<indexterm scope="glibc-vr"><primary>SCHAR_MIN</primary></indexterm>
      </term><listitem><para>
Bir <command>signed char</command> tarafından tutulabilen en küçük değerdir.
      </para></listitem></varlistentry><varlistentry><term id="glibc-SCHAR_MAX">
<command>SCHAR_MAX</command>
<indexterm scope="glibc-vr"><primary>SCHAR_MAX</primary></indexterm>
      </term><term id="glibc-UCHAR_MAX">
<command>UCHAR_MAX</command>
<indexterm scope="glibc-vr"><primary>UCHAR_MAX</primary></indexterm>
      </term><listitem><para>
Sırasıyla <command>signed char</command> ve <command>unsigned char</command> tarafından tutulabilen en büyük değerlerdir.
      </para></listitem></varlistentry><varlistentry><term id="glibc-CHAR_MIN">
<command>CHAR_MIN</command>
<indexterm scope="glibc-vr"><primary>CHAR_MIN</primary></indexterm>
      </term><listitem><para>
Bir <command>char</command> tarafından tutulabilen en küçük değerdir. <command>char</command> işaretli ise <command>SCHAR_MIN</command>'e eşittir, yoksa sıfırdır.
      </para></listitem></varlistentry><varlistentry><term id="glibc-CHAR_MAX">
<command>CHAR_MAX</command>
<indexterm scope="glibc-vr"><primary>CHAR_MAX</primary></indexterm>
      </term><listitem><para>
Bir <command>char</command> tarafından tutulabilen en büyük değerdir. <command>char</command> işaretli ise <command>SCHAR_MAX</command>'a eşittir, yoksa <command>UCHAR_MAX</command>'a eşittir.
      </para></listitem></varlistentry><varlistentry><term id="glibc-SHRT_MIN">
<command>SHRT_MIN</command>
<indexterm scope="glibc-vr"><primary>SHRT_MIN</primary></indexterm>
      </term><listitem><para>
Bir <command>signed short int</command> tarafından tutulabilen en küçük değerdir. GNU C kütüphanesinin çalıştığı çoğu makinede <command>short</command> tamsayılar 16 bit genişliktedir.
      </para></listitem></varlistentry><varlistentry><term id="glibc-SHRT_MAX">
<command>SHRT_MAX</command>
<indexterm scope="glibc-vr"><primary>SHRT_MAX</primary></indexterm>
      </term><term id="glibc-USHRT_MAX">
<command>USHRT_MAX</command>
<indexterm scope="glibc-vr"><primary>USHRT_MAX</primary></indexterm>
      </term><listitem><para>
Sırasıyla <command>signed short int</command> ve  <command>unsigned short int</command> tarafından tutulabilen en büyük değerlerdir.
      </para></listitem></varlistentry><varlistentry><term id="glibc-INT_MIN">
<command>INT_MIN</command>
<indexterm scope="glibc-vr"><primary>INT_MIN</primary></indexterm>
      </term><listitem><para>
Bir <command>signed int</command> tarafından tutulabilen en küçük  değerdir. GNU C kütüphanesinin çalıştığı çoğu makinede <command>int</command> tamsayılar 32 bit genişliktedir.
      </para></listitem></varlistentry><varlistentry><term id="glibc-INT_MAX">
<command>INT_MAX</command>
<indexterm scope="glibc-vr"><primary>INT_MAX</primary></indexterm>
      </term><term id="glibc-UINT_MAX">
<command>UINT_MAX</command>
<indexterm scope="glibc-vr"><primary>UINT_MAX</primary></indexterm>
      </term><listitem><para>
Sırasıyla <command>signed int</command> ve <command>unsigned int</command> tarafından tutulabilen en büyük değerlerdir.
      </para></listitem></varlistentry><varlistentry><term id="glibc-LONG_MIN">
<command>LONG_MIN</command>
<indexterm scope="glibc-vr"><primary>LONG_MIN</primary></indexterm>
      </term><listitem><para>
Bir <command>signed long int</command> tarafından tutulabilen en küçük değerdir. GNU C kütüphanesinin çalıştığı çoğu makinede <command>long</command> tamsayılar <command>int</command> ile aynı olarak 32 bit genişliktedir.
      </para></listitem></varlistentry><varlistentry><term id="glibc-LONG_MAX">
<command>LONG_MAX</command>
<indexterm scope="glibc-vr"><primary>LONG_MAX</primary></indexterm>
      </term><term id="glibc-ULONG_MAX">
<command>ULONG_MAX</command>
<indexterm scope="glibc-vr"><primary>ULONG_MAX</primary></indexterm>
      </term><listitem><para>
Sırasıyla <command>signed long int</command> ve <command>unsigned long int</command> tarafından tutulabilen en büyük değerlerdir.
      </para></listitem></varlistentry><varlistentry><term id="glibc-LONG_LONG_MIN">
<command>LONG_LONG_MIN</command>
<indexterm scope="glibc-vr"><primary>LONG_LONG_MIN</primary></indexterm>
      </term><listitem><para>
 Bir <command>signed long long int</command> tarafından tutulabilen en küçük değerdir. GNU C kütüphanesinin çalıştığı çoğu makinede <command>long long</command> tamsayılar 64 bit genişliktedir.
      </para></listitem></varlistentry><varlistentry><term id="glibc-LONG_LONG_MAX">
<command>LONG_LONG_MAX</command>
<indexterm scope="glibc-vr"><primary>LONG_LONG_MAX</primary></indexterm>
      </term><term id="glibc-ULONG_LONG_MAX">
<command>ULONG_LONG_MAX</command>
<indexterm scope="glibc-vr"><primary>ULONG_LONG_MAX</primary></indexterm>
      </term><listitem><para>
Sırasıyla <command>signed long long int</command> ve <command>unsigned long long int</command> tarafından tutulabilen en büyük değerlerdir.
      </para></listitem></varlistentry><varlistentry><term id="glibc-WCHAR_MAX-">
<command>WCHAR_MAX</command>
<indexterm scope="glibc-vr"><primary>WCHAR_MAX</primary></indexterm>
      </term><listitem><para>
Bir <command>wchar_t</command> tarafından tutulabilen en büyük değerdir. Bkz.  <xref linkend="glibc-Extended-Char-Intro"/>.
      </para></listitem></varlistentry></variablelist>
    </para><para>
<filename>limits.h</filename> başlık dosyası ayrıca işletim sistemi ve dosya sistemi sınırlarını belirleyen bazı sabitler de bulunmaktadır. Bu sabitler <xref linkend="glibc-System-Configuration"/> bölümünde açıklanmıştır.
    </para>
  </sect2><sect2 id="glibc-Floating-Type-Macros">
    <title>Gerçek Sayı Türü Makroları</title>
    <titleabbrev>Gerçek sayı türlerini ölçümlemede kullanılan makrolar.</titleabbrev>
    <para>
<indexterm scope="glibc-cp"><primary>gerçek sayılar</primary><secondary>türün genişliği</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>veri türü olçüleri</primary><secondary>gerçek sayılar</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>sınırlar</primary><secondary>gerçek sayı türler</secondary></indexterm>
Gerçek sayılara özel gösterim makineden makineye değişir. Çünkü gerçek sayılar dahili olarak yaklaşık niceliklerle gösterilir. Gerçek sayı verilerle çalışan algoritmalar çoğunlukla makinenin doğru gerçek sayı gösterim ayrıntılarına dikkat etmeyi gerektirir.
    </para><para>
C kütüphanesindeki bazı işlevlerin kendileri bu bilgiye gereksinim duyar; örneğin, gerçek sayıları okumak ve basmak (Bkz. <xref linkend="glibc-I-O-on-Streams"/>) için ve trigonometrik ve gerçel işlevlerin (Bkz. <xref linkend="glibc-Mathematics"/>)  hesaplanmasında kullanılan algoritmalar yuvarlama hatalarından ve hassasiyet kayıplarından kaçınmak için bunu kullanır. Sayısal analiz teknikleri gerçekleştiren bazı kullanıcı yazılımları da çoğunlukla hata sınırlarının küçültmesi ya da hesaplanması sırasında bu bilgiye ihtiyaç duyar.
    </para><para>
<filename>float.h</filename> başlık dosyası makinenizde kullanılan biçimi açıklar.
    </para>
    <sect3 id="glibc-Floating-Point-Concepts">
      <title>Gerçek Sayı Gösterimi ile İlgili Kavramlar</title>
      <titleabbrev>Terminoloji.</titleabbrev>
      <para>
<dicterm><english>base</english><turkish>taban (sayılar)</turkish></dicterm>
<dicterm><english>radix</english><turkish>taban (sayılar)</turkish></dicterm>
<dicterm><english>exponent</english><turkish>üstel kısım (sayılar)</turkish></dicterm>
<dicterm><english>mantissa</english><turkish>ondalık kısım (sayılar)</turkish></dicterm>
<dicterm><english>significant</english><turkish>ondalık kısım (sayılar)</turkish></dicterm>

Bu bölümde gerçek sayı gösterimleri ile ilgili terminolojiye değinilmiştir.
      </para><para>
Büyük ihtimalle gerçek sayılar için üstel gösterim veya bilimsel terimler olarak bu kavramların çoğuna zaten aşinasınızdır. Örneğin <command>123456.0</command> sayısı üstel olarak <command>1.23456e+05</command> biçiminde, <command>1.23456</command> sayısı ile  <command>10</command> üssü <command>5</command>'in çarpımı olarak gösterilir.
      </para><para>
Daha biçimsel olarak, gerçek sayıların bit gösterimi aşağıdaki terimlerle karakterize edilebilir:
      </para><para>
        <itemizedlist><listitem><para>
<indexterm scope="glibc-cp"><primary>gerçek sayıların bit gösterimi</primary><secondary>işaret biti</secondary></indexterm>
<wordasword>İşaret biti</wordasword> ya <command>-1</command> ya da <command>1</command>'dir.
        </para></listitem><listitem><para>
<indexterm scope="glibc-cp"><primary>gerçek sayıların bit gösterimi</primary><secondary>taban</secondary></indexterm>
Üs alma için <wordasword>taban</wordasword>,  <command>1</command>'den büyük bir tamsayıdır. Belirli bir gösterim için bu bir sabittir.
        </para></listitem><listitem><para>
<indexterm scope="glibc-cp"><primary>gerçek sayıların bit gösterimi</primary><secondary>üstel kısım</secondary></indexterm>
<wordasword>Üstel kısım</wordasword> tabanın kendisiyle kaç defa çarpılacağını gösterir.  Bir belirli gösterim için üs değerinin alt ve üst sınırları birer sabittir.
        </para><para>
Kimi zaman gerçek sayının bit gösteriminde üssü ifade eden kısım bir sabit eklenmesiyle daima işaretsiz bir nicelik yapılır. Bu sadece bit alanlarını ayırıp gerçek sayıyı kendiniz oluşturmak isterseniz önemli olur, ancak GNU kütüphanesinde böyle bir işlem için destek yoktur.
        </para></listitem><listitem><para>
<indexterm scope="glibc-cp"><primary>gerçek sayıların bit gösterimi</primary><secondary>ondalık kısım</secondary></indexterm>
<wordasword>Ondalık kısım</wordasword> her gerçek sayının bir parçası olan bir işaretsiz tamsayıdır.
        </para></listitem><listitem><para>
<indexterm scope="glibc-cp"><primary>gerçek sayıların bit gösterimi</primary><secondary>hassasiyet</secondary></indexterm>
Ondalık kısmın <wordasword>hassasiyet</wordasword>i. Eğer bit gösteriminde taban <varname>b</varname> ise hassasiyet, ondalık kısmın taban-<varname>b</varname> sayıda basamağıdır. Bu belirli bir gösterim için bir sabittir.
        </para><para>
<indexterm scope="glibc-cp"><primary>gerçek sayıların bit gösterimi</primary><secondary>gizli bit</secondary></indexterm>
Birçok gerçek sayı gösterimi ondalık kısım içinde bir örtük <wordasword>gizli bit</wordasword> içerir. Bu ondalık kısım içinde olduğu varsayılan bir bittir ancak bellekte saklanmaz, çünkü bir normalleştirilmiş sayı içinde daima 1 dir. Hassasiyet ile ilgili kısım kendi içinde çok sayıda gizli bit içerebilir.
        </para><para>
Tekrar belirtelim, GNU kütüphanesi gerçek sayıların düşük seviye (ikilik tabandaki bit gösterimi) gösterimleri ile ilgili oluşumlara destek sağlamamaktadır.
        </para></listitem></itemizedlist>
      </para><para>
<dicterm><english>fraction</english><turkish>kesir</turkish></dicterm>
<dicterm><english>denominator</english><turkish>payda</turkish></dicterm>
Bir gerçek sayının bit gösterimindeki ondalık kısım dolaylı olarak paydası üstel taban hassasiyetteki bir kesri ifade eder. Bu ondalık kısım ile gösterilebilecek en büyük sayı bu paydadan bir eksiği olduğundan kesrin değeri daima birden küçüktür. Bu bit gösteriminin matematiksel değeri bu kesir ile işaret ve üstel tabanın çarpımıdır.
      </para><para>
<indexterm scope="glibc-cp"><primary>normalleştirilmiş gerçek sayı</primary></indexterm>
<note><para>Ç.N. - Özgün metinde burada anlatılan biraz karışık olmuş. Kafa karıştırmamak için çevirmedim. Basitçe ifade etmek gerekirse 32 bitlik gerçek sayı gösterimiyle ifade  edilebilecek en küçük değer <literal>2<superscript>-149</superscript></literal>  olsa da bu sayı <command>float</command> türü için  <literal>2<superscript>-126</superscript></literal> olarak normalleştirilmiştir. En azından GNU C kütüphanesinde bu böyle.
 </para></note>
      </para>
    </sect3><sect3 id="glibc-Floating-Point-Parameters">
      <title>Gerçek Sayılar ile İlgili Makrolar</title>
      <titleabbrev>Bu sayılara özgü makroların açıklamaları.</titleabbrev>
      <para>
<indexterm scope="glibc-pg"><primary>float.h</primary></indexterm>
Bu makroların tanımlarını <filename>float.h</filename> başlık dosyasında bulabilirsiniz.
      </para><para>
<dicterm><english>floating point numbers</english><turkish>gerçek sayılar</turkish></dicterm>
<command>FLT_</command> ile başlayan makro isimleri <command>float</command> türü ile, <command>DBL_</command> ile başlayanlar <command>double</command> türü ile ve <command>LDBL_</command> ile başlayanlar da <command>long double</command> türü ile ilgilidir. (GCC hedef makinede bir veri türü olarak <command>long double</command> türünü desteklemezse, <command>LDBL_</command> ile başlayan sabitler <command>double</command> türüne karşılık olan sabitlere eşitlenir.)
      </para><para>
Bu makrolardan sadece <command>FLT_RADIX</command> bir sabit ifadesi olarak garantilidir. Burada listelenmiş diğer sabitler <command>#if</command> önişlemci komutu ya da durağan dizilerin boyutları gibi yerlerde sabit ifadesi olarak güvenilir olamaz.
      </para><para>
ISO C standardı bu parametrelerin en küçük ve en büyük değerlerini belirtse de, GNU C gerçeklemesi hedef makinede desteklenen gerçek sayı gösterimlerini açıklayan değerleri kullanır. Yani GNU C prensip olarak ISO C gereksinimlerini hedef makinenin yapabildiği kadarıyla karşılar. Uygulamada tüm makinelerde bu destekler zaten vardır.
      </para><para>
        <variablelist><varlistentry><term>
<command>FLT_ROUNDS</command>
        </term><listitem><para>
Bu değer gerçek sayı toplamasında yuvarlama kipini belirler. Standart yuvarlama kiplerinin değerleri:
        </para><para>
<variablelist><varlistentry><term><command>-1</command></term>
  <listitem><para>Bu kip belirlenebilir değildir.</para></listitem>
</varlistentry><varlistentry><term><command>0</command></term>
  <listitem><para>Sıfıra yuvarlar.</para></listitem>
</varlistentry><varlistentry><term><command>1</command></term>
  <listitem><para>En yakın sayıya yuvarlar.</para></listitem>
</varlistentry><varlistentry><term><command>2</command></term>
  <listitem><para>Pozitif sonsuza yuvarlar.</para></listitem>
</varlistentry><varlistentry><term><command>3</command></term>
  <listitem><para>Negatif sonsuza yuvarlar.</para></listitem>
</varlistentry></variablelist>
        </para><para>
Diğer değerler, eğer varsa, makine bağımlı standart dışı yuvarlama kiplerini belirtir.
        </para><para>
Gerçek sayılar için IEEE standardı gereğince çoğu makinede <command>1</command> değeri kullanılır.
        </para><para>
<dicterm><english>single-precision</english><turkish>tek hassasiyetli</turkish></dicterm>
<dicterm><english>double-precision</english><turkish>çift hassasiyetli</turkish></dicterm>
Aşağıdaki tabloda <command>FLT_ROUNDS</command> sabitinin olası değerleri ile yuvarlamanın nasıl yapıldığı gösterilmiştir. Yuvarlama IEEE tek hassasiyetli gerçek sayılar standardına uygun olarak yapılmıştır.
        </para><para>
<screen>
                0      1             2             3
 1.00000003    1.0    1.0           1.00000012    1.0
 1.00000007    1.0    1.00000012    1.00000012    1.0
-1.00000003   -1.0   -1.0          -1.0          -1.00000012
-1.00000007   -1.0   -1.00000012   -1.0          -1.00000012
</screen>
        </para></listitem></varlistentry><varlistentry><term>
<command>FLT_RADIX</command>
        </term><listitem><para>
Bit gösteriminde üstel kısmın tabanına karşılık gelen değerdir. Bu bölümde açıklanan diğer makroların aksine bir sabit ifadesi olarak garantilidir. IBM 360 ve türevleri dışında bilinen tüm makineler için değeri 2 dir.
        </para></listitem></varlistentry><varlistentry><term>
<command>FLT_MANT_DIG</command>
        </term><listitem><para>
<dicterm><english>decimal digits</english><turkish>ondalık basamaklar</turkish></dicterm>
<command>float</command> veri türü için gerçek sayının ondalık kısmındaki taban-<command>FLT_RADIX</command> basamağın basamak sayısıdır. Aşağıdaki ifade ondalık kısım basamaklarının sınırlı olmasından dolayı <command>1.0</command>'a gider (matematiksel olarak olmasada):
        </para><para>
<screen>
float radix = FLT_RADIX;

1.0f + 1.0f / radix / radix / … / radix
</screen></para><para>
Burada <command>radix</command>, <command>FLT_MANT_DIG</command> kere uygulanır.
        </para></listitem></varlistentry><varlistentry><term>
<command>DBL_MANT_DIG</command>
        </term><term>
<command>LDBL_MANT_DIG</command>
        </term><listitem><para>
Sırasıyla <command>double</command>  ve <command>long double</command> veri türleri için gerçek sayının ondalık kısmındaki taban-<command>FLT_RADIX</command> basamağın basamak sayısıdır.
        </para></listitem></varlistentry><varlistentry><term>
<command>FLT_DIG</command>
        </term><listitem><para>
<command>float</command> türü için hassasiyeti belirleyen ondalık basamakların sayısıdır. Teknik olarak <varname>h</varname> ve <varname>i</varname> sırasıyla ikilik gösterimdeki hassasiyet ve taban ise ve ondalık basamakların sayısı <varname>o</varname> onluk gösterimdeki hassasiyet ise, örneğin, 10 tabanındaki <varname>o</varname> basamaklı bir gerçek sayı <varname>b</varname> tabanındaki <varname>h</varname> basamağa yuvarlanır ve <varname>o</varname> ondalık basamak sayısı değiştirilmeksizin tekrar geri alınır.
        </para><para>
Bu makronun değerinin ISO C gereksinimlerini karşılamak üzere en azından <command>6</command> olacağı varsayılır.
        </para></listitem></varlistentry><varlistentry><term>
<command>DBL_DIG</command>
        </term><term>
<command>LDBL_DIG</command>
        </term><listitem><para>
<command>FLT_DIG</command>'e benzerler ancak sırasıyla <command>double</command> ve <command>long double</command> veri türleri içindir. Bu makroların değerlerinin en azından <command>10</command>  olacağı varsayılır.
        </para></listitem></varlistentry><varlistentry><term>
<command>FLT_MIN_EXP</command>
        </term><listitem><para>
 <command>float</command> türü için ikilik gösterimdeki mümkün en küçük üs değeridir. Daha ayrıntılı ifade etmek gerekirse, <command>float</command> türündeki normalleştirilmiş bir gerçek sayı olarak <command>FLT_RADIX</command> değerinin bu değerden bir eksiğinin artan kuvvetlerinden elde edilebilecek en küçük değerini sağlayacak olan en küçük negatif tamsayıdır. (Pratikte <command>float</command> türü için en küçük değer <literal>2<superscript>-125-1</superscript></literal> dir ve burada  <command>FLT_MIN_EXP</command> <literal>-125</literal> tir.)
        </para></listitem></varlistentry><varlistentry><term>
<command>DBL_MIN_EXP</command>
        </term><term>
<command>LDBL_MIN_EXP</command>
        </term><listitem><para>
<command>FLT_MIN_EXP</command>'e benzerler ancak sırasıyla <command>double</command> ve <command>long double</command> veri türleri içindir.
        </para></listitem></varlistentry><varlistentry><term>
<command>FLT_MIN_10_EXP</command>
        </term><listitem><para>
<command>float</command> türü için onluk tabanda üssün en küçük negatif değeri olan bir tamsayıdır. Normalleştirilmiş gerçek sayıların mümkün en küçük değeri için <command>10</command>'un bu değerden 1 eksiği artan kuvvetindeki değerine karşılıktır. Bu değerin <command>-37</command> veya daha az olduğu varsayılır.
        </para></listitem></varlistentry><varlistentry><term>
<command>DBL_MIN_10_EXP</command>
        </term><term>
<command>LDBL_MIN_10_EXP</command>
        </term><listitem><para>
<command>FLT_MIN_10_EXP</command>'e benzerler ancak sırasıyla <command>double</command> ve <command>long double</command> veri türleri içindir.
        </para></listitem></varlistentry><varlistentry><term>
<command>FLT_MAX_EXP</command>
        </term><listitem><para>
<command>float</command> türü için ikilik gösterimdeki mümkün en büyük üs değeridir. Daha ayrıntılı ifade etmek gerekirse, <command>float</command> türündeki normalleştirilmiş bir gerçek sayı olarak <command>FLT_RADIX</command> değerinin bu değerden bir eksiğinin artan kuvvetlerinden elde edilebilecek en büyük değerini sağlayacak olan en büyük pozitif tamsayıdır.
        </para></listitem></varlistentry><varlistentry><term>
<command>DBL_MAX_EXP</command>
        </term><term>
<command>LDBL_MAX_EXP</command>
        </term><listitem><para>
<command>FLT_MAX_EXP</command>'e benzerler ancak sırasıyla <command>double</command> ve <command>long double</command> veri türleri içindir.
        </para></listitem></varlistentry><varlistentry><term>
<command>FLT_MAX_10_EXP</command>
        </term><listitem><para>
<command>float</command> türü için onluk tabanda üssün en büyük değeri olan bir pozitif tamsayıdır. Normalleştirilmiş gerçek sayıların mümkün en küçük değeri için <command>10</command>'un bu değerden 1 eksiği artan kuvvetindeki değerine karşılıktır. Bu değerin en azından <command>37</command> olduğu varsayılır.
        </para></listitem></varlistentry><varlistentry><term>
<command>DBL_MAX_10_EXP</command>
        </term><term>
<command>LDBL_MAX_10_EXP</command>
        </term><listitem><para>
<command>FLT_MAX_10_EXP</command>'e benzerler ancak sırasıyla <command>double</command> ve <command>long double</command> veri türleri içindir.
        </para></listitem></varlistentry><varlistentry><term>
<command>FLT_MAX</command>
        </term><listitem><para>
Bu makronun değeri <command>float</command> türünde ifade edilebilecek en büyük gerçek sayının değeridir. Bu değerin en azından <command>1E+37</command> olacağı varsayılır ve bu değer <command>float</command> türündendir.
        </para><para>
İfade edilebilir en küçük sayı ise <command>- FLT_MAX</command>'tır.
        </para></listitem></varlistentry><varlistentry><term>
<command>DBL_MAX</command>
        </term><term>
<command>LDBL_MAX</command>
        </term><listitem><para>
<command>FLT_MAX</command>'e benzerler ancak sırasıyla <command>double</command> ve <command>long double</command> veri türleri içindir. Makro değerinin veri türü kendi türü ile aynıdır.
        </para></listitem></varlistentry><varlistentry><term>
<command>FLT_MIN</command>
        </term><listitem><para>
Bu makronun değeri <command>float</command> türünde ifade edilebilecek en küçük gerçek sayının değeridir. Bu değerin <command>1E-37</command>'den daha büyük olmayacağı varsayılır ve bu değer <command>float</command> türündendir.
        </para></listitem></varlistentry><varlistentry><term>
<command>DBL_MIN</command>
        </term><term>
<command>LDBL_MIN</command>
        </term><listitem><para>
<command>FLT_MIN</command>'e benzerler ancak sırasıyla <command>double</command> ve <command>long double</command> veri türleri içindir. Makro değerinin veri türü kendi türü ile aynıdır.
        </para></listitem></varlistentry><varlistentry><term>
<command>FLT_EPSILON</command>
        </term><listitem><para>
<command>1.0 + FLT_EPSILON != 1.0</command> gibi bir ifadeyi doğrulayan <command>float</command> türündeki en küçük pozitif gerçek sayıdır. <command>1E-5</command>'den büyük olmayacağı varsayılır.
        </para></listitem></varlistentry><varlistentry><term>
<command>DBL_EPSILON</command>
        </term><term>
<command>LDBL_EPSILON</command>
        </term><listitem><para>
<command>FLT_MIN</command>'e benzerler ancak sırasıyla <command>double</command> ve <command>long double</command> veri türleri içindir. Makro değerinin veri türü kendi türü ile aynıdır. Bu değerlerin <command>1E-9</command>'dan daha büyük olmayacağı varsayılır.
        </para></listitem></varlistentry></variablelist>
      </para>
    </sect3><sect3 id="glibc-IEEE-Floating-Point">
      <title>IEEE Gerçek Sayı Gösterimleri</title>
      <titleabbrev>Bir ortak gösterim için ölçüler.</titleabbrev>
      <para>
<indexterm scope="glibc-cp"><primary>IEEE gerçek sayı gösterimleri</primary></indexterm>
<indexterm scope="glibc-cp"><primary>gerçek sayıların bit gösterimi</primary><secondary>IEEE</secondary></indexterm>
Burada, en genel gerçek sayı gösterimi olan  <citation>IEEE Standard for Binary Floating Point Arithmetic (ANSI/IEEE Std 754-1985)</citation> tarafından belirtilmiş gerçek sayı metrikleri için bir örnek gösterilmektedir. 1980 lerden sonra tasarlanan tüm bilgisayarlar bu biçimi kullanır.
      </para><para>
IEEE tek hassasiyetli gerçek sayı biçimi ikilik tabanı kullanır. Bir işaret biti, 23 artı bir gizli bit olmak üzere (yani toplam hassasiyet 24 taban-2 basamak) 24 bitlik ondalık kısım ile  -125 ile 128 aralığındaki üs değerleri için 8 bitlik üstel kısımdan oluşan bir gösterim sunar.
      </para><para>
Bu gösterimin <command>float</command> veri türünü gerçeklemekte kullanılan ilgili değerleri aşağıda gösterilmiştir.
      </para><para>
<screen>
FLT_RADIX                             2
FLT_MANT_DIG                         24
FLT_DIG                               6
FLT_MIN_EXP                        -125
FLT_MIN_10_EXP                      -37
FLT_MAX_EXP                         128
FLT_MAX_10_EXP                      +38
FLT_MIN                 1.17549435E-38F
FLT_MAX                 3.40282347E+38F
FLT_EPSILON             1.19209290E-07F
</screen></para><para>
Bunlar da <command>double</command> veri türü içindir:
     </para><para>
<screen>
DBL_MANT_DIG                         53
DBL_DIG                              15
DBL_MIN_EXP                       -1021
DBL_MIN_10_EXP                     -307
DBL_MAX_EXP                        1024
DBL_MAX_10_EXP                      308
DBL_MAX         1.7976931348623157E+308
DBL_MIN         2.2250738585072014E-308
DBL_EPSILON     2.2204460492503131E-016
</screen></para>
    </sect3>
  </sect2><sect2 id="glibc-Structure-Measurement">
    <title>Yapı Alanı Konum Ölçüleri</title>
    <titleabbrev>Yapı türleri üzerinden ölçü alınması.</titleabbrev>
    <para>
Bir yapı içindeki bir yapı üyesinin konumunu <command>offsetof</command> kullanarak bulabilirsiniz.
    </para><para>
<indexterm scope="glibc-fn"><primary>offsetof</primary></indexterm>
<funcsynopsis><funcprototype role="makro" id="glibc-offsetof">
<funcdef>size_t <command>offsetof</command></funcdef>
<paramdef>(<varname>tür</varname>, <varname>üye</varname>)</paramdef>
</funcprototype><funcdescr><para>
İşlev, <varname>tür</varname> türündeki yapının <varname>üye</varname> isimli üyesinin konumunu bir tamsayı sabit olarak döndürür. Örneğin <command>offsetof (struct s, elem)</command> ifadesi, <command>struct s</command> içindeki <command>elem</command> üyesinin bayt cinsinden başlangıç konumunu verir.
      </para><para>
Bu makro, <varname>üye</varname> bir bit alanı ise çalışmayacaktır. Bu durumda C derleyicisinden bir hata alırsınız.
      </para></funcdescr></funcsynopsis></para>
    </sect2>
  </sect1>
</appendix>
