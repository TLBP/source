<?xml version="1.0" encoding="UTF-8"?>
<!-- ********************************************************************
        glibc/ch16.xml,v2.36, GFDL,LGPL, NBB, 2023
     ******************************************************************** -->
<part xml:id="glibc-Sockets">
 <title>Soketler</title>
 <titleabbrev>Ağ destekli, biraz daha karmaşık, süreçler arası iletişim düzeneği.</titleabbrev>
 <preliminary>
  <para>This chapter describes the GNU facilities for interprocess
communication using sockets.
  </para>
  <para>
   <indexterm linkend="glibc-cp"><primary>soketler</primary></indexterm>
   <indexterm linkend="glibc-cp"><primary>soketler</primary><secondary>süreçlerarası iletişim</secondary></indexterm>
   A <emphasis>socket</emphasis> is a generalized interprocess communication channel.
Like a pipe, a socket is represented as a file descriptor.  Unlike pipes
sockets support communication between unrelated processes, and even
between processes running on different machines that communicate over a
network.  Sockets are the primary means of communicating with other
machines; <code>telnet</code>, <code>rlogin</code>, <code>ftp</code>, <code>talk</code> and the
other familiar network programs use sockets.
</para>
<para>Not all operating systems support sockets.  In the GNU C Library, the
header file <filename>sys/socket.h</filename> exists regardless of the operating
system, and the socket functions always exist, but if the system does
not really support sockets these functions always fail.
<dicterm><english>broadcast messages</english><turkish>yayın iletileri</turkish></dicterm>
<dicterm><english>header file</english><turkish>başlık dosyası</turkish></dicterm>
</para>
  <note><title>Eksik Bilgi:</title>
   <para>
    Yayın iletileri veya Internet arayüzünün ayarlanması ile ilgili oluşumlar henüz belgelenmemiştir. IPv6 ile ilgili bazı yeni işlevler ve evresel (reentrant) işlevler de henüz belgelenmemiştir.
   </para>
  </note>
 </preliminary><!--
<sect xml:id="glibc-Socket-Concepts">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Communication-Styles" accesskey="n" rel="next">Communication Styles</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Sockets" accesskey="u" rel="up">Sockets</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Socket-Concepts-1"></span><h3 class="section">16.1 Socket Concepts</title>

<span xml:id="glibc-index-communication-style-_0028of-a-socket_0029"></span>
<span xml:id="glibc-index-style-of-communication-_0028of-a-socket_0029"></span>
<para>When you create a socket, you must specify the style of communication
you want to use and the type of protocol that should implement it.
The <emphasis>communication style</emphasis> of a socket defines the user-level
semantics of sending and receiving data on the socket.  Choosing a
communication style specifies the answers to questions such as these:
</para>
<ul>
<li> <span xml:id="glibc-index-packet"></span>
<span xml:id="glibc-index-byte-stream"></span>
<span xml:id="glibc-index-stream-_0028sockets_0029"></span>
<strong>What are the units of data transmission?</strong>  Some communication
styles regard the data as a sequence of bytes with no larger
structure; others group the bytes into records (which are known in
this context as <emphasis>packets</emphasis>).

</li><li> <span xml:id="glibc-index-loss-of-data-on-sockets"></span>
<span xml:id="glibc-index-data-loss-on-sockets"></span>
<strong>Can data be lost during normal operation?</strong>  Some communication
styles guarantee that all the data sent arrives in the order it was
sent (barring system or network crashes); other styles occasionally
lose data as a normal part of operation, and may sometimes deliver
packets more than once or in the wrong order.

<para>Designing a program to use unreliable communication styles usually
involves taking precautions to detect lost or misordered packets and
to retransmit data as needed.
</para>
</li><li> <strong>Is communication entirely with one partner?</strong>  Some
communication styles are like a telephone call—you make a
<emphasis>connection</emphasis> with one remote socket and then exchange data
freely.  Other styles are like mailing letters—you specify a
destination address for each message you send.
</li></ul>

<span xml:id="glibc-index-namespace-_0028of-socket_0029"></span>
<span xml:id="glibc-index-domain-_0028of-socket_0029"></span>
<span xml:id="glibc-index-socket-namespace"></span>
<span xml:id="glibc-index-socket-domain"></span>
<para>You must also choose a <emphasis>namespace</emphasis> for naming the socket.  A socket
name (“address”) is meaningful only in the context of a particular
namespace.  In fact, even the data type to use for a socket name may
depend on the namespace.  Namespaces are also called “domains”, but we
avoid that word as it can be confused with other usage of the same
term.  Each namespace has a symbolic name that starts with ‘<filename>PF_</filename>’.
A corresponding symbolic name starting with ‘<filename>AF_</filename>’ designates the
address format for that namespace.
</para>
<span xml:id="glibc-index-network-protocol"></span>
<span xml:id="glibc-index-protocol-_0028of-socket_0029"></span>
<span xml:id="glibc-index-socket-protocol"></span>
<span xml:id="glibc-index-protocol-family"></span>
<para>Finally you must choose the <emphasis>protocol</emphasis> to carry out the
communication.  The protocol determines what low-level mechanism is used
to transmit and receive data.  Each protocol is valid for a particular
namespace and communication style; a namespace is sometimes called a
<emphasis>protocol family</emphasis> because of this, which is why the namespace names
start with ‘<filename>PF_</filename>’.
</para>
<para>The rules of a protocol apply to the data passing between two programs,
perhaps on different computers; most of these rules are handled by the
operating system and you need not know about them.  What you do need to
know about protocols is this:
</para>
<ul>
<li> In order to have communication between two sockets, they must specify
the <emphasis>same</emphasis> protocol.

</li><li> Each protocol is meaningful with particular style/namespace
combinations and cannot be used with inappropriate combinations.  For
example, the TCP protocol fits only the byte stream style of
communication and the Internet namespace.

</li><li> For each combination of style and namespace there is a <emphasis>default
protocol</emphasis>, which you can request by specifying 0 as the protocol
number.  And that’s what you should normally do—use the default.
</li></ul>

<para>Throughout the following description at various places
variables/parameters to denote sizes are required.  And here the trouble
starts.  In the first implementations the type of these variables was
simply <code>int</code>.  On most machines at that time an <code>int</code> was 32
bits wide, which created a <emphasis>de facto</emphasis> standard requiring 32-bit
variables.  This is important since references to variables of this type
are passed to the kernel.
</para>
<para>Then the POSIX people came and unified the interface with the words "all
size values are of type <code>size_t</code>".  On 64-bit machines
<code>size_t</code> is 64 bits wide, so pointers to variables were no longer
possible.
</para>
<para>The Unix98 specification provides a solution by introducing a type
<code>socklen_t</code>.  This type is used in all of the cases that POSIX
changed to use <code>size_t</code>.  The only requirement of this type is that
it be an unsigned type of at least 32 bits.  Therefore, implementations
which require that references to 32-bit variables be passed can be as
happy as implementations which use 64-bit values.
</para>

<hr>
</div>
<sect xml:id="glibc-Communication-Styles">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Socket-Addresses" accesskey="n" rel="next">Socket Addresses</a>, Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Socket-Concepts" accesskey="p" rel="prev">Socket Concepts</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Sockets" accesskey="u" rel="up">Sockets</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Communication-Styles-1"></span><h3 class="section">16.2 Communication Styles</title>

<para>The GNU C Library includes support for several different kinds of sockets,
each with different characteristics.  This section describes the
supported socket types.  The symbolic constants listed here are
defined in <filename>sys/socket.h</filename>.
<span xml:id="glibc-index-sys_002fsocket_002eh"></span>
</para>
<dl class="def">
<dt xml:id="glibc-index-SOCK_005fSTREAM"><span class="category">Macro: </span><span><emphasis>int</emphasis> <strong>SOCK_STREAM</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-SOCK_005fSTREAM" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>The <code>SOCK_STREAM</code> style is like a pipe (see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Pipes-and-FIFOs">Pipes and FIFOs</a>).
It operates over a connection with a particular remote socket and
transmits data reliably as a stream of bytes.
</para>
<para>Use of this style is covered in detail in <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Connections">Using Sockets with Connections</a>.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-SOCK_005fDGRAM"><span class="category">Macro: </span><span><emphasis>int</emphasis> <strong>SOCK_DGRAM</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-SOCK_005fDGRAM" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>The <code>SOCK_DGRAM</code> style is used for sending
individually-addressed packets unreliably.
It is the diametrical opposite of <code>SOCK_STREAM</code>.
</para>
<para>Each time you write data to a socket of this kind, that data becomes
one packet.  Since <code>SOCK_DGRAM</code> sockets do not have connections,
you must specify the recipient address with each packet.
</para>
<para>The only guarantee that the system makes about your requests to
transmit data is that it will try its best to deliver each packet you
send.  It may succeed with the sixth packet after failing with the
fourth and fifth packets; the seventh packet may arrive before the
sixth, and may arrive a second time after the sixth.
</para>
<para>The typical use for <code>SOCK_DGRAM</code> is in situations where it is
acceptable to simply re-send a packet if no response is seen in a
reasonable amount of time.
</para>
<para>See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Datagrams">Datagram Socket Operations</a>, for detailed information about how to use datagram
sockets.
</para></dd></dl>



<dl class="def">
<dt xml:id="glibc-index-SOCK_005fRAW"><span class="category">Macro: </span><span><emphasis>int</emphasis> <strong>SOCK_RAW</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-SOCK_005fRAW" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>This style provides access to low-level network protocols and
interfaces.  Ordinary user programs usually have no need to use this
style.
</para></dd></dl>

<hr>
</div>
<sect xml:id="glibc-Socket-Addresses">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Interface-Naming" accesskey="n" rel="next">Interface Naming</a>, Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Communication-Styles" accesskey="p" rel="prev">Communication Styles</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Sockets" accesskey="u" rel="up">Sockets</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Socket-Addresses-1"></span><h3 class="section">16.3 Socket Addresses</title>

<span xml:id="glibc-index-address-of-socket"></span>
<span xml:id="glibc-index-name-of-socket"></span>
<span xml:id="glibc-index-binding-a-socket-address"></span>
<span xml:id="glibc-index-socket-address-_0028name_0029-binding"></span>
<para>The name of a socket is normally called an <emphasis>address</emphasis>.  The
functions and symbols for dealing with socket addresses were named
inconsistently, sometimes using the term “name” and sometimes using
“address”.  You can regard these terms as synonymous where sockets
are concerned.
</para>
<para>A socket newly created with the <code>socket</code> function has no
address.  Other processes can find it for communication only if you
give it an address.  We call this <emphasis>binding</emphasis> the address to the
socket, and the way to do it is with the <code>bind</code> function.
</para>
<para>You need only be concerned with the address of a socket if other processes
are to find it and start communicating with it.  You can specify an
address for other sockets, but this is usually pointless; the first time
you send data from a socket, or use it to initiate a connection, the
system assigns an address automatically if you have not specified one.
</para>
<para>Occasionally a client needs to specify an address because the server
discriminates based on address; for example, the rsh and rlogin
protocols look at the client’s socket address and only bypass passphrase
checking if it is less than <code>IPPORT_RESERVED</code> (see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Ports">Internet Ports</a>).
</para>
<para>The details of socket addresses vary depending on what namespace you are
using.  See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Local-Namespace">The Local Namespace</a>, or <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Internet-Namespace">The Internet Namespace</a>, for specific
information.
</para>
<para>Regardless of the namespace, you use the same functions <code>bind</code> and
<code>getsockname</code> to set and examine a socket’s address.  These
functions use a phony data type, <code>struct sockaddr *</code>, to accept the
address.  In practice, the address lives in a structure of some other
data type appropriate to the address format you are using, but you cast
its address to <code>struct sockaddr *</code> when you pass it to
<code>bind</code>.
</para>

<ul class="section-toc">
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Address-Formats" accesskey="1">Address Formats</a></li>
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Setting-Address" accesskey="2">Setting the Address of a Socket</a></li>
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Reading-Address" accesskey="3">Reading the Address of a Socket</a></li>
</ul>
<hr>
<div class="subsection" xml:id="glibc-Address-Formats">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Setting-Address" accesskey="n" rel="next">Setting the Address of a Socket</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Socket-Addresses" accesskey="u" rel="up">Socket Addresses</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Address-Formats-1"></span><h4 class="subsection">16.3.1 Address Formats</title>

<para>The functions <code>bind</code> and <code>getsockname</code> use the generic data
type <code>struct sockaddr *</code> to represent a pointer to a socket
address.  You can’t use this data type effectively to interpret an
address or construct one; for that, you must use the proper data type
for the socket’s namespace.
</para>
<para>Thus, the usual practice is to construct an address of the proper
namespace-specific type, then cast a pointer to <code>struct sockaddr *</code>
when you call <code>bind</code> or <code>getsockname</code>.
</para>
<para>The one piece of information that you can get from the <code>struct
sockaddr</code> data type is the <emphasis>address format designator</emphasis>.  This tells
you which data type to use to understand the address fully.
</para>
<span xml:id="glibc-index-sys_002fsocket_002eh-1"></span>
<para>The symbols in this section are defined in the header file
<filename>sys/socket.h</filename>.
</para>
<dl class="def">
<dt xml:id="glibc-index-struct-sockaddr"><span class="category">Data Type: </span><span><strong>struct sockaddr</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-struct-sockaddr" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>The <code>struct sockaddr</code> type itself has the following members:
</para>
<dl compact="compact">
<dt><span><code>short int sa_family</code></span></dt>
<dd><para>This is the code for the address format of this address.  It
identifies the format of the data which follows.
</para>
</dd>
<dt><span><code>char sa_data[14]</code></span></dt>
<dd><para>This is the actual socket address data, which is format-dependent.  Its
length also depends on the format, and may well be more than 14.  The
length 14 of <code>sa_data</code> is essentially arbitrary.
</para></dd>
</dl>
</dd></dl>

<para>Each address format has a symbolic name which starts with ‘<filename>AF_</filename>’.
Each of them corresponds to a ‘<filename>PF_</filename>’ symbol which designates the
corresponding namespace.  Here is a list of address format names:
</para>
<dl compact="compact">
<dt xml:id="glibc-index-AF_005fLOCAL"><span><code>AF_LOCAL</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-AF_005fLOCAL" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>This designates the address format that goes with the local namespace.
(<code>PF_LOCAL</code> is the name of that namespace.)  See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Local-Namespace-Details">Details of Local Namespace</a>, for information about this address format.
</para>
</dd>
<dt xml:id="glibc-index-AF_005fUNIX"><span><code>AF_UNIX</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-AF_005fUNIX" class="copiable-anchor"> ¶</a></span></dt>
<dd>

<para>This is a synonym for <code>AF_LOCAL</code>.  Although <code>AF_LOCAL</code> is
mandated by POSIX.1g, <code>AF_UNIX</code> is portable to more systems.
<code>AF_UNIX</code> was the traditional name stemming from BSD, so even most
POSIX systems support it.  It is also the name of choice in the Unix98
specification. (The same is true for <code>PF_UNIX</code>
vs. <code>PF_LOCAL</code>).
</para>
</dd>
<dt xml:id="glibc-index-AF_005fFILE"><span><code>AF_FILE</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-AF_005fFILE" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>This is another synonym for <code>AF_LOCAL</code>, for compatibility.
(<code>PF_FILE</code> is likewise a synonym for <code>PF_LOCAL</code>.)
</para>
</dd>
<dt xml:id="glibc-index-AF_005fINET"><span><code>AF_INET</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-AF_005fINET" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>This designates the address format that goes with the Internet
namespace.  (<code>PF_INET</code> is the name of that namespace.)
See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Internet-Address-Formats">Internet Socket Address Formats</a>.
</para>
</dd>
<dt xml:id="glibc-index-AF_005fINET6"><span><code>AF_INET6</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-AF_005fINET6" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>This is similar to <code>AF_INET</code>, but refers to the IPv6 protocol.
(<code>PF_INET6</code> is the name of the corresponding namespace.)
</para>
</dd>
<dt xml:id="glibc-index-AF_005fUNSPEC"><span><code>AF_UNSPEC</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-AF_005fUNSPEC" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>This designates no particular address format.  It is used only in rare
cases, such as to clear out the default destination address of a
“connected” datagram socket.  See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Sending-Datagrams">Sending Datagrams</a>.
</para>
<para>The corresponding namespace designator symbol <code>PF_UNSPEC</code> exists
for completeness, but there is no reason to use it in a program.
</para></dd>
</dl>

<para><filename>sys/socket.h</filename> defines symbols starting with ‘<filename>AF_</filename>’ for many
different kinds of networks, most or all of which are not actually
implemented.  We will document those that really work as we receive
information about how to use them.
</para>
<hr>
</div>
<div class="subsection" xml:id="glibc-Setting-Address">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Reading-Address" accesskey="n" rel="next">Reading the Address of a Socket</a>, Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Address-Formats" accesskey="p" rel="prev">Address Formats</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Socket-Addresses" accesskey="u" rel="up">Socket Addresses</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Setting-the-Address-of-a-Socket"></span><h4 class="subsection">16.3.2 Setting the Address of a Socket</title>

<span xml:id="glibc-index-sys_002fsocket_002eh-2"></span>
<para>Use the <code>bind</code> function to assign an address to a socket.  The
prototype for <code>bind</code> is in the header file <filename>sys/socket.h</filename>.
For examples of use, see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Local-Socket-Example">Example of Local-Namespace Sockets</a>, or see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Inet-Example">Internet Socket Example</a>.
</para>
<dl class="def">
<dt xml:id="glibc-index-bind"><span class="category">Function: </span><span><emphasis>int</emphasis> <strong>bind</strong> <emphasis>(int <var>socket</var>, struct sockaddr *<var>addr</var>, socklen_t <var>length</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-bind" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Safe
| AC-Safe
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>The <code>bind</code> function assigns an address to the socket
<var>socket</var>.  The <var>addr</var> and <var>length</var> arguments specify the
address; the detailed format of the address depends on the namespace.
The first part of the address is always the format designator, which
specifies a namespace, and says that the address is in the format of
that namespace.
</para>
<para>The return value is <code>0</code> on success and <code>-1</code> on failure.  The
following <code>errno</code> error conditions are defined for this function:
</para>
<dl compact="compact">
<dt><span><code>EBADF</code></span></dt>
<dd><para>The <var>socket</var> argument is not a valid file descriptor.
</para>
</dd>
<dt><span><code>ENOTSOCK</code></span></dt>
<dd><para>The descriptor <var>socket</var> is not a socket.
</para>
</dd>
<dt><span><code>EADDRNOTAVAIL</code></span></dt>
<dd><para>The specified address is not available on this machine.
</para>
</dd>
<dt><span><code>EADDRINUSE</code></span></dt>
<dd><para>Some other socket is already using the specified address.
</para>
</dd>
<dt><span><code>EINVAL</code></span></dt>
<dd><para>The socket <var>socket</var> already has an address.
</para>
</dd>
<dt><span><code>EACCES</code></span></dt>
<dd><para>You do not have permission to access the requested address.  (In the
Internet domain, only the super-user is allowed to specify a port number
in the range 0 through <code>IPPORT_RESERVED</code> minus one; see
<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Ports">Internet Ports</a>.)
</para></dd>
</dl>

<para>Additional conditions may be possible depending on the particular namespace
of the socket.
</para></dd></dl>

<hr>
</div>
<div class="subsection" xml:id="glibc-Reading-Address">
<div class="header">
<para>
Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Setting-Address" accesskey="p" rel="prev">Setting the Address of a Socket</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Socket-Addresses" accesskey="u" rel="up">Socket Addresses</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Reading-the-Address-of-a-Socket"></span><h4 class="subsection">16.3.3 Reading the Address of a Socket</title>

<span xml:id="glibc-index-sys_002fsocket_002eh-3"></span>
<para>Use the function <code>getsockname</code> to examine the address of an
Internet socket.  The prototype for this function is in the header file
<filename>sys/socket.h</filename>.
</para>
<dl class="def">
<dt xml:id="glibc-index-getsockname"><span class="category">Function: </span><span><emphasis>int</emphasis> <strong>getsockname</strong> <emphasis>(int <var>socket</var>, struct sockaddr *<var>addr</var>, socklen_t *<var>length-ptr</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-getsockname" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Safe
| AC-Safe mem/hurd
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>The <code>getsockname</code> function returns information about the
address of the socket <var>socket</var> in the locations specified by the
<var>addr</var> and <var>length-ptr</var> arguments.  Note that the
<var>length-ptr</var> is a pointer; you should initialize it to be the
allocation size of <var>addr</var>, and on return it contains the actual
size of the address data.
</para>
<para>The format of the address data depends on the socket namespace.  The
length of the information is usually fixed for a given namespace, so
normally you can know exactly how much space is needed and can provide
that much.  The usual practice is to allocate a place for the value
using the proper data type for the socket’s namespace, then cast its
address to <code>struct sockaddr *</code> to pass it to <code>getsockname</code>.
</para>
<para>The return value is <code>0</code> on success and <code>-1</code> on error.  The
following <code>errno</code> error conditions are defined for this function:
</para>
<dl compact="compact">
<dt><span><code>EBADF</code></span></dt>
<dd><para>The <var>socket</var> argument is not a valid file descriptor.
</para>
</dd>
<dt><span><code>ENOTSOCK</code></span></dt>
<dd><para>The descriptor <var>socket</var> is not a socket.
</para>
</dd>
<dt><span><code>ENOBUFS</code></span></dt>
<dd><para>There are not enough internal buffers available for the operation.
</para></dd>
</dl>
</dd></dl>

<para>You can’t read the address of a socket in the file namespace.  This is
consistent with the rest of the system; in general, there’s no way to
find a file’s name from a descriptor for that file.
</para>
<hr>
</div>
</div>
<sect xml:id="glibc-Interface-Naming">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Local-Namespace" accesskey="n" rel="next">The Local Namespace</a>, Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Socket-Addresses" accesskey="p" rel="prev">Socket Addresses</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Sockets" accesskey="u" rel="up">Sockets</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Interface-Naming-1"></span><h3 class="section">16.4 Interface Naming</title>

<para>Each network interface has a name.  This usually consists of a few
letters that relate to the type of interface, which may be followed by a
number if there is more than one interface of that type.  Examples
might be <code>lo</code> (the loopback interface) and <code>eth0</code> (the first
Ethernet interface).
</para>
<para>Although such names are convenient for humans, it would be clumsy to
have to use them whenever a program needs to refer to an interface.  In
such situations an interface is referred to by its <emphasis>index</emphasis>, which is
an arbitrarily-assigned small positive integer.
</para>
<para>The following functions, constants and data types are declared in the
header file <filename>net/if.h</filename>.
</para>
<dl class="def">
<dt xml:id="glibc-index-IFNAMSIZ"><span class="category">Constant: </span><span><emphasis>size_t</emphasis> <strong>IFNAMSIZ</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-IFNAMSIZ" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>This constant defines the maximum buffer size needed to hold an
interface name, including its terminating zero byte.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-if_005fnametoindex"><span class="category">Function: </span><span><emphasis>unsigned int</emphasis> <strong>if_nametoindex</strong> <emphasis>(const char *<var>ifname</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-if_005fnametoindex" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Unsafe lock
| AC-Unsafe lock fd
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>This function yields the interface index corresponding to a particular
name.  If no interface exists with the name given, it returns 0.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-if_005findextoname"><span class="category">Function: </span><span><emphasis>char *</emphasis> <strong>if_indextoname</strong> <emphasis>(unsigned int <var>ifindex</var>, char *<var>ifname</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-if_005findextoname" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Unsafe lock
| AC-Unsafe lock fd
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>This function maps an interface index to its corresponding name.  The
returned name is placed in the buffer pointed to by <code>ifname</code>, which
must be at least <code>IFNAMSIZ</code> bytes in length.  If the index was
invalid, the function’s return value is a null pointer, otherwise it is
<code>ifname</code>.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-struct-if_005fnameindex"><span class="category">Data Type: </span><span><strong>struct if_nameindex</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-struct-if_005fnameindex" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>This data type is used to hold the information about a single
interface.  It has the following members:
</para>
<dl compact="compact">
<dt><span><code>unsigned int if_index;</code></span></dt>
<dd><para>This is the interface index.
</para>
</dd>
<dt><span><code>char *if_name</code></span></dt>
<dd><para>This is the null-terminated index name.
</para>
</dd>
</dl>
</dd></dl>

<dl class="def">
<dt xml:id="glibc-index-if_005fnameindex"><span class="category">Function: </span><span><emphasis>struct if_nameindex *</emphasis> <strong>if_nameindex</strong> <emphasis>(void)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-if_005fnameindex" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Unsafe heap lock/hurd
| AC-Unsafe lock/hurd fd mem
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>This function returns an array of <code>if_nameindex</code> structures, one
for every interface that is present.  The end of the list is indicated
by a structure with an interface of 0 and a null name pointer.  If an
error occurs, this function returns a null pointer.
</para>
<para>The returned structure must be freed with <code>if_freenameindex</code> after
use.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-if_005ffreenameindex"><span class="category">Function: </span><span><emphasis>void</emphasis> <strong>if_freenameindex</strong> <emphasis>(struct if_nameindex *<var>ptr</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-if_005ffreenameindex" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Unsafe heap
| AC-Unsafe mem
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>This function frees the structure returned by an earlier call to
<code>if_nameindex</code>.
</para></dd></dl>

<hr>
</div>
<sect xml:id="glibc-Local-Namespace">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Internet-Namespace" accesskey="n" rel="next">The Internet Namespace</a>, Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Interface-Naming" accesskey="p" rel="prev">Interface Naming</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Sockets" accesskey="u" rel="up">Sockets</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-The-Local-Namespace"></span><h3 class="section">16.5 The Local Namespace</title>
<span xml:id="glibc-index-local-namespace_002c-for-sockets"></span>

<para>This section describes the details of the local namespace, whose
symbolic name (required when you create a socket) is <code>PF_LOCAL</code>.
The local namespace is also known as “Unix domain sockets”.  Another
name is file namespace since socket addresses are normally implemented
as file names.
</para>

<ul class="section-toc">
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Local-Namespace-Concepts" accesskey="1">Local Namespace Concepts</a></li>
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Local-Namespace-Details" accesskey="2">Details of Local Namespace</a></li>
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Local-Socket-Example" accesskey="3">Example of Local-Namespace Sockets</a></li>
</ul>
<hr>
<div class="subsection" xml:id="glibc-Local-Namespace-Concepts">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Local-Namespace-Details" accesskey="n" rel="next">Details of Local Namespace</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Local-Namespace" accesskey="u" rel="up">The Local Namespace</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Local-Namespace-Concepts-1"></span><h4 class="subsection">16.5.1 Local Namespace Concepts</title>

<para>In the local namespace socket addresses are file names.  You can specify
any file name you want as the address of the socket, but you must have
write permission on the directory containing it.
It’s common to put these files in the <filename>/tmp</filename> directory.
</para>
<para>One peculiarity of the local namespace is that the name is only used
when opening the connection; once open the address is not meaningful and
may not exist.
</para>
<para>Another peculiarity is that you cannot connect to such a socket from
another machine–not even if the other machine shares the file system
which contains the name of the socket.  You can see the socket in a
directory listing, but connecting to it never succeeds.  Some programs
take advantage of this, such as by asking the client to send its own
process ID, and using the process IDs to distinguish between clients.
However, we recommend you not use this method in protocols you design,
as we might someday permit connections from other machines that mount
the same file systems.  Instead, send each new client an identifying
number if you want it to have one.
</para>
<para>After you close a socket in the local namespace, you should delete the
file name from the file system.  Use <code>unlink</code> or <code>remove</code> to
do this; see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Deleting-Files">Deleting Files</a>.
</para>
<para>The local namespace supports just one protocol for any communication
style; it is protocol number <code>0</code>.
</para>
<hr>
</div>
<div class="subsection" xml:id="glibc-Local-Namespace-Details">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Local-Socket-Example" accesskey="n" rel="next">Example of Local-Namespace Sockets</a>, Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Local-Namespace-Concepts" accesskey="p" rel="prev">Local Namespace Concepts</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Local-Namespace" accesskey="u" rel="up">The Local Namespace</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Details-of-Local-Namespace"></span><h4 class="subsection">16.5.2 Details of Local Namespace</title>

<span xml:id="glibc-index-sys_002fsocket_002eh-4"></span>
<para>To create a socket in the local namespace, use the constant
<code>PF_LOCAL</code> as the <var>namespace</var> argument to <code>socket</code> or
<code>socketpair</code>.  This constant is defined in <filename>sys/socket.h</filename>.
</para>
<dl class="def">
<dt xml:id="glibc-index-PF_005fLOCAL"><span class="category">Macro: </span><span><emphasis>int</emphasis> <strong>PF_LOCAL</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-PF_005fLOCAL" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>This designates the local namespace, in which socket addresses are local
names, and its associated family of protocols.  <code>PF_LOCAL</code> is the
macro used by POSIX.1g.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-PF_005fUNIX"><span class="category">Macro: </span><span><emphasis>int</emphasis> <strong>PF_UNIX</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-PF_005fUNIX" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>This is a synonym for <code>PF_LOCAL</code>, for compatibility’s sake.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-PF_005fFILE"><span class="category">Macro: </span><span><emphasis>int</emphasis> <strong>PF_FILE</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-PF_005fFILE" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>This is a synonym for <code>PF_LOCAL</code>, for compatibility’s sake.
</para></dd></dl>

<para>The structure for specifying socket names in the local namespace is
defined in the header file <filename>sys/un.h</filename>:
<span xml:id="glibc-index-sys_002fun_002eh"></span>
</para>
<dl class="def">
<dt xml:id="glibc-index-struct-sockaddr_005fun"><span class="category">Data Type: </span><span><strong>struct sockaddr_un</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-struct-sockaddr_005fun" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>This structure is used to specify local namespace socket addresses.  It has
the following members:
</para>
<dl compact="compact">
<dt><span><code>short int sun_family</code></span></dt>
<dd><para>This identifies the address family or format of the socket address.
You should store the value <code>AF_LOCAL</code> to designate the local
namespace.  See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Socket-Addresses">Socket Addresses</a>.
</para>
</dd>
<dt><span><code>char sun_path[108]</code></span></dt>
<dd><para>This is the file name to use.
</para>
<para><strong>Incomplete:</strong>  Why is 108 a magic number?  RMS suggests making
this a zero-length array and tweaking the following example to use
<code>alloca</code> to allocate an appropriate amount of storage based on
the length of the filename.
</para></dd>
</dl>
</dd></dl>

<para>You should compute the <var>length</var> parameter for a socket address in
the local namespace as the sum of the size of the <code>sun_family</code>
component and the string length (<emphasis>not</emphasis> the allocation size!) of
the file name string.  This can be done using the macro <code>SUN_LEN</code>:
</para>
<dl class="def">
<dt xml:id="glibc-index-SUN_005fLEN"><span class="category">Macro: </span><span><emphasis>int</emphasis> <strong>SUN_LEN</strong> <emphasis>(<emphasis>struct sockaddr_un *</emphasis> <var>ptr</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-SUN_005fLEN" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Safe
| AC-Safe
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>This macro computes the length of the socket address in the local namespace.
</para></dd></dl>

<hr>
</div>
<div class="subsection" xml:id="glibc-Local-Socket-Example">
<div class="header">
<para>
Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Local-Namespace-Details" accesskey="p" rel="prev">Details of Local Namespace</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Local-Namespace" accesskey="u" rel="up">The Local Namespace</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Example-of-Local_002dNamespace-Sockets"></span><h4 class="subsection">16.5.3 Example of Local-Namespace Sockets</title>

<para>Here is an example showing how to create and name a socket in the local
namespace.
</para>
<div class="example">
<pre class="example">
#include &lt;stddef.h&gt;
#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/un.h&gt;

int
make_named_socket (const char *filename)
{
  struct sockaddr_un name;
  int sock;
  size_t size;

  /* <span class="roman">Create the socket.</span> */
  sock = socket (PF_LOCAL, SOCK_DGRAM, 0);
  if (sock &lt; 0)
    {
      perror ("socket");
      exit (EXIT_FAILURE);
    }

  /* <span class="roman">Bind a name to the socket.</span> */
  name.sun_family = AF_LOCAL;
  strncpy (name.sun_path, filename, sizeof (name.sun_path));
  name.sun_path[sizeof (name.sun_path) - 1] = '\0';

  /* <span class="roman">The size of the address is
     the offset of the start of the filename,
     plus its length (not including the terminating null byte).
     Alternatively you can just do:
     size = SUN_LEN (&amp;name);
</span> */
  size = (offsetof (struct sockaddr_un, sun_path)
          + strlen (name.sun_path));

  if (bind (sock, (struct sockaddr *) &amp;name, size) &lt; 0)
    {
      perror ("bind");
      exit (EXIT_FAILURE);
    }

  return sock;
}
</pre></div>

<hr>
</div>
</div>
<sect xml:id="glibc-Internet-Namespace">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Misc-Namespaces" accesskey="n" rel="next">Other Namespaces</a>, Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Local-Namespace" accesskey="p" rel="prev">The Local Namespace</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Sockets" accesskey="u" rel="up">Sockets</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-The-Internet-Namespace"></span><h3 class="section">16.6 The Internet Namespace</title>
<span xml:id="glibc-index-Internet-namespace_002c-for-sockets"></span>

<para>This section describes the details of the protocols and socket naming
conventions used in the Internet namespace.
</para>
<para>Originally the Internet namespace used only IP version 4 (IPv4).  With
the growing number of hosts on the Internet, a new protocol with a
larger address space was necessary: IP version 6 (IPv6).  IPv6
introduces 128-bit addresses (IPv4 has 32-bit addresses) and other
features, and will eventually replace IPv4.
</para>
<para>To create a socket in the IPv4 Internet namespace, use the symbolic name
<code>PF_INET</code> of this namespace as the <var>namespace</var> argument to
<code>socket</code> or <code>socketpair</code>.  For IPv6 addresses you need the
macro <code>PF_INET6</code>.  These macros are defined in <filename>sys/socket.h</filename>.
<span xml:id="glibc-index-sys_002fsocket_002eh-5"></span>
</para>
<dl class="def">
<dt xml:id="glibc-index-PF_005fINET"><span class="category">Macro: </span><span><emphasis>int</emphasis> <strong>PF_INET</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-PF_005fINET" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>This designates the IPv4 Internet namespace and associated family of
protocols.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-PF_005fINET6"><span class="category">Macro: </span><span><emphasis>int</emphasis> <strong>PF_INET6</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-PF_005fINET6" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>This designates the IPv6 Internet namespace and associated family of
protocols.
</para></dd></dl>

<para>A socket address for the Internet namespace includes the following components:
</para>
<ul>
<li> The address of the machine you want to connect to.  Internet addresses
can be specified in several ways; these are discussed in <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Internet-Address-Formats">Internet Socket Address Formats</a>, <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Host-Addresses">Host Addresses</a> and <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Host-Names">Host Names</a>.

</li><li> A port number for that machine.  See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Ports">Internet Ports</a>.
</li></ul>

<para>You must ensure that the address and port number are represented in a
canonical format called <emphasis>network byte order</emphasis>.  See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Byte-Order">Byte Order Conversion</a>,
for information about this.
</para>

<ul class="section-toc">
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Internet-Address-Formats" accesskey="1">Internet Socket Address Formats</a></li>
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Host-Addresses" accesskey="2">Host Addresses</a></li>
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Ports" accesskey="3">Internet Ports</a></li>
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Services-Database" accesskey="4">The Services Database</a></li>
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Byte-Order" accesskey="5">Byte Order Conversion</a></li>
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Protocols-Database" accesskey="6">Protocols Database</a></li>
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Inet-Example" accesskey="7">Internet Socket Example</a></li>
</ul>
<hr>
<div class="subsection" xml:id="glibc-Internet-Address-Formats">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Host-Addresses" accesskey="n" rel="next">Host Addresses</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Internet-Namespace" accesskey="u" rel="up">The Internet Namespace</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Internet-Socket-Address-Formats"></span><h4 class="subsection">16.6.1 Internet Socket Address Formats</title>

<para>In the Internet namespace, for both IPv4 (<code>AF_INET</code>) and IPv6
(<code>AF_INET6</code>), a socket address consists of a host address
and a port on that host.  In addition, the protocol you choose serves
effectively as a part of the address because local port numbers are
meaningful only within a particular protocol.
</para>
<para>The data types for representing socket addresses in the Internet namespace
are defined in the header file <filename>netinet/in.h</filename>.
<span xml:id="glibc-index-netinet_002fin_002eh"></span>
</para>
<dl class="def">
<dt xml:id="glibc-index-struct-sockaddr_005fin"><span class="category">Data Type: </span><span><strong>struct sockaddr_in</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-struct-sockaddr_005fin" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>This is the data type used to represent socket addresses in the
Internet namespace.  It has the following members:
</para>
<dl compact="compact">
<dt><span><code>sa_family_t sin_family</code></span></dt>
<dd><para>This identifies the address family or format of the socket address.
You should store the value <code>AF_INET</code> in this member.  The address
family is stored in host byte order.  See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Socket-Addresses">Socket Addresses</a>.
</para>
</dd>
<dt><span><code>struct in_addr sin_addr</code></span></dt>
<dd><para>This is the IPv4 address.  See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Host-Addresses">Host Addresses</a>, and <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Host-Names">Host Names</a>, for how to get a value to store here.  The IPv4 address is
stored in network byte order.
</para>
</dd>
<dt><span><code>unsigned short int sin_port</code></span></dt>
<dd><para>This is the port number.  See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Ports">Internet Ports</a>.  The port number is stored in
network byte order.
</para></dd>
</dl>
</dd></dl>

<para>When you call <code>bind</code> or <code>getsockname</code>, you should specify
<code>sizeof (struct sockaddr_in)</code> as the <var>length</var> parameter if
you are using an IPv4 Internet namespace socket address.
</para>
<dl class="def">
<dt xml:id="glibc-index-struct-sockaddr_005fin6"><span class="category">Data Type: </span><span><strong>struct sockaddr_in6</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-struct-sockaddr_005fin6" class="copiable-anchor"> ¶</a></span></dt>
<dd><para>This is the data type used to represent socket addresses in the IPv6
namespace.  It has the following members:
</para>
<dl compact="compact">
<dt><span><code>sa_family_t sin6_family</code></span></dt>
<dd><para>This identifies the address family or format of the socket address.
You should store the value of <code>AF_INET6</code> in this member.
See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Socket-Addresses">Socket Addresses</a>.  The address family is stored in host byte
order.
</para>
</dd>
<dt><span><code>struct in6_addr sin6_addr</code></span></dt>
<dd><para>This is the IPv6 address of the host machine.  See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Host-Addresses">Host Addresses</a>, and <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Host-Names">Host Names</a>, for how to get a value to store
here.  The address is stored in network byte order.
</para>
</dd>
<dt xml:id="glibc-index-flow-label"><span><code>uint32_t sin6_flowinfo</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-flow-label" class="copiable-anchor"> ¶</a></span></dt>
<dd><span xml:id="glibc-index-IPv6-flow-label"></span>
<span xml:id="glibc-index-traffic-class"></span>
<span xml:id="glibc-index-IPv6-traffic-class"></span>
<para>This combines the IPv6 traffic class and flow label values, as found
in the IPv6 header.  This field is stored in network byte order.  Only
the 28 lower bits (of the number in network byte order) are used; the
remainig bits must be zero.  The lower 20 bits are the flow label, and
bits 20 to 27 are the the traffic class.  Typically, this field is
zero.
</para>
</dd>
<dt xml:id="glibc-index-scope-ID"><span><code>uint32_t sin6_scope_id</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-scope-ID" class="copiable-anchor"> ¶</a></span></dt>
<dd><span xml:id="glibc-index-IPv6-scope-ID"></span>
<para>For link-local addresses, this identifies the interface on which this
address is valid.  The scope ID is stored in host byte order.
Typically, this field is zero.
</para>
</dd>
<dt><span><code>uint16_t sin6_port</code></span></dt>
<dd><para>This is the port number.  See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Ports">Internet Ports</a>.  The port number is stored in
network byte order.
</para>
</dd>
</dl>
</dd></dl>

<hr>
</div>
<div class="subsection" xml:id="glibc-Host-Addresses">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Ports" accesskey="n" rel="next">Internet Ports</a>, Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Internet-Address-Formats" accesskey="p" rel="prev">Internet Socket Address Formats</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Internet-Namespace" accesskey="u" rel="up">The Internet Namespace</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Host-Addresses-1"></span><h4 class="subsection">16.6.2 Host Addresses</title>

<para>Each computer on the Internet has one or more <emphasis>Internet addresses</emphasis>,
numbers which identify that computer among all those on the Internet.
Users typically write IPv4 numeric host addresses as sequences of four
numbers, separated by periods, as in ‘<filename>128.52.46.32</filename>’, and IPv6
numeric host addresses as sequences of up to eight numbers separated by
colons, as in ‘<filename>5f03:1200:836f:c100::1</filename>’.
</para>
<para>Each computer also has one or more <emphasis>host names</emphasis>, which are strings
of words separated by periods, as in ‘<filename>www.gnu.org</filename>’.
</para>
<para>Programs that let the user specify a host typically accept both numeric
addresses and host names.  To open a connection a program needs a
numeric address, and so must convert a host name to the numeric address
it stands for.
</para>

<ul class="section-toc">
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Abstract-Host-Addresses" accesskey="1">Internet Host Addresses</a></li>
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Host-Address-Data-Type" accesskey="2">Host Address Data Type</a></li>
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Host-Address-Functions" accesskey="3">Host Address Functions</a></li>
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Host-Names" accesskey="4">Host Names</a></li>
</ul>
<hr>
<div class="subsubsection" xml:id="glibc-Abstract-Host-Addresses">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Host-Address-Data-Type" accesskey="n" rel="next">Host Address Data Type</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Host-Addresses" accesskey="u" rel="up">Host Addresses</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Internet-Host-Addresses"></span><h4 class="subsubsection">16.6.2.1 Internet Host Addresses</title>
<span xml:id="glibc-index-host-address_002c-Internet"></span>
<span xml:id="glibc-index-Internet-host-address"></span>


<span xml:id="glibc-index-network-number"></span>
<span xml:id="glibc-index-local-network-address-number"></span>
<para>An IPv4 Internet host address is a number containing four bytes of data.
Historically these are divided into two parts, a <emphasis>network number</emphasis> and a
<emphasis>local network address number</emphasis> within that network.  In the
mid-1990s classless addresses were introduced which changed this
behavior.  Since some functions implicitly expect the old definitions,
we first describe the class-based network and will then describe
classless addresses.  IPv6 uses only classless addresses and therefore
the following paragraphs don’t apply.
</para>
<para>The class-based IPv4 network number consists of the first one, two or
three bytes; the rest of the bytes are the local address.
</para>
<para>IPv4 network numbers are registered with the Network Information Center
(NIC), and are divided into three classes—A, B and C.  The local
network address numbers of individual machines are registered with the
administrator of the particular network.
</para>
<para>Class A networks have single-byte numbers in the range 0 to 127.  There
are only a small number of Class A networks, but they can each support a
very large number of hosts.  Medium-sized Class B networks have two-byte
network numbers, with the first byte in the range 128 to 191.  Class C
networks are the smallest; they have three-byte network numbers, with
the first byte in the range 192-255.  Thus, the first 1, 2, or 3 bytes
of an Internet address specify a network.  The remaining bytes of the
Internet address specify the address within that network.
</para>
<para>The Class A network 0 is reserved for broadcast to all networks.  In
addition, the host number 0 within each network is reserved for broadcast
to all hosts in that network.  These uses are obsolete now but for
compatibility reasons you shouldn’t use network 0 and host number 0.
</para>
<para>The Class A network 127 is reserved for loopback; you can always use
the Internet address ‘<filename>127.0.0.1</filename>’ to refer to the host machine.
</para>
<para>Since a single machine can be a member of multiple networks, it can
have multiple Internet host addresses.  However, there is never
supposed to be more than one machine with the same host address.
</para>

<span xml:id="glibc-index-standard-dot-notation_002c-for-Internet-addresses"></span>
<span xml:id="glibc-index-dot-notation_002c-for-Internet-addresses"></span>
<para>There are four forms of the <emphasis>standard numbers-and-dots notation</emphasis>
for Internet addresses:
</para>
<dl compact="compact">
<dt><span><code><var>a</var>.<var>b</var>.<var>c</var>.<var>d</var></code></span></dt>
<dd><para>This specifies all four bytes of the address individually and is the
commonly used representation.
</para>
</dd>
<dt><span><code><var>a</var>.<var>b</var>.<var>c</var></code></span></dt>
<dd><para>The last part of the address, <var>c</var>, is interpreted as a 2-byte quantity.
This is useful for specifying host addresses in a Class B network with
network address number <code><var>a</var>.<var>b</var></code>.
</para>
</dd>
<dt><span><code><var>a</var>.<var>b</var></code></span></dt>
<dd><para>The last part of the address, <var>b</var>, is interpreted as a 3-byte quantity.
This is useful for specifying host addresses in a Class A network with
network address number <var>a</var>.
</para>
</dd>
<dt><span><code><var>a</var></code></span></dt>
<dd><para>If only one part is given, this corresponds directly to the host address
number.
</para></dd>
</dl>

<para>Within each part of the address, the usual C conventions for specifying
the radix apply.  In other words, a leading ‘<filename>0x</filename>’ or ‘<filename>0X</filename>’ implies
hexadecimal radix; a leading ‘<filename>0</filename>’ implies octal; and otherwise decimal
radix is assumed.
</para>
<span xml:id="glibc-Classless-Addresses"></span><h4 class="subsubheading">Classless Addresses</title>

<para>IPv4 addresses (and IPv6 addresses also) are now considered classless;
the distinction between classes A, B and C can be ignored.  Instead an
IPv4 host address consists of a 32-bit address and a 32-bit mask.  The
mask contains set bits for the network part and cleared bits for the
host part.  The network part is contiguous from the left, with the
remaining bits representing the host.  As a consequence, the netmask can
simply be specified as the number of set bits.  Classes A, B and C are
just special cases of this general rule.  For example, class A addresses
have a netmask of ‘<filename>255.0.0.0</filename>’ or a prefix length of 8.
</para>
<para>Classless IPv4 network addresses are written in numbers-and-dots
notation with the prefix length appended and a slash as separator.  For
example the class A network 10 is written as ‘<filename>10.0.0.0/8</filename>’.
</para>
<span xml:id="glibc-IPv6-Addresses"></span><h4 class="subsubheading">IPv6 Addresses</title>

<para>IPv6 addresses contain 128 bits (IPv4 has 32 bits) of data.  A host
address is usually written as eight 16-bit hexadecimal numbers that are
separated by colons.  Two colons are used to abbreviate strings of
consecutive zeros.  For example, the IPv6 loopback address
‘<filename>0:0:0:0:0:0:0:1</filename>’ can just be written as ‘<filename>::1</filename>’.
</para>
<hr>
</div>
<div class="subsubsection" xml:id="glibc-Host-Address-Data-Type">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Host-Address-Functions" accesskey="n" rel="next">Host Address Functions</a>, Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Abstract-Host-Addresses" accesskey="p" rel="prev">Internet Host Addresses</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Host-Addresses" accesskey="u" rel="up">Host Addresses</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Host-Address-Data-Type-1"></span><h4 class="subsubsection">16.6.2.2 Host Address Data Type</title>

<para>IPv4 Internet host addresses are represented in some contexts as integers
(type <code>uint32_t</code>).  In other contexts, the integer is
packaged inside a structure of type <code>struct in_addr</code>.  It would
be better if the usage were made consistent, but it is not hard to extract
the integer from the structure or put the integer into a structure.
</para>
<para>You will find older code that uses <code>unsigned long int</code> for
IPv4 Internet host addresses instead of <code>uint32_t</code> or <code>struct
in_addr</code>.  Historically <code>unsigned long int</code> was a 32-bit number but
with 64-bit machines this has changed.  Using <code>unsigned long int</code>
might break the code if it is used on machines where this type doesn’t
have 32 bits.  <code>uint32_t</code> is specified by Unix98 and guaranteed to have
32 bits.
</para>
<para>IPv6 Internet host addresses have 128 bits and are packaged inside a
structure of type <code>struct in6_addr</code>.
</para>
<para>The following basic definitions for Internet addresses are declared in
the header file <filename>netinet/in.h</filename>:
<span xml:id="glibc-index-netinet_002fin_002eh-1"></span>
</para>
<dl class="def">
<dt xml:id="glibc-index-struct-in_005faddr"><span class="category">Data Type: </span><span><strong>struct in_addr</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-struct-in_005faddr" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>This data type is used in certain contexts to contain an IPv4 Internet
host address.  It has just one field, named <code>s_addr</code>, which records
the host address number as an <code>uint32_t</code>.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-INADDR_005fLOOPBACK"><span class="category">Macro: </span><span><emphasis>uint32_t</emphasis> <strong>INADDR_LOOPBACK</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-INADDR_005fLOOPBACK" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>You can use this constant to stand for “the address of this machine,”
instead of finding its actual address.  It is the IPv4 Internet address
‘<filename>127.0.0.1</filename>’, which is usually called ‘<filename>localhost</filename>’.  This
special constant saves you the trouble of looking up the address of your
own machine.  Also, the system usually implements <code>INADDR_LOOPBACK</code>
specially, avoiding any network traffic for the case of one machine
talking to itself.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-INADDR_005fANY"><span class="category">Macro: </span><span><emphasis>uint32_t</emphasis> <strong>INADDR_ANY</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-INADDR_005fANY" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>You can use this constant to stand for “any incoming address” when
binding to an address.  See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Setting-Address">Setting the Address of a Socket</a>.  This is the usual
address to give in the <code>sin_addr</code> member of <code>struct&nbsp;<span class="nolinebreak">sockaddr_in</span></code> when you want to accept Internet connections.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-INADDR_005fBROADCAST"><span class="category">Macro: </span><span><emphasis>uint32_t</emphasis> <strong>INADDR_BROADCAST</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-INADDR_005fBROADCAST" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>This constant is the address you use to send a broadcast message.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-INADDR_005fNONE"><span class="category">Macro: </span><span><emphasis>uint32_t</emphasis> <strong>INADDR_NONE</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-INADDR_005fNONE" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>This constant is returned by some functions to indicate an error.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-struct-in6_005faddr"><span class="category">Data Type: </span><span><strong>struct in6_addr</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-struct-in6_005faddr" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>This data type is used to store an IPv6 address.  It stores 128 bits of
data, which can be accessed (via a union) in a variety of ways.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-in6addr_005floopback"><span class="category">Constant: </span><span><emphasis>struct in6_addr</emphasis> <strong>in6addr_loopback</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-in6addr_005floopback" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>This constant is the IPv6 address ‘<filename>::1</filename>’, the loopback address.  See
above for a description of what this means.  The macro
<code>IN6ADDR_LOOPBACK_INIT</code> is provided to allow you to initialize your
own variables to this value.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-in6addr_005fany"><span class="category">Constant: </span><span><emphasis>struct in6_addr</emphasis> <strong>in6addr_any</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-in6addr_005fany" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>This constant is the IPv6 address ‘<filename>::</filename>’, the unspecified address.  See
above for a description of what this means.  The macro
<code>IN6ADDR_ANY_INIT</code> is provided to allow you to initialize your
own variables to this value.
</para></dd></dl>

<hr>
</div>
<div class="subsubsection" xml:id="glibc-Host-Address-Functions">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Host-Names" accesskey="n" rel="next">Host Names</a>, Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Host-Address-Data-Type" accesskey="p" rel="prev">Host Address Data Type</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Host-Addresses" accesskey="u" rel="up">Host Addresses</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Host-Address-Functions-1"></span><h4 class="subsubsection">16.6.2.3 Host Address Functions</title>

<span xml:id="glibc-index-arpa_002finet_002eh"></span>
<para>These additional functions for manipulating Internet addresses are
declared in the header file <filename>arpa/inet.h</filename>.  They represent Internet
addresses in network byte order, and network numbers and
local-address-within-network numbers in host byte order.  See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Byte-Order">Byte Order Conversion</a>, for an explanation of network and host byte order.
</para>
<dl class="def">
<dt xml:id="glibc-index-inet_005faton"><span class="category">Function: </span><span><emphasis>int</emphasis> <strong>inet_aton</strong> <emphasis>(const char *<var>name</var>, struct in_addr *<var>addr</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-inet_005faton" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe locale
| AS-Safe
| AC-Safe
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>This function converts the IPv4 Internet host address <var>name</var>
from the standard numbers-and-dots notation into binary data and stores
it in the <code>struct in_addr</code> that <var>addr</var> points to.
<code>inet_aton</code> returns nonzero if the address is valid, zero if not.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-inet_005faddr"><span class="category">Function: </span><span><emphasis>uint32_t</emphasis> <strong>inet_addr</strong> <emphasis>(const char *<var>name</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-inet_005faddr" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe locale
| AS-Safe
| AC-Safe
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>This function converts the IPv4 Internet host address <var>name</var> from the
standard numbers-and-dots notation into binary data.  If the input is
not valid, <code>inet_addr</code> returns <code>INADDR_NONE</code>.  This is an
obsolete interface to <code>inet_aton</code>, described immediately above.  It
is obsolete because <code>INADDR_NONE</code> is a valid address
(255.255.255.255), and <code>inet_aton</code> provides a cleaner way to
indicate error return.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-inet_005fnetwork"><span class="category">Function: </span><span><emphasis>uint32_t</emphasis> <strong>inet_network</strong> <emphasis>(const char *<var>name</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-inet_005fnetwork" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe locale
| AS-Safe
| AC-Safe
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>This function extracts the network number from the address <var>name</var>,
given in the standard numbers-and-dots notation.  The returned address is
in host order.  If the input is not valid, <code>inet_network</code> returns
<code>-1</code>.
</para>
<para>The function works only with traditional IPv4 class A, B and C network
types.  It doesn’t work with classless addresses and shouldn’t be used
anymore.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-inet_005fntoa"><span class="category">Function: </span><span><emphasis>char *</emphasis> <strong>inet_ntoa</strong> <emphasis>(struct in_addr <var>addr</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-inet_005fntoa" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe locale
| AS-Unsafe race
| AC-Safe
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>This function converts the IPv4 Internet host address <var>addr</var> to a
string in the standard numbers-and-dots notation.  The return value is
a pointer into a statically-allocated buffer.  Subsequent calls will
overwrite the same buffer, so you should copy the string if you need
to save it.
</para>
<para>In multi-threaded programs each thread has its own statically-allocated
buffer.  But still subsequent calls of <code>inet_ntoa</code> in the same
thread will overwrite the result of the last call.
</para>
<para>Instead of <code>inet_ntoa</code> the newer function <code>inet_ntop</code> which is
described below should be used since it handles both IPv4 and IPv6
addresses.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-inet_005fmakeaddr"><span class="category">Function: </span><span><emphasis>struct in_addr</emphasis> <strong>inet_makeaddr</strong> <emphasis>(uint32_t <var>net</var>, uint32_t <var>local</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-inet_005fmakeaddr" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Safe
| AC-Safe
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>This function makes an IPv4 Internet host address by combining the network
number <var>net</var> with the local-address-within-network number
<var>local</var>.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-inet_005flnaof"><span class="category">Function: </span><span><emphasis>uint32_t</emphasis> <strong>inet_lnaof</strong> <emphasis>(struct in_addr <var>addr</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-inet_005flnaof" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Safe
| AC-Safe
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>This function returns the local-address-within-network part of the
Internet host address <var>addr</var>.
</para>
<para>The function works only with traditional IPv4 class A, B and C network
types.  It doesn’t work with classless addresses and shouldn’t be used
anymore.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-inet_005fnetof"><span class="category">Function: </span><span><emphasis>uint32_t</emphasis> <strong>inet_netof</strong> <emphasis>(struct in_addr <var>addr</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-inet_005fnetof" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Safe
| AC-Safe
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>This function returns the network number part of the Internet host
address <var>addr</var>.
</para>
<para>The function works only with traditional IPv4 class A, B and C network
types.  It doesn’t work with classless addresses and shouldn’t be used
anymore.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-inet_005fpton"><span class="category">Function: </span><span><emphasis>int</emphasis> <strong>inet_pton</strong> <emphasis>(int <var>af</var>, const char *<var>cp</var>, void *<var>buf</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-inet_005fpton" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe locale
| AS-Safe
| AC-Safe
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>This function converts an Internet address (either IPv4 or IPv6) from
presentation (textual) to network (binary) format.  <var>af</var> should be
either <code>AF_INET</code> or <code>AF_INET6</code>, as appropriate for the type of
address being converted.  <var>cp</var> is a pointer to the input string, and
<var>buf</var> is a pointer to a buffer for the result.  It is the caller’s
responsibility to make sure the buffer is large enough.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-inet_005fntop"><span class="category">Function: </span><span><emphasis>const char *</emphasis> <strong>inet_ntop</strong> <emphasis>(int <var>af</var>, const void *<var>cp</var>, char *<var>buf</var>, socklen_t <var>len</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-inet_005fntop" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe locale
| AS-Safe
| AC-Safe
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>This function converts an Internet address (either IPv4 or IPv6) from
network (binary) to presentation (textual) form.  <var>af</var> should be
either <code>AF_INET</code> or <code>AF_INET6</code>, as appropriate.  <var>cp</var> is a
pointer to the address to be converted.  <var>buf</var> should be a pointer
to a buffer to hold the result, and <var>len</var> is the length of this
buffer.  The return value from the function will be this buffer address.
</para></dd></dl>

<hr>
</div>
<div class="subsubsection" xml:id="glibc-Host-Names">
<div class="header">
<para>
Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Host-Address-Functions" accesskey="p" rel="prev">Host Address Functions</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Host-Addresses" accesskey="u" rel="up">Host Addresses</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Host-Names-1"></span><h4 class="subsubsection">16.6.2.4 Host Names</title>
<span xml:id="glibc-index-hosts-database"></span>
<span xml:id="glibc-index-converting-host-name-to-address"></span>
<span xml:id="glibc-index-converting-host-address-to-name"></span>

<para>Besides the standard numbers-and-dots notation for Internet addresses,
you can also refer to a host by a symbolic name.  The advantage of a
symbolic name is that it is usually easier to remember.  For example,
the machine with Internet address ‘<filename>158.121.106.19</filename>’ is also known as
‘<filename>alpha.gnu.org</filename>’; and other machines in the ‘<filename>gnu.org</filename>’
domain can refer to it simply as ‘<filename>alpha</filename>’.
</para>
<span xml:id="glibc-index-_002fetc_002fhosts"></span>
<span xml:id="glibc-index-netdb_002eh"></span>
<para>Internally, the system uses a database to keep track of the mapping
between host names and host numbers.  This database is usually either
the file <filename>/etc/hosts</filename> or an equivalent provided by a name server.
The functions and other symbols for accessing this database are declared
in <filename>netdb.h</filename>.  They are BSD features, defined unconditionally if
you include <filename>netdb.h</filename>.
</para>
<dl class="def">
<dt xml:id="glibc-index-struct-hostent"><span class="category">Data Type: </span><span><strong>struct hostent</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-struct-hostent" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>This data type is used to represent an entry in the hosts database.  It
has the following members:
</para>
<dl compact="compact">
<dt><span><code>char *h_name</code></span></dt>
<dd><para>This is the “official” name of the host.
</para>
</dd>
<dt><span><code>char **h_aliases</code></span></dt>
<dd><para>These are alternative names for the host, represented as a null-terminated
vector of strings.
</para>
</dd>
<dt><span><code>int h_addrtype</code></span></dt>
<dd><para>This is the host address type; in practice, its value is always either
<code>AF_INET</code> or <code>AF_INET6</code>, with the latter being used for IPv6
hosts.  In principle other kinds of addresses could be represented in
the database as well as Internet addresses; if this were done, you
might find a value in this field other than <code>AF_INET</code> or
<code>AF_INET6</code>.  See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Socket-Addresses">Socket Addresses</a>.
</para>
</dd>
<dt><span><code>int h_length</code></span></dt>
<dd><para>This is the length, in bytes, of each address.
</para>
</dd>
<dt><span><code>char **h_addr_list</code></span></dt>
<dd><para>This is the vector of addresses for the host.  (Recall that the host
might be connected to multiple networks and have different addresses on
each one.)  The vector is terminated by a null pointer.
</para>
</dd>
<dt><span><code>char *h_addr</code></span></dt>
<dd><para>This is a synonym for <code>h_addr_list[0]</code>; in other words, it is the
first host address.
</para></dd>
</dl>
</dd></dl>

<para>As far as the host database is concerned, each address is just a block
of memory <code>h_length</code> bytes long.  But in other contexts there is an
implicit assumption that you can convert IPv4 addresses to a
<code>struct in_addr</code> or an <code>uint32_t</code>.  Host addresses in
a <code>struct hostent</code> structure are always given in network byte
order; see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Byte-Order">Byte Order Conversion</a>.
</para>
<para>You can use <code>gethostbyname</code>, <code>gethostbyname2</code> or
<code>gethostbyaddr</code> to search the hosts database for information about
a particular host.  The information is returned in a
statically-allocated structure; you must copy the information if you
need to save it across calls.  You can also use <code>getaddrinfo</code> and
<code>getnameinfo</code> to obtain this information.
</para>
<dl class="def">
<dt xml:id="glibc-index-gethostbyname"><span class="category">Function: </span><span><emphasis>struct hostent *</emphasis> <strong>gethostbyname</strong> <emphasis>(const char *<var>name</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-gethostbyname" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Unsafe race:hostbyname env locale
| AS-Unsafe dlopen plugin corrupt heap lock
| AC-Unsafe lock corrupt mem fd
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>The <code>gethostbyname</code> function returns information about the host
named <var>name</var>.  If the lookup fails, it returns a null pointer.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-gethostbyname2"><span class="category">Function: </span><span><emphasis>struct hostent *</emphasis> <strong>gethostbyname2</strong> <emphasis>(const char *<var>name</var>, int <var>af</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-gethostbyname2" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Unsafe race:hostbyname2 env locale
| AS-Unsafe dlopen plugin corrupt heap lock
| AC-Unsafe lock corrupt mem fd
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>The <code>gethostbyname2</code> function is like <code>gethostbyname</code>, but
allows the caller to specify the desired address family (e.g.
<code>AF_INET</code> or <code>AF_INET6</code>) of the result.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-gethostbyaddr"><span class="category">Function: </span><span><emphasis>struct hostent *</emphasis> <strong>gethostbyaddr</strong> <emphasis>(const void *<var>addr</var>, socklen_t <var>length</var>, int <var>format</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-gethostbyaddr" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Unsafe race:hostbyaddr env locale
| AS-Unsafe dlopen plugin corrupt heap lock
| AC-Unsafe lock corrupt mem fd
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>The <code>gethostbyaddr</code> function returns information about the host
with Internet address <var>addr</var>.  The parameter <var>addr</var> is not
really a pointer to char - it can be a pointer to an IPv4 or an IPv6
address.  The <var>length</var> argument is the size (in bytes) of the address
at <var>addr</var>.  <var>format</var> specifies the address format; for an IPv4
Internet address, specify a value of <code>AF_INET</code>; for an IPv6
Internet address, use <code>AF_INET6</code>.
</para>
<para>If the lookup fails, <code>gethostbyaddr</code> returns a null pointer.
</para></dd></dl>

<span xml:id="glibc-index-h_005ferrno"></span>
<para>If the name lookup by <code>gethostbyname</code> or <code>gethostbyaddr</code>
fails, you can find out the reason by looking at the value of the
variable <code>h_errno</code>.  (It would be cleaner design for these
functions to set <code>errno</code>, but use of <code>h_errno</code> is compatible
with other systems.)
</para>
<para>Here are the error codes that you may find in <code>h_errno</code>:
</para>
<dl compact="compact">
<dt xml:id="glibc-index-HOST_005fNOT_005fFOUND"><span><code>HOST_NOT_FOUND</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-HOST_005fNOT_005fFOUND" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>No such host is known in the database.
</para>
</dd>
<dt xml:id="glibc-index-TRY_005fAGAIN"><span><code>TRY_AGAIN</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-TRY_005fAGAIN" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>This condition happens when the name server could not be contacted.  If
you try again later, you may succeed then.
</para>
</dd>
<dt xml:id="glibc-index-NO_005fRECOVERY"><span><code>NO_RECOVERY</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-NO_005fRECOVERY" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>A non-recoverable error occurred.
</para>
</dd>
<dt xml:id="glibc-index-NO_005fADDRESS"><span><code>NO_ADDRESS</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-NO_005fADDRESS" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>The host database contains an entry for the name, but it doesn’t have an
associated Internet address.
</para></dd>
</dl>

<para>The lookup functions above all have one thing in common: they are not
reentrant and therefore unusable in multi-threaded applications.
Therefore provides the GNU C Library a new set of functions which can be
used in this context.
</para>
<dl class="def">
<dt xml:id="glibc-index-gethostbyname_005fr"><span class="category">Function: </span><span><emphasis>int</emphasis> <strong>gethostbyname_r</strong> <emphasis>(const char *restrict <var>name</var>, struct hostent *restrict <var>result_buf</var>, char *restrict <var>buf</var>, size_t <var>buflen</var>, struct hostent **restrict <var>result</var>, int *restrict <var>h_errnop</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-gethostbyname_005fr" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe env locale
| AS-Unsafe dlopen plugin corrupt heap lock
| AC-Unsafe lock corrupt mem fd
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>The <code>gethostbyname_r</code> function returns information about the host
named <var>name</var>.  The caller must pass a pointer to an object of type
<code>struct hostent</code> in the <var>result_buf</var> parameter.  In addition
the function may need extra buffer space and the caller must pass a
pointer and the size of the buffer in the <var>buf</var> and <var>buflen</var>
parameters.
</para>
<para>A pointer to the buffer, in which the result is stored, is available in
<code>*<var>result</var></code> after the function call successfully returned.  The
buffer passed as the <var>buf</var> parameter can be freed only once the caller
has finished with the result hostent struct, or has copied it including all
the other memory that it points to.  If an error occurs or if no entry is
found, the pointer <code>*<var>result</var></code> is a null pointer.  Success is
signalled by a zero return value.  If the function failed the return value
is an error number.  In addition to the errors defined for
<code>gethostbyname</code> it can also be <code>ERANGE</code>.  In this case the call
should be repeated with a larger buffer.  Additional error information is
not stored in the global variable <code>h_errno</code> but instead in the object
pointed to by <var>h_errnop</var>.
</para>
<para>Here’s a small example:
</para><div class="example">
<pre class="example">struct hostent *
gethostname (char *host)
{
  struct hostent *hostbuf, *hp;
  size_t hstbuflen;
  char *tmphstbuf;
  int res;
  int herr;

  hostbuf = malloc (sizeof (struct hostent));
  hstbuflen = 1024;
  tmphstbuf = malloc (hstbuflen);

  while ((res = gethostbyname_r (host, hostbuf, tmphstbuf, hstbuflen,
                                 &amp;hp, &amp;herr)) == ERANGE)
    {
      /* Enlarge the buffer.  */
      tmphstbuf = reallocarray (tmphstbuf, hstbuflen, 2);
      hstbuflen *= 2;
    }

  free (tmphstbuf);
  /*  Check for errors.  */
  if (res || hp == NULL)
    return NULL;
  return hp;
}
</pre></div>
</dd></dl>

<dl class="def">
<dt xml:id="glibc-index-gethostbyname2_005fr"><span class="category">Function: </span><span><emphasis>int</emphasis> <strong>gethostbyname2_r</strong> <emphasis>(const char *<var>name</var>, int <var>af</var>, struct hostent *restrict <var>result_buf</var>, char *restrict <var>buf</var>, size_t <var>buflen</var>, struct hostent **restrict <var>result</var>, int *restrict <var>h_errnop</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-gethostbyname2_005fr" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe env locale
| AS-Unsafe dlopen plugin corrupt heap lock
| AC-Unsafe lock corrupt mem fd
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>The <code>gethostbyname2_r</code> function is like <code>gethostbyname_r</code>, but
allows the caller to specify the desired address family (e.g.
<code>AF_INET</code> or <code>AF_INET6</code>) for the result.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-gethostbyaddr_005fr"><span class="category">Function: </span><span><emphasis>int</emphasis> <strong>gethostbyaddr_r</strong> <emphasis>(const void *<var>addr</var>, socklen_t <var>length</var>, int <var>format</var>, struct hostent *restrict <var>result_buf</var>, char *restrict <var>buf</var>, size_t <var>buflen</var>, struct hostent **restrict <var>result</var>, int *restrict <var>h_errnop</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-gethostbyaddr_005fr" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe env locale
| AS-Unsafe dlopen plugin corrupt heap lock
| AC-Unsafe lock corrupt mem fd
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>The <code>gethostbyaddr_r</code> function returns information about the host
with Internet address <var>addr</var>.  The parameter <var>addr</var> is not
really a pointer to char - it can be a pointer to an IPv4 or an IPv6
address.  The <var>length</var> argument is the size (in bytes) of the address
at <var>addr</var>.  <var>format</var> specifies the address format; for an IPv4
Internet address, specify a value of <code>AF_INET</code>; for an IPv6
Internet address, use <code>AF_INET6</code>.
</para>
<para>Similar to the <code>gethostbyname_r</code> function, the caller must provide
buffers for the result and memory used internally.  In case of success
the function returns zero.  Otherwise the value is an error number where
<code>ERANGE</code> has the special meaning that the caller-provided buffer is
too small.
</para></dd></dl>

<para>You can also scan the entire hosts database one entry at a time using
<code>sethostent</code>, <code>gethostent</code> and <code>endhostent</code>.  Be careful
when using these functions because they are not reentrant.
</para>
<dl class="def">
<dt xml:id="glibc-index-sethostent"><span class="category">Function: </span><span><emphasis>void</emphasis> <strong>sethostent</strong> <emphasis>(int <var>stayopen</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-sethostent" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Unsafe race:hostent env locale
| AS-Unsafe dlopen plugin heap lock
| AC-Unsafe corrupt lock fd mem
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>This function opens the hosts database to begin scanning it.  You can
then call <code>gethostent</code> to read the entries.
</para>
<para>If the <var>stayopen</var> argument is nonzero, this sets a flag so that
subsequent calls to <code>gethostbyname</code> or <code>gethostbyaddr</code> will
not close the database (as they usually would).  This makes for more
efficiency if you call those functions several times, by avoiding
reopening the database for each call.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-gethostent"><span class="category">Function: </span><span><emphasis>struct hostent *</emphasis> <strong>gethostent</strong> <emphasis>(void)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-gethostent" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Unsafe race:hostent race:hostentbuf env locale
| AS-Unsafe dlopen plugin heap lock
| AC-Unsafe corrupt lock fd mem
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>


<para>This function returns the next entry in the hosts database.  It
returns a null pointer if there are no more entries.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-endhostent"><span class="category">Function: </span><span><emphasis>void</emphasis> <strong>endhostent</strong> <emphasis>(void)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-endhostent" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Unsafe race:hostent env locale
| AS-Unsafe dlopen plugin heap lock
| AC-Unsafe corrupt lock fd mem
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>This function closes the hosts database.
</para></dd></dl>

<hr>
</div>
</div>
<div class="subsection" xml:id="glibc-Ports">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Services-Database" accesskey="n" rel="next">The Services Database</a>, Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Host-Addresses" accesskey="p" rel="prev">Host Addresses</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Internet-Namespace" accesskey="u" rel="up">The Internet Namespace</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Internet-Ports"></span><h4 class="subsection">16.6.3 Internet Ports</title>
<span xml:id="glibc-index-port-number"></span>

<para>A socket address in the Internet namespace consists of a machine’s
Internet address plus a <emphasis>port number</emphasis> which distinguishes the
sockets on a given machine (for a given protocol).  Port numbers range
from 0 to 65,535.
</para>
<para>Port numbers less than <code>IPPORT_RESERVED</code> are reserved for standard
servers, such as <code>finger</code> and <code>telnet</code>.  There is a database
that keeps track of these, and you can use the <code>getservbyname</code>
function to map a service name onto a port number; see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Services-Database">The Services Database</a>.
</para>
<para>If you write a server that is not one of the standard ones defined in
the database, you must choose a port number for it.  Use a number
greater than <code>IPPORT_USERRESERVED</code>; such numbers are reserved for
servers and won’t ever be generated automatically by the system.
Avoiding conflicts with servers being run by other users is up to you.
</para>
<para>When you use a socket without specifying its address, the system
generates a port number for it.  This number is between
<code>IPPORT_RESERVED</code> and <code>IPPORT_USERRESERVED</code>.
</para>
<para>On the Internet, it is actually legitimate to have two different
sockets with the same port number, as long as they never both try to
communicate with the same socket address (host address plus port
number).  You shouldn’t duplicate a port number except in special
circumstances where a higher-level protocol requires it.  Normally,
the system won’t let you do it; <code>bind</code> normally insists on
distinct port numbers.  To reuse a port number, you must set the
socket option <code>SO_REUSEADDR</code>.  See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Socket_002dLevel-Options">Socket-Level Options</a>.
</para>
<span xml:id="glibc-index-netinet_002fin_002eh-2"></span>
<para>These macros are defined in the header file <filename>netinet/in.h</filename>.
</para>
<dl class="def">
<dt xml:id="glibc-index-IPPORT_005fRESERVED"><span class="category">Macro: </span><span><emphasis>int</emphasis> <strong>IPPORT_RESERVED</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-IPPORT_005fRESERVED" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Port numbers less than <code>IPPORT_RESERVED</code> are reserved for
superuser use.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-IPPORT_005fUSERRESERVED"><span class="category">Macro: </span><span><emphasis>int</emphasis> <strong>IPPORT_USERRESERVED</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-IPPORT_005fUSERRESERVED" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Port numbers greater than or equal to <code>IPPORT_USERRESERVED</code> are
reserved for explicit use; they will never be allocated automatically.
</para></dd></dl>

<hr>
</div>
<div class="subsection" xml:id="glibc-Services-Database">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Byte-Order" accesskey="n" rel="next">Byte Order Conversion</a>, Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Ports" accesskey="p" rel="prev">Internet Ports</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Internet-Namespace" accesskey="u" rel="up">The Internet Namespace</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-The-Services-Database"></span><h4 class="subsection">16.6.4 The Services Database</title>
<span xml:id="glibc-index-services-database"></span>
<span xml:id="glibc-index-converting-service-name-to-port-number"></span>
<span xml:id="glibc-index-converting-port-number-to-service-name"></span>

<span xml:id="glibc-index-_002fetc_002fservices"></span>
<para>The database that keeps track of “well-known” services is usually
either the file <filename>/etc/services</filename> or an equivalent from a name server.
You can use these utilities, declared in <filename>netdb.h</filename>, to access
the services database.
<span xml:id="glibc-index-netdb_002eh-1"></span>
</para>
<dl class="def">
<dt xml:id="glibc-index-struct-servent"><span class="category">Data Type: </span><span><strong>struct servent</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-struct-servent" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>This data type holds information about entries from the services database.
It has the following members:
</para>
<dl compact="compact">
<dt><span><code>char *s_name</code></span></dt>
<dd><para>This is the “official” name of the service.
</para>
</dd>
<dt><span><code>char **s_aliases</code></span></dt>
<dd><para>These are alternate names for the service, represented as an array of
strings.  A null pointer terminates the array.
</para>
</dd>
<dt><span><code>int s_port</code></span></dt>
<dd><para>This is the port number for the service.  Port numbers are given in
network byte order; see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Byte-Order">Byte Order Conversion</a>.
</para>
</dd>
<dt><span><code>char *s_proto</code></span></dt>
<dd><para>This is the name of the protocol to use with this service.
See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Protocols-Database">Protocols Database</a>.
</para></dd>
</dl>
</dd></dl>

<para>To get information about a particular service, use the
<code>getservbyname</code> or <code>getservbyport</code> functions.  The information
is returned in a statically-allocated structure; you must copy the
information if you need to save it across calls.
</para>
<dl class="def">
<dt xml:id="glibc-index-getservbyname"><span class="category">Function: </span><span><emphasis>struct servent *</emphasis> <strong>getservbyname</strong> <emphasis>(const char *<var>name</var>, const char *<var>proto</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-getservbyname" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Unsafe race:servbyname locale
| AS-Unsafe dlopen plugin heap lock
| AC-Unsafe corrupt lock fd mem
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>The <code>getservbyname</code> function returns information about the
service named <var>name</var> using protocol <var>proto</var>.  If it can’t find
such a service, it returns a null pointer.
</para>
<para>This function is useful for servers as well as for clients; servers
use it to determine which port they should listen on (see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Listening">Listening for Connections</a>).
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-getservbyport"><span class="category">Function: </span><span><emphasis>struct servent *</emphasis> <strong>getservbyport</strong> <emphasis>(int <var>port</var>, const char *<var>proto</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-getservbyport" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Unsafe race:servbyport locale
| AS-Unsafe dlopen plugin heap lock
| AC-Unsafe corrupt lock fd mem
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>The <code>getservbyport</code> function returns information about the
service at port <var>port</var> using protocol <var>proto</var>.  If it can’t
find such a service, it returns a null pointer.
</para></dd></dl>

<para>You can also scan the services database using <code>setservent</code>,
<code>getservent</code> and <code>endservent</code>.  Be careful when using these
functions because they are not reentrant.
</para>
<dl class="def">
<dt xml:id="glibc-index-setservent"><span class="category">Function: </span><span><emphasis>void</emphasis> <strong>setservent</strong> <emphasis>(int <var>stayopen</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-setservent" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Unsafe race:servent locale
| AS-Unsafe dlopen plugin heap lock
| AC-Unsafe corrupt lock fd mem
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>This function opens the services database to begin scanning it.
</para>
<para>If the <var>stayopen</var> argument is nonzero, this sets a flag so that
subsequent calls to <code>getservbyname</code> or <code>getservbyport</code> will
not close the database (as they usually would).  This makes for more
efficiency if you call those functions several times, by avoiding
reopening the database for each call.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-getservent"><span class="category">Function: </span><span><emphasis>struct servent *</emphasis> <strong>getservent</strong> <emphasis>(void)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-getservent" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Unsafe race:servent race:serventbuf locale
| AS-Unsafe dlopen plugin heap lock
| AC-Unsafe corrupt lock fd mem
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>This function returns the next entry in the services database.  If
there are no more entries, it returns a null pointer.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-endservent"><span class="category">Function: </span><span><emphasis>void</emphasis> <strong>endservent</strong> <emphasis>(void)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-endservent" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Unsafe race:servent locale
| AS-Unsafe dlopen plugin heap lock
| AC-Unsafe corrupt lock fd mem
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>This function closes the services database.
</para></dd></dl>

<hr>
</div>
<div class="subsection" xml:id="glibc-Byte-Order">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Protocols-Database" accesskey="n" rel="next">Protocols Database</a>, Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Services-Database" accesskey="p" rel="prev">The Services Database</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Internet-Namespace" accesskey="u" rel="up">The Internet Namespace</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Byte-Order-Conversion"></span><h4 class="subsection">16.6.5 Byte Order Conversion</title>
<span xml:id="glibc-index-byte-order-conversion_002c-for-socket"></span>
<span xml:id="glibc-index-converting-byte-order"></span>

<span xml:id="glibc-index-big_002dendian"></span>
<span xml:id="glibc-index-little_002dendian"></span>
<para>Different kinds of computers use different conventions for the
ordering of bytes within a word.  Some computers put the most
significant byte within a word first (this is called “big-endian”
order), and others put it last (“little-endian” order).
</para>
<span xml:id="glibc-index-network-byte-order"></span>
<para>So that machines with different byte order conventions can
communicate, the Internet protocols specify a canonical byte order
convention for data transmitted over the network.  This is known
as <emphasis>network byte order</emphasis>.
</para>
<para>When establishing an Internet socket connection, you must make sure that
the data in the <code>sin_port</code> and <code>sin_addr</code> members of the
<code>sockaddr_in</code> structure are represented in network byte order.
If you are encoding integer data in the messages sent through the
socket, you should convert this to network byte order too.  If you don’t
do this, your program may fail when running on or talking to other kinds
of machines.
</para>
<para>If you use <code>getservbyname</code> and <code>gethostbyname</code> or
<code>inet_addr</code> to get the port number and host address, the values are
already in network byte order, and you can copy them directly into
the <code>sockaddr_in</code> structure.
</para>
<para>Otherwise, you have to convert the values explicitly.  Use <code>htons</code>
and <code>ntohs</code> to convert values for the <code>sin_port</code> member.  Use
<code>htonl</code> and <code>ntohl</code> to convert IPv4 addresses for the
<code>sin_addr</code> member.  (Remember, <code>struct in_addr</code> is equivalent
to <code>uint32_t</code>.)  These functions are declared in
<filename>netinet/in.h</filename>.
<span xml:id="glibc-index-netinet_002fin_002eh-3"></span>
</para>
<dl class="def">
<dt xml:id="glibc-index-htons"><span class="category">Function: </span><span><emphasis>uint16_t</emphasis> <strong>htons</strong> <emphasis>(uint16_t <var>hostshort</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-htons" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Safe
| AC-Safe
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>


<para>This function converts the <code>uint16_t</code> integer <var>hostshort</var> from
host byte order to network byte order.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-ntohs"><span class="category">Function: </span><span><emphasis>uint16_t</emphasis> <strong>ntohs</strong> <emphasis>(uint16_t <var>netshort</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-ntohs" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Safe
| AC-Safe
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>This function converts the <code>uint16_t</code> integer <var>netshort</var> from
network byte order to host byte order.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-htonl"><span class="category">Function: </span><span><emphasis>uint32_t</emphasis> <strong>htonl</strong> <emphasis>(uint32_t <var>hostlong</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-htonl" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Safe
| AC-Safe
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>This function converts the <code>uint32_t</code> integer <var>hostlong</var> from
host byte order to network byte order.
</para>
<para>This is used for IPv4 Internet addresses.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-ntohl"><span class="category">Function: </span><span><emphasis>uint32_t</emphasis> <strong>ntohl</strong> <emphasis>(uint32_t <var>netlong</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-ntohl" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Safe
| AC-Safe
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>This function converts the <code>uint32_t</code> integer <var>netlong</var> from
network byte order to host byte order.
</para>
<para>This is used for IPv4 Internet addresses.
</para></dd></dl>

<hr>
</div>
<div class="subsection" xml:id="glibc-Protocols-Database">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Inet-Example" accesskey="n" rel="next">Internet Socket Example</a>, Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Byte-Order" accesskey="p" rel="prev">Byte Order Conversion</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Internet-Namespace" accesskey="u" rel="up">The Internet Namespace</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Protocols-Database-1"></span><h4 class="subsection">16.6.6 Protocols Database</title>
<span xml:id="glibc-index-protocols-database"></span>

<para>The communications protocol used with a socket controls low-level
details of how data are exchanged.  For example, the protocol implements
things like checksums to detect errors in transmissions, and routing
instructions for messages.  Normal user programs have little reason to
mess with these details directly.
</para>
<span xml:id="glibc-index-TCP-_0028Internet-protocol_0029"></span>
<para>The default communications protocol for the Internet namespace depends on
the communication style.  For stream communication, the default is TCP
(“transmission control protocol”).  For datagram communication, the
default is UDP (“user datagram protocol”).  For reliable datagram
communication, the default is RDP (“reliable datagram protocol”).
You should nearly always use the default.
</para>
<span xml:id="glibc-index-_002fetc_002fprotocols"></span>
<para>Internet protocols are generally specified by a name instead of a
number.  The network protocols that a host knows about are stored in a
database.  This is usually either derived from the file
<filename>/etc/protocols</filename>, or it may be an equivalent provided by a name
server.  You look up the protocol number associated with a named
protocol in the database using the <code>getprotobyname</code> function.
</para>
<para>Here are detailed descriptions of the utilities for accessing the
protocols database.  These are declared in <filename>netdb.h</filename>.
<span xml:id="glibc-index-netdb_002eh-2"></span>
</para>
<dl class="def">
<dt xml:id="glibc-index-struct-protoent"><span class="category">Data Type: </span><span><strong>struct protoent</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-struct-protoent" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>This data type is used to represent entries in the network protocols
database.  It has the following members:
</para>
<dl compact="compact">
<dt><span><code>char *p_name</code></span></dt>
<dd><para>This is the official name of the protocol.
</para>
</dd>
<dt><span><code>char **p_aliases</code></span></dt>
<dd><para>These are alternate names for the protocol, specified as an array of
strings.  The last element of the array is a null pointer.
</para>
</dd>
<dt><span><code>int p_proto</code></span></dt>
<dd><para>This is the protocol number (in host byte order); use this member as the
<var>protocol</var> argument to <code>socket</code>.
</para></dd>
</dl>
</dd></dl>

<para>You can use <code>getprotobyname</code> and <code>getprotobynumber</code> to search
the protocols database for a specific protocol.  The information is
returned in a statically-allocated structure; you must copy the
information if you need to save it across calls.
</para>
<dl class="def">
<dt xml:id="glibc-index-getprotobyname"><span class="category">Function: </span><span><emphasis>struct protoent *</emphasis> <strong>getprotobyname</strong> <emphasis>(const char *<var>name</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-getprotobyname" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Unsafe race:protobyname locale
| AS-Unsafe dlopen plugin heap lock
| AC-Unsafe corrupt lock fd mem
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>The <code>getprotobyname</code> function returns information about the
network protocol named <var>name</var>.  If there is no such protocol, it
returns a null pointer.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-getprotobynumber"><span class="category">Function: </span><span><emphasis>struct protoent *</emphasis> <strong>getprotobynumber</strong> <emphasis>(int <var>protocol</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-getprotobynumber" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Unsafe race:protobynumber locale
| AS-Unsafe dlopen plugin heap lock
| AC-Unsafe corrupt lock fd mem
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>The <code>getprotobynumber</code> function returns information about the
network protocol with number <var>protocol</var>.  If there is no such
protocol, it returns a null pointer.
</para></dd></dl>

<para>You can also scan the whole protocols database one protocol at a time by
using <code>setprotoent</code>, <code>getprotoent</code> and <code>endprotoent</code>.
Be careful when using these functions because they are not reentrant.
</para>
<dl class="def">
<dt xml:id="glibc-index-setprotoent"><span class="category">Function: </span><span><emphasis>void</emphasis> <strong>setprotoent</strong> <emphasis>(int <var>stayopen</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-setprotoent" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Unsafe race:protoent locale
| AS-Unsafe dlopen plugin heap lock
| AC-Unsafe corrupt lock fd mem
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>This function opens the protocols database to begin scanning it.
</para>
<para>If the <var>stayopen</var> argument is nonzero, this sets a flag so that
subsequent calls to <code>getprotobyname</code> or <code>getprotobynumber</code> will
not close the database (as they usually would).  This makes for more
efficiency if you call those functions several times, by avoiding
reopening the database for each call.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-getprotoent"><span class="category">Function: </span><span><emphasis>struct protoent *</emphasis> <strong>getprotoent</strong> <emphasis>(void)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-getprotoent" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Unsafe race:protoent race:protoentbuf locale
| AS-Unsafe dlopen plugin heap lock
| AC-Unsafe corrupt lock fd mem
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>This function returns the next entry in the protocols database.  It
returns a null pointer if there are no more entries.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-endprotoent"><span class="category">Function: </span><span><emphasis>void</emphasis> <strong>endprotoent</strong> <emphasis>(void)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-endprotoent" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Unsafe race:protoent locale
| AS-Unsafe dlopen plugin heap lock
| AC-Unsafe corrupt lock fd mem
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>This function closes the protocols database.
</para></dd></dl>

<hr>
</div>
<div class="subsection" xml:id="glibc-Inet-Example">
<div class="header">
<para>
Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Protocols-Database" accesskey="p" rel="prev">Protocols Database</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Internet-Namespace" accesskey="u" rel="up">The Internet Namespace</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Internet-Socket-Example"></span><h4 class="subsection">16.6.7 Internet Socket Example</title>

<para>Here is an example showing how to create and name a socket in the
Internet namespace.  The newly created socket exists on the machine that
the program is running on.  Rather than finding and using the machine’s
Internet address, this example specifies <code>INADDR_ANY</code> as the host
address; the system replaces that with the machine’s actual address.
</para>
<div class="example">
<pre class="example">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;

int
make_socket (uint16_t port)
{
  int sock;
  struct sockaddr_in name;

  /* <span class="roman">Create the socket.</span> */
  sock = socket (PF_INET, SOCK_STREAM, 0);
  if (sock &lt; 0)
    {
      perror ("socket");
      exit (EXIT_FAILURE);
    }

  /* <span class="roman">Give the socket a name.</span> */
  name.sin_family = AF_INET;
  name.sin_port = htons (port);
  name.sin_addr.s_addr = htonl (INADDR_ANY);
  if (bind (sock, (struct sockaddr *) &amp;name, sizeof (name)) &lt; 0)
    {
      perror ("bind");
      exit (EXIT_FAILURE);
    }

  return sock;
}
</pre></div>

<para>Here is another example, showing how you can fill in a <code>sockaddr_in</code>
structure, given a host name string and a port number:
</para>
<div class="example">
<pre class="example">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netdb.h&gt;

void
init_sockaddr (struct sockaddr_in *name,
               const char *hostname,
               uint16_t port)
{
  struct hostent *hostinfo;

  name-&gt;sin_family = AF_INET;
  name-&gt;sin_port = htons (port);
  hostinfo = gethostbyname (hostname);
  if (hostinfo == NULL)
    {
      fprintf (stderr, "Unknown host %s.\n", hostname);
      exit (EXIT_FAILURE);
    }
  name-&gt;sin_addr = *(struct in_addr *) hostinfo-&gt;h_addr;
}
</pre></div>

<hr>
</div>
</div>
<sect xml:id="glibc-Misc-Namespaces">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Open_002fClose-Sockets" accesskey="n" rel="next">Opening and Closing Sockets</a>, Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Internet-Namespace" accesskey="p" rel="prev">The Internet Namespace</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Sockets" accesskey="u" rel="up">Sockets</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Other-Namespaces"></span><h3 class="section">16.7 Other Namespaces</title>

<span xml:id="glibc-index-PF_005fNS"></span>
<span xml:id="glibc-index-PF_005fISO"></span>
<span xml:id="glibc-index-PF_005fCCITT"></span>
<span xml:id="glibc-index-PF_005fIMPLINK"></span>
<span xml:id="glibc-index-PF_005fROUTE"></span>
<para>Certain other namespaces and associated protocol families are supported
but not documented yet because they are not often used.  <code>PF_NS</code>
refers to the Xerox Network Software protocols.  <code>PF_ISO</code> stands
for Open Systems Interconnect.  <code>PF_CCITT</code> refers to protocols from
CCITT.  <filename>socket.h</filename> defines these symbols and others naming protocols
not actually implemented.
</para>
<para><code>PF_IMPLINK</code> is used for communicating between hosts and Internet
Message Processors.  For information on this and <code>PF_ROUTE</code>, an
occasionally-used local area routing protocol, see the GNU Hurd Manual
(to appear in the future).
</para>
<hr>
</div>
<sect xml:id="glibc-Open_002fClose-Sockets">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Connections" accesskey="n" rel="next">Using Sockets with Connections</a>, Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Misc-Namespaces" accesskey="p" rel="prev">Other Namespaces</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Sockets" accesskey="u" rel="up">Sockets</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Opening-and-Closing-Sockets"></span><h3 class="section">16.8 Opening and Closing Sockets</title>

<para>This section describes the actual library functions for opening and
closing sockets.  The same functions work for all namespaces and
connection styles.
</para>

<ul class="section-toc">
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Creating-a-Socket" accesskey="1">Creating a Socket</a></li>
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Closing-a-Socket" accesskey="2">Closing a Socket</a></li>
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Socket-Pairs" accesskey="3">Socket Pairs</a></li>
</ul>
<hr>
<div class="subsection" xml:id="glibc-Creating-a-Socket">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Closing-a-Socket" accesskey="n" rel="next">Closing a Socket</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Open_002fClose-Sockets" accesskey="u" rel="up">Opening and Closing Sockets</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Creating-a-Socket-1"></span><h4 class="subsection">16.8.1 Creating a Socket</title>
<span xml:id="glibc-index-creating-a-socket"></span>
<span xml:id="glibc-index-socket_002c-creating"></span>
<span xml:id="glibc-index-opening-a-socket"></span>

<para>The primitive for creating a socket is the <code>socket</code> function,
declared in <filename>sys/socket.h</filename>.
<span xml:id="glibc-index-sys_002fsocket_002eh-6"></span>
</para>
<dl class="def">
<dt xml:id="glibc-index-socket-1"><span class="category">Function: </span><span><emphasis>int</emphasis> <strong>socket</strong> <emphasis>(int <var>namespace</var>, int <var>style</var>, int <var>protocol</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-socket-1" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Safe
| AC-Safe fd
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>This function creates a socket and specifies communication style
<var>style</var>, which should be one of the socket styles listed in
<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Communication-Styles">Communication Styles</a>.  The <var>namespace</var> argument specifies
the namespace; it must be <code>PF_LOCAL</code> (see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Local-Namespace">The Local Namespace</a>) or
<code>PF_INET</code> (see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Internet-Namespace">The Internet Namespace</a>).  <var>protocol</var>
designates the specific protocol (see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Socket-Concepts">Socket Concepts</a>); zero is
usually right for <var>protocol</var>.
</para>
<para>The return value from <code>socket</code> is the file descriptor for the new
socket, or <code>-1</code> in case of error.  The following <code>errno</code> error
conditions are defined for this function:
</para>
<dl compact="compact">
<dt><span><code>EPROTONOSUPPORT</code></span></dt>
<dd><para>The <var>protocol</var> or <var>style</var> is not supported by the
<var>namespace</var> specified.
</para>
</dd>
<dt><span><code>EMFILE</code></span></dt>
<dd><para>The process already has too many file descriptors open.
</para>
</dd>
<dt><span><code>ENFILE</code></span></dt>
<dd><para>The system already has too many file descriptors open.
</para>
</dd>
<dt><span><code>EACCES</code></span></dt>
<dd><para>The process does not have the privilege to create a socket of the specified
<var>style</var> or <var>protocol</var>.
</para>
</dd>
<dt><span><code>ENOBUFS</code></span></dt>
<dd><para>The system ran out of internal buffer space.
</para></dd>
</dl>

<para>The file descriptor returned by the <code>socket</code> function supports both
read and write operations.  However, like pipes, sockets do not support file
positioning operations.
</para></dd></dl>

<para>For examples of how to call the <code>socket</code> function,
see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Local-Socket-Example">Example of Local-Namespace Sockets</a>, or <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Inet-Example">Internet Socket Example</a>.
</para>

<hr>
</div>
<div class="subsection" xml:id="glibc-Closing-a-Socket">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Socket-Pairs" accesskey="n" rel="next">Socket Pairs</a>, Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Creating-a-Socket" accesskey="p" rel="prev">Creating a Socket</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Open_002fClose-Sockets" accesskey="u" rel="up">Opening and Closing Sockets</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Closing-a-Socket-1"></span><h4 class="subsection">16.8.2 Closing a Socket</title>
<span xml:id="glibc-index-socket_002c-closing"></span>
<span xml:id="glibc-index-closing-a-socket"></span>
<span xml:id="glibc-index-shutting-down-a-socket"></span>
<span xml:id="glibc-index-socket-shutdown"></span>

<para>When you have finished using a socket, you can simply close its
file descriptor with <code>close</code>; see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Opening-and-Closing-Files">Opening and Closing Files</a>.
If there is still data waiting to be transmitted over the connection,
normally <code>close</code> tries to complete this transmission.  You
can control this behavior using the <code>SO_LINGER</code> socket option to
specify a timeout period; see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Socket-Options">Socket Options</a>.
</para>
<span xml:id="glibc-index-sys_002fsocket_002eh-7"></span>
<para>You can also shut down only reception or transmission on a
connection by calling <code>shutdown</code>, which is declared in
<filename>sys/socket.h</filename>.
</para>
<dl class="def">
<dt xml:id="glibc-index-shutdown"><span class="category">Function: </span><span><emphasis>int</emphasis> <strong>shutdown</strong> <emphasis>(int <var>socket</var>, int <var>how</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-shutdown" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Safe
| AC-Safe
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>The <code>shutdown</code> function shuts down the connection of socket
<var>socket</var>.  The argument <var>how</var> specifies what action to
perform:
</para>
<dl compact="compact">
<dt><span><code>0</code></span></dt>
<dd><para>Stop receiving data for this socket.  If further data arrives,
reject it.
</para>
</dd>
<dt><span><code>1</code></span></dt>
<dd><para>Stop trying to transmit data from this socket.  Discard any data
waiting to be sent.  Stop looking for acknowledgement of data already
sent; don’t retransmit it if it is lost.
</para>
</dd>
<dt><span><code>2</code></span></dt>
<dd><para>Stop both reception and transmission.
</para></dd>
</dl>

<para>The return value is <code>0</code> on success and <code>-1</code> on failure.  The
following <code>errno</code> error conditions are defined for this function:
</para>
<dl compact="compact">
<dt><span><code>EBADF</code></span></dt>
<dd><para><var>socket</var> is not a valid file descriptor.
</para>
</dd>
<dt><span><code>ENOTSOCK</code></span></dt>
<dd><para><var>socket</var> is not a socket.
</para>
</dd>
<dt><span><code>ENOTCONN</code></span></dt>
<dd><para><var>socket</var> is not connected.
</para></dd>
</dl>
</dd></dl>

<hr>
</div>
<div class="subsection" xml:id="glibc-Socket-Pairs">
<div class="header">
<para>
Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Closing-a-Socket" accesskey="p" rel="prev">Closing a Socket</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Open_002fClose-Sockets" accesskey="u" rel="up">Opening and Closing Sockets</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Socket-Pairs-1"></span><h4 class="subsection">16.8.3 Socket Pairs</title>
<span xml:id="glibc-index-creating-a-socket-pair"></span>
<span xml:id="glibc-index-socket-pair"></span>
<span xml:id="glibc-index-opening-a-socket-pair"></span>

<span xml:id="glibc-index-sys_002fsocket_002eh-8"></span>
<para>A <emphasis>socket pair</emphasis> consists of a pair of connected (but unnamed)
sockets.  It is very similar to a pipe and is used in much the same
way.  Socket pairs are created with the <code>socketpair</code> function,
declared in <filename>sys/socket.h</filename>.  A socket pair is much like a pipe; the
main difference is that the socket pair is bidirectional, whereas the
pipe has one input-only end and one output-only end (see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Pipes-and-FIFOs">Pipes and FIFOs</a>).
</para>
<dl class="def">
<dt xml:id="glibc-index-socketpair"><span class="category">Function: </span><span><emphasis>int</emphasis> <strong>socketpair</strong> <emphasis>(int <var>namespace</var>, int <var>style</var>, int <var>protocol</var>, int <var>filedes</var><tt>[2]</tt>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-socketpair" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Safe
| AC-Safe fd
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>This function creates a socket pair, returning the file descriptors in
<code><var>filedes</var>[0]</code> and <code><var>filedes</var>[1]</code>.  The socket pair
is a full-duplex communications channel, so that both reading and writing
may be performed at either end.
</para>
<para>The <var>namespace</var>, <var>style</var> and <var>protocol</var> arguments are
interpreted as for the <code>socket</code> function.  <var>style</var> should be
one of the communication styles listed in <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Communication-Styles">Communication Styles</a>.
The <var>namespace</var> argument specifies the namespace, which must be
<code>AF_LOCAL</code> (see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Local-Namespace">The Local Namespace</a>); <var>protocol</var> specifies the
communications protocol, but zero is the only meaningful value.
</para>
<para>If <var>style</var> specifies a connectionless communication style, then
the two sockets you get are not <emphasis>connected</emphasis>, strictly speaking,
but each of them knows the other as the default destination address,
so they can send packets to each other.
</para>
<para>The <code>socketpair</code> function returns <code>0</code> on success and <code>-1</code>
on failure.  The following <code>errno</code> error conditions are defined
for this function:
</para>
<dl compact="compact">
<dt><span><code>EMFILE</code></span></dt>
<dd><para>The process has too many file descriptors open.
</para>
</dd>
<dt><span><code>EAFNOSUPPORT</code></span></dt>
<dd><para>The specified namespace is not supported.
</para>
</dd>
<dt><span><code>EPROTONOSUPPORT</code></span></dt>
<dd><para>The specified protocol is not supported.
</para>
</dd>
<dt><span><code>EOPNOTSUPP</code></span></dt>
<dd><para>The specified protocol does not support the creation of socket pairs.
</para></dd>
</dl>
</dd></dl>

<hr>
</div>
</div>
<sect xml:id="glibc-Connections">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Datagrams" accesskey="n" rel="next">Datagram Socket Operations</a>, Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Open_002fClose-Sockets" accesskey="p" rel="prev">Opening and Closing Sockets</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Sockets" accesskey="u" rel="up">Sockets</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Using-Sockets-with-Connections"></span><h3 class="section">16.9 Using Sockets with Connections</title>

<span xml:id="glibc-index-connection"></span>
<span xml:id="glibc-index-client"></span>
<span xml:id="glibc-index-server"></span>
<para>The most common communication styles involve making a connection to a
particular other socket, and then exchanging data with that socket
over and over.  Making a connection is asymmetric; one side (the
<emphasis>client</emphasis>) acts to request a connection, while the other side (the
<emphasis>server</emphasis>) makes a socket and waits for the connection request.
</para>


<ul class="section-toc">
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Connecting" accesskey="1">Making a Connection</a></li>
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Listening" accesskey="2">Listening for Connections</a></li>
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Accepting-Connections" accesskey="3">Accepting Connections</a></li>
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Who-is-Connected" accesskey="4">Who is Connected to Me?</a></li>
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Transferring-Data" accesskey="5">Transferring Data</a></li>
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Byte-Stream-Example" accesskey="6">Byte Stream Socket Example</a></li>
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Server-Example" accesskey="7">Byte Stream Connection Server Example</a></li>
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Out_002dof_002dBand-Data" accesskey="8">Out-of-Band Data</a></li>
</ul>
<hr>
<div class="subsection" xml:id="glibc-Connecting">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Listening" accesskey="n" rel="next">Listening for Connections</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Connections" accesskey="u" rel="up">Using Sockets with Connections</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Making-a-Connection"></span><h4 class="subsection">16.9.1 Making a Connection</title>
<span xml:id="glibc-index-connecting-a-socket"></span>
<span xml:id="glibc-index-socket_002c-connecting"></span>
<span xml:id="glibc-index-socket_002c-initiating-a-connection"></span>
<span xml:id="glibc-index-socket_002c-client-actions"></span>

<para>In making a connection, the client makes a connection while the server
waits for and accepts the connection.  Here we discuss what the client
program must do with the <code>connect</code> function, which is declared in
<filename>sys/socket.h</filename>.
</para>
<dl class="def">
<dt xml:id="glibc-index-connect"><span class="category">Function: </span><span><emphasis>int</emphasis> <strong>connect</strong> <emphasis>(int <var>socket</var>, struct sockaddr *<var>addr</var>, socklen_t <var>length</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-connect" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Safe
| AC-Safe
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>The <code>connect</code> function initiates a connection from the socket
with file descriptor <var>socket</var> to the socket whose address is
specified by the <var>addr</var> and <var>length</var> arguments.  (This socket
is typically on another machine, and it must be already set up as a
server.)  See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Socket-Addresses">Socket Addresses</a>, for information about how these
arguments are interpreted.
</para>
<para>Normally, <code>connect</code> waits until the server responds to the request
before it returns.  You can set nonblocking mode on the socket
<var>socket</var> to make <code>connect</code> return immediately without waiting
for the response.  See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#File-Status-Flags">File Status Flags</a>, for information about
nonblocking mode.
</para>
<para>The normal return value from <code>connect</code> is <code>0</code>.  If an error
occurs, <code>connect</code> returns <code>-1</code>.  The following <code>errno</code>
error conditions are defined for this function:
</para>
<dl compact="compact">
<dt><span><code>EBADF</code></span></dt>
<dd><para>The socket <var>socket</var> is not a valid file descriptor.
</para>
</dd>
<dt><span><code>ENOTSOCK</code></span></dt>
<dd><para>File descriptor <var>socket</var> is not a socket.
</para>
</dd>
<dt><span><code>EADDRNOTAVAIL</code></span></dt>
<dd><para>The specified address is not available on the remote machine.
</para>
</dd>
<dt><span><code>EAFNOSUPPORT</code></span></dt>
<dd><para>The namespace of the <var>addr</var> is not supported by this socket.
</para>
</dd>
<dt><span><code>EISCONN</code></span></dt>
<dd><para>The socket <var>socket</var> is already connected.
</para>
</dd>
<dt><span><code>ETIMEDOUT</code></span></dt>
<dd><para>The attempt to establish the connection timed out.
</para>
</dd>
<dt><span><code>ECONNREFUSED</code></span></dt>
<dd><para>The server has actively refused to establish the connection.
</para>
</dd>
<dt><span><code>ENETUNREACH</code></span></dt>
<dd><para>The network of the given <var>addr</var> isn’t reachable from this host.
</para>
</dd>
<dt><span><code>EADDRINUSE</code></span></dt>
<dd><para>The socket address of the given <var>addr</var> is already in use.
</para>
</dd>
<dt><span><code>EINPROGRESS</code></span></dt>
<dd><para>The socket <var>socket</var> is non-blocking and the connection could not be
established immediately.  You can determine when the connection is
completely established with <code>select</code>; see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Waiting-for-I_002fO">Waiting for Input or Output</a>.
Another <code>connect</code> call on the same socket, before the connection is
completely established, will fail with <code>EALREADY</code>.
</para>
</dd>
<dt><span><code>EALREADY</code></span></dt>
<dd><para>The socket <var>socket</var> is non-blocking and already has a pending
connection in progress (see <code>EINPROGRESS</code> above).
</para></dd>
</dl>

<para>This function is defined as a cancellation point in multi-threaded
programs, so one has to be prepared for this and make sure that
allocated resources (like memory, file descriptors, semaphores or
whatever) are freed even if the thread is canceled.
</para></dd></dl>

<hr>
</div>
<div class="subsection" xml:id="glibc-Listening">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Accepting-Connections" accesskey="n" rel="next">Accepting Connections</a>, Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Connecting" accesskey="p" rel="prev">Making a Connection</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Connections" accesskey="u" rel="up">Using Sockets with Connections</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Listening-for-Connections"></span><h4 class="subsection">16.9.2 Listening for Connections</title>
<span xml:id="glibc-index-listening-_0028sockets_0029"></span>
<span xml:id="glibc-index-sockets_002c-server-actions"></span>
<span xml:id="glibc-index-sockets_002c-listening"></span>

<para>Now let us consider what the server process must do to accept
connections on a socket.  First it must use the <code>listen</code> function
to enable connection requests on the socket, and then accept each
incoming connection with a call to <code>accept</code> (see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Accepting-Connections">Accepting Connections</a>).  Once connection requests are enabled on a server socket,
the <code>select</code> function reports when the socket has a connection
ready to be accepted (see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Waiting-for-I_002fO">Waiting for Input or Output</a>).
</para>
<para>The <code>listen</code> function is not allowed for sockets using
connectionless communication styles.
</para>
<para>You can write a network server that does not even start running until a
connection to it is requested.  See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Inetd-Servers"><code>inetd</code> Servers</a>.
</para>
<para>In the Internet namespace, there are no special protection mechanisms
for controlling access to a port; any process on any machine
can make a connection to your server.  If you want to restrict access to
your server, make it examine the addresses associated with connection
requests or implement some other handshaking or identification
protocol.
</para>
<para>In the local namespace, the ordinary file protection bits control who has
access to connect to the socket.
</para>
<dl class="def">
<dt xml:id="glibc-index-listen"><span class="category">Function: </span><span><emphasis>int</emphasis> <strong>listen</strong> <emphasis>(int <var>socket</var>, int <var>n</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-listen" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Safe
| AC-Safe fd
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>The <code>listen</code> function enables the socket <var>socket</var> to accept
connections, thus making it a server socket.
</para>
<para>The argument <var>n</var> specifies the length of the queue for pending
connections.  When the queue fills, new clients attempting to connect
fail with <code>ECONNREFUSED</code> until the server calls <code>accept</code> to
accept a connection from the queue.
</para>
<para>The <code>listen</code> function returns <code>0</code> on success and <code>-1</code>
on failure.  The following <code>errno</code> error conditions are defined
for this function:
</para>
<dl compact="compact">
<dt><span><code>EBADF</code></span></dt>
<dd><para>The argument <var>socket</var> is not a valid file descriptor.
</para>
</dd>
<dt><span><code>ENOTSOCK</code></span></dt>
<dd><para>The argument <var>socket</var> is not a socket.
</para>
</dd>
<dt><span><code>EOPNOTSUPP</code></span></dt>
<dd><para>The socket <var>socket</var> does not support this operation.
</para></dd>
</dl>
</dd></dl>

<hr>
</div>
<div class="subsection" xml:id="glibc-Accepting-Connections">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Who-is-Connected" accesskey="n" rel="next">Who is Connected to Me?</a>, Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Listening" accesskey="p" rel="prev">Listening for Connections</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Connections" accesskey="u" rel="up">Using Sockets with Connections</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Accepting-Connections-1"></span><h4 class="subsection">16.9.3 Accepting Connections</title>
<span xml:id="glibc-index-sockets_002c-accepting-connections"></span>
<span xml:id="glibc-index-accepting-connections"></span>

<para>When a server receives a connection request, it can complete the
connection by accepting the request.  Use the function <code>accept</code>
to do this.
</para>
<para>A socket that has been established as a server can accept connection
requests from multiple clients.  The server’s original socket
<emphasis>does not become part of the connection</emphasis>; instead, <code>accept</code>
makes a new socket which participates in the connection.
<code>accept</code> returns the descriptor for this socket.  The server’s
original socket remains available for listening for further connection
requests.
</para>
<para>The number of pending connection requests on a server socket is finite.
If connection requests arrive from clients faster than the server can
act upon them, the queue can fill up and additional requests are refused
with an <code>ECONNREFUSED</code> error.  You can specify the maximum length of
this queue as an argument to the <code>listen</code> function, although the
system may also impose its own internal limit on the length of this
queue.
</para>
<dl class="def">
<dt xml:id="glibc-index-accept"><span class="category">Function: </span><span><emphasis>int</emphasis> <strong>accept</strong> <emphasis>(int <var>socket</var>, struct sockaddr *<var>addr</var>, socklen_t *<var>length_ptr</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-accept" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Safe
| AC-Safe fd
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>This function is used to accept a connection request on the server
socket <var>socket</var>.
</para>
<para>The <code>accept</code> function waits if there are no connections pending,
unless the socket <var>socket</var> has nonblocking mode set.  (You can use
<code>select</code> to wait for a pending connection, with a nonblocking
socket.)  See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#File-Status-Flags">File Status Flags</a>, for information about nonblocking
mode.
</para>
<para>The <var>addr</var> and <var>length-ptr</var> arguments are used to return
information about the name of the client socket that initiated the
connection.  See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Socket-Addresses">Socket Addresses</a>, for information about the format
of the information.
</para>
<para>Accepting a connection does not make <var>socket</var> part of the
connection.  Instead, it creates a new socket which becomes
connected.  The normal return value of <code>accept</code> is the file
descriptor for the new socket.
</para>
<para>After <code>accept</code>, the original socket <var>socket</var> remains open and
unconnected, and continues listening until you close it.  You can
accept further connections with <var>socket</var> by calling <code>accept</code>
again.
</para>
<para>If an error occurs, <code>accept</code> returns <code>-1</code>.  The following
<code>errno</code> error conditions are defined for this function:
</para>
<dl compact="compact">
<dt><span><code>EBADF</code></span></dt>
<dd><para>The <var>socket</var> argument is not a valid file descriptor.
</para>
</dd>
<dt><span><code>ENOTSOCK</code></span></dt>
<dd><para>The descriptor <var>socket</var> argument is not a socket.
</para>
</dd>
<dt><span><code>EOPNOTSUPP</code></span></dt>
<dd><para>The descriptor <var>socket</var> does not support this operation.
</para>
</dd>
<dt><span><code>EWOULDBLOCK</code></span></dt>
<dd><para><var>socket</var> has nonblocking mode set, and there are no pending
connections immediately available.
</para></dd>
</dl>

<para>This function is defined as a cancellation point in multi-threaded
programs, so one has to be prepared for this and make sure that
allocated resources (like memory, file descriptors, semaphores or
whatever) are freed even if the thread is canceled.
</para></dd></dl>

<para>The <code>accept</code> function is not allowed for sockets using
connectionless communication styles.
</para>
<hr>
</div>
<div class="subsection" xml:id="glibc-Who-is-Connected">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Transferring-Data" accesskey="n" rel="next">Transferring Data</a>, Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Accepting-Connections" accesskey="p" rel="prev">Accepting Connections</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Connections" accesskey="u" rel="up">Using Sockets with Connections</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Who-is-Connected-to-Me_003f"></span><h4 class="subsection">16.9.4 Who is Connected to Me?</title>

<dl class="def">
<dt xml:id="glibc-index-getpeername"><span class="category">Function: </span><span><emphasis>int</emphasis> <strong>getpeername</strong> <emphasis>(int <var>socket</var>, struct sockaddr *<var>addr</var>, socklen_t *<var>length-ptr</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-getpeername" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Safe
| AC-Safe
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>The <code>getpeername</code> function returns the address of the socket that
<var>socket</var> is connected to; it stores the address in the memory space
specified by <var>addr</var> and <var>length-ptr</var>.  It stores the length of
the address in <code>*<var>length-ptr</var></code>.
</para>
<para>See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Socket-Addresses">Socket Addresses</a>, for information about the format of the
address.  In some operating systems, <code>getpeername</code> works only for
sockets in the Internet domain.
</para>
<para>The return value is <code>0</code> on success and <code>-1</code> on error.  The
following <code>errno</code> error conditions are defined for this function:
</para>
<dl compact="compact">
<dt><span><code>EBADF</code></span></dt>
<dd><para>The argument <var>socket</var> is not a valid file descriptor.
</para>
</dd>
<dt><span><code>ENOTSOCK</code></span></dt>
<dd><para>The descriptor <var>socket</var> is not a socket.
</para>
</dd>
<dt><span><code>ENOTCONN</code></span></dt>
<dd><para>The socket <var>socket</var> is not connected.
</para>
</dd>
<dt><span><code>ENOBUFS</code></span></dt>
<dd><para>There are not enough internal buffers available.
</para></dd>
</dl>
</dd></dl>


<hr>
</div>
<div class="subsection" xml:id="glibc-Transferring-Data">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Byte-Stream-Example" accesskey="n" rel="next">Byte Stream Socket Example</a>, Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Who-is-Connected" accesskey="p" rel="prev">Who is Connected to Me?</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Connections" accesskey="u" rel="up">Using Sockets with Connections</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Transferring-Data-1"></span><h4 class="subsection">16.9.5 Transferring Data</title>
<span xml:id="glibc-index-reading-from-a-socket"></span>
<span xml:id="glibc-index-writing-to-a-socket"></span>

<para>Once a socket has been connected to a peer, you can use the ordinary
<code>read</code> and <code>write</code> operations (see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#I_002fO-Primitives">Input and Output Primitives</a>) to
transfer data.  A socket is a two-way communications channel, so read
and write operations can be performed at either end.
</para>
<para>There are also some I/O modes that are specific to socket operations.
In order to specify these modes, you must use the <code>recv</code> and
<code>send</code> functions instead of the more generic <code>read</code> and
<code>write</code> functions.  The <code>recv</code> and <code>send</code> functions take
an additional argument which you can use to specify various flags to
control special I/O modes.  For example, you can specify the
<code>MSG_OOB</code> flag to read or write out-of-band data, the
<code>MSG_PEEK</code> flag to peek at input, or the <code>MSG_DONTROUTE</code> flag
to control inclusion of routing information on output.
</para>

<ul class="section-toc">
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Sending-Data" accesskey="1">Sending Data</a></li>
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Receiving-Data" accesskey="2">Receiving Data</a></li>
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Socket-Data-Options" accesskey="3">Socket Data Options</a></li>
</ul>
<hr>
<div class="subsubsection" xml:id="glibc-Sending-Data">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Receiving-Data" accesskey="n" rel="next">Receiving Data</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Transferring-Data" accesskey="u" rel="up">Transferring Data</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Sending-Data-1"></span><h4 class="subsubsection">16.9.5.1 Sending Data</title>

<span xml:id="glibc-index-sys_002fsocket_002eh-9"></span>
<para>The <code>send</code> function is declared in the header file
<filename>sys/socket.h</filename>.  If your <var>flags</var> argument is zero, you can just
as well use <code>write</code> instead of <code>send</code>; see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#I_002fO-Primitives">Input and Output Primitives</a>.  If the socket was connected but the connection has broken,
you get a <code>SIGPIPE</code> signal for any use of <code>send</code> or
<code>write</code> (see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Miscellaneous-Signals">Miscellaneous Signals</a>).
</para>
<dl class="def">
<dt xml:id="glibc-index-send"><span class="category">Function: </span><span><emphasis>ssize_t</emphasis> <strong>send</strong> <emphasis>(int <var>socket</var>, const void *<var>buffer</var>, size_t <var>size</var>, int <var>flags</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-send" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Safe
| AC-Safe
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>The <code>send</code> function is like <code>write</code>, but with the additional
flags <var>flags</var>.  The possible values of <var>flags</var> are described
in <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Socket-Data-Options">Socket Data Options</a>.
</para>
<para>This function returns the number of bytes transmitted, or <code>-1</code> on
failure.  If the socket is nonblocking, then <code>send</code> (like
<code>write</code>) can return after sending just part of the data.
See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#File-Status-Flags">File Status Flags</a>, for information about nonblocking mode.
</para>
<para>Note, however, that a successful return value merely indicates that
the message has been sent without error, not necessarily that it has
been received without error.
</para>
<para>The following <code>errno</code> error conditions are defined for this function:
</para>
<dl compact="compact">
<dt><span><code>EBADF</code></span></dt>
<dd><para>The <var>socket</var> argument is not a valid file descriptor.
</para>
</dd>
<dt><span><code>EINTR</code></span></dt>
<dd><para>The operation was interrupted by a signal before any data was sent.
See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Interrupted-Primitives">Primitives Interrupted by Signals</a>.
</para>
</dd>
<dt><span><code>ENOTSOCK</code></span></dt>
<dd><para>The descriptor <var>socket</var> is not a socket.
</para>
</dd>
<dt><span><code>EMSGSIZE</code></span></dt>
<dd><para>The socket type requires that the message be sent atomically, but the
message is too large for this to be possible.
</para>
</dd>
<dt><span><code>EWOULDBLOCK</code></span></dt>
<dd><para>Nonblocking mode has been set on the socket, and the write operation
would block.  (Normally <code>send</code> blocks until the operation can be
completed.)
</para>
</dd>
<dt><span><code>ENOBUFS</code></span></dt>
<dd><para>There is not enough internal buffer space available.
</para>
</dd>
<dt><span><code>ENOTCONN</code></span></dt>
<dd><para>You never connected this socket.
</para>
</dd>
<dt><span><code>EPIPE</code></span></dt>
<dd><para>This socket was connected but the connection is now broken.  In this
case, <code>send</code> generates a <code>SIGPIPE</code> signal first; if that
signal is ignored or blocked, or if its handler returns, then
<code>send</code> fails with <code>EPIPE</code>.
</para></dd>
</dl>

<para>This function is defined as a cancellation point in multi-threaded
programs, so one has to be prepared for this and make sure that
allocated resources (like memory, file descriptors, semaphores or
whatever) are freed even if the thread is canceled.
</para></dd></dl>

<hr>
</div>
<div class="subsubsection" xml:id="glibc-Receiving-Data">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Socket-Data-Options" accesskey="n" rel="next">Socket Data Options</a>, Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Sending-Data" accesskey="p" rel="prev">Sending Data</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Transferring-Data" accesskey="u" rel="up">Transferring Data</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Receiving-Data-1"></span><h4 class="subsubsection">16.9.5.2 Receiving Data</title>

<span xml:id="glibc-index-sys_002fsocket_002eh-10"></span>
<para>The <code>recv</code> function is declared in the header file
<filename>sys/socket.h</filename>.  If your <var>flags</var> argument is zero, you can
just as well use <code>read</code> instead of <code>recv</code>; see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#I_002fO-Primitives">Input and Output Primitives</a>.
</para>
<dl class="def">
<dt xml:id="glibc-index-recv"><span class="category">Function: </span><span><emphasis>ssize_t</emphasis> <strong>recv</strong> <emphasis>(int <var>socket</var>, void *<var>buffer</var>, size_t <var>size</var>, int <var>flags</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-recv" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Safe
| AC-Safe
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>The <code>recv</code> function is like <code>read</code>, but with the additional
flags <var>flags</var>.  The possible values of <var>flags</var> are described
in <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Socket-Data-Options">Socket Data Options</a>.
</para>
<para>If nonblocking mode is set for <var>socket</var>, and no data are available to
be read, <code>recv</code> fails immediately rather than waiting.  See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#File-Status-Flags">File Status Flags</a>, for information about nonblocking mode.
</para>
<para>This function returns the number of bytes received, or <code>-1</code> on failure.
The following <code>errno</code> error conditions are defined for this function:
</para>
<dl compact="compact">
<dt><span><code>EBADF</code></span></dt>
<dd><para>The <var>socket</var> argument is not a valid file descriptor.
</para>
</dd>
<dt><span><code>ENOTSOCK</code></span></dt>
<dd><para>The descriptor <var>socket</var> is not a socket.
</para>
</dd>
<dt><span><code>EWOULDBLOCK</code></span></dt>
<dd><para>Nonblocking mode has been set on the socket, and the read operation
would block.  (Normally, <code>recv</code> blocks until there is input
available to be read.)
</para>
</dd>
<dt><span><code>EINTR</code></span></dt>
<dd><para>The operation was interrupted by a signal before any data was read.
See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Interrupted-Primitives">Primitives Interrupted by Signals</a>.
</para>
</dd>
<dt><span><code>ENOTCONN</code></span></dt>
<dd><para>You never connected this socket.
</para></dd>
</dl>

<para>This function is defined as a cancellation point in multi-threaded
programs, so one has to be prepared for this and make sure that
allocated resources (like memory, file descriptors, semaphores or
whatever) are freed even if the thread is canceled.
</para></dd></dl>

<hr>
</div>
<div class="subsubsection" xml:id="glibc-Socket-Data-Options">
<div class="header">
<para>
Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Receiving-Data" accesskey="p" rel="prev">Receiving Data</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Transferring-Data" accesskey="u" rel="up">Transferring Data</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Socket-Data-Options-1"></span><h4 class="subsubsection">16.9.5.3 Socket Data Options</title>

<span xml:id="glibc-index-sys_002fsocket_002eh-11"></span>
<para>The <var>flags</var> argument to <code>send</code> and <code>recv</code> is a bit
mask.  You can bitwise-OR the values of the following macros together
to obtain a value for this argument.  All are defined in the header
file <filename>sys/socket.h</filename>.
</para>
<dl class="def">
<dt xml:id="glibc-index-MSG_005fOOB"><span class="category">Macro: </span><span><emphasis>int</emphasis> <strong>MSG_OOB</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-MSG_005fOOB" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Send or receive out-of-band data.  See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Out_002dof_002dBand-Data">Out-of-Band Data</a>.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-MSG_005fPEEK"><span class="category">Macro: </span><span><emphasis>int</emphasis> <strong>MSG_PEEK</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-MSG_005fPEEK" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Look at the data but don’t remove it from the input queue.  This is
only meaningful with input functions such as <code>recv</code>, not with
<code>send</code>.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-MSG_005fDONTROUTE"><span class="category">Macro: </span><span><emphasis>int</emphasis> <strong>MSG_DONTROUTE</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-MSG_005fDONTROUTE" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Don’t include routing information in the message.  This is only
meaningful with output operations, and is usually only of interest for
diagnostic or routing programs.  We don’t try to explain it here.
</para></dd></dl>

<hr>
</div>
</div>
<div class="subsection" xml:id="glibc-Byte-Stream-Example">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Server-Example" accesskey="n" rel="next">Byte Stream Connection Server Example</a>, Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Transferring-Data" accesskey="p" rel="prev">Transferring Data</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Connections" accesskey="u" rel="up">Using Sockets with Connections</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Byte-Stream-Socket-Example"></span><h4 class="subsection">16.9.6 Byte Stream Socket Example</title>

<para>Here is an example client program that makes a connection for a byte
stream socket in the Internet namespace.  It doesn’t do anything
particularly interesting once it has connected to the server; it just
sends a text string to the server and exits.
</para>
<para>This program uses <code>init_sockaddr</code> to set up the socket address; see
<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Inet-Example">Internet Socket Example</a>.
</para>
<div class="example">
<pre class="example">
#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netdb.h&gt;

#define PORT            5555
#define MESSAGE         "Yow!!! Are we having fun yet?!?"
#define SERVERHOST      "www.gnu.org"

void
write_to_server (int filedes)
{
  int nbytes;

  nbytes = write (filedes, MESSAGE, strlen (MESSAGE) + 1);
  if (nbytes &lt; 0)
    {
      perror ("write");
      exit (EXIT_FAILURE);
    }
}


int
main (void)
{
  extern void init_sockaddr (struct sockaddr_in *name,
                             const char *hostname,
                             uint16_t port);
  int sock;
  struct sockaddr_in servername;

  /* <span class="roman">Create the socket.</span> */
  sock = socket (PF_INET, SOCK_STREAM, 0);
  if (sock &lt; 0)
    {
      perror ("socket (client)");
      exit (EXIT_FAILURE);
    }

  /* <span class="roman">Connect to the server.</span> */
  init_sockaddr (&amp;servername, SERVERHOST, PORT);
  if (0 &gt; connect (sock,
                   (struct sockaddr *) &amp;servername,
                   sizeof (servername)))
    {
      perror ("connect (client)");
      exit (EXIT_FAILURE);
    }

  /* <span class="roman">Send data to the server.</span> */
  write_to_server (sock);
  close (sock);
  exit (EXIT_SUCCESS);
}
</pre></div>

<hr>
</div>
<div class="subsection" xml:id="glibc-Server-Example">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Out_002dof_002dBand-Data" accesskey="n" rel="next">Out-of-Band Data</a>, Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Byte-Stream-Example" accesskey="p" rel="prev">Byte Stream Socket Example</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Connections" accesskey="u" rel="up">Using Sockets with Connections</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Byte-Stream-Connection-Server-Example"></span><h4 class="subsection">16.9.7 Byte Stream Connection Server Example</title>

<para>The server end is much more complicated.  Since we want to allow
multiple clients to be connected to the server at the same time, it
would be incorrect to wait for input from a single client by simply
calling <code>read</code> or <code>recv</code>.  Instead, the right thing to do is
to use <code>select</code> (see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Waiting-for-I_002fO">Waiting for Input or Output</a>) to wait for input on
all of the open sockets.  This also allows the server to deal with
additional connection requests.
</para>
<para>This particular server doesn’t do anything interesting once it has
gotten a message from a client.  It does close the socket for that
client when it detects an end-of-file condition (resulting from the
client shutting down its end of the connection).
</para>
<para>This program uses <code>make_socket</code> to set up the socket address; see
<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Inet-Example">Internet Socket Example</a>.
</para>
<div class="example">
<pre class="example">
#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netdb.h&gt;

#define PORT    5555
#define MAXMSG  512

int
read_from_client (int filedes)
{
  char buffer[MAXMSG];
  int nbytes;

  nbytes = read (filedes, buffer, MAXMSG);
  if (nbytes &lt; 0)
    {
      /* <span class="roman">Read error.</span> */
      perror ("read");
      exit (EXIT_FAILURE);
    }
  else if (nbytes == 0)
    /* <span class="roman">End-of-file.</span> */
    return -1;
  else
    {
      /* <span class="roman">Data read.</span> */
      fprintf (stderr, "Server: got message: `%s'\n", buffer);
      return 0;
    }
}

int
main (void)
{
  extern int make_socket (uint16_t port);
  int sock;
  fd_set active_fd_set, read_fd_set;
  int i;
  struct sockaddr_in clientname;
  size_t size;

  /* <span class="roman">Create the socket and set it up to accept connections.</span> */
  sock = make_socket (PORT);
  if (listen (sock, 1) &lt; 0)
    {
      perror ("listen");
      exit (EXIT_FAILURE);
    }

  /* <span class="roman">Initialize the set of active sockets.</span> */
  FD_ZERO (&amp;active_fd_set);
  FD_SET (sock, &amp;active_fd_set);

  while (1)
    {
      /* <span class="roman">Block until input arrives on one or more active sockets.</span> */
      read_fd_set = active_fd_set;
      if (select (FD_SETSIZE, &amp;read_fd_set, NULL, NULL, NULL) &lt; 0)
        {
          perror ("select");
          exit (EXIT_FAILURE);
        }

      /* <span class="roman">Service all the sockets with input pending.</span> */
      for (i = 0; i &lt; FD_SETSIZE; ++i)
        if (FD_ISSET (i, &amp;read_fd_set))
          {
            if (i == sock)
              {
                /* <span class="roman">Connection request on original socket.</span> */
                int new;
                size = sizeof (clientname);
                new = accept (sock,
                              (struct sockaddr *) &amp;clientname,
                              &amp;size);
                if (new &lt; 0)
                  {
                    perror ("accept");
                    exit (EXIT_FAILURE);
                  }
                fprintf (stderr,
                         "Server: connect from host %s, port %hd.\n",
                         inet_ntoa (clientname.sin_addr),
                         ntohs (clientname.sin_port));
                FD_SET (new, &amp;active_fd_set);
              }
            else
              {
                /* <span class="roman">Data arriving on an already-connected socket.</span> */
                if (read_from_client (i) &lt; 0)
                  {
                    close (i);
                    FD_CLR (i, &amp;active_fd_set);
                  }
              }
          }
    }
}
</pre></div>

<hr>
</div>
<div class="subsection" xml:id="glibc-Out_002dof_002dBand-Data">
<div class="header">
<para>
Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Server-Example" accesskey="p" rel="prev">Byte Stream Connection Server Example</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Connections" accesskey="u" rel="up">Using Sockets with Connections</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Out_002dof_002dBand-Data-1"></span><h4 class="subsection">16.9.8 Out-of-Band Data</title>

<span xml:id="glibc-index-out_002dof_002dband-data"></span>
<span xml:id="glibc-index-high_002dpriority-data"></span>
<para>Streams with connections permit <emphasis>out-of-band</emphasis> data that is
delivered with higher priority than ordinary data.  Typically the
reason for sending out-of-band data is to send notice of an
exceptional condition.  To send out-of-band data use
<code>send</code>, specifying the flag <code>MSG_OOB</code> (see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Sending-Data">Sending Data</a>).
</para>
<para>Out-of-band data are received with higher priority because the
receiving process need not read it in sequence; to read the next
available out-of-band data, use <code>recv</code> with the <code>MSG_OOB</code>
flag (see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Receiving-Data">Receiving Data</a>).  Ordinary read operations do not read
out-of-band data; they read only ordinary data.
</para>
<span xml:id="glibc-index-urgent-socket-condition"></span>
<para>When a socket finds that out-of-band data are on their way, it sends a
<code>SIGURG</code> signal to the owner process or process group of the
socket.  You can specify the owner using the <code>F_SETOWN</code> command
to the <code>fcntl</code> function; see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Interrupt-Input">Interrupt-Driven Input</a>.  You must
also establish a handler for this signal, as described in <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Signal-Handling">Signal Handling</a>, in order to take appropriate action such as reading the
out-of-band data.
</para>
<para>Alternatively, you can test for pending out-of-band data, or wait
until there is out-of-band data, using the <code>select</code> function; it
can wait for an exceptional condition on the socket.  See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Waiting-for-I_002fO">Waiting for Input or Output</a>, for more information about <code>select</code>.
</para>
<para>Notification of out-of-band data (whether with <code>SIGURG</code> or with
<code>select</code>) indicates that out-of-band data are on the way; the data
may not actually arrive until later.  If you try to read the
out-of-band data before it arrives, <code>recv</code> fails with an
<code>EWOULDBLOCK</code> error.
</para>
<para>Sending out-of-band data automatically places a “mark” in the stream
of ordinary data, showing where in the sequence the out-of-band data
“would have been”.  This is useful when the meaning of out-of-band
data is “cancel everything sent so far”.  Here is how you can test,
in the receiving process, whether any ordinary data was sent before
the mark:
</para>
<div class="example">
<pre class="example">success = ioctl (socket, SIOCATMARK, &amp;atmark);
</pre></div>

<para>The <code>integer</code> variable <var>atmark</var> is set to a nonzero value if
the socket’s read pointer has reached the “mark”.
</para>

<para>Here’s a function to discard any ordinary data preceding the
out-of-band mark:
</para>
<div class="example">
<pre class="example">int
discard_until_mark (int socket)
{
  while (1)
    {
      /* <span class="roman">This is not an arbitrary limit; any size will do.</span>  */
      char buffer[1024];
      int atmark, success;

      /* <span class="roman">If we have reached the mark, return.</span>  */
      success = ioctl (socket, SIOCATMARK, &amp;atmark);
      if (success &lt; 0)
        perror ("ioctl");
      if (result)
        return;

      /* <span class="roman">Otherwise, read a bunch of ordinary data and discard it.</span>
         <span class="roman">This is guaranteed not to read past the mark</span>
         <span class="roman">if it starts before the mark.</span>  */
      success = read (socket, buffer, sizeof buffer);
      if (success &lt; 0)
        perror ("read");
    }
}
</pre></div>

<para>If you don’t want to discard the ordinary data preceding the mark, you
may need to read some of it anyway, to make room in internal system
buffers for the out-of-band data.  If you try to read out-of-band data
and get an <code>EWOULDBLOCK</code> error, try reading some ordinary data
(saving it so that you can use it when you want it) and see if that
makes room.  Here is an example:
</para>
<div class="example">
<pre class="example">struct buffer
{
  char *buf;
  int size;
  struct buffer *next;
};

/* <span class="roman">Read the out-of-band data from SOCKET and return it</span>
   <span class="roman">as a ‘struct buffer’, which records the address of the data</span>
   <span class="roman">and its size.</span>

   <span class="roman">It may be necessary to read some ordinary data</span>
   <span class="roman">in order to make room for the out-of-band data.</span>
   <span class="roman">If so, the ordinary data are saved as a chain of buffers</span>
   <span class="roman">found in the ‘next’ field of the value.</span>  */

struct buffer *
read_oob (int socket)
{
  struct buffer *tail = 0;
  struct buffer *list = 0;

  while (1)
    {
      /* <span class="roman">This is an arbitrary limit.</span>
         <span class="roman">Does anyone know how to do this without a limit?</span>  */
#define BUF_SZ 1024
      char *buf = (char *) xmalloc (BUF_SZ);
      int success;
      int atmark;

      /* <span class="roman">Try again to read the out-of-band data.</span>  */
      success = recv (socket, buf, BUF_SZ, MSG_OOB);
      if (success &gt;= 0)
        {
          /* <span class="roman">We got it, so return it.</span>  */
          struct buffer *link
            = (struct buffer *) xmalloc (sizeof (struct buffer));
          link-&gt;buf = buf;
          link-&gt;size = success;
          link-&gt;next = list;
          return link;
        }

      /* <span class="roman">If we fail, see if we are at the mark.</span>  */
      success = ioctl (socket, SIOCATMARK, &amp;atmark);
      if (success &lt; 0)
        perror ("ioctl");
      if (atmark)
        {
          /* <span class="roman">At the mark; skipping past more ordinary data cannot help.</span>
             <span class="roman">So just wait a while.</span>  */
          sleep (1);
          continue;
        }

      /* <span class="roman">Otherwise, read a bunch of ordinary data and save it.</span>
         <span class="roman">This is guaranteed not to read past the mark</span>
         <span class="roman">if it starts before the mark.</span>  */
      success = read (socket, buf, BUF_SZ);
      if (success &lt; 0)
        perror ("read");

      /* <span class="roman">Save this data in the buffer list.</span>  */
      {
        struct buffer *link
          = (struct buffer *) xmalloc (sizeof (struct buffer));
        link-&gt;buf = buf;
        link-&gt;size = success;

        /* <span class="roman">Add the new link to the end of the list.</span>  */
        if (tail)
          tail-&gt;next = link;
        else
          list = link;
        tail = link;
      }
    }
}
</pre></div>

<hr>
</div>
</div>
<sect xml:id="glibc-Datagrams">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Inetd" accesskey="n" rel="next">The <code>inetd</code> Daemon</a>, Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Connections" accesskey="p" rel="prev">Using Sockets with Connections</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Sockets" accesskey="u" rel="up">Sockets</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Datagram-Socket-Operations"></span><h3 class="section">16.10 Datagram Socket Operations</title>

<span xml:id="glibc-index-datagram-socket"></span>
<para>This section describes how to use communication styles that don’t use
connections (styles <code>SOCK_DGRAM</code> and <code>SOCK_RDM</code>).  Using
these styles, you group data into packets and each packet is an
independent communication.  You specify the destination for each
packet individually.
</para>
<para>Datagram packets are like letters: you send each one independently
with its own destination address, and they may arrive in the wrong
order or not at all.
</para>
<para>The <code>listen</code> and <code>accept</code> functions are not allowed for
sockets using connectionless communication styles.
</para>

<ul class="section-toc">
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Sending-Datagrams" accesskey="1">Sending Datagrams</a></li>
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Receiving-Datagrams" accesskey="2">Receiving Datagrams</a></li>
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Datagram-Example" accesskey="3">Datagram Socket Example</a></li>
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Example-Receiver" accesskey="4">Example of Reading Datagrams</a></li>
</ul>
<hr>
<div class="subsection" xml:id="glibc-Sending-Datagrams">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Receiving-Datagrams" accesskey="n" rel="next">Receiving Datagrams</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Datagrams" accesskey="u" rel="up">Datagram Socket Operations</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Sending-Datagrams-1"></span><h4 class="subsection">16.10.1 Sending Datagrams</title>
<span xml:id="glibc-index-sending-a-datagram"></span>
<span xml:id="glibc-index-transmitting-datagrams"></span>
<span xml:id="glibc-index-datagrams_002c-transmitting"></span>

<span xml:id="glibc-index-sys_002fsocket_002eh-12"></span>
<para>The normal way of sending data on a datagram socket is by using the
<code>sendto</code> function, declared in <filename>sys/socket.h</filename>.
</para>
<para>You can call <code>connect</code> on a datagram socket, but this only
specifies a default destination for further data transmission on the
socket.  When a socket has a default destination you can use
<code>send</code> (see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Sending-Data">Sending Data</a>) or even <code>write</code> (see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#I_002fO-Primitives">Input and Output Primitives</a>) to send a packet there.  You can cancel the default
destination by calling <code>connect</code> using an address format of
<code>AF_UNSPEC</code> in the <var>addr</var> argument.  See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Connecting">Making a Connection</a>, for
more information about the <code>connect</code> function.
</para>
<dl class="def">
<dt xml:id="glibc-index-sendto"><span class="category">Function: </span><span><emphasis>ssize_t</emphasis> <strong>sendto</strong> <emphasis>(int <var>socket</var>, const void *<var>buffer</var>, size_t <var>size</var>, int <var>flags</var>, struct sockaddr *<var>addr</var>, socklen_t <var>length</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-sendto" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Safe
| AC-Safe
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>The <code>sendto</code> function transmits the data in the <var>buffer</var>
through the socket <var>socket</var> to the destination address specified
by the <var>addr</var> and <var>length</var> arguments.  The <var>size</var> argument
specifies the number of bytes to be transmitted.
</para>
<para>The <var>flags</var> are interpreted the same way as for <code>send</code>; see
<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Socket-Data-Options">Socket Data Options</a>.
</para>
<para>The return value and error conditions are also the same as for
<code>send</code>, but you cannot rely on the system to detect errors and
report them; the most common error is that the packet is lost or there
is no-one at the specified address to receive it, and the operating
system on your machine usually does not know this.
</para>
<para>It is also possible for one call to <code>sendto</code> to report an error
owing to a problem related to a previous call.
</para>
<para>This function is defined as a cancellation point in multi-threaded
programs, so one has to be prepared for this and make sure that
allocated resources (like memory, file descriptors, semaphores or
whatever) are freed even if the thread is canceled.
</para></dd></dl>

<hr>
</div>
<div class="subsection" xml:id="glibc-Receiving-Datagrams">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Datagram-Example" accesskey="n" rel="next">Datagram Socket Example</a>, Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Sending-Datagrams" accesskey="p" rel="prev">Sending Datagrams</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Datagrams" accesskey="u" rel="up">Datagram Socket Operations</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Receiving-Datagrams-1"></span><h4 class="subsection">16.10.2 Receiving Datagrams</title>
<span xml:id="glibc-index-receiving-datagrams"></span>

<para>The <code>recvfrom</code> function reads a packet from a datagram socket and
also tells you where it was sent from.  This function is declared in
<filename>sys/socket.h</filename>.
</para>
<dl class="def">
<dt xml:id="glibc-index-recvfrom"><span class="category">Function: </span><span><emphasis>ssize_t</emphasis> <strong>recvfrom</strong> <emphasis>(int <var>socket</var>, void *<var>buffer</var>, size_t <var>size</var>, int <var>flags</var>, struct sockaddr *<var>addr</var>, socklen_t *<var>length-ptr</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-recvfrom" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Safe
| AC-Safe
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>The <code>recvfrom</code> function reads one packet from the socket
<var>socket</var> into the buffer <var>buffer</var>.  The <var>size</var> argument
specifies the maximum number of bytes to be read.
</para>
<para>If the packet is longer than <var>size</var> bytes, then you get the first
<var>size</var> bytes of the packet and the rest of the packet is lost.
There’s no way to read the rest of the packet.  Thus, when you use a
packet protocol, you must always know how long a packet to expect.
</para>
<para>The <var>addr</var> and <var>length-ptr</var> arguments are used to return the
address where the packet came from.  See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Socket-Addresses">Socket Addresses</a>.  For a
socket in the local domain the address information won’t be meaningful,
since you can’t read the address of such a socket (see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Local-Namespace">The Local Namespace</a>).  You can specify a null pointer as the <var>addr</var> argument
if you are not interested in this information.
</para>
<para>The <var>flags</var> are interpreted the same way as for <code>recv</code>
(see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Socket-Data-Options">Socket Data Options</a>).  The return value and error conditions
are also the same as for <code>recv</code>.
</para>
<para>This function is defined as a cancellation point in multi-threaded
programs, so one has to be prepared for this and make sure that
allocated resources (like memory, file descriptors, semaphores or
whatever) are freed even if the thread is canceled.
</para></dd></dl>

<para>You can use plain <code>recv</code> (see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Receiving-Data">Receiving Data</a>) instead of
<code>recvfrom</code> if you don’t need to find out who sent the packet
(either because you know where it should come from or because you
treat all possible senders alike).  Even <code>read</code> can be used if
you don’t want to specify <var>flags</var> (see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#I_002fO-Primitives">Input and Output Primitives</a>).
</para>

<hr>
</div>
<div class="subsection" xml:id="glibc-Datagram-Example">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Example-Receiver" accesskey="n" rel="next">Example of Reading Datagrams</a>, Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Receiving-Datagrams" accesskey="p" rel="prev">Receiving Datagrams</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Datagrams" accesskey="u" rel="up">Datagram Socket Operations</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Datagram-Socket-Example"></span><h4 class="subsection">16.10.3 Datagram Socket Example</title>

<para>Here is a set of example programs that send messages over a datagram
stream in the local namespace.  Both the client and server programs use
the <code>make_named_socket</code> function that was presented in <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Local-Socket-Example">Example of Local-Namespace Sockets</a>, to create and name their sockets.
</para>
<para>First, here is the server program.  It sits in a loop waiting for
messages to arrive, bouncing each message back to the sender.
Obviously this isn’t a particularly useful program, but it does show
the general ideas involved.
</para>
<div class="example">
<pre class="example">
#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/un.h&gt;

#define SERVER  "/tmp/serversocket"
#define MAXMSG  512

int
main (void)
{
  int sock;
  char message[MAXMSG];
  struct sockaddr_un name;
  size_t size;
  int nbytes;

  /* <span class="roman">Remove the filename first, it’s ok if the call fails</span> */
  unlink (SERVER);

  /* <span class="roman">Make the socket, then loop endlessly.</span> */
  sock = make_named_socket (SERVER);
  while (1)
    {
      /* <span class="roman">Wait for a datagram.</span> */
      size = sizeof (name);
      nbytes = recvfrom (sock, message, MAXMSG, 0,
                         (struct sockaddr *) &amp; name, &amp;size);
      if (nbytes &lt; 0)
        {
          perror ("recfrom (server)");
          exit (EXIT_FAILURE);
        }

      /* <span class="roman">Give a diagnostic message.</span> */
      fprintf (stderr, "Server: got message: %s\n", message);

      /* <span class="roman">Bounce the message back to the sender.</span> */
      nbytes = sendto (sock, message, nbytes, 0,
                       (struct sockaddr *) &amp; name, size);
      if (nbytes &lt; 0)
        {
          perror ("sendto (server)");
          exit (EXIT_FAILURE);
        }
    }
}
</pre></div>

<hr>
</div>
<div class="subsection" xml:id="glibc-Example-Receiver">
<div class="header">
<para>
Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Datagram-Example" accesskey="p" rel="prev">Datagram Socket Example</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Datagrams" accesskey="u" rel="up">Datagram Socket Operations</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Example-of-Reading-Datagrams"></span><h4 class="subsection">16.10.4 Example of Reading Datagrams</title>

<para>Here is the client program corresponding to the server above.
</para>
<para>It sends a datagram to the server and then waits for a reply.  Notice
that the socket for the client (as well as for the server) in this
example has to be given a name.  This is so that the server can direct
a message back to the client.  Since the socket has no associated
connection state, the only way the server can do this is by
referencing the name of the client.
</para>
<div class="example">
<pre class="example">
#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/un.h&gt;

#define SERVER  "/tmp/serversocket"
#define CLIENT  "/tmp/mysocket"
#define MAXMSG  512
#define MESSAGE "Yow!!! Are we having fun yet?!?"

int
main (void)
{
  extern int make_named_socket (const char *name);
  int sock;
  char message[MAXMSG];
  struct sockaddr_un name;
  size_t size;
  int nbytes;

  /* <span class="roman">Make the socket.</span> */
  sock = make_named_socket (CLIENT);

  /* <span class="roman">Initialize the server socket address.</span> */
  name.sun_family = AF_LOCAL;
  strcpy (name.sun_path, SERVER);
  size = strlen (name.sun_path) + sizeof (name.sun_family);

  /* <span class="roman">Send the datagram.</span> */
  nbytes = sendto (sock, MESSAGE, strlen (MESSAGE) + 1, 0,
                   (struct sockaddr *) &amp; name, size);
  if (nbytes &lt; 0)
    {
      perror ("sendto (client)");
      exit (EXIT_FAILURE);
    }

  /* <span class="roman">Wait for a reply.</span> */
  nbytes = recvfrom (sock, message, MAXMSG, 0, NULL, 0);
  if (nbytes &lt; 0)
    {
      perror ("recfrom (client)");
      exit (EXIT_FAILURE);
    }

  /* <span class="roman">Print a diagnostic message.</span> */
  fprintf (stderr, "Client: got message: %s\n", message);

  /* <span class="roman">Clean up.</span> */
  remove (CLIENT);
  close (sock);
}
</pre></div>

<para>Keep in mind that datagram socket communications are unreliable.  In
this example, the client program waits indefinitely if the message
never reaches the server or if the server’s response never comes
back.  It’s up to the user running the program to kill and restart
it if desired.  A more automatic solution could be to use
<code>select</code> (see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Waiting-for-I_002fO">Waiting for Input or Output</a>) to establish a timeout period
for the reply, and in case of timeout either re-send the message or
shut down the socket and exit.
</para>
<hr>
</div>
</div>
<sect xml:id="glibc-Inetd">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Socket-Options" accesskey="n" rel="next">Socket Options</a>, Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Datagrams" accesskey="p" rel="prev">Datagram Socket Operations</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Sockets" accesskey="u" rel="up">Sockets</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-The-inetd-Daemon"></span><h3 class="section">16.11 The <code>inetd</code> Daemon</title>

<para>We’ve explained above how to write a server program that does its own
listening.  Such a server must already be running in order for anyone
to connect to it.
</para>
<para>Another way to provide a service on an Internet port is to let the daemon
program <code>inetd</code> do the listening.  <code>inetd</code> is a program that
runs all the time and waits (using <code>select</code>) for messages on a
specified set of ports.  When it receives a message, it accepts the
connection (if the socket style calls for connections) and then forks a
child process to run the corresponding server program.  You specify the
ports and their programs in the file <filename>/etc/inetd.conf</filename>.
</para>

<ul class="section-toc">
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Inetd-Servers" accesskey="1"><code>inetd</code> Servers</a></li>
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Configuring-Inetd" accesskey="2">Configuring <code>inetd</code></a></li>
</ul>
<hr>
<div class="subsection" xml:id="glibc-Inetd-Servers">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Configuring-Inetd" accesskey="n" rel="next">Configuring <code>inetd</code></a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Inetd" accesskey="u" rel="up">The <code>inetd</code> Daemon</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-inetd-Servers"></span><h4 class="subsection">16.11.1 <code>inetd</code> Servers</title>

<para>Writing a server program to be run by <code>inetd</code> is very simple.  Each time
someone requests a connection to the appropriate port, a new server
process starts.  The connection already exists at this time; the
socket is available as the standard input descriptor and as the
standard output descriptor (descriptors 0 and 1) in the server
process.  Thus the server program can begin reading and writing data
right away.  Often the program needs only the ordinary I/O facilities;
in fact, a general-purpose filter program that knows nothing about
sockets can work as a byte stream server run by <code>inetd</code>.
</para>
<para>You can also use <code>inetd</code> for servers that use connectionless
communication styles.  For these servers, <code>inetd</code> does not try to accept
a connection since no connection is possible.  It just starts the
server program, which can read the incoming datagram packet from
descriptor 0.  The server program can handle one request and then
exit, or you can choose to write it to keep reading more requests
until no more arrive, and then exit.  You must specify which of these
two techniques the server uses when you configure <code>inetd</code>.
</para>
<hr>
</div>
<div class="subsection" xml:id="glibc-Configuring-Inetd">
<div class="header">
<para>
Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Inetd-Servers" accesskey="p" rel="prev"><code>inetd</code> Servers</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Inetd" accesskey="u" rel="up">The <code>inetd</code> Daemon</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Configuring-inetd"></span><h4 class="subsection">16.11.2 Configuring <code>inetd</code></title>

<para>The file <filename>/etc/inetd.conf</filename> tells <code>inetd</code> which ports to listen to
and what server programs to run for them.  Normally each entry in the
file is one line, but you can split it onto multiple lines provided
all but the first line of the entry start with whitespace.  Lines that
start with ‘<filename>#</filename>’ are comments.
</para>
<para>Here are two standard entries in <filename>/etc/inetd.conf</filename>:
</para>
<div class="example">
<pre class="example">ftp	stream	tcp	nowait	root	/libexec/ftpd	ftpd
talk	dgram	udp	wait	root	/libexec/talkd	talkd
</pre></div>

<para>An entry has this format:
</para>
<div class="example">
<pre class="example"><var>service</var> <var>style</var> <var>protocol</var> <var>wait</var> <var>username</var> <var>program</var> <var>arguments</var>
</pre></div>

<para>The <var>service</var> field says which service this program provides.  It
should be the name of a service defined in <filename>/etc/services</filename>.
<code>inetd</code> uses <var>service</var> to decide which port to listen on for
this entry.
</para>
<para>The fields <var>style</var> and <var>protocol</var> specify the communication
style and the protocol to use for the listening socket.  The style
should be the name of a communication style, converted to lower case
and with ‘<filename>SOCK_</filename>’ deleted—for example, ‘<filename>stream</filename>’ or
‘<filename>dgram</filename>’.  <var>protocol</var> should be one of the protocols listed in
<filename>/etc/protocols</filename>.  The typical protocol names are ‘<filename>tcp</filename>’ for
byte stream connections and ‘<filename>udp</filename>’ for unreliable datagrams.
</para>
<para>The <var>wait</var> field should be either ‘<filename>wait</filename>’ or ‘<filename>nowait</filename>’.
Use ‘<filename>wait</filename>’ if <var>style</var> is a connectionless style and the
server, once started, handles multiple requests as they come in.
Use ‘<filename>nowait</filename>’ if <code>inetd</code> should start a new process for each message
or request that comes in.  If <var>style</var> uses connections, then
<var>wait</var> <strong>must</strong> be ‘<filename>nowait</filename>’.
</para>
<para><var>user</var> is the user name that the server should run as.  <code>inetd</code> runs
as root, so it can set the user ID of its children arbitrarily.  It’s
best to avoid using ‘<filename>root</filename>’ for <var>user</var> if you can; but some
servers, such as Telnet and FTP, read a username and passphrase
themselves.  These servers need to be root initially so they can log
in as commanded by the data coming over the network.
</para>
<para><var>program</var> together with <var>arguments</var> specifies the command to
run to start the server.  <var>program</var> should be an absolute file
name specifying the executable file to run.  <var>arguments</var> consists
of any number of whitespace-separated words, which become the
command-line arguments of <var>program</var>.  The first word in
<var>arguments</var> is argument zero, which should by convention be the
program name itself (sans directories).
</para>
<para>If you edit <filename>/etc/inetd.conf</filename>, you can tell <code>inetd</code> to reread the
file and obey its new contents by sending the <code>inetd</code> process the
<code>SIGHUP</code> signal.  You’ll have to use <code>ps</code> to determine the
process ID of the <code>inetd</code> process as it is not fixed.
</para>

<hr>
</div>
</div>
<sect xml:id="glibc-Socket-Options">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Networks-Database" accesskey="n" rel="next">Networks Database</a>, Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Inetd" accesskey="p" rel="prev">The <code>inetd</code> Daemon</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Sockets" accesskey="u" rel="up">Sockets</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Socket-Options-1"></span><h3 class="section">16.12 Socket Options</title>
<span xml:id="glibc-index-socket-options"></span>

<para>This section describes how to read or set various options that modify
the behavior of sockets and their underlying communications protocols.
</para>
<span xml:id="glibc-index-level_002c-for-socket-options"></span>
<span xml:id="glibc-index-socket-option-level"></span>
<para>When you are manipulating a socket option, you must specify which
<emphasis>level</emphasis> the option pertains to.  This describes whether the option
applies to the socket interface, or to a lower-level communications
protocol interface.
</para>

<ul class="section-toc">
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Socket-Option-Functions" accesskey="1">Socket Option Functions</a></li>
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Socket_002dLevel-Options" accesskey="2">Socket-Level Options</a></li>
</ul>
<hr>
<div class="subsection" xml:id="glibc-Socket-Option-Functions">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Socket_002dLevel-Options" accesskey="n" rel="next">Socket-Level Options</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Socket-Options" accesskey="u" rel="up">Socket Options</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Socket-Option-Functions-1"></span><h4 class="subsection">16.12.1 Socket Option Functions</title>

<span xml:id="glibc-index-sys_002fsocket_002eh-13"></span>
<para>Here are the functions for examining and modifying socket options.
They are declared in <filename>sys/socket.h</filename>.
</para>
<dl class="def">
<dt xml:id="glibc-index-getsockopt"><span class="category">Function: </span><span><emphasis>int</emphasis> <strong>getsockopt</strong> <emphasis>(int <var>socket</var>, int <var>level</var>, int <var>optname</var>, void *<var>optval</var>, socklen_t *<var>optlen-ptr</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-getsockopt" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Safe
| AC-Safe
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>The <code>getsockopt</code> function gets information about the value of
option <var>optname</var> at level <var>level</var> for socket <var>socket</var>.
</para>
<para>The option value is stored in the buffer that <var>optval</var> points to.
Before the call, you should supply in <code>*<var>optlen-ptr</var></code> the
size of this buffer; on return, it contains the number of bytes of
information actually stored in the buffer.
</para>
<para>Most options interpret the <var>optval</var> buffer as a single <code>int</code>
value.
</para>
<para>The actual return value of <code>getsockopt</code> is <code>0</code> on success
and <code>-1</code> on failure.  The following <code>errno</code> error conditions
are defined:
</para>
<dl compact="compact">
<dt><span><code>EBADF</code></span></dt>
<dd><para>The <var>socket</var> argument is not a valid file descriptor.
</para>
</dd>
<dt><span><code>ENOTSOCK</code></span></dt>
<dd><para>The descriptor <var>socket</var> is not a socket.
</para>
</dd>
<dt><span><code>ENOPROTOOPT</code></span></dt>
<dd><para>The <var>optname</var> doesn’t make sense for the given <var>level</var>.
</para></dd>
</dl>
</dd></dl>

<dl class="def">
<dt xml:id="glibc-index-setsockopt"><span class="category">Function: </span><span><emphasis>int</emphasis> <strong>setsockopt</strong> <emphasis>(int <var>socket</var>, int <var>level</var>, int <var>optname</var>, const void *<var>optval</var>, socklen_t <var>optlen</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-setsockopt" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Safe
| AC-Safe
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>This function is used to set the socket option <var>optname</var> at level
<var>level</var> for socket <var>socket</var>.  The value of the option is passed
in the buffer <var>optval</var> of size <var>optlen</var>.
</para>

</dd></dl>

<hr>
</div>
<div class="subsection" xml:id="glibc-Socket_002dLevel-Options">
<div class="header">
<para>
Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Socket-Option-Functions" accesskey="p" rel="prev">Socket Option Functions</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Socket-Options" accesskey="u" rel="up">Socket Options</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Socket_002dLevel-Options-1"></span><h4 class="subsection">16.12.2 Socket-Level Options</title>

<dl class="def">
<dt xml:id="glibc-index-SOL_005fSOCKET"><span class="category">Constant: </span><span><emphasis>int</emphasis> <strong>SOL_SOCKET</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-SOL_005fSOCKET" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Use this constant as the <var>level</var> argument to <code>getsockopt</code> or
<code>setsockopt</code> to manipulate the socket-level options described in
this section.
</para></dd></dl>

<span xml:id="glibc-index-sys_002fsocket_002eh-14"></span>
<para>Here is a table of socket-level option names; all are defined in the
header file <filename>sys/socket.h</filename>.
</para>
<dl compact="compact">
<dt xml:id="glibc-index-SO_005fDEBUG"><span><code>SO_DEBUG</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-SO_005fDEBUG" class="copiable-anchor"> ¶</a></span></dt>
<dd>

<para>This option toggles recording of debugging information in the underlying
protocol modules.  The value has type <code>int</code>; a nonzero value means
“yes”.
</para>
</dd>
<dt xml:id="glibc-index-SO_005fREUSEADDR"><span><code>SO_REUSEADDR</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-SO_005fREUSEADDR" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>This option controls whether <code>bind</code> (see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Setting-Address">Setting the Address of a Socket</a>)
should permit reuse of local addresses for this socket.  If you enable
this option, you can actually have two sockets with the same Internet
port number; but the system won’t allow you to use the two
identically-named sockets in a way that would confuse the Internet.  The
reason for this option is that some higher-level Internet protocols,
including FTP, require you to keep reusing the same port number.
</para>
<para>The value has type <code>int</code>; a nonzero value means “yes”.
</para>
</dd>
<dt xml:id="glibc-index-SO_005fKEEPALIVE"><span><code>SO_KEEPALIVE</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-SO_005fKEEPALIVE" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>This option controls whether the underlying protocol should
periodically transmit messages on a connected socket.  If the peer
fails to respond to these messages, the connection is considered
broken.  The value has type <code>int</code>; a nonzero value means
“yes”.
</para>
</dd>
<dt xml:id="glibc-index-SO_005fDONTROUTE"><span><code>SO_DONTROUTE</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-SO_005fDONTROUTE" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>This option controls whether outgoing messages bypass the normal
message routing facilities.  If set, messages are sent directly to the
network interface instead.  The value has type <code>int</code>; a nonzero
value means “yes”.
</para>
</dd>
<dt xml:id="glibc-index-SO_005fLINGER"><span><code>SO_LINGER</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-SO_005fLINGER" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>This option specifies what should happen when the socket of a type
that promises reliable delivery still has untransmitted messages when
it is closed; see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Closing-a-Socket">Closing a Socket</a>.  The value has type
<code>struct linger</code>.
</para>
<dl class="def">
<dt xml:id="glibc-index-struct-linger"><span class="category">Data Type: </span><span><strong>struct linger</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-struct-linger" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>This structure type has the following members:
</para>
<dl compact="compact">
<dt><span><code>int l_onoff</code></span></dt>
<dd><para>This field is interpreted as a boolean.  If nonzero, <code>close</code>
blocks until the data are transmitted or the timeout period has expired.
</para>
</dd>
<dt><span><code>int l_linger</code></span></dt>
<dd><para>This specifies the timeout period, in seconds.
</para></dd>
</dl>
</dd></dl>

</dd>
<dt xml:id="glibc-index-SO_005fBROADCAST"><span><code>SO_BROADCAST</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-SO_005fBROADCAST" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>This option controls whether datagrams may be broadcast from the socket.
The value has type <code>int</code>; a nonzero value means “yes”.
</para>
</dd>
<dt xml:id="glibc-index-SO_005fOOBINLINE"><span><code>SO_OOBINLINE</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-SO_005fOOBINLINE" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>If this option is set, out-of-band data received on the socket is
placed in the normal input queue.  This permits it to be read using
<code>read</code> or <code>recv</code> without specifying the <code>MSG_OOB</code>
flag.  See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Out_002dof_002dBand-Data">Out-of-Band Data</a>.  The value has type <code>int</code>; a
nonzero value means “yes”.
</para>
</dd>
<dt xml:id="glibc-index-SO_005fSNDBUF"><span><code>SO_SNDBUF</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-SO_005fSNDBUF" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>This option gets or sets the size of the output buffer.  The value is a
<code>size_t</code>, which is the size in bytes.
</para>
</dd>
<dt xml:id="glibc-index-SO_005fRCVBUF"><span><code>SO_RCVBUF</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-SO_005fRCVBUF" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>This option gets or sets the size of the input buffer.  The value is a
<code>size_t</code>, which is the size in bytes.
</para>
</dd>
<dt xml:id="glibc-index-SO_005fSTYLE"><span><code>SO_STYLE</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-SO_005fSTYLE" class="copiable-anchor"> ¶</a></span></dt>
<dt xml:id="glibc-index-SO_005fTYPE"><span><code>SO_TYPE</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-SO_005fTYPE" class="copiable-anchor"> ¶</a></span></dt>
<dd>

<para>This option can be used with <code>getsockopt</code> only.  It is used to
get the socket’s communication style.  <code>SO_TYPE</code> is the
historical name, and <code>SO_STYLE</code> is the preferred name in GNU.
The value has type <code>int</code> and its value designates a communication
style; see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Communication-Styles">Communication Styles</a>.
</para>
</dd>
<dt xml:id="glibc-index-SO_005fERROR"><span><code>SO_ERROR</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-SO_005fERROR" class="copiable-anchor"> ¶</a></span></dt>
<dd>

<para>This option can be used with <code>getsockopt</code> only.  It is used to reset
the error status of the socket.  The value is an <code>int</code>, which represents
the previous error status.
</para></dd>
</dl>

<hr>
</div>
</div>
<sect xml:id="glibc-Networks-Database">
<div class="header">
<para>
Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Socket-Options" accesskey="p" rel="prev">Socket Options</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Sockets" accesskey="u" rel="up">Sockets</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Networks-Database-1"></span><h3 class="section">16.13 Networks Database</title>
<span xml:id="glibc-index-networks-database"></span>
<span xml:id="glibc-index-converting-network-number-to-network-name"></span>
<span xml:id="glibc-index-converting-network-name-to-network-number"></span>

<span xml:id="glibc-index-_002fetc_002fnetworks"></span>
<span xml:id="glibc-index-netdb_002eh-3"></span>
<para>Many systems come with a database that records a list of networks known
to the system developer.  This is usually kept either in the file
<filename>/etc/networks</filename> or in an equivalent from a name server.  This data
base is useful for routing programs such as <code>route</code>, but it is not
useful for programs that simply communicate over the network.  We
provide functions to access this database, which are declared in
<filename>netdb.h</filename>.
</para>
<dl class="def">
<dt xml:id="glibc-index-struct-netent"><span class="category">Data Type: </span><span><strong>struct netent</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-struct-netent" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>This data type is used to represent information about entries in the
networks database.  It has the following members:
</para>
<dl compact="compact">
<dt><span><code>char *n_name</code></span></dt>
<dd><para>This is the “official” name of the network.
</para>
</dd>
<dt><span><code>char **n_aliases</code></span></dt>
<dd><para>These are alternative names for the network, represented as a vector
of strings.  A null pointer terminates the array.
</para>
</dd>
<dt><span><code>int n_addrtype</code></span></dt>
<dd><para>This is the type of the network number; this is always equal to
<code>AF_INET</code> for Internet networks.
</para>
</dd>
<dt><span><code>unsigned long int n_net</code></span></dt>
<dd><para>This is the network number.  Network numbers are returned in host
byte order; see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Byte-Order">Byte Order Conversion</a>.
</para></dd>
</dl>
</dd></dl>

<para>Use the <code>getnetbyname</code> or <code>getnetbyaddr</code> functions to search
the networks database for information about a specific network.  The
information is returned in a statically-allocated structure; you must
copy the information if you need to save it.
</para>
<dl class="def">
<dt xml:id="glibc-index-getnetbyname"><span class="category">Function: </span><span><emphasis>struct netent *</emphasis> <strong>getnetbyname</strong> <emphasis>(const char *<var>name</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-getnetbyname" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Unsafe race:netbyname env locale
| AS-Unsafe dlopen plugin heap lock
| AC-Unsafe corrupt lock fd mem
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>The <code>getnetbyname</code> function returns information about the network
named <var>name</var>.  It returns a null pointer if there is no such
network.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-getnetbyaddr"><span class="category">Function: </span><span><emphasis>struct netent *</emphasis> <strong>getnetbyaddr</strong> <emphasis>(uint32_t <var>net</var>, int <var>type</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-getnetbyaddr" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Unsafe race:netbyaddr locale
| AS-Unsafe dlopen plugin heap lock
| AC-Unsafe corrupt lock fd mem
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>The <code>getnetbyaddr</code> function returns information about the network
of type <var>type</var> with number <var>net</var>.  You should specify a value of
<code>AF_INET</code> for the <var>type</var> argument for Internet networks.
</para>
<para><code>getnetbyaddr</code> returns a null pointer if there is no such
network.
</para></dd></dl>

<para>You can also scan the networks database using <code>setnetent</code>,
<code>getnetent</code> and <code>endnetent</code>.  Be careful when using these
functions because they are not reentrant.
</para>
<dl class="def">
<dt xml:id="glibc-index-setnetent"><span class="category">Function: </span><span><emphasis>void</emphasis> <strong>setnetent</strong> <emphasis>(int <var>stayopen</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-setnetent" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Unsafe race:netent env locale
| AS-Unsafe dlopen plugin heap lock
| AC-Unsafe corrupt lock fd mem
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>This function opens and rewinds the networks database.
</para>
<para>If the <var>stayopen</var> argument is nonzero, this sets a flag so that
subsequent calls to <code>getnetbyname</code> or <code>getnetbyaddr</code> will
not close the database (as they usually would).  This makes for more
efficiency if you call those functions several times, by avoiding
reopening the database for each call.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-getnetent"><span class="category">Function: </span><span><emphasis>struct netent *</emphasis> <strong>getnetent</strong> <emphasis>(void)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-getnetent" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Unsafe race:netent race:netentbuf env locale
| AS-Unsafe dlopen plugin heap lock
| AC-Unsafe corrupt lock fd mem
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>This function returns the next entry in the networks database.  It
returns a null pointer if there are no more entries.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-endnetent"><span class="category">Function: </span><span><emphasis>void</emphasis> <strong>endnetent</strong> <emphasis>(void)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-endnetent" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Unsafe race:netent env locale
| AS-Unsafe dlopen plugin heap lock
| AC-Unsafe corrupt lock fd mem
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>This function closes the networks database.
</para></dd></dl>
<hr>
</div>
</div-->
</part>
