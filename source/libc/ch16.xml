<?xml version="1.0" encoding="UTF-8"?>
<!-- ********************************************************************
        glibc/ch16.xml,v2.36, GFDL,LGPL, NBB, 2023
     ******************************************************************** -->
<part xml:id="glibc-Sockets" userlevel="longtoc">
 <title>Soketler</title>
 <titleabbrev>Ağ destekli, biraz daha karmaşık, süreçler arası iletişim düzeneği.</titleabbrev>
 <preliminary>
  <para>
   Bu kısımda soketleri kullanarak süreçler arası iletişim için kullanılan GNU oluşumlarından bahsedilmiştir.
  </para>
  <para>
   <indexterm linkend="glibc-cp"><primary>soketler</primary></indexterm>
   <indexterm linkend="glibc-cp"><primary>soketler</primary><secondary>süreçler arası iletişim</secondary></indexterm>
   <dicterm><english>broadcast messages</english><turkish>yayın iletileri</turkish></dicterm>
   <dicterm><english>header file</english><turkish>başlık dosyası</turkish></dicterm>
   Bir <wordasword>soket</wordasword> genelleştirilmiş süreçler arası iletişim kanalıdır. Ardışık süreçler gibi soketler de bir dosya tanıtıcı olarak temsil edilir. Ardışık süreçlerden farklı olarak soketler aralarında ilişki olmayan süreçler arasındaki iletişimi ve hatta ağ üzerindeki farklı makineler üzerinde çalışan süreçler arasındaki iletişimi de destekler. Soketlerin birincil kullanım alanları farklı makinelerle iletişimdir; <uri xl:href="man1-telnet"/>, <uri xl:href="man1-rlogin"/>, <uri xl:href="man1-ftp"/>, <uri xl:href="man1-talk"/> ve diğer bildik ağ yazılımları soketleri kullanır.
  </para>
  <para>
   Bütün işletim sistemleri soketleri desteklememektedir. &glibc;nde, işletim sisteminden bağımsız olarak &sys-socket.h; başlık dosyası ve beraberinde soket işlevleri daima bulunur, fakat eğer sistem soketleri desteklemiyorsa bu işlevler daima başarısız olur.
  </para>
  <note><title>Eksik</title>
   <para>
    Yayın iletileri veya İnternet arayüzünün ayarlanması ile ilgili oluşumlar henüz belgelenmemiştir. IPv6 ile ilgili bazı yeni işlevler ve evresel işlevler de henüz belgelenmemiştir.
   </para>
  </note>
 </preliminary>
 <chapter xml:id="glibc-Socket-Concepts">
  <title>Soket Kavramları</title>
  <titleabbrev>Bilinmesi gereken basit kavramlar.</titleabbrev>
  <para>
   <indexterm linkend="glibc-cp"><primary>soketler</primary><secondary>iletişim tarzı</secondary></indexterm>
   <indexterm linkend="glibc-cp"><primary>iletişim tarzı</primary><secondary>soketler</secondary></indexterm>
   Bir soket oluşturulduğunda, kullanılmak istenen iletişim tarzının ve bunu uygulayacak protokol türünün belirtilmesi gerekir. Bir soketin <wordasword>iletişim tarzı</wordasword>, soket üzerinde veri gönderimi ve alımının kullanıcı-seviyesindeki anlamını tanımlar. İletişim tarzının seçimi aşağıdaki sorulara yanıt olur:
  </para>
  <variablelist>
   <varlistentry>
    <term>Veri iletimi birimleri nelerdir?
     <indexterm linkend="glibc-cp"><primary>paket</primary></indexterm>
     <indexterm linkend="glibc-cp"><primary>bayt akımları</primary></indexterm>
     <indexterm linkend="glibc-cp"><primary>akımlar</primary><secondary>soketler</secondary></indexterm>
     <indexterm linkend="glibc-cp"><primary>soketler</primary><secondary>akımlar</secondary></indexterm>
    </term>
    <listitem>
     <para>
      Bazı iletişim tarzları veriye büyük bir yapısı olmayan bir dizi bayt olarak bakar; bazıları da bu baytları gruplayarak birer kayıt olarak ele alır (bu bağlamda bunlara <wordasword>paket</wordasword> denir).
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Normal bir işlem sırasında veri kaybı olur mu?
     <indexterm linkend="glibc-cp"><primary>soketler</primary><secondary>veri kaybı</secondary></indexterm>
     <indexterm linkend="glibc-cp"><primary>veri kaybı</primary><secondary>soketler üzerinde</secondary></indexterm>
    </term>
    <listitem>
     <para>
      Bazı iletişim tarzları gönderilen her verinin ulaştığını garanti eder (sistem veya ağ çökmediği takdirde); diğer tarzlar ara sıra gerçekleşen veri kaybını normal karşılayıp, bazı paketleri defalarca veya yanlış sırada gönderebilir.
     </para>
     <para>
      Güvenilmez bir iletişim tarzını kullanan bir yazılım tasarımı genellikle kayıp veya yanlış sırada gönderilen paketleri tespit edecek, gerektiğinde veriyi tekrar gönderecek tedbirler içerir.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>İletişim sadece tek eşle mi gerçekleştirilir?</term>
    <listitem>
     <para>
      Bazı iletişim tarzları telefon konuşmasına benzer; karşı soket ile <wordasword>bağlantı</wordasword> kurulur ve veri alışverişi gerçekleştirilir. Diğer tarzlar ise mektuba benzer; gönderilecek her ileti için adres belirtmek gerekir.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
  <para>
   <dicterm><english>namespace</english><turkish>isim alanı</turkish></dicterm>
   <dicterm><english>domain</english><turkish>etki alanı</turkish></dicterm>
   <dicterm><english>protocol</english><turkish>protokol</turkish></dicterm>
   <indexterm linkend="glibc-cp"><primary>soketler</primary><secondary>isim alanları</secondary></indexterm>
   <indexterm linkend="glibc-cp"><primary>soketler</primary><secondary>etki alanları</secondary></indexterm>
   <indexterm linkend="glibc-cp"><primary>soket isim alanı</primary></indexterm>
   <indexterm linkend="glibc-cp"><primary>soket etki alanı</primary></indexterm>
   Ayrıca, soketi isimlendirmek için bir <wordasword>isim alanı</wordasword> seçilmelidir. Soket adı ("adresi") sadece belirli bir isim alanı içerisinde anlamlıdır. Aslında, soket ismi için kullanılacak veri türü bile isim alanına bağlı olabilir. İsim alanları "Etki Alanı" (domain) olarak da adlandırılır, ancak kavram karmaşası yaratmamak için bu kullanımdan kaçınılmıştır. Her isim alanının <code>PF_</code> ile başlayan simgesel bir ismi vardır. Buna ilişkin <code>AF_</code> ile başlayan simgesel isim bu isim alanının adres biçimini gösterir.
  </para>
  <para>
   <indexterm linkend="glibc-cp"><primary>ağ protokolü</primary></indexterm>
   <indexterm linkend="glibc-cp"><primary>protokoller</primary><secondary>soketler</secondary></indexterm>
   <indexterm linkend="glibc-cp"><primary>soketler</primary><secondary>protokoller</secondary></indexterm>
   <indexterm linkend="glibc-cp"><primary>soket protokolü</primary></indexterm>
   <indexterm linkend="glibc-cp"><primary>protokol ailesi</primary></indexterm>
   Son olarak iletişimi sağlayacak protokolün seçilmesi gerekir. <wordasword>Protokol</wordasword> veri gönderim ve alımında hangi alt seviye düzeneğin kullanılacağını belirler. Her protokol belirli bir isim alanı ve iletişim tarzı için geçerlidir; bir isim alanı zaman zaman <wordasword>protokol ailesi</wordasword> olarak adlandırıldığı için, isim alanının simgesel ismi <code>PF_</code>  ("Protocol Family" kısaltması) ile başlar.
  </para>
  <para>
   Protokol kuralları iki yazılım, belki de iki ayrı bilgisayar arasında geçen veriye uygulanır; bu kuralların birçoğu işletim sistemi tarafından halledilir ve işletim sistemi tarafından halledilenler konumuzun dışındadır. Protokoller ile ilgili bilinmesi gerekenler:
  </para>
  <simplelist>
   <member>
    İki soket arasında iletişimin gerçekleşmesi için, soketler <emphasis>aynı</emphasis> protokolü kullanmalıdır.
   </member>
   <member>
    Her protokol belirli bir tarz ve isim alanının birleşimi olarak anlam kazanır ve uygun olmayan bileşimlerle kullanılamaz. Örneğin TCP protokolü sadece bayt akımı tarzında iletişim ile İnternet isim alanına uyar.
   </member>
   <member>
    Her tarz ve isim alanı bileşimi için bir <wordasword>varsayılan protokol</wordasword> vardır, protokol numarasına 0 belirtilerek istenebilir. Normalde yapılması gereken de budur; varsayılan protokol kullanılmalıdır.
   </member>
  </simplelist>
  <para>
   Bu kısımdaki açıklamaların başından sonuna çeşitli yerlerde değişken/bağımsız değişken boyutunu göstermek gerekmektedir. Ve işte burada sorun başlar. İlk uygulamalarda bu değişkenlerin değişken türü basitçe <type>int</type> idi. Zamanımızda birçok makinede <type>int</type> 32 bit genişliğindedir ve <emphasis>fiilen</emphasis> 32 bitlik bir değişken standardı yaratmıştır. Bu tür değişken göstericileri, çekirdeğe aktarıldığı için önemlidir.
  </para>
  <para>
   Ardından POSIX'çiler, "bütün büyüklük değerleri <type>size_t</type> türündedir" sözleriyle arayüzü birleştirmiştir. 64 bitlik makinelerde <type>size_t</type> 64 bit genişliğindedir, böylece değişkenlere göstericiler ortadan kalkmıştır.
  </para>
  <para>
   Unix98 belirtimi <type>socklen_t</type> türü ile bir çözüm üretmiştir. Bu tür, POSIX'in <type>size_t</type> olarak değiştirdiği tüm hallerde kullanılır. Bu türün tek gereksinimi işaretsiz en az 32 bittir. Bu nedenle 32 bitlik değişkenlere aktarılacak göstericiler, 64 bitlik değerler kullanan gerçeklenimlerle kolayca aktarılabilir.
  </para>
 </chapter>
 <chapter xml:id="glibc-Communication-Styles">
  <title>İletişim Tarzları</title>
  <titleabbrev>Akım iletişimi, veri katarları ve diğer tarzlar.</titleabbrev>
  <para>
   &glibc; her biri farklı özellikte, birkaç farklı soket türü için destek içerir. Bu bölümde desteklenen soket türleri açıklanmaktadır. Burada listelenen simgesel sabitler &sys-socket.h; başlık dosyasında tanımlanmıştır.
   <indexterm linkend="glibc-pg"><primary>sys/socket.h</primary></indexterm>
  </para>
  <csynopsis>
   <indexterm linkend="glibc-vr" xml:id="glibc-vr-SOCK_STREAM"><primary>SOCK_STREAM</primary></indexterm>
   <csproto type="makro">
    <csname><type>int</type><function>SOCK_STREAM</function></csname>
   </csproto>
   <header>&sys-socket.h;</header>
   <para>
    <code>SOCK_STREAM</code> tarzı <link linkend="glibc-Pipes-and-FIFOs">ardışık süreç akımı</link> gibidir. Belirli bir karşı soket bağlantısıyla çalışır ve veriyi bir bayt akımı olarak güvenle iletir.
   </para>
   <para>
    Bu tarz ayrıntılı olarak <xref linkend="glibc-Connections"/> başlığı altında açıklanmıştır.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-vr" xml:id="glibc-vr-SOCK_DGRAM"><primary>SOCK_DGRAM</primary></indexterm>
   <csproto type="makro">
    <csname><type>int</type><function>SOCK_DGRAM</function></csname>
   </csproto>
   <header>&sys-socket.h;</header>
   <para>
    <code>SOCK_DGRAM</code> tarzı, tek tek adreslenen paketlerin güvensiz şekilde iletiminde kullanılır. Bu, <varname>SOCK_STREAM</varname> tarzının tam zıddıdır.
   </para>
   <para>
    Sokete bu türde her veri yazımında, veri bir paket haline gelir. <varname>SOCK_DGRAM</varname> soketlerinin bağlantıları olmadığı için her paketle birlikte alıcı adresinin de belirtilmesi gerekir.
   </para>
   <para>
    Sistemin veri iletimi ile ilgili isteklere verdiği tek garanti gönderilen her paketin teslimi için elinden gelenin en iyisinin deneneceğidir. Dördüncü ve beşinci pakette başarısızlığa uğradıktan sonra altıncı pakette başarıya ulaşılabilir, yedinci paket altıncıdan önce ulaşabilir ve altıncı paketten sonra ikinci defa ulaştırılabilir.
   </para>
   <para>
    <varname>SOCK_DGRAM</varname>'ın en bildik kullanım şekli, makul bir süre içerisinde karşı taraftan yanıt gelmemesi halinde paketin tekrar gönderilmesinin kabul edilebilir olduğu durumlardır.
   </para>
   <para>
    <xref linkend="glibc-Datagrams"/>, konu başlığı altında veri katarı soketlerinin kullanımı hakkında ayrıntılı bilgi bulunmaktadır.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-vr" xml:id="glibc-vr-SOCK_RAW"><primary>SOCK_RAW</primary></indexterm>
   <csproto type="makro">
    <csname><type>int</type><function>SOCK_RAW</function></csname>
   </csproto>
   <header>&sys-socket.h;</header>
   <para>
    Bu tarz, alt-seviye ağ protokolleri ve arayüzlerine erişimi destekler. Sıradan kullanıcı yazılımları genellikle bu tarzı kullanma ihtiyacı duymaz.
   </para>
  </csynopsis>
 </chapter>
 <chapter xml:id="glibc-Socket-Addresses">
  <title>Soket Adresleri</title>
  <titleabbrev>Soket isimleri ("adresleri") nasıl çalışır.</titleabbrev>
  <para>
   <indexterm linkend="glibc-cp"><primary>soket adresi</primary></indexterm>
   <indexterm linkend="glibc-cp"><primary>soket ismi</primary></indexterm>
   <indexterm linkend="glibc-cp"><primary>soketler</primary><secondary>adresler</secondary></indexterm>
   <indexterm linkend="glibc-cp"><primary>soketler</primary><secondary>adresler</secondary><tertiary>bağlanması</tertiary></indexterm>
   Soket ismi genelde <wordasword>adres</wordasword> olarak kullanılır. Soket adresleriyle ilgili işlev ve simgelerin isimlendirmesinde tutarsızlıklar vardır, bazen "isim" terimi bazen "adres" terimi kullanılmıştır. Soket konusu içinde bu terimler eşanlamlı kabul edilebilir.
  </para>
  <para>
   <function>socket</function> işlevi ile yeni oluşturulan bir soketin adresi yoktur. Diğer süreçlerin onunla iletişim kurması için adres vermek gerekir. Buna <wordasword>adresin sokete bağlanması</wordasword> denir ve bunu yapmak için <function>bind</function> işlevi kullanılır.
  </para>
  <para>
   Diğer süreçlerin soketi bulup iletişime başlayabilmesi için soket adresine ihtiyaç duyulacaktır. Diğer soketler için de kullanılacaksa birer adres belirtilebilir, fakat bu genelde anlamsızdır; soketten ilk veri gönderiminde veya soketle bağlantı başlatıldığında, henüz belirtilmemişse sistem özdevinimli olarak sokete adresini atayacaktır.
  </para>
  <para>
   Bazan istemcinin adres belirtmesi gerekir çünkü sunucu adrese göre ayrım yapmaktadır; örneğin, <code>rsh</code> ve <code>rlogin</code> protokolleri istemcinin soket adresine bakar ve yalnızca <varname>IPPORT_RESERVED</varname> değerinden küçükse parola denetimini atlar (Bkz, <xref linkend="glibc-Ports"/>).
  </para>
  <para>
   Soket adresleriyle ilgili ayrıntılar kullanılan isim alanına bağlı olarak değişir. Bu konu hakkında daha ayrıntılı bilgi <xref linkend="glibc-Local-Namespace"/> veya <xref linkend="glibc-Internet-Namespace"/> başlıkları altında bulunabilir.
  </para>
  <para>
   Soket adresini belirtmek ve sınamak için <function>bind</function> ve <function>getsockname</function> işlevleri isim alanına bakılmaksızın kullanılabilir. Bu işlevler adresi kabul etmek için sahte bir veri türü olan <type>struct sockaddr *</type> türünü  kullanır. Uygulamada adres kullanılan biçime uygun başka bir veri türündeki yapıda tutulur, fakat <function>bind</function> işlevine aktarırken adresin <type>struct sockaddr *</type> türüne dönüştürülmesi gerekir.
  </para>
  <sect1 xml:id="glibc-Address-Formats">
   <title>Adres Biçimleri</title>
   <titleabbrev><code>sockaddr</code> yapısı hakkında.</titleabbrev>
   <para>
    <function>bind</function> ve <function>getsockname</function> işlevleri soket adresine gösterici olarak genel bir veri türü olan <type>struct&nbsp;sockaddr</type> türünü kullanır. Bu veri türünün bir adresi yorumlamak veya oluşturmak için kullanılması verimli değildir; bunun yerine soketin isim alanı ile uyumlu bir veri türünün kullanılması gerekir.
   </para>
   <para>
    Bu bakımdan genel kullanımda, uygun isim alanına özgü bir adres oluşturulur, ardından da <function>bind</function> veya <function>getsockname</function> çağrılarak <type>struct&nbsp;sockaddr</type> türünde bir göstericiye dönüştürülür.
   </para>
   <para>
    <type>struct&nbsp;sockaddr</type> veri türünden alınabilecek bilgilerden biri de <wordasword>adres biçim tasarımcısı</wordasword>dır. Bu, adresin tamamını anlamak için hangi veri türünün kullanılacağını belirler.
   </para>
   <para>
    <indexterm linkend="glibc-pg"><primary>sys/socket.h</primary></indexterm>
    Bu bölümdeki simgeler &sys-socket.h; başlık dosyasında tanımlanmıştır.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-tp" xml:id="glibc-tp-sockaddr"><primary sortas="sockaddr">struct&nbsp;sockaddr</primary></indexterm>
    <csproto type="veri türü">
     <csname><type>struct</type><function>sockaddr</function></csname>
    </csproto>
    <header>&sys-socket.h;</header>
    <para>
     <code>struct&nbsp;sockaddr</code> türü aşağıdaki üyelere sahiptir:
    </para>
    <glosslist>
     <glossentry>
      <glossterm>
       <type>short&nbsp;int&nbsp;</type><structfield>sa_family</structfield>
      </glossterm>
      <glossdef>
       <para>
        Adresin adres biçim kodudur. Takip eden verinin biçimini tanımlar.
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm>
       <type>char&nbsp;</type><structfield>sa_data[14]</structfield>
      </glossterm>
      <glossdef>
       <para>
        Biçime bağımlı olan asıl soket adresi verisidir. Uzunluğu biçime bağlıdır ve 14'ten büyük olabilir. <code>sa_data</code> üyesinin 14 olan uzunluğu temelde isteğe bağlıdır.
       </para>
      </glossdef>
     </glossentry>
    </glosslist>
   </csynopsis>
   <para>
    Her adres biçimi <code>AF_</code> ile başlayan simgesel bir isme sahiptir. Her biri ilgili isim alanını tasarlayan bir <code>PF_</code>simgesi ile eşleşir. Aşağıda adres biçim isimlerinin listesi görülmektedir:
   </para>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-AF_LOCAL"><primary>AF_LOCAL</primary></indexterm>
    <csproto type="sabit">
     <csname><function>AF_LOCAL</function></csname>
    </csproto>
    <para>
     Yerel isim alanıyla giden adres biçimini tasarlar (<varname>PF_LOCAL</varname> isim alanının adıdır).  Bu adres biçimi hakkında <xref linkend="glibc-Local-Namespace-Details"/> bölümünde daha ayrıntılı  bilgi bulunabilir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-AF_UNIX"><primary>AF_UNIX</primary></indexterm>
    <csproto type="sabit">
     <csname><function>AF_UNIX</function></csname>
    </csproto>
    <para>
     <varname>AF_LOCAL</varname> ile eşanlamlıdır. Gerçi <varname>AF_LOCAL</varname> POSIX.1g tarafından önerilmişse de, <code>AF_UNIX</code> sistemler arasında daha taşınabilirdir. <code>AF_UNIX</code>, BSD kaynaklı geleneksel ismidir, hatta birçok POSIX sisteminde desteklenmektedir. Bu aynı zamanda Unix98 belirtimi için de seçilen isimdir. (Aynı şey <varname>PF_UNIX</varname> ve dolayısıyla <varname>PF_LOCAL</varname> için de geçerlidir.)
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-AF_FILE"><primary>AF_FILE</primary></indexterm>
    <csproto type="sabit">
     <csname><function>AF_FILE</function></csname>
    </csproto>
    <para>
     Uyumluluk için konulmuştur ve <varname>AF_LOCAL</varname> ile eşanlamlıdır
     (Keza <varname>PF_FILE</varname> da <varname>PF_LOCAL</varname> ile eşanlamlıdır).
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-AF_INET"><primary>AF_INET</primary></indexterm>
    <csproto type="sabit">
     <csname><function>AF_INET</function></csname>
    </csproto>
    <para>
     İnternet isim alanıyla giden adres biçimini tasarlar (<varname>PF_INET</varname> isim alanının adıdır). Bkz, <xref linkend="glibc-Internet-Address-Formats"/>.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-AF_INET6"><primary>AF_INET6</primary></indexterm>
    <csproto type="sabit">
     <csname><function>AF_INET6</function></csname>
    </csproto>
    <para>
     <varname>AF_INET</varname> ile benzerdir, fakat IPv6 protokolüyle ilgilidir (<varname>PF_INET6</varname> IPv6'ya ilişkin isim alanının adıdır).
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-AF_UNSPEC"><primary>AF_UNSPEC</primary></indexterm>
    <csproto type="sabit">
     <csname><function>AF_UNSPEC</function></csname>
    </csproto>
    <para>
     Belirli bir adres biçimi tasarlamaz. Kullanımı çok nadirdir, örneğin "bağlı" bir veri katarı soketinin varsayılan hedef adresini silmek için kullanılır. Bkz, <xref linkend="glibc-Sending-Datagrams"/>.
    </para>
    <para>
     İlişkili isim alanının tasarlayıcı simgesi <varname>PF_UNSPEC</varname> tamamlayıcı olarak bulunmaktadır, fakat yazılım içinde kullanmanın anlamı yoktur.
    </para>
   </csynopsis>
   <para>
    &sys-socket.h; birçok farklı ağ türü için <code>AF_</code> ile başlayan birçok simge tanımlar, birçoğu veya tamamı aslında gerçekleştirilmemiştir. Bunlar düzgün çalışmaya başladığı zaman ve nasıl kullanıldığı hakkında bilgi edinildiğinde bunlar da belgelendirelecektir.
   </para>
  </sect1>
  <sect1 xml:id="glibc-Setting-Address">
   <title>Adreslerin Atanması</title>
   <titleabbrev>Bir adresin bir sokete bağlanması.</titleabbrev>
   <para>
    <indexterm linkend="glibc-pg"><primary>sys/socket.h</primary></indexterm>
    Bir sokete adres atamak için <function>bind</function> işlevi kullanılır.   <function>bind</function> işlevi &sys-socket.h; başlık dosyasında bildirilmiştir. Örnek kullanımlar <xref linkend="glibc-Local-Socket-Example"/> ve <xref linkend="glibc-Inet-Example"/> bölümlerinde bulunabilir.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-bind"><primary>bind</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-bind"><primary>soketler</primary><secondary>bağlanması</secondary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>bind</function></csname>
     <csparam><type>int</type><parameter>socket</parameter></csparam>
     <csparam><ptr>struct&#160;sockaddr</ptr><parameter>addr</parameter></csparam>
     <csparam><type>socklen_t</type><parameter>length</parameter></csparam>
    </csproto>
    <header>&sys-socket.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     <code>bind</code> işlevi <parameter>socket</parameter> soketine adresini tanımlar. Soket adresi <parameter>addr</parameter>, adres uzunluğu <parameter>length</parameter> bağımsız değişkenleri ile belirtilir; adresin ayrıntılı biçimi isim alanına bağlıdır. Adresin ilk kısmı daima, isim alanını belirten ve adresin o isim alanı biçiminde olduğunu söyleyen, biçim tasarlayıcısıdır.
    </para>
    <para>
     Hata olduğunda <code>-1</code> olmadığında <code>0</code> değeri döndürür. Aşağıdaki <varname>errno</varname> hata durumları bu işlev için tanımlanmıştır:
    </para>
    <variablelist>
     <varlistentry>
      <term><code>EBADF</code></term>
      <listitem>
       <para>
        <parameter>socket</parameter> bağımsız değişkeni geçerli bir dosya tanıtıcı değil.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>ENOTSOCK</code></term>
      <listitem>
       <para>
        <parameter>socket</parameter> tanıtıcısı bir soket değil.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>EADDRNOTAVAIL</code></term>
      <listitem>
       <para>
        Belirtilen adres bu makinede bulunmuyor.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>EADDRINUSE</code></term>
      <listitem>
       <para>
        Başka bir soket zaten belirtilen adresi kullanıyor.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>EINVAL</code></term>
      <listitem>
       <para>
        <parameter>socket</parameter> soketinin zaten bir adresi var.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>EACCES</code></term>
      <listitem>
       <para>
        İstenilen adrese erişim için izniniz yok. (İnternet etki alanı içinde, sadece süper kullanıcı <code>0</code> ile <varname>IPPORT_RESERVED</varname> eksi bir aralığında port numarası tanımlayabilir; bkz, <xref linkend="glibc-Ports"/>.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
    <para>
     Soketin özel isim alanına bağlı olarak ek koşullar mümkün olabilir.
    </para>
   </csynopsis>
  </sect1>
  <sect1 xml:id="glibc-Reading-Address">
   <title>Adresin Okunması</title>
   <titleabbrev>Soket adresinin okunması.</titleabbrev>
   <para>
    <indexterm linkend="glibc-pg"><primary>sys/socket.h</primary></indexterm>
    <function>getsockname</function> işlevi &sys-socket.h; başlık dosyasında bildirilmiş olup bir internet soketinin adresini almak için kullanılır.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-getsockname"><primary>getsockname</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-getsockname"><primary>soketler</primary><secondary>adresin alınması</secondary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>getsockname</function></csname>
     <csparam><type>int</type><parameter>socket</parameter></csparam>
     <csparam><ptr>struct&#160;sockaddr</ptr><parameter>addr</parameter></csparam>
     <csparam><ptr>socklen_t</ptr><parameter>length-ptr</parameter></csparam>
    </csproto>
    <header>&sys-socket.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe; &mem;<code linkend="glibc-safety-condition">/hurd</code></concept>
    </conceptlist>
    <para>
     <code>getsockname</code> işlevi <parameter>socket</parameter> soketinin <parameter>addr</parameter> ve <parameter>length-ptr</parameter> bağımsız değişkenleri ile belirlenen adresi ile ilgili bilgiyi döndürür. <parameter>length-ptr</parameter> bağımsız değişkeninin bir gösterici olması nedeniyle <parameter>addr</parameter> boyutu kadar yer tahsis edilecek şekilde ilklendirilmelidir, böylece değer döndürüldüğünde adres verisinin gerçek boyutunu içerecektir.
    </para>
    <para>
     Adres verisinin biçimi soket isim alanına bağlıdır. Belirtilen isim alanının bilgi uzunluğu genelde sabittir, böylece normalde ne kadar alan gerektiği tam olarak bilinir. Genel uygulama soketin isim alanı için uygun veri türünü kullanarak değer için yer tahsis etmek, ardından adresi <code>getsockname</code> işlevine aktarmak için <code>struct sockaddr *</code> türüne dönüştürmektir.
    </para>
    <para>
     Hata olduğunda <code>-1</code> olmadığında <code>0</code> değeri döner. Aşağıdaki <varname>errno</varname> hata durumları bu işlev için tanımlanmıştır:
    </para>
    <variablelist>
     <varlistentry>
      <term><code>EBADF</code></term>
      <listitem>
       <para>
        <parameter>socket</parameter> bağımsız değişkeni geçerli bir dosya tanıtıcı değil.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>ENOTSOCK</code></term>
      <listitem>
       <para>
        <parameter>socket</parameter> tanıtıcısı bir soket değil.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>ENOBUFS</code></term>
      <listitem>
       <para>
        Bu işlem için yeterli dahili tampon yok.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </csynopsis>
   <para>
    Dosya isim alanındaki bir soketin adresi okunamaz. Bu sistemin geri kalanı için de geçerlidir, bir dosya tanıtıcıdan dosyanın ismini bulmak mümkün değildir.
   </para>
  </sect1>
 </chapter>
 <chapter xml:id="glibc-Interface-Naming">
  <title>Arayüz İsimlendirmesi</title>
  <titleabbrev>Bazı ağ arayüzlerinin tanımlanması.</titleabbrev>
  <para>
   Her ağ arayüzünün bir ismi vardır. Bu isim genellikle arayüz türüyle ilişkili birkaç harften oluşur, buna ek olarak eğer aynı türde birden fazla arayüz varsa sonuna bir numara eklenir. Örneğin <code>lo</code> (geri dönüş arayüzü - loopback interface) ve <code>eth0</code> (birinci eternet arabirimi).
  </para>
  <para>
   Her ne kadar bunun gibi isimler insanlar için uygun olsa da bir yazılımın arayüz bilgisine her ihtiyaç olduğunda bu kullanım hantal kalabilir. Bu gibi durumlarda arayüze küçük pozitif tamsayı değer olan bir <wordasword>indis</wordasword> ile erişilir.
  </para>
  <para>
   Sözü edilen işlevler, sabitler ve veri türleri &net-if.h; başlık dosyasında bildirilmiştir.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-vr" xml:id="glibc-vr-IFNAMSIZ"><primary>IFNAMSIZ</primary></indexterm>
   <csproto type="sabit">
    <csname><type>size_t</type><function>IFNAMSIZ</function></csname>
   </csproto>
   <header>&net-if.h;</header>
   <para>
    Bu sabit, arayüz ismini ve sonlandırıcı boş baytı tutmak için gerekli azami tampon boyutunu belirtir.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-if_nametoindex"><primary>if_nametoindex</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-if_nametoindex"><primary>soketler</primary><secondary>ağ arayüzü indisi</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>unsigned&#160;int</type><function>if_nametoindex</function></csname>
    <csparam><ptr>const&#160;char</ptr><parameter>ifname</parameter></csparam>
   </csproto>
   <header>&net-if.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&asunsafe; &lock;</concept>
    <concept>&acunsafe; &lock; &fd;</concept>
   </conceptlist>
   <para>
    Bu işlev belirli bir isme karşılık gelen arayüz indisini verir. Belirtilen isimde bir arayüz yoksa <code>0</code> döndürür.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-if_indextoname"><primary>if_indextoname</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-if_indextoname"><primary>soketler</primary><secondary>ağ arayüzü ismi</secondary></indexterm>
   <csproto type="işlev">
    <csname><ptr>char</ptr><function>if_indextoname</function></csname>
    <csparam><type>unsigned&#160;int</type><parameter>ifindex</parameter></csparam>
    <csparam><ptr>char</ptr><parameter>ifname</parameter></csparam>
   </csproto>
   <header>&net-if.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&asunsafe; &lock;</concept>
    <concept>&acunsafe; &lock; &fd;</concept>
   </conceptlist>
   <para>
    Bu işlev bir arayüz indisini karşılık gelen arayüz ismine eşler. Döndürülen isim <parameter>ifname</parameter> ile gösterilen tampona yerleştirilir (<parameter>ifname</parameter> en az <varname>IFNAMSIZ</varname> bayt uzunluğunda olmalıdır). İndis geçersizse boş gösterici, aksi takdirde <parameter>ifname</parameter> döner.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-tp" xml:id="glibc-tp-if_nameindex"><primary sortas="if_nameindex">struct&#160;if_nameindex</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-if_nameindex"><primary>soketler</primary><secondary>ağ arayüz veri türü</secondary></indexterm>
   <csproto type="veri türü">
    <csname><type>struct</type><function>if_nameindex</function></csname>
   </csproto>
   <header>&net-if.h;</header>
   <para>
    Bu veri türü bir arayüz ile ilgili bilgiyi tutmak için kullanılır. Aşağıdaki üyeleri içerir:
   </para>
   <glosslist>
    <glossentry>
     <glossterm>
      <type>unsigned&nbsp;int&nbsp;</type><structfield>if_index</structfield>
     </glossterm>
     <glossdef>
      <para>
       Arayüz indisi.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <type>char&nbsp;*</type><structfield>if_name</structfield>
     </glossterm>
     <glossdef>
      <para>
       Boş bayt sonlandırmalı indis ismi.
       </para>
      </glossdef>
     </glossentry>
    </glosslist>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-if_nameindex"><primary>if_nameindex</primary></indexterm>
   <csproto type="işlev">
    <csname><ptr>struct&#160;if_nameindex</ptr><function>if_nameindex</function></csname>
    <csparam><void/></csparam>
   </csproto>
   <header>&net-if.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&asunsafe; &heap; &lock;<code linkend="glibc-safety-condition">/hurd</code></concept>
    <concept>&acunsafe; &lock;<code linkend="glibc-safety-condition">/hurd</code> &fd; &mem;</concept>
   </conceptlist>
   <para>
    Bu işlev mevcut arayüzlerin her biri için <type>struct&#160;if_nameindex</type> yapısını içeren bir dizi döndürür. Listenin sonu <code>0</code> arayüzü ve boş isim göstericisi içeren bir yapı ile belirtilmiştir.
   </para>
   <para>
    Döndürülen yapı kullanımdan sonra <function>if_freenameindex</function> ile serbest bırakılmalıdır.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-if_freenameindex"><primary>if_freenameindex</primary></indexterm>
   <csproto type="işlev">
    <csname><type>void</type><function>if_freenameindex</function></csname>
    <csparam><ptr>struct&#160;if_nameindex</ptr><parameter>ptr</parameter></csparam>
   </csproto>
   <header>&net-if.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&asunsafe; &heap;</concept>
    <concept>&acunsafe; &mem;</concept>
   </conceptlist>
   <para>
    Bu işlev evvelce yapılmış bir <function>if_nameindex</function> çağrısından dönen yapıyı serbest bırakır.
   </para>
  </csynopsis>
 </chapter>
 <chapter xml:id="glibc-Local-Namespace" userlevel="notoc">
  <?dbhtml stop-chunking?>
  <title>Yerel İsim Alanı</title>
  <titleabbrev>Yerel isim alanı ile ilgili ayrıntılar.</titleabbrev>
  <para>
   <indexterm linkend="glibc-cp"><primary>soketler</primary><secondary>yerel isim alanı</secondary></indexterm>
   Bu bölüm simgesel ismi (soket oluşturulurken ihtiyaç duyulur) <varname>PF_LOCAL</varname> olan yerel isim alanı ile ilgili ayrıntıları açıklar. Yerel isim alanı "Unix etki alanı soketleri" olarak da bilinir. Diğer bir ismi de dosya isim alanıdır, çünkü soket adresleri genelde dosya isimleri olarak gerçeklenmiştir.
  </para>
  <sect1 xml:id="glibc-Local-Namespace-Concepts">
   <title>Yerel İsim Alanı Kavramları</title>
   <titleabbrev>Anlamak için gereken herşey.</titleabbrev>
   <para>
    Yerel isim alanında soket adresleri dosya isimleridir. Soket adresi olarak herhangi bir dosya ismi verilebilir, fakat dosyayı içeren dizine yazma izni verilmesi gerekir. Bu dosyalar genellikle <filename>/tmp</filename> dizini içine konulur.
   </para>
   <para>
    Yerel isim alanının tuhaf bir özelliği de ismin sadece bağlantı açılırken kullanılmasıdır; bir kere adres açıldıktan sonra anlamı yoktur ve bulunmasa da olur.
   </para>
   <para>
    Diğer bir tuhaflık ise böyle bir sokete, diğer makine soketin ismini içeren dosya sistemini paylaşsa bile bağlanılamamasıdır. Soket, dizin listesinde görünür ancak bağlanılamaz. Bazı yazılımlar bunun getirilerini kullanır; örneğin istemciye kendi süreç kimliğini (PID) sorar ve farklı istemcileri ayırt etmek için süreç kimliğini kullanır. Fakat, tasarlanan protokollerde bu yöntemin kullanılması önerilmez, belki bir gün aynı dosya sistemini bağlayan diğer makinelerden de bağlantılara izin verilebilir. Bunun yerine, her yeni istemciye belirleyici bir numara gönderilebilir.
   </para>
   <para>
    Yerel isim alanındaki soket kapatıldıktan sonra, dosya ismini silmek gerekir. Bunun için <function>unlink</function> veya <function>remove</function> kullanılmalıdır. Bkz, <xref linkend="glibc-Deleting-Files"/>.
   </para>
   <para>
    Yerel isim alanı herhangi bir iletişim tarzı için tek bir protokolü, <code>0</code> numaralı protokolü destekler.
   </para>
  </sect1>
  <sect1 xml:id="glibc-Local-Namespace-Details">
   <title>Yerel İsim Alanı ile İlgili Ayrıntılar</title>
   <titleabbrev>Adres biçimi, simgesel isimler, vs.</titleabbrev>
   <para>
    <indexterm linkend="glibc-pg"><primary>sys/socket.h</primary></indexterm>
    Yerel isim alanında bir soket oluşturmak için, <function>socket</function> veya <function>socketpair</function> işlevinin <parameter>namespace</parameter> bağımsız değişkeninde <varname>PF_LOCAL</varname> sabiti kullanılmalıdır. Bu sabit &sys-socket.h; başlık dosyasında tanımlıdır.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-PF_LOCAL"><primary>PF_LOCAL</primary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>PF_LOCAL</function></csname>
    </csproto>
    <header>&sys-socket.h;</header>
    <para>
     İçerisindeki soket adresleri yerel adlar olan yerel isim alanını ve onunla ilgili protokol ailesini gösterir. <code>PF_LOCAL</code> POSIX.1g tarafından kullanılan makrodur.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-PF_UNIX"><primary>PF_UNIX</primary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>PF_UNIX</function></csname>
    </csproto>
    <header>&sys-socket.h;</header>
    <para>
     <varname>PF_LOCAL</varname> ile aynıdır ve uyumluluk için konmuştur.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-PF_FILE"><primary>PF_FILE</primary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>PF_FILE</function></csname>
    </csproto>
    <header>&sys-socket.h;</header>
    <para>
     <varname>PF_LOCAL</varname> ile aynıdır ve uyumluluk için konmuştur.
    </para>
   </csynopsis>
   <para>
    Yerel isim alanları içindeki soket isimlerini tanımlayan yapı &sys-un.h; başlık dosyası içinde tanımlıdır:
    <indexterm linkend="glibc-pg"><primary>sys/un.h</primary></indexterm>
   </para>
   <csynopsis>
    <indexterm linkend="glibc-tp" xml:id="glibc-tp-sockaddr_un"><primary sortas="sockaddr_un">struct&#160;sockaddr_un</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-sockaddr_un"><primary>soketler</primary><secondary>yerel isim alanı adresleri</secondary></indexterm>
    <csproto type="veri türü">
     <csname><type>struct</type><function>sockaddr_un</function></csname>
    </csproto>
    <header>&sys-un.h;</header>
    <para>
     Bu yapı yerel isim alanının soket adreslerini tanımlamak için kullanılır. Aşağıdaki üyeleri içerir:
    </para>
    <glosslist>
     <glossentry>
      <glossterm>
       <type>short&nbsp;int&nbsp;</type><structfield>sun_family</structfield>
      </glossterm>
      <glossdef>
       <para>
        <link linkend="glibc-Socket-Addresses">Soket adresinin</link> adres ailesini veya biçimini belirtir. Yerel isim alanını belirtmek için değeri <varname>AF_LOCAL</varname> olmalıdır.
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm>
       <type>char&nbsp;</type><structfield>sun_path[108]</structfield>
      </glossterm>
      <glossdef>
       <para>
        Bu kullanılacak dosyanın ismidir.
       </para>
       <note><title>Eksik</title>
        <para>
         108 neden sihirli bir numaradır? RMS, bunu sıfır uzunluklu bir dizi yapmayı ve dosya adının uzunluğuna bağlı olarak uygun miktarda depolama alanı tahsisi için <function>alloca</function> işlevini kullanmak üzere aşağıdaki örneği düzenlemeyi önermektedir.
        </para>
       </note>
      </glossdef>
     </glossentry>
    </glosslist>
   </csynopsis>
   <para>
    Yerel isim alanındaki soket adresi için <parameter>length</parameter> bağımsız değişkenini, dosya isminin dizge uzunluğu (dizgeye tahsis edilen alan değil) ve <code>sun_family</code> bileşeninin toplamı olarak hesaplanmalıdır. Soket adresinin uzunluğunu hesaplamak için <varname>SUN_LEN</varname> makrosu kullanılabilir:
   </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-SUN_LEN"><primary>SUN_LEN</primary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>SUN_LEN</function></csname>
     <csparam><ptr>struct&#160;sockaddr_un</ptr><parameter>ptr</parameter></csparam>
    </csproto>
    <header>&sys-un.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     Bu makro yerel isim alanındaki soket adresinin uzunluğunu hesaplar.
    </para>
   </csynopsis>
  </sect1>
  <sect1 xml:id="glibc-Local-Socket-Example">
   <title>Soketlerde Yerel İsim Alanı Örneği</title>
   <titleabbrev>Soket oluşturma örneği.</titleabbrev>
   <para>
    Buradaki örnekte yerel isim alanında bir soketin nasıl oluşturulduğu ve isimlendirildiği gösterilmiştir.
   </para>
   <screen>#include &lt;stddef.h&gt;
#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/un.h&gt;

int
sokete_isim_ver (const char *dosyaismi)
{
  struct sockaddr_un isim;
  int soket;
  size_t boyut;

  /* <replaceable>Soketi oluştur.</replaceable> */
  soket = socket (PF_LOCAL, SOCK_DGRAM, 0);
  if (soket &lt; 0)
    {
      perror ("socket");
      exit (EXIT_FAILURE);
    }

  /* <replaceable>Sokete isim ver.</replaceable> */
  isim.sun_family = AF_LOCAL;
  strncpy (isim.sun_path, dosyaismi, sizeof (isim.sun_path));
  isim.sun_path[sizeof (isim.sun_path) - 1] = '\0';

  /* <replaceable>Adresin konumu, dosya isminin başlangıç konumu
     artı adres uzunluğudur (sonlandıran boş bayt hariç).
     Hesaplama şöyle yapılabilirdi:</replaceable>
       boyut = SUN_LEN (&amp;isim);
  */
  boyut = (offsetof (struct sockaddr_un, sun_path)
          + strlen (isim.sun_path));

  if (bind (soket, (struct sockaddr *) &amp;isim, boyut) &lt; 0)
    {
      perror ("bind");
      exit (EXIT_FAILURE);
    }

  return soket;
}
</screen>
  </sect1>
 </chapter>
 <chapter xml:id="glibc-Internet-Namespace">
  <title>İnternet İsim Alanı</title>
  <titleabbrev>İnternet isim alanı ile ilgili ayrıntılar.</titleabbrev>
  <preliminary>
   <para>
   <indexterm linkend="glibc-cp"><primary>soketler</primary><secondary>İnternet isim alanı</secondary></indexterm>
   Bu bölümde İnternet isim alanında kullanılan soket isimlendirme eğilimleri ve protokoller ile ilgili ayrıntılar açıklanmıştır.
   </para>
  </preliminary>
  <para>
   Başlangıçta İnternet isim alanı sadece IP sürüm 4'ü (IPv4) kullanırdı. İnternetteki konak sayısının artmasıyla, daha büyük bir adres alanına sahip yeni bir protokol gerekti; IP sürüm 6 (IPv6). IPv6 128 bitlik adresleri ortaya attı (IPv4 32 bitliktir) ve diğer özellikleriyle de sonunda IPv4'ün yerine geçecektir.
  </para>
  <para>
   IPv4 İnternet isim alanında soket oluştururken <function>socket</function> veya <function>socketpair</function> işlevinde bağımsız değişken olarak <varname>PF_INET</varname> makrosu kullanılmalıdır. IPv6 adresleri için ise <varname>PF_INET6</varname> makrosu gerekir. Bu makrolar &sys-socket.h; başlık dosyasında tanımlanmıştır.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-vr" xml:id="glibc-vr-PF_INET"><primary>PF_INET</primary></indexterm>
   <csproto type="makro">
    <csname><type>int</type><function>PF_INET</function></csname>
   </csproto>
   <header>&sys-socket.h;</header>
   <para>
    IPv4 İnternet isim alanını ve onunla ilişkili protokol ailesini belirtir.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-vr" xml:id="glibc-vr-PF_INET6"><primary>PF_INET6</primary></indexterm>
   <csproto type="makro">
    <csname><type>int</type><function>PF_INET6</function></csname>
   </csproto>
   <header>&sys-socket.h;</header>
   <para>
    IPv6 İnternet isim alanını ve onunla ilişkili protokol ailesini belirtir.
   </para>
  </csynopsis>
  <para>
   İnternet isim alanı soket adresi aşağıdaki bileşenleri içerir:
  </para>
  <itemizedlist>
   <listitem>
    <para>
     Bağlanılacak makinenin adresi. İnternet adresi çeşitli yollarla belirtilebilir; bunlar <xref linkend="glibc-Internet-Address-Formats"/>,  <xref linkend="glibc-Host-Addresses"/> ve <xref linkend="glibc-Host-Names"/> başlıkları altında açıklanmıştır.
    </para>
   </listitem>
   <listitem>
    <para>
     Bağlanılacak makinenin port numarası. Bkz. <xref linkend="glibc-Ports"/>.
    </para>
   </listitem>
  </itemizedlist>
  <para>
   Adres ve port numarasının <wordasword>ağ bayt sırası</wordasword> denilen bayt sıralamasıyla gösterildiğinden emin olunmalıdır. Bkz, <xref linkend="glibc-Byte-Order"/>
  </para>
  <sect1 xml:id="glibc-Internet-Address-Formats">
   <title>İnternet Soket Adreslerinin Biçimleri</title>
   <titleabbrev>İnternet isim alanında soket adresleri nasıl belirtilir.</titleabbrev>
   <para>
    İnternet isim alanında, hem IPv4 (<varname>AF_INET</varname>) hem de IPv6 (<varname>AF_INET6</varname>) protokolleri için soket adresi, konak adresiyle konağın bir portunun adresinden oluşur. Ek olarak, seçilen protokol de adresin bir parçası haline gelir, çünkü yerel port numaraları sadece belli bir protokolün içinde anlam kazanır.
   </para>
   <para>
    İnternet isim alanında soket adreslerinin gösteriminde kullanılan veri türleri &netinet-in.h; başlık dosyasında tanımlıdır.
    <indexterm linkend="glibc-pg"><primary>netinet/in.h</primary></indexterm>
   </para>
   <csynopsis>
    <indexterm linkend="glibc-tp" xml:id="glibc-tp-sockaddr_in"><primary sortas="sockaddr_in">struct&#160;sockaddr_in</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-sockaddr_in"><primary>soketler</primary><secondary>IPv4 isim alanı adresleri</secondary></indexterm>
    <csproto type="veri türü">
     <csname><type>struct</type><function>sockaddr_in</function></csname>
    </csproto>
    <header>&netinet-in.h;</header>
    <para>
     IPv4 isim alanındaki soket adreslerinin gösteriminde kullanılan veri türüdür. Aşağıdaki üyeleri içerir:
    </para>
    <glosslist>
     <glossentry>
      <glossterm>
       <type>sa_family_t&nbsp;</type><structfield>sin_family</structfield>
      </glossterm>
      <glossdef>
       <para>
        Soket adresinin adres ailesini veya biçimini tanımlar. Bu üye içinde <varname>AF_INET</varname> değeri saklanmalıdır. Adres ailesi konak bayt sıralamasıyla saklanır. Bkz. <xref linkend="glibc-Socket-Addresses"/>.
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm>
       <type>struct&nbsp;in_addr&nbsp;</type><structfield>sin_addr</structfield>
      </glossterm>
      <glossdef>
       <para>
        Konak IPv4 adresidir. Değerin nasıl alınıp buraya kaydedileceği <xref linkend="glibc-Host-Addresses"/> ve <xref linkend="glibc-Host-Names"/> bölümlerinde anlatılmıştır. IPv4 adresi ağ bayt sıralamasıyla saklanır.
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm>
       <type>unsigned&nbsp;short&nbsp;int&nbsp;</type><structfield>sin_port</structfield>
      </glossterm>
      <glossdef>
       <para>
        Port numarasıdır.  Bkz. <xref linkend="glibc-Ports"/>. Port numarası ağ bayt sıralamasıyla saklanır.
       </para>
      </glossdef>
     </glossentry>
    </glosslist>
   </csynopsis>
   <para>
    <function>bind</function> veya <function>getsockname </function> işlevleri çağrıldığında, IPv4 İnternet isim alanı soket adresleri kullanılıyorsa <parameter>length</parameter> bağımsız değişkeninde <code>sizeof (struct sockaddr_in)</code> değeri belirtilmelidir.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-tp" xml:id="glibc-tp-sockaddr_in6"><primary sortas="sockaddr_in6">struct&#160;sockaddr_in6</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-sockaddr_in6"><primary>soketler</primary><secondary>IPv6 isim alanı adresleri</secondary></indexterm>
    <csproto type="veri türü">
     <csname><type>struct</type><function>sockaddr_in6</function></csname>
    </csproto>
    <header>&netinet-in.h;</header>
    <para>
     IPv6 isim alanındaki soket adreslerinin gösteriminde kullanılan veri türüdür. Aşağıdaki üyeleri içerir:
    </para>
    <glosslist>
     <glossentry>
      <glossterm>
       <type>sa_family_t&nbsp;</type><structfield>sin6_family</structfield>
      </glossterm>
      <glossdef>
       <para>
        Soket adresinin adres ailesini veya biçimini tanımlar. Bu üye içinde <varname>AF_INET6</varname> değeri saklanmalıdır. Adres ailesi konak bayt sıralamasıyla saklanır. Bkz. <xref linkend="glibc-Socket-Addresses"/>.
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm>
       <type>struct&nbsp;in6_addr&nbsp;</type><structfield>sin6_addr</structfield>
      </glossterm>
      <glossdef>
       <para>
        Konak IPv6 adresidir. Değerin nasıl alınıp buraya kaydedileceği <xref linkend="glibc-Host-Addresses"/> ve <xref linkend="glibc-Host-Names"/> bölümlerinde anlatılmıştır. IPv6 adresi ağ bayt sıralamasıyla saklanır.
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm>
       <type>uint32_t&nbsp;</type><structfield>sin6_flowinfo</structfield>
       <indexterm linkend="glibc-cp" xml:id="glibc-cp-sin6_flowinfo"><primary>IPv6</primary><secondary>akış etiketi</secondary></indexterm>
       <indexterm linkend="glibc-cp" xml:id="glibc-cp-sin6_flowinfo1"><primary>trafik sınıfı</primary></indexterm>
        <indexterm linkend="glibc-cp" xml:id="glibc-cp-sin6_flowinfo2"><primary>IPv6</primary><secondary>trafik sınıfı</secondary></indexterm>
      </glossterm>
      <glossdef>
       <para>
        Bu, IPv6 başlığında bulunan IPv6 trafik sınıfı ve akış etiketi değerlerini birleştirir. Bu alan ağ bayt sıralamasıyla saklanır. Ağ bayt sırasındaki sayının yalnızca 28 alt biti kullanılır; kalan bitler sıfır olmalıdır. Alttaki 20 bit akış etiketidir ve 20 ile 27 arasındaki bitler trafik sınıfıdır. Genelde, bu alan sıfırdır.
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm>
       <type>uint32_t&nbsp;</type><structfield>sin6_scope_id</structfield>
      </glossterm>
      <glossdef>
       <para>
        Yerel bağlantı adresleri için, bu adresin geçerli olduğu arabirimi tanımlar. Kapsam kimliği, konak bayt sıralamasıyla saklanır. Genelde, bu alan sıfırdır.
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm>
       <type>uint16_t&nbsp;</type><structfield>sin6_port</structfield>
      </glossterm>
      <glossdef>
       <para>
        Port numarasıdır.  Bkz. <xref linkend="glibc-Ports"/>. Port numarası ağ bayt sıralamasıyla saklanır.
       </para>
      </glossdef>
     </glossentry>
    </glosslist>
   </csynopsis>
  </sect1>
  <sect1 xml:id="glibc-Host-Addresses">
   <title>Konak Adresleri</title>
   <titleabbrev>İnternet konaklarının konak adresleriyle ile ilgili herşey.</titleabbrev>
   <preliminary>
    <para>
     İnternetteki her bilgisayarın, o bilgisayarı internetteki diğer bilgisayarlardan ayıran ve tanımlayan numaralardan oluşan bir veya daha fazla <wordasword>internet adresi</wordasword> vardır. Kullanıcılar genellikle IPv4 numaralı konak adreslerini, <command>127.0.0.1</command> gibi noktalarla ayrılmış dört numaralı bir dizi olarak yazar. IPv6 numaralı konak adreslerini ise <command>5f03:1200:836f:c100::1</command> gibi iki nokta üst üste ile ayrılmış en fazla sekiz bölümden oluşan onaltılık numaralarla yazar.
    </para>
    <para>
     Her bilgisayarın ayrıca, noktalarla ayrılmış kelimelerden oluşan <command>www.example.org</command> gibi bir veya birden fazla <wordasword>konak ismi</wordasword> vardır.
    </para>
    <para>
     Kullanıcıların konak adreslerini belirtmelerine olanak sağlayan yazılımlar genellikle hem numaralı adresi hem de konak ismini kabul eder. Yazılım, bir bağlantı açmak için numaralı bir adrese ihtiyaç duyar ve bu nedenle konak ismini karşılık gelen numaralı adrese çevirmek zorundadır.
    </para>
   </preliminary>
   <sect2 xml:id="glibc-Abstract-Host-Addresses">
    <title>Kısaca Konak Adresleri</title>
    <titleabbrev>Konak numarası nelerden oluşur.</titleabbrev>
    <para>
     <indexterm linkend="glibc-cp"><primary>konak adresleri</primary><secondary>internet</secondary></indexterm>
     <indexterm linkend="glibc-cp"><primary>İnternet</primary><secondary>konak adresleri</secondary></indexterm>
     <indexterm linkend="glibc-cp"><primary>ağ numarası</primary></indexterm>
     <indexterm linkend="glibc-cp"><primary>yerel ağ adresi</primary></indexterm>
     IPv4 İnternet konak adresi dört baytlık veri tutan bir numaradır. Tarihsel olarak bakıldığında bunlar iki kısma ayrılır, <wordasword>ağ numarası</wordasword> ve ağ içerisindeki <wordasword>yerel ağ adresi</wordasword>. 1990'ların ortasında ortaya çıkan sınıfsız adresler bu yaklaşımı değiştirdi. Bazı işlevler içlerinde eski tanımları aradıkları için, öncelikle sınıf tabanlı ağlar, sonra da sınıfsız adresler anlatılacaktır. IPv6 sadece sınıfsız adresleri kullanır, bu nedenle aşağıdaki anlatım IPv6 adreslerine uygulanmaz.
    </para>
    <para>
     Sınıf tabanlı IPv4 ağ numaraları ilk bir, iki veya üç bayttan oluşur; geriye kalan baytlar yerel adreslerdir.
    </para>
    <para>
     IPv4 ağ numaraları Ağ Bilgi Merkezi (NIC - Network Information Center) denilen merkeze kayıtlıdır ve A, B, C adında üç sınıfa bölünmüştür. Yerel ağdaki makinelerin yerel ağ adres numaraları bu merkezce değil, ağın yöneticisi tarafından kaydedilir.
    </para>
    <para>
     A sınıfı ağların 0 ile 127 arasında değişen tek baytlık ağ numarası vardır. Az sayıda A sınıfı ağ vardır, fakat her biri devasa boyutlarda konak sayısına sahiptir. Orta ölçekli B sınıfı ağların ilk baytı 128'den 191'e kadar olan iki baytlık ağ numaraları vardır. C sınıfı ağlar en küçükleridir; ilk baytı 192 ile 255 arasında olan üç baytlık ağ numaraları vardır. Bu nedenle İnternet adresinin ilk bir, iki veya üç baytı ağı belirtir. İnternet adresinin kalan baytları da o ağ içerisindeki adresini belirtir.
    </para>
    <para>
     A sınıfı ağdaki 0 bütün ağlara yayın için ayrılmıştır. Ek olarak, her ağdaki 0 numaralı konak adresi ağ içerisindeki bütün konaklara yayın için ayrılmıştır. Bu kullanımlar günümüzde atıldır fakat uyumluluk nedeniyle 0 numaralı ağ ve 0 numaralı konak numarası kullanılmamalıdır.
     </para>
     <para>
      A sınıfı ağdaki 127 geri dönüş (loopback) arabirimi için ayrılmıştır; 127.0.0.1 adresi konak makine için kullanılabilir.
     </para>
     <para>
      Bir makine birden fazla ağın üyesi olabileceği için birden fazla ağ konak adresine de sahip olabilir. Fakat, bir adres hiç bir zaman birden fazla makineyi belirtemez.
     </para>
     <para>
      <indexterm linkend="glibc-cp"><primary>standart noktalı gösterim</primary><secondary>internet adresleri için</secondary></indexterm>
      <indexterm linkend="glibc-cp"><primary>İnternet adresleri</primary><secondary>standart noktalı gösterim</secondary></indexterm>
      İnternet adresleri için standart noktalı gösterimde dört numaralama biçimi vardır:
     </para>
     <variablelist>
      <varlistentry>
       <term><replaceable>a.b.c.d</replaceable></term>
       <listitem>
        <para>
         Bu adresin dört baytlık kısmının tamamını tanımlar ve genelde kullanılan gösterim şeklidir.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><replaceable>a.b.c</replaceable></term>
       <listitem>
        <para>
         Adresin son kısmı, <replaceable>c</replaceable>, 2 baytlık bir büyüklük olarak yorumlanır. Bu <replaceable>a.b</replaceable> ağ adresi numaralı B sınıfı bir ağdaki konak adreslerinin belirtilmesi için kullanışlıdır.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><replaceable>a.b</replaceable></term>
       <listitem>
        <para>
         Adresin son kısmı, <replaceable>b</replaceable>, 3 baytlık bir büyüklük olarak yorumlanır. Bu <replaceable>a</replaceable> ağ adres numaralı A sınıfı bir ağdaki konak adreslerinin belirtilmesi için kullanışlıdır.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><replaceable>a</replaceable></term>
       <listitem>
        <para>
         Eğer sadece tek parça verilirse, bu doğrudan konak adres numarasına karşılıktır.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
     <para>
      Adresin her kısmında, tabanı tanımlamak için olağan C uzlaşımları uygulanır. Diğer bir deyişle, sayının, başında <code>0x</code> veya <code>0X</code> varsa onaltılık tabanda, <code>0</code> varsa sekizlik tabanda; diğer durumlarda onluk tabanda olduğu kabul edilir.
     </para>
     <simplesect><title>Sınıfsız Adresler</title>
      <para>
       IPv4 adresleri (ve IPv6 adresleri) şimdilik sınıfsız olarak düşünülürse; A, B ve C sınıfları arasındaki farklar görmezden gelinebilir. Bir IPv4 konak adresi 32 bitlik adres ve 32 bitlik maskeden oluşmaktadır. Maske ağ kısmı için birler ve konak kısmı için sıfırlar içerir. Ağ kısmı soldan itibaren birlerle, kalanı da konağı gösteren sıfırlardan oluşur. Sonuç olarak, ağ maskesi sadece bir bitleriyle belirtilebilir. A, B ve C sınıfları bu kuralın sadece özel durumlarıdır. Örneğin, A sınıfı adreslerinin ağ maskesi <code>255.0.0.0</code>'dır veya önek uzunluğu 8'dir.
      </para>
      <para>
       Sınıfsız IPv4 ağ adresleri, noktalı gösterimin sonuna bir bölü ayracıyla eklenmiş önek uzunluğuyla yazılır. Örneğin 10 numaralı A sınıfı ağı <code>10.0.0.0/8</code> olarak yazılır.
     </para>
    </simplesect>
    <simplesect><title>IPv6 Adresleri</title>
     <para>
      IPv6 adresleri 128 bitlik veri içerir (IPv4 32 bit içerir). Bir konak adresi genelde iki nokta üst üste (:) ile ayrılmış sekiz adet 16 bitlik onaltılık sayı olarak yazılır. Ardarda gelen sıfırları kısaltmak için iki adet iki nokta üst üste (:) yan yana konulur. Örneğin, IPv6 geri dönüş adresi <code>0:0:0:0:0:0:0:1</code>, sadece <code>::1</code> şeklinde yazılabilir.
     </para>
    </simplesect>
   </sect2>
   <sect2 xml:id="glibc-Host-Address-Data-Type">
    <title>Konak Adresinin Veri Türü</title>
    <titleabbrev>Konak numarasının veri türü.</titleabbrev>
    <para>
     IPv4 İnternet konak adresleri bazı yaklaşımlarda (<type>uint32_t</type> türünde) tamsayı değerler olarak gösterilir. Diğer yaklaşımlarda tamsayı <type>struct&nbsp;in_addr</type> türünde bir yapı içerisine paketlenir. Kullanımın tutarlı olması daha iyi olurdu ancak tamsayı değerini yapıdan çıkarmak veya yapı içerisine sokmak zordur.
    </para>
    <para>
     IPv4 İnternet konak adresleri için <type>uint32_t</type> veya <type>struct&nbsp;in_addr</type> kullanmak yerine <type>unsigned&nbsp;long&nbsp;int</type> kullanan eski kodlar olabilir. Eskiden <type>unsigned&nbsp;long&nbsp;int</type> 32 bitlik numaraydı fakat 64 bitlik bilgisayarlarla birlikte bu değişti. <type>unsigned&nbsp;long&nbsp;int</type> türünün 32 bit olmadığı bilgisayarlarda bu veri türü kodun çalışmamasına sebep olabilir. <type>uint32_t</type> türü Unix98 tarafından tanımlanmış ve 32 bit olması garanti edilmiştir.
    </para>
    <para>
     IPv6 İnternet konak adresleri 128 bittir ve <type>struct in6_addr</type> yapısı içerisinde paketlenmiştir.
    </para>
    <para>
     Aşağıdaki İnternet adreslerinin temel tanımları &netinet-in.h; başlık dosyasında tanımlanmıştır:
    </para>
    <csynopsis>
     <indexterm linkend="glibc-tp" xml:id="glibc-tp-in_addr"><primary sortas="in_addr">struct&nbsp;in_addr</primary></indexterm>
     <csproto type="veri türü">
      <csname><type>struct</type><function>in_addr</function></csname>
     </csproto>
     <header>&netinet-in.h;</header>
     <para>
      Bu veri türü, IPv4 İnternet konak adresini tutmak için kullanılmaktadır. Konak adres numarasını <type>uint32_t</type> olarak kaydeden <code>s_addr</code> adında sadece bir alanı vardır.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-INADDR_LOOPBACK"><primary>INADDR_LOOPBACK</primary></indexterm>
     <csproto type="makro">
      <csname><type>uint32_t</type><function>INADDR_LOOPBACK</function></csname>
     </csproto>
     <header>&netinet-in.h;</header>
     <para>
      Bu sabit makinenin gerçek adresini bulmak yerine "makinenin adresi" olarak kullanılabilir. Buna genellikle <code>localhost</code> adı verilir ve IPv4 İnternet adresi <code>127.0.0.1</code>'dir. Bu özel sabit makine adresini bulma çilesinden kurtarır. Ayrıca, özellikle, makinenin kendisiyle iletişiminde herhangi bir ağ trafiğinden kaçınmak için sistem <code>INADDR_LOOPBACK</code> sabitini kullanır.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-INADDR_ANY"><primary>INADDR_ANY</primary></indexterm>
     <csproto type="makro">
      <csname><type>uint32_t</type><function>INADDR_ANY</function></csname>
     </csproto>
     <header>&netinet-in.h;</header>
     <para>
      Bu sabit, bir sokete adres verilmesi sırasında "gelen herhangi bir adres" yerine kullanılabilir. Bkz. <xref linkend="glibc-Setting-Address"/>. İnternet bağlantıları kabul edilirken <type>struct&nbsp;sockaddr_in</type> yapısının  <code>sin_addr</code> üyesinde belirtmek için kullanışlıdır.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-INADDR_BROADCAST"><primary>INADDR_BROADCAST</primary></indexterm>
     <csproto type="makro">
      <csname><type>uint32_t</type><function>INADDR_BROADCAST</function></csname>
     </csproto>
     <header>&netinet-in.h;</header>
     <para>
      Bu sabit bir yayın iletisi göndermek için kullanılan adrestir.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-INADDR_NONE"><primary>INADDR_NONE</primary></indexterm>
     <csproto type="makro">
      <csname><type>uint32_t</type><function>INADDR_NONE</function></csname>
     </csproto>
     <header>&netinet-in.h;</header>
     <para>
      Bu sabit bazı işlevler tarafından hata oluştuğunu belirtmek için döndürülür.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-tp" xml:id="glibc-tp-in6_addr"><primary sortas="in6_addr">struct&nbsp;in6_addr</primary></indexterm>
     <csproto type="veri türü">
      <csname><type>struct</type><function>in6_addr</function></csname>
     </csproto>
     <header>&netinet-in.h;</header>
     <para>
      Bu veri türü bir IPv6 adresi tutmak için kullanılır. Çeşitli yollarla (örn, birleşik yapı üzerinden) erişilebilir 128 bitlik veri tutar.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-in6addr_loopback"><primary>in6addr_loopback</primary></indexterm>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-IN6ADDR_LOOPBACK_INIT"><primary>IN6ADDR_LOOPBACK_INIT</primary></indexterm>
     <csproto type="sabit">
      <csname><type>struct&nbsp;in6_addr</type><function>in6addr_loopback</function></csname>
     </csproto>
     <header>&netinet-in.h;</header>
     <para>
      Bu sabit IPv6 <code>::1</code> geridönüş adresidir. <varname>INADDR_LOOPBACK</varname> sabitinin IPv6 karşılığı olarak değişkenleri ilklendirmek için <code>IN6ADDR_LOOPBACK_INIT</code> makrosu sağlanmıştır.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-in6addr_any"><primary>in6addr_any</primary></indexterm>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-IN6ADDR_ANY_INIT"><primary>IN6ADDR_ANY_INIT</primary></indexterm>
     <csproto type="sabit">
      <csname><type>struct&nbsp;in6_addr</type><function>in6addr_any</function></csname>
     </csproto>
     <header>&netinet-in.h;</header>
     <para>
      Bu sabit IPv6 <code>::</code> belirtilmemiş adresidir. <varname>INADDR_ANY</varname> sabitinin IPv6 karşılığı olarak değişkenleri ilklendirmek için <code>IN6ADDR_ANY_INIT</code> makrosu sağlanmıştır.
     </para>
    </csynopsis>
   </sect2>
   <sect2 xml:id="glibc-Host-Address-Functions">
    <title>Konak Adresi İşlevleri</title>
    <titleabbrev>Makinenin konak adresi üzerinde çalışan işlevler.</titleabbrev>
    <para>
     <indexterm linkend="glibc-pg"><primary>arpa/inet.h</primary></indexterm>
     İnternet adreslerini işlemek için kullanılan bu ek işlevler &arpa-inet.h; başlık dosyasında tanımlıdır. Bunlar İnternet adreslerini ağ bayt sırasında; ağ numaraları ve ağ içi yerel adres numaralarını da konak bayt sırasında göstermektedir. Ağ ve konak bayt sırası ile ilgili açıklama <xref linkend="glibc-Byte-Order"/> bölümünde bulunabilir.
    </para>
    <csynopsis>
     <indexterm linkend="glibc-fn" xml:id="glibc-fn-inet_aton"><primary>inet_aton</primary></indexterm>
     <csproto type="işlev">
      <csname><type>int</type><function>inet_aton</function></csname>
      <csparam><ptr>const&#160;char</ptr><parameter>name</parameter></csparam>
      <csparam><ptr>struct&#160;in_addr</ptr><parameter>addr</parameter></csparam>
     </csproto>
     <header>&arpa-inet.h;</header>
     <conceptlist>
      <concept>&mtsafe; &locale;</concept>
      <concept>&assafe;</concept>
      <concept>&acsafe;</concept>
     </conceptlist>
     <para>
      Bu işlev <parameter>name</parameter> IPv4 İnternet konak adresini standart noktalı gösterimden ikil veriye dönüştürür ve <parameter>addr</parameter> ile gösterilen <type>struct&#160;in_addr</type> yapısında saklar. Eğer adres geçerli ise işlev sıfırdan farklı bir değer, aksi takdirde sıfır döndürür.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-fn" xml:id="glibc-fn-inet_addr"><primary>inet_addr</primary></indexterm>
     <csproto type="işlev">
      <csname><type>uint32_t</type><function>inet_addr</function></csname>
      <csparam><ptr>const&#160;char</ptr><parameter>name</parameter></csparam>
     </csproto>
     <header>&arpa-inet.h;</header>
     <conceptlist>
      <concept>&mtsafe; &locale;</concept>
      <concept>&assafe;</concept>
      <concept>&acsafe;</concept>
     </conceptlist>
     <para>
      Bu işlev <parameter>name</parameter> IPv4 İnternet konak adresini standart noktalı gösterimden ikil veriye dönüştürür. Eğer girdi geçerli değilse, işlev <varname>INADDR_NONE</varname> döndürür. Yukarıdaki <function>inet_aton</function> işlevi için atıl arayüzdür. Atıl olmasının sebebi <varname>INADDR_NONE</varname> adresinin (255.255.255.255) geçerli bir adres olması ve <function>inet_aton</function> işlevinin hata döndürmek için daha temiz bir yol sunmasıdır.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-fn" xml:id="glibc-fn-inet_network"><primary>inet_network</primary></indexterm>
     <csproto type="işlev">
      <csname><type>uint32_t</type><function>inet_network</function></csname>
      <csparam><ptr>const&#160;char</ptr><parameter>name</parameter></csparam>
     </csproto>
     <header>&arpa-inet.h;</header>
     <conceptlist>
      <concept>&mtsafe; &locale;</concept>
      <concept>&assafe;</concept>
      <concept>&acsafe;</concept>
     </conceptlist>
     <para>
      Bu işlev, standart noktalı gösterim ile verilen <parameter>name</parameter> adresinden ağ numarasını elde eder. Döndürülen adres konak bayt sırasındadır. Girdi geçerli değilse, <code>-1</code> döner.
     </para>
     <para>
      İşlev yalnızca geleneksel IPv4 A, B ve C sınıfı ağ türleri ile çalışır. Sınıfsız adreslerle çalışmaz ve artık kullanılmamalıdır.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-fn" xml:id="glibc-fn-inet_ntoa"><primary>inet_ntoa</primary></indexterm>
     <csproto type="işlev">
      <csname><ptr>char</ptr><function>inet_ntoa</function></csname>
      <csparam><type>struct&#160;in_addr</type><parameter>addr</parameter></csparam>
     </csproto>
     <header>&arpa-inet.h;</header>
     <conceptlist>
      <concept>&mtsafe; &locale;</concept>
      <concept>&asunsafe; &race;</concept>
      <concept>&acsafe;</concept>
     </conceptlist>
     <para>
      Bu işlev <parameter>addr</parameter> IPv4 İnternet konak adresini standart noktalı gösterimli dizgeye dönüştürür. Dönüş değeri duruk olarak tahsis edilmiş tampona göstericidir. İşlevin sonraki çağrıları aynı tamponun üzerine yazacağından, dönen değerin kaybolmaması isteniyorsa kopyalanması gerekir.
     </para>
     <para>
      Çok evreli yazılımlarda her evrenin duruk olarak tahsis edilmiş kendi tamponu vardır. Fakat işlevin aynı evredeki sonraki çağrıları da önceki sonucun üzerine yazar.
     </para>
     <para>
      <code>inet_ntoa</code> yerine, hem IPv4 hem de IPv6 adreslerini destekleyen yeni bir işlev olan <function>inet_ntop</function> kullanılmalıdır.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-fn" xml:id="glibc-fn-inet_makeaddr"><primary>inet_makeaddr</primary></indexterm>
     <csproto type="işlev">
      <csname><type>struct&#160;in_addr</type><function>inet_makeaddr</function></csname>
      <csparam><type>uint32_t</type><parameter>net</parameter></csparam>
      <csparam><type>uint32_t</type><parameter>local</parameter></csparam>
     </csproto>
     <header>&arpa-inet.h;</header>
     <conceptlist>
      <concept>&mtsafe;</concept>
      <concept>&assafe;</concept>
      <concept>&acsafe;</concept>
     </conceptlist>
     <para>
      Bu işlev <parameter>net</parameter> ağ numarası ile <parameter>local</parameter> ağ-numarası-içindeki-yerel-adres değerlerini birleştirerek bir IPv4 İnternet konak adresi yapar.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-fn" xml:id="glibc-fn-inet_lnaof"><primary>inet_lnaof</primary></indexterm>
     <csproto type="işlev">
      <csname><type>uint32_t</type><function>inet_lnaof</function></csname>
      <csparam><type>struct&#160;in_addr</type><parameter>addr</parameter></csparam>
     </csproto>
     <header>&arpa-inet.h;</header>
     <conceptlist>
      <concept>&mtsafe;</concept>
      <concept>&assafe;</concept>
      <concept>&acsafe;</concept>
     </conceptlist>
     <para>
      Bu işlev <varname>adres</varname> İnternet konak adresinin ağ içindeki yerel adres kısmını döndür.
     </para>
     <para>
      İşlev yalnızca geleneksel IPv4 A, B ve C sınıfı ağ türleri ile çalışır. Sınıfsız adreslerle çalışmaz ve artık kullanılmamalıdır.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-fn" xml:id="glibc-fn-inet_netof"><primary>inet_netof</primary></indexterm>
     <csproto type="işlev">
      <csname><type>uint32_t</type><function>inet_netof</function></csname>
      <csparam><type>struct&#160;in_addr</type><parameter>addr</parameter></csparam>
     </csproto>
     <header>&arpa-inet.h;</header>
     <conceptlist>
      <concept>&mtsafe;</concept>
      <concept>&assafe;</concept>
      <concept>&acsafe;</concept>
     </conceptlist>
     <para>
      Bu işlev <parameter>addr</parameter> İnternet konak adresinin ağ numarası kısmını döndürür.
     </para>
     <para>
      İşlev yalnızca geleneksel IPv4 A, B ve C sınıfı ağ türleri ile çalışır. Sınıfsız adreslerle çalışmaz ve artık kullanılmamalıdır.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-fn" xml:id="glibc-fn-inet_pton"><primary>inet_pton</primary></indexterm>
     <csproto type="işlev">
      <csname><type>int</type><function>inet_pton</function></csname>
      <csparam><type>int</type><parameter>af</parameter></csparam>
      <csparam><ptr>const&#160;char</ptr><parameter>cp</parameter></csparam>
      <csparam><ptr>void</ptr><parameter>buf</parameter></csparam>
     </csproto>
     <header>&arpa-inet.h;</header>
     <conceptlist>
      <concept>&mtsafe; &locale;</concept>
      <concept>&assafe;</concept>
      <concept>&acsafe;</concept>
     </conceptlist>
     <para>
      Bu işlev bir (IPv4 veya IPv6) İnternet adresini metin gösteriminden ağ biçimine (ikil) dönüştürür. <parameter>af</parameter> dönüştürüleceği adres türünü belirtmek üzere <varname>AF_INET</varname> veya <varname>AF_INET6</varname> olmalıdır. <parameter>cp</parameter> girilen dizgeye gösterici, <parameter>buf</parameter> ise sonucu saklamak için kullanılan tampona göstericidir. Tamponun yeterli büyüklükte olmasını sağlamak işlevi çağıranın sorumluluğudur.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-fn" xml:id="glibc-fn-inet_ntop"><primary>inet_ntop</primary></indexterm>
     <csproto type="işlev">
      <csname><ptr>const&#160;char</ptr><function>inet_ntop</function></csname>
      <csparam><type>int</type><parameter>af</parameter></csparam>
      <csparam><ptr>const&#160;void</ptr><parameter>cp</parameter></csparam>
      <csparam><ptr>char</ptr><parameter>buf</parameter></csparam>
      <csparam><type>socklen_t</type><parameter>len</parameter></csparam>
     </csproto>
     <header>&arpa-inet.h;</header>
     <conceptlist>
      <concept>&mtsafe; &locale;</concept>
      <concept>&assafe;</concept>
      <concept>&acsafe;</concept>
     </conceptlist>
     <para>
      Bu işlev bir (IPv4 veya IPv6) İnternet adresini ağ biçiminden (ikil), metin gösterimine dönüştürür. <parameter>af</parameter> dönüştürülecek adres türünü belirtmek üzere <varname>AF_INET</varname> veya <varname>AF_INET6</varname> olmalıdır. <parameter>cp</parameter> girilen dizgeye gösterici, <parameter>buf</parameter> ise sonucu saklamak için kullanılan tampona göstericidir ve <parameter>len</parameter> bu tamponun uzunluğudur. İşlevden dönen değer bu tamponun adresidir.
     </para>
    </csynopsis>
   </sect2>
   <sect2 xml:id="glibc-Host-Names">
    <title>Konak İsimleri</title>
    <titleabbrev>Makine konak isimlerinin konak numaralarına dönüştürülmesi.</titleabbrev>
    <para>
     <indexterm linkend="glibc-cp"><primary>konak veritabanı</primary></indexterm>
     <indexterm linkend="glibc-cp"><primary>konak isimlerini adreslere dönüştürme</primary></indexterm>
     <indexterm linkend="glibc-cp"><primary>konak adreslerini konak isimlerine dönüştürme</primary></indexterm>
     İnternet adresleri için standart noktalı gösterime ek olarak bir konağa ulaşmak için simgesel isim de kullanılabilir. Simgesel ismin yararı akılda kalmasının kolay oluşudur. Örneğin, İnternet adresi <code>158.121.106.19</code> olan bir makine <code>alpha.gnu.org</code> şeklinde de bilinir; ve <code>gnu.org</code> etki alanındaki diğer makineler ona yalnızca <code>alpha</code> ile erişebilir.
    </para>
    <para>
     <indexterm linkend="glibc-pg"><primary sortas="etc/hosts">/etc/hosts</primary></indexterm>
     <indexterm linkend="glibc-pg"><primary>netdb.h</primary></indexterm>
     Arka planda, sistem, konak isimlerini konak numaralarına eşleyerek bunların kayıtlarını tutabileceği bir veritabanı kullanır. Bu veritabanı genellikle <filename>/etc/hosts</filename> dosyası veya bir isim sunucusunun sunduğu eşdeğeridir. Veritabanına erişim için kullanılan işlev ve simge tanımları &netdb.h; başlık dosyasında bulunur. &netdb.h; dosya olarak içerilirse, BSD'nin özellikleri de tümüyle gelir.
    </para>
    <csynopsis>
     <indexterm linkend="glibc-tp" xml:id="glibc-tp-hostent"><primary sortas="hostent">struct&nbsp;hostent</primary></indexterm>
     <csproto type="veri türü">
      <csname><type>struct</type><function>hostent</function></csname>
     </csproto>
     <header>&netdb.h;</header>
     <para>
      Konak veritabanındaki her girdi için kullanılır. Aşağıdaki üyelere sahiptir:
     </para>
     <glosslist>
      <glossentry>
       <glossterm>
        <type>char&nbsp;*</type><structfield>h_name</structfield>
       </glossterm>
       <glossdef>
        <para>
         Konağın "resmi" adıdır.
        </para>
       </glossdef>
      </glossentry>
      <glossentry>
       <glossterm>
        <type>char&nbsp;**</type><structfield>h_aliases</structfield>
       </glossterm>
       <glossdef>
        <para>
         Konağın diğer adlarıdır, boş bayt sonlandırmalı dizgeler dizisi olarak ifade edilir.
        </para>
       </glossdef>
      </glossentry>
      <glossentry>
       <glossterm>
        <type>int&nbsp;</type><structfield>h_addrtype</structfield>
       </glossterm>
       <glossdef>
        <para>
         Bu konak adres türüdür; uygulamada, değeri her zaman IPv4 adresler için <varname>AF_INET</varname>, IPv6 adresler için <varname>AF_INET6</varname>'dır. Kural olarak, her türde adres veritabanında İnternet adresi olarak gösterilebilir; bu yapılırsa, bu alanda <varname>AF_INET</varname> veya <varname>AF_INET6</varname>'dan farklı bir değer görülebilir. Bkz. <xref linkend="glibc-Socket-Addresses"/>.
        </para>
       </glossdef>
      </glossentry>
      <glossentry>
       <glossterm>
        <type>int&nbsp;</type><structfield>h_length</structfield>
       </glossterm>
       <glossdef>
        <para>
         Adresin bayt cinsinden uzunluğudur.
        </para>
       </glossdef>
      </glossentry>
      <glossentry>
       <glossterm>
        <type>char&nbsp;**</type><structfield>h_addr_list</structfield>
       </glossterm>
       <glossdef>
        <para>
         Konak adres dizgeleri dizisidir. (Hatırlatma: bir makine birden fazla ağa bağlı olabilir ve her birinin farklı bir adresi olabilir.) Dizi boş gösterici ile sonlandırılır.
        </para>
       </glossdef>
      </glossentry>
      <glossentry>
       <glossterm>
        <type>char&nbsp;*</type><structfield>h_addr</structfield>
       </glossterm>
       <glossdef>
        <para>
         <command>h_addr_list[0]</command> ile aynıdır; diğer bir deyişle, ilk konak adresidir.
        </para>
       </glossdef>
      </glossentry>
     </glosslist>
    </csynopsis>
    <para>
     Konak veritabanı düşünülüğünde, her adres sadece <code>h_length</code> bayt uzunluğunda bir bellek diliminden ibarettir. Fakat diğer yaklaşımlarda IPv4 adreslerin <type>struct&nbsp;in_addr</type> veya <type>uint32_t</type> türüne dönüştürülebileceği şeklinde bir varsayım da vardır. <type>struct&nbsp;hostent</type> türündeki konak adresleri her zaman ağ bayt sırasında verilmiştir; bkz, <xref linkend="glibc-Byte-Order"/>.
    </para>
    <para>
     Konak veritabanında arama yaparak belirli bir konak hakkında bilgi almak için <function>gethostbyname</function>, <function>gethostbyname2</function> veya <function>gethostbyaddr</function> işlevleri kullanılabilir. Bilgi duruk olarak tahsis edilmiş bir yapı içinde döndürülür; çağrılar arasında kaydetmek için bilgiyi kopyalamak gerekir. Ayrıca, bu bilgiye ulaşmak için <function>getaddrinfo</function> ve <function>getnameinfo</function> işlevleri de kullanılabilir.
    </para>
    <csynopsis>
     <indexterm linkend="glibc-fn" xml:id="glibc-fn-gethostbyname"><primary>gethostbyname</primary></indexterm>
     <csproto type="işlev">
      <csname><ptr>struct&#160;hostent</ptr><function>gethostbyname</function></csname>
      <csparam><ptr>const&#160;char</ptr><parameter>name</parameter></csparam>
     </csproto>
     <header>&netdb.h;</header>
     <conceptlist>
      <concept>&mtunsafe; &race;<code linkend="glibc-safety-identifier">:hostbyname</code> &env; &locale;</concept>
      <concept>&asunsafe; &dlopen; &plugin; &corrupt; &heap; &lock;</concept>
      <concept>&acunsafe; &lock; &corrupt; &mem;  &fd;</concept>
     </conceptlist>
     <para>
      <code>gethostbyname</code> işlevi <parameter>name</parameter> adlı konak hakkında bilgi döndürür. Başarısızlık durumunda, boş gösterici döner.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-fn" xml:id="glibc-fn-gethostbyname2"><primary>gethostbyname2</primary></indexterm>
     <csproto type="işlev">
      <csname><ptr>struct&#160;hostent</ptr><function>gethostbyname2</function></csname>
      <csparam><ptr>const&#160;char</ptr><parameter>name</parameter></csparam>
      <csparam><type>int</type><parameter>af</parameter></csparam>
     </csproto>
     <header>&netdb.h;</header>
     <conceptlist>
      <concept>&mtunsafe; &race;<code linkend="glibc-safety-identifier">:hostbyname2</code> &env; &locale;</concept>
      <concept>&asunsafe; &dlopen; &plugin; &corrupt; &heap; &lock;</concept>
      <concept>&acunsafe; &lock; &corrupt; &mem;  &fd;</concept>
     </conceptlist>
     <para>
      <code>gethostbyname2</code> işlevi <function>gethostbyname</function> gibidir, fakat çağrıcıya sonuç için istediği adres ailesini (örneğin <varname>AF_INET</varname> veya <varname>AF_INET6</varname>) belirtme imkanı sunar.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-fn" xml:id="glibc-fn-gethostbyaddr"><primary>gethostbyaddr</primary></indexterm>
     <csproto type="işlev">
      <csname><ptr>struct&#160;hostent</ptr><function>gethostbyaddr</function></csname>
      <csparam><ptr>const&#160;void</ptr><parameter>addr</parameter></csparam>
      <csparam><type>socklen_t</type><parameter>length</parameter></csparam>
      <csparam><type>int</type><parameter>format</parameter></csparam>
     </csproto>
     <header>&netdb.h;</header>
     <conceptlist>
      <concept>&mtunsafe; &race;<code linkend="glibc-safety-identifier">:hostbyaddr</code> &env; &locale;</concept>
      <concept>&asunsafe; &dlopen; &plugin; &corrupt; &heap; &lock;</concept>
      <concept>&acunsafe; &lock; &corrupt; &mem;  &fd;</concept>
     </conceptlist>
     <para>
      <code>gethostbyaddr</code> işlevi <parameter>addr</parameter> İnternet adresli konak hakkında bilgi döndürür. <parameter>addr</parameter> bağımsız değişkeni aslında <type>char</type> göstericisi değildir - IPv4 veya IPv6 adresine gösterici olabilir. <parameter>length</parameter> bağımsız değişkeni <parameter>addr</parameter> adresinin bayt cinsinden boyutudur. <parameter>format</parameter> adres türünü belirtir; IPv4 İnternet adresi için, <varname>AF_INET</varname>, IPv6 İnternet adresi için <varname>AF_INET6</varname> kullanılır.
     </para>
     <para>
      Başarısızlık durumunda, boş gösterici döner.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm xml:id="glibc-vr-h_errno" linkend="glibc-vr"><primary>h_errno</primary></indexterm>
     <csproto type="değişken">
      <csname><type>volatile&#160;int</type><varname>h_errno</varname></csname>
     </csproto>
     <header>&netdb.h;</header>
     <para>
      <function>gethostbyname</function> veya <function>gethostbyaddr</function> ile isim sorgulaması yapılamazsa, sebebi <code>h_errno</code> değişkeninin değerine bakılarak bulunabilir. (Bu işlevler için <varname>errno</varname> değerini değiştirmek daha temiz bir çözüm olurdu, ancak <code>h_errno</code> diğer sistemlerle de uyumludur.)
     </para>
    </csynopsis>
    <para>
     <varname>h_errno</varname> hata kodları:
    </para>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-HOST_NOT_FOUND"><primary>HOST_NOT_FOUND</primary></indexterm>
     <csproto type="makro">
      <csname><function>HOST_NOT_FOUND</function></csname>
     </csproto>
     <header>&netdb.h;</header>
     <para>
      Veritabanında böyle bir konak yok.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-TRY_AGAIN"><primary>TRY_AGAIN</primary></indexterm>
     <csproto type="makro">
      <csname><function>TRY_AGAIN</function></csname>
     </csproto>
     <header>&netdb.h;</header>
     <para>
      Bu durum isim sunucusu ile bağlantı kurulamadığında gerçekleşir. Eğer tekrar denenirse, başarılı olabilir.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-NO_RECOVERY"><primary>NO_RECOVERY</primary></indexterm>
     <csproto type="makro">
      <csname><function>NO_RECOVERY</function></csname>
     </csproto>
     <header>&netdb.h;</header>
     <para>
      Kurtarılamaz bir hata oluştu.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-NO_ADDRESS"><primary>NO_ADDRESS</primary></indexterm>
     <csproto type="makro">
      <csname><function>NO_ADDRESS</function></csname>
     </csproto>
     <header>&netdb.h;</header>
     <para>
      Konak veritabanı isim için bir girdi içeriyor, fakat buna ilişkin bir İnternet adresi yok.
     </para>
    </csynopsis>
    <para>
     Yukarıdaki arama işlevlerinin ortak özellikleri: hiçbiri evresel değildir ve çok evreli uygulamalarda kullanılamaz. Bu nedenle &glibc; bu bağlamda kullanılabilen bir grup yeni işlev sağlar.
    </para>
    <csynopsis>
     <indexterm linkend="glibc-fn" xml:id="glibc-fn-gethostbyname_r"><primary>gethostbyname_r</primary></indexterm>
     <csproto type="işlev">
      <csname><type>int</type><function>gethostbyname_r</function></csname>
      <csparam><type>const&#160;char&#160;*restrict</type><parameter>name</parameter></csparam>
      <csparam><type>struct&#160;hostent&#160;*restrict</type><parameter>result_buf</parameter></csparam>
      <csparam><type>char&#160;*restrict</type><parameter>buf</parameter></csparam>
      <csparam><type>size_t</type><parameter>buflen</parameter></csparam>
      <csparam><type>struct&#160;hostent&#160;**restrict</type><parameter>result</parameter></csparam>
      <csparam><type>int&#160;*restrict</type><parameter>h_errnop</parameter></csparam>
     </csproto>
     <header>&netdb.h;</header>
     <conceptlist>
      <concept>&mtsafe; &env; &locale;</concept>
      <concept>&asunsafe; &dlopen; &plugin; &corrupt; &heap; &lock;</concept>
      <concept>&acunsafe; &lock; &corrupt; &mem;  &fd;</concept>
     </conceptlist>
     <para>
      <code>gethostbyname_r</code> işlevi <parameter>name</parameter> adındaki konak hakında bilgi döndürür. Çağrı sırasında işleve <parameter>result_buf</parameter> bağımsız değişkeni ile <type>struct&#160;hostent</type> türündeki nesneye gösterici aktarılmalıdır. Ek olarak işlev fazladan bir tampon alanına ihtiyaç duyabildiğinden çağrı sırasında işleve bu tampona gösterici <parameter>buf</parameter> ile ve tamponun uzunluğu da <parameter>buflen</parameter> ile aktarılmalıdır.
     </para>
     <para>
      Sonucun tutulduğu tampona gösterici, başarılı bir işlev çağrısından sonra döndürülen *<parameter>result</parameter> içinde bulunur. Eğer bir hata oluşur veya girdi bulunamazsa *<parameter>result</parameter> göstericisi boş göstericidir. Başarı sıfır dönüş değeri ile belirtilir. Eğer işlev çalışmazsa dönüş değeri hatanın numarasıdır. <function>gethostbyname</function> için tanımlanan hatalara ek olarak <varname>ERANGE</varname> hatası da oluşabilir. Bu durumda çağrı daha büyük bir tampon ile tekrarlanmalıdır. İlave hata bilgisi küresel değişken <varname>h_errno</varname>'da değil <parameter>h_errnop</parameter> ile gösterilen nesnede saklanır.
     </para>
     <example>
      <screen>struct hostent *
gethostname (char *host)
{
  struct hostent *hostbuf, *hp;
  size_t hstbuflen;
  char *tmphstbuf;
  int res;
  int herr;

  /* <replaceable>Tamponu ayır.</replaceable>  */
  hostbuf = malloc (sizeof (struct hostent));
  hstbuflen = 1024;
  tmphstbuf = malloc (hstbuflen);

  while ((res = gethostbyname_r (host, hostbuf, tmphstbuf, hstbuflen,
                                 &amp;hp, &amp;herr)) == ERANGE)
    {
      /* <replaceable>Tamponu genişlet.</replaceable>  */
      tmphstbuf = reallocarray (tmphstbuf, hstbuflen, 2);
      hstbuflen *= 2;
    }

  free (tmphstbuf);
  /*  <replaceable>Hata var mı, bak.</replaceable>  */
  if (res || hp == NULL)
    return NULL;
  return hp;
}
</screen>
     </example>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-fn" xml:id="glibc-fn-gethostbyname2_r"><primary>gethostbyname2_r</primary></indexterm>
     <csproto type="işlev">
      <csname><type>int</type><function>gethostbyname2_r</function></csname>
      <csparam><ptr>const&#160;char</ptr><parameter>name</parameter></csparam>
      <csparam><type>int</type><parameter>af</parameter></csparam>
      <csparam><type>struct&#160;hostent&#160;*restrict</type><parameter>result_buf</parameter></csparam>
      <csparam><type>char&#160;*restrict</type><parameter>buf</parameter></csparam>
      <csparam><type>size_t</type><parameter>buflen</parameter></csparam>
      <csparam><type>struct&#160;hostent&#160;**restrict</type><parameter>result</parameter></csparam>
      <csparam><type>int&#160;*restrict</type><parameter>h_errnop</parameter></csparam>
     </csproto>
     <header>&netdb.h;</header>
     <conceptlist>
      <concept>&mtsafe; &env; &locale;</concept>
      <concept>&asunsafe; &dlopen; &plugin; &corrupt; &heap; &lock;</concept>
      <concept>&acunsafe; &lock; &corrupt; &mem;  &fd;</concept>
     </conceptlist>
     <para>
      <code>gethostbyname2_r</code> işlevi  <function>gethostbyname_r</function> gibidir, fakat çağrı sırasında sonuç için istenen adres türünü <parameter>af</parameter> ile (örn, <varname>AF_INET</varname> veya <varname>AF_INET6</varname>) belirtme imkanı sunar.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-fn" xml:id="glibc-fn-gethostbyaddr_r"><primary>gethostbyaddr_r</primary></indexterm>
     <csproto type="işlev">
      <csname><type>int</type><function>gethostbyaddr_r</function></csname>
      <csparam><ptr>const&#160;void</ptr><parameter>addr</parameter></csparam>
      <csparam><type>socklen_t</type><parameter>length</parameter></csparam>
      <csparam><type>int</type><parameter>format</parameter></csparam>
      <csparam><type>struct&#160;hostent&#160;*restrict</type><parameter>result_buf</parameter></csparam>
      <csparam><type>char&#160;*restrict</type><parameter>buf</parameter></csparam>
      <csparam><type>size_t</type><parameter>buflen</parameter></csparam>
      <csparam><type>struct&#160;hostent&#160;**restrict</type><parameter>result</parameter></csparam>
      <csparam><type>int&#160;*restrict</type><parameter>h_errnop</parameter></csparam>
     </csproto>
     <header>&netdb.h;</header>
     <conceptlist>
      <concept>&mtsafe; &env; &locale;</concept>
      <concept>&asunsafe; &dlopen; &plugin; &corrupt; &heap; &lock;</concept>
      <concept>&acunsafe; &lock; &corrupt; &mem;  &fd;</concept>
     </conceptlist>
     <para>
      <code>gethostbyaddr_r</code> işlevi <parameter>addr</parameter> İnternet adresine sahip konak hakkında bilgi döndürür. <parameter>addr</parameter> bağımsız değişkeni aslında karaktere gösterici değildir - IPv4 veya IPv6 adresine gösterici olabilir. <parameter>length</parameter> bağımsız değişkeni <parameter>addr</parameter> adresinin (bayt cinsinden) boyutudur. <parameter>format</parameter> adres türünü belirtir; IPv4 İnternet adresi için <varname>AF_INET</varname>, IPv6 İnternet adresi için <varname>AF_INET6</varname> kullanılır.
     </para>
     <para>
      <function>gethostbyname_r</function> işlevine benzer olarak, çağrıcı, sonuç için gerekli tampon alanını ve iç kullanım için gerekli belleği sağlamak zorundadır. Başarı halinde işlev sıfır döndürür. Aksi takdirde değer bir hata numarasıdır ve burada <varname>ERANGE</varname> çağırıcının sağladığı tamponun yeterli olmadığını belirten özel bir anlama sahiptir.
     </para>
    </csynopsis>
    <para>
     <function>sethostent</function>, <function>gethostent</function> ve <function>endhostent</function> kullanarak bütün konak veritabanı bir girdi için taranabilir. Bu işlevleri kullanırken dikkatli olunmalıdır, çünkü bunlar evresel işlevler değildir.
    </para>
    <csynopsis>
     <indexterm linkend="glibc-fn" xml:id="glibc-fn-sethostent"><primary>sethostent</primary></indexterm>
     <csproto type="işlev">
      <csname><type>void</type><function>sethostent</function></csname>
      <csparam><type>int</type><parameter>stayopen</parameter></csparam>
     </csproto>
     <header>&netdb.h;</header>
     <conceptlist>
      <concept>&mtunsafe; &race;<code linkend="glibc-safety-identifier">:hostent</code> &env; &locale;</concept>
      <concept>&asunsafe; &dlopen; &plugin; &heap; &lock;</concept>
      <concept>&acunsafe; &corrupt; &lock;  &fd; &mem;</concept>
     </conceptlist>
     <para>
      Bu işlev konak veritabanını taranması için açar. Bu işlev çağrısının ardından girdileri okumak için <function>gethostent</function> çağrılabilir.
     </para>
     <para>
      Eğer <varname>stayopen</varname> bağımsız değişkeni sıfır değilse, bir bayrağı kaldırarak <function>gethostbyname</function> veya <function>gethostbyaddr</function> işlevlerine yapılan çağrılarda veritabanının kapanmamasını sağlar (normalde olması gerektiği gibi). Bu yaklaşım işlevlerin sık çağırılması durumunda veritabanının her çağrıda tekrardan açılmasından kurtararak verimi artırır.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-fn" xml:id="glibc-fn-gethostent"><primary>gethostent</primary></indexterm>
     <csproto type="işlev">
      <csname><ptr>struct&#160;hostent</ptr><function>gethostent</function></csname>
      <csparam><void/></csparam>
     </csproto>
     <header>&netdb.h;</header>
     <conceptlist>
      <concept>&mtunsafe; &race;<code linkend="glibc-safety-identifier">:hostent</code> &race;<code linkend="glibc-safety-identifier">:hostentbuf</code> &env; &locale;</concept>
      <concept>&asunsafe; &dlopen; &plugin; &heap; &lock;</concept>
      <concept>&acunsafe; &corrupt; &lock;  &fd; &mem;</concept>
     </conceptlist>
     <para>
      Bu işlev konak veritabanındaki sıradaki girdiyi döndürür. Eğer başka girdi yoksa boş gösterici döndürür.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-fn" xml:id="glibc-fn-endhostent"><primary>endhostent</primary></indexterm>
     <csproto type="işlev">
      <csname><type>void</type><function>endhostent</function></csname>
      <csparam><void/></csparam>
     </csproto>
     <header>&netdb.h;</header>
     <conceptlist>
      <concept>&mtunsafe; &race;<code linkend="glibc-safety-identifier">:hostent</code> &env; &locale;</concept>
      <concept>&asunsafe; &dlopen; &plugin; &heap; &lock;</concept>
      <concept>&acunsafe; &corrupt; &lock; &fd; &mem;</concept>
     </conceptlist>
     <para>
      Bu işlev konak veritabanını kapatır.
     </para>
    </csynopsis>
   </sect2>
  </sect1>
  <sect1 xml:id="glibc-Ports">
   <title>İnternet Portları</title>
   <titleabbrev>İnternet port numaraları.</titleabbrev>
   <para>
    <indexterm linkend="glibc-cp"><primary>port number</primary></indexterm>
    İnternet isim alanındaki bir soket adresi, bir makinenin İnternet adresi ile makine üzerindeki soketleri birbirinden ayıran (belirtilen protokole göre) <wordasword>port numarası</wordasword>ndan oluşur. Port numaraları 0 ile 65,535 arasında değer alır.
   </para>
   <para>
    <varname>IPPORT_RESERVED</varname> değerinin altındaki port numaraları <uri xl:href="man1-finger"/> ve <uri xl:href="man1-telnet"/> gibi standart sunucular için ayrılmıştır. Bunların kayıtlarını tutan bir veritabanı vardır ve hizmet ismini port numarasına eşlemek için <function>getservbyname</function> işlevi kullanılabilir. Bkz. <xref linkend="glibc-Services-Database"/>.
   </para>
   <para>
    Eğer veritabanında tanımlanmış standart sunucular dışında bir sunucu yazılırsa onun için bir port numarası seçmek gerekir. Bunun için <varname>IPPORT_USERRESERVED</varname> değerinden büyük bir numara kullanılmalıdır; bu numaralar sunucular için ayrılmıştır ancak sistem tarafından özdevinimli olarak üretilmez. Diğer kullanıcılar tarafından çalıştırılan sunucularla karışıklıktan kaçınmak yazılımcının sorumluluğundadır.
   </para>
   <para>
    Bir soket adres belirtmeden kullanılırsa, port numarasını sistem üretir. Bu numara <varname>IPPORT_RESERVED</varname> ve <varname>IPPORT_USERRESERVED</varname> arasındadır.
   </para>
   <para>
    Aslında internette iki farklı soketin aynı port numarasını kullanması, her ikisi de aynı soket adresiyle (konak adresi artı port numarası) çalışmadığı sürece olasıdır. Port numarası, üst düzey protokollerin bunu gerektirmesi gibi özel durumlar haricinde tekrar kullanılmamalıdır. Normalde sistem buna izin vermez; <function>bind</function> normalde farklı port numaraları verilmesinde ısrar eder. Port numarasını tekrar kullanmak için, <varname>SO_REUSEADDR</varname> <link linkend="glibc-Socket-Level-Options">soket seçeneğinin</link> etkinleştirilmesi gerekir.
   </para>
   <para>
    <indexterm linkend="glibc-pg"><primary>netinet/in.h</primary></indexterm>
    Bu makrolar &netinet-in.h; başlık dosyasında tanımlıdır.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-IPPORT_RESERVED"><primary>IPPORT_RESERVED</primary></indexterm>
    <csproto type="makro">
     <csname><type>int</type> <function>IPPORT_RESERVED</function></csname>
    </csproto>
    <header>&netinet-in.h;</header>
    <para>
     <code>IPPORT_RESERVED</code> değerinden düşük port numaraları süper kullanıcının kullanımına ayrılmıştır.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-IPPORT_USERRESERVED"><primary>IPPORT_USERRESERVED</primary></indexterm>
    <csproto type="makro">
     <csname><type>int</type> <function>IPPORT_USERRESERVED</function></csname>
    </csproto>
    <header>&netinet-in.h;</header>
    <para>
     <code>IPPORT_USERRESERVED</code> değerinden büyük ya da eşit port numaraları doğrudan kullanıma ayrılmıştır; bunlar özdevinimli ayrılmaz.
    </para>
   </csynopsis>
  </sect1>
  <sect1 xml:id="glibc-Services-Database">
   <title>Hizmet Veritabanı</title>
   <titleabbrev>Portların simgesel isimleri olabilir.</titleabbrev>
   <para>
    <indexterm linkend="glibc-cp"><primary>hizmet veritabanı</primary></indexterm>
    <indexterm linkend="glibc-cp"><primary>hizmet isminin port numarasına çevrilmesi</primary></indexterm>
    <indexterm linkend="glibc-cp"><primary>port numarasının hizmet ismine çevrilmesi</primary></indexterm>
    <indexterm linkend="glibc-pg"><primary sortas="etc/services">/etc/services</primary></indexterm>
    <indexterm linkend="glibc-pg"><primary>netdb.h</primary></indexterm>
    Bilinen hizmetlerin kayıtlarını tutan veritabanı genellikle <filename>/etc/services</filename> dosyası veya bir isim sunucusundaki eşdeğeridir. Bu araçlar, &netdb.h; başlık dosyasında tanımlı olup hizmet veritabanına erişim için kullanılabilir.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-tp" xml:id="glibc-tp-servent"><primary sortas="servent">struct&nbsp;servent</primary></indexterm>
    <csproto type="veri türü">
     <csname><type>struct</type><function>servent</function></csname>
    </csproto>
    <header>&netdb.h;</header>
    <para>
     <code>struct&nbsp;servent</code> türü hizmet veritabanındaki girdilerle ilgili bilgiyi tutar. Aşağıdaki üyelere sahiptir:
    </para>
    <glosslist>
     <glossentry>
      <glossterm>
       <type>char&nbsp;*</type><structfield>s_name</structfield>
      </glossterm>
      <glossdef>
       <para>
        Hizmetin "resmi" adıdır.
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm>
       <type>char&nbsp;**</type><structfield>s_aliases</structfield>
      </glossterm>
      <glossdef>
       <para>
        Hizmetin diğer adlarıdır ve dizgelerden oluşan bir dizi olarak gösterilir. Boş gösterici diziyi sonlandırır.
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm>
       <type>int&nbsp;</type><structfield>s_port</structfield>
      </glossterm>
      <glossdef>
       <para>
        Hizmetin port numarasıdır. Port numaraları ağ bayt sıralamasında verilmiştir; bkz, <xref linkend="glibc-Byte-Order"/>.
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm>
       <type>char&nbsp;*</type><structfield>s_proto</structfield>
      </glossterm>
      <glossdef>
       <para>
        Hizmet ile beraber kullanılan protokolün adıdır; bkz. <xref linkend="glibc-Protocols-Database"/>.
       </para>
      </glossdef>
     </glossentry>
    </glosslist>
   </csynopsis>
   <para>
    Belirli bir hizmet hakkında bilgi almak için, <function>getservbyname</function> veya <function>getservbyport</function> işlevleri kullanılır. Bilgi duruk olarak tahsis edilmiş bir yapı içinde döndürülür; çağrılar arasında bu bilgi kaydedilmek istenirse bilginin kopyalanması gerekir.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-getservbyname"><primary>getservbyname</primary></indexterm>
    <csproto type="işlev">
     <csname><ptr>struct&#160;servent</ptr><function>getservbyname</function></csname>
     <csparam><ptr>const&#160;char</ptr><parameter>name</parameter></csparam>
     <csparam><ptr>const&#160;char</ptr><parameter>proto</parameter></csparam>
    </csproto>
    <header>&netdb.h;</header>
    <conceptlist>
     <concept>&mtunsafe; &race;<code linkend="glibc-safety-identifier">:servbyname</code> &locale;</concept>
     <concept>&asunsafe; &dlopen; &plugin; &heap; &lock;</concept>
     <concept>&acunsafe; &corrupt; &lock; &fd; &mem;</concept>
    </conceptlist>
    <para>
     <code>getservbyname</code> işlevi <parameter>name</parameter> adlı <parameter>proto</parameter> protokolünü kullanan hizmet hakkında bilgi döndürür. Eğer böyle bir hizmet yoksa boş gösterici döndürür.
    </para>
    <para>
     Bu işlev sunucular için olduğu kadar istemciler için de kullanışlıdır; sunucular hangi portu <link linkend="glibc-Listening">dinlemeleri</link> gerektiğini bu işlevle belirler.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-getservbyport"><primary>getservbyport</primary></indexterm>
    <csproto type="işlev">
     <csname><ptr>struct&#160;servent</ptr><function>getservbyport</function></csname>
     <csparam><type>int</type><parameter>port</parameter></csparam>
     <csparam><ptr>const&#160;char</ptr><parameter>proto</parameter></csparam>
    </csproto>
    <header>&netdb.h;</header>
    <conceptlist>
     <concept>&mtunsafe; &race;<code linkend="glibc-safety-identifier">:servbyport</code> &locale;</concept>
     <concept>&asunsafe; &dlopen; &plugin; &heap; &lock;</concept>
     <concept>&acunsafe; &corrupt; &lock; &fd; &mem;</concept>
    </conceptlist>
    <para>
     <code>getservbyport</code> işlevi <parameter>port</parameter> portunda <parameter>proto</parameter> protokolünü kullanan hizmet hakkında bilgi döndürür. Eğer böyle bir hizmet yoksa boş gösterici döndürür.
    </para>
   </csynopsis>
   <para>
    <function>setservent</function>, <function>getservent</function> ve <function>endservent</function> işlevlerini kullanarak hizmet veritabanı taranabilir. Bu işlevleri kullanırken dikkatli olunmalıdır çünkü bunlar evresel işlevler değildir.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-setservent"><primary>setservent</primary></indexterm>
    <csproto type="işlev">
     <csname><type>void</type><function>setservent</function></csname>
     <csparam><type>int</type><parameter>stayopen</parameter></csparam>
    </csproto>
    <header>&netdb.h;</header>
    <conceptlist>
     <concept>&mtunsafe; &race;<code linkend="glibc-safety-identifier">:servent</code> &locale;</concept>
     <concept>&asunsafe; &dlopen; &plugin; &heap; &lock;</concept>
     <concept>&acunsafe; &corrupt; &lock; &fd; &mem;</concept>
    </conceptlist>
    <para>
     Bu işlev hizmet veritabanını taramaya başlamak için açar.
    </para>
    <para>
     <parameter>stayopen</parameter> bağımsız değişkeni sıfır değilse, bir bayrağı kaldırarak <function>getservbyname</function> veya <function>getservbyport</function> işlevlerine yapılan çağrılarda veritabanının kapanmamasını sağlar (normalde olması gerektiği gibi). Bu yaklaşım işlevlerin sık çağırılması durumunda veritabanının her çağrıda tekrardan açılmasından kurtararak verimi artırır.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-getservent"><primary>getservent</primary></indexterm>
    <csproto type="işlev">
     <csname><ptr>struct&#160;servent</ptr><function>getservent</function></csname>
     <csparam><void/></csparam>
    </csproto>
    <header>&netdb.h;</header>
    <conceptlist>
     <concept>&mtunsafe; &race;<code linkend="glibc-safety-identifier">:servent</code> &race;<code linkend="glibc-safety-identifier">:serventbuf</code> &locale;</concept>
     <concept>&asunsafe; &dlopen; &plugin; &heap; &lock;</concept>
     <concept>&acunsafe; &corrupt; &lock; &fd; &mem;</concept>
    </conceptlist>
    <para>
     Bu işlev hizmet veritabanındaki bir sonraki girdiyi döndürür. Eğer başka girdi yoksa boş gösterici döner.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-endservent"><primary>endservent</primary></indexterm>
    <csproto type="işlev">
     <csname><type>void</type><function>endservent</function></csname>
     <csparam><void/></csparam>
    </csproto>
    <header>&netdb.h;</header>
    <conceptlist>
     <concept>&mtunsafe; &race;<code linkend="glibc-safety-identifier">:servent</code> &locale;</concept>
     <concept>&asunsafe; &dlopen; &plugin; &heap; &lock;</concept>
     <concept>&acunsafe; &corrupt; &lock; &fd; &mem;</concept>
    </conceptlist>
    <para>
     Bu işlev hizmet veritabanını kapatır.
    </para>
   </csynopsis>
  </sect1>
  <sect1 xml:id="glibc-Byte-Order">
   <title>Bayt Sırası Dönüşümü</title>
   <titleabbrev>Bazı konaklar farklı bayt sıralama kabulleri kullanabilir.</titleabbrev>
   <para>
    <indexterm linkend="glibc-cp"><primary>soketler</primary><secondary>bayt sırası dönüşümü</secondary></indexterm>
    <indexterm linkend="glibc-cp"><primary>bayt sırası</primary><secondary>dönüşüm</secondary></indexterm>
    <indexterm linkend="glibc-cp"><primary>bayt sırası</primary><secondary>anlamlı bayt başta (big-endian)</secondary></indexterm>
    <indexterm linkend="glibc-cp"><primary>bayt sırası</primary><secondary>anlamlı bayt sonda (little-endian)</secondary></indexterm>
    <indexterm linkend="glibc-cp"><primary>big-endian</primary></indexterm>
    <indexterm linkend="glibc-cp"><primary>little-endian</primary></indexterm>
    <indexterm linkend="glibc-cp"><primary>bayt sırası</primary><secondary>ağ bayt sırası</secondary></indexterm>
    <indexterm linkend="glibc-cp"><primary>bayt sırası</primary><secondary>konak bayt sırası</secondary></indexterm>
    Bir kelime (harfleri bayt olan kelime) içindeki bayt sırasının dönüşümü için farklı bilgisayarlar farklı yaklaşımlar kullanır. Bazı bilgisayarlar bir kelimenin en anlamlı baytını başa ("big-endian") ve bzıları da sona ("little-endian") koyar.
   </para>
   <para>
    <indexterm linkend="glibc-cp"><primary>ağ bayt sırası</primary></indexterm>
    İnternet protokolleri ile ağ üzerinden aktarılan veri için "genelde geçerli bayt sıralaması" yaklaşımı belirlendiğinden farklı bayt sıralama yöntemleri kullanan makineler haberleşebilir. Bu <wordasword>ağ bayt sıralaması</wordasword> olarak bilinir.
   </para>
   <para>
    Bir İnternet soket bağlantısı kurulacağında <type>struct&nbsp;sockaddr_in</type> yapısının <code>sin_port</code> ve <code>sin_addr</code> üyelerinde verinin ağ bayt sırasında gösterildiğinden emin olmak gerekir. Eğer soketten gönderilen iletilerde bir tamsayı veri kodlanıyorsa, ağ bayt sırasına göre kodlanmalıdır. Bu yapılmazsa, yazılım çalışırken veya diğer makinelerle konuşurken çökebilir.
   </para>
   <para>
    Port numarası ve konak adresini almak için <function>getservbyname</function>, <function>gethostbyname</function> veya <function>inet_addr</function> kullanılıyorsa, değerler zaten ağ bayt sırasındadır ve bunlar doğrudan <type>struct&nbsp;sockaddr_in</type> yapısına kopyalanabilir.
   </para>
   <para>
    Aksi takdirde, değerler dönüştürülmek zorundadır. <code>sin_port</code> üyesine atanacak değerleri dönüştürmek için <function>htons</function> ve <function>ntohs</function> kullanılmalıdır. <code>sin_addr</code> üyesine atanacak IPv4 adreslerini dönüştürmek için ise <function>htonl</function> ve <function>ntohl</function> kullanılmalıdır. (<type>struct&nbsp;in_addr</type> ve <type>uint32_t</type> veri türlerinin eşdeğer olduğu unutulmamalıdır.) Bu işlevler &netinet-in.h; başlık dosyasında tanımlıdır.
    <indexterm linkend="glibc-pg"><primary>netinet/in.h</primary></indexterm>
   </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-htons"><primary>htons</primary></indexterm>
    <csproto type="işlev">
     <csname><type>uint16_t</type><function>htons</function></csname>
     <csparam><type>uint16_t</type><parameter>hostshort</parameter></csparam>
    </csproto>
    <header>&netinet-in.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     Bu işlev <type>uint16_t</type> türündeki <parameter>hostshort</parameter> tamsayısını konak bayt sırasından ağ bayt sırasına dönüştürür.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-ntohs"><primary>ntohs</primary></indexterm>
    <csproto type="işlev">
     <csname><type>uint16_t</type><function>ntohs</function></csname>
     <csparam><type>uint16_t</type><parameter>netshort</parameter></csparam>
    </csproto>
    <header>&netinet-in.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     Bu işlev <type>uint16_t</type> türündeki <parameter>netshort</parameter> tamsayısını ağ bayt sırasından konak bayt sırasına dönüştürür.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-htonl"><primary>htonl</primary></indexterm>
    <csproto type="işlev">
     <csname><type>uint32_t</type><function>htonl</function></csname>
     <csparam><type>uint32_t</type><parameter>hostlong</parameter></csparam>
    </csproto>
    <header>&netinet-in.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     Bu işlev <type>uint32_t</type> türündeki <parameter>hostlong</parameter> tamsayısını konak bayt sırasından ağ bayt sırasına dönüştürür.
    </para>
    <para>
     IPv4 İnternet adresleri için kullanılır.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-ntohl"><primary>ntohl</primary></indexterm>
    <csproto type="işlev">
     <csname><type>uint32_t</type><function>ntohl</function></csname>
     <csparam><type>uint32_t</type><parameter>netlong</parameter></csparam>
    </csproto>
    <header>&netinet-in.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     Bu işlev <type>uint32_t</type> türündeki <parameter>netlong</parameter> tamsayısını ağ bayt sırasından konak bayt sırasına dönüştürür.
    </para>
    <para>
     IPv4 İnternet adresleri için kullanılır.
    </para>
   </csynopsis>
  </sect1>
  <sect1 xml:id="glibc-Protocols-Database">
   <title>Protokol Veritabanı</title>
   <titleabbrev>İsimleriyle protokoller.</titleabbrev>
   <para>
    <indexterm linkend="glibc-cp"><primary>protokol veritabanı</primary></indexterm>
    Soketlerle kullanılan iletişim protokolleri verinin nasıl değiş/tokuş edildiği konusundaki alt seviye ayrıntılarla ilgilidir. Örneğin, protokol veri aktarımındaki ve ileti yönlendirme komutlarındaki hataları bulmak için sağlama toplamı uygular. Normal kullanıcı yazılımlarının bu ayrıntılarla ilgilenmeleri gerekmez.
   </para>
   <para>
    <indexterm linkend="glibc-cp"><primary>TCP (İnternet protokolü)</primary></indexterm>
    İnternet isim alanındaki varsayılan iletişim protokolü iletişim tarzına bağlıdır. Akım (stream) iletişimi için varsayılan iletişim tarzı TCP'dir (Transmission Control Protocol - Denetimli Aktarım Protokolü). Veri katarı iletişimi için varsayılan iletişim tarzı UDP'dir (User Datagram Protocol - Kullanıcı Veri Katarı Protokolü). Güvenilir veri katarı iletişimi için varsayılan iletişim tarzı RDP'dir (Reliable Datagram Protocol - Güvenilir Veri Katarı Protokolü). Hemen hemen her zaman varsayılan iletişim tarzının kullanılması gerekir.
   </para>
   <para>
    <indexterm linkend="glibc-pg"><primary sortas="etc/protocols">/etc/protocols</primary></indexterm>
    İnternet protokolleri genelde numara yerine isimle belirtilir. Bir konak tarafından bilinen ağ protokolleri bir veritabanında saklanmaktadır. Bu genellikle ya <filename>/etc/protocols</filename> dosyasından veya bir isim sunucusunun sunduğu eşdeğerinden elde edilir. Protokol numarası ile ilişkili protokol ismini veritabanında aramak için <function>getprotobyname</function> işlevi kullanılabilir.
   </para>
   <para>
    <indexterm linkend="glibc-pg"><primary>netdb.h</primary></indexterm>
    Burada protokol veritabanına erişim için gerekli araçların ayrıntılı açıklaması bulunabilir. Bunlar &netdb.h; başlık dosyasında tanımlıdır.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-tp" xml:id="glibc-tp-protoent"><primary sortas="protoent">struct&#160;protoent</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-protoent"><primary>soketler</primary><secondary>protokol veritabanı</secondary></indexterm>
    <csproto type="veri türü">
     <csname><type>struct</type><function>protoent</function></csname>
    </csproto>
    <header>&netdb.h;</header>
    <para>
     Bu veri türü ağ protokolleri veritabanındaki girdileri göstermek için kullanılır. Aşağıdaki üyeleri içerir:
    </para>
    <glosslist>
     <glossentry>
      <glossterm>
       <type>char&nbsp;*</type><structfield>p_name</structfield>
      </glossterm>
      <glossdef>
       <para>
        Protokolün "resmi" adıdır.
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm>
       <type>char&nbsp;**</type><structfield>p_aliases</structfield>
      </glossterm>
      <glossdef>
       <para>
        Bunlar protokolün diğer adlarıdır, bir dizgeler dizisi olarak belirtilmiştir. Dizinin son elemanı boş göstericidir.
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm>
       <type>int&nbsp;</type><structfield>p_proto</structfield>
      </glossterm>
      <glossdef>
       <para>
        Protokol numarasıdır (konak bayt sırasında); <function>socket</function> işlevinin <parameter>protokol</parameter> bağımsız değişkeninde kullanılır.
       </para>
      </glossdef>
     </glossentry>
    </glosslist>
   </csynopsis>
   <para>
    Belirli bir protokolü protokol veritabanında aramak için <command>getprotobyname</command> ve <command>getprotobynumber</command> işlevleri kullanılabilir. Bilgi duruk olarak tahsis edilmiş bir yapı içinde döner; çağrılar arasında bu bilgi kaydedilmek istenirse bilginin kopyalanması gerekir.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-getprotobyname"><primary>getprotobyname</primary></indexterm>
    <csproto type="işlev">
     <csname><ptr>struct&nbsp;protoent</ptr><function>getprotobyname</function></csname>
     <csparam><ptr>const&nbsp;char</ptr><parameter>name</parameter></csparam>
    </csproto>
    <header>&netdb.h;</header>
    <conceptlist>
     <concept>&mtunsafe; &race;<code linkend="glibc-safety-identifier">:protobyname</code> &locale;</concept>
     <concept>&asunsafe; &dlopen; &plugin; &heap; &lock;</concept>
     <concept>&acunsafe; &corrupt; &lock; &fd; &mem;</concept>
    </conceptlist>
    <para>
     <code>getprotobyname</code> işlevi <parameter>name</parameter> isimli ağ protokolü hakkında bilgi döndürür. Böyle bir protokol yoksa, boş gösterici döner.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-getprotobynumber"><primary>getprotobynumber</primary></indexterm>
    <csproto type="işlev">
     <csname><ptr>struct&nbsp;protoent</ptr><function>getprotobynumber</function></csname>
     <csparam><type>int</type><parameter>protocol</parameter></csparam>
    </csproto>
    <header>&netdb.h;</header>
    <conceptlist>
     <concept>&mtunsafe; &race;<code linkend="glibc-safety-identifier">:protobynumber</code> &locale;</concept>
     <concept>&asunsafe; &dlopen; &plugin; &heap; &lock;</concept>
     <concept>&acunsafe; &corrupt; &lock; &fd; &mem;</concept>
    </conceptlist>
    <para>
     <code>getprotobynumber</code> işlevi <parameter>protocol</parameter> numaralı ağ protokolü hakkında bilgi döndürür. Böyle bir protokol yoksa, boş gösterici döner.
    </para>
   </csynopsis>
   <para>
    <function>setprotoent</function>, <function>getprotoent</function> ve <function>endprotoent</function> işlevlerini kullanarak bütün protokol veritabanı belli bir protokol için taranabilir. Bu işlevler evresel işlevler olmadığı için kullanırken dikkatli olunmalıdır.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-setprotoent"><primary>setprotoent</primary></indexterm>
    <csproto type="işlev">
     <csname><type>void</type><function>setprotoent</function></csname>
     <csparam><type>int</type><parameter>stayopen</parameter></csparam>
    </csproto>
    <header>&netdb.h;</header>
    <conceptlist>
     <concept>&mtunsafe; &race;<code linkend="glibc-safety-identifier">:protoent</code> &locale;</concept>
     <concept>&asunsafe; &dlopen; &plugin; &heap; &lock;</concept>
     <concept>&acunsafe; &corrupt; &lock; &fd; &mem;</concept>
    </conceptlist>
    <para>
     Bu işlev protokol veritabanını taramaya başlamak için açar.
    </para>
    <para>
     <parameter>stayopen</parameter> bağımsız değişkeni sıfır değilse, bir bayrağı kaldırarak <function>getprotobyname</function> veya <function>getprotobynumber</function> işlevine yapılan çağrılarda veritabanının kapanmamasını sağlar (normalde olması gerektiği gibi). Bu yaklaşım işlevlerin sık çağırılması durumunda veritabanının her çağrıda tekrardan açılmasından kurtararak verimi artırır.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-getprotoent"><primary>getprotoent</primary></indexterm>
    <csproto type="işlev">
     <csname><ptr>struct&nbsp;protoent</ptr><function>getprotoent</function></csname>
     <csparam><void/></csparam>
    </csproto>
    <header>&netdb.h;</header>
    <conceptlist>
     <concept>&mtunsafe; &race;<code linkend="glibc-safety-identifier">:protoent</code> &race;<code linkend="glibc-safety-identifier">:protoentbuf</code> &locale;</concept>
     <concept>&asunsafe; &dlopen; &plugin; &heap; &lock;</concept>
     <concept>&acunsafe; &corrupt; &lock; &fd; &mem;</concept>
    </conceptlist>
    <para>
     Bu işlev protokol veritabanında sıradaki girdiyi döndürür. Başka girdi yoksa boş gösterici döner.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-endprotoent"><primary>endprotoent</primary></indexterm>
    <csproto type="işlev">
     <csname><type>void</type><function>endprotoent</function></csname>
     <csparam><void/></csparam>
    </csproto>
    <header>&netdb.h;</header>
    <conceptlist>
     <concept>&mtunsafe; &race;<code linkend="glibc-safety-identifier">:protoent</code> &locale;</concept>
     <concept>&asunsafe; &dlopen; &plugin; &heap; &lock;</concept>
     <concept>&acunsafe; &corrupt; &lock; &fd; &mem;</concept>
    </conceptlist>
    <para>
     Bu işlev protokol veritabanını kapatır.
    </para>
   </csynopsis>
  </sect1>
  <sect1 xml:id="glibc-Inet-Example">
   <title>İnternet Soketi Örneği</title>
   <titleabbrev>Olay budur.</titleabbrev>
   <para>
    Burada İnternet isim alanında bir soketin nasıl oluşturulacağını ve isimlendirileceğini gösteren bir örnek bulunmaktadır. Yeni oluşturulan soket yazılımın çalıştığı makinede bulunur. Makinenin İnternet adresini bulup kullanmak yerine, bu örnekte konak adres, yerine <varname>INADDR_ANY</varname> kullanılmıştır; sistem bunu makinenin gerçek adresi ile değiştirir.
   </para>
   <example>
    <screen>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;

int
make_socket (uint16_t port)
{
  int sock;
  struct sockaddr_in name;

  /* <replaceable>Soketi oluştur.</replaceable> */
  sock = socket (PF_INET, SOCK_STREAM, 0);
  if (sock &lt; 0)
    {
      perror ("socket");
      exit (EXIT_FAILURE);
    }

  /* <replaceable>Sokete bir isim ver.</replaceable> */
  name.sin_family = AF_INET;
  name.sin_port = htons (port);
  name.sin_addr.s_addr = htonl (INADDR_ANY);
  if (bind (sock, (struct sockaddr *) &amp;name, sizeof (name)) &lt; 0)
    {
      perror ("bind");
      exit (EXIT_FAILURE);
    }

  return sock;
}
</screen>
    <para>
     Konak ismi ve port numarası verildiğinde <type>struct&nbsp;sockaddr_in</type> yapısını nasıl doldurulacağını gösteren örnek:
    </para>
    <screen>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netdb.h&gt;

void
init_sockaddr (struct sockaddr_in *name,
               const char *hostname,
               uint16_t port)
{
  struct hostent *hostinfo;

  name-&gt;sin_family = AF_INET;
  name-&gt;sin_port = htons (port);
  hostinfo = gethostbyname (hostname);
  if (hostinfo == NULL)
    {
      fprintf (stderr, "%s diye bir konak yok.\n", hostname);
      exit (EXIT_FAILURE);
    }
  name-&gt;sin_addr = *(struct in_addr *) hostinfo-&gt;h_addr;
}
</screen>
   </example>
  </sect1>
 </chapter>
 <chapter xml:id="glibc-Misc-Namespaces">
  <title>Diğer İsim Alanları</title>
  <titleabbrev>Diğer isim alanlarının tamamı burada belgelendirilmemiştir.</titleabbrev>
  <para>
   <indexterm linkend="glibc-vr"><primary>PF_NS</primary></indexterm>
   <indexterm linkend="glibc-vr"><primary>PF_ISO</primary></indexterm>
   <indexterm linkend="glibc-vr"><primary>PF_CCITT</primary></indexterm>
   <indexterm linkend="glibc-vr"><primary>PF_IMPLINK</primary></indexterm>
   <indexterm linkend="glibc-vr"><primary>PF_ROUTE</primary></indexterm>
   Diğer bazı isim alanları ve ilişkili protokol aileleri de desteklenmektedir fakat henüz belgelendirilmemiştir, çünkü sık kullanılmamaktadır. <varname>PF_NS</varname> Xerox Ağ Yazılımı (Xerox Network Software) protokollerini belirtir. <varname>PF_ISO</varname> Open Systems Interconnect'i belirtir. <varname>PF_CCITT</varname>, CCITT protokollerini belirtir. &sys-socket.h; bu simgeleri ve henüz gerçeklenmemiş diğerlerinin isimlendirme protokollerini tanımlar.
  </para>
  <para>
   <varname>PF_IMPLINK</varname> konaklar ve İnternet İleti İşlemcileri arası iletişim için kullanılır. Bunun ve sıklıkla kullanılan yerel ağ yönlendirme protokolü <varname>PF_ROUTE</varname> hakkında bilgi için GNU Hurd Kılavuzuna bakılabilir (Bir gün olacak İnşallah...).
  </para>
 </chapter>

 <chapter xml:id="glibc-Open-Close-Sockets" userlevel="notoc">
  <?dbhtml stop-chunking?>
  <title>Soketlerin Açılması ve Kapatılması</title>
  <titleabbrev>Soketlerin oluşturulması ve yok edilmesi.</titleabbrev>
  <para>
   Bu bölümde soket açma ve kapatma amacıyla kullanılan asıl kütüphane işlevleri açıklanmaktadır. Aynı işlevler tüm isim alanları ve bağlantı türleri için çalışır.
  </para>
  <sect1 xml:id="glibc-Creating-a-Socket">
   <title>Soketin Oluşturulması</title>
   <titleabbrev>Soket nasıl açılır.</titleabbrev>
   <para>
    <indexterm linkend="glibc-cp"><primary>soketler</primary><secondary>açılması</secondary></indexterm>
    Soket oluşturmanın en ilkel yöntemi &sys-socket.h; başlık dosyasında tanımlı <function>socket</function> işlevini kullanmaktır.
    <indexterm linkend="glibc-pg"><primary>sys/socket.h</primary></indexterm>
   </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-socket"><primary>socket</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-socket"><primary>soketler</primary><secondary>oluşturulması</secondary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>socket</function></csname>
     <csparam><type>int</type><parameter>namespace</parameter></csparam>
     <csparam><type>int</type><parameter>style</parameter></csparam>
     <csparam><type>int</type><parameter>protocol</parameter></csparam>
    </csproto>
    <header>&sys-socket.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe; &fd;</concept>
    </conceptlist>
    <para>
     Bu işlev soket oluşturur. <parameter>style</parameter> iletişim tarzını belirler; <xref linkend="glibc-Communication-Styles"/> bölümünde listelenen soket tarzlarından biri olmalıdır. <parameter>namespace</parameter> isim alanını belirtir; <varname>PF_LOCAL</varname> (Bkz. <xref linkend="glibc-Local-Namespace"/>) veya <varname>PF_INET</varname> (Bkz. <xref linkend="glibc-Internet-Namespace"/>) olmak zorundadır. <parameter>protocol</parameter> belirli bir protokolü gösterir (Bkz. <xref linkend="glibc-Socket-Concepts"/>); <parameter>protocol</parameter> için sıfır genellikle doğru değerdir.
    </para>
    <para>
     <code>socket</code> işlevinin dönüş değeri yeni soket için bir dosya tanıtıcıdır. Hata durumunda <code>-1</code> değeri döner. Aşağıdaki <varname>errno</varname> hata durumları bu işlev için tanımlanmıştır:
    </para>
    <variablelist>
     <varlistentry>
      <term><code>EPROTONOSUPPORT</code></term>
      <listitem>
       <para>
        <parameter>protocol</parameter> veya <parameter>style</parameter> belirtilen <parameter>namespace</parameter> tarafından desteklenmiyor.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>EMFILE</code></term>
      <listitem>
       <para>
        Süreç zaten çok sayıda açık dosya tanıtıcısına sahip.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>ENFILE</code></term>
      <listitem>
       <para>
        Sistem zaten çok sayıda açık dosya tanıtıcısına sahip.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>EACCES</code></term>
      <listitem>
       <para>
        Süreç belirtilen <parameter>protocol</parameter> veya <parameter>style</parameter> ile soket açma yetkisine sahip değil.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>ENOBUFS</code></term>
      <listitem>
       <para>
        Sistem dahili tampon alanını tüketti.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
    <para>
     <code>socket</code> işlevinin döndürdüğü dosya tanıtıcı hem okuma hem de yazma işlemlerini desteklemektedir. Fakat, ardışık süreçler gibi, soketler de dosya içi konumlama işlemlerini desteklemez.
    </para>
   </csynopsis>
   <para>
    <function>socket</function> işlevinin kullanımına ilişkin örnekler <xref linkend="glibc-Local-Socket-Example"/> ya da <xref linkend="glibc-Inet-Example"/> bölümünde bulunabilir.
   </para>
  </sect1>
  <sect1 xml:id="glibc-Closing-a-Socket">
   <title>Soketin Kapatılması</title>
   <titleabbrev>Soket nasıl kapatılır.</titleabbrev>
   <para>
    <indexterm linkend="glibc-cp"><primary>soketler</primary><secondary>kapatılması</secondary></indexterm>
    Soketin kullanımı sona erdiğinde,  dosya tanıtıcısı basitçe <function>close</function> işlevi ile kapatılabilir; bkz. <xref linkend="glibc-Opening-and-Closing-Files"/>. Bağlantı üzerinde hala aktarılmayı bekleyen veri varsa, normalde <function>close</function> aktarımın tamamlanmasına çalışır. Bu davranış, bir zaman aşımı değeri belirtmek için <varname>SO_LINGER</varname> soket seçeneği kullanılarak denetlenebilir; bkz. <xref linkend="glibc-Socket-Options"/>.
   </para>
   <para>
    <indexterm linkend="glibc-pg"><primary>sys/socket.h</primary></indexterm>
    Ayrıca, sadece aktarım veya alım durdurulmak istenirse, &sys-socket.h; içerisinde tanımlı <function>shutdown</function> işlevi çağrılabilir.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-shutdown"><primary>shutdown</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-shutdown"><primary>soketler</primary><secondary>aktarımın durdurulması</secondary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>shutdown</function></csname>
     <csparam><type>int</type><parameter>socket</parameter></csparam>
     <csparam><type>int</type><parameter>how</parameter></csparam>
    </csproto>
    <header>&sys-socket.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe; &fd;</concept>
    </conceptlist>
    <para>
     <code>shutdown</code> işlevi <parameter>socket</parameter> soketinin bağlantısını kapatır. <parameter>how</parameter> bağımsız değişkeni yapılacak işlem türünü belirler:
    </para>
    <variablelist>
     <varlistentry>
      <term><code>0</code></term>
      <listitem>
       <para>
        Soketin veri alımını durdur. Eğer veri hala geliyorsa, reddedilir.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>1</code></term>
      <listitem>
       <para>
        Soketten veri gönderimini durdur. Aktarım için bekleyen veri iptal edilir. Gönderilmiş veri için ulaştı bilgisi beklenmez, eğer veri kaybolduysa tekrar gönderilmez.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>2</code></term>
      <listitem>
       <para>
        Hem alımı hem de gönderimi durdur.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
    <para>
     Başarı halinde dönüş değeri <code>0</code>, başarısızlıkta <code>-1</code>'dir. Aşağıdaki <varname>errno</varname> hata durumları bu işlev için tanımlanmıştır:
    </para>
    <variablelist>
     <varlistentry>
      <term><code>EBADF</code></term>
      <listitem>
       <para>
        <parameter>socket</parameter> geçerli bir dosya tanıtıcı değil.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>ENOTSOCK</code></term>
      <listitem>
       <para>
        <parameter>socket</parameter> bir soket değil.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>ENOTCONN</code></term>
      <listitem>
       <para>
        <parameter>socket</parameter> bağlı değil.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </csynopsis>
  </sect1>
  <sect1 xml:id="glibc-Socket-Pairs">
   <title>Soket Çiftleri</title>
   <titleabbrev>Ardışık süreçler gibi oluşturulur.</titleabbrev>
   <para>
    <indexterm linkend="glibc-cp"><primary>soketler</primary><secondary>soket çiftleri</secondary></indexterm>
    <indexterm linkend="glibc-cp"><primary>soket çiftleri</primary><secondary>oluşturulması</secondary></indexterm>
    <indexterm linkend="glibc-cp"><primary>soket çiftleri</primary><secondary>açılması</secondary></indexterm>
    <indexterm linkend="glibc-pg"><primary>sys/socket.h</primary></indexterm>
    Bir <wordasword>soket çifti</wordasword> bir çift bağlı (ancak isimsiz) soketten oluşur. Bu yapı ardışık süreçlere çok benzer ve çoğunlukla da böyle kullanılır. Soket çifti &sys-socket.h; başlık dosyasında tanımlı <function>socketpair</function> işleviyle oluşturulur. Soket çifti ardışık süreçlere çok benzer; ana fark soket çifti çift yönlü olduğu halde; ardışık süreçlerde bir ucun yalnızca-girdi ve diğer ucun ise yalnızca-çıktı için kullanılabilmesidir (Bkz. <xref linkend="glibc-Pipes-and-FIFOs"/>).
   </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-socketpair"><primary>socketpair</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-socketpair"><primary>soket çiftleri</primary><secondary>oluşturulması</secondary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>socketpair</function></csname>
     <csparam><type>int</type><parameter>namespace</parameter></csparam>
     <csparam><type>int</type><parameter>style</parameter></csparam>
     <csparam><type>int</type><parameter>protocol</parameter></csparam>
     <csparam><type>int</type><parameter>filedes[2]</parameter></csparam>
    </csproto>
    <header>&sys-socket.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe; &fd;</concept>
    </conceptlist>
    <para>
     Bu işlev <parameter>filedes[0]</parameter> ve <parameter>filedes[1]</parameter> içine dosya tanıtıcıları yerleştirerek bir soket çifti oluşturur. Soket çifti aynı anda iki yönlü (full-duplex) iletişim yapılabilen bir iletişim kanalıdır, böylece her iki ucundan da hem okuma hem yazma gerçekleşebilmektedir.
    </para>
    <para>
     <parameter>namespace</parameter>, <parameter>style</parameter> ve <parameter>protocol</parameter> bağımsız değişkenleri <function>socket</function> işlevindeki gibi kullanılmaktadır. <parameter>style</parameter> <xref linkend="glibc-Communication-Styles"/> bölümünde listelenen iletişim tarzlarından biri olmalıdır. <parameter>namespace</parameter> bağımsız değişkeni isim alanını belirler ve <varname>AF_LOCAL</varname> olmalıdır; <parameter>protocol</parameter> iletişim protokolünü belirler, fakat tek anlamlı değer sıfırdır.
    </para>
    <para>
     Eğer <parameter>style</parameter> bağlantısız bir iletişim tarzını belirtiyorsa, elde edilen iki soket bağlı değildir, fakat her ikisi de diğerini varsayılan hedef adres olarak bilir, böylece her ikisi de diğerine paket gönderebilir.
    </para>
    <para>
     <code>socketpair</code> işlevi başarı durumunda <code>0</code>, başarısızlıkta <code>-1</code> döndürür. Aşağıdaki <varname>errno</varname> hata durumları bu işlev için tanımlanmıştır:
    </para>
    <variablelist>
     <varlistentry>
      <term><code>EMFILE</code></term>
      <listitem>
       <para>
        Süreç çok fazla açık dosya tanıtıcısına sahip.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>EAFNOSUPPORT</code></term>
      <listitem>
       <para>
        Belirtilen isim alanı desteklenmiyor.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>EPROTONOSUPPORT</code></term>
      <listitem>
       <para>
        Belirtilen protokol desteklenmiyor.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>EOPNOTSUPP</code></term>
      <listitem>
       <para>
        Belirtilen protokol, soket çifti oluşturmayı desteklemiyor.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </csynopsis>
  </sect1>
 </chapter>

 <chapter xml:id="glibc-Connections">
  <title>Soketlerin Bağlantıda Kullanılması</title>
  <titleabbrev>Bağlantı durumunda soketler üzerindeki işlemler.</titleabbrev>
  <para>
   <indexterm linkend="glibc-cp"><primary>bağlantı</primary></indexterm>
   <indexterm linkend="glibc-cp"><primary>istemci</primary></indexterm>
   <indexterm linkend="glibc-cp"><primary>sunucu</primary></indexterm>
   En sık kullanılan iletişim tarzları belirli bir sokete bağlantı kurulmasını ve onunla veri değişimini içerir. Bağlantı yapılması bakışımsızdır; bir taraf (<wordasword>istemci</wordasword>) bağlantı isteğinde bulunurken diğer taraf (<wordasword>sunucu</wordasword>) soket oluşturur ve bağlantı isteği için bekler.
  </para>
  <sect1 xml:id="glibc-Connecting">
   <title>Bağlantının Oluşturulması</title>
   <titleabbrev>İstemci yazılım ne yapmalı.</titleabbrev>
   <para>
    <indexterm linkend="glibc-cp"><primary>soketler</primary><secondary>bağlanması</secondary></indexterm>
    <indexterm linkend="glibc-cp"><primary>soketler</primary><secondary>bir bağlantının başlatılması</secondary></indexterm>
    <indexterm linkend="glibc-cp"><primary>soketler</primary><secondary>istemci tarafı</secondary></indexterm>
    <indexterm linkend="glibc-cp"><primary>bağlantının başlatılması</primary></indexterm>
    Bir bağlantının kurulmasında, sunucu bağlantı için beklerken istemci bağlanır ve sunucu kabul eder. Burada tartışılan şey istemci yazılımın &sys-socket.h; başlık dosyasında tanımlı <function>connect</function> işleviyle ne yapması gerektiği ile ilgilidir.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-connect"><primary>connect</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-connect"><primary>soketler</primary><secondary>bağlantı</secondary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>connect</function></csname>
     <csparam><type>int</type><parameter>socket</parameter></csparam>
     <csparam><ptr>struct&nbsp;sockaddr</ptr><parameter>addr</parameter></csparam>
     <csparam><type>socklen_t</type><parameter>length</parameter></csparam>
    </csproto>
    <header>&sys-socket.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     <code>connect</code> işlevi <parameter>socket</parameter> dosya tanıtıcılı soketten <parameter>addr</parameter> adresli ve <parameter>length</parameter> adres uzunluklu sokete bağlantı başlatır. (Bu soketin normal olarak başka bir makinede ve sunucu olarak kurulmuş olması gerekir.) Bu bağımsız değişkenlerin nasıl yorumlandıkları konusunda bilgi için bkz, <xref linkend="glibc-Socket-Addresses"/>.
    </para>
    <para>
     Normalde, <code>connect</code> sunucu isteğe yanıt verene kadar bekler. <code>connect</code> işlevinin yanıt beklemeden hemen dönmesini sağlamak için <parameter>socket</parameter> soketinde <link linkend="glibc-File-Status-Flags">engellemesiz kip</link> seçilebilir.
    </para>
    <para>
     <code>connect</code> işlevi başarı durumunda <code>0</code>, başarısızlıkta <code>-1</code> döndürür. Aşağıdaki <varname>errno</varname> hata durumları bu işlev için tanımlanmıştır:
    </para>
    <variablelist>
     <varlistentry>
      <term><code>EBADF</code></term>
      <listitem>
       <para>
        <parameter>socket</parameter> soketi geçerli bir dosya tanıtıcı değil.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>ENOTSOCK</code></term>
      <listitem>
       <para>
        <parameter>socket</parameter> dosya tanıtıcısı soket değil.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>EADDRNOTAVAIL</code></term>
      <listitem>
       <para>
        Belirtilen adres uzak makinede yok.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>EAFNOSUPPORT</code></term>
      <listitem>
       <para>
        <parameter>addr</parameter> isim alanı bu soket tarafından desteklenmiyor.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>EISCONN</code></term>
      <listitem>
       <para>
        <parameter>socket</parameter> soketi zaten bağlı.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>ETIMEDOUT</code></term>
      <listitem>
       <para>
        Bağlantı girişimi zaman aşımına uğradı.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>ECONNREFUSED</code></term>
      <listitem>
       <para>
        Sunucu bağlantı isteğini açıkça reddetti.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>ENETUNREACH</code></term>
      <listitem>
       <para>
        <parameter>addr</parameter> ile belirtilen ağa bu konak erişemez.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>EADDRINUSE</code></term>
      <listitem>
       <para>
        <parameter>addr</parameter> ile belirtilen soket adresi zaten kullanımda.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>EINPROGRESS</code></term>
      <listitem>
       <para>
        <parameter>socket</parameter> soketi engellemesiz kipte olduğundan bağlantı hemen kurulamıyor. <function>select</function> ile bağlantının tam olarak ne zaman kurulabileceği tespit edilebilir; Bkz. <xref linkend="glibc-Waiting-for-I-O"/>. Bağlantı tam kurulamadan aynı sokete tekrar bir <code>connect</code> çağrısı yapılırsa, çağrı <varname>EALREADY</varname> hatası ile sonlanır.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>EALREADY</code></term>
      <listitem>
       <para>
        <parameter>socket</parameter> soketi engellemesiz kipte ve zaten askıda bekleyen bir bağlantı var (bkz, üstteki <code>EINPROGRESS</code> açıklaması).
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
    <para>
     Bu işlev çok evreli yazılımlar için iptal noktası olarak tanımlanmıştır, bu nedenle tahsis edilen öz kaynakların (bellek, dosya tanıtıcısı, semafor veya herhangi başka bir kaynak) evre iptal edilse dahi serbest bırakılmasının sağlanması şarttır.
    </para>
   </csynopsis>
  </sect1>
  <sect1 xml:id="glibc-Listening">
   <title>Bağlantıların Dinlenmesi</title>
   <titleabbrev>Sunucu yazılım istekleri nasıl bekler.</titleabbrev>
   <para>
    <indexterm linkend="glibc-cp"><primary>soketler</primary><secondary>dinleme</secondary></indexterm>
    <indexterm linkend="glibc-cp"><primary>soketler</primary><secondary>sunucu tarafı</secondary></indexterm>
    Artık sunucu sürecin soket üzerinden bağlantıları kabul etmek için ne yapması gerektiği incelenebilir. Öncelikle sokete gelen bağlantı isteklerini alabilmesi için <function>listen</function> işlevinin kullanılması gerekli, ardında da gelen bağlantıyı kabul etmek için <function>accept</function> işlevi çağrılmalıdır (Bkz. <xref linkend="glibc-Accepting-Connections"/>). Sunucu soketi üzerinde bağlantı isteği olduğunda, <function>select</function> işlevi soketin bağlantı kabul etmek için ne zaman hazır olacağını bildirir (Bkz. <xref linkend="glibc-Waiting-for-I-O"/>).
   </para>
   <para>
    <function>listen</function> işlevi bağlantısız iletişim tarzı kullanılan soketler için kullanılamaz.
   </para>
   <para>
    Bir bağlantı isteği gelene kadar çalışmaya başlamayan ağ sunucusu yazmak bile mümkündür. Bkz. <xref linkend="glibc-Inetd-Servers"/>.
   </para>
   <para>
    İnternet isim alanında, port erişimini denetlemek için özel bir koruma düzeneği yoktur, herhangi bir makinedeki bir süreç sunucuya bağlanabilir. Sunucuya erişimin kısıtlanması isteniyorsa ya sunucunun bağlantı isteğinde bulunan adresi incelemesi sağlanmalı ya da başka bir uzlaşma veya kimlik doğrulama protokolü uygulanmalıdır.
   </para>
   <para>
    Yerel isim alanında ise sokete bağlanmak için erişim izinleri sıradan dosya koruma bitleriyle denetlenir.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-listen"><primary>listen</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-listen"><primary>soketler</primary><secondary>dinleme</secondary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>listen</function></csname>
     <csparam><type>int</type><parameter>socket</parameter></csparam>
     <csparam><type>int</type><parameter>n</parameter></csparam>
    </csproto>
    <header>&sys-socket.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe; &fd;</concept>
    </conceptlist>
    <para>
     <code>listen</code> işlevi bağlantıları kabul edecek <parameter>socket</parameter> soketini etkinleştirir, böylece sunucu soketi elde edilir.
    </para>
    <para>
     <parameter>n</parameter> bağımsız değişkeni bekleyen bağlantılar için kuyruk uzunluğunu belirler. Kuyruk dolunca, bağlanmak için teşebbüs eden yeni istemcilerin bağlantısı, sunucu kuyrukta bekleyen bir bağlantı için <function>accept</function> işlevini çağırana kadar <varname>ECONNREFUSED</varname> hatası ile başarısız olur.
    </para>
    <para>
     İşlev başarı durumunda <code>0</code>, başarısızlıkta <code>-1</code> döndürür. Aşağıdaki <varname>errno</varname> hata durumları bu işlev için tanımlanmıştır:
    </para>
    <variablelist>
     <varlistentry>
      <term><code>EBADF</code></term>
      <listitem>
       <para>
        <parameter>socket</parameter> soketi geçerli bir dosya tanıtıcı değil.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>ENOTSOCK</code></term>
      <listitem>
       <para>
        <parameter>socket</parameter> dosya tanıtıcısı soket değil.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>EOPNOTSUPP</code></term>
      <listitem>
       <para>
        <parameter>socket</parameter> soketi bu işlemi desteklemiyor.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </csynopsis>
  </sect1>
  <sect1 xml:id="glibc-Accepting-Connections">
   <title>Bağlantıların Kabul Edilmesi</title>
   <titleabbrev>Sunucu istek geldiğinde ne yapar.</titleabbrev>
   <para>
    <indexterm linkend="glibc-cp"><primary>bağlantıların kabulü</primary></indexterm>
    Bir sunucu bağlantı isteği aldığında, bağlantıyı isteği kabul ederek tamamlayabilir. Bunun için <function>accept</function> işlevi kullanılır.
   </para>
   <para>
    Sunucu olarak kurulmuş olan bir soket çok sayıda istemciden gelen bağlantı isteklerini kabul edebilir. Bağlantı için sunucunun dinlediği soket değil, <function>accept</function> işlevinin bağlantıyla ilgili oluşturduğu yeni soket kullanılır. <function>accept</function> bu yeni soketin dosya tanıtıcısını döndürür. Sunucunun dinlediği soket diğer bağlantı isteklerini dinlemeye devam eder.
   </para>
   <para>
    Sunucunun dinlediği sokette bekleyen bağlantı isteği sayısı sınırlıdır. İstemcilerden gelen bağlantı istekleri sunucunun karşılık verebileceğinden hızlı gelirse, kuyruk dolabilir ve ilave istekler <varname>ECONNREFUSED</varname> hatası ile reddedilebilir. Azami kuyruk uzunluğu <function>listen</function> işlevinin <parameter>n</parameter> bağımsız değişkeninde belirtilebilir; yine de sistem kuyruk uzunluğu için kendi iç sınırını baskın kılabilir.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-accept"><primary>accept</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-accept"><primary>soketler</primary><secondary>bağlantının kabulü</secondary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>accept</function></csname>
     <csparam><type>int</type><parameter>socket</parameter></csparam>
     <csparam><ptr>struct&nbsp;sockaddr</ptr><parameter>addr</parameter></csparam>
     <csparam><ptr>socklen_t</ptr><parameter>length_ptr</parameter></csparam>
    </csproto>
    <header>&sys-socket.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe; &fd;</concept>
    </conceptlist>
    <para>
     <parameter>socket</parameter> sunucu soketindeki bir bağlantı isteğini kabul etmek için kullanılır.
    </para>
    <para>
     <code>accept</code> işlevi, <parameter>socket</parameter> soketi için engellemesiz kip seçilmediği sürece, süren bir bağlantı yoksa bekler (engellemesiz soketlerde <function>select</function> işlevini kullanarak süren bağlantıların bitmesini beklemek mümkündür.) <xref linkend="glibc-File-Status-Flags"/>, engellemesiz kip hakkında bilgi içerir.
    </para>
    <para>
     <parameter>addr</parameter> ve <parameter>length_ptr</parameter> bağımsız değişkenleri bağlantıyı başlatan istemci soketinin ismi hakkında bilgi döndürür. Bilginin biçimi hakkında bilgi edinmek için bkz, <xref linkend="glibc-Socket-Addresses"/>.
    </para>
    <para>
     Bağlantının kabul edilmesi ile bağlantı <parameter>socket</parameter> soketinden yapılmaz. Bunun yerine, bağlantı yapılacak yeni bir soket oluşturulur. <code>accept</code> işlevinin normal dönüş değeri yeni soketin dosya tanıtıcısıdır.
    </para>
    <para>
     <code>accept</code> işlevinin ardından, <parameter>socket</parameter> soketi bağlantısız ve açık olarak kalır ve kapatılıncaya kadar dinlemeye devam eder. <code>accept</code> işlevi <parameter>socket</parameter> ile tekrar çağrılarak başka bağlantılar kabul edilebilir.
    </para>
    <para>
     Hata oluşursa <code>-1</code> döner. Aşağıdaki <varname>errno</varname> hata durumları bu işlev için tanımlanmıştır:
    </para>
    <variablelist>
     <varlistentry>
      <term><code>EBADF</code></term>
      <listitem>
       <para>
        <parameter>socket</parameter> soketi geçerli bir dosya tanıtıcı değil.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>ENOTSOCK</code></term>
      <listitem>
       <para>
        <parameter>socket</parameter> dosya tanıtıcısı soket değil.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>EOPNOTSUPP</code></term>
      <listitem>
       <para>
        <parameter>socket</parameter> soketi bu işlemi desteklemiyor.
      </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>EWOULDBLOCK</code></term>
      <listitem>
       <para>
        <parameter>socket</parameter> soketi engellemesiz kipte ve bekleyen bağlantı yok.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
    <para>
     Bu işlev çok evreli yazılımlar için iptal noktası olarak tanımlanmıştır, bu nedenle tahsis edilen öz kaynakların (bellek, dosya tanıtıcısı, semafor veya herhangi başka bir kaynak) evre iptal edilse dahi serbest bırakılmasının sağlanması şarttır.
    </para>
   </csynopsis>
   <para>
    <function>accept</function> işlevi bağlantısız iletişim tarzlarını kullanan soketler için kullanılamaz.
   </para>
  </sect1>
  <sect1 xml:id="glibc-Who-is-Connected">
   <title>Bana Kim Bağlı?</title>
   <titleabbrev>Bağlantının diğer ucunun adresinin alınması.</titleabbrev>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-getpeername"><primary>getpeername</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-getpeername"><primary>soketler</primary><secondary>kim bağlı</secondary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>getpeername</function></csname>
     <csparam><type>int</type><parameter>socket</parameter></csparam>
     <csparam><ptr>struct&nbsp;sockaddr</ptr><parameter>addr</parameter></csparam>
     <csparam><ptr>socklen_t</ptr><parameter>length_ptr</parameter></csparam>
    </csproto>
    <header>&sys-socket.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     <code>getpeername</code> işlevi <parameter>socket</parameter>'in bağlı olduğu soket adresini döndürür; adresi <parameter>addr</parameter> ve <parameter>length_ptr</parameter> ile belirtilen bellek alanında saklar. Adresin uzunluğunu *<parameter>length_ptr</parameter> içinde saklar.
    </para>
    <para>
     Adresin biçimi hakkında bilgi edinmek için bkz, <xref linkend="glibc-Socket-Addresses"/>. Bazı işletim sistemlerinde, <code>getpeername</code> yalnızca İnternet etki alanında çalışır.
    </para>
    <para>
     <code>getpeername</code> işlevi başarı durumunda <code>0</code>, başarısızlıkta <code>-1</code> döndürür. Aşağıdaki <varname>errno</varname> hata durumları bu işlev için tanımlanmıştır:
    </para>
    <variablelist>
     <varlistentry>
      <term><code>EBADF</code></term>
      <listitem>
       <para>
        <parameter>socket</parameter> soketi geçerli bir dosya tanıtıcı değil.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>ENOTSOCK</code></term>
      <listitem>
       <para>
        <parameter>socket</parameter> dosya tanıtıcısı soket değil.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>ENOTCONN</code></term>
      <listitem>
       <para>
        <parameter>socket</parameter> soketi bu işlemi desteklemiyor.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>ENOBUFS</code></term>
      <listitem>
       <para>
        Dahili tamponlar yeterli değil.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </csynopsis>
  </sect1>

  <sect1 xml:id="glibc-Transferring-Data" userlevel="notoc">
   <?dbhtml stop-chunking?>
   <title>Veri Aktarımı</title>
   <titleabbrev>Veri nasıl gönderilip alınır.</titleabbrev>
   <para>
    <indexterm linkend="glibc-cp"><primary>soketler</primary><secondary>okuma</secondary></indexterm>
    <indexterm linkend="glibc-cp"><primary>soketler</primary><secondary>yazma</secondary></indexterm>
    Soket bir kez karşıya bağlandığında, veri aktarımı için sıradan <wordasword>okuma</wordasword> ve <wordasword>yazma</wordasword> işlemleri (<xref  linkend="glibc-I-O-Primitives"/>) yapılabilir. Bir soket iki yönlü iletişim kanalıdır, böylece okuma ve yazma işlemleri her iki uçta da gerçekleştirilebilir.
   </para>
   <para>
    Soket işlemlerine özgü bazı G/Ç kipleri de vardır. Bu kipleri belirtmek için, daha genel olan <function>read</function> ve <function>write</function> işlevleri yerine <function>recv</function> ve <function>send</function> işlevlerini  kullanmak gerekir. <function>recv</function> ve <function>send</function> işlevleri, özel G/Ç kiplerinin denetlenmesi için çeşitli bayrakların belirtilebileceği, ek bir bağımsız değişken alır. Örneğin, <varname>MSG_OOB</varname> bayrağı belirtilerek sıra dışı veri okunup yazılabilir, <varname>MSG_PEEK</varname> bayrağı girdiyi gözetlemek için,  <varname>MSG_DONTROUTE</varname> bayrağı yönlendirme bilgisinin çıktıda içerilmesini denetlemek için kullanılabilir.
   </para>
   <sect2 xml:id="glibc-Sending-Data">
    <title>Veri Gönderimi</title>
    <titleabbrev>Verinin <code>send</code> ile gönderilmesi.</titleabbrev>
    <para>
     <indexterm linkend="glibc-pg"><primary>sys/socket.h</primary></indexterm>
     <function>send</function> işlevi &sys-socket.h; başlık dosyasında bildirilmiştir. Eğer <parameter>flags</parameter> bağımsız değişkeni sıfır ise, <function>send</function> yerine <function>write</function> kullanılabilir; bkz. <xref linkend="glibc-I-O-Primitives"/>. Eğer soket bağlıyken bağlantısı koparsa, <function>send</function> veya <function>write</function> işlevinin herhangi bir kullanımında <varname>SIGPIPE</varname> sinyali alınır (bkz, <xref linkend="glibc-Miscellaneous-Signals"/>).
    </para>
    <csynopsis>
     <indexterm linkend="glibc-fn" xml:id="glibc-fn-send"><primary>send</primary></indexterm>
     <indexterm linkend="glibc-cp" xml:id="glibc-cp-send"><primary>soketler</primary><secondary>veri gönderimi</secondary></indexterm>
     <csproto type="işlev">
      <csname><type>ssize_t</type><function>send</function></csname>
      <csparam><type>int</type><parameter>socket</parameter></csparam>
      <csparam><ptr>const&#160;void</ptr><parameter>buffer</parameter></csparam>
      <csparam><type>size_t</type><parameter>size</parameter></csparam>
      <csparam><type>int</type><parameter>flags</parameter></csparam>
     </csproto>
     <header>&sys-socket.h;</header>
     <conceptlist>
      <concept>&mtsafe;</concept>
      <concept>&assafe;</concept>
      <concept>&acsafe;</concept>
     </conceptlist>
     <para>
      <code>send</code> işlevi <function>write</function> gibidir, ancak fazladan <parameter>flags</parameter> bağımsız değişkeni vardır. <parameter>flags</parameter> bağımsız değişkeni için olası değerler <xref linkend="glibc-Socket-Data-Options"/> bölümünde bulunabilir.
     </para>
     <para>
      Bu işlev aktarılan bayt miktarı ile veya hata durumunda <code>-1</code> ile döner. Soket engellemesiz kipteyse <code>send</code> (<function>write</function> gibi) verinin henüz bir kısmını gönderdikten sonra dönebilir. Engellemesiz kip hakkında daha fazla bilgi için bkz, <xref linkend="glibc-File-Status-Flags"/>.
     </para>
     <para>
      Başarılı bir dönüş değeri her ne kadar verinin hatasız bir şekilde gönderildiğini belirtse de, hatasız bir şekilde alındığını belirtmez.
     </para>
     <para>
      Aşağıdaki <varname>errno</varname> hata durumları bu işlev için tanımlanmıştır:
     </para>
     <variablelist>
      <varlistentry>
       <term><code>EBADF</code></term>
       <listitem>
        <para>
         <parameter>socket</parameter> soketi geçerli bir dosya tanıtıcı değil.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><code>EINTR</code></term>
       <listitem>
        <para>
         Veri gönderilmeden önce işlem bir sinyal tarafından kesildi. Bkz, <xref linkend="glibc-Interrupted-Primitives"/>.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><code>ENOTSOCK</code></term>
       <listitem>
        <para>
         <parameter>socket</parameter> dosya tanıtıcısı soket değil.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><code>EMSGSIZE</code></term>
       <listitem>
        <para>
         Soket türü verinin bütün olarak gönderilmesini gerektiriyor, fakat veri bunun için çok büyük.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><code>EWOULDBLOCK</code></term>
       <listitem>
        <para>
         Soket engellemesiz kipte ve yazma işlemi soketi engeller. (Normalde <code>send</code> işlem bitinceye kadar soketi engeller.)
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><code>ENOBUFS</code></term>
       <listitem>
        <para>
         Dahili tamponlar yeterli değil.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><code>ENOTCONN</code></term>
       <listitem>
        <para>
         <parameter>socket</parameter> soketi bu işlemi desteklemiyor.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><code>EPIPE</code></term>
       <listitem>
        <para>
         Bu soket bağlıydı ancak bağlantı koptu. Bu durumda, <code>send</code> öncelikle bir <varname>SIGPIPE</varname> sinyali üretir; sinyal yok sayılır veya engellenirse ya da bu sinyal işleyicisi dönerse <code>send</code> işlevi <varname>EPIPE</varname> hatası ile başarısız olur.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
     <para>
      Bu işlev çok evreli yazılımlar için iptal noktası olarak tanımlanmıştır, bu nedenle tahsis edilen öz kaynakların (bellek, dosya tanıtıcısı, semafor veya herhangi başka bir kaynak) evre iptal edilse dahi serbest bırakılmasının sağlanması şarttır.
     </para>
    </csynopsis>
   </sect2>
   <sect2 xml:id="glibc-Receiving-Data">
    <title>Veri Alımı</title>
    <titleabbrev>Verinin <code>recv</code> ile okunması.</titleabbrev>
    <para>
     <indexterm linkend="glibc-pg"><primary>sys/socket.h</primary></indexterm>
     <function>recv</function> işlevi &sys-socket.h; başlık dosyasında bildirilmiştir. <parameter>flags</parameter> bağımsız değişkeni sıfırsa, <function>recv</function> yerine <function>read</function> kullanılabilir; bkz. <xref linkend="glibc-I-O-Primitives"/>.
    </para>
    <csynopsis>
     <indexterm linkend="glibc-fn" xml:id="glibc-fn-recv"><primary>recv</primary></indexterm>
     <indexterm linkend="glibc-cp" xml:id="glibc-cp-recv"><primary>soketler</primary><secondary>veri alımı</secondary></indexterm>
     <csproto type="işlev">
      <csname><type>ssize_t</type><function>recv</function></csname>
      <csparam><type>int</type><parameter>socket</parameter></csparam>
      <csparam><ptr>void</ptr><parameter>buffer</parameter></csparam>
      <csparam><type>size_t</type><parameter>size</parameter></csparam>
      <csparam><type>int</type><parameter>flags</parameter></csparam>
     </csproto>
     <header>&sys-socket.h;</header>
     <conceptlist>
      <concept>&mtsafe;</concept>
      <concept>&assafe;</concept>
      <concept>&acsafe;</concept>
     </conceptlist>
     <para>
      <code>recv</code> işlevi <function>read</function> gibidir, ancak fazladan <parameter>flags</parameter> bağımsız değişkeni vardır. <parameter>flags</parameter> bağımsız değişkeni için olası değerler <xref linkend="glibc-Socket-Data-Options"/> bölümünde bulunabilir.
     </para>
     <para>
      Eğer <parameter>socket</parameter> için engellemesiz kip seçildiyse ve okunacak veri yoksa, <code>recv</code> beklemeden hemen döner. Engellemesiz kip hakkında daha fazla bilgi için bkz, <xref linkend="glibc-File-Status-Flags"/>.
     </para>
     <para>
      Bu işlev aktarılan bayt miktarı ile veya hata durumunda <code>-1</code> ile döner. Aşağıdaki <varname>errno</varname> hata durumları bu işlev için tanımlanmıştır:
     </para>
     <variablelist>
      <varlistentry>
       <term><code>EBADF</code></term>
       <listitem>
        <para>
         <parameter>socket</parameter> soketi geçerli bir dosya tanıtıcı değil.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><code>EINTR</code></term>
       <listitem>
        <para>
         Veri alınmadan önce işlem bir sinyal tarafından kesildi. Bkz, <xref linkend="glibc-Interrupted-Primitives"/>.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><code>ENOTSOCK</code></term>
       <listitem>
        <para>
         <parameter>socket</parameter> dosya tanıtıcısı soket değil.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><code>EWOULDBLOCK</code></term>
       <listitem>
        <para>
         Soket engellemesiz kipte ve okuma işlemi soketi engeller. (Normalde <code>recv</code> işlem bitinceye kadar soketi engeller.)
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><code>ENOTCONN</code></term>
       <listitem>
        <para>
         <parameter>socket</parameter> soketi bu işlemi desteklemiyor.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
     <para>
      Bu işlev çok evreli yazılımlar için iptal noktası olarak tanımlanmıştır, bu nedenle tahsis edilen öz kaynakların (bellek, dosya tanıtıcısı, semafor veya herhangi başka bir kaynak) evre iptal edilse dahi serbest bırakılmasının sağlanması şarttır.
     </para>
    </csynopsis>
   </sect2>
   <sect2 xml:id="glibc-Socket-Data-Options">
    <title>Soket Verisi Seçenekleri</title>
    <titleabbrev><code>send</code> ve <code>recv</code> kullanımı.</titleabbrev>
    <para>
     <indexterm linkend="glibc-pg"><primary>sys/socket.h</primary></indexterm>
     <function>send</function> ve <function>recv</function> işlevlerindeki <parameter>flags</parameter> bağımsız değişkeni bit maskesidir. Aşağıdaki makroların değerleri bitsel VEYAlanarak bu bağımsız değişken için değer elde edilebilir. Hepsi &sys-socket.h; başlık dosyasında tanımlıdır.
    </para>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-MSG_OOB"><primary>MSG_OOB</primary></indexterm>
     <csproto type="makro">
      <csname><type>int</type><function>MSG_OOB</function></csname>
     </csproto>
     <header>&sys-socket.h;</header>
     <para>
      Sıra-dışı-veri gönderilir ve alınır; bkz. <xref linkend="glibc-Out-of-Band-Data"/>.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-MSG_PEEK"><primary>MSG_PEEK</primary></indexterm>
     <csproto type="makro">
      <csname><type>int</type><function>MSG_PEEK</function></csname>
     </csproto>
     <header>&sys-socket.h;</header>
     <para>
      Veriye bakılır ancak girdi kuyruğundan çıkarılmaz. Bu sadece <function>recv</function> gibi girdi işlevleri için anlamlıdır (<function>send</function> ile anlamlı değildir).
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-MSG_DONTROUTE"><primary>MSG_DONTROUTE</primary></indexterm>
     <csproto type="makro">
      <csname><type>int</type><function>MSG_DONTROUTE</function></csname>
     </csproto>
     <header>&sys-socket.h;</header>
     <para>
      Yönlendirme bilgisi iletinin içinde bulunmaz. Bu sadece çıktı işlevlerinde anlamlıdır ve genellikle sadece tanı veya yönlendirme amaçlı yazılımlarda kullanılır. Bu konu burada anlatılmayacaktır.
     </para>
    </csynopsis>
   </sect2>
  </sect1>
  <sect1 xml:id="glibc-Byte-Stream-Example">
   <title>Bayt Akımlı Soket Örneği</title>
   <titleabbrev>İnternet isim alanında bayt akımlı soket üzerinden haberleşen istemci.</titleabbrev>
   <para>
    Burada İnternet isim alanında bayt akımlı bir soket için bağlantı yapan örnek bir istemci yazılım görülmektedir; sunucuya bağlandıktan sonra sunucuya sadece bir dizge gönderip çıkmaktadır.
   </para>
   <para>
    Bu yazılım soket adresini ayarlamak için <function>init_sockaddr</function> kullanmaktadır; bkz. <xref linkend="glibc-Inet-Example"/>.
   </para>
   <screen>#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netdb.h&gt;

#define PORT            5555
#define MESSAGE         "Alooo!! Hala egleniyor musun?!?"
#define SERVERHOST      "www.gnu.org"

void
write_to_server (int filedes)
{
  int nbytes;

  nbytes = write (filedes, MESSAGE, strlen (MESSAGE) + 1);
  if (nbytes &lt; 0)
    {
      perror ("write");
      exit (EXIT_FAILURE);
    }
}


int
main (void)
{
  extern void init_sockaddr (struct sockaddr_in *name,
                             const char *hostname,
                             uint16_t port);
  int sock;
  struct sockaddr_in servername;

  /* <replaceable>Soketi oluştur.</replaceable> */
  sock = socket (PF_INET, SOCK_STREAM, 0);
  if (sock &lt; 0)
    {
      perror ("socket (client)");
      exit (EXIT_FAILURE);
    }

  /* <replaceable>Sunucuya bağlan.</replaceable> */
  init_sockaddr (&amp;servername, SERVERHOST, PORT);
  if (0 &gt; connect (sock,
                   (struct sockaddr *) &amp;servername,
                   sizeof (servername)))
    {
      perror ("connect (client)");
      exit (EXIT_FAILURE);
    }

  /* <replaceable>Veriyi sunucuya gönder.</replaceable> */
  write_to_server (sock);
  close (sock);
  exit (EXIT_SUCCESS);
}
</screen>
  </sect1>
  <sect1 xml:id="glibc-Server-Example">
   <title>Bayt Akımlı Bağlantı Sunucusu Örneği</title>
   <titleabbrev>Bayt akımlı bağlantı sunucusu yazılımı.</titleabbrev>
   <para>
    Sunucu tarafı daha karmaşıktır. Aynı anda çok sayıda istemcinin sunucuya bağlı kalması istendiği için, basitçe <function>read</function> veya <function>recv</function> işlevini çağırarak tek bir istemciden girdi beklemek doğru olmaz. Yapılması gereken şey <function>select</function> işlevini (<xref linkend="glibc-Waiting-for-I-O"/>) kullanarak açık olan bütün soketlerden girdi beklemektir. Bu sunucuya diğer bağlantı istekleriyle ilgilenme olanağı da sağlar.
   </para>
   <para>
    Bu sunucu istemciden bir ileti aldığında ilgi çekecek hiçbir şey yapmaz. Dosya sonu durumunu algıladığında o istemci için soketi kapatır (bu aynı zamanda istemcinin de soketi kapatmasını sağlar).
   </para>
   <para>
    Bu yazılım soket adresini ayarlamak için <function>make_socket</function> işlevini kullanmaktadır; bkz. <xref linkend="glibc-Inet-Example"/>.
   </para>
   <screen>#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netdb.h&gt;

#define PORT    5555
#define MAXMSG  512

int
read_from_client (int filedes)
{
  char buffer[MAXMSG];
  int nbytes;

  nbytes = read (filedes, buffer, MAXMSG);
  if (nbytes &lt; 0)
    {
      /* <replaceable>Okuma hatası.</replaceable> */
      perror ("read");
      exit (EXIT_FAILURE);
    }
  else if (nbytes == 0)
    /* <replaceable>Dosya-sonu.</replaceable> */
    return -1;
  else
    {
      /* <replaceable>Veri okundu.</replaceable> */
      fprintf (stderr, "Sunucu: gelen ileti: `%s'\n", buffer);
      return 0;
    }
}

int
main (void)
{
  extern int make_socket (uint16_t port);
  int sock;
  fd_set active_fd_set, read_fd_set;
  int i;
  struct sockaddr_in clientname;
  size_t size;

  /* <replaceable>Soketi oluştur ve bağlantı kabul etmeye ayarla.</replaceable> */
  sock = make_socket (PORT);
  if (listen (sock, 1) &lt; 0)
    {
      perror ("listen");
      exit (EXIT_FAILURE);
    }

  /* <replaceable>Etkin soketleri ilklendir.</replaceable> */
  &fd;_ZERO (&amp;active_fd_set);
  &fd;_SET (sock, &amp;active_fd_set);

  while (1)
    {
      /* <replaceable>Etkin soketlerden bilgi gelene kadar engelle.</replaceable> */
      read_fd_set = active_fd_set;
      if (select (FD_SETSIZE, &amp;read_fd_set, NULL, NULL, NULL) &lt; 0)
        {
          perror ("select");
          exit (EXIT_FAILURE);
        }

      /* <replaceable>Girdi bekleyerek bütün soketleri hizmete al.</replaceable> */
      for (i = 0; i &lt; &fd;_SETSIZE; ++i)
        if (FD_ISSET (i, &amp;read_fd_set))
          {
            if (i == sock)
              {
                /* <replaceable>Dinlenen sokette bağlantı isteği var.</replaceable> */
                int new;
                size = sizeof (clientname);
                new = accept (sock,
                              (struct sockaddr *) &amp;clientname,
                              &amp;size);
                if (new &lt; 0)
                  {
                    perror ("accept");
                    exit (EXIT_FAILURE);
                  }
                fprintf (stderr,
                         "Sunucu: Konak %s, %hd. portundan baglaniyor\n",
                         inet_ntoa (clientname.sin_addr),
                         ntohs (clientname.sin_port));
                &fd;_SET (new, &amp;active_fd_set);
              }
            else
              {
                /* <replaceable>Bağlı olan sokete veri ulaşıyor.</replaceable> */
                if (read_from_client (i) &lt; 0)
                  {
                    close (i);
                    &fd;_CLR (i, &amp;active_fd_set);
                  }
              }
          }
    }
}
</screen>
  </sect1>
  <sect1 xml:id="glibc-Out-of-Band-Data">
   <title>Sıra-Dışı-Veri Aktarımı</title>
   <titleabbrev>Önceliği olan bir özellik.</titleabbrev>
   <para>
    <indexterm linkend="glibc-cp"><primary>Sıra-dışı-veri</primary></indexterm>
    <indexterm linkend="glibc-cp"><primary>soketler</primary><secondary>öncelikli veri</secondary></indexterm>
    <indexterm linkend="glibc-cp"><primary>soketler</primary><secondary>sıra-dışı-veri</secondary></indexterm>
    Bağlantılı akımlar, sıradan veriye nazaran teslim edilme önceliğine sahip <wordasword>sıra-dışı-veri</wordasword> aktarımına izin vermektedir. Sıra dışı veri gönderiminin asıl kullanılma nedeni, özel durumlarda uyarı gönderme ihtiyacıdır. Sıra dışı veri göndermek için <function>send</function> işlevi <varname>MSG_OOB</varname> bayrağıyla kullanılır (Bkz. <xref linkend="glibc-Sending-Data"/>).
   </para>
   <para>
    Sıra dışı veriler yüksek öncelikle alınır çünkü alıcı işlem onu sırayla almak zorunda değildir; bir sonraki sıra dışı veriyi okumak için, <function>recv</function> işlevi <varname>MSG_OOB</varname> bayrağıyla kullanılır (Bkz. <xref linkend="glibc-Receiving-Data"/>). Sıradan okuma işlemleri sıra dışı veriyi okumaz; sadece sıradan veriyi okur.
   </para>
   <para>
    <indexterm linkend="glibc-cp"><primary>soketler</primary><secondary>acil durum</secondary></indexterm>
    Soket, sıra dışı verinin geldiğini görünce, kendi sürecine ya da süreç grubuna <varname>SIGURG</varname> sinyalini gönderir. Soket sahibi <function>fcntl</function> işlevinde <varname>F_SETOWN</varname> komutu kullanılarak belirtilebilir; bkz. <xref linkend="glibc-Interrupt-Input"/>. Sıra dışı veriyi okuma gereksinimi gibi bir durumda uygun hareketi yapmak için bu sinyalin işleyicisinin kurulması gerekir, bkz. <xref linkend="glibc-Signal-Handling"/>.
   </para>
   <para>
    Diğer bir seçenek olarak, sokette özel durum oluşması için bekleyebilen <function>select</function> işlevini kullanarak sıra dışı veri olana kadar beklenebilir ya da bekleyen sıra dışı veri var mı diye bakılabilir.  <function>select</function> işlevi hakkında daha fazla bilgi için bkz, <xref linkend="glibc-Waiting-for-I-O"/>.
   </para>
   <para>
    Sıra dışı verinin bildirilmesi (<varname>SIGURG</varname> veya <function>select</function> ile) sıra dışı verinin gelmek üzere olduğunu gösterir; veri daha sonra ulaşabilir. Eğer sıra dışı veri daha gelmeden okunmaya çalışılırsa, <function>recv</function> işlevi <varname>EWOULDBLOCK</varname> hatası ile sonlanır.
   </para>
   <para>
    Sıra dışı veri gönderilince, akımdaki sıradan veri otomatik olarak "im"lenir, bu da sıra dışı verinin "ne durumda olabileceğini" gösterir. Bu sıra dışı verinin anlamı "şimdiye kadar gönderdiklerimi iptal et" ise kullanışlıdır. Buradaki alıcı işlemde, imlenmeden önce sıradan verinin gönderilip gönderilmediğini sınanabilir:
   </para>
   <para>
    <screen>success = ioctl (socket, SIOCATMARK, &amp;imgeldi);</screen>
   </para>
   <para>
    Eğer soketin okuma göstericisine "im" ulaştıysa bir tamsayı değişken olan <replaceable>imgeldi</replaceable> sıfır olmayan bir değer yapılır.
   </para>
   <para>
    Burada sıra dışı iminden önce gelen sıradan veriyi iptal eden bir işlev görülmektedir:
   </para>
   <example>
    <screen>int
discard_until_mark (int socket)
{
  while (1)
    {
      /* <replaceable>Bu isteğe bağlı bir sınır değildir;
         herhangi bir büyüklük olabilir.</replaceable>  */
      char buffer[1024];
      int imgeldi, success;

      /* <replaceable>im geldiyse işlev dönsün.</replaceable>  */
      success = ioctl (socket, SIOCATMARK, &amp;imgeldi);
      if (success &lt; 0)
        perror ("ioctl");
      if (result)
        return;

      /* <replaceable>Aksi takdirde, bir miktar sıradan veriyi
         oku ve iptal et. Bu imden sonrasını okumamayı
         garantiler, tabii ki imden önce başlıyorsa.</replaceable>  */
      success = read (socket, buffer, sizeof buffer);
      if (success &lt; 0)
        perror ("read");
    }
}
</screen>
   </example>
   <para>
    Eğer imden önceki verinin iptali istenmiyorsa, sıra dışı veriye sistem içi tampon bölgesinde yer açmak için bir kısmı okunabilir. Eğer sıra dışı veri okunmaya çalışılır ve <varname>EWOULDBLOCK</varname> hatası alınırsa, bir miktar sıradan veri okunmaya çalışılır (kaydederek daha sonra istendiğinde kullanılabilir) ve yer açıldığı görülür.
   </para>
   <example>
    <screen>struct buffer
{
  char *buf;
  int size;
  struct buffer *next;
};

/* <replaceable>Sıra dışı veriyi SOKET'ten oku ve verinin adresini
   ve büyüklüğünü `struct buffer' içinde döndür.

   Sıra dışı veriye yer açmak için bir miktar sıradan
   veri okumak gerekebilir. Bu durumda, sıradan veri
   'next' alanında bulunan tamponlar zincirine
   kaydedilir.</replaceable>  */

struct buffer *
read_oob (int socket)
{
  struct buffer *tail = 0;
  struct buffer *list = 0;

  while (1)
    {
      /* <replaceable>Bu keyfi bir sınırdır.
         Bunu sınırsız yapmayı bilen var mı?</replaceable>  */
#define BUF_SZ 1024
      char *buf = (char *) xmalloc (BUF_SZ);
      int success;
      int atmark;

      /* <replaceable>Sıra dışı veriyi tekrar okumaya çalış</replaceable>  */
      success = recv (socket, buf, BUF_SZ, MSG_OOB);
      if (success &gt;= 0)
        {
          /* <replaceable>Alındı, dön.</replaceable>  */
          struct buffer *link
            = (struct buffer *) xmalloc (sizeof (struct buffer));
          link-&gt;buf = buf;
          link-&gt;size = success;
          link-&gt;next = list;
          return link;
        }

      /* <replaceable>Yoksa, imin (atmark) gelip gelmediğine bak.</replaceable>  */
      success = ioctl (socket, SIOCATMARK, &amp;atmark);
      if (success &lt; 0)
        perror ("ioctl");
      if (atmark)
        {
          /* <replaceable>İm (atmark) gelmiş; geriye kalan sıradan
             verinin faydası olmaz. Bir süre bekle.</replaceable>  */
          sleep (1);
          continue;
        }

      /* <replaceable>Aksi takdirde, bir miktar sıradan veriyi
         okuyup kaydet. Bu imden sonrasını okumamayı
         garantiler, tabii ki imden önce başlıyorsa.</replaceable>  */
      success = read (socket, buf, BUF_SZ);
      if (success &lt; 0)
        perror ("read");

      /* <replaceable>Bu veriyi tampon listesine kaydet.</replaceable>  */
      {
        struct buffer *link
          = (struct buffer *) xmalloc (sizeof (struct buffer));
        link-&gt;buf = buf;
        link-&gt;size = success;

        /* <replaceable>Yeni veriyi listenin sonuna ekle.</replaceable>  */
        if (tail)
          tail-&gt;next = link;
        else
          list = link;
        tail = link;
      }
    }
}
</screen>
   </example>
  </sect1>
 </chapter>
 <chapter xml:id="glibc-Datagrams" userlevel="notoc">
  <?dbhtml stop-chunking?>
  <title>Bağlantısız Soket İşlemleri</title>
  <titleabbrev>Veri katarı soketleri ile işlemler</titleabbrev>
  <para>
   <indexterm linkend="glibc-cp"><primary>soketler</primary><secondary>veri katarları</secondary></indexterm>
   <indexterm linkend="glibc-cp"><primary>soketler</primary><secondary>bağlantısız</secondary></indexterm>
   Bu bölümde bağlantı kullanmayan iletişim tarzlarının (<varname>SOCK_DGRAM</varname> ve <varname>SOCK_RDM</varname> tarzları) nasıl kullanıldığını açıklanmaktadır. Bu tarzların kullanımında veri paketleri katar haline getirilir ve her paket bağımsız birer iletişim sağlar. Her paket için hedef adresi belirtmek gerekir.
  </para>
  <para>
   Veri katarı paketleri mektuplara benzer: her biri bağımsız olarak kendi hedef adresiyle gönderilirse ve yanlış sırayla ulaşabilir veya hiç ulaşamayabilir.
  </para>
  <para>
   <function>listen</function> ve <function>accept</function> işlevleri soketlerde bağlantısız iletişim tarzlarında kullanılamaz.
  </para>
  <sect1 xml:id="glibc-Sending-Datagrams">
   <title>Veri Katarının Gönderilmesi</title>
   <titleabbrev>Bir veri katarı soketinde paketlerin gönderimi.</titleabbrev>
   <para>
    <indexterm linkend="glibc-cp"><primary>veri katarı</primary><secondary>aktarılması</secondary></indexterm>
    <indexterm linkend="glibc-pg"><primary>sys/socket.h</primary></indexterm>
    Veri katarı soketinden veri gönderiminin normal yolu &sys-socket.h; başlık dosyasında bildirilen <function>sendto</function> işlevini kullanmaktır.
   </para>
   <para>
    Bir veri katarı soketi üzerinde <function>connect</function> işlevi çağrılabilir, fakat bu sadece soket üzerinden veri aktarımları için varsayılan hedefi belirler. Bir soketin varsayılan adresi olduğunda oraya <function>send</function> (<xref linkend="glibc-Sending-Data"/>) veya <function>write</function> (<xref linkend="glibc-I-O-Primitives"/>) kullanılarak paket gönderilebilir. Ön tanımlı hedef, <function>connect</function> işlevinin <parameter>addr</parameter> bağımsız değişkeninde <varname>AF_UNSPEC</varname> belirtilerek iptal edilebilir. <function>connect</function> işlevi hakkında daha fazla bilgi için bkz, <xref linkend="glibc-Connecting"/>.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-sendto"><primary>sendto</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-sendto"><primary>veri katarı</primary><secondary>gönderilmesi</secondary></indexterm>
    <csproto type="işlev">
     <csname><type>ssize_t</type><function>sendto</function></csname>
     <csparam><type>int</type><parameter>socket</parameter></csparam>
     <csparam><ptr>const&nbsp;void</ptr><parameter>buffer</parameter></csparam>
     <csparam><type>size_t</type><parameter>size</parameter></csparam>
     <csparam><type>int</type><parameter>flags</parameter></csparam>
     <csparam><ptr>struct&nbsp;sockaddr</ptr><parameter>addr</parameter></csparam>
     <csparam><type>socklen_t</type><parameter>length</parameter></csparam>
    </csproto>
    <header>&sys-socket.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     <code>sendto</code> işlevi <parameter>buffer</parameter> içindeki veriyi,  <parameter>socket</parameter> soketi üzerinden, <parameter>addr</parameter> ve <parameter>length</parameter> (uzunluk) bağımsız değişkenleri ile belirtilen hedef adresine aktarır. <parameter>size</parameter> bağımsız değişkeni aktarılacak bayt sayısını belirtir.
    </para>
    <para>
     <parameter>flags</parameter> bağımsız değişkeni <function>send</function> işlevindeki gibi yorumlanır; bkz. <xref linkend="glibc-Socket-Data-Options"/>.
    </para>
    <para>
     Dönüş değeri ve hata durumları da <function>send</function> işlevindeki gibidir, fakat hataların algılanması ve raporlanması için sisteme güvenilemez; en sık rastlanan hata, paket kaybı veya belirtilen adreste alıcının bulunmamasıdır ve gönderici makinedeki işletim sisteminin genelde bundan haberi olmaz.
    </para>
    <para>
     <code>sendto</code> işlevinden bir önceki çağrıya ilişkin sorunları raporlaması istenebilir.
    </para>
    <para>
     Bu işlev çok evreli yazılımlar için iptal noktası olarak tanımlanmıştır, bu nedenle tahsis edilen öz kaynakların (bellek, dosya tanımlayıcısı, semafor veya herhangi başka bir kaynak) evre iptal edilse dahi serbest bırakılmasının sağlanması şarttır.
    </para>
   </csynopsis>
  </sect1>
  <sect1 xml:id="glibc-Receiving-Datagrams">
   <title>Veri Katarının Alınması</title>
   <titleabbrev>Veri katarındaki paketlerin alımı.</titleabbrev>
   <para>
    <indexterm linkend="glibc-cp"><primary>veri katarı</primary><secondary>alınması</secondary></indexterm>
    <indexterm linkend="glibc-pg"><primary>sys/socket.h</primary></indexterm>
    <function>recvfrom</function> işlevi veri katarı soketinden bir paket okur ve ek olarak nereden gönderildiğini de söyler. Bu işlev &sys-socket.h; başlık dosyasında bildirilmiştir.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-recvfrom"><primary>recvfrom</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-recvfrom"><primary>veri katarı</primary><secondary>alınması</secondary></indexterm>
    <csproto type="işlev">
     <csname><type>ssize_t</type><function>recvfrom</function></csname>
     <csparam><type>int</type><parameter>socket</parameter></csparam>
     <csparam><ptr>void</ptr><parameter>buffer</parameter></csparam>
     <csparam><type>size_t</type><parameter>size</parameter></csparam>
     <csparam><type>int</type><parameter>flags</parameter></csparam>
     <csparam><ptr>struct&nbsp;sockaddr</ptr><parameter>addr</parameter></csparam>
     <csparam><ptr>socklen_t</ptr><parameter>length-ptr</parameter></csparam>
    </csproto>
    <header>&sys-socket.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     <code>recvfrom</code> işlevi <parameter>socket</parameter> soketinden bir paketi <parameter>buffer</parameter> alanına okur. <parameter>size</parameter> bağımsız değişkeni okunacak azami bayt sayısını belirtir.
    </para>
    <para>
     Paket <parameter>size</parameter> bayttan uzunsa, paketin ilk <parameter>size</parameter> baytı alınır ve paketin geri kalanı kaybolur. Paketin gerisini okumanın hiç bir yolu yoktur. Bu nedenle, bir paket protokolü kullanıldığında, paketin ne uzunlukta olacağını her zaman bilmek gerekir.
    </para>
    <para>
     <parameter>addr</parameter> ve <parameter>length-ptr</parameter> bağımsız değişkenleri paketin geldiği yerin adresini döndürmek için kullanılır. Bkz. <xref linkend="glibc-Socket-Addresses"/>. Yerel etki alanındaki bir soket için adres bilgisi anlamlı değildir, çünkü böyle bir soketin adresi okunamaz (Bkz. <xref linkend="glibc-Local-Namespace"/>). Bu bilgiyle ilgilenilmiyorsa <parameter>addr</parameter> bağımsız değişkenine boş gösterici belirtilebilir.
    </para>
    <para>
     <parameter>flags</parameter> bağımsız değişkeni <function>recv</function> işlevindeki gibi yorumlanır (bkz. <xref linkend="glibc-Socket-Data-Options"/>). Dönüş değeri ve hata durumları da <function>recv</function> işlevi ile aynıdır.
    </para>
    <para>
     Bu işlev çok evreli yazılımlar için iptal noktası olarak tanımlanmıştır, bu nedenle tahsis edilen öz kaynakların (bellek, dosya tanımlayıcısı, semafor veya herhangi başka bir kaynak) evre iptal edilse dahi serbest bırakılmasının sağlanması şarttır.
    </para>
   </csynopsis>
   <para>
    Paketi kimin gönderdiği bilinmek istenmiyorsa <function>recvfrom</function> yerine basitçe <function>recv</function> işlevi de (bkz. <xref linkend="glibc-Receiving-Data"/>) kullanılabilir (çünkü paketin nereden gelmesi gerektiği biliniyordur). Hatta <parameter>flags</parameter> bağımsız değişkeni belirtilmeyecekse <function>read</function> işlevi bile kullanılabilir (bkz. <xref linkend="glibc-I-O-Primitives"/>).
   </para>
  </sect1>
  <sect1 xml:id="glibc-Datagram-Example">
    <title>Veri Katarı Soket Örneği</title>
    <titleabbrev>Yerel isim alanı içindeki veri katarı soketi üzerinden paket gönderimi.</titleabbrev>
    <para>
     Burada yerel isim alanındaki veri katarı akımı üzerinden veri gönderen bir grup örnek bulunmaktadır. Hem istemci hem de sunucu yazılımları <xref linkend="glibc-Local-Socket-Example"/> içindeki <code>make_named_socket</code> işlevini kendi soketlerini oluşturmak ve isimlendirmek için kullanmaktadır.
    </para>
    <para>
     Öncelikle sunucu yazılımı gösterilmiştir. Gelecek veriler için bir döngü içerisinde beklemekte ve gelen veri gerisin geriye göndericiye iletilmektedir. Tabii ki bu işe yarar bir yazılım değil, fakat ana fikri vermektedir.
    </para>
    <example>
     <screen>#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/un.h&gt;

#define SERVER  "/tmp/serversocket"
#define MAXMSG  512

int
main (void)
{
  int sock;
  char message[MAXMSG];
  struct sockaddr_un name;
  size_t size;
  int nbytes;

  /* <replaceable>Öncelikle dosya ismini kaldıralım,
     isim yokluğu sorun değil</replaceable> */
  unlink (SERVER);

  /* <replaceable>Soketi oluşturup sonsuz döngüye gir.</replaceable> */
  sock = make_named_socket (SERVER);
  while (1)
    {
      /* <replaceable>Veri katarını bekle.</replaceable> */
      size = sizeof (name);
      nbytes = recvfrom (sock, message, MAXMSG, 0,
                         (struct sockaddr *) &amp; name, &amp;size);
      if (nbytes &lt; 0)
        {
          perror ("recfrom (server)");
          exit (EXIT_FAILURE);
        }

      /* <replaceable>Bir tanı iletisi ver.</replaceable> */
      fprintf (stderr, "Sunucu: alinan ileti: %s\n", message);

      /* <replaceable>İletiyi göndericiye geri yolla.</replaceable> */
      nbytes = sendto (sock, message, nbytes, 0,
                       (struct sockaddr *) &amp; name, size);
      if (nbytes &lt; 0)
        {
          perror ("sendto (server)");
          exit (EXIT_FAILURE);
        }
    }
}
</screen>
   </example>
  </sect1>
  <sect1 xml:id="glibc-Example-Receiver">
    <title>Veri Katarı Okuma Örneği</title>
    <titleabbrev>Veri katarı alan bir yazılım.</titleabbrev>
    <para>
     Bu da önceki sunucuyla ilişkili istemci yazılımıdır.
    </para>
    <para>
     Sunucuya bir veri katarı gönderir ve ardından yanıt bekler. Bu örnekte istemci (ve sunucu) için sokete bir ad verilmesi gerektiğine dikkat edilmelidir. Bu, sunucunun bir iletiyi istemciye geri yönlendirebilmesi içindir. Soket bağlantısız olduğundan, sunucunun bunu yapabilmesinin tek yolu istemcinin adına başvurmaktır.
    </para>
    <example>
     <screen>#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/un.h&gt;

#define SERVER  "/tmp/serversocket"
#define CLIENT  "/tmp/mysocket"
#define MAXMSG  512
#define MESSAGE "Yow!!! Are we having fun yet?!?"

int
main (void)
{
  extern int make_named_socket (const char *name);
  int sock;
  char message[MAXMSG];
  struct sockaddr_un name;
  size_t size;
  int nbytes;

  /* <replaceable>Soketi oluştur.</replaceable> */
  sock = make_named_socket (CLIENT);

  /* <replaceable>Sunucu soket adresini ilklendir.</replaceable> */
  name.sun_family = AF_LOCAL;
  strcpy (name.sun_path, SERVER);
  size = strlen (name.sun_path) + sizeof (name.sun_family);

  /* <replaceable>Veri katarını yolla.</replaceable> */
  nbytes = sendto (sock, MESSAGE, strlen (MESSAGE) + 1, 0,
                   (struct sockaddr *) &amp; name, size);
  if (nbytes &lt; 0)
    {
      perror ("sendto (client)");
      exit (EXIT_FAILURE);
    }

  /* <replaceable>Yanıt bekle.</replaceable> */
  nbytes = recvfrom (sock, message, MAXMSG, 0, NULL, 0);
  if (nbytes &lt; 0)
    {
      perror ("recfrom (client)");
      exit (EXIT_FAILURE);
    }

  /* <replaceable>Durumu bildir.</replaceable> */
  fprintf (stderr, "istemci: gelen ileti: %s\n", message);

  /* <replaceable>Temizlik.</replaceable> */
  remove (CLIENT);
  close (sock);
}
</screen>
    </example>
    <para>
     Veri katarı soket iletişiminin güvenilir olmadığı unutulmamalıdır. Bu örnekte, istemci yazılım, ileti sunucuya ulaşmazsa veya sunucunun yanıtı gelmezse sonsuza kadar bekler. Yazılımı sonlandırmak veya yeniden başlatmak çalıştırana bırakılmıştır. Daha özdevinimli bir çözüm ise <function>select</function> (<xref linkend="glibc-Waiting-for-I-O"/>) ile yanıt için zaman aşımı belirtmek ve bu süre sonunda iletiyi tekrar göndermek veya soketi kapatarak çıkmaktır.
    </para>
  </sect1>
 </chapter>

 <chapter xml:id="glibc-Inetd" userlevel="notoc">
  <?dbhtml stop-chunking?>
  <title><code>inetd</code> Artalan Süreci</title>
  <titleabbrev>Bir sunucu yazmak için en uygun yol <code>inetd</code> ile çalışmasını sağlamaktır.</titleabbrev>
  <para>
   Önceki bölümde kendi dinleme işlemini yapan bir sunucu yazılımınının nasıl yazıldığı anlatılmıştı. Bu tür bir sunucu bağlanacaklar için çalışıyor durumda olmalıdır.
  </para>
  <para>
   Bir İnternet portunda bir hizmet sunmanın diğer bir yolu ise bir artalan süreç yazılımı olan <command>inetd</command>'nin dinlemesidir. <command>inetd</command>, sürekli çalışan ve belirli portlardan gelecek iletiler için bekleyen bir yazılımdır. Bir ileti aldığında, bağlantıyı kabul eder (eğer soket tarzı bağlantı kabul ediyorsa) ve ilgili sunucu yazılımını çalıştırmak için <function>fork</function> ile bir alt süreç oluşturur. Port ve ilgili yazılımlar <filename>/etc/inetd.conf</filename> dosyasında tanımlanmalıdır.
  </para>
  <sect1 xml:id="glibc-Inetd-Servers">
   <title><code>inetd</code> Sunucuları</title>
   <para>
    <command>inetd</command> ile çalışacak bir sunucu yazmak oldukça basittir. Her seferinde birileri uygun porttan bağlantı isteğinde bulunur ve yeni bir sunucu süreci başlar. Bu durumda bağlantı zaten vardır; soket, sunucu sürecinde standart girdi ve çıktı tanıtıcısı (0 ve 1) olarak bulunmaktadır. Böylece sunucu yazılımı okuma ve yazma işlemlerine başlayabilir. Genelde yazılım sadece sıradan G/Ç imkanlarına ihtiyaç duyar; aslında, genel kullanıma yönelik, soketten bir şey anlamayan bir süzme yazılımı <command>inetd</command> ile bayt akımlı sunucu olarak çalışabilir.
   </para>
   <para>
    <command>inetd</command> aynı zamanda bağlantısız iletişim tarzlarını kullanan sunucular için de kullanılabilir. Bu sunucular için, <command>inetd</command> bağlantı kabul etmeye çalışmaz çünkü bağlantı imkanı yoktur. Sadece, 0 tanıtıcısından gelen veri katarı paketini okuyabilen sunucu yazılımını başlatır. Sunucu yazılımı bir isteği ele alıp sonra çıkabilir veya daha fazla istek gelmeden, yazması sağlanabilir. <command>inetd</command> yapılandırılırken sunucunun kullandığı bu iki teknikten biri belirtilmelidir.
   </para>
  </sect1>
  <sect1 xml:id="glibc-Configuring-Inetd">
   <title><code>inetd</code> Yapılandırması</title>
   <para>
    <filename>/etc/inetd.conf</filename> dosyası <command>inetd</command>'ye hangi portları dinleyeceğini ve bunlarda hangi sunucu yazılımlarını çalıştıracağını söyler. Normalde dosya içindeki her girdi bir satırdır, bunlar çoklu satırlara bölünmek istenirse girdinin ilk satırını boşlukla başlatmak gerekir. <code>#</code> ile başlayan satırlar açıklama satırlarıdır.
   </para>
   <para>
    Aşağıda <filename>/etc/inetd.conf</filename> dosyasındaki iki standart girdi görülmektedir:
   </para>
   <literallayout class="monospaced">ftp     stream  tcp     nowait  root    /libexec/ftpd   ftpd
talk    dgram   udp     wait    root    /libexec/talkd  talkd
</literallayout>
   <para>
    Her girdi aşağıdaki yapıdadır:
   </para>
   <literallayout class="monospaced"><replaceable>hizmet tarz protokol bekleme kullanıcı yazılım seçenekler</replaceable>
</literallayout>
   <para>
    <replaceable>hizmet</replaceable> alanı bu yazılımın hangi hizmeti desteklediğini söyler. Bu <filename>/etc/services</filename> içinde tanımlı hizmet isimlerinden biri olmalıdır. <command>inetd</command>, <replaceable>hizmet</replaceable>i bu girdi için hangi portun dinleneceğine karar vermek için kullanır.
   </para>
   <para>
    <replaceable>tarz</replaceable> ve <replaceable>protokol</replaceable> alanları soketi dinlemek için kullanılan iletişim tarzını ve protokolünü belirler. <replaceable>tarz</replaceable>, küçük harflere çevrilmiş ve başındaki <code>SOCK_</code> kaldırılmış, '<code>stream</code>' veya '<code>dgram</code>' gibi bir iletişim tarzı adı olmalıdır. <replaceable>protokol</replaceable>, <filename>/etc/protocols</filename> içinde listelenen protokollerden biri olmalıdır. Genelde protokol isimleri bayt akımlı bağlantılar için <code>tcp</code> ve güvensiz veri katarları için <code>udp</code>'dir.
   </para>
   <para>
    <replaceable>bekleme</replaceable> alanı ya <code>wait</code> ya da <code>nowait</code> olmalıdır. Eğer bağlantısız iletişim tarzı kullanılıyorsa ve sunucu başladığında gelen çoklu istekler ele alınıyorsa <code>wait</code> kullanılır. <command>inetd</command>'nin gelen her ileti veya istek için yeni bir süreç başlatması gerekiyorsa <code>nowait</code> kullanılır. <replaceable>tarz</replaceable> bağlantıları kullanıyorsa, <replaceable>bekleme</replaceable> alanı <code>nowait</code> olmalıdır.
   </para>
   <para>
    <replaceable>kullanıcı</replaceable> sunucunun hangi kullanıcı altında çalışması gerektiğidir. <command>inetd root</command> olarak çalışır, böylece çocuklarına istediği kullanıcı kimliğini verebilir. Yapılabilirse, <replaceable>kullanıcı</replaceable> için <command>root</command> kullanmamak en iyisidir; fakat bazı sunucular, örneğin Telnet ve FTP, kendisi için kullanıcı adı ve parola okur. Bu sunucuların ilk başta <command>root</command> olması gerekir böylece ağ üzerinden gelen verinin yönlendirdiği şekilde giriş yapabilir.
   </para>
   <para>
    <replaceable>seçenekler</replaceable> ile birlikte <replaceable>yazılım</replaceable> sunucuyu başlatacak komutu belirtir. <replaceable>yazılım</replaceable> çalıştırılabilir bir dosyanın tam dosya ismi olmalıdır. <replaceable>seçenekler</replaceable> boşluklarla ayrılmış herhangi sayıda sözcükten oluşur; bunlar <replaceable>yazılım</replaceable>'ın komut satırı seçenekleri olur. <replaceable>seçenekler</replaceable> içindeki ilk sözcüğün bağımsız değişken numarası sıfırdır ve bu yazılım isminin kendisidir (dizinsiz olarak).
   </para>
   <para>
    <filename>/etc/inetd.conf</filename> dosyası değiştirilirse, <command>inetd</command>'ye <varname>SIGHUP</varname> sinyali göndererek dosyayı tekrar okuması ve yeni içeriğe uyması söylenebilir. <uri xl:href="man1-ps"/> ile <command>inetd</command>'nin süreç kimliği (PID) saptanabilir.
   </para>
  </sect1>
 </chapter>
 <chapter xml:id="glibc-Socket-Options" userlevel="notoc">
  <?dbhtml stop-chunking?>
  <title>Socket Seçenekleri</title>
  <titleabbrev>Çeşitli düşük seviyeli soket seçenekleri.</titleabbrev>
  <para>
   <indexterm linkend="glibc-cp"><primary>soket seçenekleri</primary></indexterm>
   Bu bölümde soketlerin davranışlarını değiştiren çeşitli özelliklerin nasıl okunduğu veya ayarlandığı ve altındaki iletişim protokolleri anlatılmıştır.
  </para>
  <para>
   <indexterm linkend="glibc-cp"><primary>soket seçenek seviyesi</primary></indexterm>
   Bir soket seçeneği değiştirilirken seçeneğin hangi <wordasword>düzey</wordasword>e ait olduğunu belirtmek gerekir. Bu, özelliğin soket arayüzüne mi yoksa alt-seviye iletişim protokol arayüzüne mi etki edeceğini belirler.
  </para>
  <sect1 xml:id="glibc-Socket-Option-Functions">
   <title>Soket Seçenek İşlevleri</title>
   <titleabbrev>Soket seçeneklerini ayarlamak ve değerlerini almak için işlevler.</titleabbrev>
   <para>
    <indexterm linkend="glibc-pg"><primary>sys/socket.h</primary></indexterm>
    Burada soket seçeneklerini incelemek ve değiştirmek için kullanılan işlevlere yer verilmiştir. Bunlar &sys-socket.h; başlık dosyasında bildirilmiştir.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-getsockopt"><primary>getsockopt</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-getsockopt"><primary>soketler</primary><secondary>seçenekler</secondary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>getsockopt</function></csname>
     <csparam><type>int</type><parameter>socket</parameter></csparam>
     <csparam><type>int</type><parameter>level</parameter></csparam>
     <csparam><type>int</type><parameter>optname</parameter></csparam>
     <csparam><ptr>void</ptr><parameter>optval</parameter></csparam>
     <csparam><ptr>socklen_t</ptr><parameter>optlen-ptr</parameter></csparam>
    </csproto>
    <header>&sys-socket.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     <code>getsockopt</code> işlevi <parameter>socket</parameter> soketi için <parameter>level</parameter> seviyesindeki <parameter>optname</parameter> seçeneğinin değeriyle ilgili bilgi döndürür.
    </para>
    <para>
     Seçenek değeri <parameter>optval</parameter> ile gösterilen tampon içinde saklanır. İşlevi çağırmadan önce, tampon boyutunun *<parameter>optlen-ptr</parameter> ile verilmesi gerekir; dönüşte, tamponda gerçekte saklanan bilginin bayt sayısını içerecektir.
    </para>
    <para>
     Çoğu seçenek <parameter>optval</parameter> tamponunu tek bir <type>int</type> değer olarak yorumlar.
    </para>
    <para>
     <code>getsockopt</code> işlevinin başarı durumunda döndürdüğü değer <code>0</code>, başarısızlık durumunda <code>-1</code>'dir. Aşağıdaki <varname>errno</varname> hata durumları bu işlev için tanımlanmıştır:
    </para>
    <variablelist>
     <varlistentry>
      <term><code>EBADF</code></term>
      <listitem>
       <para>
        <parameter>socket</parameter> soketi geçerli bir dosya tanıtıcı değil.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>ENOTSOCK</code></term>
      <listitem>
       <para>
        <parameter>socket</parameter> dosya tanıtıcısı soket değil.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>ENOPROTOOPT</code></term>
      <listitem>
       <para>
        <parameter>optname</parameter> belirtilen <parameter>level</parameter> seviyesine duyarsız.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-setsockopt"><primary>setsockopt</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>setsockopt</function></csname>
     <csparam><type>int</type><parameter>socket</parameter></csparam>
     <csparam><type>int</type><parameter>level</parameter></csparam>
     <csparam><type>int</type><parameter>optname</parameter></csparam>
     <csparam><ptr>const&nbsp;void</ptr><parameter>optval</parameter></csparam>
     <csparam><type>socklen_t</type><parameter>optlen</parameter></csparam>
    </csproto>
    <header>&sys-socket.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     Bu işlev <parameter>socket</parameter> soketi için <parameter>level</parameter> seviyesinde <parameter>optname</parameter> soket seçeneğini etkinleştirmek kullanılır. Seçenek değeri <parameter>optlen</parameter> uzunluğundaki <parameter>optval</parameter> tamponunda aktarılır.
    </para>
   </csynopsis>
  </sect1>
  <sect1 xml:id="glibc-Socket-Level-Options">
   <title>Soket Seviye Seçenekleri</title>
   <titleabbrev>Soket seviye seçeneklerinin ayrıntıları.</titleabbrev>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-SOL_SOCKET"><primary>SOL_SOCKET</primary></indexterm>
    <csproto type="sabit">
     <csname><type>int</type><function>SOL_SOCKET</function></csname>
    </csproto>
    <header>&sys-socket.h;</header>
    <para>
     Bu sabit, bu bölümde açıklanan soket seviye seçeneklerini değiştirmek için <function>getsockopt</function> veya <function>setsockopt</function> işlevinde <parameter>level</parameter> bağımsız değişkeni olarak  kullanılır.
    </para>
   </csynopsis>
   <para>
    <indexterm linkend="glibc-pg"><primary>sys/socket.h</primary></indexterm>
    Aşağıda listesi verilen soket seviye seçeneklerinin isimleri &sys-socket.h; başlık dosyasında tanımlıdır.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-SO_DEBUG"><primary>SO_DEBUG</primary></indexterm>
    <csproto type="değişken">
     <csname><type>int</type><function>SO_DEBUG</function></csname>
    </csproto>
    <header>&sys-socket.h;</header>
    <para>
     Bu seçenek ilgili protokol modülleri içindeki hata ayıklama bilgileri kaydının etkinleştirilmesi ile ilgilidir. <type>int</type> türünde değer alır; sıfırdan farklı ise "evet" anlamına gelir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-SO_REUSEADDR"><primary>SO_REUSEADDR</primary></indexterm>
    <csproto type="değişken">
     <csname><type>int</type><function>SO_REUSEADDR</function></csname>
    </csproto>
    <header>&sys-socket.h;</header>
    <para>
     Bu seçenek <function>bind</function> (bkz, <xref linkend="glibc-Setting-Address"/>) işlevinin soket için yerel adreslerin tekrar kullanımına izin verip vermeyeceğini belirler. Bu özellik etkinleştirilirse, aynı Internet port numarasına sahip iki soket olur; fakat sistem bu iki aynı-isimli soketin İnternet ortamında karışıklık yaratacak şekilde kullanılmasına izin vermez. Bu özelliğin varoluş nedeni bazı yüksek seviyeli İnternet protokollerine dayanmaktadır, örneğin FTP, aynı port numarasının tekrar kullanımını gerektirmektedir.
    </para>
    <para>
     <type>int</type> türünde değer alır; sıfırdan farklı değer "evet" anlamına gelir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-SO_KEEPALIVE"><primary>SO_KEEPALIVE</primary></indexterm>
    <csproto type="değişken">
     <csname><type>int</type><function>SO_KEEPALIVE</function></csname>
    </csproto>
    <header>&sys-socket.h;</header>
    <para>
     Bu seçenek ilgili protokolün bağlantılı bir soketten iletinin belirli aralıklarla gönderip göndermeyeceğini belirler. Eğer karşıdaki soket bu iletilere yanıt vermezse, bağlantı kesilmiş kabul edilir. <type>int</type> türünde değer alır; sıfırdan farklı değer "evet" anlamına gelir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-SO_DONTROUTE"><primary>SO_DONTROUTE</primary></indexterm>
    <csproto type="değişken">
     <csname><type>int</type><function>SO_DONTROUTE</function></csname>
    </csproto>
    <header>&sys-socket.h;</header>
    <para>
     Bu seçenek giden iletilerin normal ileti yönlendirme imkanlarını devre dışı bırakıp bırakmayacağını belirler. Eğer belirtilirse, iletiler doğrudan ağ arayüzüne gönderilir. <type>int</type> türünde değer alır; sıfırdan farklı değer "evet" anlamına gelir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-SO_LINGER"><primary>SO_LINGER</primary></indexterm>
    <csproto type="değişken">
     <csname><type>struct&nbsp;linger</type><function>SO_LINGER</function></csname>
    </csproto>
    <header>&sys-socket.h;</header>
    <para>
     Bu seçenek güvenli teslim garantisi veren bir soketin bağlantısı kesilirse ve hala aktarılmamış iletiler varsa ne olacağını belirler; bkz. <xref linkend="glibc-Closing-a-Socket"/>. <type>struct&nbsp;linger</type> türünde değer alır.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-tp" xml:id="glibc-tp-linger"><primary sortas="linger">struct&nbsp;linger</primary></indexterm>
    <csproto type="veri türü">
     <csname><type>struct</type><function>linger</function></csname>
    </csproto>
    <header>&sys-socket.h;</header>
    <para>
     Bu yapı aşağıdaki üyelere sahiptir:
    </para>
    <glosslist>
     <glossentry>
      <glossterm>
       <type>int&nbsp;</type><structfield>l_onoff</structfield>
      </glossterm>
      <glossdef>
       <para>
        Mantıksal değer olarak yorumlanır. Sıfırdan farklıysa, <function>close</function> veri aktarılıncaya veya zaman aşımına uğrayıncaya kadar engellenir.
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm>
       <type>int&nbsp;</type><structfield>l_linger</structfield>
      </glossterm>
      <glossdef>
       <para>
        Zaman aşımını saniye cinsinden belirtir.
       </para>
      </glossdef>
     </glossentry>
    </glosslist>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-SO_BROADCAST"><primary>SO_BROADCAST</primary></indexterm>
    <csproto type="değişken">
     <csname><type>int</type><function>SO_BROADCAST</function></csname>
    </csproto>
    <header>&sys-socket.h;</header>
    <para>
     Bu seçenek veri katarlarının soketten yayınlanabilmesi ile ilgilidir. <type>int</type> türünde değer alır; sıfırdan farklı değer "evet" anlamına gelir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-SO_OOBINLINE"><primary>SO_OOBINLINE</primary></indexterm>
    <csproto type="değişken">
     <csname><type>int</type><function>SO_OOBINLINE</function></csname>
    </csproto>
    <header>&sys-socket.h;</header>
    <para>
     Eğer bu seçenek belirtilirse, soketten alınan sıra dışı veri normal girdi sırasına konulur. Bu <varname>MSG_OOB</varname> bayrağını belirtmeden <function>read</function> veya <function>recv</function> ile okuma yapmaya izin verir. Bkz. <xref linkend="glibc-Out-of-Band-Data"/>. <type>int</type> türünde değer alır; sıfırdan farklı değer "evet" anlamına gelir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-SO_SNDBUF"><primary>SO_SNDBUF</primary></indexterm>
    <csproto type="değişken">
     <csname><type>size_t</type><function>SO_SNDBUF</function></csname>
    </csproto>
    <header>&sys-socket.h;</header>
    <para>
     Bu seçenek çıktı için kullanılan tamponun boyutunu getirir veya belirtir. Bayt cinsinden olan <type>size_t</type> türündedir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-SO_RCVBUF"><primary>SO_RCVBUF</primary></indexterm>
    <csproto type="değişken">
     <csname><type>size_t</type><function>SO_RCVBUF</function></csname>
    </csproto>
    <header>&sys-socket.h;</header>
    <para>
     Bu seçenek girdi için kullanılan tamponun boyutunu getirir veya belirtir. Bayt cinsinden olan <type>size_t</type> türündedir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-SO_STYLE"><primary>SO_STYLE</primary></indexterm>
    <csproto type="değişken">
     <csname><type>int</type><function>SO_STYLE</function></csname>
    </csproto>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-SO_TYPE"><primary>SO_TYPE</primary></indexterm>
    <csproto type="değişken">
     <csname><type>int</type><function>SO_TYPE</function></csname>
    </csproto>
    <header>&sys-socket.h;</header>
    <para>
     Bu seçenek sadece <function>getsockopt</function> ile kullanılabilir. Soketin iletişim tarzını getirmek için kullanılır. <code>SO_TYPE</code> eski ismidir ve <code>SO_STYLE</code> GNU için tercih edilen isimdir. <type>int</type> türünde değer alır ve değeri bir iletişim tarzını gösterir; bkz. <xref linkend="glibc-Communication-Styles"/>.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-SO_ERROR"><primary>SO_ERROR</primary></indexterm>
    <csproto type="değişken">
     <csname><type>int</type><function>SO_ERROR</function></csname>
    </csproto>
    <header>&sys-socket.h;</header>
    <para>
     Bu seçenek sadece <function>getsockopt</function> ile kullanılabilir. Soketin hata durumunu sıfırlamak için kullanılır. Önceki hata durumunu gösteren <type>int</type> türünde bir değerdir.
    </para>
   </csynopsis>
  </sect1>
 </chapter>

 <chapter xml:id="glibc-Networks-Database">
  <title>Ağ İsimleri Veritabanı</title>
  <titleabbrev>Ağ isimleri veritabanına erişim.</titleabbrev>
  <para>
   <indexterm linkend="glibc-cp"><primary>ağ veritabanı</primary></indexterm>
   <indexterm linkend="glibc-cp"><primary>ağ numaralarını ağ isimlerine dönüştürme</primary></indexterm>
   <indexterm linkend="glibc-cp"><primary>ağ isimlerini ağ numaralarına dönüştürme</primary></indexterm>
   <indexterm linkend="glibc-pg"><primary sortas="etc/networks">/etc/networks</primary></indexterm>
   <indexterm linkend="glibc-pg"><primary>netdb.h</primary></indexterm>
   Birçok sistem bilinen ağ isimlerinin listesini kaydederek bunları sistem geliştiricisine sunan bir veritabanı ile beraber gelir. Bu bilgi genellikle <filename>/etc/networks</filename> dosyası içerisinde veya eşdeğer bir isim sunucusunda tutulur. Bu veritabanı <uri xl:href="man8-route"/> gibi yönlendirme yazılımları için kullanışlıdır. Ancak ağ üzerinde basitçe haberleşen yazılımlar için değildir. Bu veritabanına erişmek için gerekli işlevler &netdb.h; başlık dosyasında bildirilmiştir.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-tp" xml:id="glibc-tp-netent"><primary sortas="netent">struct&nbsp;netent</primary></indexterm>
   <csproto type="veri türü">
    <csname><type>struct</type><function>netent</function></csname>
   </csproto>
   <header>&netdb.h;</header>
   <para>
    Bu veri türü ağ veritabanındaki girdi bilgilerininin gösterimi için kullanılır. Aşağıdaki üyelere sahiptir:
   </para>
   <glosslist>
    <glossentry>
     <glossterm>
      <type>char&nbsp;*</type><structfield>n_name</structfield>
     </glossterm>
     <glossdef>
      <para>
       "Resmi" ağ ismidir.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <type>char&nbsp;**</type><structfield>n_aliases</structfield>
     </glossterm>
     <glossdef>
      <para>
       Bunlar bir dizgeler dizisi olarak ağ takma adlarıdır. Diziyi boş gösterici sonlandırır.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <type>int&nbsp;</type><structfield>n_addrtype</structfield>
     </glossterm>
     <glossdef>
      <para>
       Bu ağ numarasının türüdür; İnternet ağları için herzaman <varname>AF_INET</varname>'e eşittir.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <type>unsigned&nbsp;long&nbsp;int&nbsp;</type><structfield>n_net</structfield>
     </glossterm>
     <glossdef>
      <para>
       Bu ağ numarasıdır. Ağ numaraları <link linkend="glibc-Byte-Order">konak bayt sırası</link> ile döndürülür.
      </para>
     </glossdef>
    </glossentry>
   </glosslist>
  </csynopsis>
  <para>
   Ağ veritabanında belirli bir ağ hakkında arama yapıp bilgi edinmek için  <function>getnetbyname</function> veya <function>getnetbyaddr</function> işlevi kullanılır. Bilgi duruk olarak tahsis edilmiş bir yapıda döner; saklamak gerekiyorsa bilginin kopyalanması gerekir.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-getnetbyname"><primary>getnetbyname</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-getnetbyname"><primary>ağ veritabanı</primary><secondary>bilgi alınması</secondary></indexterm>
   <csproto type="işlev">
    <csname><ptr>struct&nbsp;netent</ptr><function>getnetbyname</function></csname>
    <csparam><ptr>const&nbsp;char</ptr><parameter>name</parameter></csparam>
   </csproto>
   <header>&netdb.h;</header>
   <conceptlist>
    <concept>&mtunsafe; &race;<code linkend="glibc-safety-identifier">:netbyname</code> &env; &locale;</concept>
    <concept>&asunsafe; &dlopen; &plugin; &heap; &lock;</concept>
    <concept>&acunsafe; &corrupt; &lock; &fd; &mem;</concept>
   </conceptlist>
   <para>
    <code>getnetbyname</code> işlevi <parameter>name</parameter> adlı ağ hakkında bilgi döndürür. Öyle bir ağ yoksa boş gösterici döndürür.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-getnetbyaddr"><primary>getnetbyaddr</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-getnetbyaddr"><primary>ağ veritabanı</primary><secondary>bilgi alınması</secondary></indexterm>
   <csproto type="işlev">
    <csname><ptr>struct&nbsp;netent</ptr><function>getnetbyaddr</function></csname>
    <csparam><type>uint32_t</type><parameter>net</parameter></csparam>
    <csparam><type>int</type><parameter>type</parameter></csparam>
   </csproto>
   <header>&netdb.h;</header>
   <conceptlist>
    <concept>&mtunsafe; &race;<code linkend="glibc-safety-identifier">:netbyaddr</code> &locale;</concept>
    <concept>&asunsafe; &dlopen; &plugin; &heap; &lock;</concept>
    <concept>&acunsafe; &corrupt; &lock; &fd; &mem;</concept>
   </conceptlist>
   <para>
    <code>getnetbyaddr</code> işlevi <parameter>type</parameter> türünde ve <parameter>net</parameter> numarasındaki ağ hakkında bilgi döndürür. İnternet ağları için <parameter>type</parameter> bağımsız değişkenine  <varname>AF_INET</varname> değeri belirtilmelidir.
   </para>
   <para>
    İşlev öyle bir ağ yoksa boş gösterici döndürür.
   </para>
  </csynopsis>
  <para>
   Ayrıca <function>setnetent</function>, <function>getnetent</function> ve <function>endnetent</function> kullanarak ağ veritabanı taranabilir. Bu işlevleri kullanırken dikkatli olunmalıdır, çünkü bunlar evresel işlevler değildir.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-setnetent"><primary>setnetent</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-setnetent"><primary>ağ veritabanı</primary><secondary>açılması</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>void</type><function>setnetent</function></csname>
    <csparam><type>int</type><parameter>stayopen</parameter></csparam>
   </csproto>
   <header>&netdb.h;</header>
   <conceptlist>
    <concept>&mtunsafe; &race;<code linkend="glibc-safety-identifier">:netent</code> &env; &locale;</concept>
    <concept>&asunsafe; &dlopen; &plugin; &heap; &lock;</concept>
    <concept>&acunsafe; &corrupt; &lock; &fd; &mem;</concept>
   </conceptlist>
   <para>
    Bu işlev ağ veritabanını açar ve sayacı başa getirir.
   </para>
   <para>
    <parameter>stayopen</parameter> bağımsız değişkeni sıfır ise bir bayrak etkin olur, böylece sonraki <function>getnetbyname</function> veya <function>getnetbyaddr</function> işlev çağrıları veritabanını kapatmaz (normalde olması gerektiği gibi). Eğer bu işlevleri çok kez çağrılıyorsa, her çağrıda veritabanını tekrar açmak gerekmez ve daha verimli sonuç elde edilir.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-getnetent"><primary>getnetent</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-getnetent"><primary>ağ veritabanı</primary><secondary>bilgi alınması</secondary></indexterm>
   <csproto type="işlev">
    <csname><ptr>struct&nbsp;netent</ptr><function>getnetent</function></csname>
    <csparam><void/></csparam>
   </csproto>
   <header>&netdb.h;</header>
   <conceptlist>
    <concept>&mtunsafe; &race;<code linkend="glibc-safety-identifier">:netent</code> &race;<code linkend="glibc-safety-identifier">:netentbuf</code> &env; &locale;</concept>
    <concept>&asunsafe; &dlopen; &plugin; &heap; &lock;</concept>
    <concept>&acunsafe; &corrupt; &lock; &fd; &mem;</concept>
   </conceptlist>
   <para>
    Bu işlev ağ veritabanındaki sonraki girdiyi döndürür. Eğer sonraki girdi yoksa boş gösterici döndürür.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-endnetent"><primary>endnetent</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-endnetent"><primary>ağ veritabanı</primary><secondary>kapatılması</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>void</type><function>endnetent</function></csname>
    <csparam><void/></csparam>
   </csproto>
   <header>&netdb.h;</header>
   <conceptlist>
    <concept>&mtunsafe; &race;<code linkend="glibc-safety-identifier">:netent</code> &env; &locale;</concept>
    <concept>&asunsafe; &dlopen; &plugin; &heap; &lock;</concept>
    <concept>&acunsafe; &corrupt; &lock; &fd; &mem;</concept>
   </conceptlist>
   <para>
    Bu işlev ağ veritabanını kapatır.
   </para>
  </csynopsis>
 </chapter>
</part>
