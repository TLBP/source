<?xml version="1.0" encoding="UTF-8"?>
<!-- ********************************************************************
        glibc/ch12.xml,v2.36, GFDL,LGPL, NBB, 2023
     ******************************************************************** -->
<part xml:id="glibc-I-O-on-Streams" userlevel="longtoc">
 <title>Akımlar Üzerinde Giriş/Çıkış</title>
 <titleabbrev>Yüksek seviyeli, taşınabilir G/Ç oluşumları.</titleabbrev>
 <preliminary>
  <para>
   Bu oylumda akımları oluşturmak ve üzerlerinde giriş ve çıkış işlemleri yapmak için kullanılan işlevler anlatılmıştır. <xref linkend="glibc-I-O-Overview"/> oylumunda değinildiği gibi, akım bir dosya, aygıt ya da sürece iletişim kanalı sağlayan yüksek seviyeli ve tamamen soyut bir kavramdır.
  </para>
 </preliminary>
 <chapter xml:id="glibc-Streams">
  <title>Akımlar</title>
  <titleabbrev>Akımı ifade eden veri türleri hakkında.</titleabbrev>
  <para>
   Tarihsel sebeplerle, bir akımı ifade eden C veri yapısının türü &quot;stream&quot; değil <type>FILE</type>'dır. Kütüphane işlevlerinin çoğu <type>FILE *</type> türü nesnelerle ilgilendiğinden kimi zaman <wordasword>dosya göstericisi</wordasword> deyimi "akım" anlamında kullanılmıştır. Bu, birçok C kitabında terminoloji bakımından talihsiz sayılabilecek karışıklıklara yol açmıştır. Bu kılavuzda "dosya" ve "akım" terimleri teknik duyarlılıkla ve dikkatle kullanılmıştır.
   <indexterm linkend="glibc-cp"><primary>dosyalar</primary><secondary>dosya göstericisi</secondary></indexterm>
   <indexterm linkend="glibc-cp"><primary>dosyalar</primary><secondary>akımlar</secondary></indexterm>
   <indexterm linkend="glibc-pg"><primary>stdio.h</primary></indexterm>
   <type>FILE</type> türü &stdio.h; başlık dosyasında bildirilmiştir.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-tp" xml:id="glibc-tp-FILE"><primary>FILE</primary></indexterm>
   <csproto type="veri türü">
    <csname><function>FILE</function></csname>
   </csproto>
   <header>&stdio.h;</header>
   <para>
    Akım nesneleri için kullanılan veri türüdür. <code>FILE</code> türünden bir nesne, ilişkilendirildiği dosyayla yapılan bağlantı hakkında dosya konum belirteci ve tamponlama bilgisi gibi şeyleri içeren dahili durum bilgisinin tamamını tutar. Her akım ayrıca <function>ferror</function> ve <function>feof</function> işlevleri ile sınanabilen hata ve dosya sonu durum belirteçlerine de sahiptir. Bkz.  <xref linkend="glibc-EOF-and-Errors"/>.
   </para>
  </csynopsis>
  <para>
   <type>FILE</type> türünden nesneler dahili olarak giriş/çıkış kütüphanesi işlevleri tarafından ayrılır ve yönetilir. <type>FILE</type> türünden nesneler oluşturulmaya çalışılmamalıdır. Yazılımlar bu nesnelerin kendileri ile değil sadece göstericileri (<type>FILE *</type> değerleri) ile çalışılabilir.
  </para>
 </chapter>
 <chapter xml:id="glibc-Standard-Streams">
  <title>Standart Akımlar</title>
  <titleabbrev>Standart girdi ve çıktı aygıtlarına akım oluşturmak.</titleabbrev>
  <para>
   <indexterm linkend="glibc-cp"><primary>standart akımlar</primary></indexterm>
   <indexterm linkend="glibc-cp"><primary>akımlar</primary><secondary>standart</secondary></indexterm>
   Bir yazılım, <function>main</function> işlevi çağrıldığı anda üç tane önceden tanımlanmış ve kullanıma hazır akıma sahip olur. Bunlar süreç için oluşturulmuş "standart" giriş ve çıkış kanallarıdır.
  </para>
  <para>
   Bu akımlar &stdio.h; başlık dosyasında bildirilmiştir.
   <indexterm linkend="glibc-pg"><primary>stdio.h</primary></indexterm>
   <dicterm><english>stdin</english><turkish>standart girdi</turkish></dicterm>
   <dicterm><english>stdout</english><turkish>standart çıktı</turkish></dicterm>
   <indexterm linkend="glibc-cp"><primary>standart girdi</primary></indexterm>
  </para>
  <csynopsis>
   <indexterm linkend="glibc-vr" xml:id="glibc-vr-stdin"><primary>stdin</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-stdin"><primary>standart girdi</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-s-stdin"><primary>akımlar</primary><secondary>standart girdi</secondary></indexterm>
   <csproto type="değişken">
    <csname><ptr>FILE</ptr><varname>stdin</varname></csname>
   </csproto>
   <header>&stdio.h;</header>
   <para>
    Yazılım için normal giriş kaynağı olan <wordasword>standart girdi</wordasword> akımıdır.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-vr" xml:id="glibc-vr-stdout"><primary>stdout</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-stdout"><primary>standart çıktı</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-s-stdout"><primary>akımlar</primary><secondary>standart çıktı</secondary></indexterm>
   <csproto type="değişken">
    <csname><ptr>FILE</ptr><varname>stdout</varname></csname>
   </csproto>
   <header>&stdio.h;</header>
   <para>
    Yazılım için normal çıktı kaynağı olan <wordasword>standart çıktı</wordasword> akımıdır.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-vr" xml:id="glibc-vr-stderr"><primary>stderr</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-stderr"><primary>standart hata</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-s-stderr"><primary>akımlar</primary><secondary>standart hata</secondary></indexterm>
   <csproto type="değişken">
    <csname><ptr>FILE</ptr><varname>stderr</varname></csname>
   </csproto>
   <header>&stdio.h;</header>
   <para>
    Yazılım tarafından hata iletileri ve tanılama amacıyla kullanılan <wordasword>standart hata</wordasword> akımıdır.
   </para>
  </csynopsis>
  <para>
   GNU sisteminde kabuk tarafından sağlanan ardışık komutlar ve yönlendirme oluşumları kullanılarak bu akımlara karşılık gelen süreçler ve dosyalar belirlenebilir. (Kabuklarda bu oluşumları gerçekleştirmekte kullanılan ilkeller <xref linkend="glibc-File-System-Interface"/> bölümünde açıklanmıştır.) Diğer işletim sistemlerinin çoğu benzer mekanizmaları sağlar ancak kullanımı ile ilgili ayrıntılar değişiklik gösterir.
  </para>
  <para>
   &glibc;nde <varname>stdin</varname>, <varname>stdout</varname> ve <varname>stderr</varname> normal değişkenlerdir ve diğer değişkenler gibi onlara da değer atanabilir.
  </para>
  <example><title>bir dosyanın standart çıktıya yönlendirilmesi</title>
<screen>fclose (stdout);
stdout = fopen ("standart-cikti-dosyasi", "w");
</screen>
  </example>
  <note>
   <para>
    Diğer sistemlerde <varname>stdin</varname>, <varname>stdout</varname> ve <varname>stderr</varname> normal yoldan bir şeyler atayamayacağınız  makrolardır. Ancak <function>freopen</function> işlevi onların kapatılması ve yeniden açılması etkilerini elde etmek için kullanılabilir. Bkz. <xref linkend="glibc-Opening-Streams"/>.
   </para>
  </note>
  <para>
   Üç akım; <varname>stdin</varname>, <varname>stdout</varname> ve <varname>stderr</varname> sürecin başlangıcında yönlenimsiz değildir (Bkz. <xref linkend="glibc-Streams-and-I18N"/>).
  </para>
 </chapter>
 <chapter xml:id="glibc-Opening-Streams">
  <title>Akımların Açılması</title>
  <titleabbrev>Bir dosyayla konuşmak için akım nasıl oluşturulur.</titleabbrev>
  <para>
   Bir dosyanın <function>fopen</function> işlevi ile açılması yeni bir akım ve bu akım ile dosya arasında bağlantı oluşturur. Bu yeni dosya oluşturulmasına sebep olabilir.
  </para>
  <para>
   <indexterm linkend="glibc-pg"><primary>stdio.h</primary></indexterm>
   Bu kısımda açıklanan herşey &stdio.h; başlık dosyasında  bildirilmiştir.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-fopen"><primary>fopen</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-fopen"><primary>akımlar</primary><secondary>açılması</secondary></indexterm>
   <csproto type="işlev">
    <csname><ptr>FILE</ptr><function>fopen</function></csname>
    <csparam><ptr>const&#160;char</ptr><parameter>filename</parameter></csparam>
    <csparam><ptr>const&#160;char</ptr><parameter>opentype</parameter></csparam>
   </csproto>
   <header>&stdio.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&asunsafe; &heap; &lock;</concept>
    <concept>&acunsafe; &mem; &fd; &lock;</concept>
   </conceptlist>
   <para>
    <code>fopen</code> işlevi, <parameter>filename</parameter> dosyasına G/Ç için bir akım açar ve bu akıma gösterici ile döner.
   </para>
   <para>
    <parameter>opentype</parameter> bağımsız değişkeni dosyanın nasıl açılacağını ve sonuçlanan akımın özniteliklerini belirtmekte kullanılan bir dizgedir. Aşağıdaki dizgelerden biri ile başlamalıdır:
   </para>
   <variablelist>
    <varlistentry>
     <term>'<code>r</code>'</term>
     <listitem>
      <para>
       Mevcut bir dosyayı salt-okunur olarak açar.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>'<code>w</code>'</term>
     <listitem>
      <para>
       Dosyayı sadece yazmak için açar. Dosya zaten varsa içeriği silinir. Aksi takdirde yeni bir dosya oluşturulur.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>'<code>a</code>'</term>
     <listitem>
      <para>
       Bir dosyayı sadece sonuna yazmak için açar. Dosya zaten varsa, içeriği değiştirilmez ve akıma yapılan çıktı dosyanın sonuna eklenir. Aksi takdirde yeni bir dosya oluşturulur.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>'<code>r+</code>'</term>
     <listitem>
      <para>
       Bir dosyayı oku-yaz olarak açar. Dosyanın içeriği değiştirilmez ve konumlayıcı dosyanın başına yerleştirilir.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>'<code>w+</code>'</term>
     <listitem>
      <para>
       Bir dosyayı oku-yaz olarak açar. Dosya zaten varsa içeriği silinir. Aksi takdirde yeni bir dosya oluşturulur.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>'<code>a+</code>'</term>
     <listitem>
      <para>
       Dosyayı hem okumak hem de eklemek için açar ya da oluşturur. Dosya zaten varsa içeriği değiştirilmez. Aksi takdirde yeni bir dosya oluşturulur. Dosya konumlayıcı okumak için dosyanın başına konumlansa da çıktı daima dosyanın sonuna eklenir.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    Görüldüğü gibi, ‘<filename>+</filename>’ imi bir akımın hem girdi hem de çıktı yapabilmesini sağlar. Böyle bir akımı kullanırken <function>fflush</function> çağrısı (Bkz. <xref linkend="glibc-Stream-Buffering"/>) yapmalı ya da okumadan yazmaya veya yazmadan okumaya geçerken <function>fseek</function> (Bkz. <xref linkend="glibc-File-Positioning"/>) gibi bir dosya konumlama işlevine çağrı yapılmalıdır. Aksi takdirde, dahili tamponlar olması gerektiği gibi boşaltılamaz. &glibc; için böyle bir sınırlama yoktur; bir akım üzerinde okuma ve yazma işlemleri istenen sırada yapılabilir.
   </para>
   <para>
    Bunlardan sonra çağrı için bayrakları belirtmek amacıyla ek karakterler kullanılabilir. Daima önce kip (‘<filename>r</filename>’, ‘<filename>w+</filename>’, vs.) yerleştirilir; bu tüm sistemler tarafından anlaşılacağı garanti edilen tek parçadır.
   </para>
   <para>
     &glibc; <parameter>opentype</parameter> bağımsız değişkeninde kullanmak için ek karakterler tanımlar:
    </para>
   <variablelist>
    <varlistentry>
     <term>'<code>c</code>'</term>
     <listitem>
      <para>
       G/Ç işlevleri devre dışı bırakıldığında dosya silinerek açılır.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>'<code>e</code>'</term>
     <listitem>
      <para>
       <code>exec…</code> işlevlerinden herhangi biri kullanılırsa, ilgili dosya tanıtıcı kapatılır (bkz. <xref linkend="glibc-Executing-a-File"/>). (Bu, o tanıtıcıya <varname>FD_CLOEXEC</varname> atamaya eşdeğerdir.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>'<code>m</code>'</term>
     <listitem>
      <para>
       Dosya açılır ve <function>mmap</function> kullanılarak erişilir. Bu, yalnızca okumak için açılan dosyalarda desteklenir.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>'<code>x</code>'</term>
     <listitem>
      <para>
       Yeni bir dosya oluşturmakta ısrarcı olunur; <parameter>filename</parameter> zaten varsa, <code>fopen</code> onu açmak yerine başarısız olur. ‘<filename>x</filename>’ kullanılırsa, mevcut dosyanın bozulmayacağı garanti edilir. Bu,  <function>open</function> işlevinin <varname>O_EXCL</varname> erişim kipiyle kullanımına eşdeğerdir. Bkz. <xref linkend="glibc-Opening-and-Closing-Files"/>"
      </para>
      <para>
       '<code>x</code>' değiştiricisi ISO C11'in bir parçası olup dosyanın özel erişimle oluşturulduğunu belirtir; &glibc;nde <varname>O_EXCL</varname> erişim kipine eşdeğerdir.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    <parameter>opentype</parameter> bağımsız değişkenindeki '<code>b</code>' karakterinin standart bir anlamı vardır; metin akımı yerine ikil akım isteğinde bulunur.  Fakat POSIX sistemlerinde (GNU dahil) bu bir fark oluşturmaz. <code>+</code> ve '<code>b</code>' birlikte belirtilirse, herhangi bir sırada yazılabilir. Bkz. <xref linkend="glibc-Binary-Streams"/>.
   </para>
   <para>
    <indexterm linkend="glibc-cp"><primary>akım yönlenimi</primary></indexterm>
    <indexterm linkend="glibc-cp"><primary>akımlar</primary><secondary>yönlenim</secondary></indexterm>
    <parameter>opentype</parameter> bağımsız değişkeni <code>,ccs=</code><replaceable>DİZGE</replaceable> içeriyorsa, buradaki <replaceable>DİZGE</replaceable> bir kodlu karakter kümesinin ismi olarak ele alınır ve <code>fopen</code> işlevi, <replaceable>DİZGE</replaceable> karakter kümesi ile ilgili dönüşümlerin uygun dönüştürme işlevleriyle dahili olarak yapılabilmesi için, bu akımı geniş yönlenimli olarak imler. Her akım normalde ilk açıldığında yönlenimsizdir ve yönlenime ilk dosya işleminde karar verilir. Eğer ilk işlem bir geniş karakter işlemiyse, akım sadece geniş yönlenimli olarak imlenmez ayrıca yerelin kodlu karakter kümesine uygun dönüşüm işlevleri de yüklenir. Artık bu noktadan sonra yerelin seçildiği <varname>LC_CTYPE</varname> sınıfı değiştirilse bile bu değişmez.
   </para>
   <para>
    <parameter>opentype</parameter> bağımsız değişkeninde başka karakterler varsa bunlar yok sayılır. Bunlar diğer sistemler için anlamlı olabilir.
   </para>
   <para>
    Açma işlemi başarısız olursa <code>fopen</code> boş gösterici ile döner.
   </para>
   <para>
    Kaynak dosyalar 32 bitlik bir makinede <code>_FILE_OFFSET_BITS == 64</code> ile derlendiğinde büyük dosya sistemi arayüzü eski arayüzle şeffaf olarak değiştirildiğinden bu işlev için <function>fopen64</function> tanımı kullanılır.
   </para>
  </csynopsis>
  <para>
   Aynı dosya için aynı anda açılmış çok sayıda akım (ya da dosya tanıtıcı) olabilir. Sadece girdi yapılacaksa bu doğru dürüst çalışır ama çıktı akımları da varsa dikkatli olmak gerekir. Bkz. <xref  linkend="glibc-Stream-Descriptor-Precautions"/>. Bu durum, akımlar tek süreç tarafından da açılsa, çok sayıda süreç tarafından da açılsa hemen hemen aynıdır. Aynı anda erişimden kaçınmak için dosya kilitleme oluşumları yararlı olabilir. Bkz. <xref linkend="glibc-File-Locks"/>.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-fopen64"><primary>fopen64</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-fopen64"><primary>akımlar</primary><secondary>açılması</secondary></indexterm>
   <csproto type="işlev">
    <csname><ptr>FILE</ptr><function>fopen64</function></csname>
    <csparam><ptr>const&#160;char</ptr><parameter>filename</parameter></csparam>
    <csparam><ptr>const&#160;char</ptr><parameter>opentype</parameter></csparam>
   </csproto>
   <header>&stdio.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&asunsafe; &heap; &lock;</concept>
    <concept>&acunsafe; &mem; &fd; &lock;</concept>
   </conceptlist>
   <para>
    Bu işlev <function>fopen</function> işlevine benzer ama <function>open64</function> işlevi kullanılarak açılan akıma gösterici ile döner. Diğer yandan bu akım 32 bitlik makineler üzerinde  <literal>2</literal><superscript>31</superscript> bayttan büyük dosyalar üzerinde bile çalışır.
   </para>
   <note>
    <para>
     Dönen gösterici yine <type>FILE *</type> türünde olacaktır. Çünkü LFS arayüzü için özel bir <type>FILE</type> türü yoktur.
    </para>
   </note>
   <para>
    Kaynak dosyaları 32 bitlik bir makine üzerinde <code>_FILE_OFFSET_BITS == 64</code> ile derlenirse bu işlev <function>fopen</function> ismi ile kullanılabilir yani eski arayüz ile şeffaf olarak yer değiştirir.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-vr" xml:id="glibc-vr-FOPEN_MAX"><primary>FOPEN_MAX</primary></indexterm>
   <csproto type="makro">
    <csname><type>int</type><function>FOPEN_MAX</function></csname>
   </csproto>
   <header>&stdio.h;</header>
   <para>
    Bu makronun değeri gerçeklenimin aynı anda açık olmasını garanti ettiği en düşük akım sayısına karşılık gelen bir sabit ifadesidir. Bu değerden daha fazla sayıda akım açılabilir ancak bu garanti edilmez. Bu sabitin değeri en az sekizdir ve üç standart akımı da (<varname>stdin</varname>, <varname>stdout</varname> ve <varname>stderr</varname>) içerir. POSIX.1 sistemlerde  bu değer <varname>OPEN_MAX</varname> makrosu tarafından belirlenir. Bkz. <xref linkend="glibc-General-Limits"/>. BSD ve GNU'da ise <varname>RLIMIT_NOFILE</varname> öz kaynak sınırıyla belirlenir. Bkz. <xref linkend="glibc-Limits-on-Resources"/>.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-freopen"><primary>freopen</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-freopen"><primary>akımlar</primary><secondary>kapatıp açılması</secondary></indexterm>
   <csproto type="işlev">
    <csname><ptr>FILE</ptr><function>freopen</function></csname>
    <csparam><ptr>const&#160;char</ptr><parameter>filename</parameter></csparam>
    <csparam><ptr>const&#160;char</ptr><parameter>opentype</parameter></csparam>
    <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
   </csproto>
   <header>&stdio.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&asunsafe; &corrupt;</concept>
    <concept>&acunsafe; &corrupt; &fd;</concept>
   </conceptlist>
   <para>
    Bu işlev, <function>fclose</function> ve <function>fopen</function> işlevlerinin bir birleşimi gibidir. Önce <parameter>stream</parameter> ile gösterilen akımı kapatır, kapatırken oluşan hatalar yok sayılır. (Hataların yok sayılmasından dolayı, akıma bir çıktılama yapılmışsa çıktı akımı üzerinde <function>freopen</function> kullanılmamalıdır.) Sonra da <parameter>filename</parameter> isimli dosyayı <function>fopen</function> işlevindeki türlerden biri olarak <parameter>opentype</parameter> kipinde açar ve aynı <parameter>stream</parameter> nesnesi ile ilişkilendirir.
   </para>
   <para>
    İşlem başarısız olursa boş gösterici döner; aksi takdirde işlev <parameter>stream</parameter> ile döner. Linux'ta, <code>freopen</code> çağrılmadan önce çekirdek yapısı eski dosya tanıtıcı için tamamen ilklendirilmediğinde, <code>freopen</code> başarısız olabilir ve <varname>errno</varname> değişkenine <varname>EBUSY</varname> atayabilir. Bu, yalnızca çok evreli yazılımlarda, iki evre aynı dosya tanıtıcı numarasını tahsis etmek için yarıştığında ortaya çıkabilir. Bu yarış olasılığını önlemek için, ilgili <type>FILE</type> dosya tanıtıcısını kapatmak amacıyla <function>close</function> kullanılmamalıdır; ya dosya açıkken <code>freopen</code> kullanılmalı ya da yeni bir dosya tanıtıcı tahsisi için <function>open</function> ve ardından <function>dup2</function> kullanılmalıdır.
   </para>
   <para>
    <code>freopen</code> işlevi geleneksel olarak <varname>stdin</varname> gibi standart akımlara seçilen bir dosyayla bağlanmak için kullanılır. Bu, standart akıma belirli amaçlarla doğrudan yazmak için yararlıdır. &glibc;nde standart akımlar basitçe kapatılabilir ve yeni biri <function>fopen</function> ile açılabilir. Ancak bazı sistemler bu tarz çalışmayı desteklemez, bu nedenle <code>freopen</code> kullanımı daha taşınabilir olacaktır.
   </para>
   <para>
    Kaynak dosyalar 32 bitlik bir makinede <code>_FILE_OFFSET_BITS == 64</code> ile derlendiğinde LFS arayüzü eski arayüzle şeffaf olarak değiştirildiğinden bu işlev için <function>freopen64</function> tanımı kullanılır.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-freopen64"><primary>freopen64</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-freopen64"><primary>akımlar</primary><secondary>kapatıp açılması</secondary></indexterm>
   <csproto type="işlev">
    <csname><ptr>FILE</ptr><function>freopen64</function></csname>
    <csparam><ptr>const&#160;char</ptr><parameter>filename</parameter></csparam>
    <csparam><ptr>const&#160;char</ptr><parameter>opentype</parameter></csparam>
    <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
   </csproto>
   <header>&stdio.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&asunsafe; &corrupt;</concept>
    <concept>&acunsafe; &corrupt; &fd;</concept>
   </conceptlist>
   <para>
    Bu işlev <function>freopen</function> işlevine benzer. Tek farkla, bu akım 32 bitlik makineler üzerinde <literal>2</literal><superscript>31</superscript> bayttan büyük dosyalar üzerinde bile çalışır. <parameter>stream</parameter> tarafından gösterilen akımın kipi bu işlev için önemli olmadığından, akımın <function>fopen64</function> veya <function>freopen64</function> kullanarak açılmış olmaması gerekir.
   </para>
   <para>
    Kaynak dosyaları 32 bitlik bir makine üzerinde <code>_FILE_OFFSET_BITS == 64</code> ile derlenirse bu işlev <function>freopen</function> ismi ile kullanılabilir yani eski arayüz ile şeffaf olarak yer değiştirir.
   </para>
  </csynopsis>
  <para>
   Bazı durumlarda, belirtilen akımın okuma ve yazma için kullanılabilir olup olmadığını bilmek kullanışlıdır. Bu bilgi normalde mevcut değildir ve ayrı ayrı hatırlanması gerekirdi. Solaris, akım tanıtıcıdan bu bilgiyi alacak birkaç işlev içerir ve bu işlevler &glibc;nde de vardır.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-freadable"><primary>__freadable</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-freadable"><primary>akımlar</primary><secondary>okunabilirlik</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>__freadable</function></csname>
    <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
   </csproto>
   <header>&stdio_ext.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&asunsafe;</concept>
    <concept>&acunsafe;</concept>
   </conceptlist>
   <para>
    <code>__freadable</code> işlevi <parameter>stream</parameter> akımının okuma iznine sahip olup olmadığını saptar. Okuma izni varsa sıfırdan farklı bir değer ile döner. Sadece yazma izni olan akımlarda işlev sıfır ile döner.
   </para>
   <para>
    Bu işlev &stdio_ext.h; başlık dosyasında bildirilmiştir.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-fwritable"><primary>__fwritable</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-fwritable"><primary>akımlar</primary><secondary>yazılabilirlik</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>__fwritable</function></csname>
    <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
   </csproto>
   <header>&stdio_ext.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&asunsafe;</concept>
    <concept>&acunsafe;</concept>
   </conceptlist>
   <para>
    <code>__fwritable</code> işlevi <parameter>stream</parameter> akımının yazma iznine sahip olup olmadığını saptar. Yazma izni varsa sıfırdan farklı bir değer ile döner. Sadece okuma izni olan akımlarda işlev sıfır ile döner.
   </para>
   <para>
    Bu işlev &stdio_ext.h; başlık dosyasında bildirilmiştir.
   </para>
  </csynopsis>
  <para>
   Biraz daha farklı çeşitte sorunlar için iki işlev daha vardır. Bunlar biraz daha hassas bilgiler sağlar.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-freading"><primary sortas="freading">__freading</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-freading"><primary>akımlar</primary><secondary>okunurluk</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>__freading</function></csname>
    <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
   </csproto>
   <header>&stdio_ext.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&asunsafe;</concept>
    <concept>&acunsafe;</concept>
   </conceptlist>
   <para>
    <code>__freading</code> işlevi <parameter>stream</parameter> akımından son olarak okuma işlemi yapılmışsa ya da akım salt okunur olarak açılmışsa sıfırdan farklı bir değerle döner, aksi takdirde sıfır ile döner. Bir akımın okuma ve yazma için açılıp açılmadığının saptanması işlemi son yazma sırasında kullanılmışsa diğer şeylerin yanı sıra içerik ve tampon hakkında sonuçlar çıkarmaya da izin verilir.
   </para>
   <para>
    Bu işlev &stdio_ext.h; başlık dosyasında bildirilmiştir.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-fwriting"><primary sortas="fwriting">__fwriting</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-fwriting"><primary>akımlar</primary><secondary>yazılırlık</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>__fwriting</function></csname>
    <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
   </csproto>
   <header>&stdio_ext.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&asunsafe;</concept>
    <concept>&acunsafe;</concept>
   </conceptlist>
   <para>
    <code>__fwriting</code> işlevi <parameter>stream</parameter> akımına son olarak yazma işlemi yapılmışsa ya da akım salt yazılır olarak açılmışsa sıfırdan farklı bir değerle döner, aksi takdirde sıfır ile döner.
   </para>
   <para>
    Bu işlev &stdio_ext.h; başlık dosyasında bildirilmiştir.
   </para>
  </csynopsis>
 </chapter>
 <chapter xml:id="glibc-Closing-Streams">
  <title>Akımların Kapatılması</title>
  <titleabbrev>İşi biten akım kapatılmalıdır.</titleabbrev>
  <para>
   Bir akım <function>fclose</function> ile kapatıldığında akım ile dosya arasındaki bağlantı kesilir. Kapatılan akımın üzerinde artık işlem yapılamaz.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-fclose"><primary>fclose</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-fclose"><primary>akımlar</primary><secondary>kapatılması</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>fclose</function></csname>
    <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
   </csproto>
   <header>&stdio.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&asunsafe; &heap; &lock;</concept>
    <concept>&acunsafe; &lock; &mem; &fd;</concept>
   </conceptlist>
   <para>
    Bu işlev <parameter>stream</parameter> akımının kapatılmasına ve dosya ile bağlantısının kesilmesine sebep olur. Tamponlanmış çıktılar yazılır, tamponlanmış girdiler ise iptal edilir. Dosya başarıyla kapatılırsa işlev sıfırla döner, aksi takdirde <varname>EOF</varname> ile döner.
   </para>
   <para>
    Bir çıkış akımını kapatmak için <code>fclose</code> çağrısı yapıldığında hataların saptanması önem kazanır, çünkü gerçek hayatta her gün aldığınız hatalar bu sırada da oluşabilir. Örneğin, <code>fclose</code> tampondaki çıktıyı yazarken disk doluverirse bir hata alınabilir. Hatta tamponun boş olduğu bilinse bile eğer NFS kullanılıyorsa dosya kapatılırken hata alınabilir.
   </para>
  </csynopsis>
  <para>
   &glibc;nde tüm akımları kapatmak için ayrı bir işlev vardır.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-fcloseall"><primary>fcloseall</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-fcloseall"><primary>akımlar</primary><secondary>tümünün kapatılması</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>fcloseall</function></csname>
    <csparam><void/></csparam>
   </csproto>
   <header>&stdio.h;</header>
   <conceptlist>
    <concept>&mtunsafe; &race;<code linkend="glibc-safety-identifier">:streams</code></concept>
    <concept>&asunsafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    Bu işlev sürecin açık olan tüm akımlarını kapatır ve bunlarla bağlantılı dosyalara olan bağlantılar kesilir. Tüm tamponlanmış veri yazılır, tamponlanmış girdiler ise iptal edilir. İşlev, tüm dosyalar hatasız kapatılırsa sıfır ile, hata oluşursa <varname>EOF</varname> ile döner.
   </para>
   <para>
    Bu işlev çok özel durumlarda örneğin bir hata oluşup sürecin sonlandırılması  gerektiğinde kullanılmalıdır. Normalde her akım sorunlarının tanımlanabilmesi için ayrı ayrı kapatılmalıdır. Ayrıca bu işlev <link linkend="glibc-Standard-Streams">standart akımları</link> da kapatacağından sorunlar çıkarır.
   </para>
  </csynopsis>
  <para>
   Yazılımı <function>main</function> işlevinden normal çıkış yaparsa ya da bir <function>exit</function> çağrısı ile çıkarsa (bkz. <xref linkend="glibc-Normal-Termination"/>) tüm açık akımlar özdevinimli olarak düzgünce kapatılır. Yazılım başka bir şekilde, örneğin bir <function>abort</function> çağrısı ile (bkz. <xref linkend="glibc-Aborting-a-Program"/>) ya da bir ölümcül sinyal ile (Bkz. <xref linkend="glibc-Signal-Handling"/>) sonlandırılırsa açık akımlar düzgünce kapatılamayabilir. Tamponlanmış çıktılar dosyalara yazılamayabilir ve dosyalar eksik ya da boş kalabilir. Akımların tamponlanması ile ilgili daha ayrıntılı bilgi <xref linkend="glibc-Stream-Buffering"/> bölümünde bulunabilir.
  </para>
 </chapter>
 <chapter xml:id="glibc-Streams-and-Threads">
  <title>Akımlar ve Evreler</title>
  <titleabbrev>Evreli yazılımlarda akımlarla ilgili işlemler.</titleabbrev>
  <para>
   <indexterm linkend="glibc-cp"><primary>evreler</primary></indexterm>
   <indexterm linkend="glibc-cp"><primary>çok evreli yazılımlar</primary></indexterm>
   Akımlar çok evreli yazılımlarda tek evreli yazılımlardaki gibi kullanılır. Ancak yazılımcı olası karışıklıkların farkında olmalıdır. Birçok akım işlevinin tasarımı ve gerçeklenmesi çok evreli yazılım geliştirmeyle ilgili ek gereksinimlerden oldukça etkileneceğinden yazılımda evrelerin asla kullanılamayabileceğinin bilinmesi ayrıca önemlidir.
  </para>
  <para>
   POSIX standardı aksi belirtilmedikçe akım işlemlerinin bölünmez olmasını gerektirir. Örneğin iki akım işleminin iki evre halinde aynı anda bir akıma uygulanması işlemlerin sırayla yapılıyormuş gibi yapılmasına sebep olacaktır. Okuma ve yazma sırasında uygulanan tampon işlemleri aynı akımı kullanan diğerlerinden korunur. Bu, her akımın yapılacak bir çalışma öncesi (dolaylı olarak) elde edilen bir dahili kilitleme nesnesine sahip olması ile sağlanır.
  </para>
  <para>
   Ancak bunun yeterli olmadığı ya da istenmediği durumlar da vardır. Eğer yazılım birden fazla akım işlevi çağrısının teker teker yapılmasını gerektiriyorsa dolaylı kilitleme mekanizması yetersiz kalır. Bir yazılımın üretmek istediği bir satırı çeşitli işlev çağrılarıyla oluşturması buna bir örnek olarak verilebilir. Evrelere ayırma işi tüm işlev çağrıları üzerinde değil, işlevlerin kendileri tarafından, kendi işlemlerini evrelere ayırarak, yapılmalıdır. Bunun olabilmesi için de akım kilitleme işleminin yazılım kodunda yapılması gerekir.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-flockfile"><primary>flockfile</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-flockfile"><primary>akımlar</primary><secondary>kilitlenmesi</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>void</type><function>flockfile</function></csname>
    <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
   </csproto>
   <header>&stdio.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acunsafe; &lock;</concept>
   </conceptlist>
   <para>
    <code>flockfile</code> işlevi <parameter>stream</parameter> akımı ile ilişkili dahili kilitleme nesnesini elde etmekte kullanılır. İşlev, başka hiçbir evrenin doğrudan <code>flockfile</code>/<function>ftrylockfile</function> üzerinden veya dolaylı olarak bir akım işlevi çağrısıyla akımı kilitleyememesini garanti eder. Kilit elde edilinceye kadar evre engellenir. <function>funlockfile</function> işlevine yapılacak bir doğrudan çağrı kilit nesnesini serbest bırakacaktır.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-ftrylockfile"><primary>ftrylockfile</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-ftrylockfile"><primary>akımlar</primary><secondary>kilitlenmesi</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>ftrylockfile</function></csname>
    <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
   </csproto>
   <header>&stdio.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acunsafe; &lock;</concept>
   </conceptlist>
   <para>
    <code>ftrylockfile</code> işlevi <function>flockfile</function>  işlevi gibi <parameter>stream</parameter> akımı ile ilişkili dahili kilitleme nesnesini elde etmeye çalışır. <function>flockfile</function> işlevinin aksine bu işlev kilit kullanılabilir değilse engelleme yapmaz. Kilit başarıyla elde edilirse işlev sıfırla döner, aksi takdirde akımı başka bir evre kilitlemiş demektir.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-funlockfile"><primary>funlockfile</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-funlockfile"><primary>akımlar</primary><secondary>kilidin açılması</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>void</type><function>funlockfile</function></csname>
    <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
   </csproto>
   <header>&stdio.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acunsafe; &lock;</concept>
   </conceptlist>
   <para>
    <code>funlockfile</code> işlevi <parameter>stream</parameter> akımının kilitleme nesnesini serbest bırakır. Akım bir <function>flockfile</function> çağrısı ya da başarılı bir <function>ftrylockfile</function> çağrısı tarafından önceden kilitlenmiş olmalıdır. Akım işlemleri tarafından uygulanan dolaylı kilitlemeler sayılmaz. <code>funlockfile</code> işlevi bir hata durumu döndürmez ve geçerli evre tarafından kilitlenmemiş bir akım için yapılan çağrının davranışı tanımsızdır.
   </para>
  </csynopsis>
  <example>
   <para>
    Yukarıdaki işlevlerin nasıl kullanılacağını gösteren ve çok evreli yazılımlarda  bile kullanılabilecek aşağıdaki örnekte bir çıktı satırı bölünmez bir işlem olarak üretilmektedir (evet, aynı iş tek bir <function>fprintf</function> çağrısı ile yapılabilirdi ama kimi zaman bu mümkün olmaz):
   </para>
   <screen>FILE *fp;
{
   …
   flockfile (fp);
   fputs ("This is test number ", fp);
   fprintf (fp, "%d\n", test);
   funlockfile (fp)
}
</screen>
   <para>
    Doğrudan kilitleme olmaksızın <function>fputs</function> çağrısı döndükten  sonra ve <function>fprintf</function> işlevinin '<literal>number</literal>'  sözcüğünden sonra numarayı basmasından önce başka bir evrenin <parameter>fp</parameter> akımını kullanması mümkün olabilirdi.
   </para>
   <para>
    Bu açıklamalardan sonra akımlardaki kilitleme nesnelerinin basit <link linkend="glibc-ISO-C-Mutexes">karşılıklı dışlama nesneleri</link> olmadığı anlaşılmış olmalıdır. Aynı akımın aynı evre içinde iki kere kilitlenmesi mümkün olduğundan kilitleme nesneleri, ardışık karşılıklı dışlama nesnelerine eşdeğer olmalıdır. Bu karşılıklı dışlama nesneleri sahibini ve kilit alınma sayısını takip eder. Akımdaki kilitleme nesnelerini tamamen serbest bırakmak için aynı evreler tarafından aynı sayıda <function>funlockfile</function> çağrısı gereklidir. Örneğin:
   </para>
   <screen>void
foo (FILE *fp)
{
  ftrylockfile (fp);
  fputs ("in foo\n", fp);
  /* <replaceable>Bu çok yanlış!!!</replaceable>  */
  funlockfile (fp);
}
</screen>
   <para>
    Burada önemli olan, <function>funlockfile</function> işlevinin "sadece" <function>ftrylockfile</function> işlevinin akımı başarıyla kilitlediği anlaşıldığı takdirde kullanılabileceğidir. Örnekte <function>ftrylockfile</function> işlevinin sonucu gözardı edildiğinden yapılan işlem yanlıştır. <function>flockfile</function> kullanılsaydı bu yanlış olmayacaktı. Yukarıdaki gibi bir kodun sonucunda ya <function>funlockfile</function> o anki evre tarafından kilitlenmeyen bir akımı serbest bırakmaya çalışacak ya da akımı vakitsiz olarak serbest bırakacaktır. Kod aşağıdaki gibi olmalıydı:
   </para>
<screen>void
foo (FILE *fp)
{
  if (ftrylockfile (fp) == 0)
    {
      fputs ("in foo\n", fp);
      funlockfile (fp);
    }
}
</screen>
  </example>
  <para>
   Kilitlemenin niçin gerekli olduğu konusu halledildiğine göre artık kilitlemenin ne zaman istenmediği ve bu durumda ne yapılabileceği üzerinde durulacaktır. Kilitleme işlemleri (doğrudan ya da dolaylı) bedavaya gelmez. Bir kilit alınmasa bile maliyeti sıfır değildir. Uygulanan işlemler çok işlemcili ortamlardaki güvenli bellek erişimlerini gerektirir. Böyle sistemlerdeki çok sayıda yerel önbellekle bu oldukça maliyetlidir.
  </para>
  <para>
   En iyisi çok gerekli değilse (bir akımın iki veya daha fazla evre  tarafından kullanılamayacağı bağlamlarda) kilitlemeden tamamen kaçınmaktır. Bu çoğu zaman uygulama kodu için uygulanabilir olsa da çok sayıda bağlam içinde kullanılabilen kütüphane kodu için tutucu olunmalı ve gerekli olmasa bile kilitleme kullanılmalıdır.
  </para>
  <para>
   Kilitlemeden kaçınmada iki temel düzenek vardır. İlki akım işlemlerinin <code>_unlocked</code> sonekli biçimlerini kullanmaktır. POSIX standardı bunların pek azını tanımlar ve GNU kütüphanesi bunlara birkaç tane daha ekler. İşlevlerin bu biçimleri isimlerine <code>_unlocked</code> soneki getirilen işlevlerle benzer davranışı gösterir; tek farkla, akımları kilitlemezler. Bu işlevler çok daha hızlı olabilme olasılıklarından dolayı daha çok tercih edilir. Bu sadece kilitleme işlemlerinden kendilerini korumalarından dolayı değildir. Daha önemli olarak, <function>putc</function> ve <function>getc</function> işlevleri çok basittir ve geleneksel olarak (evrelere girişten önce) tampon boş değilse çok hızlı olan makrolar halinde gerçeklenmişlerdir. Kilitleme gereksinimlerinin eklenmesiyle bu işlevlerin kodu çok büyüdüğünden artık makrolar halinde gerçeklenememektedir. Ancak bu makrolar aynı işlevsellikle yeni isimler altında (<function>putc_unlocked</function> ve  <function>getc_unlocked</function>) hala kullanılabilmektedir. Hızlarındaki bu dev farktan dolayı <code>_unlocked</code> sonekli işlevlerin kullanılması kilitleme gerekli olduğu durumlarda bile tercih edilmesine sebep olmaktadır. Kilitleme ile birlikte kullanıma bir örnek:
  </para>
  <example>
   <screen>void
foo (FILE *fp, char *buf)
{
  flockfile (fp);
  while (*buf != '/')
    putc_unlocked (*buf++, fp);
  funlockfile (fp);
}
</screen>
   <para>
    Bu örnekte <function>putc</function> işlevi kullanılsaydı ve doğrudan kilitleme olmasaydı, <function>putc</function> işlevi döngü sonlanana kadar her çağrıda bir olmak üzere kilidi defalarca elde edecekti. Bu örnek <function>putc_unlocked</function> makrosu ile akım tamponunun defalarca kilitlenmeksizin doğrudan nasıl değiştirilebileceğini göstermek için yazılmıştır.
   </para>
  </example>
  <para>
   Kilitlemeden kaçınmak için ikinci yol Solaris’te bulunan ve &glibc;nde de kullanılabilen, standartta olmayan bir işlevi kullanmaktır.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-fsetlocking"><primary sortas="fsetlocking">__fsetlocking</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-fsetlocking"><primary>akımlar</primary><secondary>kilitlemekden kaçınmak</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>__fsetlocking</function></csname>
    <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
    <csparam><type>int</type><parameter>type</parameter></csparam>
   </csproto>
   <header>&stdio_ext.h;</header>
   <conceptlist>
    <concept>&mtsafe; &race;<code linkend="glibc-safety-identifier">:stream</code></concept>
    <concept>&asunsafe; &lock;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <code>__fsetlocking</code> işlevi, akım işlemlerinin <parameter>stream</parameter> akımının kilitleme nesnesini dolaylı elde edip etmeyeceğini seçmekte kullanılır. Öntanımlı olarak kilit dolaylı elde edilir ancak bu işlev kullanılarak kilidin alınması iptal edilebilir ya da tekrar yerleştirilebilir. <parameter>type</parameter> bağımsız değişkeninde kullanılabilecek üç değer vardır:
   </para>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-FSETLOCKING_INTERNAL"><primary>FSETLOCKING_INTERNAL</primary></indexterm>
    <csproto type="sabit">
     <csname><function>FSETLOCKING_INTERNAL</function></csname>
    </csproto>
    <header>&stdio_ext.h;</header>
    <para>
     <parameter>stream</parameter> akımı önceden tanımlı dahili kilitlemeyi hemen kullanmaya başlar. <code>_unlocked</code> sonekli biçim hariç her akım işlemi akımı dolaylı olarak kilitleyecektir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-FSETLOCKING_BYCALLER"><primary>FSETLOCKING_BYCALLER</primary></indexterm>
    <csproto type="sabit">
     <csname><function>FSETLOCKING_BYCALLER</function></csname>
    </csproto>
    <header>&stdio_ext.h;</header>
    <para>
     <code>__fsetlocking</code> işlevi döndükten sonra akımın kilitlenmesinden kullanıcı sorumlu olur. Durum <varname>FSETLOCKING_INTERNAL</varname> ile ilk durumuna döndürülünceye kadar bunu örtük olarak yapacak hiçbir akım işlemi yoktur.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-FSETLOCKING_QUERY"><primary>FSETLOCKING_QUERY</primary></indexterm>
    <csproto type="sabit">
     <csname><function>FSETLOCKING_QUERY</function></csname>
    </csproto>
    <header>&stdio_ext.h;</header>
    <para>
     <code>__fsetlocking</code> işlevi sadece akımın o anki kilitleme durumunu sorgular. Dönen değer kilitleme durumuna bağlı olarak ya <varname>FSETLOCKING_INTERNAL</varname> ya da <varname>FSETLOCKING_BYCALLER</varname> olacaktır.
    </para>
   </csynopsis>
   <para>
    Bu işlev özellikle yazılım kodu  <code>_unlocked</code> işlevleri hakkında yeterli bilgiye sahip olunmadan yazılmışsa (ya da yazılımcı onları çok delice kullanmışsa) yararlıdır.
   </para>
   <para>
    Bu işlev ve <parameter>type</parameter> bağımsız değişkeninde kullanılabilecek üç değer &stdio_ext.h; başlık dosyasında bildirilmiştir.
   </para>
  </csynopsis>
 </chapter>
 <chapter xml:id="glibc-Streams-and-I18N">
  <title>Akımlar ve Uluslararasılaştırma</title>
  <titleabbrev>Uluslararasılaştırılmış uygulamalarda akımlar.</titleabbrev>
  <para>
   &isoc;90 geniş karakter kümeleriyle çalışmak için <type>wchar_t</type> isimli yeni bir veri türü tanımladı. Eksik olan, <type>wchar_t</type> dizgelerini doğrudan çıktılama olasılığıydı. Biri onları <function>mbstowcs</function> kullanarak çok baytlı dizgelere çevirdi (henüz bir <function>mbsrtowcs</function> yok) ve sonra normal akım işlevlerini kullandı. Bu yapılabilir olurken anlamsız olmayan dönüşümler uyguladığından ve yazılımın karmaşıklığını ve boyutlarını fazlaca artırdığından çok hantal oldu.
  </para>
  <para>
   Unix standardı daha erken olarak (galiba XPG4.2'de) <function>printf</function> ve <function>scanf</function> işlevleri için iki ek biçem belirteci tanımladı. Tek geniş karakterin okunması ve basılması <code>%C</code> belirteci ile geniş karakterli dizgelerinki ise <code>%S</code> belirteci kullanılarak mümkün hale getirildi. Bu belirteçler geniş karakter türü kullanmak dışında tıpkı <code>%c</code> ve <code>%s</code> belirteçleri gibi çalışıyordu. Ancak geniş karakterler ve dizgeler kullanılmadan önce çok baytlı dizgelere ya da tersine çevriliyordu.
  </para>
  <para>
   Bu bir başlangıçtı ama hala yeterince iyi değildi. <function>printf</function>  ve <function>scanf</function> kullanımı hep tercih edilen bir şey değildi. Daha küçük ve daha hızlı diğer işlevler geniş karakterlerle çalışamıyordu. İkincisi, <function>printf</function> ve <function>scanf</function> işlevleri için geniş karakterleri oluşturulmasını sağlayacak bir biçem dizgesine sahip değildi. Sonuç olarak, eğer temel olmayan karakterleri içermeleri gerekiyorsa, biçem dizgilerinin oluşturulması gerekecekti.
  </para>
  <para>
   <indexterm linkend="glibc-cp" xml:id="glibc-Streams-cplus"><primary>C++ akımları</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-Streams-cplusplus"><primary>akımlar</primary><secondary>C++</secondary></indexterm>
   &isoc;90'ın 1. düzeltmesinde sorunu çözümlemek için yeni bir işlevler kümesi eklendi. Akım işlevlerinin çoğu bir karakter veya dizge yerine bir geniş karakter veya bir geniş karakterli dizge alır hale getirildi. Yeni işlevler aynı akımlar (örn, <varname>stdout</varname>) üzerinde işlem yapmaktadır. Bu normal ve geniş karakterler G/Ç işlemleri için ayrı akım işlevleri kullanılan C++ çalışma anı kütüphanesindeki modelden farklıdır.
  </para>
  <para>
   <indexterm linkend="glibc-cp" xml:id="glibc-Streams-orientation"><primary>akımlar</primary><secondary>yönlenim</secondary></indexterm>
   Aynı akımın hem normal hem de geniş karakterlerle kullanılabilmesi bir sınırlama ile mümkün olur: Bir akım ya normal karakterleri kullanır ya da geniş karakterleri, ikisi birden olmaz. Bir kere karar verildikten sonra dönüşü yoktur. Sadece <function>freopen</function> ya da <function>freopen64</function> işlevleri yönlenimi sıfırlayabilir. Yönlenime üç yolla karar verilebilir:
  </para>
  <itemizedlist>
   <listitem>
    <para>
     Normal karakter işlevlerinden biri (<function>fread</function> ve <function>fwrite</function> işlevleri dahil) kullanılmışsa akım "geniş yönlenimli değildir" olarak imlenir.
    </para>
   </listitem>
   <listitem>
    <para>
     Geniş karakter işlevlerinden biri kullanılmışsa akım "geniş yönlenimli" olarak imlenir.
    </para>
   </listitem>
   <listitem>
    <para>
     Yönlenimi belirtmek için <function>fwide</function> işlevi kullanılır.
    </para>
   </listitem>
  </itemizedlist>
  <para>
   Geniş ve geniş olmayan karakter işlemlerinin aynı akım üzerinde asla karıştırılmaması gerekliliği önemlidir. Bunun için tasarlanmış bir tanılama yolu yoktur. Uygulama basitçe tuhaflaşır hatta daha basitçe çökebilir. <function>fwide</function> işlevi bundan kaçınılmasına yardımcı olabilir.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-fwide"><primary>fwide</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-fwide"><primary>akımlar</primary><secondary>geniş karakterler</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>fwide</function></csname>
    <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
    <csparam><type>int</type><parameter>mode</parameter></csparam>
   </csproto>
   <header>&wchar.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&asunsafe; &corrupt;</concept>
    <concept>&acunsafe; &lock;</concept>
   </conceptlist>
   <para>
    <code>fwide</code> işlevi <parameter>stream</parameter> akımının yönleniminin belirlenmesinde ve sorgulanmasında kullanılabilir. <parameter>mode</parameter> bağımsız değişkeni pozitif değer belirtiyorsa akım geniş yönlenimli, negatif bir değer belirtiyorsa dar yönlenimlidir. <code>fwide</code> ile önceki yönlenimi değiştirmek mümkün değildir. <parameter>stream</parameter> akımı zaten yönlenimli ise işlev hiçbir şey yapmaz.
   </para>
   <para>
    <parameter>mode</parameter> sıfırsa, o anki yönlenim durumu sorgulanır ve hiçbir değişiklik yapılmaz.
   </para>
   <para>
    <code>fwide</code> işlevi yönlenimin durumuna bağlı olarak, dar, hiçbiri veya geniş yönlenimli olmasına göre sırayla bir negatif değer, sıfır veya bir pozitif değerle döner.
   </para>
   <para>
    Bu işlev &isoc;90'ın 1. düzeltmesinde tanımlanmıştır.
   </para>
  </csynopsis>
  <para>
   Genel olarak bir akımın yönlenimini mümkün olduğu kadar erken belirlemek daha iyidir. Bu özellikle <varname>stdin</varname>, <varname>stdout</varname> ve <varname>stderr</varname> standart akımlarında ortaya çıkacak bazı sürprizlerden  koruyabilir. Bu akımlardan birini kullanan bazı kütüphane işlevleri bazı durumlarda akımın yönlenimini uygulamanın kalanında, sonlanma ve hata üretilmesi  dışında farklı bir yolla kullanır. Akımların yönleniminin yanlış kullanımında hata üretilmediği unutulmamalıdır. Bir akımın oluşturulduktan sonra yönlenimsiz bırakılması normalde, sadece akımları farklı bağlamlarda kullanmak üzere oluşturan kütüphane işlevleri için gereklidir.
  </para>
  <para>
   Akımların kullanıldığı ve bu akımların farklı bağlamlarda kullanılabildiği bir kodu yazarken bir akımı kullanmadan önce akımın yönlenimini (kütüphane arayüzünün kuralları belli bir yönlenimi talep etmedikçe) sorgulamak önemlidir. Aşağıdaki küçük işlev bunu örneklemektedir:
  </para>
  <example>
   <screen>void
print_f (FILE *fp)
{
  if (fwide (fp, 0) &gt; 0)
    /* <replaceable>Dönen pozitif değer geniş yönlenimi gösterir.</replaceable>  */
    fputwc (L'f', fp);
  else
    fputc ('f', fp);
}
</screen>
   <para>
    Burada <function>print_f</function> işlevi, akım önceden yönlenimsiz olsa da akımın yönlenimine karar vermektedir (yukarıdaki bilgiler ışığında olumsuz bir şey olmayacağı görülecektir).
   </para>
  </example>
  <para>
   <type>wchar_t</type> değerleri için kullanılan karakter kodlaması belirtilmemiştir ve yazılımcı karakter kodlaması hakkında herhangi bir kabulde bulunmamalıdır. <type>wchar_t</type> değerlerinin G/Ç işlemleri için bunun anlamı, bu değerlerin akıma doğrudan doğruya yazılmasının imkansızlığıdır. Bu &isoc; yerel modelinde izlenen yol da değildir. Baytların alttaki ortamdan okunması ve oraya yazılması yerine yapılacak olan önce <type>wchar_t</type> için gerçekleme tarafından seçilen dahili yerele dönüşümdür. Harici karakter kodlaması o anki yerelin <varname>LC_CTYPE</varname> yerel sınıfı tarafından ya da <function>fopen</function>, <function>fopen64</function>, <function>freopen</function> veya <function>freopen64</function> işlevlerine verilen kip belirtiminin parçası olan <code>ccs</code> değeri tarafından belirlenir. Dönüşümün ne zaman ve nasıl olacağı belirsizdir ve kullanıcıya görünür değildir.
  </para>
  <para>
   Bir akım yönlenimsiz durumda oluşturulduğunda bu noktada onunla ilişkili bir dönüşüm yapılmaz. Kullanılacak dönüşüm akım yönlenimlendiği sırada <varname>LC_CTYPE</varname> yerel sınıfı tarafından saptanmış olacaktır. Dikkatli olunmazsa, yerel çalışma anında değiştirilirse sürprizli durumlarla karşılaşılabilir. Bu da, akımın yönleniminin mümkün olduğunca erken belirlenmesinin önemini gösteren iyi bir sebeptir. Bu işlemin bir <function>fwide</function> çağrısı ile yapılması gerekir.
  </para>
 </chapter>
 <chapter xml:id="glibc-Simple-Output">
  <title>Karakterlerin ve Satırların Basit Çıktılanması</title>
  <titleabbrev>Karakterlerin ve satırların biçimlenmeden çıktılanması.</titleabbrev>
  <para>
   <indexterm linkend="glibc-cp"><primary>akımlar</primary><secondary>yazma</secondary><tertiary>tek karakter</tertiary></indexterm>
   Bu kısımda karakter ve satır yönlenimli çıktılama işlemleri için kullanılan işlevler açıklanmıştır.
  </para>
  <para>
   Bu kısımdaki dar yönlenimli akım işlevleri &stdio.h; başlık dosyasında, geniş yönlenimli akım işlevleri ise &wchar.h; başlık dosyasında bildirilmiştir.
   <indexterm linkend="glibc-pg"><primary>stdio.h</primary></indexterm>
   <indexterm linkend="glibc-pg"><primary>wchar.h</primary></indexterm>
  </para>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-fputc"><primary>fputc</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-fputc"><primary>dar karakterler</primary><secondary>akımlara çıktılama</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>fputc</function></csname>
    <csparam><type>int</type><parameter>c</parameter></csparam>
    <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
   </csproto>
   <header>&stdio.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&asunsafe; &corrupt;</concept>
    <concept>&acunsafe; &corrupt; &lock;</concept>
   </conceptlist>
   <para>
    <code>fputc</code> işlevi <parameter>c</parameter> karakterini <type>unsigned&nbsp;char</type> türüne çevirip <parameter>stream</parameter> akımna yazar. Bir hata oluşursa <varname>EOF</varname>, aksi takdirde <parameter>c</parameter> karakteri döner.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-fputwc"><primary>fputwc</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-fputwc"><primary>geniş karakterler</primary><secondary>akımlara çıktılama</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>wint_t</type><function>fputwc</function></csname>
    <csparam><type>wchar_t</type><parameter>wc</parameter></csparam>
    <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
   </csproto>
   <header>&wchar.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&asunsafe; &corrupt;</concept>
    <concept>&acunsafe; &corrupt; &lock;</concept>
   </conceptlist>
   <para>
    <code>fputwc</code> işlevi <parameter>wc</parameter> geniş karakterini <parameter>stream</parameter> akımna yazar. Bir hata oluşursa <varname>WEOF</varname>, aksi takdirde <parameter>wc</parameter> karakteri döner.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-fputc_unlocked"><primary>fputc_unlocked</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-fputc_unlocked"><primary>dar karakterler</primary><secondary>akımlara kilitsiz çıktılama</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>fputc_unlocked</function></csname>
    <csparam><type>int</type><parameter>c</parameter></csparam>
    <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
   </csproto>
   <header>&stdio.h;</header>
   <conceptlist>
    <concept>&mtsafe; &race;<code linkend="glibc-safety-identifier">:stream</code></concept>
    <concept>&asunsafe; &corrupt;</concept>
    <concept>&acunsafe; &corrupt;</concept>
   </conceptlist>
   <para>
    <code>fputc_unlocked</code> işlevi akımı örtük olarak kilitlememesi dışında <function>fputc</function> işlevine eşdeğerdir.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-fputwc_unlocked"><primary>fputwc_unlocked</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-fputwc_unlocked"><primary>geniş karakterler</primary><secondary>akımlara kilitsiz çıktılama</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>wint_t</type><function>fputwc_unlocked</function></csname>
    <csparam><type>wchar_t</type><parameter>wc</parameter></csparam>
    <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
   </csproto>
   <header>&wchar.h;</header>
   <conceptlist>
    <concept>&mtsafe; &race;<code linkend="glibc-safety-identifier">:stream</code></concept>
    <concept>&asunsafe; &corrupt;</concept>
    <concept>&acunsafe; &corrupt;</concept>
   </conceptlist>
   <para>
    <code>fputwc_unlocked</code> işlevi akımı örtük olarak kilitlememesi dışında <function>fputwc</function> işlevine eşdeğerdir.
   </para>
   <para>
    Bu işlev GNU oluşumudur.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-putc"><primary>putc</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-putc"><primary>dar karakterler</primary><secondary>akımlara çıktılama makrosu</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>putc</function></csname>
    <csparam><type>int</type><parameter>c</parameter></csparam>
    <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
   </csproto>
   <header>&stdio.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&asunsafe; &corrupt;</concept>
    <concept>&acunsafe; &corrupt; &lock;</concept>
   </conceptlist>
   <para>
    Birçok sistem tarafından daha hızlı olması için bir makro olarak gerçeklenmesi dışında tamamen <function>fputc</function> gibidir. Makrolar için genel kurala bir istisna olarak <parameter>stream</parameter> bağımsız değişkenini bir kereden fazla değerlendirebilmesi ona önem kazandırır. Genellikle <code>putc</code> işlevi tek bir karakterin yazılması için kullanılacak en iyi işlevdir.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-putwc"><primary>putwc</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-putwc"><primary>geniş karakterler</primary><secondary>akımlara çıktılama makrosu</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>wint_t</type><function>putwc</function></csname>
    <csparam><type>wchar_t</type><parameter>wc</parameter></csparam>
    <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
   </csproto>
   <header>&wchar.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&asunsafe; &corrupt;</concept>
    <concept>&acunsafe; &corrupt; &lock;</concept>
   </conceptlist>
   <para>
    Birçok sistem tarafından daha hızlı olması için bir makro olarak gerçeklenmesi dışında tamamen <function>fputwc</function> gibidir. Makrolar için genel kurala bir istisna olarak <parameter>stream</parameter> bağımsız değişkenini bir kereden fazla değerlendirebilmesi ona önem kazandırır. Genellikle <code>putwc</code> işlevi tek bir karakterin yazılması için kullanılacak en iyi işlevdir.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-putc_unlocked"><primary>putc_unlocked</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-putc_unlocked"><primary>dar karakterler</primary><secondary>akımlara kilitsiz çıktılama</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>putc_unlocked</function></csname>
    <csparam><type>int</type><parameter>c</parameter></csparam>
    <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
   </csproto>
   <header>&stdio.h;</header>
   <conceptlist>
    <concept>&mtsafe; &race;<code linkend="glibc-safety-identifier">:stream</code></concept>
    <concept>&asunsafe; &corrupt;</concept>
    <concept>&acunsafe; &corrupt;</concept>
   </conceptlist>
   <para>
    <code>putc_unlocked</code> işlevi akımı örtük olarak kilitlememesi dışında <function>putc</function> işlevine eşdeğerdir.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-putwc_unlocked"><primary>putwc_unlocked</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-putwc_unlocked"><primary>geniş karakterler</primary><secondary>akımlara kilitsiz çıktılama</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>wint_t</type><function>putwc_unlocked</function></csname>
    <csparam><type>wchar_t</type><parameter>wc</parameter></csparam>
    <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
   </csproto>
   <header>&wchar.h;</header>
   <conceptlist>
    <concept>&mtsafe; &race;<code linkend="glibc-safety-identifier">:stream</code></concept>
    <concept>&asunsafe; &corrupt;</concept>
    <concept>&acunsafe; &corrupt;</concept>
   </conceptlist>
   <para>
    <code>putwc_unlocked</code> işlevi akımı örtük olarak kilitlememesi dışında <function>putwc</function> işlevine eşdeğerdir.
   </para>
   <para>
    Bu işlev GNU oluşumudur.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-putchar"><primary>putchar</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-putchar"><primary>dar karakterler</primary><secondary>standart çıktıya</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>putchar</function></csname>
    <csparam><type>int</type><parameter>c</parameter></csparam>
   </csproto>
   <header>&stdio.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&asunsafe; &corrupt;</concept>
    <concept>&acunsafe; &corrupt; &lock;</concept>
   </conceptlist>
   <para>
    <code>putchar</code> işlevi, <function>putc</function> işlevinin <parameter>stream</parameter> bağımsız değişkenine değer olarak <varname>stdout</varname> belirtilerek çağrılmasına eşdeğerdir. Yani bu işlev belirtilen karakteri doğrudan standart çıktıya basar.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-putwchar"><primary>putwchar</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-putwchar"><primary>geniş karakterler</primary><secondary>standart çıktıya</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>wint_t</type><function>putwchar</function></csname>
    <csparam><type>wchar_t</type><parameter>wc</parameter></csparam>
   </csproto>
   <header>&wchar.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&asunsafe; &corrupt;</concept>
    <concept>&acunsafe; &corrupt; &lock;</concept>
   </conceptlist>
   <para>
    <code>putwchar</code> işlevi, <function>putwc</function> işlevinin <parameter>stream</parameter> bağımsız değişkenine değer olarak <varname>stdout</varname> belirtilerek çağrılmasına eşdeğerdir.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-putchar_unlocked"><primary>putchar_unlocked</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-putchar_unlocked"><primary>dar karakterler</primary><secondary>standart çıktıya (kilitsiz)</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>putchar_unlocked</function></csname>
    <csparam><type>int</type><parameter>c</parameter></csparam>
   </csproto>
   <header>&stdio.h;</header>
   <conceptlist>
    <concept>&mtunsafe; &race;<code linkend="glibc-safety-identifier">:stdout</code></concept>
    <concept>&asunsafe; &corrupt;</concept>
    <concept>&acunsafe; &corrupt;</concept>
   </conceptlist>
   <para>
    <code>putchar_unlocked</code> işlevi akımı örtük olarak kilitlememesi dışında <function>putchar</function> işlevine eşdeğerdir.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-putwchar_unlocked"><primary>putwchar_unlocked</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-putwchar_unlocked"><primary>geniş karakterler</primary><secondary>standart çıktıya (kilitsiz)</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>wint_t</type><function>putwchar_unlocked</function></csname>
    <csparam><type>wchar_t</type><parameter>wc</parameter></csparam>
   </csproto>
   <header>&wchar.h;</header>
   <conceptlist>
    <concept>&mtunsafe; &race;<code linkend="glibc-safety-identifier">:stdout</code></concept>
    <concept>&asunsafe; &corrupt;</concept>
    <concept>&acunsafe; &corrupt;</concept>
   </conceptlist>
   <para>
    <code>putwchar_unlocked</code> işlevi akımı örtük olarak kilitlememesi dışında <function>putwchar</function> işlevine eşdeğerdir.
   </para>
   <para>
    Bu işlev GNU oluşumudur.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-fputs"><primary>fputs</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-fputs"><primary>dizgeler</primary><secondary>akıma çıktılama</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>fputs</function></csname>
    <csparam><ptr>const&#160;char</ptr><parameter>s</parameter></csparam>
    <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
   </csproto>
   <header>&stdio.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&asunsafe; &corrupt;</concept>
    <concept>&acunsafe; &corrupt; &lock;</concept>
   </conceptlist>
   <para>
    <code>fputs</code> işlevi <parameter>s</parameter> dizgesini <parameter>stream</parameter> akımına yazar.  Dizgeyi sonlandıran boş karakter yazılmadığı gibi sonuna bir satır sonu karakteri de eklemez. Sadece dizge içindeki karakterleri çıktılar.
   </para>
   <para>
    Bir yazma hatası oluşursa işlev <varname>EOF</varname> ile , aksi takdirde negatif olmayan bir değerle döner. Örneğin:
   </para>
   <example>
    <screen>fputs (&quot;Burada &quot;, stdout);
fputs (&quot;hava &quot;, stdout);
fputs (&quot;serin\n&quot;, stdout);
</screen>
    <para>
     kodu <literal>Burada hava serin</literal> dizgesini sonuna bir satır sonu karakteri ekleyerek çıktılar.
    </para>
   </example>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-fputws"><primary>fputws</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-fputws"><primary>geniş dizgeler</primary><secondary>akıma çıktılama</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>fputws</function></csname>
    <csparam><ptr>const&#160;wchar_t</ptr><parameter>ws</parameter></csparam>
    <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
   </csproto>
   <header>&wchar.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&asunsafe; &corrupt;</concept>
    <concept>&acunsafe; &corrupt; &lock;</concept>
   </conceptlist>
   <para>
    <code>fputws</code> işlevi <parameter>ws</parameter> geniş karakterli dizgesini <parameter>stream</parameter> akımına yazar.  Dizgeyi sonlandıran boş karakter yazılmadığı gibi sonuna bir satır sonu karakteri de eklemez. Sadece dizge içindeki karakterleri çıktılar.
   </para>
   <para>
    Bir yazma hatası oluşursa işlev <varname>WEOF</varname> ile, aksi takdirde negatif olmayan bir değerle döner.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-fputs_unlocked"><primary>fputs_unlocked</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-fputs_unlocked"><primary>dizgeler</primary><secondary>akıma çıktılama (kilitsiz)</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>fputs_unlocked</function></csname>
    <csparam><ptr>const&#160;char</ptr><parameter>s</parameter></csparam>
    <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
   </csproto>
   <header>&stdio.h;</header>
   <conceptlist>
    <concept>&mtsafe; &race;<code linkend="glibc-safety-identifier">:stream</code></concept>
    <concept>&asunsafe; &corrupt;</concept>
    <concept>&acunsafe; &corrupt;</concept>
   </conceptlist>
   <para>
    <code>fputs_unlocked</code> işlevi akımı örtük olarak kilitlememesi dışında <function>fputs</function> işlevine eşdeğerdir.
   </para>
   <para>
    Bu işlev GNU oluşumudur.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-fputws_unlocked"><primary>fputws_unlocked</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-fputws_unlocked"><primary>geniş dizgeler</primary><secondary>akıma çıktılama (kilitsiz)</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>fputws_unlocked</function></csname>
    <csparam><ptr>const&#160;wchar_t</ptr><parameter>ws</parameter></csparam>
    <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
   </csproto>
   <header>&wchar.h;</header>
   <conceptlist>
    <concept>&mtsafe; &race;<code linkend="glibc-safety-identifier">:stream</code></concept>
    <concept>&asunsafe; &corrupt;</concept>
    <concept>&acunsafe; &corrupt;</concept>
   </conceptlist>
   <para>
    <code>fputws_unlocked</code> işlevi akımı örtük olarak kilitlememesi dışında <function>fputws</function> işlevine eşdeğerdir.
   </para>
   <para>
    Bu işlev GNU oluşumudur.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-puts"><primary>puts</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-puts"><primary>dizgeler</primary><secondary>standart çıktıya satır çıktılama</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>puts</function></csname>
    <csparam><ptr>const&#160;char</ptr><parameter>s</parameter></csparam>
   </csproto>
   <header>&stdio.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&asunsafe; &corrupt;</concept>
    <concept>&acunsafe; &corrupt; &lock;</concept>
   </conceptlist>
   <para>
    <code>puts</code> işlevi <parameter>s</parameter> dizgesini standart çıktıya bir satır sonu karakteri ekleyerek yazar.  Dizgeyi sonlandıran boş karakter yazılmaz. (<function>fputs</function> işlevinin tersine bu işlevin dizgeye satır sonu karakteri eklediği unutulmamalıdır.)
   </para>
   <para>
    <code>puts</code> basit iletileri yazdırmak için en uygun işlevdir.
   </para>
   <example>
    <screen>puts ("Bu bir iletidir.");
</screen>
    <para>
     satırı ‘<literal>Bu bir iletidir.</literal>’ dizgesini bir satır sonu karakteri ekleyerek çıktılar.
    </para>
   </example>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-putw"><primary>putw</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-putw"><primary>dizgeler</primary><secondary>akıma sözcük çıktılama</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>putw</function></csname>
    <csparam><type>int</type><parameter>w</parameter></csparam>
    <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
   </csproto>
   <header>&stdio.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&asunsafe; &corrupt;</concept>
    <concept>&acunsafe; &corrupt; &lock;</concept>
   </conceptlist>
   <para>
    Bu işlev <parameter>w</parameter> sözcüğünü (<type>int</type> türündedir) <parameter>stream</parameter> akımına yazar. SVID ile uyumluluk için vardır, ancak bunun yerine <function>fwrite</function> kullanılması önerilir. Bkz. <xref linkend="glibc-Block-Input-Output"/>.
   </para>
  </csynopsis>
 </chapter>

 <chapter xml:id="glibc-Character-Input">
  <title>Karakter Girdilerinin Alınması</title>
  <titleabbrev>Biçimlenmemiş karakterlerin ve sözcüklerin girdi olarak alınması.</titleabbrev>
  <para>
   <indexterm linkend="glibc-cp"><primary>akımlar</primary><secondary>okuma</secondary><tertiary>tek karakter</tertiary></indexterm>
   <indexterm linkend="glibc-pg"><primary>stdio.h</primary></indexterm>
   <indexterm linkend="glibc-pg"><primary>wchar.h</primary></indexterm>
   Bu kısımda girdi olarak karakter alan işlevler açıklanmıştır. Bu kısımdaki dar yönlenimli akım işlevleri &stdio.h; başlık dosyasında, geniş yönlenimli akım işlevleri ise &wchar.h; başlık dosyasında bildirilmiştir.
  </para>
  <para>
   Bu işlevler bir karakter girdisinde, dar yönlenimli ise bir <type>int</type> türünden değerle, geniş yönlenimli ise bir <type>wint_t</type> türünden bir değerle ya da <varname>EOF</varname>/<varname>WEOF</varname> özel değeri (genellikle <code>-1</code>) ile döner.
  </para>
  <para>
   Dar yönlenimli akım işlevleri için, işlev sonucunun bir karakter olarak kullanılması tasarlanıyor olsa bile, bu işlevlerin sonucunun <type>char</type> türü yerine <type>int</type> türünden bir değişkene atanması önemlidir. <varname>EOF</varname> değerinin <type>char</type> türünden bir değişkene atanması onun bir karakterlik boyuta indirilmesine sebep olur ki bu durumda artık geçerli bir karakterden (<code>(char) -1</code>) farkı kalmaz. Bu durumda, <function>getc</function> ve arkadaşlarının daima <type>int</type> türünden bir değişkene atanarak çağrılması ve dönen değerin <varname>EOF</varname> olup olmadığına bakılması gerekir. Dönen değer <varname>EOF</varname> değilse  artık <type>char</type> türünden bir değişkene bilgi kaybı olmadan atanabilir.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-fgetc"><primary>fgetc</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-fgetc"><primary>dar karakterler</primary><secondary>akımdan girdi alıması</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>fgetc</function></csname>
    <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
   </csproto>
   <header>&stdio.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&asunsafe; &corrupt;</concept>
    <concept>&acunsafe; &corrupt; &lock;</concept>
   </conceptlist>
   <para>
    Bu işlev <parameter>stream</parameter> akımındaki sonraki karakteri bir <type>unsigned&nbsp;char</type> olarak okur ve değerini <type>int</type> türüne dönüştürerek döndürür. Bir dosya sonu durumunda ya da bir hata oluştuğunda hata durumu yerine <varname>EOF</varname> ile döner.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-fgetwc"><primary>fgetwc</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-fgetwc"><primary>geniş karakterler</primary><secondary>akımdan girdi alıması</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>wint_t</type><function>fgetwc</function></csname>
    <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
   </csproto>
   <header>&wchar.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&asunsafe; &corrupt;</concept>
    <concept>&acunsafe; &corrupt; &lock;</concept>
   </conceptlist>
   <para>
    Bu işlev <parameter>stream</parameter> akımındaki sonraki geniş karakteri okur ve değerini döndürür. Bir dosya sonu durumunda ya da bir hata oluştuğunda hata durumu yerine <varname>WEOF</varname> ile döner.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-fgetc_unlocked"><primary>fgetc_unlocked</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-fgetc_unlocked"><primary>dar karakterler</primary><secondary>akımdan (kilitsiz) girdi alıması</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>fgetc_unlocked</function></csname>
    <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
   </csproto>
   <header>&stdio.h;</header>
   <conceptlist>
    <concept>&mtsafe; &race;<code linkend="glibc-safety-identifier">:stream</code></concept>
    <concept>&asunsafe; &corrupt;</concept>
    <concept>&acunsafe; &corrupt;</concept>
   </conceptlist>
   <para>
    <code>fgetc_unlocked</code> işlevi akımı örtük olarak kilitlememesi dışında <function>fgetc</function> işlevine eşdeğerdir.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-fgetwc_unlocked"><primary>fgetwc_unlocked</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-fgetwc_unlocked"><primary>geniş karakterler</primary><secondary>akımdan (kilitsiz) girdi alıması</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>wint_t</type><function>fgetwc_unlocked</function></csname>
    <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
   </csproto>
   <header>&wchar.h;</header>
   <conceptlist>
    <concept>&mtsafe; &race;<code linkend="glibc-safety-identifier">:stream</code></concept>
    <concept>&asunsafe; &corrupt;</concept>
    <concept>&acunsafe; &corrupt;</concept>
   </conceptlist>
   <para>
    <code>fgetwc_unlocked</code> işlevi akımı örtük olarak kilitlememesi dışında <function>fgetwc</function> işlevine eşdeğerdir.
   </para>
   <para>
    Bu işlev GNU oluşumudur.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-getc"><primary>getc</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-getc"><primary>dar karakterler</primary><secondary>akımdan karakter okumak</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>getc</function></csname>
    <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
   </csproto>
   <header>&stdio.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&asunsafe; &corrupt;</concept>
    <concept>&acunsafe; &lock; &corrupt;</concept>
   </conceptlist>
   <para>
    Birçok sistemin daha hızlı olması için bir makro olarak gerçeklemesi dışında tamamen <function>fgetc</function> gibidir. Makrolar için genel kurala bir istisna olarak <parameter>stream</parameter> bağımsız değişkenini bir kereden fazla değerlendirebilmesi işleve önem kazandırır. Genellikle <code>getc</code> işlevi tek bir karakterin okunması için kullanılacak en iyi işlevdir.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-getwc"><primary>getwc</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-getwc"><primary>dar karakterler</primary><secondary>akımdan karakter okumak</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>wint_t</type><function>getwc</function></csname>
    <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
   </csproto>
   <header>&wchar.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&asunsafe; &corrupt;</concept>
    <concept>&acunsafe; &lock; &corrupt;</concept>
   </conceptlist>
   <para>
    Birçok sistemin daha hızlı olması için bir makro olarak gerçeklemesi dışında tamamen <function>fgetwc</function> gibidir. Makrolar için genel kurala bir istisna olarak <parameter>stream</parameter> bağımsız değişkenini bir kereden fazla değerlendirebilmesi işleve önem kazandırır. Genellikle <code>getwc</code> işlevi tek bir geniş karakterin okunması için kullanılacak en iyi işlevdir.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-getc_unlocked"><primary>getc_unlocked</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-getc_unlocked"><primary>dar karakterler</primary><secondary>akımdan (kilitsiz) karakter okumak</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>getc_unlocked</function></csname>
    <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
   </csproto>
   <header>&stdio.h;</header>
   <conceptlist>
    <concept>&mtsafe; &race;<code linkend="glibc-safety-identifier">:stream</code></concept>
    <concept>&asunsafe; &corrupt;</concept>
    <concept>&acunsafe; &corrupt;</concept>
   </conceptlist>
   <para>
    <code>getc_unlocked</code> işlevi akımı örtük olarak kilitlememesi dışında <function>getc</function> işlevine eşdeğerdir.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-getwc_unlocked"><primary>getwc_unlocked</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-getwc_unlocked"><primary>geniş karakterler</primary><secondary>akımdan (kilitsiz) geniş karakter okumak</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>wint_t</type><function>getwc_unlocked</function></csname>
    <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
   </csproto>
   <header>&wchar.h;</header>
   <conceptlist>
    <concept>&mtsafe; &race;<code linkend="glibc-safety-identifier">:stream</code></concept>
    <concept>&asunsafe; &corrupt;</concept>
    <concept>&acunsafe; &corrupt;</concept>
   </conceptlist>
   <para>
    <code>getwc_unlocked</code> işlevi akımı örtük olarak kilitlememesi dışında <function>getwc</function> işlevine eşdeğerdir.
   </para>
   <para>
    Bu işlev GNU oluşumudur.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-getchar"><primary>getchar</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-getchar"><primary>dar karakterler</primary><secondary>standart girdiden karakter okumak</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>getchar</function></csname>
    <csparam><void/></csparam>
   </csproto>
   <header>&stdio.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&asunsafe; &corrupt;</concept>
    <concept>&acunsafe; &lock; &corrupt;</concept>
   </conceptlist>
   <para>
    <code>getchar</code> işlevi <function>getc</function> işlevinin <parameter>stream</parameter> bağımsız değişkenine değer olarak <varname>stdin</varname> belirtilerek çağrılmasına eşdeğerdir. Yani bu işlev bir karakteri doğrudan standart girdiden okur.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-getwchar"><primary>getwchar</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-getwchar"><primary>geniş karakterler</primary><secondary>standart girdiden karakter okumak</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>wint_t</type><function>getwchar</function></csname>
    <csparam><void/></csparam>
   </csproto>
   <header>&wchar.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&asunsafe; &corrupt;</concept>
    <concept>&acunsafe; &lock; &corrupt;</concept>
   </conceptlist>
   <para>
    <code>getwchar</code> işlevi <function>getwc</function> işlevinin <parameter>stream</parameter> bağımsız değişkenine değer olarak <varname>stdin</varname> belirtilerek çağrılmasına eşdeğerdir.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-getchar_unlocked"><primary>getchar_unlocked</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-getchar_unlocked"><primary>dar karakterler</primary><secondary>standart girdiden (kilitsiz) karakter okumak</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>getchar_unlocked</function></csname>
    <csparam><void/></csparam>
   </csproto>
   <header>&stdio.h;</header>
   <conceptlist>
    <concept>&mtunsafe; &race;<code linkend="glibc-safety-identifier">:stdin</code></concept>
    <concept>&asunsafe; &corrupt;</concept>
    <concept>&acunsafe; &corrupt;</concept>
   </conceptlist>
   <para>
    <code>getchar_unlocked</code> işlevi akımı örtük olarak kilitlememesi dışında <function>getchar</function> işlevine eşdeğerdir.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-getwchar_unlocked"><primary>getwchar_unlocked</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-getwchar_unlocked"><primary>geniş karakterler</primary><secondary>standart girdiden (kilitsiz) karakter okumak</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>wint_t</type><function>getwchar_unlocked</function></csname>
    <csparam><void/></csparam>
   </csproto>
   <header>&wchar.h;</header>
   <conceptlist>
    <concept>&mtunsafe; &race;<code linkend="glibc-safety-identifier">:stdin</code></concept>
    <concept>&asunsafe; &corrupt;</concept>
    <concept>&acunsafe; &corrupt;</concept>
   </conceptlist>
   <para>
    <code>getwchar_unlocked</code> işlevi akımı örtük olarak kilitlememesi dışında <function>getwchar</function> işlevine eşdeğerdir.
   </para>
   <para>
    Bu işlev GNU oluşumudur.
   </para>
  </csynopsis>
  <example>
   <para>
    Aşağıda <function>fgetc</function> kullanarak girdi alan bir işlev örneği vardır. İşlev <code>fgetc&nbsp;(stdin)</code> yerine <function>getc</function> ya da <function>getchar</function> kullanarak da çalışırdı. Kod ayrıca geniş yönlenimli akım işlevleri için de aynı şekilde çalışırdı.
  </para>
  <screen>int
e_veya_h (const char *soru)
{
  fputs (soru, stdout);
  while (1)
    {
      int c, cevap;
      /* <replaceable>Bir boşluk ile yanıtı sorudan ayır.</replaceable> */
      fputc (' ', stdout);
      /* <replaceable>Satırdan ilk karakteri oku.
         Bu yanıt karakteri olmalı ama olmayabilir.</replaceable> */
      c = tolower (fgetc (stdin));
      answer = c;
      /* <replaceable>Satırın kalanını iptal et.</replaceable> */
      while (c != '\n' &amp;&amp; c != EOF)
        c = fgetc (stdin);
      /* <replaceable>Yanıt geçerliyse uygun dönüşü yap.</replaceable> */
      if (cevap == 'y')
        return 1;
      if (cevap == 'n')
        return 0;
      /* <replaceable>Yanıt geçersiz: Geçerli yanıtı almaya çalış.</replaceable> */
      fputs (&quot;Yanıtınız e ya da h olmalı: &quot;, stdout);
    }
}
</screen>
  </example>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-getw"><primary>getw</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-getw"><primary>dar karakterler</primary><secondary>standart girdiden (kilitsiz) karakter okumak</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>getw</function></csname>
    <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
   </csproto>
   <header>&stdio.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&asunsafe; &corrupt;</concept>
    <concept>&acunsafe; &lock; &corrupt;</concept>
   </conceptlist>
   <para>
    <code>getchar_unlocked</code> işlevi bir sözcüğü (<type>int</type> türünde) <parameter>stream</parameter> akımından okur. SVID ile uyumluluk için vardır, ancak bunun yerine <function>fread</function> kullanılması önerilir. Bkz. <xref linkend="glibc-Block-Input-Output"/>. <function>getc</function> işlevinin tersine herhangi <type>int</type> türünden değer geçerli sonuç olmalıydı. İşlev bir hata oluştuğunda ya da dosya sonu saptandığında <varname>EOF</varname> ile döner, ancak <code>-1</code> değerini geçerli sözcükten ayırmak için bir yol yoktur.
   </para>
  </csynopsis>
 </chapter>
 <chapter xml:id="glibc-Line-Input">
  <title>Satır Yönlenimli Girdi</title>
  <titleabbrev>Bir akımdan bir kaydın ya da satırın okunması.</titleabbrev>
  <para>
   Birçok yazılım girdiyi satır temelinde yorumladığından bir akımdan bir metin satırını okuyacak işlevlerin de bulunması yararlıdır.
  </para>
  <para>
   Standart C bunu yapacak işlevlere sahiptir ama onlar çok güvenilir değildir: Boş karakterler ve hatta uzun satırlar (<function>gets</function> için) onları şaşırtabilir. Bu nedenle &glibc; satırları güvenilir bir şekilde kolayca okumak için standart olmayan <function>getline</function> işlevini içerir.
  </para>
  <para>
   Diğer bir GNU oluşumu olan <function>getdelim</function> işlevi, <function>getline</function> işlevini genelleştirir. İşlev belirtilmiş bir ayraç karakteriyle ayrılmış kayıtlardan bir kaydı okur.
  </para>
  <para>
   Bu işlevlerin tümü &stdio.h; başlık dosyasında bildirilmiştir.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-getline"><primary>getline</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-getline"><primary>akımlar</primary><secondary>satır okumak</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>ssize_t</type><function>getline</function></csname>
    <csparam><pptr>char</pptr><parameter>lineptr</parameter></csparam>
    <csparam><ptr>size_t</ptr><parameter>n</parameter></csparam>
    <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
   </csproto>
   <header>&stdio.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&asunsafe; &corrupt; &heap;</concept>
    <concept>&acunsafe; &lock; &corrupt; &mem;</concept>
   </conceptlist>
   <para>
    Bu işlev <parameter>stream</parameter> akımından tam bir satır okur, metni satır sonu karakteri ve bir sonlandırıcı boş karakterle bir tampona yazar ve tamponun adresini *<parameter>lineptr</parameter> içinde saklar.
   </para>
   <para>
    <code>getline</code> çağrısından önce, *<parameter>n</parameter> bayt uzunluğundaki <function>malloc</function> ile tahsis edilmiş tamponun adresi  *<parameter>lineptr</parameter> içine yerleştirilmelidir. Bu tampon yeterli uzunluktaysa, <code>getline</code> okuduğu satırı bu tampona yazar. Aksi takdirde <code>getline</code>, <function>realloc</function> kullanarak tamponu büyütür ve yeni tampon adresini *<parameter>lineptr</parameter> bağımsız değişkeni ile ve artırdığı uzunluğu *<parameter>n</parameter> bağımsız değişkeni ile döndürür. Bkz. <xref linkend="glibc-Unconstrained-Allocation"/>.
   </para>
   <para>
    *<parameter>lineptr</parameter> olarak boş gösterici ve *<parameter>n</parameter> için <code>0</code> değeri ile çağrı yapılırsa, <code>getline</code> işlevi <function>malloc</function> işlevini kullanarak tamponu özdevinimli olarak tahsis eder.
   </para>
   <para>
    Her iki durumda, <code>getline</code> döndüğünde,  *<parameter>lineptr</parameter> satırın metnini gösteren  bir <type>char&nbsp;*</type>’dır.
   </para>
   <para>
    <code>getline</code> başarılı olduğunda okunan karakterlerin sayısı (satır sonu karakteri ve boş karakter dahil) ile döner. Bu değer satırın parçası olan boş karakterlerim sonlandırıcı olarak eklenen boş karakterden ayırt edilebilmesini sağlar.
   </para>
   <para>
    Bu işlev bir GNU oluşumudur ve bir akımdan satırları okumak için önerilen bir yoldur. Aynı amaçlı diğer standart işlevler güvenilir değildir.
   </para>
   <para>
    Bir hata oluşursa ya da herhangi bir bayt okunmadan dosya sonuna gelinirse <code>getline</code> işlevi <code>-1</code> ile döner.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-getdelim"><primary>getdelim</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-getdelim"><primary>akımlar</primary><secondary>ayraçla satır okumak</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>ssize_t</type><function>getdelim</function></csname>
    <csparam><pptr>char</pptr><parameter>lineptr</parameter></csparam>
    <csparam><ptr>size_t</ptr><parameter>n</parameter></csparam>
    <csparam><type>int</type><parameter>delimiter</parameter></csparam>
    <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
   </csproto>
   <header>&stdio.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&asunsafe; &corrupt; &heap;</concept>
    <concept>&acunsafe; &lock; &corrupt; &mem;</concept>
   </conceptlist>
   <para>
    Bu işlev okumayı sonlandıran karakterin belirtilebilmesi dışında <function>getline</function> gibidir. <parameter>delimiter</parameter> bağımsız değişkeni ile ayraç karakteri belirtilir. İşlev bu karakteri görene kadar ya da bu karakter yoksa dosya sonunu görene kadar metni okur.
   </para>
   <para>
    <parameter>lineptr</parameter> içinde saklanan metin ayraç karakterini ve  sonlandırıcı olarak boş karakter içerir. <function>getline</function> gibi  <code>getdelim</code> işlevi de gerekirse <parameter>lineptr</parameter> tamponunu büyütür.
   </para>
   <para>
    <function>getline</function> işlevi  <code>getdelim</code> işlevi kullanılarak aşağıdaki gibi gerçeklenebilir:
   </para>
   <example>
    <screen>ssize_t
getline (char **lineptr, size_t *n, FILE *stream)
{
  return getdelim (lineptr, n, '\n', stream);
}
</screen>
   </example>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-fgets"><primary>fgets</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-fgets"><primary>akımlar</primary><secondary>satır okumak (önerilmeyen)</secondary></indexterm>
   <csproto type="işlev">
    <csname><ptr>char</ptr><function>fgets</function></csname>
    <csparam><ptr>char</ptr><parameter>s</parameter></csparam>
    <csparam><type>int</type><parameter>count</parameter></csparam>
    <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
   </csproto>
   <header>&stdio.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&asunsafe; &corrupt;</concept>
    <concept>&acunsafe; &lock; &corrupt;</concept>
   </conceptlist>
   <para>
    <code>fgets</code> işlevi <parameter>stream</parameter> akımından satırı satır sonu karakterine kadar bu karakter de dahil olmak üzere okur ve <parameter>s</parameter> dizgesine sonuna boş karakter ekleyerek yerleştirir. <parameter>s</parameter> dizgesindeki alan <parameter>count</parameter> karakterlik belirtilebilir, ancak okunan karakter sayısı <parameter>count</parameter> - 1 olacaktır. Kalan son yer, dizgenin sonunu gösteren boş karakter için kullanılacaktır.
   </para>
   <para>
    <code>fgets</code> çağrısı sırasında sistem zaten dosyanın sonundaysa <parameter>s</parameter> dizisinin içeriği değiştirilmez ve boş gösterici döner. Bir okuma hatası olduğunda da boş gösterici döner. Aksi takdirde dönen değer <parameter>s</parameter> dizisine göstericidir.
   </para>
   <warning>
    <para>
     Girdi verisi boş karakter içeriyorsa bu belirtilemez. Bu nedenle, sadece verinin boş karakter içermediği biliniyorsa <code>fgets</code> işlevi kullanılmalı, yoksa kullanılmamalıdır. Kullanıcı tarafından düzenlenmiş dosyaları okumak için <code>fgets</code> kullanılmamalıdır, çünkü kullanıcı boş karakter girmişse ya onu olması gerektiği gibi okumak ya da bir hata iletisi çıktılamak gerekir. Daha iyisi, <code>fgets</code> yerine <function>getline</function> kullanılması önerilir.
    </para>
   </warning>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-fgetws"><primary>fgetws</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-fgetws"><primary>akımlar</primary><secondary>geniş karakterli satır okumak</secondary></indexterm>
   <csproto type="işlev">
    <csname><ptr>wchar_t</ptr><function>fgetws</function></csname>
    <csparam><ptr>wchar_t</ptr><parameter>ws</parameter></csparam>
    <csparam><type>int</type><parameter>count</parameter></csparam>
    <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
   </csproto>
   <header>&wchar.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&asunsafe; &corrupt;</concept>
    <concept>&acunsafe; &lock; &corrupt;</concept>
   </conceptlist>
   <para>
    <code>fgetws</code> işlevi <parameter>stream</parameter> akımından bir satırı satır sonu karakterine kadar bu karakter de dahil olmak üzere okur ve <parameter>ws</parameter> dizgesine sonuna boş geniş karakter ekleyerek yerleştirir. <parameter>ws</parameter> dizgesindeki alan <parameter>count</parameter> karakterlik belirtilebilir, ancak okunan karakter sayısı <parameter>count</parameter> - 1 olacaktır. Kalan son yer, dizgenin sonunu gösteren boş geniş karakter için kullanılacaktır.
   </para>
   <para>
    <code>fgetws</code> çağrısı sırasında sistem zaten dosyanın sonundaysa <parameter>ws</parameter> dizisinin içeriği değiştirilmez ve boş gösterici döner. Bir okuma hatası olduğunda da boş gösterici döner. Aksi takdirde dönen değer <parameter>ws</parameter> dizisine göstericidir.
   </para>
   <warning>
    <para>
     Girdi verisi boş geniş karakter içeriyorsa bu belirtilemez. Bu nedenle, sadece verinin boş geniş karakter içermediği biliniyorsa <code>fgetws</code> işlevi kullanılmalı, yoksa kullanılmamalıdır. Kullanıcı tarafından düzenlenmiş dosyaları okumak için <code>fgetws</code> kullanılmamalıdır, çünkü kullanıcı boş geniş karakter girmişse ya onu olması gerektiği gibi okumak ya da bir hata iletisi çıktılamak gerekir.
    </para>
   </warning>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-fgets_unlocked"><primary>fgets_unlocked</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-fgets_unlocked"><primary>akımlar</primary><secondary>satır okumak (kilitsiz)</secondary></indexterm>
   <csproto type="işlev">
    <csname><ptr>char</ptr><function>fgets_unlocked</function></csname>
    <csparam><ptr>char</ptr><parameter>s</parameter></csparam>
    <csparam><type>int</type><parameter>count</parameter></csparam>
    <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
   </csproto>
   <header>&stdio.h;</header>
   <conceptlist>
    <concept>&mtsafe; &race;<code linkend="glibc-safety-identifier">:stream</code></concept>
    <concept>&asunsafe; &corrupt;</concept>
    <concept>&acunsafe; &corrupt;</concept>
   </conceptlist>
   <para>
    <code>fgets_unlocked</code> işlevi akımı dolaylı olarak kilitlememesi dışında <function>fgets</function> işlevine eşdeğerdir.
   </para>
   <para>
    Bu işlev GNU oluşumudur.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-fgetws_unlocked"><primary>fgetws_unlocked</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-fgetws_unlocked"><primary>akımlar</primary><secondary>geniş karakterli satır okumak (kilitsiz)</secondary></indexterm>
   <csproto type="işlev">
    <csname><ptr>wchar_t</ptr><function>fgetws_unlocked</function></csname>
    <csparam><ptr>wchar_t</ptr><parameter>ws</parameter></csparam>
    <csparam><type>int</type><parameter>count</parameter></csparam>
    <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
   </csproto>
   <header>&wchar.h;</header>
   <conceptlist>
    <concept>&mtsafe; &race;<code linkend="glibc-safety-identifier">:stream</code></concept>
    <concept>&asunsafe; &corrupt;</concept>
    <concept>&acunsafe; &corrupt;</concept>
   </conceptlist>
   <para>
    <code>fgetws_unlocked</code> işlevi akımı dolaylı olarak kilitlememesi dışında <function>fgetws</function> işlevine eşdeğerdir.
   </para>
   <para>
    Bu işlev GNU oluşumudur.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-gets"><primary>gets</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-gets"><primary>akımlar</primary><secondary>standart girdiden satır okumak (tehlikeli)</secondary></indexterm>
   <csproto type="işlev">
    <csname><ptr>char</ptr><function>gets</function></csname>
    <csparam><ptr>char</ptr><parameter>s</parameter></csparam>
   </csproto>
   <header>&stdio.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&asunsafe; &corrupt;</concept>
    <concept>&acunsafe; &lock; &corrupt;</concept>
   </conceptlist>
   <para>
    <code>gets</code> işlevi standart girdiden satırı satır sonu karakterine kadar okur ve <parameter>s</parameter> dizgesine yerleştirir. Satır sonu karakteri iptal edilir. (İşlev bu davranışı ile  satır sonu karakterini de dizgeye yerleştiren <function>fgets</function>  işlevinden faklıdır.) Bir okuma hatası olduğunda ya da dosya sonu saptandığında boş gösterici döner. Aksi takdirde dönen değer <parameter>s</parameter> dizgesine göstericidir.
   </para>
   <warning>
    <para>
     <code>gets</code> işlevi <wordasword>çok tehlikelidir</wordasword>. Çünkü <parameter>s</parameter> dizgesinin taşmasına karşı bir korumaya sahip değildir. &glibc; işlevi sadece uyumluluk adına içerir. Bunun yerine daima ya <function>fgets</function> ya da <function>getline</function> işlevi kullanılmalıdır. Bunu hatırlatmak için ilintileyici (GNU <uri xl:href="man1-ld"/> kullanılıyorsa) <code>gets</code> kullanılırsa uyaracaktır.
    </para>
   </warning>
  </csynopsis>
 </chapter>

 <chapter xml:id="glibc-Unreading" userlevel="notoc">
  <?dbhtml stop-chunking?>
  <title>Okunmamış Yapmak</title>
  <titleabbrev>Girdinin okunmasından sonra akımın okunmamış gibi bırakılması.</titleabbrev>
  <para>
   <indexterm linkend="glibc-cp"><primary>girdiye öncesinden bakış</primary></indexterm>
   <indexterm linkend="glibc-cp"><primary>karakterlerin okunmamış yapılması</primary></indexterm>
   <indexterm linkend="glibc-cp"><primary>girdiyi geri itme</primary></indexterm>
   Çözümleyici yazılımlarda akımdaki sonraki karakterin ne olduğuna bakmak ama onu akımdan silmeksizin okumak çoğunlukla kullanışlıdır. Buna girdide "ileriye bakış" denir, çünkü yazılımınız daha sonra okuyacağı girdinin anlık bir görüntüsünü alır.
  </para>
  <para>
   Akım G/Ç işlemlerini kullanarak, girdiyi akımdan önce okuyup sonra da okunmamış yaparak (buna girdiyi "geri itme" de denir) girdiye öncesinden bakabilirsiniz. Bir karakterin okunmamış yapılması onu akımdan tekrar okunabilmesi için kullanılabilir yapar. Sonraki bir <function>fgetc</function> çağrısı ya da diğer bir girdi işlevi ile akımdan okunabilir.
  </para>
  <sect1 xml:id="glibc-Unreading-Idea">
   <title>Okunmamış Yapmak Ne Demek</title>
   <titleabbrev>Okunmamış yapmanın resimli anlatımı.</titleabbrev>
   <para>
    Okunmamış yapma işlemi burada görsel örneklerle açıklanmaya çalışılmıştır. Bir dosyayı okuyan bir akımın olduğunu ve dosyanın altı karakter içerdiği varsayılsın. Bu karakterler '<literal>foobar</literal>' olsun. İlk üç karakter okunmuş olsun. Durum bunun gibi olacaktır:
   </para>
   <example>
    <screen>
f  o  o  b  a  r
         ^
</screen>
    <para>
    Yani sonraki girdi karakteri '<code>b</code>' olacaktır.
    </para>
    <para>
     '<code>b</code>' harfini okumak yerine '<code>o</code>' harfi okunmamış yapılırsa durum şöyle olur:
    </para>
    <screen>
f  o  o  b a r
         |
      o--
      ^
</screen>
    <para>
     Böylece sonraki girdi karakterleri '<code>o</code>' ve '<code>b</code>' olacaktır.
    </para>
    <para>
     '<code>o</code>' harfi yerine '<code>9</code>' karakteri okunmamış yapılırsa durum şöyle olur:
    </para>
    <screen>
f  o  o  b a r
         |
      9--
      ^
</screen>
    <para>
     Burada sonraki girdi karakterleri '<code>9</code>' ve '<code>b</code>' olacaktır.
    </para>
   </example>
  </sect1>
  <sect1 xml:id="glibc-How-Unread">
   <title>Okunmamış Nasıl Yapılır</title>
   <titleabbrev>Yanıt: <code>ungetc</code> kullanarak.</titleabbrev>
   <para>
    <function>ungetc</function> işlevi bir karakteri okunmamış yapar, çünkü <command>getc</command> işlevinin eylemini tersine çevirir.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-ungetc"><primary>ungetc</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-ungetc"><primary>akımlar</primary><secondary>karakteri okunmamış yapmak</secondary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>ungetc</function></csname>
     <csparam><type>int</type><parameter>c</parameter></csparam>
     <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
    </csproto>
    <header>&stdio.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&asunsafe; &corrupt;</concept>
     <concept>&acunsafe; &lock; &corrupt;</concept>
    </conceptlist>
    <para>
     <code>ungetc</code> işlevi, <parameter>stream</parameter> akımına sıradaki karakterden önce okunacak ilk girdi olarak <parameter>c</parameter> karakterini yerleştirir.
    </para>
    <para>
     <parameter>c</parameter> karakteri olarak <varname>EOF</varname> verilirse işlev hiçbir işlem yapmaz ve <varname>EOF</varname> ile döner. Bu özelliğini kullanarak, <parameter>c</parameter> karakteri olarak <function>getc</function> işlevinin dönüş değerini vererek <function>getc</function>’den dönen değer üzerinde hata denetimi yapılması gerekmez.
    </para>
    <para>
     Akıma gönderilen karakterin son okunan karakter olması gerekmez. Hatta <command>ungetc</command> kullanmak için akımdan son karakteri okumak da gerekmez. Ancak bir akımdan hiçbir okuma yapmadan bir karakteri akıma geri itmenin de bir anlamı yoktur. &glibc;nde ikil kipte açılmış dosyalar için de bu destek vardır, diğer sistemlerde olmayabilir.
    </para>
    <para>
     &glibc; akıma sadece tek bir karakterin geri itilmesini destekler. Hiçbir okuma yapmadan işlev ard arda iki defa kullanılamaz. Diğer sistemlerde çok sayıda karakter akıma geri itilebilir ve akıma itilen karakterler ters sırada okunabilir; yani, son itilen karakter ilk olarak okunur.
    </para>
    <para>
     Karakterlerin akıma geri itilmesi dosyada bir değişiklik yapmaz, sadece dahili tampon etkilenir. Bir dosya konumlama işlevi (<function>fseek</function>, <function>fseeko</function> ve <function>rewind</function> işlevlerinden biri; bkz. <xref linkend="glibc-File-Positioning"/>) çağrılırsa geri itilmiş olarak bekleyen karakterler iptal edilir.
    </para>
    <para>
     Okunmamış karakter olarak bir akıma itilen karakter dosya sonuna denk gelirse, akımın dosya sonu belirteci temizlenir, çünkü artık akımda okunacak bir karakter vardır. Karakteri okuduktan sonra tekrar dosya sonu saptanacaktır.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-ungetwc"><primary>ungetwc</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-ungetwc"><primary>akımlar</primary><secondary>geniş karakteri okunmamış yapmak</secondary></indexterm>
    <csproto type="işlev">
     <csname><type>wint_t</type><function>ungetwc</function></csname>
     <csparam><type>wint_t</type><parameter>wc</parameter></csparam>
     <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
    </csproto>
    <header>&wchar.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&asunsafe; &corrupt;</concept>
     <concept>&acunsafe; &lock; &corrupt;</concept>
    </conceptlist>
    <para>
     <code>ungetwc</code> işlevi tek bir geniş karakteri geri itmesi dışında <function>ungetc</function> işlevi ile tamamen aynıdır.
    </para>
   </csynopsis>
   <example>
    <para>
     Aşağıdaki örnekte <function>getc</function> ve <function>ungetc</function>  işlevleri akımdaki boşluk karakterlerini ayıklamakta kullanılmıştır. İşlev rastladığı boşluk olmayan her karakteri akıma geri iter. Böylece akım daha sonra okunduğunda bu karakterler okunmamış olarak yeniden okunabilir.
    </para>
    <screen>#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;

void
skip_whitespace (FILE *stream)
{
  int c;
  do
    /* <replaceable>EOF için bir sınama yapmaya gerek yoktur,
       çünkü ungetc EOF'u yok sayar.</replaceable>  */
    c = getc (stream);
  while (isspace (c));
  ungetc (c, stream);
}
</screen>
   </example>
  </sect1>
 </chapter>

 <chapter xml:id="glibc-Block-Input-Output">
  <title>Sabit Uzunlukta Giriş ve Çıkış</title>
  <titleabbrev>Veri dilimleri üzerinde G/Ç işlemleri.</titleabbrev>
  <para>
   <indexterm linkend="glibc-cp"><primary>akımlar</primary><secondary>ikil G/Ç</secondary></indexterm>
   <indexterm linkend="glibc-cp"><primary>akımlar</primary><secondary>dilimli G/Ç</secondary></indexterm>
   <indexterm linkend="glibc-cp"><primary>akımlar</primary><secondary>okuma</secondary><tertiary>sabit uzunlukta</tertiary></indexterm>
   <indexterm linkend="glibc-cp"><primary>akımlar</primary><secondary>yazma</secondary><tertiary>sabit uzunlukta</tertiary></indexterm>
   <indexterm linkend="glibc-pg"><primary>stdio.h</primary></indexterm>
   Bu kısımda veri dilimleri üzerinde giriş ve çıkış işlemlerinin nasıl yapıldığı  anlatılmıştır. Bu işlevler kullanılarak ikil verilerin giriş ve çıkış işlemleri  yapılabileceği gibi satırlar ve karakterler yerine sabit uzunluktaki metinler üzerinde de giriş ve çıkış işlemleri yapılabilir.
  </para>
  <para>
   İkil dosyalar, genellikle, bir çalışan yazılımın içeriği ile aynı biçimdeki veri dilimlerinin okunması ve yazılmasında kullanılır. Başka bir deyişle, istenen bellek dilimleri (sadece karakter ya da dizge nesneleri değil) bir ikil dosyaya kaydedilir ve aynı yazılım tarafından anlamlı olarak tekrar okunur.
  </para>
  <para>
   Verinin ikil biçimde saklanması biçimli G/Ç işlemlerini kullanmaktan çok daha verimlidir. Ayrıca gerçek sayıların ikil biçimde okunması dönüşüm sırasında olası hassasiyet kayıplarının da önüne geçer. Diğer taraftan, ikil dosyalar birçok standart dosya aracıyla (örn., metin düzenleyiciler) ile düzenlenemez ve dilin farklı gerçeklemeleri ya da farklı bilgisayarlar arasında taşınabilir değildir.
  </para>
  <para>
   Bu işlevler &stdio.h; başlık dosyasında bildirilmiştir.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-fread"><primary>fread</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-fread"><primary>akımlar</primary><secondary>ikil verinin okunması</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>size_t</type><function>fread</function></csname>
    <csparam><ptr>void</ptr><parameter>data</parameter></csparam>
    <csparam><type>size_t</type><parameter>size</parameter></csparam>
    <csparam><type>size_t</type><parameter>count</parameter></csparam>
    <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
   </csproto>
   <header>&stdio.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&asunsafe; &corrupt;</concept>
    <concept>&acunsafe; &lock; &corrupt;</concept>
   </conceptlist>
   <para>
    Bu işlev, <parameter>size</parameter> uzunluktaki <parameter>count</parameter> sayıda nesneyi <parameter>stream</parameter> akımından okur ve <parameter>data</parameter> dizisine yazar. Bir hata oluşur veya dosya sonuna ulaşılırsa, okunan nesnelerin sayısı olan ve belirtilen <parameter>count</parameter>’dan küçük bir sayı ile döner. <parameter>size</parameter> ya da <parameter>count</parameter> sıfır değeriyle verilmişse işlev hiçbir işlem yapmaz ve sıfır ile döner.
   </para>
   <para>
    İşlev bir nesnenin ortasında dosya sonu saptarsa tamamen okunabilen nesnelerin sayısı ile döner ve kısmen okunan nesneyi iptal eder. Bu nedenle gerçek dosya sonu akımda kalır.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-fread_unlocked"><primary>fread_unlocked</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-fread_unlocked"><primary>akımlar</primary><secondary>ikil verinin kilitsiz okunması</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>size_t</type><function>fread_unlocked</function></csname>
    <csparam><ptr>void</ptr><parameter>data</parameter></csparam>
    <csparam><type>size_t</type><parameter>size</parameter></csparam>
    <csparam><type>size_t</type><parameter>count</parameter></csparam>
    <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
   </csproto>
   <header>&stdio.h;</header>
   <conceptlist>
    <concept>&mtsafe; &race;<code linkend="glibc-safety-identifier">:stream</code></concept>
    <concept>&asunsafe; &corrupt;</concept>
    <concept>&acunsafe; &corrupt;</concept>
   </conceptlist>
   <para>
    <code>fread_unlocked</code> işlevi akımı dolaylı olarak kilitlememesi dışında <function>fread</function> işlevine eşdeğerdir.
   </para>
   <para>
    Bu işlev GNU oluşumudur.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-fwrite"><primary>fwrite</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-fwrite"><primary>akımlar</primary><secondary>ikil verinin yazılması</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>size_t</type><function>fwrite</function></csname>
    <csparam><ptr>const&nbsp;void</ptr><parameter>data</parameter></csparam>
    <csparam><type>size_t</type><parameter>size</parameter></csparam>
    <csparam><type>size_t</type><parameter>count</parameter></csparam>
    <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
   </csproto>
   <header>&stdio.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&asunsafe; &corrupt;</concept>
    <concept>&acunsafe; &lock; &corrupt;</concept>
   </conceptlist>
   <para>
    Bu işlev, <parameter>size</parameter> uzunluktaki <parameter>count</parameter> sayıda nesneyi <parameter>data</parameter> dizisinden okur ve <parameter>stream</parameter> akımına yazar. İşlev başarılı olursa <parameter>count</parameter> ile döner. Farklı bir değer dönmüşse bu, alan yetersizliği gibi bazı hataları belirtir.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-fwrite_unlocked"><primary>fwrite_unlocked</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-fwrite_unlocked"><primary>akımlar</primary><secondary>ikil verinin kilitsiz yazılması</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>size_t</type><function>fwrite_unlocked</function></csname>
    <csparam><ptr>const&nbsp;void</ptr><parameter>data</parameter></csparam>
    <csparam><type>size_t</type><parameter>size</parameter></csparam>
    <csparam><type>size_t</type><parameter>count</parameter></csparam>
    <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
   </csproto>
   <header>&stdio.h;</header>
   <conceptlist>
    <concept>&mtsafe; &race;<code linkend="glibc-safety-identifier">:stream</code></concept>
    <concept>&asunsafe; &corrupt;</concept>
    <concept>&acunsafe; &corrupt;</concept>
   </conceptlist>
   <para>
    <code>fwrite_unlocked</code> işlevi akımı dolaylı olarak kilitlememesi dışında <function>fwrite</function> işlevine eşdeğerdir.
   </para>
   <para>
    Bu işlev GNU oluşumudur.
   </para>
  </csynopsis>
 </chapter>

 <chapter xml:id="glibc-Formatted-Output">
  <title>Biçimli Çıktı</title>
  <titleabbrev><code>printf</code> ve ilgili işlevler.</titleabbrev>
  <preliminary>
   <para>
    <indexterm linkend="glibc-cp"><primary>biçimli çıktı</primary><secondary>biçim dizgesi</secondary></indexterm>
    <indexterm linkend="glibc-cp"><primary>biçimli çıktı</primary><secondary>kalıp dizge</secondary></indexterm>
    <indexterm linkend="glibc-cp"><primary>akımlar</primary><secondary>yazma</secondary><tertiary>biçimli</tertiary></indexterm>
    Bu kısımda açıklanan işlevler (<function>printf</function> ve ilgili işlevler) biçimli çıktılama için kullanışlı bir yol sağlar. <function>printf</function> işlevi kalan bağımsız değişkenlerin değerlerinin nasıl biçimlendirileceğini belirten bir <wordasword>biçem dizgesi</wordasword> veya bir <wordasword>kalıp dizgesi</wordasword> ile çağrılır.
   </para>
   <para>
    Yazılım, satır ya da karakter yönlenimli işlemler uygulayan bir süzme aracı değilse, bu kısımda açıklanan <function>printf</function> veya diğer bir benzer işlevle veri biçimli olarak kolayca çıktılanabilir. Bu işlevler özellikle hata iletilerini, tabloları ve benzerlerini basmak için kullanışlıdır.
   </para>
  </preliminary>

  <sect1 xml:id="glibc-Formatted-Output-Basics">
   <title>Biçimli Çıktılamanın Temelleri</title>
   <titleabbrev>Başlangıçta bilinmesi gerekenler.</titleabbrev>
   <para>
    <indexterm linkend="glibc-cp"><primary>biçimli çıktı</primary><secondary>dönüşüm belirtimleri</secondary></indexterm>
    <function>printf</function> işlevi istenen sayıda bağımsız değişkeni basmak için  kullanılabilir. İşlev çağrılırken belirtilecek kalıp dizgesi içinde sadece ek bağımsız değişkenlerin sayısına ilişkin bilgi değil türleri ve nasıl biçimlenerek çıktılanacağına ilişkin bilgiler de verilebilir.
   </para>
   <para>
    Kalıp dizgesi içindeki özellik içermeyen karakterler oldukları gibi akıma  çıktılanırken kalıp dizgesi içindeki bir <code>%</code> karakteri ile vurgulanan <wordasword>dönüşüm belirtimleri</wordasword> alt bileşen bağımsız değişkenlerin biçimlenerek akıma çıktılanmasını sağlar.
   </para>
   <example>
    <screen>int pct = 37;
char filename[] = "foo.txt";
printf ("`%s' dosyasının %%%d'lik kısmı işlendi.\nLütfen sabırlı olun.\n",
	filename, pct);
</screen>
   <para>
    kodu şöyle bir çıktı üretir:
   </para>
   <screen>`foo.txt' dosyasının %37'lik kısmı işlendi.
Lütfen sabırlı olun.
</screen>
   <para>
    Bu örnekteki <code>%d</code> biçimleyeceği ikinci art bileşen bağımsız değişkenin <type>int</type> türünden olduğunu ve bir onluk tamsayı olarak basılacağını belirtir. <code>%s</code> ise ilk art bileşen bağımsız değişkenin bir dizge olduğunu belirtir. <code>%d</code> belirtimini önceleyen <code>%%</code> karakterleri <code>%</code> imi olarak yorumlanır.
   </para>
  </example>
  <para>
   Bir tamsayı bağımsız değişkenin bir işaretsiz sekizlik, onluk ya da onaltılık tabanda bir sayı olarak (sırasıyla <code>%o</code>, <code>%u</code>, <code>%x</code>) ya da bir karakter <code>%c</code>) olarak yorumlanmasını sağlanabilir.
  </para>
  <para>
   Bir gerçek sayı, <code>%f</code> ile ondalık gösterimde (kaymayan noktalı), <code>%e</code> ile üstel gösterimde (kayan noktalı) basılabilir. <code>%g</code> dönüşümü ile gerçek sayıya, sayının büyüklüğüne bağlı olarak  <code>%f</code> veya <code>%g</code> dönüşümü uygulanır.
   </para>
   <para>
    Biçimlemeyi <code>%</code> ile dönüşüm karakteri arasına <wordasword>değiştiriciler</wordasword> yerleştirerek daha hassas olarak ayarlamak mümkündür. Bunlar kimi zaman normal dönüşüm davranışını oldukça değiştirebilir. Örneğin, dönüşüm belirtimlerinin çoğu bir en küçük alan genişliği ile alanın sağa mı yoksa sola mı yanaştırılarak yazılacağını belirleyen imlerin kullanılmasına izin verir.
   </para>
   <para>
    Bu tür değiştirici ve imler dönüşüm türüne bağlı olarak farklı yorumlanabilir. Bunlar başta oldukça karmaşık görünebilir; ancak bir değiştirici ya da im kullanmadan da serbest biçimde gayet anlamlı çıktılar üretilebilir. Bu değiştirici ve imler özellikle ve çoğunlukla tablo benzeri çıktılarda daha hoş görünümler elde etmek amacıyla kullanılır.
   </para>
  </sect1>
  <sect1 xml:id="glibc-Output-Conversion-Syntax">
   <title>Çıktı Dönüşüm Sözdizimi</title>
   <titleabbrev>Dönüşüm belirtimlerinin genel sözdizimi.</titleabbrev>
   <para>
    Bu bölümde bir <function>printf</function> kalıp dizgesindeki dönüşüm belirtimlerinin tam sözdizimi ayrıntılarıyla açıklanmıştır.
   </para>
   <para>
    Kalıp dizgesindeki bir dönüşüm belirtiminin parçası olmayan karakterler akıma oldukları gibi çıktılanır. Kalıp dizgesinde çok baytlı karakter dizileri de kullanılabilir (Bkz. <xref linkend="glibc-Character-Set-Handling"/>).
   </para>
   <para>
    Bir <function>printf</function> kalıp dizgesindeki dönüşüm belirtimlerinin genel sözdizimi:
   </para>
   <literallayout class="monospaced"><code>% [ <replaceable>konum</replaceable> $] <replaceable>imler</replaceable> <replaceable>genişlik</replaceable> [ . <replaceable>hassasiyet</replaceable> ] <replaceable>tür</replaceable> <replaceable>dönüşüm</replaceable></code>
</literallayout>
   <para>veya</para>
   <literallayout class="monospaced"><code>% [ <replaceable>konum</replaceable> $] <replaceable>imler</replaceable> <replaceable>genişlik</replaceable> . * [ <replaceable>konum</replaceable> $] <replaceable>tür</replaceable> <replaceable>dönüşüm</replaceable></code>
</literallayout>
   <para>
    <dicterm><english>conversion specification</english><turkish> dönüşüm belirteci (biçimleme için)</turkish></dicterm>
    Örneğin, <code>%-10.8ld</code> dönüşüm belirtecinde, <code>-</code> ile im, <code>10</code> ile alan genişliği, <code>8</code> ile hassasiyet, <code>l</code> ile veri türü, <code>d</code> ile dönüşüm tarzı belirtilmektedir. (Bu dönüşüm belirteci art bileşen bağımsız değişkeninin en az <code>10</code> karakter genişlikteki alana onluk tabanda <code>8</code> basamaklı <type>long&nbsp;int</type> türündeki değerinin sola yanaşık olarak basılacağını belirtir.)
   </para>
   <para>
    Çıktı dönüşüm belirtimlerinde <code>%</code> imini izleyen  belirteçler sırayla aşağıda açıklanmıştır:
   </para>
   <itemizedlist>
    <listitem>
     <para>
      İsteğe bağlı <replaceable>konum</replaceable>. Normalde <function>printf</function> işlevi, kalıp dizgesini izleyen bağımsız değişkenleri verildikleri sıraya göre basar. Ancak bazı durumlarda (örneğin çevirilerde) bu sıra uygun düşmez ve bunların sırasını değiştirmek gerekir. Bu sıra değişikliği <replaceable>konum</replaceable> ile belirtilir.
     </para>
     <para>
      Sözdizimindeki <replaceable>konum</replaceable> parçası 1’den çağrıdaki art bileşen bağımsız değişkenlerinin sayısına kadar bir aralıkta bir tamsayı olmalıdır. Bazı gerçeklenimler belirtilebilecek artbileşen bağımsız değişkenlerinin sayısına bir üst sınır koyar. Bu sınır değer aşağıdaki sabit ile belirlenir.
     </para>
     <csynopsis>
      <indexterm linkend="glibc-vr" xml:id="glibc-vr-NL_ARGMAX"><primary>NL_ARGMAX</primary></indexterm>
      <csproto type="sabit">
       <csname><function>NL_ARGMAX</function></csname>
      </csproto>
      <para>
       <code>NL_ARGMAX</code> sabitinin değeri bir <function>printf</function> çağrısında belirtilebilecek art bileşen bağımsız değişkenlerin sayısının üst sınırıdır. Çalışma anında etkin olan bu değer <function>sysconf</function> işlevinin <parameter>parameter</parameter> bağımsız değişkeninde <command>_SC_NL_ARGMAX</command> kullanılarak alınabilir. Bkz.  <xref linkend="glibc-Sysconf-Definition"/>.
      </para>
      <para>
       Bazı sistemler oldukça düşük değerlere sahiptir, örneğin System&nbsp;V için bu değer 9'dur. &glibc;nde böyle bir sınır yoktur.
      </para>
     </csynopsis>
     <para>
      Biçemlerden herhangi birinde <replaceable>konum</replaceable> belirtilmişse diğerlerinde de olmalıdır. Aksi takdirde, işlevin davranışı tanımlanmamıştır.
     </para>
    </listitem>
    <listitem>
     <para>
      <indexterm linkend="glibc-cp" xml:id="glibc-cp-im"><primary>biçimli çıktı</primary><secondary>im karakteri</secondary></indexterm>
      Dönüşüm belirtiminin normal davranışını değiştiren sıfır veya daha fazla  <wordasword>im karakteri</wordasword>.
     </para>
    </listitem>
    <listitem>
     <para>
      <indexterm linkend="glibc-cp"><primary>biçimli çıktı</primary><secondary>en küçük alan genişliği</secondary></indexterm>
      <wordasword>En küçük alan genişliği</wordasword>ni belirten isteğe bağlı bir onluk tamsayı. Normal dönüşüm bundan daha az karakter üretiyorsa eksik karakterlerin yeri boşluklarla doldurulur. Bu bir <emphasis>en küçük</emphasis> değerdir; normal dönüşüm bundan daha fazla karakter üretiyorsa, değer alan genişliği ile sınırlanmaz.  Normalde çıktı alan içinde sağa yanaştırılır.
     </para>
     <para>
      Alan genişliği <code>*</code> ile de belirtilebilir. Bu durumda bağımsız değişken listesindeki sonraki bağımsız değişken alan genişliği olarak kullanılır. Değer <type>int</type> türünde olmalıdır. Değer negatifse  <code>-</code> imi im karakteri olarak, mutlak değer ise alan genişliği olarak kullanılır.
     </para>
    </listitem>
    <listitem>
     <para>
      <dicterm><english>precision</english><turkish>hassasiyet</turkish></dicterm>
      <indexterm linkend="glibc-cp" xml:id="glibc-cp-hassasiyet"><primary>biçimli çıktı</primary><secondary>hassasiyet</secondary></indexterm>
      Sayısal dönüşümlerde basamak sayısını belirtmek için isteğe bağlı <wordasword>hassasiyet</wordasword> değeri. Hassasiyet belirtilmişse, noktadan (<command>.</command>) sonra gelen onluk tamsayıdır (verilmezse sıfırdır).
     </para>
     <para>
      Hassasiyet <code>*</code> ile de belirtilebilir. Bu durumda bağımsız değişken listesindeki sonraki bağımsız değişkenin hassasiyeti olarak kullanılır. Değer <type>int</type> türünde olmalıdır. Negatifse yok sayılır. Hem alan genişliği hem de hassasiyet <code>*</code> ile belirtilirse, alan genişliği hassasiyetten önce olmalıdır. Diğer C kütüphanesi sürümleri bu sözdizimini tanımayabilir.
     </para>
    </listitem>
    <listitem>
     <para>
      <indexterm linkend="glibc-cp" xml:id="glibc-cp-tür-değiştirme"><primary>biçimli çıktı</primary><secondary>tür değiştirme karakteri</secondary></indexterm>
      İsteğe bağlı bir <wordasword>tür değiştirme karakteri</wordasword>; art bileşen bağımsız değişkenin türünden farklı bir tür belirtmek için kullanılır. (Örneğin tamsayı dönüşümleri <type>int</type> türünde varsayılır, ama <code>h</code>, <code>l</code> veya <code>L</code> harfi ile başka bir tür belirtilebilir.)
     </para>
    </listitem>
    <listitem>
     <para>
      <indexterm linkend="glibc-cp" xml:id="glibc-cp-belirtec"><primary>biçimli çıktı</primary><secondary>dönüşüm belirteci</secondary></indexterm>
      Uygulanacak dönüşümü belirten bir karakter (<wordasword>dönüşüm belirteci</wordasword>).
     </para>
    </listitem>
   </itemizedlist>
   <para>
    İzin verilen seçenekler ve yorumlanışları farklı dönüşüm belirteçleri için aynı değildir. Bir seçeneğin kullanıldığı bir dönüşümdeki yorumlanışı ile ilgili bilgiler, o dönüşümün açıklamalarında bulunabilir.
   </para>
   <para>
    <option>-Wformat</option> seçeneği ile GNU C derleyicisi <function>printf</function> ve ilgili işlevleri denetler. Biçim dizgesine bakarak doğru sayı ve türde bağımsız değişken belirtilip belirtilmediğini denetler. Yazılan <function>printf</function> tarzı biçem dizgesini denetlemek için GNU C sözdizimini derleyiciye söyleyecek bir işlev de vardır. (Bkz: GCC info'sundaki <link xl:href="https://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html#Function-Attributes">"İşlev Özniteliklerinin Bildirilmesi"</link> [Declaring Attributes  of Functions])
   </para>
  </sect1>
  <sect1 xml:id="glibc-Table-of-Output-Conversions">
   <title>Çıktı Dönüşümlerinin Listesi</title>
   <titleabbrev>Çıktı dönüşümleri ve ne yaptıklarının bir özeti.</titleabbrev>
   <para>
    <indexterm linkend="glibc-cp"><primary>biçimli çıktı</primary><secondary>çıktı dönüşüm belirteçleri</secondary></indexterm>
    Aşağıda tüm farklı dönüşümler özetlenmiştir:
   </para>
   <variablelist>
    <varlistentry>
     <term>'<code>%d</code>', '<code>%i</code>'</term>
     <listitem>
      <para>
       Tamsayıyı imli onluk sayı olarak basar. Bkz. <xref linkend="glibc-Integer-Conversions"/>. '<code>%d</code>' ve '<code>%i</code>' çıktı için eşanlamlıdır ama <function>scanf</function> ile girdi için kullanıldıklarında farklıdır (Bkz. <xref linkend="glibc-Table-of-Input-Conversions"/>).
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>'<code>%b</code>', '<code>%B</code>'</term>
     <listitem>
      <para>
       Tamsayıyı imsiz bir ikil sayı olarak basar. ‘<code>%b</code>’ belirteci  ‘<code>#</code>’ seçeneği ile küçük harf ‘<code>b</code>’ kullanırken ‘<code>%B</code>’ ise büyük harf kullanır. ‘<code>%b</code>’ belirteci bir ISO C23 özelliğidir; ‘<code>%B</code>’ belirteci, ISO C23 tarafından önerilen bir genişletmedir. Ayrıntılar için bkz. <xref linkend="glibc-Integer-Conversions"/>
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>'<code>%o</code>'</term>
     <listitem>
      <para>
       Tamsayıyı imsiz sekizlik sayı olarak basar. Ayrıntılar için bkz. <xref linkend="glibc-Integer-Conversions"/>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>'<code>%u</code>'</term>
     <listitem>
      <para>
       Tamsayıyı imsiz onluk sayı olarak basar. Ayrıntılar için bkz. <xref linkend="glibc-Integer-Conversions"/>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>'<code>%x</code>', '<code>%X</code>'</term>
     <listitem>
      <para>
       Tamsayıyı imsiz onaltılık sayı olarak basar. ‘<code>%x</code>’ küçük harfleri, ‘<code>%X</code>’ büyük harfleri kullanır. Ayrıntılar için bkz. <xref linkend="glibc-Integer-Conversions"/>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>'<code>%e</code>', '<code>%E</code>'</term>
     <listitem>
      <para>
       Gerçek sayıyı kayan noktalı üstel gösterimle  basar. ‘<code>%e</code>’ küçük harfleri, ‘<code>%E</code>’ büyük harfleri kullanır. Ayrıntılar için bkz. <xref linkend="glibc-Floating-Point-Conversions"/>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>'<code>%f</code>', '<code>%F</code>'</term>
     <listitem>
      <para>
       Gerçek sayıyı kaymayan noktalı gösterimle basar. ‘<code>%f</code>’ küçük harfleri, ‘<code>%F</code>’ büyük harfleri kullanır. Ayrıntılar için bkz. <xref linkend="glibc-Floating-Point-Conversions"/>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>'<code>%g</code>', '<code>%G</code>'</term>
     <listitem>
      <para>
       Gerçek sayıyı büyüklüğüne uygun olarak ya kaymayan noktalı gösterimle ya da kayan noktalı üstel gösterimle basar. ‘<code>%g</code>’ küçük harfleri, ‘<code>%G</code>’ büyük harfleri kullanır. Ayrıntılar için bkz. <xref linkend="glibc-Floating-Point-Conversions"/>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>'<code>%a</code>', '<code>%A</code>'</term>
     <listitem>
      <para>
       Gerçek sayıyı 2 tabanındaki üstel kısmını onluk sayı, kesir kısmını onaltılık sayı olarak basar. ‘<code>%a</code>’ küçük harfleri, ‘<code>%A</code>’ büyük harfleri kullanır. Ayrıntılar için bkz. <xref linkend="glibc-Floating-Point-Conversions"/>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>'<code>%c</code>‘</term>
     <listitem>
      <para>
       Tek bir karakter basar. Bkz. <xref linkend="glibc-Other-Output-Conversions"/>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>'<code>%C</code>‘</term>
     <listitem>
      <para>
       ‘<code>%lc</code>’ için takma addır. Unix standardı ile uyumluluk için desteklenmektedir.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>'<code>%s</code>‘</term>
     <listitem>
      <para>
       Dizge basar. Ayrıntılar için bkz. <xref linkend="glibc-Other-Output-Conversions"/>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>'<code>%S</code>‘</term>
     <listitem>
      <para>
       ‘<code>%ls</code>’ için takma addır. Unix standardı ile uyumluluk için desteklenmektedir.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>'<code>%p</code>‘</term>
     <listitem>
      <para>
       Gösterici değerini basar. Ayrıntılar için bkz. <xref linkend="glibc-Other-Output-Conversions"/>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>'<code>%n</code>‘</term>
     <listitem>
      <para>
       O ana kadar basılan karakterlerin sayısını alır. Bu belirteç hiçbir çıktı üretmez. Ayrıntılar için bkz. <xref linkend="glibc-Other-Output-Conversions"/>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>'<code>%m</code>‘</term>
     <listitem>
      <para>
       <varname>errno</varname> değerine karşılık olan hata iletisini basar. Bu bir GNU oluşumudur. Ayrıntılar için bkz. <xref linkend="glibc-Other-Output-Conversions"/>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>'<code>%%</code>‘</term>
     <listitem>
      <para>
       Sadece '<code>%</code>' imi basar. Ayrıntılar için  bkz. <xref linkend="glibc-Other-Output-Conversions"/>.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    Dönüşüm belirtecinin sözdizimi geçersizse beklenmeyen şeyler olabilir. Kalıp dizgesinde belirtilenden daha az sayıda art bileşen bağımsız değişken varsa ya da art bileşen bağımsız değişkenlerin türleri ile dönüşüm belirtimleri uyumsuzsa sonucun ne olacağı belli olmaz. Kalıp dizgesinde belirtilenden daha çok sayıda art bileşen bağımsız değişken varsa fazla bağımsız değişkenler basitçe yok sayılır; bu kimi zaman kullanışlıdır.
   </para>
  </sect1>
  <sect1 xml:id="glibc-Integer-Conversions">
   <title>Tamsayı Dönüşümleri</title>
   <titleabbrev>Tamsayıların biçimlendirilmesi ile ilgili ayrıntılar.</titleabbrev>
   <para>
    Bu bölümde ‘<code>%d</code>’, ‘<code>%i</code>’, ‘<code>%b</code>’, ‘<code>%B</code>’, ‘<code>%o</code>’, ‘<code>%u</code>’, ‘<code>%x</code>’ ve ‘<code>%X</code>’ dönüşüm belirteçleri ile kullanılan seçenekler açıklanmıştır. Bu dönüşümler tamsayıları çeşitli biçimlerde basmak için kullanılır.
   </para>
   <para>
    '<code>%d</code>' ve '<code>%i</code>' belirteçlerinin her ikisi de bir imli ondalık sayı olarak; '<code>b</code>' belirteci imsiz ikil, ‘<code>%o</code>’ sekizlik, ‘<code>%u</code>’ onluk ve ‘<code>%x</code>’ onaltılık sayı olarak basılır. <literal>ABCDEF</literal> harflerini kullanan <code>%X</code> belirteci ile <literal>abcdef</literal> harflerini kullanan <code>%x</code> belirteci aynıdır. Çıktısı ‘<code>0b</code>’ ile başlayan ‘<code>%b</code>’ belirteci ‘<code>#</code>’ seçeneğini kullanması dışında çıktısı ‘<code>0B</code>’ ile başlayan ‘<code>%B</code>’ gibidir.
   </para>
   <para>
    Seçenekler ve anlamları:
   </para>
   <variablelist>
    <varlistentry>
     <term>'<code>-</code>‘</term>
     <listitem>
      <para>
       Alan içinde sonucu sola yanaştırır (normalde sağa yanaştırılır).
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>'<code>+</code>‘</term>
     <listitem>
      <para>
       İmli '<code>%d</code>' ve '<code>%i</code>' belirteçleri için değer pozitifse artı işareti basar.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>'&nbsp; '</term>
     <listitem>
      <para>
       İmli '<code>%d</code>' ve '<code>%i</code>' belirteçleri için sonuç bir artı ya da eksi işareti içermiyorsa im yerine boşluk basar. '<code>+</code>' im karakteri belirtilmişse sonuç mutlaka bir im içerir. Hem '<code>+</code>' hem de boşluk karakteri belirtilmişse boşluk yok sayılır.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>'<code>#</code>‘</term>
     <listitem>
      <para>
       '<code>%o</code>' belirteci için sayının hassasiyeti artırılmış gibi '<code>0</code>' ile öncelenmesini sağlar. '<code>%x</code>' veya '<code>%X</code>' için sırasıyla '<code>0x</code>' veya '<code>0X</code>' ile öncelenmesini sağlar. ‘<code>%b</code>’ veya ‘<code>%B</code>’ için için sırasıyla '<code>0b</code>' veya '<code>0B</code>' ile öncelenmesini sağlar. '<code>%d</code>', '<code>%i</code>' veya '<code>%u</code>' için kullanışlı hiçbir şey yapmaz. Bu seçeneğin kullanılması <function>strtoul</function> (<xref linkend="glibc-Parsing-of-Integers"/>) tarafından ve <function>scanf</function> işlevinin '<code>%i</code>' dönüşümü (<xref linkend="glibc-Numeric-Input-Conversions"/>) ile çözümlenen çıktıyı üretir.
      </para>
      <para>
       ‘<filename>%m</filename>’ belirteci için bir hata iletisi (veya çevirisi) yerine bir hata sabiti veya ondalık hata numarası basar.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>‘<code>'</code>‘</term>
     <listitem>
      <para>
       <command>LC_NUMERIC</command> yereline göre sayıyı gruplara ayırır. Bu im bir GNU oluşumudur. Bkz. <xref linkend="glibc-General-Numeric"/>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>‘<code>0</code>‘</term>
     <listitem>
      <para>
       Alanda boş kalan yerleri boşluk yerine sıfırlarla doldurur. Sıfırlar imden ya da taban belirtecinden sonra konur. Bu imle birlikte ‘<code>-</code>‘ imi ya da hassasiyet belirtilmişse bu im yok sayılır.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    Hassasiyet belirtilmişse, görüntülenecek hane sayısıdır ve gerekliyse baştaki sıfırlar üretilir. Hassasiyet belirtilmişse sayı olduğu gibi basılır. Açıkça belirterek sıfır hassasiyetle sıfır değeri dönüştürülmek istenirse hiçbir karakter üretilmez.
   </para>
   <para>
    Tür değiştirici olmaksızın, ilgili bağımsız değişken (imli ‘<code>%i</code>’ ve ‘<code>%d</code>’ dönüşümleri için)  <type>int</type>  ya da (imsiz ‘<code>%b</code>’, ‘<code>%B</code>’, ‘<code>%o</code>’, ‘<code>%u</code>’, ‘<code>%x</code>’ ve ‘<code>%X</code>’ dönüşümleri için) <type>unsigned&nbsp;int</type> olarak ele alınır. <function>printf</function> ve arkadaşları değişkin işlevler olduklarından <type>char</type> ve <type>short</type> bağımsız değişkenler varsayılan bağımsız değişken terfileri tarafından özdevinimli olarak <type>int</type> türüne dönüştürülür. Diğer tamsayı türleri için aşağıdaki tür değiştiricileri kullanılabilir:
   </para>
   <variablelist>
    <varlistentry>
     <term>‘<code>hh</code>’</term>
     <listitem>
      <para>
       Bağımsız değişkenin duruma göre <type>signed&nbsp;char</type> veya <type>unsigned&nbsp;char</type> olarak yorumlanacağını belirtir. Öntanımlı bağımsız değişken terfileri çerçevesinde <type>char</type> türünden bir değer <type>int</type> veya <type>unsigned&nbsp;int</type> türüne terfi ettirilir. Ancak ‘<code>hh</code>’ tür değiştiricisi onu tekrar <type>char</type> türüne çevirir.
      </para>
      <para>
       Bu değiştirici &isoc;99'da tanımlanmıştır.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>‘<code>h</code>’</term>
     <listitem>
      <para>
       Bağımsız değişkenin duruma göre <type>short&nbsp;int</type> veya <type>unsigned&nbsp;short&nbsp;int</type> olarak yorumlanacağını belirtir. Öntanımlı bağımsız değişken terfileri çerçevesinde <type>short</type> türünden bir değer <type>int</type> veya <type>unsigned&nbsp;int</type> türüne terfi ettirilir. Ancak ‘<code>h</code>’ tür değiştiricisi onu tekrar <type>short</type> türüne çevirir.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>‘<code>j</code>’</term>
     <listitem>
      <para>
       Bağımsız değişkenin duruma göre <type>intmax_t</type> veya  <type>uintmax_t</type> olarak yorumlanacağını belirtir.
      </para>
      <para>
       Bu değiştirici &isoc;99'da tanımlanmıştır.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>‘<code>l</code>’</term>
     <listitem>
      <para>
       Bağımsız değişkenin duruma göre <type>long&nbsp;int</type> veya <type>unsigned&nbsp;long&nbsp;int</type> olarak yorumlanacağını belirtir. İki ‘<code>l</code>’ karakteri biraz aşağıda açıklanan ‘<code>L</code>’ değiştiricisine benzer.
      </para>
      <para>
       ‘<code>%c</code>’ veya ‘<code>%s</code>’ belirteci ile birlikte kullanılmışsa bağımsız değişken geniş karakter veya geniş karakter dizgesi olarak yorumlanır. ‘<code>l</code>’ değiştiricisinin bu kullanımı &isoc;90 1. düzeltmesinde tanımlanmıştır.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>
      <glossterm>‘<code>L</code>’</glossterm>
      <glossterm>‘<code>ll</code>’</glossterm>
      <glossterm>‘<code>q</code>’</glossterm>
     </term>
     <listitem>
      <para>
       Üçü de bağımsız değişkenin <type>long&nbsp;long&nbsp;int</type> türünde yorumlanacağını belirtir. (Bu tür GNU C derleyicisi tarafından desteklenmektedir. Fazla uzun tamsayıları desteklemeyen sistemlerde bu değiştirici <type>long&nbsp;int</type> olarak değerlendirilir.)
      </para>
      <para>
       ‘<code>q</code>’ değiştiricisi 4.4 BSD’den gelmektedir. <type>long&nbsp;long&nbsp;int</type> türü kimi zaman <type>int</type> "kare" olarak da isimlendirilir.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>‘<code>t</code>’</term>
     <listitem>
      <para>
       Bağımsız değişkenin <type>ptrdiff_t</type> türünde olduğunu belirtir.
      </para>
      <para>
       Bu değiştirici &isoc;99'da tanımlanmıştır.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>
      <glossterm>‘<code>z</code>’</glossterm>
      <glossterm>‘<code>Z</code>’</glossterm>
     </term>
     <listitem>
      <para>
       Bağımsız değişkenin <type>size_t</type> türünde olduğunu belirtir.
      </para>
      <para>
       ‘<code>z</code>’ değiştiricisi &isoc;99'da tanımlanmıştı. ‘<code>Z</code>’ ise bu tanımdan önceki bir GNU oluşumu olup yeni kodlarda kullanılmamalıdır.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <example><title>Kalıp dizgesi kullanım örneği</title>
    <screen>"|%5d|%-5d|%+5d|%+-5d|% 5d|%05d|%5.0d|%5.2d|%d|\n"
</screen>
    <para>
     ‘<code>%d</code>’ için farklı seçeneklerin kullanıldığı bu dizge aşağıdaki sonuçları verir:
    </para>
    <screen>|    0|0    |   +0|+0   |    0|00000|     |   00|0|
|    1|1    |   +1|+1   |    1|00001|    1|   01|1|
|   -1|-1   |   -1|-1   |   -1|-0001|   -1|  -01|-1|
|100000|100000|+100000|+100000| 100000|100000|100000|100000|100000|
</screen>
    <para>
     Dikkat edilirse, son satırda en küçük alan genişliğine sığmayan bir sayı belirtilmiştir.
    </para>
    <para>
     Burada ise imsiz tamsayılar çeşitli dönüşüm seçenekleri ile kullanılmıştır:
    </para>
    <screen>"|%5u|%5o|%5x|%5X|%#5o|%#5x|%#5X|%#10.8x|\n"
</screen>
    <para>
     Bu dizge aşağıdaki sonuçları verir:
    </para>
<screen>|    0|    0|    0|    0|    0|    0|    0|  00000000|
|    1|    1|    1|    1|   01|  0x1|  0X1|0x00000001|
|100000|303240|186a0|186A0|0303240|0x186a0|0X186A0|0x000186a0|
</screen>
   </example>
  </sect1>
  <sect1 xml:id="glibc-Floating-Point-Conversions">
   <title>Kayan Noktalı Sayı Dönüşümleri</title>
   <titleabbrev>Kayan noktalı sayıların biçimlendirilmesi ile ilgili ayrıntılar.</titleabbrev>
   <para>
    Bu bölümde kayan noktalı sayıların dönüşüm belirtimlerine yer verilmiştir. Bunlar ‘<code>%f</code>’, ‘<code>%e</code>’, ‘<code>%E</code>’, ‘<code>%g</code>’ ve ‘<code>%G</code>’ dönüşümleridir.
   </para>
   <para>
    ‘<code>%f</code>’ dönüşümü bağımsız değişkenini kaymayan noktalı gösterimle şu biçimde çıktılar: <code>[-]<parameter>ddd</parameter>.<parameter>ddd</parameter></code>
   </para>
   <para>
    Buradaki ondalık noktayı izleyen basamakların sayısı hassasiyet ile belirtilebilir.
   </para>
   <para>
    ‘<code>%e</code>’ dönüşümü bağımsız değişkenini üstel gösterimle şu biçimde çıktılar: <code>[-]<parameter>d</parameter>.<parameter>ddd</parameter>[+|-]<parameter>dd</parameter></code>
   </para>
   <para>
    Burada da ondalık noktayı izleyen basamakların sayısı hassasiyet ile belirtilebilir. Üs daima son iki hanede bulunur. ‘<code>%E</code>’ dönüşümü de aynı gösterimi üretir; tek farkla ‘<code>e</code>’ yerine ‘<code>E</code>’ harfi kullanılır.
   </para>
   <para>
    Üs -4’ten küçükse ya da hassasiyete eşit veya daha büyükse ‘<code>%g</code>’ ve ‘<code>%G</code>’ dönüşümleri sırasıyla ‘<code>%e</code>’ ve ‘<code>%E</code>’  ile eşdeğerdir. Aksi takdirde, ‘<code>%f</code>’ ile eşdeğerdir. <code>0</code> hassasiyet <code>1</code> olarak değerlendirilir. Sonucun ondalık kısmının sağındaki sıfırlar kaldırılır ve nokta sadece sağında bir sayı varsa gösterilir.
   </para>
   <para>
    ‘<code>%a</code>’ ve ‘<code>%A</code>’ gerçek sayıyı metin biçiminde çıktılar. Bu çıktı farklı yazılım ve/veya makineler arasında metin verisi olarak aktarılabilir. Sayılar şu biçimde gösterilir: <code>[-]0x<parameter>h</parameter>.<parameter>hhh</parameter>p[+|-]<parameter>dd</parameter></code>
   </para>
   <para>
    Ondalık noktanın solunda sadece bir rakam bulunur. Sayı normalleştirilmemişse bu rakam <code>0</code>'dır. Aksi takdirde gerçeklemede kaç bit ayrıldığına bağlı olarak herhangi bir rakam olabilir. Ondalık noktanın sağındaki basamakların sayısı hassasiyet için belirtilen değerle sınırlıdır. Hassasiyet olarak sıfır verilmişse sayının en doğru gösterilebileceği yeterlikteki (veya <varname>FLT_RADIX</varname> (Bkz. <xref linkend="glibc-Floating-Point-Parameters"/>) değeri 2'nin kuvvetlerindeki bir değer değilse yanyana iki değerin iki ayrı değer olarak seçilebileceği yeterlikte) basamak sayısı kullanılır. ‘<code>%a</code>’ dönüşümü için onaltılık sayı, <code>0x</code> ve <code>p</code> ile gösterilen önek ve üstel değer için küçük harfler kullanılır. ‘<code>%A</code>’ dönüşümünde bunlar için büyük harfler kullanılır. Üstel kısım iki tabanına göre onluk bir sayı olarak en az bir rakamla ifade edilir, ancak değer gerektiriyorsa daha fazla rakam da kullanılabilir.
   </para>
   <para>
    Basılan değer sonsuzluk ya da sayı olmayan bir değerse ve dönüşüm belirteçleri ‘<filename>%a</filename>’, ‘<filename>%e</filename>’, ‘<filename>%f</filename>’ veya ‘<filename>%g</filename>’ ise çıktı sırayla <code>[-]inf</code> ya da <code>nan</code>’dır; dönüşüm belirteçleri ‘<filename>%A</filename>’, ‘<filename>%E</filename>’ veya ‘<filename>%G</filename>’ ise çıktı sırayla <code>[-]INF</code> ya da <code>NAN</code>’dır.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-PRINTF_NAN_LEN_MAX"><primary sortas="PRINTF_NAN_LEN_MAX">_PRINTF_NAN_LEN_MAX</primary></indexterm>
    <csproto type="sabit">
     <csname><function>_PRINTF_NAN_LEN_MAX</function></csname>
    </csproto>
    <header>&stdio.h;</header>
    <para>
     Bazı uygulamalarda sayı olmayan değer, NaN'ın yükü hakkında bilgi içeren daha uzun bir çıktıya neden olabilir; &isoc;23, bu çıktının azami uzunluğunu veren  <code>_PRINTF_NAN_LEN_MAX</code> makrosunu tanımlamıştır.
    </para>
   </csynopsis>
   <para>
    Davranışı değiştirmek için kullanılan imler şunlardır:
   </para>
   <variablelist>
    <varlistentry>
     <term>‘<code>-</code>’</term>
     <listitem>
      <para>
       Alan içinde sonucu sola yanaştırır (normalde sağa yanaştırılır).
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>‘<code>+</code>’</term>
     <listitem>
      <para>
       Sonuç daima artı ya da eksi işareti içerir.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>‘ ’</term>
     <listitem>
      <para>
       Sonuç artı ya da eksi imi içermiyorsa im yerine boşluk basar. ‘<code>+</code>’ im karakteri belirtilmişse sonuç mutlaka bir im içerir. Hem ‘<code>+</code>’ hem de boşluk karakteri belirtilmişse boşluk yok sayılır.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>‘<code>#</code>’</term>
     <listitem>
      <para>
       Sonuç ondalık noktanın sağında hiçbir sayı içermese bile ondalık nokta gösterilir. ‘<code>%g</code>’ ve ‘<code>%G</code>’ dönüşümleri ondalık noktadan sonraki sondaki sıfırların kaldırılması istenmişse bile yerinde kalmaya zorlar.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>‘<code>'</code>’</term>
     <listitem>
      <para>
       <varname>LC_NUMERIC</varname> yereline uygun olarak tamsayı kısmı gruplara ayırır. Bu im bir GNU oluşumudur. Bkz. <xref linkend="glibc-General-Numeric"/>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>‘<code>0</code>’</term>
     <listitem>
      <para>
       Alanda boş kalan yerleri boşluk yerine sıfırlarla doldurur. Sıfırlar imden sonra konur. Bu imle birlikte ‘<code>-</code>’ imi belirtilmişse bu im yok sayılır.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    Hassasiyet, belirtilmişse ‘<code>%f</code>’, ‘<code>%e</code>’ ve ‘<code>%E</code>’ dönüşümleri için ondalık noktadan sonraki basamakların sayısıdır. Bu dönüşümler için varsayılan hassasiyet <code>6</code>'dır. Hassasiyet olarak <code>0</code> değeri belirtilmişse ondalık nokta basılmaz. ‘<code>%g</code>’ ve ‘<code>%G</code>’ dönüşümleri için hassasiyet önemli basamak sayısıdır. Önemli basamaklar noktanın solundaki tek basamak ile noktanın sağındakilerin tamamıdır. Hassasiyet <code>0</code> ise ya da belirtilmemişse <code>1</code> belirtilmiş varsayılır. Basılacak değer belirtilen basamak sayısı ile doğru olarak gösterilemeyecekse gösterilebilecek en yakın sayıya yuvarlanır.
   </para>
   <para>
    Tür değiştirici belirtilmeksizin tüm kayan noktalı sayı dönüşüm belirteçleri bağımsız değişkeni <type>double</type> türünde yorumlar. (Öntanımlı bağımsız değişken terfileri çerçevesinde <type>float</type> türünden bağımsız değişkenler özdevinimli olarak <type>double</type> türüne dönüştürülür.) Desteklenen tür değiştiricisi:
    </para>
    <variablelist>
     <varlistentry>
      <term>‘<code>L</code>’</term>
      <listitem>
       <para>
        Bağımsız değişkenin <type>long&nbsp;double</type> türünde yorumlanacağını belirtir.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
    <example><title>Kayan noktalı sayı dönüşümleri</title>
    <para>
     Aşağıdaki örneklerde kayan noktalı sayı dönüşümleri kullanılarak sayıların nasıl basılacağı gösterilmiştir:
    </para>
    <screen>"|%13.4a|%13.4f|%13.4e|%13.4g|\n"
</screen>
    <para>Çıktısı:</para>
<screen>|  0x0.0000p+0|       0.0000|   0.0000e+00|            0|
|  0x1.0000p-1|       0.5000|   5.0000e-01|          0.5|
|  0x1.0000p+0|       1.0000|   1.0000e+00|            1|
| -0x1.0000p+0|      -1.0000|  -1.0000e+00|           -1|
|  0x1.9000p+6|     100.0000|   1.0000e+02|          100|
|  0x1.f400p+9|    1000.0000|   1.0000e+03|         1000|
| 0x1.3880p+13|   10000.0000|   1.0000e+04|        1e+04|
| 0x1.81c8p+13|   12345.0000|   1.2345e+04|    1.234e+04|
| 0x1.86a0p+16|  100000.0000|   1.0000e+05|        1e+05|
| 0x1.e240p+16|  123456.0000|   1.2346e+05|    1.235e+05|
</screen>
    <para>
     Dikkat edilirse ‘<filename>%g</filename>’ dönüşümünde sağdaki sıfırlar kaldırılmıştır.
    </para>
   </example>
  </sect1>

  <sect1 xml:id="glibc-Other-Output-Conversions">
   <title>Diğer Çıktı Dönüşümleri</title>
   <titleabbrev>Dizge, karakter, gösterici ve benzerlerinin biçimlenmesi.</titleabbrev>
   <para>
    Bu bölümde <function>printf</function> için çeşitli dönüşümlerden bahsedilmiştir.
   </para>
   <para>
    ‘<code>%c</code>’ dönüşümü tek bir karakter basar.  ‘<code>l</code>’ değiştiricisinin olmadığı durumda  <type>int</type> türündeki bağımsız değişken önce <type>unsigned&nbsp;char</type> türüne dönüştürülür.  Bundan sonra, bir geniş yönlenimli akım işlevi kullanılmışsa karakter karşı düşen geniş karaktere dönüştürülür. ‘<code>-</code>’ imi kullanılmış, başka bir im tanımlanmamış, tür ve hassasiyet belirtilmemişse karakter alanda sola yanaştırılır. Örneğin:
   </para>
   <example>
    <screen>printf ("%c%c%c%c%c", 'h', 'e', 'l', 'l', 'o');
</screen>
    <para>‘hello’ basar.</para>
   </example>
   <para>
     ‘<code>l</code>’ değiştiricisi varsa bağımsız değişkenin <type>wint_t</type> türünde olacağı umulur. Çok baytlı karakter işlevi içinde kullanılmışsa geniş karakter çıktıya eklenmeden önce çok baytlı karaktere dönüştürülür. Bu durumda birden fazla bayt içeren çıktı üretilebilir.
    </para>
    <para>
     ‘<code>%s</code>’ dönüşümü bir dizge basar. ‘<code>l</code>’ değiştiricisi yoksa karşı düşen bağımsız değişken <type>char&nbsp;*</type> (ya da <type>const&nbsp;char&nbsp;*</type>) türünde olmalıdır. Geniş yönlenimli akım işlevi kullanılmışsa, dizge geniş karakter dizgesine dönüştürülür. Yazılacak karakterlerin sayısı hassasiyet ile belirtilebilir; aksi takdirde, sonlandıran boş karaktere kadar boş karakter hariç dizge akıma çıktılanır. ‘<code>-</code>’ imi kullanılmış ama başka bir im tanımlanmamış, tür ve hassasiyet belirtilmemişse dizge alanda sola yanaştırılır. Örneğin:
    </para>
    <example>
     <screen>printf ("%3s%-6s", "no", "where");
</screen>
     <para>‘nowhere’ basar.</para>
    </example>
    <para>
     ‘<code>l</code>’ değiştiricisi varsa bağımsız değişkenin <type>wchar_t</type> (ya da <type>const&nbsp;wchar_t&nbsp;*</type>) türünde olacağı umulur.
   </para>
   <para>
    ‘<code>%s</code>’ dönüşümüne istemeyerek bağımsız değişken olarak boş gösterici aktarılırsa, &glibc; onu <code>(null)</code> olarak basar. Bunun çökmekten daha iyi olduğunu düşünülmektedir. Ancak boş göstericiyi bile bile aktarmak iyi bir uygulama olmayacaktır.
   </para>
   <para>
   ‘<code>%m</code>’ dönüşümü <varname>errno</varname> hata kodunun karşılığı olan dizgeyi basar. Bkz. <xref linkend="glibc-Error-Messages"/>. Burada:
   </para>
   <example>
    <screen>fprintf (stderr, "`%s' açılamıyor: %m\n", filename);
</screen>
    <para>deyimi ile</para>
    <screen>fprintf (stderr, "`%s' açılamıyor: %s\n", filename, strerror (errno));
</screen>
    <para>
     deyimi eşdeğerdir.
    </para>
   </example>
   <para>
    ‘<code>%m</code>’ dönüşümü <function>strerrorname_np</function> tarafından sağlanan hata sabitini basmak için ‘<code>#</code>’ seçeneği ile birlikte kullanılabilir.‘<code>%m</code>’ ve ‘<code>%#m</code>’ birer &glibc; oluşumudur.
   </para>
   <para>
    ‘<code>%p</code>’ dönüşümü gösterici değeri basar. Karşı düşen bağımsız değişken <type>void&nbsp;*</type> türünde olmalıdır. Uygulamada herhangi bir türden gösterici kullanılabilir.
   </para>
   <para>
    <dicterm><english>signed integer</english><turkish>imli tamsayı</turkish></dicterm>
    <dicterm><english>unsigned integer</english><turkish>imsiz tamsayı</turkish></dicterm>
    &glibc;nde boş olmayan göstericiler bir ‘<code>%#x</code>’ dönüşümü kullanılmış gibi imsiz tamsayı olarak basılır. Boş göstericiler <code>(nil)</code> olarak basılır. (Diğer sistemlerde göstericiler farklı basılabilir.)
   </para>
   <example>
    <screen>printf ("%p", "testing");
</screen>
    <para>
     deyimi ‘<code>0x</code>’ten sonra <code>"testing"</code> dizge sabitinin adresini onaltılık sayı olarak basar; '<code>testing</code>' sözcüğünü basmaz.
    </para>
   </example>
   <para>
    ‘<code>-</code>’ imi kullanılmış ama başka bir im tanımlanmamış, tür ve  hassasiyet belirtilmemişse gösterici değeri alanda sola yanaştırılır.
   </para>
   <para>
    ‘<code>%n</code>’ belirteci diğer dönüşüm belirteçlerine benzemez. Bir <type>int</type> türüne gösterici olan bir bağımsız değişken kullanır, ama bir şey çıktılamaz, onun yerine o çağrı ile çıktılanan karakterlerin sayısını kaydeder. ‘<code>h</code>’ ve ‘<code>l</code>’ tür değiştiricileri kullanılarak (birim, hassasiyet veya alan genişliği belirtilemez) bağımsız değişkenin türü <type>int&nbsp;*</type> yerine <type>short&nbsp;int&nbsp;*</type> veya <type>long&nbsp;int&nbsp;*</type> türünde belirtilebilir.
   </para>
   <example>
    <screen>int nchar;
printf ("%d %s%n\n", 3, "bears", &amp;nchar);
</screen>
    <para>deyimi</para>
    <screen>3 bears
</screen>
    <para>
     basar ve <code>nchar</code>'a 7 değerini atar, çünkü basılan karakterlerin sayısı 7'dir.
    </para>
   </example>
   <para>
    ‘<code>%%</code>’ belirteci bir <code>%</code> imi basar. Bu belirteç bir bağımsız değişken kullanmaz ve im, alan genişliği, hassasiyet veya tür değiştirici belirtilemez.
   </para>
  </sect1>

  <sect1 xml:id="glibc-Formatted-Output-Functions">
   <title>Biçimli Çıktı İşlevleri</title>
   <titleabbrev>Biçimli çıktı üreten işlevlerin açıklamaları.</titleabbrev>
   <para>
    Bu bölümde <function>printf</function> ve ilgili işlevlerin nasıl çağrıldığı anlatılmıştır. Bu işlevler &stdio.h; başlık dosyasında bildirilmiştir. Bu işlevlerin değişken sayıda bağımsız değişken almalarından dolayı, kullanılmadan önce ilk örnekleri ile bildirilmelidir. Şüphesiz bunu yapmanın en kolay yolu bu işlevlerin bildirildiği &stdio.h; başlık dosyasının kaynak dosyasında içerilmesidir.
    <indexterm linkend="glibc-pg"><primary>stdio.h</primary></indexterm>
   </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-printf"><primary>printf</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-printf"><primary>biçimli çıktı</primary><secondary>dar yönlenimli standart çıktıya</secondary></indexterm>
    <csproto type="işlev" varargs="">
     <csname><type>int</type><function>printf</function></csname>
     <csparam><ptr>const&#160;char</ptr><parameter>template</parameter></csparam>
    </csproto>
    <header>&stdio.h;</header>
    <conceptlist>
     <concept>&mtsafe; &locale;</concept>
     <concept>&asunsafe; &corrupt;</concept>
     <concept>&acunsafe; &mem; &lock; &corrupt;</concept>
    </conceptlist>
    <para>
     <code>printf</code> işlevi <parameter>template</parameter> biçim dizgesinin denetimi altında isteğe bağlı bağımsız değişkenleri standart çıktıya basar ve basılan karakterlerin sayısı ile döner; bir çıktılama hatası oluşursa negatif değerle döner.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-wprintf"><primary>wprintf</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-wprintf"><primary>biçimli çıktı</primary><secondary>geniş yönlenimli standart çıktıya</secondary></indexterm>
    <csproto type="işlev" varargs="">
     <csname><type>int</type><function>wprintf</function></csname>
     <csparam><ptr>const&#160;wchar_t</ptr><parameter>template</parameter></csparam>
    </csproto>
    <header>&wchar.h;</header>
    <conceptlist>
     <concept>&mtsafe; &locale;</concept>
     <concept>&asunsafe; &corrupt; &heap;</concept>
     <concept>&acunsafe; &mem; &lock; &corrupt;</concept>
    </conceptlist>
    <para>
     <code>wprintf</code> işlevi <parameter>template</parameter> geniş biçim  dizgesinin denetimi altında isteğe bağlı bağımsız değişkenleri standart çıktıya basar ve basılan geniş karakterlerin sayısı ile döner; bir çıktılama hatası oluşursa negatif değerle döner.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-fprintf"><primary>fprintf</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-fprintf"><primary>biçimli çıktı</primary><secondary>dar yönlenimli akıma</secondary></indexterm>
    <csproto type="işlev" varargs="">
     <csname><type>int</type><function>fprintf</function></csname>
     <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
     <csparam><ptr>const&#160;char</ptr><parameter>template</parameter></csparam>
    </csproto>
    <header>&stdio.h;</header>
    <conceptlist>
     <concept>&mtsafe; &locale;</concept>
     <concept>&asunsafe; &corrupt; &heap;</concept>
     <concept>&acunsafe; &mem; &lock; &corrupt;</concept>
    </conceptlist>
    <para>
     Bu işlev <function>printf</function> gibidir, tek farkla, çıktıyı standart çıktıya değil <parameter>stream</parameter> akımına yazar.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-fwprintf"><primary>fwprintf</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-fwprintf"><primary>biçimli çıktı</primary><secondary>dar yönlenimli akıma</secondary></indexterm>
    <csproto type="işlev" varargs="">
     <csname><type>int</type><function>fwprintf</function></csname>
     <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
     <csparam><ptr>const&#160;wchar_t</ptr><parameter>template</parameter></csparam>
    </csproto>
    <header>&stdio.h;</header>
    <header>&wchar.h;</header>
    <conceptlist>
     <concept>&mtsafe; &locale;</concept>
     <concept>&asunsafe; &corrupt; &heap;</concept>
     <concept>&acunsafe; &mem; &lock; &corrupt;</concept>
    </conceptlist>
    <para>
     Bu işlev <function>wprintf</function> gibidir, tek farkla, çıktıyı standart çıktıya değil <parameter>stream</parameter> akımına yazar.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-sprintf"><primary>sprintf</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-sprintf"><primary>biçimli çıktı</primary><secondary>dar yönlenimli dizgeye</secondary></indexterm>
    <csproto type="işlev" varargs="">
     <csname><type>int</type><function>sprintf</function></csname>
     <csparam><ptr>char</ptr><parameter>s</parameter></csparam>
     <csparam><ptr>const&#160;char</ptr><parameter>template</parameter></csparam>
    </csproto>
    <header>&stdio.h;</header>
    <conceptlist>
     <concept>&mtsafe; &locale;</concept>
     <concept>&asunsafe; &heap;</concept>
     <concept>&acunsafe; &mem;</concept>
    </conceptlist>
    <para>
     Bu işlev <function>printf</function> gibidir, tek farkla, çıktıyı standart çıktıya değil <parameter>s</parameter> dizisine yazar. Dizge boş karakterle sonlandırılır.
    </para>
    <para>
     <code>sprintf</code> işlevi sonlandırıcı boş karakter hariç <parameter>s</parameter> dizisine yazılan karakterlerin sayısı ile döner.
    </para>
    <para>
     Bu işlevin davranışı, birbirini kapsayan nesneler arasında kopyalama yapılırsa, örneğin, <code>%s</code> belirtecinin bağımsız değişkeni olarak <parameter>s</parameter> dizgesi verilmişse, tanımsızdır. Bkz. <xref linkend="glibc-Copying-Strings-and-Arrays"/>.
    </para>
    <warning>
     <para>
      <command>sprintf</command> işlevi <wordasword>tehlikeli</wordasword> olabilir. <parameter>s</parameter> dizgesi için tahsis edilen yerin biçim dizgesinin ürettiği dizge için yetersiz olabilme olasılığı vardır. Alan genişliği bağımsız değişkeninin en küçük alan genişliğini belirttiği ve kimi zaman bu genişliğin aşılabildiği unutulmamalıdır.
     </para>
     <para>
      Bu sorundan kaçımak için aşağıda açıklanacak olan <function>snprintf</function> veya <function>asprintf</function> işlevleri kullanılabilir.
     </para>
    </warning>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-swprintf"><primary>swprintf</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-swprintf"><primary>biçimli çıktı</primary><secondary>geniş yönlenimli dizgeye</secondary></indexterm>
    <csproto type="işlev" varargs="">
     <csname><type>int</type><function>swprintf</function></csname>
     <csparam><ptr>wchar_t</ptr><parameter>ws</parameter></csparam>
     <csparam><type>size_t</type><parameter>size</parameter></csparam>
     <csparam><ptr>const&#160;wchar_t</ptr><parameter>template</parameter></csparam>
    </csproto>
    <header>&wchar.h;</header>
    <conceptlist>
     <concept>&mtsafe; &locale;</concept>
     <concept>&asunsafe; &heap;</concept>
     <concept>&acunsafe; &mem;</concept>
    </conceptlist>
    <para>
     Bu işlev <function>wprintf</function> gibidir, tek farkla, çıktıyı standart çıktıya değil <parameter>ws</parameter> geniş karakter dizisine yazar. Dizge boş geniş karakterle sonlandırılır. <parameter>size</parameter> bağımsız değişkeni ile üretilecek en büyük karakter sayısı belirtilir. Sonlandırıcı boş karakter de bu sınırın içinde olduğundan <parameter>ws</parameter> dizgesi için en az <parameter>size</parameter> geniş karakterlik yer ayrılmalıdır.
    </para>
    <para>
     <code>swprintf</code> işlevi sonlandırıcı boş geniş karakter hariç <parameter>ws</parameter> geniş karakter dizisine yazılan karakterlerin sayısı ile döner. Çıktı belirtilen tampona sığmazsa negatif değer ile döner. Bu davranışı ile işlev <function>snprintf</function> işlevinden farklıdır.
    </para>
    <note>
     <para>
      Benzeri olan dar yönlenimli akım işlevleri daha az bağımsız değişken alır. <code>swprintf</code> işlevi aslında <function>snprintf</function> işlevinin karşılığıdır. <function>sprintf</function> işlevi tehlikeli olabildiğinden, &isoc; komitesi aynı yanlışı tekrar yapmaktan kaçınmalı ve <function>sprintf</function> işlevinin tam karşılığı olan bir işlevi tanımlamama kararı almalıdır.
     </para>
    </note>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-snprintf"><primary>snprintf</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-snprintf"><primary>biçimli çıktı</primary><secondary>dar yönlenimli dizgeye</secondary></indexterm>
    <csproto type="işlev" varargs="">
     <csname><type>int</type><function>snprintf</function></csname>
     <csparam><ptr>char</ptr><parameter>s</parameter></csparam>
     <csparam><type>size_t</type><parameter>size</parameter></csparam>
     <csparam><ptr>const&#160;char</ptr><parameter>template</parameter></csparam>
    </csproto>
    <header>&stdio.h;</header>
    <conceptlist>
     <concept>&mtsafe; &locale;</concept>
     <concept>&asunsafe; &heap;</concept>
     <concept>&acunsafe; &mem;</concept>
    </conceptlist>
    <para>
     <code>snprintf</code> işlevi, <function>sprintf</function> gibidir, tek farkla, <parameter>size</parameter> bağımsız değişkeni ile üretilecek en büyük karakter sayısı belirtilir. Sonlandırıcı boş karakter de bu sınırın içinde olduğundan <parameter>s</parameter>dizgesi için en az <parameter>size</parameter> karakterlik yer tahsis edilmelidir.
    </para>
    <para>
     <code>snprintf</code> işlevi sonlandırıcı boş geniş karakter hariç <parameter>s</parameter> karakter dizisine yazılan karakterlerin sayısı ile döner. Bu değer <parameter>size</parameter> bayta eşit ya da ondan büyükse sonucun tüm karakterleri <parameter>s</parameter> dizisine yazılamamış demektir. Bu durumda daha büyük çıktı dizisi ile çağrı yinelenmelidir. Aşağıda bunun yapıldığı bir örnek vardır:
    </para>
    <example>
     <screen>/* <replaceable>'name' isminde ve 'value' değerinde
    bir değişkenin değerini açıklayan bir ileti oluştur.</replaceable> */
char *
make_message (char *name, char *value)
{
  /* <replaceable>Nasılsa 100 karakterden daha fazla yere ihtiyaç olmaz.</replaceable> */
  size_t size = 100;
  char *buffer = xmalloc (size);
  /* <replaceable>Tahsis edilen alana iletiyi yazmaya çalış.</replaceable> */
  int buflen = snprintf (buffer, size, "value of %s is %s",
		         name, value);
  if (! (0 &lt;= buflen &amp;&amp; buflen &lt; SIZE_MAX))
    fatal ("integer overflow");
  if (buflen &gt;= size)
    {
      /* <replaceable>Artık ne kadar yere ihtiyaç olduğu biliniyor.
         O halde tamponu yeniden ayır.</replaceable> */
      size = buflen;
      size++;
      buffer = xrealloc (buffer, size);

      /* <replaceable>Yeniden dene.</replaceable> */
      snprintf (buffer, size, "value of %s is %s",
		name, value);
    }
  /* <replaceable>Son çağrı çalıştığından dizge ile dön.</replaceable> */
  return buffer;
}
</screen>
    </example>
    <para>
     Aslında, <function>asprintf</function> işlevini kullanmak çok daha kolaydır.
    </para>
    <caution>
     <para>
      &glibc;nin 2.1 öncesi sürümlerinde dönüş değeri, sonlandırıcı boş karakter hariç saklanan karakterlerin sayısıydı. <parameter>s</parameter> dizisinde yeterli yer yoksa <code>-1</code> dönüyordu. Bu, &isoc;99 standardına uyum sırasında değiştirildi.
     </para>
    </caution>
   </csynopsis>
  </sect1>

  <sect1 xml:id="glibc-Dynamic-Output">
   <title>Biçimli Çıktıya Özdevimli Tahsis</title>
   <titleabbrev>Çıktı için belleği özdevimli tahsis eden işlevler.</titleabbrev>
   <para>
    Bu bölümdeki işlevler biçimli çıktı oluşturur ve sonucu özdevimli tahsis edilen belleğe yazar.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-asprintf"><primary>asprintf</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-asprintf"><primary>biçimli çıktı</primary><secondary>dar yönlenimli değişkene</secondary></indexterm>
    <csproto type="işlev" varargs="">
     <csname><type>int</type><function>asprintf</function></csname>
     <csparam><pptr>char</pptr><parameter>ptr</parameter></csparam>
     <csparam><ptr>const&#160;char</ptr><parameter>template</parameter></csparam>
    </csproto>
    <header>&stdio.h;</header>
    <conceptlist>
     <concept>&mtsafe; &locale;</concept>
     <concept>&asunsafe; &heap;</concept>
     <concept>&acunsafe; &mem;</concept>
    </conceptlist>
    <para>
     Bu işlev, çıktıyı yazılımcının tahsis ettiği bir tampona değil, özdevimli ayrılmış (<function>malloc</function> ile; Bkz. <xref linkend="glibc-Unconstrained-Allocation"/>) bir dizgeye yazması dışında <function>sprintf</function> işlevi gibidir. <parameter>ptr</parameter> bağımsız değişkeni,  <type>char&#160;*</type> türünde bir nesnesinin adresi olmalıdır. <code>asprintf</code> bu adresteki dizgeye bir gösterici saklayacaktır.
    </para>
    <para>
     Dönen değer ayrılan dizgenin karakter sayısıdır; dizge için yer ayrılamadığı durumlarda ve hata durumunda sıfırdan küçük bir değerle döner.
    </para>
    <para>
     Aşağıdaki örnekte, <function>snprintf</function> örneğindeki sonucun <code>asprintf</code> kullanarak nasıl elde edildiği gösterilmektedir:
    </para>
    <example>
     <screen>/* <replaceable>'name' isminde ve 'value' değerinde
    bir değişkenin değerini açıklayan bir ileti oluştur.</replaceable> */
char *
make_message (char *name, char *value)
{
  char *result;
  if (asprintf (&amp;result, "value of %s is %s", name, value) &lt; 0)
    return NULL;
  return result;
}
</screen>
    </example>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-obstack_printf"><primary>obstack_printf</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-obstack_printf"><primary>biçimli çıktı</primary><secondary>dar yönlenimli yığınağa</secondary></indexterm>
    <csproto type="işlev" varargs="">
     <csname><type>int</type><function>obstack_printf</function></csname>
     <csparam><ptr>struct&#160;obstack</ptr><parameter>obstack</parameter></csparam>
     <csparam><ptr>const&#160;char</ptr><parameter>template</parameter></csparam>
    </csproto>
    <header>&stdio.h;</header>
    <conceptlist>
     <concept>&mtsafe; &race;<code linkend="glibc-safety-identifier">:obstack</code> &locale;</concept>
     <concept>&asunsafe; &corrupt; &heap;</concept>
     <concept>&acunsafe; &corrupt; &mem;</concept>
    </conceptlist>
    <para>
     Bu işlev, alan tahsisi için <parameter>obstack</parameter> yığınağını kullanması dışında <function>asprintf</function> işlevinin benzeridir. Yığınaklarla ilgili bilgi için bkz. <xref linkend="glibc-Obstacks"/>.
    </para>
    <para>
     Karakterler nesnenin sonuna yazılır. Onları almak için nesnenin <function>obstack_finish</function> ile bitirilmesi gerekir. Bkz. <xref linkend="glibc-Growing-Objects"/>.
    </para>
   </csynopsis>
  </sect1>
  <sect1 xml:id="glibc-Variable-Arguments-Output">
   <title>Değişkin Çıktı İşlevleri</title>
   <titleabbrev><code>vprintf</code> ve arkadaşları.</titleabbrev>
   <para>
    Yerleşik biçimli çıktı işlevleriyle aynı iç oluşumları kullanarak değişkin <function>printf</function> benzeri işlevlerin yazılımcı tarafından tanımlanabilmesi için <function>vprintf</function> işlevi ve arkadaşları oluşturulmuştur.
   </para>
   <para>
    Bu tür işlevleri tanımlamanın en doğal yolu, "<function>printf</function> işlevini çağır ve bu kalıpla birlikte ilk 5 bağımsız değişkenden sonra benim bağımsız değişkenlerimi aktar" diyecek bir dil yapısı kullanmak olurdu. Fakat C'de bunu yapmanın bir yolu yoktur. Ayrıca üçüncü düzey C dilinde işlevinizin kaç bağımsız değişken aldığını söyleyecek bir yol olmadığından, bir yol üretmek de zor olurdu.
   </para>
   <para>
    Bu yöntemle mümkün olmadığından "ilk 5 bağımsız değişkenden sonra benim bağımsız değişkenlerimi aktar" denilebilecek <type>va_list</type>'in aktarılacağı bir dizi işlev olarak <function>vprintf</function> ailesi üretilmiştir.
   </para>
   <para>
    Gerçek bir işlev yerine bir makro tanımlamak yeterli olduğundan, GNU C derleyicisi bunu makrolarla çok daha kolay yapacak bir yol sağlar.
   </para>
   <example>
    <screen>#define myprintf(a, b, c, d, e, rest...) \
	    printf (mytemplate , ## rest)
</screen>
   </example>
   <para>
    Değişken sayıda bağımsız değişkenli makrolar hakkında ayrıntılı bilgi edinmek için C Önişlemci belgelerindeki <link xl:href="https://gcc.gnu.org/onlinedocs/cpp/Variadic-Macros.html#Variadic-Macros">Variadic Macros</link> bölümüne bakılabilir. Ancak, bu yöntem makrolarla sınırlıdır, gerçek işlevlere uygulanmaz.
   </para>
   <para>
    <function>vprintf</function> veya bu bölümde listelenmiş diğer işlevleri çağırmadan önce değişken sayıdaki bağımsız değişkeni ilklendirmek için bir <function>va_start</function> çağrısı (<xref linkend="glibc-Variadic-Functions"/>) yapılmalıdır. Sonra da elde edilmek istenen bağımsız değişkenleri almak için <function>va_arg</function> çağrıları yapılmalıdır. Bu işlem, göstericiyi bu bağımsız değişkenlerin sonrasına ilerletir.
   </para>
   <para>
    <type>va_list</type> göstericisi için seçilen ilk bağımsız değişken gösterildikten sonra artık <function>vprintf</function> çağrısı yapılacak duruma gelinmiş demektir. Tanımlanan işleve aktarılan bu bağımsız değişken ve art bileşen bağımsız değişkenler ile belirtilen kalıp dizgesi <function>vprintf</function> işlevi tarafından kullanılacaktır.
   </para>
   <note><title>Taşınabilirlik Bilgisi</title>
    <para>
     <function>vprintf</function> çağrısından sonra <type>va_list</type> göstericisi belirsiz duruma gelebilir ve <function>vprintf</function> çağrısından sonra <function>va_arg</function> işlevi kullanılamayabilir. Bu durumda bir <function>va_end</function> çağrısından sonra <function>va_start</function> ile değişkin bağımsız değişken listesinin başlangıcındaki bağımsız değişkenlerin alımına başlanabilir. (Bunun yerine, <function>vprintf</function> çağrısından önce <type>va_list</type> göstericisinin bir kopyasını yapmak için <function>va_copy</function> kullanılabilir.) <function>vprintf</function> işlevi tanımlanan işlevin bağımsız değişken listesini ortadan kaldırmaz, yalnızca ona aktarılan göstericiyi yok eder.
    </para>
   </note>
   <para>
    <indexterm linkend="glibc-pg"><primary>stdio.h</primary></indexterm>
    Bu işlevler &stdio.h; başlık dosyasında bildirilmiştir.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-vprintf"><primary>vprintf</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-vprintf"><primary>biçimli çıktı</primary><secondary>printf benzerleri</secondary><tertiary>vprintf</tertiary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>vprintf</function></csname>
     <csparam><ptr>const&#160;char</ptr><parameter>template</parameter></csparam>
      <csparam><type>va_list</type><parameter>ap</parameter></csparam>
    </csproto>
    <header>&stdio.h;</header>
    <conceptlist>
     <concept>&mtsafe; &locale;</concept>
     <concept>&asunsafe; &corrupt; &heap;</concept>
     <concept>&acunsafe; &mem; &lock; &corrupt;</concept>
    </conceptlist>
    <para>
     Bu işlev değişken sayıdaki bağımsız değişkenlerini doğrudan almak yerine <parameter>ap</parameter> bağımsız değişken listesi göstericisinden alması dışında <function>printf</function> ile aynıdır.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-vwprintf"><primary>vwprintf</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-vwprintf"><primary>biçimli çıktı</primary><secondary>printf benzerleri</secondary><tertiary>vwprintf</tertiary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>vwprintf</function></csname>
     <csparam><ptr>const&#160;wchar_t</ptr><parameter>template</parameter></csparam>
      <csparam><type>va_list</type><parameter>ap</parameter></csparam>
    </csproto>
    <header>&stdarg.h;</header>
    <header>&wchar.h;</header>
    <conceptlist>
     <concept>&mtsafe; &locale;</concept>
     <concept>&asunsafe; &corrupt; &heap;</concept>
     <concept>&acunsafe; &mem; &lock; &corrupt;</concept>
    </conceptlist>
    <para>
     Bu işlev değişken sayıdaki bağımsız değişkenlerini doğrudan almak yerine <parameter>ap</parameter> bağımsız değişken listesi göstericisinden alması dışında <function>wprintf</function> ile aynıdır.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-vfprintf"><primary>vfprintf</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-vfprintf"><primary>biçimli çıktı</primary><secondary>printf benzerleri</secondary><tertiary>vfprintf</tertiary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>vfprintf</function></csname>
     <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
     <csparam><ptr>const&#160;char</ptr><parameter>template</parameter></csparam>
      <csparam><type>va_list</type><parameter>ap</parameter></csparam>
    </csproto>
    <header>&stdio.h;</header>
    <conceptlist>
     <concept>&mtsafe; &locale;</concept>
     <concept>&asunsafe; &corrupt; &heap;</concept>
     <concept>&acunsafe; &mem; &lock; &corrupt;</concept>
    </conceptlist>
    <para>
     <function>vprintf</function> işlevindeki gibi doğrudan belirtilen değişken bağımsız değişken listesiyle <function>fprintf</function> işlevinin eşdeğeridir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-vfwprintf"><primary>vfwprintf</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-vfwprintf"><primary>biçimli çıktı</primary><secondary>printf benzerleri</secondary><tertiary>vfwprintf</tertiary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>vfwprintf</function></csname>
     <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
     <csparam><ptr>const&#160;wchar_t</ptr><parameter>template</parameter></csparam>
      <csparam><type>va_list</type><parameter>ap</parameter></csparam>
    </csproto>
    <header>&stdarg.h;</header>
    <header>&stdio.h;</header>
    <header>&wchar.h;</header>
    <conceptlist>
     <concept>&mtsafe; &locale;</concept>
     <concept>&asunsafe; &corrupt; &heap;</concept>
     <concept>&acunsafe; &mem; &lock; &corrupt;</concept>
    </conceptlist>
    <para>
     <function>vwprintf</function> işlevindeki gibi doğrudan belirtilen değişken bağımsız değişken listesiyle <function>fwprintf</function> işlevinin eşdeğeridir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-vsprintf"><primary>vsprintf</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-vsprintf"><primary>biçimli çıktı</primary><secondary>printf benzerleri</secondary><tertiary>vsprintf</tertiary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>vsprintf</function></csname>
     <csparam><ptr>char</ptr><parameter>s</parameter></csparam>
     <csparam><ptr>const&#160;char</ptr><parameter>template</parameter></csparam>
      <csparam><type>va_list</type><parameter>ap</parameter></csparam>
    </csproto>
    <header>&stdio.h;</header>
    <conceptlist>
     <concept>&mtsafe; &locale;</concept>
     <concept>&asunsafe; &heap;</concept>
     <concept>&acunsafe; &mem;</concept>
    </conceptlist>
    <para>
     <function>vprintf</function> işlevindeki gibi doğrudan belirtilen değişken bağımsız değişken listesiyle <function>sprintf</function> işlevinin eşdeğeridir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-vswprintf"><primary>vswprintf</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-vswprintf"><primary>biçimli çıktı</primary><secondary>printf benzerleri</secondary><tertiary>vswprintf</tertiary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>vswprintf</function></csname>
     <csparam><ptr>wchar_t</ptr><parameter>ws</parameter></csparam>
     <csparam><type>size_t</type><parameter>size</parameter></csparam>
     <csparam><ptr>const&#160;wchar_t</ptr><parameter>template</parameter></csparam>
      <csparam><type>va_list</type><parameter>ap</parameter></csparam>
    </csproto>
    <header>&stdarg.h;</header>
    <header>&wchar.h;</header>
    <conceptlist>
     <concept>&mtsafe; &locale;</concept>
     <concept>&asunsafe; &heap;</concept>
     <concept>&acunsafe; &mem;</concept>
    </conceptlist>
    <para>
     <function>vwprintf</function> işlevindeki gibi doğrudan belirtilen değişken bağımsız değişken listesiyle <function>swprintf</function> işlevinin eşdeğeridir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-vsnprintf"><primary>vsnprintf</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-vsnprintf"><primary>biçimli çıktı</primary><secondary>printf benzerleri</secondary><tertiary>vsnprintf</tertiary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>vsnprintf</function></csname>
     <csparam><ptr>char</ptr><parameter>s</parameter></csparam>
     <csparam><type>size_t</type><parameter>size</parameter></csparam>
     <csparam><ptr>const&#160;wchar_t</ptr><parameter>template</parameter></csparam>
      <csparam><type>va_list</type><parameter>ap</parameter></csparam>
    </csproto>
    <header>&stdio.h;</header>
    <conceptlist>
     <concept>&mtsafe; &locale;</concept>
     <concept>&asunsafe; &heap;</concept>
     <concept>&acunsafe; &mem;</concept>
    </conceptlist>
    <para>
     <function>vprintf</function> işlevindeki gibi doğrudan belirtilen değişken bağımsız değişken listesiyle <function>snprintf</function> işlevinin eşdeğeridir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-vasprintf"><primary>vasprintf</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-vasprintf"><primary>biçimli çıktı</primary><secondary>printf benzerleri</secondary><tertiary>vasprintf</tertiary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>vasprintf</function></csname>
     <csparam><pptr>char</pptr><parameter>ptr</parameter></csparam>
     <csparam><ptr>const&#160;char</ptr><parameter>template</parameter></csparam>
     <csparam><type>va_list</type><parameter>ap</parameter></csparam>
    </csproto>
    <header>&stdio.h;</header>
    <conceptlist>
     <concept>&mtsafe; &locale;</concept>
     <concept>&asunsafe; &heap;</concept>
     <concept>&acunsafe; &mem;</concept>
    </conceptlist>
    <para>
     <function>vprintf</function> işlevindeki gibi doğrudan belirtilen değişken bağımsız değişken listesiyle <function>asprintf</function> işlevinin eşdeğeridir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-obstack_vprintf"><primary>obstack_vprintf</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-obstack_vprintf"><primary>biçimli çıktı</primary><secondary>printf benzerleri</secondary><tertiary>obstack_vprintf</tertiary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>obstack_vprintf</function></csname>
     <csparam><ptr>struct&#160;obstack</ptr><parameter>obstack</parameter></csparam>
     <csparam><ptr>const&#160;char</ptr><parameter>template</parameter></csparam>
     <csparam><type>va_list</type><parameter>ap</parameter></csparam>
    </csproto>
    <header>&stdio.h;</header>
    <conceptlist>
     <concept>&mtsafe; &race;<code linkend="glibc-safety-identifier">:obstack</code> &locale;</concept>
     <concept>&asunsafe; &corrupt; &heap;</concept>
     <concept>&acunsafe; &corrupt; &mem;</concept>
    </conceptlist>
    <para>
     <function>vprintf</function> işlevindeki gibi doğrudan belirtilen değişken bağımsız değişken listesiyle <function>obstack_vprintf</function> işlevinin eşdeğeridir.
    </para>
   </csynopsis>
   <example>
    <para>
     Burada <function>vfprintf</function> kullanılan bir örnek vardır. Örnekteki işlev yazılımın ismi ile önceleyerek standart hataya bir hata iletisi basmaktadır. (<varname>program_invocation_short_name</varname> değişkeninin açıklamaları için bkz. <xref linkend="glibc-Error-Messages"/>.)
    </para>
    <screen>#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;

void
eprintf (const char *template, ...)
{
  va_list ap;
  extern char *program_invocation_short_name;

  fprintf (stderr, "%s: ", program_invocation_short_name);
  va_start (ap, template);
  vfprintf (stderr, template, ap);
  va_end (ap);
}
</screen>
    <para>
     <code>eprintf</code> işlevi şöyle çağrılabilir:
    </para>
    <screen>eprintf ("file `%s' does not exist\n", filename);
</screen>
    <para>
     GNU C'de <function>printf</function> tarzı biçim dizgesi kullanan bir işlevi derleyiciye bildirmek için özel bir yapı vardır. Bu yapı kullanıldığında işlevin her çağrısı için kullanılan bağımsız değişkenlerin türleri ve sayısı denetlenir ve biçim dizgesiyle eşleşmeyenler için uyarı verir. Örneğin, bu yapı <code>eprintf</code> için şöyle kullanabilir:
    </para>
    <screen>void eprintf (const char *template, ...)
	__attribute__ ((format (printf, 1, 2)));
</screen>
    <para>
     Bu kod parçası derleyiciye <code>eprintf</code> işlevinin ilk bağımsız değişkeninin <function>printf</function> biçim dizgesi olarak (<function>scanf</function> işlevinin tersine; bkz. <xref linkend="glibc-Formatted-Input"/>), biçim dizgesini oluşturan diğer bağımsız değişkenlerin başlangıcının ikinci bağımsız değişken olarak kullanıldığını söyler. İşlev özniteliklerinin bildirilmesi ile ilgili ayrıntılı bilgi edinmek için GCC kılavuzunun <link xl:href="https://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html#Function-Attributes">Declaring Attributes of Functions</link> bölümüne bakılabilir.
    </para>
   </example>
  </sect1>

  <sect1 xml:id="glibc-Parsing-a-Template-String">
   <title>Kalıp Dizgesinin Çözümlenmesi</title>
   <titleabbrev>Kalıp dizgesindeki çeşitli bağımsız değişkenler neler yapar?</titleabbrev>
   <para>
    <function>parse_printf_format</function> işlevini kullanılarak bir kalıp dizgesindeki dönüşüm belirteçlerinin karşılığı olan bağımsız değişkenlerin sayısı ve türü hakkında bilgi alınabilir. Bu işlevi kullanarak kullanıcının uygulamadan geçersiz bağımsız değişkenler girerek bir çökmeye sebep olmasından kaçınmak için <function>printf</function> işlevine bir arayüz oluşturulabilir.
   </para>
   <para>
    <indexterm linkend="glibc-pg"><primary>printf.h</primary></indexterm>
    Bu bölümde açıklanan tüm işlevler &printf.h; başlık dosyasında bildirilmiştir.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-parse_printf_format"><primary>parse_printf_format</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-parse_printf_format"><primary>biçimli çıktı</primary><secondary>kalıp dizgesinin çözümlenmesi</secondary></indexterm>
    <csproto type="işlev">
     <csname><type>size_t</type><function>parse_printf_format</function></csname>
     <csparam><ptr>const&#160;char</ptr><parameter>template</parameter></csparam>
     <csparam><type>size_t</type><parameter>n</parameter></csparam>
     <csparam><ptr>int</ptr><parameter>argtypes</parameter></csparam>
    </csproto>
    <header>&printf.h;</header>
    <conceptlist>
     <concept>&mtsafe; &locale;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     Bu işlev <parameter>template</parameter> biçim dizgesi tarafından kullanılacak  bağımsız değişkenlerin sayısı ve türleri hakkında bilgi ile döner. Bu bilgi her elemanı bir bağımsız değişken için olmak üzere <parameter>argtypes</parameter> dizisine kaydedilir. Bu bilgi aşağıda listelenen çeşitli <code>PA_</code> makroları kullanılarak kodlanır.
    </para>
    <para>
     <parameter>n</parameter> bağımsız değişkeni ile <parameter>argtypes</parameter> dizisindeki eleman sayısı belirtilir. Bu sayı, <code>parse_printf_format</code> işlevinin yazmayı deneyeceği azami eleman sayısıdır.
    </para>
    <para>
     <code>parse_printf_format</code> işlevi <parameter>template</parameter> dizgesinin gerektirdiği bağımsız değişken sayısı ile döner. Bu sayı <parameter>n</parameter> ile belirtilenden büyükse dönen bilgi sadece ilk <parameter>n</parameter> bağımsız değişken içindir. Tüm bağımsız değişkenler için bilgi alınmak istenirse, daha büyük bir dizi tahsis edip işlev tekrar çağrılmalıdır.
    </para>
   </csynopsis>
   <para>
    Bağımsız değişken türleri temel tür ile değiştirici seçenek bitlerinin birleşimi olarak kodlanır.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-PA_FLAG_MASK"><primary>PA_FLAG_MASK</primary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>PA_FLAG_MASK</function></csname>
    </csproto>
    <header>&printf.h;</header>
    <para>
     Bu makro tür değiştirici seçenek bitleri için bit maskesidir. Bir bağımsız değişkenin seçenek bitlerini çıkarmak için <code>(argtypes[i] &amp; PA_FLAG_MASK)</code> ifadesi, temel tür kodunu çıkarmak için <code>(argtypes[i] &amp; ~PA_FLAG_MASK)</code> ifadesi kullanılabilir.
    </para>
   </csynopsis>
   <para>
    Tamsayı değerler olarak temel türleri ifade eden simgesel sabitler:
   </para>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-PA_INT"><primary>PA_INT</primary></indexterm>
    <csproto type="sabit">
     <csname><function>PA_INT</function></csname>
    </csproto>
    <header>&printf.h;</header>
    <para>
     <type>int</type> temel türünü belirtir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-PA_CHAR"><primary>PA_CHAR</primary></indexterm>
    <csproto type="sabit">
     <csname><function>PA_CHAR</function></csname>
    </csproto>
    <header>&printf.h;</header>
    <para>
     <type>char</type> türüne dönüşen <type>int</type> temel türünü belirtir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-PA_STRING"><primary>PA_STRING</primary></indexterm>
    <csproto type="sabit">
     <csname><function>PA_STRING</function></csname>
    </csproto>
    <header>&printf.h;</header>
    <para>
     Boş karakter sonlandırmalı dizge gösteren <type>char&#160;*</type> temel türünü belirtir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-PA_POINTER"><primary>PA_POINTER</primary></indexterm>
    <csproto type="sabit">
     <csname><function>PA_POINTER</function></csname>
    </csproto>
    <header>&printf.h;</header>
    <para>
     Herhangi bir gösterici olarak <type>void&#160;*</type> temel türünü belirtir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-PA_FLOAT"><primary>PA_FLOAT</primary></indexterm>
    <csproto type="sabit">
     <csname><function>PA_FLOAT</function></csname>
    </csproto>
    <header>&printf.h;</header>
    <para>
     <type>float</type> temel türünü belirtir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-PA_DOUBLE"><primary>PA_DOUBLE</primary></indexterm>
    <csproto type="sabit">
     <csname><function>PA_DOUBLE</function></csname>
    </csproto>
    <header>&printf.h;</header>
    <para>
     <type>double</type> temel türünü belirtir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-PA_LAST"><primary>PA_LAST</primary></indexterm>
    <csproto type="sabit">
     <csname><function>PA_LAST</function></csname>
    </csproto>
    <header>&printf.h;</header>
    <para>
     Yazılımcı <code>PA_LAST</code>'ın artan değerleri olarak ek temel türler tanımlayabilir. Örneğin, <code>foo</code> ve <code>bar</code> veri türlerinin kodlaması özelleştirilmiş <function>printf</function> dönüşümleri ile şöyle tanımlanmalıdır:
    </para>
    <screen>#define PA_FOO  PA_LAST
#define PA_BAR  (PA_LAST + 1)
</screen>
   </csynopsis>
   <para>
    Aşağıda temel türü değiştiren seçenek bitleri listelenmiştir. Bunları temel türlerle VEYA'lanarak birleştirilebilir.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-PA_FLAG_PTR"><primary>PA_FLAG_PTR</primary></indexterm>
    <csproto type="sabit">
     <csname><function>PA_FLAG_PTR</function></csname>
    </csproto>
    <header>&printf.h;</header>
    <para>
     Bu bit 1 ise kodlanan türün değere değil temel türe gösterici olduğunu belirtir. Örneğin, <code>PA_INT|PA_FLAG_PTR</code> ifadesi <type>int&#160;*</type> türü içindir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-PA_FLAG_SHORT"><primary>PA_FLAG_SHORT</primary></indexterm>
    <csproto type="sabit">
     <csname><function>PA_FLAG_SHORT</function></csname>
    </csproto>
    <header>&printf.h;</header>
    <para>
     Bu bit 1 ise temel türün <type>short</type> ile değiştirildiğini belirtir. ('<code>h</code>' tür değiştiricisine karşılıktır.)
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-PA_FLAG_LONG"><primary>PA_FLAG_LONG</primary></indexterm>
    <csproto type="sabit">
     <csname><function>PA_FLAG_LONG</function></csname>
    </csproto>
    <header>&printf.h;</header>
    <para>
     Bu bit 1 ise temel türün <type>long</type> ile değiştirildiğini belirtir. ('<code>l</code>' tür değiştiricisine karşılıktır.)
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-PA_FLAG_LONG_LONG"><primary>PA_FLAG_LONG_LONG</primary></indexterm>
    <csproto type="sabit">
     <csname><function>PA_FLAG_LONG_LONG</function></csname>
    </csproto>
    <header>&printf.h;</header>
    <para>
     Bu bit 1 ise temel türün <type>long&#160;long</type> ile değiştirildiğini belirtir. ('<code>L</code>' tür değiştiricisine karşılıktır.)
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-PA_FLAG_LONG_DOUBLE"><primary>PA_FLAG_LONG_DOUBLE</primary></indexterm>
    <csproto type="sabit">
     <csname><function>PA_FLAG_LONG_DOUBLE</function></csname>
    </csproto>
    <header>&printf.h;</header>
    <para>
     Bu <varname>PA_FLAG_LONG_LONG</varname> ile eşanlamlıdır ve teamülen <type>long&#160;double</type> türü belirten <varname>PA_DOUBLE</varname> temel türü ile kullanılır.
    </para>
   </csynopsis>
  </sect1>
  <sect1 xml:id="glibc-Example-of-Parsing">
   <title>Kalıp Dizgesinin Çözümlenmesi Örneği</title>
   <titleabbrev><command>parse_printf_format</command> kullanılan bir örnek.</titleabbrev>
   <para>
    Bu örnekte bir biçim dizgesi için gereken bağımsız değişken türleri çözümlenmektedir. Bu örneğe özel olarak bağımsız değişken türlerini <code>NUMBER</code>, <code>CHAR</code>, <code>STRING</code> ve <code>STRUCTURE</code> isimleri ile sınıflandırdık (başka türlerde var tabii ama bu sadece bir örnek).
   </para>
   <example>
    <screen>/* Belirtilen 'nargs' adet nesne kalıp dizgesi için
   geçerli mi, değil mi?
   Geçerliyse 1,
   değilse 0 dönsün ve bir hata iletisi bassın.  */

int
validate_args (char *format, int nargs, OBJECT *args)
{
  int *argtypes;
  int nwanted;

  /* <replaceable>Bağımsız değişkenler hakkında bilgi al.
     Her dönüşüm belirtimi en az iki karakterlik olmalı,
     o halde dizgenin yarı uzunluğundan daha fazla sayıda
     belirtim olamaz.</replaceable>  */

  argtypes = (int *) alloca (strlen (format) / 2 * sizeof (int));
  nwanted = parse_printf_format (format, nargs, argtypes);

  /* <replaceable>Bağımsız değişken sayısına bak.</replaceable>  */
  if (nwanted &gt; nargs)
    {
      error ("Çok az bağımsız değişken (en azından %d gerekir)", nwanted);
      return 0;
    }

  /* <replaceable>Her bağımsız değişkenin C türüne ve</replaceable>
     <replaceable>belirtilen nesnenin uygunluğuna bak.</replaceable>  */
  for (i = 0; i &lt; nwanted; i++)
    {
      int istenen;

      if (argtypes[i] &amp; PA_FLAG_PTR)
	istenen = STRUCTURE;
      else
	switch (argtypes[i] &amp; ~PA_FLAG_MASK)
	  {
	  case PA_INT:
	  case PA_FLOAT:
	  case PA_DOUBLE:
	    istenen = NUMBER;
	    break;
	  case PA_CHAR:
	    istenen = CHAR;
	    break;
	  case PA_STRING:
	    istenen = STRING;
	    break;
	  case PA_POINTER:
	    istenen = STRUCTURE;
	    break;
	  }
      if (TYPE (args[i]) != istenen)
	{
	  error ("%d. bağımsız değişken için tür uyumsuz", i);
	  return 0;
	}
    }
  return 1;
}
</screen>
   </example>
  </sect1>
 </chapter>

 <chapter xml:id="glibc-Customizing-Printf" userlevel="longtoc">
  <title><code>printf</code> İşlevinin Özelleştirilmesi</title>
  <titleabbrev><code>printf</code> ve arkadaşları için yeni dönüşüm belirtimleri
  tanımlanabilir.</titleabbrev>
  <preliminary>
   <para>
    <indexterm linkend="glibc-cp"><primary>biçimli çıktı</primary><secondary>özelleştirilmesi</secondary></indexterm>
    <indexterm linkend="glibc-cp"><primary>biçimli çıktı</primary><secondary>dönüşüm belirtimleri</secondary><tertiary>yenisini tanımlama</tertiary></indexterm>
    &glibc; uygulamanızın önemli veri yapılarını basacak becerikli yöntemleri <function>printf</function> işlevine  öğretecek özelleştirilmiş dönüşüm belirteçleri tanımlamanızı mümkün kılar.
   </para>
   <para>
    Bunu yapmanın yolu <function>register_printf_function</function> işlevini kullanarak dönüşümleri kaydetmektir; Bkz. <xref linkend="glibc-Registering-New-Conversions"/>. Bu işleve aktarılacak bağımsız değişkenlerden biri asıl çıktılamayı yapacak olan işleve gösterici olacaktır; bu işlevin nasıl yazılacağı  <xref linkend="glibc-Defining-the-Output-Handler"/> bölümünde anlatılmıştır.
   </para>
   <para>
    Ayrıca tanımlanan dönüşüm belirteçleri tarafından kullanılacak bağımsız değişkenlerin sayısı ve türü hakkında bilgi veren bir işlev de yazılabilir; bu konu için bkz. <xref linkend="glibc-Parsing-a-Template-String"/>.
   </para>
   <para>
    Bu kısımda sözü edilen oluşumlar &printf.h; başlık dosyasında bildirilmiştir.
   </para>
   <note><title>Taşınabilirlik Bilgisi:</title>
    <para>
     <function>printf</function> kalıp dizgesi sözdiziminin geliştirilebilirlik özelliği bir GNU oluşumudur. &isoc; standardında buna benzer bir şey yoktur. GNU C derleyicisini veya standart G/Ç işlevlerine yapılan çağrıları dil standardının kurallarına göre yorumlayan başka herhangi bir derleyiciyi kullanılırken, uygun derleyici seçeneğiyle böyle bir yorumlamayı devre dışı bırakmak gerekir. Aksi takdirde, bu oluşuma dayanan bir yazılımın davranışı tanımsızdır.
    </para>
   </note>
  </preliminary>

  <sect1 xml:id="glibc-Registering-New-Conversions">
   <title>Yeni Dönüşümlerin Kaydı</title>
   <titleabbrev><code>register_printf_function</code> ile yeni dönüşüm belirteçlerinin kaydedilmesi.</titleabbrev>
   <para>
    <dicterm><english>register</english><turkish>yazmaç</turkish></dicterm>
    <function>register_printf_function</function> işlevi &printf.h; başlık dosyasında bildirilmiştir ve yeni tanımladığınız dönüşüm belirtecini kaydetmek için kullanılır.
    <indexterm linkend="glibc-pg"><primary>printf.h</primary></indexterm>
   </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-register_printf_function"><primary>register_printf_function</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-register_printf_function"><primary>biçimli çıktı</primary><secondary>dönüşüm belirtecinin kaydedilmesi</secondary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>register_printf_function</function></csname>
     <csparam><type>int</type><parameter>spec</parameter></csparam>
     <csparam><type>printf_function</type><parameter>handler-function</parameter></csparam>
     <csparam><type>printf_arginfo_function</type><parameter>arginfo-function</parameter></csparam>
    </csproto>
    <header>&printf.h;</header>
    <conceptlist>
     <concept>&mtunsafe; &const;<code linkend="glibc-safety-identifier">:printfext</code></concept>
     <concept>&asunsafe; &heap; &lock;</concept>
     <concept>&acunsafe; &mem; &lock;</concept>
    </conceptlist>
    <para>
     Bu işlev <parameter>spec</parameter> dönüşüm belirteç karakterini tanımlar. Eğer <parameter>spec</parameter> <code>'Y'</code> ise dönüşüm belirteci '<code>%Y</code>' olacaktır. '<code>%s</code>' gibi yerleşik dönüşüm belirteçleri de tanımlanabilir ama '<code>#</code>' gibi im karakterleri '<code>l</code>' gibi tür değiştiricileri dönüşüm karakteri olarak tanımlanamaz. İşlev bu karakterlerden biri ile çağrılırsa hiçbir etkisi olmaz. Küçük harflerin dönüşüm karakteri olarak tanımlanmaması iyi olur, çünkü &isoc; standardı, standardın gelecekteki iyileştirmelerinde başka küçük harflerin de standarda dahil edebileceği konusunda uyarıyor.
    </para>
    <para>
     <parameter>handler-function</parameter> (işleyici işlev), bir kalıp dizgesinde tanımlanan karakterlerlerden birine rastlarsa <function>printf</function> ve arkadaşları tarafından çağrılacak işlevdir. Bağımsız değişken olarak atanan böyle bir işlevin nasıl tanımlanacağı <xref linkend="glibc-Defining-the-Output-Handler"/> bölümünde açıklanmıştır. Bu bağımsız değişkene boş gösterici belirtilirse, <parameter>spec</parameter> için atanan işleyici işlev kaldırılır.
    </para>
    <para>
     <parameter>arginfo-function</parameter> (bağımsız değişken bilgileri işlevi) ise, bu dönüşüm belirteci bir kalıp dizgesinde kullanıldığında <function>parse_printf_format</function> işlevi tarafından çağrılır. Bu konu hakkında daha ayrıntılı bilgi almak için bkz. <xref linkend="glibc-Parsing-a-Template-String"/>.
    </para>
    <caution>
     <para>
      &glibc;nin 2.0 öncesi sürümlerinde <function>parse_printf_format</function> işlevi çağrılmadıkça <parameter>arginfo-function</parameter> işlevinin tanımlanması gerekmiyordu. Bu şimdi değişti. Artık, dönüşüm belirteci kalıp dizgesinde kullanılmışsa her <function>printf</function> çağrısında bu işlev çağrılmaktadır.
     </para>
    </caution>
    <para>
     İşlev başarı durumunda <code>0</code> ile döner. Hata oluşması halinde (<parameter>spec</parameter> aralık dışındaysa) <code>-1</code> ile döner.
    </para>
    <note><title>Taşınabilirlik Bilgisi:</title>
     <para>
      Standart çıktı dönüşümlerini yeniden tanımlamak mümkündür, ancak dönüşümlerin etkilerinin ilgili dil standartlarına uygun olduğunu varsayan yazılımların ve derleyici gerçeklenimlerinin davranışlarıyla etkileşebileceğinden, bunu yapmak kesinlikle önerilmez. Ek olarak, uyumlu derleyicilerin, standart bir dönüşüm için kaydedilen işlevin, bir yazılımdaki her biçim dizgesindeki bu tür her dönüşüm için çağrılacağını garanti etmesi gerekmez.
     </para>
    </note>
   </csynopsis>
  </sect1>

  <sect1 xml:id="glibc-Conversion-Specifier-Options">
   <title>Dönüşüm Belirteci Seçenekleri</title>
   <titleabbrev>Bir kalıpta belirtilmiş seçenekler için bir yapı olabilir.</titleabbrev>
   <para>
    Bir dönüşüm belirteci olarak '<code>%A</code>' tanımlanmış olsun, bir kalıp örneğin, '<code>%+23A</code>' veya '<code>%-#A</code>' içeriyorsa ne olacak? Dönüşüm belirteçleri ile birlikte verilen seçeneklerin tanımlanacağı bir yapı olabilir.
   </para>
   <para>
    Hem işleyici işlev hem de bağımsız değişken bilgileri işlevi bir dönüşüm belirtecinde görülen seçenekler hakkında bilgi içeren <type>struct&#160;printf_info</type> yapısına gösterici alır. Bu veri türü &printf.h; başlık dosyasında bildirilmiştir.
    <indexterm linkend="glibc-pg"><primary>printf.h</primary></indexterm>
   </para>
   <csynopsis>
    <indexterm linkend="glibc-tp" xml:id="glibc-tp-printf_info"><primary sortas="printf_info">struct&#160;printf_info</primary></indexterm>
    <csproto type="veri türü">
     <csname><type>struct</type><function>printf_info</function></csname>
    </csproto>
    <header>&printf.h;</header>
    <para>
     Bu yapı bir kalıp dizgesindeki dönüşüm belirteçleri için kullanılan bağımsız değişken türleri ve sayıları hakkında bilgi veren ve bu belirteçleri çıktılayan işlevlere bilgi aktarmak için kullanılır. Yapı üyeleri şunlardır:
    </para>
    <glosslist>
     <glossentry>
      <glossterm>
       <type>int&#160;</type><structfield>prec</structfield>
      </glossterm>
      <glossdef>
       <para>
        Belirtilen hassasiyettir. Hassasiyet belirtilmemişse değeri <code>-1</code>’dir. Hassasiyet '<code>*</code>' olarak verilmişse, işleyici işleve aktarılan <type>printf_info</type> yapısı bağımsız değişken listesinden alınan değeri içerir. Ancak bağımsız değişken türleri ve sayısı için bilgi veren işleve aktarılan yapı, değer bilinmediğinden <varname>INT_MIN</varname> değerini içerir.
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm>
       <literal>int&#160;</literal><structfield>width</structfield>
      </glossterm>
      <glossdef>
       <para>
        Belirtilen en küçük alan genişliğidir. <code>0</code> değeri bir genişlik belirtilmediği anlamına gelir. Alan genişliği '<code>*</code>' olarak verilmişse, işleyici işleve aktarılan <type>printf_info</type> yapısı bağımsız değişken listesinden alınan değeri içerir. Ancak bağımsız değişken türleri ve sayısı için bilgi veren işleve aktarılan yapı, değer bilinmediğinden <varname>INT_MIN</varname> değerini içerir.
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm>
       <literal>wchar_t&#160;</literal><structfield>spec</structfield>
      </glossterm>
      <glossdef>
       <para>
        Belirtilen dönüşüm belirteci karakteridir. Bunun yapı içinde bulunmasının sebebi çok sayıda karaktere aynı işleyici işlevi kaydedebilmenizi sağlamaktır, ancak bu olmasa bile işleyici işlevi çağırdığınızda onları ayıracak bir yol vardır.
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm>
       <literal>unsigned&#160;int&#160;</literal><structfield>is_long_double</structfield>
      </glossterm>
      <glossdef>
       <para>
        ‘<code>L</code>’, ‘<code>ll</code>’ veya ‘<code>q</code>’ tür değiştiricileri belirtilmişse değeri, mantıksal doğrudur. Kayan noktalı sayı dönüşümlerinde bu <type>long&#160;double</type> iken tamsayı dönüşümlerinde <type>long&#160;long&#160;int</type>’tir.
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm>
       <literal>unsigned&#160;int&#160;</literal><structfield>is_char</structfield>
      </glossterm>
      <glossdef>
       <para>
        ‘<code>hh</code>’ tür değiştiricisi belirtilmişse değeri mantıksal doğrudur.
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm>
       <literal>unsigned&#160;int&#160;</literal><structfield>is_short</structfield>
      </glossterm>
      <glossdef>
       <para>
        ‘<code>h</code>’ tür değiştiricisi belirtilmişse değeri mantıksal doğrudur.
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm>
       <literal>unsigned&#160;int&#160;</literal><structfield>is_long</structfield>
      </glossterm>
      <glossdef>
       <para>
        ‘<code>l</code>’ tür değiştiricisi belirtilmişse değeri mantıksal doğrudur.
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm>
       <literal>unsigned&#160;int&#160;</literal><structfield>alt</structfield>
      </glossterm>
      <glossdef>
       <para>
        ‘<code>#</code>’ seçeneği belirtilmişse değeri mantıksal doğrudur.
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm>
       <literal>unsigned&#160;int&#160;</literal><structfield>space</structfield>
      </glossterm>
      <glossdef>
       <para>
        ‘&#160; ’ seçeneği belirtilmişse değeri mantıksal doğrudur.
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm>
       <literal>unsigned&#160;int&#160;</literal><structfield>left</structfield>
      </glossterm>
      <glossdef>
       <para>
        ‘<code>-</code>’ seçeneği belirtilmişse değeri mantıksal doğrudur.
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm>
       <literal>unsigned&#160;int&#160;</literal><structfield>showsign</structfield>
      </glossterm>
      <glossdef>
       <para>
        ‘<code>+</code>’ seçeneği belirtilmişse değeri mantıksal doğrudur.
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm>
       <literal>unsigned&#160;int&#160;</literal><structfield>group</structfield>
      </glossterm>
      <glossdef>
       <para>
        ‘<code>'</code>’ seçeneği belirtilmişse değeri mantıksal doğrudur.
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm>
       <literal>unsigned&#160;int&#160;</literal><structfield>extra</structfield>
      </glossterm>
      <glossdef>
       <para>
        Bu üyenin değerinin bağlama özgü bir anlamı vardır. Yapı <function>printf</function> işlevi tarafından kullanılmışsa değeri <code>0</code>’dır. Kullanıcı tarafından tanımlanmış bir işlev tarafından kullanıldığında ise herhangi bir değer içerebilir.
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm>
       <literal>unsigned&#160;int&#160;</literal><structfield>wide</structfield>
      </glossterm>
      <glossdef>
       <para>
        Akım geniş yönlenimli ise bu üyenin değeri <code>1</code>’dir.
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm>
       <literal>wchar_t&#160;</literal><structfield>pad</structfield>
      </glossterm>
      <glossdef>
       <para>
        Çıktıda en küçük alan genişliğinde boş kalan yerlere yerleştirilecek karakterdir. Boş kalan yerler sıfırlarla doldurulursa bu üyenin değeri <code>'0'</code>’dır, aksi takdirde <code>' '</code> yani boşluktur.
       </para>
      </glossdef>
     </glossentry>
    </glosslist>
   </csynopsis>
  </sect1>

  <sect1 xml:id="glibc-Defining-the-Output-Handler">
   <title>İşleyici İşlevin Tanımlanması</title>
   <titleabbrev><code>register_printf_function</code> işlevine aktarılacak işleyici işlev ile bağımsız değişken bilgileri işlevinin tanımlanması.</titleabbrev>
   <para>
    Bu bölümde <function>register_printf_function</function> işlevine aktarılacak işleyici işlev ile bağımsız değişken bilgileri işlevinin nasıl tanımlanacağı açıklanacaktır.
   </para>
   <note><title>Uyumluluk Bilgisi:</title>
    <para>
     Arayüz &glibc; 2.0 sürümünde değiştirilmiştir. Bundan önce üçüncü bağımsız değişkenin türü <type>va_list&#160;*</type> idi.
    </para>
   </note>
   <csynopsis>
    <indexterm linkend="glibc-tp" xml:id="glibc-tp-printf_function"><primary>printf_function</primary></indexterm>
    <csproto type="veri türü">
     <csname><type>int</type><function>printf_function</function></csname>
     <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
     <csparam><ptr>const&#160;struct&#160;printf_info</ptr><parameter>info</parameter></csparam>
     <csparam><ptr>const&#160;void&#160;*const</ptr><parameter>args</parameter></csparam>
    </csproto>
    <header>&printf.h;</header>
    <para>
     <code>printf_function</code> türü, <function>register_printf_function</function> işlevinin <parameter>handler-function</parameter> (işleyici-işlev) bağımsız değişkeninin türüdür.
    </para>
    <para>
     Yazılımda <function>parse_printf_format</function> işlevi kullanılacaksa, <function>register_printf_function</function> ile tanımlanacak her dönüşüm belirteci için <parameter>handler-function</parameter> bağımsız değişkeni ile aktarılacak işlevin de tanımlanması gerekir. İşlevin sözdizimi bu türün bildirimindeki gibi olmalıdır.
    </para>
    <para>
     <parameter>stream</parameter> bağımsız değişkeni, işleyici işlevin çıktıyı yazacağı akımdır.
    </para>
    <para>
     <parameter>info</parameter> bağımsız değişkeni, kalıp dizgesindeki belirteç ile birlikte belirtilen çeşitli seçenekler hakkında bilgi içeren yapıya göstericidir. Bu veri yapısının işleyici işlev içinde değiştirilmemesi gerekir. Bu veri yapısının açıklamaları için bkz. <xref linkend="glibc-Conversion-Specifier-Options"/>.
    </para>
    <para>
     <parameter>args</parameter> bağımsız değişkenlerin verilerine göstericileri içeren bir gösterici dizisidir. Bağımsız değişken sayısı, yazılımcı tarafından tanımlanan bağımsız değişken bilgileri işlevi çağrılarak elde edilir.
    </para>
    <para>
     Yazılımcı tarafından tanımlanacak bu işleyici-işlev de tıpkı <function>printf</function> işlevi gibi değer döndürmelidir: Ya çıktılanan karakterlerin sayısı ile dönmeli ya da hata durumunda hatayı ifade eden negatif bir değer ile dönmelidir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-tp" xml:id="glibc-tp-printf_arginfo_function"><primary>printf_arginfo_function</primary></indexterm>
    <csproto type="veri türü">
     <csname><type>int</type><function>printf_arginfo_function</function></csname>
     <csparam><ptr>const&#160;struct&#160;printf_info</ptr><parameter>info</parameter></csparam>
     <csparam><type>size_t</type><parameter>n</parameter></csparam>
     <csparam><ptr>int</ptr><parameter>argtypes</parameter></csparam>
    </csproto>
    <header>&printf.h;</header>
    <para>
     <function>register_printf_function</function> işlevinin <parameter>arginfo-function</parameter> bağımsız değişkeni ile aktarılacak işlevin sözdizimi bu türün bildirimindeki gibi olmalıdır.
    </para>
    <para>
     İşlevden dönen değer, dönüşümü umulan bağımsız değişkenlerin sayısı olmalıdır. İşlev ayrıca <function>printf</function> işlevinin bağımsız değişkenlerinin her biri için tür bilgisini içeren en çok <parameter>n</parameter> elemanlı <parameter>argtypes</parameter> dizisini de doldurmalıdır. Bu bilgi <code>PA_</code> makroları kullanılarak kodlanır. (Bu, <function>parse_printf_format</function> işlevinin kullandığı çağrı ile aynı yapıdaysa bir uyarı verilir.)
    </para>
   </csynopsis>
  </sect1>
  <sect1 xml:id="glibc-Printf-Extension-Example">
   <title><code>printf</code> Genişletme Örneği</title>
   <titleabbrev><code>printf</code> işleyici işlevi nasıl tanımlanır.</titleabbrev>
   <example>
    <para>
     Burada bir <function>printf</function> işleyici işlevinin nasıl tanımlanacağı örneklenmiştir. Bu yazılım <code>Widget</code> isimli bir veri yapısı ve <code>Widget&nbsp;*</code> bağımsız değişkenleri hakkında bilgi basacak '<code>%W</code>' dönüşüm belirtecini tanımlar. '<code>%W</code>' dönüşüm belirteci en küçük alan genişliği ile sola yanaştırma imini desteklemekte diğer herşeyi yok saymaktadır.
    </para>
    <screen>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;printf.h&gt;

typedef struct
{
  char *name;
}
Widget;

int
print_widget (FILE *stream,
              const struct printf_info *info,
              const void *const *args)
{
  const Widget *w;
  char *buffer;
  int len;

  /* <replaceable>Bir dizgeye çıktılanacak biçim.</replaceable> */
  w = *((const Widget **) (args[0]));
  len = asprintf (&amp;buffer, "&lt;Widget %p: %s&gt;", w, w-&gt;name);
  if (len == -1)
    return -1;

  /* <replaceable>En küçük alan genişliğini doldurup akıma bas.</replaceable> */
  len = fprintf (stream, "%*s",
                 (info-&gt;left ? -info-&gt;width : info-&gt;width),
                 buffer);

  /* <replaceable>Ortalığı temizle ve dön.</replaceable> */
  free (buffer);
  return len;
}


int
print_widget_arginfo (const struct printf_info *info, size_t n,
                      int *argtypes)
{
  /* <replaceable>Daima tek bir bağımsız değişken alınıyor
     ve bu, yapı için bir gösterici oluyor.</replaceable> */
  if (n &gt; 0)
    argtypes[0] = PA_POINTER;
  return 1;
}


int
main (void)
{
  /* <replaceable>Basılacak aracı (mywidget) oluştur.</replaceable> */
  Widget mywidget;
  mywidget.name = "mywidget";

  /* <replaceable>Araçları basacak işlevi kaydet.</replaceable> */
  register_printf_function ('W', print_widget, print_widget_arginfo);

  /* <replaceable>Aracı bas.</replaceable> */
  printf ("|%W|\n", &amp;mywidget);
  printf ("|%35W|\n", &amp;mywidget);
  printf ("|%-35W|\n", &amp;mywidget);

  return 0;
}
</screen>
    <para>Yazılımın çıktısı:</para>
    <screen>|&lt;Widget 0xffeffb7c: mywidget&gt;|
|      &lt;Widget 0xffeffb7c: mywidget&gt;|
|&lt;Widget 0xffeffb7c: mywidget&gt;      |
</screen>
   </example>
  </sect1>

  <sect1 xml:id="glibc-Predefined-Printf-Handlers">
   <title>Yerleşik İşleyici İşlevler</title>
   <titleabbrev>Kütüphanede tanımlanmış işleyici işlevler.</titleabbrev>
   <para>
    &glibc; ayrıca <function>printf</function> işleyici oluşumunun somut ve kullanışlı bir uygulamasını içerir. Kayan noktalı sayıları özel bir yolla basmak için iki işlev vardır.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-printf_size"><primary>printf_size</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>printf_size</function></csname>
     <csparam><ptr>FILE</ptr><parameter>fp</parameter></csparam>
     <csparam><ptr>const&#160;struct&#160;printf_info</ptr><parameter>info</parameter></csparam>
     <csparam><ptr>const&#160;void&#160;*const</ptr><parameter>args</parameter></csparam>
    </csproto>
    <header>&printf.h;</header>
    <conceptlist>
     <concept>&mtsafe; &race;<code linkend="glibc-safety-identifier">:fp</code></concept>
     <concept>&asunsafe; &corrupt; &heap;</concept>
     <concept>&acunsafe; &mem; &corrupt;</concept>
    </conceptlist>
    <para>
     Verilen kayan noktalı sayıyı <code>%f</code> dönüşüm belirtecini kullanarak özel bir şekilde basar. Sayıyı 1000’den daha küçük bir sayı olarak ifade eden bir birim karakteri kullanılır. Bu birim karakteri bölene karşılıktır. Mümkün iki bölen vardır; biri 1000'in kuvvetleri diğeri 1024'ün kuvvetleri. Birim, küçük harf ise 1024'ün kuvvetleri, büyük harf ise 1000'in kuvvetleri kullanılır.
    </para>
    <para>
     Birim bayt, kilobayt, megabayt, gigabayt, vs. karşılığı bir karakterdir. Tamamı tablo olarak:
    </para>
    <informaltable>
     <tgroup cols="5">
      <colspec align="center"/>
      <colspec align="right"/>
      <colspec align="center"/>
      <colspec align="center"/>
      <colspec align="right"/>
      <thead>
       <row rowsep="0">
        <entry>Birim</entry>
        <entry></entry>
        <entry>Birim</entry>
        <entry>Birim</entry>
        <entry></entry>
       </row>
       <row>
        <entry>harfi</entry>
        <entry align="center">Çarpan</entry>
        <entry>ismi</entry>
        <entry>harfi</entry>
        <entry align="center">Çarpan</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>' '</entry>
        <entry>1</entry>
        <entry/>
        <entry>' '</entry>
        <entry>1</entry>
       </row>
       <row>
       <entry>k</entry>
       <entry>2<superscript>10</superscript> (1024)</entry>
       <entry>kilo</entry>
       <entry>K</entry>
       <entry>10<superscript>3</superscript> (1000)</entry>
      </row>
      <row>
       <entry>m</entry>
       <entry>2<superscript>20</superscript></entry>
       <entry>mega</entry>
       <entry>M</entry>
       <entry>10<superscript>6</superscript></entry>
      </row>
      <row>
       <entry>g</entry>
       <entry>2<superscript>30</superscript></entry>
       <entry>giga</entry>
       <entry>G</entry>
       <entry>10<superscript>9</superscript></entry>
      </row>
      <row>
       <entry>t</entry>
       <entry>2<superscript>40</superscript></entry>
       <entry>tera</entry>
       <entry>T</entry>
       <entry>10<superscript>12</superscript></entry>
      </row>
      <row>
       <entry>p</entry>
       <entry>2<superscript>50</superscript></entry>
       <entry>peta</entry>
       <entry>P</entry>
       <entry>10<superscript>15</superscript></entry>
      </row>
      <row>
       <entry>e</entry>
       <entry>2<superscript>60</superscript></entry>
       <entry>egza</entry>
       <entry>E</entry>
       <entry>10<superscript>18</superscript></entry>
      </row>
      <row>
       <entry>z</entry>
       <entry>2<superscript>70</superscript></entry>
       <entry>zeta</entry>
       <entry>Z</entry>
       <entry>10<superscript>21</superscript></entry>
      </row>
      <row>
       <entry>y</entry>
       <entry>2<superscript>80</superscript></entry>
       <entry>yotta</entry>
       <entry>Y</entry>
       <entry>10<superscript>24</superscript></entry>
      </row>
     </tbody>
    </tgroup>
   </informaltable>
   <para>
    Öntanımlı hassasiyet 3’tür, örneğin 1024  sayısı için dönüşüm belirtimi küçük birim harfi ile <code>%.3fk</code> olarak yazılır ve bunun çıktısı <code>1.000k</code> olur.
   </para>
  </csynopsis>
  <para>
   <function>register_printf_function</function> işlevinin gereksinimlerinden dolayı bağımsız değişkenler hakkında bilgi döndüren bir işlev daha üretmek gerekir.
  </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-printf_size_info"><primary>printf_size_info</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>printf_size_info</function></csname>
     <csparam><ptr>const&#160;struct&#160;printf_info</ptr><parameter>info</parameter></csparam>
     <csparam><type>size_t</type><parameter>n</parameter></csparam>
     <csparam><ptr>int</ptr><parameter>argtypes</parameter></csparam>
    </csproto>
    <header>&printf.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     Bu işlev, <function>vfprintf</function> gerçekleniminin beklediği şekilde, kullanılan bağımsız değişkenler hakkındaki bilgileri <parameter>argtypes</parameter> bağımsız değişkeninde döndürür. Biçim her zaman bir bağımsız değişken alır.
    </para>
   </csynopsis>
   <para>
    Bu iki işlev kullanılırken aşağıdakine benzer bir çağrı ile kaydedilmelidir:
   </para>
   <screen>register_printf_function ('B', printf_size, printf_size_info);
</screen>
   <para>
    Burada <code>'B'</code> belirteç karakteri büyük harf olduğundan sayıları 1000'in kuvveti olarak basacak bir işlevi kaydetmiş olduk. Buna ek olarak <code>'b'</code> harfini de kullanmak için bir çağrı daha yapılmalıdır:
   </para>
   <screen>register_printf_function ('b', printf_size, printf_size_info);
</screen>
   <para>
    Böylece 1024'ün kuvveti de basılabilecek. Burada dikkat edilirse iki işlevde dönüşüm belirteçleri farklıdır. <function>printf_size</function> işlevi sadece büyük ve küçük harfli biçim belirteçleri arasındaki farkı bilir.
   </para>
   <para>
    <code>'B'</code> ve <code>'b'</code> kullanımı hiç de tesadüf değildir. Hatta bunları biçim belirteci olarak kullanan bazı sistemler de olduğundan bu işlevselliği kullanmak tercih edilen yoldur.
   </para>
  </sect1>
 </chapter>

 <chapter xml:id="glibc-Formatted-Input">
  <title>Biçimli Girdi</title>
  <titleabbrev><code>scanf</code> ve ilgili işlevler.</titleabbrev>
  <preliminary>
   <para>
    <indexterm linkend="glibc-cp"><primary>biçimli girdi</primary><secondary>biçim dizgesi</secondary></indexterm>
    <indexterm linkend="glibc-cp"><primary>biçimli girdi</primary><secondary>kalıp dizgesi</secondary></indexterm>
    <indexterm linkend="glibc-cp"><primary>akımlar</primary><secondary>okuma</secondary><tertiary>biçimli</tertiary></indexterm>
    Bu kısımda açıklanan işlevler (<function>scanf</function> ve ilgili işlevler) biçimli çıktı oluşumlarına benzer olarak biçimli girdi için kullanılır. Bu işlevler bir <wordasword>biçim dizgesi</wordasword> veya bir <wordasword>kalıp dizgesi</wordasword>nin denetimi altında değer okumak için düzenek sağlar.
   </para>
  </preliminary>

  <sect1 xml:id="glibc-Formatted-Input-Basics">
   <title>Biçimli Girdi Okumanın Temelleri</title>
   <titleabbrev>Başlangıç olarak bilinmesi gerekenler.</titleabbrev>
   <para>
    <indexterm linkend="glibc-cp"><primary>biçimli girdi</primary><secondary>dönüşüm belirtimleri</secondary></indexterm>
    <indexterm linkend="glibc-cp"><primary>biçimli girdi</primary><secondary>eşleşme hatası</secondary></indexterm>
    <function>scanf</function> çağrıları bağımsız değişkenleri bir kalıp dizgenin denetimi altında okumasından dolayı yüzeysel olarak <function>printf</function> çağrılarına benzer. Kalıp dizgesindeki dönüşüm belirtimlerinin sözdizimleri <function>printf</function> işlevininkilere çok benzese de, kalıp dizgesinin yorumlanması sabit alanlı biçimlemeden ziyade daha serbest biçimli ve basit kalıp eşleştirme yönündedir. Örneğin, çoğu <function>scanf</function> dönüşümü dosyadaki boş alanları (boşluk, sekme, satırsonu) atlar ve çıktı dönüşümlerindekinin aksine sayısal girdi dönüşümleri için hassasiyet diye bir kavrama sahip değildir. Ekseriyetle, kalp dizgesindeki boşluk olmayan karakterlerin girdi akımındaki karakterlerle eşleşeceği umulur, ancak bir eşleşmenin bulunamaması akım üzerindeki bir girdi hatası ile karıştırılmaz.
   </para>
   <para>
    <function>scanf</function> ile <function>printf</function> arasındaki diğer bir farklı alan, <function>scanf</function> işlevinin isteğe bağlı bağımsız değişkenlerinin doğrudan değer olarak değil göstericiler sağlayarak alındığını unutmamak gerektiğidir; okunan değerler göstericilerin gösterdiği nesnelerde saklanır. Deneyimli yazılımcılar bile kimi zaman bunu unutur, eğer yazılım <function>scanf</function> ile ilgili olarak tuhaf hatalar veriyorsa bu özellik için çifte denetim yapılmalıdır.
   </para>
   <para>
    Bir <wordasword>eşleşme hatası</wordasword> oluştuğunda, <function>scanf</function> işlevi ilk eşleşmeyen karakteri akımdan okunacak sonraki karakter olarak bırakarak hemen döner. Normalde <function>scanf</function> işlevinden dönen değer, atanmış değerlerin sayısıdır. Bu değere bakarak bir okunmamış karakter varsa eşleşme hatasının oluştuğu yer bulunabilir.
   </para>
   <example>
    <para>
     <function>scanf</function> işlevi genellikle, tabloların içeriklerini okumak gibi şeyler için kullanılır. Örneğin, buradaki işlev <type>double</type> türünde bir diziyi ilklendirmek için <function>scanf</function> işlevini kullanmaktadır:
    </para>
    <screen>void
readarray (double *array, int n)
{
  int i;
  for (i=0; i&lt;n; i++)
    if (scanf (" %lf", &amp;(array[i])) != 1)
      invalid_input_error ();
}
</screen>
   </example>
   <para>
    Biçimli girdi işlevleri, biçimli çıktı işlevleri kadar sık kullanılmaz. Kısmen, düzgün olarak kullanmak biraz dikkat gerektirdiğindendir. Diğer bir sebep, bir eşleşme hatasından kurtulmanın zorluğudur.
   </para>
   <para>
    Tek başına, sabit bir kalıpla eşleşmeyecek bir girdi okunmaya çalışılacaksa, <function>scanf</function> kullanmaktansa, bir sözel tarayıcı üretmede Flex ya da bir çözümleyici üretmede Bison gibi bir araç kullanmak daha iyi olabilir. Bu araçlar hakkında bilgi almak için bkz. <link xl:href="https://www.gnu.org/software/bison/manual/bison.html#Top">Bison Kılavuzu</link> ve <link xl:href="https://westes.github.io/flex/manual/index.html#Top">Flex Kılavuzu</link>
   </para>
  </sect1>

  <sect1 xml:id="glibc-Input-Conversion-Syntax">
   <title>Girdi Dönüşüm Sözdizimi</title>
   <titleabbrev>Dönüşüm belirtimlerinin sözdizimi.</titleabbrev>
   <para>
    <function>scanf</function> kalıp dizgesi, sıradan çok baytlı karakterler arasına serpiştirilmiş <code>%</code> ile başlayan dönüşüm belirtimleri içeren bir dizgedir.
   </para>
   <para>
    Kalıptaki boşluk karakterleri (<function>isspace</function> işlevinin tanıdıkları, bkz. <xref linkend="glibc-Classification-of-Characters"/>) girdi akımından boşluk karakterlerini okutur ve bunlar iptal edilir. Eşleşmesi istenen boşluk karakterleri ile okunacak boşluk karakterlerinin aynı karakterler olması gerekmez. Örneğin kalıba `<code> , </code>' yazılırsa bir virgül ve virgülün önünde ve/veya ardında isteğe bağlı boşluk karakterleri ile eşleşir.
   </para>
   <para>
    Dönüşüm belirteçlerinin parçası olmayan tüm karakterler girdidekilerle aynen eşleşmelidir; bu eşleşme olmazsa bir eşleşme hatası oluşur.
   </para>
   <para>
    <function>scanf</function> kalıp dizgesindeki dönüşüm belirtimlerinin genel şekli:
    </para>
    <literallayout class="monospaced"><code>%</code> <replaceable>imler genişlik tür dönüşüm</replaceable>
</literallayout>
    <para>
     Ayrıntılı olarak, dönüşüm belirtimi '<code>%</code>' imini izleyen aşağıdaki parçalardan oluşur:
    </para>
    <itemizedlist>
     <listitem>
      <para>
       <indexterm linkend="glibc-cp" xml:id="glibc-cp-flags-star"><primary>biçimli girdi</primary><secondary>im karakteri</secondary><tertiary>*</tertiary></indexterm>
       İsteğe bağlı '<command>*</command>' <wordasword>im karakteri</wordasword>, belirtim için okunan metni yok saymasını söyler. <command>scanf</command> bu imi kullanan bir belirtim bulduğunda, dönüşüm belirtiminin kalanı tarafından yönlendirildiği şekilde girdiyi okur ve bu girdiyi iptal eder, gösterici kullanılmaz ve başarılı atamalar sayacı artırılmaz.
      </para>
     </listitem>
     <listitem>
      <para>
       <indexterm linkend="glibc-cp" xml:id="glibc-cp-flags-a"><primary>biçimli girdi</primary><secondary>im karakteri</secondary><tertiary>a</tertiary></indexterm>
       İsteğe bağlı '<command>a</command>' <wordasword>im karakteri</wordasword> (sadece dizge dönüşümlerinde geçerli) dizgeyi saklamak için yeterli uzulukta bir tampon ayrılmasını söyler. (Bu im GNU oluşumudur.) Bkz. <xref linkend="glibc-Dynamic-String-Input"/>.
      </para>
     </listitem>
     <listitem>
      <para>
       <indexterm linkend="glibc-cp" xml:id="glibc-cp-inputs-maxwidth"><primary>biçimli girdi</primary><secondary>en büyük alan genişliği</secondary></indexterm>
       İsteğe bağlı <wordasword>en büyük alan genişliği</wordasword> onluk bir tamsayıdır. En büyük genişlik aşıldığında ya da eşleşmeyen karaktere rastlandığında girdi akımından karakterlerin okunması durdurulur. Çoğu dönüşümde okunan boşluk karakterleri (bunlar açıkça belgelendirilmiş değildir) iptal edilir ve bu iptal edilen karakterler en büyük alan genişliğinden sayılmaz. Dizge girdi dönüşümleri girdinin sonuna boş karakter ekler, bu karakter de en büyük alan genişliğine dahil edilmez.
      </para>
     </listitem>
     <listitem>
      <para>
       <indexterm linkend="glibc-cp" xml:id="glibc-cp-inputs-types"><primary>biçimli girdi</primary><secondary>tür değiştirici karakter</secondary></indexterm>
       İsteğe bağlı <wordasword>tür değiştirici karakter</wordasword>. Örneğin, <type>int</type> türünden gösterici bağımsız değişkeni belirten '<code>%d</code>' dönüşüm belirteci ile '<code>l</code>' tür değiştiricisi tamsayı dönüşümü için belirtilerek gösterici türü <type>long&nbsp;int</type> olarak değiştirilebilir.
      </para>
     </listitem>
     <listitem>
      <para>
       Uygulanacak dönüşümü belirten karakter.
      </para>
     </listitem>
    </itemizedlist>
    <para>
     İzin verilen seçenekler ve yorumlanışları farklı dönüşüm belirtimleri arasında değişkenlik gösterir. Bir seçeneğin, kullanıldığı dönüşümdeki yorumlanışı ile ilgili bilgiler, o dönüşümün açıklamalarında bulunabilir.
    </para>
    <para>
     <option>-Wformat</option> seçeneği ile GNU C derleyicisi <function>scanf</function> ve ilgili işlevleri denetler. Biçim dizgesini inceleyip doğru sayı ve türde bağımsız değişken belirtilip belirtilmediğini denetler. GNU C derleyicisine <function>scanf</function> tarzı biçim dizgesini denetletecek bir sözdizimi de vardır. (Ayrıntılı bilgi için GCC belgelerinde, <link xl:href="https://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html#Function-Attributes">Declaring Attributes of Functions</link> (İşlev Özniteliklerinin Bildirilmesi) bölümüne bakılabilir.
    </para>
  </sect1>
  <sect1 xml:id="glibc-Table-of-Input-Conversions">
    <title>Girdi Dönüşüm Belirtimlerinin Listesi</title>
    <titleabbrev>Girdi dönüşümleri ve ne yaptıklarının bir özeti.</titleabbrev>
    <para>
     <indexterm linkend="glibc-cp"><primary>biçimli girdi</primary><secondary>girdi dönüşüm belirtimleri</secondary></indexterm>
     Aşağıda tüm farklı dönüşümler özetlenmiştir:
    </para>
   <variablelist>
    <varlistentry>
     <term>‘<code>%d</code>’</term>
     <listitem>
      <para>
       Seçimlik olarak onluk tabanda yazılmış bir imli tamsayı ile eşleşir. Bkz.  <xref linkend="glibc-Numeric-Input-Conversions"/>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>‘<code>%i</code>’</term>
     <listitem>
      <para>
       Bir tamsayı sabit için C dilinde tanımlı herhangi bir biçimdeki imli tamsayı ile seçimlik olarak eşleşir. Bkz. <xref linkend="glibc-Numeric-Input-Conversions"/>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>‘<code>%o</code>’</term>
     <listitem>
      <para>
       Sekizlik tabanda yazılmış imli tamsayı ile eşleşir. Bkz. <xref linkend="glibc-Numeric-Input-Conversions"/>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>‘<code>%u</code>’</term>
     <listitem>
      <para>
       Onluk tabanda yazılmış imsiz tamsayı ile eşleşir. Bkz. <xref linkend="glibc-Numeric-Input-Conversions"/>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>‘<code>%x</code>’, ‘<code>%X</code>’</term>
     <listitem>
      <para>
       Onaltılık tabanda yazılmış bir işaretsiz tamsayı ile eşleşir. Bkz. <xref linkend="glibc-Numeric-Input-Conversions"/>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>‘<code>%e</code>’, ‘<code>%f</code>’, ‘<code>%g</code>’, ‘<code>%E</code>’, ‘<code>%G</code>’</term>
     <listitem>
      <para>
       Seçimlik olarak, imli gerçek sayı ile eşleşir. Bkz.  <xref linkend="glibc-Numeric-Input-Conversions"/>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>‘<code>%s</code>’</term>
     <listitem>
      <para>
       Boşluk içermeyen bir dizge ile eşleşir. Bkz. <xref linkend="glibc-String-Input-Conversions"/>. ‘<code>l</code>’ tür değiştiricisinin varlığı dizgenin geniş karakterli ya da çok baytlı dizge olarak ele alınmasını sağlar. ‘<code>%s</code>’ bir geniş karakter işlevinde kullanılmışsa dizge çoklu <function>wcrtomb</function> çağrılarıyla çok baytlı dizgeye dönüştürülür. Bu, tamponda, okunan her karakter için <varname>MB_CUR_MAX</varname> baytlık yer ayrılması gerektiği anlamına gelir. ‘<code>%ls</code>’ çok baytlı bir işlevde kullanıldığında ise sonuç yazılımcının sağladığı tampona yazılmadan önce çoklu <function>mbrtowc</function> çağrılarıyla geniş karakterlere dönüştürülür.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>‘<code>%S</code>’</term>
     <listitem>
      <para>
       Unix standardı ile uyumluluk için ‘<code>%ls</code>’ yerine kullanılmak üzere desteklenmiştir.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>‘<code>%[</code>’</term>
     <listitem>
      <para>
       Belirtilmiş bir kümeye ait olan karakterleri içeren bir dizge ile eşleşir. Bkz. <xref linkend="glibc-String-Input-Conversions"/>. ‘<code>l</code>’ tür değiştiricisinin varlığı dizgenin geniş karakterli ya da çok baytlı dizge olarak ele alınmasını sağlar. ‘<code>%[</code>’ bir geniş karakter işlevinde kullanılmışsa dizge çoklu <function>wcrtomb</function> çağrılarıyla çok baytlı dizgeye dönüştürülür. Bu, tamponda, okunan her karakter için <varname>MB_CUR_MAX</varname> baytlık yer ayrılması gerektiği anlamına gelir. ‘<code>%l[</code>’ birçok baytlı işlevde kullanıldığında ise sonuç yazılımcının sağladığı tampona yazılmadan önce çoklu <function>mbrtowc</function> çağrılarıyla geniş karakterlere dönüştürülür.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>‘<code>%c</code>’</term>
     <listitem>
      <para>
       Bir ya da daha fazla karakterden oluşan bir dizge ile eşleşir. Okunacak karakterlerin sayısı dönüşüm belirtiminde belirtilmiş olan en büyük alan genişliğindedir. Bkz. <xref linkend="glibc-String-Input-Conversions"/>.
      </para>
      <para>
       ‘<code>%c</code>’ bir geniş yönlenimli akım işlevinde kullanılırsa okunan geniş karakter karşılığı olan çok baytlı karaktere dönüştürüldükten sonra saklanır. Bu dönüşüm birden fazla karakter üretebilir, bundan dolayı tamponda her karakter için <varname>MB_CUR_MAX</varname> baytlık yer sağlanmalıdır. ‘<code>%lc</code>’ çok baytlı işlevde kullanılırsa, çok baytlı dizi olarak (bayt değil) ele alınır ve sonuç <function>mbrtowc</function> çağrılarıyla dönüştürülür.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>‘<code>%C</code>’</term>
     <listitem>
      <para>
       Unix standardı ile uyumluluk için ‘<code>%lc</code>’ yerine kullanılmak üzere desteklenmiştir.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>‘<code>%p</code>’</term>
     <listitem>
      <para>
       <function>printf</function> için ‘<code>%p</code>’ çıktı dönüşümü tarafından kullanılan biçimle aynı gerçeklenim tanımlı biçim kullanılarak bir gösterici değeri ile eşleşir. Bkz. <xref linkend="glibc-Other-Input-Conversions"/>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>‘<code>%n</code>’</term>
     <listitem>
      <para>
       Bu dönüşüm herhangi bir karakter okumaz; çağrı tarafından o ana kadar okunan karakterlerin sayısını kaydeder. Bkz. <xref linkend="glibc-Other-Input-Conversions"/>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>‘<code>%%</code>’</term>
     <listitem>
      <para>
       Girdi akımındaki bir ‘<code>%</code>’ karakteri ile eşleşir. Karşılığı olarak bir bağımsız değişken belirtilmez. Bkz. <xref linkend="glibc-Other-Input-Conversions"/>.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    Bir dönüşüm belirtiminin sözdizimi geçersizse, davranış tanımlanmamıştır. Kalıp dizgesinde belirtilenden daha az sayıda art bileşen bağımsız değişken varsa ya da art bileşen bağımsız değişkenlerin türleri ile dönüşüm belirtimleri uyumsuzsa sonucun ne olacağı belirlenmemiştir. Kalıp dizgesinde belirtilenden daha çok art bileşen bağımsız değişken varsa fazla bağımsız değişkenler basitçe yok sayılır.
   </para>
  </sect1>
  <sect1 xml:id="glibc-Numeric-Input-Conversions">
   <title>Sayısal Girdi Dönüşümleri</title>
   <titleabbrev>Sayıların okunması sırasındaki dönüşümlerin ayrıntıları.</titleabbrev>
   <para>
    Bu bölümde, sayısal değerlerin okunması sırasındaki <function>scanf</function> dönüşümleri açıklanmıştır.
   </para>
   <para>
    ‘<code>%d</code>’ dönüşümü seçmeli olarak onluk tabanda bir imli tamsayı ile eşleşir. Sözdizimi <function>strtol</function> işlevinin <parameter>base</parameter> bağımsız değişkeninin <code>10</code> değerli çağrısıyla aynı şekilde tanınır. (Bkz. <xref linkend="glibc-Parsing-of-Integers"/>.)
   </para>
   <para>
    ‘<code>%i</code>’ dönüşümü tamsayı sabit için C dilinde tanımlı herhangi bir biçimdeki imli tamsayı ile seçmeli olarak eşleşir. Sözdizimi <function>strtol</function> işlevinin <parameter>base</parameter> bağımsız değişkeninin <code>0</code> değerli çağrısıyla aynı şekilde tanınır. (Bkz. <xref linkend="glibc-Parsing-of-Integers"/>.) (Bu sözdizimindeki tamsayıları <function>printf</function> işlevini ‘<code>#</code>’ im karakteri ve ‘<code>%x</code>’, ‘<code>%o</code>’ veya ‘<code>%d</code>’ dönüşümlerinden biri birlikte kullanarak çıktılanabilir. Bkz. <xref linkend="glibc-Integer-Conversions"/>.)
   </para>
   <para>
    Örneğin, ‘<code>10</code>’, ‘<code>0xa</code>’, ‘<code>012</code>’ dizgelerinin her biri ‘<code>%i</code>’ dönüşümü altında birer tamsayı olarak okunmalıdır. Bu dizgelerin her biri onluk tabanda <code>10</code> sayısıdır.
   </para>
   <para>
    ‘<code>%o</code>’, ‘<code>%u</code>’  ve ‘<code>%x</code>’ dönüşümleri sırayla sekizlik, onluk ve onaltılık tabandaki işaretsiz tamsayılarla eşleşir.  Sözdizimi <function>strtol</function> işlevinin <parameter>base</parameter> bağımsız değişkeninin sırasıyla <code>8</code>, <code>10</code> veya <code>16</code> değerli çağrısıyla aynı şekilde tanınır. (Bkz. <xref linkend="glibc-Parsing-of-Integers"/>.)
   </para>
   <para>
    ‘<code>%X</code>’ ve ‘<code>%x</code>’ dönüşümleri eşanlamlıdır. Her ikisi de rakam olarak büyük ya da küçük harfleri tanır.
   </para>
   <para>
    Öntanımlı tür, ‘<code>%d</code>’ ve ‘<code>%i</code>’ dönüşümleri için <type>int&nbsp;*</type>, diğer tamsayı dönüşümleri için <type>unsigned&nbsp;int&nbsp;*</type>’tir. Tamsayı türleri için aşağıdaki tür değiştiriciler kullanılabilir:
   </para>
   <variablelist>
    <varlistentry>
     <term>‘<code>hh</code>’</term>
     <listitem>
      <para>
       Bağımsız değişkenin <type>signed&nbsp;char&nbsp;*</type> veya <type>unsigned&nbsp;char&nbsp;*</type> olduğunu belirtir.
      </para>
      <para>
       Bu değiştirici &isoc;99'da tanımlanmıştır.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>‘<code>h</code>’</term>
     <listitem>
      <para>
       Bağımsız değişkenin <type>short&nbsp;int&nbsp;*</type> veya <type>unsigned&nbsp;short&nbsp;int&nbsp;*</type> olduğunu belirtir.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>‘<code>j</code>’</term>
     <listitem>
      <para>
       Bağımsız değişkenin <type>intmax_t&nbsp;*</type> veya  <type>uintmax_t&nbsp;*</type> olduğunu belirtir.
      </para>
      <para>
       Bu değiştirici &isoc;99'da tanımlanmıştır.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>‘<code>l</code>’</term>
     <listitem>
      <para>
       Bağımsız değişkenin <type>long&nbsp;int&nbsp;*</type> veya <type>unsigned&nbsp;long&nbsp;int&nbsp;*</type> olduğunu belirtir. İki ‘<code>l</code>’ karakteri ‘<code>L</code>’ değiştiricisi gibidir.
      </para>
      <para>
       ‘<code>%c</code>’ veya ‘<code>%s</code>’ belirteci ile birlikte kullanılmışsa bağımsız değişken geniş karakter veya geniş karakter dizgesi olarak ele alınır. ‘<code>l</code>’ değiştiricisinin bu kullanımı &isoc;90 1. düzeltmesinde tanımlanmıştır.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>
      <glossterm>‘<code>L</code>’</glossterm>
      <glossterm>‘<code>ll</code>’</glossterm>
      <glossterm>‘<code>q</code>’</glossterm>
     </term>
     <listitem>
      <para>
       Üçü de bağımsız değişkenin <type>long&nbsp;long&nbsp;int&nbsp;*</type> veya <type>unsigned&nbsp;long&nbsp;long&nbsp;int&nbsp;*</type> türünde olduğunu belirtir. (<type>long&nbsp;long</type> türü GNU C derleyicisi tarafından desteklenmektedir. Fazla uzun tamsayıları desteklemeyen sistemlerde bu değiştirici <type>long&nbsp;int</type> olarak değerlendirilir.)
      </para>
      <para>
       ‘<code>q</code>’ değiştiricisi 4.4 BSD’den gelmektedir. <type>long&nbsp;long&nbsp;int</type> türü kimi zaman <type>int</type> "kare" olarak da isimlendirilir.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>‘<code>t</code>’</term>
     <listitem>
      <para>
       Bağımsız değişkenin <type>ptrdiff_t&nbsp;*</type> türünde olduğunu belirtir.
      </para>
      <para>
       Bu değiştirici &isoc;99'da tanımlanmıştır.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>
      <glossterm>‘<code>z</code>’</glossterm>
     </term>
     <listitem>
      <para>
       Bağımsız değişkenin <type>size_t&nbsp;*</type> türünde olduğunu belirtir.
      </para>
      <para>
       ‘<code>z</code>’ değiştiricisi &isoc;99'da tanımlanmıştı. ‘<code>Z</code>’ ise bu tanımdan önceki bir GNU oluşumu olup yeni kodlarda kullanılmamalıdır.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    ‘<code>%e</code>’, ‘<code>%f</code>’, ‘<code>%g</code>’, ‘<code>%E</code>’, ‘<code>%F</code>’ ve ‘<code>%G</code>’ girdi dönüşümlerinin tümü birbirinin yerine kullanılabilir. Bunların tümü <function>strtod</function>  işlevindeki sözdizimi ile aynı sözdiziminde, seçimlik olarak bir kayan noktalı sayı ile eşleşir (Bkz. <xref linkend="glibc-Parsing-of-Floats"/>).
   </para>
   <para>
    Kayan noktalı sayı girdi dönüşümleri için varsayılan bağımsız değişken türü <type>float&nbsp;*</type>’dır. (Çıktı dönüşümlerinde varsayılan tür <type>double</type>’dır ve varsayılan bağımsız değişken terfileri çerçevesinde bir <type>float</type> bağımsız değişken <type>double</type> türe terfi ettirilir. Ama girdi dönüşümlerinde bu terfi uygulanmaz.) Kayan noktalı sayıların türleri için aşağıdaki tür değiştiricileri kullanılabilir:
   </para>
   <variablelist>
    <varlistentry>
     <term>‘<code>l</code>’</term>
     <listitem>
      <para>
       <type>double&nbsp;*</type> türünde bağımsız değişken belirtir.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>‘<code>L</code>’</term>
     <listitem>
      <para>
       <type>long&nbsp;double&nbsp;*</type> türünde bağımsız değişken belirtir.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    Yukarıdaki sayı çözümleme biçimlerinin tümü için isteğe bağlı ek bir ‘<code>'</code>’ imi vardır. Bu im kullanıldığında <function>scanf</function> işlevi girdi dizgesinin geçerli yerelin sayı gruplama kurallarına uygun olacağını umar (Bkz. <xref linkend="glibc-General-Numeric"/>).
   </para>
   <para>
    <code>&quot;C&quot;</code> veya <code>&quot;POSIX&quot;</code> yereli geçerli yerelse bir fark olmaz. Fakat diğer yerellerde bu dizge yerele özgü biçime uygun verilmiş olmalıdır. Aksi takdirde doğru biçimli en uzun önek işlenir.
   </para>
  </sect1>
  <sect1 xml:id="glibc-String-Input-Conversions">
   <title>Dizgeler için Girdi Dönüşümleri</title>
   <titleabbrev>Dizgelerin okunması sırasındaki dönüşümlerin ayrıntıları.</titleabbrev>
   <para>
    Bu bölümde dizge ve karakterlerin okunması için ‘<code>%s</code>’, ‘<code>%S</code>’, ‘<code>%[</code>’, ‘<code>%c</code>’ ve ‘<code>%C</code>’ girdi dönüşüm belirteçleri açıklanmıştır.
   </para>
   <para>
    Bu dönüşümlerden girdilerin alınması için iki seçenek vardır:
   </para>
   <itemizedlist>
    <listitem>
     <para>
      Girdiyi saklamak için bir tampon sağlanması gereklidir. Bu tampona ilişkin bağımsız değişken <type>char&nbsp;*</type> veya <type>wchar_t&nbsp;*</type> türünde olmalıdır (‘<code>l</code>’ değiştiricisi varsa ikincisi olmalı).
     </para>
     <warning>
      <para>
       Sağlam bir yazılım için girdi (sonlandırıcı boş karakter dahil), sağlanan tamponun boyunu aşmamalıdır. Genelde, bunu yapmanın tek yolu, en büyük alan genişliğini tampon boyunun bir eksiği olarak vermektir. <wordasword>Bir tampon oluşturuluyorsa, taşmalardan kaçınmak için uzunluğu daima en büyük alan genişliğine eşit uzunlukta seçilmelidir. </wordasword>
      </para>
     </warning>
    </listitem>
    <listitem>
     <para>
      Ne kadar büyüklükte bir tampon gerektiği <command>scanf</command> işlevine ‘<code>a</code>’ im karakteri belirtilerek sorulabilir. Bu bir GNU oluşumudur. Tampon adresi için bağımsız değişken <type>char&nbsp;**</type> türünde olmalıdır. Bkz. <xref linkend="glibc-Dynamic-String-Input"/>.
     </para>
    </listitem>
   </itemizedlist>
   <para>
    ‘<code>%c</code>’ dönüşümü en basitidir: Daima sabit sayıda karakterle eşleşir. En büyük alan genişliği kaç karakter okunacağını söyler; en büyük alan genişliği belirtilmezse <code>l</code> değeri kullanılır. Bu dönüşüm okuduğu metnin sonuna boş karakter eklemez. Ayrıca metnin içindeki boşluk karakterlerini de atlar. Özellikle sonraki <parameter>n</parameter> karakteri okur, bu kadar karakter bulamazsa başarısız olur. ‘<code>%c</code>’ dönüşümü daima sabit uzunlukta okuma yaptığından taşmadan kaçınmak için tampon yeterli uzunlukta oluşturulmalıdır.
   </para>
   <para>
    ‘<code>%lc</code>’ veya ‘<code>%C</code>’ dönüşümleri akımın, harici bayt akımından açıldığı sırada saptanan dönüşüm kullanılarak dönüştürülen geniş karakterlerin saklanmasını sağlar. Ortamdan okunan baytların sayısı <varname>MB_CUR_LEN</varname> * <parameter>n</parameter> ile sınırlıdır ve çıktı dizgesinde saklanan en çok <parameter>n</parameter> geniş karakter alınır.
   </para>
   <para>
    ‘<code>%s</code>’ dönüşümü boşluk karakterleri dışındaki karakterlerden oluşan bir dizge ile eşleşir. Dahili boşlukları atlar ve iptal eder, fakat biraz okuma yaptıktan sonra çok fazla boşluk karakterine rastlarsa durur. Okuduğu metnin sonuna boş karakter ekler.
   </para>
   <para>
    Örneğin, okunacak girdi,
   </para>
   <literallayout class="monospaced">hello, world
</literallayout>
   <para>
    ise, ‘<code>%10c</code>’ dönüşümü <literal>" hello, wo"</literal> üretir. Aynı girdi için ‘<code>%10s</code>’ dönüşümü kullanılırsa, <literal>"hello,"</literal> üretilir.
   </para>
   <warning>
    <para>
     ‘<code>%s</code>’ dönüşümü için bir alan genişliği belirtilirse, okunan karakter sayısı boşluk karakterine rastlanan yer ile sınırlıdır. Bu hemen hemen kaçınılmaz olarak geçersiz bir girdinin yazılımınızın çökmesine sebep olacağı anlamına gelir ki bu bir yazılım hatasıdır.
    </para>
   </warning>
   <para>
    ‘<code>%ls</code>’ ve ‘<code>%S</code>’ dönüşümleri ‘<code>%s</code>’ gibi işlenir, bir farkla, dış bayt dizisi, kendi karakter kodlaması ile geniş karakterlere dönüşüm için akım ile ilişkili dönüşüm kullanılır. Biçim ile birlikte genişlik veya hassasiyet belirtilirse, bunlar geniş karakterleri ölçtüğünden, akımdan kaç bayt okunacağı doğrudan saptanmaz. Fakat genişlik değeri ile <varname>MB_CUR_MAX</varname> çarpılarak üst sınır hesaplanabilir.
   </para>
   <para>
    Seçime bağlı olarak karakterlerin okunmasının belli kurallara göre olması istenirse ‘<code>%[</code>’ dönüşümü kullanılmalıdır. '<code>[</code>' ve '<code>]</code>' ayraçlarının arası düzenli ifadelerdeki sözdizimi kullanılarak yazılabilir. Özel durumlar olarak:
   </para>
   <simplelist>
    <member>
      '<code>]</code>' karakteri ifadenin ilk karakteri olarak belirtilebilir.
    </member>
    <member>
      Gömülü '<code>-</code>' karakteri (ifadenin ilk veya son karakteri olamaz) bir karakter aralığını belirtmek için kullanılabilir.
    </member>
    <member>
      '<code>^</code>' karakteri '<code>[</code>' ayracından sonra kullanılırsa, girdi karakterleri burada listelenen karakterlerin dışındakilerdir.
    </member>
   </simplelist>
   <para>
    ‘<code>%[</code>’ dönüşümü dahili boşluk karakterlerini atlamaz.
   </para>
   <para>
    Aşağıda bazı ‘<code>%[</code>’ dönüşüm örnekleri ve anlamları vardır:
   </para>
   <variablelist>
    <varlistentry>
     <term>'<code>%25[1234567890]</code>'</term>
     <listitem>
      <para>
       25 basamağa kadar bir sayı ile eşleşir.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>'<code>%25[][]</code>'</term>
     <listitem>
      <para>
       25 köşeli ayraca kadar bir dizge ile eşleşir.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>'<code>%25[^ \f\n\r\t\v]</code>'</term>
     <listitem>
      <para>
       Hiçbir boşluk karakteri içermeyen 25 karaktere kadar bir dizge ile eşleşir. Bu ‘<code>%s</code>' dönüşümünden tamamen farklıdır, çünkü girdi, boşluk karakterlerinden biri ile başlarsa bu ‘<code>%[</code>’ dönüşümü bir eşleşme hatası bildirir ama ‘<code>%s</code>' dönüşümü boşluk karakterlerini basitçe iptal eder.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>'<code>%25[a-z]</code>'</term>
     <listitem>
      <para>
       25 karaktere kadar küçük harflerle eşleşir.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    ‘<code>%c</code>' ve ‘<code>%s</code>' gibi ‘<code>%[</code>’ dönüşümü de ‘<code>l</code>' tür değiştiricisi varsa geniş karakterleri üretebilir. Yukarıda ‘<code>%ls</code>' ile ilgili bahsedilen herşey ‘<code>%l[</code>’ için de geçerlidir.
   </para>
   <important><title>Bir hatırlatma daha</title>
    <para>
     En büyük genişlik belirtilmezse ya da ‘<code>a</code>' imi kullanılmazsa ‘<code>%s</code>' ve ‘<code>%[</code>’ dönüşümleri <wordasword>tehlikelidir</wordasword>, çünkü girdi çok uzun olursa tampon taşar. Tamponun ne kadar uzunlukta olduğunun önemi yoktur, bir kullanıcı tamponu taşıracak kadar girdi yapabilir. İyi geliştirilmiş bir yazılım geçersiz bir girdiyi kapsamlı bir hata iletisi ile bildirir, çökerek değil.
    </para>
   </important>
  </sect1>

  <sect1 xml:id="glibc-Dynamic-String-Input">
   <title>Dizge Dönüşümlerinde Özdevimli Tahsis</title>
   <titleabbrev><code>malloc</code> tamponlu dizge dönüşümleri.</titleabbrev>
   <para>
    Biçimlendirilmiş girdiye yönelik bir GNU oluşumu, azami boyutu olmayan bir dizgenin güvenle okunmasını sağlar. Bu özellik kullanıldığında tampon tahsis etmeye gerek yoktur. <function>scanf</function> veriyi tutacak kadar büyüklükte tamponu kendi ayırır ve adresini verir. Bu özelliği kullanmak için im karakteri olarak ‘<code>a</code>' karakteri ‘<code>%as</code>' ya da ‘<code>%a[0-9a-z]</code>' dönüşümü ile belirtilebilir.
   </para>
   <para>
    Girdinin saklanacağı tamponun adresini tutacak gösterici bağımsız değişkeni  <type>char&nbsp;**</type> türünde olmalıdır. <function>scanf</function> işlevi bir tampon tahsis eder ve adresini bu bağımsız değişkenin gösterdiği yere kaydeder. Tampona ihtiyaç kalmadığında <function>free</function> ile tahsis edilen alan serbest bırakılmalıdır.
   </para>
   <example>
    <para>
     Bu örnekte ‘<code>%[…]</code>' dönüşüm belirtimi ‘<code>a</code>' imi ile birlikte kullanılarak <replaceable>değişken</replaceable> = <replaceable>değer</replaceable> çifti halinde bir "değişken ataması" okunmaktadır.
    </para>
    <screen>{
  char *degisken, *deger;

  if (2 &gt; scanf ("%a[a-zA-Z0-9] = %a[^\n]\n",
		 &amp;degisken, &amp;deger))
    {
      invalid_input_error ();
      return 0;
    }

  …
}
</screen>
   </example>
  </sect1>

  <sect1 xml:id="glibc-Other-Input-Conversions">
   <title>Diğer Girdi Dönüşümleri</title>
   <titleabbrev>Diğer dönüşümlerin ayrıntıları.</titleabbrev>
   <para>
    Bu bölümde çeşitli girdi dönüşümlerine yer verilmiştir.
   </para>
   <para>
    ‘<code>%p</code>' belirtimi gösterici değeri okumakta kullanılır. <function>printf</function> (<xref linkend="glibc-Other-Output-Conversions"/>) için kullanılan ‘<code>%p</code>' çıktı dönüşüm belirtimi ile aynı sözdizimini tanır; ‘<code>%x</code>' belirtiminin yaptığı gibi onaltılık sayı kabul eder. Karşılığı olan bağımsız değişken, yani göstericinin saklanacağı yerin adresi <type>void&nbsp;**</type> türünde olmalıdır.
   </para>
   <para>
    Eğer değer okunduğu yazılımın yürütülmesi sırasında özgün olarak yazılmamışsa sonuçlanan gösterici değerinin geçerli olacağı garanti edilmez.
   </para>
   <para>
    ‘<code>%n</code>' belirtimi işlevin çağrısı sırasında o ana kadar okunan karakterlerin sayısını üretir.  Belirtime kaşılık olan bağımsız değişken <type>int&nbsp;*</type> türünde olmalıdır. Bu dönüşüm belirteci, <function>printf</function> için kullanılan ‘<code>%n</code>' belirtimi ile aynı şekilde çalışır. Bkz. <xref linkend="glibc-Other-Output-Conversions"/> bölümündeki örnek.
   </para>
   <para>
    ‘<code>%n</code>' belirtimi sadece başarılı eşleşmeler veya bastırılmış atamalı dönüşümleri saptamak için bir düzenektir. ‘<code>%n</code>' belirtiminden önce bir eşleşme hatası oluşursa, <function>scanf</function>, ‘<code>%n</code>' belirtimini işlemeden döndüğünden, bağımsız değişkenine bir değer atanmaz. <function>scanf</function> işlevi çağrılmadan önce bağımsız değişken alanına <code>-1</code> değeri yerleştirilirse, çağrıdan sonra da bu değer hala duruyorsa, '<code>%n</code>' belirtimi işlenmeden önce bir hata oluşmuş demektir.
   </para>
   <para>
    Son olarak, '<code>%%</code>' belirtimi akımdaki bir '<code>%</code>' imi ile eşleşir, bu belirtim için bir bağımsız değişken kullanılmaz. Bu belirtim ile birlikte bir im, alan genişliği ya da tür değiştirici belirtilmesine izin verilmez.
   </para>
  </sect1>

  <sect1 xml:id="glibc-Formatted-Input-Functions">
   <title>Biçimli Girdi İşlevleri</title>
   <titleabbrev>İşlevlerin açıklamaları.</titleabbrev>
   <para>
    Bu bölümde biçimli girdi okumak için kullanılan işlevler açıklanmıştır. Bu işlevler &stdio.h; başlık dosyasında bildirilmiştir.
    <indexterm linkend="glibc-pg"><primary>stdio.h</primary></indexterm>
   </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-scanf"><primary>scanf</primary></indexterm>
    <indexterm xml:id="glibc-cp-scanf" linkend="glibc-cp"><primary>biçimli girdi</primary><secondary>standart girdiden okunması</secondary></indexterm>
    <csproto type="işlev" varargs="">
     <csname><type>int</type><function>scanf</function></csname>
     <csparam><ptr>const&#160;char</ptr><parameter>template</parameter></csparam>
    </csproto>
    <header>&stdio.h;</header>
    <conceptlist>
     <concept>&mtsafe; &locale;</concept>
     <concept>&asunsafe; &corrupt; &heap;</concept>
     <concept>&acunsafe; &mem; &lock; &corrupt;</concept>
    </conceptlist>
    <para>
     <code>scanf</code> işlevi <parameter>template</parameter> biçim dizgesinin denetimi altında biçimli girdiyi standart girdiden okur. İsteğe bağlı bağımsız değişkenler sonuçlanan değerlerin alındığı yerlere gösterici olmalıdır.
    </para>
    <para>
     Dönen değer normalde başarılı atamaların sayısıdır. <parameter>template</parameter> dizgesindeki boşluk ve karakterlerle eşleşmeler dahil olmak üzere herhangi bir eşleşme gerçekleştirilmeden önce bir dosya sonu algılanırsa, <varname>EOF</varname> döndürülür.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-wscanf"><primary>wscanf</primary></indexterm>
    <indexterm xml:id="glibc-cp-wscanf" linkend="glibc-cp"><primary>biçimli girdi</primary><secondary>geniş yönlenimli standart girdiden okunması</secondary></indexterm>
    <csproto type="işlev" varargs="">
     <csname><type>int</type><function>wscanf</function></csname>
     <csparam><ptr>const&#160;wchar_t</ptr><parameter>template</parameter></csparam>
    </csproto>
    <header>&stdio.h;</header>
    <conceptlist>
     <concept>&mtsafe; &locale;</concept>
     <concept>&asunsafe; &corrupt; &heap;</concept>
     <concept>&acunsafe; &mem; &lock; &corrupt;</concept>
    </conceptlist>
    <para>
     <code>wscanf</code> işlevi <parameter>template</parameter> biçim dizgesinin denetimi altında biçimli girdiyi standart girdiden okur. İsteğe bağlı bağımsız değişkenler sonuçlanan değerlerin alındığı yerlere gösterici olmalıdır.
    </para>
    <para>
     Dönen değer normalde başarılı atamaların sayısıdır. <parameter>template</parameter> dizgesindeki boşluk ve karakterlerle eşleşmeler dahil olmak üzere herhangi bir eşleşme gerçekleştirilmeden önce bir dosya sonu algılanırsa, <varname>WEOF</varname> döndürülür.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-fscanf"><primary>fscanf</primary></indexterm>
    <indexterm xml:id="glibc-cp-fscanf" linkend="glibc-cp"><primary>biçimli girdi</primary><secondary>dar yönlenimli akımdan okunması</secondary></indexterm>
    <csproto type="işlev" varargs="">
     <csname><type>int</type><function>fscanf</function></csname>
     <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
     <csparam><ptr>const&#160;char</ptr><parameter>template</parameter></csparam>
    </csproto>
    <header>&stdio.h;</header>
    <conceptlist>
     <concept>&mtsafe; &locale;</concept>
     <concept>&asunsafe; &corrupt; &heap;</concept>
     <concept>&acunsafe; &mem; &lock; &corrupt;</concept>
    </conceptlist>
    <para>
     Bu işlev, girdinin standart girdi yerine <parameter>stream</parameter> akımından okunması dışında <function>scanf</function> gibidir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-fwscanf"><primary>fwscanf</primary></indexterm>
    <indexterm xml:id="glibc-cp-fwscanf" linkend="glibc-cp"><primary>biçimli girdi</primary><secondary>geniş yönlenimli akımdan okunması</secondary></indexterm>
    <csproto type="işlev" varargs="">
     <csname><type>int</type><function>fwscanf</function></csname>
     <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
     <csparam><ptr>const&#160;wchar_t</ptr><parameter>template</parameter></csparam>
    </csproto>
    <header>&stdio.h;</header>
    <header>&wchar.h;</header>
    <conceptlist>
     <concept>&mtsafe; &locale;</concept>
     <concept>&asunsafe; &corrupt; &heap;</concept>
     <concept>&acunsafe; &mem; &lock; &corrupt;</concept>
    </conceptlist>
    <para>
     Bu işlev, girdinin standart girdi yerine <parameter>stream</parameter> akımından okunması dışında <function>wscanf</function> gibidir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-sscanf"><primary>sscanf</primary></indexterm>
    <indexterm xml:id="glibc-cp-sscanf" linkend="glibc-cp"><primary>biçimli girdi</primary><secondary>dizgeden okunması</secondary></indexterm>
    <csproto type="işlev" varargs="">
     <csname><type>int</type><function>sscanf</function></csname>
     <csparam><ptr>const&#160;char</ptr><parameter>s</parameter></csparam>
     <csparam><ptr>const&#160;char</ptr><parameter>template</parameter></csparam>
    </csproto>
    <header>&stdio.h;</header>
    <conceptlist>
     <concept>&mtsafe; &locale;</concept>
     <concept>&asunsafe; &heap;</concept>
     <concept>&acunsafe; &mem;</concept>
    </conceptlist>
    <para>
     Bu işlev, girdinin standart girdi yerine boş karakter sonlandırmalı <parameter>s</parameter> dizgesinden alınması dışında <function>scanf</function> gibidir. Dizge sonunun aşılması bir dosya sonu durumu olarak ele alınır.
    </para>
    <para>
     Bu işlevin davranışı, birbirini kapsayan nesneler arasında kopyalama yapılırsa, örneğin, ‘<code>%s</code>’, ‘<code>%S</code>’ veya ‘<code>%[</code>’ dönüşümünün denetimi altında okunacak dizgeyi alacak bağımsız değişken olarak <parameter>s</parameter> dizgesi verilmişse, tanımsızdır.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-swscanf"><primary>swscanf</primary></indexterm>
    <indexterm xml:id="glibc-cp-swscanf" linkend="glibc-cp"><primary>biçimli girdi</primary><secondary>geniş dizgeden okunması</secondary></indexterm>
    <csproto type="işlev" varargs="">
     <csname><type>int</type><function>swscanf</function></csname>
     <csparam><ptr>const&#160;wchar_t</ptr><parameter>ws</parameter></csparam>
     <csparam><ptr>const&#160;wchar_t</ptr><parameter>template</parameter></csparam>
    </csproto>
    <header>&wchar.h;</header>
    <conceptlist>
     <concept>&mtsafe; &locale;</concept>
     <concept>&asunsafe; &heap;</concept>
     <concept>&acunsafe; &mem;</concept>
    </conceptlist>
    <para>
     Bu işlev, girdinin standart girdi yerine boş karakter sonlandırmalı <parameter>ws</parameter> dizgesinden alınması dışında <function>wscanf</function> gibidir. Dizge sonunun aşılması bir dosya sonu durumu olarak ele alınır.
    </para>
    <para>
     Bu işlevin davranışı, birbirini kapsayan nesneler arasında kopyalama yapılırsa, örneğin, ‘<code>%s</code>’, ‘<code>%S</code>’ veya ‘<code>%[</code>’ dönüşümünün denetimi altında okunacak dizgeyi alacak bağımsız değişken olarak <parameter>ws</parameter> dizgesi verilmişse, tanımsızdır.
    </para>
   </csynopsis>
  </sect1>

  <sect1 xml:id="glibc-Variable-Arguments-Input">
   <title>Değişken Bağımsız Değişkenli Girdi İşlevleri</title>
   <titleabbrev><code>vscanf</code> ve arkadaşları.</titleabbrev>
   <para>
    <function>vscanf</function> işlevi ve arkadaşları, yerleşik biçimli çıktı işlevleriyle aynı dahili oluşumları kullanan değişkin <function>scanf</function> benzeri işlevleri yazılımcının tanımlayabilmesi için sağlanmıştır. Bu işlevler <function>vprintf</function> ailesi biçimli çıktı işlevlerini andırır. Nasıl kullanıldıkları ile ilgili önemli bilgiler <xref linkend="glibc-Variable-Arguments-Output"/> bölümünde bulunabilir.
   </para>
   <warning><title>Taşınabilirlik Bilgisi</title>
    <para>
     Bu bölümdeki işlevler &isoc;99'da tanımlanmıştı ve daha önce GNU oluşumları olarak vardı.
    </para>
   </warning>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-vscanf"><primary>vscanf</primary></indexterm>
    <indexterm xml:id="glibc-cp-vscanf" linkend="glibc-cp"><primary>biçimli girdi</primary><secondary>değişkin işlevle</secondary><tertiary>standart girdiden okunması</tertiary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>vscanf</function></csname>
     <csparam><ptr>const&#160;char</ptr><parameter>template</parameter></csparam>
     <csparam><type>va_list</type><parameter>ap</parameter></csparam>
    </csproto>
    <header>&stdio.h;</header>
    <conceptlist>
     <concept>&mtsafe; &locale;</concept>
     <concept>&asunsafe; &corrupt; &heap;</concept>
     <concept>&acunsafe; &mem; &lock; &corrupt;</concept>
    </conceptlist>
    <para>
     Bu işlev değişken sayıdaki bağımsız değişkenlerini doğrudan almak yerine <type>va_list</type> türündeki <parameter>ap</parameter> bağımsız değişken listesi göstericisinden alması dışında <function>scanf</function> ile aynıdır (Bkz. <xref linkend="glibc-Variadic-Functions"/>).
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-vwscanf"><primary>vwscanf</primary></indexterm>
    <indexterm xml:id="glibc-cp-vwscanf" linkend="glibc-cp"><primary>biçimli girdi</primary><secondary>değişkin işlevle</secondary><tertiary>geniş yönlenimli standart girdiden okunması</tertiary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>vwscanf</function></csname>
     <csparam><ptr>const&#160;wchar_t</ptr><parameter>template</parameter></csparam>
     <csparam><type>va_list</type><parameter>ap</parameter></csparam>
    </csproto>
    <header>&stdarg.h;</header>
    <header>&wchar.h;</header>
    <conceptlist>
     <concept>&mtsafe; &locale;</concept>
     <concept>&asunsafe; &corrupt; &heap;</concept>
     <concept>&acunsafe; &mem; &lock; &corrupt;</concept>
    </conceptlist>
    <para>
     Bu işlev değişken sayıdaki bağımsız değişkenlerini doğrudan almak yerine <type>va_list</type> türündeki <parameter>ap</parameter> bağımsız değişken listesi göstericisinden alması dışında <function>wscanf</function> ile aynıdır (Bkz. <xref linkend="glibc-Variadic-Functions"/>).
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-vfscanf"><primary>vfscanf</primary></indexterm>
    <indexterm xml:id="glibc-cp-vfscanf" linkend="glibc-cp"><primary>biçimli girdi</primary><secondary>değişkin işlevle</secondary><tertiary>dar yönlenimli akımdan okunması</tertiary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>vfscanf</function></csname>
     <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
     <csparam><ptr>const&#160;char</ptr><parameter>template</parameter></csparam>
     <csparam><type>va_list</type><parameter>ap</parameter></csparam>
    </csproto>
    <header>&stdarg.h;</header>
    <header>&stdio.h;</header>
    <conceptlist>
     <concept>&mtsafe; &locale;</concept>
     <concept>&asunsafe; &corrupt; &heap;</concept>
     <concept>&acunsafe; &mem; &lock; &corrupt;</concept>
    </conceptlist>
    <para>
     Bu işlev değişken sayıdaki bağımsız değişkenlerini doğrudan almak yerine <type>va_list</type> türündeki <parameter>ap</parameter> bağımsız değişken listesi göstericisinden alması dışında <function>fscanf</function> ile aynıdır (Bkz. <xref linkend="glibc-Variadic-Functions"/>).
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-vfwscanf"><primary>vfwscanf</primary></indexterm>
    <indexterm xml:id="glibc-cp-vfwscanf" linkend="glibc-cp"><primary>biçimli girdi</primary><secondary>değişkin işlevle</secondary><tertiary>geniş yönlenimli akımdan okunması</tertiary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>vfwscanf</function></csname>
     <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
     <csparam><ptr>const&#160;wchar_t</ptr><parameter>template</parameter></csparam>
     <csparam><type>va_list</type><parameter>ap</parameter></csparam>
    </csproto>
    <header>&stdarg.h;</header>
    <header>&stdio.h;</header>
    <header>&wchar.h;</header>
    <conceptlist>
     <concept>&mtsafe; &locale;</concept>
     <concept>&asunsafe; &corrupt; &heap;</concept>
     <concept>&acunsafe; &mem; &lock; &corrupt;</concept>
    </conceptlist>
    <para>
     Bu işlev değişken sayıdaki bağımsız değişkenlerini doğrudan almak yerine <type>va_list</type> türündeki <parameter>ap</parameter> bağımsız değişken listesi göstericisinden alması dışında <function>fwscanf</function> ile aynıdır (Bkz. <xref linkend="glibc-Variadic-Functions"/>).
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-vsscanf"><primary>vsscanf</primary></indexterm>
    <indexterm xml:id="glibc-cp-vsscanf" linkend="glibc-cp"><primary>biçimli girdi</primary><secondary>değişkin işlevle</secondary><tertiary>dizgeden okunması</tertiary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>vsscanf</function></csname>
     <csparam><ptr>const&#160;char</ptr><parameter>s</parameter></csparam>
     <csparam><ptr>const&#160;char</ptr><parameter>template</parameter></csparam>
     <csparam><type>va_list</type><parameter>ap</parameter></csparam>
    </csproto>
    <header>&stdarg.h;</header>
    <header>&stdio.h;</header>
    <conceptlist>
     <concept>&mtsafe; &locale;</concept>
     <concept>&asunsafe; &heap;</concept>
     <concept>&acunsafe; &mem;</concept>
    </conceptlist>
    <para>
     Bu işlev değişken sayıdaki bağımsız değişkenlerini doğrudan almak yerine <type>va_list</type> türündeki <parameter>ap</parameter> bağımsız değişken listesi göstericisinden alması dışında <function>sscanf</function> ile aynıdır (Bkz. <xref linkend="glibc-Variadic-Functions"/>).
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-vswscanf"><primary>vswscanf</primary></indexterm>
    <indexterm xml:id="glibc-cp-vswscanf" linkend="glibc-cp"><primary>biçimli girdi</primary><secondary>değişkin işlevle</secondary><tertiary>geniş dizgeden okunması</tertiary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>vswscanf</function></csname>
     <csparam><ptr>const&#160;wchar_t</ptr><parameter>ws</parameter></csparam>
     <csparam><ptr>const&#160;wchar_t</ptr><parameter>template</parameter></csparam>
     <csparam><type>va_list</type><parameter>ap</parameter></csparam>
    </csproto>
    <header>&stdarg.h;</header>
    <header>&wchar.h;</header>
    <conceptlist>
     <concept>&mtsafe; &locale;</concept>
     <concept>&asunsafe; &heap;</concept>
     <concept>&acunsafe; &mem;</concept>
    </conceptlist>
    <para>
     Bu işlev değişken sayıdaki bağımsız değişkenlerini doğrudan almak yerine <type>va_list</type> türündeki <parameter>ap</parameter> bağımsız değişken listesi göstericisinden alması dışında <function>swscanf</function> ile aynıdır (Bkz. <xref linkend="glibc-Variadic-Functions"/>).
    </para>
   </csynopsis>
   <para>
    GNU C'de <function>scanf</function> tarzı biçim dizgesi kullanan bir işlevi derleyiciye bildirmek için özel bir yapı vardır. Bu yapı kullanıldığında işlevin her çağrısı için kullanılan bağımsız değişkenlerin türleri ve sayısı denetlenir ve biçim dizgesiyle eşleşmeyenler için uyarır. İşlev özniteliklerinin bildirilmesi ile ilgili ayrıntılı bilgi edinmek için GCC kılavuzunun <link xl:href="https://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html#Function-Attributes">Declaring Attributes of Functions</link> bölümüne bakılabilir.
   </para>
  </sect1>
 </chapter>

 <chapter xml:id="glibc-EOF-and-Errors">
  <title>Dosya Sonu ve Hatalar</title>
  <titleabbrev>Bir G/Ç hatası oluşursa nasıl belirtilir.</titleabbrev>
  <para>
   <indexterm linkend="glibc-cp"><primary>akımlar</primary><secondary>dosya sonu</secondary></indexterm>
   Bu kısımda açıklanan işlevlerin birçoğu işlemin başarısızlıkla tamamlandığını belirten <varname>EOF</varname> makrosunun değerini döndürür. <varname>EOF</varname> hem dosya sonunu hem de birtakım hataların olduğunu belirttiğinden, dosya sonu için <function>feof</function>, hatalar için de <function>ferror</function> işlevleri sağlanmıştır. Bunları kullanarak dosya sonu ile ilgili hatalar ayrı ayrı elde edilebilir. Bu işlevler akım nesnesinin dahili durumunun bir parçası olan durum belirteçlerine bakar, bu belirteçler akım üzerindeki önceki G/Ç işlemi tarafından uygun koşul saptanmışsa etkin olur.
  </para>
  <csynopsis>
   <indexterm xml:id="glibc-vr-EOF" linkend="glibc-vr"><primary>EOF</primary></indexterm>
   <csproto type="makro">
    <csname><function>EOF</function></csname>
   </csproto>
    <header>&stdio.h;</header>
   <para>
    Bu makro dosya sonu veya bazı hata durumlarını gösteren ve dar yönlenimli akım işlevleri tarafından döndürülen bir tamsayı değerdir. Diğer kütüphanelerde değeri herhangi bir negatif değer olabilirse de &glibc;nde değeri <code>-1</code>’dir.
   </para>
  </csynopsis>
  <csynopsis>
   <csproto type="makro">
    <csname><function>WEOF</function></csname>
   </csproto>
    <header>&wchar.h;</header>
   <para>
    Bu makro dosya sonu veya bazı hata durumlarını gösteren ve geniş yönlenimli akım işlevleri tarafından döndürülen bir tamsayı değerdir. Diğer kütüphanelerde değeri herhangi bir negatif değer olabilirse de &glibc;nde değeri <code>-1</code>’dir.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-feof"><primary>feof</primary></indexterm>
   <indexterm xml:id="glibc-cp-feof" linkend="glibc-cp"><primary>akımlar</primary><secondary>dosya sonunun algılanması</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>feof</function></csname>
    <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
   </csproto>
   <header>&stdio.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acunsafe; &lock;</concept>
   </conceptlist>
   <para>
    <code>feof</code> işlevi, <parameter>stream</parameter> akımında sadece ve sadece dosya sonu belirteci etkin ise sıfırdan farklı bir değerle döner.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-feof_unlocked"><primary>feof_unlocked</primary></indexterm>
   <indexterm xml:id="glibc-cp-feof_unlocked" linkend="glibc-cp"><primary>akımlar</primary><secondary>dosya sonunun algılanması (kilitsiz)</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>feof_unlocked</function></csname>
    <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
   </csproto>
   <header>&stdio.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <code>feof_unlocked</code> işlevi akımı dolaylı olarak kilitlememesi dışında <function>feof</function> işlevi ile aynıdır.
   </para>
   <para>
    Bu işlev GNU oluşumudur.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-ferror"><primary>ferror</primary></indexterm>
   <indexterm xml:id="glibc-cp-ferror" linkend="glibc-cp"><primary>akımlar</primary><secondary>hatanın algılanması</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>ferror</function></csname>
    <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
   </csproto>
   <header>&stdio.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acunsafe; &lock;</concept>
   </conceptlist>
   <para>
    <code>ferror</code> işlevi, <parameter>stream</parameter> akımında sadece ve sadece hata belirteci etkin ise sıfırdan farklı bir değerle döner. Hata belirteci, akımda bir önceki işlem sırasında bir hatanın oluştuğunu gösterir.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-ferror_unlocked"><primary>ferror_unlocked</primary></indexterm>
   <indexterm xml:id="glibc-cp-ferror_unlocked" linkend="glibc-cp"><primary>akımlar</primary><secondary>hatanın algılanması (kilitsiz)</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>ferror_unlocked</function></csname>
    <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
   </csproto>
   <header>&stdio.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <code>ferror_unlocked</code> işlevi akımı dolaylı olarak kilitlememesi dışında <function>ferror</function> işlevi ile aynıdır.
   </para>
   <para>
    Bu işlev GNU oluşumudur.
   </para>
  </csynopsis>
  <para>
   Akım ile ilişkili hata belirtecine ek olarak, akımlar üzerinde işlem yapan işlevler, dosya tanıtıcılar üzerinde düşük seviyeli işlemler yapan eşdeğerleri ile aynı şekilde hata durumunu <varname>errno</varname> değişkenine atar. Örneğin, <function>fputc</function>, <function>printf</function> ve <function>fflush</function> gibi bir akıma çıktılama yapan tüm işlevler temelde <function>write</function> üzerinden gerçeklendiklerinden bunlar için <function>write</function> işlevi ile ilgili <varname>errno</varname> hataları anlamlı olmaktadır. Dosya tanıtıcı seviyesi G/Ç işlemleri ile ilgili daha fazla bilgi edinmek için bkz. <xref linkend="glibc-Low-Level-I-O"/>.
  </para>
 </chapter>

 <chapter xml:id="glibc-Error-Recovery">
  <title>Hatalardan Kurtulma</title>
  <titleabbrev>Hatalardan kurtulmak için yapılacaklar.</titleabbrev>
  <para>
   Bir hata ya da dosya sonu durumu <function>clearerr</function> işlevi ile doğrudan temizlenebilir.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-clearerr"><primary>clearerr</primary></indexterm>
   <indexterm xml:id="glibc-cp-clearerr" linkend="glibc-cp"><primary>akımlar</primary><secondary>dosya sonu ve hata durumunun sıfırlanması</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>void</type><function>clearerr</function></csname>
    <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
   </csproto>
   <header>&stdio.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acunsafe; &lock;</concept>
   </conceptlist>
   <para>
    Bu işlev <parameter>stream</parameter> akımı ile ilgili dosya sonu ve hata durum belirteçlerini temizler.
   </para>
   <para>
    Ayrıca dosya konumlama işlevleri de (<xref linkend="glibc-File-Positioning"/>) akım ile ilgili dosya sonu belirtecini temizler.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-clearerr_unlocked"><primary>clearerr_unlocked</primary></indexterm>
   <indexterm xml:id="glibc-cp-clearerr_unlocked" linkend="glibc-cp"><primary>akımlar</primary><secondary>dosya sonu ve hata durumunun sıfırlanması</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>void</type><function>clearerr_unlocked</function></csname>
    <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
   </csproto>
   <header>&stdio.h;</header>
   <conceptlist>
    <concept>&mtsafe; &race;<code linkend="glibc-safety-identifier">:stream</code></concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <code>clearerr_unlocked</code> işlevi akımı dolaylı olarak kilitlememesi dışında <function>clearerr</function> işlevi ile aynıdır.
   </para>
   <para>
    Bu işlev GNU oluşumudur.
   </para>
  </csynopsis>
  <note>
   <para>
    Hata durumu belirtecinin temizlenmesi ve başarısız akım işlevinin yinelenmesi <emphasis>doğru olmaz</emphasis>. Başarısız bir yazma işleminden sonra, tamponda olup da dosyaya gönderilmesi gereken verinin bir kısmı iptal olabilir. Bir kere yinelense bile verinin kaybına ya da tekrarına sebep olabilir.
   </para>
  </note>
  <para>
   Başarısız bir okuma ise ikinci deneme için dosya göstericisini ilgisiz bir konumda bırakabilir. Her iki durumda da işlemi yinelemeden önce bilinen son konuma gitmek gerekir.
  </para>
  <para>
   Hataların çoğu kurtarılabilir değildir; ikinci bir deneme daima aynı şekilde başarısız olur. En iyisi karmaşık hata kurtarma kodları yazmak yerine, hatayı kullanıcıya raporlayarak işlemi kesmektir.
  </para>
  <para>
   Önemli bir hata durumu da <varname>EINTR</varname>’dir (<xref linkend="glibc-Interrupted-Primitives"/>). Çoğu akım G/Ç gerçeklemesi bu hatayı az çok sakıncalı sıradan bir hata olarak ele alır. Tüm sinyallerin <varname>SA_RESTART</varname> bayrağıyla kurulması bu rahatsız edici durumdan kaçınılmasını sağlayabilir.
  </para>
  <para>
   Benzer sebeplerle, bir akımın dosya tanıtıcısının engellenmeyen G/Ç olarak ayarlanması genellikle önerilmez.
  </para>
 </chapter>

 <chapter xml:id="glibc-Binary-Streams">
  <title>İkil ve Metin Akımları</title>
  <titleabbrev>Bazı sistemlerde metin dosyaları ile ikil dosyalar farklı ele alınır.</titleabbrev>
  <para>
   GNU sistemleri ve diğer POSIX uyumlu işletim sistemleri tüm dosyaları karakterlerin tektip dizisi olarak tanır. Diğer yandan, başka bazı sistemler metin içeren dosyalarla ikil veri içeren dosyalar arasında ayrım yapar; &isoc; giriş ve çıkış oluşumları da bu ayrıma göredir. Bu kısımda böyle sistemler arasında taşınabilir yazılımların nasıl geliştirileceğinden bahsedilmiştir.
  </para>
  <para>
   <indexterm linkend="glibc-cp"><primary>akımlar</primary><secondary>metin</secondary></indexterm>
   <indexterm linkend="glibc-cp"><primary>akımlar</primary><secondary>ikil</secondary></indexterm>
   Bir akım açılırken ya <wordasword>metin akımı</wordasword> ya da <wordasword>ikil akım</wordasword> olarak belirtilebilir. Bir ikil akımı, <function>fopen</function> işlevinin <parameter>opentype</parameter> bağımsız değişkenine ‘<code>b</code>’ değiştiricisini belirtilerek açılabilir; bkz. <xref linkend="glibc-Opening-Streams"/>. Bu seçenek olmaksızın dosya metin akımı olarak açılır.
  </para>
  <para>
   Metin akımları ile ikil akımlar çeşitli bakımlardan farklıdır:
  </para>
  <itemizedlist>
   <listitem>
    <para>
     <indexterm linkend="glibc-cp"><primary>satır</primary><secondary>metin dosyasında</secondary></indexterm>
     Veri, bir ikil akımdan basitçe karakterlerin uzun bir dizisi olarak, bir metin akımından ise satır sonu  (<code>'\n'</code>) karakterleri ile sonlandırılmış satırlara bölünerek okunur. Bazı sistemler, 254 karakterden (satır sonu karakteri dahil) uzun satırlar içeren metin akımlarında başarısız olabilir.
    </para>
   </listitem>
   <listitem>
    <para>
     Bazı sistemlerde, metin dosyaları sadece yazdırılabilen karakterleri, yatay sekme karekterlerini ve satır sonu karakterlerini içerebilir ve diğer karakterler desteklenmeyebilir. Buna karşın, ikil akımlar her türlü karakteri içerebilir.
    </para>
   </listitem>
   <listitem>
    <para>
     Bir metin akımı içinde bir satır sonu karakteri ile öncelenmiş boşluk karakterleri, dosya tekrar okunduğunda görünmeyebilir.
    </para>
   </listitem>
   <listitem>
    <para>
     Daha genel olarak, bir metin akımından okunan veya metin akımına yazılan karakterler arasında birebir eşleşme gerekli olmayabilir.
    </para>
   </listitem>
  </itemizedlist>
  <para>
   Bir ikil akım, bir metin akımına göre daha tahmin edilebilir ve daha yetenekli olduğuna göre metin akımlarının ne amaçla sunulduğu düşünülebilir. Niçin basitçe sadece ikil akımlar kullanılmaz? Yanıtı, bu işletim sistemlerinde, metin ve ikil akımların farklı dosya biçimlerini kullanması ve diğer metin yönlenimli uygulamalarla birlikte çalışırken sıradan bir metin dosyasının okumanın ve ona yazmanın tek yolunun bir metin akımı kullanmak olmasıdır.
  </para>
  <para>
   &glibc;nde ve tüm POSIX sistemlerinde, ikil akımlar ile metin akımları arasında bir fark yoktur. Bir akımı açtığınızda ikil bir akım isteyip istemediğinize bakılmaksızın aynı çeşit akım alırsınız. Bu akım, metin akımlarının sahip olduğu bazı kısıtlamalar olmaksızın her türlü dosya içeriği ile kullanılabilir.
  </para>
 </chapter>
 <chapter xml:id="glibc-File-Positioning">
  <title>Dosyalarda Konumlama</title>
  <titleabbrev>Rastgele erişimli akımlar.</titleabbrev>
  <para>
   <indexterm linkend="glibc-cp"><primary>akımlar</primary><secondary>dosyalarda konumlama</secondary></indexterm>
   <indexterm linkend="glibc-cp"><primary>akımlar</primary><secondary>konumlama</secondary></indexterm>
   Bir akım üzerinde <wordasword>dosya konumlama</wordasword>, akımın dosyanın neresinde okuma veya yazma yaptığı ile ilgilidir. Akım üzerinde G/Ç, dosya üzerinde dosya konumunu ilerletir. GNU sisteminde, dosya konumu bir tamsayı ile ifade edilir ve dosyanın başlangıcından itibaren bayt sayısını gösterir. Bkz.  <xref linkend="glibc-File-Position"/>.
  </para>
  <para>
   Sıradan bir disk dosyasında yapılan G/Ç işlemlerinde, okuma veya yazma amacıyla dosya konumu gerektiği gibi değiştirilebilir. Diğer bazı dosya çeşitlerinde de buna izin verilebilmektedir. Dosya konumu değiştirmeyi destekleyen dosyalara kimi zaman <wordasword>rastgele erişimli dosyalar</wordasword> da denmektedir.
  </para>
  <para>
   <indexterm linkend="glibc-pg"><primary>stdio.h</primary></indexterm>
   Bu bölümdeki işlevler, bir akım ile ilişkilendirilmiş dosya konumlayıcıyı değiştirmek ya da durumunu saptamak amacıyla kullanılabilir. Bu sayfadaki herşey &stdio.h; başlık dosyasında bildirilmiştir.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-ftell"><primary>ftell</primary></indexterm>
   <indexterm xml:id="glibc-cp-ftell" linkend="glibc-cp"><primary>akımlar</primary><secondary>dosya konumu</secondary><tertiary>değiştirilmesi</tertiary></indexterm>
   <csproto type="işlev">
    <csname><type>long&nbsp;int</type><function>ftell</function></csname>
    <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
   </csproto>
   <header>&stdio.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&asunsafe; &corrupt;</concept>
    <concept>&acunsafe; &lock; &corrupt;</concept>
   </conceptlist>
   <para>
    Bu işlev <parameter>stream</parameter> akımının geçerli dosya konumu ile döner.
   </para>
   <para>
    Bu işlev, akımda dosya konumlamayı desteklemiyorsa veya dosya konumu   <type>long&nbsp;int</type> türüyle ifade edilemiyorsa ve olası diğer sebeplerle başarısız olabilir. Bir başarısızlık durumunda <code>-1</code> değeri döner.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-ftello"><primary>ftello</primary></indexterm>
   <indexterm xml:id="glibc-cp-ftello" linkend="glibc-cp"><primary>akımlar</primary><secondary>dosya konumu</secondary><tertiary>değiştirilmesi</tertiary></indexterm>
   <csproto type="işlev">
    <csname><type>off_t</type><function>ftello</function></csname>
    <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
   </csproto>
   <header>&stdio.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&asunsafe; &corrupt;</concept>
    <concept>&acunsafe; &lock; &corrupt;</concept>
   </conceptlist>
   <para>
    <code>ftello</code> işlevi <type>off_t</type> türünde bir dosya konumu ile dönmesi dışında <function>ftell</function> işlevi gibidir. POSIX belirtimi tarafından kullanılan <type>long&nbsp;int</type> türünün aksine, bu veri türünü destekleyen sistemler, tüm dosya konumlarını açıklamakta <type>off_t</type> türünü kullanır. Bu ikisinin aynı boyutta olması gerekli değildir.  Bu nedenle, gerçekleme, tepede POSIX uyumlu düşük seviyeli bir G/Ç gerçeklemesi olarak yazılmışsa <function>ftell</function> kullanımı bazı sorunlara yolaçabilir, bu durumda mümkün olduğunca <code>ftello</code> kullanımı tercih edilir.
   </para>
   <para>
    Bu işlev başarısız olduğunda <code>(off_t) -1</code> ile döner. Bu, dosya konumlama desteği olmamasından ya da bir dahili hatanın sonucu olabilir. Aksi takdirde, dönüş değeri geçerli dosya konumudur.
   </para>
   <para>
    Bu işlev Tek Unix Belirtiminin 2. sürümünde tanımlı bir genişletmedir.
   </para>
   <para>
    Kaynaklar, 32 bitlik sistemlerde <code>_FILE_OFFSET_BITS == 64</code> ile derlendiğinde bu işlev <function>ftello64</function> olarak davranır. Yani büyük dosya desteği arayüzü saydam olarak eski arayüzle yer değiştirir.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-ftello64"><primary>ftello64</primary></indexterm>
   <csproto type="işlev">
    <csname><type>off64_t</type><function>ftello64</function></csname>
    <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
   </csproto>
   <header>&stdio.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&asunsafe; &corrupt;</concept>
    <concept>&acunsafe; &lock; &corrupt;</concept>
   </conceptlist>
   <para>
    Bu işlev dönüş değerinin <type>off64_t</type> türünde olması dışında
    <function>ftello</function> gibidir.  Bu ayrıca, <parameter>stream</parameter> akımının, <code>2</code><superscript>31</superscript> baytlık sınırın üzerindeki dosya konumlarına konumlayan dosya işlemlerinin  başarılı olabildiği <function>fopen64</function>, <function>freopen64</function> veya <function>tmpfile64</function> işlevlerinin kullanılarak açılmasını da gerektirir.
   </para>
   <para>
    Kaynaklar, 32 bitlik sistemlerde <code>_FILE_OFFSET_BITS == 64</code> ile derlendiğinde bu işlev <function>ftello</function> ismiyle de kullanılabilir. Yani büyük dosya desteği arayüzü saydam olarak eski arayüzle yer değiştirir.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-fseek"><primary>fseek</primary></indexterm>
   <indexterm xml:id="glibc-cp-fseek" linkend="glibc-cp"><primary>akımlar</primary><secondary>dosya konumu</secondary><tertiary>değiştirilmesi</tertiary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>fseek</function></csname>
    <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
    <csparam><type>long&nbsp;int</type><parameter>offset</parameter></csparam>
    <csparam><type>int</type><parameter>whence</parameter></csparam>
   </csproto>
   <header>&stdio.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&asunsafe; &corrupt;</concept>
    <concept>&acunsafe; &lock; &corrupt;</concept>
   </conceptlist>
   <para>
    <code>fseek</code> işlevi <parameter>stream</parameter> akımının dosya konumunu değiştirmekte kullanılır. <parameter>whence</parameter> bağımsız değişkeninin değeri,<parameter>offset</parameter> değerinin dosyanın başlangıcına mı, geçerli dosya konumuna göre mi yoksa dosyanın sonuna göre mi konumlanacağına bağlı olarak sırasıyla <varname>SEEK_SET</varname>, <varname>SEEK_CUR</varname> ya da <varname>SEEK_END</varname> sabitlerinden biri olmalıdır.
   </para>
   <para>
    Eğer işlem başarılı olursa dönüş değeri sıfırdır. Sıfırdan farklı bir dönüş değeri işlemin başarısız olduğunu gösterir. Bir başarılı çağrı ayrıca <parameter>stream</parameter> akımının dosya sonu belirtecini de temizler ve <function>ungetc</function> kullanımıyla "geri itilen" karakterleri iptal eder.
   </para>
   <para>
    <code>fseek</code> işlevi dosya konumunu değiştirmeden önce tamponlanmış çıktıyı ya boşaltır ya da aksine daha sonra dosyadaki yerine yazılmak üzere hatırlar.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-fseeko"><primary>fseeko</primary></indexterm>
   <indexterm xml:id="glibc-cp-fseeko" linkend="glibc-cp"><primary>akımlar</primary><secondary>dosya konumu</secondary><tertiary>değiştirilmesi</tertiary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>fseeko</function></csname>
    <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
    <csparam><type>off_t</type><parameter>offset</parameter></csparam>
    <csparam><type>int</type><parameter>whence</parameter></csparam>
   </csproto>
   <header>&stdio.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&asunsafe; &corrupt;</concept>
    <concept>&acunsafe; &lock; &corrupt;</concept>
   </conceptlist>
   <para>
    Bu işlev <function>fseek</function> işlevi gibidir, ancak POSIX türleri kullanılan sistemlerde <function>fseek</function> kullanımından kaynaklanan bir sorunu düzeltir. Konum için <type>long&nbsp;int</type> türünde bir değerin kullanılması POSIX ile uyumlu değildir. <function>fseeko</function> işlevi <varname>konum</varname> bağımsız değişkeni için doğru tür olan <type>off_t</type> türünü kullanır.
   </para>
   <para>
    Bu sebeple, işlevselliği ilgili tanımlamaya daha yakın olduğundan (tamamen farklı bile olsa) mümkünse <function>ftello</function> kullanımı tercih edilmelidir.
   </para>
   <para>
    İşlevsellik ve dönüş değeri <function>fseek</function> ile aynıdır.
   </para>
   <para>
    Bu işlev Tek Unix Belirtiminin 2. sürümünde tanımlı bir genişletmedir.
   </para>
   <para>
    Kaynaklar, 32 bitlik sistemlerde <code>_FILE_OFFSET_BITS == 64</code> ile derlendiğinde bu işlev <function>fseeko64</function> olarak davranır. Yani büyük dosya desteği arayüzü saydam olarak eski arayüzle yer değiştirir.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-fseeko64"><primary>fseeko64</primary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>fseeko64</function></csname>
    <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
    <csparam><type>off64_t</type><parameter>offset</parameter></csparam>
    <csparam><type>int</type><parameter>whence</parameter></csparam>
   </csproto>
   <header>&stdio.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&asunsafe; &corrupt;</concept>
    <concept>&acunsafe; &lock; &corrupt;</concept>
   </conceptlist>
   <para>
    Bu işlev <parameter>offset</parameter> bağımsız değişkeninin <type>off64_t</type> türünde olması dışında <function>fseeko</function> gibidir.  Bu ayrıca, <parameter>stream</parameter> akımının, <code>2</code><superscript>31</superscript> baytlık sınırın üzerindeki dosya konumlarına konumlayan dosya işlemlerinin  başarılı olabildiği <function>fopen64</function>, <function>freopen64</function> veya <function>tmpfile64</function> işlevlerinin kullanılarak açılmasını da gerektirir.
   </para>
   <para>
    Kaynaklar, 32 bitlik sistemlerde <code>_FILE_OFFSET_BITS == 64</code> ile derlendiğinde bu işlev <function>fseeko</function> ismiyle de kullanılabilir. Yani büyük dosya desteği arayüzü saydam olarak eski arayüzle yer değiştirir.
   </para>
  </csynopsis>
  <note><title>Uyumluluk Bilgisi:</title>
   <para>
    POSIX dışı sistemlerde <function>ftell</function>, <function>ftello</function>, <function>fseek</function> ve <function>fseeko</function> işlevleri sadece ikil akımlarla düzgün çalışabilir. Bkz. <xref linkend="glibc-Binary-Streams"/>.
   </para>
  </note>
  <para>
   Aşağıdaki simgesel sabitler <function>fseek</function> işlevinin <parameter>whence</parameter> bağımsız değişkeninde kullanmak için tanımlanmışır. Bunlar ayrıca, <function>lseek</function> işleviyle kullanmak (<xref linkend="glibc-I-O-Primitives"/>) ve dosya kilitleri için konum belirtmek (<xref linkend="glibc-Control-Operations"/>) için de kullanılır.
  </para>
  <csynopsis>
   <indexterm xml:id="glibc-vr-SEEK_SET_" linkend="glibc-vr"><primary>SEEK_SET</primary></indexterm>
   <csproto type="sabit">
    <csname><function>SEEK_SET</function></csname>
   </csproto>
   <header>&stdio.h;</header>
   <para>
    Bu tamsayı sabit, <function>fseek</function> veya <function>fseeko</function> işlevinin <parameter>whence</parameter> bağımsız değişkeninde dosyanın başlangıcına göre konum belirtmek için kullanılır.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm xml:id="glibc-vr-SEEK_CUR_" linkend="glibc-vr"><primary>SEEK_CUR</primary></indexterm>
   <csproto type="sabit">
    <csname><function>SEEK_CUR</function></csname>
   </csproto>
   <header>&stdio.h;</header>
   <para>
    Bu tamsayı sabit, <function>fseek</function> veya <function>fseeko</function> işlevinin <parameter>whence</parameter> bağımsız değişkeninde dosyanın geçerli dosya konumuna göre konum belirtmek için kullanılır.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm xml:id="glibc-vr-SEEK_END_" linkend="glibc-vr"><primary>SEEK_END</primary></indexterm>
   <csproto type="sabit">
    <csname><function>SEEK_END</function></csname>
   </csproto>
   <header>&stdio.h;</header>
   <para>
    Bu tamsayı sabit, <function>fseek</function> veya <function>fseeko</function> işlevinin <parameter>whence</parameter> bağımsız değişkeninde dosyanın sonuna göre konum belirtmek için kullanılır.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-rewind"><primary>rewind</primary></indexterm>
   <csproto type="işlev">
    <csname><type>void</type><function>rewind</function></csname>
    <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
   </csproto>
   <header>&stdio.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&asunsafe; &corrupt;</concept>
    <concept>&acunsafe; &lock; &corrupt;</concept>
   </conceptlist>
   <para>
    <code>rewind</code> işlevi <parameter>stream</parameter> akımını dosyanın başlangıcına konumlar. <function>fseek</function> veya <function>fseeko</function> işlevinin <parameter>whence</parameter> bağımsız değişkeninde <varname>SEEK_SET</varname> ve <parameter>offset</parameter> bağımsız değişkeninde <code>0L</code> belirtilerek çağrılmasına eşdeğerdedir. Bu işlevlerin aksine dönüş değeri yoktur ve akımın hata durumu belirteci sıfırlanır.
   </para>
  </csynopsis>
  <para>
   Eski BSD sistemleri ile uyumluluk adına <code>SEEK_…</code> sabitlerine karşılık olarak aşağıdaki sabitler de desteklenmektedir. Bu sabitler iki farklı başlık dosyasında tanımlıdır: &fcntl.h; ve &sys-file.h;.
  </para>
  <csynopsis>
   <indexterm xml:id="glibc-vr-L_SET_" linkend="glibc-vr"><primary>L_SET</primary></indexterm>
   <csproto type="sabit">
    <csname><function>L_SET</function></csname>
   </csproto>
   <header>&sys-file.h;</header>
   <para>
    <varname>SEEK_SET</varname> için takma addır.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm xml:id="glibc-vr-L_INCR_" linkend="glibc-vr"><primary>L_INCR</primary></indexterm>
   <csproto type="sabit">
    <csname><function>L_INCR</function></csname>
   </csproto>
   <header>&sys-file.h;</header>
   <para>
    <varname>SEEK_CUR</varname> için takma addır.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm xml:id="glibc-vr-L_XTND_" linkend="glibc-vr"><primary>L_XTND</primary></indexterm>
   <csproto type="sabit">
    <csname><function>L_XTND</function></csname>
   </csproto>
   <header>&sys-file.h;</header>
   <para>
    <varname>SEEK_END</varname> için takma addır.
   </para>
  </csynopsis>
 </chapter>
 <chapter xml:id="glibc-Portable-Positioning">
  <title>Taşınabilir Dosya Konumlama İşlevleri</title>
  <titleabbrev>&isoc; sistemlerinde rastgele erişim.</titleabbrev>
  <para>
   GNU sistemlerinde dosya konumlaması tamamen karakter sayısıdır. <function>fseek</function> veya <function>fseeko</function> işlevine konum karakter sayısı olarak belirtilebilir ve herhangi bir rastgele erişimli dosyada düzgün sonuçlar alınabilir. Ancak &isoc; sistemlerinde dosya konumlaması bu şekilde değildir.
  </para>
  <para>
   Bazı sistemlerde metin akımları ikil akımlardan tamamen farklıdır ve bir metin akımının dosya konumunu dosyanın başlangıcından itibaren karakter sayısı olarak belirtmek mümkün değildir. Örneğin bazı sistemlerde önce dosya içindeki kaydın konumuna oradan da kayıt içindeki karakter konumuna erişilir.
  </para>
  <para>
   Sonuç olarak, geliştirilen yazılımın bu sistemlere taşınabilir olması isteniyorsa bazı kurallara uyulması gerekir:
  </para>
  <itemizedlist>
   <listitem>
    <para>
     Bir metin akımında <function>ftell</function> işlevinden dönen değer, o ana kadar okunan karakterlerin sayısıyla bire bir ilişkili değildir. Tek bir şeyden emin olunabilir: <function>fseek</function> veya <function>fseeko</function> işlevinin <parameter>offset</parameter> bağımsız değişkeninde aynı değerler ardışık kullanılarak geriye aynı dosya konumuna gidilebilir.
    </para>
   </listitem>
   <listitem>
    <para>
     Bir metin akımında <function>fseek</function> veya <function>fseeko</function> çağrısında ya <parameter>offset</parameter> sıfır olmalı ya da <parameter>whence</parameter> bağımsız değişkeninin değeri <varname>SEEK_SET</varname> olmalı ve <parameter>offset</parameter> aynı akım üzerinde bir önceki <function>ftell</function> çağrısının sonucu olmalıdır.
    </para>
   </listitem>
   <listitem>
    <para>
     Bir metin akımının dosya konumlayıcı değeri, bu karakterler, onları okunmamış ya da iptal edilmemiş yapan <function>ungetc</function> ile geriye itilmişse tanımsızdır. Bkz.  <xref linkend="glibc-Unreading"/>.
    </para>
   </listitem>
  </itemizedlist>
  <para>
   Bu kurallara uyulsa bile uzun dosyalarda hala bazı sorunlar olabilir, çünkü <function>ftell</function> ve <function>fseek</function> dosya konumu için <type>long&nbsp;int</type> değer kullanır. Bu tür, büyükçe bir dosyadaki tüm dosya konumlarına erişmek için yeterli olmayabilir. <function>ftello</function> ve <function>fseeko</function> işlevlerinin kullanımı <type>off_t</type> türünü kullanmalarından ötürü tüm dosya konumlarına erişmeye yardımcı olabileceği umulsa bile hala, bir dosya konumu ile ilişkili ek bilgileri elde etmekte yardımı olmayacaktır.
  </para>
  <para>
   Bu durumda, dosya konumu için özel kodlamalar kullanılan sistemlere destek verilmek istenirse, bunlar yerine <function>fgetpos</function> ve <function>fsetpos</function> işlevlerinin kullanılması daha iyi olur. Bu işlevler dosya konumunu belirtmek için dahili genişliği sistemden sisteme değişiklik gösteren <type>fpos_t</type> veri türünü kullanır.
  </para>
  <para>
   Bu simgeler &stdio.h; başlık dosyasında bildirilmiştir.
   <indexterm linkend="glibc-pg"><primary>stdio.h</primary></indexterm>
  </para>
  <csynopsis>
   <indexterm linkend="glibc-tp" xml:id="glibc-tp-fpos_t"><primary>fpos_t</primary></indexterm>
   <csproto type="veri türü">
    <csname><function>fpos_t</function></csname>
   </csproto>
   <header>&stdio.h;</header>
   <para>
    <function>fgetpos</function> ve <function>fsetpos</function> işlevlerinde kullanmak üzere, bir akımın dosya konumu hakkındaki bilgileri kodlayan bir nesnenin türüdür.
   </para>
   <para>
    &glibc;nde, <code>fpos_t</code>, dosya konumunu içeren dahili veriyi ve dönüşüm durum bilgilerini tutan bir veri yapısıdır. Diğer sistemlerdeki görüntüsü farklı olabilir.
   </para>
   <para>
    Kaynaklar, 32 bitlik sistemlerde <code>_FILE_OFFSET_BITS == 64</code> ile derlendiğinde büyük dosya desteği arayüzü eski arayüzün yerine geçtiğinden bu veri türü <type>fpos64_t</type> türüne eşdeğer olur.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-tp" xml:id="glibc-tp-fpos64_t"><primary>fpos64_t</primary></indexterm>
   <csproto type="veri türü">
    <csname><function>fpos64_t</function></csname>
   </csproto>
   <header>&stdio.h;</header>
   <para>
    <function>fgetpos64</function> ve <function>fsetpos64</function> işlevlerinde kullanmak üzere, bir akımın dosya konumu hakkındaki bilgileri kodlayan bir nesnenin türüdür.
   </para>
   <para>
    &glibc;nde, <code>fpos64_t</code>, dosya konumunu içeren dahili veriyi ve dönüşüm durum bilgilerini tutan bir veri yapısıdır. Diğer sistemlerdeki görüntüsü farklı olabilir.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-fgetpos"><primary>fgetpos</primary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>fgetpos</function></csname>
    <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
    <csparam><ptr>fpos_t</ptr><parameter>position</parameter></csparam>
   </csproto>
   <header>&stdio.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&asunsafe; &corrupt;</concept>
    <concept>&acunsafe; &lock; &corrupt;</concept>
   </conceptlist>
   <para>
    Bu işlev <parameter>stream</parameter> akımının dosya konum değerini <parameter>position</parameter> ile gösterilen <type>fpos_t</type> nesnesinde saklar. Başarı durumunda <code>fgetpos</code> sıfır ile döner, aksi halde gerçeklemeye bağlı bir pozitif değeri <varname>errno</varname> değişkeninde saklayarak sıfırdan farklı bir değerle döner.
   </para>
   <para>
    Kaynaklar, 32 bitlik sistemlerde <code>_FILE_OFFSET_BITS == 64</code> ile derlendiğinde büyük dosya desteği arayüzü eski arayüzün yerine geçtiğinden bu işlev <function>fgetpos64</function> işlevine eşdeğer olur.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-fgetpos64"><primary>fgetpos64</primary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>fgetpos64</function></csname>
    <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
    <csparam><ptr>fpos64_t</ptr><parameter>position</parameter></csparam>
   </csproto>
   <header>&stdio.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&asunsafe; &corrupt;</concept>
    <concept>&acunsafe; &lock; &corrupt;</concept>
   </conceptlist>
   <para>
    Bu işlev dosya konumunu <parameter>position</parameter> ile gösterilen <type>fpos64_t</type> türünde bir değişken içinde döndürmesi dışında <function>fgetpos</function> işlevi gibidir.
   </para>
   <para>
    Kaynaklar, 32 bitlik sistemlerde <code>_FILE_OFFSET_BITS == 64</code> ile derlendiğinde büyük dosya desteği arayüzü eski arayüzün yerine geçtiğinden bu işlev <function>fgetpos</function> ismiyle de kullanılabilir.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-fsetpos"><primary>fsetpos</primary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>fsetpos</function></csname>
    <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
    <csparam><ptr>const&nbsp;fpos_t</ptr><parameter>position</parameter></csparam>
   </csproto>
   <header>&stdio.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&asunsafe; &corrupt;</concept>
    <concept>&acunsafe; &lock; &corrupt;</concept>
   </conceptlist>
   <para>
    Bu işlev, aynı akım üzerinde bir önceki <function>fgetpos</function> işlevinden dönen <parameter>position</parameter> değeriyle <parameter>stream</parameter> akımının dosya konum belirtecini konumlandırır. Başarı durumunda <code>fsetpos</code> akım üzerindeki dosya sonu belirtecini temizler, <function>ungetc</function> kullanımıyla geriye itilen karakterleri iptal eder ve sıfır değeriyle döner. Aksi takdirde, gerçeklenime göre <varname>errno</varname> değişkenine bir pozitif değer atar ve sıfırdan farklı bir değerle döner.
   </para>
   <para>
    Kaynaklar, 32 bitlik sistemlerde <code>_FILE_OFFSET_BITS == 64</code> ile derlendiğinde büyük dosya desteği arayüzü eski arayüzün yerine geçtiğinden bu işlev <function>fsetpos64</function> işlevine eşdeğer olur.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-fsetpos64"><primary>fsetpos64</primary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>fsetpos64</function></csname>
    <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
    <csparam><ptr>const&nbsp;fpos64_t</ptr><parameter>position</parameter></csparam>
   </csproto>
   <header>&stdio.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&asunsafe; &corrupt;</concept>
    <concept>&acunsafe; &lock; &corrupt;</concept>
   </conceptlist>
   <para>
    Bu işlev dosya konumlamasında kullanılacak <parameter>position</parameter> bağımsız değişkeninin <type>fpos64_t</type> türünde bir değişken olarak verilmesi dışında <function>fsetpos</function> ile aynıdır.
   </para>
   <para>
    Kaynaklar, 32 bitlik sistemlerde <code>_FILE_OFFSET_BITS == 64</code> ile derlendiğinde büyük dosya desteği arayüzü eski arayüzün yerine geçtiğinden bu işlev <function>fsetpos</function> ismiyle de kullanılabilir.
   </para>
  </csynopsis>
 </chapter>

 <chapter xml:id="glibc-Stream-Buffering">
  <title>Akım Tamponlama</title>
  <titleabbrev>Akımların tamponlarının denetimi.</titleabbrev>
  <preliminary>
   <para>
    <indexterm linkend="glibc-cp"><primary>akımlar</primary><secondary>tamponlama</secondary></indexterm>
    Bir akıma yazılan karakterler normalde bir araya getirilir ve uygulama tarafından bir çıktı olarak gösterilmeden bir bütün olarak dosyaya eşzamansız olarak aktarılır. Benzer olarak, akımlar çoğunlukla girdiyi konak ortamından karakter karakter değil bir bütün olarak alırlar. Bu işleme <wordasword>tamponlama</wordasword> adı verilir.
   </para>
   <para>
    Akımları kullanarak girdi ve çıktıyı etkileşimli yapan uygulamalar geliştirilirken, uygulamanın kullanıcı arayüzünü tasarlayabilmek için tamponlamanın nasıl çalıştığı bilinmek zorundadır. Aksi takdirde, kullanıcı ummadığı bir çıktı ya da beklemediği birtakım davranışlar görebilir.
   </para>
   <para>
    Bu bölüm yalnızca akım ile dosya veya aygıt arasında karakterlerin ne zaman iletileceğinin denetlenmesiyle ilgilenir; belirli aygıt sınıflarında yankı, akış denetimi ve benzerlerinin nasıl işlendiğiyle ilgilenmez. Uçbirimler üzerindeki denetim işlemleri ile ilgili bilgiler <xref linkend="glibc-Low-Level-Terminal-Interface"/> bölümünde bulunabilir.
   </para>
   <para>
    Bunun yerine dosya tanıtıcılarda çalışan düşük seviyeli giriş ve çıkış işlevlerini kullanılarak akım tamponlama oluşumları tamamen atlanabilir. Bkz.  <xref linkend="glibc-Low-Level-I-O"/>.
   </para>
  </preliminary>
  <sect1 xml:id="glibc-Buffering-Concepts">
   <title>Tamponlama Kavramları</title>
   <titleabbrev>Terminoloji.</titleabbrev>
   <para>
    Üç çeşit tamponlama yöntemi vardır:
   </para>
   <simplelist>
    <member>
      <firstterm>Tamponlanmamış</firstterm> bir akıma yazılan veya okunan karakterler dosyaya mümkün olduğunca tek tek aktarılır.
      <indexterm linkend="glibc-cp"><primary>akımlar</primary><secondary>tamponlanmamış</secondary></indexterm>
    </member>
    <member>
      <firstterm>Satır tamponlu</firstterm> akıma yazılan karakterler bir satır sonu karakterine rastlandığında dosyaya bütün olarak aktarılır.
      <indexterm linkend="glibc-cp"><primary>akımlar</primary><secondary>satır tamponlu</secondary></indexterm>
    </member>
    <member>
      <firstterm>Tamamen tamponlu</firstterm> akıma yazılan ya da okunan karakterler bir dosyaya keyfi uzunlukta dilimler halinde yazılır ya da okunur.
      <indexterm linkend="glibc-cp"><primary>akımlar</primary><secondary>tamamen tamponlu</secondary></indexterm>
    </member>
   </simplelist>
   <para>
    Normalde, yeni açılmış akımların tamamı tamponludur, bir şey dışında: Uçbirim gibi etkileşimli bir aygıtla bağlantılı akımlar dahili olarak satır tamponludur. Tamponlama türünün seçimi hakkında daha ayrıntılı bilgi için <xref linkend="glibc-Controlling-Buffering"/> bölümüne bakılabilir. Özdevinimli seçim  genellikle, açılan dosya ya da aygıt için tamponlamanın en uygun çeşidini sağlar.
   </para>
   <para>
    Etkileşimli aygıtlar için satır tamponlaması çıktılanan iletilerin sonuna (tam da istenen şey) hemen bir satır sonu karakteri ekler. Bir satır sonu karakteri ile bitmeyen çıktılar hemen gösterilebileceği gibi gösterilmeyebilir de. Hemen görüntülenmesi istenirse, <xref linkend="glibc-Flushing-Buffers"/> bölümünde açıklandığı gibi <function>fflush</function> ile tamponlu çıktı doğrudan doğruya aygıta boşaltılabilir.
   </para>
  </sect1>
  <sect1 xml:id="glibc-Flushing-Buffers">
   <title>Tamponların Boşaltılması</title>
   <titleabbrev>Çıktı tamponunun boşaltıldığı bilgisi.</titleabbrev>
   <para>
    <indexterm linkend="glibc-cp"><primary>akımlar</primary><secondary>boşaltma</secondary></indexterm>
    <wordasword>Boşaltma</wordasword>, bir tamponlu akımın biriken karakterleri bir dosyaya çıktılamasıdır. Bir akım üzerindeki tamponlu çıktının özdevinimli olarak boşaltılması çeşitli durumlarda ortaya çıkar:
   </para>
   <simplelist>
    <member>
     Çıktı tamponu dolduğu halde ve çıktılama yapılmaya çalışılmıştır.
    </member>
    <member>
     Akım kapatılıyordur. Bkz.  <xref linkend="glibc-Closing-Streams"/>.
    </member>
    <member>
     <function>exit</function> çağrısı ile uygulama sonlandırılıyordur. Bkz. <xref linkend="glibc-Normal-Termination"/>.
    </member>
    <member>
     Akım satır tamponludur ve bir satır sonu karakteri yazılmıştır.
    </member>
    <member>
     Akım veriyi dosyadan okurken bir girdi işlemi vardır.
    </member>
   </simplelist>
   <para>
    Bunların dışında tamponlu bir çıktının boşaltılması istenirse &stdio.h; başlık dosyasında bildirilmiş olan <function>fflush</function> işlevi çağrılır.
    <indexterm linkend="glibc-pg"><primary>stdio.h</primary></indexterm>
   </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-fflush"><primary>fflush</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-fflush"><primary>akımlar</primary><secondary>çıktı tamponunun boşaltılması</secondary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>fflush</function></csname>
     <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
    </csproto>
    <header>&stdio.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&asunsafe; &corrupt;</concept>
     <concept>&acunsafe; &lock; &corrupt;</concept>
    </conceptlist>
    <para>
     Bu işlev <parameter>stream</parameter> üzerindeki tamponlu çıktının dosyaya teslimini sağlar. Eğer <parameter>stream</parameter> boş gösterici ise <code>fflush</code>, tamponlu çıktının tüm açık çıktı akımlarına boşaltılmasına sebep olur.
    </para>
    <para>
     Bir yazma hatası oluşursa, bu işlev <varname>EOF</varname> döndürür. Aksi takdirde sıfır döner.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-fflush_unlocked"><primary>fflush_unlocked</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-fflush_unlocked"><primary>akımlar</primary><secondary>çıktı tamponunun boşaltılması (kilitsiz)</secondary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>fflush_unlocked</function></csname>
     <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
    </csproto>
    <header>&stdio.h;</header>
    <conceptlist>
     <concept>&mtsafe; &race;<code linkend="glibc-safety-identifier">:stream</code></concept>
     <concept>&asunsafe; &corrupt;</concept>
     <concept>&acunsafe; &corrupt;</concept>
    </conceptlist>
    <para>
     <code>fflush_unlocked</code> işlevi akımı örtük olarak kilitlememesi dışında <function>fflush</function> işlevi ile aynıdır.
    </para>
   </csynopsis>
   <para>
    <function>fflush</function> işlevi o an açık olan tüm akımları boşaltmak için kullanılabilir. Bu bazı durumlarda kullanışlıdır ama bazı durumlarda da gereklidir. Örneğin, uçbirimden girdi bekleyen bir uygulama için, uçbirimde tüm çıktının görünür olması istenir. Fakat bu sadece satır tamponlu akımlar için anlamlıdır. Solaris özellikle bu durum için bir işlev içerir. Bu işlev &glibc;nde birtakım şekillerde hep vardı ama hiçbir zaman resmen var denilmedi.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-flushlbf"><primary sortas="flushlbf">_flushlbf</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-flushlbf"><primary>akımlar</primary><secondary>satır tamponunun boşaltılması</secondary></indexterm>
    <csproto type="işlev">
     <csname><type>void</type><function>_flushlbf</function></csname>
     <csparam><void/></csparam>
    </csproto>
    <header>&stdio_ext.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&asunsafe; &corrupt;</concept>
     <concept>&acunsafe; &lock; &corrupt;</concept>
    </conceptlist>
    <para>
     <code>_flushlbf</code> işlevi o an açık bulunan tüm satır tamponlu akımları boşaltır.
    </para>
   </csynopsis>
   <note><title>Uyumluluk Bilgisi</title>
    <para>
     Satır yönlenimli girdi ve çıktıya saplantılı olduğu bilinen kafa travması geçirmiş bazı işletim sistemlerinde satır tamponlu çıktının boşaltılması bir satır sonu karakterinin de yazılmasına sebep olur. Bereket versin ki bu "özellik" giderek daha az kullanılır olmaya doğru gidiyor. &glibc;inde bundan dolayı kaygılanılmasına gerek yoktur.
    </para>
   </note>
   <para>
    Bazı durumlarda bekleyen çıktının boşaltılması yerine unutulması daha kullanışlı olabilir. Eğer aktarımın bedeli yüksekse ve geçerli bir sebep yoksa çıktılama gerekmez. Bu gibi durumlar için Solaris’te standart dışı bir işlev vardır ve &glibc;nde de bulunmaktadır.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-fpurge"><primary sortas="fpurge__">__fpurge</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-fpurge"><primary>akımlar</primary><secondary>çıktı tamponunun unutulması</secondary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>__fpurge</function></csname>
     <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
    </csproto>
    <header>&stdio_ext.h;</header>
    <conceptlist>
     <concept>&mtsafe; &race;<code linkend="glibc-safety-identifier">:stream</code></concept>
     <concept>&asunsafe; &corrupt;</concept>
     <concept>&acunsafe; &corrupt;</concept>
    </conceptlist>
    <para>
     <code>__fpurge</code> işlevi <parameter>stream</parameter> akımının tamponunun temizlenmesini sağlar. Akım zaten okuma kipindeyse tampondaki tüm girdi kaybolur. Çıktılama kipindeyse tamponlu çıktı aygıta (veya igili saklama alanına) yazılmaz ve tampon temizlenir.
    </para>
   </csynopsis>
  </sect1>

  <sect1 xml:id="glibc-Controlling-Buffering">
   <title>Tamponlama Çeşidinin Seçimi</title>
   <titleabbrev>Hangi tamponlama çeşidinin kullanılacağının belirtilmesi.</titleabbrev>
   <para>
    Bir akım açıldıktan sonra (ancak henüz başka hiçbir işlem yapılmadan), hangi tamponlama çeşidinin kullanılacağı <function>setvbuf</function> işlevi kullanılarak belirtilebilir.
   </para>
   <para>
    <indexterm linkend="glibc-cp"><primary>akımlar</primary><secondary>tamponlama seçimi</secondary></indexterm>
    <indexterm linkend="glibc-pg"><primary>stdio.h</primary></indexterm>
    Bu bölümde sözü edilen oluşumlar &stdio.h; başlık dosyasında bildirilmiştir.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-setvbuf"><primary>setvbuf</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-setvbuf"><primary>akımlar</primary><secondary>tamponlama türünün belirtilmesi</secondary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>setvbuf</function></csname>
     <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
     <csparam><ptr>char</ptr><parameter>buf</parameter></csparam>
     <csparam><type>int</type><parameter>mode</parameter></csparam>
     <csparam><type>size_t</type><parameter>size</parameter></csparam>
    </csproto>
    <header>&stdio.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&asunsafe; &corrupt;</concept>
     <concept>&acunsafe; &lock; &corrupt;</concept>
    </conceptlist>
    <para>
     Bu işlev ile <parameter>stream</parameter> akımının hangi tamponlama kipini kullanacağı belirtilir. <parameter>mode</parameter> bağımsız değişkeninde, akımın tümünün tamponlanması isteniyorsa <varname>_IOFBF</varname>, satır tamponlu olması isteniyorsa <varname>_IOLBF</varname>, girdi/çıktının tamponlanması istenmiyorsa <varname>_IONBF</varname> sabiti kullanılır.
    </para>
    <para>
     <parameter>buf</parameter> bağımsız değişkenine boş gösterici belirtilirse, işlev <function>malloc</function> kullanarak tamponu kendisi ayırır. Akım serbest bırakılınca bu tampon da serbest bırakmış olur.
    </para>
    <para>
     Aksi takdirde, <parameter>buf</parameter> en az <parameter>size</parameter> karakterlik bir karakter dizisini tutacak büyüklükte seçilmelidir. Akım açık olduğu sürece ve bu dizi akım tamponunda kaldığı sürece, dizi akım tarafından kullanılıyor olacağından diziye ayrılan alan bu süre zarfında serbest bırakılmamalıdır. Tamponun ya durağan olarak ya da <command>malloc</command> (<xref linkend="glibc-Unconstrained-Allocation"/>) kullanılarak ayrılması gerekir. Dizinin bildirildiği dilimden çıkmadan önce dosya kapatılmayacaksa özdevinimli dizi kullanımı önerilmez.
    </para>
    <para>
     Dizi bir akım tamponu olarak kaldığı sürece, akım G/Ç işlevleri dahili amaçları için tamponu kullanacaktır. Akım diziyi tamponlama amacıyla kullanırken dizinin içeriğine doğrudan erişilmemelidir.
    </para>
    <para>
     <code>setvbuf</code> işlevi başarılı olduğunda sıfır ile döner. <parameter>mode</parameter> değeri geçersizse ya da istek yerine getirilememişse sıfırdan farklı bir değerle döner.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm xml:id="glibc-vr-IOFBF" linkend="glibc-vr"> <primary sortas="IOFBF">_IOFBF</primary> </indexterm>
    <csproto type="makro">
     <csname><function>_IOFBF</function></csname>
    </csproto>
    <header>&stdio.h;</header>
    <para>
     Bu makronun değeri <function>setvbuf</function> işlevinin <parameter>mode</parameter> bağımsız değişkeninde kullanılarak akımın tamamen tamponlanacağının belirtilmesini sağlayan bir tamsayı sabittir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm xml:id="glibc-vr-IOLBF" linkend="glibc-vr"> <primary sortas="IOLBF">_IOLBF</primary> </indexterm>
    <csproto type="makro">
     <csname><function>_IOLBF</function></csname>
    </csproto>
    <header>&stdio.h;</header>
    <para>
     Bu makronun değeri <function>setvbuf</function> işlevinin <parameter>mode</parameter> bağımsız değişkeninde kullanılarak akımın satır tamponlu olacağının belirtilmesini sağlayan bir tamsayı sabittir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm xml:id="glibc-vr-IONBF" linkend="glibc-vr"> <primary sortas="IONBF">_IONBF</primary> </indexterm>
    <csproto type="makro">
     <csname><function>_IONBF</function></csname>
    </csproto>
    <header>&stdio.h;</header>
    <para>
     Bu makronun değeri <function>setvbuf</function> işlevinin <parameter>mode</parameter> bağımsız değişkeninde kullanılarak akımın tamponlanmayacağının belirtilmesini sağlayan bir tamsayı sabittir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm xml:id="glibc-vr-BUFSIZ" linkend="glibc-vr"><primary>BUFSIZ</primary> </indexterm>
    <csproto type="makro">
     <csname><function>BUFSIZ</function></csname>
    </csproto>
    <header>&stdio.h;</header>
    <para>
     Bu makronun değeri <function>setvbuf</function> işlevinin <parameter>size</parameter> bağımsız değişkeninde kullanılmasının iyi olacağı bir tamsayı sabit ifadesidir. Bu değer en azından <code>256</code> değerini garantiler.
    </para>
    <para>
     <code>BUFSIZ</code> değeri her sistemde akımın G/Ç verimliliğine uygun olarak seçilir. Bu bakımdan <function>setvbuf</function> çağrısında tampon boyu olarak <code>BUFSIZ</code> kullanmak iyi bir fikirdir.
    </para>
    <para>
     Aslında, <function>fstat</function> sistem çağrısından elde edilen bir değerin tampon boyu olarak kullanılması daha da iyi olacaktır: Dosya özniteliklerinin (<type>struct&nbsp;stat</type> yapısının) <structfield>st_blksize</structfield> alanı bu değeri içerir. Bkz.  <xref linkend="glibc-Attribute-Meanings"/>.
    </para>
    <para>
     Bazıları <function>fgets</function> (<xref linkend="glibc-Character-Input"/>) ile girdi alınması gibi durumlarda tampon tahsis boyu olarak <code>BUFSIZ</code> değerini kullanır. G/Ç işlemlerinin verimli olmasını sağlamak dışında herhangi bir tamsayı değer yerine <code>BUFSIZ</code> kullanmanın geçerli bir sebebi yoktur.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-setbuf"><primary>setbuf</primary></indexterm>
    <csproto type="işlev">
     <csname><type>void</type><function>setbuf</function></csname>
     <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
     <csparam><ptr>char</ptr><parameter>buf</parameter></csparam>
    </csproto>
    <header>&stdio.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&asunsafe; &corrupt;</concept>
     <concept>&acunsafe; &lock; &corrupt;</concept>
    </conceptlist>
    <para>
     <parameter>buf</parameter> bağımsız değişkeni boş gösterici olduğunda, bu işlev, <function>setvbuf</function> işlevinin <parameter>mode</parameter> bağımsız değişkenine <varname>_IONBF</varname> belirtilerek çağrılmasına eşdeğerdedir. Aksi takdirde <function>setvbuf</function> işlevinin <parameter>size</parameter> bağımsız değişkeninde <command>BUFSIZ</command> ve <parameter>mode</parameter> bağımsız değişkeninde <command>_IOFBF</command> kullanılarak tampon istendiği duruma eşdeğerdir.
    </para>
    <para>
     <code>setbuf</code> işlevi eski kod ile uyumluluk için vardır. Yeni yazılımlarda <function>setvbuf</function> işlevi kullanılmalıdır.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-setbuffer"><primary>setbuffer</primary></indexterm>
    <csproto type="işlev">
     <csname><type>void</type><function>setbuffer</function></csname>
     <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
     <csparam><ptr>char</ptr><parameter>buf</parameter></csparam>
     <csparam><type>size_t</type><parameter>size</parameter></csparam>
    </csproto>
    <header>&stdio.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&asunsafe; &corrupt;</concept>
     <concept>&acunsafe; &lock; &corrupt;</concept>
    </conceptlist>
    <para>
     <parameter>buf</parameter> boş gösterici ise bu işlev, <parameter>stream</parameter> akımını tamponsuz yapar. Aksi takdirde, <parameter>stream</parameter> akımı <parameter>buf</parameter> tamponuna tamamen tamponlanacaktır. <parameter>size</parameter> bağımsız değişkeni tamponunun boyunu belirtmekte kullanılır.
    </para>
    <para>
     Bu işlev eski BSD kodu ile uyumluluk için vardır. Yeni yazılımlarda <function>setvbuf</function> işlevi kullanılmalıdır.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-setlinebuf"><primary>setlinebuf</primary></indexterm>
    <csproto type="işlev">
     <csname><type>void</type><function>setlinebuf</function></csname>
     <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
    </csproto>
    <header>&stdio.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&asunsafe; &corrupt;</concept>
     <concept>&acunsafe; &lock; &corrupt;</concept>
    </conceptlist>
    <para>
     Bu işlev <parameter>stream</parameter> akımını satır tamponlu yapar ve tamponu kendisi tahsis eder.
    </para>
    <para>
     Bu işlev eski BSD kodu ile uyumluluk için vardır. Yeni yazılımlarda <function>setvbuf</function> işlevi kullanılmalıdır.
    </para>
   </csynopsis>
   <para>
    Verilen bir akımın satır tamponlu mu yoksa Solaris’te standart-dışı ama &glibc;nde mevcut işlevin kullanılmamış mı olduğu sorgulanabilir.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-flbf__"><primary sortas="flbf">__flbf</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>__flbf</function></csname>
     <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
    </csproto>
    <header>&stdio_ext.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     <code>__flbf</code> işlevi, <parameter>stream</parameter> akımı satır tamponlu ise sıfırdan farklı bir değerle döner. Aksi takdirde sıfır ile döner.
    </para>
   </csynopsis>
   <para>
    Tampon boyunu ve ne kadarının kullanılmş olsuğunu sorgulayan iki işlev daha vardır ve bunlar Solaris’te de vardır.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-fbufsize"><primary sortas="fbufsize">__fbufsize</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-fbufsize"><primary>akımlar</primary><secondary>tampon boyunun sorgulanması</secondary></indexterm>
    <csproto type="işlev">
     <csname><type>size_t</type><function>__fbufsize</function></csname>
     <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
    </csproto>
    <header>&stdio_ext.h;</header>
    <conceptlist>
     <concept>&mtsafe; &race;<code linkend="glibc-safety-identifier">:stream</code></concept>
     <concept>&asunsafe; &corrupt;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     <code>__fbufsize</code> işlevi, <parameter>stream</parameter> akımının tampon boyu ile döner. Bu değer akım kullanımını en iyilemek için kullanılabilir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-fpending"><primary sortas="fpending">__fpending</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-fpending"><primary>akımlar</primary><secondary>tampon içeriğinin boyunun sorgulanması</secondary></indexterm>
    <csproto type="işlev">
     <csname><type>size_t</type><function>__fpending</function></csname>
     <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
    </csproto>
    <header>&stdio_ext.h;</header>
    <conceptlist>
     <concept>&mtsafe; &race;<code linkend="glibc-safety-identifier">:stream</code></concept>
     <concept>&asunsafe; &corrupt;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     <code>__fpending</code> işlevi, çıktı tamponunda o an bulunan karakterlerin sayısı ile döner. Geniş karakterli tamponlar için bu boyut geniş karakter cinsindendir. Bu işlev okuma kipindeki ya da salt okunur açılmış tamponlarda kulllanılmamalıdır.
    </para>
   </csynopsis>
  </sect1>
 </chapter>

 <chapter xml:id="glibc-Other-Kinds-of-Streams" userlevel="longtoc">
  <title>Diğer Akım Çeşitleri</title>
  <titleabbrev>Açık bir dosyanın karşılığı olmayan akımlar.</titleabbrev>
  <preliminary>
   <para>
    &glibc;nde bir açık dosyanın karşılığı olması gerekmeyen akım çeşitlerini tanımlayabilme olanağı da vardır.
   </para>
   <para>
    Bu tür bir akım girdiyi dizgeden alabilir veya dizgeye yazabilir. Bu çeşit akımlar dahili olarak <function>sprintf</function> ve <function>sscanf</function> işlevlerinin gerçeklenimlerinde kullanılmaktadır. Yazılımcı <xref linkend="glibc-String-Streams"/> bölümünde açıklanan işlevleri kullanarak bu çeşit akımları kendisi de oluşturabilir.
   </para>
   <para>
    Daha genel olarak keyfi nesnelerde giriş/çıkış işlemi yapmakta kullanılan akımlar da tanımlanabilir. Bu protokol <xref linkend="glibc-Custom-Streams"/> bölümünde anlatılmıştır.
   </para>
   <note><title>Taşınabilirlik Bilgisi</title>
    <para>
     Bu bölümde açıklanan oluşumlar GNU'ya özeldir. Diğer sistemler ve diğer C gerçeklemeleri bunlara eşdeğer işlevleri sağlıyor/sağlamıyor olabilir.
    </para>
   </note>
  </preliminary>

  <sect1 xml:id="glibc-String-Streams">
   <title>Dizge Akımları</title>
   <titleabbrev>Dizge ya da bellek tamponu ile veri alışverişi için kullanılan akımlar.</titleabbrev>
   <para>
    <indexterm linkend="glibc-pg"><primary>stdio.h</primary></indexterm>
    <indexterm linkend="glibc-cp"><primary>akımlar</primary><secondary>dizgelerle G/Ç için</secondary></indexterm>
    Bir dizge ya da bellek tamponu ile veri alışverişini mümkün kılan <function>fmemopen</function> ve <function>open_memstream</function> işlevleri &stdio.h; başlık dosyasında bildirilmiştir.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-fmemopen"><primary>fmemopen</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-fmemopen"><primary>dizge akımı</primary><secondary>erişim türü belirterek açılması</secondary></indexterm>
    <csproto type="işlev">
     <csname><ptr>FILE</ptr><function>fmemopen</function></csname>
     <csparam><ptr>void</ptr><parameter>buf</parameter></csparam>
     <csparam><type>size_t</type><parameter>size</parameter></csparam>
     <csparam><ptr>const&nbsp;char</ptr><parameter>opentype</parameter></csparam>
    </csproto>
    <header>&stdio.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&asunsafe; &heap; &lock;</concept>
     <concept>&acunsafe; &mem; &lock;</concept>
    </conceptlist>
    <para>
     Bu işlev <parameter>buf</parameter> tamponunu kullanan ve <parameter>opentype</parameter> bağımsız değişkeninde belirtilen erişimi mümkün kılan bir akım açar. <varname>tampon</varname> olarak belirtilen dizi en az <parameter>size</parameter> bayt uzunlukta olmalıdır.
    </para>
    <para>
     <parameter>buf</parameter> bağımsız değişkeninde boş gösterici belirtilirse <code>fmemopen</code> işlevi <parameter>size</parameter> bayt uzunlukta bir diziyi (<function>malloc</function> kullanarak; bkz. <xref linkend="glibc-Unconstrained-Allocation"/>) özdevimli ayırırır. Bu genelikle sadece tampona bazı şeyler yazıldıktan hemen sonra okunmak istenirse kullanışlıdır. Çünkü aslında tampona bir gösterici almanın başka bir yolu yoktur (bunun için aşağıdaki <function>open_memstream</function> işlevi denenebilir). Tampon, akım kapatıldığında serbest bırakılır.
    </para>
    <para>
     <parameter>opentype</parameter> bağımsız değişkeni <function>fopen</function> işlevindeki gibi belirtilir (bkz. <xref linkend="glibc-Opening-Streams"/>). <parameter>opentype</parameter> ekleme kipinde belirtilirse, ilk dosya konumu tampondaki ilk boş karaktere ayarlanır. Aksi takdirde ilk dosya konumu tamponun başlangıcıdır.
    </para>
    <para>
     Bir akım yazmak için açılırken boşaltılır ve kapatılır, boş karakter ise yer varsa tamponun sonuna yazılır. Bunun için <parameter>size</parameter> bağımsız değişkeni tasarlanırken bu ek bayt gözönüne alınmalıdır. Tampona <parameter>size</parameter> bayttan daha fazlası yazılmak istendiğinde bir hata oluşacaktır.
    </para>
    <para>
     Okumak için açılan bir akım için tampondaki boş karakterler dosya sonu olarak ele alınmaz. Okuma işlemlerinde sadece dosya konumunun <parameter>size</parameter> bayt ilerlemesi dosya sonu olarak değerlendirilir. Bu durumda karakterler boş karakter sonlandırmalı dizgeden okunmak istenirse <parameter>size</parameter> baytlık bir dizge sağlamak gerekir.
    </para>
   </csynopsis>
   <example>
    <para>
     Bu örnekte bir dizgeden okuma yapmak için <function>fmemopen</function> kullanılarak bir akım açılmaktadır:
    </para>
    <screen>#include &lt;stdio.h&gt;

static char buffer[] = "foobar";

int
main (void)
{
  int ch;
  FILE *stream;

  stream = fmemopen (buffer, strlen (buffer), "r");
  while ((ch = fgetc (stream)) != EOF)
    printf ("%c geldi\n", ch);
  fclose (stream);

  return 0;
}
</screen>
    <para>
     Aşağıdaki çıktıyı üretir:
    </para>
    <screen>f geldi
o geldi
o geldi
b geldi
a geldi
r geldi
</screen>
   </example>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-open_memstream"><primary>open_memstream</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-open_memstream"><primary>dizge akımı</primary><secondary>yazmak için açılması</secondary></indexterm>
    <csproto type="işlev">
     <csname><ptr>FILE</ptr><function>open_memstream</function></csname>
     <csparam><pptr>char</pptr><parameter>ptr</parameter></csparam>
     <csparam><ptr>size_t</ptr><parameter>sizeloc</parameter></csparam>
    </csproto>
    <header>&stdio.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&asunsafe; &heap;</concept>
     <concept>&acunsafe; &mem;</concept>
    </conceptlist>
    <para>
     Bu işlev belirtilen tampona yazmak için akım açar. Tampon <function>malloc</function> kullanılarak özdevimli ayrılır ve gerektikçe büyütülür.  Akımı kapattıktan sonra bu tamponun <function>free</function> veya <function>realloc</function> kullanarak temizlenmesi yazılımcının sorumluluğundadır. Bkz. <xref linkend="glibc-Unconstrained-Allocation"/>.
    </para>
    <para>
     Akım <function>fclose</function> ile kapatıldığında ya da <function>fflush</function> ile boşaltıldığında, <parameter>ptr</parameter> tampona bir gösterici olarak ve boyutu da <parameter>sizeloc</parameter> değişkenine güncellenir. Buralarda saklanmış olan değerler akımda başka bir değer yer alıncaya kadar geçerli kalır. Başka çıktılar almak için kullanmadan önce akımın boşaltılması gerekir.
    </para>
    <para>
     Tamponun sonuna boş karakter yazılır. Bu boş karakter <parameter>sizeloc</parameter> bayta dahil edilmez.
    </para>
    <para>
     Akımın dosya konumu <function>fseek</function> veya <function>fseeko</function> (<xref linkend="glibc-File-Positioning"/>) işlevleri kullanılarak değiştirilebilir. Dosya konumunun yazılmış verinin sonrasına taşınması halinde arada kalan boşluklar sıfırlarla doldurulur.
    </para>
   </csynopsis>
   <example><title><code>open_memstream</code> kullanımı</title>
    <screen>#include &lt;stdio.h&gt;

int
main (void)
{
  char *bp;
  size_t size;
  FILE *stream;

  stream = open_memstream (&amp;bp, &amp;size);
  fprintf (stream, "hello");
  fflush (stream);
  printf ("buf = `%s', size = %zu\n", bp, size);
  fprintf (stream, ", world");
  fclose (stream);
  printf ("buf = `%s', size = %zu\n", bp, size);

  return 0;
}
</screen>
    <para>
     Aşağıdaki çıktıyı üretir:
    </para>
    <screen>buf = `hello', size = 5
buf = `hello, world', size = 12
</screen>
   </example>
  </sect1>

  <sect1 xml:id="glibc-Custom-Streams" userlevel="longtoc">
   <title>Özel Akımlar</title>
   <titleabbrev>Seçimlik bir veri kaynağı ile seçimlik bir veri alıcısı arasında özel bir akım tanımlamak.</titleabbrev>
   <preliminary>
    <para>
     Bu bölümde, isteğe bağlı bir veri kaynağından girdi alan veya isteğe bağlı bir veri havuzuna çıktı yazan bir akımın nasıl oluşturulabileceği açıklanmaktadır. Bunlara <wordasword>özel akımlar</wordasword> denilmektedir. Burada açıklanan işlevler ve türlerin tümü GNU oluşumudur.
    </para>
   </preliminary>
   <sect2 xml:id="glibc-Streams-and-Cookies">
    <title>Özel Akımlar ve Çerezler</title>
    <titleabbrev>"Çerez", okunan veya yazılan verilerin alınacağını veya saklanacağını yeri kaydeder.</titleabbrev>
    <para>
     <indexterm linkend="glibc-cp"><primary>özel akımlar</primary><secondary>çerezler</secondary></indexterm>
     Her özel akımın içeriği <wordasword>çerez</wordasword> adı verilen özel bir nesnedir. Bu nesne yazılımcı tarafından sağlanır ve okunan veya yazılan verinin nereden alınacağı ve nereye yazılacağının kayıtlarından oluşur. Kütüphanedeki akım işlevleri doğrudan bu akımların içeriği ile çalışamaz ve hatta veri türünü bile bilmez; bunların adresleri <type>void *</type> türünde saklanır.
    </para>
    <para>
     Özel bir akımı gerçekleştirmek için, verinin belirtilen yerden <emphasis>nasıl</emphasis> alınacağı veya <emphasis>nerede</emphasis> saklanacağı belirtilmelidir. Bu işlem, akıma yazan, akımdan okuyan, dosya konumunu değiştiren ve kapatan dört <firstterm>kanca işlevi</firstterm> tanımlanarak yapılır. Bu dört işlev akımın çerezine aktarılacak, böylece çerezler verinin nereden alınıp nerede saklanacağını söyleyebilecektir. Kütüphane işlevleri çerezin içinde neler olduğunu bilmez, yazılımcı tarafından tanımlanan işlevlerin bilmesi gerekir.
    </para>
    <para>
     Özel bir akımı oluştururken bir çerez göstericisinin ve ayrıca <type>cookie_io_functions_t</type> yapısının alanlarında saklanan dört kanca işlevin belirtilmesi gerekir.
    </para>
    <para>
     <indexterm linkend="glibc-pg"><primary>stdio.h</primary></indexterm>
     Burada sözü edilen oluşumlar &stdio.h; başlık dosyasında bildirilmiştir.
    </para>
    <csynopsis>
     <indexterm linkend="glibc-tp" xml:id="glibc-tp-cookie_io_functions_t"><primary sortas="cookie_io_functions_t">struct&nbsp;cookie_io_functions_t</primary></indexterm>
     <csproto type="veri türü">
      <csname><type>struct</type><function>cookie_io_functions_t</function></csname>
     </csproto>
     <header>&cookie_io_functions_t.h;</header>
     <para>
      Bu veri yapısı, akım ile çerezi arasındaki iletişim protokolünü tanımlayan işlevleri saklar. Aşağıdaki üyelere sahiptir:
     </para>
     <glosslist>
      <glossentry>
       <glossterm>
        <type>cookie_read_function_t&nbsp;*</type><structfield>read</structfield>
       </glossterm>
       <glossdef>
        <para>
         Çerezden veriyi okuyan işlevdir. Değeri bir işlev değil de bir boş gösterici ise bu akımdan yapılan okuma işlemleri daima <varname>EOF</varname> döndürür.
        </para>
       </glossdef>
      </glossentry>
      <glossentry>
       <glossterm>
        <type>cookie_write_function_t&nbsp;*</type><structfield>write</structfield>
       </glossterm>
       <glossdef>
        <para>
         Çereze veriyi yazan işlevdir. Değeri bir işlev değil de bir boş gösterici ise bu akıma yazılan veriler iptal edilir.
        </para>
       </glossdef>
      </glossentry>
      <glossentry>
       <glossterm>
        <type>cookie_seek_function_t&nbsp;*</type><structfield>seek</structfield>
       </glossterm>
       <glossdef>
        <para>
         Çerez üzerindeki dosya konumlamasına eşdeğer işlemleri uygulayan işlevdir. Değeri bir işlev değil de bir boş gösterici ise bu akım üzerinde yapılan <function>fseek</function> veya <function>fseeko</function> çağrıları sadece tampon içinde konumlama yapar; tamponun dışına çıkan tüm konumlama istekleri bir <function>ESPIPE</function> hatası ile sonuçlanacaktır.
        </para>
       </glossdef>
      </glossentry>
      <glossentry>
       <glossterm>
        <type>cookie_close_function_t&nbsp;*</type><structfield>close</structfield>
       </glossterm>
       <glossdef>
        <para>
         Akım kapatılırken çerez üzerinde temizlik yapan işlevdir. Değeri bir işlev değil de bir boş gösterici ise bu akım kapatılırken çerezi kapatacak hiçbir özel işlem yapılmaz.
        </para>
       </glossdef>
      </glossentry>
     </glosslist>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-fn" xml:id="glibc-fn-fopencookie"><primary>fopencookie</primary></indexterm>
     <indexterm linkend="glibc-cp" xml:id="glibc-cp-fopencookie"><primary>özel akımlar</primary><secondary>oluşturulması</secondary></indexterm>
     <csproto type="işlev">
      <csname><ptr>FILE</ptr><function>fopencookie</function></csname>
      <csparam><ptr>void</ptr><parameter>cookie</parameter></csparam>
      <csparam><ptr>const&nbsp;char</ptr><parameter>opentype</parameter></csparam>
      <csparam><type>cookie_io_functions_t</type><parameter>io-functions</parameter></csparam>
     </csproto>
     <header>&stdio.h;</header>
     <conceptlist>
      <concept>&mtsafe;</concept>
      <concept>&asunsafe; &heap; &lock;</concept>
      <concept>&acunsafe; &mem; &lock;</concept>
     </conceptlist>
     <para>
      Bu işlev, <parameter>io-functions</parameter> bağımsız değişkeninde belirtilen işlevleri kullanarak <parameter>cookie</parameter> çerezi ile haberleşen bir akım oluşturur. <parameter>opentype</parameter> bağımsız değişkeni <function>fopen</function> işlevindeki gibi kullanılır; bkz. <xref linkend="glibc-Opening-Streams"/>.  (Fakat "açılışta kırp" seçeneği gözardı edilir.) Oluşturulan akımın tamamı tamponlanır.
     </para>
     <para>
      <code>fopencookie</code> işlevi ya yeni oluşturulan akım ile ya da bir hata durumunda boş gösterici ile döner.
     </para>
    </csynopsis>
   </sect2>

   <sect2 xml:id="glibc-Hook-Functions">
    <title>Özel Akım Kanca İşlevleri</title>
    <titleabbrev>Özel akımın ihtiyaç duyduğu dört kanca işlevin tanımlanması.</titleabbrev>
    <para>
     <indexterm linkend="glibc-cp"><primary>özel akımlar</primary><secondary>kanca işlevler</secondary></indexterm>
     Bu bölümde bir özel akımın gerektirdiği dört kanca işlevin tanımlanması ayrıntılı olarak incelenmiştir.
    </para>
    <para>
     Çerezden veri okuyan işlev şöyle bildirilmelidir:
    </para>
    <literallayout class="monospaced"><code>ssize_t <replaceable>okuyucu</replaceable> (void *<replaceable>çerez</replaceable>, char *<replaceable>tampon</replaceable>, size_t <replaceable>boyut</replaceable>)</code>
</literallayout>
    <para>
     Bu işlev <function>read</function> işlevine çok benzer; bkz. <xref linkend="glibc-I-O-Primitives"/>.  İşlev, <replaceable>tampon</replaceable> tamponundan <replaceable>boyut</replaceable> bayt aktarmalı ve okunan bayt sayısı ile ya da dosya sonunu belirtmek üzere sıfır ile dönmelidir. Hata durumunu belirtmek için  <code>-1</code> de döndürülebilir.
    </para>
    <para>
     Çereze veri yazan işlev şöyle bildirilmelidir:
    </para>
    <literallayout class="monospaced"><code>ssize_t <replaceable>yazıcı</replaceable> (void *<replaceable>çerez</replaceable>, const char *<replaceable>tampon</replaceable>, size_t <replaceable>boyut</replaceable>)</code>
</literallayout>
    <para>
     Bu işlev <function>write</function> işlevine çok benzer; bkz. <xref linkend="glibc-I-O-Primitives"/>. İşlev, <replaceable>tampon</replaceable> tamponuna <replaceable>boyut</replaceable> bayt aktarmalı ve yazılan bayt sayısı ile dönmelidir. Hata durumunu belirtmek için <code>-1</code> de döndürülebilir.
    </para>
    <para>
     Çerez üzerinde konumlama yapan işlev şöyle bildirilmelidir:
    </para>
    <literallayout class="monospaced"><code>ssize_t <replaceable>konumlayıcı</replaceable> (void *<replaceable>çerez</replaceable>, off64_t *<replaceable>konum</replaceable>, int <replaceable>nereden</replaceable>)</code>
</literallayout>
    <para>
     Bu işlev için <replaceable>konum</replaceable> ve <replaceable>nereden</replaceable> bağımsız değişkenleri <function>fgetpos</function> işlevindeki gibi yorumlanır; bkz. <xref linkend="glibc-Portable-Positioning"/>.
    </para>
    <para>
     Konumlama işleminden sonra, işlev sonuçlanan dosya konumunu dosyanın başlangıcına göre <replaceable>konum</replaceable> bağımsız değişkeninde saklamalıdır. İşlev başarı durumunda <code>0</code> ve hata durumunda <code>-1</code> döndürmelidir.
    </para>
    <para>
     Akımı kapatırken çerez üzerinde uygulanacak temizlik işlemlerini yapacak işlev şöyle tanımlanmalıdır:
    </para>
    <literallayout class="monospaced"><code>int <replaceable>temizlikçi</replaceable> (void *<replaceable>çerez</replaceable>)</code>
</literallayout>
    <para>
     İşlev başarı durumunda <code>0</code> ve hata durumunda <code>-1</code> döndürmelidir.
    </para>
    <csynopsis>
     <indexterm linkend="glibc-tp" xml:id="glibc-tp-cookie_read_function_t"><primary>cookie_read_function_t</primary></indexterm>
     <csproto type="veri türü">
      <csname><function>cookie_read_function_t</function></csname>
     </csproto>
     <header>&cookie_io_functions_t.h;</header>
     <para>
      Özel bir akımın gerektirdiği okuyucu işlevin veri türüdür. İşlev yukarıdaki gibi tanımlanırsa, bu, o işlevin veri türü olacaktır.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-tp" xml:id="glibc-tp-cookie_write_function_t"><primary>cookie_write_function_t</primary></indexterm>
     <csproto type="veri türü">
      <csname><function>cookie_write_function_t</function></csname>
     </csproto>
     <header>&cookie_io_functions_t.h;</header>
     <para>
      Özel bir akımın gerektirdiği yazıcı işlevin veri türüdür.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-tp" xml:id="glibc-tp-cookie_seek_function_t"><primary>cookie_seek_function_t</primary></indexterm>
     <csproto type="veri türü">
      <csname><function>cookie_seek_function_t</function></csname>
     </csproto>
     <header>&cookie_io_functions_t.h;</header>
     <para>
      Özel bir akımın gerektirdiği konumlayıcı işlevin veri türüdür.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-tp" xml:id="glibc-tp-cookie_close_function_t"><primary>cookie_close_function_t</primary></indexterm>
     <csproto type="veri türü">
      <csname><function>cookie_close_function_t</function></csname>
     </csproto>
     <header>&cookie_io_functions_t.h;</header>
     <para>
      Özel bir akımın gerektirdiği kapatma işlevinin veri türüdür.
     </para>
    </csynopsis>
   </sect2>
  </sect1>
 </chapter>

 <chapter xml:id="glibc-Formatted-Messages">
  <title>Biçimli İletiler</title>
  <titleabbrev>Tamamen biçimlenmiş iletilerin basılması.</titleabbrev>
   <preliminary>
    <para>
     <indexterm linkend="glibc-cp"><primary>biçimli iletiler</primary></indexterm>
     System V tabanlı sistemlerde uygulamalar (özellikle sistem araçları) <function>fmtmsg</function> işlevini kullanarak iletilerini daima belli bir biçimde basar. Bu tek biçimlilik kimi zaman iletileri yorumlayan kullanıcılara yardımcı olur ve <function>fmtmsg</function> işlevinin belirli biçimine bağlı sınamalarla yazılımcıyı daha az sayıda gereksinimi karşılamak zorunda bırakır.
    </para>
   </preliminary>
   <sect1 xml:id="glibc-Printing-Formatted-Messages">
    <title>Biçimli İletilerin Basılması</title>
    <titleabbrev><code>fmtmsg</code> işlevi.</titleabbrev>
    <para>
     İletiler standart hataya ve/veya konsola basılabilir. Hedefi seçerken yazılımcı <function>fmtmsg</function> işlevinin <parameter>classification</parameter> bağımsız değişkeninde aşağıdaki iki değeri kullanabilir, isterse bitsel VEYAlayarak bunları birleştirebilir:
    </para>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-MM_PRINT"><primary>MM_PRINT</primary></indexterm>
     <csproto type="sabit">
      <csname><function>MM_PRINT</function></csname>
     </csproto>
     <header>&fmtmsg.h;</header>
     <para>
      İleti standart hatada gösterilir.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-MM_CONSOLE"><primary>MM_CONSOLE</primary></indexterm>
     <csproto type="sabit">
      <csname><function>MM_CONSOLE</function></csname>
     </csproto>
     <header>&fmtmsg.h;</header>
     <para>
      İleti sistem konsolunda gösterilir.
     </para>
    </csynopsis>
    <para>
     Sistemdeki hata kaynakları <function>fmtmsg</function> işlevinin <parameter>classification</parameter> bağımsız değişkeninde aşağıdaki değerler bitsel VEYAlanarak belirtilebilir:
    </para>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-MM_HARD"><primary>MM_HARD</primary></indexterm>
     <csproto type="sabit">
      <csname><function>MM_HARD</function></csname>
     </csproto>
     <header>&fmtmsg.h;</header>
     <para>
      Sorunun kaynağı donanımdır.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-MM_SOFT"><primary>MM_SOFT</primary></indexterm>
     <csproto type="sabit">
      <csname><function>MM_SOFT</function></csname>
     </csproto>
     <header>&fmtmsg.h;</header>
     <para>
      Sorunun kaynağı yazılımdır.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-MM_FIRM"><primary>MM_FIRM</primary></indexterm>
     <csproto type="sabit">
      <csname><function>MM_FIRM</function></csname>
     </csproto>
     <header>&fmtmsg.h;</header>
     <para>
      Sorunun kaynağı aygıt yazılımıdır.
     </para>
    </csynopsis>
    <para>
     <function>fmtmsg</function> işlevinin <parameter>classification</parameter> bağımsız değişkeninde belirtilebilecek üçüncü eleman sorunun saptandığı sistem parçalarını açıklamakta kullanılır. Bu aşağıdaki değerlerden sadece biri kullanılarak yapılır:
    </para>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-MM_APPL"><primary>MM_APPL</primary></indexterm>
     <csproto type="sabit">
      <csname><function>MM_APPL</function></csname>
     </csproto>
     <header>&fmtmsg.h;</header>
     <para>
      Sorun uygulama tarafından saptandı.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-MM_UTIL"><primary>MM_UTIL</primary></indexterm>
     <csproto type="sabit">
      <csname><function>MM_UTIL</function></csname>
     </csproto>
     <header>&fmtmsg.h;</header>
     <para>
      Sorun başka bir uygulama tarafından saptandı.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-MM_OPSYS"><primary>MM_OPSYS</primary></indexterm>
     <csproto type="sabit">
      <csname><function>MM_OPSYS</function></csname>
     </csproto>
     <header>&fmtmsg.h;</header>
     <para>
      Sorun işletim sistemi tarafından saptandı.
     </para>
    </csynopsis>
    <para>
     <function>fmtmsg</function> işlevinin <parameter>classification</parameter> bağımsız değişkeninde belirtilebilecek son eleman bu iletinin sonucunu gösterir. Aşağıdaki değerlerden sadece biri kullanılabilir:
    </para>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-MM_RECOVER"><primary>MM_RECOVER</primary></indexterm>
     <csproto type="sabit">
      <csname><function>MM_RECOVER</function></csname>
     </csproto>
     <header>&fmtmsg.h;</header>
     <para>
      Kurtarılabilir hata.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-MM_NRECOV"><primary>MM_NRECOV</primary></indexterm>
     <csproto type="sabit">
      <csname><function>MM_NRECOV</function></csname>
     </csproto>
     <header>&fmtmsg.h;</header>
     <para>
      Kurtarılamayacak hata.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-fn" xml:id="glibc-fn-fmtmsg"><primary>fmtmsg</primary></indexterm>
     <indexterm linkend="glibc-cp" xml:id="glibc-cp-fmtmsg"><primary>biçimli iletiler</primary><secondary>oluşturulması</secondary></indexterm>
     <csproto type="işlev">
      <csname><type>int</type><function>fmtmsg</function></csname>
      <csparam><type>long&nbsp;int</type><parameter>classification</parameter></csparam>
      <csparam><ptr>const&nbsp;char</ptr><parameter>label</parameter></csparam>
      <csparam><type>int</type><parameter>severity</parameter></csparam>
      <csparam><ptr>const&nbsp;char</ptr><parameter>text</parameter></csparam>
      <csparam><ptr>const&nbsp;char</ptr><parameter>action</parameter></csparam>
      <csparam><ptr>const&nbsp;char</ptr><parameter>tag</parameter></csparam>
     </csproto>
     <header>&stdio.h;</header>
     <conceptlist>
      <concept>&mtsafe;</concept>
      <concept>&asunsafe; &lock;</concept>
      <concept>&acsafe;</concept>
     </conceptlist>
     <para>
      Bağımsız değişkenleriyle açıklanan bir iletiyi <parameter>classification</parameter> bağımsız değişkeninde belirtilen aygıt(lar) üzerinde görüntüler. <parameter>label</parameter> bağımsız değişkeni ileti kaynağını tanımlar. Dizge iki sütunu oluşturan iki parçadan oluşur. Birinci parça 10 karakterden, ikinci parça ise 14 karakterden uzun olamaz.  <parameter>text</parameter> bağımsız değişkeni hata durumunu, <parameter>action</parameter> bağımsız değişkeni hatadan kurtulmak için olası adımları açıklar, <parameter>tag</parameter> bağımsız değişkeni ise daha fazla bilgi edinilebilecek çevrimiçi belgelendirmeye bağ içerir. <parameter>label</parameter> değerini ve eşsiz kimlik numarası içermelidir.
    </para>
    <para>
     Bağımsız değişkenlerin her biri istenirse yok sayılabilecek özel bir değer alabilir. Bu değerler için kullanılabilecek simgesel isimler:
    </para>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-MM_NULLLBL"><primary>MM_NULLLBL</primary></indexterm>
     <csproto type="makro">
      <csname><function>MM_NULLLBL</function></csname>
     </csproto>
     <header>&fmtmsg.h;</header>
     <para>
      <parameter>label</parameter> bağımsız değişkeni yok sayılır.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-MM_NULLSEV"><primary>MM_NULLSEV</primary></indexterm>
     <csproto type="makro">
      <csname><function>MM_NULLSEV</function></csname>
     </csproto>
     <header>&fmtmsg.h;</header>
     <para>
      <parameter>severity</parameter> bağımsız değişkeni yok sayılır.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-MM_NULLMC"><primary>MM_NULLMC</primary></indexterm>
     <csproto type="makro">
      <csname><function>MM_NULLMC</function></csname>
     </csproto>
     <header>&fmtmsg.h;</header>
     <para>
      <parameter>classification</parameter> bağımsız değişkeni yok sayılır. Dolaylı olarak hiçbir şey basılmamasını sağlar.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-MM_NULLTXT"><primary>MM_NULLTXT</primary></indexterm>
     <csproto type="makro">
      <csname><function>MM_NULLTXT</function></csname>
     </csproto>
     <header>&fmtmsg.h;</header>
     <para>
      <parameter>text</parameter> bağımsız değişkeni yok sayılır.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-MM_NULLACT"><primary>MM_NULLACT</primary></indexterm>
     <csproto type="makro">
      <csname><function>MM_NULLACT</function></csname>
     </csproto>
     <header>&fmtmsg.h;</header>
     <para>
      <parameter>action</parameter> bağımsız değişkeni yok sayılır.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-MM_NULLTAG"><primary>MM_NULLTAG</primary></indexterm>
     <csproto type="makro">
      <csname><function>MM_NULLTAG</function></csname>
     </csproto>
     <header>&fmtmsg.h;</header>
     <para>
      <parameter>tag</parameter> bağımsız değişkeni yok sayılır.
     </para>
    </csynopsis>
    <para>
     Bu alanların yok sayılması için başka bir yöntem de çıktının standart hataya gönderilmesinde kullanılabilir. Bu yöntemde davranışı aşağıda açıklanan ortam değişkenleri belirler.
    </para>
    <para>
     <parameter>severity</parameter> bağımsız değişkeni aşağıdaki değerlerden biri olabilir:
    </para>
    <csynopsis>
     <indexterm linkend="glibc-cp" xml:id="glibc-cp-MM_NOSEV"><primary>önem derecesi</primary></indexterm>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-MM_NOSEV"><primary>MM_NOSEV</primary></indexterm>
     <csproto type="sabit">
      <csname><function>MM_NOSEV</function></csname>
     </csproto>
     <header>&fmtmsg.h;</header>
     <para>
      Hiçbir şey basılmaz, <varname>MM_NULLSEV</varname> ile aynıdır.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-MM_HALT"><primary>MM_HALT</primary></indexterm>
     <csproto type="sabit">
      <csname><function>MM_HALT</function></csname>
     </csproto>
     <header>&fmtmsg.h;</header>
     <para>
      Hata uygulamanın çökmesine sebep oluyor. <code>HALT</code> ile bildirilir.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-MM_ERROR"><primary>MM_ERROR</primary></indexterm>
     <csproto type="sabit">
      <csname><function>MM_ERROR</function></csname>
     </csproto>
     <header>&fmtmsg.h;</header>
     <para>
      Uygulama ölümcül olmayan bir hata saptadı. <code>ERROR</code> ile bildirilir.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-MM_WARNING"><primary>MM_WARNING</primary></indexterm>
     <csproto type="sabit">
      <csname><function>MM_WARNING</function></csname>
     </csproto>
     <header>&fmtmsg.h;</header>
     <para>
      Uygulama olağan dışı, hata olmayan bir durum algıladı. <code>WARNING</code> ile bildirilir.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-MM_INFO"><primary>MM_INFO</primary></indexterm>
     <csproto type="sabit">
      <csname><function>MM_INFO</function></csname>
     </csproto>
     <header>&fmtmsg.h;</header>
     <para>
      Bilgilendirici ileti. <code>INFO</code> ile bildirilir.
     </para>
    </csynopsis>
    <para>
     Bu beş makronun değeri <code>0</code> ile <code>4</code> arasındadır.  <varname>SEV_LEVEL</varname> ortam değişkeni kullanılarak ya da <function>addseverity</function> işleviyle basılacak dizgeye karşılık olarak başka önem dereceleri de belirlenebilir. Bu konu <xref linkend="glibc-Adding-Severity-Classes"/> bölümünde açıklanmıştır.
    </para>
    <para>
     Hiçbir bağımsız değişken yok sayılmadığında çıktı şuna benzer:
    </para>
    <literallayout class="monospaced"><code><replaceable>isim</replaceable>: <replaceable>önem-dizgesi</replaceable>: <replaceable>metin</replaceable>
TO FIX: <replaceable>eylem</replaceable> <replaceable>etiket</replaceable></code>
</literallayout>
    <para>
     İki nokta üstüste, satır sonu ve <code>TO FIX</code> (DÜZELTMEK İÇİN) dizgesi üretilmesini sağlayan bağımsız değişkenler yok sayılarak görüntülenmeyebilir.
    </para>
    <para>
     Bu işlev X/Open Taşınabilirlik Kılavuzunda belirtilmiştir. Ayrıca System V'den türetilmiş tüm sistemlerde bulunur.
    </para>
    <para>
     İşlevin dönüş değerleri:
    </para>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-MM_OK"><primary>MM_OK</primary></indexterm>
     <csproto type="sabit">
      <csname><function>MM_OK</function></csname>
     </csproto>
     <header>&fmtmsg.h;</header>
     <para>
      Hata yoksa döner.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-MM_NOMSG"><primary>MM_NOMSG</primary></indexterm>
     <csproto type="sabit">
      <csname><function>MM_NOMSG</function></csname>
     </csproto>
     <header>&fmtmsg.h;</header>
     <para>
      Standart hataya yazılamazsa döner.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-MM_NOCON"><primary>MM_NOCON</primary></indexterm>
     <csproto type="sabit">
      <csname><function>MM_NOCON</function></csname>
     </csproto>
     <header>&fmtmsg.h;</header>
     <para>
      Konsola yazılamazsa döner.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-MM_NOTOK"><primary>MM_NOTOK</primary></indexterm>
     <csproto type="sabit">
      <csname><function>MM_NOTOK</function></csname>
     </csproto>
     <header>&fmtmsg.h;</header>
     <para>
      Tüm çıktılamanın başarısız olduğu bu durumda ayrıca bir bağımsız değişkenin değeri yanlışsa bu bilgi de döner.
     </para>
    </csynopsis>
   </csynopsis>
   <para>
    <function>fmtmsg</function> işlevinin davranışını açıklayan iki ortam değişkeni vardır:
   </para>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-MSGVERB"><primary>MSGVERB</primary></indexterm>
    <csproto type="ortam">
     <csname><function>MSGVERB</function></csname>
    </csproto>
    <para>
     Çıktının gerçekte standart hataya (konsola değil) gönderilmesinde kullanılır. Beş alanın herbiri açıkça etkinleştirilir. Bunu yapmak için, işlev çağrılmadan önce ortam değişkeni aşağıdaki gibi düzenlenir:
    </para>
    <literallayout class="monospaced"><code>MSGVERB=<replaceable>anahtar-sözcük</replaceable>[:<replaceable>anahtar-sözcük</replaceable>[:…]]</code>
</literallayout>
    <para>
     Geçerli <replaceable>anahtar-sözcük</replaceable>ler <code>label</code> (isim), <code>severity</code> (önem), <code>text</code> (metin), <code>action</code> (eylem) ve <code>tag</code> (etiket) sözcükleridir. Ortam değişkeni yoksa veya boşsa, desteklenmeyen bir anahtar sözcük kullanılmışsa ya da değer iletinin bir parçası olarak geçersizse iletinin hiçbir kısmı maskelenmez.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-SEV_LEVEL"><primary>SEV_LEVEL</primary></indexterm>
    <csproto type="ortam">
     <csname><function>SEV_LEVEL</function></csname>
    </csproto>
    <para>
     Bu değişken ve <function>fmtmsg</function> işlevinin davranış değiştirmesi X/Open Taşınabilirlik Kılavuzunda belirtilmemiştir.  Yine de System V sistemlerinde bulunmaktadır. Yeni önem derecelerini belirtmekte kullanılır.  Öntanımlı olarak yukarıda açıklanan beş önem derecesi vardır. Diğer sayısal değerlerler <function>fmtmsg</function> işlevinin bir şey basmasını sağlamaz.
    </para>
    <para>
     Kullanıcı <code>SEV_LEVEL</code> değişkenini <function>fmtmsg</function> işlevini çağırmadan önce şöyle tanımlayabilir:
    </para>
    <literallayout class="monospaced"><code>SEV_LEVEL=[<replaceable>açıklama</replaceable>[:<replaceable>açıklama</replaceable>[:…]]]</code>
</literallayout>
    <para>
     <function>fmtmsg</function> işlevine yapılan ilk çağrıdan önceki süreç ortamında, <replaceable>açıklama</replaceable> alanları aşağıdaki değerleri alabilir:
    </para>
    <literallayout class="monospaced"><replaceable>önem-sözcüğü</replaceable>, <replaceable>seviye</replaceable>, <replaceable>basılacak-dizge</replaceable>
</literallayout>
    <para>
     <replaceable>önem-sözcüğü</replaceable> parçası <function>fmtmsg</function> tarafından kullanılmaz ama yine de vardır. <replaceable>seviye</replaceable> bir numaranın dizgesel gösterimidir. Sayısal değer 4’ten büyük olmalıdır. Bu değer, <function>fmtmsg</function> işlevinin bu önem derecesini seçmesini sağlayan <parameter>severity</parameter> bağımsız değişkeninde kullanılır. Öntanımlı önem derecelerinin yerini alacak bir değer mümkün değildir. <replaceable>basılacak-dizge</replaceable> parçası ise <function>fmtmsg</function> tarafından bu önem derecesi işleme alındığında gösterilecek iletidir (yukarıya bakılırsa, <function>fmtmsg</function> işlevinin sayısal değeri değil, onun dizge karşılığını bastığı görülür).
    </para>
   </csynopsis>
  </sect1>

  <sect1 xml:id="glibc-Adding-Severity-Classes">
   <title>Önem Derecelerinin Eklenmesi</title>
   <titleabbrev>Yeni önem sınıflarının eklenmesi.</titleabbrev>
   <para>
    <indexterm linkend="glibc-cp"><primary>önem derecesi</primary></indexterm>
    <varname>SEV_LEVEL</varname> ortam değişkenini kullanmanın yanında yeni önem derecelerini belirlemek için bir olasılık daha vardır. Bu yöntem çalışan bir yazılım içinde başka önem derecelerinden bahsedilebilmesini kolaylaştırır.
    <function>setenv</function> veya <function>putenv</function> işlevleri ortam değişkenlerini tanımlamakta kullanılabilir ama bu zahmetlidir.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-addseverity"><primary>biçimli iletiler</primary><secondary>önem derecesinin eklenmesi</secondary></indexterm>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-addseverity"><primary>addseverity</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>addseverity</function></csname>
     <csparam><type>int</type><parameter>severity</parameter></csparam>
     <csparam><ptr>const&nbsp;char</ptr><parameter>string</parameter></csparam>
    </csproto>
    <header>&stdio.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&asunsafe; &heap; &lock;</concept>
     <concept>&acsafe; &lock; &mem;</concept>
    </conceptlist>
    <para>
     Bu işlev, <function>fmtmsg</function> işlevinin <parameter>severity</parameter> bağımsız değişkeni tarafından adreslenebilecek yeni önem derecesini belirlemekte kullanılır. <code>addseverity</code> işlevinin <parameter>severity</parameter> bağımsız değişkeni <function>fmtmsg</function> işlevinin <parameter>severity</parameter> bağımsız değişkeninin değeri ile eşleşmeli ve <parameter>string</parameter> de asıl iletide sayısal değer yerine gösterilecek dizge olmalıdır.
    </para>
    <para>
     <parameter>string</parameter> dizgesinin değeri <varname>NULL</varname> ise <parameter>severity</parameter> değerine karşılık olan önem derecesi kaldırılır.
    </para>
    <para>
     Öntanımlı önem derecelerini kaldırmak ya da değiştirmek mümkün değildir. <parameter>severity</parameter> bağımsız değişkeninde bu değerlerlerden biri kullanılarak yapılan <code>addseverity</code> çağrıları başarısız olacaktır.
    </para>
    <para>
     Görev yerine getirilmişse işlev <varname>MM_OK</varname> ile döner. <varname>MM_NOTOK</varname> dönmüşse bir şeyler yanlış gitmiş demektir. Bu durumda ya yeterli bellek ya da kaldırılmak istenen önem derecesi yoktur.
    </para>
    <para>
     X/Open Taşınabilirlik Kılavuzunda <function>fmtmsg</function> olduğu halde bu işlev yoktur. System V sistemlerinde vardır.
    </para>
   </csynopsis>
  </sect1>

  <sect1 xml:id="glibc-Example">
   <title><code>fmtmsg</code> ve <code>addseverity</code> kullanımı</title>
   <titleabbrev>Kullanım örneği.</titleabbrev>
   <para>
    Burada, bu kısımda bahsedilmiş olan <function>fmtmsg</function> ve <function>addseverity</function> işlevlerinin kullanımı örneklenmiştir. (Ç.N.: Bağımsız değişken değerleri değişmez alanları göstermesi açısından Türkçe’ye çevrilmiştir.).
   </para>
   <screen>#include &lt;fmtmsg.h>

int
main (void)
{
  addseverity (5, "BİLGİ2");
  fmtmsg (MM_PRINT, "tek1alan", MM_INFO, "metin2", "eylem2", "etiket2");
  fmtmsg (MM_PRINT, "UX:cat", 5, "sözdizimi geçersiz", "belgelere bakınız",
          "UX:cat:001");
  fmtmsg (MM_PRINT, "isim:foo", 6, "metin", "eylem", "etiket");
  return 0;
}
</screen>
   <para>
    <function>fmtmsg</function> işlevinin ikinci çağrısı genelde bu işlevin ağırlıkla kullanıldığı System V sistemlerinde görülen kullanımını örneklemektedir. Bu sistemin System V üzerinde nasıl çalıştığına burada kısaca değinmek iyi olacaktır. <parameter>label</parameter> alanındaki <code>UX:cat</code>, bir Unix uygulaması olan <uri xl:href="man1-cat"/>'in bir hata verdiğini belirtir. Devamında hatanın açıklaması ile <parameter>action</parameter> bağımsız değişkeni olarak <code>"belgeye bakınız"</code> değeri yer alır. Gerekiyorsa daha özel bir şeyler yazılabilirdi. <parameter>tag</parameter> alanı evvelce de bahsedildiği gibi <parameter>label</parameter> bağımsız değişkeninin değerine ek olarak eşsiz bir kimlik (burada '<code>001</code>') dizgesinden oluşur. GNU ortamında bu dizge uygulamanın info belgesindeki bu konuya karşılık düşen düğümünü içermeliydi.
   </para>
   <para>
    <varname>MSGVERB</varname> ve <varname>SEV_LEVEL</varname> ortam değişkenleri tanımlanmadan yazılım çalıştırılırsa aşağıdaki çıktı üretilir:
   </para>
   <screen>UX:cat: BİLGİ2: sözdizimi geçersiz
TO FIX: belgelere bakınız UX:cat:001
</screen>
   <para>
    Burada iletinin farklı alanlarının iki nokta üstüste ve '<code>TO FIX</code>' dizgesi ile birlikte nasıl basıldığı görülmektedir. Ama üç <function>fmtmsg</function> çağrısından yalnız biri bu çıktıyı üretti. İlk çağrı <parameter>label</parameter> bağımsız değişkeni doğru biçimde olmadığından hiçbir çıktı üretmedi. Dizge iki nokta üstüste ile ayrılmış iki alan içermeliydi (<xref linkend="glibc-Printing-Formatted-Messages"/>). Üçüncü <function>fmtmsg</function> çağrısı da sayısal değeri <code>6</code> olan önem derecesi tanımlanmadığı için çıktı üretmedi. Sayısal değeri <code>5</code> olan önem derecesi ayrıca ilk değer olarak tanımlanmadığı halde <function>addseverity</function> çağrısı ile tanımlanmış ve ikinci <function>fmtmsg</function> çağrısı yukarıdaki çıktıyı üretmiştir.
   </para>
   <para>
    Uygulamamız çalışırken ortamı <code>SEV_LEVEL=XXX,6,BİLGİ</code> ile değiştirirsek aşağıdaki sonucu alırız:
   </para>
   <screen>UX:cat: BİLGİ2: sözdizimi geçersiz
TO FIX: belgelere bakınız UX:cat:001
isim:foo: BİLGİ: metin
TO FIX: eylem etiket
</screen>
   <para>
    Böylece üçüncü <function>fmtmsg</function> çağrısı da çıktı üretti ve ortam değişkenindeki <code>BİLGİ</code> dizgesinin ileti içinde nasıl kullanıldığı da görülmüş oldu.
   </para>
   <para>
    Sadece gerekli alanlarla çıktı üretmek için <varname>MSGVERB</varname> ortam değişkenine <code>severity:label:action</code> (önem:isim:eylem) değeri atanırsa aşağıdaki çıktı alınır:
   </para>
   <screen>UX:cat: BİLGİ2
TO FIX: belgelere bakınız
isim:foo: BİLGİ
TO FIX: eylem
</screen>
   <para>
    Böylece, <function>fmtmsg</function> işlevinin <parameter>text</parameter> ve <parameter>tag</parameter> bağımsız değişkenleri kullanılmamış oldu. Dikkat edilirse <code>BİLGİ</code> ve <code>BİLGİ2</code> dizgelerinden sonra iki nokta üstüste kullanılmamıştır. Bu satırlarda bu dizgelerden sonra gösterilecek metin çıktılanmayacağından bu karakter kullanılmamıştır.
   </para>
  </sect1>
 </chapter>
</part>
