<?xml version="1.0" encoding="UTF-8"?>
<!-- ********************************************************************
        glibc/ch05.xml,v2.36, GFDL,LGPL, NBB, 2023
     ******************************************************************** -->
<part xml:id="glibc-String-and-Array-Utilities">
 <title>Diziler ve Dizgeler</title>
 <titleabbrev>Dizileri ve dizgeleri karşılaşırma ve kopyalama araçları.</titleabbrev>
 <preliminary>
  <para>
   Dizge (boş bayt sonlandırmalı bayt dizisi) işlemleri birçok uygulamanın önemli bir parçasını oluşturur. GNU C kütüphanesi kopyalama, birleştirme, karşılaştırma ve arama işlevleri de dahil olmak üzere geniş bir dizge işleme işlevleri kümesine sahiptir. Bu işlevlerin çoğu bellek erişimi ile ilgili olarak da çalışır; örneğin <function>memcpy</function> işlevi her çeşit dizi içeriğinin kopyalanmasında kullanılabilir.
  </para>
  <para>
   C yazılımcılığına yeni başlayanlar genelde bu işlevlerin benzerlerini yazarak "tekerleği yeniden icadeder". Halbuki bu zaman kütüphane işlevlerini öğrenmeye ayrılsa ve bunlar kullanılsa verimlilik, taşınabilirlik ve sürdürülebilirlik adına bir çok kazanç elde edilirdi.
  </para>
  <para>
   Örneğin bir dizge diğeriyle iki satır C kodu yazarak kolayca karşılaştırılabilir, fakat yerleşik <function>strcmp</function> işlevi kullanılırsa daha az hata oluşur. Ve bu kütüphane işlevleri yüksek derecede en iyilendiklerinden geliştirilen yazılım daha hızlı çalışır.
  </para>
 </preliminary>
 <chapter xml:id="glibc-Representation-of-Strings">
  <title>Dizgelerle İlgili Kavramlar</title>
  <titleabbrev>Temel kavramlarla giriş.</titleabbrev>
  <para>
   <indexterm linkend="glibc-cp"><primary>dizgeler</primary> <secondary>görünümleri</secondary></indexterm>
   Bu kısım, C yazılımcılığına yeni başlayanlar için dizge kavramlarının kısa bir özetini barındırır. Karakter dizgelerinin C'de nasıl temsil edildiği ve bilinen bazı tuzaklar hakkında bilgi verilecektir. Bunlar zaten biliniyorsa bu bölüm atlanabilir.
  </para>
  <para>
   <indexterm linkend="glibc-cp"><primary>boş gösterici</primary></indexterm>
   <indexterm linkend="glibc-cp"><primary>dizgeler</primary></indexterm>
   <indexterm linkend="glibc-cp"><primary>dizgeler</primary><secondary>geniş karakterli</secondary></indexterm>
   Bir <wordasword>dizge</wordasword>, <type>char</type> türünde baytlardan oluşan boş bayt ile sonlandırılmış bir dizidir. Fakat dizge değerli değişkenler genellikle <type>char&#160;*</type> türünden bir gösterici olarak bildirilir. Başka bir yerde, bir dizi değişkeninde, bir dizi sabitinde veya özdevimli olarak tahsis edilmiş bellekte saklanması gereken dizge metni için böyle değişkenlerde yeterli alan yoktur (bkz. <xref linkend="glibc-Memory-Allocation"/>). Gösterici değişkeninde seçilen bellek alanının adresi saklanabileceği gibi boş gösterici de saklanabilir. <wordasword>Boş gösterici</wordasword> herhangi bir yeri göstermez, bu nedenle göstermediği dizgeye başvurulmaya çalışılırsa hata oluşur.
  </para>
  <para>
   <indexterm xml:id="glibc-Representation-of-Stringsa" linkend="glibc-cp"><primary>geniş karakter</primary></indexterm>
   <indexterm xml:id="glibc-Representation-of-Stringsb" linkend="glibc-cp"><primary>geniş karakterli dizge</primary></indexterm>
   <indexterm xml:id="glibc-Representation-of-Stringsc" linkend="glibc-cp"><primary>geniş dizge</primary></indexterm>
   <wordasword>Çok baytlı karakter</wordasword>, yerelin kodlama şemasını kullanan tek bir karakteri temsil eden bir veya daha fazla bayt içeren bir dizidir; boş bayt her zaman boş karakteri temsil eder. <wordasword>Çok baytlı karakter dizgesi</wordasword><footnote><para>Ç.N.: Çok baytlı karakter dizgeleri, ASCII karakter kümesi kullanılan yerellerde geniş karakterleri birden fazla tek baytlı karakterle oluşturmaya yarayan (bizim kullanmadığımız) ikincil bir işlem olup ingilizcede bu işleme "combination" (birleştirme) denmektedir.</para><para>Örneğin, bizim klavyemizde de bulunan iki tek baytlı karakter ile "ñ" çok baytlı karakteri önce ~ ardından n tuşlanarak oluşturulabilmektedir. X klavye eşlemi olarak özellikle yabancıların kullanımı için ölü tuşlarla çalışan bir klavye eşlemimiz ("tr intl") bulunmaktadır. Örneğimizdeki ~ karakterinin o klavyede ölü tuş karşılığı bulunmakta bu tuşa basıdığında ekrana herhangi bir karakter çıktılanmamakta, hemen ardından n tuşuna basınca ekrana ñ karakteri çıktılanmaktadır.</para><para>Böyle oluşan karakterler geniş karakter değil çok baytlı karakterlerdir ve dizge ekleme, çıkarma işlemlerinde geniş karakterler gibi bunların da ortadan kesilmemesi gerekmektedir. Dizgelerin kırpılması söz konusu olduğunda sorun bu kadarla kalmayabilmektedir. Tamamı tek baytlı karakterlerden oluşsa bile bir insan adının kırpılması başka bir insan adı ile sonuçlanabilir...</para></footnote>, tamamen çok baytlı karakterlerden oluşan bir dizgedir. Bunun aksine, <wordasword>geniş dizge</wordasword>, elemanları <type>wchar_t</type> nesnelerinden oluşan boş geniş karakter sonlandırmalı bir dizidir. Bir <wordasword>dizge değişkeni</wordasword> <type>char&#160;*</type> türünde bir gösterici ile bildirilirken bir <wordasword>geniş dizge değişkeni</wordasword>, genellikle <type>wchar_t&#160;*</type> türünde bir gösterici ile bildirilir. Bkz. <xref linkend="glibc-Extended-Char-Intro"/>.
  </para>
  <para>
   <indexterm xml:id="glibc-Representation-of-Stringsd" linkend="glibc-cp"><primary>dizgeler</primary><secondary>boş karakter</secondary></indexterm>
   <indexterm xml:id="glibc-Representation-of-Stringse" linkend="glibc-cp"><primary>geniş dizgeler</primary><secondary>boş geniş karakter</secondary></indexterm>
   <indexterm xml:id="glibc-Representation-of-Stringsf" linkend="glibc-cp"><primary>boş karakter</primary><secondary>dizge sonlandıran</secondary></indexterm>
   <indexterm xml:id="glibc-Representation-of-Stringsg" linkend="glibc-cp"><primary>boş geniş karakter</primary><secondary>geniş dizge sonlandıran</secondary></indexterm>
   Uzlaşımsal olarak, <wordasword>boş karakter</wordasword>, bir dizgenin sonuna konan <code>'\0'</code> karakteridir, <wordasword>boş geniş karakter</wordasword> ise geniş karakterli dizgenin sonuna konan <code>L'\0'</code> karakteridir. Örneğin, <type>char&#160;*</type> türündeki <replaceable>p</replaceable> değişkeninin gösterdiği dizgenin sonunda boş karakter olup olmadığı <code>!*</code><replaceable>p</replaceable> veya <code>*<replaceable>p</replaceable>&#160;==&#160;'\0'</code> yazarak sınanabilir.
  </para>
  <para>
   Her ikisi de <code>0</code> tamsayısı ile temsil edilse de, boş bayt kavramsal olarak boş göstericiden oldukça farklıdır.
  </para>
  <para>
   <indexterm linkend="glibc-cp"><primary>dizgeler</primary><secondary>dizge sabitler</secondary></indexterm>
   <wordasword>Dizge sabitler</wordasword> C yazılımlarında çift tırnaklar arasına alınmış çok baytlı dizgelerdir. İlk çift tırnak imi büyük harf L ile öncelenirse (<code>L&quot;foo&quot;</code> gibi) dizge sabit, <wordasword>geniş dizge sabiti</wordasword> haline gelir. Dizge sabitler arasında, dizge birleştirme işlemleri de yaplabilir: <code>"a" "b"</code> ile <code>"ab"</code> aynıdır. Geniş dizgeler için <code>L"a" L"b"</code> veya <code>L"a" "b"</code> kullanılabilir. GNU C derleyicisi dizge sabitler üzerinde değişiklik yapılmasına izin vermez, çünkü sabitler salt-okunur bölgede tutulur.
  </para>
  <para>
   Ayrıca <code>const</code> ile bildirilen diziler de değiştirilemez. Değiştirilmesi tasarlanmayan dizge göstericilerini <type>const&#160;char&#160;*</type> türünde bildirmek genellikle daha iyidir, çünkü bu genellikle C derleyicisinin yanlışlıkla yapılan değişiklikleri algılamasına ve yazılımda dizgeyle ne yapılmak istendiğine dair bir miktar belge sağlanmasına olanak tanır.
  </para>
  <para>
   Bayt dizisi için tahsis edilmiş belleğin miktarı dizgenin sonunu belirleyen dizideki boş karaktere kadar bayt sayısıdır. Bu belgede <wordasword>tahsis edilen boyut</wordasword> denilince daima dizi için tahsis edilen belleğin toplam miktarından, <wordasword>uzunluk</wordasword> denilince de sondaki boş bayt hariç bayt sayısından bahsediliyor olacaktır.
   <indexterm xml:id="glibc-Representation-of-Stringsh" linkend="glibc-cp"><primary>dizgeler</primary><secondary>uzunluk</secondary></indexterm>
   <indexterm xml:id="glibc-Representation-of-Stringsi" linkend="glibc-cp"><primary>dizgeler</primary><secondary>tahsis edilen boyut</secondary></indexterm>
   <indexterm xml:id="glibc-Representation-of-Stringsj" linkend="glibc-cp"><primary>dizgeler</primary> <secondary>dizge boyutu</secondary></indexterm>
   <indexterm xml:id="glibc-Representation-of-Stringsk" linkend="glibc-cp"><primary>dizgeler</primary><secondary>dizge uzunluğu</secondary></indexterm>
  </para>
  <para>
   Namlı yazılım hatalarından biri bir dizgeye tahsis edilen yere sığacağından daha fazla bayt koymaya çalışılmasıdır. Kodu yazarken, yeri önceden tahsis edilmiş bir dizi içine dizge veya bayt taşırken metnin uzunluğu sürekli denetlenmeli, dizinin tahsis edilmiş yerin dışına taşmamasına dikkat edilmelidir. Kütüphane işlevlerinin çoğu bu işlemi sizin yerinize <emphasis>yapmaz</emphasis>! Dizgenin sonunu belirleyecek olan boş bayt için de yer tahsisi gerektiği unutulmamalıdır.
  </para>
  <para>
   <indexterm xml:id="glibc-Representation-of-Stringsl" linkend="glibc-cp"><primary>dizgeler</primary><secondary>tek baytlı - çok baytlı</secondary></indexterm>
   Genellikle, dizgeler, her baytı tek bir karakteri ifade eden bayt dizileridir. Bu özellik, dizgenin tek baytlık karakter kodlaması ile yazılması halinde geçerlidir. Eğer çok baytlı karakter kodlaması kullanılmışsa bu değişir. (Karakter kodlamaları için bilgi <xref linkend="glibc-Extended-Char-Intro"/> bölümünde bulunabilir.) Yazılım geliştirme arayüzü bakımından bu iki dizge çeşidi arasında bir fark yoktur; yazılımcı bu özelliği bilmeli, tek baytlı ve çok baytlı dizgeleri buna göre yorumlamalıdır.
  </para>
  <para>
   Ancak arayüz için bir farklılık oluşturmayan bayt temelli işlevlerin kullanımı kimi zaman zorlaşır. Bu işlevlerin sayaç bağımsız değişkenleri baytları saydığından <code>memcpy</code> işlevine yapılan bir çağrı çok baytlı bir karakterin ortadan kesilmesine ve tampona eksik (dolayısıyla kullanışsız) bayt dizisinin konulmasına sebep olabilir.
  </para>
  <para>
   <indexterm xml:id="glibc-Representation-of-Stringsm" linkend="glibc-cp"><primary>dizgeler</primary><secondary>geniş karakterli</secondary></indexterm>
   Bu sorunlardan kurtulmak için &isoc; standardının daha sonraki sürümlerinde <wordasword>geniş karakterler</wordasword> (<xref linkend="glibc-Extended-Char-Intro"/>) ile çalışan ikinci bir işlev kümesi daha tanımlandı. Her geniş karakter kurallara uygun ve yorumlanabilir olduğundan tek baytlı karakter dizileriyle çalışmada karşılaşılan sorunlar bu işlevlerle ortadan kalktı. Bu geniş karakterli dizgelerde kesme işleminin sorunsuz olacağı anlamına gelmez. Normalde abece temelli diller (normalleştirilmemiş metinler hariç) için sorun yoktur, ancak hece temelli dillerde (Çince gibi) mantıksal birimler çok sayıda geniş karakterden oluştuğundan bu sorun hala devam etmektedir. Bu, C&nbsp;kütüphanesi işlevlerinin çözmek için tasarlanmadığı daha yüksek düzeyde bir sorundur. Bu kadarı bile yine de iyidir, çünkü en azından geçersiz bayt dizileri oluşmamaktadır. Ayrıca, yüksek seviyeli işlevler geniş karakterlerle çok baytlı karakterlerden daha kolay çalışır. Bir metin basitçe kopyalamaktan daha fazlasını gerektirebildiğinden dahili olarak geniş karakter kullanımı tercih edilmelidir.
  </para>
  <para>
   Bu kısmın kalanında geniş dizgeler üzerinde işlem yapan işlevlere paralel olarak, aralarında hemen hemen tam bir eşdeğer kullanılabilirlik olduğundan, tek baytlı karakter dizileri üzerinde işlem yapan işlevlere de değinilecektir.
  </para>
 </chapter>

 <chapter xml:id="glibc-String-Array-Conventions">
  <title>Dizi ve Dizge Uzlaşımları</title>
  <titleabbrev>Bir dizge işlevini mi yoksa bir dizi işlevini mi kullanmalı.</titleabbrev>
  <para>
   Bu kısımda hem sıradan diziler veya bellek dilimleri üzerinde çalışan işlevler hem de tek baytlı karakter dizileri ve geniş dizgelere özgü işlevler açıklanmıştır.
  </para>
  <para>
   Bellek dilimleri üzerinde işlem yapan işlevlerin isimleri <code>mem</code> ve  <code>wmem</code> ile başlar (<function>memcpy</function> ve <function>wmemcpy</function> gibi) ve üzerinde çalışacağı bellek diliminin boyutunu (sırasıyla bayt ve geniş karakter sayısı olarak) belirleyen bir bağımsız değişken alır. Bu işlevlerin dizi bağımsız değişkenleri ve dönüş değerleri <type>void&nbsp;*</type> veya <type>wchar_t&nbsp;*</type> türündendir. İsimleri <code>mem</code> ile başlayan işlevler ile kullanılan dizi elemanları birer bayttan oluştuğundan bu işlevlere her çeşit gösterici aktarılabileceği gibi, <parameter>size</parameter> (boyut) bağımsız değişkeninin değeri hesaplanırken <operator>sizeof</operator> işleci kullanılabilir. İsimleri  <code>wmem</code>  ile başlayan işlevlerin bağımsız değişkenleri ise <type>wchar_t&nbsp;*</type> türünde olmalıdır. Bu işlevler yalnızca bu türden diziler için kullanışlıdır.
  </para>
  <para>
   Özellikle dizgeler ve geniş dizgelerle çalışan işlevlerin isimleri ise sırasıyla <code>str</code> ve <code>wcs</code> ile başlar (<function>strcpy</function> ve <function>wcscpy</function> gibi) ve bir uzunluk bağımsız değişkeni almak yerine dizgeyi sonlandıran "boş bayt"a veya "boş geniş karakter"e bakar. (Bu işlevlerin bazıları bir azami uzunluk değeri alır ve ayrıca "boş bayt"la veya "boş geniş karakter"le vaktinden önce sonlandırma olup olmadığını da sınar.) Bu işlevlerin dizi bağımsız değişkenleri ve dönüş değerleri <type>char&nbsp;*</type> ve <type>wchar_t&nbsp;*</type> türünde olmalı ve dizi elemanları sırasıyla "baytlar"dan veya "geniş karakterler"den oluşmalıdır.
  </para>
  <para>
   Çoğu durumda bir işlevin hem <code>mem</code> hem de <code>str</code>/<code>wcs</code> sürümleri vardır. Duruma bağlı olarak her birinin kullanılması gerekebilir. Bir yazılım dizileri veya bellek dilimlerini değiştiriyorsa daima <code>mem</code> işlevleri kullanılmalıdır. Diğer taraftan, dizgeler üzerinde işlem yaparken dizgenin uzunluğu bilinmiyorsa, <code>str</code>/<code>wcs</code> işlevlerini kullanmak daha uygun olur. Boyutları bilinen geniş karakter dizilerinde <code>wmem</code> işlevleri kullanılmalıdır.
  </para>
  <para>
   <indexterm linkend="glibc-cp"><primary>wint_t</primary></indexterm>
   <indexterm linkend="glibc-cp"><primary>bağımsız değişken terfileri</primary></indexterm>
   Bellek ve dizge işlevlerinin bazıları bağımsız değişken olarak tek karakter alır. İşlevdeki bağımsız değişken <type>int</type> türünde bildirildiğinde, <type>char</type> türünden bir değer bağımsız değişken olarak kullanıldığında özdevinimli olarak <type>int</type> türünden bir değere dönüştürülür. Geniş karakter işlevleri için de benzer bir durum sözkonusudur; tek geniş karakter için bağımsız değişken <type>wchar_t</type> değil <type>wint_t</type> türündedir. Ancak bir çok gerçekleme <type>wchar_t</type> türü yeterince geniş olduğundan özdevinimli dönüşüme gerek duymaz. &isoc; standardı belli türün seçilmesini gerektirmediğinden <type>wint_t</type> türü kullanılmıştır.
  </para>
 </chapter>

 <chapter xml:id="glibc-String-Length">
  <title>Dizge Uzunluğu</title>
  <titleabbrev>Bir dizgenin uzunluğunun saptanması.</titleabbrev>
  <para>
   <indexterm linkend="glibc-pg"><primary>string.h</primary></indexterm>
   Dizgenin (tek baytlı karakter dizisinin) uzunluğu <function>strlen</function> işlevi kullanılarak alınabilir. Bu işlev &string.h; başlık dosyasında bildirilmiştir.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-strlen"><primary>strlen</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-strlen"><primary>dizgeler</primary><secondary>dizge uzunluğu</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>size_t</type><function>strlen</function></csname>
    <csparam><ptr>const&#160;char</ptr><parameter>s</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <code>strlen</code>  işlevi boş bayt sonlandırmalı <parameter>s</parameter> dizgesinin bayt cinsinden uzunluğu ile döner. (Başka bir deyişle dizi içindeki boş baytın konumu ile döner.)
   </para>
   <example>
    <screen>strlen ("hello, world")
    ⇒ 12
</screen>
    <para>
     Bir diziye uygulandığında <code>strlen</code> işlevi burada saklanan dizgenin uzunluğu ile döner, diziye tahsis edilen boyutla değil. Diziye tahsis edilen boyut <operator>sizeof</operator> işleci ile öğrenilebilir:
    </para>
<screen>char string[32] = "hello, world";
sizeof (string)
    ⇒ 32
strlen (string)
    ⇒ 12
</screen>
    <para>
     Yalnız dikkatli olunmalıdır, <parameter>string</parameter> bir gösterici değil tek baytlı karakter dizisi olmalıdır. Yoksa karakter dizisinin değil göstericinin uzunluğu döner:
    </para>
<screen>char string[32] = "hello, world";
char *ptr = string;
sizeof (string)
    ⇒ 32
sizeof (ptr)
    ⇒ 4  /* <replaceable>(göstericilerin 4 bayt olduğu bir makine üzerinde)</replaceable> */
</screen>
    </example>
    <para>
     Dizge bağımsız değişken alan işlevlerle çalışırken bu yanlışı yapmak çok kolaydır; çünkü bu işlevlerin bağımsız değişkenleri daima göstericidir, dizi değildir.
    </para>
    <para>
     Ayrıca, tek baytlı karakterlerle çalışan bu işlevin çok baytlı karakter dizileri ile kullanıldığında dönen değerin dizgedeki karakterlerin sayısı olmadığına da dikkat etmek gerekir. Bu değer alınmak istenirse dizge önce geniş dizgeye dönüştürülmeli, ardından ya <function>wcslen</function> işlevi ya da aşağıdakine benzer bir kod kullanılmalıdır:
    </para>
    <example>
     <screen>/* <replaceable>Girdi</replaceable> <code>string</code> <replaceable>içinde.
   Uzunluk ise</replaceable> <code>n</code> <replaceable>bayt umuluyor.</replaceable>  */
{
  mbstate_t t;
  char *scopy = string;
  /* <replaceable>İlklendir.</replaceable>  */
  memset (&amp;t, '\0', sizeof (t));
  /* <replaceable>Karakter sayısını belirle.</replaceable>  */
  n = mbsrtowcs (NULL, &amp;scopy, strlen (scopy), &amp;t);
}
</screen>
   </example>
   <para>
    Bu zahmetli bir işlemdir. Karakter sayısına (bayt sayısı değil) ihtiyaç varsa geniş karakterlerle çalışmak daha iyidir.
   </para>
   <header>&string.h;</header>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-wcslen"><primary>wcslen</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-wcslen"><primary>geniş dizgeler</primary><secondary>dizge uzunluğu</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>size_t</type><function>wcslen</function></csname>
    <csparam><ptr>const&#160;wchar_t</ptr><parameter>ws</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <code>wcslen</code> işlevi, <function>strlen</function> işlevinin geniş karakterlerle çalışan karşılığıdır. Dönen değer, göstericisi <parameter>ws</parameter> olan geniş karakter dizgesinin geniş karakter sayısıdır. (Bu değer aynı zamanda boş geniş karakter sonlandırmalı <parameter>ws</parameter> dizisinin boş geniş karakteri içeren elemanının konumudur).
   </para>
   <para>
    Bir geniş karakter, çok baytlı karakter dizisi olmadığından dönen değer sadece dizideki bir konum değil, ayrıca geniş karakterlerin de sayısıdır.
   </para>
   <para>
    Bu işlev &isoc;90 standardının 1. düzeltmesinde tanımlıdır.
   </para>
   <header>&wchar.h;</header>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-strnlen"><primary>strnlen</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-strnlen"><primary>dizgeler</primary><secondary>dizge uzunluğu</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>size_t</type><function>strnlen</function></csname>
    <csparam><ptr>const&#160;char</ptr><parameter>s</parameter></csparam>
    <csparam><type>size_t</type><parameter>maxlen</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <parameter>maxlen</parameter> baytlık <parameter>s</parameter> dizgesi bir boş bayt içeriyorsa işlev <parameter>s</parameter> dizgesinin uzunluğu ile döner, içermiyorsa <parameter>maxlen</parameter> ile döner. Bu bakımdan bu işlev
    <code>(strlen (<parameter>s</parameter>) &lt; <parameter>maxlen</parameter> ? strlen (<parameter>s</parameter>) : <parameter>maxlen</parameter>)</code> ifadesine eşdeğer olsa da işlev daha verimlidir, çünkü <parameter>maxlen</parameter> ile belirtilen uzunluk <parameter>s</parameter> dizisinin uzunluğundan fazla olmadığı sürece <parameter>s</parameter> boş bayt ile sonlandırılmamış olsa bile işlev çalışır.
   </para>
   <example>
    <screen>char string[32] = "hello, world";
strnlen (string, 32)
    ⇒ 12
strnlen (string, 5)
    ⇒ 5
</screen>
   </example>
   <para>
    Bu işlev GNU oluşumudur.
   </para>
   <header>&string.h;</header>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-wcsnlen"><primary>wcsnlen</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-wcsnlen"><primary>geniş dizgeler</primary><secondary>dizge uzunluğu</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>size_t</type><function>wcsnlen</function></csname>
    <csparam><ptr>const&#160;wchar_t</ptr><parameter>ws</parameter></csparam>
    <csparam><type>size_t</type><parameter>maxlen</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <code>wcsnlen</code> işlevi <function>strnlen</function> işlevinin geniş karakter karşılığıdır.  <parameter>maxlen</parameter> geniş karakterlerin azami sayısıdır (azami bayt sayısı değildir).
   </para>
   <para>
    Bu işlev GNU oluşumudur.
   </para>
   <header>&wchar.h;</header>
  </csynopsis>
 </chapter>

 <chapter xml:id="glibc-Copying-Strings-and-Arrays">
  <title>Dizilerin ve Dizgelerin Kopyalanması</title>
  <titleabbrev>Dizilerin ve dizgelerin içeriğini kopyalayan işlevler.</titleabbrev>
  <para>
   <indexterm linkend="glibc-pg"><primary>string.h</primary></indexterm>
   <indexterm linkend="glibc-pg"><primary>wchar.h</primary></indexterm>
   <indexterm linkend="glibc-cp"><primary>dizgeler</primary><secondary>kopyalama</secondary></indexterm>
   <indexterm linkend="glibc-cp"><primary>dizgeler</primary> <secondary>ekleme</secondary></indexterm>
   <indexterm linkend="glibc-cp"><primary>geniş dizgeler</primary><secondary>kopyalama</secondary></indexterm>
   <indexterm linkend="glibc-cp"><primary>geniş dizgeler</primary><secondary>ekleme</secondary></indexterm>
   <indexterm linkend="glibc-cp"><primary>diziler</primary><secondary>kopyalama</secondary></indexterm>
   <indexterm linkend="glibc-cp"><primary>diziler</primary><secondary>ekleme</secondary></indexterm>
   Bu kısımda dizi ve dizge ve geniş dizgelerin içeriğini kopyalayan işlevler açıklanmıştır. İsimleri <code>str</code> ve <code>mem</code> ile başlayan işlevler &string.h; başlık dosyasında, <code>w</code> ile başlayan işlevler ise &wchar.h;  başlık dosyasında bildirilmiştir.
  </para>
  <para>
   Bu bölümdeki işlevlere ilişkin bağımsız değişkenlerin sırasını hatırlamanın yararlı bir yolu, sıranın bir atama ifadesine karşılık gelmesidir. Bağımsız değişken sırası hedef, kaynak şeklinde belirtilen bu tür işlevlerin çoğu hedef dizinin adresi ile  bazıları da hedefin boş sonlandırıcısının konumu veya boş sonlandırıcı yoksa hedefin uzunluğu ile döner.
  </para>
  <para>
   Kaynak dizi ve hedef diziden uzunsa bu işlevlerin çoğu çalışmaz. Örneğin, kaynak dizisinin sonu, hedef dizisinin başlangıcını aşarsa, kaynak dizisi hedefe yazılırken başlangıcı, kendi sonunun üzerine yazılır. Daha kötüsü, bunların dizge içermesi durumunda kaynak dizgenin sonlandırıcısı kaybolur ve bu durumda oluşan döngü yazılıma tahsis edilen belleğin tamamen çöpe dönüşmesine kadar gidebilir.
  </para>
  <para>
   Dizilerin kopyalanmasında üst üste binme sorunu olan tüm işlevler bu  kılavuzda  açıkça belirtilmiştir. Bu kısımdaki işlevlere ek olarak  <function>sprintf</function> (<xref linkend="glibc-Formatted-Output-Functions"/>) ve <function>scanf</function> (<xref linkend="glibc-Formatted-Input-Functions"/>) gibi başka işlevler de vardır.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-memcpy"><primary>memcpy</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-memcpy"><primary>diziler</primary><secondary>kopyalama</secondary></indexterm>
   <csproto type="işlev">
    <csname><ptr>void</ptr><function>memcpy</function></csname>
    <csparam><type>void&#160;*restrict</type><parameter>to</parameter></csparam>
    <csparam><type>const&#160;void&#160;*restrict</type><parameter>from</parameter></csparam>
    <csparam><type>size_t</type><parameter>size</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <code>memcpy</code> işlevi <parameter>size</parameter> baytı <parameter>from</parameter> adresinde başlayan nesneden <parameter>to</parameter> adresinde başlayan nesneye kopyalar. Bu işlevde <parameter>from</parameter> dizisinin <parameter>to</parameter> dizisinin üzerine binmesi durumundaki davranışı tanımsızdır; üst üste binme olasılığı varsa <function>memmove</function> kullanılmalıdır.
   </para>
   <para>
    <code>memcpy</code> işlevi <parameter>to</parameter> değeri ile döner.
   </para>
   <example>
    <para>
     Bu örnekte bir dizinin içeriğini kopyalamak için <code>memcpy</code> işlevinin nasıl kullanılacağı gösterilmiştir:
    </para>
    <screen>struct foo *eskidizi, *yenidizi;
int diziboyu;
…
memcpy (yeni, eski, diziboyu * sizeof (struct foo));
</screen>
    </example>
   <header>&string.h;</header>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-wmemcpy"><primary>wmemcpy</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-wmemcpy"><primary>geniş dizgeler</primary><secondary>kopyalama</secondary></indexterm>
   <csproto type="işlev">
    <csname><ptr>wchar_t</ptr><function>wmemcpy</function></csname>
    <csparam><type>wchar_t&#160;*restrict</type><parameter>wto</parameter></csparam>
    <csparam><type>const&#160;wchar_t&#160;*restrict</type><parameter>wfrom</parameter></csparam>
    <csparam><type>size_t</type><parameter>size</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <code>wmemcpy</code> işlevi <parameter>size</parameter> geniş karakteri <parameter>wfrom</parameter> adresinde başlayan nesneden <parameter>wto</parameter> adresinde başlayan nesneye kopyalar. Bu işlevde <parameter>wfrom</parameter> dizisinin <parameter>wto</parameter> dizisinin üzerine binmesi durumundaki davranış tanımsızdır; üst üste binme olasılığı varsa <function>wmemmove</function> kullanılmalıdır.
   </para>
   <example>
    <para>
     Burada <code>wmemcpy</code> işlevinin olası bir gerçeklemesi vardır. Ancak, daha fazla en iyileme yapılabilir.
    </para>
    <screen>wchar_t *
wmemcpy (wchar_t *restrict <parameter>wto</parameter>, const wchar_t *restrict <parameter>wfrom</parameter>,
         size_t <parameter>size</parameter>)
{
  return (wchar_t *) memcpy (<parameter>wto</parameter>, <parameter>wfrom</parameter>, <parameter>size</parameter> * sizeof (wchar_t));
}
</screen>
   </example>
   <para>
    <code>wmemcpy</code> işlevi <parameter>wto</parameter> değeri ile döner.
   </para>
   <para>
    Bu işlev &isoc;90 standardının 1. düzeltmesinde tanımlanmıştır.
   </para>
   <header>&wchar.h;</header>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-mempcpy"><primary>mempcpy</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-mempcpy"><primary>diziler</primary><secondary>kopyalama</secondary></indexterm>
   <csproto type="işlev">
    <csname><ptr>void</ptr><function>mempcpy</function></csname>
    <csparam><type>void&#160;*restrict</type><parameter>to</parameter></csparam>
    <csparam><type>const&#160;void&#160;*restrict</type><parameter>from</parameter></csparam>
    <csparam><type>size_t</type><parameter>size</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <code>mempcpy</code> işlevi <function>memcpy</function> işlevi ile hemen hemen eşdeğerdir. <parameter>size</parameter> baytı, göstericisi <parameter>from</parameter> olan nesneden göstericisi <parameter>to</parameter> olan nesneye kopyalar. Fakat dönen değer <parameter>to</parameter> nesnesinin değeri değildir. <parameter>to</parameter> nesnesine yazılan son bayttan sonraki baytın göstericisi ile döner. Yani, dönen değer:
   </para>
   <literallayout class="monospaced"><code>((void *) ((char *) <parameter>to</parameter> + <parameter>size</parameter>))</code>.
</literallayout>
   <para>
    Bu işlev çok sayıda nesnenin ardışık bellek konumlarına kopyalanması durumunda kullanışlıdır.
   </para>
   <example>
    <screen>void *
combine (void *o1, size_t s1, void *o2, size_t s2)
{
  void *result = malloc (s1 + s2);
  if (result != NULL)
    mempcpy (mempcpy (result, o1, s1), o2, s2);
  return result;
}
</screen>
   </example>
   <para>Bu işlev GNU oluşumudur.</para>
   <header>&string.h;</header>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-wmempcpy"><primary>wmempcpy</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-wmempcpy"><primary>geniş dizgeler</primary><secondary>kopyalama</secondary></indexterm>
   <csproto type="işlev">
    <csname><ptr>wchar_t</ptr><function>wmempcpy</function></csname>
    <csparam><type>wchar_t&#160;*restrict</type><parameter>wto</parameter></csparam>
    <csparam><type>const&#160;wchar_t&#160;*restrict</type><parameter>wfrom</parameter></csparam>
    <csparam><type>size_t</type><parameter>size</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <code>wmempcpy</code> işlevi <function>wmemcpy</function> işlevi ile hemen hemen eşdeğerdir. İşlev, <parameter>size</parameter> geniş karakteri <parameter>wfrom</parameter> adresinden başlayan nesneden <parameter>wto</parameter> adresine kopyalar. Fakat dönen değer <parameter>wto</parameter> değeri değildir. <parameter>wto</parameter> başlangıcından itibaren yazılan son geniş karakteri izleyen geniş karakterin adresi ile döner. Yani, dönen değer: <parameter>wto</parameter>&#160;+&#160;<parameter>size</parameter>.
   </para>
   <para>
    Bu işlev çok sayıda nesnenin ardışık bellek konumlarına kopyalanması durumunda kullanışlıdır.
   </para>
   <example>
    <para>
     Burada <code>wmemcpy</code> işlevinin olası bir gerçeklemesi vardır. Ancak, daha fazla en iyileme yapılabilir.
    </para>
    <screen>wchar_t *
wmempcpy (wchar_t *restrict <parameter>wto</parameter>, const wchar_t *restrict <parameter>wfrom</parameter>,
          size_t <parameter>size</parameter>)
{
  return (wchar_t *) mempcpy (<parameter>wto</parameter>, <parameter>wfrom</parameter>, <parameter>size</parameter> * sizeof (wchar_t));
}
</screen>
   </example>
   <para>Bu işlev GNU oluşumudur.</para>
   <header>&wchar.h;</header>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-memmove"><primary>memmove</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-memmove"><primary>diziler</primary><secondary>kopyalama</secondary></indexterm>
   <csproto type="işlev">
    <csname><ptr>void</ptr><function>memmove</function></csname>
    <csparam><ptr>void</ptr><parameter>to</parameter></csparam>
    <csparam><ptr>const&#160;void</ptr><parameter>from</parameter></csparam>
    <csparam><type>size_t</type><parameter>size</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <code>memmove</code> işlevi <parameter>size</parameter> baytı <parameter>from</parameter>’dan <parameter>to</parameter>’ya birbirlerinin üstüne binseler bile kopyalar. Üst üste binme durumunda, işlev, <parameter>to</parameter> dilimindeki baytlar dahil <parameter>from</parameter> dilimindeki baytları <parameter>to</parameter> dilimine dikkatle kopyalar.
   </para>
   <para>
    İşlev, <parameter>to</parameter> değeri ile döner.
   </para>
   <header>&string.h;</header>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-wmemmove"><primary>wmemmove</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-wmemmove"><primary>geniş dizgeler</primary><secondary>kopyalama</secondary></indexterm>
   <csproto type="işlev">
    <csname><ptr>wchar_t</ptr><function>wmemmove</function></csname>
    <csparam><ptr>wchar_t&#160;</ptr><parameter>wto</parameter></csparam>
    <csparam><ptr>const&#160;wchar_t</ptr><parameter>wfrom</parameter></csparam>
    <csparam><type>size_t</type><parameter>size</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <code>wmemmove</code> işlevi <parameter>size</parameter> baytı <parameter>wfrom</parameter>’dan <parameter>wto</parameter>’ya üst üste binseler bile kopyalar. Üst üste binme durumunda, işlev, <parameter>wto</parameter> dilimindeki baytlar dahil <parameter>wfrom</parameter> dilimindeki baytları <parameter>wto</parameter> dilimine dikkatle kopyalar.
   </para>
   <example>
    <para>
     Burada <code>wmemmove</code> işlevinin olası bir gerçeklemesi vardır. Ancak, daha fazla en iyileme yapılabilir.
    </para>
    <screen>wchar_t *
wmemmove (wchar_t *<parameter>wto</parameter>, const wchar_t *<parameter>wfrom</parameter>,
          size_t <parameter>size</parameter>)
{
  return (wchar_t *) memmove (<parameter>wto</parameter>, <parameter>wfrom</parameter>, <parameter>size</parameter> * sizeof (wchar_t));
}
</screen>
   </example>
   <para>
    İşlev, <parameter>wto</parameter> değeri ile döner.
   </para>
   <header>&wchar.h;</header>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-memccpy"><primary>memccpy</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-memccpy"><primary>diziler</primary><secondary>kopyalama</secondary></indexterm>
   <csproto type="işlev">
    <csname><ptr>void</ptr><function>memccpy</function></csname>
    <csparam><type>void&#160;*restrict</type><parameter>to</parameter></csparam>
    <csparam><type>const&#160;void&#160;*restrict</type><parameter>from</parameter></csparam>
    <csparam><type>int</type><parameter>c</parameter></csparam>
    <csparam><type>size_t</type><parameter>size</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    Bu işlev <parameter>size</parameter> baytlık dizinin içindeki <parameter>c</parameter> karakterine kadar olan kısmı <parameter>from</parameter>’dan <parameter>to</parameter>’ya kopyalar. Dönen değer, <parameter>to</parameter>’ya kopyalanan kısmın <parameter>c</parameter> karakterini izleyen baytının adresidir, eğer <parameter>size</parameter> bayt içinde <parameter>c</parameter> karakteri bulunamamışsa işlev boş gösterici ile döner.
   </para>
   <header>&string.h;</header>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-memset"><primary>memset</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-memset"><primary>diziler</primary><secondary>sıfırlama</secondary></indexterm>
   <csproto type="işlev">
    <csname><ptr>void</ptr><function>memset</function></csname>
    <csparam><ptr>void</ptr><parameter>block</parameter></csparam>
    <csparam><type>int</type><parameter>c</parameter></csparam>
    <csparam><type>size_t</type><parameter>size</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    Bu işlev, <parameter>c</parameter> değerini (<type>unsigned&#160;char</type> türüne dönüştürerek) <parameter>block</parameter> adresinden başlayan nesnenin ilk <parameter>size</parameter> baytının her birine kopyalar ve <parameter>block</parameter> değeri ile döner.
   </para>
   <header>&string.h;</header>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-wmemset"><primary>wmemset</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-wmemset"><primary>geniş dizgeler</primary><secondary>sıfırlama</secondary></indexterm>
   <csproto type="işlev">
    <csname><ptr>wchar_t</ptr><function>wmemset</function></csname>
    <csparam><ptr>wchar_t</ptr><parameter>block</parameter></csparam>
    <csparam><type>wchar_t</type><parameter>c</parameter></csparam>
    <csparam><type>size_t</type><parameter>size</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    Bu işlev, <parameter>c</parameter> değerini <parameter>block</parameter> adresinden başlayan nesnenin ilk <parameter>size</parameter> geniş karakterinin her birine kopyalar ve <parameter>block</parameter> değeri ile döner.
   </para>
   <header>&wchar.h;</header>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-strcpy"><primary>strcpy</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-strcpy"><primary>dizgeler</primary><secondary>kopyalama</secondary></indexterm>
   <csproto type="işlev">
    <csname><ptr>char</ptr><function>strcpy</function></csname>
    <csparam><type>char&#160;*restrict</type><parameter>to</parameter></csparam>
    <csparam><type>const&#160;char&#160;*restrict</type><parameter>from</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <parameter>from</parameter> dizgesini (sonlandırıcı boş bayta kadar) <parameter>to</parameter> dizgesine kopyalar. Bu işlevde <parameter>from</parameter> dizgesinin <parameter>to</parameter> dizgesinin üzerine binmesi durumundaki davranışı tanımsızdır. İşlev, <parameter>to</parameter> dizgesi ile döner.
   </para>
   <header>&string.h;</header>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-wcscpy"><primary>wcscpy</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-wcscpy"><primary>geniş dizgeler</primary><secondary>kopyalama</secondary></indexterm>
   <csproto type="işlev">
    <csname><ptr>wchar_t</ptr><function>wcscpy</function></csname>
    <csparam><type>wchar_t&#160;*restrict</type><parameter>wto</parameter></csparam>
    <csparam><type>const&#160;wchar_t&#160;*restrict</type><parameter>wfrom</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <parameter>wfrom</parameter> dizgesini (sonlandırıcı boş geniş karaktere kadar) <parameter>wto</parameter> dizgesine kopyalar. Bu işlevde <parameter>wfrom</parameter> dizgesinin  <parameter>wto</parameter> dizgesinin üzerine binmesi durumundaki davranışı tanımsızdır. İşlev, <parameter>wto</parameter> değeri ile döner.
   </para>
   <header>&wchar.h;</header>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-strdup"><primary>strdup</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-strdup"><primary>dizgeler</primary><secondary>bellek tahsisi</secondary></indexterm>
   <csproto type="işlev">
    <csname><ptr>char</ptr><function>strdup</function></csname>
    <csparam><ptr>const&#160;char</ptr><parameter>s</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&asunsafe; &heap;</concept>
    <concept>&acunsafe; &mem;</concept>
   </conceptlist>
   <para>
    Bu işlev <parameter>s</parameter> dizgesini yeni tahsis edilmiş bellek alanına kopyalar. Tahsis işlemi <function>malloc</function> ile yapılır; bkz. <xref linkend="glibc-Unconstrained-Allocation"/>. <function>malloc</function> yeni dizge için bellek tahsis edemezse işlev boş gösterici ile döner, aksi takdirde yeni dizgeye gösterici ile döner.
   </para>
   <header>&string.h;</header>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-wcsdup"><primary>wcsdup</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-wcsdup"><primary>geniş dizgeler</primary><secondary>bellek tahsisi</secondary></indexterm>
   <csproto type="işlev">
    <csname><ptr>wchar_t</ptr><function>wcsdup</function></csname>
    <csparam><ptr>const&#160;wchar_t</ptr><parameter>ws</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&asunsafe; &heap;</concept>
    <concept>&acunsafe; &mem;</concept>
   </conceptlist>
   <para>
    Bu işlev <parameter>ws</parameter> geniş dizgesini yeni tahsis edilmiş bellek alanına kopyalar. Tahsis işlemi <function>malloc</function> ile yapılır; bkz. <xref linkend="glibc-Unconstrained-Allocation"/>. <function>malloc</function> yeni geniş dizge için bellek tahsis edemezse işlev boş gösterici ile döner, aksi takdirde yeni geniş dizgeye gösterici ile döner.
   </para>
   <para>Bu işlev GNU oluşumudur.</para>
   <header>&wchar.h;</header>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-stpcpy"><primary>stpcpy</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-stpcpy"><primary>dizgeler</primary><secondary>kopyalama</secondary></indexterm>
   <csproto type="işlev">
    <csname><ptr>char</ptr><function>stpcpy</function></csname>
    <csparam><type>char&#160;*restrict</type><parameter>to</parameter></csparam>
    <csparam><type>const&#160;char&#160;*restrict</type><parameter>from</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    Bu işlev <parameter>to</parameter> dizgesinin sonunu gösteren bir gösterici ile dönmesi dışında <function>strcpy</function> işlevi gibidir.
   </para>
   <example>
    <para>
     Bu yazılımda <filename>foo</filename> ve <filename>bar</filename> birleştirilerek <filename>foobar</filename> üretilip çıktılanmaktadır:
    </para>
    <screen>#include &lt;string.h&gt;
#include &lt;stdio.h&gt;

int
main (void)
{
  char buffer[10];
  char *<parameter>to</parameter> = buffer;
  <parameter>to</parameter> = stpcpy (<parameter>to</parameter>, "foo");
  <parameter>to</parameter> = stpcpy (<parameter>to</parameter>, "bar");
  puts (buffer);
  return 0;
}
</screen>
   </example>
   <para>
    Bu işlev, POSIX.1-2008 ve sonraki sürümlerin bir parçasıdır, ancak standartlaştırılmadan çok önce bir genişletme olarak GNU C Kütüphanesinde ve diğer sistemlerde mevcuttu.
   </para>
   <para>
    Dizgelerin üst üste binmesi durumundaki davranış tanımsızdır.
   </para>
   <header>&string.h;</header>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-wcpcpy"><primary>wcpcpy</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-wcpcpy"><primary>geniş dizgeler</primary><secondary>kopyalama</secondary></indexterm>
   <csproto type="işlev">
    <csname><ptr>wchar_t</ptr><function>wcpcpy</function></csname>
    <csparam><type>wchar_t&#160;*restrict</type><parameter>wto</parameter></csparam>
    <csparam><type>const&#160;wchar_t&#160;*restrict</type><parameter>wfrom</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    Bu işlev <parameter>wto</parameter> dizgesinin sonuna gösterici ile dönmesi dışında <function>wcscpy</function> işlevi gibidir. İşlev kopyalanan dizgenin başlangıç adresi ile değil, dizgeyi sonlandıran boş geniş karakterin adresi ile döner.
   </para>
   <para>
    Bu işlev bir ISO veya POSIX oluşumu değildir, ancak GNU C kütüphanesi geliştirilirken kullanışlı bulunmuştur.
   </para>
   <para>
    Üst üste binme durumunda işlevin davranışı tanımsızdır. Bu işlev GNU oluşumudur.
   </para>
   <header>&wchar.h;</header>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-strdupa"><primary>strdupa</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-strdupa"><primary>dizgeler</primary><secondary>bellek tahsisi</secondary></indexterm>
   <csproto type="makro">
    <csname><ptr>char</ptr><function>strdupa</function></csname>
    <csparam><ptr>const&#160;char</ptr><parameter>s</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    Bu makro, yeni dizgeye bellek tahsis etmek için <function>malloc</function>  yerine <function>alloca</function> (bkz. <xref linkend="glibc-Variable-Size-Automatic"/>) kullanması dışında <function>strdup</function> gibidir. Yani, <function>alloca</function> kullanarak tahsis edilen bellek dilimleri ile aynı sınırlamalara sahip bir dizi döner.
   </para>
   <para>
    Çeşitli sebeplerle <code>strdupa</code> sadece makro olarak gerçeklenmiştir; yani bir işlev gibi adresi alınamaz. Bu sınırlama dışında işlev olarak kullanışlıdır.
   </para>
   <example>
    <para>
     Aşağıdaki kodda <function>malloc</function> kullanıldığında işlemin ne kadar pahalıya malolduğu gösterilmiştir.
    </para>
    <screen>#include &lt;paths.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;

const char path[] = _PATH_STDPATH;

int
main (void)
{
  char *wr_path = strdupa (path);
  char *cp = strtok (wr_path, ":");

  while (cp != NULL)
    {
      puts (cp);
      cp = strtok (NULL, ":");
    }
  return 0;
}
</screen>
    <para>
     <function>strtok</function>'un doğrudan <code>path</code> kullanılarak çağrılmasının geçersiz oluşuna dikkat edilmelidir. Ayrıca, <code>strdupa</code>
     bağımsız değişken aktarımında girişime sebep olabilen <function>alloca</function>'yı  (bkz. <xref linkend="glibc-Variable-Size-Automatic"/>) kullandığından  <function>strtok</function>'un bağımsız değişken listesinde  <code>strdupa</code> kullanımına izin verilmez.
    </para>
   </example>
   <para>
    Bu işlev sadece GNU C derleyicisi ile kullanılabilir.
   </para>
   <header>&string.h;</header>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-bcopy"><primary>bcopy</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-bcopy"><primary>diziler</primary><secondary>kopyalama</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>void</type><function>bcopy</function></csname>
    <csparam><ptr>const&#160;void</ptr><parameter>from</parameter></csparam>
    <csparam><ptr>void</ptr><parameter>to</parameter></csparam>
    <csparam><type>size_t</type><parameter>size</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    Bu işlev, BSD'den türetilen, <function>memmove</function>'un kısmen eskimiş bir benzeridir.  Ancak <function>memmove</function> ile eşdeğer değildir, çünkü bağımsız değişkenleri aynı sırada değildir ve dönen değer yoktur.
   </para>
   <header>&string.h;</header>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-bzero"><primary>bzero</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-bzero"><primary>diziler</primary><secondary>sıfırlama</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>void</type><function>bzero</function></csname>
    <csparam><ptr>void</ptr><parameter>block</parameter></csparam>
    <csparam><type>size_t</type><parameter>size</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    Bu işlev, BSD'den türetilen, <function>memset</function>'in kısmen eskimiş bir benzeridir.  Ancak <function>memset</function> ile eşdeğer değildir, çünkü sakladığı tek değer sıfırdır.
   </para>
   <header>&string.h;</header>
  </csynopsis>
 </chapter>

 <chapter xml:id="glibc-Concatenating-Strings">
  <title>Dizgelerin Birleştirilmesi</title>
  <titleabbrev>Dizgelerin kopyalanarak birbirine eklenmesi.</titleabbrev>
  <para>
   <indexterm linkend="glibc-pg"><primary>string.h</primary></indexterm>
   <indexterm linkend="glibc-pg"><primary>wchar.h</primary></indexterm>
   <indexterm linkend="glibc-cp"><primary>birleştirme</primary><secondary>dizgeler</secondary></indexterm>
   <indexterm linkend="glibc-cp"><primary>dizge birleştirme işlevleri</primary></indexterm>
   Bu bölümde açıklanan işlevler, bir dizgenin veya geniş dizgenin içeriğini diğerine birleştirir. Dizge kopyalama işlevleri ile ilgili uzlaşımlar bunlara da uygulanır (Bkz. <xref linkend="glibc-Copying-Strings-and-Arrays"/>). ‘<function>strcat</function>’ işlevi &string.h;, ‘<function>wcscat</function>’ işlevi ise &wchar.h; başlık dosyasına bildirilmiştir.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-strcat"><primary>strcat</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-strcat"><primary>dizgeler</primary><secondary>ekleme</secondary></indexterm>
   <csproto type="işlev">
    <csname><ptr>char</ptr><function>strcat</function></csname>
    <csparam><type>char&#160;*restrict</type><parameter>to</parameter></csparam>
    <csparam><type>const&#160;char&#160;*restrict</type><parameter>from</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <parameter>from</parameter> dizgesini <parameter>to</parameter> dizgesinin üzerine yazmak yerine <parameter>to</parameter> dizgesinin sonuna ekleyerek onunla birleştirmesi dışında <function>strcpy</function> işlevine benzer. <parameter>from</parameter> dizgesinin ilk baytı <parameter>to</parameter> dizgesini sonlandıran boş baytın üzerine yazılır.
   </para>
   <example>
   <para>
    <code>strcat</code> işlevinin tanımı aşağıdakine eşdeğerdir:
   </para>
<screen>char *
strcat (char *restrict <parameter>to</parameter>, const char *restrict <parameter>from</parameter>)
{
  strcpy (<parameter>to</parameter> + strlen (<parameter>to</parameter>), <parameter>from</parameter>);
  return <parameter>to</parameter>;
}
</screen>
   </example>
   <para>
    Dizgelerin üst üste binmesi durumu için bu işlevin davranışı tanımlanmamıştır.
   </para>
   <para>
    <link linkend="glibc-strcat-performance-issues">Aşağıda belirtildiği gibi</link>, bu işlevin önemli başarım sorunları vardır.
   </para>
   <header>&string.h;</header>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-wcscat"><primary>wcscat</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-wcscat"><primary>geniş dizgeler</primary><secondary>ekleme</secondary></indexterm>
   <csproto type="işlev">
    <csname><ptr>wchar_t</ptr><function>wcscat</function></csname>
    <csparam><type>wchar_t&#160;*restrict</type><parameter>wto</parameter></csparam>
    <csparam><type>const&#160;wchar_t&#160;*restrict</type><parameter>wfrom</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <parameter>wfrom</parameter> geniş dizgesini <parameter>to</parameter> geniş dizgesinin üzerine yazmak yerine <parameter>to</parameter> geniş dizgesinin sonuna ekleyerek onunla birleştirmesi dışında <function>wcscpy</function> işlevine benzer. <parameter>wfrom</parameter> dizgesinin ilk geniş karakteri <parameter>wto</parameter> geniş dizgesini sonlandıran boş geniş karakterin üzerine yazılır.
   </para>
   <example>
    <para>
     <code>wcscat</code> işlevinin tanımı aşağıdakine eşdeğerdir:
    </para>
    <screen>wchar_t *
wcscat (wchar_t *wto, const wchar_t *wfrom)
{
  wcscpy (wto + wcslen (wto), wfrom);
  return wto;
}
</screen>
   </example>
   <para>
    Dizgelerin üst üste binmesi durumu için bu işlevin davranışı tanımlanmamıştır.
   </para>
   <para>
    Aşağıda belirtildiği gibi, bu işlevin önemli başarım sorunları vardır.
   </para>
   <header>&wchar.h;</header>
  </csynopsis>
  <note xml:id="glibc-strcat-performance-issues">
   <title><code>strcat/wcscat</code> işlevleri ile ilgili başarım sorunları</title>
   <para>
    <function>strcat</function> ya da <function>wcscat</function> (veya sonraki bölüme tanımlanmış olan <function>strncat</function> ya da <function>wcsncat</function>) işlevlerini kullanan yazılımcılar kolayca ihtiyatsız ve hatta çılgın olarak tanımlanabilir. Hemen hemen her durumda, eklemlenecek dizge uzunlukları bilinir (tampon boyutunun yeterli olup olmayacağı bilinemeyeceğine göre, öyle olmalı). Ya da en azından, çeşitli işlev çağrılarının sonuçları izlenerek bilinir. Ama yine de <function>strcat</function>/<function>wcscat</function> işlevleri yetersizdir. Kopyalama başladığında hedef dizgenin sonunu bulmak için gereksiz zaman harcanacaktır. Aşağıdaki örneğe bakınız:
    <indexterm linkend="glibc-cp"><primary>va_copy</primary></indexterm>
   </para>
   <example>
    <screen>/* <replaceable>Bu işlev birçok dizgeyi birleştirir.</replaceable>
   <replaceable>Son bağımsız değişken NULL olmalı.</replaceable>  */
char *
concat (const char *str, …)
{
  va_list ap, ap2;
  size_t total = 1;

  va_start (ap, str);
  va_copy (ap2, ap);

  /* <replaceable>Ne kadar yer lazım ?</replaceable>  */
  for (const char *s = str; s != NULL; s = va_arg (ap, const char *))
    total += strlen (s);

  va_end (ap);

  char *result = malloc (total);
  if (result != NULL)
    {
      result[0] = '\0';

      /* <replaceable>Dizgeleri kopyala.</replaceable>  */
      for (s = str; s != NULL; s = va_arg (ap2, const char *))
        strcat (result, s);
    }

  va_end (ap2);

  return result;
}
</screen>
   </example>
   <para>
    Basit gibi görünüyor, özellikle dizgelerin kopyalandığı ikinci döngü. Ancak bu masum satırlar, büyük bir başarım kaybını gizliyor. Her birinin 100 baytlık on dizgeyi birleştirdiği varsayılsın. Aranan ikinci dizge için dizgenin sonunda zaten 100 bayt tahsis edildiğinden sonraki dizge eklenebilir. Toplamda tüm dizgeler için ara sonuçlarla birlikte uzunluk 5500! olur. Bellek tahsisi için yapılan arama ile kopyalama birleştirilirse bu işlev daha verimli kılınabilir:
   </para>
   <example>
    <screen>char *
concat (const char *str, …)
{
  size_t allocated = 100;
  char *result = malloc (allocated);

  if (result != NULL)
    {
      va_list ap;
      size_t resultlen = 0;
      char *newp;

      va_start (ap, str);

      for (const char *s = str; s != NULL; s = va_arg (ap, const char *))
        {
          size_t len = strlen (s);

          /* <replaceable>Gerekirse, tutulan belleği arttır</replaceable>  */
          if (resultlen + len + 1 &gt; allocated)
            {
              allocated += len;
              newp = reallocarray (result, allocated, 2);
              allocated *= 2;
              if (newp == NULL)
                {
                  free (result);
                  return NULL;
                }
              result = newp;
            }

          memcpy (result + resultlen, s, len);
          resultlen += len;
        }

      /* <replaceable>Sonuçlanan dizgeyi sonlandır.</replaceable>  */
      result[resultlen++] = '\0';

      /* <replaceable>Belleği tam istenen boyuta ayarla.</replaceable>  */
      newp = realloc (result, resultlen);
      if (newp != NULL)
        result = newp;

      va_end (ap);
    }

  return result;
}
</screen>
   </example>
   <para>
    Girdi dizgeleri hakkına biraz daha fazla bilgi birikimi kullanarak bellek tahsis işlemi daha hassas yapılabilirdi. Burada farklı olarak <function>strcat</function> işlevi hiç kullanılmadı. Ara sonuçların izi sürülerek dizge sonlarının bulunması güvenceye alındı ve <function>mempcpy</function> işlevi kullanıldı. Ayrıca, dizgeleri elde etmek bakımından daha doğal görünen <function>stpcpy</function> işlevi de kullanılmadı. Ama zaten, dizge uzunluğu bilindiğine göre bu gerekli değildi ve bu sebeple daha hızlı bellek kopyalaması yapılabildi. Bu örnek, geniş karakterler için de aynı şekilde çalışırdı.
   </para>
   <para>
    Bir yazılımcı <function>strcat</function> kullanmaya karar vermeden önce iki kere düşünmeli ve hesaplanmış sonuçların getirilerinden yararlanmak için kod tekrar yazılamaz mı acaba diye bakmalıdır. Tekrar:  <function>strcat</function> işlevinin kullanılması hemen hemen daima gereksizdir.
   </para>
  </note>
 </chapter>

 <chapter xml:id="glibc-Truncating-Strings">
  <title>Dizgelerin Kırpılması</title>
  <titleabbrev>Dizgelerin kopyalanarak kırpılması.</titleabbrev>
  <para>
   <indexterm linkend="glibc-cp"><primary>kırpma</primary><secondary>dizgeler</secondary></indexterm>
   <indexterm linkend="glibc-cp"><primary>dizgelerin kırpılması</primary></indexterm>
   Bu bölümde açıklanan işlevler, bir dizinin, dizgenin veya geniş dizgenin muhtemelen kırpılmış içeriğini diğerine kopyalar veya ekler. Başlık dosyaları ile ilgili uzlaşımlar bunlara da uygulanır (Bkz. <xref linkend="glibc-Copying-Strings-and-Arrays"/>). ‘<code>str</code>’ işlevleri &string.h;, ‘<code>wc</code>’ işlevleri ise &wchar.h; başlık dosyasına bildirilmiştir.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-strncpy"><primary>strncpy</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-strncpy"><primary>dizgeler</primary><secondary>kırparak kopyalama</secondary></indexterm>
   <csproto type="işlev">
    <csname><ptr>char</ptr><function>strncpy</function></csname>
    <csparam><type>char&#160;*restrict</type><parameter>to</parameter></csparam>
    <csparam><type>const&#160;char&#160;*restrict</type><parameter>from</parameter></csparam>
    <csparam><type>size_t</type><parameter>size</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    Bu işlev <parameter>size</parameter> sayıda karakteri <parameter>to</parameter> dizgesine kopyalaması dışında <function>strcpy</function> işlevi gibidir.
   </para>
   <para>
    <parameter>from</parameter> dizgesinin ilk <parameter>size</parameter> baytı boş bayt içermiyorsa ve <parameter>from</parameter> uzunluğu <parameter>size</parameter> bayttan uzunsa işlev, ilk <parameter>size</parameter> baytı kopyalar. Bu durumda <parameter>to</parameter> dizgesi sonlandırıcı boş baytı içermez.
   </para>
   <para>
    <parameter>from</parameter> dizgesinin uzunluğu <parameter>size</parameter> bayttan kısaysa <parameter>from</parameter> dizgesi ile boş bayttan sonraki <parameter>size</parameter> bayta kadar olan baytlar boş baytlarla doldurularak <parameter>to</parameter> dizgesine kopyalanır.
   </para>
   <para>
    Üst üste binme durumunda <code>strncpy</code> işlevinin davranışı tanımsızdır.
   </para>
   <para>
    Bu işlev, boş olmayan baytlardan oluşan ve ardından sıfır veya daha fazla boş bayt gelen, artık nadiren kullanılan diziler için tasarlanmıştır. <parameter>size</parameter>, <parameter>from</parameter> dizgesinin uzunluğundan çok daha büyük olsa bile, hedefin boyut baytının tamamına yazılması gerekir. <link linkend="glibc-poor-choice-for-text">Aşağıda da belirtildiği gibi</link>, bu işlev genellikle metin işlemleri için kötü seçimdir.
   </para>
   <header>&string.h;</header>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-wcsncpy"><primary>wcsncpy</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-wcsncpy"><primary>geniş dizgeler</primary><secondary>kırparak kopyalama</secondary></indexterm>
   <csproto type="işlev">
    <csname><ptr>wchar_t</ptr><function>wcsncpy</function></csname>
    <csparam><type>wchar_t&#160;*restrict</type><parameter>wto</parameter></csparam>
    <csparam><type>const&#160;wchar_t&#160;*restrict</type><parameter>wfrom</parameter></csparam>
    <csparam><type>size_t</type><parameter>size</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    Bu işlev <parameter>size</parameter> sayıda geniş karakteri <parameter>to</parameter> dizgesine kopyalaması dışında <function>wcscpy</function> işlevi gibidir.
   </para>
   <para>
    <parameter>wfrom</parameter> geniş dizgesinin ilk <parameter>size</parameter> geniş karakteri arasında boş geniş karakter yoksa ve <parameter>wfrom</parameter> geniş dizgesinin uzunluğu <parameter>size</parameter> geniş karakterden uzunsa işlev, ilk <parameter>size</parameter> geniş karakteri kopyalar. Bu durumda <parameter>wto</parameter> dizgesi sonlandırıcı boş geniş karakteri içermez.
   </para>
   <para>
    <parameter>wfrom</parameter> geniş dizgesinin uzunluğu <parameter>size</parameter> geniş karakterden kısaysa <parameter>wfrom</parameter> geniş dizgesi ile boş geniş karakterden sonraki <parameter>size</parameter> geniş karaktere kadar olan baytlar boş geniş karakterlerle doldurularak <parameter>wto</parameter> geniş dizgesine kopyalanır.
   </para>
   <para>
    Üst üste binme durumunda <code>wcsncpy</code> işlevinin davranışı tanımsızdır.
   </para>
   <para>
    Bu işlev <function>strncpy</function> işlevinin geniş karakter karşılığıdır ve <function>strncpy</function> işlevi ile ilgili sorunların çoğu bu işlev için de geçerlidir. <link linkend="glibc-poor-choice-for-text">Aşağıda da belirtildiği gibi</link>, bu işlev genellikle metin işlemleri için kötü seçimdir.
   </para>
   <header>&wchar.h;</header>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-strndup"><primary>strndup</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-strndup"><primary>dizgeler</primary><secondary>tahsisli kopyalama</secondary></indexterm>
   <csproto type="işlev">
    <csname><ptr>char</ptr><function>strndup</function></csname>
    <csparam><ptr>const&#160;char</ptr><parameter>s</parameter></csparam>
    <csparam><type>size_t</type><parameter>size</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&asunsafe; &heap;</concept>
    <concept>&acunsafe; &mem;</concept>
   </conceptlist>
   <para>
    Bu işlev en fazla <parameter>size</parameter> baytı kopyalamak dışında <function>strdup</function> işlevi gibidir.
   </para>
   <para>
    <parameter>s</parameter> dizgesinin uzunluğu <parameter>size</parameter> bayttan uzun ise işlev ilk <parameter>size</parameter> baytı kopyalar ve sonuna boş baytı ekler, aksi takdirde tüm karakterler kopyalanır ve dizge sonlandırılır.
   </para>
   <para>
    Bu işlev hedef dizgeyi daima boş bayt ile sonlandırması bakımından <function>strncpy</function> işlevinden de farklıdır.
   </para>
   <para>
    Bu işlev GNU oluşumudur ve <link linkend="glibc-poor-choice-for-text">aşağıda da belirtildiği gibi</link>, bu işlev genellikle metin işlemleri için kötü seçimdir.
   </para>
   <header>&string.h;</header>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-strndupa"><primary>strndupa</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-strndupa"><primary>dizgeler</primary><secondary>tahsisli kopyalama</secondary></indexterm>
   <csproto type="makro">
    <csname><ptr>char</ptr><function>strndupa</function></csname>
    <csparam><ptr>const&#160;char</ptr><parameter>s</parameter></csparam>
    <csparam><type>size_t</type><parameter>size</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    Bu işlev, yeni dizge için belleği <function>alloca</function> ile tahsis etmesi dışında <function>strndup</function> gibidir. <function>strdupa</function> için geçerli olan yararlar ve sınırlamalar, <code>strndupa</code> için de geçerlidir.
   </para>
   <para>
    Bu işlev de <function>strdupa</function> gibi sadece makro olarak gerçeklenmiştir. <function>strdupa</function> gibi bu makro da bir işlev çağrısının bağımsız değişken listesinde kullanılamaz.
   </para>
   <para>
    Bu işlev sadece GNU C derleyicisi ile kullanılabilir ve <link linkend="glibc-poor-choice-for-text">aşağıda da belirtildiği gibi</link>, bu işlev genellikle metin işlemleri için kötü seçimdir.
   </para>
   <header>&string.h;</header>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-stpncpy"><primary>stpncpy</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-stpncpy"><primary>dizgeler</primary><secondary>kırparak kopyalama</secondary></indexterm>
   <csproto type="işlev">
    <csname><ptr>char</ptr><function>stpncpy</function></csname>
    <csparam><type>char&#160;*restrict</type><parameter>to</parameter></csparam>
    <csparam><type>const&#160;char&#160;*restrict</type><parameter>from</parameter></csparam>
    <csparam><type>size_t</type><parameter>size</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    Bu işlev, <parameter>to</parameter>’ya ilk <parameter>size</parameter> baytı kopyalaması dışında <function>stpcpy</function> gibidir.
   </para>
   <para>
    <parameter>from</parameter> dizgesinin uzunluğu <parameter>size</parameter> bayttan uzunsa işlev, ilk <parameter>size</parameter> baytı kopyalar ve kopyalanan son bayttan sonraki baytın adresi ile döner. Bu durumda <parameter>to</parameter> dizgesi boş karakteri içermez.
   </para>
   <para>
    <parameter>from</parameter> dizgesinin uzunluğu <parameter>size</parameter> bayttan kısaysa <parameter>from</parameter> dizgesinin boş baytından sonraki <parameter>size</parameter> bayta kadar olan baytlar boş baytlarla doldurularak <parameter>from</parameter> dizgesi <parameter>to</parameter> dizgesine kopyalanır ve yazılan <emphasis>ilk</emphasis> boş baytın adresi ile döner.  Bu işlev az kullanışlıdır ama  <function>strncpy</function> işlevinin davranışı kullanışlı bulunduğundan gerçeklenmiştir.
   </para>
   <para>
    Bu işlev bir ISO veya POSIX oluşumu değildir, ancak GNU C kütüphanesi geliştirilirken kullanışlı bulunmuştur. Ancak, <link linkend="glibc-poor-choice-for-text">aşağıda da belirtildiği gibi</link>, bu işlev genellikle metin işlemleri için kötü seçimdir.
   </para>
   <para>
    Dizgelerin üst üste binmesi durumundaki davranış tanımsızdır.
   </para>
   <header>&string.h;</header>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-wcpncpy"><primary>wcpncpy</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-wcpncpy"><primary>geniş dizgeler</primary><secondary>kırparak kopyalama</secondary></indexterm>
   <csproto type="işlev">
    <csname><ptr>wchar_t</ptr><function>wcpncpy</function></csname>
    <csparam><type>wchar_t&#160;*restrict</type><parameter>wto</parameter></csparam>
    <csparam><type>const&#160;wchar_t&#160;*restrict</type><parameter>wfrom</parameter></csparam>
    <csparam><type>size_t</type><parameter>size</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    Bu işlev, <parameter>wto</parameter>’ya ilk <parameter>size</parameter> geniş karakteri kopyalaması dışında <function>wcpcpy</function> gibidir.
   </para>
   <para>
    <parameter>wfrom</parameter> dizgesinin uzunluğu <parameter>size</parameter> bayttan uzunsa işlev, ilk <parameter>size</parameter> baytı kopyalar ve kopyalanan son bayttan sonraki baytın adresi ile döner. Bu durumda <parameter>wto</parameter> dizgesi boş karakteri içermez.
   </para>
   <para>
    <parameter>wfrom</parameter> geniş dizgesinin uzunluğu <parameter>size</parameter> geniş karakterden kısaysa <parameter>wfrom</parameter> dizgesinin boş geniş karakterinden sonraki <parameter>size</parameter> geniş karaktere kadar olan baytlar boş geniş karakterlerle doldurularak <parameter>wfrom</parameter> geniş dizgesi <parameter>wto</parameter> geniş dizgesine kopyalanır ve yazılan <emphasis>ilk</emphasis> boş geniş karakaterin adresi ile döner.  Bu işlev az kullanışlıdır ama  <function>wcsncpy</function> işlevinin davranışı kullanışlı bulunduğundan gerçeklenmiştir.
   </para>
   <para>
    Bu işlev bir ISO veya POSIX oluşumu değildir, ancak GNU C kütüphanesi geliştirilirken kullanışlı bulunmuştur. Ancak, <link linkend="glibc-poor-choice-for-text">aşağıda da belirtildiği gibi</link>, bu işlev genellikle metin işlemleri için kötü seçimdir.
   </para>
   <para>
    Dizgelerin üst üste binmesi durumundaki davranış tanımsızdır.
   </para>
   <header>&wchar.h;</header>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-strncat"><primary>strncat</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-strncat"><primary>dizgeler</primary><secondary>ekleme</secondary></indexterm>
   <csproto type="işlev">
    <csname><ptr>char</ptr><function>strncat</function></csname>
    <csparam><type>char&#160;*restrict</type><parameter>to</parameter></csparam>
    <csparam><type>const&#160;char&#160;*restrict</type><parameter>from</parameter></csparam>
    <csparam><type>size_t</type><parameter>size</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    Bu işlev, <parameter>from</parameter> dizgesinin ilk <parameter>size</parameter> baytını <parameter>to</parameter> dizgesinin sonuna eklemesi dışında <function>strcat</function> gibidir. <parameter>to</parameter> dizgesinin sonuna daima boş bayt eklendiğinden <parameter>to</parameter> için tahsis edilmiş yer en azından <parameter>from</parameter><code> + 1</code> bayt olmalıdır.
   </para>
   <example>
    <para>
     Bu işlev aşağıdaki gibi de gerçeklenebilirdi:
    </para>
    <screen>char *
strncat (char *<parameter>to</parameter>, const char *<parameter>from</parameter>, size_t <parameter>size</parameter>)
{
  <parameter>to</parameter>[strlen (<parameter>to</parameter>) + <parameter>size</parameter>] = '\0';
  strncpy (<parameter>to</parameter> + strlen (<parameter>to</parameter>), <parameter>from</parameter>, <parameter>size</parameter>);
  return <parameter>to</parameter>;
}
</screen>
   </example>
   <para>
    Dizgelerin üst üste binmesi durumu için bu işlevin davranışı tanımlanmamıştır.
   </para>
   <para>
    <function>strncpy</function>'nin tamamlayıcısı olarak, <code>strncat</code>, boş olmayan baytlardan oluşan ve ardından sıfır veya daha fazla boş bayt gelen, nadiren kullanılan diziler için tasarlanmıştır. <link linkend="glibc-poor-choice-for-text">Aşağıda da belirtildiği gibi</link>, bu işlev genellikle metin işlemleri için kötü seçimdir. <link linkend="glibc-strcat-performance-issues">Ayrıca, evvelce belirtildiği gibi</link>, bu işlevin önemli başarım sorunları vardır.
   </para>
   <header>&string.h;</header>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-wcsncat"><primary>wcsncat</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-wcsncat"><primary>geniş dizgeler</primary><secondary>ekleme</secondary></indexterm>
   <csproto type="işlev">
    <csname><ptr>wchar_t</ptr><function>wcsncat</function></csname>
    <csparam><type>wchar_t&#160;*restrict</type><parameter>wto</parameter></csparam>
    <csparam><type>const&#160;wchar_t&#160;*restrict</type><parameter>wfrom</parameter></csparam>
    <csparam><type>size_t</type><parameter>size</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    Bu işlev, <parameter>wfrom</parameter> geniş dizgesinin ilk <parameter>size</parameter> geniş karakterini <parameter>wto</parameter> geniş dizgesinin sonuna eklemesi dışında <function>wcscat</function> gibidir. <parameter>wto</parameter> geniş dizgesinin sonuna daima boş geniş karakter eklendiğinden <parameter>wto</parameter> için tahsis edilmiş yer en azından <code>wcsnlen (<parameter>wfrom</parameter>, <parameter>size</parameter>) + 1</code> geniş karakter olmalıdır.
   </para>
   <example>
    <para>
     Bu işlev aşağıdaki gibi de gerçeklenebilirdi:
    </para>
    <screen>wchar_t *
wcsncat (wchar_t *restrict <parameter>wto</parameter>, const wchar_t *restrict <parameter>wfrom</parameter>,
         size_t <parameter>size</parameter>)
{
  size_t len = wcslen (<parameter>wto</parameter>);
  memcpy (<parameter>wto</parameter> + len, <parameter>wfrom</parameter>, wcsnlen (<parameter>wfrom</parameter>, <parameter>size</parameter>) * sizeof (wchar_t));
  <parameter>wto</parameter>[len + wcsnlen (<parameter>wfrom</parameter>, <parameter>size</parameter>)] = L'\0';
  return <parameter>wto</parameter>;
}
</screen>
   </example>
   <para>
    Dizgelerin üst üste binmesi durumu için bu işlevin davranışı tanımlanmamıştır.
   </para>
   <para>
    <link linkend="glibc-poor-choice-for-text">Aşağıda da belirtildiği gibi</link>, bu işlev genellikle metin işlemleri için kötü seçimdir. <link linkend="glibc-strcat-performance-issues">Ayrıca, evvelce belirtildiği gibi</link>, bu işlevin önemli başarım sorunları vardır.
   </para>
   <header>&wchar.h;</header>
  </csynopsis>
  <note xml:id="glibc-poor-choice-for-text">
   <title>Kırpıcı metin işlevleri olarak kötü seçimler</title>
   <para>
    Bu işlevler dizgeleri veya geniş dizgeleri sonlandırmadan kesebildiğinden, metin işlemek için genellikle yetersiz seçimlerdir. Bu işlevler çok baytlı dizgeleri kopyalarken veya birleştirirken, çok baytlı bir karakteri baytları arasından kesip geçersiz çok baytlı bir dizge döndürebilir. Çok baytlı veya geniş dizgeler birleştirilirken veya kırpılırken, dizgenin bir birleşik veya geniş karakterin ilk baytından sonra kesilmesiyle çıktı bozuk bir karakter içerebilir. Bu işlevler,tek baytlı karakter dizgeleri işlenirken bile hatalara neden olabilir: örneğin, ASCII kullanıcı adını elde etmeye çalışırken, kesik bir ad başka bir kullanıcının adıyla sonuçlanabilir.
   </para>
   <para>
    Bazı tampon taşmaları, kopyalama işlevlerine yapılan çağrılar, kesme işlevlerine yapılan çağrılarla değiştirilerek önlenebilse bile, tampon taşmalarında bir yazılımın güvenle sonlandırmasını sağlayan GCC'nin <option>-fcheck-pointer-bounds</option> ve <option>-fsanitize=</option><replaceable>adres</replaceable> komut satırı seçenekleri gibi genellikle daha kolay ve daha güvenli özdevinimli teknikler de vardır. Bkz.  <citation>GCC Kullanımı</citation> - <link xl:href="https://gcc.gnu.org/onlinedocs/gcc/Debugging-Options.html#Debugging-Options">Yazılımlarda veya GCC'de Hata Ayıklamak için Seçenekler</link>.  Kesme işlevleri, normalde özdevinimli tekniklerle yakalanacak uygulama hatalarını maskeleyebileceğinden, bu işlevler yalnızca uygulama, kesme işlemini gerektirdiğinde kullanılmalıdır.
   </para>
  </note>
  <note>
   <para>
    GNU yazılımları normal dizgeleri ve geniş dizgeleri gelişigüzel boyutlardan kesmemelidir. Bkz.<citation>GNU Kodlama Standartları</citation> - <link xl:href="https://www.gnu.org/prep/standards/standards.html#Semantics">Güçlü Uygulamalar Yazmak</link>. Özdevimli bellek tahsisi kullanımı dizge kırpma işlevlerini kullanmaktan çok daha güvenlidir (bkz. <xref linkend="glibc-Unconstrained-Allocation"/> ve dizge oluşturmakta kullanılan <function>strdup</function> ve <function>asprintf</function> gibi işlevler.
   </para>
  </note>
 </chapter>

 <chapter xml:id="glibc-String-Array-Comparison">
  <title>Dizi/Dizge Karşılaştırması</title>
  <titleabbrev>Bayt seviyesi ile karakter seviyesi işlevlerin kıyaslanması.</titleabbrev>
  <para>
   <indexterm linkend="glibc-cp"><primary>dizi ve dizgelerin karşılaştırması</primary></indexterm>
   <indexterm linkend="glibc-cp"><primary>dizge karşılaştırma işlevleri</primary></indexterm>
   <indexterm linkend="glibc-cp"><primary>dizi karşılaştırma işlevleri</primary></indexterm>
   <indexterm linkend="glibc-cp"><primary>dizgelerde öngörülebilirlik</primary></indexterm>
   <indexterm linkend="glibc-cp"><primary>dizilerde öngörülebilirlik</primary></indexterm>
   Bu kısımdaki işlevler dizi ve dizge içerikleri üzerinde karşılaştırmalar yapmak için kullanılabilir. Eşitliğin denetlenmesi kadar, ayrıca sıralama işlevleri olarak da kullanılabilir. Bunun bir örneği olarak <xref linkend="glibc-Searching-and-Sorting"/> bölümüne bakılabilir.
  </para>
  <para>
   C'deki çoğu karşılaştırma işleminin aksine, dizge karşılaştırma işlevleri dizgelerin eşitliğinin varlığında değil <replaceable>yokluğunda</replaceable> sıfırdan farklı bir değer ile döner. İmin değeri eşdeğer olmayan dizgelerin ilk bölümünün göreli sırasına bağlıdır: Bir negatif değer ilk dizgenin ikincisinden "küçük", pozitif bir değer ise "büyük" olduğunu gösterir.
  </para>
  <para>
   Bu işlevler çoğunlukla sadece eşitlik denetiminde kullanılırlar. Bu, ifade yazım kurallarına uygun olarak <code>!&nbsp;strcmp&nbsp;(s1,&nbsp;s2)</code> gibi bir ifade ile yapılır.
   <indexterm linkend="glibc-pg"><primary>string.h</primary></indexterm>
  </para>
  <para>
   Bu işlevlerin tümü &string.h; başlık dosyasında bildirilmiştir.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-memcmp"><primary>memcmp</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-memcmp"><primary>diziler</primary><secondary>karşılaştırma</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>memcmp</function></csname>
    <csparam><ptr>const&#160;void</ptr><parameter>a1</parameter></csparam>
    <csparam><ptr>const&#160;void</ptr><parameter>a2</parameter></csparam>
    <csparam><type>size_t</type><parameter>size</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <code>memcmp</code>  işlevi belleğin <parameter>a1</parameter>'de başlayan <parameter>size</parameter> baytı ile <parameter>a2</parameter>'de başlayan <parameter>size</parameter> baytını karşılaştırır. Dönen değer, ilk farklı bayt çifti arasındaki farkın işaretine bağlıdır (önce <type>unsigned char</type> türünden nesneler olarak yorumlanır, sonra da <type>int</type> türüne terfi ettirilir).
   </para>
   <para>
    <parameter>size</parameter> baytlık iki içerik aynı ise işlev <code>0</code> ile döner.
   </para>
   <header>&string.h;</header>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-wmemcmp"><primary>wmemcmp</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-wmemcmp"><primary>geniş dizgeler</primary><secondary>karşılaştırma</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>wmemcmp</function></csname>
    <csparam><ptr>const&#160;wchar_t</ptr><parameter>a1</parameter></csparam>
    <csparam><ptr>const&#160;wchar_t</ptr><parameter>a2</parameter></csparam>
    <csparam><type>size_t</type><parameter>size</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <code>wmemcmp</code> işlevi <parameter>a1</parameter>'de başlayan <parameter>size</parameter> geniş karakter ile <parameter>a2</parameter>'de başlayan <parameter>size</parameter> geniş karakteri karşılaştırır. <parameter>a1</parameter>’deki <parameter>a2</parameter>’dekinden farklı ilk geniş karakterin <parameter>a2</parameter>’dekinden küçük ya da büyük olmasına bağlı olarak sıfırdan küçük ya da büyük bir değerle döner.
   </para>
   <para>
    <parameter>size</parameter> geniş karakterlik iki içerik aynı ise işlev <code>0</code> ile döner.
   </para>
   <header>&string.h;</header>
  </csynopsis>
  <para>
   Keyfi değerli dizilerde <function>memcmp</function> işlevi çoğunlukla eşitlik denetiminde kullanılır. Genellikle, bayt dizileri dışındaki dizilerde bayt seviyesinde bir karşılaştırma anlamı değildir. Örneğin gerçek sayılardan oluşan dizilerin bayt seviyesinde karşılaştırılması gerçek sayıların değerleri arasındaki ilişki hakkında hiçbir şey söyleyemez.
  </para>
  <para>
   <function>wmemcmp</function> işlevi, bir defada <code>sizeof (wchar_t)</code> bayta baktığından ve bunların sayısı sisteme bağımlı olduğundan aslında sadece <type>wchar_t</type> türünde dizileri karşılaştırmakta yararlıdır.
  </para>
  <para>
   Ayrıca <function>memcmp</function> işlevini, hizalama gereksinimlerinden dolayı aralarında boşluk bırakılmış yapı nesneleri, sonlarında fazladan boşluk bulunan birleşik yapılar ve tahsis edilmiş yere göre küçük olduklarından sonunda fazladan boşluk bulunan dizgeler gibi "delikler" içeren nesneleri karşılaştırırken dikkatli olunmalıdır. Bu "delikler"in içerikleri düzensizdir ve bayt seviyesinden karşılaştırmalar tuhaf sonuçlara sebep olabilir. Daha öngörülebilir sonuçlar için doğrudan öğe bazında karşılaştırma yapılmalıdır.
  </para>
  <example>
   <para>
    Aşağıdaki gibi bir yapı türü tanımında:
   </para>
   <screen>struct foo
  {
    unsigned char tag;
    union
      {
        double f;
        long i;
        char *p;
      } value;
  };
</screen>
   <para>
    <code>struct foo</code> türündeki gibi nesneleri <function>memcmp</function> ile karşılaştırmak yerine özelleştirilmiş karşılaştırma işlevlerinin yazılması tercih edilmelidir.
   </para>
  </example>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-strcmp"><primary>strcmp</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-strcmp"><primary>dizgeler</primary><secondary>karşılaştırma</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>strcmp</function></csname>
    <csparam><ptr>const&#160;char</ptr><parameter>s1</parameter></csparam>
    <csparam><ptr>const&#160;char</ptr><parameter>s2</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <code>strcmp</code> işlevi <parameter>s1</parameter> ve <parameter>s2</parameter> dizgelerini karşılaştırır. Dönen değer, ilk farklı karakter çifti arasındaki farkın işaretine bağlıdır (önce <type>unsigned char</type> türünden nesneler olarak yorumlanır, sonra da <type>int</type> türüne terfi ettirilir).
   </para>
   <para>
    İki dizgenin içeriği aynı ise <code>strcmp</code> <code>0</code> ile döner.
   </para>
   <para>
    <code>strcmp</code> işlevi tarafından kullanılan sıralamanın bir sonucu olarak, <parameter>s1</parameter> dizgesi <parameter>s2</parameter> dizgesinin ilk alt dizgesi ise <parameter>s1</parameter> dizgesi, <parameter>s2</parameter>’den "küçük" kabul edilir.
   </para>
   <para>
    <code>strcmp</code> işlevi dizgelerin yazıldığı dilin sıralama kurallarını dikkate almaz. Bunların dikkate alınması için <function>strcoll</function> kullanılmalıdır.
   </para>
   <header>&string.h;</header>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-wcscmp"><primary>wcscmp</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-wcscmp"><primary>geniş dizgeler</primary><secondary>karşılaştırma</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>wcscmp</function></csname>
    <csparam><ptr>const&#160;wchar_t</ptr><parameter>ws1</parameter></csparam>
    <csparam><ptr>const&#160;wchar_t</ptr><parameter>ws2</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <code>wcscmp</code> işlevi <parameter>ws1</parameter> geniş dizgesi ile <parameter>ws2</parameter> geniş dizgesini karşılaştırır. <parameter>ws1</parameter>’deki <parameter>ws2</parameter>’dekinden farklı ilk geniş karakterin <parameter>ws2</parameter>’dekinden küçük ya da büyük olmasına bağlı olarak sıfırdan küçük ya da büyük bir değerle döner.
   </para>
   <para>
    İki içerik aynı ise işlev <code>0</code> ile döner.
   </para>
   <para>
    <code>wcscmp</code> işlevi tarafından kullanılan sıralamanın bir sonucu olarak, <parameter>ws1</parameter> dizgesi <parameter>ws2</parameter> dizgesinin ilk alt dizgesi ise <parameter>ws1</parameter> dizgesi, <parameter>ws2</parameter>’den "küçük" kabul edilir.
   </para>
   <para>
    <code>wcscmp</code> işlevi dizgelerin yazıldığı dilin sıralama kurallarını dikkate almaz. Bunların dikkate alınması için <function>wcscoll</function> kullanılmalıdır.
   </para>
   <header>&string.h;</header>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-strcasecmp"><primary>strcasecmp</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-strcasecmp"><primary>dizgeler</primary><secondary>karşılaştırma</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>strcasecmp</function></csname>
    <csparam><ptr>const&#160;char</ptr><parameter>s1</parameter></csparam>
    <csparam><ptr>const&#160;char</ptr><parameter>s2</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe; &locale;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    Bu işlev harf büyüklükleri arasındaki farkları yok sayması dışında <function>strcmp</function> gibidir. Küçük ve büyük harfler arasındaki ilişki o an seçilmiş olan yerele bağlıdır. Standart <code>"C"</code> yerelinde Ä ve ä karakterleri eşleşmez ama, bu karakterleri alfabelerinde kullanan yerellerde eşleşir.
   </para>
   <para>
    <code>strcasecmp</code> BSD'den alınmıştır.
   </para>
   <header>&string.h;</header>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-wcscasecmp"><primary>wcscasecmp</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-wcscasecmp"><primary>geniş dizgeler</primary><secondary>karşılaştırma</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>wcscasecmp</function></csname>
    <csparam><ptr>const&#160;wchar_t</ptr><parameter>ws1</parameter></csparam>
    <csparam><ptr>const&#160;wchar_t</ptr><parameter>ws2</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe; &locale;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    Bu işlev harf büyüklükleri arasındaki farkları yok sayması dışında <function>wcscmp</function> gibidir. Küçük ve büyük harfler arasındaki ilişki o an seçilmiş olan yerele bağlıdır. Standart <code>"C"</code> yerelinde Ä ve ä karakterleri eşleşmez ama, bu karakterleri alfabelerinde kullanan yerellerde eşleşir.
   </para>
   <para>
    <code>strcasecmp</code> GNU oluşumudur.
   </para>
   <header>&string.h;</header>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-strncmp"><primary>strncmp</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-strncmp"><primary>dizgeler</primary><secondary>karşılaştırma</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>strncmp</function></csname>
    <csparam><ptr>const&#160;char</ptr><parameter>s1</parameter></csparam>
    <csparam><ptr>const&#160;char</ptr><parameter>s2</parameter></csparam>
    <csparam><type>size_t</type><parameter>size</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    Bu işlev ilk <parameter>size</parameter> baytın karşılaştırılması dışında <function>strcmp</function> gibidir. Başka bir deyişle, iki dizgenin ilk <parameter>size</parameter> baytı aynıysa işlev sıfırla döner.
   </para>
   <header>&string.h;</header>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-wcsncmp"><primary>wcsncmp</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-wcsncmp"><primary>geniş dizgeler</primary><secondary>karşılaştırma</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>wcsncmp</function></csname>
    <csparam><ptr>const&#160;wchar_t</ptr><parameter>ws1</parameter></csparam>
    <csparam><ptr>const&#160;wchar_t</ptr><parameter>ws2</parameter></csparam>
    <csparam><type>size_t</type><parameter>size</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    Bu işlev ilk <parameter>size</parameter> geniş karakterin karşılaştırılması dışında <function>wcscmp</function> gibidir. Başka bir deyişle, iki dizgenin ilk <parameter>size</parameter> geniş karakteri aynıysa işlev sıfırla döner.
   </para>
   <header>&string.h;</header>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-strncasecmp"><primary>strncasecmp</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-strncasecmp"><primary>dizgeler</primary><secondary>karşılaştırma</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>strncasecmp</function></csname>
    <csparam><ptr>const&#160;char</ptr><parameter>s1</parameter></csparam>
    <csparam><ptr>const&#160;char</ptr><parameter>s2</parameter></csparam>
    <csparam><type>size_t</type><parameter>n</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe; &locale;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    Bu işlev harf büyüklükleri arasındaki farkları yok sayması dışında <function>strncmp</function> gibidir. <function>strcasecmp</function> gibi küçük ve büyük harfler arasındaki ilişki o an seçili olan yerele bağlıdır.
   </para>
   <para>
    <function>strncasecmp</function> işlevi GNU oluşumudur.
   </para>
   <header>&string.h;</header>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-wcsncasecmp"><primary>wcsncasecmp</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-wcsncasecmp"><primary>geniş dizgeler</primary><secondary>karşılaştırma</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>wcsncasecmp</function></csname>
    <csparam><ptr>const&#160;wchar_t</ptr><parameter>ws1</parameter></csparam>
    <csparam><ptr>const&#160;wchar_t</ptr><parameter>ws2</parameter></csparam>
    <csparam><type>size_t</type><parameter>n</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe; &locale;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    Bu işlev harf büyüklükleri arasındaki farkları yok sayması dışında <function>wcsncmp</function> gibidir. <function>wcscasecmp</function> gibi küçük ve büyük harfler arasındaki ilişki o an seçili olan yerele bağlıdır.
   </para>
   <para>
    <function>wcsncasecmp</function> işlevi GNU oluşumudur.
   </para>
   <header>&string.h;</header>
  </csynopsis>
  <example>
   <para>
    Aşağıdaki örnkelerde  <function>strcmp</function> ve <function>strncmp</function> kullanımı gösterilmiştir. Bu örneklerin benzerleri geniş karakterler için de yazılabilir. Bu örneklerde ASCII karakter kümesinin kullanıldığı varsayılmıştır. (Diğer karakter kümeleri -- örn, EBCDIC -- kullanılırsa, harfler farklı sayısal değerlerle ilişkilendirileceğinden dönen değerler ve sıralama farklı olacaktır.)
   </para>
<screen>strcmp ("hello", "hello")
    ⇒ 0    /* <replaceable>Bu iki dizge aynı.</replaceable> */
strcmp ("hello", "Hello")
    ⇒ 32   /* <replaceable>Karşılaştırma harf büyüklüğüne duyarlıdır.</replaceable> */
strcmp ("hello", "world")
    ⇒ -15  /* <code>'h'</code><replaceable> baytı </replaceable><code>'w'</code><replaceable> baytından öncedir.</replaceable> */
strcmp ("hello", "hello, world")
    ⇒ -44  /* <replaceable>Boş karaktere karşılık virgül.</replaceable> */
strncmp ("hello", "hello, world", 5)
    ⇒ 0    /* <replaceable>İlk 5 bayt aynı</replaceable> */
strncmp ("hello, world", "hello, stupid world!!!", 5)
    ⇒ 0    /* <replaceable>İlk 5 bayt aynı.</replaceable> */
</screen>
  </example>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-strverscmp"><primary>strverscmp</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-strverscmp"><primary>dizgeler</primary><secondary>karşılaştırma</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>strverscmp</function></csname>
    <csparam><ptr>const&#160;char</ptr><parameter>s1</parameter></csparam>
    <csparam><ptr>const&#160;char</ptr><parameter>s2</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe; &locale;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <code>strverscmp</code> işlevi <parameter>s1</parameter> ve <parameter>s2</parameter> dizgelerini indis/sürüm numarası içerdiğini varsayarak karşılaştırır. Dönen değer <function>strcmp</function> işlevindeki gibidir. Aslında, dizgeler herhangi bir rakam içermiyorsa işlev, <function>strcmp</function> işlevi gibi davranır (sonucun aynı işaretli olması anlamında).
   </para>
   <para>
    <code>strverscmp</code> işlevinin uyguladığı karşılaştırma algoritması, diğer sürüm karşılaştırma algoritmalarından biraz farklıdır. Gerçeklenim, davranışı aşağıda yaklaşık olarak açıklanan sonlu durum makinesine dayanmaktadır.
   </para>
   <itemizedlist>
    <listitem>
     <para>
      Girdi dizgelerinin her biri, rakamlar ve rakam olmayanlar diye iki diziye bölünmüştür. Bu dizilerde, dizgenin başı ve sonu boş olabilir. Rakamlar <function>isdigit</function> işlevi tarafından belirlenir ve bu nedenle geçerli yerele bağlıdır.
     </para>
    </listitem>
    <listitem>
     <para>
      Karşılaştırma (muhtemelen boş) rakam içermeyen bir dizi karakter ile başlar. Rakamlardan veya rakam olmayanlardan ilk eşleşmeyen çift, karşılaştırmanın sonucunu belirler.
     </para>
    </listitem>
    <listitem>
     <para>
      Her iki dizgede karşılaştırılan rakam içermeyen bölümler, uzunlukları eşitse sözlüksel olarak karşılaştırılır. Uzunluklar farklıysa, rakam içermeyen kısa dizge, hemen ardından gelen girdi dizgesi karakteriyle genişletilir (bu, boş sonlandırıcı olabilir), diğer dizge uzatılmış dizge ile aynı uzunlukta olacak şekilde kesilir ve bu iki dizi abecesel olarak karşılaştırılır. Abecesel karşılaştırma işlevin sonucunu belirler çünkü uzatma karakteri (veya ondan önceki karakterler) diğer girdi dizgesindeki aynı konumdaki karakterden ister istemez farklı olacaktır.
     </para>
    </listitem>
    <listitem>
     <para>
      İki rakam dizgesi için baştaki sıfırlar sayılır (sıfır olabilir). Sonuçlar farklıysa, başında daha fazla sıfır olan dizge diğer dizgeden küçük kabul edilir.
     </para>
    </listitem>
    <listitem>
     <para>
      İki rakam dizgesinin başında sıfır yoksa, dizge uzunlukları karşılaştırılır. Uzunluklar farklıysa uzun dizge daha büyük kabul edilir, uzunluklar aynıysa bunlar abecesayısal olarak karşılaştırılır.
     </para>
    </listitem>
    <listitem>
     <para>
      Her iki rakam dizgesi de sıfırla başlıyorsa ve eşit sayıda sıfıra sahipse, uzunlukları da aynıysa bunlar abecesayısal olarak karşılaştırılır. Uzunluklar farklıysa, kısa dizi, girdi dizesinin sonundaki karakterle uzatılır, diğer dizge aynı uzunlukta kesilir ve her iki dizge abecesayısal olarak karşılaştırılır (yukarıdaki rakamsız dizgede olduğu gibi).
     </para>
    </listitem>
   </itemizedlist>
   <para>
    Baştaki sıfırların ve eşitliği bozan (aslında rakam olmayan/rakam dizgesi boyunca yayılan) uzatma karakterlerinin işlenmesi, diğer sürüm karşılaştırma algoritmalarından farklıdır.
   </para>
   <example>
    <screen>strverscmp ("rakam yok", "rakam yok")
    ⇒ 0    /* <replaceable>davranış strcmp ile aynı.</replaceable> */
strverscmp ("item#99", "item#100")
    ⇒ &lt;0   /* <replaceable>önekler aynı, ama 99 &lt; 100.</replaceable> */
strverscmp ("alpha1", "alpha001")
    ⇒ &gt;0   /* <replaceable>baştaki sıfırların sayısı farklı (0 ve 2).</replaceable> */
strverscmp ("part1_f012", "part1_f01")
    ⇒ &gt;0   /* <replaceable>baştaki sıfırlarla abecesayısal karşılaştırma.</replaceable> */
strverscmp ("foo.009", "foo.0")
    ⇒ &lt;0   /* <replaceable>baştaki sıfırların sayısı farklı (2 ve 1).</replaceable> */
</screen>
   </example>
   <para>
    <code>strverscmp</code> GNU oluşumudur.
   </para>
   <header>&string.h;</header>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-bcmp"><primary>bcmp</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-bcmp"><primary>dizgeler</primary><secondary>karşılaştırma</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>bcmp</function></csname>
    <csparam><ptr>const&#160;void</ptr><parameter>a1</parameter></csparam>
    <csparam><ptr>const&#160;void</ptr><parameter>a2</parameter></csparam>
    <csparam><type>size_t</type><parameter>n</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    Bu işlev BSD'den alınmıştır ve <function>memcmp</function> işlevinin artık kullanımı önerilmeyen takma adıdır.
   </para>
   <header>&string.h;</header>
  </csynopsis>
 </chapter>

 <chapter xml:id="glibc-Collation-Functions">
  <title>Dizgeleri Yerele Özgü Karşılaştırma İşlevleri</title>
  <titleabbrev>Yerele özgü karakter sıralamasına uygun dizge karşılaştırma işlevleri.</titleabbrev>
  <para>
   <indexterm linkend="glibc-cp"><primary>yerele özgü dizge karşılaştırma</primary></indexterm>
   <indexterm linkend="glibc-cp"><primary>geniş dizgeler</primary><secondary>yerele özgü karşılaştırma işlevleri</secondary></indexterm>
   Bazı yerellerde alfabetik sıralama karakter kodlarının sıralamasından farklıdır. Örneğin, Türkçedeki abecesel "<code>CÇD</code>" sıralaması <code>67-199-68</code> karakter kodu sıralamasından farklıdır. Harfler sırf karakter koduna göre sıralansaydı, bazıları sıralamada sona kalacaktı.
  </para>
  <para>
   <indexterm linkend="glibc-pg"><primary>string.h</primary></indexterm>
   <indexterm linkend="glibc-pg"><primary>wchar.h</primary></indexterm>
   &string.h; başlık dosyasında bildirilen <function>strcoll</function> ve <function>strxfrm</function> işlevleri ile &wchar.h;  başlık dosyasında bildirilen <function>wcscoll</function> ve <function>wcsxfrm</function> işlevleri, yerele özgü karakter sıralamasına uygun dizge karşılaştırmalarında kullanılabilir. Bu işlevlerin kullanılacağı yerel, <varname>LC_COLLATE</varname> yerel sınıfına gerekli değer atanarak belirtilebilir. Daha ayrıntılı bilgi için bkz. <xref linkend="glibc-Locales"/>.
   <indexterm linkend="glibc-pg"><primary>string.h</primary></indexterm>
   <indexterm linkend="glibc-pg"><primary>wchar.h</primary></indexterm>
  </para>
  <para>
   Standart C yerelinde karakter sıralaması bakımından <function>strcoll</function> ile <function>strcmp</function> işlevlerinin davranışlarında bir fark yoktur. Benzer olarak  <function>wcscoll</function> ve <function>wcscmp</function> işlevleri de bu bakımdan aynıdır.
  </para>
  <para>
   Bu işlevleri etkin olarak çalıştırmanın yolu çok baytlı bir dizgenin içindeki karakterleri yerelin karakter sıralamasına uygun bir konumlamayla bir bayt sıralamasına dönüştürmektir. Böyle oluşturulmuş bayt sıralamaları ile yerelin karakter sıralamasına uygun olarak dizgeleri karşılaştırmak artık daha kolaydır.
  </para>
  <para>
   <function>strcoll</function> ve <function>wcscoll</function> işlevleri bu dönüşümü karşılaştırma sırasından dolaylı olarak uygular. <function>strxfrm</function> ve <function>wcsxfrm</function> işlevleri ise tam aksine doğrudan doğruya karakter sıralaması/alfabetik sıralama eşleştirmesi yapar. Bir dizge kümesi üzerinde çok sayıda karşılaştırma yapılacaksa önce <function>strxfrm</function> veya <function>wcsxfrm</function> işlevlerini kullanarak dizgeleri bir kerede dönüştürüp ardından <function>strcmp</function> veya <function>wcscmp</function> ile dönüştürülmüş dizgeleri karşılaştırmak daha verimli bir yöntemdir.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-strcoll"><primary>strcoll</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-strcoll"><primary>dizgeler</primary><secondary>yerele uygun karşılaştırma</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>strcoll</function></csname>
    <csparam><ptr>const&#160;char</ptr><parameter>s1</parameter></csparam>
    <csparam><ptr>const&#160;char</ptr><parameter>s2</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe; &locale;</concept>
    <concept>&asunsafe; &heap;</concept>
    <concept>&acunsafe; &mem;</concept>
   </conceptlist>
   <para>
    <code>strcoll</code> işlevi, karakter sıralaması için yerelin karakter sıralamasını (<varname>LC_COLLATE</varname> yereli) kullanması dışında <function>strcmp</function> işlevine benzer. İşlevin bağımsız değişkenleri çok baytlı dizgelerdir.
   </para>
   <header>&string.h;</header>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-wcscoll"><primary>wcscoll</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-wcscoll"><primary>geniş dizgeler</primary><secondary>yerele uygun karşılaştırma</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>wcscoll</function></csname>
    <csparam><ptr>const&#160;wchar_t</ptr><parameter>ws1</parameter></csparam>
    <csparam><ptr>const&#160;wchar_t</ptr><parameter>ws2</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe; &locale;</concept>
    <concept>&asunsafe; &heap;</concept>
    <concept>&acunsafe; &mem;</concept>
   </conceptlist>
   <para>
    <code>wcscoll</code> işlevi, karakter sıralaması için yerelin karakter sıralamasını (<varname>LC_COLLATE</varname> yereli) kullanması dışında <function>wcscmp</function> işlevine benzer.
   </para>
   <header>&wchar.h;</header>
  </csynopsis>
  <example><title><code>qsort</code> ile kullanılan karşılaştırma işlevi</title>
   <para>
    Bu örnekte bir dizge dizisi <function>strcoll</function> ile karşılaştırılarak sıralanmaktadır. Burada gerçek sıralama algoritması yazılmamıştır; bunun için <function>qsort</function> (<xref linkend="glibc-Array-Sort-Function"/>) kullanılmıştır. Buradaki kodun yaptığı iş dizgeler sıralanırken nasıl karşılaştırılacağını göstermektir. (Bu bölümün devamında <function>strxfrm</function> kullanarak bunun daha verimli olarak nasıl yapılacağından ayrıca bahsedilecektir.)
    </para>
    <screen>int
elemanlari_karsilastir (const void *v1, const void *v2)
{
  char * const *p1 = v1;
  char * const *p2 = v2;

  return strcoll (*p1, *p2);
}

/* <replaceable>Burası giriş noktası — yerelin karakter sıralamasını
   kullanarak dizgeleri sıralayan işlev.</replaceable> */

void
sirala (char **dizi, int dizge_sayisi)
{
  /* <replaceable>Dizgeleri karşılaştırarak diziyi sırala.</replaceable> */
  qsort (dizi, dizge_sayisi,
         sizeof (char *), elemanlari_karsilastir);
}
</screen>
  </example>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-strxfrm"><primary>strxfrm</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-strxfrm"><primary>dizgeler</primary><secondary>yerelin harf sıralamasına dönüşüm</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>size_t</type><function>strxfrm</function></csname>
    <csparam><type>char&#160;*restrict</type><parameter>to</parameter></csparam>
    <csparam><type>const&#160;char&#160;*restrict</type><parameter>from</parameter></csparam>
    <csparam><type>size_t</type><parameter>size</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe; &locale;</concept>
    <concept>&asunsafe; &heap;</concept>
    <concept>&acunsafe; &mem;</concept>
   </conceptlist>
   <para>
    <code>strxfrm</code> işlevi, harf sıralaması için seçilmiş olan yerele göre saptanan karşılaştırma dönüşümünü kullanarak <parameter>from</parameter> dizgesini dönüştürür ve dönüştürülen <parameter>size</parameter> baytlık dizgeyi (sonlandırıcı boş bayt dahil) <parameter>to</parameter> dizisine kaydeder.
   </para>
   <para>
    <parameter>from</parameter> dizgesinin <parameter>to</parameter> dizgesine sarkması durumundaki davranış belirlenmemiştir (bkz. <xref linkend="glibc-Copying-Strings-and-Arrays"/>).
   </para>
   <para>
    Dönen değer dönüştürülen dizgenin uzunluğudur. Bu değer <parameter>size</parameter> değerinden etkilenmez, ancak <parameter>size</parameter> bayttan büyük ya da eşitse, dönüştürülen dizge <parameter>to</parameter> dizisine sığmamış, diziye dizgenin sığdığı kadarı kaydedilmiş demektir. Dönüştürülen dizgenin tamamını almak için işlevin daha büyük bir dizi ile tekrar çağrılması gerekir.
   </para>
   <para>
    Dönüştürülmüş dizge verilen dizgeden daha uzun olabileceği gibi daha kısa da olabilir.
   </para>
   <para>
    <parameter>size</parameter> sıfırsa, <parameter>to</parameter> dizisine herhangi bir değer kaydedilmez.  Bu durumda,  <code>strxfrm</code> işlevi sadece dönüştürülmüş dizgenin uzunluğu ile döner. Bu değer, dizinin bellek tahsis boyutunu belirlemekte kullanılabilir. <parameter>size</parameter> sıfır olduğunda <parameter>to</parameter> önemsizdir, boş gösterici bile olabilir.
   </para>
   <header>&string.h;</header>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-wcsxfrm"><primary>wcsxfrm</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-wcsxfrm"><primary>geniş dizgeler</primary><secondary>yerelin harf sıralamasına dönüşüm</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>size_t</type><function>wcsxfrm</function></csname>
    <csparam><type>wchar_t&#160;*restrict</type><parameter>wto</parameter></csparam>
    <csparam><type>const&#160;wchar_t&#160;*restrict</type><parameter>wfrom</parameter></csparam>
    <csparam><type>size_t</type><parameter>size</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe; &locale;</concept>
    <concept>&asunsafe; &heap;</concept>
    <concept>&acunsafe; &mem;</concept>
   </conceptlist>
   <para>
    <code>wcsxfrm</code> işlevi, harf sıralaması için seçilmiş olan yerele göre saptanan karşılaştırma dönüşümünü kullanarak <parameter>wfrom</parameter> dizgesini dönüştürür ve dönüştürülen <parameter>size</parameter> geniş karakterlik dizgeyi (sonlandırıcı boş geniş karakter dahil) <parameter>wto</parameter> dizisine kaydeder.
   </para>
   <para>
    <parameter>wfrom</parameter> geniş dizgesinin <parameter>wto</parameter> dizgesine sarkması durumundaki davranış belirlenmemiştir (bkz. <xref linkend="glibc-Copying-Strings-and-Arrays"/>).
   </para>
   <para>
    Dönen değer dönüştürülen geniş dizgenin uzunluğudur. Bu değer <parameter>size</parameter> değerinden etkilenmez, ancak <parameter>size</parameter> geniş karakterden büyük ya da eşitse, dönüştürülen dizge <parameter>wto</parameter> dizisine sığmamış, diziye geniş dizgenin sığdığı kadarı kaydedilmiş demektir. Dönüştürülen geniş dizgenin tamamını almak için işlevin daha büyük bir dizi ile tekrar çağrılması gerekir.
   </para>
   <para>
    Dönüştürülmüş geniş dizge verilen geniş dizgeden daha uzun olabileceği gibi daha kısa da olabilir.
   </para>
   <para>
    <parameter>size</parameter> sıfırsa, <parameter>wto</parameter> dizisine herhangi bir değer kaydedilmez.  Bu durumda,  <code>wcsxfrm</code> işlevi sadece dönüştürülmüş geniş dizgenin uzunluğu ile döner. Bu değer, dizinin bellek tahsis boyutunu belirlemekte kullanılabilir. <parameter>size</parameter> sıfır olduğunda <parameter>wto</parameter> önemsizdir, boş gösterici bile olabilir.
   </para>
   <header>&wchar.h;</header>
  </csynopsis>
  <example><title><code>struct siralayici</code> dizisini sıralamak için <code>qsort</code> ile kullanılan karşılaştırma işlevi</title>
   <para>
    Buradaki örnekte, çok sayıda karşılaştırma yapılması durumunda <function>strxfrm</function> işlevinin nasıl kullanılacağı gösterilmiştir. Önceki örnekle aynı şeyi yapsa da buradaki daha hızlıdır, çünkü her dizgeye sadece bir kere dönüşüm uygular, diğer dizgelerle kaç defa karşılaştırma yapıldığının önemi yoktur. Çok sayıda dizge olduğunda kazanılan zaman, bellek tahsisi ve serbest bırakılması için harcanan zamandan bile daha büyüktür.
   </para>
   <screen>struct siralayici { char *girdi; char *donusmus; };

int
elemanlari_karsilastir (const void *v1, const void *v2)
{
  const struct siralayici *p1 = v1;
  const struct siralayici *p2 = v2;

  return strcmp (p1-&gt;donusmus, p2-&gt;donusmus);
}

/* <replaceable>Burası giriş noktası — yerelin karakter sıralamasını
   kullanarak dizgeleri sıralayan işlev.</replaceable> */

void
hizli_sirala (char **dizi, int dizge_sayisi)
{
  struct siralayici gecici_dizi[dizge_sayisi];
  int i;

  /* <code>gecici_dizi</code> <replaceable> dizisini ilklendir.
     Her eleman bir girdi dizgesi ve onun dönüştürülmüşünü içersin.</replaceable> */
  for (i = 0; i &lt; dizge_sayisi; i++)
    {
      size_t uzunluk = strlen (dizi[i]) * 2;
      char *donusmus;
      size_t donusmus_uzunluk;

      gecici_dizi[i].girdi = dizi[i];

      /* <replaceable>Önce yeterince büyük bir tamponla dene.</replaceable>  */
      donusmus = (char *) xmalloc (uzunluk);

      /* <code>dizi[i]</code><replaceable> dizisini dönüştür.</replaceable>  */
      donusmus_uzunluk = strxfrm (donusmus, dizi[i], uzunluk);

      /* <replaceable>Tampon yetersizse yeniden boyutlandırıp tekrar dene.</replaceable>  */
      if (donusmus_uzunluk &gt;= uzunluk)
        {
          /* <replaceable>Gerekli belleği tahsis et.
             Sonlandırıcı boş bayt için +1'i unutma.</replaceable>  */
          donusmus = xrealloc (donusmus,
                                  donusmus_uzunluk + 1);

          /* <replaceable>Dönen değerin önemi yok çünkü dönüşmüş
             dizgenin uzunluğu biliniyor.</replaceable>  */
          (void) strxfrm (donusmus, dizi[i],
                          donusmus_uzunluk + 1);
        }

      gecici_dizi[i].donusmus = donusmus;
    }

  /* <replaceable>Dönüştürülmüş dizgeleri karşılaştırarak geçici diziyi sırala.</replaceable> */
  qsort (gecici_dizi, dizge_sayisi,
         sizeof (struct siralayici), elemanlari_karsilastir);

  /* <replaceable>Elemanları geri, kalıcı diziye sıralı olarak yerleştir.</replaceable> */
  for (i = 0; i &lt; dizge_sayisi; i++)
    dizi[i] = gecici_dizi[i].girdi;

  /* <replaceable>tahsis edilen dizgeleri serbest bırak.</replaceable> */
  for (i = 0; i &lt; dizge_sayisi; i++)
    free (gecici_dizi[i].donusmus);
}
</screen>
   <para>
    Bu kodun geniş karakterli sürümünü ilgilendiren parçası şöyle olurdu:
   </para>
   <screen>void
hizli_sirala (wchar_t **dizi, int dizge_sayisi)
{
  …
      /* <code>dizi[i]</code><replaceable> dizisini dönüştür.</replaceable>  */
      donusmus_uzunluk = wcsxfrm (donusmus, dizi[i], uzunluk);

      /* <replaceable>Tampon yetersizse yeniden boyutlandırıp tekrar dene.</replaceable>  */
      if (donusmus_uzunluk &gt;= uzunluk)
        {
          /* <replaceable>Gerekli belleği tahsis et.
             Sonlandırıcı</replaceable> <code>L'\0'</code> <replaceable>geniş karakteri unutma.</replaceable>  */
          donusmus = xreallocarray (donusmus,
                                       donusmus_uzunluk + 1,
                                       sizeof *donusmus);

          /* <replaceable>Dönen değerin önemi yok çünkü dönüşmüş
             dizgenin uzunluğu biliniyor.</replaceable>  */
          (void) wcsxfrm (donusmus, dizi[i],
                          donusmus_uzunluk + 1);
        }
  …
</screen>
   <para>
    <function>realloc</function> çağrısındaki ek olarak yapılan <code>sizeof (wchar_t)</code> ile çarpma işlemine dikkat!
   </para>
  </example>
  <note><title>Uyumluluk Bilgisi</title>
   <para>
    Dizgelerin yerele özgü harf sıralama işlevleri &isoc;90'nın yeni bir özelliğidir. Daha eski C oluşumlarında buna eşdeğer bir özellik yoktur. Geniş karakter sürümü ise &isoc;90'nın 1. düzeltmesinde yer almıştır.
   </para>
  </note>
 </chapter>
 <chapter xml:id="glibc-Search-Functions">
  <title>Arama İşlevleri</title>
  <titleabbrev>Belli bir elemanın veya bir alt dizgenin aranması.</titleabbrev>
  <para>
   Bu kısımda dizgeler ve diziler üzerinde çeşitli aramalar yapan kütüphane işlevleri açıklanmıştır. Bu işlevler &string.h; başlık dosyasında bildirilmiştir.
   <indexterm linkend="glibc-pg"><primary>string.h</primary></indexterm>
   <indexterm linkend="glibc-cp"><primary>dizgeler</primary><secondary>arama</secondary></indexterm>
   <indexterm linkend="glibc-cp"><primary>dizge arama işlevleri</primary></indexterm>
  </para>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-memchr"><primary>memchr</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-memchr"><primary>dizgeler</primary><secondary>samanlıkta iğne</secondary></indexterm>
   <csproto type="işlev">
    <csname><ptr>void</ptr><function>memchr</function></csname>
    <csparam><ptr>const&#160;void</ptr><parameter>block</parameter></csparam>
    <csparam><type>int</type><parameter>c</parameter></csparam>
    <csparam><type>size_t</type><parameter>size</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    Bu işlev <parameter>block</parameter> adresinden başlayan nesnenin (samanlık) ilk <parameter>size</parameter> baytı içindeki ilk <parameter>c</parameter>  (<command>unsigned char</command>'a dönüştürülmüş) baytını (iğneyi) bulur. Dönen değer baytın konumunu içeren bir göstericidir. <parameter>c</parameter> baytı bulunamazsa boş gösterici döner.
   </para>
   <header>&string.h;</header>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-wmemchr"><primary>wmemchr</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-wmemchr"><primary>geniş dizgeler</primary><secondary>samanlıkta iğne</secondary></indexterm>
   <csproto type="işlev">
    <csname><ptr>wchar_t</ptr><function>wmemchr</function></csname>
    <csparam><ptr>const&#160;wchar_t</ptr><parameter>block</parameter></csparam>
    <csparam><type>wchar_t</type><parameter>wc</parameter></csparam>
    <csparam><type>size_t</type><parameter>size</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    Bu işlev <parameter>block</parameter> adresinden başlayan nesnenin (samanlık) ilk <parameter>size</parameter> geniş karakteri içindeki ilk <parameter>wc</parameter>  (<command>unsigned char</command>'a dönüştürülmüş) geniş karakterini (iğneyi) bulur. Dönen değer geniş karakterin konumuna göstericidir. <parameter>wc</parameter> bulunamazsa boş gösterici döner.
   </para>
   <header>&string.h;</header>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-rawmemchr"><primary>rawmemchr</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-rawmemchr"><primary>dizgeler</primary><secondary>arama</secondary></indexterm>
   <csproto type="işlev">
    <csname><ptr>void</ptr><function>rawmemchr</function></csname>
    <csparam><ptr>const&#160;void</ptr><parameter>block</parameter></csparam>
    <csparam><type>int</type><parameter>c</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <code>memchr</code> işlevi çoğunlukla, bağımsız değişkenlerle belirtilen bellek diliminde <parameter>c</parameter> baytının bulunduğu bilinerek kullanılır. Bu işlevle uygulanan sınamalar (dilim sonunun aşılıp aşılmadığına bakılması gibi) çalışma anında yapıldığından <parameter>size</parameter> bağımsız değişkeni gerekli değildir.
   </para>
   <para>
    <code>rawmemchr</code> işlevi şaşırtıcı sıklıkla karşılaşılan bu durum için vardır. Arayüzü, <parameter>size</parameter> bağımsız değişkeninin bulunmayışı dışında <function>memchr</function> işlevine benzer. Yazılımcı, <parameter>c</parameter> karakterinin <parameter>block</parameter> içinde mevcut olduğu kabulünde hataya düşerse, işlev bellek diliminin sonunu aşacaktır. Bu durum için sonuç belirsizdir. Aksi takdirde bayt konumuna gösterici döner.
   </para>
   <para>
    Bu işlev özellikle bir dizgenin sonu bulunmak istendiğinde kullanılır. Tüm dizgeler boş baytla sonlandırılmış olduğundan,
   </para>
   <screen>rawmemchr (str, '\0')</screen>
   <para>
    gibi bir çağrı dizgenin sonunu asla aşmayacaktır.
   </para>
   <para>
    Bu işlev bir GNU oluşumudur.
   </para>
   <header>&string.h;</header>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-memrchr"><primary>memrchr</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-memrchr"><primary>dizgeler</primary><secondary>arama</secondary></indexterm>
   <csproto type="işlev">
    <csname><ptr>void</ptr><function>memrchr</function></csname>
    <csparam><ptr>const&#160;void</ptr><parameter>block</parameter></csparam>
    <csparam><type>int</type><parameter>c</parameter></csparam>
    <csparam><type>size_t</type><parameter>size</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <code>memrchr</code> işlevi <parameter>block</parameter> ve <parameter>size</parameter> ile belirtilen bellek dilimini sondan başa doğru araması dışında, aramayı baştan sona doğru yapan <function>memrchr</function> gibidir.
   </para>
   <para>Bu işlev GNU oluşumudur.</para>
   <header>&string.h;</header>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-strchr"><primary>strchr</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-strchr"><primary>dizgeler</primary><secondary>karakter arama</secondary></indexterm>
   <csproto type="işlev">
    <csname><ptr>char</ptr><function>strchr</function></csname>
    <csparam><ptr>const&#160;char</ptr><parameter>string</parameter></csparam>
    <csparam><type>int</type><parameter>c</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <code>strchr</code> işlevi, <parameter>string</parameter> dizgesi içinde başlangıçtan itibaren <parameter>c</parameter> karakterinin ilk konumunu (<type>char</type> türüne dönüştürerek) bulursa karaktere gösterici ile döner, bulamazsa boş gösterici ile döner.
   </para>
   <example>
<screen>strchr ("hello, world", 'l')
    ⇒ "llo, world"
strchr ("hello, world", '?')
    ⇒ NULL
</screen>
   </example>
   <para>
    Sonlandırıcı boş bayt dizgenin bir parçası olarak ele alındığından, <parameter>c</parameter> bağımsız değişkenine <code>'\0'</code> belirterek dizge sonuna gösterici alınabilir.
   </para>
   <para>
    İşlev aranan baytı bulamadığında boş gösterici döndürdüğünden, sonlandırıcı boş baytın konumunu bilinemeyecektir. Bu bilginin gerektiği durumlarda ikinci bir çağrı yapmaktansa <function>strchrnul</function> kullanmak daha iyidir (ama daha az taşınabilirdir).
   </para>
   <header>&string.h;</header>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-wcschr"><primary>wcschr</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-wcschr"><primary>geniş dizgeler</primary><secondary>geniş karakter arama</secondary></indexterm>
   <csproto type="işlev">
    <csname><ptr>wchar_t</ptr><function>wcschr</function></csname>
    <csparam><ptr>const&#160;wchar_t</ptr><parameter>wstring</parameter></csparam>
    <csparam><type>wchar_t</type><parameter>wc</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <code>wcschr</code> işlevi, <parameter>wstring</parameter> geniş dizgesi içinde başlangıçtan itibaren <parameter>wc</parameter> geniş karakterinin ilk konumunu bulursa geniş karaktere gösterici ile döner, bulamazsa boş gösterici ile döner.
   </para>
   <para>
    Sonlandırıcı boş geniş karakter dizgenin bir parçası olarak ele alındığından, <parameter>wc</parameter> bağımsız değişkenine <code>'\0'</code> belirterek geniş dizgenin sonuna gösterici alınabilir. Böyle durumlarda ikinci bir çağrı yapmaktansa <function>wcschrnul</function> kullanmak daha iyidir (ama daha az taşınabilirdir).
   </para>
   <header>&wchar.h;</header>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-strchrnul"><primary>strchrnul</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-strchrnul"><primary>dizgeler</primary><secondary>boş baytı da aramak</secondary></indexterm>
   <csproto type="işlev">
    <csname><ptr>char</ptr><function>strchrnul</function></csname>
    <csparam><ptr>const&#160;char</ptr><parameter>string</parameter></csparam>
    <csparam><type>int</type><parameter>c</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <code>strchrnul</code> aranan baytı bulamadığı takdirde dizgeyi sonlandıran boş bayta gösterici döndürmesi dışında <function>strchr</function> ile aynıdır.
   </para>
   <para>Bu işlev GNU oluşumudur.</para>
   <header>&string.h;</header>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-wcschrnul"><primary>wcschrnul</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-wcschrnul"><primary>geniş dizgeler</primary><secondary>sonlandırıcıyı da arama</secondary></indexterm>
   <csproto type="işlev">
    <csname><ptr>wchar_t</ptr><function>wcschrnul</function></csname>
    <csparam><ptr>const&#160;wchar_t</ptr><parameter>wstring</parameter></csparam>
    <csparam><type>wchar_t</type><parameter>wc</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <code>wcschrnul</code> aranan geniş karakteri bulamadığı takdirde dizgeyi sonlandıran boş geniş karaktere gösterici döndürmesi dışında <function>wcschr</function> ile aynıdır.
   </para>
   <para>Bu işlev GNU oluşumudur.</para>
   <header>&wchar.h;</header>
  </csynopsis>
  <para>
   <function>strchr</function> işlevinin kullanışlı ama sıradışı bir kullanımı da dizgeyi sonlandıran boş bayta gösterici istenmesi durumudur. Bunu yapmanın kolay bir yolu vardır:
  </para>
  <para><code>s += strlen (s);</code></para>
  <para>
   Bu oldukça iyi bir çözüm gibi görünürse de toplama işlemi, <function>strlen</function> ile zaten yapılan işlemin tekrarlanmasını sağlar. Daha iyi bir çözüm şöyle olurdu:
  </para>
  <para><code>s = strchr (s, '\0');</code></para>
  <para>
   <function>strchr</function> işlevinin ikinci bağımsız değişkeni için bir sınırlama olmadığından burada boş bayt belirtilebilir. Görünüşe göre <function>strchr</function> çıkışta iki duruma baktığından <function>strlen</function> işlevine göre daha çok işlem yapacaktır. Bu doğru. Ama GNU C kütüphanesinde <function>strchr</function> işlevi özel olarak hız için en iyilenerek gerçeklenmiştir.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-strrchr"><primary>strrchr</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-strrchr"><primary>dizgeler</primary><secondary>sondan başa arama</secondary></indexterm>
   <csproto type="işlev">
    <csname><ptr>char</ptr><function>strrchr</function></csname>
    <csparam><ptr>const&#160;char</ptr><parameter>string</parameter></csparam>
    <csparam><type>int</type><parameter>c</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <code>strrchr</code> işlevi, <parameter>string</parameter> dizgesini sondan başa doğru araması dışında <function>strchr</function> işlevine benzer.
   </para>
   <example>
<screen>strrchr ("hello, world", 'l')
    ⇒ "ld"
</screen>
   </example>
   <header>&string.h;</header>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-wcsrchr"><primary>wcsrchr</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-wcsrchr"><primary>geniş dizgeler</primary><secondary>sondan başa arama</secondary></indexterm>
   <csproto type="işlev">
    <csname><ptr>wchar_t</ptr><function>wcsrchr</function></csname>
    <csparam><ptr>const&#160;wchar_t</ptr><parameter>wstring</parameter></csparam>
    <csparam><type>wchar_t</type><parameter>wc</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <code>wcsrchr</code> işlevi, <parameter>wstring</parameter> geniş dizgesini sondan başa doğru araması dışında <function>wcschr</function> işlevine benzer.
   </para>
   <header>&wchar.h;</header>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-strstr"><primary>strstr</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-strstr"><primary>dizgeler</primary><secondary>samanlıkta iğne</secondary></indexterm>
   <csproto type="işlev">
    <csname><ptr>char</ptr><function>strstr</function></csname>
    <csparam><ptr>const&#160;char</ptr><parameter>haystack</parameter></csparam>
    <csparam><ptr>const&#160;char</ptr><parameter>needle</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <parameter>haystack</parameter> dizgesi içinde tek bir bayt yerine <parameter>needle</parameter> alt dizgesini araması dışında <function>strchr</function> gibidir. <parameter>haystack</parameter> içinde <parameter>needle</parameter> bulunduğunda ilk bayta gösterici döner, bulunamazsa boş gösterici döner. <parameter>needle</parameter> boş dizge olursa işlev <parameter>haystack</parameter> ile döner.
   </para>
   <example>
    <screen>strstr ("hello, world", "l")
    ⇒ "llo, world"
strstr ("hello, world", "wo")
    ⇒ "world"
</screen>
   </example>
   <header>&string.h;</header>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-wcsstr"><primary>wcsstr</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-wcsstr"><primary>geniş dizgeler</primary><secondary>samanlıkta iğne</secondary></indexterm>
   <csproto type="işlev">
    <csname><ptr>wchar_t</ptr><function>wcsstr</function></csname>
    <csparam><ptr>const&#160;wchar_t</ptr><parameter>haystack</parameter></csparam>
    <csparam><ptr>const&#160;wchar_t</ptr><parameter>needle</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <parameter>haystack</parameter> geniş dizgesi içinde geniş karakter yerine <parameter>needle</parameter> alt geniş dizgesini araması dışında <function>wcschr</function> gibidir. <parameter>haystack</parameter> içinde <parameter>needle</parameter> bulunduğunda ilk geniş karakterine gösterici döner, bulunamazsa boş gösterici döner. <parameter>needle</parameter> boş dizge olursa işlev <parameter>haystack</parameter> ile döner.
   </para>
   <header>&wchar.h;</header>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-wcswcs"><primary>wcswcs</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-wcswcs"><primary>geniş dizgeler</primary><secondary>samanlıkta iğne</secondary></indexterm>
   <csproto type="işlev">
    <csname><ptr>wchar_t</ptr><function>wcswcs</function></csname>
    <csparam><ptr>const&#160;wchar_t</ptr><parameter>haystack</parameter></csparam>
    <csparam><ptr>const&#160;wchar_t</ptr><parameter>needle</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <function>wcsstr</function> işlevinin eski ve artık kullanılmayan bir benzeridir. İşlevin ismi ilk olarak, &isoc;90 standardının 1. düzeltmesinden önce X/Open Taşınabilirlik Kılavuzunda kullanılmıştı.
   </para>
   <header>&wchar.h;</header>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-strcasestr"><primary>strcasestr</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-strcasestr"><primary>dizgeler</primary><secondary>arama</secondary></indexterm>
   <csproto type="işlev">
    <csname><ptr>char</ptr><function>strcasestr</function></csname>
    <csparam><ptr>const&#160;char</ptr><parameter>haystack</parameter></csparam>
    <csparam><ptr>const&#160;char</ptr><parameter>needle</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe; &locale;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    Arama yaparken harf büyüklüğünü gözardı etmesi dışında <function>strstr</function> işlevi gibidir. <function>strcasecmp</function> işlevindeki gibi büyük ve küçük harflerin birbirleriyle ilişkileri yerele bağlıdır ve bağımsız değişkenlerin ikisi de çok baytlı dizgelerdir.
   </para>
   <example>
    <screen>strcasestr ("hello, world", "L")
    ⇒ "llo, world"
strcasestr ("hello, World", "wo")
    ⇒ "World"
</screen>
   </example>
   <header>&string.h;</header>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-memmem"><primary>memmem</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-memmem"><primary>diziler</primary><secondary>alt dizi arama</secondary></indexterm>
   <csproto type="işlev">
    <csname><ptr>void</ptr><function>memmem</function></csname>
    <csparam><ptr>const&#160;void</ptr><parameter>haystack</parameter></csparam>
    <csparam><type>size_t</type><parameter>haystack-len</parameter></csparam>
    <csparam><ptr>const&#160;void</ptr><parameter>needle</parameter></csparam>
    <csparam><type>size_t</type><parameter>needle-len</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <function>strstr</function> işlevi gibidir, ama <parameter>needle</parameter> ve <parameter>haystack</parameter> birer boş bayt sonlandırmalı dizge değil birer bayt dizisidir, <parameter>haystack-len</parameter> ve <parameter>needle-len</parameter> bunların uzunluklarıdır.
   </para>
   <para>Bu işlev GNU oluşumudur.</para>
   <header>&string.h;</header>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-strspn"><primary>strspn</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-strspn"><primary>dizgeler</primary><secondary>en kısa ters kiriş</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>size_t</type><function>strspn</function></csname>
    <csparam><ptr>const&#160;char</ptr><parameter>string</parameter></csparam>
    <csparam><ptr>const&#160;char</ptr><parameter>skipset</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <code>strspn</code> işlevi ("string span" kısaltmasıdır), <parameter>string</parameter> içinde <parameter>skipset</parameter> dizgesi ile belirtilen baytlardan birinin bulunması durumunda, bulunan baytın <parameter>skipset</parameter> içinde, bulunduğu ilk alt dizgenin uzunluğu ile döner. <parameter>skipset</parameter> dizgesindeki baytların sırasının önemi yoktur.
   </para>
   <example>
<screen>strspn ("hello, world", "abcdefghijklmnopqrstuvwxyz")
    ⇒ 5
</screen>
   </example>
   <para>
    Çok baytlı dizgelerde birden fazla bayttan oluşan karakterlerin baytları ayrı ayrı ele alınmaz. Bu işlevde baytlar ayrı ayrı ele alınır. İşlev yerelden bağımsızdır.
   </para>
   <header>&string.h;</header>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-wcsspn"><primary>wcsspn</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-wcsspn"><primary>geniş dizgeler</primary><secondary>en kısa ters kiriş</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>size_t</type><function>wcsspn</function></csname>
    <csparam><ptr>const&#160;wchar_t</ptr><parameter>wstring</parameter></csparam>
    <csparam><ptr>const&#160;wchar_t</ptr><parameter>skipset</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <code>wcsspn</code> işlevi ("wide character string span" kısaltmasıdır), <parameter>wstring</parameter> içinde <parameter>skipset</parameter> geniş dizgesi ile belirtilen geniş karakterlerden birinin bulunması durumunda, bulunan geniş karakterin <parameter>skipset</parameter> içinde, bulunduğu ilk geniş alt dizgenin uzunluğu ile döner. <parameter>skipset</parameter> dizgesindeki geniş karakterlerin sırasının önemi yoktur.
   </para>
   <header>&wchar.h;</header>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-strcspn"><primary>strcspn</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-strcspn"><primary>dizgeler</primary><secondary>en kısa kiriş</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>size_t</type><function>strcspn</function></csname>
    <csparam><ptr>const&#160;char</ptr><parameter>string</parameter></csparam>
    <csparam><ptr>const&#160;char</ptr><parameter>stopset</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <code>strcspn</code> işlevi ("string complement span" kısaltmasıdır), <parameter>string</parameter> içinde <parameter>stopset</parameter> dizgesi ile belirtilen baytlardan birinin bulunması durumunda, <parameter>string</parameter> içinde, aranan baytları içermeyen ilk alt dizgenin uzunluğu ile döner. Başka bir deyişle, <parameter>string</parameter> dizgesinin <parameter>stopset</parameter> üyesi ilk karakterinin konumunu döndürür.
   </para>
   <example>
    <screen>strcspn ("hello, world", " \t\n,.;!?")
    ⇒ 5
</screen>
   </example>
   <para>
    Çok baytlı dizgelerde birden fazla bayttan oluşan karakterlerin baytları ayrı ayrı ele alınmaz. Bu işlevde baytlar ayrı ayrı ele alınır. İşlev yerelden bağımsızdır.
   </para>
   <header>&string.h;</header>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-wcscspn"><primary>wcscspn</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-wcscspn"><primary>geniş dizgeler</primary><secondary>en kısa kiriş</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>size_t</type><function>wcscspn</function></csname>
    <csparam><ptr>const&#160;wchar_t</ptr><parameter>wstring</parameter></csparam>
    <csparam><ptr>const&#160;wchar_t</ptr><parameter>stopset</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <code>wcscspn</code> işlevi ("wide character string complement span" kısaltmasıdır), <parameter>wstring</parameter> içinde <parameter>stopset</parameter> dizgesi ile belirtilen geniş karakterlerden birinin bulunması durumunda, <parameter>wstring</parameter> içinde, aranan geniş karakterleri içermeyen ilk geniş alt dizgenin uzunluğu ile döner. Başka bir deyişle, <parameter>wstring</parameter> geniş dizgesinin <parameter>stopset</parameter> üyesi ilk geniş karakterinin konumunu döndürür.
   </para>
   <header>&wchar.h;</header>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-strpbrk"><primary>strpbrk</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-strpbrk"><primary>dizgeler</primary><secondary>en kısa kiriş</secondary></indexterm>
   <csproto type="işlev">
    <csname><ptr>char</ptr><function>strpbrk</function></csname>
    <csparam><ptr>const&#160;char</ptr><parameter>string</parameter></csparam>
    <csparam><ptr>const&#160;char</ptr><parameter>stopset</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <code>strpbrk</code> işlevi (“string pointer break” kısaltmasıdır), <parameter>string</parameter> içinde, <parameter>stopset</parameter> dizgesi ile belirtilen karakterlerden biriyle başlayan dizgeye gösterici ile dönmesi dışında <function>strcspn</function> gibidir. <parameter>stopset</parameter> içindeki karakterlerden biri bulunamazsa boş gösterici döner.
   </para>
   <example>
    <screen>strpbrk ("hello, world", " \t\n,.;!?")
    ⇒ ", world"
</screen>
   </example>
   <para>
    Çok baytlı dizgelerde birden fazla bayttan oluşan karakterlerin baytları ayrı ayrı ele alınmaz. Bu işlevde baytlar ayrı ayrı ele alınır. İşlev yerelden bağımsızdır.
   </para>
   <header>&string.h;</header>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-wcspbrk"><primary>wcspbrk</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-wcspbrk"><primary>geniş dizgeler</primary><secondary>en kısa kiriş</secondary></indexterm>
   <csproto type="işlev">
    <csname><ptr>wchar_t</ptr><function>wcspbrk</function></csname>
    <csparam><ptr>const&#160;wchar_t</ptr><parameter>wstring</parameter></csparam>
    <csparam><ptr>const&#160;wchar_t</ptr><parameter>stopset</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <code>wcspbrk</code> işlevi (“wide character string pointer break” kısaltmasıdır), <parameter>wstring</parameter> içinde, <parameter>stopset</parameter> dizgesi ile belirtilen geniş karakterlerden biriyle başlayan geniş dizgeye gösterici ile dönmesi dışında <function>wcscspn</function> gibidir. <parameter>stopset</parameter> içindeki geniş karakterlerden biri bulunamazsa boş gösterici döner.
   </para>
   <header>&wchar.h;</header>
  </csynopsis>
  <sect1 xml:id="glibc-Search-Functions-Compatibility">
   <title>Uyumlu Dizge Arama İşlevleri</title>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-index"><primary>index</primary></indexterm>
    <csproto type="işlev">
     <csname><ptr>char</ptr><function>index</function></csname>
     <csparam><ptr>const&#160;char</ptr><parameter>string</parameter></csparam>
     <csparam><type>int</type><parameter>c</parameter></csparam>
    </csproto>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     <code>index</code> işlevi <function>strchr</function> işlevinin diğer adıdır; ikisi tamamen aynıdır. <code>index</code> işlevi BSD'dan gelir ve System V'den türetilmiş sistemlerde hiç kullanılmamıştır. &isoc; bu ismi değil, <function>strchr</function> ismini içerdiğinden daima <function>strchr</function> kullanılmalıdır.
    </para>
    <header>&string.h;</header>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-rindex"><primary>rindex</primary></indexterm>
    <csproto type="işlev">
     <csname><ptr>char</ptr><function>rindex</function></csname>
      <csparam><ptr>const&#160;char</ptr><parameter>string</parameter></csparam>
      <csparam><type>int</type><parameter>c</parameter></csparam>
    </csproto>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     <code>rindex</code> işlevi <function>strrchr</function> işlevinin diğer adıdır; ikisi tamamen aynıdır. <code>rindex</code> işlevi BSD'dan gelir ve System V'den türetilmiş sistemlerde hiç kullanılmamıştır. &isoc; bu ismi değil, <function>strrchr</function> ismini içerdiğinden daima <function>strrchr</function> kullanılmalıdır.
    </para>
    <header>&string.h;</header>
   </csynopsis>
  </sect1>
 </chapter>
 <chapter xml:id="glibc-Finding-Tokens-in-a-String">
  <title>Dizgeciklere Bölme</title>
  <titleabbrev>Bir dizgeyi içerdiği ayraçlara göre bölme.</titleabbrev>
  <para>
   Hemen her uygulamada, bir komut dizgesini dizgeciklere ayırmak gibi bazı basit ayrıştırma işlemlerine ihtiyaç  duyulur. Bunun için  &string.h; başlık dosyasında bildirilmiş olan <function>strtok</function> işlevi ile kullanılabilir.
   <indexterm linkend="glibc-pg"><primary>string.h</primary></indexterm>
  </para>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-strtok"><primary>strtok</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-strtok"><primary>dizgeler</primary><secondary>dizgeciklere bölme</secondary></indexterm>
   <csproto type="işlev">
    <csname><ptr>char</ptr><function>strtok</function></csname>
    <csparam><type>char&#160;*restrict</type><parameter>newstring</parameter></csparam>
    <csparam><type>const&#160;char&#160;*restrict</type><parameter>delimiters</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtunsafe; &race;<code linkend="glibc-safety-identifier">:strtok</code></concept>
    <concept>&asunsafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    Bir dizge <code>strtok</code> işlevi peşpeşe çağrılarak dizgeciklerine bölünebilir.
   </para>
   <para>
    Bölünecek dizge yalnızca ilk çağrıda <parameter>newstring</parameter> bağımsız değişkeni ile işleve aktarılır. <code>strtok</code> işlevi bunu bazı dahili durum bilgilerini ayarlamakta kullanır. Sonraki çağrılarda, <parameter>newstring</parameter> bağımsız değişkeni ile boş gösterici aktarılması aynı dizgeden başka dizgeciklerin alınacağını belirtir. <parameter>newstring</parameter> bağımsız değişkenine boş gösterici olmayan bir gösterici belirterek yapılan her <code>strtok</code> çağrısı, durum bilgilerini yeniden ilklendirir. Hiçbir kütüphane işlevinin yazılımcının bilgisi dahilinde olmayan (bu dahili durum bilgisini karıştıran) <code>strtok</code> çağrısı yapmayacağı garanti edilmiştir.
   </para>
   <para>
    <parameter>delimiters</parameter> bağımsız değişkeni çıkarılacak dizgecikleri belirlemede kullanılan ayraçlardan oluşan bir dizgedir. Bu ayraçlardan birine rastlandığında bu karakter boş bayt ile değiştirilir ve dizgenin başlangıcı <parameter>newstring</parameter> bağımsız değişkeninde döndürülür. Dizgecikler daima dizgeciğin sonunda bulunan bir ayracın varlığına göre ayrıştırılır.
   </para>
   <para>
    Sonraki <code>strtok</code> çağrılarında arama önceki dizgeciği sonlandıran boş bayttan sonraki karakterden başlar. Sonraki <code>strtok</code> çağrılarında hep aynı <parameter>delimiters</parameter> dizgesini kullanmak zorunluluğu yoktur.
   </para>
   <para>
    <parameter>newstring</parameter> dizgesinin sonuna gelindiğinde ya da kalan dizge sadece ayraç karakterlerinden oluşuyorsa işlev boş gösterici ile döner.
   </para>
   <para>
    Çok baytlı dizgelerde birden fazla bayttan oluşan karakterlerin baytları ayrı ayrı ele alınmaz. Bu işlevde baytlar ayrı ayrı ele alınır. İşlev yerelden bağımsızdır.
   </para>
   <header>&string.h;</header>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-wcstok"><primary>wcstok</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-wcstok"><primary>geniş dizgeler</primary><secondary>dizgeciklere bölme</secondary></indexterm>
   <csproto type="işlev">
    <csname><ptr>wchar_t</ptr><function>wcstok</function></csname>
    <csparam><ptr>wchar_t</ptr><parameter>newstring</parameter></csparam>
    <csparam><ptr>const&#160;wchar_t</ptr><parameter>delimiters</parameter></csparam>
    <csparam><pptr>wchar_t</pptr><parameter>save_ptr</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    Bir dizge <code>wcstok</code> işlevi peşpeşe çağrılarak dizgeciklerine bölünebilir.
   </para>
   <para>
    Bölünecek dizge yalnızca ilk çağrıda <parameter>newstring</parameter> bağımsız değişkeni ile işleve aktarılır. <code>wcstok</code> işlevi bunu bazı dahili durum bilgilerini ayarlamakta kullanır. Sonraki çağrılarda, <parameter>newstring</parameter> bağımsız değişkeni ile boş gösterici aktarılması aynı dizgeden başka dizgeciklerin alınacağını belirtir. Bölünecek dizgenin başlangıcı olarak daha önce <parameter>save_ptr</parameter> dizisine kaydedilen gösterici kullanılır.
   </para>
   <para>
    <parameter>delimiters</parameter> bağımsız değişkeni çıkarılacak dizgecikleri belirlemede kullanılan ayraçlardan oluşan geniş dizgedir. Bu ayraçlardan birine rastlandığında bu karakter boş geniş karakter ile değiştirilir. <parameter>delimiters</parameter> üyesi olmayan ilk geniş karakter, yeni dizgeciğin başlangıcını işaretler. Yeni dizgeciğin sonu, <parameter>delimiters</parameter> üyesi olan bir sonraki geniş karakter aranarak bulunur. <parameter>newstring</parameter> dizgesindeki <parameter>delimiters</parameter> üyesi geniş karakterin üzerine boş geniş karakter yazılır, üzerine yazılan geniş karakteri geçen gösterici (bir sonraki aramanın başlangıcı)  <parameter>save_ptr</parameter> ile ve dizgeciğin başlangıcına gösterici <parameter>newstring</parameter> bağımsız değişkeninde döndürülür.
   </para>
   <para>
    Sonraki <code>wcstok</code> çağrısında arama, önceki dizgeciği sonlandıran boş geniş karakterden sonraki geniş karakterde başlar. Sonraki <code>wcstok</code> çağrılarında hep aynı <parameter>delimiters</parameter> dizgesini kullanmak zorunlu değildir.
   </para>
   <para>
    <parameter>newstring</parameter> dizgesinin sonuna gelindiğinde ya da kalan dizge sadece ayraç karakterlerinden oluşuyorsa işlev boş gösterici ile döner.
   </para>
   <header>&wchar.h;</header>
  </csynopsis>
  <warning>
   <para>
    <function>strtok</function> ve <function>wcstok</function> işlevleri ayrıştırma sırasında dizgeyi değiştirdiğinden,  <function>strtok</function>/<function>wcstok</function> çağrısından önce dizge daima geçici bir tampona kaydedilmelidir (Bkz. <xref linkend="glibc-Copying-Strings-and-Arrays"/>). <function>strtok</function> veya <function>wcstok</function> işlevinin yazılımın başka bir parçasından gelen bir dizgeyi değiştirmesine izin verilirse, <function>strtok</function> veya <function>wcstok</function> çağrısından sonra dizge değişmiş olacağından dizgenin başka amaçlar için kullanılması gerektiğinde beklenen değerde olmaması sorunlara sebep olabilir.
   </para>
  </warning>
  <para>
   Üzerinde işlem yapılan dizge bir sabit olduğu takdirde, <function>strtok</function> veya <function>wcstok</function> işlevi sabiti değiştirmeye kalktığında yazılım salt-okunur belleğe yazacağından bir ölümcül hata oluşacaktır Bkz. <xref linkend="glibc-Program-Error-Signals"/>. <function>strtok</function> veya <function>wcstok</function> işlevinin yaptığı işlem dizgeyi değiştirmeyeceği  varsayılsa bile (örneğin, yalnızca bir dizgecik vardır) dizge değiştirilebilir (GNU C Kütüphanesi değiştirecektir).
  </para>
  <para>
   Bu, genel bir kuralın özel bir durumudur: Eğer bir yazılım parçası belli bir veri yapısını güncelleme ile görevlendirilmemişse sözkonusu veri yapısının bu yazılım tarafından geçici olarak güncellenmesi hatalara yol açabilir.
  </para>
  <para>
   <function>wcstok</function> işlevinin tersine <function>strtok</function> işlevi çok evreliliğe uygun değildir. Çok evreliliğe uygunluğun niçin ve nerede önemli olduğu <xref linkend="glibc-Nonreentrancy"/> bölümünde incelenmiştir.
  </para>
  <example><title><code>strtok</code> kullanımı</title>
   <screen>#include &lt;string.h&gt;
#include &lt;stddef.h&gt;

…

const char string[] = "words separated by spaces - and, punctuation!";
const char delimiters[] = " .,;:!-";
char *token, *cp;

…

cp = strdupa (string);                /* yazılabilir bir kopya oluştur.  */
token = strtok (cp, delimiters);      /* token =&gt; "words" */
token = strtok (NULL, delimiters);    /* token =&gt; "separated" */
token = strtok (NULL, delimiters);    /* token =&gt; "by" */
token = strtok (NULL, delimiters);    /* token =&gt; "spaces" */
token = strtok (NULL, delimiters);    /* token =&gt; "and" */
token = strtok (NULL, delimiters);    /* token =&gt; "punctuation" */
token = strtok (NULL, delimiters);    /* token =&gt; NULL */
</screen>
  </example>
  <para>
   GNU C kütüphanesi bir dizgeyi dizgeciklerine bölmek için, çok evreliliğe uygun olmamaktan kaynaklanan sınırlamaları aşan iki işlev daha içerir. Bu işlevler geniş dizgeler üzerinde kullanılmaz.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-strtok_r"><primary>strtok_r</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-strtok_r"><primary>dizgeler</primary><secondary>dizgeciklere bölme</secondary></indexterm>
   <csproto type="işlev">
    <csname><ptr>char</ptr><function>strtok_r</function></csname>
    <csparam><ptr>char</ptr><parameter>newstring</parameter></csparam>
    <csparam><ptr>const&#160;char</ptr><parameter>delimiters</parameter></csparam>
    <csparam><pptr>char</pptr><parameter>save_ptr</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    Bu işlev, <function>strtok</function> gibi, ardışık olarak çağrılarak bir dizgeyi dizgeciklerine ayırmakta kullanılır. Farkı, sonraki dizgecik hakkındaki bilgilerin, <function>wcstok</function> işlevindeki gibi bir dizge göstericisine gösterici olan <parameter>save_ptr</parameter> bağımsız değişkeni ile gösterilen alanda saklanmasıdır. İşlevin, <parameter>newstring</parameter> bağımsız değişkeninin boş gösterici ile çağrılması ve çağrılar arasında <parameter>save_ptr</parameter> bağımsız değişkeninin değişmeden bırakılması, çok evreliliği aksatmaksızın işlemin yapılmasını sağlar.
   </para>
   <para>
    Bu işlev POSIX.1 içinde tanımlıdır ve çok evreliliği destekleyen çoğu sistemde bulunur.
   </para>
   <header>&string.h;</header>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-strsep"><primary>strsep</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-strsep"><primary>dizgeler</primary><secondary>arama</secondary></indexterm>
   <csproto type="işlev">
    <csname><ptr>char</ptr><function>strsep</function></csname>
    <csparam><pptr>char</pptr><parameter>string_ptr</parameter></csparam>
    <csparam><ptr>const&#160;char</ptr><parameter>delimiter</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    Bu işlev, <function>strtok_r</function> işlevindeki <parameter>newstring</parameter> bağımsız değişkeninin yerini <parameter>string_ptr</parameter> bağımsız değişkeninin alması dışında <function>strtok_r</function> işlevine benzer. Taşıyıcı göstericinin ilklendirilmesi yazılımcı tarafından yapılır. <code>strsep</code> işlevine art arda yapılan çağrılar, göstericiyi <parameter>delimiter</parameter> ile tahsis edilmiş dizgecikler boyunca hareket ettirerek bir sonraki dizgeciğin adresini döndürürken <parameter>string_ptr</parameter> bağımsız değişkenini bir sonraki dizgeciğin başlangıcını gösterecek şekilde günceller.
   </para>
   <para>
    <code>strsep</code> ile <function>strtok_r</function> arasındaki bir diğer fark da, eğer girdi dizgesi içinde <parameter>delimiter</parameter> karakterlerinden biri birden fazla içeriliyorsa, her <parameter>delimiter</parameter> karakteri çifti için bir boş dizge döndürmesidir. Yani, yazılımın normalde işlevi çalıştırmadan önce işlevin boş dizge döndürüp döndürmeyeceğini sınaması gerekir.
   </para>
   <para>
    Bu işlev 4.3 BSD içinde tanımlıdır ve genişçe bir kullanım alanı vardır.
   </para>
   <header>&string.h;</header>
  </csynopsis>
  <example><title>Önceki örneğin <code>strsep</code> sürümü</title>
   <screen>#include &lt;string.h&gt;
#include &lt;stddef.h&gt;

…

const char string[] = "words separated by spaces - and, punctuation!";
const char delimiters[] = " .,;:!-";
char *running;
char *token;

…

running = strdupa (string);
token = strsep (&amp;running, delimiters);    /* token =&gt; "words" */
token = strsep (&amp;running, delimiters);    /* token =&gt; "separated" */
token = strsep (&amp;running, delimiters);    /* token =&gt; "by" */
token = strsep (&amp;running, delimiters);    /* token =&gt; "spaces" */
token = strsep (&amp;running, delimiters);    /* token =&gt; "" */
token = strsep (&amp;running, delimiters);    /* token =&gt; "" */
token = strsep (&amp;running, delimiters);    /* token =&gt; "" */
token = strsep (&amp;running, delimiters);    /* token =&gt; "and" */
token = strsep (&amp;running, delimiters);    /* token =&gt; "" */
token = strsep (&amp;running, delimiters);    /* token =&gt; "punctuation" */
token = strsep (&amp;running, delimiters);    /* token =&gt; "" */
token = strsep (&amp;running, delimiters);    /* token =&gt; NULL */
</screen>
  </example>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-basename-gnu"><primary>basename (GNU)</primary></indexterm>
   <csproto type="işlev">
    <csname><ptr>char</ptr><function>basename</function></csname>
    <csparam><ptr>const&#160;char</ptr><parameter>filename</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <code>basename</code> işlevinin GNU sürümü, <parameter>filename</parameter> ile belirtilen dosya yolunun son elemanı ile döner. <parameter>filename</parameter> bağımsız değişkenini içerdiği ters eğik çizgiler bakımından değiştirmediğinden kullanımı tercih edilir. İşlev &string.h; başlık dosyasında bildirilmiştir.  &libgen.h; başlık dosyası da içerildiğinde bu işlevin XPG sürümü ile değiştirileceği unutulmamalıdır.
   </para>
   <example><title>GNU <code>basename</code> kullanımı</title>
    <screen>#include &lt;string.h&gt;

int
main (int argc, char *argv[])
{
  char *prog = basename (argv[0]);

  if (argc &lt; 2)
    {
      fprintf (stderr, "Kullanımı: %s &lt;arg&gt;\n", prog);
      exit (1);
    }

  …
}
</screen>
   </example>
   <note><title>Taşınabilirlik Bilgisi</title>
    <para>
     Bu işlev, farklı sistemlerde farklı sonuçlar üretebilir.
    </para>
   </note>
   <header>&string.h;</header>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-basename-xpg"><primary>basename (XPG)</primary></indexterm>
   <csproto type="işlev">
    <csname><ptr>char</ptr><function>basename</function></csname>
    <csparam><ptr>char</ptr><parameter>path</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <code>basename</code> işlevinin XPG sürümüdür ve ruhen GNU sürümüne benzer. Fakat, <parameter>path</parameter>  içindeki '/' karakterleri silinerek değişikliğe uğratılır. Eğer bağımsız değişken sadece '/' karakterinden oluşuyorsa '/' karakteri döner. Ayrıca, <code>NULL</code> ise ya da boş dizge ise "." döner. İşlevin XPG sürümü &libgen.h; başlık dosyasında bildirilmiştir.
   </para>
   <example><title>XPG <code>basename</code> kullanımı</title>
    <screen>#include &lt;libgen.h&gt;

int
main (int argc, char *argv[])
{
  char *prog;
  char *path = strdupa (argv[0]);

  prog = basename (path);

  if (argc &lt; 2)
    {
      fprintf (stderr, "Kullanımı: %s &lt;arg&gt;\n", prog);
      exit (1);
    }

  …

}
</screen>
   </example>
   <header>&libgen.h;</header>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-dirname"><primary>dirname</primary></indexterm>
   <csproto type="işlev">
    <csname><ptr>char</ptr><function>dirname</function></csname>
    <csparam><ptr>char</ptr><parameter>path</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <code>dirname</code> işlevi, <function>basename</function> işlevinin XPG sürümünün tümleyenidir. <parameter>path</parameter> ile belirtilen dosyayı içeren dizin ile döner. Bağımsız değişkenin değeri  <code>NULL</code> ise veya boş dizge ise ya da hiç '/' karakteri içermiyorsa, "." döner.
   </para>
   <header>&libgen.h;</header>
  </csynopsis>
 </chapter>
 <chapter xml:id="glibc-Erasing-Sensitive-Data">
  <title>Hassas Bilgilerin Silinmesi</title>
  <titleabbrev>İhtiyaç kalmadığında bellekten hassas verilerin temizlenmesi.</titleabbrev>
  <para>
   Şifreleme anahtarları gibi hassas veriler, bir yazılım hatasının dış dünyaya ifşa olma riskini azaltmak için kullanımdan sonra bellekten silinmelidir. Bununla birlikte, derleyici en iyileme yaparken bu silme işlemini "gereksiz" olarak belirleyebilir ve bu işlemi üretilen koddan kaldırabilir, çünkü hiçbir doğru uygulama, yeniden bellek tahsisinden sonra hassas verileri içeren değişkene veya yığın nesnesine erişemez. Silme, yazılım hatalarına karşı bir önlem olduğundan, bu en iyileme uygun değildir.
  </para>
  <para>
   <function>explicit_bzero</function> işlevi bir bellek dilimini siler ve derleyicinin silmeyi "gereksiz" bularak kaldırmayacağını garanti eder.
  </para>
  <example>
   <screen>#include &lt;string.h&gt;

extern void encrypt (const char *key, const char *in,
                     char *out, size_t n);
extern void genkey (const char *phrase, char *key);

void encrypt_with_phrase (const char *phrase, const char *in,
                          char *out, size_t n)
{
  char key[16];
  genkey (phrase, key);
  encrypt (key, in, out, n);
  explicit_bzero (key, 16);
}
</screen>
  </example>
  <para>
   Bu örnekte, <function>memset</function>, <function>bzero</function> veya elle yazılmış bir döngü kullanılsaydı, derleyici bunları "gereksiz" bularak kaldırabilirdi.
  </para>
  <warning>
   <para>
    <function>explicit_bzero</function> işlevi hassas verilerin bellekten "tamamen" silinmesini garanti etmez. Yazmaçlar ve "karalama" yığıt alanı gibi geçici depolama alanlarında kopyalar olabilir; bunlar kaynak kodu tarafından görülmediğinden, kütüphane işlevi bunları silemez.
   </para>
  </warning>
  <para>
   Ayrıca, <function>explicit_bzero</function> yalnızca RAM üzerinde çalışır. Hassas veri nesnesi, <function>explicit_bzero</function>'yu çağırmak dışında hiçbir zaman adresinin alınması gerekmiyorsa, <function>explicit_bzero</function> "çağrılana kadar" tamamen işlemci yazmaçlarında kalabilir. Çağrıldıktan sonra RAM'e kopyalanacak, kopya silinecek ve özgün veri bozulmadan kalacaktır. RAM'deki verilerin bir yazılım hatasından dolayı açığa çıkma olasılığı, yazmaçlardaki verilerin açığa çıkma olasılığından daha yüksektir, bu nedenle yazılımın silmeye çalışmadığı duruma göre verilerin açığa çıkma riskinin daha fazla olduğu küçük bir pencere oluşur.
  </para>
  <para>
   Hassas değişkenlerin <type>volatile</type> olarak bildirilmesi, yukarıdaki sorunların her ikisini de <emphasis>daha kötü</emphasis> hale getirecektir. <type>volatile</type> bir değişken, tüm ömrü boyunca bellekte saklanacağından derleyici normalden daha fazla kopya yapacaktır. Normal bir değişkeni, <type>volatile</type> nitelikli bir gösterici aracılığıyla "elle" silmeye çalışmak hiç işe yaramaz çünkü değişkenin kendisi <type>volatile</type> değildir. Bazı derleyiciler göstericideki niteliği yok sayacak ve silme işlemini yine de kaldıracaktır.
  </para>
  <para>
   Tüm bunlardan sonra, çoğu durumda <function>explicit_bzero</function> kullanmak, kullanmamaktan daha iyidir. Şu anda, daha kapsamlı bir iş yapmanın tek yolu, hassas işlemin tamamını makine dilinde yazmaktır. Gelecekte, derleyicilerin <function>explicit_bzero</function> çağrılarını tanıyacağını ve nerede olursa olsun etkilenen verilerin tüm kopyalarını silmek için uygun adımları atacağını tahmin ediyoruz.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-explicit_bzero"><primary>explicit_bzero</primary></indexterm>
   <csproto type="işlev">
    <csname><type>void</type><function>explicit_bzero</function></csname>
    <csparam><ptr>void</ptr><parameter>block</parameter></csparam>
    <csparam><type>size_t</type><parameter>len</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <code>explicit_bzero</code> işlevi <code>bzero</code> işlevinin yaptığı gibi <parameter>block</parameter> adresinden başlayan <parameter>len</parameter> baytlık belleğe sıfır yazar. Hiçbir doğru yazılım sıfırları geri okumayacağı için derleyici bunun "gereksiz" olduğuna karar verse bile sıfırlar daima yazılır.
   </para>
   <note>
    <para>
     <code>explicit_bzero</code> işlevinin devre dışı bıraktığı <emphasis>tek</emphasis> en iyileme, belleğe "gereksiz" yazmaların kaldırılmasıdır. Derleyici, bir <function>memset</function> çağrısı için yapabileceği diğer tüm iyileştirmeleri gerçekleştirebilir. Örneğin, işlev çağrısını satırlaştırılmış bellek yazmalarıyla değiştirebilir ve bloğun bir boş gösterici olamayacağını varsayabilir.
    </para>
   </note>
   <note><title>Taşınabilirlik Bilgisi</title>
    <para>
     Bu işlev ilk defa OpenBSD 5.5'te görülmüş ve standart durumuna getirilmemiştir. Diğer sistemler aynı işlevselliği, <function>explicit_memset</function>, <function>memset_s</function> veya <function>SecureZeroMemory</function> gibi başka isimler altında gerçekleyebilir.
    </para>
   </note>
   <para>
    GNU C Kütüphanesi bu işlevi &string.h; başlık dosyasında bildirmiştir, ama başka sistemler bunun yerine &strings.h; başlık dosyasında bildirmiş olabilir.
   </para>
   <header>&string.h;</header>
  </csynopsis>
 </chapter>

 <chapter xml:id="glibc-Shuffling-Bytes">
  <title>Baytların Karılması</title>
  <titleabbrev>Baytları kart destesini karar gibi karıştırmak.</titleabbrev>
  <para>
   Aşağıdaki işlev, oldukça eski bir yazılım geliştirme ikilemini ele almaktadır: "Dizge biçimindeki işe yarar veriyi nasıl acısız bir şekilde çöpe dönüştürebilirim?" Bu, yazılımcının tek başına kodlayamayacağı kadar zor bir şey değildir, ancak GNU C Kütüphanesinin yazarları bunu mümkün olduğu kadar elverişli hale getirmek istemektedir.
  </para>
  <para>
   Veriyi <emphasis>silmek</emphasis> için <function>explicit_bzero</function>,
   (bkz. <xref linkend="glibc-Erasing-Sensitive-Data"/>); geri dönüşümlü olarak karartmak için <function>memfrob</function> (bkz. <xref linkend="glibc-Obfuscating-Data"/>) kullanılabilir.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-strfry"><primary>strfry</primary></indexterm>
   <csproto type="işlev">
    <csname><ptr>char</ptr><function>strfry</function></csname>
    <csparam><ptr>char</ptr><parameter>string</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <code>strfry</code> işlevi bir dizgeyi yerinde kararak dönüştürür. Her karakter bulunduğu konumundan silinir, karakterin özgün konumundan başlayan bölüm içinde rastgele seçilen bir konuma yerleştirilir (Tarafsız karma için Fisher-Yates algoritması).
   </para>
   <para>
    <code>strfry</code> işlevinin çağrılması küresel durumdaki rastgele sayı üreteçlerinin kullanılmasına sebep olmaz (bkz. <xref linkend="glibc-Pseudo-Random-Numbers"/>).
   </para>
   <para>
    <code>strfry</code> işlevi daima <parameter>string</parameter> ile döner.
   </para>
   <note><title>Taşınabilirlik Bilgisi</title>
    <para>
     İşlev GNU C kütüphanesine özeldir.
    </para>
   </note>
   <header>&string.h;</header>
  </csynopsis>
 </chapter>

 <chapter xml:id="glibc-Obfuscating-Data">
  <title>Verilerin Karartılması</title>
  <titleabbrev>Verinin geri dönüşümlü gizlenmesi</titleabbrev>
  <para>
   <code>memfrob</code> işlevi bir ikil veri dizisini tanınmayacak hale getirmek daha sonra tekrar eski haline getirmek için kullanılır. Şifrelenmiş veri herkes tarafından kolayca normal veriye dönüştürülebildiğinden tam bir şifreleme sayılmaz. Dönüşüm, rahatsız edici şakaları, konu ipuçlarını ve benzerlerini gizlemek için kullanılan Usenet'in "Rot13" şifreleme yöntemine eşdeğerdir. Rot13'ün aksine <code>memfrob</code> işlevi sadece metin üzerinde değil ikil verilerle de çalışır.
  </para>
  <para>
   Özgün veriyi tamamen gizleyen ve gizli anahtar bilgisi olmadan geri alınamayan bir dönüşüm olan gerçek şifrelemeye ihtiyaç duyulan yazılımlarda, <link xl:href="https://www.gnu.org/software/libgcrypt/">libgcrypt</link> gibi özel bir şifreleme kütüphanesi kullanmalıdır.
  </para>
  <para>
   Verinin tamamen yok edilmesine ihtiyaç duyulan yazılımlarda ise <function>explicit_bzero</function> (bkz. <xref linkend="glibc-Erasing-Sensitive-Data"/>) veya <function>strfry</function> (bkz. <xref linkend="glibc-Shuffling-Bytes"/>) kullanılmalıdır.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-memfrob"><primary>memfrob</primary></indexterm>
   <csproto type="işlev">
    <csname><ptr>void</ptr><function>memfrob</function></csname>
    <csparam><ptr>void</ptr><parameter>mem</parameter></csparam>
    <csparam><type>size_t</type><parameter>length</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <code>memfrob</code> işlevi, <parameter>mem</parameter> adresinden başlayan <parameter>length</parameter> baytlık belleği yerinde karartır. Karartma işlemi her baytın ikil 00101010 kalıbı (onaltılık 0x2A) ile bitsel olarak ayrıcalıklı VEYAlanmasından ibarettir. İşlev, daima <parameter>mem</parameter> ile döner.
   </para>
   <para>
    <code>memfrob</code> işlevi aynı veri ile tekrar çağrıldığında özgün veri elde edilir.
   </para>
   <note><title>Taşınabilirlik Bilgisi</title>
    <para>
     İşlev GNU C kütüphanesine özeldir.
    </para>
   </note>
   <header>&string.h;</header>
  </csynopsis>
 </chapter>

 <chapter xml:id="glibc-Encode-Binary-Data">
  <title>İkil Verinin Kodlanması</title>
  <titleabbrev>İkil verilerin kodlanması ve kodlarının çözülmesi.</titleabbrev>
  <para>
   Sadece metin türü verilerin saklanabildiği ya da aktarılabildiği ortamlarda saklama ya da aktarma öncesi ikil veri baytlarının karakterlere dönüştürülmesi gerekir. SVID sistemleri (ve günümüzde XPG uyumlu sistemler) bu işlem için çok az destek sağlar.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-l64a"><primary>l64a</primary></indexterm>
   <csproto type="işlev">
    <csname><ptr>char</ptr><function>l64a</function></csname>
    <csparam><type>long&#160;int</type><parameter>n</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtunsafe; &race;<code linkend="glibc-safety-identifier">:l64a</code></concept>
    <concept>&asunsafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    Bu işlev, temel karakter kümesindeki baytları kullanarak  32 bitlik girdiyi kodlar. İşlev <parameter>n</parameter> sayısının kodlanmış halini içeren 7 baytlık tampona gösterici ile döner. Yazılımcı bir sayı dizisini kodlamak istiyorsa, ikinci bir tampona dönen veriyi kopyalamalıdır. <parameter>n</parameter> sıfırsa boş dizge döner, biraz tuhaf ama standart böyle.
   </para>
   <warning>
    <para>
     Tamponu duruk olduğundan işlev çok evreli yazılımlarda kullanılmamalıdır. Bu işlevin evreli yazılımlarca kullanılabilecek bir eşdeğeri C kütüphanesinde yoktur.
    </para>
   </warning>
   <note><title>Uyumluluk Bilgisi</title>
    <para>
     XPG standardında negatif <parameter>n</parameter> değerleri için <code>l64a</code> işlevinin dönüş değeri anlamlı değildir. GNU gerçekleniminde, işlev bağımsız değişkeni işaretsiz olarak ele alınır, böylece sıfırdan farklı <parameter>n</parameter> değerleri negatif olsalar bile anlamlı bir değer döner. Taşınabilir bir yazılım geliştiriliyorsa bu durum dikkate alınmalıdır.
    </para>
   </note>
   <para>
    Büyük bir tamponu kodlamak için, her seferinde 32 bitlik tampon dönüştürecek bir döngü kullanılmalıdır.
   </para>
   <example>
    <screen>char *
encode (const void *buf, size_t len)
{
  /* <replaceable>Gereken tampon uzunluğu biliniyor</replaceable> */
  unsigned char *in = (unsigned char *) buf;
  char *out = malloc (6 + ((len + 3) / 4) * 6 + 1);
  char *cp = out, *p;

  /* <replaceable>Uzunluğu kodla.</replaceable> */
  /* <replaceable>Farklı bayt sıralaması kullanan makinelerde bile doğru
      çözümleme yapılmasını garanti etmek için `htonl' kullan.
      `l64a' 6 bayttan daha kısa dizge döndürebilir,
      bu durumda genişliği tamamlamak için sondaki boşluğu
      0 ('.') kodlamasıyla doldur.</replaceable> */

  p = stpcpy (cp, l64a (htonl (len)));
  cp = mempcpy (p, "......", 6 - (p - cp));

  while (len &gt; 3)
    {
      unsigned long int n = *in++;
      n = (n &lt;&lt; 8) | *in++;
      n = (n &lt;&lt; 8) | *in++;
      n = (n &lt;&lt; 8) | *in++;
      len -= 4;
      p = stpcpy (cp, l64a (htonl (n)));
      cp = mempcpy (p, "......", 6 - (p - cp));
    }
  if (len &gt; 0)
    {
      unsigned long int n = *in++;
      if (- -len &gt; 0)
        {
          n = (n &lt;&lt; 8) | *in++;
          if (- -len &gt; 0)
            n = (n &lt;&lt; 8) | *in;
        }
      cp = stpcpy (cp, l64a (htonl (n)));
    }
  *cp = '\0';
  return out;
}
</screen>
   </example>
   <para>
    Kütüphanenin gereken tam işlevselliği sağlamaması tuhaf ama elden ne gelir.
   </para>
   <header>&stdlib.h;</header>
  </csynopsis>
  <para>
   <code>l64a</code> işleviyle kodlanmış veri aşağıdaki işlev kullanılarak eski haline getirilebilir.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-a64l"><primary>a64l</primary></indexterm>
   <csproto type="işlev">
    <csname><type>long&#160;int</type><function>a64l</function></csname>
    <csparam><ptr>const&#160;char</ptr><parameter>string</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <parameter>string</parameter> bağımsız değişkeni, <function>l64a</function> çağrısı ile elde edilmiş bir dizge olmalıdır. İşlev dizgenin  en az 6 karakterini işleme alır ve bulduğu baytları aşağıdaki tabloya göre çözümler. Tabloda bulunmayan bir karaktere rastlanırsa işlev, <function>atoi</function> işlevinin tersine çözümlemeyi durdurur. Satırlara ayrılmış bir tampon kullanılıyorsa, satır sonu karakterleri dikkatle atlanmalıdır.
   </para>
   <para>
    Kodu çözülen sayı bir <command>long int</command> değer olarak döndürülür.
   </para>
   <header>&stdlib.h;</header>
  </csynopsis>
  <para>
   <function>l64a</function> ve <function>a64l</function> işlevleri base 64 kodlaması kullanır. Yani kodlanmış dizgenin her karakteri bir girdi sözcüğünün altı biti ile ifade edilir. 64'lük tabandaki sayılar için kullanılan rakamlar:
  </para>
<literallayout class="monospaced">
<replaceable>    0  1  2  3  4  5  6  7</replaceable>
<replaceable> 0</replaceable><literal>  .  /  0  1  2  3  4  5</literal>
<replaceable> 8</replaceable><literal>  6  7  8  9  A  B  C  D</literal>
<replaceable>16</replaceable><literal>  E  F  G  H  I  J  K  L</literal>
<replaceable>24</replaceable><literal>  M  N  O  P  Q  R  S  T</literal>
<replaceable>32</replaceable><literal>  U  V  W  X  Y  Z  a  b</literal>
<replaceable>40</replaceable><literal>  c  d  e  f  g  h  i  j</literal>
<replaceable>48</replaceable><literal>  k  l  m  n  o  p  q  r</literal>
<replaceable>56</replaceable><literal>  s  t  u  v  w  x  y  z</literal>
</literallayout>
  <para>
   Bu kodlama şeması standart değildir. Daha geniş çapta kullanılan başka kodlama yöntemleri de (UU kodlaması, MIME kodlaması gibi) vardır. Genelde bu kodlamalardan birini kullanmak daha iyidir.
  </para>
 </chapter>
 <chapter xml:id="glibc-Argz-and-Envz-Vectors">
  <title>Argz ve Envz Gösterici Dizileri</title>
  <titleabbrev>Dizge göstericisi dizileri</titleabbrev>
  <preliminary>
   <para>
    <dicterm><english>vector</english><turkish>vektör (boş gösterici sonlandırmalı  gösterici dizisi)</turkish></dicterm>
    <indexterm linkend="glibc-cp"><primary>vektör</primary></indexterm>
    <indexterm linkend="glibc-cp"><primary>argz vektörleri</primary></indexterm>
    <indexterm linkend="glibc-cp"><primary>dizge dizileri</primary><secondary>boş bayt ayraçlı</secondary></indexterm>
    <indexterm linkend="glibc-cp"><primary>bağımsız değişken vektörleri</primary></indexterm>
    <wordasword>argz vektörü</wordasword>, her elemanı komşusundan boş bayt (<code>'\0'</code>) ile ayrılmış kesintisiz bir bellek dilimi içindeki dizgeler dizisidir.
   </para>
   <para>
    <indexterm linkend="glibc-cp"><primary>envz vektörleri (ortam dizgeleri dizisi)</primary></indexterm>
    <indexterm linkend="glibc-cp"><primary>ortam vektörleri</primary><secondary>boş bayt ayraçlı</secondary></indexterm>
    <wordasword>envz vektörü</wordasword> her elemanı bir isim-değer çifti olan ve bu çiftlerin <code>'='</code> karakteri ile ayrıldığı (en azından Unix ortamında) bir argz vektörüdür.
   </para>
  </preliminary>
  <sect1 xml:id="glibc-Argz-Functions">
   <title>Argz İşlevleri</title>
   <titleabbrev>Argz vektörleri üzerindeki işlemler.</titleabbrev>
   <para>
    Her argz vektörü ilk elemanı gösteren <type>char *</type> türünde bir gösterici ve dizi boyutunu belirten <type>size_t</type> türünde bir boyut ile temsil edilir. Her ikisi de boş argz vektörünü gösteren <code>0</code> ile ilklendirilir. Tüm argz işlevleri ya bir gösterici ile bir boyut bağımsız değişkeni ya da her ikisinin de değişebileceği öngörüldüğü durumlarda her ikisi de gösterici olan bağımsız değişkenler alır.
   </para>
   <para>
    Argz işlevleri dizge dizilerine bellek tahsisi için ya da tahsis edilmiş belleği büyütmek için <function>malloc</function>/<function>realloc</function> işlevlerini kullanır. Böylece bu işlevler tarafından oluşturulan tüm argz vektörleri <function>free</function> işlevi ile serbest bırakılabilir. Buna karşın, bir dizgeyi büyütebilen argz işlevlerinin dizgeyi tutacak belleği <function>malloc</function> kullanarak tahsis etmesi beklenir (bu tür argz işlevleri, bellek sıralaması ne olursa olsun, sadece kendi bağımsız değişkenlerini saptar ve onları değiştirmek için aynı alanı kullanır). Bkz. <xref linkend="glibc-Unconstrained-Allocation"/>.
   </para>
   <para>
    Bellek tahsis işlemi de yapan tüm argz işlevleri <type>error_t</type> türünde bir değer ile döner. Başarı durumunda bu değer <code>0</code>’dır. Aksi takdirde, bir tahsis hatası oluşursa <varname>ENOMEM</varname> ile döner.
   </para>
   <para>
    <indexterm linkend="glibc-pg"><primary>argz.h</primary></indexterm>
    Bu işlevler &argz.h; başlık dosyası içinde bildirilmiştir.
   </para>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-argz_create"><primary>argz_create</primary></indexterm>
   <csproto type="işlev">
    <csname><type>error_t</type><function>argz_create</function></csname>
    <csparam><type>char&#160;*const</type><parameter>argv[]</parameter></csparam>
    <csparam><pptr>char</pptr><parameter>argz</parameter></csparam>
    <csparam><ptr>size_t</ptr><parameter>argz_len</parameter></csparam>
   </csproto>
   <header>&argz.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&asunsafe; &heap;</concept>
    <concept>&acunsafe; &mem;</concept>
   </conceptlist>
   <para>
    <code>argz_create</code> işlevi <parameter>argv</parameter> Unix tarzı girdi vektörünü (normal C dizgelerine göstericilerden oluşmuş, <code>(char *)0</code> ile sonlandırılmış bir diziye gösterici; bkz, <xref linkend="glibc-Program-Arguments"/>) aynı elemanlarla argz vektörüne dönüştürüp <parameter>argz</parameter> ve <parameter>argz_len</parameter> olarak döndürür.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-argz_create_sep"><primary>argz_create_sep</primary></indexterm>
   <csproto type="işlev">
    <csname><type>error_t</type><function>argz_create_sep</function></csname>
    <csparam><ptr>const&#160;char</ptr><parameter>string</parameter></csparam>
    <csparam><type>int</type><parameter>sep</parameter></csparam>
    <csparam><pptr>char</pptr><parameter>argz</parameter></csparam>
    <csparam><ptr>size_t</ptr><parameter>argz_len</parameter></csparam>
   </csproto>
   <header>&argz.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&asunsafe; &heap;</concept>
    <concept>&acunsafe; &mem;</concept>
   </conceptlist>
   <para>
    <code>argz_create_sep</code> işlevi, <parameter>string</parameter> dizgesini her <parameter>sep</parameter> karakterinde bir eleman ayırarak (<parameter>argz</parameter> ve <parameter>argz_len</parameter> içinde döndürülen) bir argz vektörüne dönüştürür.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-argz_count"><primary>argz_count</primary></indexterm>
   <csproto type="işlev">
    <csname><type>size_t</type><function>argz_count</function></csname>
    <csparam><ptr>const&#160;char</ptr><parameter>argz</parameter></csparam>
    <csparam><type>size_t</type><parameter>argz_len</parameter></csparam>
   </csproto>
   <header>&argz.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <parameter>argz</parameter> ve <parameter>argz_len</parameter> ile belirtilen argz vektörünün eleman sayısı ile döner.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-argz_extract"><primary>argz_extract</primary></indexterm>
   <csproto type="işlev">
    <csname><type>void</type><function>argz_extract</function></csname>
    <csparam><ptr>const&#160;char</ptr><parameter>argz</parameter></csparam>
    <csparam><type>size_t</type><parameter>argz_len</parameter></csparam>
    <csparam><pptr>char</pptr><parameter>argv</parameter></csparam>
   </csproto>
   <header>&argz.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <code>argz_extract</code> işlevi, <parameter>argz</parameter> ve <parameter>argz_len</parameter> ile belirtilen argz vektörünü, (<parameter>argz</parameter> içindeki her elemana bir göstericiyi <code>0</code> ile sonladırılmış olarak <parameter>argv</parameter> içindeki kendi konumuna yerleştirerek) <parameter>argv</parameter> içinde saklanan Unix tarzı girdi vektörüne dönüştürür. <parameter>argv</parameter>, <parameter>argz</parameter> dizisinin tüm elemanları artı sonlandırıcı <code>(char *)0</code> için yeterince yer bulunan (yer olarak <code>(<function>argz_count</function> (<parameter>argz</parameter>, <parameter>argz_len</parameter>) + 1) * <operator>sizeof</operator> (<type>char</type> *)</code> bayt yeterlidir) önceden tahsis edilmiş bir alanı göstermelidir. <parameter>argv</parameter> içindeki dizge göstericileri, <parameter>argz</parameter> içindeki alanları gösterdiğinden (kopyasını değil), <parameter>argz</parameter>'nin <parameter>argv</parameter> etkinken değişmemesi isteniyorsa ayrıca kopyalanmalıdır. Bu işlev <parameter>argz</parameter> içindeki elemanların bir <link linkend="glibc-Executing-a-File">exec işlevine</link> aktarılması için kullanışlıdır.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-argz_stringify"><primary>argz_stringify</primary></indexterm>
   <csproto type="işlev">
    <csname><type>void</type><function>argz_stringify</function></csname>
    <csparam><ptr>char</ptr><parameter>argz</parameter></csparam>
    <csparam><type>size_t</type><parameter>len</parameter></csparam>
    <csparam><type>int</type><parameter>sep</parameter></csparam>
   </csproto>
   <header>&argz.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <code>argz_stringify</code> işlevi, <parameter>argz</parameter> içindeki <code>'\0'</code> karakterlerini <parameter>sep</parameter> karakteri ile değiştirerek (dizgeyi sonlandıran boş bayt hariç) elemanları birleştirip normal bir dizgeye çevirir. Bu işlev, <parameter>argz</parameter>'nin okunabilir olarak yazdırılması gibi işlemler için faydalıdır.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-argz_add"><primary>argz_add</primary></indexterm>
   <csproto type="işlev">
    <csname><type>error_t</type><function>argz_add</function></csname>
    <csparam><pptr>char</pptr><parameter>argz</parameter></csparam>
    <csparam><ptr>size_t</ptr><parameter>argz_len</parameter></csparam>
    <csparam><ptr>const&#160;char</ptr><parameter>str</parameter></csparam>
   </csproto>
   <header>&argz.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&asunsafe; &heap;</concept>
    <concept>&acunsafe; &mem;</concept>
   </conceptlist>
   <para>
    <code>argz_add</code> işlevi, <parameter>str</parameter> dizisini *<parameter>argz</parameter> vektörünün sonuna ekleyip *<parameter>argz</parameter> ile *<parameter>argz_len</parameter> bağımsız değişkenlerini yeni duruma uygun olarak günceller.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-argz_add_sep"><primary>argz_add_sep</primary></indexterm>
   <csproto type="işlev">
    <csname><type>error_t</type><function>argz_add_sep</function></csname>
    <csparam><pptr>char</pptr><parameter>argz</parameter></csparam>
    <csparam><ptr>size_t</ptr><parameter>argz_len</parameter></csparam>
    <csparam><ptr>const&#160;char</ptr><parameter>str</parameter></csparam>
    <csparam><type>int</type><parameter>delim</parameter></csparam>
   </csproto>
   <header>&argz.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&asunsafe; &heap;</concept>
    <concept>&acunsafe; &mem;</concept>
   </conceptlist>
   <para>
    <code>argz_add_sep</code> işlevi <function>argz_add</function> işlevine benzer. Farklı olarak, <parameter>str</parameter> dizgesini <parameter>delim</parameter> baytına göre alt dizgelerine ayırıp *<parameter>argz</parameter> vektörünün sonuna ekler. Bu işlev, <parameter>delim</parameter> karakteri olarak <code>':'</code> belirterek, <varname>PATH</varname> ortam değişkeni gibi bir değişkenin değerini oluşturan tüm elamanların ayrı birer dizge olarak eklenmek istenmesi durumunda yararlıdır.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-argz_append"><primary>argz_append</primary></indexterm>
   <csproto type="işlev">
    <csname><type>error_t</type><function>argz_append</function></csname>
    <csparam><pptr>char</pptr><parameter>argz</parameter></csparam>
    <csparam><ptr>size_t</ptr><parameter>argz_len</parameter></csparam>
    <csparam><ptr>const&#160;char</ptr><parameter>buf</parameter></csparam>
    <csparam><type>size_t</type><parameter>buf_len</parameter></csparam>
   </csproto>
   <header>&argz.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&asunsafe; &heap;</concept>
    <concept>&acunsafe; &mem;</concept>
   </conceptlist>
   <para>
    <code>argz_append</code> işlevi, <parameter>buf_len</parameter> değerini *<parameter>argz_len</parameter>'e ve <parameter>buf</parameter>  ile başlayan dizgeyi yeniden tahsis edilen *<parameter>argz</parameter> vektörüne ekler.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-argz_delete"><primary>argz_delete</primary></indexterm>
   <csproto type="işlev">
    <csname><type>void</type><function>argz_delete</function></csname>
    <csparam><pptr>char</pptr><parameter>argz</parameter></csparam>
    <csparam><ptr>size_t</ptr><parameter>argz_len</parameter></csparam>
    <csparam><ptr>char</ptr><parameter>entry</parameter></csparam>
   </csproto>
   <header>&argz.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&asunsafe; &heap;</concept>
    <concept>&acunsafe; &mem;</concept>
   </conceptlist>
   <para>
    Eğer <parameter>entry</parameter>, *<parameter>argz</parameter> vektörünün elemanlarından birinin başlangıcını gösteriyorsa, <code>argz_delete</code> işlevi bu girdiyi silip *<parameter>argz_len</parameter>'i ve yeniden tahsis edilen *<parameter>argz</parameter> vektörünü günceller. Eleman silen argz işlevleri genelde <parameter>argz</parameter> bağımsız değişkenleri için yeniden bellek tahsis ettiklerinden buradaki <parameter>entry</parameter> göstericisinde olduğu gibi kaldırılan elemanın göstericisi geçersiz duruma gelir.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-argz_insert"><primary>argz_insert</primary></indexterm>
   <csproto type="işlev">
    <csname><type>error_t</type><function>argz_insert</function></csname>
    <csparam><pptr>char</pptr><parameter>argz</parameter></csparam>
    <csparam><ptr>size_t</ptr><parameter>argz_len</parameter></csparam>
    <csparam><ptr>char</ptr><parameter>before</parameter></csparam>
    <csparam><ptr>const&#160;char</ptr><parameter>entry</parameter></csparam>
   </csproto>
   <header>&argz.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&asunsafe; &heap;</concept>
    <concept>&acunsafe; &mem;</concept>
   </conceptlist>
   <para>
    <code>argz_insert</code> işlevi, <parameter>entry</parameter> dizgesini *<parameter>argz</parameter> vektörünün <parameter>before</parameter> ile gösterilen elemanının öncesine ekleyip <parameter>argz_len</parameter>'i ve yeniden tahsis edilen *<parameter>argz</parameter> vektörünü günceller. Eğer <parameter>entry</parameter> <code>0</code> ise işlev <function>argz_add</function> işlevinin yaptığı gibi elemanı sona ekler. İlk eleman *<parameter>argz</parameter> ile aynı olduğundan <parameter>before</parameter> için *<parameter>argz</parameter> verilirse, <parameter>entry</parameter> dizgesi başa eklenir.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-argz_next"><primary>argz_next</primary></indexterm>
   <csproto type="işlev">
    <csname><ptr>char</ptr><function>argz_next</function></csname>
    <csparam><ptr>const&#160;char</ptr><parameter>argz</parameter></csparam>
    <csparam><type>size_t</type><parameter>argz_len</parameter></csparam>
    <csparam><ptr>const&#160;char</ptr><parameter>entry</parameter></csparam>
   </csproto>
   <header>&argz.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <code>argz_next</code> işlevi <parameter>argz</parameter> vektöründeki elemanları yinelemek için uygun bir yol sağlar. <parameter>argz</parameter> vektöründe <parameter>entry</parameter> elemanından sonraki elemana ya bir gösterici ile döner ya da <parameter>entry</parameter> elemanını izleyen bir eleman yoksa <code>0</code> ile döner. <parameter>entry</parameter> olarak <code>0</code> verilirse, <parameter>argz</parameter> vektörünün ilk elemanı döner.
   </para>
   <para>
    Bu davranış iki yineleme tarzını akla getirir:
   </para>
   <example>
    <screen>char *entry = 0;
while ((entry = argz_next (<parameter>argz</parameter>, <parameter>argz_len</parameter>, entry)))
  <replaceable>eylem</replaceable>;
</screen>
    <para>
     (Çift yaylı ayraç kullanımı, bazı C derleyicilerinin <statement>while</statement> sınaması sırasında şüpheli buldukları şeyler hakkında susmasını sağlamak için gereklidir.) ve:
    </para>
<screen>
char *entry;
for (entry = <parameter>argz</parameter>;
     entry;
     entry = argz_next (<parameter>argz</parameter>, <parameter>argz_len</parameter>, entry))
  <replaceable>eylem</replaceable>;
</screen>
    <para>
     İkincisi <parameter>argz</parameter> vektörünün boş olması durumunda boş bellek dilimine gösterici değil, <code>0</code> değerinde olması gerekliliğine bağlıdır; bu sabit, buradaki işlevler tarafından oluşturulan argz işlevleri için sağlanmıştır.
    </para>
   </example>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-argz_replace"><primary>argz_replace</primary></indexterm>
   <csproto type="işlev">
    <csname><type>error_t</type><function>argz_replace</function></csname>
    <csparam><pptr>char</pptr><parameter>argz</parameter></csparam>
    <csparam><ptr>size_t</ptr><parameter>argz_len</parameter></csparam>
    <csparam><ptr>const&#160;char</ptr><parameter>str</parameter></csparam>
    <csparam><ptr>const&#160;char</ptr><parameter>with</parameter></csparam>
    <csparam><ptr>unsigned&#160;int</ptr><parameter>replace_count</parameter></csparam>
   </csproto>
   <header>&argz.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&asunsafe; &heap;</concept>
    <concept>&acunsafe; &mem;</concept>
   </conceptlist>
   <para>
    içindeki <parameter>str</parameter> dizgelerini <parameter>with</parameter> dizgesi ile değiştirir ve <parameter>argz</parameter> için gerekliyse yeniden bellek tahsis eder. <parameter>replace_count</parameter> sıfırdan farklı ise *<parameter>replace_count</parameter> uygulanan yer değiştirmenin sayısı kadar arttırılır.
   </para>
  </csynopsis>
  </sect1>
  <sect1 xml:id="glibc-Envz-Functions">
   <title>Envz İşlevleri</title>
   <titleabbrev>Ortam vektörlerine uygulanan diğer işlemler.</titleabbrev>
   <para>
    Envz vektörleri her elemanının üzerindeki ek kısıtlamalar dışında argz vektörleri gibidir; örneğin, gerekirse, üzerlerinde argz işlevleri de kullanılabilir.
   </para>
   <para>
    Envz vektörünün her elemanı <code>'='</code> ile ayrılmış bir isim-değer çiftidir; eğer bir eleman içinde birden fazla <code>'='</code> karakteri varsa bu karakterlerden ilkinden sonraki dizge değer olarak kabul edilir ve diğer tüm <code>'\0'</code> olmayan baytlar gibi ele alınır.
   </para>
   <para>
    Eleman bir <code>'='</code> karakteri içermiyorsa, eleman "null" değerli bir girdinin ismi kabul edilir. Bu girdiyi boş değerli girdiden ayırmak için:
    <function>envz_get</function> işlevi isim bir null girdinin ismi ise <code>0</code> ile döner, aksine girdi boş değer içeriyorsa <code>""</code> ile döner; <function>envz_entry</function> işlevi bu tür girdileri nasıl olursa olsun bulacaktır. Null girdiler <function>envz_strip</function> işlevi ile kaldırılabilir.
   </para>
   <para>
    Argz işlevlerindeki gibi, envz işlevleri de bellek ayırabildiğinden <type>error_t</type> türünde dönüş değeri vardır ve ya <code>0</code> ya da <varname>ENOMEM</varname> ile döner.
   </para>
   <para>
    <indexterm linkend="glibc-pg"><primary>envz.h</primary></indexterm>
    Bu işlevler &envz.h; başlık dosyasında dosyasında bildirilmiştir.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-envz_entry"><primary>envz_entry</primary></indexterm>
    <csproto type="işlev">
     <csname><ptr>char</ptr><function>envz_entry</function></csname>
     <csparam><ptr>const&#160;char</ptr><parameter>envz</parameter></csparam>
     <csparam><type>size_t</type><parameter>envz_len</parameter></csparam>
     <csparam><ptr>const&#160;char</ptr><parameter>name</parameter></csparam>
    </csproto>
    <header>&envz.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     <code>envz_entry</code> işlevi <parameter>envz</parameter> içinde <parameter>name</parameter> adlı girdiyi bulur ve bu girdiye (<parameter>name</parameter> ile başlar ve <code>'='</code> ile devam eder) gösterici ile döner. <parameter>name</parameter> içeren bir girdi yoksa <code>0</code> döner.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-envz_get"><primary>envz_get</primary></indexterm>
    <csproto type="işlev">
     <csname><ptr>char</ptr><function>envz_get</function></csname>
     <csparam><ptr>const&#160;char</ptr><parameter>envz</parameter></csparam>
     <csparam><type>size_t</type><parameter>envz_len</parameter></csparam>
     <csparam><ptr>const&#160;char</ptr><parameter>name</parameter></csparam>
    </csproto>
    <header>&envz.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     <code>envz_get</code> işlevi <parameter>envz</parameter> içinde <parameter>name</parameter> adlı girdiyi bulur ve bu elemanın değer parçasına (<code>'='</code> karakterinden sonrası) gösterici ile döner. Eğer <code>'='</code> içeren bir girdi yoksa ya da girdi sadece isim parçasından oluşuyorsa (null girdi), <code>0</code> döner.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-envz_add"><primary>envz_add</primary></indexterm>
    <csproto type="işlev">
     <csname><type>error_t</type><function>envz_add</function></csname>
     <csparam><pptr>char</pptr><parameter>envz</parameter></csparam>
     <csparam><ptr>size_t</ptr><parameter>envz_len</parameter></csparam>
     <csparam><ptr>const&#160;char</ptr><parameter>name</parameter></csparam>
     <csparam><ptr>const&#160;char</ptr><parameter>value</parameter></csparam>
    </csproto>
    <header>&envz.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&asunsafe; &heap;</concept>
     <concept>&acunsafe; &mem;</concept>
    </conceptlist>
    <para>
     <code>envz_add</code> işlevi, <parameter>name</parameter> isimli ve <parameter>value</parameter> değerli bir girdiyi *<parameter>envz</parameter> vektörüne ekler ve *<parameter>envz</parameter> ile *<varname>envz_boyu</varname>’nu güncelleyerek *<parameter>envz</parameter> için yeniden bellek tahsis eder. <parameter>envz</parameter> içinde <parameter>name</parameter> isminde bir girdi varsa önce bu girdi kaldırılır. Eğer <parameter>value</parameter> <code>0</code> ise, yeni girdi null türünde özel bir girdi (yukarıda bahsedilmişti) olacaktır.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-envz_merge"><primary>envz_merge</primary></indexterm>
    <csproto type="işlev">
     <csname><type>error_t</type><function>envz_merge</function></csname>
     <csparam><pptr>char</pptr><parameter>envz</parameter></csparam>
     <csparam><ptr>size_t</ptr><parameter>envz_len</parameter></csparam>
     <csparam><ptr>const&#160;char</ptr><parameter>envz2</parameter></csparam>
     <csparam><type>size_t</type><parameter>envz2_len</parameter></csparam>
     <csparam><type>int</type><parameter>override</parameter></csparam>
    </csproto>
    <header>&envz.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&asunsafe; &heap;</concept>
     <concept>&acunsafe; &mem;</concept>
    </conceptlist>
    <para>
     <code>envz_merge</code> işlevi, <parameter>envz2</parameter> içindeki girdileri <parameter>envz</parameter> vektörüne ekler ve <function>envz_add</function> işlevindeki gibi *<parameter>envz</parameter> ve *<parameter>envz_len</parameter>’i günceller. Eğer <parameter>override</parameter> doğru ise, <parameter>envz2</parameter> içindeki girdilerden <parameter>envz</parameter> içinde olanlar varsa <parameter>envz2</parameter> içindekiler <parameter>envz</parameter> içindekilerin üstüne yazılır, değilse üste yazılmaz.
    </para>
    <para>
     Null girdiler de diğer girdiler gibi ele alınır. Yani, her iki vektörde de aynı isimde iki girdi varsa, <parameter>envz</parameter> içindeki bir null girdi ise ve <parameter>override</parameter> yanlışsa, <parameter>envz2</parameter> içindeki girdi <parameter>envz</parameter> vektörüne eklenmez.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-envz_strip"><primary>envz_strip</primary></indexterm>
    <csproto type="işlev">
     <csname><type>void</type><function>envz_strip</function></csname>
     <csparam><pptr>char</pptr><parameter>envz</parameter></csparam>
     <csparam><ptr>size_t</ptr><parameter>envz_len</parameter></csparam>
    </csproto>
    <header>&envz.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     <code>envz_strip</code> işlevi <parameter>envz</parameter> içindeki null girdileri kaldırıp *<parameter>envz</parameter> ve *<parameter>envz_len</parameter>’i günceller.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-envz_remove"><primary>envz_remove</primary></indexterm>
    <csproto type="işlev">
     <csname><type>void</type><function>envz_remove</function></csname>
     <csparam><pptr>char</pptr><parameter>envz</parameter></csparam>
     <csparam><ptr>size_t</ptr><parameter>envz_len</parameter></csparam>
     <csparam><ptr>const&#160;char</ptr><parameter>name</parameter></csparam>
    </csproto>
    <header>&envz.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&asunsafe; &heap;</concept>
     <concept>&acunsafe; &mem;</concept>
    </conceptlist>
    <para>
     <code>envz_remove</code> işlevi <parameter>envz</parameter> içindeki <parameter>name</parameter> adlı girdiyi kaldırıp*<parameter>envz</parameter> ve *<parameter>envz_len</parameter>’i günceller.
    </para>
   </csynopsis>
  </sect1>
 </chapter>
</part>

