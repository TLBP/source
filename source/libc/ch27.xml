<?xml version="1.0" encoding="UTF-8"?>
<!-- ********************************************************************
     $Id: ch27.xml,v 1.2 2002/12/20 22:29:48 nilgun Exp $
******************************************************************** -->
<part id="glibc-Job-Control">
  <title>İş Denetimi</title>
  <titleabbrev>Süreç grupları ve oturumlar hakkında herşey.</titleabbrev>
  <partintro><para>
<indexterm scope="glibc-cp"><primary>süreç grubu</primary></indexterm>
<indexterm scope="glibc-cp"><primary>iş denetimi</primary></indexterm>
<indexterm scope="glibc-cp"><primary>oturum</primary></indexterm>
<wordasword>İş denetimi</wordasword> bir kullanıcıya tek bir <wordasword>sisteme giriş oturumu</wordasword> içinde çok sayıda <wordasword>süreç grubu</wordasword> (ya da <wordasword>iş</wordasword>) arasında hareket imkanı veren bir protokoldür. İş denetimi oluşumları çoğu süreci işlerini özdevinmli olarak yapmaları için ayarlar ve bunun olması için bu yazılımların iş denetimi ile ilgili hiçbir şey yapmaları gerekmez. Dolayısıyla, eğer bir kabuk ya da bir oturum açma uygulaması yazmıyacaksanız bu oylumda bahsedilenleri yoksayabilirsiniz.
  </para><para>
Bu oylumda bahsedilenleri daha iyi anlayabilmek için <link linkend="glibc-Process-Creation-Concepts">süreç oluşturma</link> ve <link linkend="glibc-Signal-Handling">sinyal işleme</link> ile ilgili kavramlar hakkında bilgi sahibi olmanız gerekir.
  </para></partintro>
  <chapter id="glibc-Concepts-of-Job-Control">
    <title>İş Denetimi Kavramları</title>
    <titleabbrev>İşler bir kabuk tarafından denetlenebilir.</titleabbrev>
    <para>
<indexterm scope="glibc-cp"><primary>kabuk</primary></indexterm>
Bir etkileşimli kabuğun temel amacı kullanıcının uçbiriminden komutları okumak ve bu komutlarla belirtilen yazılımları çalıştırarak süreçler oluşturmaktır. Kabuk bunu <command>fork</command> (<xref linkend="glibc-Creating-a-Process"/>) ve <command>exec</command> (<xref linkend="glibc-Executing-a-File"/>) işlevlerini kullanarak yapabilir.
   </para><para>
Tek bir komut sadece bir süreci çalıştırmalı gibi düşünülebilir ama çoğunlukla bir komut çeşitli süreçleri kullanır. Bir kabuk komutunda <command>|</command> işlecini kullanarak, doğrudan kendi süreçleri içinde çeşitli uygulamaları çalıştırabilirsiniz. Ama sadece tek bir uygulamayı çalıştırmak istemiş olsanız bile bu uygulama dahili olarak çok sayıda süreci kullanabilir. Örneğin, <command>cc -c foo.c</command> gibi tek bir komut (normalde iki olmasına rağmen) genellikle dört süreç  gerektirir. Hele bir <command>make</command> komutunu vardır ki, onun işi ayrı süreçler halinde başka uygulamaları çalıştırmaktır.
   </para><para>
Tek bir komuta bağlı olarak çalışan süreçlere <wordasword>süreç grubu</wordasword> ya da <wordasword>iş</wordasword> denir. Bu hepsinin aynı anda çalışmasından dolayıdır. Örneğin, <command>C-c</command> tuşlayıp <command>SIGINT</command> sinyali göndererek önalan süreç grubundaki tüm süreçleri sonlandırabilirsiniz.
   </para><para>
<indexterm scope="glibc-cp"><primary>oturum</primary></indexterm>
Bir <wordasword>oturum</wordasword> geniş bir süreçler grubudur. Normalde tüm süreçler tek bir oturum açılışında aynı oturuma ait olarak oluşturulurlar.
   </para><para>
Her süreç bir süreç grubuna aittir. Bir süreç oluşturulduğu zaman, onun ata süreci ile aynı süreç grubunun ve oturumun bir üyesi haline gelir. Onu aynı oturuma ait bir süreç grubu olan başka bir süreç grubuna <command>setpgid</command> işlevini kullanarak koyabilirsiniz.
   </para><para>
<indexterm scope="glibc-cp"><primary>oturum</primary><secondary>oturum lideri</secondary></indexterm>
Bir süreci başka bir oturuma yerleştirmenin tek çaresi onu yeni bir oturumun ilk süreci ya da <command>setsid</command> işlevini kullanarak bir <wordasword>oturum lideri</wordasword> yapmaktır. Bu işlem ayrıca oturum liderini yeni bir süreç grubuna yerleştirir ve artık onu bu süreç grubundan tekrar dışarı taşıyamazsınız.
   </para><para>
Çoğunlukla, yeni oturumları sistemin login komutu oluşturur ve oturum lideri kullanıcının oturum açma kabuğunu çalıştıran süreç olur.
   </para><para>
<indexterm scope="glibc-cp"><primary>denetim uçbirimi</primary></indexterm>
İş denetimi desteği olan bir kabuk, her an uçbirimi kullanabilecek işi denetleyecek düzenlemeyi yapmalıdır. Aksi takdirde uçbirimden okumayı deneyen çok sayıda iş olabilir ve kullanıcı tarafından yazılan girdileri hangi sürecin alacağı konusunda karışıklık çıkar. Bundan kaçınmak için kabuk, bu oylumda bahsedilen protokolü kullanarak uçbirim sürücüsü ile işbirliği yapmalıdır.
   </para><para>
<indexterm scope="glibc-cp"><primary>önalan işi</primary></indexterm>
<indexterm scope="glibc-cp"><primary>artalan işi</primary></indexterm>
Kabuk, bir defada sadece bir sürece denetim uçbiriminde sınırsız erişim verebilir. Denetim uçbirimine sınırsız erişim yapabilen sürece <wordasword>önalan işi</wordasword> denir. Kabuk tarafından yönetilen ve uçbirime bu tür bir erişimi olmayan diğer süreç gruplarına ise <wordasword>artalan işleri</wordasword> denir.
   </para><para>
<indexterm scope="glibc-cp"><primary>durmuş iş</primary></indexterm>
Eğer artalan işlerinden biri denetim uçbiriminden okuma yapmak ihtiyacı duyarsa, uçbirim sürücüsü tarafından <firstterm>durdurulur</firstterm>;  eğer <command>TOSTOP</command> kipi etkinse, yazmak istediğinde de durdurulur. Bir önalan işini bir kullanıcı <link linkend="glibc-Special-Characters">SUSP karakterini</link> kullanarak durdurabileceği gibi bir süreç de bir <command>SIGSTOP</command> sinyali göndererek durdurabilir. İşler durduğunda uyarmak, bunlar hakkında kullanıcıyı uyarmak ve durdurulan işlerin kullanıcı ile etkileşimli olarak sürdürülmesini ve artalan işleri ile önalan işi arasında geçişi mümkün kılmak için mekanizmalar sağlamak kabuğun sorumluluğudur.
   </para><para>
Denetim uçbiriminde G/Ç işlemleri hakkında daha fazla bilgi edinmek için <xref linkend="glibc-Access-to-the-Terminal"/> bölümüne bakınız.
   </para></chapter>
  <chapter id="glibc-Job-Control-is-Optional">
    <title>İş Denetimi İsteğe Bağlıdır</title>
    <titleabbrev>POSIX sistemlerinin bazılarında iş denetimi desteği yoktur.</titleabbrev>
    <para>
<indexterm scope="glibc-cp"><primary>iş denetimi isteğe bağlıdır</primary></indexterm>
İşletim sistemlerinin bazıları iş denetimini desteklemez. GNU sistemi iş denetimini desteklese de, kütüphaneyi kullandığınız diğer sistemlerde sistemin kendisi iş denetimini desteklemeyebilir.
   </para><para>
Sistemin iş denetimini destekleyip desteklemediğini <command>_POSIX_JOB_CONTROL</command> makrosunu kullanarak derleme sırasında sınayabilirsiniz. Bkz. <xref linkend="glibc-System-Options"/>.
   </para><para>
İş denetimi desteklenmiyorsa, her oturumda daima önalanda çalışan sadece bir süreç grubu olabilir. Ek süreç grupları oluşturan işlevler <command>ENOSYS</command> hata durumu ile başarısız olurlar.
   </para><para>
Çeşitli <link linkend="glibc-Job-Control-Signals">iş denetim sinyallerini isimlendiren makrolar</link> iş denetimi desteği olmasa bile tanımlanır. Ancak sistem bu sinyalleri hiçbir zaman üretmez ve bir iş denetim sinyalinin gönderilmesi, incelenmesi ya da eylemlerinin belirtilmesi ya hatalarla raporlanır ya da bir şeye sebep olmaz.
   </para></chapter>
  <chapter id="glibc-Controlling-Terminal">
    <title>Bir Sürecin Denetim Uçbirimi</title>
    <titleabbrev>Bir süreç kendi denetim uçbirimini nasıl edinir.</titleabbrev>
    <para>
Bir sürecin özniteliklerinden biri de kendi denetim uçbirimidir. <command>fork</command> ile oluşturulan alt süreçler denetim uçbirimlerini kendilerini oluşturan süreçten miras alırlar. Bu yolla, bir oturumdaki tüm süreçler denetim uçbirimini oturum liderinden miras alırlar. Bir oturum liderinin bir uçbirimin denetimine sahip olması, onu, bu uçbirimin <wordasword>denetçi süreci</wordasword> haline getirir.
   </para><para>
<indexterm scope="glibc-cp"><primary>denetçi süreç</primary></indexterm>
Genelde, siz sisteme oturum açarken işlem sizin yerinize sistem tarafından yapıldığından bir denetim uçbiriminin ayrılmasında kullanılan mekanizma hakkında endişelenmeniz gerekmez.
   </para><para>
Bir süreç, <command>setsid</command> çağrısı ile yeni bir oturumun lideri haline gelerek kendi denetim uçbiriminden kopar. Bkz. <xref linkend="glibc-Process-Group-Functions"/>.
   </para></chapter>
  <chapter id="glibc-Access-to-the-Terminal">
    <title>Denetim Uçbirimine Erişim</title>
    <titleabbrev>Süreçler denetim uçbirimini nasıl paylaşır.</titleabbrev>
    <para>
<indexterm scope="glibc-cp"><primary>denetim uçbirimi</primary><secondary>erişim</secondary></indexterm>
Bir denetim uçbiriminin önalan işindeki süreçlerin uçbirime erişimi sınırlandırılmamıştır. Bu kısımda, artalandaki bir sürecin kendi denetim uçbirimine erişmeye çalıştığı zaman neler olduğu ayrıntılı olarak açıklanacaktır.
   </para><para>
<indexterm scope="glibc-cp"><primary><command>SIGTTIN</command> sinyali</primary><secondary>artalan işinden</secondary></indexterm>
Artalandaki bir süreç kendi denetim uçbiriminden okumaya çalıştığı zaman, süreç grubuna çoğu kez bir <command>SIGTTIN</command> sinyali gönderilir. Bu normalde süreç grubundaki tüm süreçlerin durmasına sebep olur (sinyali yakalamıyorlarsa ve kendilerini durdurmamışlarsa). Ancak, eğer okuyan süreç bu sinyali yoksayıyor ya da engelliyorsa, <command>read</command> işlevi bir <command>EIO</command> hatasıyla başarısız olacaktır.
   </para><para>
<indexterm scope="glibc-cp"><primary><command>SIGTTOU</command> sinyali</primary><secondary>artalan işinden</secondary></indexterm>
Benzer olarak, artalandaki bir süreç kendi denetim uçbirimine yazmaya çalıştığı zaman, öntanımlı davranış süreç grubuna bir <command>SIGTTOU</command> sinyali göndermektir. Ancak, bu davranış yerel kip seçeneklerinden <command>TOSTOP</command> biti tarafından değiştirilir (bkz. <xref linkend="glibc-Local-Modes"/>). Bu bit etkin değilse (öntanımlı böyledir), denetim uçbirimine yazma işlemine bir sinyal gönderilmeksizin daima izin verilir. Yazmaya ayrıca, yazan süreç tarafından <command>SIGTTOU</command> sinyali yoksayılıyor ya da engelleniyorsa da izin verilir.
   </para><para>
Diğer uçbirim işlemlerinden çoğu birer okuma ya da yazma işlemi olarak ele alınır. (Her işlemin açıklamasında hangisi olduğu belirtilmiştir).
   </para><para>
İlkel <command>read</command> ve <command>write</command> işlevleri hakkında daha fazla bilgi için <xref linkend="glibc-I-O-Primitives"/> bölümüne bakınız.
   </para></chapter>
  <chapter id="glibc-Orphaned-Process-Groups">
    <title>Öksüz Süreç Grubu</title>
    <titleabbrev>Kullanıcı oturumu kapattıktan sonra sahipsiz kalan süreçler.</titleabbrev>
    <para>
<dicterm><english>orphaned process</english><turkish>öksüz süreç</turkish></dicterm>
<indexterm scope="glibc-cp"><primary>öksüz süreç grubu</primary></indexterm>
<indexterm scope="glibc-cp"><primary>süreç grubu</primary><secondary>öksüz kalmış</secondary></indexterm>
Bir denetim süreci sonlandığında onun uçbirimi serbest kalır ve yeni bir oturum başlatmaya hazır hale gelir. (Bu işlem gerçekte başka bir kullanıcının sistemde oturum açabilmesi demektir.) Eğer eski oturumdan kalan bir süreç hala uçbirimi kullanmaya çalışırsa bu sorunlara sebep olur.
   </para><para>
Bu sorunlardan kaçınmak için, oturumun lideri olan süreç sonlansa bile süreç, <wordasword>öksüz süreç grubu</wordasword> adı verilen bir süreç grubuna alınarak çalışmasına devam etmesi sağlanır.
   </para><para>
Bir süreç grubu öksüz kaldığında, süreçlerine <command>SIGHUP</command> sinyali gönderilir. Diğer yandan bir uygulama bu sinyali yoksayar ya da onun için bir sinyal eylemci kurarsa (<xref linkend="glibc-Signal-Handling"/>), bu süreci denetleyen süreç sonlandıktan sonra bile süreç, öksüz süreç grubuna alınarak çalışmasına devam edebilir; ancak ne olursa olsun bundan sonra uçbirime erişemez.
   </para></chapter>
  <chapter id="glibc-Implementing-a-Shell">
    <title>Bir İş Denetim kabuğunun Gerçeklenmesi</title>
    <titleabbrev>İş denetimini gerçekleştirmek için bir kabuk ne yapmalıdır.</titleabbrev>
    <para>
Bu kısımda, iş denetimini gerçekleştirmek için bir kabuğun neler yapması gerektiği, bahsi geçen kavramları örnekleyen kapsamlı bir yazılım örneği de verilerek açıklanacaktır.
   </para>
    <sect1 id="glibc-Data-Structures">
      <title>Kabuk için Veri Yapıları</title>
      <titleabbrev>Örnek kabuğa giriş.</titleabbrev>
      <para>
Bu kısımdaki yazılım örneklerinin hepsi basit bir kabuk yazılımının parçalarıdır. Bu bölümdeki veri yapıları ve işlevler örnekte kullanmak içindir.
    </para><para>
Örnek kabukta başlıca iki veri yapısı bulunur.  <command>job</command> türü, birbirine borularla bağlanan altsüreçlerden oluşan bir iş ile ilgili bilgileri içerir. <command>process</command> türü ise, tek bir altsüreç hakkında bilgi içerir. Bu veri yapılarının bildirimleri:
    </para><para>
 <screen>/* process yapısı tek bir süreçle ilgilidir.  */
typedef struct process
{
  struct process *next;       /* boruhattındaki sonraki süreç */
  char **argv;                /* exec için */
  pid_t pid;                  /* süreç kimliği */
  char completed;             /* süreç tamamlanmışsa doğru */
  char stopped;               /* süreç durmuşsa doğru */
  int status;                 /* raporlanan durum değeri */
} process;

/* job yapısı boruhattıyla bağlı süreçlerden oluşur.  */
typedef struct job
{
  struct job *next;           /* sonraki etkin iş */
  char *command;              /* komut satırı, iletiler için */
  process *first_process;     /* bu işteki süreçlerin listesi */
  pid_t pgid;                 /* süreç grubu kimliği */
  char notified;              /* duran iş için kullanıcıya uyarı varsa doğru */
  struct termios tmodes;      /* kayıtlı uçbirim kipleri */
  int stdin, stdout, stderr;  /* standart g/ç kanalları */
} job;

/* Etkin iş bir listeyle ilintilenir.  Bu onun başıdır.   */
job *first_job = NULL;
</screen></para><para>
<command>job</command> nesneleri üzerinde işlem yapan bazı işlevler:
    </para><para>
<screen>/* pgid ile belirtilen etkin işi bul.  */
job *
find_job (pid_t pgid)
{
  job *j;

  for (j = first_job; j; j = j->next)
    if (j->pgid == pgid)
      return j;
  return NULL;
}

/* İşteki tüm süreçler durmuş ya da tamamlanmışsa "doğru" ile dön.  */
int
job_is_stopped (job *j)
{
  process *p;

  for (p = j->first_process; p; p = p->next)
    if (!p->completed &amp;&amp; !p->stopped)
      return 0;
  return 1;
}

/* İşteki tüm süreçler tamamlanmışsa "doğru" ile dön.  */
int
job_is_completed (job *j)
{
  process *p;

  for (p = j->first_process; p; p = p->next)
    if (!p->completed)
      return 0;
  return 1;
}
</screen></para></sect1>
    <sect1 id="glibc-Initializing-the-Shell">
      <title>Kabuğun İlklendirilmesi</title>
      <titleabbrev>İş denetiminin sorumluluğunu alacak kabuk ne yapmalıdır.</titleabbrev>
      <para>
<indexterm scope="glibc-cp"><primary>iş denetimi</primary><secondary>etkinleştirme</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>altkabuk</primary></indexterm>
Normalde iş denetimi yapan bir kabuk başlatıldığında, kendi iş denetimini yapan başka bir kabuk tarafından çalıştırılmışsa dikkatli olmak zorundadır.
    </para><para>
Etkileşimli olarak çalışan bir altkabuk kendi iş denetimini etkinleştirmeden önce kendini çalıştıran kabuk tarafından önalana mı yerleştirildiğine bakmak zorundadır. <command>getpgrp</command> işlevi ile kendi süreç grup kimliğini öğrenip, bunu kendi denetim uçbiriminin önalan işinin süreç grup kimliği (<command>tcgetpgrp</command> işlevi ile öğrenebilir) ile karşılaştırarak yapar.
    </para><para>
Eğer altkabuk bir önalan işi olarak çalışmıyorsa, kendi süreç grubuna bir <command>SIGTTIN</command> sinyali göndererek kendini durdurmalıdır. Kendini keyfi olarak önalana yerleştiremez; bunu kendini çalıştıran kabuğa kullanıcının söylemesini beklemek zorundadır. Eğer alt kabuk yine de devam ederse bu sınamayı tekrarlayıp hala önalanda değilse, kendini tekrar durdurmalıdır.
    </para><para>
Bir alt kabuk kendini çalıştıran kabuk tarafından önalana yerliştirildikten sonra kendi iş denetimini etkinleştirebilir. Bunu <command>setpgid</command> işlevini çağırıp kendini, kendi süreç grubuna koyduktan sonra <command>tcsetpgrp</command> çağrısıyla bu süreç grubunu önalana yerleştirerek yapar.
    </para><para>
Bir kabuk iş denetimini etkinleştirdiğinde, kendini tüm iş denetimi durdurma sinyallerini yoksaymaya ayarlayıp kazaen kendi kendini durdurma şansını ortadan kaldırmalıdır. Bunu tüm durdurma sinyalllerine eylem olarak <command>SIG_IGN</command> atayarak yapabilirsiniz.
    </para><para>
Etklileşimsiz olarak çalışan bir kabuk iş denetimini destekleyemez ve desteklememelidir. Kendi süreç grubunda oluşturulan tüm süreçleri bırakmalıdır; bu onu etkileşimsiz kabuk yapar. Onun alt süreçleri kendini çalıştıran kabuğun tek tek işleri olarak ele alınır. Bunu yapmak kolaydır, iş denetim ilkellerini kullanmamak yeterlidir, ama bunu kabuğa yaptırmayı unutmamalısınız.
    </para><para>
Burada bunun örnek kabuğumuz tarafından ilklendirme kodunda nasıl yapıldığı gösterilmiştir.
    </para><para>
<screen>/* Kabuğun özniteliklerini hatırlayalım.  */

#include &lt;sys/types.h>
#include &lt;termios.h>
#include &lt;unistd.h>

pid_t shell_pgid;
struct termios shell_tmodes;
int shell_terminal;
int shell_is_interactive;


/* Başlamadan önce kabuğun önalan işi olarak etkileşimli
   çalışacağından emin olalım. */

void
init_shell ()
{

  /* Etkileşimli mi çalışıyor acaba.  */
  shell_terminal = STDIN_FILENO;
  shell_is_interactive = isatty (shell_terminal);

  if (shell_is_interactive)
    {
      /* Önalana geçinceye kadar döngüde kalsın.  */
      while (tcgetpgrp (shell_terminal) != (shell_pgid = getpgrp ()))
        kill (- shell_pgid, SIGTTIN);

      /* Etkileşimli ve iş denetimi sinyallarini yoksayalım.  */
      signal (SIGINT, SIG_IGN);
      signal (SIGQUIT, SIG_IGN);
      signal (SIGTSTP, SIG_IGN);
      signal (SIGTTIN, SIG_IGN);
      signal (SIGTTOU, SIG_IGN);
      signal (SIGCHLD, SIG_IGN);

      /* Kendimizi kendi süreç grubumuza koyalım.  */
      shell_pgid = getpid ();
      if (setpgid (shell_pgid, shell_pgid) &lt; 0)
        {
          perror ("Kabuk kendini kendi süreç grubuna yerleştiremedi");
          exit (1);
        }

      /* Uçbirim denetimini ele geçirelim.  */
      tcsetpgrp (shell_terminal, shell_pgid);

      /* Kabuğun öntanımlı uçbirim öznitelikerini saklayalım.  */
      tcgetattr (shell_terminal, &amp;shell_tmodes);
    }
}
</screen></para></sect1>
    <sect1 id="glibc-Launching-Jobs">
      <title>İşlerin Başlatılması</title>
      <titleabbrev>Komutları çalıştırarak işlerin oluşturulması.</titleabbrev>
      <para>
<indexterm scope="glibc-cp"><primary>işlerin başlatılması</primary></indexterm>
Kabuk kendi denetim uçbiriminde iş denetimi uygulamak için sorumluluğu aldıktan sonra, kullanıcı tarafından yazılan komutlara yanıt olarak işleri başlatabilir.
    </para><para>
Bir süreç grubunda süreçleri oluşturmak için <xref linkend="glibc-Process-Creation-Concepts"/> bölümünde açıklandığı gibi  <command>fork</command> ve <command>exec</command> işlevleri kullanılabilir. Çok sayıda alt süreç karışık olduğundan, ister istemez, bazı şeyler biraz karmaşıklaşır, bu bakımdan bunları doğru sırada yapmak önem kazanır. Aksi takdirde istenmeyen yarış koşulları ortaya çıkabilir.
    </para><para>
Süreçlerle ilgili ata-çocuk birliktelik ağacının yapılanmasında yerine göre iki seçimden birini kullanabilirsiniz. Ya, süreç grubundaki tüm süreçleri kabuk sürecinin çocukları yaparsınız ya da, süreç grubundaki bir süreci gruptaki diğer süreçlerin atası yaparsınız. Tıpkı, bu oylumun tamamındaki örnekleri basit bir kabuk yazılımının parçaları olarak vermemiz gibi, çünkü bu, bazı şeylerin muhasebesini yapmayı koloylaştırıyor.
    </para><para>
<indexterm scope="glibc-cp"><primary>süreç grubu</primary><secondary>lideri</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>süreç grubu</primary><secondary>kimliği</secondary></indexterm>
Her süreç çatallandığında, <command>setpgid</command> çağrısı ile kendini yeni süreç grubuna koymalıdır; bkz. <xref linkend="glibc-Process-Group-Functions"/>. Süreç grubundaki ilk süreç <wordasword>süreç grubunun lideri</wordasword> haline gelir ve onun süreç kimliği de <wordasword>süreç grup kimliği</wordasword> haline gelir.
    </para><para>
<indexterm scope="glibc-cp"><primary>yarış koşulları</primary><secondary>iş denetimi ile ilgili</secondary></indexterm>
Kabuk buna ek olarak kendi alt süreçlerinini yeni süreç grubuna koymak için her süreç için ayrı ayrı <command>setpgid</command> çağrıları yapmalıdır. Olası bir zamanlama sorunu nedeniyle bunun böyle olması gerekir: her alt süreç kendi alt sürecini çalıştırmaya başlamadan önce süreç grubuna konulmak ve dolayısıyla kabuk çalışamaya devam etmeden önce grubundaki alt süreçlerini bağlamak zorundadır. Eğer hem kabuk hem de alt süreci <command>setpgid</command> çağrısı yaparsa, hangi sürecin bunu önce yaptığına bakılmaksızın işler olması gerektiği gibi yürür.
    </para><para>
Eğer iş bir önalan işi olarak başlatılmışsa, yeni süreç grubunun ayrıca <command>tcsetpgrp</command> kullanılarak denetim uçbiriminde önalana konulması gerekir. Tekrar, yarış koşullarından kaçınmak için bu işlem, hem kabuk tarafından hem de kabuğun alt süreçlerinin her biri tarafından yapılmalıdır.
    </para><para>
Bundan sonra, her alt süreç kendi sinyal eylemlerini sıfırlamalıdır.
    </para><para>
İlklendirme sırasında, kabuk süreci kendini iş denetim sinyallarini yoksaymaya ayarlamalıdır; bkz. <xref linkend="glibc-Initializing-the-Shell"/>.  Sonuç olarak, bir miras olarak her alt süreç oluşturulduğunda bu sinyalleri yoksayacaktır. Bu kesinlikle istenmeyen bir durumdur, bu bakımdan kabuğun her alt süreci çatallandığında bu sinyaller <command>SIG_DFL</command>'a yani öntanımlı haline getirmelidir.
    </para><para>
Kabuklar bu uzlaşımlara uyduğundan, uygulamalar kendini çalıştıran süreçten bu sinyalleri doğru eylemlerle aldıklarını kabul edebilirler. Fakat her uygulamanın durdurma sinyallerinin işlenmesini bozmama sorumluluğu vardır. SUSP karakterinin normal yorumunu iptal eden uygulamalar, kullanıcıya işi durdurmak için başka mekanizmalar sunmalıdır. Kullanıcı bu mekanizmayı çalıştırdığında yazılım sadece kendi sürecinde değil, kendi süreç grubuna da bir <command>SIGTSTP</command> sinyali göndermelidir. Bkz. <xref linkend="glibc-Signaling-Another-Process"/>.
    </para><para>
Son olarak, her süreç normal yolla <command>exec</command> çağrısı yapmalıdır. Bu ayrıca standart girdi ve çıktı kanallarının yönlendirilmesinde önemlidir. Bunun nasıl yapılacağı <xref linkend="glibc-Duplicating-Descriptors"/> bölümünde açıklanmıştır.
    </para><para>
Örnek kabuk yazılımından, bir uygulamayı çalıştırmakla yükümlü bir işlev aşağıda gösterilmiştir. Kabuk tarafından çatatallandıktan hemen sonra her alt süreç tarafından bu işlev çalıştırılır ve işlev asla dönmez.
    </para><para>
<screen>void
launch_process (process *p, pid_t pgid,
                int infile, int outfile, int errfile,
                int foreground)
{
  pid_t pid;

  if (shell_is_interactive)
    {
      /* Süreci süreç grubuna koy ve uygunsa uçbirimi
         süreç grubuna ver. Olası yarış koşullarının oluşmasını
         engellemek için hem kabuk hem de her alt süreç
         tarafından bu yapılmalıdır.  */
      pid = getpid ();
      if (pgid == 0) pgid = pid;
      setpgid (pid, pgid);
      if (foreground)
        tcsetpgrp (shell_terminal, pgid);

      /* İş denetim sinyallerini öntanımlı eylemlerine ayarlayalım..  */
      signal (SIGINT, SIG_DFL);
      signal (SIGQUIT, SIG_DFL);
      signal (SIGTSTP, SIG_DFL);
      signal (SIGTTIN, SIG_DFL);
      signal (SIGTTOU, SIG_DFL);
      signal (SIGCHLD, SIG_DFL);
    }

  /* Standart girdi/çıktı kanallarını yeni sürece ayarlayalım.  */
  if (infile != STDIN_FILENO)
    {
      dup2 (infile, STDIN_FILENO);
      close (infile);
    }
  if (outfile != STDOUT_FILENO)
    {
      dup2 (outfile, STDOUT_FILENO);
      close (outfile);
    }
  if (errfile != STDERR_FILENO)
    {
      dup2 (errfile, STDERR_FILENO);
      close (errfile);
    }

  /* Yeni süreci çalıştıralım ve çıkalım.  */
  execvp (p->argv[0], p->argv);
  perror ("execvp");
  exit (1);
}
</screen></para><para>
Kabuk etkileşimli olarak çalışmıyorsa, bu işlev süreç grubu ve sinyallerle ilgili olarak hiçbir şey yapmaz. İş denetimi yapmayan bir kabuğun kendi alt süreçlerini kendi süreç grubunda tuttuğunu hatırlayın.
    </para><para>
Aşağıda, bir işi tam anlamıyla çalıştıran bir işleve yer verilmiştir. Alt süreç oluşturulduktan sonra, bu işlev yeni oluşturulan işi önalana ya da artalana koyacak bazı işlevleri çağırır; bunlar <xref linkend="glibc-Foreground-and-Background"/> bölümünde açıklanmıştır.
    </para><para>
<screen>void
launch_job (job *j, int foreground)
{
  process *p;
  pid_t pid;
  int mypipe[2], infile, outfile;

  infile = j->stdin;
  for (p = j->first_process; p; p = p->next)
    {
      /* Set up pipes, if necessary.  */
      if (p->next)
        {
          if (pipe (mypipe) &lt; 0)
            {
              perror ("pipe");
              exit (1);
            }
          outfile = mypipe[1];
        }
      else
        outfile = j->stdout;

      /* Alt süreci çatallayalım.  */
      pid = fork ();
      if (pid == 0)
        /* This is the child process.  */
        launch_process (p, j->pgid, infile,
                        outfile, j->stderr, foreground);
      else if (pid &lt; 0)
        {
          /* Çatallama başarısız.  */
          perror ("fork");
          exit (1);
        }
      else
        {
          /* Bu, ata süreç.  */
          p->pid = pid;
          if (shell_is_interactive)
            {
              if (!j->pgid)
                j->pgid = pid;
              setpgid (pid, j->pgid);
            }
        }

      /* Boruları temizleyelim.  */
      if (infile != j->stdin)
        close (infile);
      if (outfile != j->stdout)
        close (outfile);
      infile = mypipe[0];
    }

  format_job_info (j, "işe başladı");

  if (!shell_is_interactive)
    wait_for_job (j);
  else if (foreground)
    put_job_in_foreground (j, 0);
  else
    put_job_in_background (j, 0);
}
</screen></para></sect1>
    <sect1 id="glibc-Foreground-and-Background">
      <title>Önalan ve Artalan</title>
      <titleabbrev>Bir işin artalandan önalana konulması.</titleabbrev>
      <para>
Kabuk tarafından bir iş önalanda başlatılırken kabuk tarafından hangi eylemlerin ele alınması gerektiğine ve bunun bir artalan işi başlatmaktan ne gibi farkları olduğuna bakalım.
    </para><para>
<indexterm scope="glibc-cp"><primary>önalan işi</primary><secondary>başlatılması</secondary></indexterm>
Bir önalan işi başlatılırken, ilk olarak kabuk bir <command>tcsetpgrp</command> çağrısı yaparak ona denetim uçbiriminde erişim vermelidir. Bundan sonra, kabuk bu süreç grubundaki sürecin sonlanmasını ya da durmasını beklemelidir. Bu ayrıntılı olarak <xref linkend="glibc-Stopped-and-Terminated-Jobs"/> bölümünde anlatılmıştır.
    </para><para>
Gruptaki tüm süreçler tamamlandığında ya da durduğunda, kabuk tekrar bir <command>tcsetpgrp</command> çağrısı yaparak kendi süreç grubu için uçbirim denetimini geri kazanmalıdır. Süreç grubuna, bir artalan işindeki G/Ç işleminden ya da kullanıcı tarafından tuşlanan bir SUSP karakterinden dolayı oluşan durdurma sinyalleri gönderildiğinde normal olarak işteki tüm süreçler durdurulur.
    </para><para>
Önalan işi tuhaf bir durumda uçbirimde kalabilir, bu durumda kabuk devam etmeden önce kendi uçbirim kiplerini eski haline getirmelidir. İşin sadece durmuş olması durumunda, iş daha sonra devam edebileceğinden, kabuk önce o anki uçbirim kiplerini kaydetmelidir. Uçbirim kipleri ile ilgili işlemler için kullanılan <command>tcgetattr</command> ve <command>tcsetattr</command> işlevleri <xref linkend="glibc-Terminal-Modes"/> bölümünde anlatılmıştır.
    </para><para>
Bunların hepsini yapan örnek kabuk işlevi:
    </para><para>
<screen>/* j işini önalana koyalım. cont sıfırdan farklıysa,
   kayıtlı uçbirim kiplerini yerine koyalım ve
   biz engellemeden önce sürecin devam edebilmesi için
   süreç grubuna bir SIGCONT sinyali gönderelim.  */

void
put_job_in_foreground (job *j, int cont)
{
  /* İşi önalana koyalım.  */
  tcsetpgrp (shell_terminal, j->pgid);

  /* Gerekliyse, işe bir devamet sinyali gönderelim.  */
  if (cont)
    {
      tcsetattr (shell_terminal, TCSADRAIN, &amp;j->tmodes);
      if (kill (- j->pgid, SIGCONT) &lt; 0)
        perror ("kill (SIGCONT)");
    }

  /* Rapor vermesini bekleyelim.  */
  wait_for_job (j);

  /* Kabuğu tekrar önalana koyalım.  */
  tcsetpgrp (shell_terminal, shell_pgid);

  /* Kabuğa uçbirim kiplerini geri verelim.  */
  tcgetattr (shell_terminal, &amp;j->tmodes);
  tcsetattr (shell_terminal, TCSADRAIN, &amp;shell_tmodes);
}
</screen></para><para>
<indexterm scope="glibc-cp"><primary>artalan işi</primary><secondary>başlatılması</secondary></indexterm>
Eğer süreç grubu bir artalan işi olarak başlatılıyorsa, kabuğun kendisi önalanda kalmalı ve uçbirimden komutları okumaya devam etmelidir.
    </para><para>
Örnek kabukta, bir işi artalana koymak için çok fazla bir şey yapmak gerekmemiştir. Bu işlem için kullanılan işlev:
    </para><para>
<screen>/* Bir işi artalana koyacağız. cont doğru ise,
   süreç grubuna devam etmesi için bir
   <command>SIGCONT</command> sinyali gönderelim.  */

void
put_job_in_background (job *j, int cont)
{
  /* Gerekliyse artalan işine bir devamet sinyali gönderelim.  */
  if (cont)
    if (kill (-j->pgid, SIGCONT) &lt; 0)
      perror (&quot;kill (SIGCONT)&quot;);
}
</screen></para></sect1>
    <sect1 id="glibc-Stopped-and-Terminated-Jobs">
      <title>İşlerin Durdurulması ve Sonlandırılması</title>
      <titleabbrev>İş durumunun raporlanması.</titleabbrev>
      <para>
<indexterm scope="glibc-cp"><primary>iş denetimi</primary><secondary>durmuş iş</secondary><tertiary>saptanması</tertiary></indexterm>
<indexterm scope="glibc-cp"><primary>iş denetimi</primary><secondary>sonlandırılmış iş</secondary><tertiary>saptanması</tertiary></indexterm>
<indexterm scope="glibc-cp"><primary>sonlandırılmış iş</primary><secondary>saptanması</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>durmuş iş</primary><secondary>saptanması</secondary></indexterm>
Bir önalan işi başlatıldığında, kabuk, işteki tüm süreçler durana ya da sonlanana kadar beklemelidir. Bunu <command>waitpid</command> çağrısı ile yapabilir; bkz. <xref linkend="glibc-Process-Completion"/>.  Süreçlerin durması ya da sonlanması halinde durumu raporlamaları için <command>WUNTRACED</command> seçeneği kullanılır.
    </para><para>
Kabuk bir artalan işinin kullanıcı tarafından durdurulması ya da sonlandırılmasının da raporlanmasını ayrıca beklemelidir; bu <command>waitpid</command> işlevinin <command>WNOHANG</command> seçeneği ile çağrılması ile yapılabilir. Bu sınamanın yapılacağı en iyi yer yeni bir komut isteminin hemen öncesidir.
    </para><para>
<indexterm scope="glibc-cp"><primary><command>SIGCHLD</command> sinyali</primary><secondary>işlenmesi</secondary></indexterm>
Kabuk ayrıca, <command>SIGCHLD</command> sinyallerine bir <link linkend="glibc-Signal-Handling">sinyal eylemci</link> kurmuş bir alt süreç için durum bilgisi içeren bir eşzamansız uyarı alabilir.
    </para><para>
Örnek kabuk yazılımında, <command>SIGCHLD</command> sinyalleri normal olarak yoksayılmaktadır. Bu, kabuğun zaman zaman değiştirdiği genel veri yapılarından kaynaklanan evresellik (reentrancy) sorunlarında kaçınmak içindir. Fakat belirli zamanlarda, kabuğun bu veri yapılarını kullanmadığı zamanlarda ( örneğin, uçbirimden girdi beklerken), <command>SIGCHLD</command> sinyali için bir eylemciyi etkinleştirmeye ihtiyaç duyar. Eşzamanlı durum sınamaları yapmak için kullanılan işlev (bu durumda <command>do_job_notification</command> işlevi), bu eylemci tarafından ayrıca çağrılabilir.
    </para><para>
Burada, örnek kabuk yazılımından işlerin durumunu sınayıp durumu kullanıcıya bildiren parçası görülmektedir:
    </para><para>
<screen>/* waitpid tarafından döndürülen  süreç kimliğinin durumunu
   saklayalım. İstenen yapıldıysa 0 yoksa sıfırdan farklı
   bir değerle dönelim..  */

int
mark_process_status (pid_t pid, int status)
{
  job *j;
  process *p;

  if (pid > 0)
    {
      /* Süreç için kaydı güncelleyelim.  */
      for (j = first_job; j; j = j->next)
        for (p = j->first_process; p; p = p->next)
          if (p->pid == pid)
            {
              p->status = status;
              if (WIFSTOPPED (status))
                p->stopped = 1;
              else
                {
                  p->completed = 1;
                  if (WIFSIGNALED (status))
                    fprintf (stderr, "%d: %d sinyali ile sonlandırıldı.\n",
                              (int) pid, WTERMSIG (p->status));
                }
              return 0;
              }
      fprintf (stderr, "%d kimlikli bir süreç yok.\n", pid);
      return -1;
    }
  else if (pid == 0 || errno == ECHILD)
    /* Rapor verecek süreç yok.  */
    return -1;
  else {
    /* Diğer tuhaf hatalar.  */
    perror ("waitpid");
    return -1;
  }
}

/* Süreçleri beklemeden durum bilgilerinin varlığını sınayalım.  */

void
update_status (void)
{
  int status;
  pid_t pid;

  do
    pid = waitpid (WAIT_ANY, &amp;status, WUNTRACED|WNOHANG);
  while (!mark_process_status (pid, status));
}

/* Belirtilen işteki tüm süreçleri beklerken
   durum bilgilerinin varlığını sınayalım.  */

void
wait_for_job (job *j)
{
  int status;
  pid_t pid;

  do
    pid = waitpid (WAIT_ANY, &amp;status, WUNTRACED);
  while (!mark_process_status (pid, status)
          &amp;&amp; !job_is_stopped (j)
          &amp;&amp; !job_is_completed (j));
}

/* İş durumu ile ilgili bilgileri kullanıcıya sunmak için biçimleyelim.  */

void
format_job_info (job *j, const char *status)
{
  fprintf (stderr, "%ld (%s): %s\n", (long)j->pgid, status, j->command);
}

/* Durmuş ya da sonlandılılmış işler hakkında kullanıcıyı uyaralım.
   Sonlanmış işleri etkin iş listesinden kaldıralım.  */

void
do_job_notification (void)
{
  job *j, *jlast, *jnext;
  process *p;

  /* Alt sürecin durum bilgisini güncelleyelim.  */
  update_status ();

  jlast = NULL;
  for (j = first_job; j; j = jnext)
    {
      jnext = j->next;

      /* Tüm süreçler tamamlanmışsa, kullanıcıya işin tamamlandığını
         bildirelim ve onu etkin işler listesinden silelim.  */
      if (job_is_completed (j)) {
        format_job_info (j, "iş tamamdır");
        if (jlast)
          jlast->next = jnext;
        else
          first_job = jnext;
        free_job (j);
      }

      /* Duran işleri kullanıcıya bildirelim ve
         bunu bir daha yapmamak için onları imleyelim.  */
      else if (job_is_stopped (j) &amp;&amp; !j->notified) {
        format_job_info (j, "iş durdu");
        j->notified = 1;
        jlast = j;
      }

      /* Hala sürmekte olan işler için bir şey söylemek gerekmez.  */
      else
        jlast = j;
    }
}
</screen></para></sect1>
    <sect1 id="glibc-Continuing-Stopped-Jobs">
      <title>Duran İşlerin Sürdürülmesi</title>
      <titleabbrev>Artalanda ya da önalanda durmuş bir iş tekrar nasıl devam ettirilir.</titleabbrev>
      <para>
<indexterm scope="glibc-cp"><primary>iş denetimi</primary><secondary>durmuş iş</secondary><tertiary>sürdürülmesi</tertiary></indexterm>
<indexterm scope="glibc-cp"><primary>durmuş iş</primary><secondary>sürdürülmesi</secondary></indexterm>
Kabuk durmuş bir işi onun süreç grubuna bir <command>SIGCONT</command> sinyali göndererek çalışmaya devam etmesini sağlayabilir. İşin önalanda sürdürülmesi durumunda, kabuk önce uçbirimde erişim vermek için bir <command>tcsetpgrp</command> çağrısı yapmalıdır. İş önalanda kaldığı yerden çalışmaya başladıktan sonra sanki iş önalanda ilk defa başlatılmış gibi kabuk işin tamamlanması ya da durmasını beklemek zorundadır.
    </para><para>
Örnek kabuk yazılımında hem yeni oluşturulan hem de devam ettrilen işler aynı işlev çiftiyle, <command>put_job_in_foreground</command> ve <command>put_job_in_background</command> işleviyle izlenirler. Bu işlevlerin tanımları <xref linkend="glibc-Foreground-and-Background"/> bölümündeki örnek kod parçasında bulunabilir. Durmuş bir işin devam ettrilmesi durumunda <varname>cont</varname> argümanına sıfırdan farklı bir değer atanarak <command>SIGCONT</command> sinyalinin gönderilmesi ve uçbirim kiplerinin eski değerlerine getirilmesi sağlanır.
    </para><para>
Burada durmuş işin tekrar çalışmaya devam etmesini sağlayan kod parçası gösterilmiştir:
    </para><para>
<screen>/* Durmuş j işini tekrar çalışmaya başlasın diye imleyelim.  */

void
mark_job_as_running (job *j)
{
  Process *p;

  for (p = j->first_process; p; p = p->next)
    p->stopped = 0;
  j->notified = 0;
}

/* j işi devam etsin.  */

void
continue_job (job *j, int foreground)
{
  mark_job_as_running (j);
  if (foreground)
    put_job_in_foreground (j, 1);
  else
    put_job_in_background (j, 1);
}
</screen></para></sect1>
    <sect1 id="glibc-Missing-Pieces">
      <title>Eksik Parçalar</title>
      <titleabbrev>Örnek kabuğun diğer parçaları.</titleabbrev>
      <para>
Bu oylumda çeşitli örnekler halinde verilen kabuk yazılımı, yazılımın tamamı değildir. Yazılımın çok küçük bir kısmının örneklenmesi dışında <command>job</command> ve <command>program</command> veri yapılarının nasıl ayrıldığı ve ilklendirildiği de dahil olmak üzere, hemen hiçbir şey söylenmedi.
    </para><para>
Gerçek kabukların çoğu, bir komut dili, değişkenler, kısaltmalar, ikameler, dosya isimleri üzerinde kalıp eşleme gibi pek çok desteği içeren oldukça karmaşık bir kullanıcı arayüzü içerir. Tüm bunların verilmesi için doğaldır ki, burası yeri değildir. Bunun yerine süreç oluşturulması ile ilgili gerçekleme ve iş denetimi  işlevlerinin böyle bir kabuk içinden çağrılmasını gösteren bir özet verdik.
    </para><para>
Şimdiye kadar sunduğumuz ana konuları şöyle özetleyebiliriz:
    </para><para><glosslist><glossentry><glossterm>
    <literal>void <command>init_shell</command> (void)</literal>
    </glossterm><glossdef><para>
Kabuğun dahili durumunun ilklendirir. Bkz.<xref linkend="glibc-Initializing-the-Shell"/>.
    </para></glossdef></glossentry><glossentry><glossterm>
    <literal>void <command>launch_job</command> (job *<varname>j</varname>, int <varname>foreground</varname>)</literal>
    </glossterm><glossdef><para>
<varname>j</varname> işinin hem önalanda hem de artalanda başlatılması için. Bkz. <xref linkend="glibc-Launching-Jobs"/>.
    </para></glossdef></glossentry><glossentry><glossterm>
    <literal>void <command>do_job_notification</command> (void)</literal>
    </glossterm><glossdef><para>
Sonlanmış ya da durmuş bir işin varlığını sınar ve raporlar. Eşzamanlı çağrılabileceği gibi <command>SIGCHLD</command> sinyallerinin eylemcisinden de çağrılabilir. Bkz. <xref linkend="glibc-Stopped-and-Terminated-Jobs"/>.
    </para></glossdef></glossentry><glossentry><glossterm>
    <literal>void <command>continue_job</command> (job *<varname>j</varname>, int <varname>foreground</varname>)</literal>
    </glossterm><glossdef><para>
<varname>j</varname> işinin sürdürülmesini sağlar. Bkz. <xref linkend="glibc-Continuing-Stopped-Jobs"/>.
    </para></glossdef></glossentry></glosslist></para><para>
Süphesiz, gerçek bir kabuk işlerin yönetilmesi için daha fazlasını gerektirir. Örneğin, tüm etkin işleri listeleyen ya da bir işe bir sinyal gönderen (<command>SIGKILL</command> gibi) komutlar içermesi faydalı olurdu.
    </para></sect1></chapter>
  <chapter id="glibc-Functions-for-Job-Control">
    <title>İş Denetimi İşlevleri</title>
    <titleabbrev>Süreç gruplarını denetleyen işlevler.</titleabbrev>
    <para>
<indexterm scope="glibc-cp"><primary>süreç grubu</primary><secondary>işlevleri</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>iş denetimi</primary><secondary>işlevleri</secondary></indexterm>
Bu kısımda iş denetimi ile ilgili işlevlerin ayrıntılı açıklamalarına yer verilmiştir.
   </para>
    <sect1 id="glibc-Identifying-the-Terminal">
      <title>Denetim Uçbiriminin İsimlendirilmesi</title>
      <titleabbrev>Denetim uçbiriminin isminin saptanması.</titleabbrev>
      <para>
<indexterm scope="glibc-cp"><primary>denetim uçbirimi</primary><secondary>saptanması</secondary></indexterm>
Denetim uçbirimini açmakta kullanılabilecek dosya ismini almak için <command>ctermid</command> işlevini kullanabilirsiniz. GNU kütüphanesinde her zaman aynı dizgeyi döndürür: <filename>&quot;/dev/tty&quot;</filename>.  Bu o an çalışmakta olan sürecin denetim uçbirimini ifade eden "sihirli" bir özel isimdir. Belli bir uçbirim aygıtının ismini bulmak için ise  <command>ttyname</command> işlevini kullanabilirsiniz; bkz. <xref linkend="glibc-Is-It-a-Terminal"/>.
    </para><para>
<command>ctermid</command> işlevi <filename>stdio.h</filename> başlık dosyasında bildirilmiştir.
<indexterm scope="glibc-pg"><primary>stdio.h</primary></indexterm>
    </para><para>
<indexterm scope="glibc-fn"><primary>ctermid</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-ctermid">
<funcdef>char *<command>ctermid</command></funcdef>
<paramdef>(char *<varname>dizge</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>ctermid</command> işlevi, sürecin denetim uçbiriminin dosya ismini içeren bir dizge ile döner. <varname>dizge</varname> bir boş gösterici değilse, en azından <command>L_ctermid</command> karakteri tutabilecek bir dizi olmalıdır; istenen dizge bu dizi içinde dönecektir. Aksi takdirde, işlevin sonraki çağrıları ile üzerine yazılabilen, durağan alanda ayrılmış dizgeye bir gösterici ile döner.
    </para><para>
Herhangi bir sebeple dosya ismi saptanamazsa bir boş dizge döner. Bir dosya ismi dönmüş olsa bile, bu dosyaya erişim garanti edilmez.
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-vr"><primary>L_ctermid</primary></indexterm>
<funcsynopsis><funcprototype role="makro" id="glibc-L_ctermid">
<funcdef>int <command>L_ctermid</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu makronun değeri, <command>ctermid</command> işlevi ile döndürülen dosya isminin tutulacağı genişlikte bir dizgenin uzunluğunu ifade eder.
</para></funcdescr></funcsynopsis></para><para>
Ayrıca <xref linkend="glibc-Is-It-a-Terminal"/> bölümündeki <command>isatty</command> ve <command>ttyname</command> işlevlerine de bakınız.
    </para></sect1>
    <sect1 id="glibc-Process-Group-Functions">
      <title>Süreç Grubu İşlevleri</title>
      <titleabbrev>Süreç gruplarıyla etkileşen işlevler.</titleabbrev>
      <para>
Bu bölümde süreç grupları ile etkileşen işlevlerin açıklamaları bulunmaktadır. Bu işlevleri kullanabilmek için yazılımınıza <filename>sys/types.h</filename> ve <filename>unistd.h</filename> başlık dosyalarını dahil etmelisiniz.
<indexterm scope="glibc-pg"><primary>unistd.h</primary></indexterm>
<indexterm scope="glibc-pg"><primary>sys/types.h</primary></indexterm>
    </para><para>
<indexterm scope="glibc-fn"><primary>setsid</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-setsid">
<funcdef>pid_t <command>setsid</command></funcdef>
<paramdef>(void)</paramdef>
</funcprototype><funcdescr><para>
<command>setsid</command> işlevi yeni bir oturum oluşturur. Bu işlevi çağıran süreç oturum lideri haline gelir ve süreç, süreç grubunun kimliği kendi süreç kimliği olan süreç grubuna konur. Başlangıçta yeni süreç grubunda başka süreç ve süreç grubu yoktur.
    </para><para>
Bu işlev ayrıca çağrıldığı süreci denetim uçbirimsiz süreç durumuna getirir.
    </para><para>
Normalde, <command>setsid</command> işlevi kendini çağıran sürecin yeni süreç grubu kimliği ile döner. Dönüş değeri <command>-1</command> ise bu bir hata oluştuğunu gösterir. Aşağıdaki <command>errno</command> hata durumu bu işlev için tanımlanmıştır:
    </para><para><variablelist><varlistentry>
    <term><literal>EPERM</literal></term><listitem><para>
Çağıran süreç zaten bir süreç grubunun lideri ya da aynı süreç grup kimliğine sahip başka bir süreç grubu var
       </para></listitem></varlistentry></variablelist>
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>getsid</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-getsid">
<funcdef>pid_t <command>getsid</command></funcdef>
<paramdef>(pid_t <varname>pid</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>getsid</command> işlevi belirtilen sürecin oturum liderinin süreç grup kimliğini döndürür. <varname>pid</varname>'in değeri <command>0</command> ise, işlevi çağıran sürecin oturum liderinin süreç grup kimliği döner.
    </para><para>
Bir hata oluşmuşsa işlev <command>-1</command> ile döner ve <command>errno</command> değişkenine şu hata durumlarından biri atanır:
    </para><para><variablelist><varlistentry>
    <term><literal>ESRCH</literal></term><listitem><para>
<varname>pid</varname> kimlikli bir süreç yok
       </para></listitem></varlistentry><varlistentry>
       <term><literal>EPERM</literal></term><listitem><para>
Çağıran süreç ve <varname>pid</varname> ile belirtilen süreç farklı oturumlara ait ve gerçekleme <varname>pid</varname> ile belirtilen sürecin oturum liderinin süreç grup kimliğine erişime izin vermiyor
       </para></listitem></varlistentry></variablelist>
</para></funcdescr></funcsynopsis></para><para>
<command>getpgrp</command> işlevinin iki tanımı vardır: biri BSD Unix'den diğeri POSIX.1 standardından türetilmiştir. <link linkend="glibc-Feature-Test-Macros">Özellik sınama makrolarıyla</link> hangi tanımı kullanmak istediğinizi belirleyebilirsiniz. Özellikle, BSD sürümünü kullanmak istiyorsanız <command>_BSD_SOURCE</command>; POSIX sürümünü kullanmak istiyorsanız <command>_POSIX_SOURCE</command> veya <command>_GNU_SOURCE</command> makrosunu belirtmelisiniz.  Özellikle <command>_BSD_SOURCE</command> altında tanımlı <command>getpgrp</command> işlevini kullanan Eski BSD sistemleri için yazılmış yazılımlar <filename>unistd.h</filename> başlık dosyasını içermeyecektir.  Böyle yazılımların BSD tanımlarını elde etmek için <command>-lbsd-compat</command> ile ilintilemelisiniz.
<indexterm scope="glibc-pg"><primary sortas="lbsd-compat">-lbsd-compat</primary></indexterm>
<indexterm scope="glibc-pg"><primary>bsd-compat</primary></indexterm>
<indexterm scope="glibc-cp"><primary>BSD uyumluluk kütüphanesi</primary></indexterm>
       </para><para>
<indexterm scope="glibc-fn"><primary>getpgrp</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-getpgrp">
<funcdef>pid_t <command>getpgrp</command></funcdef>
<paramdef>(void)</paramdef>
</funcprototype><funcdescr><para>
Çağrıldığı sürecin süreç grup kimliğini döndüren <command>getpgrp</command> işlevinin POSIX.1 tanımı.
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>getpgrp</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-bsd-getpgrp">
<funcdef>pid_t <command>getpgrp</command></funcdef>
<paramdef>(pid_t <varname>pid</varname>)</paramdef>
</funcprototype><funcdescr><para>
<varname>pid</varname> kimlikli sürecin süreç grup kimliğini döndüren <command>getpgrp</command> işlevinin BSD tanımı. <varname>pid</varname> değeri olarak <command>0</command> verirseniz çağrıldığı sürecin süreç grup kimliğini döndürür.
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>getpgid</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-getpgid">
<funcdef>int <command>getpgid</command></funcdef>
<paramdef>(pid_t <varname>pid</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>getpgid</command> işlevi bir BSD işlevi olarak <command>getpgrp</command> işlevi ile aynıdır.  <varname>pid</varname> kimlikli sürecin süreç grup kimliğini döndürür. <varname>pid</varname> değeri olarak <command>0</command> verirseniz çağrıldığı sürecin süreç grup kimliğini döndürür.
    </para><para>
Bir hata oluşmuşsa işlev <command>-1</command> ile döner ve <command>errno</command> değişkenine şu hata durumlarından biri atanır:
    </para><para><variablelist><varlistentry>
    <term><literal>ESRCH</literal></term><listitem><para>
Çağıran süreç ve <varname>pid</varname> ile belirtilen süreç farklı oturumlara ait ve gerçekleme <varname>pid</varname> ile belirtilen sürecin oturum liderinin süreç grup kimliğine erişime izin vermiyor
       </para></listitem></varlistentry></variablelist>
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>setpgid</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-setpgid">
<funcdef>int <command>setpgid</command></funcdef>
<paramdef>(pid_t <varname>pid</varname>,
 pid_t <varname>pgid</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>setpgid</command> işlevi <varname>pid</varname> sürecini <varname>pgid</varname> süreç grubuna koyar. Özel bir durum olarak, çağıran süreci belirtmek üzere <varname>pid</varname> ya da <varname>pgid</varname> sıfır olabilir.
    </para><para>
İş denetimini desteklemeyen bir sistemde işlev başarısız olur. Daha fazla bilgi için <xref linkend="glibc-Job-Control-is-Optional"/> bölümüne bakınız.
    </para><para>
İşlem başarılıysa işlev sıfırla döner. Aksi takdirde <command>-1</command> döner ve <command>errno</command> değişkenine şu hata durumlarından biri atanır:
    </para><para><variablelist><varlistentry>
    <term><literal>EACCES</literal></term><listitem><para>
<varname>pid</varname> kimlikli alt süreç çatallandığında bir <command>exec</command> çağrısı yaptı
       </para></listitem></varlistentry><varlistentry>
       <term><literal>EINVAL</literal></term><listitem><para>
<varname>pgid</varname> değeri geçersiz
       </para></listitem></varlistentry><varlistentry>
       <term><literal>ENOSYS</literal></term><listitem><para>
Sistem iş denetimini desteklemiyor
       </para></listitem></varlistentry><varlistentry>
       <term><literal>EPERM</literal></term><listitem><para>
<varname>pid</varname> ile belirtilen süreç ya bir oturum lideri ya da işlevin çağrıldığı süreçle aynı oturumda değil veya <varname>pgid</varname> argümanı işlevin çağrıldığı süreç ile aynı oturumdaki bir süreç grup kimliğiyle eşleşmiyor
       </para></listitem></varlistentry><varlistentry>
       <term><literal>ESRCH</literal></term><listitem><para>
<varname>pid</varname> kimlikli süreç işlevi çağıran süreç değil ya da işlevi çağıran sürecin bir alt süreci değil.
       </para></listitem></varlistentry></variablelist>
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>setpgrp</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-setpgrp">
<funcdef>int <command>setpgrp</command></funcdef>
<paramdef>(pid_t <varname>pid</varname>,
 pid_t <varname>pgid</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev, <command>setpgid</command> işlevinin BSD Unix sürümüdür.  Her iki işlev de tamamen aynı işlemi yapar.
    </para></funcdescr></funcsynopsis></para></sect1>
    <sect1 id="glibc-Terminal-Access-Functions">
      <title>Denetim Uçbirimine Erişim İşlevleri</title>
      <para>
Bunlar bir uçbirimin önalan süreç grubunu belirlemek ya da okumak için kullanılan işlevlerdir. Bu işlevleri yazılımınızda kullanacaksanız <filename>sys/types.h</filename> ve <filename>unistd.h</filename> başlık dosyalarını yazılımınıza dahil etmelisiniz.
<indexterm scope="glibc-pg"><primary>unistd.h</primary></indexterm>
<indexterm scope="glibc-pg"><primary>sys/types.h</primary></indexterm>
    </para><para>
Bu işlevler uçbirim aygıtını belirten bir dosya tanıtıcı almasına rağmen önalan işi, açık bir dosya tanıtıcı ile değil, uçbirim dosyasının kendisi ile ilgilidir.
    </para><para>
<indexterm scope="glibc-fn"><primary>tcgetpgrp</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-tcgetpgrp">
<funcdef>pid_t <command>tcgetpgrp</command></funcdef>
<paramdef>(int <varname>dosyatanıtıcı</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev, <varname>dosyatanıtıcı</varname> ile açılmış uçbirim ile ilişkili önalan süreç grubunun süreç grup kimliğini döndürür.
    </para><para>
Bir önalan süreç grubu yoksa, dönüş değeri, mevcut bir süreç grubunun süreç grup kimliği ile eşleşmeyen ve değeri <command>1</command>'den büyük bir sayıdır. Eğer, evvelce önalan işi olan ve tüm süreçleri sonlanmış bir iş varsa ve henüz önalana taşınmış bir iş yoksa bu durum ortaya çıkar.
    </para><para>
Bir hata durumunda işlev <command>-1</command> değeri ile döner. Aşağıdaki  <command>errno</command> hata durumları bu işlev için tanımlanmıştır:
    </para><para><variablelist><varlistentry>
    <term><literal>EBADF</literal></term><listitem><para>
<varname>dosyatanıtıcı</varname> argümanı geçerli bir dosya tanıtıcı değil
       </para></listitem></varlistentry><varlistentry>
       <term><literal>ENOSYS</literal></term><listitem><para>
Sistem iş denetimini desteklemiyor
       </para></listitem></varlistentry><varlistentry>
       <term><literal>ENOTTY</literal></term><listitem><para>
<varname>dosyatanıtıcı</varname> argümanı ile ilişkili uçbirim dosyası işlevin çağrıldığı sürecin denetim uçbirimi değil
       </para></listitem></varlistentry></variablelist>
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>tcsetpgrp</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-tcsetpgrp">
<funcdef>int <command>tcsetpgrp</command></funcdef>
<paramdef>(int   <varname>dosyatanıtıcı</varname>,
 pid_t <varname>pgid</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev bir uçbirimin önalan süreç grup kimliğini belirlemede kullanılır. <varname>dosyatanıtıcı</varname> argümanı uçbirimi belirten bir dosya tanıtıcıdır; <varname>pgid</varname> ise süreç grubunu belirtir.  İşlevi çağıran süreç ile <varname>pgid</varname> aynı oturumun üyesi olmalı ve aynı denetim uçbirimini kullanıyor olmalıdır.
    </para><para>
Uçbirime erişim amaçlarına uygun olarak, bu işlev çıktı olarak kabul edilir. İşlev, denetim uçbiriminin bir artalan sürecinden çağrılmışsa, normalde süreç grubundaki tüm süreçlere bir <command>SIGTTOU</command> sinyali gönderilir. İşlevi çağıran sürecin <command>SIGTTOU</command> sinyalini engellemesi ya da yoksayması durumunda, işlem yine uygulanır ama sinyal gönderilmez.
    </para><para>
İşlev başarılı olursa dönüş değeri <command>0</command>'dır. Dönüş değeri <command>-1</command> ise bu bir hata oluştuğunu gösterir. Aşağıdaki  <command>errno</command> hata durumları bu işlev için tanımlanmıştır:
    </para><para><variablelist><varlistentry>
    <term><literal>EBADF</literal></term><listitem><para>
<varname>dosyatanıtıcı</varname> argümanı geçerli bir dosya tanıtıcı değil
       </para></listitem></varlistentry><varlistentry>
       <term><literal>EINVAL</literal></term><listitem><para>
<varname>pgid</varname> argümanı geçersiz
       </para></listitem></varlistentry><varlistentry>
       <term><literal>ENOSYS</literal></term><listitem><para>
Sistem iş denetimini desteklemiyor
       </para></listitem></varlistentry><varlistentry>
       <term><literal>ENOTTY</literal></term><listitem><para>
<varname>dosyatanıtıcı</varname> argümanı ile ilişkili uçbirim dosyası işlevin çağrıldığı sürecin denetim uçbirimi değil
       </para></listitem></varlistentry><varlistentry>
       <term><literal>EPERM</literal></term><listitem><para>
<varname>pgid</varname> işlevi çağıran süreçle aynı oturumda değil
       </para></listitem></varlistentry></variablelist>
     </para><para>
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>tcgetsid</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-tcgetsid">
<funcdef>pid_t <command>tcgetsid</command></funcdef>
<paramdef>(int <varname>dosyatanıtıcı</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev, denetim uçbirimi <varname>dosyatanıtıcı</varname> ile belirtilen oturumun süreç grup kimliği ile döner. İşlev başarısız olursa dönüş değeri<command>(pid_t) -1</command> olur ve <varname>errno</varname> değişkenine şu değerlerden biri atanır:
    </para><para><variablelist><varlistentry>
    <term><literal>EBADF</literal></term><listitem><para>
<varname>dosyatanıtıcı</varname> argümanı geçerli bir dosya tanıtıcı değil
       </para></listitem></varlistentry><varlistentry>
       <term><literal>ENOTTY</literal></term><listitem><para>
İşlevi çağıran sürecin bir denetim uçbirimi yok ya da dosya bir denetim uçbirimine ait değil
       </para></listitem></varlistentry></variablelist>
     </para></funcdescr></funcsynopsis></para>
   </sect1>
 </chapter>
</part>

