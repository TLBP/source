<?xml version="1.0" encoding="UTF-8"?>
<!-- ********************************************************************
        glibc/ch29.xml,v2.36, GFDL,LGPL, NBB, 2023
     ******************************************************************** -->
<part xml:id="glibc-System-Databases-and-Name-Service-Switch">
 <title>Sistem Veritabanları ve İsim Hizmetleri Seçicisi</title>
 <titleabbrev>Sistem veritabanlarına erişim.</titleabbrev>
 <preliminary>
  <para>
   <indexterm linkend="glibc-cp"><primary>isim hizmetleri</primary></indexterm>
   <indexterm linkend="glibc-cp"><primary>NSS</primary></indexterm>
   <indexterm linkend="glibc-cp"><primary>sistem veritabanları</primary></indexterm>
   C kütüphanesindeki çeşitli işlevlerin yerel ortamda düzgün çalışması için yapılandırılmaları gerekir. Geleneksel olarak, bu işlem dosyalar kullanılarak yapılır (örn, <filename>/etc/passwd</filename>), ama diğer isim hizmetleri de (örn, Ağ Bilgi Hizmetleri - NIS, Alan Adı Hizmetleri - DNS) çok kullanılır olmuş ve C kütüphanesi içine zaman içinde dahil edilmiştir.
  </para>
  <para>
   &glibc; bu soruna daha temiz bir çözüm içerir. Bu çözüm, Sun Microsystems tarafından Solaris 2'nin C kütüphanesinde kullanılan bir yöntemden sonra tasarlanmıştır. &glibc; bunların isimlerini ve çağrılarını <wordasword>İsim Hizmetleri Seçicisi</wordasword> - <firstterm>Name Service Switch</firstterm> (NSS) şeması ile izler.
  </para>
  <para>
   Arayüzün Sun'ın sürümüne benzer olması beklenirdi ama bir ortak kod bile yoktur. &glibc;ne Sun'ın gerçeklemesinden herhangi bir kaynak kod asla alınmamıştır, bu yüzden dahili arayüz uyumsuzdur. Daha sonra görüleceği gibi dosya isimlerinde de bu açıkça ortaya konulmuştur.
  </para>
 </preliminary>

 <chapter xml:id="glibc-NSS-Basics">
  <title>NSS Temelleri</title>
  <titleabbrev>Nedir bu NSS dedikleri.</titleabbrev>
  <para>
   Anafikir, veritabanlarına erişmeye çalışan farklı hizmetlerin gerçeklemelerini ayrı modüllere koymaktır. Bunun bazı faydaları vardır:
  </para>
  <orderedlist>
   <listitem>
    <para>
     Destekçiler yeni hizmetleri &glibc;ne eklemeksizin NSS gerçeklenimine ekleyebilir.
    </para>
   </listitem>
   <listitem>
    <para>
     Modüller birbirinden bağımsız olarak güncellenebilir.
    </para>
   </listitem>
   <listitem>
    <para>
     C kütüphanesi fazla şişmemiş olur.
    </para>
   </listitem>
  </orderedlist>
  <para>
   Yukarıdaki ilk görevi yerine getirmek için modül arayüzü<footnote><para>ABI: (Application Binary Interface kısaltması) - Bir uygulama ile işletim sistemi ya da hizmetler arasında erişimi sağlayan arayüz.</para></footnote> aşağıda açıklanacaktır. Yeni bir hizmeti doğru gerçeklemek için modüller içinde işlevlerin nasıl çağrıldığını anlamak önemlidir. Yazılımcının doğrudan doğruya kullanabileceği bir yol yoktur. Yazılımcı veritabanlarına sadece belgelenmiş ve standartlaştırılmış işlevleri kullararak erişebilir.
  </para>
  <para>
   NSS şemasında mevcut veritabanları şunlardır:
   <indexterm linkend="glibc-cp"><primary>sistem veritabanları</primary><secondary>aliases</secondary></indexterm>
   <indexterm linkend="glibc-cp"><primary>sistem veritabanları</primary><secondary>ethers</secondary></indexterm>
   <indexterm linkend="glibc-cp"><primary>sistem veritabanları</primary><secondary>group</secondary></indexterm>
   <indexterm linkend="glibc-cp"><primary>sistem veritabanları</primary><secondary>gshadow</secondary></indexterm>
   <indexterm linkend="glibc-cp"><primary>sistem veritabanları</primary><secondary>hosts</secondary></indexterm>
   <indexterm linkend="glibc-cp"><primary>sistem veritabanları</primary><secondary>hosts</secondary></indexterm>
   <indexterm linkend="glibc-cp"><primary>sistem veritabanları</primary><secondary>initgroups</secondary></indexterm>
   <indexterm linkend="glibc-cp"><primary>sistem veritabanları</primary><secondary>netgroup</secondary></indexterm>
   <indexterm linkend="glibc-cp"><primary>sistem veritabanları</primary><secondary>networks</secondary></indexterm>
   <indexterm linkend="glibc-cp"><primary>sistem veritabanları</primary><secondary>passwd</secondary></indexterm>
   <indexterm linkend="glibc-cp"><primary>sistem veritabanları</primary><secondary>protocols</secondary></indexterm>
   <indexterm linkend="glibc-cp"><primary>sistem veritabanları</primary><secondary>publickey</secondary></indexterm>
   <indexterm linkend="glibc-cp"><primary>sistem veritabanları</primary><secondary>rpc</secondary></indexterm>
   <indexterm linkend="glibc-cp"><primary>sistem veritabanları</primary><secondary>services</secondary></indexterm>
   <indexterm linkend="glibc-cp"><primary>sistem veritabanları</primary><secondary>shadow</secondary></indexterm>
  </para>
  <variablelist>
   <varlistentry>
    <term><literal>aliases</literal></term>
    <listitem>
     <para>
      Posta takma adları.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>ethers</literal></term>
    <listitem>
     <para>
      Eternet numaraları.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>group</literal></term>
    <listitem>
     <para>
      Kullanıcı grupları, bkz. <xref linkend="glibc-Group-Database"/>.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>hosts</literal></term>
    <listitem>
     <para>
      Konak isimleri ve numaraları, bkz. <xref linkend="glibc-Host-Names"/>.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>initgroups</literal></term>
    <listitem>
     <para>
      Tamamlayıcı grup erişim listesi.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>netgroup</literal></term>
    <listitem>
     <para>
      Ağ çapında kullanıcılar, konaklar ve alt ağlar, bkz.<xref linkend="glibc-Netgroup-Database"/>.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>networks</literal></term>
    <listitem>
     <para>
      Ağ isimleri ve numaraları, bkz. <xref linkend="glibc-Networks-Database"/>.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>passwd</literal></term>
    <listitem>
     <para>
      Kullanıcı kimlikleri, bkz. <xref linkend="glibc-User-Database"/>.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>protocols</literal></term>
    <listitem>
     <para>
      Ağ protokolleri, <xref linkend="glibc-Protocols-Database"/>.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>publickey</literal></term>
    <listitem>
     <para>
      Güvenli uzak yordam çağrıları için genel anahtarlar.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>rpc</literal></term>
    <listitem>
     <para>
      Uzak yordam çağrı isimleri ve numaraları.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>services</literal></term>
    <listitem>
     <para>
      Ağ hizmetleri, bkz. <xref linkend="glibc-Services-Database"/>.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>shadow</literal></term>
    <listitem>
     <para>
      Kullanıcı parola aşları ve ilgili bilgiler.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
  <para>
   İleride başka veritabanları eklenebilir.
  </para>
 </chapter>

 <chapter xml:id="glibc-NSS-Configuration-File" userlevel="notoc">
  <?dbhtml stop-chunking?>
  <title>NSS Yapılandırma Dosyası</title>
  <titleabbrev>NSS yapılandırması.</titleabbrev>
  <para>
   <indexterm linkend="glibc-cp"><primary sortas="etc/nsswitch.conf"><filename>/etc/nsswitch.conf</filename></primary></indexterm>
   <indexterm linkend="glibc-cp"><primary><filename>nsswitch.conf</filename></primary></indexterm>
   Ne olursa olsun, NSS kodu kullanıcının isteklerini yerine getirmelidir. <filename>/etc/nsswitch.conf</filename> dosyası bu sebeple vardır. Bu dosyada her veritabanı için arama sürecinin nasıl çalışacağı ile ilgili bir belirtim vardır. Dosyanın içeriği şuna benzer:
  </para>
  <example>
   <screen># /etc/nsswitch.conf
#
# Name Service Switch configuration file.
#

passwd:     db files
shadow:     files
group:      db files

hosts:      files dns
networks:   files

ethers:     db files
protocols:  db files
rpc:        db files
services:   db files
</screen>
  </example>
  <para>
   lk sütunda veritabanının ismi bulunur. Satırın kalanında arama sürecinin nasıl çalışacağı belirtilir. Belirtilen yolun her veritabanı için ayrı olduğu unutulmamalıdır. Bu, eski yöntemle, bir tek parça gerçekleme ile yapılamaz.
  </para>
  <para>
   Her veritabanı için yapılandırma belirtimi iki farklı öge içerebilir:
  </para>
  <simplelist>
   <member>
    <code>files</code>, <code>db</code> veya <code>nis</code> gibi bir hizmet belirtimi.
   </member>
   <member>
    <code>[NOTFOUND=return]</code> gibi arama sonucuna verilen tepki.
   </member>
  </simplelist>

   <sect1 xml:id="glibc-Services-in-the-NSS-configuration">
    <title>NSS Yapılandırma Dosyasındaki Hizmetler</title>
    <titleabbrev>NSS yapılandırmasındaki hizmet isimleri.</titleabbrev>
    <para>
     Önceki bölümdeki örnek dosyada beş farklı hizmet vardı: <code>files</code>, <code>db</code>, <code>dns</code>, <code>nis</code> ve <code>nisplus</code>.  Bu, her yerde sadece bu hizmetlerin olduğu anlamına gelmediği gibi bunların her yerde bulunabilen hizmetler olduğu anlamına da gelmez.
    </para>
    <para>
     Aslında, bu isimler NSS kodu tarafından dolaylı olarak adresli işlevleri bulmak için kullanılan basit dizgelerdir. Dahili arayüz daha sonra açıklanacaktır. Kullanıcıya görünür olan, her biri bir hizmeti gerçekleştiren modüllerdir.
    </para>
    <para>
     <replaceable>isim</replaceable> dizgesi arama için kullanılacak hizmet olduğu varsayılırsa bu hizmeti gerçekleştiren modülün dosyası  <code>libnss_</code><replaceable>isim</replaceable> adını alır. Paylaşımlı kütüphaneleri destekleyen sistemlerde ise bu isim (örneğin)  <code>libnss_</code><replaceable>isim</replaceable><code>.so.2</code> olacaktır. Dosya isminin sonundaki sayı arayüzün o an geçerli ve pek sık değişmeyen sürümünü ifade eder. Normalde kullanıcılar bu dosyalarla ilgilenmezler, çünkü bunlar özdevinimli olarak bulunabilecekleri bir dizine konulur. Mevcut hizmetlerin sadece isimleri önemlidir.
    </para>
    <para>
     Son olarak, bazı sistem yazılımları, benzer amaçlarla kendi yapılandırmalarını depolamak için NSS yapılandırma dosyasını kullanabilir. Bunun örnekleri, <code>autofs</code> tarafından kullanılan <code>automount</code> hizmetini içerir.
    </para>
   </sect1>
   <sect1 xml:id="glibc-Actions-in-the-NSS-configuration">
    <title>NSS Yapılandırmasındaki Eylemler</title>
    <titleabbrev>Arama sonucuna verilen tepki.</titleabbrev>
    <para>
     Belirtimdeki ikinci öge, kullanıcıya arama sürecini daha iyi denetleme imkanı verir. Eylem ögeleri iki hizmet ismi arasına yerleştirilir ve köşeli parantezlerin arasına yazılır. Genel biçimi şöyledir:
    </para>
    <literallayout class="monospaced">[ ( !? <replaceable>durum</replaceable>=<replaceable>eylem</replaceable> )+ ]
</literallayout>
    <para>Burada:</para>
    <literallayout class="monospaced"><replaceable>durum</replaceable> ⇒ success | notfound | unavail | tryagain
<replaceable>eylem</replaceable> ⇒ return | continue
</literallayout>
    <para>
     olabilir. Sözcüklerin harf büyüklükleri önemsizdir. <replaceable>durum</replaceable> değerleri belirli bir hizmetin arama işlevi çağrısının sonucudur. Bunların anlamları:
    </para>
    <variablelist>
     <varlistentry>
      <term>'<literal>success</literal>'</term>
      <listitem>
       <para>
        Bir hata oluşmadan istenen girdi döndü. Öntanımlı eylem  <code>return</code>, dön'dür.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
       <term>'<literal>notfound</literal>'</term>
       <listitem>
        <para>
         Arama süreci tamamlandı ama gerekli değer bulunamadı. Öntanımlı eylem <code>continue</code>, aramaya devam et'tir.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
       <term>'<literal>unavail</literal>'</term>
       <listitem>
        <para>
         <indexterm linkend="glibc-cp"><primary>DNS sucusu hizmetdışı</primary></indexterm>
         Hizmet geçici olarak kullanım dışıdır. Bu ya gerekli dosyanın olmadığı ya da DNS için, hizmetin kullanım dışı olduğunu veya sorguya izin vermediğini belirtir. Öntanımlı eylem <code>continue</code>, aramaya devam et'tir.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>'<literal>tryagain</literal>'</term>
      <listitem>
       <para>
        Hizmet geçici olarak kullanım dışıdır. Bu bir dosyanın kilitli olduğu ya da bir sunucunun o an artık bağlantı kabul edemediğini belirtir. Öntanımlı eylem  <code>continue</code>, aramaya devam et'tir.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
    <para>
     <replaceable>eylem</replaceable> değerleri ve anlamları:
    </para>
    <variablelist>
     <varlistentry>
      <term>'<literal>return</literal>'</term>
      <listitem>
       <para>
        <replaceable>durum</replaceable> eşleşirse, bu hizmet belirtiminde arama işlemi durdurulur. Bir girdi varsa, uygulamaya aktarılır. Bir hata oluşursa,  uygulamaya bildirilir. Önceki bir ‘<code>merge</code>’ (birleştirme) eylemi durumunda, veriler aşağıda açıklandığı gibi önceki arama sonuçlarıyla birleştirilir.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>'<literal>continue</literal>'</term>
      <listitem>
       <para>
        <replaceable>durum</replaceable> eşleşirse, mevcut aramanın sonucu (ve herhangi bir birleştirilmiş veri) atılarak arama işlemine bir sonraki girdiden devam edilir. Bir istisna, ‘<code>initgroups</code>’ veritabanı ve ‘<code>continue</code>’ (devam et) eyleminin aşağıdaki <code>merge</code> (birleştir) gibi davrandığı ‘<code>success</code>’ (başarı) durumudur.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>'<literal>merge</literal>'</term>
      <listitem>
       <para>
        Geçerli arama sonucu korunarak arama işlemine devam edilir. Bu <replaceable>eylem</replaceable> yalnızca ‘<code>success</code>’ (başarı) <replaceable>durum</replaceable>unda yararlıdır. Sonraki bir hizmet araması başarılı olursa ve eşleşen bir ‘<code>return</code>’ (dönüş) <replaceable>eylem</replaceable>ine sahipse, sonuçlar birleştirilir, arama işlemi sona erer ve birleştirilen sonuçlar uygulamaya döndürülür. Aşağıdaki hizmetin eşleşen bir <code>merge</code> (birleştir) <replaceable>eylem</replaceable>i varsa, arama işlemi bu ve önceki aramalardan birleştirilmiş veriler korunarak devam eder.
       </para>
       <para>
        <code>merge</code> (birleştir) <replaceable>eylem</replaceable>inden sonra, sonraki aramalardan gelen hatalar yok sayılır ve o ana kadar toplanan veriler döndürülür.
       </para>
       <para>
        <code>merge</code> (birleştir) yalnızca ‘<code>success</code>’ (başarı) <replaceable>durum</replaceable>unda uygulanır. Şu anda ‘<filename>group</filename>’ veritabanı ve onun grup üyeleri alanı <filename>gr_mem</filename>’ için uygulanmaktadır. Diğer veritabanları için belirtilirse, aramanın başarısız olmasına neden olur (<replaceable>durum</replaceable> eşleşirse).
       </para>
       <para>
        ‘<filename>group</filename>’ üyeliği için  <code>merge</code> (birleştir) <replaceable>eylem</replaceable>i yürürlükteyken, grup kimliği ve adı her iki girdi için de aynı olmalıdır. Yalnızca biri veya diğeri eşleşirse, davranış tanımsızdır.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
    <para>
     Şöyle bir satırın varlığında:
    </para>
    <literallayout class="monospaced">ethers: nisplus [NOTFOUND=return] db files
</literallayout>
    <para>
     Satır şuna eşdeğerdir (hepsinin bir satıra yazılması zorunluluğu dışında):
    </para>
    <literallayout class="monospaced">ethers: nisplus [SUCCESS=return NOTFOUND=return UNAVAIL=continue
                 TRYAGAIN=continue]
        db      [SUCCESS=return NOTFOUND=continue UNAVAIL=continue
                 TRYAGAIN=continue]
        files
</literallayout>
    <para>
     Eylemlerin ön tanımlı değeri normalde ne istendiğini gösterir ve sadece olağan dışı durumlarda değiştirmek gerekir.
    </para>
    <para>
     <replaceable>durum</replaceable> dizgesinden önce bir <code>!</code> varsa (isteğe bağlıdır), belirtilen eylemin dışındaki tüm eylemlerin geçerli olduğu anlamına gelir. Yani, <code>!</code> işleci C dilindeki gibi "bundan farklı her şey" anlamına gelir.
    </para>
    <para>
     Bu <replaceable>eylem</replaceable> ögesini gerekli yapan olağan dışılığı açıklamadan önce birkaç yorum: <command>files</command> hizmetinden sonra bir eylem ögesi eklemenin bir faydası olmadığı açıktır. Eylem <emphasis>daima</emphasis> <code>return</code> olacağından bundan sonra başka hizmet belirtilmez.
    </para>
    <para>
     <indexterm linkend="glibc-cp"><primary>nisplus</primary><secondary>bütünlük</secondary></indexterm>
     Şimdi, bu <code>[NOTFOUND=return]</code> <replaceable>eylem</replaceable>i neden kullanışlıdır? Sebebini anlayabilmek için <code>nisplus</code> hizmetinin çoğunlukla bir bütünlük arzettiğini bilmemiz gerekir. Yani, bir girdi NIS+ tablolarında mevcut değilse başka hiçbir yerde bulunamaz. Bu durum bu eylem ögesinin neden böyle belirtildiğini açıklar: diğer hizmetler zaten bir sonuç vermeyeceğinden onlara bakmak yararsızdır.
    </para>
    <para>
     <indexterm linkend="glibc-cp"><primary>nisplus</primary><secondary>sistem açılışı</secondary></indexterm>
     NIS+ hizmetinin makinenin yeniden başlatılması nedeniyle yokluğu farklı bir durum olurdu. Bu durumda arama işlevinin dönüş değeri <code>notfound</code> değil, <code>unavail</code> olur. Yukarıdaki satırın açılımında da görüleceği gibi bu durumda <code>db</code> ve <code>files</code> hizmetleri kullanılır. Güzel değil mi? Sistem çalışmaya tamamen hazır olmadığı bir anda (sistem açılışı, kapanışı ya da bir ağ sorunu nedeniyle) sistem yöneticisinin özel bir çaba harcaması gerekmeyecektir.
    </para>
   </sect1>
   <sect1 xml:id="glibc-Notes-on-NSS-Configuration-File">
    <title>NSS Yapılandırma Dosyası için İpuçları</title>
    <titleabbrev>NSS yapılandırılırken dikkat edilmesi gerekenler.</titleabbrev>
    <para>
     Son olarak birkaç ipucu. <filename>/etc/nsswitch.conf</filename> dosyasının olmayışı durumunda NSS gerçeklemesi tamamen çaresiz bırakmaz. Desteklenen tüm veritabanları için bir ön tanımlı değer vardır, böylece dosya bozuk da olsa hiç olmasa da sistemin normal çalışması mümkün olur.
    </para>
    <para>
     <indexterm linkend="glibc-cp"><primary>NSS</primary><secondary>ön tanımlı değer</secondary></indexterm>
      <code>hosts</code> ve <code>networks</code> veritabanları için ön tanımlı değer <code>dns [!UNAVAIL=return] files</code> şeklindedir. Yani sistem DNS hizmeti olmaksızın hazırsa ama yanıt varsa dönüş kesindir.
    </para>
    <para>
     <code>passwd</code>, <code>group</code> ve <code>shadow</code> veritabanları geleneksel olarak özel bir yolla elde edilir. <filename>/etc</filename> dizinindeki ilgili dosyalar okunur, bunlar içinde <code>+</code> ile başlayan bir isim varsa NIS kullanılır. Bu çeşit arama kaldırılmıştır ve artık hizmetler için ön tanımlı değer <code>files</code>'tır. <code>libnss_compat</code> artık <code>libnsl</code>'ye bağlı değildir ve NIS olmadan kullanılabilmektedir.
    </para>
    <para>
     Tüm diğer veritabanları için ön tanımlı değer <code>files</code>'tır.
    </para>
    <para>
     <indexterm linkend="glibc-cp"><primary>NSS</primary><secondary>en iyileme</secondary></indexterm>
     <indexterm linkend="glibc-cp"><primary>en iyileme</primary><secondary>NSS</secondary></indexterm>
     İkinci bir nokta da kullanıcının arama sürecini en iyilemeye çalışmasıdır. Her hizmetin kendine özgü bir yanıt süresi vardır. Basit dosya araması bir yerel dosya üzerinde hızlı olabilirdi ama dosya uzunsa ve gerekli girdi dosyanın sonlarına doğruysa bu biraz vakit alır. Bu durumda büyük veri kümelerine daha hızlı erişim sağlayan <code>db</code> hizmetinin kullanılması daha iyi olabilir.
    </para>
    <para>
     Sıkça rastlanan bir durum NIS gibi kapsamlı bilgi hizmetlerinin kullanıldığı durumdur. Bu durumda <code>nis</code> vb. hizmet girdilerinin kullanılması kaçınılmazdır. Fakat bunun gibi yavaş hizmetlerden mümkün olduğunca kaçınılmalıdır.
    </para>
   </sect1>
  </chapter>

  <chapter xml:id="glibc-NSS-Module-Internals" userlevel="notoc">
   <?dbhtml stop-chunking?>
   <title>NSS Modüllerinin Yapısı</title>
   <titleabbrev>Modüller dahili anlamda nasıl çalışır.</titleabbrev>
   <para>
    Artık modüllerin nasıl çalıştığı açıklanabilir. Bir modülde bulunan işlevler isimleriyle anılırlar. Yani, bir sıçrama tablosu ya da benzeri bir şey yoktur. Bunun nasıl yapıldığıyla burada ilgilenilmeyecektir; bunlarla ilgilenenler Özdevimli İlintileme (Dynamic Linking) hakkında bir şeyler okumalıdır.
   </para>
   <sect1 xml:id="glibc-NSS-Module-Names">
    <title>NSS Modüllerinin İsimlendirme Şeması</title>
    <titleabbrev>NSS modüllerinin arayüz işlevinin oluşturulması.</titleabbrev>
    <para>
     Her işlevin ismi çeşitli parçaların bir araya getirilmesiyle oluşur:
    </para>
    <literallayout class="monospaced">_nss_<replaceable>hizmet</replaceable>_<replaceable>işlev</replaceable>
</literallayout>
    <para>
     <replaceable>hizmet</replaceable> şüphesiz bu işlevi içeren modülün isminden gelecektir.<footnote><para>Şimdi şöyle bir soru sorulabilir: Niçin bu bilgi işlevlerin de ismine sokuluyor, modülün isminde zaten var. Yanıtı, bunun paylaşımlı nesenelerle birlikte ilintilenmesi mümkün olmalıdır.</para></footnote>   <replaceable>işlev</replaceable> parçası C kütüphanesindeki arayüz işlevinden türetilir. Eğer kullanılan hizmet <code>files</code> ve bu hizmetin modülünde kullanılan işlev <function>gethostbyname</function> ise:
    </para>
    <literallayout class="monospaced">libnss_files.so.2
</literallayout>
    <para>modülündeki</para>
    <literallayout class="monospaced">_nss_files_gethostbyname_r
</literallayout>
     <para>işlevinden bahsediyor, oluruz.</para>
     <para>
      <indexterm linkend="glibc-cp"><primary>evresel NSS işlevleri</primary></indexterm>
      Görüldüğü gibi, yukarıda açıklanan gerçeğin tümü değildir. Aslında NSS modülleri arama işlevlerinin sadece evresel sürümlerini içerir. Yani yazılımcı aslında <function>gethostbyname_r</function> işlevini kullanacağından bunu işlevin isminde <code>gethostbyname_r</code> olarak ('gethostbayname_r'eentrant) belirtmelidir. Tüm kullanıcı arayüzü işlevleri için C kütüphanesi bu çağrıları evresel işlev çağrılarına eşler. Evresel işlevler için arayüz hemen hemen aynı olduğundan bu sıradan bir işlemdir. Evresel eşdeğeri olmayan işlevler için ise kütüphane, kullanılan dahili tamponları kullanıcı tanımlı tamponlarla değiştirerek tutar.
     </para>
     <para>
      Yani evresel işlevlerin benzer karşılıkları olabilir. Tüm veritabanları için işlevler içerecek ya da tüm veritabanlarının erişebileceği şekilde tasarlanmış bir hizmet modülü yoktur. Bir işlevin yokluğu halinde işlevin <code>unavail</code> döndüreceği varsayılmıştır (Bkz. <xref linkend="glibc-Actions-in-the-NSS-configuration"/>).
     </para>
     <para>
      <filename>libnss_files.so.2</filename> dosya ismi bir Solaris 2 sistemde <filename>nss_files.so.2</filename> olarak görünür.  Bu farktan daha önce sözedilmişti. Sun'ın NSS modülleri sadece dolaylı olarak yüklenen modüller olarak kullanılabilir.
    </para>
    <para>
     &glibc;ndeki NSS modülleri, normal kütüphane olarak kullanılmak üzere hazırlanmıştır. Fakat, bu, şu anda geçerli <emphasis>değildir</emphasis>. Fakat modüllerdeki ad alanının kuruluşu, bunu, Solaris'in aksine imkansız kılmamaktadır.     Modüllerin kitaplık olması bundan kaynaklanmaktadır.<footnote>
      <para>
       İkinci bir açıklama da şöyledir: Makefile'ları, <code>lib</code> ile başlamayan paylaşımlı nesnelerin oluşturulması için değiştirmeye üşendik, ama bunu kimseye söylemeyin.
      </para>
     </footnote>
    </para>
   </sect1>
   <sect1 xml:id="glibc-NSS-Modules-Interface">
    <title>NSS Modüllerinde İşlev Arayüzü</title>
    <titleabbrev>NSS modül işlevleriyle arayüzün geliştirilmesi.</titleabbrev>
    <para>
     Artık, modüllerdeki işlevler hakkında bir bilgi birikimi oluştu. Şimdi türleri açıklanabilir. Bir önceki bölümde işlevlerin evresel sürümlerinden bahsedilmişti. Bu, işlevin evresel olmayan sürümüne göre ek bağımsız değişkenler gerektiği anlamına gelir. <function>gethostbyname</function> işlevinin evresel olmayan ve evresel sürümlerinin prototipleri ele alınırsa:
    </para>
    <literallayout class="monospaced">struct hostent *gethostbyname (const char *name)

int gethostbyname_r (const char *name, struct hostent *result_buf,
                     char *buf, size_t buflen, struct hostent **result,
                     int *h_errnop)
</literallayout>
     <para>
      İşlevin NSS modülündeki prototipi ise şöyle olur:
     </para>
     <literallayout class="monospaced">enum nss_status _nss_files_gethostbyname_r (const char *name,
                                            struct hostent *result_buf,
                                            char *buf, size_t buflen,
                                            int *errnop, int *h_errnop)
</literallayout>
     <para>
      <indexterm linkend="glibc-tp" xml:id="glibc-tp-nss_status"><primary sortas="nss_status">enum&#160;nss_status</primary></indexterm>
      Yani, arayüz işlevi aslında <parameter>result</parameter> bağımsız değişkeni olmayan, fazladan <parameter>errnop</parameter> bağımsız değişkeni olan  ve dönüş değeri değişmiş evresel işlevdir. İşlevin evresel olmayan sürümü <parameter>result</parameter> göstericisi ile dönerken evresel sürümü şu <code>enum&#160;nss_status</code> değerlerinden biri ile döner:
     </para>
     <csynopsis>
      <indexterm linkend="glibc-vr" xml:id="glibc-vr-NSS_STATUS_TRYAGAIN"><primary>NSS_STATUS_TRYAGAIN</primary></indexterm>
      <csproto type="sabit">
       <csname><function>NSS_STATUS_TRYAGAIN</function></csname>
      </csproto>
      <header>&nss.h;</header>
      <para>
       sayısal değeri: <code>-2</code>
      </para>
     </csynopsis>
     <csynopsis>
      <indexterm linkend="glibc-vr" xml:id="glibc-vr-NSS_STATUS_UNAVAIL"><primary>NSS_STATUS_UNAVAIL</primary></indexterm>
      <csproto type="sabit">
       <csname><function>NSS_STATUS_UNAVAIL</function></csname>
      </csproto>
      <header>&nss.h;</header>
     <para>
      sayısal değeri: <code>-1</code>
     </para>
     </csynopsis>
     <csynopsis>
      <indexterm linkend="glibc-vr" xml:id="glibc-vr-NSS_STATUS_NOTFOUND"><primary>NSS_STATUS_NOTFOUND</primary></indexterm>
      <csproto type="sabit">
       <csname><function>NSS_STATUS_NOTFOUND</function></csname>
      </csproto>
      <header>&nss.h;</header>
      <para>
       sayısal değeri: <code>0</code>
      </para>
     </csynopsis>
     <csynopsis>
      <indexterm linkend="glibc-vr" xml:id="glibc-vr-NSS_STATUS_SUCCESS"><primary>NSS_STATUS_SUCCESS</primary></indexterm>
      <csproto type="sabit">
       <csname><function>NSS_STATUS_SUCCESS</function></csname>
      </csproto>
      <header>&nss.h;</header>
      <para>
       sayısal değeri: <code>1</code>
      </para>
     </csynopsis>
     <para>
      Artık, <filename>/etc/nsswitch.conf</filename> dosyasında kullanılar eylem ögelerinin yerleri incelenebilir.
     </para>
     <para>
      Kaynak kodu incelenirse, beşinci bir değerin varlığı görülür: <code>NSS_STATUS_RETURN</code>.  Bu sadece dahili olarak kullanılan bir değerdir, birkaç işlev tarafından yukarıdaki değerin kullanılamadığı yerlerde kullanılır. Eğer gerekliyse, daha fazla ayrıntıya kaynak kodu incelenerek ulaşılabilir.
     </para>
     <para>
      Arayüz işlevinin bir hata döndürmesi durumunda, doğru hata numarasının *<parameter>errnop</parameter> içinde saklanması önemlidir. Bazı dönüş durum değerleri sadece bir hata kodu ile ilgiliyken diğerleri daha fazlası ile ilgilidir.
     </para>
     <informaltable frame="none">
      <tgroup cols="3">
       <colspec colwidth="22*"/>
       <colspec colwidth="14*"/>
       <colspec colwidth="36*"/>
       <tbody>
        <row>
         <entry><varname>NSS_STATUS_TRYAGAIN</varname></entry>
         <entry><varname>EAGAIN</varname></entry>
         <entry> Kullanılan işlevlerden biri ya geçici olarak öz kaynaksız çalıştı ya da hizmet şu an kullanışsız.</entry>
        </row>
        <row>
         <entry/>
         <entry><varname>ERANGE</varname></entry>
         <entry> Belirtilen tampon yeterince geniş değil. İşlev tekrar daha geniş bir tamponla çağrılmalı.</entry>
        </row>
        <row>
         <entry><varname>NSS_STATUS_UNAVAIL</varname></entry>
         <entry><varname>ENOENT</varname></entry>
         <entry> Gerekli girdi dosyalarından biri bulunamadı.</entry>
        </row>
        <row>
         <entry><varname>NSS_STATUS_NOTFOUND</varname></entry>
         <entry><varname>ENOENT</varname></entry>
         <entry> İstenen girdi elverişli değil.</entry>
        </row>
        <row>
         <entry/>
         <entry><varname>SUCCESS</varname></entry>
         <entry> Girdi yok. Daha sonra etkinleştirilebilecek etkin olmayan hizmetler için hata döndürmekten kaçınmak için kullanılır. Bu, hizmetin geçici olarak kullanılamamasıyla aynı şey değildir.</entry>
        </row>
       </tbody>
      </tgroup>
     </informaltable>
     <para>
      Bunlar önerilen değerlerdir. Başka hata kodları olabileceği gibi açıklanan hata kodları farklı anlamlara da gelebilir. <emphasis>Biri dışında:</emphasis> <varname>NSS_STATUS_TRYAGAIN</varname> döndüğünde, hata kodu, belirtilen tamponun yetersiz olduğun anlatan <varname>ERANGE</varname> <emphasis>olmalıdır</emphasis>. Bunun dışında önemli bir şey yoktur.
    </para>
    <para>
     Duruk olarak ilintili uygulamalarda, ana uygulama ve NSS modülleri aynı evreye özgü değişken <varname>h_errno</varname>'yu paylaşmaz, <parameter>errnop</parameter> bağımsız değişkeni bu nedenle vardır.
    </para>
    <para>
     Yukarıdaki işlev hemen hemen diğer tüm modül işlevlerinde olmayan bazı özelliklere sahiptir. <parameter>errnop</parameter> diye bir bağımsız değişkeni vardır. Bu bağımsız değişkenin gösterdiği değişkene, işlev bir şekilde başarısız olduğunda hata durumu konulur.
    </para>
    <para>
     <code>get</code><replaceable>XXX</replaceable><code>by</code><replaceable>YYY</replaceable> işlevleri NSS modüllerinde en önemli işlevlerdir. Ancak başka yöntemlerle erişilen veritabanları da vardır (<function>setpwent</function>, <function>getpwent</function> ve <function>endpwent</function> işlevleri ile erişilen parola veritabanı buna örnek verilebilir). Bunlar daha sonra ayrıntılı olarak açıklanacaktır. Modül işlevinin imzasını saptayacak genel bir yöntem:
    </para>
    <itemizedlist>
     <listitem>
      <para>
       dönüş değeri <type>enum&#160;nss_status</type> türündedir.
      </para>
     </listitem>
     <listitem>
      <para>
       ismi <xref linkend="glibc-NSS-Module-Names"/> bölümünde açıklandığı gibidir.
      </para>
     </listitem>
     <listitem>
      <para>
       işlevin ilk bağımsız değişkenleri evresel olmayan eşdeğerinin bağımsız değişkenleri ile aynıdır;
      </para>
     </listitem>
     <listitem>
      <para>
       sonraki dört bağımsız değişkenleri şunlardır:
      </para>
      <glosslist>
       <glossentry>
        <glossterm>
         <code>STRUCT_TYPE&#160;*</code><parameter>result_buf</parameter>
        </glossterm>
        <glossdef>
         <para>
          sonucun saklandığı tampona gösterici.  <command>STRUCT_TYPE</command>, normalde veritabanının karşılığı olan bir yapıdır.
         </para>
        </glossdef>
       </glossentry>
       <glossentry>
        <glossterm>
         <type>char&#160;*</type><parameter>buffer</parameter>
        </glossterm>
        <glossdef>
         <para>
          sonuçla ilgili ek verilerin saklanabileceği tampona gösterici.
         </para>
        </glossdef>
       </glossentry>
       <glossentry>
        <glossterm>
         <type>size_t&#160;</type><parameter>buflen</parameter>
        </glossterm>
        <glossdef>
         <para>
          <parameter>buffer</parameter> ile gösterilen tamponun uzunluğu.
         </para>
        </glossdef>
       </glossentry>
       <glossentry>
        <glossterm>
         <type>int&#160;</type><parameter>errnop</parameter>
        </glossterm>
        <glossdef>
         <para>
          Uygulamaya dönecek düşük seviyeli hata kodu. Dönüş değeri <varname>NSS_STATUS_SUCCESS</varname> değilse, *<parameter>errnop</parameter>'a sıfır olmayan bir değer atanması gerekir. Bir NSS modülü asla *<parameter>errnop</parameter>'a sıfır atamamalıdır. <varname>ERANGE</varname> değeri, yukarıda açıklandığı gibi özeldir.
         </para>
        </glossdef>
       </glossentry>
      </glosslist>
     </listitem>
     <listitem>
      <para>
       <indexterm xml:id="glibc-vr-NETDB_INTERNAL" linkend="glibc-vr"><primary>NETDB_INTERNAL</primary></indexterm>
       konak ismi ve ağ ismi arama işlevlerinde <parameter>errnop</parameter> genelde hep son bağımsız değişkendir. <varname>NSS_STATUS_SUCCESS</varname> değilse, *<parameter>errnop</parameter>'a sıfır olmayan bir değer atanması gerekir. Genel hata kodu <varname>NETDB_INTERNAL</varname> olup daha fazla ayrıntı için *<parameter>errnop</parameter>'un incelenmesini söyler. (Buna, <varname>ERANGE</varname> özel durumu dahildir.)
      </para>
     </listitem>
    </itemizedlist>
    <para>
     <code>set…ent</code> ve <code>end…ent</code> işlevleri dışında tüm işlevler için, bu liste geçerlidir.
    </para>
  </sect1>
 </chapter>
 <chapter xml:id="glibc-Extending-NSS" userlevel="notoc">
  <?dbhtml stop-chunking?>
  <title>NSS'nin Genişletilmesi</title>
  <titleabbrev>Yeni hizmetler ve veritabanlarını eklemek için ne yapılır.</titleabbrev>
  <para>
   Evvelce bahsedildiği gibi NSS'nin getirilerinden biri kolayca genişletilebilmesidir. Genişletme iki yolla yapılabilir: İlki normalde sadece C kütüphanesi geliştiricileri tarafından yapılır. Burada önemli olan, başka bir veritabanının bağımsız olarak eklenmesi gerektiğini unutmamaktır. Çünkü bir hizmet tüm veritabanlarını ve arama işlevlerini desteklemek zorunda değildir.
  </para>
  <para>
   Bir yeni hizmetin tasarımcısı/gerçekleştiricisi ilgilendiği veritabanlarını seçmekte özgür olduğu gibi kalanı daha sonraya da bırakabilir (veya tamamen terkedebilir).
  </para>
  <sect1 xml:id="glibc-Adding-another-Service-to-NSS">
   <title>NSS'ye Başka Hizmetlerin Eklenmesi</title>
   <titleabbrev>Yeni bir hizmet eklenirken ne yapılır.</titleabbrev>
   <para>
    Yeni hizmetle ilgili kaynaklar &glibc;nin parçası olmak zorunda değildir (hatta olmamalıdır). Geliştiricinin kaynaklar ve tasarım üzerinde tam hakimiyeti olmalıdır. C kütüphanesi ile yeni hizmet modülü arasındaki bağları sadece arayüz işlevleri oluşturur.
   </para>
   <para>
    Her modül burada açıklanan özel arayüz belirtimine göre tasarlanır. Şimdilik sürümü 2'dir (arayüzün 1. sürümü yetersizdi) ve bu NSS modülünün paylaşımlı kütüphane nesnesinin sürüm numarası olarak belirtilir: bu nesnelerin isimleri <code>.2</code> uzantısını içerir. Eğer arayüz şimdikiyle uyumsuz olarak değiştirilirse bu numara artacak ama eski arayüzü kullanan modüller hala kullanılabilir olacaktır.
   </para>
   <para>
    Yeni hizmetin geliştiricileri modülün doğru arayüz numarası kullanılarak oluşturuduğundan emin olmak zorundadır. Yani, dosyanın ismi doğru tanımlanacak ve ELF sistemlerde paylaşımlı nesne ismi (<emphasis>so uzantısı</emphasis>) ayrıca bu numarayı içerecektir. Bir modül, bir ELF sisteminde GNU CC ile nesne dosyalarından şöyle derlenir:
   </para>
   <screen>gcc -shared -o libnss_<replaceable>İSİM</replaceable>.so.2 -Wl,-soname,libnss_<replaceable>İSİM</replaceable>.so.2 <replaceable>NESNELER</replaceable>
</screen>
   <para>
    Bu komut satırı hakkında daha fazla bilgi GNU CC belgelerinin <link xl:href="https://gcc.gnu.org/onlinedocs/gcc/Link-Options.html#Link-Options">İlintileme Seçenekleri</link> sayfasında bulunabilir.
   </para>
   <para>
     Modülü kullanacak kütüphane yeni modülü bulabilmelidir. Bu özdevimli ilintileyici seçenekleri kullanılarak yapılabilir, böylece ikil nesne dosyasının yerleştirildiği dizini bulabilir. ELF sistemlerde bu, modülün bulunduğu dizin <varname>LD_LIBRARY_PATH</varname> ortam değişkenine eklenerek yapılır.
   </para>
   <para>
    Fakat, bazı uygulamalar bu değişkeni yok saydığından (bunlar kullanıcının kimliğini kullanmaz) bu daima mümkün olmaz. Bu nedenle, modülün kararlı sürümünün özdevimli ilintileyicinin araştırdığı dizinlere konulması önem kazanır. Normalde bu dizin <filename>$prefix/lib</filename> dizini olmalıdır, burada <replaceable>$prefix</replaceable> derleme öncesi yapılandırma sırasında <option>&#45;&#45;prefix</option> seçeneğinde belirtilen dizindir. Aman dikkat: bu sadece, modül herhangi bir bozukluğa yol açmıyorsa yapılabilir. Sistem yöneticisi bu bakımdan dikkatli olmalıdır.
   </para>
  </sect1>
  <sect1 xml:id="glibc-NSS-Module-Function-Internals">
   <title>NSS Modül İşlevlerinin Özellikleri</title>
   <titleabbrev>Yeni NSS hizmet işlevlerini yazmak için bilinmesi gerekenler.</titleabbrev>
   <para>
    Şimdiye kadar NSS modülündeki işlevlerin sözdizimsel arayüzünden bahsedildi. Her işlevin gerçeklenmesi ister istemez farklı olacağında aslında söylenebilecek fazla bir şey yoktur. Fakat tüm işlevlerin uyması gereken birkaç genel kuraldan bahsedilebilir.
   </para>
   <para>
    Aslında arayüzde görülebilecek dört farklı işlev çeşidi vardır. Hepsi sistem veritabanları için kullanılan geleneksel işlevlerden türetilir. Aşağıdaki gösterimde <replaceable>VT</replaceable>, <replaceable>VERİTABANI</replaceable> için kısaltmadır (örn, kullanıcı veritabanı için yerini <code>pw</code> kısaltması alır).
   </para>
   <csynopsis>
    <csproto type="işlev">
     <csname><type>enum&#160;nss_status</type><code>_nss_<replaceable>VERİTABANI</replaceable>_set<replaceable>VT</replaceable>ent</code></csname>
     <csparam><void/></csparam>
    </csproto>
    <header>&nss.h;</header>
    <para>
     Bu işlev hizmeti belirtilen işlemler için hazırlar. Basit bir dosya temelli arama için dosyaları açan, diğer hizmetlerde basitçe hiçbir işlem yapmayan bir işlev olabilir.
    </para>
    <para>
     Bu işlev için özel bir durum, <function>sethostent</function> işlevindeki (<xref linkend="glibc-Host-Names"/>) gibi belirtilen bazı <replaceable>VERİTABANI</replaceable> türleri için ek bağımsız değişkenler alabilmesidir. (işlev, <code>set<replaceable>VT</replaceable>ent</code> gösterimi ile karşılaştırılırsa "hosts" veritabanı için "host" kısaltmasının kullanıldığı görülür.)
    </para>
    <para>
     Normal dönüş değeri <varname>NSS_STATUS_SUCCESS</varname> olmalı; bir hata durumunda <xref linkend="glibc-NSS-Modules-Interface"/> bölümündeki tabloda belirtilen değerlerden biri olmalıdır.
    </para>
   </csynopsis>
   <csynopsis>
    <csproto type="işlev">
     <csname><type>enum&#160;nss_status&#160;</type><code>_nss_<replaceable>VERİTABANI</replaceable>_end<replaceable>VT</replaceable>ent</code></csname>
     <csparam><void/></csparam>
    </csproto>
    <header>&nss.h;</header>
    <para>
     Bu işlev hala açık olan tüm dosyaları kapatır ya da bellekten tamponları kaldırır. Kaldırılacak bir tampon ya da kapatılacak bir dosya yoksa, işlev yine basitçe hiçbir işlem yapmayacaktır.
    </para>
    <para>
     Normalde <varname>NSS_STATUS_SUCCESS</varname>'dan farklı bir dönüş değeri olmaz.
    </para>
   </csynopsis>
   <csynopsis>
    <csproto type="işlev">
     <csname><type>enum&#160;nss_status&#160;</type><code>_nss_<replaceable>VERİTABANI</replaceable>_get<replaceable>VT</replaceable>ent</code></csname>
     <csparam><replaceable>YAPI</replaceable><code>&#160;*</code><parameter>result</parameter></csparam>
     <csparam><ptr>char</ptr><parameter>buffer</parameter></csparam>
     <csparam><type>size_t</type><parameter>buflen</parameter></csparam>
     <csparam><ptr>int</ptr><parameter>errnop</parameter></csparam>
    </csproto>
    <header>&nss.h;</header>
    <para>
     Bu işlev peşpeşe girdi almak için bir satırda defalarca çağrılacağından bir durum bilgisi tutmak zorundadır. Ama bu zorunluluk ayrıca işlevin gerçekte evresel olmayacağı anlamına da gelir. Sadece, bu işlev aynı anda yapılan başka çağrılarıyla verinin alındığı yere veri yazmayı denemeyecekse, <parameter>result</parameter> ile belirtilen tampona yazacaksa evresel olabilir. Fakat, bir ortak durumu paylaşan çağrıların varlığında ve bir dosya erişimi durumunda bu, dosyadaki komşu girdilerin dönmesi anlamına gelir.
    </para>
    <para>
     <parameter>buffer</parameter> tamponunun uzunluğunu belirtmede kullanılan <parameter>buflen</parameter> sonuç ile ilgili bazı ek verilerin saklanması için kullanılabilir, ama bu durumda işlevin sonraki çağrılarının aynı tamponla yapılabilmesi mümkün olmaz. Ancak, bazı durum bilgilerini döndürmesinden hareketle bu tampon, bir çağrıdan diğerine durum bilgisini aktarmak için kullanılmaMAlıdır.
    </para>
    <para>
     İşlev dönmeden önce, gerçekleme <parameter>errnop</parameter> ile gösterilen değeri <varname>errno</varname> genel değişkeninde saklamalıdır. Modülün durağan ilintili yazılımlarla da çalışabilmesini sağlamak için bunun böyle olması önemlidir.
    </para>
    <para>
     Evvelce açıklandığı gibi bu işlev ayrıca bir ek bağımsız değişken alabilir. Bu kullanılan veritabanına bağlıdır; sadece <code>hosts</code> ve <code>networks</code> veritabanlarında görülür.
    </para>
    <para>
     İşlev <varname>NSS_STATUS_SUCCESS</varname> ile döneceği gibi başka değerlerle de dönebilir. Son girdi okunduktan sonra <varname>NSS_STATUS_NOTFOUND</varname> dönebilir. Belirtilen tampon gereğinden küçükse <varname>NSS_STATUS_TRYAGAIN</varname> ile dönebilir. Bir <code>_nss_<replaceable>VERİTABANI</replaceable>_set<replaceable>VT</replaceable>ent</code> çağrısı ile hizmet başta ilklendirilemediğinde bu işlev için izin verilen tüm dönüş değerleri burada ayrıca döndürülebilir.
    </para>
   </csynopsis>
   <csynopsis>
    <csproto type="işlev">
     <csname><type>enum&#160;nss_status&#160;</type><code>_nss_<replaceable>VERİTABANI</replaceable>_get<replaceable>VT</replaceable>by<replaceable>XX</replaceable>_r</code></csname>
     <csparam><parameter>BAĞIMSIZ_DEĞİŞKENLER</parameter></csparam>
     <csparam><parameter>YAPI</parameter><code>&#160;*</code><parameter>result</parameter></csparam>
     <csparam><ptr>char</ptr><parameter>buffer</parameter></csparam>
     <csparam><type>size_t</type><parameter>buflen</parameter></csparam>
     <csparam><ptr>int</ptr><parameter>errnop</parameter></csparam>
    </csproto>
    <header>&nss.h;</header>
    <para>
     Bu işlev veritabanından <replaceable>BAĞIMSIZ_DEĞİŞKENLER</replaceable> ile adreslenen girdiyi döndürür. Bu bağımsız değişkenlerin sayısı ve türü değişebilir. Bunlar tek tek kullanıcı seviyesi arayüz işlevlerine bakarak saptanır. İşlevin evresel olmayan sürümünde belirtilen tüm bağımsız değişkenler burada <replaceable>BAĞIMSIZ_DEĞİŞKENLER</replaceable> alanında belirtilmelidir.
    </para>
    <para>
     Sonuç <parameter>result</parameter> ile gösterilen yapıda saklanmalıdır. Eğer döndürülecek başka veriler varsa (örn, dizgeler <parameter>result</parameter> yapısında sadece göstericilerle içerilebilir) işlev <parameter>buffer</parameter> ya da ><parameter>buflen</parameter> ile gösterilen tamponları kullanmalıdır. Sabitler biçiminde olmayan hiçbir genel değişkene başvuru olmamalıdır.
    </para>
    <para>
     Bu işlevin gerçeklemesi bir fark oluşacaksa <code>set<replaceable>VT</replaceable>ent</code> işlevi  tarafından atanan <varname>stayopen</varname> seçeneği ile de ilgilenmelidir.
    </para>
    <para>
     İşlev dönmeden önce, gerçekleme <parameter>errnop</parameter> ile gösterilen değeri <varname>errno</varname> genel değişkeninde saklamalıdır. Modülün durağan ilintili yazılımlarla da çalışabilmesini sağlamak için bunun böyle olması önemlidir.
    </para>
    <para>
     Evvelce açıklandığı gibi bu işlev <code>hosts</code> ve <code>networks</code> veritabanları için ayrıca ek bir bağımsız değişken alabilir.
    </para>
    <para>
     İşlevin dönüş değerleri daima <xref linkend="glibc-NSS-Modules-Interface"/> bölümünde açıklanan kurallara uygun olmalıdır.
    </para>
   </csynopsis>
  </sect1>
 </chapter>
</part>
