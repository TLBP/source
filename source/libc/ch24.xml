<?xml version="1.0" encoding="UTF-8"?>
<!-- ********************************************************************
        glibc/ch24.xml,v2.36, GFDL,LGPL, NBB, 2023
     ******************************************************************** -->
<part xml:id="glibc-Signal-Handling" userlevel="longtoc">
 <title>Sinyal İşleme</title>
 <titleabbrev>Sinyaller nasıl gönderilir, engellenir, işlenir.</titleabbrev>
 <preliminary>
  <para>
   <indexterm linkend="glibc-cp"><primary>sinyal</primary></indexterm>
   Bir <wordasword>sinyal</wordasword> bir sürece gönderilen bir yazılım kesmesidir. İşletim sistemi, sinyalleri, çalışan bir yazılıma olağan dışı durumları bildirmekte kullanır. Bazı sinyaller geçersiz bellek adreslerine erişim gibi durumlarda hata bildirmekte, bazıları da bir telefon hattının kapanması gibi rasgele olayları bildirmekte kullanılır.
  </para>
  <para>
   &glibc; her biri başka bir çeşit olaya karşılık olmak üzere çeşitli sinyal türleri tanımlar. Bazı olaylar, bir yazılımın çalışmasını imkansız kılabilir. Bu tür olayları bildiren sinyaller yazılımın çalışmasının durmasına sebep olur. Diğer sinyal çeşitleri zararsız olayları bildirir ve bunlar baştan yok sayılır.
  </para>
  <para>
   Bir olayın sinyallere sebep olacağı bekleniyorsa, sinyalle tetiklenen bir işlev tanımlanıp, böyle sinyaller geldiğinde işletim sisteminden bu işlevin çalıştırılması istenebilir.
  </para>
  <para>
   Son olarak, bir süreç başka bir sürece sinyal gönderebilir; bu bir sürecin kendi alt sürecini durdurması gerektiğinde ya da birbiriyle haberleşerek eşzamanlı çalışması gereken süreçler arasında kullanılabilir.
  </para>
 </preliminary>
 <chapter xml:id="glibc-Concepts-of-Signals" userlevel="notoc">
  <?dbhtml stop-chunking?>
  <title>Sinyallerle İlgili Temel Kavramlar</title>
  <titleabbrev>Sinyallerle ilgili oluşumlara genel bir bakış.</titleabbrev>
  <para>
   Bu kısımda sinyallerin nasıl üretildiği, bir sinyal alındıktan sonra neler olduğu ve yazılımlarda sinyallerin nasıl işlendiği gibi konularla ilgili kavramlara değinilecektir.
  </para>
  <sect1 xml:id="glibc-Kinds-of-Signals">
   <title>Bazı Sinyal Çeşitleri</title>
   <titleabbrev>Bir sinyali oluşturan sebeplere örnekler.</titleabbrev>
   <para>
    Bir sinyal olağan dışı bir olayın varlığını raporlar. Bir sinyale sebep olan (üreten ya da ortaya çıkaran) olayların bazıları:
   </para>
   <simplelist>
    <member>
     Sıfırla bölme ya da geçerli bir aralık dışında adres gösterme gibi yazılım hataları.
    </member>
    <member>
     Kullanıcı tarafından yazılımın durdurulmak ya da sonlandırılmak istenmesi. Çoğu ortam kullanıcıya <code>C-z</code> tuşlayarak uygulamayı durdurabilme veya <code>C-c</code> tuşlayarak uygulamayı sonlandırabilme imkanı sağlar. Bu tuş vuruşları algılandığında işletim sistemi sürece bu isteği belirten bir sinyal gönderir.
    </member>
    <member>
     Bir alt sürecin sonlanması.
    </member>
    <member>
     Alarm veya zamanlayıcının zaman aşımına uğraması.
    </member>
    <member>
     Aynı süreç tarafından yapılan bir <function>kill</function> veya <function>raise</function> çağrısı.
    </member>
    <member>
     Başka bir süreç tarafından yapılan bir <function>kill</function> çağrısı; sinyallerin süreçler arası iletişim için sınırlı ama kullanışlı biçimidir.
    </member>
    <member>
     Yapılamayacak bir G/Ç işleminin yapılmaya çalışılması. Örneğin, bir ucuna yazma yapılmayan bir ardışık süreç akımını okumaya çalışmak (bkz, <xref linkend="glibc-Pipes-and-FIFOs"/>), bazı durumlarda bir uçbirime yazmaya ya da okumaya çalışmak (bkz, <xref linkend="glibc-Job-Control"/>).
    </member>
   </simplelist>
   <para>
    Bu olayların her biri (açıkça yapılan <function>kill</function> ve <function>raise</function> çağrıları dışında) kendine özel bir sinyal üretir. Sinyal çeşitleri <xref linkend="glibc-Standard-Signals"/> bölümünde listelenmiş ve açıklanmıştır.
   </para>
  </sect1>
  <sect1 xml:id="glibc-Signal-Generation">
   <title>Sinyal Üretimi İle İlgili Kavramlar</title>
   <titleabbrev>Sinyaller niçin ve nasıl oluşur.</titleabbrev>
   <para>
    <indexterm linkend="glibc-cp"><primary>sinyallerin üretimi</primary></indexterm>
    Genellikle, sinyalleri üreten olaylar üç ana sınıf altında incelenir: hatalar, dış olaylar, doğrudan yapılan istekler.
   </para>
   <para>
    Bir hata, bir uygulamanın bazı şeyleri yanlış yaptığını ve çalışmasını sürdüremeyeceği bir durumu anlatır. Fakat, hata çeşitlerinin hepsi sinyal üretmez (aslında bu çoğu için geçerlidir). Örneğin, mevcut olmayan bir dosya bir hatadır ama bir sinyal üretmez, sadece <function>open</function> işlevi <code>-1</code> ile döner. Genelde hatalar kütüphane işlevleri ile ilişkilidir ve işlevler bir hata oluştuğunda hatayı bir değerle raporlarlar. Sinyalleri ortaya çıkaran hatalar sadece kütüphane çağrılarında değil yazılımda herhangi bir yerde oluşabilir. Bunlar sıfırla bölme, geçersiz bir bellek adresi olabilir.
   </para>
   <para>
    Bir dış olay genelde G/Ç işlemleri ya da başka süreçlerle ilgilidir. Bunlar, bir girdinin alınması, bir zamanlayıcının zaman aşımına uğraması ve bir alt sürecin sonlanması olabilir.
   </para>
   <para>
    Doğrudan yapılan istekler, amacı özellikle sinyal üretmek olan <function>kill</function> gibi bir kütüphane işlevinin kullanılmasıyla yapılır.
   </para>
   <para>
    Sinyaller <emphasis>eşzamanlı olarak</emphasis> ya da <emphasis>herhangi bir anda</emphasis> üretilebilir. Bir eşzamanlı sinyal, yazılım içindeki belirli bir eylemle ilişkilidir ve (engellenmedikçe)  bu eylem sırasında oluşur. Çoğu hatalar sinyalleri eşzamanlı üretir, öyle ki, kendisi için sinyal üretecek bir süreç kimi zaman bunu bilinçli olarak yapar. Bazı makinelerde belli birtakım donanım hataları (genellikle gerçek sayılarla ilgili olağan dışılıklar) tamamen eşzamanlı üretilir, fakat ardından birkaç makine komutunun da gelmesi gerekir.
   </para>
   <para>
    Herhangi bir anda üretilen sinyaller onları alan sürecin denetimi dışındaki olaylardan kaynaklanır. Bu sinyaller icra sırasında hiç umulmadık zamanlarda gelir. Harici olaylar sinyalleri eşzamansız olarak üretir ve diğer süreçlere yapılacak istekler için kullanılır.
   </para>
   <para>
    Bir sinyal ya özellikle eşzamanlı ya da özellikle eşzamansızdır. Örneğin, hatalar için gönderilen sinyaller özellikle eşzamanlıdır, çünkü hatalar sinyalleri eşzamanlı üretir. Ancak ister eşzamanlı olsun ister eşzamansız, sinyaller açıkça bir isteğin sonucu olarak üretilir.
   </para>
  </sect1>
  <sect1 xml:id="glibc-Delivery-of-Signal">
   <title>Sinyallerin Gönderilmesi</title>
   <titleabbrev>Bir sinyalin bir sürece etkileri.</titleabbrev>
   <para>
    <indexterm linkend="glibc-cp"><primary>sinyaller</primary><secondary>alınması</secondary></indexterm>
    <indexterm linkend="glibc-cp"><primary>sinyaller</primary><secondary>askıda kalma</secondary></indexterm>
    <indexterm linkend="glibc-cp"><primary>sinyaller</primary><secondary>engelleme</secondary></indexterm>
    Bir sinyal üretidiğinde <emphasis>beklemeye</emphasis> alınır. Normalde kısa bir süre için beklemede kaldıktan sonra sinyalleyeceği sürece gönderilir. Eğer sinyal engellenen türde ise sonsuza kadar--sinyal engellenemeyecek duruma gelinceye kadar--beklemede kalır. Sinyalin engellenemeyeceği durum oluştuğunda anında gönderilir. Bkz. <xref linkend="glibc-Blocking-Signals"/>.
   </para>
   <para>
    <indexterm linkend="glibc-cp"><primary>sinyaller</primary><secondary>belirtilen eylem</secondary></indexterm>
    <indexterm linkend="glibc-cp"><primary>sinyaller</primary><secondary>varsayılan eylem</secondary></indexterm>
    <indexterm linkend="glibc-cp"><primary>sinyal eylemi</primary></indexterm>
    <indexterm linkend="glibc-cp"><primary>sinyallerin yakalanması</primary></indexterm>
    Bir sinyal gönderildiğinde, hemen ya da uzun bir beklemenin ardından bu sinyal için belirlenmiş eylem alınır. <varname>SIGKILL</varname> ve <varname>SIGSTOP</varname> gibi sinyaller için eylem bellidir, ama diğer sinyaller için yazılım bazı seçimler yapabilir: sinyali yok sayabilir, bir <emphasis>sinyalle tetiklenen işlev</emphasis> belirtebilir ya da bu sinyal için geçerli olan <emphasis>varsayılan eylem</emphasis>i kabul eder. Yazılım seçimini <function>signal</function> veya <function>sigaction</function> gibi bir işlev ile belirtir (bkz, <xref linkend="glibc-Signal-Actions"/>). Sinyalle tetiklenen işlevlerden belge içinde kimi zaman <wordasword>sinyal işleyici</wordasword> kimi zaman da <wordasword>işleyici işlev</wordasword> olarak bahsedilecektir. Bu işlev çalışırken buna ilişkin sinyal engellenir.
   </para>
   <para>
    Bir sinyal için belirlenmiş eylem onun yok sayılması ise, böyle bir sinyal üretildiği anda iptal edilir. Bu, sinyal zamanında engellendiğinde de böyle olur. Bu yolla iptal edilmiş bir sinyal asla gönderilmez; yazılımda hemen ardından böyle bir sinyal için farklı bir eylem belirtilse hatta engellenmeyeceği belirtilse bile.
   </para>
   <para>
    Yazılım, bir sinyali ne işleme sokacağını ne de yok sayacağını belirtmemişse bu sinyal geldiğinde, sinyalin <emphasis>varsayılan eylem</emphasis>ini almış olur. Her sinyal türü kendine özgü bir varsayılan eyleme sahiptir. Bunlar <xref linkend="glibc-Standard-Signals"/> bölümünde açıklanmıştır. Sinyallerin çoğu için varsayılan eylem sürecin sonlandırılmasıdır.  "Zararsız" olaylar için gönderilen sinyaller için varsayılan eylem ise hiçbir şey yapılmamasıdır.
   </para>
   <para>
    Bir sinyal bir süreci sonlandırdığında, onu çalıştıran süreç, sonlanma sebebini <function>wait</function> veya <function>waitpid</function> işlevlerini kullanarak, bu işlevlerden dönen sonlanma durum koduna bakarak saptayabilir. (Bu <xref linkend="glibc-Process-Completion"/> bölümünde ayrıntılı olarak açıklanmıştır.) Alınan bilgi, sonlanmaya bir sinyalin mi sebep olduğunu ve ne çeşit sinyal alındığını içerir.
   </para>
   <para>
    Normalde yazılım hatalarını gösteren sinyaller özel bir niteliğe sahiptir: bu sinyallerden biri süreci sonlandırdığında, sonlanma sırasında sürecin durumunu gösteren <filename>core</filename> isimli bir döküm dosyası çıktılanır. Bu dosya bir hata ayıklayıcı ile incelenip hatanın sebebi saptanabilir.
   </para>
   <para>
    Yazılımınızın oluşturduğu bir "yazılım hatası"nın sonucu olarak bir sinyal alınıp bunun sonucu olarak süreç sonlandığında tıpkı bir hatanın sonucunda olduğu gibi <filename>core</filename> dosyası çıktılanır.
   </para>
  </sect1>
 </chapter>
 <chapter xml:id="glibc-Standard-Signals">
  <title>Standart Sinyaller</title>
  <titleabbrev>İsimleri ve eylemleri standartlaştırılmış sinyaller.</titleabbrev>
  <preliminary>
   <para>
    <indexterm linkend="glibc-cp"><primary>sinyaller</primary><secondary>isimleri</secondary></indexterm>
    <indexterm linkend="glibc-pg"><primary>signal.h</primary></indexterm>
    <indexterm linkend="glibc-cp"><primary>sinyaller</primary><secondary>numaraları</secondary></indexterm>
    Bu bölümde standart sinyallerin isimleri ve bu sinyallerin hangi olayların karşılığı olduğu açıklanmaktadır. Her sinyal ismi kendini bir <wordasword>sinyal numarası</wordasword> ile ilişkilendiren bir makrodur. Burada dikkat edilmesi gereken nokta; yazılımın bir sinyali bir numara olarak kabul etmeyip daima burada tanımlanmış isimleri kullanması gerektiğidir. Çünkü, isimlerin anlamları standarttır ama numaraları sistemden sisteme değişiklik gösterebilir.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-NSIG"><primary>NSIG</primary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>NSIG</function></csname>
    </csproto>
    <header>&signal.h;</header>
    <para>
     Bu simgesel sabitin değeri tanımlı sinyallerin toplam sayısıdır. Sinyaller artan numaralar aldıklarından <code>NSIG</code> en büyük numaralı sinyalin numarasıdır.
    </para>
   </csynopsis>
   <para>
    Bu bölümdeki sinyal isimleri &signal.h; başlık dosyasında tanımlanmıştır.
   </para>
  </preliminary>
  <sect1 xml:id="glibc-Program-Error-Signals">
   <title>Yazılım Hatalarının Sinyalleri</title>
   <titleabbrev>Yazılımdaki hataları bildiren sinyaller.</titleabbrev>
   <para>
    <indexterm linkend="glibc-cp"><primary>sinyaller</primary><secondary>yazılım hatalarını raporlayanlar</secondary></indexterm>
    Aşağıdaki sinyaller, bilgisayarın kendi ya da işletim sistemi tarafından ciddi bir yazılım hatası saptandığında üretilir. Genelde bu sinyallerin tümü yazılımın bir şeyleri önemli ölçüde bozacağı ya da sistemin bütünü açısından yazılımın çalışmasının sorun olacağı durumları belirtir.
   </para>
   <para>
    Bazı yazılımlar yazılım hatası sinyallerini sonlanmadan önceki düzenlemeler sırasında işleme sokar; örneğin, uçbirim girdisinin yansılamasını kapatan bir yazılım yansılamayı tekrar açacağı sırada yazılım hatasını işleme sokmalıdır. Sinyalin işlenmesi, varsayılan eylemin bitirilmesinin ardından bu sinyalin tekrar yayınlanması şeklinde yapılır.  Bu, yazılımın bir sinyal işleyici yokmuşçasına bu sinyalle sonlanmasını sağlayacaktır. (Bkz. <xref linkend="glibc-Termination-in-Handler"/>.)
   </para>
   <para>
    Sonlanma, çoğu yazılım için bir yazılım hatasının nihai sonucudur. Buna rağmen Lisp gibi bazı yazılım geliştirme sistemleri bir hataya maruz kalsa bile derlenmiş kullanıcı yazılımını çalışır halde tutabilir. Bu sistemler denetimi komut seviyesine döndürmek için <function>longjmp</function> kullanan sinyal işleyicilere sahiptir.
   </para>
   <para>
    Bu sinyallerin tümü için varsayılan eylem sürecin sonlandırılmasına sebep olmaktır. Bir gerçek hata yerine <function>raise</function> veya <function>kill</function> tarafından üretilmedikçe oluşan sinyaller engellenir, yok sayılır ya da bir sinyal işleyici kurulup normale çevrilirse, büyük olasılıkla yazılım dehşet verici şekilde bozulacaktır.
   </para>
   <para>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-COREFILE"><primary>COREFILE</primary></indexterm>
    Bu yazılım hatası sinyalleri bir süreci sonlandırırken, sonlanma sırasında sürecin durum kaydı olarak o an içinde bulunulan dizine <filename>core</filename> isimli bir dosya halinde bellek dökümü çıktılar. (GNU sistemlerinde dosyanın ismi kullanıcı tarafından <command>COREFILE</command> ortam değişkeni ile belirtilebilir.) Bu dosyanın çıktılanmasının amacı, dosyanın bir hata ayıklayıcı ile incelenerek hatanın sebebinin bulunmasını sağlamaktır.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-SIGFPE"><primary>sinyaller</primary><secondary>ölümcül aritmetik hata</secondary></indexterm>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-SIGFPE"><primary>SIGFPE</primary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>SIGFPE</function></csname>
    </csproto>
    <header>&signal.h;</header>
    <para>
     <code>SIGFPE</code> sinyali ölümcül aritmetik hatalardan birini raporlar. Hatanın ismi "floating-point exception" kısaltması olsa da sinyal aslında sıfırla bölme ve taşma dahil tüm aritmetik hataları kapsar. Eğer bir yazılım, tamsayı veri sakladığı bir alanı daha sonra bir gerçek sayı işleminde kullanmaya çalışırsa bu, "geçersiz işlem" istisnasına sebep olur, çünkü işlemci veriyi bir gerçek sayı olarak ele alamaz.
    </para>
    <para>
     Aslında gerçek sayı istisnaları oldukça karmaşık bir konudur, çünkü çok farklı anlamlara gelen çözümü zor çok çeşitli istisnalar vardır ve <code>SIGFPE</code> sinyali onları ayıramaz. İkil Kayan Noktalı Aritmetik için IEEE standardında (ANSI/IEEE Std 754-1985 and ANSI/IEEE Std 854-1987) çeşitli istisnalar tanımlanmıştır ve oluşumlarını bildirmek için uygun bilgisayar sistemlerini gerektirir.  Ancak, bu standart istisnaların nasıl bildirileceğini ya da işletim sisteminin yazılımcıya ne çeşit bir işleme ve denetim imkanı vereceğini belirtmez.
    </para>
    <para>
     BSD sistemleri <code>SIGFPE</code> makrosunun yanında istisnanın çeşitli sebeplerini ayrımsamak için ek bir bağımsız değişken sağlar. Bu bağımsız değişkene erişim sırasında, sinyal işleyicinin iki bağımsız değişken kabul edecek şekilde tanımlanması gerekir. İşleyici kurulurken de tek bağımsız değişkenli işlev türüne dönüştürülmelidir. &glibc; bu ek bağımsız değişkeni sağlar. Ancak bağımsız değişkenin değeri sadece bu bilgiyi sağlayan sistemler (GNU ve BSD) için anlamlıdır.
    </para>
    <csynopsis>
     <indexterm linkend="glibc-cp" xml:id="glibc-cp-FPE_INTOVF_TRAP"><primary>tuzaklar</primary><secondary>tamsayı taşması</secondary></indexterm>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-FPE_INTOVF_TRAP"><primary>FPE_INTOVF_TRAP</primary></indexterm>
     <csproto type="sabit">
      <csname><function>FPE_INTOVF_TRAP</function></csname>
     </csproto>
     <para>
      Tamsayı taşması tuzağı (C yazılımlarında donanıma özel biçimde taşma tuzağı etkinleştirilmedikçe imkansızdır).
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-cp" xml:id="glibc-cp-FPE_INTDIV_TRAP"><primary>tuzaklar</primary><secondary>sıfırla tamsayı bölme</secondary></indexterm>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-FPE_INTDIV_TRAP"><primary>FPE_INTDIV_TRAP</primary></indexterm>
     <csproto type="sabit">
      <csname><function>FPE_INTDIV_TRAP</function></csname>
     </csproto>
     <para>
      Sıfırla tamsayı bölme tuzağı.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-cp" xml:id="glibc-cp-FPE_SUBRNG_TRAP"><primary>tuzaklar</primary><secondary>indisleme aralığı</secondary></indexterm>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-FPE_SUBRNG_TRAP"><primary>FPE_SUBRNG_TRAP</primary></indexterm>
     <csproto type="sabit">
      <csname><function>FPE_SUBRNG_TRAP</function></csname>
     </csproto>
     <para>
      İndisleme aralığı tuzağı (C yazılımlarında bazı şeyler hiç denetlenmez).
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-cp" xml:id="glibc-cp-FPE_FLTOVF_TRAP"><primary>tuzaklar</primary><secondary>Gerçek sayı taşması</secondary></indexterm>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-FPE_FLTOVF_TRAP"><primary>FPE_FLTOVF_TRAP</primary></indexterm>
     <csproto type="sabit">
      <csname><function>FPE_FLTOVF_TRAP</function></csname>
     </csproto>
     <para>
      Gerçek sayı taşması tuzağı.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-cp" xml:id="glibc-cp-FPE_FLTDIV_TRAP"><primary>tuzaklar</primary><secondary>gerçek/tam sayılarda sıfırla bölme</secondary></indexterm>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-FPE_FLTDIV_TRAP"><primary>FPE_FLTDIV_TRAP</primary></indexterm>
     <csproto type="sabit">
      <csname><function>FPE_FLTDIV_TRAP</function></csname>
     </csproto>
     <para>
      Gerçek/tam sayılarda sıfırla bölme tuzağı.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-cp" xml:id="glibc-cp-FPE_FLTUND_TRAP"><primary>tuzaklar</primary><secondary>gerçek sayılarda alttan taşma</secondary></indexterm>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-FPE_FLTUND_TRAP"><primary>FPE_FLTUND_TRAP</primary></indexterm>
     <csproto type="sabit">
      <csname><function>FPE_FLTUND_TRAP</function></csname>
     </csproto>
     <para>
      Gerçek sayılarda alttan taşma tuzağı (Normalde etkin değildir).
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-cp" xml:id="glibc-cp-FPE_DECOVF_TRAP"><primary>tuzaklar</primary><secondary>ondalık taşma</secondary></indexterm>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-FPE_DECOVF_TRAP"><primary>FPE_DECOVF_TRAP</primary></indexterm>
     <csproto type="sabit">
      <csname><function>FPE_DECOVF_TRAP</function></csname>
     </csproto>
     <para>
      Ondalık taşma tuzağı (Sadece birkaç makine ondalık aritmetiğe sahiptir, C hiç kullanmaz).
     </para>
    </csynopsis>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-SIGILL"><primary>SIGILL</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-SIGILL"><primary>sinyaller</primary><secondary>kuraldışı komut</secondary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>SIGILL</function></csname>
    </csproto>
    <header>&signal.h;</header>
    <para>
     Sinyalin ismi "illegal instruction" sözcüklerinden türetilmiştir; yazılımın bozuk ya da ayrıcalıklı bir işlemci komutunu çalıştırmayı denediğini belirtir. C derleyicileri sadece geçerli işlemci komutları ürettiğinden <code>SIGILL</code> sinyali genellikle çalıştırılabilir dosyanın zarar görmüş olabileceğini ya da çalıştırılabilir olmayan bir kodun çalıştırmasının denendiğini belirtir. İkinci durumun ortaya çıktığı çok bilinen durumlar şunlardır: bir işlev olarak ele alınacağı umulan bir göstericiyle geçersiz bir nesnenin aktarılması; bir özdevinimli dizinin sonundan sonrasına yazma denemesi (benzer durum özdevinimli değişkenlere göstericilerde de ortaya çıkabilir); yığıt üzerinde, yığıt çerçevesine dönüş adresi gibi birtakım verilerin bozulması.
    </para>
    <para>
     <code>SIGILL</code> sinyali bunlardan başka, yığıt taşmalarında ya da sistemde çalışan sorunlu bir sinyal işleyicinin varlığında da üretilebilir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-SIGSEGV"><primary>SIGSEGV</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-SIGSEGV"><primary>sinyaller</primary><secondary>parçalama arızası</secondary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>SIGSEGV</function></csname>
    </csproto>
    <header>&signal.h;</header>
    <para>
     Bu sinyal, bir yazılımın kendine ayrılan bellek bölgesinin dışında okuma veya yazma denemesi yaptığında ya da salt okunur belleğe yazmaya çalıştığında oluşur. (Aslında bu sinyal sadece sistemin bellek koruma düzeneği tarafından saptanabilen, yazılımın kendi alanının dışında çok uzak bölgelere yazmaya çalıştığı durumlarda ortaya çıkar.) Sinyalin ismi "segmentation violation" sözcüklerinden türetilmiştir.
    </para>
    <para>
     <code>SIGSEGV</code> sinyalinin alındığı bilinen sorunlar: göstericinin boş ya da ilklendirilmemiş göstericiye dönüştürülmesi (dereferencing - dizi olmayan bir değişkenin göstericisi üzerinde gösterici aritmetiği uygulanması ya da ilklendirilmemiş bir yapı elemanını göstermek için -> işleci ile sol taraf değeri olarak kullanılması); bir dizinin sonunu saptamadan dizi üzerinde gösterici aritmetiği ile işlem yapılması.  Bir göstericinin boş göstericiye dönüşmesi durumunu çeşitli sistemler <code>SIGSEGV</code> ya da <varname>SIGBUS</varname> sinyali ile belirtir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-SIGBUS"><primary>SIGBUS</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-SIGBUS"><primary>sinyaller</primary><secondary>geçersiz adrese erişim</secondary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>SIGBUS</function></csname>
    </csproto>
    <header>&signal.h;</header>
    <para>
     Bu sinyal geçersiz duruma gelmiş göstericiler kullanılmaya çalışıldığında ortaya çıkar. <varname>SIGSEGV</varname> sinyalindeki gibi bu sinyalde geçersiz bir gösterici kullanımıyla ilgili olarak üretilir. İkisi arasındaki fark, <varname>SIGSEGV</varname> sinyalinin geçerli belleğe geçersiz erişimi belirtmesi, <code>SIGBUS</code> sinyalinin ise geçersiz bir adrese erişimi belirtmesidir. Kimi zaman <code>SIGBUS</code> sinyali göstericinin hatalı hizalama ile kullanıldığı durumlarda da üretilir; örneğin dört sözcüklük bir tamsayı değerinin saklandığı adreste alanın dörde bölünememesi gibi (her bilgisayarın kendine özgü adres hizalaması vardır).
    </para>
    <para>
     Sinyalin ismi "bus error" sözcüklerinden türetilmiştir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-SIGABRT"><primary>SIGABRT</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-SIGABRT"><primary>sinyaller</primary><secondary>yazılım hatasında çıkış</secondary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>SIGABRT</function></csname>
    </csproto>
    <header>&signal.h;</header>
    <para>
     Bu sinyal yazılımın kendisi tarafından saptanan bir hatayı belirtir ve <function>abort</function> çağrısı ile raporlanır. Bkz, <xref linkend="glibc-Aborting-a-Program"/>
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-SIGIOT"><primary>SIGIOT</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-SIGIOT"><primary>sinyaller</primary><secondary>yazılım hatasında çıkış</secondary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>SIGIOT</function></csname>
    </csproto>
    <header>&signal.h;</header>
    <para>
     PDP-11 "iot" komutu tarafından üretilir.  Çoğu makinede, <varname>SIGABRT</varname> sinyali olarak yer alır.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-SIGTRAP"><primary>SIGTRAP</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-SIGTRAP"><primary>sinyaller</primary><secondary>hatalı işlemci komutu</secondary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>SIGTRAP</function></csname>
    </csproto>
    <header>&signal.h;</header>
    <para>
     Makinenin "breakpoint" komutu ve bazı diğer yakalama komutları tarafından üretilir. Bu sinyal hata ayıklayıcılar tarafından kullanılır. Yazılım büyük ihtimalle sadece bazı hatalı işlemci komutlarından dolayı  <code>SIGTRAP</code> sinyalini görecektir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-SIGEMT"><primary>SIGEMT</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-SIGEMT"><primary>sinyaller</primary><secondary>öykünme tuzağı</secondary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>SIGEMT</function></csname>
    </csproto>
    <header>&signal.h;</header>
    <para>
     Öykünme tuzağı; bu sinyal henüz gerçeklenmemiş ama yazılım tarafından taklit edilen makine komutlarından ya da onların olması gerektiği gibi taklit edilememesinden dolayı işletim sistemi tarafından üretilir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-SIGSYS"><primary>SIGSYS</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-SIGSYS"><primary>sinyaller</primary><secondary>Hatalı sistem çağrısı</secondary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>SIGSYS</function></csname>
    </csproto>
    <header>&signal.h;</header>
    <para>
     Hatalı sistem çağrısı; İşletim sisteminden çalıştırılması istenen ancak çağrı için belirtilen kod numarası işlemci komutlarında geçersiz olan çağrılarda üretilir.
    </para>
   </csynopsis>
  </sect1>
  <sect1 xml:id="glibc-Termination-Signals">
   <title>Sonlandırma Sinyalleri</title>
   <titleabbrev>Bir yazılımı durduran ya da sonlandıran sinyaller.</titleabbrev>
   <para>
    <indexterm linkend="glibc-cp"><primary>sinyaller</primary><secondary>süreci sonlandıran</secondary></indexterm>
    <indexterm linkend="glibc-cp"><primary>süreçler</primary><secondary>sonlandırma sinyali</secondary></indexterm>
    Bu sinyaller bir sürece şu veya bu şekilde sonlandırılacağını söyler. Genel olarak, tüm bu sinyaller, yazılımın bir şekilde ciddi şekilde bozulduğunun göstergeleridir ve genellikle hataya sebep olan hesaplamaya devam etmenin bir yolu yoktur.
   </para>
   <para>
    Bu sinyallerin işlenme sebebi yazılımın gerçek sonlandırmayı yapmadan önce bazı hazırlıklar yapmasına imkan vermektir. Örneğin, yazılımı sonlandırmadan önce son duruma ilişkin bilgileri bir yerlere kaydetmek, geçici dosyaları silmek, önceki uçbirim kipine dönmek gibi işlemler yapılmak istenebilir. Bunu yapmak için önce sinyali engellemek, bu işlemleri yaptıktan sonra asıl sonlandırmayı gerçekleştirmek için sinyali tekrar üretmek gerekir. Bu işlem, yazılımın sinyali işleyemiyormuş gibi yaparak sonlanmasını sağlar. (Bkz, <xref linkend="glibc-Termination-in-Handler"/>.)
   </para>
   <para>
    Bu sinyaller için varsayılan eylem sürecin sonlanmasına sebep olmaktır.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-SIGTERM"><primary>SIGTERM</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-SIGTERM"><primary>sinyaller</primary><secondary>sonlandırma sinyali</secondary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>SIGTERM</function></csname>
    </csproto>
    <header>&signal.h;</header>
    <para>
     <code>SIGTERM</code> sinyali yazılımın sonlanmasına sebep olan en temel sinyallerden biridir. <varname>SIGKILL</varname> sinyalinin tersine bu sinyal engellenebilir, işleme sokulabilir ya da yok sayılabilir. Normal yöntem yazılımı sonlandırmadan önce isteği kullanıcıya doğrulatmaktır.
    </para>
    <para>
     <uri xl:href="man1-kill"/> kabuk komutu sinyal belirtilmezse <code>SIGTERM</code> sinyali üretir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-SIGINT"><primary>SIGINT</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-SIGINT"><primary>sinyaller</primary><secondary>engellenemeyen sonlandırma sinyali</secondary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>SIGINT</function></csname>
    </csproto>
    <header>&signal.h;</header>
    <para>
     <code>SIGINT</code> ("program interrupt" sözcüklerinden türetilmiştir) sinyali, kullanıcı tarafından <varname>INTR</varname> karakteri (normalde <keycap>C-c</keycap> tuşları) tuşlandığında üretilir. <keycap>C-c</keycap> sürücü desteği hakkında daha fazla bilgi için bkz, <xref linkend="glibc-Special-Characters"/>.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-SIGQUIT"><primary>SIGQUIT</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-SIGQUIT"><primary>sinyaller</primary><secondary>çıkış sinyali</secondary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>SIGQUIT</function></csname>
    </csproto>
    <header>&signal.h;</header>
    <para>
     <code>SIGQUIT</code> sinyali <varname>QUIT</varname> karakteri ile (normalde <keycap>C-\</keycap>) üretilmesi dışında <varname>SIGINT</varname> sinyali gibidir. Süreci sonlandırırken bir yazılım hatası sinyalinin yaptığı gibi son bellek dökümü olarak <filename>core</filename> dosyası çıktılar. Bu, kullanıcı tarafından "saptanan" bir hata durumu olarak düşünülebilir.
    </para>
    <para>
     Hata durumundaki bellek dökümleri hakkında daha fazla bilgi için bkz, <xref linkend="glibc-Program-Error-Signals"/>. Uçbirim sürücüsü desteği ile ilgili olarak bkz, <xref linkend="glibc-Special-Characters"/>.
    </para>
    <para>
     Bazı temizlik işlemleri yapmadan çıkmanın en iyi yolu <code>SIGQUIT</code> sinyalinin elde edilmesidir. Örneğin yazılımınız geçici dosyalar oluşturuyorsa ve diğer sonlandırma isteklerinde bu dosyaları siliyorsa onların silinmemesi için <code>SIGQUIT</code> sinyalini ürettirmek daha iyidir. Böylece bellek dökümü yanında bu geçici dosyalara da bakarak bir şeyler daha iyi saptanabilir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-SIGKILL"><primary>SIGKILL</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-SIGKILL"><primary>sinyaller</primary><secondary>öldürme sinyali</secondary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>SIGKILL</function></csname>
    </csproto>
    <header>&signal.h;</header>
    <para>
     <code>SIGKILL</code> sinyali bir uygulamanın anında sonlandırılmasında kullanılır. Bu sinyal engellenemez ve yok sayılamaz.
    </para>
    <para>
     Bu sinyal genellikle açıkça bir isteğin sonucunda üretilir. Yakalanamadığından <keycap>C-c</keycap> veya <varname>SIGTERM</varname> denendikten sonra sadece son çare olarak üretilmelidir. Eğer süreç başka herhangi bir sonlandırma sinyaline yanıt vermezse, bir <code>SIGKILL</code> sinyali gönderilerek hemen hemen daima sonlanması sağlanabilir.
    </para>
    <para>
     Ancak, eğer <code>SIGKILL</code> sinyali bir süreci sonlandıramazsa, bu bir işletim sistemi hatasıdır ve mutlaka geri bildirilmelidir.
    </para>
    <para>
     Ayrıca, bir sürecin çalışmasını sürdürmesinin imkansız olduğu durumlarda da süreç bir sinyal işleyici kullanıyor olsa bile sistem <code>SIGKILL</code> sinyali göndererek bu süreci sonlandırabilir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-SIGHUP"><primary>SIGHUP</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-SIGHUP"><primary>sinyaller</primary><secondary>hat kesildi</secondary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>SIGHUP</function></csname>
    </csproto>
    <header>&signal.h;</header>
    <para>
     <code>SIGHUP</code>  ("hang-up" sözcüklerinden türetilmiştir) sinyali kullanıcının uçbiriminin bağlantısı kesildiğinde durumu bildirmek için üretilir. Bu genellikle bir ağ ya da telefon bağlantısı kesildiğinde olur. Bu durumla ilgili daha fazla bilgi için bkz, <xref linkend="glibc-Control-Modes"/>.
    </para>
    <para>
     Bu sinyal ayrıca, bir uçbirim üzerinde o oturuma ilişkin bazı işleri yürüten bir sürecin sonlandırılmasında da kullanılır; bu sonlandırma oturumdaki tüm süreçlerin çalıştırıldığı uçbirimle bağlantısının kopmasına yol açar. Daha fazla bilgi için bkz, <xref linkend="glibc-Termination-Internals"/>.
    </para>
   </csynopsis>
  </sect1>
  <sect1 xml:id="glibc-Alarm-Signals">
   <title>Alarm Sinyalleri</title>
   <titleabbrev>Zamanlayıcıların zaman aşımına uğraması.</titleabbrev>
   <para>
    Bu sinyaller zamanlayıcıların zaman aşımına uğradığını bildirmekte kullanılır. Bu sinyallerin gönderilmesine sebep olan işlevler <xref linkend="glibc-Setting-an-Alarm"/> bölümünde bulunabilir.
   </para>
   <para>
    Bu sinyallerin varsayılan davranışı o sürecin sonlandırılmasına sebep olmasıdır. Bu varsayılan davranış geniş çapta kullanışlıdır; ancak, bu sinyallerin kullanıldığı yöntemler her durumda bir işleyici işlev kullanımını gerekli kılar.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-SIGALRM"><primary>SIGALRM</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-SIGALRM"><primary>sinyaller</primary><secondary>gerçek süreli alarm sinyali</secondary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>SIGALRM</function></csname>
    </csproto>
    <header>&signal.h;</header>
    <para>
     Bu sinyal özellikle bir zamanlayıcının gerçek ya da saat tikleri cinsinden ölçülen değeri için saptanan sınırın aşıldığını belirtir. Örneğin, <function>alarm</function> işlevi ile üretilir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-SIGVTALRM"><primary>SIGVTALRM</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-SIGVTALRM"><primary>sinyaller</primary><secondary>sanal süreli alarm sinyali</secondary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>SIGVTALRM</function></csname>
    </csproto>
    <header>&signal.h;</header>
    <para>
     Bu sinyal, özellikle süreç tarafından kullanılan işlemci zamanı cinsinden zamanlayıcı değerinin zaman aşımına uğradığını belirtir. "virtual time alarm" sözcüklerinden türetilmiştir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-SIGPROF"><primary>SIGPROF</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-SIGPROF"><primary>sinyaller</primary><secondary>profil zaman aşımı sinyali</secondary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>SIGPROF</function></csname>
    </csproto>
    <header>&signal.h;</header>
    <para>
     Bu sinyal, özellikle süreç tarafından kullanılan hem işlemci zamanı cinsinden hem de sistem tarafından süreç lehine kullanılan işlemci zamanı cinsinden zamanlayıcı değerinin zaman aşımına uğradığını belirtir. Bu tür zamanlayıcılar kod profili oluşumlarının gerçeklemelerinde kullanılır, zaten sinyalin ismi de buradan gelir.
    </para>
   </csynopsis>
  </sect1>
  <sect1 xml:id="glibc-Asynchronous-I-O-Signals">
   <title>Eşzamansız G/Ç Sinyalleri</title>
   <titleabbrev>Girdi varlığını bildiren sinyaller.</titleabbrev>
   <para>
    Bu bölümde açıklanan sinyaller eşzamansız G/Ç oluşumlarıyla ilgilidir. Bu sinyalleri üretecek dosya tanıtıcılarını etkinleştirecek <function>fcntl</function> çağrısı ile eylem doğrudan elde edilebilir (bkz, <xref linkend="glibc-Interrupt-Input"/>). Bu sinyaller için varsayılan eylem sinyalin yok sayılmasıdır.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-SIGIO"><primary>SIGIO</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-SIGIO"><primary>sinyaller</primary><secondary>g/ç var sinyali</secondary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>SIGIO</function></csname>
    </csproto>
    <header>&signal.h;</header>
    <para>
     Bu sinyal bir dosya tanıtıcı girdi veya çıktı işlemlerini yapmaya hazır olduğunda üretilir.
    </para>
    <para>
     Çoğu işletim sisteminde, <code>SIGIO</code> üretebilen dosya çeşitleri sadece uçbirimler ve soketlerdir. Sıradan dosyalarında dahil olduğu diğer dosya çeşitleri, istense bile <code>SIGIO</code> sinyalini asla üretmez.
    </para>
    <para>
     GNU sistemlerinde <code>SIGIO</code> sinyali daima <function>fcntl</function> işleviyle eşzamansız kipe girildiğinde üretilir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-SIGURG"><primary>SIGURG</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-SIGURG"><primary>sinyaller</primary><secondary>acil veri sinyali</secondary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>SIGURG</function></csname>
    </csproto>
    <header>&signal.h;</header>
    <para>
     Bu sinyal bir soket üzerinden "acil" ya da bantdışı veri geldiğinde üretilir. Bkz, <xref linkend="glibc-Out-of-Band-Data"/>.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-SIGPOLL"><primary>SIGPOLL</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-SIGPOLL"><primary>sinyaller</primary><secondary>g/ç var sinyali (System V)</secondary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>SIGPOLL</function></csname>
    </csproto>
    <header>&signal.h;</header>
    <para>
     Bu bir System V sinyal ismidir, az çok <varname>SIGIO</varname> sinyaline benzer. Sadece uyumluluk için vardır.
    </para>
   </csynopsis>
  </sect1>
  <sect1 xml:id="glibc-Job-Control-Signals">
   <title>İş Denetim Sinyalleri</title>
   <titleabbrev>İş denetimi için kullanılan sinyaller.</titleabbrev>
   <para>
    <indexterm linkend="glibc-cp"><primary>sinyaller</primary><secondary>iş denetim sinyalleri</secondary></indexterm>
    Bu sinyaller iş denetimine destek için kullanılır. Sisteminizde iş denetimi desteği yoksa, bu makrolar tanımlanmış bile olsa, sinyaller üretilemez ve yakalanamaz.
   </para>
   <para>
    İş denetiminin nasıl çalıştığı hakkında daha fazla bilgi için bkz, <xref linkend="glibc-Job-Control"/>.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-SIGCHLD"><primary>SIGCHLD</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-SIGCHLD"><primary>sinyaller</primary><secondary>alt süreç sinyali</secondary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>SIGCHLD</function></csname>
    </csproto>
    <header>&signal.h;</header>
    <para>
     Bu sinyal, alt süreç çalıştıran sürece alt süreç durdurulduğunda ya da sonlandırıldığında gönderilir.
    </para>
    <para>
     Bu sinyal için varsayılan eylem yok sayılmaktır. Sonlandırılmış alt süreçlerin olduğu ancak bunların durumlarının <function>wait</function> veya <function>waitpid</function> ile bildirilmediği durumlar için (bkz, <xref linkend="glibc-Process-Completion"/>) ya da bir işletim sistemine bağımlı olmamak için bu sinyal için bir işleyici oluşturulabilir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-SIGCLD"><primary>SIGCLD</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-SIGCLD"><primary>sinyaller</primary><secondary>alt süreç sinyali (eskisi)</secondary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>SIGCLD</function></csname>
    </csproto>
    <header>&signal.h;</header>
    <para>
     <varname>SIGCHLD</varname> için artık kullanılmayan sinyal ismidir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-SIGCONT"><primary>SIGCONT</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-SIGCONT"><primary>sinyaller</primary><secondary>devam sinyali</secondary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>SIGCONT</function></csname>
    </csproto>
    <header>&signal.h;</header>
    <para>
     <code>SIGCONT</code> sinyali, bir sürecin devam etmesini istemek için üretilebilir. Bu sinyal alınmadan önce durmuş olan bir sürecin çalışmasını sürdürmesi istendiğinde gönderilir. Ön tanımlı davranış başka bir şey yapılmamasıdır. Bu sinyal engellenemez. Bir işleyici belirtilse bile <code>SIGCONT</code> sürecin çalışmaya devam etmesini sağlar.
    </para>
    <para>
     Çoğu yazılım için <code>SIGCONT</code> sinyalini yakalamanın bir anlamı yoktur; yazılım basitçe hiç durdurulmamış gibi çalışmaya kaldığı yerden devam edecektir. Bu sinyal için bir işleyici sadece durdurulduktan sonra çalıştırldığında yazılıma özel bazı işlemler yapılması gerekiyorsa anlamlıdır. Örneğin, durdurma öncesi uçbirim çıktılaması kapalıyken açıldıysa, çalışmaya devam edilirken bunun tekrar kapatılması istenebilir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-SIGSTOP"><primary>SIGSTOP</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-SIGSTOP"><primary>sinyaller</primary><secondary>durdurma sinyali</secondary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>SIGSTOP</function></csname>
    </csproto>
    <header>&signal.h;</header>
    <para>
     <code>SIGSTOP</code> sinyali süreci durdurur. Yakalanamaz, engellenemez, yok sayılamaz.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-SIGTSTP"><primary>SIGTSTP</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-SIGTSTP"><primary>sinyaller</primary><secondary>etkileşimli durdurma sinyali</secondary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>SIGTSTP</function></csname>
    </csproto>
    <header>&signal.h;</header>
    <para>
     <code>SIGTSTP</code> sinyali bir etkileşimli durdurma sinyalidir. <varname>SIGSTOP</varname> sinyalinin aksine yakalanabilir ve yok sayılabilir.
    </para>
    <para>
     Bu sinyalle bir durdurma isteği geldiğinde dosyaların ve sistem tablolarının güvenli durumda bırakılmak istenmesi durumunda bu sinyal için bir işleyici oluşturulmalıdır. Örneğin uçbirimde çıktılama kapatılmışsa, durdurma sırasında bunu açmak gerekir.
    </para>
    <para>
     Bu sinyal kullanıcı tarafından <varname>SUSP</varname> karakteri (normalde <keycap>C-z</keycap>) tuşlandığında üretilir. Uçbirim sürücü desteği ile ilgili daha fazla bilgi için bkz, <xref linkend="glibc-Special-Characters"/>.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-SIGTTIN"><primary>SIGTTIN</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-SIGTTIN"><primary>sinyaller</primary><secondary>uçbirim girdi sinyali</secondary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>SIGTTIN</function></csname>
    </csproto>
    <header>&signal.h;</header>
    <para>
     Bir süreç, artalan işi olarak çalışıyorsa kullanıcı uçbirimini okuyamaz. Bir artalan işindeki herhangi bir süreç uçbirimden okuma yapmak istediğinde işteki tüm süreçlere bir <code>SIGTTIN</code> sinyali gönderilir. Bu sinyal için varsayılan eylem sürecin durdurulmasıdır. Uçbirimle girilen bu etkileşimle ilgili daha fazla bilgi için bkz, <xref linkend="glibc-Access-to-the-Terminal"/>.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-SIGTTOU"><primary>SIGTTOU</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-SIGTTOU"><primary>sinyaller</primary><secondary>uçbirim çıktı sinyali</secondary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>SIGTTOU</function></csname>
    </csproto>
    <header>&signal.h;</header>
    <para>
     <varname>SIGTTIN</varname> sinyaline benzer, farklı olarak artalanda iş içindeki süreç uçbirime yazmaya ya da kipi değiştirmeye çalıştığında üretilir. Burada da varsayılan eylem sürecin durdurulmasıdır. <code>SIGTTOU</code> sinyali sadece <varname>TOSTOP</varname> çıktı kipi belirtilerek uçbirime yazmaya çalışıldığında üretilir; bkz, <xref linkend="glibc-Output-Modes"/>.
    </para>
   </csynopsis>
   <para>
    Bir süreç durdurulduğunda <varname>SIGKILL</varname> ve <varname>SIGCONT</varname> sinyalleri dışında hiçbir sinyali alamaz, süreç devam ettirilene kadar askıya alınır. <varname>SIGKILL</varname>  sinyali daima süreci sonlandırır ve engellenemez, yakalanamaz ve yok sayılamaz. <varname>SIGCONT</varname> sinyali yok sayılabilir ama daima durdurulmuş bir sürecin kaldığı yerden çalışmasına devam etmesini sağlar. Bir sürece <varname>SIGCONT</varname> sinyalinin gönderilmesi askıda bekleyen bir durdurma sinyali varsa iptal edilmesine sebep olur. Benzer şekilde, askıya alınmış bir <varname>SIGCONT</varname> sinyali bir durdurma sinyali alındığında iptal edilir.
   </para>
   <para>
    Bir  <link linkend="glibc-Orphaned-Process-Groups">öksüz süreç grubundaki</link> bir süreç <varname>SIGTSTP</varname>, <varname>SIGTTIN</varname> veya <varname>SIGTTOU</varname> sinyallerinden birini alırsa ve o sinyali yakalamıyorsa, süreç durmaz. Şüphesiz böyle bir sürecin durdurulması pek kullanışlı değildir. Çünkü böyle bir süreci durması için uyaracak bir kabuk ya da devam etmesine izin verecek bir kullanıcı olmayacaktır. Bazı sistemler hiçbir şey yapmayabilir; bazıları da bunun yerine <varname>SIGKILL</varname> veya <varname>SIGHUP</varname> gibi bir sinyal alabilir. GNU/Hurd sistemlerinde süreç <varname>SIGKILL</varname> ile öldürülür; bu, sistemde durmuş ya da öksüz kalmış süreçlerle ilgili sorunları da çözer.
   </para>
  </sect1>
  <sect1 xml:id="glibc-Operation-Error-Signals">
   <title>İşlemsel Hata Sinyalleri</title>
   <titleabbrev>İşlemsel sistem hatalarını raporlayan sinyaller.</titleabbrev>
   <para>
    Bu sinyaller yazılım tarafından yapılan bir işlemin ürettiği çeşitli hataları bildirmekte kullanılır. Bunlar her zaman yazılımdaki bir yazılım geliştirme hatasını belirtmez, bir işletim sistemi çağrısının tamamlanmasına engel olan bir hatayı da belirtebilir. Bunların hepsi için varsayılan eylem sürecin sonlanmasına sebep olmaktır.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-SIGPIPE"><primary>SIGPIPE</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-SIGPIPE"><primary>sinyaller</primary><secondary>ardışık süreç sinyali</secondary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>SIGPIPE</function></csname>
    </csproto>
    <header>&signal.h;</header>
    <para>
     Kırık boru (Broken pipe).  İsimli ya da isimsiz ardışık süreç akımları kullanılıyorsa, yazılımda böyle bir akımın, bir sürecin bir ardışık süreç akımına bir ucundan yazmaya başlamasından önce başka bir sürecin diğer uçtan okumaya başlamasını sağlayacak şekilde tasarlanması zorunludur. Eğer okuyan süreç başlamazsa ya da beklenmedik şekilde sonlanırsa, akıma yazan süreç bir <code>SIGPIPE</code> sinyali üretir. Eğer <code>SIGPIPE</code> engellenir, işleme sokulur ya da yok sayılırsa etkilenen çağrı <varname>EPIPE</varname> ile başarısız olur.
    </para>
    <para>
     İsimli ya da isimsiz ardışık süreçler özel dosyalar olarak gerçeklenmiş ve <xref linkend="glibc-Pipes-and-FIFOs"/> bölümünde ayrıntılı olarak açıklanmıştır.
    </para>
    <para>
     <code>SIGPIPE</code> sinyalinin başka bir sebebi de bağlı olmayan bir sokete yazma denemesidir. Bkz, <xref linkend="glibc-Sending-Data"/>.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-SIGLOST"><primary>SIGLOST</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-SIGLOST"><primary>sinyaller</primary><secondary>kayıp öz kaynak sinyali</secondary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>SIGLOST</function></csname>
    </csproto>
    <header>&signal.h;</header>
    <para>
     Öz kaynak kaybı. Bir NFS dosyası üzerinde öneri niteliğinde bir kilit varsa, NFS sunucusu yeniden başlatıldığında bu kilidin hazırlandığı unutulmuş olacağından bu sinyal üretilir.
    </para>
    <para>
     GNU/Hurd sistemlerinde herhangi bir sunucu beklenmedik şekilde ölürse, <code>SIGLOST</code> sinyali üretilir. Genellikle sinyal yok sayılabilir; ancak ölmüş bir sunucuya yapılan çağrı sadece hata döndürür.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-SIGXCPU"><primary>SIGXCPU</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-SIGXCPU"><primary>sinyaller</primary><secondary>işlemci zaman sınırı aşıldı sinyali</secondary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>SIGXCPU</function></csname>
    </csproto>
    <header>&signal.h;</header>
    <para>
     İşlemci zaman sınırı aşıldı. Bu sinyal bir sürecin işlemci zamanı üzerindeki sanal öz kaynak sınırı aşıldığında üretilir. Bkz, <xref linkend="glibc-Limits-on-Resources"/>.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-SIGXFSZ"><primary>SIGXFSZ</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-SIGXFSZ"><primary>sinyaller</primary><secondary>dosya boyu sınırı aşıldı sinyali</secondary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>SIGXCPU</function></csname>
    </csproto>
    <header>&signal.h;</header>
    <para>
     Dosya boyu sınırı aşıldı. Bu sinyal, bir sürecin dosya boyu üzerindeki sanal öz kaynak sınırı aşılacak şekilde dosya büyütülmeye çalışıldığında üretilir. <xref linkend="glibc-Limits-on-Resources"/>.
    </para>
   </csynopsis>
  </sect1>
  <sect1 xml:id="glibc-Miscellaneous-Signals">
   <title>Çeşitli Sinyaller</title>
   <titleabbrev>Muhtelif sinyaller.</titleabbrev>
   <para>
    Bu sinyaller başka başka amaçlar için kullanılır. Özellikle belli bir amaç için kullanılmıyorsa hiçbir etkileri yoktur.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-SIGUSR1"><primary>SIGUSR1</primary></indexterm>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-SIGUSR2"><primary>SIGUSR2</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-SIGUSR1"><primary>sinyaller</primary><secondary>kullanıcı sinyalleri</secondary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>SIGUSR1</function></csname>
    </csproto>
    <csproto type="makro">
     <csname><type>int</type><function>SIGUSR2</function></csname>
    </csproto>
    <header>&signal.h;</header>
    <para>
     <code>SIGUSR1</code> ve <code>SIGUSR2</code> sinyalleri herhangi bir amaçla kullanılabilmesi için vardır. Onlar için bir sinyal işleyici yazılırsa, basit süreçler arası iletişim için kullanışlıdır.
    </para>
    <para>
     <xref linkend="glibc-Signaling-Another-Process"/> bölümünde <code>SIGUSR1</code> ve <code>SIGUSR2</code> sinyallerinin kullanım örneği vardır.
    </para>
    <para>
     Ön tanımlı eylem sürecin sonlanmasıdır.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-SIGWINCH"><primary>SIGWINCH</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-SIGWINCH"><primary>sinyaller</primary><secondary>pencere boyutu değişti sinyali</secondary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>SIGWINCH</function></csname>
    </csproto>
    <header>&signal.h;</header>
    <para>
     Pencere boyutu değişti. Bu sinyal, bazı sistemlerde (GNU dahil), uçbirim sürücüsünün ekranın satır ve sütun sayılarını tutan kaydı değiştiğinde  üretilir. Ön tanımlı eylem sinyalin yok sayılmasıdır.
    </para>
    <para>
     Bir yazılım alanı tam ekrana genişletilirse <code>SIGWINCH</code> sinyalini yakalamalıdır. Sinyal geldiğinde, yazılım yeni boyutlara göre kendini ayarlamalıdır.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-SIGINFO"><primary>SIGINFO</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-SIGINFO"><primary>sinyaller</primary><secondary>bilgi isteği sinyali</secondary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>SIGINFO</function></csname>
    </csproto>
    <header>&signal.h;</header>
    <para>
     Bilgi isteği. 4.4 BSD ve GNU/Hurd sistemlerinde, bu sinyal kullanıcı tarafından kurallı kipte <varname>STATUS</varname> karakteri tuşlandığında denetim uçbiriminin önalan süreç grubundaki tüm süreçlere gönderilir; bkz, <xref linkend="glibc-Signal-Characters"/>.
    </para>
    <para>
     Eğer süreç, süreç grubunun lideri ise varsayılan eylem, sürecin ne yaptığı ve sistem hakkındaki bazı durum bilgilerinin basılmasıdır. Aksi takdirde varsayılan olarak hiçbir şey yapılmaz.
    </para>
   </csynopsis>
  </sect1>
  <sect1 xml:id="glibc-Signal-Messages">
   <title>Sinyal İletileri</title>
   <titleabbrev>Bir sinyali açıklayan iletinin basılması.</titleabbrev>
   <para>
    Daha önce bahsedildiği gibi, bir alt süreç sinyal ile sonlandığında, kabuk bu sinyali açıklayan bir ileti basar. Bir sinyali açıklayan iletiyi basmanın en temiz yolu <function>strsignal</function> ve <function>psignal</function> işlevlerini kullanmaktır. Bu işlevler hangi sinyal çeşidini açıklayan iletinin basılacağını belirtmek için bir sinyal numarası kabul eder. Sinyal numarası bir alt sürecin sonlanma durumundan (bkz, <xref linkend="glibc-Process-Completion"/>) ya da aynı sürecin sinyal işleyicisinden gelebilir.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-strsignal"><primary>strsignal</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-strsignal"><primary>sinyaller</primary><secondary>sinyal iletileri</secondary></indexterm>
    <csproto type="işlev">
     <csname><ptr>char</ptr><function>strsignal</function></csname>
     <csparam><type>int</type><parameter>signum</parameter></csparam>
    </csproto>
    <header>&string.h;</header>
    <conceptlist>
     <concept>&mtunsafe; &race;<code linkend="glibc-safety-identifier">:strsignal</code> &locale;</concept>
     <concept>&asunsafe; &init; &i18n; &corrupt; &heap;</concept>
     <concept>&acunsafe; &init; &corrupt; &mem;</concept>
    </conceptlist>
    <para>
     <parameter>signum</parameter> numaralı sinyali açıklayan bir iletinin duruk olarak ayrılmış dizgesine gösterici ile döner. Bu dizgenin içeriğinde değişiklik yapılmamalıdır; ayrıca daha sonraki çağrılar bu dizgenin yeniden yazılmasına sebep olacağından dizge hemen kullanılmayacaksa bir kopyası saklanmalıdır.
    </para>
    <para>
     <indexterm linkend="glibc-pg" xml:id="glibc-pg-strsignal"><primary>string.h</primary></indexterm>
     Bu işlev GNU oluşumudur ve &string.h; başlık dosyasında bildirilmiştir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-pg" xml:id="glibc-pg-psignal"><primary>signal.h</primary></indexterm>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-psignal"><primary>psignal</primary></indexterm>
    <csproto type="işlev">
     <csname><type>void</type><function>psignal</function></csname>
     <csparam><type>int</type><parameter>signum</parameter></csparam>
     <csparam><ptr>const&#160;char</ptr><parameter>message</parameter></csparam>
    </csproto>
    <header>&signal.h;</header>
    <conceptlist>
     <concept>&mtsafe; &locale;</concept>
     <concept>&asunsafe; &corrupt; &i18n; &heap;</concept>
     <concept>&acunsafe;  &lock;  &corrupt; &mem;</concept>
    </conceptlist>
    <para>
     <parameter>signum</parameter> numaralı sinyali açıklayan bir iletiyi <varname>stderr</varname> standart hata çıktılama akımına basar. Bkz, <xref linkend="glibc-Standard-Streams"/>.
    </para>
    <para>
     <code>psignal</code> işlevi, boş gösterici ya da boş dizge içeren <parameter>message</parameter> bağımsız değişkeni ile çağrılırsa <parameter>signum</parameter>'un karşılığı olan iletinin sonuna bir satır sonu karakteri ile bir boşluk yerleştirilir.
    </para>
    <para>
     Bu işlev BSD oluşumudur ve &signal.h; başlık dosyasında bildirilmiştir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-pg" xml:id="glibc-pg-sigdescr_np"><primary>string.h</primary></indexterm>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-sigdescr_np"><primary>sigdescr_np</primary></indexterm>
    <csproto type="işlev">
     <csname><ptr>const&#160;char</ptr><function>sigdescr_np</function></csname>
     <csparam><type>int</type><parameter>signum</parameter></csparam>
    </csproto>
    <header>&string.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     <parameter>signum</parameter> numaralı sinyali açıklayan bir ileti (örn, <varname>SIGHUP</varname> için "Hangup") veya <parameter>signum</parameter> geçersizse <varname>NULL</varname> döndürür. <function>strsignal</function> işlevinden farklı olarak, döndürülen açıklama tercüme edilmez. Dönüş değeri, ömrü yazılımın tüm ömrü kadar olan ve ileti dizgesini içeren duruk depolamaya göstericidir.
    </para>
    <para>
     Bu işlev GNU oluşumudur ve &string.h; başlık dosyasında bildirilmiştir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-pg" xml:id="glibc-pg-sigabbrev_np"><primary>string.h</primary></indexterm>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-sigabbrev_np"><primary>sigabbrev_np</primary></indexterm>
    <csproto type="işlev">
     <csname><ptr>const&#160;char</ptr><function>sigdescr_np</function></csname>
     <csparam><type>int</type><parameter>signum</parameter></csparam>
    </csproto>
    <header>&string.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     <parameter>signum</parameter> numaralı sinyali açıklayan bir ileti veya <parameter>signum</parameter> geçersizse <varname>NULL</varname> döndürür.
     Dönüş değeri, ömrü yazılımın tüm ömrü kadar olan ve ileti dizgesini içeren duruk depolamaya göstericidir.
    </para>
    <para>
     Bu işlev GNU oluşumudur ve &string.h; başlık dosyasında bildirilmiştir.
    </para>
   </csynopsis>
  </sect1>
 </chapter>
 <chapter xml:id="glibc-Signal-Actions">
  <title>Sinyal Eylemlerinin Belirtilmesi</title>
  <titleabbrev>Bir sinyal alındığında neler yapılacağı nasıl belirtilir.</titleabbrev>
  <preliminary>
   <para>
    <indexterm linkend="glibc-cp"><primary>sinyal eylemleri</primary></indexterm>
    Bir sinyalin oluşturacağı eylemi değiştirmenin en basit yolu <function>signal</function> işlevini kullanmaktır. Yerleşik eylemlerden biri belirtilebileceği gibi bir <wordasword>sinyal işleyici</wordasword> de oluşturulabilir.
   </para>
   <para>
    &glibc; ayrıca, daha yetenekli olan <function>sigaction</function> oluşumunu da içerir. Bu kısım her iki oluşumu ve kullanımlarına ilişkin önerileri içerir.
   </para>
  </preliminary>
  <sect1 xml:id="glibc-Basic-Signal-Handling">
   <title>Basit Sinyal İşleme</title>
   <titleabbrev>Basitçe <code>signal</code> işlevi.</titleabbrev>
   <para>
    <indexterm linkend="glibc-pg"><primary>signal.h</primary></indexterm>
    <function>signal</function> işlevi, belirli bir sinyal için bir eylem oluşturmayı sağlayan basit bir arayüzdür. İşlevin ve bununla ilgili makroların bildirimleri &signal.h; başlık dosyasında bulunur.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-tp" xml:id="glibc-tp-sighandler_t"><primary>sighandler_t</primary></indexterm>
    <csproto type="veri türü">
     <csname><function>sighandler_t</function></csname>
    </csproto>
    <header>&signal.h;</header>
    <para>
     Sinyal işleyici işlevlerin veri türüdür. Sinyal işleyiciler sinyal numarasının belirtildiği tek bir bağımsız değişken alır ve dönüş türleri <type>void</type>'dir. Böyle bir sinyal işleyici işlev şöyle tanımlanmalıdır:
    </para>
    <literallayout class="monospaced"><code>void <replaceable>işleyici</replaceable> (int <replaceable>sinyalnum</replaceable>) { … }</code>
</literallayout>
    <para>
     Bu veri türünün ismi olan <code>sighandler_t</code> GNU oluşumudur.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-signal"><primary>signal</primary></indexterm>
    <csproto type="işlev">
     <csname><type>sighandler_t</type><function>signal</function></csname>
     <csparam><type>int</type><parameter>signum</parameter></csparam>
     <csparam><type>sighandler_t</type><parameter>action</parameter></csparam>
    </csproto>
    <header>&signal.h;</header>
    <conceptlist>
     <concept>&mtsafe; &sigintr;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     <code>signal</code> işlevi <parameter>signum</parameter> sinyali için eylem olarak <parameter>action</parameter> eylemini oluşturur.
    </para>
    <para>
     İlk bağımsız değişken olan <parameter>signum</parameter>, denetlenecek davranışın karşılığı olan sinyaldir ve bir sinyal numarası olarak belirtilmelidir. Bir sinyal numarasını belirtirken sembolik sinyal isimlerinin kullanılması gerekir (bkz, <xref linkend="glibc-Standard-Signals"/>). Doğrudan doğruya numara belirtilmemelidir, çünkü sinyallerin numaraları işletim sistemleri arasında değişiklik gösterebilir.
    </para>
    <para>
     İkinci bağımsız değişken olan <parameter>action</parameter> ise, <parameter>signum</parameter> sinyali için kullanılacak eylemi belirtmek için kullanılır. Bu aşağıdaki üçünden biri olabilir:
    </para>
    <formalpara><title><replaceable>işleyici</replaceable></title>
     <para>
      Sinyal alındığında yapılacak eylemi gerçekleştirecek işlevin adresi belirtilir. Sinyalle tetiklenen işlevler hakkında daha ayrıntılı bilgi edinmek için bkz, <xref linkend="glibc-Defining-Handlers"/>.
     </para>
    </formalpara>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-SIG_DFL"><primary>SIG_DFL</primary></indexterm>
     <csproto type="makro">
      <csname><type>sighandler_t</type><function>SIG_DFL</function></csname>
     </csproto>
     <para>
      <code>SIG_DFL</code> belli bir sinyal için varsayılan eylemin uygulanacağını belirtir. Çeşitli sinyaller için varsayılan eylemler  <xref linkend="glibc-Standard-Signals"/> bölümünde bulunabilir.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-SIG_IGN"><primary>SIG_IGN</primary></indexterm>
     <csproto type="makro">
      <csname><type>sighandler_t</type><function>SIG_IGN</function></csname>
     </csproto>
     <para>
      <code>SIG_IGN</code> sinyalin yok sayılacağını belirtmek için kullanılır.
     </para>
     <para>
      Normalde yazılım birbiri ardınca gelen eylemlere ait sinyalleri ya da sonlandırma isteği olarak kullanılan sinyalleri yok saymamalıdır. <varname>SIGKILL</varname> veya <varname>SIGSTOP</varname> sinyali asla yok sayılamaz. <varname>SIGSEGV</varname> benzeri bir sinyal yok sayılabilir, ama bir hatanın yok sayılması ve yazılımın çalışmasını sürdürmesi anlamlı olmaz. <varname>SIGINT</varname>, <varname>SIGQUIT</varname> ve <varname>SIGTSTP</varname> gibi kullanıcı isteğini belirten bir sinyali yok saymak pek dostça sayılmaz.
     </para>
     <para>
      Yazılımın belli bir bölümünde sinyallerin alınması istenmiyorsa sinyaller yok sayılmamalı, <link linkend="glibc-Blocking-Signals">yalnızca engellenmelidir</link>.
     </para>
    </csynopsis>
    <para>
     Bir sinyal için <varname>SIG_IGN</varname> veya <varname>SIG_DFL</varname> belirtilirse ve varsayılan eylem sinyalin yok sayılması ise, bekleyen sinyallerden bu türde olanlar (engellenmeye çalışılsa bile) iptal edilir. Bekleyen bir sinyalin iptal edilmesi, hemen ardından başka bir eylem belirtilmedikçe ve bu tür sinyallerin engellenmemesi istenmedikçe, bunların asla alınmayacağı anlamına gelir.
    </para>
    <para>
     <code>signal</code> işlevi, <parameter>signum</parameter> sinyali için evvelce belirtilmiş olan eylemle döner. Böylece, bu değer saklanabilir ve daha sonra <code>signal</code> işlevi tekrar çağrılarak bu eylemin tekrar etkin olmasını sağlanabilir.
    </para>
    <para>
     Eğer <code>signal</code> işlevi kendinden isteneni yerine getiremezse <varname>SIG_ERR</varname> ile döner. Bu işlev için tanımlanmış <varname>errno</varname> değerleri:
    </para>
    <formalpara><title><code>EINVAL</code></title>
     <para>
      Geçersiz <parameter>signum</parameter> belirtildi; ya da <varname>SIGKILL</varname> veya <varname>SIGSTOP</varname> için sinyal işleyici oluşturulmaya ya da bunlar yok sayılmaya çalışıldı.
     </para>
    </formalpara>
   </csynopsis>
   <note><title>Uyumluluk Bilgisi</title>
    <para>
     <function>signal</function> işlevi ile çalışırken saptanmış bir sorun için  BSD ve SVID sistemlerdeki davranış farkıdır. SVID sistemlerde sinyal işleyici sinyal alındıktan sonra kendiliğinden tekrar kurulur. BSD sistemlerde ise işleyici tekrar kurulmak zorundadır. &glibc;nde zaten BSD sürümü kullanılmaktadır. SVID sürümü kullanılmak istenirse, aşağıda anlatılan <function>sysv_signal</function> işlevi ya da bir makro seçici olan <varname>_XOPEN_SOURCE</varname> kullanılabilir (bkz, <xref linkend="glibc-Feature-Test-Macros"/>). Uyumluluk sorunlarından kaçınmak için normalde bu işlevler kullanılmamalıdır. Bunlar yerine uyumluluk açısından bir sorun çıkarmayan <function>sigaction</function> işlevini kullanmak daha iyidir.
    </para>
   </note>
   <example>
    <para>
     Burada, bazı ölümcül sinyaller alındığında geçici dosyaları silen basit bir işleyici örneği yer almaktadır:
    </para>
    <screen>#include &lt;signal.h&gt;

void
termination_handler (int signum)
{
  struct temp_file *p;

  for (p = temp_file_list; p; p = p-&gt;next)
    unlink (p-&gt;name);
}

int
main (void)
{
  …
  if (signal (SIGINT, termination_handler) == SIG_IGN)
    signal (SIGINT, SIG_IGN);
  if (signal (SIGHUP, termination_handler) == SIG_IGN)
    signal (SIGHUP, SIG_IGN);
  if (signal (SIGTERM, termination_handler) == SIG_IGN)
    signal (SIGTERM, SIG_IGN);
  …
}
</screen>
    <para>
     Eğer belirtilen sinyal evvelce yok sayılmaya ayarlanmışsa bu kodun bu ayarı değiştirmediğine dikkat edilmelidir. Bu, iş denetimi yapmayan kabukların alt süreçleri başlatırken bazı sinyalleri çoğunlukla yok saymasından ve alt süreçler için buna riayet edilmesi önemli olduğundan dolayıdır.
    </para>
    <para>
     Yazılım hata sinyalleri veya <varname>SIGQUIT</varname> sinyali, hata ayıklamada bilgi sağlamak için (bellek dökümü almak için) tasarlandığından ve geçici dosyalar hata ayıklamak için faydalı bilgiler sağlayabileceğinden bu örnekte işleme sokulmamıştır.
    </para>
   </example>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-sysv_signal"><primary>sysv_signal</primary></indexterm>
    <csproto type="işlev">
     <csname><type>sighandler_t</type><function>sysv_signal</function></csname>
     <csparam><type>int</type><parameter>signum</parameter></csparam>
     <csparam><type>sighandler_t</type><parameter>action</parameter></csparam>
    </csproto>
    <header>&signal.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     <code>sysv_signal</code> işlevi, SVID sistemlerindeki standart <function>signal</function> işlevinin davranışını gereçekleştirmek için tasarlanmıştır. Bunun BSD sistemlerinden farkı, bir sinyalin alınmasının ardından işleyicinin kendiliğinden tekrar kurulmasıdır.
    </para>
    <note><title>Uyumluluk Bilgisi</title>
     <para>
      <function>signal</function> işlevi için yukarıda bahsedildiği gibi, bu işlevin kullanılmasından kaçınılmalı ve bunun yerine mümkünse <function>sigaction</function> tercih edilmelidir.
     </para>
    </note>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-ssignal"><primary>ssignal</primary></indexterm>
    <csproto type="işlev">
     <csname><type>sighandler_t</type><function>ssignal</function></csname>
     <csparam><type>int</type><parameter>signum</parameter></csparam>
     <csparam><type>sighandler_t</type><parameter>action</parameter></csparam>
    </csproto>
    <header>&signal.h;</header>
    <conceptlist>
     <concept>&mtsafe; &sigintr;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     <code>ssignal</code> işlevi <function>signal</function> işlevinin yaptığını yapar; sadece SVID ile uyum için vardır.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-SIG_ERR"><primary>SIG_ERR</primary></indexterm>
    <csproto type="makro">
     <csname><type>sighandler_t</type><function>SIG_ERR</function></csname>
    </csproto>
    <para>
     Bu makronun değeri, <function>signal</function> işlevinin dönüş değeri olarak kullanılır ve hata oluştuğunu belirtir.
    </para>
   </csynopsis>
  </sect1>
  <sect1 xml:id="glibc-Advanced-Signal-Handling">
   <title>Gelişmiş Sinyal İşleme</title>
   <titleabbrev><code>sigaction</code> daha güçlü bir işlevdir.</titleabbrev>
   <para>
    <indexterm linkend="glibc-cp"><primary><code>sigaction</code> işlevi</primary></indexterm>
    <indexterm linkend="glibc-pg"><primary>signal.h</primary></indexterm>
    <function>sigaction</function> işlevi <function>signal</function> işlevi ile aynı temel etkiye sahiptir: bir sinyalin süreç tarafından nasıl işleneceği belirtilir. Farklı olarak, sinyalin üretilmesi ve işleyicinin çağrılması ile ilgili çeşitli denetim seçenekleri belirtilebilir.
   </para>
   <para>
    <function>sigaction</function> işlevi &signal.h; başlık dosyasında bildirilmiştir.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-tp" xml:id="glibc-tp-sigaction"><primary sortas="sigaction">struct&nbsp;sigaction</primary></indexterm>
    <csproto type="veri türü">
     <csname><type>struct</type><function>sigaction</function></csname>
    </csproto>
    <header>&signal.h;</header>
    <para>
     <code>struct sigaction</code> türündeki yapılar, <function>sigaction</function> işlevinde belli bir sinyalin nasıl işleneceği hakkındaki bilgilerin belirtilmesi için kullanılır. Bu yapı en azından aşağıdaki üyeleri içerir:
    </para>
    <glosslist>
     <glossentry>
      <glossterm>
       <type>sighandler_t&nbsp;</type><structfield>sa_handler</structfield>
      </glossterm>
      <glossdef>
       <para>
        <function>signal</function> işlevindeki <parameter>action</parameter> bağımsız değişkeninin yerine geçer. Değer olarak, <varname>SIG_DFL</varname>, <varname>SIG_IGN</varname> veya bir işlev göstericisi alır. Bkz, <xref linkend="glibc-Basic-Signal-Handling"/>.
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm>
       <type>sigset_t&nbsp;</type><structfield>sa_mask</structfield>
      </glossterm>
      <glossdef>
       <para>
        İşleyici çalışırken engellenecek sinyalleri belirtmek içindir. Sinyallerin engellenmesi <xref linkend="glibc-Blocking-for-Handler"/> bölümünde anlatılmıştır. Alınan bir sinyal, işleyicisi başlatılmadan önce varsayılan olarak özdevinimli engellenir; bu, <code>sa_mask</code>'ın değerine bakılmaksızın böyledir. Bir sinyalin işleyicisi nedeniyle engellenmemesi isteniyorsa işleyici içindeki kodun, sinyalin engellenmemesini sağlayacak şekilde yazılması gerekir.
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm>
       <type>int&nbsp;</type><structfield>sa_flags</structfield>
      </glossterm>
      <glossdef>
       <para>
        Burada, sinyalin davranışını etkileyebilen çeşitli seçenekler belirtilebilir. Bunlar <xref linkend="glibc-Flags-for-Sigaction"/> bölümünde daha ayrıntılı olarak açıklanmıştır.
       </para>
      </glossdef>
     </glossentry>
    </glosslist>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-sigaction"><primary>sigaction</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>sigaction</function></csname>
     <csparam><type>int</type><parameter>signum</parameter></csparam>
     <csparam><type>const&nbsp;struct&nbsp;sigaction&nbsp;*restrict</type><parameter>action</parameter></csparam>
     <csparam><type>struct&nbsp;sigaction&nbsp;*restrict</type><parameter>old-action</parameter></csparam>
    </csproto>
    <header>&signal.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     <parameter>action</parameter> bağımsız değişkeni ile <parameter>signum</parameter> sinyali için yeni bir eylem belirtilirken, <parameter>old-action</parameter> bağımsız değişkeni, bu simgeyle ilişkili önceki eylem hakkında bilgi döndürmek için kullanılır. (başka bir deyişle, <parameter>old-action</parameter> bağımsız değişkeni <function>signal</function> işlevinin dönüş değeri gibi kullanılmıştır. Bununla eski eylemin ne olduğuna bakılabilir ve istenirse bu eylem tekrar yerinde bırakılmak anlamında etkinleştirilebilir.)
    </para>
    <para>
     Hem <parameter>action</parameter> hem de <parameter>old-action</parameter> birer boş gösterici olabilir. <parameter>old-action</parameter> boş gösterici ise, <parameter>signum</parameter> sinyali ile ilişkili eylem değişmez; bu, bir sinyalin işlenme şeklini değiştirilmeksizin o sinyalin işlenmesi ile ilgili bilgi edinilmesini olanaklı kılar.
    </para>
    <para>
     <code>sigaction</code> başarılı olduğunda sıfır ile aksi takdirde <code>-1</code> ile döner. Aşağıdaki bu işlev ile ilişkili <varname>errno</varname> değerleri bulunmaktadır:
    </para>
    <formalpara><title><code>EINVAL</code></title>
     <para>
      <parameter>signum</parameter> bağımsız değişkeni geçersiz; ya da <varname>SIGKILL</varname> veya <varname>SIGSTOP</varname> sinyali yok sayılmaya ya da yakalanmaya çalışılıyor.
     </para>
    </formalpara>
   </csynopsis>
  </sect1>
  <sect1 xml:id="glibc-Signal-and-Sigaction">
   <title><code>signal</code> ve <code>sigaction</code> arasındaki etkileşim</title>
   <titleabbrev>Bu iki işlev nasıl etkileşir.</titleabbrev>
   <para>
    <function>signal</function> ve <function>sigaction</function> işlevlerini aynı yazılım içinde kullanmak mümkündür. Ancak tuhaf bir yolla bu iki işlev birbirinden etkilenir, bu nedenle bu ikisi aynı yazılım içinde kullanılıyorsa dikkatli olmak gerekir.
   </para>
   <para>
    <function>sigaction</function> işlevi <function>signal</function> işlevinden daha fazla bilgi içerir. Yani, <function>signal</function> işlevinin dönüş değeri <function>sigaction</function> işlevinin döndürdüğünden daha az bilgi döndürür. Diğer taraftan, bir eylemi kaydedip daha sonra etkinleştirmek için <function>signal</function> işlevi kullanılırsa, tekrar kurulan işleyici <function>sigaction</function> tarafından yeniden kurulan işleyici kadar düzgün oluşmayacaktır.
   </para>
   <para>
    Sonuç olarak, sorunlardan kaçınmak için, yazılımda her yerde <function>sigaction</function> kullanılmışsa, bir eylemi kaydetmek ve yeniden oluşturmak için yine <function>sigaction</function> işlevi kullanılmalıdır. Hatta, <function>sigaction</function> daha genel olduğundan, bir eylem hangi işlev ile kurulmuş olursa olsun, eylemi özgün haliyle saklamak ve yeniden oluşturmak için daima <function>sigaction</function> işlevi kullanılmaldır.
   </para>
   <para>
    Bazı sistemlerde, eğer bir eylem <function>signal</function> ile oluşturulup daha sonra <function>sigaction</function> ile incelenirse işleyici işlevin adresinin <function>signal</function> işlevinin bağımsız değişkeni olarak belirtilen adresle aynı olmadığı görülebilir. Hatta <function>signal</function> işlevinin bağımsız değişkeni olarak kullanmak için bile uygun olmayabilir. Ama <function>sigaction</function> işlevinde bağımsız değişken olarak kullanılabilir. Bu sorun GNU sistemlerinde asla görülmez.
   </para>
   <para>
    Bu durumda, bir yazılım içinde sürekli olarak bu düzeneklerden sadece birini kullanmak en iyisidir.
   </para>
   <note><title>Taşınabilirlik Bilgisi</title>
    <para>
     <function>sigaction</function> işlevi POSIX.1'in parçası olduğu halde, <function>signal</function> işlevi bir &isoc; oluşumudur. Yazılımın POSIX olmayan sistemlere taşınabilirliği bakımından kaygılar varsa, <function>sigaction</function> yerine <function>signal</function> işlevi tercih edilmelidir.
    </para>
   </note>
  </sect1>
  <sect1 xml:id="glibc-Sigaction-Function-Example">
   <title><code>sigaction</code> Örneği</title>
   <titleabbrev><code>sigaction</code> işlevinin kullanımına bir örnek.</titleabbrev>
   <example>
    <para>
     <xref linkend="glibc-Basic-Signal-Handling"/> bölümünde sonlandırma sinyalleri için <function>signal</function> işlevi kullanılan basit bir işleyici örneği verilmişti. Burada bu örneğin <function>sigaction</function> eşdeğerine yer verilmiştir:
    </para>
    <screen>#include &lt;signal.h&gt;

void
sonlanma_isleyici (int signum)
{
  struct temp_file *p;

  for (p = temp_file_list; p; p = p-&gt;next)
    unlink (p-&gt;name);
}

int
main (void)
{
  …
  struct sigaction yeni_eylem, eski_eylem;

  /* <replaceable>Yeni eylemi içeren yapıyı hazırla.</replaceable> */
  yeni_eylem.sa_handler = sonlanma_isleyici;
  sigemptyset (&amp;yeni_eylem.sa_mask);
  yeni_eylem.sa_flags = 0;

  sigaction (SIGINT, NULL, &amp;eski_eylem);
  if (eski_eylem.sa_handler != SIG_IGN)
    sigaction (SIGINT, &amp;yeni_eylem, NULL);
  sigaction (SIGHUP, NULL, &amp;eski_eylem);
  if (eski_eylem.sa_handler != SIG_IGN)
    sigaction (SIGHUP, &amp;yeni_eylem, NULL);
  sigaction (SIGTERM, NULL, &amp;eski_eylem);
  if (eski_eylem.sa_handler != SIG_IGN)
    sigaction (SIGTERM, &amp;yeni_eylem, NULL);
  …
}
</screen>
    <para>
     Yazılım, <parameter>yeni_eylem</parameter> veri yapısını istenen bağımsız değişkenlerle yükler ve onu <function>sigaction</function> çağrısına aktarır. <function>sigemptyset</function> işlevinin kullanımı <xref linkend="glibc-Signal-Sets"/> bölümünde açıklanmıştır.
    </para>
   </example>
   <para>
    <function>signal</function> işlevinin kullanıldığı örnekte, evvelce yok sayılmaya ayarlanmış sinyallerin işlenmesinden kaçınılmıştı. Bu örnekte ise yeni eylemi etkin kılmadan önce evvelki eylemi <function>sigaction</function> oluşumu sayesinde inceleme şansımız var. Böylece anlık bile olsa yok sayılmaya ayarlanmış bir sinyal işleyici değiştirilmemiş olur.
   </para>
   <example>
    <para>
     Burada başka bir örnek var. <varname>SIGINT</varname> sinyali için eylemi değiştirmeksizin mevcut eylem hakkında bilgi alınıyor:
    </para>
    <screen>struct sigaction query_action;

if (sigaction (SIGINT, NULL, &amp;query_action) &lt; 0)
  /* <replaceable><code>sigaction</code> hata durumunda -1 döndürüyor.</replaceable> */
else if (query_action.sa_handler == SIG_DFL)
  /* <replaceable><code>SIGINT</code> varsayımlı olarak yakalanıyor, ölümcül durum.</replaceable> */
else if (query_action.sa_handler == SIG_IGN)
  /* <replaceable><code>SIGINT</code> yok sayılıyor.</replaceable> */
else
  /* <replaceable>Tanımlanan sinyal işleyici etkinleştiriliyor.</replaceable> */
</screen>
   </example>
  </sect1>
  <sect1 xml:id="glibc-Flags-for-Sigaction">
   <title><code>sigaction</code> Seçenekleri</title>
   <titleabbrev>Sinyal işleyici için bazı seçenekler belirtilebilir.</titleabbrev>
   <para>
    <indexterm linkend="glibc-cp"><primary><code>sigaction</code> seçenekleri</primary></indexterm>
    <type>struct&nbsp;sigaction</type> veri yapısının <code>sa_flags</code> üyesi özel durumları belirtmek içindir. Çoğu durumda, <varname>SA_RESTART</varname> bu alanda kullanmak için iyi bir değerdir.
   </para>
   <para>
    <code>sa_flags</code> üyesinin değeri bir bit maskesi olarak yorumlanır. Böylece çok sayıda seçenek belirtilebilir.
   </para>
   <para>
    Her sinyalin kendine has seçenekleri vardır. Her <function>sigaction</function> çağrısı belli bir sinyal için yapılır ve belirtilen seçenekler de sadece bu sinyale uygulanır.
   </para>
   <para>
    &glibc;nde, <function>signal</function> işlevi ile kurulan işleyici için bu seçenekler, değeri <function>siginterrupt</function> kullanımına bağlı olan <varname>SA_RESTART</varname> haricinde sıfıra ayarlanır. Bu durumla ilgili bilgi  <xref linkend="glibc-Interrupted-Primitives"/> bölümünde bulunabilir.
   </para>
   <para>
    Bu makrolar &signal.h; başlık dosyasında tanımlanmıştır.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-pg" xml:id="glibc-pg-SA_NOCLDSTOP"><primary>signal.h</primary></indexterm>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-SA_NOCLDSTOP"><primary>SA_NOCLDSTOP</primary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>SA_NOCLDSTOP</function></csname>
    </csproto>
    <header>&signal.h;</header>
    <para>
     Bu seçenek sadece <varname>SIGCHLD</varname> sinyali için anlamlıdır. Bu seçenek etkin olduğunda sistem, durdurulan değil, sonlandırılan bir alt süreç olduğunda bu sinyali alır. Ön tanımlı olarak, <varname>SIGCHLD</varname> sinyali hem durdurulan hem de sonlandırılan bir alt süreç olduğunda alınır.
    </para>
    <para>
     Bu seçenek <varname>SIGCHLD</varname> dışında bir sinyal için belirtildiğinde etkisizdir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-SA_ONSTACK"><primary>SA_ONSTACK</primary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>SA_ONSTACK</function></csname>
    </csproto>
    <header>&signal.h;</header>
    <para>
     Bu seçenek belli bir sinyal için etkin olduğunda, sistem bu çeşit sinyalleri aldığında <link linkend="glibc-Signal-Stack">sinyal yığıtını</link> kullanır. Bu seçeneğin etkin olduğu bir sinyal alınırsa ve yazılım bir sinyal yığıtı oluşturmamışsa, sistem yazılımı <varname>SIGILL</varname> sinyali ile sonlandırır.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-SA_RESTART"><primary>SA_RESTART</primary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>SA_RESTART</function></csname>
    </csproto>
    <header>&signal.h;</header>
    <para>
     Bu seçenek, <function>open</function>, <function>read</function> ve <function>write</function> gibi ilkellerin bir sinyal aldıklarında nasıl davranacaklarını belirler ve sinyal işleyici normal olarak döner. İki durum söz konusu olabilir: kütüphane işlevi ya çalışmasını sürdürür ya da <varname>EINTR</varname> hata kodu ile başarısız olur.
    </para>
    <para>
     Seçimi belirleyen, sinyal alındığında <code>SA_RESTART</code>'ın etkin olup olmadığıdır. Etkinse, kütüphane işlevi çalışmasını sürdürür, değilse sinyal işlevin başarısız olmasına sebep olur. Bkz. <xref linkend="glibc-Interrupted-Primitives"/>.
    </para>
   </csynopsis>
  </sect1>
  <sect1 xml:id="glibc-Initial-Signal-Actions">
   <title>Sinyal Eylemlerinin İlk Durumu</title>
   <titleabbrev>Yazılımlar sinyal eylemlerini nasıl miras alır.</titleabbrev>
   <para>
    <indexterm linkend="glibc-cp"><primary>sinyal eylemlerinin ilk durumu</primary></indexterm>
    <link linkend="glibc-Creating-a-Process">Yeni bir süreç oluşturulduğunda</link>, sinyal işleyiciler onu oluşturan süreçten miras alınır. Bununla birlikte, yeni süreç <function>exec</function> işlevi ile yüklendiğinde (bkz, <xref linkend="glibc-Executing-a-File"/>), her sinyali <varname>SIG_DFL</varname> eylemine döndürecek işleyici tanımlanmış olur. (Biraz düşünülürse, bunun farklı bir şey olduğu görülür; eski yazılımın işleyici işlevleri ona özeldir ve yeni yazılımın adres alanında bunlar mevcut değildir.) Şüphesiz, yeni yazılım kendi işleyicilerini oluşturabilir.
   </para>
   <para>
    Bir yazılım bir kabukta çalıştırıldığında, normalde kabuk, oluşturduğu alt sürecin eylemlerini duruma göre <varname>SIG_DFL</varname> ya da <varname>SIG_IGN</varname> olarak ayarlar. Sinyal işleyici oluşturulmadan önce, kabuğun alt sürece başlangıç olarak <varname>SIG_IGN</varname> eylemini belirtmediğinden emin olunursa iyi olur.
   </para>
   <example>
    <para>
     Bu örnekte,  eğer yok sayılmıyorsa <varname>SIGHUP</varname> sinyali için bir işleyicinin nasıl kurulacağı gösterilmiştir:
    </para>
    <screen>…
struct sigaction temp;

sigaction (SIGHUP, NULL, &amp;temp);

if (temp.sa_handler != SIG_IGN)
  {
    temp.sa_handler = handle_sighup;
    sigemptyset (&amp;temp.sa_mask);
    sigaction (SIGHUP, &amp;temp, NULL);
  }
</screen>
   </example>
  </sect1>
 </chapter>

 <chapter xml:id="glibc-Defining-Handlers">
  <title>Sinyal İşleyicilerin Tanımlanması</title>
  <titleabbrev>Sinyalle tetiklenen bir işlev nasıl yazılır.</titleabbrev>
  <preliminary>
   <para>
    <indexterm linkend="glibc-cp"><primary>sinyalle tetiklenen işlev</primary></indexterm>
    Bu bölümde <function>signal</function> veya <function>sigaction</function> işlevi kullanılarak çağrılması sağlanan bir sinyal işleyici işlevin nasıl yazılacağı anlatılmıştır.
   </para>
   <para>
    Bir sinyal işleyici işlev, yazılımcı tarafından yazılıp yazılım içinde derlenen bir işlevdir. Tek farkla, bu işlev yazılım içinden doğrudan çağrılmaz, <function>signal</function> veya <function>sigaction</function> işlevi kullanılarak bir sinyal geldiğinde işletim sisteminin bu işlevi çağırması sağlanır. Buna <wordasword>işleyici oluşturmak</wordasword> adı verilir. Bkz. <xref linkend="glibc-Signal-Actions"/>.
   </para>
   <para>
    Bir işleyici işlevde kullanılabilecek iki yöntem vardır:
   </para>
   <simplelist>
    <member>
     Bazı genel veri yapılarıyla oynarken sinyal alındığında çalışan bir işleyici olabilir ve bu normal olarak döner.
    </member>
    <member>
     İşleyici işlev süreci sonlandırabilir ya da denetimin, sinyali oluşturan durumu ortadan kaldıran bir yere taşınmasını sağlayabilir.
    </member>
   </simplelist>
   <para>
    İşleyici işlevleri yazmak için özellikle yardıma ihtiyaç olacak, çünkü bu işlevlerin ne zaman çağrılacağı hiç belli olmaz. Hatta çok kısa aralıkla iki sinyal birden alınabilir ve bu durumda bir işleyicinin başka bir işleyiciyi çalıştırması gerekebilir. Bu kısımda işleyici işlevi yazarken nelerin yapılması nelerin yapılmaması gerektiği açıklanmıştır.
   </para>
  </preliminary>
  <sect1 xml:id="glibc-Handler-Returns">
   <title>Dönen Sinyal işleyiciler</title>
   <titleabbrev>Süreci sonlandırmayan, normal olarak dönen işleyici işlevler.</titleabbrev>
   <para>
    Normal olarak dönen işleyiciler genellikle, G/Ç ve süreçler arası iletişim sinyalleri ile <varname>SIGALRM</varname> benzeri sinyaller için kullanılır. Ancak, <varname>SIGINT</varname> sinyali için de bir işleyici dönebilir. Bir farkla, sürece uygun bir zamanda sonlanmasını söyleyen bir seçeneği etkinleştirerek döner.
   </para>
   <para>
    Bir yazılım hata sinyali için normal olarak dönen bir işlev yazmak doğru olmayacaktır. Çünkü yazılımın davranışının bir yazılım hatası sinyali alındıktan sonra ne olacağı belli değildir. Bkz,  <xref linkend="glibc-Program-Error-Signals"/>.
   </para>
   <para>
    Normalde dönen işleyiciler bir etki yaratması umulan bir genel değişkene değer atamalıdır. Bu değişken yazılımın çalışma anında belirli aralıklarla baktığı bir değişken olmalıdır. <xref linkend="glibc-Atomic-Data-Access"/> bölümünde açıklanan sebeplerle bu değişkenin veri türü <type>sig_atomic_t</type> olmalıdır.
   </para>
   <example>
    <para>
    Burada, böyle bir yazılım örneği vardır. Bir <varname>SIGALRM</varname> sinyali alınıncaya kadar bir döngü çalıştırılmaktadır. Bu teknik, döngü tamamlanmadan bir sinyal alınıncaya kadar yinelenen işlemler için yararlıdır.
   </para>
   <screen>#include &lt;signal.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

/* <replaceable>Bu değişken döngünün denetimi içindir.</replaceable> */
volatile sig_atomic_t keep_going = 1;

/* <replaceable>Sinyal işleyici değişkeni sıfırlar
   ve kendini tekrar etkinleştirir.</replaceable> */
void
catch_alarm (int sig)
{
  keep_going = 0;
  signal (sig, catch_alarm);
}

void
do_stuff (void)
{
  puts ("Uyarı gelene kadar bir şeyler yapılıyor...");
}

int
main (void)
{
  /* <replaceable>SIGALRM sinyalleri için bir işleyici oluştur.</replaceable> */
  signal (SIGALRM, catch_alarm);

  /* <replaceable>Kısa süreli bir uyarıyı etkinleştir.</replaceable> */
  alarm (2);

  /* <replaceable>Her çevrimde değişkenin değerine bakılsın.</replaceable> */
  while (keep_going)
    do_stuff ();

  return EXIT_SUCCESS;
}
</screen>
   </example>
  </sect1>
  <sect1 xml:id="glibc-Termination-in-Handler">
   <title>Süreci Sonlandıran İşleyiciler</title>
   <titleabbrev>İşleyici işlevler bir süreci nasıl sonlandırır.</titleabbrev>
   <para>
    Süreci sonlandıran işleyici işlevler genellikle düzenlenmiş bir durdurma için ya da yazılım hata sinyalleri ile etkileşen kesmelerden kurtulmak amacıyla kullanılır.
   </para>
   <para>
    Süreci sonlandıran bir işleyici için en iyi yöntem aynı sinyali işleyici çalıştığı anda tekrar yayınlamaktır. Bunun yapılışına bir örnek:
   </para>
   <example>
    <screen>volatile sig_atomic_t fatal_error_in_progress = 0;

void
fatal_error_signal (int sig)
{
  /* <replaceable>Bu işleyici çok sayıda sinyal çeşidi için kurulduğundan,
     diğer sinyaller için de defalarca çağrılabilecektir. Bu
     durumu izlemek için duruk bir değişken kullanılacak.</replaceable> */
  if (fatal_error_in_progress)
    raise (sig);
  fatal_error_in_progress = 1;

  /* <replaceable>Şimdi biraz temizlik yapalım:
     - uçbirim kipleri sıfırlansın
     - alt süreçler ölsün
     - kilit dosyaları silinsin.</replaceable> */
  …

  /* <replaceable>Şimdi sinyali tekrar yayınla. Süreci sonlandırması
     için sinyalin varsayılan eylemini etkin kıl.
     Tam bu anda <code>exit</code> veya <code>abort</code> çağrısı yapılabilmeli
     ve sürecin çıkış durumunun doğru ayarlanması için
     sinyal yeniden yayınlanmalı.</replaceable> */
  signal (sig, SIG_DFL);
  raise (sig);
}
</screen>
   </example>
  </sect1>
  <sect1 xml:id="glibc-Longjmp-in-Handler">
   <title>İşleyici İşlevlerde Denetimin Aktarımı</title>
   <titleabbrev>İşleyici işlevlerde denetimin dışarı aktarılması</titleabbrev>
   <para>
    <indexterm linkend="glibc-cp"><primary>sinyal işleyici ile denetimin dışa aktarımı</primary></indexterm>
    Bir sinyal işleyici için <function>setjmp</function> ve <function>longjmp</function> oluşumları kullanılarak denetim başka bir yere aktarılabilir. Bkz,  <xref linkend="glibc-Non-Local-Exits"/>.
   </para>
   <para>
    Bir işleyici denetimi dışarı aktardığı zaman, çalışmakta olan yazılım kalan işlemi biteremez. Örneğin yazılım o anda önemli bir veri yapısını güncelliyorsa, veri yapısı belirsiz bir durumda kalacaktır. Süreç sonlandırıldığından belirsizlik daha sonra benzer şekilde bildirilecektir.
   </para>
   <para>
    Bu sorundan kaçınmanın iki yolu vardır. Biri, önemli veri yapısının güncellenmesi bitene kadar sinyalin engellenmesidir. Bkz,  <xref linkend="glibc-Blocking-Signals"/>.
   </para>
   <para>
    Diğer yol ise, önemli veri yapısını işleyici içinde yeniden ilklendirmek ve değerlerini belirli yapmaktır.
   </para>
   <para>
    Örnekte, bir genel değişkenin yeniden ilklendirilmesi gösterilmiştir:
   </para>
   <example>
    <screen>#include &lt;signal.h&gt;
#include &lt;setjmp.h&gt;

jmp_buf return_to_top_level;

volatile sig_atomic_t waiting_for_input;

void
handle_sigint (int signum)
{
  /* <replaceable>Sinyal alındığında girdi için beklemek gerekir,
     ama denetim aktarılacağından artık beklenemez.</replaceable> */
  waiting_for_input = 0;
  longjmp (return_to_top_level, 1);
}

int
main (void)
{
  …
  signal (SIGINT, sigint_handler);
  …
  while (1) {
    prepare_for_command ();
    if (setjmp (return_to_top_level) == 0)
      read_and_execute_command ();
  }
}

/* <replaceable>Bunun çeşitli komutlar için kullanılan
   bir yordam olduğu varsayılsın.</replaceable> */
char *
read_data ()
{
  if (input_from_terminal) {
    waiting_for_input = 1;
    …
    waiting_for_input = 0;
  } else {
    …
  }
}
</screen>
   </example>
  </sect1>
  <sect1 xml:id="glibc-Signals-in-Handler">
   <title>İşleyici Çalışırken Sinyal Alınması</title>
   <titleabbrev>Sinyaller peşpeşe gelirse ne olacak.</titleabbrev>
   <para>
    <indexterm linkend="glibc-cp"><primary>sinyaller için yarış koşulları</primary></indexterm>
    Sinyal işleyici işlev çalışırken başka bir sinyal alındığında ne olacak?
   </para>
   <para>
    Belli bir sinyal için işleyici işlev çağrıldığında işleyici işlemlerini bitirene kadar sinyal özdevinimli olarak engellenir. Bu, aynı iki sinyal peşpeşe alınırsa, biri için işlem tamamlanana kadar diğeri engellenecek demektir. (Bu türden birden fazla sinyal geldiğinde bunlara da izin vermek istenirse, <function>sigprocmask</function> kullanarak sinyalin engellenmemesi sağlanabilir; bkz, <xref linkend="glibc-Process-Signal-Mask"/>.)
   </para>
   <para>
    Bununla birlikte, işleyici işlev başka çeşit bir sinyal ile hala durdurulabilir durumdadır. Bundan kaçınmak için, <function>sigaction</function> ile kullanılan veri yapısının <code>sa_mask</code> üyesinde işleyici çalışırken hangi sinyallerin engelleneği belirtilebilir. Bunlar işleyicinin çağrılmasına sebep olan sinyale ek olarak belirtilir ve diğer sinyaller normal olarak süreç tarafından engellenir. Bkz. <xref linkend="glibc-Blocking-for-Handler"/>.
   </para>
   <para>
    İşleyici işini bitirdiğinde engellenen sinyaller işleyicinin çalıştırılmadan önceki durumlarına döner. Bu durumda, işleyici işlev içinde <function>sigprocmask</function> kullanılması sadece işleyicinin çalışması sırasında gelen sinyalleri etkiler, işleyici işlev döndükten sonra gelen sinyalleri etkilemez.
   </para>
   <note><title>Taşınabilirlik Bilgisi</title>
    <para>
     Yazılımın System V Unix üzerinde gerektiği gibi çalışması isteniyorsa ve eşzamansız bir sinyal alınacağı umuluyorsa, bu sinyalin işleyicisini oluşturmak için daima <function>sigaction</function> kullanılmalıdır. Bu sistem üzerinde <function>signal</function> ile oluşturulan bir işleyici ile sinyalin yakalanması özdevinimli olarak sinyal eyleminin varsayılan eyleme yani <varname>SIG_DFL</varname>'ye ayarlanmasına sebep olur. Böyle bir işleyici her çalıştığında kendini tekrar kurmalıdır. Bu uygulama, rahatsız edici olsa da, işleyici çalışırken sinyaller işleme alınamadığında da çalışır. Şöyle ki, hemen ardından başka bir sinyal gelebilir ve işleyici kendini daha kurmadan sinyal alınabilir. Bu durumda ikinci sinyal varsayılan eylem ile karşılanacak ve süreç sonlanabilecektir.
    </para>
   </note>
  </sect1>
  <sect1 xml:id="glibc-Merged-Signals">
   <title>İşleyici Çalışmadan İkinci Bir Sinyalin Alınması</title>
   <titleabbrev>İşleyici işlev daha çalışmamışken ikinci bir sinyal gelirse ne olacak.</titleabbrev>
   <para>
    <indexterm linkend="glibc-cp"><primary>peşpeşe gelen sinyallerin işlenmesi</primary></indexterm>
    <indexterm linkend="glibc-cp"><primary>sinyaller</primary><secondary>ardışık</secondary></indexterm>
    <indexterm linkend="glibc-cp"><primary>sinyaller</primary><secondary>katıştırma</secondary></indexterm>
    Süreç, bir sinyal işleyicinin çalışmasından hemen önce aynı türden çok sayıda sinyal alırsa, işleyici tek bir sinyal alınmış gibi sadece bir kere çalıştırılabilir. Gerçekte ise, sinyaller tek bir sinyal içine katıştırılmış olur. Bu durum, sinyal engellendiğinde ya da çok süreçli bir ortam da sistemin başka bir süreçle meşgul olduğu bir sırada ortaya çıkabilir. Bu, örneğin, bir sinyal işleyicinin bir sinyal sayacı olarak kullanılamayacağı anlamına gelir. Ayırdına varılacak tek şey, bir kerede en azından bir sinyal alınmış olduğudur.
   </para>
   <para>
    Aşağıda, alt süreç tarafından üretilen sinyallerin alınan sinyallerin sayısına eşit olmayışını telafi eden bir <varname>SIGCHLD</varname> işleyici örneği verilmiştir. Burada yazılımın, alt süreçlerin izini sürmek için bir yapı zinciri kullandığı varsayılmıştır:
   </para>
   <example>
    <screen>struct process
{
  struct process *next;
  /* <replaceable>Bu alt sürecin süreç kimliği.</replaceable>  */
  int pid;
  /* <replaceable>Bu alt süreçten gelen çıktıların yönlendirileceği
     uçbirim ya da ardışık süreç akımının tanıtıcısı.</replaceable>  */
  int input_descriptor;
  /* <replaceable>Bu süreç durdurulursa ya da sonlandırılırsa
     değişkenin değeri sıfırdan farklı olacak.</replaceable>  */
  sig_atomic_t have_status;
  /* <replaceable>Bu sürecin durumu; çalışıyorsa sıfırdır,
     aksi takdirde <code>waitpid</code>'deki durum değeridir.</replaceable>  */
  int status;
};

struct process *process_list;
</screen>
   </example>
   <para>
    Bu örnek, hemen öncesinde bazı sinyallerin alınmasına bağlı olarak bir değişken de kullanıyor. Her seferinde yazılımın sonunda bu sıfırlanıyor.
   </para>
   <example>
    <screen>/* <replaceable>Sıfırdan farklı bir değer alt sürecin durumunun
   değiştiği anlamına gelir. Bu durumla ilgili ayrıntılar
   için <code>process_list</code>'e bakılmalı.</replaceable>  */
int process_status_change;
</screen>
    <para>İşleyici:</para>
    <screen>void
sigchld_handler (int signo)
{
  int old_errno = errno;

  while (1) {
    register int pid;
    int w;
    struct process *p;

    /* <replaceable>Tanımlanabilir bir sonuç alana kadar sorguyu sürdür.</replaceable>  */
    do
      {
        errno = 0;
        pid = waitpid (WAIT_ANY, &amp;w, WNOHANG | WUNTRACED);
      }
    while (pid &lt;= 0 &amp;&amp; errno == EINTR);

    if (pid &lt;= 0) {
      /* <replaceable>Bir alt süreç kalmamışsa çık.</replaceable>  */
      errno = old_errno;
      return;
    }

    /* <replaceable>Sinyal gönderen süreci bul ve durumunu kaydet.</replaceable>  */

    for (p = process_list; p; p = p-&gt;next)
      if (p-&gt;pid == pid) {
        p-&gt;status = w;
        /* <replaceable>Durum alanının bir veri içerdiğini belirt.
           Bunu onu sakladıktan sonra yap. </replaceable>  */
        p-&gt;have_status = 1;

        /* <replaceable>Süreç sonlandırılmışsa çıktısını beklemekten vazgeç.</replaceable>  */
        if (WIFSIGNALED (w) || WIFEXITED (w))
          if (p-&gt;input_descriptor)
            FD_CLR (p-&gt;input_descriptor, &amp;input_wait_mask);

        /* <replaceable>Yazılım arasıra bu değişkene süreç listesinde
           yeni bir süreç var mı diye bakmalı.</replaceable>  */
        ++process_status_change;
      }

    /* <replaceable>Söyleyecek bir şeyleri var mı diye
       tekrar dönüp tüm süreçlere bak.</replaceable>  */
  }
}
</screen>
    <para>
     <code>process_status_change</code> değişkenini denetlemek için bir yöntem:
    </para>
    <screen>if (process_status_change) {
  struct process *p;
  process_status_change = 0;

  for (p = process_list; p; p = p-&gt;next)
    if (p-&gt;have_status) {
    … <replaceable><code>p-&gt;status</code> incelemesi</replaceable> …
    }
}
</screen>
    </example>
    <para>
     Listeyi incelemeye başlamadan önce seçeneğin temizlenmesi hayati önemdedir; aksi takdirde, seçeneğin temizlenmesinden önce bir sinyal alınırsa ve süreç listesinin ilgili elemanı etkinse, bu seçenekle ilgili olarak sinyal hakkında bir uyarı alınamayacaktır. Bu sorundan kaçınmak için listeyi taramaya başlamadan önce seçeneği temizlemek gerekir; bazı işlemleri doğru sırada yapmak önemlidir.
    </para>
    <para>
     Döngüde <code>p-status</code> alanı incelenerek, sürecin durumu hakkında bilgi edinilmeye çalışılır. <code>p->have_status</code> etkin bir değere sahipse, süreç durdurulmuş ya da sonlandırılmıştır; değilse, yazılım tekrar uyarı alana kadar durdurulamamış ya da sonlandırılamamıştır. Bir değişkene erişim sırasındaki kesmelerin kaydedilmesi hakkında daha fazla bilgi için bkz, <xref linkend="glibc-Atomic-Usage"/>.
    </para>
    <para>
     Başka bir yol da, sinyal işleyicinin son sınamadan beri çalıştırılıp çalıştırılmadığına bakmaktır. Bu teknikte, sinyal işleyicinin dışında değiştirilmeyen bir sayaç kulanılır. Sayacı sıfırlamak yerine, yazılım sayacın son değerini hatırlayarak önceki sınamadan beri bir değişiklik olup olmadığına bakılır. Bu yöntemin bir faydası da, yazılımın parçalarının birbirinden bağımsız olarak denetlenebilmesidir.
    </para>
    <example>
     <screen>sig_atomic_t process_status_change;

sig_atomic_t last_process_status_change;

…
{
  sig_atomic_t prev = last_process_status_change;
  last_process_status_change = process_status_change;

  if (last_process_status_change != prev) {
    struct process *p;

    for (p = process_list; p; p = p-&gt;next)
      if (p-&gt;have_status) {
        … <replaceable><code>p-&gt;status</code> incelemesi</replaceable> …
      }
  }
}
</screen>
    </example>
  </sect1>
  <sect1 xml:id="glibc-Nonreentrancy">
   <title>Sinyal İşleme ve Evresel Olmayan İşlevler</title>
   <titleabbrev>Sinyaller bakımından evresel olduğunu bilinmedikçe hiçbir işlev çağrılmamalıdır.</titleabbrev>
   <para>
    <indexterm linkend="glibc-cp"><primary>sinyal işleme</primary><secondary>işlevlerle ilgili sınırlamalar</secondary></indexterm>
    <indexterm linkend="glibc-cp"><primary><code>volatile</code> bildirimler</primary></indexterm>
    <indexterm linkend="glibc-cp"><primary>evresel işlevler</primary></indexterm>
    Sinyal işleyici işlevler genelde çok zor değildir. En iyi çözüm, hiçbir şey yapmayan ama yazılımın sürekli sınadığı bir harici değişkene değer atayan ve bu değişkenle ilgili işlemleri yazılıma bırakan bir kod yazmaktır.  En iyisi budur çünkü, işleyici işlev rasgele, umulmadık bir zamanda, basit bir işlevin ortasında ve hatta çok sayıda işlemci komutu gerektiren C işleçlerinin başlangıcı ile sonu arasında çağrılabilir. Üzerinde çalışılan veri yapıları işleyici işlevler çağrıldığında kararsız durumda bile olabilirler.  <type>int</type> türünden bir değişkenin diğerine kopyalanması çoğu makinede iki işlemci komutundan oluşur.
   </para>
   <para>
    Yani, bir sinyal işleyici ile ne yapılacağına bağlı olarak çok dikkatli olmak gerekir.
   </para>
   <itemizedlist>
    <listitem>
     <para>
      Eğer işleyici işlevin yazılımdan herhangi bir genel değişkene erişmesi gerekiyorsa bu değişkenler <type>volatile</type> ile bildirilmelidir. Böylece, derleyiciye bu değişkenin herhangi bir anda değişebileceği ve bu tür değişikliklere göre değerlendirilmiş en iyilemelerin yapılmaması söylenmiş olur.
     </para>
    </listitem>
    <listitem>
     <para>
      İşleyici içinden bir işlev çağrılıyorsa, sinyallerle ilgili olarak <wordasword>evresel</wordasword> olduğundan, değilse, başka bir ilgili işlev tarafından sinyalin engellenmediğinden emin olunmalıdır.
     </para>
    </listitem>
   </itemizedlist>
   <para>
    Bir işlev, yığıtı değil de belleği kullanıyorsa evresel olmayabilir.
   </para>
   <itemizedlist>
    <listitem>
     <para>
      Bir işlev duruk veya genel ya da sadece kendinin erişebildiği özdevimli tahsis edilmiş bir nesne kullanıyorsa, evresel olmayabilir ve işlevin herhangi iki çağrısı bir diğeri ile etkileşebilir.
     </para>
     <para>
      Örneğin sinyal işleyici <function>gethostbyname</function> işlevini kullanıyor olsun. Bu işlev değerini duruk bir nesne içinde döndürür. Eğer <function>gethostbyname</function> çağrısı sırasında ya da çağrının ardından (yazılım hala bu değeri kullanıyorken) bir sinyal gelirse, sinyal yazılımın istediği değeri bozabilir.
     </para>
     <para>
      Diğer yandan, yazılım <function>gethostbyname</function> işlevini ya da aynı nesnedeki bilgiyi döndüren herhangi bir başka işlev kullanmıyorsa ya da her kullanımda daima sinyaller engelleniyorsa sorun yok demektir.
     </para>
     <para>
      Değeri sabit bir nesne içinde döndüren ve bu şekilde aynı nesnenin daima yeniden kullanılabilir olmasını sağlayan çok sayıda kütüphane işlevi vardır ve bunların tamamı aynı soruna yol açabilir. Bu kılavuzdaki işlev açıklamalarında bu davranış daima açıklanmıştır.
     </para>
    </listitem>
    <listitem>
     <para>
      Eğer bir işlev, yazılımda tanımlanan bir nesneyi kullanıyor ve değiştiriyorsa, büyük ihtimalle işlev evresel değildir; bu işlevler, aynı nesneyi kullandıkları takdirde birbirlerini etkileyebilir.
     </para>
     <para>
      Akımlarla G/Ç işlemleri yaparken bu durum ortaya çıkabilir. Bir sinyal işleyicinin <function>fprintf</function> işlevi ile bir ileti bastığı varsayılsın. Tam da aynı akımı kullanan bir <function>fprintf</function> çağrısının ortasında yazılım bir sinyal alırsa, hem sinyal işleyicinin hem de yazılımın verisi bozulurdu, çünkü her iki çağrı da kendi akımı üzerinde aynı veri yapısıyla çalışıyor olacaktı.
     </para>
     <para>
      Bununla birlikte, işleyicinin kullandığı akımın sinyal geldiğinde yazılım tarafından kullanılması mümkün olmayabilir; bu durumda sorun yok demektir. Yazılım başka bir akımı kullanıyorsa zaten sorun yoktur.
     </para>
    </listitem>
    <listitem>
     <para>
      Çoğu sistemde, serbest bırakılacak bellek dilimlerinin kaydı için aynı duruk veri yapısını kullandıkları için <function>malloc</function> ve <function>free</function> evresel değildir. Sonuç olarak, bellek tahsis eden ve serbest bırakan kütüphane işlevleri evresel olmayacaktır. Bu, sonucu saklayacağı alanı kendisi ayıran işlevleri de kapsar.
     </para>
     <para>
      Bir işleyici işlev içinde bellek ayırma ihtiyacından kaçınmanın en iyi yolu, işlev için kullanılacak alanı önceden ayırmaktır.
     </para>
     <para>
      Bir işleyici işlev içinde belleği serbest bırakma ihtiyacından kaçınmanın en iyi yolu ise, serbest bırakılacak nesneleri kaydetmek ya da imlemek ve yazılımda zaman zaman bu türde serbest bırakılmayı bekleyen nesneler olup olmadığına bakmaktır. Fakat bu dikkatli yapılmalıdır çünkü bir nesnenin bir zincire yerleştirilmesi işlemin bölünmezliğini bozar ve başka bir sinyal işleyici ile işlem kesmeye uğratılırsa nesnelerden birinin kaybedilmesi gibi şeyler olabilir.
     </para>
    </listitem>
    <listitem>
     <para>
      <varname>errno</varname> değişkenini değiştiren işlevler evresel değildir, fakat bu düzeltilebilir: işleyicide  <varname>errno</varname> değişkeninin özgün değerini kaydedilip normal olarak dönmeden önce bu değer yerine konabilir. Böylece, sistemin bir sinyalle tetiklediği işleyicinin çalışmaya başlamasıyla alınması engellenen hataların işleyicinin işi bittiğinde elde edilebilmesi sağlanmış olur.
     </para>
     <para>
      Bu teknik genellikle uygulanabilir; belli bir nesneyi bellekte değiştiren bir işlevin bir sinyal işleyici içinden çağrılması durumunda, nesne kaydedilerek ve sonra eski değeri yerine konarak rahatça uygulanabilir.
     </para>
    </listitem>
    <listitem>
     <para>
      Sadece, sinyal alındığında bir bellek nesnesinin okunması güvenli olabilir. Ancak, bazı veri türlerinde atama işleminin birden fazla işlemci komutuna malolduğu unutulmamalıdır, <link linkend="glibc-Atomic-Data-Access">bir değişkene yapılan atama bölünmez türde</link> değilse bir sinyal işleyici, çalışmaya başladığı anda böyle bir atamanın arasına girebilir.
     </para>
    </listitem>
    <listitem>
     <para>
      Bir sinyal alındığında, bir bellek nesnesine yazma işlemi sadece değer olabildiğince anlık değişiyorsa güvenli olabilir. Bu durumda işleyicinin çalışması bir şeyi bozmaz.
     </para>
    </listitem>
   </itemizedlist>
  </sect1>
  <sect1 xml:id="glibc-Atomic-Data-Access" userlevel="notoc">
   <?dbhtml stop-chunking?>
   <title>Bölünmez Veri Erişimi ve Sinyal İşleme</title>
   <titleabbrev>Bir sinyal işleyici, bir nesnenin okunması ya da yazılması işleminin arasına girebilir.</titleabbrev>
   <para>
    Uygulama verisinin bölünmez türde ya da salt metin olup olmamasına bağlı olarak, bölünmez türde olmayan bir veriye erişirken dikkatli olunmalıdır. Bir nesnenin okunması ya da yazılması tek bir işlemci komutu ile gerçekleşemeyebilir, böyle bir durumda bir sinyal işleyici işlemin arasına girebilir ve işlem yarıda kalabilir.
   </para>
   <para>
    Bu sorunla ilgili olarak uygulanabilecek üç yöntem vardır. Veri türlerine erişim bölünmez yapılabilir; işlem dikkatlice yapılandırılabilir böylece erişimin kesilmesi sözkonusu ise böyle bir veri erişimi ya hiç yapılmaz ya da veriye erişirken işlem sırasında sinyallerin tamamı <link linkend="glibc-Blocking-Signals">engellenir</link>.
   </para>
   <sect2 xml:id="glibc-Non-atomic-Example">
    <title>Veriye Erişimde Kesinti</title>
    <titleabbrev>Veriye erişimin kesintiye uğratıldığı yazılım örneği.</titleabbrev>
    <para>
     Bu örnekte, bir değişkenin değerinin değiştirilmesi sırasında bir sinyal işleyici işlevin araya girdiği durum gösterilmiştir. (Bir değişkenin okunması sırasında kesintiye uğratılması mantıksız sonuçlara sebep olabilir, ama burada sadece yazma olayı gösterilmiştir.)
    </para>
    <screen>#include &lt;signal.h&gt;
#include &lt;stdio.h&gt;

volatile struct two_words { int a, b; } memory;

void
isleyici(int signum)
{
   printf ("%d,%d\n", memory.a, memory.b);
   alarm (1);
}


int
main (void)
{
   static struct two_words zeros = { 0, 0 }, ones = { 1, 1 };
   signal (SIGALRM, isleyici);
   memory = zeros;
   alarm (1);
   while (1)
     {
       memory = zeros;
       memory = ones;
     }
}
</screen>
    <para>
     Yazılım, <replaceable>memory</replaceable> değişkenini sırayla sıfırlarla ve birlerle doldurmaktadır. Her saniyede bir, alarm sinyalinin işleyicisi o anki içeriği basmaktadır. (İşleyici içinde <function>printf</function> kullanımı, sinyal oluştuğu sırada <function>printf</function> işleyici dışında çağrılmadığından bu kod için sorun çıkarmaz.)
    </para>
    <para>
     Başka bir deyişle yazılım sıfır ya da bir çiftlerinden birini basar. Ama bu iş tamamen istendiği gibi olmaz! Çoğu makinede, <replaceable>memory</replaceable> değişkeninde yeni değerin saklanması bir işlemci komutundan fazlasına ihtiyaç duyar. Bu komutların çağrılması sırasında bir sinyal alınırsa, işleyici <code>memory.a</code> için <code>0</code>, <code>memory.b</code> için <code>1</code> ya da tersini basabilir (Normalde ikisi de aynı olmalıydı).
    </para>
    <para>
     Bazı makineler, işlemi tek bir işlemci komutu ile yapabilir ve bu durumda işleyici daima sıfır ya da bir çiftleri basar.
    </para>
   </sect2>
   <sect2 xml:id="glibc-Atomic-Types">
    <title>Bölünmez Türler</title>
    <titleabbrev>Kesintiye uğratılamayan veri türleri.</titleabbrev>
    <para>
     Bir değişkene erişimin ne olursa olsun kesintiye uğratılamamasını sağlamak için erişimin daima bölünmez olduğu bir veri türü kullanılabilir: <type>sig_atomic_t</type>. Bu veri türündeki bir değişkene yapılan bir okuma veya yazma işleminin tek bir işlemci komutu ile gerçekleştirilmesi garanti edilmiştir. Böylece bir sinyal işleyicinin işlemin arasına girmesi engellenmiş olur.
    </para>
    <para>
     <type>sig_atomic_t</type> türü daima bir tamsayı veri türüdür, ama hangisi olduğu yani kaç bit genişlikte olduğu makineden makineye değişebilir.
    </para>
    <csynopsis>
     <indexterm linkend="glibc-tp" xml:id="glibc-tp-sig_atomic_t"><primary>sig_atomic_t</primary></indexterm>
     <csproto type="veri türü">
      <csname><type>struct</type><function>sig_atomic_t</function></csname>
     </csproto>
     <header>&signal.h;</header>
     <para>
      Bu bir tamsayı veri türüdür. Bu türdeki nesnelere erişim kesintiye uğratılamaz.
     </para>
    </csynopsis>
    <para>
     Uygulamada, <type>int</type> türüne erişimin kesintiye uğratılmayacağı varsayılabilir. Ayrıca çok elverişli olmasa da gösterici türlerinin de böyle olduğu varsayılabilir. &glibc;ni destekleyen makinelerde ve bilinen tüm POSIX sistemlerinde her iki kabulde geçerlidir.
    </para>
   </sect2>
   <sect2 xml:id="glibc-Atomic-Usage">
    <title>Veriye Erişimde Kesintiden Kaçınma Yöntemleri</title>
    <titleabbrev>Kesmenin bozuculuğunun saptanması.</titleabbrev>
    <para>
     Bir erişimin kesintiye uğratılmasından kaçınılmasını sağlayan belli erişim şekilleri vardır. Örneğin, sinyal işleyici işlev tarafından bir seçenek etkinleştirilebilir ve ana yazılım tarafından bu değişken zaman zaman 1 ya da 0 yapılabilir. Böylece, bir veriye erişim için iki komut gerekiyorsa bu işlem güvenceye alınmış olur. Bunun böyle olduğunu göstermek için, veriye her erişimin kesmeye uğratılmaya çalışıldığı, ancak kesmeye uğratılsa bile bunun bir sorun oluşturmadığı gösterilecektir.
    </para>
    <para>
     Seçeneğin sınanması sırasında bir kesme sorun çıkarmaz, çünkü ya değerin kesinliğinin önemi olmadığı duruma karşılık değer sıfırdan farklı olacak ya da bir sonraki sınama için sıfırdan farklı görünecektir.
    </para>
    <para>
     Seçeneğin sıfırlanması sırasında da bir kesinti sorun çıkarmayacaktır, çünkü seçenek sıfırlanmadan önce bir sinyal geldiğinde ne olacağına bağlı olarak değer ya sıfır olacak ya da sıfırdan farklı olacaktır. Kod her iki durumu da olması gerektiği gibi mümkün olduğunca iyi elde eder, ayrıca seçeneğin sıfırlanması sırasında bir başka bir sinyal bile işlenebilir.
    </para>
    <para>
     Kimi zaman, bir nesneye erişimin kesintiye uğratılmaması, nesnenin başka bir nesne tarafından korunması sağlanarak da sağlama alınabilir. <xref linkend="glibc-Merged-Signals"/> bölümünde bunun bir örneği vardır.
    </para>
   </sect2>
  </sect1>
 </chapter>

 <chapter xml:id="glibc-Interrupted-Primitives">
  <title>Sinyallerle Kesilen İlkeller</title>
  <titleabbrev><code>open, read, write</code> gibi işlevleri kesintiye uğratan sinyal işleyiciler.</titleabbrev>
  <para>
   <indexterm linkend="glibc-cp"><primary>EINTR</primary><secondary>kesmeye uğratılan ilkellerin yeniden başlatılması</secondary></indexterm>
   <indexterm linkend="glibc-cp"><primary>kesmeye uğratılan ilkellerin yeniden başlatılması</primary></indexterm>
   <indexterm linkend="glibc-cp"><primary>kesmeye uğratılan ilkeller</primary></indexterm>
   <indexterm linkend="glibc-cp"><primary>ilkeller</primary><secondary>kesme</secondary></indexterm>
   <function>open</function> veya <function>read</function> benzeri bir G/Ç ilkeli bir G/Ç aygıtını beklerken bir sinyal alabilir ve bu sinyal işleme sokulabilir. Sinyalin işleyicisi işlemlerini bitirdikten sonra sistem bir sorunla başbaşa kalır: Şimdi ne olacak?
  </para>
  <para>
   POSIX bir yaklaşım belirtir: bir ilkel başarısız olduğunda ne yapacaksan beklemeden yap. Bu çeşit başarısızlıklar için hata kodu <varname>EINTR</varname>'dir. Genellikle, sinyal işleyiciler kullanan POSIX uygulamalarının bu hatayı döndüren her işlev çağrısının dönüş durumuna mutlaka bakması gerekir. Çoğunlukla yazılımcılar bu genel hata kaynağına bakmayı unutur.
  </para>
  <para>
   &glibc;, geçici bir başarısızlığın ardından çağrının yinelenmesini sağlayan oldukça kullanışlı bir yöntem olan <varname>TEMP_FAILURE_RETRY</varname> makrosunu içerir:
  </para>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-TEMP_FAILURE_RETRY"><primary>TEMP_FAILURE_RETRY</primary></indexterm>
   <csproto type="makro">
    <csname><type>long&#160;int</type><function>TEMP_FAILURE_RETRY</function></csname>
    <csparam><parameter>expression</parameter></csparam>
   </csproto>
   <header>&unistd.h;</header>
   <para>
    Bu makro <parameter>expression</parameter> ifadesini bir kere değerlendirir ve <type>long&#160;int</type> türünde döner. Eğer değer <code>-1</code> ise bu bir başarısızlık gösterir ve <varname>errno</varname> değişkenine hata durumu atanır. Eğer başarısız olursa ve <varname>EINTR</varname> hata kodunu raporlarsa, <code>TEMP_FAILURE_RETRY</code> onu tekrar değerlendirmeye tabi tutar ve bu işlem geçici başarısızlık durumu ortadan kalkana dek yinelenir.
   </para>
   <para>
    <code>TEMP_FAILURE_RETRY</code> makrosunun dönüş değeri <parameter>expression</parameter> ifadesininin sonucudur.
   </para>
  </csynopsis>
  <para>
   BSD, <varname>EINTR</varname> hata kodunu hiç göstermez ve daha iyi bir yaklaşım yapar: kesintiye uğratılan ilkeli başarısız olarak döndürmez ve hep yeniden başlatır. Bu yaklaşım benimsenirse <varname>EINTR</varname> ile ilgilenmek gerekmez.
  </para>
  <para>
   &glibc;ndeki yaklaşım seçilirse, bir sinyal işleyici <function>sigaction</function> ile kurulabilir ve işleyicinin nasıl davranacağı belirtilebilir. <varname>SA_RESTART</varname> seçeneğini belirtilirse, işleyici döndükten sonra ilkel kaldığı yerden işleme devam eder, belirtilmezse işleyici <varname>EINTR</varname> hatasının dönmesine sebep olur. Bkz. <xref linkend="glibc-Flags-for-Sigaction"/>.
  </para>
  <para>
   Seçimi belirtmenin diğer bir yolu da <function>siginterrupt</function> işlevidir. Bkz. <xref linkend="glibc-BSD-Handler"/>.
  </para>
  <para>
   Bir sinyal işleyicinin ne yapacağını <function>sigaction</function> veya <function>siginterrupt</function> ile belirtilmezse, varsayılan seçim kullanılır. &glibc;nde varsayılan seçim yazılımcının tanımladığı sınama makrolarına bağlıdır. <function>signal</function> işlevini çağırmadan önce <varname>_BSD_SOURCE</varname> veya <varname>_GNU_SOURCE</varname> makrosu tanımlanırsa, varsayılan davranış ilkelin işlemi kaldığı yerden devam ettirmesidir; aksi takdirde, varsayılan davranış <varname>EINTR</varname> ile başarısızlık olacaktır. (Kütüphane <function>signal</function> işlevinin diğer sürümlerini de içerir ve özellik sınama makroları gerçekte hangisinin kullanılacağının saptanmasını sağlar.) Bkz. <xref linkend="glibc-Feature-Test-Macros"/>.
  </para>
  <para>
   Bu kısımda bahsedilen her ilkel, hata kodu olarak <varname>EINTR</varname> döndürebilen ilkellerden biridir.
  </para>
  <para>
   Seçimden etkilenmeyen ve işlemin kaldığı yerden devamına konu olmayan tek bir durum vardır: <function>read</function> veya <function>write</function> gibi bir veri aktarım işlevi verinin bir parçasını aktardıktan sonra bir sinyal aldığında. Bu durumda işlev zaten, kısmi başarıyı belirtmek üzere aktarılan baytların sayısı ile dönecektir.
  </para>
  <para>
   Bunun en başta kayıt yönlenimli aygıtlarda (veri katarı soketleri gibi; bkz. <xref linkend="glibc-Datagrams"/>) beklenmeyen davranışlara sebep olduğu görülür; bir <function>read</function> veya <function>write</function> işleminin ikiye bölünmesi iki okuma ya da yazmaya sebep olur. Aslında, bir sorun yoktur, çünkü böyle aygıtlarda bir kısmi aktarım sonrası kesme oluşamaz; bunlar bir kaydın tümünü veri aktarımı bir kez başladı mı beklemeksizin tek bir seferde aktarır.
  </para>
 </chapter>
 <chapter xml:id="glibc-Generating-Signals">
  <title>Sinyallerin Üretilmesi</title>
  <titleabbrev>Bir sinyal bir sürece nasıl gönderilir.</titleabbrev>
  <preliminary>
   <para>
    <indexterm linkend="glibc-cp"><primary>sinyaller</primary><secondary>gönderilmesi</secondary></indexterm>
    <indexterm linkend="glibc-cp"><primary>sinyaller</primary><secondary>üretilmesi</secondary></indexterm>
    Sinyallerin bir donanım tuzağının ya da kesmesinin sonucu olarak üretilmesine ilaveten, yazılımınız da kendisine ya da başka süreçlere doğrudan doğruya sinyal gönderebilir.
   </para>
  </preliminary>
  <sect1 xml:id="glibc-Signaling-Yourself">
   <title>Kendine Sinyal Göndermek</title>
   <titleabbrev>Bir süreç kendine nasıl sinyal gönderir.</titleabbrev>
   <para>
    <indexterm linkend="glibc-pg"><primary>signal.h</primary></indexterm>
    Bir sürecin kendine sinyal göndermesi için <function>raise</function> işlevi kullanılır. Bu işlev &signal.h; başlık dosyasında bildirilmiştir.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-raise"><primary>raise</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-raise"><primary>sinyaller</primary><secondary>kendine gönderme</secondary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>raise</function></csname>
     <csparam><type>int</type><parameter>signum</parameter></csparam>
    </csproto>
    <header>&signal.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     <code>raise</code> işlevi çağrıldığı sürece <parameter>signum</parameter> sinyalini gönderir. İşlem başarılı olursa sıfırla, aksi takdirde sıfırdan farklı bir değerle döner. Başarısızlığın tek sebebi <parameter>signum</parameter> değerinin geçersiz olmasıdır.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-gsignal"><primary>gsignal</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>gsignal</function></csname>
     <csparam><type>int</type><parameter>signum</parameter></csparam>
    </csproto>
    <header>&signal.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     <code>gsignal</code> işlevi <function>raise</function> ile aynı işi yapar; sadece SVID uyumluluğu için vardır.
    </para>
   </csynopsis>
   <para>
    <function>raise</function> işlevinin genellikle kullanıldığı tek yer yakalanan sinyalin varsayılan davranışını yeniden üretmektir. Örneğin, yazılımın bir kullanıcı <varname>SUSP</varname> karakterini (<keycap>C-z</keycap>; bkz. <xref linkend="glibc-Special-Characters"/>) tuşlamış olsun. Bu işlem yazılıma etkileşimli durdurma sinyalinin (<varname>SIGTSTP</varname>) gönderilmesine sebep olur. Bu durumda durdurma öncesi bazı tamponların temizlenmesi gerekir.
   </para>
   <example>
    <screen>#include &lt;signal.h&gt;

/* <replaceable>Bir durdurma sinyali geldiğinde, eylemi önce
   varsayılan eyleme ayarla, temizliği yaptıktan
   sonra sinyali yeniden gönder.</replaceable> */

void
tstp_isleyici (int sig)
{
  signal (SIGTSTP, SIG_DFL);
  /* <replaceable>Burada temizlik işlemleri var.</replaceable> */
  …
  raise (SIGTSTP);
}

/* <replaceable>Süreç çalışmaya kaldığı yerden devam
   edeceği zaman sinyal işleyiciyi yeniden kur.</replaceable> */

void
cont_isleyici (int sig)
{
  signal (SIGCONT, cont_isleyici);
  signal (SIGTSTP, tstp_isleyici);
}

/* <replaceable>Yazılım başlatıldığında iki işleyiciyi de etkinleştir.</replaceable> */

int
main (void)
{
  signal (SIGCONT, cont_isleyici);
  signal (SIGTSTP, tstp_isleyici);
  …
}
</screen>
   </example>
   <note><title>Taşınabilirlik Bilgisi</title>
    <para>
     <function>raise</function> işlevi &isoc; komisyonu tarafından tasarlanmıştır. Daha eski sistemler işlevi desteklemeyebilir, bu bakımdan <function>kill</function> işlevinin kullanılması daha taşınabilir olacaktır. Bkz. <xref linkend="glibc-Signaling-Another-Process"/>.
    </para>
   </note>
  </sect1>
  <sect1 xml:id="glibc-Signaling-Another-Process">
   <title>Başka Bir Sürece Sinyal Göndermek</title>
   <titleabbrev>Bir sinyalin başka bir sürece gönderilmesi.</titleabbrev>
   <para>
    <indexterm linkend="glibc-cp"><primary>bir sürecin öldürülmesi</primary></indexterm>
    <function>kill</function> işlevi bir sinyalin başka bir sürece gönderilmesi için kullanılır. İsmine rağmen, bir sürecin sonlandırılmasına sebep olmaktan farklı bir şeyler yapmak için de kullanılabilir. Süreçler arasında sinyal gönderilmesini gerektiren durumlara ilişkin bazı örnekler:
   </para>
   <simplelist>
    <member>
     Bir süreç bir işlemi yerine getirmek için kendini bir alt süreç olarak çalıştırabilir -- bir alt süreç çalıştırılması bir kısır döngü oluşturabilir -- ve işlem yerine getirildiğinde alt sürecini sonlandırabilir.
    </member>
    <member>
     Bir hata oluştuğunda ya da bir olay gerçekleştiğinde, bir süreç, bir grubun parçası olarak çalıştırılıp gruptaki başka bir süreci uyarmak ya da sonlandırmak için kullanılabilir.
    </member>
    <member>
     Birlikte çalışan iki sürecin eşzamanlanması gerekebilir.
    </member>
   </simplelist>
   <para>
    Bu bölümde <link linkend="glibc-Processes">bir sürecin nasıl çalıştığı</link>nın bilindiği varsayılacaktır.
   </para>
   <para>
    <function>kill</function> işlevi &signal.h; başlık dosyasında bildirilmiştir.
    <indexterm linkend="glibc-pg"><primary>signal.h</primary></indexterm>
   </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-kill"><primary>kill</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-kill"><primary>sinyaller</primary><secondary>başka bir sürece</secondary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>kill</function></csname>
     <csparam><type>pid_t</type><parameter>pid</parameter></csparam>
     <csparam><type>int</type><parameter>signum</parameter></csparam>
    </csproto>
    <header>&signal.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     <code>kill</code> işlevi <parameter>pid</parameter> ile belirtilen süreç ya da süreç grubuna <parameter>signum</parameter> sinyalini gönderir. <xref linkend="glibc-Standard-Signals"/> bölümünde listelenen sinyallere ilaveten, ayrıca <parameter>pid</parameter> süreç kimliğini doğrulamak için sıfır değeri de kullanılabilir.
    </para>
    <para>
     Sinyal alacak süreç veya süreç grubunu belirten <parameter>pid</parameter> değerleri ve anlamları:
    </para>
    <glosslist>
     <glossentry>
      <glossterm>
       <parameter>pid</parameter><code>&nbsp;&gt;&nbsp;0</code>
      </glossterm>
      <glossdef>
       <para>
        Belirteci <parameter>pid</parameter> olan süreç. (Linux'ta <parameter>pid</parameter> süreçten başka evrenin de kimliği olsa bile sinyal sürecin tamamına gönderilir.)
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm>
       <parameter>pid</parameter><code>&nbsp;==&nbsp;0</code>
      </glossterm>
      <glossdef>
       <para>
        Gönderen ile aynı gruptaki süreçlerin tümü.
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm>
       <parameter>pid</parameter><code>&nbsp;&lt;&nbsp;-1</code>
      </glossterm>
      <glossdef>
       <para>
        Belirteci <parameter>-pid</parameter> olan süreç grubu.
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm>
       <parameter>pid</parameter><code>&nbsp;==&nbsp;-1</code>
      </glossterm>
      <glossdef>
       <para>
        Süreç ayrıcalıklı ise, sinyal, bazı özel sistem süreçleri dışında kalan tüm süreçlere gönderilir. Aksi takdirde, sinyal, aynı etkin kullanıcı kimlikli tüm süreçlere gönderilir.
       </para>
      </glossdef>
     </glossentry>
    </glosslist>
    <para>
     Bir süreç <code>kill (getpid(), <parameter>signum</parameter>)</code> gibi bir çağrı ile kendisine sinyal gönderebilir ve sinyal engellenmez, sonrasında <code>kill</code> dönmeden önce sürece en az bir sinyal gönderir (<parameter>signum</parameter> yerine beklemede olan engellenmeyen sinyaller gidebilir).
    </para>
    <para>
     Sinyal gönderme başarılı olduğunda <code>kill</code> sıfır ile döner. Aksi takdirde sinyal gönderilmemiş demektir ve <code>-1</code> ile döner. Eğer <parameter>pid</parameter> bir sinyalin birden fazla sürece gönderilmesini belirtiyorsa, en azından bir sürece sinyal gönderilebilmişse <code>kill</code> sıfır ile dönecektir. Sinyali alan ve almayan süreçlerin hangileri olduğunu saptayacak bir yöntem yoktur.
    </para>
    <para>
     Bu işlev için tanımlanmış olan <varname>errno</varname> değerleri:
    </para>
    <glosslist>
     <glossentry>
      <glossterm><code>EINVAL</code></glossterm>
      <glossdef>
       <para>
        <parameter>signum</parameter> geçersiz ya da desteklenmeyen bir numara.
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm><code>EPERM</code></glossterm>
      <glossdef>
       <para>
        <parameter>pid</parameter> ile belirtilen sürece ya da süreç grubundaki herhangi bir sürece bir sinyal gönderme yetkiniz yok.
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm><code>ESRCH</code></glossterm>
      <glossdef>
       <para>
        <parameter>pid</parameter> mevcut süreç veya grup ile ilgili değil.
       </para>
      </glossdef>
     </glossentry>
    </glosslist>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-tgkill"><primary>sinyaller</primary><secondary>bir sürecin belli bir evresine</secondary></indexterm>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-tgkill"><primary>tgkill</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>tgkill</function></csname>
     <csparam><type>pid_t</type><parameter>pid</parameter></csparam>
     <csparam><type>pid_t</type><parameter>tid</parameter></csparam>
     <csparam><type>int</type><parameter>signum</parameter></csparam>
    </csproto>
    <header>&signal.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     <code>tgkill</code> işlevi, yalnızca <parameter>tid</parameter> kimlikli evrenin süreç kimliği <parameter>pid</parameter> ise, <function>kill</function> işlevi gibi <parameter>tid</parameter> kimlikli evre veya sürece <parameter>signum</parameter> sinyalini gönderir. Hedef evre başka bir sürece aitse işlev <varname>ESRCH</varname> hata koduyla başarısız olur.
    </para>
    <para>
     Çağrıcı, <parameter>pid</parameter> değerinin çekirdek tarafından (başka bir süreç için) yeniden kullanılmadığından eminse (örneğin, geçerli sürecin süreç kimliği <function>getpid</function> tarafından döndürülen ile aynıysa) <code>tgkill</code> işlevi, yanlış süreçteki bir evreye sinyal gönderilmesini önlemek için kullanılabilir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-killpg"><primary>killpg</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>killpg</function></csname>
     <csparam><type>int</type><parameter>pgid</parameter></csparam>
     <csparam><type>int</type><parameter>signum</parameter></csparam>
    </csproto>
    <header>&signal.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     <parameter>signum</parameter> sinyalini <parameter>pgid</parameter> ile belirtilen süreç grubuna göndermesi dışında <function>kill</function> gibidir. Bu işlev BSD uyumluluğu için vardır. Bunun yerine <function>kill</function> kullanmak yazılımı daha taşınabilir yapar.
    </para>
   </csynopsis>
   <para>
    <function>kill</function> kullanımına basit bir örnek olan <code>kill&nbsp;(getpid&nbsp;(),&nbsp;<replaceable>sinyal</replaceable>)</code> çağrısı ile <code>raise&nbsp;(<replaceable>sinyal</replaceable>)</code> çağrısının etkisi aynıdır.
   </para>
  </sect1>
  <sect1 xml:id="glibc-Permission-for-kill">
   <title><code>kill</code> ile İlgili Sınırlamalar</title>
   <titleabbrev><code>kill</code> kullanım yetkileri.</titleabbrev>
   <para>
    Herhangi bir sürece <function>kill</function> kullanarak sinyal gönderilmesini engelleyen bazı sınırlamalar vardır. Bunlar, başka bir kullanıcının bir süreci kendi kararının bir sonucu olarak öldürmesi gibi asosyal davranışlara karşı tasarlanmıştır. <function>kill</function> genellikle bir sürecin kendi alt süreçlerine ve kardeş süreçler arasında sinyal gönderilmesi için kullanılır ve bu çeşit kullanımda yetkiler yeterli olur. Alışılmışın dışında olan tek durum bir alt süreç olarak bir setuid yazılımın çalıştığı durumdur; eğer yazılım sürecin hem gerçek hem de etkin kullanıcı kimliğini değiştiriyorsa, sürece sinyal gönderecek yetkiniz olmayabilir. <uri xl:href="man1-su"/> komutu bunu yapar.
   </para>
   <para>
    Bir sürece sinyal gönderme yetkisi olup olmadığına iki sürecin kullanıcı kimliklerine bakarak karar verilir. Bu kavram <xref linkend="glibc-Process-Persona"/> bölümünde ayrıntılı olarak açıklanmıştır.
   </para>
   <para>
    Genelde, bir sürecin başka bir sürece sinyal gönderebilmesi için ya gönderen süreç ayrıcalıklı kullanıcıya ait olmalı (<code>root</code> gibi) ya da gönderen sürecin gerçek ve etkin kullanıcı kimliği alan sürecinki ile aynı olmalıdır. Eğer alan süreç kendi süreç imge dosyasında set-user-ID bitiyle etkin kullanıcı kimliğini değiştirirse, etkin kullanıcı kimlik yerine süreç imge dosyasının sahibi kullanılır. Bazı gerçeklemelerde, bir süreç kendi alt sürecine kullanıcı kimlikleri aynı olmasa da sinyal gönderebilirken bazıları da başka sınırlamalar getirebilir.
   </para>
   <para>
    <varname>SIGCONT</varname> sinyali özel bir durumdur. Eğer gönderici ve alıcı  aynı oturumun parçaları ise, kullanıcı kimliklerine bakılmaksızın <varname>SIGCONT</varname> sinyali gönderilebilir.
   </para>
  </sect1>
  <sect1 xml:id="glibc-Kill-Example">
   <title><code>kill</code> Örneği</title>
   <titleabbrev>İletişimde <code>kill</code> kullanımı.</titleabbrev>
   <para>
    <indexterm linkend="glibc-cp"><primary>süreçler arası iletişim</primary><secondary>sinyallerle</secondary></indexterm>
    Burada süreçler arası iletişim için sinyallerin kullanıldığı daha kapsamlı bir örneğe yer verilmiştir. <varname>SIGUSR1</varname> ve <varname>SIGUSR2</varname> sinyalleri ile neler yapılabileceği gösterilmiştir. Bu sinyaller varsayılan olarak ölümcül olduklarından, sürecin bu sinyalleri <function>signal</function> veya <function>sigaction</function> ile yakalayacakları varsayılır.
   </para>
   <example>
    <para>
     Bu örnekte, bir süreç bir alt süreci çatalladıktan sonra alt sürecin kendini ilklendirmesini beklemekte, alt süreç ise <function>kill</function> işlevini bir <varname>SIGUSR1</varname> sinyalini göndermek için kullanarak hazır olduğunu bildirmektedir.
    </para>
    <screen>#include &lt;signal.h&gt;
#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;


/* <replaceable><code>SIGUSR1</code> sinyali alındığında bu değişken 1 olacak.</replaceable> */
volatile sig_atomic_t usr_interrupt = 0;

void
synch_signal (int sig)
{
  usr_interrupt = 1;
}

/* <replaceable>Bu işlevi alt süreç çalıştıracak.</replaceable> */
void
child_function (void)
{
  /* <replaceable>İlklendir.</replaceable> */
  printf ("Hazirim!!!  Surec kimligim: %d.\n", (int) getpid ());

  /* <replaceable>Üst sürece bunu bildir.</replaceable> */
  kill (getppid (), SIGUSR1);

  /* <replaceable>Bilgilendirme bitti, işbaşı!.</replaceable> */
  puts (""Simdilik hoscakal...."");
  exit (0);
}

int
main (void)
{
  struct sigaction usr_action;
  sigset_t block_mask;
  pid_t child_id;

  /* <replaceable> Sinyal işleyiciyi kur.</replaceable> */
  sigfillset (&amp;block_mask);
  usr_action.sa_handler = synch_signal;
  usr_action.sa_mask = block_mask;
  usr_action.sa_flags = 0;
  sigaction (SIGUSR1, &amp;usr_action, NULL);

  /* <replaceable>Alt süreci oluştur.</replaceable> */
  child_id = fork ();
  if (child_id == 0)
    child_function ();          /* <replaceable>Bir şey dönmeyecek.</replaceable> */


  /* <replaceable>Alt sürecin sinyal göndermesini bekle.</replaceable> */
  while (!usr_interrupt)
    ;


  /* <replaceable>Alt süreç hazır, işbaşı!.</replaceable> */
  puts ("Bu kadar!");

  return 0;
}
</screen>
    <para>
     Bu örnekte beklerken işlemci meşgul ediliyor, bu iyi değil, işlemciyi kullanabilecek başka süreçler engelleniyor. Sinyalin gelip gelmediğini sisteme sormak daha iyidir. <xref linkend="glibc-Waiting-for-a-Signal"/> bölümünde böyle bir örnek var.
    </para>
   </example>
  </sect1>
 </chapter>

 <chapter xml:id="glibc-Blocking-Signals">
  <title>Sinyallerin Engellenmesi</title>
  <titleabbrev>Sistemin sinyalleri geçici olarak engellemesinin sağlanması.</titleabbrev>
  <preliminary>
   <para>
    <indexterm linkend="glibc-cp"><primary>sinyaller</primary><secondary>engellenmesi</secondary></indexterm>
    Sinyal engelleme işlemi daha sonra alınmak üzere işletim sisteminin sinyali tutmasını sağlamaktır. Genelde, bir yazılım sinyalleri sonsuza kadar engelleyemez ama eylemlerini <varname>SIG_IGN</varname> ile yok sayabilir. Ancak, önemli işlemleri yapabilecek kadar kısa bir süre için sinyalleri engellemek daha iyidir. Örneğin,
   </para>
   <simplelist>
    <member>
     Bu sinyallerin işleyicileri tarafından değiştirilen genel değişkenleri ayarlayana kadar sinyalleri engellemek için <function>sigprocmask</function> işlevi kullanılabilir.
    </member>
    <member>
     Belli bir sinyal işleyici çalışırken sinyallerin engellenmesi için <type>struct&nbsp;sigaction</type> veri yapısının <code>sa_mask</code> üyesi kullanılabilir. Böylece sinyal işleyicinin başka sinyallerle kesintiye uğratılması engellenmiş olur.
    </member>
   </simplelist>
  </preliminary>
  <sect1 xml:id="glibc-Why-Block">
   <title>Sinyalleri Engellemenin Amaçları</title>
   <titleabbrev>Sinyallerin engellenmesinin faydaları.</titleabbrev>
   <para>
    Sinyalleri <function>sigprocmask</function> ile engelleyerek yazılımın önemli kısımlarının kesmelerden korunması sağlanabilir. Yazılımınn bu kısımları etkinken bir sinyal gelirse sinyalin engellenmesi kaldırılınca o sinyal tekrar alınabilir.
   </para>
   <para>
    Buna kullanışlı bir örnek, sinyal işleyici ile yazılımın diğer kısımları arasında veri paylaşımıdır. Veri türü <type>sig_atomic_t</type> (bkz. <xref linkend="glibc-Atomic-Data-Access"/>) değilse yazılım bu veriyi okur ya da yazarken işlemin ortasında sinyal işleyici çalışmaya başlarsa işlemin yarıda kalması sorunlara yol açabilir.
   </para>
   <para>
    Yazılımın düzgün çalışabilmesi için verinin işlenmesi sırasında sinyallerin alınması engellenerek sinyal işleyicinin çalışmaması sağlanabilir.
   </para>
   <para>
    Ayrıca, belli bir eylemin sadece sinyal gelmediğinde gerçekleştirilmesi gerekiyorsa sinyallerin engellenmesi gereklidir. Bir sinyal işleyicinin <type>sig_atomic_t</type> türünde bir değişkene değer atadığı ve yazılımın eylemi gerçekleştirmeden önce bu değişkenin değerine baktığı varsayılsın. Bu yöntem güvenilir değildir. Bu değişkenin değerine baktıktan hemen sonra eylem gerçekleştirilmeden bir sinyal gelebilir.
   </para>
   <para>
    Bir sinyalin alınıp alınmadığına bakmanın en güvenilir yolu sinyali engelleyerek değişkenin değerine bakmaktır.
   </para>
  </sect1>
  <sect1 xml:id="glibc-Signal-Sets">
    <title>Sinyal Kümeleri</title>
    <titleabbrev>Hangi sinyallerin engelleneceği nasıl belirtilir.</titleabbrev>
    <para>
     <indexterm linkend="glibc-cp"><primary>sinyal kümesi</primary></indexterm>
     Sinyal engeleme işlevlerinin tümü <wordasword>sinyal kümesi</wordasword> adı verilen bir veri yapısını kullanır. Bu işlem iki aşamada yapılır: Sinyal kümesi oluşturulur ve bağımsız değişken üzerinden bir kütüphane işlevine aktarılır.
    </para>
    <para>
     Bu oluşumlar &signal.h; başlık dosyasında bildirilmiştir.
     <indexterm linkend="glibc-pg"><primary>signal.h</primary></indexterm>
    </para>
    <csynopsis>
     <indexterm linkend="glibc-tp" xml:id="glibc-tp-sigset_t"><primary>sigset_t</primary></indexterm>
     <csproto type="veri türü">
      <csname><function>sigset_t</function></csname>
     </csproto>
     <header>&mcheck.h;</header>
     <para>
      <code>sigset_t</code> veri türü bir sinyal kümesi oluşturmak için kullanılır. Kütüphane içinde bir tamsayı tür ya da bir yapı olarak gerçekleştirilmiş olabilir.
    </para>
    <para>
     Taşınabilirlik açısından, <code>sigset_t</code> nesnesi içindeki veriyi okuma ve değiştirme işlemleri doğrudan değil, bu bölümde açıklanan işlevler kullanılarak yapılmalıdır.
    </para>
   </csynopsis>
   <para>
    Bir sinyal kümesini oluşturmanın iki yolu vardır. <function>sigemptyset</function> ile boş olduğunu belirtilip sinyaller tek tek eklenir. Ya da, <function>sigfillset</function> ile tüm sinyallerin içerildiği belirtilip sinyaller tek tek silinir.
   </para>
   <para>
    Herhangi bir işlem yapmadan önce sinyal kümesi bu iki işlevden biri kullanılarak ilklendirilmelidir. Sinyal kümesinde bu işlevler kullanılmadan sinyal ekleme ya da silme yapılmamalıdır, çünkü <type>sigset_t</type> nesnesinde ilklendirilmesi gereken başka alanlar da (sürüm alanı gibi) olabilir. (Ek olarak, sistemin bilinenler dışında sinyaller içermediği kabulünü yapmak pek akıllıca olmayacaktır.)
   </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-sigemptyset"><primary>sigemptyset</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>sigemptyset</function></csname>
     <csparam><ptr>sigset_t</ptr><parameter>set</parameter></csparam>
    </csproto>
    <header>&signal.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     Bu işlev <parameter>set</parameter> sinyal kümesini tanımlı hiçbir sinyali içermeden ilklendirir. Daima <code>0</code> ile döner.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-sigfillset"><primary>sigfillset</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>sigfillset</function></csname>
     <csparam><ptr>sigset_t</ptr><parameter>set</parameter></csparam>
    </csproto>
    <header>&signal.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     Bu işlev <parameter>set</parameter> sinyal kümesini tanımlı tüm sinyalleri içererek ilklendirir. Daima <code>0</code> ile döner.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-sigaddset"><primary>sigaddset</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>sigaddset</function></csname>
     <csparam><ptr>sigset_t</ptr><parameter>set</parameter></csparam>
     <csparam><type>int</type><parameter>signum</parameter></csparam>
    </csproto>
    <header>&signal.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     Bu işlev <parameter>signum</parameter> sinyalini <parameter>set</parameter> sinyal kümesine ekler. Tüm <code>sigaddset</code> çağrıları sadece <parameter>set</parameter> sinyal kümesini değiştirir, sinyal engelleme/engellememe yapmaz.
    </para>
    <para>
     Başarılı olursa <code>0</code>, aksi takdirde <code>-1</code> ile döner. Aşağıdaki <varname>errno</varname> değeri bu işlev için tanımlanmıştır:
    </para>
    <formalpara><title><code>EINVAL</code></title>
     <para>
      <parameter>signum</parameter> bağımsız değişkeni geçerli bir sinyal belirtmiyor.
     </para>
    </formalpara>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-sigdelset"><primary>sigdelset</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>sigdelset</function></csname>
     <csparam><ptr>sigset_t</ptr><parameter>set</parameter></csparam>
     <csparam><type>int</type><parameter>signum</parameter></csparam>
    </csproto>
    <header>&signal.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     Bu işlev <parameter>signum</parameter> sinyalini <parameter>set</parameter> sinyal kümesine ekler. Tüm <code>sigaddset</code> çağrıları sadece <parameter>set</parameter> sinyal kümesini değiştirir, sinyal engelleme/engellememe yapmaz. Dönüş değeri ve hata durumları <function>sigaddset</function> işlevi ile aynıdır.
    </para>
   </csynopsis>
   <para>
    Son olarak, bir sinyalin sinyal kümesinde olup olmadığına bakmak için kullanılan bir işlev vardır:
   </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-sigismember"><primary>sigismember</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>sigismember</function></csname>
     <csparam><ptr>const&nbsp;sigset_t</ptr><parameter>set</parameter></csparam>
     <csparam><type>int</type><parameter>signum</parameter></csparam>
    </csproto>
    <header>&signal.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     <code>sigismember</code> işlevi <parameter>signum</parameter> sinyalinin <parameter>set</parameter> sinyal kümesinin bir üyesi olup olmadığına bakmak için kullanılır. Sinyal, kümenin bir elemanı ise <code>1</code> ile, değilse <code>0</code> ile, bir hata oluşmuşsa <code>-1</code> ile döner.
    </para>
    <para>
     Aşağıdaki <varname>errno</varname> değeri bu işlev için tanımlanmıştır:
    </para>
    <formalpara><title><code>EINVAL</code></title>
     <para>
      <parameter>signum</parameter> bağımsız değişkeni geçerli bir sinyal belirtmiyor.
     </para>
    </formalpara>
   </csynopsis>
  </sect1>
  <sect1 xml:id="glibc-Process-Signal-Mask">
   <title>Sürecin Sinyal Maskesi</title>
   <titleabbrev>Normal çalışma sırasında sürece gelen sinyallerin engellenmesi.</titleabbrev>
   <para>
    <indexterm linkend="glibc-cp"><primary>sinyal maskesi</primary></indexterm>
    <indexterm linkend="glibc-cp"><primary>süreç sinyal maskesi</primary></indexterm>
    Engellenen sinyallerden oluşan küme <wordasword>sinyal maskesi</wordasword> olarak adlandırılır. Her sürecin kendine özgü bir sinyal maskesi vardır. Yeni bir <link linkend="glibc-Creating-a-Process">süreç oluşturulduğunda</link>, süreç sinyal maskesini onu çalıştıran süreçten miras alır. Bu sinyal maskesi değiştirilerek sinyaller tam bir esneklikle engellenebilir ya da engellenmeyebilir.
   </para>
   <para>
    <function>sigprocmask</function> işlevi &signal.h; başlık dosyasında bildirilmiştir.
    <indexterm linkend="glibc-pg"><primary>signal.h</primary></indexterm>
   </para>
   <para>
    Her evre kendi sinyal maskesine sahip olduğundan ve dolayısıyla sürecin tek bir sinyal maskesi olmadığından çok evreli süreçlerde <function>sigprocmask</function> işlevi kullanılmamalıdır. POSIX'e göre, çok evreli bir süreçte <function>sigprocmask</function> davranışı "belirsizdir". Yerine <function>pthread_sigmask</function> işlevi kullanılmalıdır.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-sigprocmask"><primary>sigprocmask</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>sigprocmask</function></csname>
     <csparam><type>int</type><parameter>how</parameter></csparam>
     <csparam><type>const&nbsp;sigset_t&nbsp;*restrict</type><parameter>set</parameter></csparam>
     <csparam><type>sigset_t&nbsp;*restrict</type><parameter>oldset</parameter></csparam>
    </csproto>
    <header>&signal.h;</header>
    <conceptlist>
     <concept>&mtunsafe; &race;<code linkend="glibc-safety-identifier">:sigprocmask</code><code linkend="glibc-safety-condition">/bsd(SIG_UNBLOCK)</code></concept>
     <concept>&asunsafe; &lock;<code linkend="glibc-safety-condition">/hurd</code></concept>
     <concept>&acunsafe; &lock;<code linkend="glibc-safety-condition">/hurd</code></concept>
    </conceptlist>
    <para>
     <code>sigprocmask</code> işlevi çağrıldığı sürecin sinyal maskesini değiştirmek ya da okumak için kullanılır. <parameter>how</parameter> bağımsız değişkeni ile sinyal maskesinin nasıl değiştirileceği aşağıdaki değerlerden biri ile belirtilmelidir:
    </para>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-SIG_BLOCK"><primary>SIG_BLOCK</primary></indexterm>
     <csproto type="sabit">
      <csname><function>SIG_BLOCK</function></csname>
     </csproto>
     <para>
      <parameter>set</parameter> kümesi içindeki sinyaller engellensin--mevcut maskeye eklensin. Başka bir deyişle, yeni maske, <parameter>oldset</parameter> ile <parameter>set</parameter> kümesinin birleşimi olur.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-SIG_UNBLOCK"><primary>SIG_UNBLOCK</primary></indexterm>
     <csproto type="sabit">
      <csname><function>SIG_UNBLOCK</function></csname>
     </csproto>
     <para>
      <parameter>set</parameter> kümesi içindeki sinyaller engellenmesin--mevcut maskeden kaldırılsın.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-SIG_SETMASK"><primary>SIG_SETMASK</primary></indexterm>
     <csproto type="sabit">
      <csname><function>SIG_SETMASK</function></csname>
     </csproto>
     <para>
      Sinyal maskesi için <parameter>set</parameter> kullanılsın; önceki maske yok sayılsın.
     </para>
    </csynopsis>
    <para>
     Son bağımsız değişken olan <parameter>oldset</parameter> sürecin eski maskesi hakkında bilgi döndürmek için kullanılır. Eski maskeye bakmaksızın maske değiştirilmek istenirse <parameter>oldset</parameter> bağımsız değişkeni ile boş gösterici aktarılmalıdır. Benzer şekilde, maskeyi değiştirmeksizin mevcut maske hakkında bilgi almak için <parameter>set</parameter> bağımsız değişkeni ile boş gösterici aktarılmalıdır (bu durumda <parameter>how</parameter> bağımsız değişkeninin önemi yoktur). <parameter>oldset</parameter> bağımsız değişkeni çoğunlukla, sinyal maskesini daha sonra eski durumuna getirmek için mevcut durum bilgisini almak gerektiğinde kullanılır. (Sinyal maskesi <function>fork</function> ve <function>exec</function> çağrıları üzerinden miras alındığından, yazılım çalışmaya başlamadan içeriği hakkında bilgi edinmek mümkün değildir.)
    </para>
    <para>
     <code>sigprocmask</code> çağrısı bekleyen sinyallerin alınmasına sebep olacağından <code>sigprocmask</code> dönmeden önce bu sinyallerden en az biri alınmış olacaktır. Bekleyen sinyallerin hangisinin önce alınacağı belli olmaz, ancak her sinyal için ayrı ayrı <code>sigprocmask</code> çağrısı yaparak hangi sinyalin önce alınacağı belirlenebilir.
    </para>
    <para>
     <code>sigprocmask</code> işlevi başarılı olduğunda <code>0</code> ile döner. <code>-1</code> ile dönmüşse bir hata var demektir. Aşağıdaki <varname>errno</varname> değeri bu işlev için tanımlanmıştır:
    </para>
    <formalpara><title><code>EINVAL</code></title>
     <para>
      <parameter>how</parameter> bağımsız değişkeni geçersiz.
     </para>
    </formalpara>
    <para>
     <varname>SIGKILL</varname> ve <varname>SIGSTOP</varname> sinyalleri engellenemez, ama sinyal kümesi bunları içerebilir. Bu durumda <code>sigprocmask</code> hata döndürmez basitçe onları yok sayar.
    </para>
    <para>
     Bir yazılım hatası sonucu olarak (<function>raise</function> veya <function>kill</function> ile gönderilen sinyallerin aksine) üretilen <varname>SIGFPE</varname> gibi yazılım hata sinyallerinin engellenmesinin, istenmeyen sonuçlara yol açacağı unutulmamalıdır. Böyle bir durumda yazılım bozulmuş olacağından sinyallerin engellenmesi kaldırıldığında yazılım isteneni yapmayabilecektir. Bkz. <xref linkend="glibc-Program-Error-Signals"/>.
    </para>
   </csynopsis>
  </sect1>
  <sect1 xml:id="glibc-Testing-for-Delivery">
   <title>Sinyal Alımının Sınanması</title>
   <titleabbrev>Sinyal alım sınamasının engellenmesi</titleabbrev>
   <para>
    Basit bir örnek; yazılımda <varname>SIGALRM</varname> sinyali için bir işleyici oluşturulduğu, bununla bir değişkene değer atandığı ve zaman zaman yazılım içinde bu değişkene bakıldığı ve sıfırlandığı varsayılsın. Kodun önemli parçaları yürütülürken <varname>SIGALRM</varname> sinyallerinin alınması <function>sigprocmask</function> çağrıları ile aşağıdaki gibi engellenebilir:
   </para>
   <screen>/* <replaceable>Bu değişkene SIGALRM sinyal işleyicisi değer atayacak.</replaceable> */
volatile sig_atomic_t flag = 0;

int
main (void)
{
  sigset_t block_alarm;

  …

  /* <replaceable>Sinyal maskesini ilklendir.</replaceable> */
  sigemptyset (&amp;block_alarm);
  sigaddset (&amp;block_alarm, SIGALRM);

  while (1)
    {
      /* <replaceable>Bir sinyal gelmiş mi bak.
         Gelmişse değişkeni sıfırla.</replaceable> */
      sigprocmask (SIG_BLOCK, &amp;block_alarm, NULL);
      if (flag)
        {
          <replaceable>sinyal alınmamışsa yapılacak işlemler burada</replaceable>
          flag = 0;
        }
      sigprocmask (SIG_UNBLOCK, &amp;block_alarm, NULL);

      …
    }
}
</screen>
  </sect1>
  <sect1 xml:id="glibc-Blocking-for-Handler">
   <title>İşleyici Çalışırken Sinyallerin Engellenmesi</title>
   <titleabbrev>Sinyal işleyici çalışırken gelen diğer sinyallerin engellenmesi.</titleabbrev>
   <para>
    <indexterm linkend="glibc-cp"><primary>sinyaller</primary><secondary>engellenmesi</secondary><tertiary>bir işleyici içinde</tertiary></indexterm>
    Bir sinyal işleyici çalışmaya başladığında çalışmasının başka bir sinyal ile kesilmesi istenmez. İşleyici çalışmaya başlayıp, işini bitirene kadar çalışmasının ya da verisinin bozulmaması için sinyaller engellenmelidir.
   </para>
   <para>
    Bir işleyici işlev bir sinyal ile çalıştırıldığında bu sinyal (ve sürecin sinyal maskesindeki diğer sinyaller) özdevinimli olarak engellenir. Örneğin, <varname>SIGTSTP</varname> sinyali için bir işleyici varsa, bu işleyici çalışmaya başlayınca daha sonra gelen <varname>SIGTSTP</varname> sinyalleri işleyicinin çalışması süresince bekletilir.
    </para>
    <para>
     Bununla birlikte, diğer çeşit sinyallerin engellenmeyeceği ve işleyicinin çalışması sırasında gelebileceği varsayılır.
    </para>
    <para>
     İşleyicinin çalışması sırasında gelen farklı sinyalleri engellemenin en güvenilir yolu <type>struct&nbsp;sigaction</type> yapısının <code>sa_mask</code> üyesini kullanmaktır.
    </para>
    <example>
     <screen>#include &lt;signal.h&gt;
#include &lt;stddef.h&gt;

void catch_stop ();

void
install_handler (void)
{
  struct sigaction setup_action;
  sigset_t block_mask;

  sigemptyset (&amp;block_mask);
  /* <replaceable>İşleyici çalışırken uçbirimden
     kaynaklanan sinyaller engellensin.</replaceable> */
  sigaddset (&amp;block_mask, SIGINT);
  sigaddset (&amp;block_mask, SIGQUIT);
  setup_action.sa_handler = catch_stop;
  setup_action.sa_mask = block_mask;
  setup_action.sa_flags = 0;
  sigaction (SIGTSTP, &amp;setup_action, NULL);
}
</screen>
     <para>
      Bu, diğer sinyallerin işleyiciyi kesintiye uğratmasını engellemenin daha güvenilir bir yoludur. Ancak, sinyaller işleyici içinden doğrudan engellenirse, işleyicinin başlangıcında kısa bir süre için bu engelleme etkin olmayacaktır.
    </para>
    <para>
     Bu düzenek ile sürecin sinyal maskesinden sinyaller kaldırılamaz. Bununla birlikte, işleyici içinden yapılacak <function>sigprocmask</function> çağrıları ile bazı sinyallerin engellenmesi ya da engellenmemesi tercih edilebilir.
    </para>
    <para>
     Her durumda, işleyici işini bitirdiğinde sistem, işleyicinin çalışmaya başladığı andaki duruma geri dönecek ve bekletilen sinyaller varsa bu sinyaller gönderilecektir.
    </para>
   </example>
  </sect1>
  <sect1 xml:id="glibc-Checking-for-Pending-Signals">
   <title>Bekleyen Sinyallerin Sınanması</title>
   <titleabbrev>Bekleyen sinyallerin sınanması</titleabbrev>
   <para>
    <indexterm linkend="glibc-cp"><primary>sinyaller</primary><secondary>bekleyen</secondary><tertiary>sınanması</tertiary></indexterm>
    <indexterm linkend="glibc-cp"><primary>sinyaller</primary><secondary>engellenen</secondary><tertiary>sınanması</tertiary></indexterm>
    <indexterm linkend="glibc-cp"><primary>bekleyen sinyallerin sınanması</primary></indexterm>
    Bekleyen sinyallerin hangileri olduğu herhangi bir anda yapılacak <function>sigpending</function> çağrıları ile öğrenilebilir. Bu işlev &signal.h; başlık dosyasında bildirilmiştir.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-sigpending"><primary>sigpending</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>sigpending</function></csname>
     <csparam><ptr>sigset_t</ptr><parameter>set</parameter></csparam>
    </csproto>
    <header>&signal.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&asunsafe; &lock;<code linkend="glibc-safety-condition">/hurd</code></concept>
     <concept>&acunsafe; &lock;<code linkend="glibc-safety-condition">/hurd</code></concept>
    </conceptlist>
    <para>
     <code>sigpending</code> işlevi bekleyen sinyallere ilişkin bilgileri  <parameter>set</parameter> kümesi içinde saklar.  Alınması engellenmiş bir sinyal varsa, bu sinyal dönen kümenin bir üyesidir. (Bir sinyalin bu kümenin üyesi olup olmadığı <xref linkend="glibc-Signal-Sets"/> bölümünde açıklanan  <function>sigismember</function> işlevi kullanılarak öğrenilebilir.)
    </para>
    <para>
     Dönen değer bir hata oluşmamışsa <code>0</code>, aksi takdirde <code>-1</code>'dir.
    </para>
   </csynopsis>
   <example>
    <screen>#include &lt;signal.h&gt;
#include &lt;stddef.h&gt;

sigset_t base_mask, waiting_mask;

sigemptyset (&amp;base_mask);
sigaddset (&amp;base_mask, SIGINT);
sigaddset (&amp;base_mask, SIGTSTP);

/* <replaceable>Diğer işlemler yapılırken kullanıcı kesmeleri engellensin.</replaceable> */
sigprocmask (SIG_SETMASK, &amp;base_mask, NULL);
…

/* <replaceable>Bir süre sonra, bekleyen sinyal var mı bak.</replaceable> */
sigpending (&amp;waiting_mask);
if (sigismember (&amp;waiting_mask, SIGINT)) {
  /* <replaceable>Kullanıcı süreci sonlandırmayı denedi.</replaceable> */
}
else if (sigismember (&amp;waiting_mask, SIGTSTP)) {
  /* <replaceable>Kullanıcı süreci durdurmayı denedi.</replaceable> */
}
</screen>
   </example>
   <para>
    Süreç için bekleyen belli bir sinyal varsa, sonradan gelen aynı türdeki sinyallerin iptal edilebileceği unutulmamalıdır. Örneğin, bir <varname>SIGINT</varname> sinyali askıya alınmışsa başka bir <varname>SIGINT</varname> sinyali geldiğinde yazılım bu sinyali engellenmesi durdurulduktan sonra alacaktır.
   </para>
   <note><title>Taşınabilirlik Bilgisi</title>
    <para>
     <function>sigpending</function> işlevi POSIX.1 ile gelmiştir.  Daha eski sistemler eşdeğeri bir oluşuma sahip değildir.
    </para>
   </note>
  </sect1>
  <sect1 xml:id="glibc-Remembering-a-Signal">
   <title>Bir Sinyalin Eyleminin Sonradan Hatırlanması</title>
   <titleabbrev>Bir sinyalinin engellenmesinin oluşturduğu etkinin sınanacak bir değişkenle tekrar elde edilmesi.</titleabbrev>
   <para>
    Bir sinyalin engellenmesi, kütüphane oluşumlarını kullanmak yerine daha sonra sinyalin engellenmediği bir sırada sınanacak bir değişkene sinyal işleyici içinde bir değer atanmak suretiyle yapılabilir.
   </para>
   <example>
    <screen>/* <replaceable>Bu değişkenin değeri sıfırdan farklıysa,
   o sinyal bekletiliyor demektir.</replaceable> */
volatile sig_atomic_t signal_pending;

/* <replaceable>Sinyal geldiğinde işleme sokulmayacaksa
   bu değişkenin değeri sıfırdan farklı olacaktır.</replaceable> */
volatile sig_atomic_t defer_signal;

void
handler (int signum)
{
  if (defer_signal)
    signal_pending = signum;
  else
    … /* <replaceable>"Gerçekten" sinyal yakalanmış.</replaceable> */
}

…

void
update_mumble (int frob)
{
  /* <replaceable>Sinyallerin hemen etki etmesini engelle.</replaceable> */
  defer_signal++;
  /* <replaceable>Şimdi kesmelerden korkmadan mumble'ı güncelle.</replaceable> */
  mumble.a = 1;
  mumble.b = hack ();
  mumble.c = frob;
  /* <replaceable>mumble güncellendi. Gelen sinyali işleme sok.</replaceable> */
  defer_signal&#45;&#45;;
  if (defer_signal == 0 &amp;&amp; signal_pending != 0)
    raise (signal_pending);
}
</screen>
   <para>
    Belli bir sinyal geldiğinde <replaceable>signal_pending</replaceable> içinde nasıl saklandığına dikkat edilmelidir. Bu yolla, aynı düzenek kullanılarak farklı türdeki sinyaller yakalanabilir.
   </para>
   <para>
    Kodun önemli yerlerinde <replaceable>defer_signal</replaceable> değişkeninin değeri önce artırılıp sonra azaltılıyor; böylece <replaceable>signal_pending</replaceable> sıfırdan farklıyken <code>update_mumble</code> çağrıldığında sadece <code>update_mumble</code> içinde değil ayrıca çağrıldığı işlev içinde de ertelenecektir. Bu nedenle, <replaceable>defer_signal</replaceable> sıfırdan farklı olduğunda <replaceable>signal_pending</replaceable>'e bakılmıyor.
   </para>
   <para>
    <replaceable>defer_signal</replaceable>'in artırılması ve eksiltilmesi bir işlemci komutundan fazlasını gerektirir; bu nedenle işlem tamamlanmamışken sinyal alınması olasılığı vardır. Fakat bu herhangi bir soruna yol açmaz. Arttırma ya da eksiltmenin başlamasından hemen önce bir sinyal gelirse bile çalışma bozulmayacaktır.
   </para>
   <para>
    <replaceable>defer_signal</replaceable>'in <replaceable>signal_pending</replaceable> sınanmadan önce artırılması ölümcül öneme sahiptir. Bu çözümü zor bir yazılım hatasından kaçınmayı sağlar. Eğer bu işlemler aşağıdaki gibi farklı bir sırada yapılmış olsaydı,
   </para>
   <screen>if (defer_signal == 1 &amp;&amp; signal_pending != 0)
  raise (signal_pending);
defer_signal&#45;&#45;;
</screen>
    <para>
     <code>if</code> deyimi ile artırım arasında gelen bir sinyal sonsuza kadar kaybolurdu. <replaceable>defer_signal</replaceable>'e sadece sinyal işleyici değer atasa ve yazılım bu değişkene baksa işleyici bu değişkene bakmazdı.
    </para>
    <para>
     <indexterm linkend="glibc-cp"><primary>sinyallerin yakalanmasında zamanlama hataları</primary></indexterm>
     Bu çeşit yazılım hatalarına <wordasword>zamanlama hataları</wordasword> adı verilir. Yaygın olarak oluştukları halde yeniden üretilmeleri imkansız olduğundan özellikle kötü hatalardır. Bu hata üretilemeyeceğinden bir hata ayıklayıcı ile bu hatalar bulunamaz. Bu nedenle onlardan kaçınmak için özellikle büyük dikkat sarfedilmelidir.
    </para>
    <para>
     (<replaceable>defer_signal</replaceable> değişkeni sayaç olarak kullanılıyorsa, kodu bu şekilde yazmak daha kolay gelebilir. Normalde bu değişkenin <replaceable>signal_pending</replaceable> değişkeni ile birlikte sınanması gerekir. Her durumda bu sayacı sıfır değeri için sınamak, herhangi bir değer için sınamaktan daha basittir. Eğer <replaceable>defer_signal</replaceable> değişkeni sayaç olarak kullanılmıyor ve sadece sıfır veya bir değerini alabiliyorsa, sınama sırası sınama işleminin karmaşıklığını pek etkilemez. Bu da <replaceable>defer_signal</replaceable> değişkenini sayaç olarak kullanmanın bir diğer getirisidir: Kodu yanlış sırada yazmak suretiyle bulunması zor olacak bir hata yapma şansı azalır.)
    </para>
   </example>
  </sect1>
 </chapter>
 <chapter xml:id="glibc-Waiting-for-a-Signal" userlevel="notoc">
  <?dbhtml stop-chunking?>
  <title>Sinyalin Beklenmesi</title>
  <titleabbrev>Bir sinyal gelene kadar sürecin bekletilmesi.</titleabbrev>
  <para>
   <indexterm linkend="glibc-cp"><primary>sinyal bekleme</primary></indexterm>
   Yazılım harici olaylarla tetikleniyorsa ya da eşzamanlama için sinyaller kullanılıyorsa ve yapacak başka işi de yoksa bir sinyal gelene kadar beklemesi gerekir.
  </para>
  <sect1 xml:id="glibc-Using-Pause">
   <title><code>pause</code> Kullanımı</title>
   <titleabbrev>Basit yol: <code>pause</code> kullanmak.</titleabbrev>
   <para>
    Sinyal gelene kadar beklemenin en basit yolu <function>pause</function> çağrısı yapmaktır. Kullanmadan önce, aşağıda açıklanan <link linkend="glibc-Pause-Problems">olumsuzluklar</link> okunmalıdır.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-pause"><primary>pause</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>pause</function></csname>
     <csparam><void/></csparam>
    </csproto>
    <header>&unistd.h;</header>
    <conceptlist>
     <concept>&mtunsafe; &mtunsafe; &race;<code linkend="glibc-safety-identifier">:sigprocmask</code><code linkend="glibc-safety-condition">/!bsd!linux</code></concept>
     <concept>&asunsafe; &lock;<code linkend="glibc-safety-condition">/hurd</code></concept>
     <concept>&acunsafe; &lock;<code linkend="glibc-safety-condition">/hurd</code></concept>
    </conceptlist>
    <para>
     <code>pause</code> işlevi, bir sinyal işleyiciyi çalıştırmak ya da süreci sonlandırmak gibi bir eylemi yerine getirmek üzere bir sinyalin gelmesini beklemek için kullanılır.
    </para>
    <para>
     Sinyal, bir işleyici işlevi tetikliyorsa <code>pause</code> döner. Bu başarısız bir dönüş olarak ele alınır (başarılı davranış, süreci sonsuza dek bekletmektir) ve işlev <code>-1</code> değeri ile döner. Hatta bir sinyal işleyici döndüğünde diğer ilkellerin çalışmalarına kaldıkları yerden devam edecekleri belirtilse bile (bkz, <xref linkend="glibc-Interrupted-Primitives"/>), bunun <code>pause</code> üzerinde bir etkisi yoktur; bir sinyal geldiğinde daima başarısız olarak dönecektir.
    </para>
    <para>
     Aşağıdaki <varname>errno</varname> değeri bu işlev içindir:
    </para>
    <formalpara><title><code>EINTR</code></title>
     <para>
      İşlev bir sinyal alarak kesintiye uğradı.
     </para>
    </formalpara>
    <para>
     Sinyal sürecin sonlanmasına sebep oluyorsa <code>pause</code> dönmeyecektir (ister istemez).
    </para>
    <para>
     Bu işlev çok evreli yazılımlar için bir iptal noktasıdır. Eğer evre <code>pause</code> çağrısı sırasında bazı öz kaynakları (bellek, dosya tanımlayıcılar, semaforlar, v.s.) ayırıyorsa sorun çıkar. Evre iptal aldığı andan itibaren süreç sonlanana kadar bu öz kaynaklar ayrılmış olarak kalacaktır. Bu tür <code>pause</code> çağrılarından kaçınmak için iptal işleyicileri kullanılarak korunulmalıdır.
    </para>
    <para>
     <code>pause</code> işlevi &unistd.h; başlık dosyasında bildirilmiştir.
    </para>
   </csynopsis>
  </sect1>
  <sect1 xml:id="glibc-Pause-Problems">
   <title><code>pause</code> Sorunları</title>
   <titleabbrev>Basit yöntemler her zaman iyi değildir.</titleabbrev>
   <para>
    <function>pause</function> basitleştirmesi, yazılımın sihirli bir şekilde çökmesine sebep olan bir sürü zamanlama hatasını gizleyebilir.
   </para>
   <para>
    Eğer herşeyi yazılımınız yapıyorsa, yani kendi sinyal işleyicilerini kullanıyor ve yazılım <function>pause</function> çağırmaktan başka bir şey yapmıyorsa <function>pause</function> kullanmak güvenilirdir. Her sinyal alınışında sinyal işleyici bir sonraki işi yapar ve döner, böylece yazılımın ana döngüsü tekrar bir <function>pause</function> çağrısı yapabilir.
   </para>
   <para>
    Birden fazla sinyalin işlenmesi için <function>pause</function> kullanarak beklemek ve sonra çalışmayı sürdürmek mümkün olmayabilir. Sinyal işleyici çalışmaya başladığında bir değişken ile bunu belirliyorsanız <function>pause</function> kullanmak artık güvenilir olmaz.
   </para>
   <example>
    <screen>/* <replaceable><code>usr_interrupt</code>'a sinyal işleyici değer atıyor.</replaceable>  */
if (!usr_interrupt)
  pause ();

/* <replaceable>Sinyal geldikten sonra yapılacaklar.</replaceable>  */
…
</screen>
    <para>
     Bu bir yazılım hatasıdır: sinyal, <code>usr_interrupt</code>'a bakıldıktan sonra ve <function>pause</function> çağrılmadan önce gelmelidir. Eğer böyle bir sinyal gelmezse, süreç bu kod parçasını bir kez daha asla çalıştırmayacaktır.
    </para>
    <para>
     <function>pause</function> kullanmak yerine <function>sleep</function> kullanarak döngü içinde bekleme sınırlanabilir. <function>sleep</function> hakkında daha ayrıntılı bilgi için bkz, <xref linkend="glibc-Sleeping"/>. Bu durumda kod şöyle olurdu:
    </para>
    <screen>/* <replaceable><code>usr_interrupt</code>'a sinyal işleyici değer atıyor.</replaceable>
while (!usr_interrupt)
  sleep (1);

/* <replaceable>Sinyal geldikten sonra yapılacaklar.</replaceable>  */
…
</screen>
    <para>
     Bazı amaçlar için bu yeterli olur. Ama biraz daha karmaşık olmakla beraber <function>sigsuspend</function> kullanarak belli bir sinyal işleyicinin çalıştırılması sağlanabilir.
    </para>
   </example>
  </sect1>
  <sect1 xml:id="glibc-Sigsuspend">
   <title><code>sigsuspend</code> Kullanımı</title>
   <titleabbrev>Belli bir sinyalin gelmesinin beklenmesi.</titleabbrev>
   <para>
    Bir sinyali beklemenin en temiz ve güvenilir yolu sinyali engelleyip <function>sigsuspend</function> kullanmaktır. Bir döngü içinde <function>sigsuspend</function> kullanarak, her sinyal için farklı bir sinyal işleyici oluşturarak sinyaller beklenebilir.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-sigsuspend"><primary>sigsuspend</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>sigsuspend</function></csname>
     <csparam><ptr>const&#160;sigset_t</ptr><parameter>set</parameter></csparam>
    </csproto>
    <header>&signal.h;</header>
    <conceptlist>
     <concept>&mtunsafe; &race;<code linkend="glibc-safety-identifier">:sigprocmask</code><code linkend="glibc-safety-condition">/!bsd!linux</code></concept>
     <concept>&asunsafe; &lock;<code linkend="glibc-safety-condition">/hurd</code></concept>
     <concept>&acunsafe; &lock;<code linkend="glibc-safety-condition">/hurd</code></concept>
    </conceptlist>
    <para>
     Bu işlev sürecin sinyal maskesini <parameter>set</parameter> maskesi ile değiştirerek bir sinyal işleyiciyi çalıştıracak ya da süreci sonlandıracak bir sinyal alıncaya kadar süreci bekletir. Başka bir deyişle, süreç, <parameter>set</parameter> maskesinin üyesi olmayan sinyallerden biri gelene dek süreci bekletir.
    </para>
    <para>
     Eğer süreç bir sinyal işleyiciyi çalıştıracak bir sinyalin alınması ve işleyici işlevin dönmesiyle işlemi sürdürüyorsa <code>sigsuspend</code> ayrıca dönecektir.
    </para>
    <para>
     <parameter>set</parameter> ile belirtilen maske <code>sigsuspend</code> etkin olduğu sürece geçerli olur. İşlev döndüğünde eski maske tekrar etkin olur.
    </para>
    <para>
     Dönüş değeri ve hata durumu  <function>pause</function> ile aynıdır.
    </para>
   </csynopsis>
   <para>
    Önceki bölümdeki <function>pause</function> ve <function>sleep</function> ile ilgili örnekler <function>sigsuspend</function> kullanılarak tamamen güvenilir duruma getirilebilir:
   </para>
   <example>
    <screen>sigset_t mask, oldmask;

…

/* <replaceable>Geçici olarak engellenecek sinyallerin maskesini oluştur</replaceable> */
sigemptyset (&amp;mask);
sigaddset (&amp;mask, SIGUSR1);

…

/* <replaceable>Sinyal gelmesini bekle.</replaceable> */
sigprocmask (SIG_BLOCK, &amp;mask, &amp;oldmask);
while (!usr_interrupt)
  sigsuspend (&amp;oldmask);
sigprocmask (SIG_UNBLOCK, &amp;mask, NULL);
</screen>
    <para>
     Kodun son parçası biraz dikkat gerektiriyor. Burada hatırlanması gereken nokta, <function>sigsuspend</function> döndüğünde sinyal maskesini çağrılmadan önceki değere ayarlamasıdır. Bu durumda <varname>SIGUSR1</varname> sinyali bir kere daha engellenir. İkinci <function>sigprocmask</function> çağrısı bu sinyalin engellenmesini kaldırmak için gereklidir.
    </para>
    <para>
     Bir diğer nokta: <code>while</code> döngüsünün neden gerekli diye düşünülebilir. Öyle ya, yazılım sadece tek bir <varname>SIGUSR1</varname> sinyali bekliyor. Yanıt: <function>sigsuspend</function>'e aktarılan maskeye bakılırsa yazılımın başka sinyalleri de beklediğini görülür--örneğin, iş denetim sinyalleri. Eğer <replaceable>usr_interrupt</replaceable> değişkenine dokunmayan sinyal işleyiciler de varsa, değişkeni değiştiren bir sinyal işleyici çalıştırılana kadar döngü sürecektir.
    </para>
    <para>
     Bu teknik birkaç satır daha gerektirir ama bu kullanım amacınıza uygun koşullara bağlı olacaktır. Kod aslında sadece bu dört satırda bekler.
    </para>
   </example>
  </sect1>
 </chapter>
 <chapter xml:id="glibc-Signal-Stack">
  <title>Sinyal Yığıtı</title>
  <titleabbrev>Ayrı bir sinyal yığıtı kullanmak</titleabbrev>
  <para>
   Bir sinyal yığıtı, sinyal işleyicilerin icra yığıtı olarak kullanılan özel bir bellek alanıdır. Taşmalardan kaçınmak için oldukça büyük olmalıdır; boyutunu belirlemek amacıyla <varname>SIGSTKSZ</varname> makrosu tanımlanmıştır. Yığıt için gereken alan <function>malloc</function> ile tahsis edilebilir. Bundan sonra yapılacak bir <function>sigaltstack</function> veya <function>sigstack</function> çağrısı ile sisteme bu alanın sinyal yığıtı olarak kullanılacağı belirtilebilir.
  </para>
  <para>
   Sinyal yığıtını kullanmaları için sinyal işleyicileri oluşturulurken farklı bir şey yapmak gerekmez. Bir yığıttan diğerine geçilmesi özdevinimli gerçekleşir. (Bazı makinelerde bir sinyal işleyicisinin sinyal yığıtını kullandığı durumda GNU hata ayıklayıcıları dışındaki bazı hata ayıklayıcılar  yığıt izlemesini başarıyla yapamayabilir.)
  </para>
  <para>
   Sisteme ayrı bir sinyal yığıtı kullanmasını belirtmenin iki yolu vardır. 4.2 BSD ile gelen <function>sigstack</function> biraz eski bir arayüzdür. 4.4 BSD ile gelen <function>sigaltstack</function> daha yenidir. <function>sigaltstack</function> işlevinin bir getirisi vardır; makineye ve işletim sistemine bağlı olan yığıt büyümesinin yönü ile ilgilenmek zorunda kalınmaz.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-tp" xml:id="glibc-tp-stack_t"><primary>stack_t</primary></indexterm>
   <csproto type="veri türü">
    <csname><function>stack_t</function></csname>
   </csproto>
   <header>&signal.h;</header>
   <para>
    Bu veri yapısı bir sinyal yığıtı hakkında bilgi içerir. Aşağıdaki üyelere sahiptir:
   </para>
   <glosslist>
    <glossentry>
     <glossterm>
      <type>void&nbsp;*</type><structfield>ss_sp</structfield>
     </glossterm>
     <glossdef>
      <para>
       Sinyal yığıtının taban adresidir.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <type>size_t&nbsp;</type><structfield>ss_size</structfield>
     </glossterm>
     <glossdef>
      <para>
       <code>ss_sp</code>'den başlayan sinyal yığıtının boyutudur. Yığıt için ne kadar yer ayrılacağı bu üye ile belirtilir.
      </para>
      <para>
       Yığıt için gereken alanı hesaplamak için &signal.h; başlık dosyasında tanımlanmış iki makro vardır:
      </para>
      <csynopsis>
       <indexterm linkend="glibc-tp" xml:id="glibc-vr-SIGSTKSZ"><primary>SIGSTKSZ</primary></indexterm>
       <csproto type="makro">
        <csname><function>SIGSTKSZ</function></csname>
       </csproto>
       <para>
        Bir sinyal yığıtı için olması gereken boyuttur. Normal kullanımlar için yeterli olabilecek kadardır.
       </para>
      </csynopsis>
      <csynopsis>
       <indexterm linkend="glibc-tp" xml:id="glibc-vr-MINSIGSTKSZ"><primary>MINSIGSTKSZ</primary></indexterm>
       <csproto type="makro">
        <csname><function>MINSIGSTKSZ</function></csname>
       </csproto>
       <para>
        İşletim sisteminin sinyal göndermeyi gerçekleştirebileceği sinyal yığıtı boyutudur. Tahsis edilecek sinyal yığıtı boyutu bu değerden <emphasis>BÜYÜK</emphasis> olmalıdır.
       </para>
       <para>
        Çoğu durumda, <code>ss_size</code> için <varname>SIGSTKSZ</varname> kullanmak yeterlidir. Ama yazılımın sinyal işleyicilerinin ne kadar yığıt alanı kullanacakları biliniyorsa, bundan farklı bir değer de kullanılabilir. Bu durumda en az <code>MINSIGSTKSZ</code> baytlık yer tahsis etmek gerekir. <code>ss_size</code> ile bu değerden büyük herhangi bir değer atanabilir.
       </para>
      </csynopsis>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <type>int&nbsp;</type><structfield>ss_flags</structfield>
     </glossterm>
     <glossdef>
      <para>
       Bu üye şu seçeneklerin bitsel VEYAlanmış değerini içerir:
      </para>
      <csynopsis>
       <indexterm linkend="glibc-tp" xml:id="glibc-vr-SS_DISABLE"><primary>SS_DISABLE</primary></indexterm>
       <csproto type="sabit">
        <csname><function>SS_DISABLE</function></csname>
       </csproto>
       <para>
        Sisteme sinyal yığıtını kullanmaMAsını belirtir.
       </para>
      </csynopsis>
    <csynopsis>
       <indexterm linkend="glibc-tp" xml:id="glibc-vr-SS_ONSTACK"><primary>SS_ONSTACK</primary></indexterm>
       <csproto type="sabit">
        <csname><function>SS_ONSTACK</function></csname>
       </csproto>
       <para>
        Sistem tarafından atanır ve sinyal yığıtının o an kullanılmakta olduğunu belirtir. Bu bit etkin değilse sinyaller, normal kullanıcı yığıtını kullanıyor demektir.
       </para>
      </csynopsis>
     </glossdef>
    </glossentry>
   </glosslist>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-sigaltstack"><primary>sigaltstack</primary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>sigaltstack</function></csname>
    <csparam><type>const&#160;stack_t&#160;*restrict</type><parameter>stack</parameter></csparam>
    <csparam><type>stack_t&#160;*restrict</type><parameter>oldstack</parameter></csparam>
   </csproto>
   <header>&signal.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&asunsafe; &lock;<code linkend="glibc-safety-condition">/hurd</code></concept>
    <concept>&acunsafe; &lock;<code linkend="glibc-safety-condition">/hurd</code></concept>
   </conceptlist>
   <para>
    <code>sigaltstack</code> işlevi, sinyal işleyicilerin ayrı bir sinyal yığıtı kullanacağını belirtir. Süreç tarafından bir sinyal alındığında sinyal eylemi sinyal yığıtı üzerinden işlenecekse, sistem, sinyal işleyici çalışırken bu sinyal yığıtının kullanılması için gerekli düzenlemeyi yapar.
   </para>
   <para>
    <parameter>oldstack</parameter> boş gösterici değilse, kurulu sinyal yığıtının bilgileri bu adreste döndürülür. <parameter>stack</parameter> boş gösterici değilse, bu, sinyal işleyiciler tarafından kullanılacak yeni yığıtı belirtir.
   </para>
   <para>
    İşlev başarılı olduğunda <code>0</code> ile döner, aksi takdirde <code>-1</code> ile döner. Aşağıdaki <varname>errno</varname> değerleri bu işlev için tanımlanmıştır:
   </para>
   <glosslist>
    <glossentry>
     <glossterm><code>EINVAL</code></glossterm>
     <glossdef>
      <para>
       Kullanımda olan yığıt iptal edilmeye çalışıldı.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm><code>ENOMEM</code></glossterm>
     <glossdef>
      <para>
       Yeni yığıtın boyu <varname>MINSIGSTKSZ</varname> değerinden küçük.
      </para>
     </glossdef>
    </glossentry>
   </glosslist>
  </csynopsis>
  <para>
   Burada eski arayüz olan <function>sigstack</function> işlevi de anlatılacaktır. Ancak, sistem bu işlevi içerse bile bunun yerine <function>sigaltstack</function> işlevi kullanılmalıdır.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-tp" xml:id="glibc-tp-sigstack"><primary sortas="sigstack">struct&nbsp;sigstack</primary></indexterm>
   <csproto type="veri türü">
    <csname><type>struct</type><function>sigstack</function></csname>
   </csproto>
   <header>&signal.h;</header>
   <para>
    Bu veri yapısı bir sinyal yığıtı hakkında bilgi içerir. Aşağıdaki üyelere sahiptir:
   </para>
   <glosslist>
    <glossentry>
     <glossterm>
      <type>void&nbsp;*</type><structfield>ss_sp</structfield>
     </glossterm>
     <glossdef>
      <para>
       Yığıt göstericisidir. Yığıt aşağı doğru büyüyorsa bu değer yığıtın tepesini, yukarı doğru büyüyorsa yığıtın tabanını gösterir.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <type>int&nbsp;</type><structfield>ss_onstack</structfield>
     </glossterm>
     <glossdef>
      <para>
       Sistem o an bu yığıtı kullanıyorsa bu alanın değeri "doğru"dur.
      </para>
     </glossdef>
    </glossentry>
   </glosslist>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-sigstack"><primary>sigstack</primary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>sigstack</function></csname>
    <csparam><ptr>struct&#160;sigstack</ptr><parameter>stack</parameter></csparam>
    <csparam><ptr>struct&#160;sigstack</ptr><parameter>oldstack</parameter></csparam>
   </csproto>
   <header>&signal.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&asunsafe; &lock;<code linkend="glibc-safety-condition">/hurd</code></concept>
    <concept>&acunsafe; &lock;<code linkend="glibc-safety-condition">/hurd</code></concept>
   </conceptlist>
   <para>
    <code>sigstack</code> işlevi, sinyal işleyicilerin ayrı bir sinyal yığıtı kullanacağını belirtir. Süreç tarafından bir sinyal alındığında sinyal eylemi sinyal yığıtı üzerinden işlenecekse, sistem, sinyal işleyici çalışırken bu sinyal yığıtının kullanılması için gerekli düzenlemeyi yapar.
   </para>
   <para>
    <parameter>oldstack</parameter> boş gösterici değilse, kurulu sinyal yığıtının bilgileri bu adreste döndürülür. <parameter>stack</parameter> boş gösterici değilse, bu, sinyal işleyiciler tarafından kullanılacak yeni yığıtı belirtir.
   </para>
   <para>
    İşlev başarılı olduğunda <code>0</code> ile döner, aksi takdirde <code>-1</code> ile döner.
   </para>
  </csynopsis>
 </chapter>
 <chapter xml:id="glibc-BSD-Signal-Handling">
  <title>BSD Usulü Sinyal İşleme</title>
  <titleabbrev>BSD ile geriye uyumluluk için var olan işlevler.</titleabbrev>
  <para>
   Bu bölümde sinyal işleme işlevlerinin BSD Unix'de gerçeklenmiş benzerleri açıklanmıştır. Bu oluşumlar zamanı için ileri düzeydeydi; günümüzde ise tamamen kullanım dışıdır ve sadece BSD Unix uyumluluğu için kütüphaneye konmuştur.
  </para>
  <para>
   BSD ve POSIX sinyal işleme oluşumları arasında birçok benzerlik vardır, çünkü POSIX oluşumları tasarlanırken BSD oluşumlarından ilham alınmıştır. İsim karışıklıklarından kaçınmak için isimlerinin farklılaştırılmalarının yanında aralarında temel bir fark bulunur: BSD Unix sinyal maskeleri <type>sigset_t</type> nesneleri değil <type>int</type> bit maskeleridir.
  </para>
  <para>
   BSD oluşumları &signal.h; başlık dosyasında bildirilmiştir.
   <indexterm linkend="glibc-pg"><primary>signal.h</primary></indexterm>
  </para>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-siginterrupt"><primary>siginterrupt</primary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>siginterrupt</function></csname>
    <csparam><type>int</type><parameter>signum</parameter></csparam>
    <csparam><type>int</type><parameter>failflag</parameter></csparam>
   </csproto>
   <header>&signal.h;</header>
   <conceptlist>
    <concept>&mtunsafe; &const;<code linkend="glibc-safety-identifier">:sigintr</code></concept>
    <concept>&asunsafe;</concept>
    <concept>&acunsafe; &corrupt;</concept>
   </conceptlist>
   <para>
    <parameter>signum</parameter> sinyali tarafından kesintiye uğrayan ilkellerin hangi yaklaşımı kullanacağını belirtmekte kullanılır. <parameter>failflag</parameter> yanlışsa, <parameter>signum</parameter> sinyali ilkelleri yeniden başlatır; doğruysa, ilkeller <varname>EINTR</varname> hata kodu ile başarısız olur Bkz. <xref linkend="glibc-Interrupted-Primitives"/>.
   </para>
   <para>
    Bu işlevin yerini <function>sigaction</function> işlevinin <varname>SA_RESTART</varname> seçeneği almıştır. Bkz, <xref linkend="glibc-Advanced-Signal-Handling"/>.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-sigmask"><primary>sigmask</primary></indexterm>
   <csproto type="makro">
    <csname><type>int</type><function>sigmask</function></csname>
    <csparam><type>int</type><parameter>signum</parameter></csparam>
   </csproto>
   <header>&signal.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    Bu makro, <parameter>signum</parameter> sinyalinin bir sinyal maskesine dahil edilmesi için kullanılır.  Birden fazla sinyal, her sinyal için yapılan <code>sigmask</code> çağrıları VEYAlanarak maskeye dahil edilebilir.
   </para>
   <example>
    <screen>(sigmask (SIGTSTP) | sigmask (SIGSTOP)
| sigmask (SIGTTIN) | sigmask (SIGTTOU))
</screen>
    <para>
     Bu kod, tamamı iş denetim sinyallerinden oluşan bir maske belirtir.
    </para>
   </example>
   <para>
    Bu makro, <type>sigset_t</type> türü ve ilgili sinyal kümesi işlevleri ile değiştirilmiştir. Bkz, <xref linkend="glibc-Signal-Sets"/>.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-sigblock"><primary>sigblock</primary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>sigblock</function></csname>
    <csparam><type>int</type><parameter>mask</parameter></csparam>
   </csproto>
   <header>&signal.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&asunsafe; &lock;<code linkend="glibc-safety-condition">/hurd</code></concept>
    <concept>&acunsafe; &lock;<code linkend="glibc-safety-condition">/hurd</code></concept>
   </conceptlist>
   <para>
    <function>sigprocmask</function> (bkz, <xref linkend="glibc-Process-Signal-Mask"/>) işlevinin <parameter>how</parameter> bağımsız değişkenine <varname>SIG_BLOCK</varname> atanmış eşdeğeridir: <parameter>mask</parameter> ile belirtilen sinyalleri sürecin engellenen sinyaller kümesine ekleyerek önceki sinyal kümesi ile döner.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-sigsetmask"><primary>sigsetmask</primary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>sigsetmask</function></csname>
    <csparam><type>int</type><parameter>mask</parameter></csparam>
   </csproto>
   <header>&signal.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&asunsafe; &lock;<code linkend="glibc-safety-condition">/hurd</code></concept>
    <concept>&acunsafe; &lock;<code linkend="glibc-safety-condition">/hurd</code></concept>
   </conceptlist>
   <para>
    <function>sigprocmask</function> (bkz, <xref linkend="glibc-Process-Signal-Mask"/>) işlevinin <parameter>how</parameter> bağımsız değişkenine <varname>SIG_SETMASK</varname> atanmış eşdeğeridir: <parameter>mask</parameter> ile belirtilen sinyalleri sürecin engellenen sinyaller kümesi yaparak önceki sinyal kümesi ile döner.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-sigpause"><primary>sigpause</primary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>sigpause</function></csname>
    <csparam><type>int</type><parameter>mask</parameter></csparam>
   </csproto>
   <header>&signal.h;</header>
   <conceptlist>
    <concept>&mtunsafe; &race;<code linkend="glibc-safety-identifier">:sigprocmask</code><code linkend="glibc-safety-condition">/!bsd!linux</code></concept>
    <concept>&asunsafe; &lock;<code linkend="glibc-safety-condition">/hurd</code></concept>
    <concept>&acunsafe; &lock;<code linkend="glibc-safety-condition">/hurd</code></concept>
   </conceptlist>
   <para>
    <function>sigsuspend</function> (bkz. <xref linkend="glibc-Waiting-for-a-Signal"/>) işlevinin eşdeğeridir: <parameter>mask</parameter> ile belirtilen sinyalleri sürecin engellenen sinyaller kümesi yaparak bir sinyal gelmesini bekler. İşlev dönerken eski sinyal kümesi etkinleştirilir.
   </para>
  </csynopsis>
 </chapter>
</part>
