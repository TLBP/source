<?xml version="1.0" encoding="UTF-8"?>
<!-- ********************************************************************
     $Id: ch24.xml,v 1.2 2002/12/20 22:29:48 nilgun Exp $
******************************************************************** -->
<!-- reentrant: evresel (bu işlevler genelde evrelerle çalışabiliyorsa reentrat oluyorlar. Yani evrelere yatkınlık baskın, bu bakımdan evresel demek hiç yanlış olmaz.) -->
<part id="glibc-Signal-Handling">
  <title>Sinyal İşleme</title>
  <titleabbrev>Sinyaller nasıl gönderilir, engellenir, işlenir.</titleabbrev>
  <partintro><para>
<indexterm scope="glibc-cp"><primary>sinyal</primary></indexterm>
Bir <wordasword>sinyal</wordasword> bir sürece gönderilen bir yazılım kesmesidir. İşletim sistemi, sinyalleri, çalışan bir yazılıma olağandışı durumları raporlamakta kullanır. Bazı sinyaller geçersiz bellek adreslerine erişim gibi durumlarda hata raporlamakta, bazıları da bir telefon hattının kapanması gibi rasgele olayları raporlamakta kullanılır.
  </para><para>
GNU C kütüphanesi her biri başka bir çeşit olaya karşılık olmak üzere çeşitli sinyal türleri tanımlar. Bazı olaylar, bir yazılımı çalışmasını imkansız kılabilir, bu tür olayları raporlayan sinyallar yazılımın çalışmasını durdurmasına sebep olur. Diğer sinyal çeşitleri zararsız olayları raporlar ve bunlar öntanımlı olarak yoksayılır.
  </para><para>
Bir olayın sinyallere sebep olacağını umuyorsanız, sinyalle tetiklenen bir işlev tanımlayıp, işletim sistemine böyle sinyaller geldiğinde bu işlevi çalıştırmasını belirtebilirsiniz.
  </para><para>
Son olarak, bir süreç başka bir sürece sinyal gönderebilir; bu bir sürecin kendi alt sürecini durdurması gerektiğinde ya da birbiriyle haberleşerek eşzamanlı çalışması gereken süreçler arasında kullanılabilir.
  </para></partintro>
  <chapter id="glibc-Concepts-of-Signals">
    <title>Sinyallerle İlgili Temel Kavramlar</title>
    <titleabbrev>Sinyallerle ilgili oluşumlara genel bir bakış.</titleabbrev>
    <para>
Bu kısımda sinyallerin nasıl üretildiği, bir sinyal alındıktan sonra neler olduğu ve yazılımlarda sinyallerin nasıl işlendiği gibi konularla ilgili kavramlara değinilecektir.
   </para>
    <sect1 id="glibc-Kinds-of-Signals">
      <title>Bazı Sinyal Çeşitleri</title>
      <titleabbrev>Bir sinyali oluşturan sebeplere örnekler.</titleabbrev>
      <para>
Bir sinyal olağandışı bir olayın varlığını raporlar. Bir sinyale sebep olan (üreten ya da ortaya çıkaran) olayların bazıları:
    </para><para><itemizedlist><listitem>
Sıfırla bölme ya da geçerli bir aralık dışında bir adres gösterme gibi yazılım hataları.
      </listitem><listitem>
Kullanıcı tarafından yazılımın durdurulmak ya da sonlandırılmak istenmesi. Çoğu ortam kullanıcıya <command>C-z</command> tuşlayarak uygulamayı durdurabilme veya <command>C-c</command> tuşlayarak uygulamayı sonlandırabilme imkanı sağlar. Bu tuş vuruşları algılandığında işletim sistemi sürece bu isteği belirten bir sinyal gönderir.
      </listitem><listitem>
Bir alt sürecin sonlanması.
      </listitem><listitem>
Alarm veya zamanlayıcının zamanaşımına uğraması.
      </listitem><listitem>
Aynı süreç tarafından yapılan bir <command>kill</command> veya <command>raise</command> çağrısı.
      </listitem><listitem>
Başka bir süreç tarafından yapılan bir <command>kill</command> çağrısı; sinyallerin süreçler arası iletişim için sınırlı ama kullanışlı biçimidir.
      </listitem><listitem>
Yapılamayacak bir G/Ç işlemini yapmaya çalışma. Örneğin, bir ucuna yazma yapılmayan bir boruyu okumaya çalışmak (bkz, <xref linkend="glibc-Pipes-and-FIFOs"/>), bazı durumlarda bir uçbirime yazmaya ya da okumaya çalışmak (bkz, <xref linkend="glibc-Job-Control"/>).
      </listitem></itemizedlist></para><para>
Bu olayların her biri (açıkça yapılan <command>kill</command> ve <command>raise</command> çağrıları dışında) kendine özel bir sinyal üretir. Sinyal çeşitleri <xref linkend="glibc-Standard-Signals"/> bölümünde listelenmiş ve açıklanmıştır.
    </para></sect1>
    <sect1 id="glibc-Signal-Generation">
      <title>Sinyal Üretimi İle İlgili Kavramlar</title>
      <titleabbrev>Sinyaller niçin ve nasıl oluşur.</titleabbrev>
      <para>
<indexterm scope="glibc-cp"><primary>sinyallerin üretimi</primary></indexterm>
Genellikle, sinyalleri üreten olaylar üç ana sınıf altında incelenir: hatalar, dış olaylar, doğrudan yapılan istekler.
    </para><para>
Bir hata, bir uygulamanın bazı şeyleri yanlış yaptığını ve çalışmasını sürdüremeyeceği bir durumu anlatır. Fakat, hata çeşitlerinin hepsi sinyal üretmez (aslında bu çoğu için geçerlidir). Örneğin, mevcut olmayan bir dosya bir hatadır ama bir sinyal üretmez, sadece <command>open</command> işlevi <command>-1</command> ile döner. Genelde hatalar kütüphane işlevleri ile ilişkilidir ve işlevler bir hata oluştuğunda hatayı bir değerle raporlarlar. Sinyalleri ortaya çıkaran hatalar sadece kütüphane çağrılarında değil yazılımda herhangi bir yerde oluşabilir. Bunlar sıfırla bölme, geçersiz bir bellek adresi olabilir.
    </para><para>
Bir dış olay genelde G/Ç işlemleri ya da başka süreçlerle ilgilidir. Bunlar, bir girdinin alınması, bir zamanlayıcının zamanaşımına uğraması ve bir alt sürecin sonlanması olabilir.
    </para><para>
Doğrudan yapılan istekler, amacı özellikle sinyal üretmek olan <command>kill</command> gibi bir kütüphane işlevinin kullanılmasıyla yapılır.
    </para><para>
Sinyaller <emphasis>eşzamanlı olarak</emphasis> ya da <emphasis>herhangi bir anda</emphasis> üretilebilir. Bir eşzamanlı sinyal, yazılım içindeki belirli bir eylemle ilişkilidir ve (engellenmedikçe)  bu eylem sırasında oluşur. Çoğu hatalar sinyalleri eşzamanlı üretir, öyle ki, kendisi için sinyal üretecek bir süreç kimi zaman bunu bilinçli olarak yapar. Bazı makinelerde belli bir takım donanım hataları (genellikle gerçek sayılarla ilgili olağandışılıklar) tamamen eşzamanlı üretilirler, fakat ardından bir kaç makine komutu gelmelidir.
    </para><para>
Herhangibir anda üretilen sinyaller onları alan sürecin denetimi dışındaki olaylardan kaynaklanır. Bu sinyaller icra sırasında hiç umulmadık zamanlarda gelir. Harici olaylar sinyalleri eşzamansız olarak üretir ve diğer süreçlere yapılacak istekler için kullanılır.
    </para><para>
Bir sinyal ya özellikle eşzamanlı ya da özellikle eşzamansızdır. Örneğin, hatalar için gönderilen sinyaller özellikle eşzamanlıdır, çünkü hatalar sinyalleri eşzamanlı üretir. Ancak ister eşzamanlı olsun ister eşzamansız, sinyaller açıkça bir isteğin sonucu olarak üretilir.
    </para></sect1>
    <sect1 id="glibc-Delivery-of-Signal">
      <title>Sinyallerin Gönderilmesi</title>
      <titleabbrev>Bir sinyalin bir sürece etkileri.</titleabbrev>
      <para>
<indexterm scope="glibc-cp"><primary>sinyaller</primary><secondary>alınması</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>sinyaller</primary><secondary>askıda kalma</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>sinyaller</primary><secondary>engelleme</secondary></indexterm>
Bir sinyal üretidiğinde <emphasis>beklemeye</emphasis> alınır. Normalde kısa bir süre için beklemede kaldıktan sonra sinyalleyeceği sürece gönderilir. Eğer sinyal engellenen türde ise sonsuza kadar beklemede kalır--sinyal engellenemeyecek duruma gelininceye kadar. Sinyalin engellenemeyeceği durum oluştuğunda anında gönderilecektir. Bkz. <xref linkend="glibc-Blocking-Signals"/>.
    </para><para>
<indexterm scope="glibc-cp"><primary>sinyaller</primary><secondary>belirtilen eylem</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>sinyaller</primary><secondary>öntanımlı eylem</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>sinyal eylemi</primary></indexterm>
<indexterm scope="glibc-cp"><primary>sinyallerin yakalanması</primary></indexterm>
Bir sinyal gönderildiğinde, hemen ya da uzun bir beklemenin ardından bu sinyal için belirlenmiş eylem alınır. <command>SIGKILL</command> ve <command>SIGSTOP</command> gibi sinyaller için eylem bellidir, ama diğer sinyaller için yazılım bazı seçimler yapabilir: sinyali yoksayabilir, bir <emphasis>sinyalle tetiklenen işlev</emphasis> belirtebilir ya da bu sinyal için geçerli olan <emphasis>öntanımlı eylem</emphasis>i kabul eder. Yazılım seçimini <command>signal</command> veya <command>sigaction</command> (<xref linkend="glibc-Signal-Actions"/>) gibi bir işlev ile belirtir. Kimi zaman sinyalle tetiklenen işlevlerden belge içinde kimi zaman <wordasword>sinyal yakalayıcı</wordasword> kimi zaman da <wordasword>eylemci işlev</wordasword> olarak da söz edeceğiz. Bu işlev çalışırken buna ilişkin sinyal engellenir.
    </para><para>
Bir sinyal için belirlenmiş eylem onun yoksayılması ise, böyle bir sinyal üretildiği anda iptal edilir. Bu, sinyal zamanında engellendiğinde de böyle olur. Bu yolla iptal edilmiş bir sinyal asla gönderilmez; yazılımda hemen ardından böyle bir sinyal için farklı bir eylem belirtilse hatta engellenmeyeceği belirtilse bile.
    </para><para>
Bir sinyali ne işleme sokacağını ne de yoksayacağını belirtmemişse bu sinyal geldiğinde yazılım, sinyalin <emphasis>öntanımlı eylem</emphasis>ini almış olur. Her sinyal türü kendine özgü bir öntanımlı eyleme sahiptir. Bunlar <xref linkend="glibc-Standard-Signals"/> bölümünde açıklanmıştır. Sinyallerin çoğu için öntanımlı eylem sürecin sonlandırılmasıdır.  "Zararsız" olaylar için gönderilen sinyaller için öntanımlı eylem ise hiçbir şey yapılmamasıdır.
    </para><para>
Bir sinyal bir süreci sonlandırdığında onu çalıştıran süreç sonlanma sebebini <command>wait</command> veya <command>waitpid</command> işlevleri kullanarak onlardan dönen sonlanma durum koduna bakarak saptayabilir. (Bu <xref linkend="glibc-Process-Completion"/> bölümünde ayrıntılı olarak açıklanmıştır.) Alınan bilgi, sonlanmaya bir sinyalin mi sebep olduğunu ve ne çeşit sinyal alındığını içerir.
    </para><para>
Normalde yazılım hatalarını gösteren sinyaller özel bir niteliğe sahiptir: bu sinyallerden biri süreci sonlandırdığında, sonlanma sırasında sürecin durumunu gösteren <emphasis>core</emphasis> isimli bir döküm dosyası çıktılanır. Bu dosyayı bir hata ayıklayıcı ile inceleyip hatanın sebebini saptayabilirsiniz.
    </para><para>
Yazılımınızın oluşturduğu bir "yazılım hatası"nın sonucu olarak bir sinyal alınıp bunun sonucu olarak süreç sonlandığında tıpkı bir hatanın sonucunda olduğu gibi <literal>core</literal> dosyası çıktılanır.
    </para></sect1></chapter>
  <chapter id="glibc-Standard-Signals">
    <title>Standart Sinyaller</title>
    <titleabbrev>İsimleri ve eylemleri standartlaştırılmış sinyaller.</titleabbrev>
    <para>
<indexterm scope="glibc-cp"><primary>sinyaller</primary><secondary>isimleri</secondary></indexterm>
<indexterm scope="glibc-pg"><primary>signal.h</primary></indexterm>
<indexterm scope="glibc-cp"><primary>sinyaller</primary><secondary>numaraları</secondary></indexterm>
Bu bölümde standart sinyallerin isimleri ve bu sinyallerin hangi olayların karşılığı olduğu açıklanmaktadır. Her sinyal ismi kendini bir <wordasword>sinyal numarası</wordasword> ile ilişkilendiren bir makrodur. Burada dikkat etmeniz gereken nokta; yazılımınız bir sinyali bir numara olarak kabul etmeyip daima burada tanımlanmış isimlerini kullanmalıdır. Çünkü, isimlerin anlamları standarttır ama numaraları sistemden sisteme değişiklik gösterebilir.
   </para><para>
Bu kısımdaki sinyal isimleri <filename>signal.h</filename> başlık dosyasında tanımlanmıştır.
   </para><para>
<indexterm scope="glibc-vr"><primary>NSIG</primary></indexterm>
<funcsynopsis><funcprototype role="makro" id="glibc-NSIG">
<funcdef>int <command>NSIG</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu sembolik sabitin değeri tanımlı sinyallerin toplam sayısıdır. Sinyaller artan numaralar aldıklarından <command>NSIG</command> en büyük numaralı sinyalin numarasıdır.
    </para></funcdescr></funcsynopsis></para>
    <sect1 id="glibc-Program-Error-Signals">
      <title>Yazılım Hatalarının Sinyalleri</title>
      <titleabbrev>Yazılımınızdaki hataları raporlayan sinyaller.</titleabbrev>
      <para>
<indexterm scope="glibc-cp"><primary>sinyaller</primary><secondary>yazılım hatalarını raporlayanlar</secondary></indexterm>
Aşağıdaki sinyaller, bilgisayarın kendi ya da işletim sistemi tarafından ciddi bir yazılım hatası saptandığında üretilir. Genelde bu sinyallerin tümü yazılımınızın bir şeyleri önemli ölçüde bozacağı ya da sistemin bütünü açısından yazılımın çalışmasının sorun olacağı durumları belirtir.
    </para><para>
Bazı yazılımlar yazılım hatası sinyallerini sonlanmadan önceki düzenlemeler sırasında işleme sokar; örneğin, uçbirim girdisinin yansılamasını kapatan bir yazılım yansılamayı tekrar açacağı sırada yazılım hatasını işleme sokmalıdır. Sinyalin işlenmesi, öntanımlı eylemin bitirilmesinin ardından bu sinyalin tekrar yayınlanması şeklinde yapılır.  Bu, yazılımın bir sinyal eylemci yokmuşçasına bu sinyalle sonlanmasını sağlayacaktır. (Bkz. <xref linkend="glibc-Termination-in-Handler"/>.)
    </para><para>
Sonlanma, çoğu yazılım için bir yazılım hatasının nihai sonucudur. Buna rağmen Lisp gibi bazı yazılım geliştirme sistemleri bir hataya maruz kalsa bile derlenmiş kullanıcı yazılımını çalışır halde tutabilir. Bu sistemler denetimi komut seviyesine döndürmek için <command>longjmp</command> kullanılan sinyal eylemcilere sahiptir.
    </para><para>
Bu sinyallerin tümü için öntanımlı eylem sürecin sonlandırılmasına sebep olmaktır. Bir gerçek hata yerine <command>raise</command> veya <command>kill</command> tarafından üretilmedikçe oluşan sinyalleri engeller, yoksayar ya da bir sinyal yakalayıcı kurup normale çevirirseniz, büyük olasılıkla yazılımınız dehşet verici şekilde bozulacaktır.
    </para><para>
<indexterm scope="glibc-vr"><primary>COREFILE</primary></indexterm>
Bu yazılım hatası sinyalleri bir süreci sonlandırırken, sonlanma sırasında sürecin durum kaydı olarak o an içinde bulunulan dizine <filename>core</filename> isimli bir dosya olarak bellek dökümü çıktılar. (GNU sistemlerinde dosyanın ismini <command>COREFILE</command> ortam değişkeni ile belirtebilirsiniz.) Bu dosyanın çıktılanmasının amacı, dosyanın bir hata ayıklayıcı ile incelenerek hatanın sebebinin bulunmasını sağlamaktır.
    </para><para>
<indexterm scope="glibc-vr"><primary>SIGFPE</primary></indexterm>
<indexterm scope="glibc-cp"><primary>olağandışılık</primary></indexterm>
<indexterm scope="glibc-cp"><primary>olağandışılık</primary><secondary>gerçek sayılarda</secondary></indexterm>
<funcsynopsis><funcprototype role="makro" id="glibc-SIGFPE">
<funcdef>int <command>SIGFPE</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
<command>SIGFPE</command> sinyali bir ölümcül aritmetik hata raporlar. Hatanın isminin "floating-point exception" kısaltması olarak oluşturlmasına rağmen sinyal aslında sıfırla bölme ve taşma dahil tüm aritmetik hataları kapsar. Eğer bir yazılım, tamsayı veri sakladığı bir alanı daha sonra bir gerçek sayı işleminde kullanmaya çalışırsa bu, bir "geçersiz işlem" olağandışılığına sebep olur, çünkü işlemci veriyi bir gerçek sayı olarak ele alamaz.
    </para><para>
Aslında gerçek sayı olağandışılıkları oldukça karmaşık bir konudur, çünkü çok farklı anlamlara gelen çözümü zor çok çeşitli olağandışılıklar vardır ve <command>SIGFPE</command> sinyali onları ayıramaz. İkilik Kayan Noktalı Aritmetik için IEEE standardında (ANSI/IEEE Std 754-1985 and ANSI/IEEE Std 854-1987) çeşitli olağandışılıklar tanımlanmıştır ve onların oluşumlarını raporlayacak bilgisayar sistemleri arasında uyumluluk gerektirir.  Ancak, bu standart olağandışılıkların nasıl raporlanacağını ya da işletim sisteminin yazılımcıya ne çeşit bir işleme ve denetim imkanı vereceğini belirtmez.
       </para><para>
BSD sistemleri <command>SIGFPE</command> makrosunun yanında olağandışılığın çeşitli sebeplerini ayrımsamak için bir ek argüman sağlar. Bu argümana erişim sırasında, sinyal eylemciyi iki argüman kabul edecek şekilde tanımlamalısınız. Eylemci kurulurken de tek argümanlı işlev türüne dönüştürmelisiniz. GNU kütüphanesi bu ek argümanı sağlar. Ancak argümanın değeri sadece bu bilgiyi sağlayan sistemler (GNU ve BSD) için anlamlıdır.
    </para><para><variablelist><varlistentry>
    <term><literal>FPE_INTOVF_TRAP</literal></term><listitem><para>
<indexterm scope="glibc-vr"><primary>FPE_INTOVF_TRAP</primary></indexterm>
Tamsayı taşması (C yazılımlarında donanıma özel biçimde taşma yakalayıcıyı etkinleştirmedikçe imkansızdır).
       </para></listitem></varlistentry><varlistentry>
       <term><literal>FPE_INTDIV_TRAP</literal></term><listitem><para>
<indexterm scope="glibc-vr"><primary>FPE_INTDIV_TRAP</primary></indexterm>
Sıfırla tamsayı bölme.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>FPE_SUBRNG_TRAP</literal></term><listitem><para>
<indexterm scope="glibc-vr"><primary>FPE_SUBRNG_TRAP</primary></indexterm>
İndisleme aralığı (C yazılımlarında bazı şeyler hiç denetlenmez).
       </para></listitem></varlistentry><varlistentry>
       <term><literal>FPE_FLTOVF_TRAP</literal></term><listitem><para>
<indexterm scope="glibc-vr"><primary>FPE_FLTOVF_TRAP</primary></indexterm>
Gerçek sayı taşması.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>FPE_FLTDIV_TRAP</literal></term><listitem><para>
<indexterm scope="glibc-vr"><primary>FPE_FLTDIV_TRAP</primary></indexterm>
Gerçek/tam sayılarda sıfırla bölme.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>FPE_FLTUND_TRAP</literal></term><listitem><para>
<indexterm scope="glibc-vr"><primary>FPE_FLTUND_TRAP</primary></indexterm>
Gerçek sayılarda alttan taşma (Normalde etkin değildir).
       </para></listitem></varlistentry><varlistentry>
       <term><literal>FPE_DECOVF_TRAP</literal></term><listitem><para>
<indexterm scope="glibc-vr"><primary>FPE_DECOVF_TRAP</primary></indexterm>
Ondalık taşma (Sadece bir kaç makine ondalık aritmetiğe sahiptir, C hiç kullanmaz).
       </para></listitem></varlistentry></variablelist>
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-vr"><primary>SIGILL</primary></indexterm>
<indexterm scope="glibc-cp"><primary>kuraldışı komut</primary></indexterm>
<funcsynopsis><funcprototype role="makro" id="glibc-SIGILL">
<funcdef>int <command>SIGILL</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Sinyalin ismi "illegal instruction" sözcüklerinden türetilmiştir; yazılımınızın bozuk ya da ayrıcalıklı bir makine kodu komutunu çalıştırmayı denediğini belirtir. C derleyicileri sadece geçerli makine kodu komutlar ürettiğinden <command>SIGILL</command> sinyali genellikle çalıştırılabilir dosyanın zarar görmüş olabileceğini ya da çalıştırılabilir olmayan bir kodu çalıştırmayı denediğinizi belirtir. İkinci durumun ortaya çıktığı çok bilinen durumlar şunlardır: bir işlev olarak ele alınacağı umulan bir göstericiyle geçersiz nir nesnenin aktarılması; bir özdevinimli dizinin sonundan sonrasına yazma denemesi (benzer durum özdevinimli değişkenlere göstericilerde de ortaya çıkabilir); yığıt üzerinde, yığıt çerçevesine dönüş adresi gibi bir takım verilerin bozulması.
    </para><para>
<command>SIGILL</command> sinyali bunlardan başka, yığıt taşmalarında ya da sistemde çalışan sorunlu bir sinyal eylemcinin varlığında da üretilebilir.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-vr"><primary>SIGSEGV</primary></indexterm>
<indexterm scope="glibc-cp"><primary>bölüt çatışması</primary></indexterm>
<funcsynopsis><funcprototype role="makro" id="glibc-SIGSEGV">
<funcdef>int <command>SIGSEGV</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu sinyal, bir yazılımın kendine ayrılan bellek bölgesinin dışında okuma veya yazma denemesi yaptığında ya da salt okunur belleğe yazma denemesinde oluşur. (Aslında bu sinyal sadece sistemin bellek koruma mekanizması tarafından saptanabilen, yazılımın kendi alanının dışında çok uzak bölgelere yazmaya çalıştığı durumlarda ortaya çıkar.) Sinyalin ismi "segmentation violation" sözcüklerinden türetilmiştir.
    </para><para>
<command>SIGSEGV</command> sinyalinin alındığı bilinen sorunlar: göstericinin bir boş ya da ilklendirilmemiş göstericiye dönüştürülmesi (dereferencing - dizi olmayan bir değişkene gösterici üzerinde gösterici aritmetiği uygulanması ya da ilklendirilmemiş bir yapı elemanını göstermek için bir -> işleci ile sol taraf değeri olarak kullanılması); bir dizinin sonunu kontrol etmeden dizi üzerinde gösterici aritmetiği ile işlem yapılması.  Bir göstericinin bir boş göstericiye dönüşmesini durumunu çeşitli sistemler <command>SIGSEGV</command> ya da <command>SIGBUS</command> sinyali ile belirtir.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-vr"><primary>SIGBUS</primary></indexterm>
<indexterm scope="glibc-cp"><primary>taşıt hatası</primary></indexterm>
<funcsynopsis><funcprototype role="makro" id="glibc-SIGBUS">
<funcdef>int <command>SIGBUS</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu sinyal geçersiz duruma gelmiş göstericiler kullanılmaya çalışıldığında ortaya çıkar. <command>SIGSEGV</command> sinyalindeki gibi bu sinyalde geçersiz bir gösterici kullanımıyla ilgili olarak üretilir. İkisi arasındaki fark, <command>SIGSEGV</command> sinyalinin geçerli belleğe geçersiz erişimi belirtmesi, <command>SIGBUS</command> sinyalinin ise geçersiz bir adrese erişimi belirtmesidir. Kimi zaman <command>SIGBUS</command> sinyali göstericinin hatalı hizalama ile kullanıldığı durumlarda da üretilir; örneğin dört sözcüklük bir tamsayı değerinin saklandığı adreste alanın dörde bölünememesi gibi (her bilgisayarın kendine özgü adres hizalaması vardır).
    </para><para>
Sinyalin ismi "bus error" sözcüklerinden türetilmiştir.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-vr"><primary>SIGABRT</primary></indexterm>
<indexterm scope="glibc-cp"><primary>çıkıyorum sinyali</primary></indexterm>
<funcsynopsis><funcprototype role="makro" id="glibc-SIGABRT">
<funcdef>int <command>SIGABRT</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu sinyal yazılımın kendisi tarafından saptanan bir hatayı belirtir ve <command>abort</command> çağrısı ile raporlanır. Bkz, <xref linkend="glibc-Aborting-a-Program"/>.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-vr"><primary>SIGIOT</primary></indexterm>
<funcsynopsis><funcprototype role="makro" id="glibc-SIGIOT">
<funcdef>int <command>SIGIOT</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
PDP-11 "iot" komutu tarafından üretilir.  Çoğu makinede, <command>SIGABRT</command> sinyali olarak yer alır.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-vr"><primary>SIGTRAP</primary></indexterm>
<funcsynopsis><funcprototype role="makro" id="glibc-SIGTRAP">
<funcdef>int <command>SIGTRAP</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Makinenin "breakpoint" komutu ve bazı diğer yakalama komutları tarafından üretilir. Bu sinyal hata ayıklayıcılar tarafından kullanılır. Yazılımınız büyük ihtimalle bazı hatalı makine komutları dolayısıyla sadece <command>SIGTRAP</command> sinyalini görecektir.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-vr"><primary>SIGEMT</primary></indexterm>
<funcsynopsis><funcprototype role="makro" id="glibc-SIGEMT">
<funcdef>int <command>SIGEMT</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Öykünme tuzağı; bu sinyal henüz gerçeklenmemiş ama yazılım tarafından taklit edilen makine komutlarından ya da onların olması gerektiği gibi taklit edilememesinden dolayı işletim sistemi tarafından üretilir.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-vr"><primary>SIGSYS</primary></indexterm>
<funcsynopsis><funcprototype role="makro" id="glibc-SIGSYS">
<funcdef>int <command>SIGSYS</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Hatalı sistem çağrısı; İşletim sisteminden çalıştırılması istenen ancak çağrı için belirtilen kod numarası makine komutlarında geçersiz olan çağrılarda üretilir.
    </para></funcdescr></funcsynopsis></para></sect1>
    <sect1 id="glibc-Termination-Signals">
      <title>Sonlandırma Sinyalleri</title>
      <titleabbrev>Bir yazılımı durduran ya da sonlandıran sinyaller.</titleabbrev>
      <para>
<indexterm scope="glibc-cp"><primary>sinyaller</primary><secondary>süreci sonlandıran</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>süreçler</primary><secondary>sonlandırma sinyali</secondary></indexterm>
Bu sinyaller bir sürece şu veya bu şekilde sonlandırılacağını söyler. Farklı amaçlarla yazılımlar onları farklı algılama isteklerine uygun olarak farklı isimlere sahiptirler.
    </para><para>
Bu sinyallerin işlenme sebebi yazılımın gerçek sonlandırmayı yapmadan önce bazı hazırlıklar yapmasına imkan vermektir. Örneğin, yazılımı sonlandırmadan önce son duruma ilişkin bilgileri bir yerlere kaydetmek, geçici dosyaları silmek, önceki uçbirim kipine dönmek isteyebilirsiniz. Bunu yapmak için önce sinyali engeller, bu işlemleri yaptıktan sonra asıl sonlandırmayı gerçekleştirmek için sinyali tekrar üretirsiniz. Bu işlem, yazılımınız sanki sinyali elde edemeyen bir yazılım gibi sonlanmasını sağlar. (Bakınız, <xref linkend="glibc-Termination-in-Handler"/>.)
    </para><para>
Bu sinyaller için öntanımlı eylem sürecin sonlanmasına sebep olmaktır.
    </para><para>
<indexterm scope="glibc-vr"><primary>SIGTERM</primary></indexterm>
<indexterm scope="glibc-cp"><primary>sonlandırma sinyali</primary></indexterm>
<indexterm scope="glibc-cp"><primary>sinyaller</primary><secondary>sonlandırma sinyali</secondary></indexterm>
<funcsynopsis><funcprototype role="makro" id="glibc-SIGTERM">
<funcdef>int <command>SIGTERM</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
<command>SIGTERM</command>, yazılımın sonlanmasına sebep olan en temel sinyallerden biridir. <command>SIGKILL</command> sinyalinin tersine bu sinyal engellenebilir, işleme sokulabilir ya da yoksayılabilir. Normal yöntem yazılımı sonlandırmadan önce isteği kullanıcıya doğrulatmaktır.
    </para><para>
<command>kill</command> kabuk komutu öntanımlı olarak (seçeneksiz kullanımda) <command>SIGTERM</command> sinyali üretir.
<indexterm scope="glibc-pg"><primary>kill</primary></indexterm>
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-vr"><primary>SIGINT</primary></indexterm>
<indexterm scope="glibc-cp"><primary>durdurma sinyali</primary></indexterm>
<indexterm scope="glibc-cp"><primary>sinyaller</primary><secondary>durdurma sinyali</secondary></indexterm>
<funcsynopsis><funcprototype role="makro" id="glibc-SIGINT">
<funcdef>int <command>SIGINT</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
<command>SIGINT</command> ("program interrupt" sözcüklerinden türetilmiştir) sinyali, kullanıcı tarafından INTR karakteri (normalde <command>C-c</command> tuşları) tuşlandığında üretilir. <command>C-c</command> sürücü desteği hakkında daha fazla bilgi için <xref linkend="glibc-Special-Characters"/> bölümüne bakınız.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-vr"><primary>SIGQUIT</primary></indexterm>
<indexterm scope="glibc-cp"><primary>sinyaller</primary><secondary>çıkış sinyali</secondary></indexterm>
<funcsynopsis><funcprototype role="makro" id="glibc-SIGQUIT">
<funcdef>int <command>SIGQUIT</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
<command>SIGQUIT</command> sinyali QUIT karakteri ile (normalde <command>C-\</command>) üretilmesi dışında <command>SIGINT</command> sinyali gibidir. Süreci sonlandırırken bir yazılım hatası sinyalinin yaptığı gibi son bellek dökümü olarak <filename>core</filename> dosyası çıktılar. Bunu kullanıcı tarafından "saptanan" bir hata durumu olarak düşünebilirsiniz.
    </para><para>
Hata durumndaki bellek dökümleri hakkında daha fazla bilgi için <xref linkend="glibc-Program-Error-Signals"/> bölümüne bakınız. Uçbirim sürücüsü desteği ile ilgili olarak da <xref linkend="glibc-Special-Characters"/> bölümüne bakınız.
    </para><para>
Bazı temizlik işlemleri yapmadan çıkmanın en iyi yolu <command>SIGQUIT</command> sinyalinin elde edilmesidir. Örneğin yazılımınız geçici dosyalar oluşturuyorsa ve diğer sonlandırma isteklerinde bu dosyaları siliyorsa onların silinmemesi için <command>SIGQUIT</command> sinyalini ürettirmek daha iyidir. Böylece bellek dökümü yanında bu geçici dosyalara da bakarak birşeyler daha iyi saptanabilir.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-vr"><primary>SIGKILL</primary></indexterm>
<indexterm scope="glibc-cp"><primary>sinyaller</primary><secondary>ölüm sinyali</secondary></indexterm>
<funcsynopsis><funcprototype role="makro" id="glibc-SIGKILL">
<funcdef>int <command>SIGKILL</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
<command>SIGKILL</command> sinyali bir uygulamanın anında sonlandırılmasında kullanılır. Bu sinyal engellenemez ve yoksayılamaz.
    </para><para>
Bu sinyal genellikle açıkça bir isteğin sonucunda üretilir. Yakalanamadığından <command>C-c</command> veya <command>SIGTERM</command> denedikten sonra sadece bir son çare olarak üretmelisiniz. Eğer süreç başka herhangi bir sonlandırma sinyaline yanıt vermezse, ona bir <command>SIGKILL</command> sinyali göndererek hemen hemen daima sonlanmasını sağlayabilirsiniz.
    </para><para>
Ancak, eğer <command>SIGKILL</command> sinyali bir süreci sonlandıramazsa, bu bir işletim sistemi hatasıdır ve mutlaka rapor edilmelidir.
    </para><para>
Ayrıca, bir sürecin çalışmasını sürdürmesinin imkansız olduğu durumlarda da süreç bir sinyal eylemci kullanıyor olsa bile sistem <command>SIGKILL</command> sinyali göndererek bu süreci sonlandırabilir.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-vr"><primary>SIGHUP</primary></indexterm>
<indexterm scope="glibc-cp"><primary>sinyaller</primary><secondary>hat kesildi sinyali</secondary></indexterm>
<funcsynopsis><funcprototype role="makro" id="glibc-SIGHUP">
<funcdef>int <command>SIGHUP</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
<command>SIGHUP</command> ("hang-up" sözcüklerinden türetilmiştir) sinyali kullanıcının uçbiriminin bağlantısı kesildiğinde durumu bildirmek için üretilir. Bu genellikle bir ağ ya da telefon bağlantısı kesildiğinde olur. Bu durumla ilgili daha fazla bilgi için <xref linkend="glibc-Control-Modes"/> bölümüne bakınız.
    </para><para>
Bu sinyal ayrıca, bir uçbirim üzerinde o oturuma ilişkin işler yürütülen bir sürecin sonlandırılmasında da kullanılır; bu sonlandırma oturumdaki tüm süreçlerin çalıştırıldığı uçbirimle bağlantısının kopmasına yol açar. Daha fazla bilgi için <xref linkend="glibc-Termination-Internals"/> bölümüne bakınız.
    </para></funcdescr></funcsynopsis></para></sect1>
    <sect1 id="glibc-Alarm-Signals">
      <title>Alarm Sinyalleri</title>
      <titleabbrev>Zamanlayıcıların zamanaşımına uğraması.</titleabbrev>
      <para>
Bu sinyaller zamanlayıcıların zaman aşımına uğradığını bildirmekte kullanılır. Bu sinyallerin gönderilmesine sebep olan işlevler <xref linkend="glibc-Setting-an-Alarm"/> bölümünde bulunabilir.
    </para><para>
Bu sinyallerin öntanımlı davranışı o sürecin sonlandırılmasına sebep olmasıdır. Bu öntanımlı davranış geniş çapta kullanışlıdır; ancak, bu sinyallerin kullanıldığı yöntemler her durumda bir eylemci işlev kullanımını gerekli kılar.
    </para><para>
<indexterm scope="glibc-vr"><primary>SIGALRM</primary></indexterm>
<indexterm scope="glibc-cp"><primary>sinyaller</primary><secondary>gerçek süreli alarm sinyali</secondary></indexterm>
<funcsynopsis><funcprototype role="makro" id="glibc-SIGALRM">
<funcdef>int <command>SIGALRM</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu sinyal özellikle bir zamanlayıcının gerçek ya da saat tikleri cinsinden ölçülen değeri için saptanan sınırın aşıldığını belirtir. <command>alarm</command> işlevi gibi işlevlerle üretilir.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-vr"><primary>SIGVTALRM</primary></indexterm>
<indexterm scope="glibc-cp"><primary>sinyaller</primary><secondary>sanal süreli alarm sinyali</secondary></indexterm>
<funcsynopsis><funcprototype role="makro" id="glibc-SIGVTALRM">
<funcdef>int <command>SIGVTALRM</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu sinyal, özellikle süreç tarafından kullanılan işlemci zamanı cinsinden zamanlayıcı değerinin zamanaşımına uğradığını belirtir. "virtual time alarm" sözcüklerinden türetilmiştir.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-vr"><primary>SIGPROF</primary></indexterm>
<indexterm scope="glibc-cp"><primary>sinyaller</primary><secondary>profil alarm sinyali</secondary></indexterm>
<funcsynopsis><funcprototype role="makro" id="glibc-SIGPROF">
<funcdef>int <command>SIGPROF</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu sinyal, özellikle süreç tarafından kullanılan hem işlemci zamanı cinsinden hem de sistem tarafından süreç lehine kullanılan işlemci zamanı cinsinden zamanlayıcı değerinin zamanaşımına uğradığını belirtir. Bu tür zamanlayıcılar kod profili oluşumlarının gerçeklemelerinde kullanılır, zaten sinyalin ismi de buradan gelir.
    </para></funcdescr></funcsynopsis></para></sect1>
    <sect1 id="glibc-Asynchronous-I-O-Signals">
      <title>Eşzamansız G/Ç Sinyalleri</title>
      <titleabbrev>Girdi varlığını bildiren sinyaller.</titleabbrev>
      <para>
Bu bölümde açıklanan sinyaller eşzamansız G/Ç oluşumlarıyla ilgilidir. Bu sinyalleri üretecek dosya tanımlayıcıları etkinleştirecek <command>fcntl</command> çağrısı ile eylemi (<xref linkend="glibc-Interrupt-Input"/>) doğrudan elde edebilirsiniz. Bu sinyaller için öntanımlı eylem onların yoksayılmasıdır.
    </para><para>
<indexterm scope="glibc-vr"><primary>SIGIO</primary></indexterm>
<indexterm scope="glibc-cp"><primary>sinyaller</primary><secondary>girdi var sinyali</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>sinyaller</primary><secondary>çıktı var sinyali</secondary></indexterm>
<funcsynopsis><funcprototype role="makro" id="glibc-SIGIO">
<funcdef>int <command>SIGIO</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu sinyal bir dosya tanımlayıcı girdi veya çıktı işlemleri yapmaya hazır olduğunda üretilir.
    </para><para>
Çoğu işletim sisteminde, <command>SIGIO</command> üretebilen dosya çeşitleri sadece uçbirimler ve soketlerdir. Sıradan dosyalarında dahil olduğu diğer dosya çeşitleri, isteseniz bile <command>SIGIO</command> sinyalini asla üretmez.
    </para><para>
GNU sisteminde <command>SIGIO</command> sinyali daima <command>fcntl</command> işleviyle eşzamansız kipe girildiğinde üretilir.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-vr"><primary>SIGURG</primary></indexterm>
<indexterm scope="glibc-cp"><primary>sinyaller</primary><secondary>acil veri sinyali</secondary></indexterm>
<funcsynopsis><funcprototype role="makro" id="glibc-SIGURG">
<funcdef>int <command>SIGURG</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu sinyal bir soket üzerinden "acil" ya da bantdışı veri geldiğinde üretilir. Bkz, <xref linkend="glibc-Out-of-Band-Data"/>.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-vr"><primary>SIGPOLL</primary></indexterm>
<funcsynopsis><funcprototype role="makro" id="glibc-SIGPOLL">
<funcdef>int <command>SIGPOLL</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu bir System V sinyal ismidir, az çok <command>SIGIO</command> sinyaline benzer. Sadece uyumluluk için vardır.
    </para></funcdescr></funcsynopsis></para></sect1>
    <sect1 id="glibc-Job-Control-Signals">
    <title>İş Denetim Sinyalleri</title>
    <titleabbrev>İş denetimi için kullanılan sinyaller.</titleabbrev>
    <para>
<indexterm scope="glibc-cp"><primary>sinyaller</primary><secondary>iş denetim sinyalleri</secondary></indexterm>
Bu sinyaller iş denetimine (job control)  destek için kullanılır. Sisteminizde iş denetimi desteği yoksa, bu makrolar tanımlanmış bile olsa, sinyaller üretilemez ve yakalanamaz.
    </para><para>
İş denetiminin nasıl çalıştığı hakkında bir fikriniz yoksa bu sinyalleri unutun. Daha fazla bilgi için <xref linkend="glibc-Job-Control"/> bölümüne bakınız.
    </para><para>
<indexterm scope="glibc-vr"><primary>SIGCHLD</primary></indexterm>
<indexterm scope="glibc-cp"><primary>sinyaller</primary><secondary>alt süreç sinyali</secondary></indexterm>
<funcsynopsis><funcprototype role="makro" id="glibc-SIGCHLD">
<funcdef>int <command>SIGCHLD</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu sinyal, bir alt süreci çalıştıran sürece alt süreç durdurulduğunda ya da sonlandırıldığında gönderilir.
    </para><para>
Bu sinyal için öntanımlı eylem yoksayılmaktır. Sonlandırılmış alt süreçlerinizin olup bunların durumlarının <command>wait</command> veya <command>waitpid</command> (<xref linkend="glibc-Process-Completion"/>) ile bildirilmediği durumlar için ya da bir işletim sistemine bağımlı olmamak için bu sinyal için bir eylemci oluşturabilirsiniz.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-vr"><primary>SIGCLD</primary></indexterm>
<funcsynopsis><funcprototype role="makro" id="glibc-SIGCLD">
<funcdef>int <command>SIGCLD</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
<command>SIGCHLD</command> için atıl olmuş bir sinyal ismidir.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-vr"><primary>SIGCONT</primary></indexterm>
<indexterm scope="glibc-cp"><primary>sinyaller</primary><secondary>devam sinyali</secondary></indexterm>
<funcsynopsis><funcprototype role="makro" id="glibc-SIGCONT">
<funcdef>int <command>SIGCONT</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
<command>SIGCONT</command> sinyalini bir sürecin devam etmesini istemek için üretebilirsiniz. Bu sinyal alınmadan önce durmuş olan bir sürecin çalışmasını sürdürmesi istendiğinde gönderilir. Öntanımlı davranış başka bir şey yapılmamasıdır. Bu sinyal engellenemez. Bir eylemci belirtseniz bile <command>SIGCONT</command> sürecin çalışmaya devam etmesini sağlar.
    </para><para>
Çoğu yazılım için <command>SIGCONT</command> sinyalini yakalamanın bir anlamı yoktur; basitçe hiç durdurulmamışlar gibi çalışmaya kaldıkları yerden devam edeceklerdir. Bu sinyal için bir eylemci sadece durdurulduktan sonra çalıştırldığında yazılıma özel bazı işlemler yapmanız gerekiyorsa anlamlıdır. Örneğin, durdurma öncesi uçbirim çıktılaması kapalıyken açtıysanız, çalışmaya devam edileceğinde bunu tekrar kapatmak isteyebilirsiniz.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-vr"><primary>SIGSTOP</primary></indexterm>
<indexterm scope="glibc-cp"><primary>sinyaller</primary><secondary>durdurma sinyali</secondary></indexterm>
<funcsynopsis><funcprototype role="makro" id="glibc-SIGSTOP">
<funcdef>int <command>SIGSTOP</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
<command>SIGSTOP</command> sinyali süreci durdurur. Yakalanamaz, engellenemez, yoksayılamaz.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-vr"><primary>SIGTSTP</primary></indexterm>
<indexterm scope="glibc-cp"><primary>sinyaller</primary><secondary>etkileşimli durdurma sinyali</secondary></indexterm>
<funcsynopsis><funcprototype role="makro" id="glibc-SIGTSTP">
<funcdef>int <command>SIGTSTP</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
<command>SIGTSTP</command> sinyali bir etkileşimli durdurma sinyalidir. <command>SIGSTOP</command> sinyalinin aksine yakalanabilir ve yoksayılabilir.
    </para><para>
Bu sinyalle bir durdurma isteği geldiğinde dosyalarınızı ve sistem tablolarınızı güvenli durumda bırakmak isterseniz bu sinyal için bir eylemci oluşturmalısınız. Örneğin uçbirimde çıktılamayı kapatmışsanız, durdurma sırasında bunu açmanız gerekir.
    </para><para>
Bu sinyal kullanıcı tarafından <literal>SUSP</literal> karakteri (normalde <command>C-z</command>) tuşlandığında üretilir. Uçbirim sürücü desteği ile ilgili daha fazla bilgi için <xref linkend="glibc-Special-Characters"/> bölümüne bakınız.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-vr"><primary>SIGTTIN</primary></indexterm>
<indexterm scope="glibc-cp"><primary>sinyaller</primary><secondary>uçbirim girdi sinyali</secondary></indexterm>
<funcsynopsis><funcprototype role="makro" id="glibc-SIGTTIN">
<funcdef>int <command>SIGTTIN</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bir süreç bir artalan işi olarak çalışıyorsa kullanıcı uçbirimini okuyamaz. Bir artalan işindeki herhangi bir süreç uçbirimden okuma yapmak istediğinde işteki tüm süreçlere bir <command>SIGTTIN</command> sinyali gönderilir. Bu sinyal için öntanımlı eylem sürecin durdurulmasıdır. Uçbirimle girilen bu etkileşimle ilgili daha fazla bilgi almak için <xref linkend="glibc-Access-to-the-Terminal"/> bölümüne bakınız.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-vr"><primary>SIGTTOU</primary></indexterm>
<indexterm scope="glibc-cp"><primary>sinyaller</primary><secondary>uçbirim çıktı sinyali</secondary></indexterm>
<funcsynopsis><funcprototype role="makro" id="glibc-SIGTTOU">
<funcdef>int <command>SIGTTOU</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
<command>SIGTTIN</command> sinyaline benzer, farklı olarak artalandaki iş içindeki süreç uçbirime yazmaya ya da kipi değiştirmeye çalıştığında üretilir. Burada da öntanımlı eylem sürecin durdurulmasıdır. <command>SIGTTOU</command> sinyali sadece <command>TOSTOP</command> çıktı kipi belirtilerek uçbirime yazmaya çalışıldığında üretilir; bkz, <xref linkend="glibc-Output-Modes"/>.
</para></funcdescr></funcsynopsis></para><para>
Bir süreç durdurulduğunda <command>SIGKILL</command> ve <command>SIGCONT</command> sinyalleri dışında hiçbir sinyali alamaz, süreç devam ettirilene kadar askıya alınırlar. <command>SIGKILL</command>  sinyali daima süreci sonlandırır ve engellenemez, yakalanamaz ve yoksayılamaz. <command>SIGCONT</command> sinyali yoksayılabilir ama daima durdurulmuş bir sürecin kaldığı yerden çalışmasına devam etmesini sağlar. Bir sürece <command>SIGCONT</command> sinyalinin gönderilmesi askıda bekleyen bir durdurma sinyali varsa iptal edilmesine sebep olur. Benzer şekilde, askıya alınmış bir <command>SIGCONT</command> sinyali bir durdurma sinyali alındığında iptal edilir.
    </para><para>
Bir  <link linkend="glibc-Orphaned-Process-Groups">öksüz süreç grubundaki</link> bir süreç <command>SIGTSTP</command>, <command>SIGTTIN</command> veya <command>SIGTTOU</command> sinyallerinden birini alırsa ve o sinyali yakalamıyorsa, süreç durmaz. Şüphesiz böyle bir sürecin durdurulması pek kullanışlı değildir. Çünkü böyle bir süreci durması için uyaracak bir kabuk ya da devam etmesine izin verecek bir kullanıcı olmayacaktır. Bazı sistemler hiçbir şey yapmayabilir; bazıları da bunun yerine <command>SIGKILL</command> veya <command>SIGHUP</command> gibi bir sinyal alabilir. GNU sistemlerinde süreç <command>SIGKILL</command> ile öldürülür; bu sistemde durmuş ya da öksüz kalmış süreçlerle ilgili sorunları da çözer.
    </para></sect1>
    <sect1 id="glibc-Operation-Error-Signals">
      <title>İşlemsel Hata Sinyalleri</title>
      <titleabbrev>İşlemsel sistem hatalarını raporlayan sinyaller.</titleabbrev>
      <para>
Bu sinyaller yazılım tarafından yapılan bir işlemin ürettiği çeşitli hataları raporlamakta kullanılır. Bunlar her zaman yazılımdaki bir yazılım geliştirme hatasını belirtmezler, bir işletim sistemi çağrısının tamamlanmasına engel olan bir hatayı da belirtebilir. Bunların hepsi için öntanımlı eylem sürecin sonlanmasına sebep olmaktır.
    </para><para>
<indexterm scope="glibc-vr"><primary>SIGPIPE</primary></indexterm>
<indexterm scope="glibc-cp"><primary>sinyaller</primary><secondary>boru sinyali</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>sinyaller</primary><secondary>kırık boru sinyali</secondary></indexterm>
<funcsynopsis><funcprototype role="makro" id="glibc-SIGPIPE">
<funcdef>int <command>SIGPIPE</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Kırık boru (Broken pipe).  Boruları ya da FIFO'ları kullanıyorsanız, yazılımınızı, bir süreç bir borunun ucundan yazmaya başlamasından önce başka bir sürecin diğer uçtan okumaya başlamasını sağlayacak şekilde tasarlamak zorundasınız. Eğer okuyan süreç başlamazsa ya da beklenmedik şekilde sonlanırsa, boruya ya da FIFO'ya yazan süreç bir <command>SIGPIPE</command> sinyali üretir. Eğer <command>SIGPIPE</command> engellenir, işleme sokulur ya da yoksayılırsa etkilenen çağrı <command>EPIPE</command> ile başarısız olur.
    </para><para>
Borular ve FIFOlar özel dosyalardır ve <xref linkend="glibc-Pipes-and-FIFOs"/> bölümünde ayrıntılı olarak açıklanmıştır.
    </para><para>
<command>SIGPIPE</command> sinyalinin başka bir sebebi de bağlı olmayan bir sokete yazma denemesidir. Bkz, <xref linkend="glibc-Sending-Data"/>.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-vr"><primary>SIGLOST</primary></indexterm>
<indexterm scope="glibc-cp"><primary>sinyaller</primary><secondary>kayıp özkaynak sinyali</secondary></indexterm>
<funcsynopsis><funcprototype role="makro" id="glibc-SIGLOST">
<funcdef>int <command>SIGLOST</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Özkaynak kaybı. Bir NFS dosyası üzerinde tavsiye niteliğinde bir kilit varsa ve NFS sunucusu yeniden başlatıldığında sizin kilidi hazırladığınızı unutacağından bu sinyal üretilir.
    </para><para>
GNU sisteminde herhangi bir sunucu beklenmedik şekilde ölürse, <command>SIGLOST</command> sinyali üretilir. Genellikle sinyal yoksayılabilir; ancak ölmüş bir sunucuya yapılan bir çağrı sadece hata döndürür.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-vr"><primary>SIGXCPU</primary></indexterm>
<funcsynopsis><funcprototype role="makro" id="glibc-SIGXCPU">
<funcdef>int <command>SIGXCPU</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
İşlemci zaman sınırı aşıldı. Bu sinyal bir sürecin işlemci zamanı üzerindeki sanal özkaynak sınırı aşıldığında üretilir. Bkz, <xref linkend="glibc-Limits-on-Resources"/>.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-vr"><primary>SIGXFSZ</primary></indexterm>
<funcsynopsis><funcprototype role="makro" id="glibc-SIGXFSZ">
<funcdef>int <command>SIGXFSZ</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Dosya boyu sınırı aşıldı. Bu sinyal, dosya boyu üzerindeki sürecin sanal özkaynak sınırı aşılacak şekilde dosya büyütülmeye çalışıldığında üretilir. <xref linkend="glibc-Limits-on-Resources"/>.
    </para></funcdescr></funcsynopsis></para></sect1>
    <sect1 id="glibc-Miscellaneous-Signals">
      <title>Çeşitli Sinyaller</title>
      <titleabbrev>Muhtelif sinyaller.</titleabbrev>
      <para>
Bu sinyaller başka başka amaçlar için kullanılır. Onları birşeyler için özellikle kullanmıyorsanız hiçbir etkileri yoktur.
    </para><para>
<indexterm scope="glibc-vr"><primary>SIGUSR1</primary></indexterm>
<indexterm scope="glibc-cp"><primary>sinyaller</primary><secondary>kullanıcı sinyalleri</secondary></indexterm>
<indexterm scope="glibc-vr"><primary>SIGUSR2</primary></indexterm>
<funcsynopsis><funcprototype role="makro" id="glibc-SIGUSR1">
<funcdef>int <command>SIGUSR1</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcprototype role="makro" id="glibc-SIGUSR2">
<funcdef>int <command>SIGUSR2</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
<command>SIGUSR1</command> ve <command>SIGUSR2</command> sinyalleri istediğiniz herhangi bir amaçla kullanabilmeniz için vardır. Onlar için bir sinyal eylemci yazarsanız, basit süreçler arası iletişim için kullanışlıdırlar.
    </para><para>
<xref linkend="glibc-Signaling-Another-Process"/> bölümünde <command>SIGUSR1</command> ve <command>SIGUSR2</command> sinyallerinin kullanımına bir örnek bulabilirsiniz.
    </para><para>
Öntanımlı eylem sürecin sonlanmasıdır.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-vr"><primary>SIGWINCH</primary></indexterm>
<funcsynopsis><funcprototype role="makro" id="glibc-SIGWINCH">
<funcdef>int <command>SIGWINCH</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Pencere boyutu değişti. Bu sinyal, bazı sistemlerde (GNU dahil), uçbirim sürücüsünün ekranın satır ve sütun sayılarını tutan kaydı değiştiğinde  üretilir. Öntanımlı eylem sinyalin yoksayılmasıdır.
    </para><para>
Bir yazılım alanını tam ekrana genişletilirse <command>SIGWINCH</command> sinyalini yakalamalıdır. Sinyal geldiğinde, yazılım yeni boyutlara göre kendini ayarlamalıdır.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-vr"><primary>SIGINFO</primary></indexterm>
<funcsynopsis><funcprototype role="makro" id="glibc-SIGINFO">
<funcdef>int <command>SIGINFO</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bilgi isteği. 4.4 BSD ve GNU sisteminde, bu sinyal kullanıcı tarafından meşru kipte STATUS karakterini tuşladığında denetçi uçbirimin önalan süreç grubundaki tüm süreçlere gönderilir; bkz, <xref linkend="glibc-Signal-Characters"/>.
    </para><para>
Eğer süreç, süreç grubunun lideri ise öntanımlı eylem, sürecin ne yaptığı ve sistem hakkındaki bazı durum bilgilerinin basılmasıdır. Aksi takdirde öntanımlı olarak hiçbir şey yapılmaz.
    </para></funcdescr></funcsynopsis></para></sect1>
    <sect1 id="glibc-Signal-Messages">
      <title>Sinyal İletileri</title>
      <titleabbrev>Bir sinyali açıklayan bir iletinin basılması.</titleabbrev>
      <para>
<indexterm scope="glibc-cp"><primary>sinyaller</primary><secondary>sinyal iletileri</secondary></indexterm>
Daha önce bahsettiğimiz gibi, bir alt süreç sinyal ile sonlandığında, kabuk bu sinyali açıklayan bir ileti basar. Bir sinyali açıklayan bir ileti basmanın en temiz yolu <command>strsignal</command> ve <command>psignal</command> işlevlerini kullanmaktır. Bu işlevler hangi sinyal çeşidini açıklayan iletinin basılacağını belirtmek için bir sinyal numarası kabul ederler. Sinyal numarası bir alt sürecin sonlanma durumundan (<xref linkend="glibc-Process-Completion"/>) ya da aynı sürecin sinyal eylemcisinden gelebilir.
    </para><para>
<indexterm scope="glibc-fn"><primary>strsignal</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-strsignal">
<funcdef>char *<command>strsignal</command></funcdef>
<paramdef>(int <varname>sinyalnum</varname>)</paramdef>
</funcprototype><funcdescr><para>
<varname>sinyalnum</varname> numaralı sinyali açıklayan bir iletinin durağan olarak ayrılmış dizgesine bir gösterici ile döner. Bu dizgenin içeriğinde değişiklik yapmamalısınız; ayrıca daha sonraki çağrılar bu dizgenin yeniden yazılmasına sebep olacağından dizgeyi hemen kullanmayacaksanız bir kopyasını saklamalısınız.
    </para><para>
<indexterm scope="glibc-pg"><primary>string.h</primary></indexterm>
Bu işlev bir GNU oluşumudur ve <filename>string.h</filename> başlık dosyasında bildirilmiştir.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>psignal</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-psignal">
<funcdef>void <command>psignal</command></funcdef>
<paramdef>(int         <varname>sinyalnum</varname>,
 const char *<varname>ileti</varname>)</paramdef>
</funcprototype><funcdescr><para>
<varname>sinyalnum</varname> numaralı sinyali açıklayan bir iletiyi <command>stderr</command> standart hata çıktılama akımına basar. Bkz, <xref linkend="glibc-Standard-Streams"/>.
    </para><para>
<command>psignal</command> işlevini bir boş gösterici ya da bir boş dizge olarak bir <varname>ileti</varname> ile çağırırsanız <varname>sinyalnum</varname>'un karşılığı olan iletinin sonuna bir satırsonu karakteri ile bir boşluk yerleştirir.
    </para><para>
<indexterm scope="glibc-pg"><primary>signal.h</primary></indexterm>
Bu işlev bir BSD oluşumudur ve <filename>signal.h</filename> başlık dosyasında bildirilmiştir.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-vr"><primary>sys_siglist</primary></indexterm>
Bunlardan başka çeşitli sinyal kodları için iletiler içeren <command>sys_siglist</command> dizisi vardır. Bu dizi, <command>strsignal</command>'in aksine BSD sistemlerinde bulunur.
    </para></sect1></chapter>
  <chapter id="glibc-Signal-Actions">
    <title>Sinyal Eylemlerinin Belirtilmesi</title>
    <titleabbrev>Bir sinyal alındığında neler yapılacağı nasıl belirtilir.</titleabbrev>
    <para>
<indexterm scope="glibc-cp"><primary>sinyal eylemleri</primary></indexterm>
Bir sinyalin oluşturacağı eylemi değiştirmenin en basit yolu <command>signal</command> işlevini kullanmaktır. Yerleşik eylemlerden birini belirtebileceğiniz gibi bir <wordasword>sinyal yakalayıcı</wordasword> da oluşturabilirsiniz.
   </para><para>
GNU kütüphanesi ayrıca, daha yetenekli olan <command>sigaction</command> oluşumunu da içerir. Bu kısım her iki oluşum ve kullanımlarına ilişkin önerileri içerir.
   </para>
    <sect1 id="glibc-Basic-Signal-Handling">
      <title>Basit Sinyal İşleme</title>
      <titleabbrev>Basitçe <command>signal</command> işlevi.</titleabbrev>
      <para>
<indexterm scope="glibc-cp"><primary><command>signal</command> işlevi</primary></indexterm>
<command>signal</command> işlevi, belirli bir sinyal için bir eylem oluşturmayı sağlayan basit bir arayüzdür. İşlevin ve bununla ilgili makroların bildirimleri <filename>signal.h</filename> başlık dosyasında bulunur.
<indexterm scope="glibc-pg"><primary>signal.h</primary></indexterm>
   </para><para>
<indexterm scope="glibc-tp"><primary>sighandler_t</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü" id="glibc-sighandler_t">
<funcdef><command>sighandler_t</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu, sinyal yakalama işlevlerinin veri türüdür. Sinyal yakalama işlevleri sinyal numarasının belirtildiği tek bir argüman alırlar ve dönüş türleri <command>void</command>'dir. Böyle bir sinyal yakalama işlevi şöyle tanımlanmalıdır:
    </para><para>
<screen>void <varname>eylemci</varname> (int <command>sinyalnum</command>) { … }
</screen></para><para>
Bu veri türünün ismi olan <command>sighandler_t</command> bir GNU oluşumudur.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>signal</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-signal">
<funcdef>sighandler_t <command>signal</command></funcdef>
<paramdef>(int          <varname>sinyalnum</varname>,
 sighandler_t <varname>eylem</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>signal</command> işlevi <varname>sinyalnum</varname> sinyali için eylem olarak <varname>eylem</varname> eylemini oluşturur.
    </para><para>
İlk argüman olan <varname>sinyalnum</varname>, denetlenecek davranışın karşılığı olan sinyaldir ve bir sinyal numarası olarak belirtilmelidir. Bir sinyal numarasını belirtirken sembolik sinyal isimlerini kullanmanız gerekir (<xref linkend="glibc-Standard-Signals"/>). Doğrudan doğruya numarasını belirtmeyin, çünkü sinyallerin numaraları işletim sistemleri arasında değişiklik gösterebilir.
    </para><para>
İkinci argüman olan <varname>eylem</varname> ise, <varname>sinyalnum</varname> sinyali için kullanılacak eylemi belirtmek için kullanılır. Bu şağıdakilerden biri olabilir:
    </para><para><variablelist><varlistentry>
    <term><literal>SIG_DFL</literal></term><listitem><para>
<indexterm scope="glibc-vr"><primary>SIG_DFL</primary></indexterm>
<indexterm scope="glibc-cp"><primary>sinyaller</primary><secondary>öntanımlı eylem</secondary></indexterm>
<command>SIG_DFL</command>, belli bir sinyal için öntenımlı olan eylemi belirtir. Çeşitli sinyaller için öntanımlı olan eylemler  <xref linkend="glibc-Standard-Signals"/> bölümünde bulunabilir.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>SIG_IGN</literal></term><listitem><para>
<indexterm scope="glibc-vr"><primary>SIG_IGN</primary></indexterm>
<indexterm scope="glibc-cp"><primary>sinyaller</primary><secondary>yoksayılan eylem</secondary></indexterm>
<command>SIG_IGN</command>, sinyalin yoksayılacağını belirtmek için kullanılır.
       </para><para>
Normalde yazılımınız birbiri ardınca gelen eylemlere ait sinyalleri ya da sonlandırma isteği olarak kullanılan sinyalleri yoksaymamalıdır. <command>SIGKILL</command> veya <command>SIGSTOP</command> sinyalini ne yaparsanız yapın yoksayamazsınız. <command>SIGSEGV</command> benzeri bir sinyali yoksayabilirsiniz, ama bir hatanın yoksayılması ve yazılımın çalışmasını sürdürmesi anlamlı olmaz. <command>SIGINT</command>, <command>SIGQUIT</command> ve <command>SIGTSTP</command> gibi kullanıcı isteğini belirten bir sinyali yoksaymak pek dostça sayılmaz.
       </para><para>
Yazılımınızın belli bir bölümünde sinyallerin alınmasını istemiyorsanız onları yoksaymayın, <link linkend="glibc-Blocking-Signals">onları engelleyebilirsiniz</link>.
       </para></listitem></varlistentry><varlistentry>
       <term><literal><varname>eylemci</varname></literal></term><listitem><para>
Sinyal alındığında yapılacak eylemi gerçekleştirecek işlevin adresi belirtilir.
       </para><para>
Sinyalle tetiklenen işlevler hakkında daha ayrıntılı bilgi edinmek için <xref linkend="glibc-Defining-Handlers"/> bölümüne bakınız.
       </para></listitem></varlistentry></variablelist></para><para>
Bir sinyal için <command>SIG_IGN</command> veya <command>SIG_DFL</command> belirtirseniz ve öntanımlı eylem sinyalin yoksayılması ise, bekleyen sinyallerden bu türde olanları (engellenmeye çalışılsa bile) iptal edilir. Bekleyen bir sinyalin iptal edilmesi, hemen ardından başka bir eylem belirtilmedikçe ve bu tür sinyallerin engellenmemesi istenmedikçe, bunların asla alınmayacağı anlamına gelir.
    </para><para>
<command>signal</command> işlevi, <varname>sinyalnum</varname> sinyali için evvelce belirtilmiş olan eylemle döner. Böylece, bu değeri saklayabilir ve daha sonra <command>signal</command> işlevini tekrar çağırarak bu eylemin tekrar etkin olmasını sağlayabilirsiniz.
    </para><para>
Eğer <command>signal</command> işlevi kendinden isteneni yerine getiremezse <command>SIG_ERR</command> ile döner. Bu işlev için tanımlanmış <command>errno</command> değerleri:
    </para><para><variablelist><varlistentry>
    <term><literal>EINVAL</literal></term><listitem><para>
Geçersiz bir <varname>sinyalnum</varname> belirttiniz; ya da <command>SIGKILL</command> veya <command>SIGSTOP</command> için sinyal yakalayıcı oluşturmaya ya da bunları yoksaymaya çalıştınız.
       </para></listitem></varlistentry></variablelist>
</para></funcdescr></funcsynopsis></para><para>
<note><title>Uyumluluk Bilgisi</title><para><command>signal</command> işlevi ile çalışırken saptanmış bir sorun,  BSD ve SVID sistemlerdeki davranış farkıdır. SVID sistemlerde sinyal yakalayıcı sinyal alındıktan sonra kendiliğinden tekrar kurulur. BSD sistemlerde ise yakalayıcı tekrar kurulmak zorundadır. GNU C kütüphanesinde öntanımlı olarak BSD sürümünü kullanıyoruz. SVID sürümünü kullanmak isterseniz, aşağıda anlatılan <command>sysv_signal</command> işlevini ya da bir makro seçici olan <command>_XOPEN_SOURCE</command>'u kullanabilirsiniz (<xref linkend="glibc-Feature-Test-Macros"/>). Uyumluluk sorunlarından kaçınmak için normalde bu işlevler kullanılmamalıdır. Bunlar yerine uyumluluk açısından bir sorun çıkarmayan <command>sigaction</command>'ı kullanmak daha iyidir.</para></note>
    </para><para>
Aşağıda, bazı ölümcül sinyaller alındığında geçici dosyaları silen basit bir yakalayıcı örneği yeralmaktadır:
    </para><para>
<screen>#include &lt;signal.h>

void
termination_handler (int signum)
{
  struct temp_file *p;

  for (p = temp_file_list; p; p = p->next)
    unlink (p->name);
}

int
main (void)
{
  ...
  if (signal (SIGINT, termination_handler) == SIG_IGN)
    signal (SIGINT, SIG_IGN);
  if (signal (SIGHUP, termination_handler) == SIG_IGN)
    signal (SIGHUP, SIG_IGN);
  if (signal (SIGTERM, termination_handler) == SIG_IGN)
    signal (SIGTERM, SIG_IGN);
  ...
}
</screen></para><para>
Eğer belirtilen bir sinyal evvelce yoksayılmaya ayarlanmışsa bu kodun bu ayarı değiştirmediğine dikkat edin. Bu, iş denetimi yapmayan kabukların alt süreçleri başlatırken bazı sinyalleri çoğunlukla yoksaymasından ve alt süreçler için buna riayet edilmesi önemli olduğundan dolayıdır.
    </para><para>
Yazılım hata sinyallerini veya <command>SIGQUIT</command> sinyalini, hata ayıklamada bilgi sağlamak için (bellek dökümü almak için) tasarlandıklarından ve geçici dosyalar hata ayıklamak için faydalı bilgiler sağlayabileceğinden bu örnekte işleme sokmadık.
    </para><para>
<indexterm scope="glibc-fn"><primary>sysv_signal</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-sysv_signal">
<funcdef>sighandler_t <command>sysv_signal</command></funcdef>
<paramdef>(int          <varname>sinyalnum</varname>,
 sighandler_t <varname>eylem</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>sysv_signal</command> işlevi, SVID sistemlerindeki standart <command>signal</command> işlevinin davranışını gereçekleştirmek için tasarlanmıştır. Bunun BSD sistemlerinden farkı, bir sinyalin alınmasının ardından yakalayıcının kendiliğinden tekrar kurulmasıdır.
    </para><para>
<note><title>Uyumluluk Bilgisi</title><para><command>signal</command> işlevi için yukarıda bahsedildiği gibi, bu işlevin kullanılmasından kaçınılmalı ve bunun yerine mümkünse <command>sigaction</command> tercih edilmelidir.</para></note>
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>ssignal</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-ssignal">
<funcdef>sighandler_t <command>ssignal</command></funcdef>
<paramdef>(int          <varname>sinyalnum</varname>,
 sighandler_t <varname>eylem</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>ssignal</command> işlevi <command>signal</command> işlevinin yaptığını yapar; sadece SVID ile uyum için vardır.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-vr"><primary>SIG_ERR</primary></indexterm>
<funcsynopsis><funcprototype role="makro" id="glibc-SIG_ERR">
<funcdef>sighandler_t <command>SIG_ERR</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu makronun değeri, <command>signal</command> işlevinin dönen bir hata değeri olarak kullanılır.
    </para></funcdescr></funcsynopsis></para></sect1>
    <sect1 id="glibc-Advanced-Signal-Handling">
      <title>Gelişmiş Sinyal İşleme</title>
      <titleabbrev><command>sigaction</command> daha güçlü bir işlevdir.</titleabbrev>
      <para>
<indexterm scope="glibc-cp"><primary><command>sigaction</command> işlevi</primary></indexterm>
<command>sigaction</command> işlevi <command>signal</command> işlevi ile aynı temel etkiye sahiptir: bir sinyalin süreç tarafından nasıl işleneceği belirtilir. Farklı olarak, sinyalin üretilmesi ve eylemcinin çağrılması ile ilgili çeşitli denetim seçenekleri belirtebilirsiniz.
    </para><para>
<command>sigaction</command> işlevi <filename>signal.h</filename> başlık dosyasında bildirilmiştir.
<indexterm scope="glibc-pg"><primary>signal.h</primary></indexterm>
    </para><para>
<indexterm scope="glibc-tp"><primary sortas="sigaction">struct sigaction</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü" id="glibc-struct-sigaction">
<funcdef>struct <command>sigaction</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
<command>struct sigaction</command> türündeki yapılar, <command>sigaction</command> işlevinde belli bir sinyalin nasıl işleneceği hakkındaki bilgilerin belirtilmesi için kullanılır. Bu yapı en azından aşağıdaki üyeleri içerir:
    </para><para><glosslist><glossentry><glossterm>
    <literal>sighandler_t <command>sa_handler</command></literal>
    </glossterm><glossdef><para>
<command>signal</command> işlevindeki <varname>eylem</varname> argümanının yerine geçer. Değer olarak, <command>SIG_DFL</command>,
<command>SIG_IGN</command> veya bir işlev göstericisi alır. Bkz. <xref linkend="glibc-Basic-Signal-Handling"/>.
    </para></glossdef></glossentry><glossentry><glossterm>
    <literal>sigset_t <command>sa_mask</command></literal>
    </glossterm><glossdef><para>
Eylemci çalışırken engellenecek sinyalleri belirtmek içindir. Sinyallerin engellenmesi <xref linkend="glibc-Blocking-for-Handler"/> bölümünde anlatılmıştır. Alınan bir sinyal, eylemcisi başlatılmadan önce öntanımlı olarak özdevinimli engellenir; bu,  <command>sa_mask</command>'ın değerine bakılmaksızın böyledir. Bir sinyalin eylemcisi nedeniyle engellenmemesini istiyorsanız eylemci içindeki kodu sinyalin engellenmemesini sağlayacak şekilde yazmalısınız.
    </para></glossdef></glossentry><glossentry><glossterm>
    <literal>int <command>sa_flags</command></literal>
    </glossterm><glossdef><para>
Burada, sinyalin davranışını etkileyebilen çeşitli seçenekler belirtilebilir. Bunlar <xref linkend="glibc-Flags-for-Sigaction"/> bölümünde daha ayrıntılı olarak açıklanmıştır.
    </para></glossdef></glossentry></glosslist>
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>sigaction</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-sigaction">
<funcdef>int <command>sigaction</command></funcdef>
<paramdef>(int                              <varname>sinyalnum</varname>,
 const struct sigaction *restrict <varname>eylem</varname>,
 struct sigaction *restrict       <varname>eski-eylem</varname>)</paramdef>
</funcprototype><funcdescr><para>
<varname>eylem</varname> argümanı ile <varname>sinyalnum</varname> sinyali için yeni bir eylem belirtilirken, <varname>eski-eylem</varname> argümanı, bu sembolle ilişkili evvelki eylem hakkında bilgi döndürmek için kullanılır. (başka bir deyişle, <varname>eski-eylem</varname> argümanı <command>signal</command> işlevinin dönüş değeri gibi kullanılmıştır. Bununla eski eylemin ne olduğuna bakabilir ve isterseniz bu eylemi tekrar yerinde bırakmak anlamında etkinleştirebilirsiniz.)
    </para><para>
Hem <varname>eylem</varname> hem de <varname>eski-eylem</varname> birer boş gösterici olabilir.  <varname>eski-eylem</varname> bir boş gösterici ise, <varname>sinyalnum</varname> sinyali ile ilişkili eylem değişmez; bu, bir sinyalin işlenme şeklini değiştirilmeksizin o sinyalin işlenmesi ile ilgili bilgi edinmenizi mümkün kılar.
    </para><para>
<command>sigaction</command> başarılı olduğunda sıfır ile aksi takdirde <command>-1</command> ile döner. Aşağıdaki bu işlev ile ilişkili <command>errno</command> değerleri bulunmaktadır:
    </para><para><variablelist><varlistentry>
    <term><literal>EINVAL</literal></term><listitem><para>
<varname>sinyalnum</varname> argümanı geçersiz; ya da <command>SIGKILL</command> veya <command>SIGSTOP</command> sinyali yoksayılmaya ya da yakalanmaya çalışılıyor.
       </para></listitem></varlistentry></variablelist>
    </para></funcdescr></funcsynopsis></para></sect1>
    <sect1 id="glibc-Signal-and-Sigaction">
      <title><literal>signal</literal> ve <literal>sigaction</literal> arasındaki etkileşim</title>
      <titleabbrev>Bu iki işlev nasıl etkileşir.</titleabbrev>
      <para>
<command>signal</command> ve <command>sigaction</command> işlevlerini aynı yazılım içinde kullanmak mümkündür. Ancak tuhaf bir yolla bu iki işlev birbirinden etkilenir, bu nedenle bu ikisini aynı yazılım içinde kullanıyorsanız dikkatli olmanız gerekir.
    </para><para>
<command>sigaction</command> işlevi <command>signal</command> işlevinden daha fazla bilgi içerir. Yani, <command>signal</command> işlevinin dönüş değeri <command>sigaction</command> işlevinin döndürdüğünden daha az bilgi döndürür. Diğer taraftan, bir eylemi kaydedip daha sonra etkinleştirmek için <command>signal</command> işlevini kullanırsanız, tekrar kurulan eylemci <command>sigaction</command> tarafından yeniden kurulan eylemci kadar düzgün oluşmayacaktır.
    </para><para>
Sonuç olarak, sorunlardan kaçınmak için, yazılımınızda her yerde <command>sigaction</command> kullanmışsanız, bir eylemi kaydetmek ve yeniden oluşturmak için yine <command>sigaction</command> işlevini kullanın. Hatta, <command>sigaction</command> daha genel olduğundan, bir eylem hangi işlev ile kurulmuş olursa olsun, bir eylemi orjinal haliyle saklamak ve yeniden oluşturmak için daima <command>sigaction</command> işlevini kullanın.
    </para><para>
Bazı sistemlerde, eğer bir eylemi <command>signal</command> ile oluşturup daha sonra <command>sigaction</command> ile incelerseniz eylemci işlevin adresinin <command>signal</command> işlevinin argümanı olarak belirtilen adresle aynı olmadığını görebilirsiniz. Hatta <command>signal</command> işlevinin bir argümanı olarak kullanmak için bile uygun olmayabilir. Ama <command>sigaction</command> işlevine bir argüman olarak kullanabilirsiniz. Bu sorun GNU sistemlerinde asla görülmez.
    </para><para>
Bu durumda, en iyisi bir yazılım içinde sürekli olarak bu mekanizmalardan sadece birini kullanmaktır.
    </para><para>
<note><title>Taşınabilirlik Bilgisi</title> <para><command>sigaction</command> işlevi POSIX.1'in parçası olduğu halde, <command>signal</command> işlevi bir ISO C oluşumudur. Yazılımınızın POSIX olmayan sistemlere taşınabilirliği bakımından kaygınız varsa,  <command>sigaction</command> yerine <command>signal</command> işlevini tercih etmelisiniz.</para></note>
    </para></sect1>
    <sect1 id="glibc-Sigaction-Function-Example">
      <title><literal>sigaction</literal> Örneği</title>
      <titleabbrev><command>sigaction</command> işlevinin kullanımına bir örnek.</titleabbrev>
      <para>
<xref linkend="glibc-Basic-Signal-Handling"/> bölümünde sonlandırma sinyalleri için <command>signal</command> işlevi kullanılan basit bir eylemci örneği verilmişti. Burada bu örneğin  <command>sigaction</command> eşdeğerini bulacaksınız:
    </para><para>
<screen>#include &lt;signal.h>

void
termination_handler (int signum)
{
  struct temp_file *p;

  for (p = temp_file_list; p; p = p->next)
    unlink (p->name);
}

int
main (void)
{
  ...
  struct sigaction yeni_eylem, eski_eylem;

  /* Yeni eylemi içeren yapıyı hazırlayalım. */
  yeni_eylem.sa_handler = termination_handler;
  sigemptyset (&amp;yeni_eylem.sa_mask);
  yeni_eylem.sa_flags = 0;

  sigaction (SIGINT, NULL, &amp;eski_eylem);
  if (eski_eylem.sa_handler != SIG_IGN)
    sigaction (SIGINT, &amp;yeni_eylem, NULL);
  sigaction (SIGHUP, NULL, &amp;eski_eylem);
  if (eski_eylem.sa_handler != SIG_IGN)
    sigaction (SIGHUP, &amp;yeni_eylem, NULL);
  sigaction (SIGTERM, NULL, &amp;eski_eylem);
  if (eski_eylem.sa_handler != SIG_IGN)
    sigaction (SIGTERM, &amp;yeni_eylem, NULL);
  ...
}
</screen></para><para>
Yazılım, <command>yeni_eylem</command> veri yapısını istenen parametrelerle yükler ve onu <command>sigaction</command> çağrısına aktarır. <command>sigemptyset</command> işlevinin kullanımı <xref linkend="glibc-Blocking-Signals"/> bölümünde açıklanmıştır.
    </para><para>
<command>signal</command> işlevinin kullanıldığı örnekte, evvelce yoksayılmaya ayarlanmış sinyalleri işlemekten kaçınmıştık. Bu örnekte ise yeni eylemi etkin kılmadan önce evvelki eylemi <command>sigaction</command> oluşumu sayesinde inceleme şansımız var. Böylece anlık bile olsa yoksayılmaya ayarlanmış bir sinyal eylemciyi değiştirmemiş oluyoruz.
    </para><para>
Aşağıda başka bir örnek var. <command>SIGINT</command> sinyali için eylemi değiştirmeksizin mevcut eylem hakkında bilgi alıyoruz:
    </para><para><screen>
struct sigaction query_action;

if (sigaction (SIGINT, NULL, &amp;query_action) &lt; 0)
  /* <command>sigaction</command> hata durumunda -1 döndürüyor. */
else if (query_action.sa_handler == SIG_DFL)
  /* <command>SIGINT</command> öntanımlı olarak yakalanıyor, ölümcül durum. */
else if (query_action.sa_handler == SIG_IGN)
  /* <command>SIGINT</command> yoksayılıyor. */
else
  /* Tanımlanan sinyal yakalayıcı etkinleştiriliyor. */
</screen></para></sect1>
    <sect1 id="glibc-Flags-for-Sigaction">
      <title><literal>sigaction</literal> Seçenekleri</title>
      <titleabbrev>Sinyal yakalayıcı için bazı seçenekler belirtilebilir.</titleabbrev>
      <para>
<indexterm scope="glibc-cp"><primary><command>sigaction</command> seçenekleri</primary></indexterm>
<command>sigaction</command> veri yapısının <command>sa_flags</command> üyesi özel durumları belirtmek içindir. Çoğu durumda, <command>SA_RESTART</command> bu alanda kullanmak için iyi bir değerdir.
    </para><para>
<command>sa_flags</command> üyesinin değeri bir bit maskesi olarak yorumlanır. Böylece çok sayıda seçenek belirtilebilir.
    </para><para>
Her sinyalin kendine has seçenekleri vardır. her <command>sigaction</command> çağrısı belli bir sinyal için yapılır ve belirtilen seçenekler de sadece bu sinyale uygulanır.
    </para><para>
GNU C kütüphanesinde, <command>signal</command> işlevi ile kurulan eylemci için bu seçenekler, değeri <command>siginterrupt</command> kullanımına bağlı olan <command>SA_RESTART</command> haricinde sıfıra ayarlanır. Bu durumla ilgili bilgiyi  <xref linkend="glibc-Interrupted-Primitives"/> bölümünde bulabilirsiniz.
    </para><para>
<indexterm scope="glibc-pg"><primary>signal.h</primary></indexterm>
Bu makrolar <filename>signal.h</filename> başlık dosyasında tanımlanmıştır.
    </para><para>
<indexterm scope="glibc-vr"><primary>SA_NOCLDSTOP</primary></indexterm>
<funcsynopsis><funcprototype role="makro" id="glibc-SA_NOCLDSTOP">
<funcdef>int <command>SA_NOCLDSTOP</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu seçenek sadece <command>SIGCHLD</command> sinyali için anlamlıdır. Bu seçenek etkin olduğunda sistem, durdurulan değil, sonlandırılan bir alt süreç olduğunda bu sinyali alır. Öntanımlı olarak, <command>SIGCHLD</command> sinyali hem durdurulan hem de sonlandırılan bir alt süreç olduğunda alınır.
    </para><para>
Bu seçenek <command>SIGCHLD</command> dışında bir sinyal için belirtildiğinde etkisizdir.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-vr"><primary>SA_ONSTACK</primary></indexterm>
<funcsynopsis><funcprototype role="makro" id="glibc-SA_ONSTACK">
<funcdef>int <command>SA_ONSTACK</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu seçenek belli bir sinyal için etkin olduğunda, sistem bu çeşit sinyalleri aldığında <link linkend="glibc-Signal-Stack">sinyal yığıtını</link> kullanır. Bu seçeneğin etkin olduğu bir sinyal alınırsa ve siz bir sinyal yığıtı oluşturmamışsanız, sistem yazılımınızı <command>SIGILL</command> sinyali ile sonlandırır.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-vr"><primary>SA_RESTART</primary></indexterm>
<funcsynopsis><funcprototype role="makro" id="glibc-SA_RESTART">
<funcdef>int <command>SA_RESTART</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu seçenek, <command>open</command>, <command>read</command> ve <command>write</command> gibi ilkellerin bir sinyal aldıklarında nasıl davranacaklarını belirler ve sinyal yakalayıcı normal olarak döner. İki durum söz konusu olabilir: kütüphane işlevi ya çalışmasını sürdürür ya da <command>EINTR</command> hata kodu ile başarısız olur.
    </para><para>
Seçimi belirleyen, sinyal alındığında <command>SA_RESTART</command>'ın etkin olup olmadığıdır. Etkinse, kütüphane işlevi çalışmasını sürdürür, değilse sinyal işlevin başarısız olmasına sebep olur. Bkz. <xref linkend="glibc-Interrupted-Primitives"/>.
    </para></funcdescr></funcsynopsis></para></sect1>
    <sect1 id="glibc-Initial-Signal-Actions">
      <title>Sinyal Eylemlerinin İlk Durumu</title>
      <titleabbrev>Yazılımlar sinyal eylemlerini nasıl miras alırlar.</titleabbrev>
      <para>
<indexterm scope="glibc-cp"><primary>sinyal eylemlerinin ilk durumu</primary></indexterm>
<link linkend="glibc-Creating-a-Process">Yeni bir süreç oluşturulduğunda</link>, sinyal yakalayıcılar onu oluşturan süreçten miras alınır. Bununla birlikte, yeni süreci <command>exec</command> işlevi ile yüklediğinizde (<xref linkend="glibc-Executing-a-File"/>), her sinyali <command>SIG_DFL</command> eylemine döndürecek kendi eylemcinizi tanımlamış olursunuz. (Burada durup biraz düşüneceksiniz, bu farklı birşey; eski yazılımın yakalama işlevleri ona özeldir ve yeni yazılımın adres alanında bunlar mevcut değildir.) Şüphesiz, yeni yazılım kendi eylemcilerini oluşturabilir.
    </para><para>
Bir yazılım bir kabukta çalıştırıldığında, normalde kabuk, oluşturduğu alt sürecin eylemlerini duruma göre <command>SIG_DFL</command> ya da <command>SIG_IGN</command>'e ayarlar. Kendi sinyal yakalayıcınızı oluşturmadan önce, kabuğun alt sürece başlangıç olarak <command>SIG_IGN</command> eylemini belirtmediğinden emin olmanız için onu kontrol etmeniz iyi olur.
    </para><para>
Bu örnekte,  eğer yoksayılmıyorsa <command>SIGHUP</command> sinyali için bir eylemcinin nasıl kurulacağı gösterilmiştir:
    </para><para>
<screen>...
struct sigaction temp;

sigaction (SIGHUP, NULL, &amp;temp);

if (temp.sa_handler != SIG_IGN)
  {
    temp.sa_handler = handle_sighup;
    sigemptyset (&amp;temp.sa_mask);
    sigaction (SIGHUP, &amp;temp, NULL);
  }
</screen></para></sect1></chapter>
  <chapter id="glibc-Defining-Handlers">
    <title>Sinyal Yakalayıcıların Tanımlanması</title>
    <titleabbrev>Sinyalle tetiklenen bir işlev nasıl yazılır.</titleabbrev>
    <para>
<indexterm scope="glibc-cp"><primary>sinyalle tetiklenen işlev</primary></indexterm>
Bu bölümde <command>signal</command> veya <command>sigaction</command> işlevi kullanılarak oluşturulan bir sinyal yakalama işlevinin nasıl yazılacağı anlatılmıştır.
   </para><para>
Bir sinyal yakalama işlevi, yazılımınızın içinde derlenen bir işlevdir. Tek farkla, bu işlevi doğrudan siz çağırmazsınız, <command>signal</command> veya <command>sigaction</command> işlevini kullanarak bir sinyal geldiğinde işletim sisteminin bu işlevi çağırmasını sağlarsınız. Buna <wordasword>eylemci oluşturmak</wordasword> diyoruz. Bkz. <xref linkend="glibc-Signal-Actions"/>.
   </para><para>
Bir eylemci işlevde kullanabileceğiniz iki strateji vardır:
   </para><itemizedlist><listitem><para>
Bazı genel veri yapılarıyla oynarken sinyal alındığında çalışan bir eylemciniz olabilir ve bu normal olarak döner.
     </para></listitem><listitem><para>
Eylemci işleviniz süreci sonlandırabilir ya da denetimi, sinyali oluşturan durumu ortadan kaldıran bir yere taşımanızı sağlayabilir.
     </para></listitem></itemizedlist><para>
Eylemci işlevleri yazmak için özellikle yardıma ihtiyacınız olacak, çünkü bu işlevlerin ne zaman çağrılacağı hiç belli olmaz. Hatta çok kısa aralıkla iki sinyal birden alabilirsiniz ve bu durumda bir eylemcinin başka bir eylemciyi çalıştırması gerekebilir. Bu kısımda eylemci işlevi yazarken neleri yapmanız neleri yapmamanız gerektiği açıklanmıştır.
   </para>
    <sect1 id="glibc-Handler-Returns">
      <title>Dönen Sinyal Yakalayıcılar</title>
      <titleabbrev>Süreci sonlandırmayan, normal olarak dönen eylemci işlevler.</titleabbrev>
      <para>
Normal olarak dönen eylemciler genellikle, G/Ç ve süreçler arası iletişim sinyalleri ile <command>SIGALRM</command> benzeri sinyaller için kullanılır. Ancak, <command>SIGINT</command> sinyali için de bir eylemci dönebilir. Bir farkla, sürece uygun bir zamanda sonlanmasını söyleyen bir seçeneği etkinleştirerek döner.
    </para><para>
Bir yazılım hata sinyali için normal olarak dönen bir işlev yazmak doğru olmayacaktır. Çünkü yazılımın davranışının bir yazılım hatası sinyali alındıktan sonra ne olacağı belli değildir. Bkz.  <xref linkend="glibc-Program-Error-Signals"/>.
    </para><para>
Normalde dönen eylemciler bir etki yaratması umulan bir genel değişkene değer atamalıdır. Bu değişken yazılımın çalışma anında belirli aralıklarla baktığı bir değişken olmalıdır. <xref linkend="glibc-Atomic-Data-Access"/> bölümünde açıklanan sebeplerle bu değişkenin veri türü <command>sig_atomic_t</command> olmalıdır.
    </para><para>
Aşağıda, böyle bir yazılım örneği vardır. Bir <command>SIGALRM</command> sinyali alınıncaya kadar bir döngüyü çalıştırmaktadır. Bu teknik, döngü tamamlanmadan bir sinyal alınıncaya kadar yinelenen işlemler için yararlıdır.
    </para><para>
<screen>#include &lt;signal.h>
#include &lt;stdio.h>
#include &lt;stdlib.h>

/* Bu değişken döngünün denetimi içindir. */
volatile sig_atomic_t keep_going = 1;

/* Sinyal yakalayıcı değişkeni sıfırlar ve kendini tekrar etkinleştirir. */
void
catch_alarm (int sig)
{
  keep_going = 0;
  signal (sig, catch_alarm);
}

void
do_stuff (void)
{
  puts ("Uyarı gelene kadar birşeyler yapılıyor....");
}

int
main (void)
{
  /* SIGALRM sinyalleri için bir eylemci oluşturalım. */
  signal (SIGALRM, catch_alarm);

  /* kısa süreli bir uyarıyı etkinleştirelim. */
  alarm (2);

  /* Her çevrimde değişkenin değerine bakılsın. */
  while (keep_going)
    do_stuff ();

  return EXIT_SUCCESS;
}
</screen></para></sect1>
    <sect1 id="glibc-Termination-in-Handler">
      <title>Süreci Sonlandıran Eylemciler</title>
      <titleabbrev>Eylemci işlevler bir süreci nasıl sonlandırır.</titleabbrev>
      <para>
Süreci sonlandıran eylemci işlevler genellikle düzenlenmiş bir durdurma için ya da yazılım hata sinyalleri ile etkileşimli kesmelerden kurtulmak amacıyla kullanılırlar.
    </para><para>
Süreci sonlandıran bir eylemci için en iyi yöntem aynı sinyali eylemci çalıştığı anda tekrar yayınlamaktır. Bunun yapılışına bir örnek:
    </para><para>
<screen>volatile sig_atomic_t fatal_error_in_progress = 0;

void
fatal_error_signal (int sig)
{
  /* Bu eylemci çok sayıda sinyal çeşidi için kurulduğundan,
     diğer sinyaller için de defalarca çağrılabilecektir. Bu
     durumu izlemek için bir durağan değişken kullanacağız. */
  if (fatal_error_in_progress)
    raise (sig);
  fatal_error_in_progress = 1;

  /* Şimdi biraz temizlik yapalım:
     - uçbirim kipleri sıfırlansın
     - alt süreçler ölsün
     - kilit dosyaları silinsin */
  …

  /* Şimdi sinyali tekrar yayınlayalım. Süreci sonlandırması için
     sinyalin öntanımlı eylemini etkin kılıyoruz.
     Tam bu anda <command>exit</command> veya <command>abort</command>
     çağrısı yapabilmeli ve sürecin çıkış durumunun doğru ayarlanması
     için sinyali yeniden yayınlamalıyız. */
  signal (sig, SIG_DFL);
  raise (sig);
}
</screen></para></sect1>
    <sect1 id="glibc-Longjmp-in-Handler">
      <title>Eylemci İşlevlerde Denetimin Aktarımı</title>
      <titleabbrev>Eylemci işlevlerde denetimin dışarı aktarılması</titleabbrev>
      <para>
<indexterm scope="glibc-cp"><primary>sinyal yakalayıcı ile denetimin dışa aktarımı</primary></indexterm>
Bir sinyal yakalayıcı için <command>setjmp</command> ve <command>longjmp</command> oluşumları kullanılarak denetim başka bir yere aktarılabilir. Bkz. <xref linkend="glibc-Non-Local-Exits"/>.
    </para><para>
Bir eylemci denetimi dışarı aktardığı zaman, çalışmakta olan yazılım kalan işlemi biteremez. Örneğin yazılım o anda önemli bir veri yapısını güncelliyorsa, veri yapısı belirsiz bir durumda kalacaktır. Süreç sonlandırıldığından belirsizlik daha sonra benzer şekilde bildirilecektir.
    </para><para>
Bu sorundan kaçınmanın iki yolu vardır. Biri, önemli veri yapısının güncellenmesi bitene kadar sinyalin engellenmesidir. Bkz.  <xref linkend="glibc-Blocking-Signals"/>.
    </para><para>
Diğer yol ise, önemli veri yapısını eylemci içinde yeniden ilklendirmek ve değerlerini belirli yapmaktır.
    </para><para>
Örnekte, bir genel değişkenin yeniden ilklendirilmesi gösterilmiştir:
    </para><para>
<screen>#include &lt;signal.h>
#include &lt;setjmp.h>

jmp_buf return_to_top_level;

volatile sig_atomic_t waiting_for_input;

void
handle_sigint (int signum)
{
  /* Sinyal alındığında girdi için beklemeliyiz, ama denetimi
     aktaracağımızdan artık bekleyemeyiz.  */
  waiting_for_input = 0;
  longjmp (return_to_top_level, 1);
}

int
main (void)
{
  ...
  signal (SIGINT, sigint_handler);
  ...
  while (1) {
    prepare_for_command ();
    if (setjmp (return_to_top_level) == 0)
      read_and_execute_command ();
  }
}

/* Bunun çeşitli komutlar için kullanılan bir yordam
   olduğunu hayal edin. */
char *
read_data ()
{
  if (input_from_terminal) {
    waiting_for_input = 1;
    ...
    waiting_for_input = 0;
  } else {
    ...
  }
}
</screen></para></sect1>
    <sect1 id="glibc-Signals-in-Handler">
      <title>Eylemci Çalışırken Sinyal Alınması</title>
      <titleabbrev>Sinyaller peşpeşe gelirse ne olacak.</titleabbrev>
      <para>
<indexterm scope="glibc-cp"><primary>sinyaller için yarış koşulları</primary></indexterm>
Sinyal yakalama işlevi çalışırken başka bir sinyal alındığıda ne olacak?
    </para><para>
Belli bir sinyal için eylemci işlev çağrıldığında eylemci işlemlerini bitirene kadar sinyal özdevinimli olarak engellenir. Bu, aynı iki sinyal peşpeşe alınırsa, biri için işlem tamamlanana kadar diğeri engellenecek demektir. (Bu türden birden fazla sinyal geldiğinde bunlara da izin vermek isterseniz, <command>sigprocmask</command> kullanarak sinyalin engellenmemesini sağlayabilirsiniz; bkz. <xref linkend="glibc-Process-Signal-Mask"/>.)
    </para><para>
Bununla birlikte, eylemci işleviniz başka çeşit bir sinyal ile hala durdurulabilir durumdadır. Bundan kaçınmak için, <command>sigaction</command> ile kullanılan veri yapısının <command>sa_mask</command> üyesinde eylemci çalışırken hangi sinyallerin engelleneğini belirtebilirsiniz. Bunlar eylemcinin çağrılmasına sebep olan sinyale ek olarak belirtilir ve diğer sinyaller normal olarak süreç tarafından engellenir. Bkz. <xref linkend="glibc-Blocking-for-Handler"/>.
    </para><para>
Eylemci işini bitirdiğinde engellenen sinyaller eylemcinin çalıştırılmadan önceki durumlarına dönerler. Bu durumda, eylemci işlev içinde <command>sigprocmask</command> kullanılması sadece eylemcinin çalışması sırasında gelen sinyalleri etkiler, eylemci işlev döndükten sonra gelen sinyalleri etkilemez.
    </para><para>
<note><title>Taşınabilirlik Bilgisi</title><para>
Yazılımınızın System V Unix üzerinde gerektiği gibi çalışmasını istiyorsanız ve eşzamansız bir sinyal alacağınızı umuyorsanız, bu sinyalin eylemcisini oluşturmak için daima <command>sigaction</command> kullanın. Bu sistem üzerinde <command>signal</command> ile oluşturulan bir eylemci ile sinyalin yakalanması özdevinimli olarak sinyal eyleminin öntanımlı eyleme yani <command>SIG_DFL</command>'a ayarlanmasına sebep olur. Böyle bir eylemci her çalıştığında kendini tekrar kurmalıdır. Bu uygulama, rahatsız edici olsa da, eylemci çalışırken sinyaller işleme alınamadığında da çalışır. Şöyle ki, hemen ardından başka bir sinyal gelebilir ve eylemci kendini daha kurmadan sinyal alınabilir. Bu durumda ikinci sinyal öntanımlı eylem ile karşılanacak ve süreç sonlanabilecektir.</para></note>
    </para></sect1>
    <sect1 id="glibc-Merged-Signals">
      <title>Eylemci Çalışmadan İkinci Bir Sinyalin Alınması</title>
      <titleabbrev>Eylemci işlev daha çalışmamışken ikinci bir sinyal gelirse ne olacak.</titleabbrev>
      <para>
<indexterm scope="glibc-cp"><primary>peşpeşe gelen sinyallerin işlenmesi</primary></indexterm>
<indexterm scope="glibc-cp"><primary>sinyaller</primary><secondary>ardışık</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>sinyaller</primary><secondary>katıştırma</secondary></indexterm>
Süreciniz bir sinyal yakalayıcının çalışmasından hemen önce aynı türden çok sayıda sinyal alırsa, yakalayıcı tek bir sinyal alınmış gibi sadece bir kere çalıştırılabilir. Gerçekte ise, sinyaller tek bir sinyal içine katıştırılmış olur. Bu durum, sinyal engellendiğinde ya da çok süreçli bir ortam da sistemin başka bir süreçle meşgul olduğı bir sırada ortaya çıkabilir. Bu, örneğin, bir sinyal yakalayıcıyı bir sinyal sayacı olarak kullanamayacağınız anlamına gelir. Ayırdına varacağınız tek şey, bir kerede en azından bir sinyal almış olduğunuz olacaktır.
    </para><para>
Aşağıda, alt süreç tarafından üretilen sinyallerin alınan sinyallerin sayısına eşit olmayışını telafi eden bir <command>SIGCHLD</command> yakalayıcısı örneği verilmiştir. Burada yazılımın, alt süreçlerin izini sürmek için bir yapı zinciri kullandığı varsayılmıştır:
    </para><para>
<screen>struct process
{
  struct process *next;
  /* Bu sürecin süreç kimliği.  */
  int pid;
  /* Bu süreçten gelen çıktıların yönlendirileceği
     uçbirim ya da boru tanımlayıcı. */
  int input_descriptor;
  /* Bu süreç durdurulursa ya da sonlandırılırsa
     değişkenin değeri sıfırdan farklı olacak.  */
  sig_atomic_t have_status;
  /* Bu sürecin durumu; çalışıyorsa sıfırdır,
     aksi takdirde <command>waitpid</command>'deki durum değeridir. */
  int status;
};

struct process *process_list;
</screen></para><para>
Bu örnek, hemen öncesinde bazı sinyallerin alınmasına bağlı olarak bir değişken de kullanıyor. Her seferinde yazılımın sonunda bu sıfırlanıyor.
    </para><para>
<screen>
/* Sıfırdan farklı bir değer alt sürecin durumunun
   değiştiği anlamına gelir. Bu durumla ilgili ayrıntılar
   için <command>process_list</command>'e bakılmalı. */
int process_status_change;
</screen></para><para>
Eylemci:
    </para><para>
<screen>void
sigchld_handler (int signo)
{
  int old_errno = errno;

  while (1) {
    register int pid;
    int w;
    struct process *p;

    /* Tanımlanabilir bir sonuç alana kadar sorguyu sürdürüyoruz.  */
    do
      {
        errno = 0;
        pid = waitpid (WAIT_ANY, &amp;w, WNOHANG | WUNTRACED);
      }
    while (pid &lt;= 0 &amp;&amp; errno == EINTR);

    if (pid &lt;= 0) {
      /* Bir alt süreç kalmamışsa çıkabiliriz.  */
      errno = old_errno;
      return;
    }

    /* Sinyal gönderen süreci bulalım ve durumunu kaydedelim.  */

    for (p = process_list; p; p = p->next)
      if (p->pid == pid) {
        p->status = w;
        /* Durum alanınnı bir veri içerdiğini belirtelim.
           Bunu onu sakladıktan sonra yapıyoruz.  */
        p->have_status = 1;

        /* Süreç sonlandırılmışsa çıktısını beklemekten vazgeçiyoruz.  */
        if (WIFSIGNALED (w) || WIFEXITED (w))
          if (p->input_descriptor)
            FD_CLR (p->input_descriptor, &amp;input_wait_mask);

        /* Yazılım arasıra bu değişkene süreç listesinde yeni bir
           süreç var mı diye bakmalı.  */
        ++process_status_change;
      }

    /* Bize söyleyecek birşeyleri var mı diye tekrar dönüp tüm
       süreçlere bakalım.  */
  }
}
</screen></para><para>
<command>process_status_change</command> değişkenini denetlemek için bir yöntem:
    </para><para><screen>
if (process_status_change) {
  struct process *p;
  process_status_change = 0;
  for (p = process_list; p; p = p->next)
    if (p->have_status) {
      … <command>p->status</command> incelemesi …
    }
}
</screen></para><para>
Listeyi incelemeye başlamadan önce seçeneğin temizlenmesi hayati önemdedir; aksi takdirde, seçeneğin temizlenmesinden önce bir sinyal alınırsa ve süreç listesinin ilgili elemanı etkinse, bu seçenekle ilgili olarak sinyal hakkında bir uyarı alınamayacaktır. Bu sorundan kaçınmak için listeyi taramaya başlamadan önce seçeneği temizlemeniz gerekir; bazı işlemleri doğru sırada yapmak önemlidir.
    </para><para>
Döngüde <command>p-status</command> alanı incelenerek, sürecin durumu hakkında bilgi edinilmeye çalışılır. <command>p->have_status</command> etkin bir değere sahipse, süreç durdurulmuş ya da sonlandırılmıştır; değilse, yazılım tekrar uyarı alana kadar durdurulamamış ya da sonlandırılamamıştır. Bir değişkene erişim sırasındaki kesmelerin kaydedilmesi hakkında daha fazla bilgi için <xref linkend="glibc-Atomic-Usage"/> bölümüne bakınız.
    </para><para>
Bşaka bir yol da, sinyal yakalayıcının son sınamadan beri çalıştırılıp çalıştırılmadığına bakmaktır. Bu teknikte, sinyal yakalayıcının dışında değiştirilmeyen bir sayaç kulanılır. Sayacı sıfırlamak yerine, yazılım sayacın son değerini hatırlayarak önceki sınamadan beri bir değişiklik olup olmadığına bakar. Bu yöntemin bir faydası da, yazılımın parçalarının birbirinden bağımsız olarak denetlenebilmesidir.
    </para><para>
<screen>
sig_atomic_t process_status_change;

sig_atomic_t last_process_status_change;

…
{
  sig_atomic_t prev = last_process_status_change;
  last_process_status_change = process_status_change;
  if (last_process_status_change != prev) {
    struct process *p;
    for (p = process_list; p; p = p->next)
      if (p->have_status) {
        … <command>p->status</command> incelemesi…
      }
  }
}
</screen></para></sect1>
    <sect1 id="glibc-Nonreentrancy">
    <title>Sinyal İşleme ve Evresel Olmayan İşlevler</title>
    <titleabbrev>Sinyaller bakımından evresel olduğunu bilmedikçe hiçbir işlevi çağırmayın.</titleabbrev>
    <para>
<indexterm scope="glibc-cp"><primary>sinyal işleme</primary><secondary>işlevlerle ilgili sınırlamalar</secondary></indexterm>
Sinyal yakalama işlevleri genelde çok zor değildir. En iyi çözüm, hiçbir şey yapmayan ama yazılımın sürekli sınadığı bir harici değişkene değer atayan ve bu değişkenle ilgili işlemleri yazılıma bırakan bir kod yazmaktır.  En iyisi budur çünkü, eylemci işlev rasgele, umulmadık bir zamanda, basit bir işlevin ortasında ve hatta çok sayıda makine kodu komut gerektiren C işleçlerinin başlangıcı ile sonu arasında çağrılabilir. Üzerinde çalışılan veri yapıları eylemci işlevler çağrıldığında kararsız durumda bile olabilirler. Bir <command>int</command> türünden değişkenin diğerine kopyalanması çoğu makinede iki makine komutundan oluşur.
    </para><para>
Bu, bir sinyal yakalayıcı ile ne yapmaya hazırlandığınıza bağlı olarak çok dikkatli olmak zorunda olduğunuz anlamına gelir.
    </para><para><itemizedlist><listitem><para>
<indexterm scope="glibc-cp"><primary><command>volatile</command> bildirimler</primary></indexterm>
Eğer eylemci işlevin yazılımınızdan herhangi bir genel değişkene erişmesi gerekiyorsa bu değişkenleri <command>volatile</command> olarak bildirin. Bu, derleyiciye bu değişkenin herhangi bir anda değişebileceğini ve bu tür değişikliklere göre değerlendirilmiş eniyilemelerin yapılmamasını söyler.
      </para></listitem><listitem><para>
<indexterm scope="glibc-cp"><primary>evresel işlevler</primary></indexterm>
Eylemci içinden bir işlev çağırıyorsanız, onun sinyallerle ilgili olarak <wordasword>evresel</wordasword> olduğundan, değilse, başka bir ilgili işlev tarafından sinyalin engellenmediğinden emin olmalısınız.
      </para></listitem></itemizedlist></para><para>
Bir işlev yığıtı değil de belleği kullanıyorsa evresel olmayabilir.
    </para><para><itemizedlist><listitem><para>
Bir işlev bir durağan veya bir genel ya da sadece kendinin erişebildiği bir özdevimli ayrılmış nesne kullanıyorsa, evresel olmayabilir ve işlevin herhangi iki çağrısı bir diğeri ile etkileşebilir.
      </para><para>
Örneğin sinyal yakalayıcının <command>gethostbyname</command> işlevini kullandığını varsayalım. Bu işlev değerini bir durağan nesne içinde döndürür. Eğer <command>gethostbyname</command> çağrısı sırasında ya da çağrının ardından (yazılım hala bu değeri kullanıyorken) bir sinyal gelirse, yazılımın istediği değerin taşmasına sebep olabilir.
      </para><para>
Diğer yandan, yazılım <command>gethostbyname</command> işlevini ya da aynı nesnedeki bilgiyi döndüren herhangi bir başka işlev kullanmıyorsa ya da her kullanımda daima sinyaller engelleniyorsa  güvendesiniz demektir.
      </para><para>
Değeri bir sabit nesne içinde döndüren ve bu şekilde aynı nesnenin daima yeniden kullanılabilir olmasını sağlayan çok sayıda kütüphane işlevi vardır ve bunların tamamı aynı soruna yol açabilir. Bu kılavuzdaki işlev açıklamalarında bu davranış daima açıklanmıştır.
      </para></listitem><listitem><para>
Eğer bir işlev, sizin tanımladığınız bir nesneyi kullanıyor ve değiştiriyorsa, büyük ihtimalle işlev evresel değildir; bu işlevlerin aynı nesneyi kullanması halinde birbirlerini etkileyebilirler.
      </para><para>
Akımlarla G/Ç işlemleri yaptığınızda bu durum ortaya çıkabilir. Bir sinyal yakalayıcını <command>fprintf</command> işlevi ile bir ileti bastığını varsayalım. Tam da aynı akımı kullanan bir <command>fprintf</command> çağrısının ortasında yazılımın bir sinyal aldığını varsayalım. Hem sinyal eylemcinin hem de yazılımın verisi bozulurdu, çünkü her iki çağrı kendi akımı üzerinde aynı veri yapısıyla çalışıyor olacaklardı.
      </para><para>
Bununla birlikte, eylemcinin kullandığı akımın sinyal geldiğinde yazılım tarafından kullanılması mümkün olmayabilir ki, bu durumda güvendesiniz demektir. Yazılım başka bir akımı kullanıyorsa sorun yoktur.
      </para></listitem><listitem><para>
Çoğu sistemde, hangi bellek bloklarının serbest bırakılacağını kaydettikleri bir durağan veri yapısı kullandıklarından <command>malloc</command> ve <command>free</command> evresel değildir. Sonuç olarak, bellek ayıran ve serbest bırakan kütüphane işlevleri evresel olmayacaktır. Bu, bir sonucu saklayacağı alanı ayıran işlevleri de kapsar.
      </para><para>
Bir yakalama işlevi içinde bellek ayırma ihtiyacından kaçınmanın en iyi yolu, işlev için kullanılacak alanı önceden ayırmaktır.
      </para><para>
Bir yakalama işlevi içinde belleği serbest bırakma ihtiyacından kaçınmanın en iyi yolu ise, serbest bırakılacak nesneleri kaydetmek ya da imlemek ve yazılımda zaman zaman bu türde serbest bırakılmayı bekleyen nesneler olup olmadığına bakmaktır. Fakat bu dikkatli yapılmalıdır çünkü bir nesnenin bir zincire yerleştirilmesi atomik değildir ve başka bir sinyal yakalayıcı ile işlem kesmeye uğratılırsa nesnelerden birinin kaybedilmesi gibi şeyler olabilir.
      </para></listitem><listitem><para>
<command>errno</command> değişkenini değiştiren işlevler evresel değildir, fakat bunu düzeltebilirsiniz: eylemcide  <command>errno</command> değişkeninin orjinal değerini kaydedip normal olarak dönmeden önce eski yerine koyabilirsiniz. Bu, sistemin bir sinyalle tetiklediği eylemcinin çalışmaya başlamasıyla alınması engellenen hataların eylemcinin işi bittiğinde elde edilebilmesini sağlar.
      </para><para>
Bu teknik genellikle uygulanabilirdir; belli bir nesneyi bellekte değiştiren bir işlevi bir sinyal yakalayıcı içinden çağırmak isterseniz, bunu nesneyi kaydederek ve sonra eski değeri yerine koyarak rahatça yapabilirsiniz.
      </para></listitem><listitem><para>
Sadece, bir sinyal alındığında bir bellek nesnesinin okunması güvenli olabilir. Ancak, bazı veri türlerinde atama işleminin birden fazla makine komutuna malolduğunu unutmayın, bir sinyal yakalayıcı çalışmaya başladığı anda eğer <link linkend="glibc-Atomic-Data-Access">atomik değilse bir değişkene yapılan atama</link> işleminin arasına girebilir.
      </para></listitem><listitem><para>
Bir sinyal alındığında, bir bellek nesnesine yazma işlemi sadece değerin olabildiğince anlık bir değişikliğinde güvenli olabilir. Bu durumda eylemcinin çalışması birşeyi bozmaz.
      </para></listitem></itemizedlist></para></sect1>
    <sect1 id="glibc-Atomic-Data-Access">
      <title>Atomik Veri Erişimi ve Sinyal İşleme</title>
      <titleabbrev>Bir sinyal yakalayıcı, bir nesnenin okunması ya da yazılması işleminin arasına girebilir.</titleabbrev>
      <para>
Uygulama verinizin atomsal ya da sırt metin olup olmamasına bağlı olarak, atomik olmayan tek bir veriye erişirken dikkatli olmalısınız. Bir nesnenin okunması ya da yazılması tek bir makine kodu ile gerçekleşemeyebilir, böyle bir durumda bir sinyal yakalayıcı işlemin arasına girebilir ve işlem yarıda kalabilir.
    </para><para>
Bu sorunla ilgili olarak uygulanabilecek üç yöntem vardır. Veri türlerine erişimi atomsal yapabilirsiniz; işlemi dikkatlice yapılandırabilir böylece erişimin kesilmesi sözkonusu ise böyle bir veri erişimini hiç yapmazsınız ya da veriye erişirken işlem sırasında sinyallerin tamamını <link linkend="glibc-Blocking-Signals">engellersiniz</link>.
    </para>
      <sect2 id="glibc-Non-atomic-Example">
        <title>Atomsal Olmayan Veriye Erişimle İlgili Sorunlar</title>
        <titleabbrev>Veriye erişimin kesmeye uğratıldığı yazılıma bir örnek.</titleabbrev>
        <para>
Bu örnekte, bir değişkenin değerinin değiştirilmesi sırasında bir sinyal yakalama işlevinin araya girdiği durum gösterilmiştir. (Bir değişkenin okunması sırasında kesintiye uğratılması mantıksız sonuçlara sebep olabilir, ama burada sadece yazma olayı gösterilmiştir.)
     </para><para>
<screen>#include &lt;signal.h>
#include &lt;stdio.h>

volatile struct two_words { int a, b; } memory;

void
handler(int signum)
{
    printf ("%d,%d\n", memory.a, memory.b);
    alarm (1);
}

int
main (void)
{
    static struct two_words zeros = { 0, 0 }, ones = { 1, 1 };
    signal (SIGALRM, handler);
    memory = zeros;
    alarm (1);
    while (1)
      {
        memory = zeros;
        memory = ones;
      }
}
</screen></para><para>
Yazılım, <command>memory</command> değişkenini sırayla sıfırlarla ve birlerle doldurmaktadır. Bu sırada her saniyede bir, alarm sinyalinin yakalayıcısı o anki içeriği basmaktadır. (Eylemci içinde <command>printf</command> kullanımı, sinyal oluştuğu sırada <command>printf</command> eylemci dışında çağrılmadığından bu kod için sorun çıkarmaz.)
     </para><para>
Başka bir deyişle yazılım sıfır ya da bir çiftlerinde birini basar. Ama bu iş tamamen bizim istediğimiz gibi olmaz! Çoğu makinede, <command>memory</command> değişkeninde yeni değerin saklanması bir makine komutundan fazlasına ihiyaç duyar. Bu komutların çağrılması sırasında bir sinyal alınırsa, eylemci <command>memory.a</command> için 0, <command>memory.b</command> için 1 ya da tersini basabilir (Normalde ikisi de aynı olmalıydı).
     </para><para>
Bazı makineler, işlemi tek bir makine kodu ile yapabilir ve bu durumda eylemci daima sıfır ya da bir çiftleri basar.
     </para></sect2>
       <sect2 id="glibc-Atomic-Types">
         <title>Atomsal Türler</title>
         <titleabbrev>Kesmeye uğratılamayan veri türleri.</titleabbrev>
         <para>
Bir değişkene erişimin ne olursa olsun kesintiye uğratılamamasını sağlam için erişimin daima atomsal olduğu veri türünü kullanabilirsiniz: <command>sig_atomic_t</command>. Bu veri türündeki bir değişkene yapılan bir okuma veya yazma işleminin tek bir makine kodu ile gerçekleştirilmesi garanti edilmiştir. Böylece bir sinyal yakalayıcının işlemin arasına girmesi engellenmiş olur.
     </para><para>
<command>sig_atomic_t</command> türü daima bir tamsayı veri türüdür, ama hangisi olduğu yani kaç bit genişlikte olduğu makineden makineye değişebilir.
     </para><para>
<indexterm scope="glibc-tp"><primary>sig_atomic_t</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü" id="glibc-sig_atomic_t">
<funcdef><command>sig_atomic_t</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu bir tamsayı veri türüdür. Bu türdeki nesnelere erişim daima atomsaldır.
</para></funcdescr></funcsynopsis></para><para>
Uygulamada, <command>int</command> türünü atomsal olduğunu varsayabilirsiniz. Ayrıca çok elverişli olmasa da gösterici türlerininde atomsal olduğunu varsayabilirsiniz. GNU C kütüphanesini destekleyen makinelerde ve bilinen tüm POSIX sistemlerinde her iki kabulde geçerlidir.
     </para></sect2>
      <sect2 id="glibc-Atomic-Usage">
        <title>Atomsal Kullanım Şekilleri</title>
        <titleabbrev>Kesmenin bozuculuğunun saptanması.</titleabbrev>
        <para>
Bir erişimin kesmeye uğratılmasından kaçınılmasını sağlayan belli erişim şekikilleri vardır. Örneğin, sinyal yakalama işlevi tarafından bir seçenek etkinleştirilebilir ve ana yazılım tarafından bu değişken zaman zaman 1 ya da 0 yapılabilir. Böylece, bir veriye erişim için iki komut gerekiyorsa bu işlem güvenceye alınmış olur. Bunun böyle olduğunu göstermek için, veriye her erişimin kesmeye uğratılmaya çalışıldığını kabul edeceğiz, ancak kesmeye uğratılsa bile bunun bir sorun oluşturmadığını göstereceğiz.
     </para><para>
Seçeneğin sınanması sırasında bir kesme sorun çıkarmayacaktır, çünkü ya değerin kesinliğinin önemi olmadığı duruma karşılık değer sıfırdan farklı olacak ya da bir sonraki sınama için sıfırdan farklı görünecektir.
     </para><para>
Seçeneğin sıfırlanması sırasında da bir kesme sorun çıkarmayacaktır, çünkü seçenek sıfırlanmadan önce bir sinyal geldiğinde ne olacağına bağlı olarak ya değer sıfır olacak ya da sıfırdan farklı olacaktır.Kod her iki durumu da olması gerektiği gibi mümkün olduğunca iyi elde eder, ayrıca seçeneğin sıfırlanması sırasında bir sinyal yakalama işlemi de yapılabilir.
     </para><para>
Kimi zaman, bir nesneye erişimin kesintiye uğratılmamasını, nesnenin başka bir nesne tarafından korunmasını sağlayarak sağlama alabilirsiniz, bu da atomsallığı garanti etmenin yollarından biridir. Örnek için  <xref linkend="glibc-Merged-Signals"/> bölümüne bakınız.
     </para></sect2></sect1>
   </chapter>

<chapter id="glibc-Interrupted-Primitives">
  <title>Sinyallerle Kesilen İlkeller</title>
  <titleabbrev><command>open, read, write</command> ve benzeri işlevleri kesintiye uğratan sinyal eylemciler.</titleabbrev>
  <para>
<command>open</command> veya <command>read</command> benzeri bir G/Ç ilkeli bir G/Ç aygıtını beklerken bir sinyal alabilir ve bu sinyal işleme sokulabilir. Sinyalin eylemcisi işlemlerini bitirdikten sonra sistem bir sorunla başbaşa kalır: şimdi ne olacak?
   </para><para>
POSIX bir yaklaşım belirtir: bir ilkel başarısız olduğunda ne yapacaksan beklemeden yap. Bu çeşit başarısızlıklar için hata kodu <command>EINTR</command>'dir. Genellikle, sinyal eylemciler kullanılan POSIX uygulamaları bu hatayı döndüren her işlev çağrısının dönüş durumuna mutlaka bakmalıdır. Çoğunlukla yazılımcılar bu genel hata kaynağına bakmayı unuturlar.
   </para><para>
GNU kütüphanesi, geçici bir başarısızlığın ardından çağrının yinelenmesini sağlayan oldukça kullanışlı bir yöntem olan <command>TEMP_FAILURE_RETRY</command> makrosunu içerir:
   </para><para>
<indexterm scope="glibc-fn"><primary>TEMP_FAILURE_RETRY</primary></indexterm>
<funcsynopsis><funcprototype role="makro" id="glibc-TEMP_FAILURE_RETRY">
<funcdef><command>TEMP_FAILURE_RETRY</command></funcdef>
<paramdef>(<varname>ifade</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu makro <varname>ifade</varname>'yi bir kere değerlendirir ve <command>long int</command> türünde döner. Eğer değer <command>-1</command> ise bu bir başarısızlık gösterir ve <command>errno</command> değişkenine hata durumu atanır. Eğer başarısız olursa ve <command>EINTR</command> hata kodunu raporlarsa, <command>TEMP_FAILURE_RETRY</command> onu tekrar değerlendirmeye tabi tutar ve bu işlem geçici başarısızlık durumu ortadan kalkana dek yinelenir.
   </para><para>
<command>TEMP_FAILURE_RETRY</command> makrosunun dönüş değeri <varname>ifade</varname>'nin dönüş değeri neyse odur.
</para></funcdescr></funcsynopsis></para><para>
BSD, <command>EINTR</command> hata kodunu hiç göstermez ve daha iyi bir yaklaşım yapar: kesintiye uğratılan ilkeli başarısız olarak döndürmez ve hep yeniden başlatır. Bu yaklaşımı benimserseniz <command>EINTR</command> ile ilgilenmeniz gerekmez.
   </para><para>
GNU kütüphanesindeki yaklaşımı seçebilirsiniz. Bir sinyal yakalayıcıyı <command>sigaction</command> ile kuruyorsanız, eylemcinin nasıl davranacağını belirtebilirsiniz. <command>SA_RESTART</command> seçeneğini belirtirseniz eylemci döndükten sonra ilkel kaldığı yerden işine devam eder, belirtmezseniz eylemci <command>EINTR</command> hatasının dönmesine sebep olacaktır. Bkz. <xref linkend="glibc-Flags-for-Sigaction"/>.
   </para><para>
Seçiminizi belirtmenin diğer bir yolu da <command>siginterrupt</command> işlevidir. Bkz. <xref linkend="glibc-BSD-Handler"/>.
   </para><para>
Bir sinyal yakalayıcının ne yapacağını <command>sigaction</command> veya <command>siginterrupt</command> ile belirtmezseniz, öntanımlı seçim kullanılır. GNU kütüphanesinde öntanımlı seçim sizin tanımladığınız sınama makrolarına bağlıdır. <command>signal</command> işlevini çağırmadan önce <command>_BSD_SOURCE</command> veya <command>_GNU_SOURCE</command> makrosunu tanımlarsanız, öntanımlı davranış ilkelin işlemi kaldığı yerden devam ettirmesidir; aksi takdirde, öntanımlı davranış <command>EINTR</command> ile başarısızlık olacaktır. (Kütüphane <command>signal</command> işlevinin diğer sürümlerini de içerir ve özellik sınama makroları gerçekte hangisinin kullanılacağının saptanmasını sağlar.) Bkz. <xref linkend="glibc-Feature-Test-Macros"/>.
<indexterm scope="glibc-cp"><primary>EINTR</primary><secondary>kesmeye uğratılan ilkellerin yeniden başlatılması</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>kesmeye uğratılan ilkellerin yeniden başlatılması</primary></indexterm>
<indexterm scope="glibc-cp"><primary>kesmeye uğratılan ilkeller</primary></indexterm>
<indexterm scope="glibc-cp"><primary>ilkeller</primary><secondary>kesme</secondary></indexterm>
   </para><para>
Bu kısımda bahsedilen her ilkel, hata kodu olarak <command>EINTR</command> döndürebilen ilkellerden biridir.
   </para><para>
Seçimizden etkilenmeyen ve işlemin kaldığı yerden devamına konu olmayan tek bir durum vardır: <command>read</command> veya <command>write</command> gibi bir veri aktarım işlevi verinin bir parçasını aktardıktan sonra bir sinyal aldığında. Bu durumda işlev zaten, kısmi başarıyı belirtmek üzere aktarılan baytların sayısı ile dönecektir.
   </para><para>
Bunun en başta kayıt yönlenimli aygıtlarda (datagram soketleri gibi; bkz. <xref linkend="glibc-Datagrams"/>) beklenmeyen davranışlara sebep olduğu görülür; bir <command>read</command> ya da <command>write</command> işleminin ikiye bölünmesi iki okuma ya da yazmaya sebep olur. Aslında, bir sorun yoktur, çünkü böyle aygıtlarda bir kısmi aktarım sonrası kesme oluşamaz; bunlar bir kaydın tümünü veri aktarımı bir kez başladı mı beklemeksizin tek bir seferde aktarırlar.
   </para></chapter>
<chapter id="glibc-Generating-Signals">
  <title>Sinyallerin Üretilmesi</title>
  <titleabbrev>Bir sinyal bir sürece nasıl gönderilir.</titleabbrev>
  <para>
<indexterm scope="glibc-cp"><primary>sinyaller</primary><secondary>gönderilmesi</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>sinyaller</primary><secondary>kendine gönderme</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>sinyaller</primary><secondary>üretilmesi</secondary></indexterm>
Sinyallerin bir donanım kapanı ya da kesmesinin sonucu olarak üretilmesine ilaveten, yazılımınız da kendisine ya da başka süreçlere doğrudan doğruya sinyal gönderebilir.
   </para>
    <sect1 id="glibc-Signaling-Yourself">
      <title>Kendine Sinyal Gönderme</title>
      <titleabbrev>Bir süreç kendine nasıl sinyal gönderir.</titleabbrev>
      <para>
Bir sürecin kendine sinyal göndermesi için <command>raise</command> işlevi kullanılır. Bu işlev <filename>signal.h</filename> başlık dosyasında bildirilmiştir.
<indexterm scope="glibc-pg"><primary>signal.h</primary></indexterm>
   </para><para>
<indexterm scope="glibc-fn"><primary>raise</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-raise">
<funcdef>int <command>raise</command></funcdef>
<paramdef>(int <varname>sinyalnum</varname>)</paramdef>
</funcprototype><funcdescr><para>
işlev çağrıldığı sürece <varname>sinyalnum</varname> sinyalini gönderir. İşlem başarılı olursa sıfırla, aksi takdirde sıfırdan farklı bir değerle döner. Başarısızlığın tek sebebi <varname>sinyalnum</varname> değerinin geçersiz olmasıdır.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>gsignal</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-gsignal">
<funcdef>int <command>gsignal</command></funcdef>
<paramdef>(int <varname>sinyalnum</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>raise</command> ile aynı işi yapar; sadece SVID uyumluluğu için vardır.
</para></funcdescr></funcsynopsis></para><para>
<command>raise</command> işlevinin genellikle kullanıldığı tek yer yakalanan sinyalin öntanımlı davranışını yeniden üretmektir. Örneğin, yazılımınızın bir kullanıcısının SUSP karakterini (<command>C-z</command>; bkz. <xref linkend="glibc-Special-Characters"/>) tuşladığını varsayalım. Bu işlem yazılıma etkileşimli durdurma sinyalinin (<command>SIGTSTP</command>) gönderilmesine sebep olur. Bu durumda siz de durdurma öncesi bazı tamponları temizlemek istersiniz. Bunu da şöyle yaparsınız:
    </para><para>
<screen>#include &lt;signal.h>

/* Bir durdurma sinyali geldiğinde, eylemi önce öntanımlı eyleme
   ayarlayalım, temizliği yaptıktan sonra da sinyali yeniden
   gönderelim. */

void
tstp_handler (int sig)
{
  signal (SIGTSTP, SIG_DFL);
  /* Temizlik işlemleri */
  ...
  raise (SIGTSTP);
}

/* Süreç çalışmaya kaldığı yerden devam edeceği zaman
   sinyal eylemciyi yeniden kuralım. */

void
cont_handler (int sig)
{
  signal (SIGCONT, cont_handler);
  signal (SIGTSTP, tstp_handler);
}

/* Her iki eylemciyi de yazılım başlatıldığında etkinleştirelim. */

int
main (void)
{
  signal (SIGCONT, cont_handler);
  signal (SIGTSTP, tstp_handler);
  ...
}
</screen></para><para>
<note><title>Taşınabilirlik Bilgisi</title><para><command>raise</command> işlevi ISO C komisyonu tarafından tasarlanmıştır. Daha eski sistemler işlevi desteklemeyebilir, bu bakımdan <command>kill</command> işlevinin kullanılması daha taşınabilir olacaktır. Bkz. <xref linkend="glibc-Signaling-Another-Process"/>.</para></note>
    </para></sect1>
  <sect1 id="glibc-Signaling-Another-Process">
    <title>Başka Bir Sürece Sinyal Gönderme</title>
    <titleabbrev>Bir sinyalin başka bir sürece gönderilmesi.</titleabbrev>
    <para>
<indexterm scope="glibc-cp"><primary>bir sürecin öldürülmesi</primary></indexterm>
<command>kill</command> işlevi bir sinyalin başka bir sürece gönderilmesi için kullanılır. İsmine rağmen, bir sürecin sonlandırılmasına sebep olmaktan farklı birşeyler yapmak için de kullanılabilir. Süreçler arasında sinyal gönderilmesini gerektiren durumlara ilişkin bazı örnekler:
    </para><itemizedlist><listitem><para>
Bir süreç bir işlemi yerine getirmesi için kendini bir alt süreç olarak çalıştırabilir -- bir altsüreç çalıştırılması bir kısır döngü oluşturabilir -- ve işlem yerine getirildiğinde alt sürecini sonlandırabilir.
      </para></listitem><listitem><para>
Bir hata oluştuğunda ya da bir olay gerçekleştiğinde, bir süreç, bir grubun parçası olarak çalıştırılıp gruptaki başka bir süreci uyarmak ya da sonlandırmak için kullanılabilir.
      </para></listitem><listitem><para>
Birlikte çalışan iki sürecin eşzamanlanması gerekir.
      </para></listitem></itemizedlist><para>
Bu bölümde <link linkend="glibc-Processes">bir sürecin nasıl çalıştığını</link> bildiğinizi varsayacağız.
    </para><para>
<command>kill</command> işlevi <filename>signal.h</filename> dosyasında bildirilmiştir.
<indexterm scope="glibc-pg"><primary>signal.h</primary></indexterm>
    </para><para>
<indexterm scope="glibc-fn"><primary>kill</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-kill">
<funcdef>int <command>kill</command></funcdef>
<paramdef>(pid_t <varname>pid</varname>,
 int   <varname>sinyalnum</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>kill</command> işlevi <varname>pid</varname> ile belirtilen süreç ya da süreç grubuna <varname>sinyalnum</varname> sinyalini gönderir. <xref linkend="glibc-Standard-Signals"/> bölümünde listelenen sinyallere ilaveten, ayrıca <varname>pid</varname> süreç kimliğini doğrulamak için sıfır değerini de kullanabilirsiniz.
    </para><para>
Sinyal alacak süreç veya süreç grubunu belirten <varname>pid</varname> değerleri ve anlamları:
    </para><para><variablelist><varlistentry>
    <term><varname>pid</varname><literal> > 0</literal></term><listitem><para>
Belirteci <varname>pid</varname> olan süreç.
       </para></listitem></varlistentry><varlistentry>
       <term><varname>pid</varname><literal> == 0</literal></term><listitem><para>
Gönderen ile aynı gruptaki süreçlerin tümü.
       </para></listitem></varlistentry><varlistentry>
       <term><varname>pid</varname><literal> &lt; -1</literal></term><listitem><para>
Belirteci <varname>-pid</varname> olan süreç grubu.
       </para></listitem></varlistentry><varlistentry>
       <term><varname>pid</varname><literal> == -1</literal></term><listitem><para>
Eğer süreç ayrıcalıklı ise, sinyal, bazı özel sistem süreçleri dışında kalan tüm süreçlere gönderilir. Aksi takdirde, sinyal, aynı etkin kullanıcı kimlikli tüm süreçlere gönderilir.
       </para></listitem></varlistentry></variablelist></para><para>
Bir süreç <command>kill (getpid(), <varname>sinyal</varname>)</command> gibi bir çağrı ile kendisine bir sinyal gönderebilir ve sinyal engellenmez, sonrasında <command>kill</command> dönmeden önce sürece en az bir sinyal (<varname>sinyalnum</varname> yerine beklemede olan engellenmeyen sinyaller gidebilir) gönderir.
    </para><para>
Sinyal gönderme başarılı olduğunda <command>kill</command> sıfır ile döner. Aksi takdirde sinyal gönderilmemiş demektir ve <command>-1</command> ile döner. Eğer <varname>pid</varname> bir sinyalin birden fazla sürece gönderilmesini belirtiyorsa, en azından bir sürece sinyal gönderilebilmişse <command>kill</command> sıfır ile dönecektir. Sinyali alan ve alamayan süreçlerin hangileri olduğunu saptayacak bir yöntem yoktur.
    </para><para>
Bu işlev için tanımlanmış olan <command>errno</command> değerleri:
    </para><para><variablelist><varlistentry>
    <term><literal>EINVAL</literal></term><listitem><para>
<varname>sinyalnum</varname> geçersiz ya da desteklenmeyen bir numara.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>EPERM</literal></term><listitem><para>
<varname>pid</varname> ile belirtilen sürece ya da süreç grubundaki herhangi bir sürece bir sinyal göndermeye yetkili değilsiniz.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>ESRCH</literal></term><listitem><para>
<varname>pid</varname> mevcut bir süreci veya grubu betimlemiyor.
       </para></listitem></varlistentry></variablelist>
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>killpg</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-killpg">
<funcdef>int <command>killpg</command></funcdef>
<paramdef>(int <varname>pgid</varname>,
 int <varname>sinyalnum</varname>)</paramdef>
</funcprototype><funcdescr><para>
<varname>sinyalnum</varname> sinyalini <varname>pgid</varname> ile belirtilen süreç grubuna göndermesi dışında <command>kill</command> gibidir. Bu işlev BSD uyumluluğu için vardır. Bunun yerine <command>kill</command> kullanmak yazılımınızı daha taşınabilir yapar.
</para></funcdescr></funcsynopsis></para><para>
<command>kill</command> kullanımına basit bir örnek olan<sbr/> <command>kill (getpid (), <varname>sinyal</varname>)</command> çağrısı<sbr/><command>raise (<varname>sinyal</varname>)</command> çağrısı ile aynı etkiye sahiptir.
    </para></sect1>
  <sect1 id="glibc-Permission-for-kill">
    <title><literal>kill</literal> ile İlgili Sınırlamalar</title>
    <titleabbrev><command>kill</command> kullanım yetkileri.</titleabbrev>
    <para>
Herhangi bir sürece <command>kill</command> kullanarak sinyal göndermenizi engelleyen bazı sınırlamalar vardır. Bunlar, başka bir kullanıcının bir süreci kendi kararının bir sonucu olarak öldürmesi gibi asosyal davranışlara karşı tasarlanmıştır. <command>kill</command> genellikle bir sürecin kendi altsüreçlerine ve kardeş süreçler arasında sinyal gönderilmesi için kullanılır ve bu çeşit kullanımda yetkileriniz yeterli olur. Alışılmışın dışında olan tek durum bir alt süreç olarak bir setuid yazılımın çalıştığı durumdur; eğer yazılım sürecin hem gerçek hem de etkin kullanıcı kimliğini değiştiriyorsa, sürece sinyal gönderecek yetkiniz olmayabilir. <command>su</command> komutu bunu yapar.
    </para><para>
Bir sürece sinyal gönderme yetkiniz olup olmadığına iki sürecin kullanıcı kimliklerine bakarak karar verilir. Bu kavram <xref linkend="glibc-Process-Persona"/> bölümünde ayrıntılı olarak açıklanmıştır.
    </para><para>
Genelde, bir sürecin başka bir sürece sinyal gönderebilmesi için ya gönderen süreç ayrıcalıklı kullanıcıya ait olmalı (<command>root</command> gibi) ya da gönderen sürecin gerçek ve etkin kullanıcı kimliği alan sürecinki ile aynı olmalıdır. Eğer alan süreç kendi süreç imge dosyasında set-user-ID bitiyle etkin kullanıcı kimliğini değiştirirse, etkin kullanıcı kimlik yerine süreç imge dosyasının sahibi kullanılır. Bazı gerçeklemelerde, bir süreç kendi alt sürecine kullanıcı kimlikleri aynı olmasa bir sinyal gönderebilir olmalıyken bazıları da başka sınırlamalar getirebilir.
    </para><para>
<command>SIGCONT</command> sinyali özel bir durumdur. Eğer gönderici ve alıcı  aynı oturumun parçaları iseler kullanıcı kimliklerine bakılmaksızın bu sinyali gönderilebilir.
    </para></sect1>
  <sect1 id="glibc-Kill-Example">
    <title><literal>kill</literal> Örneği</title>
    <titleabbrev>İletişimde <command>kill</command> kullanımı.</titleabbrev>
    <para>
<indexterm scope="glibc-cp"><primary>süreçler arası iletişim</primary><secondary>sinyallerle</secondary></indexterm>
Burada süreçler arası iletişim için sinyallerin kullanıldığı daha kapsamlı bir örneğe yer verilmiştir. <command>SIGUSR1</command> ve <command>SIGUSR2</command> sinyalleri ile neler yapılabileceği gösterilmiştir. Bu sinyaller öntanımlı olarak ölümcül olduklarından, sürecin bu sinyalleri <command>signal</command> veya <command>sigaction</command> ile yakalayacakları varsayılır.
    </para><para>
Bu örnekte, bir süreç bir alt süreci çatalladıktan sonra alt sürecin kendini ilklendirmesini beklemekte, alt süreç ise  <command>kill</command> işlevini bir <command>SIGUSR1</command> sinyalini göndermek için kullanarak hazır olduğunu bildirmektedir.
    </para><para>
<screen>#include &lt;signal.h>
#include &lt;stdio.h>
#include &lt;sys/types.h>
#include &lt;unistd.h>

/* SIGUSR1 sinyali alındığında bu değişken 1 olacak. */
volatile sig_atomic_t usr_interrupt = 0;

void
synch_signal (int sig)
{
  usr_interrupt = 1;
}

/* Bu işlevi alt süreç çalıştıracak. */
void
child_function (void)
{
  /* İlklendirme bitmiş demektir. */
  printf ("Hazirim!!!  Surec kimligim: %d.\n", (int) getpid ());

  /* Üst sürece de bildirmek lazım. */
  kill (getppid (), SIGUSR1);

  /* Bilgilendirme bitti, işbaşı!. */
  puts ("Simdilik hoscakalin....");
  exit (0);
}

int
main (void)
{
  struct sigaction usr_action;
  sigset_t block_mask;
  pid_t child_id;

  /* Sinyal eylemciyi kurgulayalım. */
  sigfillset (&amp;block_mask);
  usr_action.sa_handler = synch_signal;
  usr_action.sa_mask = block_mask;
  usr_action.sa_flags = 0;
  sigaction (SIGUSR1, &amp;usr_action, NULL);

  /* Alt süreci oluşturalım. */
  child_id = fork ();
  if (child_id == 0)
    child_function ();          /* Birşey dönmeyecek. */

  /* Alt sürecin bir sinyal göndermesini bekleyelim */
  while (!usr_interrupt)
    ;

  /* Alt süreç hazır, işbaşı!. */
  puts ("Bu kadar!");

  return 0;
}
</screen></para><para>
Bu örnekte beklerken işlemci meşgul ediliyor, bu iyi değil, işlemciyi kullanabilecek başka süreçler engelleniyor. Sinyalin gelip gelmediğini sisteme sormak daha iyidir. Böyle bir örneği <xref linkend="glibc-Waiting-for-a-Signal"/> bölümünde bulabilirsiniz.
    </para></sect1></chapter>
  <chapter id="glibc-Blocking-Signals">
    <title>Sinyallerin Engellenmesi</title>
    <titleabbrev>Sistemin sinyalleri geçici olarak engellemesinin sağlanması.</titleabbrev>
    <para>
<indexterm scope="glibc-cp"><primary>sinyaller</primary><secondary>engellenmesi</secondary></indexterm>
Sinyal engelleme işlemi daha sonra alınmak üzere işletim sisteminin onu tutmasını sağlamaktır. Genelde, bir yazılım sinyalleri sonsuza kadar engelleyemez ama onların eylemlerini <command>SIG_IGN</command> ile yoksayabilir. Ancak, önemli işlemleri yapabilecek kadar kısa bir süre için sinyalleri engellemek daha iyidir. Örneğin,
   </para><para><itemizedlist><listitem><para>
Bu sinyallerin eylemcileri tarafından değiştirilen genel değişkenleri ayarlayana kadar sinyalleri engellemek için <command>sigprocmask</command> işlevini kullanabilirsiniz.
     </para></listitem><listitem><para>
Belli bir sinyal eylemci çalışırken sinyallerin engellenmesi için <command>sigaction</command> veri yapısının <command>sa_mask</command> üyesini kullanabilirsiniz. Böylece sinyal eylemcinin başka sinyallerle kesintiye uğratılması engellenmiş olur.
     </para></listitem></itemizedlist></para>
  <sect1 id="glibc-Why-Block">
    <title>Sinyalleri Engellemenin Amaçları</title>
    <titleabbrev>Sinyallerin engellenmesinin faydaları.</titleabbrev>
    <para>
Sinyalleri <command>sigprocmask</command> ile engelleyerek yazılımınızın kritik kısımlarının kesmelerden korunmasını sağlayabilirsiniz. Yazılımınızın bu kısımları etkinken bir sinyal gelirse bir sinyalin engellenmesini kaldırınca o sinyal tekrar alınabilir.
    </para><para>
Buna kullanışlı bir örnek, sinyal eylemci ile yazılımın diğer kısımları arasında veri paylaşımıdır. Veri türü <command>sig_atomic_t</command> (bkz. <xref linkend="glibc-Atomic-Data-Access"/>) değilse yazılımınız bu veriyi okur ya da yazarken işlemin ortasında sinyal eylemci çalışmaya başlarsa işlem yarıda kalacağından sorunlara yol açabilir.
    </para><para>
Yazılımın düzgün çalışabilmesi için verinin işlenmesi sırasında sinyallerin alınmasını engelleyerek sinyal eylemcinin çalışmamasını sağlayabilirsiniz.
    </para><para>
Ayrıca, belli bir eylemi sadece bir sinyal gelmediğinde gerçekleştirmeniz gerekiyorsa sinyallerin engellenmesi gereklidir. Bir sinyal eylemcisinin <command>sig_atomic_t</command> türünde bir değişkene değer atadığını, sizin de eyleminizi gerçekleştirmeden önce bu değişkenin değerine baktığınızı varsayalım. Bu yöntem güvenilir değildir. Eyleminizi gerçekleştirmeden, bu değişkenin değerine baktıktan hemen sonra da bir sinyal gelebilir.
    </para><para>
Bir sinyalin alınıp alınmadığına bakmanın en güvenilir yolu sinyali engelleyerek değişkenin değerine bakmaktır.
    </para></sect1>
  <sect1 id="glibc-Signal-Sets">
    <title>Sinyal Kümeleri</title>
    <titleabbrev>Hangi sinyallerin engelleneceği nasıl belirtilir.</titleabbrev>
    <para>
Sinyal engeleme işlevlerinin tümü <wordasword>sinyal kümesi</wordasword> adı verilen bir veri yapısını kullanırlar. Bu işlem iki kademede yapılır: sinyal kümesi oluşturulur ve bir argüman olarak bir kütüphane işlevine aktarılır.
<indexterm scope="glibc-cp"><primary>sinyal kümesi</primary></indexterm>
    </para><para>
Bu oluşumlar <filename>signal.h</filename> başlık dosyasında bildirilmiştir.
<indexterm scope="glibc-pg"><primary>signal.h</primary></indexterm>
    </para><para>
<indexterm scope="glibc-tp"><primary>sigset_t</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü" id="glibc-sigset_t">
<funcdef><command>sigset_t</command></funcdef>
<paramdef>(int <varname>pgid</varname>,
 int <varname>sinyalnum</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>sigset_t</command> veri türü bir sinyal kümesi oluşturmak için kullanılır. Kütüphane içinde bir tamsayı tür ya da bir yapı olarak gerçekleştirilmiş olabilir.
    </para><para>
Taşınabilirlik açısından, <command>sigset_t</command> yapısı içindeki veriyi okuma ve değiştirme işlemlerini doğrudan değil, bu bölümde açıklanan işlevleri kullanarak yapmalısınız.
       </para><para>
Bir sinyal kümesini oluşturmanın iki yolu vardır. <command>sigemptyset</command> ile boş olduğunu belirtip sinyalleri tek tek eklersiniz. Ya da, <command>sigfillset</command> ile tüm sinyalleri içerdiğini belirtip sinyalleri tek tek silersiniz.
    </para><para>
Herhangi bir işlem yapmadan önce sinyal kümesini bu iki işlevden birini kullanarak ilklendirmelisiniz. Sinyal kümesinde sinyalleri bu işlevleri kullanmadan eklemeye ya da silmeye çalışmayın, çünkü <command>sigset_t</command> nesnesinde ilklendirilmesi gereken başka alanlar da (sürüm alanı gibi) olabilir. (Ek olarak, sistemin sizin bildiklerinizden başka sinyalleri içermediği kabulünü yapmanız pek akıllıca olmayacaktır.)
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>sigemptyset</primary></indexterm>
<indexterm scope="glibc-fn"><primary>sigfillset</primary></indexterm>
<indexterm scope="glibc-fn"><primary>sigaddset</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-sigemptyset">
<funcdef>int <command>sigemptyset</command></funcdef>
<paramdef>(sigset_t *<varname>küme</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev <varname>küme</varname> sinyal kümesini tanımlı hiçbir sinyali içermediği biçimde ilklendirir. Daima <command>0</command> ile döner.
</para></funcdescr></funcsynopsis></para><para>
<funcsynopsis><funcprototype role="işlev" id="glibc-sigfillset">
<funcdef>int <command>sigfillset</command></funcdef>
<paramdef>(sigset_t *<varname>küme</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev <varname>küme</varname> sinyal kümesini tanımlı tüm sinyalleri içerdiği biçimde ilklendirir. Daima <command>0</command> ile döner.
</para></funcdescr></funcsynopsis></para><para>
<funcsynopsis><funcprototype role="işlev" id="glibc-sigaddset">
<funcdef>int <command>sigaddset</command></funcdef>
<paramdef>(sigset_t *<varname>küme</varname>,
 int       <varname>sinyalnum</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev <varname>sinyalnum</varname> sinyalini <varname>küme</varname> sinyal kümesine ekler. <command>sigaddset</command>'ler sadece <varname>küme</varname>'yi değiştirir, sinyal engelleme/engellememe yapmaz.
    </para><para>
Başarılı olursa <command>0</command>, aksi takdirde <command>-1</command> ile döner. Aşağıdaki <command>errno</command> değeri bu işlev için tanımlanmıştır:
    </para><para><variablelist><varlistentry>
    <term><literal>EINVAL</literal></term><listitem><para>
<varname>sinyalnum</varname> argümanı geçerli bir sinyal belirtmiyor.
       </para></listitem></varlistentry></variablelist>
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>sigdelset</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-sigdelset">
<funcdef>int <command>sigdelset</command></funcdef>
<paramdef>(sigset_t *<varname>küme</varname>,
 int       <varname>sinyalnum</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev <varname>sinyalnum</varname> sinyalini <varname>küme</varname> sinyal kümesinden çıkarır. <command>sigdelset</command>'ler sadece <varname>küme</varname>'yi değiştirir, sinyal engelleme/engellememe yapmaz. Dönüş değeri ve hata durumları <command>sigaddset</command> işlevindeki gibidir.
       </para><para>
Son olarak, bir sinyalin sinyal kümesinde olup olmadığına bakmak için kullanılan bir işlev vardır:
</para></funcdescr></funcsynopsis>
</para><para>
<indexterm scope="glibc-fn"><primary>sigismember</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-sigismember">
<funcdef>int <command>sigismember</command></funcdef>
<paramdef>(sigset_t *<varname>küme</varname>,
 int       <varname>sinyalnum</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>sigismember</command> işlevi <varname>sinyalnum</varname> sinyalinin <varname>küme</varname> sinyal kümesinin bir üyesi olup olmadığına bakmak için kullanılır. Sinyal, kümenin bir elemanı ise <command>1</command> ile, değilse <command>0</command> ile, bir hata oluşmuşsa <command>-1</command> ile döner.
    </para><para>
Aşağıdaki <command>errno</command> değeri bu işlev için tanımlanmıştır:
    </para><para><variablelist><varlistentry>
    <term><literal>EINVAL</literal></term><listitem><para>
<varname>sinyalnum</varname> argümanı geçerli bir sinyal belirtmiyor.       </para></listitem></varlistentry></variablelist>
  </para></funcdescr></funcsynopsis></para></sect1>
  <sect1 id="glibc-Process-Signal-Mask">
    <title>Sürecin Sinyal Maskesi</title>
    <titleabbrev>Normal çalışma sırasında sürece gelen sinyallerin engellenmesi.</titleabbrev>
    <para>
<indexterm scope="glibc-cp"><primary>sinyal maskesi</primary></indexterm>
<indexterm scope="glibc-cp"><primary>süreç sinyal maskesi</primary></indexterm>
Engellenen sinyallerden oluşan küme <wordasword>sinyal maskesi</wordasword> olarak da adlandırılır. Her sürecin kendine özgü bir sinyal maskesi vardır. Yeni bir <link linkend="glibc-Creating-a-Process">süreç oluşturduğunuzda</link>, süreç sinyal maskesini onu çalıştıran süreçten miras alır. Bu sinyal maskesini değiştirerek istediğiniz sinyalleri engelleyebilir ya da da engellemeyebilirsiniz.
    </para><para>
<command>sigprocmask</command> işlevinin prototipi <command>signal.h</command> dosyasındadır.
<indexterm scope="glibc-pg"><primary>signal.h</primary></indexterm>
    </para><para>
Her evre kendi sinyal maskesine sahip olduğundan ve dolayısıyla tek bir sinyal maskesi olmadığından çok evreli süreçlerde <command>sigprocmask</command> işlevini kullanmamalısınız. POSIX'e göre, çok evreli bir süreçte <command>sigprocmask</command> davranışı "belirsizdir". Yerine <command>pthread_sigmask</command> kullanılmalıdır.
    </para><para>
<indexterm scope="glibc-fn"><primary>sigprocmask</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-sigprocmask">
<funcdef>int <command>sigprocmask</command></funcdef>
<paramdef>(int                      <varname>nasıl</varname>,
 const sigset_t *restrict <varname>küme</varname>,
 sigset_t *restrict       <varname>eski_küme</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>sigprocmask</command> işlevi çağrıldığı sürecin sinyal maskesini değiştirmek ya da okumak için kullanılır. <varname>nasıl</varname> argümanı ile sinyal maskesinin nasıl değiştirileceği aşağıdaki değerlerden biri ile belirtilmelidir:
    </para><para><variablelist><varlistentry>
    <term><literal>SIG_BLOCK</literal></term><listitem><para>
<indexterm scope="glibc-vr"><primary>SIG_BLOCK</primary></indexterm>
<varname>küme</varname> içindeki sinyaller engellensin--mevcut maskeye eklensin. Başka bir deyişle, yeni maske, mevcut maske ile <varname>küme</varname>'nin birleşimi olur.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>SIG_UNBLOCK</literal></term><listitem><para>
<indexterm scope="glibc-vr"><primary>SIG_UNBLOCK</primary></indexterm>
<varname>küme</varname> içindeki sinyaller engellenmesin--mevcut maskeden kaldırılsın.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>SIG_SETMASK</literal></term><listitem><para>
<indexterm scope="glibc-vr"><primary>SIG_SETMASK</primary></indexterm>
Sinyal maskesi için <varname>küme</varname> kullanılsın; önceki maske yoksayılsın.
       </para></listitem></varlistentry></variablelist>
     </para><para>
Son argüman olan <varname>eski_küme</varname> sürecin eski maskesi hakkında bilgi döndürmek için kullanılır. Eski maskeye bakmaksızın maskeyi değiştirmek isterseniz <varname>eski_küme</varname> argümanı ile boş gösterici aktarmalısınız. Benzer şekilde, makeyi değiştirmeksizin mevcut maske hakkında bilgi almak için <varname>küme</varname> argümanı ile boş gösterici aktarmalısınız (bu durumda <varname>nasıl</varname> argümanının önemi yoktur).  <varname>eski_küme</varname> argümanı çoğunlukla, sinyal maskesini daha sonra eski durumuna getirmek için mevcut durum bilgisini almak gerektiğinde kullanılır. (Sinyal maskesi <command>fork</command> ve <command>exec</command> çağrıları üzerinden miras alındığından, yazılımınız çalışmaya başlamadan içeriği hakkında bilgi edinmeniz mümkün değildir.)
    </para><para>
<command>sigprocmask</command> çağrısı bekleyen sinyallerin alınmasına sebep olacağından <command>sigprocmask</command> dönmeden önce bu sinyallerden en az biri alınmış olacaktır. Bekleyen sinyallerin hangisinin önce alınacağı belli olmaz, ancak her sinyal için ayrı ayrı <command>sigprocmask</command> çağrısı yaparak hangi sinyalin önce alınacağını kendiniz belirleyebilirsiniz.
    </para><para>
<command>sigprocmask</command> işlevi başarılı olduğunda <command>0</command> ile döner. <command>-1</command> ile dönmüşse bir hata var demektir. Aşağıdaki <command>errno</command> değeri bu işlev için tanımlanmıştır:
    </para><para><variablelist><varlistentry>
    <term><literal>EINVAL</literal></term><listitem><para>
<varname>nasıl</varname> argümanı geçersiz.
       </para></listitem></varlistentry></variablelist>
     </para><para>
<command>SIGKILL</command> ve <command>SIGSTOP</command> sinyallerini engelleyemezsiniz, ama bir sinyal kümesi bunları içerebilir. Bu durumda <command>sigprocmask</command> hata döndürmez basitçe onları yoksayar.
    </para><para>
Bir yazılım hatası (<command>raise</command> veya <command>kill</command> ile gönderilen sinyallerin aksine) sonucu olarak üretilen <command>SIGFPE</command> gibi yazılım hata sinyallerinin engellenmesinin tahmin edilmesi mümkün olmayan sonuçlara yol açacağı unutulmamalıdır. Böyle bir durumda yazılım bozulmuş olacağından sinyallerin engellenmesi kaldırıldığında yazılım isteneni yapmayabilecektir. Bkz. <xref linkend="glibc-Program-Error-Signals"/>.
  </para></funcdescr></funcsynopsis></para></sect1>
  <sect1 id="glibc-Testing-for-Delivery">
    <title>Sinyal Alımının Sınanması</title>
    <titleabbrev>Sinyal alım sınamasının engellenmesi</titleabbrev>
    <para>
Basit bir örnekle açıklayalım. <command>SIGALRM</command> sinyali için bir eylemci oluşturduğunuzu, bununla bir değişkene değer atadığınızı ve zaman zaman azılım içinde bu değişkene baktığınızı ve onu sıfırladığınızı varsayalım. Kodun kritik parçaları icra edilirken <command>SIGALRM</command> sinyallerinin alınmasından <command>sigprocmask</command> çağrıları ile aşağıdaki gibi kaçınabilirsiniz:
    </para><para>
<screen>/* Bu değişkene SIGALRM sinyal eylemcisi değer atayacak. */
volatile sig_atomic_t flag = 0;

int
main (void)
{
  sigset_t block_alarm;

  ...

  /* Sinyal maskesini ilklendirelim. */
  sigemptyset (&amp;block_alarm);
  sigaddset (&amp;block_alarm, SIGALRM);

  while (1)
    {
      /* Bir sinyal gelmiş mi bakalım. Gelmişse değişkeni sıfırlayalım. */
      sigprocmask (SIG_BLOCK, &amp;block_alarm, NULL);
      if (flag)
        {
          <varname>sinyal alınmamışsa yapılacak işlemler</varname>
          flag = 0;
        }
      sigprocmask (SIG_UNBLOCK, &amp;block_alarm, NULL);

      ...
    }
}
</screen></para></sect1>
  <sect1 id="glibc-Blocking-for-Handler">
    <title>Eylemci Çalışırken Sinyallerin Engellenmesi</title>
    <titleabbrev>Bir sinyal eylemci çalışırken gelen diğer sinyallerin engellenmesi.</titleabbrev>
    <para>
<indexterm scope="glibc-cp"><primary>sinyaller</primary><secondary>engellenmesi</secondary><tertiary>bir eylemci içinde</tertiary></indexterm>
Bir sinyal eylemci çalışmaya başladığında çalışmasının başka bir sinyal ile kesilmesini istemezsiniz. Eylemci çalışmaya başlayıp, işini bitirene kadar çalışmasının ya da verisinin bozulmaması için sinyalleri engellemelisiniz.
    </para><para>
Bir eylemci işlev bir sinyal ile çalıştırıldığında bu sinyal (ve sürecin sinyal maskesindeki diğer sinyaller) özdevinimli olarak engellenir. Örneğin, <command>SIGTSTP</command> sinyali için bir eylemciniz varsa, bu eylemci çalışmaya başlayınca daha sonra gelen <command>SIGTSTP</command> sinyalleri eylemcinin çalışması süresince bekletilecektir.
    </para><para>
Bununla birlikte, öntanımlı olarak, diğer çeşit sinyaller engellenmez ve eylemcinin çalışması sırasında gelebilirler.
    </para><para>
Eylemcinin çalışması sırasında gelen farklı sinyalleri engellemenin en güvenilir yolu <command>sigaction</command> yapısının <command>sa_mask</command> üyesini kullanmaktır.
    </para><para>Bir örnek:</para><para>
<screen>#include &lt;signal.h>
#include &lt;stddef.h>

void catch_stop ();

void
install_handler (void)
{
  struct sigaction setup_action;
  sigset_t block_mask;

  sigemptyset (&amp;block_mask);
  /* Eyelmci çalışırken uçbirimden kaynaklanan sinyaller engellensin */
  sigaddset (&amp;block_mask, SIGINT);
  sigaddset (&amp;block_mask, SIGQUIT);
  setup_action.sa_handler = catch_stop;
  setup_action.sa_mask = block_mask;
  setup_action.sa_flags = 0;
  sigaction (SIGTSTP, &amp;setup_action, NULL);
}
</screen></para><para>
Bu, diğer sinyallerin eylemciyi kesintiye uğratmasının engelleminin daha güvenilir bir yoludur. Ancak, sinyalleri eylemci içinden doğrudan engellerseniz, eylemcinin başlangıcında kısa bir süre için bu engelleme etkin olmayacaktır.
    </para><para>
Bu mekanizma ile sürecin sinyal maskesinden sinyalleri kaldıramazsınız. Bununla birlikte, eylemci içinden yapacağınız <command>sigprocmask</command> çağrıları ile bazı sinyalleri engelemeyi ya da engellememeyi tercih edebilirsiniz.
    </para><para>
Her durumda, eylemci işini bitirdiğinde sistem, eylemcinin çalışmaya başladığı andaki duruma geri dönecek ve bekletilen sinyaller varsa bu sinyaller  gönderilecektir.
    </para></sect1>
  <sect1 id="glibc-Checking-for-Pending-Signals">
    <title>Bekleyen Sinyallerin Sınanması</title>
    <titleabbrev>Bekleyen sinyallerin sınanması</titleabbrev>
    <para>
<indexterm scope="glibc-cp"><primary>sinyaller</primary><secondary>bekleyen</secondary><tertiary>sınanması</tertiary></indexterm>
<indexterm scope="glibc-cp"><primary>sinyaller</primary><secondary>engellenen</secondary><tertiary>sınanması</tertiary></indexterm>
<indexterm scope="glibc-cp"><primary>bekleyen sinyallerin sınanması</primary></indexterm>
Bekleyen sinyallerin hangileri olduğunu herhangi bir anda yapacağınız <command>sigpending</command> çağrıları ile öğrenebilirsiniz. Bu işlev <filename>signal.h</filename> dosyasında bildirilmiştir.
<indexterm scope="glibc-pg"><primary>signal.h</primary></indexterm>
    </para><para>
<indexterm scope="glibc-fn"><primary>sigpending</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-sigpending">
<funcdef>int <command>sigpending</command></funcdef>
<paramdef>(sigset_t *<varname>küme</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>sigpending</command> işlevi bekleyen sinyallere ilişkin bilgileri  <varname>küme</varname> içinde saklar.  Alınması engellenmiş bir sinyal varsa, bu sinyal dönen kümenin bir üyesidir. (Bir sinyalin bu kümenin üyesi olup olmadığını <xref linkend="glibc-Signal-Sets"/> bölümünde açıklanan  <command>sigismember</command> işlevini kullanarak öğrenebilirsiniz.)
    </para><para>
Dönen değer bir hata oluşmamışsa <command>0</command>, aksi takdirde <command>-1</command>'dir.
</para></funcdescr></funcsynopsis></para><para>
Bekleyen bir sinyalin olup olmadığına bakmak her zaman kullanışlı olmaz. Engellenmemiş bir sinyalin varlığına bakmak ise daima kötü bir tasarım olur.
    </para><para>Bir örnek:</para><para>
<screen>#include &lt;signal.h>
#include &lt;stddef.h>

sigset_t base_mask, waiting_mask;

sigemptyset (&amp;base_mask);
sigaddset (&amp;base_mask, SIGINT);
sigaddset (&amp;base_mask, SIGTSTP);

/* Diğer işlemler yapılırken kullanıcı kesmeleri engellensin. */
sigprocmask (SIG_SETMASK, &amp;base_mask, NULL);
...

/* Bir süre sonra, bekleyen bir sinyal var mı bakalım. */
sigpending (&amp;waiting_mask);
if (sigismember (&amp;waiting_mask, SIGINT)) {
  /* Kullanıcı süreci sonlandırmayı denedi. */
}
else if (sigismember (&amp;waiting_mask, SIGTSTP)) {
  /* Kullanıcı süreci durdurmayı denedi. */
}
</screen></para><para>
Süreciniz için bekleyen belli bir sinyal varsa, sonradan gelen aynı türdeki sinyallerin iptal edilebileceğini unutmayın. Örneğin, bir <command>SIGINT</command> sinyali askıya alınmışsa başka bir <command>SIGINT</command> sinyali geldiğinde yazılımınız bu sinyali engellenmesi durdurulduktan sonra alacaktır.
    </para><para>
<note><title>Taşınabilirlik Bilgisi</title><para> <command>sigpending</command> işlevi POSIX.1 ile gelmiştir.  Daha eski sistemler eşdeğeri bir oluşuma sahip değildir.</para></note>
    </para></sect1>
  <sect1 id="glibc-Remembering-a-Signal">
    <title>Bir Sinyalin Eyleminin Sonradan Hatırlanması</title>
    <titleabbrev>Bir sinyalinin engellenmesinin oluşturduğu etkinin onu yakalayıp daha sonra sınanacak bir değişken sayesinde tekrar elde edilmesi.</titleabbrev>
    <para>
Bir sinyalin engellenmesini, kütüphane oluşumlarını kullanmak yerine daha sonra sinyalin engellenmediği bir sırada sınanacak bir değişkene sinyal eylemci içinde bir değer atamak suretiyle yapabilirsiniz. Bir örnek:
    </para><para>
<screen>/* Bu değişkenin değeri sıfırdan farklıysa, o sinyal bekletiliyordur. */
volatile sig_atomic_t signal_pending;

/* Bir sinyal geldiğinde işleme sokulmayacaksa bu değişkenin değeri
   sıfırdan farklı olacaktır. */
volatile sig_atomic_t defer_signal;

void
handler (int signum)
{
  if (defer_signal)
    signal_pending = signum;
  else
    ... /* "Gerçekten" sinyal yakalanmış. */
}

...

void
update_mumble (int frob)
{
  /* Sinyallerin hemen etki etmesini engelleyelim. */
  defer_signal++;
  /* Şimdi kesmelerden korkmadan mumble'ı güncelleyelim. */
  mumble.a = 1;
  mumble.b = hack ();
  mumble.c = frob;
  /* mumble güncellendi.  Gelen herhangi bir sinyali işleme sokabiliriz. */
  defer_signal--;
  if (defer_signal == 0 &amp;&amp; signal_pending != 0)
    raise (signal_pending);
}
</screen></para><para>
Belli bir sinyalin geldiğinde <command>signal_pending</command> içinde nasıl saklandığına dikkat edin. Bu yolla, aynı mekanizmayı kullanarak farklı türdeki sinyalleri yakalayabiliriz.
    </para><para>
Kodun önemli yerlerinde <command>defer_signal</command> değişkeninin değerini önce arttırıp sonra azaltıyoruz; böylece <command>signal_pending</command> sıfırdan farklıyken <command>update_mumble</command> çağrıldığında sadece <command>update_mumble</command> içinde değil ayrıca çağrıcı içinde de ertelenecektir. Bu nedenle, <command>defer_signal</command> sıfırdan farklı olduğunda <command>signal_pending</command>'e bakmıyoruz.
    </para><para>
<command>defer_signal</command>'in arttırılması ve eksiltilmesi bir makine komutundan fazlasını gerektirir; bu nedenle işlemin tamamlanmamışken sinyal alınması ihtimal dahilindedir. Fakat bu herhangi bir soruna yolaçmaz. Arttırma ya da eksiltmenin başlamasından hemen önce bir sinyal gelirse bile çalışma bozulmayacaktır.
    </para><para>
<command>defer_signal</command>'in <command>signal_pending</command> sınanmadan önce arttırılması ölümcül öneme sahiptir. Bu çözümü zor bir yazılım hatasından kaçınmayı sağlar. Eğer bu işlemleri aşağıdaki gibi farklı bir sırada yapmış olsaydık,
    </para><para>
<screen>
  if (defer_signal == 1 &amp;&amp; signal_pending != 0)
    raise (signal_pending);
  defer_signal--;
</screen></para><para>
<command>if</command>  deyimi ile arttırım arasında gelen bir sinyal sonsuza kadar kaybolurdu. <command>defer_signal</command>'e sadece sinyal eylemci değer atasa ve yazılım bu değişkene baksa eylemci bu değişkene bakmazdı.
    </para><para>
<indexterm scope="glibc-cp"><primary>sinyallerin yakalanmasında zamanlama hataları</primary></indexterm>
Bu çeşit yazılım hatalarına <wordasword>zamanlama hataları</wordasword> adı verilir. Yaygın olarak oluştukları halde yeniden üretilmeleri imkansız olduklarından özellikle kötü hatalardır. Bu hatayı üretemeyeceğinizden bir hata ayıklayıcı ile bu hataları bulamazsınız. Bu nedenle onlardan kaçınmak için özellikle büyük dikkat sarfetmelisiniz.
    </para><para>
(<command>defer_signal</command> değişkenini sayaç olarak kullanıyorsanız
kodu bu şekilde yazmak size daha kolay gelebilir. Normalde bu değişkenin
<command>signal_pending</command> değişkeni ile birlikte sınanması
gerekir. Her durumda bu sayacı sıfır değeri için sınamak, bir değeri için
sınamaktan daha basittir. Eğer <command>defer_signal</command> değişkeni
sayaç olarak kullanılmıyor ve sadece sıfır veya bir değerini alabiliyorsa,
sınama sırası sınama işleminin karmaşıklığını pek etkilemez. Bu da
<command>defer_signal</command> değişkenini sayaç olarak kullanmanın bir
diğer getirisidir: Kodu yanlış sırada yazmak suretiyle bulunması zor olacak
bir hata yapma şansınız azalır.)
    </para></sect1></chapter>
  <chapter id="glibc-Waiting-for-a-Signal">
    <title>Sinyalin Beklenmesi</title>
    <titleabbrev>Bir sinyal gelene kadar sürecin bekletilmesi.</titleabbrev>
    <para>
<indexterm scope="glibc-cp"><primary>sinyal bekleme</primary></indexterm>
<indexterm scope="glibc-cp"><primary><command>pause</command> işlevi</primary></indexterm>
Yazılımınız harici olaylarla tetikleniyorsa ya da eşzamanlama için sinyalleri kullanıyorsa ve yapacak başka işi yoksa bir sinyal gelene kadar beklemesi gerekir.
   </para>
  <sect1 id="glibc-Using-Pause">
    <title><literal>pause</literal> Kullanımı</title>
    <titleabbrev>Basit yol, <command>pause</command> kullanmak.</titleabbrev>
    <para>
Sinyal gelene kadar beklemenin en basit yolu <command>pause</command> çağrısı yapmaktır. Kullanmadan önce lütfen aşağıda açıklanan olumsuzluklarını okuyun.
    </para><para>
<indexterm scope="glibc-fn"><primary>pause</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-pause">
<funcdef>int <command>pause</command></funcdef>
<paramdef>()</paramdef>
</funcprototype><funcdescr><para>
<command>pause</command> işlevi, bir sinyal eylemciyi çalıştırmak ya da süreci sonlandırmak gibi bir eylemi yerine getirmek üzere bir sinyalin gelmesini beklemek için kullanılır.
    </para><para>
Sinyal, bir eylemci işlevi tetikliyorsa <command>pause</command> döner. Bu başarısız bir dönüş olarak ele alınır (başarılı davranış, süreci sonsuza dek bekletmektir) ve işlev <command>-1</command> değeri ile döner. Hatta bir sinyal eylemci döndüğünde diğer ilkellerin çalışmalarına kaldıkları yerden devam edeceklerini belirtseniz bile (<xref linkend="glibc-Interrupted-Primitives"/>), bunun <command>pause</command> üzerinde bir etkisi yoktur; bir sinyal geldiğinde daima başarısız olarak dönecektir.
    </para><para>
Aşağıdaki <command>errno</command> değeri bu işlev içindir:
    </para><para><variablelist><varlistentry>
    <term><literal>EINTR</literal></term><listitem><para>
İşlev bir sinyal alarak kesintiye uğradı.
       </para></listitem></varlistentry></variablelist>
     </para><para>
Sinyal sürecin sonlanmasına sebep oluyorsa <command>pause</command> dönmeyecektir (ister istemez).
    </para><para>
Bu işlev çok evreli yazılımlar için bir iptal noktasıdır. Eğer evre <command>pause</command> çağrısı sırasında bazı özkaynakları (bellek, dosya tanımlayıcılar, semaforlar, v.s.) ayırıyorsa sorun çıkar. Evre iptal aldığı andan itibaren süreç sonlanana kadar bu özkaynaklar ayrılmış olarak kalacaktır. Bu tür <command>pause</command> çağrılarından kaçınmak için iptal eylemcileri kullanarak korunulmalıdır.
    </para><para>
<command>pause</command> işlevi <filename>unistd.h</filename> dosyasında bildirilmiştir.
  </para></funcdescr></funcsynopsis></para></sect1>
  <sect1 id="glibc-Pause-Problems">
    <title><literal>pause</literal> Sorunları</title>
    <titleabbrev>Basit yöntemler her zaman iyi değildir.</titleabbrev>
    <para>
<command>pause</command> basitleştirmesi, yazılımın sihirli bir şekilde çökmesine sebep olan bir sürü zamanlama hatasını gizleyebilir.
    </para><para>
Eğer herşeyi yazılımınız yapıyorsa, yani kendi sinyal eylemcilerini kullanıyor ve yazılım <command>pause</command> çağırmaktan başka birşey yapmıyorsa <command>pause</command> kullanmak güvenilirdir. Her sinyal alınışında sinyal eylemci bir sonraki işi yapar ve döner, böylece yazılımın ana döngüsü tekrar bir <command>pause</command> çağrısı yapabilir.
    </para><para>
Birden fazla sinyalin işlenmesi için <command>pause</command> kullanarak beklemek ve sonra çalışmayı sürdürmek mümkün olmayabilir. Sinyal eylemci çalışmaya başladığında bir değişken ile bunu belirliyorsanız <command>pause</command> kullanmak artık güvenilir olmaz; örnek:
    </para><para>
<screen>/* <command>usr_interrupt</command>'a sinyal eylemci değer atıyor.  */
if (!usr_interrupt)
  pause ();

/* Sinyal geldikten sonra yapılacaklar.  */
…
</screen></para><para>
Bu bir yazılım hatasıdır: sinyal, <varname>usr_interrupt</varname>'a bakıldıktan sonra ve <command>pause</command> çağrılmadan önce gelmelidir. Eğer böyle bir sinyal gelmezse, süreç bu kod parçasını bir kez daha asla çalıştırmayacaktır.
    </para><para>
<command>pause</command> kullanmak yerine döngü içinde beklemeyi <command>sleep</command> kullanarak sınırlayabilirsiniz. <command>sleep</command> hakkında daha ayrıntılı bilgiyi <xref linkend="glibc-Sleeping"/> bölümünde bulabilirsiniz. Bu durumda kod şöyle olurdu:
    </para><para>
<screen>
/* <command>usr_interrupt</command>'a sinyal eylemci değer atıyor.  */
while (!usr_interrupt)
  sleep (1);

/* Sinyal geldikten sonra yapılacaklar.  */
…
</screen></para><para>
Bazı amaçlar için bu yeterli olur. Ama biraz daha karmaşık olmakla beraber belli bir sinyal eylemcisinin çalıştırılmasını <command>sigsuspend</command> kullanarak sağlayabilirsiniz.
    </para></sect1>
  <sect1 id="glibc-Sigsuspend">
    <title><literal>sigsuspend</literal> Kullanımı</title>
    <titleabbrev>Belli bir sinyalin gelmesinin beklenmesi.</titleabbrev>
    <para>
Bir sinyali beklemenin en temiz ve güvenilir yolu sinyali engelleyip <command>sigsuspend</command> kullanmaktır. Bir döngü içinde <command>sigsuspend</command> kullanarak, her sinyal için farklı bir sinyal eylemci oluşturarak sinyalleri bekleyebilirsiniz.
    </para><para>
<indexterm scope="glibc-fn"><primary>sigsuspend</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-sigsuspend">
<funcdef>int <command>sigsuspend</command></funcdef>
<paramdef>(const sigset_t *<varname>küme</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev sürecin sinyal maskesini <varname>küme</varname> ile değiştirerek bir sinyal eylemciyi çalıştıracak ya da süreci sonlandıracak bir sinyal alıncaya kadar süreci bekletir. Başka bir deyişle, süreç, <varname>küme</varname>'nin üyesi olmayan sinyallerden biri gelene dek süreci bekletir.
    </para><para>
Eğer süreç bir sinyal eylemciyi çalıştıracak bir sinyalin alınması ve eylemci işlevin dönmesiyle işlemi sürdürüyorsa <command>sigsuspend</command> ayrıca dönecektir.
    </para><para>
<varname>küme</varname> ile belirtilen maske <command>sigsuspend</command> etkin olduğu sürece geçerli olur. İşlev döndüğünde eski maske tekrar etkin olur.
    </para><para>
Dönüş değeri ve hata durumu  <command>pause</command> ile aynıdır.
</para></funcdescr></funcsynopsis></para><para>
Önceki bölümdeki <command>pause</command> ve <command>sleep</command> ile ilgili örnekleri <command>sigsuspend</command> tamamen güvenilir duruma getirebilirsiniz:
    </para><para>
<screen>sigset_t mask, oldmask;

...

/* Geçici olarak engellenecek sinyallerin maskesini oluşturalım. */
sigemptyset (&amp;mask);
sigaddset (&amp;mask, SIGUSR1);

...

/* Sinyal gelmesini bekleyelim. */
sigprocmask (SIG_BLOCK, &amp;mask, &amp;oldmask);
while (!usr_interrupt)
  sigsuspend (&amp;oldmask);
sigprocmask (SIG_UNBLOCK, &amp;mask, NULL);

</screen></para><para>
Kodun son parçası biraz dikkat gerektiriyor. Burada hatırlanması gereken nokta, <command>sigsuspend</command> döndüğünde sinyal maskesini çağrılmadan önceki değere ayarlamasıdır. Bu durumda <command>SIGUSR1</command> sinyali bir kere daha engellenir. İkinci <command>sigprocmask</command> çağrısı bu sinyalin engellenmesini kaldırmak için gereklidir.
    </para><para>
Bir diğer nokta: <command>while</command> döngüsünün neden gerekli olduğunu düşünebilirsiniz. Öyle ya, yazılım sadece tek bir <command>SIGUSR1</command> sinyali bekliyor. Yanıt: <command>sigsuspend</command>'e aktarılan maskeye bakarsanız yazılımın ayrıca başka sinyalleri de beklediğini görürsünüz--örneğin, iş denetim sinyalleri. Eğer <command>usr_interrupt</command> değişkenine dokunmayan sinyal eylemciler de varsa, değişkeni değiştiren bir sinyal eylemci çalıştırılana kadar döngü sürecektir.
    </para><para>
Bu teknik bir kaç satır daha gerektirir ama bu kullanım amacınıza uygun kriterlere bağlı olacaktır. Koda aslında sadece bu dört satırda bekler.
    </para></sect1></chapter>
  <chapter id="glibc-Signal-Stack">
    <title>Sinyal Yığıtı</title>
    <titleabbrev>Ayrı bir sinyal yığıtı kullanmak</titleabbrev>
    <para>
Bir sinyal yığıtı, sinyal eylemcilerin icra yığıtı olarak kullanılan özel bir bellek alanıdır. Taşmalardan kaçınmak için oldukça büyük olmalıdır; boyutunu belirlemek amacıyla <command>SIGSTKSZ</command> makrosu tanımlanmıştır. Yığıt için gereken alanı <command>malloc</command> ile ayırabilirsiniz. Bundan sonra yapacağınız bir <command>sigaltstack</command> veya <command>sigstack</command> çağrısı ile sisteme bu alanın sinyal yığıtı olarak kullanılacağını belirtebilirsiniz.
   </para><para>
Sinyal yığıtını kullanmaları için sinyal eylemcileri oluştururken farklı bir şey yapmanız gerekmez. Bir yığıttan diğerine geçilmesi özdevinimli gerçekleşir. (GNU hata ayıklayıcıları dışındaki bazı hata ayıklayıcılar bazı makinelerde bir sinyal eylemcisinin sinyal yığıtını kullandığı durumda yığıt izlemesini başarıyla yapamayabilir.)
   </para><para>
Sisteme ayrı bir sinyal yığıtı kullanmasını belirtmenin iki yolu vardır. 4.2 BSD ile gelen <command>sigstack</command> biraz eski bir arayüzdür. 4.4 BSD ile gelen <command>sigaltstack</command> daha yenidir. <command>sigaltstack</command> işlevinin bir getirisi vardır; makineye ve işletim sistemine bağlı olan yığıt büyümesinin yönü ile ilgilenmek zorunda kalmazsınız.
   </para><para>
<indexterm scope="glibc-tp"><primary>stack_t</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü" id="glibc-stack_t">
<funcdef><command>stack_t</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu veri yapısı bir sinyal yığıtı hakkında bilgi içerir. Aşağıdaki üyelere sahiptir:
   </para><para><glosslist><glossentry><glossterm>
   <literal>void *<command>ss_sp</command></literal>
   </glossterm><glossdef><para>
Sinyal yığıtının taban adresidir.
   </para></glossdef></glossentry><glossentry><glossterm>
   <literal>size_t <command>ss_size</command></literal>
   </glossterm><glossdef><para>
<command>ss_sp</command>'den başlayan sinyal yığıtının boyutudur. Yığıt için ne kadar yer ayrılacağını bu üye ile belirteceksiniz.
      </para><para>
Yığıt için gereken alanı hesaplamak için <filename>signal.h</filename> dosyasında tanımlanmış iki makro vardır:
      </para><para><variablelist><varlistentry>
      <term><literal>SIGSTKSZ</literal></term><listitem><para>
Bu bir sinyal yığıtı için olması gereken boyuttur. Normal kullanımlar için yeterli olabilecek kadardır.
         </para></listitem></varlistentry><varlistentry>
         <term><literal>MINSIGSTKSZ</literal></term><listitem><para>
İşletim sisteminin sinyal göndermeyi gerçekleştirebileceği sinyal yığıtı boyutudur. Ayıracağınız sinyal yığıtı boyutu bu değerden <emphasis>BÜYÜK</emphasis> olmalıdır.
         </para><para>
Çoğu durumda, <command>ss_size</command> için <command>SIGSTKSZ</command> kullanmak yeterlidir. Ama yazılımınızın sinyal eylemcilerinin ne kadar yığıt alanı kullanacaklarını biliyorsanız, bundan farklı bir değer de kullanabilirsiniz. Bu durumda en az <command>MINSIGSTKSZ</command> yer ayırmanız gerekir, <command>ss_size</command> ile bu değerden büyük herhangi bir değeri atayabilirsiniz.
         </para></listitem></varlistentry></variablelist>
   </para></glossdef></glossentry><glossentry><glossterm>
   <literal>int <command>ss_flags</command></literal>
   </glossterm><glossdef><para>
Bu üye şu seçeneklerin bit bit veyalanmış değerini içerir:
      </para><para><variablelist><varlistentry>
      <term><literal>SS_DISABLE</literal></term><listitem><para>
Sistemin sinyal yığıtını kullanmaMAsını belirtir.
         </para></listitem></varlistentry><varlistentry>
         <term><literal>SS_ONSTACK</literal></term><listitem><para>
Sistem tarafından atanır ve sinyal yığıtının o an kullanılmakta olduğunu belirtir. Bu bit etkin değilse sinyaller, normal kullanıcı yığıtını kullanıyor demektir.
         </para></listitem></varlistentry></variablelist>
   </para></glossdef></glossentry></glosslist>
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>sigaltstack</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-sigaltstack">
<funcdef>int <command>sigaltstack</command></funcdef>
<paramdef>(const stack_t *restrict <varname>yığıt</varname>,
 stack_t *restrict       <varname>eski_yığıt</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>sigaltstack</command> işlevi, sinyal eylemcilerin ayrı bir sinyal yığıtı kullanacağını belirtir. Süreç tarafından bir sinyal alındığında sinyalin eyleminin sinyal yığıtı üzerinden işlenecekse, sistem, sinyal eylemcinin çalışırken bu sinyal yığıtının kullanılması için gerekli düzenlemeyi yapar.
   </para><para>
<varname>eski_yığıt</varname> bir boş gösterici değilse, kurulu sinyal yığıtının bilgileri bu adreste döndürülür.  <varname>yığıt</varname> bir boş gösterici değilse, bu, sinyal eylemciler tarafından kullanılacak yeni yığıtı belirtir.
   </para><para>
İşlev başarılı olduğunda <command>0</command> ile döner, aksi takdirde <command>-1</command> ile döner. Aşağıdaki <command>errno</command> değerleri bu işlev için tanımlanmıştır:
   </para><para><variablelist><varlistentry>
   <term><literal>EINVAL</literal></term><listitem><para>
Kullanımda olan bir yığıtı iptal etmeye çalıştınız.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>ENOMEM</literal></term><listitem><para>
Yeni yığıtın boyu <command>MINSIGSTKSZ</command> değerinden küçük.
      </para></listitem></varlistentry></variablelist>
</para></funcdescr></funcsynopsis></para><para>
Burada eski arayüz olan <command>sigstack</command> işlevini de anlatacağız ancak, sistem bu işlevi içerse bile bunun yerine <command>sigaltstack</command> işlevini kullanmalısınız.
   </para><para>
<indexterm scope="glibc-tp"><primary sortas="sigstack">struct sigstack</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü" id="glibc-struct-sigstack">
<funcdef>struct <command>sigstack</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu veri yapısı bir sinyal yığıtı hakkında bilgi içerir. Şu üyelere sahiptir:
   </para><para><glosslist><glossentry><glossterm>
   <literal>void *<command>ss_sp</command></literal>
   </glossterm><glossdef><para>
Yığıt göstericisidir. Yığıt aşağı doğru büyüyorsa bu değer yığıtın tepesini, yukarı doğru büyüyorsa yığıtın altını gösterir.
   </para></glossdef></glossentry><glossentry><glossterm>
   <literal>int <command>ss_onstack</command></literal>
   </glossterm><glossdef><para>
Sistem o an bu yığıtı kullanıyorsa bu alanın değeri "doğru"dur.
   </para></glossdef></glossentry></glosslist>
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>sigstack</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-sigstack">
<funcdef>int <command>sigstack</command></funcdef>
<paramdef>(const struct sigstack *<varname>yığıt</varname>,
 struct sigstack       *<varname>eski_yığıt</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>sigstack</command> işlevi, sinyal eylemcilerin ayrı bir sinyal yığıtı kullanacağını belirtir. Süreç tarafından bir sinyal alındığında sinyalin eyleminin sinyal yığıtı üzerinden işlenecekse, sistem, sinyal eylemcinin çalışırken bu sinyal yığıtının kullanılması için gerekli düzenlemeyi yapar.
   </para><para>
<varname>eski_yığıt</varname> bir boş gösterici değilse, kurulu sinyal yığıtının bilgileri bu adreste döndürülür.  <varname>yığıt</varname> bir boş gösterici değilse, bu, sinyal eylemciler tarafından kullanılacak yeni yığıtı belirtir.
   </para><para>
İşlev başarılı olduğunda <command>0</command> ile döner, aksi takdirde <command>-1</command> ile döner.
  </para></funcdescr></funcsynopsis></para></chapter>
  <chapter id="glibc-BSD-Signal-Handling">
    <title>BSD Usulü Sinyal İşleme</title>
    <titleabbrev>BSD ile geriye uyumluluk için varolan işlevler.</titleabbrev>
    <para>
Bu bölümde sinyal işleme işlevlerinin BSD Unix'de gerçeklenmiş benzerleri açıklanmıştır. Bu oluşumlar zamanı için ileri düzeydeydiler; günümüzde ise tamamen atıl olmuşlardır ve sadece BSD Unix uyumluluğu için kütüphaneye konmuşlardır.
   </para><para>
BSD ve POSIX sinyal işleme oluşumları arasında bir çok benzerlik vardır, çünkü POSIX oluşumları tasarlanırken BSD oluşumlarından ilham alınmıştır. İsim karışıklıklarından kaçınmak için isimlerinin farklılaştırılmalarının yanında aralarınta iki temel fark bulunur:
   </para><para><itemizedlist><listitem><para>
BSD Unix sinyal maskeleri, birer <command>sigset_t</command> nesnesi olarak değil birer <command>int</command> bit maskesi olarak tasarlanmıştır.
     </para></listitem><listitem><para>
Kesme alan ilkellerin başarısız mı kabul edileceği yoksa işlemlerine kaldıkları yerden devam mı edeceklerini belirten öntanımlama BSD oluşumlarında farklıdır. POSIX oluşumları aksi belirtilmedikçe ilkellerin başarısız olacaklarını, BSD oluşumları ise aksi belirtilmedikçe bu ilkellerin işlemlerine kaldıkları yerden devam edecekleri kabulüne dayanır. Bkz. <xref linkend="glibc-Interrupted-Primitives"/>.
     </para></listitem></itemizedlist></para><para>
BSD oluşumları <filename>signal.h</filename> dosyasında bildirilmiştir.
<indexterm scope="glibc-pg"><primary>signal.h</primary></indexterm></para>
  <sect1 id="glibc-BSD-Handler">
    <title>BSD Eylemciler</title>
    <titleabbrev>Bir eylemciyi kuran BSD oluşumları.</titleabbrev>
    <para>
<indexterm scope="glibc-tp"><primary sortas="sigvec">struct sigvec</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü" id="glibc-struct-sigvec">
<funcdef>struct <command>sigvec</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu veri türü <command>struct sigaction</command> yapısının BSD eşdeğeridir. (Bkz. <xref linkend="glibc-Advanced-Signal-Handling"/>); <command>sigvec</command> işlevine sinyal eylemlerini belirtmek için kullanılır. Üyeleri şunlardır:
   </para><para><glosslist><glossentry><glossterm>
   <literal>sighandler_t <command>sv_handler</command></literal>
   </glossterm><glossdef><para>
Eylemci işlevdir.
   </para></glossdef></glossentry><glossentry><glossterm>
   <literal>int <command>sv_mask</command></literal>
   </glossterm><glossdef><para>
Eylemci çalışırken engellenecek sinyallerden oluşan maske.
   </para></glossdef></glossentry><glossentry><glossterm>
   <literal>int <command>sv_flags</command></literal>
   </glossterm><glossdef><para>
Sinyalin davranışını etkileyen seçeneklerden oluşan maske. Bu alana ayrıca
<command>sv_onstack</command> ile de erişebilirsiniz.
   </para></glossdef></glossentry></glosslist>
</para></funcdescr></funcsynopsis></para><para>
Bu sembolik sabitler bir <command>sigvec</command> yapısının <command>sv_flags</command> alanının değerleri olarak kullanılabilirler. Bu alan bir bit maskesi olduğundan bu değerleri bit bit veyalayarak birarada belirtebilirsiniz.
    </para><para>
<indexterm scope="glibc-vr"><primary>SV_ONSTACK</primary></indexterm>
<funcsynopsis><funcprototype role="makro" id="glibc-SV_ONSTACK">
<funcdef>int <command>SV_ONSTACK</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu bit, <command>sigvec</command> yapısının <command>sv_flags</command> alanında etkinse, sinyal alındığında sinyal yığıtı kullanılır.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-vr"><primary>SV_INTERRUPT</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü" id="glibc-SV_INTERRUPT">
<funcdef>int <command>SV_INTERRUPT</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu bit, <command>sigvec</command> yapısının <command>sv_flags</command> alanında etkinse, sistem çağrılarını kesmeye uğratan sinyaller alındığında, sinyal eylemci işini bitirdiğinde bu çağrılar yeniden yapılmaz; bunun yerine sistem çağrıları <command>EINTR</command> hata durumu ile döner. Bkz. <xref linkend="glibc-Interrupted-Primitives"/>.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-vr"><primary>SV_RESETHAND</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü" id="glibc-SV_RESETHAND">
<funcdef>int <command>SV_RESETHAND</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu bit, <command>sigvec</command> yapısının <command>sv_flags</command> alanında etkinse, sinyal alındığında sinyalin eylemi <command>SIG_DFL</command> yapılır.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>sigvec</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-sigvec">
<funcdef>int <command>sigvec</command></funcdef>
<paramdef>(int                  <varname>sinyalnum</varname>,
 const struct sigvec *<varname>eylem</varname>,
 struct sigvec       *<varname>eski_eylem</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>sigaction</command> işlevinin eşdeğeridir (Bkz. <xref linkend="glibc-Advanced-Signal-Handling"/>); <varname>sinyalnum</varname> sinyali için <varname>eylem</varname> eylemini kurar. Önceki eylem <varname>eski_eylem</varname> argümanında döner.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>siginterrupt</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-siginterrupt">
<funcdef>int <command>siginterrupt</command></funcdef>
<paramdef>(int <varname>sinyalnum</varname>,
 int <varname>seçenek</varname>)</paramdef>
</funcprototype><funcdescr><para>
<varname>sinyalnum</varname> sinyali arafından kesintiye uğrayan ilkellerin hangi yaklaşımı kullanacağını belirtmekte kullanılır. <varname>seçenek</varname> yanlışsa, <varname>sinyalnum</varname> sinyali ilkelleri yeniden başlatır; doğruysa, ilkeller <command>EINTR</command> hata kodu ile başarısız olur Bkz.  <xref linkend="glibc-Interrupted-Primitives"/>.
  </para></funcdescr></funcsynopsis></para></sect1>
  <sect1 id="glibc-Blocking-in-BSD">
    <title>BSD'de Sinyal Engelleme</title>
    <titleabbrev>Sinyalleri engellemekte kullanılan BSD işlevleri</titleabbrev>
    <para>
<indexterm scope="glibc-fn"><primary>sigmask</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-sigmask">
<funcdef>int <command>sigmask</command></funcdef>
<paramdef>(int <varname>sinyalnum</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu makro, <varname>sinyalnum</varname> sinyalinin bir sinyal maskesine dahil edilmesi için kullanılır.  Birden fazla sinyali her sinyal için yapılan <command>sigmask</command> çağrılarını veyalayarak maskeye dahil edebilirsiniz. Örnek:
    </para><para>
<screen>(sigmask (SIGTSTP) | sigmask (SIGSTOP)
 | sigmask (SIGTTIN) | sigmask (SIGTTOU))
</screen></para><para>
Bu kod, tamamı iş denetim sinyallerinden oluşan bir maske belirtir.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>sigblock</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-sigblock">
<funcdef>int <command>sigblock</command></funcdef>
<paramdef>(int <varname>maske</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>sigprocmask</command> (bkz. <xref linkend="glibc-Process-Signal-Mask"/>) işlevinin <varname>nasıl</varname> argümanına <command>SIG_BLOCK</command> atanmış bir eşdeğeridir: <varname>maske</varname> ile belirtilen sinyalleri sürecin engellenen sinyaller kümesine ekleyerek önceki sinyal kümesi ile döner.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>sigsetmask</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-sigsetmask">
<funcdef>int <command>sigsetmask</command></funcdef>
<paramdef>(int <varname>maske</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>sigprocmask</command> (bkz. <xref linkend="glibc-Process-Signal-Mask"/>) işlevinin <varname>nasıl</varname> argümanına <command>SIG_SETMASK</command> atanmış bir eşdeğeridir: <varname>maske</varname> ile belirtilen sinyalleri sürecin engellenen sinyaller kümesi yaparak önceki sinyal kümesi ile döner.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>sigpause</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-sigpause">
<funcdef>int <command>sigpause</command></funcdef>
<paramdef>(int <varname>maske</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>sigsuspend</command> (bkz. <xref linkend="glibc-Waiting-for-a-Signal"/>) işlevinin eşdeğeridir: <varname>maske</varname> ile belirtilen sinyalleri sürecin engellenen sinyaller kümesi yaparak bir sinyal gelmesini bekler. İşlev dönerken eski sinyal kümesi etkinleştirilir.
    </para></funcdescr></funcsynopsis></para></sect1>
</chapter>
</part>
