<?xml version="1.0" encoding="UTF-8"?>
<!-- ********************************************************************
        glibc/ch26.xml,v2.36, GFDL,LGPL, NBB, 2023
     ******************************************************************** -->
<part xml:id="glibc-Processes">
 <title>Süreçler</title>
 <titleabbrev>Süreçler nasıl oluşturulur ve diğer yazılımlar nasıl çalıştırılır.</titleabbrev>
 <preliminary>
  <para>
   <indexterm linkend="glibc-cp"><primary>süreçler</primary></indexterm>
   <wordasword>Süreçler</wordasword> sistem kaynaklarının ayrılmasını sağlayan temel birimlerdir. Her süreç kendi adres alanına ve (genellikle) bir denetim evresine sahiptir. Süreç yazılımı çalıştırır; aynı yazılımı çalıştıran farklı süreçler olabilir, fakat her süreç kendi adres alanında yazılımın kendi kopyasına sahiptir ve bunu diğer kopyalardan bağımsız olarak çalıştırır.
  </para>
  <para>
   <indexterm linkend="glibc-cp"><primary>süreçler</primary><secondary>alt süreç</secondary></indexterm>
   <indexterm linkend="glibc-cp"><primary>süreçler</primary><secondary>üst süreç</secondary></indexterm>
   Süreçler hiyerarşik olarak düzenlenmiştir. Her sürecin, kendisini oluşturan bir <wordasword>üst süreç</wordasword>i vardır. Üst süreç tarafından oluşturulan süreçler <wordasword>alt süreçler</wordasword> olarak anılır. Bir alt süreç birçok özelliğini üst sürecinden alır.
  </para>
  <para>
   Bu kısımda bir yazılımın alt süreçleri nasıl oluşturabileceği, sonlandırabileceğini ve denetleyebileceğini anlatılmıştır. Aslında, üç farklı işlem vardır: yeni bir alt sürecin oluşturulması, yeni sürecin bir yazılımı çalıştırması ve alt sürecin tamamlanmasının ana yazılımla eşgüdümlenmesi.
  </para>
  <para>
   <function>system</function> işlevi başka bir yazılımın çalıştırılması için basit, taşınabilir bir düzenek sunmaktadır; üç adımı da özdevinimli olarak yapar. Bunun yapılışı ile ilgili ayrıntılar üzerinde daha fazla denetim sahibi olmak için, temel işlevler kullanılarak her adım tek tek gerçekleştirilebilir.
  </para>
 </preliminary>
 <chapter xml:id="glibc-Running-a-Command">
  <title>Komut Çalıştırmak</title>
  <titleabbrev>Başka bir yazılımı çalıştırmanın kolay yolu.</titleabbrev>
  <para>
   Başka bir yazılımı çalıştırmanın kolay yolu <function>system</function> işlevinin kullanılmasıdır.  Bu işlev bir alt yazılımı çalıştırmak için gerekli bütün işi yapar, ayrıntılar üzerinde fazla denetim sağlamaz:  başka bir şey yapmadan önce alt yazılım sonlanıncaya kadar beklemek gerekir.
   <indexterm linkend="glibc-pg"><primary>stdlib.h</primary></indexterm>
  </para>
  <csynopsis>
   <indexterm linkend="glibc-pg" xml:id="glibc-pg-system"><primary>sh</primary></indexterm>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-system"><primary>system</primary></indexterm>
   <indexterm linkend="glibc-cp"><primary>süreçler</primary><secondary>komut çalıştırmak</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>system</function></csname>
    <csparam><ptr>const&nbsp;char</ptr><parameter>command</parameter></csparam>
   </csproto>
   <header>&stdlib.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&asunsafe; &plugin; &heap; &lock;</concept>
    <concept>&acunsafe; &lock; &mem;</concept>
   </conceptlist>
   <para>
    Bu işlev <parameter>command</parameter> komutunu bir kabuk komutu olarak çalıştırır. &glibc;nde, bir komutu çalıştırmak için her zaman ön tanımlı kabuk olan <link linkend="man1-dash">sh</link> kullanılır. Özellikle <varname>PATH</varname> içinde belirtilen dizinleri arayarak çalıştırılacak yazılımı bulmaya çalışır. Kabuk sürecini oluşturamadıysa dönüş değeri <code>-1</code>, aksi takdirde kabuk sürecinin durumudur. Bu durum kodunun nasıl yorumlanacağı konusunda ayrıntılı bilgi için bkz. <xref linkend="glibc-Process-Completion"/>.
   </para>
   <para>
    <parameter>command</parameter> bağımsız değişkeni boş gösterici olarak verilirse, dönüş değerinin sıfır olması hiçbir komut işleticisinin olmadığını gösterir.
   </para>
   <para>
    Bu işlev çok evreli yazılımlar için iptal noktasıdır. Eğer <code>system</code> çağrıldığında bir evre bazı kaynakları (bellek, dosya tanıtıcısı, semafor veya herhangi bir öz kaynak) tahsis ederse bu sorun olur. Evre iptal edilirse bu kaynaklar yazılım sonlanıncaya kadar tahsisli durumda kalır. Bundan kaçınmak için <code>system</code> işlevine yapılan çağrılarda iptal işleyicileri kullanılarak korunulmalıdır.
   </para>
  </csynopsis>
  <note><title>Uyumluluk Bilgisi</title>
   <para>
    Bazı C gerçeklemeleri başka yazılımları çalıştıran bir komut işleticisine sahip olmayabilir. Komut işleticisinin olup olmadığı <code>system&nbsp;(NULL)</code> çalıştırılarak anlaşılabilir; eğer dönüş değeri sıfır değilse, bir komut işleticisi vardır.
   </para>
  </note>
  <para>
   <function>popen</function> ve <function>pclose</function> işlevleri (<xref linkend="glibc-Pipe-to-a-Subprocess"/>) <function>system</function> işleviyle yakından ilgilidir. Bunlar üst sürecin, çalıştırılan komutun standart girdi ve çıktı kanallarıyla haberleşmesini sağlar.
  </para>
 </chapter>
 <chapter xml:id="glibc-Process-Creation-Concepts">
  <title>Süreç Oluşturma Kavramları</title>
  <titleabbrev>Zor yoldan yapılışına genel bakış.</titleabbrev>
  <para>
   Bu bölüm süreçlere genel bakış, adım adım süreç oluşturma ve süreçlerin başka bir yazılımı çalıştırmasını içermektedir.
  </para>
  <para>
   <indexterm linkend="glibc-cp"><primary>süreçler</primary><secondary>süreç kimliği (PID)</secondary></indexterm>
   <indexterm linkend="glibc-cp"><primary>süreçler</primary><secondary>süreç ömrü</secondary></indexterm>
   Yeni bir süreç, <function>posix_spawn</function>, <function>fork</function>, <function>_Fork</function> veya <function>vfork</function> işlevlerinden biri çağrıldığında oluşur. (<function>system</function> ve <function>popen</function> ayrıca yeni süreçleri dahili olarak oluşturur.) <function>fork</function> işlevinin adından dolayı, yeni bir süreç oluşturma eylemine bazen <wordasword>çatallama</wordasword> adı verilir. Her yeni sürece (çocuk süreç veya alt süreç), üst sürecin süreç kimliğinden farklı bir  <wordasword>süreç kimliği </wordasword> atanır. Bkz. <xref linkend="glibc-Process-Completion"/>.
  </para>
  <para>
   <indexterm linkend="glibc-cp"><primary>süreçler</primary><secondary>oluşturulması</secondary></indexterm>
   <indexterm linkend="glibc-cp"><primary>süreçler</primary><secondary>çatallama</secondary></indexterm>
   <indexterm linkend="glibc-cp"><primary>süreçler</primary><secondary>alt süreç</secondary></indexterm>
   <indexterm linkend="glibc-cp"><primary>süreçler</primary><secondary>üst süreç</secondary></indexterm>
   Bir alt süreci çatalladıktan sonra, üst ve alt süreçler normal çalışmalarına devam eder. Yazılımın devam etmeden önce alt süreçlerin çalışması bitinceye kadar beklemesi isteniyorsa, çatallanma işleminden hemen sonra <function>wait</function> veya <function>waitpid</function> çağrılarıyla bunun açıkça yapılması gerekir (<xref linkend="glibc-Process-Completion"/>). Bu işlevler alt sürecin neden sonlandırıldığı hakkında sınırlı bilgi verir -- örneğin, çıkış durum kodu gibi.
  </para>
  <para>
   Yeni çatallanan alt süreç aynı yazılımı, <function>fork</function> çağrısının döndüğü noktada, üst süreç olarak çalıştırmaya devam eder. <function>fork</function> işlevinin dönüş değeri, yazılımın üst süreçte mi yoksa alt süreçte mi çalıştığını söylemek için kullanılabilir.
  </para>
  <para>
   <indexterm linkend="glibc-cp"><primary>süreçler</primary><secondary>süreç imgesi</secondary></indexterm>
   Aynı yazılımı çalıştıran çeşitli süreçlerin olması ara sıra kullanışlıdır. Fakat alt süreç <function>exec</function> işlevlerinden birini kullanarak başka bir yazılımı da çalıştırabilir; bkz. <xref linkend="glibc-Executing-a-File"/>. Sürecin çalıştırdığı yazılıma <wordasword>süreç imgesi</wordasword> denir. Yeni yazılımın yürütülmeye başlanması, sürecin, önceki süreç imgesi hakkındaki herşeyi unutmasına sebep olur; yeni yazılım sonlandığında, önceki süreç imgesine dönülmez, süreç de sonlanır.
  </para>
 </chapter>
 <chapter xml:id="glibc-Process-Identification">
  <title>Süreç Kimliği</title>
  <titleabbrev>Bir sürecin süreç kimliği nasıl elde edilir.</titleabbrev>
  <para>
   Her süreç, <type>pid_t</type> türünde bir değer olan bir süreç kimlik numarasıyla adlandırılır. Oluşturulduğunda her sürece bir <wordasword>süreç kimliği</wordasword>  atanır. Süreç kimlikleri zaman zaman yeniden kullanılır. Bir sürecin ömrü, üst süreci süreç kimliğinde beklerken, süreç sonlandırıldığında sona erer. Bkz. <xref linkend="glibc-Process-Completion"/> (Üst süreç, böyle bir beklemenin örtük olarak gerçekleşmesini sağlayabilir.) Bir süreç kimliği, bir süreci yalnızca sürecin ömrü boyunca eşsiz bir şekilde tanımlar. Genel bir kural olarak, bu, sürecin hala çalışıyor olması gerektiği anlamına gelir.
  </para>
  <para>
   Süreç kimlikleri, süreç gruplarını ve oturumlarını da ifade edebilir. Bkz. <xref linkend="glibc-Job-Control"/>.
   </para>
  <para>
   <indexterm linkend="glibc-cp"><primary>süreçler</primary><secondary>evre kimliği</secondary></indexterm>
   <indexterm linkend="glibc-cp"><primary>süreçler</primary><secondary>görev kimliği</secondary></indexterm>
   <indexterm linkend="glibc-cp"><primary>süreçler</primary><secondary>evre grubu</secondary></indexterm>
   <indexterm linkend="glibc-cp"><primary>süreçler</primary><secondary>evre grup kimliği</secondary></indexterm>
   Linux'ta, <function>pthread_create</function> tarafından oluşturulan evreler bunun yanında bir de <wordasword>evre kimliği</wordasword> alır. İlk (ana) evrenin evre kimliği, tüm sürecin süreç kimliği ile aynıdır. Daha sonra oluşturulan evreler için evre kimlikleri farklıdır. Evre kimlikleri, süreç kimlikleriyle aynı numaralandırma alanından tahsis edilir. Süreç kimlikleri ve evre kimlikleri bazen toplu olarak <wordasword>görev kimlikleri</wordasword> olarak da anılır. Süreçlerin aksine, evreler hiçbir zaman açıkça bekletilmez, bu nedenle bir evre kimliği, evre çıkar çıkmaz veya iptal edilir edilmez yeniden kullanıma uygun hale gelir. Bu, yalnızca kopan evreler için değil, eklemlenebilir evreler için bile geçerlidir. Evreler bir <wordasword>evre grubu</wordasword>na atanır. Linux üzerinde çalışan &glibc; gerçekleniminde, süreç kimliği, süreçteki tüm evreler için <wordasword>evre grup kimliği</wordasword>dir.
  </para>
  <para>
   Bir sürecin süreç kimliği <function>getpid</function> çağrısıyla alınabilir. Geçerli sürecin <wordasword>üst süreç kimliği</wordasword> ise <function>getppid</function> çağrısıyla alınabilir. Bu işlevleri kullanmak için yazılımın &unistd.h; ve &sys-types.h; başlık dosyalarını içermesi gerekir.
   <indexterm linkend="glibc-pg"><primary>sys/types.h</primary></indexterm>
   <indexterm linkend="glibc-pg"><primary>unistd.h</primary></indexterm>
  </para>
  <csynopsis>
   <indexterm linkend="glibc-tp" xml:id="glibc-tp-pid_t"><primary>pid_t</primary></indexterm>
   <csproto type="veri türü">
    <csname><function>pid_t</function></csname>
   </csproto>
   <header>&unistd.h;</header>
   <para>
    <code>pid_t</code> veri türü süreç kimliğini gösterebilen imli bir tamsayıdır. &glibc;nde, bu <type>int</type> türüne eşlenir.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-getpid"><primary>getpid</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-getpid"><primary>geçerli sürecin süreç kimliği</primary></indexterm>
   <csproto type="işlev">
    <csname><type>pid_t</type><function>getpid</function></csname>
    <csparam><void/></csparam>
   </csproto>
   <header>&unistd.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <code>getpid</code> işlevi geçerli sürecin süreç kimliğini döndürür.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-getppid"><primary>getppid</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-getppid"><primary>geçerli sürecin üst süreç kimliği</primary></indexterm>
   <csproto type="işlev">
    <csname><type>pid_t</type><function>getppid</function></csname>
    <csparam><void/></csparam>
   </csproto>
   <header>&unistd.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <code>getpid</code> işlevi geçerli sürecin üst süreç kimliğini döndürür.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-gettid"><primary>gettid</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-gettid"><primary>geçerli evrenin evre kimliği</primary></indexterm>
   <csproto type="işlev">
    <csname><type>pid_t</type><function>gettid</function></csname>
    <csparam><void/></csparam>
   </csproto>
   <header>&unistd.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <code>getpid</code> işlevi geçerli evrenin evre kimliğini döndürür. Döndürülen değer, Linux çekirdeğinden alınır ve önbellekte saklanmaz. Sonlanan veya iptal olan evrelerin kimlikleri yukarıda açıklandığı gibi yeniden kullanıma hazır hale gelir.
   </para>
   <para>
    Bu işlev Linux'a özgüdür.
   </para>
  </csynopsis>
 </chapter>
 <chapter xml:id="glibc-Creating-a-Process">
  <title>Bir Sürecin Oluşturulması</title>
  <titleabbrev>Bir alt süreç nasıl çatallanır.</titleabbrev>
  <para>
   <function>fork</function> işlevi süreç oluşturma ilkelidir ve &unistd.h; başlık dosyasında bildirilmiştir.
   <indexterm linkend="glibc-pg"><primary>unistd.h</primary></indexterm>
  </para>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-fork"><primary>fork</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-fork"><primary>geçerli evrenin çatallanması</primary></indexterm>
   <csproto type="işlev">
    <csname><type>pid_t</type><function>fork</function></csname>
    <csparam><void/></csparam>
   </csproto>
   <header>&unistd.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&asunsafe; &plugin;</concept>
    <concept>&acunsafe; &lock;</concept>
   </conceptlist>
   <para>
    <code>fork</code> işlevi yeni bir süreç oluşturur.
   </para>
   <para>
    Süreç oluşturma başarılıysa, hem üst hem de alt sürecin her ikisi de <code>fork</code> işlevinin döndüğünü görür, ancak gördükleri dönüş değerleri farklıdır: <code>fork</code> işlevi, alt sürece <code>0</code> değerini ve üst sürece ise alt sürecin süreç kimliğini döndürür.
   </para>
   <para>
    Süreç oluşturma başarısızsa, <code>fork</code> işlevi üst sürece <code>-1</code> değerini döndürür. Aşağıdaki <varname>errno</varname> hata durumları <code>fork</code> işlevi için tanımlanmıştır:
   </para>
   <variablelist>
    <varlistentry>
     <term><code>EAGAIN</code></term>
     <listitem>
      <para>
       Başka süreç oluşturmak için yeterli sistem kaynağı yok ya da kullanıcının zaten çok fazla süreci çalışmakta. Bu <varname>RLIMIT_NPROC</varname> kaynak sınırının aşılmakta olduğu anlamına gelir, bu genellikle artırılabilir; bkz. <xref linkend="glibc-Limits-on-Resources"/>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>ENOMEM</code></term>
     <listitem>
      <para>
       Süreç sistemin sağlayabileceğinden daha fazla yere ihtiyaç duyuyor.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </csynopsis>
  <para>
   Alt süreçlerin üst süreçlerden farklı olan öznitelikleri:
  </para>
  <simplelist>
   <member>
    Alt sürecin kendi süreç kimliği vardır.
   </member>
   <member>
    Alt sürecin üst süreç kimliği üst sürecinin süreç kimliğidir.
   </member>
   <member>
    Alt süreç, üst sürecin açık dosya tanıtıcılarının kendine ait kopyalarını alır. Böylece üst süreçteki dosya tanıtıcısının özelliklerinin değiştirilmesi alt süreçteki dosya tanıtıcıları etkilemez, bunun tersi de geçerlidir.  Bkz. <xref linkend="glibc-Control-Operations"/>. Ancak, her tanıyıcıyla ilişkilendirilmiş olan dosya konumu her iki süreç tarafından paylaşılır; bkz. <xref linkend="glibc-File-Position"/>.
   </member>
   <member>
    Alt süreçler için biten işlemci zamanları sıfırlanır; bkz. <xref linkend="glibc-Processor-Time"/>.
   </member>
   <member>
    Alt süreç üstü tarafından oluşturulmuş dosya kilitlerini miras almaz.<xref linkend="glibc-Control-Operations"/>.
   </member>
   <member>
    Alt süreç üstü tarafından oluşturulmuş uyarıları miras almaz.<xref linkend="glibc-Setting-an-Alarm"/>.
   </member>
   <member>
    Alt süreç için bekleyen sinyallerin tümü  (<xref linkend="glibc-Delivery-of-Signal"/>) temizlenir. (Alt süreç baskılanmış sinyallerin maskesini ve sinyal eylemlerini üst sürecinden miras alır.)
   </member>
  </simplelist>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-fork_"><primary sortas="Fork">_Fork</primary></indexterm>
   <csproto type="işlev">
    <csname><type>pid_t</type><function>_Fork</function></csname>
    <csparam><void/></csparam>
   </csproto>
   <header>&unistd.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <code>_Fork</code> işlevi <function>fork</function> işlevinin benzeridir, farklı olarak, ne <function>pthread_atfork</function> tarafından kaydedilmiş geri çağırım işlevlerini çağırır ne de herhangi bir kilidi (<function>malloc</function> kilitleri gibi) veya dahili durumu sıfırlar. Yeni alt süreçlerde yalnızca <function>dup2</function> or <function>execve</function> gibi eşzamansız-sinyal-güvenilir (&assafe;) işlevler çağrılır.
   </para>
   <para>
    <code>_Fork</code> işlevi, <function>fork</function> işlevinin &assafe; olan benzeri olup bir GNU oluşumudur.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-vfork"><primary>vfork</primary></indexterm>
   <csproto type="işlev">
    <csname><type>pid_t</type><function>vfork</function></csname>
    <csparam><void/></csparam>
   </csproto>
   <header>&unistd.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&asunsafe; &plugin;</concept>
    <concept>&acunsafe; &lock;</concept>
   </conceptlist>
   <para>
    <code>vfork</code> işlevi <function>fork</function> gibidir fakat bazı sistemlerde daha verimlidir; ancak, güvenli kullanımı için bazı kısıtlar vardır.
   </para>
   <para>
    <function>fork</function> çağıran sürecin adres alanının tam bir kopyasını alıp hem alt hem de üst sürecin bağımsız olarak çalışmasını sağlarken, <code>vfork</code> bu kopyayı yapmaz. Bunun yerine <code>vfork</code> ile oluşturulan alt süreç <function>_exit</function> veya <function>exec</function> işlevleri çağrılana kadar üst sürecin adres alanını paylaşır. Bu arada, üst süreç çalışmayı askıya alır.
   </para>
   <para>
    <code>vfork</code> ile oluşturulan alt sürecin küresel verileri, hatta üstüyle paylaştığı yerel değişkenleri bile değiştirmesine izin vermemek konusunda dikkatli olunmalıdır. Bundan başka, alt süreç <code>vfork</code>'u çağıran işlevden dönemez (veya uzun atlama yapamaz)! Bu üst sürecin denetim bilgisini karıştırabilir. Kuşkunuz varsa, <function>fork</function> kullanın.
   </para>
   <para>
    Bazı işletim sistemleri gerçek anlamda <code>vfork</code>'u gerçeklemez.  &glibc; <code>vfork</code>'un bütün sistemlerde kullanımına izin verir, ancak aslında <code>vfork</code> yoksa <function>fork</function> çalıştırır. Eğer  <code>vfork</code> kullanımında gerekli önlemler alınırsa, sistem onun yerine <code>fork</code>'u kullansa bile yazılım çalışır.
   </para>
  </csynopsis>
 </chapter>
 <chapter xml:id="glibc-Executing-a-File">
  <title>Bir Dosyanın Çalıştırılması</title>
  <titleabbrev>Bir süreç başka bir yazılımı nasıl çalıştırır.</titleabbrev>
  <para>
   <indexterm linkend="glibc-cp"><primary>süreçler</primary><secondary>bir dosyanın çalıştırılması</secondary></indexterm>
   <indexterm linkend="glibc-cp"><primary><command>exec</command> işlevleri</primary></indexterm>
   Bu bölüm bir dosyayı bir süreç imgesi olarak çalıştırmak için kullanılan <function>exec</function> ailesi işlevlerini anlatmaktadır. Bu işlevler bir alt sürecin çatallandıktan sonra yeni bir yazılımı çalıştırmasını sağlamak için kullanılabilir.
  </para>
  <para>
   <function>exec</function> işlevinin etkilerini çağırıldığı yazılımın bakış açısıyla görmek için, bkz. <xref linkend="glibc-Program-Basics"/>.
  </para>
  <para>
   <indexterm linkend="glibc-pg"><primary>unistd.h</primary></indexterm>
   Bu ailedeki işlevler bağımsız değişkenlerinin belirtiliş şekillerine göre farklılıklar gösterir, aksi takdirde hepsi aynı işi yapar. Bunlar &unistd.h; başlık dosyası içinde bildirilmiştir.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-execv"><primary>execv</primary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>execv</function></csname>
    <csparam><ptr>const&nbsp;char</ptr><parameter>filename</parameter></csparam>
    <csparam><type>char&nbsp;*const</type><parameter>argv</parameter><code>[]</code></csparam>
   </csproto>
   <header>&unistd.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <code>execv</code> işlevi <parameter>filename</parameter> adındaki dosyayı yeni bir süreç imgesi olarak çalıştırır.
   </para>
   <para>
    <parameter>argv</parameter> bağımsız değişkeni boş karakter sonlandırmalı dizgelerden oluşan bir dizidir ve bu çalıştırılan yazılımın <code>main</code> işlevinin <parameter>argv</parameter> bağımsız değişkenine değer sağlamak için kullanılır. Bu dizinin son elemanı boş gösterici olmalıdır. Kural olarak, bu dizinin ilk elemanı yazılımın dizinleri olmaksızın dosya ismidir. Yazılımların bu bağımsız değişkenlere nasıl eriştiğiyle ilgili tüm ayrıntılar için, bkz. <xref linkend="glibc-Program-Arguments"/>.
   </para>
   <para>
    Yeni süreç imgesinin ortamı geçerli süreç imgesinin <varname>environ</varname> değişkeninden alınır; ortam değişkenleri hakkında bilgi için, bkz. <xref linkend="glibc-Environment-Variables"/>.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-execl"><primary>execl</primary></indexterm>
   <csproto type="işlev" varargs="">
    <csname><type>int</type><function>execl</function></csname>
    <csparam><ptr>const&nbsp;char</ptr><parameter>filename</parameter></csparam>
    <csparam><ptr>const&nbsp;char</ptr><parameter>arg0</parameter></csparam>
   </csproto>
   <header>&unistd.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&asunsafe; &heap;</concept>
    <concept>&acunsafe; &mem;</concept>
   </conceptlist>
   <para>
    <function>execv</function> gibidir, fakat <parameter>argv</parameter> dizgeleri bir dizi yerine tek tek belirtilir. Son bağımsız değişken boş gösterici olmalıdır.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-execve"><primary>execve</primary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>execve</function></csname>
    <csparam><ptr>const&nbsp;char</ptr><parameter>filename</parameter></csparam>
    <csparam><type>char&nbsp;*const</type><parameter>argv</parameter><code>[]</code></csparam>
    <csparam><type>char&nbsp;*const</type><parameter>env</parameter><code>[]</code></csparam>
   </csproto>
   <header>&unistd.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <function>execv</function> gibidir, fakat yeni yazılım için ortamın açıkça belirtilmesine <parameter>env</parameter> bağımsız değişkeni ile izin verir. Bu <varname>environ</varname> değişkeniyle aynı biçimde, dizgelerden oluşan bir dizi olmalıdır; bkz. <xref linkend="glibc-Environment-Access"/>.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-fexecve"><primary>fexecve</primary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>fexecve</function></csname>
    <csparam><type>int</type><parameter>fd</parameter></csparam>
    <csparam><type>char&nbsp;*const</type><parameter>argv</parameter><code>[]</code></csparam>
    <csparam><type>char&nbsp;*const</type><parameter>env</parameter><code>[]</code></csparam>
   </csproto>
   <header>&unistd.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <function>execve</function> gibidir, çalıştırılabiliri dosya yolu ile belirtmek yerine <parameter>fd</parameter> dosya tanıtıcısını kullanılır. Tanıtıcı  <varname>O_RDONLY</varname> veya (Linux üzerinde) <varname>O_PATH</varname> seçeneği ile açılmış olmalıdır.
   </para>
   <para>
    Linux'ta, <filename>/proc</filename> bağlı değilse ve çekirdek ilgili <function>execveat</function> sistem çağrısı için destek içermiyorsa, <code>fexecve</code> <varname>ENOSYS</varname> hatası vererek başarısız olabilir.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-execle"><primary>execle</primary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>execle</function></csname>
    <csparam><ptr>const&nbsp;char</ptr><parameter>filename</parameter></csparam>
    <csparam><ptr>const&nbsp;char</ptr><parameter>arg0</parameter></csparam>
    <varargs/>
    <csparam><type>char&nbsp;*const</type><parameter>env</parameter><code>[]</code></csparam>
   </csproto>
   <header>&unistd.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&asunsafe; &heap;</concept>
    <concept>&acunsafe; &mem;</concept>
   </conceptlist>
   <para>
    <function>execl</function> gibidir, fakat yeni yazılım için ortamın açıkça belirtilmesine izin verir. <parameter>env</parameter> bağımsız değişkeni son <parameter>argv</parameter> bağımsız değişkeni olan boş göstericiden sonra gelmeli ve <varname>environ</varname> değişkeniyle aynı biçimde, dizgelerden oluşan bir dizi olmalıdır.
   </para>
   </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-execvp"><primary>execvp</primary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>execvp</function></csname>
    <csparam><ptr>const&nbsp;char</ptr><parameter>filename</parameter></csparam>
    <csparam><type>char&nbsp;*const</type><parameter>argv</parameter><code>[]</code></csparam>
   </csproto>
   <header>&unistd.h;</header>
   <conceptlist>
    <concept>&mtsafe; &env;</concept>
    <concept>&asunsafe; &heap;</concept>
    <concept>&acunsafe; &mem;</concept>
   </conceptlist>
   <para>
    <code>execvp</code> işlevi <function>execv</function> gibidir, ancak eğer <parameter>filename</parameter> bir <code>/</code> içermiyorsa <parameter>filename</parameter> isimli dosyanın tam ismini bulmak için <varname>PATH</varname> ortam değişkeninde  (<xref linkend="glibc-Standard-Environment"/>) listelenen dizinleri de arar.
   </para>
   <para>
    Bu işlev sisteme yardımcı yazılımların çalıştırılmasında kullanışlı olabilir, çünkü bu yazılımları bulmak için kullanıcının seçtiği yerlere bakar. Kabuklar bunu kullanıcının yazdığı komutları çalıştırmak için kullanır.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-execlp"><primary>execlp</primary></indexterm>
   <csproto type="işlev" varargs="">
    <csname><type>int</type><function>execlp</function></csname>
    <csparam><ptr>const&nbsp;char</ptr><parameter>filename</parameter></csparam>
    <csparam><ptr>const&nbsp;char</ptr><parameter>arg0</parameter></csparam>
   </csproto>
   <header>&unistd.h;</header>
   <conceptlist>
    <concept>&mtsafe; &env;</concept>
    <concept>&asunsafe; &heap;</concept>
    <concept>&acunsafe; &mem;</concept>
   </conceptlist>
   <para>
    Bu işlev <function>execl</function> gibidir, ancak <function>execvp</function> işlevi gibi dosya ismi araması yapar.
   </para>
  </csynopsis>
  <para>
   Bağımsız değişken listesinin ve ortam değişkenleri listesinin toplam boyutu <varname>ARG_MAX</varname> bayttan büyük olmamalıdır. Bkz. <xref linkend="glibc-General-Limits"/>. GNU sisteminde, her dizge için bu boyut (<varname>ARG_MAX</varname> ile karşılaştırıldığında), "dizge içerisindeki karakter sayısı, artı <type>char *</type> türünün boyutu, artı bir" değerinin <type>char *</type> boyutunun katlarına yuvarlanması ile elde edilir. Diğer sistemler biraz farklı sayım kuralları uygulayabilir.
  </para>
  <para>
   Bu işlevler normalde değer döndürmez, çünkü yeni bir yazılımın çalıştırılması halen çalışan yazılımın tamamen terk edilmesine neden olur. Hata durumunda <code>-1</code> döndürülür. Olağan <link linkend="glibc-File-Name-Errors">dosya ismi hatalarına</link> ek olarak, aşağıdaki <varname>errno</varname> hata durumları bu işlevler için tanımlanmıştır:
  </para>
  <variablelist>
   <varlistentry>
    <term><code>E2BIG</code></term>
    <listitem>
     <para>
      Yeni yazılımın bağımsız değişken listesinin uzunluğuyla ortam değişkenleri listesinin birleştirilmiş büyüklüğü <varname>ARG_MAX</varname> bayttan büyüktür. GNU sisteminde bağımsız değişken listesi büyüklüğü için belirtilmiş bir sınır yoktur, böylece bu hata kodu oluşamaz, ancak eğer bağımsız değişkenler kullanılabilir bellek için çok büyük ise bunun yerine <varname>ENOMEM</varname> alınabilir.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><code>ENOEXEC</code></term>
    <listitem>
     <para>
      Belirtilen dosya doğru biçimde olmadığı için çalıştırılamıyor.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><code>ENOMEM</code></term>
    <listitem>
     <para>
      Belirtilen dosyanın çalıştırılması mevcut olandan daha fazla depolama alanı gerektiriyor.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
  <para>
   Yeni dosyanın çalıştırılması başarılı olursa, okumada olduğu gibi dosyanın erişim zamanı alanını günceller. Dosyaların erişim zamanları hakkında daha fazla bilgi için <xref linkend="glibc-File-Times"/> bölümüne bakınız.
  </para>
  <para>
   Dosyanın tekrar kapandığı nokta belirtilmemiştir, ancak süreçten çıkmadan önceki bir nokta veya başka bir süreç imgesi çalıştırılmadan önceki nokta belirtilmiş olabilir.
  </para>
  <para>
   Yeni bir süreç imgesinin çalıştırılması, sadece bağımsız değişken ve ortam dizgelerini yeni yerlerine kopyalayarak bellek içeriğini tamamen değiştirir. Fakat sürecin diğer birçok özelliği değişmez:
  </para>
  <simplelist>
   <member>
    Süreç kimliği ve üst süreç kimliği. Bkz. <xref linkend="glibc-Process-Creation-Concepts"/>.
   </member>
   <member>
    Oturum ve süreç grubu üyeliği. Bkz. <xref linkend="glibc-Concepts-of-Job-Control"/>.
   </member>
   <member>
    Gerçek kullanıcı kimliği ve grup kimliği ile ek grup kimlikleri.  Bkz. <xref linkend="glibc-Process-Persona"/>.
   </member>
   <member>
    Bekleyen uyarılar. Bkz. <xref linkend="glibc-Setting-an-Alarm"/>.
   </member>
   <member>
    Geçerli çalışma dizini ve kök dizini. Bkz. <xref linkend="glibc-Working-Directory"/>. GNU sisteminde, kök dizini bir setuid yazılım çalıştırılırken kopyalanmaz; bunun yerine yeni yazılım için sistemin ön tanımlı kök dizini kullanılır.
   </member>
   <member>
    Dosya kipi oluşturma maskesi. Bkz. <xref linkend="glibc-Setting-Permissions"/>.
   </member>
   <member>
    Süreç sinyal maskesi; bkz. <xref linkend="glibc-Process-Signal-Mask"/>.
   </member>
   <member>
    Bekleyen sinyaller; bkz. <xref linkend="glibc-Blocking-Signals"/>.
   </member>
   <member>
    Sürece ilişkin biten işlemci süresi; bkz. <xref linkend="glibc-Processor-Time"/>.
   </member>
  </simplelist>
  <para>
   Eğer süreç görüntü dosyasının set-user-ID ve set-group-ID kip bitleri işaretlenmişse, bu sürecin etkin kullanıcı kimliği ve grup kimliği (sırasıyla) değerlerini etkiler. Bu kavramlara ayrıntılı bir şekilde <xref linkend="glibc-Process-Persona"/> bölümünde değinilmiştir.
  </para>
  <para>
   Geçerli süreçte görmezden gelinecek sinyaller yeni süreçte de dikkate alınmayacak şekilde ayarlanmalıdır. Diğer bütün sinyaller yeni süreç imgesinde ön tanımlı hareketlerine ayarlanır. Sinyaller hakkında daha fazla bilgi için, bkz.  <xref linkend="glibc-Signal-Handling"/>.
  </para>
  <para>
   Varolan süreç imgesinde açık kalan dosya tantıcıları yeni süreç imgesinde de <varname>FD_CLOEXEC</varname> (close-on-exec) bayrak kümesine sahip değilse açık kalır. Açık kalan dosyalar var olan süreç imgesinden açık dosya tanıtıcısının dosya kilitleri dahil bütün özelliklerini miras alır. Dosya tanıtıcıları <xref linkend="glibc-Low-Level-I-O"/> bölümünde incelenmiştir.
  </para>
  <para>
   Akımlar, buna karşın, <function>exec</function> işlevleriyle varlıklarını sürdüremez, çünkü bunlar sürecin kendi bellek alanına yerleşmektedir. Yeni süreç imgesinin kendisinin yeniden oluşturdukları dışında akımları yoktur. <function>exec</function> öncesi süreç imgesinin içindeki akımların her birinin içinde bir tanıtıcı vardır ve bunlar <function>exec</function> ile varlıklarını sürdürür (<varname>FD_CLOEXEC</varname> kümesinin olmaması halinde). Yeni süreç imgesi bu yeni akımlara <function>fdopen</function> kullanarak tekrar bağlanabilir (bkz. <xref linkend="glibc-Descriptors-and-Streams"/>).
  </para>
 </chapter>
 <chapter xml:id="glibc-Process-Completion">
  <title>Süreç Tamamlama</title>
  <titleabbrev>Bir alt sürecin tamamlandığı nasıl anlaşılır.</titleabbrev>
  <para>
   <indexterm linkend="glibc-pg"><primary>sys/wait.h</primary></indexterm>
   <indexterm linkend="glibc-cp"><primary>süreçler</primary><secondary>süreç tamamlama</secondary></indexterm>
   <indexterm linkend="glibc-cp"><primary>süreçler</primary><secondary>bir alt sürecin tamamlanmasının beklenmesi</secondary></indexterm>
   <indexterm linkend="glibc-cp"><primary>süreçler</primary><secondary>bir alt sürecin çıkış durumunun sınanması</secondary></indexterm>
   Bu bölümde anlatılan işlevler bir alt sürecin sonlanmasını veya durmasını beklemek ve durumunu algılamak için kullanılır. Bu işlevler &sys-wait.h; başlık dosyasında bildirilmiştir.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-waitpid"><primary>waitpid</primary></indexterm>
   <csproto type="işlev">
    <csname><type>pid_t</type><function>waitpid</function></csname>
    <csparam><type>pid_t</type><parameter>pid</parameter></csparam>
    <csparam><ptr>int</ptr><parameter>status-ptr</parameter></csparam>
    <csparam><type>int</type><parameter>options</parameter></csparam>
   </csproto>
   <header>&sys-wait.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <code>waitpid</code> işlevi, süreç kimliği <parameter>pid</parameter> olan alt sürecin durum bilgisini istemek için kullanılır. Normalde, çağıran süreç, alt süreç sonlanarak durum bilgisini verene kadar askıda kalır.
   </para>
   <para>
    <parameter>pid</parameter> bağımsız değişkeni için verilecek diğer değerler farklı yorumlanır. <code>-1</code> veya <varname>WAIT_ANY</varname> değeri herhangi bir alt süreç için durum bilgisi ister; <code>0</code> veya <varname>WAIT_MYPGRP</varname> değeri çağıran süreçle aynı süreç grubundaki herhangi bir alt süreç için bilgi ister; ve -<varname>sgkim</varname> gibi başka herhangi bir negatif değer, süreç grup kimliği <varname>sgkim</varname> olan herhangi bir alt süreç için bilgi ister.
   </para>
   <para>
    Eğer alt süreç durum bilgisi mevcutsa, bu işlev beklemeden hemen döner. Eğer birden fazla seçilebilir alt sürecin durum bilgisi mevcutsa, rastgele birisi seçilir ve durum bilgisi hemen döndürülür. Diğer seçilebilir alt süreçlerden birinin durum bilgisini almak için, <code>waitpid</code> işlevini tekrar çağırmak gerekir.
   </para>
   <para>
    <parameter>options</parameter> bağımsız değişkeni bit maskesidir. Değeri sıfır veya daha çok sayıda <varname>WNOHANG</varname> ve <varname>WUNTRACED</varname> bayrağının bitsel VEYAlanmış (yani, <command>|</command> işleci) hali olmalıdır. <varname>WNOHANG</varname> bayrağı üst sürecin beklememesi gerektiğini belirtmek için, <varname>WUNTRACED</varname> bayrağı ise duran ve hatta sonlanan süreçlerden durum bilgisi istemek için kullanılır.
   </para>
   <para>
    Alt süreçten alınan durum bilgisi, <parameter>status-ptr</parameter> boş gösterici değilse, <parameter>status-ptr</parameter> tarafından gösterilen nesnede saklanır.
   </para>
   <para>
    Bu işlev çok evreli yazılımlar için iptal noktasıdır. <code>waitpid</code> çağrıldığında bir evre bazı kaynakları (bellek, dosya tanıtıcısı, semafor veya herhangi bir öz kaynak) tahsis ederse bu sorun olur. Evre iptal edilirse bu kaynaklar yazılım sonlanıncaya kadar tahsisli durumda kalırlar. Bundan kaçınmak için <code>waitpid</code>'e yapılan çağrılar iptal işleyicileri kullanılarak korunmalıdır.
   </para>
   <para>
    Dönüş değeri normalde durumu bildirilen alt sürecin süreç kimliğidir. Eğer alt süreçler var ancak hiçbiri algılanmayı beklemiyorsa, <code>waitpid</code> birisi algılanana kadar engeller. Fakat, <varname>WNOHANG</varname> seçeneği belirtildiyse, <code>waitpid</code> engellemek yerine sıfır döndürür.
   </para>
   <para>
    Eğer <code>waitpid</code> belirli bir süreç kimliği için bekleyecekse, diğer hiçbir alt süreci (varsa) dikkate almaz. Bu nedenle, algılanmayı bekleyen alt süreçler varsa, fakat süreç kimliği belirtilen çocuk bunlardan biri değilse, <code>waitpid</code> yukarıda açıklandığı gibi ya engeller ya da  sıfır döndürür.
   </para>
   <para>
    <code>-1</code> değeri hata halinde döndürülür. Aşağıdaki <varname>errno</varname> hata durumları bu işlev için tanımlanmıştır:
   </para>
   <variablelist>
    <varlistentry>
     <term><code>EINTR</code></term>
     <listitem>
      <para>
       Çağıran sürece bir sinyal gelmesi nedeniyle işlev kesintiye uğradı. Bkz  <xref linkend="glibc-Interrupted-Primitives"/>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>ECHILD</code></term>
     <listitem>
      <para>
       Bekleyen alt süreç yok veya belirtilen <parameter>pid</parameter> çağıran sürecin bir alt süreci değil.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>EINVAL</code></term>
     <listitem>
      <para>
       <parameter>options</parameter> bağımsız değişkeni için geçersiz bir değer verildi.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    Bu simgesel sabitler <code>waitpid</code> işlevinin <parameter>pid</parameter> bağımsız değişkeninin değerleri olarak tanımlanmıştır.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-WAIT_ANY"><primary>WAIT_ANY</primary></indexterm>
    <csproto type="sabit">
     <csname><function>WAIT_ANY</function></csname>
    </csproto>
    <header>&sys-wait.h;</header>
    <para>
     Bu sabit makrosu (değeri <code>-1</code>'dir) <code>waitpid</code> işlevinin herhangi bir alt süreç hakkında durum bilgisi döndürmesi gerektiğini belirtir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-WAIT_MYPGRP"><primary>WAIT_MYPGRP</primary></indexterm>
    <csproto type="sabit">
     <csname><function>WAIT_MYPGRP</function></csname>
    </csproto>
    <header>&sys-wait.h;</header>
    <para>
     Bu sabit (<code>0</code> değerli) <code>waitpid</code> işlevinin çağıran süreçle aynı süreç grubundaki herhangi bir alt süreç hakkında durum bilgisi döndürmesi gerektiğini belirtir.
    </para>
   </csynopsis>
   <para>
    Bu simgesel sabitler <code>waitpid</code> işlevinin <parameter>options</parameter> bağımsız değişkeni için bayrak olarak tanımlanmıştır. Bayraklar bitsel VEYAlanarak bağımsız değişkene değer olarak kullanılabilir.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-WNOHANG"><primary>WNOHANG</primary></indexterm>
    <csproto type="sabit">
     <csname><function>WNOHANG</function></csname>
    </csproto>
    <header>&sys-wait.h;</header>
    <para>
     Bu bayrak, algılanmaya hazır bir alt süreç yoksa, <code>waitpid</code> işlevinin beklemek yerine hemen dönmesi gerektiğini belirtir.
    </para>
   </csynopsis>
   <csynopsis>
   <indexterm linkend="glibc-vr" xml:id="glibc-vr-WUNTRACED"><primary>WUNTRACED</primary></indexterm>
    <csproto type="sabit">
     <csname><function>WUNTRACED</function></csname>
    </csproto>
    <header>&sys-wait.h;</header>
    <para>
     Bu bayrak, <code>waitpid</code> işlevinin durmuş veya sonlandırılmış alt süreçlerinin durumlarını bildirmesi gerektiğini belirtir.
    </para>
   </csynopsis>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-wait"><primary>wait</primary></indexterm>
   <csproto type="işlev">
    <csname><type>pid_t</type><function>wait</function></csname>
    <csparam><ptr>int</ptr><parameter>status-ptr</parameter></csparam>
   </csproto>
   <header>&sys-wait.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    Bu <function>waitpid</function> işlevininin basitleştirilmiş sürümüdür ve herhangi bir alt süreç sonlanıncaya kadar beklemek için kullanılır. Aşağıdaki çağrı şekli:
   </para>
   <literallayout class="monospaced"><code>wait (&amp;<replaceable>status</replaceable>)</code>
</literallayout>
   <para>
    aşağıdaki ile tamamen aynıdır:
   </para>
   <literallayout class="monospaced"><code>waitpid (-1, &amp;<replaceable>status</replaceable>, 0)</code>
</literallayout>
   <para>
    Bu işlev çok evreli yazılımlar için iptal noktasıdır. Eğer <code>wait</code> çağrıldığında bir evre bazı kaynakları (bellek, dosya tanıtıcısı, semafor veya herhangi bir öz kaynak) tahsis ederse bu sorun olur. Evre iptal edilirse bu kaynaklar yazılım sonlanıncaya kadar tahsisli durumda kalır. Bundan kaçınmak için <code>wait</code>'e yapılan çağrılar iptal işleyicileri kullanılarak korunmalıdır.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-wait4"><primary>wait4</primary></indexterm>
   <csproto type="işlev">
    <csname><type>pid_t</type><function>wait4</function></csname>
    <csparam><type>pid_t</type><parameter>pid</parameter></csparam>
    <csparam><ptr>int</ptr><parameter>status-ptr</parameter></csparam>
    <csparam><type>int</type><parameter>options</parameter></csparam>
    <csparam><ptr>struct&nbsp;rusage</ptr><parameter>usage</parameter></csparam>
   </csproto>
   <header>&sys-wait.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <parameter>usage</parameter> boş gösterici ise, <code>wait4</code> işlevi <code>waitpid (<parameter>pid</parameter>, <parameter>status-ptr</parameter>, <parameter>options</parameter>)</code>  ile eşdeğerdir.
   </para>
   <para>
    <parameter>usage</parameter> boş gösterici değilse, <code>wait4</code> işlevi *<parameter>usage</parameter> içinde alt sürecin kullanım şekillerini saklar (alt süreç durduysa değil, yalnızca sonlandıysa).  Bkz. <xref linkend="glibc-Resource-Usage"/>.
   </para>
   <para>
    Bu işlev BSD oluşumudur.
   </para>
  </csynopsis>
  <example>
   <para>
    Bu örnekte sonlandırılmış bütün alt süreçlerin durumunu beklemeden almak için <function>waitpid</function> işlevinin kullanımını gösterilmiştir. Bu işlev, en azından bir alt sürecin sonlandırılması gerektiğini belirten bir sinyal olan, <varname>SIGCHLD</varname> için bir işleyici olarak tasarlanmıştır.
   </para>
   <screen>void
sigchld_handler (int signum)
{
  int pid, status, serrno;
  serrno = errno;
  while (1)
    {
      pid = waitpid (WAIT_ANY, &amp;status, WNOHANG);
      if (pid &lt; 0)
        {
          perror ("waitpid");
          break;
        }
      if (pid == 0)
        break;
      notice_termination (pid, status);
    }
  errno = serrno;
}
</screen>
  </example>
 </chapter>
 <chapter xml:id="glibc-Process-Completion-Status">
  <title>Süreç Tamamlanma Durumu</title>
  <titleabbrev>Alt süreçten dönen durum değeri nasıl yorumlanır.</titleabbrev>
  <para>
   Eğer alt sürecin <link linkend="glibc-Program-Termination">çıkış durum değeri</link> sıfırsa, o zaman <function>waitpid</function> veya <function>wait</function> ile bildirilen durum değeri de sıfırdır. Aşağıdaki makrolar kullanılarak dönen durum değerlerinde kodlanmış diğer türlerdeki bilgiler sınanabilir. Bu makrolar &sys-wait.h; başlık dosyası içinde tanımlıdır.
   <indexterm linkend="glibc-pg"><primary>sys/wait.h</primary></indexterm>
  </para>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-WIFEXITED"><primary>WIFEXITED</primary></indexterm>
   <csproto type="makro">
    <csname><type>int</type><function>WIFEXITED</function></csname>
    <csparam><ptr>int</ptr><parameter>status</parameter></csparam>
   </csproto>
   <header>&sys-wait.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    Bu makro alt süreç normal olarak <function>exit</function> veya <function>_exit</function> ile sonlandırılmışsa sıfırdan farklı bir değer döndürür.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-WEXITSTATUS"><primary>WEXITSTATUS</primary></indexterm>
   <csproto type="makro">
    <csname><type>int</type><function>WEXITSTATUS</function></csname>
    <csparam><ptr>int</ptr><parameter>status</parameter></csparam>
   </csproto>
   <header>&sys-wait.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    Eğer <function>WIFEXITED</function> makrosu <parameter>status</parameter> için doğruysa, bu makro, alt süreçten <link linkend="glibc-Exit-Status">çıkış değerinin</link> düşük sıralı 8 bitini döndürür.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-WIFSIGNALED"><primary>WIFSIGNALED</primary></indexterm>
   <csproto type="makro">
    <csname><type>int</type><function>WIFSIGNALED</function></csname>
    <csparam><ptr>int</ptr><parameter>status</parameter></csparam>
   </csproto>
   <header>&sys-wait.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    Bu makro alt süreç işlenemeyen bir sinyal aldıysa ve sonlandıysa sıfırdan farklı bir değer döndürür. Bkz. <xref linkend="glibc-Signal-Handling"/>.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-WTERMSIG"><primary>WTERMSIG</primary></indexterm>
   <csproto type="makro">
    <csname><type>int</type><function>WTERMSIG</function></csname>
    <csparam><ptr>int</ptr><parameter>status</parameter></csparam>
   </csproto>
   <header>&sys-wait.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    Eğer <function>WIFSIGNALED</function> makrosu <parameter>status</parameter> için doğruysa, bu makro alt süreci sonlandıran sinyalin sinyal numarasını döndürür.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-WCOREDUMP"><primary>WCOREDUMP</primary></indexterm>
   <csproto type="makro">
    <csname><type>int</type><function>WCOREDUMP</function></csname>
    <csparam><ptr>int</ptr><parameter>status</parameter></csparam>
   </csproto>
   <header>&sys-wait.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    Bu makro alt süreç sonlandıysa ve bir çekirdek dökümü ürettiyse sıfırdan farklı bir değer döndürür.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-WIFSTOPPED"><primary>WIFSTOPPED</primary></indexterm>
   <csproto type="makro">
    <csname><type>int</type><function>WIFSTOPPED</function></csname>
    <csparam><ptr>int</ptr><parameter>status</parameter></csparam>
   </csproto>
   <header>&sys-wait.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    Bu makro alt süreç durduysa sıfırdan farklı bir değer döndürür.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-WSTOPSIG"><primary>WSTOPSIG</primary></indexterm>
   <csproto type="makro">
    <csname><type>int</type><function>WSTOPSIG</function></csname>
    <csparam><ptr>int</ptr><parameter>status</parameter></csparam>
   </csproto>
   <header>&sys-wait.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    Eğer <function>WIFSTOPPED</function> makrosu <parameter>status</parameter> için doğruysa, bu makro alt sürecin durmasına neden olan sinyalin sinyal numarasını döndürür.
   </para>
  </csynopsis>
 </chapter>
 <chapter xml:id="glibc-BSD-Wait-Functions">
  <title>BSD Süreç Bekletme İşlevleri</title>
  <titleabbrev>Geriye dönük uyumluluk için bazı işlevler.</titleabbrev>
  <para>
   <indexterm linkend="glibc-pg"><primary>sys/wait.h</primary></indexterm>
   &glibc;, BSD ile uyumluluk için <function>wait3</function> işlevini de sağlar. Bu işlev &sys-wait.h; başlık dosyasında bildirilmiştir. Daha esnek olan <function>wait4</function> işlevininin öncülüdür. <function>wait3</function> işlevi artık kullanılmamaktadır.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-wait3"><primary>wait3</primary></indexterm>
   <csproto type="işlev">
    <csname><type>pid_t</type><function>wait3</function></csname>
    <csparam><ptr>int</ptr><parameter>status-ptr</parameter></csparam>
    <csparam><type>int</type><parameter>options</parameter></csparam>
    <csparam><ptr>struct&nbsp;rusage</ptr><parameter>usage</parameter></csparam>
   </csproto>
   <header>&sys-wait.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    Eğer <parameter>usage</parameter> boş gösterici ise, <code>wait3</code> işlevi <code>waitpid (-1, <parameter>status-ptr</parameter>, <parameter>options</parameter>)</code> işlevinin eşdeğeridir.
   </para>
   <para>
    Eğer <parameter>usage</parameter> boş gösterici değilse, <code>wait3</code> alt sürecin kullanım şekillerini *<parameter>usage</parameter> içinde saklar (eğer alt süreç sonlandıysa; durduysa değil). Bkz. <xref linkend="glibc-Resource-Usage"/>.
   </para>
  </csynopsis>
 </chapter>
 <chapter xml:id="glibc-Process-Creation-Example">
  <title>Süreç Oluşturma Örneği</title>
  <titleabbrev>Tam Örnek.</titleabbrev>
  <para>
   Burada yerleşik <function>system</function> işlevine benzer örnek bir yazılım bulunmaktadır. Kendi <replaceable>command</replaceable> bağımsız değişkenini ‘<code>sh -c </code><replaceable>command</replaceable>’ komutunun eşdeğerini kullanarak çalıştırır.
  </para>
  <screen>#include &lt;stddef.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/wait.h&gt;

/* <replaceable>Komutu bu kabukta çalıştır.</replaceable>  */
#define SHELL "/bin/sh"

int
my_system (const char *command)
{
  int status;
  pid_t pid;

  pid = fork ();
  if (pid == 0)
    {
      /* <replaceable>Bu alt süreçtir.  Kabuk komutunu çalıştırır.</replaceable> */
      execl (SHELL, SHELL, "-c", command, NULL);
      _exit (EXIT_FAILURE);
    }
  else if (pid &lt; 0)
    /* <replaceable>Çatallama başarılamadı. Başarısızlığı bildir.</replaceable>  */
    status = -1;
  else
    /* <replaceable>Bu üst süreçtir.  Bitirmek için alt süreci bekle.</replaceable>  */
    if (waitpid (pid, &amp;status, 0) != pid)
      status = -1;
  return status;
}
</screen>
  <para>
   Bu örnekte dikkat edilmesi gereken birkaç nokta var.
  </para>
  <para>
   Yazılıma sağlanan ilk <parameter>argv</parameter> bağımsız değişkeninin çalıştırılan yazılımın adı olduğu unutulmamalıdır. Bu nedenle, <function>execl</function> çağrısında, <command>SHELL</command> bir kere çalıştırılacak yazılım ismini sağlamak için, bir kere de <code>argv[0]</code>'a değer sağlamak için kullanılmıştır.
  </para>
  <para>
   Alt süreçteki <function>execl</function> çağrısı başarılıysa değer döndürmez. Başarısız olursa, alt sürecin sonlanması için bir şeyler yapılması gerekir. Sadece <code>return</code> ile kötü durum kodu döndürülmesi, özgün yazılımı çalıştıran iki süreci bırakabilir. Bunun yerine, doğru davranış üst sürece alt süreç ile ilgili başarısızlığın bildirilmesidir.
  </para>
  <para>
   Bunu başarmak için <function>_exit</function> işlevi çağrılır. <function>_exit</function> işlevini <function>exit</function> yerine kullanma nedeni <varname>stdout</varname> gibi tamamen tamponlanmış akımları boşaltmanın önüne geçmektir. Bu akımların tamponları büyük olasılıkla üst süreçten <function>fork</function> ile kopyalanmış veri içerir, sonunda bu veri üst süreç tarafından çıktı alınır. Alt süreçte <function>exit</function> çağrısı verinin iki kez çıktı vermesine neden olabilir. Bkz <xref linkend="glibc-Termination-Internals"/>.
  </para>
 </chapter>
</part>
