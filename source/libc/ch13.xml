<?xml version="1.0" encoding="UTF-8"?>
<!-- ********************************************************************
     $Id: ch13.xml,v 1.2 2002/12/20 22:29:48 nilgun Exp $
******************************************************************** -->
<part id="glibc-Low-Level-I-O">
  <title>Düşük Seviyeli Girdi ve Çıktı</title>
  <titleabbrev>Düşük seviyeli, daha az taşınabilir G/Ç.</titleabbrev>
  <partintro><para>
Bu oylumda dosya tanıtıcıları üzerinde düşük seviyeli girdi ve çıktı işlemlerini gerçekleştiren işlevlerden bahsedilecektir. Bu işlevler <xref linkend="glibc-I-O-on-Streams"/> bölümünde açıklanan daha yüksek seviyeli G/Ç işlemleri ile ilgili ilkeller ile akımlarda eşdeğeri olmayan düşük seviyeli denetim işlemlerini gerçekleştiren işlevlerdir.
  </para><para>
Akım seviyesindeki G/Ç daha esnek ve daha kullanışlıdır; bununla birlikte, yazılımcılar gerektiğinde dosya tanıtıcı seviyesindeki işlevleri de kullanırlar. Bunların kullanım sebepleri genellikle şunlardır:
  </para><para><itemizedlist><listitem>
İkilik dosyaları büyük tomarlar halinde okumak için.
    </listitem><listitem>
Dosyanın tamamını çözümlemek amacıyla <literal>core</literal> dosyasına okumak için.
    </listitem><listitem>
Sadece dosya tanıtıcıları ile yapılabilen veri aktarımı işlemlerini gerçekleştirmek için. (Bir akıma karşılık olan tanıtıcıyı <command>fileno</command> kullanarak alabilirsiniz.)
    </listitem><listitem>
Tanıtıcıları alt süreçlere aktarmak için. (Bir alt süreç bir akımı miras alamadığından bir tanıtıcıyı miras alıp onu kendi akımını oluşturmak için kullanır.)
    </listitem></itemizedlist></para></partintro>
  <chapter id="glibc-Opening-and-Closing-Files">
    <title>Dosyaların Açılması ve Kapatılması</title>
    <titleabbrev>Dosya tanıtıcılarının açılması ve kapatılması.</titleabbrev>
    <para>
<indexterm scope="glibc-cp"><primary>dosya tanıtıcılar</primary><secondary>açılması</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>dosya tanıtıcılar</primary><secondary>kapatılması</secondary></indexterm>
Bu kısımda dosya tanıtıcılar kullanılarak dosyaların açılması ve kapatılması için kullanılan ilkeller açıklanacaktır. <command>open</command> ve <command>creat</command> işlevleri <filename>fcntl.h</filename> dosyasında bildirilmişken <command>close</command> işlevi <filename>unistd.h</filename> dosyasında bildirilmiştir.
<indexterm scope="glibc-pg"><primary>unistd.h</primary></indexterm>
<indexterm scope="glibc-pg"><primary>fcntl.h</primary></indexterm>
  </para><para id="glibc-open">
<indexterm scope="glibc-fn"><primary>open</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>open</command></funcdef>
<paramdef>(const char *<varname>dosyaismi</varname>,
 int         <varname>seçenekler</varname>[, mode_t <varname>kip</varname>])</paramdef>
</funcprototype><funcdescr><para>
<command>open</command> işlevi, <varname>dosyaismi</varname> isimli dosya için bir dosya tanıtıcı oluşturur ve bunu döndürür. İlk olarak dosya konum göstergesi dosyanın başlangıcındadır. <varname>kip</varname> argümanı sadece dosya oluşturulurken kullanılır, ancak herhangi bir durumda argümanın bir zararı yoktur.
   </para><para>
<varname>seçenekler</varname> argümanı dosyanın nasıl açılacağını belirler. Bu bir bit maskesidir ve ilgili parametreleri bit bit veyalayarak (C'de <command>|</command> işleci ile) değer oluşturabilirsiniz. Kullanılabilecek parametreleri <xref linkend="glibc-File-Status-Flags"/> bölümünde bulabilirsiniz.
   </para><para>
<command>open</command> işlevinin normal dönüş değeri negatif olmayan bir tamsayı olarak dosya tanıtıcısıdır. Bir hata durumunda <command>-1</command> değeri döner. Olağan <link linkend="glibc-File-Name-Errors">dosya ismi hatalarına</link> ek olarak aşağıdaki <command>errno</command> hata durumları bu işlev için tanımlanmıştır:
   </para><para><variablelist><varlistentry>
   <term><literal>EACCES</literal></term><listitem><para>
Dosya var ancak <varname>seçenekler</varname> argümanında istendiği gibi okunabilir/yazılabilir değil; dosya yok, dizine de yazılamadığından dosya oluşturulamıyor.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>EEXIST</literal></term><listitem><para>
<command>O_CREAT</command> ve <command>O_EXCL</command> ikisi de belirtilmiş ve isimli dosya zaten var.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>EINTR</literal></term><listitem><para>
<command>open</command> işlemi bir sinyal tarafından durduruldu. Bkz. <xref linkend="glibc-Interrupted-Primitives"/>.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>EISDIR</literal></term><listitem><para>
<varname>seçenekler</varname> argümanında yazma erişimi belirtilmiş ve dosya bir dizin.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>EMFILE</literal></term><listitem><para>
Sürecin çok fazla açık dosyası var. Dosya tanıtıcılarının azami sayısı <command>RLIMIT_NOFILE</command> özkaynak sınırı tarafından denetlenir; bkz. <xref linkend="glibc-Limits-on-Resources"/>.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>ENFILE</literal></term><listitem><para>
Dizini içeren sistemin tamamı ya da muhtemelen dosya sistemi, bu anda hiçbir ek açık dosyayı destekleyemiyor. (Böyle bir sorun GNU sisteminde asla olmaz.)
      </para></listitem></varlistentry><varlistentry>
      <term><literal>ENOENT</literal></term><listitem><para>
İsimli dosya yok ve <command>O_CREAT</command> belirtilmemiş.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>ENOSPC</literal></term><listitem><para>
Yeni dosyayı içerecek dizin ya da dosya sistemi genişletilemiyor çünkü diskte yer yok.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>ENXIO</literal></term><listitem><para>
<command>O_NONBLOCK</command> ve <command>O_WRONLY</command> ikisi de <varname>seçenekler</varname> argümanında belirtilmiş ve okumak için dosya açmış bir süreç yok.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>EROFS</literal></term><listitem><para>
Dosya bir salt okunur dosya istemi üzerinde ve <varname>seçenekler</varname> argümanında <command>O_WRONLY</command>, <command>O_RDWR</command> ve <command>O_TRUNC</command>'dan biri belirtilmiş; veya <command>O_CREAT</command> belirtilmiş ve dosya mevcut değil.
      </para></listitem></varlistentry></variablelist>
    </para><para>
Bir 32 bitlik makinede kaynaklar <command>_FILE_OFFSET_BITS == 64</command> ile dönüştürülürse, <command>open</command> işlevi, 2^63 baytlık ve -2^63 ile 2^63 arasındaki konum sınırlı dosyalarda kullanılan dosya işleme işlevlerini etkinleştiren büyük dosya kipinde açılmış bir dosya tanıtıcı ile döner. Bu, tüm düşük seviyeli dosya işleme işlevleri büyük dosya kipindeki eşdeğerleri ile değiştirilerek kullanıcı bakımından şeffaf olarak yapılır.
   </para><para>
Bu işlev çok evreli yazılımlarda bir iptal noktasıdır. <command>open</command> çağrısı sırasında evre bazı özkaynakları (bellek, dosya tanıtıcı, semafor, vb.) ayırdığında bu bir sorun olur. Evre tam bu anda bir iptal alırsa ayrılan özkaynaklar yazılım sonlanana kadar ayrılmış olarak kalır. Bu tür <command>open</command> çağrılarından kaçınmak için iptal eylemcileri kullanılarak korunulmalıdır.
   </para><para>
<command>open</command> işlevi, akımları oluşturan <command>fopen</command> ve <command>freopen</command> işlevlerinin düşük seviyedeki karşılığıdır.
</para></funcdescr></funcsynopsis></para><para id="glibc-open64">
<indexterm scope="glibc-fn"><primary>open64</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>open64</command></funcdef>
<paramdef>(const char *<varname>dosyaismi</varname>,
 int         <varname>seçenekler</varname>[, mode_t <varname>kip</varname>])</paramdef>
</funcprototype><funcdescr><para>
Bu işlev <command>open</command> işlevine benzer.  <varname>dosyaismi</varname> isimli dosyaya erişim için kullanılabilen bir dosya tanıtıcı ile döner. Tek farkı bu işlevin 32 bitlik sistemlerde dosyayı büyük dosya (dosya uzunluğunun ve konum değerlerinin 63 bit genişlikte olduğu dosyalar) kipinde açmasıdır.
   </para><para>
Kaynakların <command>_FILE_OFFSET_BITS == 64</command> ile dönüştürülürdüğü durumda, bu işlev aslında <command>open</command> ismi altında kullanılır. Yani 64 bitlik yeni, genişletilmiş arayüz eski arayüzle şeffaf olarak değiştirilir.
</para></funcdescr></funcsynopsis></para><para id="glibc-creat">
<indexterm scope="glibc-fn"><primary>creat</primary></indexterm>
<funcsynopsis><funcprototype role="artık kullanılmayan işlev">
<funcdef>int <command>creat</command></funcdef>
<paramdef>(const char *<varname>dosyaismi</varname>,
 mode_t      <varname>kip</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev atıl olmuştur.
   </para><para>
<screen>creat (<varname>dosyaismi</varname>, <varname>kip</varname>)</screen>
   </para><para>
gibi bir çağrı:
   </para><para>
<screen>
open (<varname>dosyaismi</varname>, O_WRONLY | O_CREAT | O_TRUNC, <varname>kip</varname>)
</screen></para><para>çağrısına eşdeğerdir.</para><para>
Bir 32 bitlik makinede kaynaklar <command>_FILE_OFFSET_BITS == 64</command> ile dönüştürülürse, <command>creat</command> işlevi, 2^63 baytlık ve -2^63 ile 2^63 arasındaki konum sınırlı dosyalarda kullanılan dosya işleme işlevlerini etkinleştiren büyük dosya kipinde açılmış bir dosya tanıtıcı ile döner. Bu, tüm düşük seviyeli dosya işleme işlevleri büyük dosya kipindeki eşdeğerleri ile değiştirilerek kullanıcı bakımından şeffaf olarak yapılır.
</para></funcdescr></funcsynopsis></para><para id="glibc-creat64">
<indexterm scope="glibc-fn"><primary>creat64</primary></indexterm>
<funcsynopsis><funcprototype role="artık kullanılmayan işlev">
<funcdef>int <command>creat64</command></funcdef>
<paramdef>(const char *<varname>dosyaismi</varname>,
 mode_t      <varname>kip</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev <command>creat</command> işlevine benzer.  <varname>dosyaismi</varname> isimli dosyaya erişim için kullanılabilen bir dosya tanıtıcı ile döner. Tek farkı bu işlevin 32 bitlik sistemlerde dosyayı büyük dosya (dosya uzunluğunun ve konum değerlerinin 31 bit genişlikte olduğu dosyalar) kipinde açmasıdır.
   </para><para>
Bu dosya tanıtıcıları <command>*64</command> biçiminde isimlendirilmiş işlevler (<command>read64</command> gibi) dışında normal dosya işlemlerinde kullanılmamalıdır.
   </para><para>
Kaynakların <command>_FILE_OFFSET_BITS == 64</command> ile dönüştürülürdüğü durumda, bu işlev aslında <command>creat</command> ismi altında kullanılır. Yani 64 bitlik yeni, genişletilmiş arayüz eski arayüzle şeffaf olarak değiştirilir.
</para></funcdescr></funcsynopsis></para><para id="glibc-close">
<indexterm scope="glibc-fn"><primary>close</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>close</command></funcdef>
<paramdef>(int <varname>dosyatanıtıcı</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev dosya tanıtıcısı <varname>dosyatanıtıcı</varname> ile belirtilen dosyayı kapatır. Bir dosyanın kapatılma işlemi şöyle yürütülür:
   </para><para><itemizedlist><listitem>
Dosya tanıtıcı serbest bırakılır.
     </listitem><listitem>
Dosyadaki süreç tarafından sahiplenilmiş kayıt kilitleri kaldırılır.
     </listitem><listitem>
Bir boru ya da FIFO ile ilişkili tüm dosya tanıtıcılar kapatılır, okunmamış veri varsa iptal edilir.
     </listitem></itemizedlist>
   </para><para>
Bu işlev çok evreli yazılımlarda bir iptal noktasıdır. <command>close</command> çağrısı sırasında evre bazı özkaynakları (bellek, dosya tanıtıcı, semafor, vb.) ayırdığında bu bir sorun olur. Evre tam bu anda bir iptal alırsa ayrılan özkaynaklar yazılım sonlanana kadar ayrılmış olarak kalır. Bu tür <command>close</command> çağrılarından kaçınmak için iptal eylemcileri kullanılarak korunulmalıdır.
   </para><para>
<command>close</command> işlevinin normal dönüş değeri sıfırdır. Bir hata durumunda <command>-1</command> değeri döner. Aşağıdaki <command>errno</command> hata durumları bu işlev için tanımlanmıştır:
   </para><para><variablelist><varlistentry>
   <term><literal>EBADF</literal></term><listitem><para>
<varname>dosyatanıtıcı</varname> geçerli bir dosya tanıtıcı değil.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>EINTR</literal></term><listitem><para>
Çağrı bir sinyalle durduruldu Bkz. <xref linkend="glibc-Interrupted-Primitives"/>. <command>EINTR</command> hatasının düzgün olarak elde edilişine bir örnek:
      </para><para>
<screen>TEMP_FAILURE_RETRY (close (desc));
</screen>
    </para></listitem></varlistentry><varlistentry>
    <term><command>ENOSPC</command></term>
    </varlistentry><varlistentry><term><command>EIO</command></term>
    </varlistentry><varlistentry><term><command>EDQUOT</command></term>
    <listitem><para>
Dosyaya NFS üzerinden erişilirken, <command>write</command> işlevinden kaynaklanan bu hatalar kimi zaman bir <command>close</command> çağrısına kadar saptanamaz. Bunun ne anlama geldiği <xref linkend="glibc-I-O-Primitives"/> bölümünde açıklanmıştır.
      </para></listitem></varlistentry></variablelist>
    </para><para>
Ayrı bir <command>close64</command> işlevinin bulunmadığını aklınızdan çıkarmayın. Çünkü bu işlev dosya kipine bağımlı olmadığı gibi bunu saptamaya da çalışmaz. Bunu çekirdek bilir ve bir <command>close</command> çağrısı olduğunda gerekeni yapar.
</para></funcdescr></funcsynopsis></para><para>
Bir akımı kapatırken, <command>fclose</command> (bkz. <xref linkend="glibc-Closing-Streams"/>) işlevini kullanmalısınız, işlevin düşük seviye eşdeğeri olan <command>close</command> ile kapatmaya çalışmayın. <command>fclose</command> işlevi tamponda bir veri varsa bunu boşaltır ve akım nesnesini kapandığını belirtecek şekilde günceller.
   </para></chapter>
  <chapter id="glibc-I-O-Primitives">
    <title>Girdi ve Çıktı İlkelleri</title>
    <titleabbrev>Verinin okunması ve yazılması.</titleabbrev>
    <para>
Bu kısımda dosya tanıtıcılar üzerinde düşük seviyeli girdi ve çıktı işlemlerini gerçekleştiren <command>read</command>, <command>write</command> ve <command>lseek</command> işlevlerinden bahsedilecektir. Bu işlevler <filename>unistd.h</filename> başlık dosyasında bildirilmiştir.
<indexterm scope="glibc-pg"><primary>unistd.h</primary></indexterm>
   </para><para id="glibc-ssize_t">
<indexterm scope="glibc-tp"><primary>ssize_t</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü">
<funcdef><command>ssize_t</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu veri türü tek bir işlem olarak okunup yazılabilen veri parçalarınını uzunluğunu göstermekte kullanılır. <command>size_t</command> türüne benzemekle birlikte bu bir işaretsiz bir türdür.
</para></funcdescr></funcsynopsis></para><para id="glibc-read">
<indexterm scope="glibc-cp"><primary>dosya tanıtıcılar</primary><secondary>bir dosyanın okunması</secondary></indexterm>
<indexterm scope="glibc-fn"><primary>read</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>ssize_t <command>read</command></funcdef>
<paramdef>(int    <varname>dosyatanıtıcı</varname>,
 void  *<varname>tampon</varname>,
 size_t <varname>boyut</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>read</command> işlevi <varname>dosyatanıtıcı</varname> tanıtıcılı dosyadan <varname>boyut</varname> baytlık okuma yapar ve sonucu <varname>tampon</varname> içinde döndürür. (Bunun bir karakter dizgesi olması gerekmediği gibi sonlandırıcı boş karakter de eklenmez.)
   </para><para>
<indexterm scope="glibc-cp"><primary>dosya tanıtıcılar</primary><secondary>dosyasonu</secondary></indexterm>
İşlevin normal dönüş değeri okunan baytların sayısıdır. Bu <varname>boyut</varname> bayttan küçük olabilir; örneğin dosyada kalan baytlar <varname>boyut</varname> bayttan az olabilir ya da o an için bu dosyada bu kadar bayt olmayabilir. Davranış aslında dosyanın çeşidine bağlıdır. <varname>boyut</varname> bayttan daha az verinin okunmuş olmasının bir hata olarak değerlendirilmediğini unutmayın.
   </para><para>
Sıfır dönüş değeri dosyasonunu belirtir (<varname>boyut</varname> argümanının sıfır olduğu durum dışında). Bu bir hata olarak sayılmaz. Dosya sonunda <command>read</command> çağrısı yapmayı sürdürürseniz, işlev de başka bir şey yapmadan sıfır döndürmeye devam eder.
   </para><para>
<command>read</command> çağrısı ile zaten tek bir karakter döndürüyorsanız dosya sonuna eriştiğinizde bunu anlayamayacaksınız. Ancak dosya sonunda, sonraki <command>read</command> çağrıları hep sıfır döndürecektir.
   </para><para>
Bir hata durumunda işlev <command>-1</command> ile döner. Aşağıdaki <command>errno</command> hata durumları bu işlev için tanımlanmıştır:
   </para><para><variablelist><varlistentry>
   <term><literal>EAGAIN</literal></term><listitem><para>
Normalde, bir girdi yoksa <command>read</command> girdi varolana kadar bekler. Fakat dosya için <command>O_NONBLOCK</command> seçeneği etkinse (bkz. <xref linkend="glibc-File-Status-Flags"/>), böyle bir durumda <command>read</command> hiç veri okumadan hemen döner ve bunu bu hatayla raporlar.
      </para><para>
<note><title>Uyumluluk Bilgisi</title><para>BSD Unix'lerin çoğu sürümü bunun için farklı bir hata kodu kullanır:  <command>EWOULDBLOCK</command>.  GNU kütüphanesinde <command>EWOULDBLOCK</command>, <command>EAGAIN</command> için bir takma addır, dolayısıyla hangi ismi kullandığınızın bir önemi yoktur. </para></note>
      </para><para>
Bazı sistemlerde, çekirdek kullanıcı sayfaları için yeterli fiziksel bellek bulamazsa, bir karakter özel dosyasından büyük miktarda veri okunması da <command>EAGAIN</command> hata koduna sebep olur. Bu, kullanıcı belleğine doğrudan bellek erişimi ile iletim yapan aygıtlarla sınırlıdır. Bunlar uçbirimleri kapsamaz, çünkü uçbirimler için çekirdek içinde daima ayrı tamponlar vardır. GNU kütüphanesinde böyle bir sorunla asla karşılaşmayacaksınız.
      </para><para>
<command>EAGAIN</command> ile sonuçlanabilecek bir durumda istenenden daha az bayt döndürerek <command>read</command> başarılı olabilir. Hemen ardından yapılan bir <command>read</command> çağrısı <command>EAGAIN</command> ile sonuçlanırdı.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>EBADF</literal></term><listitem><para>
<varname>dosyatanıtıcı</varname> argümanı geçerli bir dosya tanıtıcı değil ya da okumak için açılmamış
      </para></listitem></varlistentry><varlistentry>
      <term><literal>EINTR</literal></term><listitem><para>
<command>read</command> çağrısı girdi beklerken bir sinyal ile durduruldu. Bkz. <xref linkend="glibc-Interrupted-Primitives"/>.  Bir sinyalin <command>read</command> çağrısının <command>EINTR</command> döndürmesine sebep olması şart değildir; istenenden daha az bayt döndürerek <command>read</command> başarılı olabilir.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>EIO</literal></term><listitem><para>
Çoğu aygıt ve disk dosyası için bu hata kodu bir donanım hatasına işaret eder.
      </para><para>
<command>EIO</command> ayrıca, bir artalan süreci denetim uçbiriminden okuma yapmaya çalışırken ve sürecin bir <command>SIGTTIN</command> sinyali gönderilerek durdurulmasında normal eylemin çalışmaması durumunda oluşabilir. Bu <command>SIGTTIN</command> sinyalinin engellenmesi ya da yoksayılmasından kaynaklanabileceği gibi süreç grubunun öksüz kalması nedeniyle de olabilir. Sinyaller hakkında daha fazla bilgi almak için <xref linkend="glibc-Signal-Handling"/> bölümüne ve iş denetimi için <xref linkend="glibc-Job-Control"/> bölümüne bakabilirsiniz.
      </para></listitem></varlistentry><varlistentry>
      <term><command>EINVAL</command></term><listitem><para>
Bazı sistemlerde bir karakter veya blok aygıtından okuma yapılırken, konum ve boyut başlangıçları belli bir blok boyuna hizalanmalıdır. Bu hata başlangıçların gerektiği gibi hizalanmadığını belirtir.
      </para></listitem></varlistentry></variablelist>
    </para><para>
<command>read64</command> isminde bir işlevin olmadığını unutmayın. İşlev olası geniş dosya konumlarını işlemek ya da değiştirmek için bir işlem yapmadığından bu gerekli değidir. Çekirdek gerekeni kendi içinde hallettiğinden <command>read</command> işlevi her durumda kullanılabilir.
   </para><para>
Bu işlev çok evreli yazılımlarda bir iptal noktasıdır. <command>read</command> çağrısı sırasında evre bazı özkaynakları (bellek, dosya tanıtıcı, semafor, vb.) ayırdığında bu bir sorun olur. Evre tam bu anda bir iptal alırsa ayrılan özkaynaklar yazılım sonlanana kadar ayrılmış olarak kalır. Bu tür <command>read</command> çağrılarından kaçınmak için iptal eylemcileri kullanılarak korunulmalıdır.
   </para><para>
<command>read</command> işlevi, akımlardan okuma yapan <command>fgetc</command> gibi işlevlerin düşük seviyedeki karşılığıdır.
</para></funcdescr></funcsynopsis></para><para id="glibc-pread">
<indexterm scope="glibc-fn"><primary>pread</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>ssize_t <command>pread</command></funcdef>
<paramdef>(int    <varname>dosyatanıtıcı</varname>,
 void  *<varname>tampon</varname>,
 size_t <varname>boyut</varname>,
 off_t  <varname>konum</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>pread</command> işlevi ilk üç argümanının ve dönüş değeri ile hata durumlarının aynı olmasıyla <command>read</command> işlevine çok benzer.
   </para><para>
Fark dördüncü argümanda ve onun elde edilişindedir. Okuma işlemi <varname>dosyatanıtıcı</varname> dosya tanıtıcısının o anki konumundan değil, <varname>konum</varname> ile belirtilen konumdan başlar ve dosya tanıtıcısının konumu bu işlemden etkilenmez; değeri çağrı öncesindeki değerinde kalır.
   </para><para>
Kaynak dosyası <command>_FILE_OFFSET_BITS == 64</command> ile derlenmişse <command>pread</command> işlevi aslında 2^63 bayta kadar dosyalarla çalışabilen ve 64 bitlik <command>off_t</command> türünde olan <command>pread64</command> işlevi olur.
   </para><para>
<command>pread</command> işlevinin normal dönüş değeri okunan baytların sayısıdır. Hata durumunda <command>read</command> gibi <command>-1</command> ile döndüğü gibi hata kodları aşağıdakiler dışında aynıdır:
   </para><para><variablelist><varlistentry>
   <term><literal>EINVAL</literal></term><listitem><para>
<varname>konum</varname> değeri negatif dolayısıyla kuraldışı
      </para></listitem></varlistentry><varlistentry>
      <term><literal>ESPIPE</literal></term><listitem><para>
<varname>dosyatanıtıcı</varname> bir boru ya da FIFO ile ilişkili ve bu aygıtlar dosya içinde konum belirtilmesine izin vermez.
      </para></listitem></varlistentry></variablelist>
    </para><para>
İşlev Unix Tek Belirtiminin 2. sürümünde tanımlı bir oluşumdur.
</para></funcdescr></funcsynopsis></para><para id="glibc-pread64">
<indexterm scope="glibc-fn"><primary>pread64</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>ssize_t <command>pread64</command></funcdef>
<paramdef>(int      <varname>dosyatanıtıcı</varname>,
 void    *<varname>tampon</varname>,
 size_t   <varname>boyut</varname>,
 off64_t  <varname>konum</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev <command>pread</command> işlevinin benzeridir.  Farkı <varname>konum</varname> parametresinin  2^31 bayta kadar dosyalar için olan <command>off_t</command> türünde değil, 2^63 bayta kadar dosyalar için olan <command>off64_t</command> türünde olmasıdır. Bu işlev için kullanılan <varname>dosyatanıtıcı</varname> tanıtıcısının <command>open64</command> ile açılması önemlidir. Aksi takdirde, küçük dosya kipinde açılmış dosya tanıtıcılarla <command>off64_t</command> türündeki dosya konumları hatalara yol açacaktır.
   </para><para>
Kaynak dosyası <command>_FILE_OFFSET_BITS == 64</command> ile derlenmişse 32 bitlik sistemlerde bu işleve <command>pread</command> ismiyle erişilir. Yani 32 bitlik arayüz 64 bitlik olanıyla değiştirilir.
</para></funcdescr></funcsynopsis></para><para id="glibc-write">
<indexterm scope="glibc-cp"><primary>dosya tanıtıcılar</primary><secondary>bir dosyaya yazmak</secondary></indexterm>
<indexterm scope="glibc-fn"><primary>write</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>ssize_t <command>write</command></funcdef>
<paramdef>(int    <varname>dosyatanıtıcı</varname>,
 void  *<varname>tampon</varname>,
 size_t <varname>boyut</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>write</command> işlevi <varname>dosyatanıtıcı</varname> tanıtıcılı dosyaya
<varname>tampon</varname> tamponundaki <varname>boyut</varname> baytı yazar. <varname>tampon</varname> içindeki veri bir karakter dizgesi olması gerekmediği gibi bir boş karakter de sıradan bir karakter olarak ele alınır.
   </para><para>
İşlevin normal dönüş değeri yazılabilen baytların sayısıdır. Bu <varname>boyut</varname> sayıda olabileceği halde hep daha küçük olur. Yazılımınızda işlevi, tüm veriyi yazana kadar tekrarlanan <command>write</command> çağrıları şeklinde bir döngü içinde kullanmalısınız.
   </para><para>
<command>write</command> döndükten hemen sonra kuyruklanan veri okunabilir. Bunun için verinin kalıcı bir saklama alanına yazılması şart değildir. Devam etmeden önce verinin kalıcı saklama alanına yazılmasını sağlamak için <command>fsync</command> kullanablirsiniz. (Yazma işlemini peşpeşe çağrılar şeklinde bir defada gerçekleştirip saklama alanına yazma işini sisteme bırakmak daha verimlidir. Normalde bu veri diske bir dakikadan daha geç yazılmaz.) Günümüz sistemlerinde <command>fdatasync</command> adında bir işlev daha vardır ve bununla dosya verisinin bütünlüğü garanti edilmiştir ve daha hızlıdır. Dosyayı  <command>O_FSYNC</command> kipinde açarsanız <command>write</command> çağrıları veri diske yazılmadan dönmeyecektir; bkz.  <xref linkend="glibc-Operating-Modes"/>.
   </para><para>
Hata durumunda işlev <command>-1</command> ile döner. Aşağıdaki <command>errno</command> hata durumları bu işlev için tanımlanmıştır:
   </para><para><variablelist><varlistentry>
   <term><literal>EAGAIN</literal></term><listitem><para>
Normalde, yazma işlemi tamamlanana kadar <command>write</command> dönmez. Fakat <command>O_NONBLOCK</command> seçeneği etkinse (bkz. <xref linkend="glibc-Control-Operations"/>), hiçbir veri yazılmadan işlev hemen bu hata durumu ile döner. Bu duruma bir örnek vermek gerekirse, sürecin bir STOP karakteri aldığında, akış denetimini destekleyen bir uçbirim aygıtına çıktının  yazılmasını engellemesi verilebilir.
      </para><para>
<note><title>Uyumluluk Bilgisi</title><para>BSD Unix'in çoğu sürümü bu hata kodu için farklı bir hata kodu kullanır: <command>EWOULDBLOCK</command>.  GNU kütüphanesinde <command>EWOULDBLOCK</command>, <command>EAGAIN</command> için bir takma addır, dolayısıyla hangi ismin kullanıldığının bir önemi yoktur.</para></note>
      </para><para>
Bazı sistemlerde, çekirdek kullanıcı sayfaları için yeterli fiziksel bellek bulamazsa, bir karakter özel dosyasına büyük miktarda veri yazılması da <command>EAGAIN</command> hata koduna sebep olur. Bu, kullanıcı belleğine doğrudan bellek erişimi ile iletim yapan aygıtlarla sınırlıdır. Bunlar uçbirimleri kapsamaz, çünkü uçbirimler için çekirdek içinde daima ayrı tamponlar vardır. GNU kütüphanesinde böyle bir sorunla asla karşılaşmayacaksınız.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>EBADF</literal></term><listitem><para>
<varname>dosyatanıtıcı</varname> argümanı geçerli bir dosya tanıtıcı değil ya da yazma amacıyla açılmamış
      </para></listitem></varlistentry><varlistentry>
      <term><literal>EFBIG</literal></term><listitem><para>
Dosya boyutu gerçeklemenin desteklediğinden büyük
      </para></listitem></varlistentry><varlistentry>
      <term><literal>EINTR</literal></term><listitem><para>
<command>write</command> işlemi tamamlanmadan önce bir sinyal tarafından durduruldu. Bir sinyal her zaman <command>write</command> işlevinin <command>EINTR</command> döndürmesine sebep olmaz; istenenden daha az baytı yazarak da işlev başarılı olabilir. Bkz. <xref linkend="glibc-Interrupted-Primitives"/>.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>EIO</literal></term><listitem><para>
Çoğu aygıt ve disk dosyası için bu hata kodu bir donanım hatasını işaret eder.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>ENOSPC</literal></term><listitem><para>
Aygıtın dosyası dolu.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>EPIPE</literal></term><listitem><para>
Bu hata bir süreç tarafından okumak için açılmamış bir boru ya da FIFO'ya yazmaya çalışırsanız oluşur. Bu oluştuğu zaman sürece bir <command>SIGPIPE</command> sinyali gönderilir; bkz. <xref linkend="glibc-Signal-Handling"/>.
      </para></listitem></varlistentry><varlistentry>
      <term><command>EINVAL</command></term><listitem><para>
Bazı sistemlerde bir karakter veya blok aygıtından okuma yapılırken, konum ve boyut başlangıçları belli bir blok boyuna hizalanmalıdır. Bu hata başlangıçların gerektiği gibi hizalanmadığını belirtir.
      </para></listitem></varlistentry></variablelist>
    </para><para>
<command>EINTR</command> başarısızlıklarından korunmak için bir düzenleme yapmadıkça,  her başarısız <command>write</command> çağrısından sonra <command>errno</command> değişkenine bakmalı ve bu <command>EINTR</command> hatası ise çağrıyı tekrarlamalısınız. Bkz. <xref linkend="glibc-Interrupted-Primitives"/>.  Bunu yapmanın kolay bir yolu <command>TEMP_FAILURE_RETRY</command> makrosunu kullanmaktır:
   </para><para>
<screen>
nbytes = TEMP_FAILURE_RETRY (write (desc, buffer, count));
</screen></para><para>
<command>write64</command> isminde bir işlevin olmadığını unutmayın. İşlev olası geniş dosya konumlarını işlemek ya da değiştirmek için bir işlem yapmadığından bu gerekli değidir. Çekirdek gerekeni kendi içinde hallettiğinden <command>write</command> işlevi her durumda kullanılabilir.
   </para><para>
Bu işlev çok evreli yazılımlarda bir iptal noktasıdır. <command>write</command> çağrısı sırasında evre bazı özkaynakları (bellek, dosya tanıtıcı, semafor, vb.) ayırdığında bu bir sorun olur. Evre tam bu anda bir iptal alırsa ayrılan özkaynaklar yazılım sonlanana kadar ayrılmış olarak kalır. Bu tür <command>write</command> çağrılarından kaçınmak için iptal eylemcileri kullanılarak korunulmalıdır.
   </para><para>
<command>write</command> işlevi, akımlardan okuma yapan <command>fputc</command> gibi işlevlerin düşük seviyedeki karşılığıdır.
</para></funcdescr></funcsynopsis></para><para id="glibc-pwrite">
<indexterm scope="glibc-fn"><primary>pwrite</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>ssize_t <command>pwrite</command></funcdef>
<paramdef>(int         <varname>dosyatanıtıcı</varname>,
 const void *<varname>tampon</varname>,
 size_t      <varname>boyut</varname>,
 off_t       <varname>konum</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>pwrite</command> işlevi ilk üç argümanının ve dönüş değeri ile hata durumlarının aynı olmasıyla <command>write</command> işlevine çok benzer.
   </para><para>
Fark dördüncü argümanda ve onun elde edilişindedir. Yazma işlemi <varname>dosyatanıtıcı</varname> dosya tanıtıcısının o anki konumundan değil, <varname>konum</varname> ile belirtilen konumdan başlar ve dosya tanıtıcısının konumu bu işlemden etkilenmez; değeri çağrı öncesindeki değerinde kalır.
   </para><para>
Kaynak dosyası <command>_FILE_OFFSET_BITS == 64</command> ile derlenmişse <command>pwrite</command> işlevi aslında 2^63 bayta kadar dosyalarla çalışabilen ve 64 bitlik <command>off_t</command> türünde olan <command>pwrite64</command> işlevi olur.
   </para><para>
<command>pwrite</command> işlevinin normal dönüş değeri yazılan baytların sayısıdır. Hata durumunda <command>write</command> gibi <command>-1</command> ile döndüğü gibi hata kodları aşağıdakiler dışında aynıdır:
   </para><para><variablelist><varlistentry>
   <term><literal>EINVAL</literal></term><listitem><para>
<varname>konum</varname> değeri negatif dolayısıyla kuraldışı
      </para></listitem></varlistentry><varlistentry>
      <term><literal>ESPIPE</literal></term><listitem><para>
<varname>dosyatanıtıcı</varname> bir boru ya da FIFO ile ilişkili ve bu aygıtlar dosya içinde konum belirtilmesine izin vermez.
      </para></listitem></varlistentry></variablelist>
    </para><para>
İşlev Unix Tek Belirtiminin 2. sürümünde tanımlı bir oluşumdur.
</para></funcdescr></funcsynopsis></para><para id="glibc-pwrite64">
<indexterm scope="glibc-fn"><primary>pwrite64</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>ssize_t <command>pwrite64</command></funcdef>
<paramdef>(int         <varname>dosyatanıtıcı</varname>,
 const void *<varname>tampon</varname>,
 size_t      <varname>boyut</varname>,
 off64_t     <varname>konum</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev <command>pwrite</command> işlevinin benzeridir.  Farkı <varname>konum</varname> parametresinin  2^31 bayta kadar dosyalar için olan <command>off_t</command> türünde değil, 2^63 bayta kadar dosyalar için olan <command>off64_t</command> türünde olmasıdır. Bu işlev için kullanılan <varname>dosyatanıtıcı</varname> tanıtıcısının <command>open64</command> ile açılması önemlidir. Aksi takdirde, küçük dosya kipinde açılmış dosya tanıtıcılarla <command>off64_t</command> türündeki dosya konumları hatalara yol açacaktır.
   </para><para>
Kaynak dosyası <command>_FILE_OFFSET_BITS == 64</command> ile derlenmişse 32 bitlik sistemlerde bu işleve <command>pwrite</command> ismiyle erişilir. Yani 32 bitlik arayüz 64 bitlik olanıyla değiştirilir.
  </para></funcdescr></funcsynopsis></para></chapter>
  <chapter id="glibc-File-Position-Primitive">
    <title>Dosya Konumu İlkeli</title>
    <titleabbrev>Bir tanıtıcının dosya konumunun belirtilmesi</titleabbrev>
    <para>
Bir akımın dosya konumunu <command>fseek</command> ile belirtiğiniz gibi, bir tanıtıcının dosya konumunu da <command>lseek</command> ile sonraki <command>read</command> veya <command>write</command> işlemleri için belirtebilirsiniz. Dosya konumlamanın ne olduğu ve daha fazlası için <xref linkend="glibc-File-Positioning"/> bölümüne bakabilirsiniz.
   </para><para>
Bir tanıtıcıdan o anki dosya konumunu okumak için<sbr/><command>lseek (<varname>tanıtıcı</varname>, 0, SEEK_CUR)</command> çağrısını kullanabilirsiniz.
   </para><para id="glibc-lseek">
<indexterm scope="glibc-cp"><primary>dosya tanıtıcılar</primary><secondary>dosyada konumlama</secondary></indexterm>
<indexterm scope="glibc-fn"><primary>lseek</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>off_t <command>lseek</command></funcdef>
<paramdef>(int   <varname>dosyatanıtıcı</varname>,
 off_t <varname>konum</varname>,
 int   <varname>nereye</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>lseek</command> işlevi <varname>dosyatanıtıcı</varname> tanıtıcısında dosya konumunu değiştirmek için kullanılır.
   </para><para>
<varname>nereye</varname> argümanı <command>fseek</command> işlevindeki gibi <varname>konum</varname>'un nasıl yorumlanacağını belirtir. Değeri <command>SEEK_SET</command>, <command>SEEK_CUR</command> veya <command>SEEK_END</command> sembolik sabitlerinden biri olabilir.
   </para><para><variablelist><varlistentry>
   <term><literal>SEEK_SET</literal></term><listitem><para>
<varname>nereye</varname> dosyanın başlangıcından itibaren karakter sayısını belirtir.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>SEEK_CUR</literal></term><listitem><para>
<varname>nereye</varname> o anki dosya konumundan itibaren karakter sayısını belirtir.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>SEEK_END</literal></term><listitem><para>
<varname>nereye</varname> dosya sonundan kaç karakter sayılacağını belirtir. Negatif bir değer dosya sonundan ileriye doğru, pozitif bir değer dosya sonundan geriye doğru karakter sayısıdır. Konumu sondan başa doğru belirtirseniz ve yazma yapıyorsanız, dosya, konuma kadar sıfırlarla doldurularak büyütülecektir.
      </para></listitem></varlistentry></variablelist>
    </para><para>
<command>lseek</command> işlevinin normal dönüş değeri sonuçlanan dosya başlangıcından itibaren karakter sayısı olarak dosya konumudur. Bu özelliğini, o anki dosya konumunu öğrenmek için <command>SEEK_CUR</command> ile kullanabilirsiniz.
   </para><para>
Dosyaya eklema yapmak isterseniz, dosya konumunu o anki dosya sonundan itibaren <command>SEEK_END</command> ile belirtmek yeterli olmaz. Siz dosya konumunu değiştirdikten sonra ancak yazmaya başlamadan önce başka bir süreç dosyaya bir miktar veri yazmış olabilir, dolayısıyla böyle bir konuma yapacağınız bir yazma işlemi mevcut verinin kaybına sebep olur. Bunun olmaması için <command>O_APPEND</command> işletim kipini kullanmalısınız; bkz. <xref linkend="glibc-Operating-Modes"/>.
   </para><para>
Dosya konumunu dosyanın o anki dosya sonundan başa doğru belirtebilirsiniz. Bu dosyanı kendisini uzatmaz; <command>lseek</command> dosyanın boyunu asla değiştirmez. Fakat aynı konuma daha sonra yapılan çıktılama dosyayı uzatır.  Dosyanın önceki sonu ile yeni konum arası sıfırlarla doldurulur. Bu yolla uzatılan dosyada sıfırlardan oluşan bir "delik" oluşur, disk üzerinde yer ayırma yapılmaz, bu durumda dosya göründüğünden daha az alanı kapsar; bu durumdaki bir dosyaya "seyrek dosya" (sparse file) denir.
<indexterm scope="glibc-cp"><primary>dosyalar</primary><secondary>seyrek</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>dosyalar</primary><secondary>delikler</secondary></indexterm>
Dosya konumu değiştirilemezse ya da işlem bir şekilde geçersiz olmuşsa, işlev <command>-1</command> ile döner. Aşağıdaki <command>errno</command> hata durmları bu işlev için tanımlanmıştır:
   </para><para><variablelist><varlistentry>
   <term><literal>EBADF</literal></term><listitem><para>
<varname>dosyatanıtıcı</varname> geçerli bir dosya tanıtıcı değil
      </para></listitem></varlistentry><varlistentry>
      <term><literal>EINVAL</literal></term><listitem><para>
<varname>nereye</varname> argümanının değeri geçersiz ya da sonuçlanan dosya konumu geçersiz. Bir dosya konumu geçersiz.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>ESPIPE</literal></term><listitem><para>
<varname>dosyatanıtıcı</varname>, bir boru, FIFO ya da uçbirim gibi dosya konumlamasına izin verilmeyen bir nesneye karşılık olduğundan konunlama yapılamıyor. (POSIX.1 bu hatayı sadece borular ve FIFO'lar için belirtir, ancak GNU sisteminde konumlama yapılamayan her nesne için daima <command>ESPIPE</command> hatasını alırsınız.)
      </para></listitem></varlistentry></variablelist></para><para>
Kaynak dosyası <command>_FILE_OFFSET_BITS == 64</command> ile derlenmişse <command>lseek</command> işlevi aslında 2^63 bayta kadar dosyalarla çalışabilen ve 64 bitlik <command>off_t</command> türünde olan <command>lseek64</command> işlevi olur.
   </para><para>
Bu işlev çok evreli yazılımlarda bir iptal noktasıdır. <command>lseek</command> çağrısı sırasında evre bazı özkaynakları (bellek, dosya tanıtıcı, semafor, vb.) ayırdığında bu bir sorun olur. Evre tam bu anda bir iptal alırsa ayrılan özkaynaklar yazılım sonlanana kadar ayrılmış olarak kalır. Bu tür <command>lseek</command> çağrılarından kaçınmak için iptal eylemcileri kullanılarak korunulmalıdır.
   </para><para>
<command>lseek</command> işlevi, akımlarda konumlama yapan <command>fseek</command>, <command>fseeko</command>, <command>ftell</command>, <command>ftello</command> ve <command>rewind</command> işlevlerinin düşük seviyedeki karşılığıdır.
</para></funcdescr></funcsynopsis></para><para id="glibc-lseek64">
<indexterm scope="glibc-fn"><primary>lseek64</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>off64_t <command>lseek64</command></funcdef>
<paramdef>(int     <varname>dosyatanıtıcı</varname>,
 off64_t <varname>konum</varname>,
 int     <varname>nereye</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev <command>lseek</command> işlevinin benzeridir.  Farkı <varname>konum</varname> parametresinin  2^31 bayta kadar dosyalar için olan <command>off_t</command> türünde değil, 2^63 bayta kadar dosyalar için olan <command>off64_t</command> türünde olmasıdır. Bu işlev için kullanılan <varname>dosyatanıtıcı</varname> tanıtıcısının <command>open64</command> ile açılması önemlidir. Aksi takdirde, küçük dosya kipinde açılmış dosya tanıtıcılarla <command>off64_t</command> türündeki dosya konumları hatalara yol açacaktır.
   </para><para>
Kaynak dosyası <command>_FILE_OFFSET_BITS == 64</command> ile derlenmişse 32 bitlik sistemlerde bu işleve <command>lseek</command> ismiyle erişilir. Yani 32 bitlik arayüz 64 bitlik olanıyla değiştirilir.
</para></funcdescr></funcsynopsis></para><para>
Bir dosyayı defalarca açarsanız ya da <command>dup</command> ile tanıtıcıyı çoğaltırsanız aynı dosya için çok sayıda tanıtıcınız olabilir. <command>open</command> çağrıları ile elde edilen tanıtıcıların dosya konumları birbirinden bağımsızdır dolayısıyla biri üzerinde kullanacağınız <command>lseek</command> diğerlerini etkilemez. Örneğin,
   </para><para>
<screen>{
  int d1, d2;
  char buf[4];
  d1 = open (&quot;foo&quot;, O_RDONLY);
  d2 = open (&quot;foo&quot;, O_RDONLY);
  lseek (d1, 1024, SEEK_SET);
  read (d2, buf, 4);
}
     </screen></para><para>
<command>foo</command> dosyasının ilk dört karakterini okuyacaktır. (Gerçek br yazılımda gerekli olan hata denetimine, örneği karıştırmaması için yer verilmemiştir.)
   </para><para>
Tersine olarak, çoğaltma yoluyla elde edilen dosya tanıtıcılar ortak bir dosya konumunu paylaşırlar. Biri üzerinde yapılan okuma, yazma, dosya konumu değiştirme gibi her işlem diğerlerini etkiler. Örneğin,
   </para><para>
<screen>{
  int d1, d2, d3;
  char buf1[4], buf2[4];
  d1 = open (&quot;foo&quot;, O_RDONLY);
  d2 = dup (d1);
  d3 = dup (d2);
  lseek (d3, 1024, SEEK_SET);
  read (d1, buf1, 4);
  read (d2, buf2, 4);
}
</screen></para><para>
<command>foo</command> dosyasının 1024. karakterinden başlayarak dört karakter okur ve 1028. karakterden başlayarak dört karakter daha okur.
   </para><para id="glibc-off_t">
<indexterm scope="glibc-tp"><primary>off_t</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü">
<funcdef><command>off_t</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu dosya boyutlarını göstermekte kullanıan bir veri türüdür. GNU sisteminde <command>fpos_t</command> veya <command>long int</command> türüne eşdeğerdir.
   </para><para>
Kaynak dosyası <command>_FILE_OFFSET_BITS == 64</command> ile derlenmişse, bu veri türü <command>off64_t</command> veri türüne eşdeğer olur.
</para></funcdescr></funcsynopsis></para><para id="glibc-off64_t">
<indexterm scope="glibc-tp"><primary>off64_t</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü">
<funcdef><command>off64_t</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
<command>off_t</command> veri türüne benzer.  Bir farkla: 32 bitlik makinelerde <command>off_t</command> 32 bitlikken <command>off64_t</command> 64 bitliktir. Böylece dosyalar 2^63 bayta kadar adreslenebilir.
   </para><para>
Kaynak dosyası <command>_FILE_OFFSET_BITS == 64</command> ile derlenmişse, bu veri türü <command>off_t</command> ismiyle kullanılır.
      </para><para>
<command>SEEK_…</command> sabitleri için daha eski BSD sistemleri ile uyumluluk adına takma adlar tanımlanıştır. Bunlar iki ayrı başlık dosyasında tanımlıdır: <filename>fcntl.h</filename> ve <filename>sys/file.h</filename>.
   </para><para><variablelist><varlistentry>
   <term><literal>L_SET</literal></term><listitem><para>
<command>SEEK_SET</command> için takma addır.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>L_INCR</literal></term><listitem><para>
<command>SEEK_CUR</command> için takma addır.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>L_XTND</literal></term><listitem><para>
<command>SEEK_END</command> için takma addır.
      </para></listitem></varlistentry></variablelist>
  </para></funcdescr></funcsynopsis></para></chapter>
  <chapter id="glibc-Descriptors-and-Streams">
    <title>Tanıtıcılar ve Akımlar</title>
    <titleabbrev>Tanıtıcılar ile akımların birbirine dönüştürülmesi.</titleabbrev>
    <para>
<indexterm scope="glibc-cp"><primary>akımlar</primary><secondary>dosya tanıtıcıların elde edilmesi</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>dosya tanıtıcılar</primary><secondary>akımlara dönüştürülmesi</secondary></indexterm>
Belirtilen bir dosya tanıtıcı için <command>fdopen</command> ile bir akım oluşturabileceğiniz gibi <command>fileno</command> ile mevcut bir akımın dosya tanıtıcısını elde edebilirsiniz. Bu işlevler <filename>stdio.h</filename> başlık dosyasında bildirilmiştir.
<indexterm scope="glibc-pg"><primary>stdio.h</primary></indexterm>
   </para><para id="glibc-fdopen">
<indexterm scope="glibc-fn"><primary>fdopen</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>FILE *<command>fdopen</command></funcdef>
<paramdef>(int         <varname>dosyatanıtıcı</varname>,
 const char *<varname>açıştürü</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>fdopen</command> işlevi <varname>dosyatanıtıcı</varname> tanıtıcısı için yeni bir akım döndürür.
   </para><para>
<varname>açıştürü</varname> argümanı <command>fopen</command> işlevindeki gibi yorumlanır (bkz. <xref linkend="glibc-Opening-Streams"/>). Bir farkla: GNU sisteminde ikilik ve metin dosyalar arasında bir fark gözetilmediğinden <command>b</command> seçeneğine izin verilmez. Ayrıca <command>&quot;w&quot;</command> ve <command>&quot;w+&quot;</command> dosyanın kırpılmasına sebep olmaz; bu sadece dosyayı açarken etkilidir ve bu durumda zaten dosya açıktır. <varname>açıştürü</varname> argümanı açık dosyanın kipiyle eşleşmek zorundadır, buna dikkat etmelisiniz.
   </para><para>
İşlevin normal dönüş değeri yeni akımdır. Akım oluşturulamazsa bir boş gösterici döner. Bu duruma bir örnek: dosya tanıtıcının dosya kipinin <varname>açıştürü</varname> argümanında belirtilen erişim türüne izin vermemesi.
   </para><para>
Bazı sistemlerde, <varname>açıştürü</varname> argümanında belirtilen erişim türüne izin vermeyen dosya tanıtıcı kipi saptanırken <command>fdopen</command> başarısız olabilir. GNU C kütüphanesi daima bunun için denetlenir.
      </para><para>
<command>fdopen</command> işlevinin bir kullanım örneğini <xref linkend="glibc-Creating-a-Pipe"/> bölümünde bulabilirsiniz.
</para></funcdescr></funcsynopsis></para><para id="glibc-fileno">
<indexterm scope="glibc-fn"><primary>fileno</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>fileno</command></funcdef>
<paramdef>(FILE *<varname>akım</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev <varname>akım</varname> akımıyla ilişkili dosya tanıtıcı ile döner. Bir hata saptanırsa (örn, <varname>akım</varname> geçersizse) ya da <varname>akım</varname> bir dosyayla G/Ç yapmıyorsa, işlev <command>-1</command> ile döner.
</para></funcdescr></funcsynopsis></para><para id="glibc-fileno_unlocked">
<indexterm scope="glibc-fn"><primary>fileno_unlocked</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>fileno_unlocked</command></funcdef>
<paramdef>(FILE *<varname>akım</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>fileno_unlocked</command> işlevi, durum <command>FSETLOCKING_INTERNAL</command> ise akımı doğrudan kilitlememesi dışında <command>fileno</command> işlevine eşdeğerdir.
   </para><para>
Bu işlev bir GNU oluşumudur.
      </para><para>
<indexterm scope="glibc-cp"><primary>standard dosya tanıtıcılar</primary></indexterm>
<indexterm scope="glibc-cp"><primary>dosya tanıtıcılar</primary><secondary>standart  dosya tanıtıcılar</secondary></indexterm>
<command>stdin</command>, <command>stdout</command> ve <command>stderr</command> <link linkend="glibc-Standard-Streams">standart akımlarının</link> dosya tanıtıcıları için sembolik sabitleri vardır ve bunlar <filename>unistd.h</filename> başlık dosyasında tanımlıdır.
<indexterm scope="glibc-pg"><primary>unistd.h</primary></indexterm>
  </para><para id="glibc-STDIN_FILENO">
<indexterm scope="glibc-vr"><primary>STDIN_FILENO</primary></indexterm>
<indexterm scope="glibc-cp"><primary>dosya tanıtıcılar</primary><secondary>standart girdi</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>standart girdi</primary><secondary>dosya tanıtıcı</secondary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef><command>STDIN_FILENO</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu makro standart girdi için dosya tanıtıcı olarak <command>0</command> değerine sahiptir.
</para></funcdescr></funcsynopsis>
  </para><para id="glibc-STDOUT_FILENO">
<indexterm scope="glibc-vr"><primary>STDOUT_FILENO</primary></indexterm>
<indexterm scope="glibc-cp"><primary>dosya tanıtıcılar</primary><secondary>standart çıktı</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>standart çıktı</primary><secondary>dosya tanıtıcı</secondary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef><command>STDOUT_FILENO</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu makro standart çıktı için dosya tanıtıcı olarak <command>1</command> değerine sahiptir.
</para></funcdescr></funcsynopsis>
  </para><para id="glibc-STDERR_FILENO">
<indexterm scope="glibc-vr"><primary>STDERR_FILENO</primary></indexterm>
<indexterm scope="glibc-cp"><primary>dosya tanıtıcılar</primary><secondary>standart hata</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>standart hata</primary><secondary>dosya tanıtıcı</secondary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef><command>STDERR_FILENO</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu makro standart hata için dosya tanıtıcı olarak <command>2</command> değerine sahiptir.
</para></funcdescr></funcsynopsis>
  </para></funcdescr></funcsynopsis></para></chapter>
  <chapter id="glibc-Stream-Descriptor-Precautions">
    <title>Akımlarla Tanıtıcıları Karıştırmanın Tehlikeleri</title>
    <titleabbrev>Akımları ve tanıtıcıları birlikte kullanıyorsanız dikkatli olmalısınız.</titleabbrev>
    <para>
<indexterm scope="glibc-cp"><primary>dosyalar</primary><secondary>kanallar</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>kanallar</primary></indexterm>
<indexterm scope="glibc-cp"><primary>akımlar</primary><secondary>dosya tanıtıcılarla karıştırılırsa</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>dosya tanıtıcılar</primary><secondary>akımlarla karıştırılırsa</secondary></indexterm>
Aynı dosyaya bağlı çok sayıda dosya tanıtıcısı ve akıma (bunların ikisine birden kanallar diyebiliriz) sahip olabilirsiniz ama kanalları birbiri yerine kullanmaktan kaçınmanız gerekir. Ele alınacak iki durum vardır: tek bir dosya konumunu paylaşan <wordasword>ilintili kanallar</wordasword> ile kendi dosya konumları olan <wordasword>bağımsız kanallar</wordasword>.
   </para><para>
Tüm erişimin girdi amacıyla olması dışında, bir dosyayla veri iletimi için yazılımınızda sadece bir kanalı kullanmanız en iyisidir. Örneğin, bazı şeylerin sadece dosya tanıtıcıları ile yapılabildiği bir boru açarsanız, tüm G/Ç işlemlerini hem dosya tanıtıcı ile hem de bu dosya tanıtıcı için <command>fdopen</command> ile oluşturacağınız akım ile yapabilirsiniz.
   </para>
    <sect1 id="glibc-Linked-Channels">
      <title>İlintili Kanallar</title>
      <titleabbrev>Dosya konumunu paylaşan kanallarla çalışma.</titleabbrev>
      <para>
<indexterm scope="glibc-cp"><primary>kanallar</primary><secondary>ilintili</secondary></indexterm>
Tek bir açılışta aynı dosya konumunu paylaşan kanallara <wordasword>ilintili kanallar</wordasword> diyoruz. <command>fdopen</command> kullanarak bir tanıtıcıdan bir akım yaptığınızda, <command>fileno</command> ile bir akım ile ilişkili dosya tanıtıcısına eriştiğinizde, <command>dup</command> veya <command>dup2</command> ile bir dosya tanıtıcısını çoğalttığınızda ve <command>fork</command> ile dosya tanıtıcıları alt süreçte miras aldığınızda bir ilintili kanalınız olur. Uçbirimler ve borular gibi rasgele erişimi desteklemeyen dosyalar için <emphasis>tüm</emphasis> kanallar zorunlu olarak ilintilidir. Rasgele erişimli dosyalarda, sona ekleme yapılan akımlar da zorunlu olarak diğeri ile ilintilidir.
    </para><para>
<indexterm scope="glibc-cp"><primary>akımlar</primary><secondary>temizlenmesi</secondary></indexterm>
G/Ç için bir akım kullanıyorsanız (sadece akım açmışsanız) ve onunla ilintili diğer kanalla (bir akım ya da tanıtıcı olabilir) G/Ç yapmak isterseniz, kullanmakta olduğunuz akımı önce <link linkend="glibc-Cleaning-Streams">temizlemelisiniz</link>.
    </para><para>
Bir sürecin sonladırılması ya da süreç içinde yeni bir yazılımın çalıştırılması süreç içindeki tüm akımların ortadan kaldırılmasına sebep olur. Bu akımlarla ilintili tanıtıcılar diğer süreçte kalır, dolayısıyla dosya konumları tanımsız duruma gelir. Bundan kaçınmak için ortadan kaldırmadan önce akımları temizlemeniz gerekir.
    </para></sect1>
    <sect1 id="glibc-Independent-Channels">
      <title>Bağımsız Kanallar</title>
      <titleabbrev>Ayrı ayrı açılmış, ilintisiz kanallarla çalışma.</titleabbrev>
      <para>
<indexterm scope="glibc-cp"><primary>kanallar</primary><secondary>bağımsız</secondary></indexterm>
Dosya konumlaması yapılabilen bir dosya için ayrı kanallar (akım ya da tanıtıcı) açtığınızda her kanalın kendi dosya konumu olur. Bu tür kanallara <wordasword>bağımsız kanallar</wordasword> denir.
    </para><para>
Sistem her kanalı bağımsız olarak elde eder. Çoğu zaman, bu tahmin edilebilir ve (özellikle girdi için) doğal bir sonuçtur: her kanal, kendi dosyasında ve kendi konumunda sıralı okuma ya da yazma yapabilir. Bununla birlikte, birer akım olan bazı kanallarda şunlara dikkat etmeniz gerekir:
    </para><itemizedlist><listitem><para>
Dosyanın aynı parçasında okuma ya da yazma yapacaksanız, birşey yapmadan önce ve kullandıktan sonra çıktı akımını temizlemelisiniz.
      </para></listitem><listitem><para>
Bir bağımsız kanal kullanılarak değiştirilmekte olan verinin okunmasından önce bir girdi akımını temizlemelisiniz. Aksi takdirde, akımın tamponunda bulunan atıl veriyi okuyabilirsiniz.
      </para></listitem></itemizedlist><para>
Bir dosyanın sonunda tek bir kanala çıktılama yaparsanız, diğer bağımsız kanalların dosya sonuna göre yaptıkları konumlamayı alakasız bir noktaya taşımış olacaktır. Sizin dosya konumlaması yapmanız ile dosyaya yazmanız arasında başka bir sürecin aynı şeyi yapmasını engelleyemediğiniz gibi sizinde bunun tersine olarak onların dosya konumlarını doğru yere kaydıramazsınız. Ama tanıtıcı ya da akımı dosya sonuna ekleme yapan türde açarsanız, daima o anki dosya sonuna ekleme yaparsınız. Dosya sonu konumlamasını doğru yapabilmek için çıktı kanalını, kanal bir akımsa temizlemelisiniz.
    </para><para>
Rasgele erişimi desteklemeyen bir dosya için farklı dosya konumları olan iki kanal açmak mümkündür. Bu şekilde dosyaya okuma ve yazma amacıyla açılan kanallar bağımsız açılsa bile ilintilidir. Dosya sonuna ekleme türünde açılan kanallar daima ilintilidir. Bu kanallar için <link linkend="glibc-Linked-Channels">ilintili kanallarla ilgili kurallar</link> uygulanır.
    </para></sect1>
    <sect1 id="glibc-Cleaning-Streams">
      <title>Akımların Temizlenmesi</title>
      <titleabbrev>Başka bir kanala güvence sağlamak için bir akımın temizlenmesi.</titleabbrev>
      <para>
GNU sisteminde, herhangi bir akımı <command>fclean</command> ile temizleyebilirsiniz:
    </para><para id="glibc-fclean">
<indexterm scope="glibc-fn"><primary>fclean</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>fclean</command></funcdef>
<paramdef>(FILE *<varname>akım</varname>)</paramdef>
</funcprototype><funcdescr><para>
<varname>akım</varname> akımını temizler yani tamponunu boşaltır. <varname>akım</varname> çıktılama yapıyorsa, çıktılamaya zorlar; giriş yapıyorsa, tampondaki veriyi yeniden okumak için düzenleyerek sisteme iade eder.
</para></funcdescr></funcsynopsis></para><para>
Diğer sistemlerde, çoğu durumda bir akımı temizlemek için <command>fflush</command> kullanabilirsiniz.
    </para><para>
Bir akımın zaten temiz olduğunu biliyorsanız <command>fclean</command> veya <command>fflush</command> çağrısı yapmayabilirsiniz. Örneğin, bir tamponsuz akım daima temizdir. Dosya sonundaki bir girdi akımı daima temizdir. Son çıktılanan karakter bir satırsonu karakteri ise bir satır tamponlu akım daima temizdir. Bununla birlikte, açıldığı anda bir girdi akımı, girdi tamponu boş olmayabileceğinden temiz olmayabilir.
    </para><para>
Çoğu sistemde bir akımı temizlemenin mümkün olmadığı bir durum vardır. Bu, rasgele erişimli olmayan bir dosyadan girdi yapan bir akımın varlığıdır. Böyle akımlar genellikle sürekli okur ama dosya rasgele erişimli olmadığında, okunmuş olan veriye tekrar erişmenin bir yolu yoktur. Bir girdi akımı bir rasgele erişimli dosyadan okuduğu zaman, <command>fflush</command> akımı temizler ama dosya konumlayıcıyı alakasız bir yerde bırakır; bu bakımdan, herhangi bir G/Ç işlemi yapmadan öce dosya konumlayıcıyı doğru yere ayarlamalısınız. GNU sisteminde <command>fclean</command> kullandığınızda her iki sorun da ortaya çıkmaz.
    </para><para>
Sadece çıktılama yapan bir akımın kapatılması da <command>fflush</command>  yapar, dolayısıyla bir çıktı akımının temizlenmesinde bu yöntem de kullanılabilir. GNU sisteminde bir girdi akımının kapatılması <command>fclean</command> yapar.
    </para><para>
Uçbirim kipini ayarlamak gibi denetim işlemleri için tanıtıcısını kullanmadan önce bir akımı temizleyemezsiniz; bu işlemler dosya konumunu etkilemez ve dosya konumundan etkilenmez. Bu işlemler için her tanımlayıcıyı kullanabilirsiniz ve tüm kanallar aynı anda etkilenir. Bununla birlikte, metin zaten bir akıma çıktılanır ama hemen ardından boşaltılırken yeni uçbirim kiplerine konu olacak akım tarafından hala tamponlu olur. Yapılan çıktılamanın o anda etkili olan uçbirim ayarları tarafından kapsandığından emin olmak için kipi ayarlanmadan önce uçbirimin çıktı akımları boşaltılır. Bkz. <xref linkend="glibc-Terminal-Modes"/>.
    </para></sect1></chapter>
  <chapter id="glibc-Scatter-Gather">
    <title>G/Ç'yı Hızlı Dağıtıp Toplama</title>
    <titleabbrev>Kesintili tamponlarda hızlı G/Ç.</titleabbrev>
    <para>
<indexterm scope="glibc-cp"><primary>dağıtma-toplama</primary></indexterm>
Bazı uygulamalarda bellekte ayrı yerlerde duran çok sayıda tampona yazmak ya da okumak gerekebilir. Bu işlem çok sayıda <command>read</command> ve <command>write</command> çağrısı ile kolayca yapılabildiği halde, her çekirdek çağrısının sabit bir maliyeti olduğundan bu verimli olmaz.
   </para><para>
Bunun yerine, çoğu platformada tek bir çekirdek çağrısında her iki işlemi birlikte yapan yüksek hızlı özel ilkeller vardır. GNU C kütüphanesi bu ilkellerin her sistemde benzetilmesini sağlayarak bunların taşınabilirliğe konu olmamasını sağlamıştır. Bu ilkeller  <filename>sys/uio.h</filename> başlık dosyasında tanımlıdır.
   </para><para>
Bu işlevler, her tamponun boyutunun ve konumunun belirtildiği <command>iovec</command> yapılarından oluşan bir diziyle çalışırlar.
   </para><para id="glibc-iovec">
<indexterm scope="glibc-tp"><primary sortas="iovec">struct iovec</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü">
<funcdef>struct <command>iovec</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
<command>iovec</command> yapısı bir tampon ile ilgili bilgileri içerir. İki alanı vardır:
   </para><para><glosslist><glossentry><glossterm>
   <literal>void *<command>iov_base</command></literal>
   </glossterm><glossdef><para>Tamponun adresidir
   </para></glossdef></glossentry><glossentry><glossterm>
   <literal>size_t <command>iov_len</command></literal>
   </glossterm><glossdef><para>Tamponun uzunluğudur.
   </para></glossdef></glossentry></glosslist>
</para></funcdescr></funcsynopsis></para><para id="glibc-readv">
<indexterm scope="glibc-fn"><primary>readv</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>ssize_t <command>readv</command></funcdef>
<paramdef>(int                 <varname>dosyatanıtıcı</varname>,
 const struct iovec *<varname>vektör</varname>,
 int                 <varname>sayı</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>readv</command> işlevi veriyi <varname>dosyatanıtıcı</varname> tanıtıcısından okuyup  <varname>sayı</varname> yapılık <varname>vektör</varname> dizisindeki tamponlara bir tampon dolduktan sonra diğerine geçerek dağıtır.
   </para><para>
<command>readv</command> işlevinin tamponların tümünü dolduracağı garanti edilmemiştir. <command>read</command> işlevinde olduğu gibi aynı sebeplerle işlem bir noktada durabilir.
   </para><para>
Normal dönüş değeri okunan (tamponlara yazılan değil) baytları sayısıdır. 0 değeri dosya sonunu belirtir. <command>-1</command> değeri ise bir hata saptandığını gösterir. Olası hatalar <command>read</command> işlevindekilerle aynıdır.
</para></funcdescr></funcsynopsis></para><para id="glibc-writev">
<indexterm scope="glibc-fn"><primary>writev</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>ssize_t <command>writev</command></funcdef>
<paramdef>(int                 <varname>dosyatanıtıcı</varname>,
 const struct iovec *<varname>vektör</varname>,
 int                 <varname>sayı</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>writev</command> işlevi veriyi <varname>sayı</varname> yapılık <varname>vektör</varname> dizisindeki tamponlardan onları sırayla okuyarak toplayıp <varname>dosyatanıtıcı</varname> tanıtıcısına yazar.
   </para><para>
<command>readv</command> gibi, <command>writev</command> işlevi de <command>write</command> işlevindeki aynı koşullarda işlemin ortasında durabilir.
   </para><para>
Normal dönüş değeri yazılan baytların sayısıdır. <command>-1</command> değeri hata saptandığını belirtir. Olası hatalar <command>write</command> işlevindekilerle aynıdır.
</para></funcdescr></funcsynopsis></para><para>
Bu tamponların küçük (1kB'ın altında) olması halinde yüksek seviyeli akımların bu işlevlerden daha hızlı olacaklarını unutmayın. Bununla birlikte, <command>readv</command> ve <command>writev</command> işlevleri tamponların büyük olması (toplam çıktının değil) durumunda daha verimlidir. Bu durumda bir yüksek seviyeli akımın veriyi verimli olarak arabelleklemesi mümkün olmazdı.
  </para></chapter>
  <chapter id="glibc-Memory-mapped-I-O">
    <title>Bellek Eşlemli G/Ç</title>
    <titleabbrev>Bellek benzeri dosyaların kullanımı.</titleabbrev>
    <para>
Günümüz işletim sistemlerinde, bir dosyayı bir bellek bölgesine eşlemek mümkündür. Bu yapıldığında dosyaya yazılım içinden bir dizi gibi erişilebilir.
   </para><para>
Yazılımın bir dosyanın sadece yüklü bölümlerine erişim anlamında bu işlem <command>read</command> veya <command>write</command> ile yapılan işlemlerden daha verimlidir. Henüz belleğe yüklenmemiş parçalara bellek sayfalarının takaslanmasına benzer bir yolla erişilir.
   </para><para>
Belleğe eşlenmiş sayfalar, fiziksel bellek azaldığında tekrar dosyasında saklanabilir, belleğe eşlenmiş dosyaların boyutları büyüdükçe hem fiziksel bellekte hem de takas alanında eşlenebilir. Tek sınır adres alanıdır. Teorik sınır 32 bitlik makinelerde 4GB'dır. Başka amaçlarla ayrılan alanlardan dolayı gerçek sınır daha küçük olabilir. LFS arayüzü kullanan 32 bitlik dosya sistemlerinde dosya boyu 64 bitlik olabildiğinden  2GB ile sınırlı değildir (konumların işaretli tamsayılar olması halinde adreslenebilir alan 4GB'ın yarısına düşebilir).
   </para><para>
Bellek eşleme, bellekte sadece sayfalarla çalışır. Bu bakımdam, eşleşme adresleri sayfalara hizalanmış ve uzunluk değerleri de buna göre yuvarlanmış olmalıdır. Makinede kullanılan sayfa boyutlarını saptamak için
   </para><para>
<indexterm scope="glibc-vr"><primary sortas="SC_PAGESIZE">_SC_PAGESIZE</primary></indexterm>
<screen>size_t page_size = (size_t) sysconf (_SC_PAGESIZE);</screen>
   </para><para>kullanılabilir. Bu işlevler <filename>sys/mman.h</filename> başlık dosyasında bildirilmiştir.
   </para><para id="glibc-mmap">
<indexterm scope="glibc-fn"><primary>mmap</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>void *<command>mmap</command></funcdef>
<paramdef>(void  *<varname>adres</varname>,
 size_t <varname>uzunluk</varname>,
 int    <varname>izinler</varname>,
 int    <varname>seçenekler</varname>,
 int    <varname>dosyatanıtıcı</varname>,
 off_t  <varname>konum</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>mmap</command> işlevi <varname>dosyatanıtıcı</varname> ile açılan dosya için yeni bir eşlem oluşturur. Eşlem  (<varname>konum</varname>)'dan başlar, (<varname>konum</varname> + <varname>uzunluk</varname> - 1) de biter. <varname>dosyatanıtıcı</varname> ile belirtilen dosya için dosya kapatıldığında bile kaldırılmayan yeni bir referans oluşturur.
   </para><para>
<varname>adres</varname> ile eşlem için tercih edilen adres belirtilir. <command>NULL</command> tercih belirtilmediğini gösterir. Adreste evvelce bir eşlem varsa özdevinimli olarak kaldırılır. <command>MAP_FIXED</command> seçeneği kullanmasanızda belirttiğiniz adres yine de değiştirilmeyebilir.
   </para><para id="glibc-PROT_READ">
<indexterm scope="glibc-vr"><primary>PROT_READ</primary></indexterm>
<indexterm scope="glibc-vr"><primary>PROT_WRITE</primary></indexterm>
<indexterm scope="glibc-vr"><primary>PROT_EXEC</primary></indexterm>
<varname>izinler</varname> ne çeşit erişime izin verildiğini belirten seçenekleri içerir. Bunlar sırayla okuma, yazma ve çalıştırma izinlerini belirten <command>PROT_READ</command>, <command>PROT_WRITE</command> ve <command>PROT_EXEC</command> seçenekleri olabilir. Belirtilmeyen bir iznin kullanılmaya çalışılması bir parçalama arızasına (segfault) yol açacaktır (bkz. <xref linkend="glibc-Program-Error-Signals"/>).
   </para><para>
Çoğu donanım tasarımının okuma izni olmadan yazma iznini desteklemediğini ve çoğunun okuma ve çalıştırma izinleri bakımından bir ayrım yapmadığını aklınızdan çıkarmayın. Bu bakımdan, istediğinizden daha geniş yetkilere sahip olabileceğiniz gibi sadece yazılabilir olarak belirttiğiniz dosyalara <command>PROT_READ</command> kullanmadığınız takdirde erişemeyebileceğinizi de unutmayın.
   </para><para>
<varname>seçenekler</varname> eşlemin doğasını denetleyen seçenekleri içerir. Burada <command>MAP_SHARED</command> veya <command>MAP_PRIVATE</command> seçeneklerinden biri belirtilmelidir.
   </para><para>Bunlar:
   </para><para><variablelist><varlistentry>
   <term><literal>MAP_PRIVATE</literal></term><listitem><para>
Eşlemle ilgili dosyaya yazılamasa da bellek bölgesine yazılabileceğini belirtir. Bunun yerine, süreç için bir kopya yapılır ve normal olarak bellek azsa bölge takaslanır. Başka hiçbir süreç değişiklikleri görmez.
      </para><para>
Özel eşlemler üzerlerine yazıldıklarında fiilen sıradan belleğe konulduğundan eğer bu kipi <command>PROT_WRITE</command> ile kullanıyorsanız eşlemlenmiş bölgenin tamamının kopyası için yeterli sanal bellek olmalıdır.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>MAP_SHARED</literal></term><listitem><para>
bölgeye yapılan yazmaların dosyaya da yazılacağını belirtir. Değişiklikler aynı dosyayı eşlemlemiş olan diğer süreçlerle anında paylaşılacaktır.
      </para><para>
Asıl yazma işlemlerinin herhangi bir anda olabileceğini unutmayın. Diğer süreçlerin geleneksel G/Ç işlemlerini kullanarak dosyanın tutarlı bir görünümünü almaları önemliyse, aşağıda açıklanan <command>msync</command> işlevini kullanmanız gerekir.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>MAP_FIXED</literal></term><listitem><para>
Sistemin eşlem adresi olarak <varname>adres</varname> ile belirtilen adresi kullanması için zorlar. Bu olmazsa işlev başarısız olur.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>MAP_ANONYMOUS</literal></term>
      </varlistentry><varlistentry>
      <term><literal>MAP_ANON</literal></term><listitem><para>
Sisteme, bir dosyaya bağlı olmayan bir anonim eşlem oluşturmasını söyler. <varname>dosyatanıtıcı</varname> ve <varname>konum</varname> yoksayılır ve bölge sıfırlarla ilklendirilir.
      </para><para>
Anonim eşlemler bazı sistemlerde özdevimli ayırma yapılabilen bellek bölgesinin genişletilmesinde temel ilkel olarak kullanılır. Ayrıca bir dosya oluşturmadan çok sayıda görev arasında veri paylaşmak için de kullanışlıdır.
      </para><para>
Bazı sistemlerde büyük bellek blokları ile çalışırken özel anonim eşlemleri kullanmak <command>malloc</command> kullanmaktan daha verimlidir. GNU C sisteminde <command>malloc</command> gerektiği takdirde özdevinimli olarak <command>mmap</command> işlevini kullanır.
      </para></listitem></varlistentry></variablelist>
    </para><para>
<command>mmap</command> normalde yeni eşlemin adresi ile döner. <command>-1</command> dönüş değeri bir hata oluştuğunu belirtir.
   </para><para>
Olası hatalar:
   </para><para><variablelist><varlistentry>
   <term><literal>EINVAL</literal></term><listitem><para>
Ya <varname>adres</varname> işe yaramaz ya da belirtilen <varname>seçenekler</varname> tutarsız
      </para></listitem></varlistentry><varlistentry>
      <term><literal>EACCES</literal></term><listitem>
<para><varname>dosyatanıtıcı</varname> belirtilen <varname>izinler</varname> ile açılmadı
      </para></listitem></varlistentry><varlistentry>
      <term><literal>ENOMEM</literal></term><listitem><para>
Ya işlem için yeterli bellek yok ya da süreç, adres alanı dışında
      </para></listitem></varlistentry><varlistentry>
      <term><literal>ENODEV</literal></term><listitem><para>
Bu dosya belleğe eşlemlenen türde değil
      </para></listitem></varlistentry><varlistentry>
      <term><literal>ENOEXEC</literal></term><listitem><para>
Dosya belleğe eşlemlemeyi desteklemeyen bir dosya sisteminde
      </para></listitem></varlistentry></variablelist>
</para></funcdescr></funcsynopsis></para><para id="glibc-mmap64">
<indexterm scope="glibc-fn"><primary>mmap64</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>void *<command>mmap64</command></funcdef>
<paramdef>(void   *<varname>adres</varname>,
 size_t  <varname>uzunluk</varname>,
 int     <varname>izinler</varname>,
 int     <varname>seçenekler</varname>,
 int     <varname>dosyatanıtıcı</varname>,
 off64_t <varname>konum</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>mmap64</command> işlevi <varname>konum</varname> parametresinin <command>off64_t</command> türünde olması dışında <command>mmap</command> işlevine eşdeğerdir. 32 bitlik sistemlerde bu, tanıtıcısı <varname>dosyatanıtıcı</varname> olan dosyanın 2GB'dan büyük olabilmesini mümkün kılar. <varname>dosyatanıtıcı</varname>, <command>open64</command> veya <command>fopen64</command> ve <command>freopen64</command> çağrılarından dönen bir tanıtıcı olmalıdır.
   </para><para>
Kaynak dosyaları <command>_FILE_OFFSET_BITS == 64</command> ile derlenmişse bu işleve <command>mmap</command> ismiyle erişilir. Yani, derleme sırasında 64 bitlik yeni arayüz eski arayüzün yerine geçer.
</para></funcdescr></funcsynopsis></para><para id="glibc-munmap">
<indexterm scope="glibc-fn"><primary>munmap</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>munmap</command></funcdef>
<paramdef>(void  *<varname>adres</varname>,
 size_t <varname>uzunluk</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>munmap</command> işlevi (<varname>adres</varname>)'ten (<varname>adres</varname> + <varname>uzunluk</varname>)'a kadar olan eşlemi siler.  <varname>uzunluk</varname> eşlemin uzunluğu olmalıdır.
   </para><para>
Aralık içinde eşlenmemiş alanlar olabilir, bu şekilde çok sayıda eşlem tek bir komutla silinebilir. Ayrıca mevcut eşlemin sadece bir bölümünü silmek de mümkündür. Ancak sadece tam sayfalar silinebilir. <varname>uzunluk</varname> sayfa sayısına denk değilse bile üste yuvarlanır.
   </para><para>
Normal dönüş değeri sıfırdır, <command>-1</command> bir hata belirtir.
   </para><para>
Olası hata:
   </para><para><variablelist><varlistentry>
   <term><literal>EINVAL</literal></term><listitem><para>
Belirtilen bellek adresi aralığı kullanıcının mmap aralığının dışında ya da sayfa hizalı değil
      </para></listitem></varlistentry></variablelist>
</para></funcdescr></funcsynopsis></para><para id="glibc-msync">
<indexterm scope="glibc-fn"><primary>msync</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>msync</command></funcdef>
<paramdef>(void  *<varname>adres</varname>,
 size_t <varname>uzunluk</varname>,
 int    <varname>seçenekler</varname>)</paramdef>
</funcprototype><funcdescr><para>
Paylaşımlı eşlemler kullanılırken, silmeden önce çekirdek herhangi bir zamanda eşlemi
dosyaya yazabilir. Değişmiş bir veri varsa, dosyaya bellek eşlemli olmayan G/Ç ile erişen süreçler veri dosyaya fiilen yazılana kadar bunları göremezler. Bunun olmaması için bu işlevi kullanmak gerekir.
   </para><para>
İşlev <varname>adres</varname>'ten (<varname>adres</varname> + <varname>uzunluk</varname>)'a kadar olan bölgede çalışır. Bu bölge çok sayıda dosyanın eşlemlerini içerebileceği gibi bir dosyanın bir bölümünü içeren bir eşlem bölgesi de olabilir.
   </para><para>
<varname>seçenekler</varname> şunları içerebilir:
   </para><para><variablelist><varlistentry>
   <term><literal>MS_SYNC</literal></term><listitem><para>
Bu seçenek verinin "disk"e yazılmasını sağlar. Normalde <command>msync</command> işlevi geleneksel G/Ç işlemleri ile bir dosyaya erişimde son yapılan değişikliklere dosyada mevcutmuş gibi erişilmesini sağlar.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>MS_ASYNC</literal></term><listitem><para>
<command>msync</command>'e eşzamanlamaya başlamasını söyler ama başlaması için beklemez.
      </para></listitem></varlistentry></variablelist>
    </para><para>
<command>msync</command> normalde sıfır ile hata oluştuğunda <command>-1</command> ile döner. Olası hatalar:
   </para><para><variablelist><varlistentry>
   <term><literal>EINVAL</literal></term><listitem><para>
Ya geçersiz bir bölge belirtilmiş ya da <varname>seçenekler</varname> geçersiz
      </para></listitem></varlistentry><varlistentry>
      <term><literal>EFAULT</literal></term><listitem><para>
Bir bellek eşlemin parçası olarak bile bir eşlem yok
      </para></listitem></varlistentry></variablelist>
</para></funcdescr></funcsynopsis></para><para id="glibc-mremap">
<indexterm scope="glibc-fn"><primary>mremap</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>void *<command>mremap</command></funcdef>
<paramdef>(void  *<varname>adres</varname>,
 size_t <varname>uzunluk</varname>,
 size_t <varname>yeni_uzunluk</varname>,
 int    <varname>seçenek</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev mevcut bir bellek alanının boyunu değiştirmekte kullanılabilir. <varname>adres</varname> ve <varname>uzunluk</varname> tamamı aynı <command>mmap</command> deyiminde eşlemlenmiş bir bölgeyi belirtmelidir. <varname>yeni_uzunluk</varname> ile belirtilen yeni eşlem aynı karakteristik özelliklerle dönecektir.
   </para><para>
Tek bir seçenek, <command>MREMAP_MAYMOVE</command> belirtilebilir. Bu, <varname>seçenek</varname> içinde belirtilmişse, sistem mevcut eşlemi silip başka bir yerde belirtilen uzunlukta yeni bir eşlem oluşturur.
   </para><para>
Normalde yeni eşlemin adresi ile bir hata oluştuğunda ise <command>-1</command> ile döner. Olası hatalar:
   </para><para><variablelist><varlistentry>
   <term><literal>EFAULT</literal></term><listitem><para>
Özgün eşlemin parçası olarak bile bir eşlem yok veya bölge birden fazla farklı eşlem içeriyor
      </para></listitem></varlistentry><varlistentry>
      <term><literal>EINVAL</literal></term><listitem><para>
Belirtilen adres hizalı değil ya da uygunsuz
      </para></listitem></varlistentry><varlistentry>
      <term><literal>EAGAIN</literal></term><listitem><para>
Bölge kilitli sayfalar içeriyor, eğer genişletmek gerekirse kilitli sayfalar için <link linkend="glibc-Limits-on-Resources">sürecin özkaynak sınırı</link> aşılabilir.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>ENOMEM</literal></term><listitem><para>
Bölge yazılabilir ama özel, ayrıca genişletmek için sanal bellek yetersiz. Bundan başka, <command>MREMAP_MAYMOVE</command> belirtilmemişse ve  genişletme başka bir eşlemli bölge ile çatışacaksa bu hata oluşacaktır.
      </para></listitem></varlistentry></variablelist>
    </para><para>
Bu işlev sadece bir kaç sistemde kullanılabilir. İsteğe bağlı eniyilemeler gerçekleştirmek dışında bu işlev kullanılmamalıdır.
   </para><para>
Tüm dosya tanıtıcılar bellek eşlemli olamaz. Soketler, borular ve çoğu aygıta sadece ardışık erişim mümkündür ve ayrılabilecek bir eşleme sığmaz. Ek olarak, bazı normal dosyalar da eşlemlenemez ve eski çekirdekler eşlemlemeyi hiç desteklemeyebilir. Bu bakımdan bu işlevi kullanacak yazılımların işlev başarısız olduğunda kullanılacak bir sonçare yöntemi olmalıdır. Bkz. <xref linkend="standards-Mmap"/>.
</para></funcdescr></funcsynopsis></para><para id="glibc-madvise">
<indexterm scope="glibc-fn"><primary>madvise</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>madvise</command></funcdef>
<paramdef>(void  *<varname>adres</varname>,
 size_t <varname>uzunluk</varname>,
 int    <varname>öneri</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev, sisteme <varname>adres</varname>'tan başlayan <varname>uzunluk</varname> baytlık bellek bölgesinin düşünülen kullanım şekliyle ilgili bir öneri yapmak için kullanılabilir.
   </para><para>
<varname>öneri</varname> için geçerli BSD değerleri şunlardır:
   </para><para><variablelist><varlistentry>
   <term><literal>MADV_NORMAL</literal></term><listitem><para>
Bölge özel birşey yapmadan alınmalı.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>MADV_RANDOM</literal></term><listitem><para>
Bölge rasgele sayfa referansları üzerinde erişilebilir olacak. Çekirdek her sayfalama hatası için en az sayıda sayfayı gerçek belleğe sayfalamalıdır.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>MADV_SEQUENTIAL</literal></term><listitem><para>
Bölge ardışık sayfa referansları üzerinde erişilebilir olacak. Bu çekirdeğin bölge içindeki her sayfalama hatasından sonra bir ardışık referans umarak sürekli ileri okumaya zorlanmasına sebep olur.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>MADV_WILLNEED</literal></term><listitem><para>
Bölge gerekli olacaktır. Bu bölge içindeki sayfalar çekirdek tarafından önceden gerçek belleğe sayfalanmış olmalıdır.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>MADV_DONTNEED</literal></term><listitem><para>
Bölge artık gerekmeyecektir. Sayfa kaybına sebep olabilecek bir değişiklikte ya da sanal belleğe kopyalanması gerektiğinde bunun yapılmaması suretiyle çekirdek bu sayfaları serbest bırakabilir.
      </para></listitem></varlistentry></variablelist>
    </para><para>
POSIX isimleri birazcık farklıdır ama isimler aynı anlama gelir:
   </para><para><variablelist><varlistentry>
   <term><literal>POSIX_MADV_NORMAL</literal></term><listitem><para>
BSD'nin <command>MADV_NORMAL</command> seçeneğine karşılıktır.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>POSIX_MADV_RANDOM</literal></term><listitem><para>
BSD'nin <command>MADV_RANDOM</command> seçeneğine karşılıktır..
      </para></listitem></varlistentry><varlistentry>
      <term><literal>POSIX_MADV_SEQUENTIAL</literal></term><listitem><para>
BSD'nin <command>MADV_SEQUENTIAL</command> seçeneğine karşılıktır.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>POSIX_MADV_WILLNEED</literal></term><listitem><para>
BSD'nin <command>MADV_WILLNEED</command> seçeneğine karşılıktır.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>POSIX_MADV_DONTNEED</literal></term><listitem><para>
BSD'nin <command>MADV_DONTNEED</command> seçeneğine karşılıktır.
      </para></listitem></varlistentry></variablelist>
    </para><para>
Normalde <command>msync</command> sıfır ile döner, <command>-1</command> bir hata saptandığını belirtir. Olası hatalar:
   </para><para><variablelist><varlistentry>
   <term><literal>EINVAL</literal></term><listitem><para>
Ya belirtilen bölge ya da <varname>öneri</varname> geçersiz
      </para></listitem></varlistentry><varlistentry>
      <term><literal>EFAULT</literal></term><listitem><para>
Belirtilen bölgenin bir parçası olabilecek kadar bile eşlem yok
      </para></listitem></varlistentry></variablelist>
    </para></funcdescr></funcsynopsis></para></chapter>

<chapter id="glibc-Waiting-for-I-O">
  <title>Girdi ve Çıktının Beklenmesi</title>
  <titleabbrev>Çok sayıda dosya tanıtıcısı üzerinde gidi ve çıktı nasıl denetlenir.</titleabbrev>
  <para>
<indexterm scope="glibc-cp"><primary>dosya tanıtıcılar</primary><secondary>girdi ve çıktının beklenmesi</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>girdi</primary><secondary>bekleme</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>girdi</primary><secondary>çoğullama</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>girdi</primary><secondary>çok sayıda dosyadan</secondary></indexterm>
Kimi zaman bir yazılımın girdiyi gelişine bağlı olarak çok sayıda girdi kanalından kabul etmesi gerekir. Örneğin bazı iş istasyonları tablet, işlev düğmeleri kutusu, normal eşzamansız seri arayüz üzerinden bağlanılan çevirmeli ağ gibi çok sayıda aygıttan aynı anda ve anında yanıt verecek iyi bir kullanıcı arayüzü gerektirmektedir. Başka bir örnek de bir yazılımın başka süreçlere borular ve FIFO'lar üzerinden bir sunucu olarak hizmet vermesidir.
   </para><para>
Normalde bu amaçla <command>read</command> kullanamazsınız, çünkü işlev bir dosya tanıtıcıdan bir girdi gelene kadar beklerken diğer kanallardaki girdi fazladan bekletilir. Engellenmeyen kipe geçmeniz ve dosya tanıtıcılarını sürekli taramanız gerekir ki bu da pek verimli değildir.
   </para><para>
Daha iyi bir çözüm <command>select</command> işlevini kullanmaktır.  Bu, belirtilen dosya tanıtıcı kümesinde bir girdi ya da çıktı hazır olana kadar ya da bir zamanlayıcı zamanaşımına uğrayıncaya kadar (hangisi önce gerçekleşirse), bekler. Bu oluşum <filename>sys/types.h</filename> başlık dosyasında bildirilmiştir.
<indexterm scope="glibc-pg"><primary>sys/types.h</primary></indexterm>
   </para><para>
Bir <link linkend="glibc-Listening">sunucu soketi</link> için konuşursak, askıda <link linkend="glibc-Accepting-Connections">kabul edilmiş bağlantılar</link> olduğunda girdinin var olabileceğinden söz edilebilir. <command>accept</command> işlevi sunucu soketini beklemeye alır ve <command>read</command> işlevinin normal girdi için yaptığı gibi  <command>select</command> ile etkileşir.
   </para><para>
<indexterm scope="glibc-cp"><primary>dosya tanıtıcılar</primary><secondary>tanıtıcı kümeleri</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>dosya tanıtıcılar</primary><secondary><command>select</command> işlevi</secondary></indexterm>
<command>select</command> işlevi için dosya tanıtıcı kümeleri <command>fd_set</command> nesneleri olarak belirtilir. Burada bu nesnelerin veri türü ve bunlarla ilgili makrolara değinilecektir.
   </para><para id="glibc-fd_set">
<indexterm scope="glibc-tp"><primary>fd_set</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü">
<funcdef><command>fd_set</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
<command>fd_set</command> veri türü <command>select</command> işlevinin üzerlerinde işlem yaptığı dosya tanıtıcılarının kümesini içerir.  Aslında bir bit dizisidir.
</para></funcdescr></funcsynopsis></para><para id="glibc-FD_SETSIZE">
<indexterm scope="glibc-vr"><primary>FD_SETSIZE</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>int <command>FD_SETSIZE</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
<command>fd_set</command> nesnesinde saklanabilen dosya tanıtıcılarının azami sayısıdır. Azami sayının sabit olduğu sistemlerde <command>FD_SETSIZE</command> bu sayıya eşittir. GNU sistemininde dahil olduğu bazı sistemlerde açık tanıtıcıların azami sayısı için mutlak bir üst sınır olmamasına rağmen <command>fd_set</command> içindeki bitlerin sayısını belirten sabit bir değerdir; <command>FD_SETSIZE</command>'ıncıdan sonra bir dosya tanıtıcıyı daha <command>fd_set</command> içine koyamazsınız.
</para></funcdescr></funcsynopsis></para><para id="glibc-FD_ZERO">
<indexterm scope="glibc-vr"><primary>FD_ZERO</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>void <command>FD_ZERO</command></funcdef>
<paramdef>(fd_set *<varname>küme</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu makro <varname>küme</varname> dosya tanıtıcı kümesini boş bir küme olarak ilklendirir.
</para></funcdescr></funcsynopsis></para><para id="glibc-FD_SET">
<indexterm scope="glibc-vr"><primary>FD_SET</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>void <command>FD_SET</command></funcdef>
<paramdef>(int     <varname>dosyatanıtıcı</varname>,
 fd_set *<varname>küme</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu makro <varname>dosyatanıtıcı</varname> dosya tanıtıcısını <varname>küme</varname> dosya tanıtıcı kümesine dahil eder.
</para><para>
<varname>dosyatanıtıcı</varname> parametresi birden fazla değerlendirildiğinden yan etkilere sahip olmamalıdır .
</para></funcdescr></funcsynopsis></para><para id="glibc-FD_CLR">
<indexterm scope="glibc-vr"><primary>FD_CLR</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>void <command>FD_CLR</command></funcdef>
<paramdef>(int     <varname>dosyatanıtıcı</varname>,
 fd_set *<varname>küme</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu makro <varname>dosyatanıtıcı</varname> dosya tanıtıcısını <varname>küme</varname> dosya tanıtıcı kümesinden kaldırır.
</para><para>
<varname>dosyatanıtıcı</varname> parametresi birden fazla değerlendirildiğinden yan etkilere sahip olmamalıdır .
</para></funcdescr></funcsynopsis></para><para id="glibc-FD_ISSET">
<indexterm scope="glibc-vr"><primary>FD_ISSET</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>int <command>FD_ISSET</command></funcdef>
<paramdef>(int           <varname>dosyatanıtıcı</varname>,
 const fd_set *<varname>küme</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu makro <varname>dosyatanıtıcı</varname> dosya tanıtıcısını <varname>küme</varname> dosya tanıtıcı kümesinin bir üyesi ise sıfırdan farklı bir değerle aksi takdirde sıfırla döner.
</para><para>
<varname>dosyatanıtıcı</varname> parametresi birden fazla değerlendirildiğinden yan etkilere sahip olmamalıdır .
</para></funcdescr></funcsynopsis></para><para id="glibc-select">
<indexterm scope="glibc-fn"><primary>select</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>select</command></funcdef>
<paramdef>(int             <varname>dtsayısı</varname>,
 fd_set         *<varname>oku-dt</varname>,
 fd_set         *<varname>yaz-dt</varname>,
 fd_set         *<varname>diğer-dt</varname>,
 struct timeval *<varname>süre</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>select</command> işlevi, çağrıldığı süreci belirtilen dosya tananıtıcı kümesindeki tanıtıcılarda bir etkinlik olana kadar ya da belirtilen zamanaşımı süresi dolana kadar bekletir.
   </para><para>
<varname>oku-dt</varname> argümanı ile okumaya hazır tanıtıcılar, <varname>yaz-dt</varname> argümanı ile yazmaya hazır tanıtıcılar belirtilir. <varname>diğer-dt</varname> ile belirtilen tanıtıcılar ise olağandışı durumlara göre denetlenir. İlgilenmediğiniz durumla ilgili olan argümana boş gösterici atayabilirsiniz.
   </para><para>
Bir dosya gösterici eğer bir <command>read</command> çağrısı engellenmeyecekse okumaya hazır olarak kabul edilir. Engellenme durumları olarak okuma başlangıcının dosyanın sonunda olması veya raporlanacak bir hatanın varlığından bahsedilebilir. Bir sunucu soketi de <command>accept</command> ile <link linkend="glibc-Accepting-Connections">kabul edilebilen bir bağlantı</link> askıdaysa okumaya hazır kabul edilir. Bir istemci soketi ise <link linkend="glibc-Connecting">bağlantı tamamen kurulduğunda</link> yazmaya hazır olur.
   </para><para>
"Olağandışı durumlar" hata anlamında değildir; hatalar oluştuğunda sistem çağrıları tarafından raporlanır ve bunların tanıtıcının durumu ile ilgisi yoktur. Olağandışı durumlar bir soket üzerinde acil bir iletinin varlığı gibi durumlardır. (Acil iletiler hakkında <xref linkend="glibc-Sockets"/> bölümünde bilgi bulabilirsiniz.)
   </para><para>
<command>select</command> işlevi sadece ilk <varname>dtsayısı</varname> dosya tanıtıcısını denetler. <varname>dtsayısı</varname> olarak <command>FD_SETSIZE</command> çok kullanışlıdır.
   </para><para>
<varname>süre</varname> azami bekleme süresini belirtir. Bir boş gösterici belirtmişseniz bir süre sınırı olmaksızın bir dosya tanıtıcı hazır olana kadar işlev bekleyecektir. Bunun olmaması için <command>struct timeval</command> biçiminde bir <link linkend="glibc-High-Resolution-Calendar">zamanaşımı süresi belirtmelisiniz</link>. Beklemeden hangi dosya tanıtıcıların hazır olduğuna bakmak isterseniz buraya süre olarak sıfır (<command>struct timeval</command>'ın üyelerinin hepsi sıfır) belirtebilirsiniz.
   </para><para>
İşlevin normal dönüş değeri tüm kümelerde hazır olan dosya tanıtıcıların sayısıdır. Küme argümanlarının her birinde hazır olan tanıtıcılarla ilgili bilgi bulunur. <command>select</command> döndükten sonra belli bir dosya tanıtıcının girdi için hazır olup olmadığını<sbr/><command>FD_ISSET (<varname>dosyatanıtıcı</varname>, <varname>oku-dt</varname>)</command> ile öğrenebilirsiniz.
   </para><para>
<command>select</command> zamanaşımına uğramışsa sıfır ile döner.
   </para><para>
Herhangi bir sinyal <command>select</command> işlevinin anında dönmesine sebep olur. Yazılımınızda sinyaller kullanılıyorsa belirttiğiniz zamanaşımı süresince işlevin beklemede kalması mümkün olmayabilir. Bu sürenin mutlaka beklenmesini istiyorsanız <command>EINTR</command> durumunun varlığına bakarak o anki zaman değeri ile karşılaştırarak yeni bekleme süresini hesaplayıp çağrıyı yinelemelisiniz. Bunun bir örneği aşağıda verilmiştir, ayrıca <xref linkend="glibc-Interrupted-Primitives"/> bölümüne de bakın.
   </para><para>
Bir hata oluşursa işlev <command>-1</command> ile döner ve dosya tanıtıcı kümesi argümanlarında  bir değişiklik yapmaz. Aşağıdaki <command>errno</command> hata durumları bu işlev için tanımlanmıştır:
   </para><para><variablelist><varlistentry>
   <term><literal>EBADF</literal></term><listitem><para>
Dosya tanıtıcı kümelerinden biri geçersiz bir dosya tanıtıcı içeriyor
      </para></listitem></varlistentry><varlistentry>
      <term><literal>EINTR</literal></term><listitem><para>
İşlem bir sinyalle durduruldu. Bkz.  <xref linkend="glibc-Interrupted-Primitives"/>.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>EINVAL</literal></term><listitem><para>
<varname>süre</varname> argümanı geçersiz; üyelerinden biri ya negatif ya da çok büyük
      </para></listitem></varlistentry></variablelist>
</para></funcdescr></funcsynopsis></para><para>
<note><title>Taşınabilirlik Bilgisi</title><para><command>select</command> işlevi bir BSD Unix özelliğidir.</para></note>
   </para><para>
Bu örnekte bir dosya tanıtıcısının okumaya hazır olmasını belli bir süre beklemek için <command>select</command> işlevinin kullanımı gösterilmiştir. <command>input_timeout</command> işlevi çağrıldığı süreci dosya tanıtıcı üzerinde bir girdi olana kadar ya da belli bir zamanaşımına kadar bekletir.
   </para><para>
<screen>#include &lt;errno.h>
#include &lt;stdio.h>
#include &lt;unistd.h>
#include &lt;sys/types.h>
#include &lt;sys/time.h>

int
input_timeout (int filedes, unsigned int seconds)
{
  fd_set set;
  struct timeval timeout;

  /* Dosya tanıtıcı kümesini ilklendirelim. */
  FD_ZERO (&amp;set);
  FD_SET (filedes, &amp;set);

  /* Zamanaşımı yapısını ilklendirelim. */
  timeout.tv_sec = seconds;
  timeout.tv_usec = 0;

  /* select, zamanaşımına uğrarsa 0 ile,
     girdi varsa 1 ile, hata oluşursa -1 ile döner. */
  return TEMP_FAILURE_RETRY (select (FD_SETSIZE,
                                      &amp;set, NULL, NULL,
                                      &amp;timeout));
}

int
main (void)
{
  fprintf (stderr, "select %d ile döndü.\n",
            input_timeout (STDIN_FILENO, 5));
  return 0;
}</screen></para><para>
<command>select</command> işlevinin çok sayıda soketten çoklu girdi alınması ile ilgili kullanım örneğini  <xref linkend="glibc-Server-Example"/> bölümünde bulabilirsiniz.
   </para></chapter>
<chapter id="glibc-Synchronizing-I-O">
  <title>G/Ç İşlemlerinin Eşzamanlanması</title>
  <titleabbrev>Tüm G/Ç işlemlerinin tamamlandığını bilmek.</titleabbrev>
  <para>
<indexterm scope="glibc-cp"><primary>eşzamanlama</primary></indexterm>
Günümüzdeki çoğu işletim sisteminde normal G/Ç işlemleri eşzamanlı yapılmaz. Örneğin, bir <command>write</command> çağrısı normal olarak dönse bile bu, verinin ilgili ortama (örn, disk) yazılmış olduğu anlamına gelmez.
   </para><para>
Eşzamanlamanın gerektiği durumlarda, işlev dönmeden önce tüm işlemlerin tamamlanmış olduğundan emin olunmasını sağlayan özel işlevler vardır.
   </para><para id="glibc-sync">
<indexterm scope="glibc-fn"><primary>sync</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>sync</command></funcdef>
<paramdef>(void)</paramdef>
</funcprototype><funcdescr><para>
Bu işleve yapılacak bir çağrı, veri aygıta yazılana kadar dönmez. Çekirdekte içinde veri bulunan tüm tamponlar boşaltılır (veri yerine yazıldıktan sonra tampon silinir), böylece sistemin tamamı tutarlı duruma gelir (veriyi paralel yazan bir süreç yoksa).
   </para><para>
<command>sync</command> işlevinin prototipi <filename>unistd.h</filename> başlık dosyasında bulunur.
   </para><para>
Normal dönüş değeri sıfırdır.
      </para><para>
Yazılımlar çoğunlukla sistemdeki tüm verinin değil, bir dosya ile ilgili bir verinin o dosyaya yazıldığından emin olmak ister. Bu bakımdan <command>sync</command> fazla gelir.
</para></funcdescr></funcsynopsis></para><para id="glibc-fsync">
<indexterm scope="glibc-fn"><primary>fsync</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>fsync</command></funcdef>
<paramdef>(int <varname>dosyatanıtıcı</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>fsync</command> işlevi yazmak amacıyla açılmış ve tanıtıcısı <varname>dosyatanıtıcı</varname> olan dosyaya tüm veri fiziksel olarak yazılıncaya kadar dönmez.
   </para><para>
<command>fsync</command> işlevinin prototip <filename>unistd.h</filename> başlık dosyasında bulunur.
   </para><para>
Bu işlev çok evreli yazılımlarda bir iptal noktasıdır. <command>fsync</command> çağrısı sırasında evre bazı özkaynakları (bellek, dosya tanıtıcı, semafor, vb.) ayırdığında bu bir sorun olur. Evre tam bu anda bir iptal alırsa ayrılan özkaynaklar yazılım sonlanana kadar ayrılmış olarak kalır. Bu tür <command>fsync</command> çağrılarından kaçınmak için iptal eylemcileri kullanılarak korunulmalıdır.
   </para><para>
İşlevin normal dönüş değeri sıfırdır, bir hata oluşmuşsa <command>-1</command> ile döner. Aşağıdaki <varname>errno</varname> hata durumları bu işlev için tanımlanmıştır:
   </para><para><variablelist><varlistentry>
   <term><literal>EBADF</literal></term><listitem><para>
<varname>dosyatanıtıcı</varname> tanıtıcısı geçersiz
      </para></listitem></varlistentry><varlistentry>
      <term><literal>EINVAL</literal></term><listitem><para>
Sistemde ilgili oluşum gerçeklenmediğinden eşzamanlama mümkün değil
      </para></listitem></varlistentry></variablelist>
</para></funcdescr></funcsynopsis></para><para>
Kimi zaman bir dosya tanıtıcı ile ilgili verinin tamamını yazmak gerekmez. Örneğin, veritabanı dosyalarına veri yazarken dosya boyutu değişmeyeceğinden dosyanın içerdiği verinin aygıta yazılması yeterlidir. Dosya ile ilgili değişiklik zamanı gibi temel veriler önemli değildir ve bu bilgilerin olduğu gibi bırakılması bir sorun çıktığında dosyanın başarıyla kurtarılmasını engellemez.
   </para><para id="glibc-fdatasync">
<indexterm scope="glibc-fn"><primary>fdatasync</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>fdatasync</command></funcdef>
<paramdef>(int <varname>dosyatanıtıcı</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>fdatasync</command> çağrıldığında, dosya verisinin tamamı aygıta yazılmadan dönmez. Bekleyen tüm G/Ç işlemleri için parçalar veri bütünlüğünü sağlayacak şekilde birleştirilir.
   </para><para>
Tüm sistemler <command>fdatasync</command> işlemini gerçekleştirmez. Bu işlevselleğin olmadığı sistemlerde <command>fdatasync</command> işlemleri, gerçekleştirilen eylemler <command>fdatasync</command> için gereken işlemlerin bir üst kümesi olarak bir <command>fsync</command> çağrısı ile benzeştirilir.
   </para><para>
<command>fdatasync</command> işlevinin prototip <filename>unistd.h</filename> başlık dosyasında bulunur.
   </para><para>
İşlevin normal dönüş değeri sıfırdır, bir hata oluşmuşsa <command>-1</command> ile döner. Aşağıdaki <varname>errno</varname> hata durumları bu işlev için tanımlanmıştır:
   </para><para><variablelist><varlistentry>
   <term><literal>EBADF</literal></term><listitem><para>
<varname>dosyatanıtıcı</varname> tanıtıcısı geçersiz
      </para></listitem></varlistentry><varlistentry>
      <term><literal>EINVAL</literal></term><listitem><para>
Sistemde ilgili oluşum gerçeklenmediğinden eşzamanlama mümkün değil
      </para></listitem></varlistentry></variablelist>
    </para></funcdescr></funcsynopsis></para></chapter>
<chapter id="glibc-Asynchronous-I-O">
  <title>Eşzamansız G/Ç</title>
  <titleabbrev>G/Ç işlemlerinin birarada yapılması.</titleabbrev>
  <para>
POSIX.1b standardı G/Ç işlemlerinde beklemelerden kaynaklanan zaman kaybını en aza indiren yeni bir G/Ç işlemleri kümesi tanımlar. Yeni işlevler bir yazılımın birden fazla G/Ç işlemini ilklendirmesini ve G/Ç işlemlerini birarada (paralel) gerçekleştirdikten hemen sonra yazılımın normal çalışmasına dönmesini mümkün kılar. Bu işlevsellik varsa <command>unistd.h</command> dosyasında <command>_POSIX_ASYNCHRONOUS_IO</command> sembolü tanımlıdır.
   </para><para>
Bu işlevler, gerçek zamanlı işlevler içeren <command>librt</command> isimli kütüphanenin bir parçasıdır. Aslında <command>libc</command> kodunun parçası değildir. Bu işlevlerin gerçeklenmesi çekirdekteki destek (varsa) kullanılarak ya da kullanıcı seviyesinde evrelere tabanlanmış bir gerçekleme kullanılarak yapılabilir. Son durumda uygulamaları <command>librt</command> kütüphanesinden başka <command>libpthread</command> evre kütüphanesi ile de ilintilemek gerekir.
   </para><para>
Tüm eşzamansız G/Ç işlemleri önceden açılmış dosyalar üzerinde yapılır. Bir dosya üzerinde keyfi manada çok sayıda işlem yapılıyor olabilir. Eşzamansız G/Ç işlemleri <command>struct aiocb</command> isimli ("AIO control block" kısaltması) bir veri yapısı kullanılarak denetlenir. <command>struct aiocb</command> yapısı <filename>aio.h</filename> başlık dosyasında tanımlıdır.
   </para><para id="glibc-aiocb">
<indexterm scope="glibc-tp"><primary sortas="aiocb">struct aiocb</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü">
<funcdef>struct <command>aiocb</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
POSIX.1b standardı <command>struct aiocb</command> yapısının en azından aşağıdaki listede açıklanan üyelere sahip olmasını zorunlu kılar. Gerçekleme tarafından kullanılan daha fazla eleman olabilir, ancak bu elemanlara bağımlılık taşınabilir olmayacağından buna şiddetle karşı çıkılır.
   </para><para><glosslist><glossentry><glossterm>
   <literal>int <command>aio_fildes</command></literal>
   </glossterm><glossdef><para>
Bu eleman işlem için kullanılan dosya tanıtıcıyı içerir. Geçerli bir tanıtıcı olmalıdır, aksi takdirde işlem başarısız olur.
      </para><para>
Dosya üzerinde açılan aygıt konumlama işlemlerine izin vermelidir. Örneğin, <command>lseek</command> çağrılarının hataya yolaçtığı uçbirim benzeri aygıtlar üzerinde eşzamansız G/Ç işlemleri yapılması mümkün değildir.
   </para></glossdef></glossentry><glossentry><glossterm>
   <literal>off_t <command>aio_offset</command></literal>
   </glossterm><glossdef><para>
Dosyada işlem (girdi ya da çıktı) yapılacak dosya konumunu belirtir. İşlem keyfi sırada yapıldığından ve bir dosya tanıtıcı üzerinde birden fazla işlem başlatıldığından bunun dosya tanıtıcısının o anki okuma/yazma konumu olduğundan bahsedilemez.
   </para></glossdef></glossentry><glossentry><glossterm>
   <literal>volatile void *<command>aio_buf</command></literal>
   </glossterm><glossdef><para>
Verinin yazıldığı ya da okunan verinin saklandığı tampona göstericidir.
   </para></glossdef></glossentry><glossentry><glossterm>
   <literal>size_t <command>aio_nbytes</command></literal>
   </glossterm><glossdef><para><command>aio_buf</command> ile gösterilen tamponun uzunluğudur.
   </para></glossdef></glossentry><glossentry><glossterm>
   <literal>int <command>aio_reqprio</command></literal>
   </glossterm><glossdef><para>Eğer platform <command>_POSIX_PRIORITIZED_IO</command> ve <command>_POSIX_PRIORITY_SCHEDULING</command> ile tanımlanmışsa, eşzamansız G/Ç istekleri o anki zamanlama önceliğine göre işlenir. <command>aio_reqprio</command> elemanı eşzamansız G/Ç işlemini daha düşük önceliğe ayarlamakta kullanılabilir.
   </para></glossdef></glossentry><glossentry><glossterm>
   <literal>struct sigevent <command>aio_sigevent</command></literal>
   </glossterm><glossdef><para>Çağıran sürecin işlem sonlandığında nasıl uyarılacağını belirtir. <command>sigev_notify</command> elemanının değeri <command>SIGEV_NONE</command> ise uyarı gönderilmez. <command>SIGEV_SIGNAL</command> ise <command>sigev_signo</command> tarafından saptanan sinyal gönderilir. Aksi takdirde, <command>sigev_notify</command> elemanının değeri <command>SIGEV_THREAD</command> olmalıdır. Bu durumda, <command>sigev_notify_function</command> tarafından gösterilen işlev çalıştırılarak  başlatılan bir evre oluşturulur.
   </para></glossdef></glossentry><glossentry><glossterm>
   <literal>int <command>aio_lio_opcode</command></literal>
   </glossterm><glossdef><para>
Bu eleman sadece <command>lio_listio</command> ve <command>lio_listio64</command> işlevleri tarafından kullanılır. Bu işlevler bir kerede birden fazla keyfi işlemin başlatılmasını mümkün kıldığından ve her işlem bir girdi ya da bir çıktı (ya da hiçbir şey) olabildiğinden, bilgi denetim bloğunda saklanmalıdır. Olası değerler şunlardır:
      </para><para><variablelist><varlistentry>
      <term><literal>LIO_READ</literal></term><listitem><para>
Bir okuma işlemi başlatır. Okuma <command>aio_offset</command>'deki konumdan başlar ve okunan ilk <command>aio_nbytes</command> bayt <command>aio_buf</command> ile gösterilen tamponda saklanır.
         </para></listitem></varlistentry><varlistentry>
         <term><literal>LIO_WRITE</literal></term><listitem><para>
Bir yazma işlemi başlatır. <command>aio_buf</command>'dan başlayan  <command>aio_nbytes</command> bayt, dosyaya <command>aio_offset</command> konumdan itibaren yazılır.
         </para></listitem></varlistentry><varlistentry>
         <term><literal>LIO_NOP</literal></term><listitem><para>
Hiçbir şey yapılmaz. Bu değer <command>struct aiocb</command> dizisi delikler içerdiğinde kimi zaman kullanışlı olur; örneğin, dizinin tamamında elde edilememiş bazı değerlerle <command>lio_listio</command> çağrısı yapmak.
         </para></listitem></varlistentry></variablelist>
       </para></glossdef></glossentry></glosslist>
     </para><para>
Kaynak dosyası <command>_FILE_OFFSET_BITS == 64</command> ile derlenmişse 32 bitlik sistemlerde bu tür aslında <command>struct aiocb64</command> yapısına karşılıktır. Yani 32 bitlik arayüz 64 bitlik olanıyla değiştirilir.
</para></funcdescr></funcsynopsis></para><para>
LFS'de tanımlı eşzamansız G/Ç işlevleri ile kullanmak amacıyla tanımlanmış benzer bir veri türü vardır. Bu yapının üyelerinin türleri daha geniş veri türleridir. Bunun dışında her iki yapının üyelerinin isimleri aynıdır.
   </para><para id="glibc-aiocb64">
<indexterm scope="glibc-tp"><primary sortas="aiocb64">struct aiocb64</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü">
<funcdef>struct <command>aiocb64</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
   <glosslist><glossentry><glossterm>
   <literal>int <command>aio_fildes</command></literal>
   </glossterm><glossdef><para>
Bu eleman işlem için kullanılan dosya tanıtıcıyı içerir. Geçerli bir tanıtıcı olmalıdır, aksi takdirde işlem başarısız olur.
      </para><para>
Dosya üzerinde açılan aygıt konumlama işlemlerine izin vermelidir. Örneğin, <command>lseek</command> çağrılarının hataya yolaçtığı uçbirim benzeri aygıtlar üzerinde eşzamansız G/Ç işlemleri yapılması mümkün değildir.
   </para></glossdef></glossentry><glossentry><glossterm>
   <literal>off64_t <command>aio_offset</command></literal>
   </glossterm><glossdef><para>
Dosyada işlem (girdi ya da çıktı) yapılacak dosya konumunu belirtir. İşlem keyfi sırada yapıldığından ve bir dosya tanıtıcı üzerinde birden fazla işlem başlatıldığından bunun dosya tanıtıcısının o anki okuma/yazma konumu olduğundan bahsedilemez.
   </para></glossdef></glossentry><glossentry><glossterm>
   <literal>volatile void *<command>aio_buf</command></literal>
   </glossterm><glossdef><para>
Verinin yazıldığı ya da okunan verinin saklandığı tampona göstericidir.
   </para></glossdef></glossentry><glossentry><glossterm>
   <literal>size_t <command>aio_nbytes</command></literal>
   </glossterm><glossdef><para><command>aio_buf</command> ile gösterilen tamponun uzunluğudur.
   </para></glossdef></glossentry><glossentry><glossterm>
   <literal>int <command>aio_reqprio</command></literal>
   </glossterm><glossdef><para>
<command>_POSIX_PRIORITIZED_IO</command> ve <command>_POSIX_PRIORITY_SCHEDULING</command> ile tanımlanmışsa, eşzamansız G/Ç istekleri o anki zamanlama önceliğine göre işlenir. <command>aio_reqprio</command> elemanı eşzamansız G/Ç işlemini daha düşük önceliğe ayarlamakta kullanılabilir.
   </para></glossdef></glossentry><glossentry><glossterm>
   <literal>struct sigevent <command>aio_sigevent</command></literal>
   </glossterm><glossdef><para>
Çağıran sürecin işlem sonlandığında nasıl uyarılacağını belirtir. <command>sigev_notify</command> elemanının değeri <command>SIGEV_NONE</command> ise uyarı gönderilmez. <command>SIGEV_SIGNAL</command> ise <command>sigev_signo</command> tarafından saptanan sinyal gönderilir. Aksi takdirde, <command>sigev_notify</command> elemanının değeri <command>SIGEV_THREAD</command> olmalıdır. Bu durumda, <command>sigev_notify_function</command> tarafından gösterilen işlev çalıştırılarak  başlatılan bir evre oluşturulur.
   </para></glossdef></glossentry><glossentry><glossterm>
    <literal>int <command>aio_lio_opcode</command></literal>
    </glossterm><glossdef><para>
Bu eleman sadece <command>lio_listio</command> ve <command>lio_listio64</command> işlevleri tarafından kullanılır. Bu işlevler bir kerede birden fazla keyfi işlemin başlatılmasını mümkün kıldığından ve her işlem bir girdi ya da bir çıktı (ya da hiçbir şey) olabildiğinden, bilgi denetim bloğunda saklanmalıdır.  Olası değerlerin açıklamaları için <command>struct aiocb</command> yapısında bu üyenin açıklamasına bakınız.
      </para></glossdef></glossentry></glosslist>
</para></funcdescr></funcsynopsis></para><para>
Kaynak dosyası <command>_FILE_OFFSET_BITS == 64</command> ile derlenmişse 32 bitlik sistemlerde bu türe <command>struct aiocb</command> ismiyle erişilir. Yani 32 bitlik arayüz 64 bitlik olanıyla değiştirilir.
   </para>
  <sect1 id="glibc-Asynchronous-Reads-Writes">
    <title>Eşzamansız Okuma ve Yazma İşlemleri</title>
    <para id="glibc-aio_read">
<indexterm scope="glibc-fn"><primary>aio_read</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>aio_read</command></funcdef>
<paramdef>(struct aiocb *<varname>aiocbp</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev bir eşzamansız okuma işlemini ilklendirir. İşlem kuyruğa alındığında ya da bir hata oluştuğunda işlev beklemeksizin döner.
    </para><para>
Tanıtıcısı <command>aiocbp->aio_fildes</command> olan dosyanın <command>aiocbp->aio_offset</command> bayttan itibaren ilk <command>aiocbp->aio_nbytes</command> baytı <command>aiocbp->aio_buf</command>'dan başlayan tampona yazılır.
    </para><para>
Öncelikli G/Ç destekleyen platformlarda <command>aiocbp->aio_reqprio</command> değeri, istek kuyruğa alınmadan önceki önceliği ayarlamakta kullanılır.
    </para><para>
İşlevin çağrıldığı süreç okuma isteğinin sonlaması halinde <command>aiocbp->aio_sigevent</command> değerine göre uyarılır.
    </para><para>
<command>aio_read</command> işlevinin normal dönüş değeri sıfırdır. İşlem kuyruğa alınmadan önce bir hata oluşmuşsa işlev <command>-1</command> ile döner ve bu durumda <command>errno</command> değişkenine şu değerlerden biri atanır:
    </para><para><variablelist><varlistentry>
    <term><literal>EAGAIN</literal></term><listitem><para>
Özkaynak sınırları (geçici olarak) aşıldığı için istek kuyruğa alınmadı
       </para></listitem></varlistentry><varlistentry>
       <term><literal>ENOSYS</literal></term><listitem><para>
<command>aio_read</command> işlevi gerçeklenmedi
       </para></listitem></varlistentry><varlistentry>
       <term><literal>EBADF</literal></term><listitem><para>
<command>aiocbp->aio_fildes</command> tanıtıcısı geçersiz. Bu hata durumu isteğin kuyruğa alınmasından önce tanınmamış olabilir ve bu bakımdan bu hata ayrıca eşzamansız olarak sinyallenir.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>EINVAL</literal></term><listitem><para>
<command>aiocbp->aio_offset</command> ya da <command>aiocbp->aio_reqpiro</command> değeri geçersiz.  Bu hata durumu isteğin kuyruğa alınmasından önce tanınmamış olabilir ve bu bakımdan bu hata ayrıca eşzamansız olarak sinyallenir.
       </para></listitem></varlistentry></variablelist>
     </para><para>
<command>aio_read</command> sıfırla dönerse, isteğin o anki durumu <command>aio_error</command> ve <command>aio_return</command> işlevleri ile sorgulanabilir. <command>aio_error</command> işlevinden dönen değer <command>EINPROGRESS</command> oldukça işlem henüz tamamlanmamış demektir. Eğer <command>aio_error</command> sıfırla dönerse işlem başarıyla bitmiş demektir; aksi takdirde, dönen değer bir hata kodu olarak değerlendirilmelidir. İşlem sonlanmışsa, işlemin sonucu  <command>aio_return</command> çağrısı ile sağlanabilir. Dönen değer, eşdeğer <command>read</command> çağrısından dönen değerle aynıdır. <command>aio_error</command> çağrısından dönebilecek olası hata durumları şunlardır:
    </para><para><variablelist><varlistentry>
    <term><literal>EBADF</literal></term><listitem><para>
<command>aiocbp->aio_fildes</command> tanıtıcısı geçersiz
       </para></listitem></varlistentry><varlistentry>
       <term><literal>ECANCELED</literal></term><listitem><para>
İşlem bitmeden durduruldu (bkz. <xref linkend="glibc-Cancel-AIO-Operations"/>)
       </para></listitem></varlistentry><varlistentry>
       <term><literal>EINVAL</literal></term><listitem><para>
<command>aiocbp->aio_offset</command> değeri geçersiz
       </para></listitem></varlistentry></variablelist>
     </para><para>
Kaynak dosyası <command>_FILE_OFFSET_BITS == 64</command> ile derlenmişse 32 bitlik sistemlerde bu işlev aslında <command>aio_read64</command> işlevine karşılıktır. Yani 32 bitlik arayüz 64 bitlik olanıyla değiştirilir.
</para></funcdescr></funcsynopsis></para><para id="glibc-aio_read64">
<indexterm scope="glibc-fn"><primary>aio_read64</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>aio_read64</command></funcdef>
<paramdef>(struct aiocb *<varname>aiocbp</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev <command>aio_read</command> işlevine çok benzer. Tek fark, 32 bitlik makinelerde dosya tanıtıcısının büyük dosya kipinde açılmış olmasıdır. İçsel olarak, <command>aio_read64</command> işlevi okumak için dosya konumlayıcıyı doğru yere konumlandırırken <command>lseek64</command> (<xref linkend="glibc-File-Position-Primitive"/>) işlevselliğini kullanır, benzer şekilde <command>aio_read</command> işlevi de <command>lseek</command>  işlevselliğini kullanır.
    </para><para>
Kaynak dosyası <command>_FILE_OFFSET_BITS == 64</command> ile derlenmişse 32 bitlik sistemlerde bu işleve <command>aio_read</command> ismiyle erişilir. Yani 32 bitlik arayüz 64 bitlik olanıyla değiştirilir.
</para></funcdescr></funcsynopsis></para><para>
Veriyi bir dosyaya eşzamansız yazmak için çok benzer bir arayüze sahip eşdeğer bir işlev çifti vardır.
    </para><para id="glibc-aio_write">
<indexterm scope="glibc-fn"><primary>aio_write</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>aio_write</command></funcdef>
<paramdef>(struct aiocb *<varname>aiocbp</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev bir eşzamansız yazma işlemini ilklendirir. İşlem kuyruğa alındığında ya da bir hata oluştuğunda işlev beklemeksizin döner.
    </para><para>
<command>aiocbp->aio_buf</command>'dan başlayan tampondaki ilk <command>aiocbp->aio_offset</command> bayt tanıtıcısı <command>aiocbp->aio_fildes</command> olan dosyaya <command>aiocbp->aio_offset</command> bayttan itibaren yazılır.
    </para><para>
Öncelikli G/Ç destekleyen platformlarda <command>aiocbp->aio_reqprio</command> değeri, istek kuyruğa alınmadan önceki önceliği ayarlamakta kullanılır.
    </para><para>
İşlevin çağrıldığı süreç yazma isteğinin sonlaması halinde <command>aiocbp->aio_sigevent</command> değerine göre uyarılır.
    </para><para>
<command>aio_write</command> işlevinin normal dönüş değeri sıfırdır. İşlem kuyruğa alınmadan önce bir hata oluşmuşsa işlev <command>-1</command> ile döner ve bu durumda <command>errno</command> değişkenine şu değerlerden biri atanır:
    </para><para><variablelist><varlistentry>
    <term><literal>EAGAIN</literal></term><listitem><para>
Özkaynak sınırları (geçici olarak) aşıldığı için istek kuyruğa alınmadı
       </para></listitem></varlistentry><varlistentry>
       <term><literal>ENOSYS</literal></term><listitem><para>
<command>aio_write</command>  işlevi gerçeklenmedi
       </para></listitem></varlistentry><varlistentry>
       <term><literal>EBADF</literal></term><listitem><para>
<command>aiocbp->aio_fildes</command> tanıtıcısı geçersiz. Bu hata durumu isteğin kuyruğa alınmasından önce tanınmamış olabilir ve bu bakımdan bu hata ayrıca eşzamansız olarak sinyallenir.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>EINVAL</literal></term><listitem><para>
<command>aiocbp->aio_offset</command> ya da <command>aiocbp->aio_reqpiro</command> değeri geçersiz.  Bu hata durumu isteğin kuyruğa alınmasından önce tanınmamış olabilir ve bu bakımdan bu hata ayrıca eşzamansız olarak sinyallenir.
       </para></listitem></varlistentry></variablelist>
     </para><para>
<command>aio_write</command> sıfırla dönerse, isteğin o anki durumu <command>aio_error</command> ve <command>aio_return</command> işlevleri ile sorgulanabilir. <command>aio_error</command> işlevinden dönen değer <command>EINPROGRESS</command> oldukça işlem henüz tamamlanmamış demektir. Eğer <command>aio_error</command> sıfırla dönerse işlem başarıyla bitmiş demektir; aksi takdirde, dönen değer bir hata kodu olarak değerlendirilmelidir. İşlem sonlanmışsa, işlemin sonucu  <command>aio_return</command> çağrısı ile sağlanabilir. Dönen değer, eşdeğer <command>write</command> çağrısından dönen değerle aynıdır. <command>aio_error</command> çağrısından dönebilecek olası hata durumları şunlardır:
    </para><para><variablelist><varlistentry>
    <term><literal>EBADF</literal></term><listitem><para>
<command>aiocbp->aio_fildes</command> tanıtıcısı geçersiz
       </para></listitem></varlistentry><varlistentry>
       <term><literal>ECANCELED</literal></term><listitem><para>
İşlem bitmeden durduruldu (bkz. <xref linkend="glibc-Cancel-AIO-Operations"/>)
       </para></listitem></varlistentry><varlistentry>
       <term><literal>EINVAL</literal></term><listitem><para>
<command>aiocbp->aio_offset</command> değeri geçersiz
       </para></listitem></varlistentry></variablelist>
     </para><para>
Kaynak dosyası <command>_FILE_OFFSET_BITS == 64</command> ile derlenmişse 32 bitlik sistemlerde bu işlev aslında <command>aio_write64</command> işlevine karşılıktır. Yani 32 bitlik arayüz 64 bitlik olanıyla değiştirilir.
</para></funcdescr></funcsynopsis></para><para id="glibc-aio_write64">
<indexterm scope="glibc-fn"><primary>aio_write64</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>aio_write64</command></funcdef>
<paramdef>(struct aiocb *<varname>aiocbp</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev <command>aio_write</command> işlevine çok benzer. Tek fark, 32 bitlik makinelerde dosya tanıtıcısının büyük dosya kipinde açılmış olmasıdır. İçsel olarak, <command>aio_write64</command> işlevi okumak için dosya konumlayıcıyı doğru yere konumlandırırken <command>lseek64</command> (<xref linkend="glibc-File-Position-Primitive"/>) işlevselliğini kullanır, benzer şekilde <command>aio_write</command> işlevi de <command>lseek</command>  işlevselliğini kullanır.
    </para><para>
Kaynak dosyası <command>_FILE_OFFSET_BITS == 64</command> ile derlenmişse 32 bitlik sistemlerde bu işleve <command>aio_write</command> ismiyle erişilir. Yani 32 bitlik arayüz 64 bitlik olanıyla değiştirilir.
</para></funcdescr></funcsynopsis></para><para>
Az ya da çok geleneksel arayüzle bu işlevlerden başka, POSIX.1b bir defada birden fazla karışık okuma ve yazma işlemini ilklendiren bir işlev daha tanımlar. Bu işlev <command>readv</command> ve <command>writev</command>  işlevlerinin bir birleşimi gibidir.
    </para><para id="glibc-lio_listio">
<indexterm scope="glibc-fn"><primary>lio_listio</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>lio_listio</command></funcdef>
<paramdef>(int                 <varname>kip</varname>,
 struct aiocb *const <varname>liste</varname>[],
 int                 <varname>isteksayısı</varname>,
 struct sigevent    *<varname>sinyal</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>lio_listio</command> işlevi bir defada birden fazla okuma ve yazma isteğini kuyruğa almakta kullanılabilir. İsteklerin hepsi aynı dosya için, farklı dosyalar için ya da bunlar arasındaki işlemler için olabilir.
    </para><para>
<command>lio_listio</command> işlevi <varname>isteksayısı</varname> isteği <varname>liste</varname> ile gösterilen diziden alır. Uygulanacak işlem <varname>liste</varname> dizisinin her elemenındaki <command>aio_lio_opcode</command> elemanından saptanır. Bu alandaki değer <command>LIO_READ</command> ise dizinin bu elemenına bir <command>aio_read</command> çağrısı yapılmış gibi (bir farkla, sonlanma aşağıda belirtileceği gibi farklı bir yolla sinyallenir) okuma işlemi kuyruğa alınır. <command>aio_lio_opcode</command> üyesinin değeri <command>LIO_WRITE</command> ise yazma işlemi kuyruğa alınır. Bunlar dışında üyenin değeri <command>LIO_NOP</command> olmalıdır, bu durumda dizinin bu elemanı basitçe yoksayılır. Yoksayma işlemi, bütün elemenlar için işlem yapılmayacaksa istekleri içeren dizinin eleman sayısını değiştirmeden isteklerin ele alınması için faydalıdır. Başka durumda, <command>lio_listio</command> çağrısının tüm istekleri işleme sokmadan durdurulduğu durumdur (bkz. <xref linkend="glibc-Cancel-AIO-Operations"/>). Bu durumda işleme sokulmayan istekler yinelenirken işleme sokulmuş istekler yoksayılabilir.
    </para><para>
<varname>liste</varname> ile gösterilen dizinin yoksayılmayan elemanlarının üyeleri, evvelce <command>aio_read</command> ve <command>aio_write</command> işlevlerinin açıklamasında belirtilen işlemlere uygun değerlere sahip olmalıdır.
    </para><para>
<varname>kip</varname> argümanı <command>lio_listio</command> işlevinin tüm istekler kuyruğa alındıktan sonra nasıl davranacağını saptamakta kullanılır. <varname>kip</varname> olarak <command>LIO_WAIT</command> belirtilmişse, tüm istekler tamamlanana kadar işlev bekler. Aksi takdirde, <varname>kip</varname> olarak <command>LIO_NOWAIT</command> verilebilir ki, bu durumda işlev, işlemler kuyruğa alındıktan hemen sonra işlemlerin bitmesini beklenmeden döner. Bu durumda, işlevi çağıran süreç tüm istekler için <varname>sinyal</varname> ile belirtilen değere bağlı olarak sonlanmaları ile ilgili bir uyarı alır. <varname>sinyal</varname> olarak <command>NULL</command> belirtilmişse herhangi bir uyarı gönderilmez. Aksi takdirde ya bir sinyal gönderilir ya da <command>aio_read</command> ve <command>aio_write</command> işlevlerinin açıklamalarında belirtildiği gibi bir evre başlatılır.
    </para><para>
<varname>kip</varname> değeri <command>LIO_WAIT</command> ise ve tüm istekler yerine getirilmişse işlevin dönüş değeri sıfır olur. Aksi takdirde işlev <command>-1</command> ile döner ve hata durumu <command>errno</command> değişkenine atanır. Hangi isteklerin başarısız olduğunu bulmak için <varname>liste</varname> dizisindeki her eleman için bir <command>aio_error</command> çağrısı yapılmalıdır.
    </para><para>
<varname>kip</varname> değeri <command>LIO_NOWAIT</command> ise tüm istekler düzgün bir şekilde kuyruğa alınmışsa işlevin dönüş değeri sıfır olur. İsteklerin mevcut durumu <command>aio_error</command> ve <command>aio_return</command> çağrıları ile saptanabilir. İşlev bu kipte <command>-1</command> ile dönerse, hata durumu <command>errno</command> değişkenine atanır. Bir istek henüz sonlanmamışsa bir <command>aio_error</command> çağrısı <command>EINPROGRESS</command> döndürür. Değer farklı olursa, istek bitmiş demektir, <command>aio_error</command> ya bir hata değeri ya da sıfır ile döner, bu durumda işlemin sonucu <command>aio_return</command> kullanılarak saptanabilir.
    </para><para>
<command>errno</command> için olası değerler şunlardır:
    </para><para><variablelist><varlistentry>
    <term><command>EAGAIN</command></term><listitem><para>
Tüm istekleri kuyruğa almak için gereken özkaynaklar şu anda yok. Hangi isteğin başarısız olduğunu bulmak için <varname>liste</varname> dizisinin tüm elemanları için hata durumuna bakmalısınız.
       </para><para>
Bu hatanın başka bir sebebi de eşzamansız G/Ç isteklerinin sistem çapında sınırları aşması olabilirdi. Bu durum GNU sisteminde keyfi sınırlar olmadığından mümkün değildir.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>EINVAL</literal></term><listitem><para>
Ya <varname>kip</varname> parametresi geçersiz ya da <varname>isteksayısı </varname><literal>> </literal><command>AIO_LISTIO_MAX</command>.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>EIO</literal></term><listitem><para>
Bir ya da daha fazla G/Ç isteği başarısız oldu. Hangi isteğin başarısız olduğunu bulmak için <varname>liste</varname> dizisinin tüm elemanları için hata durumuna bakmalısınız.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>ENOSYS</literal></term><listitem><para>
<command>lio_listio</command> işlevi desteklenmiyor
       </para></listitem></varlistentry></variablelist>
     </para><para>
<varname>kip</varname> değeri <command>LIO_NOWAIT</command> ise ve istek iptal edilmişse bu istek için <command>aio_error</command> çağrısından dönen hata durumu <command>ECANCELED</command> olur.
    </para><para>
Kaynak dosyası <command>_FILE_OFFSET_BITS == 64</command> ile derlenmişse 32 bitlik sistemlerde bu işlev aslında <command>lio_listio64</command> işlevine karşılıktır. Yani 32 bitlik arayüz 64 bitlik olanıyla değiştirilir.
</para></funcdescr></funcsynopsis></para><para id="glibc-lio_listio64">
<indexterm scope="glibc-fn"><primary>lio_listio64</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>lio_listio64</command></funcdef>
<paramdef>(int                 <varname>kip</varname>,
 struct aiocb *const <varname>liste</varname>,
 int                 <varname>isteksayısı</varname>,
 struct sigevent    *<varname>sinyal</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev <command>lio_listio</command> işlevinin benzeridir. Tek fark, 32 bitlik makinelerde dosya tanıtıcısının büyük dosya kipinde açılmış olmasıdır. İçsel olarak, <command>lio_listio64</command> işlevi okumak için dosya konumlayıcıyı doğru yere konumlandırırken <command>lseek64</command> (<xref linkend="glibc-File-Position-Primitive"/>) işlevselliğini kullanır, benzer şekilde <command>lio_listio</command> işlevi de <command>lseek</command>  işlevselliğini kullanır.
    </para><para>
Kaynak dosyası <command>_FILE_OFFSET_BITS == 64</command> ile derlenmişse 32 bitlik sistemlerde bu işleve <command>lio_listio</command> ismiyle erişilir. Yani 32 bitlik arayüz 64 bitlik olanıyla değiştirilir.
  </para></funcdescr></funcsynopsis></para></sect1>
  <sect1 id="glibc-Status-of-AIO-Operations">
    <title>Eşzamansız G/Ç İşlemlerinin Durumu</title>
    <titleabbrev>Eşzamansız G/Ç işlemlerinin durumunu öğrenilmesi</titleabbrev>
    <para>
Geçtiğimiz bölümde değinilen işlevlerin açıklamalarında da belirtildiği gibi, bir G/Ç isteğinin durumu hakkında bilgi edinilmesi mümkün olmalıdır. İşlem gerçekten eşzamansız olarak gerçekleştirildiğinde (<command>aio_read</command> ve <command>aio_write</command> ile ilgili olarak <command>lio_listio</command> işlevinde kip olarak <command>LIO_NOWAIT</command> belirtilmesi durumu), kimi zaman bir isteğin sonlanmış olup olmadığı, sonlanmışsa sonucun ne olduğunu bilmek gerekir. Aşağıdaki iki işlev bu çeşit bilgileri almak için tasarlanmıştır.
    </para><para id="glibc-aio_error">
<indexterm scope="glibc-fn"><primary>aio_error</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>aio_error</command></funcdef>
<paramdef>(const struct aiocb *<varname>aiocbp</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev <varname>aiocbp</varname> ile gösterilen <command>struct aiocb</command> yapısında açıklanan isteğin hata durumunu saptar. İstek henüz sonlanmamışsa daima <command>EINPROGRESS</command> döner. İstek sonlandıktan sonra <command>aio_error</command> işlevi istek başarıyla tamamlanmışsa sıfır ile döner, aksi takdirde isteğin <command>read</command>, <command>write</command> ya da <command>fsync</command> işlevlerinin sonucu olarak <command>errno</command> hata durumlarının karşılığı olan bir değer döner.
    </para><para>
İşlev gerçeklenmemişse <command>ENOSYS</command> dönebilir. Eğer <varname>aiocbp</varname> parametresi dönüş durumu bilinmeyen bir eşzamansız işlemi belirtiyorsa işlev  <command>EINVAL</command> değeriyle de dönebilir.
    </para><para>
Kaynak dosyası <command>_FILE_OFFSET_BITS == 64</command> ile derlenmişse 32 bitlik sistemlerde bu işlev aslında <command>aio_error64</command> işlevine karşılıktır. Yani 32 bitlik arayüz 64 bitlik olanıyla değiştirilir.
</para></funcdescr></funcsynopsis></para><para id="glibc-aio_error64">
<indexterm scope="glibc-fn"><primary>aio_error64</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>aio_error64</command></funcdef>
<paramdef>(const struct aiocb64 *<varname>aiocbp</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev, argümanının <command>struct aiocb64</command> türünde bir değişken olması dışında <command>aio_error</command> işlevine benzer.
    </para><para>
Kaynak dosyası <command>_FILE_OFFSET_BITS == 64</command> ile derlenmişse 32 bitlik sistemlerde bu işleve <command>aio_error</command> ismiyle erişilir. Yani 32 bitlik arayüz 64 bitlik olanıyla değiştirilir.
</para></funcdescr></funcsynopsis></para><para id="glibc-aio_return">
<indexterm scope="glibc-fn"><primary>aio_return</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>ssize_t <command>aio_return</command></funcdef>
<paramdef>(const struct aiocb *<varname>aiocbp</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev <varname>aiocbp</varname> ile gösterilen <command>struct aiocb</command> yapısında açıklanan isteğin dönüş durumunu saptar. <command>aio_error</command> işlevinin bu istek için <command>EINPROGRESS</command> döndürdüğü durumda bu işlevin dönüş değeri tanımsızdır.
    </para><para>
İstek bittikten hemen sonra bu işlev dönüş durumunu saptamak için kullanılır. Aşağıdaki çağrılar tanımlanmamış bir davranışla sonuçlanabilir. Dönüş değeri yapılan işleme göre <command>read</command>, <command>write</command> ya da <command>fsync</command> çağrılarının döndürdüğü değerdir.
    </para><para>
İşlev gerçeklenmemişse <command>ENOSYS</command> dönebilir. Eğer <varname>aiocbp</varname> parametresi dönüş durumu bilinmeyen bir eşzamansız işlemi belirtiyorsa işlev  <command>EINVAL</command> değeriyle de dönebilir.
    </para><para>
Kaynak dosyası <command>_FILE_OFFSET_BITS == 64</command> ile derlenmişse 32 bitlik sistemlerde bu işlev aslında <command>aio_return64</command> işlevine karşılıktır. Yani 32 bitlik arayüz 64 bitlik olanıyla değiştirilir.
</para></funcdescr></funcsynopsis></para><para id="glibc-aio_return64">
<indexterm scope="glibc-fn"><primary>aio_return64</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>ssize_t <command>aio_return64</command></funcdef>
<paramdef>(const struct aiocb64 *<varname>aiocbp</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev, argümanının <command>struct aiocb64</command> türünde bir değişken olması dışında <command>aio_return</command> işlevine benzer.
    </para><para>
Kaynak dosyası <command>_FILE_OFFSET_BITS == 64</command> ile derlenmişse 32 bitlik sistemlerde bu işleve <command>aio_return</command> ismiyle erişilir. Yani 32 bitlik arayüz 64 bitlik olanıyla değiştirilir.
  </para></funcdescr></funcsynopsis></para></sect1>
  <sect1 id="glibc-Synchronizing-AIO-Operations">
    <title>Eşzamansız G/Ç İşlemlerinin Eşzamanlanması</title>
    <titleabbrev>İstikrarlı duruma geçme.</titleabbrev>
    <para>
Eşzamansız işlemlerle çalışırken kimi zaman istikrarlı duruma geçmek gerekir. Bu, eşzamansız G/Ç işlemlerinde belli bir isteğin ya da belli bir istek grubunun işlenip işlenmediğinin bilinmesinin istendiği anlamına gelir. Bu, işlem sonlandıktan sonra sistem tarafından gönderilecek bir uyarı beklenerek de yapılabilirdi, fakat bu kimi zaman özkaynakların kirlenmesi anlamına gelir (özellikle hesaplama sırasında). Bunun yerine istikrar gerektiren çoğu durumda yardımcı olmak üzere POSIX.1b iki işlev tanımlamıştır.
    </para><para>
<command>aio_fsync</command> ve <command>aio_fsync64</command> işlevleri sadece <filename>unistd.h</filename> dosyasında <command>_POSIX_SYNCHRONIZED_IO</command> sembolü tanımlıysa kullanılabilir.
    </para><para id="glibc-aio_fsync">
<indexterm scope="glibc-cp"><primary>eşzamanlama</primary></indexterm>
<indexterm scope="glibc-fn"><primary>aio_fsync</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>aio_fsync</command></funcdef>
<paramdef>(int           <varname>kip</varname>,
 struct aiocb *<varname>aiocbp</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev çağrıldığında <command>aiocbp->aio_fildes</command> tanıtıcısı üzerinde işlev çağrısının çalışması esnasında kuyruktaki tüm G/Ç işlemleri eşzamanlı G/Ç tamamlama durumuna (bkz. <xref linkend="glibc-Synchronizing-I-O"/>) sokulmaya zorlanır. <command>aio_fsync</command> işlevi beklemeden hemen döner ancak, <command>aiocbp->aio_sigevent</command> ile belirtilen yöntem üzerinden uyarı sadece dosya tanıtıcısı sonlandığında ve dosya eşzamanlandığında verilir. Bu ayrıca, eşzamanlama isteğinden sonra aynı dosya tanıtıcısı için yapılan bu isteklerin etkili olmadığı anlamına gelir.
    </para><para>
<varname>kip</varname> değeri <command>O_DSYNC</command> ise eşzamanlama bir <command>fdatasync</command> çağrısı olarak, <command>O_SYNC</command> ise bir <command>fsync</command> çağrısı olarak gerçekleştirilir.
    </para><para>
Eşzamanlama oluşmadığı sürece, <varname>aiocbp</varname> ile gösterilen nesne ile yapılan <command>aio_error</command> çağrıları <command>EINPROGRESS</command> ile döner. Eşzamanlama oluştuktan sonra yapılan bir <command>aio_error</command> çağrısı eşzamanlama gerçekleşmişse sıfır ile döner; aksi takdirde, <command>fsync</command> ya da <command>fdatasync</command> çağrılarının hata durumunda <command>errno</command> değişkenine atadıkları değer ile döner. Bu durumda dosya tanıtıcısına veri yazmada istikrar anlamında hiçbir şey yapılmamış olabilir.
    </para><para>
İstek başarıyla kuyruğa alınmışsa bu işlevin dönüş değeri sıfır olur. Aksi takdirde <command>-1</command> ile döner ve <command>errno</command> değişkenine şu değerlerden biri atanır:
    </para><para><variablelist><varlistentry>
    <term><literal>EAGAIN</literal></term><listitem><para>
İstek, özkaynakların geçici yokluğundan dolayı kuyruğa alınmadı
       </para></listitem></varlistentry><varlistentry>
       <term><literal>EBADF</literal></term><listitem><para>
<command>aiocbp->aio_fildes</command> tanıtıcı ya geçersiz ya da yazmak için açılmamış
       </para></listitem></varlistentry><varlistentry>
       <term><literal>EINVAL</literal></term><listitem><para>
Ya gerçekleme G/Ç eşzamanlamasını gerçeklemiyor ya da <varname>kip</varname> değeri <command>O_DSYNC</command> veya <command>O_SYNC</command> değil
       </para></listitem></varlistentry><varlistentry>
       <term><literal>ENOSYS</literal></term><listitem><para>
İşlev desteklenmiyor
       </para></listitem></varlistentry></variablelist>
     </para><para>
Kaynak dosyası <command>_FILE_OFFSET_BITS == 64</command> ile derlenmişse 32 bitlik sistemlerde bu işlev aslında <command>aio_fsync64</command> işlevine karşılıktır. Yani 32 bitlik arayüz 64 bitlik olanıyla değiştirilir.
</para></funcdescr></funcsynopsis></para><para id="glibc-aio_fsync64">
<indexterm scope="glibc-fn"><primary>aio_fsync64</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>aio_fsync64</command></funcdef>
<paramdef>(int             <varname>kip</varname>,
 struct aiocb64 *<varname>aiocbp</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev, argümanının <command>struct aiocb64</command> türünde bir değişken olması dışında <command>aio_fsync</command> işlevine benzer.
    </para><para>
Kaynak dosyası <command>_FILE_OFFSET_BITS == 64</command> ile derlenmişse 32 bitlik sistemlerde bu işleve <command>aio_fsync</command> ismiyle erişilir. Yani 32 bitlik arayüz 64 bitlik olanıyla değiştirilir.
</para></funcdescr></funcsynopsis></para><para>
Başka bir eşzamanlama yöntemi de bir ya da daha fazla istekten oluşan belli bir küme sonlanana kadar beklemektir. Bu, sonlanma hakkında işlemi başlatan sürecin uyarılmasında <command>aio_*</command> işlevleri kullanılmasıyla mümkün olsa da bazı durumlarda bu ideal bir çözüm değildir. Sunucuya bağlı istemcileri sürekli güncel tutan bir yazılımda bazı bağlantıların yavaş bağlantılar olması nedeniyle istemcileri sırayla taranması da en iyi çözüm olmaz. Diğer taraftan, bir istemci güncellenmeden bir uyarı alan süreç yeni istemciye geçemeyeceğinden bir <command>aio_*</command> işlevinden bir uyarı ile işlemin durdurulması birşey ifade etmeyeceğinden bu da iyi bir çözüm olmaz. Bu gibi durumlar için <command>aio_suspend</command> kullanılmalıdır.
    </para><para id="glibc-aio_suspend">
<indexterm scope="glibc-fn"><primary>aio_suspend</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>aio_suspend</command></funcdef>
<paramdef>(const struct aiocb *const <varname>liste</varname>[],
 int                       <varname>isteksayısı</varname>,
 const struct timespec    *<varname>süre</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev çağrıldığında, <varname>liste</varname> dizisinin <varname>isteksayısı</varname> elemanı tarafından yapılan isteklerden en az biri tamamlanana kadar çağıran evre bekletilir. <command>aio_suspend</command> çağrısı sırasında zaten tamamlanmış bir istek varsa işlev beklemeksizin döner. Bir isteğin sonlanıp sonlanmadığı isteğin hata durumunun <command>EINPROGRESS</command> olup olmamasına bağlıdır. <varname>liste</varname>'nin <command>NULL</command> bir elemanı varsa bu girdi yoksayılır.
    </para><para>
Tamamlanan bir istek yoksa, çağıran süreç beklemeye alınır. <varname>süre</varname> argümanında <command>NULL</command> belirtilmişse, bir istek tamamlanana kadar süreç ilerlemez. <varname>süre</varname> argümanında <command>NULL</command> belirtilmemişse, belirtilen süre kadar süreç bekletilir. Bu durumda <command>aio_suspend</command> bir hata ile döner.
    </para><para>
<varname>liste</varname>'deki elemanlardan en az biri sonlanmışsa işlev sıfır değeri ile döner. Aksi takdirde <command>-1</command> ile döner, bu durumda <command>errno</command> değişkeninde şu durumlardan biri olabilir:
    </para><para><variablelist><varlistentry>
    <term><literal>EAGAIN</literal></term><listitem><para>
<varname>liste</varname>'deki elemanlardan hiçbiri belirtilen <varname>süre</varname>'de tamamlanmadı
       </para></listitem></varlistentry><varlistentry>
       <term><literal>EINTR</literal></term><listitem><para>
<command>aio_suspend</command> işlevini bir sinyal durdurdu. Bu sinyal eşzamansız G/Ç gerçeklemesi tarafından isteklerden birinin sonlanması sinyallenirken de gönderilmiş olabilir.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>ENOSYS</literal></term><listitem><para>
<command>aio_suspend</command> işlevi desteklenmiyor
       </para></listitem></varlistentry></variablelist>
     </para><para>
Kaynak dosyası <command>_FILE_OFFSET_BITS == 64</command> ile derlenmişse 32 bitlik sistemlerde bu işlev aslında <command>aio_suspend64</command> işlevine karşılıktır. Yani 32 bitlik arayüz 64 bitlik olanıyla değiştirilir.
</para></funcdescr></funcsynopsis></para><para id="glibc-aio_suspend64">
<indexterm scope="glibc-fn"><primary>aio_suspend64</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>aio_suspend64</command></funcdef>
<paramdef>(const struct aiocb64 *const <varname>liste</varname>[],
 int                         <varname>isteksayısı</varname>,
 const struct timespec      *<varname>süre</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev, argümanının <command>struct aiocb64</command> türünde bir değişken olması dışında <command>aio_suspend</command> işlevine benzer.
    </para><para>
Kaynak dosyası <command>_FILE_OFFSET_BITS == 64</command> ile derlenmişse 32 bitlik sistemlerde bu işleve <command>aio_suspend</command> ismiyle erişilir. Yani 32 bitlik arayüz 64 bitlik olanıyla değiştirilir.
  </para></funcdescr></funcsynopsis></para></sect1>
  <sect1 id="glibc-Cancel-AIO-Operations">
    <title>Eşzamansız G/Ç İşlemlerinin İptal Edilmesi</title>
    <para>
Bir ya da daha fazla istek eşzamansız olarak işlenirken, yazılması istenen bir verinin artık geçersiz hale gelmesi ve dolayısıyla bu verinin daha sonra düzeltilmesinin gerekmesi gibi bazı durumlarda seçilen bir işlemin iptal edilmesi gerekebilir. Bir örnek olarak, gelen veriyi dosyalara yazan bir uygulamanın, bir dosyaya yazılmak üzere gelmiş bir verinin kuyruğa alınacak bir başka istek ile güncellenmek istemesi verilebilir. POSIX eşzamansız G/Ç gerçeklemesi böyle bir işlev içerir, fakat bu işlevin bir isteği iptale zorlama yeteneği yoktur. Sadece bir isteğin iptalinin mümkün olup olmadığına karar vermeye yardımcı olur.
    </para><para id="glibc-aio_cancel">
<indexterm scope="glibc-fn"><primary>aio_cancel</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>aio_cancel</command></funcdef>
<paramdef>(int           <varname>dosyatanıtıcı</varname>,
 struct aiocb *<varname>aiocbp</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>aio_cancel</command> işlevi askıdaki bir ya da daha fazla isteği iptal etmek için kullanılabilir. <varname>aiocbp</varname> parametresi <command>NULL</command> ise <varname>dosyatanıtıcı</varname> ile ilgili askıdaki tüm işlemleri iptal etmeye çalışır. <varname>aiocbp</varname> parametresi <command>NULL</command> değilse, <varname>aiocbp</varname> ile gösterilen belli bir isteği iptal etmeye çalışır.
    </para><para>
Başarıyla iptal edilen istekler için isteğin sonlanması ile ilgili normal uyarı yapılmalıdır. Bunu denetleyen <command>struct sigevent</command> nesnesine bağlı olarak hiçbir şey yapılmaz, bir sinyal gönderilir ya da evre başlatılır. İstek iptal edilemezse, işlem, gerçekleştikten sonra normal yolla sonlanır.
    </para><para>
Bir istek başarıyla iptal edildikten sonra, bu istek için yapılan bir <command>aio_error</command> çağrısı <command>ECANCELED</command> ile, <command>aio_return</command> ise <command>-1</command> ile döner. Eğer istek iptal edilmemişse ve hala işlenmekteyse hata durumu <command>EINPROGRESS</command> olur.
    </para><para>
Sonlanmadan iptal edilmiş bir istek varsa, işlevin dönüş değeri <command>AIO_CANCELED</command> olur. İptal edilmemiş istek ya da istekler varsa, dömüş değeri <command>AIO_NOTCANCELED</command> olur. Bu durumda (<varname>aiocbp</varname>'nin <command>NULL</command> olarak belirtildiği durum) iptal edilemeyen istekleri bulmak için <command>aio_error</command> kullanılmalıdır. Tüm istekler iptal edilmişse <command>aio_cancel</command> işlevinin dönüş değeri <command>AIO_ALLDONE</command> olacaktır.
    </para><para>
<command>aio_cancel</command> çağrısı sırasında bir hata oluşmuşsa işlev <command>-1</command> ile döner ve <command>errno</command> değişkenine aşağıdaki durumlardan biri atanır:
    </para><para><variablelist><varlistentry>
    <term><literal>EBADF</literal></term><listitem><para>
<varname>dosyatanıtıcı</varname> tanıtıcısı geçersiz
       </para></listitem></varlistentry><varlistentry>
       <term><literal>ENOSYS</literal></term><listitem><para>
<command>aio_cancel</command> desteklenmiyor
       </para></listitem></varlistentry></variablelist>
     </para><para>
Kaynak dosyası <command>_FILE_OFFSET_BITS == 64</command> ile derlenmişse 32 bitlik sistemlerde bu işlev aslında <command>aio_cancel64</command> işlevine karşılıktır. Yani 32 bitlik arayüz 64 bitlik olanıyla değiştirilir.
</para></funcdescr></funcsynopsis></para><para id="glibc-aio_cancel64">
<indexterm scope="glibc-fn"><primary>aio_cancel64</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>aio_cancel64</command></funcdef>
<paramdef>(int             <varname>dosyatanıtıcı</varname>,
 struct aiocb64 *<varname>aiocbp</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev, argümanının <command>struct aiocb64</command> türünde bir değişken olması dışında <command>aio_cancel</command> işlevine benzer.
    </para><para>
Kaynak dosyası <command>_FILE_OFFSET_BITS == 64</command> ile derlenmişse 32 bitlik sistemlerde bu işleve <command>aio_cancel</command> ismiyle erişilir. Yani 32 bitlik arayüz 64 bitlik olanıyla değiştirilir.
  </para></funcdescr></funcsynopsis></para></sect1>
  <sect1 id="glibc-Configuration-of-AIO">
    <title>Eşzamansız G/Ç İşlemlerinin Yapılandırılması</title>
    <titleabbrev>Eşzamansız G/Ç işlemleri nasıl eniyilenir</titleabbrev>
    <para>
POSIX standardı eşzamansız G/Ç işlevlerinin nasıl gerçekleneceğini belirtmez. Bunlar sistem çağrıları olabileceği gibi ayrıca kullanıcı seviyesinde de gerçekleştirilmiş olabilirler.
    </para><para>
Bu kılavuzun yazılması sırasında geçerli olan gerçekleme, kuyruğa alınmış işlemlerin gerçekleştirilmesinde evrelerin kullanıldığı bir kullanıcı seviyesi gerçekleşmeydi. Bu gerçekleme sınırlamalarla ilgili bazı kararlar vermeyi gerektirirken, değiştirilemeyen sınırlamaların bazılarından GNU C kütüphanesinde en iyi biçimde kaçınılmıştır. Bununla birlikte, GNU C kütüphanesi bireysel kullanımla ilgili olarak eşzamansız G/Ç gerçeklemesinde bazı ayarlamalar yapılabilmesini sağlamıştır.
    </para><para id="glibc-struct-aioinit">
<indexterm scope="glibc-tp"><primary sortas="aioinit">struct aioinit</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü">
<funcdef>struct <command>aioinit</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu veri türü yapılandırmayı ya da ayarlanabilir parametreleri gerçeklemeye aktarmakta kullanılır. Bir yazılım bu yapının üyelerini ilklendirdikten sonra bunu gerçeklemeye <command>aio_init</command> işlevini kullanarak aktarmalıdır.
    </para><para><glosslist><glossentry><glossterm>
    <literal>int <command>aio_threads</command></literal>
    </glossterm><glossdef><para>
Herhangi bir anda kullanılabilen azami evre sayısını belirler.
    </para></glossdef></glossentry><glossentry><glossterm>
    <literal>int <command>aio_num</command></literal>
    </glossterm><glossdef><para>
Aynı anda kuyruğa alınabilecek isteklerin azami sayısına bir yaklaşıklık sağlar.
    </para></glossdef></glossentry><glossentry><glossterm>
    <literal>int <command>aio_locks</command></literal>
    </glossterm><glossdef><para>Kullanılmadı.
    </para></glossdef></glossentry><glossentry><glossterm>
    <literal>int <command>aio_usedba</command></literal>
    </glossterm><glossdef><para>Kullanılmadı.
    </para></glossdef></glossentry><glossentry><glossterm>
    <literal>int <command>aio_debug</command></literal>
    </glossterm><glossdef><para>Kullanılmadı.
    </para></glossdef></glossentry><glossentry><glossterm>
    <literal>int <command>aio_numusers</command></literal>
    </glossterm><glossdef><para>Kullanılmadı.
    </para></glossdef></glossentry><glossentry><glossterm>
    <literal>int <command>aio_reserved[2]</command></literal>
    </glossterm><glossdef><para>Kullanılmadı.
       </para></glossdef></glossentry></glosslist>
</para></funcdescr></funcsynopsis></para><para id="glibc-aio_init">
<indexterm scope="glibc-fn"><primary>aio_init</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>void <command>aio_init</command></funcdef>
<paramdef>(const struct aioinit *<varname>init</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev harhangi bir eşzamansız G/Ç işlevinden önce çağrılmalıdır. Çağrılması tamamen isteğe bağlıdır, sadece eşzamansız G/Ç işlemleri gerçeklemesinin daha iyi yapılmasına yardımcı olma anlamında kullanılabilir.
    </para><para>
<command>aio_init</command> çağrısı yapılmadan önce, <command>struct aioinit</command> yapısının üyeleri ilklendirilmelidir. Bu yapıldıktan sonra yapı işleve bir argüman olarak aktarılır.
    </para><para>
İşlev bir dönüş değerine sahip olmadığı gibi işlevle ilgili atanmış bir hata da yoktur. Irix 6'daki SGI gerçeklemesindeki bir öneriden kaynaklanan bir oluşumdur. POSIX.1b veya Unix98 standartlarının kapsamında değildir.
       </para></funcdescr></funcsynopsis></para></sect1></chapter>

<chapter id="glibc-Control-Operations">
  <title>Dosyalar Üzerindeki Denetim İşlemleri</title>
  <titleabbrev>Dosya tanıtıcılardaki diğer işlemler.</titleabbrev>
  <para>
<indexterm scope="glibc-cp"><primary>dosya tanıtıcılar</primary><secondary>denetim işlemleri</secondary></indexterm>
<indexterm scope="glibc-cp"><primary><command>fcntl</command> işlevi</primary></indexterm>
Bu kısımda dosya tanıtıcıları üzerinde, dosya tanıtıcılarla ilgili seçeneklerin ayarlanması ve sorgulanması, kayıt kilitleri gibi diğer işlemlerin nasıl uygulanacağından bahsedilecektir. Bu işlemlerin hepsi <command>fcntl</command> işleviyle uygulanır.
   </para><para>
<command>fcntl</command> işlevinin ikinci argümanı hangi işlemin uygulanacağını belirleyen bir komuttur. Bu işlemlerle ilgili çeşitli seçenekleri isimlendiren makrolar ile işlevler <filename>fcntl.h</filename> başlık dosyasında bildirilmiştir. Bu seçeneklerin çoğu <command>open</command> işlevi tarafından da kullanılır; bkz. <xref linkend="glibc-Opening-and-Closing-Files"/>.
<indexterm scope="glibc-pg"><primary>fcntl.h</primary></indexterm>
   </para><para id="glibc-fcntl">
<indexterm scope="glibc-fn"><primary>fcntl</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>fcntl</command></funcdef>
<paramdef>(int <varname>dosyatanıtıcı</varname>,
 int <varname>komut</varname>,
 …)</paramdef>
</funcprototype><funcdescr><para>
<command>fcntl</command> işlevi <varname>komut</varname> ile belirtilen işlemi <varname>dosyatanıtıcı</varname> tanıtıcısna uygular.  Bazı komutlar ek argümanlar gerektirebilir. Ek argümanlar gerektiren komutlar, bunların dönüş değerleri ve hata durumları her komutun açıklamasında ayrı ayrı belirtilmiştir.
   </para><para>
Komutların özet listesi:
   </para><para><variablelist><varlistentry>
   <term><literal>F_DUPFD</literal></term><listitem><para>
Dosya tanıtıcısının kopyasını yapar (aynı açık dosyaya başka bir dosya tanıtıcı döndürür). Bkz. <xref linkend="glibc-Duplicating-Descriptors"/>.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>F_GETFD</literal></term><listitem><para>
Dosya tanıtıcı ile ilgili seçenekleri döndürür. Bkz. <xref linkend="glibc-Descriptor-Flags"/>.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>F_SETFD</literal></term><listitem><para>
Dosya tanıtıcı ile ilgili seçenekleri ayarlar. Bkz. <xref linkend="glibc-Descriptor-Flags"/>.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>F_GETFL</literal></term><listitem><para>
Açık dosya ile ilgili seçenekleri döndürür. Bkz. <xref linkend="glibc-File-Status-Flags"/>.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>F_SETFL</literal></term><listitem><para>
Açık dosya ile ilgili seçenekleri ayarlar. Bkz. <xref linkend="glibc-File-Status-Flags"/>.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>F_GETLK</literal></term><listitem><para>
Bir dosya kilidi ile döner. Bkz. <xref linkend="glibc-File-Locks"/>.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>F_SETLK</literal></term><listitem><para>
Bir dosya kilidini oluşturur ya da kaldırır. Bkz. <xref linkend="glibc-File-Locks"/>.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>F_SETLKW</literal></term><listitem><para>
Tamamlanmasının beklenmesi dışında <command>F_SETLK</command> ile aynıdır. Bkz. <xref linkend="glibc-File-Locks"/>.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>F_GETOWN</literal></term><listitem><para>
<command>SIGIO</command> sinyallarini alacak süreç ya da süreç grup kimliği ile döner. Bkz. <xref linkend="glibc-Interrupt-Input"/>.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>F_SETOWN</literal></term><listitem><para>
<command>SIGIO</command> sinyallarini alacak süreç ya da süreç grup kimliğini ayarlar. Bkz. <xref linkend="glibc-Interrupt-Input"/>.
      </para></listitem></varlistentry></variablelist>
     </para><para>
Bu işlev çok evreli yazılımlarda bir iptal noktasıdır. <command>fcntl</command> çağrısı sırasında evre bazı özkaynakları (bellek, dosya tanıtıcı, semafor, vb.) ayırdığında bu bir sorun olur. Evre tam bu anda bir iptal alırsa ayrılan özkaynaklar yazılım sonlanana kadar ayrılmış olarak kalır. Bu tür <command>fcntl</command> çağrılarından kaçınmak için iptal eylemcileri kullanılarak korunulmalıdır.
   </para></funcdescr></funcsynopsis></para>
</chapter>

<chapter id="glibc-Duplicating-Descriptors">
  <title>Tanıtıcıların Çoğullanması</title>
  <titleabbrev>Dosya tanıtıcıları çoğullayan <command>fcntl</command> komutları.</titleabbrev>
  <para>
<indexterm scope="glibc-cp"><primary>dosya tanıtıcılar</primary><secondary>çoğullanması</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>dosya tanıtıcılar</primary><secondary>girdi ve çıktının yönlendirilmesi</secondary></indexterm>
Bir dosya tanıtıcısını <wordasword>çoğullayabilir</wordasword> ya da aynı dosya için başka bir dosya tanıtıcı edinebilirsiniz. Çoğullanan dosya tanıtıcılar aynı dosya konumunu ve aynı <link linkend="glibc-File-Status-Flags">dosya durum seçeneklerini</link> paylaşırlarken, her biri kendi <link linkend="glibc-Descriptor-Flags">dosya tanıtıcı seçeneklerine</link> sahiptir.
   </para><para>
Bir dosya tanıtıcısının çoğullanmasının ana amacı girdi ve çıktı <wordasword>yönlendirme</wordasword>dir: bu, bir dosya ya da boruyu kendisi ile ilgili başka bir dosya tanıtıcısı ile değiştirmek anlamındadır.
   </para><para>
Çoğullama işlemini <command>fcntl</command> işlevini <command>F_DUPFD</command> komutu ile kullanarak yapabileceğiniz gibi dosya tanıtıcıları çoğullayan <command>dup</command> ve <command>dup2</command> işlevleri ile de yapabilirsiniz.
   </para><para>
<indexterm scope="glibc-pg"><primary>unistd.h</primary></indexterm>
<indexterm scope="glibc-pg"><primary>fcntl.h</primary></indexterm>
<command>fcntl</command> işlevi ve seçenekleri <filename>fcntl.h</filename> başlık dosyasında bildirilmişken, <command>dup</command> ve <command>dup2</command> işlevlerinin prototipleri <filename>unistd.h</filename> başlık dosyasında bulunur.
   </para><para id="glibc-dup">
<indexterm scope="glibc-fn"><primary>dup</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>dup</command></funcdef>
<paramdef>(int <varname>eski</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev <varname>eski</varname> dosya tanıtıcısını kullanılabilir (o an açık olmayan) ilk dosya tanıtıcı numarasına kopyalar. Bu işlem<sbr/><command>fcntl (<varname>eski</varname>, F_DUPFD, 0)</command> çağrısına eşdeğerdir.
</para></funcdescr></funcsynopsis></para><para id="glibc-dup2">
<indexterm scope="glibc-fn"><primary>dup2</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>dup2</command></funcdef>
<paramdef>(int <varname>eski</varname>,
 int <varname>yeni</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev <varname>eski</varname> tanıtıcıyı <varname>yeni</varname> tanıtıcıya kopyalar.
   </para><para>
<varname>eski</varname> geçersiz bir tanıtıcı ise <command>dup2</command> hiçbir şey yapmaz; <varname>yeni</varname>'yi de kapatmaz.  Aksi takdirde, <varname>eski</varname> tanıtıcısı, zaten bir tanıtıcı olan <varname>yeni</varname> tanıtıcısı kapatıldıktan sonra <varname>yeni</varname> tanıtıcısına kopyalanır.
   </para><para>
<varname>eski</varname> ve <varname>yeni</varname> farklı numaralarsa ve <varname>eski</varname> geçerli bir tanıtıcı numarası ise, <command>dup2</command> şu koda eşdeğerdir:
   </para><para>
<screen>close (<varname>yeni</varname>);
fcntl (<varname>eski</varname>, F_DUPFD, <varname>yeni</varname>)
</screen></para><para>
Bununla birlikte, <command>dup2</command> bunu atomik olarak yapar; <command>dup2</command> çağrısının ortasında <varname>yeni</varname>'nin kapatıldığı ama henüz <varname>eski</varname>'nin kopyası yapılmadığı bir an yoktur.
</para></funcdescr></funcsynopsis></para><para id="glibc-F_DUPFD">
<indexterm scope="glibc-vr"><primary>F_DUPFD</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>int <command>F_DUPFD</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu makro <command>fcntl</command> işlevinin <varname>komut</varname> argümanında kullanıldığında işlevin ilk argümanında belirtilen dosya tanıtıcıyı kopyalar.
   </para><para>
Bu çağrı şöyle yapılır:
   </para><para>
<screen>fcntl (<varname>eski</varname>, F_DUPFD, <varname>sonraki_tanıtıcı</varname>)
</screen></para><para>
<varname>sonraki_tanıtıcı</varname> argümanı <command>int</command> türünde olmalı ve döndürülecek dosya tanıtıcısı bu değerde ya da bu değerden büyük kullanılabilir ilk dosya tanıtıcı olacak şekilde belirtilmelidir.
   </para><para>
Böyle bir  <command>fcntl</command> çağrısının normal dönüş değeri yeni dosya tanıtıcısının değeridir. Dönüş değeri <command>-1</command> ise bu bir hata oluştuğunu gösterir. Aşağıdaki <command>errno</command> hata durumları bu komut için tanımlanmıştır:
   </para><para><variablelist><varlistentry>
   <term><literal>EBADF</literal></term><listitem><para>
<varname>eski</varname> argümanı geçersiz
      </para></listitem></varlistentry><varlistentry>
      <term><literal>EINVAL</literal></term><listitem><para>
<varname>sonraki_tanıtıcı</varname> argümanı geçersiz
      </para></listitem></varlistentry><varlistentry>
      <term><literal>EMFILE</literal></term><listitem><para>
Kullanılabilir başka tanıtıcı yok--yazılımınız olanı zaten kullanmış. BSD ve GNU'da bu değerin alabileceği azami değeri belirten özkaynak sınırı değiştirilebilir; <command>RLIMIT_NOFILE</command> sınırı hakkında daha ayrıntılı bilgi almak için <xref linkend="glibc-Limits-on-Resources"/> bölümüne bakınız.
      </para></listitem></varlistentry></variablelist>
    </para><para>
<command>EMFILE</command> hata durumu <command>dup2</command> işlevinde oluşmaz çünkü <command>dup2</command> tanıtıcıyı yeni bir dosya açılışı olarak oluşturmaz, mevcut birini kapattıktan sonra ona kopyalama yapar.
</para></funcdescr></funcsynopsis></para><para>
Aşağıdaki örnekte yönlendirme için <command>dup2</command> işlevinin nasıl kullanıldığı gösterilmiştir. Genellikle, standart akımların (<command>stdin</command> gibi) yönlendirilmesi kabuk tarafından ya da kabuk benzeri bir yazılım tarafından yeni bir yazılımın ya da bir alt sürecin <link linkend="glibc-Executing-a-File">çalıştırılması</link> için bir <command>exec</command> çağrısı yapılmadan önce yapılır. Yeni bir yazılım çalıştırıldığında, <command>main</command> işlevi çalıştırılmadan önce, standart akımlar kendileriyle ilgili dosya tanıtıcılarla oluşturulur ve ilklendirilir.
   </para><para>
Standart girdinin bir dosyaya yönlendirilmesi kabuk tarafından şöyle yapılabilirdi:
   </para><para>
<screen>pid = fork ();
if (pid == 0)
  {
    char *dosyaismi;
    char *program;
    int dosya;
    …
    dosya = TEMP_FAILURE_RETRY (open (dosyaismi, O_RDONLY));
    dup2 (dosya, STDIN_FILENO);
    TEMP_FAILURE_RETRY (close (dosya));
    execv (program, NULL);
  }
</screen></para><para>
<xref linkend="glibc-Launching-Jobs"/> bölümünde, süreçlerin bir boruhattının bağlamı içinde yönlendirilmesinin gerçekleştirildiği daha ayrıntılı bir örnek vardır.
   </para></chapter>

<chapter id="glibc-Descriptor-Flags">
  <title>Dosya Tanıtıcı Seçenekleri</title>
  <titleabbrev>Dosya tanıtıcılarla ilgili seçenekleri değiştiren <command>fcntl</command> komutları.</titleabbrev>
  <para>
<indexterm scope="glibc-cp"><primary>dosya tanıtıcılar</primary><secondary>seçenekler</secondary></indexterm>
<firstterm>Dosya tanıtıcı seçenekleri</firstterm> bir dosya tanıtıcısının çeşitli öznitelikleridir. Bu seçenekler her dosya tanıtıcısı için özeldir, yani tek bir dosya için bir dosya tanıtıcısını kopyalayarak çoğaltsanız bile yeni dosya tanıtıcısının seçeneklerinde yapacağınız değişiklik özgün tanıtıcıyı etkilemeyecektir.
   </para><para>
Şimdilik sadece bir dosya tanıtıcı seçeneği vardır:<command>FD_CLOEXEC</command>. Bu seçenek <link linkend="glibc-Executing-a-File"><command>exec…</command> işlevlerini</link> kullandığınızda tanıtıcının kapanmasına sebep olur.
   </para><para>
Bu kısımdaki semboller <filename>fcntl.h</filename> başlık dosyasında tanımlıdır.
<indexterm scope="glibc-pg"><primary>fcntl.h</primary></indexterm>
   </para><para id="glibc-F_GETFD">
<indexterm scope="glibc-vr"><primary>F_GETFD</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>int <command>F_GETFD</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu makro <command>fcntl</command> işlevinin <varname>komut</varname> argümanında kullanıldığında <varname>dosyatanıtıcı</varname> ile ilişkili dosya tanıtıcı seçeneklerini döndürür.
   </para><para>
Bu komutun <command>fcntl</command> işlevinden döndürdüğü değer tek tek seçeneklerin bit seviyesinde VEYA'lanarak yorumlandığı negatif olmayan bir sayıdır (tek tek seçenekler dense de şimdilik sadece bir seçenek var).
   </para><para>
Bir hata oluşmuşsa işlev <command>-1</command> ile döner. Aşağıdaki <command>errno</command> hata durumu bu komut için tanımlıdır:
   </para><para><variablelist><varlistentry>
   <term><literal>EBADF</literal></term><listitem><para>
<varname>dosyatanıtıcı</varname> argümanı geçersiz
      </para></listitem></varlistentry></variablelist>
</para></funcdescr></funcsynopsis></para><para id="glibc-F_SETFD">
<indexterm scope="glibc-vr"><primary>F_SETFD</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>int <command>F_SETFD</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu makro <command>fcntl</command> işlevinin <varname>komut</varname> argümanında <varname>dosyatanıtıcı</varname> ile ilişkili dosya tanıtıcı seçeneklerini belirlemek için kullanılır. Bu komut yeni seçeneklerin belirtildiği <command>int</command> türünde üçüncü bir argüman gerektirir. Böyle bir çağrı şöyle yapılabilir:
   </para><para>
<screen>fcntl (<varname>dosyatanıtıcı</varname>, F_SETFD, <varname>yeni_seçenekler</varname>)
</screen></para><para>
Bu komutun <command>fcntl</command> işlevinden döndürdüğü değer hata durumunu belirten <command>-1</command> değeri dışında belirsizdir. Seçenekler ve hata durumları <command>F_GETFD</command> komutundakilerle aynıdır.
</para></funcdescr></funcsynopsis></para><para>
Aşağıdaki makro <command>fcntl</command> işlevinde bir dosya tanıtıcı seçeneği olarak kullanılmak üzere tanımlanmıştır. Değeri bir bitmaskesi değeri olarak kullanılabilecek bir tamsayı sabittir.
</para><para id="glibc-FD_CLOEXEC">
<indexterm scope="glibc-vr"><primary>FD_CLOEXEC</primary></indexterm>
<indexterm scope="glibc-cp"><primary>dosya tanıtıcılar</primary><secondary>seçenekler</secondary><tertiary>close-on-exec</tertiary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>int <command>FD_CLOEXEC</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu seçenek, bir <link linkend="glibc-Executing-a-File"><command>exec</command> işlevi çağrıldığında</link> dosya tanıtıcının kapatılacağını belirtmek için kullanılır.  Bir dosya tanıtıcı bir <command>open</command> veya <command>dup</command> işlevi ile ayrıldığında, bu seçenek temizlenir. Böylece <command>exec</command> işlevi ile oluşturulan yeni sürecin dosya tanıtıcısını miras alabilmesi sağlanmış olur.
      </para><para>
Dosya tanıtıcı seçeneklerini değiştirmek isterseniz, mevcut seçenekleri <command>F_GETFD</command> ile alıp değeri değiştirmelisiniz. Sadece burada açıklanan seçeneklerin varolduğu gibi bir kabul yapmamalısınız; yazılımınız yıllar sonra daha fazla seçeneğin varolduğu bir sistem üzerinde de çalışabilmelidir. Örneğin, aşağıdaki işlev diğer seçeneklere dokunmadan sadece <command>FD_CLOEXEC</command> seçeneği ile çalışır:
   </para><para>
<screen>
/* <varname>desc</varname> tanıtıcısına <command>FD_CLOEXEC</command> seçeneği,
  <varname>value</varname> sıfırdan farklıysa atanır, değilse temizlenir.
  Dönüş değeri hata yoksa 0, varsa <command>-1</command> olur ve hata <command>errno</command>'ya
  atanır. */

int
set_cloexec_flag (int desc, int value)
{
  int oldflags = fcntl (desc, F_GETFD, 0);
  /* seçeneklerin okunması başarısız olursa,
     hata durmunun belirtip hemen dönelim. */
  if (oldflags &lt; 0)
    return oldflags;
  /* Seçeneğin durumunu belirleyebiliriz. */
  if (value != 0)
    oldflags |= FD_CLOEXEC;
  else
    oldflags &amp;= ~FD_CLOEXEC;
  /* Değiştirilen seçeneği dosya tanıtıcısına atayalım. */
  return fcntl (desc, F_SETFD, oldflags);
}
</screen></para></funcdescr></funcsynopsis></para></chapter>

<chapter id="glibc-File-Status-Flags">
  <title>Dosya Durum Seçenekleri</title>
  <titleabbrev>Açık dosyalarla ilgili seçenekleri değiştiren <command>fcntl</command> komutları.</titleabbrev>
  <para>
<indexterm scope="glibc-cp"><primary>dosya tanıtıcılar</primary><secondary>dosya durum seçenekleri</secondary></indexterm>
<wordasword>Dosya durum seçenekleri</wordasword> bir açık dosyanın özniteliklerini belirlemekte kullanılır. <xref linkend="glibc-Descriptor-Flags"/> bölümünde açıklanan dosya tanıtıcı seçeneklerinin aksine, dosya durum seçenekleri tek bir dosya için çoğullanan dosya tanıtıcıları arasında paylaşılır. Dosya durum seçenekleri <command>open</command> işlevinin <varname>seçenekler</varname> argümanında belirtilir; bkz. <xref linkend="glibc-Opening-and-Closing-Files"/>.
   </para><para>
Dosya durum seçenekleri, her biri ayrı bir bölümde üç kategori halinde incelenmiştir.
   </para><para><itemizedlist><listitem><para>
<xref linkend="glibc-Access-Modes"/> bölümü dosya için izin verilen erişim türü ile ilgilidir: okuma, yazma, ikisi de.  <command>open</command> ile belirtilebilir, <command>fcntl</command> ile öğrenilebilir ama değiştirilemezler.
     </para></listitem><listitem><para>
<xref linkend="glibc-Open-time-Flags"/> bölümü <command>open</command> işlevinin yaptıklarının denetimi ile ilgili ayrıntıları içerir. Bu seçenekler <command>open</command> çağrısından sonra saklanmaz.
     </para></listitem><listitem><para>
<xref linkend="glibc-Operating-Modes"/> bölümünde, <command>read</command> ve <command>write</command> işlevlerinin işlemlerini etkileyen seçenekler bulunur. <command>open</command> ile belirtilebilir, <command>fcntl</command> ile öğrenilebilir veya değiştirilebilirler.
     </para></listitem></itemizedlist></para><para>
Bu kısımdaki semboller <filename>fcntl.h</filename> başlık dosyasında tanımlıdır.
<indexterm scope="glibc-pg"><primary>fcntl.h</primary></indexterm>
  </para>
  <sect1 id="glibc-Access-Modes">
    <title>Dosya Erişim Kipleri</title>
    <titleabbrev>Tanıtıcı okuyabilir ya da yazabilir mi.</titleabbrev>
    <para>
Erişim kipleri bir dosya tanıtıcısına okuma izni, yazma izni veya her iki izni vermek için kullanılır (GNU sisteminde bunların hiçbirine de izin vermemek mümkün olduğu gibi, bir dosyanın bir çalıştırılabilir olarak çalıştırılmasına izin vermek de mümkündür). Erişim kipleri dosya açılırken belirlenir ve bir daha değiştirilemez.
    </para><para id="glibc-O_RDONLY">
<indexterm scope="glibc-vr"><primary>O_RDONLY</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>int <command>O_RDONLY</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Dosya okuma erişimi için açılır.
</para></funcdescr></funcsynopsis></para><para id="glibc-O_WRONLY">
<indexterm scope="glibc-vr"><primary>O_WRONLY</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>int <command>O_WRONLY</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Dosya yazma erişimi için açılır.
</para></funcdescr></funcsynopsis></para><para id="glibc-O_RDWR">
<indexterm scope="glibc-vr"><primary>O_RDWR</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>int <command>O_RDWR</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Dosya hem okuma hem de yazma erişimi için açılır.
</para></funcdescr></funcsynopsis></para><para>
GNU sisteminde (başka sistemlerde böyle değildir), <command>O_RDONLY</command> ve <command>O_WRONLY</command> bit seviyesinde VEYA'lanabilen bağımsız değerlerdir, yani <command>O_RDWR</command> aslında <command>O_RDONLY|O_WRONLY</command>'dir. Sıfır erişim kipine de izin verilmiştir; bu kipte dosyaya girdi ve çıktı için bir işleme izin verlimez ama <command>fchmod</command> gibi başka işlemlere izin verilir. GNU sisteminde, "salt-okunur" ve "salt-yazılır" yanlış isimlendirme olarak kabul edildiğinden  <filename>fcntl.h</filename> dosyasında dosya erişim kipleri için ek isimler tanımlanmıştır. Bu isimler GNU'ya özel kod yazarken tercih edilir. Ama POSIX.1 uyumuluğu istenen yazılımlarda aşağıdaki isimler yerine yukarıdaki POSIX.1 isimleri kullanılmalıdır.
    </para><para id="glibc-O_READ">
<indexterm scope="glibc-vr"><primary>O_READ</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>int <command>O_READ</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Dosya okuma erişimi için açılır. Yalnız GNU'da tanımlıdır. <command>O_RDONLY</command> ile aynıdır.
</para></funcdescr></funcsynopsis></para><para id="glibc-O_WRITE">
<indexterm scope="glibc-vr"><primary>O_WRITE</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>int <command>O_WRITE</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Dosya yazma erişimi için açılır. Yalnız GNU'da tanımlıdır. <command>O_WRONLY</command> ile aynıdır.
</para></funcdescr></funcsynopsis></para><para id="glibc-O_EXEC">
<indexterm scope="glibc-vr"><primary>O_EXEC</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>int <command>O_EXEC</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Dosya çalıştırmak için açılır. Yalnız GNU'da tanımlıdır.
</para></funcdescr></funcsynopsis></para><para>
Dosya erişim kipini <command>fcntl</command> ile öğrenmek isterseniz, dosya durum seçeneklerinden erişim kipi bitlerini elde etmeniz gerekir. GNU sisteminde <command>O_READ</command> ve <command>O_WRITE</command> bitlerini seçenekler arasından kolayca elde edebilmenize karşın, POSIX.1 sistemlerde okuma ve yazma erişim kipleri ayrı ayrı elde edilebilen bitsel seçenekler değildir. Dosya erişim kiplerine taşınabilir anlamda erişmek için en iyi yöntem <command>O_ACCMODE</command> makrosunu kullanmaktır.
    </para><para id="glibc-O_ACCMODE">
<indexterm scope="glibc-vr"><primary>O_ACCMODE</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>int <command>O_ACCMODE</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu makro dosya erişim kiplerinin dosya durum seçeneklerinden bit seviyesinde VE'lenebilen bir değer olarak elde edilmesini sağlar. Erişim kipleri  <command>O_RDONLY</command>, <command>O_WRONLY</command> veya <command>O_RDWR</command> olabilir. (GNU sisteminde sıfır da olabilir ve asla  <command>O_EXEC</command> bitini içermez.)
  </para></funcdescr></funcsynopsis></para></sect1>
  <sect1 id="glibc-Open-time-Flags">
    <title>Açış Anı Seçenekleri</title>
    <titleabbrev><command>open</command> ile ilgili ayrıntılar.</titleabbrev>
    <para>
Açış anı seçenekleri <command>open</command>  işlevinin davranışlarını etkileyen seçeneklerdir. Bu seçenekler dosya açıldıktan sonra saklanmaz. Buna bir istisna, bir G/Ç işlem kipi de olan <command>O_NONBLOCK</command> seçeneğidir ki, bu seçenek kaydedilir. <command>open</command> çağrılarının nasıl yapıldığı <xref linkend="glibc-Opening-and-Closing-Files"/> bölümünde anlatılmıştır.
    </para><para>
Açış anı seçenekleri iki alt gruba ayrılır.
    </para><para><itemizedlist><listitem><para>
<firstterm>Dosya ismi dönüşüm seçenekleri</firstterm> <command>open</command> işlevinin dosyayı konumlamada dosya ismini nasıl ele alacağını ve dosyanın oluşturulabilir olup olmadığını etkiler.
<indexterm scope="glibc-cp"><primary>dosya ismi dönüşüm seçenekleri</primary></indexterm>
<indexterm scope="glibc-cp"><primary>dosyalar</primary><secondary>seçenekler</secondary><tertiary>dosya ismi dönüşümü</tertiary></indexterm>
    </para></listitem><listitem><para>
<firstterm>Açış anı eylem seçenekleri</firstterm> <command>open</command> işlevinin dosyanın açılışı anında yapacağı ek işlemleri belirler.
<indexterm scope="glibc-cp"><primary>açış anı eylem seçenekleri</primary></indexterm>
<indexterm scope="glibc-cp"><primary>dosyalar</primary><secondary>seçenekler</secondary><tertiary>açış anı eylemleri</tertiary></indexterm>
    </para></listitem></itemizedlist></para><para>
Dosya ismi dönüşüm seçenekleri şunlardır:
    </para><para id="glibc-O_CREAT">
<indexterm scope="glibc-vr"><primary>O_CREAT</primary></indexterm>
<indexterm scope="glibc-cp"><primary>dosya ismi dönüşüm seçenekleri</primary><secondary>dosyayı açarken oluşturma</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>dosyalar</primary><secondary>seçenekler</secondary><tertiary>dosya ismi dönüşümü</tertiary><fourth>dosyayı açarken oluşturma</fourth></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>int <command>O_CREAT</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu bit varsa ve dosya mevcut değilse oluşturulur.
</para></funcdescr></funcsynopsis></para><para id="glibc-O_EXCL">
<indexterm scope="glibc-vr"><primary>O_EXCL</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>int <command>O_EXCL</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Hem <command>O_CREAT</command> hem de <command>O_EXCL</command> bitleri varsa ve belirtilen dosya mevcutsa <command>open</command> başarısız olur. Bu mevcut bir dosyanın fütursuzca üzerine yazılmasını engellemeyi garanti eder.
</para></funcdescr></funcsynopsis></para><para id="glibc-O_NONBLOCK">
<indexterm scope="glibc-vr"><primary>O_NONBLOCK</primary></indexterm>
<indexterm scope="glibc-cp"><primary>dosya ismi dönüşüm seçenekleri</primary><secondary>beklemeden açma</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>dosyalar</primary><secondary>seçenekler</secondary><tertiary>dosya ismi dönüşümü</tertiary><fourth>beklemeden açma</fourth></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>int <command>O_NONBLOCK</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
<command>open</command> işlevinin dosyanın açılışı sırasında uzun süre beklememesini sağlar. Bu sadece bazı dosya çeşitlerinde anlamlıdır, genelde seri portlar gibi aygıtlarda kullanışlıdır; bu seçeneğin anlamlı olmadığı dosyalarda zararı olmaz ve yoksayılır. Çoğunlukla bir modeme bir port açılması modem taşıyıcıyı saptayana kadar engellenir; <command>O_NONBLOCK</command> etkin olduğunda <command>open</command> taşıyıcıyı beklemeden dönecektir.
    </para><para>
<command>O_NONBLOCK</command> seçeneğinin hem G/Ç işlem kipi hem de bir dosya ismi dönüşüm seçeneği olarak belirtilmesi durumunda <command>open</command> işlevi ayrıca beklemeyen G/Ç kipini de etkin kılacaktır. <command>open</command> işlevinin dosyayı açarken beklemesi ama G/Ç işlemleri için beklemeyen kipi etkinleştirmesini istiyorsanız <command>open</command> işlevini <command>O_NONBLOCK</command> etkin olarak çağırmalı ve ardından bir <command>fcntl</command> çağrısı ile bu biti temizlemelisiniz.
</para></funcdescr></funcsynopsis></para><para id="glibc-O_NOCTTY">
<indexterm scope="glibc-vr"><primary>O_NOCTTY</primary></indexterm>
<indexterm scope="glibc-cp"><primary>dosya ismi dönüşüm seçenekleri</primary><secondary>denetim uçbirimi</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>dosyalar</primary><secondary>seçenekler</secondary><tertiary>dosya ismi dönüşümü</tertiary><fourth>denetim uçbirimi</fourth></indexterm>
<indexterm scope="glibc-cp"><primary>denetim uçbirimi</primary><secondary>belirtilmesi</secondary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>int <command>O_NOCTTY</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
İsimli dosya bir uçbirim aygıtı ise, aygıt sürecin denetim uçbirimi yapılmaz. Denetim uçbiriminin ne anlama geldiği <xref linkend="glibc-Job-Control"/> bölümünde açıklanmıştır.
    </para><para>
GNU sisteminde ve 4.4 BSD'de, <command>O_NOCTTY</command> sıfırdır ve bir dosya açılışı aygıtı hiçbir zaman denetim uçbirimi yapmaz; taşınabilirlik önemliyse bundan kaçınmak için <command>O_NOCTTY</command> seçeneğini kullanın.
    </para><para>
Aşağıdaki dosya ismi dönüşüm seçenekleri sadece GNU sisteminde geçerlidir.
</para></funcdescr></funcsynopsis></para><para id="glibc-O_IGNORE_CTTY">
<indexterm scope="glibc-vr"><primary>O_IGNORE_CTTY</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>int <command>O_IGNORE_CTTY</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Aygıt sürecin denetim uçbirimi olarak belirlenmiş olsa bile isimli dosya sürecin denetim uçbirimi olarak tanınmaz. Yeni dosya tanıtıcı hiçbir zaman iş denetim sinyallerini içermeyecektir. Bkz. <xref linkend="glibc-Job-Control"/>.
</para></funcdescr></funcsynopsis></para><para id="glibc-O_NOLINK">
<indexterm scope="glibc-vr"><primary>O_NOLINK</primary></indexterm>
<indexterm scope="glibc-cp"><primary>sembolik bağlar</primary><secondary>açılması</secondary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>int <command>O_NOLINK</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
İsimli dosya bir sembolik bağ ise, bağın hedefindeki dosya değil bağın kendisi açılır. (Yeni dosya tanıtıcı ile yapılan <command>fstat</command> çağrısı bağın ismiyle yapılacak bir <command>lstat</command> çağrısından dönecek bilgileri döndürececektir.)
</para></funcdescr></funcsynopsis></para><para id="glibc-O_NOTRANS">
<indexterm scope="glibc-vr"><primary>O_NOTRANS</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>int <command>O_NOTRANS</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
İsimli dosya özellikle dönüştürülürse, dönüştürücü çağrılmaz. Dönüştürücü onu göreceğinden dosyayı sadece açar.
</para></funcdescr></funcsynopsis></para><para>
Açış anı eylem seçenekleri <command>open</command> işlevine aslında dosyanın açılışı ile ilgili olmayan ek işlemleri belirtmek için kullanılır. Bunun ayrı çağrılarla değil de <command>open</command> işlevinin bir parçası olarak yapılmasının sebebi <command>open</command> işlevinin bu işlemleri atomik olarak yapabilmesidir.
</para><para id="glibc-O_TRUNC">
<indexterm scope="glibc-vr"><primary>O_TRUNC</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>int <command>O_TRUNC</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Dosyanın uzunluğunu sıfırlar. Bu seçenek dizin veya FIFO gibi özel dosyalarda değil sadece sıradan dosyalarda kullanışlıdır. POSIX.1, bir dosyanın yazma amacıyla açılması için <command>O_TRUNC</command> kullanılmasını gerekli kılar. GNU ve BSD'de dosyayı sıfırlayabilmek için yazma izni olması gerekir ama bunu yapmak için dosyanın yazma amacıyla açılması gerekmez.
    </para><para>
Bu POSIX.1 tarafından belirtilmiş tek açış anı eylem seçeneğidir. Dosyanın sıfırlanmasının <command>open</command> tarafından yapılmasının iyi bir sebebi yoksa bunu yapmak yerine <command>open</command> çağrısının hemen ardından <command>ftruncate</command> çağrısı yapın. <command>O_TRUNC</command> seçeneği <command>ftruncate</command> tasarlanmadan önce Unix'de vardı ama artık geriye uyumluluk adına var.
</para></funcdescr></funcsynopsis></para><para>
Kalan işlem kipleri BSD oluşumlarıdır. Sadece bazı sistemlerde vardır, diğerlerinde bu makrolar tanımlanmamıştır.
    </para><para id="glibc-O_SHLOCK">
<indexterm scope="glibc-vr"><primary>O_SHLOCK</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>int <command>O_SHLOCK</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
<command>flock</command>'un yaptığı gibi dosya üzerinde bir paylaşımlı kilit edinilir. Bkz.  <xref linkend="glibc-File-Locks"/>.
    </para><para>
<command>O_CREAT</command> belirtilmişse,dosya oluşturulurken kilitleme atomik olarak yapılır. Yeni dosyada başka bir sürecin kilitleme yapması mümkün olmaz.
</para></funcdescr></funcsynopsis></para><para id="glibc-O_EXLOCK">
<indexterm scope="glibc-vr"><primary>O_EXLOCK</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>int <command>O_EXLOCK</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
<command>flock</command>'un yaptığı gibi dosya üzerinde bir ayrıcalıklı kilit edinilir. Bkz.  <xref linkend="glibc-File-Locks"/>. Bu, <command>O_SHLOCK</command>'daki gibi atomik yapılır.
  </para></funcdescr></funcsynopsis></para></sect1>
  <sect1 id="glibc-Operating-Modes">
    <title>G/Ç İşlem Kipleri</title>
    <titleabbrev>G/Ç işlemlerini denetleyen özel kipler.</titleabbrev>
    <para>
İşlem kipleri dosya tanıtıcının girdi ve çıktı işlemlerinde nasıl kullanılacağını belirler. Bu seçenekler <command>open</command> ile belirtilir, <command>fcntl</command> ile okunur ve değiştirilir.
    </para><para id="glibc-O_APPEND">
<indexterm scope="glibc-vr"><primary>O_APPEND</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>int <command>O_APPEND</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu bit dosyaya ekleme kipini etkin kılar. Bu bit varsa, tüm <command>write</command> işlemleri o anki dosya konumundan bağımsız olarak veriyi dosyanın sonuna ekleyecektir. Bu bir dosyaya ek yapmanın en güvenilir yoludur. Ekleme kipi, dosyaya yazan başka süreçlerin yaptıklarından etkilenmeksizin daima dosya sonuna veri eklemeyi garanti eder. Bu kipi kullanmadan kendiniz dosya konumunu dosya sonuna ayarlayıp yazmaya çalışırsanız, hemen öncesinde başka bir sürecin dosyaya yaptığı bir yazma işlemi sonucunda veriniz dosyanın sonuna değil dosyanın içinde bir yere yazılmış olabilir.
</para></funcdescr></funcsynopsis></para><para id="glibc-O_NONBLOCK2">
<indexterm scope="glibc-vr"><primary>O_NONBLOCK</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>int <command>O_NONBLOCK</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu bit dosya için beklememe kipini etkin kılar. Bu bit varsa, <command>read</command> işlemlerinde o an bir girdinin mevcut olmaması durumunda işlev veriyi beklemeksizin bir hata durumu ile döner. Benzer şekilde <command>write</command> işlemlerinde çıktı hemen yazılamıyorsa işlev beklemeksizin bir hata durumu ile döner.
    </para><para>
<command>O_NONBLOCK</command> seçeneğinin hem G/Ç işlem kipi olarak hem de dosya ismi dönüşüm seçeneği olarak etkin olabileceğini unutmayın; bkz. <xref linkend="glibc-Open-time-Flags"/>.
</para></funcdescr></funcsynopsis></para><para id="glibc-O_NDELAY">
<indexterm scope="glibc-vr"><primary>O_NDELAY</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>int <command>O_NDELAY</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu, BSD ile uyumluluk adına bulunan <command>O_NONBLOCK</command> seçeneğinin atıl takma adıdır. POSIX.1 standardında tanımlanmamıştır.
</para></funcdescr></funcsynopsis></para><para id="glibc-O_ASYNC">
<indexterm scope="glibc-vr"><primary>O_ASYNC</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>int <command>O_ASYNC</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu bit eşzamansız girdi kipini etkin kılar. Bu bit varsa, girdi olduğunda <command>SIGIO</command> sinyalleri üretilecektir. Bkz.  <xref linkend="glibc-Interrupt-Input"/>.
    </para><para>
Eşzamansız girdi kipi bir BSD özelliğidir.
</para></funcdescr></funcsynopsis></para><para id="glibc-O_FSYNC">
<indexterm scope="glibc-vr"><primary>O_FSYNC</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>int <command>O_FSYNC</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu bit eşzamanlı yazma kipini etkin kılar. Bu bit varsa, <command>write</command> çağrısı veri diske yazılmadan dönmeyecektir. Eşzamanlı yazma kipi bir BSD özelliğidir.
</para></funcdescr></funcsynopsis></para><para id="glibc-O_SYNC">
<indexterm scope="glibc-vr"><primary>O_SYNC</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>int <command>O_SYNC</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
<command>O_FSYNC</command> ile aynıdır.
</para></funcdescr></funcsynopsis></para><para id="glibc-O_NOATIME">
<indexterm scope="glibc-vr"><primary>O_NOATIME</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>int <command>O_NOATIME</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu bit varsa, <command>read</command> çağrısı <link linkend="glibc-File-Times">dosyanın erişim zamanını</link> güncellemeyecektir. Bu kip yedekleme uygulamalarınca kullanılır, böylece yedeklenen dosya işlem sırasında okunmuş sayılmaz. Bu kipi sadece dosyanın sahibi veya süper kullanıcı etkin kılabilir.
    </para><para>
Bu kip bir GNU oluşumudur.
  </para></funcdescr></funcsynopsis></para></sect1>
  <sect1 id="glibc-Getting-File-Status-Flags">
    <title>Dosya Durum Seçeneklerinin Saptanması</title>
    <titleabbrev>Dosya durum seçeneklerinin öğrenilmesi ve belirlenmesi.</titleabbrev>
    <para>
Dosya durum seçeneklerini öğrenmek ve belirlemek için <command>fcntl</command> işlevi kullanılır.
    </para><para id="glibc-F_GETFL">
<indexterm scope="glibc-vr"><primary>F_GETFL</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>int <command>F_GETFL</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu makro <command>fcntl</command> işlevinin <varname>komut</varname> argümanında kullanıldığında <varname>dosyatanıtıcı</varname> ile ilgili açık dosyanın dosya durum seçeneklerini okur.
    </para><para>
Bu komutun <command>fcntl</command> işlevinden döndürdüğü değer normalde tek tek seçeneklerin bit seviyesinde VEYA'lanmasıyla elde edilen negatif olmayan bir değerdir. Dosya erişim kipleri GNU sistemi dışında eşsiz bit değerler olmadıklarından bu bitlere bu makro ile değil, <command>O_ACCMODE</command> makrosu ile erişebilirsiniz.
    </para><para>
Bir hata durumunda <command>fcntl</command> <command>-1</command> ile döner. Aşağıdaki  <command>errno</command> hata durumu bu komut için tanımlanmıştır:
    </para><para><variablelist><varlistentry>
    <term><literal>EBADF</literal></term><listitem><para>
<varname>dosyatanıtıcı</varname> argümanı geçersiz.
       </para></listitem></varlistentry></variablelist>
</para></funcdescr></funcsynopsis></para><para id="glibc-F_SETFL">
<indexterm scope="glibc-vr"><primary>F_SETFL</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>int <command>F_SETFL</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu makro <command>fcntl</command> işlevinin <varname>komut</varname> argümanında kullanılarak <varname>dosyatanıtıcı</varname> ile ilgili açık dosyanın dosya durum seçenekleri belirlenebilir. Bu komut, yeni seçeneklerin belirtildiği üçüncü bir argümanın varlığını gerektirir:
    </para><para>
<screen>fcntl (<varname>dosyatanıtıcı</varname>, F_SETFL, <varname>yeni_seçenekler</varname>)
</screen></para><para>
Bir dosya tanıtıcının erişim kipini bu komutla değiştiremezsiniz.
    </para><para>
Bu komutun <command>fcntl</command> işlevinden döndürdüğü değer hata durumunu belirten <command>-1</command> değeri dışında belirsizdir. Hata durumları  <command>F_GETFL</command> komutu ile aynıdır.
</para></funcdescr></funcsynopsis></para><para>
Dosya durum seçeneklerini değiştirmek isterseniz önce o anki seçenekleri <command>F_GETFL</command> ile almalı sonra bu değeri değiştirmelisiniz. Sadece burada açıklanan seçeneklerin varolduğu gibi bir kabul yapmamalısınız; yazılımınız yıllar sonra daha fazla seçeneğin varolduğu bir sistem üzerinde de çalışabilmelidir. Örneğin, aşağıdaki işlev diğer seçeneklere dokunmadan sadece <command>O_NONBLOCK</command> seçeneğini değiştirir:
    </para><para>
<screen>
/* <varname>desc</varname> tanıtıcısına <command>O_NONBLOCK</command> seçeneği,
  <varname>value</varname> sıfırdan farklıysa atanır, değilse temizlenir.
  Dönüş değeri hata yoksa 0, varsa <command>-1</command> olur ve hata <command>errno</command>'ya
  atanır. */

int
set_nonblock_flag (int desc, int value)
{
  int oldflags = fcntl (desc, F_GETFL, 0);
  /* seçeneklerin okunması başarısız olursa,
     hata durmunun belirtip hemen dönelim. */
  if (oldflags == -1)
    return -1;
  /* Seçeneğin durumunu belirleyebiliriz. */
  if (value != 0)
    oldflags |= O_NONBLOCK;
  else
    oldflags &amp;= ~O_NONBLOCK;
  /* Değiştirilen seçeneği dosya tanıtıcısına atayalım. */
  return fcntl (desc, F_SETFL, oldflags);
}
</screen></para></sect1></chapter>
<chapter id="glibc-File-Locks">
  <title>Dosya Kilitleri</title>
  <titleabbrev>Dosya kilitleme ile ilgili <command>fcntl</command> komutları.</titleabbrev>
  <para>
<indexterm scope="glibc-cp"><primary>dosya kilitleri</primary></indexterm>
<indexterm scope="glibc-cp"><primary>dosya kilitleri</primary><secondary>kayıt kilitleme</secondary></indexterm>
Kalan <command>fcntl</command> komutları, aynı anda çok sayıda süreci çalışabilen uygulamalarda bir sürecin aynı dosyaya hataya eğilimli bir yolla aynı anda erişimini engelleyen <wordasword>dosya kilitleme</wordasword> desteği içindir.
   </para><para>
<indexterm scope="glibc-cp"><primary>dosya kilitleri</primary><secondary>ayrıcalıklı kilit</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>dosya kilitleri</primary><secondary>yazma kilidi</secondary></indexterm>
Bir <firstterm>ayrıcalıklı</firstterm> ya da <firstterm>yazma</firstterm> kilidi  sürecin dosyanın belli bir parçasına yazma amacıyla ayrıcalıklı erişimini mümkün kılar. Bir yazma kilidi etkinken başka bir süreç dosyanın kilitli bölümünü kilitleyemez.
   </para><para>
<indexterm scope="glibc-cp"><primary>dosya kilitleri</primary><secondary>paylaşımlı kilit</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>dosya kilitleri</primary><secondary>okuma kilidi</secondary></indexterm>
Bir <firstterm>paylaşımlı</firstterm> veya <firstterm>okuma</firstterm> kilidi başka bir sürecin dosyanın okuma kilitli parçasında bir yazma kilidi isteği yapmasına engel olur, ancak bir okuma kilidi isteğini engellemez.
   </para><para>
Aslında <command>read</command> ve <command>write</command> işlevleri dosyanın bir yerinde bir kilit var mı, yok mu diye bakmaz. Çok sayıda süreç arasında dosya kilitlemesini etkili olarak kullanmak istiyorsanız, kilitlerin durumunu doğrudan <command>fcntl</command> çağrıları ile saptadıktan sonra işlemi yapıp yapmamaya karar vermelisiniz.
   </para><para>
Kilitler süreçlerle ilişkilendirilir. Bir süreç belirtilen bir dosyanın her baytı için sadece bir çeşit kilitleme yapabilir. Bir dosya ile ilişkili dosya tanıtıcılardan herhangi biri kapatıldığında, diğer dosya tanıtıcılar açık bile olsa, süreçte bu dosya ile ilişkilendirilmiş tüm kilitler iptal edilir.  Benzer şekilde bir süreç sonlandığında da kilitler iptal edilir, ayrıca <command>fork</command> ile <link linkend="glibc-Creating-a-Process">oluşturulan alt süreçler</link> bu kilitleri miras almazlar.
   </para><para>
Bir kilit oluşturulurken ne çeşit kilidin nerede oluşturulacağını belirtmek için <command>struct flock</command> yapısı kullanılır. Bu veri türü ve kilitlerle ilgili  <command>fcntl</command> makroları <filename>fcntl.h</filename> başlık dosyasında bildirilmiştir.
<indexterm scope="glibc-pg"><primary>fcntl.h</primary></indexterm>
   </para><para id="glibc-struct-flock">
<indexterm scope="glibc-tp"><primary sortas="flock">struct flock</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü">
<funcdef>struct <command>flock</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu yapı <command>fcntl</command> işlevi ile bir dosya kilidini yapılandırmada kullanılır. Şu üyelere sahiptir:
   </para><para><glosslist><glossentry><glossterm>
    <literal>short int <command>l_type</command></literal>
    </glossterm><glossdef><para>
Kilidin türünü belirtir; <command>F_RDLCK</command>, <command>F_WRLCK</command> veya <command>F_UNLCK</command> makrolarından biri olabilir:
   </para><para><variablelist><varlistentry>
   <term><literal>F_RDLCK</literal>
   <indexterm scope="glibc-vr"><primary>F_RDLCK</primary></indexterm>
   </term><listitem><para>
Bir okuma kilidi (ya da paylaşımlı kilit) belirtir.
      </para><para>
<indexterm scope="glibc-vr"><primary>F_WRLCK</primary></indexterm>
   </para></listitem></varlistentry><varlistentry>
   <term><literal>F_WRLCK</literal></term><listitem><para>
Bir yazma kilidi (ya da ayrıcalıklı kilit) belirtir.
      </para><para>
<indexterm scope="glibc-vr"><primary>F_UNLCK</primary></indexterm>
   </para></listitem></varlistentry><varlistentry>
   <term><literal>F_UNLCK</literal></term><listitem><para>
Bölgeden kilidin kaldırılmasını belirtir.
      </para></listitem></varlistentry></variablelist>
    </para></glossdef></glossentry><glossentry><glossterm>
    <literal>short int <command>l_whence</command></literal>
    </glossterm><glossdef><para><command>fseek</command> veya <command>lseek</command> işlevinin <varname>nereye</varname> veya <varname>nereden</varname> argümanında kullanıldığı gibi dosya konumunun nereye göre belirlendiğini belirtir. Değeri <command>SEEK_SET</command>, <command>SEEK_CUR</command> veya <command>SEEK_END</command> olabilir.
    </para></glossdef></glossentry><glossentry><glossterm>
    <literal>off_t <command>l_start</command></literal>
    </glossterm><glossdef><para>
Kilidin uygulanacağı bölümün başlangıcından uzaklığını belirler ve yapının <command>l_whence</command> üyesinde belirtilen noktaya göre bayt cinsinden ifade edilir.
    </para></glossdef></glossentry><glossentry><glossterm>
    <literal>off_t <command>l_len</command></literal>
    </glossterm><glossdef><para>
Kilitlenecek bölgenin uzunluğunu belirler. <command>0</command> değerinin özel bir anlamı vardır, bölgenin dosyanın sonuna kadar genişleyebileceğini belirtir.
    </para></glossdef></glossentry><glossentry><glossterm>
    <literal>pid_t <command>l_pid</command></literal>
    </glossterm><glossdef><para>
Kilidi tutan sürecin <link linkend="glibc-Process-Creation-Concepts">süreç kimliğidir</link>. Bu alan kilidi oluştururken yoksayılır, sadece <command>fcntl</command> işlevinin <command>F_GETLK</command> komutu ile yapılan çağrısı ile doldurulur.
      </para></glossdef></glossentry></glosslist>
</para></funcdescr></funcsynopsis></para><para id="glibc-F_GETLK">
<indexterm scope="glibc-vr"><primary>F_GETLK</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>int <command>F_GETLK</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu makro <command>fcntl</command> işlevinin <varname>komut</varname> argümanında kullanılır ve bir kilit hakkında bilgi istendiğini belirtir. Bu komut <command>fcntl</command> işlevinde <command>struct flock *</command> türünde  üçüncü bir argüman gerektirir:
   </para><para>
<screen>fcntl (<varname>dosyatanıtıcı</varname>, F_GETLK, <varname>kilit_gst</varname>)
</screen></para><para>
<varname>kilit_gst</varname> argümanı ile belirtilen yerde bir kilit varsa, kilit ile ilgili bilgi <varname>*kilit_gst</varname>'ye yazılır. Belirtilen yeni kilitle uyumluysa mevcut kilitler raporlanmaz. Bu bakımdan, hem okuma hem de yazma ile ilgili kilitleri bulmak için <command>F_WRLCK</command> türünde bir kilit, sadece yazma ile ilgili kilitleri bulmak için ise, <command>F_RDLCK</command> türünde bir kilit belirtmelisiniz.
   </para><para>
<varname>kilit_gst</varname> tarafından belirtilen bölgeyi etkileyen birden fazla kilit varsa bunlardan sadece biri raporlanır. <varname>kilit_gst</varname> yapısının <command>l_whence</command> üyesine <command>SEEK_SET</command> atanır, <command>l_start</command> ve <command>l_len</command> üyelerine de kilitli bölgeyi tanımlayan değerler atanır.
   </para><para>
Bir kilit yoksa, <varname>kilit_gst</varname> yapısının sadece <command>l_type</command> üyesine <command>F_UNLCK</command> atanır.
   </para><para>
<command>fcntl</command> işlevinin bu komut ile ilgili dönüş değeri hata oluştuğunu belirten <command>-1</command> değeri dışında belirsizdir. Aşağıdaki <command>errno</command> hata durumları bu komut için tanımlanmıştır:
   </para><para><variablelist><varlistentry>
   <term><literal>EBADF</literal></term><listitem><para>
<varname>dosyatanıtıcı</varname> argümanı geçersiz
      </para></listitem></varlistentry><varlistentry>
      <term><literal>EINVAL</literal></term><listitem><para>
Ya <varname>kilit_gst</varname> argümanı geçerli bir kilit belirtmiyor ya da <varname>dosyatanıtıcı</varname> kilitleri desteklemiyor
      </para></listitem></varlistentry></variablelist>
</para></funcdescr></funcsynopsis></para><para id="glibc-F_SETLK">
<indexterm scope="glibc-vr"><primary>F_SETLK</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>int <command>F_SETLK</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu makro <command>fcntl</command> işlevinin <varname>komut</varname> argümanında bir kilit oluşturmak ya da kaldırmak amacıyla kullanır. Bu komut <command>fcntl</command> işlevinde <command>struct flock *</command> türünde  üçüncü bir argüman gerektirir:
   </para><para>
<screen>fcntl (<varname>dosyatanıtıcı</varname>, F_SETLK, <varname>kilit_gst</varname>)
</screen></para><para>
Süreç dosyanın belirtilen bölgesinde bir kilide sahipse eski kilit yenisiyle değiştirilir. Mevcut bir kilidi <command>F_UNLCK</command> türünde bir kilit belirterek kaldırabilirsiniz.
   </para><para>
Kilit oluşturulamazsa <command>fcntl</command> <command>-1</command> değeriyle döner. Bu işlev başka bir sürecin kilidi bırakması için beklemez.  <command>fcntl</command> işlevi başarılı olduğundan <command>-1</command>'den farklı bir değerle döner.
   </para><para>
Aşağıdaki <command>errno</command> hata durumları bu komut için tanımlanmıştır:
   </para><para><variablelist><varlistentry>
   <term><literal>EAGAIN</literal></term>
   </varlistentry><varlistentry>
   <term><literal>EACCES</literal></term><listitem><para>
Dosya üzerindeki başka bir kilit tarafından engellendiğinden kilit oluşturulamıyor. Bazı sistemler bu durumda <command>EAGAIN</command> kullanırken başkaları  <command>EACCES</command> kullanır; yazılımınızda her ikisini de beklemelisiniz. (GNU sistemi daima <command>EAGAIN</command> kullanır.)
      </para></listitem></varlistentry><varlistentry>
      <term><literal>EBADF</literal></term><listitem><para>
<varname>dosyatanıtıcı</varname> argümanı geçersiz; ya okuma erişimi için açılmamış <varname>dosyatanıtıcı</varname> için bir okuma kilidi istemişsinizdir ya da yazma erişimi için açılmamış bir <varname>dosyatanıtıcı</varname> için yazma kilidi istemişsinizdir.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>EINVAL</literal></term><listitem><para>
Ya <varname>kilit_gst</varname> argümanı geçerli kilit bilgisi içermiyor ya da <varname>dosyatanıtıcı</varname> ile ilişkili dosya kilitleri desteklemiyor.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>ENOLCK</literal></term><listitem><para>
Sistemde dosya kilidi özkaynakları tükendi; dosya kilidi istenen yerde zaten fazlasıyla dosya kilidi var
      </para><para>
İyi tasarlanmış dosya sistemleri bu hatayı hiç raporlamaz, çünkü dosya kilitleri ile ilgili bir sınır yoktur. Yine de, bir dosya sisteminin ağ üzerinden eriştiği başka bir dosya sistemi bu hatayı verebileceğinden bu hatayı hesaba katmanız gerekir.
      </para></listitem></varlistentry></variablelist>
</para></funcdescr></funcsynopsis></para><para id="glibc-F_SETLKW">
<indexterm scope="glibc-vr"><primary>F_SETLKW</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>int <command>F_SETLKW</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu makro <command>fcntl</command> işlevinin <varname>komut</varname> argümanında bir kilit oluşturmak ya da kaldırmak amacıyla kullanır. <command>F_SETLK</command> komutu gibi olmakla birlikte farklı olarak kilidi ayırana ya da kilit serbest kalıncaya kadar süreci bekletir.
   </para><para>
Bu komut da <command>F_SETLK</command> komutu gibi <command>struct flock *</command> türünde bir argüman gerektirir.
   </para><para>
<command>F_SETLK</command> komutu için <command>fcntl</command> işlevindeki hata durumlarına ek olarak aşağıdaki hata durumları bu komut için tanımlanmıştır:
   </para><para><variablelist><varlistentry>
   <term><literal>EINTR</literal></term><listitem><para>
İşlev beklerken bir sinyal ile durduruldu. Bkz. <xref linkend="glibc-Interrupted-Primitives"/>.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>EDEADLK</literal></term><listitem><para>
Belirtilen bölge başka bir süreç tarafından kilitlenmiş. Ama süreç, başka sürecin kilitlediği bölgeyi kendisi kilitleyene dek bekler, bu da kilit isteğinin sonsuza kadar beklenmesi anlamına gelebilir. Sistem tüm durumlarda bu hatanın saptanmasını garanti etmez ama eğer bu konuda uyarılmışsanız, şanslısınız demektir.
      </para></listitem></varlistentry></variablelist>
</para></funcdescr></funcsynopsis></para><para>
Dosya kilitlemenin faydalı olduğu bir duruma örnek olarak, bir yazılımın çok sayıda kullanıcı tarafından aynı anda çalıştırıldığını ve bu süreçlerin durum bilgisini ortak bir dosyaya yazdıklarını varsayabiliriz. Bu tür bir örnek, oyuncuların aldıkları puanları bir dosyaya kaydeden oyunlar olabilir. Buna başka bir örnek de hesap bilgilerini ve kullanımlarını kaydeden bir yazılım olabilir.
   </para><para>
Bir yazılımın çok sayıda kopyasının bir dosyaya aynı anda yazması dosya içeriğinin karışmasına sebep olur. Bu çeşit sorunların oluşması, dosyaya yapılacak bir yazma işleminden önce bir yazma kilidi oluştururarak önlenebilir.
   </para><para>
Yazılımın dosyayı tutarlı bir durumda iken okuması önemliyse bir okuma kilidi kullanılabilir. Bir okuma kilidinin varlığı başka bir sürecin dosyanın bir bölümünü yazmak için kilitlemesini önler.
   </para><para>
Dosya kilitlerinin bir dosyaya erişimi denetlemek için "isteğe bağlı" bir protokol olduğunu unutmayın. Kilitleme protokolünü kullanmayan başka süreçlerin dosyaya erişimi hala mümkün olacaktır.
   </para></chapter>

<chapter id="glibc-Interrupt-Input">
  <title>Sinyallerle Sürülen Girdi</title>
  <titleabbrev>Girdi geldiğinde eşzamansız bir sinyalin alınması.</titleabbrev>
  <para>
<indexterm scope="glibc-cp"><primary>dosya tanıtıcılar</primary><secondary>sinyallerle sürülen girdi</secondary></indexterm>
Bir dosya tanıtıcıda <command>O_ASYNC</command> <link linkend="glibc-File-Status-Flags">durum seçeneği</link> etkinse, bu dosya tanıtıcı ile ilgili bir girdi ya da çıktı olasılığı varsa bir  <command>SIGIO</command> sinyali gönderilir. Sinyali alacak süreç veya süreç grubu <command>F_SETOWN</command> komutu <command>fcntl</command> işlevinde kullanılarak seçilebilir. Dosya tanıtıcısı bir soket ise bu ayrıca, sokete bir <link linkend="glibc-Out-of-Band-Data">banddışı veri</link> geldiğinde alınan <command>SIGURG</command> sinyallerinin alıcılarını seçmekte de kullanılır. <command>SIGURG</command> sinyali <command>select</command> işlevinin bir "olağandışı durumu" raporladığı durumlarda gönderilir. Bkz. <xref linkend="glibc-Waiting-for-I-O"/>.)
   </para><para>
Dosya tanıtıcı bir uçbirim aygıtı ile ilgiliyse <command>SIGIO</command> sinyalleri uçbirimin önalan süreç grubuna gönderilir. Bkz. <xref linkend="glibc-Job-Control"/>.
   </para><para>
<indexterm scope="glibc-pg"><primary>fcntl.h</primary></indexterm>
Bu kısımdaki semboller <filename>fcntl.h</filename> başlık dosyasında tanımlanmıştır.
   </para><para id="glibc-F_GETOWN">
<indexterm scope="glibc-vr"><primary>F_GETOWN</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>int <command>F_GETOWN</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu makro <command>fcntl</command> işlevinin <varname>komut</varname> argümanında kullanıldığında <command>SIGIO</command> sinyallerinin gönderildiği süreç veya süreç grubu ile ilgili bilgilerin alınmasını sağlar. (Bir uçbirim için bu bilgi, <command>tcgetpgrp</command> kullanılarak alınabilen önalan süreç grubunun kimliğidir. Bkz. <xref linkend="glibc-Terminal-Access-Functions"/>.)
   </para><para>
Dönüş değeri bir süreç kimliği olarak yorumlanır; negatifse, dönüş değerinin mutlak değeri süreç grup kimliğidir.
   </para><para>
Aşağıdaki <command>errno</command> hata durumu bu komut için tanımlanmıştır:
   </para><para><variablelist><varlistentry>
   <term><literal>EBADF</literal></term><listitem><para>
<varname>dosyatanıtıcı</varname> argümanı geçersiz
      </para></listitem></varlistentry></variablelist>
</para></funcdescr></funcsynopsis></para><para id="glibc-F_SETOWN">
<indexterm scope="glibc-vr"><primary>F_SETOWN</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>int <command>F_SETOWN</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu makro <command>fcntl</command> işlevinin <varname>komut</varname> argümanında kullanılarak <command>SIGIO</command> sinyallerinin gönderildiği süreç veya süreç grubunu belirtilebilir. Bu komut, <command>fcntl</command> işlevinde <command>pid_t</command> türünde üçüncü bir agüman kullanılmasını gerektirir:
   </para><para>
<screen>fcntl (<varname>dosyatanıtıcı</varname>, F_SETOWN, <varname>pid</varname>)
</screen></para><para>
<varname>pid</varname> argümanı bir süreç kimliği olmalıdır. Ayrıca mutlak değeri bir süreç grup kimliği olan negatif sayı da belirtilebilir.
   </para><para>
Bu komutun <command>fcntl</command> işlevinden döndürdüğü değer bir hata oluşmuşsa <command>-1</command>'dir, aksi takdirde farklı bir değer döner. Aşağıdaki <command>errno</command> hata durumları bu komut için tanımlanmıştır:
   </para><para><variablelist><varlistentry>
   <term><literal>EBADF</literal></term><listitem><para>
<varname>dosyatanıtıcı</varname> argümanı geçersiz.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>ESRCH</literal></term><listitem><para>
<varname>pid</varname>'e karşılık bir süreç ya da süreç grubu yok.
      </para></listitem></varlistentry></variablelist>
    </para></funcdescr></funcsynopsis></para></chapter>
<chapter id="glibc-IOCTLs">
  <title>Soysal G/Ç Denetim İşlemleri</title>
  <para>
<indexterm scope="glibc-cp"><primary>dosya tanıtıcılar</primary><secondary>soysal G/Ç denetim işlemleri</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>IOCTLs</primary></indexterm>
GNU sistem bir çok farklı aygıt ve nesne üzerindeki çoğu girdi/çıktı işlemini <command>read</command>, <command>write</command> ve <command>lseek</command>  işlevinden oluşan bir kaç ilkelle gerçekleştirir. Buna karşın çoğu aygıt bu modelle karşılanamayan bir kaç tuhaf işleme ihtiyaç gösterir. Örneğin:
   </para><para><itemizedlist><listitem>
Bir uçbirimde kullanılan yazıtipinin değişirilmesi.
     </listitem><listitem>
Bir manyetik teybe geri ya da ileri sarmasının söylenmesi. (Bayt artışları ile hareket ettirilemediklerinden <command>lseek</command> uygulanamaz.)
     </listitem><listitem>
Bir diskin sürücüsünden çıkarılması.
     </listitem><listitem>
Bir CD-ROM aygıtındaki ses kaydının çalınması.
     </listitem><listitem>
Bir ağın yönlendirme tablolarının bakımı.
     </listitem></itemizedlist>
   </para><para>
Bu tür nesnelerin yanında soketler ve uçbirimler<footnote><para>Aslında, uçbirimlere özel işlevler, çoğu platformda IOCTL'lerle gerçeklenir.</para></footnote> gibi nesneler de kendilerine özgü özel işlevlere sahiptir, tüm bu durumlar için işlevler oluşturmak pratik olmazdı.
   </para><para>
Bu küçük işlemler yerine <firstterm>IOCTL</firstterm>'ler olarak bilinen kod numaraları atanır ve  <filename>sys/ioctl.h</filename> başlık dosyasında tanımlı olan <command>ioctl</command> işlevi üzerinden bunlar çoğullanır. Kod numaraları farklı başlık dosyalarında tanımlıdır.
   </para><para id="glibc-ioctl">
<indexterm scope="glibc-fn"><primary>ioctl</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>ioctl</command></funcdef>
<paramdef>(int <varname>dosyatanıtıcı</varname>,
 int <varname>komut</varname>,
 …)</paramdef>
</funcprototype><funcdescr><para>
<command>ioctl</command> işlevi <varname>dosyatanıtıcı</varname> tanıtıcı üzerine <varname>komut</varname> soysal G/Ç işlemini uygular.
   </para><para>
Genellikle, tek bir sayı ya da bir yapıya gösterici olarak üçüncü bir argüman daha olur. Bu argümanın anlamı, dönüş değeri ve kullanılan komut ile ilgili hata durumudur. Başarısızlık halinde çoğunlukla <command>-1</command> döner.
</para></funcdescr></funcsynopsis></para><para>
Bazı sistemlerde farklı aygıtlar tarafından kullanılan IOCTL'ler aynı numaraları paylaşırlar. Bu durumda, böyle bir IOCTL hep aynı hatayı üretir. Aygıta özel IOCTL'leri bilinmeyen bir aygıt üzerinde kullanmaya çalışmamalısınız.
   </para><para>
Çoğu IOCTL işletim sistemine özeldir ve/veya sadece özel sistem araçlarında kullanılır ve bu nedenle bu belgenin kapsamı dışında kalırlar. Bir IOCTL kullanım örneğini <xref linkend="glibc-Out-of-Band-Data"/> bölümünde bulabilirsiniz.
   </para>
 </chapter>
</part>

