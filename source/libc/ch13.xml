<?xml version="1.0" encoding="UTF-8"?>
<!-- ********************************************************************
        glibc/ch13.xml,v2.36, GFDL,LGPL, NBB, 2023
     ******************************************************************** -->
<part xml:id="glibc-Low-Level-I-O" userlevel="longtoc">
 <title>Düşük Seviyeli Girdi ve Çıktı</title>
 <titleabbrev>Düşük seviyeli, daha az taşınabilir G/Ç.</titleabbrev>
 <preliminary>
  <para>
   Bu oylumda dosya tanıtıcı kimlikleri üzerinde düşük seviyeli girdi ve çıktı işlemlerini gerçekleştiren işlevlerden bahsedilecektir. Bu işlevler <xref linkend="glibc-I-O-on-Streams"/> bölümünde açıklanan daha yüksek seviyeli G/Ç işlemleri ile ilgili ilkeller ile akımlarda eşdeğeri olmayan düşük seviyeli denetim işlemlerini gerçekleştiren işlevlerdir.
  </para>
  <para>
   Akım seviyesindeki G/Ç daha esnek ve daha kullanışlıdır; bununla birlikte, yazılımcılar gerektiğinde dosya tanıtıcı kimliği seviyesindeki işlevleri de kullanırlar. Bunların kullanım sebepleri genellikle şunlardır:
  </para>
  <simplelist>
   <member>
    İkilik dosyaları büyük tomarlar halinde okumak için.
   </member>
   <member>
    Dosyanın tamamını çözümlemek amacıyla <filename>core</filename> dosyasına okumak için.
   </member>
   <member>
    Sadece dosya tanıtıcı kimlikleri ile yapılabilen veri aktarımı işlemlerini gerçekleştirmek için. (Bir akıma karşılık olan tanıtıcı kimliği <varname>fileno</varname> kullanılarak alınabilir.)
   </member>
   <member>
    Tanıtıcı kimliklerini alt süreçlere aktarmak için. (Bir alt süreç bir akımı miras alamadığından bir tanıtıcı kimliğini miras alıp onu kendi akımını oluşturmak için kullanır.)
   </member>
  </simplelist>
 </preliminary>
 <chapter xml:id="glibc-Opening-and-Closing-Files">
  <title>Dosyaların Açılması ve Kapatılması</title>
  <titleabbrev>Dosya tanıtıcıların açılması ve kapatılması.</titleabbrev>
  <para>
   Bu kısımda dosya tanıtıcılar<footnote><para>Ç.N.: İleri bölümlerde <link linkend="glibc-Open-File-Description-Locks">açık dosya tanıtıcı kilitlerinden</link> bahsedilirken "dosya tanıtıcısı" (file description) ile "dosya tanıtıcı kimliği" (file descriptor - tanıtıcıya atıf yapan bir numara) arasında ayrım yapılırken <function>open</function> işlevi ile dosya tanıtıcı alındığından <function>dup</function> ile tanıtıcının değil kimliğin çoğaltıldığından ayrıca bahsedilmişken bu ayrıma diğer bölümlerde dikkat edilmediği gözlemlenmiştir. Örneğin bu bölümde <function>open</function> ile dosya tanıtıcı kimliği alındığından bahsedilerek kilitlerle ilgili bölümde yapılan açıklama (<function>open</function> ile elde edilen tanıtıcıdan, kimlikten farklı olarak dosya örneği (instance) olarak söz edilmekte) ile bu bilgi çelişmektedir.</para></footnote> kullanılarak dosyaların açılması ve kapatılması için kullanılan ilkeller açıklanacaktır. <function>open</function> ve <function>creat</function> işlevleri &fcntl.h; başlık dosyasında bildirilmişken <function>close</function> işlevi &unistd.h; başlık dosyasında bildirilmiştir.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-cp-open"><primary>dosya tanıtıcılar</primary><secondary>açılması</secondary></indexterm>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-open"><primary>open</primary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>open</function></csname>
    <csparam><ptr>const&#160;char</ptr><parameter>filename</parameter></csparam>
    <csparam><type>int</type><parameter>flags</parameter>[</csparam>
    <csparam><type>mode_t</type><parameter>mode</parameter>]</csparam>
   </csproto>
   <header>&fcntl.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe; &fd;</concept>
   </conceptlist>
   <para>
    <code>open</code> işlevi, <parameter>filename</parameter> adlı dosya için bir dosya tanıtıcı kimliği oluşturur ve bunu döndürür. İlk olarak dosya konum indisi dosyanın başlangıcındadır. <parameter>mode</parameter> bağımsız değişkeni (bkz. <xref linkend="glibc-Permission-Bits"/>) sadece dosya oluşturulurken kullanılır, ancak herhangi bir durumda bu bağımsız değişkenin bir zararı yoktur.
   </para>
   <para>
    <parameter>flags</parameter> bağımsız değişkeni dosyanın nasıl açılacağını belirler. Bu bir bit maskesidir ve ilgili seçenekler bitsel VEYAlanarak (C'de <operator>|</operator> işleci ile) maskenin değeri oluşturulabilir. Kullanılabilecek seçenekler <xref linkend="glibc-File-Status-Flags"/> bölümünde bulunabilir.
   </para>
   <para>
    <code>open</code> işlevinin normal dönüş değeri negatif olmayan bir tamsayı olarak dosya tanıtıcı kimliğidir. Bir hata durumunda <code>-1</code> değeri döner. Olağan <link linkend="glibc-File-Name-Errors">dosya ismi hatalarına</link> ek olarak aşağıdaki <varname>errno</varname> hata durumları bu işlev için tanımlanmıştır:
   </para>
   <variablelist>
    <varlistentry>
     <term><code>EACCES</code></term>
     <listitem>
      <para>
       Dosya var, ancak <parameter>flags</parameter> bağımsız değişkeninde istendiği gibi okunabilir/yazılabilir değil veya dosya yok, dizine de yazılamadığından dosya oluşturulamıyor.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>EEXIST</code></term>
     <listitem>
      <para>
       <varname>O_CREAT</varname> ve <varname>O_EXCL</varname> seçeneklerinin ikisi de belirtilmiş ama isimli dosya zaten var.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>EINTR</code></term>
      <listitem>
       <para>
        <code>open</code> işlemi bir sinyal tarafından durduruldu. Bkz. <xref linkend="glibc-Interrupted-Primitives"/>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>EISDIR</code></term>
      <listitem>
       <para>
        <parameter>flags</parameter> bağımsız değişkeninde yazma erişimi belirtilmiş ve dosya bir dizin.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>EMFILE</code></term>
      <listitem>
       <para>
        Sürecin çok fazla açık dosyası var. Dosya tanıtıcılarının azami sayısı <varname>RLIMIT_NOFILE</varname> öz kaynak sınırı tarafından denetlenir; bkz. <xref linkend="glibc-Limits-on-Resources"/>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>ENFILE</code></term>
      <listitem>
       <para>
        Dizini içeren sistemin tamamı ya da muhtemelen dosya sistemi, bu anda hiçbir ek açık dosyayı destekleyemiyor. (GNU/Hurd sistemlerinde asla böyle bir sorun olmaz.)
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>ENOENT</code></term>
      <listitem>
       <para>
        İsmi belirtilen dosya yok ve <varname>O_CREAT</varname> belirtilmemiş.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>ENOSPC</code></term>
      <listitem>
       <para>
        Yeni dosyayı içerecek dizin ya da dosya sistemi genişletilemiyor çünkü diskte yer yok.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>ENXIO</code></term>
      <listitem>
       <para>
        <varname>O_NONBLOCK</varname> ve <varname>O_WRONLY</varname> seçeneklerinin ikisi de <parameter>flags</parameter> bağımsız değişkeninde belirtilmiş ama okumak için dosya açmış bir süreç yok.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>EROFS</code></term>
      <listitem>
       <para>
        Dosya salt okunur dosya sistemi üzerinde ve <parameter>flags</parameter> bağımsız değişkeninde <varname>O_WRONLY</varname>, <varname>O_RDWR</varname> ve <varname>O_TRUNC</varname> seçeneklerinden biri belirtilmiş; veya <varname>O_CREAT</varname> belirtilmiş ve dosya mevcut değil.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    Bir 32 bitlik makinede kaynaklar <code>_FILE_OFFSET_BITS == 64</code> ile dönüştürülürse, <code>open</code> işlevi, 2^63 baytlık ve -2^63 ile 2^63 arasında konum sınırlı dosyalarda kullanılan dosya işleme işlevlerini etkinleştiren büyük dosya kipinde açılmış bir dosya tanıtıcı ile döner. Bu, tüm düşük seviyeli dosya işleme işlevleri büyük dosya kipindeki eşdeğerleri ile değiştirilerek kullanıcı bakımından şeffaf olarak yapılır.
   </para>
   <para>
    Bu işlev çok evreli yazılımlarda bir iptal noktasıdır. <code>open</code> çağrısı sırasında evre bazı öz kaynakları (bellek, dosya tanıtıcı, semafor, vb.) tahsis ettiğinde bu sorun ortaya çıkar. Evre tam bu anda bir iptal alırsa tahsis edilen öz kaynaklar yazılım sonlanana kadar tahsisli olarak kalır. Bu tür <code>open</code> çağrılarından kaçınmak için iptal eylemcileri kullanılarak korunulmalıdır.
   </para>
   <para>
    <code>open</code> işlevi, akımları oluşturan <function>fopen</function> ve <function>freopen</function> işlevlerinin düşük seviyeli karşılığıdır.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-open64"><primary>open64</primary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>open64</function></csname>
    <csparam><ptr>const&#160;char</ptr><parameter>filename</parameter></csparam>
    <csparam><type>int</type><parameter>flags</parameter>[</csparam>
    <csparam><type>mode_t</type><parameter>mode</parameter>]</csparam>
   </csproto>
   <header>&fcntl.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe; &fd;</concept>
   </conceptlist>
   <para>
    Bu işlev <code>open</code> işlevine benzer. <parameter>filename</parameter> isimli dosyaya erişim için kullanılabilen bir dosya tanıtıcı ile döner. Tek farkı bu işlevin 32 bitlik sistemlerde dosyayı büyük dosya (dosya uzunluğunun ve konum değerlerinin 63 bit genişlikte olduğu dosyalar) kipinde açmasıdır.
   </para>
   <para>
    Kaynakların <code>_FILE_OFFSET_BITS == 64</code> ile dönüştürülürdüğü durumda, bu işlev aslında <code>open</code> ismi altında kullanılır. Yani 64 bitlik yeni, genişletilmiş arayüz eski arayüzle şeffaf olarak değiştirilir.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-creat"><primary>creat</primary></indexterm>
   <csproto type="atıl işlev">
    <csname><type>int</type><function>creat</function></csname>
    <csparam><ptr>const&#160;char</ptr><parameter>filename</parameter></csparam>
    <csparam><type>mode_t</type><parameter>mode</parameter></csparam>
   </csproto>
   <header>&fcntl.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe; &fd;</concept>
   </conceptlist>
   <para>
    Bu işlev atıl olmuştur, geriye uyumluluk için vardır, kullanılmamalıdır.
   </para>
   <literallayout class="monospaced"><code>creat (<parameter>filename</parameter>, <parameter>mode</parameter>)</code>
</literallayout>
   <para>gibi bir çağrı,</para>
   <literallayout class="monospaced"><code>open (<parameter>filename</parameter>, O_WRONLY | O_CREAT | O_TRUNC, <parameter>mode</parameter>)</code>
</literallayout>
   <para>çağrısına eşdeğerdir.</para>
   <para>
    32 bitlik bir makinede kaynaklar <code>_FILE_OFFSET_BITS == 64</code> ile dönüştürülüyorsa, <code>creat</code> işlevi, 2^63 baytlık ve -2^63 ile 2^63 arasındaki konum sınırlı dosyalarda kullanılan dosya işleme işlevlerini etkinleştiren büyük dosya kipinde açılmış bir dosya tanıtıcı ile döner. Yani, tüm düşük seviyeli dosya işleme işlevleri için büyük dosya kipindeki eşdeğerlerinin tanımları geçerli olur.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-creat64"><primary>creat64</primary></indexterm>
   <csproto type="atıl işlev">
    <csname><type>int</type><function>creat64</function></csname>
    <csparam><ptr>const&#160;char</ptr><parameter>filename</parameter></csparam>
    <csparam><type>mode_t</type><parameter>mode</parameter></csparam>
   </csproto>
   <header>&fcntl.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe; &fd;</concept>
   </conceptlist>
   <para>
    Bu işlev atıl olmuştur, geriye uyumluluk için vardır, kullanılmamalıdır.
   </para>
   <para>
    Bu işlev <function>creat</function> işlevine benzer. <parameter>filename</parameter> isimli dosyaya erişim için kullanılabilen bir dosya tanıtıcı ile döner. Tek farkı bu işlevin 32 bitlik sistemlerde dosyayı büyük dosya (dosya uzunluğunun ve konum değerlerinin 31 bit genişlikte olduğu dosyalar) kipinde açmasıdır.
   </para>
   <para>
    Bu dosya tanıtıcıları <code>*64</code> biçiminde isimlendirilmiş işlevler (<function>read64</function> gibi) dışında normal dosya işlemlerinde kullanılmamalıdır.
   </para>
   <para>
    Kaynakların <code>_FILE_OFFSET_BITS == 64</code> ile dönüştürülürdüğü durumda, bu işlev aslında <function>creat</function> ismi altında kullanılır. Yani eski arayüz için şeffaf olarak 64 bitlik yeni, genişletilmiş arayüz kullanılır.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-cp-close"><primary>dosya tanıtıcılar</primary><secondary>kapatılması</secondary></indexterm>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-close"><primary>close</primary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>close</function></csname>
    <csparam><type>int</type><parameter>filedes</parameter></csparam>
   </csproto>
   <header>&unistd.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe; &fd;</concept>
   </conceptlist>
   <para>
    <code>close</code> işlevi, dosya tanıtıcısı <parameter>filedes</parameter> ile belirtilen dosyayı kapatır. Bir dosyanın kapatılma işlemi şöyle yürütülür:
   </para>
   <simplelist>
    <member>
     Dosya tanıtıcı serbest bırakılır.
    </member>
    <member>
     Dosyadaki süreç tarafından sahiplenilmiş kayıt kilitleri kaldırılır.
    </member>
    <member>
     İsimli ya da isimsiz bir ardışık süreç ile ilişkili tüm dosya tanıtıcılar kapatılır, okunmamış veri varsa iptal edilir.
    </member>
   </simplelist>
   <para>
    Bu işlev çok evreli yazılımlarda bir iptal noktasıdır. <code>close</code> çağrısı sırasında evre bazı öz kaynakları (bellek, dosya tanıtıcı, semafor, vb.) tahsis ettiğinde bu sorun ortaya çıkar. Evre tam bu anda bir iptal alırsa tahsis edilen öz kaynaklar yazılım sonlanana kadar tahsisli olarak kalır. Bu tür <code>close</code> çağrılarından kaçınmak için iptal eylemcileri kullanılarak korunulmalıdır.
   </para>
   <para>
    <code>close</code> işlevinin normal dönüş değeri sıfırdır. Bir hata durumunda <code>-1</code> değeri döner. Aşağıdaki <varname>errno</varname> hata durumları bu işlev için tanımlanmıştır:
   </para>
   <glosslist>
    <glossentry>
     <glossterm><code>EBADF</code></glossterm>
     <glossdef>
      <para>
       <parameter>filedes</parameter> geçerli bir dosya tanıtıcı değil.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm><code>EINTR</code></glossterm>
     <glossdef>
      <para>
       Çağrı bir sinyalle durduruldu Bkz. <xref linkend="glibc-Interrupted-Primitives"/>. <code>EINTR</code> hatasının düzgün olarak elde edilişine bir örnek:
      </para>
      <screen>TEMP_FAILURE_RETRY (close (desc));
</screen>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <glossterm><code>ENOSPC</code></glossterm>
      <glossterm><code>EIO</code></glossterm>
      <glossterm><code>EDQUOT</code></glossterm>
     </glossterm>
     <glossdef>
      <para>
       Dosyaya NFS üzerinden erişilirken, <function>write</function> işlevinden kaynaklanan bu hatalar kimi zaman <code>close</code> çağrısına kadar saptanamaz. Bunun ne anlama geldiği <xref linkend="glibc-I-O-Primitives"/> bölümünde açıklanmıştır.
      </para>
     </glossdef>
    </glossentry>
   </glosslist>
   <para>
    Ayrı bir <code>close64</code> işlevinin bulunmadığını unutulmamalıdır. Çünkü bu işlev dosya kipine bağımlı olmadığı gibi bunu saptamaya da çalışmaz. Bunu çekirdek bilir ve bir <code>close</code> çağrısı olduğunda gerekeni yapar.
   </para>
  </csynopsis>
  <para>
   Bir akımı kapatırken, <function>fclose</function> (bkz. <xref linkend="glibc-Closing-Streams"/>) işlevi kullanılmalıdır, işlevin düşük seviye eşdeğeri olan <function>close</function> ile kapatmaya çalışılmamalıdır. <function>fclose</function> işlevi tamponda bir veri varsa bunu boşaltır ve akım nesnesini kapandığını belirtecek şekilde günceller.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-close_range"><primary>close_range</primary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>close_range</function></csname>
    <csparam><type>unsigned&#160;int</type><parameter>lowfd</parameter></csparam>
    <csparam><type>unsigned&#160;int</type><parameter>maxfd</parameter></csparam>
    <csparam><type>int</type><parameter>flags</parameter></csparam>
   </csproto>
   <header>&posix-unistd.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe; &fd;</concept>
   </conceptlist>
   <para>
    <code>close_range</code> işlevi <parameter>lowfd</parameter>'den (dahil) <parameter>maxfd</parameter>'ye (dahil) kadar dosya tanıtıcılarını kapatır. <parameter>flags</parameter> bağımlılığı ile belirtilen dosya tanıtıcı aralığında <code>close</code> çağrısına benzer.
   </para>
   <para>
    Bu işlev yalnızca son Linux sürümlerinde desteklenir ve &glibc; hata durumunda herhangi bir çare sağlamaz (uygulamanın olası <varname>ENOSYS</varname> hatalarını işlemesi gerekir).
   </para>
   <para>
    <parameter>flags</parameter> dosyaların kapanışı ile ilgili seçenekler ekler. Linux şimdilik şunları desteklemektedir:
   </para>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-CLOSE_RANGE_UNSHARE"><primary>CLOSE_RANGE_UNSHARE</primary></indexterm>
    <csproto type="sabit">
     <csname><function>CLOSE_RANGE_UNSHARE</function></csname>
    </csproto>
    <header>&bits-unistd_ext.h;</header>
    <para>
     Dosya tanıtıcılar kapatılmadan önce dosya tanıtıcı tablosunun paylaşımı kaldırılır.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-CLOSE_RANGE_CLOEXEC"><primary>CLOSE_RANGE_CLOEXEC</primary></indexterm>
    <csproto type="sabit">
     <csname><function>CLOSE_RANGE_CLOEXEC</function></csname>
    </csproto>
    <header>&bits-unistd_ext.h;</header>
    <para>
     Dosya tanıtıcıyı kapatmak yerine <varname>FD_CLOEXEC</varname> biti tanımlanır.
    </para>
   </csynopsis>
   <para>
    <code>close_range</code> normal dönüş değeri <code>0</code>'dır; başarısızlık durumunda <code>-1</code> döndürülür. Bu işlev için aşağıdaki <varname>errno</varname> hata durumları tanımlanmıştır:
   </para>
   <glosslist>
    <glossentry>
     <glossterm><code>EINVAL</code></glossterm>
     <glossdef>
      <para>
       <parameter>lowfd</parameter> değeri <parameter>maxfd</parameter> değerinden büyük veya belirtilen <parameter>flags</parameter> desteklenmiyor.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm><code>ENOMEM</code></glossterm>
     <glossdef>
      <para>
       Ya işlem için yeterli bellek yok ya da sürecin adres alanı yetersiz. Yalnızca <varname>CLOSE_RANGE_UNSHARE</varname> kapanış seçeneği kullanıldığında oluşur.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm><code>EMFILE</code></glossterm>
     <glossdef>
      <para>
       Süreçte çok fazla açık dosya var. Yalnızca <varname>CLOSE_RANGE_UNSHARE</varname> kapanış seçeneği kullanıldığında oluşur. Azami dosya tanıtıcı sayısı, <varname>RLIMIT_NOFILE</varname> öz kaynak sınırı tarafından denetlenir. Bkz. <xref linkend="glibc-Limits-on-Resources"/>.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm><code>ENOSYS</code></glossterm>
     <glossdef>
      <para>
       Çekirdek gereken işlevselliği sağlamıyor.
      </para>
     </glossdef>
    </glossentry>
   </glosslist>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-closefrom"><primary>closefrom</primary></indexterm>
   <csproto type="işlev">
    <csname><type>void</type><function>closefrom</function></csname>
    <csparam><type>int</type><parameter>lowfd</parameter></csparam>
   </csproto>
   <header>&unistd.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe; &fd;</concept>
   </conceptlist>
   <para>
    <code>closefrom</code> işlevi, <parameter>lowfd</parameter>'den büyük veya ona eşit olan tüm dosya tanıtıcılarını kapatır. Bu işlev, <parameter>lowfd</parameter>'den küçük olmayan tüm açık dosya tanıtıcıları için <function>close</function> çağırmaya benzer.
   </para>
   <para>
    Zaten kapanmış dosya tanıtıcıları yok sayılır.
   </para>
  </csynopsis>
 </chapter>

 <chapter xml:id="glibc-I-O-Primitives">
  <title>Girdi ve Çıktı İlkelleri</title>
  <titleabbrev>Verinin okunması ve yazılması.</titleabbrev>
  <para>
   Bu kısımda dosya tanıtıcılar üzerinde düşük seviyeli girdi ve çıktı işlemlerini gerçekleştiren <function>read</function>, <function>write</function> ve <function>lseek</function> işlevlerinden bahsedilecektir. Bu işlevler &unistd.h; başlık dosyasında bildirilmiştir.
   <indexterm linkend="glibc-pg"><primary>unistd.h</primary></indexterm>
  </para>
  <csynopsis>
   <indexterm linkend="glibc-tp" xml:id="glibc-tp-ssize_t"><primary>ssize_t</primary></indexterm>
   <indexterm xml:id="glibc-cp-ssize_t" linkend="glibc-cp"><primary>dosya G/Ç işlevleri</primary><secondary>dönüş veri türü</secondary></indexterm>
   <csproto type="veri türü">
    <csname><function>ssize_t</function></csname>
   </csproto>
   <header>&unistd.h;</header>
   <para>
    Bu veri türü tek bir işlem olarak okunup yazılabilen veri parçalarının uzunluğunu göstermekte kullanılır. <type>size_t</type> türüne benzemekle birlikte bu işaretli türüdür.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-read"><primary>dosya tanıtıcılar</primary><secondary>okunması</secondary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-read-eof"><primary>dosya tanıtıcılar</primary><secondary>dosya sonu</secondary></indexterm>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-read"><primary>read</primary></indexterm>
   <csproto type="işlev">
    <csname><type>ssize_t</type><function>read</function></csname>
    <csparam><type>int</type><parameter>filedes</parameter></csparam>
    <csparam><ptr>void</ptr><parameter>buffer</parameter></csparam>
    <csparam><type>size_t</type><parameter>size</parameter></csparam>
   </csproto>
   <header>&unistd.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <code>read</code> işlevi <parameter>filedes</parameter> tanıtıcılı dosyadan <parameter>size</parameter> baytlık okuma yapar ve sonucu <parameter>buffer</parameter> içinde döndürür. (Bunun bir karakter dizgesi olması gerekmediği gibi sonlandırıcı boş karakter de eklenmez.)
   </para>
   <para>
    İşlevin normal dönüş değeri okunan baytların sayısıdır. Bu <parameter>size</parameter> bayttan küçük olabilir; örneğin dosyada kalan baytlar <parameter>size</parameter> bayttan az olabilir ya da o an için dosyada <parameter>size</parameter> bayt olmayabilir. Davranış aslında dosyanın çeşidine bağlıdır. <parameter>size</parameter> bayttan daha az verinin okunmuş olmasının bir hata olarak değerlendirilmediği unutulmamalıdır.
   </para>
   <para>
    Sıfır dönüş değeri dosya sonunu belirtir (<parameter>size</parameter> bağımsız değişkeninin sıfır olduğu durum dışında). Bu bir hata sayılmaz. Dosya sonunda sürekli <code>read</code> çağrısı yapılırsa, işlev başka bir şey yapmadan sıfır döndürmeye devam eder.
   </para>
   <para>
    <code>read</code> çağrısı ile zaten tek bir karakter döndürülüyorsa, dosya sonuna erişildiğinde bu anlaşılamaz. Ancak dosya sonunda, sonraki <code>read</code> çağrıları hep sıfır döndürecektir.
   </para>
   <para>
    Bir hata durumunda işlev <code>-1</code> ile döner. Aşağıdaki <varname>errno</varname> hata durumları bu işlev için tanımlanmıştır:
   </para>
   <variablelist>
    <varlistentry>
     <term><code>EAGAIN</code></term>
     <listitem>
      <para>
       Normalde, bir girdi yoksa <code>read</code> girdi var olana kadar bekler. Fakat dosya için <varname>O_NONBLOCK</varname> seçeneği etkinse (bkz. <xref linkend="glibc-File-Status-Flags"/>), böyle bir durumda <code>read</code> hiç veri okumadan hemen döner ve bunu <code>EAGAIN</code> ile bildirir.
      </para>
      <note><title>Uyumluluk Bilgisi</title>
       <para>
        BSD Unix'lerin çoğu sürümü bunun için farklı bir hata kodu kullanır:  <varname>EWOULDBLOCK</varname>.  &glibc;nde <varname>EWOULDBLOCK</varname>, <code>EAGAIN</code> için takma addır, dolayısıyla hangi ismi kullandığınızın bir önemi yoktur.
       </para>
      </note>
      <para>
       Bazı sistemlerde çekirdek, kullanıcı sayfaları için yeterli fiziksel bellek bulamazsa, bir karakter özel dosyasından büyük miktarda veri okunması da <code>EAGAIN</code> hata koduna sebep olur. Bu, kullanıcı belleğine doğrudan erişim ile iletim yapan aygıtlarla sınırlıdır. Bunlar uçbirimleri kapsamaz, çünkü uçbirimler için çekirdek içinde daima ayrı tamponlar vardır. GNU/Hurd sistemlerinde böyle bir sorunla asla karşılaşılmaz.
      </para>
      <para>
       <code>EAGAIN</code> ile sonuçlanabilecek bir durumda istenenden daha az bayt döndürerek <code>read</code> başarılı olabilir. Hemen ardından yapılan bir <code>read</code> çağrısı <code>EAGAIN</code> ile sonuçlanırdı.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>EBADF</code></term>
     <listitem>
      <para>
       <parameter>filedes</parameter> bağımsız değişkeni geçerli bir dosya tanıtıcı değil ya da okumak için açılmamış.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>EINTR</code></term>
     <listitem>
      <para>
       <code>read</code> çağrısı girdi beklerken bir sinyal ile durduruldu. Bkz. <xref linkend="glibc-Interrupted-Primitives"/>.  Bir sinyalin <code>read</code> çağrısının <code>EINTR</code> döndürmesine sebep olması şart değildir; istenenden daha az bayt döndürerek <code>read</code> başarılı olabilir.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>EIO</code></term>
     <listitem>
      <para>
       Çoğu aygıt ve disk dosyası için bu hata kodu bir donanım hatasına işaret eder.
      </para>
      <para>
       <code>EIO</code> ayrıca, bir artalan süreci denetim uçbiriminden okuma yapmaya çalışırken ve sürecin bir <varname>SIGTTIN</varname> sinyali gönderilerek durdurulmasıyla normal eylem çalışmadığında da oluşabilir. Bu <varname>SIGTTIN</varname> sinyalinin engellenmesi ya da yok sayılmasından kaynaklanabileceği gibi süreç grubunun öksüz kalması nedeniyle de oluşabilir. Sinyaller hakkında daha fazla bilgi için <xref linkend="glibc-Signal-Handling"/> bölümüne ve iş denetimi için <xref linkend="glibc-Job-Control"/> bölümüne bakılabilir.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>EINVAL</code></term>
     <listitem>
      <para>
       Bazı sistemlerde bir karakter veya blok aygıtından okuma yapılırken, konum ve boyut başlangıçları belli bir blok boyuna hizalanmalıdır. Bu hata başlangıçların gerektiği gibi hizalanmadığını belirtir.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    <code>read64</code> isminde bir işlevin olmadığını unutulmamalıdır. İşlev olası geniş dosya konumlarını işlemek ya da değiştirmek için bir işlem yapmadığından bu gerekli değidir. Çekirdek gerekeni kendi içinde hallettiğinden <code>read</code> işlevi her durumda kullanılabilir.
   </para>
   <para>
    Bu işlev çok evreli yazılımlarda bir iptal noktasıdır. <code>read</code> çağrısı sırasında evre bazı öz kaynakları (bellek, dosya tanıtıcı, semafor, vb.) tahsis ettiğinde bu sorun ortaya çıkar. Evre tam bu anda bir iptal alırsa tahsis edilen öz kaynaklar yazılım sonlanana kadar tahsisli olarak kalır. Bu tür <code>read</code> çağrılarından kaçınmak için iptal eylemcileri kullanılarak korunulmalıdır.
   </para>
   <para>
    <command>read</command> işlevi, akımlardan okuma yapan <function>fgetc</function> gibi işlevler için temel ilkeldir.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-pread"><primary>dosya tanıtıcılar</primary><secondary>konumsal okuma</secondary></indexterm>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-pread"><primary>pread</primary></indexterm>
   <csproto type="işlev">
    <csname><type>ssize_t</type><function>pread</function></csname>
    <csparam><type>int</type><parameter>filedes</parameter></csparam>
    <csparam><ptr>void</ptr><parameter>buffer</parameter></csparam>
    <csparam><type>size_t</type><parameter>size</parameter></csparam>
    <csparam><type>off_t</type><parameter>offset</parameter></csparam>
   </csproto>
   <header>&unistd.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <code>pread</code> işlevi ilk üç bağımsız değişkeninin ve dönüş değeri ile hata durumlarının aynı olmasıyla <function>read</function> işlevine çok benzer.
   </para>
   <para>
    Fark dördüncü bağımsız değişkende ve onun elde edilişindedir. Okuma işlemi <parameter>filedes</parameter> dosya tanıtıcısının geçerli konumundan değil, <parameter>offset</parameter> ile belirtilen konumdan başlar ve dosya tanıtıcısının konumu bu işlemden etkilenmez; değeri çağrı öncesindeki değerinde kalır.
   </para>
   <para>
    Kaynak dosyası <code>_FILE_OFFSET_BITS == 64</code> ile derlenmişse <code>pread</code> işlevi aslında 2^63 bayta kadar dosyalarla 64 bitlik <type>off_t</type> türünde konumlarla çalışan <function>pread64</function> işlevi olur.
   </para>
   <para>
    <code>pread</code> işlevinin normal dönüş değeri okunan baytların sayısıdır. Hata durumunda <function>read</function> gibi <code>-1</code> ile döndüğü gibi hata kodları aşağıdakiler dışında aynıdır:
   </para>
   <variablelist>
    <varlistentry>
     <term><code>EINVAL</code></term>
     <listitem>
      <para>
       <parameter>offset</parameter> değeri negatif dolayısıyla kural dışı.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>ESPIPE</code></term>
     <listitem>
      <para>
       <parameter>offset</parameter> ardışık süreç ile ilişkili ve bu aygıt dosya içinde konum belirtilmesine izin vermiyor.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    İşlev Unix Tek Belirtiminin 2. sürümünde tanımlı bir oluşumdur.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-pread64"><primary>pread64</primary></indexterm>
   <csproto type="işlev">
    <csname><type>ssize_t</type><function>pread64</function></csname>
    <csparam><type>int</type><parameter>filedes</parameter></csparam>
    <csparam><ptr>void</ptr><parameter>buffer</parameter></csparam>
    <csparam><type>size_t</type><parameter>size</parameter></csparam>
    <csparam><type>off64_t</type><parameter>offset</parameter></csparam>
   </csproto>
   <header>&unistd.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    Bu işlev <function>pread</function> işlevinin benzeridir.  Farkı <parameter>offset</parameter> bağımsız değişkeninin  2^31 bayta kadar dosyalar için olan <type>off_t</type> türünde değil, 2^63 bayta kadar dosyalar için olan <type>off64_t</type> türünde olmasıdır. Bu işlev için kullanılan <parameter>filedes</parameter> tanıtıcısının <function>open64</function> ile açılması önemlidir. Aksi takdirde, küçük dosya kipinde açılmış dosya tanıtıcılı <type>off64_t</type> türündeki dosya konumları hatalara yol açacaktır.
   </para>
   <para>
    Kaynak dosyası <code>_FILE_OFFSET_BITS == 64</code> ile derlenmişse 32 bitlik sistemlerde bu işleve <function>pread</function> ismiyle erişilir. Yani 64 bitlik arayüz 32 bitlik olanıyla değiştirilir.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-write"><primary>dosya tanıtıcılar</primary><secondary>yazılması</secondary></indexterm>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-write"><primary>write</primary></indexterm>
   <csproto type="işlev">
    <csname><type>ssize_t</type><function>write</function></csname>
    <csparam><type>int</type><parameter>filedes</parameter></csparam>
    <csparam><ptr>const&nbsp;void</ptr><parameter>buffer</parameter></csparam>
    <csparam><type>size_t</type><parameter>size</parameter></csparam>
   </csproto>
   <header>&unistd.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <code>write</code> işlevi <parameter>filedes</parameter> tanıtıcılı dosyaya <parameter>buffer</parameter> tamponundaki <parameter>size</parameter> baytı yazar. <parameter>buffer</parameter> içindeki verinin bir karakter dizgesi olması gerekmediği gibi boş karakter de sıradan bir karakter olarak ele alınır.
   </para>
   <para>
    İşlevin normal dönüş değeri yazılabilen baytların sayısıdır. Bu <parameter>size</parameter> sayıda olabileceği halde hep daha küçük olur. İşlevin, tüm veri yazılana kadar tekrarlanan <code>write</code> çağrıları şeklinde bir döngü içinde kullanılması gerekir.
   </para>
   <para>
    <code>write</code> döndükten hemen sonra kuyruklanan veri okunabilir. Bunun için verinin kalıcı bir saklama alanına yazılması şart değildir. Devam etmeden önce verinin kalıcı saklama alanına yazılmasını sağlamak için <function>fsync</function> kullanılabilir. (Yazma işlemini ard arda çağrılar şeklinde bir defada gerçekleştirip saklama alanına yazma işini sisteme bırakmak daha verimlidir. Normalde bu veri diske bir dakikadan daha geç yazılmaz.) Günümüz sistemlerinde <function>fdatasync</function> adında bir işlev daha vardır ve bununla dosya verisinin bütünlüğü garanti edilmiştir ve daha hızlıdır. Dosya  <varname>O_FSYNC</varname> kipinde açılırsa <code>write</code> çağrıları veri diske yazılmadan dönmeyecektir; bkz.  <xref linkend="glibc-Operating-Modes"/>.
   </para>
   <para>
    Hata durumunda işlev <code>-1</code> ile döner. Aşağıdaki <varname>errno</varname> hata durumları bu işlev için tanımlanmıştır:
   </para>
   <variablelist>
    <varlistentry>
     <term><code>EAGAIN</code></term>
     <listitem>
      <para>
       Normalde, yazma işlemi tamamlanana kadar <code>write</code> dönmez. Fakat <varname>O_NONBLOCK</varname> seçeneği etkinse (bkz. <xref linkend="glibc-Control-Operations"/>), hiçbir veri yazılmadan işlev hemen bu hata durumu ile döner. Bu duruma bir örnek vermek gerekirse, sürecin  akış denetimini destekleyen bir uçbirim bir <varname>STOP</varname> karakteri aldığında çıktının aygıta yazılmasını engellemesi verilebilir.
      </para>
      <note><title>Uyumluluk Bilgisi</title>
       <para>
        BSD Unix'in çoğu sürümü bu hata kodu için farklı bir hata kodu kullanır: <varname>EWOULDBLOCK</varname>. &glibc;nde <varname>EWOULDBLOCK</varname>, <code>EAGAIN</code> için takma addır, dolayısıyla hangi ismin kullanıldığının bir önemi yoktur.
       </para>
      </note>
      <para>
       Bazı sistemlerde, çekirdek kullanıcı sayfaları için yeterli fiziksel bellek bulamazsa, bir karakter özel dosyasına büyük miktarda veri yazılması da <code>EAGAIN</code> hata koduna sebep olur. Bu, kullanıcı belleğine doğrudan erişim ile aktarım yapan aygıtlarla sınırlıdır. Bunlar uçbirimleri kapsamaz, çünkü uçbirimler için çekirdek içinde daima ayrı tamponlar vardır. GNU/Hurd sistemlerinde böyle bir sorunla asla karşılaşılmaz.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>EBADF</code></term>
     <listitem>
      <para>
       <parameter>filedes</parameter> bağımsız değişkeni geçerli bir dosya tanıtıcı değil ya da okumak için açılmamış.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>EFBIG</code></term>
     <listitem>
      <para>
       Dosya boyutu gerçeklemenin desteklediğinden büyük olacak.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>EINTR</code></term>
     <listitem>
      <para>
       Yazma işlemi tamamlanmadan önce bir sinyal tarafından durduruldu. Bir sinyal her zaman <code>write</code> işlevinin <code>EINTR</code> döndürmesine sebep olmaz; istenenden daha az baytı yazarak da işlev başarılı olabilir. Bkz. <xref linkend="glibc-Interrupted-Primitives"/>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>EIO</code></term>
     <listitem>
      <para>
       Çoğu aygıt ve disk dosyası için bu hata kodu bir donanım hatasını işaret eder.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>ENOSPC</code></term>
     <listitem>
      <para>
       Dosyayı içeren aygıt dolmuş.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>ESPIPE</code></term>
     <listitem>
      <para>
       Bu hata bir süreç tarafından yazmak için açılmamış bir ardışık sürece yazmaya çalışılırsa oluşur. Bu oluştuğu zaman sürece bir <varname>SIGPIPE</varname> sinyali gönderilir; bkz. <xref linkend="glibc-Signal-Handling"/>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>EINVAL</code></term>
     <listitem>
      <para>
       Bazı sistemlerde bir karakter veya blok aygıtına yazarken, konum ve boyut başlangıçlarının belli bir blok boyuna hizalanması gerekir. Bu hata konumların gerektiği gibi hizalanmadığını belirtir.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    <varname>EINTR</varname> başarısızlıklarından korunmak için bir düzenleme yapılmadıkça,  her başarısız <code>write</code> çağrısından sonra <varname>errno</varname> değişkenine bakılmalı ve bu <varname>EINTR</varname> hatası ise çağrı tekrarlanmalıdır. Bkz. <xref linkend="glibc-Interrupted-Primitives"/>.  Bunu yapmanın kolay bir yolu <function>TEMP_FAILURE_RETRY</function> makrosunu kullanmaktır:
   </para>
   <example>
    <screen>nbytes = TEMP_FAILURE_RETRY (write (desc, buffer, count));
</screen>
   </example>
   <para>
    <code>write64</code> isminde bir işlevin olmadığını unutulmamalıdır. İşlev olası geniş dosya konumlarını işlemek ya da değiştirmek için bir işlem yapmadığından bu gerekli değidir. Çekirdek gerekeni kendi içinde hallettiğinden <code>write</code> işlevi her durumda kullanılabilir.
   </para>
   <para>
    Bu işlev çok evreli yazılımlarda bir iptal noktasıdır. <code>write</code> çağrısı sırasında evre bazı öz kaynakları (bellek, dosya tanıtıcı, semafor, vb.) tahsis ettiğinde bu sorun ortaya çıkar. Evre tam bu anda bir iptal alırsa tahsis edilen öz kaynaklar yazılım sonlanana kadar tahsisli olarak kalır. Bu tür <code>write</code> çağrılarından kaçınmak için iptal işleyicilerle korunulmalıdır.
   </para>
   <para>
    <code>write</code> işlevi, akımlardan okuma yapan <function>fputc</function> gibi işlevler için temel ilkeldir.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-pwrite"><primary>dosya tanıtıcılar</primary><secondary>konumsal yazma</secondary></indexterm>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-pwrite"><primary>pwrite</primary></indexterm>
   <csproto type="işlev">
    <csname><type>ssize_t</type><function>pwrite</function></csname>
    <csparam><type>int</type><parameter>filedes</parameter></csparam>
    <csparam><ptr>const&nbsp;void</ptr><parameter>buffer</parameter></csparam>
    <csparam><type>size_t</type><parameter>size</parameter></csparam>
    <csparam><type>off_t</type><parameter>offset</parameter></csparam>
   </csproto>
   <header>&unistd.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <code>pwrite</code> işlevi ilk üç bağımsız değişkeninin ve dönüş değeri ile hata durumlarının aynı olmasıyla <function>write</function> işlevine çok benzer.
   </para>
   <para>
    Fark dördüncü bağımsız değişkende ve onun elde edilişindedir. Yazma işlemi <parameter>filedes</parameter> dosya tanıtıcısının geçerli konumundan değil, <parameter>offset</parameter> ile belirtilen konumdan başlar ve dosya tanıtıcısının konumu bu işlemden etkilenmez; değeri çağrı öncesindeki değerinde kalır.
   </para>
   <para>
    Kaynak dosyası <code>_FILE_OFFSET_BITS == 64</code> ile derlenmişse <code>pwrite</code> işlevi aslında 2^63 bayta kadar dosyalarla 64 bitlik <type>off_t</type> türünde konumlarla çalışan <function>pwrite64</function> işlevi olur.
   </para>
   <para>
    <code>pwrite</code> işlevinin normal dönüş değeri yazılan baytların sayısıdır. Hata durumunda <function>write</function> gibi <code>-1</code> ile döndüğü gibi hata kodları aşağıdakiler dışında aynıdır:
   </para>
   <variablelist>
    <varlistentry>
     <term><code>EINVAL</code></term>
     <listitem>
      <para>
       <parameter>offset</parameter> değeri negatif dolayısıyla kural dışı.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>ESPIPE</code></term>
     <listitem>
      <para>
       <parameter>offset</parameter> ardışık süreç ile ilişkili ve bu aygıt dosya içinde konum belirtilmesine izin vermiyor.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    İşlev Unix Tek Belirtiminin 2. sürümünde tanımlı bir oluşumdur.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-pwrite64"><primary>pwrite64</primary></indexterm>
   <csproto type="işlev">
    <csname><type>ssize_t</type><function>pwrite64</function></csname>
    <csparam><type>int</type><parameter>filedes</parameter></csparam>
    <csparam><ptr>const&nbsp;void</ptr><parameter>buffer</parameter></csparam>
    <csparam><type>size_t</type><parameter>size</parameter></csparam>
    <csparam><type>off64_t</type><parameter>offset</parameter></csparam>
   </csproto>
   <header>&unistd.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    Bu işlev <function>pwrite</function> işlevinin benzeridir.  Farkı <parameter>offset</parameter> bağımsız değişkeninin  2^31 bayta kadar dosyalar için olan <type>off_t</type> türünde değil, 2^63 bayta kadar dosyalar için olan <type>off64_t</type> türünde olmasıdır. Bu işlev için kullanılan <parameter>filedes</parameter> tanıtıcısının <function>open64</function> ile açılması önemlidir. Aksi takdirde, küçük dosya kipinde açılmış dosya tanıtıcılı <type>off64_t</type> türündeki dosya konumları hatalara yol açacaktır.
   </para>
   <para>
    Kaynak dosyası <code>_FILE_OFFSET_BITS == 64</code> ile derlenmişse 32 bitlik sistemlerde bu işleve <function>pwrite</function> ismiyle erişilir. Yani 64 bitlik arayüz 32 bitlik olanıyla değiştirilir.
   </para>
  </csynopsis>
 </chapter>

 <chapter xml:id="glibc-File-Position-Primitive">
  <title>Dosya Konumu İlkeli</title>
  <titleabbrev>Bir tanıtıcının dosya konumunun belirtilmesi.</titleabbrev>
  <para>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-konum"><primary>dosya tanıtıcılar</primary><secondary>dosyadaki konumu</secondary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-konumlama"><primary>dosya tanıtıcılar</primary><secondary>konumlama</secondary></indexterm>
   Akımın dosya konumunun <function>fseek</function> ile belirtilmesi gibi, sonraki <function>read</function> veya <function>write</function> işlemleri için bir tanıtıcının dosya konumu da <function>lseek</function> ile  belirtilebilir. Dosya konumlamanın ne olduğu ve daha fazlası için <xref linkend="glibc-File-Positioning"/> bölümüne bakılabilir.
  </para>
  <para>
   Bir tanıtıcıdan geçerli dosya konumunu okumak için <code>lseek (<replaceable>tanıtıcı</replaceable>, 0, SEEK_CUR)</code> çağrısı kullanılabilir.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-lseek"><primary>lseek</primary></indexterm>
   <csproto type="işlev">
    <csname><type>off_t</type><function>lseek</function></csname>
    <csparam><type>int</type><parameter>filedes</parameter></csparam>
    <csparam><type>off_t</type><parameter>offset</parameter></csparam>
    <csparam><type>int</type><parameter>whence</parameter></csparam>
   </csproto>
   <header>&unistd.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <code>lseek</code> işlevi <parameter>filedes</parameter> tanıtıcısında dosya konumunu değiştirmek için kullanılır.
   </para>
   <para>
    <parameter>whence</parameter> bağımsız değişkeni <function>fseek</function> işlevindeki gibi <parameter>offset</parameter> konumunun nasıl yorumlanacağını belirtir. Değeri <varname>SEEK_SET</varname>, <varname>SEEK_CUR</varname> veya <varname>SEEK_END</varname> sembolik sabitlerinden biri olabilir.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-SEEK_SET"><primary>SEEK_SET</primary></indexterm>
    <csproto type="sabit">
     <csname><function>SEEK_SET</function></csname>
    </csproto>
    <header> &stdio.h;</header>
    <para>
     <parameter>whence</parameter> bağımsız değişkeni, dosyanın başlangıcından itibaren karakter sayısını belirtir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-SEEK_CUR"><primary>SEEK_CUR</primary></indexterm>
    <csproto type="sabit">
     <csname><function>SEEK_CUR</function></csname>
    </csproto>
    <header> &stdio.h;</header>
    <para>
     <parameter>whence</parameter> bağımsız değişkeni, geçerli dosya konumundan itibaren karakter sayısını belirtir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-SEEK_END"><primary>SEEK_END</primary></indexterm>
    <csproto type="sabit">
     <csname><function>SEEK_END</function></csname>
    </csproto>
    <header> &stdio.h;</header>
    <para>
     <parameter>whence</parameter> bağımsız değişkeni, dosya sonundan kaç karakter sayılacağını belirtir. Negatif bir değer dosya sonundan ileriye doğru, pozitif bir değer dosya sonundan geriye doğru karakter sayısıdır. Konumu sondan başa doğru belirtirseniz ve yazma yapıyorsanız, dosya, konuma kadar sıfırlarla doldurularak büyütülecektir.
    </para>
   </csynopsis>
   <para>
    <code>lseek</code> işlevinin normal dönüş değeri sonuçlanan dosya başlangıcından itibaren karakter sayısı olarak dosya konumudur. Bu özellik, geçerli dosya konumunu öğrenmek için <varname>SEEK_CUR</varname> ile kullanılabilir.
   </para>
   <para>
    Dosyaya ekleme yapmak istenirse, dosya konumunu geçerli dosya sonundan itibaren <varname>SEEK_END</varname> ile belirtmek yeterli olmaz. Dosya konumu değiştirildikten sonra, ancak yazmaya başlanmadan önce, başka bir süreç dosyaya bir miktar veri yazmış olabilir, dolayısıyla böyle bir konuma yapılacak bir yazma işlemi mevcut verinin kaybına sebep olur. Bunun olmaması için <varname>O_APPEND</varname> işletim kipinin kullanılması gerekir; bkz. <xref linkend="glibc-Operating-Modes"/>.
   </para>
   <para>
    Dosya konumu, dosyanın geçerli dosya sonundan başa doğru belirtilebilir. Bu dosyanın kendisini uzatmaz; <code>lseek</code> dosyanın boyunu asla değiştirmez. Fakat aynı konuma daha sonra yapılan çıktılama dosyayı uzatır.  Dosyanın önceki sonu ile yeni konum arası sıfırlarla doldurulur. Bu yolla uzatılan dosyada sıfırlardan oluşan bir "delik" oluşur, disk üzerinde delik için yer ayrılmaz, bu durumda dosya göründüğünden daha az alanı kaplar; bu durumdaki bir dosyaya "seyrek dosya" (sparse file) denir.
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-seyrek"><primary>dosyalar</primary><secondary>seyrek</secondary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-delik"><primary>dosyalar</primary><secondary>delikler</secondary></indexterm>
   </para>
   <para>
    Dosya konumu değiştirilemezse ya da işlem bir şekilde geçersiz olmuşsa, işlev <code>-1</code> ile döner. Aşağıdaki <varname>errno</varname> hata durumları bu işlev için tanımlanmıştır:
   </para>
   <variablelist>
    <varlistentry>
     <term><code>EBADF</code></term>
     <listitem>
      <para>
       <parameter>filedes</parameter> geçerli bir dosya tanıtıcısı değil.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>EINVAL</code></term>
     <listitem>
      <para>
       <parameter>whence</parameter> bağımsız değişkeninin değeri geçersiz ya da sonuçlanan dosya konumu geçersiz. Dosya konumu geçersiz.
     </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>ESPIPE</code></term>
     <listitem>
      <para>
       <parameter>offset</parameter> bağımsız değişkeni, bir ardışık süreç ya da uçbirim gibi dosya konumlamasına izin verilmeyen bir nesneyle ilgili olduğundan konumlama yapılamıyor. (POSIX.1 bu hatayı sadece ardışık süreçler için belirtir, ancak GNU sistemlerinde konumlama yapılamayan her nesne için daima <command>ESPIPE</command> hatası alınır.)
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    Kaynak dosyası <code>_FILE_OFFSET_BITS == 64</code> ile derlenmişse <code>lseek</code> işlevi aslında 2^63 bayta kadar dosyalarla 64 bitlik <type>off_t</type> türünde konumlarla çalışan <function>lseek64</function> işlevi olur.
   </para>
   <para>
    Bu işlev çok evreli yazılımlarda bir iptal noktasıdır. <code>lseek</code> çağrısı sırasında evre bazı öz kaynakları (bellek, dosya tanıtıcı, semafor, vb.) tahsis ettiğinde bu sorun ortaya çıkar. Evre tam bu anda bir iptal alırsa tahsis edilen öz kaynaklar yazılım sonlanana kadar tahsisli olarak kalır. Bu tür <code>lseek</code> çağrılarından kaçınmak için iptal işleyicilerle korunulmalıdır.
   </para>
   <para>
    <command>lseek</command> işlevi, akımlardan okuma yapan <function>fseek</function>, <function>fseeko</function>, <function>ftell</function>, <function>ftello</function> ve <function>rewind</function> gibi işlevler için temel ilkeldir.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-lseek64"><primary>lseek64</primary></indexterm>
   <csproto type="işlev">
    <csname><type>off64_t</type><function>lseek64</function></csname>
    <csparam><type>int</type><parameter>filedes</parameter></csparam>
    <csparam><type>off64_t</type><parameter>offset</parameter></csparam>
    <csparam><type>int</type><parameter>whence</parameter></csparam>
   </csproto>
   <header>&unistd.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    Bu işlev <function>lseek</function> işlevinin benzeridir.  Farkı <parameter>offset</parameter> bağımsız değişkeninin  2^31 bayta kadar dosyalar için olan <type>off_t</type> türünde değil, 2^63 bayta kadar dosyalar için olan <type>off64_t</type> türünde olmasıdır. Bu işlev için kullanılan <parameter>filedes</parameter> tanıtıcısının <function>open64</function> ile açılması önemlidir. Aksi takdirde, küçük dosya kipinde açılmış dosya tanıtıcılarla <type>off64_t</type> türündeki dosya konumları hatalara yol açacaktır.
   </para>
   <para>
    Kaynak dosyası <code>_FILE_OFFSET_BITS == 64</code> ile derlenmişse 32 bitlik sistemlerde bu işleve <function>lseek</function> ismiyle erişilir. Yani 64 bitlik arayüz 32 bitlik olanıyla değiştirilir.
   </para>
  </csynopsis>
  <para>
   Bir dosya defalarca açılırsa ya da <function>dup</function> ile tanıtıcı çoğaltılırsa aynı dosya için çok sayıda tanıtıcı olabilir. <function>open</function> çağrıları ile elde edilen tanıtıcıların dosya konumları birbirinden bağımsızdır dolayısıyla biri üzerinde kullanılan <function>lseek</function> diğerlerini etkilemez. Örneğin,
  </para>
  <example>
   <screen>{
  int d1, d2;
  char buf[4];
  d1 = open ("foo", O_RDONLY);
  d2 = open ("foo", O_RDONLY);
  lseek (d1, 1024, SEEK_SET);
  read (d2, buf, 4);
}
</screen>
   <para>
    <filename>foo</filename> dosyasının ilk dört karakterini okuyacaktır. (Gerçek bir yazılımda gerekli olan hata denetimine, örneği karıştırmaması için yer verilmemiştir.)
   </para>
   <para>
    Tersine olarak, çoğaltma yoluyla elde edilen dosya tanıtıcılar ortak bir dosya  konumunu paylaşır. Biri üzerinde yapılan okuma, yazma, dosyada konumlama gibi her işlem diğerlerini etkiler. Örneğin,
   </para>
   <screen>{
  int d1, d2, d3;
  char buf1[4], buf2[4];
  d1 = open ("foo", O_RDONLY);
  d2 = dup (d1);
  d3 = dup (d2);
  lseek (d3, 1024, SEEK_SET);
  read (d1, buf1, 4);
  read (d2, buf2, 4);
}
</screen>
   <para>
    <filename>foo</filename> dosyasının 1024. karakterinden başlayarak dört karakter okur ve 1028. karakterden başlayarak dört karakter daha okur.
   </para>
  </example>
  <csynopsis>
   <indexterm linkend="glibc-tp" xml:id="glibc-tp-off_t"><primary>off_t</primary></indexterm>
   <csproto type="veri türü">
    <csname><function>off_t</function></csname>
   </csproto>
   <header>&unistd.h;</header>
   <para>
    Bu işaretli tamsayı veri türü dosya boyutlarını göstermekte kullanılır. &glibc;nde <type>int</type> türünden daha dardır.
   </para>
   <para>
    Kaynak dosyası <code>_FILE_OFFSET_BITS == 64</code> ile derlenmişse, bu veri türü <type>off64_t</type> veri türüne eşdeğer olur.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-tp" xml:id="glibc-tp-off64_t"><primary>off64_t</primary></indexterm>
   <csproto type="veri türü">
    <csname><function>off64_t</function></csname>
   </csproto>
   <header>&unistd.h;</header>
   <para>
    <type>off_t</type> veri türüne benzer.  Bir farkla: 32 bitlik makinelerde <type>off_t</type> 32 bitlikken <code>off64_t</code> 64 bitliktir. Böylece dosyalar 2^63 bayta kadar adreslenebilir.
   </para>
   <para>
    Kaynak dosyası <code>_FILE_OFFSET_BITS == 64</code> ile derlenmişse, bu veri türü <type>off_t</type> ismiyle kullanılır.
   </para>
  </csynopsis>
  <para>
   <code>SEEK_…</code> sabitleri için eski BSD sistemleri ile uyumluluk adına takma adlar tanımlanıştır. Bunlar iki ayrı başlık dosyasında tanımlıdır: &fcntl.h; ve &sys-file.h;.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-vr" xml:id="glibc-vr-L_SET"><primary>L_SET</primary></indexterm>
   <csproto type="sabit">
    <csname><function>L_SET</function></csname>
   </csproto>
   <header>&sys-file.h;</header>
   <para>
    <varname>SEEK_SET</varname> için takma addır.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-vr" xml:id="glibc-vr-L_INCR"><primary>L_INCR</primary></indexterm>
   <csproto type="sabit">
    <csname><function>L_INCR</function></csname>
   </csproto>
   <header>&sys-file.h;</header>
   <para>
    <varname>SEEK_CUR</varname> için takma addır.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-vr" xml:id="glibc-vr-L_XTND"><primary>L_XTND</primary></indexterm>
   <csproto type="sabit">
    <csname><function>L_XTND</function></csname>
   </csproto>
   <header>&sys-file.h;</header>
   <para>
    <varname>SEEK_END</varname> için takma addır.
   </para>
  </csynopsis>
 </chapter>

 <chapter xml:id="glibc-Descriptors-and-Streams">
  <title>Tanıtıcılar ve Akımlar</title>
  <titleabbrev>Tanıtıcılar ile akımların birbirine dönüştürülmesi.</titleabbrev>
  <para>
   <indexterm linkend="glibc-pg"><primary>stdio.h</primary></indexterm>
   <indexterm linkend="glibc-cp"><primary>akımlar</primary><secondary>dosya tanıtıcıların elde edilmesi</secondary></indexterm>
   <indexterm linkend="glibc-cp"><primary>dosya tanıtıcılar</primary><secondary>akımlara dönüştürülmesi</secondary></indexterm>
   Belirtilen bir dosya tanıtıcı için <function>fdopen</function> ile bir akım oluşturulabileceği gibi <function>fileno</function> ile de mevcut bir akımın dosya tanıtıcısı elde edilebilir. Bu işlevler &stdio.h; başlık dosyasında bildirilmiştir.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-fdopen"><primary>fdopen</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-fdopen"><primary>dosya tanıtıcılar</primary><secondary>akım oluşturma</secondary></indexterm>
   <csproto type="işlev">
    <csname><ptr>FILE</ptr><function>fdopen</function></csname>
    <csparam><type>int</type><parameter>filedes</parameter></csparam>
    <csparam><ptr>const&#160;char</ptr><parameter>opentype</parameter></csparam>
   </csproto>
   <header>&stdio.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&asunsafe; &heap; &lock;</concept>
    <concept>&acunsafe; &mem; &lock;</concept>
   </conceptlist>
   <para>
    <code>fdopen</code> işlevi <parameter>filedes</parameter> tanıtıcısı için yeni bir akım döndürür.
   </para>
   <para>
    <parameter>opentype</parameter> bağımsız değişkeni <code>fdopen</code> işlevindeki gibi yorumlanır (bkz. <xref linkend="glibc-Opening-Streams"/>). Bir farkla: GNU sisteminde ikil ve metin dosyalar arasında bir fark gözetilmediğinden <code>b</code> seçeneğine izin verilmez. Ayrıca <code>&quot;w&quot;</code> ve <code>&quot;w+&quot;</code> dosyanın kırpılmasına sebep olmaz; bu sadece dosyayı açarken etkilidir ve bu durumda zaten dosya açıktır. <parameter>opentype</parameter> bağımsız değişkeni açık dosyanın kipiyle eşleşmek zorundadır, buna dikkat edilmelidir.
   </para>
   <para>
    İşlevin normal dönüş değeri yeni akımdır. Akım oluşturulamazsa (örneğin, dosya tanıtıcının dosya kipinin <parameter>opentype</parameter> bağımsız değişkeninde belirtilen erişim türüne izin vermezse) boş gösterici döner.
   </para>
   <para>
    Bazı sistemlerde, <parameter>opentype</parameter> bağımsız değişkeninde belirtilen erişim türüne izin vermeyen dosya tanıtıcı kipi saptanırken <code>fdopen</code> başarısız olabilir. &glibc; bunu daima denetler.
   </para>
   <para>
    <code>fdopen</code> işlevinin kullanım örneği <xref linkend="glibc-Creating-a-Pipe"/> bölümünde bulunabilir.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-fileno"><primary>fileno</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-fileno"><primary>akımlar</primary><secondary>dosya tanıtıcı</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>fileno</function></csname>
    <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
   </csproto>
   <header>&stdio.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    Bu işlev <parameter>stream</parameter> akımıyla ilişkili dosya tanıtıcı ile döner. Bir hata saptanırsa (örn, <parameter>stream</parameter> geçersizse) ya da <parameter>stream</parameter> bir dosyayla G/Ç yapmıyorsa, işlev <code>-1</code> ile döner.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-fileno_unlocked"><primary>fileno_unlocked</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-fileno_unlocked"><primary>akımlar</primary><secondary>dosya tanıtıcı</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>fileno_unlocked</function></csname>
    <csparam><ptr>FILE</ptr><parameter>stream</parameter></csparam>
   </csproto>
   <header>&stdio.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <code>fileno_unlocked</code> işlevi, durum <varname>FSETLOCKING_INTERNAL</varname> ise akımı doğrudan kilitlememesi dışında <function>fileno</function> işlevine eşdeğerdir.
   </para>
   <para>
    Bu işlev GNU oluşumudur.
   </para>
  </csynopsis>
  <para>
   <indexterm linkend="glibc-cp"><primary>standard dosya tanıtıcılar</primary></indexterm>
   <indexterm linkend="glibc-cp"><primary>dosya tanıtıcılar</primary><secondary>standart dosya tanıtıcılar</secondary></indexterm>
   <varname>stdin</varname>, <varname>stdout</varname> ve <varname>stderr</varname> <link linkend="glibc-Standard-Streams">standart akımlarının</link> dosya tanıtıcıları için simgesel sabitler vardır ve bunlar &unistd.h; başlık dosyasında tanımlıdır.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-vr" xml:id="glibc-vr-STDIN_FILENO"><primary>STDIN_FILENO</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-STDIN_FILENO"><primary>standart girdi</primary><secondary>dosya tanıtıcısl</secondary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-STDIN_FILENO_"><primary>dosya tanıtıcılar</primary><secondary>standart girdi</secondary></indexterm>
   <csproto type="sabit">
    <csname><function>STDIN_FILENO</function></csname>
   </csproto>
   <header>&unistd.h;</header>
   <para>
    Bu makro standart girdi için dosya tanıtıcı olarak <code>0</code> değerine sahiptir.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-vr" xml:id="glibc-vr-STDOUT_FILENO"><primary>STDOUT_FILENO</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-STDOUT_FILENO_"><primary>dosya tanıtıcılar</primary><secondary>standart çıktı</secondary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-STDOUT_FILENO"><primary>standart çıktı</primary><secondary>dosya tanıtıcısı</secondary></indexterm>
   <csproto type="sabit">
    <csname><function>STDOUT_FILENO</function></csname>
   </csproto>
   <header>&unistd.h;</header>
   <para>
    Bu makro standart çıktı için dosya tanıtıcı olarak <code>1</code> değerine sahiptir.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-vr" xml:id="glibc-vr-STDERR_FILENO"><primary>STDERR_FILENO</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-STDERR_FILENO_"><primary>dosya tanıtıcılar</primary><secondary>standart hata</secondary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-STDERR_FILENO"><primary>standart hata</primary><secondary>dosya tanıtıcısı</secondary></indexterm>
   <csproto type="sabit">
    <csname><function>STDERR_FILENO</function></csname>
   </csproto>
   <header>&unistd.h;</header>
   <para>
    Bu makro standart hata için dosya tanıtıcı olarak <code>2</code> değerine sahiptir.
   </para>
  </csynopsis>
 </chapter>

 <chapter xml:id="glibc-Stream-Descriptor-Precautions" userlevel="notoc">
  <?dbhtml stop-chunking?>
  <title>Akımlarla Tanıtıcıları Karıştırmanın Tehlikeleri</title>
  <titleabbrev>Akımlar ve tanıtıcılar birlikte kullanılıyorsa dikkatli olunmalıdır.</titleabbrev>
  <para>
   <indexterm linkend="glibc-cp"><primary>dosyalar</primary><secondary>kanallar</secondary></indexterm>
   <indexterm linkend="glibc-cp"><primary>kanallar</primary></indexterm>
   <indexterm linkend="glibc-cp"><primary>akımlar</primary><secondary>dosya tanıtıcılarla karıştırılırsa</secondary></indexterm>
   <indexterm linkend="glibc-cp"><primary>dosya tanıtıcılar</primary><secondary>akımlarla karıştırılırsa</secondary></indexterm>
   Aynı dosyaya bağlı çok sayıda dosya tanıtıcısı ve akıma (bunların ikisine birden <wordasword>kanallar</wordasword> diyebiliriz) sahip olabilirsiniz ama bu iki kanalın birbirlerinin yerine kullanımından kaçınmak gerekir. Ele alınacak iki durum vardır: tek bir dosya konumunu paylaşan <wordasword>ilintili kanallar</wordasword> ile kendi dosya konumları olan <wordasword>bağımsız kanallar</wordasword>.
  </para>
  <para>
   Tüm erişimin girdi amacıyla olması dışında, bir dosyayla veri iletimi için yazılımda sadece bir kanal kullanmak en iyisidir. Örneğin, bazı şeylerin sadece dosya tanıtıcılarla yapılabildiği bir ardışık komut açılırsa, tüm G/Ç işlemleri hem dosya tanıtıcı ile hem de bu dosya tanıtıcı için <function>fdopen</function> ile oluşturulacak akım ile yapılabilir.
  </para>
  <sect1 xml:id="glibc-Linked-Channels">
   <title>İlintili Kanallar</title>
   <titleabbrev>Dosya konumunu paylaşan kanallarla çalışma.</titleabbrev>
   <para>
    <indexterm linkend="glibc-cp"><primary>kanallar</primary><secondary>ilintili</secondary></indexterm>
    Tek bir açılışta aynı dosya konumunu paylaşan kanallara <wordasword>ilintili kanallar</wordasword> denir. <function>fdopen</function> kullanarak bir tanıtıcıdan akım oluşturunca, <function>fileno</function> kullanarak bir akım ile ilişkili dosya tanıtıcısına erişildiğinde, <function>dup</function> veya <function>dup2</function> ile bir dosya tanıtıcısı çoğaltıldığında ve <function>fork</function> ile dosya tanıtıcılar üst süreçten miras alındığında ilintili bir kanal elde edilmiş olur. Uçbirimler ve ardışık komutlar gibi rastgele erişimi desteklemeyen dosyalar için <emphasis>tüm</emphasis> kanallar zorunlu olarak ilintilidir. Rasgele erişimli dosyalarda, sona ekleme yapan akımlar da zorunlu olarak diğeri ile ilintilidir.
   </para>
   <para>
    <indexterm linkend="glibc-cp"><primary>akımlar</primary><secondary>temizlenmesi</secondary></indexterm>
    G/Ç için akım kullanılıyorsa (sadece akım açılmışsa) ve onunla ilintili diğer kanalla (bir akım ya da tanıtıcı olabilir) G/Ç yapılmak istenirse, kullanılmadan önce <link linkend="glibc-Cleaning-Streams">akımın temizlenmesi</link> gerekir.
   </para>
   <para>
    Bir sürecin sonladırılması ya da süreç içinde yeni bir yazılımın çalıştırılması süreç içindeki tüm akımların ortadan kaldırılmasına sebep olur. Bu akımlarla ilintili tanıtıcılar diğer süreçte kalır, dolayısıyla dosya konumları tanımsız duruma gelir. Bundan kaçınmak için ortadan kaldırılmadan önce akımların temizlenmesi gerekir.
   </para>
  </sect1>
   <sect1 xml:id="glibc-Independent-Channels">
   <title>Bağımsız Kanallar</title>
   <titleabbrev>Ayrı ayrı açılmış, ilintisiz kanallarla çalışma.</titleabbrev>
   <para>
    <indexterm linkend="glibc-cp"><primary>kanallar</primary><secondary>bağımsız</secondary></indexterm>
    Dosya konumlaması yapılabilen bir dosya için ayrı kanallar (akım ya da tanıtıcı) açtığınızda her kanalın kendi dosya konumu olur. Bu tür kanallara <wordasword>bağımsız kanallar</wordasword> denir.
   </para>
   <para>
    Sistem her kanalı bağımsız olarak elde eder. Çoğu zaman, bu tahmin edilebilir ve (özellikle girdi için) doğal bir sonuçtur: her kanal, kendi dosyasında ve kendi konumunda sıralı okuma ya da yazma yapabilir. Bununla birlikte, birer akım olan bazı kanallarda şunlara dikkat etmeniz gerekir:
   </para>
   <itemizedlist>
    <listitem>
     <para>
      Dosyanın aynı parçasında okuma ya da yazma yapılacaksa, bir şey yapmadan önce ve kullandıktan sonra çıktı akımının temizlenmesi gerekir.
     </para>
    </listitem>
    <listitem>
     <para>
      Bağımsız kanal kullanılarak değiştirilmekte olan verinin okunmasından önce girdi akımının temizlenmesi gerekir. Aksi takdirde, akımın tamponunda kalmış eski veri okunabilir.
     </para>
    </listitem>
   </itemizedlist>
   <para>
    Bir dosyanın sonunda tek bir kanala çıktılama yapılırsa, diğer bağımsız kanalların dosya sonuna göre yaptıkları konumlama alakasız bir noktaya taşınmış olur. Dosya konumlaması ile dosyaya yazma arasında başka bir sürecin aynı şeyi yapması engellenemediği gibi bunun tersine olarak diğer süreçlerin dosya konumları doğru yere kaydırılamaz. Ama tanıtıcı ya da akım dosya sonuna ekleme yapan türde açılırsa, daima geçerli dosya sonuna ekleme yapılır. Dosya sonu konumlamasını doğru yapabilmek için çıktı kanalının, kanal bir akımsa temizlenmesi gerekir.
   </para>
   <para>
    Rastgele erişimi desteklemeyen bir dosya için farklı dosya konumları olan iki kanal açmak mümkündür. Bu şekilde dosyaya okuma ve yazma amacıyla açılan kanallar bağımsız açılsa bile ilintili olur. Dosya sonuna ekleme türünde açılan kanallar daima ilintilidir. Bu kanallar için <link linkend="glibc-Linked-Channels">ilintili kanallarla ilgili kurallar</link> uygulanır.
   </para>
  </sect1>
  <sect1 xml:id="glibc-Cleaning-Streams">
   <title>Akımların Temizlenmesi</title>
   <titleabbrev>Başka bir kanala güvence sağlamak için akımın temizlenmesi.</titleabbrev>
   <para>
    Çoğu durumda akımı temizlemek için <function>fflush</function> kullanılabilir.
   </para>
   <para>
    Akımın zaten temiz olduğu biliniyorsa <function>fflush</function> çağrısı yapılmayabilir. Örneğin, tamponsuz bir akım daima temizdir. Dosya sonundaki girdi akımı daima temizdir. Son çıktılanan karakter satır sonu karakteri ise satır tamponlu bir akım daima temizdir. Bununla birlikte girdi akımı açıldığı anda, girdi tamponu boş olmayabileceğinden, temiz olmayabilir.
   </para>
   <para>
    Çoğu sistemde bir akımı temizlemenin mümkün olmadığı bir durum vardır. Bu, rastgele erişimli olmayan bir dosyadan girdi yapan bir akımın varlığıdır. Böyle akımlar genellikle sürekli okur ama dosya rastgele erişimli olmadığında, okunmuş olan veriye tekrar erişmenin bir yolu yoktur. Girdi akımı rastgele erişimli bir dosyadan okuduğu zaman, <function>fflush</function> akımı temizler ama dosya konumlayıcıyı alakasız bir yerde bırakır; bu bakımdan, herhangi bir G/Ç işlemi yapmadan önce dosya konumlayıcı doğru yere konumlanmalıdır.
   </para>
   <para>
    Sadece çıktılama yapan bir akımın kapatılması da <function>fflush</function> çağrısına sebep olur, dolayısıyla bir çıktı akımının temizlenmesinde bu yöntem de kullanılabilir.
   </para>
   <para>
    Uçbirim kipini ayarlamak gibi denetim işlemleri için tanıtıcısını kullanmadan önce akım temizlenemez; bu işlemler dosya konumunu etkilemez ve dosya konumundan etkilenmez. Bu işlemler için her tanıtıcı kullanılabilir ve tüm kanallar aynı anda etkilenir. Bununla birlikte, metin zaten bir akıma çıktılanıp hemen ardından boşaltılıyorsa, yeni uçbirim kiplerine konu olacak akım tarafından hala tamponlu olur. Yapılan çıktılamanın o anda etkili olan uçbirim ayarları tarafından kapsandığından emin olmak için kipi ayarlanmadan önce uçbirimin çıktı akımları boşaltılır. Bkz. <xref linkend="glibc-Terminal-Modes"/>.
   </para>
  </sect1>
 </chapter>

 <chapter xml:id="glibc-Scatter-Gather">
  <title>G/Ç'yı Hızlı Dağıtıp Toplama</title>
  <titleabbrev>Kesintili tamponlarda hızlı G/Ç.</titleabbrev>
  <para>
   <indexterm linkend="glibc-cp"><primary>dağıtma-toplama</primary></indexterm>
   <indexterm linkend="glibc-cp"><primary>akımlar</primary><secondary>hızlı dağıtıp toplama</secondary></indexterm>
   Bazı uygulamalarda bellekte ayrı yerlerde duran çok sayıda tampona yazmak ya da okumak gerekebilir. Bu işlem çok sayıda <function>read</function> ve <function>write</function> çağrısı ile kolayca yapılabildiği halde, her çekirdek çağrısının sabit bir maliyeti olduğundan bu verimli olmaz.
   </para>
   <para>
    Bunun yerine, çoğu platformada tek bir çekirdek çağrısında her iki işlemi birlikte yapan yüksek hızlı özel ilkeller vardır. &glibc; tarafından bu ilkellerin her sistemde öykünülmesi sağlanarak bunların taşınabilirliğe konu olmaması sağlanmıştır. Bu ilkeller &sys-uio.h; başlık dosyasında tanımlıdır.
   </para>
   <para>
    Bu işlevler, her tamponun boyutunun ve konumunun belirtildiği <type>iovec</type> yapılarından oluşan bir diziyle çalışır.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-tp" xml:id="glibc-tp-iovec"><primary sortas="iovec">struct&#160;iovec</primary></indexterm>
    <csproto type="veri türü">
     <csname><type>struct</type><function>iovec</function></csname>
    </csproto>
    <header>&sys-uio.h;</header>
    <para>
     <code>iovec</code> yapısı bir tampon ile ilgili bilgileri içerir. İki alanı vardır:
    </para>
    <glosslist>
     <glossentry>
      <glossterm>
       <type>void *</type><structfield>iov_base</structfield>
      </glossterm>
      <glossdef>
       <para>
        Tamponun adresidir.
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm>
       <type>size_t </type><structfield>iov_len</structfield>
      </glossterm>
      <glossdef>
       <para>
        Tamponun uzunluğudur.
       </para>
      </glossdef>
     </glossentry>
    </glosslist>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-readv"><primary>readv</primary></indexterm>
    <csproto type="işlev">
     <csname><type>ssize_t</type><function>readv</function></csname>
     <csparam><type>int</type><parameter>filedes</parameter></csparam>
     <csparam><ptr>const&#160;struct&#160;iovec</ptr><parameter>vector</parameter></csparam>
     <csparam><type>int</type><parameter>count</parameter></csparam>
    </csproto>
    <header>&sys-uio.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&asunsafe; &heap;</concept>
     <concept>&acunsafe; &mem;</concept>
    </conceptlist>
    <para>
     <code>readv</code> işlevi veriyi <parameter>filedes</parameter> tanıtıcısından okuyup <parameter>count</parameter> yapılık <parameter>vector</parameter> dizisindeki tamponlara bir tampon dolduktan sonra diğerine geçerek dağıtır.
    </para>
    <para>
     <code>readv</code> işlevinin tamponların tümünü dolduracağı garanti edilmemiştir. <function>read</function> işlevinde olduğu gibi aynı sebeplerle işlem bir noktada durabilir.
    </para>
    <para>
     Normal dönüş değeri tampondan okunan (tamponlara yazılan değil) baytları sayısıdır. <code>0</code> değeri dosya sonunu belirtir. <code>-1</code> değeri ise bir hata saptandığını gösterir. Olası hatalar <function>read</function> işlevindekilerle aynıdır.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-writev"><primary>writev</primary></indexterm>
    <csproto type="işlev">
     <csname><type>ssize_t</type><function>writev</function></csname>
     <csparam><type>int</type><parameter>filedes</parameter></csparam>
     <csparam><ptr>const&#160;struct&#160;iovec</ptr><parameter>vector</parameter></csparam>
     <csparam><type>int</type><parameter>count</parameter></csparam>
    </csproto>
    <header>&sys-uio.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&asunsafe; &heap;</concept>
     <concept>&acunsafe; &mem;</concept>
    </conceptlist>
    <para>
     <code>writev</code> işlevi veriyi <parameter>count</parameter> yapılık <parameter>vector</parameter> dizisindeki tamponları sırayla okuyarak toplar ve <parameter>filedes</parameter> tanıtıcısına yazar.
    </para>
    <para>
     <function>readv</function> gibi, <code>writev</code> işlevi de <function>write</function> işlevindeki aynı koşullarda işlemin ortasında durabilir.
    </para>
    <para>
     Normal dönüş değeri yazılan baytların sayısıdır. <code>-1</code> değeri hata saptandığını belirtir. Olası hatalar <function>write</function> işlevindekilerle aynıdır.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-preadv"><primary>preadv</primary></indexterm>
    <csproto type="işlev">
     <csname><type>ssize_t</type><function>preadv</function></csname>
     <csparam><type>int</type><parameter>fd</parameter></csparam>
     <csparam><ptr>const&#160;struct&#160;iovec</ptr><parameter>iov</parameter></csparam>
     <csparam><type>int</type><parameter>iovcnt</parameter></csparam>
     <csparam><type>off_t</type><parameter>offset</parameter></csparam>
    </csproto>
    <header>&sys-uio.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     Bu işlev <code>readv</code> işlevine benzer, ek olarak, <function>pread</function> işlevindeki gibi <type>off_t</type> türündeki <parameter>offset</parameter> bağımsız değişkenine sahiptir. Verinin dosyadan okunması <parameter>offset</parameter> konumundan başlar. Dosya tanıtıcısının konumu bu işlemden etkilenmez, çağrıdan önceki konumunda kalır.
    </para>
    <para>
     Kaynak dosyası <code>_FILE_OFFSET_BITS == 64</code> ile derlenmişse <code>preadv</code> işlevi aslında 2^63 bayta kadar dosyalarla 64 bitlik <type>off_t</type> türünde konumlarla çalışan <function>preadv64</function> işlevi olur.
    </para>
    <para>
     Dönüş değeri okunan bayt sayısıdır (tampon sayısı değil), <code>0</code> değeri dosya sonunu, <code>-1</code> değeri hata saptandığını belirtir. Olası hatalar <function>readv</function> işlevindekilerle aynıdır.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-preadv64"><primary>preadv64</primary></indexterm>
    <csproto type="işlev">
     <csname><type>ssize_t</type><function>preadv64</function></csname>
     <csparam><type>int</type><parameter>fd</parameter></csparam>
     <csparam><ptr>const&#160;struct&#160;iovec</ptr><parameter>iov</parameter></csparam>
     <csparam><type>int</type><parameter>iovcnt</parameter></csparam>
     <csparam><type>off64_t</type><parameter>offset</parameter></csparam>
    </csproto>
    <header>&sys-uio.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     Bu işlev <function>preadv</function> işlevinin benzeridir.  Farkı <parameter>offset</parameter> bağımsız değişkeninin <type>off_t</type> türünde değil, 32 bit makinelerde 2^31 bayttan büyük ve 2^63 bayta kadar olan dosyaların adreslenmesini mümkün kılan <type>off64_t</type> türünde olmasıdır. Bu işlev için kullanılan <parameter>filedes</parameter> tanıtıcısının <function>open64</function> ile açılması önemlidir. Aksi takdirde, küçük dosya kipinde açılmış dosya tanıtıcılı <type>off64_t</type> türündeki dosya konumları hatalara yol açacaktır.
    </para>
    <para>
     Kaynak dosyası <code>_FILE_OFFSET_BITS == 64</code> ile derlenmişse 32 bitlik sistemlerde bu işleve <function>preadv</function> ismiyle erişilir. Yani 32 ve 64 bitlik arayüzler yer değiştirilir.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-pwritev"><primary>pwritev</primary></indexterm>
   <csproto type="işlev">
    <csname><type>ssize_t</type><function>pwritev</function></csname>
    <csparam><type>int</type><parameter>fd</parameter></csparam>
    <csparam><ptr>const&#160;struct&#160;iovec</ptr><parameter>iov</parameter></csparam>
    <csparam><type>int</type><parameter>iovcnt</parameter></csparam>
    <csparam><type>off_t</type><parameter>offset</parameter></csparam>
   </csproto>
   <header>&sys-uio.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    Bu işlev <code>writev</code> işlevine benzer, ek olarak, <function>pwrite</function> işlevindeki gibi <type>off_t</type> türündeki <parameter>offset</parameter> bağımsız değişkenine sahiptir. Verinin dosyaya yazılması <parameter>offset</parameter> konumundan başlar. Dosya tanıtıcısının konumu bu işlemden etkilenmez, çağrıdan önceki konumunda kalır.
   </para>
   <para>
    Bununla birlikte, Linux'ta, dosya <varname>O_APPEND</varname> ile açılırsa, <code>pwritev</code>, <parameter>offset</parameter> değeri ne olursa olsun veriyi dosyanın sonuna ekler.
   </para>
   <para>
    Kaynak dosyası <code>_FILE_OFFSET_BITS == 64</code> ile derlenmişse <code>pwritev</code> işlevi aslında 2^63 bayta kadar dosyalarla 64 bitlik <type>off_t</type> türünde konumlarla çalışan <function>pwritev64</function> işlevi olur.
   </para>
   <para>
    Dönüş değeri okunan bayt sayısıdır (tampon sayısı değil), <code>0</code> değeri dosya sonunu, <code>-1</code> değeri hata saptandığını belirtir. Olası hatalar <function>writev</function> ve <function>pwritev</function> işlevindekilerle aynıdır.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-pwritev64"><primary>pwritev64</primary></indexterm>
   <csproto type="işlev">
    <csname><type>ssize_t</type><function>pwritev64</function></csname>
    <csparam><type>int</type><parameter>fd</parameter></csparam>
    <csparam><ptr>const&#160;struct&#160;iovec</ptr><parameter>iov</parameter></csparam>
    <csparam><type>int</type><parameter>iovcnt</parameter></csparam>
    <csparam><type>off64_t</type><parameter>offset</parameter></csparam>
   </csproto>
   <header>&sys-uio.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    Bu işlev <function>pwritev</function> işlevinin benzeridir.  Farkı <parameter>offset</parameter> bağımsız değişkeninin <type>off_t</type> türünde değil, 32 bit makinelerde 2^31 bayttan büyük ve 2^63 bayta kadar olan dosyaların adreslenmesini mümkün kılan <type>off64_t</type> türünde olmasıdır. Bu işlev için kullanılan <parameter>filedes</parameter> tanıtıcısının <function>open64</function> ile açılması önemlidir. Aksi takdirde, küçük dosya kipinde açılmış dosya tanıtıcılı <type>off64_t</type> türündeki dosya konumları hatalara yol açacaktır.
   </para>
   <para>
    Kaynak dosyası <code>_FILE_OFFSET_BITS == 64</code> ile derlenmişse 32 bitlik sistemlerde bu işleve <function>pwritev</function> ismiyle erişilir. Yani 32 ve 64 bitlik arayüzler yer değiştirilir.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-preadv2"><primary>preadv2</primary></indexterm>
   <csproto type="işlev">
    <csname><type>ssize_t</type><function>preadv2</function></csname>
    <csparam><type>int</type><parameter>fd</parameter></csparam>
    <csparam><ptr>const&#160;struct&#160;iovec</ptr><parameter>iov</parameter></csparam>
    <csparam><type>int</type><parameter>iovcnt</parameter></csparam>
    <csparam><type>off_t</type><parameter>offset</parameter></csparam>
    <csparam><type>int</type><parameter>flags</parameter></csparam>
   </csproto>
   <header>&sys-uio.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    Bu işlev <function>preadv</function> işlevine benzer, ek olarak <type>int</type> türünde <parameter>flags</parameter> bağımsız değişkenine sahiptir. Bundan başka, <parameter>offset</parameter> için <code>-1</code> değeri belirtilmişse geçerli dosya konumu kullanılır ve güncellenir (<function>readv</function> işlevindeki gibi).
   </para>
   <para>
    <parameter>flags</parameter> bağımsız değişkenininde belirtilebilecek bayraklar sisteme bağlıdır. Linux için desteklenenler:
   </para>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-RWF_HIPRI"><primary>RWF_HIPRI</primary></indexterm>
    <csproto type="sabit">
     <csname><function>RWF_HIPRI</function></csname>
    </csproto>
    <para>
     Yüksek öncelikli istek. Dosya sistemine bunun yüksek öncelikli bir istek olduğunu ve bunun için donanımı yoklamaya değer olduğunu bildiren bir bayrak ekler. Bayrak tamamen öneri niteliğindedir ve desteklenmiyorsa göz ardı edilebilir. <parameter>fd</parameter> dosya tanıtıcısı, <varname>O_DIRECT</varname> kullanılarak açılmalıdır.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-RWF_DSYNC"><primary>RWF_DSYNC</primary></indexterm>
    <csproto type="sabit">
     <csname><function>RWF_DSYNC</function></csname>
    </csproto>
    <para>
     Dosya <varname>O_DSYNC</varname> kullanılarak açılmış gibi her G/Ç  eşzamanlanır.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-RWF_SYNC"><primary>RWF_SYNC</primary></indexterm>
    <csproto type="sabit">
     <csname><function>RWF_SYNC</function></csname>
    </csproto>
    <para>
     Dosya <varname>O_SYNC</varname> kullanılarak açılmış gibi her G/Ç  eşzamanlanır.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-RWF_NOWAIT"><primary>RWF_NOWAIT</primary></indexterm>
    <csproto type="sabit">
     <csname><function>RWF_NOWAIT</function></csname>
    </csproto>
    <para>
     İşlem için engellemesiz kip kullanılır; böylece, <code>preadv2</code> çağrısı başarısız olur ve işlem engellenirse <varname>errno</varname> değişkenine <varname>EAGAIN</varname> atanır.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-RWF_APPEND"><primary>RWF_APPEND</primary></indexterm>
    <csproto type="sabit">
     <csname><function>RWF_APPEND</function></csname>
    </csproto>
    <para>
     Dosya <varname>O_APPEND</varname> kullanılarak açılmış gibi her G/Ç  eşzamanlanır.
    </para>
   </csynopsis>
   <para>
    Kaynak dosyası <code>_FILE_OFFSET_BITS == 64</code> ile derlenmişse <code>preadv2</code> işlevi aslında 2^63 bayta kadar dosyalarla 64 bitlik <type>off_t</type> türünde konumlarla çalışan <function>preadv64v2</function> işlevi olur.
   </para>
   <para>
    Dönüş değeri okunan bayt sayısıdır (tampon sayısı değil), <code>0</code> değeri dosya sonunu, <code>-1</code> değeri hata saptandığını belirtir. Olası hatalar aşağıdaki dışında <function>preadv</function> işlevindekilerle aynıdır.
   </para>
   <variablelist>
    <varlistentry>
     <term><code>EOPNOTSUPP</code></term>
     <listitem>
      <para>
       <parameter>flags</parameter> bağımsız değişkenininde desteklenmeyen bayrak kullanıldı.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-preadv64v2"><primary>preadv64v2</primary></indexterm>
   <csproto type="işlev">
    <csname><type>ssize_t</type><function>preadv64v2</function></csname>
    <csparam><type>int</type><parameter>fd</parameter></csparam>
    <csparam><ptr>const&#160;struct&#160;iovec</ptr><parameter>iov</parameter></csparam>
    <csparam><type>int</type><parameter>iovcnt</parameter></csparam>
    <csparam><type>off64_t</type><parameter>offset</parameter></csparam>
    <csparam><type>int</type><parameter>flags</parameter></csparam>
   </csproto>
   <header>&sys-uio.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    Bu işlev <function>preadv2</function> işlevinin benzeridir.  Farkı <parameter>offset</parameter> bağımsız değişkeninin <type>off_t</type> türünde değil, 32 bit makinelerde 2^31 bayttan büyük ve 2^63 bayta kadar olan dosyaların adreslenmesini mümkün kılan <type>off64_t</type> türünde olmasıdır. Bu işlev için kullanılan <parameter>filedes</parameter> tanıtıcısının <function>open64</function> ile açılması önemlidir. Aksi takdirde, küçük dosya kipinde açılmış dosya tanıtıcılı <type>off64_t</type> türündeki dosya konumları hatalara yol açacaktır.
   </para>
   <para>
    Kaynak dosyası <code>_FILE_OFFSET_BITS == 64</code> ile derlenmişse 32 bitlik sistemlerde bu işleve <function>preadv2</function> ismiyle erişilir. Yani 32 ve 64 bitlik arayüzler yer değiştirilir.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-pwritev2"><primary>pwritev2</primary></indexterm>
   <csproto type="işlev">
    <csname><type>ssize_t</type><function>pwritev2</function></csname>
    <csparam><type>int</type><parameter>fd</parameter></csparam>
    <csparam><ptr>const&#160;struct&#160;iovec</ptr><parameter>iov</parameter></csparam>
    <csparam><type>int</type><parameter>iovcnt</parameter></csparam>
    <csparam><type>off_t</type><parameter>offset</parameter></csparam>
    <csparam><type>int</type><parameter>flags</parameter></csparam>
   </csproto>
   <header>&sys-uio.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    Bu işlev <function>pwritev</function> işlevine benzer, ek olarak <type>int</type> türünde <parameter>flags</parameter> bağımsız değişkenine sahiptir. Bundan başka, <parameter>offset</parameter> için <code>-1</code> değeri belirtilmişse geçerli dosya konumu kullanılır ve güncellenir (<function>writev</function> işlevindeki gibi).
   </para>
   <para>
    <parameter>flags</parameter> bağımsız değişkenininde belirtilebilecek bayraklar sisteme bağlıdır. Linux için desteklenen bayraklar <function>preadv2</function> işlevindekiyle aynıdır.
   </para>
   <para>
    Kaynak dosyası <code>_FILE_OFFSET_BITS == 64</code> ile derlenmişse <code>pwritev2</code> işlevi aslında 2^63 bayta kadar dosyalarla 64 bitlik <type>off_t</type> türünde konumlarla çalışan <function>pwritev64v2</function> işlevi olur.
   </para>
   <para>
    Dönüş değeri okunan bayt sayısıdır (tampon sayısı değil), <code>0</code> değeri dosya sonunu, <code>-1</code> değeri hata saptandığını belirtir. Olası hatalar <function>preadv2</function> işlevindekilerle aynıdır.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-pwritev64v2"><primary>pwritev64v2</primary></indexterm>
   <csproto type="işlev">
    <csname><type>ssize_t</type><function>pwritev64v2</function></csname>
    <csparam><type>int</type><parameter>fd</parameter></csparam>
    <csparam><ptr>const&#160;struct&#160;iovec</ptr><parameter>iov</parameter></csparam>
    <csparam><type>int</type><parameter>iovcnt</parameter></csparam>
    <csparam><type>off64_t</type><parameter>offset</parameter></csparam>
    <csparam><type>int</type><parameter>flags</parameter></csparam>
   </csproto>
   <header>&sys-uio.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    Bu işlev <function>pwritev2</function> işlevinin benzeridir.  Farkı <parameter>offset</parameter> bağımsız değişkeninin <type>off_t</type> türünde değil, 32 bit makinelerde 2^31 bayttan büyük ve 2^63 bayta kadar olan dosyaların adreslenmesini mümkün kılan <type>off64_t</type> türünde olmasıdır. Bu işlev için kullanılan <parameter>filedes</parameter> tanıtıcısının <function>open64</function> ile açılması önemlidir. Aksi takdirde, küçük dosya kipinde açılmış dosya tanıtıcılı <type>off64_t</type> türündeki dosya konumları hatalara yol açacaktır.
   </para>
   <para>
    Kaynak dosyası <code>_FILE_OFFSET_BITS == 64</code> ile derlenmişse 32 bitlik sistemlerde bu işleve <function>pwritev2</function> ismiyle erişilir. Yani 32 ve 64 bitlik arayüzler yer değiştirilir.
   </para>
  </csynopsis>
 </chapter>
 <chapter xml:id="glibc-Copying-File-Data">
  <title>Dosya Verisinin Kopyalanması</title>
  <titleabbrev>Verinin iki dosya arasında kopyalanması.</titleabbrev>
  <para>
   <indexterm linkend="glibc-cp"><primary>dosyalar</primary><secondary>kopyalanması</secondary></indexterm>
   <indexterm linkend="glibc-cp"><primary>dosyadan dosyaya veri kopyalama</primary></indexterm>
   <indexterm linkend="glibc-cp"><primary>veri kopyalama</primary><secondary>dosyadan dosyaya</secondary></indexterm>
   Aynı dosya sistemindeki iki dosya arasında veri kopyalamak için özel bir işlev sağlanmıştır. Sistem, bu tür kopyalama işlemlerini en iyileyebilir. Bu ağ dosya sistemlerinde özellikle önemlidir, aksi takdirde verilerin ağ üzerinden iki kez aktarılması gerekir.
  </para>
  <para>
   Bu işlevin yalnızca dosya verilerini kopyaladığı, dosya izinleri veya genişletilmiş öznitelikler gibi meta verileri kopyalamadığı unutulmamalıdır.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-copy_file_range"><primary>copy_file_range</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-copy_file_range"><primary>dosyadan dosyaya veri kopyalama</primary></indexterm>
   <csproto type="işlev">
    <csname><type>ssize_t</type><function>copy_file_range</function></csname>
    <csparam><type>int</type><parameter>inputfd</parameter></csparam>
    <csparam><ptr>off64_t</ptr><parameter>inputpos</parameter></csparam>
    <csparam><type>int</type><parameter>outputfd</parameter></csparam>
    <csparam><ptr>off64_t</ptr><parameter>outputpos</parameter></csparam>
    <csparam><type>ssize_t</type><parameter>length</parameter></csparam>
    <csparam><type>unsigned&#160;int</type><parameter>flags</parameter></csparam>
   </csproto>
   <header>&unistd.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    Bu işlev <parameter>length</parameter> baytı <parameter>inputfd</parameter> dosya tanıtıcısından <parameter>outputfd</parameter> dosya tanıtıcısına kopyalar.
   </para>
   <para>
    İşlev, hem geçerli dosya konumunda (<code>read</code> ve <code>write</code> gibi) hem de belirtilen dosya konumunda (<code>pread</code> ve <code>pwrite</code> gibi) çalışabilir. <parameter>inputpos</parameter> boş gösterici ise, <parameter>inputfd</parameter> tanıtıcısının dosya konumu kopyalama işleminin başlangıç noktası olarak kullanılır ve bu işlem dosya konumunu ilerletilir. <parameter>inputpos</parameter> boş gösterici değilse, kopyalama işleminin başlangıç noktası olarak *<parameter>inputpos</parameter> kullanılır ve *<parameter>inputpos</parameter> kopyalanan bayt sayısı kadar artırılır, ancak dosya konumu değişmeden kalır. Çıkış dosyası konumu için <parameter>outputfd</parameter> ve <parameter>outputpos</parameter> bağımsız değişkenlerinde benzer kurallar geçerlidir.
   </para>
   <para>
    <parameter>flags</parameter> bağımsız değişkeni şimdilik kullanılmamakta olup değeri daima <code>0</code> olmalıdır.
   </para>
   <para>
    <code>copy_file_range</code> işlevi kopyalanan bayt sayısı ile döner. Girdi dosyasında <parameter>length</parameter> bayttan daha az veri kalması durumunda veya okuma/yazma hatası oluşursa, dönen değer <parameter>length</parameter> bayttan az olabilir. Girdi dosyasının sonuna gelinmişse dönen değer <code>0</code> olur.
   </para>
   <para>
    Hiçbir bayt kopyalanmazsa, <code>copy_file_range</code> hatayı bildirmek için <code>-1</code> döndürür ve hatayı <code>errno</code> değişkenine atar. Bu işleve özgü hata durumları:
   </para>
   <variablelist>
    <varlistentry>
     <term><code>ENOSYS</code></term>
     <listitem>
      <para>
       Çekirdek gereken işlevselliği gerçeklemiyor.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>EISDIR</code></term>
     <listitem>
      <para>
       <parameter>inputfd</parameter> ve <parameter>outputfd</parameter> dosya tanıtıcılarından en az biri bir dizine ait.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>EINVAL</code></term>
     <listitem>
      <para>
       <parameter>inputfd</parameter> ve <parameter>outputfd</parameter> dosya tanıtıcılarından en az biri normal dosya veya dizin olmayan bir oluşuma ait (bir soket veya isimli ardışık süreç).
      </para>
      <para>
       Kopyalama işlemlerinden önceki ve sonraki girdi veya çıktı konumları, gerçeklenimle tanımlanan sınırın dışında.
      </para>
      <para>
       <parameter>flags</parameter> bağımsız değişkeni <code>0</code> değil.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>EFBIG</code></term>
     <listitem>
      <para>
       Yeni dosya boyutu, süreç dosyası boyutu sınırını aşıyor. Bkz. <xref linkend="glibc-Limits-on-Resources"/>.
      </para>
      <para>
       Kopyalama işlemlerinden önceki ve sonraki girdi veya çıktı konumları, gerçeklenimle tanımlanan sınırın dışındadır. Dosya 32 bitlik makinelerde büyük dosya desteği (LFS) ile açılmadıysa ve kopyalama işlemi <type>off_t</type>'nin konumlayabileceğinden daha büyük bir dosya oluşturursa bu hata oluşabilir.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>EBADF</code></term>
     <listitem>
      <para>
       <parameter>inputfd</parameter> bağımsız değişkeni, okumak için açılmış geçerli bir dosya tanıtıcısı değil.
      </para>
      <para>
       <parameter>ouputfd</parameter> bağımsız değişkeni, yazmak için açılmış geçerli bir dosya tanıtıcısı değil ya da <varname>O_APPEND</varname> ile açılmış.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    Ek olarak, <code>copy_file_range</code>, <function>read</function>, <function>pread</function>, <function>write</function> ve <function>pwrite</function> tarafından kullanılan hata kodlarıyla da başarısız olabilir.
   </para>
   <para>
    <code>copy_file_range</code> işlevi iptal noktasıdır. İptal durumunda, girdi konumu (dosya konumu veya *<parameter>inputpos</parameter>'taki değer) belirsizdir.
   </para>
  </csynopsis>
 </chapter>

 <chapter xml:id="glibc-Memory-mapped-I-O">
  <title>Bellek Eşlemli G/Ç</title>
  <titleabbrev>Bellek benzeri dosyaların kullanımı.</titleabbrev>
  <para>
   Günümüz işletim sistemlerinde, bir dosyayı bir bellek bölgesine eşlemek mümkündür. Bu yapıldığında dosyaya yazılım içinden bir dizi gibi erişilebilir.
  </para>
  <para>
   Yazılımın bir dosyanın sadece yüklü bölümlerine erişim anlamında bu işlem <function>read</function> veya <function>write</function> ile yapılan işlemlerden daha verimlidir. Henüz belleğe yüklenmemiş parçalara bellek sayfalarının takaslanmasına benzer bir yolla erişilir.
  </para>
  <para>
   Belleğe eşlenmiş sayfalar, fiziksel bellek azaldığında tekrar dosyasında saklanabilir, belleğe eşlenmiş dosyaların boyutları büyüdükçe hem fiziksel bellekte hem de takas alanında eşlenebilir. Tek sınır adres alanıdır. Teorik sınır 32 bitlik makinelerde 4GB'dır. Başka amaçlarla ayrılan alanlardan dolayı gerçek sınır daha küçük olabilir. LFS arayüzü kullanan 32 bitlik dosya sistemlerinde dosya boyu 64 bitlik olabildiğinden  2GB ile sınırlı değildir (konumların işaretli tamsayılar olması halinde adreslenebilir alan 4GB'ın yarısına düşebilir); 64 bitlik arayüz kullanılabilir.
  </para>
  <para>
   Bellek eşleme, bellekte sadece sayfalarla çalışır. Bu bakımdam, eşleşme adresleri sayfalara hizalanmış ve uzunluk değerleri de buna göre yuvarlanmış olmalıdır. Makinede kullanılan sayfa boyutlarının varsayılanlarını saptamak için
  </para>
  <literallayout class="monospaced"><code>size_t page_size = (size_t) <function>sysconf</function> (<varname>_SC_PAGESIZE</varname>);</code>
</literallayout>
  <para>
   kullanılabilir. Bazı sistemlerde, eşlemler belirli dosyalar için daha büyük sayfa boyutları kullanabilir ve uygulamalar da, isimsiz eşlemler için daha büyük sayfa boyutları talep edebilir (Bkz: <varname>MAP_HUGETLB</varname> bayrağı).
  </para>
  <para>
   Bu bölümdeki işlevler &sys-mman.h; başlık dosyasında bildirilmiştir.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-mmap"><primary>mmap</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-mmap"><primary>bellek eşlemli G/Ç</primary></indexterm>
   <csproto type="işlev">
    <csname><ptr>void</ptr><function>mmap</function></csname>
    <csparam><ptr>void</ptr><parameter>address</parameter></csparam>
    <csparam><type>size_t</type><parameter>length</parameter></csparam>
    <csparam><type>int</type><parameter>protect</parameter></csparam>
    <csparam><type>int</type><parameter>flags</parameter></csparam>
    <csparam><type>int</type><parameter>filedes</parameter></csparam>
    <csparam><type>off_t</type><parameter>offset</parameter></csparam>
   </csproto>
   <header>&sys-mman.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <code>mmap</code> işlevi <parameter>filedes</parameter> ile açılan dosya için yeni bir eşlem oluşturur. Eşlem <parameter>offset</parameter> baytta başlar, (<parameter>offset</parameter> + <parameter>length</parameter> - 1) baytta biter. <parameter>filedes</parameter> ile belirtilen dosya için dosya kapatıldığında bile kaldırılmayan yeni bir başvuru oluşturur.
   </para>
   <para>
    <parameter>address</parameter> ile eşlem için tercih edilen adres belirtilir. <varname>NULL</varname> tercih belirtilmediğini gösterir. Adreste evvelce bir eşlem varsa özdevinimli olarak kaldırılır. <varname>MAP_FIXED</varname> seçeneği kullanılmadıkça belirtilen adres değiştirilemeyebilir.
   </para>
   <para>
    <indexterm linkend="glibc-vr"><primary>PROT_READ</primary></indexterm>
    <indexterm linkend="glibc-vr"><primary>PROT_WRITE</primary></indexterm>
    <indexterm linkend="glibc-vr"><primary>PROT_EXEC</primary></indexterm>
    <parameter>protect</parameter> ne çeşit erişime izin verildiğini belirten seçenekleri içerir. Bunlar sırayla okuma, yazma ve çalıştırma izinlerini belirten <varname>PROT_READ</varname>, <varname>PROT_WRITE</varname> ve <varname>PROT_EXEC</varname> seçenekleri olabilir. Özel <varname>PROT_NONE</varname> seçeneği, adres bölgesini ileride kullanmak üzere ayırır. Koruma seçeneklerini değiştirmek için <function>mprotect</function> işlevi kullanılabilir (bkz. <xref linkend="glibc-Memory-Protection"/>).
   </para>
   <para>
    <parameter>flags</parameter> bağımsız değişkeni eşlemin doğasını denetleyen seçenekleri içerir. Burada <varname>MAP_SHARED</varname> veya <varname>MAP_PRIVATE</varname> seçeneklerinden biri belirtilmelidir.
   </para>
   <para>
    Bellek eşleminin doğasını denetleyen seçenekler:
   </para>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-MAP_PRIVATE"><primary>MAP_PRIVATE</primary></indexterm>
    <csproto type="sabit">
     <csname><function>MAP_PRIVATE</function></csname>
    </csproto>
    <para>
     Eşlemle ilgili dosyaya yazılamasa da bellek bölgesine yazılabileceğini belirtir. Bunun yerine, süreç için bir kopya yapılır ve normal olarak bellek azsa bölge takaslanır. Başka hiçbir süreç değişiklikleri görmez.
    </para>
    <para>
     Özel eşlemler üzerlerine yazıldıklarında fiilen sıradan belleğe konulduğundan eğer bu kip <varname>PROT_WRITE</varname> ile kullanılıyorsa eşlemlenmiş bölgenin tamamının kopyası için yeterli sanal bellek olmalıdır.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-MAP_SHARED"><primary>MAP_SHARED</primary></indexterm>
    <csproto type="sabit">
     <csname><function>MAP_SHARED</function></csname>
    </csproto>
    <para>
     Bölgeye yapılan yazmaların dosyaya da yazılacağını belirtir. Değişiklikler aynı dosyayı eşlemlemiş olan diğer süreçlerle anında paylaşılır.
    </para>
    <para>
     Asıl yazma işlemlerinin herhangi bir anda olabileceği unutulmamalıdır. Diğer süreçlerin geleneksel G/Ç işlemlerini kullanarak dosyanın tutarlı bir görünümünü almaları önemliyse, aşağıda açıklanan <function>msync</function> işlevinin kullanılması gerekir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-MAP_FIXED"><primary>MAP_FIXED</primary></indexterm>
    <csproto type="sabit">
     <csname><function>MAP_FIXED</function></csname>
    </csproto>
    <para>
     Sistemi, eşlem adresi olarak <parameter>address</parameter> ile belirtilen adresi kullanması için zorlar. Bu olmazsa işlev başarısız olur.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-MAP_ANONYMOUS"><primary>MAP_ANONYMOUS</primary></indexterm>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-MAP_ANON"><primary>MAP_ANON</primary></indexterm>
    <csproto type="sabit">
     <csname><function>MAP_ANONYMOUS</function></csname>
    </csproto>
    <csproto type="sabit">
     <csname><function>MAP_ANON</function></csname>
    </csproto>
    <para>
     Sisteme, bir dosyaya bağlı olmayan isimsiz bir eşlem oluşturmasını söyler. <parameter>filedes</parameter> ve <parameter>offset</parameter> yok sayılır ve bölge sıfırlarla ilklendirilir.
    </para>
    <para>
     İsimsiz eşlemler bazı sistemlerde özdevimli tahsis yapılabilen bellek bölgesinin genişletilmesinde temel ilkel olarak kullanılır. Ayrıca bir dosya oluşturmadan çok sayıda görev arasında veri paylaşmak için de kullanışlıdır.
    </para>
    <para>
     Bazı sistemlerde büyük bellek blokları ile çalışırken özel isimsiz eşlemleri kullanmak <function>malloc</function> kullanmaktan daha verimlidir. &glibc; <function>malloc</function> gerektiği takdirde özdevinimli olarak <code>mmap</code> işlevini kullanır.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-MAP_HUGETLB"><primary>MAP_HUGETLB</primary></indexterm>
    <csproto type="sabit">
     <csname><function>MAP_HUGETLB</function></csname>
    </csproto>
    <para>
     Sistemin eşlem için varsayılan sayfa boyutundan daha büyük başka bir sayfa boyutu kullanmasını ister. Bazı iş yüklerinde, büyük eşlemler için sayfa boyutunu artırmak, sistemin çok daha az sayfayı işlemesini gerektiğinden başarımı artırır. Azaltılmış sayfa ayrıntı düzeyi, depolama veya farklı düğümler arasında sık sık sayfa aktarımı gerektiren diğer iş yükleri için  artırılmış sayfa boyutu ve daha büyük aktarımlar nedeniyle başarım sorunlarına neden olabilir.
    </para>
    <para>
     Eşlemin oluşturması sırasında, sistemin artırılmış sayfa boyutunda fiziksel olarak bitişik belleğe ihtiyacı vardır. Sonuç olarak, <code>MAP_HUGETLB</code> eşlemleri belleğin saçılmasından etkilenir ve sistemde bol miktarda bellek bulunsa bile bunların oluşturulması başarısız olabilir.
    </para>
    <para>
     Tüm dosya sistemleri, artırılmış sayfa boyutuna sahip eşlemleri desteklemez.
    </para>
    <para>
     <code>MAP_HUGETLB</code> seçeneği Linux'a özgüdür.
    </para>
   </csynopsis>
   <para>
    <code>mmap</code> normalde yeni eşlemin adresi ile döner. <code>-1</code> dönüş değeri bir hata oluştuğunu belirtir.
   </para>
   <para>Olası hatalar:</para>
   <variablelist>
    <varlistentry>
     <term><code>EINVAL</code></term>
     <listitem>
      <para>
       Ya <parameter>address</parameter> işe yaramaz (geçerli sayfa boyutunun katı olmadığı için) ya da belirtilen <parameter>flags</parameter> tutarsız.
      </para>
      <para>
       <varname>MAP_HUGETLB</varname> belirtilmişse, dosya veya sistem büyük sayfa boyutlarını desteklemiyordur.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>EACCES</code></term>
     <listitem>
      <para>
       <parameter>filedes</parameter> tanıtıcısı <parameter>protect</parameter> ile belirtilen adres türü için açılmamış.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>ENOMEM</code></term>
     <listitem>
      <para>
       Ya işlem için bellek yetersiz ya da süreç adres uzayının dışında.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>ENODEV</code></term>
     <listitem>
      <para>
       Dosya bellek eşlemini desteklemeyen türde.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>ENOEXEC</code></term>
     <listitem>
      <para>
       Dosya bellek eşlemini desteklemeyen dosya sistemi üzerinde.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-mmap64"><primary>mmap64</primary></indexterm>
   <csproto type="işlev">
    <csname><ptr>void</ptr><function>mmap64</function></csname>
    <csparam><ptr>void</ptr><parameter>address</parameter></csparam>
    <csparam><type>size_t</type><parameter>length</parameter></csparam>
    <csparam><type>int</type><parameter>protect</parameter></csparam>
    <csparam><type>int</type><parameter>flags</parameter></csparam>
    <csparam><type>int</type><parameter>filedes</parameter></csparam>
    <csparam><type>off64_t</type><parameter>offset</parameter></csparam>
   </csproto>
   <header>&sys-mman.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <code>mmap64</code> işlevi <parameter>offset</parameter> bağımsız değişkeninin <type>off64_t</type> türünde olması dışında <function>mmap</function> işlevine eşdeğerdir. 32 bitlik sistemlerde bu, tanıtıcısı <parameter>filedes</parameter> olan dosyanın 2GB'dan büyük olabilmesini mümkün kılar. <parameter>filedes</parameter>, <function>open64</function> veya <function>fopen64</function> ve <function>freopen64</function> çağrılarından dönen bir tanıtıcı olmalıdır.
   </para>
   <para>
    Kaynak dosyaları <code>_FILE_OFFSET_BITS == 64</code> ile derlenmişse bu işleve <function>mmap</function> ismiyle erişilir. Yani, derleme sırasında 64 bitlik yeni arayüz eski arayüzün yerine geçer.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-munmap"><primary>munmap</primary></indexterm>
   <csproto type="işlev">
    <csname><ptr>int</ptr><function>munmap</function></csname>
    <csparam><ptr>void</ptr><parameter>address</parameter></csparam>
    <csparam><type>size_t</type><parameter>length</parameter></csparam>
   </csproto>
   <header>&sys-mman.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <code>munmap</code> işlevi <parameter>address</parameter> adresinden (<parameter>address</parameter> + <parameter>length</parameter>) adresine kadar olan eşlemi siler. <parameter>length</parameter> eşlemin uzunluğu olmalıdır.
   </para>
   <para>
    Aralık içinde eşlenmemiş alanlar olabilir, bu şekilde çok sayıda eşlem tek bir komutla silinebilir. Ayrıca mevcut eşlemin sadece bir bölümünü silmek de mümkündür. Ancak sadece tam sayfalar silinebilir. <parameter>length</parameter> sayfa sayısına denk değilse bile üste yuvarlanır.
   </para>
   <para>
    Normal dönüş değeri sıfırdır, <code>-1</code> ise hata oluşmuştur.
   </para>
   <para>
    Olası hata:
   </para>
   <variablelist>
    <varlistentry>
     <term><code>EINVAL</code></term>
     <listitem>
      <para>
       Belirtilen bellek adresi aralığı kullanıcının bellek eşlem aralığının dışında ya da sayfa hizalı değil
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-msync"><primary>msync</primary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>msync</function></csname>
    <csparam><ptr>void</ptr><parameter>address</parameter></csparam>
    <csparam><type>size_t</type><parameter>length</parameter></csparam>
    <csparam><type>int</type><parameter>flags</parameter></csparam>
   </csproto>
   <header>&sys-mman.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    Paylaşımlı eşlemler kullanılırken, eşlem silinmeden önce çekirdek herhangi bir zamanda eşlemi dosyaya yazabilir. Değişmiş bir veri varsa, dosyaya bellek eşlemli olmayan G/Ç ile erişen süreçler veri dosyaya fiilen yazılana kadar bunları göremez. Bunun olmaması için bu işlevin kullanılması gerekir.
   </para>
   <para>
    İşlev <parameter>address</parameter> adresinden (<parameter>address</parameter> + <parameter>length</parameter>) adresinde kadar olan bölgede çalışır. Bu bölge çok sayıda dosyanın eşlemlerini içerebileceği gibi bir dosyanın bir bölümünü içeren bir eşlem bölgesi de olabilir, ancak eşlemsiz alan içermemelidir.
   </para>
   <para>
    <parameter>flags</parameter> şunları içerebilir:
   </para>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-MS_SYNC"><primary>MS_SYNC</primary></indexterm>
    <csproto type="sabit">
     <csname><function>MS_SYNC</function></csname>
    </csproto>
    <para>
     Bu seçenek verinin "disk"e yazılmasını sağlar. Normalde <code>msync</code> işlevi geleneksel G/Ç işlemleri ile bir dosyaya erişimde son yapılan değişikliklere dosyada mevcutmuş gibi erişilmesini sağlar.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-MS_ASYNC"><primary>MS_ASYNC</primary></indexterm>
    <csproto type="sabit">
     <csname><function>MS_ASYNC</function></csname>
    </csproto>
    <para>
     <code>msync</code> işlevine eşzamanlamaya başlamasını söyler ama başlaması için beklemez.
    </para>
   </csynopsis>
   <para>
    <code>msync</code> normalde sıfır ile hata oluştuğunda <code>-1</code> ile döner. Olası hatalar:
   </para>
   <variablelist>
    <varlistentry>
     <term><code>EINVAL</code></term>
     <listitem>
      <para>
       Ya geçersiz bölge belirtilmiş ya da <parameter>flags</parameter> geçersiz.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>EFAULT</code></term>
     <listitem>
      <para>
       Belirtilen bölgenin en azından bir kısmında bile herhangi bir eşlem yok.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-mremap"><primary>mremap</primary></indexterm>
   <csproto type="işlev">
    <csname><ptr>void</ptr><function>mremap</function></csname>
    <csparam><ptr>void</ptr><parameter>address</parameter></csparam>
    <csparam><type>size_t</type><parameter>length</parameter></csparam>
    <csparam><type>size_t</type><parameter>new_length</parameter></csparam>
    <csparam><type>int</type><parameter>flag</parameter></csparam>
   </csproto>
   <header>&sys-mman.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    Bu işlev mevcut bir bellek alanının boyunu değiştirmekte kullanılabilir. <parameter>address</parameter> ve <parameter>length</parameter> tamamen aynı <function>mmap</function> işleviyle eşlemlenmiş bölgeyi belirtmelidir. <parameter>new_length</parameter> ile belirtilen yeni eşlem aynı karakteristik özelliklerle dönecektir.
   </para>
   <para>
    Tek bir seçenek, <varname>MREMAP_MAYMOVE</varname> belirtilebilir. Bu, <parameter>flag</parameter> içinde belirtilmişse, sistem mevcut eşlemi silip başka bir yerde belirtilen uzunlukta yeni bir eşlem oluşturur.
   </para>
   <para>
    Normalde yeni eşlemin adresi ile bir hata oluştuğunda ise <code>-1</code> ile döner. Olası hatalar:
   </para>
   <variablelist>
    <varlistentry>
     <term><code>EFAULT</code></term>
     <listitem>
      <para>
       Özgün eşlemin parçası olarak bile bir eşlem yok veya bölge bir veya daha fazla farklı eşlem içeriyor.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>EINVAL</code></term>
     <listitem>
      <para>
       Belirtilen adres hizalı ya da uygun değil.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>EAGAIN</code></term>
     <listitem>
      <para>
       Bölge kilitli sayfalar içeriyor, eğer genişletmek gerekirse kilitli sayfalar için <link linkend="glibc-Limits-on-Resources">sürecin öz kaynak sınırı</link> aşılabilir.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>ENOMEM</code></term>
     <listitem>
      <para>
       Bölge yazılabilir ama özel, ayrıca genişletmek için sanal bellek yetersiz. Bundan başka, <varname>MREMAP_MAYMOVE</varname> belirtilmemişse ve genişletme başka bir eşlemli bölge ile çatışacaksa bu hata oluşacaktır.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </csynopsis>
  <para>
   Bu işlev sadece birkaç sistemde kullanılabilir. İsteğe bağlı en iyilemeler gerçekleştirmek dışında bu işlev kullanılmamalıdır.
  </para>
  <para>
   Tüm dosya tanıtıcılar bellek eşlemli olamaz. Soketler, ardışık süreçler ve çoğu aygıt için sadece sıralı erişim mümkündür ve eşlem soyutlaması uygun değildir. Ek olarak, bazı normal dosyalar da eşlemlenemez ve eski çekirdekler eşlemlemeyi hiç desteklemeyebilir. Bu bakımdan bu işlevi kullanacak yazılımların işlev başarısız olduğunda kullanılacak bir son çare yöntemi olmalıdır. Bkz. GNU Kodlama Standartlarında <link xl:href="https://www.gnu.org/prep/standards/standards.html#Mmap">Mmap</link>.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-madvise"><primary>madvise</primary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>madvise</function></csname>
    <csparam><ptr>void</ptr><parameter>addr</parameter></csparam>
    <csparam><type>size_t</type><parameter>length</parameter></csparam>
    <csparam><type>int</type><parameter>advice</parameter></csparam>
   </csproto>
   <header>&sys-mman.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    Bu işlev, sisteme <parameter>addr</parameter> adresinde başlayan <parameter>length</parameter> baytlık bellek bölgesinin düşünülen kullanım şekliyle ilgili bir öneri yapmak için kullanılabilir.
   </para>
   <para>
    <parameter>advice</parameter> (öneri) için geçerli BSD değerleri şunlardır:
   </para>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-MADV_NORMAL"><primary>MADV_NORMAL</primary></indexterm>
    <csproto type="sabit">
     <csname><function>MADV_NORMAL</function></csname>
    </csproto>
    <para>
     Bölge özel bir şey yapmadan alınmalı.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-MADV_RANDOM"><primary>MADV_RANDOM</primary></indexterm>
    <csproto type="sabit">
     <csname><function>MADV_RANDOM</function></csname>
    </csproto>
    <para>
     Bölge rastgele sayfa başvuruları üzerinden erişilebilir olacak. Çekirdek her sayfalama hatası için en az sayıda sayfayı gerçek belleğe sayfalamalıdır.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-MADV_SEQUENTIAL"><primary>MADV_SEQUENTIAL</primary></indexterm>
    <csproto type="sabit">
     <csname><function>MADV_SEQUENTIAL</function></csname>
    </csproto>
    <para>
     Bölge ardışık sayfa başvuruları üzerinden erişilebilir olacak. Bu çekirdeğin bölge içindeki her sayfalama hatasından sonra bir ardışık başvuru umarak sürekli ileri doğru okumaya zorlanmasına sebep olur.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-MADV_WILLNEED"><primary>MADV_WILLNEED</primary></indexterm>
    <csproto type="sabit">
     <csname><function>MADV_WILLNEED</function></csname>
    </csproto>
    <para>
     Bölge gerekli olacaktır. Bu bölge içindeki sayfalar çekirdek tarafından önceden gerçek belleğe sayfalanmış olmalıdır.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-MADV_DONTNEED"><primary>MADV_DONTNEED</primary></indexterm>
    <csproto type="sabit">
     <csname><function>MADV_DONTNEED</function></csname>
    </csproto>
    <para>
     Bölge artık gerekmeyecektir. Sayfa kaybına sebep olabilecek bir değişiklikte ya da sanal belleğe kopyalanması gerektiğinde bunun yapılmaması suretiyle çekirdek bu sayfaları serbest bırakabilir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-MADV_HUGEPAGE"><primary>MADV_HUGEPAGE</primary></indexterm>
    <csproto type="sabit">
     <csname><function>MADV_HUGEPAGE</function></csname>
    </csproto>
    <para>
     Eşlem için sayfa boyutunu artırmanın yararlı olduğunu belirtir. Sistemin çok daha az sayfayı işlemesi gerektiğinden, daha büyük eşlemler için başarımı artırabilir. Bununla birlikte, eşlemnin bölümleri sık sık depolama veya farklı düğümler arasında aktarılırsa, artan sayfa boyutu nedeniyle bireysel aktarımlar önemli ölçüde büyüyebileceğinden başarım düşebilir.
    </para>
    <para>
     Seçenek Linux'a özgüdür.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-MADV_NOHUGEPAGE"><primary>MADV_NOHUGEPAGE</primary></indexterm>
    <csproto type="sabit">
     <csname><function>MADV_NOHUGEPAGE</function></csname>
    </csproto>
    <para>
     Önceki <varname>MADV_HUGEPAGE</varname> önerisinin etkisini geri alır.
    </para>
    <para>
     Seçenek Linux'a özgüdür.
    </para>
   </csynopsis>
   <para>
    POSIX isimleri biraz farklıdır ama isimler aynı anlama gelir:
   </para>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-POSIX_MADV_NORMAL"><primary>POSIX_MADV_NORMAL</primary></indexterm>
    <csproto type="sabit">
     <csname><function>POSIX_MADV_NORMAL</function></csname>
    </csproto>
    <para>
     BSD'nin <varname>MADV_NORMAL</varname> seçeneğine karşılıktır.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-POSIX_MADV_RANDOM"><primary>POSIX_MADV_RANDOM</primary></indexterm>
    <csproto type="sabit">
     <csname><function>POSIX_MADV_RANDOM</function></csname>
    </csproto>
    <para>
     BSD'nin <varname>MADV_RANDOM</varname> seçeneğine karşılıktır.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-POSIX_MADV_SEQUENTIAL"><primary>POSIX_MADV_SEQUENTIAL</primary></indexterm>
    <csproto type="sabit">
     <csname><function>POSIX_MADV_SEQUENTIAL</function></csname>
    </csproto>
    <para>
     BSD'nin <varname>MADV_SEQUENTIAL</varname> seçeneğine karşılıktır.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-POSIX_MADV_WILLNEED"><primary>POSIX_MADV_WILLNEED</primary></indexterm>
    <csproto type="sabit">
     <csname><function>POSIX_MADV_WILLNEED</function></csname>
    </csproto>
    <para>
     BSD'nin <varname>MADV_WILLNEED</varname> seçeneğine karşılıktır.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-POSIX_MADV_DONTNEED"><primary>POSIX_MADV_DONTNEED</primary></indexterm>
    <csproto type="sabit">
     <csname><function>POSIX_MADV_DONTNEED</function></csname>
    </csproto>
    <para>
     BSD'nin <varname>MADV_DONTNEED</varname> seçeneğine karşılıktır.
    </para>
   </csynopsis>
   <para>
    <code>madvise</code> başarı durumunda <code>0</code>, hata durumunda <code>-1</code> ile döner. Olası hatalar:
   </para>
   <variablelist>
    <varlistentry>
     <term><code>EFAULT</code></term>
     <listitem>
      <para>
       Özgün eşlemin parçası olarak bile bir eşlem yok veya bölge bir veya daha fazla farklı eşlem içeriyor.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>EINVAL</code></term>
     <listitem>
      <para>
       Belirtilen bölge geçersiz ya da <parameter>advice</parameter> (öneri) geçersiz.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>EFAULT</code></term>
     <listitem>
      <para>
       Belirtilen bölgenin en azından bir kısmında bile herhangi bir eşlem yok.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-shm_open"><primary>shm_open</primary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>shm_open</function></csname>
    <csparam><ptr>const&nbsp;char</ptr><parameter>name</parameter></csparam>
    <csparam><type>int</type><parameter>oflag</parameter></csparam>
    <csparam><type>mode_t</type><parameter>mode</parameter></csparam>
   </csproto>
   <header>&sys-mman.h;</header>
   <conceptlist>
    <concept>&mtsafe; &locale;</concept>
    <concept>&asunsafe; &init; &heap; &lock;</concept>
    <concept>&acunsafe; &lock; &mem; &fd;</concept>
   </conceptlist>
   <para>
    Bu işlev, <function>mmap</function> aracılığıyla paylaşımlı belleği tahsis etmek için kullanılabilecek bir dosya tanıtıcı döndürür. İlişkisiz süreçler, mevcut paylaşılan bellek nesnelerini oluşturmak veya açmak için aynı adı (<parameter>name</parameter>) kullanabilir.
   </para>
   <para>
    <parameter>name</parameter> bağımsız değişkeni, açılacak paylaşılan bellek nesnesini belirtir. &glibc;nde, isteğe bağlı bir eğik çizgi ile başlayan ancak başka eğik çizgi içermeyen <varname>NAME_MAX</varname> bayttan daha küçük bir dizge olmalıdır.
   </para>
   <para>
    <parameter>oflag</parameter> ve <parameter>mode</parameter> bağımsız değişkenleri <function>open</function> işlevindeki gibi değerlendirilir.
   </para>
   <para>
    <code>shm_open</code> başarı durumunda dosya tanıtıcısını, hata durumunda <code>-1</code> döndürür ve hatayı <varname>errno</varname> değişkenine atar.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-shm_unlink"><primary>shm_unlink</primary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>shm_unlink</function></csname>
    <csparam><ptr>const&nbsp;char</ptr><parameter>name</parameter></csparam>
   </csproto>
   <header>&sys-mman.h;</header>
   <conceptlist>
    <concept>&mtsafe; &locale;</concept>
    <concept>&asunsafe; &init; &heap; &lock;</concept>
    <concept>&acunsafe; &lock; &mem; &fd;</concept>
   </conceptlist>
   <para>
    Bu işlev, <function>shm_open</function> işlevinin tersidir ve daha önce <function>shm_open</function> tarafından oluşturulan, adı <parameter>name</parameter> olan nesneyi kaldırır.
   </para>
   <para>
    <code>shm_unlink</code> başarı durumunda <code>0</code>, hata durumunda <code>-1</code> döndürür ve hatayı <varname>errno</varname> değişkenine atar.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-memfd_create"><primary>memfd_create</primary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>memfd_create</function></csname>
    <csparam><ptr>const&nbsp;char</ptr><parameter>name</parameter></csparam>
    <csparam><type>unsigned&nbsp;int</type><parameter>flags</parameter></csparam>
   </csproto>
   <header>&sys-mman.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe; &fd;</concept>
   </conceptlist>
   <para>
    <code>memfd_create</code> işlevi, <function>mmap</function> işlevini kullanarak bellek eşlemleri oluşturmakta kullanılabilecek bir dosya tanıtıcı döndürür. Bu eşlemlerin gerçek dosyalar tarafından desteklenmemesi anlamında <function>shm_open</function> işlevine benzer. Ancak <code>memfd_create</code> tarafından döndürülen tanıtıcı, isimli bir nesneye karşılık gelmez; <parameter>name</parameter> bağımsız değişkeni yalnızca hata ayıklama amacıyla kullanılır (örneğin, <filename>/proc</filename>'ta görünür) ve <code>memfd_create</code> işlevinin aynı <parameter>name</parameter> kullanarak yapılan farklı çağrıları, aynı bellek bölgesi için tanıtıcılar döndürmez. Tanıtıcı, aynı süreç içinde takma adlı eşlemler oluşturmak için de kullanılabilir.
   </para>
   <para>
    Tanıtıcı başlangıçta sıfır uzunluklu bir dosyaya atıfta bulunur. Bellek tarafından desteklenen eşlemler oluşturulmadan önce, dosya boyutunun <function>ftruncate</function> işleviyle artırılması gerekir. Bkz. <xref linkend="glibc-File-Size"/>.
   </para>
   <para>
    <parameter>flags</parameter> bağımsız değişken aşağıdaki bayrakların birleşimi olabilir:
   </para>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-MFD_CLOEXEC"><primary>MFD_CLOEXEC</primary></indexterm>
    <csproto type="sabit">
     <csname><function>MFD_CLOEXEC</function></csname>
    </csproto>
    <para>
     Tanıtıcı <varname>O_CLOEXEC</varname> bayrağı ile oluşturulur.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-MFD_ALLOW_SEALING"><primary>MFD_ALLOW_SEALING</primary></indexterm>
    <csproto type="sabit">
     <csname><function>MFD_ALLOW_SEALING</function></csname>
    </csproto>
    <para>
     Tanıtıcı, <function>fcntl</function> işlevi kullanılarak mühür eklenmesini destekler.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-MFD_HUGETLB"><primary>MFD_HUGETLB</primary></indexterm>
    <csproto type="sabit">
     <csname><function>MFD_HUGETLB</function></csname>
    </csproto>
    <para>
     Döndürülen dosya tanıtıcı kullanılarak oluşturulan eşlemlerin daha büyük sayfa boyutu kullanmasını ister. Ayrıntılar için bkz: <varname>MAP_HUGETLB</varname>.
    </para>
    <para>
     <varname>MFD_ALLOW_SEALING</varname> ile uyumsuzdur.
    </para>
   </csynopsis>
   <para>
    <code>memfd_create</code> işlevi, başarı durumunda dosya tanıtıcısını, hata durumunda <code>-1</code> döndürür ve hatayı <varname>errno</varname> değişkenine atar. Bu işlev için tanımlanmış hata durumları:
   </para>
   <variablelist>
    <varlistentry>
     <term><code>EINVAL</code></term>
     <listitem>
      <para>
       <parameter>flags</parameter> ile geçersiz bir birleşim belirtilmiş veya <parameter>name</parameter> çok uzun.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>EFAULT</code></term>
     <listitem>
      <para>
       <parameter>name</parameter> bir dizge göstermiyor.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>EMFILE</code></term>
     <listitem>
      <para>
       İşlem, bu sürecin dosya tanıtıcı sınırını aşıyor.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>ENFILE</code></term>
     <listitem>
      <para>
       İşlem, sistem çapında dosya tanıtıcı sınırını aşıyor.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>ENOMEM</code></term>
     <listitem>
      <para>
       İşlem için bellek yetersiz.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </csynopsis>
 </chapter>

 <chapter xml:id="glibc-Waiting-for-I-O">
  <title>Girdi ve Çıktının Beklenmesi</title>
  <titleabbrev>Çok sayıda dosya tanıtıcısı üzerinde girdi ve çıktı nasıl denetlenir.</titleabbrev>
  <para>
   <indexterm linkend="glibc-cp"><primary>dosya tanıtıcılar</primary><secondary>girdi ve çıktının beklenmesi</secondary></indexterm>
   <indexterm linkend="glibc-cp"><primary>girdi</primary><secondary>bekleme</secondary></indexterm>
   <indexterm linkend="glibc-cp"><primary>girdi</primary><secondary>çoğullama</secondary></indexterm>
   <indexterm linkend="glibc-cp"><primary>girdi</primary><secondary>çok sayıda dosyadan</secondary></indexterm>
   Kimi zaman bir yazılımın girdiyi gelişine bağlı olarak çok sayıda girdi kanalından kabul etmesi gerekir. Örneğin bazı iş istasyonları tablet, işlev düğmeleri kutusu, normal eşzamansız seri arayüz üzerinden bağlanılan çevirmeli ağ gibi çok sayıda aygıttan aynı anda ve anında yanıt verecek iyi bir kullanıcı arayüzü gerektirmektedir. Başka bir örnek de bir yazılımın başka süreçlere adlı ya da adsız ardışık süreçler üzerinden bir sunucu olarak hizmet vermesidir.
  </para>
  <para>
   Normalde bu amaçla <function>read</function> kullanılamaz, çünkü işlev dosya tanıtıcıdan bir girdi gelene kadar beklerken diğer kanallardaki girdi fazladan bekletilir. Engellenmeyen kipe geçilmesi ve dosya tanıtıcılarının sürekli taranması gerekir ki bu da pek verimli değildir.
  </para>
  <para>
   Daha iyi bir çözüm <function>select</function> işlevini kullanmaktır.  Bu, belirtilen dosya tanıtıcı kümesinde bir girdi ya da çıktı hazır olana kadar ya da bir zamanlayıcı zaman aşımına uğrayıncaya kadar (hangisi önce gerçekleşirse), bekler. Bu oluşum &sys-types.h; başlık dosyasında bildirilmiştir.
   <indexterm linkend="glibc-pg"><primary>sys/types.h</primary></indexterm>
  </para>
  <para>
   Bir <link linkend="glibc-Listening">sunucu soketi</link> durumunda, askıda olduğu <link linkend="glibc-Accepting-Connections">varsayılan bağlantılar</link> olduğunda girdinin de var olabileceğinden söz edilebilir. <function>accept</function> işlevi sunucu soketini beklemeye alır ve <function>read</function> işlevinin normal girdi için yaptığı gibi  <function>select</function> ile etkileşir.
  </para>
  <para>
   <indexterm linkend="glibc-cp"><primary>dosya tanıtıcılar</primary><secondary>tanıtıcı kümeleri</secondary></indexterm>
   <indexterm linkend="glibc-cp"><primary>dosya tanıtıcılar</primary><secondary><function>select</function> işlevi</secondary></indexterm>
   <function>select</function> işlevi için dosya tanıtıcı kümeleri <type>fd_set</type> türünde nesneler olarak belirtilir. Burada bu nesnelerin veri türü ve bunlarla ilgili makrolara değinilecektir.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-tp" xml:id="glibc-tp-fd_set"><primary>fd_set</primary></indexterm>
   <indexterm xml:id="glibc-cp-fd_set" linkend="glibc-cp"><primary>dosya tanıtıcılar</primary><secondary>tanıtıcı kümeleri</secondary></indexterm>
   <csproto type="veri türü">
    <csname><function>fd_set</function></csname>
   </csproto>
   <header>&sys-types.h;</header>
   <para>
    <code>fd_set</code> veri türü <function>select</function> işlevi için tanımlanan dosya tanıtıcı kümelerinin veri türü olup aslında bit dizisidir.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-vr" xml:id="glibc-vr-FD_SETSIZE"><primary>FD_SETSIZE</primary></indexterm>
   <csproto type="makro">
    <csname><type>int</type><function>FD_SETSIZE</function></csname>
   </csproto>
   <header>&sys-types.h;</header>
   <para>
    <type>fd_set</type> nesnesinde saklanabilen dosya tanıtıcılarının azami sayısıdır. Azami sayının sabit olduğu sistemlerde <code>FD_SETSIZE</code> bu sayıya eşittir. GNU sistemininde dahil olduğu bazı sistemlerde açık tanıtıcıların azami sayısı için mutlak bir üst sınır olmamasına rağmen bu sabit <type>fd_set</type> içindeki bitlerin sayısını belirten bir değerdir; <code>FD_SETSIZE</code>'ıncıdan sonraki bir dosya tanıtıcısı <type>fd_set</type> içine konamaz.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-FD_ZERO"><primary>FD_ZERO</primary></indexterm>
   <csproto type="makro">
    <csname><type>void</type><function>FD_ZERO</function></csname>
    <csparam><ptr>fd_set</ptr><parameter>set</parameter></csparam>
   </csproto>
   <header>&sys-types.h;</header>
   <conceptlist>
    <concept>&mtsafe; &race;<code linkend="glibc-safety-identifier">:set</code></concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    Bu makro <parameter>set</parameter> dosya tanıtıcı kümesini boş bir küme olarak ilklendirir.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-FD_SET"><primary>FD_SET</primary></indexterm>
   <csproto type="makro">
    <csname><type>void</type><function>FD_SET</function></csname>
    <csparam><type>int</type><parameter>filedes</parameter></csparam>
    <csparam><ptr>fd_set</ptr><parameter>set</parameter></csparam>
   </csproto>
   <header>&sys-types.h;</header>
   <conceptlist>
    <concept>&mtsafe; &race;<code linkend="glibc-safety-identifier">:set</code></concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    Bu makro <parameter>filedes</parameter> dosya tanıtıcısını <parameter>set</parameter> dosya tanıtıcı kümesine dahil eder.
   </para>
   <para>
    <parameter>filedes</parameter> bağımsız değişkeni bir kereden fazla değerlendirildiğinden yan etkilere sahip olmamalıdır.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-FD_CLR"><primary>FD_CLR</primary></indexterm>
   <csproto type="makro">
    <csname><type>void</type><function>FD_CLR</function></csname>
    <csparam><type>int</type><parameter>filedes</parameter></csparam>
    <csparam><ptr>fd_set</ptr><parameter>set</parameter></csparam>
   </csproto>
   <header>&sys-types.h;</header>
   <conceptlist>
    <concept>&mtsafe; &race;<code linkend="glibc-safety-identifier">:set</code></concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    Bu makro <parameter>filedes</parameter> dosya tanıtıcısını <parameter>set</parameter> dosya tanıtıcı kümesinden kaldırır.
   </para>
   <para>
    <parameter>filedes</parameter> bağımsız değişkeni bir kereden fazla değerlendirildiğinden yan etkilere sahip olmamalıdır.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-FD_ISSET"><primary>FD_ISSET</primary></indexterm>
   <csproto type="makro">
    <csname><type>int</type><function>FD_ISSET</function></csname>
    <csparam><type>int</type><parameter>filedes</parameter></csparam>
    <csparam><ptr>fd_set</ptr><parameter>set</parameter></csparam>
   </csproto>
   <header>&sys-types.h;</header>
   <conceptlist>
    <concept>&mtsafe; &race;<code linkend="glibc-safety-identifier">:set</code></concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    Bu makro, <parameter>filedes</parameter> dosya tanıtıcısı <parameter>set</parameter> dosya tanıtıcı kümesinin bir üyesi ise sıfırdan farklı bir değerle (true), aksi takdirde sıfırla (false) döner.
   </para>
   <para>
    <parameter>filedes</parameter> bağımsız değişkeni bir kereden fazla değerlendirildiğinden yan etkilere sahip olmamalıdır.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-select"><primary>select</primary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>select</function></csname>
    <csparam><type>int</type><parameter>nfds</parameter></csparam>
    <csparam><ptr>fd_set</ptr><parameter>read-fds</parameter></csparam>
    <csparam><ptr>fd_set</ptr><parameter>write-fds</parameter></csparam>
    <csparam><ptr>fd_set</ptr><parameter>except-fds</parameter></csparam>
    <csparam><ptr>struct&nbsp;timeval</ptr><parameter>timeout</parameter></csparam>
   </csproto>
   <header>&sys-mman.h;</header>
   <conceptlist>
    <concept>&mtsafe; &race;<code linkend="glibc-safety-identifier">:read-fds</code>  &race;<code linkend="glibc-safety-identifier">:write-fds</code>  &race;<code linkend="glibc-safety-identifier">:except-fds</code></concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <code>select</code> işlevi, belirtilen dosya tanıtıcı kümesindeki tanıtıcılarda bir etkinlik olana kadar ya da belirtilen zaman aşımı süresi dolana kadar çağrıldığı süreci bekletir.
   </para>
   <para>
    <parameter>read-fds</parameter> bağımsız değişkeni ile okumaya hazır tanıtıcılar, <parameter>write-fds</parameter> bağımsız değişkeni ile yazmaya hazır tanıtıcılar belirtilir. <parameter>except-fds</parameter> ile belirtilen tanıtıcılar ise olağan dışı durumlara göre denetlenir. İlgilenilmeyen durumla ilgili olan bağımsız değişkene boş gösterici atanabilir.
   </para>
   <para>
    Bir dosya gösterici eğer <command>read</command> çağrısı engellenmeyecekse okumaya hazır olarak kabul edilir. Engellenme durumları olarak okuma başlangıcının dosyanın sonunda olması veya raporlanacak bir hatanın varlığından bahsedilebilir. Bir sunucu soketi de <command>accept</command> ile <link linkend="glibc-Accepting-Connections">kabul edilebilen bir bağlantı</link> askıdaysa okumaya hazır kabul edilir. Bir istemci soketi ise <link linkend="glibc-Connecting">bağlantı tamamen kurulduğunda</link> yazmaya hazır olur.
   </para>
   <para>
    "Olağandışı durumlar" hata anlamında değildir; hatalar oluştuğunda sistem çağrıları tarafından raporlanır ve bunların tanıtıcının durumu ile ilgisi yoktur. Olağandışı durumlar bir soket üzerinde acil bir iletinin varlığı gibi durumlardır. (Acil iletiler hakkında <xref linkend="glibc-Sockets"/> bölümünde bilgi bulunabilir.)
   </para>
   <para>
    <code>select</code> işlevi sadece ilk <parameter>nfds</parameter> dosya tanıtıcısını denetler. <parameter>nfds</parameter> olarak <varname>FD_SETSIZE</varname> değeri çok kullanışlıdır.
   </para>
   <para>
    <parameter>timeout</parameter> azami bekleme süresini belirtir. Boş gösterici belirtmişse bir süre sınırı olmaksızın bir dosya tanıtıcı hazır olana kadar işlev bekleyecektir. Bunun olmaması için <type>struct&nbsp;timeval</type> türünde bir <link linkend="glibc-High-Resolution-Calendar">zaman aşımı süresi</link> belirtilmelidir. Beklemeden hangi dosya tanıtıcıların hazır olduğuna bakılmak istenirse, buraya süre olarak sıfır (<type>struct&nbsp;timeval</type> üyelerinin hepsi sıfır) belirtilebilir.
   </para>
   <para>
    İşlevin normal dönüş değeri tüm kümelerde hazır olan dosya tanıtıcıların sayısıdır. Küme bağımsız değişkenlerinin her birinde hazır olan tanıtıcılarla ilgili bilgi bulunur. <code>select</code> döndükten sonra belli bir dosya tanıtıcının girdi için hazır olup olmadığı <code>FD_ISSET (<replaceable>dt</replaceable>, <replaceable>oku-dt</replaceable>)</code> ile öğrenilebilir.
   </para>
   <para>
    <code>select</code> zaman aşımına uğramışsa sıfır ile döner.
   </para>
   <para>
    Herhangi bir sinyal <code>select</code> işlevinin anında dönmesine sebep olur. Yazılımda sinyaller kullanılıyorsa belirtilen zaman aşımı süresince işlevin beklemede kalması mümkün olmayabilir. Bu sürenin mutlaka beklenmesi isteniyorsa, <varname>EINTR</varname> durumunun varlığına göre geçerli zaman değeri ile karşılaştırılarak yeni bekleme süresi hesaplanıp çağrı yinelenmelidir. Bunun bir örneği aşağıda verilmiştir, ayrıca bkz. <xref linkend="glibc-Interrupted-Primitives"/>.
   </para>
   <para>
    Bir hata oluşursa işlev <code>-1</code> ile döner ve dosya tanıtıcı kümesi bağımsız değişkenlerinde  bir değişiklik yapmaz. Aşağıdaki <varname>errno</varname> hata durumları bu işlev için tanımlanmıştır:
   </para>
   <variablelist>
    <varlistentry>
     <term><code>EBADF</code></term>
     <listitem>
      <para>
       Dosya tanıtıcı kümelerinden biri geçersiz bir dosya tanıtıcı içeriyor.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>EINTR</code></term>
     <listitem>
      <para>
       İşlem bir sinyalle durduruldu. Bkz.  <xref linkend="glibc-Interrupted-Primitives"/>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>EINVAL</code></term>
     <listitem>
      <para>
       <parameter>timeout</parameter> bağımsız değişkeni geçersiz; üyelerinden biri ya negatif ya da çok büyük.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </csynopsis>
  <note><title>Taşınabilirlik Bilgisi</title>
   <para>
    <function>select</function> işlevi bir BSD Unix özelliğidir.
   </para>
  </note>
  <example>
   <para>
    Bu örnekte bir dosya tanıtıcısının okumaya hazır olmasını belli bir süre beklemek için <function>select</function> işlevinin kullanımı gösterilmiştir. <code>input_timeout</code> işlevi çağrıldığı süreci dosya tanıtıcı üzerinde bir girdi olana kadar ya da belli bir zaman aşımına kadar bekletir.
   </para>
   <screen>#include &lt;errno.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/time.h&gt;

int
input_timeout (int filedes, unsigned int seconds)
{
  fd_set set;
  struct timeval timeout;

  /* <replaceable>Dosya tanıtıcı kümesini ilklendir.</replaceable> */
  FD_ZERO (&amp;set);
  FD_SET (filedes, &amp;set);

  /* <replaceable>Zaman aşımı yapısını ilklendir.</replaceable> */
  timeout.tv_sec = seconds;
  timeout.tv_usec = 0;

  /* <replaceable>select, zamanaşımına uğrarsa 0 ile,
     girdi varsa 1 ile, hata oluşursa -1 ile döner.</replaceable> */
  return TEMP_FAILURE_RETRY (select (FD_SETSIZE,
                                     &amp;set, NULL, NULL,
                                     &amp;timeout));
}

int
main (void)
{
  fprintf (stderr, "select returned %d.\n",
           input_timeout (STDIN_FILENO, 5));
  return 0;
}
</screen>
  </example>
  <para>
   <code>select</code> işlevinin çok sayıda soketten çoklu girdi alınması ile ilgili kullanım örneği  <xref linkend="glibc-Server-Example"/> bölümünde bulunabilir.
  </para>
 </chapter>

 <chapter xml:id="glibc-Synchronizing-I-O">
  <title>G/Ç İşlemlerinin Eşzamanlanması</title>
  <titleabbrev>Tüm G/Ç işlemlerinin tamamlandığını bilmek.</titleabbrev>
  <para>
   <indexterm linkend="glibc-cp"><primary>eşzamanlama</primary></indexterm>
   Günümüzdeki çoğu işletim sisteminde normal G/Ç işlemleri eşzamanlı yapılmaz. Örneğin, bir <function>write</function> çağrısı normal olarak dönse bile bu, verinin ilgili ortama (örn, disk) yazılmış olduğu anlamına gelmez.
  </para>
  <para>
   Eşzamanlamanın gerektiği durumlarda, işlev dönmeden önce tüm işlemlerin tamamlanmış olduğundan emin olunmasını sağlayan özel işlevler vardır.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-sync"><primary>sync</primary></indexterm>
   <csproto type="işlev">
    <csname><type>void</type><function>sync</function></csname>
    <csparam><void/></csparam>
   </csproto>
   <header>&unistd.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    Bu işleve yapılacak bir çağrı, veri aygıta yazılana kadar dönmez. Çekirdekte içinde veri bulunan tüm tamponlar boşaltılır (veri yerine yazıldıktan sonra tampon silinir), böylece sistemin tamamı tutarlı duruma gelir (o an veri yazmakta olan başka bir süreç yoksa).
   </para>
  </csynopsis>
  <para>
   Yazılımlar çoğunlukla sistemdeki tüm verinin değil, bir dosya ile ilgili bir verinin o dosyaya yazıldığından emin olmak ister. Bu bakımdan <function>sync</function> fazla gelir.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-fsync"><primary>fsync</primary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>fsync</function></csname>
    <csparam><type>int</type><parameter>fildes</parameter></csparam>
   </csproto>
   <header>&unistd.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <code>fsync</code> işlevi yazmak amacıyla açılmış ve tanıtıcısı <parameter>fildes</parameter> olan dosyaya tüm veri fiziksel olarak yazılıncaya kadar dönmez.
   </para>
   <para>
    Bu işlev çok evreli yazılımlarda iptal noktasıdır. <code>fsync</code> çağrısı sırasında evre bazı öz kaynakları (bellek, dosya tanıtıcı, semafor, vb.) tahsis ettiğinde bu sorun ortaya çıkar. Evre tam bu anda bir iptal alırsa tahsis edilen öz kaynaklar yazılım sonlanana kadar tahsisli olarak kalır. Bu tür <code>fsync</code> çağrılarından kaçınmak için iptal eylemcileri kullanılarak korunulmalıdır.
   </para>
   <para>
    İşlevin normal dönüş değeri sıfırdır, bir hata oluşmuşsa <code>-1</code> ile döner. Aşağıdaki <varname>errno</varname> hata durumları bu işlev için tanımlanmıştır:
   </para>
   <variablelist>
    <varlistentry>
     <term><code>EBADF</code></term>
     <listitem>
      <para>
       <parameter>fildes</parameter> geçersiz.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>EINVAL</code></term>
     <listitem>
      <para>
       Sistemde ilgili oluşum gerçeklenmediğinden eşzamanlama mümkün değil.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </csynopsis>
  <para>
   Kimi zaman dosya tanıtıcı ile ilgili verinin tamamını yazmak gerekmez. Örneğin, veritabanı dosyalarına veri yazarken dosya boyutu değişmeyeceğinden dosyanın içerdiği verinin aygıta yazılması yeterlidir. Dosya ile ilgili değişiklik zamanı gibi temel veriler önemli değildir ve bu bilgilerin olduğu gibi bırakılması bir sorun çıktığında dosyanın başarıyla kurtarılmasını engellemez.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-fdatasync"><primary>fdatasync</primary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>fdatasync</function></csname>
    <csparam><type>int</type><parameter>fildes</parameter></csparam>
   </csproto>
   <header>&unistd.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <code>fdatasync</code> çağrıldığında, dosya verisinin tamamı aygıta yazılmadan dönmez. Bekleyen tüm G/Ç işlemleri için parçalar veri bütünlüğünü sağlayacak şekilde birleştirilir.
   </para>
   <para>
    Tüm sistemler <code>fdatasync</code> işlemini gerçekleştirmez. Bu işlevselliğin olmadığı sistemlerde <code>fdatasync</code> işlemleri, <code>fdatasync</code> için gereken işlemlerin bir üst kümesi olarak bir <command>fsync</command> çağrısı ile yerine getirilir.
   </para>
   <para>
    İşlevin normal dönüş değeri sıfırdır, bir hata oluşmuşsa <code>-1</code> ile döner. Aşağıdaki <varname>errno</varname> hata durumları bu işlev için tanımlanmıştır:
   </para>
   <variablelist>
    <varlistentry>
     <term><code>EBADF</code></term>
     <listitem>
      <para>
       <parameter>fildes</parameter> geçersiz.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>EINVAL</code></term>
     <listitem>
      <para>
       Sistemde ilgili oluşum gerçeklenmediğinden eşzamanlama mümkün değil.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </csynopsis>
 </chapter>

 <chapter xml:id="glibc-Asynchronous-I-O">
  <title>Eşzamansız G/Ç</title>
  <titleabbrev>G/Ç işlemlerinin birarada yapılması.</titleabbrev>
  <preliminary>
   <para>
    POSIX.1b standardı G/Ç işlemlerinde beklemelerden kaynaklanan zaman kaybını en aza indiren yeni bir G/Ç işlemleri kümesi tanımlar. Yeni işlevler bir yazılımın birden fazla G/Ç işlemini ilklendirmesini ve G/Ç işlemlerini bir arada (paralel) gerçekleştirdikten hemen sonra yazılımın normal çalışmasına dönmesini mümkün kılar. Bu işlevsellik varsa &unistd.h; dosyasında <varname>_POSIX_ASYNCHRONOUS_IO</varname> simgesi tanımlıdır.
   </para>
   <para>
    Bu işlevler, gerçek zamanlı işlevler içeren <filename>librt</filename>  kütüphanesinin bir parçasıdır. Aslında <filename>libc</filename> kodunun parçası değildir. Bu işlevlerin gerçeklenmesi çekirdekteki destek (varsa) kullanılarak ya da kullanıcı seviyesinde evrelere tabanlanmış bir gerçekleme kullanılarak yapılabilir. Son durumda uygulamaları <filename>librt</filename> kütüphanesinden başka <filename>libpthread</filename> evre kütüphanesi ile de ilintilemek gerekir.
   </para>
  </preliminary>
  <para>
   Tüm eşzamansız G/Ç işlemleri önceden açılmış dosyalar üzerinde yapılır. Bir dosya üzerinde seçimlik olarak çok sayıda işlem yapılıyor olabilir. Eşzamansız G/Ç işlemleri <type>struct&nbsp;aiocb</type> ("AIO control block" kısaltmasıdır) isimli bir veri yapısı kullanılarak denetlenir. <type>struct&nbsp;aiocb</type> yapısı &aio.h; başlık dosyasında tanımlıdır.
   <indexterm linkend="glibc-pg"><primary>aio.h</primary></indexterm>.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-tp" xml:id="glibc-tp-aiocb"><primary sortas="aiocb">struct&nbsp;aiocb</primary></indexterm>
   <indexterm xml:id="glibc-cp-aiocb" linkend="glibc-cp"><primary>eşzamansız G/Ç</primary><secondary>veri yapısı</secondary></indexterm>
   <csproto type="veri türü">
    <csname><type>struct</type><function>aiocb</function></csname>
   </csproto>
   <header>&aio.h;</header>
   <para>
    POSIX.1b standardı <code>struct&nbsp;aiocb</code> yapısının en azından aşağıdaki listede açıklanan üyelere sahip olmasını zorunlu kılar. Gerçekleme tarafından kullanılan daha fazla eleman olabilir, ancak bu elemanlara bağımlılık taşınabilir olmayacağından bu kesinlikle önerilmez.
   </para>
   <glosslist>
    <glossentry>
     <glossterm>
      <type>int&nbsp;</type><structfield>aio_fildes</structfield>
     </glossterm>
     <glossdef>
      <para>
       Bu eleman işlem için kullanılan dosya tanıtıcıyı içerir. Tanıtıcı geçerli olmalıdır, aksi takdirde işlem başarısız olur.
      </para>
      <para>
       Dosyanın üzerinde açıldığı aygıt konumlama işlemlerine izin vermelidir. Örneğin, <function>lseek</function> çağrılarının hataya yol açtığı uçbirim benzeri aygıtlar üzerinde eşzamansız G/Ç işlemleri yapılması mümkün değildir.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <type>off_t&nbsp;</type><structfield>aio_offset</structfield>
     </glossterm>
     <glossdef>
      <para>
       Dosyada işlem (girdi ya da çıktı) yapılacak dosya konumunu belirtir. İşlem keyfi sırada yapıldığından ve bir dosya tanıtıcı üzerinde birden fazla işlem başlatıldığından bunun dosya tanıtıcısının geçerli okuma/yazma konumu olduğundan bahsedilemez.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <type>volatile&nbsp;void&nbsp;*</type><structfield>aio_buf</structfield>
     </glossterm>
     <glossdef>
      <para>
       Verinin yazıldığı ya da okunan verinin saklandığı tampona göstericidir.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <type>size_t&nbsp;</type><structfield>aio_nbytes</structfield>
     </glossterm>
     <glossdef>
      <para>
       <structfield>aio_buf</structfield> ile gösterilen tamponun uzunluğudur.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <type>int&nbsp;</type><structfield>aio_reqprio</structfield>
     </glossterm>
     <glossdef>
      <para>
       <indexterm linkend="glibc-vr" xml:id="glibc-vr-POSIX_ASYNCHRONOUS_IO"><primary sortas="POSIX_ASYNCHRONOUS_IO">_POSIX_ASYNCHRONOUS_IO</primary></indexterm>
       <indexterm linkend="glibc-vr" xml:id="glibc-vr-POSIX_PRIORITY_SCHEDULING"><primary sortas="POSIX_PRIORITY_SCHEDULING">_POSIX_PRIORITY_SCHEDULING</primary></indexterm>
       Eğer platform <varname>_POSIX_PRIORITIZED_IO</varname> ve <varname>_POSIX_PRIORITY_SCHEDULING</varname> ile tanımlanmışsa, eşzamansız G/Ç istekleri geçerli zamanlama önceliğine göre işlenir. Bu üye eşzamansız G/Ç işlemini daha düşük önceliğe ayarlamakta kullanılabilir.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <type>struct&nbsp;sigevent&nbsp;</type><structfield>aio_sigevent</structfield>
     </glossterm>
     <glossdef>
      <para>
       <indexterm linkend="glibc-tp" xml:id="glibc-tp-sigevent"><primary sortas="sigevent">struct&nbsp;sigevent</primary></indexterm>
       <indexterm linkend="glibc-vr" xml:id="glibc-vr-SIGEV_NONE"><primary>SIGEV_NONE</primary></indexterm>
       <indexterm linkend="glibc-vr" xml:id="glibc-vr-SIGEV_SIGNAL"><primary>SIGEV_SIGNAL</primary></indexterm>
       <indexterm linkend="glibc-vr" xml:id="glibc-vr-SIGEV_THREAD"><primary>SIGEV_THREAD</primary></indexterm>
       Çağıran sürecin işlem sonlandığında nasıl uyarılacağını belirtir. <code>aio_sigevent.sigev_notify</code> elemanının değeri <code>SIGEV_NONE</code> ise uyarı gönderilmez. <code>SIGEV_SIGNAL</code> ise <code>aio_sigevent.sigev_signo</code> tarafından saptanan sinyal gönderilir. Aksi takdirde, <code>aio_sigevent.sigev_notify</code> elemanının değeri <code>SIGEV_THREAD</code> olmalıdır. Bu durumda, <code>aio_sigevent.sigev_notify_function</code> tarafından gösterilen işlev çalıştırılarak başlatılan bir evre oluşturulur. <footnote><para>Ç.N.: <code>struct&nbsp;sigevent</code> hakkında ayrıntılı bilgi <uri xl:href="man7-sigevent"/> kılavuz sayfasında bulunabilir.</para></footnote>
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <type>int&nbsp;</type><structfield>aio_lio_opcode</structfield>
     </glossterm>
     <glossdef>
      <para>
       Bu eleman sadece <function>lio_listio</function> ve <function>lio_listio64</function> işlevleri tarafından kullanılır. Bu işlevler bir kerede birden fazla keyfi işlemin başlatılmasını mümkün kıldığından ve her işlem bir girdi ya da bir çıktı (ya da hiçbir şey) olabildiğinden, bilgi denetim yapısında (<type>struct&nbsp;aiocb</type>) saklanmalıdır. Olası değerler şunlardır:
      </para>
      <csynopsis>
       <indexterm linkend="glibc-vr" xml:id="glibc-vr-LIO_READ"><primary>LIO_READ</primary></indexterm>
       <csproto type="sabit">
        <csname><function>LIO_READ</function></csname>
       </csproto>
       <header>&aio.h;</header>
       <para>
        Okuma işlemi başlatır. Okuma <structfield>aio_offset</structfield> konumundan başlar ve okunan ilk <structfield>aio_nbytes</structfield> bayt <structfield>aio_buf</structfield> ile gösterilen tamponda saklanır.
       </para>
      </csynopsis>
      <csynopsis>
       <indexterm linkend="glibc-vr" xml:id="glibc-vr-LIO_WRITE"><primary>LIO_WRITE</primary></indexterm>
       <csproto type="sabit">
        <csname><function>LIO_WRITE</function></csname>
       </csproto>
       <header>&aio.h;</header>
       <para>
        Yazma işlemi başlatır. <structfield>aio_buf</structfield>'tan başlayan  <structfield>aio_nbytes</structfield> bayt, dosyaya <structfield>aio_offset</structfield> konumdan itibaren yazılır.
       </para>
      </csynopsis>
      <csynopsis>
       <indexterm linkend="glibc-vr" xml:id="glibc-vr-LIO_NOP"><primary>LIO_NOP</primary></indexterm>
       <csproto type="sabit">
        <csname><function>LIO_NOP</function></csname>
       </csproto>
       <header>&aio.h;</header>
       <para>
        Hiçbir şey yapılmaz. Bu değer, <type>struct&nbsp;aiocb</type> dizisi delikler içerdiğinde kimi zaman kullanışlı olur; örneğin, dizinin tamamında elde edilememiş bazı değerlerle <function>lio_listio</function> çağrısı yapmak.
       </para>
      </csynopsis>
     </glossdef>
    </glossentry>
   </glosslist>
   <para>
    Kaynak dosyası <code>_FILE_OFFSET_BITS == 64</code> ile derlenmişse 32 bitlik sistemlerde bu tür aslında <type>struct&nbsp;aiocb64</type> yapısına karşılıktır. Yani 32 ve 64 bitlik arayüzler yer değiştirir.
   </para>
  </csynopsis>
  <para>
   Büyük Dosya Sisteminde tanımlı eşzamansız G/Ç işlevleri ile kullanmak amacıyla tanımlanmış benzer bir veri türü vardır. Bu yapının üyelerinin türleri daha geniştir. Bunun dışında her iki yapının üyelerinin isimleri aynıdır.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-tp" xml:id="glibc-tp-aiocb64"><primary sortas="aiocb64">struct&nbsp;aiocb64</primary></indexterm>
   <csproto type="veri türü">
    <csname><type>struct</type><function>aiocb64</function></csname>
   </csproto>
   <header>&aio.h;</header>
   <glosslist>
    <glossentry>
     <glossterm>
      <type>int&nbsp;</type><structfield>aio_fildes</structfield>
     </glossterm>
     <glossdef>
      <para>
       Bu eleman işlem için kullanılan dosya tanıtıcıyı içerir. Tanıtıcı geçerli olmalıdır, aksi takdirde işlem başarısız olur.
      </para>
      <para>
       Dosyanın üzerinde açıldığı aygıt konumlama işlemlerine izin vermelidir. Örneğin, <function>lseek</function> çağrılarının hataya yol açtığı uçbirim benzeri aygıtlar üzerinde eşzamansız G/Ç işlemleri yapılması mümkün değildir.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <type>off64_t&nbsp;</type><structfield>aio_offset</structfield>
     </glossterm>
     <glossdef>
      <para>
       Dosyada işlem (girdi ya da çıktı) yapılacak dosya konumunu belirtir. İşlem keyfi sırada yapıldığından ve bir dosya tanıtıcı üzerinde birden fazla işlem başlatıldığından bunun dosya tanıtıcısının geçerli okuma/yazma konumu olduğundan bahsedilemez.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <type>volatile&nbsp;void&nbsp;*</type><structfield>aio_buf</structfield>
     </glossterm>
     <glossdef>
      <para>
       Verinin yazıldığı ya da okunan verinin saklandığı tampona göstericidir.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <type>size_t&nbsp;</type><structfield>aio_nbytes</structfield>
     </glossterm>
     <glossdef>
      <para>
       <structfield>aio_buf</structfield> ile gösterilen tamponun uzunluğudur.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <type>int&nbsp;</type><structfield>aio_reqprio</structfield>
     </glossterm>
     <glossdef>
      <para>
       Eğer platform <varname>_POSIX_PRIORITIZED_IO</varname> ve <varname>_POSIX_PRIORITY_SCHEDULING</varname> ile tanımlanmışsa, eşzamansız G/Ç istekleri geçerli zamanlama önceliğine göre işlenir. Bu üye eşzamansız G/Ç işlemini daha düşük önceliğe ayarlamakta kullanılabilir.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <type>struct&nbsp;sigevent&nbsp;</type><structfield>aio_sigevent</structfield>
     </glossterm>
     <glossdef>
      <para>
       Çağıran sürecin işlem sonlandığında nasıl uyarılacağını belirtir. <code>aio_sigevent.sigev_notify</code> elemanının değeri <code>SIGEV_NONE</code> ise uyarı gönderilmez. <code>SIGEV_SIGNAL</code> ise <code>aio_sigevent.sigev_signo</code> tarafından saptanan sinyal gönderilir. Aksi takdirde, <code>aio_sigevent.sigev_notify</code> elemanının değeri <code>SIGEV_THREAD</code> olmalıdır. Bu durumda, <code>aio_sigevent.sigev_notify_function</code> tarafından gösterilen işlev çalıştırılarak başlatılan bir evre oluşturulur.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <type>int&nbsp;</type><structfield>aio_lio_opcode</structfield>
     </glossterm>
     <glossdef>
      <para>
       Bu eleman sadece <function>lio_listio</function> ve <function>lio_listio64</function> işlevleri tarafından kullanılır. Bu işlevler bir kerede birden fazla keyfi işlemin başlatılmasını mümkün kıldığından ve her işlem bir girdi ya da bir çıktı (ya da hiçbir şey) olabildiğinden, bilgi denetim yapısında (<type>struct&nbsp;aiocb</type>) saklanmalıdır. Olası değerler şunlardır:
      </para>
     </glossdef>
    </glossentry>
   </glosslist>
   <para>
    Kaynak dosyası <code>_FILE_OFFSET_BITS == 64</code> ile derlenmişse 32 bitlik sistemlerde  <type>struct&nbsp;aiocb</type> aslında <type>struct&nbsp;aiocb64</type> yapısına karşılıktır. Yani 32 ve 64 bitlik arayüzler yer değiştirir.
   </para>
  </csynopsis>
  <sect1 xml:id="glibc-Asynchronous-Reads-Writes">
   <title>Eşzamansız Okuma ve Yazma İşlemleri</title>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-aio_read"><primary>aio_read</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-aio_read"><primary>eşzamansız G/Ç</primary><secondary>okumanın ilklendirilmesi</secondary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>aio_read</function></csname>
     <csparam><ptr>struct&#160;aiocb</ptr><parameter>aiocbp</parameter></csparam>
    </csproto>
    <header>&aio.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&asunsafe; &lock; &heap;</concept>
     <concept>&acunsafe; &lock; &mem;</concept>
    </conceptlist>
    <para>
     Bu işlev bir eşzamansız okuma işlemini ilklendirir. İşlem kuyruğa alındığında ya da bir hata oluştuğunda işlev beklemeksizin döner.
    </para>
    <para>
     Tanıtıcısı <code>aiocbp->aio_fildes</code> olan dosyanın <code>aiocbp->aio_offset</code> bayttan itibaren ilk <code>aiocbp->aio_nbytes</code> baytı <code>aiocbp->aio_buf</code>'dan başlayan tampona yazılır.
    </para>
    <para>
     Öncelikli G/Ç destekleyen platformlarda <code>aiocbp->aio_reqprio</code> değeri, istek kuyruğa alınmadan önceki önceliği ayarlamakta kullanılır.
    </para>
    <para>
     İşlevin çağrıldığı süreç, okuma isteğinin sonlaması halinde <code>aiocbp->aio_sigevent</code> değerine göre uyarılır.
    </para>
    <para>
     <code>aio_read</code> işlevinin normal dönüş değeri sıfırdır. İşlem kuyruğa alınmadan önce bir hata oluşmuşsa işlev <code>-1</code> ile döner ve bu durumda <varname>errno</varname> değişkenine şu değerlerden biri atanır:
    </para>
    <variablelist>
     <varlistentry>
      <term><code>EAGAIN</code></term>
      <listitem>
       <para>
        Özkaynak sınırları (geçici olarak) aşıldığı için istek kuyruğa alınmadı.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>ENOSYS</code></term>
      <listitem>
       <para>
        <code>aio_read</code> işlevi gerçeklenmedi.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>EBADF</code></term>
      <listitem>
       <para>
        <code>aiocbp-&gt;aio_fildes</code> tanıtıcısı geçersiz. Bu hata durumu isteğin kuyruğa alınmasından önce tanınmamış olabilir ve bu bakımdan bu hata ayrıca eşzamansız olarak sinyallenir.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>EINVAL</code></term>
      <listitem>
       <para>
        <code>aiocbp-&gt;aio_offset</code> veya <code>aiocbp-&gt;aio_reqpiro</code> değeri geçersiz.  Bu hata durumu isteğin kuyruğa alınmasından önce tanınmamış olabilir ve bu bakımdan bu hata ayrıca eşzamansız olarak sinyallenir.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
    <para>
     <code>aio_read</code> sıfırla dönerse, isteğin geçerli durumu <function>aio_error</function> ve <function>aio_return</function> işlevleri ile sorgulanabilir. <function>aio_error</function> işlevinden dönen değer <varname>EINPROGRESS</varname> oldukça işlem henüz tamamlanmamış demektir. Eğer <function>aio_error</function> sıfırla dönerse işlem başarıyla bitmiş demektir; aksi takdirde, dönen değer bir hata kodu olarak değerlendirilmelidir. İşlem sonlanmışsa, işlemin sonucu  <function>aio_return</function> çağrısı ile sağlanabilir. Dönen değer, eşdeğer <function>read</function> çağrısından dönen değerle aynıdır. <function>aio_error</function> çağrısından dönebilecek olası hata durumları şunlardır:
    </para>
    <variablelist>
     <varlistentry>
      <term><code>EBADF</code></term>
      <listitem>
       <para>
        <code>aiocbp-&gt;aio_fildes</code> tanıtıcısı geçersiz.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>ECANCELED</code></term>
      <listitem>
       <para>
        İşlem bitmeden durduruldu (bkz. <xref linkend="glibc-Cancel-AIO-Operations"/>)
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>EINVAL</code></term>
      <listitem>
       <para>
        <code>aiocbp-&gt;aio_offset</code> değeri geçersiz.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
    <para>
     Kaynak dosyası <code>_FILE_OFFSET_BITS == 64</code> ile derlenmişse 32 bitlik sistemlerde aslında <function>aio_read64</function> işlevine karşılıktır. Yani 32 ve 64 bitlik arayüzler yer değiştirir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-aio_read64"><primary>aio_read64</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>aio_read64</function></csname>
     <csparam><ptr>struct&#160;aiocb64</ptr><parameter>aiocbp</parameter></csparam>
    </csproto>
    <header>&aio.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&asunsafe; &lock; &heap;</concept>
     <concept>&acunsafe; &lock; &mem;</concept>
    </conceptlist>
    <para>
     Bu işlev <function>aio_read</function> işlevine çok benzer. Tek fark, 32 bitlik makinelerde dosya tanıtıcısının büyük dosya kipinde açılmış olmasıdır. İçsel olarak, <code>aio_read64</code> işlevi okumak için dosya konumlayıcıyı doğru yere konumlandırırken <function>lseek64</function> (<xref linkend="glibc-File-Position-Primitive"/>) işlevselliğini kullanır, benzer şekilde <function>aio_read</function> işlevi de <function>lseek</function>  işlevselliğini kullanır.
    </para>
    <para>
     Kaynak dosyası <code>_FILE_OFFSET_BITS == 64</code> ile derlenmişse 32 bitlik sistemlerde bu işleve <function>aio_read</function> ismiyle erişilir. Yani 32 ve 64 bitlik arayüzler yer değiştirir.
    </para>
   </csynopsis>
   <para>
    Veriyi bir dosyaya eşzamansız yazmak için çok benzer bir arayüze sahip eşdeğer bir işlev çifti vardır.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-aio_write"><primary>aio_write</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-aio_write"><primary>eşzamansız G/Ç</primary><secondary>yazmanın ilklendirilmesi</secondary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>aio_write</function></csname>
     <csparam><ptr>struct&#160;aiocb</ptr><parameter>aiocbp</parameter></csparam>
    </csproto>
    <header>&aio.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&asunsafe; &lock; &heap;</concept>
     <concept>&acunsafe; &lock; &mem;</concept>
    </conceptlist>
    <para>
     Bu işlev eşzamansız yazma işlemini ilklendirir. İşlem kuyruğa alındığında ya da bir hata oluştuğunda işlev beklemeksizin döner.
    </para>
    <para>
     <code>aiocbp->aio_buf</code>'dan başlayan tampondaki ilk <code>aiocbp->aio_offset</code> bayt, tanıtıcısı <code>aiocbp->aio_fildes</code> olan dosyaya <code>aiocbp->aio_offset</code> bayttan itibaren yazılır.
    </para>
    <para>
     Öncelikli G/Ç destekleyen platformlarda <code>aiocbp->aio_reqprio</code> değeri, istek kuyruğa alınmadan önceki önceliği ayarlamakta kullanılır.
    </para>
    <para>
     İşlevin çağrıldığı süreç, yazma isteğinin sonlaması halinde <code>aiocbp->aio_sigevent</code> değerine göre uyarılır.
    </para>
    <para>
     <code>aio_write</code> işlevinin normal dönüş değeri sıfırdır. İşlem kuyruğa alınmadan önce bir hata oluşmuşsa işlev <code>-1</code> ile döner ve bu durumda <varname>errno</varname> değişkenine şu değerlerden biri atanır:
    </para>
    <variablelist>
     <varlistentry>
      <term><code>EAGAIN</code></term>
      <listitem>
       <para>
        Özkaynak sınırları (geçici olarak) aşıldığı için istek kuyruğa alınmadı.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>ENOSYS</code></term>
      <listitem>
       <para>
        <code>aio_write</code> işlevi gerçeklenmedi.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>EBADF</code></term>
      <listitem>
       <para>
        <code>aiocbp-&gt;aio_fildes</code> tanıtıcısı geçersiz. Bu hata durumu isteğin kuyruğa alınmasından önce tanınmamış olabilir ve bu bakımdan bu hata ayrıca eşzamansız olarak sinyallenir.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>EINVAL</code></term>
      <listitem>
       <para>
        <code>aiocbp-&gt;aio_offset</code> veya <code>aiocbp-&gt;aio_reqpiro</code> değeri geçersiz.  Bu hata durumu isteğin kuyruğa alınmasından önce tanınmamış olabilir ve bu bakımdan bu hata ayrıca eşzamansız olarak sinyallenir.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
    <para>
     <code>aio_write</code> sıfırla dönerse, isteğin geçerli durumu <function>aio_error</function> ve <function>aio_return</function> işlevleri ile sorgulanabilir. <function>aio_error</function> işlevinden dönen değer <varname>EINPROGRESS</varname> oldukça işlem henüz tamamlanmamış demektir. Eğer <function>aio_error</function> sıfırla dönerse işlem başarıyla bitmiş demektir; aksi takdirde, dönen değer bir hata kodu olarak değerlendirilmelidir. İşlem sonlanmışsa, işlemin sonucu  <function>aio_return</function> çağrısı ile sağlanabilir. Dönen değer, eşdeğer <function>read</function> çağrısından dönen değerle aynıdır. <function>aio_error</function> çağrısından dönebilecek olası hata durumları şunlardır:
    </para>
    <variablelist>
     <varlistentry>
      <term><code>EBADF</code></term>
      <listitem>
       <para>
        <code>aiocbp-&gt;aio_fildes</code> tanıtıcısı geçersiz.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>ECANCELED</code></term>
      <listitem>
       <para>
        İşlem bitmeden durduruldu (bkz. <xref linkend="glibc-Cancel-AIO-Operations"/>)
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>EINVAL</code></term>
      <listitem>
       <para>
        <code>aiocbp-&gt;aio_offset</code> değeri geçersiz.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
    <para>
     Kaynak dosyası <code>_FILE_OFFSET_BITS == 64</code> ile derlenmişse 32 bitlik sistemlerde aslında <function>aio_write64</function> işlevine karşılıktır. Yani 32 ve 64 bitlik arayüzler yer değiştirir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-aio_write64"><primary>aio_write64</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>aio_write64</function></csname>
     <csparam><ptr>struct&#160;aiocb64</ptr><parameter>aiocbp</parameter></csparam>
    </csproto>
    <header>&aio.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&asunsafe; &lock; &heap;</concept>
     <concept>&acunsafe; &lock; &mem;</concept>
    </conceptlist>
    <para>
     Bu işlev <function>aio_read</function> işlevine çok benzer. Tek fark, 32 bitlik makinelerde dosya tanıtıcısının büyük dosya kipinde açılmış olmasıdır. İçsel olarak, <code>aio_read64</code> işlevi okumak için dosya konumlayıcıyı doğru yere konumlandırırken <function>lseek64</function> (<xref linkend="glibc-File-Position-Primitive"/>) işlevselliğini kullanır, benzer şekilde <function>aio_read</function> işlevi de <function>lseek</function>  işlevselliğini kullanır.
    </para>
    <para>
     Kaynak dosyası <code>_FILE_OFFSET_BITS == 64</code> ile derlenmişse 32 bitlik sistemlerde bu işleve <function>aio_read</function> ismiyle erişilir. Yani 32 ve 64 bitlik arayüzler yer değiştirir.
    </para>
   </csynopsis>
   <para>
    Az ya da çok geleneksel arayüzle bu işlevlerden başka, POSIX.1b bir defada birden fazla karışık okuma ve yazma işlemini ilklendiren bir işlev daha tanımlar. Bu işlev <function>readv</function> ve <function>writev</function>  işlevlerinin bir birleşimi gibidir.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-lio_listio"><primary>lio_listio</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-lio_listio"><primary>eşzamansız G/Ç</primary><secondary>oku/yaz ilklendirmesi</secondary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>lio_listio</function></csname>
     <csparam><type>int</type><parameter>mode</parameter></csparam>
     <csparam><type>struct&#160;aiocb&#160;*const</type><parameter>list</parameter><code>[]</code></csparam>
     <csparam><type>int</type><parameter>nent</parameter></csparam>
     <csparam><ptr>struct&#160;sigevent</ptr><parameter>sig</parameter></csparam>
    </csproto>
    <header>&aio.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&asunsafe; &lock; &heap;</concept>
     <concept>&acunsafe; &lock; &mem;</concept>
    </conceptlist>
    <para>
     <code>lio_listio</code> işlevi bir defada birden fazla okuma ve yazma isteğini kuyruğa almakta kullanılabilir. İsteklerin hepsi aynı dosya için, farklı dosyalar için ya da bunlar arasındaki işlemler için olabilir.
    </para>
    <para>
     <code>lio_listio</code> işlevi <parameter>nent</parameter> isteği <parameter>list</parameter> ile gösterilen diziden alır. Uygulanacak işlem <parameter>list</parameter> dizisinin her elemanındaki <structfield>aio_lio_opcode</structfield> elemanından saptanır. Bu alandaki değer <varname>LIO_READ</varname> ise dizinin bu elemanına bir <function>aio_read</function> çağrısı yapılmış gibi (bir farkla, sonlanma aşağıda belirtileceği gibi farklı bir yolla sinyallenir) okuma işlemi kuyruğa alınır. <structfield>aio_lio_opcode</structfield> üyesinin değeri <varname>LIO_WRITE</varname> ise yazma işlemi kuyruğa alınır. Bunlar dışında üyenin değeri <varname>LIO_NOP</varname> olmalıdır, bu durumda dizinin bu elemanı basitçe yok sayılır. Yoksayma işlemi, bütün elemanlar için işlem yapılmayacaksa istekleri içeren dizinin eleman sayısını değiştirmeden isteklerin ele alınması için faydalıdır. Başka durumda, <code>lio_listio</code> çağrısının tüm istekleri işleme sokmadan durdurulduğu durumdur (bkz. <xref linkend="glibc-Cancel-AIO-Operations"/>). Bu durumda işleme sokulmayan istekler yinelenirken işleme sokulmuş istekler yok sayılabilir.
    </para>
    <para>
     <parameter>list</parameter> ile gösterilen dizinin yok sayılmayan elemanlarının üyeleri, evvelce <function>aio_read</function> ve <function>aio_write</function> işlevlerinin açıklamasında belirtilen işlemlere uygun değerlere sahip olmalıdır.
    </para>
    <para>
     <parameter>mode</parameter> bağımsız değişkeni <code>lio_listio</code> işlevinin tüm istekler kuyruğa alındıktan sonra nasıl davranacağını saptamakta kullanılır. <parameter>mode</parameter> olarak <varname>LIO_WAIT</varname> belirtilmişse, tüm istekler tamamlanana kadar işlev bekler. Aksi takdirde, <parameter>mode</parameter> olarak <varname>LIO_NOWAIT</varname> verilebilir ki, bu durumda işlev, işlemler kuyruğa alındıktan hemen sonra işlemlerin bitmesini beklenmeden döner. Bu durumda, işlevi çağıran süreç tüm istekler için <parameter>sig</parameter> ile belirtilen değere bağlı olarak sonlanmaları ile ilgili bir uyarı alır. <parameter>sig</parameter> olarak <varname>NULL</varname> belirtilmişse herhangi bir uyarı gönderilmez. Aksi takdirde ya bir sinyal gönderilir ya da <function>aio_read</function> ve <function>aio_write</function> işlevlerinin açıklamalarında belirtildiği gibi bir evre başlatılır.
    </para>
    <para>
     <parameter>mode</parameter> değeri <varname>LIO_WAIT</varname> ise ve tüm istekler yerine getirilmişse işlevin dönüş değeri sıfır olur. Aksi takdirde işlev <code>-1</code> ile döner ve hata durumu <varname>errno</varname> değişkenine atanır. Hangi isteklerin başarısız olduğunu bulmak için <parameter>list</parameter> dizisindeki her eleman için bir <function>aio_error</function> çağrısı yapılmalıdır.
    </para>
    <para>
     <parameter>mode</parameter> değeri <varname>LIO_NOWAIT</varname> ise tüm istekler düzgün bir şekilde kuyruğa alınmışsa işlevin dönüş değeri sıfır olur. İsteklerin mevcut durumu <function>aio_error</function> ve <function>aio_return</function> çağrıları ile saptanabilir. İşlev bu kipte <code>-1</code> ile dönerse, hata durumu <varname>errno</varname> değişkenine atanır. Bir istek henüz sonlanmamışsa <function>aio_error</function> çağrısı <varname>EINPROGRESS</varname> döndürür. Değer farklı olursa, istek bitmiş demektir, <function>aio_error</function> ya bir hata değeri ya da sıfır ile döner, bu durumda işlemin sonucu <function>aio_return</function> kullanılarak saptanabilir.
    </para>
    <para>
     <varname>errno</varname> için olası değerler şunlardır:
    </para>
    <variablelist>
     <varlistentry>
      <term><code>EAGAIN</code></term>
      <listitem>
       <para>
        Tüm istekleri kuyruğa almak için gereken öz kaynaklar şu anda yok. Hangi isteğin başarısız olduğunu bulmak için <parameter>list</parameter> dizisinin tüm elemanları için hata durumuna bakılmalıdır.
       </para>
       <para>
        Bu hatanın başka bir sebebi de eşzamansız G/Ç isteklerinin sistem çapında sınırları aşması olabilirdi. Bu durum GNU sistemlerinde keyfi sınırlar olmadığından mümkün değildir.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>EINVAL</code></term>
      <listitem>
       <para>
        Ya <parameter>mode</parameter> bağımsız değişkeni geçersiz ya da <parameter>nent</parameter><code> &gt; </code><varname>AIO_LISTIO_MAX</varname>.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>EIO</code></term>
      <listitem>
       <para>
        Bir ya da daha fazla G/Ç isteği başarısız oldu. Hangi isteğin başarısız olduğunu bulmak için <parameter>list</parameter> dizisinin tüm elemanları için hata durumuna bakılmalıdır.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>ENOSYS</code></term>
      <listitem>
       <para>
        <code>lio_listio</code> işlevi desteklenmiyor.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
    <para>
     <parameter>mode</parameter> değeri <varname>LIO_NOWAIT</varname> ise ve istek iptal edilmişse bu istek için <function>aio_error</function> çağrısından dönen hata durumu <varname>ECANCELED</varname> olur.
    </para>
    <para>
     Kaynak dosyası <code>_FILE_OFFSET_BITS == 64</code> ile derlenmişse 32 bitlik sistemlerde bu işlev aslında <function>lio_listio64</function> işlevine karşılıktır. Yani 32 ve 64 bitlik arayüzler yer değiştirir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-lio_listio64"><primary>lio_listio64</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>lio_listio64</function></csname>
     <csparam><type>int</type><parameter>mode</parameter></csparam>
     <csparam><type>struct&#160;aiocb64&#160;*const</type><parameter>list</parameter><code>[]</code></csparam>
     <csparam><type>int</type><parameter>nent</parameter></csparam>
     <csparam><ptr>struct&#160;sigevent</ptr><parameter>sig</parameter></csparam>
    </csproto>
    <header>&aio.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&asunsafe; &lock; &heap;</concept>
     <concept>&acunsafe; &lock; &mem;</concept>
    </conceptlist>
    <para>
     Bu işlev <function>lio_listio</function> işlevine çok benzer. Tek fark, 32 bitlik makinelerde dosya tanıtıcısının büyük dosya kipinde açılmış olmasıdır. İçsel olarak, <code>lio_listio64</code> işlevi okumak için dosya konumlayıcıyı doğru yere konumlandırırken <function>lseek64</function> (<xref linkend="glibc-File-Position-Primitive"/>) işlevselliğini kullanır, benzer şekilde <function>lio_listio</function> işlevi de <function>lseek</function>  işlevselliğini kullanır.
    </para>
    <para>
     Kaynak dosyası <code>_FILE_OFFSET_BITS == 64</code> ile derlenmişse 32 bitlik sistemlerde bu işleve <function>lio_listio</function> ismiyle erişilir. Yani 32 ve 64 bitlik arayüzler yer değiştirir.
    </para>
   </csynopsis>
  </sect1>
  <sect1 xml:id="glibc-Status-of-AIO-Operations">
   <title>Eşzamansız G/Ç İşlemlerinin Durumu</title>
   <titleabbrev>Eşzamansız G/Ç işlemlerinin durumunu öğrenilmesi</titleabbrev>
   <para>
    Önceki bölümde değinilen işlevlerin açıklamalarında da belirtildiği gibi, bir G/Ç isteğinin durumu hakkında bilgi edinilmesi mümkün olmalıdır. İşlem gerçekten eşzamansız olarak gerçekleştirildiğinde (<function>aio_read</function> ve <function>aio_write</function> ile ilgili olarak <function>lio_listio</function> işlevinde kip olarak <varname>LIO_NOWAIT</varname> belirtilmesi durumu), kimi zaman bir isteğin sonlanmış olup olmadığı, sonlanmışsa sonucun ne olduğunu bilmek gerekir. Aşağıdaki iki işlev bu çeşit bilgileri almak için tasarlanmıştır.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-aio_error"><primary>aio_error</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-aio_error"><primary>eşzamansız G/Ç</primary><secondary>hata durumu</secondary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>aio_error</function></csname>
     <csparam><ptr>const&#160;struct&#160;aiocb</ptr><parameter>aiocbp</parameter></csparam>
    </csproto>
    <header>&aio.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     Bu işlev <parameter>aiocbp</parameter> ile gösterilen <type>struct&#160;aiocb</type> yapısında açıklanan isteğin hata durumunu saptar. İstek henüz sonlanmamışsa daima <varname>EINPROGRESS</varname> döner. İstek sonlandıktan sonra <code>aio_error</code> işlevi istek başarıyla tamamlanmışsa sıfır ile döner, aksi takdirde isteğin <function>read</function>, <function>write</function> ya da <function>fsync</function> işlevlerinin sonucu olarak <varname>errno</varname> hata durumlarının karşılığı olan bir değer döner.
    </para>
    <para>
     İşlev gerçeklenmemişse <varname>ENOSYS</varname> dönebilir. Eğer <parameter>aiocbp</parameter> bağımsız değişkeni dönüş durumu bilinmeyen bir eşzamansız işlemi belirtiyorsa işlev  <varname>EINVAL</varname> değeriyle de dönebilir.
    </para>
    <para>
     Kaynak dosyası <code>_FILE_OFFSET_BITS == 64</code> ile derlenmişse 32 bitlik sistemlerde bu işlev aslında <function>aio_error64</function> işlevine karşılıktır. Yani 32 ve 64 bitlik arayüzler yer değiştirir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-aio_error64"><primary>aio_error64</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>aio_error64</function></csname>
     <csparam><ptr>const&#160;struct&#160;aiocb64</ptr><parameter>aiocbp</parameter></csparam>
    </csproto>
    <header>&aio.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     Bu işlev, bağımsız değişkeninin <type>struct&#160;aiocb64</type> türünde bir değişken olması dışında <function>aio_error</function> işlevine benzer.
    </para>
    <para>
     Kaynak dosyası <code>_FILE_OFFSET_BITS == 64</code> ile derlenmişse 32 bitlik sistemlerde bu işleve <function>aio_error</function> ismiyle erişilir. Yani 32 ve 64 bitlik arayüzler yer değiştirir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-aio_return"><primary>aio_return</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-aio_return"><primary>eşzamansız G/Ç</primary><secondary>dönüş durumu</secondary></indexterm>
    <csproto type="işlev">
     <csname><type>ssize_t</type><function>aio_return</function></csname>
     <csparam><ptr>struct&#160;aiocb</ptr><parameter>aiocbp</parameter></csparam>
    </csproto>
    <header>&aio.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     Bu işlev <parameter>aiocbp</parameter> ile gösterilen <type>struct&#160;aiocb</type> yapısında açıklanan isteğin dönüş durumunu saptar. <function>aio_error</function> işlevinin bu istek için <varname>EINPROGRESS</varname> döndürdüğü durumda bu işlevin dönüş değeri tanımsızdır.
    </para>
    <para>
     İstek bittikten hemen sonra bu işlev dönüş durumunu saptamak için kullanılır. Aşağıdaki çağrılar tanımlanmamış bir davranışla sonuçlanabilir. Dönüş değeri yapılan işleme göre <function>read</function>, <function>write</function> ya da <function>fsync</function> çağrılarının döndürdüğü değerdir.
    </para>
    <para>
     İşlev gerçeklenmemişse <varname>ENOSYS</varname> dönebilir. Eğer <parameter>aiocbp</parameter> bağımsız değişkeni dönüş durumu bilinmeyen bir eşzamansız işlemi belirtiyorsa işlev  <varname>EINVAL</varname> değeriyle de dönebilir.
    </para>
    <para>
     Kaynak dosyası <code>_FILE_OFFSET_BITS == 64</code> ile derlenmişse 32 bitlik sistemlerde bu işlev aslında <function>aio_return64</function> işlevine karşılıktır. Yani 32 ve 64 bitlik arayüzler yer değiştirir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-aio_return64"><primary>aio_return64</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>aio_return64</function></csname>
     <csparam><ptr>struct&#160;aiocb64</ptr><parameter>aiocbp</parameter></csparam>
    </csproto>
    <header>&aio.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     Bu işlev, bağımsız değişkeninin <type>struct&#160;aiocb64</type> türünde bir değişken olması dışında <function>aio_return</function> işlevine benzer.
    </para>
    <para>
     Kaynak dosyası <command>_FILE_OFFSET_BITS == 64</command> ile derlenmişse 32 bitlik sistemlerde bu işleve <function>aio_return</function> ismiyle erişilir. Yani 32 ve 64 bitlik arayüzler yer değiştirir.
    </para>
   </csynopsis>
  </sect1>
  <sect1 xml:id="glibc-Synchronizing-AIO-Operations">
   <title>Eşzamansız G/Ç İşlemlerinin Eşzamanlanması</title>
   <titleabbrev>İstikrarlı duruma geçme.</titleabbrev>
   <para>
    Eşzamansız işlemlerle çalışırken kimi zaman tutarlı duruma geçmek gerekir. Bu, eşzamansız G/Ç işlemlerinde belli bir isteğin ya da belli bir istek grubunun işlenip işlenmediğinin bilinmesinin istendiği anlamına gelir. Bu, işlem sonlandıktan sonra sistem tarafından gönderilecek bir uyarı beklenerek de yapılabilirdi, fakat bu kimi zaman öz kaynakların kirlenmesi anlamına gelir (özellikle hesaplama sırasında). Bunun yerine tutarlılık gerektiren çoğu durumda yardımcı olmak üzere POSIX.1b iki işlev tanımlamıştır.
   </para>
   <para>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-POSIX_SYNCHRONIZED_IO"><primary sortas="POSIX_SYNCHRONIZED_IO">_POSIX_SYNCHRONIZED_IO</primary></indexterm>
    <function>aio_fsync</function> ve <function>aio_fsync64</function> işlevleri sadece &unistd.h; dosyasında <varname>_POSIX_SYNCHRONIZED_IO</varname> tanımlıysa kullanılabilir.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-aio_fsync"><primary>aio_fsync</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-aio_fsync"><primary>eşzamansız G/Ç</primary><secondary>tutarlı durum</secondary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>aio_fsync</function></csname>
     <csparam><type>int</type><parameter>op</parameter></csparam>
     <csparam><ptr>struct&#160;aiocb</ptr><parameter>aiocbp</parameter></csparam>
    </csproto>
    <header>&aio.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&asunsafe; &lock; &heap;</concept>
     <concept>&acunsafe; &lock; &mem;</concept>
    </conceptlist>
    <para>
     Bu işlev çağrıldığında <code>aiocbp->aio_fildes</code> tanıtıcısı üzerinde işlev çağrısının çalışması esnasında kuyruktaki tüm G/Ç işlemleri eşzamanlı G/Ç tamamlama durumuna (bkz. <xref linkend="glibc-Synchronizing-I-O"/>) sokulmaya zorlanır. <code>aio_fsync</code> işlevi beklemeden hemen döner ancak, <code>aiocbp->aio_sigevent</code> ile belirtilen yöntem üzerinden uyarı sadece dosya tanıtıcısı sonlandığında ve dosya eşzamanlandığında verilir. Bu ayrıca, eşzamanlama isteğinden sonra aynı dosya tanıtıcısı için yapılan bu isteklerin etkili olmadığı anlamına gelir.
    </para>
    <para>
     <parameter>op</parameter> değeri <varname>O_DSYNC</varname> ise eşzamanlama bir <function>fdatasync</function> çağrısı olarak, <varname>O_SYNC</varname> ise bir <function>fsync</function> çağrısı olarak gerçekleştirilir.
    </para>
    <para>
     Eşzamanlama oluşmadığı sürece, <parameter>aiocbp</parameter> ile gösterilen nesne ile yapılan <function>aio_error</function> çağrıları <varname>EINPROGRESS</varname> ile döner. Eşzamanlama oluştuktan sonra yapılan bir <function>aio_error</function> çağrısı eşzamanlama gerçekleşmişse sıfır ile döner; aksi takdirde, <function>fsync</function> ya da <function>fdatasync</function> çağrılarının hata durumunda <varname>errno</varname> değişkenine atadıkları değer ile döner. Bu durumda dosya tanıtıcısına veri yazmada tutarlılık anlamında hiçbir şey yapılmamış olabilir.
    </para>
    <para>
     İstek başarıyla kuyruğa alınmışsa bu işlevin dönüş değeri sıfır olur. Aksi takdirde <code>-1</code> ile döner ve <varname>errno</varname> değişkenine şu değerlerden biri atanır:
    </para>
    <variablelist>
     <varlistentry>
      <term><code>EAGAIN</code></term>
      <listitem>
       <para>
        Tüm istekleri kuyruğa almak için gereken öz kaynaklar şu anda yok. Hangi isteğin başarısız olduğunu bulmak için <parameter>list</parameter> dizisinin tüm elemanları için hata durumuna bakılmalıdır.
       </para>
       <para>
        Bu hatanın başka bir sebebi de eşzamansız G/Ç isteklerinin sistem çapında sınırları aşması olabilirdi. Bu durum GNU sistemlerinde keyfi sınırlar olmadığından mümkün değildir.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>EAGAIN</code></term>
      <listitem>
       <para>
        İstek, öz kaynakların geçici yokluğundan dolayı kuyruğa alınmadı.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>EBADF</code></term>
      <listitem>
       <para>
        <code><parameter>aiocbp</parameter>-&gt;aio_fildes</code> tanıtıcı ya geçersiz ya da yazmak için açılmamış.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>EINVAL</code></term>
      <listitem>
       <para>
        Ya gerçekleme G/Ç eşzamanlamasını gerçeklemiyor ya da  <parameter>op</parameter> değeri <varname>O_DSYNC</varname> veya <varname>O_SYNC</varname> değil.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>ENOSYS</code></term>
      <listitem>
       <para>
        İşlev gerçeklenmedi.
      </para>
      </listitem>
     </varlistentry>
    </variablelist>
    <para>
     Kaynak dosyası <code>_FILE_OFFSET_BITS == 64</code> ile derlenmişse 32 bitlik sistemlerde bu işlev aslında <command>aio_fsync64</command> işlevine karşılıktır. Yani 32 ve 64 bitlik arayüzler yer değiştirilir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-aio_fsync64"><primary>aio_fsync64</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>aio_fsync64</function></csname>
     <csparam><type>int</type><parameter>op</parameter></csparam>
     <csparam><ptr>struct&#160;aiocb64</ptr><parameter>aiocbp</parameter></csparam>
    </csproto>
    <header>&aio.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&asunsafe; &lock; &heap;</concept>
     <concept>&acunsafe; &lock; &mem;</concept>
    </conceptlist>
    <para>
     Bu işlev, bağımsız değişkeninin <type>struct&#160;aiocb64</type> türünde bir değişken olması dışında <function>aio_fsync</function> işlevine benzer.
    </para>
    <para>
     Kaynak dosyası <command>_FILE_OFFSET_BITS == 64</command> ile derlenmişse 32 bitlik sistemlerde bu işleve <function>aio_fsync</function> ismiyle erişilir. Yani 32 ve 64 bitlik arayüzler yer değiştirilir.
    </para>
   </csynopsis>
   <para>
    Başka bir eşzamanlama yöntemi de bir ya da daha fazla istekten oluşan belli bir küme sonlanana kadar beklemektir. Bu, sonlanma hakkında işlemi başlatan sürecin uyarılmasında <code>aio_*</code> işlevleri kullanılmasıyla mümkün olsa da bazı durumlarda bu ideal bir çözüm değildir. Sunucuya bağlı istemcileri sürekli güncel tutan bir yazılımda bazı bağlantıların yavaş bağlantılar olması nedeniyle istemcilerin sırayla taranması da en iyi çözüm olmaz. Diğer taraftan, bir istemci güncellenmeden uyarı alan süreç yeni istemciye geçemeyeceğinden, bir <code>aio_*</code> işlevinden uyarı ile işlemin durdurulması bir şey ifade etmeyeceği için bu da iyi bir çözüm olmaz. Bu gibi durumlar için <function>aio_suspend</function> kullanılmalıdır.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-aio_suspend"><primary>aio_suspend</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-aio_suspend"><primary>eşzamansız G/Ç</primary><secondary>bekletme</secondary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>aio_suspend</function></csname>
     <csparam><type>const&#160;struct&#160;aiocb&#160;*const</type><parameter>list</parameter><code>[]</code></csparam>
     <csparam><type>int</type><parameter>nent</parameter></csparam>
     <csparam><type>const&#160;struct&#160;timespec&#160;*restrict</type><parameter>timeout</parameter></csparam>
    </csproto>
    <header>&aio.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&asunsafe; &lock;</concept>
     <concept>&acunsafe; &lock;</concept>
    </conceptlist>
    <para>
     Bu işlev çağrıldığında, <parameter>list</parameter> dizisinin <parameter>nent</parameter> elemanı tarafından yapılan isteklerden en az biri tamamlanana kadar çağıran evre bekletilir. <code>aio_suspend</code> çağrısı sırasında zaten tamamlanmış bir istek varsa işlev beklemeksizin döner. Bir isteğin sonlanıp sonlanmadığı isteğin hata durumunun <varname>EINPROGRESS</varname> olup olmamasına bağlıdır. <parameter>list</parameter>enin <varname>NULL</varname> elemanı varsa bu girdi yok sayılır.
    </para>
    <para>
     Tamamlanan bir istek yoksa, çağıran süreç beklemeye alınır. <parameter>timeout</parameter> bağımsız değişkeninde <varname>NULL</varname> belirtilmişse, bir istek tamamlanana kadar süreç ilerlemez. <parameter>timeout</parameter> bağımsız değişkeni <varname>NULL</varname> değilse, belirtilen süre kadar süreç bekletilir. Bu durumda <code>aio_suspend</code> bir hata ile döner.
    </para>
    <para>
     <parameter>list</parameter>edeki elemanlardan en az biri sonlanmışsa işlev sıfır değeri ile döner. Aksi takdirde <code>-1</code> ile döner, bu durumda <varname>errno</varname> değişkeninde şu durumlardan biri olabilir:
    </para>
    <variablelist>
     <varlistentry>
      <term><code>EAGAIN</code></term>
      <listitem>
       <para>
        <parameter>list</parameter>edeki elemanlardan hiçbiri belirtilen <parameter>timeout</parameter> süresinde tamamlanmadı.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>EINTR</code></term>
      <listitem>
       <para>
        <code>aio_suspend</code> işlevini bir sinyal durdurdu. Bu sinyal eşzamansız G/Ç gerçeklenimi tarafından isteklerden birinin sonlanması sinyallenirken de gönderilmiş olabilir.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>ENOSYS</code></term>
      <listitem>
       <para>
        <code>aio_suspend</code> işlevi gerçeklenmedi.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
    <para>
     Kaynak dosyası <code>_FILE_OFFSET_BITS == 64</code> ile derlenmişse 32 bitlik sistemlerde bu işlev aslında <function>aio_suspend64</function> işlevine karşılıktır. Yani 32 ve 64 bitlik arayüzler yer değiştirilir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-aio_suspend64"><primary>aio_suspend64</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>aio_suspend64</function></csname>
     <csparam><type>const&#160;struct&#160;aiocb64&#160;*const</type><parameter>list</parameter><code>[]</code></csparam>
     <csparam><type>int</type><parameter>nent</parameter></csparam>
     <csparam><type>const&#160;struct&#160;timespec&#160;*restrict</type><parameter>timeout</parameter></csparam>
    </csproto>
    <header>&aio.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&asunsafe; &lock;</concept>
     <concept>&acunsafe; &lock;</concept>
    </conceptlist>
    <para>
     Bu işlev, bağımsız değişkeninin <type>struct&#160;aiocb64</type> türünde bir değişken olması dışında <function>aio_suspend</function> işlevine benzer.
    </para>
    <para>
     Kaynak dosyası <command>_FILE_OFFSET_BITS == 64</command> ile derlenmişse 32 bitlik sistemlerde bu işleve <function>aio_suspend</function> ismiyle erişilir. Yani 32 ve 64 bitlik arayüzler yer değiştirilir.
    </para>
   </csynopsis>
  </sect1>
  <sect1 xml:id="glibc-Cancel-AIO-Operations">
   <title>Eşzamansız G/Ç İşlemlerinin İptal Edilmesi</title>
   <para>
    Bir ya da daha fazla istek eşzamansız olarak işlenirken, yazılması istenen bir verinin artık geçersiz hale gelmesi ve dolayısıyla bu verinin daha sonra düzeltilmesinin gerekmesi gibi bazı durumlarda seçilen bir işlemin iptal edilmesi gerekebilir. Bir örnek olarak, gelen veriyi dosyalara yazan bir uygulamanın, bir dosyaya yazılmak üzere gelmiş bir verinin kuyruğa alınacak bir başka istek ile güncellenmek istemesi verilebilir. POSIX eşzamansız G/Ç gerçeklemesi böyle bir işlev içerir, fakat bu işlevin bir isteği iptale zorlama yeteneği yoktur. Sadece bir isteğin iptalinin mümkün olup olmadığına karar vermeye yardımcı olur.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-aio_cancel"><primary>aio_cancel</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-aio_cancel"><primary>eşzamansız G/Ç</primary><secondary>işlemin iptal edilebilirliği</secondary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>aio_cancel</function></csname>
     <csparam><type>int</type><parameter>fildes</parameter></csparam>
     <csparam><ptr>struct&#160;aiocb</ptr><parameter>aiocbp</parameter></csparam>
    </csproto>
    <header>&aio.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&asunsafe; &lock; &heap;</concept>
     <concept>&acunsafe; &lock; &mem;</concept>
    </conceptlist>
    <para>
     <code>aio_cancel</code> işlevi askıdaki bir ya da daha fazla isteği iptal etmek için kullanılabilir. <parameter>aiocbp</parameter> bağımsız değişkeni <varname>NULL</varname> ise <parameter>fildes</parameter> ile ilgili askıdaki tüm işlemleri iptal etmeye çalışır. <parameter>aiocbp</parameter> bağımsız değişkeni <varname>NULL</varname> değilse, <parameter>aiocbp</parameter> ile gösterilen belli bir isteği iptal etmeye çalışır.
    </para>
    <para>
     Başarıyla iptal edilen istekler için isteğin sonlanması ile ilgili normal uyarı yapılmalıdır. Bunu denetleyen <type>struct&#160;sigevent</type> nesnesine bağlı olarak hiçbir şey yapılmaz, bir sinyal gönderilir ya da evre başlatılır. İstek iptal edilemezse, işlem, gerçekleştikten sonra normal yolla sonlanır.
    </para>
    <para>
     Bir istek başarıyla iptal edildikten sonra, bu istek için yapılan bir <function>aio_error</function> çağrısı <varname>ECANCELED</varname> ile, <function>aio_return</function> ise <code>-1</code> ile döner. Eğer istek iptal edilmemişse ve hala işlenmekteyse hata durumu <varname>EINPROGRESS</varname> olur.
    </para>
    <para>
     Sonlanmadan iptal edilmiş bir istek varsa, işlevin dönüş değeri <varname>AIO_CANCELED</varname> olur. İptal edilmemiş istek ya da istekler varsa, dönüş değeri <varname>AIO_NOTCANCELED</varname> olur. Bu durumda (<parameter>aiocbp</parameter>'nin <varname>NULL</varname> olarak belirtildiği durum) iptal edilemeyen istekleri bulmak için <function>aio_error</function> kullanılmalıdır. Tüm istekler iptal edilmişse <code>aio_cancel</code> işlevinin dönüş değeri <varname>AIO_ALLDONE</varname> olacaktır.
    </para>
    <para>
     <code>aio_cancel</code> çağrısı sırasında bir hata oluşmuşsa işlev <code>-1</code> ile döner ve <varname>errno</varname> değişkenine aşağıdaki durumlardan biri atanır:
    </para>
    <variablelist>
     <varlistentry>
      <term><code>EBADF</code></term>
      <listitem>
       <para>
        <parameter>fildes</parameter> tanıtıcısı geçersiz.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>ENOSYS</code></term>
      <listitem>
       <para>
        <code>aio_cancel</code> işlevi gerçeklenmedi.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
    <para>
     Kaynak dosyası <code>_FILE_OFFSET_BITS == 64</code> ile derlenmişse 32 bitlik sistemlerde bu işlev aslında <function>aio_cancel64</function> işlevine karşılıktır. Yani 32 ve 64 bitlik arayüzler yer değiştirilir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-aio_cancel64"><primary>aio_cancel64</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>aio_cancel64</function></csname>
     <csparam><type>int</type><parameter>fildes</parameter></csparam>
     <csparam><ptr>struct&#160;aiocb64</ptr><parameter>aiocbp</parameter></csparam>
    </csproto>
    <header>&aio.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&asunsafe; &lock; &heap;</concept>
     <concept>&acunsafe; &lock; &mem;</concept>
    </conceptlist>
    <para>
     Bu işlev, bağımsız değişkeninin <type>struct&#160;aiocb64</type> türünde bir değişken olması dışında <function>aio_cancel</function> işlevine benzer.
    </para>
    <para>
     Kaynak dosyası <command>_FILE_OFFSET_BITS == 64</command> ile derlenmişse 32 bitlik sistemlerde bu işleve <function>aio_cancel</function> ismiyle erişilir. Yani 32 ve 64 bitlik arayüzler yer değiştirilir.
    </para>
   </csynopsis>
  </sect1>
  <sect1 xml:id="glibc-Configuration-of-AIO">
   <title>Eşzamansız G/Ç İşlemlerinin Yapılandırılması</title>
   <titleabbrev>Eşzamansız G/Ç işlemleri nasıl en iyilenir</titleabbrev>
   <para>
    POSIX standardı eşzamansız G/Ç işlevlerinin nasıl gerçekleneceğini belirtmez. Bunlar sistem çağrıları olabileceği gibi ayrıca kullanıcı seviyesinde de gerçekleştirilmiş olabilir.
   </para>
   <para>
    Bu kılavuzun yazılması sırasında geçerli olan gerçeklenim, kuyruğa alınmış işlemlerin gerçeklenmesinde evrelerin kullanıldığı bir kullanıcı seviyesi gerçeklenimiydi. Bu gerçeklenim sınırlamalarla ilgili bazı kararlar vermeyi gerektirirken, değiştirilemeyen sınırlamaların bazılarından &glibc;nde en iyi biçimde kaçınılmıştır. Bununla birlikte, &glibc; bireysel kullanımla ilgili olarak eşzamansız G/Ç gerçekleniminde bazı ayarlamalar yapılabilmesini sağlamıştır.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-tp" xml:id="glibc-tp-aioinit"><primary sortas="aioinit">struct&#160;aioinit</primary></indexterm>
    <csproto type="veri türü">
     <csname><type>struct</type><function>aioinit</function></csname>
    </csproto>
    <header>&aio.h;</header>
    <para>
     Bu veri türü yapılandırmayı ya da ayarlanabilir bağımsız değişkenleri gerçeklenime aktarmakta kullanılır. Bir yazılım bu yapının üyelerini ilklendirdikten sonra bunu gerçeklenime <function>aio_init</function> işlevini kullanarak aktarmalıdır.
    </para>
    <glosslist>
     <glossentry>
      <glossterm>
       <type>int&nbsp;</type><structfield>aio_threads</structfield>
      </glossterm>
      <glossdef>
       <para>
        Herhangi bir anda kullanılabilen azami evre sayısını belirler.
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm>
       <type>int&nbsp;</type><structfield>aio_num</structfield>
      </glossterm>
      <glossdef>
       <para>
        Aynı anda kuyruğa alınabilecek isteklerin azami sayısına bir yaklaşıklık sağlar.
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm>
       <glossterm>
        <type>int&nbsp;</type><structfield>aio_locks</structfield>
       </glossterm>
       <glossterm>
        <type>int&nbsp;</type><structfield>aio_usedba</structfield>
       </glossterm>
       <glossterm>
        <type>int&nbsp;</type><structfield>aio_debug</structfield>
       </glossterm>
       <glossterm>
        <type>int&nbsp;</type><structfield>aio_numusers</structfield>
       </glossterm>
       <glossterm>
        <type>int&nbsp;</type><structfield>aio_reserved</structfield><code>[2]</code>
       </glossterm>
      </glossterm>
      <glossdef>
       <para>
        Kullanılmadı.
       </para>
      </glossdef>
     </glossentry>
    </glosslist>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-aio_init"><primary>aio_init</primary></indexterm>
    <csproto type="işlev">
     <csname><type>void</type><function>aio_init</function></csname>
     <csparam><ptr>const&#160;struct&#160;aioinit</ptr><parameter>init</parameter></csparam>
    </csproto>
    <header>&aio.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&asunsafe; &lock;</concept>
     <concept>&acunsafe; &lock;</concept>
    </conceptlist>
    <para>
     Bu işlev herhangi bir eşzamansız G/Ç işlevinden önce çağrılmalıdır. Çağrılması tamamen isteğe bağlıdır, sadece eşzamansız G/Ç işlemleri gerçekleniminin daha iyi işlem yapmasına yardımcı olunması için kullanılabilir.
    </para>
    <para>
     <code>aio_init</code> çağrısı yapılmadan önce, <type>struct&#160;aioinit</type> yapısının üyeleri ilklendirilmelidir. Bu yapıldıktan sonra yapı işleve bağımsız değişken olarak aktarılır.
    </para>
    <para>
     İşlev bir dönüş değerine sahip olmadığı gibi işlevle ilgili atanmış bir hata da yoktur. Irix 6'daki SGI gerçeklenimindeki bir öneriden kaynaklanan bir oluşumdur. POSIX.1b veya Unix98 standartlarının kapsamında değildir.
    </para>
   </csynopsis>
  </sect1>
 </chapter>

 <chapter xml:id="glibc-Control-Operations">
  <title>Dosyalar Üzerindeki Denetim İşlemleri</title>
  <titleabbrev>Dosya tanıtıcılardaki diğer işlemler.</titleabbrev>
  <para>
   <indexterm linkend="glibc-cp"><primary>dosya tanıtıcılar</primary><secondary>denetim işlemleri</secondary></indexterm>
   Bu kısımda dosya tanıtıcıları üzerinde, dosya tanıtıcılarla ilgili seçeneklerin ayarlanması ve sorgulanması, kayıt kilitleri gibi diğer işlemlerin nasıl uygulanacağından bahsedilecektir. Bu işlemlerin hepsi <function>fcntl</function> işleviyle uygulanır.
  </para>
  <para>
   <indexterm linkend="glibc-pg"><primary>fcntl.h</primary></indexterm>
   <function>fcntl</function> işlevinin ikinci bağımsız değişkeni hangi işlemin uygulanacağını belirleyen bir komuttur. Bu işlemlerle ilgili çeşitli seçenekleri isimlendiren makrolar ile işlevler &fcntl.h; başlık dosyasında bildirilmiştir. Bu seçeneklerin çoğu <function>open</function> işlevi tarafından da kullanılır; bkz. <xref linkend="glibc-Opening-and-Closing-Files"/>.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-fcntl"><primary>fcntl</primary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>fcntl</function></csname>
    <csparam><type>int</type><parameter>filedes</parameter></csparam>
    <csparam><type>int</type><parameter>command</parameter></csparam>
    <varargs/>
   </csproto>
   <header>&fcntl.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <code>fcntl</code> işlevi <parameter>command</parameter> ile belirtilen işlemi <parameter>filedes</parameter> tanıtıcısına uygular.  Bazı komutlar ek bağımsız değişkenler gerektirebilir. Ek bağımsız değişkenler gerektiren komutlar, bunların dönüş değerleri ve hata durumları her komutun bağlantılı açıklamasında ayrı ayrı belirtilmiştir.
   </para>
   <para>
    Komutların özet listesi:
   </para>
   <glosslist>
    <glossentry>
     <glossterm><varname>F_DUPFD</varname></glossterm>
     <glossdef>
      <para>
       Dosya tanıtıcısının kopyasını yapar (aynı açık dosyaya başka bir dosya tanıtıcı döndürür). Bkz. <xref linkend="glibc-Duplicating-Descriptors"/>.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm><varname>F_GETFD</varname></glossterm>
     <glossdef>
      <para>
       Dosya tanıtıcı ile ilgili seçenekleri döndürür. Bkz. <xref linkend="glibc-Descriptor-Flags"/>.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm><varname>F_SETFD</varname></glossterm>
     <glossdef>
      <para>
       Dosya tanıtıcı ile ilgili seçenekleri ayarlar. Bkz. <xref linkend="glibc-Descriptor-Flags"/>.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm><varname>F_GETFL</varname></glossterm>
     <glossdef>
      <para>
       Açık dosya ile ilgili seçenekleri döndürür. Bkz. <xref linkend="glibc-File-Status-Flags"/>.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm><varname>F_SETFL</varname></glossterm>
     <glossdef>
      <para>
       Açık dosya ile ilgili seçenekleri ayarlar. Bkz. <xref linkend="glibc-File-Status-Flags"/>.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm><varname>F_GETLK</varname></glossterm>
     <glossdef>
      <para>
       Bir dosya kilidini sınar. Bkz. <xref linkend="glibc-File-Locks"/>.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm><varname>F_SETLK</varname></glossterm>
     <glossdef>
      <para>
       Bir dosya kilidini oluşturur ya da kaldırır. Bkz. <xref linkend="glibc-File-Locks"/>.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm><varname>F_SETLKW</varname></glossterm>
     <glossdef>
      <para>
       İşlemin tamamlanmasının beklenmesi dışında <command>F_SETLK</command> ile aynıdır. Bkz. <xref linkend="glibc-File-Locks"/>.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm><varname>F_OFD_GETLK</varname></glossterm>
     <glossdef>
      <para>
       Bir açık dosya tanıtıcının kilidini sınar. Bkz. <xref linkend="glibc-Open-File-Description-Locks"/>. Linux'a özgüdür.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm><varname>F_OFD_SETLK</varname></glossterm>
     <glossdef>
      <para>
       Bir açık dosya tanıtıcının kilidini oluşturur veya kaldırır. Bkz. <xref linkend="glibc-Open-File-Description-Locks"/>. Linux'a özgüdür.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm><varname>F_OFD_SETLKW</varname></glossterm>
     <glossdef>
      <para>
       Kilit alınıncaya kadar bekletmesi dışında <varname>F_OFD_SETLK</varname> gibidir. Bkz. <xref linkend="glibc-Open-File-Description-Locks"/>. Linux'a özgüdür.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm><varname>F_GETOWN</varname></glossterm>
     <glossdef>
      <para>
       <varname>SIGIO</varname> sinyallarini alacak süreç ya da süreç grup kimliği ile döner. Bkz. <xref linkend="glibc-Interrupt-Input"/>.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm><varname>F_SETOWN</varname></glossterm>
     <glossdef>
      <para>
       <varname>SIGIO</varname> sinyallarini alacak süreç ya da süreç grup kimliğini tanımlar. Bkz. <xref linkend="glibc-Interrupt-Input"/>.
      </para>
     </glossdef>
    </glossentry>
   </glosslist>
   <para>
    Bu işlev çok evreli yazılımlarda <varname>F_SETLKW</varname> (ve büyük doya sistemindeki benzeri <varname>F_SETLKW64</varname>) ve <varname>F_OFD_SETLKW</varname> komutları için iptal noktasıdır. <code>fcntl</code> çağrısı sırasında evre bazı öz kaynakları (bellek, dosya tanıtıcı, semafor, vb.) tahsis ettiğinde bu sorun ortaya çıkar. Evre tam bu anda bir iptal alırsa tahsis edilen öz kaynaklar yazılım sonlanana kadar tahsisli olarak kalır. Bu tür <code>fcntl</code> çağrılarından kaçınmak için iptal eylemcileri kullanılarak korunulmalıdır.
   </para>
  </csynopsis>
 </chapter>

 <chapter xml:id="glibc-Duplicating-Descriptors">
  <title>Tanıtıcı Kimliklerinin Çoğaltılması</title>
  <titleabbrev>Dosya tanıtıcı kimliklerini çoğullayan <code>fcntl</code> komutları.</titleabbrev>
  <note>
   <para>
    Açık dosya tanıtıcısı (genellikle <function>open</function> çağrısıyla oluşturulan bir açık dosya örneği) ile açık dosya tanıtıcısına atıfta bulunan sayısal bir değer olan açık dosya tanıtıcı kimliği arasında ayrım yapmak önemlidir. <!-- description: tanıtıcı, descriptor: tanıtıcı kimliği -->
   </para>
  </note>
  <para>
   <indexterm linkend="glibc-cp"><primary>dosya tanıtıcılar</primary><secondary>girdi ve çıktının yönlendirilmesi</secondary></indexterm>
   Bir dosya tanıtıcı kimliği <wordasword>çoğullanabilir</wordasword> ya da aynı dosya için başka bir özgün dosya tanıtıcı kimliği edinilebilir. Çoğullanan dosya tanıtıcı kimlikleri aynı dosya konumunu ve aynı <link linkend="glibc-File-Status-Flags">dosya durum seçeneklerini</link> paylaşırken, her birinin kendi <link linkend="glibc-Descriptor-Flags">dosya tanıtıcı kimliği seçenekleri</link> vardır.
  </para>
  <para>
   Bir dosya tanıtıcı kimliğinin çoğaltılmasının ana amacı girdi ve çıktı <wordasword>yönlendirme</wordasword>sidir: bu, bir dosya ya da ardışık süreç dosya tanıtıcı kimliğinin kendisi ile ilgili başka bir dosya tanıtıcı kimliği ile değiştirilmesi demektir.
  </para>
  <para>
   Çoğullama işlemi <function>fcntl</function> işlevinin <varname>F_DUPFD</varname> komutu ile yapılabileceği gibi dosya tanıtıcı kimliklerini çoğullayan <function>dup</function> ve <function>dup2</function> işlevleri ile de yapılabilir.
  </para>
  <para>
   <indexterm linkend="glibc-pg"><primary>unistd.h</primary></indexterm>
   <indexterm linkend="glibc-pg"><primary>fcntl.h</primary></indexterm>
   <function>fcntl</function> işlevi ve seçenekleri &fcntl.h; başlık dosyasında, <function>dup</function> ve <function>dup2</function> işlevleri ise &unistd.h; başlık dosyasında bildirilmiştir.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-dup"><primary>dup</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-dup"><primary>dosya tanıtıcılar</primary><secondary>çoğullanması</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>dup</function></csname>
    <csparam><type>int</type><parameter>old</parameter></csparam>
   </csproto>
   <header>&unistd.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    Bu işlev <parameter>old</parameter> dosya tanıtıcı kimliğini kullanılabilir (o an açık olmayan) ilk dosya tanıtıcı kimliğine kopyalar. Bu işlem <code>fcntl (<parameter>old</parameter>, F_DUPFD, 0)</code> çağrısına eşdeğerdir.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-dup2"><primary>dup2</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-dup2"><primary>dosya tanıtıcılar</primary><secondary>kopyalanması</secondary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>dup2</function></csname>
    <csparam><type>int</type><parameter>eski</parameter></csparam>
    <csparam><type>int</type><parameter>yeni</parameter></csparam>
   </csproto>
   <header>&unistd.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    Bu işlev <parameter>eski</parameter> dosya tanıtıcı kimliğini <parameter>yeni</parameter> dosya tanıtıcı kimliğine kopyalar.
   </para>
   <para>
    <parameter>eski</parameter> geçersiz bir tanıtıcı kimliği ise <code>dup2</code> hiçbir şey yapmaz ve <parameter>yeni</parameter> kimlik kapatılmaz.  Aksi takdirde, <parameter>eski</parameter> kimlik, zaten bir tanıtıcı kimliği olan <parameter>yeni</parameter> kimlik kapatıldıktan sonra <parameter>yeni</parameter> kimliğe kopyalanır.
   </para>
   <para>
    <parameter>eski</parameter> ve <parameter>yeni</parameter> farklı numaralarsa ve <parameter>eski</parameter> geçerli bir tanıtıcı kimliği ise, <code>dup2</code> şu koda eşdeğerdir:
   </para>
   <literallayout class="monospaced"><code>close (<parameter>yeni</parameter>);
     fcntl (<parameter>eski</parameter>, F_DUPFD, <parameter>yeni</parameter>)</code>
</literallayout>
   <para>
    Bununla birlikte, <code>dup2</code> bunu bölünmez bir işlem olarak yapar; <code>dup2</code> çağrısının ortasında <parameter>yeni</parameter> kimliğinin kapatıldığı halde <parameter>eski</parameter> kimliğinin kopyasının henüz yapılmadığı bir an yoktur.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-vr" xml:id="glibc-vr-F_DUPFD"><primary>F_DUPFD</primary></indexterm>
   <csproto type="makro">
    <csname><type>int</type><function>F_DUPFD</function></csname>
   </csproto>
   <header>&fcntl.h;</header>
   <para>
    Bu makro <function>fcntl</function> işlevinin <parameter>command</parameter> bağımsız değişkeninde kullanıldığında işlevin ilk bağımsız değişkeninde belirtilen dosya tanıtıcı kimliğini kopyalar.
   </para>
   <para>
    Bu çağrı şöyle yapılır:
   </para>
   <literallayout class="monospaced"><code>fcntl (<replaceable>eski_kimlik</replaceable>, F_DUPFD, <replaceable>sonraki_kimlik</replaceable>)</code>
</literallayout>
   <para>
    <replaceable>sonraki_kimlik</replaceable> bağımsız değişkeni <type>int</type> türünde olmalı ve döndürülecek dosya tanıtıcı kimliği bu değerde ya da bu değerden büyük kullanılabilir ilk dosya tanıtıcı kimliği olacak şekilde belirtilmelidir.
   </para>
   <para>
    Böyle bir <function>fcntl</function> çağrısının normal dönüş değeri yeni dosya tanıtıcı kimliğinin değeridir. Dönüş değeri <code>-1</code> ise bu bir hata oluştuğunu gösterir. Aşağıdaki <varname>errno</varname> hata durumları bu komut için tanımlanmıştır:
   </para>
   <variablelist>
    <varlistentry>
     <term><code>EBADF</code></term>
     <listitem>
      <para>
       <parameter>eski_kimlik</parameter> geçersiz.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>EINVAL</code></term>
     <listitem>
      <para>
       <parameter>sonraki_kimlik</parameter> geçersiz.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>EMFILE</code></term>
     <listitem>
      <para>
       Kullanılabilir başka tanıtıcı yok--yazılımınız olanı zaten kullanmış. BSD ve GNU'da bu değerin alabileceği azami değeri belirten öz kaynak sınırı değiştirilebilir; <varname>RLIMIT_NOFILE</varname> sınırı hakkında daha ayrıntılı bilgi için bkz. <xref linkend="glibc-Limits-on-Resources"/>.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    <varname>ENFILE</varname> hata durumu <function>dup2</function> işlevinde oluşmaz çünkü <function>dup2</function> kimliği yeni bir dosya açılışı olarak oluşturmaz, mevcut birini kapattıktan sonra ona kopyalama yapar.
   </para>
  </csynopsis>
  <example>
   <para>
    Bu örnekte yönlendirme için <function>dup2</function> işlevinin nasıl kullanıldığı gösterilmiştir. Genellikle, standart akımların (<varname>stdin</varname> gibi) yönlendirilmesi kabuk tarafından ya da kabuk benzeri bir yazılım tarafından yeni bir yazılımın ya da bir alt sürecin <link linkend="glibc-Executing-a-File">çalıştırılması</link> için bir <function>exec</function> çağrısı yapılmadan önce yapılır. Yeni bir yazılım çalıştırıldığında, <code>main</code> işlevi çalıştırılmadan önce, standart akımlar kendileriyle ilgili dosya tanıtıcı kimlikleriyle oluşturulur ve ilklendirilir.
   </para>
   <para>
    Standart girdinin bir dosyaya yönlendirilmesi kabuk tarafından şöyle yapılabilirdi:
   </para>
   <screen>pid = fork ();
if (pid == 0)
  {
    char *filename;
    char *program;
    int file;
    …
    file = TEMP_FAILURE_RETRY (open (filename, O_RDONLY));
    dup2 (file, STDIN_FILENO);
    TEMP_FAILURE_RETRY (close (file));
    execv (program, NULL);
  }
</screen>
  </example>
  <para>
   <xref linkend="glibc-Launching-Jobs"/> bölümünde, süreçlerin ardışık süreçler bağlamında yönlendirilmesinin gerçekleştirildiği daha ayrıntılı bir örnek vardır.
  </para>
 </chapter>

 <chapter xml:id="glibc-Descriptor-Flags">
  <title>Dosya Tanıtıcı Kimliği Seçenekleri</title>
  <titleabbrev>Dosya tanıtıcı kimlikleri ilgili seçenekleri değiştiren <code>fcntl</code> komutları.</titleabbrev>
  <para>
   <indexterm linkend="glibc-cp"><primary>dosya tanıtıcı kimlikleri</primary><secondary>seçenekler</secondary></indexterm>
   <firstterm>Dosya tanıtıcı kimliği seçenekleri</firstterm> bir dosya tanıtıcı kimliğinin çeşitli öznitelikleridir. Bu seçenekler her dosya tanıtıcı kimliği için özeldir, yani tek bir dosya için bir dosya tanıtıcı kimliği kopyalanarak çoğaltılsa bile yeni dosya tanıtıcı kimliğinin seçeneklerinde yapılacak değişiklik özgün kimliği etkilemeyecektir.
  </para>
  <para>
   Şimdilik tek bir dosya tanıtıcı kimliği seçeneği vardır: <varname>FD_CLOEXEC</varname>. Bu seçenek <link linkend="glibc-Executing-a-File"><command>exec…</command> işlevleri</link> kullanıldığında tanıtıcı kimliğinin kapanmasına sebep olur.
  </para>
  <para>
   <indexterm linkend="glibc-pg"><primary>fcntl.h</primary></indexterm>
   Bu kısımdaki simgeler &fcntl.h; başlık dosyasında tanımlıdır.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-vr" xml:id="glibc-vr-F_GETFD"><primary>F_GETFD</primary></indexterm>
   <csproto type="makro">
    <csname><type>int</type><function>F_GETFD</function></csname>
   </csproto>
   <header>&fcntl.h;</header>
   <para>
    Bu makro <function>fcntl</function> işlevinin <parameter>command</parameter> bağımsız değişkeninde kullanıldığında <parameter>filedes</parameter> ile ilişkili dosya tanıtıcı kimliği seçeneklerini döndürür.
   </para>
   <para>
    Bu komutun <function>fcntl</function> işlevinden döndürdüğü değer,  seçeneklerin bit seviyesinde VEYA'lanarak yorumlandığı negatif olmayan bir sayıdır (seçenekler dense de şimdilik sadece bir seçenek var).
   </para>
   <para>
    Bir hata oluşmuşsa işlev <code>-1</code> ile döner. Aşağıdaki <varname>errno</varname> hata durumu bu komut için tanımlıdır:
   </para>
   <formalpara><title><code>EBADF</code></title>
    <para>
     <parameter>filedes</parameter> kimliği geçersiz.
    </para>
   </formalpara>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-vr" xml:id="glibc-vr-F_SETFD"><primary>F_SETFD</primary></indexterm>
   <csproto type="makro">
    <csname><type>int</type><function>F_SETFD</function></csname>
   </csproto>
   <header>&fcntl.h;</header>
   <para>
    Bu makro <function>fcntl</function> işlevinin <parameter>command</parameter> bağımsız değişkeninde <parameter>filedes</parameter> ile ilişkili dosya tanıtıcı kimliği seçeneklerini belirlemek için kullanılır. Bu komut yeni seçeneklerin belirtildiği <type>int</type> türünde üçüncü bir bağımsız değişken gerektirir. Böyle bir çağrı şöyle yapılabilir:
   </para>
   <literallayout class="monospaced"><code>fcntl (<parameter>tanıtıcı-kimliği</parameter>, F_SETFD, <parameter>yeni-seçenekler</parameter>)</code>
</literallayout>
   <para>
    Bu komutun <function>fcntl</function> işlevinden döndürdüğü değer hata durumunu belirten <code>-1</code> değeri dışında belirsizdir. Seçenekler ve hata durumları <varname>F_GETFD</varname> komutundakilerle aynıdır.
   </para>
  </csynopsis>
  <para>
   Aşağıdaki makro <function>fcntl</function> işlevinde bir dosya tanıtıcı kimliği seçeneği olarak kullanılmak üzere tanımlanmıştır. Değeri bit maskesi değeri olarak kullanılabilecek bir tamsayı sabittir.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-FD_CLOEXEC"><primary>dosya tanıtıcı kimlikleri</primary><secondary>seçenekler</secondary><tertiary>close-on-exec</tertiary></indexterm>
   <indexterm linkend="glibc-vr" xml:id="glibc-vr-FD_CLOEXEC"><primary>FD_CLOEXEC</primary></indexterm>
   <csproto type="makro">
    <csname><type>int</type><function>FD_CLOEXEC</function></csname>
   </csproto>
   <header>&fcntl.h;</header>
   <para>
    Bu seçenek, bir <function>exec</function> işlevi çağrıldığında dosya tanıtıcı kimliğini kapatılacağını belirtmek için kullanılır; bkz. <xref linkend="glibc-Executing-a-File"/>.  Bir dosya tanıtıcı kimiği bir <function>dup</function> işlevi ile tahsis edildiğinde, bu seçenek temizlenir. Böylece <function>exec</function> işlevi ile oluşturulan yeni süreç dosya tanıtıcı kimliğini miras alır.
   </para>
  </csynopsis>
  <para>
   Dosya tanıtıcı kimliği seçenekleri değiştirilmek istenirse, mevcut seçeneklerin <varname>F_GETFD</varname> ile alınıp değerinin değiştirilmesi gerekir. Sadece burada açıklanan seçeneklerin var olduğu gibi bir kabul yapılmamalıdır; yazılım yıllar sonra daha fazla seçeneğin var olduğu bir sistem üzerinde de çalışabilmelidir.
  </para>
  <example>
   <para>
    Aşağıdaki işlev diğer seçeneklere dokunmadan sadece <code>FD_CLOEXEC</code> seçeneği ile çalışır.
   </para>
   <screen>/* <replaceable>desc tanıtıcısına FD_CLOEXEC seçeneği,
  value sıfırdan farklıysa atanır, değilse temizlenir.
  Dönüş değeri hata yoksa 0, varsa -1 olur ve hata errno'ya atanır.</replaceable> */

int
set_cloexec_flag (int desc, int value)
{
  int oldflags = fcntl (desc, F_GETFD, 0);
  /* <replaceable>Seçeneklerin okunması başarısız olursa,
     hata durmunun belirtip hemen dön.</replaceable> */
  if (oldflags &lt; 0)
    return oldflags;
  /* <replaceable>Seçeneğin durumunu belirle.</replaceable> */
  if (value != 0)
    oldflags |= FD_CLOEXEC;
  else
    oldflags &amp;= ~FD_CLOEXEC;
  /* <replaceable>Değiştirilen seçeneği dosya tanıtıcı kimliğne ata.</replaceable> */
  return fcntl (desc, F_SETFD, oldflags);
}
</screen>
  </example>
 </chapter>

 <chapter xml:id="glibc-File-Status-Flags">
  <title>Dosya Durum Seçenekleri</title>
  <titleabbrev>Açık dosyalarla ilgili seçenekleri değiştiren <code>fcntl</code> komutları.</titleabbrev>
  <preliminary>
   <para>
    <indexterm linkend="glibc-cp"><primary>dosya tanıtıcılar</primary><secondary>dosya durum seçenekleri</secondary></indexterm>
    <wordasword>Dosya durum seçenekleri</wordasword> bir açık dosyanın özniteliklerini belirlemekte kullanılır. <xref linkend="glibc-Descriptor-Flags"/> bölümünde açıklanan dosya tanıtıcı kimliği seçeneklerinin aksine, dosya durum seçenekleri tek bir dosya için, çoğullanan dosya tanıtıcı kimlikleri arasında paylaşılır. Dosya durum seçenekleri <function>open</function> işlevinin <parameter>flags</parameter> bağımsız değişkeninde belirtilir; bkz. <xref linkend="glibc-Opening-and-Closing-Files"/>.
   </para>
   <para>
    Dosya durum seçenekleri, her biri ayrı bir bölümde üç sınıf halinde incelenmiştir.
   </para>
   <itemizedlist>
    <listitem>
     <para>
      <xref linkend="glibc-Access-Modes"/> bölümü dosya için izin verilen erişim türü ile ilgilidir: okuma, yazma ve ikisi de.  <function>open</function> ile belirtilebilir, <function>fcntl</function> ile öğrenilebilir ama değiştirilemez.
     </para>
    </listitem>
    <listitem>
     <para>
      <xref linkend="glibc-Open-time-Flags"/> bölümü <function>open</function> işlevinin yaptıklarının denetimi ile ilgili ayrıntıları içerir. Bu seçenekler <function>open</function> çağrısından sonra saklanmaz.
     </para>
    </listitem>
    <listitem>
     <para>
      <xref linkend="glibc-Operating-Modes"/> bölümünde, <function>read</function> ve <function>write</function> işlevlerinin işlemlerini etkileyen seçenekler bulunur. <function>open</function> ile belirtilebilir, <function>fcntl</function> ile öğrenilebilir veya değiştirilebilir.
     </para>
    </listitem>
   </itemizedlist>
   <para>
    Bu kısımdaki simgeler &fcntl.h; başlık dosyasında bildirilmiştir.
    <indexterm linkend="glibc-pg"><primary>fcntl.h</primary></indexterm>
   </para>
  </preliminary>
  <sect1 xml:id="glibc-Access-Modes">
   <title>Dosya Erişim Kipleri</title>
   <titleabbrev>Tanıtıcının okuyup yazabilmesi.</titleabbrev>
   <para>
    Erişim kipleri bir dosya tanıtıcı kimliğine okuma izni, yazma izni veya her iki izni vermek için kullanılır. Erişim kipleri dosya açılırken belirlenir ve bir daha değiştirilemez.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-O_RDONLY"><primary>dosya tanıtıcılar</primary><secondary>okuma izniyle açılması</secondary></indexterm>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-O_RDONLY"><primary>O_RDONLY</primary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>O_RDONLY</function></csname>
    </csproto>
    <header>&fcntl.h;</header>
    <para>
     Dosya okuma erişimi için açılır.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-O_WRONLY"><primary>dosya tanıtıcı kimlikleri</primary><secondary>yazma izniyle açılması</secondary></indexterm>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-O_WRONLY"><primary>O_WRONLY</primary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>O_WRONLY</function></csname>
    </csproto>
    <header>&fcntl.h;</header>
    <para>
     Dosya yazma erişimi için açılır.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-O_RDWR"><primary>dosya tanıtıcı kimlikleri</primary><secondary>oku-yaz izniyle açılması</secondary></indexterm>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-O_RDWR"><primary>O_RDWR</primary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>O_RDWR</function></csname>
    </csproto>
    <header>&fcntl.h;</header>
    <para>
     Dosya hem okuma hem de yazma erişimi için açılır.
    </para>
   </csynopsis>
   <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-O_PATH"><primary>O_PATH</primary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>O_PATH</function></csname>
    </csproto>
    <header>&fcntl.h;</header>
    <para>
     Dosya için bir dosya tanıtıcı kimliği edinilir, ancak dosya okumak veya yazmak için açılmaz. Dosya açıldığında dosyanın kendisi için izin denetimleri atlanır (ancak dosyayı içeren dizine erişim izni hala gereklidir) ve daha sonra kimlik kullanılırken izinlere bakılır.
    </para>
    <para>
     Örneğin, bu tür tanıtıcı kimlikleri <function>fexecve</function> işleviyle birlikte kullanılabilir (bkz. <xref linkend="glibc-Executing-a-File"/>).
    </para>
    <para>
     Bu erişim kipi Linux'a özgüdür. GNU/Hurd sistemlerinde, açıkça <varname>O_EXEC</varname> kullanmak veya hiçbir erişim kipi belirtmemek mümkündür (aşağıya bakınız).
    </para>
   </csynopsis>
   <para>
    Taşınabilir <varname>O_RDONLY</varname>, <varname>O_WRONLY</varname> ve <varname>O_RDWR</varname> dosya erişim kipleri ayrı bitlere karşılık gelmeyebilir. Dosya erişim kipini <function>fcntl</function> ile belirlemek için, erişim kipi bitlerinin <varname>O_ACCMODE</varname> maskesi kullanılarak elde edilen dosya durum bayraklarından çıkarılması gerekir.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-O_ACCMODE"><primary>O_ACCMODE</primary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>O_ACCMODE</function></csname>
    </csproto>
    <header>&fcntl.h;</header>
    <para>
     Bu makro, standart dosya erişim kipinin kullanımda olduğu varsayılarak, dosya erişim kipini kurtarmak için dosya durumu bayrak değeriyle bitsel VE'lenebilen bir maskedir.
    </para>
   </csynopsis>
   <para>
    Standart olmayan bir dosya erişim kipi kullanılırsa (<varname>O_PATH</varname> veya <varname>O_EXEC</varname> gibi), <varname>O_ACCMODE</varname> ile maskeleme hatalı sonuçlar verebilir. Bu standart olmayan erişim kipleri, ayrı bitlerle tanımlanır ve doğrudan denetlenmesi gerekir (önce  <varname>O_ACCMODE</varname> ile maskelemeksizin).
   </para>
   <para>
    GNU/Hurd sistemlerinde (başka sistemlerde böyle değildir), <varname>O_RDONLY</varname> ve <varname>O_WRONLY</varname> bitsel VEYA'lanabilen bağımsız değerlerdir, yani <varname>O_RDWR</varname> aslında <code>O_RDONLY|O_WRONLY</code>'dir. Sıfır erişim kipine de izin verilmiştir; bu kipte dosyaya girdi ve çıktı için hiçbir işleme izin verilmez ama <function>fchmod</function> gibi başka işlemlere izin verilir. GNU/Hurd sistemlerinde, "salt-okunur" ve "salt-yazılır" yanlış isimlendirme olarak kabul edildiğinden &fcntl.h; dosyasında dosya erişim kipleri için ek isimler tanımlanmıştır.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-O_READ"><primary>O_READ</primary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>O_READ</function></csname>
    </csproto>
    <header>&fcntl.h;</header>
    <para>
     Dosya okuma erişimi için açılır. <varname>O_RDONLY</varname> ile aynıdır. Yalnız GNU/HURD sistemlerinde tanımlıdır.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-O_WRITE"><primary>O_WRITE</primary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>O_WRITE</function></csname>
    </csproto>
    <header>&fcntl.h;</header>
    <para>
     Dosya yazma erişimi için açılır. <varname>O_WRONLY</varname> ile aynıdır. Yalnız GNU/HURD sistemlerinde tanımlıdır.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-O_EXEC"><primary>O_EXEC</primary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>O_EXEC</function></csname>
    </csproto>
    <header>&fcntl.h;</header>
    <para>
     Dosya çalıştırılmak için açılır. Yalnız GNU/HURD sistemlerinde tanımlıdır.
    </para>
   </csynopsis>
  </sect1>
  <sect1 xml:id="glibc-Open-time-Flags">
   <title>Açış Anı Seçenekleri</title>
   <titleabbrev><code>open</code> ile ilgili ayrıntılar.</titleabbrev>
   <para>
    Açış anı seçenekleri <function>open</function>  işlevinin davranışlarını etkileyen seçeneklerdir. Bu seçenekler dosya açıldıktan sonra saklanmaz. Buna bir istisna, bir G/Ç işlem kipi de olan <varname>O_NONBLOCK</varname> seçeneğidir ki, bu seçenek kaydedilir. <function>open</function> çağrılarının nasıl yapıldığı <xref linkend="glibc-Opening-and-Closing-Files"/> bölümünde anlatılmıştır.
   </para>
   <para>
    Açış anı seçenekleri iki alt gruba ayrılır.
   </para>
   <itemizedlist>
    <listitem>
     <para>
      <firstterm>Dosya ismi dönüşüm seçenekleri</firstterm> <function>open</function> işlevinin dosyayı konumlamada dosya ismini nasıl ele alacağını ve dosyanın oluşturulabilir olup olmadığını etkiler.
      <indexterm linkend="glibc-cp"><primary>dosya ismi dönüşüm seçenekleri</primary></indexterm>
      <indexterm linkend="glibc-cp"><primary>dosyalar</primary><secondary>seçenekler</secondary><tertiary>dosya ismi dönüşümü</tertiary></indexterm>
     </para>
    </listitem>
    <listitem>
     <para>
      <firstterm>Açış anı eylem seçenekleri</firstterm> <function>open</function> işlevinin dosyanın açılışı anında yapacağı ek işlemleri belirler.
      <indexterm linkend="glibc-cp"><primary>açış anı eylem seçenekleri</primary></indexterm>
      <indexterm linkend="glibc-cp"><primary>dosyalar</primary><secondary>seçenekler</secondary><tertiary>açış anı eylemleri</tertiary></indexterm>
     </para>
    </listitem>
   </itemizedlist>
   <para>
    Dosya ismi dönüşüm seçenekleri şunlardır:
   </para>
   <csynopsis>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-O_CREAT"><primary>dosyalar</primary><secondary>açarken oluşturma</secondary></indexterm>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-O_CREAT"><primary>O_CREAT</primary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>O_CREAT</function></csname>
    </csproto>
    <header>&fcntl.h;</header>
    <para>
     Bu bit varsa ve dosya mevcut değilse oluşturulur.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-O_EXCL"><primary>O_EXCL</primary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>O_EXCL</function></csname>
    </csproto>
    <header>&fcntl.h;</header>
    <para>
     Hem <varname>O_CREAT</varname> hem de <code>O_EXCL</code> bitleri varsa ve belirtilen dosya mevcutsa <function>open</function> başarısız olur. Bu mevcut bir dosyanın fütursuzca üzerine yazılmasını engellemeyi garanti eder.
    </para>
    <para>
     <code>O_EXCL</code> seçeneğinin, <varname>O_TMPFILE</varname> ile birlikte özel bir anlamı vardır; bkz. <varname>O_TMPFILE</varname>.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-O_DIRECTORY"><primary>O_DIRECTORY</primary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>O_DIRECTORY</function></csname>
    </csproto>
    <header>&fcntl.h;</header>
    <para>
     Bu bit varsa, verilen ad bir dizinin adı değilse açma işlemi başarısız olur. Bu hata durumu için <varname>errno</varname> değişkenine <varname>ENOTDIR</varname> atanır.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-O_NOFOLLOW"><primary>O_NOFOLLOW</primary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>O_NOFOLLOW</function></csname>
    </csproto>
    <header>&fcntl.h;</header>
    <para>
     Bu bit varsa, dosya isminin son bileşeni simgesel bağ ise açma işlemi başarısız olur. Bu hata durumu için <varname>errno</varname> değişkenine <varname>ELOOP</varname> atanır.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-O_TMPFILE"><primary>O_TMPFILE</primary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>O_TMPFILE</function></csname>
    </csproto>
    <header>&fcntl.h;</header>
    <para>
     Bu bit varsa, <function>open</function> işlev ailesindeki işlevler adsız bir geçici dosya oluşturur. Bu durumda, <function>open</function> işlev ailesinin <parameter>filename</parameter> bağımsız değişkeni (bkz. <xref linkend="glibc-Opening-and-Closing-Files"/>), geçici dosyanın oluşturulduğu dizin olarak yorumlanır (böylece dosya için depolama sağlayan dosya sistemi belirlenir). <code>O_TMPFILE</code> seçeneği, <varname>O_WRONLY</varname> veya  <varname>O_RDWR</varname> seçeneği ile birleştirilmeli ve <parameter>mode</parameter> bağımsız değişkeni belirtilmelidir.
    </para>
    <para>
     Geçici dosya daha sonra <function>linkat</function> kullanılarak normal bir dosyaya dönüştürülüp bir ad verilebilir. Bu, belirli dosya özniteliklerine (kip ve genişletilmiş öznitelikler) ve dosya içeriklerine sahip bir dosyanın bölünmez bir işlem olarak oluşturulmasına izin verir. Güvenlik nedeniyle dosyaya bir ad verilmesi istenmiyorsa, <varname>O_EXCL</varname> seçeneği <code>O_TMPFILE</code> ile birlikte belirtilebilir.
    </para>
    <para>
     Tüm çekirdekler bu açma seçeneğini desteklemez. Bu seçenek desteklenmiyorsa, adsız bir geçici dosya oluşturma denemesi <varname>EINVAL</varname> hatası ile başarısız olur. Dosya sistemi <code>O_TMPFILE</code> seçeneğini desteklemiyorsa sonuç bir <varname>EOPNOTSUPP</varname> hatasıdır.
    </para>
    <para>
     <code>O_TMPFILE</code> seçeneği GNU oluşumudur.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-O_NONBLOCK"><primary>O_NONBLOCK</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-O_NONBLOCK"><primary>dosyalar</primary><secondary>beklemeden açma</secondary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>O_NONBLOCK</function></csname>
    </csproto>
    <header>&fcntl.h;</header>
    <para>
     <function>open</function> işlevinin dosyanın açılışı sırasında uzun süre beklememesini sağlar. Bu sadece bazı dosya çeşitlerinde anlamlıdır, genelde seri portlar gibi aygıtlarda kullanışlıdır; bu seçeneğin anlamlı olmadığı dosyalarda zararı olmaz ve yok sayılır. Çoğunlukla bir modeme port açılması modem taşıyıcıyı saptayana kadar engellenir; <code>O_NONBLOCK</code> etkin olduğunda <function>open</function> taşıyıcıyı beklemeden dönecektir.
    </para>
    <para>
     <code>O_NONBLOCK</code> seçeneğinin hem G/Ç işlem kipi hem de bir dosya ismi dönüşüm seçeneği olarak belirtilmesi durumunda <function>open</function> işlevi ayrıca beklemeyen G/Ç kipini de etkin kılacaktır. <function>open</function> işlevinin dosyayı açarken beklemesi ama G/Ç işlemleri için beklemeyen kipi etkinleştirmesi isteniyorsa <function>open</function> işlevi <code>O_NONBLOCK</code> etkin olarak çağrılmalı ve ardından bir <function>fcntl</function> çağrısı ile bu bit temizlenmelidir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-O_NOCTTY"><primary>O_NOCTTY</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-O_NOCTTY"><primary>denetim uçbirimi</primary><secondary>belirtilmesi</secondary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>O_NOCTTY</function></csname>
    </csproto>
    <header>&fcntl.h;</header>
    <para>
     İsimli dosya bir uçbirim aygıtı ise, aygıt sürecin denetim uçbirimi yapılmaz. Denetim uçbiriminin ne anlama geldiği <xref linkend="glibc-Job-Control"/> bölümünde açıklanmıştır.
    </para>
    <para>
     GNU/HURD sistemlerinde ve 4.4 BSD'de, <code>O_NOCTTY</code> sıfırdır ve bir dosya açılışı aygıtı hiçbir zaman denetim uçbirimi yapmaz; taşınabilirlik önemliyse bundan kaçınmak için <code>O_NOCTTY</code> seçeneği kullanılmalıdır.
    </para>
   </csynopsis>
   <para>
    Aşağıdaki dosya ismi dönüşüm seçenekleri sadece GNU/HURD sistemlerinde geçerlidir.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-O_IGNORE_CTTY"><primary>O_IGNORE_CTTY</primary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>O_IGNORE_CTTY</function></csname>
    </csproto>
    <header>&fcntl.h;</header>
    <para>
     Aygıt sürecin denetim uçbirimi olarak belirlenmiş olsa bile isimli dosya sürecin denetim uçbirimi olarak tanınmaz. Yeni dosya tanıtıcı kimliği hiçbir zaman iş denetim sinyallerini içermeyecektir. Bkz. <xref linkend="glibc-Job-Control"/>.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-O_NOLINK"><primary>O_NOLINK</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-O_NOLINK"><primary>simgesel bağlar</primary><secondary>açılması</secondary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>O_NOLINK</function></csname>
    </csproto>
    <header>&fcntl.h;</header>
    <para>
     İsimli dosya bir simgesel bağ ise, bağın hedefindeki dosya değil bağın kendisi açılır. (Yeni dosya tanıtıcı kimliği ile yapılan <function>fstat</function> çağrısı bağın ismiyle yapılacak bir <function>lstat</function> çağrısından dönecek bilgileri döndürececektir.)
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-O_NOTRANS"><primary>O_NOTRANS</primary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>O_NOTRANS</function></csname>
    </csproto>
    <header>&fcntl.h;</header>
    <para>
     İsimli dosya özellikle dönüştürülürse, dönüştürücü çağrılmaz. Dönüştürücü dosyayı göreceğinden sadece açar.
    </para>
   </csynopsis>
   <para>
    Açış anı eylem seçenekleri <function>open</function> işlevine aslında dosyanın açılışı ile ilgili olmayan ek işlemleri belirtmek için kullanılır. Bunun ayrı çağrılarla değil de <function>open</function> işlevinin bir parçası olarak yapılmasının sebebi <function>open</function> işlevinin bu işlemleri bölünmez tek bir işlem olarak yapabilmesidir.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-O_TRUNC"><primary>O_TRUNC</primary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>O_TRUNC</function></csname>
    </csproto>
    <header>&fcntl.h;</header>
    <para>
     Dosyayı sıfır uzunluğa düşürür. Bu seçenek, dizinler veya isimli ardışık süreçler gibi özel dosyalar için değil, yalnızca normal dosyalar için kullanışlıdır. POSIX.1, <code>O_TRUNC</code> kullanmak için dosyanın yazma amacıyla açılmasını gerektirir. BSD ve GNU'da, dosyayı kısaltmak için yazma izni gerekir, ancak yazma erişimi için dosyanın açılması gerekmez.
    </para>
    <para>
     Bu, POSIX.1 tarafından belirtilen tek açış anı eylem seçeneğidir. Dosyanın kısaltılmasının <function>open</function> tarafından yapılmasının iyi bir sebebi yoksa bunu yapmak yerine <function>open</function> çağrısının hemen ardından <function>ftruncate</function> çağrısı yapılabilir. <code>O_TRUNC</code> seçeneği, Unix'te <function>ftruncate</function> tanımlanmadan önce de vardı ve geriye dönük uyumluluk için korunmaktadır.
    </para>
   </csynopsis>
   <para>
    Kalan işlem kipleri BSD oluşumlarıdır. Sadece bazı sistemlerde vardır, diğerlerinde bu makrolar tanımlanmamıştır.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-O_SHLOCK"><primary>O_SHLOCK</primary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>O_SHLOCK</function></csname>
    </csproto>
    <header>&fcntl.h;</header>
    <para>
     <function>flock</function> işlevinin yaptığı gibi dosya üzerinde paylaşımlı bir kilit edinilir. Bkz. <xref linkend="glibc-File-Locks"/>.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-O_EXLOCK"><primary>O_EXLOCK</primary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>O_EXLOCK</function></csname>
    </csproto>
    <header>&fcntl.h;</header>
    <para>
     <function>flock</function> işlevinin yaptığı gibi dosya üzerinde ayrıcalıklı bir kilit edinilir. <varname>O_SHLOCK</varname> seçeneğindeki gibi bölünmez tek bir işlemdir. Bkz. <xref linkend="glibc-File-Locks"/>.
    </para>
   </csynopsis>
  </sect1>
  <sect1 xml:id="glibc-Operating-Modes">
   <title>G/Ç İşlem Kipleri</title>
   <titleabbrev>G/Ç işlemlerini denetleyen özel kipler.</titleabbrev>
   <para>
    İşlem kipleri dosya tanıtıcı kimliğinin girdi ve çıktı işlemlerinde nasıl kullanılacağını belirler. Bu seçenekler <function>open</function> ile belirtilir, <function>fcntl</function> ile okunur ve değiştirilir.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-O_APPEND"><primary>O_APPEND</primary></indexterm>
    <indexterm linkend="glibc-vr" xml:id="glibc-cp-O_APPEND"><primary>dosyalar</primary><secondary>ekleme kipi</secondary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>O_APPEND</function></csname>
    </csproto>
    <header>&fcntl.h;</header>
    <para>
     Bu bit dosyaya ekleme kipini etkin kılar. Bu bit varsa, tüm <function>write</function> işlemleri geçerli dosya konumundan bağımsız olarak veriyi dosyanın sonuna ekleyecektir. Bu bir dosyaya ek yapmanın en güvenilir yoludur. Ekleme kipi, dosyaya yazan başka süreçlerin yaptıklarından etkilenmeksizin daima dosya sonuna veri eklemeyi garanti eder. Bu kip kullanılmadan dosya konumu dosya sonuna ayarlanıp yazılmaya çalışılırsa, hemen öncesinde başka bir sürecin dosyaya yaptığı bir yazma işlemi sonucunda veri dosyanın sonuna değil dosyanın içinde bir yere yazılmış olabilir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-O_NONBLOCK_"><primary>O_NONBLOCK</primary></indexterm>
    <indexterm linkend="glibc-vr" xml:id="glibc-cp-O_NONBLOCK_"><primary>dosyalar</primary><secondary>beklememe kipi</secondary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>O_NONBLOCK</function></csname>
    </csproto>
    <header>&fcntl.h;</header>
    <para>
     Bu bit dosya için beklememe kipini etkin kılar. Bu bit varsa, <function>read</function> işlemlerinde o an bir girdinin mevcut olmaması durumunda işlev veriyi beklemeksizin bir hata durumu ile döner. Benzer şekilde <function>write</function> işlemlerinde çıktı hemen yazılamıyorsa işlev beklemeksizin bir hata durumu ile döner.
    </para>
    <para>
     <code>O_NONBLOCK</code> seçeneğinin hem G/Ç işlem kipi olarak hem de dosya ismi dönüşüm seçeneği olarak etkin olabileceği unutulmamalıdır; bkz. <xref linkend="glibc-Open-time-Flags"/>.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-O_NDELAY"><primary>O_NDELAY</primary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>O_NDELAY</function></csname>
    </csproto>
    <header>&fcntl.h;</header>
    <para>
     Bu, BSD ile uyumluluk adına bulunan <varname>O_NONBLOCK</varname> seçeneğinin atıl takma adıdır. POSIX.1 standardında tanımlanmamıştır.
    </para>
   </csynopsis>
   <para>
    Kalan işlem kipleri GNU ve BSD oluşumlarıdır. Sadece bazı sistemlerde vardır, diğerlerinde bu makrolar tanımlanmamıştır.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-O_ASYNC"><primary>O_ASYNC</primary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>O_ASYNC</function></csname>
    </csproto>
    <header>&fcntl.h;</header>
    <para>
     Bu bit eşzamansız girdi kipini etkin kılar. Bu bit varsa, girdi olduğunda <varname>SIGIO</varname> sinyalleri üretilecektir. Bkz.  <xref linkend="glibc-Interrupt-Input"/>.
    </para>
    <para>
     Eşzamansız girdi kipi BSD oluşumudur.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-O_FSYNC"><primary>O_FSYNC</primary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>O_FSYNC</function></csname>
    </csproto>
    <header>&fcntl.h;</header>
    <para>
     Bu bit eşzamanlı yazma kipini etkin kılar. Bu bit varsa, <function>write</function> çağrısı veri diske yazılmadan dönmeyecektir.
    </para>
    <para>
     Eşzamanlı yazma kipi bir BSD özelliğidir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-O_SYNC"><primary>O_SYNC</primary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>O_SYNC</function></csname>
    </csproto>
    <header>&fcntl.h;</header>
    <para>
     <varname>O_FSYNC</varname> ile aynıdır ve aynı değere sahiptir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-O_NOATIME"><primary>O_NOATIME</primary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>O_NOATIME</function></csname>
    </csproto>
    <header>&fcntl.h;</header>
    <para>
     Bu bit varsa, <function>read</function> çağrısı <link linkend="glibc-File-Times">dosyanın erişim zamanını</link> güncellemeyecektir. Bu kip yedekleme uygulamalarınca kullanılır, böylece yedeklenen dosya işlem sırasında okunmuş sayılmaz. Bu kipi sadece dosyanın sahibi veya süper kullanıcı etkin kılabilir.
    </para>
    <para>
     Bu kip GNU oluşumudur.
    </para>
   </csynopsis>
  </sect1>
  <sect1 xml:id="glibc-Getting-File-Status-Flags">
   <title>Dosya Durum Seçeneklerinin Saptanması</title>
   <titleabbrev>Dosya durum seçeneklerinin öğrenilmesi ve belirlenmesi.</titleabbrev>
   <para>
    Dosya durum seçeneklerini öğrenmek ve belirlemek için <function>fcntl</function> işlevi kullanılır.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-F_GETFL"><primary>F_GETFL</primary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>F_GETFL</function></csname>
    </csproto>
    <header>&fcntl.h;</header>
    <para>
     Bu makro <function>fcntl</function> işlevinin <parameter>command</parameter> bağımsız değişkeninde kullanıldığında <parameter>filedes</parameter> tanıtıcı kimliği ile ilgili açık dosyanın dosya durum seçeneklerini okumak için kullanılır.
    </para>
    <para>
     Bu komutun <function>fcntl</function> işlevinden döndürdüğü değer normalde seçeneklerin bitsel VEYA'lanmasıyla elde edilen negatif olmayan bir değerdir. Dosya erişim kipleri tek bitlik değerler olmadıklarından bu bitlere <varname>O_ACCMODE</varname> makrosu ile elde edilen maske kullanılarak erişilebilir.
    </para>
    <para>
     Bir hata durumunda <function>fcntl</function> <code>-1</code> ile döner. Aşağıdaki  <varname>errno</varname> hata durumu bu komut için tanımlanmıştır:
    </para>
    <formalpara><title><code>EBADF</code></title>
     <para>
      <parameter>filedes</parameter> bağımsız değişkeni geçersiz.
     </para>
    </formalpara>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-F_SETFL"><primary>F_SETFL</primary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>F_SETFL</function></csname>
    </csproto>
    <header>&fcntl.h;</header>
    <para>
     Bu makro <function>fcntl</function> işlevinin <parameter>command</parameter> bağımsız değişkeninde kullanıldığında <parameter>filedes</parameter> tanıtıcı kimliği ile ilgili açık dosyanın dosya durum seçeneklerini belirtmek için kullanılır. Bu komut, yeni seçeneklerin belirtildiği <type>int</type> türünde üçüncü bir bağımsız değişkenin varlığını gerektirir:
    </para>
    <literallayout class="monospaced"><code>fcntl (<parameter>tanıtıcı-kimliği</parameter>, F_SETFL, <parameter>yeni_seçenekler</parameter>)</code>
</literallayout>
    <para>
     Bir dosya tanıtıcının erişim kipi bu komutla değiştirilemez. Dosya tanıtıcısı yazmak ya da okumak için açılmıştır ve artık bu değişmez.
    </para>
    <para>
     Bu komutun <function>fcntl</function> işlevinden döndürdüğü değer hata durumunu belirten <code>-1</code> değeri dışında belirsizdir. Hata durumları  <varname>F_GETFL</varname> komutu ile aynıdır.
    </para>
   </csynopsis>
   <example>
    <para>
     Dosya durum seçenekleri değiştirilmek istenirse önce geçerli seçenekler <varname>F_GETFL</varname> ile alınmalı sonra bu değer değiştirilmelidir. Sadece burada açıklanan seçeneklerin var olduğu gibi bir kabul yapılmamalıdır; yazılımı yıllar sonra daha fazla seçeneğin var olduğu bir sistem üzerinde de çalışabilmelidir. Örneğin, aşağıdaki işlev diğer seçeneklere dokunmadan sadece <varname>O_NONBLOCK</varname> seçeneğini değiştirir:
    </para>
    <screen>/* <replaceable>desc kimliğine O_NONBLOCK seçeneği,
  value sıfırdan farklıysa atanır, değilse temizlenir.
  Dönüş değeri hata yoksa 0, varsa -1 olur
  ve hata errno'ya atanır.</replaceable> */

int
set_nonblock_flag (int desc, int value)
{
  int oldflags = fcntl (desc, F_GETFL, 0);
  /* <replaceable>seçeneklerin okunması başarısız olursa,
     hata durmunun belirtip hemen dön.</replaceable> */
  if (oldflags == -1)
    return -1;
  /* <replaceable>Seçeneğin durumunu belirlenebilir</replaceable> */
  if (value != 0)
    oldflags |= O_NONBLOCK;
  else
    oldflags &amp;= ~O_NONBLOCK;
  /* <replaceable>Değiştirilen seçeneği tanıtıcı kimliğine ata.</replaceable> */
  return fcntl (desc, F_SETFL, oldflags);
}
</screen>
   </example>
  </sect1>
 </chapter>

 <chapter xml:id="glibc-File-Locks">
  <title>Dosya Kilitleri</title>
  <titleabbrev>Dosya kilitleme ile ilgili <code>fcntl</code> komutları.</titleabbrev>
  <para>
   <indexterm linkend="glibc-cp"><primary>dosya kilitleri</primary></indexterm>
   <indexterm linkend="glibc-cp"><primary>dosya kilitleri</primary><secondary>kayıt kilitleme</secondary></indexterm>
   Bu bölümde, süreçle ilişkili kayıt kilitleri açıklanmaktadır. Süreç yerine açık dosya tanıtıcısı ile ilişkilendirilen farklı bir kayıt kilidi türü daha vardır. Bkz. <xref linkend="glibc-Open-File-Description-Locks"/>.
  </para>
  <para>
   Geri kalan <function>fcntl</function> komutları, çok sayıda süreçle işbirliği yapan bir sürecin diğerlerini, bir dosyanın bölümlerine aynı anda hataya açık yollarla erişmesini engellemesini sağlayan kayıt kilitlemeyi desteklemek için kullanılır.
  </para>
  <para>
   <indexterm linkend="glibc-cp"><primary>dosya kilitleri</primary><secondary>ayrıcalıklı kilit</secondary></indexterm>
   <indexterm linkend="glibc-cp"><primary>dosya kilitleri</primary><secondary>yazma kilidi</secondary></indexterm>
   Bir <wordasword>ayrıcalıklı kilit</wordasword> ya da <wordasword>yazma kilidi</wordasword> sürecin dosyanın belli bir parçasına yazma amacıyla ayrıcalıklı erişimini mümkün kılar. Bir yazma kilidi etkinken başka hiçbir süreç dosyanın kilitli bölümünü kilitleyemez.
  </para>
  <para>
   <indexterm linkend="glibc-cp"><primary>dosya kilitleri</primary><secondary>paylaşımlı kilit</secondary></indexterm>
   <indexterm linkend="glibc-cp"><primary>dosya kilitleri</primary><secondary>okuma kilidi</secondary></indexterm>
   Bir <wordasword>paylaşımlı kilit</wordasword> veya <wordasword>okuma kilidi</wordasword> başka hiçbir sürecin dosyanın okuma kilitli parçasında bir yazma kilidi isteği yapamamasını sağlar, ancak okuma kilidi isteği engellenmez.
  </para>
  <para>
   Aslında <function>read</function> ve <function>write</function> işlevleri dosyanın bir yerinde bir kilit var mı, yok mu diye bakmaz. Üzerinde birden çok süreç tarafından işlem yapılan bir dosya için kilit uygulaması yapılmak istenirse, uygun noktalarda kilitleri istemek ve temizlemek için doğrudan <function>fcntl</function> çağrıları yapılması gerekir.
  </para>
  <para>
   Kilitler süreçlerle ilişkilendirilir. Bir süreç belirtilen bir dosyanın her baytı için sadece bir çeşit kilitleme yapabilir. Bir dosya ile ilişkili dosya tanıtıcı kimliklerinden herhangi biri süreç tarafından kapatıldığında, diğer dosya tanıtıcı kimlikleri açık bile olsa, süreçte bu dosya ile ilişkilendirilmiş tüm kilitler iptal edilir.  Benzer şekilde bir süreç sonlandığında da kilitler iptal edilir, ayrıca <function>fork</function> ile <link linkend="glibc-Creating-a-Process">oluşturulan alt süreçler</link> bu kilitleri miras almaz.
  </para>
  <para>
   <indexterm linkend="glibc-pg"><primary>fcntl.h</primary></indexterm>
   Bir kilit oluşturulurken ne çeşit kilidin nerede oluşturulacağını belirtmek için <type>struct&nbsp;flock</type> yapısı kullanılır. Bu veri türü ve kilitlerle ilgili  <function>fcntl</function> makroları &fcntl.h; başlık dosyasında bildirilmiştir.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-tp" xml:id="glibc-tp-flock"><primary sortas="flock">struct&nbsp;flock</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-flock"><primary>dosya kilitleri</primary><secondary>veri türü</secondary></indexterm>
   <csproto type="veri türü">
    <csname><type>struct</type><function>flock</function></csname>
   </csproto>
   <header>&stddef.h;</header>
   <para>
    Bu yapı <function>fcntl</function> işlevi ile bir dosya kilidini yapılandırmakta kullanılır. Şu üyelere sahiptir:
   </para>
   <glosslist>
    <glossentry>
     <glossterm>
      <type>short&nbsp;int&nbsp;</type><structfield>l_type</structfield>
     </glossterm>
     <glossdef>
      <para>
       Kilidin türünü belirtir; <varname>F_RDLCK</varname>, <varname>F_WRLCK</varname> veya <varname>F_UNLCK</varname> makrolarından biri olabilir.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <type>short&nbsp;int&nbsp;</type><structfield>l_whence</structfield>
     </glossterm>
     <glossdef>
      <para>
       <function>fseek</function> veya <function>lseek</function> işlevinin <parameter>whence</parameter> bağımsız değişkeninde kullanıldığı gibi dosya konumunun nereye göre belirlendiğini belirtir. Değeri <varname>SEEK_SET</varname>, <varname>SEEK_CUR</varname> veya <varname>SEEK_END</varname> olabilir.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <type>off_t&nbsp;</type><structfield>l_start</structfield>
     </glossterm>
     <glossdef>
      <para>
       Kilidin uygulanacağı bölümün başlangıcından uzaklığını belirler ve yapının <structfield>l_whence</structfield> üyesinde belirtilen noktaya göre bayt cinsinden ifade edilir.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <type>off_t&nbsp;</type><structfield>l_len</structfield>
     </glossterm>
     <glossdef>
      <para>
       Kilitlenecek bölgenin uzunluğunu belirler. <code>0</code> değerinin özel bir anlamı vardır, bölgenin dosyanın sonuna kadar genişleyebileceğini belirtir.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <type>pid_t&nbsp;</type><structfield>l_pid</structfield>
     </glossterm>
     <glossdef>
      <para>
       Kilidi tutan sürecin <link linkend="glibc-Process-Creation-Concepts">süreç kimliğidir</link>. Bu alan kilidi oluştururken yok sayılır, sadece <function>fcntl</function> işlevinin <varname>F_GETLK</varname> komutu ile yapılan çağrısı ile doldurulur. Çakışan kilit, açık dosya tanıtıcı kilidi ise, bu alana <code>-1</code> atanır. Bkz. <xref linkend="glibc-Open-File-Description-Locks"/>.
      </para>
     </glossdef>
    </glossentry>
   </glosslist>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-vr" xml:id="glibc-vr-F_GETLK"><primary>F_GETLK</primary></indexterm>
   <csproto type="makro">
    <csname><type>int</type><function>F_GETLK</function></csname>
   </csproto>
   <header>&fcntl.h;</header>
   <para>
    Bu makro <function>fcntl</function> işlevinin <parameter>command</parameter> bağımsız değişkeninde kullanılır ve bir kilit hakkında bilgi istendiğini belirtir. Bu komut <function>fcntl</function> işlevinde <code>struct&nbsp;flock&nbsp;*</code> türünde üçüncü bir bağımsız değişken gerektirir:
   </para>
   <literallayout class="monospaced"><code>fcntl (<replaceable>tanıtıcı-kimliği</replaceable>, F_GETLK, <replaceable>kilit_gst</replaceable>)</code>
</literallayout>
   <para>
    <replaceable>kilit_gst</replaceable> bağımsız değişkeni ile belirtilen yerde bir kilit varsa, kilit ile ilgili bilgi *<replaceable>kilit_gst</replaceable>'ye yazılır. Mevcut kilitler, belirtilen yeni kilitle uyumluysa  raporlanmaz. Bu bakımdan, hem okuma hem de yazma ile ilgili kilitleri bulmak için <varname>F_WRLCK</varname> türünde bir kilit, sadece yazma ile ilgili kilitleri bulmak için ise, <varname>F_RDLCK</varname> türünde bir kilit belirtilmelidir.
   </para>
   <para>
    <replaceable>kilit_gst</replaceable> tarafından belirtilen bölgeyi etkileyen birden fazla kilit varsa bunlardan sadece biri raporlanır. <replaceable>kilit_gst</replaceable> yapısının <structfield>l_whence</structfield> üyesine <varname>SEEK_SET</varname> atanır, <structfield>l_start</structfield> ve <structfield>l_len</structfield> üyelerine de kilitli bölgeyi tanımlayan değerler atanır.
   </para>
   <para>
    Bir kilit yoksa, <replaceable>kilit_gst</replaceable> yapısının sadece <structfield>l_type</structfield> üyesine <varname>F_UNLCK</varname> atanır.
   </para>
   <para>
    <function>fcntl</function> işlevinin bu komut ile ilgili dönüş değeri hata oluştuğunu belirten <code>-1</code> değeri dışında belirsizdir. Aşağıdaki <varname>errno</varname> hata durumları bu komut için tanımlanmıştır:
   </para>
   <variablelist>
    <varlistentry>
     <term><code>EBADF</code></term>
     <listitem>
      <para>
       <replaceable>tanıtıcı-kimliği</replaceable> geçersiz.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>EINVAL</code></term>
     <listitem>
      <para>
       Ya <replaceable>kilit_gst</replaceable> bağımsız değişkeni geçerli bir kilit belirtmiyor ya da <replaceable>tanıtıcı-kimliği</replaceable> kilitleri desteklemiyor.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-vr" xml:id="glibc-vr-F_SETLK"><primary>F_SETLK</primary></indexterm>
   <csproto type="makro">
    <csname><type>int</type><function>F_SETLK</function></csname>
   </csproto>
   <header>&fcntl.h;</header>
   <para>
    Bu makro <function>fcntl</function> işlevinin <parameter>command</parameter> bağımsız değişkeninde bir kilit oluşturmak ya da kaldırmak amacıyla kullanır. Bu komut <function>fcntl</function> işlevinde <code>struct&nbsp;flock&nbsp;*</code> türünde  üçüncü bir bağımsız değişken gerektirir:
   </para>
   <literallayout class="monospaced"><code>fcntl (<replaceable>dosya-tanıtıcı</replaceable>, F_SETLK, <replaceable>kilit_gst</replaceable>)</code>
</literallayout>
   <para>
    Süreç dosyanın belirtilen bölgesinde bir kilide sahipse eski kilit yenisiyle değiştirilir. Mevcut kilit <varname>F_UNLCK</varname> türünde bir kilit belirterek kaldırılabilir.
   </para>
   <para>
    Kilit oluşturulamazsa <function>fcntl</function> <code>-1</code> değeriyle döner. Bu işlev başka bir sürecin kilidi bırakması için beklemez.  <function>fcntl</function> işlevi başarılı olduğunda <code>-1</code>'den farklı bir değerle döner.
   </para>
   <para>
    Aşağıdaki <varname>errno</varname> hata durumları bu komut için tanımlanmıştır:
   </para>
   <variablelist>
    <varlistentry>
     <term>
      <glossterm><code>EAGAIN</code></glossterm>
      <glossterm><code>EACCES</code></glossterm>
     </term>
     <listitem>
      <para>
       Dosya üzerindeki başka bir kilit tarafından engellendiğinden kilit oluşturulamıyor. Bazı sistemler bu durumda <varname>EAGAIN</varname> kullanırken başkaları  <varname>EACCES</varname> kullanır; her ikisi için de aynı davranış gerekir. (GNU/Hurd sistemleri daima <varname>EAGAIN</varname> kullanır.)
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>EBADF</code></term>
     <listitem>
      <para>
       <replaceable>tanıtıcı-kimliği</replaceable> bağımsız değişkeni geçersiz; ya okuma erişimi için açılmamış <replaceable>tanıtıcı-kimliği</replaceable> için bir okuma kilidi istenmiş ya da yazma erişimi için açılmamış bir <replaceable>tanıtıcı-kimliği</replaceable> için yazma kilidi istenmiş.
     </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>EINVAL</code></term>
     <listitem>
      <para>
       Ya <replaceable>kilit_gst</replaceable> bağımsız değişkeni geçerli kilit bilgisi içermiyor ya da <replaceable>tanıtıcı-kimliği</replaceable> ile ilişkili dosya, kilitleri desteklemiyor.
     </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>ENOLCK</code></term>
     <listitem>
      <para>
       Sistemde dosya kilidi öz kaynakları tükendi; dosya kilidi istenen yerde zaten fazlasıyla dosya kilidi var.
      </para>
      <para>
       İyi tasarlanmış dosya sistemleri bu hatayı hiç raporlamaz, çünkü dosya kilitleri ile ilgili bir sınır yoktur. Yine de, bir dosya sisteminin ağ üzerinden eriştiği başka bir dosya sistemi bu hatayı verebileceğinden bu hatayı hesaba katmak gerekir.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-vr" xml:id="glibc-vr-F_SETLKW"><primary>F_SETLKW</primary></indexterm>
   <csproto type="makro">
    <csname><type>int</type><function>F_SETLKW</function></csname>
   </csproto>
   <header>&fcntl.h;</header>
   <para>
    Bu makro <function>fcntl</function> işlevinin <parameter>command</parameter> bağımsız değişkeninde bir kilit oluşturmak ya da kaldırmak amacıyla kullanır. <varname>F_SETLK</varname> komutu gibi olmakla birlikte farklı olarak kilidi ayırana ya da kilit serbest kalıncaya kadar süreci bekletir.
  </para>
  <para>
   Bu komut da <varname>F_SETLK</varname> komutu gibi <code>struct&nbsp;flock&nbsp;*</code> türünde bir bağımsız değişken gerektirir.
  </para>
  <para>
   <varname>F_SETLK</varname> komutu için <function>fcntl</function> işlevindeki hata durumlarına ek olarak aşağıdaki hata durumları bu komut için tanımlanmıştır:
  </para>
   <variablelist>
    <varlistentry>
     <term><code>EINTR</code></term>
     <listitem>
      <para>
       İşlev beklerken bir sinyal ile durduruldu. Bkz. <xref linkend="glibc-Interrupted-Primitives"/>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>EDEADLK</code></term>
     <listitem>
      <para>
       Belirtilen bölge başka bir süreç tarafından kilitlenmiş. Ama süreç, başka sürecin kilitlediği bölgeyi kendisi kilitleyene dek bekler, bu da kilit isteğinin sonsuza kadar beklenmesi anlamına gelebilir. Sistem tüm durumlarda bu hatanın saptanmasını garanti etmez ama yine de bu konuda bir uyarı gelme şansı vardır.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </csynopsis>
  <para>
   Aşağıdaki makrolar, <type>struct&nbsp;flock</type> yapısının <code>l_type</code> üyesinde değer olarak kullanılmak üzere tanımlanmıştır. Değerler tam sayı sabitleridir.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-vr" xml:id="glibc-vr-F_RDLCK"><primary>F_RDLCK</primary></indexterm>
   <csproto type="sabit">
    <csname><type>int</type><function>F_RDLCK</function></csname>
   </csproto>
   <header>&fcntl.h;</header>
   <para>
    Bir okuma kilidi (ya da paylaşımlı kilit) belirtir.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-vr" xml:id="glibc-vr-F_WRLCK"><primary>F_WRLCK</primary></indexterm>
   <csproto type="sabit">
    <csname><type>int</type><function>F_WRLCK</function></csname>
   </csproto>
   <header>&fcntl.h;</header>
   <para>
    Bir yazma kilidi (ya da ayrıcalıklı kilit) belirtir.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-vr" xml:id="glibc-vr-F_UNLCK"><primary>F_UNLCK</primary></indexterm>
   <csproto type="sabit">
    <csname><type>int</type><function>F_UNLCK</function></csname>
   </csproto>
   <header>&fcntl.h;</header>
   <para>
    Bölgeden kilidin kaldırılmasını belirtir.
   </para>
  </csynopsis>
  <para>
   Dosya kilitlemenin faydalı olduğu bir duruma örnek olarak, bir yazılımın çok sayıda kullanıcı tarafından aynı anda çalıştırıldığı ve bu süreçlerin durum bilgisini ortak bir dosyaya yazdıkları varsayılabilir. Bu tür bir örnek, oyuncuların aldıkları puanları bir dosyaya kaydeden oyunlar olabilir. Buna başka bir örnek de hesap bilgilerini ve kullanımlarını kaydeden bir yazılım olabilir.
  </para>
  <para>
   Bir yazılımın çok sayıda kopyasının bir dosyaya aynı anda yazması dosya içeriğinin karışmasına sebep olur. Bu çeşit sorunların oluşması, dosyaya yapılacak bir yazma işleminden önce bir yazma kilidi oluştururarak önlenebilir.
  </para>
  <para>
   Yazılımın dosyayı tutarlı bir durumda iken okuması önemliyse bir okuma kilidi kullanılabilir. Bir okuma kilidinin varlığı başka bir sürecin dosyanın bir bölümünü yazmak için kilitlemesini önler.
  </para>
  <para>
   Dosya kilitlerinin bir dosyaya erişiminin denetlenmesinin "isteğe bağlı" bir protokol olduğu unutulmamalıdır. Kilitleme protokolünü kullanmayan başka süreçlerin dosyaya erişimi hala mümkün olacaktır.
  </para>
 </chapter>

 <chapter xml:id="glibc-Open-File-Description-Locks">
  <title>Açık Dosya Tanıtıcı Kilitleri</title>
  <titleabbrev>Açık dosya tanıtıcı kilitlemeyi gerçekleştiren <code>fcntl</code> komutları.</titleabbrev>
  <para>
   Bir süreçle ilişkili kayıt kilitlerinin aksine (bkz. <xref linkend="glibc-File-Locks"/>), açık dosya tanıtıcı kayıt kilitleri, süreçle değil açık  dosya tanıtıcısıyla ilişkilendirilir.
  </para>
  <para>
   Aynı dosya tanıtıcı kimliği aracılığıyla oluşturulmuş açık dosya tanıtıcı kilidine sahip bir bölgeye başka bir açık dosya tanıtıcı kilidi daha uygulamak için <function>fcntl</function> işlevini kullanmak hiçbir zaman kilit çakışmasına neden olmaz.
  </para>
  <para>
   Açık dosya tanıtıcı kilitleri ayrıca, açık dosya tanıtıcı kimliği ile birlikte <varname>CLONE_FILES</varname> ile <function>clone</function> veya <function>fork</function> aracılığıyla oluşturulmuş alt süreçler tarafından da devralınır (bkz. <xref linkend="glibc-Creating-a-Process"/>).
  </para>
  <para>
   Açık dosya tanıtıcısı (genellikle <function>open</function> çağrısıyla oluşturulan bir açık dosya örneği) ile açık dosya tanıtıcısına atıfta bulunan sayısal bir değer olan açık dosya tanıtıcı kimliği arasında ayrım yapmak önemlidir. Burada açıklanan kilitler, açık dosya tanıtıcısı ile değil, açık dosya tanıtıcı kimliği ile ilişkilidir.<!-- description: tanıtıcı, descriptor: tanıtıcı kimliği -->
  </para>
  <para>
   Bir dosya tanıtıcı kimliğinin <function>dup</function> ile kopyalanması (bkz. <xref linkend="glibc-Duplicating-Descriptors"/>) yeni bir açık dosya tanıtıcısı vermez, bunun yerine mevcut bir açık dosya tanıtıcısına başvuruyu kopyalar ve onu yeni bir dosya tanıtıcı kimliğine atar. Bu nedenle, <function>dup</function> tarafından kopyalanan bir dosya tanıtıcı kimliğine atanan açık dosya tanıtıcı kilitleri, aynı açık dosya tanıtıcı kimliğine başvurdukları için özgün tanıtıcı kimliğine atanan açık dosya tanıtıcı kilitleriyle asla çelişmez. İlgili kilidin aralığına ve türüne bağlı olarak, ancak bu durumda özgün kilit <varname>F_OFD_SETLK</varname> veya <varname>F_OFD_SETLKW</varname> komutuyla değiştirilebilir.
  </para>
  <para>
   Açık dosya tanıtıcı kilitleri, aynı süreç tarafından veya aynı açık dosya tanıtıcı kimliği için alınmış olsa bile, her zaman süreçle ilişkili kilitlerle çakışır.
  </para>
  <para>
   Açık dosya tanıtıcı kilitleri bağımsız değişkenlerinde, süreçle ilişkili kilitlerle aynı <type>struct&nbsp;flock</type> yapısını kullanır (bkz. <xref linkend="glibc-File-Locks"/>) ve <parameter>command</parameter> makroları da &fcntl.h; başlık dosyasında bildirilir. Bunları kullanmak için, herhangi bir başlık dosyası eklenmeden önce <varname>_GNU_SOURCE</varname> makrosu tanımlanmalıdır.
  </para>
  <para>
   Süreçle ilişkili kilitlerin aksine, dosya tanıtıcı kilit komutunun bağımsız değişkeninde kullanılan <type>struct&nbsp;flock</type> yapısının <code>l_pid</code> üyesine <code>0</code> değeri atanmalıdır. Ayrıca, bir <varname>F_GETLK</varname> veya <varname>F_OFD_GETLK</varname> isteğinde açık dosya tanıtıcı kilidi hakkında bilgi döndürürken, <type>struct&nbsp;flock</type> yapısının <code>l_pid</code> üyesine, kilidin süreçle ilişkili olmadığını belirtmek için <code>-1</code> atanır.
  </para>
  <para>
   Aynı  <type>struct&nbsp;flock</type> yapısı, bir <varname>F_OFD_GETLK</varname> isteği için kullanıldıktan sonra bir <varname>F_OFD_SETLK</varname> veya <varname>F_OFD_SETLKW</varname> isteği için bağımsız değişken olarak yeniden kullanıldığında,<code>l_pid</code> üyesini incelemek ve <code>0</code> değeri ile sıfırlamak gerekir.
  </para>
  <csynopsis>
  <indexterm linkend="glibc-pg" xml:id="glibc-pg-F_OFD_GETLK"><primary>fcntl.h</primary></indexterm>
   <indexterm linkend="glibc-vr" xml:id="glibc-vr-F_OFD_GETLK"><primary>F_OFD_GETLK</primary></indexterm>
   <csproto type="makro">
    <csname><type>int</type><function>F_OFD_GETLK</function></csname>
   </csproto>
   <header>&fcntl.h;</header>
   <para>
    Bu makro <function>fcntl</function> işlevinin <parameter>command</parameter> bağımsız değişkeninde bir kilit ile ilgili bilgi edinmek amacıyla kullanır. Bu komut <function>fcntl</function> işlevinde <code>struct&nbsp;flock&nbsp;*</code> türünde üçüncü bir bağımsız değişken gerektirir:
   </para>
   <literallayout class="monospaced"><code>fcntl (<replaceable>tanıtıcı-kimliği</replaceable>, F_OFD_GETLK, <replaceable>kilit_gst</replaceable>)</code>
</literallayout>
   <para>
    <replaceable>kilit_gst</replaceable> bağımsız değişkeni ile belirtilen yerde bir kilit varsa, kilit ile ilgili bilgi *<replaceable>kilit_gst</replaceable>'ye yazılır. Mevcut kilitler, belirtilen yeni kilitle uyumluysa  raporlanmaz. Bu bakımdan, hem okuma hem de yazma ile ilgili kilitleri bulmak için <varname>F_WRLCK</varname> türünde bir kilit, sadece yazma ile ilgili kilitleri bulmak için ise, <varname>F_RDLCK</varname> türünde bir kilit belirtilmelidir.
   </para>
   <para>
    <replaceable>kilit_gst</replaceable> tarafından belirtilen bölgeyi etkileyen birden fazla kilit varsa bunlardan sadece biri raporlanır. Bu durumda hangi kilidin döneceği belli olmaz.
   </para>
   <para>
    <replaceable>kilit_gst</replaceable> yapısının <structfield>l_whence</structfield> üyesine <varname>SEEK_SET</varname> atanır, <structfield>l_start</structfield> ve <structfield>l_len</structfield> üyelerine de kilitli bölgeyi tanımlayan değerler atanır.
   </para>
   <para>
    Bir kilit yoksa, <replaceable>kilit_gst</replaceable> yapısının sadece <structfield>l_type</structfield> üyesine <varname>F_UNLCK</varname> atanır.
   </para>
   <para>
    <function>fcntl</function> işlevinin bu komut ile ilgili dönüş değeri hata oluştuğunu belirten <code>-1</code> değeri dışında belirsizdir. Aşağıdaki <varname>errno</varname> hata durumları bu komut için tanımlanmıştır:
   </para>
   <variablelist>
    <varlistentry>
     <term><code>EBADF</code></term>
     <listitem>
      <para>
       <replaceable>tanıtıcı-kimliği</replaceable> geçersiz.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>EINVAL</code></term>
     <listitem>
      <para>
       Ya <replaceable>kilit_gst</replaceable> bağımsız değişkeni geçerli bir kilit belirtmiyor ya da işletim sistemi çekirdeği açık dosya tanıtıcı kilitlerini desteklemiyor veya <replaceable>tanıtıcı-kimliği</replaceable> ile ilişkili dosya kilitleri desteklemiyor.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-vr" xml:id="glibc-vr-F_OFD_SETLK"><primary>F_OFD_SETLK</primary></indexterm>
   <csproto type="makro">
    <csname><type>int</type><function>F_OFD_SETLK</function></csname>
   </csproto>
   <header>&fcntl.h;</header>
   <para>
    Bu makro <function>fcntl</function> işlevinin <parameter>command</parameter> bağımsız değişkeninde bir kilit ile oluşturulması veya temizlenmesi gerektiğini belirtmek amacıyla kullanır. Bu komut <function>fcntl</function> işlevinde <code>struct&nbsp;flock&nbsp;*</code> türünde üçüncü bir bağımsız değişken gerektirir:
   </para>
   <literallayout class="monospaced"><code>fcntl (<replaceable>tanıtıcı-kimliği</replaceable>, F_OFD_SETLK, <replaceable>kilit_gst</replaceable>)</code>
</literallayout>
   <para>
    Açık dosya belirtilen bölgede bir kilide sahipse eski kilit yenisiyle değiştirilir. Mevcut kilit <varname>F_UNLCK</varname> türünde bir kilit belirterek kaldırılabilir.
   </para>
   <para>
    Kilit oluşturulamazsa <function>fcntl</function> <code>-1</code> değeriyle döner. Bu işlev başka bir sürecin kilidi bırakması için beklemez.  <function>fcntl</function> işlevi başarılı olduğunda <code>0</code> değeriyle döner.
   </para>
   <para>
    Aşağıdaki <varname>errno</varname> hata durumları bu komut için tanımlanmıştır:
   </para>
   <variablelist>
    <varlistentry>
     <term><code>EAGAIN</code></term>
     <listitem>
      <para>
       Dosya üzerindeki başka bir kilit tarafından engellendiğinden kilit oluşturulamıyor.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>EBADF</code></term>
     <listitem>
      <para>
       <replaceable>tanıtıcı-kimliği</replaceable> bağımsız değişkeni geçersiz; ya okuma erişimi için açılmamış <replaceable>tanıtıcı-kimliği</replaceable> için bir okuma kilidi istenmiş ya da yazma erişimi için açılmamış bir <replaceable>tanıtıcı-kimliği</replaceable> için yazma kilidi istenmiş.
     </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>EINVAL</code></term>
     <listitem>
      <para>
       Ya <replaceable>kilit_gst</replaceable> bağımsız değişkeni geçerli kilit bilgisi içermiyor ya da <replaceable>tanıtıcı-kimliği</replaceable> ile ilişkili dosya, kilitleri desteklemiyor.
     </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>ENOLCK</code></term>
     <listitem>
      <para>
       Sistemde dosya kilidi öz kaynakları tükendi; dosya kilidi istenen yerde zaten fazlasıyla dosya kilidi var.
      </para>
      <para>
       İyi tasarlanmış dosya sistemleri bu hatayı hiç raporlamaz, çünkü dosya kilitleri ile ilgili bir sınır yoktur. Yine de, bir dosya sisteminin ağ üzerinden eriştiği başka bir dosya sistemi bu hatayı verebileceğinden bu hatayı hesaba katmak gerekir.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-vr" xml:id="glibc-vr-F_OFD_SETLKW"><primary>F_OFD_SETLKW</primary></indexterm>
   <csproto type="makro">
    <csname><type>int</type><function>F_OFD_SETLKW</function></csname>
   </csproto>
   <header>&fcntl.h;</header>
   <para>
    Bu makro <function>fcntl</function> işlevinin <parameter>command</parameter> bağımsız değişkeninde bir kilit oluşturmak ya da kaldırmak amacıyla kullanır. <varname>F_OFD_SETLK</varname> komutu gibi olmakla birlikte farklı olarak istek tamamlanana kadar süreci bekletir.
   </para>
   <para>
    Bu komut da <varname>F_OFD_SETLK</varname> komutu gibi <code>struct&nbsp;flock&nbsp;*</code> türünde bir bağımsız değişken gerektirir.
   </para>
   <para>
    <varname>F_OFD_SETLK</varname> komutu için <function>fcntl</function> işlevindeki hata durumlarına ek olarak aşağıdaki hata durumları bu komut için tanımlanmıştır:
   </para>
   <variablelist>
    <varlistentry>
     <term><code>EINTR</code></term>
     <listitem>
      <para>
       İşlev beklerken bir sinyal ile durduruldu. Bkz. <xref linkend="glibc-Interrupted-Primitives"/>.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </csynopsis>
  <para>
   Açık dosya tanıtıcı kilitleri, süreçle ilişkili kilitlerle aynı türden durumlarda kullanışlıdır. Ayrıca, kendi açık dosya tanıtıcısını elde etmek için her evrenin <function>open</function> ile kendi dosyasını açmasını sağlayarak, aynı süreç içindeki evreler arasında dosya erişimini eşzamanlamak için kullanılabilir.
  </para>
  <para>
   Açık dosya tanıtıcı kilitleri, yalnızca açık dosya tanıtıcısına atıfta bulunan son dosya tanıtıcı kimliği kapatıldığında özdevinimli olarak serbest kaldığından, bu kilitleme düzeneği, uygulamanın farkında olmadan bir dosyayı açıp kapatan bir kitaplık yordamı nedeniyle kilitlerin yanlışlıkla serbest bırakılma olasılığını önler.
  </para>
  <para>
   Süreçle ilişkili kilitlerde olduğu gibi, açık dosya tanıtıcı kilitleri tavsiye niteliğindedir.
  </para>
 </chapter>

 <chapter xml:id="glibc-Open-File-Description-Locks-Example">
  <title>Açık Dosya Tanıtıcı Kilitleri Örneği</title>
  <titleabbrev>Açık dosya tanıtıcı kilitlemeyi gerçekleştiren <code>fcntl</code> komutları için örnek.</titleabbrev>
  <para>
   Burada, evreli bir yazılımda açık dosya tanıtıcı kilitlerinin kullanımı ile ilgili bir örneğe yer verilmiştir. Bu yazılım süreçle ilişkili kilitler kullandığı takdirde, süreçle ilişkili kilitler süreç içindeki evreler tarafından paylaşıldığı ve bu nedenle bir evre tarafından aynı süreçte başka bir evreyi kilitlemek için kullanılamadığı için veri bozulmasına uğrar.
  </para>
  <para>
   Kısa olması için aşağıdaki yazılımda hata işleme ilgili kod çıkarılmıştır.
  </para>
  <screen>#define _GNU_SOURCE
#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;pthread.h&gt;

#define FILENAME        "/tmp/foo"
#define NUM_THREADS     3
#define ITERATIONS      5

void *
thread_start (void *arg)
{
  int i, fd, len;
  long tid = (long) arg;
  char buf[256];
  struct flock lck = {
    .l_whence = SEEK_SET,
    .l_start = 0,
    .l_len = 1,
  };

  fd = open ("/tmp/foo", O_RDWR | O_CREAT, 0666);

  for (i = 0; i &lt; ITERATIONS; i++)
    {
      lck.l_type = F_WRLCK;
      fcntl (fd, F_OFD_SETLKW, &amp;lck);

      len = sprintf (buf, "%d: tid=%ld fd=%d\n", i, tid, fd);

      lseek (fd, 0, SEEK_END);
      write (fd, buf, len);
      fsync (fd);

      lck.l_type = F_UNLCK;
      fcntl (fd, F_OFD_SETLK, &amp;lck);

      /* <replaceable>kilidi başka evrenin alabilmesi için uyut</replaceable> */
      usleep (1);
    }
  pthread_exit (NULL);
}

int
main (int argc, char **argv)
{
  long i;
  pthread_t threads[NUM_THREADS];

  truncate (FILENAME, 0);

  for (i = 0; i &lt; NUM_THREADS; i++)
    pthread_create (&amp;threads[i], NULL, thread_start, (void *) i);

  pthread_exit (NULL);
  return 0;
}
</screen>
  <para>
   Bu örnek, her biri dosyaya eklenerek beş kez dönen üç evre oluşturur. Dosyaya erişim, açık dosya tanıtıcı kilitleri aracılığıyla dizileştirilir. Yukarıdaki yazılım derlenip çalıştırılırsa, sonunda içinde 15 satır bulunan <filename>/tmp/foo</filename> dosyası elde edilir.
  </para>
  <para>
   Bununla birlikte, <varname>F_OFD_SETLK</varname> ve <varname>F_OFD_SETLKW</varname> komutları süreçle ilişkili kilit eşdeğerleriyle değiştirilirse, kilitleme tamamen aynı süreç bağlamında yapıldığından, kilitleme işlevsiz olur. Bazı evreler diğerlerinin yazdığı verilerin üzerine yazdığından (genelde eksik satırlar olarak kendini gösterir) veri bozulmasına yol açar.
  </para>
 </chapter>

 <chapter xml:id="glibc-Interrupt-Input">
  <title>Sinyallerle Sürülen Girdi</title>
  <titleabbrev>Girdi geldiğinde eşzamansız bir sinyalin alınması.</titleabbrev>
  <para>
   <indexterm linkend="glibc-cp"><primary>dosya tanıtıcılar</primary><secondary>sinyallerle sürülen girdi</secondary></indexterm>
   Bir dosya tanıtıcıda <varname>O_ASYNC</varname> <link linkend="glibc-File-Status-Flags">durum seçeneği</link> etkinse, bu dosya tanıtıcı ile ilgili bir girdi ya da çıktı olasılığı varsa bir  <varname>SIGIO</varname> sinyali gönderilir. Sinyali alacak süreç veya süreç grubu <function>fcntl</function> işlevinde <varname>F_SETOWN</varname> komutu kullanılarak seçilebilir. Dosya tanıtıcısı bir soket ise bu ayrıca, sokete bir <link linkend="glibc-Out-of-Band-Data">band dışı veri</link> geldiğinde alınan <varname>SIGURG</varname> sinyallerinin alıcılarını seçmekte de kullanılır. <varname>SIGURG</varname> sinyali <function>select</function> işlevinin bir "olağan dışı durumu" raporladığı durumlarda gönderilir. Bkz. <xref linkend="glibc-Waiting-for-I-O"/>.)
  </para>
  <para>
   Dosya tanıtıcı bir uçbirim aygıtı ile ilgiliyse <varname>SIGIO</varname> sinyalleri uçbirimin önalan süreç grubuna gönderilir. Bkz. <xref linkend="glibc-Job-Control"/>.
  </para>
  <para>
   <indexterm linkend="glibc-pg"><primary>fcntl.h</primary></indexterm>
   Bu kısımdaki simgeler &fcntl.h; başlık dosyasında tanımlanmıştır.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-vr" xml:id="glibc-vr-F_GETOWN"><primary>F_GETOWN</primary></indexterm>
   <csproto type="makro">
    <csname><type>int</type><function>F_GETOWN</function></csname>
   </csproto>
   <header>&fcntl.h;</header>
   <para>
    Bu makro <function>fcntl</function> işlevinin <parameter>command</parameter> bağımsız değişkeninde <code>SIGIO</code> sinyallerinin gönderildiği süreç veya süreç grubu hakkında bilgi edinmek için kullanılır. (Bir uçbirim için, bu aslında <function>tcgetpgrp</function> kullanılarak alınabilen önalan süreç grubu kimliğidir; bkz. <xref linkend="glibc-Terminal-Access-Functions"/>.)
   </para>
   <para>
    Dönen değer, bir süreç kimliği olarak yorumlanır; negatifse, mutlak değeri süreç grubu kimliğidir.
   </para>
   <para>
    Aşağıdaki <varname>errno</varname> hata durumu bu komut için tanımlanmıştır:
   </para>
   <formalpara><title><code>EBADF</code></title>
    <para>
     <parameter>filedes</parameter> bağımsız değişkeni geçersiz.
    </para>
   </formalpara>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-vr" xml:id="glibc-vr-F_SETOWN"><primary>F_SETOWN</primary></indexterm>
   <csproto type="makro">
    <csname><type>int</type><function>F_SETOWN</function></csname>
   </csproto>
   <header>&fcntl.h;</header>
   <para>
    Bu makro <function>fcntl</function> işlevinin <parameter>command</parameter> bağımsız değişkeninde <varname>SIGIO</varname> sinyallerinin gönderildiği süreç veya süreç grubun oluşturulması gerektiğini belirtmek için kullanılır. Bu komut, <function>fcntl</function> işlevinde <type>pid_t</type> türünde üçüncü bir bağımsız değişken kullanılmasını gerektirir:
   </para>
   <literallayout class="monospaced"><code>fcntl (<replaceable>tanıtıcı-kimliği</replaceable>, F_OFD_SETLK, <replaceable>pid</replaceable>)</code>
</literallayout>
   <para>
    <replaceable>pid</replaceable> bağımsız değişkeni bir süreç kimliği olmalıdır. Ayrıca mutlak değeri bir süreç grup kimliği olan negatif bir sayı da belirtilebilir.
   </para>
   <para>
    Bu komutun <function>fcntl</function> işlevinden döndürdüğü değer bir hata oluşmuşsa <code>-1</code>'dir, aksi takdirde farklı bir değer döner. Aşağıdaki <varname>errno</varname> hata durumları bu komut için tanımlanmıştır:
   </para>
   <variablelist>
    <varlistentry>
     <term><code>EBADF</code></term>
     <listitem>
      <para>
       <replaceable>tanıtıcı-kimliği</replaceable> bağımsız değişkeni geçersiz.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><code>ESRCH</code></term>
     <listitem>
      <para>
       <replaceable>pid</replaceable>'e karşılık bir süreç ya da süreç grubu yok.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </csynopsis>
 </chapter>

 <chapter xml:id="glibc-IOCTLs">
  <title>G/Ç Denetim İşlemleri</title>
  <para>
   <indexterm linkend="glibc-cp"><primary>dosya tanıtıcılar</primary><secondary>G/Ç denetim işlemleri</secondary></indexterm>
   GNU sistemleri birçok farklı aygıt ve nesne üzerindeki çoğu girdi/çıktı işlemini <function>read</function>, <function>write</function> ve <function>lseek</function>  işlevinden oluşan birkaç ilkelle gerçekleştirir. Buna karşın çoğu aygıt bu modelle karşılanamayan birkaç tuhaf işleme ihtiyaç gösterir. Örneğin:
  </para>
  <simplelist>
   <member>
    Bir uçbirimde kullanılan yazı tipinin değişirilmesi.
   </member>
   <member>
    Bir manyetik teybe geri ya da ileri sarmasının söylenmesi. (Bayt artışları ile hareket ettirilemediklerinden <command>lseek</command> uygulanamaz.)
   </member>
   <member>
    Bir diskin sürücüsünden çıkarılması.
   </member>
   <member>
    Bir CD-ROM aygıtındaki ses kaydının çalınması.
   </member>
   <member>
    Bir ağın yönlendirme tablolarının bakımı.
   </member>
  </simplelist>
  <para>
   Bu tür nesnelerin yanında soketler ve uçbirimler<footnote><para>Aslında, uçbirimlere özel işlevler, çoğu platformda G/Ç denetimleri ile gerçeklenir.</para></footnote> gibi nesneler de kendilerine özgü özel işlevlere sahiptir, tüm bu durumlar için işlevler oluşturmak uygun olmazdı.
  </para>
  <para>
   Bu küçük işlemler yerine <firstterm>G/Ç denetimleri</firstterm> olarak bilinen kod numaraları atanır ve  &sys-ioctl.h; başlık dosyasında bildirilmiş olan <function>ioctl</function> işlevi üzerinden bunlar çoğullanır. Kod numaraları farklı başlık dosyalarında tanımlıdır.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-ioctl"><primary>ioctl</primary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>ioctl</function></csname>
    <csparam><type>int</type><parameter>filedes</parameter></csparam>
    <csparam><type>int</type><parameter>command</parameter></csparam>
    <varargs/>
   </csproto>
   <header>&sys-ioctl.h;</header>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <code>ioctl</code> işlevi <parameter>filedes</parameter> üzerinde <parameter>command</parameter> genel G/Ç işlemi komutunu uygular.
   </para>
   <para>
    Genellikle bir yapıya gösterici veya tek bir sayı olarak üçüncü bir bağımsız değişken bulunur. Bu bağımsız değişkenin anlamı, döndürülen değere ve varsa hata kodlarının kullanıldığı komuta bağlıdır. Genellikle başarısızlık durumunda <code>-1</code> döner.
   </para>
  </csynopsis>
 </chapter>
</part>
