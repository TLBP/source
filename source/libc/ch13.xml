<?xml version="1.0" encoding="UTF-8"?>
<!-- ********************************************************************
        glibc/ch13.xml,v2.36, GFDL,LGPL, NBB, 2023
     ******************************************************************** -->
<part xml:id="glibc-Low-Level-I-O">
  <title>Düşük Seviyeli Girdi ve Çıktı</title>
  <titleabbrev>Düşük seviyeli, daha az taşınabilir G/Ç.</titleabbrev>
  <preliminary>
   <para>This chapter describes functions for performing low-level input/output
operations on file descriptors.  These functions include the primitives
for the higher-level I/O functions described in <xref linkend="glibc-I-O-on-Streams"/>, as
well as functions for performing low-level control operations for which
there are no equivalents on streams.
</para>
<para>Stream-level I/O is more flexible and usually more convenient;
therefore, programmers generally use the descriptor-level functions only
when necessary.  These are some of the usual reasons:
</para>
<!--
<ul>
<li> For reading binary files in large chunks.

</li><li> For reading an entire file into core before parsing it.

</li><li> To perform operations other than data transfer, which can only be done
with a descriptor.  (You can use <code>fileno</code> to get the descriptor
corresponding to a stream.)

</li><li> To pass descriptors to a child process.  (The child can create its own
stream to use a descriptor that it inherits, but cannot inherit a stream
directly.)
</li></ul>
-->
</preliminary>
<!--

<ul class="section-toc">
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Opening-and-Closing-Files" accesskey="1">Opening and Closing Files</a></li>
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#I_002fO-Primitives" accesskey="2">Input and Output Primitives</a></li>
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#File-Position-Primitive" accesskey="3">Setting the File Position of a Descriptor</a></li>
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Descriptors-and-Streams" accesskey="4">Descriptors and Streams</a></li>
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Stream_002fDescriptor-Precautions" accesskey="5">Dangers of Mixing Streams and Descriptors</a></li>
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Scatter_002dGather" accesskey="6">Fast Scatter-Gather I/O</a></li>
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Copying-File-Data" accesskey="7">Copying data between two files</a></li>
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Memory_002dmapped-I_002fO" accesskey="8">Memory-mapped I/O</a></li>
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Waiting-for-I_002fO" accesskey="9">Waiting for Input or Output</a></li>
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Synchronizing-I_002fO">Synchronizing I/O operations</a></li>
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Asynchronous-I_002fO">Perform I/O Operations in Parallel</a></li>
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Control-Operations">Control Operations on Files</a></li>
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Duplicating-Descriptors">Duplicating Descriptors</a></li>
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Descriptor-Flags">File Descriptor Flags</a></li>
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#File-Status-Flags">File Status Flags</a></li>
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#File-Locks">File Locks</a></li>
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Open-File-Description-Locks">Open File Description Locks</a></li>
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Open-File-Description-Locks-Example">Open File Description Locks Example</a></li>
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Interrupt-Input">Interrupt-Driven Input</a></li>
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#IOCTLs">Generic I/O Control operations</a></li>
</ul>
<hr>
<sect xml:id="glibc-Opening-and-Closing-Files">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#I_002fO-Primitives" accesskey="n" rel="next">Input and Output Primitives</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Low_002dLevel-I_002fO" accesskey="u" rel="up">Low-Level Input/Output</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Opening-and-Closing-Files-1"></span><h3 class="section">13.1 Opening and Closing Files</title>

<span xml:id="glibc-index-opening-a-file-descriptor"></span>
<span xml:id="glibc-index-closing-a-file-descriptor"></span>
<para>This section describes the primitives for opening and closing files
using file descriptors.  The <code>open</code> and <code>creat</code> functions are
declared in the header file <filename>fcntl.h</filename>, while <code>close</code> is
declared in <filename>unistd.h</filename>.
<span xml:id="glibc-index-unistd_002eh"></span>
<span xml:id="glibc-index-fcntl_002eh-1"></span>
</para>
<dl class="def">
<dt xml:id="glibc-index-open"><span class="category">Function: </span><span><emphasis>int</emphasis> <strong>open</strong> <emphasis>(const char *<var>filename</var>, int <var>flags</var>[, mode_t <var>mode</var>])</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-open" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Safe
| AC-Safe fd
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>The <code>open</code> function creates and returns a new file descriptor for
the file named by <var>filename</var>.  Initially, the file position
indicator for the file is at the beginning of the file.  The argument
<var>mode</var> (see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Permission-Bits">The Mode Bits for Access Permission</a>) is used only when a file is
created, but it doesn’t hurt to supply the argument in any case.
</para>
<para>The <var>flags</var> argument controls how the file is to be opened.  This is
a bit mask; you create the value by the bitwise OR of the appropriate
parameters (using the ‘<filename>|</filename>’ operator in C).
See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#File-Status-Flags">File Status Flags</a>, for the parameters available.
</para>
<para>The normal return value from <code>open</code> is a non-negative integer file
descriptor.  In the case of an error, a value of <em class="math">-1</emphasis> is returned
instead.  In addition to the usual file name errors (see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#File-Name-Errors">File Name Errors</a>), the following <code>errno</code> error conditions are defined
for this function:
</para>
<dl compact="compact">
<dt><span><code>EACCES</code></span></dt>
<dd><para>The file exists but is not readable/writable as requested by the <var>flags</var>
argument, or the file does not exist and the directory is unwritable so
it cannot be created.
</para>
</dd>
<dt><span><code>EEXIST</code></span></dt>
<dd><para>Both <code>O_CREAT</code> and <code>O_EXCL</code> are set, and the named file already
exists.
</para>
</dd>
<dt><span><code>EINTR</code></span></dt>
<dd><para>The <code>open</code> operation was interrupted by a signal.
See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Interrupted-Primitives">Primitives Interrupted by Signals</a>.
</para>
</dd>
<dt><span><code>EISDIR</code></span></dt>
<dd><para>The <var>flags</var> argument specified write access, and the file is a directory.
</para>
</dd>
<dt><span><code>EMFILE</code></span></dt>
<dd><para>The process has too many files open.
The maximum number of file descriptors is controlled by the
<code>RLIMIT_NOFILE</code> resource limit; see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Limits-on-Resources">Limiting Resource Usage</a>.
</para>
</dd>
<dt><span><code>ENFILE</code></span></dt>
<dd><para>The entire system, or perhaps the file system which contains the
directory, cannot support any additional open files at the moment.
(This problem cannot happen on GNU/Hurd systems.)
</para>
</dd>
<dt><span><code>ENOENT</code></span></dt>
<dd><para>The named file does not exist, and <code>O_CREAT</code> is not specified.
</para>
</dd>
<dt><span><code>ENOSPC</code></span></dt>
<dd><para>The directory or file system that would contain the new file cannot be
extended, because there is no disk space left.
</para>
</dd>
<dt><span><code>ENXIO</code></span></dt>
<dd><para><code>O_NONBLOCK</code> and <code>O_WRONLY</code> are both set in the <var>flags</var>
argument, the file named by <var>filename</var> is a FIFO (see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Pipes-and-FIFOs">Pipes and FIFOs</a>), and no process has the file open for reading.
</para>
</dd>
<dt><span><code>EROFS</code></span></dt>
<dd><para>The file resides on a read-only file system and any of <code><span class="nolinebreak">O_WRONLY</span></code>,
<code>O_RDWR</code>, and <code>O_TRUNC</code> are set in the <var>flags</var> argument,
or <code>O_CREAT</code> is set and the file does not already exist.
</para></dd>
</dl>


<para>If on a 32 bit machine the sources are translated with
<code>_FILE_OFFSET_BITS == 64</code> the function <code>open</code> returns a file
descriptor opened in the large file mode which enables the file handling
functions to use files up to 2^63 bytes in size and offset from
-2^63 to 2^63.  This happens transparently for the user
since all of the low-level file handling functions are equally replaced.
</para>
<para>This function is a cancellation point in multi-threaded programs.  This
is a problem if the thread allocates some resources (like memory, file
descriptors, semaphores or whatever) at the time <code>open</code> is
called.  If the thread gets canceled these resources stay allocated
until the program ends.  To avoid this calls to <code>open</code> should be
protected using cancellation handlers.
</para>
<para>The <code>open</code> function is the underlying primitive for the <code>fopen</code>
and <code>freopen</code> functions, that create streams.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-open64"><span class="category">Function: </span><span><emphasis>int</emphasis> <strong>open64</strong> <emphasis>(const char *<var>filename</var>, int <var>flags</var>[, mode_t <var>mode</var>])</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-open64" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Safe
| AC-Safe fd
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>This function is similar to <code>open</code>.  It returns a file descriptor
which can be used to access the file named by <var>filename</var>.  The only
difference is that on 32 bit systems the file is opened in the
large file mode.  I.e., file length and file offsets can exceed 31 bits.
</para>
<para>When the sources are translated with <code>_FILE_OFFSET_BITS == 64</code> this
function is actually available under the name <code>open</code>.  I.e., the
new, extended API using 64 bit file sizes and offsets transparently
replaces the old API.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-creat"><span class="category">Obsolete function: </span><span><emphasis>int</emphasis> <strong>creat</strong> <emphasis>(const char *<var>filename</var>, mode_t <var>mode</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-creat" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Safe
| AC-Safe fd
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>This function is obsolete.  The call:
</para>
<div class="example">
<pre class="example">creat (<var>filename</var>, <var>mode</var>)
</pre></div>

<para>is equivalent to:
</para>
<div class="example">
<pre class="example">open (<var>filename</var>, O_WRONLY | O_CREAT | O_TRUNC, <var>mode</var>)
</pre></div>

<para>If on a 32 bit machine the sources are translated with
<code>_FILE_OFFSET_BITS == 64</code> the function <code>creat</code> returns a file
descriptor opened in the large file mode which enables the file handling
functions to use files up to 2^63 in size and offset from
-2^63 to 2^63.  This happens transparently for the user
since all of the low-level file handling functions are equally replaced.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-creat64"><span class="category">Obsolete function: </span><span><emphasis>int</emphasis> <strong>creat64</strong> <emphasis>(const char *<var>filename</var>, mode_t <var>mode</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-creat64" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Safe
| AC-Safe fd
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>This function is similar to <code>creat</code>.  It returns a file descriptor
which can be used to access the file named by <var>filename</var>.  The only
difference is that on 32 bit systems the file is opened in the
large file mode.  I.e., file length and file offsets can exceed 31 bits.
</para>
<para>To use this file descriptor one must not use the normal operations but
instead the counterparts named <code>*64</code>, e.g., <code>read64</code>.
</para>
<para>When the sources are translated with <code>_FILE_OFFSET_BITS == 64</code> this
function is actually available under the name <code>open</code>.  I.e., the
new, extended API using 64 bit file sizes and offsets transparently
replaces the old API.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-close"><span class="category">Function: </span><span><emphasis>int</emphasis> <strong>close</strong> <emphasis>(int <var>filedes</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-close" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Safe
| AC-Safe fd
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>The function <code>close</code> closes the file descriptor <var>filedes</var>.
Closing a file has the following consequences:
</para>
<ul>
<li> The file descriptor is deallocated.

</li><li> Any record locks owned by the process on the file are unlocked.

</li><li> When all file descriptors associated with a pipe or FIFO have been closed,
any unread data is discarded.
</li></ul>

<para>This function is a cancellation point in multi-threaded programs.  This
is a problem if the thread allocates some resources (like memory, file
descriptors, semaphores or whatever) at the time <code>close</code> is
called.  If the thread gets canceled these resources stay allocated
until the program ends.  To avoid this, calls to <code>close</code> should be
protected using cancellation handlers.
</para>
<para>The normal return value from <code>close</code> is <em class="math">0</emphasis>; a value of <em class="math">-1</emphasis>
is returned in case of failure.  The following <code>errno</code> error
conditions are defined for this function:
</para>
<dl compact="compact">
<dt><span><code>EBADF</code></span></dt>
<dd><para>The <var>filedes</var> argument is not a valid file descriptor.
</para>
</dd>
<dt><span><code>EINTR</code></span></dt>
<dd><para>The <code>close</code> call was interrupted by a signal.
See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Interrupted-Primitives">Primitives Interrupted by Signals</a>.
Here is an example of how to handle <code>EINTR</code> properly:
</para>
<div class="example">
<pre class="example">TEMP_FAILURE_RETRY (close (desc));
</pre></div>

</dd>
<dt><span><code>ENOSPC</code></span></dt>
<dt><span><code>EIO</code></span></dt>
<dt><span><code>EDQUOT</code></span></dt>
<dd><para>When the file is accessed by NFS, these errors from <code>write</code> can sometimes
not be detected until <code>close</code>.  See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#I_002fO-Primitives">Input and Output Primitives</a>, for details
on their meaning.
</para></dd>
</dl>

<para>Please note that there is <emphasis>no</emphasis> separate <code>close64</code> function.
This is not necessary since this function does not determine nor depend
on the mode of the file.  The kernel which performs the <code>close</code>
operation knows which mode the descriptor is used for and can handle
this situation.
</para></dd></dl>

<para>To close a stream, call <code>fclose</code> (see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Closing-Streams">Closing Streams</a>) instead
of trying to close its underlying file descriptor with <code>close</code>.
This flushes any buffered output and updates the stream object to
indicate that it is closed.
</para>
<dl class="def">
<dt xml:id="glibc-index-close_005frange"><span class="category">Function: </span><span><emphasis>int</emphasis> <strong>close_range</strong> <emphasis>(unsigned int <var>lowfd</var>, unsigned int <var>maxfd</var>, int <var>flags</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-close_005frange" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Safe
| AC-Safe fd
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>


<para>The function <code>close_range</code> closes the file descriptor from <var>lowfd</var>
to <var>maxfd</var> (inclusive).  This function is similar to call <code>close</code> in
specified file descriptor range depending on the <var>flags</var>.
</para>
<para>This is function is only supported on recent Linux versions and the GNU C Library
does not provide any fallback (the application will need to handle possible
<code>ENOSYS</code>).
</para>
<para>The <var>flags</var> add options on how the files are closes.  Linux currently
supports:
</para>
<dl compact="compact">
<dt xml:id="glibc-index-CLOSE_005fRANGE_005fUNSHARE"><span><code>CLOSE_RANGE_UNSHARE</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-CLOSE_005fRANGE_005fUNSHARE" class="copiable-anchor"> ¶</a></span></dt>
<dd><para>Unshare the file descriptor table before closing file descriptors.
</para>
</dd>
<dt xml:id="glibc-index-CLOSE_005fRANGE_005fCLOEXEC"><span><code>CLOSE_RANGE_CLOEXEC</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-CLOSE_005fRANGE_005fCLOEXEC" class="copiable-anchor"> ¶</a></span></dt>
<dd><para>Set the <code>FD_CLOEXEC</code> bit instead of closing the file descriptor.
</para></dd>
</dl>

<para>The normal return value from <code>close_range</code> is <em class="math">0</emphasis>; a value
of <em class="math">-1</emphasis> is returned in case of failure.  The following <code>errno</code> error
conditions are defined for this function:
</para>
<dl compact="compact">
<dt><span><code>EINVAL</code></span></dt>
<dd><para>The <var>lowfd</var> value is larger than <var>maxfd</var> or an unsupported <var>flags</var>
is used.
</para>
</dd>
<dt><span><code>ENOMEM</code></span></dt>
<dd><para>Either there is not enough memory for the operation, or the process is
out of address space.  It can only happnes when <code>CLOSE_RANGE_UNSHARED</code>
flag is used.
</para>
</dd>
<dt><span><code>EMFILE</code></span></dt>
<dd><para>The process has too many files open and it can only happens when
<code>CLOSE_RANGE_UNSHARED</code> flag is used.
The maximum number of file descriptors is controlled by the
<code>RLIMIT_NOFILE</code> resource limit; see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Limits-on-Resources">Limiting Resource Usage</a>.
</para>
</dd>
<dt><span><code>ENOSYS</code></span></dt>
<dd><para>The kernel does not implement the required functionality.
</para></dd>
</dl>
</dd></dl>

<dl class="def">
<dt xml:id="glibc-index-closefrom"><span class="category">Function: </span><span><emphasis>void</emphasis> <strong>closefrom</strong> <emphasis>(int <var>lowfd</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-closefrom" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Safe
| AC-Safe fd
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>


<para>The function <code>closefrom</code> closes all file descriptors greater than or equal
to <var>lowfd</var>.  This function is similar to calling
<code>close</code> for all open file descriptors not less than <var>lowfd</var>.
</para>
<para>Already closed file descriptors are ignored.
</para></dd></dl>

<hr>
</div>
<sect xml:id="glibc-I_002fO-Primitives">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#File-Position-Primitive" accesskey="n" rel="next">Setting the File Position of a Descriptor</a>, Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Opening-and-Closing-Files" accesskey="p" rel="prev">Opening and Closing Files</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Low_002dLevel-I_002fO" accesskey="u" rel="up">Low-Level Input/Output</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Input-and-Output-Primitives"></span><h3 class="section">13.2 Input and Output Primitives</title>

<para>This section describes the functions for performing primitive input and
output operations on file descriptors: <code>read</code>, <code>write</code>, and
<code>lseek</code>.  These functions are declared in the header file
<filename>unistd.h</filename>.
<span xml:id="glibc-index-unistd_002eh-1"></span>
</para>
<dl class="def">
<dt xml:id="glibc-index-ssize_005ft"><span class="category">Data Type: </span><span><strong>ssize_t</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-ssize_005ft" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>This data type is used to represent the sizes of blocks that can be
read or written in a single operation.  It is similar to <code>size_t</code>,
but must be a signed type.
</para></dd></dl>

<span xml:id="glibc-index-reading-from-a-file-descriptor"></span>
<dl class="def">
<dt xml:id="glibc-index-read"><span class="category">Function: </span><span><emphasis>ssize_t</emphasis> <strong>read</strong> <emphasis>(int <var>filedes</var>, void *<var>buffer</var>, size_t <var>size</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-read" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Safe
| AC-Safe
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>The <code>read</code> function reads up to <var>size</var> bytes from the file
with descriptor <var>filedes</var>, storing the results in the <var>buffer</var>.
(This is not necessarily a character string, and no terminating null
character is added.)
</para>
<span xml:id="glibc-index-end_002dof_002dfile_002c-on-a-file-descriptor"></span>
<para>The return value is the number of bytes actually read.  This might be
less than <var>size</var>; for example, if there aren’t that many bytes left
in the file or if there aren’t that many bytes immediately available.
The exact behavior depends on what kind of file it is.  Note that
reading less than <var>size</var> bytes is not an error.
</para>
<para>A value of zero indicates end-of-file (except if the value of the
<var>size</var> argument is also zero).  This is not considered an error.
If you keep calling <code>read</code> while at end-of-file, it will keep
returning zero and doing nothing else.
</para>
<para>If <code>read</code> returns at least one character, there is no way you can
tell whether end-of-file was reached.  But if you did reach the end, the
next read will return zero.
</para>
<para>In case of an error, <code>read</code> returns <em class="math">-1</emphasis>.  The following
<code>errno</code> error conditions are defined for this function:
</para>
<dl compact="compact">
<dt><span><code>EAGAIN</code></span></dt>
<dd><para>Normally, when no input is immediately available, <code>read</code> waits for
some input.  But if the <code>O_NONBLOCK</code> flag is set for the file
(see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#File-Status-Flags">File Status Flags</a>), <code>read</code> returns immediately without
reading any data, and reports this error.
</para>
<para><strong>Compatibility Note:</strong> Most versions of BSD Unix use a different
error code for this: <code>EWOULDBLOCK</code>.  In the GNU C Library,
<code>EWOULDBLOCK</code> is an alias for <code>EAGAIN</code>, so it doesn’t matter
which name you use.
</para>
<para>On some systems, reading a large amount of data from a character special
file can also fail with <code>EAGAIN</code> if the kernel cannot find enough
physical memory to lock down the user’s pages.  This is limited to
devices that transfer with direct memory access into the user’s memory,
which means it does not include terminals, since they always use
separate buffers inside the kernel.  This problem never happens on
GNU/Hurd systems.
</para>
<para>Any condition that could result in <code>EAGAIN</code> can instead result in a
successful <code>read</code> which returns fewer bytes than requested.
Calling <code>read</code> again immediately would result in <code>EAGAIN</code>.
</para>
</dd>
<dt><span><code>EBADF</code></span></dt>
<dd><para>The <var>filedes</var> argument is not a valid file descriptor,
or is not open for reading.
</para>
</dd>
<dt><span><code>EINTR</code></span></dt>
<dd><para><code>read</code> was interrupted by a signal while it was waiting for input.
See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Interrupted-Primitives">Primitives Interrupted by Signals</a>.  A signal will not necessarily cause
<code>read</code> to return <code>EINTR</code>; it may instead result in a
successful <code>read</code> which returns fewer bytes than requested.
</para>
</dd>
<dt><span><code>EIO</code></span></dt>
<dd><para>For many devices, and for disk files, this error code indicates
a hardware error.
</para>
<para><code>EIO</code> also occurs when a background process tries to read from the
controlling terminal, and the normal action of stopping the process by
sending it a <code>SIGTTIN</code> signal isn’t working.  This might happen if
the signal is being blocked or ignored, or because the process group is
orphaned.  See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Job-Control">Job Control</a>, for more information about job control,
and <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Signal-Handling">Signal Handling</a>, for information about signals.
</para>
</dd>
<dt><span><code>EINVAL</code></span></dt>
<dd><para>In some systems, when reading from a character or block device, position
and size offsets must be aligned to a particular block size.  This error
indicates that the offsets were not properly aligned.
</para></dd>
</dl>

<para>Please note that there is no function named <code>read64</code>.  This is not
necessary since this function does not directly modify or handle the
possibly wide file offset.  Since the kernel handles this state
internally, the <code>read</code> function can be used for all cases.
</para>
<para>This function is a cancellation point in multi-threaded programs.  This
is a problem if the thread allocates some resources (like memory, file
descriptors, semaphores or whatever) at the time <code>read</code> is
called.  If the thread gets canceled these resources stay allocated
until the program ends.  To avoid this, calls to <code>read</code> should be
protected using cancellation handlers.
</para>
<para>The <code>read</code> function is the underlying primitive for all of the
functions that read from streams, such as <code>fgetc</code>.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-pread"><span class="category">Function: </span><span><emphasis>ssize_t</emphasis> <strong>pread</strong> <emphasis>(int <var>filedes</var>, void *<var>buffer</var>, size_t <var>size</var>, off_t <var>offset</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-pread" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Safe
| AC-Safe
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>The <code>pread</code> function is similar to the <code>read</code> function.  The
first three arguments are identical, and the return values and error
codes also correspond.
</para>
<para>The difference is the fourth argument and its handling.  The data block
is not read from the current position of the file descriptor
<code>filedes</code>.  Instead the data is read from the file starting at
position <var>offset</var>.  The position of the file descriptor itself is
not affected by the operation.  The value is the same as before the call.
</para>
<para>When the source file is compiled with <code>_FILE_OFFSET_BITS == 64</code> the
<code>pread</code> function is in fact <code>pread64</code> and the type
<code>off_t</code> has 64 bits, which makes it possible to handle files up to
2^63 bytes in length.
</para>
<para>The return value of <code>pread</code> describes the number of bytes read.
In the error case it returns <em class="math">-1</emphasis> like <code>read</code> does and the
error codes are also the same, with these additions:
</para>
<dl compact="compact">
<dt><span><code>EINVAL</code></span></dt>
<dd><para>The value given for <var>offset</var> is negative and therefore illegal.
</para>
</dd>
<dt><span><code>ESPIPE</code></span></dt>
<dd><para>The file descriptor <var>filedes</var> is associated with a pipe or a FIFO and
this device does not allow positioning of the file pointer.
</para></dd>
</dl>

<para>The function is an extension defined in the Unix Single Specification
version 2.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-pread64"><span class="category">Function: </span><span><emphasis>ssize_t</emphasis> <strong>pread64</strong> <emphasis>(int <var>filedes</var>, void *<var>buffer</var>, size_t <var>size</var>, off64_t <var>offset</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-pread64" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Safe
| AC-Safe
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>This function is similar to the <code>pread</code> function.  The difference
is that the <var>offset</var> parameter is of type <code>off64_t</code> instead of
<code>off_t</code> which makes it possible on 32 bit machines to address
files larger than 2^31 bytes and up to 2^63 bytes.  The
file descriptor <code>filedes</code> must be opened using <code>open64</code> since
otherwise the large offsets possible with <code>off64_t</code> will lead to
errors with a descriptor in small file mode.
</para>
<para>When the source file is compiled with <code>_FILE_OFFSET_BITS == 64</code> on a
32 bit machine this function is actually available under the name
<code>pread</code> and so transparently replaces the 32 bit interface.
</para></dd></dl>

<span xml:id="glibc-index-writing-to-a-file-descriptor"></span>
<dl class="def">
<dt xml:id="glibc-index-write"><span class="category">Function: </span><span><emphasis>ssize_t</emphasis> <strong>write</strong> <emphasis>(int <var>filedes</var>, const void *<var>buffer</var>, size_t <var>size</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-write" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Safe
| AC-Safe
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>The <code>write</code> function writes up to <var>size</var> bytes from
<var>buffer</var> to the file with descriptor <var>filedes</var>.  The data in
<var>buffer</var> is not necessarily a character string and a null character is
output like any other character.
</para>
<para>The return value is the number of bytes actually written.  This may be
<var>size</var>, but can always be smaller.  Your program should always call
<code>write</code> in a loop, iterating until all the data is written.
</para>
<para>Once <code>write</code> returns, the data is enqueued to be written and can be
read back right away, but it is not necessarily written out to permanent
storage immediately.  You can use <code>fsync</code> when you need to be sure
your data has been permanently stored before continuing.  (It is more
efficient for the system to batch up consecutive writes and do them all
at once when convenient.  Normally they will always be written to disk
within a minute or less.)  Modern systems provide another function
<code>fdatasync</code> which guarantees integrity only for the file data and
is therefore faster.
You can use the <code>O_FSYNC</code> open mode to make <code>write</code> always
store the data to disk before returning; see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Operating-Modes">I/O Operating Modes</a>.
</para>
<para>In the case of an error, <code>write</code> returns <em class="math">-1</emphasis>.  The following
<code>errno</code> error conditions are defined for this function:
</para>
<dl compact="compact">
<dt><span><code>EAGAIN</code></span></dt>
<dd><para>Normally, <code>write</code> blocks until the write operation is complete.
But if the <code>O_NONBLOCK</code> flag is set for the file (see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Control-Operations">Control Operations on Files</a>), it returns immediately without writing any data and
reports this error.  An example of a situation that might cause the
process to block on output is writing to a terminal device that supports
flow control, where output has been suspended by receipt of a STOP
character.
</para>
<para><strong>Compatibility Note:</strong> Most versions of BSD Unix use a different
error code for this: <code>EWOULDBLOCK</code>.  In the GNU C Library,
<code>EWOULDBLOCK</code> is an alias for <code>EAGAIN</code>, so it doesn’t matter
which name you use.
</para>
<para>On some systems, writing a large amount of data from a character special
file can also fail with <code>EAGAIN</code> if the kernel cannot find enough
physical memory to lock down the user’s pages.  This is limited to
devices that transfer with direct memory access into the user’s memory,
which means it does not include terminals, since they always use
separate buffers inside the kernel.  This problem does not arise on
GNU/Hurd systems.
</para>
</dd>
<dt><span><code>EBADF</code></span></dt>
<dd><para>The <var>filedes</var> argument is not a valid file descriptor,
or is not open for writing.
</para>
</dd>
<dt><span><code>EFBIG</code></span></dt>
<dd><para>The size of the file would become larger than the implementation can support.
</para>
</dd>
<dt><span><code>EINTR</code></span></dt>
<dd><para>The <code>write</code> operation was interrupted by a signal while it was
blocked waiting for completion.  A signal will not necessarily cause
<code>write</code> to return <code>EINTR</code>; it may instead result in a
successful <code>write</code> which writes fewer bytes than requested.
See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Interrupted-Primitives">Primitives Interrupted by Signals</a>.
</para>
</dd>
<dt><span><code>EIO</code></span></dt>
<dd><para>For many devices, and for disk files, this error code indicates
a hardware error.
</para>
</dd>
<dt><span><code>ENOSPC</code></span></dt>
<dd><para>The device containing the file is full.
</para>
</dd>
<dt><span><code>EPIPE</code></span></dt>
<dd><para>This error is returned when you try to write to a pipe or FIFO that
isn’t open for reading by any process.  When this happens, a <code>SIGPIPE</code>
signal is also sent to the process; see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Signal-Handling">Signal Handling</a>.
</para>
</dd>
<dt><span><code>EINVAL</code></span></dt>
<dd><para>In some systems, when writing to a character or block device, position
and size offsets must be aligned to a particular block size.  This error
indicates that the offsets were not properly aligned.
</para></dd>
</dl>

<para>Unless you have arranged to prevent <code>EINTR</code> failures, you should
check <code>errno</code> after each failing call to <code>write</code>, and if the
error was <code>EINTR</code>, you should simply repeat the call.
See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Interrupted-Primitives">Primitives Interrupted by Signals</a>.  The easy way to do this is with the
macro <code>TEMP_FAILURE_RETRY</code>, as follows:
</para>
<div class="example">
<pre class="example">nbytes = TEMP_FAILURE_RETRY (write (desc, buffer, count));
</pre></div>

<para>Please note that there is no function named <code>write64</code>.  This is not
necessary since this function does not directly modify or handle the
possibly wide file offset.  Since the kernel handles this state
internally the <code>write</code> function can be used for all cases.
</para>
<para>This function is a cancellation point in multi-threaded programs.  This
is a problem if the thread allocates some resources (like memory, file
descriptors, semaphores or whatever) at the time <code>write</code> is
called.  If the thread gets canceled these resources stay allocated
until the program ends.  To avoid this, calls to <code>write</code> should be
protected using cancellation handlers.
</para>
<para>The <code>write</code> function is the underlying primitive for all of the
functions that write to streams, such as <code>fputc</code>.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-pwrite"><span class="category">Function: </span><span><emphasis>ssize_t</emphasis> <strong>pwrite</strong> <emphasis>(int <var>filedes</var>, const void *<var>buffer</var>, size_t <var>size</var>, off_t <var>offset</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-pwrite" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Safe
| AC-Safe
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>The <code>pwrite</code> function is similar to the <code>write</code> function.  The
first three arguments are identical, and the return values and error codes
also correspond.
</para>
<para>The difference is the fourth argument and its handling.  The data block
is not written to the current position of the file descriptor
<code>filedes</code>.  Instead the data is written to the file starting at
position <var>offset</var>.  The position of the file descriptor itself is
not affected by the operation.  The value is the same as before the call.
</para>
<para>However, on Linux, if a file is opened with <code>O_APPEND</code>,  <code>pwrite</code>
appends data to the end of the file, regardless of the value of
<code>offset</code>.
</para>
<para>When the source file is compiled with <code>_FILE_OFFSET_BITS == 64</code> the
<code>pwrite</code> function is in fact <code>pwrite64</code> and the type
<code>off_t</code> has 64 bits, which makes it possible to handle files up to
2^63 bytes in length.
</para>
<para>The return value of <code>pwrite</code> describes the number of written bytes.
In the error case it returns <em class="math">-1</emphasis> like <code>write</code> does and the
error codes are also the same, with these additions:
</para>
<dl compact="compact">
<dt><span><code>EINVAL</code></span></dt>
<dd><para>The value given for <var>offset</var> is negative and therefore illegal.
</para>
</dd>
<dt><span><code>ESPIPE</code></span></dt>
<dd><para>The file descriptor <var>filedes</var> is associated with a pipe or a FIFO and
this device does not allow positioning of the file pointer.
</para></dd>
</dl>

<para>The function is an extension defined in the Unix Single Specification
version 2.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-pwrite64"><span class="category">Function: </span><span><emphasis>ssize_t</emphasis> <strong>pwrite64</strong> <emphasis>(int <var>filedes</var>, const void *<var>buffer</var>, size_t <var>size</var>, off64_t <var>offset</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-pwrite64" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Safe
| AC-Safe
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>This function is similar to the <code>pwrite</code> function.  The difference
is that the <var>offset</var> parameter is of type <code>off64_t</code> instead of
<code>off_t</code> which makes it possible on 32 bit machines to address
files larger than 2^31 bytes and up to 2^63 bytes.  The
file descriptor <code>filedes</code> must be opened using <code>open64</code> since
otherwise the large offsets possible with <code>off64_t</code> will lead to
errors with a descriptor in small file mode.
</para>
<para>When the source file is compiled using <code>_FILE_OFFSET_BITS == 64</code> on a
32 bit machine this function is actually available under the name
<code>pwrite</code> and so transparently replaces the 32 bit interface.
</para></dd></dl>

<hr>
</div>
<sect xml:id="glibc-File-Position-Primitive">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Descriptors-and-Streams" accesskey="n" rel="next">Descriptors and Streams</a>, Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#I_002fO-Primitives" accesskey="p" rel="prev">Input and Output Primitives</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Low_002dLevel-I_002fO" accesskey="u" rel="up">Low-Level Input/Output</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Setting-the-File-Position-of-a-Descriptor"></span><h3 class="section">13.3 Setting the File Position of a Descriptor</title>

<para>Just as you can set the file position of a stream with <code>fseek</code>, you
can set the file position of a descriptor with <code>lseek</code>.  This
specifies the position in the file for the next <code>read</code> or
<code>write</code> operation.  See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#File-Positioning">File Positioning</a>, for more information
on the file position and what it means.
</para>
<para>To read the current file position value from a descriptor, use
<code>lseek (<var>desc</var>, 0, SEEK_CUR)</code>.
</para>
<span xml:id="glibc-index-file-positioning-on-a-file-descriptor"></span>
<span xml:id="glibc-index-positioning-a-file-descriptor"></span>
<span xml:id="glibc-index-seeking-on-a-file-descriptor"></span>
<dl class="def">
<dt xml:id="glibc-index-lseek"><span class="category">Function: </span><span><emphasis>off_t</emphasis> <strong>lseek</strong> <emphasis>(int <var>filedes</var>, off_t <var>offset</var>, int <var>whence</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-lseek" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Safe
| AC-Safe
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>The <code>lseek</code> function is used to change the file position of the
file with descriptor <var>filedes</var>.
</para>
<para>The <var>whence</var> argument specifies how the <var>offset</var> should be
interpreted, in the same way as for the <code>fseek</code> function, and it must
be one of the symbolic constants <code>SEEK_SET</code>, <code>SEEK_CUR</code>, or
<code>SEEK_END</code>.
</para>
<dl compact="compact">
<dt xml:id="glibc-index-SEEK_005fSET-1"><span><code>SEEK_SET</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-SEEK_005fSET-1" class="copiable-anchor"> ¶</a></span></dt>
<dd><para>Specifies that <var>offset</var> is a count of characters from the beginning
of the file.
</para>
</dd>
<dt xml:id="glibc-index-SEEK_005fCUR-1"><span><code>SEEK_CUR</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-SEEK_005fCUR-1" class="copiable-anchor"> ¶</a></span></dt>
<dd><para>Specifies that <var>offset</var> is a count of characters from the current
file position.  This count may be positive or negative.
</para>
</dd>
<dt xml:id="glibc-index-SEEK_005fEND-1"><span><code>SEEK_END</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-SEEK_005fEND-1" class="copiable-anchor"> ¶</a></span></dt>
<dd><para>Specifies that <var>offset</var> is a count of characters from the end of
the file.  A negative count specifies a position within the current
extent of the file; a positive count specifies a position past the
current end.  If you set the position past the current end, and
actually write data, you will extend the file with zeros up to that
position.
</para></dd>
</dl>

<para>The return value from <code>lseek</code> is normally the resulting file
position, measured in bytes from the beginning of the file.
You can use this feature together with <code>SEEK_CUR</code> to read the
current file position.
</para>
<para>If you want to append to the file, setting the file position to the
current end of file with <code>SEEK_END</code> is not sufficient.  Another
process may write more data after you seek but before you write,
extending the file so the position you write onto clobbers their data.
Instead, use the <code>O_APPEND</code> operating mode; see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Operating-Modes">I/O Operating Modes</a>.
</para>
<para>You can set the file position past the current end of the file.  This
does not by itself make the file longer; <code>lseek</code> never changes the
file.  But subsequent output at that position will extend the file.
Characters between the previous end of file and the new position are
filled with zeros.  Extending the file in this way can create a
“hole”: the blocks of zeros are not actually allocated on disk, so the
file takes up less space than it appears to; it is then called a
“sparse file”.
<span xml:id="glibc-index-sparse-files"></span>
<span xml:id="glibc-index-holes-in-files"></span>
</para>
<para>If the file position cannot be changed, or the operation is in some way
invalid, <code>lseek</code> returns a value of <em class="math">-1</emphasis>.  The following
<code>errno</code> error conditions are defined for this function:
</para>
<dl compact="compact">
<dt><span><code>EBADF</code></span></dt>
<dd><para>The <var>filedes</var> is not a valid file descriptor.
</para>
</dd>
<dt><span><code>EINVAL</code></span></dt>
<dd><para>The <var>whence</var> argument value is not valid, or the resulting
file offset is not valid.  A file offset is invalid.
</para>
</dd>
<dt><span><code>ESPIPE</code></span></dt>
<dd><para>The <var>filedes</var> corresponds to an object that cannot be positioned,
such as a pipe, FIFO or terminal device.  (POSIX.1 specifies this error
only for pipes and FIFOs, but on GNU systems, you always get
<code>ESPIPE</code> if the object is not seekable.)
</para></dd>
</dl>

<para>When the source file is compiled with <code>_FILE_OFFSET_BITS == 64</code> the
<code>lseek</code> function is in fact <code>lseek64</code> and the type
<code>off_t</code> has 64 bits which makes it possible to handle files up to
2^63 bytes in length.
</para>
<para>This function is a cancellation point in multi-threaded programs.  This
is a problem if the thread allocates some resources (like memory, file
descriptors, semaphores or whatever) at the time <code>lseek</code> is
called.  If the thread gets canceled these resources stay allocated
until the program ends.  To avoid this calls to <code>lseek</code> should be
protected using cancellation handlers.
</para>
<para>The <code>lseek</code> function is the underlying primitive for the
<code>fseek</code>, <code>fseeko</code>, <code>ftell</code>, <code>ftello</code> and
<code>rewind</code> functions, which operate on streams instead of file
descriptors.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-lseek64"><span class="category">Function: </span><span><emphasis>off64_t</emphasis> <strong>lseek64</strong> <emphasis>(int <var>filedes</var>, off64_t <var>offset</var>, int <var>whence</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-lseek64" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Safe
| AC-Safe
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>This function is similar to the <code>lseek</code> function.  The difference
is that the <var>offset</var> parameter is of type <code>off64_t</code> instead of
<code>off_t</code> which makes it possible on 32 bit machines to address
files larger than 2^31 bytes and up to 2^63 bytes.  The
file descriptor <code>filedes</code> must be opened using <code>open64</code> since
otherwise the large offsets possible with <code>off64_t</code> will lead to
errors with a descriptor in small file mode.
</para>
<para>When the source file is compiled with <code>_FILE_OFFSET_BITS == 64</code> on a
32 bits machine this function is actually available under the name
<code>lseek</code> and so transparently replaces the 32 bit interface.
</para></dd></dl>

<para>You can have multiple descriptors for the same file if you open the file
more than once, or if you duplicate a descriptor with <code>dup</code>.
Descriptors that come from separate calls to <code>open</code> have independent
file positions; using <code>lseek</code> on one descriptor has no effect on the
other.  For example,
</para>
<div class="example">
<pre class="example">{
  int d1, d2;
  char buf[4];
  d1 = open ("foo", O_RDONLY);
  d2 = open ("foo", O_RDONLY);
  lseek (d1, 1024, SEEK_SET);
  read (d2, buf, 4);
}
</pre></div>

<para>will read the first four characters of the file <filename>foo</filename>.  (The
error-checking code necessary for a real program has been omitted here
for brevity.)
</para>
<para>By contrast, descriptors made by duplication share a common file
position with the original descriptor that was duplicated.  Anything
which alters the file position of one of the duplicates, including
reading or writing data, affects all of them alike.  Thus, for example,
</para>
<div class="example">
<pre class="example">{
  int d1, d2, d3;
  char buf1[4], buf2[4];
  d1 = open ("foo", O_RDONLY);
  d2 = dup (d1);
  d3 = dup (d2);
  lseek (d3, 1024, SEEK_SET);
  read (d1, buf1, 4);
  read (d2, buf2, 4);
}
</pre></div>

<para>will read four characters starting with the 1024’th character of
<filename>foo</filename>, and then four more characters starting with the 1028’th
character.
</para>
<dl class="def">
<dt xml:id="glibc-index-off_005ft"><span class="category">Data Type: </span><span><strong>off_t</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-off_005ft" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>This is a signed integer type used to represent file sizes.  In
the GNU C Library, this type is no narrower than <code>int</code>.
</para>
<para>If the source is compiled with <code>_FILE_OFFSET_BITS == 64</code> this type
is transparently replaced by <code>off64_t</code>.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-off64_005ft"><span class="category">Data Type: </span><span><strong>off64_t</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-off64_005ft" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>This type is used similar to <code>off_t</code>.  The difference is that even
on 32 bit machines, where the <code>off_t</code> type would have 32 bits,
<code>off64_t</code> has 64 bits and so is able to address files up to
2^63 bytes in length.
</para>
<para>When compiling with <code>_FILE_OFFSET_BITS == 64</code> this type is
available under the name <code>off_t</code>.
</para></dd></dl>

<para>These aliases for the ‘<filename>SEEK_…</filename>’ constants exist for the sake
of compatibility with older BSD systems.  They are defined in two
different header files: <filename>fcntl.h</filename> and <filename>sys/file.h</filename>.
</para>
<dl compact="compact">
<dt xml:id="glibc-index-L_005fSET-1"><span><code>L_SET</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-L_005fSET-1" class="copiable-anchor"> ¶</a></span></dt>
<dd><para>An alias for <code>SEEK_SET</code>.
</para>
</dd>
<dt xml:id="glibc-index-L_005fINCR-1"><span><code>L_INCR</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-L_005fINCR-1" class="copiable-anchor"> ¶</a></span></dt>
<dd><para>An alias for <code>SEEK_CUR</code>.
</para>
</dd>
<dt xml:id="glibc-index-L_005fXTND-1"><span><code>L_XTND</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-L_005fXTND-1" class="copiable-anchor"> ¶</a></span></dt>
<dd><para>An alias for <code>SEEK_END</code>.
</para></dd>
</dl>

<hr>
</div>
<sect xml:id="glibc-Descriptors-and-Streams">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Stream_002fDescriptor-Precautions" accesskey="n" rel="next">Dangers of Mixing Streams and Descriptors</a>, Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#File-Position-Primitive" accesskey="p" rel="prev">Setting the File Position of a Descriptor</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Low_002dLevel-I_002fO" accesskey="u" rel="up">Low-Level Input/Output</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Descriptors-and-Streams-1"></span><h3 class="section">13.4 Descriptors and Streams</title>
<span xml:id="glibc-index-streams_002c-and-file-descriptors"></span>
<span xml:id="glibc-index-converting-file-descriptor-to-stream"></span>
<span xml:id="glibc-index-extracting-file-descriptor-from-stream"></span>

<para>Given an open file descriptor, you can create a stream for it with the
<code>fdopen</code> function.  You can get the underlying file descriptor for
an existing stream with the <code>fileno</code> function.  These functions are
declared in the header file <filename>stdio.h</filename>.
<span xml:id="glibc-index-stdio_002eh-15"></span>
</para>
<dl class="def">
<dt xml:id="glibc-index-fdopen"><span class="category">Function: </span><span><emphasis>FILE *</emphasis> <strong>fdopen</strong> <emphasis>(int <var>filedes</var>, const char *<var>opentype</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-fdopen" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Unsafe heap lock
| AC-Unsafe mem lock
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>The <code>fdopen</code> function returns a new stream for the file descriptor
<var>filedes</var>.
</para>
<para>The <var>opentype</var> argument is interpreted in the same way as for the
<code>fopen</code> function (see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Opening-Streams">Opening Streams</a>), except that
the ‘<filename>b</filename>’ option is not permitted; this is because GNU systems make no
distinction between text and binary files.  Also, <code>"w"</code> and
<code>"w+"</code> do not cause truncation of the file; these have an effect only
when opening a file, and in this case the file has already been opened.
You must make sure that the <var>opentype</var> argument matches the actual
mode of the open file descriptor.
</para>
<para>The return value is the new stream.  If the stream cannot be created
(for example, if the modes for the file indicated by the file descriptor
do not permit the access specified by the <var>opentype</var> argument), a
null pointer is returned instead.
</para>
<para>In some other systems, <code>fdopen</code> may fail to detect that the modes
for file descriptors do not permit the access specified by
<code>opentype</code>.  The GNU C Library always checks for this.
</para></dd></dl>

<para>For an example showing the use of the <code>fdopen</code> function,
see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Creating-a-Pipe">Creating a Pipe</a>.
</para>
<dl class="def">
<dt xml:id="glibc-index-fileno"><span class="category">Function: </span><span><emphasis>int</emphasis> <strong>fileno</strong> <emphasis>(FILE *<var>stream</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-fileno" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Safe
| AC-Safe
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>This function returns the file descriptor associated with the stream
<var>stream</var>.  If an error is detected (for example, if the <var>stream</var>
is not valid) or if <var>stream</var> does not do I/O to a file,
<code>fileno</code> returns <em class="math">-1</emphasis>.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-fileno_005funlocked"><span class="category">Function: </span><span><emphasis>int</emphasis> <strong>fileno_unlocked</strong> <emphasis>(FILE *<var>stream</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-fileno_005funlocked" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Safe
| AC-Safe
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>The <code>fileno_unlocked</code> function is equivalent to the <code>fileno</code>
function except that it does not implicitly lock the stream if the state
is <code>FSETLOCKING_INTERNAL</code>.
</para>
<para>This function is a GNU extension.
</para></dd></dl>

<span xml:id="glibc-index-standard-file-descriptors"></span>
<span xml:id="glibc-index-file-descriptors_002c-standard"></span>
<para>There are also symbolic constants defined in <filename>unistd.h</filename> for the
file descriptors belonging to the standard streams <code>stdin</code>,
<code>stdout</code>, and <code>stderr</code>; see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Standard-Streams">Standard Streams</a>.
<span xml:id="glibc-index-unistd_002eh-2"></span>
</para>
<dl compact="compact">
<dt xml:id="glibc-index-STDIN_005fFILENO"><span><code>STDIN_FILENO</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-STDIN_005fFILENO" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>This macro has value <code>0</code>, which is the file descriptor for
standard input.
<span xml:id="glibc-index-standard-input-file-descriptor"></span>
</para>
</dd>
<dt xml:id="glibc-index-STDOUT_005fFILENO"><span><code>STDOUT_FILENO</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-STDOUT_005fFILENO" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>This macro has value <code>1</code>, which is the file descriptor for
standard output.
<span xml:id="glibc-index-standard-output-file-descriptor"></span>
</para>
</dd>
<dt xml:id="glibc-index-STDERR_005fFILENO"><span><code>STDERR_FILENO</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-STDERR_005fFILENO" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>This macro has value <code>2</code>, which is the file descriptor for
standard error output.
</para></dd>
</dl>
<span xml:id="glibc-index-standard-error-file-descriptor"></span>

<hr>
</div>
<sect xml:id="glibc-Stream_002fDescriptor-Precautions">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Scatter_002dGather" accesskey="n" rel="next">Fast Scatter-Gather I/O</a>, Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Descriptors-and-Streams" accesskey="p" rel="prev">Descriptors and Streams</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Low_002dLevel-I_002fO" accesskey="u" rel="up">Low-Level Input/Output</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Dangers-of-Mixing-Streams-and-Descriptors"></span><h3 class="section">13.5 Dangers of Mixing Streams and Descriptors</title>
<span xml:id="glibc-index-channels"></span>
<span xml:id="glibc-index-streams-and-descriptors"></span>
<span xml:id="glibc-index-descriptors-and-streams"></span>
<span xml:id="glibc-index-mixing-descriptors-and-streams"></span>

<para>You can have multiple file descriptors and streams (let’s call both
streams and descriptors “channels” for short) connected to the same
file, but you must take care to avoid confusion between channels.  There
are two cases to consider: <emphasis>linked</emphasis> channels that share a single
file position value, and <emphasis>independent</emphasis> channels that have their own
file positions.
</para>
<para>It’s best to use just one channel in your program for actual data
transfer to any given file, except when all the access is for input.
For example, if you open a pipe (something you can only do at the file
descriptor level), either do all I/O with the descriptor, or construct a
stream from the descriptor with <code>fdopen</code> and then do all I/O with
the stream.
</para>

<ul class="section-toc">
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Linked-Channels" accesskey="1">Linked Channels</a></li>
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Independent-Channels" accesskey="2">Independent Channels</a></li>
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Cleaning-Streams" accesskey="3">Cleaning Streams</a></li>
</ul>
<hr>
<div class="subsection" xml:id="glibc-Linked-Channels">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Independent-Channels" accesskey="n" rel="next">Independent Channels</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Stream_002fDescriptor-Precautions" accesskey="u" rel="up">Dangers of Mixing Streams and Descriptors</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Linked-Channels-1"></span><h4 class="subsection">13.5.1 Linked Channels</title>
<span xml:id="glibc-index-linked-channels"></span>

<para>Channels that come from a single opening share the same file position;
we call them <emphasis>linked</emphasis> channels.  Linked channels result when you
make a stream from a descriptor using <code>fdopen</code>, when you get a
descriptor from a stream with <code>fileno</code>, when you copy a descriptor
with <code>dup</code> or <code>dup2</code>, and when descriptors are inherited
during <code>fork</code>.  For files that don’t support random access, such as
terminals and pipes, <emphasis>all</emphasis> channels are effectively linked.  On
random-access files, all append-type output streams are effectively
linked to each other.
</para>
<span xml:id="glibc-index-cleaning-up-a-stream"></span>
<para>If you have been using a stream for I/O (or have just opened the stream),
and you want to do I/O using
another channel (either a stream or a descriptor) that is linked to it,
you must first <emphasis>clean up</emphasis> the stream that you have been using.
See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Cleaning-Streams">Cleaning Streams</a>.
</para>
<para>Terminating a process, or executing a new program in the process,
destroys all the streams in the process.  If descriptors linked to these
streams persist in other processes, their file positions become
undefined as a result.  To prevent this, you must clean up the streams
before destroying them.
</para>
<hr>
</div>
<div class="subsection" xml:id="glibc-Independent-Channels">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Cleaning-Streams" accesskey="n" rel="next">Cleaning Streams</a>, Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Linked-Channels" accesskey="p" rel="prev">Linked Channels</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Stream_002fDescriptor-Precautions" accesskey="u" rel="up">Dangers of Mixing Streams and Descriptors</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Independent-Channels-1"></span><h4 class="subsection">13.5.2 Independent Channels</title>
<span xml:id="glibc-index-independent-channels"></span>

<para>When you open channels (streams or descriptors) separately on a seekable
file, each channel has its own file position.  These are called
<emphasis>independent channels</emphasis>.
</para>
<para>The system handles each channel independently.  Most of the time, this
is quite predictable and natural (especially for input): each channel
can read or write sequentially at its own place in the file.  However,
if some of the channels are streams, you must take these precautions:
</para>
<ul>
<li> You should clean an output stream after use, before doing anything else
that might read or write from the same part of the file.

</li><li> You should clean an input stream before reading data that may have been
modified using an independent channel.  Otherwise, you might read
obsolete data that had been in the stream’s buffer.
</li></ul>

<para>If you do output to one channel at the end of the file, this will
certainly leave the other independent channels positioned somewhere
before the new end.  You cannot reliably set their file positions to the
new end of file before writing, because the file can always be extended
by another process between when you set the file position and when you
write the data.  Instead, use an append-type descriptor or stream; they
always output at the current end of the file.  In order to make the
end-of-file position accurate, you must clean the output channel you
were using, if it is a stream.
</para>
<para>It’s impossible for two channels to have separate file pointers for a
file that doesn’t support random access.  Thus, channels for reading or
writing such files are always linked, never independent.  Append-type
channels are also always linked.  For these channels, follow the rules
for linked channels; see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Linked-Channels">Linked Channels</a>.
</para>
<hr>
</div>
<div class="subsection" xml:id="glibc-Cleaning-Streams">
<div class="header">
<para>
Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Independent-Channels" accesskey="p" rel="prev">Independent Channels</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Stream_002fDescriptor-Precautions" accesskey="u" rel="up">Dangers of Mixing Streams and Descriptors</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Cleaning-Streams-1"></span><h4 class="subsection">13.5.3 Cleaning Streams</title>

<para>You can use <code>fflush</code> to clean a stream in most
cases.
</para>
<para>You can skip the <code>fflush</code> if you know the stream
is already clean.  A stream is clean whenever its buffer is empty.  For
example, an unbuffered stream is always clean.  An input stream that is
at end-of-file is clean.  A line-buffered stream is clean when the last
character output was a newline.  However, a just-opened input stream
might not be clean, as its input buffer might not be empty.
</para>
<para>There is one case in which cleaning a stream is impossible on most
systems.  This is when the stream is doing input from a file that is not
random-access.  Such streams typically read ahead, and when the file is
not random access, there is no way to give back the excess data already
read.  When an input stream reads from a random-access file,
<code>fflush</code> does clean the stream, but leaves the file pointer at an
unpredictable place; you must set the file pointer before doing any
further I/O.
</para>
<para>Closing an output-only stream also does <code>fflush</code>, so this is a
valid way of cleaning an output stream.
</para>
<para>You need not clean a stream before using its descriptor for control
operations such as setting terminal modes; these operations don’t affect
the file position and are not affected by it.  You can use any
descriptor for these operations, and all channels are affected
simultaneously.  However, text already “output” to a stream but still
buffered by the stream will be subject to the new terminal modes when
subsequently flushed.  To make sure “past” output is covered by the
terminal settings that were in effect at the time, flush the output
streams for that terminal before setting the modes.  See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Terminal-Modes">Terminal Modes</a>.
</para>
<hr>
</div>
</div>
<sect xml:id="glibc-Scatter_002dGather">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Copying-File-Data" accesskey="n" rel="next">Copying data between two files</a>, Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Stream_002fDescriptor-Precautions" accesskey="p" rel="prev">Dangers of Mixing Streams and Descriptors</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Low_002dLevel-I_002fO" accesskey="u" rel="up">Low-Level Input/Output</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Fast-Scatter_002dGather-I_002fO"></span><h3 class="section">13.6 Fast Scatter-Gather I/O</title>
<span xml:id="glibc-index-scatter_002dgather"></span>

<para>Some applications may need to read or write data to multiple buffers,
which are separated in memory.  Although this can be done easily enough
with multiple calls to <code>read</code> and <code>write</code>, it is inefficient
because there is overhead associated with each kernel call.
</para>
<para>Instead, many platforms provide special high-speed primitives to perform
these <emphasis>scatter-gather</emphasis> operations in a single kernel call.  The GNU C Library
will provide an emulation on any system that lacks these
primitives, so they are not a portability threat.  They are defined in
<code>sys/uio.h</code>.
</para>
<para>These functions are controlled with arrays of <code>iovec</code> structures,
which describe the location and size of each buffer.
</para>
<dl class="def">
<dt xml:id="glibc-index-struct-iovec"><span class="category">Data Type: </span><span><strong>struct iovec</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-struct-iovec" class="copiable-anchor"> ¶</a></span></dt>
<dd>

<para>The <code>iovec</code> structure describes a buffer.  It contains two fields:
</para>
<dl compact="compact">
<dt><span><code>void *iov_base</code></span></dt>
<dd><para>Contains the address of a buffer.
</para>
</dd>
<dt><span><code>size_t iov_len</code></span></dt>
<dd><para>Contains the length of the buffer.
</para>
</dd>
</dl>
</dd></dl>

<dl class="def">
<dt xml:id="glibc-index-readv"><span class="category">Function: </span><span><emphasis>ssize_t</emphasis> <strong>readv</strong> <emphasis>(int <var>filedes</var>, const struct iovec *<var>vector</var>, int <var>count</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-readv" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Unsafe heap
| AC-Unsafe mem
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>


<para>The <code>readv</code> function reads data from <var>filedes</var> and scatters it
into the buffers described in <var>vector</var>, which is taken to be
<var>count</var> structures long.  As each buffer is filled, data is sent to the
next.
</para>
<para>Note that <code>readv</code> is not guaranteed to fill all the buffers.
It may stop at any point, for the same reasons <code>read</code> would.
</para>
<para>The return value is a count of bytes (<emphasis>not</emphasis> buffers) read, <em class="math">0</emphasis>
indicating end-of-file, or <em class="math">-1</emphasis> indicating an error.  The possible
errors are the same as in <code>read</code>.
</para>
</dd></dl>

<dl class="def">
<dt xml:id="glibc-index-writev"><span class="category">Function: </span><span><emphasis>ssize_t</emphasis> <strong>writev</strong> <emphasis>(int <var>filedes</var>, const struct iovec *<var>vector</var>, int <var>count</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-writev" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Unsafe heap
| AC-Unsafe mem
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>


<para>The <code>writev</code> function gathers data from the buffers described in
<var>vector</var>, which is taken to be <var>count</var> structures long, and writes
them to <code>filedes</code>.  As each buffer is written, it moves on to the
next.
</para>
<para>Like <code>readv</code>, <code>writev</code> may stop midstream under the same
conditions <code>write</code> would.
</para>
<para>The return value is a count of bytes written, or <em class="math">-1</emphasis> indicating an
error.  The possible errors are the same as in <code>write</code>.
</para>
</dd></dl>

<dl class="def">
<dt xml:id="glibc-index-preadv"><span class="category">Function: </span><span><emphasis>ssize_t</emphasis> <strong>preadv</strong> <emphasis>(int <var>fd</var>, const struct iovec *<var>iov</var>, int <var>iovcnt</var>, off_t <var>offset</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-preadv" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Safe
| AC-Safe
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>


<para>This function is similar to the <code>readv</code> function, with the difference
it adds an extra <var>offset</var> parameter of type <code>off_t</code> similar to
<code>pread</code>.  The data is read from the file starting at position
<var>offset</var>.  The position of the file descriptor itself is not affected
by the operation.  The value is the same as before the call.
</para>
<para>When the source file is compiled with <code>_FILE_OFFSET_BITS == 64</code> the
<code>preadv</code> function is in fact <code>preadv64</code> and the type
<code>off_t</code> has 64 bits, which makes it possible to handle files up to
2^63 bytes in length.
</para>
<para>The return value is a count of bytes (<emphasis>not</emphasis> buffers) read, <em class="math">0</emphasis>
indicating end-of-file, or <em class="math">-1</emphasis> indicating an error.  The possible
errors are the same as in <code>readv</code> and <code>pread</code>.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-preadv64"><span class="category">Function: </span><span><emphasis>ssize_t</emphasis> <strong>preadv64</strong> <emphasis>(int <var>fd</var>, const struct iovec *<var>iov</var>, int <var>iovcnt</var>, off64_t <var>offset</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-preadv64" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Safe
| AC-Safe
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>


<para>This function is similar to the <code>preadv</code> function with the difference
is that the <var>offset</var> parameter is of type <code>off64_t</code> instead of
<code>off_t</code>.  It makes it possible on 32 bit machines to address
files larger than 2^31 bytes and up to 2^63 bytes.  The
file descriptor <code>filedes</code> must be opened using <code>open64</code> since
otherwise the large offsets possible with <code>off64_t</code> will lead to
errors with a descriptor in small file mode.
</para>
<para>When the source file is compiled using <code>_FILE_OFFSET_BITS == 64</code> on a
32 bit machine this function is actually available under the name
<code>preadv</code> and so transparently replaces the 32 bit interface.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-pwritev"><span class="category">Function: </span><span><emphasis>ssize_t</emphasis> <strong>pwritev</strong> <emphasis>(int <var>fd</var>, const struct iovec *<var>iov</var>, int <var>iovcnt</var>, off_t <var>offset</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-pwritev" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Safe
| AC-Safe
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>


<para>This function is similar to the <code>writev</code> function, with the difference
it adds an extra <var>offset</var> parameter of type <code>off_t</code> similar to
<code>pwrite</code>.  The data is written to the file starting at position
<var>offset</var>.  The position of the file descriptor itself is not affected
by the operation.  The value is the same as before the call.
</para>
<para>However, on Linux, if a file is opened with <code>O_APPEND</code>,  <code>pwrite</code>
appends data to the end of the file, regardless of the value of
<code>offset</code>.
</para>
<para>When the source file is compiled with <code>_FILE_OFFSET_BITS == 64</code> the
<code>pwritev</code> function is in fact <code>pwritev64</code> and the type
<code>off_t</code> has 64 bits, which makes it possible to handle files up to
2^63 bytes in length.
</para>
<para>The return value is a count of bytes (<emphasis>not</emphasis> buffers) written, <em class="math">0</emphasis>
indicating end-of-file, or <em class="math">-1</emphasis> indicating an error.  The possible
errors are the same as in <code>writev</code> and <code>pwrite</code>.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-pwritev64"><span class="category">Function: </span><span><emphasis>ssize_t</emphasis> <strong>pwritev64</strong> <emphasis>(int <var>fd</var>, const struct iovec *<var>iov</var>, int <var>iovcnt</var>, off64_t <var>offset</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-pwritev64" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Safe
| AC-Safe
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>


<para>This function is similar to the <code>pwritev</code> function with the difference
is that the <var>offset</var> parameter is of type <code>off64_t</code> instead of
<code>off_t</code>.  It makes it possible on 32 bit machines to address
files larger than 2^31 bytes and up to 2^63 bytes.  The
file descriptor <code>filedes</code> must be opened using <code>open64</code> since
otherwise the large offsets possible with <code>off64_t</code> will lead to
errors with a descriptor in small file mode.
</para>
<para>When the source file is compiled using <code>_FILE_OFFSET_BITS == 64</code> on a
32 bit machine this function is actually available under the name
<code>pwritev</code> and so transparently replaces the 32 bit interface.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-preadv2"><span class="category">Function: </span><span><emphasis>ssize_t</emphasis> <strong>preadv2</strong> <emphasis>(int <var>fd</var>, const struct iovec *<var>iov</var>, int <var>iovcnt</var>, off_t <var>offset</var>, int <var>flags</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-preadv2" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Safe
| AC-Safe
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>


<para>This function is similar to the <code>preadv</code> function, with the
difference it adds an extra <var>flags</var> parameter of type <code>int</code>.
Additionally, if <var>offset</var> is <em class="math">-1</emphasis>, the current file position
is used and updated (like the <code>readv</code> function).
</para>
<para>The supported <var>flags</var> are dependent of the underlying system.  For
Linux it supports:
</para>
<dl compact="compact">
<dt xml:id="glibc-index-RWF_005fHIPRI"><span><code>RWF_HIPRI</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-RWF_005fHIPRI" class="copiable-anchor"> ¶</a></span></dt>
<dd><para>High priority request.  This adds a flag that tells the file system that
this is a high priority request for which it is worth to poll the hardware.
The flag is purely advisory and can be ignored if not supported.  The
<var>fd</var> must be opened using <code>O_DIRECT</code>.
</para>
</dd>
<dt xml:id="glibc-index-RWF_005fDSYNC"><span><code>RWF_DSYNC</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-RWF_005fDSYNC" class="copiable-anchor"> ¶</a></span></dt>
<dd><para>Per-IO synchronization as if the file was opened with <code>O_DSYNC</code> flag.
</para>
</dd>
<dt xml:id="glibc-index-RWF_005fSYNC"><span><code>RWF_SYNC</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-RWF_005fSYNC" class="copiable-anchor"> ¶</a></span></dt>
<dd><para>Per-IO synchronization as if the file was opened with <code>O_SYNC</code> flag.
</para>
</dd>
<dt xml:id="glibc-index-RWF_005fNOWAIT"><span><code>RWF_NOWAIT</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-RWF_005fNOWAIT" class="copiable-anchor"> ¶</a></span></dt>
<dd><para>Use nonblocking mode for this operation; that is, this call to <code>preadv2</code>
will fail and set <code>errno</code> to <code>EAGAIN</code> if the operation would block.
</para>
</dd>
<dt xml:id="glibc-index-RWF_005fAPPEND"><span><code>RWF_APPEND</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-RWF_005fAPPEND" class="copiable-anchor"> ¶</a></span></dt>
<dd><para>Per-IO synchronization as if the file was opened with <code>O_APPEND</code> flag.
</para></dd>
</dl>

<para>When the source file is compiled with <code>_FILE_OFFSET_BITS == 64</code> the
<code>preadv2</code> function is in fact <code>preadv64v2</code> and the type
<code>off_t</code> has 64 bits, which makes it possible to handle files up to
2^63 bytes in length.
</para>
<para>The return value is a count of bytes (<emphasis>not</emphasis> buffers) read, <em class="math">0</emphasis>
indicating end-of-file, or <em class="math">-1</emphasis> indicating an error.  The possible
errors are the same as in <code>preadv</code> with the addition of:
</para>
<dl compact="compact">
<dt><span><code>EOPNOTSUPP</code></span></dt>
<dd>
<para>An unsupported <var>flags</var> was used.
</para>
</dd>
</dl>

</dd></dl>

<dl class="def">
<dt xml:id="glibc-index-preadv64v2"><span class="category">Function: </span><span><emphasis>ssize_t</emphasis> <strong>preadv64v2</strong> <emphasis>(int <var>fd</var>, const struct iovec *<var>iov</var>, int <var>iovcnt</var>, off64_t <var>offset</var>, int <var>flags</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-preadv64v2" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Safe
| AC-Safe
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>


<para>This function is similar to the <code>preadv2</code> function with the difference
is that the <var>offset</var> parameter is of type <code>off64_t</code> instead of
<code>off_t</code>.  It makes it possible on 32 bit machines to address
files larger than 2^31 bytes and up to 2^63 bytes.  The
file descriptor <code>filedes</code> must be opened using <code>open64</code> since
otherwise the large offsets possible with <code>off64_t</code> will lead to
errors with a descriptor in small file mode.
</para>
<para>When the source file is compiled using <code>_FILE_OFFSET_BITS == 64</code> on a
32 bit machine this function is actually available under the name
<code>preadv2</code> and so transparently replaces the 32 bit interface.
</para></dd></dl>


<dl class="def">
<dt xml:id="glibc-index-pwritev2"><span class="category">Function: </span><span><emphasis>ssize_t</emphasis> <strong>pwritev2</strong> <emphasis>(int <var>fd</var>, const struct iovec *<var>iov</var>, int <var>iovcnt</var>, off_t <var>offset</var>, int <var>flags</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-pwritev2" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Safe
| AC-Safe
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>


<para>This function is similar to the <code>pwritev</code> function, with the
difference it adds an extra <var>flags</var> parameter of type <code>int</code>.
Additionally, if <var>offset</var> is <em class="math">-1</emphasis>, the current file position
should is used and updated (like the <code>writev</code> function).
</para>
<para>The supported <var>flags</var> are dependent of the underlying system.  For
Linux, the supported flags are the same as those for <code>preadv2</code>.
</para>
<para>When the source file is compiled with <code>_FILE_OFFSET_BITS == 64</code> the
<code>pwritev2</code> function is in fact <code>pwritev64v2</code> and the type
<code>off_t</code> has 64 bits, which makes it possible to handle files up to
2^63 bytes in length.
</para>
<para>The return value is a count of bytes (<emphasis>not</emphasis> buffers) write, <em class="math">0</emphasis>
indicating end-of-file, or <em class="math">-1</emphasis> indicating an error.  The possible
errors are the same as in <code>preadv2</code>.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-pwritev64v2"><span class="category">Function: </span><span><emphasis>ssize_t</emphasis> <strong>pwritev64v2</strong> <emphasis>(int <var>fd</var>, const struct iovec *<var>iov</var>, int <var>iovcnt</var>, off64_t <var>offset</var>, int <var>flags</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-pwritev64v2" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Safe
| AC-Safe
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>


<para>This function is similar to the <code>pwritev2</code> function with the difference
is that the <var>offset</var> parameter is of type <code>off64_t</code> instead of
<code>off_t</code>.  It makes it possible on 32 bit machines to address
files larger than 2^31 bytes and up to 2^63 bytes.  The
file descriptor <code>filedes</code> must be opened using <code>open64</code> since
otherwise the large offsets possible with <code>off64_t</code> will lead to
errors with a descriptor in small file mode.
</para>
<para>When the source file is compiled using <code>_FILE_OFFSET_BITS == 64</code> on a
32 bit machine this function is actually available under the name
<code>pwritev2</code> and so transparently replaces the 32 bit interface.
</para></dd></dl>

<hr>
</div>
<sect xml:id="glibc-Copying-File-Data">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Memory_002dmapped-I_002fO" accesskey="n" rel="next">Memory-mapped I/O</a>, Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Scatter_002dGather" accesskey="p" rel="prev">Fast Scatter-Gather I/O</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Low_002dLevel-I_002fO" accesskey="u" rel="up">Low-Level Input/Output</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Copying-data-between-two-files"></span><h3 class="section">13.7 Copying data between two files</title>
<span xml:id="glibc-index-copying-files"></span>
<span xml:id="glibc-index-file-copy"></span>

<para>A special function is provided to copy data between two files on the
same file system.  The system can optimize such copy operations.  This
is particularly important on network file systems, where the data would
otherwise have to be transferred twice over the network.
</para>
<para>Note that this function only copies file data, but not metadata such as
file permissions or extended attributes.
</para>
<dl class="def">
<dt xml:id="glibc-index-copy_005ffile_005frange"><span class="category">Function: </span><span><emphasis>ssize_t</emphasis> <strong>copy_file_range</strong> <emphasis>(int <var>inputfd</var>, off64_t *<var>inputpos</var>, int <var>outputfd</var>, off64_t *<var>outputpos</var>, ssize_t <var>length</var>, unsigned int <var>flags</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-copy_005ffile_005frange" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Safe
| AC-Safe
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>


<para>This function copies up to <var>length</var> bytes from the file descriptor
<var>inputfd</var> to the file descriptor <var>outputfd</var>.
</para>
<para>The function can operate on both the current file position (like
<code>read</code> and <code>write</code>) and an explicit offset (like <code>pread</code>
and <code>pwrite</code>).  If the <var>inputpos</var> pointer is null, the file
position of <var>inputfd</var> is used as the starting point of the copy
operation, and the file position is advanced during it.  If
<var>inputpos</var> is not null, then <code>*<var>inputpos</var></code> is used as the
starting point of the copy operation, and <code>*<var>inputpos</var></code> is
incremented by the number of copied bytes, but the file position remains
unchanged.  Similar rules apply to <var>outputfd</var> and <var>outputpos</var>
for the output file position.
</para>
<para>The <var>flags</var> argument is currently reserved and must be zero.
</para>
<para>The <code>copy_file_range</code> function returns the number of bytes copied.
This can be less than the specified <var>length</var> in case the input file
contains fewer remaining bytes than <var>length</var>, or if a read or write
failure occurs.  The return value is zero if the end of the input file
is encountered immediately.
</para>
<para>If no bytes can be copied, to report an error, <code>copy_file_range</code>
returns the value <em class="math">-1</emphasis> and sets <code>errno</code>.  The table below
lists some of the error conditions for this function.
</para>
<dl compact="compact">
<dt><span><code>ENOSYS</code></span></dt>
<dd><para>The kernel does not implement the required functionality.
</para>
</dd>
<dt><span><code>EISDIR</code></span></dt>
<dd><para>At least one of the descriptors <var>inputfd</var> or <var>outputfd</var> refers
to a directory.
</para>
</dd>
<dt><span><code>EINVAL</code></span></dt>
<dd><para>At least one of the descriptors <var>inputfd</var> or <var>outputfd</var> refers
to a non-regular, non-directory file (such as a socket or a FIFO).
</para>
<para>The input or output positions before are after the copy operations are
outside of an implementation-defined limit.
</para>
<para>The <var>flags</var> argument is not zero.
</para>
</dd>
<dt><span><code>EFBIG</code></span></dt>
<dd><para>The new file size would exceed the process file size limit.
See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Limits-on-Resources">Limiting Resource Usage</a>.
</para>
<para>The input or output positions before are after the copy operations are
outside of an implementation-defined limit.  This can happen if the file
was not opened with large file support (LFS) on 32-bit machines, and the
copy operation would create a file which is larger than what
<code>off_t</code> could represent.
</para>
</dd>
<dt><span><code>EBADF</code></span></dt>
<dd><para>The argument <var>inputfd</var> is not a valid file descriptor open for
reading.
</para>
<para>The argument <var>outputfd</var> is not a valid file descriptor open for
writing, or <var>outputfd</var> has been opened with <code>O_APPEND</code>.
</para></dd>
</dl>

<para>In addition, <code>copy_file_range</code> can fail with the error codes
which are used by <code>read</code>, <code>pread</code>, <code>write</code>, and
<code>pwrite</code>.
</para>
<para>The <code>copy_file_range</code> function is a cancellation point.  In case of
cancellation, the input location (the file position or the value at
<code>*<var>inputpos</var></code>) is indeterminate.
</para></dd></dl>

<hr>
</div>
<sect xml:id="glibc-Memory_002dmapped-I_002fO">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Waiting-for-I_002fO" accesskey="n" rel="next">Waiting for Input or Output</a>, Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Copying-File-Data" accesskey="p" rel="prev">Copying data between two files</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Low_002dLevel-I_002fO" accesskey="u" rel="up">Low-Level Input/Output</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Memory_002dmapped-I_002fO-1"></span><h3 class="section">13.8 Memory-mapped I/O</title>

<para>On modern operating systems, it is possible to <emphasis>mmap</emphasis> (pronounced
“em-map”) a file to a region of memory.  When this is done, the file can
be accessed just like an array in the program.
</para>
<para>This is more efficient than <code>read</code> or <code>write</code>, as only the regions
of the file that a program actually accesses are loaded.  Accesses to
not-yet-loaded parts of the mmapped region are handled in the same way as
swapped out pages.
</para>
<para>Since mmapped pages can be stored back to their file when physical
memory is low, it is possible to mmap files orders of magnitude larger
than both the physical memory <emphasis>and</emphasis> swap space.  The only limit is
address space.  The theoretical limit is 4GB on a 32-bit machine -
however, the actual limit will be smaller since some areas will be
reserved for other purposes.  If the LFS interface is used the file size
on 32-bit systems is not limited to 2GB (offsets are signed which
reduces the addressable area of 4GB by half); the full 64-bit are
available.
</para>
<para>Memory mapping only works on entire pages of memory.  Thus, addresses
for mapping must be page-aligned, and length values will be rounded up.
To determine the default size of a page the machine uses one should use:
</para>
<span xml:id="glibc-index-_005fSC_005fPAGESIZE"></span>
<div class="example">
<pre class="example">size_t page_size = (size_t) sysconf (_SC_PAGESIZE);
</pre></div>

<para>On some systems, mappings can use larger page sizes
for certain files, and applications can request larger page sizes for
anonymous mappings as well (see the <code>MAP_HUGETLB</code> flag below).
</para>
<para>The following functions are declared in <filename>sys/mman.h</filename>:
</para>
<dl class="def">
<dt xml:id="glibc-index-mmap"><span class="category">Function: </span><span><emphasis>void *</emphasis> <strong>mmap</strong> <emphasis>(void *<var>address</var>, size_t <var>length</var>, int <var>protect</var>, int <var>flags</var>, int <var>filedes</var>, off_t <var>offset</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-mmap" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Safe
| AC-Safe
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>


<para>The <code>mmap</code> function creates a new mapping, connected to bytes
(<var>offset</var>) to (<var>offset</var> + <var>length</var> - 1) in the file open on
<var>filedes</var>.  A new reference for the file specified by <var>filedes</var>
is created, which is not removed by closing the file.
</para>
<para><var>address</var> gives a preferred starting address for the mapping.
<code>NULL</code> expresses no preference.  Any previous mapping at that
address is automatically removed.  The address you give may still be
changed, unless you use the <code>MAP_FIXED</code> flag.
</para>
<para><var>protect</var> contains flags that control what kind of access is
permitted.  They include <code>PROT_READ</code>, <code>PROT_WRITE</code>, and
<code>PROT_EXEC</code>.  The special flag <code>PROT_NONE</code> reserves a region
of address space for future use.  The <code>mprotect</code> function can be
used to change the protection flags.  See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Memory-Protection">Memory Protection</a>.
</para>
<para><var>flags</var> contains flags that control the nature of the map.
One of <code>MAP_SHARED</code> or <code>MAP_PRIVATE</code> must be specified.
</para>
<para>They include:
</para>
<dl compact="compact">
<dt xml:id="glibc-index-MAP_005fPRIVATE"><span><code>MAP_PRIVATE</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-MAP_005fPRIVATE" class="copiable-anchor"> ¶</a></span></dt>
<dd><para>This specifies that writes to the region should never be written back
to the attached file.  Instead, a copy is made for the process, and the
region will be swapped normally if memory runs low.  No other process will
see the changes.
</para>
<para>Since private mappings effectively revert to ordinary memory
when written to, you must have enough virtual memory for a copy of
the entire mmapped region if you use this mode with <code>PROT_WRITE</code>.
</para>
</dd>
<dt xml:id="glibc-index-MAP_005fSHARED"><span><code>MAP_SHARED</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-MAP_005fSHARED" class="copiable-anchor"> ¶</a></span></dt>
<dd><para>This specifies that writes to the region will be written back to the
file.  Changes made will be shared immediately with other processes
mmaping the same file.
</para>
<para>Note that actual writing may take place at any time.  You need to use
<code>msync</code>, described below, if it is important that other processes
using conventional I/O get a consistent view of the file.
</para>
</dd>
<dt xml:id="glibc-index-MAP_005fFIXED"><span><code>MAP_FIXED</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-MAP_005fFIXED" class="copiable-anchor"> ¶</a></span></dt>
<dd><para>This forces the system to use the exact mapping address specified in
<var>address</var> and fail if it can’t.
</para>
</dd>
<dt xml:id="glibc-index-MAP_005fANONYMOUS"><span><code>MAP_ANONYMOUS</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-MAP_005fANONYMOUS" class="copiable-anchor"> ¶</a></span></dt>
<dt xml:id="glibc-index-MAP_005fANON"><span><code>MAP_ANON</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-MAP_005fANON" class="copiable-anchor"> ¶</a></span></dt>
<dd><para>This flag tells the system to create an anonymous mapping, not connected
to a file.  <var>filedes</var> and <var>offset</var> are ignored, and the region is
initialized with zeros.
</para>
<para>Anonymous maps are used as the basic primitive to extend the heap on some
systems.  They are also useful to share data between multiple tasks
without creating a file.
</para>
<para>On some systems using private anonymous mmaps is more efficient than using
<code>malloc</code> for large blocks.  This is not an issue with the GNU C Library,
as the included <code>malloc</code> automatically uses <code>mmap</code> where appropriate.
</para>
</dd>
<dt xml:id="glibc-index-MAP_005fHUGETLB"><span><code>MAP_HUGETLB</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-MAP_005fHUGETLB" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>This requests that the system uses an alternative page size which is
larger than the default page size for the mapping.  For some workloads,
increasing the page size for large mappings improves performance because
the system needs to handle far fewer pages.  For other workloads which
require frequent transfer of pages between storage or different nodes,
the decreased page granularity may cause performance problems due to the
increased page size and larger transfers.
</para>
<para>In order to create the mapping, the system needs physically contiguous
memory of the size of the increased page size.  As a result,
<code>MAP_HUGETLB</code> mappings are affected by memory fragmentation, and
their creation can fail even if plenty of memory is available in the
system.
</para>
<para>Not all file systems support mappings with an increased page size.
</para>
<para>The <code>MAP_HUGETLB</code> flag is specific to Linux.
</para>


</dd>
</dl>

<para><code>mmap</code> returns the address of the new mapping, or
<code>MAP_FAILED</code> for an error.
</para>
<para>Possible errors include:
</para>
<dl compact="compact">
<dt><span><code>EINVAL</code></span></dt>
<dd>
<para>Either <var>address</var> was unusable (because it is not a multiple of the
applicable page size), or inconsistent <var>flags</var> were given.
</para>
<para>If <code>MAP_HUGETLB</code> was specified, the file or system does not support
large page sizes.
</para>
</dd>
<dt><span><code>EACCES</code></span></dt>
<dd>
<para><var>filedes</var> was not open for the type of access specified in <var>protect</var>.
</para>
</dd>
<dt><span><code>ENOMEM</code></span></dt>
<dd>
<para>Either there is not enough memory for the operation, or the process is
out of address space.
</para>
</dd>
<dt><span><code>ENODEV</code></span></dt>
<dd>
<para>This file is of a type that doesn’t support mapping.
</para>
</dd>
<dt><span><code>ENOEXEC</code></span></dt>
<dd>
<para>The file is on a filesystem that doesn’t support mapping.
</para>

</dd>
</dl>

</dd></dl>

<dl class="def">
<dt xml:id="glibc-index-mmap64"><span class="category">Function: </span><span><emphasis>void *</emphasis> <strong>mmap64</strong> <emphasis>(void *<var>address</var>, size_t <var>length</var>, int <var>protect</var>, int <var>flags</var>, int <var>filedes</var>, off64_t <var>offset</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-mmap64" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Safe
| AC-Safe
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>The <code>mmap64</code> function is equivalent to the <code>mmap</code> function but
the <var>offset</var> parameter is of type <code>off64_t</code>.  On 32-bit systems
this allows the file associated with the <var>filedes</var> descriptor to be
larger than 2GB.  <var>filedes</var> must be a descriptor returned from a
call to <code>open64</code> or <code>fopen64</code> and <code>freopen64</code> where the
descriptor is retrieved with <code>fileno</code>.
</para>
<para>When the sources are translated with <code>_FILE_OFFSET_BITS == 64</code> this
function is actually available under the name <code>mmap</code>.  I.e., the
new, extended API using 64 bit file sizes and offsets transparently
replaces the old API.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-munmap"><span class="category">Function: </span><span><emphasis>int</emphasis> <strong>munmap</strong> <emphasis>(void *<var>addr</var>, size_t <var>length</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-munmap" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Safe
| AC-Safe
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>


<para><code>munmap</code> removes any memory maps from (<var>addr</var>) to (<var>addr</var> +
<var>length</var>).  <var>length</var> should be the length of the mapping.
</para>
<para>It is safe to unmap multiple mappings in one command, or include unmapped
space in the range.  It is also possible to unmap only part of an existing
mapping.  However, only entire pages can be removed.  If <var>length</var> is not
an even number of pages, it will be rounded up.
</para>
<para>It returns <em class="math">0</emphasis> for success and <em class="math">-1</emphasis> for an error.
</para>
<para>One error is possible:
</para>
<dl compact="compact">
<dt><span><code>EINVAL</code></span></dt>
<dd><para>The memory range given was outside the user mmap range or wasn’t page
aligned.
</para>
</dd>
</dl>

</dd></dl>

<dl class="def">
<dt xml:id="glibc-index-msync"><span class="category">Function: </span><span><emphasis>int</emphasis> <strong>msync</strong> <emphasis>(void *<var>address</var>, size_t <var>length</var>, int <var>flags</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-msync" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Safe
| AC-Safe
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>


<para>When using shared mappings, the kernel can write the file at any time
before the mapping is removed.  To be certain data has actually been
written to the file and will be accessible to non-memory-mapped I/O, it
is necessary to use this function.
</para>
<para>It operates on the region <var>address</var> to (<var>address</var> + <var>length</var>).
It may be used on part of a mapping or multiple mappings, however the
region given should not contain any unmapped space.
</para>
<para><var>flags</var> can contain some options:
</para>
<dl compact="compact">
<dt xml:id="glibc-index-MS_005fSYNC"><span><code>MS_SYNC</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-MS_005fSYNC" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>This flag makes sure the data is actually written <emphasis>to disk</emphasis>.
Normally <code>msync</code> only makes sure that accesses to a file with
conventional I/O reflect the recent changes.
</para>
</dd>
<dt xml:id="glibc-index-MS_005fASYNC"><span><code>MS_ASYNC</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-MS_005fASYNC" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>This tells <code>msync</code> to begin the synchronization, but not to wait for
it to complete.
</para>

</dd>
</dl>

<para><code>msync</code> returns <em class="math">0</emphasis> for success and <em class="math">-1</emphasis> for
error.  Errors include:
</para>
<dl compact="compact">
<dt><span><code>EINVAL</code></span></dt>
<dd><para>An invalid region was given, or the <var>flags</var> were invalid.
</para>
</dd>
<dt><span><code>EFAULT</code></span></dt>
<dd><para>There is no existing mapping in at least part of the given region.
</para>
</dd>
</dl>

</dd></dl>

<dl class="def">
<dt xml:id="glibc-index-mremap"><span class="category">Function: </span><span><emphasis>void *</emphasis> <strong>mremap</strong> <emphasis>(void *<var>address</var>, size_t <var>length</var>, size_t <var>new_length</var>, int <var>flag</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-mremap" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Safe
| AC-Safe
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>


<para>This function can be used to change the size of an existing memory
area. <var>address</var> and <var>length</var> must cover a region entirely mapped
in the same <code>mmap</code> statement.  A new mapping with the same
characteristics will be returned with the length <var>new_length</var>.
</para>
<para>One option is possible, <code>MREMAP_MAYMOVE</code>.  If it is given in
<var>flags</var>, the system may remove the existing mapping and create a new
one of the desired length in another location.
</para>
<para>The address of the resulting mapping is returned, or <em class="math">-1</emphasis>.  Possible
error codes include:
</para>
<dl compact="compact">
<dt><span><code>EFAULT</code></span></dt>
<dd><para>There is no existing mapping in at least part of the original region, or
the region covers two or more distinct mappings.
</para>
</dd>
<dt><span><code>EINVAL</code></span></dt>
<dd><para>The address given is misaligned or inappropriate.
</para>
</dd>
<dt><span><code>EAGAIN</code></span></dt>
<dd><para>The region has pages locked, and if extended it would exceed the
process’s resource limit for locked pages.  See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Limits-on-Resources">Limiting Resource Usage</a>.
</para>
</dd>
<dt><span><code>ENOMEM</code></span></dt>
<dd><para>The region is private writable, and insufficient virtual memory is
available to extend it.  Also, this error will occur if
<code>MREMAP_MAYMOVE</code> is not given and the extension would collide with
another mapped region.
</para>
</dd>
</dl>
</dd></dl>

<para>This function is only available on a few systems.  Except for performing
optional optimizations one should not rely on this function.
</para>
<para>Not all file descriptors may be mapped.  Sockets, pipes, and most devices
only allow sequential access and do not fit into the mapping abstraction.
In addition, some regular files may not be mmapable, and older kernels may
not support mapping at all.  Thus, programs using <code>mmap</code> should
have a fallback method to use should it fail. See <a data-manual="standards" href="https://www.gnu.org/prep/standards/standards.html#Mmap">Mmap</a> in <cite>GNU
Coding Standards</cite>.
</para>
<dl class="def">
<dt xml:id="glibc-index-madvise"><span class="category">Function: </span><span><emphasis>int</emphasis> <strong>madvise</strong> <emphasis>(void *<var>addr</var>, size_t <var>length</var>, int <var>advice</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-madvise" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Safe
| AC-Safe
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>


<para>This function can be used to provide the system with <var>advice</var> about
the intended usage patterns of the memory region starting at <var>addr</var>
and extending <var>length</var> bytes.
</para>
<para>The valid BSD values for <var>advice</var> are:
</para>
<dl compact="compact">
<dt xml:id="glibc-index-MADV_005fNORMAL"><span><code>MADV_NORMAL</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-MADV_005fNORMAL" class="copiable-anchor"> ¶</a></span></dt>
<dd><para>The region should receive no further special treatment.
</para>
</dd>
<dt xml:id="glibc-index-MADV_005fRANDOM"><span><code>MADV_RANDOM</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-MADV_005fRANDOM" class="copiable-anchor"> ¶</a></span></dt>
<dd><para>The region will be accessed via random page references.  The kernel
should page-in the minimal number of pages for each page fault.
</para>
</dd>
<dt xml:id="glibc-index-MADV_005fSEQUENTIAL"><span><code>MADV_SEQUENTIAL</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-MADV_005fSEQUENTIAL" class="copiable-anchor"> ¶</a></span></dt>
<dd><para>The region will be accessed via sequential page references.  This
may cause the kernel to aggressively read-ahead, expecting further
sequential references after any page fault within this region.
</para>
</dd>
<dt xml:id="glibc-index-MADV_005fWILLNEED"><span><code>MADV_WILLNEED</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-MADV_005fWILLNEED" class="copiable-anchor"> ¶</a></span></dt>
<dd><para>The region will be needed.  The pages within this region may
be pre-faulted in by the kernel.
</para>
</dd>
<dt xml:id="glibc-index-MADV_005fDONTNEED"><span><code>MADV_DONTNEED</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-MADV_005fDONTNEED" class="copiable-anchor"> ¶</a></span></dt>
<dd><para>The region is no longer needed.  The kernel may free these pages,
causing any changes to the pages to be lost, as well as swapped
out pages to be discarded.
</para>
</dd>
<dt xml:id="glibc-index-MADV_005fHUGEPAGE"><span><code>MADV_HUGEPAGE</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-MADV_005fHUGEPAGE" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Indicate that it is beneficial to increase the page size for this
mapping.  This can improve performance for larger mappings because the
system needs to handle far fewer pages.  However, if parts of the
mapping are frequently transferred between storage or different nodes,
performance may suffer because individual transfers can become
substantially larger due to the increased page size.
</para>
<para>This flag is specific to Linux.
</para>
</dd>
<dt xml:id="glibc-index-MADV_005fNOHUGEPAGE"><span><code>MADV_NOHUGEPAGE</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-MADV_005fNOHUGEPAGE" class="copiable-anchor"> ¶</a></span></dt>
<dd><para>Undo the effect of a previous <code>MADV_HUGEPAGE</code> advice.  This flag
is specific to Linux.
</para>
</dd>
</dl>

<para>The POSIX names are slightly different, but with the same meanings:
</para>
<dl compact="compact">
<dt xml:id="glibc-index-POSIX_005fMADV_005fNORMAL"><span><code>POSIX_MADV_NORMAL</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-POSIX_005fMADV_005fNORMAL" class="copiable-anchor"> ¶</a></span></dt>
<dd><para>This corresponds with BSD’s <code>MADV_NORMAL</code>.
</para>
</dd>
<dt xml:id="glibc-index-POSIX_005fMADV_005fRANDOM"><span><code>POSIX_MADV_RANDOM</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-POSIX_005fMADV_005fRANDOM" class="copiable-anchor"> ¶</a></span></dt>
<dd><para>This corresponds with BSD’s <code>MADV_RANDOM</code>.
</para>
</dd>
<dt xml:id="glibc-index-POSIX_005fMADV_005fSEQUENTIAL"><span><code>POSIX_MADV_SEQUENTIAL</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-POSIX_005fMADV_005fSEQUENTIAL" class="copiable-anchor"> ¶</a></span></dt>
<dd><para>This corresponds with BSD’s <code>MADV_SEQUENTIAL</code>.
</para>
</dd>
<dt xml:id="glibc-index-POSIX_005fMADV_005fWILLNEED"><span><code>POSIX_MADV_WILLNEED</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-POSIX_005fMADV_005fWILLNEED" class="copiable-anchor"> ¶</a></span></dt>
<dd><para>This corresponds with BSD’s <code>MADV_WILLNEED</code>.
</para>
</dd>
<dt xml:id="glibc-index-POSIX_005fMADV_005fDONTNEED"><span><code>POSIX_MADV_DONTNEED</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-POSIX_005fMADV_005fDONTNEED" class="copiable-anchor"> ¶</a></span></dt>
<dd><para>This corresponds with BSD’s <code>MADV_DONTNEED</code>.
</para>
</dd>
</dl>

<para><code>madvise</code> returns <em class="math">0</emphasis> for success and <em class="math">-1</emphasis> for
error.  Errors include:
</para><dl compact="compact">
<dt><span><code>EINVAL</code></span></dt>
<dd><para>An invalid region was given, or the <var>advice</var> was invalid.
</para>
</dd>
<dt><span><code>EFAULT</code></span></dt>
<dd><para>There is no existing mapping in at least part of the given region.
</para>
</dd>
</dl>
</dd></dl>

<dl class="def">
<dt xml:id="glibc-index-shm_005fopen"><span class="category">Function: </span><span><emphasis>int</emphasis> <strong>shm_open</strong> <emphasis>(const char *<var>name</var>, int <var>oflag</var>, mode_t <var>mode</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-shm_005fopen" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe locale
| AS-Unsafe init heap lock
| AC-Unsafe lock mem fd
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>


<para>This function returns a file descriptor that can be used to allocate shared
memory via mmap.  Unrelated processes can use same <var>name</var> to create or
open existing shared memory objects.
</para>
<para>A <var>name</var> argument specifies the shared memory object to be opened.
In the GNU C Library it must be a string smaller than <code>NAME_MAX</code> bytes starting
with an optional slash but containing no other slashes.
</para>
<para>The semantics of <var>oflag</var> and <var>mode</var> arguments is same as in <code>open</code>.
</para>
<para><code>shm_open</code> returns the file descriptor on success or <em class="math">-1</emphasis> on error.
On failure <code>errno</code> is set.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-shm_005funlink"><span class="category">Function: </span><span><emphasis>int</emphasis> <strong>shm_unlink</strong> <emphasis>(const char *<var>name</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-shm_005funlink" class="copiable-anchor"> ¶</a></span></dt>
<dd><para>Preliminary:
| MT-Safe locale
| AS-Unsafe init heap lock
| AC-Unsafe lock mem fd
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>


<para>This function is the inverse of <code>shm_open</code> and removes the object with
the given <var>name</var> previously created by <code>shm_open</code>.
</para>
<para><code>shm_unlink</code> returns <em class="math">0</emphasis> on success or <em class="math">-1</emphasis> on error.
On failure <code>errno</code> is set.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-memfd_005fcreate"><span class="category">Function: </span><span><emphasis>int</emphasis> <strong>memfd_create</strong> <emphasis>(const char *<var>name</var>, unsigned int <var>flags</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-memfd_005fcreate" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Safe
| AC-Safe fd
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>The <code>memfd_create</code> function returns a file descriptor which can be
used to create memory mappings using the <code>mmap</code> function.  It is
similar to the <code>shm_open</code> function in the sense that these mappings
are not backed by actual files.  However, the descriptor returned by
<code>memfd_create</code> does not correspond to a named object; the
<var>name</var> argument is used for debugging purposes only (e.g., will
appear in <filename>/proc</filename>), and separate invocations of <code>memfd_create</code>
with the same <var>name</var> will not return descriptors for the same region
of memory.  The descriptor can also be used to create alias mappings
within the same process.
</para>
<para>The descriptor initially refers to a zero-length file.  Before mappings
can be created which are backed by memory, the file size needs to be
increased with the <code>ftruncate</code> function.  See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#File-Size">File Size</a>.
</para>
<para>The <var>flags</var> argument can be a combination of the following flags:
</para>
<dl compact="compact">
<dt xml:id="glibc-index-MFD_005fCLOEXEC"><span><code>MFD_CLOEXEC</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-MFD_005fCLOEXEC" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>The descriptor is created with the <code>O_CLOEXEC</code> flag.
</para>
</dd>
<dt xml:id="glibc-index-MFD_005fALLOW_005fSEALING"><span><code>MFD_ALLOW_SEALING</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-MFD_005fALLOW_005fSEALING" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>The descriptor supports the addition of seals using the <code>fcntl</code>
function.
</para>
</dd>
<dt xml:id="glibc-index-MFD_005fHUGETLB"><span><code>MFD_HUGETLB</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-MFD_005fHUGETLB" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>This requests that mappings created using the returned file descriptor
use a larger page size.  See <code>MAP_HUGETLB</code> above for details.
</para>
<para>This flag is incompatible with <code>MFD_ALLOW_SEALING</code>.
</para></dd>
</dl>

<para><code>memfd_create</code> returns a file descriptor on success, and <em class="math">-1</emphasis>
on failure.
</para>
<para>The following <code>errno</code> error conditions are defined for this
function:
</para>
<dl compact="compact">
<dt><span><code>EINVAL</code></span></dt>
<dd><para>An invalid combination is specified in <var>flags</var>, or <var>name</var> is
too long.
</para>
</dd>
<dt><span><code>EFAULT</code></span></dt>
<dd><para>The <var>name</var> argument does not point to a string.
</para>
</dd>
<dt><span><code>EMFILE</code></span></dt>
<dd><para>The operation would exceed the file descriptor limit for this process.
</para>
</dd>
<dt><span><code>ENFILE</code></span></dt>
<dd><para>The operation would exceed the system-wide file descriptor limit.
</para>
</dd>
<dt><span><code>ENOMEM</code></span></dt>
<dd><para>There is not enough memory for the operation.
</para></dd>
</dl>
</dd></dl>

<hr>
</div>
<sect xml:id="glibc-Waiting-for-I_002fO">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Synchronizing-I_002fO" accesskey="n" rel="next">Synchronizing I/O operations</a>, Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Memory_002dmapped-I_002fO" accesskey="p" rel="prev">Memory-mapped I/O</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Low_002dLevel-I_002fO" accesskey="u" rel="up">Low-Level Input/Output</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Waiting-for-Input-or-Output"></span><h3 class="section">13.9 Waiting for Input or Output</title>
<span xml:id="glibc-index-waiting-for-input-or-output"></span>
<span xml:id="glibc-index-multiplexing-input"></span>
<span xml:id="glibc-index-input-from-multiple-files"></span>

<para>Sometimes a program needs to accept input on multiple input channels
whenever input arrives.  For example, some workstations may have devices
such as a digitizing tablet, function button box, or dial box that are
connected via normal asynchronous serial interfaces; good user interface
style requires responding immediately to input on any device.  Another
example is a program that acts as a server to several other processes
via pipes or sockets.
</para>
<para>You cannot normally use <code>read</code> for this purpose, because this
blocks the program until input is available on one particular file
descriptor; input on other channels won’t wake it up.  You could set
nonblocking mode and poll each file descriptor in turn, but this is very
inefficient.
</para>
<para>A better solution is to use the <code>select</code> function.  This blocks the
program until input or output is ready on a specified set of file
descriptors, or until a timer expires, whichever comes first.  This
facility is declared in the header file <filename>sys/types.h</filename>.
<span xml:id="glibc-index-sys_002ftypes_002eh"></span>
</para>
<para>In the case of a server socket (see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Listening">Listening for Connections</a>), we say that
“input” is available when there are pending connections that could be
accepted (see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Accepting-Connections">Accepting Connections</a>).  <code>accept</code> for server
sockets blocks and interacts with <code>select</code> just as <code>read</code> does
for normal input.
</para>
<span xml:id="glibc-index-file-descriptor-sets_002c-for-select"></span>
<para>The file descriptor sets for the <code>select</code> function are specified
as <code>fd_set</code> objects.  Here is the description of the data type
and some macros for manipulating these objects.
</para>
<dl class="def">
<dt xml:id="glibc-index-fd_005fset"><span class="category">Data Type: </span><span><strong>fd_set</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-fd_005fset" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>The <code>fd_set</code> data type represents file descriptor sets for the
<code>select</code> function.  It is actually a bit array.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-FD_005fSETSIZE"><span class="category">Macro: </span><span><emphasis>int</emphasis> <strong>FD_SETSIZE</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-FD_005fSETSIZE" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>The value of this macro is the maximum number of file descriptors that a
<code>fd_set</code> object can hold information about.  On systems with a
fixed maximum number, <code>FD_SETSIZE</code> is at least that number.  On
some systems, including GNU, there is no absolute limit on the number of
descriptors open, but this macro still has a constant value which
controls the number of bits in an <code>fd_set</code>; if you get a file
descriptor with a value as high as <code>FD_SETSIZE</code>, you cannot put
that descriptor into an <code>fd_set</code>.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-FD_005fZERO"><span class="category">Macro: </span><span><emphasis>void</emphasis> <strong>FD_ZERO</strong> <emphasis>(fd_set *<var>set</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-FD_005fZERO" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe race:set
| AS-Safe
| AC-Safe
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>This macro initializes the file descriptor set <var>set</var> to be the
empty set.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-FD_005fSET"><span class="category">Macro: </span><span><emphasis>void</emphasis> <strong>FD_SET</strong> <emphasis>(int <var>filedes</var>, fd_set *<var>set</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-FD_005fSET" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe race:set
| AS-Safe
| AC-Safe
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>This macro adds <var>filedes</var> to the file descriptor set <var>set</var>.
</para>
<para>The <var>filedes</var> parameter must not have side effects since it is
evaluated more than once.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-FD_005fCLR"><span class="category">Macro: </span><span><emphasis>void</emphasis> <strong>FD_CLR</strong> <emphasis>(int <var>filedes</var>, fd_set *<var>set</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-FD_005fCLR" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe race:set
| AS-Safe
| AC-Safe
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>This macro removes <var>filedes</var> from the file descriptor set <var>set</var>.
</para>
<para>The <var>filedes</var> parameter must not have side effects since it is
evaluated more than once.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-FD_005fISSET"><span class="category">Macro: </span><span><emphasis>int</emphasis> <strong>FD_ISSET</strong> <emphasis>(int <var>filedes</var>, const fd_set *<var>set</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-FD_005fISSET" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe race:set
| AS-Safe
| AC-Safe
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>This macro returns a nonzero value (true) if <var>filedes</var> is a member
of the file descriptor set <var>set</var>, and zero (false) otherwise.
</para>
<para>The <var>filedes</var> parameter must not have side effects since it is
evaluated more than once.
</para></dd></dl>

<para>Next, here is the description of the <code>select</code> function itself.
</para>
<dl class="def">
<dt xml:id="glibc-index-select"><span class="category">Function: </span><span><emphasis>int</emphasis> <strong>select</strong> <emphasis>(int <var>nfds</var>, fd_set *<var>read-fds</var>, fd_set *<var>write-fds</var>, fd_set *<var>except-fds</var>, struct timeval *<var>timeout</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-select" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe race:read-fds race:write-fds race:except-fds
| AS-Safe
| AC-Safe
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>The <code>select</code> function blocks the calling process until there is
activity on any of the specified sets of file descriptors, or until the
timeout period has expired.
</para>
<para>The file descriptors specified by the <var>read-fds</var> argument are
checked to see if they are ready for reading; the <var>write-fds</var> file
descriptors are checked to see if they are ready for writing; and the
<var>except-fds</var> file descriptors are checked for exceptional
conditions.  You can pass a null pointer for any of these arguments if
you are not interested in checking for that kind of condition.
</para>
<para>A file descriptor is considered ready for reading if a <code>read</code>
call will not block.  This usually includes the read offset being at
the end of the file or there is an error to report.  A server socket
is considered ready for reading if there is a pending connection which
can be accepted with <code>accept</code>; see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Accepting-Connections">Accepting Connections</a>.  A
client socket is ready for writing when its connection is fully
established; see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Connecting">Making a Connection</a>.
</para>
<para>“Exceptional conditions” does not mean errors—errors are reported
immediately when an erroneous system call is executed, and do not
constitute a state of the descriptor.  Rather, they include conditions
such as the presence of an urgent message on a socket.  (See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Sockets">Sockets</a>,
for information on urgent messages.)
</para>
<para>The <code>select</code> function checks only the first <var>nfds</var> file
descriptors.  The usual thing is to pass <code>FD_SETSIZE</code> as the value
of this argument.
</para>
<para>The <var>timeout</var> specifies the maximum time to wait.  If you pass a
null pointer for this argument, it means to block indefinitely until
one of the file descriptors is ready.  Otherwise, you should provide
the time in <code>struct timeval</code> format; see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Time-Types">Time Types</a>.
Specify zero as the time (a <code>struct timeval</code> containing all
zeros) if you want to find out which descriptors are ready without
waiting if none are ready.
</para>
<para>The normal return value from <code>select</code> is the total number of ready file
descriptors in all of the sets.  Each of the argument sets is overwritten
with information about the descriptors that are ready for the corresponding
operation.  Thus, to see if a particular descriptor <var>desc</var> has input,
use <code>FD_ISSET (<var>desc</var>, <var>read-fds</var>)</code> after <code>select</code> returns.
</para>
<para>If <code>select</code> returns because the timeout period expires, it returns
a value of zero.
</para>
<para>Any signal will cause <code>select</code> to return immediately.  So if your
program uses signals, you can’t rely on <code>select</code> to keep waiting
for the full time specified.  If you want to be sure of waiting for a
particular amount of time, you must check for <code>EINTR</code> and repeat
the <code>select</code> with a newly calculated timeout based on the current
time.  See the example below.  See also <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Interrupted-Primitives">Primitives Interrupted by Signals</a>.
</para>
<para>If an error occurs, <code>select</code> returns <code>-1</code> and does not modify
the argument file descriptor sets.  The following <code>errno</code> error
conditions are defined for this function:
</para>
<dl compact="compact">
<dt><span><code>EBADF</code></span></dt>
<dd><para>One of the file descriptor sets specified an invalid file descriptor.
</para>
</dd>
<dt><span><code>EINTR</code></span></dt>
<dd><para>The operation was interrupted by a signal.  See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Interrupted-Primitives">Primitives Interrupted by Signals</a>.
</para>
</dd>
<dt><span><code>EINVAL</code></span></dt>
<dd><para>The <var>timeout</var> argument is invalid; one of the components is negative
or too large.
</para></dd>
</dl>
</dd></dl>

<para><strong>Portability Note:</strong>  The <code>select</code> function is a BSD Unix
feature.
</para>
<para>Here is an example showing how you can use <code>select</code> to establish a
timeout period for reading from a file descriptor.  The <code>input_timeout</code>
function blocks the calling process until input is available on the
file descriptor, or until the timeout period expires.
</para>
<div class="example">
<pre class="example">
</pre><pre class="example">#include &lt;errno.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/time.h&gt;
</pre><pre class="example">
</pre><pre class="example">int
input_timeout (int filedes, unsigned int seconds)
{
  fd_set set;
  struct timeval timeout;
</pre><pre class="example">
  /* <span class="roman">Initialize the file descriptor set.</span> */
  FD_ZERO (&amp;set);
  FD_SET (filedes, &amp;set);

  /* <span class="roman">Initialize the timeout data structure.</span> */
  timeout.tv_sec = seconds;
  timeout.tv_usec = 0;

</pre><pre class="example">  /* <span class="roman"><code>select</code> returns 0 if timeout, 1 if input available, -1 if error.</span> */
  return TEMP_FAILURE_RETRY (select (FD_SETSIZE,
                                     &amp;set, NULL, NULL,
                                     &amp;timeout));
}
</pre><pre class="example">
</pre><pre class="example">int
main (void)
{
  fprintf (stderr, "select returned %d.\n",
           input_timeout (STDIN_FILENO, 5));
  return 0;
}
</pre></div>

<para>There is another example showing the use of <code>select</code> to multiplex
input from multiple sockets in <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Server-Example">Byte Stream Connection Server Example</a>.
</para>

<hr>
</div>
<sect xml:id="glibc-Synchronizing-I_002fO">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Asynchronous-I_002fO" accesskey="n" rel="next">Perform I/O Operations in Parallel</a>, Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Waiting-for-I_002fO" accesskey="p" rel="prev">Waiting for Input or Output</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Low_002dLevel-I_002fO" accesskey="u" rel="up">Low-Level Input/Output</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Synchronizing-I_002fO-operations"></span><h3 class="section">13.10 Synchronizing I/O operations</title>

<span xml:id="glibc-index-synchronizing"></span>
<para>In most modern operating systems, the normal I/O operations are not
executed synchronously.  I.e., even if a <code>write</code> system call
returns, this does not mean the data is actually written to the media,
e.g., the disk.
</para>
<para>In situations where synchronization points are necessary, you can use
special functions which ensure that all operations finish before
they return.
</para>
<dl class="def">
<dt xml:id="glibc-index-sync"><span class="category">Function: </span><span><emphasis>void</emphasis> <strong>sync</strong> <emphasis>(void)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-sync" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Safe
| AC-Safe
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>A call to this function will not return as long as there is data which
has not been written to the device.  All dirty buffers in the kernel will
be written and so an overall consistent system can be achieved (if no
other process in parallel writes data).
</para>
<para>A prototype for <code>sync</code> can be found in <filename>unistd.h</filename>.
</para></dd></dl>

<para>Programs more often want to ensure that data written to a given file is
committed, rather than all data in the system.  For this, <code>sync</code> is overkill.
</para>

<dl class="def">
<dt xml:id="glibc-index-fsync"><span class="category">Function: </span><span><emphasis>int</emphasis> <strong>fsync</strong> <emphasis>(int <var>fildes</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-fsync" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Safe
| AC-Safe
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>The <code>fsync</code> function can be used to make sure all data associated with
the open file <var>fildes</var> is written to the device associated with the
descriptor.  The function call does not return unless all actions have
finished.
</para>
<para>A prototype for <code>fsync</code> can be found in <filename>unistd.h</filename>.
</para>
<para>This function is a cancellation point in multi-threaded programs.  This
is a problem if the thread allocates some resources (like memory, file
descriptors, semaphores or whatever) at the time <code>fsync</code> is
called.  If the thread gets canceled these resources stay allocated
until the program ends.  To avoid this, calls to <code>fsync</code> should be
protected using cancellation handlers.
</para>
<para>The return value of the function is zero if no error occurred.  Otherwise
it is <em class="math">-1</emphasis> and the global variable <code>errno</code> is set to the
following values:
</para><dl compact="compact">
<dt><span><code>EBADF</code></span></dt>
<dd><para>The descriptor <var>fildes</var> is not valid.
</para>
</dd>
<dt><span><code>EINVAL</code></span></dt>
<dd><para>No synchronization is possible since the system does not implement this.
</para></dd>
</dl>
</dd></dl>

<para>Sometimes it is not even necessary to write all data associated with a
file descriptor.  E.g., in database files which do not change in size it
is enough to write all the file content data to the device.
Meta-information, like the modification time etc., are not that important
and leaving such information uncommitted does not prevent a successful
recovery of the file in case of a problem.
</para>
<dl class="def">
<dt xml:id="glibc-index-fdatasync"><span class="category">Function: </span><span><emphasis>int</emphasis> <strong>fdatasync</strong> <emphasis>(int <var>fildes</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-fdatasync" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Safe
| AC-Safe
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>When a call to the <code>fdatasync</code> function returns, it is ensured
that all of the file data is written to the device.  For all pending I/O
operations, the parts guaranteeing data integrity finished.
</para>
<para>Not all systems implement the <code>fdatasync</code> operation.  On systems
missing this functionality <code>fdatasync</code> is emulated by a call to
<code>fsync</code> since the performed actions are a superset of those
required by <code>fdatasync</code>.
</para>
<para>The prototype for <code>fdatasync</code> is in <filename>unistd.h</filename>.
</para>
<para>The return value of the function is zero if no error occurred.  Otherwise
it is <em class="math">-1</emphasis> and the global variable <code>errno</code> is set to the
following values:
</para><dl compact="compact">
<dt><span><code>EBADF</code></span></dt>
<dd><para>The descriptor <var>fildes</var> is not valid.
</para>
</dd>
<dt><span><code>EINVAL</code></span></dt>
<dd><para>No synchronization is possible since the system does not implement this.
</para></dd>
</dl>
</dd></dl>


<hr>
</div>
<sect xml:id="glibc-Asynchronous-I_002fO">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Control-Operations" accesskey="n" rel="next">Control Operations on Files</a>, Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Synchronizing-I_002fO" accesskey="p" rel="prev">Synchronizing I/O operations</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Low_002dLevel-I_002fO" accesskey="u" rel="up">Low-Level Input/Output</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Perform-I_002fO-Operations-in-Parallel"></span><h3 class="section">13.11 Perform I/O Operations in Parallel</title>

<para>The POSIX.1b standard defines a new set of I/O operations which can
significantly reduce the time an application spends waiting for I/O.  The
new functions allow a program to initiate one or more I/O operations and
then immediately resume normal work while the I/O operations are
executed in parallel.  This functionality is available if the
<filename>unistd.h</filename> file defines the symbol <code>_POSIX_ASYNCHRONOUS_IO</code>.
</para>
<para>These functions are part of the library with realtime functions named
<filename>librt</filename>.  They are not actually part of the <filename>libc</filename> binary.
The implementation of these functions can be done using support in the
kernel (if available) or using an implementation based on threads at
userlevel.  In the latter case it might be necessary to link applications
with the thread library <filename>libpthread</filename> in addition to <filename>librt</filename>.
</para>
<para>All AIO operations operate on files which were opened previously.  There
might be arbitrarily many operations running for one file.  The
asynchronous I/O operations are controlled using a data structure named
<code>struct aiocb</code> (<emphasis>AIO control block</emphasis>).  It is defined in
<filename>aio.h</filename> as follows.
</para>
<dl class="def">
<dt xml:id="glibc-index-struct-aiocb"><span class="category">Data Type: </span><span><strong>struct aiocb</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-struct-aiocb" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>The POSIX.1b standard mandates that the <code>struct aiocb</code> structure
contains at least the members described in the following table.  There
might be more elements which are used by the implementation, but
depending upon these elements is not portable and is highly deprecated.
</para>
<dl compact="compact">
<dt><span><code>int aio_fildes</code></span></dt>
<dd><para>This element specifies the file descriptor to be used for the
operation.  It must be a legal descriptor, otherwise the operation will
fail.
</para>
<para>The device on which the file is opened must allow the seek operation.
I.e., it is not possible to use any of the AIO operations on devices
like terminals where an <code>lseek</code> call would lead to an error.
</para>
</dd>
<dt><span><code>off_t aio_offset</code></span></dt>
<dd><para>This element specifies the offset in the file at which the operation (input
or output) is performed.  Since the operations are carried out in arbitrary
order and more than one operation for one file descriptor can be
started, one cannot expect a current read/write position of the file
descriptor.
</para>
</dd>
<dt><span><code>volatile void *aio_buf</code></span></dt>
<dd><para>This is a pointer to the buffer with the data to be written or the place
where the read data is stored.
</para>
</dd>
<dt><span><code>size_t aio_nbytes</code></span></dt>
<dd><para>This element specifies the length of the buffer pointed to by <code>aio_buf</code>.
</para>
</dd>
<dt><span><code>int aio_reqprio</code></span></dt>
<dd><para>If the platform has defined <code>_POSIX_PRIORITIZED_IO</code> and
<code>_POSIX_PRIORITY_SCHEDULING</code>, the AIO requests are
processed based on the current scheduling priority.  The
<code>aio_reqprio</code> element can then be used to lower the priority of the
AIO operation.
</para>
</dd>
<dt><span><code>struct sigevent aio_sigevent</code></span></dt>
<dd><para>This element specifies how the calling process is notified once the
operation terminates.  If the <code>sigev_notify</code> element is
<code>SIGEV_NONE</code>, no notification is sent.  If it is <code>SIGEV_SIGNAL</code>,
the signal determined by <code>sigev_signo</code> is sent.  Otherwise,
<code>sigev_notify</code> must be <code>SIGEV_THREAD</code>.  In this case, a thread
is created which starts executing the function pointed to by
<code>sigev_notify_function</code>.
</para>
</dd>
<dt><span><code>int aio_lio_opcode</code></span></dt>
<dd><para>This element is only used by the <code>lio_listio</code> and
<code>lio_listio64</code> functions.  Since these functions allow an
arbitrary number of operations to start at once, and each operation can be
input or output (or nothing), the information must be stored in the
control block.  The possible values are:
</para>
<dl compact="compact">
<dt xml:id="glibc-index-LIO_005fREAD"><span><code>LIO_READ</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-LIO_005fREAD" class="copiable-anchor"> ¶</a></span></dt>
<dd><para>Start a read operation.  Read from the file at position
<code>aio_offset</code> and store the next <code>aio_nbytes</code> bytes in the
buffer pointed to by <code>aio_buf</code>.
</para>
</dd>
<dt xml:id="glibc-index-LIO_005fWRITE"><span><code>LIO_WRITE</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-LIO_005fWRITE" class="copiable-anchor"> ¶</a></span></dt>
<dd><para>Start a write operation.  Write <code>aio_nbytes</code> bytes starting at
<code>aio_buf</code> into the file starting at position <code>aio_offset</code>.
</para>
</dd>
<dt xml:id="glibc-index-LIO_005fNOP"><span><code>LIO_NOP</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-LIO_005fNOP" class="copiable-anchor"> ¶</a></span></dt>
<dd><para>Do nothing for this control block.  This value is useful sometimes when
an array of <code>struct aiocb</code> values contains holes, i.e., some of the
values must not be handled although the whole array is presented to the
<code>lio_listio</code> function.
</para></dd>
</dl>
</dd>
</dl>

<para>When the sources are compiled using <code>_FILE_OFFSET_BITS == 64</code> on a
32 bit machine, this type is in fact <code>struct aiocb64</code>, since the LFS
interface transparently replaces the <code>struct aiocb</code> definition.
</para></dd></dl>

<para>For use with the AIO functions defined in the LFS, there is a similar type
defined which replaces the types of the appropriate members with larger
types but otherwise is equivalent to <code>struct aiocb</code>.  Particularly,
all member names are the same.
</para>
<dl class="def">
<dt xml:id="glibc-index-struct-aiocb64"><span class="category">Data Type: </span><span><strong>struct aiocb64</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-struct-aiocb64" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<dl compact="compact">
<dt><span><code>int aio_fildes</code></span></dt>
<dd><para>This element specifies the file descriptor which is used for the
operation.  It must be a legal descriptor since otherwise the operation
fails for obvious reasons.
</para>
<para>The device on which the file is opened must allow the seek operation.
I.e., it is not possible to use any of the AIO operations on devices
like terminals where an <code>lseek</code> call would lead to an error.
</para>
</dd>
<dt><span><code>off64_t aio_offset</code></span></dt>
<dd><para>This element specifies at which offset in the file the operation (input
or output) is performed.  Since the operation are carried in arbitrary
order and more than one operation for one file descriptor can be
started, one cannot expect a current read/write position of the file
descriptor.
</para>
</dd>
<dt><span><code>volatile void *aio_buf</code></span></dt>
<dd><para>This is a pointer to the buffer with the data to be written or the place
where the read data is stored.
</para>
</dd>
<dt><span><code>size_t aio_nbytes</code></span></dt>
<dd><para>This element specifies the length of the buffer pointed to by <code>aio_buf</code>.
</para>
</dd>
<dt><span><code>int aio_reqprio</code></span></dt>
<dd><para>If for the platform <code>_POSIX_PRIORITIZED_IO</code> and
<code>_POSIX_PRIORITY_SCHEDULING</code> are defined the AIO requests are
processed based on the current scheduling priority.  The
<code>aio_reqprio</code> element can then be used to lower the priority of the
AIO operation.
</para>
</dd>
<dt><span><code>struct sigevent aio_sigevent</code></span></dt>
<dd><para>This element specifies how the calling process is notified once the
operation terminates.  If the <code>sigev_notify</code> element is
<code>SIGEV_NONE</code> no notification is sent.  If it is <code>SIGEV_SIGNAL</code>,
the signal determined by <code>sigev_signo</code> is sent.  Otherwise,
<code>sigev_notify</code> must be <code>SIGEV_THREAD</code> in which case a thread
is created which starts executing the function pointed to by
<code>sigev_notify_function</code>.
</para>
</dd>
<dt><span><code>int aio_lio_opcode</code></span></dt>
<dd><para>This element is only used by the <code>lio_listio</code> and
<code>lio_listio64</code> functions.  Since these functions allow an
arbitrary number of operations to start at once, and since each operation can be
input or output (or nothing), the information must be stored in the
control block.  See the description of <code>struct aiocb</code> for a description
of the possible values.
</para></dd>
</dl>

<para>When the sources are compiled using <code>_FILE_OFFSET_BITS == 64</code> on a
32 bit machine, this type is available under the name <code>struct
aiocb64</code>, since the LFS transparently replaces the old interface.
</para></dd></dl>


<ul class="section-toc">
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Asynchronous-Reads_002fWrites" accesskey="1">Asynchronous Read and Write Operations</a></li>
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Status-of-AIO-Operations" accesskey="2">Getting the Status of AIO Operations</a></li>
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Synchronizing-AIO-Operations" accesskey="3">Getting into a Consistent State</a></li>
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Cancel-AIO-Operations" accesskey="4">Cancellation of AIO Operations</a></li>
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Configuration-of-AIO" accesskey="5">How to optimize the AIO implementation</a></li>
</ul>
<hr>
<div class="subsection" xml:id="glibc-Asynchronous-Reads_002fWrites">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Status-of-AIO-Operations" accesskey="n" rel="next">Getting the Status of AIO Operations</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Asynchronous-I_002fO" accesskey="u" rel="up">Perform I/O Operations in Parallel</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Asynchronous-Read-and-Write-Operations"></span><h4 class="subsection">13.11.1 Asynchronous Read and Write Operations</title>

<dl class="def">
<dt xml:id="glibc-index-aio_005fread"><span class="category">Function: </span><span><emphasis>int</emphasis> <strong>aio_read</strong> <emphasis>(struct aiocb *<var>aiocbp</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-aio_005fread" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Unsafe lock heap
| AC-Unsafe lock mem
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>



<para>This function initiates an asynchronous read operation.  It
immediately returns after the operation was enqueued or when an
error was encountered.
</para>
<para>The first <code>aiocbp-&gt;aio_nbytes</code> bytes of the file for which
<code>aiocbp-&gt;aio_fildes</code> is a descriptor are written to the buffer
starting at <code>aiocbp-&gt;aio_buf</code>.  Reading starts at the absolute
position <code>aiocbp-&gt;aio_offset</code> in the file.
</para>
<para>If prioritized I/O is supported by the platform the
<code>aiocbp-&gt;aio_reqprio</code> value is used to adjust the priority before
the request is actually enqueued.
</para>
<para>The calling process is notified about the termination of the read
request according to the <code>aiocbp-&gt;aio_sigevent</code> value.
</para>
<para>When <code>aio_read</code> returns, the return value is zero if no error
occurred that can be found before the process is enqueued.  If such an
early error is found, the function returns <em class="math">-1</emphasis> and sets
<code>errno</code> to one of the following values:
</para>
<dl compact="compact">
<dt><span><code>EAGAIN</code></span></dt>
<dd><para>The request was not enqueued due to (temporarily) exceeded resource
limitations.
</para></dd>
<dt><span><code>ENOSYS</code></span></dt>
<dd><para>The <code>aio_read</code> function is not implemented.
</para></dd>
<dt><span><code>EBADF</code></span></dt>
<dd><para>The <code>aiocbp-&gt;aio_fildes</code> descriptor is not valid.  This condition
need not be recognized before enqueueing the request and so this error
might also be signaled asynchronously.
</para></dd>
<dt><span><code>EINVAL</code></span></dt>
<dd><para>The <code>aiocbp-&gt;aio_offset</code> or <code>aiocbp-&gt;aio_reqpiro</code> value is
invalid.  This condition need not be recognized before enqueueing the
request and so this error might also be signaled asynchronously.
</para></dd>
</dl>

<para>If <code>aio_read</code> returns zero, the current status of the request
can be queried using <code>aio_error</code> and <code>aio_return</code> functions.
As long as the value returned by <code>aio_error</code> is <code>EINPROGRESS</code>
the operation has not yet completed.  If <code>aio_error</code> returns zero,
the operation successfully terminated, otherwise the value is to be
interpreted as an error code.  If the function terminated, the result of
the operation can be obtained using a call to <code>aio_return</code>.  The
returned value is the same as an equivalent call to <code>read</code> would
have returned.  Possible error codes returned by <code>aio_error</code> are:
</para>
<dl compact="compact">
<dt><span><code>EBADF</code></span></dt>
<dd><para>The <code>aiocbp-&gt;aio_fildes</code> descriptor is not valid.
</para></dd>
<dt><span><code>ECANCELED</code></span></dt>
<dd><para>The operation was canceled before the operation was finished
(see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Cancel-AIO-Operations">Cancellation of AIO Operations</a>)
</para></dd>
<dt><span><code>EINVAL</code></span></dt>
<dd><para>The <code>aiocbp-&gt;aio_offset</code> value is invalid.
</para></dd>
</dl>

<para>When the sources are compiled with <code>_FILE_OFFSET_BITS == 64</code> this
function is in fact <code>aio_read64</code> since the LFS interface transparently
replaces the normal implementation.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-aio_005fread64"><span class="category">Function: </span><span><emphasis>int</emphasis> <strong>aio_read64</strong> <emphasis>(struct aiocb64 *<var>aiocbp</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-aio_005fread64" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Unsafe lock heap
| AC-Unsafe lock mem
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>This function is similar to the <code>aio_read</code> function.  The only
difference is that on 32&nbsp;bit machines, the file descriptor should
be opened in the large file mode.  Internally, <code>aio_read64</code> uses
functionality equivalent to <code>lseek64</code> (see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#File-Position-Primitive">Setting the File Position of a Descriptor</a>) to position the file descriptor correctly for the reading,
as opposed to the <code>lseek</code> functionality used in <code>aio_read</code>.
</para>
<para>When the sources are compiled with <code>_FILE_OFFSET_BITS == 64</code>, this
function is available under the name <code>aio_read</code> and so transparently
replaces the interface for small files on 32 bit machines.
</para></dd></dl>

<para>To write data asynchronously to a file, there exists an equivalent pair
of functions with a very similar interface.
</para>
<dl class="def">
<dt xml:id="glibc-index-aio_005fwrite"><span class="category">Function: </span><span><emphasis>int</emphasis> <strong>aio_write</strong> <emphasis>(struct aiocb *<var>aiocbp</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-aio_005fwrite" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Unsafe lock heap
| AC-Unsafe lock mem
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>This function initiates an asynchronous write operation.  The function
call immediately returns after the operation was enqueued or if before
this happens an error was encountered.
</para>
<para>The first <code>aiocbp-&gt;aio_nbytes</code> bytes from the buffer starting at
<code>aiocbp-&gt;aio_buf</code> are written to the file for which
<code>aiocbp-&gt;aio_fildes</code> is a descriptor, starting at the absolute
position <code>aiocbp-&gt;aio_offset</code> in the file.
</para>
<para>If prioritized I/O is supported by the platform, the
<code>aiocbp-&gt;aio_reqprio</code> value is used to adjust the priority before
the request is actually enqueued.
</para>
<para>The calling process is notified about the termination of the read
request according to the <code>aiocbp-&gt;aio_sigevent</code> value.
</para>
<para>When <code>aio_write</code> returns, the return value is zero if no error
occurred that can be found before the process is enqueued.  If such an
early error is found the function returns <em class="math">-1</emphasis> and sets
<code>errno</code> to one of the following values.
</para>
<dl compact="compact">
<dt><span><code>EAGAIN</code></span></dt>
<dd><para>The request was not enqueued due to (temporarily) exceeded resource
limitations.
</para></dd>
<dt><span><code>ENOSYS</code></span></dt>
<dd><para>The <code>aio_write</code> function is not implemented.
</para></dd>
<dt><span><code>EBADF</code></span></dt>
<dd><para>The <code>aiocbp-&gt;aio_fildes</code> descriptor is not valid.  This condition
may not be recognized before enqueueing the request, and so this error
might also be signaled asynchronously.
</para></dd>
<dt><span><code>EINVAL</code></span></dt>
<dd><para>The <code>aiocbp-&gt;aio_offset</code> or <code>aiocbp-&gt;aio_reqprio</code> value is
invalid.  This condition may not be recognized before enqueueing the
request and so this error might also be signaled asynchronously.
</para></dd>
</dl>

<para>In the case <code>aio_write</code> returns zero, the current status of the
request can be queried using the <code>aio_error</code> and <code>aio_return</code>
functions.  As long as the value returned by <code>aio_error</code> is
<code>EINPROGRESS</code> the operation has not yet completed.  If
<code>aio_error</code> returns zero, the operation successfully terminated,
otherwise the value is to be interpreted as an error code.  If the
function terminated, the result of the operation can be obtained using a call
to <code>aio_return</code>.  The returned value is the same as an equivalent
call to <code>read</code> would have returned.  Possible error codes returned
by <code>aio_error</code> are:
</para>
<dl compact="compact">
<dt><span><code>EBADF</code></span></dt>
<dd><para>The <code>aiocbp-&gt;aio_fildes</code> descriptor is not valid.
</para></dd>
<dt><span><code>ECANCELED</code></span></dt>
<dd><para>The operation was canceled before the operation was finished.
(see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Cancel-AIO-Operations">Cancellation of AIO Operations</a>)
</para></dd>
<dt><span><code>EINVAL</code></span></dt>
<dd><para>The <code>aiocbp-&gt;aio_offset</code> value is invalid.
</para></dd>
</dl>

<para>When the sources are compiled with <code>_FILE_OFFSET_BITS == 64</code>, this
function is in fact <code>aio_write64</code> since the LFS interface transparently
replaces the normal implementation.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-aio_005fwrite64"><span class="category">Function: </span><span><emphasis>int</emphasis> <strong>aio_write64</strong> <emphasis>(struct aiocb64 *<var>aiocbp</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-aio_005fwrite64" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Unsafe lock heap
| AC-Unsafe lock mem
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>This function is similar to the <code>aio_write</code> function.  The only
difference is that on 32&nbsp;bit machines the file descriptor should
be opened in the large file mode.  Internally <code>aio_write64</code> uses
functionality equivalent to <code>lseek64</code> (see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#File-Position-Primitive">Setting the File Position of a Descriptor</a>) to position the file descriptor correctly for the writing,
as opposed to the <code>lseek</code> functionality used in <code>aio_write</code>.
</para>
<para>When the sources are compiled with <code>_FILE_OFFSET_BITS == 64</code>, this
function is available under the name <code>aio_write</code> and so transparently
replaces the interface for small files on 32 bit machines.
</para></dd></dl>

<para>Besides these functions with the more or less traditional interface,
POSIX.1b also defines a function which can initiate more than one
operation at a time, and which can handle freely mixed read and write
operations.  It is therefore similar to a combination of <code>readv</code> and
<code>writev</code>.
</para>
<dl class="def">
<dt xml:id="glibc-index-lio_005flistio"><span class="category">Function: </span><span><emphasis>int</emphasis> <strong>lio_listio</strong> <emphasis>(int <var>mode</var>, struct aiocb *const <var>list</var>[], int <var>nent</var>, struct sigevent *<var>sig</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-lio_005flistio" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Unsafe lock heap
| AC-Unsafe lock mem
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>The <code>lio_listio</code> function can be used to enqueue an arbitrary
number of read and write requests at one time.  The requests can all be
meant for the same file, all for different files or every solution in
between.
</para>
<para><code>lio_listio</code> gets the <var>nent</var> requests from the array pointed to
by <var>list</var>.  The operation to be performed is determined by the
<code>aio_lio_opcode</code> member in each element of <var>list</var>.  If this
field is <code>LIO_READ</code> a read operation is enqueued, similar to a call
of <code>aio_read</code> for this element of the array (except that the way
the termination is signalled is different, as we will see below).  If
the <code>aio_lio_opcode</code> member is <code>LIO_WRITE</code> a write operation
is enqueued.  Otherwise the <code>aio_lio_opcode</code> must be <code>LIO_NOP</code>
in which case this element of <var>list</var> is simply ignored.  This
“operation” is useful in situations where one has a fixed array of
<code>struct aiocb</code> elements from which only a few need to be handled at
a time.  Another situation is where the <code>lio_listio</code> call was
canceled before all requests are processed (see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Cancel-AIO-Operations">Cancellation of AIO Operations</a>) and the remaining requests have to be reissued.
</para>
<para>The other members of each element of the array pointed to by
<code>list</code> must have values suitable for the operation as described in
the documentation for <code>aio_read</code> and <code>aio_write</code> above.
</para>
<para>The <var>mode</var> argument determines how <code>lio_listio</code> behaves after
having enqueued all the requests.  If <var>mode</var> is <code>LIO_WAIT</code> it
waits until all requests terminated.  Otherwise <var>mode</var> must be
<code>LIO_NOWAIT</code> and in this case the function returns immediately after
having enqueued all the requests.  In this case the caller gets a
notification of the termination of all requests according to the
<var>sig</var> parameter.  If <var>sig</var> is <code>NULL</code> no notification is
sent.  Otherwise a signal is sent or a thread is started, just as
described in the description for <code>aio_read</code> or <code>aio_write</code>.
</para>
<para>If <var>mode</var> is <code>LIO_WAIT</code>, the return value of <code>lio_listio</code>
is <em class="math">0</emphasis> when all requests completed successfully.  Otherwise the
function returns <em class="math">-1</emphasis> and <code>errno</code> is set accordingly.  To find
out which request or requests failed one has to use the <code>aio_error</code>
function on all the elements of the array <var>list</var>.
</para>
<para>In case <var>mode</var> is <code>LIO_NOWAIT</code>, the function returns <em class="math">0</emphasis> if
all requests were enqueued correctly.  The current state of the requests
can be found using <code>aio_error</code> and <code>aio_return</code> as described
above.  If <code>lio_listio</code> returns <em class="math">-1</emphasis> in this mode, the
global variable <code>errno</code> is set accordingly.  If a request did not
yet terminate, a call to <code>aio_error</code> returns <code>EINPROGRESS</code>.  If
the value is different, the request is finished and the error value (or
<em class="math">0</emphasis>) is returned and the result of the operation can be retrieved
using <code>aio_return</code>.
</para>
<para>Possible values for <code>errno</code> are:
</para>
<dl compact="compact">
<dt><span><code>EAGAIN</code></span></dt>
<dd><para>The resources necessary to queue all the requests are not available at
the moment.  The error status for each element of <var>list</var> must be
checked to determine which request failed.
</para>
<para>Another reason could be that the system wide limit of AIO requests is
exceeded.  This cannot be the case for the implementation on GNU systems
since no arbitrary limits exist.
</para></dd>
<dt><span><code>EINVAL</code></span></dt>
<dd><para>The <var>mode</var> parameter is invalid or <var>nent</var> is larger than
<code>AIO_LISTIO_MAX</code>.
</para></dd>
<dt><span><code>EIO</code></span></dt>
<dd><para>One or more of the request’s I/O operations failed.  The error status of
each request should be checked to determine which one failed.
</para></dd>
<dt><span><code>ENOSYS</code></span></dt>
<dd><para>The <code>lio_listio</code> function is not supported.
</para></dd>
</dl>

<para>If the <var>mode</var> parameter is <code>LIO_NOWAIT</code> and the caller cancels
a request, the error status for this request returned by
<code>aio_error</code> is <code>ECANCELED</code>.
</para>
<para>When the sources are compiled with <code>_FILE_OFFSET_BITS == 64</code>, this
function is in fact <code>lio_listio64</code> since the LFS interface
transparently replaces the normal implementation.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-lio_005flistio64"><span class="category">Function: </span><span><emphasis>int</emphasis> <strong>lio_listio64</strong> <emphasis>(int <var>mode</var>, struct aiocb64 *const <var>list</var>[], int <var>nent</var>, struct sigevent *<var>sig</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-lio_005flistio64" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Unsafe lock heap
| AC-Unsafe lock mem
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>This function is similar to the <code>lio_listio</code> function.  The only
difference is that on 32&nbsp;bit machines, the file descriptor should
be opened in the large file mode.  Internally, <code>lio_listio64</code> uses
functionality equivalent to <code>lseek64</code> (see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#File-Position-Primitive">Setting the File Position of a Descriptor</a>) to position the file descriptor correctly for the reading or
writing, as opposed to the <code>lseek</code> functionality used in
<code>lio_listio</code>.
</para>
<para>When the sources are compiled with <code>_FILE_OFFSET_BITS == 64</code>, this
function is available under the name <code>lio_listio</code> and so
transparently replaces the interface for small files on 32 bit
machines.
</para></dd></dl>

<hr>
</div>
<div class="subsection" xml:id="glibc-Status-of-AIO-Operations">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Synchronizing-AIO-Operations" accesskey="n" rel="next">Getting into a Consistent State</a>, Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Asynchronous-Reads_002fWrites" accesskey="p" rel="prev">Asynchronous Read and Write Operations</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Asynchronous-I_002fO" accesskey="u" rel="up">Perform I/O Operations in Parallel</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Getting-the-Status-of-AIO-Operations"></span><h4 class="subsection">13.11.2 Getting the Status of AIO Operations</title>

<para>As already described in the documentation of the functions in the last
section, it must be possible to get information about the status of an I/O
request.  When the operation is performed truly asynchronously (as with
<code>aio_read</code> and <code>aio_write</code> and with <code>lio_listio</code> when the
mode is <code>LIO_NOWAIT</code>), one sometimes needs to know whether a
specific request already terminated and if so, what the result was.
The following two functions allow you to get this kind of information.
</para>
<dl class="def">
<dt xml:id="glibc-index-aio_005ferror"><span class="category">Function: </span><span><emphasis>int</emphasis> <strong>aio_error</strong> <emphasis>(const struct aiocb *<var>aiocbp</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-aio_005ferror" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Safe
| AC-Safe
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>This function determines the error state of the request described by the
<code>struct aiocb</code> variable pointed to by <var>aiocbp</var>.  If the
request has not yet terminated the value returned is always
<code>EINPROGRESS</code>.  Once the request has terminated the value
<code>aio_error</code> returns is either <em class="math">0</emphasis> if the request completed
successfully or it returns the value which would be stored in the
<code>errno</code> variable if the request would have been done using
<code>read</code>, <code>write</code>, or <code>fsync</code>.
</para>
<para>The function can return <code>ENOSYS</code> if it is not implemented.  It
could also return <code>EINVAL</code> if the <var>aiocbp</var> parameter does not
refer to an asynchronous operation whose return status is not yet known.
</para>
<para>When the sources are compiled with <code>_FILE_OFFSET_BITS == 64</code> this
function is in fact <code>aio_error64</code> since the LFS interface
transparently replaces the normal implementation.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-aio_005ferror64"><span class="category">Function: </span><span><emphasis>int</emphasis> <strong>aio_error64</strong> <emphasis>(const struct aiocb64 *<var>aiocbp</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-aio_005ferror64" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Safe
| AC-Safe
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>This function is similar to <code>aio_error</code> with the only difference
that the argument is a reference to a variable of type <code>struct
aiocb64</code>.
</para>
<para>When the sources are compiled with <code>_FILE_OFFSET_BITS == 64</code> this
function is available under the name <code>aio_error</code> and so
transparently replaces the interface for small files on 32 bit
machines.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-aio_005freturn"><span class="category">Function: </span><span><emphasis>ssize_t</emphasis> <strong>aio_return</strong> <emphasis>(struct aiocb *<var>aiocbp</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-aio_005freturn" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Safe
| AC-Safe
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>This function can be used to retrieve the return status of the operation
carried out by the request described in the variable pointed to by
<var>aiocbp</var>.  As long as the error status of this request as returned
by <code>aio_error</code> is <code>EINPROGRESS</code> the return value of this function is
undefined.
</para>
<para>Once the request is finished this function can be used exactly once to
retrieve the return value.  Following calls might lead to undefined
behavior.  The return value itself is the value which would have been
returned by the <code>read</code>, <code>write</code>, or <code>fsync</code> call.
</para>
<para>The function can return <code>ENOSYS</code> if it is not implemented.  It
could also return <code>EINVAL</code> if the <var>aiocbp</var> parameter does not
refer to an asynchronous operation whose return status is not yet known.
</para>
<para>When the sources are compiled with <code>_FILE_OFFSET_BITS == 64</code> this
function is in fact <code>aio_return64</code> since the LFS interface
transparently replaces the normal implementation.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-aio_005freturn64"><span class="category">Function: </span><span><emphasis>ssize_t</emphasis> <strong>aio_return64</strong> <emphasis>(struct aiocb64 *<var>aiocbp</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-aio_005freturn64" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Safe
| AC-Safe
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>This function is similar to <code>aio_return</code> with the only difference
that the argument is a reference to a variable of type <code>struct
aiocb64</code>.
</para>
<para>When the sources are compiled with <code>_FILE_OFFSET_BITS == 64</code> this
function is available under the name <code>aio_return</code> and so
transparently replaces the interface for small files on 32 bit
machines.
</para></dd></dl>

<hr>
</div>
<div class="subsection" xml:id="glibc-Synchronizing-AIO-Operations">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Cancel-AIO-Operations" accesskey="n" rel="next">Cancellation of AIO Operations</a>, Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Status-of-AIO-Operations" accesskey="p" rel="prev">Getting the Status of AIO Operations</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Asynchronous-I_002fO" accesskey="u" rel="up">Perform I/O Operations in Parallel</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Getting-into-a-Consistent-State"></span><h4 class="subsection">13.11.3 Getting into a Consistent State</title>

<para>When dealing with asynchronous operations it is sometimes necessary to
get into a consistent state.  This would mean for AIO that one wants to
know whether a certain request or a group of requests were processed.
This could be done by waiting for the notification sent by the system
after the operation terminated, but this sometimes would mean wasting
resources (mainly computation time).  Instead POSIX.1b defines two
functions which will help with most kinds of consistency.
</para>
<para>The <code>aio_fsync</code> and <code>aio_fsync64</code> functions are only available
if the symbol <code>_POSIX_SYNCHRONIZED_IO</code> is defined in <filename>unistd.h</filename>.
</para>
<span xml:id="glibc-index-synchronizing-1"></span>
<dl class="def">
<dt xml:id="glibc-index-aio_005ffsync"><span class="category">Function: </span><span><emphasis>int</emphasis> <strong>aio_fsync</strong> <emphasis>(int <var>op</var>, struct aiocb *<var>aiocbp</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-aio_005ffsync" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Unsafe lock heap
| AC-Unsafe lock mem
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>Calling this function forces all I/O operations queued at the
time of the function call operating on the file descriptor
<code>aiocbp-&gt;aio_fildes</code> into the synchronized I/O completion state
(see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Synchronizing-I_002fO">Synchronizing I/O operations</a>).  The <code>aio_fsync</code> function returns
immediately but the notification through the method described in
<code>aiocbp-&gt;aio_sigevent</code> will happen only after all requests for this
file descriptor have terminated and the file is synchronized.  This also
means that requests for this very same file descriptor which are queued
after the synchronization request are not affected.
</para>
<para>If <var>op</var> is <code>O_DSYNC</code> the synchronization happens as with a call
to <code>fdatasync</code>.  Otherwise <var>op</var> should be <code>O_SYNC</code> and
the synchronization happens as with <code>fsync</code>.
</para>
<para>As long as the synchronization has not happened, a call to
<code>aio_error</code> with the reference to the object pointed to by
<var>aiocbp</var> returns <code>EINPROGRESS</code>.  Once the synchronization is
done <code>aio_error</code> return <em class="math">0</emphasis> if the synchronization was not
successful.  Otherwise the value returned is the value to which the
<code>fsync</code> or <code>fdatasync</code> function would have set the
<code>errno</code> variable.  In this case nothing can be assumed about the
consistency of the data written to this file descriptor.
</para>
<para>The return value of this function is <em class="math">0</emphasis> if the request was
successfully enqueued.  Otherwise the return value is <em class="math">-1</emphasis> and
<code>errno</code> is set to one of the following values:
</para>
<dl compact="compact">
<dt><span><code>EAGAIN</code></span></dt>
<dd><para>The request could not be enqueued due to temporary lack of resources.
</para></dd>
<dt><span><code>EBADF</code></span></dt>
<dd><para>The file descriptor <code><var>aiocbp</var>-&gt;aio_fildes</code> is not valid.
</para></dd>
<dt><span><code>EINVAL</code></span></dt>
<dd><para>The implementation does not support I/O synchronization or the <var>op</var>
parameter is other than <code>O_DSYNC</code> and <code>O_SYNC</code>.
</para></dd>
<dt><span><code>ENOSYS</code></span></dt>
<dd><para>This function is not implemented.
</para></dd>
</dl>

<para>When the sources are compiled with <code>_FILE_OFFSET_BITS == 64</code> this
function is in fact <code>aio_fsync64</code> since the LFS interface
transparently replaces the normal implementation.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-aio_005ffsync64"><span class="category">Function: </span><span><emphasis>int</emphasis> <strong>aio_fsync64</strong> <emphasis>(int <var>op</var>, struct aiocb64 *<var>aiocbp</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-aio_005ffsync64" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Unsafe lock heap
| AC-Unsafe lock mem
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>This function is similar to <code>aio_fsync</code> with the only difference
that the argument is a reference to a variable of type <code>struct
aiocb64</code>.
</para>
<para>When the sources are compiled with <code>_FILE_OFFSET_BITS == 64</code> this
function is available under the name <code>aio_fsync</code> and so
transparently replaces the interface for small files on 32 bit
machines.
</para></dd></dl>

<para>Another method of synchronization is to wait until one or more requests of a
specific set terminated.  This could be achieved by the <code>aio_*</code>
functions to notify the initiating process about the termination but in
some situations this is not the ideal solution.  In a program which
constantly updates clients somehow connected to the server it is not
always the best solution to go round robin since some connections might
be slow.  On the other hand letting the <code>aio_*</code> functions notify the
caller might also be not the best solution since whenever the process
works on preparing data for a client it makes no sense to be
interrupted by a notification since the new client will not be handled
before the current client is served.  For situations like this
<code>aio_suspend</code> should be used.
</para>
<dl class="def">
<dt xml:id="glibc-index-aio_005fsuspend"><span class="category">Function: </span><span><emphasis>int</emphasis> <strong>aio_suspend</strong> <emphasis>(const struct aiocb *const <var>list</var>[], int <var>nent</var>, const struct timespec *<var>timeout</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-aio_005fsuspend" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Unsafe lock
| AC-Unsafe lock
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>When calling this function, the calling thread is suspended until at
least one of the requests pointed to by the <var>nent</var> elements of the
array <var>list</var> has completed.  If any of the requests has already
completed at the time <code>aio_suspend</code> is called, the function returns
immediately.  Whether a request has terminated or not is determined by
comparing the error status of the request with <code>EINPROGRESS</code>.  If
an element of <var>list</var> is <code>NULL</code>, the entry is simply ignored.
</para>
<para>If no request has finished, the calling process is suspended.  If
<var>timeout</var> is <code>NULL</code>, the process is not woken until a request
has finished.  If <var>timeout</var> is not <code>NULL</code>, the process remains
suspended at least as long as specified in <var>timeout</var>.  In this case,
<code>aio_suspend</code> returns with an error.
</para>
<para>The return value of the function is <em class="math">0</emphasis> if one or more requests
from the <var>list</var> have terminated.  Otherwise the function returns
<em class="math">-1</emphasis> and <code>errno</code> is set to one of the following values:
</para>
<dl compact="compact">
<dt><span><code>EAGAIN</code></span></dt>
<dd><para>None of the requests from the <var>list</var> completed in the time specified
by <var>timeout</var>.
</para></dd>
<dt><span><code>EINTR</code></span></dt>
<dd><para>A signal interrupted the <code>aio_suspend</code> function.  This signal might
also be sent by the AIO implementation while signalling the termination
of one of the requests.
</para></dd>
<dt><span><code>ENOSYS</code></span></dt>
<dd><para>The <code>aio_suspend</code> function is not implemented.
</para></dd>
</dl>

<para>When the sources are compiled with <code>_FILE_OFFSET_BITS == 64</code> this
function is in fact <code>aio_suspend64</code> since the LFS interface
transparently replaces the normal implementation.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-aio_005fsuspend64"><span class="category">Function: </span><span><emphasis>int</emphasis> <strong>aio_suspend64</strong> <emphasis>(const struct aiocb64 *const <var>list</var>[], int <var>nent</var>, const struct timespec *<var>timeout</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-aio_005fsuspend64" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Unsafe lock
| AC-Unsafe lock
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>This function is similar to <code>aio_suspend</code> with the only difference
that the argument is a reference to a variable of type <code>struct
aiocb64</code>.
</para>
<para>When the sources are compiled with <code>_FILE_OFFSET_BITS == 64</code> this
function is available under the name <code>aio_suspend</code> and so
transparently replaces the interface for small files on 32 bit
machines.
</para></dd></dl>

<hr>
</div>
<div class="subsection" xml:id="glibc-Cancel-AIO-Operations">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Configuration-of-AIO" accesskey="n" rel="next">How to optimize the AIO implementation</a>, Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Synchronizing-AIO-Operations" accesskey="p" rel="prev">Getting into a Consistent State</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Asynchronous-I_002fO" accesskey="u" rel="up">Perform I/O Operations in Parallel</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Cancellation-of-AIO-Operations"></span><h4 class="subsection">13.11.4 Cancellation of AIO Operations</title>

<para>When one or more requests are asynchronously processed, it might be
useful in some situations to cancel a selected operation, e.g., if it
becomes obvious that the written data is no longer accurate and would
have to be overwritten soon.  As an example, assume an application, which
writes data in files in a situation where new incoming data would have
to be written in a file which will be updated by an enqueued request.
The POSIX AIO implementation provides such a function, but this function
is not capable of forcing the cancellation of the request.  It is up to the
implementation to decide whether it is possible to cancel the operation
or not.  Therefore using this function is merely a hint.
</para>
<dl class="def">
<dt xml:id="glibc-index-aio_005fcancel"><span class="category">Function: </span><span><emphasis>int</emphasis> <strong>aio_cancel</strong> <emphasis>(int <var>fildes</var>, struct aiocb *<var>aiocbp</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-aio_005fcancel" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Unsafe lock heap
| AC-Unsafe lock mem
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>The <code>aio_cancel</code> function can be used to cancel one or more
outstanding requests.  If the <var>aiocbp</var> parameter is <code>NULL</code>, the
function tries to cancel all of the outstanding requests which would process
the file descriptor <var>fildes</var> (i.e., whose <code>aio_fildes</code> member
is <var>fildes</var>).  If <var>aiocbp</var> is not <code>NULL</code>, <code>aio_cancel</code>
attempts to cancel the specific request pointed to by <var>aiocbp</var>.
</para>
<para>For requests which were successfully canceled, the normal notification
about the termination of the request should take place.  I.e., depending
on the <code>struct sigevent</code> object which controls this, nothing
happens, a signal is sent or a thread is started.  If the request cannot
be canceled, it terminates the usual way after performing the operation.
</para>
<para>After a request is successfully canceled, a call to <code>aio_error</code> with
a reference to this request as the parameter will return
<code>ECANCELED</code> and a call to <code>aio_return</code> will return <em class="math">-1</emphasis>.
If the request wasn’t canceled and is still running the error status is
still <code>EINPROGRESS</code>.
</para>
<para>The return value of the function is <code>AIO_CANCELED</code> if there were
requests which haven’t terminated and which were successfully canceled.
If there is one or more requests left which couldn’t be canceled, the
return value is <code>AIO_NOTCANCELED</code>.  In this case <code>aio_error</code>
must be used to find out which of the, perhaps multiple, requests (if
<var>aiocbp</var> is <code>NULL</code>) weren’t successfully canceled.  If all
requests already terminated at the time <code>aio_cancel</code> is called the
return value is <code>AIO_ALLDONE</code>.
</para>
<para>If an error occurred during the execution of <code>aio_cancel</code> the
function returns <em class="math">-1</emphasis> and sets <code>errno</code> to one of the following
values.
</para>
<dl compact="compact">
<dt><span><code>EBADF</code></span></dt>
<dd><para>The file descriptor <var>fildes</var> is not valid.
</para></dd>
<dt><span><code>ENOSYS</code></span></dt>
<dd><para><code>aio_cancel</code> is not implemented.
</para></dd>
</dl>

<para>When the sources are compiled with <code>_FILE_OFFSET_BITS == 64</code>, this
function is in fact <code>aio_cancel64</code> since the LFS interface
transparently replaces the normal implementation.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-aio_005fcancel64"><span class="category">Function: </span><span><emphasis>int</emphasis> <strong>aio_cancel64</strong> <emphasis>(int <var>fildes</var>, struct aiocb64 *<var>aiocbp</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-aio_005fcancel64" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Unsafe lock heap
| AC-Unsafe lock mem
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>This function is similar to <code>aio_cancel</code> with the only difference
that the argument is a reference to a variable of type <code>struct
aiocb64</code>.
</para>
<para>When the sources are compiled with <code>_FILE_OFFSET_BITS == 64</code>, this
function is available under the name <code>aio_cancel</code> and so
transparently replaces the interface for small files on 32 bit
machines.
</para></dd></dl>

<hr>
</div>
<div class="subsection" xml:id="glibc-Configuration-of-AIO">
<div class="header">
<para>
Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Cancel-AIO-Operations" accesskey="p" rel="prev">Cancellation of AIO Operations</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Asynchronous-I_002fO" accesskey="u" rel="up">Perform I/O Operations in Parallel</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-How-to-optimize-the-AIO-implementation"></span><h4 class="subsection">13.11.5 How to optimize the AIO implementation</title>

<para>The POSIX standard does not specify how the AIO functions are
implemented.  They could be system calls, but it is also possible to
emulate them at userlevel.
</para>
<para>At the time of writing, the available implementation is a user-level
implementation which uses threads for handling the enqueued requests.
While this implementation requires making some decisions about
limitations, hard limitations are something best avoided
in the GNU C Library.  Therefore, the GNU C Library provides a means
for tuning the AIO implementation according to the individual use.
</para>
<dl class="def">
<dt xml:id="glibc-index-struct-aioinit"><span class="category">Data Type: </span><span><strong>struct aioinit</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-struct-aioinit" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>This data type is used to pass the configuration or tunable parameters
to the implementation.  The program has to initialize the members of
this struct and pass it to the implementation using the <code>aio_init</code>
function.
</para>
<dl compact="compact">
<dt><span><code>int aio_threads</code></span></dt>
<dd><para>This member specifies the maximal number of threads which may be used
at any one time.
</para></dd>
<dt><span><code>int aio_num</code></span></dt>
<dd><para>This number provides an estimate on the maximal number of simultaneously
enqueued requests.
</para></dd>
<dt><span><code>int aio_locks</code></span></dt>
<dd><para>Unused.
</para></dd>
<dt><span><code>int aio_usedba</code></span></dt>
<dd><para>Unused.
</para></dd>
<dt><span><code>int aio_debug</code></span></dt>
<dd><para>Unused.
</para></dd>
<dt><span><code>int aio_numusers</code></span></dt>
<dd><para>Unused.
</para></dd>
<dt><span><code>int aio_reserved[2]</code></span></dt>
<dd><para>Unused.
</para></dd>
</dl>
</dd></dl>

<dl class="def">
<dt xml:id="glibc-index-aio_005finit"><span class="category">Function: </span><span><emphasis>void</emphasis> <strong>aio_init</strong> <emphasis>(const struct aioinit *<var>init</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-aio_005finit" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Unsafe lock
| AC-Unsafe lock
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>This function must be called before any other AIO function.  Calling it
is completely voluntary, as it is only meant to help the AIO
implementation perform better.
</para>
<para>Before calling <code>aio_init</code>, the members of a variable of
type <code>struct aioinit</code> must be initialized.  Then a reference to
this variable is passed as the parameter to <code>aio_init</code> which itself
may or may not pay attention to the hints.
</para>
<para>The function has no return value and no error cases are defined.  It is
an extension which follows a proposal from the SGI implementation in
Irix&nbsp;6.  It is not covered by POSIX.1b or Unix98.
</para></dd></dl>

<hr>
</div>
</div>
<sect xml:id="glibc-Control-Operations">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Duplicating-Descriptors" accesskey="n" rel="next">Duplicating Descriptors</a>, Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Asynchronous-I_002fO" accesskey="p" rel="prev">Perform I/O Operations in Parallel</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Low_002dLevel-I_002fO" accesskey="u" rel="up">Low-Level Input/Output</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Control-Operations-on-Files"></span><h3 class="section">13.12 Control Operations on Files</title>

<span xml:id="glibc-index-control-operations-on-files"></span>
<span xml:id="glibc-index-fcntl-function"></span>
<para>This section describes how you can perform various other operations on
file descriptors, such as inquiring about or setting flags describing
the status of the file descriptor, manipulating record locks, and the
like.  All of these operations are performed by the function <code>fcntl</code>.
</para>
<para>The second argument to the <code>fcntl</code> function is a command that
specifies which operation to perform.  The function and macros that name
various flags that are used with it are declared in the header file
<filename>fcntl.h</filename>.  Many of these flags are also used by the <code>open</code>
function; see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Opening-and-Closing-Files">Opening and Closing Files</a>.
<span xml:id="glibc-index-fcntl_002eh-2"></span>
</para>
<dl class="def">
<dt xml:id="glibc-index-fcntl"><span class="category">Function: </span><span><emphasis>int</emphasis> <strong>fcntl</strong> <emphasis>(int <var>filedes</var>, int <var>command</var>, …)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-fcntl" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Safe
| AC-Safe
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>The <code>fcntl</code> function performs the operation specified by
<var>command</var> on the file descriptor <var>filedes</var>.  Some commands
require additional arguments to be supplied.  These additional arguments
and the return value and error conditions are given in the detailed
descriptions of the individual commands.
</para>
<para>Briefly, here is a list of what the various commands are.
</para>
<dl compact="compact">
<dt xml:id="glibc-index-F_005fDUPFD"><span><code>F_DUPFD</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-F_005fDUPFD" class="copiable-anchor"> ¶</a></span></dt>
<dd><para>Duplicate the file descriptor (return another file descriptor pointing
to the same open file).  See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Duplicating-Descriptors">Duplicating Descriptors</a>.
</para>
</dd>
<dt xml:id="glibc-index-F_005fGETFD"><span><code>F_GETFD</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-F_005fGETFD" class="copiable-anchor"> ¶</a></span></dt>
<dd><para>Get flags associated with the file descriptor.  See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Descriptor-Flags">File Descriptor Flags</a>.
</para>
</dd>
<dt xml:id="glibc-index-F_005fSETFD"><span><code>F_SETFD</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-F_005fSETFD" class="copiable-anchor"> ¶</a></span></dt>
<dd><para>Set flags associated with the file descriptor.  See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Descriptor-Flags">File Descriptor Flags</a>.
</para>
</dd>
<dt xml:id="glibc-index-F_005fGETFL"><span><code>F_GETFL</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-F_005fGETFL" class="copiable-anchor"> ¶</a></span></dt>
<dd><para>Get flags associated with the open file.  See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#File-Status-Flags">File Status Flags</a>.
</para>
</dd>
<dt xml:id="glibc-index-F_005fSETFL"><span><code>F_SETFL</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-F_005fSETFL" class="copiable-anchor"> ¶</a></span></dt>
<dd><para>Set flags associated with the open file.  See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#File-Status-Flags">File Status Flags</a>.
</para>
</dd>
<dt xml:id="glibc-index-F_005fGETLK"><span><code>F_GETLK</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-F_005fGETLK" class="copiable-anchor"> ¶</a></span></dt>
<dd><para>Test a file lock.  See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#File-Locks">File Locks</a>.
</para>
</dd>
<dt xml:id="glibc-index-F_005fSETLK"><span><code>F_SETLK</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-F_005fSETLK" class="copiable-anchor"> ¶</a></span></dt>
<dd><para>Set or clear a file lock.  See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#File-Locks">File Locks</a>.
</para>
</dd>
<dt xml:id="glibc-index-F_005fSETLKW"><span><code>F_SETLKW</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-F_005fSETLKW" class="copiable-anchor"> ¶</a></span></dt>
<dd><para>Like <code>F_SETLK</code>, but wait for completion.  See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#File-Locks">File Locks</a>.
</para>
</dd>
<dt xml:id="glibc-index-F_005fOFD_005fGETLK"><span><code>F_OFD_GETLK</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-F_005fOFD_005fGETLK" class="copiable-anchor"> ¶</a></span></dt>
<dd><para>Test an open file description lock.  See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Open-File-Description-Locks">Open File Description Locks</a>.
Specific to Linux.
</para>
</dd>
<dt xml:id="glibc-index-F_005fOFD_005fSETLK"><span><code>F_OFD_SETLK</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-F_005fOFD_005fSETLK" class="copiable-anchor"> ¶</a></span></dt>
<dd><para>Set or clear an open file description lock.  See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Open-File-Description-Locks">Open File Description Locks</a>.
Specific to Linux.
</para>
</dd>
<dt xml:id="glibc-index-F_005fOFD_005fSETLKW"><span><code>F_OFD_SETLKW</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-F_005fOFD_005fSETLKW" class="copiable-anchor"> ¶</a></span></dt>
<dd><para>Like <code>F_OFD_SETLK</code>, but block until lock is acquired.
See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Open-File-Description-Locks">Open File Description Locks</a>.  Specific to Linux.
</para>
</dd>
<dt xml:id="glibc-index-F_005fGETOWN"><span><code>F_GETOWN</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-F_005fGETOWN" class="copiable-anchor"> ¶</a></span></dt>
<dd><para>Get process or process group ID to receive <code>SIGIO</code> signals.
See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Interrupt-Input">Interrupt-Driven Input</a>.
</para>
</dd>
<dt xml:id="glibc-index-F_005fSETOWN"><span><code>F_SETOWN</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-F_005fSETOWN" class="copiable-anchor"> ¶</a></span></dt>
<dd><para>Set process or process group ID to receive <code>SIGIO</code> signals.
See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Interrupt-Input">Interrupt-Driven Input</a>.
</para></dd>
</dl>

<para>This function is a cancellation point in multi-threaded programs for the
commands <code>F_SETLKW</code> (and the LFS analogous <code>F_SETLKW64</code>) and
<code>F_OFD_SETLKW</code>.  This is a problem if the thread allocates some
resources (like memory, file descriptors, semaphores or whatever) at the time
<code>fcntl</code> is called.  If the thread gets canceled these resources stay
allocated until the program ends.  To avoid this calls to <code>fcntl</code> should
be protected using cancellation handlers.
</para></dd></dl>


<hr>
</div>
<sect xml:id="glibc-Duplicating-Descriptors">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Descriptor-Flags" accesskey="n" rel="next">File Descriptor Flags</a>, Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Control-Operations" accesskey="p" rel="prev">Control Operations on Files</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Low_002dLevel-I_002fO" accesskey="u" rel="up">Low-Level Input/Output</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Duplicating-Descriptors-1"></span><h3 class="section">13.13 Duplicating Descriptors</title>

<span xml:id="glibc-index-duplicating-file-descriptors"></span>
<span xml:id="glibc-index-redirecting-input-and-output"></span>

<para>You can <emphasis>duplicate</emphasis> a file descriptor, or allocate another file
descriptor that refers to the same open file as the original.  Duplicate
descriptors share one file position and one set of file status flags
(see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#File-Status-Flags">File Status Flags</a>), but each has its own set of file descriptor
flags (see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Descriptor-Flags">File Descriptor Flags</a>).
</para>
<para>The major use of duplicating a file descriptor is to implement
<emphasis>redirection</emphasis> of input or output:  that is, to change the
file or pipe that a particular file descriptor corresponds to.
</para>
<para>You can perform this operation using the <code>fcntl</code> function with the
<code>F_DUPFD</code> command, but there are also convenient functions
<code>dup</code> and <code>dup2</code> for duplicating descriptors.
</para>
<span xml:id="glibc-index-unistd_002eh-3"></span>
<span xml:id="glibc-index-fcntl_002eh-3"></span>
<para>The <code>fcntl</code> function and flags are declared in <filename>fcntl.h</filename>,
while prototypes for <code>dup</code> and <code>dup2</code> are in the header file
<filename>unistd.h</filename>.
</para>
<dl class="def">
<dt xml:id="glibc-index-dup"><span class="category">Function: </span><span><emphasis>int</emphasis> <strong>dup</strong> <emphasis>(int <var>old</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-dup" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Safe
| AC-Safe
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>This function copies descriptor <var>old</var> to the first available
descriptor number (the first number not currently open).  It is
equivalent to <code>fcntl (<var>old</var>, F_DUPFD, 0)</code>.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-dup2"><span class="category">Function: </span><span><emphasis>int</emphasis> <strong>dup2</strong> <emphasis>(int <var>old</var>, int <var>new</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-dup2" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Safe
| AC-Safe
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>This function copies the descriptor <var>old</var> to descriptor number
<var>new</var>.
</para>
<para>If <var>old</var> is an invalid descriptor, then <code>dup2</code> does nothing; it
does not close <var>new</var>.  Otherwise, the new duplicate of <var>old</var>
replaces any previous meaning of descriptor <var>new</var>, as if <var>new</var>
were closed first.
</para>
<para>If <var>old</var> and <var>new</var> are different numbers, and <var>old</var> is a
valid descriptor number, then <code>dup2</code> is equivalent to:
</para>
<div class="example">
<pre class="example">close (<var>new</var>);
fcntl (<var>old</var>, F_DUPFD, <var>new</var>)
</pre></div>

<para>However, <code>dup2</code> does this atomically; there is no instant in the
middle of calling <code>dup2</code> at which <var>new</var> is closed and not yet a
duplicate of <var>old</var>.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-F_005fDUPFD-1"><span class="category">Macro: </span><span><emphasis>int</emphasis> <strong>F_DUPFD</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-F_005fDUPFD-1" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>This macro is used as the <var>command</var> argument to <code>fcntl</code>, to
copy the file descriptor given as the first argument.
</para>
<para>The form of the call in this case is:
</para>
<div class="example">
<pre class="example">fcntl (<var>old</var>, F_DUPFD, <var>next-filedes</var>)
</pre></div>

<para>The <var>next-filedes</var> argument is of type <code>int</code> and specifies that
the file descriptor returned should be the next available one greater
than or equal to this value.
</para>
<para>The return value from <code>fcntl</code> with this command is normally the value
of the new file descriptor.  A return value of <em class="math">-1</emphasis> indicates an
error.  The following <code>errno</code> error conditions are defined for
this command:
</para>
<dl compact="compact">
<dt><span><code>EBADF</code></span></dt>
<dd><para>The <var>old</var> argument is invalid.
</para>
</dd>
<dt><span><code>EINVAL</code></span></dt>
<dd><para>The <var>next-filedes</var> argument is invalid.
</para>
</dd>
<dt><span><code>EMFILE</code></span></dt>
<dd><para>There are no more file descriptors available—your program is already
using the maximum.  In BSD and GNU, the maximum is controlled by a
resource limit that can be changed; see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Limits-on-Resources">Limiting Resource Usage</a>, for
more information about the <code>RLIMIT_NOFILE</code> limit.
</para></dd>
</dl>

<para><code>ENFILE</code> is not a possible error code for <code>dup2</code> because
<code>dup2</code> does not create a new opening of a file; duplicate
descriptors do not count toward the limit which <code>ENFILE</code>
indicates.  <code>EMFILE</code> is possible because it refers to the limit on
distinct descriptor numbers in use in one process.
</para></dd></dl>

<para>Here is an example showing how to use <code>dup2</code> to do redirection.
Typically, redirection of the standard streams (like <code>stdin</code>) is
done by a shell or shell-like program before calling one of the
<code>exec</code> functions (see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Executing-a-File">Executing a File</a>) to execute a new
program in a child process.  When the new program is executed, it
creates and initializes the standard streams to point to the
corresponding file descriptors, before its <code>main</code> function is
invoked.
</para>
<para>So, to redirect standard input to a file, the shell could do something
like:
</para>
<div class="example">
<pre class="example">pid = fork ();
if (pid == 0)
  {
    char *filename;
    char *program;
    int file;
    …
    file = TEMP_FAILURE_RETRY (open (filename, O_RDONLY));
    dup2 (file, STDIN_FILENO);
    TEMP_FAILURE_RETRY (close (file));
    execv (program, NULL);
  }
</pre></div>

<para>There is also a more detailed example showing how to implement redirection
in the context of a pipeline of processes in <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Launching-Jobs">Launching Jobs</a>.
</para>

<hr>
</div>
<sect xml:id="glibc-Descriptor-Flags">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#File-Status-Flags" accesskey="n" rel="next">File Status Flags</a>, Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Duplicating-Descriptors" accesskey="p" rel="prev">Duplicating Descriptors</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Low_002dLevel-I_002fO" accesskey="u" rel="up">Low-Level Input/Output</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-File-Descriptor-Flags"></span><h3 class="section">13.14 File Descriptor Flags</title>
<span xml:id="glibc-index-file-descriptor-flags"></span>

<para><emphasis>File descriptor flags</emphasis> are miscellaneous attributes of a file
descriptor.  These flags are associated with particular file
descriptors, so that if you have created duplicate file descriptors
from a single opening of a file, each descriptor has its own set of flags.
</para>
<para>Currently there is just one file descriptor flag: <code>FD_CLOEXEC</code>,
which causes the descriptor to be closed if you use any of the
<code>exec…</code> functions (see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Executing-a-File">Executing a File</a>).
</para>
<para>The symbols in this section are defined in the header file
<filename>fcntl.h</filename>.
<span xml:id="glibc-index-fcntl_002eh-4"></span>
</para>
<dl class="def">
<dt xml:id="glibc-index-F_005fGETFD-1"><span class="category">Macro: </span><span><emphasis>int</emphasis> <strong>F_GETFD</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-F_005fGETFD-1" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>This macro is used as the <var>command</var> argument to <code>fcntl</code>, to
specify that it should return the file descriptor flags associated
with the <var>filedes</var> argument.
</para>
<para>The normal return value from <code>fcntl</code> with this command is a
nonnegative number which can be interpreted as the bitwise OR of the
individual flags (except that currently there is only one flag to use).
</para>
<para>In case of an error, <code>fcntl</code> returns <em class="math">-1</emphasis>.  The following
<code>errno</code> error conditions are defined for this command:
</para>
<dl compact="compact">
<dt><span><code>EBADF</code></span></dt>
<dd><para>The <var>filedes</var> argument is invalid.
</para></dd>
</dl>
</dd></dl>


<dl class="def">
<dt xml:id="glibc-index-F_005fSETFD-1"><span class="category">Macro: </span><span><emphasis>int</emphasis> <strong>F_SETFD</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-F_005fSETFD-1" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>This macro is used as the <var>command</var> argument to <code>fcntl</code>, to
specify that it should set the file descriptor flags associated with the
<var>filedes</var> argument.  This requires a third <code>int</code> argument to
specify the new flags, so the form of the call is:
</para>
<div class="example">
<pre class="example">fcntl (<var>filedes</var>, F_SETFD, <var>new-flags</var>)
</pre></div>

<para>The normal return value from <code>fcntl</code> with this command is an
unspecified value other than <em class="math">-1</emphasis>, which indicates an error.
The flags and error conditions are the same as for the <code>F_GETFD</code>
command.
</para></dd></dl>

<para>The following macro is defined for use as a file descriptor flag with
the <code>fcntl</code> function.  The value is an integer constant usable
as a bit mask value.
</para>
<dl class="def">
<dt xml:id="glibc-index-FD_005fCLOEXEC"><span class="category">Macro: </span><span><emphasis>int</emphasis> <strong>FD_CLOEXEC</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-FD_005fCLOEXEC" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<span xml:id="glibc-index-close_002don_002dexec-_0028file-descriptor-flag_0029"></span>
<para>This flag specifies that the file descriptor should be closed when
an <code>exec</code> function is invoked; see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Executing-a-File">Executing a File</a>.  When
a file descriptor is allocated (as with <code>open</code> or <code>dup</code>),
this bit is initially cleared on the new file descriptor, meaning that
descriptor will survive into the new program after <code>exec</code>.
</para></dd></dl>

<para>If you want to modify the file descriptor flags, you should get the
current flags with <code>F_GETFD</code> and modify the value.  Don’t assume
that the flags listed here are the only ones that are implemented; your
program may be run years from now and more flags may exist then.  For
example, here is a function to set or clear the flag <code>FD_CLOEXEC</code>
without altering any other flags:
</para>
<div class="example">
<pre class="example">/* <span class="roman">Set the <code>FD_CLOEXEC</code> flag of <var>desc</var> if <var>value</var> is nonzero,</span>
   <span class="roman">or clear the flag if <var>value</var> is 0.</span>
   <span class="roman">Return 0 on success, or -1 on error with <code>errno</code> set.</span> */

int
set_cloexec_flag (int desc, int value)
{
  int oldflags = fcntl (desc, F_GETFD, 0);
  /* <span class="roman">If reading the flags failed, return error indication now.</span> */
  if (oldflags &lt; 0)
    return oldflags;
  /* <span class="roman">Set just the flag we want to set.</span> */
  if (value != 0)
    oldflags |= FD_CLOEXEC;
  else
    oldflags &amp;= ~FD_CLOEXEC;
  /* <span class="roman">Store modified flag word in the descriptor.</span> */
  return fcntl (desc, F_SETFD, oldflags);
}
</pre></div>

<hr>
</div>
<sect xml:id="glibc-File-Status-Flags">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#File-Locks" accesskey="n" rel="next">File Locks</a>, Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Descriptor-Flags" accesskey="p" rel="prev">File Descriptor Flags</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Low_002dLevel-I_002fO" accesskey="u" rel="up">Low-Level Input/Output</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-File-Status-Flags-1"></span><h3 class="section">13.15 File Status Flags</title>
<span xml:id="glibc-index-file-status-flags"></span>

<para><emphasis>File status flags</emphasis> are used to specify attributes of the opening of a
file.  Unlike the file descriptor flags discussed in <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Descriptor-Flags">File Descriptor Flags</a>, the file status flags are shared by duplicated file descriptors
resulting from a single opening of the file.  The file status flags are
specified with the <var>flags</var> argument to <code>open</code>;
see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Opening-and-Closing-Files">Opening and Closing Files</a>.
</para>
<para>File status flags fall into three categories, which are described in the
following sections.
</para>
<ul>
<li> <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Access-Modes">File Access Modes</a>, specify what type of access is allowed to the
file: reading, writing, or both.  They are set by <code>open</code> and are
returned by <code>fcntl</code>, but cannot be changed.

</li><li> <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Open_002dtime-Flags">Open-time Flags</a>, control details of what <code>open</code> will do.
These flags are not preserved after the <code>open</code> call.

</li><li> <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Operating-Modes">I/O Operating Modes</a>, affect how operations such as <code>read</code> and
<code>write</code> are done.  They are set by <code>open</code>, and can be fetched or
changed with <code>fcntl</code>.
</li></ul>

<para>The symbols in this section are defined in the header file
<filename>fcntl.h</filename>.
<span xml:id="glibc-index-fcntl_002eh-5"></span>
</para>

<ul class="section-toc">
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Access-Modes" accesskey="1">File Access Modes</a></li>
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Open_002dtime-Flags" accesskey="2">Open-time Flags</a></li>
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Operating-Modes" accesskey="3">I/O Operating Modes</a></li>
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Getting-File-Status-Flags" accesskey="4">Getting and Setting File Status Flags</a></li>
</ul>
<hr>
<div class="subsection" xml:id="glibc-Access-Modes">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Open_002dtime-Flags" accesskey="n" rel="next">Open-time Flags</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#File-Status-Flags" accesskey="u" rel="up">File Status Flags</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-File-Access-Modes"></span><h4 class="subsection">13.15.1 File Access Modes</title>

<para>The file access mode allows a file descriptor to be used for reading,
writing, both, or neither.  The access mode is determined when the file
is opened, and never change.
</para>
<dl class="def">
<dt xml:id="glibc-index-O_005fRDONLY"><span class="category">Macro: </span><span><emphasis>int</emphasis> <strong>O_RDONLY</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-O_005fRDONLY" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Open the file for read access.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-O_005fWRONLY"><span class="category">Macro: </span><span><emphasis>int</emphasis> <strong>O_WRONLY</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-O_005fWRONLY" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Open the file for write access.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-O_005fRDWR"><span class="category">Macro: </span><span><emphasis>int</emphasis> <strong>O_RDWR</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-O_005fRDWR" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Open the file for both reading and writing.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-O_005fPATH"><span class="category">Macro: </span><span><emphasis>int</emphasis> <strong>O_PATH</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-O_005fPATH" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Obtain a file descriptor for the file, but do not open the file for
reading or writing.  Permission checks for the file itself are skipped
when the file is opened (but permission to access the directory that
contains it is still needed), and permissions are checked when the
descriptor is used later on.
</para>
<para>For example, such descriptors can be used with the <code>fexecve</code>
function (see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Executing-a-File">Executing a File</a>).
</para>
<para>This access mode is specific to Linux.  On GNU/Hurd systems, it is
possible to use <code>O_EXEC</code> explicitly, or specify no access modes
at all (see below).
</para></dd></dl>

<para>The portable file access modes <code>O_RDONLY</code>, <code>O_WRONLY</code>, and
<code>O_RDWR</code> may not correspond to individual bits.  To determine the
file access mode with <code>fcntl</code>, you must extract the access mode
bits from the retrieved file status flags, using the <code>O_ACCMODE</code>
mask.
</para>
<dl class="def">
<dt xml:id="glibc-index-O_005fACCMODE"><span class="category">Macro: </span><span><emphasis>int</emphasis> <strong>O_ACCMODE</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-O_005fACCMODE" class="copiable-anchor"> ¶</a></span></dt>
<dd>

<para>This macro is a mask that can be bitwise-ANDed with the file status flag
value to recover the file access mode, assuming that a standard file
access mode is in use.
</para></dd></dl>

<para>If a non-standard file access mode is used (such as <code>O_PATH</code> or
<code>O_EXEC</code>), masking with <code>O_ACCMODE</code> may give incorrect
results.  These non-standard access modes are identified by individual
bits and have to be checked directly (without masking with
<code>O_ACCMODE</code> first).
</para>
<para>On GNU/Hurd systems (but not on other systems), <code>O_RDONLY</code> and
<code>O_WRONLY</code> are independent bits that can be bitwise-ORed together,
and it is valid for either bit to be set or clear.  This means that
<code>O_RDWR</code> is the same as <code>O_RDONLY|O_WRONLY</code>.  A file access
mode of zero is permissible; it allows no operations that do input or
output to the file, but does allow other operations such as
<code>fchmod</code>.  On GNU/Hurd systems, since “read-only” or “write-only”
is a misnomer, <filename>fcntl.h</filename> defines additional names for the file
access modes.
</para>
<dl class="def">
<dt xml:id="glibc-index-O_005fREAD"><span class="category">Macro: </span><span><emphasis>int</emphasis> <strong>O_READ</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-O_005fREAD" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Open the file for reading.  Same as <code>O_RDONLY</code>; only defined on GNU/Hurd.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-O_005fWRITE"><span class="category">Macro: </span><span><emphasis>int</emphasis> <strong>O_WRITE</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-O_005fWRITE" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Open the file for writing.  Same as <code>O_WRONLY</code>; only defined on GNU/Hurd.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-O_005fEXEC"><span class="category">Macro: </span><span><emphasis>int</emphasis> <strong>O_EXEC</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-O_005fEXEC" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Open the file for executing.  Only defined on GNU/Hurd.
</para></dd></dl>

<hr>
</div>
<div class="subsection" xml:id="glibc-Open_002dtime-Flags">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Operating-Modes" accesskey="n" rel="next">I/O Operating Modes</a>, Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Access-Modes" accesskey="p" rel="prev">File Access Modes</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#File-Status-Flags" accesskey="u" rel="up">File Status Flags</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Open_002dtime-Flags-1"></span><h4 class="subsection">13.15.2 Open-time Flags</title>

<para>The open-time flags specify options affecting how <code>open</code> will behave.
These options are not preserved once the file is open.  The exception to
this is <code>O_NONBLOCK</code>, which is also an I/O operating mode and so it
<emphasis>is</emphasis> saved.  See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Opening-and-Closing-Files">Opening and Closing Files</a>, for how to call
<code>open</code>.
</para>
<para>There are two sorts of options specified by open-time flags.
</para>
<ul>
<li> <emphasis>File name translation flags</emphasis> affect how <code>open</code> looks up the
file name to locate the file, and whether the file can be created.
<span xml:id="glibc-index-file-name-translation-flags"></span>
<span xml:id="glibc-index-flags_002c-file-name-translation"></span>

</li><li> <emphasis>Open-time action flags</emphasis> specify extra operations that <code>open</code> will
perform on the file once it is open.
<span xml:id="glibc-index-open_002dtime-action-flags"></span>
<span xml:id="glibc-index-flags_002c-open_002dtime-action"></span>
</li></ul>

<para>Here are the file name translation flags.
</para>
<dl class="def">
<dt xml:id="glibc-index-O_005fCREAT"><span class="category">Macro: </span><span><emphasis>int</emphasis> <strong>O_CREAT</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-O_005fCREAT" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>If set, the file will be created if it doesn’t already exist.
<span xml:id="glibc-index-create-on-open-_0028file-status-flag_0029"></span>
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-O_005fEXCL"><span class="category">Macro: </span><span><emphasis>int</emphasis> <strong>O_EXCL</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-O_005fEXCL" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>If both <code>O_CREAT</code> and <code>O_EXCL</code> are set, then <code>open</code> fails
if the specified file already exists.  This is guaranteed to never
clobber an existing file.
</para>
<para>The <code>O_EXCL</code> flag has a special meaning in combination with
<code>O_TMPFILE</code>; see below.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-O_005fDIRECTORY"><span class="category">Macro: </span><span><emphasis>int</emphasis> <strong>O_DIRECTORY</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-O_005fDIRECTORY" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>If set, the open operation fails if the given name is not the name of
a directory.  The <code>errno</code> variable is set to <code>ENOTDIR</code> for
this error condition.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-O_005fNOFOLLOW"><span class="category">Macro: </span><span><emphasis>int</emphasis> <strong>O_NOFOLLOW</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-O_005fNOFOLLOW" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>If set, the open operation fails if the final component of the file name
refers to a symbolic link.  The <code>errno</code> variable is set to
<code>ELOOP</code> for this error condition.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-O_005fTMPFILE"><span class="category">Macro: </span><span><emphasis>int</emphasis> <strong>O_TMPFILE</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-O_005fTMPFILE" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>If this flag is specified, functions in the <code>open</code> family create an
unnamed temporary file.  In this case, the pathname argument to the
<code>open</code> family of functions (see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Opening-and-Closing-Files">Opening and Closing Files</a>) is
interpreted as the directory in which the temporary file is created
(thus determining the file system which provides the storage for the
file).  The <code>O_TMPFILE</code> flag must be combined with <code>O_WRONLY</code>
or <code>O_RDWR</code>, and the <var>mode</var> argument is required.
</para>
<para>The temporary file can later be given a name using <code>linkat</code>,
turning it into a regular file.  This allows the atomic creation of a
file with the specific file attributes (mode and extended attributes)
and file contents.  If, for security reasons, it is not desirable that a
name can be given to the file, the <code>O_EXCL</code> flag can be specified
along with <code>O_TMPFILE</code>.
</para>
<para>Not all kernels support this open flag.  If this flag is unsupported, an
attempt to create an unnamed temporary file fails with an error of
<code>EINVAL</code>.  If the underlying file system does not support the
<code>O_TMPFILE</code> flag, an <code>EOPNOTSUPP</code> error is the result.
</para>
<para>The <code>O_TMPFILE</code> flag is a GNU extension.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-O_005fNONBLOCK"><span class="category">Macro: </span><span><emphasis>int</emphasis> <strong>O_NONBLOCK</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-O_005fNONBLOCK" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<span xml:id="glibc-index-non_002dblocking-open"></span>
<para>This prevents <code>open</code> from blocking for a “long time” to open the
file.  This is only meaningful for some kinds of files, usually devices
such as serial ports; when it is not meaningful, it is harmless and
ignored.  Often, opening a port to a modem blocks until the modem reports
carrier detection; if <code>O_NONBLOCK</code> is specified, <code>open</code> will
return immediately without a carrier.
</para>
<para>Note that the <code>O_NONBLOCK</code> flag is overloaded as both an I/O operating
mode and a file name translation flag.  This means that specifying
<code>O_NONBLOCK</code> in <code>open</code> also sets nonblocking I/O mode;
see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Operating-Modes">I/O Operating Modes</a>.  To open the file without blocking but do normal
I/O that blocks, you must call <code>open</code> with <code>O_NONBLOCK</code> set and
then call <code>fcntl</code> to turn the bit off.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-O_005fNOCTTY"><span class="category">Macro: </span><span><emphasis>int</emphasis> <strong>O_NOCTTY</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-O_005fNOCTTY" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>If the named file is a terminal device, don’t make it the controlling
terminal for the process.  See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Job-Control">Job Control</a>, for information about
what it means to be the controlling terminal.
</para>
<para>On GNU/Hurd systems and 4.4 BSD, opening a file never makes it the
controlling terminal and <code>O_NOCTTY</code> is zero.  However, GNU/Linux systems
and some other systems use a nonzero value for <code>O_NOCTTY</code> and set the
controlling terminal when you open a file that is a terminal device; so
to be portable, use <code>O_NOCTTY</code> when it is important to avoid this.
<span xml:id="glibc-index-controlling-terminal_002c-setting"></span>
</para></dd></dl>

<para>The following three file name translation flags exist only on
GNU/Hurd systems.
</para>
<dl class="def">
<dt xml:id="glibc-index-O_005fIGNORE_005fCTTY"><span class="category">Macro: </span><span><emphasis>int</emphasis> <strong>O_IGNORE_CTTY</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-O_005fIGNORE_005fCTTY" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Do not recognize the named file as the controlling terminal, even if it
refers to the process’s existing controlling terminal device.  Operations
on the new file descriptor will never induce job control signals.
See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Job-Control">Job Control</a>.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-O_005fNOLINK"><span class="category">Macro: </span><span><emphasis>int</emphasis> <strong>O_NOLINK</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-O_005fNOLINK" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>If the named file is a symbolic link, open the link itself instead of
the file it refers to.  (<code>fstat</code> on the new file descriptor will
return the information returned by <code>lstat</code> on the link’s name.)
<span xml:id="glibc-index-symbolic-link_002c-opening"></span>
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-O_005fNOTRANS"><span class="category">Macro: </span><span><emphasis>int</emphasis> <strong>O_NOTRANS</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-O_005fNOTRANS" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>If the named file is specially translated, do not invoke the translator.
Open the bare file the translator itself sees.
</para></dd></dl>


<para>The open-time action flags tell <code>open</code> to do additional operations
which are not really related to opening the file.  The reason to do them
as part of <code>open</code> instead of in separate calls is that <code>open</code>
can do them <i>atomically</i>.
</para>
<dl class="def">
<dt xml:id="glibc-index-O_005fTRUNC"><span class="category">Macro: </span><span><emphasis>int</emphasis> <strong>O_TRUNC</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-O_005fTRUNC" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Truncate the file to zero length.  This option is only useful for
regular files, not special files such as directories or FIFOs.  POSIX.1
requires that you open the file for writing to use <code>O_TRUNC</code>.  In
BSD and GNU you must have permission to write the file to truncate it,
but you need not open for write access.
</para>
<para>This is the only open-time action flag specified by POSIX.1.  There is
no good reason for truncation to be done by <code>open</code>, instead of by
calling <code>ftruncate</code> afterwards.  The <code>O_TRUNC</code> flag existed in
Unix before <code>ftruncate</code> was invented, and is retained for backward
compatibility.
</para></dd></dl>

<para>The remaining operating modes are BSD extensions.  They exist only
on some systems.  On other systems, these macros are not defined.
</para>
<dl class="def">
<dt xml:id="glibc-index-O_005fSHLOCK"><span class="category">Macro: </span><span><emphasis>int</emphasis> <strong>O_SHLOCK</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-O_005fSHLOCK" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Acquire a shared lock on the file, as with <code>flock</code>.
See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#File-Locks">File Locks</a>.
</para>
<para>If <code>O_CREAT</code> is specified, the locking is done atomically when
creating the file.  You are guaranteed that no other process will get
the lock on the new file first.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-O_005fEXLOCK"><span class="category">Macro: </span><span><emphasis>int</emphasis> <strong>O_EXLOCK</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-O_005fEXLOCK" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Acquire an exclusive lock on the file, as with <code>flock</code>.
See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#File-Locks">File Locks</a>.  This is atomic like <code>O_SHLOCK</code>.
</para></dd></dl>

<hr>
</div>
<div class="subsection" xml:id="glibc-Operating-Modes">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Getting-File-Status-Flags" accesskey="n" rel="next">Getting and Setting File Status Flags</a>, Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Open_002dtime-Flags" accesskey="p" rel="prev">Open-time Flags</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#File-Status-Flags" accesskey="u" rel="up">File Status Flags</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-I_002fO-Operating-Modes"></span><h4 class="subsection">13.15.3 I/O Operating Modes</title>

<para>The operating modes affect how input and output operations using a file
descriptor work.  These flags are set by <code>open</code> and can be fetched
and changed with <code>fcntl</code>.
</para>
<dl class="def">
<dt xml:id="glibc-index-O_005fAPPEND"><span class="category">Macro: </span><span><emphasis>int</emphasis> <strong>O_APPEND</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-O_005fAPPEND" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>The bit that enables append mode for the file.  If set, then all
<code>write</code> operations write the data at the end of the file, extending
it, regardless of the current file position.  This is the only reliable
way to append to a file.  In append mode, you are guaranteed that the
data you write will always go to the current end of the file, regardless
of other processes writing to the file.  Conversely, if you simply set
the file position to the end of file and write, then another process can
extend the file after you set the file position but before you write,
resulting in your data appearing someplace before the real end of file.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-O_005fNONBLOCK-1"><span class="category">Macro: </span><span><emphasis>int</emphasis> <strong>O_NONBLOCK</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-O_005fNONBLOCK-1" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>The bit that enables nonblocking mode for the file.  If this bit is set,
<code>read</code> requests on the file can return immediately with a failure
status if there is no input immediately available, instead of blocking.
Likewise, <code>write</code> requests can also return immediately with a
failure status if the output can’t be written immediately.
</para>
<para>Note that the <code>O_NONBLOCK</code> flag is overloaded as both an I/O
operating mode and a file name translation flag; see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Open_002dtime-Flags">Open-time Flags</a>.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-O_005fNDELAY"><span class="category">Macro: </span><span><emphasis>int</emphasis> <strong>O_NDELAY</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-O_005fNDELAY" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>This is an obsolete name for <code>O_NONBLOCK</code>, provided for
compatibility with BSD.  It is not defined by the POSIX.1 standard.
</para></dd></dl>

<para>The remaining operating modes are BSD and GNU extensions.  They exist only
on some systems.  On other systems, these macros are not defined.
</para>
<dl class="def">
<dt xml:id="glibc-index-O_005fASYNC"><span class="category">Macro: </span><span><emphasis>int</emphasis> <strong>O_ASYNC</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-O_005fASYNC" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>The bit that enables asynchronous input mode.  If set, then <code>SIGIO</code>
signals will be generated when input is available.  See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Interrupt-Input">Interrupt-Driven Input</a>.
</para>
<para>Asynchronous input mode is a BSD feature.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-O_005fFSYNC"><span class="category">Macro: </span><span><emphasis>int</emphasis> <strong>O_FSYNC</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-O_005fFSYNC" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>The bit that enables synchronous writing for the file.  If set, each
<code>write</code> call will make sure the data is reliably stored on disk before
returning. </para>
<para>Synchronous writing is a BSD feature.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-O_005fSYNC"><span class="category">Macro: </span><span><emphasis>int</emphasis> <strong>O_SYNC</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-O_005fSYNC" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>This is another name for <code>O_FSYNC</code>.  They have the same value.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-O_005fNOATIME"><span class="category">Macro: </span><span><emphasis>int</emphasis> <strong>O_NOATIME</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-O_005fNOATIME" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>If this bit is set, <code>read</code> will not update the access time of the
file.  See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#File-Times">File Times</a>.  This is used by programs that do backups, so
that backing a file up does not count as reading it.
Only the owner of the file or the superuser may use this bit.
</para>
<para>This is a GNU extension.
</para></dd></dl>

<hr>
</div>
<div class="subsection" xml:id="glibc-Getting-File-Status-Flags">
<div class="header">
<para>
Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Operating-Modes" accesskey="p" rel="prev">I/O Operating Modes</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#File-Status-Flags" accesskey="u" rel="up">File Status Flags</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Getting-and-Setting-File-Status-Flags"></span><h4 class="subsection">13.15.4 Getting and Setting File Status Flags</title>

<para>The <code>fcntl</code> function can fetch or change file status flags.
</para>
<dl class="def">
<dt xml:id="glibc-index-F_005fGETFL-1"><span class="category">Macro: </span><span><emphasis>int</emphasis> <strong>F_GETFL</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-F_005fGETFL-1" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>This macro is used as the <var>command</var> argument to <code>fcntl</code>, to
read the file status flags for the open file with descriptor
<var>filedes</var>.
</para>
<para>The normal return value from <code>fcntl</code> with this command is a
nonnegative number which can be interpreted as the bitwise OR of the
individual flags.  Since the file access modes are not single-bit values,
you can mask off other bits in the returned flags with <code>O_ACCMODE</code>
to compare them.
</para>
<para>In case of an error, <code>fcntl</code> returns <em class="math">-1</emphasis>.  The following
<code>errno</code> error conditions are defined for this command:
</para>
<dl compact="compact">
<dt><span><code>EBADF</code></span></dt>
<dd><para>The <var>filedes</var> argument is invalid.
</para></dd>
</dl>
</dd></dl>

<dl class="def">
<dt xml:id="glibc-index-F_005fSETFL-1"><span class="category">Macro: </span><span><emphasis>int</emphasis> <strong>F_SETFL</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-F_005fSETFL-1" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>This macro is used as the <var>command</var> argument to <code>fcntl</code>, to set
the file status flags for the open file corresponding to the
<var>filedes</var> argument.  This command requires a third <code>int</code>
argument to specify the new flags, so the call looks like this:
</para>
<div class="example">
<pre class="example">fcntl (<var>filedes</var>, F_SETFL, <var>new-flags</var>)
</pre></div>

<para>You can’t change the access mode for the file in this way; that is,
whether the file descriptor was opened for reading or writing.
</para>
<para>The normal return value from <code>fcntl</code> with this command is an
unspecified value other than <em class="math">-1</emphasis>, which indicates an error.  The
error conditions are the same as for the <code>F_GETFL</code> command.
</para></dd></dl>

<para>If you want to modify the file status flags, you should get the current
flags with <code>F_GETFL</code> and modify the value.  Don’t assume that the
flags listed here are the only ones that are implemented; your program
may be run years from now and more flags may exist then.  For example,
here is a function to set or clear the flag <code>O_NONBLOCK</code> without
altering any other flags:
</para>
<div class="example">
<pre class="example">/* <span class="roman">Set the <code>O_NONBLOCK</code> flag of <var>desc</var> if <var>value</var> is nonzero,</span>
   <span class="roman">or clear the flag if <var>value</var> is 0.</span>
   <span class="roman">Return 0 on success, or -1 on error with <code>errno</code> set.</span> */

int
set_nonblock_flag (int desc, int value)
{
  int oldflags = fcntl (desc, F_GETFL, 0);
  /* <span class="roman">If reading the flags failed, return error indication now.</span> */
  if (oldflags == -1)
    return -1;
  /* <span class="roman">Set just the flag we want to set.</span> */
  if (value != 0)
    oldflags |= O_NONBLOCK;
  else
    oldflags &amp;= ~O_NONBLOCK;
  /* <span class="roman">Store modified flag word in the descriptor.</span> */
  return fcntl (desc, F_SETFL, oldflags);
}
</pre></div>

<hr>
</div>
</div>
<sect xml:id="glibc-File-Locks">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Open-File-Description-Locks" accesskey="n" rel="next">Open File Description Locks</a>, Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#File-Status-Flags" accesskey="p" rel="prev">File Status Flags</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Low_002dLevel-I_002fO" accesskey="u" rel="up">Low-Level Input/Output</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-File-Locks-1"></span><h3 class="section">13.16 File Locks</title>

<span xml:id="glibc-index-file-locks"></span>
<span xml:id="glibc-index-record-locking"></span>
<para>This section describes record locks that are associated with the process.
There is also a different type of record lock that is associated with the
open file description instead of the process.  See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Open-File-Description-Locks">Open File Description Locks</a>.
</para>
<para>The remaining <code>fcntl</code> commands are used to support <emphasis>record
locking</emphasis>, which permits multiple cooperating programs to prevent each
other from simultaneously accessing parts of a file in error-prone
ways.
</para>
<span xml:id="glibc-index-exclusive-lock"></span>
<span xml:id="glibc-index-write-lock"></span>
<para>An <emphasis>exclusive</emphasis> or <emphasis>write</emphasis> lock gives a process exclusive access
for writing to the specified part of the file.  While a write lock is in
place, no other process can lock that part of the file.
</para>
<span xml:id="glibc-index-shared-lock"></span>
<span xml:id="glibc-index-read-lock"></span>
<para>A <emphasis>shared</emphasis> or <emphasis>read</emphasis> lock prohibits any other process from
requesting a write lock on the specified part of the file.  However,
other processes can request read locks.
</para>
<para>The <code>read</code> and <code>write</code> functions do not actually check to see
whether there are any locks in place.  If you want to implement a
locking protocol for a file shared by multiple processes, your application
must do explicit <code>fcntl</code> calls to request and clear locks at the
appropriate points.
</para>
<para>Locks are associated with processes.  A process can only have one kind
of lock set for each byte of a given file.  When any file descriptor for
that file is closed by the process, all of the locks that process holds
on that file are released, even if the locks were made using other
descriptors that remain open.  Likewise, locks are released when a
process exits, and are not inherited by child processes created using
<code>fork</code> (see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Creating-a-Process">Creating a Process</a>).
</para>
<para>When making a lock, use a <code>struct flock</code> to specify what kind of
lock and where.  This data type and the associated macros for the
<code>fcntl</code> function are declared in the header file <filename>fcntl.h</filename>.
<span xml:id="glibc-index-fcntl_002eh-6"></span>
</para>
<dl class="def">
<dt xml:id="glibc-index-struct-flock"><span class="category">Data Type: </span><span><strong>struct flock</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-struct-flock" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>This structure is used with the <code>fcntl</code> function to describe a file
lock.  It has these members:
</para>
<dl compact="compact">
<dt><span><code>short int l_type</code></span></dt>
<dd><para>Specifies the type of the lock; one of <code>F_RDLCK</code>, <code>F_WRLCK</code>, or
<code>F_UNLCK</code>.
</para>
</dd>
<dt><span><code>short int l_whence</code></span></dt>
<dd><para>This corresponds to the <var>whence</var> argument to <code>fseek</code> or
<code>lseek</code>, and specifies what the offset is relative to.  Its value
can be one of <code>SEEK_SET</code>, <code>SEEK_CUR</code>, or <code>SEEK_END</code>.
</para>
</dd>
<dt><span><code>off_t l_start</code></span></dt>
<dd><para>This specifies the offset of the start of the region to which the lock
applies, and is given in bytes relative to the point specified by the
<code>l_whence</code> member.
</para>
</dd>
<dt><span><code>off_t l_len</code></span></dt>
<dd><para>This specifies the length of the region to be locked.  A value of
<code>0</code> is treated specially; it means the region extends to the end of
the file.
</para>
</dd>
<dt><span><code>pid_t l_pid</code></span></dt>
<dd><para>This field is the process ID (see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Process-Creation-Concepts">Process Creation Concepts</a>) of the
process holding the lock.  It is filled in by calling <code>fcntl</code> with
the <code>F_GETLK</code> command, but is ignored when making a lock.  If the
conflicting lock is an open file description lock
(see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Open-File-Description-Locks">Open File Description Locks</a>), then this field will be set to
<em class="math">-1</emphasis>.
</para></dd>
</dl>
</dd></dl>

<dl class="def">
<dt xml:id="glibc-index-F_005fGETLK-1"><span class="category">Macro: </span><span><emphasis>int</emphasis> <strong>F_GETLK</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-F_005fGETLK-1" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>This macro is used as the <var>command</var> argument to <code>fcntl</code>, to
specify that it should get information about a lock.  This command
requires a third argument of type <code>struct&nbsp;flock&nbsp;*</code> to be passed
to <code>fcntl</code>, so that the form of the call is:
</para>
<div class="example">
<pre class="example">fcntl (<var>filedes</var>, F_GETLK, <var>lockp</var>)
</pre></div>

<para>If there is a lock already in place that would block the lock described
by the <var>lockp</var> argument, information about that lock overwrites
<code>*<var>lockp</var></code>.  Existing locks are not reported if they are
compatible with making a new lock as specified.  Thus, you should
specify a lock type of <code>F_WRLCK</code> if you want to find out about both
read and write locks, or <code>F_RDLCK</code> if you want to find out about
write locks only.
</para>
<para>There might be more than one lock affecting the region specified by the
<var>lockp</var> argument, but <code>fcntl</code> only returns information about
one of them.  The <code>l_whence</code> member of the <var>lockp</var> structure is
set to <code>SEEK_SET</code> and the <code>l_start</code> and <code>l_len</code> fields
set to identify the locked region.
</para>
<para>If no lock applies, the only change to the <var>lockp</var> structure is to
update the <code>l_type</code> to a value of <code>F_UNLCK</code>.
</para>
<para>The normal return value from <code>fcntl</code> with this command is an
unspecified value other than <em class="math">-1</emphasis>, which is reserved to indicate an
error.  The following <code>errno</code> error conditions are defined for
this command:
</para>
<dl compact="compact">
<dt><span><code>EBADF</code></span></dt>
<dd><para>The <var>filedes</var> argument is invalid.
</para>
</dd>
<dt><span><code>EINVAL</code></span></dt>
<dd><para>Either the <var>lockp</var> argument doesn’t specify valid lock information,
or the file associated with <var>filedes</var> doesn’t support locks.
</para></dd>
</dl>
</dd></dl>

<dl class="def">
<dt xml:id="glibc-index-F_005fSETLK-1"><span class="category">Macro: </span><span><emphasis>int</emphasis> <strong>F_SETLK</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-F_005fSETLK-1" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>This macro is used as the <var>command</var> argument to <code>fcntl</code>, to
specify that it should set or clear a lock.  This command requires a
third argument of type <code>struct&nbsp;flock&nbsp;*</code> to be passed to
<code>fcntl</code>, so that the form of the call is:
</para>
<div class="example">
<pre class="example">fcntl (<var>filedes</var>, F_SETLK, <var>lockp</var>)
</pre></div>

<para>If the process already has a lock on any part of the region, the old lock
on that part is replaced with the new lock.  You can remove a lock
by specifying a lock type of <code>F_UNLCK</code>.
</para>
<para>If the lock cannot be set, <code>fcntl</code> returns immediately with a value
of <em class="math">-1</emphasis>.  This function does not block while waiting for other processes
to release locks.  If <code>fcntl</code> succeeds, it returns a value other
than <em class="math">-1</emphasis>.
</para>
<para>The following <code>errno</code> error conditions are defined for this
function:
</para>
<dl compact="compact">
<dt><span><code>EAGAIN</code></span></dt>
<dt><span><code>EACCES</code></span></dt>
<dd><para>The lock cannot be set because it is blocked by an existing lock on the
file.  Some systems use <code>EAGAIN</code> in this case, and other systems
use <code>EACCES</code>; your program should treat them alike, after
<code>F_SETLK</code>.  (GNU/Linux and GNU/Hurd systems always use <code>EAGAIN</code>.)
</para>
</dd>
<dt><span><code>EBADF</code></span></dt>
<dd><para>Either: the <var>filedes</var> argument is invalid; you requested a read lock
but the <var>filedes</var> is not open for read access; or, you requested a
write lock but the <var>filedes</var> is not open for write access.
</para>
</dd>
<dt><span><code>EINVAL</code></span></dt>
<dd><para>Either the <var>lockp</var> argument doesn’t specify valid lock information,
or the file associated with <var>filedes</var> doesn’t support locks.
</para>
</dd>
<dt><span><code>ENOLCK</code></span></dt>
<dd><para>The system has run out of file lock resources; there are already too
many file locks in place.
</para>
<para>Well-designed file systems never report this error, because they have no
limitation on the number of locks.  However, you must still take account
of the possibility of this error, as it could result from network access
to a file system on another machine.
</para></dd>
</dl>
</dd></dl>

<dl class="def">
<dt xml:id="glibc-index-F_005fSETLKW-1"><span class="category">Macro: </span><span><emphasis>int</emphasis> <strong>F_SETLKW</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-F_005fSETLKW-1" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>This macro is used as the <var>command</var> argument to <code>fcntl</code>, to
specify that it should set or clear a lock.  It is just like the
<code>F_SETLK</code> command, but causes the process to block (or wait)
until the request can be specified.
</para>
<para>This command requires a third argument of type <code>struct flock *</code>, as
for the <code>F_SETLK</code> command.
</para>
<para>The <code>fcntl</code> return values and errors are the same as for the
<code>F_SETLK</code> command, but these additional <code>errno</code> error conditions
are defined for this command:
</para>
<dl compact="compact">
<dt><span><code>EINTR</code></span></dt>
<dd><para>The function was interrupted by a signal while it was waiting.
See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Interrupted-Primitives">Primitives Interrupted by Signals</a>.
</para>
</dd>
<dt><span><code>EDEADLK</code></span></dt>
<dd><para>The specified region is being locked by another process.  But that
process is waiting to lock a region which the current process has
locked, so waiting for the lock would result in deadlock.  The system
does not guarantee that it will detect all such conditions, but it lets
you know if it notices one.
</para></dd>
</dl>
</dd></dl>


<para>The following macros are defined for use as values for the <code>l_type</code>
member of the <code>flock</code> structure.  The values are integer constants.
</para>
<dl compact="compact">
<dt xml:id="glibc-index-F_005fRDLCK"><span><code>F_RDLCK</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-F_005fRDLCK" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>This macro is used to specify a read (or shared) lock.
</para>
</dd>
<dt xml:id="glibc-index-F_005fWRLCK"><span><code>F_WRLCK</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-F_005fWRLCK" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>This macro is used to specify a write (or exclusive) lock.
</para>
</dd>
<dt xml:id="glibc-index-F_005fUNLCK"><span><code>F_UNLCK</code><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-F_005fUNLCK" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>This macro is used to specify that the region is unlocked.
</para></dd>
</dl>

<para>As an example of a situation where file locking is useful, consider a
program that can be run simultaneously by several different users, that
logs status information to a common file.  One example of such a program
might be a game that uses a file to keep track of high scores.  Another
example might be a program that records usage or accounting information
for billing purposes.
</para>
<para>Having multiple copies of the program simultaneously writing to the
file could cause the contents of the file to become mixed up.  But
you can prevent this kind of problem by setting a write lock on the
file before actually writing to the file.
</para>
<para>If the program also needs to read the file and wants to make sure that
the contents of the file are in a consistent state, then it can also use
a read lock.  While the read lock is set, no other process can lock
that part of the file for writing.
</para>

<para>Remember that file locks are only an <emphasis>advisory</emphasis> protocol for
controlling access to a file.  There is still potential for access to
the file by programs that don’t use the lock protocol.
</para>
<hr>
</div>
<sect xml:id="glibc-Open-File-Description-Locks">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Open-File-Description-Locks-Example" accesskey="n" rel="next">Open File Description Locks Example</a>, Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#File-Locks" accesskey="p" rel="prev">File Locks</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Low_002dLevel-I_002fO" accesskey="u" rel="up">Low-Level Input/Output</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Open-File-Description-Locks-1"></span><h3 class="section">13.17 Open File Description Locks</title>

<para>In contrast to process-associated record locks (see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#File-Locks">File Locks</a>),
open file description record locks are associated with an open file
description rather than a process.
</para>
<para>Using <code>fcntl</code> to apply an open file description lock on a region that
already has an existing open file description lock that was created via the
same file descriptor will never cause a lock conflict.
</para>
<para>Open file description locks are also inherited by child processes across
<code>fork</code>, or <code>clone</code> with <code>CLONE_FILES</code> set
(see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Creating-a-Process">Creating a Process</a>), along with the file descriptor.
</para>
<para>It is important to distinguish between the open file <emphasis>description</emphasis> (an
instance of an open file, usually created by a call to <code>open</code>) and
an open file <emphasis>descriptor</emphasis>, which is a numeric value that refers to the
open file description.  The locks described here are associated with the
open file <emphasis>description</emphasis> and not the open file <emphasis>descriptor</emphasis>.
</para>
<para>Using <code>dup</code> (see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Duplicating-Descriptors">Duplicating Descriptors</a>) to copy a file
descriptor does not give you a new open file description, but rather copies a
reference to an existing open file description and assigns it to a new
file descriptor.  Thus, open file description locks set on a file
descriptor cloned by <code>dup</code> will never conflict with open file
description locks set on the original descriptor since they refer to the
same open file description.  Depending on the range and type of lock
involved, the original lock may be modified by a <code>F_OFD_SETLK</code> or
<code>F_OFD_SETLKW</code> command in this situation however.
</para>
<para>Open file description locks always conflict with process-associated locks,
even if acquired by the same process or on the same open file
descriptor.
</para>
<para>Open file description locks use the same <code>struct flock</code> as
process-associated locks as an argument (see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#File-Locks">File Locks</a>) and the
macros for the <code>command</code> values are also declared in the header file
<filename>fcntl.h</filename>. To use them, the macro <code>_GNU_SOURCE</code> must be
defined prior to including any header file.
</para>
<para>In contrast to process-associated locks, any <code>struct flock</code> used as
an argument to open file description lock commands must have the <code>l_pid</code>
value set to <em class="math">0</emphasis>.  Also, when returning information about an
open file description lock in a <code>F_GETLK</code> or <code>F_OFD_GETLK</code> request,
the <code>l_pid</code> field in <code>struct flock</code> will be set to <em class="math">-1</emphasis>
to indicate that the lock is not associated with a process.
</para>
<para>When the same <code>struct flock</code> is reused as an argument to a
<code>F_OFD_SETLK</code> or <code>F_OFD_SETLKW</code> request after being used for an
<code>F_OFD_GETLK</code> request, it is necessary to inspect and reset the
<code>l_pid</code> field to <em class="math">0</emphasis>.
</para>
<span xml:id="glibc-index-fcntl_002eh_002e"></span>

<dl class="def">
<dt xml:id="glibc-index-F_005fOFD_005fGETLK-1"><span class="category">Macro: </span><span><emphasis>int</emphasis> <strong>F_OFD_GETLK</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-F_005fOFD_005fGETLK-1" class="copiable-anchor"> ¶</a></span></dt>
<dd><para>This macro is used as the <var>command</var> argument to <code>fcntl</code>, to
specify that it should get information about a lock.  This command
requires a third argument of type <code>struct&nbsp;flock&nbsp;*</code> to be passed
to <code>fcntl</code>, so that the form of the call is:
</para>
<div class="example">
<pre class="example">fcntl (<var>filedes</var>, F_OFD_GETLK, <var>lockp</var>)
</pre></div>

<para>If there is a lock already in place that would block the lock described
by the <var>lockp</var> argument, information about that lock is written to
<code>*<var>lockp</var></code>.  Existing locks are not reported if they are
compatible with making a new lock as specified.  Thus, you should
specify a lock type of <code>F_WRLCK</code> if you want to find out about both
read and write locks, or <code>F_RDLCK</code> if you want to find out about
write locks only.
</para>
<para>There might be more than one lock affecting the region specified by the
<var>lockp</var> argument, but <code>fcntl</code> only returns information about
one of them. Which lock is returned in this situation is undefined.
</para>
<para>The <code>l_whence</code> member of the <var>lockp</var> structure are set to
<code>SEEK_SET</code> and the <code>l_start</code> and <code>l_len</code> fields are set
to identify the locked region.
</para>
<para>If no conflicting lock exists, the only change to the <var>lockp</var> structure
is to update the <code>l_type</code> field to the value <code>F_UNLCK</code>.
</para>
<para>The normal return value from <code>fcntl</code> with this command is either <em class="math">0</emphasis>
on success or <em class="math">-1</emphasis>, which indicates an error. The following <code>errno</code>
error conditions are defined for this command:
</para>
<dl compact="compact">
<dt><span><code>EBADF</code></span></dt>
<dd><para>The <var>filedes</var> argument is invalid.
</para>
</dd>
<dt><span><code>EINVAL</code></span></dt>
<dd><para>Either the <var>lockp</var> argument doesn’t specify valid lock information,
the operating system kernel doesn’t support open file description locks, or the file
associated with <var>filedes</var> doesn’t support locks.
</para></dd>
</dl>
</dd></dl>

<dl class="def">
<dt xml:id="glibc-index-F_005fOFD_005fSETLK-1"><span class="category">Macro: </span><span><emphasis>int</emphasis> <strong>F_OFD_SETLK</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-F_005fOFD_005fSETLK-1" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>This macro is used as the <var>command</var> argument to <code>fcntl</code>, to
specify that it should set or clear a lock.  This command requires a
third argument of type <code>struct&nbsp;flock&nbsp;*</code> to be passed to
<code>fcntl</code>, so that the form of the call is:
</para>
<div class="example">
<pre class="example">fcntl (<var>filedes</var>, F_OFD_SETLK, <var>lockp</var>)
</pre></div>

<para>If the open file already has a lock on any part of the
region, the old lock on that part is replaced with the new lock.  You
can remove a lock by specifying a lock type of <code>F_UNLCK</code>.
</para>
<para>If the lock cannot be set, <code>fcntl</code> returns immediately with a value
of <em class="math">-1</emphasis>.  This command does not wait for other tasks
to release locks.  If <code>fcntl</code> succeeds, it returns <em class="math">0</emphasis>.
</para>
<para>The following <code>errno</code> error conditions are defined for this
command:
</para>
<dl compact="compact">
<dt><span><code>EAGAIN</code></span></dt>
<dd><para>The lock cannot be set because it is blocked by an existing lock on the
file.
</para>
</dd>
<dt><span><code>EBADF</code></span></dt>
<dd><para>Either: the <var>filedes</var> argument is invalid; you requested a read lock
but the <var>filedes</var> is not open for read access; or, you requested a
write lock but the <var>filedes</var> is not open for write access.
</para>
</dd>
<dt><span><code>EINVAL</code></span></dt>
<dd><para>Either the <var>lockp</var> argument doesn’t specify valid lock information,
the operating system kernel doesn’t support open file description locks, or the
file associated with <var>filedes</var> doesn’t support locks.
</para>
</dd>
<dt><span><code>ENOLCK</code></span></dt>
<dd><para>The system has run out of file lock resources; there are already too
many file locks in place.
</para>
<para>Well-designed file systems never report this error, because they have no
limitation on the number of locks.  However, you must still take account
of the possibility of this error, as it could result from network access
to a file system on another machine.
</para></dd>
</dl>
</dd></dl>

<dl class="def">
<dt xml:id="glibc-index-F_005fOFD_005fSETLKW-1"><span class="category">Macro: </span><span><emphasis>int</emphasis> <strong>F_OFD_SETLKW</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-F_005fOFD_005fSETLKW-1" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>This macro is used as the <var>command</var> argument to <code>fcntl</code>, to
specify that it should set or clear a lock.  It is just like the
<code>F_OFD_SETLK</code> command, but causes the process to wait until the request
can be completed.
</para>
<para>This command requires a third argument of type <code>struct flock *</code>, as
for the <code>F_OFD_SETLK</code> command.
</para>
<para>The <code>fcntl</code> return values and errors are the same as for the
<code>F_OFD_SETLK</code> command, but these additional <code>errno</code> error conditions
are defined for this command:
</para>
<dl compact="compact">
<dt><span><code>EINTR</code></span></dt>
<dd><para>The function was interrupted by a signal while it was waiting.
See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Interrupted-Primitives">Primitives Interrupted by Signals</a>.
</para>
</dd>
</dl>
</dd></dl>

<para>Open file description locks are useful in the same sorts of situations as
process-associated locks. They can also be used to synchronize file
access between threads within the same process by having each thread perform
its own <code>open</code> of the file, to obtain its own open file description.
</para>
<para>Because open file description locks are automatically freed only upon
closing the last file descriptor that refers to the open file
description, this locking mechanism avoids the possibility that locks
are inadvertently released due to a library routine opening and closing
a file without the application being aware.
</para>
<para>As with process-associated locks, open file description locks are advisory.
</para>
<hr>
</div>
<sect xml:id="glibc-Open-File-Description-Locks-Example">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Interrupt-Input" accesskey="n" rel="next">Interrupt-Driven Input</a>, Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Open-File-Description-Locks" accesskey="p" rel="prev">Open File Description Locks</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Low_002dLevel-I_002fO" accesskey="u" rel="up">Low-Level Input/Output</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Open-File-Description-Locks-Example-1"></span><h3 class="section">13.18 Open File Description Locks Example</title>

<para>Here is an example of using open file description locks in a threaded
program. If this program used process-associated locks, then it would be
subject to data corruption because process-associated locks are shared
by the threads inside a process, and thus cannot be used by one thread
to lock out another thread in the same process.
</para>
<para>Proper error handling has been omitted in the following program for
brevity.
</para>
<div class="example">
<pre class="example">
#define _GNU_SOURCE
#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;pthread.h&gt;

#define FILENAME        "/tmp/foo"
#define NUM_THREADS     3
#define ITERATIONS      5

void *
thread_start (void *arg)
{
  int i, fd, len;
  long tid = (long) arg;
  char buf[256];
  struct flock lck = {
    .l_whence = SEEK_SET,
    .l_start = 0,
    .l_len = 1,
  };

  fd = open ("/tmp/foo", O_RDWR | O_CREAT, 0666);

  for (i = 0; i &lt; ITERATIONS; i++)
    {
      lck.l_type = F_WRLCK;
      fcntl (fd, F_OFD_SETLKW, &amp;lck);

      len = sprintf (buf, "%d: tid=%ld fd=%d\n", i, tid, fd);

      lseek (fd, 0, SEEK_END);
      write (fd, buf, len);
      fsync (fd);

      lck.l_type = F_UNLCK;
      fcntl (fd, F_OFD_SETLK, &amp;lck);

      /* <span class="roman">sleep to ensure lock is yielded to another thread</span> */
      usleep (1);
    }
  pthread_exit (NULL);
}

int
main (int argc, char **argv)
{
  long i;
  pthread_t threads[NUM_THREADS];

  truncate (FILENAME, 0);

  for (i = 0; i &lt; NUM_THREADS; i++)
    pthread_create (&amp;threads[i], NULL, thread_start, (void *) i);

  pthread_exit (NULL);
  return 0;
}
</pre></div>

<para>This example creates three threads each of which loops five times,
appending to the file.  Access to the file is serialized via open file
description locks. If we compile and run the above program, we’ll end up
with /tmp/foo that has 15 lines in it.
</para>
<para>If we, however, were to replace the <code>F_OFD_SETLK</code> and
<code>F_OFD_SETLKW</code> commands with their process-associated lock
equivalents, the locking essentially becomes a noop since it is all done
within the context of the same process. That leads to data corruption
(typically manifested as missing lines) as some threads race in and
overwrite the data written by others.
</para>
<hr>
</div>
<sect xml:id="glibc-Interrupt-Input">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#IOCTLs" accesskey="n" rel="next">Generic I/O Control operations</a>, Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Open-File-Description-Locks-Example" accesskey="p" rel="prev">Open File Description Locks Example</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Low_002dLevel-I_002fO" accesskey="u" rel="up">Low-Level Input/Output</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Interrupt_002dDriven-Input"></span><h3 class="section">13.19 Interrupt-Driven Input</title>

<span xml:id="glibc-index-interrupt_002ddriven-input"></span>
<para>If you set the <code>O_ASYNC</code> status flag on a file descriptor
(see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#File-Status-Flags">File Status Flags</a>), a <code>SIGIO</code> signal is sent whenever
input or output becomes possible on that file descriptor.  The process
or process group to receive the signal can be selected by using the
<code>F_SETOWN</code> command to the <code>fcntl</code> function.  If the file
descriptor is a socket, this also selects the recipient of <code>SIGURG</code>
signals that are delivered when out-of-band data arrives on that socket;
see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Out_002dof_002dBand-Data">Out-of-Band Data</a>.  (<code>SIGURG</code> is sent in any situation
where <code>select</code> would report the socket as having an “exceptional
condition”.  See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Waiting-for-I_002fO">Waiting for Input or Output</a>.)
</para>
<para>If the file descriptor corresponds to a terminal device, then <code>SIGIO</code>
signals are sent to the foreground process group of the terminal.
See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Job-Control">Job Control</a>.
</para>
<span xml:id="glibc-index-fcntl_002eh-7"></span>
<para>The symbols in this section are defined in the header file
<filename>fcntl.h</filename>.
</para>
<dl class="def">
<dt xml:id="glibc-index-F_005fGETOWN-1"><span class="category">Macro: </span><span><emphasis>int</emphasis> <strong>F_GETOWN</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-F_005fGETOWN-1" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>This macro is used as the <var>command</var> argument to <code>fcntl</code>, to
specify that it should get information about the process or process
group to which <code>SIGIO</code> signals are sent.  (For a terminal, this is
actually the foreground process group ID, which you can get using
<code>tcgetpgrp</code>; see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Terminal-Access-Functions">Functions for Controlling Terminal Access</a>.)
</para>
<para>The return value is interpreted as a process ID; if negative, its
absolute value is the process group ID.
</para>
<para>The following <code>errno</code> error condition is defined for this command:
</para>
<dl compact="compact">
<dt><span><code>EBADF</code></span></dt>
<dd><para>The <var>filedes</var> argument is invalid.
</para></dd>
</dl>
</dd></dl>

<dl class="def">
<dt xml:id="glibc-index-F_005fSETOWN-1"><span class="category">Macro: </span><span><emphasis>int</emphasis> <strong>F_SETOWN</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-F_005fSETOWN-1" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>This macro is used as the <var>command</var> argument to <code>fcntl</code>, to
specify that it should set the process or process group to which
<code>SIGIO</code> signals are sent.  This command requires a third argument
of type <code>pid_t</code> to be passed to <code>fcntl</code>, so that the form of
the call is:
</para>
<div class="example">
<pre class="example">fcntl (<var>filedes</var>, F_SETOWN, <var>pid</var>)
</pre></div>

<para>The <var>pid</var> argument should be a process ID.  You can also pass a
negative number whose absolute value is a process group ID.
</para>
<para>The return value from <code>fcntl</code> with this command is <em class="math">-1</emphasis>
in case of error and some other value if successful.  The following
<code>errno</code> error conditions are defined for this command:
</para>
<dl compact="compact">
<dt><span><code>EBADF</code></span></dt>
<dd><para>The <var>filedes</var> argument is invalid.
</para>
</dd>
<dt><span><code>ESRCH</code></span></dt>
<dd><para>There is no process or process group corresponding to <var>pid</var>.
</para></dd>
</dl>
</dd></dl>


<hr>
</div>
<sect xml:id="glibc-IOCTLs">
<div class="header">
<para>
Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Interrupt-Input" accesskey="p" rel="prev">Interrupt-Driven Input</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Low_002dLevel-I_002fO" accesskey="u" rel="up">Low-Level Input/Output</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Generic-I_002fO-Control-operations"></span><h3 class="section">13.20 Generic I/O Control operations</title>
<span xml:id="glibc-index-generic-i_002fo-control-operations"></span>
<span xml:id="glibc-index-IOCTLs"></span>

<para>GNU systems can handle most input/output operations on many different
devices and objects in terms of a few file primitives - <code>read</code>,
<code>write</code> and <code>lseek</code>.  However, most devices also have a few
peculiar operations which do not fit into this model.  Such as:
</para>
<ul>
<li> Changing the character font used on a terminal.

</li><li> Telling a magnetic tape system to rewind or fast forward.  (Since they
cannot move in byte increments, <code>lseek</code> is inapplicable).

</li><li> Ejecting a disk from a drive.

</li><li> Playing an audio track from a CD-ROM drive.

</li><li> Maintaining routing tables for a network.

</li></ul>

<para>Although some such objects such as sockets and terminals
<a xml:id="glibc-DOCF3" href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#FOOT3"><sup>3</sup></a> have special functions of their own, it would
not be practical to create functions for all these cases.
</para>
<para>Instead these minor operations, known as <emphasis>IOCTL</emphasis>s, are assigned code
numbers and multiplexed through the <code>ioctl</code> function, defined in
<code>sys/ioctl.h</code>.  The code numbers themselves are defined in many
different headers.
</para>
<dl class="def">
<dt xml:id="glibc-index-ioctl"><span class="category">Function: </span><span><emphasis>int</emphasis> <strong>ioctl</strong> <emphasis>(int <var>filedes</var>, int <var>command</var>, …)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-ioctl" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Safe
| AC-Safe
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>


<para>The <code>ioctl</code> function performs the generic I/O operation
<var>command</var> on <var>filedes</var>.
</para>
<para>A third argument is usually present, either a single number or a pointer
to a structure.  The meaning of this argument, the returned value, and
any error codes depends upon the command used.  Often <em class="math">-1</emphasis> is
returned for a failure.
</para>
</dd></dl>

<para>On some systems, IOCTLs used by different devices share the same numbers.
Thus, although use of an inappropriate IOCTL <emphasis>usually</emphasis> only produces
an error, you should not attempt to use device-specific IOCTLs on an
unknown device.
</para>
<para>Most IOCTLs are OS-specific and/or only used in special system utilities,
and are thus beyond the scope of this document.  For an example of the use
of an IOCTL, see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Out_002dof_002dBand-Data">Out-of-Band Data</a>.
</para>
<hr>
</div>
</div-->
</part>
