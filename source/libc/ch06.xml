<?xml version="1.0" encoding="UTF-8"?>
<!-- ********************************************************************
        glibc/ch06.xml,v2.36, GFDL,LGPL, NBB, 2023
     ******************************************************************** -->
<part xml:id="glibc-Character-Set-Handling">
 <title>Karakter Kümeleriyle Çalışma</title>
 <titleabbrev>Genişletilmiş karakter kümeleri desteği.</titleabbrev>
 <preliminary>
  <para>
   Bilgisayarların ilk görüldüğü zamanlarda karakter kümelerinde her karakter için altı, yedi ya da sekiz bit kullanılmıştı: Sekiz bitten (bir bayt) daha geniş karakter hiç yoktu. Bu yaklaşımın sınırlamaları latin karakter kümelerini kullanmayanlar nezdinde daha belirgin hale geldi. Bunlarda dilin karakter kümesindeki karakter sayısı için genellikle <code>2^8</code> yeterli değildir. Bu kısımda birden fazla karakter kümesini desteklemek için C kütüphanesine eklenmiş işlevsellikten söz edilecektir.
  </para>
 </preliminary>
 <chapter xml:id="glibc-Extended-Char-Intro">
  <title>Genişletilmiş Karakterlere Giriş</title>
  <para>
   Karakterlerle baytlar arasında 1:1 ilişki olan karakter kümeleri ile 1:2 den 1:4
   oranlarına kadar ilişki olan karakter kümeleri arasındaki farkları giderecek çok çeşitli çözümler vardır. Bu bölümün devamında, C kütüphanesinin bu işlevselliğini geliştirirken verilen tasarım kararlarını anlamaya yardımcı olacak birkaç örneğe de yer verilmiştir.
  </para>
  <para>
   <indexterm linkend="glibc-cp"><primary>dahili gösterim</primary></indexterm>
   Önce dahili ve harici gösterimler arasında bir ayrım yapılması gerekir. <wordasword>Dahili gösterim</wordasword> bir yazılım tarafından bellekte tutulan metnin gösterimidir. <wordasword>Harici gösterim</wordasword> ise bazı iletişim kanalları üzerinden aktarımda ya da bunlar üzerinde saklanacak metinlerin gösterimleridir. Harici gösterime örnek olarak, bir dizinde bulunan ve okunacak ya da ayrıştırılacak dosyalar gösterilebilir.
  </para>
  <para>
   Geleneksel olarak iki gösterim arasında fark yoktur. Tek baytlık dahili ve harici gösterim aynıdır ve eşit kullanılabilirliktedir. Bu kullanılabilirlik karakter kümeleri genişledikçe ve sayıları arttıkça azalır.
  </para>
  <para>
   Dahili gösterimle ilgili aşılacak sorunlardan biri farklı karakter kümeleriyle harici olarak kodlanmış metinlerin elde edilmesidir. İki metni okuyup bazı ölçütleri kullanarak karşılaştıran bir yazılım varsa, karşılaştırma sadece metinler dahili olarak ortak bir biçemde tutulabiliyorsa yapılabilir.
  </para>
  <para>
   <indexterm linkend="glibc-cp"><primary>geniş karakter</primary></indexterm>
   Böyle bir ortak biçim (= karakter kümesi) için sekiz bit elbette artık yeterli değildir. Öyleyse en küçük öge büyütülmelidir: <wordasword>geniş karakterler</wordasword> kullanılmalıdır. Karakter başına bir bayt yerine iki veya dört bayt kullanılması sözkonusu olacaktır. (Üç, bellek adreslemesi açısından iyi bir değer değildir ve dört bayttan fazlası da gerekmemektedir).
  </para>
  <para>
   <indexterm linkend="glibc-cp"><primary>Unicode</primary></indexterm>
   <indexterm linkend="glibc-cp"><primary>ISO 10646</primary></indexterm>
   Bu kılavuzun bazı bölümlerinde görüleceği gibi bellekte geniş karakterli metinlerle çalışabilen işlevlerle tamamen yeni bir işlev ailesi oluşturulmuştur. Bu tür geniş karakter gösterimleri için kullanılan karakter kümelerinin çoğu Unicode ve ISO 10646 (UCS olarak da bilinir. UCS: Universal Character Set - Evrensel Karakter Kümesi) kullanır. Unicode (yunikod diye okunur) bir 16 bitlik karakter kümesi olarak tasarlandı; ISO 10646 ise 31 bitlik dev bir kod uzayı olarak tasarlandı. Uygulamada her iki standart eşdeğerdir. İkisi de aynı karakter listesini ve aynı kod tablosunu kullanır. Fakat Unicode ek anlamsallık belirtir. Bu noktada, sadece ilk <code>0x10000</code> koda karakter atanmıştır (BMP: Basic Multilingual Plane - "Temel Çokdilli Seviye" olarak da bilinir). Unicode ve ISO 10646 karakterleri için tanımlanmış kodlamalar:
   <indexterm linkend="glibc-cp"><primary>UCS-2</primary></indexterm>
   <indexterm linkend="glibc-cp"><primary>UCS-4</primary></indexterm>
   <indexterm linkend="glibc-cp"><primary>UTF-8</primary></indexterm>
   <indexterm linkend="glibc-cp"><primary>UTF-16</primary></indexterm>
  </para>
  <simplelist>
   <member>
    CS-2 16 bitliktir ve sadece BMP'deki karakterleri içerir.
   </member>
   <member>
    UCS-4 32 bitliktir ve Unicode ve ISO 10646 karakterlerini içerir.
   </member>
   <member>
    UTF-8 tek baytla gösterilen ASCII karakter kümesine ek olarak  ASCII olmayan 2 ilâ 6 baytlık dizilimlerle ifade edilen karakterleri içerir.
   </member>
   <member>
    UTF-16, UCS-2'nin içerdiklerine ek olarak <code>0x10ffff</code>'ye kadar BMP olmayan karakterleri içerir.
   </member>
  </simplelist>
  <para>
   Geniş karakterleri göstermek için <type>char</type> türü yeterli değildir. Bu sebeple &isoc; standardı geniş karakterli dizge karakterlerini tutmak için tasarlanmış yeni bir veri türünden bahseder. Benzerliği sağlamak için tek bir geniş karakter alan işlevlerde kullanılan ve <type>int</type> türüne karşı düşen bir tür de vardır.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-pg"><primary>stddef.h</primary></indexterm>
   <indexterm linkend="glibc-tp" xml:id="glibc-tp-wchar_t"><primary>wchar_t</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-wchar_t"><primary>geniş dizgeler</primary><secondary>geniş karakter veri türü</secondary></indexterm>
   <csproto type="veri türü">
    <csname><function>wchar_t</function></csname>
   </csproto>
   <header>&stddef.h;</header>
   <para>
    Bu veri türü geniş karakterli dizgelerin temel türü olarak kullanılır. Başka bir deyişle, bu türden nesne dizileri, çok baytlı dizgeler için <code>char[]</code> dizisine eşdeğerdir.
   </para>
   <para>
    &isoc;90 standardı, <code>wchar_t</code>'den bahsederken gösterimi hakkında belirgin hiçbir şey söylemez. Sadece temel karakter kümesinin tüm elemanlarını saklama yeteneğinde olması gerektiğini belirtir. Diğer taraftan, gömülü sistemlere uyarlanabilirlik bakımından <code>wchar_t</code> türünün <type>char</type> olarak tanımlanması meşru olurdu.
   </para>
   <para>
    Fakat GNU sistemleri için <code>wchar_t</code> daima 32 bit genişliktedir ve tüm USC-4 değerleri gösterebilme yeteneğine sahiptir, böylece ISO 10646'nın tümü kapsama dahil olur. Bazı Unix sistemlerinde <code>wchar_t</code> 16 bitlik olarak tanımlanır ve sadece Unicode'u kapsar. Bu tanımlama standart açısından geçerli olmakla birlikte ISO 10646 ve UCS-2 deki karakterlerinin tümü ile UTF-16'nın 16 biti aşan karakterlerini fiilen çoklu geniş karakter kodlaması olarak gösterebilir. Fakat çoklu geniş karakterli kodlamaya başvurulması <code>wchar_t</code> türünün kullanım amacıyla çelişir.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-pg"><primary>wchar.h</primary></indexterm>
   <indexterm linkend="glibc-tp" xml:id="glibc-tp-wint_t"><primary>wint_t</primary></indexterm>
   <indexterm linkend="glibc-cp" xml:id="glibc-cp-wint_t"><primary>geniş karakterler</primary><secondary>geniş karakter veri türü</secondary></indexterm>
   <csproto type="veri türü">
    <csname><function>wint_t</function></csname>
   </csproto>
   <header>&wchar.h;</header>
   <para>
    <code>wint_t</code> tek bir geniş karakter içeren değişkenler ve bağımsız değişkenler için kullanılan bir veri türüdür. Normal <type>char</type> dizgeler kullanılırken isim olarak <type>int</type> türüne eşdeğer olan bu türün kullanılması önerilir. <type>wchar_t</type> ve <code>wint_t</code> türleri 32 bit genişlikte olduklarında çoğunlukla aynı gösterime sahiptir ancak, <type>wchar_t</type> <type>char</type> olarak tanımlanmışsa, bağımsız değişken terfilerinden dolayı <code>wint_t</code> de <type>int</type> olarak tanımlanmalıdır.
   </para>
   <para>
    Bu veri türü &isoc;90'ın 1. düzeltmesinde bulunur.
   </para>
  </csynopsis>
  <para>
   <type>char</type> veri türü için var olan makrolar gibi <type>wchar_t</type> türünden bir nesnenin gösterebileceği azami ve asgari değerleri belirten makrolar da vardır.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-pg"><primary>stdint.h</primary></indexterm>
   <indexterm linkend="glibc-vr" xml:id="glibc-vr-WCHAR_MIN"><primary>WCHAR_MIN</primary></indexterm>
   <csproto type="makro">
    <csname><type>wint_t</type><function>WCHAR_MIN</function></csname>
   </csproto>
   <header>&stdint.h;</header>
   <para>
    <type>wint_t</type> türünde bir nesne tarafından tutulabilecek en küçük değerdir.
   </para>
   <para>
    Bu makro &isoc;90 standardının 1. düzeltmesinde bulunur.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-vr" xml:id="glibc-vr-WCHAR_MAX"><primary>WCHAR_MAX</primary></indexterm>
   <csproto type="makro">
    <csname><type>wint_t</type><function>WCHAR_MAX</function></csname>
   </csproto>
   <header>&wchar.h;</header>
   <para>
    <type>wint_t</type> türünde bir nesne tarafından tutulabilecek en büyük değerdir.
   </para>
   <para>
    Bu makro &isoc;90 standardının 1. düzeltmesinde bulunur.
   </para>
  </csynopsis>
  <para>
   Diğer bir geniş karakterlere özel değer <varname>EOF</varname>'a eşdeğer olan <varname>WEOF</varname>'tur.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-vr" xml:id="glibc-vr-WEOF"><primary>WEOF</primary></indexterm>
   <csproto type="makro">
    <csname><type>wint_t</type><function>WEOF</function></csname>
   </csproto>
   <header>&wchar.h;</header>
   <para>
    <code>WEOF</code> makrosu genişletilmiş karakter kümesindeki herhangi bir üyeden farklı olan <type>wint_t</type> türünde bir sabit ifadesi olarak değerlendirilir.
   </para>
   <para>
    <code>WEOF</code>, <varname>EOF</varname> ile aynı değerde olmakla birlikte onun aksine negatif olamaz.  Başka bir deyişle, aşağıdaki küçük kod,
   </para>
   <screen>{
  int c;
  …
  while ((c = getc (fp)) &lt; 0)
    …
}
</screen>
   <para>
    geniş karakterler için doğrudan <code>WEOF</code>  kullanılarak aşağıdaki gibi yazılır:
   </para>
   <screen>{
  wint_t c;
  …
  while ((c = getwc (fp)) != WEOF)
    …
}
</screen>
   <para>
    Bu makro &isoc;90 standardının 1. düzeltmesinde bulunur.
   </para>
  </csynopsis>
  <para>
   <dicterm><english>endianess</english><turkish>bayt sıralaması</turkish></dicterm>
   Bu dahili gösterimler saklama ve aktarım sırasına sorunlara yol açar. Çünkü her geniş karakter çok sayıda bayttan oluşur ve bunlar bayt sıralamasından etkilenir. Makinelerin farklı bayt sıralamasına (endianess) sahip olmaları aynı verinin farklı değerlendirilmesine sebep olur. Bu bayt sıralaması ayrıca tamamı bayt temelli olan iletişim protokollerinden de etkilenir. Çoğunlukla gönderici geniş karakterleri baytlarına ayırmak konusunda bir karar vermek durumunda kalır. Bir son (ama en az önemli) husus da geniş karaktelerin, özelleştirilmiş tek baytlı karakter kümelerine göre daha fazla saklama alanı gerektirmesidir.
  </para>
  <para>
   <indexterm linkend="glibc-cp"><primary>çok baytlı karakter</primary></indexterm>
   <indexterm linkend="glibc-cp"><primary>EBCDIC</primary></indexterm>
   Yukarıdaki sebeplerden dolayı, dahili kodlama UCS-2 ya da UCS-4 ise çoğunlukla harici kodlama dahili kodlamadan farklı olur. Harici kodlama bayt temellidir ve ortama ve elde edilecek metine uygun olarak seçilebilir. Bu harici kodlama için farklı karakter kümeleri kullanılabilir. ASCII temelli tüm karakter kümeleri bir gereksinimi tamamen karşılar: Dosya sistemi bakımından yeterlilik (filesystem safe); yani <code>'/'</code> karakteri kodlama içinde sadece <emphasis>kendi</emphasis> olarak kullanılır. Bazı şeyler EBCDIC (Extended Binary Coded Decimal Interchange Code - Genişletilmiş İkil Kodlu Ondalık Değişim Kodu; IBM tarafından kullanılan bir karakter kümesi ailesidir) gibi karakter setleri için biraz farklıdır, ama işletim sistemi EBCDIC'i doğrudan anlayamıyorsa sistem çağrılarının bağımsız değişkenlerinde kullanmadan önce işletim sisteminin anlayabileceği kodlamaya dönüştürülmüş olmalıdır.
  </para>
  <itemizedlist>
   <listitem>
    <para>
     En basit karakter kümeleri tek baytlık karakter kümeleridir. Sadece 256 karakter içerebilir ve tüm dilleri kapsamak açısından yetersizdir. 8 bitlik karakter kümeleri ile çalışmak basittir. Daha sonra gösterileceği gibi bu doğru değildir, uygulamalar 8 bitlik karakter kümelerini kullanmaları gerektiği için kullanır.
    </para>
   </listitem>
   <listitem>
    <para>
     <indexterm linkend="glibc-cp"><primary>ISO 2022</primary></indexterm>
     ISO&nbsp;2022 standardı, bir baytttan daha fazla baytla gösterilebilen karakterlerin olduğu genişletilmiş karakter kümeleri için bir mekanizma tanımlar. Bu, bir metni bir durumla ilişkilendirerek yapılır.  Karakterler, metin içinde bulunabildikleri durumu değiştirmekte kullanılabilir. Metindeki her bayt, her durum için farklı yorumlanmalıdır. Bir baytın kendisi olarak mı yoksa bir karakteri oluşturan çok sayıda bayttan biri olarak mı yorumlanacağı duruma bağlıdır.
    </para>
    <para>
     <indexterm linkend="glibc-cp"><primary>EUC</primary></indexterm>
     <indexterm linkend="glibc-cp"><primary>Shift_JIS</primary></indexterm>
     <indexterm linkend="glibc-cp"><primary>SJIS</primary></indexterm>
     ISO 2022'nin çoğu kullanımında tanımlı karakter kümeleri bir sonraki karakterden fazlasını kapsayan durum değişikliklerine izin vermez. Bir karakterin bayt sırasının başlangıcı bulunduktan sonra metin doğru olarak yorumlanabildiğinden bu büyük yarar sağlar. Bu kuralı kullanan karakter kümelerine örnek olarak çeşitli EUC karakter kümeleri (Sun'ın işletim sistemlerinde kullanılan, EUC-JP, EUC-KR, EUC-TW ve EUC-CN) veya Shift_JIS (SJIS, bir Japonca kodlama) verilebilir.
    </para>
    <para>
     Ancak bir karakterden daha fazlası için geçerli olan ve diğer bir bayt sıralaması tarafından değiştirilen bir durumu kullanan karakter kümeleri de vardır. Bunlara örnek olarak  ISO-2022-JP, ISO-2022-KR ve ISO-2022-CN verilebilir.
    </para>
   </listitem>
   <listitem>
    <para>
     <indexterm linkend="glibc-cp"><primary>ISO 6937</primary></indexterm>
     Latin abecesini kullanan dillerin 8 bitlik karakter kümelerini düzeltmek için başlatılan çalışmalar ISO 6937 benzeri karakter kümeleri ile sonuçlandı. Burada vurgulu aksan gibi karakterleri oluşturan baytlar kendileri olarak bir çıktı üretmez: İstenen sonucu üretmek için birtakım karakterler birlikte kullanılır. Örneğin, "vurgulu küçük a" karakterini elde etmek için <code>0xc2 0x61</code> bayt dizisi (basılmayan vurgu, ardından küçük harf 'a' gelir). Vurgulu aksan karakterinin tek başına kendisini elde etmek için, <code>0xc2 0x20</code> (basılmayan vurgu ve ardından boşluk) yazılmalıdır.
    </para>
    <para>
     ISO&nbsp;6937 benzeri karakter kümeleri teletex gibi bazı gömülü sistemlerde kullanılır.
    </para>
   </listitem>
   <listitem>
    <para>
     <indexterm linkend="glibc-cp"><primary>UTF-8</primary></indexterm>
     Dahili olarak kullanılan Unicode veya ISO 10646 metinlerini dönüştürmek yerine UCS-2/UCS-4 den farklı bir kodlamanın kullanılması çoğunlukla yeterli olur. Unicode ve ISO 10646'nın her ikisi de böyle bir kodlamayı belirtir: UTF-8. Bu kodlama, 1 bayttan 6 bayta kadar uzunluklarda bayt dizgelerini 31 bit genişlikle, ISO 10646'daki tüm karakterleri gösterebilmektedir.
    </para>
    <para>
     <indexterm linkend="glibc-cp"><primary>UTF-7</primary></indexterm>
     ISO 10646'yı UTF-7 olarak kodlamak üzere bazı çalışmalarda yapılmıştır, ancak günümüzde kullanılması gereken tek kodlama UTF-8 dir. Aslında, UTF-8 gelecekte desteklenen tek harici kodlama olacaktır. Evrensel olarak kullanılabilirliği anlaşılmıştır. Tek olumsuz yanı, bazı dillerin karakterlerini oluştururken kullanılan bayt dizgelerinin uzunluğu bu diller (Kril, Yunan, Asya dilleri) için kullanılan özel kodlamalara  göre daha büyük yer harcanmasına sebep olmasıdır. Ancak Unicode sıkıştırma şeması gibi yöntemlerle bu sorunlar da giderilebilir.
    </para>
   </listitem>
  </itemizedlist>
  <para>
   Sona kalan soru şudur: Kullanılacak kodlama ya da karakter kümesi nasıl seçilecektir?
   Yanıt: Buna siz kendi kendinize karar veremezsiniz, bunu sistem geliştiricileri ile kullanıcıların çoğunluğunun yaptığı tercih belirler. Amaç birlikte çalışabilirlik olunca birinin kullandığını bir diğeri birlikte çalışabilmek için kullanacaktır. Bir kısıtlama yoksa seçim kullanıcıların ortak gereksinimlerine göre şekillenecektir. Başka bir deyişle örneğin, bir projenin sadece Rusya'da kullanılacağı düşünülüyorsa KOI8-R ya da benzeri bir karakter kümesi kullanmak gerekir. Ama aynı proje örneğin Yunanistan'da da kullanılabilecekse, karakter kümesi seçimi herkesin gereksinimlerine yanıt verebilecek şekilde seçilmelidir.
  </para>
  <para>
   En geniş çözümü sağlayan, en genel karakter kümesi hangisi diye baktığımızda bunun ISO&nbsp;10646 olduğunu görürüz.  Harici kodlama olarak UTF-8 kullanılır ve geçmişte kendi dillerini kullanmakta sorunları olan kullanıcıların sorunları kalmaz.
  </para>
  <para>
   Geniş karakter gösteriminin seçilmesi ile ilgili olarak son bir açıklama daha yapmak gerekir. Yukarıdaki açıklamaların ışığında doğal seçim Unicode veya ISO&nbsp;10646 kullanmaktır dedik. Bu gerekli değildir ama en azından &isoc; standardı tarafından cesaretlendiriliyoruz. Standart en azından <varname>__STDC_ISO_10646__</varname> diye bir makro tanımlar ve bu makro sadece <type>wchar_t</type> türünün kodladığı ISO&nbsp;10646 karakterlerinin kullanıldığı sistemlerde tanımlıdır. Bu sembolü tanımlamayarak geniş karakterli gösterimlerle ilgili kabuller yapılmasından kaçınılmalıdır. Yazılımcılar sadece C kütüphanesi tarafından sağlanan bu işlevleri kullandıklarında geniş karakterle ilgili olarak diğer sistemlerle bir uyumluluk sorunu yaşamaz.
  </para>
 </chapter>

 <chapter xml:id="glibc-Charset-Function-Overview">
  <title>Karakter Kümesi İşlevlerine Bakış</title>
  <titleabbrev>Karakterlerle çalışmak için kullanılan işlevlere bir bakış</titleabbrev>
  <para>
   Bir Unix C kütüphanesi karakter kümesi dönüşümleri için iki aile içinde toplanan üç farklı işlev kümesi içerir. İlk aile (en çok kullanılanı) &isoc;90 standardında belirtilmiştir ve bundan dolayı Unix dünyasında taşınabilirdir. Maalesef bu aile en az kullanışlı olanıdır. Özellikle kütüphane geliştirirken (uygulamaların aksine) bu işlevlerden mümkün olduğunca kaçınılmalıdır.
  </para>
  <para>
   İkinci işlev ailesi, erken dönem Unix standartlarında (XPG2) görülür ve hala en son ve en büyük Unix standardı olan Unix&nbsp;98'in de parçasıdır. Ayrıca en güçlü ve en kullanışlı işlevler kümesidir. Fakat biz, &isoc;90 1. düzeltmesinde tanımlanan işlevlerle başlayacağız.
  </para>
 </chapter>

 <chapter xml:id="glibc-Restartable-multibyte-conversion">
  <title>Çok Baytlı Dönüşüm</title>
  <titleabbrev>Çok baytlı dönüşüm işlevleri</titleabbrev>
  <preliminary>
   <para>
    &isoc; standardı dizgeleri çok baytlı gösterimden geniş karakterli dizgelere dönüştürecek işlevler tanımlar. Bunların birtakım tuhaf özellikleri vardır:
   </para>
   <itemizedlist>
    <listitem>
     <para>
      Çok baytlı kodlama için varsayılan karakter kümesi, işlevlere bağımsız değişken olarak belirtilmez. Bunun yerine yerelin <varname>LC_CTYPE</varname> sınıfı ile belirtilen karakter kümesi kullanılır; bkz. <xref linkend="glibc-Locale-Categories"/>.
     </para>
    </listitem>
    <listitem>
     <para>
      Bir defada bir karakterden fazlası ile çalışan işlevler bağımsız değişken olarak boş bayt sonlandırmalı dizgeler gerektirir (örneğin, metin bloklarının dönüşümü uygun bir yere boş bayt eklenmedikçe yapılmaz). &glibc; boyut belirtmeye imkan veren oluşumları içeriyor olsa da bunlar yine de genellikle sonlandırılmış dizge bekler.
     </para>
    </listitem>
   </itemizedlist>
   <para>
    Bu sınırlamalara rağmen &isoc; işlevleri çoğu bağlamda kullanılabilir. Grafik kullanıcı arayüzlerinde örneğin, metin basit ASCII değilse geniş karakterli dizge olarak gösterilmesinin gerektiği durumlar için kullanılacak işlevlerin de bulunması gerekir. Metin, çevirileri içeren bir dosyadan gelmeli, kullanıcı çeviriyi kullanabileceği yerele ve dolayısıyla ayrıca kullanacağı harici kodlamaya karar vermelidir. Böyle bir durumda (ve birçok başka durumda), burada açıklanan işlevler çok uygundur. Dönüşümleri uygularken daha özgür olmak istenirse <function>iconv</function> işlevlerine de bakılabilir: <xref linkend="glibc-Generic-Charset-Conversion"/>.
   </para>
  </preliminary>
  <sect1 xml:id="glibc-Selecting-the-Conversion">
   <title>Dönüşüm Seçimi</title>
   <titleabbrev>Dönüşüm ve özelliklerinin seçimi</titleabbrev>
   <para>
    <indexterm linkend="glibc-pg"><primary>limits.h</primary></indexterm>
    <indexterm linkend="glibc-pg"><primary>stdlib.h</primary></indexterm>
    Burada açıklayacağımız işlevler tarafından uygulanan dönüşümlerde önceki bölümde bahsettiğimiz gibi seçilen yerelin <varname>LC_CTYPE</varname> sınıfı tarafından belirlenen karakter kümesi kullanılır. Her yerelin (<function>localedef</function>'e bağımsız değişken olarak verilen) kendi karakter kümesi vardır ve bunun harici çok baytlı kodlamalardan biri olduğu kabul edilir. Geniş karakterli karakter kümesi daima UCS-4'tür, en azından GNU sistemlerinde böyledir.
   </para>
   <para>
    Çok baytlı karakter kümelerinin karakteristik özelliklerinden biri, bir karakteri göstermek için gereken en fazla bayt sayısıdır. Bu, dönüşüm işlevlerinin kullanıldığı bir kodu yazarken oldukça önemli bir bilgidir (örnekleri aşağıda görülebilir). Bu bilgiyi sağlamak için &isoc; standardı iki makro tanımlar.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-MB_LEN_MAX"><primary>MB_LEN_MAX</primary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>MB_LEN_MAX</function></csname>
    </csproto>
    <header>&limits.h;</header>
    <para>
     <code>MB_LEN_MAX</code> desteklenen yerellerin herhangi birinde tek bir karakterin çok baytlı gösterimindeki azami bayt sayısını belirler. Derleme zamanı sabitidir.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-vr" xml:id="glibc-vr-MB_CUR_MAX"><primary>MB_CUR_MAX</primary></indexterm>
    <csproto type="makro">
     <csname><type>int</type><function>MB_CUR_MAX</function></csname>
    </csproto>
    <header>&stdlib.h;</header>
    <para>
     <code>MB_CUR_MAX</code> geçerli yereldeki çok baytlı bir karakterin azami bayt sayısı olan pozitif bir tamsayı ifadeye genişletilir. Değeri hiçbir zaman <varname>MB_LEN_MAX</varname>'tan büyük olamaz. <varname>MB_LEN_MAX</varname>'ın tersine bu makronun derleme zamanı sabiti olması gerekmez ve &glibc;nde de derleme zamanı sabiti değildir.
    </para>
   </csynopsis>
   <para>
    &isoc; derleyicileri değişken uzunluklu dizi tanımlarına kesinlikle izin vermediğinden iki farklı makro gerekir, ancak yine de özdevimli bellek tahsisinden kaçınılması istenir. Kodun bu eksik parçası aşağıdaki soruna yol açar:
   </para>
   <example>
    <screen>{
  char tampon[MB_LEN_MAX];
  ssize_t uzunluk = 0;

  while (! feof (fp))
    {
      fread (&amp;tampon[len], 1, MB_CUR_MAX - uzunluk, fp);
      /* <replaceable>… tamponu işle</replaceable> */
      uzunluk -= kullanilan;
    }
}
</screen>
    <para>
     İç döngüdeki kod tek birçok baytlı karakterin dönüşümü için <replaceable>tampon</replaceable> dizisinde daima yeterli bayt bulunduğu varsayımına dayanır. Çoğu derleyici değişken uzunluktaki dizilere izin vermediğinden <replaceable>tampon</replaceable> dizisi sabit uzunluktadır. <function>fread</function> çağrısı <replaceable>tampon</replaceable> dizisinde daima <varname>MB_CUR_MAX</varname> bayt olduğundan emin olarak yapılır. Burada <varname>MB_CUR_MAX</varname> bir derleme zamanı sabiti değilse bir sorun çıkmaz.
    </para>
   </example>
  </sect1>
  <sect1 xml:id="glibc-Keeping-the-state">
   <title>Durumun saklanması</title>
   <titleabbrev>Dönüşüm durumunun gösterimi</titleabbrev>
   <para>
    <indexterm linkend="glibc-cp"><primary>durumsal</primary></indexterm>
    Bu kısmın başlarında <wordasword>durumsal</wordasword> kodlama kullanılan karakter kümelerinden bahsedilmişti. Bunların metnin içindeki kodlanmış değerleri öncekilere bir şekilde bağımlıdır.
   </para>
   <para>
    Dönüşüm işlevleri bir metni birden fazla adımda dönüştürebildiğinden bu bilginin işlevlerin bir çağrısından diğerine aktarılması gerekir.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-cp"><primary>öteleme durumu</primary></indexterm>
    <indexterm linkend="glibc-tp" xml:id="glibc-tp-mbstate_t"><primary>mbstate_t</primary></indexterm>
    <csproto type="veri türü">
     <csname><function>mbstate_t</function></csname>
    </csproto>
    <header>&wchar.h;</header>
    <para>
     <code>mbstate_t</code> türünde bir değişken bir dönüşüm işlevi çağrısından diğerine aktarılması gerekli olan <wordasword>öteleme durumu</wordasword> hakkında tüm bilgiyi içerir.
    </para>
    <para>
     <code>mbstate_t</code> türü &isoc;90 standardının 1. düzeltmesinde bulunur.
    </para>
   </csynopsis>
   <para>
    <type>mbstate_t</type> türünde nesneleri kullanırken yazılımcı bu nesneleri tanımlamalı (normalde yığıt üzerinde yerel değişkenler olarak) ve dönüşüm işlevine göstericisi ile aktarmalıdır. Çok baytlı karakter durumsal ise dönüşüm işlevi bu yolla nesneyi güncelleyebilir.
   </para>
   <para>
    Durum nesnesini belirli bir duruma koyacak bir ilklendirici ya da bu işleme özel bir işlev yoktur. Kurallar gereğince nesne daima ilk kullanımdan önce ilk durumu göstermeli ve bu, aşağıdaki gibi bir kodla değişkeni tamamen temizleyerek yapılmalıdır:
   </para>
   <example>
    <screen>{
  mbstate_t durum;
  memset (&amp;durum, '\0', sizeof (durum));
  /* <replaceable>bundan sonra <code>durum</code> kullanılabilir.</replaceable>  */
  …
}
</screen>
   </example>
   <para>
    Çıktıyı üretecek dönüşüm işlevlerini kullanırken çoğunlukla o anki durumun ilk durum olup olmadığına bakılması gerekir. Örneğin, dizilimin bir noktasında durumu ilk duruma ayarlayacak önceleme dizilimlerinin kullanılıp kullanılmayacağına karar vermek için bu gereklidir. İletişim protokolleri genellikle bunu gerektirir.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-mbsinit"><primary>mbsinit</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-mbsinit"><primary>çok baytlı dizgeler</primary><secondary>ilklendirme</secondary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>mbsinit</function></csname>
     <csparam><ptr>const&#160;mbstate_t</ptr><parameter>ps</parameter></csparam>
    </csproto>
    <header>&wchar.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     <code>mbsinit</code> işlevi göstericisi <parameter>ps</parameter> olan nesnenin ilk durumda olup olmadığını saptamakta kullanılır. <parameter>ps</parameter> bir boş göstericiyse ya da nesne ilk durumdaysa dönen değer sıfırdan farklı olur. Aksi takdirde sıfır döner.
    </para>
    <para>
     <code>mbsinit</code> işlevi &isoc;90 standardının 1. düzeltmesinde bulunur.
    </para>
   </csynopsis>
   <para>
    <function>mbsinit</function> kullanılan bir kod çoğunlukla aşağıdakine benzer:
   </para>
   <example>
    <screen>{
  mbstate_t durum;
  memset (&amp;durum, '\0', sizeof (durum));
  /* <replaceable><code>durum</code> burada kullanılıyor.</replaceable>  */
  …
  if (! mbsinit (&amp;durum))
    {
      /* <replaceable>ilk duruma döndürecek kod</replaceable>  */
      const wchar_t bos[] = L"";
      const wchar_t *kaynak = bos;
      wcsrtombs (outbuf, &amp;kaynak, outbuflen, &amp;durum);
    }
  …
}
</screen>
    <para>
     <dicterm><english>escape sequence</english><turkish>önceleme dizilimi</turkish></dicterm>
     İlk duruma geri dönmeyi sağlayacak olan önceleme dizilimini çıktılayacak kod ilginçtir. <function>wcsrtombs</function> işlevi gerekli çıktılama kodunu (bkz. <xref linkend="glibc-Converting-Strings"/>) saptamakta kullanılabilir.
    </para>
   </example>
   <note>
    <para>
     Geniş karakterli kodlama durumsal olmadığından GNU sistemlerinde çok baytlı metni geniş karakterli metne dönüştürmek için bu ek eylemin uygulanması gerekli değildir. Ancak bir durumsal kodlama kullanarak <type>wchar_t</type> yapılmasının yasaklanmasına hiçbir standartta değinilmemiştir.
    </para>
   </note>
  </sect1>
  <sect1 xml:id="glibc-Converting-a-Character">
   <title>Karakterlerin Dönüştürülmesi</title>
   <titleabbrev>Karakterlerin tek tek dönüştürülmesi</titleabbrev>
   <para>
    En temel dönüşüm işlevlerinin çoğu tek karakter ile çalışır. Tek karakterin her zaman tek bayt anlamına gelmediği unutulmamalıdır. Ancak çoğunlukla çok baytlı karakter kümeleri tek baytlık karakterler içerdiğinden, baytları dönüştürmeye yarayan işlevler vardır. Sıklıkla, ASCII çok baytlı karakter kümesinin bir alt kümesidir. Böyle bir senaryoda, her ASCII karakter kendini temsil eder, tüm diğer karakterlerin en azından ilk baytı <code>0</code> ile <code>127</code> arasındaki karakterlerden biri olur.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-btowc"><primary>btowc</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-btowc"><primary>karakter dönüşümü</primary><secondary>tek baytlıdan geniş karaktere</secondary></indexterm>
    <csproto type="işlev">
     <csname><type>wint_t</type><function>btowc</function></csname>
     <csparam><type>int</type><parameter>c</parameter></csparam>
    </csproto>
    <header>&wchar.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&asunsafe; &corrupt; &heap; &lock; &dlopen;</concept>
     <concept>&acunsafe; &corrupt; &lock; &mem; &fd;</concept>
    </conceptlist>
    <para>
     <code>btowc</code> işlevi ("byte to wide character" kısaltmasıdır), ilk öteleme durumundaki tek baytlık geçerli <parameter>c</parameter> karakterini geçerli <varname>LC_CTYPE</varname> yerelindeki dönüşüm kurallarına uygun olarak geniş karakter eşdeğerine dönüştürür.
    </para>
    <para>
     Eğer <code>(unsigned char)</code><parameter>c</parameter> geçerli olmayan tek baytlık birçok baytlı karakter ise ya da <parameter>c</parameter> karakteri <varname>EOF</varname> ise işlev <varname>WEOF</varname> ile döner.
    </para>
    <para>
     <parameter>c</parameter> karakterinin geçerliliğinin sadece ilk öteleme durumu için sınandığı unutulmamalıdır. Durum bilgisinin alınmasında kullanılacak bir <type>mbstate_t</type> nesnesi yoktur ve ayrıca işlev herhangi bir sabit durum kullanmaz.
    </para>
    <para>
     <code>btowc</code> işlevi &isoc;90 standardının 1. düzeltmesinde bulunur.
    </para>
   </csynopsis>
   <para>
    Tek baytlık değerlerin daima ilk durumuna göre yorumlanması sınırlamasına rağmen bu işlev aslında çoğu zaman oldukça kullanışlıdır. Karakterlerin çoğu ya tamamen tek baytlık karakter kümelerindendir ya da ASCII'ye göre bir genişletmedir. Bu bilgilerden sonra aşağıdaki gibi bir kod yazmak mümkündür (bu özel örnek çok kullanışlıdır):
   </para>
   <example>
    <screen>wchar_t *
itow (unsigned long int val)
{
  static wchar_t buf[30];
  wchar_t *wcp = &amp;buf[29];
  *wcp = L'\0';
  while (val != 0)
  {
      *--wcp = btowc ('0' + val % 10);
      val /= 10;
    }
  if (wcp == &amp;buf[29])
    *--wcp = L'0';
  return wcp;
}
</screen>
    <para>
     Böylesine karmaşık bir gerçeklemeyi kullanmak neden gerekli ve neden basitçe <code>'0' + val % 10</code> bir geniş karaktere dönüştürülmüyor? Yanıtı, <type>wchar_t</type> türünde karakterler üzerinde bu çeşit aritmetik işlemler uygulandığında sonuç garanti değildir de ondan. Diğer durumlarda ise baytlar derleme zamanında sabit değildir, bu nedenle derleyici işlem yapamaz. Bu gibi durumlarda <function>btowc</function> kullanmak gerekir.
    </para>
   </example>
   <para>
    Aksi yönde dönüşüm için de bir işlev vardır.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-wctob"><primary>wctob</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-wctob"><primary>karakter dönüşümü</primary><secondary>geniş karakterden tek baytlıya</secondary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>wctob</function></csname>
     <csparam><type>wint_t</type><parameter>c</parameter></csparam>
    </csproto>
    <header>&wchar.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&asunsafe; &corrupt; &heap; &lock; &dlopen;</concept>
     <concept>&acunsafe; &corrupt; &lock; &mem; &fd;</concept>
    </conceptlist>
    <para>
     <code>wctob</code> işlevi ("wide character to byte" kısaltmasıdır), bağımsız değişken olarak geçerli bir geniş karakter alır. Bu karakterin ilk durumu bir bayt uzunlukta ise işlevin dönüş değeri karakterin kendisi olacaktır. Aksi takdirde <varname>EOF</varname> döner.
    </para>
    <para>
     <code>wctob</code> işlevi &isoc;90 standardının 1. düzeltmesinde bulunur.
    </para>
   </csynopsis>
   <para>
    Karakterleri tek tek çok baytlı gösterimden geniş karakterli gösterime ya da tersine dönüştürecek daha genel amaçlı işlevler de vardır. Bu işlevler çok baytlı gösterimin uzunluğu ile ilgili bir sınırlamaya sahip değildir ve ayrıca ilk durumda olmayı gerektirmez.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-mbrtowc"><primary>mbrtowc</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-mbrtowc"><primary>karakter dönüşümü</primary><secondary>çok baytlıdan geniş karaktere</secondary></indexterm>
    <csproto type="işlev">
     <csname><type>size_t</type><function>mbrtowc</function></csname>
     <csparam><type>wchar_t&#160;*restrict</type><parameter>pwc</parameter></csparam>
     <csparam><type>const&#160;char&#160;*restrict</type><parameter>s</parameter></csparam>
     <csparam><type>size_t</type><parameter>n</parameter></csparam>
     <csparam><type>mbstate_t&#160;*restrict</type><parameter>ps</parameter></csparam>
    </csproto>
    <header>&wchar.h;</header>
    <conceptlist>
     <concept>&mtunsafe; &race;<code linkend="glibc-safety-identifier">:mbrtowc</code><code linkend="glibc-safety-condition">/!ps</code></concept>
     <concept>&asunsafe; &corrupt; &heap; &lock; &dlopen;</concept>
     <concept>&acunsafe; &corrupt; &lock; &mem; &fd;</concept>
    </conceptlist>
    <para>
     <code>mbrtowc</code> işlevi ("multibyte restartable to wide character" kısaltmasıdır), <parameter>s</parameter> ile gösterilen dizgedeki sonraki çok baytlı karakteri geniş karaktere dönüştürür ve <parameter>pwc</parameter> ile gösterilen geniş karakterli dizge içinde saklar. Dönüşüm geçerli <varname>LC_CTYPE</varname> yereline bağlı olarak gerçekleşir. Yerelde kullanılan karakter kümesi, dönüşüm için bir durum bilgisi gerektiriyorsa, bu bilgi  <parameter>ps</parameter> ile gösterilen nesne ile belirtilebilir. <parameter>ps</parameter> boş gösterici ise, işlev tarafından duruk bir dahili durum değişkeni kullanılır.
    </para>
    <para>
     Sonraki çok baytlı karakter boş geniş karakter ise, işlevin dönüş değeri sıfırdır ve durum nesnesi sonrasında ilk durumdadır. Eğer sonraki <parameter>n</parameter> veya daha az bayt doğru çok baytlı karakter biçimindeyse, dönüş değeri, çok baytlı karakter biçimindeki <parameter>s</parameter> göstericisinde başlayan baytların sayısıdır. Dönüşüm durumu dönüşümde tüketilen baytlara göre güncellenir. Her iki durumda da geniş karakter (ya <command>L'\0'</command> ya da dönüşümde bulunan karakter), <parameter>pwc</parameter> boş gösterici değilse, <parameter>pwc</parameter> ile gösterilen dizgede saklanır.
    </para>
    <para>
     Çok baytlı dizgenin ilk <parameter>n</parameter> baytının geçerli birçok baytlı karakter olduğu varsayıldığı halde dönüşüm için <parameter>n</parameter>’den daha fazla bayt gerekiyorsa işlevin dönüş değeri <code>(size_t) -2</code>’dir ve <parameter>pwc</parameter>'de hiçbir değer saklanmaz. Girdi gereğinden fazla öteleme durumu içerebildiğinden <parameter>n</parameter>, <varname>MB_CUR_MAX</varname>'dan büyük ya da ona eşit bir değer içerdiğinde bile bu durumun oluşabileceği unutulmamalıdır.
    </para>
    <para>
     Çok baytlı dizgenin ilk <parameter>n</parameter> baytı geçerli birçok baytlı karakter oluşturamıyorsa, <parameter>pwc</parameter>'de hiçbir değer saklanmaz, <varname>errno</varname> genel değişkenine <varname>EILSEQ</varname> değeri atanır ve işlev <code>(size_t) -1</code> değeri ile döner. Dönüşüm durumu bundan sonra tanımsızdır.
    </para>
    <para>
     Belirtildiği gibi, <code>mbrtowc</code> işlevi gömülü boş baytlar içeren (UTF-16 gibi Unicode kodlamalarındaki gibi) çok baytlı dizilimlerle ilgilenebilir, ancak GNU C Kitaplığı bu tür çok baytlı kodlamaları desteklemez. Boş bir girdi baytı ile karşılaşıldığında, işlev ya sıfır döndürür ya da <code>(size_t) -1)</code> döndürür ve <varname>EILSEQ</varname> hatası bildirir. <function>iconv</function> işlevi, isteğe bağlı kodlamalar arasında dönüştürme yapmak için kullanılabilir. Bkz. <xref linkend="glibc-Generic-Conversion-Interface"/>.
    </para>
    <para>
     <code>mbrtowc</code> işlevi &isoc;90 standardının 1. düzeltmesinde bulunur.
    </para>
   </csynopsis>
   <example>
    <para>
     Çok baytlı bir dizgeyi geniş karakterli dizgeye kopyalarken küçük harfleri büyük harfe çeviren bir işlev şöyle olur (bu tam bir uygulama değildir; sadece örnektir; hata denetimi yapılmaz ve bellek kaçağı olabilir):
    </para>
    <screen>wchar_t *
mbstouwcs (const char *s)
{
  /* <replaceable>Dönüşümde boş sonlandırıcı içerir.</replaceable> */
  size_t len = strlen (s) + 1;
  wchar_t *sonuc = reallocarray (NULL, len, sizeof (wchar_t));
  if (sonuc == NULL)
    return NULL;

  wchar_t *wcp = sonuc;
  mbstate_t state;
  memset (&amp;state, '\0', sizeof (state));

  while (true)
    {
      wchar_t wc;
      size_t nbytes = mbrtowc (&amp;wc, s, len, &amp;state);
      if (nbytes == 0)
        {
          /* <replaceable>Sonuçlanan dizgeyi sonlandır.</replaceable> */
          *wcp = L'\0';
          break;
        }
      else if (nbytes == (size_t) -2)
        {
          /* <replaceable>Girdi dizgesini kırp.</replaceable> */
          errno = EILSEQ;
          free (sonuc);
          return NULL;
        }
      else if (nbytes == (size_t) -1)
        {
          /* <replaceable>Başka bir hata (EILSEQ dahil).</replaceable> */
          free (sonuc);
          return NULL;
        }
      else
        {
          /* <replaceable>Karakter dönüştürüldü.</replaceable> */
          *wcp++ = towupper (wc);
          len -= nbytes;
          s += nbytes;
        }
    }
  return sonuc;
}
</screen>
    <para>
     İç döngüde, <replaceable>wc</replaceable>'de tek bir geniş karakter saklanır ve tüketilen bayt sayısı <replaceable>nbytes</replaceable> değişkeninde saklanır. Dönüştürme başarılı olursa, geniş karakterin büyük harfli karşılığı sonuç dizisinde saklanır ve giriş dizgesinin göstericisi ve kullanılabilir bayt sayısı ayarlanır. <function>mbrtowc</function> işlevi sıfır döndürürse, boş girdi baytı dönüştürülmez, dolayısıyla doğrudan <replaceable>sonuç</replaceable>ta saklanması gerekir.
    </para>
    <para>
     Yukarıdaki kod, çok baytlı girdi dizgesindeki baytların dönüşüm sonrası elde edilen geniş karakterli dizgenin bayt sayısından büyük ya da eşit olduğu varsayımına dayandırılmıştır. Bu yöntem sonucun uzunluğu hakkında iyimserdir ve çok sayıda geniş karakterli dizge ya da çok uzun bir dizge bu yöntemle oluşturulmaya çalışılırsa ek bellek ayrılması gerekebilecektir. Ayrılan bellek bloğu döndürülmeden önce doğru boyuta ayarlanabilir, fakat en doğrusu sonucun gerektirdiği kadar belleği baştan ayırmaktır. Umulanın aksine, elde edilecek geniş karakterli dizgenin boyunu çok baytlı dizgenin boyutlarına bakarak elde edebilecek bir işlev yoktur. Yine de, işlemin bir parçası olabilecek bir işlev vardır.
    </para>
   </example>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-mbrlen"><primary>mbrlen</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-mbrlen"><primary>karakter dönüşümü</primary><secondary>çok baytlı karakter uzunluğu</secondary></indexterm>
    <csproto type="işlev">
     <csname><type>size_t</type><function>mbrlen</function></csname>
     <csparam><type>const&#160;char&#160;*restrict</type><parameter>s</parameter></csparam>
     <csparam><type>size_t</type><parameter>n</parameter></csparam>
     <csparam><ptr>mbstate_t</ptr><parameter>ps</parameter></csparam>
    </csproto>
    <header>&wchar.h;</header>
    <conceptlist>
     <concept>&mtunsafe; &race;<code linkend="glibc-safety-identifier">:mbrlen</code><code linkend="glibc-safety-condition">/!ps</code></concept>
     <concept>&asunsafe; &corrupt; &heap; &lock; &dlopen;</concept>
     <concept>&acunsafe; &corrupt; &lock; &mem; &fd;</concept>
    </conceptlist>
    <para>
     <code>mbrlen</code> işlevi ("multibyte restartable length" kısaltmasıdır), <parameter>s</parameter> ile başlayan en fazla <parameter>n</parameter> baytlık sonraki geçerli ve çok baytlı tam karakterin bayt sayısını hesaplar.
    </para>
    <para>
     Sonraki çok baytlı karakter boş geniş karaktere karşılıksa, dönüş değeri sıfırdır. Sonraki <parameter>n</parameter> bayt, geçerli birçok baytlı karaktere aitse, bu çok baytlı karakteri oluşturan baytların sayısı döner.
    </para>
    <para>
     Eğer ilk <parameter>n</parameter> bayt geçerli birçok baytlı karakter için yetersizse, dönüş değeri <code>(size_t) -2</code>’dir. Aksi halde, çok baytlı karakter dizilimi geçersizdir ve dönüş değeri <code>(size_t) -1</code>’dir.
    </para>
    <para>
     Çok baytlı dizilim <parameter>ps</parameter> ile gösterilen nesne ile belirtilen duruma göre yorumlanır. <parameter>ps</parameter> boş gösterici ise <code>mbrlen</code>'e özgü bir dahili durum nesnesi kullanılır.
    </para>
    <para>
     <code>mbrtowc</code> işlevi &isoc;90 standardının 1. düzeltmesinde bulunur.
    </para>
   </csynopsis>
   <example>
    <para>
     Dikkatli okuyucular <function>mbrlen</function> işlevinin şöyle gerçeklenebileceğini farkedecektir:
    </para>
    <screen>mbrtowc (NULL, s, n, ps != NULL ? ps : &amp;internal)
</screen>
    <para>
     Bu doğrudur ve aslında resmi belirtimde bahsedilendir. Aşağıda, çok baytlı bir karakter dizisinden geniş karakterli karşılığının uzunluğunun nasıl saptanabileceği gösterilmiştir. İşlev doğrudan kullanılabilir değildir, fakat <code>mbslen</code> isimli bir işlevi onu kullanarak tanımlayabiliriz:
    </para>
    <screen>size_t
mbslen (const char *s)
{
  mbstate_t state;
  size_t sonuc = 0;
  size_t nbytes;
  memset (&amp;state, '\0', sizeof (state));
  while ((nbytes = mbrlen (s, MB_LEN_MAX, &amp;state)) &gt; 0)
    {
      if (nbytes &gt;= (size_t) -2)
        /* <replaceable>Birşeyler yanlış.</replaceable>  */
        return (size_t) -1;
      s += nbytes;
      ++sonuc;
    }
  return sonuc;
}
</screen>
    <para>
     Bu işlev, dizgedeki her çok baytlı karakter için basitçe <function>mbrlen</function> çağrısı yapar ve işlev çağrılarını sayar. Burada <varname>MB_LEN_MAX</varname>, <function>mbrlen</function>'in boyut bağımsız değişkeni <parameter>n</parameter> olarak kullandığına dikkat edilmelidir. Bu kabul edilebilir, çünkü;
    </para>
    <orderedlist numeration="loweralpha">
     <listitem>
      <para>
       Bu değer en uzun çok baytlı karakter diziliminden büyüktür.
      </para>
     </listitem>
     <listitem>
      <para>
       <parameter>s</parameter> dizgesinin boş bayt ile bittiğini biliyoruz. Bu sonlandırıcı bayt başka birçok baytlı karakter diziliminin parçası olamaz ama boş geniş karakteri temsil edebilir.
      </para>
     </listitem>
    </orderedlist>
    <para>
     Diğer taraftan, <function>mbrlen</function> işlevi geçersiz belleği asla okumaz.
    </para>
    <para>
     Şimdi bu işlev kullanılabilir (sadece açıklığa kavuşturmak için, bu işlev &glibc;nin bir parçası <emphasis>değildir</emphasis>). Çok baytlı karakterli <parameter>s</parameter> dizgesinden dönüştürülerek elde edilecek geniş karakterli dizgenin saklanacağı alanın genişliği artık hesaplanabilir:
    </para>
    <screen>wcs_bytes = (mbslen (s) + 1) * sizeof (wchar_t);
</screen>
    <para>
     <code>mbslen</code> işlevinin verimsiz olduğu unutulmamalıdır. <function>mbstouwcs</function>'nin <code>mbslen</code> ile gerçeklenmesi çok baytlı karakterli girdi dizgesine iki defa dönüşüm uyguladığından bu dönüşüm masraflıdır. Bu durumda, kullanımı daha kolay ama işlemi iki defa yapmayan bir yöntem düşünmek gerekir.
    </para>
   </example>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-wcrtomb"><primary>wcrtomb</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-wcrtomb"><primary>karakter dönüşümü</primary><secondary>geniş karakterden çok baytlıya</secondary></indexterm>
    <csproto type="işlev">
     <csname><type>size_t</type><function>wcrtomb</function></csname>
     <csparam><type>char&#160;*restrict</type><parameter>s</parameter></csparam>
     <csparam><type>wchar_t</type><parameter>wc</parameter></csparam>
     <csparam><type>mbstate_t&#160;*restrict</type><parameter>ps</parameter></csparam>
    </csproto>
    <header>&wchar.h;</header>
    <conceptlist>
     <concept>&mtunsafe; &race;<code linkend="glibc-safety-identifier">:wcrtomb</code><code linkend="glibc-safety-condition">/!ps</code></concept>
     <concept>&asunsafe; &corrupt; &heap; &lock; &dlopen;</concept>
     <concept>&acunsafe; &corrupt; &lock; &mem; &fd;</concept>
    </conceptlist>
    <para>
     <code>wcrtomb</code> işlevi ("wide character restartable to multibyte" kısaltmasıdır),  tek bir geniş karakteri, karşılığı olan çok baytlı karakter dizgesine dönüştürür.
    </para>
    <para>
     <parameter>s</parameter> boş gösterici ise, <code>wcrtomb</code> <parameter>ps</parameter> ile gösterilen nesnedeki durum bilgisini (ya da işlevin dahili durum bilgisini) başlangıç durumuna sıfırlar. Bu aşağıdaki gibi bir çağrı ile sağlanabilir:
    </para>
     <screen>wcrtombs (temp_buf, L'\0', ps)
</screen>
    <para>
     <parameter>s</parameter> boş gösterici ise, <code>wcrtomb</code> yeterince büyük olduğu garanti edilen bir dahili tampona yazıyormuş gibi çalışır.
    </para>
    <para>
     <parameter>wc</parameter> boş geniş karakter ise, <code>wcrtomb</code> eğer gerekliyse,  <parameter>s</parameter> dizgesinde saklanan, <parameter>ps</parameter> durumunu ilk duruma getirecek öteleme dizilimini ardında bir boş karakter ile çıktılar.
    </para>
    <para>
     Aksi takdirde, bayt dizilimi (öteleme dizilimlerini de içerebilir) <parameter>s</parameter> dizgesine yazılır. Bu sadece <parameter>wc</parameter> geçerli bir geniş karakterse mümkündür (örneğin, <varname>LC_CTYPE</varname> yereline göre seçilen karakter kümesinde çok baytlı gösterimi varsa). <parameter>wc</parameter> geçerli geniş karakter değilse, <parameter>s</parameter> dizgesine hiçbir şey saklanmaz, <varname>errno</varname> değişkenine <varname>EILSEQ</varname> atanır, <parameter>ps</parameter>'deki durum bilgisi tanımsız olur ve <code>(size_t) -1</code> döner.
    </para>
    <para>
     Bir hata oluşmazsa, işlev <parameter>s</parameter> dizgesinde saklanan baytların sayısı ile döner. Bu, öteleme durumlarını gösteren bütün baytları içerir.
    </para>
    <para>
     İşlevin arayüzünden biraz bahsetmek gerekirse: <parameter>s</parameter> dizgesinin uzunluğunu belirten bir bağımsız değişken yoktur. Bunun yerine, işlev en azından <varname>MB_CUR_MAX</varname> baytın varlığını kabul eder. Çünkü tek bir karakterin ifade edilebileceği azami bayt sayısı budur ve &glibc; sürümlerinde çalışması gereken yazılımların bu sınıra uyması gerekir. Bu durumda, çağrıcı yeterli yerin mevcut olduğuna emindir, aksi takdirde tampon taşması oluşabilirdi.
    </para>
    <para>
     <code>mbrtowc</code> işlevi &isoc;90 standardının 1. düzeltmesinde bulunur.
    </para>
   </csynopsis>
   <example>
    <para>
     <function>wcrtomb</function> işlevinin kullanımı <function>mbrtowc</function> işlevinin kullanımına göre daha kolaydır. Bu örnekte, geniş karakterli bir dizge çok baytlı bir dizgeye eklenmektedir. Tekrar belirtelim; kod kullanılabilir (veya doğru) değildir, işlevin kullanımı ve bazı sorunlar örneklenmiştir.
    </para>
    <screen>char *
mbscatwcs (char *s, size_t len, const wchar_t *ws)
{
  mbstate_t state;
  /* <replaceable>Mevcut dizgenin uzunluğunu bul.</replaceable>  */
  char *wp = strchr (s, '\0');
  len -= wp - s;
  memset (&amp;state, '\0', sizeof (state));
  do
    {
      size_t nbytes;
      if (len &lt; MB_CUR_LEN)
        {
          /* <replaceable>Sonraki karakterin tampona sığacağı garanti
             değildir. Bu durumda bir hata dönebilir.</replaceable>  */
            errno = <varname>E2BIG</varname>;
          return NULL;
        }
      nbytes = wcrtomb (wp, *ws, &amp;state);
      if (nbytes == (size_t) -1)
        /* <replaceable>Dönüşümde hata.</replaceable>  */
        return NULL;
      len -= nbytes;
      wp += nbytes;
    }
  while (*ws++ != L'\0');
  return s;
}
</screen>
    <para>
     İlk işlevde <parameter>s</parameter> dizisi içindeki dizgenin sonu bulunmalıdır. <function>strchr</function> işlevi bunu çok iyi yapar, çünkü çok baytlı karakter gösterimlerinde bir gereklilik olarak boş bayt kendisini temsil etmesi (bu bağlamda dizgenin sonudur) dışında bir amaçla asla kullanılmaz.
    </para>
    <para>
     Durum nesnesini ilklendirip döngüye girilince ilk iş olarak <parameter>s</parameter> dizisinde yeterince yer olup olmadığına bakılmaktadır. <varname>MB_CUR_LEN</varname> bayttan daha az yer varsa, en iyi seçim olmasa da işlevden çıkılmaktadır. <varname>MB_CUR_LEN</varname> bayttan daha az yer olabilir ve sonraki çok baytlı karakter sadece bir bayt uzunlukta olabilirdi. Bu durumda tamponda yeterince yerin varlığına karar verecek ek kod nedeniyle işlev çok geç dönerdi. Bu çözüm pek kullanışlı değildir, daha doğru ama çok yavaş bir çözümdür.
    </para>
    <screen>  …
  if (len &lt; MB_CUR_LEN)
    {
      mbstate_t temp_state;
      memcpy (&amp;temp_state, &amp;state, sizeof (state));
      if (wcrtomb (NULL, *ws, &amp;temp_state) &gt; len)
        {
          /* <replaceable>Sonraki karakterin tampona sığacağı garanti
             değildir. Bu durumda bir hata dönebilir.</replaceable>  */
          errno = <varname>E2BIG</varname>;
          return NULL;
        }
    }
  …
</screen>
    <para>
     Burada tamponun taşabileceği bir dönüşüm uygulanmaktadır, yani tamponun boyutu hakkındaki karar işlemden sonra verilmektedir. <function>wcrtomb</function> çağrısındaki hedef tampon için <varname>NULL</varname> bağımsız değişkenine dikkat edilmelidir; bu noktada dönüştürülen metinle ilgilenilmediğinden, bu sorunu aşmak için iyi bir yöntemdir. Bu kod parçasındaki en lüzumsuz şey dönüşüm durum nesnesinin yinelenmesidir; ancak eğer sonraki çok baytlı karakteri yok sayacak bir değişiklik gerekliyse gerçek dönüşümde aynı öteleme durum değişikliğinin uygulanması, bunun yanında, ilk öteleme durum bilgisinin de korunması gerekir.
    </para>
    <para>
     Bu soruna çok sayıda ve çok daha iyi çözümler vardır. Bu örnek sadece öğrenim amacıyla hazırlanmıştır.
    </para>
   </example>
  </sect1>
  <sect1 xml:id="glibc-Converting-Strings">
   <title>Dizge Dönüşümleri</title>
   <titleabbrev>Çok baytlı karakterlerle geniş karakterler arasındaki dönüşümler.</titleabbrev>
   <para>
    Önceki bölümde bahsedilen işlevler bir defada sadece tek bir karakteri dönüştürmek içindi. Gerçekte uygulanan çoğu işlem dizgeler üzerinde yapılır ve &isoc; standardı dizgelerin tamamının dönüşümlerini de tanımlar. Bununla birlikte, tanımlı işlevlerin bazı sınırlamaları vardır; ancak, &glibc; bazı önemli durumlarda yardımcı olabilecek bazı genişletmeler içerir.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-mbsrtowcs"><primary>mbsrtowcs</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-mbsrtowcs"><primary>dizgelerde karakter dönüşümü</primary><secondary>çok baytlıdan genişe</secondary></indexterm>
    <csproto type="işlev">
     <csname><type>size_t</type><function>mbsrtowcs</function></csname>
     <csparam><type>wchar_t&#160;*restrict</type><parameter>dst</parameter></csparam>
     <csparam><type>const&#160;char&#160;**restrict</type><parameter>src</parameter></csparam>
     <csparam><type>size_t</type><parameter>len</parameter></csparam>
     <csparam><type>mbstate_t&#160;*restrict</type><parameter>ps</parameter></csparam>
    </csproto>
    <header>&wchar.h;</header>
    <conceptlist>
     <concept>&mtunsafe; &race;<code linkend="glibc-safety-identifier">:mbsrtowcs</code><code linkend="glibc-safety-condition">/!ps</code></concept>
     <concept>&asunsafe; &corrupt; &heap; &lock; &dlopen;</concept>
     <concept>&acunsafe; &corrupt; &lock; &mem; &fd;</concept>
    </conceptlist>
    <para>
     <code>mbsrtowcs</code> işlevi ("multibyte string restartable to wide character string" kısaltmasıdır) *<parameter>src</parameter> içindeki boş karakter sonlandırmalı çok baytlı karakter dizgesini eşdeğer geniş karakter dizgesine dönüştürür. Dönüşüm, <parameter>ps</parameter> ile gösterilen nesnedeki ya da <parameter>ps</parameter> boş gösterici ise <code>mbsrtowcs</code> içindeki dahili durum bilgisi kullanılarak başlatılır. İşlev dönmeden önce, durum nesnesi son karakter dönüştürüldükten sonraki durumla güncellenir. Dönüşüm sonlandırıcı boş karaktere de uygulandığında durum, ilk durum olur.
    </para>
    <para>
     <parameter>dst</parameter> boş gösterici değilse, sonuç <parameter>dst</parameter> ile gösterilen dizide saklanır; aksi takdirde, dönüşüm sonucu dahili tamponda saklanmış olacağından sonuç kullanılabilir olmayacaktır.
    </para>
    <para>
     <parameter>dst</parameter> dizgesinde dizge sonuna ulaşmayan <parameter>len</parameter> geniş karakter varsa, girdi dizgesinin dönüştürülen kısmı <parameter>len</parameter> geniş karakterlik olduğunda dönüşüm durdurulur ve <parameter>len</parameter> döner. <parameter>dst</parameter> bir boş dizge ise <parameter>len</parameter> anlamlı değildir.
    </para>
    <para>
     Eksik dönüşümlü bir dönüşün sebeplerinden biri de girdi dizgesinin geçersiz çok baytlı dizilim içermesidir. Bu durumda <varname>errno</varname> değişkenine <varname>EILSEQ</varname> atanarak işlev, <code>(size_t) -1</code> ile döner.
    </para>
    <para>
     Tüm diğer durumlarda işlev, bu çağrı ile dönüştürülmüş geniş karakterlerin sayısı ile döner. <parameter>dst</parameter> boş değilse, <code>mbsrtowcs</code> işlevi <parameter>src</parameter> ile ya boş gösterici (girdi dizgesinde boş karaktere erişilmişse) ya da son dönüştürülen çok baytlı karakterden sonraki baytın adresini döndürür.
    </para>
    <para>
     <function>mbstowcs</function> işlevindeki gibi, <parameter>dst</parameter> boş gösterici olabilir ve işlev gereken geniş karakter sayısını bulmakta kullanılabilir.
    </para>
    <para>
     <code>mbstowcs</code> işlevi &isoc;90 standardının 1. düzeltmesinde bulunur.
    </para>
   </csynopsis>
   <para>
    <function>mbsrtowcs</function> işlevinin tanımı önemli bir sınırlama içerir. <parameter>dst</parameter>'nin boş karakter sonlandırmalı dizge içermesi gereksinimi dönüşümün metin içeren tamponlarda yapılması durumunda sorunlara sebep olur. Bir tampon normalde, boş karakter sonlandırmalı dizgeler değil, her biri satır sonu karakteri ile biten satırlar içerir. Şimdi bir işlevden tampon içindeki satırlardan birini dönüştürmesi istenmiş olsun. Satır boş karakterle bitmediğinden kaynak gösterici değiştirilmemiş metin tamponunu doğrudan gösteremez. Bunun anlamı: Ya <function>mbsrtowcs</function> çağrısı sırasında uygun bir yere boş karakter yerleştirilmeli (bu, salt okunur tamponlarda ve çok evreli uygulamalarda yapılamaz) ya da satır, boş karakterle sonlandırılmış olarak başka bir tampona kopyalanmalıdır. <parameter>len</parameter> bağımsız değişkenine belli bir değer atayarak dönüştürülecek karakterlerin sayısını sınırlamak genellikle mümkün değildir. Her çok baytlı karakterin kaç bayttan oluştuğu bilinemediğinden sadece tahmin yapılabilir.
   </para>
   <para>
    <indexterm linkend="glibc-cp"><primary>durumsal</primary></indexterm>
    Satır sonu karakterinden sonra boş bayt koyarak satırın sonlandırılması ile ilgili olarak çok tuhaf sonuçlara sebep olan bir sorun hala mevcuttur. Yukarıda  <function>mbsrtowcs</function> işlevinin açıklamasında bahsedildiği gibi girdi dizgesinin sonundaki boş bayt işlendikten sonra durumun ilk öteleme durumu olacağı garanti edilmiştir. Fakat bu boş bayt gerçekte metnin bir parçası değildir (yani, özgün metinde satır sonu karakterinden sonraki dönüşüm durumu ilk öteleme durumundan farklı olacaktı ve sonraki satırın ilk karakteri bu durum kullanılarak kodlanacaktı). Diğer taraftan, dönüşüm boş baytta duracağından (öteleme durumu sıfırlanacağından) gerçekte olması gereken durum bilgisi kaybolacaktır. Günümüzdeki çoğu karakter kümesi bir satır sonu karakterinden sonraki öteleme durumunun ilk durum olmasını gerektirse de bu kesin bir garanti değildir. Basitçe, metnin üzerinde çalışılan parçasının boş karakterle sonlandırılması her zaman uygun çözüm değildir ve genellikle hiç kullanılmaz.
   </para>
   <para>
    Karakter kümesi dönüşüm arayüzü (<xref linkend="glibc-Generic-Charset-Conversion"/>) bu sınırlamaya sahip değildir (basitçe tamponlarla çalışır, dizgelerle değil) ve &glibc; girdi dizgesinde işlenecek baytların azami sayısının belirtilebildiği ek bağımsız değişkenler alan işlevler içerir. Bu yolla, <function>mbsrtowcs</function> işlevinin yukarıdaki örneğindeki sorun, satır uzunluğu saptanıp bu uzunluk işleve aktarılarak çözülebilir.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-wcsrtombs"><primary>wcsrtombs</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-wcsrtombs"><primary>dizgelerde karakter dönüşümü</primary><secondary>genişten çok baytlıya</secondary></indexterm>
    <csproto type="işlev">
     <csname><type>size_t</type><function>wcsrtombs</function></csname>
     <csparam><type>char&#160;*restrict</type><parameter>dst</parameter></csparam>
     <csparam><type>const&#160;wchar_t&#160;**restrict</type><parameter>src</parameter></csparam>
     <csparam><type>size_t</type><parameter>len</parameter></csparam>
     <csparam><type>mbstate_t&#160;*restrict</type><parameter>ps</parameter></csparam>
    </csproto>
    <header>&wchar.h;</header>
    <conceptlist>
     <concept>&mtunsafe; &race;<code linkend="glibc-safety-identifier">:wcsrtombs</code><code linkend="glibc-safety-condition">/!ps</code></concept>
     <concept>&asunsafe; &corrupt; &heap; &lock; &dlopen;</concept>
     <concept>&acunsafe; &corrupt; &lock; &mem; &fd;</concept>
    </conceptlist>
    <para>
     <code>wcsrtombs</code> işlevi ("wide character string restartable to multibyte string" kısaltmasıdır), boş geniş karakter sonlandırmalı *<parameter>src</parameter> geniş karakter dizgesini eşdeğeri olan çok baytlı karakter dizgesine dönüştürür ve sonucu <parameter>dst</parameter> ile gösterilen dizide saklar. Boş geniş karakter ayrıca dönüştürülür. Dönüşüm, <parameter>ps</parameter> ile gösterilen nesnedeki  ya da <parameter>ps</parameter> boş gösterici ise <code>wcsrtombs</code> içindeki dahili durum bilgisi kullanılarak başlatılır. <parameter>dst</parameter> boş gösterici olduğunda dönüşüm yine yapılır ama sonuç döndürülmez. Girdi dizgesindeki tüm karakterler dönüştürülmüşse ve <parameter>dst</parameter> boş gösterici değilse <parameter>src</parameter> ile gösterilen göstericiye boş gösterici atanır.
    </para>
    <para>
     Geniş karakterlerden birinin geçerli çok baytlı karakter eşdeğeri yoksa dönüşüm durdurulur ve <varname>errno</varname> genel değişkenine <varname>EILSEQ</varname> değeri atanarak işlev <code>(size_t) -1</code> ile döner.
    </para>
    <para>
     İşlemin eksik kalmasına başka bir sebep de <parameter>dst</parameter>'nin boş karakter olmadığı durumda dönüştürülecek karakterin dizideki <parameter>len</parameter> bayttan fazlasını gerektirmesidir. Bu durumda <parameter>src</parameter> ile gösterilen göstericiye başarıyla dönüştürülmüş son karakterden sonraki karakteri gösteren gösterici atanır.
    </para>
    <para>
     Bir kodlama hatası haricinde, <command>wcsrtombs</command> işlevinin dönüş değeri <parameter>dst</parameter> içinde saklanan çok baytlı karakterlerin toplam bayt sayısıdır. İşlev dönmeden önce, durum nesnesi son karakter dönüştürüldükten sonraki durumla güncellenir. Sonlandırıcı boş geniş karakter işlenmişse durum, ilk durum olur.
    </para>
    <para>
     <code>wcsrtombs</code> işlevi &isoc;90 standardının 1. düzeltmesinde bulunur.
    </para>
   </csynopsis>
   <para>
    Yukarıda <function>mbsrtowcs</function> işlevi ile ilgili sınırlama bu işlevde de geçerlidir. Girdi karakterlerinin sayısını doğrudan belirlemek mümkün değildir. Ya doğru yere boş geniş karakter yerleştirilmeli ya da işlenen girdi uzunluğu dolaylı olarak çıktı dizgesinin uzunluğu (<parameter>len</parameter> bağımsız değişkeni) sınanarak saptanmalıdır.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-mbsnrtowcs"><primary>mbsnrtowcs</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-mbsnrtowcs"><primary>dizgelerde karakter dönüşümü</primary><secondary>çok baytlıdan genişe</secondary></indexterm>
    <csproto type="işlev">
     <csname><type>size_t</type><function>mbsnrtowcs</function></csname>
     <csparam><type>wchar_t&#160;*restrict</type><parameter>dst</parameter></csparam>
     <csparam><type>const&#160;char&#160;**restrict</type><parameter>src</parameter></csparam>
     <csparam><type>size_t</type><parameter>nmc</parameter></csparam>
     <csparam><type>size_t</type><parameter>len</parameter></csparam>
     <csparam><type>mbstate_t&#160;*restrict</type><parameter>ps</parameter></csparam>
    </csproto>
    <header>&wchar.h;</header>
    <conceptlist>
     <concept>&mtunsafe; &race;<code linkend="glibc-safety-identifier">:mbsnrtowcs</code><code linkend="glibc-safety-condition">/!ps</code></concept>
     <concept>&asunsafe; &corrupt; &heap; &lock; &dlopen;</concept>
     <concept>&acunsafe; &corrupt; &lock; &mem; &fd;</concept>
    </conceptlist>
    <para>
     <code>mbsnrtowcs</code> işlevi, <function>mbsrtowcs</function> işlevine çok benzer. <parameter>nmc</parameter> bağımsız değişkeni dışında tüm bağımsız değişkenler ve işlevin dönüş durumu aynıdır.
    </para>
    <para>
     <parameter>nmc</parameter> bağımsız değişkeni ile çok baytlı karakter dizgesinin en çok kaç baytının kullanılacağı belirtilir. Başka bir deyişle, *<parameter>src</parameter> çok baytlı karakter dizisinin boş bayt sonlandırmalı olması gerekli değildir. Fakat dizge içinde ilk <parameter>nmc</parameter> karakter içinde boş bayta rastlanırsa dönüşüm orada durur.
    </para>
    <para>
     Bu işlev GNU oluşumudur. Amacı yukarıda belirtilen sorunun etrafından dolanmaktır. Böylece çok baytlı karakterler içeren bir tamponun dönüştürülmesi boş karakter yerleştirmeden ve boş karakter dönüşüm durum nesnesini etkilemeksizin mümkün olur.
    </para>
   </csynopsis>
   <example>
    <para>
     Çok baytlı karakter dizgesini geniş karakter dizgesine dönüştürecek ve gösterecek işlev şöyle yazılabilir (örnek kullanılabilir değildir):
    </para>
    <screen>void
showmbs (const char *src, FILE *fp)
{
  mbstate_t state;
  int cnt = 0;
  memset (&amp;state, '\0', sizeof (state));
  while (1)
    {
      wchar_t linebuf[100];
      const char *endp = strchr (src, '\n');
      size_t n;

      /* <replaceable>Satır kalmadıysa çık.</replaceable>  */
      if (endp == NULL)
        break;

      n = mbsnrtowcs (linebuf, &amp;src, endp - src, 99, &amp;state);
      linebuf[n] = L'\0';
      fprintf (fp, "line %d: \"%S\"\n", linebuf);
    }
}
</screen>
    <para>
     <function>mbsnrtowcs</function> çağrısından sonra durumla ilgili bir sorun çıkmaz. Dizgelere dışarıdan bir karakter yerleştirilmediğinden <replaceable>state</replaceable> durumunu sadece verilen tamponu dönüştürmek için kullanıldı. Durumun değişmesiyle ilgili bir sorun çıkmadı.
    </para>
   </example>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-wcsnrtombs"><primary>wcsnrtombs</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-wcsnrtombs"><primary>dizgelerde karakter dönüşümü</primary><secondary>genişten çok baytlıya</secondary></indexterm>
    <csproto type="işlev">
     <csname><type>size_t</type><function>wcsnrtombs</function></csname>
     <csparam><type>char&#160;*restrict</type><parameter>dst</parameter></csparam>
     <csparam><type>const&#160;wchar_t&#160;**restrict</type><parameter>src</parameter></csparam>
     <csparam><type>size_t</type><parameter>nwc</parameter></csparam>
     <csparam><type>size_t</type><parameter>len</parameter></csparam>
     <csparam><type>mbstate_t&#160;*restrict</type><parameter>ps</parameter></csparam>
    </csproto>
    <header>&wchar.h;</header>
    <conceptlist>
     <concept>&mtunsafe; &race;<code linkend="glibc-safety-identifier">:wcsnrtombs</code><code linkend="glibc-safety-condition">/!ps</code></concept>
     <concept>&asunsafe; &corrupt; &heap; &lock; &dlopen;</concept>
     <concept>&acunsafe; &corrupt; &lock; &mem; &fd;</concept>
    </conceptlist>
    <para>
     <code>wcsnrtombs</code> işlevi geniş karakter dizgesini çok baytlı karakter dizgesine dönüştürmekte kullanılır. <function>wcsrtombs</function> işlevine benzemekle birlikte <function>mbsnrtowcs</function> işlevi gibi girdi dizgesinin uzunluğunun belirtilebildiği ek bir bağımsız değişken alır.
    </para>
    <para>
     *<parameter>src</parameter> dizgesinin sadece ilk <parameter>nwc</parameter> geniş karakteri dönüştürülür. Bu parça içinde boş geniş karaktere rastlanırsa dönüşüm bu karakterde durdurulur.
    </para>
    <para>
     <code>wcsnrtombs</code> işlevi GNU oluşumudur ve <function>mbsnrtowcs</function> işlevi gibi boş sonlandırıcı içermeyen dizgelerin dönüştürülmesinde yararlı olur.
    </para>
   </csynopsis>
  </sect1>
  <sect1 xml:id="glibc-Multibyte-Conversion-Example">
   <title>Çok Baytlı Dönüşüm Örneği</title>
   <titleabbrev>Eksiksiz birçok baytlı dönüşüm örneği</titleabbrev>
   <para>
    Bundan önceki bölümlerde verilen örnekler birer özetti ve hata denetimlerini içermiyordu. Burada tam ve belgelemesi yapılmış bir örneğe yer verilmiştir. <function>mbrtowc</function> işlevi kullanılmışsa da diğer işlevlerin yardımıyla kolayca gerçeklenebilirdi.
   </para>
   <example>
    <screen>int
file_mbsrtowcs (int input, int output)
{
  /* <code>MB_LEN_MAX</code> <replaceable>kullanımına dikkat.</replaceable>
     <code>MB_CUR_MAX</code> <replaceable> burada taşınabilir değildir.</replaceable>  */
  char tampon[BUFSIZ + MB_LEN_MAX];
  mbstate_t durum;
  int filled = 0;
  int eof = 0;

  /* <replaceable>Dönüşüm durumunu ilklendir.</replaceable>  */
  memset (&amp;durum, '\0', sizeof (durum));

  while (!eof)
    {
      ssize_t nread;
      ssize_t nwrite;
      char *inp = tampon;
      wchar_t outbuf[BUFSIZ];
      wchar_t *outp = outbuf;

      /* <replaceable>Tamponu girdi dosyasından doldur.</replaceable>  */
      nread = read (input, tampon + filled, BUFSIZ);
      if (nread &lt; 0)
        {
          perror ("read");
          return 0;
        }
      /* <replaceable>Dosya sonuna gelindiğini belirt.</replaceable> */
      if (nread == 0)
        eof = 1;

      /* <code>dolan</code>  <code>tampon</code><replaceable>a aktarılan bayt sayısıdır.</replaceable> */
      dolan += nread;

      /* <replaceable>Bu baytları mümkün olduğunda geniş karakterlere dönüştür.</replaceable> */
      while (1)
        {
          size_t thislen = mbrtowc (outp, inp, dolan, &amp;durum);
          /* <replaceable>Geçersiz karakterde dönüşümü durdur.</replaceable>
             <replaceable>Böylece geçerli son karaktere kadar olan
             parça okunmuş olacak.</replaceable>  */
          if (thislen == (size_t) -1)
            break;
          /* <replaceable>Dizge içindeki boş karakterler için 0 döner.
             Bunu düzelt.</replaceable>  */
          if (thislen == 0)
            thislen = 1;
          /* <replaceable>Bu karakter işlendi, diğerine geç.</replaceable> */
          inp += thislen;
          dolan -= thislen;
          ++outp;
        }

      /* <replaceable>Dönüştürülen geniş karakterleri yaz.</replaceable>  */
      nwrite = write (output, outbuf,
                      (outp - outbuf) * sizeof (wchar_t));
      if (nwrite &lt; 0)
        {
          perror ("write");
          return 0;
        }

      /* <replaceable>Gerçekten geçersiz karakter var mı, bak.</replaceable> */
      if ((eof &amp;&amp; dolan &gt; 0) || dolan &gt;= MB_CUR_MAX)
        {
          error (0, 0, "cok baytli karakter gecersiz");
          return 0;
        }

      /* <replaceable>Kalan karakterleri tamponun başına yerleştir.</replaceable> */
      if (dolan &gt; 0)
        memmove (tampon, inp, dolan);
    }

  return 1;
}
</screen>
   </example>
  </sect1>
 </chapter>

 <chapter xml:id="glibc-Non-reentrant-Conversion">
  <title>Evresel Olmayan Dönüşümler</title>
  <titleabbrev>Evresel olmayan dönüşüm işlevi</titleabbrev>
  <preliminary>
   <para>
    Önceki kısımda bahsedilen dönüşüm işlevleri &isoc;90'ın 1. düzeltmesinde tanımlanmış işlevlerdi. Fakat &isoc;90 standardı da karakter kümesi dönüşümlerini yapmak için işlevler içermektedir. Önce bu işlevleri açıklamadık, çünkü bu ilk işlevler hemen hemen tamamen kullanışsızdır.
   </para>
   <para>
    &isoc;90'da tanımlanan dönüşüm işlevlerinin tümü sadece işlev içindeki durumu kullanır. Bu dahili durum kullanılarak çoklu dönüşümler aynı anda (sadece evreler kullanıldığında değil) yapılamaz ve dönüşüm işlevlerine hangi durumu kullanacakları belirtilemediğinden tek tek karakter dönüşümleri ve dolayısıyla dizge dönüşümleri yapılamaz.
   </para>
   <para>
    Bu ilk işlevler sadece çok sınırlı durumlarda kullanılabilir. Yeni bir dizgenin dönüştürülmesine başlamadan önce mevcut dizge tamamen dönüştürülmüş olmalı ve her dizge aynı işlevle dönüştürülmelidir (bu noktada kütüphanenin kendisi ile ilgili bir sorun yoktur; bir işlevin kullandığı durumun başka bir işlev tarafından değiştirilmeyeceği garanti edilmiştir). <command>Bu sebeplerle, evresel olmayan dönüşüm işlevleri yerine önceki kısımda bahsedilen işlevlerin kullanılması tercih edilmelidir.</command>
   </para>
  </preliminary>
  <sect1 xml:id="glibc-Non-reentrant-Character-Conversion">
   <title>Evresel Olmayan Karakter Dönüşümleri</title>
   <titleabbrev>Tek bir karakterin evresel olmayan dönüşümü</titleabbrev>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-mbtowc"><primary>mbtowc</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>mbtowc</function></csname>
     <csparam><type>wchar_t&#160;*restrict</type><parameter>result</parameter></csparam>
     <csparam><type>const&#160;char&#160;**restrict</type><parameter>string</parameter></csparam>
     <csparam><type>size_t</type><parameter>size</parameter></csparam>
    </csproto>
    <header>&stdlib.h;</header>
    <conceptlist>
     <concept>&mtunsafe; &race;</concept>
     <concept>&asunsafe; &corrupt; &heap; &lock; &dlopen;</concept>
     <concept>&acunsafe; &corrupt; &lock; &mem; &fd;</concept>
    </conceptlist>
    <para>
     <code>mbtowc</code> işlevi ("multibyte to wide character" kısaltmasıdır), boş gösterici olmayan <parameter>string</parameter> ile çağrıldığında <parameter>string</parameter> dizgesinin ilk çok baytlı karakterinin karşılığı olan geniş karakter *<parameter>result</parameter>'ta saklanır.
    </para>
    <para>
     <code>mbtowc</code> işlevi <parameter>size</parameter> bayttan fazlasına bakmaz. (Eldeki verinin bayt sayısının <parameter>size</parameter> olarak sağlandığı varsayılıyor.)
    </para>
    <para>
     <code>mbtowc</code> işlevi boş gösterici olmayan <parameter>string</parameter> için üç olasılığı ayrımsar:
    </para>
    <simplelist>
     <member><parameter>string</parameter>'in ilk <parameter>size</parameter> baytı geçerli çok baytlı karakterlerle başlar,</member>
     <member><parameter>string</parameter> geçersiz bir bayt dizilimi ile ya da bir karakterin parçası olarak başlar,</member>
     <member><parameter>string</parameter> bir boş dizgeyi (boş bayt) gösterir.</member>
    </simplelist>
    <para>
     Geçerli birçok baytlı karakteri <code>mbtowc</code> bir geniş karaktere dönüştürüp *<parameter>result</parameter>'ta saklar ve bu karakterin bayt sayısı ile döner (daima en az 1 dir ve asla <parameter>size</parameter> bayttan büyük değildir).
    </para>
    <para>
     Geçersiz bir bayt diziliminde <code>-1</code> ile döner.  Boş dizge için *<parameter>result</parameter>'a <code>'\0'</code> atayıp <code>0</code> ile döner.
    </para>
    <para>
     Çok baytlı karakter kodu ötelenmiş karakterleri kullanıyorsa, <code>mbtowc</code> bunu düzeltir ve öteleme durumunu günceller. <code>mbtowc</code> boş gösterici içeren <parameter>string</parameter> ile çağrılırsa öteleme durumunu kendi standart ilk durumuyla ilklendirir. Ayrıca kullanılan çok baytlı karakter kodu için bir öteleme durumu varsa sıfırdan farklı bir değerle döner. Bkz. <xref linkend="glibc-Shift-State"/>.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-wctomb"><primary>wctomb</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>wctomb</function></csname>
     <csparam><ptr>char</ptr><parameter>string</parameter></csparam>
     <csparam><type>wchar_t</type><parameter>wchar</parameter></csparam>
    </csproto>
    <header>&stdlib.h;</header>
    <conceptlist>
     <concept>&mtunsafe; &race;</concept>
     <concept>&asunsafe; &corrupt; &heap; &lock; &dlopen;</concept>
     <concept>&acunsafe; &corrupt; &lock; &mem; &fd;</concept>
    </conceptlist>
    <para>
     <code>wctomb</code> işlevi ("wide character to multibyte" kısaltmasıdır),  <parameter>wchar</parameter> geniş karakter kodunu karşılığı olan çok baytlı karaktere dönüştürür ve sonucu bayt cinsinden <parameter>string</parameter> içinde saklar. <parameter>string</parameter> en az <varname>MB_CUR_MAX</varname> bayt saklayabilmelidir.
    </para>
    <para>
     <code>wctomb</code> işlevi boş olmayan <parameter>string</parameter> ile çağrılırsa <parameter>wchar</parameter> için üç olasılığı ayrımsar:  Geçerli bir geniş karakter kodu, geçersiz bir kod ve <code>L'\0'</code>.
    </para>
    <para>
     Geçerli bir kod verilmişse, <code>wctomb</code> bunu çok baytlı karaktere dönüştürüp sonucu <parameter>string</parameter> içinde saklar ve karakterdeki bayt sayısı ile döner (daima en az <code>1</code>'dir ve <varname>MB_CUR_MAX</varname>'dan büyük değildir).
    </para>
    <para>
     <parameter>wchar</parameter> geçersiz bir geniş karakter kodu ise <code>wctomb</code> <code>-1</code> ile döner. <code>L'\0'</code> ise *<parameter>string</parameter>'e <code>'\0'</code> atayıp <code>0</code> ile döner.
    </para>
    <para>
     Çok baytlı karakter kodu ötelenmiş karakterler içeriyorsa <code>wctomb</code> bunu düzeltip öteleme durumunu günceller. İşlev boş gösterici içeren <parameter>string</parameter> ile çağrılırsa öteleme durumunu kendi standart ilk durumuyla ilklendirir. Ayrıca çok baytlı karakter kodu için bir öteleme durumu varsa sıfırdan farklı bir değerle döner. Bkz. <xref linkend="glibc-Shift-State"/>
    </para>
    <para>
     Bu işlev <parameter>string</parameter> boş dizge değilken <parameter>wchar</parameter> bağımsız değişkenine sıfır aktarılarak çağrılmasının şöyle bir yan etkisi vardır: İşlev, saklanmış öteleme durumu yeniden ilklendirip <code>'\0'</code> çok baytlı karakterini saklayıp <code>0</code> ile döner.
    </para>
   </csynopsis>
   <para>
    <function>mbrlen</function> işlevinin benzeri olarak birçok baytlı karakterin uzunluğunu hesaplayan evresel olmayan bir işlev de vardır. Bu işlev <function>mbtowc</function> kurallarıyla tanımlanabilir.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-mblen"><primary>mblen</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>mblen</function></csname>
     <csparam><ptr>const&#160;char</ptr><parameter>string</parameter></csparam>
     <csparam><type>size_t</type><parameter>size</parameter></csparam>
    </csproto>
    <header>&stdlib.h;</header>
    <conceptlist>
     <concept>&mtunsafe; &race;</concept>
     <concept>&asunsafe; &corrupt; &heap; &lock; &dlopen;</concept>
     <concept>&acunsafe; &corrupt; &lock; &mem; &fd;</concept>
    </conceptlist>
    <para>
     <code>mblen</code> işlevi boş olmayan <parameter>string</parameter> bağımsız değişkeni ile çağrıldığında <parameter>string</parameter>'in başındaki çok baytlı karakterin <parameter>size</parameter> baytına bakar ve ilk çok baytlı karakterin bayt sayısı ile döner. (Eldeki verinin bayt sayısının <parameter>size</parameter> olarak sağlandığı varsayılıyor.)
    </para>
    <para>
     <code>mblen</code>'in dönüş değeri üç olasılığa bağlıdır:
    </para>
    <simplelist>
     <member><parameter>string</parameter>'in ilk <parameter>size</parameter> baytı geçerli çok baytlı karakterlerle başlar,</member>
     <member><parameter>string</parameter> geçersiz bir bayt dizilimi ile ya da bir karakterin parçası olarak başlar,</member>
     <member><parameter>string</parameter> bir boş dizgeyi (boş bayt) gösterir.</member>
    </simplelist>
    <para>
     Geçerli çok baytlı bir karakter için <code>mblen</code> karakterdeki bayt sayısı ile döner (en az <code>1</code>, en çok <parameter>size</parameter> bayt). Geçersiz bayt dizilimi için <code>-1</code> ile döner. Bir boş dizge için ise <code>0</code> ile döner.
    </para>
    <para>
     Çok baytlı karakter kodu ötelenmiş karakterleri kullanıyorsa, <code>mblen</code> bunu düzeltir ve öteleme durumunu günceller. <code>mblen</code> boş gösterici içeren <parameter>string</parameter> ile çağrılırsa öteleme durumunu kendi standart ilk durumuyla ilklendirir. Ayrıca kullanılan çok baytlı karakter kodu için bir öteleme durumu varsa sıfırdan farklı bir değerle döner. Bkz. <xref linkend="glibc-Shift-State"/>.
    </para>
   </csynopsis>
  </sect1>
  <sect1 xml:id="glibc-Non-reentrant-String-Conversion">
   <title>Evresel Olmayan Dizge Dönüşümleri</title>
   <titleabbrev>Dizgelerin evresel olmayan dönüşümleri</titleabbrev>
   <para>
    &isoc;90 standardında tek karakterlerden başka dizgeleri dönüştürecek işlevler de tanımlanmıştır. Bu işlevler &isoc;90 standardınının 1. düzeltmesinde tanımlanmış olan benzerleriyle aynı sorunlardan muzdariptir; bkz. <xref linkend="glibc-Converting-Strings"/>.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-mbstowcs"><primary>mbstowcs</primary></indexterm>
    <csproto type="işlev">
     <csname><type>size_t</type><function>mbstowcs</function></csname>
     <csparam><ptr>wchar_t</ptr><parameter>wstring</parameter></csparam>
     <csparam><ptr>const&#160;char</ptr><parameter>string</parameter></csparam>
     <csparam><type>size_t</type><parameter>size</parameter></csparam>
    </csproto>
    <header>&stdlib.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&asunsafe; &corrupt; &heap; &lock; &dlopen;</concept>
     <concept>&acunsafe; &corrupt; &lock; &mem; &fd;</concept>
    </conceptlist>
    <para>
     <code>mbstowcs</code> işlevi ("multibyte string to wide character string" kısaltmasıdır), <parameter>string</parameter> boş bayt sonlandırmalı çok baytlı karakter dizgesini geniş karakter kodlu bir diziye dönüştürür ve sonucun ilk <parameter>size</parameter> geniş karakterini <parameter>wstring</parameter> içinde saklar. Sonlandıran boş karakter boyuta dahildir. Bu durumda <parameter>string</parameter>'den elde edilen geniş karakterlerin sayısı <parameter>size</parameter> bayttan fazla ise sonuç sonlandırıcı boş geniş karakteri içermeyecektir.
    </para>
    <para>
     <parameter>string</parameter>'deki karakterlerin dönüşümü ilk öteleme durumuyla başlar.
    </para>
    <para>
     Çok baytlı karakter dizgesi geçersizse, <code>mbstowcs</code> işlevi <code>-1</code> değeri ile döner. Aksi takdirde <parameter>wstring</parameter> dizisi içinde saklanan geniş karakterlerin sayısı ile döner. Bu değer <parameter>size</parameter> bayttan küçükse sonlandırıcı boş karakter dahil değildir.
    </para>
    <para>
     Aşağıdaki örnekte çok baytlı karakter dizisi dönüşümü ve elde edilen sonuç için nasıl yer ayrılacağı gösterilmiştir.
    </para>
    <example>
     <screen>wchar_t *
mbstowcs_alloc (const char *string)
{
  size_t size = strlen (string) + 1;
  wchar_t *buf = xmalloc (size * sizeof (wchar_t));

  size = mbstowcs (buf, string, size);
  if (size == (size_t) -1)
    return NULL;
  buf = xreallocarray (buf, size + 1, sizeof *buf);
  return buf;
}
</screen>
    </example>
    <para>
     Eğer <parameter>wstring</parameter> boş gösterici ise, çıktı yazılmaz ve dönüşüm yukarıdaki gibi devam eder ve sonuç döndürülür. Uygulamada bu tür davranışlar, dizgeyi dönüştürmek için gereken tam geniş karakter sayısını hesaplamak için kullanışlıdır. <parameter>wstring</parameter> için boş gösterici kabul etme davranışı, &isoc;'de belirtilmeyen ve POSIX'te isteğe bağlı olan bir XPG4.2 uzantısıdır.
    </para>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-wcstombs"><primary>wcstombs</primary></indexterm>
    <csproto type="işlev">
     <csname><type>size_t</type><function>wcstombs</function></csname>
     <csparam><ptr>char</ptr><parameter>string</parameter></csparam>
     <csparam><ptr>const&#160;wchar_t</ptr><parameter>wstring</parameter></csparam>
     <csparam><type>size_t</type><parameter>size</parameter></csparam>
    </csproto>
    <header>&stdlib.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&asunsafe; &corrupt; &heap; &lock; &dlopen;</concept>
     <concept>&acunsafe; &corrupt; &lock; &mem; &fd;</concept>
    </conceptlist>
    <para>
     <code>wcstombs</code> işlevi ("wide character string to multibyte string" kısaltmasıdır),  boş geniş karakter sonlandırmalı <parameter>wstring</parameter> geniş karakter dizgesini çok baytlı karakter dizgesine dönüştürür ve sonucun <parameter>size</parameter> baytını <parameter>string</parameter> içinde saklar. Yeterince yer yoksa sonuç sonlandırıcı boş karakteri içermez. Karakter dönüşümü ilk öteleme durumuyla başlar.
    </para>
    <para>
     Sonlandırıcı boş karakter boyuta dahildir. Bu bakımdan <parameter>size</parameter>, <parameter>wstring</parameter> içindeki baytların sayısına eşit ya da daha küçükse sonlandırıcı boş bayt saklanmaz.
    </para>
    <para>
     Kod için geçerli çok baytlı karakter bulunamazsa işlev <code>-1</code> ile döner. Aksi takdirde, <parameter>string</parameter> dizisi içinde saklanan baytların sayısı ile döner. Bu değer <parameter>size</parameter> bayttan küçükse sonlandırıcı boş karakter dahil değildir.
    </para>
   </csynopsis>
  </sect1>
  <sect1 xml:id="glibc-Shift-State">
   <title>Öteleme Durumu</title>
   <titleabbrev>Evresel olmayan işlevlerde durumlar</titleabbrev>
   <para>
    <indexterm linkend="glibc-cp"><primary>öteleme dizilimleri</primary></indexterm>
    <indexterm linkend="glibc-cp"><primary>öteleme durumu</primary></indexterm>
    Bazı çok baytlı karakterlerin bayt dizilimleri tek başlarına anlamlı değildir; dizge içindeki kendilerinden önce gelen karakterlere bağlı olarak değerlendirilir. Kendinden sonraki dizilimlerin anlamını değiştiren belli başlı birkaç dizilim vardır. Bu dizilimlere <wordasword>öteleme dizilimleri</wordasword> ve bunların hepsine birden <wordasword>öteleme durumu</wordasword> denir.
   </para>
   <para>
    Öteleme dizilimlerini ve öteleme durumu şöyle bir örnekle açıklanabilir: <code>0200</code> diziliminin (bir baytlık) Japonca kipini başlattığı varsayılsın. Bu dizilimden sonra gelen <code>0240</code> ile <code>0377</code> arasındaki bayt çiftleri birer karakter olarak yorumlanır. Aynı şekilde, <code>0201</code> ile Latin-1 kipine girilirse <code>0240</code> ile <code>0377</code> arasındaki tek karakterler Latin-1 karakter kümesindeki karakterler olarak yorumlanır.  Burada iki öteleme durumu (Japonca ve Latin-1 kipi) olan çok baytlı kod ile belli öteleme durumlarını belirten iki öteleme diziliminden bahsedilmiş oldu.
   </para>
   <para>
    Kullanımdaki çok baytlı karakter kodu için öteleme durumları varsa, <function>mblen</function>, <function>mbtowc</function> ve <function>wctomb</function> işlevleri taradıkları dizgenin mevcut öteleme durumlarını düzenlemeli ve güncellemelidir. Bunun olması için şu kurallara uyulmalıdır:
   </para>
   <itemizedlist>
    <listitem>
     <para>
      Bir dizgeyi taramaya başlamadan önce, çok baytlı karakter adresi için işlev <code>mblen (NULL, 0)</code> gibi bir boş gösterici ile çağrılmalıdır. Böylece öteleme durumu işlevin kendi standart ilk değeriyle ilklendirilecektir.
     </para>
    </listitem>
    <listitem>
     <para>
      Dizge sırayla bir defada bir karakter işlenecek şekilde taranmalıdır. Taranan karakterler yedeklenmemeli, yeniden taranmamalı ve bu arada başka dizgeler işleme sokulmamalıdır.
     </para>
    </listitem>
   </itemizedlist>
   <example>
    <para>
     <function>mblen</function> işlevinin bu kurallara uygun olarak kullanımına bir örnek:
    </para>
    <screen>void
scan_string (char *s)
{
  int length = strlen (s);

  /* <replaceable>Öteleme durumunu ilklendir.</replaceable>  */
  mblen (NULL, 0);

  while (1)
    {
      int thischar = mblen (s, length);
      /* <replaceable>Dizge sonunu ve geçersiz karakteri yakala.</replaceable>  */
      if (thischar == 0)
        break;
      if (thischar == -1)
        {
          error ("cok baytli karakter gecersiz");
          break;
        }
      /* <replaceable>Sonraki karaktere geç.</replaceable>  */
      s += thischar;
      length -= thischar;
    }
}
</screen>
   </example>
   <para>
    <function>mblen</function>, <function>mbtowc</function> ve <function>wctomb</function> işlevleri öteleme durumu kullanan çok baytlı kod için evresel değildir. Bununla birlikte, bu işlevleri çağıran herhangi bir kütüphane işlevi olmadığından öteleme durumunun yazılımcının bilgisi dışında değişmesi mümkün değildir.
   </para>
  </sect1>
 </chapter>

 <chapter xml:id="glibc-Generic-Charset-Conversion">
  <title>Karakter Kümesi Dönüşümü</title>
  <titleabbrev><code>iconv</code> arayüzü</titleabbrev>
  <preliminary>
   <para>
    Bu kısma kadar bahsedilen dönüşüm işlevlerinin hiçbirinde işlem yaptıkları karakter kümeleri işlevin bir bağımsız değişkeni olarak belirtilmiyordu ve bu işlevler tüm karakter kümeleri için kullanılabiliyordu. Çok baytlı kodlama <varname>LC_CTYPE</varname> yereli tarafından belirtilen karakter kümesini kullanır. Geniş karakter kümesi gerçeklemeyle sabittir (&glibc; için daima ISO 10646 kodlu UCS-4'tür).
   </para>
   <para>
    Bu, genel karakter dönüşümlerinde birtakım sorunlar içerir:
   </para>
   <itemizedlist>
    <listitem>
     <para>
      Kaynak ve hedef karakter kümelerinden hiçbirinin <varname>LC_CTYPE</varname> yerelinin karakter kümesi olmadığı durumda <varname>LC_CTYPE</varname> yereli <function>setlocale</function> işlevi kullanılarak değiştirilebilir.
     </para>
     <para>
      <varname>LC_CTYPE</varname> yerelinin değiştirilmesi, <varname>LC_CTYPE</varname> sınıfını kullanan işlevlerden (örn, <link linkend="glibc-Classification-of-Characters">karakter sınıflandırma işlevleri</link>) dolayı yazılımın kalanında büyük sorunlara yol açar.
     </para>
    </listitem>
    <listitem>
     <para>
      <varname>LC_CTYPE</varname> seçimi genel olduğundan ve tüm evreler tarafından paylaşılan bir seçim olduğundan farklı karakter kümeleri arasında paralel dönüşümler mümkün olmaz.
     </para>
    </listitem>
    <listitem>
     <para>
      <type>wchar_t</type> gösterimi için kaynağın ve hedefin karakter kümesi kullanılamadığına göre önceki işlevler kullanılarak bir metin dönüştürülmek istenirse iki kademeli işlem gerekir. Birinci adımda çok baytlı kodlama için kaynak karakter kümesi seçilip metin <type>wchar_t</type> metnine dönüştürülecek, ikinci adımda ise hedefin karakter kümesi seçilip geniş karakterli metin bu karakter kümesindeki çok baytlı karakterlere dönüştürülecektir.
     </para>
     <para>
      Bu mümkün olsa bile (garanti değildir) çok yorucu bir çalışmadır. Bundan başka, yerelin iki defa değişmesine bağlı olarak bazı sorunlara da yol açabilecektir.
     </para>
    </listitem>
   </itemizedlist>
   <para>
    XPG2 standardı bu sınırlamaları olmayan tamamen yeni bir işlev ailesi tanımlar. Bunlar seçili yerele bağlı olmadıkları gibi kaynak ve hedef için seçilmiş karakter kümeleriyle ilgili bir sınırlama da getirmez. Tek sınır dönüşüm için kullanılabilecek karakter kümeleridir. Böyle bir kullanışlılık gerçeklemenin kalitesinin bir ölçüsüdür.
   </para>
   <para>
    Bundan sonraki bölümlerde önce <function>iconv</function> arayüzünden ve dönüşüm işlevinden söz edilecektir. Son olarak gelişkin dönüşüm yeteneklerinden yararlanmak isteyen ileri düzey yazılımcıları ilgilendireceği umularak gerçeklemeden bahsedilecektir.
   </para>
  </preliminary>
  <sect1 xml:id="glibc-Generic-Conversion-Interface">
   <title>Dönüşüm Arayüzü</title>
   <titleabbrev>Soysal karakter kümesi dönüşüm arayüzü</titleabbrev>
   <para>
    Bu işlev ailesi geleneksel öz kaynak kullanım yöntemini kullanır: aç-kullan-kapat. Arayüz her biri bir adımı gerçekleştiren üç işlevden oluşur.
   </para>
   <para>
    <indexterm linkend="glibc-pg"><primary>iconv.h</primary></indexterm>
    Arayüzün açıklanmasına geçmeden önce bir veri türünden bahsedilmesi gerekiyor.
    Diğer aç-kullan-kapat arayüzler gibi burada bahsedilen işlevler de tanıtıcıları kullanarak çalışır. Bu tanıtıcıların kullandığı özel veri türü &iconv.h; başlık dosyasında tanımlanmıştır.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-tp" xml:id="glibc-tp-iconv_t"><primary>iconv_t</primary></indexterm>
    <csproto type="veri türü">
     <csname><function>iconv_t</function></csname>
    </csproto>
    <header>&iconv.h;</header>
    <para>
     Bu veri türü soyut, şeffaf olmayan bir türdür. Yazılımcı bu veri türünün tanımıyla ilgili hiçbir kabul yapmamalıdır.
    </para>
    <para>
     Bu türdeki nesneler <function>iconv</function> işlevleri kullanılan dönüşümler için atanmış tanıtıcıları alabilir.  Tanıtıcıyı kullanan dönüşümlerin nesneyi serbest bırakması gerektiğinden nesnelerin kendi kendilerini serbest bırakmaması gerekir.
    </para>
   </csynopsis>
   <para>İlk adım tanıtıcıyı oluşturan işlevdir.</para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-iconv_open"><primary>iconv_open</primary></indexterm>
    <csproto type="işlev">
     <csname><type>iconv_t</type><function>iconv_open</function></csname>
     <csparam><ptr>const&#160;char</ptr><parameter>tocode</parameter></csparam>
     <csparam><ptr>const&#160;char</ptr><parameter>fromcode</parameter></csparam>
    </csproto>
    <header>&iconv.h;</header>
    <conceptlist>
     <concept>&mtsafe; &locale;</concept>
     <concept>&asunsafe; &corrupt; &heap; &lock; &dlopen;</concept>
     <concept>&acunsafe; &corrupt; &lock; &mem; &fd;</concept>
    </conceptlist>
    <para>
     <code>iconv_open</code> işlevi bir dönüşüm başlatmadan önce kullanılması gereken işlevdir. İşlev, dönüşüm için kullanılacak karakter kümelerinin belirtildiği iki bağımsız değişken alır. Gerçekleme böyle bir dönüşümü yapabilecek yeterlilikteyse işlev bir tanıtıcı ile döner.
    </para>
    <para>
     İstenen dönüşüm mümkün değilse işlev, <code>(iconv_t) -1</code> ile döner. Bu durumda <varname>errno</varname> genel değişkenine şu değerlerden biri atanır:
    </para>
    <variablelist>
     <varlistentry>
      <term><code>EMFILE</code></term>
      <listitem>
       <para>
        Süreç zaten <varname>OPEN_MAX</varname> dosya tanıtıcı açmış.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>ENFILE</code></term>
      <listitem>
       <para>
        Sistemin açık dosya sayısı ile ilgili sınırı aşıldı.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>ENOMEM</code></term>
      <listitem>
       <para>
        İşlemi gerçekleştirecek kadar bellek yok.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>EINVAL</code></term>
      <listitem>
       <para>
        <parameter>fromcode</parameter> ile <parameter>tocode</parameter> arasında dönüşüm desteklenmiyor.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
    <para>
     Bağımsız dönüşümler yapacak farklı evrelerde aynı tanıtıcıyı kullanmak mümkün değildir. Tanıtıcı ile ilişkili veri yapıları dönüşüm durumu hakkında bilgi içerir. Bu bilgi farklı dönüşümlerde kullanılarak bozulmamalıdır.
    </para>
    <para>
     Bir <function>iconv</function> tanıtıcısı bir dosya tanıtıcısı gibi her kullanım için yeniden oluşturulmalıdır. Tanıtıcı <parameter>fromcode</parameter> ile <parameter>tocode</parameter> arasındaki tüm dönüşümleri temsil etmez.
    </para>
    <para>
     &glibc;nin <code>iconv_open</code> gerçeklemesi diğer gerçeklemelerden farklı olarak önemli bir özelliğe sahiptir. Dönüşüm için desteklenen tüm karakter kümeleri ile ilgili verileri ve kodları içeren dosyalar belli başlı dizinlerde tutulur. Bu özelliğin nasıl gerçeklendiği <xref linkend="glibc-iconv-Implementation"/> bölümünde açıklanmıştır. Burada üstünde durulacak tek şey, <varname>GCONV_PATH</varname> ortam değişkeninde ismi bulunan dizinlerin sadece bir <filename>gconv-modules</filename> dosyası içermesi halinde geçerli olduğudur. Bu dizinlerin sistem yönetici tarafından oluşturulması şart değildir. Aslında bu özellik kullanıcıların kendilerine özel dönüşümleri yazabilmelerine ve kullanabilmelerine imkan vermek için tasarlanmıştır. Güvenlik kaygıları nedeniyle SUID çalıştırılabilirlerle çalışmaz; bu durumda sadece sistem dizinlerine bakılır. Bunun yeri de normalde <replaceable>önek</replaceable><filename>/lib/gconv</filename> dizinidir. <varname>GCONV_PATH</varname> ortam değişkenine sadece <code>iconv_open</code> işlevi ilk çağrıldığında bakılır. Değişkende sonradan yapılan değişikliğin etkisi yoktur.
    </para>
   </csynopsis>
   <para>
    <code>iconv</code> gerçeklenimi, tanıtıcısı <function>iconv_open</function> tarafından döndürülen geniş veri yapısı ile ilişkilendirilebilir. Diğer taraftan, tüm dönüşümler yapıldıktan sonra ve başka dönüşüm kalmamışsa tüm öz kaynakların hemen serbest bırakılması önemlidir.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-iconv_close"><primary>iconv_close</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>iconv_close</function></csname>
     <csparam><type>iconv_t</type><parameter>cd</parameter></csparam>
    </csproto>
    <header>&iconv.h;</header>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&asunsafe; &corrupt; &heap; &lock; &dlopen;</concept>
     <concept>&acunsafe; &corrupt; &lock; &mem; &fd;</concept>
    </conceptlist>
    <para>
     <code>iconv_close</code> işlevi önceki bir <function>iconv_open</function> çağrısından dönen  <parameter>cd</parameter> tanıtıcısı ile ilişkili tüm öz kaynakları serbest bırakır.
    </para>
    <para>
     İşlev hatasız bir işlem yürütmüşse <code>0</code> ile döner, aksi takdirde <varname>errno</varname> değişkenine hata durumunu kaydederek <code>-1</code> ile döner. İşlev için tanımlı hatalar:
    </para>
    <variablelist>
     <varlistentry>
      <term><code>EBADF</code></term>
      <listitem>
       <para>Dönüşüm tanımlayıcı geçersiz.</para>
      </listitem>
      </varlistentry>
     </variablelist>
     <para>
      <code>iconv_close</code> işlevi diğer <function>iconv</function> işlevleri ile birlikte XPG2 içinde tanımlanmıştır.
     </para>
    </csynopsis>
    <para>
     Standart aslında tek bir dönüşüm işlevi tanımlar. Bu çok genel bir arayüz tanımlandığı için böyledir: Dönüşümün bir tampondan diğerine yapılacağı öngörülmüştür. Dosyadan tampona ve tersi ya da dosyadan dosyaya dönüşümler standarttaki bu tanımı genişleterek gerçeklenebilir.
    </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-iconv"><primary>iconv</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-cp-iconv"><primary>durumsal</primary></indexterm>
    <csproto type="işlev">
     <csname><type>size_t</type><function>iconv</function></csname>
     <csparam><type>iconv_t</type><parameter>cd</parameter></csparam>
     <csparam><pptr>char</pptr><parameter>inbuf</parameter></csparam>
     <csparam><ptr>size_t</ptr><parameter>inbytesleft</parameter></csparam>
     <csparam><pptr>char</pptr><parameter>outbuf</parameter></csparam>
     <csparam><ptr>size_t</ptr><parameter>outbytesleft</parameter></csparam>
    </csproto>
    <header>&iconv.h;</header>
    <conceptlist>
     <concept>&mtsafe; &race;<code linkend="glibc-safety-identifier">:cd</code></concept>
     <concept>&assafe;</concept>
     <concept>&acunsafe; &corrupt;</concept>
    </conceptlist>
    <para>
     <code>iconv</code> işlevi <parameter>cd</parameter> dönüşüm tanıtıcısı ile ilişkilendirilmiş kurallara uygun olarak girdi tamponundaki metni dönüştürerek sonucu çıktı tamponunda saklar. Gerekli durum bilgisi tanıtıcı ile ilişkilendirilmiş veri yapıları içinde tutulduğundan işlev aynı metin için defalarca çağrılabilir.
    </para>
    <para>
     *<parameter>inbuf</parameter> ile belirtilen girdi tamponu *<parameter>inbytesleft</parameter> bayt içerir. Kullanılan girdinin çağrıcı ile iletişimi için ek olarak bir dolaylı işlem gerekir. Tampon göstericisinin <type>char</type> türünde ve tampondaki karakterler geniş karakterler olduğu halde tampon uzunluğunun bayt cinsinden olmasına dikkat edilmelidir.
    </para>
    <para>
     Çıktı tamponu da benzer şekilde sonucun saklanacağı *<parameter>outbuf</parameter> göstericisinin belirtiği adresten başlayan en az *<parameter>outbytesleft</parameter> baytlık bir alan olarak belirtilir. Yine benzer şekilde tampon göstericisi <type>char</type> türündedir ve tampon uzunluğu bayt cinsindendir. <parameter>outbuf</parameter> veya *<parameter>outbuf</parameter> boş gösterici ise dönüşüm yine yapılır ama çıktı üretilmez.
    </para>
    <para>
     <parameter>inbuf</parameter> boş gösterici ise, dönüşüm durumunu ilk duruma getiren bir eylem gerçekleştirilir. Bu, durumsal olmayan kodlamalarda bir eylemle sonuçlanmaz, ama eğer, kodlama bir duruma sahipse böyle bir işlev çağrısı gerekli durum değişikliklerini gerçekleştirecek bazı bayt dizilimlerini çıktı tamponuna koyar. Normal bir <parameter>inbuf</parameter> ile yapılan bir sonraki işlev çağrısında dönüşüm ilk durumdan başlar. Yazılımcının dönüşümün durumsallığı ile ilgili bir ön kabul yapmaktan kaçınması gerekir. Girdi ve çıktı karakterleri durumsal olmasa bile gerçekleme yine de durumları tutmak zorunda olabilir. Aşağıda açıklanan sebeplerden dolayı &glibc;nde bu böyledir. Bu nedenle, durumu sıfırlayacak bir <code>iconv</code> çağrısı, bir protokol, çıktı metni için bunu gerektiriyorsa daima bunu yapacaktır.
    </para>
    <para>
     Dönüşüm üç sebepten birine bağlı olarak durabilir. İlki girdi tamponundaki tüm karakterlerin dönüştürüldüğü durumdur. Bu aslında iki farklı anlama gelir: Ya girdi tamponundaki tüm karakterler tüketilmiştir ya da tamponun sonunda girdide eksik ama tamponda tam biçimde olan bazı baytlar bulunmuştur. Durmanın ikinci sebebi çıktı tamponunun dolmasıdır. Üçüncüsü ise girdinin geçersiz karakterler içermesidir.
    </para>
    <para>
     Bu durumların hepsinde sorunsuz yapılan son dönüşümün ardından girdi ve çıktı tamponları <parameter>inbuf</parameter> ve <parameter>outbuf</parameter>,  tamponun uzunlukları ise sırayla <parameter>inbytesleft</parameter> ve <parameter>outbytesleft</parameter> göstericileriyle döndürülür.
    </para>
    <para>
     <function>iconv_open</function> çağrısında seçilen karakter kümeleri hemen hemen tamamen isteğe bağlı olduğundan girdi karakter kümesinde, çıktı karakter kümesinde karşılığı olmayan karakterler bulunabilir. Bu durumda işlevin davranışı tanımsızdır. &glibc;nin bu durum karşısında <emphasis>şimdiki</emphasis> davranışı bir hata durumu ile dönmektir. Bu olması gereken çözüm değildir; bu nedenle, daha iyi bir çözüm için çalışmalar sürmektedir ve kütüphanenin gelecek sürümlerinde daha iyi bir çözüm sunulacaktır.
    </para>
    <para>
     Girdi tamponundaki karakterlerin tümü değiştirilip sonuç çıktı tamponunda saklanmışsa, işlev tersinir olmayan dönüşümlerin sayısı ile döner. Bunun dışındaki tüm durumlarda işlev <code>(size_t) -1</code> ile döner ve <varname>errno</varname> değişkenine hata durumunu kaydeder. Böyle durumlarda <parameter>inbytesleft</parameter> ile gösterilen değer sıfırdan farklıdır.
    </para>
    <variablelist>
     <varlistentry>
      <term><code>EILSEQ</code></term>
      <listitem>
       <para>
        Girdi geçersiz bir bayt dizilimi içerdiğinden dönüşüm durdu. Çağrıdan sonra, *<parameter>inbytesleft</parameter> geçerli bayt dizilimlerinin ilk baytını gösterir.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>E2BIG</code></term>
      <listitem>
       <para>
        Çıktı tamponu yetersiz olduğundan dönüşüm durdu.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>EINVAL</code></term>
      <listitem>
       <para>
        Girdi tamponunun sonundaki bayt dizilimi eksik olduğundan dönüşüm durdu.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><code>EBADF</code></term>
      <listitem>
       <para>
        <parameter>cd</parameter> bağımsız değişkeni geçersiz.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
    <para>
     <code>iconv</code> işlevi XPG2 içinde tanımlanmıştır.
    </para>
   </csynopsis>
   <para>
    <code>iconv</code> işlevi, benzerlerinden daha iyi gerçeklenmiştir. Daha esnek bir işlevsellik sunar. Sorunlu kısımlar, geçersiz girdi ve girdi tamponunun sonundaki geçersiz bayt dizilimlerinin olduğu durumlardır. Üçüncü bir sorun varsa da, bu bir tasarım sorunu değildir, dönüşümlerin seçimi ile ilgilidir. Standart, meşru isimler hakkında bir şey içermez. Bunun diğer gerçeklemeleri nasıl olumsuz etkilediğini sonraki bölümde bir örnekle gösterilecektir.
   </para>
  </sect1>
  <sect1 xml:id="glibc-iconv-Examples">
   <title><code>iconv</code> Örneği</title>
   <titleabbrev>Eksiksiz bir <code>iconv</code> örneği</titleabbrev>
   <para>
    Aşağıdaki örnekte ortak bir soruna bir çözüm sunulmaktadır. <type>wchar_t</type> dizgeleri için sistem tarafından bilinen kodlamalar verilmiştir. Metin bir dosyadan okunmakta ve geniş karakter tamponunda saklanmaktadır. Dönüşüm <function>mbsrtowcs</function> kullanılarak da yapılabilirdi fakat evvelce bahsedilen sorunlar oluşurdu.
   </para>
   <screen>int
file2wcs (int fd, const char *charset, wchar_t *outbuf, size_t avail)
{
  char inbuf[BUFSIZ];
  size_t insize = 0;
  char *wrptr = (char *) outbuf;
  int result = 0;
  iconv_t cd;

  cd = iconv_open ("WCHAR_T", charset);
  if (cd == (iconv_t) -1)
    {
      /* <replaceable>Yanlış giden bir şeyler olabilir.</replaceable>  */
      if (errno == EINVAL)
        error (0, 0, "'%s' için wchar_t cinsinden bir karşılık yok",
               charset);
      else
        perror ("iconv_open");

      /* <replaceable>Çıktı dizgesini sonlandır.</replaceable>  */
      *outbuf = L'\0';

      return -1;
    }

  while (avail &gt; 0)
    {
      size_t nread;
      size_t nconv;
      char *inptr = inbuf;

      /* <replaceable>Girdinin kalanını oku.</replaceable>  */
      nread = read (fd, inbuf + insize, sizeof (inbuf) - insize);
      if (nread == 0)
        {
          /* <replaceable>Buraya gelimişsek okuma tamamlanmıştır.
             Ama hala <code>inbuf</code> içinde kullanılmamış
             karakterler kalmış olabilir. Onları geri koy.</replaceable>  */
          if (lseek (fd, -insize, SEEK_CUR) == -1)
            result = -1;

          /* <replaceable>Gerekliyse, ilk duruma girecek bayt dizilimini yaz.</replaceable>  */
          iconv (cd, NULL, NULL, &amp;wrptr, &amp;avail);

          break;
        }
      insize += nread;

      /* <replaceable>Dönüşümü yap.</replaceable>  */
      nconv = iconv (cd, &amp;inptr, &amp;insize, &amp;wrptr, &amp;avail);
      if (nconv == (size_t) -1)
        {
          /* <replaceable>Herşey yolunda gitmez. Tamponun sonunda bitmemiş
             bayt dizilimi olabilir. Kimi zaman da gerçekten
             önemli bir sorun olabilir.</replaceable>  */
          if (errno == EINVAL)
            /* <replaceable>Bu zararsız. Kullanılmayan baytları tamponun başına
               taşı, böylece sonraki adımda kullanılabilir.</replaceable>  */
            memmove (inbuf, inptr, insize);
          else
            {
              /* <replaceable>Bu gerçekten bir sorun. Ya çıktı tamponu yetersiz
                 ya da girdi geçersiz. Her durumda, dosya
                 göstericisini işlenen son baytın konumuna ayarla.</replaceable>  */
              lseek (fd, -insize, SEEK_CUR);
              result = -1;
              break;
            }
        }
    }

  /* <replaceable>Çıktı dizgesini sonlandır.</replaceable>  */
  if (avail &gt;= sizeof (wchar_t))
    *((wchar_t *) wrptr) = L'\0';

  if (iconv_close (cd) != 0)
    perror ("iconv_close");

  return (wchar_t *) wrptr - outbuf;
}
</screen>
   <para>
    Bu örnek, <function>iconv</function> işlevlerinin en önemli kullanım şekillerini göstermektedir. Büyük boyutta bir metnin <function>iconv</function> çağrılarıyla nasıl dönüştürülebileceği gösterilmiştir. Kullanıcı durumsal kodlamalar hakkında bir şey bilmek zorunda değildir.
   </para>
   <para>
    <function>iconv</function> işlevinin <varname>errno</varname> değişkenine <varname>EINVAL</varname> değerini atayarak döndüğü durum ilginçtir. Bu gerçekte dönüşümdeki bir hata değildir. Girdi karakter kümesinin tek parça olarak işlenemeyen metinler ve bir bayttan uzun bayt dizilimleri içermesine bağlı olarak oluşur. Bu durumda çok baytlı dizilimin bölünmesi olasılığı vardır. Çağrıcı basitçe bu sorunlu baytları atlayıp girdiden kalan baytları okuyup <function>iconv</function>'ye aktararak dönüşümü devam ettirebilir. &isoc; standardında böyle bir olay sonrasındaki duruma bağlı olarak dönüşüm işlevlerinin tanıtıcıda tutulan dahili durum bilgisinin ne olacağı belirtilmemiştir.
   </para>
   <para>
    Ayrıca, örnekte <function>iconv</function> işlevinde geniş karakterli dizgelerin kullanımına bağlı sorunlar da gösterilmiştir. <function>iconv</function> işlevinin açıklamasında belirtildiği gibi, işlev daima bir <type>char</type> dizisi alır, dolayısıyla bu dizinin boyutu bayt cinsindendir. Örnekte ise çıktı tamponu geniş karakter tamponudur; bu nedenle <function>iconv</function> çağrısında <type>char*</type> türünde olan <replaceable>wrptr</replaceable> yerel değişkeni kullanıldı.
   </para>
   <para>
    Bu oldukça masum görünür ama hizalama konusunda sıkı sınırlamaları olan platformlarda sorunlara yol açabilir. Bu nedenle bu tür <function>iconv</function> çağrılarında ilgili karakter kümesindeki karakterlere erişmek için uygun bir gösterici kullanılmalıdır. İşlevin girdi bağımsız değişkeni <type>wchar_t</type> göstericisi olduğundan bu sağlanmıştır (aksi takdirde bağımsız değişken hesaplanırken hizalama bozulacaktı). Fakat diğer bir durumda, özellikle kullanılan karakter kümesi türünün bilinmediği soysal işlevler yazılırken metinler bayt dizilimleri olarak ele alındığından bu çok zor olabilir.
   </para>
  </sect1>
  <sect1 xml:id="glibc-Other-iconv-Implementations">
   <title>Diğer <code>iconv</code> Gerçeklenimleri</title>
   <titleabbrev>Diğer <code>iconv</code> gerçeklenimleri hakkında.</titleabbrev>
   <para>
    Burada diğer sistemlerdeki <function>iconv</function> gerçeklenimleri tartışılmayacaktır, ancak taşınabilir uygulamalar yazılırken onlar hakkında biraz bir şeyler bilmek gerekir. Önceki bölümlerde <function>iconv</function> işlevinin belirtimi ile ilgili olarak taşınabilirlik sorunlarından bahsedilmişti.
   </para>
   <para>
    İlk uyarı, kullanılabilecek karakter kümesi sayısının çokluğu ile ilgilidir. Dönüşümlerin doğrudan C kütüphanesinde kodlanması elbette uygulanabilir değildir. Bu nedenle, dönüşüm bilgisi C kütüphanesi dışından bazı dosyalarla sağlanmalıdır. Bu, aşağıdaki yöntemlerden biri ya da her ikisi birden kullanılarak yapılır:
   </para>
   <itemizedlist>
    <listitem>
     <para>
      C kütüphanesi gerekli dönüşüm tablolarını ve diğer bilgileri veri dosyalarından okuyabilen işlevler ailesi içerir. Bu dosyalar gerektikçe yüklenir.
     </para>
     <para>
      Bu çözüm tüm karakter kümelerine (teorik olarak sonsuz sayıda) uygulanması büyük bir çaba gerektirdiğinden oldukça sorunludur. Farklı karakter kümelerinin yapısal farkları çok çeşitli tablo işleme işlevlerinin geliştirilmesini gerektirir.Bu işlevler doğaları gereğince gerçekleştirilmiş işlevlerden özellikle daha yavaştır.
     </para>
    </listitem>
    <listitem>
     <para>
      C kütüphanesi özdevimli yüklenebilen nesne dosyaları içerir ve dönüşüm işlevleri bu nesnelerin içeriğini icra eder.
     </para>
     <para>
      Bu çözüm çok büyük esneklik sağlar. C kütüphanesinin kendisi çok az kod içerir ve bu nedenle genel bellek ihtiyacı çok azalır. Ayrıca, C kütüphanesi ile yüklenebilir modüller arasındaki belgelemesi yapılmış bir arayüz ile kullanılabilecek dönüşüm modüllerinin üçüncü parti modüllerle genişletilebilmesi mümkündür. Bu çözümün uygulanabilir olması için özdevimli yükleme mümkün olmalıdır.
     </para>
    </listitem>
   </itemizedlist>
   <para>
    Ticari Unix'lerdeki bazı gerçeklenimler bu yöntemlerin bir karışımını kullanırken çoğunluğu ikinci çözümü kullanır. Yüklenebilir modüllerin kullanımı kodu kütüphanenin dışına taşır, genişletmeler ve eklentiler için kapıyı açık tutar. Ancak, durağan olarak ilintilenmiş yazılımlarda özdevimli yükleme desteği olmayan bazı sistemlerde bu tasarım bir sınırlama haline gelebilmektedir. Bu yeteneği olmayan sistemlerde bu arayüzün durağan olarak ilintilenmiş yazılımlarda kullanılması bu nedenle mümkün değildir. &glibc;nin, ELF sistemlerinde, bu gibi durumlarda özdevimli yükleme ile ilgili sorunları yoktur; bu nedenle bu konu tartışma götürür. Tehlikeli olan, bu durumla ilgili bilgi sahibi olunduğu halde diğer sistemlerin sınırlamalarını unutmaktır.
   </para>
   <para>
    Diğer <function>iconv</function> gerçeklemeleri hakkında bilmemiz gereken ikinci şey kullanılabilecek dönüşümlerin genellikle çok sınırlı kalmasıyla ilgilidir. Bazı gerçeklemeler standart dağıtımlarında (geliştirici ve özel uluslararası dağıtımlar değil) en fazla 100 bilemedin 200 dönüşüm olasılığı sağlar. Bu 200 farklı karakter kümesinin desteklendiği anlamına gelse iyi; örneğin, bir karakter kümesinin 10 farklı karakter kümesine dönüşümü 10 sayılır. Bununla birlikte bu karakter kümesinin diğer yöndeki dönüşümü de eklenerek bu sayı 20 yapılır. Bu sistemlerde yapılan ince hesabın sınırları tasavvur edilemez. Bazı Unix şirketleri ise sadece bir dönüşümü diğer dönüşümleri kullanışsız olsa bile türetmek için kullanır.
   </para>
   <para>
    Bu doğrudan üçüncü ve oldukça büyük bir soruna yol açar. Bu yolla gerçeklenmiş <function>iconv</function> dönüşüm işlevlerini kullanan Unix sistemlerinde <code>A</code> kümesinden <code>B</code> kümesine ve <code>B</code> kümesinden <code>C</code> kümesine dönüşüm yapılabilmesi <code>A</code> kümesinden <code>C</code> kümesine dönüşüm yapılabileceği anlamına gelmez.
   </para>
   <example>
    <para>
     İlk bakışta bir sorun yokmuş gibi görünse de basit bir uygulama sorunun farkedilmesini sağlar. Sorunu göstermek için A karakter kümesinden C karakter kümesine dönüşüm yapacak bir kod şöyle olurdu:
    </para>
    <screen>cd = iconv_open ("<code>C</code>", "<code>A</code>");
</screen>
    <para>
     çağrısı yukarıda belirtilen nedenle başarısız olacaktır. Şimdi yazılımın geleceği ne olacak? Bu dönüşüm gerekli...
    </para>
    <para>
     Tam baş belası. <function>iconv</function> işlevi bunu yapmalıydı. Kodu nasıl yazmalı? Önce B karakter kümesine dönüşüm yapılabilir:
    </para>
    <screen>cd1 = iconv_open ("<code>B</code>", "<code>A</code>");
</screen>
    <para>sonra da C</para>
    <screen>cd2 = iconv_open ("<code>C</code>", "<code>B</code>");
</screen>
    <para>
     Bu çalışacaktır, ama <code>B</code>'nin hangi karakter kümesi olacağı nasıl bilinecek?
    </para>
    <para>
     Yanıtı ne yazık ki, genel bir çözümün olmadığıdır. Yine de bazı sistemler bize yardımcı olabilir. Bu sistemlerde çoğu karakter kümesi UTF-8 kodlu ISO-10646 veya Unicode metinlere ve tersine dönüştürülebilir. Bundan başka sisteme çok bağlı bir yöntem de yardımcı olabilir. Bu sistemlerde, dönüşüm işlevleri yüklenebilir modüllerde gelir ve bu modüller dosya sisteminde belirli bir yerde bulunur. Bu dosyalara bakarak <code>A</code> kümesinden <code>C</code> kümesine dönüşüm yaparken kullanılacak ortak ara dönüşüm kümesi saptanabilir.
    </para>
    <para>
     Bu örnek, yukarıda bahsedilen <function>iconv</function> tasarım hatalarından birinin örneğidir. Kullanılabilecek dönüşümlerin listesini yazılımsal olarak elde etmek en azından mümkün olmalıdır. <function>iconv_open</function> işlevi böyle bir dönüşümün olamayacağını söylerse bu yolla bu liste bulunabilir.
    </para>
   </example>
  </sect1>
  <sect1 xml:id="glibc-iconv-Implementation" userlevel="notoc">
   <?dbhtml stop-chunking?>
   <title>Glibc <code>iconv</code> Gerçeklenimi</title>
   <titleabbrev>&glibc;ndeki <code>iconv</code> gerçeklenimi.</titleabbrev>
   <para>
    Bir önceki bölümde <function>iconv</function> gerçeklenimlerinin sorunlarını okuduktan sonra &glibc;ndeki gerçeklenimin bu sorunlardan hiçbirine yol açmadığını söylemek elbette iyi olacaktır. Geliştirme şimdiki durumuna göre (Ocak 1999) genişletilerek sürdürülmektedir. <function>iconv</function> işlevlerinin geliştirmesi henüz bitmemiş olmakla birlikte temel işlevsellik değişmeyecektir.
   </para>
   <para>
    &glibc;nin <function>iconv</function> gerçeklenimi dönüşümleri gerçekleştirmek için paylaşımlı yüklenebilir modülleri kullanır. Kütüphanenin kendi içinde yerleşik olan dönüşümlerin sayısı çok azdır ve bunlar oldukça önemsiz dönüşümlerdir.
   </para>
   <para>
    Yüklenebilir modüllerin tüm faydalarından &glibc;ndeki gerçeklemede yararlanılmıştır. Arayüz iyi belgelendiğinden (aşağıya bakınız), bu özellikle cezbedicidir ve bundan dolayı yeni dönüşüm modüllerini yazmak kolaydır. Yüklenebilir modüllerin kullanımından kaynaklanan sakıncalar &glibc;nde en azından ELF sistemlerde sorun çıkarmaz. Duruk ilintili çalıştırılabilir nesneler olsalar bile, kütüphane, paylaşımlı nesneleri yükleyebildiğinden, duruk ilintilemenin <function>iconv</function> kullanılmak istendiğinde yasak olmaması gerekir.
   </para>
   <para>
    Bahsi geçen sorunlardan ikincisi desteklenen dönüşümlerin sayısı ile ilgiliydi. Şu anda &glibc; yüzelliden fazla karakter kümesini desteklemektedir. Bu karakter kümeleri arasında deteklenen dönüşümlerin sayısı ise <code>22350</code>'den (<code>150</code> çarpı <code>149</code>) fazladır. Bir karakter kümesinden diğerinde dönüşüm eksikse kolayca eklenebilir.
   </para>
   <para>
    Bu yüksek sayıdan dolayı kısmen etkileyici olmakla birlikte &glibc;ndeki <function>iconv</function> gerçeklenimi önceki bölümde bahsedilen üçüncü sorundan da muaftır (<code>A</code>'dan <code>B</code>'ye ve <code>B</code>'den <code>C</code>'ye dönüşüm mümkünse <code>A</code>'dan <code>C</code>'ye doğrudan dönüşüm de daima mümkün olmalıdır da mümkün mü acaba sorunu). <command>iconv_open</command> işlevi bir hata ile dönerse ve <varname>errno</varname> değişkenine <varname>EINVAL</varname> değerini atarsa bu, istenen dönüşümün doğrudan ya da dolaylı olarak mümkün olmadığı anlamına gelir.
   </para>
   <para>
    <indexterm linkend="glibc-cp" xml:id="glibc-iconv-triangulation"><primary>üçgenlere bölme</primary></indexterm>
    Üçgenlere bölme her karakter kümesinin diğerine dönüşümü arada UCS-4 kodlu ISO 10646 dönüşümü kullanılarak gerçekleştirilir. Ara dönüşüm için ISO 10646 karakter kümesinin kullanılmasıyla üçgenlere bölme mümkün olur.
   </para>
   <para>
    Yeni bir karakter kümesi için ISO 10646 kümesinde dönüşümün gerekliliğinden bahsetmek mümkün olmadığı gibi diğer karakter kümelerine dönüşümde ISO 10646'nın ne kaynak ne de hedef karakter kümesi olarak kullanılmasının gerekliliğinden bahsetmek mümkündür. Mevcut dönüşümlerin tamamı basitçe birbiriyle alakalı dönüşümlerdir.
   </para>
   <para>
    <indexterm linkend="glibc-cp" xml:id="glibc-iconv-ISO-2022-JP"><primary>ISO-2022-JP</primary></indexterm>
    <indexterm linkend="glibc-cp" xml:id="glibc-iconv-EUC-JP"><primary>EUC-JP</primary></indexterm>
    Şu an mevcut olan tüm dönüşümler dönüşümü gereksiz yere yavaşlatan yukarıda bahsedilen üçgenlere bölme yöntemini kullanır. Eğer örneğin, ISO-2022-JP ve EUC-JP gibi bazı karakter kümeleri arasındaki dönüşümün hızlı olması istenirse aradan ISO 10646 çıkarılıp iki karakter kümesi arasında doğrudan bir dönüşüm yaptırılabilir. Bu iki karakter kümesi ISO 10646'ya nazaran birbirine daha benzer karakter kümeleridir.
   </para>
   <para>
    Böyle bir durumda yeni bir dönüşümü yazmak ve daha iyi bir seçenek üretmek kolaydır. &glibc;nin <function>iconv</function> gerçeklenimi eğer daha verimli olacağı belirtilirse dönüşümü gerçekleştiren modülü özdevinimli olarak kullanacaktır.
   </para>
   <sect2>
    <title><code>gconv-modules</code> dosyalarının biçimi</title>
    <para>
     Kullanılabilir dönüşümler hakkındaki bilgilerin tamamı <filename>gconv-modules</filename> adı verilen bir dosyanın içinde yer alır. Bu dosyanın yeri <varname>GCONV_PATH</varname> ortam değişkeninde kayıtlıdır. <filename>gconv-modules</filename> dosyaları satırlardan oluşan metin dosyalarıdır. Dosyadaki her satır şöyle yorumlanır:
    </para>
    <itemizedlist>
     <listitem>
      <para>
       Bir satırdaki boşluk olmayan ilk karakter bir <code>#</code> karakteri ise bu satırın sadece açıklamaları içerdiği varsayılır ve içeriği yorumlanmaz.
      </para>
     </listitem>
     <listitem>
      <para>
       <code>alias</code> ile başlayan satırlar karakter kümesi için bir takma ad tanımlar. Bu satırlar üzerinde iki sözcük olması beklenir. İlk sözcük takma adı, ikinci sözcük ise karakter kümesinin gerçek adını belirtir. Bu satırlarda belirtilen takma adları <function>iconv_open</function> işlevinin <parameter>fromcode</parameter> veya <parameter>tocode</parameter> bağımsız değişkenlerinde kullanırsanız gerçek karakter kümesi adı kullanılmış gibi işlem yapılır.
       </para>
       <para>
        Bir karakter kümesinin birçok farklı ad aldığı duruma sıkça rastlanır. Genelde karakter kümesinin resmi adı yerine halk dilindeki adı kullanılır. Bundan başka bir karakter kümesinin çeşitli nedenlerle oluşturulmuş özel adları da olabilir. Örneğin ISO tarafından belirtilen tüm karakter kümeleri <replaceable>nnn</replaceable> kayıt numarası olmak üzere <code>ISO-IR-</code><replaceable>nnn</replaceable> biçiminde bir takma ada sahiptir. Bu, yazılımlarca karakter kümesi adlarını oluşturan kayıt numaralarının bilinmesini ve bunların <function>iconv_open</function> çağrılarında kullanılabilmesini mümkün kılar. Bir karakter kümesi ile ilintili tüm takma adlar alt alta ayrı satırlarda belirtilebilir.
      </para>
     </listitem>
     <listitem>
      <para>
       <code>module</code> ile başlayan satırlar mevcut dönüşüm modüllerini içerir. Bu satırlar üç veya dört sözcük içermelidir.
      </para>
      <para>
       İlk sözcük kaynak karakter kümesini, ikincisi hedef karakter kümesini, üçüncüsü ise bu dönüşümde yüklenecek olan modülün dosya ismini belirtir. Dosya ismi paylaşımlı nesne dosyalarının uzantısını (normalde <filename>.so</filename>) içermemelidir. Bu dosyaların <filename>gconv-modules</filename> dosyasının bulunduğu dizinde olduğu varsaylır. Satırdaki son sözcük isteğe bağlıdır. Dönüşüm bedelini gösteren bir tamsayıdır ve belirtilmemişse ön tanımlı değeri olan 1 olduğu varsayılır. Dönüşümü gerçekletirecek alt dönüşümlerin sayısını belirtir. Aşağıda bedel değerinin kullanımı ayrıntılı olarak açıklanmıştır.
      </para>
     </listitem>
    </itemizedlist>
    <para>
     Yukarıdaki örnekte, ISO-2022-JP ile EUC-JP karakter kümeleri arasında doğrudan dönüşüm için bir modülün varlığından söz edilmişti. Her iki yönde de dönüşüm tek bir modül tarafından yapılır ve bu modülün dosya ismi <filename>ISO2022JP-EUCJP.so</filename>'dur. Dosyanın bulunduğu dizindeki <filename>gconv-modules</filename> dosyasının içeriğinde bu modülün tanımı şöyle olurdu:
    </para>
    <screen>module  ISO-2022-JP//   EUC-JP//        ISO2022JP-EUCJP    1
module  EUC-JP//        ISO-2022-JP//   ISO2022JP-EUCJP    1
</screen>
    <para>
     Bu iki satırın neden yeterli olduğunu anlamak için <function>iconv</function> tarafından bunların nasıl kullanıldığını anlamak gerekir. Bu soruna yaklaşım oldukça basittir.
    </para>
    <para>
     <function>iconv_open</function> işlevinin ilk çağrısında yazılım tüm <filename>gconv-modules</filename> dosyalarını okur ve iki tablo oluşturur: Biri bilinen takma adları diğeri dönüşümler ve bunları gerçekleştiren paylaşımlı nesneyi içerir.
    </para>
   </sect2>
   <sect2>
    <title><code>iconv</code>'de dönüşüm yolunun bulunması</title>
    <para>
     Olası dönüşümlerin listesi ağırlıklı kenarların oluşturduğu bir çizge şeklinde tarif edilebilir. Kenarların ağırlıkları <filename>gconv-modules</filename> dosyalarında belirtilen bedeller belirler. <function>iconv_open</function> işlevi kaynak ve hedef karakter kümeleri arasındaki en kısa yolu bulmak için böyle bir çizgeyle çalışan bir algoritma kullanır.
    </para>
    <para>
     <function>iconv</function> gerçeklemesinin neden örneğin ISO-2022-JP ve EUC-JP karakter kümeleri arasındaki dönüşümlerde kütüphane ile gelen dönüşümler yerine <filename>gconv-modules</filename> dosyalarında belirtilen dönüşüm modülünü kullandığını açıklamak artık kolaydır. Kütüphane ile gelen dönüşümler, dönüşümü iki adımda gerçekleştirir (ISO-2022-JP -> ISO 10646 ve ISO 10646 -> EUC-JP). Bu durumda bedel <code>1 + 1 = 2</code> olur. Yukarıda ise <filename>gconv-modules</filename> dosyasında bu dönüşümün bedeli <code>1</code> olan bir dönüşüm modülü ile gerçekleştirilebileceği belirtilmişti.
    </para>
    <para>
     Yukarıdaki (ve ayrıca &glibc; ile gelen) <filename>gconv-modules</filename> dosyası ile ilgili gizemli bir öge <code>module</code> satırlarında belirtilmiş karakter kümesi isimleridir. Bu isimlerin bazıları neden <code>//</code> ile biter? Bu şekilde biten isimler birer düzenli ifade olduklarından öyle biter. Heceleme ile ilgilenmiyorsanız bu size bir şey ifade etmeyecektir. <emphasis>Kusura bakmayın! Gerçeklenimin bu kısmı henüz bitmedi. Şimdilik sadece örnekleri izlemekle yetinin, lütfen. Gerçeklenim tamamlanınca herşey daha iyi olacak. -drepper</emphasis>
    </para>
    <para>
     <filename>gconv-modules</filename> hakkındaki son düşünceler <code>//</code> ile bitmeyen isimlerle ilgilidir. <code>INTERNAL</code>  diye bir karakter kümesi ismi sık sık geçer. Bu karakter kümesi ismi yukarıdaki dönüşüm tartışmasında üçlemenin ara adımını oluşturan karakter kümesini nitelemek için seçilmiştir. Bunun aslında UCS-4 olduğundan bahsetmişsek de bu tamamen doğru değildir. UCS-4 belirtimi, kendi içinde bayt sıralaması için kullanılan bir belirtim daha içerir. Bir UCS-4 değeri 4 bayttan oluştuğundan saklanan değer bayt sıralamasından etkilenir. Eğer işlemcinin (en azından çalışan sürecin) bayt sıralaması UCS-4 için gerekenle aynı değilse, değerin dahili gösterimi UCS-4’teki ile aynı olmayacaktır. Dönüşüm sırasında ara dönüşüm ürününün durumu ile ilgilenmeyen biri için bayt takaslama işlemlerine zaman harcamanın gereği yoktur. Bayt sıralama sorunlarından kaçınmak için, en kıymetli baytın en düşük adrese yerleştirildiği bayt sıralamasını kullanan sistemlerle aynı bayt sıralamasına sahip dahili karakter kümesine <code>INTERNAL</code> ismi verilmiştir.
    </para>
   </sect2>
   <sect2><title><code>iconv</code> modülü veri yapıları</title>
    <para>
     <indexterm linkend="glibc-pg"><primary>gconv.h</primary></indexterm>
     Bu bölüme kadar modüllerin yerlerinin kullanımı açıklandı. Burada yeni bir modül yazmak için kullanılacak arayüz açıklanacaktır. Bu bölümde açıklanacak arayüz Ocak 1999'dan beri kullanılmaktadır. Arayüz gelecekte biraz değişecekse de bu değişiklik uyumluluk korunarak yapılacaktır.
    </para>
    <para>
     Yeni bir modülü yazmak için gerekli tanımlar standart dışı bir başlık dosyası olan <filename>gconv.h</filename> içindedir. Aşağıda, bu dosyada bulunan tanımlar şimdilik sadece bir önbilgi verecek kadar açıklanmıştır.
    </para>
    <para>
     <function>iconv</function> kullanıcısının bakış açısından arayüz basittir: <function>iconv_open</function> işlevi <function>iconv</function> çağrılarında kullanılabilen bir tanıtıcı ile döner. Bu tanıtıcının görevi sona erdiğinde  bir <function>iconv_close</function> çağrısı ile tanıtıcı serbest bırakılır. Burada sorun, tanıtıcı <function>iconv</function> işlevine aktarılan herşey olduğundan tanıtıcının tüm dönüşüm adımlarını ve ayrıca her dönüşümün durum bilgisini tutması zorunluluğudur. Bu nedenle, gerçeklemeyi anlamak için en önemi elemanlar aslında bu veri yapılarıdır.
    </para>
    <para>
     İki farklı veri yapısına ihtiyacımız var. İlki dönüşümü, ikincisi da durumu, v.s. yi açıklamak için. Aslında <filename>gconv.h</filename> dosyasında bunun gibi iki tanım vardır.
    </para>
    <csynopsis>
     <indexterm linkend="glibc-tp" xml:id="glibc-tp-gconv_step"><primary sortas="gconv_step">struct&#160;__gconv_step</primary></indexterm>
     <csproto type="veri türü">
      <csname><type>struct</type><function>__gconv_step</function></csname>
     </csproto>
     <header>&gconv.h;</header>
     <para>
      Bu veri yapısı bir modülün gerçekleştirdiği bir dönüşümü açıklar. Dönüşüm işlevleri ile yüklenen bir modüldeki her işlev için bu türde tek bir nesne vardır (bu nesne asıl dönüşüme ilişkin bir bilgi içermez, sadece dönüşümün kendisini tanımlar).
     </para>
     <glosslist>
      <glossentry>
       <glossterm><glossterm>
        <type>struct __gconv_loaded_object *</type><structfield>__shlib_handle</structfield>
       </glossterm><glossterm>
        <type>const char *</type><structfield>__modname</structfield>
       </glossterm><glossterm>
        <type>int </type><structfield>__counter</structfield>
       </glossterm></glossterm>
       <glossdef>
        <para>
         Yapının bu elemanları C kütüphanesi tarafından dahili olarak kullanılır ve paylaşımın yüklenmesini ve kaldırılmasını yönetir.  Birinin kullanılmış olması diğerlerinin kullanılmasını ya da ilklendirilmesini gerektirmez.
        </para>
       </glossdef>
      </glossentry>
      <glossentry>
       <glossterm><glossterm>
        <type>const char *</type><structfield>__from_name</structfield>
       </glossterm><glossterm>
        <type>const char *</type><structfield>__to_name</structfield>
       </glossterm></glossterm>
       <glossdef>
        <para>
         <structfield>__from_name</structfield> ve <structfield>__to_name</structfield> alanları kaynak ve hedef karakter kümelerinin isimlerini içerir. Bir modül birden fazla karakter kümesi ve yönde dönüşüm için kullanılabildiğinden asıl dönüşümü tanımlamakta kullanılır.
        </para>
       </glossdef>
      </glossentry>
      <glossentry>
       <glossterm><glossterm>
        <type>gconv_fct </type><structfield>__fct</structfield>
       </glossterm><glossterm>
        <type>gconv_init_fct </type><structfield>__init_fct</structfield>
       </glossterm><glossterm>
        <type>gconv_end_fct </type><structfield>__end_fct</structfield>
       </glossterm></glossterm>
       <glossdef>
        <para>
         Bu alanlar yüklenebilir modüldeki işlevlere göstericileri içerir. Arayüz aşağıda açıklanacaktır.
        </para>
       </glossdef>
      </glossentry>
      <glossentry>
       <glossterm><glossterm>
        <type>int </type><structfield>__min_needed_from</structfield>
       </glossterm><glossterm>
        <type>int </type><structfield>__max_needed_from</structfield>
       </glossterm><glossterm>
        <type>int </type><structfield>__min_needed_to</structfield>
       </glossterm><glossterm>
        <type>int </type><structfield>__max_needed_to</structfield>
       </glossterm></glossterm>
       <glossdef>
        <para>
         Bu değerler modülün ilklendirme işleviyle atanmalıdır. <structfield>__min_needed_from</structfield> değeri kaynak karakter kümesinin en az kaç bayt gerektirdiğini belirtir. <structfield>__max_needed_from</structfield> değeri azami değer ile ayrıca olası öteleme dizilimlerini belirtir.
        </para>
        <para>
         <structfield>__min_needed_to</structfield> ve <structfield>__max_needed_to</structfield> ise benzer değerleri hedef karakter kümesi için içerir.
        </para>
        <para>
         Bu değerlerin doğruluğu son derece önemlidir, çünkü aksi takdirde dönüşüm işlevleri sorun çıkaracak ve bekleneni yapmayacaktır.
        </para>
       </glossdef>
      </glossentry>
      <glossentry>
       <glossterm><type>int </type><structfield>__stateful</structfield></glossterm>
       <glossdef>
        <para>
         Bu eleman da ilklendirme işlevi ile ilklendirilmelidir. Kaynak karakter kümesi durumsal ise bu elemanın değeri sıfırdan farklı yoksa sıfır olacaktır.
        </para>
       </glossdef>
      </glossentry>
      <glossentry>
       <glossterm><type>void *</type><structfield>__data</structfield></glossterm>
       <glossdef>
        <para>
         Bu eleman modüldeki dönüşüm işlevleri tarafından serbestçe kullanılabilir. <type>void *</type><structfield>__data</structfield> bir çağrıdan diğerine fazladan bilgi aktarmak için kullanılabilir. Gerekmedikçe ilklendirilmesi gerekmez. Elemana özdevimli ayrılmış bir bellek alanının göstericisi atanmışsa (büyük ihtimalle ilklendirme işlevi tarafından), kullanılacak son işlevin bu alanı serbest bırakması sağlanmalıdır. Aksi takdirde uygulama bellek kaçağına sebep olur.
        </para>
        <para>
         Bu veri yapısının bu belirtim dönüşümünün tüm kullanıcıları tarafından paylaşılmasının sağlanması önemlidir. Bu nedenle, <structfield>__data</structfield> elemanının, dönüşüm işlevinin belli bir kullanımına özgü veri içermemesi gerekir.
        </para>
       </glossdef>
      </glossentry>
     </glosslist>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-tp" xml:id="glibc-tp-gconv_step_data"><primary sortas="gconv_step_data">struct&#160;__gconv_step_data</primary></indexterm>
     <csproto type="veri türü">
      <csname><type>struct</type><function>__gconv_step_data</function></csname>
     </csproto>
     <header>&gconv.h;</header>
     <para>
      Bu veri türü, dönüşüm işlevlerinin kullanımına özel bilgileri içerir.
     </para>
     <glosslist>
      <glossentry>
       <glossterm><glossterm>
        <type>char *</type><structfield>__outbuf</structfield>
       </glossterm><glossterm>
        <type>char *</type><structfield>__outbufend</structfield>
       </glossterm></glossterm>
       <glossdef>
        <para>
         Bu alanlar dönüşüm adımında kullanılan çıktı tamponuna ilişkin veriyi içerir. <structfield>__outbuf</structfield> alanı tamponun başlangıcını, <structfield>__outbufend</structfield> alanı ise  tamponun son baytını belirtir. Dönüşüm işlevi tamponun boyutunun herşeye yeterli olduğunu varsaymamalı, ancak en azından tam bir karakter için tamponda yeterli yer olduğunu varsaymalıdır.
        </para>
        <para>
         Dönüşüm bittikten sonra, eğer dönüşüm son adımdaysa, son bayt tampona yazıldıktan sonra ne kadar mevcut çıktı olduğunu belirtmek için <structfield>__outbuf</structfield> alanı değiştirilmeli, <structfield>__outbufend</structfield> alanı değiştirilmemelidir.
        </para>
       </glossdef>
      </glossentry>
      <glossentry>
       <glossterm><type>int</type> <structfield>__is_last</structfield></glossterm>
       <glossdef>
        <para>
         Dönüşüm işlemi son adımdaysa bu alanın değeri sıfırdan farklıdır. Bu bilgi yineleme için gereklidir. Aşağıdaki dönüşüm işlevlerinin iç yapıları ile ilgili açıklamalara bakınız. Bu alan asla değiştirilmemelidir.
        </para>
       </glossdef>
      </glossentry>
      <glossentry>
       <glossterm><type>int</type> <structfield>__invocation_counter</structfield></glossterm>
       <glossdef>
        <para>
         Dönüşüm işlevi bu alanı kaç defa çağrıldığı bilgisini tutmak için kullanabilir. Bazı karakter kümeleri dönüşüm işlevinin ilk adımında bazı çıktılar üretirler. Bu alan bu ilk adımın belirlenmesi için kullanılabilir. Bu alan asla değiştirilmemelidir.
        </para>
       </glossdef>
      </glossentry>
      <glossentry>
       <glossterm><type>int</type> <structfield>__internal_use</structfield></glossterm>
       <glossdef>
        <para>
         Bu alan belli bazı durumlar için kullanılabilen alanlardan biridir. Dönüşüm işlevleri <function>mbsrtowcs</function> işlevini gerçeklemekte kullanılmışsa (yani, işlev <function>iconv</function> arayüzü üzerinden doğrudan kullanılmamışsa) bu alana sıfırdan farklı bir değer atanır.
        </para>
        <para>
         <function>mbsrtowcs</function> işlevlerinin normalde bütün metni dönüştürmek için tek tek dizgeleri dönüştürmek üzere defalarca çağrılmasına karşın <function>iconv</function> işlevlerinin metnin tamamını dönüştürmekte kullanılması gibi bir fark oluşur.
        </para>
        <para>
         Fakat bu durumda karakter kümesinin belirtimindeki bazı kuralların yerine getirilmesiyle ilgili bazı sorunlarla karşılaşılır. Bazı karakter kümeleri metnin tamamı için bir defalığına ilk adımda bir çıktı verilmesini gerektirir. Eğer metni dönüştürme işlemi <function>mbsrtowcs</function> işlevinin defalarca çağrılmasını gerektiriyorsa, ilk çağrıda bu çıktı verilmelidir. Bununla birlikte, <function>mbsrtowcs</function> işlevinin çağrıları arasında iletişim olmadığından dönüşüm işlevlerinin bu çıktıyı vermesi mümkün olmaz. Bu durum tanıtıcı sayesinde bu bilgiye erişebilen <function>iconv</function> çağrılarından farklı bir durumdur.
        </para>
        <example>
         <para>
          <structfield>__internal_use</structfield> alanı çoğunlukla <structfield>__invocation_counter</structfield> alanı ile birlikte ağağıdaki gibi kullanılır:
         </para>
         <screen>if (!data-&gt;__internal_use
     &amp;&amp; data-&gt;__invocation_counter == 0)
  /* <replaceable>İlk adımı çıktıla.</replaceable>  */
  …
</screen>
        </example>
        <para>
         Bu alan asla değiştirilmemelidir.
        </para>
       </glossdef>
      </glossentry>
      <glossentry>
       <glossterm><type>mbstate_t *</type><structfield>__statep</structfield></glossterm>
       <glossdef>
        <para>
         <structfield>__statep</structfield> alanı  <type>mbstate_t</type> (bkz. <xref linkend="glibc-Keeping-the-state"/>) türünde bir nesneye göstericidir. Durumsal bir karakter kümesi dönüşüm durumu hakkındaki bilgileri saklamak için <structfield>__statep</structfield> ile gösterilen alanı kullanmalıdır. <structfield>__statep</structfield> alanı kendini asla değiştirmemelidir.
        </para>
       </glossdef>
      </glossentry>
      <glossentry>
       <glossterm><type>mbstate_t</type> <structfield>__state</structfield></glossterm>
       <glossdef>
        <para>
         Bu alan <emphasis>asla</emphasis> doğrudan değiştirilmemelidir. İhtiyaç duyulan alanın tahsis edilmesi bu yapının bir parçası ile sağlanır.
        </para>
       </glossdef>
      </glossentry>
     </glosslist>
    </csynopsis>
   </sect2>
   <sect2><title><code>iconv</code> modül arayüzleri</title>
    <para>
     Veri yapıları hakkında bilgi edindikten sonra dönüşüm işlevlerinin açıklamalarına girilebilir. Arayüzü anlayabilmek için dönüşüm nesnelerini yükleyen C kütüphanesindeki işlevsellik hakkında biraz önbilgi vermek gerekir.
    </para>
    <para>
     Bir dönüşümün defalarca kullanıldığı duruma sıklıkla rastlanır (yazılımın çalışması esnasında aynı karakter kümesi için çok sayıda <function>iconv_open</function> çağrısı yapılması). &glibc;ndeki <function>mbsrtowcs</function> ve benzeri işlevler de aynı işlevin kullanım sayısını artıran <function>iconv</function> işlevselliğini kullanır.
     </para>
     <para>
      Dönüşümlerin böyle defalarca kullanılabilmesinden dolayı modüller her dönüşüm için tekrar yüklenmez. Modül bir kere yüklendikten sonra aynı <function>iconv</function> veya <function>mbsrtowcs</function> çağrıları defalarca yapılabilir. Bilgilerin işleve özel dönüşüm bilgileri ve dönüşüm verisi bilgileri olarak ayrılabilmesi sayesinde bu mümkün olur. Bunun yapılmasını sağlayan iki veri yapısından önceki bölümde bahsedilmişti.
     </para>
     <para>
      Bu ayrıca, modül tarafından sağlanan işlevlerin sözdiziminde ve arayüzün kendisinde de yansıtılır. Aşağıdaki isimlere sahip olması zorunlu üç işlev vardır:
     </para>
     <variablelist>
      <varlistentry>
      <term><function>gconv_init</function></term>
      <listitem>
       <para>
        <function>gconv_init</function> işlevi, dönüşüm işlevine özel veri yapısını ilklendirir. Bu nesne bu dönüşümü kullanan tüm dönüşümlerce paylaşılır ve bu nedenle, dönüşümün kendisi ile ilgili durum bilgisi burada saklanmaz. Bir modül birden fazla dönüşümü gerçekleştirebiliyorsa <function>gconv_init</function> işlevi defalarca çağrılabilir.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><function>gconv_end</function></term>
      <listitem>
       <para>
        <function>gconv_end</function> işlevi, <function>gconv_init</function> işlevi ile ayrılan tüm öz kaynakları serbest bırakmak için kullanılır. Böyle bir işlem gerekmiyorsa bu işlev tanımlanmayabilir. Modül birden fazla dönüşümü gerçekleştirebiliyorsa ve <function>gconv_init</function> işlevi her dönüşüm için aynı öz kaynakları ayırmıyorsa bu işlevi tanımlarken dikkatli olunmalıdır.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><function>gconv</function></term>
      <listitem>
       <para>
        Asıl dönüşüm işlevidir. Bir metin bloğunu dönüştürmekte kullanılır. Dönüşüm işlevlerinin bu amaca yönelik dönüşüm verisi ve <function>gconv_init</function> ile ilklendirilen dönüşüm adım bilgisi işleve aktarılmalıdır.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
    <para>
     Bu üç modül arayüz işlevi için tanımlanmış üç veri türü vardır ve bunlar arayüzü tanımlar.
    </para>
    <csynopsis>
     <indexterm linkend="glibc-tp" xml:id="glibc-tp-gconv_init_fct"><primary sortas="gconv_init_fct">(*__gconv_init_fct)</primary></indexterm>
     <csproto type="veri türü">
      <csname><type>int</type><function>(*__gconv_init_fct)</function></csname>
      <csparam><type>struct&#160;__gconv_step&#160;*</type></csparam>
     </csproto>
     <header>&gconv.h;</header>
     <para>
      Modülün gerçekleştirdiği her dönüşüm için sadece bir kere çağrılan ilklendirme işlevinin arayüzünü belirler.
     </para>
     <para>
      <type>struct&#160;__gconv_step</type> veri yapısının açıklamasında değinildiği gibi ilklendirme işlevi bu veri yapısının elemanlarını ilklendirir.
     </para>
     <glosslist>
      <glossentry>
       <glossterm><glossterm>
        <structfield>__min_needed_from</structfield>
       </glossterm><glossterm>
        <structfield>__max_needed_from</structfield>
       </glossterm><glossterm>
        <structfield>__min_needed_to</structfield>
       </glossterm><glossterm>
        <structfield>__max_needed_to</structfield>
       </glossterm></glossterm>
       <glossdef>
        <para>
         Bu elemanlar kaynak ve hedef karakter kümelerindeki bir karakteri oluşturan bayt sayısının azami ve asgari değerleri ile ilklendirilmelidir. Karakaterlerin hepsi aynı bayt sayısı ile ifade ediliyorsa azami ve asgari değerler aynı olacaktır.
        </para>
       </glossdef>
      </glossentry>
      <glossentry>
       <glossterm><structfield>__stateful</structfield></glossterm>
       <glossdef>
        <para>
         Bu eleman kaynak karaker kümesinin durumsal olması halinde sıfırdan farklı, aksi takdirde sıfır olmalıdır.
        </para>
       </glossdef>
      </glossentry>
     </glosslist>
     <para>
      İlklendirme işlevinin dönüşüm işlevi ile bilgi alışverişi yapması gerekliyse, bu iletişim <type>struct&#160;__gconv_step</type> yapısının <structfield>__data</structfield> elemanı kullanılarak yapılabilir. Ancak, bu veri tüm dönüşümlerce paylaşılacağından dönüşüm işlevleri bu veriyi değiştirmemelidir. Bunun yapılışına bir örnek:
     </para>
     <example>
      <screen>#define MIN_NEEDED_FROM         1
#define MAX_NEEDED_FROM         4
#define MIN_NEEDED_TO           4
#define MAX_NEEDED_TO           4

int
gconv_init (struct __gconv_step *step)
{
  /* <replaceable>Dönüşüm yönünü belirle.</replaceable>  */
  struct iso2022jp_data *new_data;
  enum direction dir = illegal_dir;
  enum variant var = illegal_var;
  int result;

  if (__strcasecmp (step-&gt;__from_name, "ISO-2022-JP//") == 0)
    {
      dir = from_iso2022jp;
      var = iso2022jp;
    }
  else if (__strcasecmp (step-&gt;__to_name, "ISO-2022-JP//") == 0)
    {
      dir = to_iso2022jp;
      var = iso2022jp;
    }
  else if (__strcasecmp (step-&gt;__from_name, "ISO-2022-JP-2//") == 0)
    {
      dir = from_iso2022jp;
      var = iso2022jp2;
    }
  else if (__strcasecmp (step-&gt;__to_name, "ISO-2022-JP-2//") == 0)
    {
      dir = to_iso2022jp;
      var = iso2022jp2;
    }

  result = __GCONV_NOCONV;
  if (dir != illegal_dir)
    {
      new_data = (struct iso2022jp_data *)
        malloc (sizeof (struct iso2022jp_data));

      result = __GCONV_NOMEM;
      if (new_data != NULL)
        {
          new_data-&gt;dir = dir;
          new_data-&gt;var = var;
          step-&gt;__data = new_data;

          if (dir == from_iso2022jp)
            {
              step-&gt;__min_needed_from = MIN_NEEDED_FROM;
              step-&gt;__max_needed_from = MAX_NEEDED_FROM;
              step-&gt;__min_needed_to = MIN_NEEDED_TO;
              step-&gt;__max_needed_to = MAX_NEEDED_TO;
            }
          else
            {
              step-&gt;__min_needed_from = MIN_NEEDED_TO;
              step-&gt;__max_needed_from = MAX_NEEDED_TO;
              step-&gt;__min_needed_to = MIN_NEEDED_FROM;
              step-&gt;__max_needed_to = MAX_NEEDED_FROM + 2;
            }

          /* <replaceable>Evet, bu durumsal bir kodlama.</replaceable>  */
          step-&gt;__stateful = 1;

          result = __GCONV_OK;
        }
    }

  return result;
}
</screen>
     </example>
     <para>
      İşlev önce hangi dönüşümün istendiğine bakar. Bu işlev ile ele alınan modül dört farklı dönüşümü gerçekleştirmektedir; hangisinin kullanılmak istendiği isimlere bakarak saptanabilir. Karşılaştırma daima harf büyüklüğünden bağımsız olarak yapılmalıdır.
     </para>
     <para>
      Sonra, seçilen dönüşüm için gerekli bilgileri içeren veri yapısına sıra geliyor ve buna yer ayrılıyor. <code>struct iso2022jp_data</code> yerel olarak modülün dışında tanımlandığından bu veri işlev dışında kullanılamaz. Eğer modülün desteklediği dört dönüşümün tamamı için dönüşüm istenseydi, dört veri bloğu olacaktı.
     </para>
     <para>
      İlginç olan veri nesnesinin <code>__min_</code> ve <code>__max_</code> elemanlarının ilklendirme adımıdır. Tek bir ISO-2022-JP karakteri bir bayttan dört bayta kadar uzunlukta olabilir. Bundan dolayı burada <code>MIN_NEEDED_FROM</code> ve <code>MAX_NEEDED_FROM</code> makroları kullanılmıştır. Çıktı daima dahili karakter kümesi (UCS-4) olacağından her karakter daima dört bayt uzunlukta olacaktır. Dahili karakter kümesinden ISO-2022-JP karakter kümesine dönüşüm için önceleme dizilimlerinin karakter kümeleri arasında geçiş yapmak için gerekli olduğunu hesaba katmak zorundayız. Bu nedenle, bu yön için <structfield>__max_needed_to</structfield> elemanına <code>MAX_NEEDED_FROM + 2</code> değeri atanmaktadır. Böylece diğer karakter kümesine geçiş için gerekli olan önceleme dizilimleri hesaba katılmış olur.  İki yöndeki azami değerler arasındaki dengesizlik kolayca açıklanabilir: ISO-2022-JP metin okunurken önceleme dizilimleri tek başlarına elde edilebilir (yani, önceleme diziliminin etkisi durum bilgisi içinde kaydedilmiş olacağından önceleme dizilimi bir gerçek karakterin işlenmesinde gerekli değildir).  Diğer yönde durum farklıdır.  Hangi karakter kümesinin sonra geleceği genelde bilinmediğinden durumu değiştirecek önceleme dizilimleri ileriye dönük hesaba katılamaz. Bu, önceleme dizilimlerinin sonraki karakter ile birlikte ele alınması zorunluluğu demektir. Bu nedenle karakterin gerektirdiğinden daha fazla alan gereklidir.
     </para>
     <para>
      İlklendirme işlevinin olası dönüş değerleri şunlardır:
     </para>
     <variablelist>
      <varlistentry>
       <term><code>__GCONV_OK</code></term>
       <listitem>
        <para>İlklendirme başarılı.</para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><code>__GCONV_NOCONV</code></term>
       <listitem>
        <para>
         İstenen dönüşümü bu modül desteklemiyor. Bu durum, <filename>gconv-modules</filename> dosyası hatalıysa oluşabilir.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><code>__GCONV_NOMEM</code></term>
       <listitem>
        <para>
         Ek bilginin saklanacağı bellek ayrılamadı.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </csynopsis>
    <para>
     Modül yüklenmeden işlevin çağrılması çok daha kolaydır. Çoğunlukla hiçbir şeye sebep olmaz; tamamen ihmal edilebilir.
    </para>
    <csynopsis>
     <indexterm linkend="glibc-tp" xml:id="glibc-tp-gconv_end_fct"><primary sortas="gconv_end_fct">(*__gconv_end_fct)</primary></indexterm>
     <csproto type="veri türü">
      <csname><type>void</type><function>(*__gconv_end_fct)</function></csname>
      <csparam><type>struct&#160;__gconv_step&#160;*</type></csparam>
     </csproto>
     <header>&gconv.h;</header>
     <para>
      Bu işlevin görevi ilklendirme işlevinin ayırdığı tüm öz kaynakları serbest bırakmaktır. Bu nedenle bağımsız değişken olarak nesnenin sadece <structfield>__data</structfield> elemanını kullanır. İlklendirme işlevi ile ilgili örneğe devam edilirse dönüşümü sonlandıran işlev şöyle olurdu:
     </para>
     <screen>void
gconv_end (struct __gconv_step *data)
{
  free (data-&gt;__data);
}
</screen>
    </csynopsis>
    <para>
     En önemli işlev, karmaşık karakter kümeleri için oldukça karışık olabilen dönüşüm işlevinin kendisidir. Daha fazlası gerekli olmadığından burada işlevin sadece iskeletinden bahsedilecektir.
    </para>
    <csynopsis>
     <indexterm linkend="glibc-tp" xml:id="glibc-tp-gconv_fct"><primary sortas="gconv_fct">(*__gconv_fct)</primary></indexterm>
     <csproto type="veri türü">
      <csname><type>int</type><function>(*__gconv_fct)</function></csname>
      <csparam><type>struct&#160;__gconv_step&#160;*</type></csparam>
      <csparam><type>struct&#160;__gconv_step_data&#160;*</type></csparam>
      <csparam><type>const&#160;char&#160;**</type></csparam>
      <csparam><type>const&#160;char&#160;*</type></csparam>
      <csparam><type>size_t&#160;*</type></csparam>
      <csparam><type>int</type></csparam>
     </csproto>
     <header>&gconv.h;</header>
     <para>
      Dönüşüm işlevinin çağrılmasını gerektiren iki sebep olabilir: Metni dönüştürmek ya da durumu sıfırlamak. <function>iconv</function> işlevinin açıklamasına bakılırsa boşaltma kipinin neden gerekli olduğu görülebilir. Hangi kipin seçilmiş olduğu bir tamsayı olan altıncı bağımsız değişkene bakılarak saptanır. Boşaltma kipi seçilmişse bu bağımsız değişkenin değeri sıfırdan farklı olacaktır.
     </para>
     <para>
      Çıktı tamponunun yerinin her iki kip için ortak olduğu görülür. Bu tampon hakkındaki bilgi dönüşüm adım verisinde saklanır. Bu bilgiye ilişkin gösterici işleve ikinci bağımsız değişken olarak aktarılır. <type>struct&#160;__gconv_step_data</type> yapısının açıklaması dönüşüm adım verisi hakkında daha fazla bilgi içerir.
     </para>
     <para>
      Boşaltma için ne yapılacağı kaynak karakter kümesine bağlıdır. Eğer kaynak karakter kümesi durumsal değilse bir şey yapmak gerekmez. Aksi takdirde, işlev durum nesnesini ilk duruma getirecek bir bayt dizilimini göndermek zorundadır. Bu yapıldıktan sonra dönüşüm zincirindeki diğer dönüşüm işlevlerine de bu imkan tanınmalıdır. Bu işlevi başka bir adımın izleyip izlemeyeceği ilk bağımsız değişkene adım verisinin <structfield>__is_last</structfield> elemanındaki bilgi aktarılarak saptanabilir.
     </para>
     <para>
      Metnin dönüştürüldüğü kip daha ilginçtir. Bu kipteki ilk adımda girdi tamponundaki metnin olabildiğince büyük bir kısmı dönüştürülür ve sonuç çıktı tamponunda saklanır. Girdi tamponunun başlangıcı, tamponun başlangıcını gösteren bir göstericiye gösterici olan üçüncü bağımsız değişkenden saptanır. Dördüncü bağımsız değişken tampondaki son bayttan sonraki bayta göstericidir.
     </para>
     <para>
      Dönüşüm, eğer karakter kümesi durumsal ise mevcut duruma bağlı olarak uygulanır. Durum bilgisi adım verisinin <structfield>__statep</structfield> elemanı tarafından gösterilen bir nesnede saklanır (ikinci bağımsız değişken). Girdi tamponu boşsa ya da çıktı tamponu dolmuşsa dönüşüm durdurulur. Bu durumda üçüncü bağımsız değişkendeki gösterici değişkeni son işlenen bayttan sonraki baytı göstermelidir (eğer tüm girdi tüketilmişse, bu gösterici ve dördüncü bağımsız değişken aynı değerde olur).
     </para>
     <para>
      Sonra ne yapılacağı bu adımın son adım olup olmamasına bağlıdır. Eğer bu adım son adımsa yapılacak tek şey, adım verisi yapısının <structfield>__outbuf</structfield> elemanının son yazılan bayttan sonraki baytı gösterecek şekilde güncellenmesidir. Ek olarak, beşinci bağımsız değişken tarafından gösterilen <type>size_t</type> türündeki değişken geri dönüşümsüz olarak dönüştürülen karakter sayısı (bayt sayısı değil) kadar artırılmalıdır. Bundan sonra işlev dönebilir.
     </para>
     <para>
      Eğer bu adım son adım değilse, sonraki dönüşüm işlevlerine kendi görevlerini yerine getirebilmeleri imkanı sağlanmalıdır. Bu nedenle uygun dönüşüm işlevi çağrısı yapılmalıdır. İşlevler hakkındaki bilgiler dönüşüm veri yapılarında saklanır ve ilk bağımsız değişken olarak aktarılır. Bu bilgi ve adım verisi dizilerde saklanır, bu durumda sonraki eleman her iki halde de basit olarak gösterici aritmetiği ile bulunabilir:
     </para>
     <example>
      <screen>int
gconv (struct __gconv_step *step, struct __gconv_step_data *data,
       const char **inbuf, const char *inbufend, size_t *written,
       int do_flush)
{
  struct __gconv_step *next_step = step + 1;
  struct __gconv_step_data *next_data = data + 1;
  …
</screen>
      <para>
       <code>next_step</code> göstericisi sonraki adım bilgisini içerirken, <code>next_data</code> sonraki veri kaydını içerir. Sonraki işlev çağrısı bu nedenle şöyle görünecektir:
      </para>
      <screen>  next_step-&gt;__fct (next_step, next_data, &amp;outerr, outbuf,
                    written, 0)
</screen>
     </example>
     <para>
      Fakat henüz bu yeterli değildir. İşlev çağrısı döndükten sonra dönüşüm işlevi biraz daha işlem yapmak zorunda kalabilir. İşlevin dönüş değeri <code>__GCONV_EMPTY_INPUT</code> ise, çıktı tamponunda hala yer var demektir. Girdi tamponu boş olmadıkça dönüşüm, işlevi girdi tamponunun kalanını işlemek üzere tekrar çağırır. Eğer dönüş değeri <code>__GCONV_EMPTY_INPUT</code> değilse bazı şeyler yanlış gitmiştir ve bunun kurtarılması gerekir.
     </para>
     <para>
      Dönüşüm işlevi için bir gereklilik de, girdi tamponu göstericisinin (üçüncü bağımsız değişken) daima çıktı tamponuna konulan dönüştürülmüş son karakteri göstermesidir. Dönüşümün uygulandığı adımda eğer daha alt adımları gerçekleştiren dönüşüm işlevleri hata verip durmazsa, çıktı tamponundaki karakterlerin tümü tüketilmemişse ve bu nedenle girdi tamponu göstericileri doğru konumu gösterecek duruma getirilmemişse bu zaten gerçekleşir.
     </para>
     <para>
      Girdi tamponunun düzeltilmesi, eğer girdi ve çıktı karakter kümelerindeki tüm karakterler sabit genişlikteyse kolaydır. Bu durumda, çıktı tamponunda kaç karakter kaldığı hesaplanabilir ve bu sonuçtan hareketle girdi tampon göstericisi benzer bir hesaplamayla elde edilebilir. Zor olan, karakter kümelerinin değişken genişlikte karakterler içermesi ve dönüşüm bir de durumsal ise işlemin daha da karmaşıklaşmasıdır. Bu durumlarda dönüşüm, ilk dönüşümden önceki bilinen durumdan bir daha başlatılır (gerekliyse, dönüşüm durumu sıfırlanmalı ve dönüşüm döngüsü tekrar çalıştırılmalıdır). Burada farklı olan ne kadar girdi oluşturulması gerektiğinin bilinmesi ve dönüşümün ilk işe yaramaz karakterden önce durdurulabilmesidir. Bu yapıldıktan sonra girdi tamponu göstericileri tekrar güncellenmelidir. Bundan sonra işlev dönebilir.
     </para>
     <para>
      Üstünde durulması gereken son bir şey daha var. Dönüşümün ilk çağrısında bir iletinin çıktılanması gerektiği durumlar için çağrının ilk çağrı olup olmadığının bilinmesi için dönüşüm işlevi adım verisi yapısının <structfield>__invocation_counter</structfield> elmanının değerini çağrıcıya dönmeden önce artırmalıdır. Bunun nasıl kullanıldığı hakkında daha fazla bilgi edinmek isterseniz <type>struct&#160;__gconv_step_data</type> yapısının açıklamasına bakılabilir.
     </para>
     <para>
      Dönüş değeri şunlardan biri olmalıdır:
     </para>
     <variablelist>
      <varlistentry>
       <term><code>__GCONV_EMPTY_INPUT</code></term>
       <listitem>
        <para>
         Tüm girdi tüketildi ve çıktı taponunda yer kaldı.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><code>__GCONV_FULL_OUTPUT</code></term>
       <listitem>
        <para>
         Çıktı tamponunda yer kalmadı. Bu değer son adımda alınmamışsa zincirdeki sonraki işlev çağrısında bu değere uygun işlem yapılmalıdır.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><code>__GCONV_INCOMPLETE_INPUT</code></term>
       <listitem>
        <para>
         Bozuk bir karakter dizilimi içerdiğinden girdi tamponu tüketilememiştir.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
     <example>
      <para>
       Aşağıda bir dönüşüm işlevinin çerçevesi çizilmeye çalışılmıştır. Yeni bir dönüşüm işlevi yazılacaksa, burada boş bırakılmış yerler doldurulmalıdır.
      </para>
      <screen>int
gconv (struct __gconv_step *step, struct __gconv_step_data *data,
       const char **inbuf, const char *inbufend, size_t *written,
       int do_flush)
{
  struct __gconv_step *next_step = step + 1;
  struct __gconv_step_data *next_data = data + 1;
  gconv_fct fct = next_step-&gt;__fct;
  int status;

  /* <replaceable>İşlev girdisiz çağrılmışsa bu ilk duruma getirme anlamındadır.
   * Girdinin bir kısmı işlendikten sonra bu yapılmışsa girdi atlanır.</replaceable>
   */
  if (do_flush)
    {
      status = __GCONV_OK;

      /* <replaceable>Durum nesnesini ilk duruma getiren bayt dizilimi gerekebilir.</replaceable>  */

      /* <replaceable>Varsa zincirdeki adımları yalnızca
         önceleme dizgesi başarıyla çıktılanmışsa çağır.</replaceable>  */
      if (status == __GCONV_OK &amp;&amp; ! data-&gt;__is_last)
        status = fct (next_step, next_data, NULL, NULL,
                      written, 1);
    }
  else
    {
      /* <replaceable>Gösterici değişkenlerinin ilk değerlerini sakla.</replaceable>  */
      const char *inptr = *inbuf;
      char *outbuf = data-&gt;__outbuf;
      char *outend = data-&gt;__outbufend;
      char *outptr;

      do
        {
          /* <replaceable>Bu adımın başlangıç değerini hatırla.</replaceable>  */
          inptr = *inbuf;
          /* <replaceable>Çıktı tamponu boş.</replaceable>  */
          outptr = outbuf;

          /* <replaceable>Durumsal kodlamalar için durum burada güvenceye alınmalı.</replaceable>  */

          /* <replaceable>Dönüşüm döngüsü çalıştır ve durumu uygun değere ayarla.</replaceable>  */

          /* <replaceable>Bu son adımsa, döngüden çık. Yapacak bir şey kalmamış.</replaceable>  */
          if (data-&gt;__is_last)
            {
              /* <replaceable>Kullanılabilir kaç bayt kaldı bilgisini sakla.</replaceable>  */
              data-&gt;__outbuf = outbuf;

             /* <replaceable>Geri dönüşümsüz dönüşüm yapılmışsa numarasını
                <code>*written</code>'a ekle.</replaceable>  */

             break;
           }

          /* <replaceable>Üretilen tüm çıktıyı yaz.</replaceable>  */
          if (outbuf &gt; outptr)
            {
              const char *outerr = data-&gt;__outbuf;
              int result;

              result = fct (next_step, next_data, &amp;outerr,
                            outbuf, written, 0);

              if (result != __GCONV_EMPTY_INPUT)
                {
                  if (outerr != outbuf)
                    {
                      /* <replaceable>Girdi tampon göstericisini sıfırla.
                         Burada karmaşık durumu belgele.</replaceable>  */
                      size_t nstatus;

                      /* <replaceable>Göstericileri yeniden yükle.</replaceable>  */
                      *inbuf = inptr;
                      outbuf = outptr;

                      /* <replaceable>Durum sıfırlanacaksa sıfırla.</replaceable>  */

                      /* <replaceable>Dönüşümü tekrar yap, ama bu sefer çıktı
                         tamponunun sonu <code>outerr</code> de.</replaceable>  */
                    }

                  /* <replaceable>Durumu değiştir.</replaceable>  */
                  status = result;
                }
              else
                /* <replaceable>Çıktı tamamlandı, herşey tamamsa
                   sonraki adıma geç.</replaceable>  */
                if (status == __GCONV_FULL_OUTPUT)
                  status = __GCONV_OK;
           }
        }
      while (status == __GCONV_OK);

      /* <replaceable>Bu adımın sonu.</replaceable>  */
      ++data-&gt;__invocation_counter;
    }

  return status;
}
</screen>
      </example>
     </csynopsis>
     <para>
      Yeni modül yazmak için bu kadar bilgi yeterlidir. Bunu yapmak isteyenler &glibc;nin kaynak koduna da bakabilirler. Pek çok çalışan ve en iyilenmiş örnek bulunmaktadır.
     </para>
    </sect2>
  </sect1>
 </chapter>
</part>
