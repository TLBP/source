<?xml version="1.0" encoding="UTF-8"?>
<!-- ********************************************************************
        glibc/ch06.xml,v2.36, GFDL,LGPL, NBB, 2023
     ******************************************************************** -->
<part xml:id="glibc-Character-Set-Handling">
 <title>Karakter Kümeleriyle Çalışma</title>
 <titleabbrev>Genişletilmiş karakter kümeleri desteği.</titleabbrev>
 <preliminary>
  <para>
   Bilgisayarların ilk görüldüğü zamanlarda karakter kümelerinde her karakter için altı, yedi ya da sekiz bit kullanılmıştı: Sekiz bitten (bir bayt) daha geniş karakter hiç yoktu. Bu yaklaşımın sınırlamaları latin karakter kümelerini kullanmayanlar nezdinde daha belirgin hale geldi. Bunlarda dilin karakter kümesindeki karakter sayısı için genellikle <code>2^8</code> yeterli değildir. Bu kısımda birden fazla karakter kümesini desteklemek için C kütüphanesine eklenmiş işlevsellikten söz edilecektir.
  </para>
 </preliminary>
 <chapter xml:id="glibc-Extended-Char-Intro">
  <title>Genişletilmiş Karakterlere Giriş</title>
  <para>
   Karakterlerle baytlar arasında 1:1 ilişki olan karakter kümeleri ile 1:2 den 1:4
   oranlarına kadar ilişki olan karakter kümeleri arasındaki farkları giderecek çok çeşitli çözümler vardır. Bu bölümün devamında, C kütüphanesinin bu işlevselliğini geliştirirken verilen tasarım kararlarını anlamaya yardımcı olacak bir kaç örneğe de yer verilmiştir.
  </para>
  <para>
   <indexterm linkend="glibc-cp"><primary>dahili gösterim</primary></indexterm>
   Önce dahili ve harici gösterimler arasında bir ayrım yapılması gerekir. <wordasword>Dahili gösterim</wordasword> bir yazılım tarafından bellekte tutulan metnin gösterimidir. <wordasword>Harici gösterim</wordasword> ise bazı iletişim kanalları üzerinden aktarımda ya da bunlar üzerinde saklanacak metinlerin gösterimleridir. Harici gösterime örnek olarak, bir dizinde bulunan ve okunacak ya da ayrıştırılacak dosyalar gösterilebilir.
  </para>
  <para>
   Geleneksel olarak iki gösterim arasında fark yoktur. Tek baytlık dahili ve harici gösterim aynıdır ve eşit kullanılabilirliktedir. Bu kullanılabilirlik karakter kümeleri genişledikçe ve sayıları arttıkça azalır.
  </para>
  <para>
   Dahili gösterimle ilgili aşılacak sorunlardan biri farklı karakter kümeleriyle harici olarak kodlanmış metinlerin elde edilmesidir. İki metni okuyup bazı ölçütleri kullanarak karşılaştıran bir yazılım varsa, karşılaştırma sadece metinler dahili olarak ortak bir biçemde tutulabiliyorsa yapılabilir.
  </para>
  <para>
   <indexterm linkend="glibc-cp"><primary>geniş karakter</primary></indexterm>
   Böyle bir ortak biçim (= karakter kümesi) için sekiz bit elbette artık yeterli değildir. Öyleyse en küçük öğe büyütülmelidir: <wordasword>geniş karakterler</wordasword> kullanılmalıdır. Karakter başına bir bayt yerine iki veya dört bayt kullanılması sözkonusu olacaktır. (Üç, bellek adreslemesi açısından iyi bir değer değildir ve dört bayttan fazlası da gerekmemektedir).
  </para><!--
  <para>
   As shown in some other part of this manual,
a completely new family has been created of functions that can handle wide
character texts in memory.  The most commonly used character sets for such
internal wide character representations are Unicode and ISO&nbsp;10646
(also known as UCS for Universal Character Set).  Unicode was originally
planned as a 16-bit character set; whereas, ISO&nbsp;10646 was designed to
be a 31-bit large code space.  The two standards are practically identical.
They have the same character repertoire and code table, but Unicode specifies
added semantics.  At the moment, only characters in the first <code>0x10000</code>
code positions (the so-called Basic Multilingual Plane, BMP) have been
assigned, but the assignment of more specialized characters outside this
16-bit space is already in progress.  A number of encodings have been
defined for Unicode and ISO&nbsp;10646 characters:
<span xml:id="glibc-index-UCS_002d2"></span>
<span xml:id="glibc-index-UCS_002d4"></span>
<span xml:id="glibc-index-UTF_002d8"></span>
<span xml:id="glibc-index-UTF_002d16"></span>
UCS-2 is a 16-bit word that can only represent characters
from the BMP, UCS-4 is a 32-bit word than can represent any Unicode
and ISO&nbsp;10646 character, UTF-8 is an ASCII compatible encoding where
ASCII characters are represented by ASCII bytes and non-ASCII characters
by sequences of 2-6 non-ASCII bytes, and finally UTF-16 is an extension
of UCS-2 in which pairs of certain UCS-2 words can be used to encode
non-BMP characters up to <code>0x10ffff</code>.
</para>
<para>To represent wide characters the <code>char</code> type is not suitable.  For
this reason the &isoc; standard introduces a new type that is
designed to keep one character of a wide character string.  To maintain
the similarity there is also a type corresponding to <code>int</code> for
those functions that take a single wide character.
</para>
<dl class="def">
<dt xml:id="glibc-index-wchar_005ft"><span class="category">Data type: </span><span><strong>wchar_t</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-wchar_005ft" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>This data type is used as the base type for wide character strings.
In other words, arrays of objects of this type are the equivalent of
<code>char[]</code> for multibyte character strings.  The type is defined in
<filename>stddef.h</filename>.
</para>
<para>The &isoc;90 standard, where <code>wchar_t</code> was introduced, does not
say anything specific about the representation.  It only requires that
this type is capable of storing all elements of the basic character set.
Therefore it would be legitimate to define <code>wchar_t</code> as <code>char</code>,
which might make sense for embedded systems.
</para>
<para>But in the GNU C Library <code>wchar_t</code> is always 32 bits wide and, therefore,
capable of representing all UCS-4 values and, therefore, covering all of
ISO&nbsp;10646.  Some Unix systems define <code>wchar_t</code> as a 16-bit type
and thereby follow Unicode very strictly.  This definition is perfectly
fine with the standard, but it also means that to represent all
characters from Unicode and ISO&nbsp;10646 one has to use UTF-16 surrogate
characters, which is in fact a multi-wide-character encoding.  But
resorting to multi-wide-character encoding contradicts the purpose of the
<code>wchar_t</code> type.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-wint_005ft-1"><span class="category">Data type: </span><span><strong>wint_t</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-wint_005ft-1" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para><code>wint_t</code> is a data type used for parameters and variables that
contain a single wide character.  As the name suggests this type is the
equivalent of <code>int</code> when using the normal <code>char</code> strings.  The
types <code>wchar_t</code> and <code>wint_t</code> often have the same
representation if their size is 32 bits wide but if <code>wchar_t</code> is
defined as <code>char</code> the type <code>wint_t</code> must be defined as
<code>int</code> due to the parameter promotion.
</para>
<span xml:id="glibc-index-wchar_002eh-3"></span>
<para>This type is defined in <filename>wchar.h</filename> and was introduced in
Amendment&nbsp;1 to &isoc;90.
</para></dd></dl>

<para>As there are for the <code>char</code> data type macros are available for
specifying the minimum and maximum value representable in an object of
type <code>wchar_t</code>.
</para>
<dl class="def">
<dt xml:id="glibc-index-WCHAR_005fMIN"><span class="category">Macro: </span><span><emphasis>wint_t</emphasis> <strong>WCHAR_MIN</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-WCHAR_005fMIN" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>The macro <code>WCHAR_MIN</code> evaluates to the minimum value representable
by an object of type <code>wint_t</code>.
</para>
<para>This macro was introduced in Amendment&nbsp;1 to &isoc;90.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-WCHAR_005fMAX"><span class="category">Macro: </span><span><emphasis>wint_t</emphasis> <strong>WCHAR_MAX</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-WCHAR_005fMAX" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>The macro <code>WCHAR_MAX</code> evaluates to the maximum value representable
by an object of type <code>wint_t</code>.
</para>
<para>This macro was introduced in Amendment&nbsp;1 to &isoc;90.
</para></dd></dl>

<para>Another special wide character value is the equivalent to <code>EOF</code>.
</para>
<dl class="def">
<dt xml:id="glibc-index-WEOF"><span class="category">Macro: </span><span><emphasis>wint_t</emphasis> <strong>WEOF</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-WEOF" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>The macro <code>WEOF</code> evaluates to a constant expression of type
<code>wint_t</code> whose value is different from any member of the extended
character set.
</para>
<para><code>WEOF</code> need not be the same value as <code>EOF</code> and unlike
<code>EOF</code> it also need <emphasis>not</emphasis> be negative.  In other words, sloppy
code like
</para>
<div class="example">
<pre class="example">{
  int c;
  …
  while ((c = getc (fp)) &lt; 0)
    …
}
</pre></div>

<para>has to be rewritten to use <code>WEOF</code> explicitly when wide characters
are used:
</para>
<div class="example">
<pre class="example">{
  wint_t c;
  …
  while ((c = getwc (fp)) != WEOF)
    …
}
</pre></div>

<span xml:id="glibc-index-wchar_002eh-4"></span>
<para>This macro was introduced in Amendment&nbsp;1 to &isoc;90 and is
defined in <filename>wchar.h</filename>.
</para></dd></dl>


<para>These internal representations present problems when it comes to storage
and transmittal.  Because each single wide character consists of more
than one byte, they are affected by byte-ordering.  Thus, machines with
different endianesses would see different values when accessing the same
data.  This byte ordering concern also applies for communication protocols
that are all byte-based and therefore require that the sender has to
decide about splitting the wide character in bytes.  A last (but not least
important) point is that wide characters often require more storage space
than a customized byte-oriented character set.
</para>
<span xml:id="glibc-index-multibyte-character-1"></span>
<span xml:id="glibc-index-EBCDIC"></span>
<para>For all the above reasons, an external encoding that is different from
the internal encoding is often used if the latter is UCS-2 or UCS-4.
The external encoding is byte-based and can be chosen appropriately for
the environment and for the texts to be handled.  A variety of different
character sets can be used for this external encoding (information that
will not be exhaustively presented here–instead, a description of the
major groups will suffice).  All of the ASCII-based character sets
fulfill one requirement: they are "filesystem safe."  This means that
the character <code>'/'</code> is used in the encoding <emphasis>only</emphasis> to
represent itself.  Things are a bit different for character sets like
EBCDIC (Extended Binary Coded Decimal Interchange Code, a character set
family used by IBM), but if the operating system does not understand
EBCDIC directly the parameters-to-system calls have to be converted
first anyhow.
</para>
<ul>
<li> The simplest character sets are single-byte character sets.  There can
be only up to 256 characters (for 8&nbsp;bit character sets), which is
not sufficient to cover all languages but might be sufficient to handle
a specific text.  Handling of a 8&nbsp;bit character sets is simple.  This
is not true for other kinds presented later, and therefore, the
application one uses might require the use of 8&nbsp;bit character sets.

</li><li> <span xml:id="glibc-index-ISO-2022"></span>
The ISO&nbsp;2022 standard defines a mechanism for extended character
sets where one character <emphasis>can</emphasis> be represented by more than one
byte.  This is achieved by associating a state with the text.
Characters that can be used to change the state can be embedded in the
text.  Each byte in the text might have a different interpretation in each
state.  The state might even influence whether a given byte stands for a
character on its own or whether it has to be combined with some more
bytes.

<span xml:id="glibc-index-EUC"></span>
<span xml:id="glibc-index-Shift_005fJIS"></span>
<span xml:id="glibc-index-SJIS"></span>
<para>In most uses of ISO&nbsp;2022 the defined character sets do not allow
state changes that cover more than the next character.  This has the
big advantage that whenever one can identify the beginning of the byte
sequence of a character one can interpret a text correctly.  Examples of
character sets using this policy are the various EUC character sets
(used by Sun’s operating systems, EUC-JP, EUC-KR, EUC-TW, and EUC-CN)
or Shift_JIS (SJIS, a Japanese encoding).
</para>
<para>But there are also character sets using a state that is valid for more
than one character and has to be changed by another byte sequence.
Examples for this are ISO-2022-JP, ISO-2022-KR, and ISO-2022-CN.
</para>
</li><li> <span xml:id="glibc-index-ISO-6937"></span>
Early attempts to fix 8 bit character sets for other languages using the
Roman alphabet lead to character sets like ISO&nbsp;6937.  Here bytes
representing characters like the acute accent do not produce output
themselves: one has to combine them with other characters to get the
desired result.  For example, the byte sequence <code>0xc2 0x61</code>
(non-spacing acute accent, followed by lower-case ‘a’) to get the “small
a with  acute” character.  To get the acute accent character on its own,
one has to write <code>0xc2 0x20</code> (the non-spacing acute followed by a
space).

<para>Character sets like ISO&nbsp;6937 are used in some embedded systems such
as teletex.
</para>
</li><li> <span xml:id="glibc-index-UTF_002d8-1"></span>
Instead of converting the Unicode or ISO&nbsp;10646 text used internally,
it is often also sufficient to simply use an encoding different than
UCS-2/UCS-4.  The Unicode and ISO&nbsp;10646 standards even specify such an
encoding: UTF-8.  This encoding is able to represent all of ISO&nbsp;10646 31 bits in a byte string of length one to six.

<span xml:id="glibc-index-UTF_002d7"></span>
<para>There were a few other attempts to encode ISO&nbsp;10646 such as UTF-7,
but UTF-8 is today the only encoding that should be used.  In fact, with
any luck UTF-8 will soon be the only external encoding that has to be
supported.  It proves to be universally usable and its only disadvantage
is that it favors Roman languages by making the byte string
representation of other scripts (Cyrillic, Greek, Asian scripts) longer
than necessary if using a specific character set for these scripts.
Methods like the Unicode compression scheme can alleviate these
problems.
</para></li></ul>

<para>The question remaining is: how to select the character set or encoding
to use.  The answer: you cannot decide about it yourself, it is decided
by the developers of the system or the majority of the users.  Since the
goal is interoperability one has to use whatever the other people one
works with use.  If there are no constraints, the selection is based on
the requirements the expected circle of users will have.  In other words,
if a project is expected to be used in only, say, Russia it is fine to use
KOI8-R or a similar character set.  But if at the same time people from,
say, Greece are participating one should use a character set that allows
all people to collaborate.
</para>
<para>The most widely useful solution seems to be: go with the most general
character set, namely ISO&nbsp;10646.  Use UTF-8 as the external encoding
and problems about users not being able to use their own language
adequately are a thing of the past.
</para>
<para>One final comment about the choice of the wide character representation
is necessary at this point.  We have said above that the natural choice
is using Unicode or ISO&nbsp;10646.  This is not required, but at least
encouraged, by the &isoc; standard.  The standard defines at least a
macro <code>__STDC_ISO_10646__</code> that is only defined on systems where
the <code>wchar_t</code> type encodes ISO&nbsp;10646 characters.  If this
symbol is not defined one should avoid making assumptions about the wide
character representation.  If the programmer uses only the functions
provided by the C library to handle wide character strings there should
be no compatibility problems with other systems.
</para>
<hr>
</div>
<sect xml:id="glibc-Charset-Function-Overview">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Restartable-multibyte-conversion" accesskey="n" rel="next">Restartable Multibyte Conversion Functions</a>, Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Extended-Char-Intro" accesskey="p" rel="prev">Introduction to Extended Characters</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Character-Set-Handling" accesskey="u" rel="up">Character Set Handling</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Overview-about-Character-Handling-Functions"></span><h3 class="section">6.2 Overview about Character Handling Functions</title>

<para>A Unix C&nbsp;library contains three different sets of functions in two
families to handle character set conversion.  One of the function families
(the most commonly used) is specified in the &isoc;90 standard and,
therefore, is portable even beyond the Unix world.  Unfortunately this
family is the least useful one.  These functions should be avoided
whenever possible, especially when developing libraries (as opposed to
applications).
</para>
<para>The second family of functions got introduced in the early Unix standards
(XPG2) and is still part of the latest and greatest Unix standard:
Unix&nbsp;98.  It is also the most powerful and useful set of functions.
But we will start with the functions defined in Amendment&nbsp;1 to
&isoc;90.
</para>
<hr>
</div>
<sect xml:id="glibc-Restartable-multibyte-conversion">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Non_002dreentrant-Conversion" accesskey="n" rel="next">Non-reentrant Conversion Function</a>, Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Charset-Function-Overview" accesskey="p" rel="prev">Overview about Character Handling Functions</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Character-Set-Handling" accesskey="u" rel="up">Character Set Handling</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Restartable-Multibyte-Conversion-Functions"></span><h3 class="section">6.3 Restartable Multibyte Conversion Functions</title>

<para>The &isoc; standard defines functions to convert strings from a
multibyte representation to wide character strings.  There are a number
of peculiarities:
</para>
<ul>
<li> The character set assumed for the multibyte encoding is not specified
as an argument to the functions.  Instead the character set specified by
the <code>LC_CTYPE</code> category of the current locale is used; see
<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Locale-Categories">Locale Categories</a>.

</li><li> The functions handling more than one character at a time require NUL
terminated strings as the argument (i.e., converting blocks of text
does not work unless one can add a NUL byte at an appropriate place).
The GNU C Library contains some extensions to the standard that allow
specifying a size, but basically they also expect terminated strings.
</li></ul>

<para>Despite these limitations the &isoc; functions can be used in many
contexts.  In graphical user interfaces, for instance, it is not
uncommon to have functions that require text to be displayed in a wide
character string if the text is not simple ASCII.  The text itself might
come from a file with translations and the user should decide about the
current locale, which determines the translation and therefore also the
external encoding used.  In such a situation (and many others) the
functions described here are perfect.  If more freedom while performing
the conversion is necessary take a look at the <code>iconv</code> functions
(see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Generic-Charset-Conversion">Generic Charset Conversion</a>).
</para>

<ul class="section-toc">
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Selecting-the-Conversion" accesskey="1">Selecting the conversion and its properties</a></li>
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Keeping-the-state" accesskey="2">Representing the state of the conversion</a></li>
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Converting-a-Character" accesskey="3">Converting Single Characters</a></li>
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Converting-Strings" accesskey="4">Converting Multibyte and Wide Character Strings</a></li>
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Multibyte-Conversion-Example" accesskey="5">A Complete Multibyte Conversion Example</a></li>
</ul>
<hr>
<div class="subsection" xml:id="glibc-Selecting-the-Conversion">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Keeping-the-state" accesskey="n" rel="next">Representing the state of the conversion</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Restartable-multibyte-conversion" accesskey="u" rel="up">Restartable Multibyte Conversion Functions</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Selecting-the-conversion-and-its-properties"></span><h4 class="subsection">6.3.1 Selecting the conversion and its properties</title>

<para>We already said above that the currently selected locale for the
<code>LC_CTYPE</code> category decides the conversion that is performed
by the functions we are about to describe.  Each locale uses its own
character set (given as an argument to <code>localedef</code>) and this is the
one assumed as the external multibyte encoding.  The wide character
set is always UCS-4 in the GNU C Library.
</para>
<para>A characteristic of each multibyte character set is the maximum number
of bytes that can be necessary to represent one character.  This
information is quite important when writing code that uses the
conversion functions (as shown in the examples below).
The &isoc; standard defines two macros that provide this information.
</para>

<dl class="def">
<dt xml:id="glibc-index-MB_005fLEN_005fMAX"><span class="category">Macro: </span><span><emphasis>int</emphasis> <strong>MB_LEN_MAX</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-MB_005fLEN_005fMAX" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para><code>MB_LEN_MAX</code> specifies the maximum number of bytes in the multibyte
sequence for a single character in any of the supported locales.  It is
a compile-time constant and is defined in <filename>limits.h</filename>.
<span xml:id="glibc-index-limits_002eh-1"></span>
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-MB_005fCUR_005fMAX"><span class="category">Macro: </span><span><emphasis>int</emphasis> <strong>MB_CUR_MAX</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-MB_005fCUR_005fMAX" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para><code>MB_CUR_MAX</code> expands into a positive integer expression that is the
maximum number of bytes in a multibyte character in the current locale.
The value is never greater than <code>MB_LEN_MAX</code>.  Unlike
<code>MB_LEN_MAX</code> this macro need not be a compile-time constant, and in
the GNU C Library it is not.
</para>
<span xml:id="glibc-index-stdlib_002eh-6"></span>
<para><code>MB_CUR_MAX</code> is defined in <filename>stdlib.h</filename>.
</para></dd></dl>

<para>Two different macros are necessary since strictly &isoc;90 compilers
do not allow variable length array definitions, but still it is desirable
to avoid dynamic allocation.  This incomplete piece of code shows the
problem:
</para>
<div class="example">
<pre class="example">{
  char buf[MB_LEN_MAX];
  ssize_t len = 0;

  while (! feof (fp))
    {
      fread (&amp;buf[len], 1, MB_CUR_MAX - len, fp);
      /* <span class="roman">… process</span> buf */
      len -= used;
    }
}
</pre></div>

<para>The code in the inner loop is expected to have always enough bytes in
the array <var>buf</var> to convert one multibyte character.  The array
<var>buf</var> has to be sized statically since many compilers do not allow a
variable size.  The <code>fread</code> call makes sure that <code>MB_CUR_MAX</code>
bytes are always available in <var>buf</var>.  Note that it isn’t
a problem if <code>MB_CUR_MAX</code> is not a compile-time constant.
</para>

<hr>
</div>
<div class="subsection" xml:id="glibc-Keeping-the-state">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Converting-a-Character" accesskey="n" rel="next">Converting Single Characters</a>, Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Selecting-the-Conversion" accesskey="p" rel="prev">Selecting the conversion and its properties</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Restartable-multibyte-conversion" accesskey="u" rel="up">Restartable Multibyte Conversion Functions</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Representing-the-state-of-the-conversion"></span><h4 class="subsection">6.3.2 Representing the state of the conversion</title>

<span xml:id="glibc-index-stateful"></span>
<para>In the introduction of this chapter it was said that certain character
sets use a <emphasis>stateful</emphasis> encoding.  That is, the encoded values depend
in some way on the previous bytes in the text.
</para>
<para>Since the conversion functions allow converting a text in more than one
step we must have a way to pass this information from one call of the
functions to another.
</para>
<dl class="def">
<dt xml:id="glibc-index-mbstate_005ft"><span class="category">Data type: </span><span><strong>mbstate_t</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-mbstate_005ft" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<span xml:id="glibc-index-shift-state"></span>
<para>A variable of type <code>mbstate_t</code> can contain all the information
about the <emphasis>shift state</emphasis> needed from one call to a conversion
function to another.
</para>
<span xml:id="glibc-index-wchar_002eh-5"></span>
<para><code>mbstate_t</code> is defined in <filename>wchar.h</filename>.  It was introduced in
Amendment&nbsp;1 to &isoc;90.
</para></dd></dl>

<para>To use objects of type <code>mbstate_t</code> the programmer has to define such
objects (normally as local variables on the stack) and pass a pointer to
the object to the conversion functions.  This way the conversion function
can update the object if the current multibyte character set is stateful.
</para>
<para>There is no specific function or initializer to put the state object in
any specific state.  The rules are that the object should always
represent the initial state before the first use, and this is achieved by
clearing the whole variable with code such as follows:
</para>
<div class="example">
<pre class="example">{
  mbstate_t state;
  memset (&amp;state, '\0', sizeof (state));
  /* <span class="roman">from now on <var>state</var> can be used.</span>  */
  …
}
</pre></div>

<para>When using the conversion functions to generate output it is often
necessary to test whether the current state corresponds to the initial
state.  This is necessary, for example, to decide whether to emit
escape sequences to set the state to the initial state at certain
sequence points.  Communication protocols often require this.
</para>
<dl class="def">
<dt xml:id="glibc-index-mbsinit"><span class="category">Function: </span><span><emphasis>int</emphasis> <strong>mbsinit</strong> <emphasis>(const mbstate_t *<var>ps</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-mbsinit" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Safe
| AC-Safe
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>The <code>mbsinit</code> function determines whether the state object pointed
to by <var>ps</var> is in the initial state.  If <var>ps</var> is a null pointer or
the object is in the initial state the return value is nonzero.  Otherwise
it is zero.
</para>
<span xml:id="glibc-index-wchar_002eh-6"></span>
<para><code>mbsinit</code> was introduced in Amendment&nbsp;1 to &isoc;90 and is
declared in <filename>wchar.h</filename>.
</para></dd></dl>

<para>Code using <code>mbsinit</code> often looks similar to this:
</para>
<div class="example">
<pre class="example">{
  mbstate_t state;
  memset (&amp;state, '\0', sizeof (state));
  /* <span class="roman">Use <var>state</var>.</span>  */
  …
  if (! mbsinit (&amp;state))
    {
      /* <span class="roman">Emit code to return to initial state.</span>  */
      const wchar_t empty[] = L"";
      const wchar_t *srcp = empty;
      wcsrtombs (outbuf, &amp;srcp, outbuflen, &amp;state);
    }
  …
}
</pre></div>

<para>The code to emit the escape sequence to get back to the initial state is
interesting.  The <code>wcsrtombs</code> function can be used to determine the
necessary output code (see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Converting-Strings">Converting Multibyte and Wide Character Strings</a>).  Please note that with
the GNU C Library it is not necessary to perform this extra action for the
conversion from multibyte text to wide character text since the wide
character encoding is not stateful.  But there is nothing mentioned in
any standard that prohibits making <code>wchar_t</code> use a stateful
encoding.
</para>
<hr>
</div>
<div class="subsection" xml:id="glibc-Converting-a-Character">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Converting-Strings" accesskey="n" rel="next">Converting Multibyte and Wide Character Strings</a>, Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Keeping-the-state" accesskey="p" rel="prev">Representing the state of the conversion</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Restartable-multibyte-conversion" accesskey="u" rel="up">Restartable Multibyte Conversion Functions</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Converting-Single-Characters"></span><h4 class="subsection">6.3.3 Converting Single Characters</title>

<para>The most fundamental of the conversion functions are those dealing with
single characters.  Please note that this does not always mean single
bytes.  But since there is very often a subset of the multibyte
character set that consists of single byte sequences, there are
functions to help with converting bytes.  Frequently, ASCII is a subset
of the multibyte character set.  In such a scenario, each ASCII character
stands for itself, and all other characters have at least a first byte
that is beyond the range <em class="math">0</emphasis> to <em class="math">127</emphasis>.
</para>
<dl class="def">
<dt xml:id="glibc-index-btowc"><span class="category">Function: </span><span><emphasis>wint_t</emphasis> <strong>btowc</strong> <emphasis>(int <var>c</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-btowc" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Unsafe corrupt heap lock dlopen
| AC-Unsafe corrupt lock mem fd
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>The <code>btowc</code> function (“byte to wide character”) converts a valid
single byte character <var>c</var> in the initial shift state into the wide
character equivalent using the conversion rules from the currently
selected locale of the <code>LC_CTYPE</code> category.
</para>
<para>If <code>(unsigned char) <var>c</var></code> is no valid single byte multibyte
character or if <var>c</var> is <code>EOF</code>, the function returns <code>WEOF</code>.
</para>
<para>Please note the restriction of <var>c</var> being tested for validity only in
the initial shift state.  No <code>mbstate_t</code> object is used from
which the state information is taken, and the function also does not use
any static state.
</para>
<span xml:id="glibc-index-wchar_002eh-7"></span>
<para>The <code>btowc</code> function was introduced in Amendment&nbsp;1 to &isoc;90
and is declared in <filename>wchar.h</filename>.
</para></dd></dl>

<para>Despite the limitation that the single byte value is always interpreted
in the initial state, this function is actually useful most of the time.
Most characters are either entirely single-byte character sets or they
are extensions to ASCII.  But then it is possible to write code like this
(not that this specific example is very useful):
</para>
<div class="example">
<pre class="example">wchar_t *
itow (unsigned long int val)
{
  static wchar_t buf[30];
  wchar_t *wcp = &amp;buf[29];
  *wcp = L'\0';
  while (val != 0)
  {
      *--><!--wcp = btowc ('0' + val % 10);
      val /= 10;
    }
  if (wcp == &amp;buf[29])
    *--><!--wcp = L'0';
  return wcp;
}
</pre></div>

<para>Why is it necessary to use such a complicated implementation and not
simply cast <code>'0' + val % 10</code> to a wide character?  The answer is
that there is no guarantee that one can perform this kind of arithmetic
on the character of the character set used for <code>wchar_t</code>
representation.  In other situations the bytes are not constant at
compile time and so the compiler cannot do the work.  In situations like
this, using <code>btowc</code> is required.
</para>
<para>There is also a function for the conversion in the other direction.
</para>
<dl class="def">
<dt xml:id="glibc-index-wctob"><span class="category">Function: </span><span><emphasis>int</emphasis> <strong>wctob</strong> <emphasis>(wint_t <var>c</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-wctob" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Unsafe corrupt heap lock dlopen
| AC-Unsafe corrupt lock mem fd
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>The <code>wctob</code> function (“wide character to byte”) takes as the
parameter a valid wide character.  If the multibyte representation for
this character in the initial state is exactly one byte long, the return
value of this function is this character.  Otherwise the return value is
<code>EOF</code>.
</para>
<span xml:id="glibc-index-wchar_002eh-8"></span>
<para><code>wctob</code> was introduced in Amendment&nbsp;1 to &isoc;90 and
is declared in <filename>wchar.h</filename>.
</para></dd></dl>

<para>There are more general functions to convert single characters from
multibyte representation to wide characters and vice versa.  These
functions pose no limit on the length of the multibyte representation
and they also do not require it to be in the initial state.
</para>
<dl class="def">
<dt xml:id="glibc-index-mbrtowc"><span class="category">Function: </span><span><emphasis>size_t</emphasis> <strong>mbrtowc</strong> <emphasis>(wchar_t *restrict <var>pwc</var>, const char *restrict <var>s</var>, size_t <var>n</var>, mbstate_t *restrict <var>ps</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-mbrtowc" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Unsafe race:mbrtowc/!ps
| AS-Unsafe corrupt heap lock dlopen
| AC-Unsafe corrupt lock mem fd
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<span xml:id="glibc-index-stateful-1"></span>
<para>The <code>mbrtowc</code> function (“multibyte restartable to wide
character”) converts the next multibyte character in the string pointed
to by <var>s</var> into a wide character and stores it in the location
pointed to by <var>pwc</var>.  The conversion is performed according
to the locale currently selected for the <code>LC_CTYPE</code> category.  If
the conversion for the character set used in the locale requires a state,
the multibyte string is interpreted in the state represented by the
object pointed to by <var>ps</var>.  If <var>ps</var> is a null pointer, a static,
internal state variable used only by the <code>mbrtowc</code> function is
used.
</para>
<para>If the next multibyte character corresponds to the null wide character,
the return value of the function is <em class="math">0</emphasis> and the state object is
afterwards in the initial state.  If the next <var>n</var> or fewer bytes
form a correct multibyte character, the return value is the number of
bytes starting from <var>s</var> that form the multibyte character.  The
conversion state is updated according to the bytes consumed in the
conversion.  In both cases the wide character (either the <code>L'\0'</code>
or the one found in the conversion) is stored in the string pointed to
by <var>pwc</var> if <var>pwc</var> is not null.
</para>
<para>If the first <var>n</var> bytes of the multibyte string possibly form a valid
multibyte character but there are more than <var>n</var> bytes needed to
complete it, the return value of the function is <code>(size_t) -2</code> and
no value is stored in <code>*<var>pwc</var></code>.  The conversion state is
updated and all <var>n</var> input bytes are consumed and should not be
submitted again.  Please note that this can happen even if <var>n</var> has a
value greater than or equal to <code>MB_CUR_MAX</code> since the input might
contain redundant shift sequences.
</para>
<para>If the first <code>n</code> bytes of the multibyte string cannot possibly form
a valid multibyte character, no value is stored, the global variable
<code>errno</code> is set to the value <code>EILSEQ</code>, and the function returns
<code>(size_t) -1</code>.  The conversion state is afterwards undefined.
</para>
<para>As specified, the <code>mbrtowc</code> function could deal with multibyte
sequences which contain embedded null bytes (which happens in Unicode
encodings such as UTF-16), but the GNU C Library does not support such
multibyte encodings.  When encountering a null input byte, the function
will either return zero, or return <code>(size_t) -1)</code> and report a
<code>EILSEQ</code> error.  The <code>iconv</code> function can be used for
converting between arbitrary encodings.  See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Generic-Conversion-Interface">Generic Character Set Conversion Interface</a>.
</para>
<span xml:id="glibc-index-wchar_002eh-9"></span>
<para><code>mbrtowc</code> was introduced in Amendment&nbsp;1 to &isoc;90 and
is declared in <filename>wchar.h</filename>.
</para></dd></dl>

<para>A function that copies a multibyte string into a wide character string
while at the same time converting all lowercase characters into
uppercase could look like this:
</para>
<div class="example">
<pre class="example">wchar_t *
mbstouwcs (const char *s)
{
  /* <span class="roman">Include the null terminator in the conversion.</span> */
  size_t len = strlen (s) + 1;
  wchar_t *result = reallocarray (NULL, len, sizeof (wchar_t));
  if (result == NULL)
    return NULL;

  wchar_t *wcp = result;
  mbstate_t state;
  memset (&amp;state, '\0', sizeof (state));

  while (true)
    {
      wchar_t wc;
      size_t nbytes = mbrtowc (&amp;wc, s, len, &amp;state);
      if (nbytes == 0)
        {
          /* <span class="roman">Terminate the result string.</span> */
          *wcp = L'\0';
          break;
        }
      else if (nbytes == (size_t) -2)
        {
          /* <span class="roman">Truncated input string.</span> */
          errno = EILSEQ;
          free (result);
          return NULL;
        }
      else if (nbytes == (size_t) -1)
        {
          /* <span class="roman">Some other error (including EILSEQ).</span> */
          free (result);
          return NULL;
        }
      else
        {
          /* <span class="roman">A character was converted.</span> */
          *wcp++ = towupper (wc);
          len -= nbytes;
          s += nbytes;
        }
    }
  return result;
}
</pre></div>

<para>In the inner loop, a single wide character is stored in <code>wc</code>, and
the number of consumed bytes is stored in the variable <code>nbytes</code>.
If the conversion is successful, the uppercase variant of the wide
character is stored in the <code>result</code> array and the pointer to the
input string and the number of available bytes is adjusted.  If the
<code>mbrtowc</code> function returns zero, the null input byte has not been
converted, so it must be stored explicitly in the result.
</para>
<para>The above code uses the fact that there can never be more wide
characters in the converted result than there are bytes in the multibyte
input string.  This method yields a pessimistic guess about the size of
the result, and if many wide character strings have to be constructed
this way or if the strings are long, the extra memory required to be
allocated because the input string contains multibyte characters might
be significant.  The allocated memory block can be resized to the
correct size before returning it, but a better solution might be to
allocate just the right amount of space for the result right away.
Unfortunately there is no function to compute the length of the wide
character string directly from the multibyte string.  There is, however,
a function that does part of the work.
</para>
<dl class="def">
<dt xml:id="glibc-index-mbrlen"><span class="category">Function: </span><span><emphasis>size_t</emphasis> <strong>mbrlen</strong> <emphasis>(const char *restrict <var>s</var>, size_t <var>n</var>, mbstate_t *<var>ps</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-mbrlen" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Unsafe race:mbrlen/!ps
| AS-Unsafe corrupt heap lock dlopen
| AC-Unsafe corrupt lock mem fd
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>The <code>mbrlen</code> function (“multibyte restartable length”) computes
the number of at most <var>n</var> bytes starting at <var>s</var>, which form the
next valid and complete multibyte character.
</para>
<para>If the next multibyte character corresponds to the NUL wide character,
the return value is <em class="math">0</emphasis>.  If the next <var>n</var> bytes form a valid
multibyte character, the number of bytes belonging to this multibyte
character byte sequence is returned.
</para>
<para>If the first <var>n</var> bytes possibly form a valid multibyte
character but the character is incomplete, the return value is
<code>(size_t) -2</code>.  Otherwise the multibyte character sequence is invalid
and the return value is <code>(size_t) -1</code>.
</para>
<para>The multibyte sequence is interpreted in the state represented by the
object pointed to by <var>ps</var>.  If <var>ps</var> is a null pointer, a state
object local to <code>mbrlen</code> is used.
</para>
<span xml:id="glibc-index-wchar_002eh-10"></span>
<para><code>mbrlen</code> was introduced in Amendment&nbsp;1 to &isoc;90 and
is declared in <filename>wchar.h</filename>.
</para></dd></dl>

<para>The attentive reader now will note that <code>mbrlen</code> can be implemented
as
</para>
<div class="example">
<pre class="example">mbrtowc (NULL, s, n, ps != NULL ? ps : &amp;internal)
</pre></div>

<para>This is true and in fact is mentioned in the official specification.
How can this function be used to determine the length of the wide
character string created from a multibyte character string?  It is not
directly usable, but we can define a function <code>mbslen</code> using it:
</para>
<div class="example">
<pre class="example">size_t
mbslen (const char *s)
{
  mbstate_t state;
  size_t result = 0;
  size_t nbytes;
  memset (&amp;state, '\0', sizeof (state));
  while ((nbytes = mbrlen (s, MB_LEN_MAX, &amp;state)) &gt; 0)
    {
      if (nbytes &gt;= (size_t) -2)
        /* <span class="roman">Something is wrong.</span>  */
        return (size_t) -1;
      s += nbytes;
      ++result;
    }
  return result;
}
</pre></div>

<para>This function simply calls <code>mbrlen</code> for each multibyte character
in the string and counts the number of function calls.  Please note that
we here use <code>MB_LEN_MAX</code> as the size argument in the <code>mbrlen</code>
call.  This is acceptable since a) this value is larger than the length of
the longest multibyte character sequence and b) we know that the string
<var>s</var> ends with a NUL byte, which cannot be part of any other multibyte
character sequence but the one representing the NUL wide character.
Therefore, the <code>mbrlen</code> function will never read invalid memory.
</para>
<para>Now that this function is available (just to make this clear, this
function is <emphasis>not</emphasis> part of the GNU C Library) we can compute the
number of wide characters required to store the converted multibyte
character string <var>s</var> using
</para>
<div class="example">
<pre class="example">wcs_bytes = (mbslen (s) + 1) * sizeof (wchar_t);
</pre></div>

<para>Please note that the <code>mbslen</code> function is quite inefficient.  The
implementation of <code>mbstouwcs</code> with <code>mbslen</code> would have to
perform the conversion of the multibyte character input string twice, and
this conversion might be quite expensive.  So it is necessary to think
about the consequences of using the easier but imprecise method before
doing the work twice.
</para>
<dl class="def">
<dt xml:id="glibc-index-wcrtomb"><span class="category">Function: </span><span><emphasis>size_t</emphasis> <strong>wcrtomb</strong> <emphasis>(char *restrict <var>s</var>, wchar_t <var>wc</var>, mbstate_t *restrict <var>ps</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-wcrtomb" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Unsafe race:wcrtomb/!ps
| AS-Unsafe corrupt heap lock dlopen
| AC-Unsafe corrupt lock mem fd
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>The <code>wcrtomb</code> function (“wide character restartable to
multibyte”) converts a single wide character into a multibyte string
corresponding to that wide character.
</para>
<para>If <var>s</var> is a null pointer, the function resets the state stored in
the object pointed to by <var>ps</var> (or the internal <code>mbstate_t</code>
object) to the initial state.  This can also be achieved by a call like
this:
</para>
<div class="example">
<pre class="example">wcrtombs (temp_buf, L'\0', ps)
</pre></div>

<para>since, if <var>s</var> is a null pointer, <code>wcrtomb</code> performs as if it
writes into an internal buffer, which is guaranteed to be large enough.
</para>
<para>If <var>wc</var> is the NUL wide character, <code>wcrtomb</code> emits, if
necessary, a shift sequence to get the state <var>ps</var> into the initial
state followed by a single NUL byte, which is stored in the string
<var>s</var>.
</para>
<para>Otherwise a byte sequence (possibly including shift sequences) is written
into the string <var>s</var>.  This only happens if <var>wc</var> is a valid wide
character (i.e., it has a multibyte representation in the character set
selected by locale of the <code>LC_CTYPE</code> category).  If <var>wc</var> is no
valid wide character, nothing is stored in the strings <var>s</var>,
<code>errno</code> is set to <code>EILSEQ</code>, the conversion state in <var>ps</var>
is undefined and the return value is <code>(size_t) -1</code>.
</para>
<para>If no error occurred the function returns the number of bytes stored in
the string <var>s</var>.  This includes all bytes representing shift
sequences.
</para>
<para>One word about the interface of the function: there is no parameter
specifying the length of the array <var>s</var>, so the caller has to make sure
that there is enough space available, otherwise buffer overruns can occur.
This version of the GNU C Library does not assume that <var>s</var> is at least
<var>MB_CUR_MAX</var> bytes long, but programs that need to run on GNU C Library
versions that have this assumption documented in the manual must comply
with this limit.
</para>
<span xml:id="glibc-index-wchar_002eh-11"></span>
<para><code>wcrtomb</code> was introduced in Amendment&nbsp;1 to &isoc;90 and is
declared in <filename>wchar.h</filename>.
</para></dd></dl>

<para>Using <code>wcrtomb</code> is as easy as using <code>mbrtowc</code>.  The following
example appends a wide character string to a multibyte character string.
Again, the code is not really useful (or correct), it is simply here to
demonstrate the use and some problems.
</para>
<div class="example">
<pre class="example">char *
mbscatwcs (char *s, size_t len, const wchar_t *ws)
{
  mbstate_t state;
  /* <span class="roman">Find the end of the existing string.</span>  */
  char *wp = strchr (s, '\0');
  len -= wp - s;
  memset (&amp;state, '\0', sizeof (state));
  do
    {
      size_t nbytes;
      if (len &lt; MB_CUR_LEN)
        {
          /* <span class="roman">We cannot guarantee that the next</span>
             <span class="roman">character fits into the buffer, so</span>
             <span class="roman">return an error.</span>  */
          errno = E2BIG;
          return NULL;
        }
      nbytes = wcrtomb (wp, *ws, &amp;state);
      if (nbytes == (size_t) -1)
        /* <span class="roman">Error in the conversion.</span>  */
        return NULL;
      len -= nbytes;
      wp += nbytes;
    }
  while (*ws++ != L'\0');
  return s;
}
</pre></div>

<para>First the function has to find the end of the string currently in the
array <var>s</var>.  The <code>strchr</code> call does this very efficiently since a
requirement for multibyte character representations is that the NUL byte
is never used except to represent itself (and in this context, the end
of the string).
</para>
<para>After initializing the state object the loop is entered where the first
task is to make sure there is enough room in the array <var>s</var>.  We
abort if there are not at least <code>MB_CUR_LEN</code> bytes available.  This
is not always optimal but we have no other choice.  We might have less
than <code>MB_CUR_LEN</code> bytes available but the next multibyte character
might also be only one byte long.  At the time the <code>wcrtomb</code> call
returns it is too late to decide whether the buffer was large enough.  If
this solution is unsuitable, there is a very slow but more accurate
solution.
</para>
<div class="example">
<pre class="example">  …
  if (len &lt; MB_CUR_LEN)
    {
      mbstate_t temp_state;
      memcpy (&amp;temp_state, &amp;state, sizeof (state));
      if (wcrtomb (NULL, *ws, &amp;temp_state) &gt; len)
        {
          /* <span class="roman">We cannot guarantee that the next</span>
             <span class="roman">character fits into the buffer, so</span>
             <span class="roman">return an error.</span>  */
          errno = E2BIG;
          return NULL;
        }
    }
  …
</pre></div>

<para>Here we perform the conversion that might overflow the buffer so that
we are afterwards in the position to make an exact decision about the
buffer size.  Please note the <code>NULL</code> argument for the destination
buffer in the new <code>wcrtomb</code> call; since we are not interested in the
converted text at this point, this is a nice way to express this.  The
most unusual thing about this piece of code certainly is the duplication
of the conversion state object, but if a change of the state is necessary
to emit the next multibyte character, we want to have the same shift state
change performed in the real conversion.  Therefore, we have to preserve
the initial shift state information.
</para>
<para>There are certainly many more and even better solutions to this problem.
This example is only provided for educational purposes.
</para>
<hr>
</div>
<div class="subsection" xml:id="glibc-Converting-Strings">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Multibyte-Conversion-Example" accesskey="n" rel="next">A Complete Multibyte Conversion Example</a>, Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Converting-a-Character" accesskey="p" rel="prev">Converting Single Characters</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Restartable-multibyte-conversion" accesskey="u" rel="up">Restartable Multibyte Conversion Functions</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Converting-Multibyte-and-Wide-Character-Strings"></span><h4 class="subsection">6.3.4 Converting Multibyte and Wide Character Strings</title>

<para>The functions described in the previous section only convert a single
character at a time.  Most operations to be performed in real-world
programs include strings and therefore the &isoc; standard also
defines conversions on entire strings.  However, the defined set of
functions is quite limited; therefore, the GNU C Library contains a few
extensions that can help in some important situations.
</para>
<dl class="def">
<dt xml:id="glibc-index-mbsrtowcs"><span class="category">Function: </span><span><emphasis>size_t</emphasis> <strong>mbsrtowcs</strong> <emphasis>(wchar_t *restrict <var>dst</var>, const char **restrict <var>src</var>, size_t <var>len</var>, mbstate_t *restrict <var>ps</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-mbsrtowcs" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Unsafe race:mbsrtowcs/!ps
| AS-Unsafe corrupt heap lock dlopen
| AC-Unsafe corrupt lock mem fd
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>The <code>mbsrtowcs</code> function (“multibyte string restartable to wide
character string”) converts the NUL-terminated multibyte character
string at <code>*<var>src</var></code> into an equivalent wide character string,
including the NUL wide character at the end.  The conversion is started
using the state information from the object pointed to by <var>ps</var> or
from an internal object of <code>mbsrtowcs</code> if <var>ps</var> is a null
pointer.  Before returning, the state object is updated to match the state
after the last converted character.  The state is the initial state if the
terminating NUL byte is reached and converted.
</para>
<para>If <var>dst</var> is not a null pointer, the result is stored in the array
pointed to by <var>dst</var>; otherwise, the conversion result is not
available since it is stored in an internal buffer.
</para>
<para>If <var>len</var> wide characters are stored in the array <var>dst</var> before
reaching the end of the input string, the conversion stops and <var>len</var>
is returned.  If <var>dst</var> is a null pointer, <var>len</var> is never checked.
</para>
<para>Another reason for a premature return from the function call is if the
input string contains an invalid multibyte sequence.  In this case the
global variable <code>errno</code> is set to <code>EILSEQ</code> and the function
returns <code>(size_t) -1</code>.
</para>

<para>In all other cases the function returns the number of wide characters
converted during this call.  If <var>dst</var> is not null, <code>mbsrtowcs</code>
stores in the pointer pointed to by <var>src</var> either a null pointer (if
the NUL byte in the input string was reached) or the address of the byte
following the last converted multibyte character.
</para>
<para>Like <code>mbstowcs</code> the <var>dst</var> parameter may be a null pointer and
the function can be used to count the number of wide characters that
would be required.
</para>
<span xml:id="glibc-index-wchar_002eh-12"></span>
<para><code>mbsrtowcs</code> was introduced in Amendment&nbsp;1 to &isoc;90 and is
declared in <filename>wchar.h</filename>.
</para></dd></dl>

<para>The definition of the <code>mbsrtowcs</code> function has one important
limitation.  The requirement that <var>dst</var> has to be a NUL-terminated
string provides problems if one wants to convert buffers with text.  A
buffer is not normally a collection of NUL-terminated strings but instead a
continuous collection of lines, separated by newline characters.  Now
assume that a function to convert one line from a buffer is needed.  Since
the line is not NUL-terminated, the source pointer cannot directly point
into the unmodified text buffer.  This means, either one inserts the NUL
byte at the appropriate place for the time of the <code>mbsrtowcs</code>
function call (which is not doable for a read-only buffer or in a
multi-threaded application) or one copies the line in an extra buffer
where it can be terminated by a NUL byte.  Note that it is not in general
possible to limit the number of characters to convert by setting the
parameter <var>len</var> to any specific value.  Since it is not known how
many bytes each multibyte character sequence is in length, one can only
guess.
</para>
<span xml:id="glibc-index-stateful-2"></span>
<para>There is still a problem with the method of NUL-terminating a line right
after the newline character, which could lead to very strange results.
As said in the description of the <code>mbsrtowcs</code> function above, the
conversion state is guaranteed to be in the initial shift state after
processing the NUL byte at the end of the input string.  But this NUL
byte is not really part of the text (i.e., the conversion state after
the newline in the original text could be something different than the
initial shift state and therefore the first character of the next line
is encoded using this state).  But the state in question is never
accessible to the user since the conversion stops after the NUL byte
(which resets the state).  Most stateful character sets in use today
require that the shift state after a newline be the initial state–but
this is not a strict guarantee.  Therefore, simply NUL-terminating a
piece of a running text is not always an adequate solution and,
therefore, should never be used in generally used code.
</para>
<para>The generic conversion interface (see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Generic-Charset-Conversion">Generic Charset Conversion</a>)
does not have this limitation (it simply works on buffers, not
strings), and the GNU C Library contains a set of functions that take
additional parameters specifying the maximal number of bytes that are
consumed from the input string.  This way the problem of
<code>mbsrtowcs</code>’s example above could be solved by determining the line
length and passing this length to the function.
</para>
<dl class="def">
<dt xml:id="glibc-index-wcsrtombs"><span class="category">Function: </span><span><emphasis>size_t</emphasis> <strong>wcsrtombs</strong> <emphasis>(char *restrict <var>dst</var>, const wchar_t **restrict <var>src</var>, size_t <var>len</var>, mbstate_t *restrict <var>ps</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-wcsrtombs" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Unsafe race:wcsrtombs/!ps
| AS-Unsafe corrupt heap lock dlopen
| AC-Unsafe corrupt lock mem fd
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>The <code>wcsrtombs</code> function (“wide character string restartable to
multibyte string”) converts the NUL-terminated wide character string at
<code>*<var>src</var></code> into an equivalent multibyte character string and
stores the result in the array pointed to by <var>dst</var>.  The NUL wide
character is also converted.  The conversion starts in the state
described in the object pointed to by <var>ps</var> or by a state object
local to <code>wcsrtombs</code> in case <var>ps</var> is a null pointer.  If
<var>dst</var> is a null pointer, the conversion is performed as usual but the
result is not available.  If all characters of the input string were
successfully converted and if <var>dst</var> is not a null pointer, the
pointer pointed to by <var>src</var> gets assigned a null pointer.
</para>
<para>If one of the wide characters in the input string has no valid multibyte
character equivalent, the conversion stops early, sets the global
variable <code>errno</code> to <code>EILSEQ</code>, and returns <code>(size_t) -1</code>.
</para>
<para>Another reason for a premature stop is if <var>dst</var> is not a null
pointer and the next converted character would require more than
<var>len</var> bytes in total to the array <var>dst</var>.  In this case (and if
<var>dst</var> is not a null pointer) the pointer pointed to by <var>src</var> is
assigned a value pointing to the wide character right after the last one
successfully converted.
</para>
<para>Except in the case of an encoding error the return value of the
<code>wcsrtombs</code> function is the number of bytes in all the multibyte
character sequences which were or would have been (if <var>dst</var> was
not a null) stored in <var>dst</var>.  Before returning, the state in the
object pointed to by <var>ps</var> (or the internal object in case <var>ps</var>
is a null pointer) is updated to reflect the state after the last
conversion.  The state is the initial shift state in case the
terminating NUL wide character was converted.
</para>
<span xml:id="glibc-index-wchar_002eh-13"></span>
<para>The <code>wcsrtombs</code> function was introduced in Amendment&nbsp;1 to
&isoc;90 and is declared in <filename>wchar.h</filename>.
</para></dd></dl>

<para>The restriction mentioned above for the <code>mbsrtowcs</code> function applies
here also.  There is no possibility of directly controlling the number of
input characters.  One has to place the NUL wide character at the correct
place or control the consumed input indirectly via the available output
array size (the <var>len</var> parameter).
</para>
<dl class="def">
<dt xml:id="glibc-index-mbsnrtowcs"><span class="category">Function: </span><span><emphasis>size_t</emphasis> <strong>mbsnrtowcs</strong> <emphasis>(wchar_t *restrict <var>dst</var>, const char **restrict <var>src</var>, size_t <var>nmc</var>, size_t <var>len</var>, mbstate_t *restrict <var>ps</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-mbsnrtowcs" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Unsafe race:mbsnrtowcs/!ps
| AS-Unsafe corrupt heap lock dlopen
| AC-Unsafe corrupt lock mem fd
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>The <code>mbsnrtowcs</code> function is very similar to the <code>mbsrtowcs</code>
function.  All the parameters are the same except for <var>nmc</var>, which is
new.  The return value is the same as for <code>mbsrtowcs</code>.
</para>
<para>This new parameter specifies how many bytes at most can be used from the
multibyte character string.  In other words, the multibyte character
string <code>*<var>src</var></code> need not be NUL-terminated.  But if a NUL byte
is found within the <var>nmc</var> first bytes of the string, the conversion
stops there.
</para>
<para>Like <code>mbstowcs</code> the <var>dst</var> parameter may be a null pointer and
the function can be used to count the number of wide characters that
would be required.
</para>
<para>This function is a GNU extension.  It is meant to work around the
problems mentioned above.  Now it is possible to convert a buffer with
multibyte character text piece by piece without having to care about
inserting NUL bytes and the effect of NUL bytes on the conversion state.
</para></dd></dl>

<para>A function to convert a multibyte string into a wide character string
and display it could be written like this (this is not a really useful
example):
</para>
<div class="example">
<pre class="example">void
showmbs (const char *src, FILE *fp)
{
  mbstate_t state;
  int cnt = 0;
  memset (&amp;state, '\0', sizeof (state));
  while (1)
    {
      wchar_t linebuf[100];
      const char *endp = strchr (src, '\n');
      size_t n;

      /* <span class="roman">Exit if there is no more line.</span>  */
      if (endp == NULL)
        break;

      n = mbsnrtowcs (linebuf, &amp;src, endp - src, 99, &amp;state);
      linebuf[n] = L'\0';
      fprintf (fp, "line %d: \"%S\"\n", linebuf);
    }
}
</pre></div>

<para>There is no problem with the state after a call to <code>mbsnrtowcs</code>.
Since we don’t insert characters in the strings that were not in there
right from the beginning and we use <var>state</var> only for the conversion
of the given buffer, there is no problem with altering the state.
</para>
<dl class="def">
<dt xml:id="glibc-index-wcsnrtombs"><span class="category">Function: </span><span><emphasis>size_t</emphasis> <strong>wcsnrtombs</strong> <emphasis>(char *restrict <var>dst</var>, const wchar_t **restrict <var>src</var>, size_t <var>nwc</var>, size_t <var>len</var>, mbstate_t *restrict <var>ps</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-wcsnrtombs" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Unsafe race:wcsnrtombs/!ps
| AS-Unsafe corrupt heap lock dlopen
| AC-Unsafe corrupt lock mem fd
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>The <code>wcsnrtombs</code> function implements the conversion from wide
character strings to multibyte character strings.  It is similar to
<code>wcsrtombs</code> but, just like <code>mbsnrtowcs</code>, it takes an extra
parameter, which specifies the length of the input string.
</para>
<para>No more than <var>nwc</var> wide characters from the input string
<code>*<var>src</var></code> are converted.  If the input string contains a NUL
wide character in the first <var>nwc</var> characters, the conversion stops at
this place.
</para>
<para>The <code>wcsnrtombs</code> function is a GNU extension and just like
<code>mbsnrtowcs</code> helps in situations where no NUL-terminated input
strings are available.
</para></dd></dl>


<hr>
</div>
<div class="subsection" xml:id="glibc-Multibyte-Conversion-Example">
<div class="header">
<para>
Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Converting-Strings" accesskey="p" rel="prev">Converting Multibyte and Wide Character Strings</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Restartable-multibyte-conversion" accesskey="u" rel="up">Restartable Multibyte Conversion Functions</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-A-Complete-Multibyte-Conversion-Example"></span><h4 class="subsection">6.3.5 A Complete Multibyte Conversion Example</title>

<para>The example programs given in the last sections are only brief and do
not contain all the error checking, etc.  Presented here is a complete
and documented example.  It features the <code>mbrtowc</code> function but it
should be easy to derive versions using the other functions.
</para>
<div class="example">
<pre class="example">int
file_mbsrtowcs (int input, int output)
{
  /* <span class="roman">Note the use of <code>MB_LEN_MAX</code>.</span>
     <span class="roman"><code>MB_CUR_MAX</code> cannot portably be used here.</span>  */
  char buffer[BUFSIZ + MB_LEN_MAX];
  mbstate_t state;
  int filled = 0;
  int eof = 0;

  /* <span class="roman">Initialize the state.</span>  */
  memset (&amp;state, '\0', sizeof (state));

  while (!eof)
    {
      ssize_t nread;
      ssize_t nwrite;
      char *inp = buffer;
      wchar_t outbuf[BUFSIZ];
      wchar_t *outp = outbuf;

      /* <span class="roman">Fill up the buffer from the input file.</span>  */
      nread = read (input, buffer + filled, BUFSIZ);
      if (nread &lt; 0)
        {
          perror ("read");
          return 0;
        }
      /* <span class="roman">If we reach end of file, make a note to read no more.</span> */
      if (nread == 0)
        eof = 1;

      /* <span class="roman"><code>filled</code> is now the number of bytes in <code>buffer</code>.</span> */
      filled += nread;

      /* <span class="roman">Convert those bytes to wide characters–as many as we can.</span> */
      while (1)
        {
          size_t thislen = mbrtowc (outp, inp, filled, &amp;state);
          /* <span class="roman">Stop converting at invalid character;</span>
             <span class="roman">this can mean we have read just the first part</span>
             <span class="roman">of a valid character.</span>  */
          if (thislen == (size_t) -1)
            break;
          /* <span class="roman">We want to handle embedded NUL bytes</span>
             <span class="roman">but the return value is 0.  Correct this.</span>  */
          if (thislen == 0)
            thislen = 1;
          /* <span class="roman">Advance past this character.</span> */
          inp += thislen;
          filled -= thislen;
          ++outp;
        }

      /* <span class="roman">Write the wide characters we just made.</span>  */
      nwrite = write (output, outbuf,
                      (outp - outbuf) * sizeof (wchar_t));
      if (nwrite &lt; 0)
        {
          perror ("write");
          return 0;
        }

      /* <span class="roman">See if we have a <emphasis>real</emphasis> invalid character.</span> */
      if ((eof &amp;&amp; filled &gt; 0) || filled &gt;= MB_CUR_MAX)
        {
          error (0, 0, "invalid multibyte character");
          return 0;
        }

      /* <span class="roman">If any characters must be carried forward,</span>
         <span class="roman">put them at the beginning of <code>buffer</code>.</span> */
      if (filled &gt; 0)
        memmove (buffer, inp, filled);
    }

  return 1;
}
</pre></div>


<hr>
</div>
</div>
<sect xml:id="glibc-Non_002dreentrant-Conversion">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Generic-Charset-Conversion" accesskey="n" rel="next">Generic Charset Conversion</a>, Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Restartable-multibyte-conversion" accesskey="p" rel="prev">Restartable Multibyte Conversion Functions</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Character-Set-Handling" accesskey="u" rel="up">Character Set Handling</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Non_002dreentrant-Conversion-Function"></span><h3 class="section">6.4 Non-reentrant Conversion Function</title>

<para>The functions described in the previous chapter are defined in
Amendment&nbsp;1 to &isoc;90, but the original &isoc;90 standard
also contained functions for character set conversion.  The reason that
these original functions are not described first is that they are almost
entirely useless.
</para>
<para>The problem is that all the conversion functions described in the
original &isoc;90 use a local state.  Using a local state implies that
multiple conversions at the same time (not only when using threads)
cannot be done, and that you cannot first convert single characters and
then strings since you cannot tell the conversion functions which state
to use.
</para>
<para>These original functions are therefore usable only in a very limited set
of situations.  One must complete converting the entire string before
starting a new one, and each string/text must be converted with the same
function (there is no problem with the library itself; it is guaranteed
that no library function changes the state of any of these functions).
<strong>For the above reasons it is highly requested that the functions
described in the previous section be used in place of non-reentrant
conversion functions.</strong>
</para>

<ul class="section-toc">
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Non_002dreentrant-Character-Conversion" accesskey="1">Non-reentrant Conversion of Single Characters</a></li>
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Non_002dreentrant-String-Conversion" accesskey="2">Non-reentrant Conversion of Strings</a></li>
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Shift-State" accesskey="3">States in Non-reentrant Functions</a></li>
</ul>
<hr>
<div class="subsection" xml:id="glibc-Non_002dreentrant-Character-Conversion">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Non_002dreentrant-String-Conversion" accesskey="n" rel="next">Non-reentrant Conversion of Strings</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Non_002dreentrant-Conversion" accesskey="u" rel="up">Non-reentrant Conversion Function</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Non_002dreentrant-Conversion-of-Single-Characters"></span><h4 class="subsection">6.4.1 Non-reentrant Conversion of Single Characters</title>

<dl class="def">
<dt xml:id="glibc-index-mbtowc"><span class="category">Function: </span><span><emphasis>int</emphasis> <strong>mbtowc</strong> <emphasis>(wchar_t *restrict <var>result</var>, const char *restrict <var>string</var>, size_t <var>size</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-mbtowc" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Unsafe race
| AS-Unsafe corrupt heap lock dlopen
| AC-Unsafe corrupt lock mem fd
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>The <code>mbtowc</code> (“multibyte to wide character”) function when called
with non-null <var>string</var> converts the first multibyte character
beginning at <var>string</var> to its corresponding wide character code.  It
stores the result in <code>*<var>result</var></code>.
</para>
<para><code>mbtowc</code> never examines more than <var>size</var> bytes.  (The idea is
to supply for <var>size</var> the number of bytes of data you have in hand.)
</para>
<para><code>mbtowc</code> with non-null <var>string</var> distinguishes three
possibilities: the first <var>size</var> bytes at <var>string</var> start with
valid multibyte characters, they start with an invalid byte sequence or
just part of a character, or <var>string</var> points to an empty string (a
null character).
</para>
<para>For a valid multibyte character, <code>mbtowc</code> converts it to a wide
character and stores that in <code>*<var>result</var></code>, and returns the
number of bytes in that character (always at least <em class="math">1</emphasis> and never
more than <var>size</var>).
</para>
<para>For an invalid byte sequence, <code>mbtowc</code> returns <em class="math">-1</emphasis>.  For an
empty string, it returns <em class="math">0</emphasis>, also storing <code>'\0'</code> in
<code>*<var>result</var></code>.
</para>
<para>If the multibyte character code uses shift characters, then
<code>mbtowc</code> maintains and updates a shift state as it scans.  If you
call <code>mbtowc</code> with a null pointer for <var>string</var>, that
initializes the shift state to its standard initial value.  It also
returns nonzero if the multibyte character code in use actually has a
shift state.  See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Shift-State">States in Non-reentrant Functions</a>.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-wctomb"><span class="category">Function: </span><span><emphasis>int</emphasis> <strong>wctomb</strong> <emphasis>(char *<var>string</var>, wchar_t <var>wchar</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-wctomb" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Unsafe race
| AS-Unsafe corrupt heap lock dlopen
| AC-Unsafe corrupt lock mem fd
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>The <code>wctomb</code> (“wide character to multibyte”) function converts
the wide character code <var>wchar</var> to its corresponding multibyte
character sequence, and stores the result in bytes starting at
<var>string</var>.  At most <code>MB_CUR_MAX</code> characters are stored.
</para>
<para><code>wctomb</code> with non-null <var>string</var> distinguishes three
possibilities for <var>wchar</var>: a valid wide character code (one that can
be translated to a multibyte character), an invalid code, and
<code>L'\0'</code>.
</para>
<para>Given a valid code, <code>wctomb</code> converts it to a multibyte character,
storing the bytes starting at <var>string</var>.  Then it returns the number
of bytes in that character (always at least <em class="math">1</emphasis> and never more
than <code>MB_CUR_MAX</code>).
</para>
<para>If <var>wchar</var> is an invalid wide character code, <code>wctomb</code> returns
<em class="math">-1</emphasis>.  If <var>wchar</var> is <code>L'\0'</code>, it returns <code>0</code>, also
storing <code>'\0'</code> in <code>*<var>string</var></code>.
</para>
<para>If the multibyte character code uses shift characters, then
<code>wctomb</code> maintains and updates a shift state as it scans.  If you
call <code>wctomb</code> with a null pointer for <var>string</var>, that
initializes the shift state to its standard initial value.  It also
returns nonzero if the multibyte character code in use actually has a
shift state.  See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Shift-State">States in Non-reentrant Functions</a>.
</para>
<para>Calling this function with a <var>wchar</var> argument of zero when
<var>string</var> is not null has the side-effect of reinitializing the
stored shift state <emphasis>as well as</emphasis> storing the multibyte character
<code>'\0'</code> and returning <em class="math">0</emphasis>.
</para></dd></dl>

<para>Similar to <code>mbrlen</code> there is also a non-reentrant function that
computes the length of a multibyte character.  It can be defined in
terms of <code>mbtowc</code>.
</para>
<dl class="def">
<dt xml:id="glibc-index-mblen"><span class="category">Function: </span><span><emphasis>int</emphasis> <strong>mblen</strong> <emphasis>(const char *<var>string</var>, size_t <var>size</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-mblen" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Unsafe race
| AS-Unsafe corrupt heap lock dlopen
| AC-Unsafe corrupt lock mem fd
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>The <code>mblen</code> function with a non-null <var>string</var> argument returns
the number of bytes that make up the multibyte character beginning at
<var>string</var>, never examining more than <var>size</var> bytes.  (The idea is
to supply for <var>size</var> the number of bytes of data you have in hand.)
</para>
<para>The return value of <code>mblen</code> distinguishes three possibilities: the
first <var>size</var> bytes at <var>string</var> start with valid multibyte
characters, they start with an invalid byte sequence or just part of a
character, or <var>string</var> points to an empty string (a null character).
</para>
<para>For a valid multibyte character, <code>mblen</code> returns the number of
bytes in that character (always at least <code>1</code> and never more than
<var>size</var>).  For an invalid byte sequence, <code>mblen</code> returns
<em class="math">-1</emphasis>.  For an empty string, it returns <em class="math">0</emphasis>.
</para>
<para>If the multibyte character code uses shift characters, then <code>mblen</code>
maintains and updates a shift state as it scans.  If you call
<code>mblen</code> with a null pointer for <var>string</var>, that initializes the
shift state to its standard initial value.  It also returns a nonzero
value if the multibyte character code in use actually has a shift state.
See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Shift-State">States in Non-reentrant Functions</a>.
</para>
<span xml:id="glibc-index-stdlib_002eh-7"></span>
<para>The function <code>mblen</code> is declared in <filename>stdlib.h</filename>.
</para></dd></dl>


<hr>
</div>
<div class="subsection" xml:id="glibc-Non_002dreentrant-String-Conversion">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Shift-State" accesskey="n" rel="next">States in Non-reentrant Functions</a>, Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Non_002dreentrant-Character-Conversion" accesskey="p" rel="prev">Non-reentrant Conversion of Single Characters</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Non_002dreentrant-Conversion" accesskey="u" rel="up">Non-reentrant Conversion Function</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Non_002dreentrant-Conversion-of-Strings"></span><h4 class="subsection">6.4.2 Non-reentrant Conversion of Strings</title>

<para>For convenience the &isoc;90 standard also defines functions to
convert entire strings instead of single characters.  These functions
suffer from the same problems as their reentrant counterparts from
Amendment&nbsp;1 to &isoc;90; see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Converting-Strings">Converting Multibyte and Wide Character Strings</a>.
</para>
<dl class="def">
<dt xml:id="glibc-index-mbstowcs"><span class="category">Function: </span><span><emphasis>size_t</emphasis> <strong>mbstowcs</strong> <emphasis>(wchar_t *<var>wstring</var>, const char *<var>string</var>, size_t <var>size</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-mbstowcs" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Unsafe corrupt heap lock dlopen
| AC-Unsafe corrupt lock mem fd
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>The <code>mbstowcs</code> (“multibyte string to wide character string”)
function converts the null-terminated string of multibyte characters
<var>string</var> to an array of wide character codes, storing not more than
<var>size</var> wide characters into the array beginning at <var>wstring</var>.
The terminating null character counts towards the size, so if <var>size</var>
is less than the actual number of wide characters resulting from
<var>string</var>, no terminating null character is stored.
</para>
<para>The conversion of characters from <var>string</var> begins in the initial
shift state.
</para>
<para>If an invalid multibyte character sequence is found, the <code>mbstowcs</code>
function returns a value of <em class="math">-1</emphasis>.  Otherwise, it returns the number
of wide characters stored in the array <var>wstring</var>.  This number does
not include the terminating null character, which is present if the
number is less than <var>size</var>.
</para>
<para>Here is an example showing how to convert a string of multibyte
characters, allocating enough space for the result.
</para>
<div class="example">
<pre class="example">wchar_t *
mbstowcs_alloc (const char *string)
{
  size_t size = strlen (string) + 1;
  wchar_t *buf = xmalloc (size * sizeof (wchar_t));

  size = mbstowcs (buf, string, size);
  if (size == (size_t) -1)
    return NULL;
  buf = xreallocarray (buf, size + 1, sizeof *buf);
  return buf;
}
</pre></div>

<para>If <var>wstring</var> is a null pointer then no output is written and the
conversion proceeds as above, and the result is returned.  In practice
such behaviour is useful for calculating the exact number of wide
characters required to convert <var>string</var>.  This behaviour of
accepting a null pointer for <var>wstring</var> is an XPG4.2 extension
that is not specified in &isoc; and is optional in POSIX.
</para></dd></dl>

<dl class="def">
<dt xml:id="glibc-index-wcstombs"><span class="category">Function: </span><span><emphasis>size_t</emphasis> <strong>wcstombs</strong> <emphasis>(char *<var>string</var>, const wchar_t *<var>wstring</var>, size_t <var>size</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-wcstombs" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Unsafe corrupt heap lock dlopen
| AC-Unsafe corrupt lock mem fd
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<para>The <code>wcstombs</code> (“wide character string to multibyte string”)
function converts the null-terminated wide character array <var>wstring</var>
into a string containing multibyte characters, storing not more than
<var>size</var> bytes starting at <var>string</var>, followed by a terminating
null character if there is room.  The conversion of characters begins in
the initial shift state.
</para>
<para>The terminating null character counts towards the size, so if <var>size</var>
is less than or equal to the number of bytes needed in <var>wstring</var>, no
terminating null character is stored.
</para>
<para>If a code that does not correspond to a valid multibyte character is
found, the <code>wcstombs</code> function returns a value of <em class="math">-1</emphasis>.
Otherwise, the return value is the number of bytes stored in the array
<var>string</var>.  This number does not include the terminating null character,
which is present if the number is less than <var>size</var>.
</para></dd></dl>

<hr>
</div>
<div class="subsection" xml:id="glibc-Shift-State">
<div class="header">
<para>
Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Non_002dreentrant-String-Conversion" accesskey="p" rel="prev">Non-reentrant Conversion of Strings</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Non_002dreentrant-Conversion" accesskey="u" rel="up">Non-reentrant Conversion Function</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-States-in-Non_002dreentrant-Functions"></span><h4 class="subsection">6.4.3 States in Non-reentrant Functions</title>

<para>In some multibyte character codes, the <emphasis>meaning</emphasis> of any particular
byte sequence is not fixed; it depends on what other sequences have come
earlier in the same string.  Typically there are just a few sequences that
can change the meaning of other sequences; these few are called
<emphasis>shift sequences</emphasis> and we say that they set the <emphasis>shift state</emphasis> for
other sequences that follow.
</para>
<para>To illustrate shift state and shift sequences, suppose we decide that
the sequence <code>0200</code> (just one byte) enters Japanese mode, in which
pairs of bytes in the range from <code>0240</code> to <code>0377</code> are single
characters, while <code>0201</code> enters Latin-1 mode, in which single bytes
in the range from <code>0240</code> to <code>0377</code> are characters, and
interpreted according to the ISO Latin-1 character set.  This is a
multibyte code that has two alternative shift states (“Japanese mode”
and “Latin-1 mode”), and two shift sequences that specify particular
shift states.
</para>
<para>When the multibyte character code in use has shift states, then
<code>mblen</code>, <code>mbtowc</code>, and <code>wctomb</code> must maintain and update
the current shift state as they scan the string.  To make this work
properly, you must follow these rules:
</para>
<ul>
<li> Before starting to scan a string, call the function with a null pointer
for the multibyte character address—for example, <code>mblen (NULL,
0)</code>.  This initializes the shift state to its standard initial value.

</li><li> Scan the string one character at a time, in order.  Do not “back up”
and rescan characters already scanned, and do not intersperse the
processing of different strings.
</li></ul>

<para>Here is an example of using <code>mblen</code> following these rules:
</para>
<div class="example">
<pre class="example">void
scan_string (char *s)
{
  int length = strlen (s);

  /* <span class="roman">Initialize shift state.</span>  */
  mblen (NULL, 0);

  while (1)
    {
      int thischar = mblen (s, length);
      /* <span class="roman">Deal with end of string and invalid characters.</span>  */
      if (thischar == 0)
        break;
      if (thischar == -1)
        {
          error ("invalid multibyte character");
          break;
        }
      /* <span class="roman">Advance past this character.</span>  */
      s += thischar;
      length -= thischar;
    }
}
</pre></div>

<para>The functions <code>mblen</code>, <code>mbtowc</code> and <code>wctomb</code> are not
reentrant when using a multibyte code that uses a shift state.  However,
no other library functions call these functions, so you don’t have to
worry that the shift state will be changed mysteriously.
</para>

<hr>
</div>
</div>
<sect xml:id="glibc-Generic-Charset-Conversion">
<div class="header">
<para>
Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Non_002dreentrant-Conversion" accesskey="p" rel="prev">Non-reentrant Conversion Function</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Character-Set-Handling" accesskey="u" rel="up">Character Set Handling</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Generic-Charset-Conversion-1"></span><h3 class="section">6.5 Generic Charset Conversion</title>

<para>The conversion functions mentioned so far in this chapter all had in
common that they operate on character sets that are not directly
specified by the functions.  The multibyte encoding used is specified by
the currently selected locale for the <code>LC_CTYPE</code> category.  The
wide character set is fixed by the implementation (in the case of the GNU C Library
it is always UCS-4 encoded ISO&nbsp;10646).
</para>
<para>This has of course several problems when it comes to general character
conversion:
</para>
<ul>
<li> For every conversion where neither the source nor the destination
character set is the character set of the locale for the <code>LC_CTYPE</code>
category, one has to change the <code>LC_CTYPE</code> locale using
<code>setlocale</code>.

<para>Changing the <code>LC_CTYPE</code> locale introduces major problems for the rest
of the programs since several more functions (e.g., the character
classification functions, see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Classification-of-Characters">Classification of Characters</a>) use the
<code>LC_CTYPE</code> category.
</para>
</li><li> Parallel conversions to and from different character sets are not
possible since the <code>LC_CTYPE</code> selection is global and shared by all
threads.

</li><li> If neither the source nor the destination character set is the character
set used for <code>wchar_t</code> representation, there is at least a two-step
process necessary to convert a text using the functions above.  One would
have to select the source character set as the multibyte encoding,
convert the text into a <code>wchar_t</code> text, select the destination
character set as the multibyte encoding, and convert the wide character
text to the multibyte (<em class="math">=</emphasis> destination) character set.

<para>Even if this is possible (which is not guaranteed) it is a very tiring
work.  Plus it suffers from the other two raised points even more due to
the steady changing of the locale.
</para></li></ul>

<para>The XPG2 standard defines a completely new set of functions, which has
none of these limitations.  They are not at all coupled to the selected
locales, and they have no constraints on the character sets selected for
source and destination.  Only the set of available conversions limits
them.  The standard does not specify that any conversion at all must be
available.  Such availability is a measure of the quality of the
implementation.
</para>
<para>In the following text first the interface to <code>iconv</code> and then the
conversion function, will be described.  Comparisons with other
implementations will show what obstacles stand in the way of portable
applications.  Finally, the implementation is described in so far as might
interest the advanced user who wants to extend conversion capabilities.
</para>

<ul class="section-toc">
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Generic-Conversion-Interface" accesskey="1">Generic Character Set Conversion Interface</a></li>
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#iconv-Examples" accesskey="2">A complete <code>iconv</code> example</a></li>
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Other-iconv-Implementations" accesskey="3">Some Details about other <code>iconv</code> Implementations</a></li>
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#glibc-iconv-Implementation" accesskey="4">The <code>iconv</code> Implementation in the GNU C Library</a></li>
</ul>
<hr>
<div class="subsection" xml:id="glibc-Generic-Conversion-Interface">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#iconv-Examples" accesskey="n" rel="next">A complete <code>iconv</code> example</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Generic-Charset-Conversion" accesskey="u" rel="up">Generic Charset Conversion</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Generic-Character-Set-Conversion-Interface"></span><h4 class="subsection">6.5.1 Generic Character Set Conversion Interface</title>

<para>This set of functions follows the traditional cycle of using a resource:
open–use–close.  The interface consists of three functions, each of
which implements one step.
</para>
<para>Before the interfaces are described it is necessary to introduce a
data type.  Just like other open–use–close interfaces the functions
introduced here work using handles and the <filename>iconv.h</filename> header
defines a special type for the handles used.
</para>
<dl class="def">
<dt xml:id="glibc-index-iconv_005ft"><span class="category">Data Type: </span><span><strong>iconv_t</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-iconv_005ft" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>This data type is an abstract type defined in <filename>iconv.h</filename>.  The user
must not assume anything about the definition of this type; it must be
completely opaque.
</para>
<para>Objects of this type can be assigned handles for the conversions using
the <code>iconv</code> functions.  The objects themselves need not be freed, but
the conversions for which the handles stand for have to.
</para></dd></dl>

<para>The first step is the function to create a handle.
</para>
<dl class="def">
<dt xml:id="glibc-index-iconv_005fopen"><span class="category">Function: </span><span><emphasis>iconv_t</emphasis> <strong>iconv_open</strong> <emphasis>(const char *<var>tocode</var>, const char *<var>fromcode</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-iconv_005fopen" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe locale
| AS-Unsafe corrupt heap lock dlopen
| AC-Unsafe corrupt lock mem fd
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>


<para>The <code>iconv_open</code> function has to be used before starting a
conversion.  The two parameters this function takes determine the
source and destination character set for the conversion, and if the
implementation has the possibility to perform such a conversion, the
function returns a handle.
</para>
<para>If the wanted conversion is not available, the <code>iconv_open</code> function
returns <code>(iconv_t) -1</code>.  In this case the global variable
<code>errno</code> can have the following values:
</para>
<dl compact="compact">
<dt><span><code>EMFILE</code></span></dt>
<dd><para>The process already has <code>OPEN_MAX</code> file descriptors open.
</para></dd>
<dt><span><code>ENFILE</code></span></dt>
<dd><para>The system limit of open files is reached.
</para></dd>
<dt><span><code>ENOMEM</code></span></dt>
<dd><para>Not enough memory to carry out the operation.
</para></dd>
<dt><span><code>EINVAL</code></span></dt>
<dd><para>The conversion from <var>fromcode</var> to <var>tocode</var> is not supported.
</para></dd>
</dl>

<para>It is not possible to use the same descriptor in different threads to
perform independent conversions.  The data structures associated
with the descriptor include information about the conversion state.
This must not be messed up by using it in different conversions.
</para>
<para>An <code>iconv</code> descriptor is like a file descriptor as for every use a
new descriptor must be created.  The descriptor does not stand for all
of the conversions from <var>fromset</var> to <var>toset</var>.
</para>
<para>The GNU C Library implementation of <code>iconv_open</code> has one
significant extension to other implementations.  To ease the extension
of the set of available conversions, the implementation allows storing
the necessary files with data and code in an arbitrary number of
directories.  How this extension must be written will be explained below
(see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#glibc-iconv-Implementation">The <code>iconv</code> Implementation in the GNU C Library</a>).  Here it is only important to say
that all directories mentioned in the <code>GCONV_PATH</code> environment
variable are considered only if they contain a file <filename>gconv-modules</filename>.
These directories need not necessarily be created by the system
administrator.  In fact, this extension is introduced to help users
writing and using their own, new conversions.  Of course, this does not
work for security reasons in SUID binaries; in this case only the system
directory is considered and this normally is
<filename><var>prefix</var>/lib/gconv</filename>.  The <code>GCONV_PATH</code> environment
variable is examined exactly once at the first call of the
<code>iconv_open</code> function.  Later modifications of the variable have no
effect.
</para>
<span xml:id="glibc-index-iconv_002eh"></span>
<para>The <code>iconv_open</code> function was introduced early in the X/Open
Portability Guide, version&nbsp;2.  It is supported by all commercial
Unices as it is required for the Unix branding.  However, the quality and
completeness of the implementation varies widely.  The <code>iconv_open</code>
function is declared in <filename>iconv.h</filename>.
</para></dd></dl>

<para>The <code>iconv</code> implementation can associate large data structure with
the handle returned by <code>iconv_open</code>.  Therefore, it is crucial to
free all the resources once all conversions are carried out and the
conversion is not needed anymore.
</para>
<dl class="def">
<dt xml:id="glibc-index-iconv_005fclose"><span class="category">Function: </span><span><emphasis>int</emphasis> <strong>iconv_close</strong> <emphasis>(iconv_t <var>cd</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-iconv_005fclose" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe
| AS-Unsafe corrupt heap lock dlopen
| AC-Unsafe corrupt lock mem
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>


<para>The <code>iconv_close</code> function frees all resources associated with the
handle <var>cd</var>, which must have been returned by a successful call to
the <code>iconv_open</code> function.
</para>
<para>If the function call was successful the return value is <em class="math">0</emphasis>.
Otherwise it is <em class="math">-1</emphasis> and <code>errno</code> is set appropriately.
Defined errors are:
</para>
<dl compact="compact">
<dt><span><code>EBADF</code></span></dt>
<dd><para>The conversion descriptor is invalid.
</para></dd>
</dl>

<span xml:id="glibc-index-iconv_002eh-1"></span>
<para>The <code>iconv_close</code> function was introduced together with the rest
of the <code>iconv</code> functions in XPG2 and is declared in <filename>iconv.h</filename>.
</para></dd></dl>

<para>The standard defines only one actual conversion function.  This has,
therefore, the most general interface: it allows conversion from one
buffer to another.  Conversion from a file to a buffer, vice versa, or
even file to file can be implemented on top of it.
</para>
<dl class="def">
<dt xml:id="glibc-index-iconv-1"><span class="category">Function: </span><span><emphasis>size_t</emphasis> <strong>iconv</strong> <emphasis>(iconv_t <var>cd</var>, char **<var>inbuf</var>, size_t *<var>inbytesleft</var>, char **<var>outbuf</var>, size_t *<var>outbytesleft</var>)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-iconv-1" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>Preliminary:
| MT-Safe race:cd
| AS-Safe
| AC-Unsafe corrupt
| See <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#POSIX-Safety-Concepts">POSIX Safety Concepts</a>.
</para>

<span xml:id="glibc-index-stateful-3"></span>
<para>The <code>iconv</code> function converts the text in the input buffer
according to the rules associated with the descriptor <var>cd</var> and
stores the result in the output buffer.  It is possible to call the
function for the same text several times in a row since for stateful
character sets the necessary state information is kept in the data
structures associated with the descriptor.
</para>
<para>The input buffer is specified by <code>*<var>inbuf</var></code> and it contains
<code>*<var>inbytesleft</var></code> bytes.  The extra indirection is necessary for
communicating the used input back to the caller (see below).  It is
important to note that the buffer pointer is of type <code>char</code> and the
length is measured in bytes even if the input text is encoded in wide
characters.
</para>
<para>The output buffer is specified in a similar way.  <code>*<var>outbuf</var></code>
points to the beginning of the buffer with at least
<code>*<var>outbytesleft</var></code> bytes room for the result.  The buffer
pointer again is of type <code>char</code> and the length is measured in
bytes.  If <var>outbuf</var> or <code>*<var>outbuf</var></code> is a null pointer, the
conversion is performed but no output is available.
</para>
<para>If <var>inbuf</var> is a null pointer, the <code>iconv</code> function performs the
necessary action to put the state of the conversion into the initial
state.  This is obviously a no-op for non-stateful encodings, but if the
encoding has a state, such a function call might put some byte sequences
in the output buffer, which perform the necessary state changes.  The
next call with <var>inbuf</var> not being a null pointer then simply goes on
from the initial state.  It is important that the programmer never makes
any assumption as to whether the conversion has to deal with states.
Even if the input and output character sets are not stateful, the
implementation might still have to keep states.  This is due to the
implementation chosen for the GNU C Library as it is described below.
Therefore an <code>iconv</code> call to reset the state should always be
performed if some protocol requires this for the output text.
</para>
<para>The conversion stops for one of three reasons.  The first is that all
characters from the input buffer are converted.  This actually can mean
two things: either all bytes from the input buffer are consumed or
there are some bytes at the end of the buffer that possibly can form a
complete character but the input is incomplete.  The second reason for a
stop is that the output buffer is full.  And the third reason is that
the input contains invalid characters.
</para>
<para>In all of these cases the buffer pointers after the last successful
conversion, for the input and output buffers, are stored in <var>inbuf</var> and
<var>outbuf</var>, and the available room in each buffer is stored in
<var>inbytesleft</var> and <var>outbytesleft</var>.
</para>
<para>Since the character sets selected in the <code>iconv_open</code> call can be
almost arbitrary, there can be situations where the input buffer contains
valid characters, which have no identical representation in the output
character set.  The behavior in this situation is undefined.  The
<emphasis>current</emphasis> behavior of the GNU C Library in this situation is to
return with an error immediately.  This certainly is not the most
desirable solution; therefore, future versions will provide better ones,
but they are not yet finished.
</para>
<para>If all input from the input buffer is successfully converted and stored
in the output buffer, the function returns the number of non-reversible
conversions performed.  In all other cases the return value is
<code>(size_t) -1</code> and <code>errno</code> is set appropriately.  In such cases
the value pointed to by <var>inbytesleft</var> is nonzero.
</para>
<dl compact="compact">
<dt><span><code>EILSEQ</code></span></dt>
<dd><para>The conversion stopped because of an invalid byte sequence in the input.
After the call, <code>*<var>inbuf</var></code> points at the first byte of the
invalid byte sequence.
</para>
</dd>
<dt><span><code>E2BIG</code></span></dt>
<dd><para>The conversion stopped because it ran out of space in the output buffer.
</para>
</dd>
<dt><span><code>EINVAL</code></span></dt>
<dd><para>The conversion stopped because of an incomplete byte sequence at the end
of the input buffer.
</para>
</dd>
<dt><span><code>EBADF</code></span></dt>
<dd><para>The <var>cd</var> argument is invalid.
</para></dd>
</dl>

<span xml:id="glibc-index-iconv_002eh-2"></span>
<para>The <code>iconv</code> function was introduced in the XPG2 standard and is
declared in the <filename>iconv.h</filename> header.
</para></dd></dl>

<para>The definition of the <code>iconv</code> function is quite good overall.  It
provides quite flexible functionality.  The only problems lie in the
boundary cases, which are incomplete byte sequences at the end of the
input buffer and invalid input.  A third problem, which is not really
a design problem, is the way conversions are selected.  The standard
does not say anything about the legitimate names, a minimal set of
available conversions.  We will see how this negatively impacts other
implementations, as demonstrated below.
</para>
<hr>
</div>
<div class="subsection" xml:id="glibc-iconv-Examples">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Other-iconv-Implementations" accesskey="n" rel="next">Some Details about other <code>iconv</code> Implementations</a>, Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Generic-Conversion-Interface" accesskey="p" rel="prev">Generic Character Set Conversion Interface</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Generic-Charset-Conversion" accesskey="u" rel="up">Generic Charset Conversion</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-A-complete-iconv-example"></span><h4 class="subsection">6.5.2 A complete <code>iconv</code> example</title>

<para>The example below features a solution for a common problem.  Given that
one knows the internal encoding used by the system for <code>wchar_t</code>
strings, one often is in the position to read text from a file and store
it in wide character buffers.  One can do this using <code>mbsrtowcs</code>,
but then we run into the problems discussed above.
</para>
<div class="example">
<pre class="example">int
file2wcs (int fd, const char *charset, wchar_t *outbuf, size_t avail)
{
  char inbuf[BUFSIZ];
  size_t insize = 0;
  char *wrptr = (char *) outbuf;
  int result = 0;
  iconv_t cd;

  cd = iconv_open ("WCHAR_T", charset);
  if (cd == (iconv_t) -1)
    {
      /* <span class="roman">Something went wrong.</span>  */
      if (errno == EINVAL)
        error (0, 0, "conversion from '%s' to wchar_t not available",
               charset);
      else
        perror ("iconv_open");

      /* <span class="roman">Terminate the output string.</span>  */
      *outbuf = L'\0';

      return -1;
    }

  while (avail &gt; 0)
    {
      size_t nread;
      size_t nconv;
      char *inptr = inbuf;

      /* <span class="roman">Read more input.</span>  */
      nread = read (fd, inbuf + insize, sizeof (inbuf) - insize);
      if (nread == 0)
        {
          /* <span class="roman">When we come here the file is completely read.</span>
             <span class="roman">This still could mean there are some unused</span>
             <span class="roman">characters in the <code>inbuf</code>.  Put them back.</span>  */
          if (lseek (fd, -insize, SEEK_CUR) == -1)
            result = -1;

          /* <span class="roman">Now write out the byte sequence to get into the</span>
             <span class="roman">initial state if this is necessary.</span>  */
          iconv (cd, NULL, NULL, &amp;wrptr, &amp;avail);

          break;
        }
      insize += nread;

      /* <span class="roman">Do the conversion.</span>  */
      nconv = iconv (cd, &amp;inptr, &amp;insize, &amp;wrptr, &amp;avail);
      if (nconv == (size_t) -1)
        {
          /* <span class="roman">Not everything went right.  It might only be</span>
             <span class="roman">an unfinished byte sequence at the end of the</span>
             <span class="roman">buffer.  Or it is a real problem.</span>  */
          if (errno == EINVAL)
            /* <span class="roman">This is harmless.  Simply move the unused</span>
               <span class="roman">bytes to the beginning of the buffer so that</span>
               <span class="roman">they can be used in the next round.</span>  */
            memmove (inbuf, inptr, insize);
          else
            {
              /* <span class="roman">It is a real problem.  Maybe we ran out of</span>
                 <span class="roman">space in the output buffer or we have invalid</span>
                 <span class="roman">input.  In any case back the file pointer to</span>
                 <span class="roman">the position of the last processed byte.</span>  */
              lseek (fd, -insize, SEEK_CUR);
              result = -1;
              break;
            }
        }
    }

  /* <span class="roman">Terminate the output string.</span>  */
  if (avail &gt;= sizeof (wchar_t))
    *((wchar_t *) wrptr) = L'\0';

  if (iconv_close (cd) != 0)
    perror ("iconv_close");

  return (wchar_t *) wrptr - outbuf;
}
</pre></div>

<span xml:id="glibc-index-stateful-4"></span>
<para>This example shows the most important aspects of using the <code>iconv</code>
functions.  It shows how successive calls to <code>iconv</code> can be used to
convert large amounts of text.  The user does not have to care about
stateful encodings as the functions take care of everything.
</para>
<para>An interesting point is the case where <code>iconv</code> returns an error and
<code>errno</code> is set to <code>EINVAL</code>.  This is not really an error in the
transformation.  It can happen whenever the input character set contains
byte sequences of more than one byte for some character and texts are not
processed in one piece.  In this case there is a chance that a multibyte
sequence is cut.  The caller can then simply read the remainder of the
takes and feed the offending bytes together with new character from the
input to <code>iconv</code> and continue the work.  The internal state kept in
the descriptor is <emphasis>not</emphasis> unspecified after such an event as is the
case with the conversion functions from the &isoc; standard.
</para>
<para>The example also shows the problem of using wide character strings with
<code>iconv</code>.  As explained in the description of the <code>iconv</code>
function above, the function always takes a pointer to a <code>char</code>
array and the available space is measured in bytes.  In the example, the
output buffer is a wide character buffer; therefore, we use a local
variable <var>wrptr</var> of type <code>char *</code>, which is used in the
<code>iconv</code> calls.
</para>
<para>This looks rather innocent but can lead to problems on platforms that
have tight restriction on alignment.  Therefore the caller of <code>iconv</code>
has to make sure that the pointers passed are suitable for access of
characters from the appropriate character set.  Since, in the
above case, the input parameter to the function is a <code>wchar_t</code>
pointer, this is the case (unless the user violates alignment when
computing the parameter).  But in other situations, especially when
writing generic functions where one does not know what type of character
set one uses and, therefore, treats text as a sequence of bytes, it might
become tricky.
</para>
<hr>
</div>
<div class="subsection" xml:id="glibc-Other-iconv-Implementations">
<div class="header">
<para>
Next: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#glibc-iconv-Implementation" accesskey="n" rel="next">The <code>iconv</code> Implementation in the GNU C Library</a>, Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#iconv-Examples" accesskey="p" rel="prev">A complete <code>iconv</code> example</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Generic-Charset-Conversion" accesskey="u" rel="up">Generic Charset Conversion</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-Some-Details-about-other-iconv-Implementations"></span><h4 class="subsection">6.5.3 Some Details about other <code>iconv</code> Implementations</title>

<para>This is not really the place to discuss the <code>iconv</code> implementation
of other systems but it is necessary to know a bit about them to write
portable programs.  The above mentioned problems with the specification
of the <code>iconv</code> functions can lead to portability issues.
</para>
<para>The first thing to notice is that, due to the large number of character
sets in use, it is certainly not practical to encode the conversions
directly in the C library.  Therefore, the conversion information must
come from files outside the C library.  This is usually done in one or
both of the following ways:
</para>
<ul>
<li> The C library contains a set of generic conversion functions that can
read the needed conversion tables and other information from data files.
These files get loaded when necessary.

<para>This solution is problematic as it requires a great deal of effort to
apply to all character sets (potentially an infinite set).  The
differences in the structure of the different character sets is so large
that many different variants of the table-processing functions must be
developed.  In addition, the generic nature of these functions make them
slower than specifically implemented functions.
</para>
</li><li> The C library only contains a framework that can dynamically load
object files and execute the conversion functions contained therein.

<para>This solution provides much more flexibility.  The C library itself
contains only very little code and therefore reduces the general memory
footprint.  Also, with a documented interface between the C library and
the loadable modules it is possible for third parties to extend the set
of available conversion modules.  A drawback of this solution is that
dynamic loading must be available.
</para></li></ul>

<para>Some implementations in commercial Unices implement a mixture of these
possibilities; the majority implement only the second solution.  Using
loadable modules moves the code out of the library itself and keeps
the door open for extensions and improvements, but this design is also
limiting on some platforms since not many platforms support dynamic
loading in statically linked programs.  On platforms without this
capability it is therefore not possible to use this interface in
statically linked programs.  The GNU C Library has, on ELF platforms, no
problems with dynamic loading in these situations; therefore, this
point is moot.  The danger is that one gets acquainted with this
situation and forgets about the restrictions on other systems.
</para>
<para>A second thing to know about other <code>iconv</code> implementations is that
the number of available conversions is often very limited.  Some
implementations provide, in the standard release (not special
international or developer releases), at most 100 to 200 conversion
possibilities.  This does not mean 200 different character sets are
supported; for example, conversions from one character set to a set of 10
others might count as 10 conversions.  Together with the other direction
this makes 20 conversion possibilities used up by one character set.  One
can imagine the thin coverage these platforms provide.  Some Unix vendors
even provide only a handful of conversions, which renders them useless for
almost all uses.
</para>
<para>This directly leads to a third and probably the most problematic point.
The way the <code>iconv</code> conversion functions are implemented on all
known Unix systems and the availability of the conversion functions from
character set <em class="math">A</emphasis> to <em class="math">B</emphasis> and the conversion from
<em class="math">B</emphasis> to <em class="math">C</emphasis> does <emphasis>not</emphasis> imply that the
conversion from <em class="math">A</emphasis> to <em class="math">C</emphasis> is available.
</para>
<para>This might not seem unreasonable and problematic at first, but it is a
quite big problem as one will notice shortly after hitting it.  To show
the problem we assume to write a program that has to convert from
<em class="math">A</emphasis> to <em class="math">C</emphasis>.  A call like
</para>
<div class="example">
<pre class="example">cd = iconv_open ("<em class="math">C</emphasis>", "<em class="math">A</emphasis>");
</pre></div>

<para>fails according to the assumption above.  But what does the program
do now?  The conversion is necessary; therefore, simply giving up is not
an option.
</para>
<para>This is a nuisance.  The <code>iconv</code> function should take care of this.
But how should the program proceed from here on?  If it tries to convert
to character set <em class="math">B</emphasis>, first the two <code>iconv_open</code>
calls
</para>
<div class="example">
<pre class="example">cd1 = iconv_open ("<em class="math">B</emphasis>", "<em class="math">A</emphasis>");
</pre></div>

<para>and
</para>
<div class="example">
<pre class="example">cd2 = iconv_open ("<em class="math">C</emphasis>", "<em class="math">B</emphasis>");
</pre></div>

<para>will succeed, but how to find <em class="math">B</emphasis>?
</para>
<para>Unfortunately, the answer is: there is no general solution.  On some
systems guessing might help.  On those systems most character sets can
convert to and from UTF-8 encoded ISO&nbsp;10646 or Unicode text.  Besides
this only some very system-specific methods can help.  Since the
conversion functions come from loadable modules and these modules must
be stored somewhere in the filesystem, one <emphasis>could</emphasis> try to find them
and determine from the available file which conversions are available
and whether there is an indirect route from <em class="math">A</emphasis> to
<em class="math">C</emphasis>.
</para>
<para>This example shows one of the design errors of <code>iconv</code> mentioned
above.  It should at least be possible to determine the list of available
conversions programmatically so that if <code>iconv_open</code> says there is no
such conversion, one could make sure this also is true for indirect
routes.
</para>
<hr>
</div>
<div class="subsection" xml:id="glibc-glibc-iconv-Implementation">
<div class="header">
<para>
Previous: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Other-iconv-Implementations" accesskey="p" rel="prev">Some Details about other <code>iconv</code> Implementations</a>, Up: <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Generic-Charset-Conversion" accesskey="u" rel="up">Generic Charset Conversion</a> &nbsp; [<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Concept-Index" title="Index" rel="index">Index</a>]</para>
</div>
<span xml:id="glibc-The-iconv-Implementation-in-the-GNU-C-Library"></span><h4 class="subsection">6.5.4 The <code>iconv</code> Implementation in the GNU C Library</title>

<para>After reading about the problems of <code>iconv</code> implementations in the
last section it is certainly good to note that the implementation in
the GNU C Library has none of the problems mentioned above.  What
follows is a step-by-step analysis of the points raised above.  The
evaluation is based on the current state of the development (as of
January 1999).  The development of the <code>iconv</code> functions is not
complete, but basic functionality has solidified.
</para>
<para>The GNU C Library’s <code>iconv</code> implementation uses shared loadable
modules to implement the conversions.  A very small number of
conversions are built into the library itself but these are only rather
trivial conversions.
</para>
<para>All the benefits of loadable modules are available in the GNU C Library
implementation.  This is especially appealing since the interface is
well documented (see below), and it, therefore, is easy to write new
conversion modules.  The drawback of using loadable objects is not a
problem in the GNU C Library, at least on ELF systems.  Since the
library is able to load shared objects even in statically linked
binaries, static linking need not be forbidden in case one wants to use
<code>iconv</code>.
</para>
<para>The second mentioned problem is the number of supported conversions.
Currently, the GNU C Library supports more than 150 character sets.  The
way the implementation is designed the number of supported conversions
is greater than 22350 (<em class="math">150</emphasis> times <em class="math">149</emphasis>).  If any conversion
from or to a character set is missing, it can be added easily.
</para>
<para>Particularly impressive as it may be, this high number is due to the
fact that the GNU C Library implementation of <code>iconv</code> does not have
the third problem mentioned above (i.e., whenever there is a conversion
from a character set <em class="math">A</emphasis> to <em class="math">B</emphasis> and from
<em class="math">B</emphasis> to <em class="math">C</emphasis> it is always possible to convert from
<em class="math">A</emphasis> to <em class="math">C</emphasis> directly).  If the <code>iconv_open</code>
returns an error and sets <code>errno</code> to <code>EINVAL</code>, there is no
known way, directly or indirectly, to perform the wanted conversion.
</para>
<span xml:id="glibc-index-triangulation"></span>
<para>Triangulation is achieved by providing for each character set a
conversion from and to UCS-4 encoded ISO&nbsp;10646.  Using ISO&nbsp;10646
as an intermediate representation it is possible to <emphasis>triangulate</emphasis>
(i.e., convert with an intermediate representation).
</para>
<para>There is no inherent requirement to provide a conversion to ISO&nbsp;10646 for a new character set, and it is also possible to provide other
conversions where neither source nor destination character set is ISO&nbsp;10646.  The existing set of conversions is simply meant to cover all
conversions that might be of interest.
</para>
<span xml:id="glibc-index-ISO_002d2022_002dJP"></span>
<span xml:id="glibc-index-EUC_002dJP"></span>
<para>All currently available conversions use the triangulation method above,
making conversion run unnecessarily slow.  If, for example, somebody
often needs the conversion from ISO-2022-JP to EUC-JP, a quicker solution
would involve direct conversion between the two character sets, skipping
the input to ISO&nbsp;10646 first.  The two character sets of interest
are much more similar to each other than to ISO&nbsp;10646.
</para>
<para>In such a situation one easily can write a new conversion and provide it
as a better alternative.  The GNU C Library <code>iconv</code> implementation
would automatically use the module implementing the conversion if it is
specified to be more efficient.
</para>
<ul class="section-toc">
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Format-of-gconv_002dmodules-files" accesskey="1">Format of <filename>gconv-modules</filename> files</a></li>
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Finding-the-conversion-path-in-iconv" accesskey="2">Finding the conversion path in <code>iconv</code></a></li>
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#iconv-module-data-structures" accesskey="3"><code>iconv</code> module data structures</a></li>
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#iconv-module-interfaces" accesskey="4"><code>iconv</code> module interfaces</a></li>
</ul>
<div class="subsubsection" xml:id="glibc-Format-of-gconv_002dmodules-files">
<h4 class="subsubsection">6.5.4.1 Format of <filename>gconv-modules</filename> files</title>

<para>All information about the available conversions comes from a file named
<filename>gconv-modules</filename>, which can be found in any of the directories along
the <code>GCONV_PATH</code>.  The <filename>gconv-modules</filename> files are line-oriented
text files, where each of the lines has one of the following formats:
</para>
<ul>
<li> If the first non-whitespace character is a <kbd>#</kbd> the line contains only
comments and is ignored.

</li><li> Lines starting with <code>alias</code> define an alias name for a character
set.  Two more words are expected on the line.  The first word
defines the alias name, and the second defines the original name of the
character set.  The effect is that it is possible to use the alias name
in the <var>fromset</var> or <var>toset</var> parameters of <code>iconv_open</code> and
achieve the same result as when using the real character set name.

<para>This is quite important as a character set has often many different
names.  There is normally an official name but this need not correspond to
the most popular name.  Besides this many character sets have special
names that are somehow constructed.  For example, all character sets
specified by the ISO have an alias of the form <code>ISO-IR-<var>nnn</var></code>
where <var>nnn</var> is the registration number.  This allows programs that
know about the registration number to construct character set names and
use them in <code>iconv_open</code> calls.  More on the available names and
aliases follows below.
</para>
</li><li> Lines starting with <code>module</code> introduce an available conversion
module.  These lines must contain three or four more words.

<para>The first word specifies the source character set, the second word the
destination character set of conversion implemented in this module, and
the third word is the name of the loadable module.  The filename is
constructed by appending the usual shared object suffix (normally
<filename>.so</filename>) and this file is then supposed to be found in the same
directory the <filename>gconv-modules</filename> file is in.  The last word on the line,
which is optional, is a numeric value representing the cost of the
conversion.  If this word is missing, a cost of <em class="math">1</emphasis> is assumed.  The
numeric value itself does not matter that much; what counts are the
relative values of the sums of costs for all possible conversion paths.
Below is a more precise description of the use of the cost value.
</para></li></ul>

<para>Returning to the example above where one has written a module to directly
convert from ISO-2022-JP to EUC-JP and back.  All that has to be done is
to put the new module, let its name be ISO2022JP-EUCJP.so, in a directory
and add a file <filename>gconv-modules</filename> with the following content in the
same directory:
</para>
<div class="example">
<pre class="example">module  ISO-2022-JP//   EUC-JP//        ISO2022JP-EUCJP    1
module  EUC-JP//        ISO-2022-JP//   ISO2022JP-EUCJP    1
</pre></div>

<para>To see why this is sufficient, it is necessary to understand how the
conversion used by <code>iconv</code> (and described in the descriptor) is
selected.  The approach to this problem is quite simple.
</para>
<para>At the first call of the <code>iconv_open</code> function the program reads
all available <filename>gconv-modules</filename> files and builds up two tables: one
containing all the known aliases and another that contains the
information about the conversions and which shared object implements
them.
</para>
</div>
<div class="subsubsection" xml:id="glibc-Finding-the-conversion-path-in-iconv">
<h4 class="subsubsection">6.5.4.2 Finding the conversion path in <code>iconv</code></title>

<para>The set of available conversions form a directed graph with weighted
edges.  The weights on the edges are the costs specified in the
<filename>gconv-modules</filename> files.  The <code>iconv_open</code> function uses an
algorithm suitable for search for the best path in such a graph and so
constructs a list of conversions that must be performed in succession
to get the transformation from the source to the destination character
set.
</para>
<para>Explaining why the above <filename>gconv-modules</filename> files allows the
<code>iconv</code> implementation to resolve the specific ISO-2022-JP to
EUC-JP conversion module instead of the conversion coming with the
library itself is straightforward.  Since the latter conversion takes two
steps (from ISO-2022-JP to ISO&nbsp;10646 and then from ISO&nbsp;10646 to
EUC-JP), the cost is <em class="math">1+1 = 2</emphasis>.  The above <filename>gconv-modules</filename>
file, however, specifies that the new conversion modules can perform this
conversion with only the cost of <em class="math">1</emphasis>.
</para>
<para>A mysterious item about the <filename>gconv-modules</filename> file above (and also
the file coming with the GNU C Library) are the names of the character
sets specified in the <code>module</code> lines.  Why do almost all the names
end in <code>//</code>?  And this is not all: the names can actually be
regular expressions.  At this point in time this mystery should not be
revealed, unless you have the relevant spell-casting materials: ashes
from an original DOS&nbsp;6.2 boot disk burnt in effigy, a crucifix
blessed by St. Emacs, assorted herbal roots from Central America, sand
from Cebu, etc.  Sorry!  <strong>The part of the implementation where
this is used is not yet finished.  For now please simply follow the
existing examples.  It’ll become clearer once it is. –drepper</strong>
</para>
<para>A last remark about the <filename>gconv-modules</filename> is about the names not
ending with <code>//</code>.  A character set named <code>INTERNAL</code> is often
mentioned.  From the discussion above and the chosen name it should have
become clear that this is the name for the representation used in the
intermediate step of the triangulation.  We have said that this is UCS-4
but actually that is not quite right.  The UCS-4 specification also
includes the specification of the byte ordering used.  Since a UCS-4 value
consists of four bytes, a stored value is affected by byte ordering.  The
internal representation is <emphasis>not</emphasis> the same as UCS-4 in case the byte
ordering of the processor (or at least the running process) is not the
same as the one required for UCS-4.  This is done for performance reasons
as one does not want to perform unnecessary byte-swapping operations if
one is not interested in actually seeing the result in UCS-4.  To avoid
trouble with endianness, the internal representation consistently is named
<code>INTERNAL</code> even on big-endian systems where the representations are
identical.
</para>
</div>
<div class="subsubsection" xml:id="glibc-iconv-module-data-structures">
<h4 class="subsubsection">6.5.4.3 <code>iconv</code> module data structures</title>

<para>So far this section has described how modules are located and considered
to be used.  What remains to be described is the interface of the modules
so that one can write new ones.  This section describes the interface as
it is in use in January 1999.  The interface will change a bit in the
future but, with luck, only in an upwardly compatible way.
</para>
<para>The definitions necessary to write new modules are publicly available
in the non-standard header <filename>gconv.h</filename>.  The following text,
therefore, describes the definitions from this header file.  First,
however, it is necessary to get an overview.
</para>
<para>From the perspective of the user of <code>iconv</code> the interface is quite
simple: the <code>iconv_open</code> function returns a handle that can be used
in calls to <code>iconv</code>, and finally the handle is freed with a call to
<code>iconv_close</code>.  The problem is that the handle has to be able to
represent the possibly long sequences of conversion steps and also the
state of each conversion since the handle is all that is passed to the
<code>iconv</code> function.  Therefore, the data structures are really the
elements necessary to understanding the implementation.
</para>
<para>We need two different kinds of data structures.  The first describes the
conversion and the second describes the state etc.  There are really two
type definitions like this in <filename>gconv.h</filename>.
<span xml:id="glibc-index-gconv_002eh"></span>
</para>
<dl class="def">
<dt xml:id="glibc-index-struct-_005f_005fgconv_005fstep"><span class="category">Data type: </span><span><strong>struct __gconv_step</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-struct-_005f_005fgconv_005fstep" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>This data structure describes one conversion a module can perform.  For
each function in a loaded module with conversion functions there is
exactly one object of this type.  This object is shared by all users of
the conversion (i.e., this object does not contain any information
corresponding to an actual conversion; it only describes the conversion
itself).
</para>
<dl compact="compact">
<dt><span><code>struct __gconv_loaded_object *__shlib_handle</code></span></dt>
<dt><span><code>const char *__modname</code></span></dt>
<dt><span><code>int __counter</code></span></dt>
<dd><para>All these elements of the structure are used internally in the C library
to coordinate loading and unloading the shared object.  One must not expect any
of the other elements to be available or initialized.
</para>
</dd>
<dt><span><code>const char *__from_name</code></span></dt>
<dt><span><code>const char *__to_name</code></span></dt>
<dd><para><code>__from_name</code> and <code>__to_name</code> contain the names of the source and
destination character sets.  They can be used to identify the actual
conversion to be carried out since one module might implement conversions
for more than one character set and/or direction.
</para>
</dd>
<dt><span><code>gconv_fct __fct</code></span></dt>
<dt><span><code>gconv_init_fct __init_fct</code></span></dt>
<dt><span><code>gconv_end_fct __end_fct</code></span></dt>
<dd><para>These elements contain pointers to the functions in the loadable module.
The interface will be explained below.
</para>
</dd>
<dt><span><code>int __min_needed_from</code></span></dt>
<dt><span><code>int __max_needed_from</code></span></dt>
<dt><span><code>int __min_needed_to</code></span></dt>
<dt><span><code>int __max_needed_to;</code></span></dt>
<dd><para>These values have to be supplied in the init function of the module.  The
<code>__min_needed_from</code> value specifies how many bytes a character of
the source character set at least needs.  The <code>__max_needed_from</code>
specifies the maximum value that also includes possible shift sequences.
</para>
<para>The <code>__min_needed_to</code> and <code>__max_needed_to</code> values serve the
same purpose as <code>__min_needed_from</code> and <code>__max_needed_from</code> but
this time for the destination character set.
</para>
<para>It is crucial that these values be accurate since otherwise the
conversion functions will have problems or not work at all.
</para>
</dd>
<dt><span><code>int __stateful</code></span></dt>
<dd><para>This element must also be initialized by the init function.
<code>int __stateful</code> is nonzero if the source character set is stateful.
Otherwise it is zero.
</para>
</dd>
<dt><span><code>void *__data</code></span></dt>
<dd><para>This element can be used freely by the conversion functions in the
module.  <code>void *__data</code> can be used to communicate extra information
from one call to another.  <code>void *__data</code> need not be initialized if
not needed at all.  If <code>void *__data</code> element is assigned a pointer
to dynamically allocated memory (presumably in the init function) it has
to be made sure that the end function deallocates the memory.  Otherwise
the application will leak memory.
</para>
<para>It is important to be aware that this data structure is shared by all
users of this specification conversion and therefore the <code>__data</code>
element must not contain data specific to one specific use of the
conversion function.
</para></dd>
</dl>
</dd></dl>

<dl class="def">
<dt xml:id="glibc-index-struct-_005f_005fgconv_005fstep_005fdata"><span class="category">Data type: </span><span><strong>struct __gconv_step_data</strong><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-struct-_005f_005fgconv_005fstep_005fdata" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>This is the data structure that contains the information specific to
each use of the conversion functions.
</para>

<dl compact="compact">
<dt><span><code>char *__outbuf</code></span></dt>
<dt><span><code>char *__outbufend</code></span></dt>
<dd><para>These elements specify the output buffer for the conversion step.  The
<code>__outbuf</code> element points to the beginning of the buffer, and
<code>__outbufend</code> points to the byte following the last byte in the
buffer.  The conversion function must not assume anything about the size
of the buffer but it can be safely assumed there is room for at
least one complete character in the output buffer.
</para>
<para>Once the conversion is finished, if the conversion is the last step, the
<code>__outbuf</code> element must be modified to point after the last byte
written into the buffer to signal how much output is available.  If this
conversion step is not the last one, the element must not be modified.
The <code>__outbufend</code> element must not be modified.
</para>
</dd>
<dt><span><code>int __is_last</code></span></dt>
<dd><para>This element is nonzero if this conversion step is the last one.  This
information is necessary for the recursion.  See the description of the
conversion function internals below.  This element must never be
modified.
</para>
</dd>
<dt><span><code>int __invocation_counter</code></span></dt>
<dd><para>The conversion function can use this element to see how many calls of
the conversion function already happened.  Some character sets require a
certain prolog when generating output, and by comparing this value with
zero, one can find out whether it is the first call and whether,
therefore, the prolog should be emitted.  This element must never be
modified.
</para>
</dd>
<dt><span><code>int __internal_use</code></span></dt>
<dd><para>This element is another one rarely used but needed in certain
situations.  It is assigned a nonzero value in case the conversion
functions are used to implement <code>mbsrtowcs</code> et.al. (i.e., the
function is not used directly through the <code>iconv</code> interface).
</para>
<para>This sometimes makes a difference as it is expected that the
<code>iconv</code> functions are used to translate entire texts while the
<code>mbsrtowcs</code> functions are normally used only to convert single
strings and might be used multiple times to convert entire texts.
</para>
<para>But in this situation we would have problem complying with some rules of
the character set specification.  Some character sets require a prolog,
which must appear exactly once for an entire text.  If a number of
<code>mbsrtowcs</code> calls are used to convert the text, only the first call
must add the prolog.  However, because there is no communication between the
different calls of <code>mbsrtowcs</code>, the conversion functions have no
possibility to find this out.  The situation is different for sequences
of <code>iconv</code> calls since the handle allows access to the needed
information.
</para>
<para>The <code>int __internal_use</code> element is mostly used together with
<code>__invocation_counter</code> as follows:
</para>
<div class="example">
<pre class="example">if (!data-&gt;__internal_use
     &amp;&amp; data-&gt;__invocation_counter == 0)
  /* <span class="roman">Emit prolog.</span>  */
  …
</pre></div>

<para>This element must never be modified.
</para>
</dd>
<dt><span><code>mbstate_t *__statep</code></span></dt>
<dd><para>The <code>__statep</code> element points to an object of type <code>mbstate_t</code>
(see <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Keeping-the-state">Representing the state of the conversion</a>).  The conversion of a stateful character
set must use the object pointed to by <code>__statep</code> to store
information about the conversion state.  The <code>__statep</code> element
itself must never be modified.
</para>
</dd>
<dt><span><code>mbstate_t __state</code></span></dt>
<dd><para>This element must <emphasis>never</emphasis> be used directly.  It is only part of
this structure to have the needed space allocated.
</para></dd>
</dl>
</dd></dl>

</div>
<div class="subsubsection" xml:id="glibc-iconv-module-interfaces">
<h4 class="subsubsection">6.5.4.4 <code>iconv</code> module interfaces</title>

<para>With the knowledge about the data structures we now can describe the
conversion function itself.  To understand the interface a bit of
knowledge is necessary about the functionality in the C library that
loads the objects with the conversions.
</para>
<para>It is often the case that one conversion is used more than once (i.e.,
there are several <code>iconv_open</code> calls for the same set of character
sets during one program run).  The <code>mbsrtowcs</code> et.al. functions in
the GNU C Library also use the <code>iconv</code> functionality, which
increases the number of uses of the same functions even more.
</para>
<para>Because of this multiple use of conversions, the modules do not get
loaded exclusively for one conversion.  Instead a module once loaded can
be used by an arbitrary number of <code>iconv</code> or <code>mbsrtowcs</code> calls
at the same time.  The splitting of the information between conversion-
function-specific information and conversion data makes this possible.
The last section showed the two data structures used to do this.
</para>
<para>This is of course also reflected in the interface and semantics of the
functions that the modules must provide.  There are three functions that
must have the following names:
</para>
<dl compact="compact">
<dt><span><code>gconv_init</code></span></dt>
<dd><para>The <code>gconv_init</code> function initializes the conversion function
specific data structure.  This very same object is shared by all
conversions that use this conversion and, therefore, no state information
about the conversion itself must be stored in here.  If a module
implements more than one conversion, the <code>gconv_init</code> function will
be called multiple times.
</para>
</dd>
<dt><span><code>gconv_end</code></span></dt>
<dd><para>The <code>gconv_end</code> function is responsible for freeing all resources
allocated by the <code>gconv_init</code> function.  If there is nothing to do,
this function can be missing.  Special care must be taken if the module
implements more than one conversion and the <code>gconv_init</code> function
does not allocate the same resources for all conversions.
</para>
</dd>
<dt><span><code>gconv</code></span></dt>
<dd><para>This is the actual conversion function.  It is called to convert one
block of text.  It gets passed the conversion step information
initialized by <code>gconv_init</code> and the conversion data, specific to
this use of the conversion functions.
</para></dd>
</dl>

<para>There are three data types defined for the three module interface
functions and these define the interface.
</para>
<dl class="def">
<dt xml:id="glibc-index-_0028_002a_005f_005fgconv_005finit_005ffct_0029"><span class="category">Data type: </span><span><emphasis>int</emphasis> <strong>(*__gconv_init_fct)</strong> <emphasis>(struct __gconv_step *)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-_0028_002a_005f_005fgconv_005finit_005ffct_0029" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>This specifies the interface of the initialization function of the
module.  It is called exactly once for each conversion the module
implements.
</para>
<para>As explained in the description of the <code>struct __gconv_step</code> data
structure above the initialization function has to initialize parts of
it.
</para>
<dl compact="compact">
<dt><span><code>__min_needed_from</code></span></dt>
<dt><span><code>__max_needed_from</code></span></dt>
<dt><span><code>__min_needed_to</code></span></dt>
<dt><span><code>__max_needed_to</code></span></dt>
<dd><para>These elements must be initialized to the exact numbers of the minimum
and maximum number of bytes used by one character in the source and
destination character sets, respectively.  If the characters all have the
same size, the minimum and maximum values are the same.
</para>
</dd>
<dt><span><code>__stateful</code></span></dt>
<dd><para>This element must be initialized to a nonzero value if the source
character set is stateful.  Otherwise it must be zero.
</para></dd>
</dl>

<para>If the initialization function needs to communicate some information
to the conversion function, this communication can happen using the
<code>__data</code> element of the <code>__gconv_step</code> structure.  But since
this data is shared by all the conversions, it must not be modified by
the conversion function.  The example below shows how this can be used.
</para>
<div class="example">
<pre class="example">#define MIN_NEEDED_FROM         1
#define MAX_NEEDED_FROM         4
#define MIN_NEEDED_TO           4
#define MAX_NEEDED_TO           4

int
gconv_init (struct __gconv_step *step)
{
  /* <span class="roman">Determine which direction.</span>  */
  struct iso2022jp_data *new_data;
  enum direction dir = illegal_dir;
  enum variant var = illegal_var;
  int result;

  if (__strcasecmp (step-&gt;__from_name, "ISO-2022-JP//") == 0)
    {
      dir = from_iso2022jp;
      var = iso2022jp;
    }
  else if (__strcasecmp (step-&gt;__to_name, "ISO-2022-JP//") == 0)
    {
      dir = to_iso2022jp;
      var = iso2022jp;
    }
  else if (__strcasecmp (step-&gt;__from_name, "ISO-2022-JP-2//") == 0)
    {
      dir = from_iso2022jp;
      var = iso2022jp2;
    }
  else if (__strcasecmp (step-&gt;__to_name, "ISO-2022-JP-2//") == 0)
    {
      dir = to_iso2022jp;
      var = iso2022jp2;
    }

  result = __GCONV_NOCONV;
  if (dir != illegal_dir)
    {
      new_data = (struct iso2022jp_data *)
        malloc (sizeof (struct iso2022jp_data));

      result = __GCONV_NOMEM;
      if (new_data != NULL)
        {
          new_data-&gt;dir = dir;
          new_data-&gt;var = var;
          step-&gt;__data = new_data;

          if (dir == from_iso2022jp)
            {
              step-&gt;__min_needed_from = MIN_NEEDED_FROM;
              step-&gt;__max_needed_from = MAX_NEEDED_FROM;
              step-&gt;__min_needed_to = MIN_NEEDED_TO;
              step-&gt;__max_needed_to = MAX_NEEDED_TO;
            }
          else
            {
              step-&gt;__min_needed_from = MIN_NEEDED_TO;
              step-&gt;__max_needed_from = MAX_NEEDED_TO;
              step-&gt;__min_needed_to = MIN_NEEDED_FROM;
              step-&gt;__max_needed_to = MAX_NEEDED_FROM + 2;
            }

          /* <span class="roman">Yes, this is a stateful encoding.</span>  */
          step-&gt;__stateful = 1;

          result = __GCONV_OK;
        }
    }

  return result;
}
</pre></div>

<para>The function first checks which conversion is wanted.  The module from
which this function is taken implements four different conversions;
which one is selected can be determined by comparing the names.  The
comparison should always be done without paying attention to the case.
</para>
<para>Next, a data structure, which contains the necessary information about
which conversion is selected, is allocated.  The data structure
<code>struct iso2022jp_data</code> is locally defined since, outside the
module, this data is not used at all.  Please note that if all four
conversions this module supports are requested there are four data
blocks.
</para>
<para>One interesting thing is the initialization of the <code>__min_</code> and
<code>__max_</code> elements of the step data object.  A single ISO-2022-JP
character can consist of one to four bytes.  Therefore the
<code>MIN_NEEDED_FROM</code> and <code>MAX_NEEDED_FROM</code> macros are defined
this way.  The output is always the <code>INTERNAL</code> character set (aka
UCS-4) and therefore each character consists of exactly four bytes.  For
the conversion from <code>INTERNAL</code> to ISO-2022-JP we have to take into
account that escape sequences might be necessary to switch the character
sets.  Therefore the <code>__max_needed_to</code> element for this direction
gets assigned <code>MAX_NEEDED_FROM + 2</code>.  This takes into account the
two bytes needed for the escape sequences to signal the switching.  The
asymmetry in the maximum values for the two directions can be explained
easily: when reading ISO-2022-JP text, escape sequences can be handled
alone (i.e., it is not necessary to process a real character since the
effect of the escape sequence can be recorded in the state information).
The situation is different for the other direction.  Since it is in
general not known which character comes next, one cannot emit escape
sequences to change the state in advance.  This means the escape
sequences have to be emitted together with the next character.
Therefore one needs more room than only for the character itself.
</para>
<para>The possible return values of the initialization function are:
</para>
<dl compact="compact">
<dt><span><code>__GCONV_OK</code></span></dt>
<dd><para>The initialization succeeded
</para></dd>
<dt><span><code>__GCONV_NOCONV</code></span></dt>
<dd><para>The requested conversion is not supported in the module.  This can
happen if the <filename>gconv-modules</filename> file has errors.
</para></dd>
<dt><span><code>__GCONV_NOMEM</code></span></dt>
<dd><para>Memory required to store additional information could not be allocated.
</para></dd>
</dl>
</dd></dl>

<para>The function called before the module is unloaded is significantly
easier.  It often has nothing at all to do; in which case it can be left
out completely.
</para>
<dl class="def">
<dt xml:id="glibc-index-_0028_002a_005f_005fgconv_005fend_005ffct_0029"><span class="category">Data type: </span><span><emphasis>void</emphasis> <strong>(*__gconv_end_fct)</strong> <emphasis>(struct gconv_step *)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-_0028_002a_005f_005fgconv_005fend_005ffct_0029" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>The task of this function is to free all resources allocated in the
initialization function.  Therefore only the <code>__data</code> element of
the object pointed to by the argument is of interest.  Continuing the
example from the initialization function, the finalization function
looks like this:
</para>
<div class="example">
<pre class="example">void
gconv_end (struct __gconv_step *data)
{
  free (data-&gt;__data);
}
</pre></div>
</dd></dl>

<para>The most important function is the conversion function itself, which can
get quite complicated for complex character sets.  But since this is not
of interest here, we will only describe a possible skeleton for the
conversion function.
</para>
<dl class="def">
<dt xml:id="glibc-index-_0028_002a_005f_005fgconv_005ffct_0029"><span class="category">Data type: </span><span><emphasis>int</emphasis> <strong>(*__gconv_fct)</strong> <emphasis>(struct __gconv_step *, struct __gconv_step_data *, const char **, const char *, size_t *, int)</emphasis><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-_0028_002a_005f_005fgconv_005ffct_0029" class="copiable-anchor"> ¶</a></span></dt>
<dd>
<para>The conversion function can be called for two basic reasons: to convert
text or to reset the state.  From the description of the <code>iconv</code>
function it can be seen why the flushing mode is necessary.  What mode
is selected is determined by the sixth argument, an integer.  This
argument being nonzero means that flushing is selected.
</para>
<para>Common to both modes is where the output buffer can be found.  The
information about this buffer is stored in the conversion step data.  A
pointer to this information is passed as the second argument to this
function.  The description of the <code>struct __gconv_step_data</code>
structure has more information on the conversion step data.
</para>
<span xml:id="glibc-index-stateful-5"></span>
<para>What has to be done for flushing depends on the source character set.
If the source character set is not stateful, nothing has to be done.
Otherwise the function has to emit a byte sequence to bring the state
object into the initial state.  Once this all happened the other
conversion modules in the chain of conversions have to get the same
chance.  Whether another step follows can be determined from the
<code>__is_last</code> element of the step data structure to which the first
parameter points.
</para>
<para>The more interesting mode is when actual text has to be converted.  The
first step in this case is to convert as much text as possible from the
input buffer and store the result in the output buffer.  The start of the
input buffer is determined by the third argument, which is a pointer to a
pointer variable referencing the beginning of the buffer.  The fourth
argument is a pointer to the byte right after the last byte in the buffer.
</para>
<para>The conversion has to be performed according to the current state if the
character set is stateful.  The state is stored in an object pointed to
by the <code>__statep</code> element of the step data (second argument).  Once
either the input buffer is empty or the output buffer is full the
conversion stops.  At this point, the pointer variable referenced by the
third parameter must point to the byte following the last processed
byte (i.e., if all of the input is consumed, this pointer and the fourth
parameter have the same value).
</para>
<para>What now happens depends on whether this step is the last one.  If it is
the last step, the only thing that has to be done is to update the
<code>__outbuf</code> element of the step data structure to point after the
last written byte.  This update gives the caller the information on how
much text is available in the output buffer.  In addition, the variable
pointed to by the fifth parameter, which is of type <code>size_t</code>, must
be incremented by the number of characters (<emphasis>not bytes</emphasis>) that were
converted in a non-reversible way.  Then, the function can return.
</para>
<para>In case the step is not the last one, the later conversion functions have
to get a chance to do their work.  Therefore, the appropriate conversion
function has to be called.  The information about the functions is
stored in the conversion data structures, passed as the first parameter.
This information and the step data are stored in arrays, so the next
element in both cases can be found by simple pointer arithmetic:
</para>
<div class="example">
<pre class="example">int
gconv (struct __gconv_step *step, struct __gconv_step_data *data,
       const char **inbuf, const char *inbufend, size_t *written,
       int do_flush)
{
  struct __gconv_step *next_step = step + 1;
  struct __gconv_step_data *next_data = data + 1;
  …
</pre></div>

<para>The <code>next_step</code> pointer references the next step information and
<code>next_data</code> the next data record.  The call of the next function
therefore will look similar to this:
</para>
<div class="example">
<pre class="example">  next_step-&gt;__fct (next_step, next_data, &amp;outerr, outbuf,
                    written, 0)
</pre></div>

<para>But this is not yet all.  Once the function call returns the conversion
function might have some more to do.  If the return value of the function
is <code>__GCONV_EMPTY_INPUT</code>, more room is available in the output
buffer.  Unless the input buffer is empty, the conversion functions start
all over again and process the rest of the input buffer.  If the return
value is not <code>__GCONV_EMPTY_INPUT</code>, something went wrong and we have
to recover from this.
</para>
<para>A requirement for the conversion function is that the input buffer
pointer (the third argument) always point to the last character that
was put in converted form into the output buffer.  This is trivially
true after the conversion performed in the current step, but if the
conversion functions deeper downstream stop prematurely, not all
characters from the output buffer are consumed and, therefore, the input
buffer pointers must be backed off to the right position.
</para>
<para>Correcting the input buffers is easy to do if the input and output
character sets have a fixed width for all characters.  In this situation
we can compute how many characters are left in the output buffer and,
therefore, can correct the input buffer pointer appropriately with a
similar computation.  Things are getting tricky if either character set
has characters represented with variable length byte sequences, and it
gets even more complicated if the conversion has to take care of the
state.  In these cases the conversion has to be performed once again, from
the known state before the initial conversion (i.e., if necessary the
state of the conversion has to be reset and the conversion loop has to be
executed again).  The difference now is that it is known how much input
must be created, and the conversion can stop before converting the first
unused character.  Once this is done the input buffer pointers must be
updated again and the function can return.
</para>
<para>One final thing should be mentioned.  If it is necessary for the
conversion to know whether it is the first invocation (in case a prolog
has to be emitted), the conversion function should increment the
<code>__invocation_counter</code> element of the step data structure just
before returning to the caller.  See the description of the <code>struct
__gconv_step_data</code> structure above for more information on how this can
be used.
</para>
<para>The return value must be one of the following values:
</para>
<dl compact="compact">
<dt><span><code>__GCONV_EMPTY_INPUT</code></span></dt>
<dd><para>All input was consumed and there is room left in the output buffer.
</para></dd>
<dt><span><code>__GCONV_FULL_OUTPUT</code></span></dt>
<dd><para>No more room in the output buffer.  In case this is not the last step
this value is propagated down from the call of the next conversion
function in the chain.
</para></dd>
<dt><span><code>__GCONV_INCOMPLETE_INPUT</code></span></dt>
<dd><para>The input buffer is not entirely empty since it contains an incomplete
character sequence.
</para></dd>
</dl>

<para>The following example provides a framework for a conversion function.
In case a new conversion has to be written the holes in this
implementation have to be filled and that is it.
</para>
<div class="example">
<pre class="example">int
gconv (struct __gconv_step *step, struct __gconv_step_data *data,
       const char **inbuf, const char *inbufend, size_t *written,
       int do_flush)
{
  struct __gconv_step *next_step = step + 1;
  struct __gconv_step_data *next_data = data + 1;
  gconv_fct fct = next_step-&gt;__fct;
  int status;

  /* <span class="roman">If the function is called with no input this means we have</span>
     <span class="roman">to reset to the initial state.  The possibly partly</span>
     <span class="roman">converted input is dropped.</span>  */
  if (do_flush)
    {
      status = __GCONV_OK;

      /* <span class="roman">Possible emit a byte sequence which put the state object</span>
         <span class="roman">into the initial state.</span>  */

      /* <span class="roman">Call the steps down the chain if there are any but only</span>
         <span class="roman">if we successfully emitted the escape sequence.</span>  */
      if (status == __GCONV_OK &amp;&amp; ! data-&gt;__is_last)
        status = fct (next_step, next_data, NULL, NULL,
                      written, 1);
    }
  else
    {
      /* <span class="roman">We preserve the initial values of the pointer variables.</span>  */
      const char *inptr = *inbuf;
      char *outbuf = data-&gt;__outbuf;
      char *outend = data-&gt;__outbufend;
      char *outptr;

      do
        {
          /* <span class="roman">Remember the start value for this round.</span>  */
          inptr = *inbuf;
          /* <span class="roman">The outbuf buffer is empty.</span>  */
          outptr = outbuf;

          /* <span class="roman">For stateful encodings the state must be safe here.</span>  */

          /* <span class="roman">Run the conversion loop.  <code>status</code> is set</span>
             <span class="roman">appropriately afterwards.</span>  */

          /* <span class="roman">If this is the last step, leave the loop.  There is</span>
             <span class="roman">nothing we can do.</span>  */
          if (data-&gt;__is_last)
            {
              /* <span class="roman">Store information about how many bytes are</span>
                 <span class="roman">available.</span>  */
              data-&gt;__outbuf = outbuf;

             /* <span class="roman">If any non-reversible conversions were performed,</span>
                <span class="roman">add the number to <code>*written</code>.</span>  */

             break;
           }

          /* <span class="roman">Write out all output that was produced.</span>  */
          if (outbuf &gt; outptr)
            {
              const char *outerr = data-&gt;__outbuf;
              int result;

              result = fct (next_step, next_data, &amp;outerr,
                            outbuf, written, 0);

              if (result != __GCONV_EMPTY_INPUT)
                {
                  if (outerr != outbuf)
                    {
                      /* <span class="roman">Reset the input buffer pointer.  We</span>
                         <span class="roman">document here the complex case.</span>  */
                      size_t nstatus;

                      /* <span class="roman">Reload the pointers.</span>  */
                      *inbuf = inptr;
                      outbuf = outptr;

                      /* <span class="roman">Possibly reset the state.</span>  */

                      /* <span class="roman">Redo the conversion, but this time</span>
                         <span class="roman">the end of the output buffer is at</span>
                         <span class="roman"><code>outerr</code>.</span>  */
                    }

                  /* <span class="roman">Change the status.</span>  */
                  status = result;
                }
              else
                /* <span class="roman">All the output is consumed, we can make</span>
                   <span class="roman"> another run if everything was ok.</span>  */
                if (status == __GCONV_FULL_OUTPUT)
                  status = __GCONV_OK;
           }
        }
      while (status == __GCONV_OK);

      /* <span class="roman">We finished one use of this step.</span>  */
      ++data-&gt;__invocation_counter;
    }

  return status;
}
</pre></div>
</dd></dl>

<para>This information should be sufficient to write new modules.  Anybody
doing so should also take a look at the available source code in the
GNU C Library sources.  It contains many examples of working and optimized
modules.
</para>
<hr>
</div>
</div>
</div-->
 </chapter>
</part>
