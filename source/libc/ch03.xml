<?xml version="1.0" encoding="UTF-8"?>
<?xml-model href="../docbook/dtd/belgeler.rng"?>
<?xml-model href="../docbook/dtd/belgeler.dtd"?>
<!-- ********************************************************************
        glibc/ch03.xml,v2.36, GFDL,LGPL, NBB, 2023
     ******************************************************************** -->
<part xml:id="glibc-Memory" xmlns="http://docbook.org/ns/docbook" version="5.0"
xmlns:xl="http://www.w3.org/1999/xlink" xml:lang="tr" userlevel="longtoc">
 <title>Sanal Belleğin Tahsisi ve Sayfalama</title>
 <titleabbrev>Sanal belleğin tahsisi ve sayfalamanın denetimi.</titleabbrev>
 <preliminary>
  <para>
   <dicterm><english>memory</english><turkish>bellek</turkish></dicterm>
   <indexterm linkend="glibc-cp"><primary>bellek tahsisi</primary></indexterm>
   <indexterm linkend="glibc-cp"><primary>saklama alanı tahsisi</primary></indexterm>
   Bu kısımda &glibc; kullanılan bir sistemde süreçlerin belleği nasıl yönettiğini ve kullandığını açıklanmıştır.
  </para>
  <para>
   &glibc; sanal belleği farklı yollarla özdevimli tahsis etmek için çeşitli işlevler içerir. Bunlar genellik ve verimlilik bakımından farklılık gösterir. Kütüphane ayrıca gerçek belleğin tahsisi ve sayfalamanın denetlenmesi için de işlevler sağlar.
  </para>
  <para>
   <xref linkend="glibc-Memory-mapped-I-O"/> bu kısımda ele alınmamıştır.
  </para>
 </preliminary>
 <chapter xml:id="glibc-Memory-Concepts">
  <title>Süreç Belleği Kavramları</title>
  <titleabbrev>Kavramlara ve terminolojiye bir bakış.</titleabbrev>
  <para>
   <dicterm><english>frame</english><turkish>çerçeve</turkish></dicterm>
   <dicterm><english>frame</english><turkish>gerçek bellek sayfası</turkish></dicterm>
   Bir sürecin kullanabildiği en temel öz kaynaklardan biri bellektir. Sistemlerin belleği düzenlemesi için çok çeşitli yollar olmakla birlikte, genellikle tercih edilen,  sıfırdan çok büyük değerlere kadar büyüyebilen adreslerle her sürecin bir doğrusal sanal adres alanına sahip olmasıdır. Bu adres alanının kesintisiz olması gerekmez; yani, bu adreslerin hepsi gerçekte veri saklamak için kullanılmaz.
  </para>
  <para>
   <dicterm><english>swap space</english><turkish>takas alanı</turkish></dicterm>
   Sanal bellek sayfalara bölünmüştür (genellikle 4 kilobaytlık). Sanal bellekteki her sayfa aslında, ya gerçek bellek sayfasıdır (buna <wordasword>çerçeve</wordasword> de denir) ya da ikincil bir saklama alanı olarak çoğunlukla disk alanıdır. Disk alanı, takas alanı olabileceği gibi sıradan bir disk dosyası da olabilir. Gerçekte, bir sayfa tamamen sıfırlardan oluşabilir ve içinde hiçbir şey bulunmayabilir –  yalnızca sayfanın sıfırlardan oluştuğunu belirten bir bayrak vardır.
   <indexterm linkend="glibc-cp"><primary>sayfa çerçevesi</primary></indexterm>
   <indexterm linkend="glibc-cp"><primary>çerçeve</primary><secondary>gerçek bellek</secondary></indexterm>
   <indexterm linkend="glibc-cp"><primary>takas alanı</primary></indexterm>
   <indexterm linkend="glibc-cp"><primary>sayfa</primary><secondary>sanal bellek</secondary></indexterm>
   <indexterm linkend="glibc-cp"><primary>sayfalama</primary></indexterm>
   <dicterm><english>paging</english><turkish>bellek sayfalaması</turkish></dicterm>
  </para>
  <para>
   Gerçek belleğin veya yedekleme alanının aynı çerçevesi çok sayıda sürecin çok sayıda sanal sayfasını destekleyebilir. Bu normal bir durumdur. Örneğin, sanal bellek &glibc; kodu tarafından işgal edilebilir. Bu durumda <command>printf</command> işlevini içeren aynı gerçek bellek çerçevesi, işlevi kullanan çok sayıda sürecin her birinde bir sanal bellek sayfasını destekler.
  </para>
  <para>
   Bir yazılımın bir sanal sayfanın herhangi bir parçasına erişebilmesi için sayfanın o anda ("ilintili") bir gerçek çerçeve tarafından yedeklenmesi gerekir. Ancak gerçekte sanal bellek gerçek bellekten daha büyük olduğundan, sayfaların düzenli olarak, gerçek bellek ile yedekleme deposu arasında ileri ve geri taşınması, bir sürecin onlara erişmesi gerektiğinde gerçek belleğe alınması ve gerek kalmadığında da yedekleme deposuna geri taşınması gerekir. Bu devinime <wordasword>sayfalama</wordasword> denir.
  </para>
  <para>
   <dicterm><english>page fault</english><turkish>sayfa hatası</turkish></dicterm>
   <dicterm><english>paging in</english><turkish>içe sayfalama</turkish></dicterm>
   <dicterm><english>paging out</english><turkish>dışa sayfalama</turkish></dicterm>
   <dicterm><english>faulting in</english><turkish>sayfalama hatası</turkish></dicterm>
   <indexterm linkend="glibc-cp"><primary>sayfa hatası</primary></indexterm>
   <indexterm linkend="glibc-cp"><primary>sayfalama</primary><secondary>gerçek belleğe sayfalama</secondary></indexterm>
   Bir süreç bir sayfaya erişmeye çalışır ve sayfa gerçek belleğe geri taşınamazsa bu olaya <wordasword>sayfa hatası</wordasword> ("page fault") denir.  Bir sayfa hatası oluştuğunda çekirdek süreci askıya alır ve sayfayı bir gerçek sayfa çerçevesine yerleştirir. Bu işleme <wordasword>içe sayfalama</wordasword> ("paging in" veya "faulting in") denir. Bu işlemin ardından artık sayfa gerçek bellekte erişilebilir olduğundan çekirdek tarafından askıya alınan süreç işlemine kaldığı yerden devam ettirilir. Aslında, tüm sayfalar sürece daima gerçek bellekteymiş gibi görünür. Bir şey dışında: bir makine dili komutun yürütme süresi normalde birkaç nano saniye iken birdenbire çok, çok daha uzun hale gelir, çünkü çekirdek sayfalamayla ilgilenmeyi tamamlamak için G/Ç işlemleri yapmak zorundadır. Bu işleme duyarlı yazılımlar için kullanılan denetim işlevleri <xref linkend="glibc-Locking-Pages"/> bölümünde açıklanmıştır.
  </para>
  <para>
   <dicterm><english>memory allocation</english><turkish>belleğin tahsisi</turkish></dicterm>
   Her sanal adres alanı içinde, her sürecin hangi adreslerinde ne olduğunun kaydını tutması gerekir ve bu işleme <wordasword>belleğin tahsis edilmesi</wordasword> denir. Tahsis süreci, genellikle kıt kaynakların dağıtılmasını akla getirir, ancak sanal bellek söz konusu olduğunda, asıl amaç bu değildir, çünkü genellikle ihtiyaç duyulandan çok daha fazlası vardır. Belleğin tahsisi işlemi, aslında, aynı bellek baytının iki farklı şeyi depolamak için kullanılmadığından emin olunmasını amaçlar.
  </para>
  <para>
   <dicterm><english>forking</english><turkish>çatallama</turkish></dicterm>
   Süreçler belleği iki farklı yolla tahsis eder: işletim (exec) sırasında ve yazılımsal olarak. Aslında, <link linkend="glibc-Creating-a-Process">çatallama</link> üçüncü bir yol olmakla beraber pek ilginç değildir.
  </para>
  <para>
   İşletim (exec), süreç için sanal adres alanının oluşturulması, ana yazılımın bu alana yüklenmesi ve yazılımın çalıştırması işlemidir. Bu, "exec" ailesi işlevlerle (örn, <function>execl</function>) yapılır. İşlem bir yazılım dosyası (işletilebilir dosya) alır, dosya içindeki tüm verinin yükleneceği bellek alanını ayırıp veriyi yükledikten sonra denetimi yazılıma aktarır. Bu veri çoğunlukla yazılımın (<wordasword>metin</wordasword>) komutlarından  oluşmakla birlikte yazılımdaki sayıllar, sabitler ve hatta bazı değişkenleri de içerir: Duruk depolama sınıfı C değişkenleri. Bkz. <xref linkend="glibc-Memory-Allocation-and-C"/>.
   <indexterm linkend="glibc-cp"><primary>işletilebilir dosya</primary></indexterm>
   <indexterm linkend="glibc-cp"><primary>sayıllar</primary></indexterm>
   <indexterm linkend="glibc-cp"><primary>sabitler</primary></indexterm>
  </para>
  <para>
   Yazılım işletilmeye başladıktan sonra ek bellek kazanmak için yazılımsal bellek tahsisi  yapar. &glibc; kullanan bir C yazılımında, iki çeşit yazılımsal bellek tahsisi yapılabilir: özdevinimli (otomatik) ve özdevimli (dinamik). Bkz. <xref linkend="glibc-Memory-Allocation-and-C"/>.
  </para>
  <para>
   Bellek eşlemli G/Ç diğer bir özdevimli sanal bellek tahsis çeşididir.  Belleğin bir dosyaya eşlenmesi, bir sürecin belli bir adres aralığındaki içeriğinin belirtilen normal bir dosyanın içeriği ile eşdeğerde olacağının  bildirilmesidir. Sistem sanal belleğin dosyanın içeriğini içermesini sağlar ve eğer yazılımcı bellekte değişiklik yaparsa sistem aynı değişiklikleri dosyaya yazar. Sanal belleğin sihiri ve sayfa hatalarının sonuçlarından dolayı, yazılım sanal belleğe erişinceye kadar, sistemin dosyayı okumak için G/Ç işlemleri yapmasına ve dosya içeriği için gerçek belleği tahsis etmesine sebep yoktur. Bkz. <xref linkend="glibc-Memory-mapped-I-O"/>.
   <indexterm linkend="glibc-cp"><primary>bellek eşlemli G/Ç</primary></indexterm>
   <indexterm linkend="glibc-cp"><primary>bellek eşlemli dosya</primary></indexterm>
   <indexterm linkend="glibc-cp"><primary>dosyalar</primary><secondary>erişim</secondary></indexterm>
  </para>
  <para>
   Belleği yazılımsal olarak tahsis edebilen yazılım, belleği yazılımsal olarak serbest de bırakabilir. İşletim (exec) ile tahsis edilen belleği yazılımcı serbest bırakamaz. Ancak yazılımın çalışması sonlandırılır (exit) veya yeniden başlatılırsa (exec) tahsis edilen tüm belleğin serbest kaldığından söz edilebilir, ancak her iki durumda da adres alanının varlığı sona erdiğinden bu konu gerçekten tartışmalıdır. Bkz. <xref linkend="glibc-Program-Termination"/>.
   <indexterm linkend="glibc-cp"><primary>yazılım</primary><secondary>işletme</secondary></indexterm>
   <indexterm linkend="glibc-cp"><primary>yazılım</primary><secondary>sonlanma</secondary></indexterm>
   <indexterm linkend="glibc-cp"><primary>bellek</primary><secondary>serbest bırakma</secondary></indexterm>
   <indexterm linkend="glibc-cp"><primary>bellek</primary><secondary>tahsisi</secondary></indexterm>
  </para>
  <para>
   <dicterm><english>text segment</english><turkish>metin bölütü (bir sürecin sanal adres alanlarından biri)</turkish></dicterm>
   <dicterm><english>data segment</english><turkish>veri bölütü (bir sürecin sanal adres alanlarından biri)</turkish></dicterm>
   <dicterm><english>stack segment</english><turkish>yığıt bölütü (bir sürecin sanal adres alanlarından biri)</turkish></dicterm>
   Bir sürecin sanal adres alanı bölütlere ayrılmıştır. Bölüt, kesintisiz bir sanal adres aralığıdır. Üç önemli <wordasword>bölüt</wordasword> vardır:
  </para>
  <glosslist>
   <glossentry>
    <indexterm linkend="glibc-cp" xml:id="glibc-text-segment"><primary>bölütler</primary><secondary>metin bölütü</secondary></indexterm>
    <glossterm>metin bölütü</glossterm>
    <glossdef>
     <para>
      Bir yazılımın komutlarını, sayıllarını ve duruk sabitlerini içerir. Yazılımın işletimi (exec) sırasında tahsis edilir ve sanal adres alanının yaşamı boyunca aynı boyutta kalır.
     </para>
    </glossdef>
   </glossentry>
   <glossentry>
    <indexterm linkend="glibc-cp" xml:id="glibc-data-segment"><primary>bölütler</primary><secondary>veri bölütü</secondary></indexterm>
    <glossterm>veri bölütü</glossterm>
    <glossdef>
     <para>
      Yazılımın çalışma deposudur. İlk tahsis ve ilk yükleme işlemi işletim (exec) sırasında yapılır ve süreç tarafından <xref linkend="glibc-Resizing-the-Data-Segment"/> bölümünde açıklandığı gibi genişletilebilir veya daraltılabilir. Alt uç sabittir.
     </para>
    </glossdef>
   </glossentry>
   <glossentry>
    <indexterm linkend="glibc-cp" xml:id="glibc-stack-segment"><primary>bölütler</primary><secondary>yığıt bölütü</secondary></indexterm>
    <glossterm>yığıt bölütü</glossterm>
    <glossdef>
     <para>
      Yazılım yığıtını içerir. Yığıtın büyüdüğü gibi büyür ama küçüldüğü gibi küçülmez.
     </para>
    </glossdef>
   </glossentry>
  </glosslist>
 </chapter>

 <chapter xml:id="glibc-Memory-Allocation">
  <title>Belleğin Tahsisi</title>
  <titleabbrev>Yazılım verisine saklama alanı tahsisi</titleabbrev>
  <preliminary>
   <para>
    Bu bölümde sıradan yazılımların kendi verilerini nasıl yönettiğinden, ünlü <function>malloc</function> işlevi ile &glibc; ve GNU derleyicisine özel oluşumlardan bahsedilmiştir.
   </para>
  </preliminary>
  <sect1 xml:id="glibc-Memory-Allocation-and-C" userlevel="notoc">
   <?dbhtml stop-chunking?>
   <title>C Yazılımlarında Belleğin Tahsisi</title>
   <titleabbrev>C dilindeki bellek tahsis işlemleri.</titleabbrev>
   <para>
    <dicterm><english>static allocation</english><turkish>duruk bellek tahsisi</turkish></dicterm>
    <dicterm><english>static allocation</english><turkish>duruk ve genel değişkenler için bellek tahsisi</turkish></dicterm>
    <dicterm><english>automatic allocation</english><turkish>özdevinimli bellek tahsisi</turkish></dicterm>
    <dicterm><english>automatic allocation</english><turkish>özdevinimli değişkenler için bellek tahsis</turkish></dicterm>
    C dili, C yazılımlarındaki değişkenler aracılığıyla iki çeşit bellek tahsisini destekler:
   </para>
   <glosslist>
    <glossentry>
     <indexterm linkend="glibc-cp"><primary>bellek</primary><secondary>tahsis</secondary><tertiary>duruk</tertiary></indexterm>
     <indexterm linkend="glibc-cp" xml:id="glibc-static-alloc"><primary>duruk bellek tahsisi</primary></indexterm>
     <indexterm linkend="glibc-cp"><primary>duruk saklama sınıfı</primary></indexterm>
     <glossterm>duruk bellek tahsisi</glossterm>
     <glossdef>
      <para>
       Duruk (static) veya genel (global) değişken tanımlarında duruk tahsis yapılır. Her duruk veya genel değişken sabit uzunlukta bir bellek dilimi tanımlar. Bu dilim, yazılım ilk çalıştırıldığında (işletim sırasında) bir kere tahsis edilir ve asla serbest bırakılmaz.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <indexterm linkend="glibc-cp"><primary>bellek</primary><secondary>tahsis</secondary><tertiary>özdevinimli</tertiary></indexterm>
     <indexterm linkend="glibc-cp" xml:id="glibc-automatic-alloc"><primary>özdevinimli bellek tahsisi</primary></indexterm>
     <indexterm linkend="glibc-cp"><primary>özdevinimli saklama sınıfı</primary></indexterm>
     <glossterm>Özdevinimli bellek tahsisi</glossterm>
     <glossdef>
      <para>
       İşlev bağımsız değişkeni ya da yerel değişken gibi özdevinimli bir değişken için özdevinimli bellek tahsisi uygulanır. Bir özdevinimli (automatic) değişken için  bellek alanı bir birleşik deyim bildirimine girildiğinde tahsis edilir ve birleşik deyimin çalışması sona erdiğinde serbest bırakılır.
      </para>
      <para>
       GNU C'de  özdevinimli saklama alanının uzunluğu ifade ile belirtilebilir ve değiştirilebilir.  Diğer C gerçeklenimlerinde bu uzunluk sabit olmalıdır.
      </para>
     </glossdef>
    </glossentry>
   </glosslist>
   <para>
    <indexterm linkend="glibc-cp" xml:id="glibc-dynamic-alloc"><primary>özdevimli bellek tahsisi</primary></indexterm>
    Üçüncü bir bellek tahsis türü ise C değişkenleri tarafından desteklenmeyen ama &glibc; işlevleri üzerinden kullanılabilen <wordasword>özdevimli bellek tahsisi</wordasword>dir.
   </para>
   <sect2 xml:id="glibc-Dynamic-Memory-Allocation">
    <title>Özdevimli Bellek Tahsisi</title>
    <para>
     <indexterm linkend="glibc-cp"><primary>bellek</primary><secondary>tahsis</secondary><tertiary>özdevimli</tertiary></indexterm>
     <dicterm><english>dynamic allocation</english><turkish>özdevimli bellek tahsisi</turkish></dicterm>
     <dicterm><english>dynamic allocation</english><turkish>malloc ile bellek tahsisi</turkish></dicterm>
     <dicterm><english>dynamic allocation</english><turkish>gösterici ile bellek tahsisi</turkish></dicterm>
     <dicterm><english>heap</english><turkish>özdevimli bellek</turkish></dicterm>
     <emphasis>Özdevimli (dynamic) bellek tahsisi</emphasis>, yazılımların çalışması sırasında bazı bilgilerin saklanacağı yeri belirleyebilmesini sağlayan bir tekniktir. Yazılımın bellek ihtiyacı olduğunda ancak ne kadar bellek ihtiyacı olacağı baştan belli olmayan durumlarda bu teknik faydalıdır.
    </para>
    <para>
     Örneğin, bir girdi dosyasından okunan bir satırın saklanması gerekebilir; bir satırın uzunluğunun belli bir sınırı olmadığından belleğin özdevimli olarak tahsisi ve satırdan daha fazlasının okunması gerekirse özdevimli olarak bu alanı büyütülmesi gerekebilir.
    </para>
    <para>
     Veya, veri girdisi olarak her kayıt ya da her tanım için bir dilim gerekebilir; bunlardan kaç tane olacağı baştan bilinemeyeceğinden, her yeni kayıt için veya okunan her yeni tanımda yeni bir dilim tahsisi gerekir.
    </para>
    <para>
     Özdevimli bellek tahsisinde, bir bellek diliminin tahsisi yazılımın doğrudan istediği bir eylemdir. Alanın tahsisi gerektiğinde istenen uzunluğu bir bağımsız değişken olarak belirterek bir işlev ya da makro çağrılabilir. Bu alanın serbest bırakılması gerektiğinde ise başka bir işlev ya da makro çağrılabilir. Tüm bu işlemler istenen zamanda ve sıklıkta yapılabilir.
    </para>
    <para>
     C değişkenlerinde "dynamic" isminde bir saklama sınıfı olmadığından özdevimli tahsis C değikenlerinde desteklenmez ve değeri özdevimli tahsis edilmiş alanda depolanan bir C değişkeni asla olamaz. Özdevimli tahsis edilmiş bellek almanın tek yolu bir sistem çağrısı üzerinden almak (bu sistem çağrısı genellikle &glibc;nin bir işlevi üzerinden yapılır) ve ona erişmenin tek yolu da bir gösterici kullanmaktır. Daha az kullanışlı olduğundan ve özdevimli bellek tahsis işlemi daha fazla hesaplama gerektirdiğinden özdevimli tahsis sadece duruk ya da özdevinimli bellek tahsisi uygulanamadığında kullanılır.
    </para>
    <para>
     Örneğin, <code>struct foobar</code> için özdevimli olarak bellek tahsisi yapılmak istenirse, bu alandaki içerik için <code>struct foobar</code> türünde bir değişken bildirilemez. Ama <code>struct foobar *</code> gösterici türünden bir değişken bildirebilir ve bu alanın adresi ona değer olarak atanabilir. Sonra da bu alandaki içeriğe erişmek için <code>*</code> ve <code>-></code> işleçleri kullanılabilir:
    </para>
    <example>
<screen>{
  struct foobar *ptr = malloc (sizeof *ptr);
  ptr-&gt;name = x;
  ptr-&gt;next = current_foobar;
  current_foobar = ptr;
}
</screen>
    </example>
   </sect2>
  </sect1>
  <sect1 xml:id="glibc-The-GNU-Allocator">
   <title>GNU Bellek Tahsis Gerçeklenimi</title>
   <titleabbrev>GNU <code>malloc</code> gerçeklenimine genel bir bakış.</titleabbrev>
   <para>
    <indexterm linkend="glibc-cp"><primary>bellek</primary><secondary>GNU bellek ayırıcısı</secondary></indexterm>
    &glibc;ndeki <function>malloc</function> gerçeklenimi, dlmalloc'tan (Doug Lea malloc) türetilen ptmalloc'tan (pthreads malloc) türetilmiştir.  &glibc;nin <function>malloc</function> gerçeklenimi, boyutuna ve kullanıcılar tarafından denetlenebilecek belli değişkenlere bağlı olarak belleği iki farklı şekilde ayırabilir. En yaygın yol, kullanılamaz dilimler biçimindeki israfı azalmak için belleğin bölünmemiş geniş bir bölümünden belleğin dilim dilim tahsis edilmesi ve bu dilimler arasındaki kullanımı en iyilemek için bunların yönetilmesidir. Geleneksel olarak yığın bellek, tek bir büyük bellek alanı olacak şekilde düzenlenmiştir, fakat &glibc;nin <function>malloc</function> gerçeklenimi belleğin çok evreli uygulamalardaki kullanımını en iyilemek için böyle çok sayıda alan sağlar. Böyle alanlardan bahsederken dahili olarak <emphasis>saha</emphasis> karşılığı kullanılacaktır.
   </para>
   <para>
    Diğer sürümlerin aksine, &glibc;ndeki <function>malloc</function>, büyük ya da küçük oluşuna bakmaksızın tahsis edilen her alanın boyutunu ikinin üstellerine yukarıya yuvarlamaz. Komşu parçalar boyutları ne olursa olsun <emphasis>özgürce</emphasis> birleştirilir. Böylece, parçalanma yoluyla bellek israf edilmeden gerçeklenim her türlü tahsis modeli için elverişli duruma getirilir. Birden çok sahanın varlığı, birden çok evrenin belleği aynı anda sahalara ayırmasına izin vererek başarımı artırır.
   </para>
   <para>
    Diğer bir bellek tahsisi yolu, muhtemelen bir sayfadan çok daha büyük, büyük tomarlar tahsis etmektir. Böyle istekler <function>mmap</function> ile yerine getirilir (anonim veya <filename>/dev/zero</filename> aracılığıyla; bkz. <xref linkend="glibc-Memory-mapped-I-O"/>). Bunun en büyük getirisi, bu tomarların serbest kaldıklarında hemen sisteme geri döndürülmeleridir. Bu nedenle, büyük bir tomar daha küçük olanlar arasında "kilitlenmez" ve <function>free</function> çağrısından sonra bile bellek boşa gitmez. <function>mmap</function> için kullanılacak boyut eşiği yazılımın bellek tahsis modeline uygun olarak özdevimli ayarlanır. Eşiği duruk olarak ayarlamak için <function>mallopt</function> işlevi <varname>M_MMAP_THRESHOLD</varname> ile kullanılabilir ve <function>mmap</function> kullanımı <varname>M_MMAP_MAX</varname> ile tamamen devre dışı bırakılabilir; bkz. <xref linkend="glibc-Malloc-Tunable-Parameters"/>.
   </para>
   <para>
    GNU Bellek Ayırıcısı ile ilgili daha ayrıntılı teknik bir açıklama <link xl:href="https://sourceware.org/glibc/wiki/MallocInternals">&glibc; wikisinde</link> bulunabilir.
   </para>
   <para>
    &glibc; tarafından sağlanan yerleşik bellek ayırıcı yerine özel bir  <function>malloc</function> işlevinin kullanımı da mümkündür.  Bkz. <xref linkend="glibc-Replacing-malloc"/>.
   </para>
  </sect1>
  <sect1 xml:id="glibc-Unconstrained-Allocation">
   <title>Kısıtlanmamış Bellek Tahsisi</title>
   <titleabbrev><code>malloc</code> işlevi ile tamamen genel özdevimli bellek tahsis edilebilir.</titleabbrev>
   <preliminary><para>
    <indexterm linkend="glibc-cp"><primary>bellek</primary><secondary>kısıtlanmamış tahsis</secondary></indexterm>
    <indexterm linkend="glibc-cp"><primary>yığın bellek (heap)</primary><secondary>özdevimli tahsis</secondary></indexterm>
    En çok kullanılan özdevimli bellek tahsis oluşumu <command>malloc</command> işlevidir. Bu işlev kullanılarak her zaman her boyutta bellek dilimi tahsis edilebilir, istendiğinde büyütülebilir, küçültülebilir ve ihtiyaç kalmadığında serbest bırakılabilir ya da hiç serbest bırakılmayabilir.
   </para></preliminary>
   <sect2 xml:id="glibc-Basic-Allocation">
    <title>Özdevimli Olarak Basit Bellek Tahsisi</title>
    <titleabbrev><code>malloc</code> işlevinin basit kullanımı.</titleabbrev>
    <para>
     <dicterm><english>subroutine</english><turkish>alt yordam</turkish></dicterm>
     <dicterm><english>sequence</english><turkish>dizilim</turkish></dicterm>
     <dicterm><english>freeing</english><turkish>serbest bırakma (bellek)</turkish></dicterm>
     <indexterm linkend="glibc-cp"><primary>bellek</primary><secondary>tahsisi</secondary><tertiary><function>malloc</function> ile</tertiary></indexterm>
     <indexterm linkend="glibc-pg"><primary>stdlib.h</primary></indexterm>
     Bellek dilimi tahsisi için <function>malloc</function> çağrılır.
    </para>
    <csynopsis>
     <indexterm linkend="glibc-fn" xml:id="glibc-fn-malloc"><primary>malloc</primary></indexterm>
     <csproto type="işlev">
      <csname><ptr>void</ptr><function>malloc</function></csname>
      <csparam><type>size_t</type><parameter>size</parameter></csparam>
     </csproto>
     <conceptlist>
      <concept>&mtsafe;</concept>
      <concept>&asunsafe; &lock;</concept>
      <concept>&acunsafe; &lock; &fd; &mem;</concept>
     </conceptlist>
     <para>
      Bu işlev <parameter>size</parameter> bayt uzunlukta yeni bir bellek dilimi ayırabilirse bu dilime gösterici, aksi takdirde hata kodunu <varname>errno</varname> değişkenine atayıp boş gösterici döndürür.
     </para>
     <header>&stdlib.h;</header>
    </csynopsis>
    <para>
     Bellek diliminin içeriği tanımsızdır; içeriğin ilklendirilmesi gerekir (ya da bu işlev yerine <function>calloc</function> kullanılabilir). Bkz. <xref linkend="glibc-Allocating-Cleared-Space"/>.
    </para>
    <para>
     Normalde değerin dilim içinde saklanmak istenen nesnenin türüne göstericiye dönüştürülmesi gerekir. Aşağıda bu yönteme ilişkin bir örnek vardır. Burada dilim, <function>memset</function> kütüphane işlevi kullanılarak sıfırlarla ilklendirilmektedir (Bkz. <xref linkend="glibc-Copying-Strings-and-Arrays"/>):
    </para>
    <example>
<screen>struct foo *ptr = malloc (sizeof *ptr);
if (ptr == 0) abort ();
memset (ptr, 0, sizeof (struct foo));
</screen>
    </example>
    <para>
     &isoc; <type>void *</type> türünü gerektiğinde özdevinimli olarak başka bir gösterici türüne dönüştürebildiğinden, <function>malloc</function> işlevinin sonucu tür dönüşümü yapılmaksızın bir gösterici değişkeninde saklanabilir. Bununla birlikte, tür gerekliyse ancak bağlamda belirtilmemişse tür dönüşümü gereklidir.
    </para>
    <para>
     Bir dizge için yer ayırırken <function>malloc</function> işlevine belirteceğiniz bağımsız değişkenin değeri, dizgenin uzunluğu artı bir olmalıdır. Bu, dizgenin bir NULL karakteri ile sonlandırılması ve bunun için bir alan gerekmesi fakat NULL karakterinin dizgenin uzunluğundan sayılmamasından dolayıdır. Örnek:
    </para>
    <example>
<screen>char *ptr = malloc (uzunluk + 1);
</screen>
    </example>
    <para>
     Bu konu hakkında daha ayrıntılı bilgi edinmek için bkz. <xref linkend="glibc-Representation-of-Strings"/>
    </para>
   </sect2>
   <sect2 xml:id="glibc-Malloc-Examples">
    <title><code>malloc</code> Örnekleri</title>
    <titleabbrev><code>malloc</code> ve <code>xmalloc</code> örnekleri.</titleabbrev>
    <para>
     <indexterm linkend="glibc-cp"><primary>bellek</primary><secondary><code>malloc</code> yerine <code>xmalloc</code></secondary></indexterm>
     Ayrılabilecek bellek yoksa <function>malloc</function> boş gösterici ile döner. <function>malloc</function> işlevinin her çağrılışında dönen değere bakılmalıdır. <function>malloc</function>'u çağıran, boş gösterici döndüğünde hatayı bildiren ve sadece dönen sıfırdan farklı değerleri döndüren yardımcı bir işlev yazılabilir. Bu yöntem geleneksel olarak <code>xmalloc</code> olarak bilinir ve aşağıdaki gibi gerçeklenebilir:
    </para>
    <example><title><code>xmalloc</code> örneği</title>
<screen>
void * xmalloc (size_t size)
{
  register void *value = malloc (size);
  if (value == 0)
    fatal (&quot;sanal bellek tükendi&quot;);
  return value;
}
</screen>
    </example>
    <para>
     Aşağıda ise <function>malloc</function> kullanılan (<code>xmalloc</code> yoluyla) gerçek bir örnek vardır. <code>savestring</code> işlevi belirtilen karakter dizisini yeni tahsis edilen boş karakter sonlandırmalı dizgeye kopyalamaktadır:
    </para>
    <example>
<screen>char *
savestring (const char *ptr, size_t len)
{
  char *value = xmalloc (len + 1);
  value[len] = '\0';
  return memcpy (value, ptr, len);
}
</screen>
    </example>
    <para>
     <function>malloc</function>'un ayırdığı bellek dilimi her türden veriyi tutabilir. GNU sistemlerinde adres her zaman, 32 bitlik sistemlerde sekizin, 64 bitlik sistemlerde ise onaltının katlarıdır. Nadiren daha yüksek sınırlar (sayfa mertebesinde) gerekir ve bu durumlarda <function>aligned_alloc</function> veya <function>posix_memalign</function> kullanılır (Bkz. <xref linkend="glibc-Aligned-Memory-Blocks"/>).
    </para>
    <para>
     Bir <function>malloc</function> çağrısı ile tahsis edilen dilimin sonuna başka şeyler için kullanmak üzere bellek eklenmesi gerekebilir. Daha önce tahsis edilmiş bir dilimi büyütmek için <function>malloc</function> kullanılmaya çalışılırsa ya önceki dilimin ya da yenisinin bozulması mümkündür. Tahsis edilmiş bellek dilimi sonradan büyütülmek istenirse <function>realloc</function> işlevi kullanılmalıdır (Bkz. <xref linkend="glibc-Changing-Block-Size"/>).
    </para>
    <note><title>Taşınabilirlik Bilgisi</title>
     <itemizedlist>
      <listitem>
       <para>
        &glibc;nde, başarılı bir <code>malloc (0)</code> çağrısı, yeni tahsis edilmiş sıfır boyutlu bellek dilimi için boş olmayan gösterici döndürebilir. Diğer gerçeklenimler bunun yerine NULL döndürebilir. POSIX ve &isoc; standartları her iki davranışa da izin vermektedir.
       </para>
      </listitem>
      <listitem>
       <para>
        &glibc;nde, başarısız bir <function>malloc</function> çağrısında hata <varname>errno</varname> değişkenine atanır, ancak &isoc; bunu gerektirmez ve POSIX uyumlu olmayan gerçeklenimlerin başarısızlık durumunda <varname>errno</varname> ataması yapmasına gerek yoktur.
       </para>
      </listitem>
      <listitem>
       <para>
        &glibc;nde <function>malloc</function>, <parameter>size</parameter> değeri <code>PTRDIFF_MAX</code>'tan büyük olduğunda, göstericiler üzerinde eksiltme yapan veya işaretli indisler kullanan yazılımlarla ilgili sorunlardan kaçınmak için her zaman başarısız olur. Diğer gerçeklenimler bu durumda başarılı olabilir ve daha sonra tanımsız davranışa yol açabilir.
       </para>
      </listitem>
     </itemizedlist>
    </note>
   </sect2>
   <sect2 xml:id="glibc-Freeing-after-Malloc">
    <title><code>malloc</code> ile Ayrılan Belleğin Serbest Bırakılması</title>
    <titleabbrev><code>malloc</code> ile tahsis edilmiş bir dilim <code>free</code> ile serbest bırakılabilir.</titleabbrev>
    <para>
     <indexterm linkend="glibc-cp"><primary>bellek</primary><secondary>serbest bırakma</secondary><tertiary><function>malloc</function> ile tahsis edilmiş</tertiary></indexterm>
     <indexterm linkend="glibc-cp"><primary>yığın bellek (heap)</primary><secondary>belleği serbest bırakmak</secondary></indexterm>
     <indexterm linkend="glibc-pg"><primary>stdlib.h</primary></indexterm>
     <function>malloc</function> ile tahsis edilmiş bir dilime ihtiyaç kalmadığında, dilime tahsis edilmiş belleğin tekrar kullanılabilmesi için dilimin <function>free</function> ile serbest bırakılması gerekir.
    </para>
    <csynopsis>
     <indexterm linkend="glibc-fn" xml:id="glibc-fn-free"><primary>free</primary></indexterm>
     <csproto type="işlev">
      <csname><type>void</type><function>free</function></csname>
      <csparam><ptr>void</ptr><parameter>ptr</parameter></csparam>
     </csproto>
     <conceptlist>
      <concept>&mtsafe;</concept>
      <concept>&asunsafe; &lock;</concept>
      <concept>&acunsafe; &lock; &fd; &mem;</concept>
     </conceptlist>
     <para>
      <code>free</code> işlevi <parameter>ptr</parameter> ile erişilen bellek dilimini serbest bırakır.
     </para>
     <header>&stdlib.h;</header>
    </csynopsis>
    <para>
     Bir bellek diliminin serbest bırakılması dilimin içeriğini değiştirir. <wordasword>Bir dilim serbest bırakıldıktan sonra dilimin içindeki bir veriye ulaşılabileceği (örneğin bir dilim zincirindeki sonraki dilime gösterici belirterek) beklenmemelidir.</wordasword> Bir bellek dilimi serbest bırakmadan önce içinde kullanılacak bir bilgi varsa kopyalanmadır. Aşağıdaki örnekte bir zincirdeki dilimlerin tümü ve içerdikleri dizgeler sırayla serbest bırakılmaktadır:
    </para>
    <example>
<screen>struct zincir
  {
    struct zincir *sonraki;
    char *dizge;
  }

void
zinciri_sal (struct zincir *zincir)
{
  while (zincir != 0)
    {
      struct zincir *sonraki = zincir-&gt;sonraki;
      free (zincir-&gt;dizge);
      free (zincir);
      zincir = sonraki;
    }
}
</screen>
    </example>
    <para>
     Durum uygun olduğunda, <function>free</function> işlevi bellek alanını işletim sistemine döndürür ve süreci küçültür. Genellikle yapılan tek şey, daha sonraki <function>malloc</function> çağrılarında bellek alanını yeniden kullanılır kılmaktır. Bu arada serbest bırakılan alan, süreç dahilinde <function>malloc</function> tarafından kullanılmak üzere serbest bırakılanlar listesinin parçası olarak yazılımda kalır.
    </para>
    <para>
     <function>free</function> işlevi, <varname>errno</varname>'nun değerini korur, böylece temizleme kodunun, <function>free</function>'ye yapılan bir çağrı çerçevesinde <varname>errno</varname>'yu kaydetmesi ve geri yüklemesi gerekmez. Ne &isoc; ne de POSIX.1-2017 <function>free</function> işlevinin <varname>errno</varname>'yu korumasını gerektirse de  POSIX'in gelecekteki bir sürümünde bunun gerektirilmesi planlanmıştır.
    </para>
    <para>
     Yazılımın çalışması sona erdiğinde tahsis edilmiş dilimlerin serbest bırakılması gerekmez. Çünkü süreç sonlandığında sürece tahsis edilmiş tüm alan sisteme geri verilir.
    </para>
   </sect2>
   <sect2 xml:id="glibc-Changing-Block-Size">
    <title>Bellek Diliminin Boyutunun Değiştirilmesi</title>
    <titleabbrev><code>realloc</code> kullanarak bir dilim büyütülebilir ve küçültülebilir.</titleabbrev>
    <para>
     <indexterm linkend="glibc-cp"><primary>bellek</primary><secondary><code>malloc</code> ile tahsis edilmiş dilimin boyunun değiştirilmesi</secondary></indexterm>
     Çoğunlukla bir bellek dilimini kullanmaya başlarken gerekecek bellek miktarı bilinemez ve dilim yaklaşık bir boyut ile tahsis edilir. Örneğin, dilim bir dosyadan okunan satırı tutan bir tampon olabilir ve bir satır için yeterli olan tampon başka bir satır için yetersiz kalabilir.
    </para>
    <para>
     <indexterm linkend="glibc-pg"><primary>stdlib.h</primary></indexterm>
     <function>realloc</function> veya <function>reallocarray</function> işlevi çağrılarak dilim uzatılabilir.
    </para>
    <csynopsis>
     <indexterm linkend="glibc-fn" xml:id="glibc-fn-realloc"><primary>realloc</primary></indexterm>
     <csproto type="işlev">
      <csname><ptr>void</ptr><function>realloc</function></csname>
      <csparam><ptr>void</ptr><parameter>ptr</parameter></csparam>
      <csparam><type>size_t</type><parameter>newsize</parameter></csparam>
     </csproto>
     <conceptlist>
      <concept>&mtsafe;</concept>
      <concept>&asunsafe; &lock;</concept>
      <concept>&acunsafe; &lock; &fd; &mem;</concept>
     </conceptlist>
     <para>
      <code>realloc</code> işlevi <parameter>ptr</parameter> ile erişilen dilimin boyunu <parameter>newsize</parameter> olacak şekilde değiştirir.
     </para>
     <para>
      Dilimin sonundan sonra gelen alan kullanımda olabileceğinden <code>realloc</code> işlevinin, dilimi daha fazla serbest alanın bulunduğu yeni bir adrese kopyalaması gerekebilir. <code>realloc</code> işlevi dilimin yeni adresi ile döner. Dilimin taşınması gerekirse, <code>realloc</code> eski içeriği yeni dilime kopyalar.
     </para>
     <para>
      <code>realloc</code> işlevine <parameter>ptr</parameter> için boş gösterici belirtilirse, işlev, <code>malloc (<parameter>newsize</parameter>)</code> çağrılmış gibi davranır. Aksi takdirde, <parameter>newsize</parameter> sıfır ise <code>realloc</code> dilimi serbest bırakır ve NULL ile döner. Aksi takdirde, <code>realloc</code> istenen boyutu yeniden ayıramazsa özgün dilime dokunmaz, NULL ile döner ve hatayı <varname>errno</varname>'ya kaydeder.
     </para>
     <header>&stdlib.h;</header>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-fn" xml:id="glibc-fn-reallocarray"><primary>reallocarray</primary></indexterm>
     <csproto type="işlev">
      <csname><ptr>void</ptr><function>reallocarray</function></csname>
      <csparam><ptr>void</ptr><parameter>ptr</parameter></csparam>
      <csparam><type>size_t</type><parameter>nmemb</parameter></csparam>
      <csparam><type>size_t</type><parameter>size</parameter></csparam>
     </csproto>
     <conceptlist>
      <concept>&mtsafe;</concept>
      <concept>&asunsafe; &lock;</concept>
      <concept>&acunsafe; &lock; &fd; &mem;</concept>
     </conceptlist>
     <para>
      <code>reallocarray</code> işlevi, <parameter>ptr</parameter> adresinde başlayan dilimi, <parameter>size</parameter> baytlık <parameter>nmemb</parameter> dilim içerecek şekilde değiştirir.  <code>reallocarray</code> işlevinin çarpma işlemi taşarsa güvenli bir şekilde başarısız olması, <varname>errno</varname>'ya <varname>ENOMEM</varname> ataması ve özgün dilimi dokunmadan bırakıp boş gösterici döndürmesi dışında ‘<code>realloc (<parameter>ptr</parameter>, <parameter>nmemb</parameter> * <parameter>size</parameter>)</code>’ çağrısına eşdeğerdir.
     </para>
     <para>
      Ayrılan dilimin yeni boyutu elde edilirken çarpım sonucunun taşma ile sonuçlanabileceği durumlarda <function>realloc</function> yerine <code>reallocarray</code> kullanılmalıdır.
     </para>
     <note><title>Taşınabilirlik Bilgisi</title>
      <para>
       Bu işlev herhangi bir standardın parçası değildir. İlk olarak, OpenBSD 5.6'da görülmüştür.
      </para>
     </note>
     <header>&stdlib.h;</header>
    </csynopsis>
    <para>
     <function>malloc</function> işlevine benzer şekilde, dilimi genişletmek için boş bellek kalmadığı durumda <code>realloc</code> ve <code>reallocarray</code> boş gösterici döndürebilir. Bu olduğunda özgün dilime dokunulmaz (boyutu değiştirilmez veya başka yere taşınmaz).
    </para>
    <para>
     Çoğu durumda, <code>realloc</code> başarısız olduğunda uygulama yazılımı yetersiz bellekle devam edemeyeceğinden özgün dilime ne olduğunun bir önemi kalmaz. Yapılacak tek şey ölümcül hata iletisiyle yazılımı sonlandırmaktır. Genellikle <code>xmalloc</code>'un <function>malloc</function> için yaptığı gibi hata iletisiyle ilgilenen, geleneksel olarak <code>xrealloc</code> ve <code>xreallocarray</code> olarak adlandırılan alt yordamları yazmak ve kullanmak daha uygundur:
     <indexterm xml:id="glibc-fn-reallocarraya" linkend="glibc-cp"><primary>bellek</primary><secondary><code>realloc</code> yerine <code>xrealloc</code></secondary></indexterm>
     <indexterm xml:id="glibc-fn-reallocarrayb" linkend="glibc-cp"><primary>bellek</primary><secondary><code>reallocarray</code> yerine <code>xreallocarray</code></secondary></indexterm>
     <indexterm xml:id="glibc-fn-reallocarrayc" linkend="glibc-cp"><primary><code>xrealloc</code> ve <code>xreallocarray</code> işlevleri</primary></indexterm>
    </para>
    <example><title><code>xrealloc</code> ve <code>xreallocarray</code> işlevleri</title>
<screen>void *
xreallocarray (void *ptr, size_t nmemb, size_t size)
{
  void *value = reallocarray (ptr, nmemb, size);
  if (value == 0)
    fatal ("Sanal bellek tükendi");
  return value;
}

void *
xrealloc (void *ptr, size_t size)
{
  return xreallocarray (ptr, 1, size);
}
</screen>
    </example>
    <para>
     Ayrıca, <function>realloc</function> ve <function>reallocarray</function> bir dilimi küçültmek için de kullanılabilir. Bunu yapma nedeni, yalnızca azına ihtiyaç varken çoğunu bağlamaktan kaçınmaktır. Çeşitli bellek tahsisi gerçeklenimlerinde, bir dilimin küçültülmesi bellek yetersizliğinde işlem başarısız olacağından içeriğinin kopyalanmasını gerektirebilir.
    </para>
    <note><title>Taşınabilirlik Bilgisi</title>
     <itemizedlist>
      <listitem>
       <para>
        Taşınabilir yazılımlar, sıfır boyutlu bellek dilimleri tahsis etmeye çalışmamalıdır. Diğer gerçeklenimler üzerinde, <parameter>ptr</parameter> olarak boş gösterici belirtilmemişse <code>realloc (<parameter>ptr</parameter>, 0)</code> dilimi serbest bırakıp sıfır boyutlu dilime gösterici döndürebilir veya dilimi serbest bırakmaksızın boş gösterici döndürerek başarısız olabilir. &isoc;17 standardı bu çeşitliliğe izin vermektedir.
       </para>
      </listitem>
      <listitem>
       <para>
        &glibc;nde, ortaya çıkan dilimin boyutu <varname>PTRDIFF_MAX</varname>'tan büyük olduğunda, göstericiler üzerinde eksiltme yapan veya işaretli indisler kullanan yazılımlarla ilgili sorunlardan kaçınmak için yeniden tahsis başarısız olur. Diğer gerçeklenimler bu durumda başarılı olabilir ve daha sonra tanımsız davranışa yol açabilir.
       </para>
      </listitem>
      <listitem>
       <para>
        &glibc;nde, yeni boyut eskisi ile aynı ise, <function>realloc</function> ve <function>reallocarray</function> hiçbir değişiklik olmayacağını garanti eder ve belirtilen adresle döner. Ancak POSIX ve &isoc; bu durumda işlevlerin dilimi yeniden tahsisine veya başarısız olmasına izin verir.
       </para>
      </listitem>
     </itemizedlist>
    </note>
   </sect2>
   <sect2 xml:id="glibc-Allocating-Cleared-Space">
    <title>Temizlenmiş Bellek Tahsisi</title>
    <titleabbrev><code>calloc</code> bellek dilimini hem tahsis etmek hem de temizlemek için kullanılabilir.</titleabbrev>
    <para>
     <function>calloc</function> işlevi belleği tahsis ettikten sonra içeriğini sıfırlarla doldurarak temizler.
     <indexterm linkend="glibc-pg"><primary>stdlib.h</primary></indexterm>
    </para>
    <csynopsis>
     <indexterm linkend="glibc-fn" xml:id="glibc-fn-calloc"><primary>calloc</primary></indexterm>
     <csproto type="işlev">
      <csname><ptr>void</ptr><function>calloc</function></csname>
      <csparam><type>size_t</type><parameter>count</parameter></csparam>
      <csparam><type>size_t</type><parameter>eltsize</parameter></csparam>
     </csproto>
     <conceptlist>
      <concept>&mtsafe;</concept>
      <concept>&asunsafe; &lock;</concept>
      <concept>&acunsafe; &lock; &fd; &mem;</concept>
     </conceptlist>
     <para>
      Bu işlev <parameter>eltsize</parameter> baytlık <parameter>count</parameter> sayıda eleman içeren bir dilim ayırır. Bu içerik <code>calloc</code> dönmeden önce sıfırlarla doldurulur.
     </para>
     <header>&stdlib.h;</header>
    </csynopsis>
    <para>
     <function>calloc</function> şöyle tanımlanabilir:
    </para>
    <example>
<screen>void *
calloc (size_t count, size_t eltsize)
{
  void *value = reallocarray (0, count, eltsize);
  if (value != 0)
    memset (value, 0, count * eltsize);
  return value;
}
</screen>
    </example>
    <para>
     Ancak genelde, <function>calloc</function> işlevinin dahili olarak <function>reallocarray</function> and <function>memset</function> işlevini çağıracağının garantisi yoktur. Örneğin, <function>calloc</function> gerçeklenimi başka nedenlerle yeni bellek dilimi içeriğinin sıfır olduğunu biliyorsa, <function>memset</function> ile dilimin içeriğini tekrar sıfırlamasına gerekmez. Ayrıca, bir uygulama C kütüphanesi dışında kendi <function>reallocarray</function> işlevini sağlıyorsa, <function>calloc</function> bu yeniden tanımlamayı kullanmayabilir. Bkz. <xref linkend="glibc-Replacing-malloc"/>.
    </para>
   </sect2>
   <sect2 xml:id="glibc-Aligned-Memory-Blocks">
    <title>Bellek Dilimlerinin Hizalanarak Tahsisi</title>
    <titleabbrev>Dilimleri özellikle adımlarını ayarlayarak adreslemek.</titleabbrev>
    <para>
     <indexterm linkend="glibc-cp"><primary>sayfa sınırı</primary></indexterm>
     <indexterm linkend="glibc-cp"><primary>hizalama</primary><secondary><code>malloc</code> ile</secondary></indexterm>
     <indexterm linkend="glibc-pg"><primary>stdlib.h</primary></indexterm>
     Bir bellek dilimi için <function>malloc</function> tarafından döndürülen adres 32 bitlik GNU sistemlerinde sekizin, 64 bitlik GNU sistemlerinde onaltının katlarıdır. Bir dilimin daha büyük adres adımları (adım boyu ikinin kuvveti olmalı) ile adreslenmesi istenirse <function>aligned_alloc</function> veya <function>posix_memalign</function> işlevi kullanılmalıdır. <function>aligned_alloc</function> ve <function>posix_memalign</function> işlevi &stdlib.h; başlık dosyasında bildirilmiştir.
    </para>
    <csynopsis>
     <indexterm linkend="glibc-fn" xml:id="glibc-fn-aligned_alloc"><primary>aligned_alloc</primary></indexterm>
     <csproto type="işlev">
      <csname><ptr>void</ptr><function>aligned_alloc</function></csname>
      <csparam><type>size_t</type><parameter>alignment</parameter></csparam>
      <csparam><type>size_t</type><parameter>size</parameter></csparam>
     </csproto>
     <conceptlist>
      <concept>&mtsafe;</concept>
      <concept>&asunsafe; &lock;</concept>
      <concept>&acunsafe; &lock; &fd; &mem;</concept>
     </conceptlist>
     <para>
      Bu işlev adresi <parameter>alignment</parameter> ile belirtilen değerin katlarında <parameter>size</parameter> boyutlu dilim ayırır. <parameter>alignment</parameter> ikinin kuvvetlerinde olmalı ve <parameter>size</parameter> değeri <parameter>alignment</parameter> değerinin katları olmalıdır.
     </para>
     <para>
      <code>aligned_alloc</code> işlevi hata durumunda boş gösterici döndürür ve <varname>errno</varname> değişkenine şu değerlerden birini atar:
     </para>
     <glosslist>
      <glossentry>
       <glossterm><code>ENOMEM</code></glossterm>
       <glossdef>
        <para>
         Bu isteği karşılayabilecek yeterli bellek yok.
        </para>
       </glossdef>
      </glossentry>
      <glossentry>
       <glossterm><code>EINVAL</code></glossterm>
       <glossdef>
        <para>
         <parameter>alignment</parameter> ikinin kuvvetlerinde değil.
        </para>
       </glossdef>
      </glossentry>
     </glosslist>
     <para>
      Bu işlev &isoc;11'de tanıtılmıştır ve bu nedenle POSIX olmayan günümüz sistemlerinde <function>posix_memalign</function> işlevinden daha iyi taşınabilirlik sağlayabilir.
     </para>
     <header>&stdlib.h;</header>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-fn" xml:id="glibc-fn-memalign"><primary>memalign</primary></indexterm>
     <csproto type="işlev">
      <csname><ptr>void</ptr><function>memalign</function></csname>
      <csparam><type>size_t</type><parameter>boundary</parameter></csparam>
      <csparam><type>size_t</type><parameter>size</parameter></csparam>
     </csproto>
     <conceptlist>
      <concept>&mtsafe;</concept>
      <concept>&asunsafe; &lock;</concept>
      <concept>&acunsafe; &lock; &fd; &mem;</concept>
     </conceptlist>
     <para>
      <code>memalign</code> işlevi adresi <parameter>boundary</parameter> ile belirtilen değerin katlarında <parameter>size</parameter> boyutlu bir dilim ayırır ve dilimin adresi ile döner. <parameter>boundary</parameter> ikinin kuvveti olan bir değer olmalıdır. İşlev biraz daha büyük miktarda dilim tahsis edip dilim içinden <parameter>boundary</parameter> ile belirtilen adım boyuna uygun adresi döndürerek çalışır.
     </para>
     <para>
      <code>memalign</code> işlevi hata durumunda boş gösterici döndürür ve <varname>errno</varname> değişkenine şu değerlerden birini atar:
     </para>
     <glosslist>
      <glossentry>
       <glossterm><code>ENOMEM</code></glossterm>
       <glossdef>
        <para>
         Bu isteği karşılayabilecek yeterli bellek yok.
        </para>
       </glossdef>
      </glossentry>
      <glossentry>
       <glossterm><code>EINVAL</code></glossterm>
       <glossdef>
        <para>
         <parameter>boundary</parameter> ikinin kuvvetlerinde değil.
        </para>
       </glossdef>
      </glossentry>
     </glosslist>
     <para>
      <code>memalign</code> işlevinin kullanımı artık önerilmemekte olup yerine <function>aligned_alloc</function> veya <function>posix_memalign</function> kullanılmalıdır.
     </para>
     <header>&stdlib.h;</header>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-fn" xml:id="glibc-fn-posix_memalign"><primary>posix_memalign</primary></indexterm>
     <csproto type="işlev">
      <csname><type>int</type><function>posix_memalign</function></csname>
      <csparam><pptr>void</pptr><parameter>memptr</parameter></csparam>
      <csparam><type>size_t</type><parameter>alignment</parameter></csparam>
      <csparam><type>size_t</type><parameter>size</parameter></csparam>
     </csproto>
     <conceptlist>
      <concept>&mtsafe;</concept>
      <concept>&asunsafe; &lock;</concept>
      <concept>&acunsafe; &lock; &fd; &mem;</concept>
     </conceptlist>
     <para>
      <code>posix_memalign</code> işlevi <function>memalign</function> işlevine benzer şekilde <parameter>alignment</parameter> değerinin katlarına hizalanmış <parameter>size</parameter> baytlık bir tampon döndürür. Ancak işlev <parameter>alignment</parameter> bağımsız değişkenine bir gereksinim ekler: değişkenin değeri <code>sizeof (void *)</code> değerinin iki katının kuvveti olmalıdır.
     </para>
     <para>
      İşlev, belleği tahsisine başarılı olursa, tahsis edilmiş belleğin göstericisi <code>*</code><parameter>memptr</parameter> adresine konur ve işlev sıfır değeriyle döner. Aksi takdirde sorunu belirten bir hata değeri ile döner. Döndürülmesi olası hata değerleri:
     </para>
     <glosslist>
      <glossentry>
       <glossterm><code>ENOMEM</code></glossterm>
       <glossdef>
        <para>
         Bu isteği karşılayabilecek yeterli bellek yok.
        </para>
       </glossdef>
      </glossentry>
      <glossentry>
       <glossterm><code>EINVAL</code></glossterm>
       <glossdef>
        <para>
         <parameter>alignment</parameter> değeri, <code>sizeof (void *)</code> değerinin iki katının kuvveti değil.
        </para>
       </glossdef>
      </glossentry>
     </glosslist>
     <para>
      Bu işlevden POSIX 1003.1d standardında bahsedilmiştir. Bu işlevin yerini <function>aligned_alloc</function> almış olsa da, &isoc;11'i desteklemeyen eski POSIX sistemleri için daha taşınabilirdir.
     </para>
     <header>&stdlib.h;</header>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-fn" xml:id="glibc-fn-valloc"><primary>valloc</primary></indexterm>
     <csproto type="işlev">
      <csname><ptr>void</ptr><function>valloc</function></csname>
      <csparam><type>size_t</type><parameter>size</parameter></csparam>
     </csproto>
     <conceptlist>
      <concept>&mtunsafe; &init;</concept>
      <concept>&asunsafe; &init; &lock;</concept>
      <concept>&acunsafe; &init; &lock; &fd; &mem;</concept>
     </conceptlist>
     <para>
      <code>valloc</code> kullanımı <function>memalign</function> kullanımına benzer ve  sayfa boyunda adresleme ile <parameter>size</parameter> uzunlukta dilim ayırır.  Aşağıdaki gibi gerçeklenebilir:
     </para>
     <example>
<screen>void *
valloc (size_t size)
{
  return memalign (getpagesize (), size);
}
</screen>
     </example>
     <para>
      Bellek alt sistemi hakkında ayrıntılı bilgi <xref  linkend="glibc-Query-Memory-Parameters"/> bölümünde bulunabilir.
     </para>
     <para>
      <code>valloc</code> işlevinin kullanımı artık önerilmemekte olup yerine <function>aligned_alloc</function> veya <function>posix_memalign</function> kullanılmalıdır.
     </para>
     <header>&stdlib.h;</header>
    </csynopsis>
   </sect2>
   <sect2 xml:id="glibc-Malloc-Tunable-Parameters">
    <title><code>malloc</code> Ayarlanabilirleri</title>
    <titleabbrev>Bellek tahsisi ayarlanabilir değişkenlerinin değerleri <code>mallopt</code> ile atanır.</titleabbrev>
    <para>
     <indexterm linkend="glibc-pg"><primary>malloc.h</primary></indexterm>
     Özdevimli bellek tahsisi ile ilgili bazı ayarlanabilir değişkenlere  <function>mallopt</function> ile değer atanabilir. Bu işlev genel SVID/XPG arayüzü olup &malloc.h; başlık dosyasında bildirilmiştir.
    </para>
    <csynopsis>
     <indexterm linkend="glibc-fn" xml:id="glibc-fn-mallopt"><primary>mallopt</primary></indexterm>
     <csproto type="işlev">
      <csname><type>int</type><function>mallopt</function></csname>
      <csparam><type>int</type><parameter>param</parameter></csparam>
      <csparam><type>int</type><parameter>value</parameter></csparam>
     </csproto>
     <header>&malloc.h;</header>
     <conceptlist>
      <concept>&mtunsafe; &init; &const;<code linkend="glibc-safety-identifier">:mallopt</code></concept>
      <concept>&asunsafe; &init; &lock;</concept>
      <concept>&acunsafe; &init; &lock;</concept>
     </conceptlist>
      <para>
      <code>mallopt</code> işlevi çağrılırken tanımlanacak ayarlanabilir değişken <parameter>param</parameter> ile, değeri ise <parameter>value</parameter> ile belirtilir. <parameter>param</parameter> için &malloc.h; başlık dosyasında tanımlı  ayarlanabilir değişkenler:
     </para>
     <csynopsis>
      <indexterm linkend="glibc-vr" xml:id="glibc-vr-M_MMAP_MAX"><primary>M_MMAP_MAX</primary></indexterm>
      <indexterm linkend="glibc-cp" xml:id="glibc-cp-M_MMAP_MAX"><primary><code>mmap</code> ile tahsis edilebilecek olası en fazla dilim sayısı</primary></indexterm>
      <csproto type="makro">
       <csname><function>M_MMAP_MAX</function></csname>
      </csproto>
      <header>&malloc.h;</header>
      <para>
       <function>mmap</function> ile tahsis edilebilecek olası en fazla dilim sayısı. Bu makroya sıfır değeri atanarak <function>mmap</function> kullanımı tamamen devre dışı bırakılabilir.
      </para>
      <para>
       <code>65536</code> varsayılan değerdir.
      </para>
      <para>
       Süreç başlatılırken <varname>MALLOC_MMAP_MAX_</varname> ortam değişkenine istenen değer atanarak bu ayarlanabilirin değeri belirlenebilir.
      </para>
     </csynopsis>
     <csynopsis>
      <indexterm linkend="glibc-vr" xml:id="glibc-vr-M_MMAP_THRESHOLD"><primary>M_MMAP_THRESHOLD</primary></indexterm>
      <indexterm linkend="glibc-cp" xml:id="glibc-cp-M_MMAP_THRESHOLD"><primary><code>mmap</code> için eşik değer</primary></indexterm>
      <csproto type="makro">
       <csname><function>M_MMAP_THRESHOLD</function></csname>
      </csproto>
      <header>&malloc.h;</header>
      <para>
       Bu değerden daha büyük dilimler <function>mmap</function> sistem çağrısı kullanılarak normal yığın belleğin dışında tahsis edilir.  Bu yol, bu parçaların <function>free</function> üzerinden sisteme döndürülebilirliğini garanti eder. Bu eşik değerden daha küçük istekler hala <function>mmap</function> üzerinden tahsis edilebilir.
      </para>
      <para>
       128 KiB varsayılan eşik değerdir ve eşik yazılımın tahsis şablonlarına uyacak şekilde özdevimli olarak atanır. Değer elle atanırsa, özdevimli atama devre dışı bırakılır ve girilen değer duruk olarak atanır.
      </para>
      <para>
       Süreç başlatılırken <varname>MALLOC_MMAP_THRESHOLD_</varname> ortam değişkenine istenen değer atanarak bu ayarlanabilirin değeri belirlenebilir.
      </para>
      </csynopsis>
     <csynopsis>
      <indexterm linkend="glibc-vr" xml:id="glibc-vr-M_PERTURB"><primary>M_PERTURB</primary></indexterm>
      <csproto type="makro">
       <csname><function>M_PERTURB</function></csname>
      </csproto>
      <header>&malloc.h;</header>
      <para>
       Eğer sıfır değilse, bellek dilimleri tahsis edildiğinde (<function>calloc</function> tarafından tahsis edilmediği sürece) ve serbest bırakıldığında bellek dilimi bu değerin bazı düşük seviyeli bitlerine bağlı değerlerle doldurulur. Bu, ilklendirilmemiş veya serbest bırakılmış yığın bellek kullanımında hata ayıklamak için kullanılabilir. Bu seçeneğin, serbest bırakılan dilimin belirli değerlere sahip olacağını garanti etmediği unutulmamalıdır. Yalnızca dilimin serbest bırakılmadan önceki içeriğinin üzerine yazılacağı garanti edilir.
      </para>
      <para>
       <code>0</code> varsayılan değerdir.
      </para>
      <para>
       Süreç başlatılırken <varname>MALLOC_PERTURB_</varname> ortam değişkenine istenen değer atanarak bu ayarlanabilirin değeri belirlenebilir.
      </para>
     </csynopsis>
     <csynopsis>
      <indexterm linkend="glibc-vr" xml:id="glibc-vr-M_TOP_PAD"><primary>M_TOP_PAD</primary></indexterm>
      <csproto type="makro">
       <csname><function>M_TOP_PAD</function></csname>
      </csproto>
      <header>&malloc.h;</header>
      <para>
       Sahanın genişletilmesi gerektiğinde sistemden alınacak ek bellek miktarını belirler. Ayrıca, bir sahayı küçültürken alıkonacak bayt sayısını da belirtir. Bu, yığın boyutunda gerekli gecikmeyi de sağlar, böylece aşırı miktarda sistem çağrısı önlenebilir.
      </para>
      <para>
       <code>0</code> varsayılan değerdir.
      </para>
      <para>
       Süreç başlatılırken <varname>MALLOC_TOP_PAD_</varname> ortam değişkenine istenen değer atanarak bu ayarlanabilirin değeri belirlenebilir.
      </para>
     </csynopsis>
     <csynopsis>
      <indexterm linkend="glibc-vr" xml:id="glibc-vr-M_TRIM_THRESHOLD"><primary>M_TRIM_THRESHOLD</primary></indexterm>
      <csproto type="makro">
       <csname><function>M_TRIM_THRESHOLD</function></csname>
      </csproto>
      <header>&malloc.h;</header>
      <para>
       Belleği sisteme döndürmek için bir sistem çağrısını tetikleyecek en üstteki serbest bırakılabilir tomarın asgari boyutudur (bayt olarak).
      </para>
      <para>
       128 KiB varsayılan eşik değerdir ve bu eşik yazılımın tahsis şablonlarına uyacak şekilde özdevimli olarak atanır. Değer elle atanırsa, özdevimli atama devre dışı bırakılır ve girilen değer duruk olarak atanır.
      </para>
      <para>
       Süreç başlatılırken <varname>MALLOC_TRIM_THRESHOLD_</varname> ortam değişkenine istenen değer atanarak bu ayarlanabilirin değeri belirlenebilir.
      </para>
     </csynopsis>
     <csynopsis>
      <indexterm linkend="glibc-vr" xml:id="glibc-vr-M_ARENA_TEST"><primary>M_ARENA_TEST</primary></indexterm>
      <csproto type="makro">
       <csname><function>M_ARENA_TEST</function></csname>
      </csproto>
      <header>&malloc.h;</header>
      <para>
       Saha sayısı sınırı sınanmadan önce oluşturulabilecek saha sayısını belirler. <varname>M_ARENA_MAX</varname> tanımlıysa bu değer yok sayılır.
      </para>
      <para>
       32 bitlik sistemlerde 2, 64 bitlik sistemlerde 8 varsayılan değerdir.
      </para>
      <para>
       Süreç başlatılırken <varname>MALLOC_ARENA_TEST</varname> ortam değişkenine istenen değer atanarak bu ayarlanabilirin değeri belirlenebilir.
      </para>
     </csynopsis>
     <csynopsis>
      <indexterm linkend="glibc-vr" xml:id="glibc-vr-M_ARENA_MAX"><primary>M_ARENA_MAX</primary></indexterm>
      <csproto type="makro">
       <csname><function>M_ARENA_MAX</function></csname>
      </csproto>
      <header>&malloc.h;</header>
      <para>
       Sistemdeki işlemci çekirdeği sayısından bağımsız olarak kullanılacak saha sayısını belirler.
      </para>
      <para>
       Varsayılan değer <code>0</code>'dır, yani saha sayısındaki sınır çevrim içi işlemci çekirdeği sayısına göre belirlenir. 32 bit sistemler için sınır, çevrimiçi işlemci çekirdeği sayısının iki katıdır ve 64 bit sistemlerde ise sekiz katıdır. Varsayılan değerin <varname>M_ARENA_TEST</varname> makrosunun varsayılan değerinden türetilmediğine ve bağımsız olarak hesaplandığına dikkat edilmelidir.
      </para>
      <para>
       Süreç başlatılırken <varname>MALLOC_ARENA_MAX</varname> ortam değişkenine istenen değer atanarak bu ayarlanabilirin değeri belirlenebilir.
      </para>
     </csynopsis>
    </csynopsis>
    <para>
     <function>mallopt</function> işlevinin <parameter>param</parameter> bağımsız değişkeninde belirtilen ayarlanabilirlerin yerine eşdeğeri olan ortam değişkenleri tanımlanabilir. Bu değişkenleri kullanmanın getirisi, yazılımın kaynak kodunun değiştirilmesine gerek kalmamasıdır. Etkili olmaları için, bu değişkenlerin bir bellek tahsis işlevine yapılan ilk çağrıdan önce tanımlanması gerekir. <function>mallopt</function> ile yapılan değişiklikler ortam değişkenlerine göre önceliklidir. Güvenlikle ilgili nedenlerden dolayı, bu değişkenlerin kullanımı SUID ve SGID'li çalıştırılabilirler için baştan iptal edilmiştir.
    </para>
    <para>
     Malloc ayarlanabilirleri yerine kullanılabilecek ortam değişkenleri (Bazı isimlerin sonundaki alt çizgi imine dikkat edilmelidir):
    </para>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-MALLOC_ARENA_MAX"><primary>MALLOC_ARENA_MAX</primary></indexterm>
     <csproto type="ortam">
      <csname><function>MALLOC_ARENA_MAX</function></csname>
     </csproto>
     <para>
      <function>mallopt</function> işlevinin <parameter>param</parameter> bağımsız değişkenine <varname>M_ARENA_MAX</varname> belirtmeye eşdeğerdir.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-MALLOC_ARENA_TEST"><primary>MALLOC_ARENA_TEST</primary></indexterm>
     <csproto type="ortam">
      <csname><function>MALLOC_ARENA_TEST</function></csname>
     </csproto>
     <para>
      <function>mallopt</function> işlevinin <parameter>param</parameter> bağımsız değişkenine <varname>M_ARENA_TEST</varname> belirtmeye eşdeğerdir.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-MALLOC_CHECK_"><primary>MALLOC_CHECK_</primary></indexterm>
     <csproto type="ortam">
      <csname><function>MALLOC_CHECK_</function></csname>
     </csproto>
     <para>
      Ayrıntılar <function>mcheck</function> işlevinin açıklamasında bulunabilir.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-MALLOC_MMAP_MAX_"><primary>MALLOC_MMAP_MAX_</primary></indexterm>
     <csproto type="ortam">
      <csname><function>MALLOC_MMAP_MAX_</function></csname>
     </csproto>
     <para>
      <function>mallopt</function> işlevinin <parameter>param</parameter> bağımsız değişkenine <varname>M_MMAP_MAX</varname> belirtmeye eşdeğerdir.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-MALLOC_MMAP_THRESHOLD_"><primary>MALLOC_MMAP_THRESHOLD_</primary></indexterm>
     <csproto type="ortam">
      <csname><function>MALLOC_MMAP_THRESHOLD_</function></csname>
     </csproto>
     <para>
      <function>mallopt</function> işlevinin <parameter>param</parameter> bağımsız değişkenine <varname>M_MMAP_THRESHOLD</varname> belirtmeye eşdeğerdir.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-MALLOC_PERTURB_"><primary>MALLOC_PERTURB_</primary></indexterm>
     <csproto type="ortam">
      <csname><function>MALLOC_PERTURB_</function></csname>
     </csproto>
     <para>
      <function>mallopt</function> işlevinin <parameter>param</parameter> bağımsız değişkenine <varname>M_PERTURB</varname> belirtmeye eşdeğerdir.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-MALLOC_TRIM_THRESHOLD_"><primary>MALLOC_TRIM_THRESHOLD_</primary></indexterm>
     <csproto type="ortam">
      <csname><function>MALLOC_TRIM_THRESHOLD_</function></csname>
     </csproto>
     <para>
      <function>mallopt</function> işlevinin <parameter>param</parameter> bağımsız değişkenine <varname>M_TRIM_THRESHOLD</varname> belirtmeye eşdeğerdir.
     </para>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-MALLOC_TOP_PAD_"><primary>MALLOC_TOP_PAD_</primary></indexterm>
     <csproto type="ortam">
      <csname><function>MALLOC_TOP_PAD_</function></csname>
     </csproto>
     <para>
      <function>mallopt</function> işlevinin <parameter>param</parameter> bağımsız değişkenine <varname>M_TOP_PAD</varname> belirtmeye eşdeğerdir.
     </para>
    </csynopsis>
   </sect2>
   <sect2 xml:id="glibc-Heap-Consistency-Checking">
    <title>Yığın Bellek Tutarlılık Denetimi</title>
    <titleabbrev>Yığın belleğin hatalara karşı özdevinimli denetlenmesi.</titleabbrev>
    <para>
     <indexterm linkend="glibc-cp"><primary>bellek</primary><secondary>yığın (heap)</secondary><tertiary>tutarlılık denetimi</tertiary></indexterm>
     <indexterm linkend="glibc-pg"><primary>mcheck.h</primary></indexterm>
     <varname>LD_PRELOAD</varname> ortam değişkenini kullanarak <filename>libc_malloc_debug</filename> hata ayıklama kütüphanesini önyükleyerek ve <function>mcheck</function> işlevini kullanarak özdevimli tahsis edilmiş belleğin tutarlılığının <function>malloc</function> tarafından denetlenmesi istenebilir. Bu işlev GNU genişletmesidir ve &mcheck.h; başlık dosyasında bildirilmiştir.
    </para>
    <csynopsis>
     <indexterm linkend="glibc-fn" xml:id="glibc-fn-mcheck"><primary>mcheck</primary></indexterm>
     <csproto type="işlev">
      <csname><type>int</type><function>mcheck</function></csname>
      <synopsis><type>void</type>(*<parameter>abortfn</parameter>) (<type>enum mcheck_status</type> <parameter>status</parameter>)</synopsis>
     </csproto>
     <conceptlist>
      <concept>&mtunsafe; &race;<code linkend="glibc-safety-identifier">:mcheck</code> &const;<code linkend="glibc-safety-identifier">:malloc_hooks</code></concept>
      <concept>&asunsafe; &corrupt;</concept>
      <concept>&acunsafe; &corrupt;</concept>
     </conceptlist>
     <para>
      <code>mcheck</code> işlevinin çağrılması <function>malloc</function>'a arasıra tutarlılık denetimi yapmasını söyler. Bunlar, <function>malloc</function> ile tahsis edilmiş dilimin sonunu aşan yazma işlemleri gibi şeyleri yakalayacaktır.
     </para>
     <para>
      Bir tutarsızlık bulunduğunda <parameter>abortfn</parameter> ile belirtilen işlev çağrılır. <parameter>abortfn</parameter> boş gösterici içeriyorsa <code>mcheck</code> bir ileti çıktılayıp <function>abort</function> çağrısı (bkz. <xref linkend="glibc-Aborting-a-Program"/>) yapan önceden tanımlı işlevi kullanır. Belirtilen işlev, ne tür bir tutarsızlık tespit edildiğini bildiren bağımsız değişkenle çağrılır; türü aşağıda açıklanmıştır.
     </para>
     <para>
      <function>malloc</function> ile tahsis sonrası tahsis denetimine başlamak için çok geç kalınmış olur. Yani <code>mcheck</code> bu durumda hiçbir şey yapmaz. İşlev, çok geç çağırırsanız  <code>-1</code>, aksi takdirde (başarılı olduğunda) <code>0</code> döndürür.
      </para>
      <para>
       <code>mcheck</code> işlevini yeterince erken çağırmanın en kolay yolu, yazılımı derlerken ‘<option>-lmcheck</option>’ seçeneğini kullanmaktır, o zaman yazılım kodunda değişiklik gerekmez. Ya da bunun yerine, yazılımın her çalıştırılışında <code>mcheck</code> çağrısı eklemek için hata ayıklayıcı kullanılabilir, örneğin aşağıdaki <uri xl:href="man1-gdb"/> komutları, yazılımın her çalıştırılışında özdevinimli olarak <code>mcheck</code> işlevini çağırır:
      </para>
      <example>
<screen>(gdb) break main
Breakpoint 1, main (argc=2, argv=0xbffff964) at nehaltsa.c:10
(gdb) command 1
Type commands for when breakpoint 1 is hit, one per line.
End with a line saying just "end".
&gt;call mcheck(0)
&gt;continue
&gt;end
(gdb) …
</screen>
      </example>
      <para>
       Bununla birlikte, <code>mcheck</code> çağrısının <function>malloc</function> işlevlerinden önce yapılması gerektiğinden, bu yalnızca ilgili herhangi bir nesneyi ilklendiren bir işlevin <function>malloc</function> işlevlerinden herhangi birine çağrı yapmadığı durumda çalışır.
      </para>
      <header>&mcheck.h;</header>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-fn" xml:id="glibc-fn-mprobe"><primary>mprobe</primary></indexterm>
     <csproto type="işlev">
      <csname><type>enum&#160;mcheck_status</type><function>mprobe</function></csname>
      <csparam><ptr>void</ptr><parameter>pointer</parameter></csparam>
     </csproto>
     <conceptlist>
      <concept>&mtunsafe; &race;<code linkend="glibc-safety-identifier">:mcheck</code> &const;<code linkend="glibc-safety-identifier">:malloc_hooks</code></concept>
      <concept>&asunsafe; &corrupt;</concept>
      <concept>&acunsafe; &corrupt;</concept>
     </conceptlist>
     <para>
      <code>mprobe</code> işlevi tahsis edilmiş belirli bir dilimdeki tutarsızlıkların doğrudan denetlenmesini sağlar. Zaten yazılımın başında, arasıra denetim yapması için <function>mcheck</function> çağrısı yapılması gerektiğinden <code>mprobe</code> çağrısı, çağrı sırasında ek bir tutarlılık denetimi yapılmasını sağlar.
     </para>
     <para>
      <parameter>pointer</parameter> bağımsız değişkeni <code>malloc</code> veya <code>realloc</code> tarafından döndürülmüş bir gösterici içermelidir.  <code>mprobe</code> bir tutarsızlık varsa bu tutarsızlığı açıklayan bir değer döndürür. Olası değerler aşağıda açıklanmıştır.
     </para>
     <header>&mcheck.h;</header>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-tp" xml:id="glibc-tp-mcheck_status"><primary sortas="mcheck_status">enum&#160;mcheck_status</primary></indexterm>
     <csproto type="veri türü">
      <csname><type>enum</type><function>mcheck_status</function></csname>
     </csproto>
     <para>
      Bu sayılama türü, tahsis edilmiş bir bellek diliminde tutarsızlık varsa saptanan tutarsızlıkları açıklar. Olası değerler:
     </para>
     <csynopsis>
      <indexterm linkend="glibc-vr" xml:id="glibc-vr-MCHECK_DISABLED"><primary>MCHECK_DISABLED</primary></indexterm>
      <csproto type="sabit">
       <csname><function>MCHECK_DISABLED</function></csname>
      </csproto>
      <para>
       <function>mcheck</function> ilk tahsisten önce çağrılmamış. Tutarsızlık denetimleri yapılamadı.
      </para>
     </csynopsis>
     <csynopsis>
      <indexterm linkend="glibc-vr" xml:id="glibc-vr-MCHECK_OK"><primary>MCHECK_OK</primary></indexterm>
      <csproto type="sabit">
       <csname><function>MCHECK_OK</function></csname>
      </csproto>
      <para>
       Herhangi bir tutarsızlık yok.
      </para>
     </csynopsis>
     <csynopsis>
      <indexterm linkend="glibc-vr" xml:id="glibc-vr-MCHECK_HEAD"><primary>MCHECK_HEAD</primary></indexterm>
      <csproto type="sabit">
       <csname><function>MCHECK_HEAD</function></csname>
      </csproto>
      <para>
       Bellek diliminin hemen öncesindeki veri değiştirildi. Bu genellikle bir dizi indisi veya göstericisi çok fazla eksiltildiğinde olur.
      </para>
     </csynopsis>
     <csynopsis>
      <indexterm linkend="glibc-vr" xml:id="glibc-vr-MCHECK_TAIL"><primary>MCHECK_TAIL</primary></indexterm>
      <csproto type="sabit">
       <csname><function>MCHECK_TAIL</function></csname>
      </csproto>
      <para>
       Bellek diliminin hemen sonrasındaki veri değiştirildi. Bu genellikle bir dizi indisi veya göstericisi çok fazla artırıldığında olur.
      </para>
     </csynopsis>
     <csynopsis>
      <indexterm linkend="glibc-vr" xml:id="glibc-vr-MCHECK_FREE"><primary>MCHECK_FREE</primary></indexterm>
      <csproto type="sabit">
       <csname><function>MCHECK_FREE</function></csname>
      </csproto>
      <para>
       Bellek dilimi zaten serbest bırakılmış.
      </para>
     </csynopsis>
     <header>&mcheck.h;</header>
    </csynopsis>
    <para>
     <function>malloc</function>, <function>realloc</function> ve <function>free</function> kullanımındaki hataları denetlemek ve bunlara karşı korunmak için başka bir olasılık da <varname>MALLOC_CHECK_</varname> ortam değişkenini tanımlamaktır. <varname>MALLOC_CHECK_</varname>, 4'ten küçük sıfırdan farklı bir değerle tanımlandığında, aynı bağımsız değişkenle çift <function>free</function> çağrısı veya tek baytlık taşma gibi basit hatalara karşı toleranslı olacak şekilde tasarlanmış özel (ama daha az verimli) bir uygulama kullanılır. Bununla birlikte, bu tür hataların tümüne karşı korunulamaz ve sonuçta bellek sızıntıları olabilir. <function>mcheck</function> durumunda olduğu gibi, <varname>MALLOC_CHECK_</varname> işlevselliğini etkinleştirmek için <filename>libc_malloc_debug</filename> kütüphanesinin önceden yüklenmiş olması gerekir. Kütüphane önceden yüklenmemişse <varname>MALLOC_CHECK_</varname> etkisiz olacaktır.
    </para>
    <para>
     Yığın bellekte herhangi bir bozulmanın saptanması sürecin anında sonlandırılmasıyla sonuçlanır.
    </para>
    <warning><title><code>MALLOC_CHECK_</code> ile ilgili bir sorun  vardır:</title>
     <para>
      Normal davranışından saparak standart hata tanıtıcısına bir şeyler yazdığı için SUID veya SGID'li çalıştırılabilirlerin istismarı sözkonusu olabilir.  Bu nedenle, <varname>MALLOC_CHECK_</varname> kullanımı SUID ve SGID'li  çalıştırılabilirler için baştan iptal edilmiştir. Ancak sistem yöneticisi tarafından <filename>/etc/suid-debug</filename> dosyası eklenerek etkinleştirilebilir (bu dosyanın içeriği önemli değildir, dosya boş olabilir).
     </para>
    </warning>
    <para>
     Öyleyse <varname>MALLOC_CHECK_</varname> kullanımı ve <option>-lmcheck</option> seçeneğiyle ilintileme arasında ne fark vardır? <option>-lmcheck</option> geriye uyumluluk adına vardır. Her ikisi de aynı yazılım hataları için kullanılırsa da <varname>MALLOC_CHECK_</varname> kullanıldığında yazılımı yeniden derlemek gerekmez.
    </para>
   </sect2>
   <sect2 xml:id="glibc-Statistics-of-Malloc">
    <title><code>malloc</code> ile Bellek Tahsis İstatistikleri</title>
    <titleabbrev>Yazılımın kullandığı bellek miktarı hakkında bilgi alma.</titleabbrev>
    <para>
     <indexterm linkend="glibc-cp"><primary>bellek tahsisi</primary><secondary>istatistikler</secondary><tertiary><code>mallinfo2</code></tertiary></indexterm>
     <function>mallinfo2</function> işlevini çağırarak özdevimli bellek tahsisi hakkında bilgi alınabilir. Bu işlev ve ilişkili veri türü &malloc.h; başlık dosyasında bildirilmiştir; bunlar, standart SVID/XPG sürümününe genişletmedir.
    </para>
    <csynopsis>
     <indexterm linkend="glibc-tp" xml:id="glibc-tp-mallinfo2"><primary sortas="mallinfo2">struct&#160;mallinfo2</primary></indexterm>
     <csproto type="veri türü">
      <csname><type>struct</type><function>mallinfo2</function></csname>
     </csproto>
     <para>
      Bu yapı türü, özdevimli bellek ayırıcı hakkında bilgi döndürmek için kullanılır. Aşağıdaki üyeleri içerir:
     </para>
     <glosslist>
      <glossentry>
       <glossterm>
        <type>size_t</type> <structfield>arena</structfield>
       </glossterm>
       <glossdef>
        <para>
         <function>malloc</function> tarafından <function>sbrk</function> ile tahsis edilmiş belleğin bayt cinsinden toplam boyudur.
        </para>
       </glossdef>
      </glossentry>
      <glossentry>
       <glossterm>
        <type>size_t</type> <structfield>ordblks</structfield>
       </glossterm>
       <glossdef>
        <para>
         Kullanılmayan tomar sayısıdır. (Bellek ayırıcı <code>size_ternally</code> işletim sistemindeki bellek tomarlarını alır ve tek tek <function>malloc</function> çağrılarına dilimleyerek dağıtır. Bkz. <xref linkend="glibc-The-GNU-Allocator"/>.)
        </para>
       </glossdef>
      </glossentry>
      <glossentry>
       <glossterm>
        <type>size_t</type> <structfield>smblks</structfield>
       </glossterm>
       <glossdef>
        <para>
         Bu alan kullanılmamıştır.
        </para>
       </glossdef>
      </glossentry>
      <glossentry>
       <glossterm>
        <type>size_t</type> <structfield>hblks</structfield>
       </glossterm>
       <glossdef>
        <para>
         <function>mmap</function> ile tahsis edilmiş tomarların toplam sayısıdır.
        </para>
       </glossdef>
      </glossentry>
      <glossentry>
       <glossterm>
        <type>size_t</type> <structfield>hblkhd</structfield>
       </glossterm>
       <glossdef>
        <para>
         <function>mmap</function> ile tahsis edilmiş belleğin bayt cinsinden toplam boyudur.
        </para>
       </glossdef>
      </glossentry>
      <glossentry>
       <glossterm>
        <type>size_t</type> <structfield>usmblks</structfield>
       </glossterm>
       <glossdef>
        <para>
         Bu alan kullanılmamıştır ve her zaman <code>0</code>'dır.
        </para>
       </glossdef>
      </glossentry>
      <glossentry>
       <glossterm>
        <type>size_t</type> <structfield>fsmblks</structfield>
       </glossterm>
       <glossdef>
        <para>
         Bu alan kullanılmamıştır.
        </para>
       </glossdef>
      </glossentry>
      <glossentry>
       <glossterm>
        <type>size_t</type> <structfield>uordblks</structfield>
       </glossterm>
       <glossdef>
        <para>
         <function>malloc</function> tarafından dağıtılan dilimlerin kapladığı toplam bellek miktarıdır.
        </para>
       </glossdef>
      </glossentry>
      <glossentry>
       <glossterm>
        <type>size_t</type> <structfield>fordblks</structfield>
       </glossterm>
       <glossdef>
        <para>
         Serbest bırakılan (kullanımda olmayan) dilimlerin kapladığı toplam bellek miktarıdır.
        </para>
       </glossdef>
      </glossentry>
      <glossentry>
       <glossterm>
        <type>size_t</type> <structfield>keepcost</structfield>
       </glossterm>
       <glossdef>
        <para>
         Normalde yığın belleğin son sınırındaki (sanal adres alanının veri bölütünün yüksek ucu) en dağıtılabilir tomarın boyudur.
        </para>
       </glossdef>
      </glossentry>
      </glosslist>
      <header>&malloc.h;</header>
     </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-fn" xml:id="glibc-fn-mallinfo2"><primary>mallinfo2</primary></indexterm>
     <csproto type="işlev">
      <csname><type>struct&#160;mallinfo2</type><function>mallinfo2</function></csname>
      <csparam><code>void</code></csparam>
     </csproto>
     <conceptlist>
      <concept>&mtunsafe; &const;<code linkend="glibc-safety-identifier">:mallopt</code></concept>
      <concept>&asunsafe; &init; &lock;</concept>
      <concept>&acunsafe; &init; &lock;</concept>
     </conceptlist>
     <para>
      Bu işlev, mevcut özdevimli bellek kullanımı hakkında bilgiyi <type>struct&#160;mallinfo2</type> yapısıyla döndürür.
     </para>
     <header>&malloc.h;</header>
    </csynopsis>
   </sect2>
   <sect2 xml:id="glibc-Summary-of-Malloc">
    <title><code>malloc</code> ve İlgili İşlevlerin Özeti</title>
    <para>
     <indexterm linkend="glibc-cp"><primary>bellek</primary><secondary>işlevlerin özeti</secondary></indexterm>
     Burada, <function>malloc</function> ile çalışan işlevlerin bir özeti bulunmaktadır:
    </para>
    <csynopsis>
     <csproto type="işlev">
      <csname><ptr>void</ptr><function>malloc</function></csname>
      <csparam><type>size_t</type><parameter>size</parameter></csparam>
     </csproto>
     <para>
      <parameter>size</parameter> baytlık bellek dilimi tahsis eder. Bkz. <xref linkend="glibc-Basic-Allocation"/>.
     </para>
     <header>&stdlib.h;</header>
    </csynopsis>
    <csynopsis>
     <csproto type="işlev">
      <csname><type>void</type><function>free</function></csname>
      <csparam><ptr>void</ptr><parameter>addr</parameter></csparam>
     </csproto>
     <para>
      Evvelce, <function>malloc</function> ile tahsis edilmiş belleği serbest bırakır. Bkz. <xref linkend="glibc-Freeing-after-Malloc"/>.
     </para>
     <header>&stdlib.h;</header>
    </csynopsis>
    <csynopsis>
     <csproto type="işlev">
      <csname><ptr>void</ptr><function>realloc</function></csname>
      <csparam><ptr>void</ptr><parameter>addr</parameter></csparam>
      <csparam><type>size_t</type><parameter>size</parameter></csparam>
     </csproto>
     <para>
      Evvelce <function>malloc</function> ile tahsis edilmiş bellek dilimini muhtemelen başka bir yere kopyalamak suretiyle büyütür veya küçültür. Bkz. <xref linkend="glibc-Changing-Block-Size"/>.
     </para>
     <header>&stdlib.h;</header>
    </csynopsis>
    <csynopsis>
     <csproto type="işlev">
      <csname><ptr>void</ptr><function>reallocarray</function></csname>
      <csparam><ptr>void</ptr><parameter>ptr</parameter></csparam>
      <csparam><type>size_t</type><parameter>nmemb</parameter></csparam>
      <csparam><type>size_t</type><parameter>size</parameter></csparam>
     </csproto>
     <para>
      Evvelce <function>malloc</function> ile tahsis edilmiş bellek diliminin boyunu <function>realloc</function> işlevine benzer şekilde <code><parameter>nmemb</parameter> * <parameter>size</parameter></code> bayta değiştirir. Bkz. <xref linkend="glibc-Changing-Block-Size"/>.
     </para>
     <header>&stdlib.h;</header>
    </csynopsis>
    <csynopsis>
     <csproto type="işlev">
      <csname><ptr>void</ptr><function>calloc</function></csname>
      <csparam><type>size_t</type><parameter>count</parameter></csparam>
      <csparam><type>size_t</type><parameter>eltsize</parameter></csparam>
     </csproto>
     <para>
      <function>malloc</function> işlevini kullanarak <code><parameter>count</parameter> * <parameter>eltsize</parameter></code> baytlık bellek dilimi ayırır. Bkz. <xref linkend="glibc-Allocating-Cleared-Space"/>.
     </para>
     <header>&stdlib.h;</header>
    </csynopsis>
    <csynopsis>
     <csproto type="işlev">
      <csname><ptr>void</ptr><function>valloc</function></csname>
      <csparam><type>size_t</type><parameter>size</parameter></csparam>
     </csproto>
     <para>
      Sayfa kenarından başlayan <parameter>size</parameter> baytlık bellek dilimi ayırır. Bkz. <xref linkend="glibc-Aligned-Memory-Blocks"/>.
     </para>
     <header>&stdlib.h;</header>
    </csynopsis>
    <csynopsis>
     <csproto type="işlev">
      <csname><ptr>void</ptr><function>aligned_alloc</function></csname>
      <csparam><type>size_t</type><parameter>size</parameter></csparam>
      <csparam><type>size_t</type><parameter>alignment</parameter></csparam>
     </csproto>
     <para>
      <parameter>alignment</parameter> değerinin katlarındaki bir adresten başlayan <parameter>size</parameter> baytlık bellek dilimi ayırır. Bkz. <xref linkend="glibc-Aligned-Memory-Blocks"/>.
     </para>
     <header>&stdlib.h;</header>
    </csynopsis>
    <csynopsis>
     <csproto type="işlev">
      <csname><type>int</type><function>posix_memalign</function></csname>
      <csparam><pptr>void</pptr><parameter>memptr</parameter></csparam>
      <csparam><type>size_t</type><parameter>alignment</parameter></csparam>
      <csparam><type>size_t</type><parameter>size</parameter></csparam>
     </csproto>
     <para>
      <parameter>alignment</parameter> değerinin katlarındaki bir adresten başlayan <parameter>size</parameter> baytlık bellek dilimi ayırır. Bkz. <xref linkend="glibc-Aligned-Memory-Blocks"/>.
     </para>
     <header>&stdlib.h;</header>
    </csynopsis>
    <csynopsis>
     <csproto type="işlev">
      <csname><ptr>void</ptr><function>memalign</function></csname>
      <csparam><type>size_t</type><parameter>size</parameter></csparam>
      <csparam><type>size_t</type><parameter>boundary</parameter></csparam>
     </csproto>
     <para>
      <parameter>boundary</parameter> değerinin katlarındaki bir adresten başlayan <parameter>size</parameter> baytlık bellek dilimi ayırır. Bkz. <xref linkend="glibc-Aligned-Memory-Blocks"/>.
     </para>
     <header>&stdlib.h;</header>
    </csynopsis>
    <csynopsis>
     <csproto type="işlev">
      <csname><type>int</type><function>mallopt</function></csname>
      <csparam><type>int</type><parameter>param</parameter></csparam>
      <csparam><type>int</type><parameter>value</parameter></csparam>
     </csproto>
     <para>
      Ayarlanabilir bağımsız değişkenleri ayarlar. Bkz.  <xref linkend="glibc-Malloc-Tunable-Parameters"/>.
     </para>
     <header>&malloc.h;</header>
    </csynopsis>
    <csynopsis>
     <csproto type="işlev">
      <csname><type>int</type><function>mcheck</function></csname>
      <synopsis><type>void</type>(*<parameter>abortfn</parameter>) (<type>enum mcheck_status</type> <parameter>status</parameter>)</synopsis>
     </csproto>
     <para>
      <function>malloc</function> işlevine özdevimli tahsis edilmiş dilim üzerinde arasıra tutarlılık denetimi yapmasını ve bir tutarsızlık bulunursa <parameter>abortfn</parameter> işlevini çağırmasını söyler. Bkz. <xref linkend="glibc-Heap-Consistency-Checking"/>.
     </para>
     <header>&mcheck.h;</header>
    </csynopsis>
    <csynopsis>
     <csproto type="işlev">
      <csname><type>struct mallinfo2</type><function>mallinfo2</function></csname>
      <csparam><type>void</type></csparam>
     </csproto>
     <para>
      Mevcut özdevimli bellek kullanımı hakkında bilgi döndürür. Bkz. <xref linkend="glibc-Statistics-of-Malloc"/>.
     </para>
     <header>&malloc.h;</header>
    </csynopsis>
   </sect2>
  </sect1>
  <sect1 xml:id="glibc-Allocation-Debugging" userlevel="notoc">
   <?dbhtml stop-chunking?>
   <title>Bellek Tahsisinde Hata Ayıklama</title>
   <titleabbrev>Serbest bırakılmamış bellek üzerinde artıkların bulunması.</titleabbrev>
   <para>
    <indexterm linkend="glibc-cp"><primary>bellek</primary><secondary>tahsis</secondary><tertiary>hata ayıklama</tertiary></indexterm>
    <indexterm linkend="glibc-cp"><primary>malloc hata ayıklayıcısı</primary></indexterm>
    Özdevimli bellek tahsisinde bellek artıklarını bulmak çöp toplayıcı kullanılmayan dillerle yazılım geliştirirken oldukça karmaşık bir iştir. Uzun süre çalışan yazılımlar özdevimli olarak ayırdıkları nesnelerin işleri bittiğinde serbest bırakılmalarını sağlamalıdır. Aksi takdirde er veya geç sistem belleği tükenebilir.
   </para>
   <para>
    &glibc;ndeki <function>malloc</function> gerçeklenimi bu tür artıkların saptanması ve konumlarının bulunmasıyla ilgili bazı bilgiler sağlar. Bunu yapacak uygulama bir ortam değişkeni ile etkinleştirilen özel bir kipte başlatılmalıdır. Hata ayıklama kipi etkinleştirilirse yazılım için hiçbir hız cezası kesilmez.
   </para>
   <sect2 xml:id="glibc-Tracing-malloc">
    <title>İzleme işlevselliğinin kurulması</title>
    <csynopsis>
     <indexterm linkend="glibc-fn" xml:id="glibc-fn-mtrace"><primary>mtrace</primary></indexterm>
     <csproto type="işlev">
      <csname><type>void</type><function>mtrace</function></csname>
      <csparam><code>void</code></csparam>
     </csproto>
     <conceptlist>
      <concept>&mtunsafe; &env; &race;<code linkend="glibc-safety-identifier">:mtrace</code> &init;</concept>
      <concept>&asunsafe; &init; &heap; &corrupt; &lock;</concept>
      <concept>&acunsafe; &init; &corrupt; &lock; &fd; &mem;</concept>
     </conceptlist>
     <para>
      <code>mtrace</code> işlevi, çağrıldığı yazılımdaki bellek tahsis olaylarını izlemek için bir yol sağlar. Kütüphanede baştan devre dışıdır ve <varname>LD_PRELOAD</varname> ortam değişkeni kullanılarak <filename>libc_malloc_debug</filename> hata ayıklama kitaplığı önyüklenerek etkinleştirilebilir.
     </para>
     <para>
      <code>mtrace</code> işlevi çağrıldığında <varname>MALLOC_TRACE</varname> isimli ortam değişkenine bakar. Bu değişkenin geçerli bir dosya ismi içereceği kabul edilir. Kullanıcının dosyaya yazma izni olmalıdır. Dosya zaten mevcutsa içeriği silinir. Ortam değişkeni yoksa ya da değeri yazmak için açılabilir geçerli bir dosya ismi değilse hiçbir şey yapılmaz. <function>malloc</function> ve benzerlerinin davranışı değiştirilmez. Belli sebeplerle SUID veya SGID'li uygulamalar için de bu durum geçerlidir.
     </para>
     <para>
      Değişkende ismi belirtilen dosya başarıyla açılırsa, <function>mtrace</function> işlevi <function>malloc</function>, <function>realloc</function> ve <function>free</function> işlevleri için özel işleyiciler oluşturur. Bundan sonra bu işlevlerin tüm kullanımları izlenir ve dosyaya listelenir. İzlenen işlevlere yapılan tüm çağrılar için artık bir hız cezası vardır. Yani normal kullanım için izleme etkinleştirilmemelidir.
     </para>
     <para>
      Bu işlev bir GNU genişletmesidir ve genelde diğer sistemler için kullanılabilir değildir.
     </para>
     <header>&mcheck.h;</header>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-fn" xml:id="glibc-fn-muntrace"><primary>muntrace</primary></indexterm>
     <csproto type="işlev">
      <csname><type>void</type><function>muntrace</function></csname>
      <csparam><code>void</code></csparam>
     </csproto>
     <conceptlist>
      <concept>&mtunsafe; &race;<code linkend="glibc-safety-identifier">:mtrace</code> &locale;</concept>
      <concept>&asunsafe; &corrupt; &heap;</concept>
      <concept>&acunsafe; &corrupt; &lock; &mem; &fd;</concept>
     </conceptlist>
     <para>
      <code>muntrace</code> işlevi <function>malloc</function> çağrılarının izlenmesini etkinleştiren <function>mtrace</function> çağrısından sonra çağrılabilir. Başarılı bir <function>mtrace</function> çağrısı yoksa <code>muntrace</code> hiçbir şey yapmaz.
     </para>
     <para>
      Aksi takdirde <function>malloc</function>, <function>realloc</function> ve <function>free</function> işlevleri için oluşturulan işleyicileri devre dışı bırakır ve izleme dosyasını kapatır. İzlenen bir çağrı kalmadığından yazılım tam hızıyla çalışır.
     </para>
     <para>
      Bu işlev bir GNU genişletmesidir ve genelde diğer sistemler için kullanılabilir değildir.
     </para>
     <header>&mcheck.h;</header>
    </csynopsis>
   </sect2>
   <sect2 xml:id="glibc-Using-the-Memory-Debugger">
    <title>Örnek Yazılım Parçaları</title>
    <titleabbrev>Hata ayıklayıcının kullanılması.</titleabbrev>
    <para>
     İzleme işlevselliği yazılımın çalışma anı davranışını açıklamasa bile tüm yazılımlarda <function>mtrace</function> çağrısı yapmak iyi fikir değildir. <function>mtrace</function> kullanarak bir yazılımda hata ayıklandığını ve hata ayıklama oturumunda kullanılan diğer tüm yazılımların da <function>malloc</function> çağrılarını izlediği varsayılırsa çıktı dosyası tüm yazılımlar için ortak olacağından hata ayıklamak kullanışsız olacaktır. Bu nedenle, derleme işlemi yalnızca hata ayıklamak için yapılmışsa <function>mtrace</function> çağrılmalı, dolayısıyla yazılım şöyle başlamalıdır:
    </para>
    <example>
<screen>#include &lt;mcheck.h&gt;

int
main (int argc, char *argv[])
{
#ifdef DEBUGGING
  mtrace ();
#endif
  …
}
</screen>
    </example>
    <para>
     Yazılımın çalışması sırasında çağrıları izlemek için gereken tek şey budur. Ayrıca, izleme herhangi bir bir anda <function>muntrace</function> ile durdurulabilir ve yeni bir <function>mtrace</function> çağrısı ile izleme yeniden başlatılabilir. Ancak, çağrılmamış işlev çağrıları olabileceğinden bu istenmeyen sonuçlara yol açabilir.
    </para>
    <note>
     <para>
      İzlenen işlevleri yalnızca yazılımın kullanmadığı kütüphanelerin de (C kütüphanesinin kendisi dahil) kullandığı unutulmamalıdır.
     </para>
    </note>
    <para>
     Bu durum, yazılım sonlanmadan önce <function>muntrace</function> çağrısı yapmanın neden iyi bir fikir olmadığı hakkında da bir fikir verir. Kütüphaneler sadece yazılımın  <function>main</function> işlevinin dönüşü veya bir <function>exit</function> çağrısından sonra yazılımın sonlandırıldığı hakkında bilgilendirilir. Dolayısıyla bu olmadan kütüphaneler kullandıkları belleği serbest bırakamaz.
    </para>
    <para>
     En iyisi, yazılımın hemen başlarında bir kere <function>mtrace</function> çağrısı yapmak ve hiç <function>muntrace</function> çağrısı yapmamaktır. Bu durumda yazılımın hemen hemen tüm <function>malloc</function> işlevlerinin (yazılımın yapılandırıcıları tarafından çalıştırılanlar ile kütüphanelerin kullandıkları hariç) kullanımları izlenir.
    </para>
   </sect2>
   <sect2 xml:id="glibc-Tips-for-the-Memory-Debugger">
    <title>Bellek Hata Ayıklaması için İpuçları</title>
    <titleabbrev>Az ya da çok becerikli başka fikirler</titleabbrev>
    <para>
     Durum biliniyor. Yazılım hata ayıklama için hazırlandı ve tüm hata ayıklama oturumları iyi çalışmakta. Ancak hata ayıklaması olmaksızın başlattınca hata oluştu. Bir örnek olarak, hata ayıklama kapatıldında bir bellek artığı görülmüş olsun. Böyle durumlar sezilebilirse kazanma şansı olabilir. Aşağıdaki küçük yazılımda bazı şeylerin eşdeğerleri basitçe kullanılmaktadır:
    </para>
    <example>
<screen>#include &lt;mcheck.h&gt;
#include &lt;signal.h&gt;

static void
enable (int sig)
{
  mtrace ();
  signal (SIGUSR1, enable);
}

static void
disable (int sig)
{
  muntrace ();
  signal (SIGUSR2, disable);
}

int
main (int argc, char *argv[])
{
  …

  signal (SIGUSR1, enable);
  signal (SIGUSR2, disable);

  …
}
</screen>
    </example>
    <para>
     Vs., yazılımcı ortamda <varname>MALLOC_TRACE</varname> atamasıyla yazılımda bellek hata ayıklamasını her zaman başlatabilir. Çıktı şüphesiz ilk sinyalden önce oluşan tahsisleri göstermez ama bir bellek artığı varsa yine de gösterilecektir.
    </para>
   </sect2>
   <sect2 xml:id="glibc-Interpreting-the-traces">
    <title>İzlerin Yorumlanması</title>
    <titleabbrev>Bu satırların anlamı ne?</titleabbrev>
    <para>
     Çıktıya bakarsanız şuna benzeyecektir:
    </para>
    <example>
<screen>= Start
&nbsp;[0x8048209] - 0x8064cc8
&nbsp;[0x8048209] - 0x8064ce0
&nbsp;[0x8048209] - 0x8064cf8
&nbsp;[0x80481eb] + 0x8064c48 0x14
&nbsp;[0x80481eb] + 0x8064c60 0x14
&nbsp;[0x80481eb] + 0x8064c78 0x14
&nbsp;[0x80481eb] + 0x8064c90 0x14
= End
</screen>
    </example>
    <para>
     İzleme dosyası bir insan tarafından okunup anlamlandırılmayacağı için bu satırların ne anlama geldiğinin bir önemi yoktur. Bu nedenle, okunabilirliğe dikkat edilmemiştir. Bu iş için &glibc; ile birlikte bu izleri yorumlayan ve kullanıcı dostu bir yolla özetleyen  bir uygulama gelir. Bu uygulamanın ismi <uri xl:href="man1-mtrace"/>'dir (aslında bir Perl betiğidir) ve bir ya da iki girdi alır. İzleme çıktısını içerecek dosyanın ismi <emphasis>mutlaka</emphasis> belirtilmelidir. İzleme dosyasının adından önce isteğe bağlı bir girdi verilebiliyorsa, bu, izi üreten yazılımın adı olmalıdır.
    </para>
    <example>
<screen>$ mtrace tst-mtrace log
No memory leaks.
</screen>
    </example>
    <para>
     Burada <filename>tst-mtrace</filename> isimli yazılım çalıştırılmış ve <filename>log</filename> isimli bir izleme dosyası üretilmiştir. <uri xl:href="man1-mtrace"/> uygulaması tarafından basılan ileti kodla ilgili bir sorun olmadığını göstermiş ve ardından tahsis edilen tüm bellek serbest bırakılmıştır.
    </para>
    <para>
     <uri xl:href="man1-mtrace"/> uygulaması yukardaki örnek izleme dosyası için çalıştırılırsa farklı bir çıktı elde edilir:
</para>
<example>
<screen>$ mtrace errlog
- 0x08064cc8 Free 2 was never alloc'd 0x8048209
- 0x08064ce0 Free 3 was never alloc'd 0x8048209
- 0x08064cf8 Free 4 was never alloc'd 0x8048209

Memory not freed:
   Address     Size     Caller
0x08064c48     0x14  at 0x80481eb
0x08064c60     0x14  at 0x80481eb
0x08064c78     0x14  at 0x80481eb
0x08064c90     0x14  at 0x80481eb
</screen>
    </example>
    <para>
     <command>mtrace</command> uygulaması tek girdi ile çağrıldı ve bu durumda betik izlerde verilen adresleri anlamlandıramadı. Daha anlamlı bir çıktı için şöyle bir çağrı yapılabilir:
    </para>
<example>
 <screen>$ mtrace tst errlog
- 0x08064cc8 Free 2 was never alloc'd /home/drepper/tst.c:39
- 0x08064ce0 Free 3 was never alloc'd /home/drepper/tst.c:39
- 0x08064cf8 Free 4 was never alloc'd /home/drepper/tst.c:39

Memory not freed:
   Address     Size     Caller
0x08064c48     0x14  at /home/drepper/tst.c:33
0x08064c60     0x14  at /home/drepper/tst.c:33
0x08064c78     0x14  at /home/drepper/tst.c:33
0x08064c90     0x14  at /home/drepper/tst.c:33
</screen>
    </example>
    <para>
     Ansızın, çıktı daha ayrıntılı oluverdi. Yazılımcı artık hangi işlev çağrısının bozukluğa sebep olduğunu hemen görebilir.
    </para>
    <para>
     Bu çıktının yorumlanması karmaşık değildir. En fazla iki farklı durum saptanmıştır. İlkinde, tahsis işlevlerinden döndürülmemiş göstericiler için <function>free</function> çağrılmış. Bu genelde çok kötü bir sorundur ve çıktının ilk üç satırında benzer bir durum gösterilmiştir. Bu gibi durumlar az görülür, çünkü sorun kendini çok dramatik olarak gösterir: yazılım normal olarak çöker.
    </para>
    <para>
     Diğer durum saptanması daha zor olan bellek artıklarıdır. Çıktıda görüldüğü gibi <function>mtrace</function> işlevi tüm bu bilgiyi toplamıştır. Bu çıktıya bakarak şu söylenebilir: Yazılım <command>/home/drepper/tst-mtrace.c</command> kaynak dosyasının 33. satırındaki tahsis işlevini dört kere çağırmış ve yazılım sonlandırılmadan önce bu bellek serbest bırakılmamış. Acaba bu araştırılmayı bekleyen gerçek bir sorun mudur?
    </para>
   </sect2>
  </sect1>
  <sect1 xml:id="glibc-Replacing-malloc">
   <title><code>malloc</code> İkamesi</title>
   <titleabbrev>Kendi bellek ayırıcımızı kullansak...</titleabbrev>
   <para>
    <indexterm linkend="glibc-cp"><primary><code>malloc</code></primary><secondary>değiştirmek</secondary></indexterm>
    <indexterm linkend="glibc-cp"><primary><code>malloc</code></primary><secondary>kişiselleştirmek</secondary></indexterm>
    <indexterm linkend="glibc-cp"><primary><code>malloc</code></primary><secondary>aracılık</secondary></indexterm>
    <indexterm linkend="glibc-cp"><primary><code>malloc</code></primary><secondary>öncelikler</secondary></indexterm>
   <indexterm linkend="glibc-cp"><primary><code>malloc</code></primary><secondary>diğer gerçeklenimler</secondary></indexterm>
    <indexterm linkend="glibc-cp"><primary><code>malloc</code></primary><secondary><code>LD_PRELOAD</code></secondary></indexterm>
    <indexterm linkend="glibc-cp"><primary>yığma</primary></indexterm>
    &glibc;, yerleşik <function>malloc</function> gerçekleniminin aynı arayüze sahip farklı bir tahsisçi ile değiştirilmesini destekler. Özdevimi olarak ilintilenmiş yazılımlar için bu, paylaşımlı nesne bağımlılıkları veya <varname>LD_PRELOAD</varname> kullanılarak araya ELF sembolünün yerleştirilmesi yoluyla gerçekleşir. Duruk ilintileme için <code>malloc</code> ikame kütüphanesinin ilintilenmesi, <filename>libc.a</filename> ilintilemesinden önce (doğrudan veya dolaylı olarak) olmalıdır.
   </para>
   <note>
    <para>
     İkame işlevlerin eksiksiz sağlanmasındaki başarısızlık (yani, uygulama, &glibc; ve  ilintilenmiş diğer kütüphaneler tarafından kullanılan tüm işlevler), duruk ilintileme hataları, çalışma zamanında yığın bellek bozulmaları ve uygulama çökmeleri ile sonuçlanabilir. İkame işlevler, &glibc;ndeki benzerleri için belgelenen davranışı gerçeklemelidir; örneğin, <function>free</function> ikamesi <varname>errno</varname>'yu da korumalıdır.
    </para>
   </note>
   <para>
    Bir <code>malloc</code> özelleştirmesi için en azından aşağıdaki işlevlerin yenileriyle değiştirilmesi gerekir:
   </para>
   <simplelist>
    <member><function>malloc</function></member>
    <member><function>free</function></member>
    <member><function>calloc</function></member>
    <member><function>realloc</function></member>
   </simplelist>
   <para>
    <function>malloc</function> ile ilgili bu işlevler, &glibc;nin düzgün çalışması için gereklidir.<footnote><para>&glibc;nin 2.25 öncesi sürümleri, özel <code>malloc</code>'un <code>__libc_memalign</code>'ı tanımlamasını gerektiriyordu (aynı <function>memalign</function> arayüzüyle).</para></footnote>
   </para>
   <para>
    &glibc;ndeki <function>malloc</function> gerçeklenimi, kütüphanenin kendisi tarafından kullanılmayan, ancak genellikle diğer sistem  kütüphaneleri ve uygulamaları tarafından kullanılan ek bir işlevsellik sağlar. Genel amaçlı bir ikame <code>malloc</code> gerçeklenimi bu işlevlerin de tanımlarını sağlamalıdır. İsimleri aşağıda listelenmiştir:
   </para>
   <simplelist>
    <member><function>aligned_alloc</function></member>
    <member><function>malloc_usable_size</function></member>
    <member><function>memalign</function></member>
    <member><function>posix_memalign</function></member>
    <member><function>pvalloc</function></member>
    <member><function>valloc</function></member>
   </simplelist>
   <para>
    Ek olarak, çok eski uygulamalar eski <function>cfree</function> işlevini de kullanabilir.
   </para>
   <para>
    <function>mallopt</function> veya <function>mallinfo2</function> gibi <function>malloc</function> ile ilgili diğer işlevlerin ya herhangi bir etkisi olmaz ya da ikame <code>malloc</code> kullanımdayken yanlış istatistikler döndürür. Ancak, bu işlevlerin değiştirilmemesi genellikle çökmelere veya diğer hatalı uygulama davranışlarına neden olmaz, ancak duruk ilintileme bozukluklarına neden olabilir.
   </para>
   <para>
    &glibc;nde yukarıda listelenmeyen ancak çağrıcıya yeniden tahsis edilen belleği döndüren başka işlevler de (<function>reallocarray</function>, <function>strdup</function>, vb.) vardır. Bu işlevlerin değiştirilmesi desteklenmez ve hatalı sonuçlara neden olabilir. Bu işlevlerin &glibc; gerçeklenimleri, kullanılabilir olduğunda ikame tahsis işlevlerini de çağıracaktır, böylece bunlar <code>malloc</code> ikameleri ile doğru şekilde çalışacaktır.
   </para>
  </sect1>

  <sect1 xml:id="glibc-Obstacks">
   <title>Yığınaklar (Obstacks)</title>
   <titleabbrev>Nesne yığınları <code>malloc</code>'dan daha az kullanılır ama daha tutarlı ve daha kullanışlıdır.</titleabbrev>
   <preliminary>
   <para>
    <indexterm linkend="glibc-fn"><see>obstack</see></indexterm>
    <indexterm linkend="glibc-cp"><primary>yığınaklar</primary></indexterm>
    <indexterm linkend="glibc-cp"><primary>yığma</primary></indexterm>
    <wordasword>yığınak</wordasword> nesne yığını içeren bellek havuzudur. Çok sayıda bağımsız yığınak oluşturulabilir ve bellek nesneleri bunların içinde tahsis edilebilir. Her yığınağın içinde tahsis edilen son bellek nesnesine karşılık daima ilki serbest bırakılır ancak her yığınak diğerinden bağımsızdır.
   </para>
   <para>
    Serbest bırakma sırası ile ilgili bu kısıtlama dışında yığınaklar tamamen geneldir: Bir yığınak farklı boyutlarda çok sayıda nesne içerebilir. Yığınaklar makrolarla gerçeklenmiştir. Böylece, nesneler küçük oldukları takdirde tahsis işlemi çok hızlı yapılır. Ve nesne başına düşen tek boşluk, her nesneyi uygun bir sınırda başlatmak için gereken dolgudur.
   </para>
   </preliminary>
   <sect2 xml:id="glibc-Creating-Obstacks">
    <title>Yığınak Oluşturma</title>
    <titleabbrev>Yığınaklar nasıl bildirilir.</titleabbrev>
    <para>
     <indexterm linkend="glibc-pg"><primary>obstack.h</primary></indexterm>
     Yığınaklar üzerinde işlem yapmak için gereken araçlar &obstack.h; başlık dosyasında bildirilmiştir.
    </para>
    <csynopsis>
     <indexterm linkend="glibc-tp" xml:id="glibc-tp-mtrace"><primary sortas="obstack">struct&#160;obstack</primary></indexterm>
     <csproto type="veri türü">
      <csname><type>struct</type><function>obstack</function></csname>
     </csproto>
     <para>
      Bir yığınak <code>struct&#160;obstack</code> türünde bir veri yapısı ile ifade edilir. Bu veri yapısı çok küçük ve sabit boyutludur. Nesnelerin içinde tahsis edilmiş alanın nasıl bulunacağı ve yığınağın durumu hakkında bilgileri kaydeder. Nesnelerin kendileri hakkında bir bilgi içermez. Bu yapının içeriğine doğrudan erişmeye çalışılmamalı, sadece bu bölümde açıklanan işlevler kullanılmalıdır.
     </para>
     <header>&obstack.h;</header>
    </csynopsis>
    <para>
     Değişkenler <code>struct&#160;obstack</code> türünde bildirilebilir ve bunlar yığınak olarak kullanılabilir ya da yığınak diğer nesne çeşitlerinde olduğu gibi gerektikçe  tahsis edilebilir. Yığınakların gerektikçe tahsisi yazılımın çok sayıda farklı yığınağa sahip olmasını mümkün kılar. (Hatta bir yığınak yapısı bir başka yığınağın içinde tahsis edilebilir, ancak bu pek kullanışlı olmaz.)
    </para>
    <para>
     Yığınaklar ile çalışan işlevlerin tümü hangi yığınağın kullanılacağının belirtilmesini gerektirir.  Bunu <code>struct&#160;obstack&#160;*</code> türünden bir gösterici ile yapabilirsiniz. Bundan sonra bir yığınaktan bahsedildiğinde ona böyle bir gösterici üzerinden erişildiği kabul edilecektir.
    </para>
    <para>
     Yığınaktaki nesneler <wordasword>öbek</wordasword> adı verilen büyük dilimler halindedir. <type>struct&#160;obstack</type> yapısı ise bu öbeklerden oluşan  zincirin kaydını tutar.
    </para>
    <para>
     Yığınak kütüphanesi, önceki öbeğe sığmayan bir bellek nesnesi tahsis edildiğinde, yeni bir öbek oluşturur. Yığınak kütüphanesi öbekleri kendisi yönettiğinden bu işlemlere fazla dikkat etmeniz gerekmez. Ancak, yığınak kütüphanesinin bir öbeği tahsis ederken kullanacağı işlevi sağlamak gerekir. Bu işlev <function>malloc</function> işlevini doğrudan ya da dolaylı kullanmalıdır. Ayrıca öbeği serbest bırakacak işlevin de sağlanması gerekir. Bu konular bir sonraki bölümde açıklanmıştır.
    </para>
   </sect2>
   <sect2 xml:id="glibc-Preparing-for-Obstacks">
    <title>Yığınakları Kullanıma Hazırlama</title>
    <titleabbrev>Yığınakları kullanmadan önce birtakım hazırlıklar gerekir.</titleabbrev>
    <para>
     <indexterm linkend="glibc-cp"><primary>yığınaklar</primary><secondary>öbek</secondary><tertiary>tahsisi</tertiary></indexterm>
     <indexterm linkend="glibc-cp"><primary>yığınaklar</primary><secondary>öbek</secondary><tertiary>serbest bırakılması</tertiary></indexterm>
     Yığınak işlevlerini kullanmayı tasarladığınız her kaynak dosyası &obstack.h; başlık dosyasını aşağıdaki gibi içermelidir:
    </para>
    <example><title>Yazılımın kaynak dosyasını yığınak kullanımına hazırlamak</title>
    <screen>#include &lt;obstack.h>
</screen>
     </example>
     <para>
      Ayrıca, kaynak dosyası <function>obstack_init</function> makrosunu da kullanıyorsa, yığınak kütüphanesi tarafından kullanılmak üzere iki işlev veya makro bildirmeli ya da tanımlamalıdır. Biri, içine nesnelerin paketleneceği bellek öbeklerinin tahsisinde kullanılacak olan <function>obstack_chunk_alloc</function> diğeri ise, içindeki nesneler serbest bırakıldığında bellek öbeklerini sisteme döndürecek olan <function>obstack_chunk_free</function> makrosudur.
     </para>
     <csynopsis>
     <indexterm linkend="glibc-fn" xml:id="glibc-fn-obstack_chunk_alloc"><primary>obstack_chunk_alloc</primary></indexterm>
     <indexterm linkend="glibc-fn" xml:id="glibc-fn-obstack_chunk_free"><primary>obstack_chunk_free</primary></indexterm>
     <csproto type="makro">
      <csname><function>obstack_chunk_alloc</function></csname>
     </csproto>
     <csproto type="makro">
      <csname><function>obstack_chunk_free</function></csname>
     </csproto>
     <para>
      Bu makrolar kaynak dosyaları içinde yığınaklar kullanılmadan önce tanımlanmış olmalıdır.
     </para>
     <para>
      Normalde bunlar <function>xmalloc</function> (<xref linkend="glibc-Unconstrained-Allocation"/>) aracılığıyla <function>malloc</function> kullanacak şekilde tanımlanır. Bu tanımlama aşağıdaki makro tanım çifti ile yapılır:
     </para>
     <example><title>Yazılımın başlık dosyasını yığınak kullanımına hazırlamak</title>
<screen>#define <code>obstack_chunk_alloc</code> <function>xmalloc</function>
#define <code>obstack_chunk_free</code> <function>free</function>
</screen>
     </example>
     <header>&obstack.h;</header>
    </csynopsis>
    <para>
     Yığınak kullanarak tahsis edilmiş bellek gerçekte <function>malloc</function>'dan gelmesine karşın, yığınakların kullanımı daha hızlıdır çünkü bellek dilimleri daha büyük olduğundan <function>malloc</function> daha az sıklıkta çağrılır. Daha ayrıntılı bilgi <xref linkend="glibc-Obstack-Chunks"/> bölümünde bulunabilir.
    </para>
    <para>
     Çalışma anında yazılım, yığınak olarak <type>struct&#160;obstack</type> yapısını kullanmaya başlamadan önce bir <function>obstack_init</function> çağrısı ile yığını ilklendirmelidir.
    </para>
    <csynopsis>
     <indexterm linkend="glibc-fn" xml:id="glibc-fn-obstack_init"><primary>obstack_init</primary></indexterm>
     <csproto type="işlev">
      <csname><type>int</type><function>obstack_init</function></csname>
      <csparam><ptr>struct&#160;obstack</ptr><parameter>obstack-ptr</parameter></csparam>
     </csproto>
     <conceptlist>
      <concept>&mtsafe; &race;<code linkend="glibc-safety-identifier">:obstack-ptr</code></concept>
      <concept>&assafe;</concept>
      <concept>&acsafe; &mem;</concept>
     </conceptlist>
     <para>
      Nesnelerin tahsis edileceği <parameter>obstack-ptr</parameter> yığınağını ilklendirir. Bu işlev yığınağın <function>obstack_chunk_alloc</function> makrosunu çağırır. Eğer bellek tahsis işlemi başarısız olursa <function>obstack_alloc_failed_handler</function> tarafından gösterilen işlev çağrılır. <code>obstack_init</code> işlevi daima <code>1</code> ile döndürür.
     </para>
     <warning><title>Uyumluluk uyarısı</title>
      <para>
       Tahsis başarısız olursa, yığınağın eski sürümleri <code>0</code> döndürürdü.
      </para>
     </warning>
     <header>&obstack.h;</header>
    </csynopsis>
    <para>
     Aşağıda bir yığınak için alan tahsisi ve ilklendirilmesi hakkında iki örnek bulunmaktadır. İlkinde yığınak (<code>ygnak</code>) duruk bir değişkendir:
    </para>
    <example>
<screen>static struct obstack ygnak;
…
obstack_init (&amp;ygnak);
</screen>
    </example>
    <para>
     İkincisinde ise yığınak (<code>ygnak</code>) kendi yerini özdevimli olarak tahsis etmektedir:
    </para>
    <example>
<screen>struct obstack *ygnak
  = (struct obstack *) xmalloc (sizeof (struct obstack));

obstack_init (ygnak);
</screen>
    </example>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-obstack_alloc_failed_handler"><primary>obstack_alloc_failed_handler</primary></indexterm>
     <csproto type="değişken">
      <csname><function>obstack_alloc_failed_handler</function></csname>
     </csproto>
     <para>
      Bu değişkenin değeri, <function>obstack_chunk_alloc</function> makrosu ile belirtilen işlev bellek tahsis etmekte başarısız olduğunda çağrılacak işleve göstericidir. Bu göstericiye belirtilecek işlev ya <function>exit</function> (<xref linkend="glibc-Program-Termination"/>) ya da  <function>longjmp</function> (<xref linkend="glibc-Non-Local-Exits"/>) işlevini çağırmalı, yani dönmemelidir.
     </para>
     <example>
      <title>Yığınağa yer kalmamışsa çağrılacak işlevin tanımı ve bildirimi</title>
<screen>void ygnaka_yer_yok (void)
 … <replaceable>işlev tanımı burada</replaceable>
<code>obstack_alloc_failed_handler</code> = &amp;ygnaka_yer_yok;
</screen>
    </example>
    <header>&obstack.h;</header>
    </csynopsis>
   </sect2>
   <sect2 xml:id="glibc-Allocation-in-an-Obstack">
    <title>Bir Yığınağa Nesne Eklenmesi</title>
    <titleabbrev>Bir yığınakta nesnelere yer tahsisi</titleabbrev>
    <para>
     <indexterm linkend="glibc-cp"><primary>yığınaklar</primary><secondary>nesne eklemek</secondary></indexterm>
     Bir bellek nesnesi için bir yığınakta yer tahsisinin en kestirme yolu, <function>malloc</function> çağırır gibi <function>obstack_alloc</function> çağrısı yapmaktır.
     </para>
    <csynopsis>
     <indexterm linkend="glibc-fn" xml:id="glibc-fn-obstack_alloc"><primary>obstack_alloc</primary></indexterm>
     <csproto type="işlev">
      <csname><ptr>void</ptr><function>obstack_alloc</function></csname>
      <csparam><ptr>struct&#160;obstack</ptr><parameter>obstack-ptr</parameter></csparam>
      <csparam><type>int</type><parameter>size</parameter></csparam>
     </csproto>
     <conceptlist>
      <concept>&mtsafe; &race;<code linkend="glibc-safety-identifier">:obstack-ptr</code></concept>
      <concept>&assafe;</concept>
      <concept>&acunsafe; &corrupt; &mem;</concept>
     </conceptlist>
     <para>
      İşlev, bir yığınakta <parameter>size</parameter> baytlık ilkendirilmemiş bir dilim ayırır ve adresi ile döner. Burada <parameter>obstack-ptr</parameter>, içinde dilimlerin tahsis edileceği yığınağı belirten <type>struct&#160;obstack</type> yapısının adresidir. Her yığınak işlevi ya da makrosu ilk bağımsız değişken olarak daima bir <parameter>obstack-ptr</parameter> belirtmeyi gerektirir.
     </para>
     <para>
      Bellekte yeni bir öbek tahsis edilmesi gerekirse bu işlev yığınağın <function>obstack_chunk_alloc</function> makrosunu çağırır. <function>obstack_chunk_alloc</function> makrosunda belirtilen işlev bellek tahsisinde başarısız  olursa <function>obstack_alloc_failed_handler</function> işlevi çağrılır.
     </para>
     <header>&obstack.h;</header>
    </csynopsis>
    <para>
     Aşağıdaki örnekte, <code>string_obstack</code> yığınağında  <parameter>dizge</parameter> dizgesinin bir kopyası için yer tahsis edilmektedir:
    </para>
    <example>
<screen>struct obstack <code>string_obstack</code>;

char *
dizge_kopyala (char *<parameter>dizge</parameter>)
{
  size_t len = strlen (<parameter>dizge</parameter>) + 1;
  char *s = (char *) obstack_alloc (&amp;<code>string_obstack</code>, len);
  memcpy (s, <parameter>dizge</parameter>, len);
  return s;
}
</screen>
    </example>
    <para>
     İçeriğini belirterek dilim tahsisi için <function>obstack_copy</function> işlevi kullanılır:
    </para>
    <csynopsis>
     <indexterm linkend="glibc-fn" xml:id="glibc-fn-obstack_copy"><primary>obstack_copy</primary></indexterm>
     <csproto type="işlev">
      <csname><ptr>void</ptr><function>obstack_copy</function></csname>
      <csparam><ptr>struct&#160;obstack</ptr><parameter>obstack-ptr</parameter></csparam>
      <csparam><ptr>void</ptr><parameter>address</parameter></csparam>
      <csparam><type>int</type><parameter>size</parameter></csparam>
     </csproto>
     <conceptlist>
      <concept>&mtsafe; &race;<code linkend="glibc-safety-identifier">:obstack-ptr</code></concept>
      <concept>&assafe;</concept>
      <concept>&acunsafe; &corrupt; &mem;</concept>
     </conceptlist>
     <para>
      Bu işlev bir dilim tahsis eder ve <parameter>address</parameter> adresinden başlayan  <parameter>size</parameter> baytlık veriyi tahsis edilmiş yere kopyalayarak dilimi ilklendirir. <function>obstack_chunk_alloc</function> tarafından bellek tahsisinde başarısızlık durumunda <function>obstack_alloc_failed_handler</function> makrosunda belirtilen işlev çağrılır.
     </para>
     <header>&obstack.h;</header>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-fn" xml:id="glibc-fn-obstack_copy0"><primary>obstack_copy0</primary></indexterm>
     <csproto type="işlev">
      <csname><ptr>void</ptr><function>obstack_copy0</function></csname>
      <csparam><ptr>struct&#160;obstack</ptr><parameter>obstack-ptr</parameter></csparam>
      <csparam><ptr>void</ptr><parameter>address</parameter></csparam>
      <csparam><type>int</type><parameter>size</parameter></csparam>
     </csproto>
     <conceptlist>
      <concept>&mtsafe; &race;<code linkend="glibc-safety-identifier">:obstack-ptr</code></concept>
      <concept>&assafe;</concept>
      <concept>&acunsafe; &corrupt; &mem;</concept>
     </conceptlist>
     <para>
      <function>obstack_copy</function> işlevi gibidir, farklı olarak, veriye boş bir bayt ekler. Bu fazladan bayt <parameter>size</parameter> değişkeninde hesaba katılmaz.
     </para>
     <header>&obstack.h;</header>
    </csynopsis>
    <para>
     <function>obstack_copy0</function> bir yığınağa bir dizgeyi boş karakter sonlandırmalı dizge olarak kopyalamanın en uygun yoludur. Aşağıda bir kullanım örneği vardır:
    </para>
    <example>
<screen>char *
ygnaka_dizge_kopyala (char *adres, int boyut)
{
  return obstack_copy0 (&amp;ygnak, adres, boyut);
}
</screen>
    </example>
    <para>
     Önceki örnekte aynı işi boş karakterle sonlandırmadan yapan <code>dizge_kopyala</code> işlevi için <function>obstack_alloc</function> kullanılmıştı.
    </para>
   </sect2>
   <sect2 xml:id="glibc-Freeing-Obstack-Objects">
    <title>Yığınaktan Nesne Çıkarılması</title>
    <titleabbrev>Yığınakta bir nesneye tahsis edilmiş yerin serbest bırakılması</titleabbrev>
    <para>
     <indexterm linkend="glibc-cp"><primary>yığınaklar</primary><secondary>nesne çıkarmak</secondary></indexterm>
     Yığınaktan bir nesneyi çıkarmak için <function>obstack_free</function> işlevi kullanılır. Bir yığınak aslında bir nesne yığıtı olduğundan, serbest bırakılan nesne kendinden sonra tahsis edilmiş diğer nesnelerin de serbest bırakılmasına sebep olur.
    </para>
    <csynopsis>
     <indexterm linkend="glibc-fn" xml:id="glibc-fn-obstack_free"><primary>obstack_free</primary></indexterm>
     <csproto type="işlev">
      <csname><type>void</type><function>obstack_free</function></csname>
      <csparam><ptr>struct&#160;obstack</ptr><parameter>obstack-ptr</parameter></csparam>
      <csparam><ptr>void</ptr><parameter>object</parameter></csparam>
     </csproto>
     <conceptlist>
      <concept>&mtsafe; &race;<code linkend="glibc-safety-identifier">:obstack-ptr</code></concept>
      <concept>&assafe;</concept>
      <concept>&acunsafe; &corrupt;</concept>
     </conceptlist>
     <para>
      <parameter>object</parameter> boş gösterici olduğunda tahsisli tüm nesneler yığınaktan çıkarılır. Boş gösterici değilse, <parameter>object</parameter> ve <parameter>object</parameter> nesnesinden sonra <parameter>obstack-ptr</parameter> yığınağına konulmuş tüm nesneler serbest bırakılır.
     </para>
     <note>
      <para>
       <parameter>object</parameter> boş gösterici ise işlevin sonucu ilklendirilmemiş bir yığınaktır. Bir yığınağın boşaltılması ve tekrar kullanılabilir yapılması gerekirse <function>obstack_free</function> işlevinin yığınaktaki ilk nesnenin göstericisi ile çağrılması gerekir:
      </para>
      <example>
<screen>obstack_free (ygnak, ilk_nesnenin_gostericisi);
</screen>
      </example>
      <para>
       Bir yığınaktaki nesnelerin öbekler halinde gruplandığı unutulmamalıdır. Bir öbekten tüm nesneler çıkarıldığında yığınak kütüphanesi öbeği özdevinimli olarak serbest bırakır (Bkz. <xref linkend="glibc-Preparing-for-Obstacks"/>). Böylece diğer yığınaklar ve bellek tahsis işlemleri için öbek alanı yeniden kullanılabilir duruma gelir.
      </para>
     </note>
     <header>&obstack.h;</header>
    </csynopsis>
   </sect2>
   <sect2 xml:id="glibc-Obstack-Functions">
    <title>Yığınak İşlevleri ve Makroları</title>
    <titleabbrev>Yığınak işlevleri hem işlev hem de makrodur.</titleabbrev>
    <para>
     <indexterm linkend="glibc-cp"><primary>makrolar</primary></indexterm>
     Derleyiciye bağlı olarak, yığınakların kullanılmasını sağlayan arayüzler işlev ya da makro olarak tanımlanabilir. Yığınak oluşumu, &isoc; ve geleneksel C dahil, tüm C derleyicileri ile çalışır, ancak GNU C derleyicisi dışındaki derleyiciler kullanılacaksa alınması gereken bazı önlemler vardır.
    </para>
    <para>
     Eski moda, &isoc; olmayan bir derleyicinin kullanılması durumunda, tüm yığınak işlevleri aslında birer makro olarak tanımlanmalıdır. Bu makrolar birer işlev gibi çağrılabilir ama bir işlevin sağladığı diğer kolaylıklardan (işlev adresini almak gibi) yararlanılamaz.
    </para>
    <para>
     Makroların çağrılması özel bir önlem almayı gerektirir: İsim olarak, ilk terim (yığınak göstericisi) herhangi bir yan etki barındırmamalıdır.
    </para>
    <example>
<screen>obstack_alloc (get_obstack (), 4);
</screen>
    </example>
    <para>
     yazılırsa, <function>get_obstack</function> defalarca çağrılacaktır. Ya da yığınak göstericisi bağımsız değişkeni olarak <code>*obstack_list_ptr++</code> kullanılırsa, defalarca artırım uygulanacağından çok tuhaf sonuçlar ortaya çıkabilir.
    </para>
    <para>
     &isoc;'de, her işlevin bir makro bir de işlev olarak tanımı vardır. Bir işlevi çağırmadan sadece adresi alınmak istenirse işlev tanımı kullanılır. Normal bir işlev çağrısında ise baştan makro tanımı kullanılır, ancak istenirse işlev ismi yaylı ayraç içinde kullanılarak işlev tanımı da kullanılabilir. Örnek:
    </para>
    <example>
<screen>char *x;
void *(*funcp) ();
/* <replaceable>Makro kullanımı</replaceable>. */
x = (char *) obstack_alloc (obptr, size);
/* <replaceable>İşlev çağrısı</replaceable>. */
x = (char *) (obstack_alloc) (obptr, size);
/* <replaceable>İşlev adresinin alınması</replaceable>. */
funcp = obstack_alloc;
</screen>
    </example>
    <para>
     Aynı durum &isoc;'deki standart kütüphane işlevleri için de geçerlidir. Bkz. <xref linkend="glibc-Macro-Definitions"/>.
    </para>
    <warning>
     <para>
      &isoc;'de bile, makroları kullanırken ilk terimin yan etkiler oluşturmasına karşı önlem almak gerekir.
     </para>
    </warning>
    <para>
     GNU C derleyicisi kullanılıyorsa, bu önlem gereksizdir, çünkü GNU C'deki çeşitli dil oluşumları, makroların, her bağımsız değişkeninin bir kere hesaplanmasını sağlayacak şekilde tanımlanmasına izin verir.
    </para>
   </sect2>
   <sect2 xml:id="glibc-Growing-Objects">
    <title>Büyüyen Nesneler</title>
    <titleabbrev>Bir nesneyi adım adım büyütmek.</titleabbrev>
    <para>
     <indexterm linkend="glibc-cp"><primary>yığınaklar</primary><secondary>büyüyen nesneler</secondary></indexterm>
     <indexterm linkend="glibc-cp"><primary>yığınaklar</primary><secondary>dilim boyunu değiştirmek</secondary></indexterm>
     <indexterm linkend="glibc-cp"><primary>nesne</primary><secondary>büyütme</secondary></indexterm>
     Yığınak öbekleri içindeki bellek sıralı erişimle kullanıldığından, bir bellek nesnesini, nesnenin sonuna bir veya daha fazla bayt ekleyerek adım adım oluşturmak mümkündür. Bu teknikle, bir nesneye veri aktarırken acaba yer kaldı mı diye düşünmek gerekmez. Bu tekniğe <wordasword>Nesnelerin Büyütülmesi</wordasword> adı verilir. Bu bölümde nesneleri sonuna veri ekleyerek büyütmekte kullanılan özel işlevlere yer verilmiştir.
    </para>
    <para>
     Bu işlevlerden birini kullanarak nesneye veri eklendiğinde nesnenin büyütülmesi özdevinimli olarak gerçekleştiğinden, bir nesneyi büyütmeye başlarken özel olarak hiçbir şey yapmak gerekmez. Ancak büyütme işlemi bittiğinde, bittiğinin belirtilmesi gerekir. Bunun için <function>obstack_finish</function> işlevi kullanılır.
    </para>
    <para>
     Bu şekilde oluşturulan nesnenin gerçek adresi, nesne bitene kadar bilinmez. O zamana kadar, nesnenin yeni bir öbeğe kopyalanmasını gerektirecek kadar çok veri eklemek her zaman mümkündür.
    </para>
    <para>
     Bir yığınak bir nesneyi büyütmek için kullanıldığında, o yığına bir başka nesne yerleştirilemez. Bu denenirse, eklenen nesneye ayrı bir nesne olarak erişilemez; büyütülen nesneye bir alan eklenmiş olur ve eklenen nesne büyütülen nesnenin bir parçası haline gelir.
    </para>
    <csynopsis>
     <indexterm linkend="glibc-fn" xml:id="glibc-fn-obstack_blank"><primary>obstack_blank</primary></indexterm>
     <csproto type="işlev">
      <csname><type>void</type><function>obstack_blank</function></csname>
      <csparam><ptr>struct&#160;obstack</ptr><parameter>obstack-ptr</parameter></csparam>
      <csparam><type>int</type><parameter>size</parameter></csparam>
     </csproto>
     <conceptlist>
      <concept>&mtsafe; &race;<code linkend="glibc-safety-identifier">:obstack-ptr</code></concept>
      <concept>&assafe;</concept>
      <concept>&acunsafe; &corrupt; &mem;</concept>
     </conceptlist>
     <para>
      Büyüyen bir nesneye ekleme yapmak için en temel işlev, ilklendirilmemiş alan ekleyen <code>obstack_blank</code> işlevidir.
     </para>
     <header>&obstack.h;</header>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-fn" xml:id="glibc-fn-obstack_grow"><primary>obstack_grow</primary></indexterm>
     <csproto type="işlev">
      <csname><type>void</type><function>obstack_grow</function></csname>
      <csparam><ptr>struct&#160;obstack</ptr><parameter>obstack-ptr</parameter></csparam>
      <csparam><ptr>void</ptr><parameter>data</parameter></csparam>
      <csparam><type>int</type><parameter>size</parameter></csparam>
     </csproto>
     <conceptlist>
      <concept>&mtsafe; &race;<code linkend="glibc-safety-identifier">:obstack-ptr</code></concept>
      <concept>&assafe;</concept>
      <concept>&acunsafe; &corrupt; &mem;</concept>
     </conceptlist>
     <para>
      İlklendirilmiş bir blok eklemekte kullanılır. <code>obstack_grow</code> işlevi nesne büyüten bir <function>obstack_copy</function> işlevi gibi düşünülebilir. Büyüyen nesneye <parameter>size</parameter> baytlık <parameter>data</parameter> ekler.
     </para>
     <header>&obstack.h;</header>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-fn" xml:id="glibc-fn-obstack_grow0"><primary>obstack_grow0</primary></indexterm>
     <csproto type="işlev">
      <csname><type>void</type><function>obstack_grow0</function></csname>
      <csparam><ptr>struct&#160;obstack</ptr><parameter>obstack-ptr</parameter></csparam>
      <csparam><ptr>void</ptr><parameter>data</parameter></csparam>
      <csparam><type>int</type><parameter>size</parameter></csparam>
     </csproto>
     <conceptlist>
      <concept>&mtsafe; &race;<code linkend="glibc-safety-identifier">:obstack-ptr</code></concept>
      <concept>&assafe;</concept>
      <concept>&acunsafe; &corrupt; &mem;</concept>
     </conceptlist>
     <para>
      Nesne büyüten bir <function>obstack_copy0</function> işlevi gibi düşünülenilir. Büyüyen nesneye <parameter>size</parameter> baytlık <parameter>data</parameter>  sonuna boş bir bayt getirilerek eklenir.
     </para>
     <header>&obstack.h;</header>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-fn" xml:id="glibc-fn-obstack_1grow"><primary>obstack_1grow</primary></indexterm>
     <csproto type="işlev">
      <csname><type>void</type><function>obstack_1grow</function></csname>
      <csparam><ptr>struct&#160;obstack</ptr><parameter>obstack-ptr</parameter></csparam>
      <csparam><type>char</type><parameter>c</parameter></csparam>
     </csproto>
     <conceptlist>
      <concept>&mtsafe; &race;<code linkend="glibc-safety-identifier">:obstack-ptr</code></concept>
      <concept>&assafe;</concept>
      <concept>&acunsafe; &corrupt; &mem;</concept>
     </conceptlist>
     <para>
      <code>obstack_1grow</code> işlevi büyüyen nesneye bir defada sadece bir bayt eklemek için kullanılır. Büyüyen nesneye ASCII <parameter>c</parameter> karakterini içeren tek bir bayt ekler.
     </para>
     <header>&obstack.h;</header>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-fn" xml:id="glibc-fn-obstack_ptr_grow"><primary>obstack_ptr_grow</primary></indexterm>
     <csproto type="işlev">
      <csname><type>void</type><function>obstack_ptr_grow</function></csname>
      <csparam><ptr>struct&#160;obstack</ptr><parameter>obstack-ptr</parameter></csparam>
      <csparam><ptr>void</ptr><parameter>data</parameter></csparam>
     </csproto>
     <conceptlist>
      <concept>&mtsafe; &race;<code linkend="glibc-safety-identifier">:obstack-ptr</code></concept>
      <concept>&assafe;</concept>
      <concept>&acunsafe; &corrupt; &mem;</concept>
     </conceptlist>
     <para>
      Gösterici değerine bir eklemek için kullanılır. Büyüyen nesneye <parameter>data</parameter> değerini içeren <code>sizeof (void *)</code> bayt ekler.
     </para>
     <header>&obstack.h;</header>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-fn" xml:id="glibc-fn-obstack_int_grow"><primary>obstack_int_grow</primary></indexterm>
     <csproto type="işlev">
      <csname><type>void</type><function>obstack_int_grow</function></csname>
      <csparam><ptr>struct&#160;obstack</ptr><parameter>obstack-ptr</parameter></csparam>
      <csparam><type>int</type><parameter>data</parameter></csparam>
     </csproto>
     <conceptlist>
      <concept>&mtsafe; &race;<code linkend="glibc-safety-identifier">:obstack-ptr</code></concept>
      <concept>&assafe;</concept>
      <concept>&acunsafe; &corrupt; &mem;</concept>
     </conceptlist>
     <para>
      Büyüyen nesneye <type>int</type> türünde tek bir değer eklemek için kullanılır. Büyüyen nesneye <code>sizeof (int)</code> bayt ekler ve <parameter>data</parameter> değeri ile ilklendirir.
     </para>
     <header>&obstack.h;</header>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-fn" xml:id="glibc-fn-obstack_finish"><primary>obstack_finish</primary></indexterm>
     <csproto type="işlev">
      <csname><ptr>void</ptr><function>obstack_finish</function></csname>
      <csparam><ptr>struct&#160;obstack</ptr><parameter>obstack-ptr</parameter></csparam>
     </csproto>
     <conceptlist>
      <concept>&mtsafe; &race;<code linkend="glibc-safety-identifier">:obstack-ptr</code></concept>
      <concept>&assafe;</concept>
      <concept>&acunsafe; &corrupt;</concept>
     </conceptlist>
     <para>
      Büyüyen nesneyle çalışma bitince nesneyi kapatıp nesne adresini döndürmek için <code>obstack_finish</code> kullanılır.
     </para>
     <para>
      Büyüyen nesneyle çalışma bitince, yığınak, normal bellek tahsisinde ya da yeni bir büyüyen nesne oluşturmakta kullanılabilir.
     </para>
     <para>
      Bu işlev <function>obstack_alloc</function> işlevi gibi aynı koşullar altında boş gösterici ile de dönebilir. Bkz. <xref linkend="glibc-Allocation-in-an-Obstack"/>.
     </para>
     <header>&obstack.h;</header>
    </csynopsis>
    <para>
     Büyüyen nesne ile çalışırken ne büyüklüğe ulaştığını bilmek gerekebilir. Büyüyen nesneyi bitirmeden <function>obstack_object_size</function> işlevi kullanılarak yığınağın eriştiği boyut öğrenilebilir:
     </para>
    <csynopsis>
     <indexterm linkend="glibc-fn" xml:id="glibc-fn-obstack_object_size"><primary>obstack_object_size</primary></indexterm>
     <csproto type="işlev">
      <csname><type>int</type><function>obstack_object_size</function></csname>
      <csparam><ptr>struct&#160;obstack</ptr><parameter>obstack-ptr</parameter></csparam>
     </csproto>
     <conceptlist>
      <concept>&mtsafe; &race;<code linkend="glibc-safety-identifier">:obstack-ptr</code></concept>
      <concept>&assafe;</concept>
      <concept>&acsafe;</concept>
     </conceptlist>
     <para>
      Bu işlev, büyüyen nesnenin o andaki bayt cinsinden uzunluğu ile döner. Bu işlevin yalnızca <function>obstack_finish</function> çağrısı ile nesne bitirilmeden önce çağrılırsa yararlı olduğu unutulmamalıdır. Nesneyi bitirdikten sonra <code>obstack_object_size</code> işlevi <code>0</code> döndürür.
     </para>
     <header>&obstack.h;</header>
    </csynopsis>
    <para>
     Büyüyen nesne oluşturduktan sonra iptal edilmesi gerekirse, önce nesnenin bitirilmesi sonra da serbest bırakılması gerekir. Örnek:
    </para>
    <example><title>Büyüyen nesneyi iptal etmek</title>
<screen>obstack_free (obstack_ptr, obstack_finish (obstack_ptr));
</screen>
    </example>
    <para>
     Nesne büyüyen bir nesne değilse bu etkisizdir.
    </para>
    <para>
     <indexterm xml:id="glibc-fn-obstack_object_sizea" linkend="glibc-cp"><primary>yığınaklar</primary><secondary>nesnelerin küçültülmesi</secondary></indexterm>
     Bir nesneyi küçültmek için <command>obstack_blank</command> işlevi negatif boyutla çağrılabilir. Ancak nesneyi küçültürken boyunun sıfırın altına düşmemesine dikkat edilmelidir, aksi takdirde neler olacağı bilinemez.
    </para>
   </sect2>
   <sect2 xml:id="glibc-Extra-Fast-Growing">
    <title>Çok Hızlı Büyüyen Nesneler</title>
    <titleabbrev>Çok yüksek verimle (daha karmaşık olduğu halde) büyüyen nesneler.</titleabbrev>
    <para>
     <indexterm linkend="glibc-cp"><primary>yığınaklar ve verimlilik</primary></indexterm>
     Büyüyen nesneleri büyütürken o anki tomarın yeterli yere sahip olup olmadığını denetleyen işlevler içinde yapılan işlemler ek yüke sebep olur. Üstelik bu nesneler küçük adımlarla ve sıklıkla büyütülürse bu israf kaydadeğer olmaya başlar.
    </para>
    <para>
     Bu masraf, bu denetimlerin yapılmadığı özel "hızlı büyütme" işlevleri kullanılarak düşürülebilir. Sağlam bir yazılım isteniyorsa bu denetimlerin yazılımcı tarafından yapılması gerekir. Bu denetim en basit yolla, nesneye veri eklemeye hazırlanırken yapılırsa hiçbir şeyin saklnması gerekmez, zaten normal büyütme işlevleri de bunu böyle yapar. Bu denetimin sıklığı ne kadar azaltılır ve verimi ne kadar artırılırsa yazılım o kadar hızlı olur.
    </para>
    <para>
     <function>obstack_room</function> işlevi, geçerli öbekte kullanılabilir oda miktarını döndürür. Aşağıdaki gibi bildirilir:
     </para>
    <csynopsis>
     <indexterm linkend="glibc-fn" xml:id="glibc-fn-obstack_room"><primary>obstack_room</primary></indexterm>
     <csproto type="işlev">
      <csname><type>int</type><function>obstack_room</function></csname>
      <csparam><ptr>struct&#160;obstack</ptr><parameter>obstack-ptr</parameter></csparam>
     </csproto>
     <conceptlist>
      <concept>&mtsafe; &race;<code linkend="glibc-safety-identifier">:obstack-ptr</code></concept>
      <concept>&assafe;</concept>
      <concept>&acsafe;</concept>
     </conceptlist>
     <para>
      Bu işlev, kullanılmakta olan (ya da yeni oluşturulan) <parameter>obstack-ptr</parameter> büyüyen nesnesine hızlı büyütme işlevleri kullanılarak eklenebilecek baytların sayısı ile döner.
     </para>
     <header>&obstack.h;</header>
    </csynopsis>
    <para>
     Ne kadar oda olduğu bilindiğinde aşağıdaki hızlı büyütme işlevleri kullanılarak büyüyen nesneye güvenle veri eklenebilir:
     </para>
    <csynopsis>
     <indexterm linkend="glibc-fn" xml:id="glibc-fn-obstack_1grow_fast"><primary>obstack_1grow_fast</primary></indexterm>
     <csproto type="işlev">
      <csname><type>void</type><function>obstack_1grow_fast</function></csname>
      <csparam><ptr>struct&#160;obstack</ptr><parameter>obstack-ptr</parameter></csparam>
      <csparam><type>char</type><parameter>c</parameter></csparam>
     </csproto>
     <conceptlist>
      <concept>&mtsafe; &race;<code linkend="glibc-safety-identifier">:obstack-ptr</code></concept>
      <concept>&assafe;</concept>
      <concept>&acunsafe; &corrupt; &mem;</concept>
     </conceptlist>
     <para>
      Yığınaktaki <parameter>obstack-ptr</parameter> büyüyen nesnesine <varname>c</varname> karakterini içeren tek bir bayt ekler.
     </para>
     <header>&obstack.h;</header>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-fn" xml:id="glibc-fn-obstack_ptr_grow_fast"><primary>obstack_ptr_grow_fast</primary></indexterm>
     <csproto type="işlev">
      <csname><type>void</type><function>obstack_ptr_grow_fast</function></csname>
      <csparam><ptr>struct&#160;obstack</ptr><parameter>obstack-ptr</parameter></csparam>
      <csparam><ptr>void</ptr><parameter>data</parameter></csparam>
     </csproto>
     <conceptlist>
      <concept>&mtsafe; &race;<code linkend="glibc-safety-identifier">:obstack-ptr</code></concept>
      <concept>&assafe;</concept>
      <concept>&acsafe;</concept>
     </conceptlist>
     <para>
      Yığınaktaki <parameter>obstack-ptr</parameter> büyüyen nesnesine <parameter>data</parameter> değerini içeren <code>sizeof (void *)</code> bayt ekler.
     </para>
     <header>&obstack.h;</header>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-fn" xml:id="glibc-fn-obstack_int_grow_fast"><primary>obstack_int_grow_fast</primary></indexterm>
     <csproto type="işlev">
      <csname><type>void</type><function>obstack_int_grow_fast</function></csname>
      <csparam><ptr>struct&#160;obstack</ptr><parameter>obstack-ptr</parameter></csparam>
      <csparam><type>int</type><parameter>data</parameter></csparam>
     </csproto>
     <conceptlist>
      <concept>&mtsafe; &race;<code linkend="glibc-safety-identifier">:obstack-ptr</code></concept>
      <concept>&assafe;</concept>
      <concept>&acsafe;</concept>
     </conceptlist>
     <para>
      Yığınaktaki <parameter>obstack-ptr</parameter> büyüyen nesnesine <parameter>data</parameter> değerini içeren <code>sizeof (int)</code> bayt ekler.
     </para>
     <header>&obstack.h;</header>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-fn" xml:id="glibc-fn-obstack_blank_fast"><primary>obstack_blank_fast</primary></indexterm>
     <csproto type="işlev">
      <csname><type>void</type><function>obstack_blank_fast</function></csname>
      <csparam><ptr>struct&#160;obstack</ptr><parameter>obstack-ptr</parameter></csparam>
      <csparam><type>int</type><parameter>size</parameter></csparam>
     </csproto>
     <conceptlist>
      <concept>&mtsafe; &race;<code linkend="glibc-safety-identifier">:obstack-ptr</code></concept>
      <concept>&assafe;</concept>
      <concept>&acsafe;</concept>
     </conceptlist>
     <para>
      Yığınaktaki <parameter>obstack-ptr</parameter> büyüyen nesnesine ilklendirmeksizin <parameter>size</parameter> bayt ekler.
     </para>
     <header>&obstack.h;</header>
    </csynopsis>
    <para>
     <function>obstack_room</function> işlevi kullanılarak yer kalmadığı tespit edilirse hızlı büyütme işlevlerini kullanmak artık güvenilir olmaz. Bu durumda, basitçe normal büyütme işlevlerine geçmek gerekir. Sonuç olarak, az yer kalmışsa normal büyütme işlevleri ile yeni bir öbek tahsis etmek gerekir, böylece hızlı büyütme işlevleri tekrar güvenle kullanılabilir olur.
    </para>
    <para>
     Sonuç olarak, <function>obstack_room</function> ile yeterli yer kalmadığı anlaşıldığı anda normal büyütme işlevleri kullanabilecek ve nesne yeni bir öbeğe kopyalandığında tekrar hızlı büyütme işlevlerinin kullanılabileceği güvenilir bir alana sahip olunabilecek demektir.
   </para>
   <example>
<screen>void
add_string (struct obstack *obek, const char *ptr, int boyut)
{
  while (boyut &gt; 0)
    {
      int oda = obstack_room (obek);
      if (oda == 0)
        {
          /* <replaceable>Yeterli boş oda yok. Bir karakter eklenirse nesne,</replaceable>
             <replaceable>yeni bir öbeğe kopyalacak ve boş oda olacak.</replaceable>  */
          obstack_1grow (obek, *ptr++);
          boyut--;
        }
      else
        {
          if (oda &gt; boyut)
            oda = boyut;
          /* <replaceable>Boş oda olduğuna göre hızla ekleme yapılabilir.</replaceable> */
          boyut -= oda;
          while (oda-- &gt; 0)
            obstack_1grow_fast (obek, *ptr++);
        }
    }
}
</screen>
    </example>
   </sect2>
   <sect2 xml:id="glibc-Status-of-an-Obstack">
    <title>Bir Yığınağın Durumu</title>
    <titleabbrev>Bir yığınağın durumu hakkında bilgi edinmek.</titleabbrev>
    <para>
     <indexterm linkend="glibc-cp"><primary>yığınaklar</primary><secondary>yığınağın durumu</secondary></indexterm>
     Burada açıklanan işlevler kullanımdaki bir yığınağın tahsis durumu hakkında bilgi verir. Buradaki işlevler büyümekte olan nesneler hakkında bilgi edinmek için de kullanılabilir.
    </para>
    <csynopsis>
     <indexterm linkend="glibc-fn" xml:id="glibc-fn-obstack_base"><primary>obstack_base</primary></indexterm>
     <csproto type="işlev">
      <csname><ptr>void</ptr><function>obstack_base</function></csname>
      <csparam><ptr>struct&#160;obstack</ptr><parameter>obstack-ptr</parameter></csparam>
     </csproto>
     <conceptlist>
      <concept>&mtsafe;</concept>
      <concept>&asunsafe; &corrupt;</concept>
      <concept>&acsafe;</concept>
     </conceptlist>
     <para>
      Bu işlev yığınaktaki <parameter>obstack-ptr</parameter> büyüyen nesnenin başlangıçta geçici olarak kullanılan adresi ile döner. Bu işlevin hemen ardından büyüyen nesne bitirilirse bu adres döner. Ama bitirme işlemi nesneyi fazlaca büyüttükten sonra yapılırsa dönen adres farklı olabilir!
     </para>
     <para>
      Büyüyen bir nesne yoksa, tahsis edilen sonraki nesnenin başlangıç adresi ile döner (öbeğin yeni bir nesne için yeterli olduğu varsayımıyla).
     </para>
     <header>&obstack.h;</header>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-fn" xml:id="glibc-fn-obstack_next_free"><primary>obstack_next_free</primary></indexterm>
     <csproto type="işlev">
      <csname><ptr>void</ptr><function>obstack_next_free</function></csname>
      <csparam><ptr>struct&#160;obstack</ptr><parameter>obstack-ptr</parameter></csparam>
     </csproto>
     <conceptlist>
      <concept>&mtsafe;</concept>
      <concept>&asunsafe; &corrupt;</concept>
      <concept>&acsafe;</concept>
     </conceptlist>
     <para>
      <parameter>obstack-ptr</parameter> nesnesinin bulunduğu öbekteki serbest bırakılmış ilk baytın adresi ile döner. Bu adres, büyümekte olan nesnenin sonundadır. Eğer nesne büyüyen bir nesne değilse, <function>obstack_base</function> tarafından döndürülen adresin aynısı döner.
     </para>
     <header>&obstack.h;</header>
    </csynopsis>
    <para>
     <function>obstack_object_size</function> işlevi şöyle de gerçeklenebilirdi:
    </para>
    <example>
<screen>obstack_next_free (<parameter>obstack-ptr</parameter>) - obstack_base (<parameter>obstack-ptr</parameter>)
</screen>
    </example>
   </sect2>
   <sect2 xml:id="glibc-Obstacks-Data-Alignment">
    <title>Yığınaktaki Verinin Hizalanması</title>
    <titleabbrev>Yığınaktaki nesnelerin hizaya sokulması</titleabbrev>
    <para>
     <indexterm linkend="glibc-cp"><primary>yığınaklar</primary><secondary>adresleme</secondary></indexterm>
     Her yığınak bir <wordasword>hizalama genişliği</wordasword>’ne sahiptir. Yığınakta tahsis edilen her nesne özdevimli olarak belirtilen genişliğin katlarındaki adreslere yerleştirilir. Öntanımlı olarak bu genişlik nesnenin her türlü veriyi tutabileceği değere hizalanır.
    </para>
    <para>
     Bir yığınağın hizalama genişliğine erişmek için, <function>obstack_alignment_mask</function> makrosu kullanılır. Makronun işlev bildirimi şuna benzer:
    </para>
    <csynopsis>
     <indexterm linkend="glibc-fn" xml:id="glibc-fn-obstack_alignment_mask"><primary>obstack_alignment_mask</primary></indexterm>
     <csproto type="makro">
      <csname><type>int</type><function>obstack_alignment_mask</function></csname>
      <csparam><ptr>struct&#160;obstack</ptr><parameter>obstack-ptr</parameter></csparam>
     </csproto>
     <conceptlist>
      <concept>&mtsafe;</concept>
      <concept>&assafe;</concept>
      <concept>&acsafe;</concept>
     </conceptlist>
     <para>
      Değer bit maskesidir; değeri 1 olan her bit, nesne adresinin ilgili bitinin 0 olması gerektiğini belirtir. Maske değeri, nesnelerin ikinin kuvvetlerindeki adreslere hizalanması için ikinin kuvveti eksi birdir. Öntanımlı maske değeri hizalı nesnelerin her veri türünü tutmasını mümkün kılar: Örneğin, maske değeri 3 ise adresleri 4'ün katlarında olabilen her veri türü saklanabilir. Maske değeri sıfırsa adresleme birer baytlıktır, yani hizalama gerekmez.
     </para>
     <para>
      <code>obstack_alignment_mask</code> makrosu bir sol taraf değeri olarak yorumlanır, yani maske belirtilerek hizalama değiştirilebilir. Örneğin:
     </para>
     <example>
     <screen>obstack_alignment_mask (obstack_ptr) = 0;
</screen>
     </example>
     <para>
      ifadesiyle belirtilen yığınak hizalama işlemine kapatılmıştır.
     </para>
     <header>&obstack.h;</header>
    </csynopsis>
     <para>
      Hizalama maskesindeki değişikliğin yığınakta nesne tahsis edilene kadar veya nesne bitirilene kadar etkili olmayacağı unutulmamalıdır. Nesne büyütülmüyorsa nesne <function>obstack_finish</function> ile bitirilip yeni hizalama maskesinin etkili olması sağlanabilir. Yani, nesne sıfır uzunlukta bitirilip sonraki nesneye uygun adresleme yapılabilir.
     </para>
   </sect2>
   <sect2 xml:id="glibc-Obstack-Chunks">
    <title>Yığınak Öbekleri</title>
    <titleabbrev>Yığınaklar öbekleri nasıl oluşturur ve serbest bırakır; verimlilik kaygıları.</titleabbrev>
    <para>
     <indexterm linkend="glibc-cp"><primary>yığınaklar</primary><secondary>öbek</secondary></indexterm>
     <indexterm linkend="glibc-cp"><primary>yığınak öbekleri</primary></indexterm>
     Yığınaklar kendilerine büyük öbekler halinde yer tahsis eder ve bu alanı istekleri karşılamak üzere parsellere böler. Doğrudan bir öbek boyutu belirtilmediği sürece öbek boyutu başlangıçta 4096 bayttır. Öbeklerde nesneleri saklamakta kullanılmayan 8 baytlık ek yük alanı bulunur. Belirtilen boyuttan bağımsız olarak, gerektiğinde büyük nesneler için daha büyük öbekler tahsis edilir.
    </para>
    <para>
     Yığınak kütüphanesi öbekleri yazılımcı tarafından tanımlanması gereken <function>obstack_chunk_alloc</function> işlevini çağırarak tahsis eder. İçinden tüm nesnelerin çıkarılmasıyla boşalan bir öbeği yine yazılımcı tarafından tanımlanması gereken <function>obstack_chunk_free</function> işlevini çağırarak serbest bırakır.
    </para>
    <para>
     Bu ikisi <function>obstack_init</function> kullanılan her kaynak dosyasında ya makro olarak tanımlanmalı ya da işlev olarak bildirilmelidir (bkz. <xref linkend="glibc-Creating-Obstacks"/>). Bunlar çoğunlukla bunun gibi bir makro olarak tanımlanır:
    </para>
    <example>
    <screen>#define obstack_chunk_alloc <function>malloc</function>
#define obstack_chunk_free <function>free</function>
</screen>
    </example>
    <para>
     Bunların basit makrolar (bağımsız değişkeni olmayan) olduğu unutulmamalıdır. Bağımsız değişkenleri olan makro tanımları çalışmaz! Her biri, tek başına, kendisi bir işlev adı değilse işlev adına genişletilmeleri gerekir.
    </para>
    <para>
     Öbekler <function>malloc</function> ile tahsis ediliyorsa öbek ikinin kuvvetleri baytlık olmalıdır. 4096 bayt tanımlı ilk değer olup, öbeğin sıradan istekleri karşılayacak kadar büyük ve kullanılmayan kısmının ise çok fazla bellek israfına yol açmayacağı kadar küçük olmasını sağladığı için bu değer seçilmiştir.
    </para>
    <csynopsis>
     <indexterm linkend="glibc-fn" xml:id="glibc-fn-obstack_chunk_size"><primary>obstack_chunk_size</primary></indexterm>
     <csproto type="makro">
      <csname><type>int</type><function>obstack_chunk_size</function></csname>
      <csparam><ptr>struct&#160;obstack</ptr><parameter>obstack-ptr</parameter></csparam>
     </csproto>
     <conceptlist>
      <concept>&mtsafe;</concept>
      <concept>&assafe;</concept>
      <concept>&acsafe;</concept>
     </conceptlist>
     <para>
      Belirtilen yığınağın öbek boyutunu döndürür.
     </para>
     <header>&obstack.h;</header>
    </csynopsis>
    <para>
     Makro sol taraf değeri olarak yorumlandığından yeni öbek boyutu, makroya atanan değerle belirlenebilir. Zaten tahsis edilmiş öbekler bundan etkilenmez. Yalnızca yeni tahsis edilecek öbeklerin boyutu üzerinde etkilidir. Öbek boyutunu küçültmenin yararı olmaz, ancak boyutu öbek boyutuna yakın çok sayıda nesnenin tahsisi durumunda öbek boyutunu büyütmek verimliliği artırabilir. Örnek:
    </para>
    <example>
    <screen>if (obstack_chunk_size (obstack_ptr) &lt; <replaceable>yeni_öbek_boyu</replaceable>)
  obstack_chunk_size (obstack_ptr) = <replaceable>yeni_öbek_boyu</replaceable>;
</screen>
    </example>
   </sect2>
   <sect2 xml:id="glibc-Summary-of-Obstacks">
    <title>Yığınak İşlevlerinin Listesi</title>
    <para>
     Burada yığınaklarla ilgili işlevlerin bir özetine yer verilmiştir. Her biri ilk bağımsız değişken olarak <code>struct&#160;obstack&#160;*</code> türünde bir yığınak adresi alır.
    </para>
    <csynopsis>
     <csproto type="işlev">
      <csname><type>int</type><function>obstack_init</function></csname>
      <csparam><ptr>struct&#160;obstack</ptr><parameter>obstack-ptr</parameter></csparam>
     </csproto>
     <para>
      Yığınağı ilklendirir.  Bkz. <xref linkend="glibc-Creating-Obstacks"/>.
     </para>
     <header>&obstack.h;</header>
    </csynopsis>
    <csynopsis>
     <csproto type="işlev">
      <csname><ptr>void</ptr><function>obstack_alloc</function></csname>
      <csparam><ptr>struct&#160;obstack</ptr><parameter>obstack-ptr</parameter></csparam>
      <csparam><type>int</type><parameter>size</parameter></csparam>
     </csproto>
     <para>
      İlklendirmeden <parameter>size</parameter> baytlık nesne tahsis eder. Bkz. <xref linkend="glibc-Allocation-in-an-Obstack"/>.
     </para>
     <header>&obstack.h;</header>
    </csynopsis>
    <csynopsis>
     <csproto type="işlev">
      <csname><ptr>void</ptr><function>obstack_copy</function></csname>
      <csparam><ptr>struct&#160;obstack</ptr><parameter>obstack-ptr</parameter></csparam>
      <csparam><ptr>void</ptr><parameter>address</parameter></csparam>
      <csparam><type>int</type><parameter>size</parameter></csparam>
     </csproto>
     <para>
      <parameter>address</parameter>'ten kopyalanan içerikle <parameter>size</parameter> baytlık nesne tahsis eder.  Bkz. <xref linkend="glibc-Allocation-in-an-Obstack"/>.
     </para>
     <header>&obstack.h;</header>
    </csynopsis>
    <csynopsis>
     <csproto type="işlev">
      <csname><ptr>void</ptr><function>obstack_copy0</function></csname>
      <csparam><ptr>struct&#160;obstack</ptr><parameter>obstack-ptr</parameter></csparam>
      <csparam><ptr>void</ptr><parameter>address</parameter></csparam>
      <csparam><type>int</type><parameter>size</parameter></csparam>
     </csproto>
     <para>
       <parameter>address</parameter>'ten kopyalanan <parameter>size</parameter> baytlık içerikle, boş karakter sonlandırmalı <parameter>size</parameter>+1 baytlık nesne tahsis eder. Bkz. <xref linkend="glibc-Allocation-in-an-Obstack"/>.
     </para>
     <header>&obstack.h;</header>
    </csynopsis>
    <csynopsis>
     <csproto type="işlev">
      <csname><type>void</type><function>obstack_free</function></csname>
      <csparam><ptr>struct&#160;obstack</ptr><parameter>obstack-ptr</parameter></csparam>
      <csparam><ptr>void</ptr><parameter>object</parameter></csparam>
     </csproto>
     <para>
      <parameter>object</parameter> nesnesini (ve <parameter>object</parameter> nesnesinden sonra tahsis edilen tüm nesneleri) serbest bırakır.  Bkz. <xref linkend="glibc-Freeing-Obstack-Objects"/>.
     </para>
     <header>&obstack.h;</header>
    </csynopsis>
    <csynopsis>
     <csproto type="işlev">
      <csname><type>void</type><function>obstack_blank</function></csname>
      <csparam><ptr>struct&#160;obstack</ptr><parameter>obstack-ptr</parameter></csparam>
      <csparam><type>int</type><parameter>size</parameter></csparam>
     </csproto>
     <para>
      Büyüyen nesneye ilklendirilmemiş <parameter>size</parameter> bayt ekler. Bkz. <xref linkend="glibc-Growing-Objects"/>.
     </para>
     <header>&obstack.h;</header>
    </csynopsis>
    <csynopsis>
     <csproto type="işlev">
      <csname><type>void</type><function>obstack_grow</function></csname>
      <csparam><ptr>struct&#160;obstack</ptr><parameter>obstack-ptr</parameter></csparam>
      <csparam><ptr>void</ptr><parameter>data</parameter></csparam>
      <csparam><type>int</type><parameter>size</parameter></csparam>
     </csproto>
     <para>
      Büyüyen nesneye <parameter>data</parameter> adresinden kopyalanan <parameter>size</parameter> baytı ekler. See <xref linkend="glibc-Growing-Objects"/>.
     </para>
     <header>&obstack.h;</header>
    </csynopsis>
    <csynopsis>
     <csproto type="işlev">
      <csname><type>void</type><function>obstack_grow0</function></csname>
      <csparam><ptr>struct&#160;obstack</ptr><parameter>obstack-ptr</parameter></csparam>
      <csparam><ptr>void</ptr><parameter>data</parameter></csparam>
      <csparam><type>int</type><parameter>size</parameter></csparam>
     </csproto>
     <para>
      <parameter>data</parameter> adresinden kopyalanan <parameter>size</parameter> baytlık içeriği ve sondaki boş karakter için 1 bayt daha ekler.  Bkz. <xref linkend="glibc-Growing-Objects"/>.
     </para>
     <header>&obstack.h;</header>
    </csynopsis>
    <csynopsis>
     <csproto type="işlev">
      <csname><type>void</type><function>obstack_1grow</function></csname>
      <csparam><ptr>struct&#160;obstack</ptr><parameter>obstack-ptr</parameter></csparam>
      <csparam><type>char</type><parameter>c</parameter></csparam>
     </csproto>
     <para>
      Her seferinde 1 bayt eklemek için kulllanılır. Büyüyen nesneye <parameter>c</parameter> karakterini içeren tek bir bayt ekler. Bkz. <xref linkend="glibc-Growing-Objects"/>.
     </para>
     <header>&obstack.h;</header>
    </csynopsis>
    <csynopsis>
     <csproto type="işlev">
      <csname><type>void</type><function>obstack_ptr_grow</function></csname>
      <csparam><ptr>struct&#160;obstack</ptr><parameter>obstack-ptr</parameter></csparam>
      <csparam><ptr>void</ptr><parameter>data</parameter></csparam>
     </csproto>
     <para>
      Nesneye gösterici ekler.  <parameter>data</parameter> değerini içeren <code>sizeof (void *)</code> baytı ekler.  Bkz. <xref linkend="glibc-Growing-Objects"/>.
     </para>
     <header>&obstack.h;</header>
    </csynopsis>
    <csynopsis>
     <csproto type="işlev">
      <csname><type>void</type><function>obstack_int_grow</function></csname>
      <csparam><ptr>struct&#160;obstack</ptr><parameter>obstack-ptr</parameter></csparam>
      <csparam><type>int</type><parameter>data</parameter></csparam>
     </csproto>
     <para>
      Nesneye <code>int</code> türünde tek bir değer ekler. Büyüyen nesneye <code>sizeof (int)</code> ekler ve <parameter>data</parameter> değeri ile ilklendirir. Bkz. <xref linkend="glibc-Growing-Objects"/>.
     </para>
     <header>&obstack.h;</header>
    </csynopsis>
    <csynopsis>
     <csproto type="işlev">
      <csname><ptr>void</ptr><function>obstack_finish</function></csname>
      <csparam><ptr>struct&#160;obstack</ptr><parameter>obstack-ptr</parameter></csparam>
     </csproto>
     <para>
      Büyüyen nesneyi bitirir ve kalıcı adresini döndürür. Bkz. <xref linkend="glibc-Growing-Objects"/>.
     </para>
     <header>&obstack.h;</header>
    </csynopsis>
    <csynopsis>
     <csproto type="işlev">
      <csname><type>int</type><function>obstack_object_size</function></csname>
      <csparam><ptr>struct&#160;obstack</ptr><parameter>obstack-ptr</parameter></csparam>
     </csproto>
     <para>
      Büyüyen nesnenin geçerli boyutunu döndürür. Bkz. <xref linkend="glibc-Growing-Objects"/>.
     </para>
     <header>&obstack.h;</header>
    </csynopsis>
    <csynopsis>
     <csproto type="işlev">
      <csname><type>int</type><function>obstack_room</function></csname>
      <csparam><ptr>struct&#160;obstack</ptr><parameter>obstack-ptr</parameter></csparam>
     </csproto>
     <para>
      Geçerli nesnenin büyütülmesinde kullanılabilecek oda miktarını döndürür. Bkz. <xref linkend="glibc-Extra-Fast-Growing"/>.
     </para>
     <header>&obstack.h;</header>
    </csynopsis>
    <csynopsis>
     <csproto type="işlev">
      <csname><type>void</type><function>obstack_1grow_fast</function></csname>
      <csparam><ptr>struct&#160;obstack</ptr><parameter>obstack-ptr</parameter></csparam>
      <csparam><type>char</type><parameter>c</parameter></csparam>
     </csproto>
     <para>
      Yeterli oda olduğuna bakmaksızın büyüyen nesneye <parameter>c</parameter> karakterini içeren tek baytı ekler.  Bkz. <xref linkend="glibc-Extra-Fast-Growing"/>.
     </para>
     <header>&obstack.h;</header>
    </csynopsis>
    <csynopsis>
     <csproto type="işlev">
      <csname><type>void</type><function>obstack_ptr_grow_fast</function></csname>
      <csparam><ptr>struct&#160;obstack</ptr><parameter>obstack-ptr</parameter></csparam>
      <csparam><ptr>void</ptr><parameter>data</parameter></csparam>
     </csproto>
     <para>
      <parameter>obstack-ptr</parameter> yığınağındaki büyüyen nesneye <parameter>data</parameter> değerini içeren <code>sizeof (void *)</code> baytı ekler. Bkz. <xref linkend="glibc-Extra-Fast-Growing"/>
     </para>
     <header>&obstack.h;</header>
    </csynopsis>
    <csynopsis>
     <csproto type="işlev">
      <csname><type>void</type><function>obstack_int_grow_fast</function></csname>
      <csparam><ptr>struct&#160;obstack</ptr><parameter>obstack-ptr</parameter></csparam>
      <csparam><type>int</type><parameter>data</parameter></csparam>
     </csproto>
     <para>
      <parameter>obstack-ptr</parameter> yığınağındaki büyüyen nesneye <parameter>data</parameter> değerini içeren <code>sizeof (int)</code> baytı ekler. Bkz. <xref linkend="glibc-Extra-Fast-Growing"/>
     </para>
     <header>&obstack.h;</header>
    </csynopsis>
    <csynopsis>
     <csproto type="işlev">
      <csname><type>void</type><function>obstack_blank_fast</function></csname>
      <csparam><ptr>struct&#160;obstack</ptr><parameter>obstack-ptr</parameter></csparam>
      <csparam><type>int</type><parameter>size</parameter></csparam>
     </csproto>
     <para>
      Yeterli oda olduğuna bakmaksızın büyüyen nesneye ilklendirilmemiş <parameter>size</parameter> baytı ekler.  Bkz. <xref linkend="glibc-Extra-Fast-Growing"/>.
     </para>
     <header>&obstack.h;</header>
    </csynopsis>
    <csynopsis>
     <csproto type="işlev">
      <csname><ptr>void</ptr><function>obstack_base</function></csname>
      <csparam><ptr>struct&#160;obstack</ptr><parameter>obstack-ptr</parameter></csparam>
     </csproto>
     <para>
      Büyümekte olan nesnenin geçici başlangıç adresini döndürür. Bkz. <xref linkend="glibc-Status-of-an-Obstack"/>.
     </para>
     <header>&obstack.h;</header>
    </csynopsis>
    <csynopsis>
     <csproto type="işlev">
      <csname><ptr>void</ptr><function>obstack_next_free</function></csname>
      <csparam><ptr>struct&#160;obstack</ptr><parameter>obstack-ptr</parameter></csparam>
     </csproto>
     <para>
      Büyümekte olan nesnenin sonundaki sonraki adresi döndürür. Bkz. <xref linkend="glibc-Status-of-an-Obstack"/>.
     </para>
     <header>&obstack.h;</header>
    </csynopsis>
    <csynopsis>
     <csproto type="işlev">
      <csname><type>int</type><function>obstack_object_size</function></csname>
      <csparam><ptr>struct&#160;obstack</ptr><parameter>obstack-ptr</parameter></csparam>
     </csproto>
     <para>
      Büyümekte olan nesnenin bayt cinsinden boyutunu döndürür. Bkz. <xref linkend="glibc-Status-of-an-Obstack"/>.
     </para>
     <header>&obstack.h;</header>
    </csynopsis>
    <csynopsis>
     <csproto type="makro">
      <csname><type>int</type><function>obstack_alignment_mask</function></csname>
      <csparam><ptr>struct&#160;obstack</ptr><parameter>obstack-ptr</parameter></csparam>
     </csproto>
     <para>
      Büyüyen nesnenin hizalanmasında kullanılacak maske. Sol taraf değeri olup maske buna atanır. Bkz.  <xref linkend="glibc-Obstacks-Data-Alignment"/>.
     </para>
     <header>&obstack.h;</header>
    </csynopsis>
    <csynopsis>
     <csproto type="makro">
      <csname><type>int</type><function>obstack_chunk_size</function></csname>
      <csparam><ptr>struct&#160;obstack</ptr><parameter>obstack-ptr</parameter></csparam>
     </csproto>
     <para>
      Öbeklere tahsis edilecek boyut. Sol taraf değeri olup değer buna atanır. Bkz. <xref linkend="glibc-Obstack-Chunks"/>.
     </para>
     <header>&obstack.h;</header>
    </csynopsis>
   </sect2>
  </sect1>
  <sect1 xml:id="glibc-Variable-Size-Automatic" userlevel="notoc">
   <?dbhtml stop-chunking?>
   <title>Değişken Boyutlu Özdevinimli Saklama</title>
   <titleabbrev>Karmaşık deyimler içindeki özdevinimli değişkenler için değişken boyutlu yer tahsisi.</titleabbrev>
   <para>
    <indexterm linkend="glibc-cp"><primary>bellek</primary><secondary>serbest bırakma</secondary><tertiary>özdevinimli</tertiary></indexterm>
    <indexterm linkend="glibc-cp"><primary><code>alloca</code> işlevi</primary></indexterm>
    <indexterm linkend="glibc-cp"><primary>değişken boyutlu özdevinimli saklama</primary></indexterm>
    <function>alloca</function> işlevi, özdevimli tahsis edilmiş ama özdevinimli serbest bırakılan dilimlerin yarı özdevimli bir bellek tahsis çeşidini destekler.
   </para>
   <para>
    <function>alloca</function> ile bir bloğun tahsisi doğrudan uygulanan bir eylemdir; istendiği kadar dilim tahsis edilebilir ve çalışma anında boyutu hesaplanabilir. Ancak serbest bırakma işlemi <function>alloca</function> işlevinin çağrıldığı işlevden çıkıldığında özdevinimli olarak gerçekleşir. Tahsis edilen alanı doğrudan serbest bırakmanın yolu yoktur.
   </para>
   <para>
    <indexterm linkend="glibc-pg"><primary>stdlib.h</primary></indexterm>
    <function>alloca</function> işlevi bir BSD oluşumudur.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-alloca"><primary>alloca</primary></indexterm>
    <csproto type="işlev">
     <csname><ptr>void</ptr><function>alloca</function></csname>
     <csparam><type>size_t</type><parameter>size</parameter></csparam>
    </csproto>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     Çağrıldığı işlevin yığıt çerçevesinde tahsis edilen <parameter>size</parameter> baytlık bloğun adresi ile döner.
    </para>
    <header>&stdlib.h;</header>
   </csynopsis>
   <para>
    <code>alloca</code> işlevi bir işlev çağrısının bağımsız değişkeni olarak kullanılmamalıdır, yoksa istenmeyen sonuçlar ortaya çıkabilir. Çünkü  <code>alloca</code> için tahsis edilmiş yığıt alanı, işlev bağımsız değişkenlerine tahsis edilmiş alanın ortasındaki yığıtta görünecektir. Örneğin, <code>foo (x, alloca (4), y)</code> gibi bir çağrı yapılmamalıdır.
   </para>
   <example xml:id="glibc-Alloca-Example">
    <title><code>alloca</code> Örneği</title>
    <para>
     İlk örnek, iki dizge bağımsız değişkeni alıp bunları birleşiminden bir dosya ismi elde eden ve bu dosyayı açtığında bu dosyaya bir tanıtıcı döndüren, dosyayı açamazsa açamadığını belirtmek üzere <code>-1</code> döndüren bir işlev:
    </para>
    <screen>int
open2 (char *str1, char *str2, int flags, int mode)
{
  char *name = (char *) alloca (strlen (str1) + strlen (str2) + 1);
  stpcpy (stpcpy (name, str1), str2);
  return open (name, flags, mode);
}
</screen>
    <para>
     İkinci örnekte ise aynı sonuç <function>malloc</function> ve <function>free</function> işlevleri ile elde edilmektedir:
    </para>
<screen>int
open2 (char *str1, char *str2, int flags, int mode)
{
  char *name = malloc (strlen (str1) + strlen (str2) + 1);
  int desc;
  if (name == 0)
    fatal ("virtual memory exceeded");
  stpcpy (stpcpy (name, str1), str2);
  desc = open (name, flags, mode);
  free (name);
  return desc;
}
</screen>
   </example>
   <para>
    Görüldüğü üzere <code>alloca</code> ile işlem daha basittir. Ancak <code>alloca</code> işlevinin getirileri kadar götürüleri de vardır.
   </para>
   <sect2 xml:id="glibc-Advantages-of-Alloca">
    <title><code>alloca</code> İşlevinin Getirileri</title>
    <titleabbrev><code>alloca</code> kullanma sebepleri.</titleabbrev>
    <para>
     <function>alloca</function> işlevinin <function>malloc</function> işlevine tercih edilmesindeki sebepler:
    </para>
    <itemizedlist>
     <listitem>
      <para>
       <function>alloca</function> kullanılarak çok küçük bir alan işe yaramaz hale gelir ve işlev çok hızlıdır. (GNU C derleyicisi içinde açık kodludur.)
      </para>
     </listitem>
     <listitem>
      <para>
       <function>alloca</function> farklı dilim boyları için ayrı havuzlar oluşturmadığından, kullanılan farklı boylardaki dilimler başka boylarda dilimler oluşturmak için yeniden kullanılabilir. <function>alloca</function> bellek saçılımına sebep olmaz.
      </para>
     </listitem>
     <listitem>
      <para>
       <function>longjmp</function> ile <xref linkend="glibc-Non-Local-Exits"/> <function>alloca</function> işlevini çağıran işlevden de çıkılmasına sebep olacağından <function>alloca</function> ile tahsis edilmiş alan özdevinimli olarak serbest bırakılır. Bu, <function>alloca</function> işlevinin kullanımı için en önemli sebeptir.
      </para>
      <para>
       Bunu görselleştirmek için, <function>open</function> gibi başarılı olduğunda bir dosya tanıtıcısı döndüren ama başarısız olduğunda dönmeyen  <replaceable>open_or_report_error</replaceable> isimli bir işlev olsun. Dosya açılamazsa bir hata iletisi bassın ve <function>longjmp</function> kullanarak yazılımın komut seviyesine geçsin. <link linkend="glibc-Alloca-Example">Önceki örnekteki</link> <function>open2</function> işlevi aşağıdaki örnekte bu işlevi kullanacak şekilde değiştirilmiştir:
      </para>
      <example>
       <screen>int
open2 (char *str1, char *str2, int flags, int mode)
{
  char *name = (char *) alloca (strlen (str1) + strlen (str2) + 1);
  stpcpy (stpcpy (name, str1), str2);
  return <replaceable>open_or_report_error</replaceable> (name, flags, mode);
}
</screen>
      </example>
      <para>
       <function>alloca</function> işlevi, çalışma şeklinden dolayı tahsis ettiği belleği hata oluşsa bile serbest bırakır ve bunun için ek bir çaba sarfetmek gerekmez.
      </para>
      <para>
       Aksine, <function>open2</function> işlevinin önceki tanımı (<function>malloc</function> ve <function>free</function> kullanılan tanımı) bu amaç için değiştirildiğinde bir bellek artığı oluşacaktı. Bunu düzeltmek için her değişikliği yapmaya razı olunsa bile, bunu yapmanın daha kolay bir yolu yoktur.
      </para>
     </listitem>
    </itemizedlist>
   </sect2>
   <sect2 xml:id="glibc-Disadvantages-of-Alloca">
    <title><code>alloca</code> İşlevinin Götürüleri</title>
    <titleabbrev><code>alloca</code> kullanmaktan kaçınma sebepleri.</titleabbrev>
    <para>
     <indexterm linkend="glibc-cp"><primary><code>alloca</code> kullanmama sebepleri</primary></indexterm>
     <function>alloca</function> işlevinin <function>malloc</function> ile karşılaştırıldığında bazı götürüleri vardır:
    </para>
    <itemizedlist>
     <listitem>
      <para>
       Makinenin sağladığından daha fazla bellek tahsis edilmeye çalışılırsa temiz bir hata iletisi gelmez. Bunun yerine bir sonsuz döngünün oluşturduğu gibi, olası bir bölütleme bozulmasından dolayı <link linkend="glibc-Program-Error-Signals">ölümcül bir sinyal</link> alınır.
      </para>
     </listitem>
     <listitem>
      <para>
       Bazı GNU dışı sistemlerde daha az taşınabilir olduğundan <function>alloca</function> desteği bulunmayabilir. Bununla birlikte, bu eksikliğin olduğu sistemlerde kullanmak için C ile yazılmış daha yavaş bir <function>alloca</function> taklidi mevcuttur.
      </para>
     </listitem>
    </itemizedlist>
   </sect2>
   <sect2 xml:id="glibc-GNU-C-Variable-Size-Arrays">
    <title>GNU C Değişken Boyutlu Dizileri</title>
    <titleabbrev>Özdevimli tahsis ve özdevinimli serbest bırakma için yalnızca GNU C için geçerli bir yöntem daha vardır.</titleabbrev>
    <para>
     <indexterm linkend="glibc-cp"><primary>değişken boyutlu diziler</primary></indexterm>
     GNU C'de <function>alloca</function> kullanımı yerine çoğu durumda değişken boyutlu diziler kullanılabilir. Önceki örneklerdeki <function>open2</function> işlevi şöyle değiştirilmiş olsun:
    </para>
    <example>
     <screen>int open2 (char *str1, char *str2, int flags, int mode)
{
  char name[strlen (str1) + strlen (str2) + 1];
  stpcpy (stpcpy (name, str1), str2);
  return open (name, flags, mode);
}
</screen>
    </example>
    <para>
     Ancak çeşitli sebeplerle, <function>alloca</function> daima değişken boyutlu bir diziye eşdeğer değildir:
    </para>
    <itemizedlist>
     <listitem>
      <para>
       Bir değişken boyutlu dizinin bellek alanı, dizi isminin etki alanının sonunda serbest bırakılır. <function>alloca</function> ile tahsis edilmiş alan ise işlev sonuna kadar kalır.
      </para>
     </listitem>
     <listitem>
      <para>
       <function>alloca</function> işlevi her yinelemede ek bir dilim tahsis etmek üzere bir döngü içinde kullanılabilir. Değişken boyutlu dizilerle bu mümkün değildir.
      </para>
     </listitem>
    </itemizedlist>
    <note>
     <para>
      Bir işlev içinde <function>alloca</function> ve değişken boyutlu diziler birlikte kullanılırsa, değişken boyutlu dizinin bildirildiği etki alanından çıkılması, o etki alanının yürütülmesi sırasında <function>alloca</function> ile tahsis edilen tüm bellek dilimlerinin serbest bırakılmasına yol açar.
     </para>
    </note>
   </sect2>
  </sect1>
 </chapter>

 <chapter xml:id="glibc-Resizing-the-Data-Segment">
  <title>Veri Bölütünün Boyunun Değiştirilmesi</title>
  <titleabbrev><code>brk</code> ve <code>sbrk</code></titleabbrev>
  <indexterm linkend="glibc-cp"><primary>bellek</primary><secondary>veri bölütü</secondary></indexterm>
  <para>
   Bu kısımdaki semboller &unistd.h; başlık dosyasında bildirilmiştir.
  </para>
  <para>
   <xref linkend="glibc-Memory-Allocation"/> bölümünde açıklanan işlevlerin kullanımı daha kolay olduğundan bu kısımda anlatılan işlevler normalde kullanılmaz. Bunlar, kullanıldıkları &glibc; bellek tahsisçisi için birer arayüz oldukları gibi sistem çağrılarının da basit birer arayüzüdür.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-brk"><primary>brk</primary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>brk</function></csname>
    <csparam><ptr>void</ptr><parameter>addr</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <code>brk</code> işlevi çağrıldığı sürecinin veri bölütünün yüksek ucunu <parameter>addr</parameter> olarak belirler.
   </para>
   <para>
    Bölüt sonunun adresi bölütteki son baytın adresi artı bir olarak tanımlıdır.
   </para>
   <para>
    Eğer <parameter>addr</parameter> veri bölütünün düşük sonundan daha düşükse işlev etkisizdir. (Bu durumda işlevin başarılı olduğu varsayılır.)
   </para>
   <para>
    Veri bölütü diğer bir bölütün içine girerse ya da <link  linkend="glibc-Limits-on-Resources">sürecin veri saklama sınırını</link> aşarsa işlev başarısız olur.
   </para>
   <para>
    Veri saklama alanı ve yığıtın aynı bölütte olduğu bir ortak geçmişsel bir olgu sebebiyle işlev bu ismi almıştır. Yığıt bölütünün üstünden altına doğru büyürken, veri saklama alanı bölütün altından üstüne doğru büyür ve bunlar arasındaki perdeye <firstterm>break</firstterm> denir.
   </para>
   <para>
    İşlev, başarı durumunda sıfır, başarısızlık durumunda <code>-1</code> döner ve hata kodu <varname>errno</varname> değişkenine atanır. Aşağıdaki <varname>errno</varname> değeri bu işleve özgüdür:
   </para>
   <glosslist>
    <glossentry>
     <glossterm><code>ENOMEM</code></glossterm>
     <glossdef>
      <para>
       İstek veri bölütünün başka bir bölütün içine girmesine ya da sürecin veri saklama sınırının aşılmasına sebep oldu.
      </para>
     </glossdef>
    </glossentry>
   </glosslist>
   <header>&unistd.h;</header>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-sbrk"><primary>sbrk</primary></indexterm>
   <csproto type="işlev">
    <csname><ptr>void</ptr><function>sbrk</function></csname>
    <csparam><type>ptrdiff_t</type><parameter>delta</parameter></csparam>
   </csproto>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    Bu işlev <command>brk</command> ile aynı sonucu verir, farklı olarak veri bölütünün yeni sonu, geçerli uçtan konum farkı olarak <varname>delta</varname> ile belirtilir ve işlev başarılı olduğunda sıfır yerine veri bölütünün sonunun adresi ile döner.
   </para>
   <para>
    Yani, veri bölütünün o anki sonunu öğrenmek için <command>sbrk(0)</command> kullanılabilir.
   </para>
   <header>&unistd.h;</header>
  </csynopsis>
 </chapter>

 <chapter xml:id="glibc-Memory-Protection">
  <title>Belleğin Korunması</title>
  <titleabbrev>Bellek bölgelerine erişimi denetleme.</titleabbrev>
  <indexterm linkend="glibc-cp"><primary>belleğin korunması</primary></indexterm>
  <indexterm linkend="glibc-cp"><primary>sayfanın korunması</primary></indexterm>
  <indexterm linkend="glibc-cp"><primary>bellek</primary><secondary>koruma</secondary></indexterm>
  <indexterm linkend="glibc-cp"><primary>sayfa</primary><secondary>koruma</secondary></indexterm>
  <indexterm linkend="glibc-cp"><primary>koruma bayrakları</primary></indexterm>
  <para>
   Bir sayfa <function>mmap</function> kullanılarak eşlendiğinde, sayfa koruma bayrakları, koruma bayrakları bağımsız değişkeni kullanılarak belirtilebilir. Bkz. <xref linkend="glibc-Memory-mapped-I-O"/>.
  </para>
  <para>
   Aşağıdaki bayraklar kullanılabilir.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-vr" xml:id="glibc-vr-PROT_WRITE"><primary>PROT_WRITE</primary></indexterm>
   <csproto type="sabit">
    <csname><function>PROT_WRITE</function></csname>
   </csproto>
   <para>
    Belleğe yazılabilir.
   </para>
   <header>&sys-mman.h;</header>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-vr" xml:id="glibc-vr-PROT_READ"><primary>PROT_READ</primary></indexterm>
   <csproto type="sabit">
    <csname><function>PROT_READ</function></csname>
   </csproto>
   <para>
    Bellek okunabilir. Bazı mimarilerde bu bayrak, belleğin de yürütülebileceğini ima eder (aynı anda <varname>PROT_EXEC</varname> belirtilmiş gibi).
   </para>
   <header>&sys-mman.h;</header>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-vr" xml:id="glibc-vr-PROT_EXEC"><primary>PROT_EXEC</primary></indexterm>
   <csproto type="sabit">
    <csname><function>PROT_EXEC</function></csname>
   </csproto>
   <para>
    Bellek daha sonra yürütülecek işlemci talimatlarını saklamak için kullanılabilir.  Bazı mimarilerde bu bayrak, belleğin okanabileceğini ima eder (aynı anda <varname>PROT_READ</varname> belirtilmiş gibi).
   </para>
   <header>&sys-mman.h;</header>
  </csynopsis>
  <csynopsis>
   <indexterm linkend="glibc-vr" xml:id="glibc-vr-PROT_NONE"><primary>PROT_NONE</primary></indexterm>
   <csproto type="sabit">
    <csname><function>PROT_NONE</function></csname>
   </csproto>
   <para>
    Bu bayrak tek başına belirtilmelidir.
   </para>
   <para>
    Bellek kayıt altına alınmıştır, ancak okunamaz, yazılamaz veya yürütülemez. Bu bayrak, bir <function>mmap</function> çağrısında belirtilirse, süreçte ileride kullanılmak üzere bir sanal bellek alanı belirlenir ve <varname>MAP_FIXED</varname> bayrağı olmaksızın, <function>mmap</function> çağrıları bunu sonraki tahsisler için kullanmaz. Çekirdek, anonim eşlemler için eşlemin oluşturulduğu sırada tahsis edilmek üzere herhangi bir fiziksel belleği kayıt altına almaz.
   </para>
   <header>&sys-mman.h;</header>
  </csynopsis>
  <para>
   Donanım, erişim denetimi amacıyla hepsini aynı şekilde ele alsa bile (bazı platformlarda <varname>PROT_READ</varname> ve <varname>PROT_EXEC</varname> ile olduğu gibi) işletim sistemi bu bayrakları ayrı ayrı takip edebilir. GNU sistemlerinde, <varname>PROT_EXEC</varname> her zaman <varname>PROT_READ</varname> anlamına gelir, böylece kullanıcılar sistemlerinde yürütülen makine kodunu görebilir.
  </para>
  <para>
   Uygun olmayan erişim parçalama arızasına sebep olur (bkz. <xref linkend="glibc-Program-Error-Signals"/>).
  </para>
  <para>
   Bellek tahsisinden sonra koruma bayrakları <function>mprotect</function> işlevi kullanılarak değiştirilebilir.
  </para>
  <csynopsis>
   <indexterm linkend="glibc-fn" xml:id="glibc-fn-mprotect"><primary>mprotect</primary></indexterm>
   <csproto type="işlev">
    <csname><type>int</type><function>mprotect</function></csname>
    <csparam><ptr>void</ptr><parameter>address</parameter></csparam>
    <csparam><type>size_t</type><parameter>length</parameter></csparam>
    <csparam><type>int</type><parameter>protection</parameter></csparam>
  </csproto>
   <conceptlist>
    <concept>&mtsafe;</concept>
    <concept>&assafe;</concept>
    <concept>&acsafe;</concept>
   </conceptlist>
   <para>
    <code>mprotect</code> işlevine yapılan başarılı bir çağrı, <parameter>address</parameter>'ten başlayarak en az <parameter>length</parameter> bayt uzunluktaki koruma bayraklarını değiştirir.
   </para>
   <para>
    <parameter>address</parameter>, eşleme için sayfa boyutuyla hizalanmalıdır. Sistem sayfa boyutu, <function>sysconf</function> işlevi <varname>_SC_PAGESIZE</varname> ile çağrılarak elde edilebilir (bkz. <xref linkend="glibc-Sysconf-Definition"/>). Sistem sayfası boyutu, anonim bellek eşlemelerinin ve çoğu dosya eşleminin sayfa korumasının değiştirilebildiği ayrıntı düzeyidir. Özel dosyalardan veya aygıtlardan eşlenen bellek, sistem sayfa boyutundan daha büyük sayfa ayrıntı düzeyine sahip olabilir ve daha büyük hizalama gerektirebilir.
   </para>
   <para>
    <parameter>length</parameter> ile belirtilen uzunluk, koruma bayraklarının değiştirilmesi gereken bayt sayısıdır. Özdevinimli olarak sistem sayfa boyutunun bir sonraki katına yuvarlanır.
   </para>
   <para>
    <parameter>protection</parameter> yukarda açıklanan <code>PROT_*</code> bayraklarının birleşimidir.
   </para>
   <para>
    <code>mprotect</code> işlevi başarı durumunda <code>0</code>, başarısızlık durumunda <code>-1</code> döndürür.
   </para>
   <para>
    Aşağıdaki <varname>errno</varname> hata durumları bu işlev için tanımlanmıştır:
   </para>
   <glosslist>
    <glossentry>
     <glossterm><code>ENOMEM</code></glossterm>
     <glossdef>
      <para>
       Sistem, isteği yerine getirmek için kaynak ayıramadı. Bu durum, sistemde yedeklemeye tahsis edilecek yeterli fiziksel bellek yoksa meydana gelebilir. Hata, yeni koruma bayraklarının bellek bölgesinin komşularından ayrılmasına neden olması ve bu tür farklı bellek bölgelerinin sayısı ile ilgili işlem/süreç sınırının aşılması durumunda da oluşabilir.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm><code>EINVAL</code></glossterm>
     <glossdef>
      <para>
       <parameter>address</parameter> eşlem için sayfa sınırına düzgün olarak hizalanmamış veya <parameter>length</parameter> eşlem için (sistem sayfa boyuna yukarı yuvarlandıktan sonra) uygulanabilir sayfa boyunun katlarında değil ya da <parameter>protection</parameter> içindeki bayrakların birleşimi geçersiz.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm><code>EACCES</code></glossterm>
     <glossdef>
      <para>
       Dosya tabanlı eşlem için dosya, <parameter>protection</parameter> ile uyumlu açma bayrakları ile açılmadı.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm><code>EPERM</code></glossterm>
     <glossdef>
      <para>
       Sistem güvenlik ilkesi, belirtilen bayraklarla eşleme izin vermiyor. Örneğin, aynı anda hem <varname>PROT_EXEC</varname> hem de <varname>PROT_WRITE</varname> olan eşlemlere izin verilmeyebilir.
      </para>
     </glossdef>
    </glossentry>
   </glosslist>
   <header>&sys-mman.h;</header>
  </csynopsis>
  <para>
   Bir bellek bölgesi, <code>mprotect</code> işlevi, <varname>PROT_NONE</varname> koruma bayrağı ile belirtilerek erişilemez duruma getirilirse ve daha sonra tekrar erişilebilir kılınırsa, bellek önceki içeriğini korur.
  </para>
  <para>
   Bazı sistemlerde, eşleme ilk oluşturulduğunda mevcut olmayan ek bayrakları belirtmek mümkün olmatabilir. Örneğin, ilk koruma bayrakları ‘<code>PROT_READ | PROT_WRITE</code>’ ise bellek bölgesini çalıştırılabilir yapma girişimi başarısız olabilir.
  </para>
  <para>
   Genel olarak <code>mprotect</code> işlevi, nasıl tahsis edilmiş olursa olsun herhangi bir süreç belleğini değiştirmek için kullanılabilir. Ancak, işlevin taşınabilir kullanımı, yalnızca <function>mmap</function> veya <function>mmap64</function> tarafından döndürülen bellek bölgeleriyle kullanılmasını gerektirir.
  </para>
  <sect1 xml:id="glibc-Memory-Protection-Keys">
   <title>Bellek Koruma Anahtarları</title>
   <titleabbrev>Her bellek sayfası ile ilişkili bir anahtar vardır.</titleabbrev>
   <para>
    <indexterm linkend="glibc-cp"><primary>bellek</primary><secondary>sayfa anahtarı</secondary></indexterm>
    <indexterm linkend="glibc-cp"><primary>sayfa</primary><secondary>koruma anahtarı</secondary></indexterm>
    <indexterm linkend="glibc-cp"><primary>bellek</primary><secondary>sayfa</secondary><tertiary>koruma anahtarı</tertiary></indexterm>
    Bazı sistemlerde, <emphasis>bellek koruma anahtarları</emphasis> kullanılarak belirli sayfalara daha fazla kısıtlama eklenebilir. Bu kısıtlamalar şu şekilde çalışır:
   </para>
   <itemizedlist>
    <listitem>
     <para>
      Tüm bellek sayfaları bir koruma anahtarıyla ilişkilendirilir. Öntanımlı koruma anahtarı, bellek erişimleri sırasında herhangi bir ek koruma uygulanmasına neden olmaz. Yeni anahtarlar, <function>pkey_alloc</function> işleviyle atanabilir ve <function>pkey_mprotect</function> kullanılarak sayfalara uygulanabilir.
     </para>
    </listitem>
    <listitem>
     <para>
      Her evrenin, her koruma anahtarı için bir dizi ayrı erişim hakkı kısıtlaması vardır. Bu erişim hakları, <function>pkey_set</function> ve <function>pkey_get</function> işlevleri kullanılarak değiştirilebilir.
     </para>
    </listitem>
    <listitem>
     <para>
      Bir bellek erişimi sırasında, erişilen sayfa için koruma anahtarını sistem sağlar ve geçerli evre için yapılandırıldığı şekliyle geçerli erişim haklarını belirlemek için bunu kullanır. Erişimin kısıtlanması, parçalanma arızası ile sonuçlanır (bkz. <xref linkend="glibc-Program-Error-Signals"/>). Bu denetimler, <function>mprotect</function> veya <function>pkey_mprotect</function> tarafından atanan <code>PROT_*</code> koruma bayraklarına ek olarak yapılır.
     </para>
    </listitem>
   </itemizedlist>
   <para>
    Yeni evreler ve alt süreçler, geçerli evre erişim haklarını devralır. Daha sonra bir koruma anahtarı tahsis edilirse, mevcut evreler (geçerli olan hariç), yeni tahsis edilen anahtarlarla ilişkili erişim hakları için belirtilmemiş olan sistem varsayılanı kullanır.
   </para>
   <para>
    Bir sinyal işleyiciye girildiğinde, sistem geçerli evrenin erişim haklarını sıfırlar, böylece varsayılan anahtarı olan sayfalara erişilebilir, ancak diğer koruma anahtarları için erişim hakları belirtilmez.
   </para>
   <para>
    Uygulamaların bir kez <function>pkey_alloc</function> kullanarak bir anahtar tahsis etmesi ve anahtarı <function>pkey_mprotect</function> ile özel koruma gerektiren bellek bölgelerine uygulaması beklenir:
   </para>
   <example>
    <screen>int key = pkey_alloc (0, PKEY_DISABLE_ACCESS);
if (key &lt; 0)
/* <replaceable>Destek yokluğu durumunda son çareyi içeren
   hata denetimini gerçekleştir.</replaceable> */
  ...;

/* <replaceable>Anahtarı, önemli verileri saklamak için kullanılan
   özel bellek bölgesine uygula.</replaceable> */
if (pkey_mprotect (region, region_length,
                   PROT_READ | PROT_WRITE, key) &lt; 0)
  ...; /* <replaceable>Hata denetimi yap (genelde ölümcül).</replaceable> */
</screen>
   </example>
   <para>
    Bellek koruma anahtarları için destek olmaması nedeniyle anahtar tahsisi başarısız olursa, <function>pkey_mprotect</function> çağrısı genellikle atlanabilir. Bu durumda, bölge korunmasız kalır. <code>-1</code> anahtar değeri ile  <function>pkey_mprotect</function> çağırmak da mümkündür, işlev bu durumda <function>mprotect</function> işlevi gibi davranacaktır.
   </para>
   <para>
    Bellek sayfalarına anahtar tahsisi atamasından sonra, <function>pkey_set</function> bellek bölgesine geçici olarak erişim elde edip vazgeçmek için kullanılabilir:
   </para>
   <example>
    <screen>if (key &gt;= 0 &amp;&amp; pkey_set (key, 0) &lt; 0)
  ...; /* <replaceable>Hata denetimi yap (genelde ölümcül).</replaceable>  */
/* <replaceable>Bu noktada, geçerli evrenin bellek bölgesine
   okuma-yazma erişimi vardır.</replaceable>  */
  ...
/* <replaceable>Yeniden erişilmez yap.</replaceable>  */
if (key &gt;= 0 &amp;&amp; pkey_set (key, PKEY_DISABLE_ACCESS) &lt; 0)
  ...; /* <replaceable>Hata denetimi yap (genelde ölümcül).</replaceable>.  */
</screen>
   </example>
   <para>
    Bu örnekte negatif bir anahtar değeri, herhangi bir anahtarın tahsis edilmediğini gösterir; bu, sistemin bellek koruma anahtarları için desteğinin olmadığı ve geçerli evrenin erişim haklarının değiştirilmesinin gerekmediği anlamına gelir (çünkü her zaman erişim izni vardır).
   </para>
   <para>
    Sayfa koruma bayraklarını değiştirmek için <function>mprotect</function> kullanmaya kıyasla, bu yaklaşımın iki getirisi vardır: Erişim haklarının yalnızca geçerli evre için değiştirilmesi anlamında evre açısından güvenlidir, yani eşleme erişim elde etmek için aynı anda kendi erişim haklarını değiştiren başka bir evre erişim haklarının birdenbire yürürlükten kaldırıldığını görmeyecektir. Ve <function>pkey_set</function> genel olarak çekirdeğe bir çağrı ve bir bağlam anahtarı içermez, bu nedenle daha verimlidir.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-pkey_alloc"><primary>pkey_alloc</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>pkey_alloc</function></csname>
     <csparam><type>unsigned&#160;int</type><parameter>flags</parameter></csparam>
     <csparam><type>unsigned&#160;int</type><parameter>restrictions</parameter></csparam>
    </csproto>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acunsafe; &corrupt;</concept>
    </conceptlist>
    <para>
     Yeni bir koruma anahtarı tahsis eder. <parameter>flags</parameter> bağımsız değişkeni şimdilik kullanılmamakta olup daima, sıfır olmalıdır. <parameter>restrictions</parameter> bağımsız değişkeni, geçerli evreye uygulanan erişim haklarını belirler (aşağıdaki <function>pkey_set</function> ile olduğu gibi). Diğer evrelerin erişim hakları değişmez.
    </para>
    <para>
     İşlev sıfırdan küçük olmayan bir sayı olarak yeni koruma anahtarını veya hata durumunda <code>-1</code> döndürür.
    </para>
    <para>
     Aşağıdaki <varname>errno</varname> hata durumları bu işlev için tanımlanmıştır:
    </para>
    <glosslist>
     <glossentry>
      <glossterm><code>ENOSYS</code></glossterm>
      <glossdef>
       <para>
        Sistem bellek koruma anahtarlarını gerçeklemiyor.
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm><code>EINVAL</code></glossterm>
      <glossdef>
       <para>
        <parameter>flags</parameter> bağımsız değişkeni sıfır değil.
       </para>
       <para>
        <parameter>restrictions</parameter> bağımsız değişkeni geçersiz.
       </para>
       <para>
        Sistem bellek koruma anahtarlarını ya gerçeklemiyor ya da bellek koruma anahtarlarının devre dışı olduğu kipte çalışıyor.
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm><code>ENOSPC</code></glossterm>
      <glossdef>
       <para>
        Kullanılabilir tüm bellek koruma anahtarları zaten tahsis edilmiş.
       </para>
       <para>
        Sistem bellek koruma anahtarlarını ya gerçeklemiyor ya da bellek koruma anahtarlarının devre dışı olduğu kipte çalışıyor.
       </para>
      </glossdef>
     </glossentry>
    </glosslist>
    <header>&sys-mman.h;</header>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-pkey_free"><primary>pkey_free</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>pkey_free</function></csname>
     <csparam><type>int</type><parameter>key</parameter></csparam>
    </csproto>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     <function>pkey_alloc</function> tarafından yeniden kullanılabilmesi için koruma anahtarını serbest bırakır.
    </para>
    <para>
     Bu işlevi çağırmak, serbest bırakılan koruma anahtarının erişim haklarını değiştirmez. Çağıran evre ve diğer evreler, daha sonra yeniden tahsis edilmiş olsa bile erişimlerini koruyabilir. Bu nedenle, <code>pkey_free</code>  işlevinin çağrılması önerilmez.
    </para>
    <glosslist>
     <glossentry>
      <glossterm><code>ENOSYS</code></glossterm>
      <glossdef>
       <para>
        Sistem bellek koruma anahtarlarını gerçeklemiyor.
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm><code>EINVAL</code></glossterm>
      <glossdef>
       <para>
        <parameter>key</parameter> bağımsız değişkeni geçerli bir koruma anahtarı değil.
       </para>
      </glossdef>
     </glossentry>
    </glosslist>
    <header>&sys-mman.h;</header>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-pkey_mprotect"><primary>pkey_mprotect</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>pkey_mprotect</function></csname>
     <csparam><ptr>void</ptr><parameter>address</parameter></csparam>
     <csparam><type>size_t</type><parameter>length</parameter></csparam>
     <csparam><type>int</type><parameter>protection</parameter></csparam>
     <csparam><type>int</type><parameter>key</parameter></csparam>
    </csproto>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     <function>mprotect</function>'e benzer, ancak aynı zamanda <parameter>key</parameter> anahtarını bellek bölgesi için bellek koruma anahtarı yapar.
    </para>
    <para>
     Bazı sistemler, belirli koruma bayrağı birleşimlerini taklit etmek için bellek koruma anahtarları kullanır. Bu gibi durumlarda, koruma anahtarının doğrudan belirtilmesi, varsayılan koruma anahtarında gerçekleşmese bile, <parameter>protection</parameter> bağımsız değişkeninde ek bayraklar belirtilmiş gibi davranabilir. Örneğin, bazı sistemler yalnızca <varname>PROT_EXEC</varname> eşlemlerini yalnızca varsayılan koruma anahtarıyla destekleyebilir ve <varname>PROT_READ</varname> olmadan <varname>PROT_EXEC</varname> belirtilirse, <function>pkey_alloc</function> kullanılarak tahsis edilmiş anahtara sahip bellek yine de okunabilir olacaktır.
    </para>
    <para>
     <parameter>key</parameter> bağımsız değişkeni <code>-1</code> ise, varsayılan koruma anahtarı <function>mprotect</function> çağrılmış gibi eşleme uygulanır.
    </para>
    <para>
     <code>pkey_mprotect</code> işlevi başarı durumunda <code>0</code>, başarısızlık durumunda <code>-1</code> döndürür. <function>mprotect</function> için tanımlı hata durumlarına ek olarak aşağıdaki <varname>errno</varname> hata durumları bu işlev için tanımlanmıştır:
    </para>
    <glosslist>
     <glossentry>
      <glossterm><code>EINVAL</code></glossterm>
      <glossdef>
       <para>
        <parameter>key</parameter> bağımsız değişkeni <code>-1</code> değil ya da <function>pkey_alloc</function> kullanarak tahsis edilmiş bellek koruma anahtarı geçersiz.
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm><code>ENOSYS</code></glossterm>
      <glossdef>
       <para>
        Sistem bellek koruma anahtarlarını gerçeklemiyor ve <parameter>key</parameter> bağımsız değişkeni <code>-1</code> değil.
       </para>
      </glossdef>
     </glossentry>
    </glosslist>
    <header>&sys-mman.h;</header>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-pkey_set"><primary>pkey_set</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>pkey_set</function></csname>
     <csparam><type>int</type><parameter>key</parameter></csparam>
     <csparam><type>unsigned&#160;int</type><parameter>rights</parameter></csparam>
    </csproto>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     Bellek sayfaları için geçerli evrenin erişim haklarını <parameter>key</parameter> koruma anahtarı ile <parameter>rights</parameter> haklarına değiştirir. <parameter>rights</parameter> sıfırsa, sayfa koruma bayraklarının üstünde hiçbir ek erişim kısıtlaması uygulanmaz. Aksi takdirde, <parameter>rights</parameter> aşağıdaki bayrakların birleşimi olmalıdır:
    </para>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-PKEY_DISABLE_WRITE"><primary>PKEY_DISABLE_WRITE</primary></indexterm>
     <csproto type="sabit">
      <csname><function>PKEY_DISABLE_WRITE</function></csname>
     </csproto>
     <para>
      Belirtilen koruma anahtarıyla belleğe sonraki yazma denemeleri hata verecektir.
     </para>
     <header>&sys-mman.h;</header>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-PKEY_DISABLE_ACCESS"><primary>PKEY_DISABLE_ACCESS</primary></indexterm>
     <csproto type="sabit">
      <csname><function>PKEY_DISABLE_ACCESS</function></csname>
     </csproto>
     <para>
      Belirtilen koruma anahtarıyla belleğe yazma veya bellekten okumaya yönelik sonraki girişimler hata verecektir.
     </para>
     <header>&sys-mman.h;</header>
    </csynopsis>
    <para>
     Bayrak olarak belirtilmeyen işlemler kısıtlanmaz. Bu, bellek bölgesinin özellikle, <varname>PROT_EXEC</varname> koruma bayrağıyla eşlenmişse ve <varname>PKEY_DISABLE_ACCESS</varname> belirtilmişse, yürütülebilir olarak kalacağı anlamına gelir.
    </para>
    <para>
     <code>pkey_set</code> işlevinin, <function>pkey_alloc</function> tarafından tahsis edilmemiş bir koruma anahtarıyla çağrılması tanımlanmamış davranışa neden olur. Yani, bellek koruma anahtarlarını desteklemeyen sistemlerde bu işlevi çağrılması anlamsızdır.
    </para>
    <para>
     <code>pkey_set</code> işlevi başarı durumunda <code>0</code>, başarısızlık durumunda <code>-1</code> döndürür.
    </para>
    <para>
     Aşağıdaki <varname>errno</varname> hata durumları bu işlev için tanımlanmıştır:
    </para>
    <glosslist>
     <glossentry>
      <glossterm><code>EINVAL</code></glossterm>
      <glossdef>
       <para>
        Sistem, <parameter>rights</parameter> bağımsız değişkeninde ifade edilen erişim hakları kısıtlamalarını desteklemiyor.
       </para>
      </glossdef>
     </glossentry>
    </glosslist>
    <header>&sys-mman.h;</header>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-pkey_get"><primary>pkey_get</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>pkey_get</function></csname>
     <csparam><type>int</type><parameter>key</parameter></csparam>
    </csproto>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     Geçerli evrenin <parameter>key</parameter> koruma anahtarıyla bellek sayfalarına erişim haklarını döndürür. Dönen değer sıfır ya da <code>PKEY_DISABLE_*</code> bayraklarının birleşimidir; bkz. <function>pkey_set</function>.
    </para>
    <para>
     <code>pkey_get</code> işlevinin, <function>pkey_alloc</function> tarafından tahsis edilmemiş bir koruma anahtarıyla çağrılması tanımlanmamış davranışa neden olur. Yani, bellek koruma anahtarlarını desteklemeyen sistemlerde bu işlevi çağrılması anlamsızdır.
    </para>
    <header>&sys-mman.h;</header>
   </csynopsis>
  </sect1>
 </chapter>

 <chapter xml:id="glibc-Locking-Pages">
  <title>Sayfaların Kilitlenmesi</title>
  <titleabbrev>Sayfa hatasından korunma</titleabbrev>
  <preliminary>
   <para>
    <indexterm linkend="glibc-cp"><primary>sayfanın kilitlenmesi</primary></indexterm>
    <indexterm linkend="glibc-cp"><primary>sayfa</primary><secondary>kilitleme</secondary></indexterm>
    <indexterm linkend="glibc-cp"><primary>sayfalama</primary></indexterm>
    <indexterm linkend="glibc-cp"><primary>sayfa hatası</primary></indexterm>
    <indexterm linkend="glibc-cp"><primary>sayfalama</primary><secondary>içe (paging in)</secondary></indexterm>
    <indexterm linkend="glibc-cp"><primary>sayfalama</primary><secondary>dışa (paging out)</secondary></indexterm>
    Sistemden belirli bir sanal bellek sayfasını gerçek sayfa çerçevesi ile ilişkilendirmesi ve bu bağlantıyı tutması istenebilir. Yani sayfa zaten gerçek bellekte değilse gerçek belleğe alınması ve asla bellek dışına alınmayacak şekilde imlenmesi sağlanabilir. Böylece bir sayfa hatası oluşmaz. Bu işleme <wordasword>sayfanın kilitlenmesi</wordasword> denir.
  </para>
  <para>
   Bu kısımdaki işlevler, çağrıldıkları sürecin sayfalarını kilitler veya kilidini kaldırır.
  </para>
 </preliminary>
  <sect1 xml:id="glibc-Why-Lock-Pages">
   <title>Sayfalar Neden Kilitlenir?</title>
   <titleabbrev>Bu bölümün okunma sebepleri.</titleabbrev>
   <para>
    Sayfalama hataları şeffaf olarak belleğe alınacak sayfaların bellek dışında kalmaya devam etmesinden kaynaklandığından, bir sürecin sayfalarının kilitlenmesi ile nadiren ilgilenmesi gerekir. Ancak bellek kilitlemeyi gerektiren iki sebep daha vardır:
   </para>
   <itemizedlist>
    <listitem>
     <para>
      <indexterm linkend="glibc-cp"><primary>gerçek zamanlı işlemler</primary></indexterm>
      <indexterm linkend="glibc-cp"><primary>çalışma hızı</primary></indexterm>
      Hız. Bir sayfalama hatası sadece, sürecin basit bir bellek erişiminin ne kadar sürdüğüne duyarlı olmadığı takdirde görünür olur. Zamana bağlı süreçler, özellikle de gerçek zamanlı süreçler bekleyemez ya da çalışma hızındaki değişikliklerle başa çıkamayabilir.
     </para>
     <para>
      Bir süreç bu sebeple sayfaların kilitlenmesine ihtiyaç duyabildiği gibi ayrıca işlemci kullanımı bakımından diğer süreçlere göre de öncelik alması gerekebilr. Bkz. <xref linkend="glibc-Priority"/>
     </para>
     <para>
      Bazı durumlarda, sistem başarımını sürdürmek için hangi sayfaların gerçek bellekte kalmasının daha iyi olacağına sistemin istek halinde sayfalayıcısı yerine yazılımcının karar vermesi gerekebilir. Böyle durumlarda sayfaların kilitlenmesi işe yarayabilir.
     </para>
    </listitem>
    <listitem>
     <para>
      Gizlilik. Bazı gizlilik gerektiren şeyleri sanal bellekte tutuyorsanız ve sanal bellek gerçek belleğe alınamazsa, gizli kalması gereken şeylerin açığa çıkma şansı artar. Örneğin, disk alanına yazılmış bir parola, sanal ve gerçek bellekler tamamen temizlendikten sonra bile uzunca bir süre disk alanında kalmaya devam edebilir.
     </para>
    </listitem>
   </itemizedlist>
   <para>
    Sanal bellek kullanıcılarından biri bir sayfayı kilitlediği zaman, diğer süreçler ve hatta kendisi için daha az çerçeve kalabilir ve bu durum daha fazla sayfalama hatasına ve hatta sistemin yavaşlamasına sebep olabilir. Daha da kötüsü, yeterince büyük bir belleğin kilitlenmesi durumunda, bazı yazılımlar gerçek bellek yokluğundan dolayı hiç çalışamayabilir.
   </para>
  </sect1>
  <sect1 xml:id="glibc-Locked-Memory-Details">
   <title>Kilitli Bellekler Hakkında</title>
   <titleabbrev>Kilitli bellekler hakkında bilinmesi gereken herşey.</titleabbrev>
   <para>
    Bir bellek kilidi gerçek bellek çerçevesi ile değil, sanal sayfa ile ilişkilidir. Sayfalama kuralı: En az bir kilitli sayfası olan bir çerçeve asla dışa sayfalanmaz.
   </para>
   <para>
    Bellek kilitleri yığıta atılmaz. Yani, belli bir sayfanın kilidi iki kere açılamaz: bir sayfa ya kilitlidir ya da değildir.
   </para>
   <para>
    Bir bellek, süreç tarafından doğrudan kilidi açılmadıkça kilitli kalmaya devam eder. (Ancak sürecin sonlandırılması veya yeniden çalıştırma (exec) sanal belleğin mevcudiyetinin sona ermesine sebep olur ve artık o kilitli değildir denebilir).
   </para>
   <para>
    Bellek kilitleri alt süreçler tarafından miras alınmaz. (Ancak, günümüz Unix sistemlerinde, bir çatallamanın hemen ardından asıl ve alt sürecin sanal adres alanı aynı gerçek sayfa çerçevesiyle desteklenir ve böylece alt süreç kendini çatallayan sürecin kilitlerinden yararlanır.) Bkz. <xref linkend="glibc-Creating-a-Process"/>.
   </para>
   <para>
    <dicterm><english>superuser</english><turkish>root kullanıcısı</turkish></dicterm>
    <dicterm><english>superuser</english><turkish>sistem yöneticisi</turkish></dicterm>
    <dicterm><english>root directory</english><turkish>kök dizin (/)</turkish></dicterm>
    Diğer süreçleri etkilemesi nedeniyle bir sayfayı sadece root kullanıcısı kilitleyebildiği halde her süreç kendi sayfasının kilidini kaldırabilir.
   </para>
   <para>
    Bir sürece atanacak bellek miktarı ve sürecin kilitleyebileceği bellek miktarı ile ilgili sınırları sistem belirler. Bkz. <xref linkend="glibc-Limits-on-Resources"/>.
   </para>
   <para>
    Linux’ta sayfaların kilitlenmesi farklıdır. Aynı belleği paylaşmayan iki sanal sayfa yine de aynı çerçeve tarafından desteklenebilir.Her iki sayfanın da aynı veriyi içerdiği çekirdek tarafından biliniyorsa ve sanal sayfalardan biri ya da her ikisi de kilitli bile olsa çekirdek bunu verimlilik adına yapar.
   </para>
   <para>
    <indexterm xml:id="glibc-Locked-Memory-Detailsa" linkend="glibc-cp"><primary>sayfanın yazılırken taşınması sorunu</primary></indexterm>
    <indexterm xml:id="glibc-Locked-Memory-Detailsb" linkend="glibc-cp"><primary>bellek</primary><secondary>sayfa hatası</secondary><tertiary>yazarken kopyalama</tertiary></indexterm>
    Fakat süreçlerden biri sayfalardan birinde değişiklik yaparsa çekirdeğin onu başka bir çerçeveye alması ve sayfa verisiyle doldurması gerekir Bu, <emphasis>sayfanın yazılırken taşınma sorunu</emphasis> olarak adlandırılır.  Bu kısa bir süre alır, ancak sorunun büyümesi durumunda çerçevenin alınması G/Ç gerektirebilir.
   </para>
   <para>
    Yazılım geliştirilirken bunun oluşmayacağından emin olmak için sayfalar kilitlenmemeli, sayfalara  yazılmayacak olsa bile bir kere yazılmalı ve kullanılacak yığıt için önceden tahsis edilmiş çerçevelerin varlığından emin olmak için de ihtiyaç duyulan en büyük yığıt boyutundan daha büyük bir C özdevinimli değişkeninin bildirildiği bir etki alanına girip değişkene  atama yapılmalı ve değişken etki alanından döndürülmelidir.
   </para>
  </sect1>
  <sect1 xml:id="glibc-Page-Lock-Functions">
   <title>Sayfaları Kilitleyen ve Açan İşlevler</title>
   <titleabbrev>Bu işlemler nasıl yapılır.</titleabbrev>
   <para>
    Bu bölümdeki işlevler &sys-mman.h; başlık dosyasında bildirilmiştir. Bu işlevler POSIX.1b tarafından tanımlanmıştır ama kullanılabilirliği sistemin çekirdeğine bağlıdır. Çekirdek bu işlevlere izin vermiyorsa var olsalar bile işlem başarısız olacaktır. Bu işlevler <emphasis>Linux çekirdeği ile kullanabilmektedir</emphasis>.
   </para>
   <note><title>Taşınabilirlik Bilgisi:</title>
    <para>
     POSIX.1b gereğince, <function>mlock</function> ve <function>munlock</function> işlevleri kullanılabilir olduğunda, bellek sayfasının bayt cinsinden boyunun &unistd.h; dosyasında <varname>_POSIX_MEMLOCK_RANGE</varname> makrosu ile ve &limits.h; dosyasında ise <varname>PAGESIZE</varname> makrosu ile tanımlanması gerekir.  Ayrıca, <function>mlockall</function> ve <function>munlockall</function> işlevleri de kullanılabilir olduğunda, &unistd.h; dosyasında <varname>_POSIX_MEMLOCK</varname> makrosunun da tanımlanmasını gerektirir. &glibc; bu gereksinimleri karşılar.
    </para>
   </note>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-mlock"><primary>mlock</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>mlock</function></csname>
     <csparam><ptr>const&#160;void</ptr><parameter>addr</parameter></csparam>
     <csparam><type>size_t</type><parameter>len</parameter></csparam>
    </csproto>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     <code>mlock</code> çağrıldığı sürecin sanal sayfalarının belli bir bölümünü kilitler.
    </para>
    <para>
     Kilitlenecek bölüm, <parameter>addr</parameter> adresinden başlar ve <parameter>len</parameter> bayt uzunluktadır. Tüm sayfaların kilitlenmesi gerektiğinden, aslında bu bölüm,  belirtilen aralığın herhangi bir kısmını içeren sayfalardan oluşur.
    </para>
    <para>
     İşlev başarılı olarak dönerse, bu sayfaların her biri bir gerçek bellek çerçevesi tarafından (yerleşik olarak) desteklenir (bağlanır) ve bu şekilde kalması için imlenir.  Bu, işlevin içe (gerçek belleğe) sayfalamalara sebep olması ve bunun gerçekleşmesini beklemek zorunda olması anlamına gelir.
    </para>
    <para>
     İşlev başarısız olursa, herhangi bir sayfa kilidini etklemez.
    </para>
    <para>
     İşlev başarı durumunda <code>0</code>, başarısızlık durumunda hata durumunu <varname>errno</varname> değişkenine atayıp <code>-1</code> döndürür. Aşağıdaki <varname>errno</varname> hata durumları bu işlev için tanımlanmıştır:
    </para>
    <glosslist>
     <glossentry>
      <glossterm><code>ENOMEM</code></glossterm>
      <glossdef>
       <simplelist>
        <member>
         Belirtilen adres aralığının bir kısmı çağıran sürecin sanal adres alanında değil.
        </member>
        <member>
         Kilitleme, sürecin kilitli sayfa sınırını aşmasına sebek olurdu.
        </member>
       </simplelist>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm><code>EPERM</code></glossterm>
      <glossdef>
       <para>
        Çağıran süreç root aidiyetinde değil.
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm><code>EINVAL</code></glossterm>
      <glossdef>
       <para>
        <parameter>len</parameter> sıfırdan büyük değil.
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm><code>ENOSYS</code></glossterm>
      <glossdef>
       <para>
        Çekirdeğin <code>mlock</code> yeteneği yok.
       </para>
      </glossdef>
     </glossentry>
    </glosslist>
    <header>&sys-mman.h;</header>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-mlock2"><primary>mlock2</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>mlock2</function></csname>
     <csparam><ptr>const&#160;void</ptr><parameter>addr</parameter></csparam>
     <csparam><type>size_t</type><parameter>len</parameter></csparam>
     <csparam><type>unsigned&#160;int</type><parameter>flags</parameter></csparam>
    </csproto>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     <function>mlock</function> işlevine benzer. <parameter>flags</parameter> sıfır olduğunda işlevin davranışı <function>mlock</function> işlevinin davranışı ile aynıdır.
    </para>
    <para>
     <parameter>flags</parameter> değeri sıfır veya aşağıdaki sabitlerin bir birleşimi olabilir:
    </para>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-MLOCK_ONFAULT"><primary>MLOCK_ONFAULT</primary></indexterm>
     <csproto type="sabit">
      <csname><function>MLOCK_ONFAULT</function></csname>
     </csproto>
     <para>
       Belirtilen adres aralığındaki sayfalardan yalnızca önceden bellekte bulunanlar hemen kilitlenir. Diğerleri, bir sayfa hatası ve bellek tahsisi durumunda özdevinimi olarak kilitlenir.
      </para>
      <header>&sys-mman.h;</header>
    </csynopsis>
    <para>
     <function>mlock</function> işlevine benzer şekilde, <code>mlock2</code> başarı durumunda <code>0</code>, başarısızlık durumunda hata durumunu <varname>errno</varname> değişkenine atayıp <code>-1</code> döndürür. Aşağıdaki <varname>errno</varname> hata durumları bu işlev için tanımlanmıştır:
    </para>
    <glosslist>
     <glossentry>
      <glossterm><code>EINVAL</code></glossterm>
      <glossdef>
       <para>
        Belirtilen (sıfırdan farklı) <parameter>flags</parameter> bağımsız değişkeni bu sistemde desteklenmiyor.
       </para>
      </glossdef>
     </glossentry>
    </glosslist>
    <header>&sys-mman.h;</header>
   </csynopsis>
   <para>
    Sürecin <emphasis>tüm</emphasis> belleği <function>mlockall</function> ile kilitlenebilir.  <function>munlock</function> veya <function>munlockall</function> ile bellek kilidi kaldırılabilir.
   </para>
   <para>
    Bir yazılımın kullandığ belleğin bir kısmı C kodundan gizli olduğundan bir C yazılımında tüm sayfa hatalarından kaçınmak için <function>mlockall</function> kullanılmalıdır. Örneğin, yığıt değişkenleri, özdevinimli değişkenler ve <function>mlock</function> işlevine hangi adresin belirtileceği bilinemez.
   </para>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-munlock"><primary>munlock</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>munlock</function></csname>
     <csparam><ptr>const&#160;void</ptr><parameter>addr</parameter></csparam>
     <csparam><type>size_t</type><parameter>len</parameter></csparam>
    </csproto>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     <code>munlock</code> işlevi çağrıldığı sürecin sanal sayfalarından belirtilen kadarının kilidini açar.
    </para>
    <para>
     <code>munlock</code> işlevi <function>mlock</function> ve benzerlerinin  tersidir ve <varname>EPERM</varname> başarısızlığı söz konusu değildir.
    </para>
    <header>&sys-mman.h;</header>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-mlockall"><primary>mlockall</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>mlockall</function></csname>
     <csparam><type>int</type><parameter>flags</parameter></csparam>
    </csproto>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     <code>mlockall</code> bir sürecin sanal adres alanındaki ve/veya ilerde eklenecek tüm sayfaları kilitler. Kod sayfaları, veri ve yığıt bölütü, paylaşımlı kütüphaneler, kullanıcı alanı çekirdek verisi, paylaşımlı bellek ve bellek eşlemli dosyalar buna dahildir.
    </para>
    <para>
     <parameter>flags</parameter> aşağıdaki makrolarla ifade edilen tek bitlik  bayrakların bir dizgesi olup bunlar <code>mlockall</code>'dan istenen işlevselliğin belirtilmesinde kullanılır. Tüm diğer bitler sıfır olmalıdır.
    </para>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-MCL_CURRENT"><primary>MCL_CURRENT</primary></indexterm>
     <csproto type="sabit">
      <csname><function>MCL_CURRENT</function></csname>
     </csproto>
     <para>
      İşlevi çağıran sürecin sanal adres alanındaki sayfaların geçerli olanlarının tümünü kilitle.
     </para>
     <header>&sys-mman.h;</header>
    </csynopsis>
    <csynopsis>
     <indexterm linkend="glibc-vr" xml:id="glibc-vr-MCL_FUTURE"><primary>MCL_FUTURE</primary></indexterm>
     <csproto type="sabit">
      <csname><function>MCL_FUTURE</function></csname>
     </csproto>
     <para>
      İşlevi çağıran sürecin sanal adres alanına ilerde eklenecek tüm sayfaların eklendiği andan itibaren kilitlenmesini sağlayacak kipi etkinleştir. Bu kip, sürecin adres alanını değiştirip <code>MCL_FUTURE</code> bayrağını silen (alt) süreç başlatma (<function>exec</function>) işleminden kaynaklanan, sürecin gelecekteki adres alanları üzerinde etkili değildir.
     </para>
     <header>&sys-mman.h;</header>
    </csynopsis>
    <para>
     <varname>MCL_CURRENT</varname> bayrağının belirtildiği işlev başarılı olarak dönerse, işlevi çağıran sürecin sayfalarının her biri bir gerçek bellek çerçevesi tarafından (yerleşik olarak) desteklenir (bağlanır) ve bu şekilde kalması için imlenir.  Bu, işlevin içe (gerçek belleğe) sayfalamalara sebep olması ve bunun gerçekleşmesini beklemek zorunda olması anlamına gelir.
    </para>
    <para>
     Süreç <varname>MCL_FUTURE</varname> kipindeyse bu işlev başarılı olduğundan dolayıdır ve <varname>MCL_CURRENT</varname> belirtildiğinde, alanın süreç tarafından sanal bellek alanına eklenmesini gerektiren bir sistem çağrısıyla ek alanın kilitlenmesi, sürecin kilitli sayfa sınırını aşmasına sebep oluyorsa işlev <varname>errno</varname> = <varname>ENOMEM</varname> hatasıyla başarısız olur. Bu durumda yığıt genişlemesi ile bağdaştırılamayan adres alanı eklemesindan dolayı yığıt genişlemesi başarısız olur, bunun sonucunda da çekirdek sürece bir <varname>SIGSEGV</varname> sinyali gönderir.
    </para>
    <para>
     İşlev başarısız olduğunda, kilitli sayfaların durumu veya gelecektekileri kilitleme kipi bundan etkilenmez.
    </para>
    <para>
     İşlev başarı durumunda <code>0</code>, başarısızlık durumunda hata durumunu <varname>errno</varname> değişkenine atayıp <code>-1</code> döndürür. Aşağıdaki <varname>errno</varname> hata durumları bu işlev için tanımlanmıştır:
    </para>
    <glosslist>
     <glossentry>
      <glossterm><code>ENOMEM</code></glossterm>
      <glossdef>
       <simplelist>
        <member>
         Belirtilen adres aralığının bir kısmı çağıran sürecin sanal adres alanında değil.
        </member>
        <member>
         Kilitleme, sürecin kilitli sayfa sınırını aşmasına sebek olurdu.
        </member>
       </simplelist>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm><code>EPERM</code></glossterm>
      <glossdef>
       <para>
        Çağıran süreç root aidiyetinde değil.
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm><code>EINVAL</code></glossterm>
      <glossdef>
       <para>
        <parameter>flags</parameter> içindeki tanımsız bitler sıfır değil.
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm><code>ENOSYS</code></glossterm>
      <glossdef>
       <para>
        Çekirdeğin <code>mlockall</code> yeteneği yok.
       </para>
      </glossdef>
     </glossentry>
    </glosslist>
    <para>
     Yalnızca belli sayfalar <function>mlock</function> ile kilitlenebilir. <function>munlockall</function> ve <function>munlock</function> ile sayfaların kilitleri kaldırılabilir.
    </para>
    <header>&sys-mman.h;</header>
   </csynopsis>
   <csynopsis>
    <indexterm linkend="glibc-fn" xml:id="glibc-fn-munlockall"><primary>munlockall</primary></indexterm>
    <csproto type="işlev">
     <csname><type>int</type><function>munlockall</function></csname>
     <csparam><code>void</code></csparam>
    </csproto>
    <conceptlist>
     <concept>&mtsafe;</concept>
     <concept>&assafe;</concept>
     <concept>&acsafe;</concept>
    </conceptlist>
    <para>
     <code>munlockall</code> çağrıldığı sürecin sanal adres alanındaki her sayfanın kilidini kaldırır ve <varname>MCL_FUTURE</varname> gelecekte kilitleme kipini kapatır.
    </para>
    <para>
     İşlev başarı durumunda <code>0</code>, başarısızlık durumunda hata durumunu <varname>errno</varname> değişkenine atayıp <code>-1</code> döndürür. Bu işlevin başarısız olmasının tek yolu, genel nedenlerden dolayı tüm işlevlerin ve sistem çağrılarının başarısız olmasıdır, dolayısıyla belirli bir <varname>errno</varname> değeri yoktur.
    </para>
    <header>&sys-mman.h;</header>
   </csynopsis>
  </sect1>
 </chapter>
</part>

