<?xml version="1.0" encoding="UTF-8"?>

<!-- ********************************************************************
     $Id: ch03.xml,v 1.2 2002/12/20 22:29:48 nilgun Exp $
******************************************************************** -->
<part id="glibc-Memory">
  <title>Sanal Bellek Ayırma ve Sayfalama</title>
  <titleabbrev>Sanal belleğin ayrılması ve sayfalamanın denetimi.</titleabbrev>
  <partintro>
    <para>
<dicterm><english>memory</english><turkish>bellek</turkish></dicterm>
<indexterm scope="glibc-cp"><primary>bellek ayırma</primary></indexterm>
<indexterm scope="glibc-cp"><primary>saklama alanı ayırma</primary></indexterm>
Bu kısımda GNU C kütüphanesi kullanılan bir sistemde belleğin kullanımı ve süreçlerin yönetiminden bahsedilmiştir.
    </para><para>
GNU C kütüphanesi sanal belleği farklı yollarla özdevimli ayırmak için çeşitli işlevler içerir. Bu çeşitlilik genellik ve tutarlılık anlamındadır. Kütüphane ayrıca gerçek belleğin ayrılması ve sayfalamanın denetlenmesi için işlevler de sağlar.
    </para><para>
<xref linkend="glibc-Memory-mapped-I-O"/> bu kısımda ele alınmamıştır.
    </para>
  </partintro>
  <chapter id="glibc-Memory-Concepts">
    <title>Süreç Belleği Kavramları</title>
    <titleabbrev>Kavramlara ve terminolojiye bir bakış.</titleabbrev>
    <para/><para>
<dicterm><english>frame</english><turkish>çerçeve</turkish></dicterm>
<dicterm><english>frame</english><turkish>gerçek bellek sayfası</turkish></dicterm>
Bir sürecin kullanabildiği çok temel özkaynaklardan biri bellektir. Sistemlerin belleği düzenlemesi için çok çeşitli yollar olmakla birlikte, genellikle tercih edilen,  sıfırdan çok büyük değerlere kadar büyüyebilen adreslerle her sürecin bir doğrusal sanal adres alanına sahip olmasıdır. Onun bir süreklilik içermesi gerekmez; örneğin, bu adreslerin hepsi gerçekte veri saklamak için değildir.
    </para><para>
<dicterm><english>swap space</english><turkish>takas alanı</turkish></dicterm>
Sanal bellek sayfalara bölünmüştür (genellikle 4 kilobaytlık). Sanal bellekteki her sayfa, bir gerçek bellek sayfası (<wordasword>çerçeve</wordasword> de denir) veya ikincil bir saklama alanı ya da çoğunlukla disk alanı olarak gerçeklenir. Disk alanı, takas alanı olabileceği gibi sıradan bir disk dosyası da olabilir. Gerçekte, bir sayfa tamamen sıfırlardan oluşabilir ve içinde hiçbir şey bulunmayabilir (bir sayfanın sadece sıfırlardan oluştuğunu belirten bir bayrak vardır).
<indexterm scope="glibc-cp"><primary>çerçeve</primary><secondary>sayfa</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>çerçeve</primary><secondary>gerçek bellek</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>takas alanı</primary></indexterm>
<indexterm scope="glibc-cp"><primary>sayfa</primary><secondary>sanal bellek</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>sayfalama</primary></indexterm>
<dicterm><english>paging</english><turkish>bellek sayfalaması</turkish></dicterm>
Gerçek belleğin veya yedekleme alanının bir çerçevesi çok sayıda süreç için çok sayıda sanal sayfayı destekleyebilir. Bu normal bir durumdur. Örneğin, sanal bellek GNU C kütüphanesi tarafından işgal edilebilir. Bu durumda <command>printf</command> işlevini içeren gerçek bellek sayfası, işlevi kullanan çok sayıda sürecin herbiri için bir sanal bellek sayfası olur.
    </para><para>
Bir yazılımın bir sanal sayfanın herhangi bir parçasına erişebilmesi için sayfa ("ilintili") bir gerçek çerçeve tarafından yedeklenir. Ancak gerçekte sanal bellek gerçek bellekten daha büyük olduğundan, sayfalar düzenli olarak, gerçek bellek ile yedekleme deposu arasında ileri ve geri taşınması, bir sürecin onlara erişmesi gerektiğinde gerçek belleğe alınması ve gerek kalmadığında da yedekleme deposuna geri taşınması gerekir. Bu devinime <wordasword>sayfalama</wordasword> denir.
    </para><para>
<dicterm><english>page fault</english><turkish>sayfalama hatası</turkish></dicterm>
<dicterm><english>paging in</english><turkish>gerçek belleğe  sayfalama</turkish></dicterm>
<dicterm><english>faulting in</english><turkish>gerçek belleğe  sayfalama</turkish></dicterm>
<dicterm><english>paging out</english><turkish>sanal belleğe  sayfalama</turkish></dicterm>
<dicterm><english>faulting out</english><turkish>sanal belleğe  sayfalama</turkish></dicterm>
Bir süreç bir sayfaya erişmeye çalışır ve sayfa gerçek belleğe kopyalanamazsa, bu olaya <wordasword>sayfalama hatası</wordasword> ("page fault") denir.  Bir sayfalama hatası oluştuğunda çekirdek süreci askıya alır ve sayfayı bir  gerçek sayfa çerçevesine kopyalar. Bu işleme <wordasword>gerçek belleğe  sayfalama</wordasword> ("paging in" or "faulting in") denir. Bu işlemin ardından artık sayfa gerçek bellekte erişilebilir olduğundan çekirdek tarafından askıya alınan süreç işlemine kaldığı yerden devam ettirilir. Aslında, tüm sayfalar sürece daima gerçek bellekteymiş gibi görünür. Bir şey dışında: bir makine dili komutun bekletilme süresi, olsun olsun ancak bir kaç nanosaniye sürer, çünkü çekirdek gerçek belleğe sayfalama işlemini bu kadar kısa sürede tamamlayabilir. Bu işleme duyarlı yazılımlar için kullanılan denetim işlevleri <xref linkend="glibc-Locking-Pages"/> bölümünde anlatılmıştır.
<indexterm scope="glibc-cp"><primary>sayfalama hatası</primary></indexterm>
<indexterm scope="glibc-cp"><primary>sayfalama</primary><secondary>gerçek belleğe sayfalama</secondary></indexterm>
    </para><para>
<dicterm><english>memory allocation</english><turkish>bellek ayırma</turkish></dicterm>
Her sanal adres alanı içinde, bir süreç hangi adreslerin ne olduğu bilgisine sahiptir ve bu sürece <wordasword>bellek ayırma</wordasword> denir. Ayırma süreci aslında kıt özkaynakları toplayarak kendine ayırır, ancak sanal bellek söz konusu olduğunda ana amaç bu değildir, çünkü orada genellikle herhangi bir ihtiyaca yetecekten fazlası vardır. Bir süreç içindeki bellek ayırma işleminin ana konusu iki farklı şeyin aynı bellek baytlarında olmadığından emin olmaktır.
    </para><para>
<dicterm><english>forking</english><turkish>çatallama</turkish></dicterm>
Süreçler belleği iki farklı yolla ayırır: çalıştırma sırasında ve yazılımsal olarak. Aslında, <link linkend="glibc-Creating-a-Process">çatallama</link> üçüncü bir yol olmakla beraber çok enteresan değildir.
    </para><para>
Çalıştırma (exec) bir işlemdir; bir süreç için bir sanal bellek ayırmak, ana yazılımı bu alana yüklemek ve yazılımı çalıştırmaktır. Bu, "exec" ailesi işlevlerle (örn, <command>execl</command>) yapılır. İşlem bir yazılım dosyası (bir çalıştırılabilir dosya) alır, içindeki tüm verinin yükleneceği alanı ayırır ve yazılımı da yükledikten sonra denetimi yazılıma aktarır. Bu veri çoğunlukla yazılımın komutlarından (<wordasword>metin</wordasword>) oluşmakla birlikte yazılımdaki dizgeler, sabitler ve hatta bazı değişkenleri de içerir: <link linkend="glibc-Memory-Allocation-and-C">durağan saklama sınıfı C değişkenleri</link>.
<indexterm scope="glibc-cp"><primary>çalıştırılabilir dosya</primary></indexterm>
<indexterm scope="glibc-cp"><primary>dizgeler</primary></indexterm>
<indexterm scope="glibc-cp"><primary>sabitler</primary></indexterm>
    </para><para>
Bir yazılım çalışmaya başladıktan sonra ek bellek kazanmak için yazılımsal ayırma  yapar. GNU C kütüphanesi kullanan bir C yazılımında, iki çeşit yazılımsal  ayırma kullanılabilir: özdevinimli (automatic) ve özdevimli (dynamic). Bkz. <xref linkend="glibc-Memory-Allocation-and-C"/>.
    </para><para>
Bellek eşlemli G/Ç diğer bir özdevimli sanal bellek ayırma şeklidir.  Belleğin bir dosyayla eşlenmesi, bir sürecin belli bir adres aralığındaki  içeriğinin belirtilen normal bir dosyanın içeriği ile eşdeğerde olacağının  bildirilmesidir. Sistem sanal belleğin dosyanın içeriğini içermesini sağlar ve eğer siz bellekte değişiklik yaparsanız sistem aynı değişiklikleri dosyaya yazar. Sanal belleğin çalışması ve sayfalama hatalarının sonuçları itibariyle, yazılım sanal belleğe erişinceye kadar, sistemin dosyayı okumak için G/Ç işlemleri yapması ve ona gerçek bellek ayırması için bir sebep yoktur. Bkz. <xref linkend="glibc-Memory-mapped-I-O"/>.
<indexterm scope="glibc-cp"><primary>bellek eşlemli G/Ç</primary></indexterm>
<indexterm scope="glibc-cp"><primary>bellek eşlemli dosya</primary></indexterm>
<indexterm scope="glibc-cp"><primary>dosyalar</primary><secondary>erişim</secondary></indexterm>
    </para><para>
Belleğin yazılımsal ayrılması gibi yazılım, yazılımsal olarak onu serbest  bırakabilir. Çalıştırma işlemi ile ayrılan belleği siz serbest bırakamazsınız. Ancak yazılımın çalışmasını sonlandırırsanız (exit) ona ayrılan tüm belleğin serbest kaldığından söz edilebilir, ancak adres alanı kesintiye uğramadan kalır ki bu nokta gerçekten tartışma götürür. Bkz. <xref linkend="glibc-Program-Termination"/>.
<indexterm scope="glibc-cp"><primary>yazılım</primary><secondary>çalıştırılması</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>yazılım</primary><secondary>çalışmanın sonlandırılması</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>bellek</primary><secondary>serbest bırakma</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>bellek</primary><secondary>ayırma</secondary></indexterm>
    </para><para id="glibc-segment">
<dicterm><english>segment</english><turkish>bölüt</turkish></dicterm>
<indexterm scope="glibc-cp"><primary>bölütler</primary></indexterm>
Bir sürecin adres alanı bölütlere bölünür. Bir <wordasword>bölüt</wordasword> kesintisiz bir sanal adres aralığıdır. Üç önemli bölüt vardır:
    </para><para>
<dicterm><english>text segment</english><turkish>metin bölütü (bir sürecin sanal adres alanlarından biri)</turkish></dicterm>
<dicterm><english>data segment</english><turkish>veri bölütü (bir sürecin sanal adres alanlarından biri)</turkish></dicterm>
<dicterm><english>stack segment</english><turkish>yığıt bölütü (bir sürecin sanal adres alanlarından biri)</turkish></dicterm>
      <variablelist><varlistentry><term id="glibc-text-segment">metin bölütü
<indexterm scope="glibc-cp"><primary>bölütler</primary><secondary>metin</secondary></indexterm>
      </term><listitem><para>
Bir yazılımın komutlarını, dizgelerini ve durağan sabitlerini içerir. Çalıştırma işlemi tarafından ayrılır ve yaşamı boyunca aynı boyutta sanal adres alanında kalır.
      </para></listitem>
      </varlistentry><varlistentry><term id="glibc-data-segment">veri bölütü
<indexterm scope="glibc-cp"><primary>bölütler</primary><secondary>veri</secondary></indexterm>
      </term><listitem><para>
Yazılımın çalışan deposudur. İlk ayırma ve ilk yükleme işlemi çalıştırma işlemi tarafından yapılabilir ve süreç tarafından <xref linkend="glibc-Resizing-the-Data-Segment"/> bölümünde açıklandığı gibi genişletilebilir veya daraltılabilir.  Alt ucu sabittir.
      </para></listitem>
      </varlistentry><varlistentry><term id="glibc-stack-segment">yığıt bölütü
<indexterm scope="glibc-cp"><primary>bölütler</primary><secondary>yığıt</secondary></indexterm>
      </term><listitem><para>
Bir yazılım yığıtı içerir.  Bir yığıtın büyüdüğü gibi büyür ama küçüldüğü gibi küçülmez.
      </para></listitem></varlistentry></variablelist>
    </para>
  </chapter>

  <chapter id="glibc-Memory-Allocation">
    <title>Yazılım Verisine Saklama Alanı Ayrılması</title>
    <titleabbrev>Yazılımınızın verilerine yer ayrılması</titleabbrev>
    <para/><para>
Bu bölümde sıradan yazılımların kendi verilerini nasıl yönettiği,  meşhur <command>malloc</command> işlevi ile GNU C kütüphanesi ve GNU derleyicisine özel oluşumlardan bahsedilmiştir.
    </para>
    <sect1 id="glibc-Memory-Allocation-and-C">
      <title>C Yazılımlarında Bellek Ayırma</title>
      <titleabbrev>C dilindeki bellek ayırma işlemleri.</titleabbrev>
      <para>
C dili, C yazılımlarındaki değişkenler için iki çeşit bellek ayırma işlemini destekler:
      </para><para>
<dicterm><english>static allocation</english><turkish>durağan bellek ayırma</turkish></dicterm>
<dicterm><english>static allocation</english><turkish>durağan ve genel değişkenler için bellekayırma</turkish></dicterm>
<dicterm><english>automatic allocation</english><turkish>özdevinimli bellek ayırma</turkish></dicterm>
<dicterm><english>automatic allocation</english><turkish>özdevinimli değişkenler için bellek ayırma</turkish></dicterm>
        <variablelist><varlistentry><term id="glibc-static-alloc">Durağan bellek ayırma
<indexterm scope="glibc-cp"><primary>bellek</primary><secondary>ayırma</secondary><tertiary>durağan</tertiary></indexterm>
<indexterm scope="glibc-cp"><primary>durağan saklama sınıfı</primary></indexterm>
        </term><listitem><para>
Bir durağan (static) veya genel (global) değişken tanımında durağan ayırma yapılır. Her durağan veya genel değişken sabit uzunlukta bir bellek bloğu tanımlar. Bu blok, yazılım ilk çalıştırıldığında bir kere ayrılır ve asla serbest bırakılmaz (durağan özelliği).
        </para></listitem>
        </varlistentry><varlistentry><term id="glibc-auto-alloc">Özdevinimli bellek ayırma
<indexterm scope="glibc-cp"><primary>bellek</primary><secondary>ayırma</secondary><tertiary>özdevinimli</tertiary></indexterm>
<indexterm scope="glibc-cp"><primary>özdevimli saklama sınıfı</primary></indexterm>
        </term><listitem><para>
Bir işlev argümanı ya da bir yerel değişken gibi bir özdevinimli bir değişken için özdevinimli bellek ayırması uygulanır. Bir özdevinimli (automatic) değişken için  bellek alanı bir birleşik deyim bildirimine girildiğinde ayrılır ve birleşik deyimin çalışması sona erdiğinde serbest bırakılır. GNU C'de bir özdevinimli saklama alanının uzunluğu bir ifade ile belirtilebilir ve değiştirilebilir.  Diğer C gerçeklemelerinde bu uzunluk bir sabit olmalıdır.
        </para></listitem></varlistentry></variablelist>
      </para><para>
Bir üçüncü bellek ayırma türü ise C değişkenleri tarafından desteklenmeyen ama GNU C kütüphanesi üzerinden kullanılabilen <wordasword>özdevimli bellek ayırma</wordasword>dır.
      </para>
      <sect2><title>Özdevimli Bellek Ayırma</title>
        <para>
<indexterm scope="glibc-cp"><primary>bellek</primary><secondary>ayırma</secondary><tertiary>özdevimli</tertiary></indexterm>
<dicterm><english>dynamic allocation</english><turkish>özdevimli bellek ayırma</turkish></dicterm>
<dicterm><english>dynamic allocation</english><turkish>malloc ile bellek ayırma</turkish></dicterm>
<dicterm><english>dynamic allocation</english><turkish>gösterici ile bellek ayırma</turkish></dicterm>
<dicterm><english>heap</english><turkish>özdevimli bellek</turkish></dicterm>
Özdevimli (dynamic) bellek ayırma, yazılımların çalışması sırasında bazı bilgilerin saklanmasını sağlayan bir tekniktir. Yazılımınızın bir bellek ihtiyacı olduğunda ancak ne kadar bellek ihtiyacı olacağı baştan belli olmayan durumlarda  bu teknik faydalıdır.
        </para><para>
Örneğin, bir girdi dosyasından okunan bir satırı saklamanız gerekebilir; bir satırın uzunluğunun belli bir sınırı olmadığından belleği özdevimli olarak ayırmanız ve satırdan daha fazlasını okumanız gerekirse özdevimli olarak bu alanı büyütmeniz gerekir.
        </para><para>
Veya, bir veri girdisi olarak her kayıt ya da her tanım için bir blok  gerekebilir; bunlardan kaç tane olacağını baştan bilemeyeceğinizden, her yeni kayıt için yeni bir blok veya her yeni tanım okunduğunda bir blok ayırmanız gerekir.
        </para><para>
Özdevimli bellek ayırması kullandığınızda, bir bellek bloğunun ayrılması yazılımın doğrudan doğruya istediği bir eylemdir. Alanı ayırmak istediğinizde ayırmak istediğiniz uzunluğu bir argüman olarak belirterek bir işlev ya da bir makro çağırırsınız. Bu alanı serbest bırakmak istediğinizde ise başka bir işlev ya da makroyu çağırırsınız. Tüm bu işlemleri ne zaman ve ne sıklıkta gerekiyorsa yapabilirsiniz.
        </para><para>
Özdevimli ayırma C değişkenlerince "dynamic" isminde bir saklama sınıfı olmadığından desteklenmez ve özdevimli ayrılmış alanda saklanan değerin atandığı bir C değişkeni asla olamaz. Özdevimli ayrılmış bellek almanın tek yolu bir sistem çağrısı üzerinden almak (bu sistem çağrısı genellikle GNU C kütüphanesinin bir işlevi üzerinden yapılır) ve ona erişmenin tek yolu da bir gösterici kullanmaktır. Daha az kullanışlı olduğundan ve özdevimli bellek ayırma işlemi daha fazla hesaplama gerektirdiğinden özdevimli ayırma sadece durağan ya da özdevinimli bellek ayırma uygulanamadığında kullanılır.
        </para><para>
Örneğin, bir <command>struct foobar</command> için özdevimli olarak bellek ayırması yapmak isterseniz, bu alandaki içerik için <command>struct foobar</command> türünde bir değişken bildiremezsiniz. Ama <command>struct foobar *</command> gösterici türünden bir değişken bildirebilir ve bu alanın adresini ona değer olarak atayabilirsiniz. Sonra da <command>*</command> ve <command>-></command> işleçlerini kullanarak bu alandaki içeriğe erişirsiniz:
        </para><para>
<screen>
{
  struct foobar *ptr
    = (struct foobar *) malloc (sizeof (struct foobar));
  ptr->name = x;
  ptr->next = current_foobar;
  current_foobar = ptr;
}
</screen></para>
      </sect2>
    </sect1>
    <sect1 id="glibc-Unconstrained-Allocation">
      <title>Özgür Bellek Ayırma</title>
      <titleabbrev><command>malloc</command> işlevi tamamen özdevimli bellek ayırır.</titleabbrev>
      <para>
<indexterm scope="glibc-cp"><primary>bellek</primary><secondary>özgür ayırma</secondary></indexterm>
<indexterm scope="glibc-cp"><primary><command>malloc</command> işlevi</primary></indexterm>
<indexterm scope="glibc-cp"><primary>yığın bellek (heap)</primary><secondary>özdevimli ayırma</secondary></indexterm>
En çok kullanılan özdevimli bellek ayırma oluşumu <command>malloc</command> işlevidir. Bu işlevi kullanarak istediğiniz zaman istediğiniz boyutta bellek bloğu ayırabilir, istediğinizde büyütebilir, küçültebilir ve ihtiyacınız kalmadığında serbest bırakabilir ya da hiç serbest bırakmayabilirsiniz.
      </para>
      <sect2 id="glibc-Basic-Allocation">
        <title>Özdevimli Olarak Basit Bellek Ayırma</title>
        <titleabbrev><command>malloc</command> işlevinin basit kullanımı.</titleabbrev>
        <para>
<dicterm><english>subroutine</english><turkish>işlem bloğu</turkish></dicterm>
<dicterm><english>sequence</english><turkish>dizilim</turkish></dicterm>
<dicterm><english>freeing</english><turkish>serbest bırakma (bellek)</turkish></dicterm>
<indexterm scope="glibc-cp"><primary>bellek</primary><secondary>ayırma</secondary><tertiary><function>malloc</function> ile</tertiary></indexterm>
Bir bellek bloğunu ayırmak için <command>malloc</command> çağrılır. Bu işlev <filename>stdlib.h</filename> başlık dosyasında bildirilmiştir.
<indexterm scope="glibc-pg"><primary>stdlib.h</primary></indexterm>
        </para><para id="glibc-malloc">
<indexterm scope="glibc-fn"><primary>malloc</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>void *<command>malloc</command></funcdef>
<paramdef>(size_t <varname>boyut</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev <varname>boyut</varname> bayt uzunlukta yeni bir bellek bloğu ayırabilirse bu bloğa bir gösterici ile döner yoksa bir boş gösterici ile döner.
          </para></funcdescr></funcsynopsis>
        </para><para>
Bloğun içi tanımsızdır; içeriğini kendiniz ilklendirmelisiniz (ya da  <command>calloc</command> kullanın). Bkz. <xref linkend="glibc-Allocating-Cleared-Space"/>.
        </para><para>
Normalde blok içinde saklamak istediğiniz nesnenin türüne bir gösterici olan değere tür dönüşümü uygulamalısınız. Aşağıda bu yönteme ilişkin bir örnek vardır. Burada blok, <command>memset</command> kütüphane işlevi kullanılarak sıfırlarla ilklendirilmektedir (Bkz. <xref linkend="glibc-Copying-and-Concatenation"/>):
     </para><para>
<screen>
struct foo *ptr;
…
ptr = (struct foo *) malloc (sizeof (struct foo));
if (ptr == 0) abort ();
memset (ptr, 0, sizeof (struct foo));
</screen></para><para>
ISO C <command>void *</command> türünü gerektiğinde özdevinimli olarak başka bir gösterici türüne dönüştürebildiğinden, <command>malloc</command> işlevinin  sonucunu bir tür dönüşümü yapmaksızın bir gösterici değişkeninde saklayabilirsiniz. Ancak kodu geleneksel C ile çalıştıracaksanız ya da atama işleci kullanmayacaksanız tür dönüşümü yapmanız gerekir.
        </para><para>
Bir dizge için yer ayırırken <command>malloc</command> işlevine belirteceğiniz argümanın değeri, dizgenin uzunluğu artı bir olmalıdır. Bu, dizgenin bir NULL karakteri ile sonlandırılması ve NULL karakterinin dizgenin uzunluğundan sayılmamasından dolayıdır. Örnek:
        </para><para>
<screen>
char *ptr;
…
ptr = (char *) malloc (length + 1);
</screen></para><para>
Bu konu hakkında daha ayrıntılı bilgi edinmek için <xref linkend="glibc-Representation-of-Strings"/> bölümüne bakınız.
        </para>
      </sect2><sect2 id="glibc-Malloc-Examples">
        <title><command>malloc</command> Örnekleri</title>
        <titleabbrev><command>malloc</command> ve <command>xmalloc</command> örnekleri.</titleabbrev>
        <para>
Ayrılabilecek bellek yoksa <command>malloc</command> bir boş gösterici ile döner. <command>malloc</command> işlevini her çağırışınızda dönen değere bakmalısınız. <command>malloc</command>'u çağıran, bir boş gösterge döndüğünde hatayı bildiren ve sadece sıfırdan farklı bir değerle dönen bir yardımcı işlev yazabilirsiniz. Bu yöntem teamülen <command>xmalloc</command> olarak bilinir ve aşağıdaki gibi gerçeklenir:
        </para><para>
<screen>
void * xmalloc (size_t size)
{
  register void *value = malloc (size);
  if (value == 0)
    fatal (&quot;sanal bellek tükendi&quot;);
  return value;
}
</screen></para><para>
Aşağıda ise <command>malloc</command> kullanılan (<command>xmalloc</command> yoluyla) gerçek bir örnek vardır. <function>savestring</function> işlevi bir karakter dizisini yeni ayrılan null sonlandırmalı dizgeye kopyalamaktadır:
        </para><para>
<screen>
char * savestring (const char *ptr, size_t len)
{
  register char *value = (char *) xmalloc (len + 1);
  value[len] = '\0';
  return (char *) memcpy (value, ptr, len);
}
</screen></para><para>
<command>malloc</command>'un size verdiği blok her türden veriyi tutabilir. GNU sisteminin bellek yönetimine göre,  bir çok sistemde adres sekizin katlarıdır, 64 bitlik sistemlerde ise onaltının katlarıdır. Daha yüksek sınırlar (sayfa seviyesi) gerekliyse <command>memalign</command>, <command>posix_memalign</command> veya <command>valloc</command>  kullanılır (Bkz. <xref linkend="glibc-Aligned-Memory-Blocks"/>).
        </para><para>
<note><para>Bir <command>malloc</command> çağrısı ile ayrılan bloğun sonuna  başka birşeyler için kullanılmak üzere  bellek eklenmesi gerekebilir. Daha önce ayrılmış bir bloğu büyütmek için <command>malloc</command> kullanmaya çalışırsanız ya önceki ayrılan bloğu ya da yenisini bozmanız mümkündür. Ayrılmış belleği sonradan büyütmek isterseniz <command>realloc</command> işlevini kullanın (Bkz. <xref linkend="glibc-Changing-Block-Size"/>).</para></note>
        </para>
      </sect2><sect2 id="glibc-Freeing-after-Malloc">
        <title><function>malloc</function> ile Ayrılan Belleğin Serbest Bırakılması</title>
        <titleabbrev>Bir bloğu <command>malloc</command> ile ayırdıysanız <command>free</command> ile serbest bırakabilirsiniz.</titleabbrev>
        <para>
<indexterm scope="glibc-cp"><primary>bellek</primary><secondary>serbest bırakma</secondary><tertiary><function>malloc</function> ile ayrılan</tertiary></indexterm>
<indexterm scope="glibc-cp"><primary>yığın bellek (heap)</primary><secondary>belleği serbest bırakmak</secondary></indexterm>
<command>malloc</command> ile ayırdığınız bir bloğa ihtiyacınız kalmadığında, ayrılan bloğu tekrar kullanılabilir hale getirmek için <command>free</command> ile serbest bırakmalısınız. <command>free</command> işlevi <filename>stdlib.h</filename> başlık dosyasında bildirilmiştir.
<indexterm scope="glibc-pg"><primary>stdlib.h</primary></indexterm>
        </para><para id="glibc-free">
<indexterm scope="glibc-fn"><primary>free</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>void <command>free</command></funcdef>
<paramdef>(void *<varname>gösterici</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>free</command> işlevi <varname>gösterici</varname> ile erişilen bellek bloğunu serbest bırakır.
          </para></funcdescr></funcsynopsis>
        </para><para id="glibc-cfree">
<indexterm scope="glibc-fn"><primary>cfree</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>void <command>cfree</command></funcdef>
<paramdef>(void *<varname>gösterici</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev <command>free</command> ile aynı işi yapar. İşlev SunOS ile geriye uyumluluk adına kütüphaneye dahil edilmiştir. Bu işlevi değil <command>free</command> işlevini kullanmalısınız.
          </para></funcdescr></funcsynopsis>
        </para><para>
Bir bloğun serbest bırakılması bloğun içeriğini değiştirir. <varname>Bir bloğu serbest bıraktıktan sonra bloğun içindeki bir veriye ulaşabileceğinizi sanmayın (örneğin bir blok zincirindeki sonraki bloğa bir gösterici belirterek.)</varname> Bir bloğu serbest bırakmadan önce içinde kullanacağınız bir bilgi varsa kopyalamayı unutmayın. Aşağıdaki örnekte bir zincirdeki blokların tümü sırayla serbest bırakılmaktadır:
        </para><para>
<screen>
struct chain
  {
    struct chain *next;
    char *name;
  }

void
free_chain (struct chain *chain)
{
  while (chain != 0)
    {
      struct chain *next = chain->next;
      free (chain->name);
      free (chain);
      chain = next;
    }
}
</screen></para><para>
<command>free</command> işlevi bellek alanını uzun dönemde işletim sistemine döndürür ve süreci küçültür. Sistem genelinde ise, bellek alanını yeniden kullanılmak üzere serbest bırakır ve daha sonraki <command>malloc</command> çağrılarını mümkün kılar. Kısa dönemde ise, serbest bırakılan alan <command>malloc</command> tarafından süreç dahilinde kullanılmak üzere bir serbest bırakılanlar listesinin parçası olarak bekletilir.
        </para><para>
Yazılımın çalışması sona erdiğinde blokların bırakılması gerekmez. Çünkü süreç sonlandığında sürece ayrılan tüm alan sisteme geri verilir.
        </para>
      </sect2><sect2 id="glibc-Changing-Block-Size">
        <title>Bir Bellek Bloğunun Boyutunun Değiştirilmesi</title>
        <titleabbrev><command>realloc</command> kullanarak bir blok büyütülebilir ve küçültülebilir.</titleabbrev>
        <para>
<indexterm scope="glibc-cp"><primary>bellek</primary><secondary><function>malloc</function> ile ayrılan bloğun boyunun değiştirilmesi</secondary></indexterm>
Çoğunlukla bir bellek bloğunu kullanmaya başlarken ihtiyacınız olacak bellek miktarını bilemez ve yaklaşık bir boyut ile bloğu ayırırsınız. Örneğin, blok bir dosyadan okunan satırı tutan bir tampon olabilir ve bir satır için yeterli olan tamponunuz başka bir satır için yetersiz kalabilir.
        </para><para>
<command>realloc</command> işlevini çağırarak bloğu uzatabilirsiniz. Bu işlev <filename>stdlib.h</filename> başlık dosyasında bildirilmiştir.
<indexterm scope="glibc-pg"><primary>stdlib.h</primary></indexterm>
        </para><para id="glibc-realloc">
<indexterm scope="glibc-fn"><primary>realloc</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>void *<command>realloc</command></funcdef>
<paramdef>(void  *<varname>gösterici</varname>,
 size_t <varname>yeniboyut</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>realloc</command> işlevi <varname>gösterici</varname> ile erişilen bloğun boyunu <varname>yeniboyut</varname> ile belirtilen değere ayarlar.
          </para><para>
Bloktan sora gelen alan kullanılabilir olsa da <command>realloc</command> işlevi bloğu daha fazla serbest alanın bulunduğu yeni bir adrese kopyalamayı gerekli bulabilir. <command>realloc</command> işlevi bloğun yeni adresi ile döner. Blokun taşınması gerekirse, <command>realloc</command> eski içeriği kopyalar.
          </para><para>
<command>realloc</command> işlevine <varname>gösterici</varname> için bir boş gösterici belirtirseniz, işlev, <command>malloc (<varname>newsize</varname>)</command> çağrılmış gibi davranır. Bu kullanışlı olabilirse de, ISO C öncesi C gerçeklemeleri bu davranışı desteklemeyebilir ve büyük ihtimalle <command>realloc</command> boş bir gösterici ile çökebilir.
          </para></funcdescr></funcsynopsis>
        </para><para>
<command>realloc</command> işlevi daha büyük blok oluşturamazsa tıpkı <command>malloc</command> işlevi gibi bir boş gösterici ile döner. Bu durum oluştuğunda eski bloka dokunulmaz; değiştirilmez ve başka bir konuma taşınmaz.
        </para><para>
Çoğu durumda <command>realloc</command> başarısız olduğunda eski bloğa ne olduğunun fazla bir önemi kalmaz. Çünkü uygulama yazılımı bellek yetmediğinde çalışmasını sürdüremez ve yapacak tek şey kalır: bir ölümcül hata iletisi ile kendini sonlandırmak. Çoğunlukla bu durum için bir yordam yazılır. <command>malloc</command> için benzer yordama <command>xmalloc</command> dendiği gibi <command>realloc</command> için olanına da <command>xrealloc</command> denir:
        </para><para>
<screen>
void * xrealloc (void *ptr, size_t size)
{
  register void *value = realloc (ptr, size);
  if (value == 0)
    fatal (&quot;Sanal bellek tükendi&quot;);
  return value;
}
</screen></para><para>
<command>realloc</command> işlevini bloğu küçültmek için de kullanabilirsiniz. Bu genelde daha küçük belleğin yeterli olduğu durumlarda bir bellek tıkanıklığı varsa ayrılan fazla belleği serbest bırakmak için yapılır. Bazı ayırma gerçeklemelerinde bir bloğun küçültülmesi bazı durumlarda kopyalanmasını zorunlu kılabilir ve kullanılabilir bir bellek yoksa işlev başarısız olabilir.
        </para><para>
<command>realloc</command> işlevine belirtilen yeni boyut eskisi ile aynıysa işlev hiçbir değişiklik yapmaz ve verdiğiniz adresi geri döndürür.
        </para>
      </sect2><sect2 id="glibc-Allocating-Cleared-Space">
        <title>Temizlenmiş Bellek Ayırma</title>
        <titleabbrev>Bir bloğu hem ayırıp hem de temizlemek için <command>calloc</command> kullanılır.</titleabbrev>
        <para>
<command>calloc</command> işlevi belleği ayırdıktan sonra içeriğini sıfırlarla doldurarak temizler. Bu işlev <filename>stdlib.h</filename> başlık dosyasında bildirilmiştir.
<indexterm scope="glibc-pg"><primary>stdlib.h</primary></indexterm>
        </para><para id="glibc-calloc">
<indexterm scope="glibc-fn"><primary>calloc</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>void *<command>calloc</command></funcdef>
<paramdef>(size_t <varname>elmsayısı</varname>,
 size_t <varname>elmboyu</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev boyu <varname>elmboyu</varname> olan <varname>elmtsayısı</varname> sayıda eleman içeren bir blok ayırır. Bu içerik <command>calloc</command> dönmeden önce sıfırlarla doldurulur.
          </para><para>
<command>calloc</command> işlevini aşağıdaki gibi tanımlayabilirsiniz:
          </para><para>
<screen>
void * calloc (size_t count, size_t eltsize)
{
  size_t size = count * eltsize;
  void *value = malloc (size);
  if (value != 0)
    memset (value, 0, size);
  return value;
}
</screen></para><para>
Ancak genelde, <command>calloc</command> işlevinin dahili olarak <command>malloc</command> işlevini çağıracağının garantisi yoktur. Bu nedenle, bir uygulama C kütüphanesi dışında kendi <command>malloc</command>, <command>realloc</command> ve <command>free</command> işlevlerini sağlıyorsa, <command>calloc</command> işlevini de mutlaka tanımlamalıdır.
          </para></funcdescr></funcsynopsis>
        </para>
      </sect2><sect2 id="glibc-Efficiency-and-Malloc">
        <title><function>malloc</function> için Yeterlik Kaygıları</title>
        <titleabbrev>Bu işlevlerin kullanımından duyulan yeterlik kaygıları.</titleabbrev>
<indexterm scope="glibc-cp"><primary>yeterlik ve <function>malloc</function></primary></indexterm>
        <para>
Diğer sürümlerin aksine GNU C kütüphanesindeki <command>malloc</command> işlevi ayırdığı belleğin boyunu ikinin kuvvetlerine ayarlamaz, dolayısıyla istenenden daha küçük ya da daha büyük bir bellek ayırmaz. Komşu bellek parçaları boyutlarına bakılmaksızın bir <command>free</command> üzerinden tek parça yapılabilir. Bu, yüksek belleğin küçük kesintili bloklar haline gelmesine sebep olmadan, gerçeklemeyi ayırma kalıplarının her türü için elverişli yapar.
        </para><para>
Çok büyük bloklar (bir sayfadan büyük) bu gerçeklenimce  <command>mmap</command> işlevi ile (anonim veya <filename>/dev/zero</filename> üzerinden) ayrılır. Serbest bırakıldıkları anda parçaların sisteme döndürülmesi büyük yarar sağlar. Bu bakımdan, daha küçük bir bloktan büyütülürken iki işlem arasında blok kilitli hale gelemez ve hatta <command>free</command> çağrısından sonra blok belleği boşalır. <command>mmap</command> için kullanılacak boyut eşiği <command>mallopt</command> ile ayarlanabilir. Ayrıca <command>mmap</command> kullanımı tamamen iptal de edilebilir.
        </para>
      </sect2><sect2 id="glibc-Aligned-Memory-Blocks">
        <title>Bellek Bloklarının Hizalanarak Ayrılması</title>
        <titleabbrev>Blokları özellikle adımlarını ayarlayarak adreslemek.</titleabbrev>
        <para>
<indexterm scope="glibc-cp"><primary>sayfa sınırı</primary></indexterm>
<indexterm scope="glibc-cp"><primary>hizalama</primary><secondary><function>malloc</function> ile</secondary></indexterm>
<indexterm scope="glibc-pg"><primary>stdlib.h</primary></indexterm>
Bir blok için <command>malloc</command> tarafından döndürülen adres GNU sistemlerinde daima sekizin katlarıdır (64 bitlik sistemlerde onaltının katlarıdır). Bir bloğun daha büyük adres adımları (adım boyu ikinin kuvveti olmalı) ile adreslenmesini isterseniz <command>memalign</command>, <command>posix_memalign</command> veya <command>valloc</command> işlevlerini kullanmalısınız. <command>memalign</command> işlevi <filename>malloc.h</filename>, <command>posix_memalign</command> işlevi ise <filename>stdlib.h</filename> başlık dosyasında bildirilmiştir.
        </para><para>
GNU kütüphanesi ile, <command>memalign</command>,  <command>posix_memalign</command> veya <command>valloc</command> ile dönen blokları serbest bırakmak için <command>free</command> kullanılır. Bu BSD ile çalışmaz, çünkü BSD bu tür blokları serbest bırakacak bir yol sağlamaz.
        </para><para id="glibc-memalign">
<indexterm scope="glibc-fn"><primary>memalign</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>void *<command>memalign</command></funcdef>
<paramdef>(size_t <varname>adımboyu</varname>,
 size_t <varname>boyut</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>memalign</command> işlevi <varname>boyut</varname> uzunluktaki bloğu <varname>adımboyu</varname>nun katları olan adreslerden birinde ayırır ve  bloğun adresi ile döner. <varname>adımboyu</varname> ikinin kuvveti olan  bir değer olmalıdır. İşlev büyük miktarda (sayfa kadar veya fazlası) bellek ayırmak için kullanılır.
          </para></funcdescr></funcsynopsis>
        </para><para id="glibc-posix_memalign">
<indexterm scope="glibc-fn"><primary>posix_memalign</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>posix_memalign</command></funcdef>
<paramdef>(void **<varname>gösterici</varname>,
 size_t <varname>adımboyu</varname>,
 size_t <varname>boyut</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>posix_memalign</command> işlevi <command>memalign</command> işlevine benzer şekilde <varname>adımboyu</varname>nun katlarına hizalayarak <varname>boyut</varname> uzunluktaki bir tampon ayırır. Ancak işlev <varname>adımboyu</varname> parametresinde bir özelliğin varlığına bağımlıdır: değer, <command>sizeof (void *)</command> değerinin ikinin kuvveti katı olmalıdır.
          </para><para>
İşlev, belleği ayırmada başarılı olursa, ayrılan belleğin göstericisi <command>*<varname>gösterici</varname></command>'ye atanır ve işlev sıfır değeriyle döner. Aksi takdirde sorunu belirten bir hata değeri ile döner.
          </para><para>
Bu işlev POSIX 1003.1d içinde geçer.
        </para></funcdescr></funcsynopsis>
        </para><para id="glibc-valloc">
<indexterm scope="glibc-fn"><primary>valloc</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>void *<command>valloc</command></funcdef>
<paramdef>(size_t <varname>boyut</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>valloc</command> işlevi sayfa boyunda adresleme ile <varname>boyut</varname> uzunlukta blok ayırır. <command>memalign</command> kullanılarak aşağıdaki gibi gerçeklenebilir:
        </para><para>
<screen>
void * valloc (size_t size)
{
  return memalign (getpagesize (), size);
}
</screen></para><para>
Bellek altsistemi hakkında ayrıntılı bilgi <xref  linkend="glibc-Query-Memory-Parameters"/> bölümünde bulunabilir.
        </para></funcdescr></funcsynopsis>
      </para>
    </sect2><sect2 id="glibc-Malloc-Tunable-Parameters">
      <title>Ayarlanabilir Malloc Parametreleri</title>
      <titleabbrev>Bellek ayırma parametreleri <command>mallopt</command> ile ayarlanır.</titleabbrev>
      <para>
Özdevimli bellek ayırma ile ilgili bazı parametreleri <command>mallopt</command> ile ayarlayabilirsiniz. Bu işlev bir genel SVID/XPG arayüzüdür ve <filename>malloc.h</filename> başlık dosyasında bildirilmiştir.
<indexterm scope="glibc-pg"><primary>malloc.h</primary></indexterm>
      </para><para id="glibc-mallopt">
<indexterm scope="glibc-fn"><primary>mallopt</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>mallopt</command></funcdef>
<paramdef>(int <varname>param</varname>,
 int <varname>değer</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>mallopt</command> işlevi çağrılırken ayarlanacak parametre <varname>param</varname> ile, değeri ise <varname>değer</varname> ile belirtilir. <filename>malloc.h</filename> başlık dosyasında tanımlı <varname>param</varname> seçenekleri şunlardır:
        </para><para>
          <variablelist><varlistentry><term><literal>M_TRIM_THRESHOLD</literal></term>
            <listitem><para>
Belleğin sisteme döndürülmesi sırasında bir negatif argüman ile <command>sbrk</command>'in çağrılmasına sağlayacak en tepedeki serbest bırakılabilir parçanın mümkün en küçük boyudur (bayt cinsinden).
            </para></listitem>
          </varlistentry><varlistentry><term><literal>M_TOP_PAD</literal></term>
            <listitem><para>
Bu parametre bir <command>sbrk</command> çağrısı gerektiğinde sistemden sağlanacak fazladan belleğin miktarını belirler. Ayrıca, bir negatif argümanla <command>sbrk</command> çağırarak yığın belleğin (heap) küçültülmesi sırasında tutulan baytların sayısını belirtir. Bu, yığın bellekte gerekli histerezisi oluşturur ve örneğin aşırı miktarlarda sistem çağrılarını engelleyebilir.
            </para></listitem>
          </varlistentry><varlistentry><term><literal>M_MMAP_THRESHOLD</literal></term>
            <listitem><para>
Bu değerden daha büyük parçalar <command>mmap</command> sistem çağrısı kullanılarak normal yığın belleğin dışında ayrılır.  Bu yol, bu parçaların <command>free</command> üzerinden sisteme döndürülebilirliğini garanti eder. Bu eşik değerden daha küçük istekler hala <command>mmap</command> üzerinden ayrılabilir.
            </para></listitem>
          </varlistentry><varlistentry><term><literal>M_MMAP_MAX</literal></term>
            <listitem><para>
<command>mmap</command> ile ayrılabilecek parçaların mümkün en büyük  sayısıdır. Bu parametreye sıfır değeri atanarak <command>mmap</command>  kullanımı iptal edilebilir.
            </para></listitem>
          </varlistentry></variablelist>
        </para></funcdescr></funcsynopsis>
      </para>
    </sect2><sect2 id="glibc-Heap-Consistency-Checking">
      <title>Yığın Bellek Tutarlılık Denetimi</title>
      <titleabbrev>Yığın belleğin hatalara karşı özdevinimli denetlenmesi.</titleabbrev>
      <para>
<indexterm scope="glibc-cp"><primary>bellek</primary><secondary>yığın (heap)</secondary><tertiary>tutarlılık denetimi</tertiary></indexterm>
<command>mcheck</command> işlevini kullanarak özdevimli ayrılan belleğin tutarlılığının <command>malloc</command> tarafından denetlenmesini isteyebilirsiniz. Bu işlev bir GNU oluşumudur ve <filename>mcheck.h</filename> başlık dosyasında bildirilmiştir.
<indexterm scope="glibc-pg"><primary>mcheck.h</primary></indexterm>
      </para><para id="glibc-mcheck">
<indexterm scope="glibc-fn"><primary>mcheck</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>mcheck</command></funcdef>
<paramdef>(void (*<varname>çıkış_işlevi</varname>) (enum mcheck_status <varname>durum</varname>))</paramdef>
</funcprototype><funcdescr><para>
<command>mcheck</command> işlevinin çağrılması <command>malloc</command>'a arasıra tutarlılık denetimi yapmasını söyler. Bu sayede <command>malloc</command> ile ayrılan belleği aşan yazma işlemleri yakalanır.
        </para><para>
<varname>çıkış_işlevi</varname> argümanı ile bir tutarsızlık bulunduğunda çağrılacak işlev belirtilir. Burada bir boş gösterici belirtirseniz, <command>mcheck</command> işlevi bir ileti basarak öntanımlı olan <link linkend="glibc-Aborting-a-Program"><command>abort</command></link> işlevini çağırır. Sizin tarafınızdan sağlanan işlev saptanan tutarsızlık türünün belirtildiği bir argümanla çağrılır. Tutarsızlık türleri <link linkend="glibc-mcheck_status">aşağıda</link>  açıklanmıştır.
        </para><para>
<command>malloc</command> ile bellek ayırma yaptıktan sonra tutarlılık denetimini başlatmak için kimi zaman çok geç kalınabilir. Bu durumda <command>mcheck</command> hiçbir şey yapmaz. Eğer çağrı için çok geç kalınmışsa <command>mcheck</command> <command>-1</command> ile aksi takdirde <command>0</command> ile döner.
        </para><para>
<command>mcheck</command> işlevini yeterince erken çağırmanın en kolay yolu, yazılımınızı ilintilerken <option>-lmcheck</option> seçeneğini kullanmaktır. Böylece yazılımınızın kaynak kodunu değiştirmeniz gerekmez. Başka bir yol da, yazılımınızı her başlattığınızda bir <command>mcheck</command> çağrısı girecek bir hata ayıklayıcı kullanmaktır. Örneğin, aşağıdaki gibi yazılımınızı her başlattığınızda gdb komutları özdevinimli olarak <command>mcheck</command>'i çağıracaktır.
        </para><para>
<screen>
(gdb) break main
Breakpoint 1, main (argc=2, argv=0xbffff964) at whatever.c:10
(gdb) command 1
Type commands for when breakpoint 1 is hit, one per line.
End with a line saying just &quot;end&quot;.
>call mcheck(0)
>continue
>end
(gdb) …
</screen></para><para>
<command>mcheck</command> işlevinin <command>malloc</command> işlevinden önce çağrılması gerektiğinden bu kod sadece <command>malloc</command> işlevini çağıran nesnelerde böyle bir ilklendirme işlevi yoksa çalışır.
        </para></funcdescr></funcsynopsis>
      </para><para id="glibc-mprobe">
<indexterm scope="glibc-fn"><primary>mprobe</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>enum mcheck_status <command>mprobe</command></funcdef>
<paramdef>(void *<varname>gösterici</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>mprobe</command> işlevi ile bir ayrılmış blok üzerinde tutarlılık denetimi yapılmasını doğrudan doğruya isteyebilirsiniz. Bu denetimin arasıra yapılması için zaten yazılımın hemen başlarında <command>mcheck</command> çağrısı yapmış olmalısınız; <command>mprobe</command> çağrısı ile çağrı sırasında bir ek tutarlılık denetimi yapılmasını isteyebilirsiniz.
        </para><para>
<varname>gösterici</varname>, bir <command>malloc</command> ya da <command>realloc</command> işlevinden dönmüş bir gösterici olmalıdır. <command>mprobe</command> işlevi ne tür bir tutarsızlık olduğunu belirten bir değer ile döner. Bu değerler aşağıda açıklanmıştır.
        </para></funcdescr></funcsynopsis>
      </para><para id="glibc-mcheck_status">
<indexterm scope="glibc-tp"><primary sortas="mcheck_status">enum mcheck_status</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü">
<funcdef>enum <command>mcheck_status</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu numaralı tür, bir ayrılmış blokta saptanan tutarsızlığın çeşidini açıklar. Olası değerler:
        </para><para><variablelist>
          <varlistentry><term id="glibc-MCHECK_DISABLED"><literal>MCHECK_DISABLED</literal></term>
            <listitem><para>
<command>mcheck</command> ilk ayırma işleminden önce çağrılmamış. Hiçbir tutarlılık denetimi yapılamaz.
            </para></listitem>
          </varlistentry><varlistentry><term id="glibc-MCHECK_OK"><literal>MCHECK_OK</literal></term>
            <listitem><para>Bir tutarsızlık yok.</para></listitem>
          </varlistentry><varlistentry><term><literal>MCHECK_HEAD</literal></term>
            <listitem><para>
Bloğun öncesi değiştirildi. Bu durum genellikle, bir dizi indisi ya da bir göstericinin bloğun başlangıcındaki değerinin altına indirildiğinde ortaya çıkar.
            </para></listitem>
          </varlistentry><varlistentry><term id="glibc-MCHECK_TAIL"><literal>MCHECK_TAIL</literal></term>
            <listitem><para>
Bloktan sonrası değiştirildi. Bu durum genellikle, bir dizi indisi ya da bir göstericinin değeri blok aşılacak kadar arttırıldığında ortaya çıkar.
            </para></listitem>
          </varlistentry><varlistentry><term id="glibc-MCHECK_FREE"><literal>MCHECK_FREE</literal></term>
            <listitem><para>Blok zaten serbest bırakılmış.</para></listitem>
          </varlistentry></variablelist>
        </para></funcdescr></funcsynopsis>
      </para><para>
Diğer bir denetim başlatma yöntemi, <command>malloc</command>, <command>realloc</command> ve <command>free</command> kullanımında yazılım hatalarına karşı bir önlem olarak <command>MALLOC_CHECK_</command> ortam değişkeninin belirtilmesidir. <command>MALLOC_CHECK_</command> bir denetim yapılması için belirtilmişse, çifte <command>free</command> çağrısı veya bir tek baytlık taşma gibi basit hatalara tolerans gösteren (daha az tutarlı) özel bir gerçekleme kullanılır. Bu tür hatalara karşı bir koruma olmadığından bellek artıkları olabileceği dikkate alınmalıdır.
      </para><para>
<command>MALLOC_CHECK_</command> için <command>0</command> değeri kullanılırsa, bir yığın bellek bozulması gözardı edilecektir. <command>1</command> kullanılırsa, standart hataya tanımlayıcı bir ileti basılır. <command>2</command> olması durumunda ise hemen <command>abort</command> çağrılır. Bu son durum genellikle hatanın hemen ardından bir çökmenin kaçınılmaz olduğu dolayısıyla hatanın geriye doğru izlenebilirliğinin çok zor olduğu durumlarda kullanışlıdır.
      </para><para>
<warning><title><literal>MALLOC_CHECK_</literal> ile ilgili bir sorun  vardır:</title><para> SUID ve  SGID'li çalıştırılabilirlerinin istismarı sözkonusu olabilir; bunlar, normal yazılım davranışından ayrılarak standart hata tanımlayıcıya bazı şeyler yazar. Bu nedenle, <command>MALLOC_CHECK_</command> kullanımı SUID ve SGID'li  çalıştırılabilirler için öntanımlı olarak iptal edilmiştir. Ancak sistem  yöneticisi tarafından <filename>/etc/suid-debug</filename> dosyası eklenerek etkinleştirilebilir (bu dosyanın içeriği önemli değildir, dosya boş olabilir).
      </para></warning></para><para>
Öyleyse <command>MALLOC_CHECK_</command> kullanımı ve <option>-lmcheck</option> seçeneğiyle ilintileme arasında ne fark vardır? <option>-lmcheck</option> geriye uyumluluk adına vardır. Her ikisi de aynı yazılım hataları için kullanılırsa da <command>MALLOC_CHECK_</command> kullandığınızda yazılımı yeniden derlemek gerekmez.
      </para>
    </sect2><sect2 id="glibc-Hooks-for-Malloc">
      <title>Bellek Ayırma Kancaları</title>
      <titleabbrev><command>malloc</command> kullanan yazılımlarda hata ayıklamak için  bu kancaları kullanabilirsiniz.</titleabbrev>
      <para>
<indexterm scope="glibc-cp"><primary>bellek</primary><secondary>ayırma</secondary><tertiary>kancalar</tertiary></indexterm>
GNU C kütüphanesi, <command>malloc</command>, <command>realloc</command> ve  <command>free</command> işlevlerinin davranışını, işlevle ilgili bir kanca işlev belirterek değiştirebilmenizi sağlar. Örneğin, özdevimli bellek ayırma kullanılan yazılımlarda hata ayıklamaya yardımcı olarak bu kancaları kullanabilirsiniz.
      </para><para>
Kanca değişkenler <filename>malloc.h</filename> başlık dosyasında tanımlanmıştır.
<indexterm scope="glibc-pg"><primary>malloc.h</primary></indexterm>
      </para><para id="glibc__malloc_hook">
<indexterm scope="glibc-vr"><primary sortas="malloc_hook">__malloc_hook</primary></indexterm>
<funcsynopsis><funcprototype role="değişken">
<funcdef><command>__malloc_hook</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu değer, her <command>malloc</command> çağrısında kullanılan işleve bir göstericidir. <command>malloc</command>'a benzeyecek bu işlevi siz tanımlayacaksınız; şöyle:
        </para><para>
<literallayout>
void *<varname>function</varname> (size_t <varname>boyut</varname>, const void *<varname>çağıran</varname>)
</literallayout></para><para>
<varname>çağıran</varname>'ın değeri, <command>malloc</command> çağrıldığında yığıtta bulunan dönüş adresidir. Bu değer yazılımın bellek tüketimini izlemenizi mümkün kılar.
        </para></funcdescr></funcsynopsis>
      </para><para id="glibc__realloc_hook">
<indexterm scope="glibc-vr"><primary sortas="realloc_hook">__realloc_hook</primary></indexterm>
<funcsynopsis><funcprototype role="değişken">
<funcdef><command>__realloc_hook</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu değer, her <command>realloc</command> çağrısında kullanılan işleve bir göstericidir. <command>realloc</command>'a benzeyecek bu işlevi siz tanımlayacaksınız; şöyle:
        </para><para>
<literallayout>
void *<varname>function</varname> (void *<varname>gösterici</varname>, size_t <varname>boyut</varname>, const void *<varname>çağıran</varname>)
</literallayout></para><para>
<varname>çağıran</varname>'ın değeri, <command>realloc</command> çağrıldığında yığıtta bulunan dönüş adresidir. Bu değer yazılımın bellek tüketimini izlemenizi mümkün kılar.
        </para></funcdescr></funcsynopsis>
      </para><para id="glibc__free_hook">
<indexterm scope="glibc-vr"><primary sortas="free_hook">__free_hook</primary></indexterm>
<funcsynopsis><funcprototype role="değişken">
<funcdef><command>__free_hook</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu değer, her <command>free</command> çağrısında kullanılan işleve bir göstericidir. <command>free</command>'ye benzeyecek bu işlevi siz tanımlayacaksınız; şöyle:
        </para><para>
<literallayout>
void <varname>function</varname> (void *<varname>gösterici</varname>, const void *<varname>çağıran</varname>)
</literallayout></para><para>
<varname>çağıran</varname>'ın değeri, <command>free</command> çağrıldığında yığıtta bulunan dönüş adresidir. Bu değer yazılımın bellek tüketimini izlemenizi mümkün kılar.
        </para></funcdescr></funcsynopsis>
      </para><para id="glibc__memalign_hook">
<indexterm scope="glibc-vr"><primary sortas="memalign_hook">__memalign_hook</primary></indexterm>
<funcsynopsis><funcprototype role="değişken">
<funcdef><command>__memalign_hook</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu değer, her <command>memalign</command> çağrısında kullanılan işleve bir göstericidir. <command>memalign</command>'a benzeyecek bu işlevi siz tanımlayacaksınız; şöyle:
        </para><para>
<literallayout>
void *<varname>function</varname> (size_t <varname>adımboyu</varname>, size_t <varname>boyut</varname>, const void *<varname>çağıran</varname>)
</literallayout></para><para>
<varname>çağıran</varname>'ın değeri, <command>free</command> çağrıldığında yığıtta bulunan dönüş adresidir. Bu değer yazılımın bellek tüketimini izlemenizi mümkün kılar.
        </para></funcdescr></funcsynopsis>
      </para><para>
<caution><para>Bu işlevlerden birine bir kanca olarak tanımladığınız işlevin, öncelikle kancayı eski değerine döndürmeden bu işlevi ardışık olarak çağırmadığından emin olmalısınız. Aksi takdirde, yazılımınız sonsuz döngüye takılacaktır. İşlevi ardışık olarak çağırmadan önce tüm kancaları önceki değerlerine döndürdüğünüzden emin olmalısınız. Bir ardışık çağrıdan geri dönüldüğünde, bir kanca kendisini değiştirebileceğinden tüm kancalar yeniden kaydedilmelidir.
      </para></caution></para><para id="glibc-__malloc_initialize_hook">
<indexterm scope="glibc-vr"><primary sortas="malloc_initialize_hook">__malloc_initialize_hook</primary></indexterm>
<funcsynopsis><funcprototype role="değişken">
<funcdef><command>__malloc_initialize_hook</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu değişkenin değeri, malloc gerçekleştirmesi ilklendirildiğinde bir kere çağrılan bir işleve göstericidir. Bu zayıf bir değişkendir ve aşağıdaki gibi bir tanımlama ile yazılım tarafından değiştirilebilir:
        </para><para>
<literallayout>
void (*<literal>__malloc_initialize_hook</literal>) (void) = ilkendirme_kancam;
</literallayout></para></funcdescr></funcsynopsis>
      </para><para>
Bakmak için en iyi zaman, malloc kanca işlevlerinin güvenle kurulduğu zamandır. Kanca işlevler, malloc'la ilgili işlevleri ardışık çağırırsa, malloc'un <command>__malloc_hook</command>'a atandığı sırada kendisini düzgün olarak ilklendirmesi gerekir. Diğer yandan, kanca işlevler kendi malloc gerçeklemelerini sağlarlarsa, kancaların yazılımdaki ilk <command>malloc</command> çağrısı tamamlanmadan önce atanması yaşamsal önemdedir. Çünkü aksi takdirde, örneğin bir normal kancasız malloc'la sağlanan bir blok daha sonra bir <command>__free_hook</command> üzerinden elde edilmelidir.
      </para><para>
Her iki durumda da sorun <literal>__malloc_initialize_hook</literal> tarafından gösterilen bir yazılımcı tanımlı işlev içinden ayarlanması ile çözümlenebilir ve böylece kancalar doğru zamanda güvenle ayarlanmış olur.
      </para><para>
Aşağıdaki örnekte <command>__malloc_hook</command> ve  <command>__free_hook</command> değişkenlerinin nasıl kullanıldığı gösterilmiştir. <command>malloc</command> veya <command>free</command> her çağrıldığında bir bilgi basan bir işlev kurulmaktadır. Bu örnekte, yazılımda <command>realloc</command> ve <command>memalign</command> işlevlerinin bulunmadığı varsayılmıştır.
     </para><para>
<screen>
/* __malloc_hook ve __free_hook için prototipler */
#include &lt;malloc.h>

/* Kancalarımız için prototipler  */
static void my_init_hook (void);
static void *my_malloc_hook (size_t, const void *);
static void my_free_hook (void*, const void *);

/* C kütüphanesindeli ilklendirme kancasının üstüne yazalım. */
void (*__malloc_initialize_hook) (void) = my_init_hook;

static void my_init_hook (void)
{
  old_malloc_hook = __malloc_hook;
  old_free_hook = __free_hook;
  __malloc_hook = my_malloc_hook;
  __free_hook = my_free_hook;
}

static void * my_malloc_hook (size_t size, const void *caller)
{
  void *result;
  /* tüm eski kancaları önceki değerlerine getirelim */
  __malloc_hook = old_malloc_hook;
  __free_hook = old_free_hook;
  /* Ardışık çağıralım */
  result = malloc (size);
  /* belirlenen kancaları kaydedelim */
  old_malloc_hook = __malloc_hook;
  old_free_hook = __free_hook;
  /* <command>printf</command>, <command>malloc</command>'u  tekrar çağırmamalı. */
  printf (&quot;malloc (%u), %p döndürdü\n&quot;, (unsigned int) size, result);
  /* Kendi kancalarımızı önceki değerlerine getirelim */
  __malloc_hook = my_malloc_hook;
  __free_hook = my_free_hook;
  return result;
}

static void
my_free_hook (void *ptr, const void *caller)
{
  /* tüm eski kancaları önceki değerlerine getirelim */
  __malloc_hook = old_malloc_hook;
  __free_hook = old_free_hook;
  /* Ardışık çağıralım */
  free (ptr);
  /* belirlenen kancaları kaydedelim */
  old_malloc_hook = __malloc_hook;
  old_free_hook = __free_hook;
  /* <command>printf</command>, <command>free</command>'yi  tekrar çağırmamalı. */
  printf (&quot;gösterici %p serbest bırakıldı\n&quot;, ptr);
  /* Kendi kancalarımızı önceki değerlerine getirelim */
  __malloc_hook = my_malloc_hook;
  __free_hook = my_free_hook;
}

main ()
{
  …
}
</screen></para><para>
<link linkend="glibc-Heap-Consistency-Checking"><command>mcheck</command></link>  işlevi böyle kancalar kurularak çalışır.
      </para>
    </sect2><sect2 id="glibc-Statistics-of-Malloc">
      <title><command>malloc</command> ile Bellek Ayırma İstatistikleri</title>
      <titleabbrev>Yazılımınızın ne kadar bellek kullandığının bulunması.</titleabbrev>
      <para>
<indexterm scope="glibc-cp"><primary>bellek</primary><secondary>ayırma</secondary><tertiary>istatistikler</tertiary></indexterm>
Özdevimli bellek ayırma hakkında <command>mallinfo</command> işlevini kullanarak bilgi edinebilirsiniz. Bu işlev ve onunla ilişkili veri türü <filename>malloc.h</filename> başlık dosyasında bildirilmiştir. Standart SVID/XPG sürümünün oluşumlarıdır.
<indexterm scope="glibc-pg"><primary>malloc.h</primary></indexterm>
      </para><para id="glibc-mallinfo_struct">
<indexterm scope="glibc-tp"><primary sortas="mallinfo"><literal>struct mallinfo</literal></primary></indexterm>
<funcsynopsis><funcprototype role="veri türü">
<funcdef>struct <command>mallinfo</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu yapı özdevimli bellek ayırıcı hakkında bilgi döndürmek için kullanılır.         Aşağıdaki üyelere sahiptir:
        </para><para>
          <glosslist><glossentry><glossterm>
            <literal>int </literal><command>arena</command></glossterm>
          <glossdef><para>
<command>malloc</command> tarafından <command>sbrk</command> ile ayrılan belleğin bayt cinsinden toplam boyudur.
          </para></glossdef>
          </glossentry><glossentry><glossterm>
           <literal>int </literal><command>ordblks</command></glossterm>
          <glossdef><para>
Kullanılmayan parçaların sayısıdır. (Bellek ayırıcı dahili olarak işletim sistemindeki bellek parçalarını alır ve tek tek  <command>malloc</command> çağrılarına dilimleyerek dağıtır. Bkz. <xref linkend="glibc-Efficiency-and-Malloc"/>.)
          </para></glossdef></glossentry><glossentry><glossterm>
            <literal>int </literal><command>smblks</command></glossterm>
          <glossdef><para>Bu alan kullanılmamıştır.</para></glossdef>
          </glossentry><glossentry><glossterm>
            <literal>int </literal><command>hblks</command></glossterm>
          <glossdef><para>
            <command>mmap</command> ile ayrılan parçaların toplam sayısıdır.
          </para></glossdef></glossentry><glossentry><glossterm>
            <literal>int </literal><command>hblkhd</command></glossterm>
          <glossdef><para>
<command>mmap</command> ile ayrılan belleğin bayt cinsinden toplam boyudur.
          </para></glossdef></glossentry><glossentry><glossterm>
            <literal>int </literal><command>usmblks</command></glossterm>
          <glossdef><para>Bu alan kullanılmamıştır.
          </para></glossdef></glossentry><glossentry><glossterm>
            <literal>int </literal><command>fsmblks</command></glossterm>
          <glossdef><para>Bu alan kullanılmamıştır.
          </para></glossdef></glossentry><glossentry><glossterm>
            <literal>int </literal><command>uordblks</command></glossterm>
          <glossdef><para>
<command>malloc</command> tarafından alınmayan parçaların işgal ettiği toplam boyuttur.
          </para></glossdef></glossentry><glossentry><glossterm>
            <literal>int </literal><command>fordblks</command></glossterm>
          <glossdef><para>
Serbest bırakılan (kullanımda olmayan) parçaların işgal ettiği belleğin toplam boyudur.
          </para></glossdef></glossentry><glossentry><glossterm>
           <literal>int </literal><command>keepcost</command></glossterm>
          <glossdef><para>
Normalde yığın belleğin son sınırındaki (sanal adres alanının veri bölütünün yüksek ucu) en tepe dağıtılabilir parçanın boyudur.
          </para></glossdef></glossentry></glosslist>
        </para></funcdescr></funcsynopsis>
      </para><para id="glibc-glibc-mallinfo_func">
<indexterm scope="glibc-fn"><primary>mallinfo</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>struct mallinfo <command>mallinfo</command></funcdef>
<paramdef>(void)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev o anki özdevimli bellek kullanımı hakkında <literal>struct mallinfo</literal> yapı türünde bilgi döndürür.
        </para></funcdescr></funcsynopsis>
      </para>
    </sect2><sect2 id="glibc-Summary-of-Malloc">
      <title><literal>malloc</literal> ile İlgili İşlevlerin Özeti</title>
      <titleabbrev><command>malloc</command> ile ilgili işlevlerin listesi.</titleabbrev>
      <para>
Burada <command>malloc</command> ile çalışan işlevlerin bir özeti bulunmaktadır:
      </para><para>
<funcsynopsis><funcprototype>
<funcdef>void *<command>malloc</command></funcdef>
<paramdef>(size_t <varname>boyut</varname>)</paramdef>
</funcprototype><funcdescr><para>
<varname>boyut</varname> baytlık bir blok ayırır. Bkz. <xref linkend="glibc-Basic-Allocation"/>.
        </para></funcdescr></funcsynopsis>
      </para><para>
<funcsynopsis><funcprototype>
<funcdef>void <command>free</command></funcdef>
<paramdef>(void *<varname>gösterici</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>malloc</command> ile ayrılan belleği serbest bırakır. Bkz. <xref linkend="glibc-Freeing-after-Malloc"/>.
        </para></funcdescr></funcsynopsis>
      </para><para>
<funcsynopsis><funcprototype>
<funcdef>void *<command>realloc</command></funcdef>
<paramdef>(void  *<varname>gösterici</varname>,
 size_t <varname>yeniboyut</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>malloc</command> ile ayrılan belleği büyütür ya da küçültür. Bunu kimi zaman veriyi başka bir yere kopyalayarak yapar. Bkz. <xref linkend="glibc-Changing-Block-Size"/>.
        </para></funcdescr></funcsynopsis>
      </para><para>
<funcsynopsis><funcprototype>
<funcdef>void *<command>calloc</command></funcdef>
<paramdef>(size_t <varname>elmsayısı</varname>,
 size_t <varname>elmboyu</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>malloc</command> kullanarak <varname>elmsayısı</varname> * <varname>elmboyu</varname> baytlık bir blok ayırır ve içini sıfırlarla doldurarak temizler. Bkz. <xref linkend="glibc-Allocating-Cleared-Space"/>.
        </para></funcdescr></funcsynopsis>
      </para><para>
<funcsynopsis><funcprototype>
<funcdef>void *<command>valloc</command></funcdef>
<paramdef>(size_t <varname>boyut</varname>)</paramdef>
</funcprototype><funcdescr><para>
Sayfa boyunda adresleme ile <varname>boyut</varname> uzunlukta blok ayırır. Bkz. <xref linkend="glibc-Aligned-Memory-Blocks"/>.
        </para></funcdescr></funcsynopsis>
      </para><para>
<funcsynopsis><funcprototype>
<funcdef>void *<command>memalign</command></funcdef>
<paramdef>(size_t <varname>adımboyu</varname>,
 size_t <varname>boyut</varname>)</paramdef>
</funcprototype><funcdescr><para>
<varname>adımboyu</varname>nun katlarında adreslenen <varname>boyut</varname> baytlık bir blok ayırır. Bkz.  <xref linkend="glibc-Aligned-Memory-Blocks"/>.
        </para></funcdescr></funcsynopsis>
      </para><para>
<funcsynopsis><funcprototype>
<funcdef>int <command>mallopt</command></funcdef>
<paramdef>(int <varname>param</varname>,
 int <varname>değer</varname>)</paramdef>
</funcprototype><funcdescr><para>
Ayarlanabilir parametreleri ayarlar. Bkz.  <xref linkend="glibc-Malloc-Tunable-Parameters"/>.
        </para></funcdescr></funcsynopsis>
      </para><para>
<funcsynopsis><funcprototype>
<funcdef>int <command>mcheck</command></funcdef>
<paramdef>(void (*<varname>çıkış_işlevi</varname>) (void))</paramdef>
</funcprototype><funcdescr><para>
<command>malloc</command>'a özdevimli ayrıan bellek üzerinde arasıra tutarlılık denetimi yapmasını ve bir tutarsızlık bulunursa <varname>çıkış_işlevi</varname>ni çağırmasını söyler. Bkz. <xref linkend="glibc-Heap-Consistency-Checking"/>.
        </para></funcdescr></funcsynopsis>
      </para><para>
<funcsynopsis><funcprototype>
<funcdef>void *(*__malloc_hook)</funcdef>
<paramdef>(size_t      <varname>boyut</varname>,
 const void *<varname>çağıran</varname>)</paramdef>
</funcprototype><funcdescr><para>
Çağrıldığında <command>malloc</command> kullanan bir işleve gösterici.
        </para></funcdescr></funcsynopsis>
      </para><para>
<funcsynopsis><funcprototype>
<funcdef>void *(*__realloc_hook)</funcdef>
<paramdef>(void       *<varname>gösterici</varname>,
 size_t      <varname>boyut</varname>,
 const void *<varname>çağıran</varname>)</paramdef>
</funcprototype><funcdescr><para>
Çağrıldığında <command>realloc</command> kullanan bir işleve gösterici.
        </para></funcdescr></funcsynopsis>
      </para><para>
<funcsynopsis><funcprototype>
<funcdef>void (*__free_hook)</funcdef>
<paramdef>(void       *<varname>ptr</varname>,
 const void *<varname>çağıran</varname>)</paramdef>
</funcprototype><funcdescr><para>
Çağrıldığında <command>free</command> kullanan bir işleve gösterici.
        </para></funcdescr></funcsynopsis>
      </para><para>
<funcsynopsis><funcprototype>
<funcdef>void (*__memalign_hook)</funcdef>
<paramdef>(size_t      <varname>boyut</varname>,
 size_t      <varname>adımboyu</varname>,
 const void *<varname>çağıran</varname>)</paramdef>
</funcprototype><funcdescr><para>
 Çağrıldığında <command>memalign</command> kullanan bir işleve gösterici.
        </para></funcdescr></funcsynopsis>
      </para><para>
<funcsynopsis><funcprototype>
<funcdef>struct mallinfo <command>mallinfo</command></funcdef>
<paramdef>(void)</paramdef>
</funcprototype><funcdescr><para>
Özdevimli bellek kullanımı hakkında bilgi döndürür. Bkz. <xref linkend="glibc-Statistics-of-Malloc"/>.
        </para></funcdescr></funcsynopsis>
      </para>
    </sect2>
  </sect1><sect1 id="glibc-Allocation-Debugging">
    <title>Bellek Ayırmada Hata Ayıklama</title>
    <titleabbrev>Serbest bırakılmamış bellek üzerinde artıkların bulunması.</titleabbrev>
    <para>
<indexterm scope="glibc-cp"><primary>bellek</primary><secondary>ayırma</secondary><tertiary>hata ayıklama</tertiary></indexterm>
<indexterm scope="glibc-cp"><primary>malloc hata ayıklayıcısı</primary></indexterm>
Özdevimli bellek ayırmasında bellek artıklarının bulunması çöp toplayıcı kullanılmayan dillerle yazılım geliştirilirken oldukça karmaşık bir iştir. Uzun süre çalışan yazılımlar özdevimli olarak ayırdıkları nesnelerin işleri bittiğinde serbest bırakılmalarını sağlamalıdır. Aksi takdirde sistem belleğinin tükenmesi sözkonusu olabilir.
    </para><para>
GNU C kütüphanesindeki <command>malloc</command> gerçeklemesi bu tür artıkların saptanması ve konumlarının bulunmasıyla ilgili bazı bilgiler sağlar. Bunu yapacak uygulama bir ortam değişkeni ile etkinleştirilen bir özel kipte başlatılmalıdır. Hata ayıklama kipi etkinleştirilirse yazılım için hiçbir hız cezası kesilmez.
    </para><sect2 id="glibc-Tracing-malloc">
      <title>İzleme işlevselliğinin kurulması</title>
      <para id="glibc-mtrace">
<indexterm scope="glibc-fn"><primary>mtrace</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>void <command>mtrace</command></funcdef>
<paramdef>(void)</paramdef>
</funcprototype><funcdescr><para>
<command>mtrace</command> işlevi çağrıldığında <command>MALLOC_TRACE</command> isimli ortam değişkenine bakar. Bu değişkenin bir dosya ismi içereceği kabul edilir. Kullanıcının yazma izni olmalıdır. Dosya zaten mevcutsa içeriği silinir. Ortam değişkeni yoksa ya da değeri yazmak için açılabilir bir geçerli dosya ismi değilse hiçbir şey yapılmaz. <command>malloc</command> ve benzerlerinin davranışı değiştirilmez. Belli sebeplerle SUID veya SGID'li uygulamalar için de bu durum geçerlidir.
        </para><para>
İsimli dosya başarıyla açılırsa, <command>mtrace</command> işlevi <command>malloc</command>, <command>realloc</command> ve <command>free</command> işlevleri için <link  linkend="glibc-Hooks-for-Malloc">kancalar</link> oluşturur. Bundan sonra bu işlevlerin tüm kullanımları izlenir ve dosyaya listelenir. İzlenen işlevlere yapılan tüm çağrılar için artık bir hız cezası vardır. Yani normal kullanım için izleme etkinleştirilmemelidir.
      </para><para>
Bu işlev bir GNU oluşumudur ve genelde diğer sistemler için kullanılabilir değildir. İşlev <filename>mcheck.h</filename> başlık dosyasında bildirilmiştir.
</para></funcdescr></funcsynopsis></para><para id="glibc-muntrace">
<indexterm scope="glibc-fn"><primary>muntrace</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>void <command>muntrace</command></funcdef>
<paramdef>(void)</paramdef>
</funcprototype><funcdescr><para>
<command>muntrace</command> işlevi <command>malloc</command> çağrılarının izlenmesini etkinleştiren <command>mtrace</command> çağrısından sonra çağrılabilir. Başarılı bir <command>mtrace</command> çağrısı yoksa <command>muntrace</command> hiçbir şey yapmaz.
        </para><para>
Aksi takdirde <command>malloc</command>, <command>realloc</command> ve <command>free</command> işlevleri için oluşturulan <link  linkend="glibc-Hooks-for-Malloc">kancaları</link> iptal eder ve izleme dosyasını kapatır. İzlenen bir çağrı kalmadığından yazılım tam gaz çalışır.
        </para><para>
Bu işlev bir GNU oluşumudur ve genelde diğer sistemler için kullanılabilir değildir. İşlev <filename>mcheck.h</filename> başlık dosyasında bildirilmiştir.
</para></funcdescr></funcsynopsis></para>
    </sect2><sect2 id="glibc-Using-the-Memory-Debugger">
      <title>Örnek Yazılım Parçaları</title>
      <titleabbrev>Hata ayıklayıcının kullanılması.</titleabbrev>
      <para>
İzleme işlevselliği yazılımın çalışma anı davranışını açıklamasa bile tüm yazılımlarda <command>mtrace</command> çağrısı yapmak iyi fikir değildir. Olaya bir bütün olarak bakarsak, siz yazılımınızda <command>mtrace</command> kullanarak hata ayıklamak istediğinizde, sistemde çalışan tüm diğer yazılımların da <command>malloc</command> çağrıları izleniyorsa, çıktı dosyası tüm yazılımlar için tek olacağından hata ayıklaması kullanışsız olacaktır. Bu nedenle, sadece hata ayıklama için derlenmişse tek <command>mtrace</command> çağrısı olmalı ve bir yazılım şöyle başlamalıdır:
      </para><para>
<screen>
#include &lt;mcheck.h>

int main (int argc, char *argv[])
{
#ifdef DEBUGGING
  mtrace ();
#endif
  …
}
</screen></para><para>
Yazılımın çalışması sırasında çağrıları izlemek isterseniz gereken tek şey budur. Ayrıca, izlemeyi istediğiniz bir anda <command>muntrace</command> ile durdurabilir ve yeni bir <command>mtrace</command> çağrısı ile izlemeyi yeniden başlatabilirsiniz. Ancak, çağrılmamış işlev çağrıları olabileceğinden bu istenmeyen sonuçlara yol açabilir.
      </para><para>
<note><para>İzleme işlevselliği sadece uygulama yazılımları için değildir, kütüphaneler de (hatta C kütüphanesinin kendisi de) bu işlevleri kullanabilir.</para></note>
      </para><para>
Bu durum, yazılım sonlanmadan önce <command>muntrace</command> çağrısı yapmanın neden iyi bir fikir olmadığı hakkında da bir fikir verir. Kütüphaneler sadece yazılımın  <command>main</command> işlevinin dönüşü veya bir <command>exit</command> çağrısından sonra yazılımın sonlandırıldığı hakkında bilgilendirilir. Dolayısıyla bu olmadan kütüphaneler kullandıkları belleği serbest bırakamazlar.
      </para><para>
En iyisi, yazılımın hemen başlarında bir kere <command>mtrace</command> çağrısı yapmak ve hiç <command>muntrace</command> çağrısı yapmamaktır. Bu durumda yazılımın hemen hemen tüm <command>malloc</command> işlevlerinin (yazılımın yapılandırıcıları tarafından çalıştırılanlar ile kütüphanelerin kullandıkları hariç) kullanımları izlenir.
     </para>
   </sect2><sect2 id="glibc-Tips-for-the-Memory-Debugger">
     <title>Bellek Hata Ayıklaması için İpuçları</title>
     <titleabbrev>Az ya da çok becerikli başka fikirler</titleabbrev>
      <para>
Durumu biliyorsunuz. Yazılım hata ayıklama için hazırlandı ve tüm hata ayıklama oturumları iyi çalışmakta. Ancak hata ayıklaması olmaksızın başlattığınızda hata gördünüz. Bir örnek olarak, hata ayıklamayı kapattığınızda bir bellek artığı görmüş olun. Böyle durumları sezebilirseniz kazanma şansınız olabilir. Aşağıdaki küçük yazılımda bazı şeylerin eşdeğerlerini basitçe kullanalım:
      </para><para>
<screen>
#include &lt;mcheck.h>
#include &lt;signal.h>

static void
enable (int sig)
{
  mtrace ();
  signal (SIGUSR1, enable);
}

static void
disable (int sig)
{
  muntrace ();
  signal (SIGUSR2, disable);
}

int
main (int argc, char *argv[])
{
  …

  signal (SIGUSR1, enable);
  signal (SIGUSR2, disable);

  …
}
</screen></para><para>
Vs., yazılımcı ortamda <command>MALLOC_TRACE</command>'i ayarlayarak yazılımda bellek hata ayıklamasını başlatabilir. Çıktı şüphesiz ilk sinyalden önce oluşan ayırmaları göstermez ama bir bellek artığı varsa yine de gösterilecektir.
      </para>
    </sect2><sect2 id="glibc-Interpreting-the-traces">
      <title>İzlerin Yorumlanması</title>
      <titleabbrev>Bu satırların anlamı ne?</titleabbrev>
      <para>
Çıktıya bakarsanız buna benzeyecektir:
      </para><para>
<screen>
= Start
 [0x8048209] - 0x8064cc8
 [0x8048209] - 0x8064ce0
 [0x8048209] - 0x8064cf8
 [0x80481eb] + 0x8064c48 0x14
 [0x80481eb] + 0x8064c60 0x14
 [0x80481eb] + 0x8064c78 0x14
 [0x80481eb] + 0x8064c90 0x14
= End
</screen></para><para>
İzleme dosyası bir insan tarafından okunup anlamlandırılmayacağı için bu satırların ne anlama geldiğinin bir önemi yoktur. Bu nedenle, okunabilirliğe dikkat edilmemiştir. Bu iş için GNU C kütüphanesi ile birlikte bu izleri yorumlayan ve kullanıcı dostu bir yolla özetleyen  bir uygulama gelir. Bu uygulamanın ismi <command>mtrace</command>'dir (aslında bir Perl betiğidir) ve bir ya da iki argüman alır. İzleme çıktısının dosya ismi mutlaka belirtilmelidir. İsteğe bağlı olarak verilebilecek ikinci argüman izleme dosyasının isminden önce verilmesi gereken ve bu izi üreten yazılımın ismidir.
      </para><para>
<screen>
<prompt>drepper$</prompt> <command>mtrace tst-mtrace log</command>
No memory leaks.
</screen></para><para>
Burada <filename>tst-mtrace</filename> isimli yazılım çalıştırılmış ve <filename>log</filename> isimli bir izleme dosyası üretilmiştir. <command>mtrace</command> uygulaması tarafından basılan ileti kodla ilgili bir sorun olmadığını göstermiş ve ardından ayrılan tüm bellek serbest bırakılmıştır.
      </para><para>
Biz <command>mtrace</command> uygulamasını yukardaki örnek izleme dosyası için çalıştırırsak farklı bir çıktı alırız:
      </para><para>
<screen>
<prompt>drepper$</prompt> <command>mtrace errlog</command>
- 0x08064cc8 Free 2 was never alloc'd 0x8048209
- 0x08064ce0 Free 3 was never alloc'd 0x8048209
- 0x08064cf8 Free 4 was never alloc'd 0x8048209

Memory not freed:
-----------------
   Address     Size     Caller
0x08064c48     0x14  at 0x80481eb
0x08064c60     0x14  at 0x80481eb
0x08064c78     0x14  at 0x80481eb
0x08064c90     0x14  at 0x80481eb
</screen></para><para>
<command>mtrace</command> uygulamasını tek argümanla çağırdık ve bu durumda betik izlerde verilen adresleri anlamlandıramadı. Daha anlamlı bir çıktı için şöyle bir çağrı yapabiliriz:
      </para><para>
<screen>
<prompt>drepper$</prompt> <command>mtrace tst errlog</command>
- 0x08064cc8 Free 2 was never alloc'd /home/drepper/tst.c:39
- 0x08064ce0 Free 3 was never alloc'd /home/drepper/tst.c:39
- 0x08064cf8 Free 4 was never alloc'd /home/drepper/tst.c:39

Memory not freed:
-----------------
   Address     Size     Caller
0x08064c48     0x14  at /home/drepper/tst.c:33
0x08064c60     0x14  at /home/drepper/tst.c:33
0x08064c78     0x14  at /home/drepper/tst.c:33
0x08064c90     0x14  at /home/drepper/tst.c:33
</screen></para><para>
Ansızın, çıktı daha ayrıntılı oluverdi. Yazılımcı artık hangi işlev çağrısının bozukluğa sebep olduğunu hemen görebilir.
      </para><para>
Bu çıktının yorumlanması karmaşık değildir. En fazla iki farklı durum saptanmıştır. İlkinde, ayırma işlevlerinden döndürülmemiş göstericiler için <command>free</command> çağrılmış. Bu genelde çok kötü bir sorundur ve çıktının ilk üç satırında benzer bir durum gösterilmiştir. Bu gibi durumlar az görülür, çünkü sorun kendini çok dramatik olarak gösterir: yazılım normal olarak çöker.
      </para><para>
Diğer durum saptanması daha zor olan bellek artıklarıdır. Çıktıda gördüğünüz gibi <command>mtrace</command> işlevi tüm bu bilgiyi toplamıştır. Bu çıktıya bakarak şunu söyleyebiliriz: yazılım <command>/home/drepper/tst-mtrace.c</command> kaynak dosyasının 33. satırındaki bir ayırma işlevini dört kere çağırmış ve yazılım sonlandırılmadan önce bu bellek serbest bırakılmamış. Acaba bu araştırılmayı bekleyen gerçek bir sorun mudur?
      </para>
    </sect2>
  </sect1>
  <sect1 id="glibc-Obstacks">
     <title>Yığınaklar (Obstacks)</title>
     <titleabbrev>Nesne yığınları <command>malloc</command>'dan daha az kullanılır ama daha tutarlı ve daha
kullanışlıdır.</titleabbrev>
<indexterm scope="glibc-fn"><see>obstack</see></indexterm>
     <para>
<indexterm scope="glibc-cp"><primary>yığınaklar</primary></indexterm>
<indexterm scope="glibc-cp"><primary>yığma</primary></indexterm>
Bir <wordasword>yığınak</wordasword> bir nesne yığını içeren bir bellek havuzudur. Çok sayıda ayrı yığınak oluşturabilir ve nesneleri bunların içinde ayırabilirsiniz. Her yığınağın içinde ayrılan son nesneye karşılık daima ilki serbest bırakılır ancak her yığınak diğerinden bağımsızdır.
    </para><para>
Serbest bırakma ile ilgili bu kısıtlama dışında yığınaklar tamamen geneldir: Bir yığınak farklı boyutlarda olabilen çok sayıda nesne içerebilir. Yığınaklar makrolarla gerçeklenmiştir. Böylece, nesneler küçük oldukları sürece ayırma işlemi çok hızlı yapılır. Her nesneyi belli bir adım aralığı ile oluşturmak gerektiğinden her nesne için sabit yer ayrılır.
    </para>
    <sect2 id="glibc-Creating-Obstacks">
      <title>Yığınak Oluşturma</title>
      <titleabbrev>Yığınaklar nasıl bildirilir.</titleabbrev>
      <para>
Yığınaklar üzerinde işlem yapmak için gereken araçlar <filename>obstack.h</filename> başlık dosyasında bildirilmiştir.
<indexterm scope="glibc-pg"><primary>obstack.h</primary></indexterm>
      </para><para id="glibc-obstack_struct">
<indexterm scope="glibc-tp"><primary sortas="obstack">struct obstack</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü">
<funcdef>struct <command>obstack</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bir yığınak <command>struct obstack</command> türünde bir veri yapısı ile ifade edilir. Bu veri yapısı çok küçük ve sabit boyutludur. Nesnelerin içinde ayrıldıkları alanın nasıl bulunacağı ve yığınağın durumu hakkında bilgileri kaydeder. Nesnelerin kendileri hakkında bir bilgi içermez. Bu yapının içeriğine doğrudan erişmeye çalışmayın; sadece bu bölümde açıklanmış olan işlevleri kullanın.
</para></funcdescr></funcsynopsis>
      </para><para>
Değişkenleri <command>struct obstack</command> türünde bildirebilir ve onları yığınak olarak kullanabilirsiniz ya da bir yığınağı diğer nesne çeşitlerinde olduğu gibi özdevimli olarak ayırabilirsiniz. Yığınakların özdevimli olarak ayrılması yazılımınızın çok sayıda farklı yığınağa sahip olmasını mümkün kılar. (Hatta bir yığınak yapısını bir başka yığınağın içinde ayırabilirsiniz ancak bu pek kullanışlı olmaz.)
      </para><para>
Yığınaklar ile çalışan işlevlerin tümü hangi yığınağın kullanılacağının belirtilmesini gerektirir.  Bunu <command>struct obstack *</command> türünden bir gösterici ile yapabilirsiniz. Bundan sonra bir yığınaktan bahsettiğimizde ona bir gösterici üzerinden eriştiğiniz kabul edilecektir.
      </para><para>
Yığınaktaki nesneler <wordasword>tomar</wordasword> olarak adlandırılan büyük bloklar halindedir. <command>struct obstack</command> yapısı ise bu tomarlardan oluşan bir zincirin kaydını tutar.
      </para><para>
Yığınak kütüphanesi, önceki tomara sığmayan bir nesne ayırdığınızda, yeni bir tomar oluşturur. Yığınak kütüphanesi tomarları özdevinimli olarak yönettiğinden bu işlemlere fazla dikkat etmeniz gerekmez. Ancak, yığınak kütüphanesinin bir tomarı ayırırken kullanacağı bir işlevi sağlamanız gerekir. Bu işlev <command>malloc</command> işlevini doğrudan ya da dolaylı kullanmalıdır. Ayrıca bir tomarı serbest bırakacak bir işlev daha sağlamanız gerekir. Bu konular aşağıdaki bölümde açıklanmıştır.
      </para>
    </sect2><sect2 id="glibc-Preparing-for-Obstacks">
      <title>Yığınakları Kullanıma Hazırlama</title>
      <titleabbrev>Yığınakları kullanmadan önce biraz hazırlık gerekir.</titleabbrev>
      <para>
Yığınak işlevlerini kullanmayı tasarladığınız her kaynak dosyası
 <ulink url="file:/usr/include/obstack.h"><filename>obstack.h</filename></ulink>
 başlık dosyasını aşağıdaki gibi içermelidir:
      </para><para><screen>#include &lt;obstack.h></screen></para><para>
<indexterm scope="glibc-fn"><primary>obstack_chunk_alloc</primary></indexterm>
<indexterm scope="glibc-fn"><primary>obstack_chunk_free</primary></indexterm>
Ayrıca, kaynak dosyası <command>obstack_init</command> makrosunu da kullanıyorsa, yığınak kütüphanesi tarafından kullanılmak üzere iki işlev veya makro bildirmeli ya da tanımlamalıdır. Biri, içine nesnelerin paketleneceği bellek tomarlarını ayırmada kullanılacak olan <command>obstack_chunk_alloc</command> işlevi diğeri ise, içindeki
 nesneler serbest bırakıldığında bellek tomarlarını sisteme döndürecek olan <command>obstack_chunk_free</command> işlevidir. Bu makrolar kaynak dosyaları içinde yığınaklar kullanılmadan önce tanımlanmış olmalıdır.
      </para><para>
Bunlar <command>xmalloc</command> (<xref linkend="glibc-Unconstrained-Allocation"/>) araortamı üzerinden <command>malloc</command> kullanacak şekilde tanımlanır. Bu tanımlama aşağıdaki makro tanım çifti ile yapılır:
      </para><para>
<screen>
#define obstack_chunk_alloc xmalloc
#define obstack_chunk_free free
</screen></para><para>
Yığınak kullanarak ayırdığınız bellek gerçekte <command>malloc</command>'dan gelmesine karşın, yığınakların kullanılması daha hızlıdır çünkü daha büyük bellek blokları halinde olduğundan <command>malloc</command> daha az sıklıkta çağrılır. Daha ayrıntılı bilgi için <xref linkend="glibc-Obstack-Chunks"/> bölümüne bakınız.
      </para><para>
Çalışma anında yazılım, yığınak olarak bir <command>struct obstack</command> yapısını kullanmaya başlamadan önce bir <command>obstack_init</command> çağrısı ile yığını ilklendirmelidir.
      </para><para id="glibc-obstack_init">
<indexterm scope="glibc-fn"><primary>obstack_init</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>obstack_init</command></funcdef>
<paramdef>(struct obstack *<varname>yığınak</varname>)</paramdef>
</funcprototype><funcdescr><para>
Nesnelerin ayrılacağı <varname>yığınak</varname> nesnesini ilklendirir. Bu işlev yığınağın <command>obstack_chunk_alloc</command> işlevini çağırır. Eğer bellek ayırma işlemi başarısız olursa <command>obstack_alloc_failed_handler</command> tarafından gösterilen işlev çağrılır. <command>obstack_init</command> işlevi daima 1 ile döner.
      </para><para>
<note><title>Uyumluluk bilgisi</title><para>Yığınak kütüphanelerinin daha şekilci sürümleri bu işlev başarısız olduğunda 0 ile döner.</para></note>
</para></funcdescr></funcsynopsis>
      </para><para>
Aşağıda bir yığınak için alan ayrılması ve onun ilklendirilmesi üzerine iki örnek bulunmaktadır. İlkinde yığınak bir durağan değişkendir:
      </para><para>
<screen>
static struct obstack myobstack;
…
obstack_init (&amp;myobstack);
</screen></para><para>
İkincisinde ise yığınak kendisini özdevimli ayırmaktadır:
     </para><para>
<screen>
struct obstack *myobstack_ptr
  = (struct obstack *) xmalloc (sizeof (struct obstack));

obstack_init (myobstack_ptr);
</screen></para><para id="glibc-obstack_alloc_failed_handler">
<indexterm scope="glibc-vr"><primary>obstack_alloc_failed_handler</primary></indexterm>
<funcsynopsis><funcprototype role="değişken">
<funcdef><command>obstack_alloc_failed_handler</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu değişkenin değeri, <command>obstack_chunk_alloc</command> işlevi bellek ayırma sırasında başarısız olduğunda çağıracağı işleve bir göstericidir. Bu göstericiye belirteceğiniz işlev ya <command>exit</command> (<xref linkend="glibc-Program-Termination"/>) ya da  <command>longjmp</command> (<xref linkend="glibc-Non-Local-Exits"/>) çağırmalı, yani dönmemelidir.
      </para><para>
<screen>
void my_obstack_alloc_failed (void)
…
obstack_alloc_failed_handler = &amp;my_obstack_alloc_failed;
</screen></para></funcdescr></funcsynopsis>
      </para>
    </sect2><sect2 id="glibc-Allocation-in-an-Obstack">
      <title>Bir Yığınağa Nesne Eklenmesi</title>
      <titleabbrev>Bir yığınakta nesnelere yer ayırma</titleabbrev>
      <para>
<indexterm scope="glibc-cp"><primary>yığınaklar</primary><secondary>nesne eklemek</secondary></indexterm>
Bir nesne için bir yığınakta yer ayırmanın en kestirme yolu, <command>malloc</command> çağırır gibi <command>obstack_alloc</command> çağrısı yapmaktır.
      </para><para id="glibc-obstack_alloc">
<indexterm scope="glibc-fn"><primary>obstack_alloc</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>void *<command>obstack_alloc</command></funcdef>
<paramdef>(struct obstack *<varname>yığınak</varname>,
 int             <varname>boyut</varname>)</paramdef>
</funcprototype><funcdescr><para>
İşlev, bir yığınakta <varname>boyut</varname> baytlık bir ilkendirilmemiş blok ayırır ve onun adresi ile döner. Burada <varname>yığınak</varname>, içinde blok ayrılacak olan yığınağı belirten <command>struct obstack</command> yapısının adresidir. Her yığınak işlevi ya da makrosu ilk argüman olarak daima bir <command><varname>* yığınak</varname></command> belirtmeyi gerektirir.
      </para><para>
Bellekte yeni bir tomar ayrılması gerekirse bu işlev yığınağın <command>obstack_chunk_alloc</command> işlevini çağırır. <command>obstack_chunk_alloc</command> işlevi bellek ayırmada başarısız  olursa <command>obstack_alloc_failed_handler</command> işlevi çağrılır.
</para></funcdescr></funcsynopsis>
      </para><para>
Aşağıdaki örnekte, <command>string_obstack</command> yığınağında  <varname>string</varname> dizgesinin bir kopyası için yer ayrılmaktadır:
      </para><para>
<screen>
struct obstack string_obstack;

char * copystring (char *string)
{
  size_t len = strlen (string) + 1;
  char *s = (char *) obstack_alloc (&amp;string_obstack, len);
  memcpy (s, string, len);
  return s;
}
</screen></para><para>
İçeriğini belirterek bir blok ayırmak için <command>obstack_copy</command> işlevi kullanılır:
      </para><para id="glibc-obstack_copy">
<indexterm scope="glibc-fn"><primary>obstack_copy</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>void *<command>obstack_copy</command></funcdef>
<paramdef>(struct obstack *<varname>yığınak</varname>,
 void           *<varname>adres</varname>,
 int             <varname>boyut</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev bir blok ayırır ve <varname>adres</varname> adresinden başlayan  <varname>boyut</varname> baytlık veriyi ayrılan yere kopyalayarak bloğu ilklendirir. <command>obstack_chunk_alloc</command> tarafından bellek ayırma işlemi başarısız olursa <command>obstack_alloc_failed_handler</command> işlevini çağırır.
</para></funcdescr></funcsynopsis>
      </para><para id="glibc-obstack_copy0">
<indexterm scope="glibc-fn"><primary>obstack_copy0</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>void *<command>obstack_copy0</command></funcdef>
<paramdef>(struct obstack *<varname>yığınak</varname>,
 void           *<varname>adres</varname>,
 int             <varname>boyut</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>obstack_copy</command> işlevi gibidir, farklı olarak, bir boş karakter ekler. Bu fazladan bayt <varname>boyut</varname>'a dahil değildir.
      </para></funcdescr></funcsynopsis></para><para>
Bu işlev, bir yığınağa bir dizgeyi bir boş sonlandırmalı dizge olarak kopyalamanın en uygun yoludur. Aşağıdaki bir kullanım örneğine bakınız:
      </para><para>
<screen>
char * obstack_savestring (char *addr, int size)
{
  return obstack_copy0 (&amp;myobstack, addr, size);
}
</screen></para><para>
Önceki örnekte aynı işi yapan <command>copystring</command> işlevi için <command>malloc</command> (<xref linkend="glibc-Basic-Allocation"/>) kullanılmıştı.
      </para>
    </sect2><sect2 id="glibc-Freeing-Obstack-Objects">
      <title>Bir Yığınaktan Nesne Çıkarılması</title>
      <titleabbrev>Yığınakta bir nesneye ayrılan yerin serbest bırakılması</titleabbrev>
      <para>
<indexterm scope="glibc-cp"><primary>yığınaklar</primary><secondary>nesne çıkarmak</secondary></indexterm>
Yığınaktan bir nesneyi çıkarmak için <command>obstack_free</command> işlevi kullanılır. Bir yığınak aslında bir nesne yığıtı olduğundan, serbest bırakılan nesne kendinden sonra ayrılan diğer nesnelerin de serbest bırakılmasına sebep olur.
      </para><para id="glibc-obstack_free">
<indexterm scope="glibc-fn"><primary>obstack_free</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>void <command>obstack_free</command></funcdef>
<paramdef>(struct obstack *<varname>yığınak</varname>,
 void           *<varname>nesne</varname>)</paramdef>
</funcprototype><funcdescr><para>
<varname>nesne</varname> hiçbir şey göstermiyorsa yığınaktan tüm nesneler çıkarılır. Aksi takdirde, gösterdiği nesne ve o nesneden sonra yığınağa konulmuş tüm nesneler serbest bırakılır.
      </para><para>
<note><para><varname>nesne</varname> hiçbir şey göstermiyorsa işlevin sonucu ilklendirilmemiş bir yığınaktır. Bir yığınağı boşaltmak ve onu kullanılabilir yapmak isterseniz <command>obstack_free</command> işlevini yığınaktaki ilk nesnenin göstericisi ile çağırmalısınız:
      </para><para>
<screen>
obstack_free (obstack_ptr, first_object_allocated_ptr);
</screen></para><para>
Bir yığınaktaki nesneler tomarlar halinde gruplanır. Bir tomardan tüm nesneler çıkarıldığında yığınak kütüphanesi tomarı özdevinimli olarak serbest bırakır (Bkz. <xref linkend="glibc-Preparing-for-Obstacks"/>). Böylece diğer yığınaklar ve bellek ayırma işlemleri için tomar alanı yeniden kullanılabilir.
</para></note></para></funcdescr></funcsynopsis></para>
    </sect2><sect2 id="glibc-Obstack-Functions">
      <title>Yığınak İşlevleri ve Makroları</title>
      <titleabbrev>Yığınak işlevleri hem işlev hem de makrodur.</titleabbrev>
      <para>
<indexterm scope="glibc-cp"><primary>makrolar</primary></indexterm>
Derleyiciye bağlı olarak, yığınakların kullanılmasını sağlayan arayüzler bir işlev ya da makro olarak tanımlanabilir. Yığınak oluşumu ISO C ve geleneksel C içeren tüm C derleyicileri ile çalışır, ancak GNU C derleyicisi dışındaki derleyicileri kullanacaksanız almanız gereken bazı önlemler vardır.
      </para><para>
Eski moda, ISO C olmayan bir derleyici kullanıyorsanız, tüm yığınak işlevleri aslında birer makro olarak tanımlanmalıdır. Bu makroları birer işlev gibi çağırabilirsiniz ama bir işlevin sağladığı diğer kolaylıklardan (işlev adresini almak gibi) yararlanamazsınız.
      </para><para>
Makroların çağrılması bir özel önlem almayı gerektirir: İsim olarak, ilk terim (yığınak göstericisi) herhangi bir yan etki barındırmamalıdır. Örneğin,
      </para><para><screen>obstack_alloc (get_obstack (), 4);</screen></para><para>
yazarsanız, <command>get_obstack</command> defalarca çağrılacaktır. Ya da yığınak göstericisi argümanı olarak <command>*obstack_list_ptr++</command> kullanırsanız, defalarca arttırım uygulanacağından çok tuhaf sonuçlar elde edebilirsiniz.
      </para><para>
ISO C'de her işlevin bir makro bir de işlev olarak tanımı vardır. Bir işlevi çağırmadan sadece adresini almak isterseniz işlev tanımı kullanılır. Normal bir işlev çağrısında ise öntanımlı olarak makro tanımı kullanılır, ancak isterseniz işlev ismini parantez içinde kullanarak işlev tanımını kullanabilirsiniz. Örnek:
      </para><para>
<screen>
char *x;
void *(*funcp) ();

/* Makro kullanımı.  */
x = (char *) obstack_alloc (ynk_gstr, boyut);

/* İşlev çağrısı.  */
x = (char *) (obstack_alloc) (ynk_gstr, boyut);

/* İşlev adresinin alınması.  */
funcp = obstack_alloc;
</screen></para><para>
Aynı durum ISO C'deki standart kütüphane işlevleri için de geçerlidir. Bkz. <xref linkend="glibc-Macro-Definitions"/>.
      </para><para>
<warning><para>ISO C'de bile, makroları kullanırken ilk terimin yan etkiler oluşturmasına karşı önlem almanız gereklidir.
      </para><para>
GNU C derleyicisini kullanıyorsanız, bu önlem gereksizdir, çünkü GNU C'deki çeşitli dil oluşumları, makroların, her argümanının bir kere hesaplanmasını sağlayacak şekilde tanımlanmasına izin verir.</para></warning>
      </para>
    </sect2><sect2 id="glibc-Growing-Objects">
      <title>Büyüyen Nesneler</title>
      <titleabbrev>Bir nesneyi adım adım büyütmek.</titleabbrev>
      <para>
<indexterm scope="glibc-cp"><primary>yığınaklar</primary><secondary>büyüyen nesneler</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>yığınaklar</primary><secondary>blok boyunu değiştirmek</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>nesne</primary><secondary>büyütme</secondary></indexterm>
Yığınak tomarları içindeki bellek sıralı erişimle kullanıldığından, bir nesneyi, nesne için ayrılan alanın sonuna bayt ya da baytlar ekleyerek adım adım oluşturmak mümkündür. Bu teknikle, bir nesneye veri aktarırken acaba yer kaldı mı diye düşünmeniz gerekmez. Bu tekniğe <wordasword>Nesnelerin Büyütülmesi</wordasword> diyoruz. Bu bölümde nesneleri sonuna veri ekleyerek büyütmek için kullanılan özel işlevlere yer verilmiştir.
      </para><para>
Bu işlevlerden birini kullanarak nesneye veri eklemek istediğinizde nesnenin büyütülmesi özdevinimli olarak gerçekleştiğinden, bir nesneyi büyütmeye başladığınızda özel olarak hiçbir şey yapmanız gerekmez. Ancak büyütme işlemi bittiğinde, bittiğinin belirtilmesi gerekir. Bunun için <command>obstack_finish</command> işlevi kullanılır.
      </para><para>
Büyütme işleminin bittiği belirtilene kadar her veri eklemesinde nesne yeni bir tomara kopyalandığı için nesnenin büyütülmesi bitene kadar nesnenin gerçek adresi bilinmez.
      </para><para>
Bir yığınak bir nesneyi büyütmek için kullanıldığında, bir başka nesneyi o yığına yerleştiremezsiniz. Bunu yapmayı denerseniz, eklediğiniz nesneye ayrı bir nesne olarak erişilemez; büyütülen nesneye bir alan eklenmiş olur ve eklediğiniz nesne büyütülen nesnenin bir parçası haline gelir.
      </para><para id="glibc-obstack_blank">
<indexterm scope="glibc-fn"><primary>obstack_blank</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>void <command>obstack_blank</command></funcdef>
<paramdef>(struct obstack *<varname>yığınak</varname>,
 int             <varname>boyut</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bir büyüyen nesneye alan oluşturmak için kullanılır. <command>obstack_blank</command> ilklendirilmemiş bir alan oluşturur.
</para></funcdescr></funcsynopsis></para><para id="glibc-obstack_grow">
<indexterm scope="glibc-fn"><primary>obstack_grow</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>void <command>obstack_grow</command></funcdef>
<paramdef>
(struct obstack *<varname>yığınak</varname>,
 void           *<varname>veri</varname>,
 int             <varname>boyut</varname>)</paramdef>
</funcprototype><funcdescr><para>
İlklendirilmiş bir blok eklemekte kullanılır. <command>obstack_grow</command> işlevi nesne büyüten bir <command>obstack_copy</command> işlevi gibi düşünülebilir. Büyüyen nesneye <varname>boyut</varname> uzunlukta  <varname>veri</varname> ekler.
</para></funcdescr></funcsynopsis></para><para id="glibc-obstack_grow0">
<indexterm scope="glibc-fn"><primary>obstack_grow0</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>void <command>obstack_grow0</command></funcdef>
<paramdef>(struct obstack *<varname>yığınak</varname>,
 void           *<varname>veri</varname>,
 int             <varname>boyut</varname>)</paramdef>
</funcprototype><funcdescr><para>
Nesne büyüten bir <command>obstack_copy0</command> işlevi gibi düşünülenilir. Büyüyen nesneye <varname>boyut</varname> uzunlukta <varname>veri</varname>  sonuna bir boş karakter getirilerek eklenir.
</para></funcdescr></funcsynopsis></para><para id="glibc-obstack_1grow">
<indexterm scope="glibc-fn"><primary>obstack_1grow</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>void <command>obstack_1grow</command></funcdef>
<paramdef>(struct obstack *<varname>yığınak</varname>,
 char            <varname>c</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>obstack_1grow</command> işlevi büyüyen nesneye bir defada sadece bir karakter eklemek için kullanılır. Büyüyen nesneye <varname>c</varname> karakterini içeren bir bayt ekler.
</para></funcdescr></funcsynopsis></para><para id="glibc-obstack_ptr_grow">
<indexterm scope="glibc-fn"><primary>obstack_ptr_grow</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>void <command>obstack_ptr_grow</command></funcdef>
<paramdef>(struct obstack *<varname>yığınak</varname>,
 void           *<varname>veri</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bir oluşumun gösterici değerini büyüyen nesneye eklemek için kullanılır. Büyüyen nesneye <varname>veri</varname>’nin değerini içeren <command>sizeof (void *)</command> bayt ekler.
</para></funcdescr></funcsynopsis></para><para id="glibc-obstack_int_grow">
<indexterm scope="glibc-fn"><primary>obstack_int_grow</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>void <command>obstack_int_grow</command></funcdef>
<paramdef>(struct obstack *<varname>yığınak</varname>,
 int             <varname>veri</varname>)</paramdef>
</funcprototype><funcdescr><para>
Büyüyen nesneye <command>int</command> türünde tek bir değer eklemek için kullanılır. Büyüyen nesneye <command>sizeof (int)</command> bayt ekler ve <varname>veri</varname>'nin değeri ile ilklendirir.
</para></funcdescr></funcsynopsis></para><para id="glibc-obstack_finish">
<indexterm scope="glibc-fn"><primary>obstack_finish</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>void *<command>obstack_finish</command></funcdef>
<paramdef>(struct obstack *<varname>yığınak</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bir büyüyen nesne ile işiniz bittiğinde onu kapatmak ve son adresini almak için bu işlevi kullanacaksınız.
        </para><para>
Büyüyen bir nesneyi bitirdiğinizde, yığınak, normal nesne ayırma ya da yeni bir büyüyen nesne oluşturmak için kullanılabilir.
        </para><para>
Bu işlev <command>obstack_alloc</command> işlevi gibi aynı koşullar altında bir boş gösterici ile de dönebilir. Bkz. <xref linkend="glibc-Allocation-in-an-Obstack"/>.
</para></funcdescr></funcsynopsis>
      </para><para>
Bir büyüyen nesne ile çalışırken ne büyüklüğe ulaştığını bilmek isteyebilirsiniz. Bir büyüyen nesneyi bitirmeden <command>obstack_object_size</command> işlevini kullanarak yığınağın eriştiği boyutu öğrenebilirsiniz:
      </para><para id="glibc-obstack_object_size-1">
<indexterm scope="glibc-fn"><primary>obstack_object_size</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>obstack_object_size</command></funcdef>
<paramdef>(struct obstack *<varname>yığınak</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev, büyüyen nesnenin o andaki bayt cinsinden uzunluğu ile döner. Bu işlevin nesneyi bitirmeden çağrılabileceğini unutmayın. Nesneyi bitirdikten sonra <command>obstack_object_size</command> işlevi sıfır değeri ile döner.
</para></funcdescr></funcsynopsis>
      </para><para>
Bir büyüyen nesne oluşturduktan sonra onu iptal etmek isterseniz, önce onu bitirin sonra da serbest bırakın. Örnek:
     </para><para>
<screen>
obstack_free (obstack_ptr, obstack_finish (obstack_ptr));
</screen></para><para>
Nesne bir büyüyen nesne değilse bu etkisizdir.
      </para><para>
<indexterm scope="glibc-cp"><primary>yığınaklar</primary><secondary>nesnelerin küçültülmesi</secondary></indexterm>
Bir nesneyi küçültmek için <command>obstack_blank</command> işlevini bir negatif boyutla çağırabilirsiniz. Ancak nesneyi küçültürken boyunun sıfırın altına inmemesine dikkat edin, aksi takdirde neler olacağı bilinemez.
      </para>
    </sect2><sect2 id="glibc-Extra-Fast-Growing">
      <title>Çok Hızlı Büyüyen Nesneler</title>
      <titleabbrev>Çok yüksek verimle (daha karmaşık olduğu halde) büyüyen nesneler.</titleabbrev>
      <para>
<indexterm scope="glibc-cp"><primary>yığınaklar ve verimlilik</primary></indexterm>
Büyüyen nesneleri büyütürken o anki tomarın yeterli yere sahip olup olmadığının denetlenmesi için işlevler içinde yapılan işlemler bir sürü masraf kalemi oluşturur. Üstelik siz bu nesneleri küçük küçük adımlarla ve sıklıkla büyütürseniz bu israf kaydadeğer olmaya başlar.
      </para><para>
Bu masrafı, bu denetimlerin yapılmadığı özel "hızlı büyütme" işlevlerini kullanarak düşürebilirsiniz. Sağlam bir yazılım istiyorsanız bu denetimleri kendiniz yapmalısınız. Bu denetimi en basit yolla, nesneye veri eklemeye hazırlanırken yaparsanız hiçbir şeyi saklamak zorunda kalmazsınız, çünkü normal büyütme işlevleri de bunu zaten böyle yapar. Bu düzenlemeyi ne kadar az sıklıkta yaparsanız yazılımınız o kadar hızlı olur.
      </para><para>
<command>obstack_room</command> işlevi kullanılan tomar içindeki kullanılabilir alanın miktarı ile döner:
      </para><para id="glibc-obstack_room">
<indexterm scope="glibc-fn"><primary>obstack_room</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>obstack_room</command></funcdef>
<paramdef>(struct obstack *<varname>yığınak</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev, kullanılmakta olan (ya da yeni oluşturulan) <varname>yığınak</varname>  büyüyen nesnesine yeni bir tomar oluşturmadan hızlı büyütme işlevleri kullanılarak eklenebilecek baytların sayısı ile döner.
</para></funcdescr></funcsynopsis>
      </para><para>
Ne kadar yeriniz olduğunu bildiğinize göre aşağıdaki hızlı büyütme işlevlerini kullanarak büyüyen nesnenize güvenle veri ekleyebilirsiniz:
      </para><para id="glibc-obstack_1grow_fast">
<indexterm scope="glibc-fn"><primary>obstack_1grow_fast</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>void <command>obstack_1grow_fast</command></funcdef>
<paramdef>(struct obstack *<varname>yığınak</varname>,
 char            <varname>c</varname>)</paramdef>
</funcprototype><funcdescr><para>
<varname>yığınak</varname>’taki büyüyen nesneye <varname>c</varname> karakterini içeren tek bir bayt eklemekte kullanılır.
</para></funcdescr></funcsynopsis></para><para id="glibc-obstack_ptr_grow_fast">
<indexterm scope="glibc-fn"><primary>obstack_ptr_grow_fast</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>void <command>obstack_ptr_grow_fast</command></funcdef>
<paramdef>(struct obstack *<varname>yığınak</varname>,
 void           *<varname>veri</varname>)</paramdef>
</funcprototype><funcdescr><para>
<varname>yığınak</varname>’taki büyüyen nesneye <varname>veri</varname> değerini içeren <command>sizeof (void *)</command> bayt ekler.
</para></funcdescr></funcsynopsis></para><para id="glibc-obstack_int_grow_fast">
<indexterm scope="glibc-fn"><primary>obstack_int_grow_fast</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>void <command>obstack_int_grow_fast</command></funcdef>
<paramdef>(struct obstack *<varname>yığınak</varname>,
 int             <varname>veri</varname>)</paramdef>
</funcprototype><funcdescr><para>
<varname>yığınak</varname>’taki büyüyen nesneye <varname>veri</varname> değerini içeren <command>sizeof (int)</command> bayt ekler.
</para></funcdescr></funcsynopsis></para><para id="glibc-obstack_blank_fast">
<indexterm scope="glibc-fn"><primary>obstack_blank_fast</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>void <command>obstack_blank_fast</command></funcdef>
<paramdef>(struct obstack *<varname>yığınak</varname>,
 int             <varname>boyut</varname>)</paramdef>
</funcprototype><funcdescr><para>
<varname>yığınak</varname>’taki büyüyen nesneye ilklendirmeksizin <varname>boyut</varname> bayt ekler.
</para></funcdescr></funcsynopsis>
      </para><para>
Kalan yeri <command>obstack_room</command> ile tespit ettiğinizde yeterli yer kalmadığını öğrenirseniz hızlı büyütme işlevlerini kullanmak artık güvenilir olmaz. Bu durmda, basitçe normal büyütme işlevlerine geçmek gerekir. Sonuç olarak, az yer kalmışsa normal büyütme işlevleri yeni bir tomar açar ve böylece bol bol yeriniz olur.
      </para><para>
Demek ki, <command>obstack_room</command> ile yeterli yer kalmadığını her anladığınızda normal büyütme işlevlerini kullanabilecek ve nesneniz yeni bir tomara kopyalandığında tekrar hızlı büyütme işlevlerini kullanabileceğiniz güvenilir bir alana sahip olabileceksiniz.
      </para><para>Burada bir örnek var:</para><para>
<screen>
void dizge_ekle (struct obstack *yiginak, const char *dizge, int uzunluk)
{
  while (uzunluk > 0)
  {
    int bosyer = obstack_room (yiginak);
    if (bosyer == 0)
    {
      /* Yeterli boş yer yok. Bir karakter eklersek nesnemiz
         yeni bir tomara kopyalacak ve boş yer olacak. */
      obstack_1grow (yiginak, *dizge++);
      uzunluk--;
    }
    else
    {
      if (bosyer > uzunluk)
        bosyer = uzunluk;

      /* Boş yer olduğuna göre hızlı olarak ekleme yapabiliriz. */
      uzunluk -= bosyer;
      while (bosyer-- > 0)
        obstack_1grow_fast (yiginak, *dizge++);
    }
  }
}
</screen></para>
    </sect2><sect2 id="glibc-Status-of-an-Obstack">
      <title>Bir Yığınağın Durumu</title>
      <titleabbrev>Bir yığınağın durumu hakkında bilgi edinmek.</titleabbrev>
      <para>
<indexterm scope="glibc-cp"><primary>yığınaklar</primary><secondary>yığınağın durumu</secondary></indexterm>
Burada açıklanan işlevler kullanımdaki bir yığınağın durumu hakkında bilgi verirler. Buradaki işlevleri büyümekte olan nesneler hakkında bilgi edinmek için de kullanabilirsiniz.
      </para><para id="glibc-obstack_base">
<indexterm scope="glibc-fn"><primary>obstack_base</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>void *<command>obstack_base</command></funcdef>
<paramdef>(struct obstack *<varname>yığınak</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev <varname>yığınak</varname>'da büyüyen nesnenin başlangıçta geçici olarak kullanılan adresi ile döner. Bu işlevin hemen ardından büyüyen nesne bitirilirse bu adres dönecektir. Ama bitirme işlemini nesneyi fazlaca büyüttükten sonra yaparsanız dönen adres farklı olabilecektir.
        </para><para>
Büyüyen bir nesne yoksa, sonraki nesnenin başlangıç adresi ile döner (tomarın yeni bir nesne için yeterli olduğu varsayımıyla).
</para></funcdescr></funcsynopsis>
</para><para id="glibc-obstack_next_free">
<indexterm scope="glibc-fn"><primary>obstack_next_free</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>void *<command>obstack_next_free</command></funcdef>
<paramdef>(struct obstack *<varname>yığınak</varname>)</paramdef>
</funcprototype><funcdescr><para>
<varname>yığınak</varname>'ın bulunduğu tomardaki ilk serbest baytın adresi ile döner. Bu adres, büyümekte olan nesnenin sonundadır. Eğer nesne bir büyüyen nesne değilse, <command>obstack_base</command> ile dönen adresin aynısı döner.
</para></funcdescr></funcsynopsis>
</para><para id="glibc-obstack_object_size">
<indexterm scope="glibc-fn"><primary>obstack_object_size</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>obstack_object_size</command></funcdef>
<paramdef>(struct obstack *<varname>yığınak</varname>)</paramdef>
</funcprototype><funcdescr><para>
Büyümekte olan nesnenin uzunluğu ile döner. Bu değer aşağıdaki ifade ile elde edilen değere eşittir:
        </para><para>
<literallayout>
obstack_next_free (<varname>yiginak</varname>) - obstack_base (<varname>yiginak</varname>)
</literallayout>
</para></funcdescr></funcsynopsis></para>
    </sect2><sect2 id="glibc-Obstacks-Data-Alignment">
      <title>Yığınaktaki Verinin Adreslenmesi</title>
      <titleabbrev>Yığınaktaki nesnelerin hizaya sokulması</titleabbrev>
      <para>
<indexterm scope="glibc-cp"><primary>yığınaklar</primary><secondary>adresleme</secondary></indexterm>
Her yığınak bir <wordasword>adres boyu</wordasword>’na sahiptir. Yığınağa konulan ilk nesne özdevimli olarak bir adrese konur ve her nesne bu adresin belirtilen adres boyunun katlarındaki adreslere yerleştirilir. Öntanımlı olarak bu adres boyu her veri türünü tutabilecek bir nesneye gereken kadardır.
      </para><para>
Adres boyunu öğrenmek için <command>obstack_alignment_mask</command> işlevi kullanılır:
      </para><para id="glibc-obstack_alignment_mask">
<indexterm scope="glibc-fn"><primary>obstack_alignment_mask</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>int <command>obstack_alignment_mask</command></funcdef>
<paramdef>(struct obstack *<varname>yığınak</varname>)</paramdef>
</funcprototype><funcdescr><para>
Dönen değer bir bit maskesidir; değeri 1 olan bir bit, nesnenin adresinin ilgili bitinin 0 olması gerektiğini belirtir. Maske değeri, nesneler ikinin kuvvetlerindeki adres boylarında adreslendiğinden, ikinin kuvveti eksi birdir. Öntanımlı maske değeri hizalı nesnelerin her veri türünü tutmasını mümkün kılacak bir değerdir: Örneğin, maske değeri 3 ise adresleri 4'ün katları olan her veri türü saklanabilir. Maske değeri sıfırsa adresleme birer baytlıktır ve bu durumda adresleme yoktur denir.
        </para><para>
<command>obstack_alignment_mask</command> makrosu bir sol taraf değeri olarak yorumlanır, yani maskı siz değiştirebilirsiniz. Örnek:
        </para><para>
<screen>
obstack_alignment_mask (yiginak) = 0;
</screen></para><para>
Burada, belirtilen yığınakta adresleme işlemi kapatılmıştır.
</para></funcdescr></funcsynopsis>
      </para><para><note><para>
Adresleme boyu değişikliği bir nesne ayrıldıktan sonra ya da bitirildiğinde etkisizdir. Bir nesneyi hiç büyütmeden yeni bir adres boyu belirtip nesneyi <command>obstack_finish</command> ile sıfır uzunlukta bitirip sonraki nesneler için yeni adres boyunu geçerli yapabilirsiniz.
      </para></note></para>
    </sect2><sect2 id="glibc-Obstack-Chunks">
      <title>Yığınak Tomarları</title>
      <titleabbrev>Yığınaklar tomarları nasıl oluşturur ve serbest bırakır; verimlilik kaygıları.</titleabbrev>
      <para>
<indexterm scope="glibc-cp"><primary>yığınaklar</primary><secondary>tomarlar</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>tomarlar</primary></indexterm>
Yığınaklar kendilerine büyük tomarlar halinde yer ayırırlar ve bu alanı sizin isteklerinizi karşılamak üzere parsellerler. Başka bir tomar uzunluğu belirtilmediği sürece öntanımlı tomar uzunluğu 4096 bayttır. Tomarın 8 baytlık bölümü nesneleri saklamakta kullanılmaz. Bir tomar uzunluğu belirtilmiş bile olsa, büyük nesneler için gerekirse daha büyük uzunlukta tomarlar ayrılabilir.
      </para><para>
Yığınak kütüphanesi tomarları sizin tanımlayacağınız <command>obstack_chunk_alloc</command> işlevini çağırarak ayırır. İçindeki tüm nesnelerin çıkarılmasıyla boşalan bir tomarı yine sizin tanımlayacağınız <command>obstack_chunk_free</command> işlevini çağırarak serbest bırakır.
      </para><para>
Bu iki işlev, <link linkend="glibc-Creating-Obstacks"><command>obstack_init </command></link> kullanılan her kaynak dosyasında ya makro olarak tanımlanmalı ya da işlev olarak bildirilmelidir. Bunlar makro olarak çoğunlukla aşağıdaki gibi tanımlanır:
      </para><para>
<screen>
#define obstack_chunk_alloc malloc
#define obstack_chunk_free free
</screen></para><para>
Bunlar basit makrolardır (argümansız). Argümanlı makro tanımları çalışmayacaktır. Bu, <command>obstack_chunk_alloc</command> veya <command>obstack_chunk_free</command> nin, tek başına kendisi bir işlev değilse bir işlev ismi olarak kullanılacağından böyledir.
      </para><para>
Tomarları <command>malloc</command> ile ayırırsanız tomar boyu ikinin kuvvetlerinden biri olmalıdır. Öntanımlı tomar boyu 4096 bayttır. Bu boyut, son tomarda kullanılmadan çok fazla bellek kalmasına yol açmayacak kadar küçük, sıradan isteklere yanıt verecek kadar da büyük bir bellek boyudur.
      </para><para id="glibc-obstack_chunk_size">
<indexterm scope="glibc-fn"><primary>obstack_chunk_size</primary></indexterm>
<funcsynopsis><funcprototype role="makro">
<funcdef>int <command>obstack_chunk_size</command></funcdef>
<paramdef>(struct obstack *<varname>yığınak</varname>)</paramdef>
</funcprototype><funcdescr><para>
Belirtilen yığınağın tomar boyu ile döner.
      </para><para>
Bu makro bir sol taraf değeri olarak yorumlandığından ona yeni bir değer atayarak farklı bir tomar boyu belirtebilirsiniz. Bunun yapılması, mevcut ayrılmış tomarları etkilemez, sadece bu atamadan sonra ayrılan tomarlar etkilenir. Bir tomarı bu yöntemle daha küçük boylarda ayırmak mümkünse de, çok fazla nesne kullanacaksanız daha büyük tomar boyları daha verimli olacaktır. Örnek:
      </para><para>
<screen>
if (obstack_chunk_size (yiginak-gstr) &lt; <varname>yeni-tomar-boyu</varname>)
  obstack_chunk_size (yiginak-gstr) = <varname>yeni-tomar-boyu</varname>;
</screen></para></funcdescr></funcsynopsis></para>
    </sect2><sect2 id="glibc-Summary-of-Obstacks">
      <title>Yığınak İşlevlerinin Listesi</title>
      <para>
Burada yığınaklarla ilgili işlevlerin bir özet listesine yer verilmiştir. Her biri ilk argüman olarak <command>struct obstack *</command> türünde bir yığınak adresi alır.
      </para><para>
<funcsynopsis><funcprototype role="işlev">
<funcdef>void <command>obstack_init</command></funcdef>
<paramdef>(struct obstack *<varname>yığınak</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bir yığınağı ilklendirir. Bkz.  <xref linkend="glibc-Creating-Obstacks"/>.
</para></funcdescr></funcsynopsis></para><para>
<funcsynopsis><funcprototype role="işlev">
<funcdef>void *<command>obstack_alloc</command></funcdef>
<paramdef>(struct obstack *<varname>yığınak</varname>,
 int             <varname>boyut</varname>)</paramdef>
</funcprototype><funcdescr><para>
İlklendirmeden <varname>boyut</varname> baytlık bir nesneye yer ayrılır. Bkz. <xref linkend="glibc-Allocation-in-an-Obstack"/>.
</para></funcdescr></funcsynopsis></para><para>
<funcsynopsis><funcprototype role="işlev">
<funcdef>void *<command>obstack_copy</command></funcdef>
<paramdef>(struct obstack *<varname>yığınak</varname>,
 void          *<varname>adres</varname>,
 int            <varname>boyut</varname>)</paramdef>
</funcprototype><funcdescr><para>
İçeriğini <varname>adres</varname>’ten kopyalayarak <varname>boyut</varname> baytlık bir nesneye yer ayırır. Bkz.  <xref linkend="glibc-Allocation-in-an-Obstack"/>.
</para></funcdescr></funcsynopsis></para><para>
<funcsynopsis><funcprototype role="işlev">
<funcdef>void *<command>obstack_copy0</command></funcdef>
<paramdef>(struct obstack *<varname>yığınak</varname>,
 void          *<varname>adres</varname>,
 int            <varname>boyut</varname>)</paramdef>
</funcprototype><funcdescr><para>
İçeriğini <varname>adres</varname>’ten kopyalayarak <varname>boyut</varname> baytlık bir nesneye sonuna bir boş karakter ekleyerek yer ayırır. Bkz. <xref linkend="glibc-Allocation-in-an-Obstack"/>.
</para></funcdescr></funcsynopsis></para><para>
<funcsynopsis><funcprototype role="işlev">
<funcdef>void <command>obstack_free</command></funcdef>
<paramdef>(struct obstack *<varname>yığınak</varname>,
 void          *<varname>nesne</varname>)</paramdef>
</funcprototype><funcdescr><para>
<varname>nesne</varname> ve <varname>nesne</varname>’den sonra ayrılan tüm nesneleri yığınaktan çıkarır (serbest bırakır). Bkz. <xref linkend="glibc-Freeing-Obstack-Objects"/>.
</para></funcdescr></funcsynopsis></para><para>
<funcsynopsis><funcprototype role="işlev">
<funcdef>void <command>obstack_blank</command></funcdef>
<paramdef>(struct obstack *<varname>yığınak</varname>,
 int             <varname>boyut</varname>)</paramdef>
</funcprototype><funcdescr><para>
Büyüyen nesneye ilklendirilmemiş <varname>boyut</varname> bayt ekler. Bkz. <xref linkend="glibc-Growing-Objects"/>.
</para></funcdescr></funcsynopsis></para><para>
<funcsynopsis><funcprototype role="işlev">
<funcdef>void <command>obstack_grow</command></funcdef>
<paramdef>(struct obstack *<varname>yığınak</varname>,
 void          *<varname>adres</varname>,
 int            <varname>boyut</varname>)</paramdef>
</funcprototype><funcdescr><para>
Büyüyen nesneye içeriğini <varname>adres</varname>’ten kopyalarak <varname>boyut</varname> bayt ekler. Bkz. <xref linkend="glibc-Growing-Objects"/>.
</para></funcdescr></funcsynopsis></para><para>
<funcsynopsis><funcprototype role="işlev">
<funcdef>void <command>obstack_grow0</command></funcdef>
<paramdef>(struct obstack *<varname>yığınak</varname>,
 void          *<varname>adres</varname>,
 int            <varname>boyut</varname>)</paramdef>
</funcprototype><funcdescr><para>
Büyüyen nesneye içeriğini <varname>adres</varname>’ten kopyalarak <varname>boyut</varname> bayt artı bir boş karakter ekler. Bkz. <xref linkend="glibc-Growing-Objects"/>.
</para></funcdescr></funcsynopsis></para><para>
<funcsynopsis><funcprototype role="işlev">
<funcdef>void <command>obstack_1grow</command></funcdef>
<paramdef>(struct obstack *<varname>yığınak</varname>,
 char            <varname>karakter</varname>)</paramdef>
</funcprototype><funcdescr><para>
Büyüyen nesneye <varname>karakter</varname> içeren bir bayt ekler. Bkz. <xref linkend="glibc-Growing-Objects"/>.
</para></funcdescr></funcsynopsis></para><para>
<funcsynopsis><funcprototype role="işlev">
<funcdef>void *<command>obstack_finish</command></funcdef>
<paramdef>(struct obstack *<varname>yığınak</varname>)</paramdef>
</funcprototype><funcdescr><para>
Büyüyen nesneyi kapatarak (bitirerek) son adresi ile döner. Bkz.  <xref linkend="glibc-Growing-Objects"/>.
</para></funcdescr></funcsynopsis></para><para>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>obstack_object_size</command></funcdef>
<paramdef>(struct obstack *<varname>yığınak</varname>)</paramdef>
</funcprototype><funcdescr><para>
Büyüyen nesnenin o andaki boyu ile döner. Bkz. <xref linkend="glibc-Growing-Objects"/>.
</para></funcdescr></funcsynopsis></para><para>
<funcsynopsis><funcprototype role="işlev">
<funcdef>void <command>obstack_blank_fast</command></funcdef>
<paramdef>(struct obstack *<varname>yığınak</varname>,
 int            <varname>boyut</varname>)</paramdef>
</funcprototype><funcdescr><para>
Yeterli yer olup olmadığını denetlemeksizin büyüyen nesneye ilklendirmeden <varname>boyut</varname> bayt ekler. Bkz. <xref linkend="glibc-Extra-Fast-Growing"/>.
</para></funcdescr></funcsynopsis></para><para>
<funcsynopsis><funcprototype role="işlev">
<funcdef>void <command>obstack_1grow_fast</command></funcdef>
<paramdef>(struct obstack *<varname>yığınak</varname>,
 char            <varname>karakter</varname>)</paramdef>
</funcprototype><funcdescr><para>
Yeterli yer olup olmadığını denetlemeksizin büyüyen nesneye  <varname>karakter</varname> içeren bir bayt ekler. Bkz. <xref linkend="glibc-Extra-Fast-Growing"/>.
</para></funcdescr></funcsynopsis></para><para>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>obstack_room</command></funcdef>
<paramdef>(struct obstack *<varname>yığınak</varname>)</paramdef>
</funcprototype><funcdescr><para>
Büyüyen nesnede o andaki kullanılabilir alanın miktarı ile döner. Bkz. <xref linkend="glibc-Extra-Fast-Growing"/>.
</para></funcdescr></funcsynopsis></para><para>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>obstack_alignment_mask</command></funcdef>
<paramdef>(struct obstack *<varname>yığınak</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bir nesnenin başlangıcını hizalamakta kullanılan maske ile döner. Bu bir sol taraf değeridir. Bkz.  <xref linkend="glibc-Obstacks-Data-Alignment"/>.
</para></funcdescr></funcsynopsis></para><para>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>obstack_chunk_size</command></funcdef>
<paramdef>(struct obstack *<varname>yığınak</varname>)</paramdef>
</funcprototype><funcdescr><para>
Ayrılan tomarların boyunu verir, ayrılacak tomarlar için boy belirtilir. Bir sol taraf değeridir. Bkz.  <xref linkend="glibc-Obstack-Chunks"/>.
</para></funcdescr></funcsynopsis></para><para>
<funcsynopsis><funcprototype role="işlev">
<funcdef>void *<command>obstack_base</command></funcdef>
<paramdef>(struct obstack *<varname>yığınak</varname>)</paramdef>
</funcprototype><funcdescr><para>
Büyüyen nesnenin geçici başlangıç adresi ile döner. Bkz. <xref linkend="glibc-Status-of-an-Obstack"/>.
</para></funcdescr></funcsynopsis></para><para>
<funcsynopsis><funcprototype role="işlev">
<funcdef>void *<command>obstack_next_free</command></funcdef>
<paramdef>(struct obstack *<varname>yığınak</varname>)</paramdef>
</funcprototype><funcdescr><para>
Belirtilen büyüyen nesnenin sonundan sonraki adres ile döner. Bkz. <xref linkend="glibc-Status-of-an-Obstack"/>.
</para></funcdescr></funcsynopsis></para>
    </sect2>
  </sect1>
  <sect1 id="glibc-Variable-Size-Automatic">
    <title>Değişken Boyutlu Özdevinimli Saklama</title>
    <titleabbrev>Karmaşık deyimler içindeki özdevinimli değişkenler için değişken boyutlu yer ayırma.</titleabbrev>
    <para>
<indexterm scope="glibc-cp"><primary>bellek</primary><secondary>serbest bırakma</secondary><tertiary>özdevinimli</tertiary></indexterm>
<indexterm scope="glibc-cp"><primary><command>alloca</command> işlevi</primary></indexterm>
<indexterm scope="glibc-cp"><primary>değişken boyutlu özdevinimli saklama</primary></indexterm>
<command>alloca</command> işlevi, özdevimli ayrılan ama özdevinimli serbest bırakılan blokların yarı özdevimli bir bellek ayırma çeşidini destekler.
    </para><para>
<command>alloca</command> ile bir bloğun ayrılması doğrudan doğruya yapılan bir eylemdir; istediğiniz kadar blok ayırabilir ve çalışma anında boyunu hesaplayabilirsiniz. Ancak serbest bırakma işlemi <command>alloca</command> işlevinin çağrıldığı işlevden çıkıldığında özdevinimli olarak gerçekleşir. Ayrılan alanı doğrudan doğruya serbest bırakmak için bir yol yoktur.
    </para><para>
<command>alloca</command> işlevi <filename>stdlib.h</filename> başlık dosyasında bildirilmiştir ve bir BSD oluşumudur.
<indexterm scope="glibc-pg"><primary>stdlib.h</primary></indexterm>
    </para><para id="glibc-alloca">
<indexterm scope="glibc-fn"><primary>alloca</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>void *<command>alloca</command></funcdef>
<paramdef>(size_t <varname>boyut</varname>)</paramdef>
</funcprototype><funcdescr><para>
Çağrıldığı işlevin yığıt çerçevesinde ayrılan <varname>boyut</varname> baytlık bir bloğun adresi ile döner.
</para></funcdescr></funcsynopsis>
    </para><para>
<command>alloca</command> işlevini bir işlev çağrısının argümanı olarak kullanmayın, yoksa istenmeyen sonuçlar ortaya çıkabilir. Çünkü  <command>alloca</command> için ayrılan yığıt alanı işlev argümanları için ayrılan alanın ortasındaki yığıtın üzerinde görünecektir. Örneğin, <command>foo (x, alloca (4), y)</command> gibi bir çağrı yapmayın.
    </para>
    <sect2 id="glibc-Alloca-Example">
      <title><command>alloca</command> Örneği</title>
      <titleabbrev><command>alloca</command> kullanılan bir örnek.</titleabbrev>
      <para>
<command>alloca</command> kullanılan bir örnek olarak, iki dizge argüman alıp bunları birleştirip bir dosya ismi elde eden ve bu dosyayı açtığında bu dosyaya bir tanıtıcı ile dönen, dosyayı açamazsa açamadığını belirtmek üzere <literal>-1</literal> ile dönen bir işlev aşağıdadır:
     </para><para>
<screen>
int
open2 (char *str1, char *str2, int flags, int mode)
{
  char *name = (char *) alloca (strlen (str1) + strlen (str2) + 1);
  stpcpy (stpcpy (name, str1), str2);
  return open (name, flags, mode);
}
</screen></para><para>
Aşağıdaki örnekte ise aynı sonuç <command>malloc</command> ve <command>free</command> işlevleri ile elde edilmektedir:
     </para><para>
<screen>
int
open2 (char *str1, char *str2, int flags, int mode)
{
  char *name = (char *) malloc (strlen (str1) + strlen (str2) + 1);
  int desc;
  if (name == 0)
    fatal (&quot;sanal bellek tükendi&quot;);
  stpcpy (stpcpy (name, str1), str2);
  desc = open (name, flags, mode);
  free (name);
  return desc;
}
</screen></para><para>
Gördüğünüz gibi <command>alloca</command> ile işlem daha basittir. Ancak <command>alloca</command> işlevinin getirileri kadar götürüleri de vardır.
      </para>
    </sect2><sect2 id="glibc-Advantages-of-Alloca">
      <title><literal>alloca</literal> İşlevinin Getirileri</title>
      <titleabbrev><command>alloca</command> kullanma sebepleri.</titleabbrev>
      <para>
<command>alloca</command> işlevinin <command>malloc</command> işlevine tercih edilmesindeki sebepler:
      </para><para><itemizedlist><listitem><para>
<command>alloca</command> kullanılarak çok küçük bir alan işe yaramaz hale gelir ve işlev çok hızlıdır. (GNU C derleyicisi içinde açık kodludur.)
      </para></listitem><listitem><para>
<command>alloca</command> farklı blok boyları için ayrı havuzlar  oluşturmadığından, farklı boylardaki bloklar başka boylarda bloklar oluşturmak için yeniden kullanılabilir. <command>alloca</command> bellek parçalanmasına sebep olmaz.
      </para></listitem><listitem><para>
<indexterm scope="glibc-cp"><primary>longjmp</primary></indexterm>
Yerel olmayan çıkışlar <link linkend="glibc-Non-Local-Exits"><command>longjmp</command></link> <command>alloca</command> işlevini çağıran işlevden de çıkışa sebep olacağından <command>alloca</command> ile ayrılan alan özdevinimli olarak serbest bırakılır. Bu, <command>alloca</command> işlevinin kullanılması için en önemli sebeptir.
      </para><para>
Bunu örnekleyecek olursak, <command>open</command> gibi başarılı olduğunda bir dosya tanıtıcı döndüren ama başarısız olduğunda dönmeyen  <function>open_or_report_error</function> isimli bir işleviniz olsun. Dosya açılamazsa bir hata iletisi bassın ve <command>longjmp</command> kullanarak yazılımınızın komut seviyesine geçsin. <link linkend="glibc-Alloca-Example">Önceki örnekteki</link> <function>open2</function> işlevini bu işlevi kullanacak şekilde değiştirelim:
      </para><para>
<screen>
int
open2 (char *str1, char *str2, int flags, int mode)
{
  char *name = (char *) alloca (strlen (str1) + strlen (str2) + 1);
  stpcpy (stpcpy (name, str1), str2);
  return open_or_report_error (name, flags, mode);
}
</screen></para><para>
<command>alloca</command> işlevinin çalışma şeklinden dolayı, ayırdığı bellek bir hata oluşsa bile serbest bırakılır ve bunun için ek bir çaba gerekmez.
      </para><para>
Karşılaştıma için, <function>open2</function> işlevinin önceki tanımı (<command>malloc</command> ve <command>free</command> kullanılan) bu amaç için değiştirildiğinde bir bellek artığı oluşacaktı. Hatta, siz bunu düzeltmek için her değişikliği yapmaya razı olsanız bile, bunu yapmanın daha kolay bir yolu yoktur.
      </para></listitem></itemizedlist></para>
    </sect2><sect2 id="glibc-Disadvantages-of-Alloca">
      <title><literal>alloca</literal> İşlevinin Götürüleri</title>
      <titleabbrev><command>alloca</command> kullanmaktan kaçınma sebepleri.</titleabbrev>
      <para>
<indexterm scope="glibc-cp"><primary><function>alloca</function> kullanmama sebepleri</primary></indexterm>
<command>alloca</command> işlevinin <command>malloc</command> ile karşılaştırıldığında bazı götürüleri vardır:
      </para><para><itemizedlist><listitem><para>
Makinenin sağladığından daha fazla bellek ayırmaya kalkarsanız temiz bir hata iletisi almazsınız. Bunun yerine bir sonsuz döngünün oluşturduğu gibi, olası bir <link linkend="glibc-Program-Error-Signals">bölütleme  karışıklığından dolayı</link> bir ölümcül sinyal alırsınız.
      </para></listitem><listitem><para>
Bazı GNU dışı sistemlerde daha az taşınabilir olduğundan <command>alloca</command> desteği bulunmayabilir. Yine de bazı sistemlerdeki bu eksikliği gidermek için yazılmış daha yavaş bir taklidi C'de vardır.
      </para></listitem></itemizedlist></para>
    </sect2> <sect2 id="glibc-GNU-C-Variable-Size-Arrays">
       <title>GNU C Değişken Boyutlu Dizileri</title>
       <titleabbrev>Özdevimli ayırma ve özdevinimli serbest bırakma için sadece GNU C için geçerli bir yöntem daha vardır.</titleabbrev>
       <para>
<indexterm scope="glibc-cp"><primary>değişken boyutlu diziler</primary></indexterm>
GNU C'de <command>alloca</command> kullanımı yerine birçok durumda bir değişken boyutlu dizi kullanılabilir. Önceki örneklerdeki <function>open2</function> işlevini bu şekilde değiştirelim:
     </para><para>
<screen>
int open2 (char *str1, char *str2, int flags, int mode)
{
  char name[strlen (str1) + strlen (str2) + 1];
  stpcpy (stpcpy (name, str1), str2);
  return open (name, flags, mode);
}
</screen></para><para>
Ancak çeşitli sebeplerle, <command>alloca</command> daima bir değişken  boyutlu diziye eşdeğer değildir:
      </para><para><itemizedlist><listitem><para>
Bir değişken boyutlu dizinin bellek alanı, dizi isminin etki alanının sonunda serbest bırakılır. <command>alloca</command> ile ayrılan alan ise işlev sonuna kadar kalır.
      </para></listitem><listitem><para>
<command>alloca</command> işlevi her yinelemede ek bir blok ayırmak üzere bir döngü içinde kullanılabilir. Bu değişken boyutlu dizilerle mümkün değildir.
      </para></listitem></itemizedlist></para><para>
<note><para><command>alloca</command> ile değişken boyutlu dizileri aynı işlevde karışık kullanırsanız, bir değişken boyutlu dizinin bildirildiği etki alanının çıkması, bu etki alanının çalışması sırasında <command>alloca</command> ile ayrılmış tüm blokların serbest bırakılmasına sebep olur.</para></note>
      </para>
    </sect2>
  </sect1>
</chapter>

<chapter id="glibc-Resizing-the-Data-Segment">
  <title>Veri Bölütünün Boyunun Değiştirilmesi</title>
  <titleabbrev><command>brk</command>, <command>sbrk</command></titleabbrev>
<indexterm scope="glibc-cp"><primary>bellek</primary><secondary>veri bölütü</secondary></indexterm>
  <para/><para>
    Bu kısımdaki semboller <filename>unistd.h</filename> başlık dosyasında bildirilmiştir.
  </para><para>
<xref linkend="glibc-Memory-Allocation"/> bölümünde açıklanan işlevlere göre kullanımı daha kolay olduğundan normalde, bu kısımda anlatılan işlevleri kullanacaksınız. Bunlar, kendi kullandıkları GNU C Kütüphanesi bellek ayırıcısı için birer arayüz oldukları gibi sistem çağrılarının da basit birer arayüzüdürler.
  </para><para id="glibc-brk">
<indexterm scope="glibc-fn"><primary>brk</primary></indexterm>
<indexterm scope="glibc-cp"><primary>bellek</primary><secondary>perde (break)</secondary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>brk</command></funcdef>
<paramdef>(void *<varname>adres</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>brk</command> işlevi çağrı sürecinin veri bölütünün yüksek sonunu <varname>adres</varname> olarak belirler.
    </para><para>
Bölüt sonunun adresi bölütteki son baytın adresi artı bir olarak tanımlıdır.
    </para><para>
İşlev, eğer <varname>adres</varname> veri bölütünün düşük sonundan daha düşükse etkisizdir. (Bu durumda işlevin başarılı olduğu varsayılmıştır.)
    </para><para>
İşlev, veri bölütü diğer bir bölütün içine girerse ya da <link  linkend="glibc-Limits-on-Resources">sürecin veri saklama sınırını</link> aşarsa başarısız olur.
    </para><para>
Veri saklama alanı ve yığıtın aynı bölütte olduğu bir ortak geçmişsel bir olgu sebebiyle işlev bu ismi almıştır. Yığıt bölütünün üstünden altına doğru büyürken, veri saklama alanı bölütün altından üstüne doğru büyür ve bunlar arasındaki perdeye perde (<firstterm>break</firstterm>) denir.
    </para><para>
Başarı durumunda sıfır değeri döner. Başarısızlık durumunda <command>-1</command> döner ve <command>errno</command> hata değerine ayarlanır. Aşağıdaki <command>errno</command> değeri bu işleve özeldir:
    </para><para>
      <variablelist><varlistentry><term id="glibc-brk-ENOMEM"><literal>ENOMEM</literal>
        <indexterm scope="glibc-vr"><primary>ENOMEM</primary></indexterm>
        </term><listitem><para>
İstek veri bölütünün başka bir bölütün içine girmesine ya da sürecin veri saklama sınırının aşılmasına sebep oldu.
        </para></listitem>
      </varlistentry></variablelist>
</para></funcdescr></funcsynopsis></para><para id="glibc-sbrk">
<indexterm scope="glibc-fn"><primary sortas="sbrk">*sbrk</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>void <command>*sbrk</command></funcdef>
<paramdef>(ptrdiff_t <varname>delta</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev <command>brk</command> ile aynı sonucu verir, farklı olarak, veri bölütünün sonundan itibaren bir konum olarak <varname>delta</varname> ile belirtirsiniz ve işlev başarılı olduğunda sıfır yerine veri bölütünün sonunun adres değeri ile döner.
    </para><para>
Yani, veri bölütünün o andaki sonunu öğrenmek için <command>sbrk(0)</command> kullanabilirsiniz.
    </para></funcdescr></funcsynopsis>
  </para>
</chapter>

<chapter id="glibc-Locking-Pages">
  <title>Sayfaların Kilitlenmesi</title>
  <titleabbrev>Sayfalama hatalarından korunma</titleabbrev>
  <para/><para>
<indexterm scope="glibc-cp"><primary>sayfaların kilitlenmesi</primary></indexterm>
<indexterm scope="glibc-cp"><primary>bellek</primary><secondary>kilitleme</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>sayfalama</primary></indexterm>
Sisteme belirli bir sanal bellek sayfasını bir gerçek bellek sayfa çerçevesi ile ilişkilendirmesini ve bu bağlantıyı tutmasını isteyebilirsiniz. Böylece bir sayfalama hatası oluşmaz. Bu işleme <wordasword>bir sayfanın kilitlenmesi</wordasword> denir.
  </para><para>
Bu kısımdaki işlevler çağrılan sürecin sayfalarını kilitlemek ve bırakmak için kullanılır.
  </para>
  <sect1 id="glibc-Why-Lock-Pages">
    <title>Sayfalar Neden Kilitlenir?</title>
    <titleabbrev>Bu bölümün okunma sebepleri.</titleabbrev>
    <para>
Sayfalama hataları şeffaf olarak gerçek belleğe alınacak sayfaların sanal bellekte kalmasına sebep olduğundan, bir sürecin nadir olarak sayfaların kilitlenmesi ile ilgilenmesi gerekir. Bununla birlikte iki sebep daha vardır:
    </para><para>
      <itemizedlist><listitem><para>
<indexterm scope="glibc-cp"><primary>gerçek zamanlı işlemler</primary></indexterm>
<indexterm scope="glibc-cp"><primary>çalışma hızı</primary></indexterm>
Hız. Bir sayfalama hatası sadece, bir süreç basit bir bellek erişiminin ne kadar süreceğine duyarlı değilse şeffaftır. Zamana bağlı süreçler, özellikle gerçek zamanlı süreçler bekleyemez ya da çalışma hızındaki bir değişikliği gideremeyebilirler. Bir süreç bu sebeple sayfaların kilitlenmesine ihtiyaç duyabildiği gibi ayrıca işlemci kullanımı bakımından diğer süreçlere göre öncelik alması gerekebilr. Bkz. <xref linkend="glibc-Priority"/>
      </para><para>
Bazı durumlarda, hangi sayfaların gerçek bellekte kalmasının sistem başarımı için en iyi olduğunu yazılımcı sistemin istek halinde sayfalama ayırıcısından  daha iyi bilir. Bu durumda sayfaların kilitlenmesi işe yarayabilir.
      </para></listitem><listitem><para>
Gizlilik. Bazı gizlilik gerektiren şeyleri sanal bellekte tutuyorsanız ve sanal bellek gerçek belleğe alınamazsa, gizli kalması gereken şeylerin açığa çıkma şansı artar. Örneğin, bir parola disk takas alanına yazılmışsa, sanal ve gerçek bellekler tamamen temizlendikten sonra çok uzun sürelerle orada kalmaya devam edebilir.
      </para></listitem></itemizedlist>
    </para><para>
Bir sayfayı kilitlediğiniz zaman, diğer sanal bellek kullanıcıları (aynı ya da başka süreçler) için daha az çerçeve kalabilir ve bu durum daha fazla sayfalama hatası oluşmasına ve hatta sistemin daha yavaş çalışmasına sebep olabilir. Hatta yeterince büyük belleği kilitlerseniz bazı yazılımlar gerçek bellek yokluğundan hiç çalışmayabilir.
    </para>
  </sect1><sect1 id="glibc-Locked-Memory-Details">
    <title>Kilitli Bellekler Hakkında</title>
    <titleabbrev>Kilitli bellekler hakkında bilinmesi gereken herşey.</titleabbrev>
    <para>
Bir bellek kilidi bir gerçek bellek çerçevesi ile değil, bir sanal sayfa ile ilişkilidir. Sayfalama kuralı: Bir çerçeveye en azından bir kilitli sayfa kopyalanmışsa, geriye sanal belleğe kopyalanmaz.
    </para><para>
Bellek kilitleri yığıta atılmaz. Örneğin, belli bir sayfayı iki kere  kilitleyemezsiniz, yani bir sayfa ya kilitlidir ya da değildir.
    </para><para>
Bir bellek, süreç tarafından doğrudan doğruya kilidi açılmadıkça kilitli kalmaya devam eder. (Ancak sürecin sonlandırılması ve çalıştırma işlemi sanal belleğin mevcudiyetinin sona ermesine sebep olur ve artık o kilitli değildir diyebilirsiniz.)
    </para><para>
Bellek kilitleri alt süreçler tarafından miras alınmaz. (Ancak, güncel bir Unix sisteminde, bir çatallamanın hemen ardından asıl ve alt sürecin sanal adres alanı aynı çerçevelere kopyalanır ve böylece alt süreç kendini çatallayan atasının kilitlerine sahip olur.) Bkz. <xref linkend="glibc-Creating-a-Process"/>.
    </para><para>
Diğer süreçleri etkilemesi nedeniyle bir sayfayı sadece süper kullanıcı kilitleyebildiği halde her süreç kendi sayfasının kilidini kaldırabilir.
    </para><para>
Bir sürecin kilitleyebileceği bellek miktarının ve ona adanabilen gerçek bellek miktarının sınırını sistem belirler. Bkz. <xref linkend="glibc-Limits-on-Resources"/>.
    </para><para>
Linux’ta kilitli sayfalar sizin düşündüğünüz gibi kilitlenmez. Belleği paylaşmayan iki sanal sayfa yine de aynı çerçeve tarafından kopyalanabilir. Her iki sayfanın aynı veriyi içerdiğini biliyorsa ve hatta sanal sayfalardan biri ya da her ikisi kilitli de olsa çekirdek bunu verimlilik adına yapar.
    </para><para>
Ama bir süreç bu sayfalardan birini değiştirirse, çekirdek onu ayrı bir  çerçeveye almalı ve çerçeveyi sayfanın verisi ile doldurmalıdır. Bu <wordasword>yazma sırasında kopyalanan sayfalama hatası</wordasword> olarak bilinir. Bu durum ve çerçevenin alınmasının G/Ç gerektirdiği marazi durumlarda biraz zaman alabilir.
<indexterm scope="glibc-cp"><primary>yazma sırasında kopyalanan sayfalama hatası</primary></indexterm>
<indexterm scope="glibc-cp"><primary>bellek</primary><secondary>sayfalama hatası</secondary><tertiary>yazma sırasında kopyalama</tertiary></indexterm>
    </para><para>
Yazılımınızda bunun oluşmayacağından emin olmak için sayfaları kilitlemeyin. Onlara yazıp yazmayacacağınızı bilmeseniz bile onlara yazın. Ve yığıtınız için önceden ayrılmış çerçevelerin varlığından emin olmak için ihtiyaç duyduğunuz en büyük yığıt boyundan daha büyük bir C özdevinimli değişkeninin bidirildiği bir karmaşık deyime girip değişkene bazı şeyler atayın ve onu döndürün.
    </para>
  </sect1><sect1 id="glibc-Page-Lock-Functions">
    <title>Sayfaları Kilitleyen ve Kilitlerini Açan İşlevler</title>
    <titleabbrev>Bu işlemler nasıl yapılır.</titleabbrev>
    <para>
Bu bölümdeki işlevler <filename>sys/mman.h</filename> başlık dosyasında bildirilmiştir. Bu işlevler by POSIX.1b tarafından tanımlanmıştır ama onların kullanılabilirliği çekirdeğinize bağımlıdır. Çekirdeğiniz bu işlevlere izin vermiyorsa onlar var olsalar bile başarısız olacaklardır. <emphasis>Linux çekirdeği ile bu işlevleri kullanabilirsiniz</emphasis>.
    </para><para>
<note><title>Taşınabilirlik Bilgisi:</title><para>POSIX.1b, <command>mlock</command>
ve <command>munlock</command> işlevleri kullanılabilir olduğunda, <command>_POSIX_MEMLOCK_RANGE</command> makrosunun <filename>unistd.h</filename> dosyasında ve bir bellek sayfasının bayt cinsinden boyu olan  <command>PAGESIZE</command> makrosunun <filename>limits.h</filename> dosyasında tanımlanmasını gerektirir.  Ayrıca, <command>mlockall</command> ve <command>munlockall</command> işlevleri kullanılabilir olduğunda, <command>_POSIX_MEMLOCK</command> makrosunun <filename>unistd.h</filename> dosyasında tanımlanmasını gerektirir. GNU C kütüphanesi bu gereksinimleri karşılar.</para></note>
    </para><para id="glibc-mlock">
<indexterm scope="glibc-fn"><primary>mlock</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>mlock</command></funcdef>
<paramdef>(const void *<varname>adres</varname>,
 size_t      <varname>uzunluk</varname>)</paramdef>
</funcprototype><funcdescr><para>
<varname>adres</varname> adresinden başlayan <varname>uzunluk</varname> bayt uzunluğundaki sanal sayfa aralığını kilitler. Aslında, sayfaları bir bütün olarak kilitlemeniz gerektiğinden belirtilen aralıktaki parçaları içeren sayfaların bir aralığıdır.
      </para><para>
İşlev başarılı olarak dönerse, bu sayfaların her biri bir gerçek bellek çerçevesi tarafından (kalıcı olarak)  kopyalanır (çerçevelenir) ve kalıcı olarak imlenir.  Bu, işlevin sayfayı gerçek belleğe kopyalaması ve orada kalmasına sebep olması demektir.
      </para><para>
İşlev başarısız olursa, sayfaların kilitlenme durumu etkin olmaz.
      </para><para>
İşlev başarılı olduğunda dönen değer sıfırdır. Aksi takdirde, <command>-1</command> döner ve <command>errno</command> ilgili hata değerine ayarlanır. Bu işleve özel <command>errno</command> değerleri:
      </para><para>
        <variablelist><varlistentry><term><literal>ENOMEM</literal></term>
          <listitem><para>
            <itemizedlist><listitem><para>
Belirtilen adres aralığının en azından bir kısmı çağrılan sürecin sanal adres aralığında mevcut değildir.
            </para></listitem><listitem><para>
Kilitleme, sürecin kilitli sayfa sınırının aşılmasına sebep olacaktır.
            </para></listitem></itemizedlist>
          </para></listitem>
        </varlistentry><varlistentry><term><literal>EPERM</literal></term>
          <listitem><para>Süreci çağıran süper kullanıcı değildir.
          </para></listitem>
        </varlistentry><varlistentry><term><literal>EINVAL</literal></term>
          <listitem><para><varname>uzunluk</varname> pozitif değildir.
          </para></listitem>
        </varlistentry><varlistentry><term><literal>ENOSYS</literal></term>
          <listitem><para>
Çekirdek <command>mlock</command> yeteneği sağlamıyor.
          </para></listitem>
        </varlistentry></variablelist>
      </para><para>
Bir sürecin <varname>tüm</varname> belleğini <command>mlockall</command> ile kilitleyebilir ve <command>munlock</command> ya da  <command>munlockall</command> ile kilitlerini açabilirsiniz.
      </para><para>
Bir C yazılımında sayfalama hatalarından kaçınmak için <command>mlockall</command> işlevini kullanmalısınız, çünkü bir yazılımın kullandığı belleğin bir kısmı örneğin, yığıt ve özdevinimli değişkenler C kodundan gizlidir ve hangi adrese <command>mlock</command> deneceğini bilmeyeceksiniz.
</para></funcdescr></funcsynopsis></para><para id="glibc-munlock">
<indexterm scope="glibc-fn"><primary>munlock</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>munlock</command></funcdef>
<paramdef>(const void *<varname>adres</varname>,
 size_t      <varname>uzunluk</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>munlock</command> çağrılan sürecin sanal sayfalarının bir aralığının kilidini açar.
      </para><para>
<command>munlock</command> işlevi <command>mlock</command> işlevinin tersidir ve <command>EPERM</command> başarısızlığı söz konusu değildir.
</para></funcdescr></funcsynopsis></para><para id="glibc-mlockall">
<indexterm scope="glibc-fn"><primary>mlockall</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>mlockall</command></funcdef>
<paramdef>(int <varname>bayraklar</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>mlockall</command> bir sürecin sanal adres alanındaki ve/veya ilerde eklenecek tüm sayfaları kilitler. Bu alan, kod sayfalarını, veri ve yığıt bölütünü, paylaşımlı kütüphaneleri, kullanıcı alanı çekirdek verisini, paylaşımlı belleği ve bellek eşlemli dosyaları içerir.
      </para><para>
<varname>bayraklar</varname> aşağıdaki makrolarla ifade edilen tek bitlik  bayrakların bir dizgesidir. Bunlar <command>mlockall</command>'dan istediğiniz işlevselliği belirtmek için kullanılır. Tüm diğer bitler sıfır olmalıdır.
      </para><para>
        <variablelist><varlistentry><term><literal>MCL_CURRENT</literal></term>
          <listitem><para>
Çağrılan sürecin sanal adres alanında o an mevcut olan tüm sayfalar kilitlenir.
          </para></listitem>
        </varlistentry><varlistentry><term><literal>MCL_FUTURE</literal></term>
          <listitem><para>
Sürecin sanal adres alanına gelecekte doğumundan itibaren eklenecek sayfaların kilitlenmesini sağlayacak kipi etkinleştirir. Bu kip aynı süreç tarafından sahiplenilecek alt süreçlerin gelecekteki adres alanları üzerinde etkili değildir. Örneğin süreç bir <command>exec</command> çağrısı ile bir alt süreç çalıştırırsa bu kip, bu alt sürecin sayfaları için etkisizdir. Bkz.  <xref linkend="glibc-Executing-a-File"/>.
          </para></listitem>
        </varlistentry></variablelist>
      </para><para>
İşlev <command>MCL_CURRENT</command> bayrağıyla çağrılır ve başarılı  olarak dönerse, bu sayfaların her biri bir gerçek bellek çerçevesi tarafından (kalıcı olarak)  kopyalanır (çerçevelenir) ve kalıcı olarak imlenir.  Bu, işlevin sayfayı gerçek belleğe
 kopyalanmasına ve orada kalmasına sebep olması demektir.
      </para><para>
Süreç <command>MCL_FUTURE</command> kipindeyse bu işlev başarılı olduğundan dolayıdır ve <command>MCL_CURRENT</command> belirtildiğinde, süreç tarafından sanal bellek alanına alan eklenmesini gerektiren bir sistem çağrısıyla ek alanın kilitlenmesi sürecin kilitli sayfa sınırının aşılmasına sebep oluyorsa işlev <command>errno</command> = <command>ENOMEM</command> hatasıyla başarısız olur. Bu durumda adres alanı eklemesi yığıt genişletmesi ile bağdaştırılamaz ve yığıt genişlemesi başarısız olur, bunun sonucunda da çekirdek sürece bir <command>SIGSEGV</command> sinyali gönderir.
      </para><para>
İşlev başarısız olduğunda, kilitli sayfaların durumu ve gelecektekileri kilitleme kipi bundan etkinemez.
      </para><para>
İşlev başarılı olduğunda dönen değer sıfırdır. Aksi takdirde, <command>-1</command> döner ve <command>errno</command> ilgili hata değerine ayarlanır. Bu işleve özel <command>errno</command> değerleri:
      </para><para>
        <variablelist><varlistentry><term><command>ENOMEM</command></term>
          <listitem><para>
            <itemizedlist><listitem><para>
Belirtilen adres aralığının en azından bir kısmı çağrılan sürecin  sanal adres aralığında mevcut değildir.
            </para></listitem><listitem><para>
Kilitleme, sürecin kilitli sayfa sınırının aşılmasına sebep olacaktır.
            </para></listitem></itemizedlist>
          </para></listitem>
        </varlistentry><varlistentry><term><literal>EPERM</literal></term>
          <listitem><para>Süreci çağıran süper kullanıcı değildir.
          </para></listitem>
        </varlistentry><varlistentry><term><literal>EINVAL</literal></term>
          <listitem><para>
<varname>bayraklar</varname> içinde belirtilmeyen bitler sıfır değil.
          </para></listitem>
        </varlistentry><varlistentry><term><literal>ENOSYS</literal></term>
          <listitem><para>
Çekirdek <command>mlockall</command> yeteneği sağlamıyor.
          </para></listitem>
        </varlistentry></variablelist>
      </para><para>
Belirli sayfaları <command>mlock</command> ile kilitleyebilirsiniz. Kilitli sayfalardan ise <command>munlockall</command> ve <command>munlock</command> ile kilitleri kaldırabilirsiniz.
</para></funcdescr></funcsynopsis></para><para id="glibc-munlockall">
<indexterm scope="glibc-fn"><primary>munlockall</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>munlockall</command></funcdef>
<paramdef>(void)</paramdef>
</funcprototype><funcdescr><para>
Çağrılan sürecin sanal adres alanındaki her sayfanın kilidini kaldırır ve <command>MCL_FUTURE</command> gelecekteki kilitleme kipini kapatır.
      </para><para>
İşlev başarılı olduğunda dönen değer sıfırdır. Aksi takdirde, <command>-1</command> döner ve <command>errno</command> ilgili hata değerine ayarlanır. Sadece, tüm işlev ve sistem çağrılarının başarısız olabildiği soysal sebeplerle işlev başarısız olursa bu duruma özel bir <command>errno</command> değeri yoktur.
      </para></funcdescr></funcsynopsis></para></sect1>
  </chapter>
</part>
