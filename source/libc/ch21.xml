<?xml version="1.0" encoding="UTF-8"?>
<!-- ********************************************************************
     $Id: ch21.xml,v 1.2 2002/12/20 22:29:48 nilgun Exp $
******************************************************************** -->
<!-- TERİMLER
continuum: süreklilik
interval: zaman aralığı
elapsed time: süre
amount of time: toplam süre
period: dönem
CPU time: işlemci zamanı
Processor time: işlemci süresi
calendar time: mutlak zaman
-->
<part id="glibc-Date-and-Time">
  <title>Tarih ve Zaman</title>
  <titleabbrev>Tarih ve saati öğrenmek ve biçimlemek için kullanılan işlevler.</titleabbrev>
  <partintro><para>
Bu oylumda tarihler, saatler yani zamanla ilgili, zamanı saptamak, değiştirmek ve zaman gösterimleri arasında dönüşüm gibi işlemleri gerçekleştiren işlevlerden bahsedilecektir.
  </para></partintro>
  <chapter id="glibc-Time-Basics">
    <title>Zaman Kavramları</title>
    <titleabbrev>Kavramlar ve tanımlar.</titleabbrev>
    <para>
<dicterm><english>continuum</english><turkish>süreklilik</turkish></dicterm>
<dicterm><english>interval</english><turkish>zaman aralığı</turkish></dicterm>
<dicterm><english>elapsed time</english><turkish>süre</turkish></dicterm>
<dicterm><english>amount of time</english><turkish>toplam süre</turkish></dicterm>
<dicterm><english>CPU time (glibc)</english><turkish>işlemci zamanı</turkish></dicterm>
<dicterm><english>processor time (glibc)</english><turkish>işlemci süresi</turkish></dicterm>
<dicterm><english>calendar time (glibc)</english><turkish>mutlak zaman</turkish></dicterm>
<indexterm scope="glibc-cp"><primary>zaman</primary></indexterm>
"Time" sözcüğü ingilizcede çok fazla anlama geldiğinden bir teknik kılavuzda zamanı tartışmak zor olabilir (Ç.N.:Katlanacağız <literal>:-)</literal>).
   </para><para>
"Takvim zamanı" zamanın sürekliliği içinde bir noktayı ifade eder, örneğin: 4 Kasım 1990 18:02.5 UTC. Buna genellikle <wordasword>mutlak zaman</wordasword>  denir.
<indexterm scope="glibc-cp"><primary>mutlak zaman</primary></indexterm>
Buna "tarih" demiyoruz, çünkü tarih mutlak zamanın doğasında var.
<indexterm scope="glibc-cp"><primary>tarih</primary></indexterm>
Bir <wordasword>zaman aralığı</wordasword> zamanın sürekliliği içinde iki mutlak zaman arasındaki kesintisiz parçadır. Örnek: 4 Temmuz 1980 tarihinde saat 9:00 ile 10:00 arası.
<indexterm scope="glibc-cp"><primary>zaman aralığı</primary></indexterm>
<wordasword>Süre</wordasword> bir aralığın uzunluğudur. Örnek: 35 dakika.
<indexterm scope="glibc-cp"><primary>süre</primary></indexterm>
   </para><para>
<wordasword>Toplam süre</wordasword>, adı üstünde, sürelerin toplamıdır. Örnek: Parça parça okunan bir kitabın toplam okuma süresi 9 saattir, gibi.
   </para><para>
<wordasword>Dönem</wordasword> sürekli belirli aralıklarla yinelenen iki olay arasındaki süredir.
<indexterm scope="glibc-cp"><primary>dönem</primary></indexterm>
   </para><para>
<wordasword>İşlemci zamanı</wordasword> mutlak zaman gibidir, bir farkla zamanın başlangıcı, bir sürecin işlemciyi kullanmaya başladığı andır. İşlemci zamanı bu nedenle sürece bağlıdır.
<indexterm scope="glibc-cp"><primary>işlemci zamanı</primary></indexterm>
   </para><para>
<wordasword>İşlemci süresi</wordasword> ise işlemcinin kullanım süresidir.
Temel bir sistem özkaynağıdır. Çok işlemcili sistemlerde bir işlemcinin ne kadar süreyle işlem yapacağını belirten süredir.
<indexterm scope="glibc-cp"><primary>işlemci süresi</primary></indexterm>
  </para></chapter>
  <chapter id="glibc-Elapsed-Time">
    <title>Süre</title>
    <titleabbrev>Süre gösterimi ile ilgili veri türleri</titleabbrev>
    <para>
<indexterm scope="glibc-cp"><primary>süre</primary></indexterm>
Süreyi göstermenin tek yolu basit bir aritmetik veri türünü kullanmaktır. Aşağıdaki işlev iki mutlak zaman arasındaki süreyi hesaplar. Bu işlev <filename>time.h</filename> başlık dosyasında tanımlanmıştır.
   </para><para>
<indexterm scope="glibc-fn"><primary>difftime</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-difftime">
<funcdef>double <command>difftime</command></funcdef>
<paramdef>(time_t <varname>zaman1</varname>,
 time_t <varname>zaman0</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>difftime</command> işlevi <varname>zaman1</varname> ve time <varname>zaman0</varname> mutlak zamanları arasındaki süreyi <command>double</command> türünde saniye cinsinden bir değer olarak hesaplar. Artık süre desteği etkinleştirilmedikçe farkın artık süresi yoksayılır.
   </para><para>
GNU sisteminde, <command>time_t</command> değerleri arasında basitçe bir çıkarma işlemi yapabilirsiniz. Fakat diğer sistemlerde <command>time_t</command> başka bir kodlamaya karşılık olabileceğinden doğrudan çıkarma işlemi ile doğru sonuç alınamayabilir.
</para></funcdescr></funcsynopsis></para><para>
GNU C kütüphanesinde özellikle süreyi ifade edebilen iki veri türü vardır. Bunlar çeşitli kütüphane işlevlerince kullanılmıştır ve siz de amaçlarınıza uygun olarak bunları kullanabilirsiniz. İkisi de aslında aynı olmakla birlikte biri saniye cinsinden bir çözünürlük içinken diğeri nanosaniye cinsinden bir çözünürlük içindir.
   </para><para>
<indexterm scope="glibc-tp"><primary sortas="timeval">struct timeval</primary></indexterm>
<indexterm scope="glibc-cp"><primary>timeval</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü" id="glibc-struct-timeval">
<funcdef>struct <command>timeval</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
<literal>struct </literal><command>timeval</command> yapısı süreyi göstermekte kullanılır. <filename>sys/time.h</filename> başlık dosyasında bildirilmiş olan yapı şu üyelere sahiptir:
   </para><para><glosslist><glossentry><glossterm>
   <literal>long int <command>tv_sec</command></literal>
   </glossterm><glossdef><para>
Sürenin tam saniyelerden oluşan kısmını içerir (ondalık ayracın solundaki kısım).
   </para></glossdef></glossentry><glossentry><glossterm>
   <literal>long int <command>tv_usec</command></literal>
   </glossterm><glossdef><para>
Sürenin saniyeden küçük kısmını (ondalık ayracın sağındaki kısım) mikrosaniye cinsinden içerir. Daima bir milyondan küçüktür.
    </para></glossdef></glossentry></glosslist>
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-tp"><primary sortas="timespec">struct timespec</primary></indexterm>
<indexterm scope="glibc-cp"><primary>timespec</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü" id="glibc-struct-timespec">
<funcdef>struct <command>timespec</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
<literal>struct </literal><command>timespec</command> yapısı süreyi göstermekte kullanılır. <filename>time.h</filename> başlık dosyasında bildirilmiş olan yapı şu üyelere sahiptir:
   </para><para><glosslist><glossentry><glossterm>
   <literal>long int <command>tv_sec</command></literal>
   </glossterm><glossdef><para>
Sürenin tam saniyelerden oluşan kısmını içerir (ondalık ayracın solundaki kısım).
   </para></glossdef></glossentry><glossentry><glossterm>
   <literal>long int <command>tv_nsec</command></literal>
   </glossterm><glossdef><para>
Sürenin saniyeden küçük kısmını (ondalık ayracın sağındaki kısım) nanosaniye cinsinden içerir. Daima bir milyardan küçüktür.
   </para></glossdef></glossentry></glosslist></para><para>
Çoğunlukla <command>struct timeval</command> veya <command>struct timespec</command> türündeki iki değeri birbirinden çıkarmak gerekir. Burada en iyi yol budur.  <command>tv_sec</command> üyesinin veri türünün işaretsiz veri türlerinden biri olduğu kendine özgü işletim sistemlerinde bile bu çalışır.
   </para><para>
<screen>
/* `struct timeval' değerleri olan X ve Y arasında çıkarma yap
    ve sonucu RESULT içinde sakla.
    Fark negatifse 1 ile değilse 0 ile dön.  */

int
timeval_subtract (result, x, y)
      struct timeval *result, *x, *y;
{
  /* Elde 1 diyelim. */
  if (x->tv_usec &lt; y->tv_usec) {
    int nsec = (y->tv_usec - x->tv_usec) / 1000000 + 1;
    y->tv_usec -= 1000000 * nsec;
    y->tv_sec += nsec;
  }
  if (x->tv_usec - y->tv_usec > 1000000) {
    int nsec = (x->tv_usec - y->tv_usec) / 1000000;
    y->tv_usec += 1000000 * nsec;
    y->tv_sec -= nsec;
  }

  /* Şimdi hesaplayalım. tv_usec kesinlikle pozitif. */
  result->tv_sec = x->tv_sec - y->tv_sec;
  result->tv_usec = x->tv_usec - y->tv_usec;

  /* Sonuç negatifse 1 dönsün. */
  return x->tv_sec &lt; y->tv_sec;
}
</screen></para></funcdescr></funcsynopsis></para><para>
<command>struct timeval</command> kullanan işlevler <command>gettimeofday</command> ve <command>settimeofday</command> işlevleridir.
   </para><para>
Doğrudan özellikle sürelerle çalışan hiçbir GNU C kütüphanesi işlevi olmamakla birlikte, mutlak zaman, işlemci süresi, alarm ve uyku ile ilgili işlevler sürelerle ilgili birşeyler yaparlar.
   </para></chapter>
  <chapter id="glibc-Processor-And-CPU-Time">
    <title>İşlemci Zamanı ve İşlemci Süresi</title>
    <titleabbrev>Bir yazılımın çalışması ile ilgili zaman ve süreler.</titleabbrev>
    <para>
Bir yazılımı eniyilemeye ya da verimliliğini ölçmeye çalışıyorsanız, ne kadar işlemci süresi kullanıldığını bilmek iyidir. Bunun için, mutlak zaman ve süreler kullanışsızdır, çünkü bir süreç işlemciyi kullanırken arada bazı G/Ç işlemlerini veya başka süreçleri bekleyebilir. Buna karşın, bu bölümdeki işlevleri kullanarak işlemci kullanımı ile ilgili bilgi alabilirsiniz.
   </para><para>
İşlemci zamanı (bkz. <xref linkend="glibc-Time-Basics"/>), <wordasword>saat tikleri</wordasword>'nin sayısı olarak <command>clock_t</command> türünde bir veridir. İşlemci bazı keyfî ancak belli başlı olaylarda kullanıldığından bir sürecin işlemciyi etkin olarak kullandığı sürelerin toplamı hesaplanabilir. GNU sistemlerinde sürecin oluşturulması böyle bir olaydır. Keyfîlik yanında genelde, sürecin belli bir parçası için olay daima aynı olaydır, bu durumda işlemci zamanını hesaplamanın başlangıcında ve bitişinde saptayarak belli bir hesaplama için ne kadar işlemci süresi kullanıldığı ölçülebilir.
   </para><para>
<indexterm scope="glibc-cp"><primary>işlemci zamanı</primary></indexterm>
<indexterm scope="glibc-cp"><primary>saat tikleri</primary></indexterm>
GNU sisteminde, <command>clock_t</command> ile <command>long int</command> eşdeğerdir ve <command>CLOCKS_PER_SEC</command> bir tamsayı değerdir. Fakat diğer sistemlerde, <command>clock_t</command> ve <command>CLOCKS_PER_SEC</command> birer tamsayı ya da birer gerçek sayı türü olabilir. Önceki bölümdeki örnekte olduğu gibi, işlemci zamanı değerlerinin <command>double</command>'a yükseltgenmesi, aritmetik ve gösterim işlemlerinin düzgün olarak yapılmasını sağlarken sistemlerin olası farklı türlerdeki gösterimlerinden etkilenmemesini de sağlar.
   </para><para>
Saat tikleri sayısının, sayı türlerinin genişliklerine bağlı olarak belli bir sınırı olduğunu unutmayın. <command>CLOCKS_PER_SEC</command>'in bir milyon olarak atandığı 32 bitlik bir sistemde bu işlev yaklaşık 72 dakikada bir aynı değeri döndürecektir.
   </para><para>
Bir sürecin kullandığı işlemci süresini incelemek ve denetlemek için de işlevler vardır, bunlar hakkında <xref linkend="glibc-Resource-Usage-And-Limitation"/> bölümünde bilgi verilmiştir.
   </para>
  <sect1 id="glibc-CPU-Time">
    <title>İşlemci Zamanının Sorgulanması</title>
    <titleabbrev><command>clock</command> işlevi.</titleabbrev>
    <para>
Bir sürecin işlemci zamanını almak için <command>clock</command> işlevini kullanabilirsiniz. Bu oluşum <filename>time.h</filename> başlık dosyasında bildirilmiştir.
<indexterm scope="glibc-pg"><primary>time.h</primary></indexterm>
    </para><para>
Genel olarak, <command>clock</command> işlevi ilgilenilen bir zaman aralığının başında ve sonunda çağrılır ve bu değerler birbirinden çıkarılıp sonuç <command>CLOCKS_PER_SEC</command> ile bölünerek işlemci süresi aşağıdaki gibi elde edilir:
    </para><para>
<screen>#include &lt;time.h>

clock_t start, end;
double cpu_time_used;

start = clock();
... /* Burada bir takım işlemler yapılıyor. */
end = clock();
cpu_time_used = ((double) (end - start)) / CLOCKS_PER_SEC;
</screen></para><para>
Belirli süreyi elde etmek için tek bir işlemci zamanı değerini kullanmayın.<footnote><para>Ç.N.: Süre, iki mutlak zaman değeri arasındaki miktardır, zaman ise belli bir olaya göreli olarak tanımlanmış bir başlangıca göre geçen süredir; "miladi zaman", "hicri zaman", Uzay Yolu'nu izlediyseniz kaptanın günlüğünde bahsettiği "yıldız zamanı" <literal>:-)</literal>  gibi.</para></footnote> Ya yukarıdaki gibi bir çıkartma işlemi yapın ya da doğrudan işlemci süresini sorgulayın. Bkz. <xref linkend="glibc-Processor-Time"/>.
    </para><para>
Farklı makineler ve işletim sistemlerinde işlemci zamanının hesabı az ya da çok çılgıncadır. Bunlarda, dahili işlemci saati saniyenin yüzde biri ile milyonda biri arasında bir çözünürlüğe sahiptir.
    </para><para>
<indexterm scope="glibc-vr"><primary>CLOCKS_PER_SEC</primary></indexterm>
<funcsynopsis><funcprototype role="makro" id="glibc-CLOCKS_PER_SEC">
<funcdef>int <command>CLOCKS_PER_SEC</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu makronun değeri <command>clock</command> işlevi tarafından ölçülen saniyedeki saat tiki sayısını verir. POSIX standardı bu değerin gerçek çözünürlükten bağımsız olarak bir milyon olmasını gerektirir.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-vr"><primary>CLK_TCK</primary></indexterm>
<funcsynopsis><funcprototype role="makro" id="glibc-CLK_TCK">
<funcdef>int <command>CLK_TCK</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu, <command>CLOCKS_PER_SEC</command> değerinin atıl olmuş eşdeğeridir.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-tp"><primary>clock_t</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü" id="glibc-clock_t">
<funcdef><command>clock_t</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu, <command>clock</command> işlevinin dönüş değerinin türüdür. <command>clock_t</command> türünden değerler saat tiklerinin sayısıdır.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>clock</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-clock">
<funcdef>clock_t <command>clock</command></funcdef>
<paramdef>(void)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev çağrıldığı sürecin o anki işlemci zamanı ile döner. İşlemci zamanı ölçülmüyorsa ya da gösterilemiyorsa, <command>clock</command> işlevi <command>clock_t</command> cinsinden <command>(-1)</command> ile döner.
    </para></funcdescr></funcsynopsis></para></sect1>
    <sect1 id="glibc-Processor-Time">
      <title>İşlemci Süresinin Sorgulanması</title>
      <titleabbrev><command>times</command> işlevi.</titleabbrev>
      <para>
<command>times</command> işlevi bir sürecin harcadığı işlemci süresi ile ilgili bilgileri, <link linkend="glibc-Time-Basics">işlemci zamanına</link> ek olarak <command>struct tms</command> cinsinden bir nesne olarak döndürür. Bu oluşum  <filename>sys/times.h</filename> başlık dosyasında bildirilmiştir.
<indexterm scope="glibc-cp"><primary>işlemci süresi</primary></indexterm>
<indexterm scope="glibc-cp"><primary>işlemci zamanı</primary></indexterm>
<indexterm scope="glibc-pg"><primary>sys/times.h</primary></indexterm>
      </para><para>
<indexterm scope="glibc-tp"><primary sortas="tms">struct tms</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü" id="glibc-struct-tms">
<funcdef>struct <command>tms</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
<command>tms</command> yapısı bir sürecin harcadığı işlemci süresi ile ilgili bilgileri döndürmek için kullanılır. En azından şu üyelere sahip olmalıdır:
    </para><para><glosslist><glossentry><glossterm>
    <literal>clock_t <command>tms_utime</command></literal>
    </glossterm><glossdef><para>
Çağrıldığı sürecin çalıştırdığı komutların harcadığı toplam işlemci süresidir.
    </para></glossdef></glossentry><glossentry><glossterm>
    <literal>clock_t <command>tms_stime</command></literal>
    </glossterm><glossdef><para>
Çağrıldığı sürece "sistem" tarafından harcanan işlemci süresidir.
    </para></glossdef></glossentry><glossentry><glossterm>
    <literal>clock_t <command>tms_cutime</command></literal>
    </glossterm><glossdef><para>
Çağrıldığı sürecin sonlandırılmış alt süreçlerinin harcadığı <command>tms_utime</command> ve <command>tms_cutime</command> sürelerinin toplamıdır. Sonlandırılmış alt süreçlerin durumu sürece <command>wait</command> veya <command>waitpid</command> ile raporlandığından (bkz. <xref linkend="glibc-Process-Completion"/>), bu değer <command>wait</command> veya <command>waitpid</command> ile raporlanmamış süreleri içermez.
<indexterm scope="glibc-cp"><primary>child process</primary></indexterm>
    </para></glossdef></glossentry><glossentry><glossterm>
    <literal>clock_t <command>tms_cstime</command></literal>
    </glossterm><glossdef><para>
Çağrıldığı sürecin sonlandırılmış alt süreçleri için "sistemin" harcadığı işlemci süresini göstermesi dışında <command>tms_cutime</command> gibidir.
    </para></glossdef></glossentry></glosslist></para><para>
Tüm süreler saat tikleri cinsinden verilmiştir. İşlemci zamanının tersine, bunlar bir olaya göreli olmayan birer süre gösterirler. Bkz. <xref linkend="glibc-Creating-a-Process"/>.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>times</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-times">
<funcdef>clock_t <command>times</command></funcdef>
<paramdef>(struct tms *<varname>tampon</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>times</command> işlevi kendisini çağıran sürecin işlemci süresi ile ilgili bilgileri <varname>tampon</varname> içinde saklar.
    </para><para>
İşlevin dönüş değeri çağrıldığı sürecin işlemci zamanıdır. Başarısızlık durumunda işlev  <command>(clock_t)(-1)</command> ile döner.
</para></funcdescr></funcsynopsis></para><para>
<note><title>Taşınabilirlik Bilgisi</title><para><xref linkend="glibc-CPU-Time"/> bölümünde anlatılan <command>clock</command> işlevi ISO C standardında belirtilmiştir. GNU sisteminde işlemci zamanı <command>times</command> tarafından döndürülen yapının <command>tms_utime</command> ve <command>tms_stime</command> alanlarındaki değerlerin toplamı olarak tanımlanmıştır.</para></note>
    </para></sect1></chapter>

<chapter id="glibc-Calendar-Time">
  <title>Mutlak Zaman</title>
  <titleabbrev>"Gerçek" tarih ve zamanlarla çalışma.</titleabbrev>
  <para>
Bu kısımda <link linkend="glibc-Time-Basics">mutlak zaman</link>'ın hesabı ile ilgili oluşumlara yer verilmiştir.
   </para><para>
GNU C kütüphanesinde mutlak zaman üç türlü gösterilir:
   </para><para><itemizedlist><listitem><para>
<wordasword>Basit zaman</wordasword> (<command>time_t</command> veri türü) gerçeklemeye özgü bir başlangıç zamanına göre geçen sürenin saniye cinsinden bir gösterimidir.
<indexterm scope="glibc-cp"><primary>basit zaman</primary></indexterm>
    </para></listitem><listitem><para>
Bir de <wordasword>yüksek çözünürlüklü zaman</wordasword> gösterimi vardır.  Basit zamandaki gibi, bir başlangıca göre geçen süre olarak gösterilmesine rağmen ölçülen değer saniye cinsinden değil, saniyenin kesirlerini de içeren <command>struct timeval</command> türünde bir veridir.  Basit zamana göre daha yüksek bir çözünürlüğe ihtiyacınız olursa bu zaman gösterimini kullanın.
<indexterm scope="glibc-cp"><primary>yüksek çözünürlüklü zaman</primary></indexterm>
    </para></listitem><listitem><para>
<wordasword>Yerel zaman</wordasword> veya <wordasword>bozuk zaman</wordasword><footnote id="glibc-Calendar-Time_fn1"><para>Jülyen takviminde M.S. 1582 de Papa III. Gergory zamanında Ekim'in 5'i ile 15'i arasındaki günler takvimlerden çıkarılmış ve bu suretle bozuk zaman düzeltilerek artık yılları hesaba karan Gregoryen takvimi oluşturulmuştur. Bu takvim ilk olarak 1752'de İngiliz ve Amerikan kolonilerinde uygulanmaya başlamıştır. Bu bakımdan eksik günlerin kimse farkına varmamıştır <literal>:))</literal>. Halen bu sistemi kullanmaktayız.
<indexterm scope="glibc-cp"><primary>Gregoryen takvimi</primary></indexterm>
<indexterm scope="glibc-cp"><primary>Jülyen takvimi</primary></indexterm>
</para></footnote> (<command>struct tm</command> veri türü) belirli bir zaman dilimi için zaman birimlerinin yıl, ay, gün v.s. olarak belirtildiği bir zaman gösterimidir. Bu zaman gösterimi sadece insanlar arası iletişimde kullanılır.
<indexterm scope="glibc-cp"><primary>yerel zaman</primary></indexterm>
<indexterm scope="glibc-cp"><primary>bozuk zaman</primary></indexterm>
    </para></listitem></itemizedlist></para>
  <sect1 id="glibc-Simple-Calendar-Time">
    <title>Basit Zaman</title>
    <titleabbrev>Mutlak zamanla çalışılan oluşumlar.</titleabbrev>
    <para>
Bu bölümde mutlak zamanı basit zaman olarak göstermekte kullanılan <command>time_t</command> veri türü ile basit zaman nesneleri üzerinde işlem yapan işlevlerden bahsedilecektir. Bu oluşumlar <filename>time.h</filename> başlık dosyasında bildirilmiştir.
<indexterm scope="glibc-pg"><primary>time.h</primary></indexterm>
<indexterm scope="glibc-cp"><primary>mutlak zaman başlangıcı [İng: epoch]</primary></indexterm>
    </para><para>
<indexterm scope="glibc-tp"><primary>time_t</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü" id="glibc-time_t">
<funcdef><command>time_t</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu basit zaman gösteriminde kullanılan veri türüdür. Kimi zaman, bir süreyi de belirttiği olur. Bir mutlak zaman değeri olarak yorumlandığında, Koordinatlı Evrensel Zamana (UTC ya da GMT denen şey) göre, 1 Ocak 1970, saat 00:00:00'dan beri geçen saniye sayısını gösterir. (Mutlak zaman başlangıcına ingilizcede "epoch" deniyor.<footnote><para>Mutlak zaman başlangıcı (epoch), sistemden sisteme değişiklik gösterir. Unix için belirtildiği gibi 1 Ocak 1970, 00:00:00 GMT iken; VMS için 17 Kasım 1858, 00:00:00; Macintosh için 1 Ocak 1904 geceyarısıdır.</para></footnote> POSIX standardının bu sayının artık saniyeleri içermemesini gerektirmesine rağmen bazı sistemlerde <command>TZ</command> ilgili değere ayarlanırsa artık saniyeler de dahil edilir. (Bkz. <xref linkend="glibc-TZ-Variable"/>).
    </para><para>
Basit zamanın yerel zaman dilimleri kavramı ile ilgisi yoktur. Mutlak zamanın, bilgisayarınızın dünyanın neresinde olduğuna bakılmaksızın aynı değeri göstereceğini unutmayın.
    </para><para>
GNU C kütüphanesinde, <command>time_t</command> ile <command>long int</command> türleri eşdeğerdir. Başka sistemlerde ise, <command>time_t</command> bir tamsayı tür olabildiği gibi gerçek sayı türlerinden biri ile de eşdeğer olabilir.
</para></funcdescr></funcsynopsis></para><para>
<command>difftime</command> işlevi iki basit mutlak zaman arasında geçen süreyi  verir ve bu sonuç her zaman bir çıkarma işleminin sonucu değildir. Bkz. <xref linkend="glibc-Elapsed-Time"/>.
    </para><para>
<indexterm scope="glibc-fn"><primary>time</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-time">
<funcdef>time_t <command>time</command></funcdef>
<paramdef>(time_t *<varname>sonuç</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>time</command> işlevi, o anki mutlak zamanı <command>time_t</command> türünde bir değer olarak döndürür. <varname>sonuç</varname> bir boş gösterici değilse bu değer ayrıca <varname>*sonuç</varname> içinde saklanır. O anki mutlak zaman alınamıyorsa işlev <command>(time_t)(-1)</command> ile döner.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>stime</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-stime">
<funcdef>int <command>stime</command></funcdef>
<paramdef>(time_t *<varname>yenizaman</varname>)</paramdef>
</funcprototype><funcdescr><para>
<indexterm scope="glibc-fn"><primary>stime</primary></indexterm>
<command>stime</command> sistem saatini ayarlar. <varname>yenizaman</varname>, yukarıda <command>time_t</command> tanımında açıklandığı gibi yorumlanarak sistem zamanı bu değere ayarlanır.
    </para><para>
<command>settimeofday</command> işlevi ise sistem zamanını bir saniyeden daha hassas bir çözünürlükle ayarlamak için tasarlanmış daha yeni bir işlevdir. <command>settimeofday</command> işlevi genellikle <command>stime</command> işlevine göre daha iyi bir seçimdir. Bkz. <xref linkend="glibc-High-Resolution-Calendar"/>.
    </para><para>
Sistem saatini sadece süper kullanıcı (<literal>root</literal>) ayarlayabilir.
    </para><para>
Eğer işlev başarılı olursa sıfır değeri ile döner. Aksi takdirde, <command>-1</command> ile döner ve  <command>errno</command> değişkenine şu değer atanır:
    </para><para><variablelist><varlistentry>
    <term><literal>EPERM</literal></term><listitem><para>
Sistem saatini sadece süper kullanıcı ayarlayabilir.
    </para></listitem></varlistentry></variablelist>
  </para></funcdescr></funcsynopsis></para></sect1>
  <sect1 id="glibc-High-Resolution-Calendar">
    <title>Yüksek Çözünürlüklü Zaman</title>
    <titleabbrev>Zamanın daha büyük çözünürlükle gösterilmesi.</titleabbrev>
    <para>
<command>time_t</command> veri türü basit zamanları bir saniyelik hassasiyet ile göstermekte kullanılır. Bazı uygulamalarda ise daha yüksek hassasiyet gerekir.
    </para><para>
Bu nedenle, GNU C kütüphanesi mutlak zamanı bir saniyeden daha yüksek hassasiyetle hesaplayabilen işlevler de içerir. Bu bölümde bahsi geçen veri türleri ve işlevler  <filename>sys/time.h</filename> başlık dosyasında bildirilmiştir.
<indexterm scope="glibc-pg"><primary>sys/time.h</primary></indexterm>
    </para><para>
<indexterm scope="glibc-tp"><primary sortas="timezone">struct timezone</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü" id="glibc-struct-timezone">
<funcdef>struct <command>timezone</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
<command>struct timezone</command> yapısı yerel zaman dilimi ile ilgili mümkün olan en az bilgiyi saklamak için kullanılır. Şu üyelere sahiptir:
   </para><para><glosslist><glossentry><glossterm>
   <literal>int <command>tz_minuteswest</command></literal>
   </glossterm><glossdef><para>
UTC'nin batısındaki dakika sayısıdır.
   </para></glossdef></glossentry><glossentry><glossterm>
   <literal>int <command>tz_dsttime</command></literal>
   </glossterm><glossdef><para>
Sıfırdan farklıysa, yılın belli bir döneminde yaz saati uygulanır.
   </para></glossdef></glossentry></glosslist></para><para>
<command>struct timezone</command> türü artık atıl olmuştur ve asla kullanılmamalıdır. Buradaki bu veri türü ile ilgili oluşumlar yerine, <xref linkend="glibc-Time-Zone-Functions"/> bölümünde anlatılan oluşumlar kullanılmalıdır.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>gettimeofday</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-gettimeofday">
<funcdef>int <command>gettimeofday</command></funcdef>
<paramdef>(struct timeval  *<varname>zaman</varname>,
 struct timezone *<varname>zamandilimi</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>gettimeofday</command> işlevi, mutlak zaman başlangıcından beri geçen süreyi <varname>zaman</varname> ile gösterilen <command>struct timeval</command> yapısı ile döndürür. Zaman dilimi bilgisi ise <varname>zamandilimi</varname> ile gösterilen yapı içinde döner. <varname>zamandilimi</varname> bir boş gösterici olarak verilmişse, zaman dilimi bilgisi yoksayılır.
    </para><para>
Eğer işlev başarılı olursa sıfır değeri ile döner. Aksi takdirde, <command>-1</command> ile döner ve  <command>errno</command> değişkenine şu değer atanır:
    </para><para><variablelist><varlistentry>
    <term><literal>ENOSYS</literal></term><listitem><para>
İşletim sistemi zaman dilimi bilgisinin alınmasını desteklemiyor. GNU işletim sistemi zaman dilimi gösteriminde 4.3 BSD'nin atıl bir özelliği olan <command>struct timezone</command> kullanımını desteklemez. Bunun yerine  <xref linkend="glibc-Time-Zone-Functions"/> bölümünde açıklanan oluşumları kullanın.
       </para></listitem></varlistentry></variablelist>
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>settimeofday</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-settimeofday">
<funcdef>int <command>settimeofday</command></funcdef>
<paramdef>(const struct timeval  *<varname>zaman</varname>,
 const struct timezone *<varname>zamandilimi</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>settimeofday</command> işlevi sistem saatini argümanlarındaki değerlerle ayarlar. <command>gettimeofday</command> işlevindeki gibi mutlak zaman, mutlak zaman başlangıcından (epoch) beri geçen süre olarak ifade edilirken zaman dilimi bilgisi de <varname>zamandilimi</varname> bir boş gösterici ise yoksayılır.
    </para><para>
<command>settimeofday</command> işlevini kullanırken süper kullanıcı olmak zorundasınız.
    </para><para>
Bazı çekirdekler sistem saatini donanım saati gibi bir kaynaktan açılış sırasında ayarlar. Linux gibi diğerleri ise, sistem saatini "geçersiz" bir duruma getirir (saat okunmaya çalışılır ve başarısız olur). Sistem başlatma betikleri ile yapılan bir <command>stime</command> çağrısı ile sistem saati geçersiz durumdan çıkarılır.
    </para><para>
<command>settimeofday</command> işlevi, sistem saatinin beklenmedik şekilde ileri ya da geri kalmasına ve sistemde çeşitli sorunlar çıkmasına sebep olur. Sistem saatini geçici olarak hızlandırarak ya da yavaşlatarak bir zamandan diğerine yumuşak bir geçiş yapmak için aşağıdaki <command>adjtime</command> işlevini kullanın.
    </para><para>
Linux çekirdeği ile, <command>adjtimex</command> işlevi aynı şeyi yapar, ayrıca sistem saatinin hızında kalıcı değişiklikler yaparak sık sık düzeltme yapma ihtiyacını ortadan kaldırır.
    </para><para>
Eğer işlev başarılı olursa sıfır değeri ile döner. Aksi takdirde, <command>-1</command> ile döner ve  <command>errno</command> değişkenine şu değer atanır:
    </para><para><variablelist><varlistentry>
    <term><literal>EPERM</literal></term><listitem><para>
Yetkileri yetersiz olduğundan bu süreç saati ayarlayamaz.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>ENOSYS</literal></term><listitem><para>
<varname>zamandilimi</varname> bir boş gösterici değil ama işletim sistemi zaman dilimi bilgisi ayarını desteklemiyor.
       </para></listitem></varlistentry></variablelist>
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>adjtime</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-adjtime">
<funcdef>int <command>adjtime</command></funcdef>
<paramdef>(const struct timeval *<varname>delta</varname>,
 struct timeval       *<varname>eskidelta</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev sistem saatini aşamalı olarak hızlandırır ya da yavaşlatır. Böyle ayarlanan sistem saati mutlak zamanı düzenli bir artışla gösterir. Saatin ayarını basitçe değiştirirseniz bu böyle olmaz.
    </para><para>
<varname>delta</varname> argümanı bir göreli ayar belirtir. Negatifse belirtilen süre tamamlanıncaya kadar saat yavaşlatılır, pozitifse hızlandırılır.
    </para><para>
<varname>eskidelta</varname> argümanı bir boş gösterici değilse, işlev henüz tamamlanmamış olan ayarın önceki ayar bilgisi ile döner.
    </para><para>
Bu işlev genellikle sistem saatini yerel ağın saati ile eşzamanlamak için kullanılır. İşlevi kullanabilmek için yetkili kullanıcı olmalısınız.
    </para><para>
Linux çekirdeği ile saat hızını kalıcı olarak değiştirmek için <command>adjtimex</command> işlevini kullanabilirsiniz.
    </para><para>
Eğer işlev başarılı olursa sıfır değeri ile döner. Aksi takdirde, <command>-1</command> ile döner ve  <command>errno</command> değişkenine şu değer atanır:
    </para><para><variablelist><varlistentry>
    <term><literal>EPERM</literal></term><listitem><para>
Saati ayarlamak için yetkileriniz yetersiz.
       </para></listitem></varlistentry></variablelist>
</para></funcdescr></funcsynopsis></para><para>
<note><title>Taşınabilirlik Bilgisi</title><para><command>gettimeofday</command>, <command>settimeofday</command> ve <command>adjtime</command> işlevleri BSD'den alınmıştır.</para></note>
    </para><para>
Aşağıdaki işlevle ilgili semboller <filename>sys/timex.h</filename> başlık dosyasında bildirilmiştir.
    </para><para>
<indexterm scope="glibc-fn"><primary>adjtimex</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-adjtimex">
<funcdef>int <command>adjtimex</command></funcdef>
<paramdef>(struct timex *<varname>timex</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>adjtimex</command> işlevi <command>ntp_adjtime</command> işlevi ile aynıdır. Bkz. <xref linkend="glibc-High-Accuracy-Clock"/>.
    </para><para>
Bu işlev sadece Linux çekirdeği ile kullanılabilir.
  </para></funcdescr></funcsynopsis></para></sect1>
  <sect1 id="glibc-Broken-down-Time">
    <title>Yerel Zaman</title>
    <titleabbrev>Yerel zamanla ilgili işlevler.</titleabbrev>
    <para>
<indexterm scope="glibc-cp"><primary>yerel zaman</primary></indexterm>
<indexterm scope="glibc-cp"><primary>mutlak zaman</primary><secondary>yerel zaman</secondary></indexterm>
Mutlak zaman, GNU C kütüphanesi işlevleri tarafından sabit bir mutlak zamanı başlangıç kabul ederek bu zamandan itibaren geçen süre olarak ifade edilir. Bu hesaplama açısından uygun olmakla birlikte, insanları düşündüğü takvim zamanıyla ilişkilendirilmesinin bir yolu yoktur. Tersine olarak <wordasword>yerel zaman</wordasword>, mutlak zamanın yıl, ay, gün, v.s. şeklinde ayrık bir ikilik gösterimidir. Yerel zaman değerleri hesaplama için elverişli olmadığı halde zaman bilgisini insanların okuyabileceği biçimde ifade etmek için elverişlidir.
    </para><para>
Bir yerel zaman değeri daima zaman dilimi seçimine göredir ve ayrıca zaman dilimi de belirtilir.
    </para><para>
Bu bölümdeki semboller <filename>time.h</filename> başlık dosyasında bildirilmiştir.
    </para><para>
<indexterm scope="glibc-tp"><primary sortas="tm">struct tm</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü" id="glibc-struct-tm">
<funcdef>struct <command>tm</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu veri türü bir yerel zamanı ifade etmek için kullanılır. Yapı, farklı sıralamayla da olsa en azından aşağıdaki üyeleri içermelidir:
   </para><para><glosslist><glossentry><glossterm>
   <literal>int <command>tm_sec</command></literal>
   </glossterm><glossdef><para>
Bu üye bir dakikadan küçük tam saniyelerin sayısıdır (normalde <command>0</command>'dan <command>59</command>'a kadar olmakla birlikte gerçek üst sınır, eğer artık saniye desteği varsa artık saniyeleri de ifade edebilmek için <command>60</command> saniyedir).
<indexterm scope="glibc-cp"><primary>leap second</primary></indexterm>
   </para></glossdef></glossentry><glossentry><glossterm>
   <literal>int <command>tm_min</command></literal>
   </glossterm><glossdef><para>
Bu üye bir saatten küçük tam dakikaların sayısıdır (<command>0</command>'dan <command>59</command>'a kadar).
   </para></glossdef></glossentry><glossentry><glossterm>
   <literal>int <command>tm_hour</command></literal>
   </glossterm><glossdef><para>
Bu üye geceyarısından itibaren geçen tam saatlerin sayısıdır (<command>0</command>'dan <command>23</command>'e kadar).
   </para></glossdef></glossentry><glossentry><glossterm>
   <literal>int <command>tm_mday</command></literal>
   </glossterm><glossdef><para>
Bu üye ayın gününü ifade eden bir sayıdır (<command>1</command>'den <command>31</command>'e kadar). Dikkat edin!, yapıdaki sıradan bir sayı olarak, bu üye yapının kalanı ile bağdaşmaz.
   </para></glossdef></glossentry><glossentry><glossterm>
   <literal>int <command>tm_mon</command></literal>
   </glossterm><glossdef><para>
Yılın başlangıcından itibaren tam ayların sayısıdır (<command>0</command>'dan <command>11</command>'e kadar). Dikkat edin!, normalde insanlar ilk ayın (Ocak ayı) numarası olarak 1'i kullanırlar.
   </para></glossdef></glossentry><glossentry><glossterm>
   <literal>int <command>tm_year</command></literal>
   </glossterm><glossdef><para>
Bu, 1900'den beri  geçen tam yılların sayısıdır.
   </para></glossdef></glossentry><glossentry><glossterm>
   <literal>int <command>tm_wday</command></literal>
   </glossterm><glossdef><para>
Bu, hafta başından (Pazar) beri geçen tam günlerin sayısıdır (<command>0</command>'dan <command>6</command>'ya kadar).
   </para></glossdef></glossentry><glossentry><glossterm>
   <literal>int <command>tm_yday</command></literal>
   </glossterm><glossdef><para>
Bu, yılın başından beri geçen tam gün sayısıdır (<command>0</command>'dan<command>365</command>'e kadar).
   </para></glossdef></glossentry><glossentry><glossterm id="glibc-struct-tm_isdst">
   <literal>int <command>tm_isdst</command></literal>
<indexterm scope="glibc-cp"><primary>yaz saati uygulaması</primary></indexterm>
   </glossterm><glossdef><para>
Bu yaz saati uygulamasının geçerli olup olmadığını gösterir. Değer pozitifse uygulanacak, sıfırsa uygulanmayacak, negatifse hiç yaz saati uygulaması yapılmıyor demektir.
   </para></glossdef></glossentry><glossentry><glossterm>
   <literal>long int <command>tm_gmtoff</command></literal>
   </glossterm><glossdef><para>
Yerel zamanı hesaplamakta kullanılan zaman dilimini belirtir. Yaz saati uygulamasını da içererek, UTC'ye göre saniye sayısını içerir. Bu üyenin değerini UTC'nin doğusundaki saniye sayısı olarak da düşünebilirsiniz. Örneğin, Türkiye için bu değer normalde <command>2*60*60</command>, yaz saati uygulaması yapılan dönemde ise <command>3*60*60</command> saniyedir. Yapının <command>tm_gmtoff</command> üyesi BSD'den alınmıştır, bir GNU kütüphanesi oluşumudur; kesin ISO C uyumluluğu istenen ortamda görülmez.
   </para></glossdef></glossentry><glossentry><glossterm>
   <literal>const char *<command>tm_zone</command></literal>
   </glossterm><glossdef><para>
Yerel zamanı hesaplamakta kullanılan zaman diliminin ismidir. Yapının bu üyesi de BSD'den alınmıştır, bir GNU kütüphanesi oluşumudur; kesin ISO C uyumluluğu istenen ortamda görülmez.
   </para></glossdef></glossentry></glosslist>
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>localtime</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-localtime">
<funcdef>struct tm *<command>localtime</command></funcdef>
<paramdef>(const time_t *<varname>zaman</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>localtime</command> işlevi, <varname>zaman</varname> ile belirtilen basit zamanı, kullanıcının belirtilmiş zaman dilimine göre ifade edilen yerel zaman gösterimine dönüştürür.
    </para><para>
Dönüş değeri bir durağan yerel zaman yapısına bir göstericidir ve yapı içeriği sonraki <command>ctime</command>, <command>gmtime</command> veya <command>localtime</command> çağrılarıyla değişebilecektir. (Kütüphanede bu nesnenin içeriğini değiştirebilen başka işlev yoktur.)
    </para><para>
<varname>zaman</varname>, bir yerel zaman olarak ifade edilemiyorsa dönüş değeri bir boş göstericidir; bu, genellikle yıl değeri <command>int</command> türüne sığmazsa ortaya çıkar.
    </para><para>
<command>localtime</command> çağrısı bir etkiye daha sahiptir: <command>tzname</command> değişkenine o anki zaman dilimi bilgisi ile ilintili bir değer atar. Bkz. <xref linkend="glibc-Time-Zone-Functions"/>.
</para></funcdescr></funcsynopsis></para><para>
<command>localtime</command> işlevi çok evreli yazılımlarda büyük bir soruna yolaçar. Sonuç bir durağan tamponda döndüğünden bu tüm evreler tarafından kullanılamaz. POSIX.1c'de bu işlevin çok evreli kullanımına yönelik bir benzerinden bahsedilir.
    </para><para>
<indexterm scope="glibc-fn"><primary>localtime_r</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-localtime_r">
<funcdef>struct tm *<command>localtime_r</command></funcdef>
<paramdef>(const time_t *<varname>zaman</varname>,
 struct tm    *<varname>sonuç</varname>)</paramdef>
</funcprototype><funcdescr><para>
The <command>localtime_r</command> işlevi, <command>localtime</command> işlevi gibi çalışır. Bir basit zaman içeren bir değişkene gösterici alır ve onu yerel zaman gösterimine dönüştürür.
    </para><para>
Ancak, sonuç durağan bir tampona yerleştirilmez. <varname>sonuç</varname> parametresi ile gösterilen <command>struct tm</command> türündeki bir nesneye yerleştirilir.
    </para><para>
Dönüşüm başarılı olursa işlev, sonucun yazıldığı nesneye bir gösterici ile, yani <varname>sonuç</varname> ile döner.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>gmtime</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-gmtime">
<funcdef>struct tm *<command>gmtime</command></funcdef>
<paramdef>(const time_t *<varname>zaman</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev, yerel zamanı bir yerel zaman diliminden ziyade UTC'ye uyarlaması dışında <command>localtime</command> gibidir.
    </para><para>
<command>localtime</command> işlevinde olduğu gibi sonucun bir durağan değişkene atanması sebebiyle bu işlev de sorunludur. POSIX.1c <command>gmtime</command> işlevi yerine sorunsuz kullanılabilen bir benzerinden bahseder.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>gmtime_r</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-gmtime_r">
<funcdef>struct tm *<command>gmtime_r</command></funcdef>
<paramdef>(const time_t *<varname>zaman</varname>,
 struct tm    *<varname>sonuç</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev <command>localtime_r</command> işlevine benzemekle birlikte, <command>gmtime</command> gibi zamanı UTC'ye göre verilmiş gibi dönüştürür.
    </para><para>
Dönüşüm başarılı olursa işlev, sonucun yazıldığı nesneye bir gösterici ile, yani <varname>sonuç</varname> ile döner.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>mktime</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-mktime">
<funcdef>time_t <command>mktime</command></funcdef>
<paramdef>(struct tm *<varname>yerelzaman</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>mktime</command> işlevi, bir yerel zaman yapısını basit zaman gösterimine dönüştürmekte kullanılır. Ayrıca yerel zaman yapısının içeriğini, haftanın gününü ve yılın gününü diğer tarih ve zaman elemanlarına göre doldurarak "normalleştirir".
    </para><para>
<command>mktime</command> işlevi yapının <command>tm_wday</command> ve <command>tm_yday</command> üyelerini yoksayar. Mutlak zamanı saptamak için yapının diğer üyelerini kullanır. Bu nedenl yapının yoksayılan üyelerinde normaldışı değerlerin bulunması sorun oluşturmaz. <command>mktime</command> işlevi ayrıca <varname>yerelzaman</varname> yapısının elemanlarını da (<command>tm_wday</command> ve <command>tm_yday</command> dahil) ayarlar.
    </para><para>
Belirtilen yerel zaman bir basit zaman olarak gösterilemiyorsa işlev, <command>(time_t)(-1)</command> değeri ile döner ve <varname>yerelzaman</varname> ile gösterilen yapının içeriğine dokunmaz.
    </para><para>
<command>mktime</command> çağrısı ayrıca, <command>tzname</command> değişkenine o anki zaman dilimi bilgisi ile ilintili bir değer atar. Bkz. <xref linkend="glibc-Time-Zone-Functions"/>.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>timelocal</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-timelocal">
<funcdef>time_t <command>timelocal</command></funcdef>
<paramdef>(struct tm *<varname>yerelzaman</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>timelocal</command> işlevi <command>mktime</command> ile aynıdır, sadece, <command>localtime</command> işlevinin yaptığının tersini yaptığından ismi daha kolay hatırlanacak şekilde seçilmiştir.
    </para><para>
<note><title>Taşınabilirlik Bilgisi</title><para><command>mktime</command> işlevi özellikle evrensel anlamda geçerli olmakla birlikte <command>timelocal</command> daha az yaygındır.</para></note>
    </para><para>
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>timegm</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-timegm">
<funcdef>time_t <command>timegm</command></funcdef>
<paramdef>(struct tm *<varname>yerelzaman</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>timegm</command> işlevi girdi olarak yerel zaman dilimine bakılmaksızın UTC'ye göre bir değer alması dışında <command>mktime</command> işlevi gibidir.
    </para><para>
<command>timegm</command> işlevi, <command>gmtime</command> işlevinin yaptığının tersini yapar.
    </para><para>
<note><title>Taşınabilirlik Bilgisi</title><para><command>mktime</command> işlevi özellikle evrensel anlamda geçerli olmakla birlikte <command>timegm</command> daha az yaygındır. UTC zamanından basit zamana dönüşüm yapan çoğu taşınabilir işlev <command>TZ</command> ortam değişkenine UTC atar, <command>mktime</command> işlevi ise değişkene yerel zaman dilimini atar.</para></note>
  </para></funcdescr></funcsynopsis></para></sect1>
  <sect1 id="glibc-High-Accuracy-Clock">
    <title>Yüksek Doğrulukta Saat</title>
    <titleabbrev>Sistem saatinin doğruluğunun arttırılması.</titleabbrev>
    <para>
<indexterm scope="glibc-cp"><primary>zaman</primary><secondary>yüksek hassasiyet</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>saat</primary><secondary>yüksek doğruluk</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>yüksek hassasiyet</primary><secondary>zaman</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>yüksek doğruluk</primary><secondary>saat</secondary></indexterm>
<indexterm scope="glibc-pg"><primary>sys/timex.h</primary></indexterm>
<command>ntp_gettime</command> ve <command>ntp_adjtime</command> işlevleri doğruluğunu arttırmak amacıyla sistem saatini izlemek ve değiştirmek için bir arayüz sağlar. Örneğin, saat hızını daha iyi bir ayar için hızlandırabilir ya da başka bir kaynaktan saati ayarlayabilirsiniz.
    </para><para>
Bu işlevler özellikle çok sayıda sistemin saatini yüksek hassasiyetli bir saat kullanarak ayarlamak için ağ zaman protokolü (NTP - Network Time Protocol) ile gerçeklenmiş sunucular tarafından kullanılır.
    </para><para>
Bu işlevler <filename>sys/timex.h</filename> başlık dosyasında bildirilmiştir.
    </para><para>
<indexterm scope="glibc-tp"><primary sortas="ntptimeval">struct ntptimeval</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü" id="glibc-struct-ntptimeval">
<funcdef>struct <command>ntptimeval</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu yapı sistem saati ile ilgili bilgiler için kullanılır. Şu üyelere sahiptir:
   </para><para><glosslist><glossentry><glossterm>
   <literal>struct <command>timeval time</command></literal>
   </glossterm><glossdef><para>
Mutlak zaman başlangıcından (epoch) itibaren geçen süre olarak ifade edilen, o anki mutlak zamandır. <command>struct timeval</command> veri türü <xref linkend="glibc-Elapsed-Time"/> bölümünde açıklanmıştır.
   </para></glossdef></glossentry><glossentry><glossterm>
   <literal>long int <command>maxerror</command></literal>
   </glossterm><glossdef><para>
Mikrosaniyeler cinsinden ölçülen en büyük hata miktarıdır. <command>ntp_adjtime</command> ile düzenli aralıklarla güncellenmedikçe, bu değer platforma özel en büyük değere ulaşacaktır.
   </para></glossdef></glossentry><glossentry><glossterm>
   <literal>long int <command>esterror</command></literal>
   </glossterm><glossdef><para>
Mikrosaniyeler cinsinde ölçülen tahmini hatadır. Bu değer gerçek mutlak zamandaki sistem saatinin tahmini ayar noktasını belirtmek için <command>ntp_adjtime</command> tarafından ayarlanabilir.
   </para></glossdef></glossentry></glosslist>
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>ntp_gettime</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-ntp_gettime">
<funcdef>int <command>ntp_gettime</command></funcdef>
<paramdef>(struct ntptimeval *<varname>tptr</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>ntp_gettime</command> işlevi <varname>tptr</varname> tarafından gösterilen yapıyı o anki değerlerle doldurur. Bundan sonra yapının elemanları çekirdeğin kabul ettiği zamanlayıcı gerçeklemesinin değerlerini içerir. Böyle değilse, bir <command>ntp_adjtime</command> çağrısı gerekir.
    </para><para>
Başarı durumunda dönüş değeri sıfır, aksi takdirde sıfırdan farklıdır. Aşağıdaki <command>errno</command> değeri bu işlev için atanmıştır:
    </para><para><variablelist><varlistentry>
    <term><literal>TIME_ERROR</literal></term><listitem><para>
Hassas saat modeli şu an için düzgün olarak ayarlanamadı; saat eşzamanlanmış kabul edilemediğinden bu değerleri dikkatli kullanmalısınız.
       </para></listitem></varlistentry></variablelist>
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-tp"><primary sortas="timex">struct timex</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü" id="glibc-struct-timex">
<funcdef>struct <command>timex</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu yapı sistem saatini izlemek ve denetlemek için kullanılır. Şu üyeleri içerir:
   </para><para><glosslist><glossentry><glossterm>
   <literal>unsigned int<command>modes</command></literal>
   </glossterm><glossdef><para>
Hangi kiplerin geçerli olduğunu belirtir. Etkin kip belirtmek için çeşitli sembolik sabitler "ikil veya"lanarak birleştirilebilir. Bu sabitler <command>MOD_</command> ile başlar.
   </para></glossdef></glossentry><glossentry><glossterm>
   <literal>long int <command>offset</command></literal>
   </glossterm><glossdef><para>
Gerçek mutlak zamandaki sistem saatinin o anki ayar noktasını belirtir. Değer mikrosaniye cinsindendir. <command>modes</command> üyesinde <command>MOD_OFFSET</command> biti varsa ayar noktası (ve olası başka bağımlı değerler) atanmış olabilir. Ayar noktasının mutlak değeri <command>MAXPHASE</command>'dan büyük olmamalıdır.
   </para></glossdef></glossentry><glossentry><glossterm>
   <literal>long int <command>frequency</command></literal>
   </glossterm><glossdef><para>
Gerçek mutlak zamanla sistem saati arasındaki farkı frekans olarak belirtir. Değer bir PPM oranıdır (milyonda birlik değerler, 0.0001%). Oranlama <command>1 &lt;&lt; SHIFT_USEC</command>'dir. Değer, <command>MOD_FREQUENCY</command> biti ile atanabilir, fakat <command>MAXFREQ</command> değerinden büyük olamaz.
   </para></glossdef></glossentry><glossentry><glossterm>
   <literal>long int <command>maxerror</command></literal>
   </glossterm><glossdef><para>
Mikrosaniyeler cinsinden ölçülen en büyük hata miktarıdır. Yeni bir değer <command>MOD_MAXERROR</command> biti kullanılarak atanabilir. <command>ntp_adjtime</command> ile düzenli aralıklarla güncellenmedikçe, bu değer platforma özel en büyük değere ulaşacaktır.
   </para></glossdef></glossentry><glossentry><glossterm>
   <literal>long int <command>esterror</command></literal>
   </glossterm><glossdef><para>
Mikrosaniyeler cinsinden ölçülen tahmini hata miktarıdır. Yeni bir değer <command>MOD_ESTERROR</command> biti kullanılarak atanabilir.
   </para></glossdef></glossentry><glossentry><glossterm>
   <literal>int <command>status</command></literal>
   </glossterm><glossdef><para>
Bu üye, saat çarkının çeşitli durumlarını gösterir. Bunlar önemli bitlerle ifade edilen sembolik sabitlerdir ve <command>STA_</command> ile başlarlar. Bu bitlerin bazıları <command>MOD_STATUS</command> biti kullanılarak güncellenebilir.
   </para></glossdef></glossentry><glossentry><glossterm>
   <literal>long int <command>constant</command></literal>
   </glossterm><glossdef><para>
Çekirdek içinde gerçeklenmiş PLL'in (phase locked loop - faz kilitlemeli çevrim) değişmezliğini ya da band genişliğini ifade eder. Bu değer <command>MOD_TIMECONST</command> biti kullanılarak değiştirilebilir.
   </para></glossdef></glossentry><glossentry><glossterm>
   <literal>long int <command>precision</command></literal>
   </glossterm><glossdef><para>
Sistem saati okumasındaki en büyük hatayı ya da doğruluğu ifade eder. Değer mikrosaniye cinsindendir.
   </para></glossdef></glossentry><glossentry><glossterm>
   <literal>long int <command>tolerance</command></literal>
   </glossterm><glossdef><para>
Sistem saatindeki en büyük frekans hatasını milyonda birlik değerler (PPM) olarak ifade eder. Bu değer <command>maxerror</command>'ü her saniyede bir arttırmakta kullanılır.
   </para></glossdef></glossentry><glossentry><glossterm>
   <literal>struct timeval <command>time</command></literal>
   </glossterm><glossdef><para>
O anki mutlak zamanı gösterir.
   </para></glossdef></glossentry><glossentry><glossterm>
   <literal>long int <command>tick</command></literal>
   </glossterm><glossdef><para>
Mikrosaniye cinsinden saat tikleri arasındaki süredir. Bir saat tiki sistem saatinin temel aldığı sürekli tekrarlanan bir zamanlayıcı kesmesidir.
   </para></glossdef></glossentry><glossentry><glossterm>
   <literal>long int <command>ppsfreq</command></literal>
   </glossterm><glossdef><para>
Sistem saatinin zapturapt altına alınması için saniyede bir darbelik (PPS) bir sinyalin kullanılması durumunda anlamlı olan bir kaç isteğe bağlı üyeden ilkidir. Değer milyonda birlik (PPM) bir oran olarak, sistem saati ile PPS sinyali arasındaki frekans farkını belirtir.
   </para></glossdef></glossentry><glossentry><glossterm>
   <literal>long int <command>jitter</command></literal>
   </glossterm><glossdef><para>
PPS sinyalindeki saçılmanın ortasına göre mikrosaniye cinsinden bir ortalamasıdır.
   </para></glossdef></glossentry><glossentry><glossterm>
   <literal>int <command>shift</command></literal>
   </glossterm><glossdef><para>
PPS kalibrasyon aralığının <command>PPS_SHIFT</command>'den <command>PPS_SHIFTMAX</command>'a kadar ikilik üstel değeridir.
   </para></glossdef></glossentry><glossentry><glossterm>
   <literal>long int <command>stabil</command></literal>
   </glossterm><glossdef><para>
PPS sinyalindeki ortasına göre saçılmanın milyonda birlik (PPM) oranıdır.
   </para></glossdef></glossentry><glossentry><glossterm>
   <literal>long int <command>jitcnt</command></literal>
   </glossterm><glossdef><para>
Seğirmenin (jitter) izin verilen en büyük değer olan <command>MAXTIME</command>'ı aştığında darbe sayısını gösteren bir sayaçtır.
   </para></glossdef></glossentry><glossentry><glossterm>
   <literal>long int <command>calcnt</command></literal>
   </glossterm><glossdef><para>
Başarılı kalibrasyon aralıklarının sayısını gösteren bir sayaçtır.
   </para></glossdef></glossentry><glossentry><glossterm>
   <literal>long int <command>errcnt</command></literal>
   </glossterm><glossdef><para>
Kalibrasyon hatalarının sayısını gösteren bir sayaçtır (hatalar çok geniş ayar aralıklarından ya da seğirmelerden kaynaklanır).
   </para></glossdef></glossentry><glossentry><glossterm>
   <literal>long int <command>stbcnt</command></literal>
   </glossterm><glossdef><para>
Kararlılık eşiği aşıldığında yapılan kalibrasyonların sayısını gösteren bir sayaçtır.
   </para></glossdef></glossentry></glosslist>
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>ntp_adjtime</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-ntp_adjtime">
<funcdef>int <command>ntp_adjtime</command></funcdef>
<paramdef>(struct timex *<varname>tptr</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>ntp_adjtime</command> işlevi <varname>tptr</varname> ile gösterilen yapıyı o anki değerlerle doldurur.
    </para><para>
Ek olarak, <command>ntp_adjtime</command> işlevi *<varname>tptr</varname> içinde aktardığınız değerlerle eşleşen bazı ayarları günceller. Güncellenecek ayarları belirtmek için *<varname>tptr</varname>'nin <command>modes</command> elemanı kullanılır. Bu yolla, <command>offset</command>, <command>freq</command>, <command>maxerror</command>, <command>esterror</command>, <command>status</command>, <command>constant</command> ve <command>tick</command> değerlerini güncelleyebilirsiniz.
    </para><para>
<command>modes</command> = sıfır ise hiçbir şey yapılmaz.
    </para><para>
Yalnız süper kullanıcı bu ayarları güncelleyebilir.
    </para><para>
Başarı durumunda dönüş değeri sıfır, aksi takdirde sıfırdan farklıdır. Aşağıdaki <command>errno</command> değerleri bu işlev için atanmıştır:
    </para><para><variablelist><varlistentry>
    <term><literal>TIME_ERROR</literal></term><listitem><para>
Hassas saat modeli şu an için düzgün olarak ayarlanamadı; saat eşzamanlanmış kabul edilemediğinden bu değerleri dikkatli kullanmalısınız. Başka bir sebep de izin verilmediği halde yeni değerlerin belirtilmesi olabilirdi.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>EPERM</literal></term><listitem><para>
Süreç bir ayarın güncellenmesini belirtiyor ama süper kullanıcı değil.
       </para></listitem></varlistentry></variablelist>
     </para><para>
Daha ayrıntılı bilgi için RFC1305 (Network Time Protocol, Version 3 [Ağ Zaman Protokolü, 3. sürüm]) ve onunla ilgili belgelere bakınız.
    </para><para>
<note><title>Taşınabilirlik Bilgisi</title><para>GNU C kütüphanesinin eski sürümlerinde bu işlev yoktu ama eşanlamlısı olan <command>adjtimex</command> işlevi vardı.</para></note>
  </para></funcdescr></funcsynopsis></para></sect1>
  <sect1 id="glibc-Formatting-Calendar-Time">
    <title>Zaman Değerlerinin Biçimlenmesi</title>
    <titleabbrev>Zaman değerlerinin dizgelere dönüştürülmesi.</titleabbrev>
    <para>
Bu bölümdeki mutlak zaman değerlerini dizgeler dönüştürerek biçimlendirmekte kullanılan işlevlerden bahsedilecektir. Bu işlevler <filename>time.h</filename> başlık dosyasında bildirilmiştir.
<indexterm scope="glibc-pg"><primary>time.h</primary></indexterm>
    </para><para>
<indexterm scope="glibc-fn"><primary>asctime</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-asctime">
<funcdef>char *<command>asctime</command></funcdef>
<paramdef>(const struct tm *<varname>yerelzaman</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>asctime</command> işlevi <varname>yerelzaman</varname> ile gösterilen yerel zaman değerini
    </para><para>
<screen>&quot;Sat Aug 28 13:49:43 2004\n&quot;</screen>
    </para><para>
standart biçimine dönüştürür. Bu işlevde kullanılan gün isimlerinin kısaltmaları: <command>Sun</command>, <command>Mon</command>, <command>Tue</command>, <command>Wed</command>, <command>Thu</command>, <command>Fri</command> ve <command>Sat</command>.
    </para><para>
Ay isimlerinin kısaltmaları: <command>Jan</command>, <command>Feb</command>, <command>Mar</command>, <command>Apr</command>, <command>May</command>, <command>Jun</command>, <command>Jul</command>, <command>Aug</command>, <command>Sep</command>, <command>Oct</command>, <command>Nov</command> ve <command>Dec</command>.
    </para><para>
Dönüş değeri bir durağan ayrılmış dizgeye göstericidir ve bu değer sonraki <command>asctime</command> veya <command>ctime</command> işlevleri ile değiştirilebilir. (Kütüphanede bu değeri değiştiren başka işlev yoktur.)
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>asctime_r</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-asctime_r">
<funcdef>char *<command>asctime_r</command></funcdef>
<paramdef>(const struct tm *<varname>yerelzaman</varname>,
 char            *<varname>tampon</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev <command>asctime</command> işlevine benzemekle birlikte, sonucu bir durağan ayrılmış tampona değil, <varname>tampon</varname> ile gösterilen tampona yazar. Bu tampon sonlandırıcı boş karakter dahil en az 26 baytlık bir yere sahip olmalıdır.
    </para><para>
Bir hata oluşmazsa işlev sonucun yazıldığı tampona bir gösterici ile yani <varname>tampon</varname> ile döner. Aksi takdirde <command>NULL</command> döner.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>ctime</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-ctime">
<funcdef>char *<command>ctime</command></funcdef>
<paramdef>(const time_t *<varname>zaman</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>ctime</command> işlevi argüman olarak bir yerel zaman değeri yerine basit zaman değeri alması dışında <command>asctime</command> işlevi gibidir.
    </para><para>
<screen>asctime (localtime (<varname>zaman</varname>))</screen>
    </para><para>
ile eşdeğerdir. <command>localtime</command> işlevi <command>tzname</command> değerini atadığından <command>ctime</command> işlevi de aynısını yapar. Bkz.  <xref linkend="glibc-Time-Zone-Functions"/>.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>ctime_r</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-ctime_r">
<funcdef>char *<command>ctime_r</command></funcdef>
<paramdef>(const time_t *<varname>zaman</varname>,
 char         *<varname>tampon</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev <command>ctime</command> işlevine benzemekle birlikte, sonucu bir durağan ayrılmış tampona değil, <varname>tampon</varname> ile gösterilen tampona yazar.
    </para><para>
<screen>({ struct tm tm; asctime_r (localtime_r (time, &amp;tm), buf); })</screen>
    </para><para>
ile eşdeğerdir (GCC oluşumları kullanılarak yazılmıştır). Bir hata oluşmazsa işlev sonucun yazıldığı tampona bir gösterici ile yani <varname>tampon</varname> ile döner. Aksi takdirde <command>NULL</command> döner.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>strftime</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-strftime">
<funcdef>size_t <command>strftime</command></funcdef>
<paramdef>(char            *<varname>dizge</varname>,
 size_t           <varname>boyut</varname>,
 const char      *<varname>şablon</varname>,
 const struct tm *<varname>yerelzaman</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bu işlev <command>sprintf</command> işlevine benzer (bkz. <xref  linkend="glibc-Formatted-Input"/>), fakat <varname>yerelzaman</varname> içindeki tarih ve saatin basılması için <varname>şablon</varname> biçim dizgesi <link linkend="glibc-Locales">o an belirtilmiş olan yerele özgü</link> zaman dönüşümlerinin yapılabilmesi için özelleştirilmiştir.
    </para><para>
<varname>şablon</varname> dizgesindeki belirteç olmayan karakterler <varname>dizge</varname> çıktı dizgesine oldukları gibi kopyalanırlar; Bu dizge çokbaytlı karakterleri de içerebilir. Dönüşüm belirteçleri bir <command>%</command> karakteri ile başlar ve bunu isteğe bağlı bir seçenek izler. Bu seçeneklerin hepsi GNU oluşumudur. İlk üçü sadece sayıların çıktılanması ile ilgilidir:
    </para><para><variablelist><varlistentry>
    <term><literal>_</literal></term><listitem><para>
Sayılar için ayrılan genişlikteki boş yerler boşlukla doldurulur.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>-</literal></term><listitem><para>
Sayılar için ayrılan genişlikteki boş yerler hiçbir şeyle doldurulmaz.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>0</literal></term><listitem><para>
Sayılar için ayrılan genişlikteki boş yerlerin boşlukla doldurulması belirtilmiş olsa bile sıfırlarla doldurulur.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>^</literal></term><listitem><para>
Çıktıda büyük harfler kullanılır, fakat bu sadece mümkün olabiliyorsa yapılır
(Bkz. <xref linkend="glibc-Case-Conversion"/>).
       </para></listitem></varlistentry></variablelist>
     </para><para>
Öntanımlı eylem sayılar için ayrılan genişliğin sıfırlarla doldurulmasıdır. Bir aralık dahilinde değişmeyen, dolayısıyla doğal bir genişliği olmayan sayılar için dolgu yapılmaz.
    </para><para>
Bundan sonra, genişlik belirtilmeyi mümkün kılan isteğe bağlı bir genişlik belirtimi gelir. Bu ondalık sayı gösterimi belirtir. Çıktılanan sayının karakter sayısı belirtilen genişlikten azsa sonuç sağa yanaştırılarak yazılırken soldaki alan boşluklarla doldurulur.
    </para><para>
Seçenek ve genişlik belirtiminden sonra isteğe bağlı bir değiştirici gelebilir. Değiştiriciler ilk olarak, POSIX.2-1992 ve ISO C99 standartları ile standartlaştırılmıştır:
    </para><para><variablelist><varlistentry>
    <term><literal>E</literal></term><listitem><para>
Tarih ve saat gösterimi için yerele özgü diğer gösterim kullanılır. Bu değiştirici <command>%c</command>, <command>%C</command>, <command>%x</command>, <command>%X</command>, <command>%y</command> ve <command>%Y</command> biçim belirteçlerine uygulanır. Japon yerelinde örneğin, <command>%Ex</command> Japon İmparator'unun hüküm sürdüğü çağa göre biçimlenmiş tarih olabilir.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>O</literal></term><listitem><para>
Sayılar için yerele özgü diğer sayısal semboller kullanılır. Bu değiştirici sadece sayısal biçim belirteçlerine uygulanır.
       </para></listitem></varlistentry></variablelist>
     </para><para>
Biçimde değiştirici desteği varsa ama yerelde diğer bir gösterim yoksa değiştirici yoksayılır.
    </para><para>
Dönüşüm belirteçleri biçim belirteçlerinden biri ile biter. Aşağıda <command>%</command> ile başlayan belirtimler ve çıktı dizgesinde nasıl yorumlandıkları liste halinde verilmiştir:
    </para><para><variablelist><varlistentry>
    <term><literal>%a</literal></term><listitem><para>
Yerele özgü kısaltılmış gün ismi.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>%A</literal></term><listitem><para>
Yerele özgü gün ismi.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>%b</literal></term><listitem><para>
Yerele özgü kısaltılmış ay ismi.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>%B</literal></term><listitem><para>
Yerele özgü ay ismi.
       </para><para>
<command>%B</command>'nin <command>%d</command> ile birlikte kullanımı bazı yerellerde imla kurallarına uygun olmayan sonuçlar üretir.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>%c</literal></term><listitem><para>
Yerele özgü tarih ve saat gösterimi.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>%C</literal></term><listitem><para>
Yılın yüzyılllık tam parçası (yüzyıl değeri değil). Yılın 100'e bölünmesi ile elde edilen sonucun tamsayı kısmıdır.
       </para><para>
Bu biçim ilk olarak POSIX.2-1992 ve ISO C99 tarafından standartlaştırılmıştır.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>%d</literal></term><listitem><para>
<command>01</command> ile <command>31</command> arasında bir değer olarak ayın gün numarası.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>%D</literal></term><listitem><para>
<command>%m/%d/%y</command> biçiminde tarih.
       </para><para>
Bu biçim ilk olarak POSIX.2-1992 ve ISO C99 tarafından standartlaştırılmıştır.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>%e</literal></term><listitem><para>
<command>1</command> ile <command>31</command> arasında bir değer olarak ayın gün numarası (tek rakamlı sayıların önüne 0 konmaz).
       </para><para>
Bu biçim ilk olarak POSIX.2-1992 ve ISO C99 tarafından standartlaştırılmıştır.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>%F</literal></term><listitem><para>
<command>%Y-%m-%d</command> biçimimde tarih.  Bu biçim ISO 8601 standardında belirtilmiştir ve  çok tercih edilen bir biçimdir.
       </para><para>
Bu biçim ilk olarak POSIX.2-1992 ve ISO C99 tarafından standartlaştırılmıştır.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>%g</literal></term><listitem><para>
<command>00</command> ile <command>99</command> arasında yılın yüzyıllık parçası olmaksızın yıl numarasıdır (örneğin, 1999 için 99, 2004 için 04). <command>%y</command> ile aynı biçim ve değerdedir, ancak ilk ve son ISO hafta numarası (bakınız <command>%V</command>) önceki ya da sonraki hangi yıla karşılıksa o yıla karşılık olan değer gösterilir.
       </para><para>
Bu biçim ilk olarak POSIX.2-1992 ve ISO C99 tarafından standartlaştırılmıştır.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>%G</literal></term><listitem><para>
<command>%Y</command> ile aynı biçim ve değerdedir, ancak ilk ve son ISO hafta numarası (bakınız <command>%V</command>) önceki ya da sonraki hangi yıla karşılıksa o yıla karşılık olan değer gösterilir.
       </para><para>
Bu biçim ilk olarak POSIX.2-1992 ve ISO C99 tarafından standartlaştırılmıştır. Fakat bir GNU oluşumu olarak evvelce de vardı.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>%h</literal></term><listitem><para>
<command>%b</command> ile aynıdır ve yerele özgü kısaltılmış ay ismidir.
       </para><para>
Bu biçim ilk olarak POSIX.2-1992 ve ISO C99 tarafından standartlaştırılmıştır.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>%H</literal></term><listitem><para>
<command>00</command> ile <command>23</command> arasında bir sayısal değer olarak 24 saatlik saat gösterimi.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>%I</literal></term><listitem><para>
<command>01</command> ile <command>12</command> arasında bir sayısal değer olarak 12 saatlik saat gösterimi.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>%j</literal></term><listitem><para>
<command>001</command> ile <command>366</command> arasında yılın gün numarası.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>%k</literal></term><listitem><para>
<command>0</command> ile <command>23</command> arasında bir sayısal değer olarak 24 saatlik saat gösterimi (tek rakamlı sayıların önüne 0 konmaz).
       </para><para>
Bu biçim bir GNU oluşumudur.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>%l</literal></term><listitem><para>
<command>1</command> ile <command>12</command> arasında bir sayısal değer olarak 12 saatlik saat gösterimi (tek rakamlı sayıların önüne 0 konmaz).
       </para><para>
Bu biçim bir GNU oluşumudur.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>%m</literal></term><listitem><para>
<command>01</command> ile <command>12</command> arasında ayın numarası.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>%M</literal></term><listitem><para>
<command>00</command> ile <command>59</command> arasında dakika değeri.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>%n</literal></term><listitem><para>
Tek bir <command>\n</command> (satırsonu) karakteri.
       </para><para>
Bu biçim ilk olarak POSIX.2-1992 ve ISO C99 tarafından standartlaştırılmıştır.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>%p</literal></term><listitem><para>
Verilen değere bağlı olarak yerele özgü <command>AM</command> veya <command>PM</command> dizgesidir. Öğleden önceki saatler için <command>AM</command> ile öğleden sonraki saatler için <command>PM</command> karşılığı olan yerele özgü dizge basılır. Bu dizgeleri desteklemeyen yerellerde <command>&quot;%p&quot;</command> bir boş dizgeye karşılıktır.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>%P</literal></term><listitem><para>
Verilen değere bağlı olarak yerele özgü <command>am</command> veya <command>pm</command> dizgesidir. Öğleden önceki saatler için <command>am</command> ile öğleden sonraki saatler için <command>pm</command> karşılığı olan yerele özgü dizge basılır. Bu dizgeleri desteklemeyen yerellerde <command>&quot;%p&quot;</command> bir boş dizgeye karşılıktır.
       </para><para>
Bu biçim bir GNU oluşumudur.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>%r</literal></term><listitem><para>
Yerele özgü AM/PM biçimli saat gösterimi (örn, 04:38:53 ÖS)
       </para><para>
Bu biçim ilk olarak POSIX.2-1992 ve ISO C99 tarafından standartlaştırılmıştır.  POSIX yerelinde, bu biçim <command>%I:%M:%S %p</command> biçim dizgesine eşdeğerdir.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>%R</literal></term><listitem><para>
<command>%H:%M</command> biçiminde saat ve dakika.
       </para><para>
Bu biçim ilk olarak POSIX.2-1992 ve ISO C99 tarafından standartlaştırılmıştır. Fakat bir GNU oluşumu olarak evvelce de vardı.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>%s</literal></term><listitem><para>
Mutlak zaman başlangıcından (epoch) yani 1970-01-01 00:00:00 UTC'den beri geçen saniye sayısı. Artık saniye desteği yoksa artık saniyeler hesaba katılmaz.
       </para><para>
Bu biçim bir GNU oluşumudur.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>%S</literal></term><listitem><para>
<command>00</command> ile <command>60</command> arasında saniye.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>%t</literal></term><listitem><para>
Tek bir <command>\t</command> (sekme) karateri.
       </para><para>
Bu biçim ilk olarak POSIX.2-1992 ve ISO C99 tarafından standartlaştırılmıştır.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>%T</literal></term><listitem><para>
<command>%H:%M:%S</command> biçiminde saat.
       </para><para>
Bu biçim ilk olarak POSIX.2-1992 ve ISO C99 tarafından standartlaştırılmıştır.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>%u</literal></term><listitem><para>
<command>1</command> ile <command>7</command> arasında haftadaki günün numarası. Pazartesi, haftanın birinci günüdür.
       </para><para>
Bu biçim ilk olarak POSIX.2-1992 ve ISO C99 tarafından standartlaştırılmıştır.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>%U</literal></term><listitem><para>
<command>00</command> ile <command>53</command> arasında hafta numarası. Yılın ilk Pazar günü ile başlayan hafta yılın ilk haftası sayılır ve <command>00</command> ile gösterilir.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>%V</literal></term><listitem><para>
<command>01</command> ile <command>53</command> arasında ISO 8601:1988 hafta numarası. ISO haftaları Pazartesi günü başlar, Pazar günü biter. Yılın <command>01</command>. haftası, günlerinin çoğunluğu yeni yıl içinde kalan ilk haftadır; örneğin, yılın ilk günü Perşembe ve son günü 4 Ocak olan hafta <command>01</command>. haftadır (7 günden 4'ü yeni yıl içinde). Yani, yılın <command>01</command>. haftası bir önceki yıldan da günler içerebileceği gibi bunun tersine <command>01</command>. haftadan önceki hafta yeni yıldan bir kaç gün içerse bile yılın son haftası (<command>52</command>. veya <command>53</command>. hafta) olabilir.
       </para><para>
Bu biçim ilk olarak POSIX.2-1992 ve ISO C99 tarafından standartlaştırılmıştır.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>%w</literal></term><listitem><para>
<command>0</command> ile <command>6</command> arasında haftadaki günün numarası. Pazar, haftanın sıfırıncı günüdür.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>%W</literal></term><listitem><para>
<command>00</command> ile <command>53</command> arasında hafta numarası. Yılın ilk Pazartesi günü ile başlayan hafta yılın ilk haftası sayılır ve <command>00</command> ile gösterilir.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>%x</literal></term><listitem><para>
Yerele özgü kısa tarih gösterimi.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>%X</literal></term><listitem><para>
Yerele özgü saat gösterimi.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>%y</literal></term><listitem><para>
<command>00</command> ile <command>99</command> arasında yılın yüzyıllık parçası olmaksızın yıl numarasıdır (örneğin, 1999 için 99, 2004 için 04).
       </para></listitem></varlistentry><varlistentry>
       <term><literal>%Y</literal></term><listitem><para>
Gregoryen takvimine göre yıl. <command>1</command>. yıldan önceki yıllar <command>0</command>, <command>-1</command>, <command>-2</command> diye gider.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>%z</literal></term><listitem><para>
RFC 822/ISO 8601:1988 tarzı zaman dilimi (örn, <command>+0300</command> veya <command>-0600</command>); zaman dilimi saptanamazsa hiçbir şey basılmaz.
       </para><para>
Bu biçim ilk olarak POSIX.2-1992 ve ISO C99 tarafından standartlaştırılmıştır. Fakat bir GNU oluşumu olarak evvelce de vardı.
       </para><para>
POSIX yerelinde, bir RFC 822 tam tarih ve saat <command>&quot;%a, %d %b %Y %H:%M:%S %z&quot;</command> (veya <command>&quot;%a, %d %b %Y %T %z&quot;</command> eşdeğeri) biçimindedir.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>%Z</literal></term><listitem><para>
Zaman dilimi kısaltması (örn, EEST); saptanamazsa boş dizge.
       </para></listitem></varlistentry><varlistentry>
       <term><literal>%%</literal></term><listitem><para>
Tek bir <command>%</command> karakteri.
       </para></listitem></varlistentry></variablelist>
     </para><para>
<varname>boyut</varname> parametresi <varname>dizge</varname> dizisi içinde sonlandırıcı boş karakter dahil saklanabilecek karakterlerin sayısı kadar ya da daha büyük olmalıdır. Biçimlenen zaman dizgesi <varname>boyut</varname> karakterden fazla ise <command>strftime</command> sıfır ile döner ve <varname>dizge</varname> dizisi tanımsız bırakılır. Aksi takdirde işlev <varname>dizge</varname> dizisine yerleştirilen karakter sayısı ile döner, bu sayıya sonlandırıcı boş karakter dahil değildir.
    </para><para>
<warning><para>Dönüş değeri için ISO C'de açıklanan bu uzlaşım bazı durumlarda sorunlara yol açabilir. Bazı yerellerde bazı biçim dizgeleri gerçekten de boş dizge çıktılar ve bu durum dönüş değerine bakarak saptanamaz. Örneğin çoğu yerel AM/PM biçimini kullanmaz (çoğu ülkede 24 saatlik biçim kullanılır) ve bu yerellerde boş dizge çıktılanır, bu durumda işlevin dönüş değeri sıfır olur. Buna benzer bir durumu saptamak için şöyle bir kod kullanılmalıdır:
    </para><para>
<screen>
buf[0] = '\1';
len = strftime (buf, bufsize, format, tp);
if (len == 0 &amp;&amp; buf[0] != '\0')
  {
    /* strftime çağrısında birşeyler yanlış gitmiş.  */
    ...
  }
</screen></para></warning></para><para>
<varname>dizge</varname> bir boş gösterici ise, <command>strftime</command> hiçbir yazma işlemi yapmaz, ama <varname>dizge</varname>'ye yazılmış gibi karakterlerin sayısı ile döner.
    </para><para>
POSIX.1 gereğince her <command>strftime</command> çağrısı bir <command>tzset</command> çağrısına sebep olur. Bu durumda, herhangi bir çıktı üretilmeden önce <command>TZ</command> ortam değişkeninin içeriği incelenebilir.
    </para><para>
Bir <command>strftime</command> örneği <xref linkend="glibc-Time-Functions-Example"/> bölümünde verilmiştir.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>wcsftime</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-wcsftime">
<funcdef>size_t <command>wcsftime</command></funcdef>
<paramdef>(wchar_t         *<varname>dizge</varname>,
 size_t           <varname>boyut</varname>,
 const wchar_t   *<varname>şablon</varname>,
 const struct tm *<varname>yerelzaman</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>wcsftime</command> işlevi geniş karakter dizgeleriyle çalışması dışında <command>strftime</command> işleviyle aynıdır. Sonucun saklandığı <varname>dizge</varname> bir geniş karakter dizisi olmalıdır. <varname>boyut</varname> parametresi ile bayt sayısı değil, geniş karakter sayısı belirtilir.
    </para><para>
Ayrıca <varname>şablon</varname> biçim dizgesi de bir geniş karakterli dizgedir.
Biçim dizgesindeki tüm karakterlerin temel karakter kümesindeki karakterler olması gerektiğinden taşınabilirlik açısından C kaynak kodunda biçim dizgesi  <command>L&quot;…&quot;</command> sözdizimi ile yazılmalıdır. <varname>yerelzaman</varname> parametresi <command>strftime</command> çağrısındaki ile aynı anlamdadır.
    </para><para>
<command>wcsftime</command> işlevi <command>strftime</command> işlevinin desteklediği tüm seçenekleri, değiştiricileri ve biçim belirteçlerini destekler.
    </para><para>
<command>wcsftime</command> işlevinin dönüş değeri <varname>dizge</varname> dizisine saklanan geniş karakterlerin sayısıdır. <varname>dizge</varname> çıktılanacak karakterler bakımından yetersizse işlev sıfır ile döner, ayrıca <command>strftime</command> işlevinin açıklamasında bahsedilen sorunlar burada da geçerlidir.
  </para></funcdescr></funcsynopsis></para></sect1>
  <sect1 id="glibc-Parsing-Date-and-Time">
    <title>Tarih ve Saatin Yerel Zamana Dönüştürülmesi</title>
    <titleabbrev>Metin biçimindeki tarih ve saatin tekrar yerel zaman değerine dönüştürülmesi.</titleabbrev>
    <para>
ISO C standardı <command>strftime</command> işlevinin çıktısının, girdisi olan ikilik biçime dönüştürülmesi için herhangi bir işlev belirtmemiştir. Bu, ilk yıllarda farklı arayüzlerin az ya da çok başarılı çeşitli gerçeklemeler geliştirmeleri ile sonuçlanmıştır. Bunların ardından Unix standardı iki ek işlev tanımladı: <command>strptime</command> ve <command>getdate</command>. Her ikisi de tuhaf arayüzlere sahip olmasına karşın geniş kullanım alanı bulmuştur.
    </para>
    <sect2 id="glibc-Low-Level-Time-String-Parsing">
      <title>Düşük Seviyede Çözümleme</title>
      <titleabbrev>Dizgenin belirtilen biçimle yorumlanması</titleabbrev>
      <para>
İlk işlev oldukça düşük seviyededir. Buna rağmen, iyi bilindiğinden yazılım geliştirirken sıklıkla kullnılır. Arayüzü ve gerçeklenmesi ağırlıkla, <command>strptime</command> çağrısı kurallarıyla tanımlanmış ve gerçeklenmiş olan <command>getdate</command> işlevinden etkilenmiştir.
     </para><para>
<indexterm scope="glibc-fn"><primary>strptime</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-strptime">
<funcdef>char *<command>strptime</command></funcdef>
<paramdef>(const char *<varname>dizge</varname>,
 const char *<varname>biçim</varname>,
 struct tm  *<varname>zaman</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>strptime</command> işlevi <varname>dizge</varname> dizgesini <varname>biçim</varname> dizgesine göre çözümleyerek sonucu <varname>zaman</varname> yapısına yazar.
     </para><para>
Girdi dizgesi <command>strftime</command> işleviyle ya da başka bir yöntemle üretilmiş olabilir. Girdi dizgesinin içeriğinin insanlar açısından anlamlı olması gerekmez, <varname>biçim</varname> dizgesi ile eşleşebilen herhangi bir dizge olabilir (örn, <command>&quot;02:1999:9&quot;</command>).
     </para><para>
Kullanıcı ne yaptığını bilmelidir, yoksa girdi saçma sapan çözümlenebilir. Örneğin <command>&quot;1999112&quot;</command> dizgesi <command>&quot;%Y%m%d&quot;</command> biçimi kullanılarak 1999-1-12, 1999-11-2 ve hatta 19991-1-2 olarak çözümlenebilir. Kararlı sonuçlar almak için girdi dizgesine uygun ayraçların eklenmesi gerekir.
     </para><para>
Biçim dizgesi, <command>strftime</command> işlevinin biçim dizgesinde kullanılan elemanlarla oluşturulur. Tek farkla; <command>_</command>, <command>-</command>, <command>0</command> ve <command>^</command> seçeneklerine izin verilmez. Girdide harf büyüklükleri gibi farklara bakılmadığından <command>strftime</command> işlevinin bazı belirli biçimleri bile <command>strptime</command>'da aynı işi yapar. İki işlev arasanıda bakışımın sağlanması için tüm biçimler desteklenmiştir.
     </para><para>
<command>E</command> ve <command>O</command> değiştiricilerine <command>strftime</command> işlevinin kullanılmasına izin verdiği her yerde izin verilmiştir.
     </para><para>
Biçimler şunlardır:
     </para><para><variablelist><varlistentry>
     <term><literal>%a</literal></term></varlistentry><varlistentry>
     <term><literal>%A</literal></term><listitem><para>
Yerele özgü kısaltılmış ya da tam gün ismi.
        </para></listitem></varlistentry><varlistentry>
        <term><literal>%b</literal></term></varlistentry><varlistentry>
        <term><literal>%B</literal></term></varlistentry><varlistentry>
        <term><literal>%h</literal></term><listitem><para>
Yerele özgü kısaltılmış ya da tam ay ismi.
        </para></listitem></varlistentry><varlistentry>
        <term><literal>%c</literal></term><listitem><para>
Yerele özgü tarih ve saat gösterimi.
        </para></listitem></varlistentry><varlistentry>
        <term><literal>%Ec</literal></term><listitem><para>
Yerele özgü diğer tarih ve saat biçimi olması dışında <command>%c</command> ile aynıdır.
        </para></listitem></varlistentry><varlistentry>
        <term><literal>%C</literal></term><listitem><para>
Yılın yüzyıllık parçası.
        </para><para>
Bu biçim, biçim dizgesi ayrıca bir <command>%y</command> biçimi içeriyorsa anlamlı olarak çözümlenir.
        </para></listitem></varlistentry><varlistentry>
        <term><literal>%EC</literal></term><listitem><para>
Yerele özgü dönem gösterimi.
        </para><para>
<command>%C</command>'den farklı olarak, bazı kültürlerde yıllar, Gregoryen yıllarına göreli bir yılı başlangıç yılı alarak gösterilebilmektedir.
        </para></listitem></varlistentry><varlistentry>
        <term><literal>%d</literal></term></varlistentry><varlistentry>
        <term><literal>%e</literal></term><listitem><para>
1 ile 31 arasında bir değer olarak ayın gün numarası (tek rakamlı sayıların önüne 0 konulsa da olur konulmasa da).
        </para></listitem></varlistentry><varlistentry>
        <term><literal>%Od</literal></term></varlistentry><varlistentry>
        <term><literal>%Oe</literal></term><listitem><para>
Yerele özgü diğer sayısal sembollerin kullanılması dışında <command>%d</command> ile aynıdır.
        </para><para>
Tek rakamlı sayıların önüne 0 konulsa da olur konulmasa da.
        </para></listitem></varlistentry><varlistentry>
        <term><literal>%D</literal></term><listitem><para>
<command>%m/%d/%y</command> biçimine eşdeğerdir.
        </para></listitem></varlistentry><varlistentry>
        <term><literal>%F</literal></term><listitem><para>
ISO 8601 tarih biçimi olan <command>%Y-%m-%d</command> ile eşdeğerdir.
        </para><para>
<command>strftime</command>'da ISO C99 oluşumu olan bir GNU oluşumudur.
        </para></listitem></varlistentry><varlistentry>
        <term><literal>%g</literal></term><listitem><para>
<command>00</command> ile <command>99</command> arasında yılın yüzyıllık parçası olmaksızın ISO hafta numarasına bağlı yıl numarasıdır.
        </para><para>
<note><para>Şimdilik tam olarak gerçeklenmemiştir. Biçim olarak tanınır ama <varname>tm</varname> yapısında ilgili alana birşey yazılmaz.</para></note>
        </para><para>
<command>strftime</command>'da da GNU oluşumu olan bir GNU oluşumudur.
        </para></listitem></varlistentry><varlistentry>
        <term><literal>%G</literal></term><listitem><para>
ISO hafta numarasına göre yıl.
        </para><para>
<note><para>Şimdilik tam olarak gerçeklenmemiştir. Biçim olarak tanınır ama <varname>tm</varname> yapısında ilgili alana birşey yazılmaz.</para></note>
        </para><para>
<command>strftime</command>'da da GNU oluşumu olan bir GNU oluşumudur.
        </para></listitem></varlistentry><varlistentry>
        <term><literal>%H</literal></term></varlistentry><varlistentry>
        <term><literal>%k</literal></term><listitem><para>
<command>00</command> ile <command>23</command> arasında bir sayısal değer olarak 24 saatlik saat gösterimi.
        </para><para>
<command>%k</command>, <command>strftime</command>'da da GNU oluşumu olan bir GNU oluşumudur.
        </para></listitem></varlistentry><varlistentry>
        <term><literal>%OH</literal></term><listitem><para>
Yerele özgü diğer sayısal sembollerin kullanılması dışında <command>%H</command> ile aynıdır.
        </para></listitem></varlistentry><varlistentry>
        <term><literal>%I</literal></term></varlistentry><varlistentry>
        <term><literal>%l</literal></term><listitem><para>
<command>01</command> ile <command>12</command> arasında bir sayısal değer olarak 12 saatlik saat gösterimi.
        </para><para>
<command>%l</command>, <command>strftime</command>'da da GNU oluşumu olan bir GNU oluşumudur.
        </para></listitem></varlistentry><varlistentry>
        <term><literal>%OI</literal></term><listitem><para>
Yerele özgü diğer sayısal sembollerin kullanılması dışında <command>%I</command> ile aynıdır.
        </para></listitem></varlistentry><varlistentry>
        <term><literal>%j</literal></term><listitem><para>
<command>1</command> ile <command>366</command> arasında yılın gün numarası.
        </para><para>
Başa 0 konulsa da olur konulmasa da.
        </para></listitem></varlistentry><varlistentry>
        <term><literal>%m</literal></term><listitem><para>
<command>1</command>'den <command>12</command>'ye kadar ay numarası.
        </para><para>
Başa 0 konulsa da olur konulmasa da.
        </para></listitem></varlistentry><varlistentry>
        <term><literal>%Om</literal></term><listitem><para>
Yerele özgü diğer sayısal sembollerin kullanılması dışında <command>%m</command> ile aynıdır.
        </para></listitem></varlistentry><varlistentry>
        <term><literal>%M</literal></term><listitem><para>
<command>0</command>'dan <command>59</command>'a kadar dakika.
        </para><para>
Başa 0 konulsa da olur konulmasa da.
        </para></listitem></varlistentry><varlistentry>
        <term><literal>%OM</literal></term><listitem><para>
Yerele özgü diğer sayısal sembollerin kullanılması dışında <command>%M</command> ile aynıdır.
        </para></listitem></varlistentry><varlistentry>
        <term><literal>%n</literal></term></varlistentry><varlistentry>
        <term><literal>%t</literal></term><listitem><para>
Boşluklarla eşleşirler.
        </para></listitem></varlistentry><varlistentry>
        <term><literal>%p</literal></term></varlistentry><varlistentry>
        <term><literal>%P</literal></term><listitem><para>
Yerele özgü <command>AM</command> veya <command>PM</command> dizgesi.
        </para><para>
Bu biçim, <command>%I</command> veya <command>%l</command> ayrıca kullanılmamışsa kullanışsızdır. Bu değerlerin atanmamış olduğu yerellerde başka sorunlara da yol açar ve bu nedenle dönüşüm başarısız olur.
        </para><para>
<command>%P</command> <command>strftime</command>'da da GNU oluşumu olan bir GNU oluşumudur..
        </para></listitem></varlistentry><varlistentry>
        <term><literal>%r</literal></term><listitem><para>
The complete time using the AM/PM format of the current locale.
        </para><para>
A complication is that the locale might not define this format at all and therefore the conversion fails.
        </para></listitem></varlistentry><varlistentry>
        <term><literal>%R</literal></term><listitem><para>
The hour and minute in decimal numbers using the format <command>%H:%M</command>.
        </para><para>
<command>%R</command>, <command>strftime</command>'da da GNU oluşumu olan bir GNU oluşumudur.
        </para></listitem></varlistentry><varlistentry>
        <term><literal>%s</literal></term><listitem><para>
Mutlak zaman başlangıcından (epoch) yani 1970-01-01 00:00:00 UTC'den beri geçen saniye sayısı. Artık saniye desteği yoksa artık saniyeler hesaba katılmaz.
        </para><para>
<command>%s</command>, <command>strftime</command>'da da GNU oluşumu olan bir GNU oluşumudur..
        </para></listitem></varlistentry><varlistentry>
        <term><literal>%S</literal></term><listitem><para>
<command>0</command>'dan <command>60</command>'a kadar saniye.
        </para><para>
Başa 0 konulsa da olur konulmasa da.
        </para><para>
<note><para>Unix belirtimi iki artık saniyenin gösterilmesinin de mümkün olması varsayımıyla bu değerin üst sınırının <command>61</command> olduğunu söyler. Bu değeri <command>61</command> olarak hiç görmeyeceksiniz, çünkü 1 artık saniyeden fazlasına sahip bir dakika yoktur ama efsane sürüyor.</para></note>
        </para></listitem></varlistentry><varlistentry>
        <term><literal>%OS</literal></term><listitem><para>
Yerele özgü diğer sayısal sembollerin kullanılması dışında <command>%S</command> ile aynıdır.
        </para></listitem></varlistentry><varlistentry>
        <term><literal>%T</literal></term><listitem><para>
<command>%H:%M:%S</command> biçimine eşdeğer olarak yorumlanır.
        </para></listitem></varlistentry><varlistentry>
        <term><literal>%u</literal></term><listitem><para>
<command>1</command>'den <command>7</command>'ye kadar gün isminin numarası. Pazartesi, haftanın birinci günüdür.
        </para><para>
Başa 0 konulsa da olur konulmasa da.
        </para><para>
<note><para>Şimdilik tam olarak gerçeklenmemiştir. Biçim olarak tanınır ama <varname>tm</varname> yapısında ilgili alana birşey yazılmaz.</para></note>
        </para></listitem></varlistentry><varlistentry>
        <term><literal>%U</literal></term><listitem><para>
<command>0</command>'dan <command>53</command>'e kadar hafta numarası.
        </para><para>
Başa 0 konulsa da olur konulmasa da.
        </para></listitem></varlistentry><varlistentry>
        <term><literal>%OU</literal></term><listitem><para>
Yerele özgü diğer sayısal sembollerin kullanılması dışında <command>%U</command> ile aynıdır.
        </para></listitem></varlistentry><varlistentry>
        <term><literal>%V</literal></term><listitem><para>
<command>1</command>'den <command>53</command>'e kadar ISO 8601:1988 hafta numarası.
        </para><para>
Başa 0 konulsa da olur konulmasa da.
        </para><para>
<note><para>Şimdilik tam olarak gerçeklenmemiştir. Biçim olarak tanınır ama <varname>tm</varname> yapısında ilgili alana birşey yazılmaz.</para></note>
        </para></listitem></varlistentry><varlistentry>
        <term><literal>%w</literal></term><listitem><para>
<command>0</command>'dan <command>6</command>'ya kadar gün isminin numarası. Pazar, haftanın ilk günüdür.
        </para><para>
Başa 0 konulsa da olur konulmasa da.
        </para><para>
<note><para>Şimdilik tam olarak gerçeklenmemiştir. Biçim olarak tanınır ama <varname>tm</varname> yapısında ilgili alana birşey yazılmaz.</para></note>
        </para></listitem></varlistentry><varlistentry>
        <term><literal>%Ow</literal></term><listitem><para>
Yerele özgü diğer sayısal sembollerin kullanılması dışında <command>%w</command> ile aynıdır.
        </para></listitem></varlistentry><varlistentry>
        <term><literal>%W</literal></term><listitem><para>
<command>0</command>'dan <command>53</command>'e kadar hafta numarası.
        </para><para>
Başa 0 konulsa da olur konulmasa da.
        </para><para>
<note><para>Şimdilik tam olarak gerçeklenmemiştir. Biçim olarak tanınır ama <varname>tm</varname> yapısında ilgili alana birşey yazılmaz.</para></note>
        </para></listitem></varlistentry><varlistentry>
        <term><literal>%x</literal></term><listitem><para>
Yerele özgü kısa tarih gösterimi.
        </para></listitem></varlistentry><varlistentry>
        <term><literal>%Ex</literal></term><listitem><para>
Yerele özgü diğer veri gösterimlerinin kullanılması dışında <command>%x</command> gibidir.
        </para></listitem></varlistentry><varlistentry>
        <term><literal>%X</literal></term><listitem><para>
Yerele özgü saat gösterimi.
        </para></listitem></varlistentry><varlistentry>
        <term><literal>%EX</literal></term><listitem><para>
Yerele özgü diğer saat gösterimlerinin kullanılması dışında <command>%x</command> gibidir.
        </para></listitem></varlistentry><varlistentry>
        <term><literal>%y</literal></term><listitem><para>
<command>0</command> ile <command>99</command> arasında yılın yüzyıllık parçası olmaksızın yıl numarası.
        </para><para>
Başa 0 konulsa da olur konulmasa da.
        </para><para>
<command>%C</command> olmaksızın bu biçim nasıl kullanılacak diye bir soru sorabilirsiniz. <command>strptime</command> işlevi 69'dan 99'a kadar değerleri 1969'dan 1999'a kadar, 0'dan 68'e kadar değerleri de 2000'den 2068'e kadar yıllara karşılık olarak ele alacaktır. Fakat bazı veri girdilerinde bu ampirik yaklaşım başarısız olabilir.
        </para><para>
Bu nedenle <command>%y</command> biçiminden uzak durup yerine <command>%Y</command> kullanmak en iyisidir.
        </para></listitem></varlistentry><varlistentry>
        <term><literal>%Ey</literal></term><listitem><para>
Yerelin diğer gösteriminde <command>%EC</command>'den itibaren geçen yıl sayısı.
        </para></listitem></varlistentry><varlistentry>
        <term><literal>%Oy</literal></term><listitem><para>
Yerelin diğer gösteriminde <command>%C</command> başlangıcından itibaren geçen yıl sayısı.
        </para></listitem></varlistentry><varlistentry>
        <term><literal>%Y</literal></term><listitem><para>
Gregoryen takvimine göre tam yıl.
        </para></listitem></varlistentry><varlistentry>
        <term><literal>%EY</literal></term><listitem><para>
Diğer tam yıl gösterimi.
        </para></listitem></varlistentry><varlistentry>
        <term><literal>%z</literal></term><listitem><para>
RFC 822/ISO 8601:1988 tarzı zaman dilimi.
        </para></listitem></varlistentry><varlistentry>
        <term><literal>%Z</literal></term><listitem><para>
Zaman dilimi kısaltması.
        </para><para>
<note><para>Şimdilik tam olarak gerçeklenmemiştir. Biçim olarak tanınır ama <varname>tm</varname> yapısında ilgili alana birşey yazılmaz.</para></note>
        </para></listitem></varlistentry><varlistentry>
        <term><literal>%%</literal></term><listitem><para>
Tek bir <command>%</command> karakteri.
        </para></listitem></varlistentry></variablelist>
      </para><para>
Biçim dizgesindeki diğer karakterler girdi dizgesindekilerle eşleşmelidir. Ancak girdi dizgesindeki boşluklar biçim dizgesinde bulunmayabileceği gibi daha fazla sayıda da bulunabilir.
     </para><para>
<note><title>Taşınabilirlik Bilgisi</title><para>XPG standardı, iki dönüşüm belirtimi arasında en azından bir boşluk (<command>isspace</command> ile belirtilenler) ya da bir alfanumerik olmayan karakter konulmasını tavsiye eder. GNU C kütüphanesi böyle bir sınırlama yapmaz ama diğer kütüphaneler <command>&quot;%d%m%Y%H%M%S&quot;</command> gibi bir biçim dizgesini yanlış çözümleyebilir.</para></note>
     </para><para>
<command>strptime</command> işlevi dizgeleri sağdan sola doğru işleme tabi tutar. Her olası girdi elemanı (boşluklar, kendisi olan karakterler, biçimler) için sırayla bakılır. Eğer girdiyle biçim eşleştirilemezse işlev işlemi durdurur. Girdi ve biçim dizgelerinin kalanı işleme tabi turulmaz.
     </para><para>
İşlev, işlenmeyen ilk karaktere bir gösterici ile döner. Eğer girdi dizgesi, biçim dizgesinde gerekli karakterlerden fazla karakter içeriyorsa, dönüş değeri son işlenen girdi karakterinden hemen sonraki karakteri gösterir. Eğer girdi dizgesi tamamen tüketilmişse dönüş değeri dizgenin sonundaki boş karakteri gösterir. Bir hata oluşmuşsa, yani işlev biçim dizgesini tam eşleştirememişse, işlev <command>NULL</command> ile döner.
</para></funcdescr></funcsynopsis></para><para>
İşlevin XPG standardındaki belirtimi, bilginin bir kaç önemli parçasını dışarda bıraktığından oldukça muğlaktır. En önemlisi, doğrudan doğruya farklı biçimlerle ilklendirilmemiş <varname>tm</varname> elemanlarının ne olacağı belirlenmemiştir. Farklı Unix sistemlerindeki gerçeklemeler bu bakımdan değişiklikler gösterir.
     </para><para>
GNU libc gerçeklemesi doğrudan ilklendirilmemiş alanlara dokunmaz. <command>tm_wday</command> ve <command>tm_yday</command> alanları bunun dışındadır. Yıl, ay veya tarih elemanları değişmişse bu alanların değerleri yeniden hesaplanır. Bunun iki faydası vardır:
     </para><itemizedlist><listitem><para>
<command>strptime</command> işlevini yeni bir girdi dizgesi ile çağırmadan önce, işleve aktaracağınız <varname>tm</varname> yapısını hazılamalısınız. Bu normalde yapının tüm elemanlarının sıfır olacağı anlamına gelir. Bunun yerine tüm alanlara <command>INT_MAX</command> değerini de atayabilirsiniz. Böylece işlev çağrısının hangi elemanlara değer atadığını saptayabilirsiniz. Bunu sıfırlarla yapamazdınız, çünkü atanan bazı değerler zaten sıfır olacaktır.
       </para><para>
<varname>tm</varname> yapısının ilgilendiğiniz alanlarına işlev çağrısı sırasında bir değer atanıp atanmadığını saptamak isterseniz yapıyı dikkatli ilklendirmelisiniz.
       </para></listitem><listitem><para>
<command>struct tm</command> değerini peşpeşe yapacağınız <command>strptime</command> çağrıları ile oluşturabilirsiniz. Bir dizgede tarih başka bir dizgede de saat gösterimi bulunan iki dizgeyi ayrı ayrı çözümleten bir uyulama için bu yararlıdır. Bir dizgeyi çözümledikten sonra yapıyı temizlemden yapacağınız ikinci çözümleme ile tam yerel zamanı elde edebilirsiniz.
       </para></listitem></itemizedlist><para>
Aşağıdaki örnekte ya US tarzında ya da ISO 8601 biçiminde olabilen bir tarih bilgisi içeren bir dizgeyi çözümleyen bir işlev gösterilmiştir:
     </para><para><screen>
const char *
parse_date (const char *input, struct tm *tm)
{
  const char *cp;

  /* Önce yapıyı temizleyelim.  */
  memset (tm, '\0', sizeof (*tm));

  /* İlk olarak ISO biçimine bakalım.  */
  cp = strptime (input, "%F", tm);
  if (cp == NULL)
    {
      /* Eşleşme yok, o halde US biçimini deneyelim.  */
      cp = strptime (input, "%D", tm);
    }

  return cp;
}
</screen></para></sect2>
    <sect2 id="glibc-General-Time-String-Parsing">
      <title>Genel Zaman Gösterimi Çözümlemesi</title>
      <titleabbrev>Tarih ve saati çözümlemede daha kullanıcı dostu bir yaklaşım.</titleabbrev>
      <para>
Unix standardı tarih dizgelerini çözümlemek için başka bir işlev tanımlar. Arayüz tuhaftır ama uygulamanıza uygun düşecek olursa işlev en iyisidir. Bir durağan ayrılmış değişkene gösterici ile döndüğünden ve bir genel değişkenle genel bir durum (bir ortam değişkeni) kullandığından çok evreli uygulama ve kütüphanelerde sorun çıkarır.
     </para><para>
<indexterm scope="glibc-vr"><primary>getdate_err</primary></indexterm>
<funcsynopsis><funcprototype role="değişken" id="glibc-getdate_err">
<funcdef><command>getdate_err</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Son başarısız <command>getdate</command> çağrısının hata kodunu içeren <command>int</command> türünde bir değişkendir. Tanımlı değerleri şunlardır:
     </para><para><variablelist><varlistentry>
     <term>1</term><listitem><para>
<command>DATEMSK</command> ortam değişkeni tanımsız ya da boş.
        </para></listitem></varlistentry><varlistentry>
        <term>2</term><listitem><para>
<command>DATEMSK</command> ortam değişkeni ile belirtilen şablon dosyası açılamadı.
        </para></listitem></varlistentry><varlistentry>
        <term>3</term><listitem><para>
Şablon dosyası ile ilgili bilgiler alınamadı.
        </para></listitem></varlistentry><varlistentry>
        <term>4</term><listitem><para>
Şablon dosyası normal bir dosya değil.
        </para></listitem></varlistentry><varlistentry>
        <term>5</term><listitem><para>
Şablon dosyası okunurken bir G/Ç hatası oluştu.
        </para></listitem></varlistentry><varlistentry>
        <term>6</term><listitem><para>
İşlevin çalışması için bellek yetersiz.
        </para></listitem></varlistentry><varlistentry>
        <term>7</term><listitem><para>
Şablon dosyası eşleşen bir şablon içermiyor.
        </para></listitem></varlistentry><varlistentry>
        <term>8</term><listitem><para>
Girdi olarak verilen tarih geçersiz. Bu tarihler Şubat'ın 31'ini içeren ya da <command>time_t</command> türünde bir değişkenle ifade edilemeyen tarihler olabilir.
        </para></listitem></varlistentry></variablelist>
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>getdate</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-getdate">
<funcdef>struct tm *<command>getdate</command></funcdef>
<paramdef>(const char *<varname>dizge</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>getdate</command> arayüzü bir dizgeyi çözümleyip bir değer döndürecek bir işlev için olası en basit arayüzdür. <varname>dizge</varname> bir girdi dizgesidir ve sonuç bir dutağan olarak ayrılmış değişkende döndürülür.
     </para><para>
Dizgenin nasıl işleme sokulduğu ile ilgili ayrıntılar kullanıcıdan gizlenmiştir. Aslında, yazılımın da denetiminin dışında olabilir. Karşılaştırma yapılacak biçim dizgeleri <command>DATEMSK</command> ortam değişkeni ile belirtilen bir dosyadadır. Bu dosya <command>strptime</command> işlevine aktarılabilecek biçim dizgelerinden oluşmuş satırlar içerir.
     </para><para>
<command>getdate</command> işlevi bu biçim dizgelerini sırayla okuyarak girdi dizgesi ile eşleştirmeye çalışır. Girdi dizgesi ile tamamen eşleşen ilk satır kullanılır.
     </para><para>
Biçim dizgesi ile ilklendirilmemiş elemanlar tekrar bir <command>getdate</command> çağrısı yapılana kadar öylece kalır.
     </para><para>
<command>getdate</command> tarafından tanınan biçimler <command>strptime</command> iişlevininkilerle aynıdır. Bunlar için önceki bölümdeki açıklamalara bakabilirsiniz. <command>strptime</command> davranışına ek olarak bir kaç ek davranış vardır:
     </para><para><itemizedlist><listitem><para>
Eğer <command>%Z</command> biçimi yerel zamanda verilmişse, çalışma anı ortamının o anki zaman diliminin zamanına değil, zaman diliminin eşleştiği o anki zamana tabanlanır.
       </para><para>
<note><para>Bu şimdilik gerçeklenmemiştir.  Sorun, zaman dilimi isimlerinin eşsiz olmamasıdır. ABD ile diğer ülkeler için aynı olarak kabul edilen bir sabit zaman dilimi (örn, <command>EST</command> ABD Doğu Sahili Zamanı anlamında) verildiğinde ABD dışındaki ülkeler açısından işlev başarısız olacaktır. Şimdiye kadar buna iyi bir çözüm bulamadık.</para></note>
       </para></listitem><listitem>
Eğer sadece haftanın günü belirtilmişse, seçilen gün o anki tarihe bağlı olacatır. Eğer o anki haftanın günü <command>tm_wday</command> değerine eşit ya da ondan büyükse o anki haftanın günü, aksi takdirde sonraki haftanın günü seçilir.
       </listitem><listitem>
Benzer bir ampirik yöntem de sadece ayın verildiği yılın belirtilmediği durumla ilgilidir. Eğer ay, o anki aya eşit ya da büyükse, o anki yıl, aksi takdirde bir sonraki yıl kullanılır. Açıkça belirtilmemişse ayın ilk günü verilmiş varsayılır.
       </listitem><listitem>
Biçimde açıça belirtilmemişse o anki saat, dakika ve saniye değeri kullanılır.
       </listitem><listitem>
Bir tarih belirtilmemişse ve zaman, o anki zamandan daha küçükse ertesi günün tarihi aksi takdirde o günkü tarih alınır.
       </listitem></itemizedlist></para><para>
Şablon dosyasındaki biçimin sadece biçim elemanlarını içermediği unutulmamalıdır. Aşağıda olası biçim dizgelerinin bir listei verilmiştir (Unix standardından alınmıştır):
     </para><para>
<screen>%m
%A %B %d, %Y %H:%M:%S
%A
%B
%m/%d/%y %I %p
%d,%m,%Y %H:%M
at %A the %dst of %B in %Y
run job at %I %p,%B %dnd
%A den %d. %B %Y %H.%M Uhr
</screen></para><para>
Gördüğünüz gibi, şablon listesi <command>run job at %I %p,%B %dnd</command> gibi çok özel dizgeler içerebilir. Bu listedeki şablonları kullanarak ve o anki zamanın Mon Sep 22 12:19:47 EDT 1986 olduğunu kabul ederek verilen girdiler için şu sonuçları aldık:
     </para><para>
<informaltable frame="none" style="background:#999999;">
<tgroup cols="3"><colspec colwidth="14*"/><colspec colwidth="12*"/><colspec colwidth="41*"/><tbody><row style="background:#ffffbb;">
<entry> Girdi </entry><entry> Eşleşen </entry><entry> Sonuç
</entry></row><row style="background:#ffffee;">
<entry>Mon </entry><entry>%a </entry><entry>Mon Sep 22 12:19:47 EDT 1986
</entry></row><row style="background:#ffffee;">
<entry>Sun </entry><entry>%a </entry><entry>Sun Sep 28 12:19:47 EDT 1986
</entry></row><row style="background:#ffffee;">
<entry>Fri </entry><entry>%a </entry><entry>Fri Sep 26 12:19:47 EDT 1986
</entry></row><row style="background:#ffffee;">
<entry>September </entry><entry>%B </entry><entry>Mon Sep 1 12:19:47 EDT 1986
</entry></row><row style="background:#ffffee;">
<entry>January </entry><entry>%B </entry><entry>Thu Jan 1 12:19:47 EST 1987
</entry></row><row style="background:#ffffee;">
<entry>December </entry><entry>%B </entry><entry>Mon Dec 1 12:19:47 EST 1986
</entry></row><row style="background:#ffffee;">
<entry>Sep Mon </entry><entry>%b %a </entry><entry>Mon Sep 1 12:19:47 EDT 1986
</entry></row><row style="background:#ffffee;">
<entry>Jan Fri </entry><entry>%b %a </entry><entry>Fri Jan 2 12:19:47 EST 1987
</entry></row><row style="background:#ffffee;">
<entry>Dec Mon </entry><entry>%b %a </entry><entry>Mon Dec 1 12:19:47 EST 1986
</entry></row><row style="background:#ffffee;">
<entry>Jan Wed 1989 </entry><entry>%b %a %Y </entry><entry>Wed Jan 4 12:19:47 EST 1989
</entry></row><row style="background:#ffffee;">
<entry>Fri 9 </entry><entry>%a %H </entry><entry>Fri Sep 26 09:00:00 EDT 1986
</entry></row><row style="background:#ffffee;">
<entry>Feb 10:30 </entry><entry>%b %H:%S </entry><entry>Sun Feb 1 10:00:30 EST 1987
</entry></row><row style="background:#ffffee;">
<entry>10:30 </entry><entry>%H:%M </entry><entry>Tue Sep 23 10:30:00 EDT 1986
</entry></row><row style="background:#ffffee;">
<entry>13:30 </entry><entry>%H:%M </entry><entry>Mon Sep 22 13:30:00 EDT 1986
     </entry></row></tbody></tgroup></informaltable>
   </para><para>
İşlevin dönüş değeri <command>struct tm</command> türündeki bir durağan ayrılmış değişkene göstericidir, bir hata oluşmuşsa boş gösterici döner. Sonuç sadece sonraki <command>getdate</command> çağrısına kadar geçerlidir. Bu, işlevi çok evreli uygulamalar açısından kullanışsız yapar.
     </para><para>
<command>errno</command> değişkeni <emphasis>değiştirilmez</emphasis>.  Hta değerleri <command>getdate_err</command> genel değişkeninde saklanır. Olası hata değerleri ve açıklamaları için <link linkend="glibc-getdate_err">yukarıya bakınız</link>.
     </para><para>
<warning><para><command>getdate</command> işlevi <emphasis>hiçbir zaman</emphasis> SUID'li yazılımlarda kullanılmamalıdır.  Sebep belli: işlev <command>DATEMSK</command> ortam değişkeninde belirtilen bir dosyayı kullanıyor; dosyada bazı bozuk girdiler (ikilik veri gibi) varsa yazılım çökecektir.</para></warning>
     </para><para>
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>getdate_r</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-getdate_r">
<funcdef>int <command>getdate_r</command></funcdef>
<paramdef>(const char *<varname>dizge</varname>,
 struct tm  *<varname>zaman</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>getdate_r</command> işlevi <command>getdate</command> işlevinin evresel sürümüdür.  <command>getdate_err</command> genel değişkenini kullanmaz, hata kodunu işlevin kendisi döndürür. Hata oluşmamışsa işlev sıfır döndürür. İşlevin döndürdüğü hata kodları <command>getdate_err</command> değişkeninin açıklamasındaki <link linkend="glibc-getdate_err">hata kodları</link> ile aynıdır.
     </para><para>
Bundan başka, <command>getdate_r</command> işlevi yerel zamanı bir durağan değişkende değil, <command>struct tm</command> türünde bir değişken olan ikinci argümanda saklar.
     </para><para>
Bu işlev Unix standardında tanımlanmamıştır. Buna rağmen birçok Unix sisteminde kullanılmaktadır.
     </para><para>
<command>getdate</command> işlevi için belirtilen SUID'li yazılımlarla ilgili uyarı bu işlev için de geçerlidir.
  </para></funcdescr></funcsynopsis></para></sect2></sect1>
  <sect1 id="glibc-TZ-Variable">
    <title>Zaman Diliminin <literal>TZ</literal> ile Belirtilmesi</title>
    <titleabbrev>Kullanıcılar zaman dilimini nasıl belirtir.</titleabbrev>
    <para>
POSIX sistemlerde, bir kullanıcı zaman dilimini <command>TZ</command> ortam değişkeni ile belirtebilir. Ortam değişkenlerine nasıl değer atandığı ile ilgili belgi almak isterseniz <xref linkend="glibc-Environment-Variables"/> bölümüne bakınız. Zaman dilimine erişim için kullanılan işlevler <filename>time.h</filename> başlık dosyasında bildirilmiştir.
<indexterm scope="glibc-pg"><primary>time.h</primary></indexterm>
<indexterm scope="glibc-cp"><primary>zaman dilimi</primary></indexterm>
     </para><para>
Normalde <command>TZ</command> değişkenine bir değer atamak zorunda kalmazsınız. Eğer sistem olması gerektiği gibi yapılandırılmışsa öntanımlı zaman dilimi doğru olacaktır. Eğer bilgisayarınız farklı zaman dilimindeki bir ağa bağlıysa ve zaman diliminizin kendi zaman diliminiz değil de ağın zaman dilimi olarak raporlanmasını istiyorsanız  <command>TZ</command> değişkenine ağın zaman dilimini atayabilirsiniz.
    </para><para>
POSIX.1 sistemlerde <command>TZ</command> değişkeninin değeri üç biçimden biri olabilir. GNU C kütüphanesi ile en ortak biçim olan sonuncusunda zaman dilimi geniş bir veri tabanından yapılan bir seçimle belirtilir. İlk iki biçim ise zaman dilimi bilgisini doğrudan açıklamak için kullanılır, daha az kesin ve çok hantaldırlar. Ama POSIX.1 standardı sadece bu ilk iki biçimin ayrıntılarını belirlemiştir. Bu nedenle zaman dilimi bilgileri veritabanı desteği bulunmayan POSIX.1 sistemlerde bunlarla karşılaşabileceğinizden onlar hakkında bilgi sahibi olmanız iyi olacaktır.
    </para><para>
İlk biçim yaz saati uygulaması yapılmayan zaman dilimlerinde kullanılır:
    </para><para>
<screen><varname>std</varname><varname>fark</varname></screen>
    </para><para>
<varname>std</varname> dizgesi zaman diliminin ismidir. En az üç karakter uzunlukta olmalı, başlangıcında iki nokta üstüste olmamalı, içinde rakam, virgül, artı ya da - işareti bulunmamalıdır.
string specifies the name of the time zone.  It must be three or more characters long and must not contain a leading colon, embedded digits, commas, nor plus and minus signs.  There is no space character separating the time zone name from the <varname>far</varname> ile zaman dilimi arasında herhangi bir boşluk karakteri olmamalıdır. Bu sınırlamalar belirtimin çözümlenebilmesi için gereklidir.
    </para><para>
<varname>fark</varname>, yerel zamanı elde etmek için UTC değerine eklenecek saat farkıdır. Sözdizimi şöyledir:
    </para><para>
<literallayout>    [<command>+</command>|<command>-</command>]<varname>ss</varname>[<command>:</command><varname>dd</varname>[<command>:</command><varname>SS</varname>]]
</literallayout>
    </para><para>
Yerel zaman dilimi ilk meridyenin batısındaysa pozitif, aksi yöndeyse negatiftir. Saatler <command>0</command> ile <command>23</command> arasında, dakika ve saniyeler ise <command>0</command> ile <command>59</command> arasına belirtilmelidir.
    </para><para>
Örneğin, Doğu Standart Zamanını yaz saati uygulaması olmaksızın belirtmek isterseniz:
    </para><para>
<screen>EST+5</screen>
    </para><para>
    </para><para>
<literallayout>
<varname>std fark yer</varname> [<varname>fark</varname>],<varname>başlangıç</varname>[/<varname>saat</varname>],<varname>bitiş</varname>[/<varname>saat</varname>]
</literallayout></para><para>
İlk <varname>std</varname> ve <varname>fark</varname> yukarıda açıklandığı gibi standart zaman dilimini belirtir. Sonraki <varname>yer</varname> dizgesi ve <varname>fark</varname> ise yaz saati uygulama bölgesinin ismini ve saat farkını belirtir. <varname>fark</varname> belirtilmemişse bir saatlik fark öntanımlıdır.
    </para><para>
Belirtimin kalanı yaz saatinin nasıl uygulanacağını belirtir. <varname>başlangıç</varname> yaz saatinin uygulanmaya başlayacağı zamanı, <varname>bitiş</varname> ise uygulamanın sonlandırılıp normal zamana dönülecek zamanı belirtir. Bu alanlarda şu biçimler kullanılabilir:
   </para><para><glosslist><glossentry><glossterm>
   <command>J</command><varname>n</varname>
   </glossterm><glossdef><para>
Jülyen takvimine göre gün belirtir. <varname>n</varname>, <command>1</command> ile <command>365</command> arasında bir değer alabilir. 29 Şubat, artık yıllarda bile sayılmaz.
   </para></glossdef></glossentry><glossentry><glossterm>
   <varname>n</varname>
   </glossterm><glossdef><para>
Jülyen takvimine göre gün belirtir. <varname>n</varname>, <command>0</command> ile <command>365</command> arasında bir değer alabilir. 29 Şubat, artık yıllarda hesaba katılır.
   </para></glossdef></glossentry><glossentry><glossterm>
   <command>M</command><varname>a</varname>.<varname>h</varname>.<varname>g</varname>
   </glossterm><glossdef><para>
<varname>a</varname>ıncı ayın <varname>h</varname>ıncı haftasının <varname>g</varname>inci gününü belirtir. <varname>g</varname> haftanın ilk günü Pazar olmak üzere <command>0</command> ile <command>6</command> arasında, <varname>h</varname> ise <command>1</command> ile <command>5</command> arasında olmalıdır; <command>1</command>. hafta <varname>g</varname>inci günü içeren ilk hafta, <command>5</command>. hafta ise <varname>g</varname>inci günü içeren son haftadır. <varname>a</varname> ise <command>1</command> ile <command>12</command> arasında olmalıdır.
    </para></glossdef></glossentry></glosslist></para><para>
<varname>saat</varname> alanı, yaz saati uygulamasının başlayacağı ve biteceği saati belirtmek için kullanılır. Verilmezse, öntanımlı olarak <command>02:00:00</command> kabul edilir.
    </para><para>
Örnek olarak ABD'de Doğu zaman diliminde yaz saati uygulamasının nasıl belirtileceğine bakalım. UTC'ye göre saat farkı 5 saat; ilk meridyenin batısında olduğundan işareti pozitif; yaz saati uygulaması Nisan ayının ilk Pazar günü öğleden önce 2:00'da başlayıp Ekim ayının son Pazar günü öğleden önce 2:00'da sona ersin dersek, bunu şöyle belirtiriz:
    </para><para><screen>
EST+5EDT,M4.1.0/2,M10.5.0/2
</screen></para><para>
Yaz saati uygulamasının zamanlaması bir takım karar organlarınca zaman içinde değiştirilebilir. Ancak bu biçim zamanlamanın yıldan yıla nasıl değişeceğinin belirtilebileceği hiçbir oluşuma sahip değildir. Tam doğru zaman dilimi belirtimi için en iyisi zaman dilimi bilgileri veritabanı kullanmaktır.
    </para><para>
Üçüncü biçim ise şöyledir:
    </para><para>
<literallayout>:<varname>karakterler</varname></literallayout></para><para>
Her işletim sistemi bu biçimi farklı yorumlar; GNU C kütüphanesinde <varname>karakterler</varname>, zaman dilimi bilgilerini içeren bir dosyanın ismidir.
    </para><para>
<indexterm scope="glibc-pg"><primary sortas="etc/localtime">/etc/localtime</primary></indexterm>
<command>TZ</command> ortam değişkenine bir değer atanmamışsa, işlem öntanımlı olarak bir zaman dilimi seçer. GNU C kütüphanesinde öntanımlı zaman dilimi <command>TZ=:/etc/localtime</command> (veya GNU C kütüphanesinin derlenişine bağlı olarak,  <command>TZ=:/usr/local/etc/localtime</command>; bkz. <xref linkend="glibc-Installation"/>) gibi bir belirtimdir.  Diğer C kütüphaneleri öntanımlı zaman dilimin seçerken kendi kurallarını kullanırlar ve bunlar hakkında burada pek az şey söyleyebiliriz.
    </para><para>
<indexterm scope="glibc-cp"><primary>zaman dilimi veritabanı</primary></indexterm>
<indexterm scope="glibc-pg"><primary sortas="share/lib/zoneinfo">/share/lib/zoneinfo</primary></indexterm>
<varname>karakterler</varname> bir bölü çizgisi ile başlıyorsa, bir mutlak dosya ismi gösterir; aksi takdirde kütüphane <command>/share/lib/zoneinfo/</command><varname>karakterler</varname> dosyasına bakar.  The <command>zoneinfo</command> dizini dünyanın farklı yerlerinde yerel zaman dilimleri hakkında bilgiler içeren veri dosyaları içerir. Bunlar, coğrafik bölge dizinleri içinde büyük şehirlerin isimlerini taşıyan dosyalardır; örneğin,<command>America/New_York</command>, <command>Europe/London</command>, <command>Asia/Hong_Kong</command> gibi. Bu veri dosyalarını sistem yöneticisi kurar ve yerel zaman dilimini <command>/etc/localtime</command> dosyasıyla belirtir.  GNU C kütüphanesi, dünyanın hemen her yerindeki gönüllüler tarafından sağlanmış zaman dilimi bilgilerinden oluşturulmuş büyük bir veritabanı ile gelir.
    </para></sect1>
  <sect1 id="glibc-Time-Zone-Functions">
    <title>Zaman Dilimi Değişkenleri ve İşlevleri</title>
    <titleabbrev>Zaman dilimini belirtmek ve öğrenmek için kullanılan işlevler.</titleabbrev>
    <para>
<indexterm scope="glibc-vr"><primary>tzname</primary></indexterm>
<funcsynopsis><funcprototype role="değişken" id="glibc-tzname">
<funcdef>char *<command>tzname</command> [2]</funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
<command>tzname</command> dizisi kullanıcı tarafından seçilen bir standart isimle diğeri yaz saati ile ilgili iki dizge içerir.  <command>tzname[0]</command> standart zaman diliminin ismi (örn, <command>&quot;EST&quot;</command>), <command>tzname[1]</command> ise yaz saati uygulaması ismidir (örn, <command>&quot;EDT&quot;</command>).  Bunlar sırayla <command>TZ</command> ortam değişkeninin <varname>std</varname> ve <varname>fark</varname> dizgelerine karşılıktır. Yaz saati uygulaması yapılmıyorsa, <command>tzname[1]</command> boş bir dizge olur.
    </para><para>
<command>tzname</command> dizisi, <command>TZ</command> ortam değişkeninden başka <command>tzset</command>, <command>ctime</command>, <command>strftime</command>, <command>mktime</command> veya <command>localtime</command> işlev çağrıları ile değiştirilebilir. Eğer bir zaman dilimini belirtmek için çok sayıda kısaltma varsa (örn, U.S. Eastern War Time ve Eastern Daylight Time için <command>&quot;EWT&quot;</command> ve <command>&quot;EDT&quot;</command>), kullanımdaki en son kısaltma belirtilmelidir.
    </para><para>
<command>tzname</command> dizisi POSIX.1 uyumluluğu gerektirir. Ancak GNU yazılımlarının yerel zaman yapısının <command>tm_zone</command> üyesi en son kullanımda olanı olmasa bile en doğru kısaltmayı içerdiğinden bu üyeyi kullanmaları daha iyi olur.
    </para><para>
Dizgeler <command>char *</command> olarak bildirildiğinden kullanıcı bu dizgeleri değiştirmekten kaçınmalıdır. Bu dizgelerin değiştirilmesi hemen hemen daima sorunlara yol açar.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>tzset</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-tzset">
<funcdef>void <command>tzset</command></funcdef>
<paramdef>(void)</paramdef>
</funcprototype><funcdescr><para>
<command>tzset</command> işlevi <command>tzname</command> değişkenini  <command>TZ</command> ortam değişkeninin değerinden günceller. Normalde bu işlevi çağırmanız gerekmez. Çünkü zaman dilimine bağlı zaman dönüşüm işlevlerini kullandığınızda bu işlev kendiliğinden çağrılır.
</para></funcdescr></funcsynopsis></para><para>
Aşağıdaki değişkenler System V Unix uyumluluğu için tanımlanmıştır. <command>tzname</command> gibi bu değişkenlere de <command>tzset</command> veya diğer zaman dönüşüm işlevleri ile değer atanır.
    </para><para>
<indexterm scope="glibc-vr"><primary>timezone</primary></indexterm>
<funcsynopsis><funcprototype role="değişken" id="glibc-timezone">
<funcdef>long int <command>timezone</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu, UTC'nin batısına doğru saniye cinsinden, UTC ile en son yerel standart zaman arasındaki saat farkıdır. Örneğin ABD Doğu zaman dilimi için bu değer <command>5*60*60</command> saniyedir. Yerel zaman yapısının <command>tm_gmtoff</command> üyesinin aksine, bu değer yaz saati uygulaması ile ilgili değildir ve işareti de terstir. GNU yazılımlarında, en son uygulananı olmasa da en doğru değeri içerdiğinden, yerel zaman yapısının <command>tm_gmtoff</command> üyesini kullanmak daha iyidir.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-vr"><primary>daylight</primary></indexterm>
<funcsynopsis><funcprototype role="değişken" id="glibc-daylight">
<funcdef>int <command>daylight</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu değişkenin değeri sıfırdan farklıysa yaz saati uygulaması kuralları uygulanır. Değerin sıfırdan farklı olması, yaz saatinin o an uygulanmakta olduğunun değil, zamanı gelince uygulanacağının göstergesidir.
  </para></funcdescr></funcsynopsis></para></sect1>
  <sect1 id="glibc-Time-Functions-Example">
    <title>Zaman İşlevleri Örneği</title>
    <titleabbrev>Zamanla ilgili bazı işlevlerin kullanımını gösteren bir örnek.</titleabbrev>
    <para>
Burada yerel zamanla ilgili bazı işlevlerin kullanımı örneklenmiştir.
    </para><para>
<screen>#include &lt;time.h>
#include &lt;stdio.h>
#include &lt;locale.h>

#define SIZE 256

int
main (void)
{
  char buffer[SIZE];
  time_t curtime;
  struct tm *loctime;

  /* Yerel zamanı gerçekten yerele özgü göstereceksek
     bu lazım, yoksa C yereline özgü gösterilir. */
  setlocale (LC_ALL, "");

  /* Şimdiki zamanı öğrenelim. */
  curtime = time (NULL);

  /* Yerel zaman gösterimine dönüştürelim. */
  loctime = localtime (&amp;curtime);

  /* Tarihi ve saati standart C biçiminde basalım. */
  fputs (asctime (loctime), stdout);

  /* Şimdi de yerele özgü ve istediğimiz biçimde basalım. */
  strftime (buffer, SIZE, "Bugün %d %B, %A.\n", loctime);
  fputs (buffer, stdout);
  strftime (buffer, SIZE, "Saat %I:%M %p.\n", loctime);
  fputs (buffer, stdout);

  return 0;
}
</screen></para><para>
Çıktısı şöyle olur:
    </para><para>
<screen>Sat Aug 28 13:49:43 2004
Bugün 28 Ağustos, Cumartesi.
Saat 01:49 ÖS.
</screen></para></sect1>
</chapter>

<chapter id="glibc-Setting-an-Alarm">
  <title>Bir Alarmın Ayarlanması</title>
  <titleabbrev>Bir sinyalin belli bir süre sonra gönderilmesi.</titleabbrev>
  <para>
<command>alarm</command> ve <command>setitimer</command> işlevleri bir sürecin kendisine gelecekte bir kesme göndermesini sağlar. Bunu bir zamanlayıcıyı ayarlayarak yaparlar; zamanlayıcının süresi dolduğunda süreç bir sinyal alır.
   </para><para>
<indexterm scope="glibc-cp"><primary>alarm</primary></indexterm>
<indexterm scope="glibc-cp"><primary>alarm</primary><secondary>ayarlanması</secondary></indexterm>
<indexterm scope="glibc-cp"><primary>zamanlayıcı</primary></indexterm>
<indexterm scope="glibc-cp"><primary>zamanlayıcı</primary><secondary>ayarlanması</secondary></indexterm>
Her süreç üç bağımsız zamanlayıcı kullanabilir:
   </para><itemizedlist><listitem><para>
Bir gerçek zamanlı zamanlayıcı kalan süreyi sayar. Bu zamanlayıcı zamanaşımına uğradığında sürece bir <command>SIGALRM</command> sinyali gönderir.
<indexterm scope="glibc-cp"><primary>zamanlayıcı</primary><secondary>gerçek zamanlı</secondary></indexterm>
   </para></listitem><listitem><para>
Bir sanal zamanlayıcı süreç tarafından kullanılan işlemci süresini sayar. Bu zamanlayıcı zamanaşımına uğradığında sürece bir <command>SIGVTALRM</command> sinyali gönderir.
<indexterm scope="glibc-cp"><primary>zamanlayıcı</primary><secondary>sanal</secondary></indexterm>
   </para></listitem><listitem><para>
Bir profil zamanlayıcı hem süreç tarafından kullanılan işlemci süresini hem de sistemin süreç adına kullandığı işlemci süresini sayar. Bu zamanlayıcı zamanaşımına uğradığında sürece bir <command>SIGPROF</command> sinyali gönderir.
<indexterm scope="glibc-cp"><primary>zamanlayıcı</primary><secondary>profil</secondary></indexterm>
     </para><para>
Bu zamanlayıcı yorumlayıcılarda profil çıkarma için kullanışlıdır. Zamanlayıcı mekanizmasının birim sayma süresi doğal kodun profilinin çıkarılması için gereken hassasiyete sahip değildir.
     </para></listitem></itemizedlist><para>
Herhangi bir anda bu üç zamanlayıcıdan sadece birini kullanabilirsiniz. Henüz zamanaşımına uğramamış bir zamanlayıcıyı tekrar kullanmaya çalışırsanız, zamanlayıcıyı basitçe yeni değerle yeniden başlatmış olursunuz.
   </para><para>
Bir <command>setitimer</command> veya <command>alarm</command> işlevini çağırmadan önce <command>signal</command> veya <command>sigaction</command> işlevini kullanarak ilgili alarm sinyali için bir sinyal eylemci oluşturmalısınız. Aksai takdirde, bir olağandışı olaylar zinciri yazılımınız daha bir sinyal eylemci kurmaya fırsat bulamadan zamanlayıcının zamanaşımına uğramasına sebep olabilir. Bu durumda, alarm sinyalleri için öntanımlı eylem sürecin sonlandırılması olduğundan yazılımınız sonlanırdı. Bkz. <xref linkend="glibc-Signal-Handling"/>.
   </para><para>
Durdurulmadığı takdirde sonsuza kadar engelleme yapabilecek bir sistem çağrısını durdurmak amacıyla alarm işlevinin kullanılmasını mümkün kılmak için sinyal eylemcinin <command>sigaction</command> ile <command>SA_RESTART</command> seçeneği atanmadan oluşturulması önemlidir. <command>sigaction</command> kullanılmadığı durumda işler biraz daha karışıktır, çünkü <command>signal</command> işlevinin yeniden başlatma açısından işleyiş mantığı sabittir: BSD mantığına göre bu seçenek atanır. Dolayısıyla herhangi bir nedenle <command>sigaction</command> kullanılamazsa <command>signal</command> değil <command>sysv_signal</command> kullanmak gerekir.
   </para><para>
Bir alarm ayarlanmak istendiğinde ilk akla gelen <command>setitimer</command> işlevidir. Bu oluşum <filename>sys/time.h</filename> başlık dosyasında bildirilmiştir. Gerçek zamanlı bir zamanlayıcıyı etkinleştirmek için biraz daha basit bir arayüz sunan <command>alarm</command> işlevi ise <filename>unistd.h</filename> dosyasında bildirilmiştir.
<indexterm scope="glibc-pg"><primary>unistd.h</primary></indexterm>
<indexterm scope="glibc-pg"><primary>sys/time.h</primary></indexterm>
   </para><para>
<indexterm scope="glibc-tp"><primary sortas="itimerval">struct itimerval</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü" id="glibc-itimerval">
<funcdef>struct <command>itimerval</command></funcdef>
<paramdef></paramdef>
</funcprototype><funcdescr><para>
Bu yapı bir zamanlayıcıyı ayarlamak için kullanılır. Şu üyeleri içerir:
   </para><para><glosslist><glossentry><glossterm>
   <literal>struct timeval <command>it_interval</command></literal>
   </glossterm><glossdef><para>
Zamanlayıcı kesmeleri arasındaki süredir. Sıfırsa alarm sadece bir kere gönderilir.
   </para></glossdef></glossentry><glossentry><glossterm>
   <literal>struct timeval <command>it_value</command></literal>
   </glossterm><glossdef><para>
İlk zamanlayıcı kesmesine kadar geçen süredir. Sıfırsa alarm iptal edilir.
   </para></glossdef></glossentry></glosslist></para><para>
The <command>struct timeval</command> data type is described in <xref linkend="glibc-Elapsed-Time"/>.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>setitimer</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-setitimer">
<funcdef>int <command>setitimer</command></funcdef>
<paramdef>(int               <varname>tür</varname>,
 struct itimerval *<varname>yeni</varname>,
 struct itimerval *<varname>eski</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>setitimer</command> işlevi <varname>tür</varname> türündeki zamanlayıcıyı <varname>yeni</varname> değere ayarlarlar. <varname>tür</varname> argümanı <command>ITIMER_REAL</command>, <command>ITIMER_VIRTUAL</command> ve <command>ITIMER_PROF</command> değerlerinden biri olabilir.
   </para><para>
<varname>eski</varname> bir boş gösterici değilse, işlev henüz zamanaşımına uğramamış aynı türde bir zamanlayıcı varsa onunla ilgili yapıyı bu gösterici ile döndürür.
   </para><para>
İşlev başarılı ise dönüş değeri <command>0</command>, değilse <command>-1</command>'dir. Aşağıdaki <command>errno</command> hata değeri bu işlev için tanımlanmıştır:
   </para><para><variablelist><varlistentry>
   <term><literal>EINVAL</literal></term><listitem><para>
Zamanlayıcının süresi çok uzun.
   </para></listitem></varlistentry></variablelist>
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>getitimer</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-getitimer">
<funcdef>int <command>getitimer</command></funcdef>
<paramdef>(int               <varname>tür</varname>,
 struct itimerval *<varname>eski</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>getitimer</command> işlevi <varname>tür</varname> türündeki zamanlayıcı ile ilgili bilgileri <varname>eski</varname> ile gösterilen yapı içinde döndürür.
   </para><para>
Dönüş değeri ve hata durumları <command>setitimer</command> ile aynıdır.
      </para><para><variablelist><varlistentry>
      <term><literal>ITIMER_REAL</literal></term><listitem><para>
Bu sabit <command>setitimer</command> ve <command>getitimer</command> işlevlerinin <varname>tür</varname> argümanında kullanıldığında gerçek zamanlı bir zamanlayıcı belirtir.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>ITIMER_VIRTUAL</literal></term><listitem><para>
Bu sabit <command>setitimer</command> ve <command>getitimer</command> işlevlerinin <varname>tür</varname> argümanında kullanıldığında sanal bir zamanlayıcı belirtir.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>ITIMER_PROF</literal></term><listitem><para>
Bu sabit <command>setitimer</command> ve <command>getitimer</command> işlevlerinin <varname>tür</varname> argümanında kullanıldığında gerçek bir profil zamanlayıcı belirtir.
      </para></listitem></varlistentry></variablelist>
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="glibc-fn"><primary>alarm</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-alarm">
<funcdef>unsigned int <command>alarm</command></funcdef>
<paramdef>(unsigned int <varname>saniye</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>alarm</command> işlevi gerçek zamanlı zamanlayıcıyı <varname>saniye</varname> saniyede zamanaşımına uğrayacak şekilde ayarlar. Mevcut bir alarmı iptal etmek isterseniz, işlevi <varname>saniye</varname> argümanında sıfır değerini aktararak çağırmanız yeterlidir.
   </para><para>
Dönüş değeri, önceki alarmın kalan süresidir. Daha önce bir alarm yoksa işlev sıfır ile döner.
</para></funcdescr></funcsynopsis></para><para>
<command>alarm</command> işlevi <command>setitimer</command> kuralları ile şöyle tanımlanabilirdi:
   </para><para><screen>
unsigned int
alarm (unsigned int seconds)
{
  struct itimerval old, new;
  new.it_interval.tv_usec = 0;
  new.it_interval.tv_sec = 0;
  new.it_value.tv_usec = 0;
  new.it_value.tv_sec = (long int) seconds;
  if (setitimer (ITIMER_REAL, &amp;new, &amp;old) &lt; 0)
    return 0;
  else
    return old.it_value.tv_sec;
}
</screen></para><para>
<command>alarm</command> işlevinin kullanım örneğini  <xref linkend="glibc-Handler-Returns"/> bölümünde bulabilirsiniz.
   </para><para>
Sürecinizin belli bir süre beklemesini isterseniz <command>sleep</command> işlevini kullanmalısınız. Bkz. <xref linkend="glibc-Sleeping"/>.
   </para><para>
Zamanlayıcı zamanaşımına uğrar uğramaz sinyalin gelmesini beklememelisiniz. Çok işlemcili ortamlarda genellikle biraz gecikme olur.
   </para><para>
<note><title>Taşınabilirlik Bilgisi</title><para><command>setitimer</command> ve <command>getitimer</command> işlevlerinin BSD Unix'den türetilmiş olmasına karşın  <command>alarm</command> işlevi POSIX.1 standardında belirtilmiştir. <command>setitimer</command> işlevi daha güçlü olduğu halde <command>alarm</command> işlevi daha yaygın olarak kullanılır.</para></note>
   </para></chapter>
<chapter id="glibc-Sleeping">
  <title>Uyku</title>
  <titleabbrev>Bir sürecin belli bir süre bekletilmesi.</titleabbrev>
  <para>
<command>sleep</command> işlevi yazılımınızın kısa bir süre için beklemeye alınmasını sağlayan basit bir yöntem sunar. Yazılımınız sinyalleri kullanmıyorsa (sonlanma hariç) <command>sleep</command>  ile belli bir süre bekleme sağlayacağınızı varsayabilirsiniz.  Ancak, eğer bir sinyal gelirse <command>sleep</command> daha erken dönebilir. Bekleme süresinin sinyallerden bağımsız olmasını isterseniz <command>select</command> (bkz. <xref linkend="glibc-Waiting-for-I-O"/>) işlevini beklenecek herhangi bir tanımlayıcı belirtmeden kullanmalısınız.
   </para><para>
<indexterm scope="glibc-fn"><primary>sleep</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-sleep">
<funcdef>unsigned int <command>sleep</command></funcdef>
<paramdef>(unsigned int <varname>saniye</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>sleep</command> işlevi bir sinyal alınmadıkça çağrıldığı süreci <varname>saniye</varname> saniye bekletir.
   </para><para>
<command>sleep</command> işlevi istenen süreyi tamamlamışsa, sıfır ile döner; bir sinyal nedeniyle tamamlayamamışsa kalan süreyi belirten bir sayı ile döner.
   </para><para>
<command>sleep</command> işlevi <filename>unistd.h</filename> başlık dosyasında bildirilmiştir.
</para></funcdescr></funcsynopsis></para><para>
<command>sleep</command> işlevinin dönüş değerini kullanarak ve sıfırdan farklıysa çağrıyı tekrarlayarak bekleme süresinin dolmasını sağlamaya karşı bir direnç oluşur. Bu çalışma sonucunda elde edilen sonucun doğruluğu sinyallerin geliş sıklığına göre değişir.
Her sinyal alınışında araya ek birkaç saniye eklenecektir. Çok sık aralıklarla birkaç sinyalin birden gelmesi kötü bir şans olurdu, bu durumda bekleme süresinin uzunluğunun ya da kısalığının bir sınırı olmayacaktır.
   </para><para>
Bunun yerine yazılımın beklemeyi sonlandıracağı zamanı bir mutlak zamana ayarlayın. Bu bir saniyeden fazla şaşmaz. Biraz daha fazla bir çalışma ile daha kesin bir bekleme süresini <command>select</command> işlevini kullanarak sağlayabilirsiniz. (Bu durumda da makine uygulamanıza adanmamışsa ağır sistem yükleri kaçınılmaz ek gecikmeler oluşturur ve bundan kaçınmanın bir yolu yoktur.)
   </para><para>
Bazı sistemlerde, <command>sleep</command> işlevi yazılımın doğrudan  <command>SIGALRM</command> kullanmasına bağlı olarak tuhaf şeyler yapabilir. <command>sleep</command> çağrıldığı sırada <command>SIGALRM</command> sinyalleri yoksayılsa ya da engellense bile, bir <command>SIGALRM</command> sinyali alındığında işlev zamanaşımı süresi bitmeden dönecektir. <command>SIGALRM</command> sinyalleri için bir sinyal eylemci oluşturursanız ve sürecin uykusu esnasında bir <command>SIGALRM</command> sinyali gelirse, bu, eylemciniz çağrılmadan önce <command>sleep</command> işlevinin dönmesine sebep olur. Eğer <command>sleep</command> işlevi, eylemcisi bir alarm isteğinde bulunan ya da <command>SIGALRM</command> sinyalinin eylemini değiştiren bir sinyalle kesildiğinde bu eylemci ile <command>sleep</command> işlevi birbiriyle etkileşecektir.
   </para><para>
GNU sisteminde, <command>sleep</command> işlevi <command>SIGALRM</command>'la etkileşecek şekilde çalışmadığından <command>sleep</command> ve <command>SIGALRM</command> aynı yazılımda güvenle kullanılabilir.
   </para><para>
<indexterm scope="glibc-fn"><primary>nanosleep</primary></indexterm>
<funcsynopsis><funcprototype role="işlev" id="glibc-nanosleep">
<funcdef>int <command>nanosleep</command></funcdef>
<paramdef>(const struct timespec *<varname>istenen</varname>,
 struct timespec       *<varname>kalan</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bir saniyelik çözünürlük yetersizse <command>nanosleep</command> işlevi kullanılabilir. İsminden de anlaşılacağı üzere uyku süresi nanosaniyeler cinsinden belirtilebilir. Asıl uyku süresini, sistemin uygulayabileceği çözünürlüğün katları olan bir tamsayıya yuvarlanacağından istenenden biraz daha uzun olabilir.
   </para><para>
<command>struct timespec</command> yapısı <xref linkend="glibc-Elapsed-Time"/> bölümünde açıklanmıştır.
   </para><para>
*<command>istenen</command> uyku süresini belirtmek için kullanılır.
   </para><para>
İşlev kesintiye uğramadan istenen süreyi doldurursa sıfır ile döner, aksi takdirde kalan süre ile ilgili bilgileri *<varname>kalan</varname> içinde saklayarak döner. İşlev -1 değeri ile döndüğünde <varname>errno</varname> değişkeninde aşağıdaki değerler atanabilir.
   </para><para><variablelist><varlistentry>
   <term><literal>EINTR</literal></term><listitem><para>
Bir sinyal alındığından çağrı durduruldu. İşlevin <varname>kalan</varname> parametresi bir boş gösterici değilse kalan süre ile ilgili bilgiler <varname>kalan</varname> ile gösterilen yapıya yerleştirilir.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>EINVAL</literal></term><listitem><para>
<varname>istenen</varname> parametresi bir kuraldığı değer içeriyor. Değer ya negatif ya da 1000 milyona eşit veya büyük.
      </para></listitem></varlistentry></variablelist></para><para>
Bu işlev çok evreli yazılımlarda bir iptal noktasıdır.  <command>nanosleep</command> çağrısı sırasında evre bazı özkaynakları ayırıyorsa (bellek, dosya tanıtıcı, semafor,v.s) bu bir sorun olabilir. Evre özkaynak ayırdıktan sonra bir iptal alırsa bu özkaynaklar uygulama sonlandırılana kadar ayrılmış olarak kalacaktır. İptal eylemcileri kullanarak <command>nanosleep</command>  çağrılarının oluşturacağı bu olumsuz durum engellenmelidir.
   </para><para>
<command>nanosleep</command> işlevi <filename>time.h</filename> başlık dosyasında bildirilmiştir.
   </para></funcdescr></funcsynopsis></para>
 </chapter>
</part>

