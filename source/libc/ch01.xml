<?xml version="1.0" encoding="UTF-8"?>
<!-- ********************************************************************
        glibc/ch01.xml,v2.36, GFDL,LGPL, NBB, 2023
     ******************************************************************** -->
<part xml:id="glibc-Introduction">
 <title>Giriş</title>
 <titleabbrev>GNU C Kütüphanesinin özellikleri</titleabbrev>
 <preliminary>
  <para>
   <indexterm xml:id="glibc-cp-library" linkend="glibc-cp"><primary>kütüphane</primary></indexterm>
   <dicterm><english>library</english><turkish>kütüphane</turkish></dicterm>
   C dili, girdi/çıktı işlemleri, bellek yönetimi, metin düzenleme ve benzeri işlemlerin uygulanabilmesi için hiçbir yerleşik çözüm sağlamaz. Bu çözümler yazılımlarınızla ilintileyip derleyebileceğiniz bir standart <wordasword>kütüphane</wordasword> içinde tanımlanır.
  </para>
  <para>
   Bu belgenin konusu olan GNU C kütüphanesi, &isoc; standardında belirtilmiş olan tüm kütüphane işlevlerine ek olarak Unix işletim sisteminin diğer türevleri ile POSIX'e özgü olan kütüphane işlevlerini ve GNU sistemine özel oluşumları tanımlar.
  </para>
  <para>
   Bu kılavuz, GNU C kütüphanesinin özelliklerini nasıl kullanacağınızı size anlatmayı amaçlar. Diğer sistemlere taşınamayacak şeylerin neler olduğuna, hangi özelliklerin hangi standartlara uyduğuna ayrıca yeri geldikçe değinilmiştir. Ancak bu kılavuzdaki bilgiler tam bir taşınabilirlik sağlamak amacında değildir.
  </para>
 </preliminary>

 <chapter xml:id="glibc-Getting-Started">
  <title>Başlarken</title>
  <titleabbrev>Bu kılavuz ne içindir ve nasıl kullanılır.</titleabbrev>
  <para>
   Bu kılavuz, sizin en azından, biraz da olsa C yazılım geliştirme diline ve temel yazılım geliştirme kavramlarına aşina olduğunuz varsayımıyla hazırlanmıştır. Özellikle, "geleneksel" &isoc; öncesi dilden ziyade ISO standardı olan C (bkz: <link linkend="glibc-ISO-C">&isoc;</link>) ile bir aşinalık olduğu varsayılmıştır.
  </para>
  <para>
   GNU C kütüphanesi, herbiri birbirleriyle yakın ilişkili özelliklere göre gruplanmış bildirimleri ve tanımları içeren, yazılımınızı işlerken C derleyicisi tarafından kullanılan çeşitli <wordasword>başlık dosyaları</wordasword> içerir. Örneğin &stdio.h; başlık dosyasında girdi ve çıktı işlemleri ile ilgili özellikler, &string.h; dosyasında ise dizge işleme araçları bildirilmiştir. Bu kılavuzdaki konular genelde başlık dosyalarının içeriğine bağlı olarak bölümlenmiştir.
  </para>
  <para>
   Bu kılavuzu ilk kez okuyorsanız, giriş bölümünü tamamen okumalı, diğer bölümlere de bir göz gezdirmelisiniz. GNU C kütüphanesi <emphasis>epeyce</emphasis> çok işlev barındırır ve onların <emphasis>nasıl</emphasis> kullanıldığını hatırlamanızı beklemek pek gerçekçi olmaz. Yazılımınızı geliştirirken kütüphane işlevlerini <emphasis>ne zaman</emphasis> kullanacağınızı ve onların akılda kalmayan özelliklerini bu kılavuzun <emphasis>neresinde</emphasis> bulacağınız bilmek için bu kılavuza bir göz gezdirmeniz gerekir.
  </para>
 </chapter>

 <chapter xml:id="glibc-Roadmap-to-the-Manual">
  <title>Kılavuzun Yol Haritası</title>
  <titleabbrev>Bu kılavuzdaki diğer kısımlarda acaba neler var.</titleabbrev>
  <para>
   Bu bölümde bu kılavuzun devamındaki kısımların içeriği hakkında kısaca bilgi verilmiştir.
  </para>
  <itemizedlist>
   <listitem>
    <para>
     <xref linkend="glibc-Error-Reporting"/> kısmında kütüphane tarafından raporlanan  hataların nasıl saptandığı açıklanmıştır.
    </para>
   </listitem>
   <listitem>
    <para>
     <dicterm><english>dynamically</english><turkish>özdevimli olarak</turkish></dicterm>
     <dicterm><english>automatically</english><turkish>özdevinimli olarak</turkish></dicterm>     <xref linkend="glibc-Memory"/> kısmında sanal belleğin özdevimli tahsisi de dahil sanal ve gerçek belleğin kullanımı ve yönetimi anlatılmıştır. Yazılımın baştan  ne kadar belleğe ihtiyacı olacağı belli değilse bellek gerektikçe özdevimli tahsis edilebilir ve göstericiler üzerinden yönetilebilir.
    </para>
   </listitem>
   <listitem>
    <para>
     <dicterm><english>string</english><turkish>dizge</turkish></dicterm>
     <dicterm><english>string</english><turkish>karakter dizisi</turkish></dicterm>
     <dicterm><english>string</english><turkish>boş karakter sonlandırmalı karakter dizisi</turkish></dicterm>
     <dicterm><english>array</english><turkish>dizi</turkish></dicterm>
     <dicterm><english>null-terminated character array</english><turkish>boş karakter sonlandırmalı dizi</turkish></dicterm>
     <dicterm><english>case conversion</english><turkish>harf büyüklüğü dönüşümü</turkish></dicterm>
     <xref linkend="glibc-Character-Handling"/> kısmı karakter sınıflandırma işlevleri (<function>isspace</function> gibi) ile harf büyüklüğü dönüşümü yapan işlevler hakkında bilgi içerir.
    </para>
   </listitem>
   <listitem>
    <para>
     <xref linkend="glibc-String-and-Array-Utilities"/> kısmında, dizgeler (boş sonlandırmalı karakter dizileri), genel amaçlı bayt dizileri işlevleri ile  kopyalama ve karşılaştıma gibi amaçlara uygun işlevler hakkında bilgi verilmiştir.
    </para>
   </listitem>
   <listitem>
    <para>
     <xref linkend="glibc-Character-Set-Handling"/> kısmında, <type>char</type> veri türü ile ifade edilemeyen karakter kümelerini kullanarak karakterler ve dizgeler üzerinde nasıl işlem yapılacağı açıklanmıştır.
    </para>
   </listitem>
   <listitem>
    <para>
     <xref linkend="glibc-Locales"/> kısmında, kütüphanenin davranışını etkileyen ülke ve dil seçimi ile ilgili bilgiler bulunmaktadır.  Örneğin harflerin sırası, hangi karakter hangisinin büyüğü ya da küçüğüdür, parasal değerler ve tarih dizgeleri nasıl biçimlenir gibi bilgiler bu kısımdadır.
    </para>
   </listitem>
   <listitem>
    <para>
     <xref linkend="glibc-Searching-and-Sorting"/> kısmı, dizilerdeki değerlerin sıralanması ve aranması için karşılaştırma işlevleri hakkında bilgi içerir.
    </para>
   </listitem>
   <listitem>
    <para>
     <dicterm><english>shell</english><turkish>kabuk</turkish></dicterm>
     <xref linkend="glibc-Pattern-Matching"/> kısmında düzenli ifadeler ve kabuk dosya isim kalıpları ile sözcüklerin kabuktaki gibi genişletilmesi ile ilgili işlevlere yer verilmiştir.
    </para>
   </listitem>
   <listitem>
    <para>
     <xref linkend="glibc-I-O-Overview"/> kısmı kütüphanedeki girdi ve çıktı oluşumlarına kapsamlı bir bakış ile dosya isimleri gibi genel kavramlar hakkında bilgiler içermektedir.
    </para>
   </listitem>
   <listitem>
    <para>
     <dicterm><english>stream</english><turkish>akım</turkish></dicterm>
     <dicterm><english>I/O</english><turkish>G/Ç</turkish></dicterm>
     <xref linkend="glibc-I-O-on-Streams"/> kısmında akımlarla (veya <code>FILE&#160;*</code> nesneleri) ilgili giriş/çıkış işlemleri anlatılmıştır. Bunlar &stdio.h; dosyasındaki normal C kütüphanesi işlevleridir.
    </para>
   </listitem>
   <listitem>
    <para>
     <dicterm><english>file descriptor</english><turkish>dosya tanıtıcı</turkish></dicterm>
     <dicterm><english>directory</english><turkish>dizin</turkish></dicterm>
     <dicterm><english>file</english><turkish>dosya</turkish></dicterm>
     <dicterm><english>attribute</english><turkish>öznitelik</turkish></dicterm>
     <xref linkend="glibc-Low-Level-I-O"/> kısmı dosya tanıtıcılar üzerinden giriş/çıkış işlemleri hakkında bilgi içerir. Dosya tanıtıcılar, Unix ailesi işletim sistemlerine özgü düşük seviyeli bir oluşumdur.
    </para>
   </listitem>
   <listitem>
    <para>
     <xref linkend="glibc-File-System-Interface"/> kısmında dosyaların silinmesi, isimlerinin değiştirilmesi, yeni dizin oluturulması gibi dosyalar üzerindeki işlemler anlatılmıştır. Bu kısım ayrıca dosyaların sahipleri, dosya koruma kipleri gibi dosya özelliklerine nasıl erişildiği hakkında bilgileri de içerir.
    </para>
   </listitem>
   <listitem>
    <para>
     <dicterm><english>pipe</english><turkish>boru</turkish></dicterm>
     <dicterm><english>pipe</english><turkish>ardışık komutlar</turkish></dicterm>
     <dicterm><english>stack</english><turkish>yığıt</turkish></dicterm>
     <dicterm><english>FIFO (First In First Out)</english><turkish>FIFO (ilk giren ilk çıkar - bir yığıt işlemidir)</turkish></dicterm>
     <dicterm><english>FIFO</english><turkish>isimli boru</turkish></dicterm>
     <dicterm><english>FIFO</english><turkish>isimli ardışık komutlar</turkish></dicterm>
     <xref linkend="glibc-Pipes-and-FIFOs"/> kısmı süreçler arası basit iletişim mekanizması hakkında bilgiler içerir. Ardışık komutlar, ilişkili (biri diğerinin çocuğu gibi) iki süreç arasındaki iletişim için kullanılırken, isimli ardışık komutlar aynı makine üzerindeki ortak dosya sistemini paylaşan süreçler arasında iletişim için kullanılır.
    </para>
   </listitem>
   <listitem>
    <para>
     <dicterm><english>socket</english><turkish>soket</turkish></dicterm>
     <dicterm><english>host</english><turkish>konak</turkish></dicterm>
     <dicterm><english>network</english><turkish>ağ</turkish></dicterm>
     <xref linkend="glibc-Sockets"/> kısmı bir ağ üzerinden haberleşen farklı makineler üzerinde çalışan süreçler arasındaki daha karmaşık bir süreçler arası iletişim mekanizması hakkında bilgiler içerir. Bu kısımda ayrıca internet konak adreslemesi ile sistemin ağ veritabanının nasıl kullanıldığı da anlatılmıştır.
    </para>
   </listitem>
   <listitem>
    <para>
     <dicterm><english>terminal</english><turkish>uçbirim</turkish></dicterm>
     <xref linkend="glibc-Low-Level-Terminal-Interface"/> kısmında bir uçbirim aygıtının özniteliklerini nasıl değiştirebileceğiniz anlatılmıştır. Örneğin bir kullanıcının yazdığı karakterlerin görüntülenmesi engellenmek isteniyorsa bu kısım okunmalıdır.
    </para>
   </listitem>
   <listitem>
    <para>
     <dicterm><english>random-number generator</english><turkish>rasgele sayı üreteci</turkish></dicterm>
     <dicterm><english>exponential function</english><turkish>üstel işlev</turkish></dicterm>
     <dicterm><english>remainder function</english><turkish>kalan işlevi</turkish></dicterm>
     <dicterm><english>floating-point number</english><turkish>gerçek sayı</turkish></dicterm>
     <dicterm><english>complex number</english><turkish>karmaşık sayı</turkish></dicterm>
     <dicterm><english>integer</english><turkish>tamsayı</turkish></dicterm>
     <xref linkend="glibc-Mathematics"/> kısmı matematik işlevleri kütüphanesi hakkındadır. Gerçek sayılarla trigonometrik veya üstel işlevler, tamsayılarda bölümden kalan işlevleri ve rasgele sayı üreteçleri gibi konulara değinilmiştir.
    </para>
   </listitem>
   <listitem>
    <para>
     <xref linkend="glibc-Arithmetic"/> kısmında basit aritmetik işlemler, gerçek sayıların incelenmesi ve dizgelerdeki sayıların okunması ile ilgili işlevler açıklanmıştır.
    </para>
   </listitem>
   <listitem>
    <para>
     <dicterm><english>timer</english><turkish>zamanlayıcı</turkish></dicterm>
     <dicterm><english>schedule</english><turkish>zaman çizelgesi</turkish></dicterm>
     <xref linkend="glibc-Date-and-Time"/> kısmında, takvim ve işlemci zamanının ölçümleri ile zamanlayıcıların ayarlanması ile ilgili işlevler anlatılmıştır.
    </para>
   </listitem>
   <listitem>
    <para>
     <xref linkend="glibc-Non-Local-Exits"/> kısmında, <function>setjmp</function> ve <function>longjmp</function> işlevleri anlatılmıştır. Bu işlevler, <statement>goto</statement> deyiminin yaptığı gibi bir işlevden diğerine atlamak için kullanılan atlama işlevleridir.
    </para>
   </listitem>
   <listitem>
    <para>
     <xref linkend="glibc-Signal-Handling"/> kısmı sinyaller hakkındadır. Sinyal nedir, bir sinyal alındığında neler yapılabilir ve yazılımınızın hassas işlemler yapılan bir bölümü çalışırken alınan sinyallerin engellenmesi gibi bilgiler içerir.
    </para>
   </listitem>
   <listitem>
    <para>
     <dicterm><english>program</english><turkish>yazılım</turkish></dicterm>
     <dicterm><english>program</english><turkish>uygulama</turkish></dicterm>
     <dicterm><english>programming</english><turkish>yazılımlama</turkish></dicterm>
     <dicterm><english>programming</english><turkish>yazılım geliştirme</turkish></dicterm>
     <dicterm><english>command-line</english><turkish>komut satırı</turkish></dicterm>
     <dicterm><english>environment variable</english><turkish>ortam değişkeni</turkish></dicterm>
     <xref linkend="glibc-Program-Basics"/> kısmında yazılımınızın komut satırı seçeneklerine ve ortam değişkenlerine nasıl erişebileceğiniz anlatılmıştır.
    </para>
   </listitem>
   <listitem>
    <para>
     <xref linkend="glibc-Processes"/> kısmı,  yeni süreçlerin başlatılması ve uygulamaların çalıştırılması hakkında bilgi içerir.
    </para>
   </listitem>
   <listitem>
    <para>
     <dicterm><english>job control</english><turkish>iş denetimi</turkish></dicterm>
     <dicterm><english>hardware</english><turkish>hırdavat</turkish></dicterm>
     <dicterm><english>hardware</english><turkish>donanım</turkish></dicterm>
     <xref linkend="glibc-Job-Control"/> kısmında, uçbirimin denetimi ve süreç grupları üzerindeki işlemlerle ilgili işlevler açıklanmıştır. Bu işlevler, kabuk yazmakla ilgili olup özellikle iş denetimi konusundadır.
    </para>
   </listitem>
   <listitem>
    <para>
     <xref linkend="glibc-Name-Service-Switch"/> kısmı, sistem veritabanındaki isimlerde arama, hangi veritabanı için hangi hizmetin kullanıldığının saptanması ve bu hizmetlerin nasıl gerçekleştirildiği gibi bilgiler içerir. Böylece hizmet yordamları oluşturulabilir.
    </para>
   </listitem>
   <listitem>
    <para>
     <xref linkend="glibc-User-Database"/> ve <xref linkend="glibc-Group-Database"/>, kısımlarında kullanıcı ve grup veritabanlarına nasıl erişileceği anlatılmıştır.
    </para>
   </listitem>
   <listitem>
    <para>
     <xref linkend="glibc-System-Management"/> kısmında, yazılımların altında çalıştığı donanım ve yazılımlar hakkındaki bilgilerin alınması ve denetimini sağlayan işlevler anlatılmıştır.
    </para>
   </listitem>
   <listitem>
    <para>
     <xref linkend="glibc-System-Configuration"/> kısmında, çeşitli işletim sistemlerinin sınırları hakkında nasıl bilgi edinileceği anlatılmıştır. Bu değişkenlerin çoğu POSIX ile uyumluluk içindir.
    </para>
   </listitem>
   <listitem>
    <para>
     <xref linkend="glibc-Language-Features"/> kısmında C dilinin standart parçaları için kütüphanedeki destek hakkında bilgiler bulunmaktadır. Bunlar,  <operator>sizeof</operator> işleci, <literal>NULL</literal> sembolik sabiti gibi oluşumlar ile girdi sayısı değişken işlevlerin nasıl yazıldığı, sayısal türlerin aralıkları ve çeşitli özellikleri gibi konulardır. Ayrıca kodunuza basit tuzaklar koyarak, sınama sonucuna göre uyarı iletileri alabileceğiniz basit bir hata ayıklama mekanizmasından da bahsedilmiştir.
    </para>
   </listitem>
   <listitem>
    <para>
     <xref linkend="glibc-Library-Summary"/> kısmı oluşum hakkında özet bir bilgi verdiği gibi oluşum hakkında daha ayrıntılı bilginin nerede bulunabileceği bilgisini de içerir. Bu ek bölüm ayrıca, örneğin, bir işlevin bağımsız değişkenlerinin türleri ve sırasını bilmek istediğinizde faydalıdır. Ayrıca her işlev, değişken veya makronun türetildiği sistem veya standardın ne olduğu da bu kısımdan öğrenilebilir.
    </para>
   </listitem>
   <listitem>
    <para>
     <xref linkend="glibc-Installation"/> kısmında GNU C Kütüphanesinin sisteme kurulumu ile  bulunabilecek hataların nasıl bildireceği açıklanmıştır.
    </para>
   </listitem>
   <listitem>
    <para>
     <xref linkend="glibc-Maintenance"/> kısmında, kütüphanenin yeni bir sisteme nasıl taşınacağı, kütüphaneye yeni işlevlerin nasıl ekleneceği gibi bilgilere yer verilmiştir.
    </para>
   </listitem>
  </itemizedlist>
  <para>
   Kullanılmak istenen kütüphane oluşumunun ismi biliniyorsa doğrudan <xref linkend="glibc-Library-Summary"/> kısmına bakılabilir. Bu kısım oluşum hakkında özet bir bilgi verdiği gibi oluşum hakkında daha ayrıntılı bilginin nerede bulunabileceğin bilgisini de içerir. Bu ek bölüm ayrıca, örneğin, bir işlevin bağımsız değişkenlerinin türleri ve sırasını bilmek istediğinizde faydalıdır. Ayrıca her işlev, değişken veya makronun türetildiği sistem veya standardın ne olduğu da bu kısımdan öğrenilebilir.
  </para>
 </chapter>

 <chapter xml:id="glibc-Standards-and-Portability">
  <title>Standartlar ve Taşınabilirlik</title>
  <titleabbrev>GNU C kütüphanesinin üzerine inşa edildiği standartlar ve kaynaklar.</titleabbrev>
  <preliminary><para>
   <indexterm xml:id="glibc-cp-sap" linkend="glibc-cp"><primary>standartlar</primary></indexterm>
   Bu bölüm GNU C kütüphanesinin üzerine inşa edildiği çeşitli standartlar ve kaynaklar hakkındadır. Bu standartlar ve kaynaklar, &isoc; ve POSIX standartları ile Sistem V ve Berkeley Unix gerçeklenimlerinden oluşur.
  </para>
  <para>
   Bu kılavuzun birincil hedefi GNU kütüphanesinin içerdiklerini daha verimli nasıl kullanacağınızı anlatmaktır. Ancak, yazılımlarınızı bu standartlarla uyumlu yapmak ya da GNU dışındaki işletim sistemlerine de taşınabilir kılmakla ilgileniyorsanız, bu, kütüphaneyi nasıl kullanacağınızı etkiler. Bu bölümde bu standartlara kısaca değinilecek, böylece kılavuzun içinde bunlara rastladıkça onların ne olduğunu bileceksiniz.
  </para>
  <para>
   <xref linkend="glibc-Library-Summary"/> bölümünde kütüphanenin içerdiği tüm işlevlerin ve sembollerin abecesel listesini bulabilirsiniz. Bu liste ayrıca her işlev ve sembolün hangi standartlara uyduğu bilgisini de içerir.
  </para></preliminary>
  <sect1 xml:id="glibc-ISO-C">
   <title>&isoc;</title>
   <titleabbrev>C yazılım geliştirme dili için uluslararası standart.</titleabbrev>
   <para>
    <indexterm xml:id="glibc-cp-isoc" linkend="glibc-cp"><primary>&isoc;</primary></indexterm>
    GNU C kütüphanesi Amerikan Ulusal Standartları Enstitüsü (ANSI) tarafından yayınlanmış <citation>American National Standard X3.159-1989—“ANSI C”</citation> ve daha sonra Uluslararası Standartlar Teşkilatı (ISO) tarafından kabul edilmiş <citation>ISO/IEC 9899:1990, “Programming languages—C”</citation> C standardı ile uyumludur. Daha genel bir kabul gördüğünden dolayı biz &isoc; standardını temel alıyoruz. GNU kütüphanesini oluşturan içerik ve başlık dosyaları, &isoc; standardı tarafından belirtilenlerin bir üst kümesidir.
    <indexterm xml:id="glibc-pg-gcc" linkend="glibc-pg"><primary>gcc</primary></indexterm>
   </para>
   <para>
    &isoc; standardına tamamen bağlı kalmak istiyorsanız, yazılımınızı GNU C derleyicisi ile derlerken <filename>-ansi</filename> seçeneğini kullanmalısınız. Bu seçenek derleyiciye ek özellikler açıkça istenmediği sürece kütüphane başlık  dosyalarından <emphasis>sadece</emphasis> &isoc; standardı olan şeyleri tanımlamasını söyler. Bu konuda daha fazla bilgi <xref linkend="glibc-Feature-Test-Macros"/> bölümünde bulunabilir.
   </para>
   <para>
    Kütüphaneye sadece &isoc; özelliklerini içerecek şekilde kısıtlama getirilebilmesi önemlidir, çünkü &isoc;, kütüphane gerçeklemelerinde tanımlanan isimlere sınırlama  getirir ve GNU genişletmeleri bu kısıtlamalara uymaz. Bu sınırlamalar hakkında daha fazla bilgi edinmek için <xref linkend="glibc-Reserved-Names"/> bölümüne bakınız.
   </para>
   <para>
    Bu kılavuzda &isoc; ile diğer C standartları arasındaki farkların tüm ayrıntıları verilmeye çalışılmamıştır. Sadece farklı C standartları altında taşınabilir yazılımlar geliştirebilmeniz için fikir verir ancak  eksiksiz bilgi sağlamayı hedeflemez.
   </para>
  </sect1>
  <sect1 xml:id="glibc-POSIX">
   <title>POSIX (Taşınabilir İşletim Sistemi Arayüzü)</title>
   <subtitle>POSIX (The Portable Operating System Interface)</subtitle>
   <titleabbrev>İşletim sistemleri için ISO/IEC 9945 (nam-ı diğer IEEE 1003) standartları.</titleabbrev>
   <indexterm xml:id="glibc-cp-posix" linkend="glibc-cp"><primary>POSIX</primary></indexterm>
   <indexterm xml:id="glibc-cp-posix1" linkend="glibc-cp"><primary>POSIX.1</primary></indexterm>
   <indexterm xml:id="glibc-cp-10031" linkend="glibc-cp"><primary>ANSI/IEEE Std 1003.1</primary></indexterm>
   <indexterm xml:id="glibc-cp-99451" linkend="glibc-cp"><primary>ISO/IEC 9945-1:1996</primary></indexterm>
   <indexterm xml:id="glibc-cp-posix2" linkend="glibc-cp"><primary>POSIX.2</primary></indexterm>
   <indexterm xml:id="glibc-cp-10032" linkend="glibc-cp"><primary>ANSI/IEEE Std 1003.2</primary></indexterm>
   <indexterm xml:id="glibc-cp-99452" linkend="glibc-cp"><primary>ISO/IEC 9945-2:1993</primary></indexterm>
   <para>
    GNU kütüphanesi ayrıca, <wordasword>Bilgisayar Ortamları için Taşınabilir İşletim Sistemi Arayüzü</wordasword> olarak da bilinen ISO  <firstterm>POSIX</firstterm> ailesi standartlarla da (ISO/IEC 9945) uyumludur.  Bunlar ayrıca ANSI/IEEE Std 1003 olarak da yayınlanmıştır. POSIX genellikle Unix işletim sisteminin çeşitli sürümlerinden türetilmiştir.
   </para>
   <para>
    <dicterm><english>library facilities</english><turkish>kütüphane oluşumları</turkish></dicterm>
    <dicterm><english>superset</english><turkish>üst küme</turkish></dicterm>
    <dicterm><english>functionality</english><turkish>işlevsellik</turkish></dicterm>
    <dicterm><english>lower-level</english><turkish>düşük seviye</turkish></dicterm>
    POSIX standartları ile belirtilen kütüphane oluşumları &isoc; ile belirlenenlerin bir üst kümesidir. POSIX, yeni ek işlevler ya da &isoc; işlevlerine eklenen bazı özellikleri belirtir. Genellikle POSIX standartları tarafından tanımlanan ek gereksinimler ve işlevsellik, farklı işletim sistemi ortamlarında çalışabilen genel yazılım geliştirme dilinden ziyade işletim sistemlerinin belli çeşitlerine düşük seviyede destek sağlamak amacındadır.
   </para>
   <para>
    GNU C kütüphanesi <citation>ISO/IEC 9945-1:1996, POSIX Sistem Uygulaması Geliştirme Arayüzü</citation> tarafından belirlenen işlevlerin tümünü gerçekler. Kılavuzda bu standart bahis konusu olduğunda POSIX.1 nitelemesi kullanılacaktır. Bu standart tarafından &isoc; oluşumlarına ek birincil genişletmeler, dosya sistemi arayüzü ilkelleri (<xref linkend="glibc-File-System-Interface"/>), aygıta özgü uçbirim denetim işlevleri (<xref linkend="glibc-Low-Level-Terminal-Interface"/>) ile süreç denetim işlevlerini (<xref linkend="glibc-Processes"/>) içerir.
   </para>
   <para>
    <dicterm><english>regular expression</english><turkish>düzenli ifade</turkish></dicterm>
    <dicterm><english>regexp</english><turkish>düzifd</turkish></dicterm>
    <dicterm><english>pattern matching</english><turkish>kalıp eşleme</turkish></dicterm>
    Ayrıca, <citation>ISO/IEC 9945-2:1993, POSIX Kabuk and Komutlar standardı</citation> (POSIX.2) içindeki bazı oluşumlara da GNU kütüphanesinde yer verilmiştir. Bunlar kalıp eşleme oluşumlarını ve düzenli ifadeleri kullanan uygulamalardır(Bkz. <xref linkend="glibc-Pattern-Matching"/>).
   </para>
   <sect2 xml:id="glibc-POSIX-Safety-Concepts">
    <title>POSIX Güvenlik Kavramları</title>
    <titleabbrev>POSIX'teki güvenlik kavramları</titleabbrev>
    <indexterm xml:id="glibc-cp-safety" linkend="glibc-cp"><primary>POSIX Güvenlik Kavramları</primary></indexterm>
    <para>
     Bu kılavuz, GNU C Kütüphanesi işlevlerinin çeşitli güvenilirlik özelliklerini, işlevlerin gösterimlerinin ardından gelen ve şuna benzer satırlarda belgelemektedir:
    </para>
    <para>Evresel Güvenilirlik: | MT-Safe | AS-Safe | AC-Safe |</para>
    <para>
     Özellikler, <literal>Thread-</literal>, <literal>Async-Signal-</literal> ve <literal>Async-Cancel- -Safety</literal> gibi güvenlik bağlamları için POSIX standardında belirtilen kurallara göre değerlendirilir. Bunu standart tanımların anlamını yakalamaya çalışan, bu özelliklerin sezgisel tanımları izler.
    </para>
    <glosslist>
     <glossentry>
      <indexterm linkend="glibc-cp" xml:id="glibc-cp-mtsafe"><primary>MT-Safe (Çok Evreli Güvenilir)</primary></indexterm>
      <indexterm linkend="glibc-cp" xml:id="glibc-cp-tsafe"><primary>Thread-Safe (Evreli Güvenilir)</primary></indexterm>
      <glossterm><code>MT-Safe</code>, <code>Thread-Safe</code></glossterm>
      <glossdef>
       <para>
        <code>MT-Safe</code> (Çok Evreli Güvenilir) veya <code>Thread-Safe</code> (Evreli Güvenilir) işlevlerin başka evreler varken çağrılması güvenlidir. <code>MT-Safe</code> içindeki MT, "Çok Evreli" anlamında bir kısaltmadır.
       </para>
       <para>
        <code>MT-Safe</code> olmak, o işlevin bölünmez bütünlükte olduğu veya POSIX'in kullanıcılara sunduğu eşzamanlı bellek tahsis mekanizmalarından birinin kullanıldığı anlamına gelmez. İşlem sırasında  <code>MT-Safe</code> işlevlerin çağrılmasının bir  <code>MT-Safe</code> birleşimi vermemesi bile mümkündür. Örneğin, iki  <code>MT-Safe</code> işlevin peşpeşe evresel çağrı yapması, diğer evrelerdeki eşzamanlı çağrılarla yıkıcı şekilde etkileşime gireceğinden, bunların tek bir bölünmez bütün olarak yürütülmesini garanti etmez.
       </para>
       <para>
        <dicterm><english>inlining</english><turkish>satırlaştırma</turkish></dicterm>
        Kütüphane arayüzleri genelinde işlevlerde satırlaştırma yapabilen tüm en iyilemeler, güvenli olmayan yeniden sıralamaya neden olabileceğinden GNU C Kitaplığı arayüzü genelinde satırlaştırma (inlining) yapılması önerilmez. Belgelenmiş  <code>MT-Safe</code> durumu, yazılımın tamamının en iyilenmesi durumunda garanti edilmez. Ancak, kullanıcıya görünür başlık dosyalarında tanımlanan işlevler, satırlaştırma için güvenilir olacak şekilde tasarlanmıştır.
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <indexterm linkend="glibc-cp" xml:id="glibc-cp-assafe"><primary>AS-Safe (Önalanda Sinyal Güvenilir)</primary></indexterm>
      <indexterm linkend="glibc-cp" xml:id="glibc-cp-as-safe"><primary>Async-Signal-Safe (Önalan-Sinyal-Güvenilir)</primary></indexterm>
      <glossterm><code>AS-Safe</code>, <code>Async-Signal-Safe</code></glossterm>
      <glossdef>
       <para>
        <code>AS-Safe</code> (Önalanda Sinyal Güvenilir) veya <code>Async-Signal-Safe</code> (Önalan-Sinyal-Güvenilir) işlevlerin önalanda sinyal işleyiciler varken çağrılması güvenlidir.  <code>AS-Safe</code> içindeki AS, "Önalanda Sinyal" anlamında bir kısaltmadır.
       </para>
       <para>
        <code>AS-Safe</code> olan pek çok işlev, <code>errno</code> değeri atayabilir veya kayan- noktalı sayı ortamını değiştirebilir, çünkü bunu yapmaları onları sinyal işleyicilerde kullanılamaz duruma getirmez. Ancak, önalandaki sinyal işleyicileri bu evreye-özgülük durumunu değiştirirse uygulamalar yanlış çalışabilir ve sinyal işleme mekanizmasının bunu koruyacağına güvenilemez. Bu nedenle,<code>errno</code> değeri atayabilecek veya  kayan- noktalı sayı ortamını değiştirebilecek işlevleri çağıran sinyal işleyicileri özgün değerlerini kaydetmeli ve geri dönmeden önce bu özgün değerleri yerine koymalıdır.
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <indexterm linkend="glibc-cp" xml:id="glibc-cp-acsafe"><primary>AC-Safe (Önalanda İptal Güvenilir)</primary></indexterm>
      <indexterm linkend="glibc-cp" xml:id="glibc-cp-ac-safe"><primary>Async-Cancel-Safe (Önalan-İptal-Güvenilir)</primary></indexterm>
      <glossterm><code>AC-Safe</code>, <code>Async-Cancel-Safe</code></glossterm>
      <glossdef>
       <para>
        <code>AC-Safe</code> (Önalanda İptal Güvenilir) veya <code>Async-Cancel-Safe</code> (Önalanda-İptal-Güvenilir) işlevlerin çağrılması önalanda iptal etkin olduğunda güvenlidir.  <code>AC-Safe</code> içindeki AC, "Önalanda İptal" anlamında bir kısaltmadır.
       </para>
       <para>
        POSIX standardı yalnızca üç <code>AC-Safe</code> işlev tanımlar:  <function>pthread_cancel</function>, <function>pthread_setcancelstate</function> ve <function>pthread_setcanceltype</function>. Günümüzde GNU C Kütüphanesi bu üç işlevle ilgili hiçbir garanti vermez, yalnızca hangi işlevlerin halihazırda <code>AC-Safe</code> olduğunu belgelendirir. Bu belgelendirme GNU C Kütüphanesi geliştiricilerinin kullanımına ayrılmıştır.
       </para>
       <para>
        Tıpkı sinyal işleyiciler gibi, iptal temizleme yordamları da ihtiyaç duydukları kayan-noktalı ortamı yapılandırmalıdır. Bu yordamlar, özellikle önalanda iptal etkin olduğunda, bir kayan-noktalı ortam olduğunu varsayamaz. Kayan-noktalı ortamının yapılandırması atomik olarak (bölünmez bütünlükte) gerçekleştirilemezse, karşılaşılan ortamın kendi içinde tutarsız olması da mümkündür.
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
     <indexterm linkend="glibc-cp" xml:id="glibc-cp-mtunsafe"><primary>MT-Unsafe (Çok Evreli Güvenilmez)</primary></indexterm>
     <indexterm linkend="glibc-cp" xml:id="glibc-cp-tunsafe"><primary>Thread-Unsafe (Evreli Güvenilmez)</primary></indexterm>
     <indexterm linkend="glibc-cp" xml:id="glibc-cp-asunsafe"><primary>AS-Unsafe (Önalanda Sinyal Güvenilmez)</primary></indexterm>
     <indexterm linkend="glibc-cp" xml:id="glibc-cp-as-unsafe"><primary>Async-Signal-Unsafe (Önalanda-Sinyal-Güvenilmez)</primary></indexterm>
     <indexterm linkend="glibc-cp" xml:id="glibc-cp-acunsafe"><primary>AC-Unsafe (Önalanda İptal Güvenilmez)</primary></indexterm>
     <indexterm linkend="glibc-cp" xml:id="glibc-safety-ac-unsafe"><primary>Async-Cancel-Unsafe (Önalanda-İptal-Güvenilmez)</primary></indexterm>
      <glossterm><code>MT-Unsafe</code>, <code>AS-Unsafe</code>, <code>AC-Unsafe</code></glossterm>
      <glossdef>
       <para>
        <code>MT-Unsafe</code> (Çok Evreli Güvenilmez), <code>AS-Unsafe</code> (Önalanda Sinyal Güvenilmez), <code>AC-Unsafe</code> (Önalanda İptal Güvenilmez) özellikli işlevlerin çağrılması yukarıda açıklanan güvenlik bağlamları içinde güvenli değildir. Böyle bağlamlar içinde çağrılmaları tanımsız davranışa yol açar.
       </para>
       <para>
        Güvenilir bağlamda açıkça "Güvenilir" olarak belgelenmemiş işlevler "Güvenilmez" olarak kabul edilmelidir.
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
     <indexterm xml:id="glibc-cp-preliminary" linkend="glibc-cp"><primary>Preliminary (Evresel Güvenilirlik)</primary></indexterm>
      <glossterm><code>Preliminary</code></glossterm>
      <glossdef>
       <para>
        <code>Preliminary</code> güvenilirlik (Evresel Güvenilirlik) özellikleri, bu özelliklerin GNU C Kitaplığının <emphasis>gelecekteki sürümlerinde hesaba katılmayabileceği varsayımıyla</emphasis> belgelenmiştir.
       </para>
       <para>
        Bu belgeye konu evresel güvenilirlik özellikleri, mevcut ve gelecekteki standartlar tarafından zorunlu kılınan ve izin verilen özelliklerin değil, mevcut GNU C Kütüphanesi gerçekleniminin özelliklerinin değerlendirilmesinin sonucudur.
       </para>
       <para>
        Standartlara uymaya çalışmamıza rağmen bazı durumlarda, standart tarafından talep edilmese bile, gerçeklenimimiz güvenilirdir ve diğer durumlarda gerçeklenimimiz standart güvenilirlik gereksinimlerini karşılamamaktadır. İkinci durum büyük olasılıkla gerçeklenimdeki hatalardır; İlki, "Evresel Güvenilirlik" bağlamında ele alınmamalıdır: Gelecekteki standartlar, mevcut gerçeklenimin sağladığı ek güvenlik özellikleriyle uyumlu olmayan değişiklikler gerektirebilir.
       </para>
       <para>
        Ayrıca, POSIX standardı ayrıntılı bir güvenilirlik tanımı da sunmamaktadır. POSIX'in "çağırmak için güvenilir" ile, yazılım tanımsız davranış başlatmadığı sürece, "çağırmak için güvenilir" işlevin belirtildiği gibi davrandığını ve diğer işlevlerin belirtilen davranışlarından sapmasına neden olmadığını kastettiğini varsayıyoruz. Gevşek güvenilirlik tanımlarını, kullanılacak en iyi tanımlar oldukları için değil, ancak bu kılavuzu POSIX ile uyumlu hale getirdiği için kullanmayı seçtik.
       </para>
       <para>
        Bunların ön tanımlar ve ek açıklamalar olduğu, tanımların belirli yönlerinin hala tartışıldığı, açıklanmaya veya değişikliğe konu olabileceği unutulmamalıdır.
       </para>
       <para>
        Zamanla, "Evresel Güvenilirlik" bilgilerini, arayüzlerimiz kadar istikrarlı, kararlı taahhütlere dönüştürmeyi düşünüyoruz. Yaptığımızda görüleceği gibi, <code>Preliminary</code> anahtar sözcüğünü (bu çeviride "Evresel Güvenilirlik" karşılığını) güvenilirlik bilgilerinden kaldıracağız. Bununla birlikte, anahtar sözcük olarak kaldığı sürece, gelecekteki davranışımızın teminatı olarak görülmemelidir.
       </para>
      </glossdef>
     </glossentry>
    </glosslist>
    <para>
     "Evresel Güvenilirlik" bilgilerinde görünen diğer anahtar sözcükler sonraki bölümlerde tanımlanmıştır.
    </para>
   </sect2>
   <sect2 xml:id="glibc-Unsafe-Features">
    <title>Güvenilmez Özellikler</title>
    <titleabbrev>İşlevleri güvenilmez kılan özellikler</titleabbrev>
    <indexterm xml:id="glibc-cp-unsafety" linkend="glibc-cp"><primary>Güvenilmez Özellikler</primary></indexterm>
    <para>
     Belirli bağlamlarda çağrılması güvenli olmayan işlevlerin çağrılmalarını güvensiz kılan özellikleri belirli anahtar sözcüklerle sınıflandırılmıştır. Bu bölümdeki <code>AS-Unsafe</code> özellikler, önalanda sinyaller etkinken çağrılması asla güvenilir olmayan işlevleri belirtir. <code>AC-Unsafe</code> özellikler ise önalanda iptal etkinken çağrılması asla güvenilir olmayan işlevleri belirtir. Bu bölümde <code>MT-Unsafe</code> özelliklerle ilgili sınıflama yoktur.
    </para>
    <glosslist>
     <glossentry>
      <indexterm linkend="glibc-cp" xml:id="glibc-safety-lock"><primary>lock (kilit)</primary></indexterm>
      <glossterm><code>lock</code></glossterm>
      <glossdef>
       <para>
        <code>AS-Unsafe</code> özellik olarak <code>lock</code> ile belirtilen işlevler, ardışık olmayan bir kilidi tutarken sinyalle kesintiye uğrayabilir. Sinyal işleyici aynı kilidi alan başka bir işlevi çağırırsa, sonuç kısır döngüdür.
       </para>
       <para>
        <code>AC-Unsafe</code> özellik olarak <code>lock</code> ile belirtilen işlevler, önalanda iptal edilirse, yürütmeleri bu şekilde kesintiye uğratılmamış olsaydı serbest bırakacakları bir kilidi serbest bırakamayabilir. Bir kilit bir kere alındıktan sonra, o kilidi alma girişimleri sürekli engellenir.
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <indexterm linkend="glibc-cp" xml:id="glibc-safety-corrupt"><primary>corrupt (bozuk)</primary></indexterm>
      <glossterm><code>corrupt</code></glossterm>
      <glossdef>
       <para>
        <code>AS-Unsafe</code> özellik olarak <code>corrupt</code> ile belirtilen işlevler, veri yapılarını bozabilir ve kesintiye sebep olduklarında veya başka bir işlev tarafından kesintiye uğratıldıklarında yanlış davranabilir. <code>lock</code> ile belirtilen işlevlerin tersine, bunlar, <code>MT-Safety</code> sorunlarından kaçınmak için ardışık kilitler alır, ancak bu, bir sinyal işleyicinin kısmen güncellenmiş bir veri yapısını gözlemlemesini durdurmak için yeterli değildir. Kesintiye uğrayan işlevin sinyal işleyiciler tarafından yapılan güncellemeleri fark etmemesi daha fazla bozulmaya neden olabilir.
       </para>
       <para>
        <code>AC-Unsafe</code> özellik olarak <code>corrupt</code> ile belirtilen işlevler, veri yapılarını bozuk, kısmen güncellenmiş durumda bırakabilir, veri yapısının sonraki kullanımlarında işlev yanlış davranabilir.
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <indexterm linkend="glibc-cp" xml:id="glibc-safety-heap"><primary>heap (yığın)</primary></indexterm>
      <glossterm><code>heap</code></glossterm>
      <glossdef>
       <para>
        <code>heap</code> ile belirtilen işlevler, <function>malloc</function>/<function>free</function> işlev ailesinden yığın bellek yönetimi işlevlerini çağırabilir ve yalnızca bu işlevler kadar güvenilirdir. <code>heap</code> şuna eşdeğerdir:
       </para>
       <para>
        | AS-Unsafe lock | AC-Unsafe lock fd mem |
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <indexterm linkend="glibc-cp" xml:id="glibc-safety-dlopen"><primary>dlopen</primary></indexterm>
      <glossterm><code>dlopen</code></glossterm>
      <glossdef>
       <para>
       <code>dlopen</code> ile belirtilen işlevler, paylaşımlı kütüphaneleri geçerli yürütme imgesine yüklemek için özdevimli yükleyiciyi kullanır. Bu, dahili özdevimli yükleyicinin kilitleri tutulurken dosyalar açılabilir, bunlar belleğe eşlenebilir, ek bellek tahsis edilebilir, semboller çözümlenebilir, yer değiştirmeler uygulanabilir ve daha pek çok şey yapılabilir.
       </para>
       <para>
        Kilitler, bu işlevlerin <code>AS-Unsafe</code> ve <code>AC-Unsafe</code>  olması için yeterlidir, ancak başka sorunlar ortaya çıkabilir. Şu anda <code>dlopen</code>, kendi üzerinden gündeme getirilen tüm olası güvenilirlik sorunları için bir yer tutucudur.
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <indexterm linkend="glibc-cp" xml:id="glibc-safety-plugin"><primary>plugin (eklenti)</primary></indexterm>
      <indexterm linkend="glibc-cp" xml:id="glibc-safety-plugin-nss"><primary>NSS</primary></indexterm>
      <indexterm linkend="glibc-cp" xml:id="glibc-safety-plugin-iconv"><primary>iconv</primary></indexterm>
      <glossterm><code>plugin</code></glossterm>
      <glossdef>
       <para>
        <code>plugin</code> ile belirtilen işlevler GNU C Kütüphanesinin dışındaki eklentilerden kod çalıştırabilir. Bu tür eklenti işlevlerinin <code>MT-Safe</code>, <code>AS-Unsafe</code> ve <code>AC-Unsafe</code> olduğu varsayılır. Bu tür eklentilere örnek olarak yığıt boşaltma kütüphaneleri, ad hizmeti anahtarı (NSS) ve karakter kümesi dönüştürme (iconv) eklentileri verilebilir.
       </para>
       <para>
        Örnek olarak belirtilen eklentilerin tümü <code>dlopen</code> aracılığıyla getirilse de, <code>plugin</code> anahtar sözcüğü, özdevimli yükleyicinin veya <code>libdl</code> arayüzlerinin herhangi bir doğrudan katkısını gerektirmez, bunlar <code>dlopen</code> kapsamındadır. Örneğin, bir işlev zaten çözülmüş işlevleri çağırırken başka bir işlev bir modülü yükleyip modüldeki işlevlerin bazı adreslerini buluyorsa, ilki <code>plugin</code> ile, ikincisi <code>dlopen</code> ile imlenir. Tüm eylemleri tek bir işlev yerine getiriyorsa, her iki imi de alır.
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <indexterm linkend="glibc-cp" xml:id="glibc-safety-i18n"><primary>i18n</primary></indexterm>
      <glossterm><code>i18n</code></glossterm>
      <glossdef>
       <para>
        <code>i18n</code> ile belirtilen işlevler <code>gettext</code> ailesinden 18n işlevlerini çağırabilir ve ancak bu işlevler kadar güvenilir olabilir. <code>i18n</code> şuna eşdeğerdir:
       </para>
       <para>
        | MT-Safe env | AS-Unsafe corrupt heap dlopen | AC-Unsafe corrupt
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <indexterm linkend="glibc-cp" xml:id="glibc-safety-timer"><primary>timer (zaman)</primary></indexterm>
      <glossterm><code>timer</code></glossterm>
      <glossdef>
       <para>
        <code>timer</code> ile belirtilen işlevler, bir sistem çağrısı veya uzun süren bir işlem için zaman aşımı ayarlamak üzere <function>alarm</function> işlevini veya benzerini kullanır. Çok evreli bir yazılımda, zaman aşımı sinyalinin farklı bir evreyi kesintiye uğratması ve dolayısıyla amaçlanan evrenin kesintiye uğramaması riski vardır. <code>MT-Unsafe</code> olmanın yanısıra bu tür işlevler, bunları çağıran sinyal işleyiciler, kesintiye uğratılan kod tarafından atanan zamanlayıcılarla etkileşime girebileceğinden daima <code>AS-Unsafe</code>'tir ve önalanda iptal durumunda daha önceki bir zamanlayıcının sıfırlanacağını garanti etmenin güvenilir bir yolu olmadığından <code>AC-Unsafe</code>'tir.
       </para>
      </glossdef>
     </glossentry>
    </glosslist>
   </sect2>
   <sect2 xml:id="glibc-Conditionally-Safe-Features">
    <title>Koşullu Olarak Güvenilir Özellikler</title>
    <titleabbrev>Geçici çözümler olmadığında işlevleri güvensiz hale getiren özellikler.</titleabbrev>
    <indexterm xml:id="glibc-cp-consafe" linkend="glibc-cp"><primary>Koşullu Olarak Güvenilir Özellikler</primary></indexterm>
    <para>
     Belirli bağlamlarda işlevlerin çağrılmasını güvensiz kılan bazı özellikler için, işlevi çağırmaktan tamamen kaçınmak dışında güvenlik sorununu ortadan kaldıracak bazı yollar vardır. Aşağıdaki anahtar sözcükler bu tür özelliklere atıfta bulunur ve bunların tanımlarının her biri, anahtar sözcük tarafından belirtilen güvenilirlik sorununu ortadan kaldırmak için tüm yazılımın nasıl sınırlandırılması gerektiğini gösterir. Yalnız ve yalnız, bir işlevi güvensiz kılan tüm nedenler gözlemlenip belgelenmiş kısıtlamalar uygulanarak ele alındığında işlevin o bağlamda çağrılması güvenilir hale gelir.
    </para>
    <glosslist>
     <glossentry>
      <indexterm linkend="glibc-cp" xml:id="glibc-safety-init"><primary>init (ilklendir)</primary></indexterm>
      <glossterm><code>init</code></glossterm>
      <glossdef>
       <para>
        <code>MT-Unsafe</code> özellik olarak <code>init</code> ile imlenmiş işlevler, ilk çağrıldıklarında <code>MT-Unsafe</code> ilklendirme yapar.
       </para>
       <para>
        Böyle bir işlevi tek evreli kipte en az bir kez çağırmak, işlevin <code>MT-Unsafe</code> olarak değerlendirilmesine sebep olan bu özel nedeni ortadan kaldırır. Bunun için başka bir neden kalmadıysa, diğer evreler başlatıldıktan sonra işlev güvenli bir şekilde çağrılabilir.
       </para>
       <para>
        <code>AS-Unsafe</code> veya <code>AC-Unsafe</code> özellik olarak <code>init</code> ile imlenmiş işlevler, dahili veri yapılarını ilklendirmek için dahili <code>libc_once</code> mekanizmasını veya benzerini kullanır.
       </para>
       <para>
        Bir sinyal işleyici böyle bir ilklendiriciyi kesintiye uğratır ve üstüne <code>libc_once</code> ilklendirmesini uygulayacak bir işlevi çağırırsa, evre kütüphanesi yüklü olduğu takdirde kısır döngü oluşur.
       </para>
       <para>
        Dahası, bir ilklendirici iptal edilmeden veya işleyicisi aynı ilklendirmeyi gerektiren bir sinyal tarafından kesintiye uğratılmadan önce kısmen tamamlanmışsa, ilklendirmenin bir kısmı veya tamamı birden fazla kez uygulanabilir, bu da kaynakların boşa harcanmasına ve hatta dahili verilerin bozulmasına neden olabilir.
       </para>
       <para>
        <code>AS-Unsafe</code> veya <code>AC-Unsafe</code> özellik olarak <code>init</code> ile imlenmiş işlevleri çağırması gereken yazılımlarda, <code>libc_once</code> ile ilgili <code>AS-Unsafe</code> ve <code>AC-Unsafe</code> sorunlarının ortaya çıkmaması için sinyal işleyicileri yapılandırılmadan veya iptali etkinleştirilmeden önce ilklendirme yapılmış olmalıdır.
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <indexterm linkend="glibc-cp" xml:id="glibc-safety-race"><primary>race (yarış)</primary></indexterm>
      <glossterm><code>race</code></glossterm>
      <glossdef>
       <para>
        <code>MT-Safety</code> özellik olarak <code>race</code> ile imlenmiş işlevler, aynı anda yürütme dışında benzer yıkıcı girişim biçimlerine veya veri yarışlarına neden olabilecek şekilde nesneler üzerinde işlem yapar. Nesneler, bazı durumlarda kullanıcılar tarafından işlevlere aktarılırken bazı durumlarda da işlevler tarafından kullanıcılara değer döndürmek için kullanılır, bazı durumlarda ise kullanıcılara hiç görünmez.
       </para>
       <para>
        İşlevlere (dolaylı) olarak aktarılan nesnelere erişimin veri yarışından bağımsız olduğu varsayılır. Veri yarışından bağımsız nesnelerin güvenilirliği işlevi çağıranın sorumluluğundadır. Yazılımcı bu tür nesnelerle uğraşırken veri yarışlarını önlemek için POSIX'in gerektirdiği önlemleri almadığı için işlev hatalı davranırsa, bu işlev <code>MT-Unsafe</code> veya <code>AS-Unsafe</code> olarak imlenmez.
       </para>
       <para>
        Genel bir kural olarak, bir işlevin (atıf yoluyla) aktarılan bir nesneden okuma yaptığı veya bu nesneyi değiştirdiği durumlarda, yazılımcının kütüphane işlevini çağırmak yerine nesneye erişimi kendisinin gerçekleştirmesi, veri yarışlarından kaçınmak için de bellek eşzamanlama ilkellerini kullanması gerekir. POSIX, <type>FILE</type> akımlarını işleyen birçok işlevde veri yarışlarına karşı kütüphanenin koruma sağlamasını zorunlu kıldığından <type>FILE</type> akımları bu genel kuralın dışındadır. Bunu, diğer türleri de kapsayacak şekilde genişletilmesi gerektiği yönündeki beklentilerin aksine, genel bir gereklilik olarak değil, kullanıcılara sağlanan bir kolaylık olarak görüyoruz.
       </para>
       <para>
        Yazılımcılara belirli bağımsız değişkenleri korumanın kendi sorumlulukları olduğunu hatırlatmak için, belirli türdeki nesneleri bağımsız değişken olarak alan işlevlere açıklama ekleyeceğiz. Yazılımcı tarafından aktarılan nesneler ile ilgili olarak çizgiyi şu şekilde çekiyoruz: Bellek tamponları, dizgeler ve kullanıcı tarafından görülebilen <type>struct</type> türleri gibi, türleri kullanıcılara açık olan ve kullanıcıların doğrudan erişmesi beklenen nesneler, işlevlerin <code>race</code> ile imlenmesine neden <emphasis>olmaz</emphasis>. Bu, genel gereksinime göre gürültülü ve gereksiz olacak ve yazılımcının doğrudan erişilebildiği nesnelere erişirken kütüphanenin buna dahili olarak koruma sağlamaması kimseyi pek şaşırtmayacaktır.
       </para>
       <para>
        Yalnızca kütüphane işlevlerine aktarılarak üzerinde işlem yapılabilecek olan (örneğin, <type>FILE</type>, <type>DIR</type>, <type>obstack</type>, <type>iconv_t</type> gibi) geçirimsiz nesneler ve benzeri için, kütüphane tarafından erişimin dahili yönetimine ilişkin ek beklentiler olabilir. Bu tür nesneleri alan ancak öntanımlı olarak bunlara erişimi zamanlamaya özen göstermeyen işlevlerin bağımsız değişkenlerini, <code>race</code>:<replaceable>değişken</replaceable> sözdizimiyle imleyeceğiz. Örneğin, <type>FILE</type> akımının "kilitleme yapmayan" işlevleri imlenir, ancak örtük kilitleme akım bazında devre dışı bırakılmış olsa bile, <code>FILE</code> akımlarında öntanımlı olarak örtük kilitleme gerçekleştirenlere bu uygulanmaz.
       </para>
       <para>
        Her iki durumda da, yazılımcının, erişimlerin iyi tanımlandığından emin olmaması durumunda, yazılımcı tarafından sağlanan nesnelere güvenli olmayan yollarla erişebilen <code>MT-Unsafe</code> işlevleri dikkate almayacağız. Yazılımcılarda, yazılımcı tarafından sağlanan ve kütüphanenin yazılımcı adına eriştiği nesneleri veri yarışlarına karşı korumasının beklendiği fikri hakimdir.
       </para>
       <para>
        Ancak, bu kullanıcı sorumluluğu, belirli çağrılardan değer döndürmek için kullanılan dahili nesneler ve statik tamponlar gibi kütüphane tarafından denetlenen nesneler için geçerli değildir. Kütüphane bunları artalandaki kullanımlara karşı korumadığında, bu durumlar <code>MT-Unsafe</code> veya <code>AS-Unsafe</code> olarak kabul edilir (ancak <code>AS-Unsafe</code> özellik olarak <code>race</code> imi, <code>MT-Unsafe</code> olanı varken gereksiz olduğundan yok sayılır). Yazılımcıya terkedilen nesnelerde olduğu gibi, imden sonra iki nokta üst üste ve <replaceable>tanıtıcı</replaceable> gelebilir. <replaceable>tanıtıcı</replaceable>, belirli bir korumasız nesne üzerinde çalışan tüm işlevleri gruplandırır. Yazılımcı, denetimindeki nesnenin <replaceable>tanıtıcı</replaceable>sıyla ilgili ardışık olmayan bir muteks oluşturarak ve bu <replaceable>tanıtıcı</replaceable>da <code>race</code> olarak imlenmiş herhangi bir işlevi çağırırken muteksi daima tutarak, bu tür dahili nesnelere önalanda korumasız erişimle ilgili <code>MT-Safe</code> sorunlarından kaçınabilir. Ardışık olmayan muteks, Çok Evreli güvenilirliği ile ilgili sorunu önler, ancak Önalanda Sinyal güvenilirliği sorununu diğeriyle değiştirir, bu nedenle önalanda sinyal kullanımı tanımsız kalır.
       </para>
       <para>
        <replaceable>tanıtıcı</replaceable>, dönüş değerlerini tutmak için kullanılan statik bir tampona ait olduğunda, tampon çağrıcı tarafından kullanıldığı sürece muteks tutulmalıdır. Statik tamponlara gösterici döndüren birçok işlev, bunun yerine geri dönüş değerlerini çağrıcı tarafından sağlanan tamponlarda saklayan evresel karşılıklarını sunar. <code>tmpname</code> gibi bazı durumlarda bu evresel karşılık, ayrı bir giriş noktası çağrılarak değil, döndürülen değerlerin saklanacağı tampona NULL olmayan bir gösterici aktarılarak seçilir. Bu evresel karşılıklar, <code>race</code> olarak imlenmiş diğer dahili tamponlar nedeniyle <code>MT-Safe</code> değilse de, genellikle çok evreli yazılımlarda tercih edilir.
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <indexterm linkend="glibc-cp" xml:id="glibc-safety-const"><primary>const (sabit)</primary></indexterm>
      <glossterm><code>const</code></glossterm>
      <glossdef>
       <para>
        <code>MT-Safe</code> özellik olarak <code>const</code> ile imlenmiş işlevler, GNU C Kütüphanesinin önemli bir bölümü bunlara zamanlamasız eriştiğinden, sabit olarak kabul edilmesi daha iyi olan dahili nesneleri bütünlüklerini bozarak değiştirir. Dahili nesnelerin hem oku hem de yaz işlevlerinin <code>MT-Unsafe</code> ve <code>AS-Unsafe</code> olarak değerlendirilmesine neden olan <code>race</code> iminden farklı olarak, <code>const</code> yalnızca yaz işlevlerine uygulanır. Yaz işlevleri çağrılmak için eşit derecede <code>MT-Unsafe</code> ve <code>AS-Unsafe</code> olarak kalırlar, ancak nesneler etkin birer sabit olduğunda zamanlama eksikliği sorun yaratmadığından, nesnelerin değiştirildikten sonraki zorunlu sabitliği, oku işlevlerinin <code>MT-Safe</code> ve <code>AS-Safe</code> olarak kabul edilmesini sağlar (güvenli olmamaları için başka bir neden kalmadığı sürece).
       </para>
       <para>
        Oku işlevlerinde <code>const:</code><replaceable>tanıtıcı</replaceable>,  kendiliğinden bir güvenilirlik imi olarak görünecektir. Yaz işlevlerini çağırmak için bu güvenlik sorununa geçici bir çözüm bulmak isteyen yazılımlar, <replaceable>tanıtıcı</replaceable> ile ilişkili ardışık olmayan bir <code>rwlock</code> kullanabilir ve <code>const:</code><replaceable>tanıtıcı</replaceable> ile imlenmiş işlevlere yapılan tüm çağrıları yazma kilidiyle ve yalnızca <replaceable>tanıtıcı</replaceable> ile imlenmiş işlevlere yapılan tüm çağrıları da bir okuma kilidiyle koruyabilir.
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <indexterm linkend="glibc-cp" xml:id="glibc-safety-sig"><primary>sig (sinyal)</primary></indexterm>
      <glossterm><code>sig</code></glossterm>
      <glossdef>
       <para>
        <code>MT-Safe</code> (ve kısa olması için çıkarılan, örtük olarak uygulanan özdeşi olan <code>AS-Safe</code>) özellik olarak <code>sig</code> ile imlenmiş işlevler, iki nokta üst üste iminden sonra tanımlanan sinyalin diğer kullanımları ile etkileşebilen bir sinyal işleyiciyi dahili amaçlarla geçici olarak kurabilir.
       </para>
       <para>
        Bu güvenilirlik sorunu, çağrı süresince sinyalin başka hiçbir şekilde kullanılmaması sağlanarak çözülebilir. Aynı geçici sinyali kullanan tüm işlevleri çağırırken ardışık olmayan bir muteks tutulması; çağrıdan önce bu sinyalin engellenmesi ve daha sonra işleyicisinin sıfırlanması önerilir.
       </para>
       <para>
        Önalanda iptal durumunda özgün sinyal işleyicinin geri yükleneceğini garanti etmenin güvenli bir yolu yoktur, bu nedenle bu şekilde imlenmiş işlevler ayrıca <code>AC-Unsafe</code>'tir.
       </para>
       <para>
        İptal sorununu önlemek ve <code>MT-Safe</code>/<code>AS-Safe</code> sorununu çözmek için önerilen önlemlerin yanı sıra önalanda iptalin devre dışı bırakılması <emphasis>ve</emphasis> sinyali istenen duruma geri getirmek için bir temizlik işleyicisinin kurulup muteksin serbest bırakılması önerilir.
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <indexterm linkend="glibc-cp" xml:id="glibc-safety-term"><primary>term (uçbirim)</primary></indexterm>
      <glossterm><code>term</code></glossterm>
      <glossdef>
       <para>
        <code>MT-Safe</code>  özellik olarak <code>term</code> ile imlenmiş işlevler, uçbirim ayarlarını önerilen şekilde değiştirebilir, yani: <function>tcgetattr</function> çağrısı yapar, bazı bayrakları değiştir ve ardından <function>tcsetattr</function> çağrısı yapar; Bu, diğer evreler tarafından yapılan değişikliklerin kaybolduğu bir pencere oluşturur. Bu nedenle, <code>term</code> ile imlenen işlevler <code>MT-Unsafe</code>'tir. Aynı pencere, önalan sinyallerinin kaybolması ile yapılan değişikliklerin etkin olmasını sağlar. Bu işlevler aynı zamanda <code>AC-Unsafe</code>'tir, ancak ilgili im gereksiz olduğundan belirtilmez.
       </para>
       <para>
        Bu nedenle, uçbirimi kullanan uygulamaların uçbirimi sinyal işleyicilerde kullanmayarak veya onu kullanabilecek sinyalleri engelleyerek ve bu işlevleri çağırırken ve uçbirimle etkileşimde bulunurken bir kilit tutarak uç birim ile eşzamanlı ve çok evreli etkileşimlerden kaçınması önerilir. Bu kilit aynı zamanda <code>race:tcattr(dt)</code> ile imlenmiş işlevlerle karşılıklı dışlama için kullanılmalıdır; burada <varname>dt</varname>, denetim uçbiriminin dosya tanıtıcısıdır. Çağrıcı, basitlik için tek bir muteks kullanabilir veya farklı dosya tanıtıcıları tarafından atıf yapılsa bile uçbirim başına bir muteks kullanabilir.
       </para>
       <para>
        <code>AC-Safe</code> özellik olarak <code>term</code> ile imlenmiş işlevlerin, geçici değişiklikler sonrası uçbirimi özgün durumuna geri getiren ancak iptal edilmeleri durumunda bunu yapmakta başarısız olabilen işlevler olduğu varsayılır.
       </para>
       <para>
        İptal sorununu önlemek ve <code>MT-Safe</code>/<code>AS-Safe</code> sorununu çözmek için önerilen önlemlerin yanı sıra önalanda iptalin devre dışı bırakılması <emphasis>ve</emphasis> uçbirimi özgün durumuna geri getirmek için bir temizlik işleyicisinin kurulup muteksin serbest bırakılması önerilir.
       </para>
      </glossdef>
     </glossentry>
    </glosslist>
   </sect2>
   <sect2 xml:id="glibc-Other-Safety-Remarks">
    <title>Güvenilirlikle ilgili Diğer Açıklamalar</title>
    <titleabbrev>Ek güvenilirlik özellikleri ve açıklamaları.</titleabbrev>
    <indexterm xml:id="glibc-cp-othersafe" linkend="glibc-cp"><primary>Diğer Güvenilirlik Açıklamaları</primary></indexterm>
    <para>
     İşlevlere, işlev çağrısını güvensiz hale getirmeyen, ancak belirli yazılım sınıflarında dikkate alınması gerekebilecek özellikleri belirten ek anahtar sözcükler eklenebilir:
    </para>
    <glosslist>
     <glossentry>
      <indexterm linkend="glibc-cp" xml:id="glibc-safety-locale"><primary>locale (yerel)</primary></indexterm>
      <glossterm><code>locale</code></glossterm>
      <glossdef>
       <para>
        <code>MT-Safe</code> özellik olarak <code>locale</code> ile imlenmiş işlevler, herhangi bir eşzamanlama biçimi olmaksızın yerele özgü nesnelerden okuma yapar. Yerele özgü değişikliklerle eşzamanlı çağrılan <code>locale</code> imli işlevler, yürütülmeleri sırasında etkin olan yerellerden hiçbirine karşılık gelmeyen, ancak bunların öngörülemeyen bir karışımı olan biçimlerde davranabilir.
       </para>
       <para>
        Ancak, yerele özgü nesneyi değiştiren işlevler <code>const:locale</code> ile imlendiğinden ve güvensiz olarak kabul edildiğinden, bu işlevleri <code>MT-Unsafe</code> veya <code>AS-Unsafe</code> olarak imlemiyoruz. Çoklu evreler çalışırken veya önalanda sinyaller etkinleştirildiğinde güvensiz olarak kabul edilenler çağrılmayacaktır ve bu bakımdan yerel (locale), bu bağlamlarda etkili şekilde sabit (<code>const</code>) kabul edilebilir, bu da <code>const:locale</code> imli işlevleri güvenilir kılar.
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <indexterm linkend="glibc-cp" xml:id="glibc-safety-env"><primary>env (ortam)</primary></indexterm>
      <glossterm><code>env</code></glossterm>
      <glossdef>
       <para>
        <code>MT-Safe</code> özellik olarak <code>env</code> ile imlenmiş işlevler, eşzamanlı değişikliklerin varlığında güvenilirliği sağlamak için herhangi bir koruma olmadan ortama <function>getenv</function> veya benzeri bir işlev ile erişir.
       </para>
       <para>
        Ancak, ortamı değiştiren işlevler <code>const:env</code> ile imlendiğinden ve güvensiz olarak kabul edildiğinden, bu işlevleri <code>MT-Unsafe</code> veya <code>AS-Unsafe</code> olarak imlemiyoruz. Çoklu evreler çalışırken veya önalanda sinyaller etkinleştirildiğinde güvensiz olarak kabul edilenler çağrılmayacaktır ve bu bakımdan ortam (env), bu bağlamlarda etkili şekilde sabit (<code>const</code>) kabul edilebilir, bu da <code>const:env</code> imli işlevleri güvenilir kılar.
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <indexterm linkend="glibc-cp" xml:id="glibc-safety-hostid"><primary>hostid (konak kimliği)</primary></indexterm>
      <glossterm><code>hostid</code></glossterm>
      <glossdef>
       <para>
        <code>MT-Safe</code> özellik olarak <code>hostid</code> ile imlenmiş işlevler, makinenin "konak kimliğini" saklandığı sistem genelindeki veri yapılarından okur. Bu veri yapıları genellikle atomik olarak (bütünlüğü bozulacak şekilde) değiştirilemez. "Konak kimliğinin" normal olarak değişmeyeceği beklendiğinden, okuyan işlev (<function>gethostid</function>) güvenilir olarak kabul edilirken, değiştiren işlev (<function>sethostid</function>) çağrıldığında değişikliğin yalnızca süreç içinde değil sistem genelinde ele alınmasının gerekebileceğini belirtmek için <code>const:hostid</code> ile imlenir.
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <indexterm linkend="glibc-cp" xml:id="glibc-safety-sigintr"><primary>sigintr</primary></indexterm>
      <glossterm><code>sigintr</code></glossterm>
      <glossdef>
       <para>
        <code>MT-Safe</code> özellik olarak <code>sigintr</code> ile imlenmiş işlevler, eşzamanlı değişikliklerin varlığında güvenilirliği sağlamak için <structname>_sigintr</structname> dahili veri yapısına herhangi bir koruma olmaksızın erişir.
       </para>
       <para>
        Ancak, bu veri yapısını değiştiren işlevler <code>const:sigintr</code> ile imlendiğinden ve güvensiz olarak kabul edildiğinden, bu işlevleri <code>MT-Unsafe</code> veya <code>AS-Unsafe</code> olarak imlemiyoruz. Çoklu evreler çalışırken veya önalanda sinyaller etkinleştirildiğinde güvensiz olarak kabul edilenler çağrılmayacaktır ve bu bakımdan veri yapısı, bu bağlamlarda etkili şekilde sabit (<code>const</code>) kabul edilebilir, bu da <code>const:sigintr</code> imli işlevleri güvenilir kılar.
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <indexterm linkend="glibc-cp" xml:id="glibc-safety-fd"><primary>fd (dosya tanıtıcı)</primary></indexterm>
      <glossterm><code>fd</code></glossterm>
      <glossdef>
       <para>
        <code>AC-Safe</code> özellik olarak <code>fd</code> ile imlenmiş işlevler, önalanda evre iptali yürütülmelerini kesintiye uğratırsa dosya tanıtıcılarında kaçak olabilir.
       </para>
       <para>
        Dosya tanıtıcıları ayıran ve serbest bırakan işlevler genelde böyle imlenir. Dosya tanıtıcı tahsisi ve yeniden tahsis işlemleri, temizlik işlevleri ile korunmaya çalışılsa bile, yeni bir tanıtıcı tahisis ve numarasını temizlik işlevlerinin serbest bırakabileceği bir yerde saklamak, tek bir bölünmez işlem olarak gerçekleştirilemez. Benzer şekilde tanıtıcının serbest bırakılması ve normalde serbest bırakılmasından sorumlu olan veri yapısından çıkarılması da tek bir bölünmez işlem olarak gerçekleştirilemez. Henüz temizleme işleyici bağımsız değişkeninde saklanmadığı veya serbest bırakılmadan önce zaten çıkarıldığı için tanıtıcının serbest bırakılamadığı bir pencere her zaman olacaktır. Tanıtıcı serbest bırakıldıktan sonra çıkarılamaz: Açık bir tanıtıcı, tanıtıcının hala kapatılması gerektiği veya zaten kapalı olduğu ancak tanıtıcının başka bir evre veya sinyal işleyici tarafından yeniden tahsis edildiği anlamına da gelebilir.
       </para>
       <para>
        Bu tür kaçaklar, önalanda evre iptalini geçici olarak devre dışı bırakarak, bir miktar başarım düşüşüyle dahili olarak önlenebilir. Bununla birlikte, tahsis veya yeniden tahsis işlev çağrılarının yapıldığı katmanda aynı türden bir kaçağı önlemek için bunun çağrıcı tarafından yapılması gerekeceğinden, üst katmanlarda sorun çözüldüğünde gereksiz, çözülmediğinde yetersiz bir başarım cezası vermektense sorunla kütüphanenin ilgilendiğinin varsayılması daha mantıklıdır.
       </para>
       <para>
        Bu açıklama tek başına bir işlevin <code>AC-Unsafe</code> olarak değerlendirilmesine neden olmaz. Ancak bu tür kaçakların birikerek artan etkileri bazı uygulamalar için sorun teşkil edebilir. Bu durumda, bu tür işlevlere yapılan çağrıların yürütülmesi sırasında önalanda iptalin askıya alınması önerilir.
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <indexterm linkend="glibc-cp" xml:id="glibc-safety-mem"><primary>mem (bellek)</primary></indexterm>
      <glossterm><code>mem</code></glossterm>
      <glossdef>
       <para>
        <code>AC-Safe</code> özellik olarak <code>mem</code> ile imlenmiş işlevler,  önalanda evre iptali yürütülmelerini kesintiye uğratırsa bellek kaçağı oluşabilir.
       </para>
       <para>
        Bu sorun, dosya tanıtıcıların sorunlarıyla benzerlik gösterir: Bu işlevlerin yapmadığı önalanda iptali en azından geçici olarak devre dışı bırakmadan, belleği tahsis edip adresini bağımsız bir değişken üzerinden bir temizleme işleyicisinde saklama veya belleği serbest bırakıp adresini bu bağımsız değişkenden kaldırma işlemini tek bir bölünmez işlem halinde yerine getirebilecek herhangi bir arayüz yoktur.
       </para>
       <para>
        Bu açıklama tek başına bir işlevin <code>AC-Unsafe</code> olarak değerlendirilmesine neden olmaz. Ancak bu tür kaçakların birikerek artan etkileri bazı uygulamalar için sorun teşkil edebilir. Bu durumda, bu tür işlevlere yapılan çağrıların yürütülmesi sırasında önalanda iptalin askıya alınması gerekebilir.
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <indexterm linkend="glibc-cp" xml:id="glibc-safety-cwd"><primary>cwd (geçerli çalışma dizini)</primary></indexterm>
      <glossterm><code>cwd</code></glossterm>
      <glossdef>
       <para>
        <code>MT-Safe</code> özellik olarak <code>cwd</code> ile imlenmiş işlevler, yürütülürken geçerli çalışma dizinini geçici olarak değiştirebilir, bu da göreli yolların diğer evrelerde veya önalanda sinyal veya iptal işleyicileri içinde beklenmedik şekillerde çözümlenmesine neden olabilir.
       </para>
       <para>
        Bu açıklama tek başına <code>cwd</code> imli işlevlerin <code>MT-Unsafe</code> veya <code>AS-Unsafe</code> olarak imlenmesi için yeterli neden değildir, ancak bu davranış seçimlik olduğunda (örneğin, <code>FTW_CHDIR</code> özellikli <function>nftw</function> çağrılarında), tam dosya yollarını kullanmak veya (<function>openat</function> gibi) göreli dosya tanıtıcılı sistem çağrıları yapmaktansa bu seçenekten kaçınılması daha iyi olabilir.
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <indexterm linkend="glibc-cp" xml:id="glibc-safety-posix"><primary sortas="posix">!posix</primary></indexterm>
      <glossterm><code>!posix</code></glossterm>
      <glossdef>
       <para>
        Bu im, işlevin güvenilirlik durmunun POSIX standardında belirtilenden farklı olduğunun bilindiğini belirtmek üzere, işleve <code>MT-Safe</code>, <code>AS-Safe</code> veya <code>AC-Safe</code> özellik atfedebilir. Örneğin POSIX, bir işlevin güvenilir olmasını gerektirmezken bizim gerçeklenimimiz güvenilirdir veya bunun tam tersidir.
       </para>
       <para>
        Şimdilik, bu imin olmaması, belgelediğimiz güvenilirlik özelliklerinin ilgili işlevler için POSIX tarafından zorunlu kılınanlarla aynı olduğu anlamına gelmez.
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <indexterm linkend="glibc-cp" xml:id="glibc-safety-identifier"><primary sortas="belirteç">:belirteç</primary></indexterm>
      <glossterm><code>:</code><replaceable>belirteç</replaceable></glossterm>
      <glossdef>
       <para>
        Örneğin, veri yapılarına güvensiz yollarla erişen birkaç işlevi gruplamak için tasarlanmış <code>race</code> ve <code>const</code> imlemelerinde olduğu gibi veya <code>sig</code> ile imlenmiş bir işlevde bir sinyal adının belirtilmesi gibi daha duruma özgü bilgiler sağlamak için imlemeler bazen <replaceable>im:belirteç</replaceable> biçiminde belirteçleriyle birlikte belirtilebilir. Bunun gelecekte <code>lock</code> ve <code>corrupt</code> için de uygulanabileceği öngörülmektedir.
       </para>
       <para>
        Çoğu durumda, belirteç bir işlevi kümesinin adı olacaktır, ancak genel nesnelerin veya işlev bağımsız değişkenlerinin ya da tanımlanabilir özelliklerin adları olabileceği gibi bunlarla ilişkili mantıksal bileşenlerin, örneğin <varname>var</varname> bağımsız değişkeniyle ilişkili bir tamponu belirtmek için <code>:tampon(var)</code> veya <varname>dt</varname> dosya tanıtıcılı bir uçbirimin özniteliklerini belirtmek için <code>:tcnitelik(dt)</code> gibi bir gösterimi olabilir.
       </para>
       <para>
        Belirteçlerin en yaygın kullanımı, belirli bir bağlamda güvenilir yürütmeyi sağlamak için aynı artalan ilkeli tarafından korunması gereken mantıksal işlev ve bağımsız değişken gruplarını belirlemektir.
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <indexterm linkend="glibc-cp" xml:id="glibc-safety-condition"><primary sortas="koşul">/koşul</primary></indexterm>
      <glossterm><code>/</code><replaceable>koşul</replaceable></glossterm>
      <glossdef>
       <para>
        Bazı güvenilirlik imlemeleri koşula bağlı olabilir, örneğin yalnızca bağımsız değişkenleri, genel değişkenleri ve hatta sistemdeki çekirdeği içeren mantıksal bir ifadenin doğru olarak değerlendirildiği durumda uygulanabiliyor olabilir. <code>/hurd</code> veya <code>/!linux!bsd</code> gibi koşullar, yalnızca sistem çekirdeği HURD olduğunda veya sırasıyla ne Linux ne de BSD çekirdeği olduğunda önlerindeki imin geçerli olduğunu gösterir. <code>/!ps</code> ve <code>/one_per_line</code>,  yalnızca <varname>ps</varname> bağımsız değişkeni NULL olduğunda veya <varname>one_per_line</varname> küresel değişkeni sıfır olmadığında önlerindeki imin geçerli olduğunu belirtir.
       </para>
       <para>
        Bir işlevi güvensiz kılan tüm imlemeler bu tür koşullarla donandığında ve belirtilen koşullardan hiçbiri sağlanmadığında, işlev güvenli olarak kabul edilebilir.
       </para>
      </glossdef>
     </glossentry>
    </glosslist>
   </sect2>
  </sect1>
  <sect1 xml:id="glibc-Berkeley-Unix">
   <title>Berkeley Unix, SVID ve XPG</title>
   <sect2><title>Berkeley Unix</title>
    <titleabbrev>BSD ve SunOS</titleabbrev>
    <indexterm xml:id="glibc-cp-bsd" linkend="glibc-cp"><primary>BSD Unix</primary></indexterm>
    <indexterm xml:id="glibc-cp-bsd4" linkend="glibc-cp"><primary>4.x BSD Unix</primary></indexterm>
    <indexterm xml:id="glibc-cp-berkeley" linkend="glibc-cp"><primary>Berkeley Unix</primary></indexterm>
    <indexterm xml:id="glibc-cp-sunos" linkend="glibc-cp"><primary>SunOS</primary></indexterm>
    <indexterm xml:id="glibc-cp-bunix" linkend="glibc-cp"><primary>Unix</primary><secondary>Berkeley</secondary></indexterm>
    <para>
     GNU C kütüphanesi özellikle 4.2 BSD, 4.3 BSD, 4.4 BSD Unix sistemleri  (<firstterm>Berkeley Unix</firstterm> olarak da bilinir) ile <firstterm>SunOS</firstterm> (biraz Unix Sistem V işlevselliği de içeren bir 4.2 BSD türevi) gibi bazı Unix sürümlerindeki, yazılı standart haline gelmemiş oluşumları da tanımlar. Bu sistemler &isoc; ve POSIX oluşumlarının çoğunu destekler. 4.4 BSD ve SunOS'un yeni dağıtımları hepsini destekler.
    </para>
    <para>
     <dicterm><english>symbolic link</english><turkish>sembolik bağ</turkish></dicterm>
     <dicterm><english>signal handling</english><turkish>sinyal işleme</turkish></dicterm>
     BSD oluşumları, <link linkend="glibc-Symbolic-Links">sembolik bağları</link>, <link linkend="glibc-Waiting-for-I-O"><function>select</function> işlevini</link>, <link linkend="glibc-BSD-Signal-Handling">BSD sinyal işlevlerini</link> ve <link linkend="glibc-Sockets">soketleri</link> içerir.
    </para>
   </sect2>
   <sect2 xml:id="glibc-SVID">
    <title>SVID (Sistem V Arayüzü Tanımlaması)</title>
    <titleabbrev>Sistem V Arayüzü Tanımlaması.</titleabbrev>
    <indexterm xml:id="glibc-cp-SVID" linkend="glibc-cp"><primary>SVID</primary></indexterm>
    <indexterm xml:id="glibc-cp-SVU" linkend="glibc-cp"><primary>System V Unix</primary></indexterm>
    <indexterm xml:id="glibc-cp-SVu" linkend="glibc-cp"><primary>Unix</primary><secondary>System V</secondary></indexterm>
    <para>
     <dicterm><english>interface</english><turkish>arayüz</turkish></dicterm>
     <wordasword>Sistem V Arayüzü Tanımlaması</wordasword> (SVID - The System V Interface Description) AT&amp;T Unix System V işletim sistemini tanımlayan bir belgedir. <link linkend="glibc-POSIX">POSIX standardına</link> ek bazı özellikler içeren bir üst küme tanımlar.
    </para>
    <para>
     <dicterm><english>compatibility</english><turkish>uyumluluk</turkish></dicterm>
     GNU C kütüphanesi, &isoc; ve POSIX standartları tarafından gerekli görülmeyen ancak SVID tarafından gerekli görülen özellikleri içeren System V Unix ve diğer Unix sistemleri (SunOS gibi) ile uyumluluk için gerekli oluşumları tanımlar. Diğer yandan, SVID tarafından gerekli görülen ancak genelde az kullanışlı ve daha zor anlaşılır olan oluşumları içermez. (Aslında Unix System V'in kendisi de onların hepsini sağlamaz.)
    </para>
    <para>
     <dicterm><english>shared memory</english><turkish>paylaşımlı bellek</turkish></dicterm>
     <dicterm><english>function</english><turkish>işlev</turkish></dicterm>
     <dicterm><english>process</english><turkish>süreç</turkish></dicterm>
     <dicterm><english>inter-process communication (IPC)</english><turkish>süreçler arası iletişim</turkish></dicterm>
     Sistem V desteği sağlayan oluşumlar, paylaşımlı bellek ve süreçler arası iletişim için yöntemler, <function>hsearch</function> ve <function>drand48</function> ailesi işlevler, <function>fmtmsg</function> ile çeşitli matematik işlevleri içerir.
    </para>
   </sect2>
   <sect2 xml:id="glibc-XPG">
    <title>XPG (X/Open Taşınabilirlik Kılavuzu)</title>
    <titleabbrev>X/Open Taşınabilirlik Kılavuzu.</titleabbrev>
    <para>
     <dicterm><english>portability</english><turkish>taşınabilirlik</turkish></dicterm>
     X/Open Taşınabilirlik Kılavuzu, X/Open Company, Ltd. şirketi tarafından yayınlanmış POSIX'den daha bir genel standarttır. X/Open, Unix telif hakkına sahiptir ve XPG de bir Unix sistemi olarak kabul edilen sistemler için gereksinimleri belirtir.
    </para>
    <para>
     GNU C kütüphanesi X/Open Taşınabilirlik Kılavuzunun 4.2 sürümü ile tüm X/Open Unix genişletmelerine ve XSI (X/Open Sistem Arayüzü) uyumlu sistemlerde ortak olan tüm genişletmelere uyar.
    </para>
    <para>
     POSIX'in üstüne yapılan eklemeler esas olarak Sistem V ve BSD sistemlerinde bulunan işlevsellikten türetilmiştir. Sistem V sistemlerindeki bazı berbat yanlışlıklar da düzeltilmiştir. Unix uzantıları ile XPG standardını karşılamak, Unix markasını elde etmenin bir ön koşulu olduğundan, işlevselliğin ticari sistemlerde bulunma şansı yüksektir.
    </para>
   </sect2>
  </sect1>
 </chapter>

 <chapter xml:id="glibc-Using-the-Library">
  <title>Kütüphanenin Kullanımı</title>
  <titleabbrev>Kütüphanenin pratikte kullanımı.</titleabbrev>
  <preliminary>
   <para>
    Bu bölümde GNU C kütüphanesinin kullanımıyla ilgili bazı pratik çözümlere yer verilmiştir.
   </para>
  </preliminary>
  <sect1 xml:id="glibc-Header-Files">
   <title>Başlık Dosyaları</title>
   <titleabbrev>Başlık dosyalarını yazılımlarınıza nasıl dahil edersiniz.</titleabbrev>
   <indexterm xml:id="glibc-cp-headers" linkend="glibc-cp"><primary>başlık dosyaları</primary></indexterm>
   <dicterm><english>data type</english><turkish>veri türü</turkish></dicterm>
   <dicterm><english>macro</english><turkish>makro</turkish></dicterm>
   <para>
    C yazılımları tarafından kullanılan kütüphaneler gerçekte iki ana parçadan oluşur: veri türlerinin ve makroların tanımlandığı, değişkenlerin ve işlevlerin bildirildiği <wordasword>başlık dosyaları</wordasword> ile değişken ve işlev tanımlarının bulunduğu <wordasword>arşiv</wordasword>, yani asıl kütüphane.
   </para>
   <para>
    <dicterm><english>declaration</english><turkish>bildirim</turkish></dicterm>
    <dicterm><english>variable</english><turkish>değişken</turkish></dicterm>
    <dicterm><english>definition</english><turkish>tanım</turkish></dicterm>
    <dicterm><english>preprocessor</english><turkish>önişlemci</turkish></dicterm>
    <dicterm><english>directive</english><turkish>yönerge</turkish></dicterm>
    <indexterm xml:id="glibc-cp-declaration" linkend="glibc-cp"><primary>tanım (bildirim ile karşılaştırmalı olarak)</primary></indexterm>
    <indexterm xml:id="glibc-cp-declvsdef" linkend="glibc-cp"><primary>bildirim (tanım ile karşılaştırmalı olarak)</primary></indexterm>
    (C ile ilgili bilgileri hatırlayalım: Bir <wordasword>bildirim</wordasword> bir işlev ya da bir değişkenin varlığı ve türü hakkında bilgi verir. İşlev bildirimi ayrıca bağımsız değişkenlerinin türleri hakkında da bilgi verir. Bildirim işlemi yoluyla, derleyiciler nesnelerin hangi özelliklere sahip olduklarını anlarlar. <wordasword>Tanım</wordasword> ise derleyiciye değişken için bellekte yer tahsisi ya da işlevin ne yaptığını belirtmek içindir. Yani tanımlama ile  derleyici bellekte bir yer tahsis ederken, bildirim de bunu yapmaz.) GNU C kütüphanesindeki oluşumları kullanırken, yazılımınızın kaynak koduna ilgili başlık dosyalarını dahil etmeniz gerekir. Böylece derleyici bu oluşumların bildirimlerini edinir ve onları doğru olarak işler. Yazılımınız önişlemci tarafından işlendikten sonra ilintileyici bunların sağladığı bilgilerle arşiv dosyasındaki tanımlara ulaşır.
   </para>
   <para>
    Başlık dosyaları bir yazılımın kaynak koduna <command>#include</command> önişlemci deyimi ile dahil edilir. C dili bu deyimi iki şekilde kabul eder; Birinci kullanım,
   </para>
   <screen>#include &quot;<filename>başlık.h</filename>&quot;
</screen>
   <para>
    şeklindedir ve bununla kendi yazdığınız, yazılımınızın farklı parçaları arasındaki arayüzleri açıklayan bildirim ve tanımları içeren <filename>başlık.h</filename> isimli bir başlık dosyasını kaynak kodunuza dahil edersiniz. İkinci kullanımı ise,
   </para>
   <screen>#include &lt;<filename>başlık.h</filename>&gt;
</screen>
   <para>
    şeklindedir ve bununla bir standart kütüphanenin bildirim ve tanımlarının bulunduğu <filename>başlık.h</filename> başlık dosyasını kaynak kodunuza dahil edersiniz. Bu dosya normalde sistem yöneticiniz tarafından standart bir yere konmuştur. C kütüphanesinin başlık dosyalarını kaynak kodunuza dahil etmek istediğinizde bu ikincisini kullanmalısınız.
   </para>
   <para>
    <dicterm><english>comment</english><turkish>açıklama</turkish></dicterm>
    <dicterm><english>feature test macros</english><turkish>özellik sınama makroları</turkish></dicterm>
    Genellikle, <command>#include</command> önişlemci deyimleri C kaynak kodunun ilk satırlarında bulunur. Kaynak dosyalarınızın başına bu kodun ne yaptığına ilişkin bazı açıklamalar koyuyorsanız, <link linkend="glibc-Feature-Test-Macros">özellik sınama makrolarının</link> tanımlarını hemen altındaki satırlara koyun ve ardından da <command>#include</command> önişlemci deyimlerini yerleştirin.
   </para>
   <para>
    Başlık dosyalarının ve ‘<filename>#include</filename>’ yönergelerinin kullanımı hakkında daha fazla bilgi için <citation>GNU C Önişlemci Kılavuzu</citation>'ndaki <link xl:href="https://gcc.gnu.org/onlinedocs/cpp/Header-Files.html#Header-Files">Başlık Dosyaları</link>na bakılabilir.
   </para>
   <para>
    GNU C kütüphanesindeki başlık dosyaları birbiriyle ilgili oluşumların tür ve makro tanımları ile değişken ve işlev bildirimleri şeklinde gruplanarak oluşturulmuştur. Bu nedenle kullanmak istediğiniz özellikler ile örtüşen çok sayıda başlık dosyasını kaynak kodunuza dahil etmeniz gerekebilir.
   </para>
   <para>
    Bazı kütüphane başlık dosyaları başka bir kütüphanenin başlık dosyalarını da içerebilir. Bu, yazılım geliştirme tarzı ile ilgilidir ve siz buna pek bel bağlamayın; en iyisi kullandığınız kütüphane oluşumları için gerekli başlık dosyalarını kendiniz yine de kodunuza dahil edin. Kaynak koduna aynı başlık dosyasının defalarca dahil edilmiş olmasının bir önemi yoktur. İlk dahil edilenden sonrakiler etkisizdir. Benzer şekilde, yazılımınızın birden fazla başlık dosyası içermesi gerekiyorsa, bunların dahil edilme sırası da önemli değildir.
   </para>
   <note><title>Uyumluluk bilgisi</title>
    <para>
     <dicterm><english>specification</english><turkish>belirtim</turkish></dicterm>
     &isoc; gerçeklemelerinin hepsi başlık dosyalarının sıralaması ve defalarca içerilmesi durumlarında bu şekilde davranır. Ancak, çok eski C gerçeklemelerinde bu geleneksel bir durum haline gelmemişti.
    </para>
   </note>
   <para>
    Belirtmek gerekir ki, bir işlevin bildirildiği bir başlık dosyasını kodunuza dahil etmek <emphasis>zorunda</emphasis> değilsiniz. Bu kılavuzdaki belirtimlere uyarak, o işlevi kendiniz de bildirebilirsiniz. Ancak başka türlü kullanılamayan türleri, makroları ve bazı işlevlerin yerine daha verimli makro karşılıklarını tanımlayabileceği için başlık dosyasını dahil etmek genellikle daha iyidir. Aynı zamanda doğru bildirime sahip olmanın kesin bir yoludur.
   </para>
  </sect1>
  <sect1 xml:id="glibc-Macro-Definitions">
   <title>Makro Olarak Tanımlanmış İşlevler</title>
   <titleabbrev>Kütüphanedeki bazı işlevler aslında bir makro olarak tanımlanmış olabilir.</titleabbrev>
   <indexterm xml:id="glibc-cp-ghostdef" linkend="glibc-cp"><primary>hayalet işlevler</primary><secondary>makro olarak tanımlama</secondary></indexterm>
   <indexterm xml:id="glibc-cp-ghostdel" linkend="glibc-cp"><primary>hayalet işlevler</primary><secondary>makroların kaldırılması</secondary></indexterm>
   <indexterm xml:id="glibc-cp-ghostrm" linkend="glibc-cp"><primary>hayalet işlevler</primary><secondary>makroların silinmesi</secondary></indexterm>
   <dicterm><english>equivalent</english><turkish>eşdeğer</turkish></dicterm>
   <dicterm><english>evaluate</english><turkish>değerlendirme</turkish></dicterm>
   <dicterm><english>context</english><turkish>bağlam</turkish></dicterm>
   <para>
    Bu kılavuzda bir işlev olarak bahsettiğimiz bazı şeyler aslında bir makro tanımı olabilir.  Makro tanımı da işlevin yaptığını yaptığından bu durum yazılımın çalışması açısından bir sorun teşkil etmez. Kütüphane işlevlerinin makro eşdeğerlerinin bağımsız değişkenleri işlev çağrılarındaki gibi değerlendirilir. İşlev tanımları yerine bu makro tanımlarının yapılmasının sebebi, makrolar sembolik dile özgü yorumlar şeklinde tek bir satır olarak üretebildiğinden, işlevlerden daha hızlı çalışabilmeleridir.
   </para>
   <para>
    Bir kütüphane işlevinin adresini almak, bu bir makro olarak tanımlanmış olsa bile  çalışır. Bu bağlam içerisinde çalışmasının sebebi, işlevin adından sonra, bir  makro çağrısını tanımak için gereken sol yaylı ayracın olmamasıdır.
   </para>
   <para>
    Kimi zaman bir makro tanımının bir işlev olarak kullanılmasını istemeyebilirsiniz. Bu, yazılımınızda hata ayıklamayı kolaylaştırır.  Bunu yapmanın iki yolu vardır:
   </para>
   <itemizedlist>
    <listitem>
     <para>
      <dicterm><english>syntactically</english><turkish>sözdizimsel olarak</turkish></dicterm>
      <dicterm><english>syntactic context</english><turkish>sözdizimsel bağlam</turkish></dicterm>
      Makro çağrılarına özel olarak, işlev ismini parantez içine alarak bir makro  tanımından kurtulabilirsiniz.  Bunun çalışmasının sebebi işlev isminin sözdizimsel olarak artık bir makro çağrısı olarak algılanmamasıdır.
     </para>
    </listitem>
    <listitem>
     <para>
      Makro tanımını kaynak kodunuzun içinde <command>#undef</command> önişlemci deyimi ile (oluşumun açıklamasında aksi belirtilmediği sürece) devre dışı bırakabilirsiniz.
     </para>
    </listitem>
   </itemizedlist>
   <para>
    Örneğin, &stdlib.h; başlık dosyasında <function>abs</function> isimli işlevin bildirimi olduğunu kabul edelim:
   </para>
   <screen>extern int abs (int);</screen>
   <para>
    Ve, <function>abs</function> için bir makro tanımı olsun:
   </para>
   <screen>
#include &lt;stdlib.h&gt;
int f (int *i) { return abs (++*i); }
</screen>
   <para>
    Burada <function>abs</function>, hem makro hem de işlevdir. Aşağıdaki örneklerde ise <function>abs</function> sadece işlevdir, makro değildir.
   </para>
   <screen>
#include &lt;stdlib.h&gt;
int g (int *i) { return (abs) (++*i); }
</screen>
   <para/>
   <screen>
#undef abs
int h (int *i) { return abs (++*i); }
</screen>
   <para>
    Makro tanımları, asıl işlevin yaptığını yapmaktan başka makroyu da tanımladığından bu yöntemlere gerçekte hiç ihtiyaç yoktur. Ayrıca, bir makro tanımının kaldırılması yazılımınızın daha yavaş çalışmasına sebep olacaktır.
   </para>
  </sect1>
  <sect1 xml:id="glibc-Reserved-Names">
   <title>Anahtar Sözcükler</title>
   <titleabbrev>C standardı, bazı isimleri kullanıcılara bazılarını da kütüphane için ayırır.</titleabbrev>
   <para>
    <indexterm xml:id="glibc-cp-kw" linkend="glibc-cp"><primary>anahtar sözcükler</primary></indexterm>
    <indexterm xml:id="glibc-cp-ns" linkend="glibc-cp"><primary>isim alanı</primary></indexterm>
    Kütüphanedeki veri türü, makro, değişken ve işlevlerin isimlerinden &isoc; standardında belirtilenler koşulsuz olarak anahtar sözcüklerdir. Yazılımınızda bu  isimleri <emphasis>yeniden tanımlayamazsınız</emphasis>. Kütüphanedeki diğer isimler ise, onların bildirildiği veya tanımlandığı başlık dosyaları içerildiği taktirde onlar da bu gruba dahil olur. Bu sınırlamaların çeşitli nedenleri vardır:
   </para>
   <itemizedlist>
    <listitem>
     <para>
      <dicterm><english>modularity</english><turkish>modülerlik</turkish></dicterm>
      <dicterm><english>maintainability</english><turkish>sürdürülebilirlik</turkish></dicterm>
      Örneğin, standart <function>exit</function> işlevinin yaptığından farklı işler yapan bir <function>exit</function> işleviniz varsa, kodunuzu okuyan başkaları, kodunuzu anlamakta çok zorluk çekecektir. Bu durumlardan kaçınırsanız, yazılımınız hem daha kolay anlaşılır olur, hem de modülerliği ve yeniden sürdürülebilirliği artar.
     </para>
    </listitem>
    <listitem>
     <para>
      Bir kullanıcının diğer kütüphane işlevleri tarafından çağrılan bir kütüphane işlevini yanlışlıkla yeniden tanımlama olasılığını ortadan kaldırır. Yani, yeniden tanımlama mümkün olsaydı diğer işlevler düzgün çalışamayabilecekti.
     </para>
    </listitem>
    <listitem>
     <para>
      <dicterm><english>redefine</english><turkish>yeniden tanımlama</turkish></dicterm>
      <dicterm><english>optimization</english><turkish>en iyileme</turkish></dicterm>
      <dicterm><english>variadic</english><turkish>değişkin</turkish></dicterm>
      <dicterm><english>built-in</english><turkish>yerleşik</turkish></dicterm>
      <dicterm><english>identifier</english><turkish>isim</turkish></dicterm>
      <dicterm><english>identifier</english><turkish>belirteç</turkish></dicterm>
      <dicterm><english>implementation</english><turkish>gerçeklenim</turkish></dicterm>
      Derleyiciden en iyileme yapması istendiğinde, bir işlevin kullanıcı tarafından yeniden tanımlanması mümkün olmadığında, derleyici bu işlevlere en iyileme yapıp yapmayacağına daha iyi karar verebilecektir. Bazı kütüphane oluşumlarında örneğin <link linkend="glibc-Variadic-Functions">bağımsız değişken sayısı değişken işlevler</link> ile çalışmada ve <link linkend="glibc-Non-Local-Exits">yerel olmayan çıkışlarda</link> C derleyicisinin bir bölümünün bu işlevlerle bir bütünlük içinde çalışması gerekir. Ayrıca gerçeklenme açısından, derleyici, dilin yerleşik parçaları olarak bunlarla daha kolay çalışabilir.
     </para>
    </listitem>
   </itemizedlist>
   <para>
    Bu kılavuzda belgelenmiş olan isimlere ek olarak, tek altçizgi (<command>_</command>) ile başlayan tüm harici isimler (genel işlevler ve değişkenler) ile nerede ve nasıl kullanılmış olurlarsa olsun iki alt çizgi ile veya bir alt çizgiden sonra bir büyük harfle başlayan tüm isimler anahtar sözcüklerdir. Kütüphane ve başlık dosyalarında tanımlanan işlevler, değişkenler ve makroların dahili kullanım amaçlı olanları, yazılımcının isim kullanım alanını daraltmamak ve yazılımcının kullanacağı olası isimlerle çakışma olmaması için bu yöntemle seçilmektedir.
   </para>
   <para>
    Bazı tanımlayıcı isim sınıfları, C dilinin ve POSIX.1 ortamının gelecekteki geliştirmelerinde kullanılmak üzere ayrılmıştır. Bu isimleri şimdi kullandığınızda bir sorun çıkmayacak olsa da gelecekte C ve POSIX standartları ile çelişebilecektir. Bu nedenle onları şimdiden kullanmamaya başlamanız önerilir.
   </para>
   <itemizedlist>
    <listitem>
     <para>
      Bir büyük <command>E</command> harfi ile başlayan, bir sayı veya büyük harf ile  devam eden tüm isimler hata kodlarının isimleri olarak ayrılmıştır. Bkz. <xref linkend="glibc-Error-Reporting"/>.
     </para>
    </listitem>
    <listitem>
     <para>
      <command>is</command> veya <command>to</command> ile başlayan ve küçük harf ile devam eden isimler karakter sınama ve dönüşüm işlevleri için kullanılmak üzere ayrılmıştır. Bkz. <xref linkend="glibc-Character-Handling"/>.
     </para>
    </listitem>
    <listitem>
     <para>
      <command>LC_</command> ile başlayan ve büyük harflerden oluşan isimler yerel öznitelikleri belirleyen makroların isimleri olarak kullanılabilir. Bkz. <xref linkend="glibc-Locales"/>.
     </para>
    </listitem>
    <listitem>
     <para>
      Mevcut tüm matematik işlevlerinin isimleri, <command>f</command> veya  <command>l</command> harfi ile sonlandırılmış olarak (sırasıyla) <command>float</command> ve <command>long double</command> bağımsız değişkenlerle kullanılmak üzere işlev isimleri olarak ayrılmıştır. Bkz. <xref linkend="glibc-Mathematics"/>.
     </para>
    </listitem>
    <listitem>
     <para>
      <command>SIG</command> ile başlayan ve büyük harflerden oluşan tüm isimler sinyal isimleri olarak ayrılmıştır. Bkz. <xref linkend="glibc-Standard-Signals"/>.
     </para>
    </listitem>
    <listitem>
     <para>
      <command>SIG_</command> ile başlayan ve büyük harflerden oluşan tüm isimler sinyal eylemlerinin isimleri olarak ayrılmıştır. Bkz.  <xref linkend="glibc-Basic-Signal-Handling"/>.
     </para>
    </listitem>
    <listitem>
     <para>
      <command>str</command>, <command>mem</command> veya <command>wcs</command> ile başlayan ve küçük harflerden oluşan isimler dizi ve dizge işlevlerinin isimleri olarak ayrılmıştır. Bkz. <xref linkend="glibc-String-and-Array-Utilities"/>.
     </para>
    </listitem>
    <listitem>
     <para>
      <command>_t</command> ile biten isimler veri türlerinin isimleri için ayrılmıştır.
     </para>
    </listitem>
   </itemizedlist>
   <para>
    Bunlara ek olarak bazı bağımsız başlık dosyaları, gerçekte tanımladıkları adların ötesinde adlar ayırır. Bu başlık dosyaları kullanıldığında bu isimler kullanılmamaya çalışılmalıdır.
   </para>
   <simplelist>
    <member xml:id="glibc-Reserved-Names-headers">
    <indexterm xml:id="glibc-pg-dirent" linkend="glibc-pg"><primary>dirent.h</primary></indexterm>
    <indexterm xml:id="glibc-pg-fcntl" linkend="glibc-pg"><primary>fcntl.h</primary></indexterm>
    <indexterm xml:id="glibc-pg-grp" linkend="glibc-pg"><primary>grp.h</primary></indexterm>
    <indexterm xml:id="glibc-pg-limits" linkend="glibc-pg"><primary>limits.h</primary></indexterm>
    <indexterm xml:id="glibc-pg-pwd" linkend="glibc-pg"><primary>pwd.h</primary></indexterm>
    <indexterm xml:id="glibc-pg-signal" linkend="glibc-pg"><primary>signal.h</primary></indexterm>
    <indexterm xml:id="glibc-pg-stat" linkend="glibc-pg"><primary>sys/stat.h</primary></indexterm>
    <indexterm xml:id="glibc-pg-termios" linkend="glibc-pg"><primary>termios.h</primary></indexterm>
     &dirent.h; başlık dosyası <command>d_</command> ile başlayan isimleri ayırır.
    </member>
    <member>
     &fcntl.h; başlık dosyası <command>l_</command>, <command>F_</command>, <command>O_</command> ve <command>S_</command> ile başlayan isimleri ayırır.
    </member>
    <member>
     &grp.h; başlık dosyası <command>gr_</command> ile başlayan isimleri ayırır.
    </member>
    <member>
     &limits.h; başlık dosyası <command>_MAX</command> ile biten isimleri ayırır.
    </member>
    <member>
     &pwd.h; başlık dosyası <command>pw_</command> ile başlayan isimleri ayırır.
    </member>
    <member>
     &signal.h; başlık dosyası <command>sa_</command> ve <command>SA_</command> ile başlayan isimleri ayırır.
    </member>
    <member>
     &sys-stat.h; başlık dosyası <command>st_</command> ve <command>S_</command> ile başlayan isimleri ayırır.
    </member>
    <member>
     &sys-times.h; başlık dosyası <command>tms_</command> ile başlayan isimleri ayırır.
    </member>
    <member>
     &termios.h; başlık dosyası <command>c_</command>, <command>V</command>, <command>I</command>,  <command>O</command> ve <command>TC</command> ile başlayan isimler ile <command>B</command> ile başlayıp bir rakam ile devam eden isimleri ayırır.
    </member>
   </simplelist>
 </sect1>
 <sect1 xml:id="glibc-Feature-Test-Macros">
  <title>Özellik Sınama Makroları</title>
  <titleabbrev>Hangi adların tanımlandığı nasıl denetlenir.</titleabbrev>
  <para>
   <indexterm xml:id="glibc-cp-ftm" linkend="glibc-cp"><primary>özellik sınama makroları</primary></indexterm>
   Bir kaynak dosyası derlenirken kullanabilecek tüm özellikler, <wordasword>özellik sınama makroları</wordasword> tanımlanarak denetlenebilir.
  </para>
  <para>
   <dicterm><english>option</english><turkish>seçenek</turkish></dicterm>
   Yazılım <command>gcc -ansi</command> kullanarak derlendiğinde, bir veya birkaç özellik makrosu tanımlanmamışsa sadece &isoc; kütüphanesinin özellikleri elde edilebilir. GCC seçenekleri hakkında daha fazla bilgi için GNU CC Kılavuzundaki <link xl:href="https://gcc.gnu.org/onlinedocs/gcc/Invoking-GCC.html">GNU CC Komut Seçenekleri</link> sayfasına bakılabilir.
  </para>
  <para>
   Bu makrolar kaynak kod dosyalarının en tepesinde <command>#define</command> önişlemci yönergesi kullanılarak tanımlanabilir. Bu deyimler, sistem başlık dosyalarının <command>#include</command> satırlarından <emphasis>önce olmalıdır</emphasis>. Daha iyi açıklamak için bu deyimlerden önce sadece açıklamalar bulunabilir denebilir. Bundan başka, bu makrolar GCC'nin <option>-D</option> seçeneği ile belirtilebilirse de makroların kaynak dosyaların kendisinde tanımlanması daha iyidir.
  </para>
  <para>
   Bu sistem çok sayıda standardı destekleyen kütüphane oluşturmayı mümkün kılar. Farklı standartlar çoğunlukla bir başka standardın üzerine birşeyler ekler ve birbirileriyle de uyumsuzdur. Geniş kapsamlı standartların gerektirdiği işlev isimleri kullanıcıya kalan isim alanını da küçültür. Bu bilgiçlik taslamaktan öte, uygulamada sorun oluşturur. Örneğin, bazı GNU dışı yazılımlar, bu kütüphanede bulunan <function>getline</function> işlevinin yaptığından tamamen farklı işlemler yürüten bir <function>getline</function> işlevi içerebilir ve bunlar eğer tüm özellikleriyle ayrım yapmaksızın etkin kılınırsa uyumluluk sağlanamaz.
  </para>
  <para>
   Bu durumdan, bir yazılım ancak sınırlı sayıda standarda uygun olabilir sonucu çıkarılmamalıdır. Üzerinde ayrım yapılamayan geniş standartlar uyumluluk için yetersizdir. Standart dışı başlık dosyalarının içerilmesinden ya da standart içinde tanımlanmamış özelliklerin katıştırılmasından sizi koruyamaz.
  </para>
  <csynopsis>
   <indexterm xml:id="glibc-vr_POSIX_SOURCE" linkend="glibc-vr"><primary sortas="POSIX_SOURCE">_POSIX_SOURCE</primary></indexterm>
   <csproto type="makro">
    <csname><function>_POSIX_SOURCE</function></csname>
   </csproto>
   <para>
    Bu makroyu <command>#define</command> ile belirtirseniz, &isoc; özelliklerine ek olarak POSIX.1 standardının (IEEE Standard 1003.1) işlevselliği de kullanılabilir olur.
   </para>
   <para>
    Bir pozitif tamsayıyı <statement>_POSIX_C_SOURCE</statement> makrosuna atarsanız <statement>_POSIX_SOURCE</statement> etkisiz olacaktır.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm xml:id="glibc-vr_POSIX_C_SOURCE" linkend="glibc-vr"> <primary sortas="POSIX_C_SOURCE">_POSIX_C_SOURCE</primary> </indexterm>
   <csproto type="makro">
    <csname><function>_POSIX_C_SOURCE</function></csname>
   </csproto>
   <para>
    Bu makroya atayacağınız pozitif tamsayılarla hangi POSIX özelliklerinin etkin olacağını belirleyebilirsiniz. Daha büyük değerler daha büyük işlevsellik sağlar.
   </para>
   <para>
    Bu makroya <literal>1</literal> ya da daha büyük bir tamsayı atarsanız, POSIX.1 standardının 1990 sürümündeki (IEEE Standard 1003.1-1990) işlevselliği elde edersiniz.
   </para>
   <para>
    Bu makroya <literal>2</literal> ya da daha büyük bir tamsayı atarsanız, POSIX.2 standardının 1992 sürümündeki (IEEE Standard 1003.2-1992) işlevselliği elde edersiniz.
   </para>
   <para>
    Bu makroya <literal>199309L</literal> ya da daha büyük bir tamsayı atarsanız, POSIX.1b standardının 1993 sürümündeki (IEEE Standard 1003.1b-1993) işlevselliği elde edersiniz.
   </para>
   <para>
    Bu makroya <literal>199506L</literal> ya da daha büyük bir tamsayı atarsanız, POSIX.1c standardının 1995 sürümündeki (IEEE Standard 1003.1c-1995) işlevselliği elde edersiniz.
   </para>
   <para>
    Bu makroya <literal>200112L</literal> ya da daha büyük bir tamsayı atarsanız, POSIX.1b standardının 2001 sürümündeki (IEEE Standard 1003.1-2001) işlevselliği elde edersiniz.
   </para>
   <para>
    Bu makroya <literal>200809L</literal> ya da daha büyük bir tamsayı atarsanız, POSIX.1b standardının 2008 sürümündeki (IEEE Standard 1003.1-2008) işlevselliği elde edersiniz.
   </para>
   <para>
    Daha büyük değerler ise geleceğe yönelik genişletmeleri etkin kılacaktır. POSIX standardının gelişim sürecinde bu değerler tanımlandıkça, GNU C kütüphanesi onlar standart haline geldikçe destekleyecektir. POSIX.1 standardının 1996 sürümüne (ISO/IEC 9945-1: 1996) göre, <statement>_POSIX_C_SOURCE</statement>'a <literal>199506L</literal> ya da daha büyük bir tamsayı atarsanız, POSIX.1 standardının 1996 sürümündeki işlevselliği elde edersiniz. Genelde, GNU C Kütüphanesinde, temel sürüm belirtilirken standartlardaki hata düzeltmeleri de dahil edilir; örneğin, POSIX.1-2004 her zaman 200112L değeriyle dahil edilir.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm xml:id="glibc-vr_XOPEN_SOURCE" linkend="glibc-vr"> <primary sortas="XOPEN_SOURCE">_XOPEN_SOURCE</primary> </indexterm>
   <indexterm xml:id="glibc-vr_XOPEN_SOURCE_EXTENDED" linkend="glibc-vr"> <primary sortas="XOPEN_SOURCE_EXTENDED">_XOPEN_SOURCE_EXTENDED</primary> </indexterm>
   <csproto type="makro">
    <csname><function>_XOPEN_SOURCE</function></csname>
   </csproto>
   <csproto type="makro">
    <csname><function>_XOPEN_SOURCE_EXTENDED</function></csname>
   </csproto>
   <para>
    Bu makro belirtilirse, X/Open Taşınabilirlik Kılavuzunda açıklanan işlevsellik elde edilir. Bu POSIX.1 ve POSIX.2 işlevselliğini de içerdiğinden <statement>_POSIX_SOURCE</statement> ve <statement>_POSIX_C_SOURCE</statement> kendiliğinden tanımlanmış olur.
   </para>
   <para>
    Tüm Unixlerin aynı olması ilkesinden hareketle, sadece BSD ve SVID'de geçerli işlevselliği de içerir.
   </para>
   <para>
    Eğer <statement>_XOPEN_SOURCE_EXTENDED</statement> makrosu da ayrıca belirtilmişse, fazladan bir işlevsellik eklenir. Bu fazladan işlevsellik, X/Open Unix ticari sürümünün gerektirdiği tüm işlevleri sağlayacaktır.
   </para>
   <para>
    <statement>_XOPEN_SOURCE</statement> makrosuna <literal>500</literal> değeri atanırsa, mevcut işlevselliğe ek olarak Single Unix Belirtimi, sürüm 2 içindeki yeni tanımlar, <literal>600</literal> atanırsa (altıncı yenileme karşılık gelir) SUSv3'teki tanımlar, <literal>700</literal> atanırsa (yedinci yenileme) SUSv4'teki tanımlar da dahil olur.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm xml:id="glibc-vr_LARGEFILE_SOURCE" linkend="glibc-vr"> <primary sortas="LARGEFILE_SOURCE">_LARGEFILE_SOURCE</primary> </indexterm>
   <csproto type="makro">
    <csname><function>_LARGEFILE_SOURCE</function></csname>
   </csproto>
   <para>
    <dicterm><english>caveat</english><turkish>yetersizlik</turkish></dicterm>
    Bu makro belirtilirse önceki tüm standartlardaki birkaç eksikliği düzelten ek işlevler tanımlanmış olur. Özellikle, <function>fseeko</function> ve  <function>ftello</function> işlevleri kullanılabilir olur. Bu işlevleri olmaksızın &isoc; arayüzü (<function>fseek</function>, <function>ftell</function>) ile düşük seviyeli POSIX arayüzü (<function>lseek</function>) arasında bazı sorunlar ortaya çıkardı.
   </para>
   <para>
    Bu makro, Büyük Dosya Desteğinin (LFS - Large File Support) bir parçası olarak kütüphaneye dahil edilmiştir.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm xml:id="glibc-vr_LARGEFILE64_SOURCE" linkend="glibc-vr"> <primary sortas="LARGEFILE64_SOURCE">_LARGEFILE64_SOURCE</primary> </indexterm>
   <csproto type="makro">
    <csname><function>_LARGEFILE64_SOURCE</function></csname>
   </csproto>
   <para>
    Bu makroyu belirtirseniz, içerdiği ek işlevlerle 32 bitlik sistemlerdeki 2GB'lık dosya büyüklüğü sınırı aşılabilir. Bu arayüz, büyük dosyaları desteklemeyen sistemlerde kullanılamaz. Doğal dosya büyüklüğü 2GB'dan büyük olan sistemlerde (örn, 64 bitlik sistemler) ise yeni işlevler, mevcutlarla eşdeğerdir.
   </para>
   <para>
    Bu yeni işlevsellik mevcut olan türler ve işlevlerle yer değiştirilerek kullanılır. Bu yeni nesnelerin isimlerinde maksadını ifade edecek şekilde  <literal>64</literal> bulunur. Örneğin, <type>off_t</type> yerine <type>off64_t</type>, <function>fseeko</function> yerine  <function>fseeko64</function> gibi.
   </para>
   <para>
    <dicterm><english>Large File Support (LFS)</english><turkish>Büyük Dosya Desteği</turkish></dicterm>
    Bu makro, Büyük Dosya Desteğinin (LFS - Large File Support) bir parçası olarak kütüphaneye dahil edilmiştir. 64 bitlik kullanımın genele yansımadığı dönem için geçiş arayüzüydü. (Bkz: <statement linkend="glibc_FILE_OFFSET_BITS">_FILE_OFFSET_BITS</statement>).
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm xml:id="glibc-vr_FILE_OFFSET_BITS" linkend="glibc-vr"> <primary sortas="FILE_OFFSET_BITS">_FILE_OFFSET_BITS</primary> </indexterm>
   <csproto type="makro">
    <csname><function>_FILE_OFFSET_BITS</function></csname>
   </csproto>
   <para>
    Bu makro sistemde hangi dosya sistemi arayüzünün kullanılacağını belirlemekte kullanılır. <statement>_LARGEFILE64_SOURCE</statement>, bir ek arayüz olarak 64 bitlik arayüzü etkin kılar. <statement>_FILE_OFFSET_BITS</statement> ise 64 bitlik arayüzün eski arayüzü değiştirmesine izin verir.
   </para>
   <para>
    <statement>_FILE_OFFSET_BITS</statement> <literal>32</literal> değeri ile belirtilmişse 32 bitlik arayüz kullanılır ve <type>off_t</type> gibi türler 32 bitlik sistemlerde 32 bit boyutta olur.
   </para>
   <para>
    Makro, <literal>64</literal> değeri ile belirtilmişse, büyük dosya arayüzü eski arayüzün yerine geçer. Yani işlevler farklı isimler altında olmaz, (<statement>_LARGEFILE64_SOURCE</statement> ile olduğu gibi) eski işlev isimleri yenileri için geçerli olur. <function>fseeko</function> işlevi çağrıldığında aslında <function>fseeko64</function> işlevi çağrılmış olur.
   </para>
   <para>
    Makro tanımlı değilse, şimdilik <literal>64</literal> değeri öntanımlıdır, ancak Y2038 güvenliği için <type>time_t</type>'yi güncelleme gereksinimi nedeniyle bu öntanımlının değiştirilmesi planlanmaktadır, bu bakımdam bu öntanımlıya güvenilmemelidir.
   </para>
   <para>
    Bu makro sadece, sistem büyük dosyalarla çalışabileceğiniz bir mekanizma sağlıyorsa belirtilebilir. 64 bitlik sistemlerde <function>*64</function> isimli işlevler normal işlevlere eşdeğer olduğundan bu makro etkisizdir.
   </para>
   <para>
    Bu makro, Büyük Dosya Desteğinin (LFS - Large File Support) bir parçası olarak kütüphaneye dahil edilmiştir.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm xml:id="glibc-vr_TIME_BITS" linkend="glibc-vr"> <primary sortas="TIME_BITS">_TIME_BITS</primary> </indexterm>
   <csproto type="makro">
    <csname><function>_TIME_BITS</function></csname>
   </csproto>
   <para>
    Bu makro, <type>time_t</type>'nin bit boyutunu ve dolayısıyla <type>time_t</type>'den türetilmiş tüm türlerin bit boyutunu ve ilgili tüm işlevlerin bildirimlerini denetlemek için tanımlanmalıdır.
   </para>
   <para>
    <statement>_TIME_BITS</statement> tanımlanmazsa, <type>time_t</type>'nin bit boyutu mimariye bağlıdır. Şu anda çoğu mimaride öntanımlı olarak <literal>64</literal> bittir. Bazı geleneksel mimarilerde (i686, ARM) öntanımlı olarak <literal>32</literal> bit olsa da, bunun değişmesi planlanmıştır ve uygulamalar buna güvenmemelidir.
   </para>
   <para>
    <statement>_TIME_BITS</statement> değeri olarak <literal>64</literal> tanımlanırsa, <type>time_t</type>, <literal>64</literal> bitlik bir tamsayı olarak tanımlanır. <type>time_t</type>'nin geleneksel olarak <literal>32</literal> bit olduğu platformlarda, uygun sistem çağrılarına yapılan çağrılar, sistemin üzerinde çalıştığı Linux çekirdeği sürümüne bağlıdır. 5.1 üstü Linux çekirdeği sürümleri için <literal>64</literal> bitlik zamanı destekleyen sistem çağrıları kullanılır. Aksi takdirde, eski (yani 32 bitlik) sistem çağrılarını içeren son çare kodu kullanılır.
   </para>
   <para>
    <statement>_TIME_BITS</statement> değeri olarak <literal>32</literal> tanımlanırsa, desteklendiği yerlerde <type>time_t</type>, <literal>32</literal> bitlik tamsayı olarak tanımlanır. <literal>32</literal> bitlik <type>time_t</type> 2038 yılında çalışmayı durduracağı için bu önerilmez.
   </para>
   <para>
    Bunların dışındaki kullanımlarda bir derleme anı hatası oluşur.
   </para>
   <para>
    <code>_TIME_BITS=64</code> yalnızca <code>_FILE_OFFSET_BITS=64</code> de tanımlandığı takdirde tanımlanabilir.
   </para>
   <para>
    Bu makroyu kullanarak, belirli platformlar 64 bitlik zaman desteği ve sonuç olarak Y2038 sorununa karşı bağışıklık kazanır.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm xml:id="glibc-vr_ISOC99_SOURCE" linkend="glibc-vr"> <primary sortas="ISOC99_SOURCE">_ISOC99_SOURCE</primary> </indexterm>
   <indexterm xml:id="glibc-cp-ISOC99_SOURCE" linkend="glibc-cp"><primary>&isoc;99</primary> </indexterm>
   <csproto type="makro">
    <csname><function>_ISOC99_SOURCE</function></csname>
   </csproto>
   <para>
    Bu makro tanımlanırsa &isoc;99 özellikleri dahil edilir. Bu özellikler öntanımlı olarak dahil edildiğinden, bu makro çoğunlukla derleyici daha eski bir dil sürümü kullanıyorsa geçerlidir.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm xml:id="glibc-vr_ISOC11_SOURCE" linkend="glibc-vr"> <primary sortas="ISOC11_SOURCE">_ISOC11_SOURCE</primary> </indexterm>
   <indexterm xml:id="glibc-cp-ISOC11_SOURCE" linkend="glibc-cp"><primary>&isoc;11</primary> </indexterm>
   <csproto type="makro">
    <csname><function>_ISOC11_SOURCE</function></csname>
   </csproto>
   <para>
    Bu makro tanımlanırsa, &isoc;11 eklentileri &isoc;99 özelliklerine dahil edilir.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm xml:id="glibc-vr_ISOC2X_SOURCE" linkend="glibc-vr"> <primary sortas="ISOC2X_SOURCE">_ISOC2X_SOURCE</primary> </indexterm>
   <indexterm xml:id="glibc-cp-ISOC23_SOURCE" linkend="glibc-cp"><primary>&isoc;23</primary> </indexterm>
   <csproto type="makro">
    <csname><function>_ISOC2X_SOURCE</function></csname>
   </csproto>
   <para>
    Bu makro tanımlanırsa, &isoc;2X eklentileri &isoc;11 özelliklerine dahil edilir. GNU C Kitaplığı tarafından, bu taslak standardın yalnızca bazı özellikleri desteklenmektedir.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm xml:id="glibc-vr_STDC_WANT_LIB_EXT2" linkend="glibc-vr"> <primary sortas="STDC_WANT_LIB_EXT2">__STDC_WANT_LIB_EXT2__</primary> </indexterm>
   <indexterm xml:id="glibc-cp-STDC_WANT_LIB_EXT2" linkend="glibc-cp"><primary>ISO/IEC TR 24731-2:2010</primary> </indexterm>
   <csproto type="makro">
    <csname><function>__STDC_WANT_LIB_EXT2__</function></csname>
   </csproto>
   <para>
    <dicterm><english>ISO/IEC TR</english><turkish>ISO/IEC Teknik Raporu</turkish></dicterm>
    Bu makro <literal>1</literal> değeriyle tanımlanırsa, ISO/IEC TR 24731-2:2010 (Özdevimli Bellek Ayırma İşlevleri) özellikleri etkin olur. GNU C kütüphanesi, bu teknik rapordaki özelliklerin yalnızca bazılarını desteklemektedir.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm xml:id="glibc-vr_STDC_WANT_IEC_60559_BFP_EXT" linkend="glibc-vr"><primary sortas="STDC_WANT_IEC_60559_BFP_EXT">__STDC_WANT_IEC_60559_BFP_EXT__</primary></indexterm>
   <indexterm xml:id="glibc-cp-STDC_WANT_IEC_60559_BFP_EXT" linkend="glibc-cp"><primary>ISO/IEC TS 18661-1:2014</primary> </indexterm>
   <csproto type="makro">
    <csname><function>__STDC_WANT_IEC_60559_BFP_EXT__</function></csname>
   </csproto>
   <para>
    <dicterm><english>ISO/IEC TS</english><turkish>ISO/IEC Teknik Belirtimi</turkish></dicterm>
    Bu makro tanımlanırsa, ISO/IEC TS 18661-1:2014 (C için gerçek sayı genişletmeleri: İkil kayan noktalı aritmetik) özellikleri etkin olur. GNU C kütüphanesi, bu teknik belirtimdeki özelliklerin yalnızca bazılarını desteklemektedir.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm xml:id="glibc-vr_STDC_WANT_IEC_60559_FUNCS_EXT" linkend="glibc-vr"> <primary sortas="STDC_WANT_IEC_60559_FUNCS_EXT">__STDC_WANT_IEC_60559_FUNCS_EXT__ </primary> </indexterm>
   <indexterm xml:id="glibc-cp-TDC_WANT_IEC_60559_FUNCS_EXT" linkend="glibc-cp"><primary>ISO/IEC TS 18661-4:2015</primary> </indexterm>
   <csproto type="makro">
    <csname><function>__STDC_WANT_IEC_60559_FUNCS_EXT__</function></csname>
   </csproto>
   <para>
    Bu makro tanımlanırsa, ISO/IEC TS 18661-4:2015 (C için gerçek sayı genişletmeleri: Tamamlayıcı işlevler) özellikleri etkin olur. GNU C kütüphanesi, bu teknik belirtimdeki özelliklerin yalnızca bazılarını desteklemektedir.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm xml:id="glibc-vr_STDC_WANT_IEC_60559_TYPES_EXT" linkend="glibc-vr"> <primary sortas="STDC_WANT_IEC_60559_TYPES_EXT"> __STDC_WANT_IEC_60559_TYPES_EXT__ </primary> </indexterm>
   <indexterm xml:id="glibc-cp-STDC_WANT_IEC_60559_TYPES_EXT" linkend="glibc-cp"><primary>ISO/IEC TS 18661-3:2015</primary> </indexterm>
   <csproto type="makro">
    <csname><function>__STDC_WANT_IEC_60559_TYPES_EXT__</function></csname>
   </csproto>
   <para>
    Bu makro tanımlanırsa, ISO/IEC TS 18661-3:2015 (C için gerçek sayı genişletmeleri: Ara değişim türleri ve genişletilmiş türler) özellikleri etkin olur. GNU C kütüphanesi, bu teknik belirtimdeki özelliklerin yalnızca bazılarını desteklemektedir.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm xml:id="glibc-vr_STDC_WANT_IEC_60559_EXT" linkend="glibc-vr"> <primary sortas="STDC_WANT_IEC_60559_EXT">__STDC_WANT_IEC_60559_EXT__</primary> </indexterm>
   <csproto type="makro">
    <csname><function>__STDC_WANT_IEC_60559_EXT__</function></csname>
   </csproto>
   <para>
    Bu makro tanımlanırsa, bu standardın F ekinde tanımlanan &isoc;2X özellikleri etkinleştirilir. Bu, <function>totalorder</function> işlevlerinin bildirimlerini ve aktarılan NaN verilerle ilgili işlevleri etkiler.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm xml:id="glibc-vr_GNU_SOURCE" linkend="glibc-vr"> <primary sortas="GNU_SOURCE"> _GNU_SOURCE</primary> </indexterm>
   <csproto type="makro">
    <csname><function>_GNU_SOURCE</function></csname>
   </csproto>
   <para>
    Bu makro belirtildiğinde herşey etkin olur: &isoc;89, &isoc;99, POSIX.1, POSIX.2, BSD, SVID, X/Open, LFS ve GNU oluşumları. POSIX.1 ile BSD arasındaki çakışma olduğu durumlarda POSIX tanımları önceliklidir.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm xml:id="glibc-vr_DEFAULT_SOURCE" linkend="glibc-vr"> <primary sortas="DEFAULT_SOURCE">_DEFAULT_SOURCE</primary> </indexterm>
   <csproto type="makro">
    <csname><function>_DEFAULT_SOURCE</function></csname>
   </csproto>
   <para>
    Bu makro tanımlanırsa, X/Open, LFS ve GNU genişletmeleri dışında çoğu özellik dahil edilir: Bunun etkisi, POSIX'in 2008 sürümündeki özelliklerin yanı sıra, özelliklerini sınamak için ayrı bir özellik sınama makrosu olmaksızın belirli BSD ve SVID özelliklerini etkinleştirmektir.
   </para>
   <para>
    Derleyici seçeneklerinin içerilen özellikleri de etkilediği unutulmamalıdır:
   </para>
   <simplelist>
    <member>
     Katı uyumluluk seçeneği kullanılırsa, derleyicinin dil sürümünün ötesindeki özellikler devre dışı bırakılır, ancak bunları etkinleştirmek için özellik sınama makroları kullanılabilir.
    </member>
    <member>
     Derleyici seçenekleri tarafından etkinleştirilen özellikler, özellik sınama makroları tarafından geçersiz kılınmaz.
    </member>
   </simplelist>
  </csynopsis>
  <csynopsis>
   <indexterm xml:id="glibc-vr_ATFILE_SOURCE" linkend="glibc-vr"> <primary sortas="ATFILE_SOURCE">_ATFILE_SOURCE</primary> </indexterm>
   <csproto type="makro">
    <csname><function>_ATFILE_SOURCE</function></csname>
   </csproto>
   <para>
    Bu makro tanımlanırsa, ek olarak <function>*at</function> arayüzleri de dahil edilir.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm xml:id="glibc-vr_FORTIFY_SOURCE" linkend="glibc-vr"> <primary sortas="FORTIFY_SOURCE">_FORTIFY_SOURCE</primary> </indexterm>
   <csproto type="makro">
    <csname><function>_FORTIFY_SOURCE</function></csname>
   </csproto>
   <para>
    Bu makro <literal>1</literal> değeriyle tanımlanırsa, çeşitli kütüphane işlevlerine güvenlik güçlendirmesi eklenir.  <literal>2</literal> değeriyle tanımlanırsa, daha sıkı denetimler uygulanır. <literal>3</literal> değeriyle tanımlanırsa, GNU C kütüphanesi ayrıca ek bir başarım yükü getirebilen sınamalar kullanabilir.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm xml:id="glibc-vr_DYNAMIC_STACK_SIZE_SOURCE" linkend="glibc-vr"> <primary sortas="DYNAMIC_STACK_SIZE_SOURCE">_DYNAMIC_STACK_SIZE_SOURCE</primary> </indexterm>
   <csproto type="makro">
    <csname><function>_DYNAMIC_STACK_SIZE_SOURCE</function></csname>
   </csproto>
   <para>
    Bu makro tanımlanırsa, doğru (ancak derleme zamanı sabiti olmayan) <constant>MINSIGSTKSZ</constant>, <constant>SIGSTKSZ</constant> ve <constant>PTHREAD_STACK_MIN</constant> sabitleri tanımlanır.
   </para>
  </csynopsis>
  <csynopsis>
   <indexterm xml:id="glibc-vr_REENTRANT" linkend="glibc-vr"> <primary sortas="REENTRANT">_REENTRANT</primary> </indexterm>
   <indexterm xml:id="glibc-vr_THREAD_SAFE" linkend="glibc-vr"> <primary sortas="THREAD_SAFE">_THREAD_SAFE</primary> </indexterm>
   <csproto type="makro">
    <csname><function>_REENTRANT</function></csname>
   </csproto>
   <csproto type="makro">
    <csname><function>_THREAD_SAFE</function></csname>
   </csproto>
   <para>
    Bu makrolar artık kullanılmamaktadır. Bunlar <code>_POSIX_C_SOURCE</code> makrosunu <code>199506L</code> değeriyle tanımlamaya eşdeğerdir.
   </para>
   <para>
    Bazı çok eski C kütüphaneleri, temel işlevlerin (ör. <function>getchar</function>) evreler açısından güvenli olması için bu makrolardan birinin tanımlanmasını gerektiriyordu.
   </para>
  </csynopsis>
  <para>
   Yeni yazılımlarda <statement>_GNU_SOURCE</statement> kullanmanızı öneririz. GCC'ye <option>-ansi</option> seçeneğini veya <option>-std=c99</option> gibi diğer uygunluk seçeneklerini belirtmez ve bu makrolardan hiçbirini belirtmezseniz bunun etkisi <statement>__DEFAULT_SOURCE</statement> makrosunu <literal>1</literal> değeriyle atamaya eşdeğerdir.
  </para>
  <para>
   Daha geniş özellikler içeren bir özellik sınama makrosu ile birlikte bu makronun kapsamında olan makrolardan birini ayrıca belirtmenin bir etkisi yoktur. Örneğin, <command>_POSIX_C_SOURCE</command> makrosundan sonra <command>_POSIX_SOURCE</command> makrosunun belirtilmesinin bir etkisi olmayacaktır. Benzer şekilde <command>_GNU_SOURCE</command> makrosundan sonra belirtilen <command>_POSIX_SOURCE</command> veya  <command>_POSIX_C_SOURCE</command> makrolarının bir etkisi olmaz.
  </para>
  </sect1>
 </chapter>
</part>
