<?xml version="1.0" encoding="UTF-8"?>
<!-- ********************************************************************
   man3/crypt.3.xml, crypt_blowfish 1.3, permissive, NBB - Eylül 2022
******************************************************************** -->
<refentry xml:id="man3-crypt" xmlns="http://docbook.org/ns/docbook"
 xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:lang="tr">
 <info xmlns:t="http://tlbp.gen.tr/ns/tlbp">
  <t:pageinfo>
   <t:name>crypt</t:name>
   <t:volnum>3</t:volnum>
   <t:section>Kütüphane İşlevleri</t:section>
   <t:source>crypt_blowfish 1.3</t:source>
   <t:date>7 Temmuz 2014</t:date>
<t:remark>.ig
Written and revised by Solar Designer &lt;solar at openwall.com> in 2000-2011.
No copyright is claimed, and this man page is hereby placed in the public
domain.  In case this attempt to disclaim copyright and place the man page
in the public domain is deemed null and void, then the man page is
Copyright (c) 2000-2011 Solar Designer and it is hereby released to the
general public under the following terms:
|
Redistribution and use in source and binary forms, with or without
modification, are permitted.
|
There's ABSOLUTELY NO WARRANTY, express or implied.
|
This manual page in its current form is intended for use on systems
based on the GNU C Library with crypt_blowfish patched into libcrypt.
..</t:remark>
  </t:pageinfo>
 </info>
 <refnamediv>
  <refname>crypt</refname>
  <refpurpose>parola ve veri şifrelemesi</refpurpose>
 </refnamediv>
 <refnamediv>
  <refname>crypt_r</refname>
  <refpurpose>parola ve veri şifrelemesi</refpurpose>
 </refnamediv>
 <refnamediv>
  <refname>crypt_rn</refname>
  <refpurpose>parola ve veri şifrelemesi</refpurpose>
 </refnamediv>
 <refnamediv>
  <refname>crypt_ra</refname>
  <refpurpose>parola ve veri şifrelemesi</refpurpose>
 </refnamediv>
 <refnamediv>
  <refname>crypt_gensalt</refname>
  <refpurpose>parola ve veri şifrelemesi</refpurpose>
 </refnamediv>
 <refnamediv>
  <refname>crypt_gensalt_rn</refname>
  <refpurpose>parola ve veri şifrelemesi</refpurpose>
 </refnamediv>
 <refnamediv>
  <refname>crypt_gensalt_ra</refname>
  <refpurpose>parola ve veri şifrelemesi</refpurpose>
 </refnamediv>
 <refsynopsisdiv><title>BİLDİRİM</title>
  <funcsynopsis>
   <funcsynopsisinfo>
    <option>#include _XOPEN_SOURCE</option>
    <option>#include &lt;unistd.h></option>
   </funcsynopsisinfo>
   <funcprototype>
    <funcdef>char *<function>crypt</function></funcdef>
    <paramdef>const char *<parameter>key</parameter></paramdef>
    <paramdef>const char *<parameter>setting</parameter></paramdef>
   </funcprototype>
  </funcsynopsis>
  <funcsynopsis>
   <funcsynopsisinfo>
    <option>#include _GNU_SOURCE</option>
    <option>#include &lt;crypt.h></option>
   </funcsynopsisinfo>
   <funcprototype>
    <funcdef>char *<function>crypt_r</function></funcdef>
    <paramdef>const char *<parameter>key</parameter></paramdef>
    <paramdef>const char *<parameter>setting</parameter></paramdef>
    <paramdef>struct crypt_data *<parameter>data</parameter></paramdef>
   </funcprototype>
  </funcsynopsis>
  <funcsynopsis>
   <funcsynopsisinfo>
    <option>#include _QW_SOURCE</option>
    <option>#include &lt;crypt.h></option>
   </funcsynopsisinfo>
   <funcprototype>
    <funcdef>char *<function>crypt_rn</function></funcdef>
    <paramdef>const char *<parameter>key</parameter></paramdef>
    <paramdef>const char *<parameter>setting</parameter></paramdef>
    <paramdef>void *<parameter>data</parameter></paramdef>
    <paramdef>int <parameter>size</parameter></paramdef>
   </funcprototype>
   <funcprototype>
    <funcdef>char *<function>crypt_ra</function></funcdef>
    <paramdef>const char *<parameter>key</parameter></paramdef>
    <paramdef>const char *<parameter>setting</parameter></paramdef>
    <paramdef>void **<parameter>data</parameter></paramdef>
    <paramdef>int *<parameter>size</parameter></paramdef>
   </funcprototype>
   <funcprototype>
    <funcdef>char *<function>crypt_gensalt</function></funcdef>
    <paramdef>const char *<parameter>prefix</parameter></paramdef>
    <paramdef>unsigned long <parameter>count</parameter></paramdef>
    <paramdef>const char *<parameter>input</parameter></paramdef>
    <paramdef>int <parameter>size</parameter></paramdef>
   </funcprototype>
   <funcprototype>
    <funcdef>char *<function>crypt_gensalt_rn</function></funcdef>
    <paramdef>const char *<parameter>prefix</parameter></paramdef>
    <paramdef>unsigned long <parameter>count</parameter></paramdef>
    <paramdef>const char *<parameter>input</parameter></paramdef>
    <paramdef>int <parameter>size</parameter></paramdef>
    <paramdef>char <parameter>output</parameter></paramdef>
    <paramdef>int <parameter>output_size</parameter></paramdef>
   </funcprototype>
   <funcprototype>
    <funcdef>char *<function>crypt_gensalt_ra</function></funcdef>
    <paramdef>const char *<parameter>prefix</parameter></paramdef>
    <paramdef>unsigned long <parameter>count</parameter></paramdef>
    <paramdef>const char *<parameter>input</parameter></paramdef>
    <paramdef>int <parameter>size</parameter></paramdef>
   </funcprototype>
  </funcsynopsis>
 </refsynopsisdiv>
 <refsect1><title>AÇIKLAMA</title>
  <para>
   <function>crypt</function>, <function>crypt_r</function>, <function>crypt_rn</function> ve <function>crypt_ra</function> işlevleri,  bir tuz ve muhtemelen diğer değiştirgeleri de aktarmak için kullanılan bir dizi desteklenen yöntemden biriyle istendiği şekilde anahtarın kriptografik aş işlevini hesaplar.
  </para>
  <para>
   Unlike  crypt,  the functions crypt_r, crypt_rn and crypt_ra are reentrant.  They place their result
       and possibly their private data in a data area of size bytes as passed to  them  by  an  application
       and/or  in memory they allocate dynamically.  Some hashing algorithms may use the data area to cache
       precomputed intermediate values across calls.  Thus, applications must properly initialize the  data
       area  before its first use.  crypt_r requires that only data->initialized be reset to zero; crypt_rn
       and crypt_ra require that either the entire data area is zeroed or, in the case of  crypt_ra,  *data
       is  NULL.   When called with a NULL *data or insufficient *size for the requested hashing algorithm,
       crypt_ra uses realloc(3) to allocate the required amount of memory dynamically.  Thus, crypt_ra  has
       the  additional requirement that *data, when non-NULL, must point to an area allocated either with a
       previous call to crypt_ra or with a malloc(3) family call.  The memory allocated by crypt_ra  should
       be freed with free(3).

  </para>
  <para>
   The crypt_gensalt, crypt_gensalt_rn, and crypt_gensalt_ra functions compile a string for use as set‐
       ting - with the given prefix (used to choose a hashing method), the iteration count (if supported by
       the  chosen  method) and up to size cryptographically random input bytes for use as the actual salt.
       If count is 0, a low default will be picked.  The random bytes may be  obtained  from  /dev/urandom.
       Unlike crypt_gensalt, the functions crypt_gensalt_rn and crypt_gensalt_ra are reentrant.  crypt_gen‐
       salt_rn places its result in the output buffer of  output_size  bytes.   crypt_gensalt_ra  allocates
       memory for its result dynamically.  The memory should be freed with free(3).

  </para>
 </refsect1>
 <refsect1><title>DÖNÜŞ DEĞERİ</title>
  <para>
   Upon successful completion, the functions crypt, crypt_r, crypt_rn, and crypt_ra return a pointer to
       a string containing the setting that was actually used and a printable encoding of the hash function
       value.   The  entire  string  is  directly  usable  as  setting  with other calls to crypt, crypt_r,
       crypt_rn, and crypt_ra and as prefix with calls to crypt_gensalt, crypt_gensalt_rn,  and  crypt_gen‐
       salt_ra.
  </para>
  <para>
   The  behavior  of  crypt  on errors isn't well standardized.  Some implementations simply can't fail
       (unless the process dies, in which case they obviously can't return), others return NULL or a  fixed
       string.  Most implementations don't set errno, but some do.  SUSv2 specifies only returning NULL and
       setting errno as a valid behavior, and defines only one possible error (ENOSYS,  "The  functionality
       is  not  supported  on this implementation.")  Unfortunately, most existing applications aren't pre‐
       pared to handle NULL returns from crypt.  The description below corresponds to  this  implementation
       of  crypt  and  crypt_r  only, and to crypt_rn and crypt_ra.  The behavior may change to match stan‐
       dards, other implementations or existing applications.
  </para>
  <para>
   crypt and crypt_r may only fail (and return) when passed an invalid or unsupported setting, in which
       case they return a pointer to a magic string that is shorter than 13 characters and is guaranteed to
       differ from setting.  This behavior is safe for older applications which  assume  that  crypt  can't
       fail, when both setting new passwords and authenticating against existing password hashes.  crypt_rn
       and crypt_ra return NULL to indicate failure.  All four functions set errno when they fail.
  </para>
  <para>
       The functions crypt_gensalt, crypt_gensalt_rn, and crypt_gensalt_ra return a pointer to the compiled
       string for setting, or NULL on error in which case errno is set.
  </para>
 </refsect1>
 <refsect1><title>HATALAR</title>
  <glosslist>
   <glossentry>
   <glossterm><constant>EINVAL</constant></glossterm>
    <glossdef>
     <para>
      crypt,  crypt_r,  crypt_rn, crypt_ra: setting is invalid or not supported by this implementation;
     </para>
     <para>
      crypt_gensalt, crypt_gensalt_rn, crypt_gensalt_ra: prefix is invalid or not supported by this implementation; count is invalid for the requested prefix; the input size is insufficient for the smallest valid salt with the requested prefix; input is NULL.
     </para>
    </glossdef>
   </glossentry>
   <glossentry>
   <glossterm><constant>ERANGE</constant></glossterm>
    <glossdef>
     <para>
      crypt_rn: the provided data area size is insufficient for the requested hashing algorithm;
     </para>
     <para>
      crypt_gensalt_rn: output_size is too small to hold the compiled setting string.
     </para>
    </glossdef>
   </glossentry>
   <glossentry>
   <glossterm><constant>ENOMEM</constant></glossterm>
    <glossdef>
     <para>
      crypt (original glibc only): failed to allocate memory for the output  buffer  (which  subsequent calls would re-use);
     </para>
     <para>
      crypt_ra:  *data is NULL or *size is insufficient for the requested hashing algorithm and realloc(3) failed;
     </para>
     <para>
      crypt_gensalt_ra: failed to allocate memory for the compiled setting string.
     </para>
    </glossdef>
   </glossentry>
   <glossentry>
   <glossterm><constant>ENOSYS</constant></glossterm>
    <glossdef>
     <para>
      crypt (SUSv2): the functionality is not supported on this implementation;
     </para>
     <para>
      crypt, crypt_r (glibc 2.0 to 2.0.1 only): the crypt add-on is not compiled in and setting requests something other than the MD5-based algorithm.
     </para>
    </glossdef>
   </glossentry>
   <glossentry>
   <glossterm><constant>EOPNOTSUPP</constant></glossterm>
    <glossdef>
     <para>
      crypt,  crypt_r  (glibc 2.0.2 to 2.1.3 only): the crypt add-on is not compiled in and setting requests something other than the MD5-based algorithm.
     </para>
    </glossdef>
   </glossentry>
  </glosslist>
 </refsect1>
 <refsect1><title>AŞLAMA YÖNTEMLERİ</title>
  <para>
   The implemented hashing methods are intended specifically for processing user passwords for  storage and authentication; they are at best inefficient for most other purposes.
  </para>
  <para>
   It  is  important to understand that password hashing is not a replacement for strong passwords.  It is always possible for an attacker with access to password hashes to try  guessing  candidate  passwords against the hashes.  There are, however, certain properties a password hashing method may have which make these key search attacks somewhat harder.
  </para>
  <para>
   All of the hashing methods use salts such that the  same  key  may  produce  many  possible  hashes. Proper use of salts may defeat a number of attacks, including:
  </para>
  <orderedlist>
   <listitem>
    <para>
     The ability to try candidate passwords against multiple hashes at the price of one.
    </para>
   </listitem>
   <listitem>
    <para>
     The use of pre-hashed lists of candidate passwords.
    </para>
   </listitem>
   <listitem>
    <para>
     The  ability  to  determine  whether two users (or two accounts of one user) have the same or different passwords without actually having to guess one of the passwords.
    </para>
   </listitem>
  </orderedlist>
  <para>
   The key search attacks depend on computing hashes of large numbers of  candidate  passwords.   Thus, the  computational  cost of a good password hashing method must be high - but of course not too high to render it impractical.
  </para>
  <para>
   All hashing methods implemented within the crypt, crypt_r, crypt_rn,  and  crypt_ra  interfaces  use multiple  iterations  of an underlying cryptographic primitive specifically in order to increase the cost of trying a candidate password.  Unfortunately, due to hardware improvements, the hashing methods which have a fixed cost become increasingly less secure over time.
  </para>
  <para>
   In addition to salts, modern password hashing methods accept a variable iteration count.  This makes it possible to adapt their cost to the hardware improvements while still maintaining compatibility.
  </para>
  <para>
   The following hashing methods are or may be implemented within the described interfaces:
  </para>
  <refsect2><title>Traditional DES-based</title>
  <para>
   This method is supported by almost all implementations of crypt.  Unfortunately, it no longer offers adequate  security  because  of its many limitations.  Thus, it should not be used for new passwords unless you absolutely have to be able to migrate the password hashes to other systems.
  </para>
  <screen><!-- glosslist-->
prefix "" (empty string);
       a string matching ^[./0-9A-Za-z]{2} (see regex(7))

Encoding syntax
       [./0-9A-Za-z]{13}

Maximum password length
       8 (uses 7-bit characters)

Effective key size
       up to 56 bits

Hash size
       64 bits

Salt size
       12 bits

Iteration count
       25
</screen>
  </refsect2>
  <refsect2><title>Extended BSDI-style DES-based</title>
  <para>
   This method is used on BSDI and is also available on at least NetBSD, OpenBSD, and  FreeBSD  due  to the use of David Burren's FreeSec library.
  </para>
  <screen><!-- glosslist-->
 prefix "_"

 Encoding syntax
        _[./0-9A-Za-z]{19}

 Maximum password length
        unlimited (uses 7-bit characters)

 Effective key size
        up to 56 bits

 Hash size
        64 bits

 Salt size
        24 bits

 Iteration count
        1 to 2**24-1 (must be odd)
</screen>
  </refsect2>
  <refsect2><title>FreeBSD-style MD5-based</title>
  <para>
   This  is Poul-Henning Kamp's MD5-based password hashing method originally developed for FreeBSD.  It is currently supported on many free Unix-like systems, on Solaris 10 and newer, and it  is  part  of the  official  glibc.   Its main disadvantage is the fixed iteration count, which is already too low for the currently available hardware.
  </para>
  <screen><!-- glosslist-->
prefix "$1$"

Encoding syntax
       \$1\$[^$]{1,8}\$[./0-9A-Za-z]{22}

Maximum password length
       unlimited (uses 8-bit characters)

Effective key size
       limited by the hash size only

Hash size
       128 bits

Salt size
       6 to 48 bits

Iteration count
       1000
</screen>
  </refsect2>
  <refsect2><title>OpenBSD-style Blowfish-based (bcrypt)</title>
  <para>
    bcrypt was originally developed by Niels Provos and David Mazieres for OpenBSD and is also supported
       on  recent  versions of FreeBSD and NetBSD, on Solaris 10 and newer, and on several GNU/*/Linux dis‐
       tributions.  It is, however, not part of the official glibc.
  </para>
  <para>
   While both bcrypt and the BSDI-style DES-based hashing offer a variable iteration count, bcrypt  may
       scale to even faster hardware, doesn't allow for certain optimizations specific to password cracking
       only, doesn't have the effective key size limitation, and uses 8-bit characters in passwords.
  </para>
  <screen><!-- glosslist-->
prefix "$2b$"

Encoding syntax
       \$2[abxy]\$[0-9]{2}\$[./A-Za-z0-9]{53}

Maximum password length
       72 (uses 8-bit characters)

Effective key size
       limited by the hash size only

Hash size
       184 bits

Salt size
       128 bits

Iteration count
       2**4 to 2**99 (current implementations are limited to 2**31 iterations)
</screen>
  <para>
   With bcrypt, the count passed to crypt_gensalt, crypt_gensalt_rn, and crypt_gensalt_ra is the base-2
       logarithm of the actual iteration count.
  </para>
  <para>
   bcrypt hashes used the "$2a$" prefix since 1997.  However, in 2011 an implementation bug was discov‐
       ered in crypt_blowfish (versions up to 1.0.4 inclusive) affecting handling  of  password  characters
       with  the  8th bit set.  Besides fixing the bug, to provide for upgrade strategies for existing sys‐
       tems, two new prefixes were introduced: "$2x$", which fully re-introduces the bug, and "$2y$", which
       guarantees correct handling of both 7- and 8-bit characters.  OpenBSD 5.5 introduced the "$2b$" pre‐
       fix for behavior that exactly matches crypt_blowfish's "$2y$", and current  crypt_blowfish  supports
       it  as  well.  Unfortunately, the behavior of "$2a$" on password characters with the 8th bit set has
       to be considered system-specific.  When generating new password hashes, the "$2b$" or "$2y$"  prefix
       should  be  used.   (If  such  hashes ever need to be migrated to a system that does not yet support
       these new prefixes, the prefix in migrated copies of the already-generated hashes may be changed  to
       "$2a$".)
  </para>
  <para>
   crypt_gensalt,  crypt_gensalt_rn,  and  crypt_gensalt_ra support the "$2b$", "$2y$", and "$2a$" pre‐
       fixes (the latter for legacy programs or configurations), but not "$2x$" (which must not be used for
       new hashes).  crypt, crypt_r, crypt_rn, and crypt_ra support all four of these prefixes.
  </para>
  </refsect2>
 </refsect1>
 <refsect1><title>TAŞINABİLİRLİK</title>
  <para>
   Bir glibc 2.x sisteminde bu işlevlerden herhangi birini kullanan yazılımların, <systemitem class="library">libcrypt</systemitem> ile ilintilenmesi gerekir. Bununla birlikte, birçok Unix benzeri işletim sistemi ve GNU C Kitaplığının eski sürümleri, libc'de <function>crypt</function> işlevini içermektedir. <function>crypt</function> ve <function>crypt_r</function> glibc-2.28'de kaldırılmıştır.
  </para>
  <para>
   <function>crypt_r</function>, <function>crypt_rn</function>, <function>crypt_ra</function>, <function>crypt_gensalt</function>, <function>crypt_gensalt_rn</function> ve <function>crypt_gensalt_ra</function> işlevleri çok taşınabilir değildir.
  </para>
  <para>
   Desteklenen aşlama yöntemleri gerçeklenime bağımlıdır.
  </para>
 </refsect1>
 <refsect1><title>ÖZNİTELİKLER</title>
  <para>
   Bu bölümde kulllanılan terimlerin açıklamaları <uri xlink:href="man7-attributes"/> sayfasında bulunabilir.
  </para>
  <informaltable>
   <tgroup cols="3" colsep='1' rowsep='1'>
    <colspec colwidth="*"/>
    <colspec colwidth="*"/>
    <colspec colwidth="*"/>
    <thead align="left">
     <row>
      <entry>İşlev</entry>
      <entry>Öznitelik</entry>
      <entry>Değer</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><function>crypt</function>, <function>crypt_gensalt</function></entry>
      <entry>Evre Güvenliği</entry>
      <entry>ÇEG-hayır yarış:crypt</entry>
     </row>
     <row>
      <entry><function>crypt_r</function>, <function>crypt_rn</function>, <function>crypt_ra</function>, <function>crypt_gensalt_rn</function>, <function>crypt_gensalt_ra</function></entry>
      <entry>Evre Güvenliği</entry>
      <entry>ÇEG-evet</entry>
     </row>
    </tbody>
   </tgroup>
  </informaltable>
 </refsect1>
 <refsect1><title>TARİHÇE</title>
  <para>
   Rotor temelli <function>crypt</function> işlevi Sürüm 6 AT&amp;T UNIX'te göründü. "Geleneksel" DES temelli <function>crypt</function> ilk kez Sürüm 7 AT&amp;T UNIX'te göründü.
  </para>
  <para>
   <function>crypt</function> işlevi SVID, X/OPEN uyumludur ve BSD 4.3 üzerinde kullanılmaktadır. <function>crypt</function> tarafından döndürülen dizgelerin uyumlu sistemler arasında taşınabilir olması gerekmez.
  </para>
  <para>
   <function>crypt_r</function> GNU C Kütüphanesinden kaynaklanır.  HP-UX ve MKS Toolkit üzerinde de bir <function>crypt_r</function> içerir fakat tanım ve anlamsallığı farklıdır.
  </para>
  <para>
   <function>crypt_gensalt</function> Openwall eklentisidir. Solaris 10 ve üstü de bir <function>crypt_gensalt</function> içerir fakat tanım ve anlamsallığı farklıdır.
  </para>
  <para>
   <function>crypt_rn</function>, <function>crypt_ra</function>, <function>crypt_gensalt_rn</function> ve <function>crypt_gensalt_ra</function> işlevleri de Openwall eklentisidir.
  </para>
 </refsect1>
 <refsect1><title>HATA AYIKLAMA</title>
  <para>
   The return values of crypt and crypt_gensalt point to static buffers that are overwritten by  subse‐
       quent  calls.   These  functions  are  not  thread-safe.   (crypt on recent versions of Solaris uses
       thread-specific data and actually is thread-safe.)
  </para>
  <para>
   The strings returned by certain other implementations of crypt on error may be stored  in  read-only
       locations  or  only initialized once, which makes it unsafe to always attempt to zero out the buffer
       normally pointed to by the crypt return value as it would otherwise be preferable for security  rea‐
       sons.   The problem could be avoided with the use of crypt_r, crypt_rn, or crypt_ra where the appli‐
       cation has full control over output buffers of these functions (and often over some of their private
       data  as  well).   Unfortunately, the functions aren't (yet?) available on platforms where crypt has
       this undesired property.
  </para>
  <para>
   Applications using the thread-safe crypt_r need to allocate address space for the  large  (over  128
       KB)  struct  crypt_data  structure.   Each  thread  needs a separate instance of the structure.  The
       crypt_r interface makes it impossible to implement a hashing algorithm which would need to  keep  an
       even  larger amount of private data, without breaking binary compatibility.  crypt_ra allows for dy‐
       namically increasing the allocation size as required by the hashing algorithm that is actually used.
       Unfortunately, crypt_ra is even more non-portable than crypt_r.
  </para>
  <para>
   Multi-threaded  applications  or  library  functions  which  are  meant to be thread-safe should use  crypt_gensalt_rn or crypt_gensalt_ra rather than crypt_gensalt.
  </para>
 </refsect1>
 <refsect1><title>İLGİLİ BELGELER</title>
  <para>
   <uri xlink:href="man1-login"/>, <uri xlink:href="man1-passwd"/>, <uri xlink:href="man3-crypto"/>,  <uri xlink:href="man3-encrypt"/>, <uri xlink:href="man3-free"/>,<uri xlink:href="man3-getpass"/>, <uri xlink:href="man3-getpwent"/>, <uri xlink:href="man3-malloc"/>, <uri xlink:href="man3-realloc"/>, <uri xlink:href="man3-shadow"/>, <uri xlink:href="man5-passwd"/>, <uri xlink:href="man5-shadow"/>, <uri xlink:href="man7-regex"/>, <uri xlink:href="man8-pam"/>
  </para>
 </refsect1>
 <refsect1><title>ÇEVİREN</title>
  <simpara>Emin İslam Tatlı - Nisan 2004</simpara>
  <simpara>Nilgün Belma Bugüner - Eylül 2022</simpara>
  <simpara>
   Lütfen, çeviri ile ilgili bildirimler için &lt;belgeler-genel (at) lists.sourceforge.net&gt; adresini kullanın.
  </simpara>
 </refsect1>
</refentry>
