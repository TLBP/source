<?xml version="1.0" encoding="UTF-8"?>
<!-- ********************************************************************
     $Id: bgnet.xml,v 1.12 2002/12/20 23:23:58 nilgun Exp $
     ********************************************************************-->
<book id="bgnet">
<?dbhtml dir="../bgnet"?>
<bookinfo>
  <title>Beej'in Ağ Programlama Kılavuzu</title>
  <subtitle>Internet Soketlerini Kullanarak</subtitle>
  <pubdate>Şubat 2003</pubdate>
  <pubdate> </pubdate>
  <revhistory>
    <para><emphasis role="bold">Özgün belgenin sürüm bilgileri:</emphasis></para>
    <revision>
      <revnumber>1.0.0</revnumber>
      <date>Ağustos 1995</date>
      <authorinitials>beej</authorinitials>
      <revremark>İlk sürüm.</revremark>
    </revision>

    <revision>
      <revnumber>1.5.5</revnumber>
      <date>13 Ocak 1999</date>
      <authorinitials>beej</authorinitials>
      <revremark>Son HTML sürümü.</revremark>
    </revision>

    <revision>
      <revnumber>2.0.0</revnumber>
      <date>6 Mart 2001</date>
      <authorinitials>beej</authorinitials>
      <revremark>DocBook XML formatına dönüştürüldü, düzeltmeler ve eklemeler.</revremark>
    </revision>

    <!--
    <revision>
      <revnumber>Version 2.0.1</revnumber>
      <date>March 7, 2001</date>
      <authorinitials>beej</authorinitials>
      <revremark>Minor corrections.</revremark>
    </revision>

    <revision>
      <revnumber>Version 2.0.2</revnumber>
      <date>March 16, 2001</date>
      <authorinitials>beej</authorinitials>
      <revremark>inet_ntoa() should have been inet_aton() in some places.</revremark>
    </revision>

    <revision>
      <revnumber>Version 2.0.3</revnumber>
      <date>April 2, 2001</date>
      <authorinitials>beej</authorinitials>
      <revremark>inet_aton() return values corrected, selectserver
      changed, typos fixed, added recvtimeout().</revremark>
    </revision>

    <revision>
      <revnumber>Version 2.1.0</revnumber>
      <date>May 3, 2001</date>
      <authorinitials>beej</authorinitials>
      <revremark>Fixed buffer overruns in client.c and listener.c,
      made server.c robustly reap zombies, added email
      policy.</revremark>
    </revision>

    <revision>
      <revnumber>Version 2.2.0</revnumber>
      <date>June 24, 2001</date>
      <authorinitials>beej</authorinitials>
      <revremark>Updates QnA, Windows, talker.c, PF_INET info,
      accept() demo, no more bzero()s, Solaris setsockopt().</revremark>
    </revision>

    <revision>
      <revnumber>Version 2.2.1</revnumber>
      <date>June 25, 2001</date>
      <authorinitials>beej</authorinitials>
      <revremark>Minor QnA update, added Amazon affiliate
      stuff.</revremark>
    </revision>

    <revision>
      <revnumber>Version 2.3.0</revnumber>
      <date>July 25, 2001</date>
      <authorinitials>beej</authorinitials>
      <revremark>Added QnA entries, polished selectserver.c, added
            WSACleanup(), struct in_addr size clarification.</revremark>
    </revision>
    -->

    <revision>
      <revnumber>2.3.1</revnumber>
      <date>8 Ekim 2001</date>
      <authorinitials>beej</authorinitials>
      <revremark>
        client.c içindeki birkaç sözdizimi hatası giderildi, sıkça sorulan
        sorular bölümüne yeni malzeme eklendi.
      </revremark>
    </revision>
  </revhistory>

  <revhistory>
    <para><emphasis role="bold">Bu çevirinin sürüm bilgileri:</emphasis></para>
    <revision>
      <revnumber>0.9</revnumber>
      <date>15 Aralık 2002</date>
      <authorinitials>FZ</authorinitials>
      <revremark>
        Çeviri ve ilk kontroller yapıldı.
      </revremark>
    </revision>
  </revhistory>
  <authorgroup>
   <author>
    <firstname>Brian</firstname><surname>Hall</surname>
    <othername>"Beej"</othername>
    <affiliation>
      <address>
        <email>beej@piratehaven.org</email>
      </address>
    </affiliation>
  </author>
  <author role="translator">
    <firstname>Emre</firstname>
    <surname>Sevinç</surname>
    <othername>"FZ"</othername>
    <affiliation>
      <address>
        <email>fz@ileriseviye.org</email>
      </address>
    </affiliation>
  </author>
  </authorgroup>
  <abstract>
    <para>
      Bu belge bir öğretici olarak tasarlanmıştır ve tam teşekküllü bir başvuru
      kılavuzu değildir. Soket programlama konusuna ciddi ciddi merak salan
      bireyler tarafından adım adım okunursa işe yarayacaktır.
    </para>
  </abstract>
    <legalnotice><title>Yasal Açıklamalar</title>
      <para>
BU BELGE "ÜCRETSİZ" OLARAK RUHSATLANDIĞI İÇİN, İÇERDİĞİ BİLGİLER İÇİN İLGİLİ KANUNLARIN
İZİN VERDİĞİ ÖLÇÜDE HERHANGİ BİR GARANTİ VERİLMEMEKTEDİR. AKSİ YAZILI OLARAK BELİRTİLMEDİĞİ
MÜDDETÇE TELİF HAKKI SAHİPLERİ VE/VEYA BAŞKA ŞAHISLAR BELGEYİ "OLDUĞU GİBİ", AŞİKAR VEYA
ZIMNEN, SATILABİLİRLİĞİ VEYA HERHANGİ BİR AMACA UYGUNLUĞU DA DAHİL OLMAK ÜZERE HİÇBİR
GARANTİ VERMEKSİZİN DAĞITMAKTADIRLAR. BİLGİNİN KALİTESİ İLE İLGİLİ TÜM SORUNLAR SİZE AİTTİR.
HERHANGİ BİR HATALI BİLGİDEN DOLAYI DOĞABİLECEK OLAN BÜTÜN SERVİS, TAMİR VEYA DÜZELTME
MASRAFLARI SİZE AİTTİR.
    </para><para>
İLGİLİ KANUNUN İCBAR ETTİĞİ DURUMLAR VEYA YAZILI ANLAŞMA HARİCİNDE HERHANGİ BİR ŞEKİLDE
TELİF HAKKI SAHİBİ VEYA YUKARIDA İZİN VERİLDİĞİ ŞEKİLDE BELGEYİ DEĞİŞTİREN VEYA YENİDEN
DAĞITAN HERHANGİ BİR KİŞİ, BİLGİNİN KULLANIMI VEYA KULLANILAMAMASI (VEYA VERİ KAYBI OLUŞMASI,
VERİNİN YANLIŞ HALE GELMESİ, SİZİN VEYA ÜÇÜNCÜ ŞAHISLARIN ZARARA UĞRAMASI VEYA BİLGİLERİN
BAŞKA BİLGİLERLE UYUMSUZ OLMASI) YÜZÜNDEN OLUŞAN GENEL, ÖZEL, DOĞRUDAN YA DA DOLAYLI HERHANGİ
BİR ZARARDAN, BÖYLE BİR TAZMİNAT TALEBİ TELİF HAKKI SAHİBİ VEYA İLGİLİ KİŞİYE BİLDİRİLMİŞ
OLSA DAHİ, SORUMLU DEĞİLDİR.
    </para><para>
Tüm telif hakları aksi özellikle belirtilmediği sürece sahibine aittir. Belge içinde geçen herhangi bir terim, bir ticari isim ya da kuruma itibar kazandırma olarak algılanmamalıdır. Bir ürün ya da markanın kullanılmış olması ona onay verildiği anlamında görülmemelidir.
      </para>
    </legalnotice>
</bookinfo>

<!-- ======================================================= -->
<!-- Introduction -->
<!-- ======================================================= -->
  <chapter id="bgnet_intro">
    <title>Giriş</title>
    <para>
      Hey! Soket programlama ile başınız belada mı? Bütün bu ayrıntılar
      <command>man</command> sayfalarından çekip çıkarmak için çok mu zor?
      En temel Internet programlama tekniklerini öğrenmek istiyorsunuz ama
      tonlarca <literal>struct</literal> ve bunları <function>bind()</function>
      işlevini çağırmadan <function>connect()</function>, vs., vs.ye parametre
      olarak nasıl geçeceğiniz konusunda binlerce ayrıntıyı öğrenmeye vaktiniz
      yok mu?
    </para><para>
      Hmm, bakın burada ne var? Bütün bu sinir bozucu ayrıntılarla ben zamanında
      boğuştum ve herkesle deneyimlerimi paylaşmak için can atıyorum! Doğru yere
      geldiniz. Bu belge ortalama bir C programcısına tüm bu ağ meseleleri ile
      ilgili temel kavramları ve pratik uygulamaları verecek düzeydedir.
    </para>
<!-- ======================================================= -->
<!-- Audience -->
<!-- ======================================================= -->
    <sect1 id="bgnet_intro-whom">
      <title>Kimin İçin?</title>
      <para>
        Bu belge bir öğretici olarak tasarlanmıştır ve tam teşekküllü bir başvuru
        kılavuzu değildir. Soket programlama konusuna ciddi ciddi merak salan
        bireyler tarafından adım adım okunursa işe yarayacaktır. Bu belge kesinlikle
        <emphasis>eksiksiz</emphasis> bir soket programlama kılavuzu değildir.
      </para><para>
        Eğer şu man sayfalarının sizin için biraz daha anlamlı hale gelmesini
        sağlarsa bu belge amacına ulaşmış demektir...<literal>:-)</literal>
      </para>
    </sect1>
<!-- ======================================================= -->
<!-- Platform and Compiler -->
<!-- ======================================================= -->
    <sect1 id="bgnet_intro-platform">
      <title>Platform ve Derleyiciler</title>
      <para>
        Bu belgedeki kodlar Linux çalıştıran bir PC üzerinde Gnu'nun
        <command>gcc</command> derleyicisi ile derlenmiştir. Ancak
        <command>gcc</command> derleyicisinin çalışabildiği her platformda
        derlenebilir. Tabii eğer Windows kullanıyorsanız yukarıda dediklerim
        geçerli değildir. Bunun için aşağıdaki <xref linkend="bgnet_intro-windows"/>
        bölümüne bakın.
      </para>
    </sect1>
<!-- ======================================================= -->
<!-- Homepage -->
<!-- ======================================================= -->
    <sect1 id="bgnet_intro-homepage">
      <title>Resmi Anasayfa</title>
      <para>
        Bu belgenin resmi adresi California Devlet Üniversitesi, Chico,
        <ulink url="http://www.ecst.csuchico.edu/~beej/guide/net/"/>'dir.
      </para>
    </sect1>
<!-- ======================================================= -->
<!-- Solaris and SunOS -->
<!-- ======================================================= -->
    <sect1 id="bgnet_intro-solaris">
      <title>Solaris/SunOS Programcılarının Dikkat Etmesi Gerekenler</title>
      <para>
        Solaris ya da SunOS için derlerken gerekli işlev kitaplıklarını
        programa bağlayabilmek için bazı ek parametreler vermeniz gerekebilir.
        Bunun için <literal>-lnsl -lsocket -lresolv</literal> parametrelerini
        derleme komutunuzun sonuna ekleyebilirsiniz, örnek:
      </para><para>
<screen>
<prompt>$</prompt> <userinput>cc -o server server.c -lnsl -lsocket -lresolv</userinput>
</screen>
      </para><para>
        eğer hala hata alıyorsanız şunu da ekleyin: <literal>-lxnet</literal>.
        Ne işe yaradığını bilmiyorum ama görünen o ki bazı durumlarda
        gerekebiliyor.
      </para><para>
        Problem yaşayabileceğiniz bir başka yer de <function>setsockopt()</function>
        işlevinin çağrıldığı yerdir. Bu işlevin Solaris/SunOS'taki prototipi benim
        Linux makinamdakinden farklıdır bu yüzden de:
      </para><para>
        <screen>int yes=1;</screen>
      </para><para>
        yerine bunu girin:
      </para><para>
        <screen>char yes='1';</screen>
      </para><para>
        Elimde bir Sun makinası yok, yukarıdakileri denemedim bu bilgiler bana
        deneme yapıp e-posta gönderen insanların söylediklerinden ibarettir.
      </para>
    </sect1>
<!-- ======================================================= -->
<!-- Windows -->
<!-- ======================================================= -->
    <sect1 id="bgnet_intro-windows">
      <title>Windows Programcılarının Dikkat Etmesi Gerekenler</title>
      <para>
        Windows'dan pek hoşlandığım söylenemez bu yüzden de bu belgeyi okuyan
        tüm Windows programcılarını GNU/Linux, BSD ya da UNIX denemeye davet
        ediyorum. Bu laflardan sonra, evet, örnek kodları Windows üzerinde
        kullanma imkanınız var.
      </para><para>
        Öncelikle burada bahsettiğim birçok sistem başlık dosyasını unutun.
        Tek yapmanız gereken aşağıdakileri programınıza katmak:
      </para><para>
<screen>
#include &lt;winsock.h>
</screen>
      </para><para>
        Bir dakika! Aynı zamanda <function>WSAStartup()</function> işlevini de
        soket kitaplıkları ile herhangi bir iş yapmadan önce çağırmanız gerekiyor.
        Bunu yapmak için gerekli kod şöyle bir şey:
      </para><para>
<screen>
#include &lt;winsock.h>

{
    WSADATA wsaData;   // if this doesn't work
    //WSAData wsaData; // then try this instead

    if (WSAStartup(MAKEWORD(1, 1), &amp;wsaData) != 0) {
        fprintf(stderr, "WSAStartup failed.\n");
        exit(1);
    }
</screen>
      </para><para>
        Tabii derleyicinize Winsock'u da bağlamasını söylemelisiniz. Bunun için
        gerekli dosyanın ismi genellikle şudur: <filename>wsock32.lib</filename>
        veya <filename>winsock32.lib</filename> veya benzer bir şey. VC++
        ortamında iseniz, bunun için <literal>Project</literal> menüsünden,
        <literal>Settings...</literal> kısmına gidin ve <literal>Link</literal>
        sekmesine gelip <literal>Object/library modules</literal> kutusunu bulun.
        <filename>wsock32.lib</filename> dosyasını bu listeye ekleyin.
      </para><para>
        En azından ben böyle duydum.
      </para><para>
        Ve son olarak da <function>WSACleanup()</function> işlevini çağırmanız
        gerekir soket kitaplığı ile işiniz bittiğinde. Ayrıntılı bilgi için
        derleyicinizin yardım belgelerine bakın.
      </para><para>
        Bunu yaptığınızda bu belgedeki örneklerin hemen hepsi genel olarak
        çalışabilir durumda olmalı belki birkaç küçük değişiklik yapmanız
        gerekebilir ama hepsi bu. Dikkat etmeniz gerekenler: Soketi kapatmak
        için <function>close()</function> işlevini kullanamazsınız -- bunun
        için <function>closesocket()</function> işlevini kullanmalısınız.
        Ayrıca <function>select()</function> işlevi sadece soket tanımlayıcılar
        içindir, dosya tanımlayıcılar (standart girdi için 0 kullanılması gibi)
        için değildir.
      </para><para>
        Aynı zamanda, <literal>CSocket</literal> isimli bir soket sınıfı da mevcuttur.
        Ayrıntılı bilgi için derleyicinizin belgelerini karıştırın.
      </para><para>
        Winsock hakkında ayrıntılı bilgi için şu adrese bakabilirsiniz: <ulink
        url="http://tangentsoft.net/wskfaq/">Winsock FAQ</ulink>
      </para><para>
        Son olarak da bildiğim kadarı ile Windows ortamında <function>fork()</function>
        isimli işlev yok ve maalesef örneklerde bu işlevi kullanmak durumdayım.
        Belki de bir POSIX kitaplığına programınızı bağlamanız gerekebilir veya
        <function>CreateProcess()</function> işlevini kullanabilirsiniz.
        <function>fork()</function> işlevi herhangi bir argüman almaz ama
        <function>CreateProcess()</function> işlevi 48 milyar argüman alır.
        Eğer bu gözünüzü biraz korkuttu ise <function>CreateThread()</function>
        işlevi biraz daha kolay bir alternatif olabilir ancak "multithreading"
        tartışması bu belgenin sınırlarının ötesindedir. Windows konusunu böylece
        burada kapatıyoruz!
      </para>
    </sect1>
<!-- ======================================================= -->
<!-- Email policy -->
<!-- ======================================================= -->
    <sect1 id="bgnet_intro-emailpolicy">
      <title>E-posta Politikası</title>
      <para>
        Genellikle e-posta ile gönderilen sorulara cevap vermeye çalışırım, bu
        yüzden yazmaktan çekinmeyin, ancak bu size cevap vereceğim anlamına
        gelmez. Epey meşgulüm ve bazen sorunuzun cevabını tam olarak bilmiyor
        olabilirim. Durum bu olduğunda mesajınızı silerim lütfen bunu şahsınıza
        yönelik bir harekete olarak algılamayın. İnanın bana sorduğunuz her
        soruyu en ince ayrıntısına kadar cevaplayacak kadar vaktim olmayabilir.
      </para><para>
        Basit bir kural: Sorunuz ne kadar karmaşık ise cevap verme ihtimalim o
        kadar düşüktür. Eğer soru kapsamını daraltır ve derdinizle ilgili
        ayrıntılı bilgileri de yollarsanız (platform, derleyici, hata mesajları,
        vs.), cevap alma ihtimaliniz artar. Daha ayrıntılı bilgi için şu adresi
        tavsiye ederim: <ulink url="http://www.tuxedo.org/~esr/faqs/smart-questions.html">How To Ask Questions The Smart
        Way</ulink>.
      </para><para>
        Eğer cevap alamıyorsanız biraz daha kurcalayın programınızı ve cevabı
        bulmaya çalışın. Hala çözemedi iseniz o zaman bana gene yazın ve belki
        o zaman elimizdeki ayrıntılı bilgilerle probleme bir çözüm bulmamız daha
        kolay olabilir.
      </para><para>
        Şimdi sizi bana nasıl yazmanız ve yazmamanız konusunda <emphasis>yeterince</emphasis>
        eğittiğime göre bu kılavuzla ilgili süreç içinde bana ulaştırılan
        övgülerin beni ne kadar motive ettiğini de itiraf etmek isterim.
        <literal>:-)</literal> Teşekkürler!
      </para>
    </sect1>
<!-- ======================================================= -->
<!-- Mirroring -->
<!-- ======================================================= -->
    <sect1 id="bgnet_intro-mirror">
      <title>Yansılama</title>
      <para>
        Sitemin bir yansısını barındırmak istiyorsanız memnuniyet duyarım. Eğer
        oluşturacağınız yansıya ana sayfamdan link vermek isterseniz
        <email>beej@piratehaven.org</email> adresine bir mesaj yollamanız yeterli
        olacaktır.
      </para>
    </sect1>
<!-- ======================================================= -->
<!-- Translators -->
<!-- ======================================================= -->
    <sect1 id="bgnet_intro-translators">
      <title>Çevirmenlerin Dikkatine</title>
      <para>
        Eğer bu belgeyi başka bir dile çevirmek isterseniz lütfen
        <email>beej@piratehaven.org</email> adresinden benimle iletişim kurun böylece ana
        sayfadan sizin tercümenizin bulunduğu sayfaya bağ verebilirim.
      </para><para>
        Çeviriye kendi isminizi ve e-posta adresinizi eklemekte tereddüt etmeyin.
      </para><para>
        Üzgünüm yer kısıtlamasından ötürü sizin çevirinizi kendi sitemde
        barındıramam.
      </para>
    </sect1>
<!-- ======================================================= -->
<!-- Copyright -->
<!-- ======================================================= -->
    <sect1 id="bgnet_intro-copyright">
      <title>Telif Hakkı ve Dağıtım</title>
      <para>
        Beej's Guide to Network Programming - Copyright © 1995-2001
        Brian "Beej" Hall.
      </para><para>
        Bu belge bütünlüğü korunduğu, içeriği değiştirilmediği ve bu kopyalama
        bilgisi de yayınlandığı sürece herhangi bir ortamda serbestçe yeninden
        yayınlanabilir.
      </para><para>
        Öğretim görevlileri bu belgeyi öğrencilerine tavsiye edebilirler.
      </para><para>
        Bu belge herhangi bir dile tercüme edilebilir yeter ki söz konusu tercüme
        aslına sadık kalsın ve belgenin bütünlüğünü bozmasın. Tercüme, tercümeyi
        yapanın ismini ve temas bilgilerini içerebilir.
      </para><para>
        Belgedeki C kaynak kodları kamuya açıktır.
      </para><para>
        İletişim adresim: <email>beej@piratehaven.org</email>.
      </para>
    </sect1>
  </chapter> <!-- /Introduction -->
<!-- ======================================================= -->
<!-- What is a socket? -->
<!-- ======================================================= -->
  <chapter id="bgnet_theory">
    <title>Soket Nedir?</title>
    <para>
      Sürekli "socket"lerden bahsedildiğini duymuşsunuzdur ve belki de bunların
      tam olarak ne anlama geldiğini merak ediyor olabilirsiniz. Soket kısaca
      şudur: Diğer programlarla standart Unix dosya tanımlayıcılarını kullanarak
      haberleşmenizi sağlayan bir yapı.</para><para>Ne?
    </para><para>
      Pekala -- bazı Unix hacker'larının, "Vay canına! Unix'teki hemen hemen
      <emphasis>herşey</emphasis> bir dosya!" dediğini duymuş olabilirsiniz.
      Böyle konuşan birinin kast ettiği aslında Unix programlarının, herhangi
      bir G/Ç işlemi yaptıklarında bunları bir dosya tanımlayıcıyı okuyarak
      ya da ona yazarak yaptıklarıdır. Bir dosya tanımlayıcı basitçe söylemek
      gerekirse açık bir dosya ile ilişkilendirilmiş bir tamsayıdır. Ancak
      (işin püf noktası da burası), söz konusu bu açık dosya diskteki normal
      bir dosya olabileceği gibi aynı zamanda bir ağ bağlantısı, bir FIFO,
      bir uçbirim ya da başka herhangi bir veri kaynağı olabilir. Gerçekten
      de Unix ortamında her şey bir dosyadır! Öyleyse Internet üzerinden başka
      bir programla iletişim kurmak isterseniz bunu bir dosya tanımlayıcı
      üzerinden yapacaksınız, inanın buna.
    </para><para>
      "Peki bay çok bilmiş, ağ iletişimi için kullanacağım bu dosya tanımlayıcı
      nerede?" gibi bir soru aklınıza gelmemiş olabilir ancak ben gene de cevabını
      vereyim ki içiniz rahat etsin: Bu dosya tanımlayıcıya ulaşmak için
      <function>socket()</function> sistem işlevini çağırmanız gerekir. Bu işlev
      size soket tanımlayıcıyı döndürür ve siz de bunu ve tabii
      <function>send()</function> ile <function>recv()</function>
      (<command><ulink url="http://linux.com.hk/man/showman.cgi?manpath=/man/man2/send.2.inc">man send</ulink></command>,
      <command><ulink url="http://linux.com.hk/man/showman.cgi?manpath=/man/man2/recv.2.inc">man recv</ulink></command>)
      isimli soket işlevlerini kullanarak istediğiniz şekilde iletişimizini
      kurarsınız.
    </para><para>
      "Hey, bir dakika!" diyebilirsiniz şimdi. "Eğer bir dosya tanımlayıcı söz
      konusu ise o halde tanrı aşkına neden her zaman kullandığım normal
      <function>read()</function> ve <function>write()</function> işlevlerini
      kullanarak soketler üzerinden iletişim kuramayayım ki?" Kısa cevap:
      "Evet tabii ki!" Uzun cevap ise "Evet, mümkün ama
      <function>send()</function> ve <function>recv()</function> işlevleri
      veri iletişiminde çok daha fazla kontrol sağlar ve işinizi kolaylaştırır."
    </para><para>
      Sırada ne var? Buna ne dersiniz: çeşit çeşit soket vardır. Mesela DARPA
      Internet adresleri (Internet Soketleri), yerel bir düğümdeki (node) yol
      isimleri (Unix Soketleri), CCITT X.25 adresleri (X.25 Soketleri ki inanın
      bunları bilmeseniz de olur) ve kullandığınız Unix sürümüne bağlı daha pek
      çok soket tipi. Bu belge sadece birinci tür soketleri ele almaktadır,
      yani: Internet Soketleri.
    </para>
<!-- ======================================================= -->
<!-- Two Types of Internet Sockets -->
<!-- ======================================================= -->
    <sect1 id="bgnet_theory-twotypes">
      <title>Internet Soketlerinin İki türü</title>
      <para>
        Bu da ne? İki tür Internet soketi mi var? Evet. Şey, aslında hayır.
        Yalan söyledim. Daha çok var ama sizi korkutmak istemedim. Size sadece iki
        tür soketten bahsedeceğim. Sadece "Ham Soketler"in (Raw Sockets) çok güçlü
        olduğunu belirttiğim bu cümle dışında yani, bir ara bunlara da göz atarsanız
        iyi olur.
      </para><para>
        Pekala, gelelim şu iki tür sokete. Bir tanesi "Veri Akış Soketleri";
        diğeri ise "Veri Paketi Soketleri" ve artık biz bunlara sırası ile
        "<constant>SOCK_STREAM</constant>" ve "<constant>SOCK_DGRAM</constant>"
        diyeceğiz. Veri paketi soketleri bazen "bağlantısız soketler" olarak da
        isimlendirilir. (Her ne kadar eğer isterseniz bunlara <function>connect()</function>
        işlevi ile bağlanabilecek olsanız da. Detaylı bilgi için aşağıdaki
        <link linkend="bgnet_syscalls-connect">connect()</link> maddesine bakın.)
      </para><para>
        Veri akış soketleri güvenilir iki yönlü iletişim kanallarıdır. Eğer bu
        tür bir sokete sıra ile "1, 2" bilgilerini gönderirseniz, bunlar kanalın
        diğer ucundan "1, 2" şeklinde çıkar. Aynı zamanda bu iletişim olası
        hatalara karşı da korumalıdır. Karşılaşacağınız her türlü hatanın kaynağı
        sizin karman çorman aklınız olacaktır ve burada bunları tartışmaya niyetim
        yok.
      </para><para>
        Stream soketleri gerçek hayatta ne işimize yarar? Hmm, sanırım
        <command>telnet</command> diye bir program duymuşsunuzdur, değil mi? İşte
        bu program veri akış soketlerini kullanır. Yazdığınız tüm karakterler
        sizin yazdığınız sırada iletilmelidir öyle değil mi? Aynı zamanda web
        tarayıcılar da HTTP protokolü ile iletişim kurarken veri akış soketleri
        aracılığı ile sayfa bilgilerini çekerler. Gerçekten de eğer bir web
        sitesine <command>telnet</command> ile 80 numaralı port üzerinden
        bağlanır ve "<literal>GET /</literal>" komutunu yollarsanız web sitesi
        size HTML içeriğini yollayacaktır.
      </para><para>
        Veri akış soketleri bu kadar sorunsuz bir veri iletişimini nasıl
        gerçekleştirir? Bunun için "Aktarım Denetim Protokolü" (Transmission
        Control Protocol) isimli kurallar dizisinden yararlanırlar ki siz
        bunu "TCP" olarak da duymuş olabilirsiniz (bkz. <ulink
        url="http://www.rfc-editor.org/rfc/rfc793.txt">RFC-793</ulink> bu belge TCP ile ilgili çok
        ayrıntılı bilgi içerir.) TCP yollanan verinin sıralı ve düzgün gitmesini
        sağlar. "TCP"yi daha önce "TCP/IP" kısaltmasının bir parçası olarak
        duymuş olabilirsiniz ki "IP" de "Internet Protocol" sözünün kısaltmasıdır
        (bkz. <ulink url="http://www.rfc-editor.org/rfc/rfc791.txt">RFC-791</ulink>.) IP kurallar
        dizisi temelde Internet yönlendirme ile ilgilidir, veri bütünlüğünün
        korunması ile ilgili pek kural içermez.
      </para><para>
        Harika. Peki veri paketi soketleri? Neden bunlara bağlantısız deniyor?
        Mesele nedir kısaca? Neden bunların "güvenilmez" olduğu söyleniyor?
        Bakın, bilmeniz gereken bazı gerçekler var: eğer bir veri paketi
        yollarsanız bu hedefine ulaşabilir de ulaşmayabilir de. Gönderdiğiniz
        sırada ulaşması garanti edilemez. Ancak eğer hedefe ulaşırsa paketin
        içerdiği bilgi hatasız olacaktır.
      </para><para>
        Veri paketi soketleri de yönlendirme için IP protokolünü kullanırlar ancak
        TCP'den faydalanmazlar onun yerine "Kullanıcı Veri Paketi Protokokü" (User
        Datagram Protocol) veya "UDP" isimli protokolü kullanırlar (bkz. <ulink
        url="http://www.rfc-editor.org/rfc/rfc768.txt">RFC-768</ulink>.)
      </para><para>
        Neden bağlantısızdırlar? Aslında böyledirler çünkü veri akış soketlerinde
        olduğu gibi bağlantıyı sürekli açık tutmanız gerekmemektedir. Sadece bir
        paketi oluşturur, tepesine gideceği adresi söyleyen bir IP başlığı yapıştırır
        ve onu yollarsınız. Herhangi bir bağlantı açmaya gerek yoktur. Bu tip
        soketler genellikle paket paket iletilen veri için kullanılır. Bu tip
        soketleri kullanan örnek uygulamalardan bazıları: <command>tftp</command>,
        <command>bootp</command>, vs.
      </para><para>
        "Yeter artık!" diye bağırdığınızı duyar gibiyim. "Eğer veri paketlerinin
        yolda kaybolma ihtimali varsa nasıl olur da yukarıda saydığın programlar
        çalışır?!" Bak dünyalı dostum bu saydığım programların hepsi UDP protokolü
        üzerine kendi protokollerini yerleştirirler. Mesela, <command>tftp</command>
        protokolüne göre gönderilen her paket için karşı tarafın "aldım!"
        (bir "ACK" paketi) paketini geri yollaması gerekir. Eğer orjinal paketin
        göndericisi mesela 5 saniye içinde cevap alamazsa o zaman paketi yeniden
        yollar, taa ki ACK cevabını alana kadar. İşte bu "aldım" prosedürü
        <constant>SOCK_DGRAM</constant> uygulamalarında çok önemlidir.
      </para>
    </sect1>
<!-- ======================================================= -->
<!-- Two Types of Internet Sockets -->
<!-- ======================================================= -->
    <sect1 id="bgnet_theory-lowlevel">
      <title>Düşük Seviye Duyarsızlığı ve Ağ Teorisi</title>
      <para>
        Protokol katmanlarından bahsettiğime göre artık ağların nasıl çalıştığına
        dair gerçekleri öğrenmenin ve <constant>SOCK_DGRAM</constant> paketlerinin
        nasıl oluşturulduğuna dair örnekler vermenin zamanı geldi. Pratik olarak
        bu bölümü atlayabilirsiniz, ancak burayı okursanız iyi bir temel bilgiye
        sahip olursunuz.
      </para><para>
        <figure float="0" id="bgnet_figure1">
          <title>Veri Paketlemesi (data encapsulation)</title>
          <inlinemediaobject>
            <imageobject>
              <imagedata align="middle"  fileref="dataencap.gif"/>
            </imageobject>
            <caption>Protokollerin Veriyi Paketlemesi</caption>
          </inlinemediaobject>
        </figure>
      </para><para>
        Hey çocuklar, Veri Paketleme konusunu öğrenme zamanı! Bu çok çok önemli.
        O kadar önemli o kadar önemli ki burada yani Chico Eyaletinde ağ
        teknolojilerine dair bir kurs alırsanız bu konu ile mutlaka
        karşılaşırsınız <literal>;-)</literal>. Temelde konu şu: bir paket doğar,
        sonra bu paket önce muhatap olduğu ilk protokol tarafından (mesela TFTP
        protokolü) ile bir başlık (ve ender olarak da olsa bir dipnot ile)
        kullanılarak paketlenir (kapsüle konur), ardından tüm bu yığın
        (TFTP başlığı da dahil) bir sonraki protokolün (örn. UDP) kurallarına
        göre paketlenir, sonra IP ve en sonundaki en alt katman olan donanım
        katmanındaki fiziksel protokol ile (örn. Ethernet) paketlenir.
      </para><para>
        Başka bir bilgisayar bu paketlenmiş paketi aldığında önce donanım Ethernet
        başlığını çıkarır, ardından işletim sistemi çekirdeği IP ve UDP başlıklarını
        alır ve ardından da TFTP programı TFTP başlığını alır ve içindeki veriye
        erişir.
      </para><para>
        Artık şu kötü üne sahip Katmanlı Ağ Modeli (Layered Network Model)
        kavramından bahsedebilirim. Bu ağ modeli diğer modellere pek çok
        üstünlüğü bulunan bir ağ işlevselliğinden bahseder. Mesela yazdığınız
        soket programının tek bir harfini bile değiştirmenize gerek kalmadan
        bu programı farklı fiziksel donanımlar üzerinde çalıştırabilirsiniz
        (seri, thin Ethernet, AUI, her ne ise) çünkü düşük seviyedeki programlar
        sizin yerinize ayrıntıları hallederler. Ağ donanımının fiziksel detayları
        ve topolojisi soket programcısını ilgilendirmez.
      </para><para>
        Daha fazla laf kalabalığı yapmadan bu müthiş modelin katmanlarını liste
        olarak vereyim, ağ ile ilgili sınava girerseniz işe yarayabilir:
      </para><para>
        <itemizedlist>
          <listitem>Uygulama</listitem>
          <listitem>Sunum</listitem>
          <listitem>Oturum</listitem>
          <listitem>Taşıma</listitem>
          <listitem>Ağ</listitem>
          <listitem>Veri Bağlantısı</listitem>
          <listitem>Fiziksel</listitem>
        </itemizedlist>
      </para><para>
        Fiziksel katman donanımla ilgilidir (seri, Ethernet, vs.). Uygulama
        katmanı fiziksel katmandan alabildiğine uzaktır -- kullanıcılar ağ ile bu
        katmanda temas kurar.
      </para><para>
        Açıkçası bu model o kadar geneldir ki eğer isterseniz bu modeli arabanıza
        bile uygulayabilirsiniz. Unix ile daha uyumlu bir katmanlı model şöyle
        yazılabilir:
      </para><para>
        <itemizedlist>
          <listitem><para>
            Uygulama Katmanı (<emphasis>telnet, ftp, etc.</emphasis>)
          </para></listitem><listitem><para>
            Konaktan Konağa Taşıma Katmanı (<emphasis>TCP, UDP</emphasis>)
          </para></listitem><listitem><para>
            Internet Katmanı (<emphasis>IP ve yönlendirme</emphasis>)
          </para></listitem><listitem><para>
            Ağa Erişim Katmanı (<emphasis>Ethernet, ATM ya da her ne ise</emphasis>)
          </para></listitem>
        </itemizedlist>
      </para><para>
        Bu aşamada söz konusu katmanların veri paketlenmesinin hangi aşamalarına
        karşılık geldiğini görebiliyor olmalısınız.
      </para><para>
        Tek bir paketi oluşturmak için ne kadar çok iş yapılması gerektiğini
        gördünüz mü! Aman allahım! Üstelik paket başlık bilgilerini de
        <command>cat</command> komutunu kullanarak elle girmeniz gerekiyor!
        Şaka şaka! Tek yapmanız gereken eğer veri akış soketi kullanıyorsanız
        <function>send()</function> ile veriyi göndermek. Eğer veri paketi soketi
        kullanıyorsanız bu sefer de yapılması gereken paketi uygun şekilde
        paketleyip <function>sendto()</function> işlevini kullanarak bunu yollamak.
        Çekirdek sizin için Taşıma katmanını ve Internet katmanını kurar,
        donanımınız da Ağa Erişim Katmanını halleder. Ah, modern teknoloji.
      </para><para>
        Ağ teorisi ile ilgili kısa dersimiz burada sona eriyor. Ah evet tabii ki
        yönlendirmeyle ilgili söylemem gereken şeyler vardı: unutun! Bundan
        bahsetmeyeceğim. Yönlendirici (router) IP başlığını çeker yönlendirme
        tablosuna bakar, seçim yapar, vs. vs. vs. Eğer gerçekten meraklı iseniz
        <ulink url="http://www.rfc-editor.org/rfc/rfc791.txt">IP RFC</ulink> belgesine bakın. Bunu
        öğrenmezsiniz ölmezsiniz.
      </para>
    </sect1>
  </chapter> <!-- /What is a socket? -->
<!-- ======================================================= -->
<!-- structs -->
<!-- ======================================================= -->
  <chapter id="bgnet_structs">
    <title><literal>struct</literal>'lar ve Veri İle Uğraşmak</title>
    <para>
      Hele şükür bu aşamaya gelebildik. Artık biraz programlamadan bahsedebiliriz.
      Bu bölümde soket arayüzleri tarafından kullanılan pek çok veri türünü ele
      alacağım çünkü bunlar gerçekten önemli.
    </para><para>
      Kolay olanlarla başlayalım: bir soket tanımlayıcı. Bir soket tanımlayıcı
      aşağıdaki türdendir:
    </para><para>
      <screen>int</screen>
    </para><para>Evet, gayet klasik, alışık olduğumuz basit bir <literal>int</literal>.
    </para><para>
      İşte bu aşamadan itibaren işler biraz garipleşmeye başlıyor bu yüzden de
      dikkatlice okuyun ve bana güvenin. İlk bilmeniz gereken: iki tür byte
      sıralaması vardır: en önemli baytın (ki buna bazen öktet de denir)
      önce geldiği sıralama veya en önemli baytın sonra geldiği sıralama.
      Bu sıralamalardan birincisine "Ağ Bayt Sıralaması" (Network Byte Order)<footnote>
      <para>Meraklısına not, Ağ Bayt Sıralaması aynı zamanda "Kıymetlisi Başta Bayt
      Sırası" (Big-Endian) ve Konak Bayt Sıralaması da "Kıymetlisi Sonda Bayt
      Sırası"(Little-Endian) olarak bilinir.</para></footnote>
      denir. Bazı makinalar içsel olarak veriyi kendi belleklerinde bu şekilde
      depolar, bazıları ise bu sırayı dikkate almaz. Bir şeyin Ağ Bayt Sıralaması'na
      göre sıralanması gerektiğini söylediğimde <function>htons()</function> gibi
      bir işlev çağırmanız gerekecek ("Konak Bayt Sıralaması"ndan [Host Byte Order]
      "Ağ Bayt Sıralaması"na dönüştürebilmek için). Eğer "Ağ Bayt Sıralaması"ndan
      bahsetmiyorsam o zaman ilgili veriyi olduğu gibi yani
      "Konak Bayt Sıralaması" düzeninde bırakmanız gerekir.
    </para><para>
      <trademark>My First Struct</trademark> -- <literal>struct sockaddr</literal>.
      Bu veri yapısı pek çok türde soket için soket adres bilgisini barındırır:
    </para><para>
<screen>
struct sockaddr {
    unsigned short    sa_family;    // adres ailesi, AF_xxx
    char              sa_data[14];  // protokol adresinin 14 byte'ı
};
</screen>
    </para><para>
      <parameter>sa_family</parameter> pek çok değerden birini alabilir ama
      bizim örneğimizde <constant>AF_INET</constant> olacak.
      <parameter>sa_data</parameter> ise soketle ilgili hedef adres ve port
      numarası bilgilerini barındırır. Bunun garip olduğunu kabul ediyorum, yani
      herhalde bu bilgiyi kendi ellerinizle paketleyerek <parameter>sa_data</parameter>
      değişkenine yerleştirmek istemezsiniz değil mi?
    </para><para>
      <literal>struct sockaddr</literal> ile başa çıkabilmek için programcılar buna
      paralel bir yapı tasarlamışlar: <literal>struct sockaddr_in</literal> ("in"
      "Internet" anlamına geliyor.)
    </para><para>
<screen>
struct sockaddr_in {
    short int          sin_family;  // Adres ailesi
    unsigned short int sin_port;    // Port numarası
    struct in_addr     sin_addr;    // Internet adresi
    unsigned char      sin_zero[8]; // struct sockaddr ile aynı boyda
};
</screen>
    </para><para>
      Bu yapı soket adresi elemanlarına erişmeyi kolaylaştırır. Dikkat etmeniz
      gereken bir nokta: <parameter>sin_zero</parameter>,<footnote><para>Burada
      bulunmasının sebebi içinde bulunduğu veri yapısının boyunu <literal>struct
      sockaddr</literal> yapısının boyuna tamamlamaktır.</para></footnote>
      <function>memset()</function> işlevi kullanılarak tamamen sıfır ile
      doldurulmalıdır. Buna ek ve daha da önemli olarak bir <literal>struct
      sockaddr_in</literal> göstergesi <literal>struct sockaddr</literal> göstergesine
      dönüştürülebilir ve tersi de doğrudur. Yani her ne kadar
      <function>socket()</function> işlevi <literal>struct sockaddr*</literal> şeklinde
      bir veri beklese de siz gene de <literal>struct sockaddr_in</literal> kullanıp
      son anda gerekli dönüştürmeyi yapabilirsiniz! Ayrıca <parameter>sin_family</parameter>
      değişkeninin de <literal>struct sockaddr</literal> yapısındaki
      <parameter>sa_family</parameter> değişkenine karşılık geldiğini ve
      "<constant>AF_INET</constant>" olarak ayarlanması gerektiğini unutmayın.
      Son olarak <parameter>sin_port</parameter> ve <parameter>sin_addr</parameter>
      değikenlerinin de Ağ Byte Sırasında bulunmaları gerektiğini unutmayın!
    </para><para>
      "Fakat," diye itiraz edebilirsiniz, "nasıl olur da tüm yapı yani
      <literal>struct in_addr sin_addr</literal> Ağ Bayt Sıralamasına göre
      dizilebilir ki?" Bu soru tüm zamanların en kötü
      <literal>union</literal>'larından biri olan <literal>struct in_addr</literal>
      yapısının dikkatli olarak incelenmesini gerektirir:
    </para><para>
<screen>
// Internet adresi (tarihi sebeplerden ötürü korunmakta)
struct in_addr {
    unsigned long s_addr; // 32-bit yani 4 bytes
};
</screen>
    </para><para>
      Evet, bir zamanlar kötü bir <literal>union</literal> idi. Neyse ki
      geçmişte kaldı. Eğer <parameter>ina</parameter> değişkenini
      <literal>struct sockaddr_in</literal> türünden tanımladı iseniz
      <parameter>ina.sin_addr.s_addr</parameter> 4 byte'lık Internet
      adresini gösterir (Ağ Bayt Sıralamasında). Aklınızda bulunsun eğer
      sizin sisteminiz kahrolası <literal>struct in_addr</literal>
      <literal>union</literal>'ını kullanıyor olsa bile yine de 4 byte'lık
      Internet adresine tamamen benim yaptığım gibi ulaşabilirsiniz
      (bunu <literal>#define</literal>'lara borçluyuz).
    </para>
<!-- ======================================================= -->
<!-- Convert The Natives -->
<!-- ======================================================= -->
    <sect1 id="bgnet_structs-convert">
      <title>Veri Türlerini Dönüştür!</title>
      <para>
        Deminden beri şu Ağ ve Konak Bayt Sıralamaları ile yeterince kafa
        şişirdim şimdi biraz eylem zamanı!
      </para><para>
        Pekala. Dönüştürebileceğiniz iki tür vardır: <literal>short</literal>
        (iki byte) ve <literal>long</literal> (dört byte). Bu işlevler
        <literal>unsigned</literal> ve varyasyonları üzerinde çalışır.
        Örneğin bir <literal>short</literal> değişkenin bayt düzenini
        Konak Bayt Sıralamasından Ağ Bayt Sıralamasına çevirmek istiyorsunuz.
        "h" ile başlayalım ("host"), sonra "to" ve ardından "n" ("network")
        son olarak da bir "s" ("short"): h-to-n-s veya htons()
        ("Host to Network Short" olarak okursanız hatırlamanız kolay olur).
      </para><para>O kadar da zor sayılmaz değil mi...
      </para><para>
        Aptallarca olanlarını bir kenara bırakırsak "n", "h", "s" ve "l" ile
        her türlü birleşimi oluşturabilirsiniz. Örneğin tabii ki
        <function>stolh()</function> ("Short to Long Host") gibi bir işlev
        yoktur. Fakat şu işlevler vardır:
      </para><para>
        <itemizedlist>
          <listitem><para>
            <function>htons()</function> -- "Host to Network Short" -- konaktan ağa short
          </para></listitem><listitem><para>
            <function>htonl()</function> -- "Host to Network Long"  -- konaktan ağa long
          </para></listitem><listitem><para>
            <function>ntohs()</function> -- "Network to Host Short" -- ağdan konağa short
          </para></listitem><listitem><para>
            <function>ntohl()</function> -- "Network to Host Long"  -- ağdan konağa long
          </para></listitem>
        </itemizedlist>
      </para><para>
        Bu konuyu kavradığınızı düşünüyor olabilirsiniz. Mesela aklınıza şu
        gelebilir: "<literal>char</literal> türünde bir verinin Bayt Sıralamasını
        değiştirmem gerekirse ne yapmam gerekir?" Ve sonra şöyle cevap
        verebilirsiniz: "Aman, boşver." Ayrıca aklınıza şu da gelebilir:
        mesela 68000 işlemcili makinanız zaten Ağ Bayt Sıralamasını kullandığına
        göre <function>htonl()</function> işlevini IP adreslerine uygulamanıza
        gerek yoktur. Haklı olabilirsiniz. FAKAT eğer geliştirdiğiniz yazılımı
        öteki türlü Bayt Sıralamasına göre çalışan bir bilgisayara taşırsanız
        programınız kesinlikle çalışmaz. Taşınabilir programlar yazın!
        Unutmayın Unix dünyasındasınız! (Her ne kadar Bill Gates aksini
        düşünmek istese de.) Sakın unutmayın: baytlarınızı ağ üzerinde
        yolculuğa çıkarmadan önce onları Ağ Bayt Sıralaması'na göre dizeceksiniz.
      </para><para>
        Son bir noktaya daha dikkat çekmek istiyorum: neden
        <literal>struct sockaddr_in</literal> yapısı içindeki
        <parameter>sin_port</parameter> ve <parameter>sin_addr</parameter>
        Ağ Bayt Sıralamasında olmak zorunda iken <parameter>sin_family</parameter>
        böyle bir özelliğe sahip olmak durumunda değil? Cevabı:
        <parameter>sin_addr</parameter> ve <parameter>sin_port</parameter>
        sırası ile IP ve UDP katmanlarında paketlenirler. Bu yüzden Ağ Bayt
        Sıralamasında gönderilmeleri gerekir oysa ki
        <parameter>sin_family</parameter>  sadece işletim sistemi çekirdeği
        tarafından veri yapısının barındırdığı adresin türünü tespit etmek
        için kullanılır. Bu yüzden de bu alanın Konak Bayt Sıralamasında
        bırakılması gerekir. Ayrıca <parameter>sin_family</parameter> ağ
        üzerinden bir yere yollanmadığı için Konak Bayt Sıralamasında
        olabilir.
      </para>
    </sect1>
<!-- ======================================================= -->
<!-- IP Addresses -->
<!-- ======================================================= -->
    <sect1 id="bgnet_structs-ipaddr">
      <title>IP Adresleri ve Bunlarla Uğraşma Yöntemleri</title>
      <para>
        Şanslısınız çünkü IP adresleri ile uğraşmanızı sağlayacak bir grup
        işlev vardır. Yani elle hesap kitap yapıp sonra da bunu bir
        <literal>long</literal> içine <literal><![CDATA[<<]]></literal>
        işleci ile tıkıştırmanıza gerek yok.
      </para><para>
        Önce örneğin elinizde bir <literal>struct sockaddr_in ina</literal>
        değişkeni ve bir de <literal>10.12.110.57</literal> şeklinde bir
        IP adresi olduğunu var sayalım. Bu adresi bu değişken içine
        yerleştirmek istiyorsunuz. Kullanmanız gereken işlev:
        <function>inet_addr()</function>. Bu işlev bir IP adresini
        yukarıdaki gibi sayılardan ve noktalardan oluşan bir biçemden alıp
        <literal>unsigned long</literal> türünde bir sayıya çevirir. Bu tür
        bir atama şu şekilde yapılabilir:
      </para><para>
<programlisting><![CDATA[
ina.sin_addr.s_addr = inet_addr("10.12.110.57"); ]]>
</programlisting>
      </para><para>
        Şuna dikkat edin: <function>inet_addr()</function> zaten döndürdüğü
        değeri Ağ Bayt Sıralamasına göre dizilmiş olarak döndürür yani
        <function>htonl()</function> işlevini burada çağırmanıza gerek yok.
        Harika!
      </para><para>
        Yukarıdaki kod parçası pek sağlam sayılmaz çünkü hiç hata denetimi yok.
        Gördüğünüz gibi <function>inet_addr()</function> hatalı bir durumla
        karşılaşınca <constant>-1</constant> değerini döndürür. İkili sayı
        sistemini hatırladınız mı? <constant>(unsigned)-1</constant> tam da
        şu IP adresine karşılık gelir: <literal>255.255.255.255</literal>!
        Bu da yayın adresidir! Aman dikkat. Hata kontrolünü düzgün bir şekilde
        yapmayı sakın ihmal etmeyin.
      </para><para>
        Aslında <function>inet_addr()</function> yerine kullanabileceğiniz
        daha güzel bir işlev var: <function>inet_aton()</function> ("aton"u,
        "ascii to network" olarak okuyun):
      </para><para>
<programlisting><![CDATA[
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

int inet_aton(const char *cp, struct in_addr *inp); ]]>
</programlisting>
      </para><para>
        Bir örnek vermek gerekirse: bu işlev <literal>struct sockaddr_in</literal>
        yapısını paketlerken (ilerledikçe bu örnek size daha da anlamlı
        gelecek <link linkend="bgnet_syscalls-bind"><function>bind()</function></link>
        ve <link linkend="bgnet_syscalls-connect"><function>connect()</function></link>
        kısımlarına kadar sabredin.)
      </para><para>
<programlisting><![CDATA[
struct sockaddr_in my_addr;

my_addr.sin_family = AF_INET;         // konak bayt sıralaması
my_addr.sin_port = htons(MYPORT);     // short, ağ bayt sıralaması
inet_aton("10.12.110.57", &(my_addr.sin_addr));
memset(&(my_addr.sin_zero), '\0', 8); // geriye kalanı sıfırla ]]>
</programlisting>
      </para><para>
        <function>inet_aton()</function>, diğer tüm soket-bağlantılı
        işlevlerden farklı olarak, sorun çıkmazsa sıfırdan farklı bir değer,
        sorun çıkarsa da sıfır değerini döndürür. Ve döndürülen adres
        <parameter>inp</parameter> içinde yer alır.
      </para><para>
        Maalesef her platform <function>inet_aton()</function> işlevini
        kullanmamaktadır. Bu yüzden her ne kadar bu işlevi tercih etsek de
        daha yaygın olması itibariyle örneklerde
        <function>inet_addr()</function> kullanılacaktır.
      </para><para>
        Artık IP adreslerini ikilik sisteme kolayca dönüştürebileceğinize
        göre bunun tersini yapmaya ne dersiniz? Yani mesela elinizde zaten
        bir <literal>struct in_addr</literal> yapısı varsa ve siz bunu alışık
        olduğunuz sayılı noktalı IP adresi biçeminde basmak istiyorsanız?
        Bu durumda kullanacağımız işlev: <function>inet_ntoa()</function>
        ("ntoa"yı "network to ascii" olarak okuyun). Şu şekilde işinizi görür:
      </para><para>
<programlisting><![CDATA[
printf("%s", inet_ntoa(ina.sin_addr)); ]]>
</programlisting>
      </para><para>
        Bu IP adresini basacaktır. Dikkat edin: <function>inet_ntoa()</function>
        argüman olarak <literal>struct in_addr</literal> alır <literal>long</literal>
        almaz. Bir diğer önemli nokta da: Bu işlev bir <literal>char</literal>'a
        işaret eden bir gösterge döndürür. Söz konusu gösterge
        <function>inet_ntoa()</function> içinde statik olarak depolanan bir
        karakter dizisine işaret eder ve <function>inet_ntoa()</function>
        işlevini her çağırışınızda son işlem görmüş olan IP adresinin üzerine
        yazılır. Örneğin:
      </para><para>
<programlisting><![CDATA[
char *a1, *a2;
.
.
a1 = inet_ntoa(ina1.sin_addr);  // burada 192.168.4.14 var
a2 = inet_ntoa(ina2.sin_addr);  // burada 10.12.110.57 var
printf("1. adres: %s\n",a1);
printf("2. adres: %s\n",a2); ]]>
</programlisting>
      </para><para>şunu basar:</para><para>
<programlisting><![CDATA[
1. adres: 10.12.110.57
2. adres: 10.12.110.57 ]]>
</programlisting>
      </para><para>
        Eğer birden fazla adresle iş yapıyorsanız ve bunları yukarıda olduğu
        gibi kaybetmek istemiyorsanız o zaman <function>strcpy()</function>
        gibi bir işlev kullanarak uygun bir yere kopyalamayı sakın ihmal
        etmeyin.
      </para><para>
        Bu konu ile söyleyeceklerim şimdilik bu kadar. Daha sonra
        "whitehouse.gov" gibi bir karakter dizisini hangi yöntemlerle
        karşılık gelen IP adresine çevirebileceğinizi göstereceğim
        (bkz. <xref linkend="bgnet_syscalls-dns"/>).
      </para>
    </sect1>
  </chapter> <!-- /structs -->
<!-- ======================================================= -->
<!-- System Calls -->
<!-- ======================================================= -->
  <chapter id="bgnet_syscalls">
    <title>Sistem Çağrıları veya Felaketleri</title>
    <para>
      Bir UNIX bilgisayardaki ağ işlevselliğine erişmenizi anlatacağım
      bölüme hoşgeldiniz. Bu işlevlerden birini çağırdınızda işletim
      sistemi çekirdeği devreye girer ve düşük seviyedeki işlemleri
      büyüleyici bir şekilde sizin için halleder.
    </para><para>
      İnsanların bu aşamada en çok takıldıkları nokta bu işlevleri hangi
      sıra ile çağıracakları sorusudur. Bu bakımdan <command>man</command>
      sayfaları bir işe yaramaz, eğer biraz uğraştıysanız ne demek
      istediğimi biliyorsunuzdur. Bu zorlu konu ile başa çıkabilmek için
      işlevleri normalde geliştirdiğiniz bir programdaki çağrılış
      sıralarına tam olarak (hemen hemen) uygun şekilde size sunmaya
      çalışacağım.
    </para><para>
      Bu açıklamalara ek olarak orada burada birkaç örnek kod parçası,
      biraz süt artı kurabiye (üzgünüm bu son ikisini siz tedarik
      etmelisiniz) ve tabii biraz da cesaret ile elinizdeki verileri
      Internet üzerinden her yere ışınlıyor olacaksınız.
    </para>
<!-- ======================================================= -->
<!-- socket -->
<!-- ======================================================= -->
    <sect1 id="bgnet_syscalls-socket">
      <title><function>socket()</function> -- Al Şu Dosya Tanımlayıcıyı!</title>
      <para>
        Sanırım artık daha fazla erteleyemem -- <function>socket()</function>
        sistem çağrısından bahsetmek zorundayım. İşte o işlev:
      </para><para>
<programlisting><![CDATA[
#include <sys/types.h>
#include <sys/socket.h>

int socket(int domain, int type, int protocol); ]]>
</programlisting>
      </para><para>
        Peki ya argümanlar? Önce, <parameter>domain</parameter> argümanına
        <constant>AF_INET</constant> değeri verilmeli, tıpkı
        <literal>struct sockaddr_in</literal> yapısında olduğu gibi. Sonra
        <parameter>type</parameter> argümanı çekirdeğe ne tür bir soket
        söz konusu olduğunu söyler: <constant>SOCK_STREAM</constant> veya
        <constant>SOCK_DGRAM</constant>. Son olarak da
        <parameter>protocol</parameter> argümanına "<constant>0</constant>"
        değerini verelim ki <function>socket()</function>,
        <parameter>type</parameter> değişkenine karşılık gelen uygun protokolü
        seçebilsin. (Dikkat: Bahsettiğimden daha çok
        <parameter>domain</parameter> ve <parameter>type</parameter> vardır.
        Bkz. <function>socket()</function> man sayfası. Ayrıca
        <parameter>protocol</parameter> değerini öğrenmenin "daha iyi" bir
        yöntemi vardır. Bkz. <function>getprotobyname()</function> man
        sayfası.)
      </para><para>
        <function>socket()</function> işlevi size bir soket tanımlayıcı
        döndürür ve artık siz bunu daha sonraki işlevlerinize parametre olarak
        geçebilirsiniz. Eğer bir hata oluşursa işlev <constant>-1</constant>
        değerini döndürür. Bu durumda <parameter>errno</parameter> isimli
        global değişken hata kodunu tutar (bkz. <function>perror()</function>
        man sayfası.)
      </para><para>
        Bazı belgelerde mistik bir <constant>PF_INET</constant> ifadesi
        görebilirsiniz, korkmayın. Normalde bu canavar günlük hayatta pek
        karşınıza çıkmaz fakat gene de kendisinden biraz bahsedeyim. Uzun
        zaman önce adres ailesinin (<constant>AF_INET</constant>'deki "AF"
        "Address Family" manasındadır) pek çok protokolü destekleyebileceği
        düşünülmüştü ( <constant>PF_INET</constant>'deki "PF" "Protocol Family"
        manasındadır). Ancak böyle bir şey olmadı. Yani doğru olan,
        <constant>AF_INET</constant> değerini <literal>struct sockaddr_in</literal>
        yapısında kullanmanız ve <constant>PF_INET</constant>'i ise
        <function>socket()</function> çağırırken kullanmanızdır. Ancak pratik
        olarak <constant>AF_INET</constant>'i her yerde kullanabilirsiniz.
        Bu işin üstadlarından W. Richard Stevens kitabında böyle yaptığı için
        ben de burada böyle yapacağım.
      </para><para>
        Peki tamam çok güzel de bu soket ne işe yarar? Tek başına bir işe yaramaz
        tabii, lütfen okumaya devam edin ve diğer sistem çağrılarını öğrenin ki
        taşlar yerine otursun.
      </para>
    </sect1>
<!-- ======================================================= -->
<!-- bind -->
<!-- ======================================================= -->
    <sect1 id="bgnet_syscalls-bind">
      <title><function>bind()</function> -- Hangi Port Üzerindeyim?</title>
      <para>
        Bir soket edindikten sonra bunu makinanızdaki bir "port" ile
        ilişkilendirmek isteyeceksiniz<footnote><para>Yani eğer
        <function>listen()</function> kullanacaksanız genellikle böyle
        bir şey yapmanız beklenir zaten. Mesela bir oyun sunucusuna
        "telnet x.y.z port 6969" şeklinde bağlanmanız söylendiğinde karşı
        tarafta tam da böyle bir hazırlık yapılmıştır.</para></footnote>.
        Bu port numarası dediğimiz şey işletim sistemi çekirdeği tarafından
        gelen bir paketi belli bir sürecin soket tanımlayıcısı ile
        ilişkilendirebilmesi için gereklidir. Eğer tek yapacağınız bir yere
        <function>connect()</function> ile bağlanmaksa o zaman buna gerek
        yoktur tabii. Gene de okumaya devam edin, zevk alacaksınız.
      </para><para>
        <function>bind()</function> sistem çağrısının özetine man komutu
        ile bakacak olursanız şöyle bir şeyle karşılaşırsınız:
      </para><para>
<programlisting><![CDATA[
#include <sys/types.h>
#include <sys/socket.h>

int bind(int sockfd, struct sockaddr *my_addr, int addrlen); ]]>
</programlisting>
      </para><para>
        <parameter>sockfd</parameter> denilen şey <function>socket()</function>
        tarafından döndürülen soket dosya tanımlayıcısıdır.
        <parameter>my_addr</parameter> değişkeni <literal>struct sockaddr</literal>
        türünde bir veriye işaret eder ve bu yapı da adresinizi yani port
        numaranızı ve IP adresinizi barındırır. <parameter>addrlen</parameter>'in
        değeri <literal>sizeof(struct sockaddr)</literal> olarak verilebilir.
      </para><para>
        Vay canına. Bir seferde sindirmek için biraz fazla değil mi? Bir örnek
        yapalım:
      </para><para>
<programlisting><![CDATA[
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>

#define MYPORT 3490

main()
{
    int sockfd;
    struct sockaddr_in my_addr;

    sockfd = socket(AF_INET, SOCK_STREAM, 0); // hata kontrolünü ihmal etmeyin!

    my_addr.sin_family = AF_INET;         // konak bayt sıralaması
    my_addr.sin_port = htons(MYPORT);     // short, ağ bayt sıralaması
    my_addr.sin_addr.s_addr = inet_addr("10.12.110.57");
    memset(&(my_addr.sin_zero), '\0', 8); // yapının geriye kalanını sıfırlayalım

    // bind() için hata kontrolü yapmayı unutmayın:
    bind(sockfd, (struct sockaddr *)&my_addr, sizeof(struct sockaddr));
    .
    .
    . ]]>
</programlisting>
      </para><para>
        Burada dikkat etmeniz gereken bazı şeyler var:
        <parameter>my_addr.sin_port</parameter> Ağ Byte Sıralamasında, ve
        tabii <parameter>my_addr.sin_addr.s_addr</parameter> de öyle.
        Bir başka nokta ise en tepede çağrılmış olan başlık dosyaları
        sistemden sisteme değişiklik gösterebilir. Kesin bilgi sahibi
        olabilmek için sisteminizdeki <command>man</command> sayfalarına
        bakmalısınız.
      </para><para>
        <function>bind()</function> konusu ile ilgili son söyleyeceğim şey
        IP ve port edinme işlemini biraz otomaktikleştirilebilir:
      </para><para>
<programlisting><![CDATA[
my_addr.sin_port = 0; // kullanılmayan herhangi bir port'u seç
my_addr.sin_addr.s_addr = INADDR_ANY;  // IP adresimi kullan ]]>
</programlisting>
      </para><para>
        Gördüğünüz gibi <parameter>my_addr.sin_port</parameter> değişkeninin
        değerini sıfır yaparak <function>bind()</function> işlevine diyoruz ki
        "uygun olan bir port sayısını bizim için sen seç". Benzer şekilde
        <parameter>my_addr.sin_addr.s_addr</parameter> değişkeninin değerini
        <constant>INADDR_ANY</constant> yaparak üzerinde çalıştığı makinanın
        IP adresini almasını söylemiş oluyoruz.
      </para><para>
        Eğer dikkatli bir okuyucu iseniz bazı şeyleri fark etmiş
        olabilirsiniz, mesela <constant>INADDR_ANY</constant> değerini Ağ
        Bayt Sıralamasına dönüştürmedim! Ne kadar da yaramaz bir programcıyım!
        Ama bildiğim bir şey var: <constant>INADDR_ANY</constant> zaten SIFIR
        değerine karşılık geliyor! Yani hangi sırada dizerseniz dizin zaten
        sıfır. Ancak takıntılı olan programcılar <constant>INADDR_ANY</constant>
        sabitinin mesela 12 olarak belirlendiği bir paralel evrenden söz
        açabilirler ve orada benim kodum çalışmaz. Tamam, sorun değil,
        hallederiz:
      </para><para>
<programlisting><![CDATA[
my_addr.sin_port = htons(0); // kullanılmayan herhangi bir port'u seç
my_addr.sin_addr.s_addr = htonl(INADDR_ANY);  // IP adresimi kullan ]]>
</programlisting>
      </para><para>
        Sistemimiz artık o kadar taşınabilir oldu ki yani bu kadar olur.
        Bunu burada belirttim çünkü karşılaşacağınız kod örneklerinin çoğu
        <constant>INADDR_ANY</constant> sabitini <function>htonl()</function>
        işlevinden geçirmez, kafanız karışmasın.
      </para><para>
        <function>bind()</function> eğer bir hata çıkarsa <constant>-1</constant>
        değerini döndürür ve <parameter>errno</parameter> isimli hata kodu
        değişkenine gerekli sayıyı yerleştir.
      </para><para>
        <function>bind()</function> işlevini çağırırken dikkat etmeniz
        gereken bir başka şey de şudur: port numarası olarak küçük bir
        değer seçmeyin. 1024'ün altındaki tüm portlar REZERVE edilmiştir
        (eğer superuser değilseniz!). Bu sayıdan başlayarak 65535'e kadar
        olan sayılardan birini port numarası olarak kullanabilirsiniz
        (tabii eğer seçtiğiniz numara başka bir program tarafından
        kullanılmıyorsa).
      </para><para>
        Bazen bir sunucuyu tekrar çalıştırmaya kalktığınızda <function>bind()</function>
        işlevinin başarısız olduğunu ve "Adres kullanımda" ("Address already
        in use.") mesajı verdiğiniz görürsünüz. Bu ne anlama gelir? Daha
        önce kullanılmış bir soket hala çekirdek seviyesinde takılı kalmıştır
        ve bu yüzden portun kullanılmasını engellemektedir. Ya kendiliğinden
        iptal olmasını beklersiniz ki bu 1 dakika kadar sürebilir ya da
        programınıza bu portu her halükârda kullanmasını sağlayacak kodu
        eklersiniz:
      </para><para>
<programlisting><![CDATA[
int yes=1;
//char yes='1'; // Solaris programcıları bunu kullanır

// "Address already in use" hata mesajından kurtul
if (setsockopt(listener,SOL_SOCKET,SO_REUSEADDR,&yes,sizeof(int)) == -1) {
    perror("setsockopt");
    exit(1);
} ]]>
</programlisting>
      </para><para>
        <note><title><function>bind()</function> ile ilgili ek bilgi</title>
        <para>Kimi durumlarda bu işlev ile hiç işiniz olmaz. Mesela eğer
        <function>connect()</function> ile uzaktaki bir makinaya bağlanıyor
        ve yerel portunuzun ne olduğu ile ilgilenmiyorsanız
        (<command>telnet</command> uygulamasında olduğu gibi önemli olan
        sadece uzaktaki makinadaki port ise) kısaca
        <function>connect()</function> işlevini çağırırsınız ve zaten bu
        işlev de soketin bağlı olup olmadığını kontrol eder ve eğer soket
        bağlı değil ise <function>bind()</function> işlevini kullanarak
        bunu makinanızdaki kullanılmayan bir port numarasına bağlar.</para>
        </note>
      </para>
    </sect1>
<!-- ======================================================= -->
<!-- connect -->
<!-- ======================================================= -->
    <sect1 id="bgnet_syscalls-connect">
      <title><function>connect()</function>--Hey, sen!</title>
      <para>
        Diyelim ki bir telnet programısınız. Sizi kullanan kişi (tıpkı
        <emphasis>TRON</emphasis> filminde olduğu gibi) size bir soket
        dosya tanımlayıcısı edinmeniz için komut veriyor. Siz de bu
        komuta uyup <function>socket()</function> işlevini çağırıyorsunuz.
        Sonra, kullanıcı sizden "<literal>10.12.110.57</literal>" adresine
        ve "<literal>23</literal>" numaralı porta bağlanmanızı istiyor
        (standart telnet portu). Aha! Şimdi ne yapacaksınız?
      </para><para>
        Bir program olarak şanslısınız çünkü tam da <function>connect()</function>
        bölümündeyiz -- uzaktaki bir bilgisayara nasıl bağlanırız bölümü.
        Okumaya devam kaybedecek zaman yok, kullanıcı bekliyor!
      </para><para>
        <function>connect()</function> işlevi şöyle birşeydir:
      </para><para>
<programlisting><![CDATA[
#include <sys/types.h>
#include <sys/socket.h>

int connect(int sockfd, struct sockaddr *serv_addr, int addrlen); ]]>
</programlisting>
      </para><para>
        <parameter>sockfd</parameter> dediğimiz değişken
        <function>socket()</function> sistem çağrısı tarafından döndürülmüş
        olan soket dosya tanımlayıcısının değerini tutar.
        <parameter>serv_addr</parameter> ise <literal>struct sockaddr</literal>
        türünde bir değişkendir ve hedef port ile IP adres bilgilerini
        barındırır. <parameter>addrlen</parameter> değişkeni de
        <literal>sizeof(struct sockaddr)</literal> değerini alırsa iyi olur.
      </para><para>
        Taşlar yerine oturmaya başladı mı? Hemen bir örneğe göz atalım:
      </para><para>
<programlisting><![CDATA[
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>

#define DEST_IP   "10.12.110.57"
#define DEST_PORT 23

main()
{
    int sockfd;
    struct sockaddr_in dest_addr;             // hedef adres

    sockfd = socket(AF_INET, SOCK_STREAM, 0); // hata denetimi yapın!

    dest_addr.sin_family = AF_INET;          // konak bayt sıralaması
    dest_addr.sin_port = htons(DEST_PORT);   // short, ağ bayt sıralaması
    dest_addr.sin_addr.s_addr = inet_addr(DEST_IP);
    memset(&(dest_addr.sin_zero), '\0', 8);  // yapının geriye kalanını sıfırla

    // connect() işlevini çağırdıktan sonra hata denetimi yap!
    connect(sockfd, (struct sockaddr *)&dest_addr, sizeof(struct sockaddr));
    .
    .
    . ]]>
</programlisting>
      </para><para>
        Sıkılsanız da söylemek zorundayım: <function>connect()</function>
        işlevinden sonra mutlaka hata denetimi yapın, eğer hata oluştu
        ise bu işlev <constant>-1</constant> değerini döndürür ve
        <parameter>errno</parameter> değişkenine ilgili hata numarasını
        yerleştirir.
      </para><para>
        Ayrıca <function>bind()</function> işlevini çağırmadığımıza da
        dikkat edin. Yani kısaca yerel port numarası ile ilgilenmiyoruz;
        bizi ilgilendiren hedef bilgisayar (uzaktaki port). İşletim sistemi
        çekirdeği bizim için bir yerel port bulacaktır ve bağlandığımız
        bilgisayar da bu bilgiyi otomatik olarak bizden öğrenecektir. Siz
        tatlı canınızı üzmeyin.
      </para>
    </sect1>
<!-- ======================================================= -->
<!-- listen -->
<!-- ======================================================= -->
    <sect1 id="bgnet_syscalls-listen">
      <title><function>listen()</function> -- Biri Beni Arayabilir mi Acaba?</title>
      <para>
        Pekala hızımızı biraz değiştirelim. Ya bir yere bağlanmak
        istemiyorsanız ne olacak? Mesela sırf zevk olsun diye size gelen
        bağlantıları dinlemek ve bunlarla ilgili gerekeni yapmak istediğinizi
        var sayalım. Bu tür bir süreç iki aşamalıdır, önce
        <function>listen()</function> ile dinler sonra da <function>accept()</function>
        ile gelen çağrıları kabul edersiniz.
      </para><para>
        Dinleme işlevi oldukça basittir ancak gene de biraz açıklama yapmak
        gerekiyor:
      </para><para>
<programlisting><![CDATA[
int listen(int sockfd, int backlog); ]]>
</programlisting>
      </para><para>
        <parameter>sockfd</parameter> bin kere söylediğim gibi
        <function>socket()</function> sistem çağrısı tarafından döndürülmüş
        olan soket dosya tanımlayıcısı oluyor. <parameter>backlog</parameter>
        ise gelen çağrı kuyruğunda izin verilen bağlantı sayısını gösteriyor.
        Bu ne mi demek? Şey, yani gelen bağlantı talepleri siz onları
        <function>accept()</function> ile kabul edene dek bir kuyrukta bekler
        demek ve işte bu kuyruğun ne kadar uzun olacağını başka bir deyişle
        sınırını siz belirlersiniz. Pek çok sistem bu sınırı 20 olarak
        belirler; siz ise mesela 5 veya 10 gibi bir değer kullanabilirsiniz.
      </para><para>
        Hemen her zamanki gibi, <function>listen()</function> işlevi hata
        durumunda <constant>-1</constant> değerini döndürür ve tabii ki
        <parameter>errno</parameter> değişkenine de ilgili hata numarasını
        yazar.
      </para><para>
        Evet, tahmin edebileceğiniz gibi <function>listen()</function>
        işlevinden önce <function>bind()</function> işlevini çağırmalıyız
        yoksa işletim sistemi çekirdeği bu dinleme işlemini gelişigüzel
        bir port üzerinden yapmaya başlar. Eğer gelen bağlantıları
        dinleyecekseniz çağırmanız gereken işlevler sırası ile şöyledir:
      </para><para>
<programlisting><![CDATA[
socket();
bind();
listen();
/* accept() buraya gelecek */ ]]>
</programlisting>
      </para><para>
        Burada çok açıklama ve kod yok çünkü zaten kendi kendini açıklıyor.
        (<function>accept()</function> bölümünde ele alacağımız kod tabii
        ki daha ayrıntılı olacak.) Bütün bu prosedürdeki en dikktali olunması
        gerken nokta <function>accept()</function> işlevinin çağrıldığı yer.
      </para>
    </sect1>
<!-- ======================================================= -->
<!-- accept -->
<!-- ======================================================= -->
    <sect1 id="bgnet_syscalls-accept">
      <title><function>accept()</function> -- "3490 Numaralı Portu
      Aradığınız İçin Teşekkürler"</title>
      <para>
        Sıkı durun -- <function>accept()</function> işlevi biraz gariptir!
        Neler oluyor? Şu oluyor: çok çok uzaklardan birileri
        <function>connect()</function> işevi ile sizin makinanızda sizin
        <function>listen()</function> ile dinlemekte olduğunuz bir porta
        bağlanmaya çalışıyor. Bu bağlantı talebi <function>accept()</function>
        ile kabul edilene dek kuyrukta bekleyecektir. Siz
        <function>accept()</function> işlevini çağırırsınız ve ona beklemekte
        olan çağrıyı kabul etmesini söylersiniz. O da size yepyeni bir soket
        dosya tanımlayıcısı döndürür sadece ve sadece söz konusu bağlantıya
        özel. Evet doğru duydunuz birdenbire elinizin altında iki soket dosya
        tanımlayıcısı oldu! Orjinal olanı halen port üzerinden dinleme işlemini
        gerçekleştirmek için kullanılıyor yeni olarak yaratılmış olan ise
        <function>send()</function> ve <function>recv()</function> işlevlerinde
        kullanılmak üzere emrinize amade. Hele şükür!
      </para><para>İşlevi şu şekilde çağırırsınız:</para><para>
<programlisting>
#include &lt;sys/socket.h>

int accept(int sockfd, void *addr, int *addrlen);
</programlisting>
      </para><para>
        <parameter>sockfd</parameter> dediğimiz <function>listen()</function>
        ile dinlediğiniz soket tanımlayıcıdır. Basit. <parameter>addr</parameter>
        yerel olarak kullandığınız <literal>struct sockaddr_in</literal>
        yapısını gösteren bir göstergedir. Gelen bağlantılarla ilgili
        bilgiler burada barındırılacak (yani bu yapıyı kullanarak gelen
        bağlantının hangi bilgisayar ve hangi porttan geldiğini
        öğrenebilirsiniz). <parameter>addrlen</parameter> yerel bir tamsayı
        değişkendir ve kullanılmadan önce <function>accept()</function>
        <literal>sizeof(struct sockaddr_in)</literal> değerini almalıdır.
        <function>accept()</function> işlevi bu değerden daha fazla
        sayıda baytı <parameter>addr</parameter> içine yerleştirmeyecektir.
        Eğer söz konusu değerden daha azını yerleştirirse o zaman da
        <parameter>addrlen</parameter> değerini, bunu yansıtacak şekilde
        değiştirecektir.
      </para><para>
        Tahmin edin ne diyeceğim? <function>accept()</function> hata durumunda
        <constant>-1</constant> değerini döndürür ve <parameter>errno</parameter>
        değişkenine ilgili hata kodunu yerleştirir. Tahmin etmiş miydiniz?
        Gerçekten?
      </para><para>
        Biliyorum, bir seferde sindirmesi kolay değil. İsterseniz aşağıdaki
        örnek koda bakalım:
      </para><para>
<programlisting><![CDATA[
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>

#define MYPORT 3490    // kullanıcıların bağlanacağı port

#define BACKLOG 10     // kuyrukta bekleyecek bağlantı sayısı

main()
{
    int sockfd, new_fd;  // sock_fd ile dinle, new_fd yeni bağlantı için
    struct sockaddr_in my_addr;    // benim adres bilgim
    struct sockaddr_in their_addr; // bağlananın adres bilgisi
    int sin_size;

    sockfd = socket(AF_INET, SOCK_STREAM, 0); // hata denetimi yap!

    my_addr.sin_family = AF_INET;         // konak bayt sıralaması
    my_addr.sin_port = htons(MYPORT);     // short, ağ bayt sıralaması
    my_addr.sin_addr.s_addr = INADDR_ANY; // otomatik olarak benim IP'im
    memset(&(my_addr.sin_zero), '\0', 8); // geriye kalanı sıfırla

    // hata denetimi yapmayı sakın unutmayın:
    bind(sockfd, (struct sockaddr *)&my_addr, sizeof(struct sockaddr));

    listen(sockfd, BACKLOG);

    sin_size = sizeof(struct sockaddr_in);
    new_fd = accept(sockfd, (struct sockaddr *)&their_addr, &sin_size);
    .
    .
    . ]]>
</programlisting>
      </para><para>
        Lütfen dikkat edin: <parameter>new_fd</parameter> şeklindeki soket
        tanımlayıcıyı tüm <function>send()</function> ve <function>recv()</function>
        işlevleri için kullanacağız. Eğer sadece ve sadece tek bir bağlantıyı
        kabul edecekseniz <function>close()</function>  ile
        <parameter>sockfd</parameter> üzerindeki dinleyici soketi
        kapatabilirsiniz böylece aynı port üzerinden başka bağlantı yaplamaz,
        eğer istediğiniz gerçekten bu ise.
      </para>
    </sect1>
<!-- ======================================================= -->
<!-- sendrecv -->
<!-- ======================================================= -->
    <sect1 id="bgnet_syscalls-sendrecv">
    <title>
      <function>send()</function> ve <function>recv()</function> --
      Konuş Benimle Bebeğim!
    </title>
    <para>
      Bu iki işlev veri akış soketler veya bağlantılı veri paketi soketleri
      üzerinden veri göndermenizi ve veri almanızı sağlar. Eğer istediğiniz
      düzenli ve bağlantısız veri paketi soketleri kullanmak ise o zaman
      <link linkend="bgnet_syscalls-sendtorecv"><function>sendto()</function> ve
      <function>recvfrom()</function></link> işlevleri ile ilgili
      aşağıdaki bölümü okumalısınız.
    </para><para>
      <function>send()</function> işlevi şu şekilde çağrılır:
    </para><para>
<programlisting><![CDATA[
int send(int sockfd, const void *msg, int len, int flags); ]]>
</programlisting>
    </para><para>
      <parameter>sockfd</parameter> üzerinden veri göndereceğiniz sokettir
      (size <function>socket()</function> veya <function>accept()</function>
      tarafından sağlanmış olabilir). <parameter>msg</parameter> göndermek
      istediğiniz mesajı gösteren bir göstergedir ve <parameter>len</parameter>
      değişkeni bu verinin byte cinsinden uzunluğudur. <parameter>flags</parameter>
      parametresini <constant>0</constant> olarak bırakabilirsiniz.
      (Bu parametre ile ilgili ayrıntılı bilgi için bkz.
      <function>send()</function> man sayfası.)
    </para><para>Örnek bir kod parçası vermek gerekirse:</para><para>
<programlisting><![CDATA[
char *msg = "Beej buradaydi!";
int len, bytes_sent;
.
.
len = strlen(msg);
bytes_sent = send(sockfd, msg, len, 0);
.
.
. ]]>
</programlisting>
    </para><para>
      <function>send()</function> değer olarak gönderilen bayt miktarını
      döndürür -- bu sizin gönderilmesini istediğiniz miktardan az olabilir!
      Gördüğünüz gibi siz ona bir yığın veri göndermesini söylersiniz ancak
      o bazen bunun tamamı ile başa çıkamayabilir. Elinden geldiği kadarını
      gönderir ve geriye kalan veriyi yeniden göndermek sizin
      sorumluluğunuzdadır. Unutmayın, eğer <function>send()</function>
      işlevinin döndürdüğü değer <parameter>len</parameter> değişkenindeki
      değer kadar değilse göndermek istediğiniz verinin geriye kalanını
      göndermek sizin işinizdir. İyi haberlere gelince: Eğer paket küçükse
      (1k civarı) bu işlev büyük ihtimalle tüm veriyi bir seferde
      gönderebilecektir. Her zamanki gibi hata durumunda <constant>-1</constant>
      değerini döndürür ve <parameter>errno</parameter> küresel değişkenine
      hata kodunu yazar.
    </para><para>
      <function>recv()</function> işlevi da pek çok bakımdan yukarıdaki işleve
      benzer:
    </para><para>
<programlisting><![CDATA[
int recv(int sockfd, void *buf, int len, unsigned int flags); ]]>
</programlisting>
    </para><para>
      <parameter>sockfd</parameter> üzerinden okuma işlemini
      gerçekleştireceğiniz sokettir, <parameter>buf</parameter> okunan verinin
      yazılacağı bellek bölgesinin başlangıç adresini gösteren göstergedir,
      <parameter>len</parameter> ise verinin yazılacağı tamponun (buffer)
      azami boyudur ve <parameter>flags</parameter> yine <constant>0</constant>
      değerini alabilir (Ayrıntılı bilgi için <function>recv()</function>
      man sayfasına bakınız).
    </para><para>
      <function>recv()</function> okunduktan sonra tampona yazılan bayt miktarını
      döndürür ya da eğer bir hata oluştu ise <constant>-1</constant> değerini
      döndürüp <parameter>errno</parameter> değişkeninini değerini belirler.
    </para><para>
      Bir dakika! <function>recv()</function> <constant>0</constant> değerini
      döndürebilir! Bunun tek bir anlamı vardır: karşı taraf bağlantıyı
      kesmiş! Döndürülen değerin <constant>0</constant> olması
      <function>recv()</function> işlevinin size "karşı taraf bağlantıyı
      kesti" mesajını vermesi demektir.
    </para><para>
      Bütün bunları anlamak kolaydı değil mi? Artık verilerinizi soketler
      üzerinden yollayıp alabilirsiniz! Vay be! Artık siz bir Unix Ağ
      Programlama Uzmanısınız!
    </para>
  </sect1>
<!-- ======================================================= -->
<!-- sendtorecv -->
<!-- ======================================================= -->
  <sect1 id="bgnet_syscalls-sendtorecv">
    <title>
      <function>sendto()</function> ve <function>recvfrom()</function>
      -- Benimle UDP'ce Konuş
    </title>
    <para>
      "Buraya dek çok güzeldi," dediğinizi duyar gibiyim, "fakat bu bilgileri
      bağlantısız veri paketi soketleri üzerinde nasıl kullanabilirim ki?".
      No problemo, amigo. İşte derdine çare.
    </para><para>
      UDP soketleri uzaktaki bir konağa bağlı olmadığından kılavuz paketi
      yollamadan önce hangi bilgiyi vermemiz gerekiyor? Doğru tahmin!
      Hedef adres! Kısaca:
    </para><para>
<programlisting><![CDATA[
int sendto(int sockfd, const void *msg, int len, unsigned int flags,
           const struct sockaddr *to, int tolen); ]]>
</programlisting>
    </para><para>
      <function>send()</function> işlevine ne kadar da benziyor değil mi?
      Tek farkı fazladan iki bilgi parçası var. <parameter>to</parameter>
      dediğimiz <literal>struct sockaddr</literal> türünde bir değişkeni
      gösteren işaretçidir (normalde <literal>struct sockaddr_in</literal>
      türündedir ve siz son anda gerekli tür dönüşümünü yaparsınız) ve
      hedef IP adresi ile port numarasını barındırır.
      <parameter>tolen</parameter> değişkeni <literal>sizeof(struct sockaddr)</literal>
      değerini almalıdır.
    </para><para>
      Tıpkı <function>send()</function> gibi, <function>sendto()</function>
      işlevi de gönderilen bayt miktarını döndürür (bu beklediğinizden az
      olabilir tabii ki!) ve eğer hata oldu ise <constant>-1</constant>
      değerini döndürür.
    </para><para>
      Tahmin edebileceğiniz gibi <function>recv()</function> ve
      <function>recvfrom()</function> işlevleri birbirlerine çok benzerdir.
      Kısaca <function>recvfrom()</function> işlevine bakarsak:
    </para><para>
<programlisting><![CDATA[
int recvfrom(int sockfd, void *buf, int len, unsigned int flags,
             struct sockaddr *from, int *fromlen); ]]>
</programlisting>
    </para><para>
      Benzer olduğunu söylemiştim yani: <function>recv()</function>
      işlevinde olduğu gibi, sadece birkaç ek değişkene ihtiyacı var.
      <parameter>from</parameter> yerel bir <literal>struct sockaddr</literal>
      türünde değişkenin adresini gösteren göstergedir ki bu değişken de
      mesajın geldiği ilgili makinanın IP adresini ve port numarasını
      barındıracaktır. <parameter>fromlen</parameter> yerel ve
      <literal>int</literal> türünde bir göstergedir ve söz konusu
      değişkenin alması gereken ilk değer
      <literal>sizeof(struct sockaddr)</literal>'dir. İşlev, çalışıp bir
      değer döndürünce <parameter>fromlen</parameter> değişkeni
      <parameter>from</parameter> değişkenindeki adresin boyunu depoluyor
      olacaktır.
    </para><para>
      <function>recvfrom()</function> işlevi okuduğu bayt sayısını veya bir
      hata oluşması durumunda <constant>-1</constant> değerini döndürür
      (ve <parameter>errno</parameter> değişkenine uygun hata kodunu
      yerleştirir).
    </para><para>
      Unutmayın, eğer <function>connect()</function> ile bir UDP soketine
      bağlantı kurarsanız <function>send()</function> ve
      <function>recv()</function> işlevlerini kullanmanızda bir sakınca
      yoktur. Soketin kendisi hala bir bağlantısız veri paketi soketidir
      ve gidip gelen paketler de hala UDP protokolünü kullanır. Fakat
      soket arayüzü otomatik olarak sizin yerinize gerekli hedef ve
      kaynak bilgisini pakete ekler.
    </para>
  </sect1>
<!-- ======================================================= -->
<!-- closedown -->
<!-- ======================================================= -->
    <sect1 id="bgnet_syscalls-closedown">
      <title>
        <function>close()</function> ve <function>shutdown()</function>
        -- Düş Yakamdan!
      </title>
      <para>
        Vay be! Deminden beri <function>send()</function> ile veri gönderip
        <function>recv()</function> ile de veri okuyorsunuz ve artık
        yoruldunuz. Soket tanımlayıcınız ile ilişkilendirilmiş olan bağlantıyı
        kesmenin zamanıdır. Kolayı var. Alışık olduğunuz Unix dosya tanımlayıcı
        kapatma işlevi olan <function>close()</function> işlevini kullanın:
      </para><para>
<programlisting><![CDATA[
close(sockfd); ]]>
</programlisting>
      </para><para>
        Böylece artık bu sokete ne yazılabilir ne de buradan veri okunabilir.
        Diğer uçta bunları yapmaya çalışan kişi artık bir hata mesajı ile
        karşılaşacaktır.
      </para><para>
        Eğer soket kapatma işlemi üzerinde biraz daha deentim sahibi olmak
        isterseniz o zaman <function>shutdown()</function> işlevini tercih
        edebilirsiniz. Bu işlevi kullanarak iletişim kanalını tek yönlü ya
        da çift yönlü olarak kapatabilirsiniz ( <function>close()</function>
        işlevi iki taraflı olarak keser). İşlev şöyledir:
      </para><para>
<programlisting><![CDATA[
int shutdown(int sockfd, int how); ]]>
</programlisting>
      </para><para>
        <parameter>sockfd</parameter> kapatmak istediğiniz soket dosya
        tanımlayıcısıdır ve <parameter>how</parameter> değişkeni de şu
        değerlerden birini alabilir:
      </para><para>
        <itemizedlist>
          <listitem><para>
            <constant>0</constant> -- Bundan sonraki okumalara izin verme
          </para></listitem><listitem><para>
            <constant>1</constant> -- Bundan sonraki göndermelere (yazmalara)
            izin verme
          </para></listitem><listitem><para>
            <constant>2</constant> -- Bundan sonraki göndermelere ve okumalara
            izin verme (<function>close()</function> işlevinin yaptığı gibi)
          </para></listitem>
        </itemizedlist>
      </para><para>
        <function>shutdown()</function> başarılı olarak görevini tamamlarsa
        <constant>0</constant> döndürür ama eğer bir hata ile karşılaşırsa
        <constant>-1</constant> döndürür (ve <parameter>errno</parameter>
        değişkenine hata kodunu yazar).
      </para><para>
        Eğer <function>shutdown()</function> işlevini bağlantısız veri paketi
        soketleri üzerinde kullanırsanız bu soketler artık <function>send()</function>
        ve <function>recv()</function> işlevleri tarafından kullanılamaz hale
        gelirler (bunları, <function>connect()</function> ile bağlanmak
        istediğinizde kullanabileceğinizi unutmayın).
      </para><para>
        Bir başka önemli nokta da: <function>shutdown()</function> aslında
        dosya tanımlayıcısını kapatmaz sadece kullanılabilirliğini
        değiştirir. Soket tanımlayıcısını gerçekten iptal etmek istiyorsanız
        <function>close()</function> kullanmalısınız.
      </para><para>Yapacak birşey yok.
      </para>
    </sect1>
<!-- ======================================================= -->
<!-- getpeername -->
<!-- ======================================================= -->
    <sect1 id="bgnet_syscalls-getpeername">
      <title><function>getpeername()</function> -- Kimsiniz?</title>
      <para>
        Bu işlev o kadar kolay ki!
      </para><para>
        Yani gerçekten o kadar kolay ki ayrı bir bölümü hak ediyor mu
        bilemiyorum.Neyse gene de yazdım işte.
      </para><para>
        <function>getpeername()</function> bağlantılı veri akış soketinin
        diğer tarafında kim olduğunu söyler:
      </para><para>
<programlisting><![CDATA[
#include <sys/socket.h>

int getpeername(int sockfd, struct sockaddr *addr, int *addrlen); ]]>
</programlisting>
      </para><para>
        <parameter>sockfd</parameter> bağlantılı veri akış soketinin
        tanımlayıcısıdır, <parameter>addr</parameter>,
        <literal>struct sockaddr</literal> (veya
        <literal>struct sockaddr_in</literal>) türündeki bir göstergedir ki
        bu da iletişimin diğer ucundaki konak ile ilgili bilgileri tutar.
        <parameter>addrlen</parameter>,  <literal>int</literal> türündeki
        göstergedir, alması gereken ilk değer ise <literal>sizeof(struct sockaddr)</literal>
        olarak verilir.
      </para><para>
        Bu işlev hata durumunda <constant>-1</constant> değerini döndürür ve
        <parameter>errno</parameter> değişkenine gerekli değeri yazar.
      </para><para>
        Bir kere karşı tarafın adres bilgisine eriştikten sonra
        <function>inet_ntoa()</function> veya <function>gethostbyaddr()</function>
        işlevleri ile daha fazla bilgi edinebilirsiniz. Hayır, onların
        login ismini öğrenemezsiniz. (Tamam, tamam. Eğer diğer bilgisayar
        <command>identd</command> sürecini çalıştırıyor ise bu mümkündür.
        Ancak bu konumuz dışında<footnote><para>Ayrıntılı bilgi için bakınız:
        <ulink url="http://www.rfc-editor.org/rfc/rfc1413.txt">RFC-1413</ulink>.)
        </para></footnote>
      </para>
    </sect1>
<!-- ======================================================= -->
<!-- gethostname -->
<!-- ======================================================= -->
    <sect1 id="bgnet_syscalls-gethostname">
      <title><function>gethostname()</function> -- Ben kimim?</title>
      <para>
        <function>getpeername()</function> işevinden daha kolay bir işlev
        varsa o da <function>gethostname()</function> işlevidir.
        Programınızın üzerinde çalıştığı konağın ismini döndürür. Bu isim
        daha sonra <function>gethostname()</function> tarafından makinanızın
        IP adresini tespit etmek için kullanılabilir.
      </para><para>
        Bundan daha eğlenceli bir şey olabilir mi? Aslında aklıma geliyor
        ama soket programlama ile ilgili değil. Neyse devam edelim:
      </para><para>
<programlisting><![CDATA[
#include <unistd.h>

int gethostname(char *hostname, size_t size); ]]>
</programlisting>
      </para><para>
        Argümanlar gayet basit: <parameter>hostname</parameter> işlev
        çağrıldıktan sonra bilgisayarın ismini barındıracak karakter
        dizisinin göstergesidir ve <parameter>size</parameter> değişkeni
        de <parameter>hostname</parameter> dizisinin bayt cinsinden
        uzunluğudur.
      </para><para>
        İşler yolunda giderse, işlev <constant>0</constant> değerini döndürür
        ve hata oluşursa da <constant>-1</constant> değerini döndürüp
        <parameter>errno</parameter> değişkenini gerekli şekilde ayarlar.
      </para>
    </sect1>
<!-- ======================================================= -->
<!-- dns -->
<!-- ======================================================= -->
  <sect1 id="bgnet_syscalls-dns">
    <title>DNS -- Sen "whitehouse.gov" de, ben de "198.137.240.92" diyeyim</title>
    <para>
      Eğer DNS'in ne olduğunu bilmiyorsanız söyleyeyim: "Domain Name System"
      yani "Alan Adı Sistemi" demek. Kısaca siz ona kolayca
      hatırlayabildiğiniz adresi verirsiniz o da size buna karşılık gelen
      IP adresini verir (ki siz de bu bilgiyi <function>bind()</function>,
      <function>connect()</function>, <function>sendto()</function> ve diğer
      işlevleri çağırırken kullanabilesiniz). Böylece biri:
    </para><para>
<screen>
<prompt>$</prompt> <userinput>telnet whitehouse.gov</userinput>
</screen>
    </para><para>
      komutunu girdiğinde <command>telnet</command> yazılımı
      <function>connect()</function> işlevine verilmesi gereken
      "198.137.240.92" bilgisine erişebilir.
    </para><para>
      Peki bu nasıl çalışır? Bunun için <function>gethostbyname()</function>
      işlevini kullanacaksınız:
    </para><para>
<programlisting><![CDATA[
#include <netdb.h>

struct hostent *gethostbyname(const char *name); ]]>
</programlisting>
    </para><para>
      Gördüğünüz gibi bu işlev <literal>struct hostent</literal> türünde
      bir gösterge döndürür. Söz konusu türün ayrıntılı yapısı da şöyledir:
    </para><para>
<programlisting><![CDATA[
struct hostent {
    char    *h_name;
    char    **h_aliases;
    int     h_addrtype;
    int     h_length;
    char    **h_addr_list;
};
#define h_addr h_addr_list[0] ]]>
</programlisting>
    </para><para>
      Bu karmaşık değişkenin içindeki alanların açıklamalarına gelince:
    </para><para>
      <itemizedlist>
        <listitem><para>
          <parameter>h_name</parameter> -- Konağın resmi ismi.
        </para></listitem><listitem><para>
          <parameter>h_aliases</parameter> -- Söz konusu konağın alternatif
          isimleri, NULL ile sonlandırılmış karakter dizileri şeklinde.
        </para></listitem><listitem><para>
          <parameter>h_addrtype</parameter> -- Dönen adresin türü, genellikle
          <literal>AF_INET</literal> değerini alır.
        </para></listitem><listitem><para>
          <parameter>h_length</parameter> -- Byte cinsinden adresin uzunluğu.
        </para></listitem><listitem><para>
          <parameter>h_addr_list</parameter> -- Konağın ağ adresinin
          sıfır sonlandılmalı dizisi. Konak adresleri ağ bayt sıralamasına
          sahiptir.
        </para></listitem><listitem><para>
          <parameter>h_addr</parameter> -- <parameter>h_addr_list</parameter>
          listesindeki ilk adres.
        </para></listitem>
      </itemizedlist>
    </para><para>
      <function>gethostbyname()</function> çalıştıktan sonra içini doldurduğu
      <literal>struct hostent</literal> türünden bir gösterge döndürür. Eğer
      hata oluşursa NULL döndürür. (Fakat <parameter>errno</parameter>
      değişkeni ile ilgili herhangi bir işlem yapmaz -- bunun yerine
      <parameter>h_errno</parameter> değişkeni kullanılır. Ayrıntılı bilgi için
      aşağıdaki <function>herror()</function> işlevine bakın.)
    </para><para>
      Peki tüm bu bilgileri nasıl kullanacağız? Bazen okuyucuya bilgi
      yığınını verip onu bununla başbaşa bırakmak yeterli olmaz (bilgisayar
      belgelerini okuyanlar ne demek istediğimi anlıyorlardır). Bu işlevi
      kullanmak düşündüğünüzden daha kolaydır.
    </para><para>
      <ulink url="http://www.ecst.csuchico.edu/~beej/guide/net/examples/getip.c"
      >İşte örnek bir program</ulink>:
    </para><para>
<programlisting><![CDATA[
/*
** getip.c -- konak isminden IP adresini elde edilmesi
*/

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <netdb.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

int main(int argc, char *argv[])
{
    struct hostent *h;

    if (argc != 2) {  // komut satırında hata denetimi
        fprintf(stderr,"usage: getip konak_ismi\n");
        exit(1);
    }

    if ((h=gethostbyname(argv[1])) == NULL) {  // konak bilgilerini al
        herror("gethostbyname");
        exit(1);
    }

    printf("Konak ismi: %s\n", h->h_name);
    printf(" IP Adresi: %s\n", inet_ntoa(*((struct in_addr *)h->h_addr)));

   return 0;
} ]]>
</programlisting>
    </para><para>
      <function>gethostbyname()</function> söz konusu olduğunda
      <function>perror()</function> işlevini hata mesajını basmak için
      kullanamazsınız (çünkü <parameter>errno</parameter> gerekli değeri
      almaz). Bunun yerine <function>herror()</function> işlevini
      kullanmalısınız.
    </para><para>
      Açıklama basit: Doğrudan ilgilendiğiniz makinanın Internet adresini
      verirsiniz ("whitehouse.gov") ve <function>gethostbyname()</function>
      işlevi de çalışıp işini bitirdikten sonra size
      <literal>struct hostent</literal> türünde bir değişken döndürür.
    </para><para>
      Buradaki tek gariplik şudur: IP adresini basarken kullanmanız gereken
      <parameter>h->h_addr</parameter>, <literal>char*</literal> türündedir
      ama <function>inet_ntoa()</function> işlevi <literal>struct in_addr</literal>
      türünde bir değişken isteme konusunda ısrarcı olduğu için önce
      <parameter>h->h_addr</parameter> değiğkenini
      <literal>struct in_addr*</literal> türüne çevirdim ve ardından veriye
      ulaştım.
    </para>
  </sect1>
</chapter>  <!-- syscalls -->

<!-- ======================================================= -->
<!-- clientserver -->
<!-- ======================================================= -->

<chapter id="bgnet_clientserver">
  <title>İstemci-Sunucu Mimarisi</title>
  <para>
    İstemci-sunucu dünyasında yaşıyoruz, bunu kabul et dostum. Ağ ortamındaki
    hemen her süreç ya da uygulama öyle ya da böyle sunucu süreçleriyle
    konuşup aldıkları cevaplara göre iş yapıyor ya da tersi oluyor. Mesela
    <command>telnet</command> programını ele alalım. Siz uzaktaki bir
    konağın 23 numaralı portuna <command>telnet</command> (istemci) ile
    bağlandığınızda o konakta da <command>telnetd</command> (sunucu) isimli
    bir program soluk alıp vermeye başlar. Bu program gelen
    <command>telnet</command> bağlantılarını dinler, size bir "login:"
    istemi gönderir, vs. vs.
  </para><para>
    <figure float="0" id="bgnet_figure2">
      <title>Sunucu-İstemci Etkileşimi</title>
      <inlinemediaobject>
        <imageobject>
          <imagedata align="center" fileref="cs-tr.gif"/>
        </imageobject>
        <caption>Sunucu-İstemci Etkileşimi</caption>
      </inlinemediaobject>
    </figure>
  </para><para>
    İstemci ile sunucu arasındaki bilgi alışverişi <xref
    linkend="bgnet_figure2"/>'de özetlenmiştir.
  </para><para>
    Dikkat etmeniz gereken noktalardan biri de şudur: istemci-sunucu çifti
    birbirleri ile <constant>SOCK_STREAM</constant>, <constant>SOCK_DGRAM</constant>
    veya başka bir tarzda konuşuyor olabilirler (yeter ki aynı dili
    konuşsunlar). İstemci-sunucu çiftlerine birkaç meşhur örnek vermek
    gerekirse: <command>telnet</command>/<command>telnetd</command>,
    <command>ftp</command>/<command>ftpd</command> veya
    <command>bootp</command>/<command>bootpd</command>. Yani ne zaman bir
    <command>ftp</command> programı çalıştırsanız diğer tarafta
    <command>ftpd</command> gibi size hizmeti sunan bir süreç vardır.
  </para><para>
    Genellikle sunucu makinada ilgili hizmet için tek bir sunucu program
    çalışır ve bu program kendisine bağlanan birden fazla istemciye
    <function>fork()</function> işlevi aracılığı ile hizmet eder. Süreci
    özetlemek gerekirse: Sunucu bir bağlantı isteği için bekleyecek,
    <function>accept()</function> işlevi ile bunu kabul edecek ve
    <function>fork()</function> işlevi ile bir çocuk süreç yaratıp veri
    alışverişini bu sürece devredecek. Bir sonraki bölümde inceleyeceğimiz
    örnek sunucu yazılımın yaptığı iş tam da yukarıda anlatıldığı gibidir.
  </para>
<!-- ======================================================= -->
<!-- simpleserver -->
<!-- ======================================================= -->
  <sect1 id="bgnet_clientserver-simpleserver">
    <title>Basit Bir Veri Akış Sunucusu</title>
    <para>
      Bu sunucunun yaptığı tek bir iş var: "<literal>Hello, World!\n</literal>"
      dizgesiniz bir veri akış bağlantısı üzerinden karşı tarafa yollamak.
      Sunucunun düzgün çalışıp çalışmadığını test etmek için tek yapmanız
      gereken derledikten sonra bir pencerede çalıştırmak ve ardından başka
      bir terminal penceresi açıp <command>telnet</command> yazılımı ile
      sunucuya şu şekilde erişmek:
    </para><para>
<screen>
<prompt>$</prompt> <userinput>telnet remotehostname 3490</userinput>
</screen>
    </para><para>
      Burada <literal>remotehostname</literal> sunucuyu üzerinde
      çalıştırdığınız makinanızın adıdır<footnote><para>Sunucu makina
      ile <command>telnet</command>'i çalıştırdığınız makina aynı ise
      <literal>localhost</literal> ismini de kullanabilirsiniz.</para>
      </footnote>.
    </para><para>
      <ulink url="http://www.ecst.csuchico.edu/~beej/guide/net/examples/server.c"
      >Sunucu yazılımın C dilindeki kaynak kodu aşağıdaki gibidir:</ulink>:
      (Bilgi: Bir satırın sonundaki \ satırın alt satırda devam ettiğini ifade
      eder.)
    </para><para>
<programlisting><![CDATA[
/*
** server.c -- bir veri akış soketi sunucusu örneği
*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/wait.h>
#include <signal.h>

#define MYPORT 3490    // kullanıcıların bağlanacağı port

#define BACKLOG 10     // bağlantı kuyruğunda bekletileceklerin sayısı

void sigchld_handler(int s)
{
    while(wait(NULL) > 0);
}

int main(void)
{
    int sockfd, new_fd;  // sock_fd ile dinle, yen bağlantıyı new_fd ile al
    struct sockaddr_in my_addr;    // adres bilgim
    struct sockaddr_in their_addr; // bağlananın adres bilgisi
    int sin_size;
    struct sigaction sa;
    int yes=1;

    if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
        perror("socket");
        exit(1);
    }

    if (setsockopt(sockfd,SOL_SOCKET,SO_REUSEADDR,&yes,sizeof(int)) == -1) {
        perror("setsockopt");
        exit(1);
    }

    my_addr.sin_family = AF_INET;         // konak bayt sıralaması
    my_addr.sin_port = htons(MYPORT);     // short, ağ bayt sıralaması
    my_addr.sin_addr.s_addr = INADDR_ANY; // otomatik olarak IP'mi kullan
    memset(&(my_addr.sin_zero), '\0', 8); // geriye kalan bölgeyi sifirla

    if (bind(sockfd, (struct sockaddr *)&my_addr, sizeof(struct sockaddr))
                                                                   == -1) {
        perror("bind");
        exit(1);
    }

    if (listen(sockfd, BACKLOG) == -1) {
        perror("listen");
        exit(1);
    }

    sa.sa_handler = sigchld_handler; // tüm ölü süreçleri kaldır
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART;
    if (sigaction(SIGCHLD, &sa, NULL) == -1) {
        perror("sigaction");
        exit(1);
    }

    while(1) {                       // ana accept() döngüsü
        sin_size = sizeof(struct sockaddr_in);
        if ((new_fd = accept(sockfd, (struct sockaddr *)&their_addr,
                                                       &sin_size)) == -1) {
            perror("accept");
            continue;
        }
        printf("server: got connection from %s\n",
                                           inet_ntoa(their_addr.sin_addr));
        if (!fork()) {               // çocuk süreç
            close(sockfd);           // çocuk sürecin dinlemesi gerekmez
            if (send(new_fd, "Hello, world!\n", 14, 0) == -1)
                perror("send");
            close(new_fd);
            exit(0);
        }
        close(new_fd);               // ana sürecin buna ihtiyacı yok
    }

    return 0;
} ]]>
</programlisting>
    </para><para>
      Meraklısına not: Evet kodu tek bir büyük <function>main()</function>
      işlevi olarak yazdım, anlaşılması basit olsun diye, ancak eğer
      isterseniz bunu işlevlere ayırabilirsiniz.
    </para><para>
      (Bir de şu <function>sigaction()</function> meselesi size yabancı
      gelebilir -- haklısınız. O gördüğünüz kod <function>fork()</function>
      ile oluşturulan çocuk süreçler sonlandıktan sonra kalabilecek "zombi"
      proseslerin icabına bakmak için var. Eğer böyle bir sürü zombi süreç
      olur ve siz bir şekilde onların icabına bakmazsanız bunlar gereksiz
      yere sistem kaynaklarını kullanır ve bu da sistem yöneticinizin size
      sinirlenmesine yol açar.)
    </para><para>
      Şimdi yukarıdaki sunucudan veri çekebilecek bir istemci program örneğine
      bakalım.
    </para>
  </sect1>
<!-- ======================================================= -->
<!-- simpleclient -->
<!-- ======================================================= -->
  <sect1 id="bgnet_clientserver-simpleclient">
    <title>Basit Bir Veri Akış İstemcisi</title>
    <para>
      Bu program daha da basit. Bu istemcinin tek yaptığı şey komut
      satırından belirleyeceğiniz bir konağa 3490 numaralı port üzerinden
      bağlanmak. Sonra da sunucunun gönderdiği dizgeyi alıp ekrana basmak.
    </para><para>
      <ulink url="http://www.ecst.csuchico.edu/~beej/guide/net/examples/client.c"
      >Hemen kaynak koduna bakalım:</ulink>:
    </para><para>
<programlisting><![CDATA[
/*
** client.c -- bir veri akış soketi istemcisi örneği
*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <netdb.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <sys/socket.h>

#define PORT 3490 // istemcinin bağlanacağı port

#define MAXDATASIZE 100 // bir seferde kabul edebileceğimizazami byte miktarı

int main(int argc, char *argv[])
{
    int sockfd, numbytes;
    char buf[MAXDATASIZE];
    struct hostent *he;
    struct sockaddr_in their_addr; // bağlananın adres bilgisi

    if (argc != 2) {
        fprintf(stderr,"usage: client hostname\n");
        exit(1);
    }

    if ((he=gethostbyname(argv[1])) == NULL) {  // konak bilgisini al
        perror("gethostbyname");
        exit(1);
    }

    if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
        perror("socket");
        exit(1);
    }

    their_addr.sin_family = AF_INET;    // konak bayt sıralaması
    their_addr.sin_port = htons(PORT);  // short, ağ bayt sıralaması
    their_addr.sin_addr = *((struct in_addr *)he->h_addr);
    memset(&(their_addr.sin_zero), '\0', 8);  // geriye kalanı sıfırla

    if (connect(sockfd, (struct sockaddr *)&their_addr,
                                          sizeof(struct sockaddr)) == -1) {
        perror("connect");
        exit(1);
    }

    if ((numbytes=recv(sockfd, buf, MAXDATASIZE-1, 0)) == -1) {
        perror("recv");
        exit(1);
    }

    buf[numbytes] = '\0';

    printf("Received: %s",buf);

    close(sockfd);

    return 0;
} ]]>
</programlisting>
    </para><para>
      Aklınızda bulunsun eğer sunucuyu çalıştırmadan yukarıdaki istemciyi
      çalıştıracak olursanız <function>connect()</function> işlevi
      "Connection refused" (Bağlantı reddedildi) hatası verir. Çok faydalı.
    </para>
  </sect1>
<!-- ======================================================= -->
<!-- datagram -->
<!-- ======================================================= -->
  <sect1 id="bgnet_clientserver-datagram">
    <title>Veri Paketi Soketleri</title>
    <para>
      Buraya dek yazılanları anladı iseniz çok fazla açıklamaya gerek yok,
      örnek programların kodunu inceleyerek kavrayabilirsiniz:
      <filename>talker.c</filename> ve <filename>listener.c.</filename>.
    </para><para>
      <command>listener</command> programı bir makinada çalıştıktan sonra
      4950 numaralı port üzerinden gelecek paketleri dinlemeye başlar.
      <command>talker</command> ise komut satırında belirteceğiniz bir
      makinanın 4950 numaralı portuna yine komut satırından yazdığınız
      mesajı bir veri paketi olarak yollar.
    </para><para>
      <ulink url="http://www.ecst.csuchico.edu/~beej/guide/net/examples/listener.c"
      ><filename>listener.c</filename></ulink> programının kaynak koduna bakalım:
    </para><para>
<programlisting><![CDATA[
/*
** listener.c -- a veri paketi soketi sunucusu örneği
*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#define MYPORT 4950    // kullanıcıların bağlanacağı port

#define MAXBUFLEN 100

int main(void)
{
    int sockfd;
    struct sockaddr_in my_addr;    // adres bilgim
    struct sockaddr_in their_addr; // bağlananın adres bilgisi
    int addr_len, numbytes;
    char buf[MAXBUFLEN];

    if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) == -1) {
        perror("socket");
        exit(1);
    }

    my_addr.sin_family = AF_INET;         // konak bayt sıralaması
    my_addr.sin_port = htons(MYPORT);     // short, ağ bayt sıralaması
    my_addr.sin_addr.s_addr = INADDR_ANY; // otomatik olarak IP'mi kullan
    memset(&(my_addr.sin_zero), '\0', 8); // kalanı sıfırla

    if (bind(sockfd, (struct sockaddr *)&my_addr,
                                          sizeof(struct sockaddr)) == -1) {
        perror("bind");
        exit(1);
    }

    addr_len = sizeof(struct sockaddr);
    if ((numbytes=recvfrom(sockfd,buf, MAXBUFLEN-1, 0,
                       (struct sockaddr *)&their_addr, &addr_len)) == -1) {
        perror("recvfrom");
        exit(1);
    }

    printf("got packet from %s\n",inet_ntoa(their_addr.sin_addr));
    printf("packet is %d bytes long\n",numbytes);
    buf[numbytes] = '\0';
    printf("packet contains \"%s\"\n",buf);

    close(sockfd);

    return 0;
} ]]>
</programlisting>
    </para><para>
      Dikkat edin ki <function>socket()</function> işlevini çağırırken
      <constant>SOCK_DGRAM</constant> kullandık. Ayrıca bu tür soketlerde
      <function>listen()</function> veya <function>accept()</function>
      işlevlerine ihtiyacımız yok. Bağlantısız veri paketi soketlerini
      kullanmanın güzel yanları da var gördüğünüz gibi!
    </para><para>
      Şimdi de sırada <ulink url="http://www.ecst.csuchico.edu/~beej/guide/net/examples/talker.c"
      ><filename>talker.c</filename></ulink> programının kaynak kodu var::
    </para><para>
<programlisting><![CDATA[
/*
** talker.c -- a datagram "client" demo
*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

#define MYPORT 4950    // kullanıcıların bağlanacağı port

int main(int argc, char *argv[])
{
    int sockfd;
    struct sockaddr_in their_addr; // bağlananın adres bilgisi
    struct hostent *he;
    int numbytes;

    if (argc != 3) {
        fprintf(stderr,"usage: talker hostname message\n");
        exit(1);
    }

    if ((he=gethostbyname(argv[1])) == NULL) {  // konak bilgisini al
        perror("gethostbyname");
        exit(1);
    }

    if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) == -1) {
        perror("socket");
        exit(1);
    }

    their_addr.sin_family = AF_INET;     // konak bayt sıralaması
    their_addr.sin_port = htons(MYPORT); // short, ağ bayt sıralaması
    their_addr.sin_addr = *((struct in_addr *)he->h_addr);
    memset(&(their_addr.sin_zero), '\0', 8); // kalanı sıfırla

    if ((numbytes=sendto(sockfd, argv[2], strlen(argv[2]), 0,
         (struct sockaddr *)&their_addr, sizeof(struct sockaddr))) == -1) {
        perror("sendto");
        exit(1);
    }

    printf("sent %d bytes to %s\n", numbytes,
                                           inet_ntoa(their_addr.sin_addr));

    close(sockfd);

    return 0;
} ]]>
</programlisting>
    </para><para>
      Hepsi bu kadar! Bir bilgisayarda <command>listener</command> programını
      derleyip çalıştırın ve başka bir bilgisayara geçip
      <command>talker</command> programını çalıştırın, birbirleri ile ne kadar
      güzel iletişim kurduklarını gözlemleyin!
    </para><para>
      Bu bölümü bitirmeden önce son bir ayrıntı: daha önce bağlantılı
      veri paketi soketlerinden bahsetmiştim. Madem veri paketi iletişimi
      ile ilgili örnek verdik o halde birkaç şey daha söylememe izin verin.
      Mesela <command>talker</command> <function>connect()</function>
      işlevini çağırıyor olsun ve <command>listener</command>'ın adresini
      belirtmiş olsun. O noktadan itibaren <command>talker</command> sadece
      ve sadece <function>connect()</function> ile belirlenen adresi
      kullanabilir. Bu yüzden <function>sendto()</function> ve
      <function>recvfrom()</function> kullanmanıza gerek kalmaz;
      <function>send()</function> ve <function>recv()</function> ile
      işinizi görebilirsiniz.
    </para>
  </sect1>
</chapter> <!-- clientserver -->
<!-- ======================================================= -->
<!-- advanced -->
<!-- ======================================================= -->
<chapter id="bgnet_advanced">
  <title>İleri Teknikler</title>
  <para>
    Aslında burada anlatacağım teknikler çok fazla ileri sayılmaz ama gene
    de şimdiye dek gördüğümüz bilgilerin ötesinde şeyler gerektiriyorlar.
    Doğrusunu söylemek gerekirse zaten bu aşamaya dek geldiyseniz kendizi
    UNIX Ağ Programlama Temelleri konusunda ciddi olarak bilgili kabul
    edebilirsiniz! Tebrikler!
  </para><para>
    Şimdi sıra soketlerle ilgili bazı garip şeyleri öğrenmede, cesur yeni
    dünyaya hoşgeldiniz. Alın bakalım!
  </para>
<!-- ======================================================= -->
<!-- blocking -->
<!-- ======================================================= -->
  <sect1 id="bgnet_advanced-blocking">
    <title>Bloklama</title>
    <para>
      Bloklama. Bunu duymuş olmalısınız -- peki anlamı nedir? Kabaca
      söylemek gerekirse "blok" (block) sözcüğü "uyku" (sleep) için
      kullandığımız teknik bir terim. Bunu, yukarıdaki
      <command>listener</command> programını çalıştırdığınızda görmüş
      olmalısınız. Yani program çalışır ve orada öylece bir paketin
      gelmesini bekler. Olup biten şudur: Bu program
      <function>recvfrom()</function> işlevini çağırır, ortalıkta bir
      veri yoktur ve bu yüzden <function>recvfrom()</function>
      "bloklama" yapar (yani orada uyur) ta ki bir veri gelene kadar.
    </para><para>
      Pek çok işlev blok yapar, yani uyur. <function>accept()</function>
      bloklar. Tüm <function>recv()</function> işlevleri bloklar, yani
      bekler. Bunu yapabilmelerinin sebebi ise onlara bunu yapabilmeleri
      için izin verilmiş olmasıdır. Soket tanımlayıcısını ilk aşamada
      <function>socket()</function> ile yarattığınızda, işletim sistemi
      çekirdeği onu bloklayan olarak ayarlar. Eğer bir soketin bloklama
      yapabilmesini istemiyorsanız o zaman <function>fcntl()</function>
      işlevini çağırmanız gerekir:
    </para><para>
<programlisting><![CDATA[
#include <unistd.h>
#include <fcntl.h>
.
.
sockfd = socket(AF_INET, SOCK_STREAM, 0);
fcntl(sockfd, F_SETFL, O_NONBLOCK);
.
. ]]>
</programlisting>
    </para><para>
      Bir soketi bloklamayan olarak ayarladığınızda o soketten bilgi
      alabilirsiniz. Eğer bloklamayan bir soketten bir şeyler okumaya
      kalkarsanız ve orada bir veri yoksa, bloklama yapmasına izin
      verilmediği için bir değer döndürecektir, bu değer <constant>-1</constant>
      olacaktır ve <parameter>errno</parameter> değişkeni de
      <constant>EWOULDBLOCK</constant> değerini alacaktır.
    </para><para>
      Ancak genelde bu şekilde bilgi edinmeye çalışmak pek de iyi bir
      fikir değildir. Eğer programınızı sürekli soketten veri okumaya
      çalışır hale getirirseniz o zaman çok fazla işlemci zamanından
      çalarsınız. Okunmak üzere bir verinin gelip gelmediğini kontrol
      etmenin daha şık bir yöntemi vardır ve bu yöntem
      <function>select()</function> işlevini temel alır.
    </para>
  </sect1>
<!-- ======================================================= -->
<!-- select -->
<!-- ======================================================= -->
  <sect1 id="bgnet_advanced-select">
    <title><function>select()</function> -- Eşzamanlı G/Ç Çoğullama</title>
    <para>
      Biraz garip olmakla birlikte bu işlevin epey faydalı olduğu
      söylenebilir. Şu durumu ele alalım: siz bir sunucu programsınız ve
      bir yandan gelen bağlantıları dinlerken öte yandan da açık olan
      bağlantılardan akmakta olan verileri okumak istiyorsunuz.
    </para><para>
      Sorun değil, diyorsunuz, bir <function>accept()</function> ve birkaç
      tane de <function>recv()</function> işimizi görür. Ağır ol dostum!
      Ya çağırdığın <function>accept()</function> işlevi bloklayan durumda
      ise? O zaman aynı anda <function>recv()</function> ile nasıl oluyor
      da veri okumayı düşünebiliyorsun? "O halde bloklamayan soketleri
      kullanırım!" Hiç yakıştıramadım senin gibi bir programcıya! İşlemci
      zamanını deliler gibi harcamak mı istiyorsun? E peki nasıl yapacağız
      öyleyse?
    </para><para>
      <function>select()</function> aynı anda birden fazla soketi gözetleme
      imkânı sunar. Bununla kalmaz aynı zamanda hangi soketin okumak için
      hazır olduğunu, hangisine yazabileceğiniz, hangisinde istisnai durumlar
      oluştuğunu da söyler.
    </para><para>
      Laf kalabalığını kesip hemen işleve geçiyorum,
      <function>select()</function>:
    </para><para>
<programlisting><![CDATA[
#include <sys/time.h>
#include <sys/types.h>
#include <unistd.h>

int select(int numfds, fd_set *readfds, fd_set *writefds,
           fd_set *exceptfds, struct timeval *timeout); ]]>
</programlisting>
    </para><para>
      Bu işlev dosya tanımlayıcı kümelerini gözlemler. Özel olarak
      ilgilendikleri ise <parameter>readfds</parameter>,
      <parameter>writefds</parameter> ve <parameter>exceptfds</parameter>'dir.
      Mesela standart girdiden ve <parameter>sockfd</parameter> gibi bir
      soket tanımlayıcıdan veri okuyup okuyamayacağınızı merak ediyorsanız
      tek yapmanız gereken <constant>0</constant> ve
      <parameter>sockfd</parameter>'yi <parameter>readfds</parameter>
      kümesine eklemek. <parameter>numfds</parameter> parametresi azami
      dosya tanımlayıcı artı bir olarak ayarlanmalıdır. Bu örnekte
      <parameter>sockfd+1</parameter> olmalıdır. Çünkü açıktır ki yukarıdaki
      değer standart girdiden (<constant>0</constant>) daha büyük olacaktır.
    </para><para>
      <function>select()</function> çalıştırıldıktan sonra <parameter>readfds</parameter>
      seçmiş olduğunuz dosya tanımlayıcılardan hangisinin okumak için hazır
      olduğunu yansıtacak şekilde güncellenir. Bunları aşağıdaki
      <function>FD_ISSET()</function> makrosu ile test edebilirsiniz.
    </para><para>
      Daha fazla ilerlemeden bu kümeler ile nasıl başa çıkacağınızı anlatayım.
      Her küme <literal>fd_set</literal> türündedir. Bu tür üzerinde aşağıdaki
      makroları kullanabilirsiniz:
    </para><para>
      <itemizedlist>
        <listitem><para>
          <function>FD_ZERO(fd_set *set)</function> -- dosya tanımlayıcı
          kümesini temizler.
        </para></listitem><listitem><para>
          <function>FD_SET(int fd, fd_set *set)</function> -- kümeye
          <parameter>fd</parameter>'yi ekler.
        </para></listitem><listitem><para>
          <function>FD_CLR(int fd, fd_set *set)</function> --
          <parameter>fd</parameter>'yi kümeden çıkarır.
        </para></listitem><listitem><para>
          <function>FD_ISSET(int fd, fd_set *set)</function> --
           <parameter>fd</parameter>'ni küme içinde olup olmadığına bakar.
        </para></listitem>
      </itemizedlist>
    </para><para>
      Son olarak, nedir bu <literal>struct timeval</literal>? Bazen birilerinin
      size veri göndermesini sonsuza dek beklemek istemezsiniz. Belki de her
      96 saniyede bir ekrana "Hala çalışıyor..." mesajı basmak istersiniz
      (program o esnada bir şey yapmıyor olsa bile). Bu zaman yapısı sizin bir
      sonlandırma süresi ("timeout period") belirlemenizi sağlar. Eğer bu süre
      geçildi ise ve <function>select()</function> hala hazır bir dosya
      tanımlayıcı bulamadı ise o zaman işlev (select) döner ve böylece de siz
      de işinize devam edebilirsiniz.
    </para><para>
      <literal>struct timeval</literal> yapısının elemanları aşağıdaki gibidir:
    </para><para>
<programlisting><![CDATA[
struct timeval {
    int tv_sec;     // seconds
    int tv_usec;    // microseconds
}; ]]>
</programlisting>
    </para><para>
      Tek yapmanız gereken <parameter>tv_sec</parameter>'i kaç saniye
      bekleneceğine ayarlamak ve <parameter>tv_usec</parameter>'i de kaç
      mikrosaniye bekleneceğine ayarlamak. Evet, doğru okudunuz,
      mikrosaniye, milisaniye değil. Bir milisaniye içinde 1,000
      mikrosaniye vardır ve bir saniye içinde de 1,000 milisaniye vardır.
      Yani bir saniye içinde 1,000,000 mikrosaniye vardır. Tamam da neden
      "usec"? Buradaki "u" harfinin Yunan alfabesindeki Mü harfine benzediği
      düşünülmüştür ve bu yüzden "mikro"yu temsilen kullanılmıştır.
      Bunlara ek olarak işlev döndüğünde <parameter>timeout</parameter>
      ne kadar zaman kaldığını gösterecek şekilde güncellenmiş olabilir.
      Bu hangi tür UNIX kullandığınıza bağlıdır.
    </para><para>
      Vay canına! Mikrosaniye hassasiyetinde bir zamanlayıcımız var! Gene de
      siz buna çok güvenmeyin. Standart Unix zamandilimi yaklaşık 100
      milisaniyedir, yani <literal>struct timeval</literal> yapısını nasıl
      ayarlarsanız ayarlayın en az bu kadar beklemek durumunda kalabilirsiniz.
    </para><para>
      Meraklısına not: Eğer <literal>struct timeval</literal> yapısındaki
      değişkeninizin alanlarınız <constant>0</constant> yaparsanız,
      <function>select()</function> işlevi anında sonlanacak ve böyle kümenizin
      içindeki tüm dosya tanımlayıcıları taramış olacaktır. Eğer
      <parameter>timeout</parameter> parametresini NULL yaparsanız bu sefer
      de işlev asla zaman aşımına uğramayacak ve ilk dosya tanımlayıcı hazır
      olana dek bekleyecektir. Son olarak: Eğer belli bir küme için beklemek
      sorun teşkil etmiyorsa o zaman <function>select()</function> işlevini
      çağırırken onu NULL olarak ayarlayabilirsiniz.
    </para><para>
      <ulink url="http://www.ecst.csuchico.edu/~beej/guide/net/examples/select.c"
      >Aşağıdaki kod parçası</ulink> standart girdiden bir veri gelmesi için
      2.5 saniye bekler:
    </para><para>
<programlisting><![CDATA[
/*
** select.c -- bir select() örneği
*/

#include <stdio.h>
#include <sys/time.h>
#include <sys/types.h>
#include <unistd.h>

#define STDIN 0  // standart girdi için dosya tanımlayıcı

int main(void)
{
    struct timeval tv;
    fd_set readfds;

    tv.tv_sec = 2;
    tv.tv_usec = 500000;

    FD_ZERO(&readfds);
    FD_SET(STDIN, &readfds);

    // writefds ve exceptfds ile ilgilenmiyoruz:
    select(STDIN+1, &readfds, NULL, NULL, &tv);

    if (FD_ISSET(STDIN, &readfds))
        printf("Bir tusa basildi!\n");
    else
        printf("Zaman doldu.\n");

    return 0;
} ]]>
</programlisting>
    </para><para>
      Üzerinde çalıştığınız uçbirim türüne bağlı olarak bir tuşa bastıktan
      sonra bunun algılanması için ENTER tuşuna basmanız gerekebilir. Aksi
      takdirde "Zaman doldu." mesajı alırsınız.
    </para><para>
      Şimdi bazılarınız bir veripaketi soketi üzerinden veri beklemek için
      bu yöntemin mükemmel bir yöntem olduğunu düşünebilir -- evet haklısınız:
      bu yötem gerçekten de mükemmel olabilir . Ancak bazı UNIX türevleri
      <literal>select</literal>'i bu şekilde kullanabilirken bazıları
      kullanamaz. Bu yüzden de pratik olarak kullanmaya başlamadan önce
      sisteminizde bu konu ile ilgili man sayfalarını okuyun.
    </para><para>
      Bazı UNIX türevleri de <literal>struct timeval</literal> yapısındaki
      değişkeninizi, zamanaşımına ne kadar süre kaldığını gösterecek şekilde
      güncelleyebilir. Bazıları ise bunu yapmaz. Eğer taşınabilir programlar
      yazmak istiyorsanız buna güvenmeyin. (<function>gettimeofday()</function>
      işlevinden faydalanın. Saçma geliyor değil mi evet ama böyle ben ne
      yapabilirim.)
    </para><para>
      Peki ya okuma kümesindeki soketlerden biri bağlantıyı kesmiş ise? Bu
      durumda <function>select()</function> bu soket için "okumaya hazır"
      mesajı verir ve siz <function>recv()</function> ile okumaya
      kalktığınızda da <function>recv()</function> size <constant>0</constant>
      değerini döndürür. Böylece istemcinin bağlantıyı kesmiş olduğunu
      anlarsınız.
    </para><para>
      Meraklısına <function>select()</function> ile ilgili bir bilgi daha: eğer
      <function>listen()</function> ile dinlemekte olan bir soketiniz varsa
      bu soketin dosya tanımlayıcısını <parameter>readfds</parameter> kümesine
      yerleştirerek yeni bir bağlantı olup olmadığını öğrenebilirsiniz.
    </para><para>
      İşte dostlarım, süper güçlü <function>select()</function> işlevinin özeti
      bu kadar.
    </para><para>
      Ancak gelen yoğun istek üzerine yukarıdaki bilgileri pratiğe dökeceğimiz
      bir örnek sizi bekliyor.
    </para><para>
      <ulink url="http://www.ecst.csuchico.edu/~beej/guide/net/examples/selectserver.c"
      >Bu program</ulink>  basit bir çok kullanıcılı "chat" sunucu olarak
      davranır. Derledikten sonra bunu bir pencerede çalıştırın ve ardından
      <command>telnet</command> ile programa bağlanın
      ("<command>telnet  hostname  9034</command>"). Farklı farklı
      pencerelerden programa aynı anda birden fazla sayıda bağlantı
      açabilirsiniz. Bir kere bağlanıp da bulunduğunuz <command>telnet</command>
      ortamından bir şeyler yazıp yolladığınızda, mesajınız diğer bağlı
      <command>telnet</command> pencerelerinde de görünmeli.
    </para><para>
<programlisting><![CDATA[
/*
** selectserver.c -- keyifli bir cok kullanicili chat sunucu
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#define PORT 9034   // dinledigimiz port

int main(void)
{
    fd_set master;    // na dosya tanimlayici listesi
    fd_set read_fds;  // select() icin gecici dosya tanimlayici listesi
    struct sockaddr_in myaddr;     // sunucu adresi
    struct sockaddr_in remoteaddr; // istemci adresi
    int fdmax;        // azami dosya tanimlayici numarası
    int listener;     // dinlenen soket tanımlayıcı
    int newfd;        // yeni accept()lenecek soket tanımlayıcı
    char buf[256];    // istemci verisi için tampon
    int nbytes;
    int yes=1;        // setsockopt() SO_REUSEADDR için, aşağıda
    int addrlen;
    int i, j;

    FD_ZERO(&master);    // ana listeyi ve gecici listeyi temizle
    FD_ZERO(&read_fds);

    // dinleyiciyi yarat
    if ((listener = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
        perror("socket");
        exit(1);
    }

    // "adres zaten kullanımda" mesajından kurtul
    if (setsockopt(listener, SOL_SOCKET, SO_REUSEADDR, &yes,
                                                        sizeof(int)) == -1) {
        perror("setsockopt");
        exit(1);
    }

    // bind
    myaddr.sin_family = AF_INET;
    myaddr.sin_addr.s_addr = INADDR_ANY;
    myaddr.sin_port = htons(PORT);
    memset(&(myaddr.sin_zero), '\0', 8);
    if (bind(listener, (struct sockaddr *)&myaddr, sizeof(myaddr)) == -1) {
        perror("bind");
        exit(1);
    }

    // listen
    if (listen(listener, 10) == -1) {
        perror("listen");
        exit(1);
    }

    // dinleyici soketi ana listeye ekle
    FD_SET(listener, &master);

    // en büyük dosya tanimlayicisi hatirla
    fdmax = listener; // so far, it's this one

    // ana döngü
    for(;;) {
        read_fds = master; // copy it
        if (select(fdmax+1, &read_fds, NULL, NULL, NULL) == -1) {
            perror("select");
            exit(1);
        }

        // mevcut baglantilari tarayip okumaya hazir olanlari tespit et
        for(i = 0; i <= fdmax; i++) {
            if (FD_ISSET(i, &read_fds)) { // bir tane yakaladik!!
                if (i == listener) {
                    // handle new connections
                    addrlen = sizeof(remoteaddr);
                    if ((newfd = accept(listener, (struct sockaddr *)&remoteaddr,
                                                             &addrlen)) == -1) {
                        perror("accept");
                    } else {
                        FD_SET(newfd, &master); // ana listeye ekle
                        if (newfd > fdmax) {    // azami miktarı güncelle
                            fdmax = newfd;
                        }
                        printf("selectserver: new connection from %s on "
                            "socket %d\n", inet_ntoa(remoteaddr.sin_addr), newfd);
                    }
                } else {
                    // istemciden gelen veri icin gerekeni yap
                    if ((nbytes = recv(i, buf, sizeof(buf), 0)) <= 0) {
                        // bir hata var ya da istemci baglantiyi kesti
                        if (nbytes == 0) {
                            // baglanti kesilmis
                            printf("selectserver: socket %d hung up\n", i);
                        } else {
                            perror("recv");
                        }
                        close(i); // bye!
                        FD_CLR(i, &master); // ana listeden cikar
                    } else {
                        // istemciden bir miktar veri geldi
                        for(j = 0; j <= fdmax; j++) {
                            // gelen veriyi herkese yolla!
                            if (FD_ISSET(j, &master)) {
                                // dinleyici ve kendimiz haric
                                if (j != listener && j != i) {
                                    if (send(j, buf, nbytes, 0) == -1) {
                                        perror("send");
                                    }
                                }
                            }
                        }
                    }
                } // O KADAR CIRKIN ki!
            }
        }
    }

    return 0;
} ]]>
</programlisting>
    </para><para>
      Lütfen dikkat edin: Yukarıdaki kod içinde iki dosya tanımlayıcı
      listem var: <parameter>master</parameter> ve <parameter>read_fds</parameter>.
      Birincisi yani, <parameter>master</parameter> o esnada bağlı olan
      tüm soket tanımlayıcılarını tutuyor ve buna ek olarak bir de
      dinleme görevini üstlenmiş olan soketi de bünyesinde barındırıyor.
    </para><para>
      <parameter>master</parameter> diye bir liste oluşturmamın sebebi
      <function>select()</function> işlevinin sizin ona verdiğiniz soket
      listesini değiştirmesi ve hangilerinin okunmaya hazır olduğunu
      gösterecek şekilde güncellemesi. <function>select()</function>
      çağrıları arasında bağlantı kümesinin bozulmamış bir kopyasına
      ihtiyacım olduğu için böyle bir şey yaptım. Yani son anda
      <parameter>master</parameter> kümesini <parameter>read_fds</parameter>
      kümesine kopyalıyor ve <function>select()</function> işlevini
      çağırıyorum.
    </para><para>
      İyi de bu aynı zamanda her yeni bağlantı talebinde bu bağlantıyı
      <parameter>master</parameter> listesine eklemem gerektiği anlamına
      gelmiyor mu? Tabii ki! Ve her bağlantı kesilmesinde de kesilen
      bağlantı ile ilgili tanımlayıcıyı da <parameter>master</parameter>
      listesinden çıkarmam gerekmiyor mu? Elbette!.
    </para><para>
      Farkında iseniz <parameter>listener</parameter> soketinin ne zaman
      hazır olduğunu kontrol ediyorum. Hazır olduğunda bu demek oluyor ki
      yeni bir bağlantı talebi var ve ben de bunu görünce bağlantıyı
      <function>accept()</function> ile kabul ediyor ve <parameter>master</parameter>
      listesine ekliyorum. Benzer şekilde bir istemci bağlantısı hazır
      olduğunda ve <function>recv()</function> işlevi <constant>0</constant>
      döndürdüğünde anlıyorum ki istemci bağlantıyı kapatmış ve bu yüzden onu
      <parameter>master</parameter> listesinden çıkarmalıyım.
    </para><para>
      Ancak eğer istemci <function>recv()</function> işlevi ile sıfırdan
      farklı bir değer döndürdüğünde de biliyorum ki okunmuş olan bir veri
      yığını var. Bu veriyi alıyorum ve sonra da <parameter>master</parameter>
      listesi üzerindeki elemanlar üzerinden tek tek dolaşıp almış olduğum
      veriyi diğer istemcilere yolluyorum.
    </para><para>
      Ve dostlarım işte size süper güçlü <function>select()</function> işlevinin
      o kadar da basit olmayan açıklaması.
    </para>
  </sect1>
<!-- ======================================================= -->
<!-- sendall -->
<!-- ======================================================= -->
  <sect1 id="bgnet_advanced-sendall">
    <title>Sorunlu <function>send()</function> Durumları</title>
    <para>
      Hatırlarsanız <xref linkend="bgnet_syscalls-sendrecv"/> bölümünde <function>send()</function>
      işlevinin sizin istediğiniz kadar veriyi bir anda gönderemeyebileceğinden
      bahsetmiştim. Tam olarak böyle yani siz ondan 512 byte göndermesini
      istersiniz ama o sadece 412 tanesini yollar. Peki geriye kalan 100
      bayta ne oldu?
    </para><para>
      Bu veriler hala bizim küçük tampon bölgemizde gönderilmeyi bekliyorlar.
      Kontrolünüz dışındaki bir takım sebeplerden ötürü işletim sistemi
      çekirdeği mevcut veriyi bir seferde göndermemeye karar verdi ve iş
      başa düştü.
    </para><para>
      Sorunu halletmek için şöyle bir işlev kullanabilirsiniz:
    </para><para>
<programlisting><![CDATA[
#include <sys/types.h>
#include <sys/socket.h>

int sendall(int s, char *buf, int *len)
{
    int total = 0;        // gönderdigimiz byte miktari
    int bytesleft = *len; // eksik kalan byte miktari
    int n;

    while(total < *len) {
        n = send(s, buf+total, bytesleft, 0);
        if (n == -1) { break; }
        total += n;
        bytesleft -= n;
    }

    *len = total; // gönderilen toplam bayt miktarı

    return n==-1?-1:0; // sorun varsa -1, işlem tamamsa 0 döner
} ]]>
</programlisting>
    </para><para>
      Bu örnekte, <parameter>s</parameter> üzerinden veriyi göndermek
      istediğimiz soketi, <parameter>buf</parameter> veriyi barındıran bellek
      bölgesini (buffer) ve <parameter>len</parameter> de tampondaki byte
      sayısını gösteren sayıya işaret eden <literal>int</literal> türünde
      bir göstergedir.
    </para><para>
      Hata durumunda işlev <constant>-1</constant> değerini döndürür (ve
      <parameter>errno</parameter> hata değişkeni de <function>send()</function>
      işlevi sayesinde gerekli hata kodunu barındırır.) Ayrıca gönderilebilmiş
      olan byte sayısı da <parameter>len</parameter> parametresinden depolanır.
      Bu sayı sizin göndermek istediğiniz sayıya eşit olacaktır (hata oluşması
      durumu haricinde). <function>sendall()</function> işlevi verinin
      tamamını yollamak için elinden geleni yapacaktır ancak bir hata ile
      karşılaşırsa size geri dönecektir.
    </para><para>
      Hemen bir örnek verelim:
    </para><para>
<programlisting><![CDATA[
char buf[10] = "Beej!";
int len;

len = strlen(buf);
if (sendall(s, buf, &len) == -1) {
    perror("sendall");
    printf("We only sent %d bytes because of the error!\n", len);
} ]]>
</programlisting>
    </para><para>
      Peki ya verinin sadece bir kısmı diğer tarafa erişebildiğinde diğer
      tarafta ne olup biter? Eğer gelen paketlerin boyu değişken ise bunları
      alan taraf bir paketin ne zaman bittiğini, diğerinin ne zaman
      başladığını nasıl anlar? Evet, gerçek dünya senaryoları insanları biraz
      düşünmeye zorlar. Büyük ihtimalle yukarıdaki problemlerle başa
      çıkabilmek için yapmanız gereken veriyi paketlemek (encapsulate)
      olacaktır (<link linkend="bgnet_theory-lowlevel">veri paketleme bölümü</link>nü
      hatırladınız mı?) Ayrıntılar için okumaya devam edin!
    </para>
  </sect1>
<!-- ======================================================= -->
<!-- sonofdataencap -->
<!-- ======================================================= -->
  <sect1 id="bgnet_advanced-sonofdataencap">
    <title>Veri Paketlemesi Hazretleri</title>
    <para>
      Veri paketlemesi de ne demek oluyor? En basit anlamına bakacak olursak
      bu şu anlama gelir: Verinin başına ya onu tanımlayan bir başlık bilgisi
      koyacaksınız ya uzunluk bilgisi ya da her ikisi birden.
    </para><para>
      Başlık deyip durduğumuz şey neye benzer? Bu tamamen size kalmış ve
      projeden projeye değişebilen bir şeydir.
    </para><para>
      Ama! Bu açıklamalar biraz havada kalmadı mı?
    </para><para>
      Tamam. Mesela çok kullanıcılı bir chat programı geliştirdiğinizi ve
      bu programın da <literal>SOCK_STREAM</literal> türünden soketler
      kullandığını var sayalım. Kullanıcılardan biri bir şey dediğinde
      sunucuya gitmesi gereken iki bilgi parçası vardır: Kim dedi ve ne dedi?
    </para><para>
      Buraya kadar güzel. "Problem ne?" diye soruyor olabilirsiniz.
    </para><para>
      Problem şu: Gelip giden mesajların uzunluğu değişken. "Ali" isimli biri
      "Selam" diyebilir ve sonra da "Veli" isimli biri "naber moruk?"
      diyebilir.
    </para><para>
      Bu durumda siz de <function>send()</function> ile gelen verileri tüm
      istemcilere yollarsınız öyle değil mi ve yolladığınız veri de şu
      şekilde olur:
    </para><para>

<screen>
A l i S e l a m V e l i N a b e r m o ru k ?
</screen>
    </para><para>
      Ve böyle sürüp gider. Peki istemci bir paketin bitip diğerinin
      başladığını nasıl anlayacak? Eğer isterseniz tüm paketlerin boyunu
      sabit yapabilirsiniz ve sonra da <function>sendall()</function>
      işlevini çağırırsınız ( <link linkend="bgnet_advanced-sendall">yukarıda bir
      örneği var</link>). Fakat bu bant genişliğini boş yere harcamak
      demektir! Yani herhalde <function>send()</function> ile sadece
      Ali'nin "Selam" demesi için 1024 byte göndermek istemeyiz değil mi?
    </para><para>
      İşte bu yüzden veriyi ufak tefek bir başlık ve paket yapısı ile
      paketleriz. Hem sunucu hem de istemci verinin nasıl paketleneceğini
      (marshal) ve bu paketin nasıl açılacağın (unmarshal) bilir. Sıkı
      durun çünkü tam da şu andan itibaren bir sunucu ile istemcinin hangi
      kurallara göre iletişim kuracağını belirleyen bir protokol
      tanımlamaya başlıyoruz!
    </para><para>
      Şimdi var sayalım ki kullanıcı adı en fazla 8 karakter boyunda
      olabiliyor ve eğer daha kısa ise geriye kalan bölge '<constant>\0</constant>'
      ile dolduruluyor. Ve sonra varsayalım ki mesaj uzunluğu değişken
      olabiliyor ve maksimum 128 karaktere izin veriyoruz. Buna göre örnek
      bir pakete bakalım:
    </para><para>
      <orderedlist>
        <listitem><para>
          <literal>len</literal> (1 byte, unsigned) -- Paketin toplam boyu,
          8 baytlık kullanıcı ismi ve chat mesajı dahil.
        </para></listitem><listitem><para>
          <literal>name</literal> (8 byte) -- Kullanıcı ismi, gerekirse sonu
          NULL ile doldurulmuş.
        </para></listitem><listitem><para>
          <literal>chatdata</literal> (<emphasis>n</emphasis>-byte) --
          Gönderilecek mesajın kendisi. En fazla 128 byte olabilir. Paket
          boyu bu verinin boyu artı 8 (kullanıcı ismi bölümünün uzunluğu)
          olarak hesaplanabilir.
        </para></listitem>
      </orderedlist>
    </para><para>
      Neden söz konusu veri alanları için sırasi ile 8 byte ve 128 byte
      sınırlarını seçtim? Tamamen keyfime kalmış, bana yeterince uzun
      göründü. Ama belki de sizin ihtiyaçlarınız için 8 byte çok az
      gelebilir ve siz de 30 byte uzunluğunda bir isim alanı
      kullanabilirsiniz. Size kalmış.
    </para><para>
      Yukarıdaki paket tanımlamasını kullanarak ilk paketimizin görüntüsü
      şuna benzeyecektir (onaltılık ve ASCII):
    </para><para>
<screen>
      0D     41 6C 69 00 00 00 00 00      53 65 6C 61 6D
  (uzunluk)  A  l  i     (dolgu)          S  e  l  a  m
</screen>
    </para><para>
      Ve ikincisi de benzer şekilde:
    </para><para>
<screen>
      13     56 65 6C 69 00 00 00 00      4E 61 62 65 72 6D 6F 72 75 6B 3F
  (uzunluk)  V  e  l  i    (dolgu)        N  a  b  e  r  m  o  r  u  k  ?
</screen>
    </para><para>
      (Uzunluk bilgisi de elbette Ağ Byte Sıralamasına uygun depolanmalıdır.
      Ancak mevcut örnekte tek bir byte olduğu için çok önemli değil. En
      genel durumda ise sakın unutmayın ki tüm ikili düzendeki tamsayılarınız
      Ağ Byte Sıralamasına göre dizilmiş olmalıdır.)
    </para><para>
      Bu veriyi yollarken güvenli bir şekilde, mesela <link linkend="bgnet_advanced-sendall"
      ><function>sendall()</function></link> gibi bir işlevle yollamalısınız.
      Böylece birçok kez <function>send()</function> işlevini çağırmış olmak
      gerekse de gittiğinden emin olabilirsiniz.
    </para><para>
      Benzer şekilde bu veriyi aldığınızda çözmek için biraz iş yapmanız
      gerekir. En genel durumda verinin ancak bir kısmının gelmiş
      olabileceğini göz önünde bulundurmalısınız (misal sadece "00 13 56 65 6C"
      size ulaşmış olabilir Veli isimli kullanıcıdan. Bu ilk parça
      gördüğünüz gibi eksiktir ve verinin tamamına erişene dek birkaç kez
      daha <function>recv()</function> işlevini çağırmanız gerekebilir.
    </para><para>
      İyi de nasıl? Paketin en başına paket uzunluğu konmuş olduğundan en baştan
      itibaren bir paketin orjinal uzunluğunu biliriz. Aynı zamanda biliriz ki
      azami paket boyu da 1+8+128 olarak hesaplanabilir yani toplam olara 137
      byte (çünkü biz böyle tanımladık).
    </para><para>
      Bu durumda yapabileceğiniz şeylerden biri iki paketi barındırabilecek
      büyüklükte bir dizi tanımlamaktır. Burası sizin çalışma diziniz olacak
      ve paketler buraya vardıkça onları buradan alıp düzenleyeceksiniz.
    </para><para>
      <function>recv()</function> işlevini her çağırışınızda gelen veriyi
      çalışma dizisine aktarırsınız ve paketin tamamlanıp tamamlanmadığına
      bakarsınız. Yani dizi içindeki byte miktarının paket boyuna eşit mi
      yoksa ondan büyük mü olduğunu kontrol edersiniz (+1 çünkü başlıktaki
      uzunluk kendisi için kullanılan 1 byte'lık uzunluğu içermez). Eğer
      tampondaki byte sayısı 1'den az ise o zaman paket tam değildir açık
      olarak. Bu durumu özel olarak ele almalısınız, çünkü bu ilk byte
      çöplüktür ve paket boyu için ona güvenemezsiniz.
    </para><para>
      Paket tamamlandığında artık onun üzerinde istediğiniz işlemi
      gerçekleştirebilirsiniz. Onu kullanabilir, çalışma dizinizden
      çıkarabilirsiniz.
    </para><para>
      Nasıl? Kafanızda evirip çevirmeye başladınız mı? Sıkı durun şimdi
      ikinci darbe geliyor: bir paketi sonuna kadar okumakla kalmayıp aynı
      esnada bir sonraki paketin de bir kısmını son <function>recv()</function>
      çağrısında okumuş olabilirsiniz. Yani çalışma bölgenizde bir tam paket
      ve bir de ardından gelen bir kısmi paket vardır! (İşte çalışma
      tamponunu biraz geniş tutun dememin sebebi bu idi. Yani iki paketi
      tutabilecek kadar -- işte şimdi o durum gerçekleşti!)
    </para><para>
      İlk paketin boyunu bildiğinize ve gelen byte'ları da takip ettiğinize
      göre bu sayıları kullanarak çalışma tamponunuzdaki baytlardan
      hangisinin ilk pakete hangisinin de kısmi pakete ait olduğunu tespit
      edebilirsiniz. Birincisi ile uğraşmayı bitirince onu çalışma dizisinden
      çıkarıp bir sonraki paketin parçasını tampon başlangıcına
      taşıyabilirsiniz ve böylece tampon da bir sonraki <function>recv()</function>
      çağrısı için hazır hale gelir.
    </para><para>
      (Bazı okuyucular belki fark etmiştir, kısmi olarak gelen ikinci paketi
      tampon başına taşımak biraz vakit alabilecek bir iştir ve program buna
      gerek duymaması için döngüsel tampon (circular buffer) kullanacak
      şekilde kodlanabilir. Maalesef döngüsel tamponla ilgili tartışma bu
      makalenin alanı dışına düşmektedir. Gerçekten merak ettiyseniz Veri
      Yapıları ile ilgili güzel bir kitap alıp ilgili bölümü okuyun)
    </para><para>
      Kolay olduğunu söylememiştim. Şey, aslında söylemiştim ve öyleydi.
      Öyledir, yani eğer pratik yapmaya başlarsanız gerisi çorap söküğü
      gibi gelecektir. Excalibur üzerine yemin ederim öyle olacağına!
    </para>
  </sect1>
</chapter> <!-- advanced -->
<!-- ======================================================= -->
<!-- reference -->
<!-- ======================================================= -->
<chapter id="bgnet_reference">
  <title>Diğer Kaynaklar</title>
  <para>
    Bu aşamaya kadar geldiniz ve daha ayrıntılı bilgi istiyorsunuz! Bütün
    bu ağ programlama konusu ile ilgili daha ayrıntılı bilgileri nereden
    edinebilirsiniz?
  </para>
<!-- ======================================================= -->
<!-- manpages -->
<!-- ======================================================= -->
  <sect1 id="bgnet_reference-manpages">
    <title>man Sayfaları</title>
    <para>
      Yeni başlayanlar aşağıdaki man sayfaları ile işe başlayabilirler:
    </para><para>
      <itemizedlist>
<listitem><para><function><ulink url="http://linux.com.hk/man/showman.cgi?manpath=/man/man3/htonl.3.inc">htonl()</ulink></function></para></listitem>
<listitem><para><function><ulink url="http://linux.com.hk/man/showman.cgi?manpath=/man/man3/htons.3.inc">htons()</ulink></function></para></listitem>
<listitem><para><function><ulink url="http://linux.com.hk/man/showman.cgi?manpath=/man/man3/ntohl.3.inc">ntohl()</ulink></function></para></listitem>
<listitem><para><function><ulink url="http://linux.com.hk/man/showman.cgi?manpath=/man/man3/ntohs.3.inc">ntohs()</ulink></function></para></listitem>
<listitem><para><function><ulink url="http://linux.com.hk/man/showman.cgi?manpath=/man/man3/inet_aton.3.inc">inet_aton()</ulink></function></para></listitem>
<listitem><para><function><ulink url="http://linux.com.hk/man/showman.cgi?manpath=/man/man3/inet_addr.3.inc">inet_addr()</ulink></function></para></listitem>
<listitem><para><function><ulink url="http://linux.com.hk/man/showman.cgi?manpath=/man/man3/inet_ntoa.3.inc">inet_ntoa()</ulink></function></para></listitem>
<listitem><para><function><ulink url="http://linux.com.hk/man/showman.cgi?manpath=/man/man2/socket.2.inc">socket()</ulink></function></para></listitem>
<listitem><para><function><ulink url="http://linux.com.hk/man/showman.cgi?manpath=/man/man7/socket.7.inc">socket options</ulink></function></para></listitem>
<listitem><para><function><ulink url="http://linux.com.hk/man/showman.cgi?manpath=/man/man2/bind.2.inc">bind()</ulink></function></para></listitem>
<listitem><para><function><ulink url="http://linux.com.hk/man/showman.cgi?manpath=/man/man2/connect.2.inc">connect()</ulink></function></para></listitem>
<listitem><para><function><ulink url="http://linux.com.hk/man/showman.cgi?manpath=/man/man2/listen.2.inc">listen()</ulink></function></para></listitem>
<listitem><para><function><ulink url="http://linux.com.hk/man/showman.cgi?manpath=/man/man2/accept.2.inc">accept()</ulink></function></para></listitem>
<listitem><para><function><ulink url="http://linux.com.hk/man/showman.cgi?manpath=/man/man2/send.2.inc">send()</ulink></function></para></listitem>
<listitem><para><function><ulink url="http://linux.com.hk/man/showman.cgi?manpath=/man/man2/recv.2.inc">recv()</ulink></function></para></listitem>
<listitem><para><function><ulink url="http://linux.com.hk/man/showman.cgi?manpath=/man/man2/sendto.2.inc">sendto()</ulink></function></para></listitem>
<listitem><para><function><ulink url="http://linux.com.hk/man/showman.cgi?manpath=/man/man2/recvfrom.2.inc">recvfrom()</ulink></function></para></listitem>
<listitem><para><function><ulink url="http://linux.com.hk/man/showman.cgi?manpath=/man/man2/close.2.inc">close()</ulink></function></para></listitem>
<listitem><para><function><ulink url="http://linux.com.hk/man/showman.cgi?manpath=/man/man2/shutdown.2.inc">shutdown()</ulink></function></para></listitem>
<listitem><para><function><ulink url="http://linux.com.hk/man/showman.cgi?manpath=/man/man2/getpeername.2.inc">getpeername()</ulink></function></para></listitem>
<listitem><para><function><ulink url="http://linux.com.hk/man/showman.cgi?manpath=/man/man2/getsockname.2.inc">getsockname()</ulink></function></para></listitem>
<listitem><para><function><ulink url="http://linux.com.hk/man/showman.cgi?manpath=/man/man3/gethostbyname.3.inc">gethostbyname()</ulink></function></para></listitem>
<listitem><para><function><ulink url="http://linux.com.hk/man/showman.cgi?manpath=/man/man3/gethostbyaddr.3.inc">gethostbyaddr()</ulink></function></para></listitem>
<listitem><para><function><ulink url="http://linux.com.hk/man/showman.cgi?manpath=/man/man3/getprotobyname.3.inc">getprotobyname()</ulink></function></para></listitem>
<listitem><para><function><ulink url="http://linux.com.hk/man/showman.cgi?manpath=/man/man2/fcntl.2.inc">fcntl()</ulink></function></para></listitem>
<listitem><para><function><ulink url="http://linux.com.hk/man/showman.cgi?manpath=/man/man2/select.2.inc">select()</ulink></function></para></listitem>
<listitem><para><function><ulink url="http://linux.com.hk/man/showman.cgi?manpath=/man/man3/perror.3.inc">perror()</ulink></function></para></listitem>
<listitem><para><function><ulink url="http://linux.com.hk/man/showman.cgi?manpath=/man/man2/gettimeofday.2.inc">gettimeofday()</ulink></function></para></listitem>
      </itemizedlist>
    </para>
  </sect1>
<!-- ======================================================= -->
<!-- books -->
<!-- ======================================================= -->

  <sect1 id="bgnet_reference-books">
    <title>Kitaplar</title>
    <para>
      Eski tarz çalışmayı, masaya kitabı koyup harıl harıl okumayı sevenler
      için aşağıdakiler harika birer yol gösterici rolü oynayacaktır.
      Amazon.com logosuna dikkat, bütün bu utanmaz ticari yaklaşımın
      sebebi şu: Siz bu link aracılığı ile ne kadar çok kitap satın
      alırsanız Amazon.com da bana o kadar çok kredi açıyor ve böylece
      ben de oradan kitap alabiliyorum. Yani eğer aşağıdaki kitaplardan
      birini satın alacaksanız neden bana da bir faydanız dokunmasın ki
      diyorum.
    </para><para>
      Ayrıca daha çok kitap demek sizin için yazacağım daha çok sayıda
      programlama rehberi demek. <literal>;-)</literal>
    </para><inlinemediaobject>
      <imageobject>
        <imagedata fileref="home-logo-130x60w.gif"/>
      </imageobject>
      <caption>In Association with Amazon.com</caption>
    </inlinemediaobject><para>
      <emphasis>Unix Network Programming, volumes 1-2</emphasis> W. Richard
      Stevens.  Prentice Hall tarafından yayınlandı. ISBN'ler, 1-2 için:
      <ulink url="http://www.amazon.com/exec/obidos/ASIN/013490012X/beejsguides-20">013490012X</ulink>,
      <ulink url="http://www.amazon.com/exec/obidos/ASIN/0130810819/beejsguides-20">0130810819</ulink>.
    </para><para>
      <emphasis>Internetworking with TCP/IP, volumes I-III</emphasis>
      Douglas E. Comer ve David L. Stevens.  Prentice Hall tarafından
      yayınlandı.ISBN'ler, I, II ve III için:
      <ulink url="http://www.amazon.com/exec/obidos/ASIN/0130183806/beejsguides-20">0130183806</ulink>,
      <ulink url="http://www.amazon.com/exec/obidos/ASIN/0139738436/beejsguides-20">0139738436</ulink>,
      <ulink url="http://www.amazon.com/exec/obidos/ASIN/0138487146/beejsguides-20">0138487146</ulink>.
    </para><para>
      <emphasis>TCP/IP Illustrated, volumes 1-3</emphasis> W. Richard Stevens
      ve Gary R. Wright. Addison Wesley tarafından yayınlandı. ISBN'ler
      1, 2 ve 3 için:
      <ulink url="http://www.amazon.com/exec/obidos/ASIN/0201633469/beejsguides-20">0201633469</ulink>,
      <ulink url="http://www.amazon.com/exec/obidos/ASIN/020163354X/beejsguides-20">020163354X</ulink>,
      <ulink url="http://www.amazon.com/exec/obidos/ASIN/0201634953/beejsguides-20">0201634953</ulink>.
    </para><para>
      <emphasis>TCP/IP Network Administration</emphasis> Craig Hunt.O'Reilly &amp;
      Associates, Inc. tarafından yayınlandı. ISBN
      <ulink url="http://www.amazon.com/exec/obidos/ASIN/1565923227/beejsguides-20">1565923227</ulink>.
    </para><para>
      <emphasis>Advanced Programming in the UNIX Environment</emphasis>  W.
      Richard Stevens.  Addison Wesley tarafından yayınlandı. ISBN
      <ulink url="http://www.amazon.com/exec/obidos/ASIN/0201563177/beejsguides-20">0201563177</ulink>.
    </para><para>
      <emphasis>Using C on the UNIX System</emphasis> David A. Curry. O'Reilly
      &amp; Associates, Inc.  tarafından yayınlandı. ISBN 0937175234.
      <emphasis>Tükendi.</emphasis>
    </para>
  </sect1>
<!-- ======================================================= -->
<!-- webref -->
<!-- ======================================================= -->
  <sect1 id="bgnet_reference-webref">
    <title>Kaynaklar</title>
    <para>Genel Ağdakiler:</para>
    <para>
      <emphasis>BSD Sockets: A Quick And Dirty Primer</emphasis> (Unix sistem programlama ile ilgili diğer konularda da ciddi bilgi içeriyor!)<sbr /> [<literal>http://www.cs.umn.edu/~bentlema/unix/</literal>] (adres geçersiz)
    </para><para>
      <emphasis>The Unix Socket FAQ</emphasis><sbr />
      [<literal>http://www.ibrado.com/sock-faq/</literal>] (adres geçersiz)
    </para><para>
      <emphasis>Client-Server Computing</emphasis><sbr />
      [<literal>http://pandonia.canberra.edu.au/ClientServer/</literal>] (adres geçersiz)
    </para><para>
      <emphasis>Intro to TCP/IP</emphasis> (gopher)<sbr />
      [<literal>gopher://gopher-chem.ucdavis.edu/11/Index/Internet_aw/Intro_the_Internet/intro.to.ip/</literal>] (adres geçersiz)
    </para><para>
      <ulink url="http://www.faqs.org/faqs/internet/tcp-ip/tcp-ip-faq/part1/">TCP/IP FAQ; Frequently Asked Questions</ulink>
    </para><para>
      <emphasis><ulink url="http://tangentsoft.net/wskfaq/">The Winsock
      FAQ</ulink></emphasis>
    </para>
  </sect1>
<!-- ======================================================= -->
<!-- rfcs -->
<!-- ======================================================= -->
  <sect1 id="bgnet_reference-rfcs">
    <title>RFC'ler</title>
    <para>
      <ulink url="http://www.rfc-editor.org/">RFC'ler</ulink>:
    </para><para>
      <emphasis><ulink url="http://www.rfc-editor.org/rfc/rfc768.txt"
      >RFC-768</ulink></emphasis> -- The User Datagram Protocol (UDP)
    </para><para>
      <emphasis><ulink url="http://www.rfc-editor.org/rfc/rfc791.txt"
      >RFC-791</ulink></emphasis> -- The Internet Protocol (IP)
    </para><para>
      <emphasis><ulink url="http://www.rfc-editor.org/rfc/rfc793.txt"
      >RFC-793</ulink></emphasis> -- The Transmission Control Protocol (TCP)
    </para><para>
      <emphasis><ulink url="http://www.rfc-editor.org/rfc/rfc854.txt"
      >RFC-854</ulink></emphasis> -- The Telnet Protocol
    </para><para>
      <emphasis><ulink url="http://www.rfc-editor.org/rfc/rfc951.txt"
      >RFC-951</ulink></emphasis> -- The Bootstrap Protocol (BOOTP)
    </para><para>
      <emphasis><ulink url="http://www.rfc-editor.org/rfc/rfc1350.txt"
      >RFC-1350</ulink></emphasis> -- The Trivial File Transfer Protocol (TFTP)
    </para>
  </sect1>
</chapter> <!-- reference -->
<!-- ======================================================= -->
<!-- faq -->
<!-- ======================================================= -->
<chapter id="bgnet_faq">
  <title>Sıkça Sorulan Sorular</title>
  <qandaset defaultlabel="qanda">
    <qandaentry>
      <question><para>
        Şu başlık dosyalarını nereden edinebilirim?
      </para></question><answer><para>
        Eğer sisteminizde bunlar mevcut değilse, muhtemelen zaten
        ihtiyacınız olmadığı içindir. Üzerinde çalıştığınız platformun
        belgelerini inceleyin. Eğer MS Windows ortamında derlemeye
        çalışıyor iseniz tek ihtiyacınız olan
        <literal>#include &lt;winsock.h&gt;</literal>.
      </para></answer>
    </qandaentry><qandaentry>
      <question><para>
        <function>bind()</function> "Address already in use" veya
        "Adres zaten kullanımda" mesajı verdiğinde ne yapmalıyım?
      </para></question><answer><para>
        Dinleyici soketler üzerinde <function>setsockopt()</function>
        ile birlikte <constant>SO_REUSEADDR</constant> seçeneğini
        kullanmalısınız. <link linkend="bgnet_syscalls-bind">bind() ile
        ilgili bölümü</link> ve <link linkend="bgnet_advanced-select">select() ile
        ilgili bölümü</link> okuyup örnekleri inceleyin.
      </para></answer>
    </qandaentry><qandaentry>
      <question><para>
        Sistemdeki açık soketlerin listesini nasıl alabilirim?
      </para></question><answer><para>
        <command>netstat</command> komutunu kullanın. Bu komutla ilgili
        ayrıntılar için ilgili man sayfasını okuyun. Basit bir örnek
        vermem gerekirse sadece:
      </para><para>
<screen>
<prompt>$</prompt> <userinput>netstat</userinput>
</screen>
      </para><para>
        yazarak bile epey mantıklı bir çıktı alabilirsiniz. Buradaki asıl
        mesele hangi soketin hangi program ile ilişkili olduğunu
        bulmak<footnote><para>Ç.N.: <command>lsof</command> komutu bu
        konuda size yardımcı olabilir, ayrıntılar için man sayfasına bakın.
        <literal>:-)</literal></para></footnote>.
      </para></answer>
    </qandaentry><qandaentry>
      <question><para>
        Yönlendirme tablosunu nasıl görüntüleyebilirim?
      </para></question><answer><para>
        Kısaca: <command>route</command> komutunu çalıştırın
        (Linux için bu komutun yeri genellikle <filename>/sbin</filename>
        dizinidir) veya <command>netstat -r</command> komutunu deneyin.
      </para></answer>
    </qandaentry><qandaentry>
      <question><para>
        Eğer tek bir bilgisayarım varsa istemci-sunucu türünde programları
        nasıl çalıştırabilirim? Bir ağ programı yazabilmek için bir ağa
        ihtiyacım yok mu?
      </para></question><answer><para>
        Şanslısınız çünkü hemen hemen tüm işletim sistemleri bir tür
        geridönüş (loopback) aygıtı denilen sanal bir ağ aygıtı kullanır.
        Bu aygıt işletim sistemi çekirdeğine gömülü bir mekanizmadır ve
        tıpkı fiziksel bir ağ kartı gibi davranır böylece aynı makinada
        hem sunucu hem de istemci yazılımlar çalışabilir.
        (Bu sanal aygıt yönlendirme tablosunda "<literal>lo</literal>"
        olarak listelenir.)
      </para><para>
        Bir örnek vermek gerekirse "<literal>goat</literal>" isimli bir
        bilgisayara giriş yaptığınızı varsayalım. Bir pencerede istemciyi
        diğerinde de suncuyu çalıştırabilirsiniz. Ya da sunucuyu şuna
        benzer bir komut ile arka planda çalıştırın:
        "<command>server &amp;</command>" ve sonra aynı yerde istemciyi
        çalıştırın. Geridönüş aygıtı dediğimiz sanal aygıt sisteminizde
        mevcut ise (%99.9 olasılıkla mevcuttur) <command>client goat</command>
        veya <command>client goat</command> gibi bir komutla
        ("<literal>localhost</literal>"un sizdeki <filename>/etc/hosts</filename>
        dosyasında tanımlı olduğunu varsayıyorum) istemci yazılımın sunucu
        yazılım ile aynı makina üzerinde konuştuğunu gözlemleyebilirsiniz.
        Bir ağa ihtiyaç duymadan!
      </para><para>
        Kısaca söylemek gerekirse ağa bağlı olmayan bir bilgisayarda
        yukarıda verilmiş olan örnek kodları çalıştırabilmek için
        herhangi bir değişiklik yapmanıza gerek yoktur. Yaşasınnn!
      </para></answer>
    </qandaentry><qandaentry>
      <question><para>
        Diğer tarafın bağlantıyı kestiğini nasıl tespit edebilirim?
      </para></question><answer><para>
        <function>recv()</function> işlevi öyle bir durumda <constant>0</constant>
        değerini döndürür.
      </para></answer>
    </qandaentry><qandaentry>
      <question><para>
        Kendi "ping" programımı nasıl yazabilirim? ICMP nedir?
        Raw soketler ve <constant>SOCK_RAW</constant> ile daha ayrıntılı
        bilgiyi nerede bulabilirim?
      </para></question><answer><para>
        Raw soketler ile ilgili tüm sorularınızın cevabını W. Richard Stevens'ın
        "UNIX Network Programming" kitaplarında bulabilirsiniz. Lütfen
        kılavuzun <link linkend="bgnet_reference-books">kitaplar</link> bölümüne bakın.
      </para></answer>
    </qandaentry><qandaentry>
  <question><para>
    Bu programları MS Windows üzerinde nasıl derlerim?
  </para></question><answer><para>
    En basit yöntem şu: MS Windows'u silin ve Linux ya da BSD işletim
    sistemini kurun. <literal>};-)</literal> Peki peki tamam, o kadar
    ısrarcı iseniz <xref linkend="bgnet_intro-windows"/> bölümüne bakın.
  </para></answer>
</qandaentry><qandaentry>
  <question><para>
     Bu programları Solaris/SunOS üzerinde nasıl derlerim?
     Derlemeye çalıştığımda linker sürekli hata veriyor!
   </para></question><answer><para>
      Linker hatası alabilirsiniz, çünkü genellikle Sun Microsystems
      ortamında soket kitaplıkları otomatik olarak bağlanmaz.
      Ayrıntılı bilgi için <xref linkend="bgnet_intro-solaris"/> bölümüne bakın.
    </para></answer>
  </qandaentry><qandaentry>
    <question><para>
      <function>select()</function> neden sinyal alır almaz düşüyor?
    </para></question><answer><para>
      Sinyaller genellikle bloklu sistem çağrılarının <constant>-1</constant>
      değerini döndürmesine ve <parameter>errno</parameter> değişkeninin de
      <constant>EINTR</constant> değerini almasına yol açar. Sinyal
      işlevi <function>sigaction()</function> ile ayarladığınızda,
      <constant>SA_RESTART</constant> kullanabilirsiniz. Böylece sistem
      çağrısı kesildiğinde onu yeniden başlatabilme ihtimali olur.
    </para><para>
      Doğal olarak bu her zaman işe yaramaz.
    </para><para>
      Bunun için önereceğim en iyi çözüm bir <literal>goto</literal>
      deyimine dayanır. Bildiğiniz gibi bu size yapısal programlama
      dersi veren profesörün tüylerinin diken diken olmasına yeter de
      artar bile, o halde neden kullanmayasınız!
    </para><para>
<programlisting><![CDATA[
select_restart:
    if ((err = select(fdmax+1, &readfds, NULL, NULL, NULL)) == -1) {
        if (errno == EINTR) {
            // bir sinyal kesildi o halde yeniden baslat
            goto select_restart;
        }
        // gerçek hata ile burada ugras:
        perror("select");
    } ]]>
</programlisting>
    </para><para>
      Tabii ki burada <literal>goto</literal> kullanmanız <emphasis>şart
      değil</emphasis>; kontrol için başka yapıları da kullanabilirsiniz,
      ancak ben özel olarak bu iş için <literal>goto</literal> deyiminin
      daha temiz olduğunu düşünüyorum.
    </para></answer>
  </qandaentry><qandaentry>
    <question><para>
      <function>recv()</function> işlevi için bir zamanaşımı mekanizmasını
      nasıl kurabilirim?
    </para></question><answer><para>
      <link linkend="bgnet_advanced-select"><function>select()</function></link> işlevini
      kullanın! Bu işlev okuyacağınız soket tanımlayıcıları için bir
      zamanaşımı parametresi belirlemenize izin verir. Ya da bu işlevselliğin
      tamamını tek bir işlev içine şu şekilde gömmelisiniz:
    </para><para>
<programlisting><![CDATA[
#include <unistd.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/socket.h>

int recvtimeout(int s, char *buf, int len, int timeout)
{
    fd_set fds;
    int n;
    struct timeval tv;

    // dosya tanımlayıcı listesini ayarla
    FD_ZERO(&fds);
    FD_SET(s, &fds);

    // zamanaşımı için struct timeval türündeki değişkeni ayarla
    tv.tv_sec = timeout;
    tv.tv_usec = 0;

    // veri gelene veya zamanaşımı dolana dek bekle
    n = select(s+1, &fds, NULL, NULL, &tv);
    if (n == 0) return -2; // zamanaşımı!
    if (n == -1) return -1; // hata

    // veri burada olmalı, o halde normal şekilde recv() çağır
    return recv(s, buf, len, 0);
}

// recvtimeout() örneği:
    .
    .
    n = recvtimeout(s, buf, sizeof(buf), 10); // zamanaşımı 10 saniye

    if (n == -1) {
        // hata olustu
        perror("recvtimeout");
    }
    else if (n == -2) {
        // zamanaşımı!
    } else {
        // buf içine veri geldi
    }
    .
    . ]]>
</programlisting>
    </para><para>
      <note><title>Dikkat edin</title>
        <para>
          <function>recvtimeout()</function> işlevi zamanaşımı durumunda
          <constant>-2</constant> değerini döndürür. Neden <constant>0</constant>
          değil? Hatırlayacak olursanız <constant>0</constant> değeri
          <function>recv()</function> işlevi söz konusu olduğunda karşı
          tarafın bağlantıyı kestiği anlamına geliyordu. Bu değer
          kullanılmış olduğu için ve <constant>-1</constant> de hata
          anlamına geldiğinden zamanaşımı durumunu göstermesi için
          <constant>-2</constant> değerini seçtim.
        </para>
      </note></para></answer>
    </qandaentry><qandaentry>
      <question><para>
        Veriyi soket üzerinden göndermeden önce nasıl şifreleyip sıkıştırabilirim?
      </para></question><answer><para>
        Şifrelemeyi gerçekleştirmenin kolay yollarından biri SSL
        (secure sockets layer - güvenlik soketleri katmanı) kullanmaktır
        ancak bu konu bu kılavuzun kapsamı dışındadır.
      </para><para>
        Ancak eğer sıkıştırma ve şifreleme algoritmalarınızı kullanmak
        istiyorsanız verinin her iki uçta da adım adım işlendiğini
        düşünmek işinizi kolaylaştıracaktır. Her adım veriyi belli bir
        şekilde dönüştürür.
      </para><para>
        <orderedlist>
          <listitem>sunucu veriyi bir dosyadan (veya bir yerlerden) okur,</listitem>
          <listitem>sunucu veriyi şifreler (bu kısmı siz ekleyeceksiniz),</listitem>
          <listitem>sunucu şifrelenmiş veriyi <function>send()</function> ile yollar.</listitem>
        </orderedlist>
      </para><para>Şimdi de öteki tarafa bakalım:</para><para>
        <orderedlist continuation="continues">
          <listitem>
            istemci <function>recv()</function> ile kendisine yollanan
            şifreli veriyi alır,
          </listitem><listitem>
            istemci şifreli veriyi çözer yani deşifre eder (bu kısmı siz
            ekleyeceksiniz).
          </listitem>
        </orderedlist>
      </para><para>
        Yukarıda şifreleme/deşifreleme yaptığınız aşamada sıkıştırma/açma
        işlemleri de yapabilirsiniz. Ya da hem şifreleme hem de sıkıştırma
        yapabilirsiniz! Yalnız aklınızda bulunsun, bir veriyi eğer
        şifreleyecekseniz önce sıkıştırın sonra şifreleyin<footnote><para>
        Ç.N.: Yazarın burada tek bir cümle olarak söyleyip geçtiği şey
        güvenlik açısından göründüğünden çok daha fazla önemlidir,
        kullanacağınız şifreleme algoritmasına çok dikkat edin ve
        <command>mutlaka şifrelemeden önce sıkıştırma işlemini
        uygulayın.</command></para></footnote>  <literal>:)</literal>
      </para><para>
        Yani istemci, sunucunun uyguladığı dönüşümlerin tersini
        uygulayabildiği sürece araya istediğiniz kadar dönüşüm, işlem,
        işlev, vs. sokabilirsiniz.
      </para><para>
        Tek yapmanız gereken verdiğim örnek kodda verinin gönderildiği
        ve alındığı kısımları tespit bunların öncesine şifreleme
        işlemini yerleştirmek.
      </para></answer>
    </qandaentry><qandaentry>
      <question><para>
        Bir sürü yerde gördüğüm şu "<constant>PF_INET</constant>" de nedir?
        <constant>AF_INET</constant> ile bir bağlantısı var mıdır?
      </para></question><answer><para>
        Evet, elbette. Bunun için lütfen <xref linkend="bgnet_syscalls-socket"/>
        bölümüne bakın.
      </para></answer>
    </qandaentry><qandaentry>
      <question><para>
        İstemciden kabuk komutlarını kabul edip onları çalıştıran bir
        sunucu yazılımını nasıl geliştirebilirim?
      </para></question><answer><para>
        Basit olsun diye varsayalım ki istemci <function>connect()</function>
        ile bağlanıyor, <function>send()</function> ile veriyi gönderiyor ve
        <function>close()</function> ile bağlantıyı kesiyor (yani istemci
        tekrar bağlanana dek bir sistem çağrısı söz konusu olmuyor).
      </para><para>İstemcinin izlediği süreç şöyledir:</para><para>
        <orderedlist>
          <listitem><function>connect()</function> ile sunucuya bağlan,</listitem>
          <listitem><function>send("/sbin/ls &gt; /tmp/client.out"),</function></listitem>
          <listitem><function>close()</function> ile bağlantıyı kes.</listitem>
        </orderedlist>
      </para><para>
        Bu arada sunucu gelen veri ile muhatap olur ve onu çalıştırır:
      </para><para>
        <orderedlist>
          <listitem><function>accept()</function> ile bağlantıyı kabul et,</listitem>
          <listitem><function>recv(str)</function>  ile komut dizisini al,</listitem>
          <listitem><function>close()</function> ile bağlantıyı kes,</listitem>
          <listitem><function>system(komut)</function> ile komutu çalıştır.</listitem>
        </orderedlist>
      </para><para>
        <caution><para>
          İstemcinin sunucuya ne yapacağını söylemesi uzaktan kabuk erişimi vermek
          demektir. Böyle bir yetkiye sahip olan bir insan kötü şeyler yapabilir.
          Mesela yukarıdaki gibi bir programda istemci
          "<command>rm -rf ~</command>" gibi bir komut gönderirse ne olur?
          Sizinle ilişkili alandakı tüm dosyalar silinir, işte budur
          olacağı!
        </para></caution>
      </para><para>
        Bu yüzden akıllı olun ve kesinlikle güvenli olduğunuz programlar
        haricinde uzaktaki istemcinin sizin sunucunuzda hiçbir şey
        çalıştırmasına izin vermeyin, örneğin <command>foobar</command>
        komutu gibi:
      </para><para>
<programlisting><![CDATA[
if (!strcmp(str, "foobar")) {
    sprintf(sysstr, "%s > /tmp/server.out", str);
    system(sysstr);
} ]]>
</programlisting>
      </para><para>
         <command>foobar</command> güvenilir ve sorunsuz bir komut
         olabilir ama gene de şüpheci olmalısınız ya istemci
         "<command>foobar; rm -rf ~</command>" gibi bir komut dizisi
         yollarsa? En güvenli yöntemlerden biri komuta verilen
         parametrelerdeki alfanümerik olmayan her karakterin (boşluk
         dahil) başına önceleme karakteri ("<constant>\</constant>")
         koyan bir işlev yazmaktır.
       </para><para>
         Gördüğünüz gibi sunucu tarafında istemcinin gönderdiği komutları
         çalıştırma gibi bir durum söz konusu olunca güvenlik çok önemli
         bir mesele haline gelmektedir.
       </para></answer>
     </qandaentry><qandaentry>
       <question><para>
         Bir yığın veriyi bir seferde yollamaya çalışıyorum ama diğer
         taraftan <function>recv()</function> ile okumaya kalktığımda
         sadece 536 veya 1460 byte geldiğini görüyorum. Ancak aynı
         denemeyi kendi makinamın üzerinde iki farklı pencere açıp
         yaptığımda sorunsuz olarak veri yollayıp alabiliyorum.
         Bunun sebebi nedir?
       </para></question><answer><para>
         MTU sınırını -- fiziksel ortamın bir seferde kaldırabileceği
         azami yük miktarını aşıyorsunuz. Makinanızdaki sanal geridönüş
         aygıtı sürücüsü 8K ya da daha fazlasını bir seferde sorunsuz
         olarak iletebilir. Ancak Ethernet bir seferde başlık bilgisi ile
         birlikte en fazla 1500 byte taşıyabilir ve siz de bu limiti
         aşmış durumdasınız. Modem üzerinden veri yollamaya kalktığınızda
         576 byte sınırı vardır ve yine bunu tek seferde geçerseniz
         sorun yaşarsınız.
       </para><para>
         Öncelikli olarak tüm veriyi yolladığınızdan emin olmalısınız.
         (Bunun için lütfen
         <link linkend="bgnet_advanced-sendall"><function>sendall()</function></link>
         ile ilgili ayrıntılı açıklamalara bakın.) Bundan eminseniz buna
         ek olarak verinin tamamını okuyana dek bir döngü içinde
         <function>recv()</function> işlevini çağırmanız gerekir.
       </para><para>
         <function>recv()</function> işlevini defalarca çağırarak verinin
         tamamını alma ile ilgili ayrıntılı açıklamalar için lütfen
         <xref linkend="bgnet_advanced-sonofdataencap"/> bölümünü okuyun.
       </para></answer>
     </qandaentry><qandaentry>
       <question><para>
         Bilgisayarımda MS Windows çalışıyor ve elimde <function>fork()</function>
         gibi bir sistem çağrısı olmadığı gibi <literal>struct sigaction</literal>
         şeklinde bir yapı da yok. Ne yapabilirim?
       </para></question><answer><para>
         Eğer varsalar POSIX kitaplıkları içindedirler ve bunlar da
         derleyiciniz ile gelmiş olabilir. Ben Windows kullanmıyorum bu
         yüzden size kesin cevap veremeyeceğim. Fakat hatırladığım kadarı
         ile Microsoft'un da kullandığı bir POSIX uyumluluk katmanı vardı
         ve işte aradığınız <function>fork()</function> olsa olsa oradadır.
         (Hatta belki <literal>sigaction</literal> bile.)
       </para><para>
         VC++ ile gelen belgeleri "fork" veya "POSIX" için bir tarayın ve
         size hangi ipuçlarını verdiğine bir bakın.
       </para><para>
         Eğer mantıklı bir şey çıkamazsa <function>fork()</function>/<literal>sigaction</literal>
         ikilisini bırakın ve şunu deneyin: <function>CreateProcess()</function>.
         Açıkçası ben <function>CreateProcess()</function> işlevi tam olarak
         nasıl kullanılır bilmiyorum -- milyarlarca argüman alıyor olmalı ama
         VC++ belgelerinde hepsi açıklanıyor olmalı.
       </para></answer>
     </qandaentry><qandaentry>
       <question><para>
         TCP/IP üzerinde veriyi güvenli ve şifreli bir şekilde nasıl
         iletebilirim?
       </para></question><answer><para>
         <ulink url="http://www.openssl.org/">OpenSSL projesi</ulink>ne
         bir göz atın.
       </para></answer>
     </qandaentry><qandaentry>
       <question><para>
         Bir güvenlik duvarının arkasındayım -- diğer taraftaki insanların
         benim IP adresimi öğrenip benim sistemime bağlanmalarını nasıl
         sağlarım?
       </para></question><answer><para>
         Maalesef bir güvenlik duvarının amacı tam da dışarıdaki
         insanların doğrudan sizim makinanıza bağlanmasını engellemektir.
         Bu şekilde içeri bağlanmaları çoğu durumda bir güvenlik açığı
         olarak kabul edilir.
       </para><para>
         Bu tabii ki talebinizin imkânsız olduğu anlamına gelmez yani
         gene de güvenlik duvarı üzerinde <function>connect()</function>
         yapabilirsiniz tabii bir "maskeleme" ya da "NAT" veya benzer
         bir şey söz konusu ise. Programlarınızı daima bağlantıyı sizin
         başlatacağınız şekilde tasarlayın, böylece işiniz kolay olur.
       </para><para>
         Eğer bu sizi tatmin etmiyorsa sistem yöneticilerinize size özel
         bir delik açmalarını söyleyebilirsiniz. Güvenlik duvarı,
         üzerindeki NAT yazılımı ile ya da vekil tarzı bir şey ile bunu
         gerçekleştirebilir.
       </para><para>
         Ancak lütfen unutmayın ki güvenlik duvarı üzerindeki bir delik
         hafife alınabilecek bir durum değildir. Kötü niyetli kişilere
         erişim hakkı vermediğinizden emin olmalısınız. Eğer bu konularda
         henüz acemiyseniz bana inanın ki güvenli programlar yazmak hayal
         edebileceğinizden çok daha zordur.
       </para><para>
         Sistem yöneticilerinizin benden nefret etmesine yol açmayın.
         <literal>;-)</literal>
       </para></answer>
     </qandaentry>
   </qandaset>
  </chapter> <!-- faq -->
<!-- ======================================================= -->
<!-- conclusion -->
<!-- ======================================================= -->
  <chapter id="bgnet_conclusion">
    <title>Son söz ve Yardım Çağrısı</title>
    <para>
      Evet hepsi bu kadar. Umuyorum ki burada verilen bilgilerin en azından
      bir bölümü sizin için geçerlidir ve çok büyük hatalar yapmamışımdır.
      Aslında, eminim hata yapmışımdır.
    </para><para>
      Bunu bir uyarı kabul edin! Eğer bazı şeyleri net olarak aktaramayıp
      ya da tam olarak sizin sisteminize bire bir uyan örnekler veremeyip
      sizi üzdüysem özür dilerim ama bu yüzden beni suçlayamazsınız. Yani
      hukuki olarak bu belgedeki sözlerimin arkasında durduğum falan yok,
      çok ciddiyim. Yani bütün burada yazılanlar, tamamı, her bir sözcük,
      yanlış olabilir!
    </para><para>
      Fakat muhtemelen o kadar da yanlış değiller. Yani her şey bir yana şu
      ağ programlama mevzusu üzerine epey bir emek harcadığımı söyleyebilirim.
      Ofiste pek çok TCP/IP uygulaması geliştirdim, çok oyunculu oyun
      motorları yazdım, vs. Ancak gene de bir soket programlama tanrısı
      sayılmam. Sıradan bir adam olduğum bile söylenebilir.
    </para><para>
      Bu arada eğer yapıcı (ya da yıkıcı) herhangi bir eleştirisi olan
      varsa lütfen şu adrese e-mail göndersin ki ben de gerekeni yapayım:
      <email>beej@piratehaven.org</email>.
    </para><para>
      Bütün bunları neden yaptığımı merak ediyor musunuz? Hepsini para
      için yaptım. Ha ha! Hayır, hayır yani asıl sebep şu: pek çok kişi
      bana soket programlama ile ilgili bir sürü soru sorup duruyordu ve
      ben de onlara tüm cevapları tek bir belgede toplamayı düşündüğümü
      söylediğimde bana "Harika!" diyorlardı. Ayrıca zorluklarla elde
      edilmiş bu bilgi başkaları ile paylaşılmazsa bence heba olur.
      Internet bunun için en uygun araç gibi görünüyor. Herkesi benzer
      şekilde bilgi paylaşımına davet ediyorum.
    </para><para>
      Bu kadar laf salatası yeter -- şimdi biraz program yazmalıyı(m|z)!
      <literal>;-)</literal>
    </para>
  </chapter> <!-- conclusion -->
</book>
