<?xml version="1.0" encoding="UTF-8"?>
<!-- ********************************************************************
     $Id: regex.xml,v 1.12 2002/12/20 23:23:58 nilgun Exp $
     ********************************************************************-->
<book xml:id="regexinfo">
<?dbhtml dir="../regex"?>
  <bookinfo>
   <title>Regex Kütüphanesi Başvuru Kılavuzu</title>
   <author role="translator">
     <firstname>Yalçın Kolukısa</firstname>
   </author>
   <date>Kasım 2003</date>
   <abstract>
     <para>
Bu belge <filename>regex-0.12</filename> paketiyle (1993  yılında bağımsız geliştirilmesi durdurulmuş ve GNU C kütüphanesine dahil edilmiştir) dağıtılmış  olan  Regex Kütüphanesi Başvuru Kılavuzunun çevirisidir. GNU C Kılavuzunda Regex oluşumları ile ilgili bilgiler bu belgedeki kadar ayrıntılı değildir. Bu nedenle, bu belge GNU C Kütüphanesi Başvuru Kılavuzunun tamamlayıcısı olarak ele alınmalıdır.
     </para>
   </abstract>
    <legalnotice>
      <title>Legal Notice</title>
      <para>
        Copyright © 1992-2005 Free Software Foundation, Inc.
      </para><para>
        Permission is granted to make and distribute verbatim copies of this
        manual provided the copyright notice and this permission notice are
        preserved on all copies.
      </para><para>
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2 or
any later version published by the Free Software Foundation; with no
Invariant Sections, with the Front-Cover texts being "A GNU Manual,"
and with the Back-Cover Texts as in (a) below.  A copy of the license is
included in the section entitled "GNU Free Documentation License."
      </para><para>
(a) The FSF's Back-Cover Text is: "You have freedom to copy and modify
this GNU Manual, like GNU software.  Copies published by the Free
Software Foundation raise funds for GNU development."
      </para>
    </legalnotice>
    <legalnotice>
      <title>Yasal Uyarı</title>
      <para>
        Telif hakkı © 1992-2005 Free Software Foundation, Inc.
      </para><para>
        Bu kılavuzun harfi harfine kopyalanmasına ve dağıtılmasına telif hakkı
        uyarısının ve bu izin uyarısının tüm kopyalarında bulunması şartıyla
        izin verilmiştir.
      </para><para>
Bu belgeyi; Free Software Foundation tarafından yayınlanmış olan GNU Özgür Belgelendirme Lisansının 1.2 veya daha sonraki bir sürümüne sadık kalmak koşulu ile kopyalayabilir, dağıtabilir veya düzenleyebilirsiniz: değişmez bölümler yoktur, ön-kapak yazısı olarak "A GNU Manual" ile aşağıdaki (a) şıkkındaki arka-kapak yazısı bulunmalıdır. Bu Lisansın bir kopyasını <xref linkend="regexinfo_gfdl"/> başlıklı bölümde bulabilirsiniz.
      </para><para>
(a) FSF'nin Arka-Kapak Metni: "You have freedom to copy and modify
this GNU Manual, like GNU software.  Copies published by the Free
Software Foundation raise funds for GNU development."
      </para>
    </legalnotice>
    <legalnotice>
      <title>Feragatname</title>
      <para>
        Belge içeriğindeki bilgileri uygulama sorumluluğu uygulayana aittir.
      </para><para>
BU KİTAP ÜCRETSİZ OLARAK RUHSATLANDIĞI İÇİN, İÇERDİĞİ BİLGİLER İÇİN İLGİLİ KANUNLARINİ İZİN VERDİĞİ ÖLÇÜDE HERHANGİ BİR GARANTİ VERİLMEMEKTEDİR. AKSİ YAZILI OLARAK BELİRTİLMEDİĞİ MÜDDETÇE TELİF HAKKI SAHİPLERİ VE/VEYA BAŞKA ŞAHISLAR KİTABI "OLDUĞU GİBİ", AŞİKAR VEYA ZIMNEN, SATILABİLİRLİĞİ VEYA HERHANGİ BİR AMACA UYGUNLUĞU DA DAHİL OLMAK ÜZERE HİÇBİR GARANTİ VERMEKSİZİN DAĞITMAKTADIRLAR. BİLGİNİN KALİTESİ  İLE İLGİLİ TÜM SORUNLAR SİZE AİTTİR. HERHANGİ BİR HATALI BİLGİDEN DOLAYI DOĞABİLECEK OLAN BÜTÜN SERVİS, TAMİR VEYA DÜZELTME MASRAFLARI SİZE AİTTİR.
      </para><para>
İLGİLİ KANUNUN İCBAR ETTİĞİ DURUMLAR VEYA YAZILI ANLAŞMA HARİCİNDE HERHANGİ BİR ŞEKİLDE TELİF HAKKI SAHİBİ VEYA YUKARIDA İZİN VERİLDİĞİ ŞEKİLDE KİTABI DEĞİŞTİREN VEYA YENİDEN DAĞITAN HERHANGİ BİR KİŞİ, BİLGİNİN KULLANIMI VEYA KULLANILAMAMASI (VEYA VERİ KAYBI OLUŞMASI, VERİNİN YANLIŞ HALE GELMESİ, SİZİN VEYA ÜÇÜNCÜ ŞAHISLARIN ZARARA UĞRAMASI VEYA BİLGİLERİN BAŞKA BİLGİLERLE UYUMSUZ OLMASI) YÜZÜNDEN OLUŞAN GENEL, ÖZEL, DOĞRUDAN YA DA DOLAYLI HERHANGİ BİR ZARARDAN, BÖYLE BİR TAZMİNAT TALEBİ TELİF HAKKI SAHİBİ VEYA İLGİLİ KİŞİYE BİLDİRİLMİŞ OLSA DAHİ, SORUMLU DEĞİLDİR.
      </para>
    </legalnotice>
  </bookinfo>

  <chapter xml:id="regexinfo-Overview">
  <title>Genel Bakış</title>
  <para>
Bir <wordasword>düzenli ifade</wordasword> (<wordasword>regexp</wordasword> veya <wordasword>şablon</wordasword>) bir matematiksel dizge kümesini açıklayan bir metin dizgesidir. <varname>s</varname> dizgesi, <varname>r</varname> düzenli ifadesi tarafından açıklanan bir dizge kümesi ise <varname>r</varname> düzenli ifadesi <varname>s</varname> dizgesi ile <wordasword>eşleşir</wordasword>.
  </para><para>
Regex kütüphanesini kullanarak yapabilecekleriniz:
  </para><itemizedlist>
   <listitem>
Bir dizge belirtilen bir şablona tamamen uyarsa bunu görürsünüz.
</listitem><listitem>
Bir dizge içinde belirtilen bir şablon ile uyuşan bir altdizgeyi arayabilirsiniz.
</listitem></itemizedlist>
  <para>
Bazı düzenli ifadeler sadece bir dizge ile eşleşir, yani bir kümenin içinde eşleşen yalnız bir üye vardır. Örneğin <command>foo</command> düzenli ifadesi sadece <command>foo</command> dizgesi ile eşleşir, başka bir şeyle eşleşmez.
</para><para>
Bazıları da bir dizgeden fazlası ile eşleşir, yani bir kümenin içinde eşleşen birden fazla üye vardır. Örneğin <command>f*</command> düzenli ifadesi sıfır veya daha fazla sayıda <command>f</command>lerden oluşan birden fazla dizge ile eşleşebilir.
Sizin de gördüğünüz gibi, düzenli ifadeler içindeki bazı karakterler kendileri ile (<command>f</command> gibi) eşleşirken, bazıları da (<command>*</command> gibi)
kendileriyle eşleşmek yerine çok sayıda farklı dizgeyi açıklayan bir kalıp olarak belirtilir.
  </para><para>
Bir düzenli ifadeyi Regex kütüphane işlevlerinde eşleşmeleri bulmak ya da arama yapmak amacıyla kullanmadan önce bir Regex şablonu derleme işlevi ile derlemelisiniz. Bir <wordasword>derlenmiş şablon</wordasword> kütüphane işlevleri tarafından kullanılabilir duruma getirilmiş bir düzenli ifadedir. Bir şablonu bir kere derledikten sonra eşleşmeleri bulmak ya da arama yapmak için defalarca kullanabilirsiniz.
  </para><para>
Regex kütüphanesi iki kaynak dosyasından oluşur: <filename>regex.h</filename> ve <filename>regex.c</filename>.
<indexterm scope="regexinfo-cp"><primary>regex.h</primary></indexterm>
<indexterm scope="regexinfo-cp"><primary>regex.c</primary></indexterm>
  </para><para>
Regex, düzenli ifadeler üzerinde işlem yapabileceğiniz üç ayrı işlev grubuna sahiptir.
Gruplardan biri olan GNU grubu işlevler en güçlü  olanlardır ama diğerleri ile, POSIX ve Berkeley  Unix grupları ile tam uyumlu değildir; arayüzü özellikle GNU için tasarlanmıştır. Diğer iki grup işlev, POSIX ve Berkeley UNIX düzenli ifade işlevlerinin arayüzleri ile benzer arayüzleri kullanırlar.
  </para><para>
Bu kısmı düzenli ifade kullanan Emacs türü uygulamaların kullanıcılarını değil, yazılımcıları düşünerek yazdık. Regex kütüphanelerini tamamı ile tanımladık.  Burada bir uygulamanın anlayacağı şekilde düzenli ifadelerin nasıl yazılacağını değil, bir bütünlük içinde Regex kütüphanesini anlattık.
  </para>
</chapter>

 <chapter xml:id="regexinfo-Regular-Expression-Syntax">
  <title>Düzenli İfade Sözdizimi</title>
<indexterm scope="regexinfo-cp"><primary>düzenli ifadeler</primary><secondary>sözdizimi</secondary></indexterm>
  <para>
<wordasword>Karakterler</wordasword> yazabildiğiniz şeylerdir.  <wordasword>İşleçler</wordasword> ise bir ya da daha fazla karakterle eşleşen bir düzenli ifade içindeki şeylerdir. Düzenli ifadeleri, bir ya da daha fazla karakteri belirtmek için kullandığımız işleçlerden meydana getirebilirsiniz.
  </para><para>
Çoğu karakter kendiyle eşleşen işleci temsil eder, çünkü bunlar kendileriyle eşleşirler.  Bu karakterlere <wordasword>sıradan karakterler</wordasword> deriz.
Diğer karakterler ise işleçlerin hepsini ya da bazı parçalarını temsil ederler.
Örneğin, <command>.</command> (nokta) karakteri her karakterle eşleşen işleç
adını alır (şaşırmayın hemen hemen her şey ile eşleşir) ve bu tür karakterlere <wordasword>özel karakterler</wordasword> deriz. Bir karakterin ne işleci olduğunu belirleyen iki şey vardır:
  </para><orderedlist numeration="arabic">
   <listitem>Düzenli ifade sözdizimi,</listitem>
   <listitem>Karakterin düzenli ifade içindeki durumu.</listitem>
  </orderedlist><para>
Bundan sonraki bölümde bu konu ayrıntıları ile anlatılmaktadır.
  </para>
  <sect1 xml:id="regexinfo-Syntax-Bits">
   <title>Sözdizimi Bitleri</title>
<indexterm scope="regexinfo-cp"><primary>sözdizimi bitleri</primary></indexterm>
   <para>
Herhangi bir düzenli ifade sözdiziminde bazı karakterler daima özeldir; bazıları bazen özeldir ve diğerleri ise asla özel karakter olmazlar.
Verilen bir düzenli ifadenin sözdiziminin Regex tarafından tanınması
bu düzenli ifadenin şablon tamponunun <command>syntax</command> alanındaki değere bağımlıdır.
   </para><para>
Bir düzenli ifadeyi derleyerek bir şablon tamponu için bellekte yer ayırabilirsiniz. Şablon tamponlar için daha ayrıntılı bilgiyi <xref linkend="regexinfo-GNU-Pattern-Buffers"/> ve <xref linkend="regexinfo-POSIX-Pattern-Buffers"/> bölümlerinde bulabilirsiniz. Derleme hakkında daha ayrıntılı bilgiyi ise <xref linkend="regexinfo-GNU-Regular-Expression-Compiling"/>, <xref linkend="regexinfo-POSIX-Regular-Expression-Compiling"/> ve <xref linkend="regexinfo-BSD-Regular-Expression-Compiling"/> konuları altında bulabilirsiniz.
   </para><para>
Regex, <command>syntax</command> alanının değerinin bitlerden oluştuğunu varsayar; bu bitlere <wordasword>sözdizimi bitleri</wordasword> denir. Pek çok durumda, hangi karakterin hangi işleçi temsil ettiği konusunda etkilidirler. Bahsi geçen işleçlerin anlamlarını <xref linkend="regexinfo-Common-Operators"/>,
<xref linkend="regexinfo-GNU-Operators"/> ve <xref linkend="regexinfo-GNU-Emacs-Operators"/> konularında tanımladık.
   </para><para>
Bir başvuru kaynağı olması için, aşağıda bütün sözdizimi bitlerinin tam bir listesini alfabetik bir sırada bulabilirsiniz:
   </para><variablelist>
<indexterm scope="regexinfo-cp"><primary><literal>RE_BACKSLASH_ESCAPE_IN_LIST</literal></primary></indexterm>
<varlistentry><term xml:id="regexinfo-RE_BACKSLASH_ESCAPE_IN_LISTS">
<literal>RE_BACKSLASH_ESCAPE_IN_LISTS</literal></term>
<listitem><para>
Bu bit birse, bir <link linkend="regexinfo-List-Operators">liste</link> içindeki <command>\</command> kendinden sonra gelen karakteri önceler (karakter bir özel karakterse onu sıradan bir karakter yapar); sıfırsa, <command>\</command> listelerin içinde sıradan bir karakter olarak ele alınır. (<command>\</command> karakterinin listeler dışında ne yaptığı <xref linkend="regexinfo-The-Backslash-Character"/> bölümünde anlatılmıştır.)
</para></listitem></varlistentry>
<indexterm scope="regexinfo-cp"><primary><literal>RE_BK_PLUS_QM </literal></primary></indexterm>
<varlistentry><term xml:id="regexinfo-RE_BK_PLUS_QM">
<literal>RE_BK_PLUS_QM</literal></term><listitem><para>
Bu bit birse,  <command>\+</command> bir veya daha fazlası ile eşleşme işleci, <command>\?</command> ise sıfır veya daha fazlası ile eşleşme işlecini temsil eder. Bu bit sıfırsa, <command>+</command> bir veya daha fazlası ile eşleşme işleci, <command>?</command> ise sıfır veya daha fazlası ile eşleşme işlecini temsil eder. <literal>RE_LIMITED_OPS</literal> biti bir ise bu bit anlamsız olur.
</para></listitem></varlistentry>
<indexterm scope="regexinfo-cp"><primary><literal>RE_CHAR_CLASSES </literal></primary></indexterm>
<varlistentry><term xml:id="regexinfo-RE_CHAR_CLASSES">
<literal>RE_CHAR_CLASSES</literal></term><listitem><para>
Bu bit birse, listelerde karakter sınıflarını kullanabilirsiniz, sıfırsa kullanamazsınız.
</para></listitem></varlistentry>
<indexterm scope="regexinfo-cp"><primary><literal>RE_CONTEXT_INDEP_ANCHORS </literal></primary></indexterm>
<varlistentry><term xml:id="regexinfo-RE_CONTEXT_INDEP_ANCHORS">
<literal>RE_CONTEXT_INDEP_ANCHORS</literal></term><listitem><para>
Bu bit birse, <command>^</command> ve <command>$</command> liste dışında her yerde özeldir. Bu bit sıfırsa, bu karakterler sadece bir liste içinde özeldir.
<xref linkend="regexinfo-Match-beginning-of-line-Operator"/> ve
<xref linkend="regexinfo-Match-end-of-line-Operator"/> bölümlerine bakınız.
</para></listitem></varlistentry>
<indexterm scope="regexinfo-cp"><primary><literal>RE_CONTEXT_INDEP_OPS </literal></primary></indexterm>
<varlistentry><term xml:id="regexinfo-RE_CONTEXT_INDEP_OPS">
<literal>RE_CONTEXT_INDEP_OPS</literal></term><listitem><para>
Bu bit birse, bazı karakterler liste dışında her yerde özeldir. Bu bit sıfırsa, bu karakterler bazı genel durumlarda özel ve diğer heryerde sıradandırlar. Özellikle, bu bit sıfırsa <command>*</command> ve <literal>RE_LIMITED_OPS</literal> sözdizimi biti sıfırsa <command>+</command> ve <command>?</command> (veya <literal>RE_BK_PLUS_QM</literal> sözdizimi bitine bağlı olarak <command>\+</command> ve <command>\?</command>) düzenli ifade içinde ilk değillerse ya da bir VEYA işleci ya da grup başlatma işlecinin hemen ardından gelmiyorlarsa yineleme işleçlerini temsil ederler. <literal>RE_INTERVALS</literal> birlenmişse ve geçerli bir aralığının başlangıcı ise <command>{</command> (veya <literal>RE_NO_BK_BRACES</literal> bitine bağlı olarak <command>\{</command>) içinde aynı durum geçerlidir.
</para></listitem></varlistentry>
<indexterm scope="regexinfo-cp"><primary><literal>RE_CONTEXT_INVALID_OPS </literal></primary></indexterm>
<varlistentry><term xml:id="regexinfo-RE_CONTEXT_INVALID_OPS">
<literal>RE_CONTEXT_INVALID_OPS</literal></term><listitem><para>
Bu bit birse, yineleme ve VEYA işleçleri bir düzenli ifade içinde belirli konumlarda bulunamazlar. Özellikle, aşağıdaki durumlarda düzenli ifade geçersizdir:
</para><itemizedlist>
<listitem><para>
Bir yineleme işleçi düzenli ifade içinde ilk ise veya satır başı eşleştirme, grup başlatma ya da VEYA işleçlerinden hemen sonra geliyor ise.
</para></listitem><listitem><para>
Bir VEYA işleçi düzenli ifade içinde ilk veya son ise, satır sonu eşleştirme işleçinden hemen önce ya da grup başlatma işleçi ya da bir VEYA işlecinden hemen sonra geliyorsa.
</para></listitem></itemizedlist><para>
Bu bit sıfırsa, yineleme ve veya karakterlerini temsil eden karakterleri düzenli ifade içinde her hangi bir yere koyabilirsiniz. Gerçekte, belirli konumlardaki işleçler olup olmamaları diğer sözdizimi bitlerine dayanır.
</para></listitem></varlistentry>
<indexterm scope="regexinfo-cp"><primary><literal>RE_DOT_NEWLINE </literal></primary></indexterm>
<varlistentry><term xml:id="regexinfo-RE_DOT_NEWLINE">
<literal>RE_DOT_NEWLINE</literal></term><listitem><para>
Bu bit birse, herhangi bir karakter ile eşleştirme işleçi satırsonu karakteri ile eşleşir; sıfırsa bunu yapmaz.
</para></listitem></varlistentry>
<indexterm scope="regexinfo-cp"><primary><literal>RE_DOT_NOT_NULL </literal></primary></indexterm>
<varlistentry><term xml:id="regexinfo-RE_DOT_NOT_NULL">
<literal>RE_DOT_NOT_NULL</literal></term><listitem><para>
Bu bit birse, herhangi bir karakterle eşleşme işleçi boş karakterle eşleşmez. Sıfırsa eşleşir.
</para></listitem></varlistentry>
<indexterm scope="regexinfo-cp"><primary><literal>RE_INTERVALS </literal></primary></indexterm>
<varlistentry><term xml:id="regexinfo-RE_INTERVALS">
<literal>RE_INTERVALS</literal></term><listitem><para>
Bu bit birse, Regex aralık işleçlerini tanır; değilse tanımaz.
</para></listitem></varlistentry>
<indexterm scope="regexinfo-cp"><primary><literal>RE_LIMITED_OPS </literal></primary></indexterm>
<varlistentry><term xml:id="regexinfo-RE_LIMITED_OPS">
<literal>RE_LIMITED_OPS</literal></term><listitem><para>
Bu bit birse, bir ya da daha fazlası ile eşleştirme, sıfır ya da biri ile eşleştirme ya da VEYA işleçleri Regex tarafından tanınmaz; değilse tanınır.
</para></listitem></varlistentry>
<indexterm scope="regexinfo-cp"><primary><literal>RE_NEWLINE_ALT </literal></primary></indexterm>
<varlistentry><term xml:id="regexinfo-RE_NEWLINE_ALT">
<literal>RE_NEWLINE_ALT</literal></term><listitem><para>
Bu bit birse, satırsonu karakteri VEYA işleçini temsil eder, değilse satırsonu karakteri sıradan karakterlerden biri olur.
</para></listitem></varlistentry>
<indexterm scope="regexinfo-cp"><primary><literal>RE_NO_BK_BRACES </literal></primary></indexterm>
<varlistentry><term xml:id="regexinfo-RE_NO_BK_BRACES">
<literal>RE_NO_BK_BRACES</literal></term><listitem><para>
Bu bit birse, <literal>{</literal> aralık başlatma işlecini, <command>}</command> aralık kapatma işleçini temsil eder; değilse, <command>\{</command> aralık başlatma işlecini, <command>\}</command> aralık kapatma işleçini temsil eder. Sadece <literal>RE_INTERVALS</literal> biti bir ise  bu bit anlamlıdır.
</para></listitem></varlistentry>
<indexterm scope="regexinfo-cp"><primary><literal>RE_NO_BK_PARENS </literal></primary></indexterm>
<varlistentry><term xml:id="regexinfo-RE_NO_BK_PARENS">
<literal>RE_NO_BK_PARENS</literal></term><listitem><para>
Bu bit birse, <command>(</command> grup başlatma işlecini, <command>)</command> grup kapatma işlecini temsil eder; sıfırsa, <command>\(</command> grup başlatma işlecini, <command>\)</command> grup kapatma işlecini temsil eder.
</para></listitem></varlistentry>
<indexterm scope="regexinfo-cp"><primary><literal>RE_NO_BK_REFS </literal></primary></indexterm>
<varlistentry><term xml:id="regexinfo-RE_NO_BK_REFS">
<literal>RE_NO_BK_REFS</literal></term><listitem><para>
Bu bit birse, <command>\</command><varname>rakam</varname> adresleme işleçi olarak tanınmaz; sıfırsa tanınır.
</para></listitem></varlistentry>
<indexterm scope="regexinfo-cp"><primary><literal>RE_NO_BK_VBAR </literal></primary></indexterm>
<varlistentry><term xml:id="regexinfo-RE_NO_BK_VBAR">
<literal>RE_NO_BK_VBAR</literal></term><listitem><para>
Bu bit birse, <command>|</command> VEYA işlecini temsil eder; sıfırsa <command>\|</command> VEYA işlecini temsil eder. <literal>RE_LIMITED_OPS</literal> biti birse bu bit anlamsızdır.
</para></listitem></varlistentry>
<indexterm scope="regexinfo-cp"><primary><literal>RE_NO_EMPTY_RANGES </literal></primary></indexterm>
<varlistentry><term xml:id="regexinfo-RE_NO_EMPTY_RANGES">
<literal>RE_NO_EMPTY_RANGES</literal></term><listitem><para>
Bu bit birse, içinde bitiş noktası başlangıç noktasından daha küçük olan bir aralık bulunan düzenli ifade geçersizdir; sıfırsa, boş bir aralık olarak kabul edilir.
</para></listitem></varlistentry>
<indexterm scope="regexinfo-cp"><primary><literal>RE_UNMATCHED_RIGHT_PAREN_ORD </literal></primary></indexterm>
<varlistentry><term xml:id="regexinfo-RE_UNMATCHED_RIGHT_PAREN_ORD">
<literal>RE_UNMATCHED_RIGHT_PAREN_ORD</literal></term><listitem><para>
Bu bit birse ve düzenli ifade grup başlatma işleçine sahip değilse, Regex, <command>)</command>'in (<literal>RE_NO_BK_PARENS</literal> bitinin durumuna göre) grup kapatma işleci olduğunu var sayacaktır.
</para></listitem></varlistentry></variablelist>
</sect1>

<sect1 xml:id="regexinfo-Predefined-Syntaxes">
   <title>Öntanımlı Sözdizimleri</title>
<indexterm scope="regexinfo-cp"><primary>Emacs</primary></indexterm>
<indexterm scope="regexinfo-cp"><primary>POSIX Awk</primary></indexterm>
<indexterm scope="regexinfo-cp"><primary>Awk</primary></indexterm>
<indexterm scope="regexinfo-cp"><primary>Grep</primary></indexterm>
<indexterm scope="regexinfo-cp"><primary>Egrep</primary></indexterm>
   <para>
Şayet Regex ile yazılım geliştiriyorsanız, bir şablon tamponun (bkz. <xref linkend="regexinfo-GNU-Pattern-Buffers"/> ve <xref linkend="regexinfo-POSIX-Pattern-Buffers"/>) <command>syntax</command> alanını, <link linkend="regexinfo-Syntax-Bits">sözdizimi bitlerini</link> kendiniz belirleyerek ya da Regex tarafından  tanımlandığı biçimde belirtebilirsiniz.  Bu yapılandırmalar, belirli yazılımlar -GNU Emacs, POSIX Awk, geleneksel Awk, Grep, Egrep- tarafından kullanılan sözdizimlerini, temel ve genişletilmiş POSIX düzenli ifadelerinin sözdizimlerine ek olarak tanımlar.
   </para><para>
Doğrudan <filename>regex.h</filename> başlık dosyasından alınmış önceden tanımlı sözdizimleri:
   </para><para>
<screen>#define RE_SYNTAX_EMACS 0

#define RE_SYNTAX_AWK                                                   \
  (RE_BACKSLASH_ESCAPE_IN_LISTS | RE_DOT_NOT_NULL                       \
   | RE_NO_BK_PARENS            | RE_NO_BK_REFS                         \
   | RE_NO_BK_VBAR               | RE_NO_EMPTY_RANGES                   \
   | RE_UNMATCHED_RIGHT_PAREN_ORD)

#define RE_SYNTAX_POSIX_AWK                                             \
  (RE_SYNTAX_POSIX_EXTENDED | RE_BACKSLASH_ESCAPE_IN_LISTS)

#define RE_SYNTAX_GREP                                                  \
  (RE_BK_PLUS_QM              | RE_CHAR_CLASSES                         \
   | RE_HAT_LISTS_NOT_NEWLINE | RE_INTERVALS                            \
   | RE_NEWLINE_ALT)

#define RE_SYNTAX_EGREP                                                 \
  (RE_CHAR_CLASSES        | RE_CONTEXT_INDEP_ANCHORS                    \
   | RE_CONTEXT_INDEP_OPS | RE_HAT_LISTS_NOT_NEWLINE                    \
   | RE_NEWLINE_ALT       | RE_NO_BK_PARENS                             \
   | RE_NO_BK_VBAR)

#define RE_SYNTAX_POSIX_EGREP                                           \
  (RE_SYNTAX_EGREP | RE_INTERVALS | RE_NO_BK_BRACES)

/* P1003.2/D11.2, section 4.20.7.1, lines 5078ff.  */
#define RE_SYNTAX_ED RE_SYNTAX_POSIX_BASIC

#define RE_SYNTAX_SED RE_SYNTAX_POSIX_BASIC

/* Temel ve genişletilmiş POSIX düzenli ifade sözdizimlerinin
   her ikisi için de geçerli sözdizimi bitleri.  */
#define _RE_SYNTAX_POSIX_COMMON                                         \
  (RE_CHAR_CLASSES | RE_DOT_NEWLINE      | RE_DOT_NOT_NULL              \
   | RE_INTERVALS  | RE_NO_EMPTY_RANGES)

#define RE_SYNTAX_POSIX_BASIC                                           \
  (_RE_SYNTAX_POSIX_COMMON | RE_BK_PLUS_QM)

/* Farklar:  Sadece ..._POSIX_BASIC'deki RE_BK_PLUS_QM'in yerini
   RE_LIMITED_OPS alır, yani, \? \+ \| artık tanınmaz. Aslında, \` gibi
   diğer işleçler iptal edilmediğinden bu pek de ufak tefek değildir. */
#define RE_SYNTAX_POSIX_MINIMAL_BASIC                                   \
  (_RE_SYNTAX_POSIX_COMMON | RE_LIMITED_OPS)

#define RE_SYNTAX_POSIX_EXTENDED                                        \
  (_RE_SYNTAX_POSIX_COMMON | RE_CONTEXT_INDEP_ANCHORS                   \
   | RE_CONTEXT_INDEP_OPS  | RE_NO_BK_BRACES                            \
   | RE_NO_BK_PARENS       | RE_NO_BK_VBAR                              \
   | RE_UNMATCHED_RIGHT_PAREN_ORD)

/* Farklar: ..._POSIX_EXTENDED'deki RE_CONTEXT_INVALID_OPS'nin yerini
   RE_CONTEXT_INDEP_OPS alır ve RE_NO_BK_REFS eklenir.  */
#define RE_SYNTAX_POSIX_MINIMAL_EXTENDED                                \
  (_RE_SYNTAX_POSIX_COMMON  | RE_CONTEXT_INDEP_ANCHORS                  \
   | RE_CONTEXT_INVALID_OPS | RE_NO_BK_BRACES                           \
   | RE_NO_BK_PARENS        | RE_NO_BK_REFS                             \
   | RE_NO_BK_VBAR          | RE_UNMATCHED_RIGHT_PAREN_ORD)
</screen>
</para>
</sect1>
  <sect1 xml:id="regexinfo-Collating-Elements-vs.-Characters">
   <title>Elemanların ve Karakterlerin Alfabetik Sıralaması</title>
   <para>
POSIX bir karakterin anlamını, bir alfabetik sıralama elemanına genelleştirir ve bir <wordasword>alfabetik sıralama elemanı</wordasword><emphasis>nı belirli bir alfabetik dizilim içinde bir alfabetik sıralama birimi olarak tanımlanmış bir ya da daha fazla bayttan oluşan bir dizilim</emphasis> olarak tanımlar.
   </para><para>
Bu, bir karakterin anlamını iki farklı yolla geneller. İlkinde tek bir karakter iki ya da daha fazla alfabetik sıralama elemanına karşılık olabilir. Örneğin, Almanca "es-zet",
sıralamada bir alfabetik sıralama elemanı <command>s</command> den sonra gelen
başka alfabetik sıralama elemanı <command>s</command> olarak ele alınır. İkincisinde, iki ya da daha fazla karakter tek bir alfabetik sıralama elemanına karşılık gelebilir. Örneğin İspanyolcada, <command>ll</command> iki karakterden oluşan tek bir alfabetik sıralama elemanıdır ve <command>l</command>'den sonra, <command>m</command>'den önce gelir.
   </para><para>
POSIX'in "alfabetik sıralama elemanı", "karakter"in gerekliliği fikrini muhafaza ettiğinden ve daha tanıdık geldiğinden bu belgede ikincisini kullandık.
   </para></sect1>
  <sect1 xml:id="regexinfo-The-Backslash-Character">
   <title>Tersbölü Karakteri</title>
<indexterm scope="regexinfo-cp"><primary><command>\</command></primary></indexterm>
   <para>
<command>\</command> karakteri, hangi <link linkend="regexinfo-Syntax-Bits">sözdizimi bitlerinin</link> belirtildiğine ve hangi bağlamda kullandığınıza göre değişen dört ayrı anlama sahiptir. 1) kendisini temsil eder, 2) sonraki karakteri önceler, 3) bir işlecin parçası olur veya 4) hiçbir şey yapmaz.
   </para><orderedlist numeration="arabic">
    <listitem><para>
<literal>RE_BACKSLASH_ESCAPE_IN_LISTS</literal> biti sıfırsa, bir <link linkend="regexinfo-List-Operators">liste</link> içinde  kendisini temsil eder. Örneğin, <command>[\]</command>, <command>\</command> ile eşleşir.
    </para></listitem><listitem><para>
Kendinden sonra gelen karakteri özel bir karakterse şu hallerde sıradan yapar:
    </para><itemizedlist>
      <listitem>
bir listenin dışında,<footnote><para>
Bazı durumlarda, özel karakterleri sıradan yapmak için onları doğrudan doğruya öncelemek zorunda değilsiniz. Örneğin, bir <link linkend="regexinfo-List-Operators">liste</link> içerisinde pek çok karakter özel anlamını kaybeder. Ek olarak, `<literal>RE_CONTEXT_INVALID_OPS</literal> ve <literal>RE_CONTEXT_INDEP_OPS</literal> sözdizimi bitleri sıfırsa (tarihsel sebeplerden dolayı), şayet işleçler özel bir anlam ihtiva etmiyorsa, özel karakterler sıradan kabul edilir; örneğin, <command>*</command> tarafından temsil edilen sıfır veya daha fazlası ile eşleştirme işleci, <command>*foo</command> düzenli ifadesinde kendisi ile eşleşir, çünkü kendinden önce gelen ve işlem yapabileceği bir ifade yoktur. Bu kötü bir örnektir, bununla birlikte, özel bir karakterin liste dışında sıradan olmasını istiyorsanız, ne olursa olsun öncelemek en iyi yoldur.</para></footnote>
      </listitem><listitem>
<literal>RE_BACKSLASH_ESCAPE_IN_LISTS</literal> biti bir ise bir listenin içinde.
      </listitem></itemizedlist>
    </listitem><listitem><para>
Belli bir sıradan karakteri öncelediğinde bir işleç olur; bazan sadece belirli sözdizimi bitleri bir ise bu olur. <xref linkend="regexinfo-Syntax-Bits"/> içindeki
<literal>RE_BK_PLUS_QM</literal>, <literal>RE_NO_BK_BRACES</literal>, <literal>RE_NO_BK_VAR</literal>,
<literal>RE_NO_BK_PARENS</literal>, <literal>RE_NO_BK_REF</literal> durumlarına bakınız. Ayrıca:
     </para><itemizedlist>
      <listitem>
<command>\b </command> <link linkend="regexinfo-Match-word-boundary-Operator">sözcük sınırıyla eşleşme işlecini</link> temsil eder.
      </listitem><listitem>
<command>\B </command> <link linkend="regexinfo-Match-within-word-Operator">sözcük-içi eşleşme işlecini</link> temsil eder.
      </listitem><listitem>
<command>\&lt; </command> <link linkend="regexinfo-Match-beginning-of-word-Operator">sözcük başlangıcıyla eşleşme işlecini</link> temsil eder.
      </listitem><listitem>
<command>\&gt; </command> <link linkend="regexinfo-Match-end-of-word-Operator">sözcük sonuyla eşleşme işlecini</link> temsil eder.
      </listitem><listitem>
<command>\w </command> <link linkend="regexinfo-Match-word-constituent-Operator">sözcük bileşenleriyle eşleşme işlecini</link> temsil eder.
      </listitem><listitem>
<command>\W </command> <link linkend="regexinfo-Match-non-word-constituent-Operator">sözcük bileşeni olmayanlarla eşleşme işlecini</link> temsil eder.
      </listitem><listitem>
<command>\` </command> <link linkend="regexinfo-Buffer-Operators">tampon başlangıcıyla eşleşme işlecini</link>, <command>\'</command> <link linkend="regexinfo-Buffer-Operators">tampon sonuyla eşleşme işlecini</link> temsil eder.
      </listitem><listitem>
şayet Regex <command>emacs </command>  önişlemci sembolü ile derlenmişse,     <command>\s</command><varname>sınıf </varname> <link linkend="regexinfo-Syntactic-Class-Operators">sınıfla sözdizimsel eşleşme işleçini</link>, <command>\S</command><varname>sınıf </varname> <link linkend="regexinfo-Syntactic-Class-Operators">sınıfla sözdizimsel olmayan eşleşme işlecini</link> temsil eder.
      </listitem></itemizedlist>
    </listitem><listitem><para>
Tüm diğer durumlarda, Regex <command>\</command> karakterini yoksayar.  Örneğin,
<command>\n</command>, <command>n</command> ile eşleşir.
     </para></listitem></orderedlist>
</sect1>
</chapter>
 <chapter xml:id="regexinfo-Common-Operators">
  <title>Ortak İşleçler</title>
  <para>
Düzenli ifadeleri işleçlerden oluşturursunuz. İzleyen bölümlerde, GNU'nun da kullandığı POSIX tarafından belirtilmiş düzenli ifade işleçlerini tanımlayacağız. Pek çok işleç birden fazla karakter ile temsil edilebilir. Hangi karakterin hangi koşul altında hangi işleci temsil ettiği <xref linkend="regexinfo-Regular-Expression-Syntax"/> bölümünde açıklanmıştır.
  </para><para>
İki farklı şekilde temsil edilebilen pek çok işleç için, birinci yol tek bir karakter ve diğeri '\' ile öncelenmiş karakterdir. Örneğin  grup başlatma işlecini ya  <command>(</command> ya da <command>\(</command> temsil eder. Hangisinin temsil ettiği sözdizimi bitinin değerine bağlıdır, grup başlatma işleci için bakılacak sözdizimi biti  <literal>RE_NO_BK_PARENS</literal>'dir. Peki neden iki farklı gösterim var?  Bir kısmı geçmişin, bir kısmı da POSIX'in dayatmasıdır.
  </para><para>
Son olarak, hemen hemen bütün karakterler <link linkend="regexinfo-List-Operators">liste</link> içerisinde özel anlamlarını kaybederler.
  </para>

  <sect1 xml:id="regexinfo-Match-self-Operator">
   <title>Kendisiyle Eşleşme İşleci</title>
   <titleabbrev>sıradan herhangi bir karakter</titleabbrev>
   <para>
Bu işleç karakterin kendisi ile eşleşir. Bütün sıradan karakterler (Bkz. <xref linkend="regexinfo-Regular-Expression-Syntax"/>) bu işleçi temsil eder. Örneğin, <command>f</command> daima sıradan bir karakterdir, bu nedenle <command>f</command> düzenli ifadesi sadece <command>f</command> dizgesi ile eşleşir. Herhangi bir sebepten dolayı <command>ff</command> ile eşleşmez.
   </para></sect1>
  <sect1 xml:id="regexinfo-Match-any-character-Operator">
   <title>Herhangi Bir Karakterle Eşleşme İşleci</title>
   <titleabbrev><command>.</command> (nokta)</titleabbrev>
<indexterm scope="regexinfo-cp"><primary><command>.</command></primary></indexterm>
   <para>
Bu işleç basılabilen veya basılamayan herhangi bir tek karakter ile eşleşir. Aşağıdaki durumlar dışında:
   </para><variablelist><varlistentry>
   <term>satırsonu karakteri (<literal>\n</literal>)</term>
     <listitem><para>
<literal>RE_DOT_NEWLINE</literal> sözdizimi biti sıfırsa bu karakterle eşleşmez.
     </para></listitem></varlistentry><varlistentry>
     <term>boş karakter (<literal>\0</literal>)</term>
     <listitem><para>
<literal>RE_DOT_NOT_NULL</literal>  sözdizimi biti bir ise bu karakterle eşleşmez.
     </para></listitem></varlistentry>
   </variablelist><para>
Bu işleci <command>.</command> (nokta) karakteri temsil eder. Örneğin,
<command>a.b</command> ifadesi <command>a</command> ile başlayan ve <command>b</command> ile biten herhangi bir üç karakterli dizge ile eşleşir.
   </para></sect1>
  <sect1 xml:id="regexinfo-Concatenation-Operator">
   <title>Birleştirme İşleci</title>
   <titleabbrev>herhangi bir karakterle ifade edilmez</titleabbrev>
   <para>
Bu işleç <varname>a</varname> ve <varname>b</varname> gibi iki düzenli ifadeyi birleştirir. Bu işleç herhangi bir karakter ile temsil edilmez; basitçe <varname>b</varname> 'yi <varname>a</varname> 'nın ardına yerleştirirsiniz.  Sonuç, <varname>a</varname> ile başlayan ve <varname>b</varname> ile devam eden bir dizge ile eşleşen bir düzenli ifadedir. Örneğin,  <command>xy</command> düzenli ifadesi sadece <command>xy</command> dizgesi ile eşleşir.
   </para></sect1>
  <sect1 xml:id="regexinfo-Repetition-Operators">
   <title>Yineleme İşleçleri</title>
   <para>
Yineleme işleçleri kendilerinden önce gelen düzenli ifadeyi, istenen miktarda tekrar etmeye yarar.
   </para>

   <sect2 xml:id="regexinfo-Match-zero-or-more-Operator" chunkthis="1">
    <title>Sıfır veya daha fazlası ile eşleşme işleci</title>
    <titleabbrev><command>*</command> karakteri</titleabbrev>
<indexterm scope="regexinfo-cp"><primary><command>* </command></primary></indexterm>
    <para>
Bu işleç, örneğe uygun hale getirene kadar, kendinden önce yer alan ve mümkün olan en küçük yapıdaki düzenli ifadeyi gerekli sayıda-sıfır dahil- tekrarlamaya yarar. Bu işleç, <command>*</command> ile temsil edilir. örneğin; <command>o*</command> içerisinde sıfır veya daha fazla <command>o</command> bulunan her hangi bir dizge ile eşleşir. Bu işleç mümkün olan en küçük parça üzerinde işlem yaptığı için, <command>fo*</command> içinde sadece <command>o</command> tekrarlanır, <command>fo</command> değil. Bu nedenle, <command>fo*</command> sıra ile; <command>f</command>, <command>fo</command>, <command>foo</command>, ... ile eşleştirilir.
    </para><para>
Sıfır veya fazlası ile eşleşme işleci  bir sonek olduğu için, kendinden önce bir düzenli ifade bulunmadığı durumlarda hiçbir işe yaramazlar. Bu, şu durumlarda geçerli olur:
    </para><itemizedlist>
     <listitem>bir düzenli ifade içindeki ilk karakter ise,</listitem>
     <listitem>bir satır başı ile eşleşme işlecinin, grup başlatma işlecinin ya da VEYA işlecinin ardından kullanılmışsa.</listitem>
    </itemizedlist><para>
Bu tür durumlarda üç farklı şey olabilir:
    </para><orderedlist numeration="arabic">
     <listitem><para>
Şayet <literal>RE_CONTEXT_INVALID_OPS</literal> sözdizimi biti bir ise, düzenli ifade geçersiz olur.
      </para></listitem><listitem><para>
Şayet <literal>RE_CONTEXT_INVALID_OPS</literal> biti sıfır ve <literal>RE_CONTEXT_INDEP_OPS</literal> biti bir ise <command>*</command>
sıfır veya fazlası ile eşleşme işlecini temsil eder (böylece boş bir dizge üzerinde işlem yapılabilir).
      </para></listitem><listitem><para>
Aksi takdirde, <command>*</command> sıradan bir karakterdir.
      </para></listitem></orderedlist><para>
<indexterm scope="regexinfo-cp"><primary>gerileterek işlem</primary></indexterm>
Eşleştirme işlemi, sıfır veya fazlası ile eşleştirme işlecinin kendinden önceki mümkün olan en küçük düzenli ifade ile öncelikle eşleştirilmesi ve bu işlemin gerektiği kadar yinelenmesi sürecidir. Daha sonra şablonun kalanı ile eşleştirmeye devam edilir.
    </para><para>
Şayet şablonun kalanı ile eşleştirilemez ise, gerektiği kadar (kaç kere gerekliyse) geri gidilir ve işlem tekrarlanır. Her geri gidişte bir önceki eşleştirme iptal edilerek şablonun bütününe en yakın eşleşme bulunmaya çalışılır ya da hiçbir eşleşme bulunamaz. Örneğin; <command>ca*ar</command> düzenli ifadesi <command>caaar</command> dizgesi ile eşleştirilirken, eşleştirici ilk önce, dizgenin üç <command>a</command>sı ile düzenli ifadenin <command>a*</command>'ını eşleştirir. Bununla beraber, düzenli ifadenin son <command>ar</command>'ı dizgenin son <command>r</command>'si ile eşleşemez. Bu durumda geriye dönülerek dizgedeki son <command>a</command> eşleşmesi iptal edilerek geriye kalan <command>ar</command> ile eşleşme sağlanır.
    </para></sect2>
   <sect2 xml:id="regexinfo-Match-one-or-more-Operator" chunkthis="1">
    <title>Bir veya daha fazlası ile eşleştirme işleci</title>
    <titleabbrev><command>+</command> veya <command>\+</command></titleabbrev>
<indexterm scope="regexinfo-cp"><primary><command>+</command></primary></indexterm>
<indexterm scope="regexinfo-cp"><primary><command>\+</command></primary></indexterm>
    <para>
<literal>RE_LIMITED_OPS</literal> sözdizimi biti bir ise, Regex bu işleci tanımaz. Aksi takdirde, <literal>RE_BK_PLUS_QM</literal> sözdizimi biti sıfırsa işleci <command>+</command>, değilse <command>\+</command> temsil eder.
    </para><para>
Bu işleç <link linkend="regexinfo-Match-zero-or-more-Operator">sıfır veya daha fazlası ile eşleştirme işleçine</link> benzer. Tek fark bu işleçin kendinden önceki düzenli ifadeyi en az bir kere yinelemesidir.
    </para><para>
Örneğin; <command>+</command> nın bir veya fazlası ile eşleşme işleçi olduğunu kabul edersek, <command>ca+ar</command> ifadesi <command>caar</command> ve <command>caaaar</command> dizgeleriyle eşleşir, fakat <command>car</command> ile eşleşmez.
    </para></sect2>
   <sect2 xml:id="regexinfo-Match-zero-or-one-Operator" chunkthis="1">
    <title>Sıfır veya bir kere eşleşme işleci</title>
    <titleabbrev><command>?</command> veya <command>\?</command></titleabbrev>
<indexterm scope="regexinfo-cp"><primary><command>?</command></primary></indexterm>
<indexterm scope="regexinfo-cp"><primary><command>\?</command></primary></indexterm>
    <para>
<literal>RE_LIMITED_OPS</literal> sözdizimi biti bir ise, Regex bu işleci tanımaz.  Aksi takdirde, <command>RE_BK_PLUS_QM</command> sözdizimi biti sıfırsa işleci <command>?</command>, değilse <command>\?</command> temsil eder.
    </para><para>
Bu işleç kendinden önceki düzenli ifadeyi en az bir kere yinelemesi ya da hiç yinelememesi dışında <link linkend="regexinfo-Match-zero-or-more-Operator">sıfır veya daha fazlası ile eşleştirme işleci</link> gibidir.
    </para><para>
Örneğin, <command>ca?r</command> düzenli ifadesi <command>car</command> ve <command>cr</command> dışında hiçbir şey ile eşleşmez.
    </para></sect2>
   <sect2 xml:id="regexinfo-Interval-Operators" chunkthis="1">
    <title>Sınırlı sayıda yineleme işleçleri</title>
    <titleabbrev><command>{&hellip;}</command> veya <command>\{&hellip;\}</command></titleabbrev>
<indexterm scope="regexinfo-cp"><primary>sınırlı sayıda yineleme işleci</primary></indexterm>
<indexterm scope="regexinfo-cp"><primary><command>{</command></primary></indexterm>
<indexterm scope="regexinfo-cp"><primary><command>}</command></primary></indexterm>
<indexterm scope="regexinfo-cp"><primary><command>\{</command></primary></indexterm>
<indexterm scope="regexinfo-cp"><primary><command>\}</command></primary></indexterm>
    <para>
<literal>RE_INTERVALS</literal> sözdizimi biti bir ise, Regex <wordasword>sınırlı sayıda yineleme işleçleri</wordasword>ni tanır. Bunlar, kendilerinden önceki mümkün olan en küçük düzenli ifadeyi belirli bir sayıda tekrar ederler.
    </para><para>
<literal>RE_NO_BK_BRACES</literal> sözdizimi biti bir ise, <command>{</command> karakteri <wordasword>sınırlı sayıda yineleme başlatma işleci</wordasword>, <command>}</command> karakteri de <wordasword>sınırlı sayıda yineleme bitirme işleci</wordasword> olur, aksi takdirde <command>\{</command> ve <command>\}</command> işleçleri geçerli olur.
    </para><para>
Özel olarak, sınırlı sayıda yineleme başlatma ve bitirme işleçlerini <command>{</command> ve <command>}</command> karakterlerinin temsil ettiğini varsayarsak:
    </para><variablelist><varlistentry>
      <term><command>{<varname>sayı</varname>}</command></term>
      <listitem><para>
Önceleyen düzenli ifadeyi tam olarak <varname>sayı</varname> kere eşleştirir.
       </para></listitem></varlistentry><varlistentry>
      <term><command>{<varname>sayı,</varname>}</command></term>
      <listitem><para>
Önceleyen düzenli ifadeyi en az <varname>sayı</varname> kere eşleştirir.
       </para></listitem></varlistentry><varlistentry>
      <term><command>{<varname>sayı1, sayı2</varname>}</command></term>
      <listitem><para>
Önceleyen düzenli ifadeyi en az <varname>sayı1</varname>, en çok <varname>sayı2</varname> kere eşleştirir.
       </para></listitem></varlistentry></variablelist><para>
Sınırlı sayıda yineleme ifadesinin geçersiz olduğu durumlar
(ancak, onu içeren düzenli ifadenin geçerliliği gerekli değildir):
    </para><itemizedlist>
     <listitem><varname>sayı1</varname> > <varname>sayı2</varname></listitem>
     <listitem>
<varname>sayı</varname>, <varname>sayı1</varname> veya <varname>sayı2</varname> sıfırla <literal>RE_DUP_MAX</literal> sabiti arasında bir değer değilse. (<literal>RE_DUP_MAX</literal> sembolik sabiti <filename>regex.h</filename> başlık dosyasında tanımlanmıştır.)
      </listitem>
     </itemizedlist><para>
Sınırlı sayıda yineleme ifadesi geçersiz ve <literal>RE_NO_BK_BRACES</literal> biti bir ise, Regex ifade içindeki karakterlerin sıradan olduğunu varsayar; bitin değeri sıfırsa, düzenli ifade geçersizdir.
    </para><para>
Sınırlı sayıda yineleme ifadesi geçerli fakat üzerinde işlem yapılacak bir önceleyen düzenli ifade yoksa ve <literal>RE_CONTEXT_INVALID_OPS</literal> biti bir ise,
düzenli ifade geçersizdir; bitin değeri sıfırsa Regex ifade içindeki karakterleri -- tersbölüler hariç -- sıradan kabul eder.
    </para>
</sect2></sect1>
  <sect1 xml:id="regexinfo-Alternation-Operator">
   <title>VEYA İşleci</title>
   <titleabbrev><command>|</command> veya <command>\|</command></titleabbrev>
<indexterm scope="regexinfo-cp"><primary><command>|</command></primary></indexterm>
<indexterm scope="regexinfo-cp"><primary><command>\|</command></primary></indexterm>
<indexterm scope="regexinfo-cp"><primary>VEYA işleci</primary></indexterm>
    <para>
<literal>RE_LIMITED_OPS</literal> sözdizimi biti bir ise, Regex bu işleci tanımaz.
Aksi takdirde, <literal>RE_NO_BK_VBAR</literal> biti bir ise, <command>|</command> değilse <command>\|</command> ile temsil edilir.
   </para><para>
Düzenli ifade içinde bu işleç ile ayrılan düzenli ifadelerden biri ile eşleştirme yapılır. Örneğin, <command>|</command> VEYA işleci ise, <command>foo|bar|quux</command> düzenli ifadesi <command>foo</command>, <command>bar</command> veya <command>quux</command> dizgelerinden herhangi biri ile eşleşecektir.
   </para><para>
VEYA işleci, düzenli ifadelerin mümkün olan en büyük bağlamı üzerinde işlem yaparlar. (Başka bir deyişle VEYA işleci herhangi bir düzenli ifade işlecine göre en düşük önceliğe sahiptir.) Bu nedenle argümanlarını sınırlamanın tek yolu onları gruplamaktır.
Örneğin, <command>(</command> ve <command>)</command> gruplama işleçleri ve <command>|</command> VEYA işleci ise, <command>fo(o|b)ar</command> düzenli ifadesi, <command>fooar</command> ya da <command>fobar</command> ile eşleşecektir.  (Düzenli ifade <command>foo|bar</command> ise <command>foo</command> veya <command>bar</command> ile eşleşir.)
   </para><para>
<indexterm scope="regexinfo-cp"><primary>gerileterek işlem</primary></indexterm>
Eşleştirme mümkün olan en büyük dizge üzerinde mümkün olan bütün olasılıkların denenmesi ile yapılır. Örneğin; <command>(fooq|foo)*(qbarquux|bar)</command> düzenli ifadesi, <command>fooqbarquux</command> dizgesi ile eşleştirilirken,
bu eşleşme olmaz, ilk (ve en ilk) birleşim eşleşirdi ve bu da sadece <command>fooqbar</command> olurdu.
   </para></sect1>
  <sect1 xml:id="regexinfo-List-Operators">
   <title>Liste İşleçleri</title>
   <titleabbrev><command>[&hellip;]</command> ve <command>[^&hellip;]</command></titleabbrev>
<indexterm scope="regexinfo-cp"><primary>eşleşme listesi</primary></indexterm>
<indexterm scope="regexinfo-cp"><primary><command>[</command></primary></indexterm>
<indexterm scope="regexinfo-cp"><primary><command>]</command></primary></indexterm>
<indexterm scope="regexinfo-cp"><primary><command>^</command></primary></indexterm>
<indexterm scope="regexinfo-cp"><primary><command>-</command></primary></indexterm>
<indexterm scope="regexinfo-cp"><primary><command>\</command></primary></indexterm>
<indexterm scope="regexinfo-cp"><primary><command>[^</command></primary></indexterm>
<indexterm scope="regexinfo-cp"><primary>eşleşmeme listesi</primary></indexterm>
<indexterm scope="regexinfo-cp"><primary>satırsonu karakteri ile eşleşme</primary></indexterm>
<indexterm scope="regexinfo-cp"><primary>köşeli ayraçlı ifade</primary></indexterm>
    <para>
<wordasword>Listeler</wordasword>, <wordasword>köşeli ayraçlı ifadeler</wordasword> olarak da bilinir ve bir ya da daha fazla öğeden oluşan kümelerdir. Burada <wordasword>öğe</wordasword> bir karakter, bir karakter sınıfı veya bir aralık ifadesidir. Bir listeye konabilecek öğe türü sözdizimi bitleri ile belirlenir. Son iki öğeyi aşağıdaki iki altbölümde açıklayacağız. Boş listeler geçersizdir.
   </para><para>
Bir <wordasword>eşleşme listesi</wordasword>, liste öğelerinden biri ile temsil edilen tek bir karakterle eşleşir. Bir eşleşme listesini <command>[</command> ile gösterilen bir <wordasword>eşleşme listesi başlatma işleci</wordasword> ile başlayan bir ya da daha fazla öğe içeren ve <command>]</command> ile gösterilen bir <wordasword>eşleşme listesi bitirme işleci</wordasword> ile biten bir ifade olarak oluşturabilirsiniz.
   </para><para>
Örneğin;  <command>[ab]</command> ifadesi <command>a</command> veya <command>b</command> ile eşleşir.  <command>[ad]*</command> ise boş bir dizge veya içinde herhangi bir sırada <command>a</command> veya <command>b</command> olan dizgelerle eşleşir.  Regex, içerisinde <command>[</command> olan ama karşılığı olan <command>]</command> karakterini içermeyen düzenli ifadeleri geçersiz sayar.
   </para><para>
Bir <wordasword>eşleşmeme listesi</wordasword> eşleşme listesine benzer fakat sadece, liste içerisinde temsil edilmeyen karakterleri eşleştirirler. Bir eşleşmeme listesini başlatmak için, bir eşleşme listesi başlatma işleci yerine  <wordasword>eşleşmeme listesi başlatma işleci</wordasword> kullanırız (<command>[^</command><footnote><para>Regex bu nedenle, <command>^</command> karakterini liste içindeki ilk karakter olarak kabul etmez. Şayet herhangi bir nedenle bir eşleştirme listesinin ilk karakteri olarak <command>^</command> kullanırsanız, bu onu eşleşmeme listesi haline dönüştürür.</para></footnote>).
   </para><para>
Örneğin; <command>[^ab]</command>, <command>a</command> ve
<command>b</command> hariç herhangi bir karakter ile eşleşebilir.
   </para><para>
<link linkend="regexinfo-GNU-Pattern-Buffers">Şablon tamponu</link> içinde <command>posix_newline</command> alanı bir ise, eşleşmeme listesi satırsonu karakteri ile eşleşmez.
   </para><para>
Pek çok karakter, liste içerisinde, özel anlamlarını kaybederler. Liste içerisinde özel anlamı olan karakter:
   </para><variablelist>
    <varlistentry>
     <term><literal>]</literal></term>
     <listitem><para>
Şayet listedeki ilk karakter değilse, listeyi kapatır. Bu nedenle liste içerisinde <command>]</command> karakterini kullanmak istiyorsanız, bu karakteri en başa koymalısınız.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>\</literal></term>
      <listitem><para>
Şayet <literal>RE_BACKSLASH_ESCAPE_IN_LISTS</literal> sözdizimi biti bir ise, önündeki karakteri önceler.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>[:</literal></term>
      <listitem><para>
Şayet <literal>RE_CHAR_CLASSES</literal>  sözdizimi biti bir ise ve kendinden sonrakiler geçerli bir karakter sınıf ifadesi ise, <link linkend="regexinfo-Character-Class-Operators">karakter sınıfı başlatma işleçini</link> temsil eder.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>:]</literal></term>
      <listitem><para>
Şayet <literal>RE_CHAR_CLASSES</literal>  sözdizimi biti bir ise ve kendinden öncekiler geçerli bir karakter sınıf ifadesi ise, <link linkend="regexinfo-Character-Class-Operators">karakter sınıfı bitirme işleçini</link> temsil eder.
      </para></listitem></varlistentry><varlistentry>
      <term><literal>-</literal></term>
      <listitem><para>
Şayet bir liste içerisinde ilk veya son karakter değilse ya da bir aralığın uç noktası değilse,  <link linkend="regexinfo-Range-Operator">aralık işleci</link>ni temsil eder.
      </para></listitem></varlistentry></variablelist><para>
Tüm diğer karakterler sıradandır. Örneğin; <command>[.*]</command> ifadesi hem  <command>.</command> hem de <command>*</command> ile eşleşir.
   </para>
   <sect2 xml:id="regexinfo-Character-Class-Operators" chunkthis="1">
    <title>Karakter Sınıfı İşleçleri</title>
    <titleabbrev><command>[:&hellip;:]</command></titleabbrev>
<indexterm scope="regexinfo-cp"><primary>karakter sınıfları</primary></indexterm>
<indexterm scope="regexinfo-cp"><primary><command>[:</command></primary></indexterm>
<indexterm scope="regexinfo-cp"><primary><command>:]</command></primary></indexterm>
    <para>
Şayet <literal>RE_CHARACTER_CLASSES</literal> sözdizimi biti bir ise, Regex, listelerin içindeki karakter sınıf ifadelerini tanır. Bir <wordasword>karakter sınıfı ifadesi</wordasword> belirtilen sınıftan bir karakter ile eşleşir.  Bir karakter sınıfı fadesini, bir <wordasword>karakter sınıfı başlatma işleci</wordasword> (<command>[:</command> ile temsil edilir) ile  bir <wordasword>karakter sınıfı bitirme işleci</wordasword> (<command>:]</command> ile temsil edilir) arasına koyarak oluşturabilirsiniz. Karakter sınıf isimleri ve anlamları şunlardır:
    </para><variablelist><varlistentry>
      <term><literal>alnum</literal></term>
      <listitem><para>harfler ve rakamlar</para></listitem>
    </varlistentry><varlistentry>
      <term><literal>alpha</literal></term>
      <listitem><para>harfler</para></listitem>
    </varlistentry><varlistentry>
      <term><literal>blank</literal></term>
      <listitem><para>sisteme bağlıdır, GNU için boşluk ve sekme (tab) karakterleridir.
      </para></listitem>
    </varlistentry><varlistentry>
      <term><literal>cntrl</literal></term>
      <listitem><para>
kontrol karakterleri (ascii kodlamada, sekizlik tabanda 040. karakterden önceki tüm karakterler ile 0177. karakter)
      </para></listitem>
    </varlistentry><varlistentry>
      <term><literal>digit</literal></term>
      <listitem><para>rakamlar</para></listitem>
    </varlistentry><varlistentry>
      <term><literal>graph</literal></term>
      <listitem><para>
boşluk karakteri hariç <command>print</command> sınıfı ile aynıdır.
      </para></listitem>
    </varlistentry><varlistentry>
      <term><literal>lower</literal></term>
      <listitem><para>küçük harfler</para></listitem>
    </varlistentry><varlistentry>
      <term><literal>print</literal></term>
      <listitem><para>
basılabilir karakterler (ascii kodlamada, boşluk, ~ ve sekizlik tabanda 040'dan 0176'ya kadar tüm karakterler)
       </para></listitem>
     </varlistentry><varlistentry>
      <term><literal>punct</literal></term>
      <listitem><para>
ne kontrol ne de alfasayısal karakterler
       </para></listitem>
     </varlistentry><varlistentry>
      <term><literal>space</literal></term>
      <listitem><para>
boşluk, satırbaşı, satırsonu, düşey sekme ve sayfa ileri karakterleri
       </para></listitem>
     </varlistentry><varlistentry>
      <term><literal>upper</literal></term>
      <listitem><para>büyük harfler</para></listitem>
    </varlistentry><varlistentry>
      <term><literal>xdigit</literal></term>
      <listitem><para>
onaltılık rakamlar: <command>0</command>-<command>9</command>, <command>a</command>-<command>f</command>, <command>A</command>-<command>F</command>
       </para></listitem>
     </varlistentry></variablelist><para>
Bunlar, GNU C kütüphanesinin <filename>ctype.h</filename> başlık dosyasındaki tanımlamalara karşı düşer. Örneğin, <command>[:alpha:]</command> ifadesi standart <command>isalpha</command> işlevine karşılık gelir. Regex, karakter sınıfı ifadelerini sadece listelerin içinde tanır; bu nedenle <command>[[:alpha:]]</command> ifadesi herhangi bir harf ile eşleşirken,  <command>[:alpha:]</command> ifadesi bir köşeli ayraçlı ifadenin dışında olduğundan ve ardından bir yinelelme işleci gelmediğinden sadece kendisiyle eşleşir.
    </para></sect2>
  <sect2 xml:id="regexinfo-Range-Operator" chunkthis="1">
    <title>Aralık İşleci</title>
    <titleabbrev><command>-</command> (tire) karakteri</titleabbrev>
    <para>
Regex bir liste içindeki <wordasword>aralık ifadeleri</wordasword>ni tanır. Kullanımdaki yerelin alfabetik sıralamasına bağlı olarak iki karakter arasında kalan bütün karakterleri temsil ederler. Bir aralık ifadesini iki karakterin arasına bir <wordasword>aralık işleci</wordasword> yerleştirerek oluşturabilirsiniz<footnote><para>Bir karakter sınıfı tek bir karakterden oluşmadığından karakter sınıflarını bir aralığın başlangıcı ya da sonu olarak belirtemezsiniz.</para></footnote> Aralık işleci <command>-</command> karakteri ile temsil edilir. Örneğin, bir liste içerisindeki <command>a-f</command> ifadesi, <command>a</command>'dan <command>f</command>'ye kadar olan bütün karakterleri kapsar.
    </para><para>
<literal>RE_NO_EMPTY_RANGES</literal> sözdizimi biti bir ise ve aralığın bitiş karakteri alfabetik sıralamada başlangıç karakterinden küçükse aralık ifadesi geçersizdir. Örneğin, <command>[z-a]</command> düzenli ifadesi geçersiz olurdu.
Bu bit sıfırsa, Regex böyle bir aralığı boş kabul eder.
    </para><para>
<command>-</command> karakteri aralık işlecini temsil ettiğinden bu karakterin kendisini bir liste öğesi yapmak isterseniz aşağıdaki yöntemlerden birini kullanmalısınız:
    </para><itemizedlist>
     <listitem>
<command>-</command> karakterini listenin ya başına ya da sonuna yerleştirin.
     </listitem><listitem>
Alfabetik sıralamada <command>-</command> karakterinden küçük bir karakterle başlayan veya bu karakterle ya da daha büyük bir karakterle biten bir aralığın içinde
bırakın. Bir aralık, bir listenin ilk öğesi olmadıkça,  bir <command>-</command> karakteri bir aralığın başlangıç karakteri olamaz ancak, bitiş karakteri olabilir. Regex, bir <command>-</command> karakteri başka bir <command>-</command> karakteri ile öncelenmedikçe, <command>-</command> karakterini aralık işleci olarak ele alır. Örneğin ascii kodlamada, <command>)</command>,
<command>*</command>, <command>+</command>, <command>,</command>, <command>-</command>, <command>.</command> ve <command>/</command> karakterleri sıralamada peşpeşe gelirler. <command>[)-+--/]</command> ifadesine bakınca, iki aralığın olduğunu düşünebilirsiniz:  <command>)-+</command> ve <command>--/</command>. Halbuki, <command>)-+</command> ve <command>+--</command> aralıkları ile <command>/</command> karakterini kapsar. Yani ifade <command>,</command> ile eşleşir ama <command>.</command> ile eşleşmez.
      </listitem><listitem>
Liste içerisine başlangıç noktası <command>-</command> olan bir aralığı ilk öğe olarak yerleştirin.
      </listitem></itemizedlist><para>
Örneğin, <command>[-a-z]</command> ifadesi herhangi bir küçük harf veya bir <command>-</command> karakteri ile eşleşir.
    </para>
</sect2></sect1>
  <sect1 xml:id="regexinfo-Grouping-Operators">
   <title>Gruplama İşleçleri</title>
   <titleabbrev><command>(&hellip;)</command> veya <command>\(&hellip;\)</command></titleabbrev>
<indexterm scope="regexinfo-cp"><primary><command>(</command></primary></indexterm>
<indexterm scope="regexinfo-cp"><primary><command>)</command></primary></indexterm>
<indexterm scope="regexinfo-cp"><primary><command>\(</command></primary></indexterm>
<indexterm scope="regexinfo-cp"><primary><command>\)</command></primary></indexterm>
<indexterm scope="regexinfo-cp"><primary>gruplama</primary></indexterm>
<indexterm scope="regexinfo-cp"><primary>alt ifadeler</primary></indexterm>
<indexterm scope="regexinfo-cp"><primary>parantezleme</primary></indexterm>
   <para>
Bir <wordasword>grup</wordasword> aynı zamanda bir <wordasword>alt ifade</wordasword>dir ve bir <wordasword>grup başlatma işleci</wordasword> ile başlatılıp, bir takım başka işleçlerden sonra bir  <wordasword>grup sonlandırma işleci</wordasword> ile sonlandırılır.  Regex böyle bir ifadeyi yazılım geliştirme dillerindeki ve matematiksel ifadelerdeki gibi tek bir birim olarak ele alır.
   </para><para>
Bu nedenle, <wordasword>grup</wordasword>ları kullanarak:
   </para><itemizedlist>
    <listitem>
Bir <link linkend="regexinfo-Alternation-Operator">VEYA işlecinin</link> veya bir <link linkend="regexinfo-Repetition-Operators">yineleme işlecinin</link> argümanlarını sınırlarsınız.
    </listitem><listitem><para>
Verilen grup ile eşleşen bir alt dizgenin indislerinin izini sürebilirsiniz. Daha ayrıntılı bir açıklama için <xref linkend="regexinfo-Using-Registers"/> bölümüne bakınız. Bu sizin:
     </para><para>
     <itemizedlist>
      <listitem>
<link linkend="regexinfo-Back-reference-Operator">adres işlecini</link>
      </listitem><listitem>
<link linkend="regexinfo-Using-Registers">yazmaçları</link>
      </listitem></itemizedlist>
      </para><para>kullanmanızı sağlar.
     </para></listitem></itemizedlist><para>
Eğer <literal>RE_NO_BK_PARENS</literal> sözdizimi biti bir ise, <command>(</command> karakteri grup başlatma işlecini, <command>)</command> karakteri de grup sonlandırma işlecini temsil eder; aksi takdirde bunlar, <command>\(</command> ve <command>\)</command> ile temsil edilir.
   </para><para>
Eğer <literal>RE_UNMATCHED_RIGHT_PAREN_ORD</literal> sözdizimi biti bir ise ve
grup sonlandırma işleci için bir grup başlatma işleci yoksa, Regex onu <command>)</command> ile (yani kendisi ile) eşleştirir.
   </para></sect1>
  <sect1 xml:id="regexinfo-Back-reference-Operator">
   <title>Grup Adresleme İşleci</title>
   <titleabbrev><command>\</command><varname>rakam</varname></titleabbrev>
<indexterm scope="regexinfo-cp"><primary>grupların adreslenmesi</primary></indexterm>
   <para>
Şayet, <literal>RE_NO_BK_REF</literal> sözdizimi biti bir ise, Regex adreslemeleri tanır. Bir adres, evvelce belirtilmiş bir grup ile eşleştirilir. Grup adresleme işleci, bir düzenli ifadenin <varname>rakam</varname>'ıncı <link linkend="regexinfo-Grouping-Operators">grubundan</link> sonra herhangi bir yere yerleştirilmiş bir <command>\</command><varname>rakam</varname> ile temsil edilir.
   </para><para>
<varname>rakam</varname>, <command>1</command>'den <command>9</command>'a kadar bir rakam olmalıdır.  Eşleştirici, saptadığı ilk 9 gruba bu numaraları atar. <command>\1</command>'den <command>\9</command>'a kadar herhangi bir işleci, kendisine karşı düşen grubun grup sonlandırma işlecinden sonra kullanarak, grubun eşleştiği alt dizge ile işleşen bir grup gibi kullanılabilir. Yani bir grubu tekrar tekrar yazmak yerine sadece grup adresleme işlecini kullanmak yeterli olur.
   </para><para>
Grup adresleme işleçleri aşağıdaki kurallara göre eşleşirler (aşağıdaki örneklerde <command>(</command> karakteri grup başlatma işleci, <command>)</command> karakteri grup sonlandırma işleci, <command>{</command> karakteri sınırlı sayıda yineleme başlatma işleci ve <command>}</command> karakteri sınırlı sayıda yineleme sonlandırma işleci olarak kullanılmıştır.):
   </para><itemizedlist>
    <listitem><para>
Şayet grup bir alt dizge ile eşleşiyorsa,  adres benzer bir alt dizge ile eşleşir. Örneğin; <command>(a)\1</command> ifadesi <command>aa</command> ile eşleşirken <command>(bana)na\1bo\1</command> ifadesi <command>bananabanabobana</command> ile eşleşir.  Aynı şekilde, <command>(.*)\1</command> ifadesi (<literal>RE_DOT_NEWLINE</literal> sözdizimi biti sıfır ise satırsonu karakteri ile eşleşmez) herhangi bir iki aynı parçadan oluşan dizge ile eşleşir; <command>(.*)</command> dizgenin ilk bölümü ile <command>\1</command> ise ikinci bölümü ile eşleşir.
     </para></listitem><listitem><para>
Şayet grup defalarca eşleştiriliyorsa (arkasında bir yineleme işleçi olabilir), adres grupla en son eşleşen alt dizge ile eşleşir. Örneğin;  <command>((a*)b)*\1\2</command> ifadesi <command>aabababa</command> ile eşleşir; ilk grup 1 (dıştaki olan), <command>aab</command> ile ve grup 2 (içteki), <command>aa</command> ile eşleşir.  Daha sonra grup 1 <command>ab</command> ile ve grup 2 <command>a</command> ile eşleştirilir.  Böylece, <command>\1</command> parçası <command>ab</command> ile ve <command>\2</command> parçası <command>a</command> ile eşleşmiş olur.
     </para></listitem><listitem><para>
Şayet grup bir eşleşmeye katılmıyorsa, Örneğin: eşleşmeyen bir VEYA işlecinin bir parçası veya sıfır kere yineleme yapan bir yineleme işleçinin bir parçası olabilir, bu durumda adres bütün eşleşmelerde başarısız olur. Örneğin, <command>(one()|two())-and-(three\2|four\3)</command> ifadesi <command>one-and-three</command> ve <command>two-and-four</command> ile eşleşir, fakat asla <command>one-and-four</command> veya
<command>two-and-three</command> ile eşleşmez. Örneğin ifade, <command>one-and-</command> ile eşleşirse 2. grup boş dizge ile eşleşirken 3. grup eşleşmeye konu olmaz. Bu durumda <command>four</command> ile eşleşme olsa bile, 3.grup ile eşleşme arandığında (çünkü ifadede <command>\3</command>, <command>four</command> ile birlikte verilmiştir), 3. grup bir eşleşmeye konu olmadığından <command>four</command> ile eşleşme başarısız olacaktır.
     </para></listitem></itemizedlist><para>
Bir grup adresleme işleci bir yineleme işlecine argüman olarak kullanılabilir.
Örneğin; <command>(a(b))\2*</command> ifadesi, <command>a</command> ve <command>a</command>'dan sonra gelen iki veya daha fazla <command>b</command> ile eşleşir. Benzer şekilde, <command>(a(b))\2{3}</command> ifadesi <command>abbbb</command> ile eşleşir.
   </para><para>
Bir <varname>rakam</varname>'ıncı grup yoksa düzenli ifade geçersiz olur.
   </para></sect1>
  <sect1 xml:id="regexinfo-Anchoring-Operators">
   <title>Demirleme İşleçleri</title>
   <titleabbrev><command>^</command> ve <command>$</command></titleabbrev>
<indexterm scope="regexinfo-cp"><primary>demirleme</primary></indexterm>
   <para>
Bu tür işleçler bir şablonu, bir dizgenin sadece başlangıcı veya bitimi ile ya da bir satırın başlangıcı veya bitimi ile eşleşmeye zorlarlar.
   </para>
   <sect2 xml:id="regexinfo-Match-beginning-of-line-Operator" chunkthis="1">
    <title>Satır başı ile eşleşme işleci</title>
    <titleabbrev><command>^</command> karakteri</titleabbrev>
<indexterm scope="regexinfo-cp"><primary><command>^</command></primary></indexterm>
<indexterm scope="regexinfo-cp"><primary>satır başı işleci</primary></indexterm>
<indexterm scope="regexinfo-cp"><primary>çapalar</primary></indexterm>
   <para>
Bu işleç, bir satırsonu karakterini izleyen boş bir dizge ile eşleşebilir. Bu durumda, şablon satırın başına <wordasword>demirlemiştir</wordasword> denebilir.
    </para><para>
Aşağıda açıklanan durumlarda, <command>^</command> karakteri bu işleci  temsil eder. Diğer durumlarda, <command>^</command> sıradandır.
    </para><itemizedlist>
     <listitem>
<command>^foo</command> örneğindeki gibi <command>^</command>, şablondaki ilk karakter ise.
     </listitem><listitem>
<indexterm scope="regexinfo-cp"><primary><literal>RE_CONTEXT_INDEP_ANCHORS</literal> ve <command>^</command></primary></indexterm>
<literal>RE_CONTEXT_INDEP_ANCHORS</literal> sözdizimi biti bir ise ve bir köşeli ayraçlı ifade dışında ise.
     </listitem><listitem>
<indexterm scope="regexinfo-cp"><primary>grup başlatma işleci ve <command>^</command></primary></indexterm>
<indexterm scope="regexinfo-cp"><primary>VEYA işleci ve <command>^</command></primary></indexterm>
<command>a\(^b\)</command> ve <command>a\|^b</command> örneklerindeki gibi,
bir <link linkend="regexinfo-Grouping-Operators">grup başlatma işlecinden</link> ya da bir <link linkend="regexinfo-Alternation-Operator">VEYA işlecinden</link> hemen sonra geliyorsa.
</listitem></itemizedlist><para>
Bu kurallar eşleştirilemeyen <command>^</command> içeren geçerli şablonlara uygulanır; örneğin, <literal>RE_CONTEXT_INDEP_ANCHORS</literal> sözdizimi biti bir ise <command>foo^bar</command> ifadesindeki <command>^</command> satır başı ile eşleşme işleci olarak değerlendirilir.
    </para><para>
<indexterm scope="regexinfo-cp"><primary>şablon tamponu</primary><secondary><literal>not_bol</literal> alanı</secondary></indexterm>
<link linkend="regexinfo-GNU-Pattern-Buffers">Şablon tamponunda</link> <command>not_bol</command> alanı bir ise, <command>^</command> işleci dizgenin başlangıcı ile eşleştirilirken başarısız olur. Bunu kullanışlı buluyorsanız, <xref linkend="regexinfo-POSIX-Matching"/> bölümüne bakınız.
    </para><para>
<indexterm scope="regexinfo-cp"><primary>şablon tamponu</primary><secondary><literal>newline_anchor</literal> alanı</secondary></indexterm>
<link linkend="regexinfo-GNU-Pattern-Buffers">Şablon tamponunda</link> <command>newline_anchor</command> alanı bir ise, <command>^</command> işleci bir satırsonu karakterinden sonrasına eşleştirilirken başarısız olur. Bu, içinde satırsonu karakteri bulunan hatalı satırların gözardı edilmesini istediğiniz durumlarda yararlıdır.
    </para></sect2>
   <sect2 xml:id="regexinfo-Match-end-of-line-Operator" chunkthis="1">
    <title>Satır sonu ile eşleşme işleci</title>
    <titleabbrev><command>$</command> karakteri</titleabbrev>
<indexterm scope="regexinfo-cp"><primary><command>$</command></primary></indexterm>
<indexterm scope="regexinfo-cp"><primary>satır sonu işleci</primary></indexterm>
<indexterm scope="regexinfo-cp"><primary>çapalar</primary></indexterm>
    <para>
Bu işleç, bir satırsonu karakterinden önceki boş bir dizge ile eşleşebilir. Bu durumda, şablon satırın sonuna <wordasword>demirlemiştir</wordasword> denebilir.
    </para><para>
Daima <command>$</command> ile temsil edilir. Örneğin, <command>foo$</command> ifadesi tek başına <command>foo</command> dizgesi ile ya da örneğin <command>foo\nbar</command> dizgesinin ilk üç karakteri ile eşleşir.
    </para><para>
Sözdizimi bitleri ve şablon tampon alanları ile etkileşimi, tam olarak, <command>^</command> işlecinin tersidir; önceki bölüme göz atınız  ("ilk" yerine "son", "sonra" yerine "önce" ve "başlama" yerine "sonlandırma" getirerek).
    </para></sect2></sect1>
</chapter>
<chapter xml:id="regexinfo-GNU-Operators">
  <title>GNU İşleçleri</title>
  <para>
Bu kısımdaki işleçler GNU tarafından tanımlanmıştır (ve POSIX ile uyumsuzdur).
  </para>
  <sect1 xml:id="regexinfo-Word-Operators">
   <title>Sözcük İşleçleri</title>
   <para>
Bu bölümdeki işleçler Regex'in sözcük parçalarını tanıması ile ilgilidir. Regex, bir karakterin bir sözcüğün parçası olup olmadığını anlamak için bir sözdizimi tablosu kullanır, yani bir karakterin bir sözcüğün öğesi olup olmadığına bakar.
   </para>
   <sect2 xml:id="regexinfo-Non-Emacs-Syntax-Tables" chunkthis="1">
    <title>Emacs-dışı Sözdizimi Tabloları</title>
    <para>
Bir <wordasword>sözdizimi tablosu</wordasword>, kullandığınız karakter kümesindeki karakterlere göre indislenmiş bir dizidir. Bu nedenle, ASCII kodlamada, bir sözdizimi tablosu 256 adet eleman içerir. Regex, sözdizimi tablosu olarak <command>char *</command> türünde olan <command>re_syntax_table</command> değişkenini kullanır. Bazı durumlarda değişkeni kendisi ilklendirir, bazı durumlarda da sizin ilklendireceğinizi umar.
    </para><itemizedlist>
     <listitem><para>
Regex, <command>emacs</command> ve <literal>SYNTAX_TABLE</literal> önişlemci sembolleri tanımsız (#undefine) olarak derlenmişse, <command>re_syntax_table</command> değişkeni için bellek ayırır ve bir <varname>i</varname> elemanı ile ilklendirir. Bu ilklendirme <varname>i</varname> elemanı bir harf, rakam ya da <command>_</command> ise <command>Sword</command> değilse sıfır değeri ile yapılır.
      </para></listitem><listitem><para>
Regex, <command>emacs</command> tanımsız ancak <literal>SYNTAX_TABLE</literal> tanımlı olarak derlenmişse, Regex, geçerli bir sözdizimi tablosu olarak <command>re_syntax_table</command> değişkenini <command>char *</command> türünde sizin tanımlayacağınızı umar.
      </para></listitem><listitem><para>
Regex'in <command>emacs</command> önişlemci sembolünün tanımlanarak derlenmesi ile ilgili durum <xref linkend="regexinfo-Emacs-Syntax-Tables"/> bölümünde açıklanmıştır.
      </para></listitem></itemizedlist>
</sect2><sect2 xml:id="regexinfo-Match-word-boundary-Operator" chunkthis="1">
    <title>Sözcük sınırlarıyla eşleşme işleci (<literal>\b</literal>)</title>
<indexterm scope="regexinfo-cp"><primary><command>\b</command></primary></indexterm>
<indexterm scope="regexinfo-cp"><primary>sözcük sınırlarıyla eşleşme</primary></indexterm>
    <para>
Bu işleç (<command>\b</command> ile temsil edilir) bir sözcüğün başındaki ya da sonundaki boş dizge ile eşleşir. Örneğin, <command>\brat\b</command> ifadesi tek başına bir sözcük olarak <command>rat</command> ile eşleşir.
    </para></sect2>
   <sect2 xml:id="regexinfo-Match-within-word-Operator" chunkthis="1">
    <title>Sözcük-içi eşleşme işleci (<literal>\B</literal>)</title>
<indexterm scope="regexinfo-cp"><primary><command>\B</command></primary></indexterm>
    <para>
Bu işleç (<command>\B</command> ile temsil edilir) bir sözcüğün içindeki boş dizge ile eşleşir. Örneğin, <command>c\Brat\Be</command> ifadesi <command>crate</command> ile eşleşirken, <command>dirty \Brat</command> ifadesi <command>dirty rat</command> dizgesiyle eşleşmez.
    </para></sect2>
   <sect2 xml:id="regexinfo-Match-beginning-of-word-Operator" chunkthis="1">
    <title>Sözcük başlangıcıyla eşleşme işleci (<literal>\&lt;</literal>)</title>
<indexterm scope="regexinfo-cp"><primary><command>\&lt;</command></primary></indexterm>
    <para>
Bu işleç (<command>\&lt;</command> ile temsil edilir) bir sözcüğün başındaki boş dizge ile eşleşir.
    </para></sect2>
   <sect2 xml:id="regexinfo-Match-end-of-word-Operator" chunkthis="1">
    <title>Sözcük sonuyla eşleşme işleci (<literal>\&gt;</literal>)</title>
<indexterm scope="regexinfo-cp"><primary><command>\&gt;</command></primary></indexterm>
    <para>
Bu işleç (<command>\&gt;</command> ile temsil edilir) bir sözcüğün sonundaki boş dizge ile eşleşir.
    </para></sect2>
   <sect2 xml:id="regexinfo-Match-word-constituent-Operator" chunkthis="1">
    <title>Sözcük bileşenleriyle eşleşme işleci (<literal>\w</literal>)</title>
<indexterm scope="regexinfo-cp"><primary><command>\w</command></primary></indexterm>
    <para>
Bu işleç (<command>\w</command> ile temsil edilir) bir sözcüğün öğesi olan herhangi bir karakter ile eşleşir.
    </para></sect2>
   <sect2 xml:id="regexinfo-Match-non-word-constituent-Operator" chunkthis="1">
    <title>Sözcük bileşeni olmayanlarla eşleşme işleci (<literal>\W</literal>)</title>
<indexterm scope="regexinfo-cp"><primary><command>\W</command></primary></indexterm>
    <para>
Bu işleç (<command>\W</command> ile temsil edilir) bir sözcüğün öğesi olmayan herhangi bir karakter ile eşleşir.
    </para></sect2></sect1>
  <sect1 xml:id="regexinfo-Buffer-Operators">
   <title>Tampon İşleçleri</title>
   <para>
Bu bölümdeki işleçler tamponlarla çalışır. Emacs için bir <wordasword>tampon</wordasword> doğal olarak bir Emacs tamponudur. Diğer uygulamalar için ise Regex, eşleştirilecek dizgenin tamamının tampon olduğunu varsayar.
   </para>
   <sect2 xml:id="regexinfo-Match-beginning-of-buffer-Operator" chunkthis="1">
    <title>Tampon başlangıcıyla eşleşme işleci (<literal>\`</literal>)</title>
<indexterm scope="regexinfo-cp"><primary><command>\`</command></primary></indexterm>
    <para>
Bu işleç (<command>\`</command> ile temsil edilir) tamponun başlangıcındaki boş dizge ile eşleşir.
    </para></sect2>
   <sect2 xml:id="regexinfo-Match-end-of-buffer-Operator" chunkthis="1">
    <title>Tampon sonuyla eşleşme işleci (<literal>\'</literal>)</title>
<indexterm scope="regexinfo-cp"><primary><command>\'</command></primary></indexterm>
    <para>
Bu işleç (<command>\'</command> ile temsil edilir) tamponun sonundaki boş dizge ile eşleşir.
    </para></sect2></sect1>
</chapter>
 <chapter xml:id="regexinfo-GNU-Emacs-Operators">
  <title>GNU Emacs İşleçleri</title>
  <para>
Aşağıdaki işleçler Regex'in sadece <command>emacs</command> önişlemci sembolü tanımlanarak  derlenmesi halinde kullanabileceğiniz GNU tarafından tanımlanmış ancak POSIX uyumlu olmayan işleçlerdir.
  </para>
  <sect1 xml:id="regexinfo-Syntactic-Class-Operators">
   <title>Sözdizimsel Sınıf İşleçleri</title>
   <para>
Bu bölümdeki işleçler, Regex’in karakterlerin sözdizimsel sınıflarını tanımasına ihtiyaç duyarlar. Regex bunları tanıyabilmek için bir sözdizimi tablosu kullanır.
   </para>
   <sect2 xml:id="regexinfo-Emacs-Syntax-Tables" chunkthis="1">
    <title>Emacs Sözdizimi Tabloları</title>
    <para>
Bir <wordasword>sözdizimi tablosu</wordasword>, sizin karakter kümenizdeki karakterler tarafından indislenmiş bir dizidir. Bu nedenle, ASCII kodlama sisteminde, bir sözdizimi tablosu 256 adet elemana sahiptir.
    </para><para>
Şayet Regex <command>emacs</command> önişlemci sembolü tanımlanarak derlenmişse, Regex sizin <command>re_syntax_table</command>  değişkenini bir Emacs sözdizimi tablosu olarak tanımlamanızı ve bu tabloyu ilklendirmenizi bekler.  Emacs sözdizimi tabloları <link linkend="regexinfo-Non-Emacs-Syntax-Tables">Regex’inkinden</link> bile daha karmaşıktırlar.  Emacs’ın sözdizimi tablolarının tarifi için <xref linkend="regexinfo-Emacs-Syntax-Tables"/> bölümüne bakınız.
    </para></sect2>
   <sect2 xml:id="regexinfo-Match-syntactic-class-Operator" chunkthis="1">
    <title>Sözdizimsel Sınıfları Eşleştirme İşleçi</title>
    <titleabbrev><command>\s</command><varname>sınıf</varname></titleabbrev>
<indexterm scope="regexinfo-cp"><primary><command>\s</command></primary></indexterm>
    <para>
Bu işleç, sözdizimsel sınıfı belirli bir karakter ile temsil edilen herhangi bir karakteri eşleştirebilir. <command>\s</command><varname>sınıf</varname> şeklinde kullanılır. Buradaki <varname>sınıf</varname> istediğiniz sözdizimsel sınıfı temsil eden karakterdir. Örneğin; <command>w</command>, sözcük bileşeni olan karakterlerinin sözdizimsel sınıfını temsil eder. Bu nedenle  <command>\sw</command> herhangi bir sözcük bileşeni karakter ile eşleşebilir.
    </para></sect2>
   <sect2 xml:id="regexinfo-Match-not-syntactic-class-Operator" chunkthis="1">
    <title>Sözdizimsel Olmayan Sınıfları Eşleştirme İşleçi</title>
    <titleabbrev><command>\S</command><varname>sınıf</varname></titleabbrev>
<indexterm scope="regexinfo-cp"><primary><command>\S</command></primary></indexterm>
    <para>
Bu işleç Sözdizimsel sınıfları eşleştirme işleçine benzerdir ama tek farkı sözdizimsel sınıfın özel bir karakter ile temsil edilmediği durumlarda eşleştirme yapmasıdır. Bu işleç <command>\S</command><varname>sınıf</varname> ile temsil edilir. Örneğin, <command>w</command> sözcük bileşeni karakterlerin sözdizimsel sınıfını temsil eder, böylece <command>\Sw</command> sözcük bileşeni olmayan herhangi bir karakter ile eşleşir.
    </para></sect2></sect1>
</chapter>
<chapter xml:id="regexinfo-What-Gets-Matched-">
  <title>Ne Eşleştirilir?</title>
  <para>
Regex, genellikle, dizgeleri "en soldaki en uzun" kuralına göre eşleştirir; yani, en soldaki en uzun eşleşmeyi seçer. Tabii ki bu alt ifadeler içeren bir düzenli ifadenin basitçe her alt ifade için soldan sağa en uzun eşleştirmeyi seçtiği anlamına gelmez. Ana düzenli ifade içindeki genel eşleşmenin mümkün olan en uzun eşleşme olması da gereklidir.
  </para><para>
Örneğin: <command>(ac*)(c*d[ac]*)\1</command> ifadesi, <command>acdacaaa</command> ile eşleşir, ilk alt ifade içindeki en uzun eşleşme olan <command>acdac</command> ile değil.
  </para></chapter>


 <chapter xml:id="regexinfo-Programming-with-Regex">
  <title>Regex ile Yazılım Geliştirme</title>
  <para>
Bu bölümde Regex veri yapılarını ve işlevlerini C yazılımları içerisinde nasıl kullanacağınız açıklanmaktadır. Regex üç tane arayüze sahiptir: biri GNU için tasarlanmıştır, biri POSIX uyumludur ve öteki Berkeley UNIX uyumlu olanıdır.
  </para>
  <sect1 xml:id="regexinfo-GNU-Regex-Functions">
   <title>GNU Regex İşlevleri</title>
   <para>
Şayet POSIX veya Berkeley UNIX ile uyumlu olmak zorunda olmayan kodlar yazıyorsanız, bu işlevleri kullanabilirsiniz. Bunlar diğer arayüzlerden daha fazla seçeneğe sahiptirler. (Ç.N. -- Özellikle eşleşmeleri arayacağınız dizge Türkçe'ye özgü karakterler içeriyorsa, bu arayüzü kullanmak kaçınılmazdır.)
   </para>
   <sect2 xml:id="regexinfo-GNU-Pattern-Buffers" chunkthis="1">
    <title>GNU Şablon Tamponları</title>
    <titleabbrev><command>re_pattern_buffer</command> türü.</titleabbrev>
<indexterm scope="regexinfo-cp"><primary>şablon tamponları</primary><secondary>tanımlanması</secondary></indexterm>
<indexterm scope="regexinfo-cp"><primary><literal>re_pattern_buffer</literal> tanımı</primary></indexterm>
<indexterm scope="regexinfo-cp"><primary><literal>struct re_pattern_buffer</literal> tanımı</primary></indexterm>
    <para>
Verilen bir düzenli ifadenin derlenmesi, eşleştirilmesi veya araştırılması için bir şablon tamponu yaratmak zorundasınızdır.  Bir <wordasword>şablon tamponu</wordasword> derlenmiş bir düzenli ifadeyi tutar.<footnote><para>Düzenli İfadeler, “şablon tamponu” isminden dolayı “şablonlar/kalıplar” olarak da adlandırılır.</para></footnote>
    </para><para>
Aynı anda birden çok ve farklı şablon tamponuna sahip olabilirsiniz, her biri değişik bir düzenli ifade için derlenmiş bir şablonu tutabilir.
    </para><para xml:id="regexinfo-re_pattern_buffer">
<indexterm scope="regexinfo-cp"><primary><literal>re_pattern_buffer</literal> türü</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü">
<funcdef>struct <command>re_pattern_buffer</command></funcdef>
</funcprototype><funcdescr><para>
<filename>regex.h</filename> şablon tamponu yapısını aşağıda belirtilen şekilde  tanımlar:
    </para><glosslist><glossentry>
      <glossterm><literal>unsigned char *</literal><command>buffer</command></glossterm>
      <glossdef><para>
Derlenmiş şablonu tutan tampon. <literal>unsigned char *</literal> şeklinde bildirilir, çünkü elemanları bazen dizi indisleri olarak kullanılır.
      </para></glossdef></glossentry><glossentry>
      <glossterm><literal>unsigned long </literal><command>allocated</command></glossterm>
      <glossdef><para>
Tampon için ayrılan baytların sayısı.
      </para></glossdef></glossentry><glossentry>
      <glossterm><literal>unsigned long </literal><command>used</command></glossterm>
      <glossdef><para>
Tampon içinde kullanılmış bayt sayısı.
      </para></glossdef></glossentry><glossentry>
      <glossterm><literal>reg_syntax_t </literal><command>syntax</command></glossterm>
      <glossdef><para>
Şablonun birlikte derlendiği sözdizimi ayarları.
      </para></glossdef></glossentry><glossentry>
      <glossterm><literal>char *</literal><command>fastmap</command></glossterm>
      <glossdef><para>
Varsa bir hızlı eşleme gösterici, aksi takdirde sıfır. Eşleşmelerin imkansız başlangıç noktalarını atlamak için varsa <command>fastmap</command>, <command>re_search</command> işlevi tarafından kullanılır.
      </para></glossdef></glossentry><glossentry>
      <glossterm><literal>char *</literal><command>translate</command></glossterm>
      <glossdef><para>
Karşılaştırma öncesi tüm karakterlere uygulanacak çeviri tablosu, çeviri yoksa sıfır. Çeviri, derlenirken şablona ve eşleştirilirken dizgeye uygulanır.
      </para></glossdef></glossentry><glossentry>
      <glossterm><literal>size_t </literal><command>re_nsub</command></glossterm>
      <glossdef><para>
Derleyici tarafından bulunan alt ifadelerin sayısı.
      </para></glossdef></glossentry><glossentry>
      <glossterm><literal>unsigned </literal><command>can_be_null</command></glossterm>
      <glossdef><para>
Bu şablon boş dizgeyi eşleştiremezse sıfır yoksa bir. Aslında sadece, <command>fastmap</command> kullanmamızın gerekip gerekmeyeceğini saptamak için <command>re_search_2</command> işlevi tarafından kullanılır. Bu nedenle bunu mükemmel olarak ayarlayamadık; <xref linkend="regexinfo-Searching-with-Fastmaps"/> bölümüne bakınız.
      </para></glossdef></glossentry><glossentry>
      <glossterm><literal>unsigned </literal><command>regs_allocated</command></glossterm>
      <glossdef><para>
<literal>REGS_UNALLOCATED</literal> tanımlıysa, <literal>max (RE_NREGS, re_nsub + 1)</literal> grup için <command>regs</command> yapısı içinde yer ayrılır. <literal>REGS_REALLOCATE</literal> tanımlıysa, gerekliyse yer yeniden ayrılır. <literal>REGS_FIXED</literal> tanımlıysa, olan kullanılır; bu öntanımlıdır.
      </para><para>
<screen>#define REGS_UNALLOCATED 0
#define REGS_REALLOCATE 1
#define REGS_FIXED 2
</screen>
      </para></glossdef></glossentry><glossentry>
      <glossterm><literal>unsigned </literal><command>fastmap_accurate</command></glossterm>
      <glossdef><para>
<command>regex_compile</command> işlevi ile bir şablonu derlediğiniz zaman sıfır olur; şayet <command>fastmap</command>, <command>re_compile_fastmap</command> işlevi ile güncellenirse bir olur.
      </para></glossdef></glossentry><glossentry>
      <glossterm><literal>unsigned </literal><command>no_sub</command></glossterm>
      <glossdef><para>
Birse, <command>re_match_2</command> işlevi alt ifadeler hakkında bilgi döndürmez.
      </para></glossdef></glossentry><glossentry>
      <glossterm><literal>unsigned </literal><command>not_bol</command></glossterm>
      <glossdef><para>
Bir ise satır başı ile eşleşme işleci dizgenin başlangıcıyla eşleşmez. Öntanımlı değeri 1'dir.
      </para></glossdef></glossentry><glossentry>
      <glossterm><literal>unsigned </literal><command>not_eol</command></glossterm>
      <glossdef><para>
Satır sonu ile eşleşme işleci için <command>not_bol</command> alanına benzer.
      </para></glossdef></glossentry><glossentry>
      <glossterm><literal>unsigned </literal><command>newline_anchor</command></glossterm>
      <glossdef><para>
Birse, demir, satırsonu karakteri ile eşleşir. Öntanımlı değeri 1'dir.
      </para></glossdef></glossentry>
    </glosslist></funcdescr></funcsynopsis></para>
   </sect2>
   <sect2 xml:id="regexinfo-GNU-Regular-Expression-Compiling" chunkthis="1">
     <title>GNU Düzenli İfadesinin Derlenmesi</title>
     <titleabbrev><command>re_compile_pattern()</command> işlevi</titleabbrev>
      <para>
GNU’da, belirtilmiş olan bir düzenli ifade için hem eşleme hem de arama yapabilirsiniz. Bunu yapmak için, öncelikle onu bir <link linkend="regexinfo-GNU-Pattern-Buffers">şablon tamponu</link> içinde derlemelisiniz.
    </para><para xml:id="regexinfo-re_syntax_options">
<indexterm scope="regexinfo-cp"><primary>sözdizimi ilklendirmesi</primary></indexterm>
<indexterm scope="regexinfo-cp"><primary><literal>re_syntax_options</literal> ilklendirmesi</primary></indexterm>
<indexterm scope="regexinfo-cp"><primary><literal>re_syntax_options</literal> değişkeni</primary></indexterm>
<funcsynopsis><funcprototype role="değişken">
<funcdef><command>re_syntax_options</command></funcdef>
</funcprototype><funcdescr><para>
Düzenli ifadeler birlikte derlendikleri söz dizimlerine göre eşleşirler; GNU‘da, <command>re_compile_pattern</command> derleme işlevi çağrılmadan önce, <command>re_syntax_options</command> değişkeni (<filename>regex.h</filename> içinde bildirilmiş ve <filename>regex.c</filename> içinde tanımlanmıştır) ile hangi sözdizimini istediğinizi belirtebirsiniz. <xref linkend="regexinfo-Syntax-Bits"/> ve
<xref linkend="regexinfo-Predefined-Syntaxes"/> bölümlerine bakınız.
    </para><para>
<command>re_syntax_options</command> değişkeninin değerini istediğiniz zaman değiştirebilirsiniz. Ancak, genellikle, değeri bir kere atanır ve bir daha değiştirilmez.
</para></funcdescr></funcsynopsis></para><para>
<indexterm scope="regexinfo-cp"><primary>şablon tamponu</primary><secondary>tamponun ilklendirilmesi</secondary></indexterm>
<command>re_compile_pattern</command> işlevi argüman olarak <command>struct re_pattern_buffer</command> türünde bir <varname>şablon_tamponu</varname> alır. Aşağıdaki alanları ilklendirmelisiniz:
    </para><variablelist>
<indexterm scope="regexinfo-cp"><primary><literal>translate</literal> ilklendirmesi</primary></indexterm>
    <varlistentry>
      <term><literal>translate</literal></term>
      <listitem><para>
Bir çeviri tablosunu göstermesini istiyorsanız bir ile, istemiyorsanız sıfır ile ilklendirin. Çeviri tabloları, <xref linkend="regexinfo-GNU-Translate-Tables"/> bölümünde açıklanmıştır.
      </para></listitem>
     </varlistentry>
<indexterm scope="regexinfo-cp"><primary><literal>fastmap</literal> ilklendirmesi</primary></indexterm>
     <varlistentry>
      <term><literal>fastmap</literal></term>
      <listitem><para>
Bir hızlı eşlem istiyorsanız bir ile istemiyorsanız sıfır ile ilklendirin.
      </para></listitem>
     </varlistentry>
<indexterm scope="regexinfo-cp"><primary><literal>buffer</literal> ilklendirmesi</primary></indexterm>
<indexterm scope="regexinfo-cp"><primary><literal>allocated</literal> ilklendirmesi</primary></indexterm>
<indexterm scope="regexinfo-cp"><primary><literal>malloc</literal></primary></indexterm>
     <varlistentry>
      <term><literal>buffer</literal></term>
      <term><literal>allocated</literal></term>
      <listitem><para>
<command>re_compile_pattern</command> işlevinin derlenmiş şablon için bellek ayırmasını istiyorsanız bunların her ikisini de sıfır ile ilklendirin. Daha önce <command>malloc</command> ile ayırdığınız bir bellek bloğu varsa ve Regex'in bunu kullanmasını istiyorsanız, adresi ile <command>buffer</command>'ı genişliği ile de
<command>allocated</command>'i ilklendirin:
       </para><para>
<screen>struct re_pattern_buffer buf;

buf.allocated = 1;
buf.buffer = xmalloc (buf.allocated);
</screen>
       </para><para>
<command>re_compile_pattern</command> işlevi, gerektiği takdirde ayrılan bloğu genişletmek için <command>realloc</command> işlevini kullanacaktır.
      </para></listitem>
     </varlistentry></variablelist><para xml:id="regexinfo-re_compile_pattern">
<indexterm scope="regexinfo-cp"><primary><literal>re_compile_pattern</literal> işlevi</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>char *<command>re_compile_pattern</command></funcdef>
<paramdef>(const char               *<varname>düzenli_ifade</varname>,
 const int                *<varname>ifade_boyutu</varname>,
 struct re_pattern_buffer *<varname>şablon_tamponu</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bir şablon tamponunu derlemek için kullanılır.
      </para><para>
<varname>düzenli_ifade</varname> düzenli ifadenin adresidir, <varname>ifade_boyutu</varname> ifadenin uzunluğu ve
<varname>şablon_tamponu</varname> da şablon tamponunun adresidir.
      </para><para>
<command>re_compile_pattern</command> işlevi şablon tamponunu başarıyla derlerse sıfır ile döner ve <literal>*<emphasis>şablon_tamponu</emphasis></literal> derlenen tamponu gösterir.  Şablon tamponunun işlev tarafından ayarlanan alanları:
      </para><variablelist>
<indexterm scope="regexinfo-cp"><primary>şablon tamponu</primary><secondary><literal>buffer</literal> alanı</secondary><tertiary><literal>re_compile_pattern</literal> ile ilklendirilmesi</tertiary></indexterm>
       <varlistentry>
         <term><literal>buffer</literal></term>
         <listitem><para>
derlenen şablon ile ilkendirilir.
         </para></listitem>
       </varlistentry>
<indexterm scope="regexinfo-cp"><primary>şablon tamponu</primary><secondary><literal>used</literal> alanı</secondary><tertiary><literal>re_compile_pattern</literal> ile ilklendirilmesi</tertiary></indexterm>
       <varlistentry>
         <term><literal>used</literal></term>
         <listitem><para>
<varname>şablon_tamponu</varname> içindeki derlenmiş şablonun bayt cinsinden uzunluğu ile ilklendirilir.
         </para></listitem>
       </varlistentry>
<indexterm scope="regexinfo-cp"><primary>şablon tamponu</primary><secondary><literal>syntax</literal> alanı</secondary><tertiary><literal>re_compile_pattern</literal> ile ilklendirilmesi</tertiary></indexterm>
       <varlistentry>
         <term><literal>syntax</literal></term>
         <listitem><para>
<command>re_syntax_options</command> değişkeninin o anki değeri ile ilklendirilir.
         </para></listitem>
       </varlistentry>
<indexterm scope="regexinfo-cp"><primary>şablon tamponu</primary><secondary><literal>re_nsub</literal> alanı</secondary><tertiary><literal>re_compile_pattern</literal> ile ilklendirilmesi</tertiary></indexterm>
       <varlistentry>
         <term><literal>re_nsub</literal></term>
         <listitem><para>
<varname>düzenli_ifade</varname> içindeki alt ifadelerin sayısı ile ilklendirilir.
         </para></listitem>
       </varlistentry>
<indexterm scope="regexinfo-cp"><primary>şablon tamponu</primary><secondary><literal>fastmap_accurate</literal> alanı</secondary><tertiary><literal>re_compile_pattern</literal> ile ilklendirilmesi</tertiary></indexterm>
       <varlistentry>
         <term><literal>fastmap_accurate</literal></term>
         <listitem><para>
Teorik olarak <varname>şablon_tamponu</varname> içine derlediğiniz şablon bir önceki derlemeden farklı olacağından sıfırla ilklendirilir; bu durumda (bir derlenmiş şablon olmaksızın bir hızlı eşlem yapamayacağınızdan), <command>fastmap</command> ya uyumsuz bir hızlı eşlem içerecekti ya da hiçbir şey.
         </para></listitem>
       </varlistentry></variablelist><para>
<command>re_compile_pattern</command> işlevi <varname>düzenli_ifade</varname>'yi, derleyemezse, <xref linkend="regexinfo-POSIX-Regular-Expression-Compiling"/> bölümünde listesi verilen hatalardan birine karşılık olan bir hata dizgesi ile döner.
    </para></funcdescr></funcsynopsis></para>
   </sect2><sect2 xml:id="regexinfo-GNU-Matching" chunkthis="1">
    <title>GNU Eşleştirme İşlevi</title>
    <titleabbrev><command>re_match()</command></titleabbrev>
<indexterm scope="regexinfo-cp"><primary>GNU işlevleri ile eşleştirme</primary></indexterm>
    <para>
GNU yöntemi ile eşleştirmenin anlamı, belirtiğiniz bir yerden başlayarak bir dizgenin mümkün olan en çok karakteri ile eşleştirme yapmaya çalışmaktır.
</para><para xml:id="regexinfo-re_match">
<indexterm scope="regexinfo-cp"><primary><literal>re_match</literal> işlevi</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>re_match</command></funcdef>
<paramdef>(struct re_pattern_buffer *<varname>şablon_tamponu</varname>,
 const char               *<varname>dizge</varname>,
 const int                 <varname>boyut</varname>,
 const int                 <varname>başlangıç</varname>,
 struct re_registers      *<varname>yazmaçlar</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bir şablonu bir <link linkend="regexinfo-GNU-Regular-Expression-Compiling">şablon tamponuna derledikten</link> sonra bu işlevi kullarak bir dizgenin bu şablonla eşleştirilmesini isteyebilirsiniz.
      </para><para>
<varname>şablon_tamponu</varname> derlenmiş dezenli ifadeyi içeren tamponunun adresidir.  <varname>dizge</varname> eşleştirilmesini istediğiniz dizgedir ve satırsonu karakteri ile boş karakter içerebilir.  <varname>boyut</varname> bu dizgenin uzunluğudur. <varname>başlangıç</varname> eşleşmenin aranacağı dizge indisidir; <varname>dizge</varname> içindeki ilk karakterin indisi sıfırdır. Açıklamasını <xref linkend="regexinfo-Using-Registers"/> bölümünde bulacağınız <varname>yazmaçlar</varname> için güvenle sıfır değerini aktarabilirsiniz.
    </para><para>
<command>re_match</command> işlevi, <varname>şablon_tamponu</varname> içindeki düzenli ifadeyi, <varname>dizge</varname> dizgesi ile  <varname>şablon_tamponu</varname>'nun <command>syntax</command> alanı içindeki sözdizimine göre eşleştirir. (<command>syntax</command> alanının nasıl ilklendirildiğini öğrenmek için <xref linkend="regexinfo-GNU-Regular-Expression-Compiling"/> bölümüne bakınız.)
      </para><para>
İşlev, <varname>dizge</varname> dizgesinin hiçbir parçası ile eşleşme bulamazsa -1 ile, bir iç hata oluşursa -2 ile, aksi takdirde <varname>dizge</varname>  içinde şablonla eşleşen karakterlerin sayısı (sıfır olabilir) ile döner.
      </para><para>
Örnek: <varname>şablon_tamponu</varname>'nun <command>a*</command> ifadesi için derlenmiş şablonu içerdiğini, <varname>dizge</varname>'nin  <command>aaaaab</command> dizgesini gösterdiğini (burada <varname>boyut</varname> değeri 6 olmalıdır) varsayalım. <varname>başlangıç</varname> 2 ise, <command>re_match</command> 3 değeri ile döner, yani, <command>a*</command> ifadesi <varname>dizge</varname> içindeki son 3 <command>a</command> ile eşleşmiş olur. <varname>başlangıç</varname> 0 olsaydı dönen değer 5 olacaktı, yani, <command>a*</command> ifadesi <varname>dizge</varname> içindeki bütün <command>a</command>larla eşleşecekti. <varname>başlangıç</varname> 5 ya da 6 olsaydı işlev 0 ile dönecekti.
      </para><para>
Şayet <varname>başlangıç</varname> sıfırdan küçük ya da <varname>boyut</varname>'dan büyük verilirse işlev -1 ile döner.
      </para></funcdescr></funcsynopsis></para>
  </sect2><sect2 xml:id="regexinfo-GNU-Searching" chunkthis="1">
    <title>GNU Arama İşlevi</title>
    <titleabbrev><command>re_search()</command> işlevi</titleabbrev>
<indexterm scope="regexinfo-cp"><primary>GNU işlevleri ile arama</primary></indexterm>
    <para>
<wordasword>Arama</wordasword> bir dizge içindeki ardışık konumlarda eşleşmenin başlangıcının aranmasıdır. <command>re_search</command> işlevi bunu yapar.
    </para><para>
<command>re_search</command> işlevini çağırmadan önce <link linkend="regexinfo-GNU-Regular-Expression-Compiling">düzenli ifadenizi derlemeniz</link> gerekir.
</para><para xml:id="regexinfo-re_search">
<indexterm scope="regexinfo-cp"><primary><literal>re_search</literal> işlevi</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>re_search</command></funcdef>
<paramdef>(struct re_pattern_buffer *<varname>şablon_tamponu</varname>,
 const char               *<varname>dizge</varname>,
 const int                 <varname>boyut</varname>,
 const int                 <varname>başlangıç</varname>,
 const int                 <varname>aralık</varname>,
 struct re_registers      *<varname>yazmaçlar</varname>)</paramdef>
</funcprototype><funcdescr><para>
<varname>aralık</varname> argümanı dışında tüm argümanlar <link linkend="regexinfo-GNU-Matching"><command>re_match</command></link> işlevi ile aynıdır.
      </para><para>
<varname>aralık</varname> positifse, <command>re_search</command> ilk eşleşmeyi <varname>başlangıç</varname> ile belirtilen indiste arar, başarısız olursa <varname>başlangıç</varname> + 1'e geçer ve böyle ilerleyerek <varname>başlangıç</varname> + <varname>aralık</varname>'a kadar işlem tekrarlanır.
<varname>aralık</varname> negatifse, <command>re_search</command> ilk eşleşmeyi <varname>başlangıç</varname> ile belirtilen indiste arar, başarısız olursa <varname>başlangıç</varname> - 1'e geçer ve böyle gider.
      </para><para>
Şayet <varname>başlangıç</varname> sıfırdan küçük ya da <varname>boyut</varname>'dan büyük verilirse işlev -1 ile döner. <varname>aralık</varname> pozitifse, <command>re_search</command> <varname>aralık</varname> değerini gerekirse, <varname>başlangıç</varname> + <varname>aralık</varname> - 1, sıfır ile <varname>boyut</varname> arasında olacak şekilde ayarlar; bu durumda <varname>dizge</varname> dışında arama yapılmamış olur. Benzer şekilde, <varname>aralık</varname> negatifse, <command>re_search</command> <varname>aralık</varname> değerini gerekirse, <varname>başlangıç</varname> + <varname>aralık</varname> + 1, sıfır ile <varname>boyut</varname> arasında olacak şekilde ayarlar.
      </para><para>
Şayet <varname>şablon tamponu</varname>'nun <command>fastmap</command> alanı sıfırsa, <command>re_search</command> eşleştirme işlemini ardarda gelen konumlarda başlatır; aksi takdirde aramayı daha verimli kılmak için <command>fastmap</command>'i kullanır (Bakınız, <xref linkend="regexinfo-Searching-with-Fastmaps"/>).
      </para><para>
Bir eşleşme bulunmazsa, <command>re_search</command> -1 ile döner. Bulunursa, eşleşmenin başladığı yerin indisi ile döner. Bir iç hata oluşmuşsa -2 ile döner.
      </para></funcdescr></funcsynopsis></para>
  </sect2><sect2 xml:id="regexinfo-Matching-Searching-with-Split-Data" chunkthis="1">
    <title>Veriyi Bölerek Arama ve Eşleştirme</title>
    <titleabbrev><command>re_match_2()</command> ve <command>re_search_2()</command></titleabbrev>
    <para>
<command>re_match_2</command> ve <command>re_search_2</command> işlevlerini kullanarak, iki ayrı dizgeye bölünmüş veriler içinde eşleştirme ve arama yapabilirsiniz.
</para><para xml:id="regexinfo-re_match_2">
<indexterm scope="regexinfo-cp"><primary><literal>re_match_2</literal> işlevi</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>re_match_2</command></funcdef>
<paramdef>(struct re_pattern_buffer *<varname>şablon_tamponu</varname>,
 const char               *<varname>dizge1</varname>,
 const int                 <varname>boyut1</varname>,
 const char               *<varname>dizge2</varname>,
 const int                 <varname>boyut2</varname>,
 const int                 <varname>başlangıç</varname>,
 struct re_registers      *<varname>yazmaçlar</varname>,
 const int                 <varname>son</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>re_match_2</command> işlevi iki veri dizgesi ve bunların boyutları ile eşleştiricinin eşleştirme denemesi yapmasını istemedikleriniz için bir son indisi belirtilmesi dışında <link linkend="regexinfo-GNU-Matching"><command>re_match</command></link> işlevine benzer.  <command>re_match</command> işlevinde olduğu gibi, başarı durumunda dizgenin eşleşen karakter sayısı ile döner.  <varname>başlangıç</varname> ve
<varname>son</varname> argümanları belirtildiğinde ve  <varname>yazmaçlar</varname>'ın içeriği kullanıldığında <varname>dizge1</varname> ve
<varname>dizge2</varname> birleşik sayılır; <command>re_match_2</command> asla
<varname>boyut1</varname> + <varname>boyut2</varname>'den daha büyük bir değerle dönmez.
</para></funcdescr></funcsynopsis>
</para><para xml:id="regexinfo-re_search_2">
<indexterm scope="regexinfo-cp"><primary><literal>re_search_2</literal> işlevi</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>re_search_2</command></funcdef>
<paramdef>(struct re_pattern_buffer *<varname>şablon_tamponu</varname>,
 const char               *<varname>dizge1</varname>,
 const int                 <varname>boyut1</varname>,
 const char               *<varname>dizge2</varname>,
 const int                 <varname>boyut2</varname>,
 const int                 <varname>başlangıç</varname>,
 const int                 <varname>aralık</varname>,
 struct re_registers      *<varname>yazmaçlar</varname>,
 const int                 <varname>son</varname>)</paramdef>
</funcprototype><funcdescr><para>
<command>re_search</command> işlevine benzer.
      </para></funcdescr></funcsynopsis></para>
    </sect2><sect2 xml:id="regexinfo-Searching-with-Fastmaps" chunkthis="1">
      <title>Hızlı Eşlemlerle Arama</title>
      <titleabbrev><command>re_compile_fastmap()</command> işlevi</titleabbrev>
<indexterm scope="regexinfo-cp"><primary>hızlı eşlemler</primary></indexterm>
      <para>
Uzun bir dizge üzerinde arama yapıyorsanız bir hızlı eşlem kullanmalısınız. Bu olmaksızın, arayıcı dizge içinde ardarda her konumda eşleşme dener. Genellikle, dizge içindeki karakterlerin pek çoğu bir eşlemeyi başlatamaz. Dizge içindeki belirli bir noktadan eşleme yapmayı denemek, karakterin bir eşlemeyi başlatıp başlatamayacağını bir tablodan kontrol etmekten çok daha fazla vakte mal olur. İşte hızlı eşlem böyle bir tablodur.
    </para><para>
Daha belirgin olarak, bir hızlı eşlem karakter kümenizdeki karakterlerle indislenmiş bir dizidir. Bundan dolayı, ascii karakter kodlaması altında bir hızlı eşlem 256 elemanlıdır. Arayıcının belirtilmiş bir şablon tamponu ile bir hızlı eşlemi kullanmasını isterseniz, bellekte dizi için yer ayırmalı ve dizinin adresini şablon tamponunun <command>fastmap</command> alanına atamalısınız:
    </para><para>
<screen>#define BYTEWIDTH 8

struct re_pattern_buffer compiled;
char fastmap[1 &lt;&lt; BYTEWIDTH];

compiled.fastmap = fastmap;
</screen>
    </para><para>
Ya hızlı eşlemi siz derlersiniz ya da <command>re_search</command> bunu sizin için yapar; <command>fastmap</command> alanının değeri sıfırdan farklı ise özel olarak derlenmiş bir şablonu kullanarak yapacağınız ilk arama sırasında hızlı eşlem <command>re_search</command> tarafından derlenir.
</para><para xml:id="regexinfo-re_compile_fastmap">
<indexterm scope="regexinfo-cp"><primary><literal>re_compile_fastmap</literal> işlevi</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>re_compile_fastmap</command></funcdef>
<paramdef>(struct re_pattern_buffer *<varname>şablon_tamponu</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bir hızlı eşlemi kendiniz derlemek isterseniz bu işlevi kullanmalısınız.  <varname>şablon_tamponu</varname> bir şablon tamponunun adresidir.  <varname>c</varname> karakteri şablon için bir eşleşme başlatmalıysa, <command>re_compile_fastmap</command>, <varname>şablon_tamponu</varname><literal>->fastmap[<emphasis>c</emphasis>]</literal> değerini sıfırdan farklı yapar. Hızlı eşlem derlenebilmişse işlev sıfır değeriyle, bir iç hata oluşmuşsa -2 değeriyle döner. Örneğin,  <command>|</command> bir VEYA işleci ise ve <varname>şablon_tamponu</varname>, <command>a|b</command> ifadesi için derlenmiş şablonu içeriyorsa, <command>re_compile_fastmap</command> işlevi sadece <command>fastmap['a']</command> ve <command>fastmap['b']</command> değerlerini sıfırdan farklı yapar.
    </para><para>
<command>re_search</command> dizge içinde hareket ederken hızlı eşlem kullanırsa, dizge içindeki karakterleri hızlı eşlem içindeki karakterlerden birini buluncaya kadar ilerler ve bu karakterden itibaren eşleştirmeyi dener. Eğer eşleşme olmazsa işlemi tekrarlar. Böylece bir hızlı eşlem kullanılarak dizge içinde zaten eşleşmeyecek konumlarda <command>re_search</command> eşleştirme için zaman harcamaz.
    </para><para>
<command>re_search</command> işlevinin hızlı eşlem kullanmasını istemeseniz, işlevi çağırmadan önce şablon tamponunun <command>fastmap</command> alanına sıfır atayın.
    </para><para>
Bir şablon tamponunun <command>fastmap</command> alanını bir kere ilklendirdikten sonra, bir daha bunu yapmaya ihtiyacınız olmaz -- içinde yeni bir şablon derleseniz bile -- yeter ki, alan sizin bir hızlı eşlem isteyip istemediğinize tepki vermeye ayarlı olsun.
    </para></funcdescr></funcsynopsis></para>
  </sect2><sect2 xml:id="regexinfo-GNU-Translate-Tables" chunkthis="1">
    <title>GNU Çeviri Tabloları</title>
    <titleabbrev><literal>translate</literal> alanı</titleabbrev>
    <para>
Bir şablon tamponunun <command>translate</command> alanına bir çeviri tablosu yerleştirirseniz, GNU Regex işlevleri bu şablon tamponunu düzenli ifadenin tamamına ve aranan dizge karakterlerine basit bir dönüşüm uygulamakta kullanır.
    </para><para>
Bir <wordasword>çeviri tablosu</wordasword> karakter kümenizdeki karakterlerle indislenmiş bir dizidir. Bu nedenle, ascii karakter kümesinde bir çeviri tablosu 256 elamanlıdır. Dizinin elamanları ayrıca karakter kümenizin karakterleridir. Regex işlevleri bir <varname>c</varname> karakteri gördüğünde onun yerine <command>translate[<varname>c</varname>]</command> kullanır, bir istisna dışında: karakter bir <command>\</command> ile öncelenmişse çeviri yapılmaz. Böylece, <command>\B</command> ve <command>\b</command> gibi işleçlerin seçilebilirliği garanti altına alınır.
    </para><para>
Örneğin; bütün küçük harfleri büyük harflere dönüştürmek üzere tasarlanmış bir tablo, eşleştiricinin harf büyüklükleri farkını yok saymasına sebebiyet verir.<footnote><para>Bütün büyük harfleri, karşılığı olan küçük harflere dönüştürmeye yarayacak bir tablo sadece bu amaç için çalışacaktır.</para></footnote>  Böyle bir tablo, küçük harfler dışındaki karakterleri kendileriyle, küçük harfleri de karşılıkları olan büyük harflerle eşleyecektir.  Ascii kodlama altında, böyle bir tabloyu nasıl ilklendireceğiniz aşağıda gösterilmiştir (tablonun ismi <command>case_fold</command>'dur):
    </para><para>
<screen>
  for (i = 0; i &lt; 256; i++)
    case_fold[i] = i;
  for (i = 'a'; i &lt;= 'z'; i++)
    case_fold[i] = i - ('a' - 'A');
</screen>
    </para><para>
Regex'in bir şablon tamponu üzerinde bir çeviri tablosunu kullanmasını isterseniz, tablonun adresini tamponun <command>translate</command> alanına atamalısınız. Regex'in herhangi bir çeviri yapmasını istemezseniz, bu alana sıfır yerleştirin. Şayet tablonun içeriğini şablon tamponunu derleme, hızlı eşlemi derleme, şablon tamponu ile eşleşme ve aramalar arasında herhangi bir zamanda değiştirmeye kalkarsanız tuhaf sonuçlar alırsınız.
    </para>
  </sect2><sect2 xml:id="regexinfo-Using-Registers" chunkthis="1">
    <title>Yazmaçların Kullanımı</title>
    <titleabbrev><literal>re_registers</literal> türü ve ilgili işlevler</titleabbrev>
    <para>
Bir düzenli ifade içindeki bir grup, düzenli ifadenin tamamen eşleştiği bir dizgenin alt dizgesi (muhtemelen boş) ile eşleşebilir.  Eşleştirici, her bir grupla eşleşen alt dizgelerin başlangıç ve bitiş noktalarını hatırlar.
    </para><para>
Onların nelerle eşleştiğini bulmak için bir GNU <link linkend="regexinfo-GNU-Matching">eşleştirme</link> ve <link linkend="regexinfo-GNU-Searching">arama</link> işlevinin <varname>yazmaçlar</varname> argümanına sıfırdan farklı bir değer, örneğin <filename>regex.h</filename> dosyasında tanımlı olan aşağıdaki gibi bir yapının adresini atayın:
</para><para xml:id="regexinfo-re_registers">
<indexterm scope="regexinfo-cp"><primary><literal>re_registers</literal> türü</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü">
<funcdef>struct <command>re_registers</command></funcdef>
<paramdef>
{
  unsigned  <varname>num_regs</varname>;
  regoff_t *<varname>start</varname>;
  regoff_t *<varname>end</varname>;
};
</paramdef>
</funcprototype><funcdescr><para>
<varname>num_regs</varname>'inci eleman hariç (aşağıya bakınız), <command>start</command> ve <command>end</command> dizilerinin <varname>i</varname>'nci elemanı, şablondaki  <varname>i</varname>'nci grup hakkındaki bilgileri kaydeder.  (Hiçbir C derleyicisi sıfır uzunluklu dizileri kabul etmediğinden bu diziler gösterici olarak bildirilmiştir; kavramsal olarak, onları dizi olarak düşünmek en kolayıdır.)
    </para><para>
<indexterm scope="regexinfo-cp"><primary><literal>regs_allocated</literal> alanı</primary></indexterm>
<command>start</command> ve <command>end</command> dizileri için, eşleştiriciye aktarılan şablon tamponu içindeki <command>regs_allocated</command> alanının değerine bağlı olarak çeşitli yöntemlerle bellek ayrılabilir.
    </para><para>
<indexterm scope="regexinfo-cp"><primary><literal>REGS_UNALLOCATED</literal></primary></indexterm>
<indexterm scope="regexinfo-cp"><primary><literal>REGS_REALLOCATE</literal></primary></indexterm>
Burada uygulanması en basit ve belki de en akıllıca yöntem; eşleştiriciye, düzenli ifade içindeki bütün grupların bilgilerinin kaydedilebileceği alanı (yeniden) ayırmaktır. <command>regs_allocated</command> alanının değeri <literal>REGS_UNALLOCATED</literal> ise, eşleştirici 1 + <varname>re_nsub</varname> yer tahsis eder (<link linkend="regexinfo-GNU-Pattern-Buffers">şablon tamponu</link> içindeki bir alan). Ek elemana -1 ve <command>regs_allocated</command> alanına <literal>REGS_REALLOCATE</literal> değeri atanır. Daha sonradan aynı şablon tamponu ve <varname>yazmaçlar</varname> argümanıyla yapılan çağrılarda, eşleştirici gerektiği kadar alanı yeniden tahsis eder.
    </para><para>
<command>regs_allocated</command> alanını <command>re_registers</command> yapısının bir parçası yapmak, şablon tamponun bir parçası yapmaktan daha akıllıca bir yöntem olabilir. Fakat bu durumda, çağrıcıya aktarılmadan önce yapının ilklendirilmesi zorunlu olacaktı. Mevcut kodların pek çoğu bu ilklendirmeyi yapmaz ve bundan kaçınmak her halükarda en iyisidir.
    </para><para>
<command>re_compile_pattern</command>, <command>regs_allocated</command> alanına <literal>REGS_UNALLOCATED</literal> atar, böylece GNU düzenli ifade işlevlerini kullanırsanız, bu davranışı öntanımlı olarak elde etmiş olursunuz.
    </para><para>
<indexterm scope="regexinfo-cp"><primary><literal>REGS_FIXED</literal></primary></indexterm>
Diğer yandan, POSIX, farklı bir arayüze ihtiyaç duyar:  çağrıcı, eşleştirici tarafından doldurulacak sabit uzunluktaki bir dizi aktarılacağını varsayar. Bu nedenle, şayet <command>regs_allocated</command> alanının değeri  <literal>REGS_FIXED</literal> ise, eşleştirici o diziyi doldurur.
    </para><para>
Aşağıdaki örneklerde, <command>re_registers</command> yapısına bilgi kaydedilmesi gösterilmiştir. (Hepsinde, <command>(</command> işlecinin grup başlatma, <command>)</command> işlecinin ise grup sonlandırma işleci olduğu varsayılmıştır.  <varname>dizge</varname> dizgesinin ilk karakterinin indisi 0 dır.)
    </para><itemizedlist>
     <listitem><para>
Şayet düzenli ifade, <varname>dizge</varname> dizgesinin bir alt dizgesi ile eşleşen ve bir alt grup içermeyen bir <varname>i</varname>'inci grup içeriyorsa, işlev, <varname>yazmaçlar</varname><literal>->start[<emphasis>i</emphasis>]</literal> alanını
<varname>dizge</varname> içindeki, <varname>i</varname>'inci grupla eşleşen altdizgenin başlangıcına, <varname>yazmaçlar</varname><literal>->end[<emphasis>i</emphasis>]</literal> alanını da alt dizgenin sonuna denk gelen indise ayarlar. İşlev, <varname>yazmaçlar</varname><literal>->start[0]</literal> ve
<varname>yazmaçlar</varname><literal>->end[0]</literal> alanlarını ise şablonun tamamı hakkındaki benzer bilgilere ayarlar.
      </para><para>
Örneğin, <command>((a)(b))</command> ifadesini <command>ab</command> dizgesi ile eşleştirirseniz şunları elde edersiniz:
      </para><itemizedlist>
        <listitem>
<varname>yazmaçlar</varname><literal>->start[0]</literal> için 0, <varname>yazmaçlar</varname><literal>->end[0]</literal> için 2
        </listitem><listitem>
<varname>yazmaçlar</varname><literal>->start[1]</literal> için 0, <varname>yazmaçlar</varname><literal>->end[1]</literal> için 2
        </listitem><listitem>
<varname>yazmaçlar</varname><literal>->start[2]</literal> için 0, <varname>yazmaçlar</varname><literal>->end[2]</literal> için 1
        </listitem><listitem>
<varname>yazmaçlar</varname><literal>->start[3]</literal> için 1, <varname>yazmaçlar</varname><literal>->end[3]</literal> için 2
        </listitem></itemizedlist>
      </listitem><listitem><para>
Şayet bir grup bir kereden fazla eşleşiyorsa (ardından bir yineleme işleci  geliyor olabilir), işlev son eşleşen grup hakkındaki bilgileri raporlar.
      </para><para>
Örneğin, <command>(a)*</command> ifadesini <command>aa</command> dizgesi ile eşleştirirseniz şunları elde edersiniz:
      </para><itemizedlist>
       <listitem>
<varname>yazmaçlar</varname><literal>->start[0]</literal> için 0, <varname>yazmaçlar</varname><literal>->end[0]</literal> için 2
        </listitem><listitem>
<varname>yazmaçlar</varname><literal>->start[1]</literal> için 1, <varname>yazmaçlar</varname><literal>->end[1]</literal> için 2
        </listitem>
      </itemizedlist>
      </listitem><listitem><para>
Şayet <varname>i</varname>'inci grup başarılı bir eşleşmede yer almamış ise (örneğin; kullanılmamış bir VEYA işleci veya sıfır kere tekrarlamaya ayarlı bir yineleme işleci olabilir), işlev <varname>yazmaçlar</varname><literal>->start[1]</literal> ve
<varname>yazmaçlar</varname><literal>->end[1]</literal> için -1 atar.
      </para><para>
Örneğin, <command>(a)*b</command> ifadesini <command>b</command> dizgesi ile eşleştirirseniz şunları elde edersiniz:
      </para><itemizedlist>
       <listitem>
<varname>yazmaçlar</varname><literal>->start[0]</literal> için 0, <varname>yazmaçlar</varname><literal>->end[0]</literal> için 1
        </listitem><listitem>
<varname>yazmaçlar</varname><literal>->start[1]</literal> için -1, <varname>yazmaçlar</varname><literal>->end[1]</literal> için -1
        </listitem></itemizedlist>
      </listitem><listitem><para>
Şayet <varname>i</varname>'inci grup sıfır uzunluktaki bir dizge ile eşleşirse, işlev
<varname>yazmaçlar</varname><literal>->start[0]</literal> ve,
<varname>yazmaçlar</varname><literal>->end[0]</literal> alanlarını sıfır uzunluktaki dizgenin hemen sonrasındaki indise ayarlar.
      </para><para>
Örneğin, <command>(a*)b</command> ifadesini <command>b</command> dizgesi ile eşleştirirseniz şunları elde edersiniz:
      </para><itemizedlist>
       <listitem>
<varname>yazmaçlar</varname><literal>->start[0]</literal> için 0, <varname>yazmaçlar</varname><literal>->end[0]</literal> için 1
        </listitem><listitem>
<varname>yazmaçlar</varname><literal>->start[0]</literal> için 0, <varname>yazmaçlar</varname><literal>->end[0]</literal> için 0
        </listitem></itemizedlist>
    </listitem><listitem><para>
Şayet <varname>i</varname>'inci grup, grup içindeki başka bir grup tarafından ihtiva edilmeyen bir <varname>j</varname>'inci gruba sahipse ve işlev <varname>i</varname>'inci grubun eşleşmesini rapor ediyorsa, <varname>j</varname>'inci grubun son eşleşmesi (şayet böyle bir eşleşme olmuş ise) <varname>yazmaçlar</varname><literal>->start[j]</literal> ve <varname>yazmaçlar</varname><literal>->end[j]</literal> içine kaydedilir.
      </para><para>
Örneğin, <command>((a*)b)*</command> ifadesi <command>abb</command> dizgesi ile ve 2. grup bir boş dizge ile eşleşirse, evvelce yapılan eşleşme ne ise onu elde etmiş oluruz:
      </para><itemizedlist>
        <listitem>
<varname>yazmaçlar</varname><literal>->start[0]</literal> için 0, <varname>yazmaçlar</varname><literal>->end[0]</literal> için 3
        </listitem><listitem>
<varname>yazmaçlar</varname><literal>->start[1]</literal> için 2, <varname>yazmaçlar</varname><literal>->end[1]</literal> için 3
        </listitem><listitem>
<varname>yazmaçlar</varname><literal>->start[2]</literal> için 2, <varname>yazmaçlar</varname><literal>->end[2]</literal> için 2
        </listitem></itemizedlist><para>
<command>((a)*b)*</command> ifadesi <command>abb</command> dizgesi ile ve son eşleşmede 2. grup eşleşmezse, şunları elde ederiz:
      </para><itemizedlist>
       <listitem>
<varname>yazmaçlar</varname><literal>->start[0]</literal> için 0, <varname>yazmaçlar</varname><literal>->end[0]</literal> için 3
        </listitem><listitem>
<varname>yazmaçlar</varname><literal>->start[1]</literal> için 2, <varname>yazmaçlar</varname><literal>->end[1]</literal> için 3
        </listitem><listitem>
<varname>yazmaçlar</varname><literal>->start[2]</literal> için 0, <varname>yazmaçlar</varname><literal>->end[2]</literal> için 1
        </listitem></itemizedlist>
    </listitem><listitem><para>
Şayet <varname>i</varname>'inci grup, grup içindeki başka bir grup tarafından ihtiva  edilmeyen bir <varname>j</varname>'inci gruba sahipse ve işlev <varname>yazmaçlar</varname><literal>->start[i]</literal> ve <varname>yazmaçlar</varname><literal>->end[i]</literal> alanların -1'e ayarlamışsa, <varname>yazmaçlar</varname><literal>->start[j]</literal> ve <varname>yazmaçlar</varname><literal>->end[j]</literal> alanları da -1'e ayarlanır.
      </para><para>
Örneğin, <command>((a)*b)*c</command> ifadesini <command>c</command> dizgesi ile eşleştirirseniz şunları elde edersiniz:
      </para><itemizedlist>
       <listitem>
<varname>yazmaçlar</varname><literal>->start[0]</literal> için 0, <varname>yazmaçlar</varname><literal>->end[0]</literal> için 1
        </listitem><listitem>
<varname>yazmaçlar</varname><literal>->start[1]</literal> için -1, <varname>yazmaçlar</varname><literal>->end[1]</literal> için -1
        </listitem><listitem>
<varname>yazmaçlar</varname><literal>->start[2]</literal> için -1, <varname>yazmaçlar</varname><literal>->end[2]</literal> için -1
        </listitem></itemizedlist>
    </listitem></itemizedlist>
    </funcdescr></funcsynopsis></para>
  </sect2><sect2 xml:id="regexinfo-Freeing-GNU-Pattern-Buffers" chunkthis="1">
    <title>GNU Şablon Tamponlarının Serbest Bırakılması</title>
    <titleabbrev><command>regfree()</command> işlevi</titleabbrev>
    <para>
Bir şablon tamponunun alanlarına ayrılan yeri serbest bırakmak için, <command>re_pattern_buffer</command> türü, POSIX şablon tamponlarının türü olan <command>regex_t</command> türü ile eşdeğerde olduğundan, <xref linkend="regexinfo-Freeing-POSIX-Pattern-Buffers"/> bölümünde anlatılan posix işlevini kullanabilirsiniz. Bir şablon tamponu serbest bıraktıktan sonra, bir düzenli ifadeyi eşleme veya arama işlevlerine aktarmadan önce ifadeyi tekrar <link linkend="regexinfo-GNU-Regular-Expression-Compiling">derlemeniz</link> gerekir.
    </para></sect2>
    <sect2 xml:id="regexinfo-GNU-regex-example" chunkthis = "1"><title>Bir Arama ve Değiştirme Örneği</title>
    <para>
Bu örnek, bu kitapçığın özgün kopyasında bulunmamaktadır. Tam bir uygulama örneği olarak yararlı olabileceği düşünülerek bu çeviriye eklenmiştir.
    </para><para>
Örnek kodun yaptığı iş bir dizgeyi &lt;b>, &lt;/b> ve &lt;i>, &lt;/i> etiketlerinden arındırmaktır. İşlemi hızlandırmak için özel bir hızlı eşlem (fastmap) kullanılmıştır. Bu özel fastmap sayesinde eşleşme araması "/&lt;>bi" dizgesindeki karakterlerden birine rastlanığında başlatılacağından işlemin beklenenden daha çabuk biteceği düşünülmüştür. <literal>SET_FASTMAP()</literal> makrosu bu hızlı eşlem dizisini ilklendirmek içindir.
    </para><para>
<literal>unformat</literal> işlevi argümanı olan <varname>string</varname> dizgesini bu etiketlerden arındırır ve bunu ek bir tampon kullanmadan doğrudan bu dizge üzerinde yapar. Arama işleminin her yinelenişinde dizge giderek etiketlerden arındığından ve özel bir hızlı eşlem kullanıldığından, dizge içinde aramanın başlatılacağı konumun ilerletilmesine gerek duyulmamıştır.
    </para><para>
<screen>void
get_regerror(int errcode, re_pattern_buffer *compiled, char *func) {

    size_t length = regerror (errcode, compiled, NULL, 0);
    char *buffer = xmalloc (length);

    regerror (errcode, compiled, buffer, length);
    fprintf(stderr, "%s: %s\n", func, buffer);
    free(buffer);
}

#define SET_FASTMAP() \
{ \
  unsigned this_char; \
  \
  memset (fastmap, invert, (1 &lt;&lt; BYTEWIDTH)); \
  \
  for (this_char = 0; this_char &lt; strlen (fastmap_string); this_char++)\
    fastmap[fastmap_string[this_char]] = !invert; \
  fastmap['\n'] = match_newline; \
}

void
unformat (char *string) {
  char *pattern;
  struct re_pattern_buffer compiled;
  char fastmap[1 &lt;&lt; BYTEWIDTH];
  const char *comperr;
  char *fastmap_string;
  unsigned invert, match_newline;
  struct re_registers *matches;
  int execerr, len, prelen, postlen, slen;

  re_set_syntax (RE_NO_BK_PARENS | RE_NO_BK_VBAR);
  pattern = "(&lt;.>|&lt;/.>)";
  invert = 0;
  match_newline = 0;
  fastmap_string = "/&lt;>bi";
  SET_FASTMAP ();

  memset (&amp;compiled, 0, sizeof (compiled));
  comperr = re_compile_pattern(pattern, strlen(pattern), &amp;compiled);
  if (comperr)
    get_regerror((int)*comperr, &amp;compiled, "re_compile_pattern");

  /* Şablon derlendi. Biçim arıtmasına başlayabiliriz. */
  slen = strlen(string);
  compiled.fastmap = fastmap;
  matches = alloca (sizeof(matches) * (compiled.re_nsub + 1));
  while (1) {
    memset (matches, 0, sizeof (matches));
    execerr = re_search (&amp;compiled, string, slen, 0, slen, matches);
    if (execerr == - 1) {
      /* puts ("Eşleşme bulunamadı"); */
      break;
    }
    if (execerr >= 0) {
      len = matches->end[0] - matches->start[0];
      postlen = slen - matches->end[0];
      prelen = matches->start[0];
      strncpy(string + prelen, string + matches->end[0], postlen);
      slen = prelen + postlen;
      string[slen] = '\0';
    } else {
      get_regerror(comperr, &amp;compiled, "re_search");
    }
  }
}
</screen>
    </para>
    </sect2></sect1>
  <sect1 xml:id="regexinfo-POSIX-Regex-Functions">
   <title>POSIX Regex işlevleri</title>
   <para>
Şayet POSIX uyumlu kodlar yazıyorsanız, bu işlevlere ihtiyacınız olacaktır. Bunların arayüzleri  POSIX taslağı 1003.2/D11.2 de tanımlanmıştır.
    </para>
    <sect2 xml:id="regexinfo-POSIX-Pattern-Buffers" chunkthis="1">
      <title>POSIX Şablon Tamponları</title>
      <titleabbrev><literal>regex_t</literal> türü</titleabbrev>
      <para>
Belirtilen bir düzenli ifadeyi POSIX tarzında derlemek veya eşleştirmek için, tıpkı GNU için yaptığımız gibi bir <link linkend="regexinfo-GNU-Pattern-Buffers">şablon tamponu</link> sağlamamız gerekir.  GNU şablon tamponlarının türü olan <command>re_pattern_buffer</command> türü, POSIX şablon tamponlarının türü olan <command>regex_t</command> türü ile eşdeğerdedir.
      </para>
    </sect2><sect2 xml:id="regexinfo-POSIX-Regular-Expression-Compiling" chunkthis="1">
      <title>POSIX Düzenli İfadelerinin Derlenmesi</title>
      <titleabbrev><command>regcomp()</command> işlevi</titleabbrev>
      <para>
POSIX ile, belirtilen bir düzenli ifade için sadece arama yapabilirsiniz; onu eşleştiremezsiniz. Bunu yapabilmek için, <command>regcomp</command> kullanarak, düzenli ifadeyi bir şablon tamponu içinde derlemelisiniz.
</para><para xml:id="regexinfo-regcomp">
<indexterm scope="regexinfo-cp"><primary><literal>regcomp</literal> işlevi</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>regcomp</command></funcdef>
<paramdef>(regex_t    *<varname>şablon</varname>,
 const char *<varname>düzenli_ifade</varname>,
 int         <varname>derleme_imleri</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bir POSIX şablon tamponunu derlemek için kullanılır.
        </para><para>
<varname>şablon</varname>, ilklendirilmiş şablon tamponunun adresi; <varname>düzenli_ifade</varname>, düzenli ifadenin adresi ve <varname>derleme_imleri</varname> ise bir bit kolleksiyonu olarak derleme imleridir. Burada geçerli bitler <filename>regex.h</filename> başlık dosyasında tanımlanmıştır:
      </para><variablelist>
<indexterm scope="regexinfo-cp"><primary><literal>REG_EXTENDED</literal></primary> </indexterm>
      <varlistentry>
        <term xml:id="regexinfo-REG_EXTENDED"><literal>REG_EXTENDED</literal></term>
        <listitem><para>
POSIX Genişletilmiş Düzenli İfade sözdiziminin kullanılacağını belirtir; şayet bu bit bir ise POSIX Genişletilmiş Düzenli İfade sözdiziminin kullanılacağını, aksi takdirde POSIX Temel Düzenli İfade sözdiziminin kullanılacağını belirtilmiş olur. <command>regcomp</command> işlevi <varname>şablon</varname>'un <command>syntax</command> alanını buna göre düzenler.
        </para></listitem>
      </varlistentry>
<indexterm scope="regexinfo-cp"><primary><literal>REG_ICASE</literal> </primary></indexterm>
<indexterm scope="regexinfo-cp"><primary>harf büyüklüğünün gözardı edilmesi</primary></indexterm>
      <varlistentry>
        <term xml:id="regexinfo-REG_ICASE"><literal>REG_ICASE</literal></term>
        <listitem><para>
Büyük/küçük harf ayrımı yapılmaz; <command>regcomp</command> işlevi, <varname>şablon</varname>'un <command>translate</command> alanını, büyük/küçük harf duyarsız bir çeviri tablosuna ayarlar, burada daha önceden bulunan herşeyi değiştirir.
        </para></listitem>
      </varlistentry>
<indexterm scope="regexinfo-cp"><primary><literal>REG_NOSUB</literal></primary> </indexterm>
      <varlistentry>
        <term xml:id="regexinfo-REG_NOSUB"><literal>REG_NOSUB</literal></term>
        <listitem><para>
<varname>şablon</varname>'un <command>no_sub</command> alanını ayarlar; bunun ne anlama geldiğini öğrenmek için <xref linkend="regexinfo-POSIX-Matching"/> bölümüne bakınız.
        </para></listitem>
      </varlistentry>
<indexterm scope="regexinfo-cp"><primary><literal>REG_NEWLINE</literal></primary> </indexterm>
      <varlistentry>
        <term xml:id="regexinfo-REG_NEWLINE"><literal>REG_NEWLINE</literal></term>
        <listitem><itemizedlist>
          <listitem>
<link linkend="regexinfo-Match-any-character-Operator">Herhangi bir_karakterle eşleşme işlecine</link>, satırsonu karakteri ile eşleşmemesini söyler.
          </listitem><listitem>
Bir satırsonu karakteri içermeyen <link linkend="regexinfo-List-Operators">eşleşmeme listesini</link> bir satırsonu karakteri ile eşleştirir.
          </listitem><listitem>
<link linkend="regexinfo-Match-beginning-of-line-Operator">Satır başı ile eşleşme işleci</link>, <link linkend="regexinfo-POSIX-Matching"><command>REG_NOTBOL</command></link> bitinin durumuna bağlı olmaksızın,  bir satırsonu karakterini izleyen boş bir dizge ile eşleşir.
          </listitem><listitem>
<link linkend="regexinfo-Match-end-of-line-Operator">Satır sonu ile eşleşme işleci</link>, <link linkend="regexinfo-POSIX-Matching"><command>REG_NOTEOL</command></link> bitinin durumuna bağlı olmaksızın,  bir satırsonu karakterinden hemen önceki boş bir dizge ile eşleşir.
          </listitem>
        </itemizedlist></listitem>
      </varlistentry>
    </variablelist><para>
<command>regcomp</command> işlevi düzenli ifadeyi derleyebilirse, derlenmiş şablonu <literal>*<emphasis>şablon</emphasis></literal>'a yerleştirir ve sıfır değeriyle döner.
<command>syntax</command> alanı hariç (yukarıda açıklandığı gibi ayarlanır). Ayrıca, <link linkend="regexinfo-GNU-Regular-Expression-Compiling">GNU derleme işlevinin</link> yaptığı benzer bir yolla aynı alanları ayarlar.
    </para><para>
<command>regcomp</command> işlevi düzenli ifadeyi derleyemezse, aşağıda listelenen hata kodlarından biriyle döner. (Aksi belirtilmedikçe, aşağıdaki tüm örneklerin sözdizimi temel düzenli ifade sözdizimidir.)
    </para><glosslist><glossentry>
        <glossterm><literal>REG_BADRP</literal></glossterm>
        <glossdef><para>
Örneğin, <command>a**</command> içindeki ardışık yineleme işleçleri <command>**</command> geçersizdir. Başka bir örnek olarak; şayet sözdizimi, genişletilmiş düzenli ifade sözdizimi ise, <command>*</command> içinde yapacak hiçbir şeyi olmayan yineleme işleci <command>*</command> geçersizdir.
        </para></glossdef>
      </glossentry><glossentry>
        <glossterm><literal>REG_BADBR</literal></glossterm>
        <glossdef><para>
Örneğin, <command>a\{-1</command> içindeki <command>-1</command> tekrar sayısı olarak geçersizdir.
        </para></glossdef>
      </glossentry><glossentry>
        <glossterm><literal>REG_EBRACE</literal></glossterm>
        <glossdef><para>
Örneğin, <command>a\{1</command> ifadesinde sınırlı sayıda yineleme bitirme işleci eksiktir.
        </para></glossdef>
      </glossentry><glossentry>
        <glossterm><literal>REG_EBRACK</literal></glossterm>
        <glossdef><para>
Örneğin, <command>[a</command> ifadesine eşleşme listesi bitirme işleci eksiktir.
        </para></glossdef>
      </glossentry><glossentry>
        <glossterm><literal>REG_ERANGE</literal></glossterm>
        <glossdef><para>
Örneğin, <command>[z-a]</command> aralığında aralık sonu olan <command>z</command> harf sıralaması bakımından başlangıç olan <command>a</command>'dan küçük yapılmıştır ve aralık ifadesi geçersizdir. Ayrıca, <command>[[:alpha:]-|]</command> aralığında, aralığın başlangıcı olarak <command>[:alpha:]</command> karakter sınıfıyla aralık yine geçersizdir.
        </para></glossdef>
      </glossentry><glossentry>
        <glossterm><literal>REG_ECTYPE</literal></glossterm>
        <glossdef><para>
Örneğin, <command>[[:foo:]</command> içindeki <command>foo</command> karakter sınıfı ismi geçersizdir.
        </para></glossdef>
      </glossentry><glossentry>
        <glossterm><literal>REG_EPAREN</literal></glossterm>
        <glossdef><para>
Örneğin, <command>a\)</command> ifadesinde grup başlatma işleci ve <command>\(a</command> ifadesinde grup sonlandırma işleci eksiktir.
        </para></glossdef>
      </glossentry><glossentry>
        <glossterm><literal>REG_ESUBREG</literal></glossterm>
        <glossdef><para>
Örneğin, <command>\(a\)\2</command> ifadesinde grup adresleme işleci <command>\2</command> olmayan bir grubu gösterdiğinden geçersizdir.
        </para></glossdef>
      </glossentry><glossentry>
        <glossterm><literal>REG_EEND</literal></glossterm>
        <glossdef><para>
Düzenli ifade özel bir hata koduna sebep olmuyorsa döner.
        </para></glossdef>
      </glossentry><glossentry>
        <glossterm><literal>REG_EESCAPE</literal></glossterm>
        <glossdef><para>
Örneğin,  <command>a\</command> ifadesi içindeki <command>\</command> tıpkı  <command>\</command> ifadesindeki gibi geçersizdir.
        </para></glossdef>
      </glossentry><glossentry>
        <glossterm><literal>REG_BADPAT</literal></glossterm>
        <glossdef><para>
Örneğin, genişletilmiş düzenli ifade sözdiziminde, <command>a()b</command> ifadesi içindeki boş grup <command>()</command> geçersizdir.
        </para></glossdef>
      </glossentry><glossentry>
        <glossterm><literal>REG_ESIZE</literal></glossterm>
        <glossdef><para>
Bir düzenli ifade 65536 bayttan daha büyük bir şablon tamponu gerektiriyorsa döner.
        </para></glossdef>
      </glossentry><glossentry>
        <glossterm><literal>REG_ESPACE</literal></glossterm>
        <glossdef><para>
Bir düzenli ifade bellek taşmasına sebep oluyorsa döner.
        </para></glossdef></glossentry>
    </glosslist></funcdescr></funcsynopsis></para>
  </sect2><sect2 xml:id="regexinfo-POSIX-Matching" chunkthis="1">
    <title>POSIX Eşleştirmesi</title>
    <titleabbrev><command>regexec()</command></titleabbrev>
    <para>
POSIX tarzı eşleştirme, bir boş karakter sonlandırmalı dizgeyi ilk karakterinden başlayarak eşleştirmek demektir. Bir ifadeyi bir <link linkend="regexinfo-POSIX-Regular-Expression-Compiling">şablon tamponu içine derledikten</link> sonra aşağıdaki işlevi kullanarak şablonu bir dizge ile eşleştirmeyi deneyebilirsiniz.
</para><para xml:id="regexinfo-regexec">
<indexterm scope="regexinfo-cp"><primary><literal>regexec</literal> işlevi</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>regexec</command></funcdef>
<paramdef>
(const regex_t *<varname>şablon</varname>,
 const char    *<varname>dizge</varname>,
 size_t         <varname>eşleşen_sayısı</varname>,
 regmatch_t     <varname>eşleşenler</varname>[],
 int            <varname>icra_imleri</varname>)</paramdef>
</funcprototype><funcdescr><para>
<varname>şablon</varname>, ifadenin derlendiği şablon tamponunun adresi,  <varname>dizge</varname> ise eşleştirilecek olan dizgedir.
    </para><para>
<varname>eşleşenler</varname> ile ilgili olarak daha ayrıntılı bilgiyi <xref linkend="regexinfo-Using-Byte-Offsets"/> bölümünde bulabilirsiniz.   <varname>eşleşen_sayısı</varname> olarak sıfır aktarırsanız ya da <varname>şablon</varname>'u <literal>REG_NOSUB</literal> derleme bitini 1 yaparak derlemişseniz, <command>regexec</command> işlevi <varname>eşleşenler</varname>'i yoksayar; aksi takdirde, onu en az <varname>eşleşen_sayısı</varname> elemanla ilklendirmelisiniz. <command>regexec</command> işlevi <varname>eşleşen_sayısı</varname> bayt konumunu <varname>eşleşenler</varname> dizisine kaydeder, kullanılmayan elemanlara da <varname>eşleşenler</varname><literal>[<emphasis>eşleşen_sayısı</emphasis> -1]</literal>'e kadar -1 değerini atar.
    </para><para>
<varname>icra_imleri</varname> ile <wordasword>çalıştırma imleri</wordasword> belirtilir (<filename>regex.h</filename> dosyasında tanımlanmış olan <literal>REG_NOTBOL</literal> ve <literal>REG_NOTEOL</literal> bitleri). <literal>REG_NOTBOL</literal> biti bir ise, <link linkend="regexinfo-Match-beginning-of-line-Operator">satır başı ile eşleşme işleci</link> daima eşleştirmede başarısız olur. Bu, size satırın bir parçası ile eşleşme yapma imkanı sağlar. Bu özelliğe, şayet bir satır içinde belirtilmiş bir şablonun tekrarlanan örneklerini arıyorsanız ihtiyacınız olacaktır. Şablonlar için, satır başı ile eşleşme işleci ile veya onsuz, bu özellik düzgün bir biçimde çalışacaktır.  <literal>REG_NOTEOL</literal> ise <link linkend="regexinfo-Match-end-of-line-Operator">satır sonu eşleşme işleci</link> için benzer şekilde çalışacaktı; bu bit simetri için vardır.
    </para><para>
<command>regexec</command> işlevi, <varname>şablon</varname>'un <command>syntax</command> alanı içindeki sözdizimine bağlı olarak <varname>dizge</varname> içinde <varname>şablon</varname> için bir eşleşme bulmaya çalışır. (Bunun nasıl ayarlandığını anlamak için <xref linkend="regexinfo-POSIX-Regular-Expression-Compiling"/> bölümüne bakınız.) Şayet derlenmiş şablon <varname>dizge</varname> ile eşleşir ise işlev sıfır ile döner, eşleşmezse <literal>REG_NOMATCH</literal> (<filename>regex.h</filename> dosyasında tanımlanmıştır) ile döner.
    </para></funcdescr></funcsynopsis></para>
  </sect2><sect2 xml:id="regexinfo-Reporting-Errors" chunkthis="1">
    <title>Hataların Bildirilmesi</title>
    <titleabbrev><command>regerror()</command> işlevi</titleabbrev>
    <para>
<command>regcomp</command> veya <command>regexec</command> başarısız olursa, sıfırdan farklı bir değer olarak bir hata koduyla döner. Bu kodlar <filename>regex.h</filename> dosyasında tanımlanmıştır. Bu kodların anlamları için <xref linkend="regexinfo-POSIX-Regular-Expression-Compiling"/> ve <xref linkend="regexinfo-POSIX-Matching"/> bölümlerine bakınız.  Bu kodlara iişkin hata dizgelerini elde etmek için aşağıdaki işlevi kullanabilirsiniz.
</para><para xml:id="regexinfo-regerror">
<indexterm scope="regexinfo-cp"><primary><literal>regerror</literal> işlevi</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>regerror</command></funcdef>
<paramdef>(int            <varname>hatakodu</varname>,
 const regex_t *<varname>şablon</varname>,
 char          *<varname>hata_tamponu</varname>,
 size_t         <varname>boyut</varname>)</paramdef>
</funcprototype><funcdescr><para>
<varname>hatakodu</varname> bir hata kodudur, <varname>şablon</varname> hatayı oluşturan şablon tamponunun adresi, <varname>hata_tamponu</varname> hata tamponu ve <varname>boyut</varname> da <varname>hata_tamponu</varname>'nun boyudur.
    </para><para>
<command>regerror</command> işlevi <varname>hatakodu</varname>na karşılık olan hata dizgesinin uzunluğu (sonlandırıcı boş karakter dahil) ile döner. Ayrıca, <varname>boyut</varname> ve <varname>hata_tamponu</varname> sıfırdan farklıysa,
<varname>hata_tamponu</varname> içinde sonlandırıcı boş karakter içererek, hata dizgesinin ilk  <varname>boyut</varname> -1 karakteri ile döner. <varname>boyut</varname>,  <varname>hata_tamponu</varname>'nun uzunluğuna eşit ya da küçük negatif olmayan bir sayı olmalıdır.
    </para><para>
<command>regerror</command> işlevini hata dizgesi için ne kadar yer gerektiğini öğrenmek için boş bir <varname>hata_tamponu</varname> ve sıfır değerli <varname>boyut</varname> ile çağırabilirsiniz.
    </para></funcdescr></funcsynopsis></para>
  </sect2><sect2 xml:id="regexinfo-Using-Byte-Offsets" chunkthis="1">
    <title>Bayt Konumlarının kullanımı</title>
    <titleabbrev><command>regmatch_t </command> türü</titleabbrev>
    <para>
POSIX'de <command>regmatch_t</command> türündeki değişkenler benzer bilgileri tutmalarına rağmen <link linkend="regexinfo-Using-Registers">GNU'nun yazmaçları</link> ile aynı değillerdir. POSIX'deki yazmaçlar hakkında bilgi almak için, <command>regexec</command> işlevine  <command>regmatch_t</command> türünde sıfırdan farklı bir <varname>eşleşenler</varname> adresi aktarmalısınız. <command>regmatch_t</command> yapısı <filename>regex.h</filename> başlık dosyasında tanımlanmıştır:
</para><para xml:id="regexinfo-regmatch_t">
<indexterm scope="regexinfo-cp"><primary><literal>regmatch_t</literal> türü</primary></indexterm>
<funcsynopsis><funcprototype role="veri türü">
<funcdef>typedef struct<command/></funcdef>
<paramdef>
{
  regoff_t <literal>rm_so</literal>;
  regoff_t <literal>rm_eo</literal>;
}<command>regmatch_t</command>;</paramdef>
</funcprototype><funcdescr><para>
Eşleştirme işlevlerinin yazmaçlar içinde bilgileri nasıl sakladığını <xref linkend="regexinfo-Using-Registers"/> bölümünden okurken, <varname>yazmaçlar</varname> yerine <varname>eşleşenler</varname>, <varname>yazmaçlar</varname><literal>->start[<emphasis>i</emphasis>]</literal> yerine <varname>eşleşenler</varname><literal>[<emphasis>i</emphasis>]->rm_so</literal> ve <varname>yazmaçlar</varname><literal>->end[<emphasis>i</emphasis>]</literal> yerine
<varname>eşleşenler</varname><literal>[<emphasis>i</emphasis>]->rm_eo</literal> koyun.
    </para></funcdescr></funcsynopsis></para>
  </sect2><sect2 xml:id="regexinfo-Freeing-POSIX-Pattern-Buffers" chunkthis="1">
    <title>POSIX Şablon Tamponlarının Serbest Bırakılması</title>
    <titleabbrev><command>regfree()</command> işlevi</titleabbrev>
    <para>
Bir şablon tamponunun alanlarına ayrılan yeri serbest bırakmak için aşağıdaki işlevi kullanabilirsiniz.
</para><para xml:id="regexinfo-regfree">
<indexterm scope="regexinfo-cp"><primary><literal>regfree</literal> işlevi</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>void <command>regfree</command></funcdef>
<paramdef>(regex_t *<varname>şablon</varname>)</paramdef>
</funcprototype><funcdescr><para>
<varname>şablon</varname> serbest bırakacağınız alanlarla ayrılmış şablon tamponudur. <command>regfree</command> işlevi ayrıca, <varname>şablon</varname>'un <command>ayrılmış</command> ve <command>kullanılmış</command> alanlarına sıfır atar. Bir şablon tamponunu boşalttıktan sonra, <link linkend="regexinfo-POSIX-Matching">eşleştirme işlevini</link> kullanmadan önce, bu tampon içinde tekrar bir düzenli ifade <link linkend="regexinfo-POSIX-Regular-Expression-Compiling">derlemelisiniz</link>.
    </para></funcdescr></funcsynopsis></para>
  </sect2>
</sect1>
<sect1 xml:id="regexinfo-BSD-Regex-Functions">
  <title>BSD Regex İşlevleri</title>
  <para>
Şayet, Berkeley UNIX ile uyumlu kodlar yazıyorsanız, arayüzleri Berkeley UNIX ile aynı olan bu işlevlere ihtiyaç duyacaksınız demektir.
  </para>
  <sect2 xml:id="regexinfo-BSD-Regular-Expression-Compiling" chunkthis="1">
    <title>BSD Düzenli İfadelerinin Derlenmesi</title>
    <titleabbrev><command>re_comp()</command> işlevi</titleabbrev>
    <para>
Berkeley UNIX ile, sadece belirtilen bir düzenli ifade için arama yapabilirsiniz, eşleştirme yapamazsınız. Arama yapmak için, ilk önce onu derlemelisiniz. Derlemeden önce, düzenli ifade sözdiziminin <command>re_syntax_options</command> (<link linkend="regexinfo-Regular-Expression-Syntax">bazı sözdizimleri</link> <filename>regex.h</filename> içinde belirtilmiştir) değişkeninin ayarlarına göre derlenmesini istediğinizi belirtmelisiniz. Bir düzenli ifadeyi derlemek için aşağıdaki işlevi kullanabilirsiniz.
</para><para xml:id="regexinfo-re_comp">
<indexterm scope="regexinfo-cp"><primary><literal>re_comp</literal> işlevi</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>char *<command>re_comp</command></funcdef>
<paramdef>(char *<varname>düzifd</varname>)</paramdef>
</funcprototype><funcdescr><para>
<varname>düzifd</varname> boş karakter sonlandırmalı düzenli ifadenin adresidir.
<command>re_comp</command> işlevi, sadece son derlenen şablon tamponunun kullanılabileceği bir dahili şablon tamponu kullanır. Bunun anlamı; şayet daha önceden derlediğiniz bir düzenli ifadeyi kullanmak istiyorsanız —fakat bu ifade sizin en son derlediğiniz olmayacak- onu tekrar derlemek zorundasınız. Şayet <command>re_comp</command> işlevini bir boş gösterici (bir boş dizge değil) ile çağırırsanız şablon tamponun içeriği değişmez.
    </para><para>
<command>re_comp</command> düzenli ifadeyi derleyebilirse, sıfırla döner. Derleyemezse, bir hata dizgesi döndürür. <command>re_comp</command> işlevinin hata dizgeleri <link linkend="regexinfo-GNU-Regular-Expression-Compiling"><command>re_compile_pattern</command></link>'inkiler ile aynıdır.
    </para></funcdescr></funcsynopsis></para>
  </sect2><sect2 xml:id="regexinfo-BSD-Searching" chunkthis="1">
    <title>BSD Araması</title>
    <titleabbrev><command>re_exec()</command> işlevi</titleabbrev>
    <para>
Berkeley UNIX tarzı arama, bir dizgenin ilk karakterinden itibaren aramaya başlamak ve eşleşecek ardışık pozisyonlara ulaşmaya çalışmak demektir. <link linkend="regexinfo-BSD-Regular-Expression-Compiling"><command>re_comp</command></link> kullanarak bir şablonu derledikten sonra, Regex’e bu şablonu bir dizge içinde aramak için aşağıdaki işlevi kullanabilirsiniz.
</para><para xml:id="regexinfo-re_exec">
<indexterm scope="regexinfo-cp"><primary><literal>re_exec</literal> işlevi</primary></indexterm>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>re_exec</command></funcdef>
<paramdef>(char *<varname>dizge</varname>)</paramdef>
</funcprototype><funcdescr><para>
<varname>dizge</varname> arama yapılacak boş karakter sonlandırmalı dizgenin adresidir.
    </para><para>
<command>re_exec</command> başarılı olursa 1, aksi takdirde 0 ile döner. Bir <link linkend="regexinfo-Searching-with-Fastmaps">GNU hızlı eşlemi</link> özdevinimli kullanılır.
    </para></funcdescr></funcsynopsis></para>
  </sect2></sect1>
</chapter>
<appendix xml:id="regexinfo_Copying-This-Manual">
  <title>Bu Kılavuzun Kopyalanması</title>
  <indexterm role="cp"><primary>GNU Free Documentation License</primary></indexterm>
  <indexterm role="cp"><primary>GNU Özgür Belgeleme Lisansı</primary></indexterm>
  <para>
GNU Özgür Belgeleme Lisansı ile lisanslanmış belgelerin bu lisansı içermesi gerektiğinden ve bu lisans kendisinin değiştirilmesine izin vermediğinden (buna tercüme de dahildir) lisans hiçbir değişiklik yapılmaksızın burada belgeye eklenmiştir.
</para><para>
(Ç.N. - GNU Özgür Belgeleme Lisansı bu özelliği sebebiyle dili İngilizce olmayan belgelerde kullanmak için uygun değildir; Türkçe belgenize İngilizce bir metin eklemek istemezsiniz, herhalde. Daha özgür -kendinin belgeye eklenmesini zorunlu kılmayan- lisanslar da var. Örneğin "Creative Commons Share Alike" kendinin belgeye eklenmesini zorunlu kılmaması dışında GNU ÖBL'ye hemen hemen eşdeğerdir.)
  </para>
  <bridgehead xml:id="regexinfo_gfdl" renderas="sect1">GNU Free Documentation License</bridgehead>
   <para>Version 1.2, November 2002</para>
<screen>Copyright &copy; 2000,2001,2002 Free Software Foundation, Inc.
59 Temple Place, Suite 330, Boston, MA  02111-1307, USA

Everyone is permitted to copy and distribute verbatim copies
of this license document, but changing it is not allowed.
</screen>
   <orderedlist numeration="arabic">
    <listitem><para>PREAMBLE</para><para>
The purpose of this License is to make a manual, textbook, or other
functional and useful document <firstterm>free</firstterm> in the sense of freedom: to
assure everyone the effective freedom to copy and redistribute it,
with or without modifying it, either commercially or noncommercially.
Secondarily, this License preserves for the author and publisher a way
to get credit for their work, while not being considered responsible
for modifications made by others.
     </para>

     <para>
This License is a kind of "copyleft", which means that derivative
works of the document must themselves be free in the same sense.  It
complements the GNU General Public License, which is a copyleft
license designed for free software.
     </para>

     <para>
We have designed this License in order to use it for manuals for free
software, because free software needs free documentation: a free
program should come with manuals providing the same freedoms that the
software does.  But this License is not limited to software manuals;
it can be used for any textual work, regardless of subject matter or
whether it is published as a printed book.  We recommend this License
principally for works whose purpose is instruction or reference.
     </para>
</listitem>
    <listitem>
     <para>
APPLICABILITY AND DEFINITIONS
     </para>

     <para>
This License applies to any manual or other work, in any medium, that
contains a notice placed by the copyright holder saying it can be
distributed under the terms of this License.  Such a notice grants a
world-wide, royalty-free license, unlimited in duration, to use that
work under the conditions stated herein.  The "Document", below,
refers to any such manual or work.  Any member of the public is a
licensee, and is addressed as "you".  You accept the license if you
copy, modify or distribute the work in a way requiring permission
under copyright law.
     </para>

     <para>
A "Modified Version" of the Document means any work containing the
Document or a portion of it, either copied verbatim, or with
modifications and/or translated into another language.
     </para>

     <para>
A "Secondary Section" is a named appendix or a front-matter section
of the Document that deals exclusively with the relationship of the
publishers or authors of the Document to the Document's overall
subject (or to related matters) and contains nothing that could fall
directly within that overall subject.  (Thus, if the Document is in
part a textbook of mathematics, a Secondary Section may not explain
any mathematics.)  The relationship could be a matter of historical
connection with the subject or with related matters, or of legal,
commercial, philosophical, ethical or political position regarding
them.
     </para>

     <para>
The "Invariant Sections" are certain Secondary Sections whose titles
are designated, as being those of Invariant Sections, in the notice
that says that the Document is released under this License.  If a
section does not fit the above definition of Secondary then it is not
allowed to be designated as Invariant.  The Document may contain zero
Invariant Sections.  If the Document does not identify any Invariant
Sections then there are none.
     </para>

     <para>
The "Cover Texts" are certain short passages of text that are listed,
as Front-Cover Texts or Back-Cover Texts, in the notice that says that
the Document is released under this License.  A Front-Cover Text may
be at most 5 words, and a Back-Cover Text may be at most 25 words.
     </para>

     <para>
A "Transparent" copy of the Document means a machine-readable copy,
represented in a format whose specification is available to the
general public, that is suitable for revising the document
straightforwardly with generic text editors or (for images composed of
pixels) generic paint programs or (for drawings) some widely available
drawing editor, and that is suitable for input to text formatters or
for automatic translation to a variety of formats suitable for input
to text formatters.  A copy made in an otherwise Transparent file
format whose markup, or absence of markup, has been arranged to thwart
or discourage subsequent modification by readers is not Transparent.
An image format is not Transparent if used for any substantial amount
of text.  A copy that is not "Transparent" is called "Opaque".
     </para>

     <para>
Examples of suitable formats for Transparent copies include plain
ascii without markup, Texinfo input format, LaTeX input
format, <acronym>SGML</acronym> or <acronym>XML</acronym> using a publicly available
<acronym>DTD</acronym>, and standard-conforming simple <acronym>HTML</acronym>,
PostScript or <acronym>PDF</acronym> designed for human modification.  Examples
of transparent image formats include <acronym>PNG</acronym>, <acronym>XCF</acronym> and
<acronym>JPG</acronym>.  Opaque formats include proprietary formats that can be
read and edited only by proprietary word processors, <acronym>SGML</acronym> or
<acronym>XML</acronym> for which the <acronym>DTD</acronym> and/or processing tools are
not generally available, and the machine-generated <acronym>HTML</acronym>,
PostScript or <acronym>PDF</acronym> produced by some word processors for
output purposes only.
     </para>

     <para>
The "Title Page" means, for a printed book, the title page itself,
plus such following pages as are needed to hold, legibly, the material
this License requires to appear in the title page.  For works in
formats which do not have any title page as such, "Title Page" means
the text near the most prominent appearance of the work's title,
preceding the beginning of the body of the text.
     </para>

     <para>
A section "Entitled XYZ" means a named subunit of the Document whose
title either is precisely XYZ or contains XYZ in parentheses following
text that translates XYZ in another language.  (Here XYZ stands for a
specific section name mentioned below, such as "Acknowledgements",
"Dedications", "Endorsements", or "History".)  To "Preserve the Title"
of such a section when you modify the Document means that it remains a
section "Entitled XYZ" according to this definition.
     </para>

     <para>
The Document may include Warranty Disclaimers next to the notice which
states that this License applies to the Document.  These Warranty
Disclaimers are considered to be included by reference in this
License, but only as regards disclaiming warranties: any other
implication that these Warranty Disclaimers may have is void and has
no effect on the meaning of this License.
     </para>
</listitem>
    <listitem>
     <para>
VERBATIM COPYING
     </para>

     <para>
You may copy and distribute the Document in any medium, either
commercially or noncommercially, provided that this License, the
copyright notices, and the license notice saying this License applies
to the Document are reproduced in all copies, and that you add no other
conditions whatsoever to those of this License.  You may not use
technical measures to obstruct or control the reading or further
copying of the copies you make or distribute.  However, you may accept
compensation in exchange for copies.  If you distribute a large enough
number of copies you must also follow the conditions in section 3.
     </para>

     <para>
You may also lend copies, under the same conditions stated above, and
you may publicly display copies.
     </para>
</listitem>
    <listitem>
     <para>
COPYING IN QUANTITY
     </para>

     <para>
If you publish printed copies (or copies in media that commonly have
printed covers) of the Document, numbering more than 100, and the
Document's license notice requires Cover Texts, you must enclose the
copies in covers that carry, clearly and legibly, all these Cover
Texts: Front-Cover Texts on the front cover, and Back-Cover Texts on
the back cover.  Both covers must also clearly and legibly identify
you as the publisher of these copies.  The front cover must present
the full title with all words of the title equally prominent and
visible.  You may add other material on the covers in addition.
Copying with changes limited to the covers, as long as they preserve
the title of the Document and satisfy these conditions, can be treated
as verbatim copying in other respects.
     </para>

     <para>
If the required texts for either cover are too voluminous to fit
legibly, you should put the first ones listed (as many as fit
reasonably) on the actual cover, and continue the rest onto adjacent
pages.
     </para>

     <para>
If you publish or distribute Opaque copies of the Document numbering
more than 100, you must either include a machine-readable Transparent
copy along with each Opaque copy, or state in or with each Opaque copy
a computer-network location from which the general network-using
public has access to download using public-standard network protocols
a complete Transparent copy of the Document, free of added material.
If you use the latter option, you must take reasonably prudent steps,
when you begin distribution of Opaque copies in quantity, to ensure
that this Transparent copy will remain thus accessible at the stated
location until at least one year after the last time you distribute an
Opaque copy (directly or through your agents or retailers) of that
edition to the public.
     </para>

     <para>
It is requested, but not required, that you contact the authors of the
Document well before redistributing any large number of copies, to give
them a chance to provide you with an updated version of the Document.
     </para>
</listitem>
    <listitem>
     <para>
MODIFICATIONS
     </para>

     <para>
You may copy and distribute a Modified Version of the Document under
the conditions of sections 2 and 3 above, provided that you release
the Modified Version under precisely this License, with the Modified
Version filling the role of the Document, thus licensing distribution
and modification of the Modified Version to whoever possesses a copy
of it.  In addition, you must do these things in the Modified Version:
     </para>

     <orderedlist numeration="upperalpha">
      <listitem>
       <para>
Use in the Title Page (and on the covers, if any) a title distinct
from that of the Document, and from those of previous versions
(which should, if there were any, be listed in the History section
of the Document).  You may use the same title as a previous version
if the original publisher of that version gives permission.
       </para>
</listitem>
      <listitem>
       <para>
List on the Title Page, as authors, one or more persons or entities
responsible for authorship of the modifications in the Modified
Version, together with at least five of the principal authors of the
Document (all of its principal authors, if it has fewer than five),
unless they release you from this requirement.
       </para>
</listitem>
      <listitem>
       <para>
State on the Title page the name of the publisher of the
Modified Version, as the publisher.
       </para>
</listitem>
      <listitem>
       <para>
Preserve all the copyright notices of the Document.
       </para>
</listitem>
      <listitem>
       <para>
Add an appropriate copyright notice for your modifications
adjacent to the other copyright notices.
       </para>
</listitem>
      <listitem>
       <para>
Include, immediately after the copyright notices, a license notice
giving the public permission to use the Modified Version under the
terms of this License, in the form shown in the Addendum below.
       </para>
</listitem>
      <listitem>
       <para>
Preserve in that license notice the full lists of Invariant Sections
and required Cover Texts given in the Document's license notice.
       </para>
</listitem>
      <listitem>
       <para>
Include an unaltered copy of this License.
       </para>
</listitem>
      <listitem>
       <para>
Preserve the section Entitled "History", Preserve its Title, and add
to it an item stating at least the title, year, new authors, and
publisher of the Modified Version as given on the Title Page.  If
there is no section Entitled "History" in the Document, create one
stating the title, year, authors, and publisher of the Document as
given on its Title Page, then add an item describing the Modified
Version as stated in the previous sentence.
       </para>
</listitem>
      <listitem>
       <para>
Preserve the network location, if any, given in the Document for
public access to a Transparent copy of the Document, and likewise
the network locations given in the Document for previous versions
it was based on.  These may be placed in the "History" section.
You may omit a network location for a work that was published at
least four years before the Document itself, or if the original
publisher of the version it refers to gives permission.
       </para>
</listitem>
      <listitem>
       <para>
For any section Entitled "Acknowledgements" or "Dedications", Preserve
the Title of the section, and preserve in the section all the
substance and tone of each of the contributor acknowledgements and/or
dedications given therein.
       </para>
</listitem>
      <listitem>
       <para>
Preserve all the Invariant Sections of the Document,
unaltered in their text and in their titles.  Section numbers
or the equivalent are not considered part of the section titles.
       </para>
</listitem>
      <listitem>
       <para>
Delete any section Entitled "Endorsements".  Such a section
may not be included in the Modified Version.
       </para>
</listitem>
      <listitem>
       <para>
Do not retitle any existing section to be Entitled "Endorsements" or
to conflict in title with any Invariant Section.
       </para>
</listitem>
      <listitem>
       <para>
Preserve any Warranty Disclaimers.
       </para></listitem></orderedlist>

     <para>
If the Modified Version includes new front-matter sections or
appendices that qualify as Secondary Sections and contain no material
copied from the Document, you may at your option designate some or all
of these sections as invariant.  To do this, add their titles to the
list of Invariant Sections in the Modified Version's license notice.
These titles must be distinct from any other section titles.
     </para>

     <para>
You may add a section Entitled "Endorsements", provided it contains
nothing but endorsements of your Modified Version by various
parties--for example, statements of peer review or that the text has
been approved by an organization as the authoritative definition of a
standard.
     </para>

     <para>
You may add a passage of up to five words as a Front-Cover Text, and a
passage of up to 25 words as a Back-Cover Text, to the end of the list
of Cover Texts in the Modified Version.  Only one passage of
Front-Cover Text and one of Back-Cover Text may be added by (or
through arrangements made by) any one entity.  If the Document already
includes a cover text for the same cover, previously added by you or
by arrangement made by the same entity you are acting on behalf of,
you may not add another; but you may replace the old one, on explicit
permission from the previous publisher that added the old one.
     </para>

     <para>
The author(s) and publisher(s) of the Document do not by this License
give permission to use their names for publicity for or to assert or
imply endorsement of any Modified Version.
     </para>
</listitem>
    <listitem>
     <para>
COMBINING DOCUMENTS
     </para>

     <para>
You may combine the Document with other documents released under this
License, under the terms defined in section 4 above for modified
versions, provided that you include in the combination all of the
Invariant Sections of all of the original documents, unmodified, and
list them all as Invariant Sections of your combined work in its
license notice, and that you preserve all their Warranty Disclaimers.
     </para>

     <para>
The combined work need only contain one copy of this License, and
multiple identical Invariant Sections may be replaced with a single
copy.  If there are multiple Invariant Sections with the same name but
different contents, make the title of each such section unique by
adding at the end of it, in parentheses, the name of the original
author or publisher of that section if known, or else a unique number.
Make the same adjustment to the section titles in the list of
Invariant Sections in the license notice of the combined work.
     </para>

     <para>
In the combination, you must combine any sections Entitled "History"
in the various original documents, forming one section Entitled
"History"; likewise combine any sections Entitled "Acknowledgements",
and any sections Entitled "Dedications".  You must delete all
sections Entitled "Endorsements."
     </para>
</listitem>
    <listitem>
     <para>
COLLECTIONS OF DOCUMENTS
     </para>

     <para>
You may make a collection consisting of the Document and other documents
released under this License, and replace the individual copies of this
License in the various documents with a single copy that is included in
the collection, provided that you follow the rules of this License for
verbatim copying of each of the documents in all other respects.
     </para>

     <para>
You may extract a single document from such a collection, and distribute
it individually under this License, provided you insert a copy of this
License into the extracted document, and follow this License in all
other respects regarding verbatim copying of that document.
     </para>
</listitem>
    <listitem>
     <para>
AGGREGATION WITH INDEPENDENT WORKS
     </para>

     <para>
A compilation of the Document or its derivatives with other separate
and independent documents or works, in or on a volume of a storage or
distribution medium, is called an "aggregate" if the copyright
resulting from the compilation is not used to limit the legal rights
of the compilation's users beyond what the individual works permit.
When the Document is included an aggregate, this License does not
apply to the other works in the aggregate which are not themselves
derivative works of the Document.
     </para>

     <para>
If the Cover Text requirement of section 3 is applicable to these
copies of the Document, then if the Document is less than one half of
the entire aggregate, the Document's Cover Texts may be placed on
covers that bracket the Document within the aggregate, or the
electronic equivalent of covers if the Document is in electronic form.
Otherwise they must appear on printed covers that bracket the whole
aggregate.
     </para>
</listitem>
    <listitem>
     <para>
TRANSLATION
     </para>

     <para>
Translation is considered a kind of modification, so you may
distribute translations of the Document under the terms of section 4.
Replacing Invariant Sections with translations requires special
permission from their copyright holders, but you may include
translations of some or all Invariant Sections in addition to the
original versions of these Invariant Sections.  You may include a
translation of this License, and all the license notices in the
Document, and any Warranty Disclaimers, provided that you also include
the original English version of this License and the original versions
of those notices and disclaimers.  In case of a disagreement between
the translation and the original version of this License or a notice
or disclaimer, the original version will prevail.
     </para>

     <para>
If a section in the Document is Entitled "Acknowledgements",
"Dedications", or "History", the requirement (section 4) to Preserve
its Title (section 1) will typically require changing the actual
title.
     </para>
</listitem>
    <listitem>
     <para>
TERMINATION
     </para>

     <para>
You may not copy, modify, sublicense, or distribute the Document except
as expressly provided for under this License.  Any other attempt to
copy, modify, sublicense or distribute the Document is void, and will
automatically terminate your rights under this License.  However,
parties who have received copies, or rights, from you under this
License will not have their licenses terminated so long as such
parties remain in full compliance.
     </para>
</listitem>
    <listitem>
     <para>
FUTURE REVISIONS OF THIS LICENSE
     </para>

     <para>
The Free Software Foundation may publish new, revised versions
of the GNU Free Documentation License from time to time.  Such new
versions will be similar in spirit to the present version, but may
differ in detail to address new problems or concerns.  See
http://www.gnu.org/copyleft/.
     </para>

     <para>
Each version of the License is given a distinguishing version number.
If the Document specifies that a particular numbered version of this
License "or any later version" applies to it, you have the option of
following the terms and conditions either of that specified version or
of any later version that has been published (not as a draft) by the
Free Software Foundation.  If the Document does not specify a version
number of this License, you may choose any version ever published (not
as a draft) by the Free Software Foundation.
     </para></listitem></orderedlist>
   <bridgehead renderas="sect2">ADDENDUM: How to use this License for your documents</bridgehead>
    <para>
To use this License in a document you have written, include a copy of
the License in the document and put the following copyright and
license notices just after the title page:
    </para>
    <para><screen>
  Copyright (C)  <varname>year</varname>  <varname>your name</varname>.
  Permission is granted to copy, distribute and/or modify this document
  under the terms of the GNU Free Documentation License, Version 1.2
  or any later version published by the Free Software Foundation;
  with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
  A copy of the license is included in the section entitled ``GNU
  Free Documentation License''.
     </screen>    </para>
    <para>
If you have Invariant Sections, Front-Cover Texts and Back-Cover Texts,
replace the "with...Texts." line with this:
    </para><para>
<screen>
with the Invariant Sections being <varname>list their titles</varname>, with
the Front-Cover Texts being <varname>list</varname>, and with the Back-Cover Texts
being <varname>list</varname>.
</screen>
     </para><para>
If you have Invariant Sections without Cover Texts, or some other
combination of the three, merge those two alternatives to suit the
situation.
    </para>
    <para>
If your document contains nontrivial examples of program code, we
recommend releasing these examples in parallel under your choice of
free software license, such as the GNU General Public License,
to permit their use in free software.
    </para>
</appendix>

<index xml:id="regexinfo-cp" condition="multi-index"><title>Dizin</title></index>
</book>