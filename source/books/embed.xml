<?xml version="1.0" encoding="UTF-8"?>
<!--DOCTYPE book SYSTEM "../../docbook/dtd/docbookx.dtd"-->
<!-- ********************************************************************
     $Id: embed.xml,v 1.4 2002/09/30 18:21:14 nilgun Exp $
     ******************************************************************** -->
<book id="embedded">
  <?dbhtml dir="../embedded"?>
  <bookinfo>
  <date>18 Mayıs 2003</date>
  <title>Gömülü Sistemler İçin Linux Dağıtımı Geliştirme</title>
  <author>
    <firstname>Murat</firstname>
    <surname>Demirten</surname>
    <affiliation>
      <address><email>murat@debian.org</email></address>
    </affiliation>
  </author>
  <abstract>
    <para>
Bu belge gömülü sistemler için Linux kullanacak kişilere faydalı olması amacıyla hazırlanmaktadır.
    </para><para>
Daha derli toplu bir içerik oluşturduktan sonra sayfaya koymayı düşünüyordum, ancak yoğun iş temposu nedeniyle bir süre yazıma ara vermek zorunda kalacağım. Bu nedenle şu anki haliyle birilerine yardımcı olabilir düşüncesiyle siteye koydum. Her türlü görüş, öneri ve istekleriniz için <email>murat@debian.org</email> adresine yazabilirsiniz.
    </para>
  </abstract>
  <revhistory>
    <revision>
      <revnumber>Versiyon 1.0.0</revnumber>
      <date>26 Mayıs 2003</date>
      <authorinitials>murat</authorinitials>
      <revremark>İlk sürüm</revremark>
    </revision>
  </revhistory>
  <copyright><year>2003</year><holder>Murat Demirten</holder></copyright>
  <legalnotice><title>Yasal Uyarı</title><para>
Bu belgeyi, Free Software Foundation tarafından yayınlanmış bulunan GNU Genel Kamu Lisansının 2 ya da daha sonraki sürümünün koşullarına bağlı kalarak kopyalayabilir, dağıtabilir ve/veya değiştirebilirsiniz. Bu lisansın bir kopyasını <ulink url="http://www.gnu.org/copyleft/gpl.html"/> adresinde bulabilirsiniz.
  </para>
  <para>
Bu belgedeki bilgilerin kullanımından doğacak sorumluluklar ve olası zararlardan belge yazarı sorumlu tutulamaz. Bu belgedeki bilgileri uygulama sorumluluğu uygulayana aittir.
  </para>
  <para>
Tüm telif hakları aksi özellikle belirtilmediği sürece sahibine aittir. Belge içinde geçen herhangi bir terim bir ticarî isim yada kuruma itibar kazandırma olarak algılanmamalıdır. Bir ürün ya da markanın kullanılmış olması ona onay verildiği anlamında görülmemelidir.
  </para>
  </legalnotice>
  </bookinfo>

  <chapter id="embedded-giris">
    <title>Gömülü (Embedded) Sistemler</title>
    <para>
Gömülü sistemler, özel amaçlar için kullanılmak üzere tasarlanmış, sadece beklenilen görevleri yerine getirmeye programlanmış aygıtlardır. Buradaki amaç belirli bir görevi mümkün olduğu kadar iyi bir şekilde yerine getirmektir.
    </para>
    <para>
Gömülü sistemler hiçbir zaman kişisel bilgisayarlar gibi genel amaçlı kullanımlar için uygun değildir. Kişisel bir bilgisayar ile gömülü sistemlerle yapılabilecek işler de gerçekleştirilebilecek olmasına rağmen böyle bir kullanım çoğu durumda kaynakların verimsiz kullanılmasına yol açacaktır.
    </para>

    <sect1 id="embedded-linux">
    <title>Gömülü Sistemler ve Linux</title>
    <para>
Özellikle donanım teknolojisindeki hızlı gelişmelerle birlikte akıllı cihazlarla sıklıkla karşılaşır olduk. Gömülü aygıtlar (Embedded Devices) olarak adlandırılan bu sistemler yaptıkları işin kapsamına göre özelleştirilmiş işletim sistemleri kullanırlar. Bu türden aygıtlar için geliştirilen özel işletim sistemleri pazarı şimdilerde büyük bir tehlikeyle karşı kaşıya. Tehlikenin adı Linux!
    <computeroutput>:)</computeroutput>
    </para>
    <para>
Gömülü sistemlerde kullanılmak üzere geliştirilmiş pek çok ticari ve ticari olmayan işletim sistemi bulunmakla birlikte, bu belgede sadece Linux işletim sisteminin bu anlamda kullanılabilmesinden bahsedilecektir. Standartları oturmuş, halihazırda on binlerce uygulamayı barındıran komple bir işletim sistemi olarak Linux'un yakın gelecekte bu pazarda çok yoğun bir şekilde kullanılacağını düşünüyoruz.
    </para>
    </sect1>
    <sect1 id="embedded-is"><title>Linux İşletim Sistemi</title>
    <para>
Linux işletim sistemi Linus Torvalds tarafından 1991 yılında ilk duyurulduğunda ancak bir işletim sisteminden beklenen en temel özellikleri yerine getirebiliyor ve sadece Intel-x86 mimarisinde çalışabiliyordu. 2003 yılına gelindiğinde ise Linux çok sayıda mimariye taşınmış ve kaynak kodunun büyüklüğü devasa boyutlara ulaşmıştır. Modüler ve güçlü yapısı, özelleştirilmeye uygunluğu ve kaynak kodunun açık olması gibi özellikleriyle Linux, gömülü işletim sistemleri pazarında da giderek artan bir yoğunlukla kullanılmaya başlanmıştır. Yapılan tahminler ve piyasa araştırmaları sonuçları çok yakın gelecekte gömülü işletim sistemleri pazarına hitap eden ürünlerin büyük oranda Linux tabanlı olacağı yönündedir.
    </para>
    <para>
Gömülü sistemler için özel bir işletim sistemi yazma çalışması pek çok zorluğu barındırmaktadır. Yazılan kodların çok sayıda kişi veya grup tarafından test edilmesi gereklidir, ancak özel bir işletim sistemi çekirdeği kullanıldığından test edebilecek kişi sayısı olması gereken sayının çok altında bir değer olacaktır. Ayrıca benzer işlemler için, sıfırdan bir işletim sisteminin geliştirilmesi zaman ve para kaybına yol açmaktadır. Basit bir örnek verecek olursak, eğer sisteminizde TCP/IP yığıtı kullanılacak ise, yeni geliştirilen, çok sayıda kişi tarafından test edilme fırsatı bulamayan bir işletim sistemi, mutlaka ciddi hataları kendi TCP/IP yığıtı içerisinde barındıracaktır. Oysaki aynı işlem Linux ile gerçekleştirilmeye çalışıldığında, TCP/IP yığıtından kaynaklanan bir hata çıkma olasılığının ne kadar düşük olacağı ortadadır.
    </para>
    <para>
Gömülü sistemler için Linux kullanımının, sadece alt katmandaki çekirdeğin sağlamlığı açısından değil, üzerinde halihazırda çalışan ve yeni geliştirilmekte olan uygulamaların çokluğu yönünden de ciddi getirileri mevcuttur. Kaynak kodu açık ve bu nedenle özelleştirmelere çok müsait binlerce programa her geçen gün artan bir hızla yenileri de eklenmektedir. Üstelik bu programlar da tüm dünyada çok sayıda kişi tarafından kullanıldığından, karşınıza çıkabilecek hata sayısı az olacaktır ve yeni bir hata bulunsa dahi hatanın düzeltilebilmesi anlamında çoğu durumda bizzat sizin bir şeyler yapmanıza gerek kalmayacak, birileri bunu zaten yapacaktır.
    </para>
    </sect1>
    <sect1 id="embedded-sbc">
<title>Tek Kartta Bilgisayar (<acronym>SBC</acronym> - Single Board Computer)</title>
 <para>
Bu belgede gömülü sistemler için Linux dağıtımı geliştiriminden bahsederken aslında kullandığımız donanım bir Tek Kartta Bilgisayar olacaktır. SBC, temel olarak bir masaüstü bilgisayarından çok farklı olmamakla birlikte, üzerinde kullanılan bazı bileşenlerde farklılıklar gösterir. Bu farklılık işlemciden başlar. SBC üzerlerindeki işlemcilerin çoğunluğu Intel x86 uyumlu olsa da standart bir Intel işlemci değildir. Farklı firmalarca, Intel uyumluluğu göz önünde bulundurularak daha az güç tüketecek, daha az yer kaplayacak ve elbette daha düşük maliyetlerle üretilebilecek şekilde tasarlanmışlardır.
    </para>
    <para>
Sistemin diğer bileşenleri için de aynı durum söz konusudur. Bellek, ekran kartı, ağ kartı, ses kartı gibi bileşenler genelde tümleşik olarak (on-board) gelmektedir. Depolama amacıyla Flash Disk teknolojileri kullanılır: Disk On Module, Disk On Chip veya Compact Flash.
    </para>
    <para>
Piyasada farklı büyüklükte ve çok farklı amaçlar için üretilmiş SBC'ler mevcuttur. Genel
 olarak baktığımızda iki tür SBC olduğunu görmekteyiz. Bunlardan birincisi, gerekli tüm bileşenleri
 içeren (All-in-one) tümleşik yapıdaki SBC'lerdir. Bunlar hemen her zaman tek başlarına kullanılır.
 İkinci tür ise gömülü sistemler için temel işlevleri içeren ancak daha büyük sistemler veya
 kartlara takılarak bütünleşik olarak çalışan, diğer türe göre özellikleri daha kısıtlı ve daha kendine
 özgü SBC'lerdir. Fikir vermesi açısından piyasadaki ürünlerin bazılarını inceleyelim. Buradaki veriler
 2002 Ağustos ayı için geçerli olduğundan arada geçen süre zarfındaki olası gelişmeleri de hesaba
 katınız. Ayrıntılı bilgileri üretici firmaların web adreslerinden elde edebilirsiniz.
    </para>
    <sect2><title>Advantech Half-Biscuit</title>
    <para>
Standart 3,5" büyüklüğünde bir SBC. Üzerinde masaüstü bilgisayarınızda bulunan hemen her bileşen mevcut. National Geode, Transmeta Crusoe ve Cyrix işlemci seçenekleri var. 486-100 ile P3-600 işlemcileri arasındakilerle eşdeğer hızlarda çalışabilen modellerini bulabilirsiniz. Üretici firma adresi: <ulink url="http://www.advantech.com"/>
    </para><figure>
    <title>Advantech's Half-Biscuit</title>
    <mediaobject><imageobject>
<imagedata  fileref="advantech.jpg" scalefit="1" width="400pt" depth="300pt" format="JPEG"/>
    </imageobject><textobject><phrase>Advantech Half-Biscuit</phrase></textobject></mediaobject>
    </figure>
    </sect2>

    <sect2><title>Ampro EnCore</title>
    <para>
Her birini 3.9" x 5.7" büyüklüğündeki modüller halinde bulup, bunları birleştirebileceğiniz türden bir SBC. İşlemci, Flash depolama birimi, IDE, disket sürücü, ethernet, seri, paralel, ses çıkışları, LCD ve CRT ekran çıkışları modül üzerinde yer almaktadır. İşlemci seçenekleri 486, Pentium, PentiumIII, MIPS ve PowerPC'dir. Üretici firmanın adresi: <ulink url="http://www.ampro.com"/>
    </para><figure>
    <title>Ampro EnCore</title>
    <mediaobject><imageobject>
<imagedata fileref="ampro.jpg" scalefit="1" width="400pt" depth="300pt" format="JPEG"/>
    </imageobject><textobject><phrase>Ampro EnCore</phrase></textobject></mediaobject>
    </figure>
    </sect2>

    <sect2><title>JUMPtec Adastra ETX</title>
    <para>
3.7" x 4.4" boyutlarında üretilen SBC, modüler yapısı sayesinde farklı sistemlerle bütünleşebiliyor. Her ETX modülü işlemci, bellek, IO birimleri, USB, ses ve ethernet desteğini içermektedir. National Geode, Intel Pentium II ve Intel Pentium III işlemcilerini desteklemektedir. Üretici firma adresi: <ulink url="http://www.adastra.com"/>
    </para><figure><title>JUMPtec Adastra ETX</title>
    <mediaobject><imageobject>
      <imagedata fileref="jumptec.jpg" scalefit="1" width="400pt" depth="300pt" format="JPEG"/>
    </imageobject><textobject><phrase>JUMPtec Adastra ETX</phrase></textobject></mediaobject>
    </figure>

    </sect2>
    <sect2><title>AMC Technologies NETdimm</title>
    <para>
5.25" x 1.5" boyutlarında dimmPCI normunda olan bu küçük SBC 32 MB SDRAM bellek, 8 MB Flash disk dahili ethernet, LCD denetleyici ve iki seri portla birlikte gelmektedir. Üretici firmanın adresi: <ulink url="http://www.amctechcorp.com"/>
    </para><figure><title>AMC Technologies NETdimm</title>
    <mediaobject><imageobject>
      <imagedata fileref="amc.jpg" scalefit="1" width="600pt" depth="200pt" format="JPEG"/>
    </imageobject><textobject><phrase>AMC Technologies NETdimm</phrase></textobject></mediaobject>
    </figure>
    </sect2>

    <sect2><title>FORTH-SYSTEME DIMM-520</title>
    <para>
Oldukça küçük boyutlardaki (2.7" x 2") bu SBC üzerinde 32 bit 133 Mhz AMD ElanSC520 x86 tabanlı bir işlemci mevcut. Ayrıca 64 MB SDRAM bellek, 16 MB Flash disk, PCI veriyolu, 2 seri 1 paralel çıkış ve dahili 100 Mbit ethernet desteği de bu küçük cihaz üzerine sığdırılmış durumda. Üretici firma adresi: <ulink url="http://www.fsforth.de"/>
    </para><figure><title>FORTH-SYSTEME DIMM-520</title>
    <mediaobject><imageobject>
      <imagedata fileref="forth.jpg" scalefit="1" width="400pt" depth="300pt" format="JPEG"/>
    </imageobject><textobject><phrase>FORTH-SYSTEME DIMM-520</phrase></textobject></mediaobject>
    </figure>
    </sect2>

    <sect2><title>Techsol Medallion</title>
    <para>
En küçük SBC'lerden biri, sadece 10 cm<subscript>2</subscript> alan kaplıyor. 60MHz ARM-720T RISC işlemci, 32 MB SDRAM, 32 MB Flash disk, 2 seri port, IrDA ve USB desteğiyle birlikte gelmektedir. Üretici firmanın adresi:  <ulink url="http://www.techsol.ca"/>
    </para><figure><title>Techsol Medallion</title>
    <mediaobject><imageobject>
      <imagedata fileref="techsol.jpg" scalefit="1" width="350pt" depth="250pt" format="JPEG"/>
    </imageobject><textobject><phrase>Techsol Medallion</phrase></textobject></mediaobject>
    </figure>
    </sect2>
    </sect1>
  </chapter>
  <chapter id="embedded-hazirlik"><title>Kurulum Öncesi Hazırlık</title>
    <para>
Bir Tek Kartta Bilgisayar üzerine Linux işletim sisteminin kurulması temelde bir Linux dağıtımı geliştiriminden farksızdır. Yani Red Hat, Debian vb. gibi Linux dağıtımlarının geliştirimi aşamasında yapılanlara benzer işlemlerin yapılması gereklidir. Fakat gömülü bir sistem geliştirirken çok kapsamlı bir kurulum programı hazırlamak gereksizdir, hemen her durumda ana sistem bir defa kurulur ve sonra bire bir kopyalama ve güncellemeler yoluyla yeni sistemler oluşturulur. Bütün mesele sistemi ilk başta kurabilmek ve sisteme hakim olabilmektir.
    </para>
    <para>
Linux üzerinde verimli çalışabilmek için sistemin işleyişi hakkında bilgi sahibi olunması gerekir. Sorunların büyük çoğunluğu sistem bileşenlerin seçimi ve kullanımından kaynaklanır. Sistem belirli bir kararlılığa ulaştıktan sonra sürekli sisteme müdahale gerekmeyecektir, ancak o aşamaya gelene kadar mutlaka ciddi çaba sarfedilmelidir.
    </para>
    <para>
Sistemin geliştirimine başlamadan önce kullanılan donanımın karakteristik özelliklerinin belirlenmesi ve buna göre sistemin tasarlanması gerekir. Küçük disk ve bellek hacmi bunların başında gelir. Ancak sistemin temel olarak yapacağı işlemlerin özellikleri ve sık kullanılan donanım bileşenlerinin kısıtlamaları birlikte düşünüldüğünde ek tasarım prensipleri de ortaya çıkacaktır.
    </para>
    <sect1 id="embedded-bilesenler"><title>Gerekli Bileşenler</title>
    <para>
Kurulum çalışmasına başlayabilmemiz için ihtiyaç duyduğumuz bileşenler aşağıdaki gibidir:
    </para><itemizedlist mark="bullet">
      <listitem>
Elbette bir Tek Kartta Bilgisayar<literal> :)</literal>
      </listitem><listitem>
Linux ve geliştirme uygulamalarının kurulu olduğu bir kişisel bilgisayar
      </listitem><listitem>
SBC'den Linux'u açabilmek amacıyla bir disket veya CD-ROM sürücü
      </listitem><listitem>
Şart olmamakla birlikte seri port üzerinden dosya aktarımı yapılacaksa bir "seri iletişim kablosu"
      </listitem></itemizedlist>
    <figure><title>Kullandığımız Tek Kartta Bilgisayar - Arbor</title>
    <mediaobject><imageobject>
<imagedata fileref="arbor.jpg" format="JPEG" scalefit="1" width="400pt" depth="300pt"/>
    </imageobject><textobject><phrase>Arbor</phrase></textobject>
    </mediaobject>
    </figure>
    </sect1>

    <sect1 id="embedded-kurulum"><title>Farklı Kurulum Seçenekleri</title>
    <para>
GNU/Linux sistemlerinde bir işi yapmanın daima birden fazla yolu mevcuttur. Aynı kural bizim için de geçerli. Amacımız elimizdeki SBC üzerinde çalışan kendi GNU/Linux dağıtımımızı oluşturmak, fakat bu işi yaparken nasıl bir yol izlemeliyiz?
    </para>
    <para>
Geliştirme yaparken en fazla kolaylık sağlayacak seçenek, SBC üzerindeki diskin, geliştirme  amaçlı kullandığınız Linux bilgisayara takılıp, tüm geliştirmenin burada yapılması; disk hazır olduğunda SBC üzerine takılarak sistemin çalıştırılmasıdır. Bu yöntemin bize sağlayacağı en büyük getiri, geliştirme sırasında sürekli disket veya CD-ROM ile iki sistem arasında dosya taşıma işlemine gerek kalmamasıdır.
    </para>
    <para>
Örnek olarak, piyasada yaygın olarak kullanılan 40 pinlik IDE bağlantısı ile anakarta takılan bir DiskOnModule kullanacaksanız, aynı anda hem DiskOnModule'u hem de diskinizi bilgisayarınıza takabilmek için, uçlarından biri 40 pin, diğeri standart 44 pin olan IDE kablosu bulmalısınız. Buna benzer bileşenler şanslı iseniz bazen SBC ile birlikte gelmektedir. Diğer durumda kendi başınıza yapmalı veya yapabilen birilerini bulmalısınız.
    </para>
    <para>
Buradaki örneklerimizde hep zor olan yöntemleri kullanmak zorunda kaldığınızı varsayarak bu şekilde bir kurulum anlatılacaktır. Örneklerdeki işlem adımlarını kısaltmak sizin elinizdedir. Eğer Linux konusunda henüz yeterli birikime sahip değilseniz temel mantığı anlamak adına bir defa tamamen burada anlatıldığı gibi bir kurulum yapmanız yararınıza olabilir.
    </para>
    <note><title>Faydalı Belgeler</title>
    <para>
<ulink url="http://www.linuxfromscratch.org"/> veya <ulink url="http://lfs.geleceklinux.org"/> (Türkçe) adresinde kendi Linux dağıtımınızı oluşturmanız için yapmanız gereken adımlar anlatılmaktadır. Bu belge hem anlatılan yöntemler hem de geliştirilmek istenen hedef sistem açısından LFS'den çok farklı olmasına rağmen zaman ayırıp LFS belgesini de incelemeniz oldukça faydalı olacaktır.
    </para>
    </note>
    </sect1>
  </chapter>

  <chapter  id="embedded-onyukleme">
  <title>Sistemin Boot Edilmesi ve Diskin Hazırlanması</title>
  <para>
Bundan sonra "Sistem"den kastımız, geliştirmekte olduğumuz, SBC üzerinde çalışacak olan sistemdir. Gerekli donanım hazır durumdaysa, SBC'yi VGA çıkışına bir monitor bağlayarak geliştirmeye başlayabiliriz. İlk olarak yapmamız gereken SBC üzerindeki diski bölümlendirmek olacaktır. Bunun için çalışan bir Linux sistemine ihtiyaç olduğundan dolayı sistemi herhangi bir dağıtımın kurulum için kullandığı açılış disketleriyle veya varsa kurulum CD'si ile açmalıyız. Ardından bellekte oluşan geçici Linux sisteminde yer alan uygulamalar ile diskimizi bölümlendirebilir ve biçimlendirebiliriz.
  </para>
  <sect1 id="embedded-onyukleme-floppy"><title>Disketten Açılış</title>
  <para>
Eğer SBC sisteminize bir CD-ROM sürücü bağlı ise bu adımı atlayabilirsiniz. Ancak düşük kapasiteli SBC'ler genelde CD-ROM desteği ile gelmezler ya da CD-ROM bağlayabilmek için gerekli olanağı size sunmazlar. Bu durumda yapmanız gereken Linux açılış disketleri oluşturarak sisteminizi açmak olacaktır.
  </para>
  <para>
Örnek olarak Debian GNU/Linux dağıtımının kurulum için kullandığı açılış disketlerinin bir kopyasını aşağıdaki adreslerden bilgisayarınıza indirip diskete yazabilirsiniz.
  </para><itemizedlist>
  <listitem>
<ulink url="http://ftp.debian.org/debian/dists/woody/main/disks-i386/3.0.23-2002-05-21/images-1.44/rescue.bin"/>
  </listitem><listitem>
<ulink url="http://ftp.debian.org/debian/dists/woody/main/disks-i386/3.0.23-2002-05-21/images-1.44/root.bin"/>
  </listitem></itemizedlist><para>
Dosyaları bilgisayarınıza indirdikten sonra bilgisayarınıza boş bir disket takıp aşağıdaki komutla indirmiş olduğunuz disket görüntüsünü diskete doğrudan yazabilirsiniz:
  </para><para>
<screen>
<userinput>dd if=rescue.bin of=/dev/fd0</userinput>
<userinput>dd if=root.bin of=/dev/fd0</userinput>
</screen>
  </para><para>
Disketler hazırlandıktan sonra SBC <emphasis>rescue</emphasis> ve <emphasis>root</emphasis> disketleri sırasıyla takılıp sistem açılmalıdır. Açılış işlemi sonrasında, yukarıdaki adreste yer alan disketleri kullandı iseniz Debian GNU/Linux kurulum programı açılacaktır. Bu esnada <userinput>Alt - F2</userinput> tuşlarına basarak 2. konsol ekranına geçebilirsiniz. Burada temel Linux uygulamalarını kullanabilirsiniz.
  </para>
  </sect1>

  <sect1 id="embedded-bolumleme"><title>Diskin Hazırlanması</title>
  <para>
Sistem boot edildikten sonra diskimizi istediğimiz gibi bölümlendirebilir ve bölümleri istediğimiz dosya sistemine göre biçimlendirebiliriz. Burada kullanılan disk teknolojisi nedeniyle sistemde bazı kısıtlamalara gitmemiz gerekebilir. Flash disk teknolojilerine kısaca değinelim.
  </para>
  <para>
Flash bellek tabanlı diskler gömülü sistemler için düşük fiyatına karşın sağladığı olanaklar sayesinde her geçen gün daha fazla kullanılır olmuştur. Flash bellekler elektrik ile silinebilir ve tekrar yazılabilirler (Electrically Erasable Read Only Memory, EEPROM). Kendi içerisinde farklı tipleri olsa da günümüzde yaygın olarak NOR Flash bellekler kullanılmaktadır. NOR Flash bellekler 128 kB büyüklüğündeki bloklar halinde üretilir. Dolayısıyla bu tip belleklerde en küçük elemanın aslında 128 kB olduğunu söyleyebiliriz. Diskten 1 bayt dahi silmek isteseniz, bu işlem silmek istediğiniz baytın bulunduğu 128 kB'lık blokun tamamen silinmesini gerektirir. Flash belleklerin ömrünü de işte bu yazma işlemlerin sayısı belirler. Tipik bir flash bellek ömrü blok başına ortalama 100.000 yazma işlemini  gerçekleştirebilecek kadardır. İlk başta 100.000 ulaşılması zor bir rakam gibi gözükebilir, ancak 1 bayt için dahi bloklar halinde bu işlemin gerçekleştirileceği hesaba katılacak olunursa aslında bu değere hiç de uzun olmayacak bir zaman diliminde erişilmesi olasılığının bulunduğu anlaşılacaktır.
  </para>
  <para>
Kısıtlamaların aşılabilmesi için sürekli yeni yöntemler geliştirilmeye çalışılmaktadır. Örneğin  "wear levelling" adı verilen bir teknik ile herhangi bir blokun diskteki diğer bloklardan çok daha önce bu 100.000 değerine ulaşması önlenebilmektedir. Bu sayede diskte yoğun olarak kullanılan bir blok yüzünden kısa zamanda diskin tamamının kullanılamaz hale gelmesinin önüne geçilebilmektedir.
  </para><figure><title>Disk On Module</title>
  <mediaobject><imageobject>
      <imagedata fileref="dom.jpg" format="JPEG"/>
  </imageobject><textobject><phrase>Disk On Module</phrase></textobject></mediaobject>
  </figure><para>
Yazma ömrü konusundaki kısıtlamalar nedeniyle Flash bellek teknolojilerini kullanan diskler üzerinde takas alanı kullanımından kesinlikle kaçınılmalıdır. Gömülü sistemler zaten önceden belirlenmiş amaçlara hizmet edeceklerinden, bellek kullanımı belirli değerler arasında sabit kalacaktır. Dolayısıyla sistem iyi tasarlandığı müddetçe takas alanı kullanımına zaten ihtiyaç olmayacaktır.
  </para>
  <para>
Gerçekleştirilecek sistemde eğer yazma işlemleri sayıca yüksek olacaksa bu durumda salt-okunur bir sistem tasarlanması mantıklı olabilir. Sistem açılışında belleğin bir bölümünün disk bölümü olarak kullanılması, gerçek diskin ise tamamen salt-okunur kipe geçirilmesiyle yazma ömrü ciddi oranda artırılabilir. Ancak bu durumda veri kayıplarını engellemek için ramdisk üzerindeki bilgilerin güvenliğini sağlayıcı önlemler getirilmelidir (Belirli aralıklarla disk üzerindeki sistemi salt-okunur kipten çıkarıp veriler ramdisk'den diske yazıldıktan sonra tekrar salt-okunur kipe geçirmek gibi).
  </para>
  <para>
Disk üzerinde kullanılacak dosya sisteminin seçimi de oldukça önemlidir. Çoğu gömülü sistem için ext2 kadar karmaşık bir dosya sistemine ihtiyaç duyulmayacaktır. İhtiyaç olmadığı halde ext2 dosya sistemi kullanıldığı takdirde gereksiz yere dosya sistemi tarafından bir yük oluşturulacaktır. İleride dosya sistemleri konusuna ayrıntılı olarak değineceğiz. Biz geliştireceğimiz gömülü sistem için <command>minix</command> dosya sistemini kullanalım. Minix dosya sisteminde bir disk bölümü maksimum 64 MB, dosya adları maksimum 31 karakter olabilir. Kullanılacak dosya sistemi seçilmeden önce bu gibi özelliklerinin araştırılıp, geliştirilecek olan sistemin yapısını etkileyip etkilemeyeceği önceden belirlenmelidir.
  </para>
  <para>
Son olarak SBC sistemimizi disketler ile açmış ve <userinput>Alt - F2</userinput> tuşları ile 2. sanal konsola geçiş yapmıştık. Diskimizin Linux çekirdeği tarafından nasıl tanındığını öğrenelim:
  </para><para>
<screen>
<prompt># </prompt><userinput>dmesg | grep -i disk</userinput>
RAM disk driver initialized:  16 RAM disks of 16384K size
hda:  64MB ATA Flash Disk, ATA DISK drive
...
</screen>
  </para><para>
Diskimizin <filename>/dev/hda </filename>olarak Linux tarafından tanındığını gördük. Şimdi <userinput>fdisk </userinput>programı ile diski bölümlendirelim.
  </para><para>
<screen>
<prompt># </prompt><userinput>fdisk /dev/hda</userinput>

Command (m for help): <userinput>n</userinput>
Command action
     e    extended
     p    primary partition (1-4)
<userinput>p</userinput>
Partition number (1-4): <userinput>1</userinput>
First cylinder (1-489, default 1): <userinput>1</userinput>
Last cylinder or +size or +sizeM or +sizeK (1-489, default 489): <userinput>489</userinput>

Command (m for help): <userinput>a</userinput>
Partition number (1-4): <userinput>1</userinput>

Command (m for help): <userinput>w</userinput>
The partition table has been altered!

Calling ioctl() to re-read partition table.
Syncing disks.
<prompt># </prompt>
</screen>
  </para><para>
Yukarıda örnekte görüldüğü gibi disk üzerinde 64 MB'lık bir Linux disk bölümü yarattık. Debian açılış disketlerinde (ve büyük olasılıkla diğer dağıtımların kullandığı disketlerde de) minix dosya sistemi yaratmak için gereken <userinput>mkfs.minix </userinput> programı bulunmamaktadır. Dolayısıyla bu programı çalışan bir Linux sisteminden disket ile SBC üzerine taşımalıyız. Bunun için bir Linux bilgisayardan gerekli dosya diskete kopyalanır. Ardından disket SBC'ye bağlı disket sürücüye takılır (Açılış tamamlandıktan sonra, açılış için kullanılan disketlerin sürücüde kalmasına gerek yoktur). Disketi SBC'ye taktıktan sonra,
  </para><para>
<screen>
<prompt># </prompt><userinput>mount /dev/fd0 /floppy</userinput>
<prompt># </prompt><userinput>ls /floppy</userinput>
mkfs~1.min
<prompt># </prompt>
</screen>
  </para><para>
Dosyayı taşımak için kullandığım disket üzerindeki dosya sistemi <literal>vfat </literal> idi. Ancak SBC'nin açılışında kullandığım  sistemde <literal>vfat </literal> desteği yok, bu nedenle disket <literal>msdos </literal> dosya sistemi ile bağlandı. <userinput>ls </userinput> komutunun çıktısında görülen <computeroutput>mkfs~1.min</computeroutput> bundan kaynaklanmaktadır. Şimdi dosyayı disketten <filename>/tmp </filename> dizini altına olması gerektiği ad ile kopyalayıp disketi çıkartalım:
  </para><para>
<screen>
<prompt># </prompt><userinput>cp /floppy/mkfs~1.min /tmp/mkfs.minix</userinput>
<prompt># </prompt><userinput>umount /floppy</userinput>
<prompt># </prompt>
</screen>
  </para><para>
Şimdi artık <userinput>mkfs.minix </userinput> ile hazırlamış olduğumuz disk bölümü üzerinde <literal>minix </literal> dosya sistemi oluşturabiliriz:
  </para><para>
<screen>
<prompt># </prompt><userinput>/tmp/mkfs.minix /dev/hda1</userinput>
20864 inodes
62576 blocks
Firstdatazone=665 (665)
Zonesize=1024
Maxsize=268966912

<prompt># </prompt>
</screen>
  </para><para>
Şimdi dosya sistemi de oluştuğuna göre diski bağlayabiliriz. Bunun için <filename>/hedef </filename> ismiyle bir dizin açıp disk bölümünü bu dizine bağladıktan sonra, geliştirmelerimizi burada yapalım.
  </para><para>
<screen>
<prompt># </prompt><userinput>mkdir /hedef</userinput>
<prompt># </prompt><userinput>mount /dev/hda1 /hedef</userinput>
<prompt># </prompt><userinput>mount</userinput>
/dev/ram0 on / type ext2 (rw)
/proc on /proc type proc (rw)
/dev/hda1 on /hedef type minix (rw)
<prompt># </prompt>
</screen>
  </para><para>
Artık diskimiz üzerindeki bölüm ve dosya sistemi <filename>/hedef </filename> dizini altında kullanımımız için hazır bulunuyor.
  </para>
  </sect1>
  </chapter>

  <chapter  id="embedded-ayarlamalar">
  <title>Temel Ayarlamalar</title>
  <para>
Her Linux sisteminde mutlaka bulunması gereken bazı dizinler vardır (<filename>/etc</filename>, <filename>/sbin </filename> vb.) ve bu dizin yapılarının oluşturulması gereklidir. Aynı şekilde bazı dizinlerin erişim hakları diğerlerinden farklılık gösterebilir (<filename>/tmp</filename> gibi), bazı dizinlerin başka yerlere sembolik olarak bağlanması gerekebilir. Sistemin çalışabilmesi için <filename>/etc</filename> dizini altında birtakım ayarlamaların yapılması  gereklidir.
  </para>

  <sect1 id="embedded-dizinler"><title>Dizinlerin Oluşturulması</title>
  <para>
Aşağıdaki komutla temel dizinleri oluşturabiliriz. Unutulan bir dizin olursa herhangi bir anda oluşturulabilir.
  </para><para>
<screen>
<prompt># </prompt><userinput>cd /hedef</userinput>
<prompt># </prompt><userinput>mkdir -p bin boot etc floppy home root lib proc sbin tmp usr var</userinput> \
<userinput>usr/bin usr/lib usr/sbin var/lib var/lock var/log var/run var/tmp</userinput>
<prompt># </prompt>
</screen>
  </para>
  </sect1>

  <sect1 id="embedded-dizine_erisim">
  <title>Dizinlere Erişimlerin Düzenlenmesi</title>
  <para>
Linux sistemlerde <filename>/tmp</filename> dizini geçici işler için sistemdeki tüm kullanıcılar tarafından kullanabilir. Geliştirmekte olduğunuz sisteme sadece bir kişi giriş yapacak olacak olsa dahi bu ayarlamalar yapılmalıdır. Çünkü sisteminizdeki bazı servisler kendilerine özel kullanıcı haklarıyla çalışacak ve <filename>/tmp</filename> dizini altına yazılabilir olduğunu varsayacaklardır. Bu nedenle <filename>/tmp</filename> dizini mutlaka kullanıcılar tarafından yazılabilir bir alan olmalı ve yapışkan biti ile verilmelidir.
  </para><para>
<screen>
<prompt># </prompt><userinput>chmod -R 1777 tmp</userinput>
<prompt># </prompt><userinput>ls -lad tmp</userinput>
drwxrwxrwt      2 root  root            64 May 25 19:53 tmp
<prompt># </prompt>
</screen>
  </para><para>
Geliştirdiğimiz sistem için çok gerekli olmamakla birlikte <filename>/root</filename> dizinine sadece <literal>root</literal> kullanıcısınıngirebilmesi için erişim hakkını düzenleyelim:
  </para><para>
<screen>
<prompt># </prompt><userinput>chmod 700 root</userinput>
<prompt># </prompt>
</screen>
  </para>
  </sect1>

  <sect1 id="embedded-aygitlar">
  <title>/dev Dizini Altındaki Aygıtların Oluşturulması</title>
  <para>
Linux sistemlerde aygıtlara erişmek için kullanılan özel dosyalar <filename>/dev</filename> dizini altında bulunur. Gömülü bir sistemde kullanılabilecek olan aygıtlar bellidir ve çok ender olarak değişir. Çok geçerli bir neden olmadıkça gömülü sistemlerde SCSI aygıtlar kullanmazsınız veya sisteminize yüzlerce kişi sisteme giriş yapmaz.Bu nedenle normal bir Linux sistemindeki <filename>/dev</filename> dizini altında yer alan aygıt dosyalarının çoğu bizim için geçerli değildir. Burada önerebileceğim yol, Linux'a hakimseniz, sadece kullanacak olduğunuz aygıtlarla ilgili dosyaları <userinput>mknod</userinput> ile ana ve alt düğüm numaraları, karakter veya blok veri transferi özelliklerine göre oluşturmanızdır. Ancak bu yol epey zahmetli olacağından hazır bir <filename>/dev</filename> dizininden yararlanmak da mantıklı olabilir. Sistemimizi açtığımız disketler de bellekte küçük bir Linux sistemi oluşturduğundan buradaki <filename>/dev</filename> dizinini aynen kopyalayabiliriz:
  </para><para>
<screen>
<prompt># </prompt><userinput>cp -a /dev .</userinput>
<prompt># </prompt>
</screen>
  </para><para>
Varolan bir sistemdeki <filename>/dev</filename> dizini kopyalandıktan sonra gereksiz gördüğünüz aygıt dosyalarını sonradan da silebilirsiniz.
  </para>
  </sect1>

  <sect1 id="embedded-kitapliklar">
  <title>Gerekli Kütüphanelerin Taşınması</title>
  <para>
Geliştirdiğimiz Linux sistemimizde kullanacak olduğumuz uygulamalara göre gerekli kütüphanelerin sisteme kurulması gereklidir. Bunun için çalışan bir Linux sistemden ilgili dosyalar, uygun yerlere kopyalanmalıdır. Dosyaları taşıyabilmek için bu aşamada tek çözüm disket kullanmak olacaktır.
  </para>
  <para>
Aşağıdaki temel paylaşımlı kütüphaneler hemen her sistem için gerekli olduğundan, bunları çalışan Linux sisteminizin <filename>/lib</filename> dizininden bir disket üzerine kopyalamalısınız:
  </para><para>
  <itemizedlist>
  <listitem>libc.so.6</listitem>
  <listitem>ld-linux.so.2</listitem>
  <listitem>libdl.so.2</listitem>
  <listitem>libnsl.so.1</listitem>
  <listitem>libm.so.6</listitem>
  <listitem>libcrypt.so.1</listitem>
  </itemizedlist>
  </para><para>
Daha sonra disketi SBC üzerine takıp <userinput>mount /dev/fd0 /floppy</userinput> komutu ile sisteme bağlayın. Disketin üzerindeki dosya sistemi FAT ise dosyalarda 8.3 karakter problemi yaşayabilirsiniz. Bu durumda dosyaları yeniden adlandırmakla uğraşmak istemiyorsanız <userinput>mkfs.minix /dev/fd0</userinput> veya <userinput>mkfs.ext2 /dev/fd0</userinput> komutuyla çalışan Linux sisteminizde disketi biçimlendirip dosya taşıma işlemini yeniden yapınız. Tüm bu adımları geçtiğinizi varsayarsak disket SBC'ye takılı ve bağlı durumda iken
  </para><para>
<screen>
<prompt># </prompt><userinput>cp /floppy/* /hedef/lib</userinput>
</screen>
  </para><para>
komutuyla dosyaları olması gereken yere kopyalayın.
  </para>
  <para>
Normalde kütüphane dosyaları doğrudan çalıştırılmadığı için erişim kipinin sadece okumaya izin vermesi yeterlidir. Ancak <filename>libc.so.6</filename> ve ve <filename>ld-linux.so.2</filename> kütüphanelerine çalıştırılabilir dosya erişimi de vermeniz gereklidir:
  </para><para>
<screen>
<prompt># </prompt><userinput>chmod 755 /hedef/lib/libc.so.6</userinput>
<prompt># </prompt><userinput>chmod 755 /hedef/lib/ld-linux.so.2</userinput>
</screen>
  </para><para>
Artık sistemimiz için gerekli olan temel kütüphaneler hazır. Şimdi gene çok gerekli olan uygulamaları kuralım ama nasıl?
  </para>
  </sect1>

  <sect1 id="embedded-busybox">
  <title>Busybox Kullanımı</title>
  <para>
Busybox projesi Debian GNU/Linux dağıtımı kurulum programının çalışabilmesi için oluşturulan 2 disketlik Linux sisteminde kullanılmak üzere geliştirilmiştir. Burada amaç, kurulum için gerekli ufak fakat çok sık kullanılan uygulamaları (<userinput>cp</userinput>, <userinput>mv</userinput>, <userinput>tar</userinput>, <userinput>ls</userinput>, <userinput>sh</userinput>, <userinput>find</userinput>, <userinput>init</userinput> vb.) yeniden yazarak tek bir uygulama üretmek ve böylece yerden kazanmaktı. Busybox bu yer kazancını, uygulamaların sık kullanılmayan özelliklerini desteklemeyen sürümlerinin yeniden yazılmasıyla gerçekleştiriyordu. Örnek olarak <userinput>find</userinput> komutu normalde onlarca parametre ile çalıştırılabilirken Busybox içerisinden çıkan <userinput>find</userinput>, sadece en sık kullanılan beş parametresini desteklemektedir. Bu koşul gözönünde bulundurularak en temel uygulamalar yeniden yazılmış ve sonuçta 300-400 kB büyüklüğündeki bir dosya ile, her biri ayrı ayrı kullanıldığında normalde 4-5 MB toplam yer kaplayacak olan uygulamalar ile aynı işlevsellik büyük ölçüde sağlanabilmiştir.
  </para>
  <para>
Sistemimizde <userinput>busybox</userinput> kullanımı disk alanından kazanç sağlayacaktır. Busybox'ın bir diğer önemli özelliği modüler yapısı sayesinde istediğimiz parçaları ekleyip çıkarabilmemizdir. Busybox'ı derlemeden önce <filename>Config.h</filename> dosyasını bir metin düzenleyici ile istediğiniz gibi düzenleyebilirsiniz. Bu dosyanın biçimi aşağıdaki gibidir:
  </para><para>
<screen>
//#define BB_LOGNAME
//#define BB_LOSETUP
#define BB_LS
#define BB_LSMOD
//#define BB_MAKEDEVS
//#define BB_MD5SUM
#define BB_MKDIR
//#define BB_MKFIFO
//#define BB_MKFS_MINIX
#define BB_MKNOD
#define BB_MKSWAP
//#define BB_MKTEMP
</screen>
  </para><para>
Standart bir C başlık dosyası olan <filename>Config.h</filename> içerisinden istediğiniz özellikleri yukarıdaki örnekte olduğu gibi ekleyebilir ve çıkarabilirsiniz. Böylelikle sadece size gerekli olan bileşenleri içeren bir <userinput>busybox</userinput> derleyebilirsiniz.
  </para>
  <para>
<userinput>busybox</userinput> derlendikten sonra sistemde sadece <userinput>busybox</userinput> programının olması, <userinput>ls</userinput>, <userinput>cp</userinput> vb. gibi desteklenen uygulamaların ise <userinput>busybox</userinput>'a sembolik bağ olarak bağlı olması yeterlidir. <userinput>busybox</userinput> kendi başına çalıştırıldığında ise içerdiği uygulamaları listeler:
  </para><para>
<screen>
<prompt>laptop:/usr/src/busybox-0.60.5$ </prompt><userinput>./busybox</userinput>
BusyBox v0.60.5 (2003.04.22-14:09+0000) multi-call binary

Usage: busybox [function] [arguments]...
  or: [function] [arguments]...

      BusyBox is a multi-call binary that combines many common Unix
      utilities into a single executable.  Most people will create a
      link to busybox for each function they wish to use, and BusyBox
      will act like whatever it was invoked as.

Currently defined functions:
      [, ash, basename, busybox, cat, chgrp, chmod, chown, chroot, chvt,
      clear, cp, cut, date, dd, df, dirname, dmesg, du, echo, env, false,
      find, free, grep, gunzip, gzip, halt, head, id, init, kill, killall,
      klogd, linuxrc, ln, logger, ls, lsmod, mkdir, mknod, mkswap, modprobe,
      more, mount, mv, pidof, poweroff, ps, pwd, reboot, reset, rm,
      rmdir, sed, sh, sleep, sort, swapoff, swapon, sync, syslogd, tail,
      tar, test, touch, true, tty, umount, uname, uniq, uptime, wc,
      which, whoami, xargs, yes, zcat

</screen>
  </para><para>
<userinput>busybox</userinput> kaynak kodlarını <ulink url="http://www.busybox.net/downloads/"/> adresinden indirebilirsiniz. tar.gz arşivi indirip açtıktan sonra bu dizine geçip, <filename>Config.h</filename> dosyasını düzenlemelisiniz. Gene aynı dizindeki <filename>Makefile</filename> dosyasını inceleyerek programın derlenme aşamasındaki seçenekleri değiştirebilirsiniz. Bu adımları tamamladıktan sonra <userinput>make</userinput> ve <userinput>make install</userinput> komutlarıyla  programın derlenmesini ve kuruluma hazır hale gelmesini sağlıyoruz. <userinput>make</userinput> komutunun çalışması bittiğinde  elimizde bir <userinput>busybox</userinput> uygulaması oluyor. <userinput>make install</userinput> ise bulunduğunuz dizinde <filename>_install</filename> adında bir alt dizin açıyor ve <userinput>busybox</userinput> uygulamasını olması gereken sembolik bağlar ile birlikte buraya kopyalıyor:
  </para><para>
<screen>
<prompt>laptop:/usr/src/busybox-0.60.5$ </prompt><userinput>ls -l _install/usr/sbin</userinput>
total 0
lrwxrwxrwx   1 demirten demirten     17 May 30 00:05 chroot -> ../../bin/busybox
lrwxrwxrwx   1 demirten demirten     17 May 30 00:05 fbset -> ../../bin/busybox
</screen>
  </para><para>
Burada <filename>bin</filename>, <filename>sbin</filename>, <filename>usr/bin</filename> ve <filename>usr/sbin</filename> dizinleri oluşturulmuş, <filename>bin</filename> dizini altına <userinput>busybox</userinput>'ın kendisi atılmış, ilgili tüm sembolik bağlar oluşturulmuştur. Bu dizini <filename>tgz</filename> arşivi haline getirerek disketle SBC  üzerine taşıyıp orada açalım:
  </para><para>
<screen>
<prompt>laptop:/usr/src/busybox-0.60.5$ </prompt><userinput>cd _install</userinput>
<prompt>laptop:/usr/src/busybox-0.60.5/_install$ </prompt><userinput>tar cvfz /tmp/busy-bin.tgz .</userinput>
...
</screen>
  </para><para>
Oluşan <filename>busy-bin.tgz</filename> arşivinin boyu 180 kB gibi çok küçük bir değer olduğu için disket ile SBC üzerine rahatlıkla taşınabilir. Daha önceden yaptığımız gibi disketi sisteme bağlayıp <filename>busy-bin.tgz</filename> dosyasını kopyalıyoruz. Ardından bu disketi SBC sistemine takıp bağladıktan sonra aşağıdaki komutlarla arşivi açıyoruz:
  </para><para>
<screen>
<prompt># </prompt><userinput>cd /hedef</userinput>
<prompt># </prompt><userinput>cp /floppy/busy-bin.tgz .</userinput>
<prompt># </prompt><userinput>tar zxvf busy-bin.tgz</userinput>
...
</screen>
  </para><para>
Artık SBC sistemimiz üzerinde onlarca kullanıma hazır temel uygulama var.
  </para>
  </sect1>
  <sect1 id="embedded-tinylogin"><title>Tinylogin Kullanımı</title>
  <para>
<userinput>busybox</userinput> kurulumu sonrasında ihtiyaç duyduğumuz temel uygulamaların neredeyse tamamı SBC sistemimize yüklenmiş oldu. Ancak <userinput>busybox</userinput> içerisinden sisteme girişler, erişim denetimi, kullanıcılar üzerinde işlemler vb. yapabilecek uygulamalar mevcut değildir. Bu uygulamalar <userinput>busybox</userinput> projesinin tamamlayıcısı niteliğinde olan <userinput>tinylogin</userinput> içerisinden çıkmaktadır. <userinput>busybox</userinput> için söylediklerimizin hepsi <userinput>tinylogin</userinput> için de geçerlidir ve aradaki tek fark, her iki uygulamanın içerdiği işlevlerdedir. Yakın bir gelecekte <userinput>tinylogin</userinput>'in tamamen <userinput>busybox</userinput> içerisine dahil edildiğini görürseniz şaşırmayın.
  </para>
  <para>
<userinput>tinylogin</userinput> uygulamasını hazırlamak için önce <ulink url="http://www.busybox.net/downloads/"/> adresinden kaynak kod arşivini indiriyoruz. Arşivi açtıktan sonra gene <userinput>busybox</userinput>'ta olduğu gibi <userinput>tinylogin</userinput> içerisine dahil etmek istediğimiz özellikleri belirleyebiliyoruz:
  </para><para>
<screen>
#define CONFIG_PASSWD
//#define CONFIG_SU
// Enable using shadow passwords
//#define CONFIG_FEATURE_SHADOWPASSWDS
// Enable using sha passwords
//#define CONFIG_FEATURE_SHA1_PASSWORDS
</screen>
  </para><para>
Burada istediğiniz özellikleri seçtikten sonra dosyayı kaydedin <userinput>make &amp;&amp; make install</userinput> komutunu verin. <userinput>busybox</userinput>'da olduğu gibi gene <filename>_install</filename> adında bir alt dizin oluşacak, burada <userinput>tinylogin</userinput> uygulaması ve olması gereken sembolik bağlar oluşturulacaktır. Bu dizin yapısını SBC üzerine taşımak için izlediğimiz yol öncekiyle aynıdır:
  </para><para>
<screen>
<prompt>laptop:/usr/src/tinylogin-1.4$ </prompt><userinput>cd _install</userinput>
<prompt>laptop:/usr/src/tinylogin-1.4$ </prompt><userinput>tar cvfz /tmp/tiny-bin.tgz .</userinput>
...
</screen>
  </para><para>
Ardından oluşan <filename>tiny-bin.tgz</filename> dosyasını disket ile SBC sistemi üzerine taşıyıp disketi bağladıktan sonra:
  </para><para>
<screen>
<prompt># </prompt><userinput>cd /hedef</userinput>
<prompt># </prompt><userinput>cp /floppy/tiny-bin.tgz .</userinput>
<prompt># </prompt><userinput>tar zxvf tiny-bin.tgz</userinput>
...
</screen>
  </para><para>
Artık sistemimize <userinput>tinylogin</userinput> uygulaması kurulmuş oldu. Derlediğimiz <userinput>tinylogin</userinput> içerisinden nelere destek verildiğini görelim:
  </para><para>
<screen>
<prompt># </prompt><userinput>/hedef/bin/tinylogin</userinput>
Tinylogin v1.4 (2003.05.29-21:22+0000) multi-call binary

Usage: tinylogin [function] [arguments]...
  or: [function] [arguments]...

      TinyLogin is a multi-call binary that combines several tiny Unix
      utilities for handling logins, user authentication, changing passwords,
      and otherwise maintaining users and groups on an embedded system.  Most
      people will create a link to TinyLogin for each function they wish to
      use, and TinyLogin will act like whatever it was invoked as.

Currently defined functions:
      addgroup, adduser, delgroup, deluser, getty, passwd, tinylogin,
      vlock
</screen>
  </para><para>
<userinput>busybox</userinput> ve <userinput>tinylogin</userinput> kurulumu tamamlandığında elimizde çalışabilir bir sistem olmaktadır. Şimdi yapmamız gereken bu sistemin kendi başına açılabilmesini sağlamak amacıyla gerekli düzenlemelerdir.
  </para>
  </sect1>
  <sect1 id="embedded-init">
  <title>Açılış Ayarları</title>
  <para>
Sistemi SBC üzerindeki sistemden başlatabilmek için yapmamız gereken bir takım ayarlamalar mevcut. Bunlar, SBC'ye özgün bir çekirdek oluşturma, açılışta <userinput>init</userinput> tarafından çalıştırılacak ilk programı hazırlama, sisteme girişleri düzenleme ve çekirdeği yükleyebilmek için bir önyükleyici ayarlamak olacaktır.
  </para>
  <sect2><title>Çekirdeğin Oluşturulması</title>
  <para>
Sistemimizi disketlerin yardımı olmadan açabilmek için öncelikle sistemi düzgün bir şekilde başlatabilecek, istediğimiz özelliklere sahip bir çekirdeğin olması gereklidir. SBC sistemi üzerinde çalışacak olan Linux çekirdeğini derlemek için bir Linux makine kullanacağız. Derleme işlemini yapacağınız zamandaki kararlı son sürüm Linux çekirdeğini <ulink url="http://www.kernel.org"/> adresinden indirip, SBC üzerindeki donanımlar ve SBC üzerinde kullanmak istediğiniz yapılar için gerekli olan çekirdek desteklerine sahip olacak  şekilde bir derleme yapmalısınız. Linux çekirdeğinin derlenmesi hakkında örneğin <link linkend="kernel-nasil">Çekirdeğe Yama Uygulanması ve Çekirdeğin Derlenmesi NASIL</link> belgesinden yararlanabilirsiniz.
  </para>
  <para>
Bu aşamada SBC üzerinde çalışacak olan Linux çekirdeğini derlediğinizi ve bir disket yardımı ile SBC üzerindeki <filename>/hedef/boot</filename> dizini altına <filename>linux</filename> adıyla kopyaladığınızı varsayıyoruz.
  </para><note><para>
Çekirdeğin derlenmesi sırasında en sık yapılan hata, SBC sisteminizde kullandığınızdan farklı bir işlemci ailesinin seçilmesi ve bu yüzden sistemin yüklenememesidir. SBC üzerindeki işlemciler aynı hızlardaki ağabeylerinin birebir aynısı değillerdir. 133 MHz hızındaki bir işlemci için 486 kipinde çekirdek derlemeniz gerekebilir, 586 ve üstü çalışmayabilir. Böyle bir durumla karşılaşırsanız çekirdeği yeniden derleyip, SBC'yi daha önce kullandığımız iki disket ile açıp kök bölümünü gene <filename>/hedef</filename> dizini altına bağladıktan sonra, yeni çekirdeği disket ile <filename>/hedef/boot </filename> dizini altına taşımalı ve ardından burada anlatılan <userinput>lilo</userinput> ayarlamalarının ilgili kısımlarını yeniden yapmalısınız.
  </para></note>
  <warning><para>
Buradaki <filename>/hedef</filename> dizini, SBC'yi açarken kullandığımız iki disketin bellekte oluşturduğu geçici Linux sistemi altında yer almaktadır. DiskOnModule üzerinde <filename>/hedef</filename> adında bir dizin yoktur.
  </para></warning>
  </sect2>

  <sect2><title>Init Ayarları</title>
  <para>
Linux çekirdeği bir önyükleyici programı tarafından açılış esnasında belleğe yüklenip çalışmaya başlar. Çekirdek donanımları tarar, sisteme yerleşir ve tüm yapması gereken işlemleri bitirdiğinde artık sistemi bize devretmek ister. İşte bu noktada çekirdeğin yaptığı iş <userinput>/sbin/init</userinput> programını çalıştırmaktır.
  </para>
  <para>
Çekirdek tarafından ilk olarak çalıştırılan <userinput>init</userinput> programının bu nedenle süreç numarası (PID) daima 1'dir. Geri kalan tüm süreçler için <userinput>init</userinput> ana süreç (parent) konumundadır.
  </para>
  <para>
Peki <userinput>init</userinput> neler yapar ve biz nerede devreye gireceğiz? <userinput>init</userinput> programı, çalıştığında öncelikle <filename>/etc/inittab</filename> ayar dosyasını okur. Buradan aldığı verilerle sisteminhangi çalışma seviyesinde (runlevel) açılacağına karar verir ve ilgili programı çalıştırır. Ayrıca sanal konsollardan sisteme girişleri sağlayabilmek için <userinput>getty</userinput> programını bu konsollarla ilişkilendirir.
  </para>
  <para>
<userinput>init</userinput> ile ilgili dikkat etmemiz gereken nokta, <userinput>busyBox</userinput> içerisinden çıkan yeniden yazılmış <userinput>init</userinput> sürümünün çalışma seviyelerini (runlevels) desteklemediğidir. Bu nedenle normal Linux bilgisayarınızdaki <filename>/etc/inittab</filename> dosyasını örnek olarak kullanamazsınız. Bunun yerine <userinput>busyBox</userinput> içersindeki <userinput>init</userinput>'in kullandığı dosya biçimini kullanmalısınız.
  </para><note><para>
Çoğu durumda gerekli olmamakla birlikte herhangi bir nedenden ötürü çalışma seviyelerine ihtiyaç duyan bir sistem geliştiriyorsanız <userinput>busyBox</userinput> ile gelen <userinput>init</userinput>'i değil, <userinput>sysvinit</userinput>'i kullanmalısınız.
  </para></note>
  <note>
<para>Eğer bir <filename>inittab</filename> dosyası ayarlamaz iseniz <userinput>busyBox</userinput> aşağıdaki gibi bir <filename>inittab</filename> içeriğini girmiş olduğunuzu varsayarak, bu içeriğe göre çalışır:
  </para><para>
<screen>
::sysinit:/etc/init.d/rcS
::askfirst:/bin/sh
::ctrlaltdel:/sbin/reboot
::shutdown:/sbin/swapoff -a
::shutdown:/bin/umount -a -r
::restart:/sbin/init
</screen>
  </para><para>
Ayrıca <filename>/dev/console</filename> aygıtının erişilebilir olduğunu görürse aşağıdaki satırları da ekleyecektir:
  </para><para>
<screen>
tty2::askfirst:/bin/sh
tty3::askfirst:/bin/sh
tty4::askfirst:/bin/sh
</screen>
  </para>
  </note><para>
Şimdi örnek bir <filename>inittab</filename> dosyası hazırlayalım. İlk iki konsoldan doğrudan sisteme giriş yapılabilsin, üçüncü konsoldan ise <filename>/etc/passwd</filename> dosyasından kimlik doğrulama yapılarak sisteme girilebilsin. Bunun için aşağıdaki gibi bir <filename>inittab</filename> dosyasını <userinput>vi /hedef/etc/inittab</userinput> komutu ile oluşturalım:
  </para><example>
  <title><filename>/etc/inittab</filename> içeriği</title>
<screen>
::sysinit:/etc/init.d/rcS
::askfirst:/bin/sh
::ctrlaltdel:/sbin/reboot
::shutdown:/bin/umount -a -r
::restart:/sbin/init

#tty1::askfirst:/bin/sh
tty2::askfirst:/bin/sh
tty3::respawn:/sbin/getty 38400 tty3
</screen>
  </example><para>
Dosyayı bu şekilde oluşturup kaydettikten sonra şimdi dosyadaki satırları açıklayalım. İlk satırda <userinput>init</userinput> programının sistemin açılışı işlemini devredeceği program belirtilmektedir. İşte burası bizim sistem açılışında doğrudan müdahale etmemiz gereken yerdir. Örneğimizde bu değer <filename>/etc/init.d/rcS</filename>'dir. <userinput>init</userinput> kendi işini bitirince bu programı çalıştıracaktır. Bu programı birazdan  hazırlayacağız.
  </para><para>
İkinci satırda <literal>askfirst</literal> özel belirteci <filename>/bin/sh</filename> ile ilişkilendirilmiştir. <literal>askfirst</literal> ile ilişkilendirilmiş bir sanal konsola geçildiğinde &lt;ENTER> tuşuna basmak suretiyle kabuğa düşülür (<userinput>/bin/sh</userinput>). Birinci konsol <filename>tty1</filename> için <literal>askfirst</literal> elemanı öntanımlı olarak ayarlandığı için dosyanın 7. satırındaki ayar, önüne <literal>#</literal> getirilerek iptal edilmiştir. Etkinleştirseniz de bir problem olmaz, sadece birinci konsolda 2 defa giriş mesajını alırsınız:
  </para><para>
<screen>
Please press Enter to activate this console.
Please press Enter to activate this console.
</screen>
  </para><para>
3, 4 ve 5. satırda yapılan işlemler isimlerinden de anlaşılacağı üzere sistemdeki belirli olaylar karşısında çalıştırılacak olan uygulamaların seçilmesini sağlamaktadır. 8. satırda 2. sanal konsol da <literal>askfirst</literal> ile ilişkilendirilmekte, 9. satırda ise 3. sanal konsol <userinput>getty</userinput> programıyla ilişkilendirilmekte ve <emphasis>respawn</emphasis> yapılarak süreç öldüğü zaman <userinput>getty</userinput>'nin yeniden çalıştırılması gerektiği belirtilmektedir.
  </para><para>
Şimdi <filename>/etc/init.d/rcS</filename> dosyamızı oluşturalım. Basit bir kabuk programı ile açılışta yapılmasını istediğimiz işlemleri burada gerçekleştireceğiz. Öncelikle sistemde <filename>init.d</filename> dizinini oluşturalım.
  </para><para>
<screen>
<prompt># </prompt><userinput>mkdir /hedef/etc/init.d</userinput>
</screen>
  </para><para>
Ardından <userinput>vi /hedef/etc/init.d/rcS</userinput> komutu ile dosyamızı yazmaya başlayalım. Bu dosyada neler yapmamız gerekiyor? <filename>rcS</filename> içerisinde teorik olarak sistemin açılırken yapmasını istediğimiz her türlü işlemi kendi keyfimize göre yaptırabiliriz (Linux'te bir işi yapmanın her zaman birden fazla yolu olduğuna göre keyif burada doğru bir tanımlama :). Ancak bu keyfi işlem adımlarının yanında bir de bazı özel durumlar haricinde yapmamız gereken bir işlem var: kök dosya sistemini oku-yaz kipinde yazılabilir olarak sisteme bağlamak. Linux çekirdeği sistemi açarken ve <userinput>init</userinput> programını çalıştırdığında kök dosya sistemi salt-okunur olarak sisteme bağlı durumdadır (Elbette bunu da değiştirmenin yolları var ille de ben bildiğimi yaparım diyorsanız). Bu yüzden <filename>rcS</filename> içerisinde kök dosya sistemi oku-yaz kipine geçirilmelidir. Ayrıca <filename>/proc</filename> sanal dosya sistemi de burada sisteme bağlanmalıdır. Bu işlemleri yapan dosya içeriği aşağıdaki gibi olup şu aşamada sistemin açılabilmesi için bize yeterlidir. İleride açılışta yapılacak yeni işlemler eklendiğinde (ağ ayarlarının yapılması gibi) bu dosyanın içeriğinde değişiklikler yapacağız.
  </para><example><title><filename>/etc/init.d/rcS</filename></title>
<screen>
#!/bin/sh

## Sistemi read-write moduna geçirelim
mount -n -o remount,rw /

## Proc'u bağlayalım
mount /proc
</screen>
  </example><para>
Bu dosya mutlaka çalıştırılabilir olmalıdır, <userinput>chmod 755 /hedef/etc/init.d/rcS</userinput> komutuyla dosyaya çalıştırma hakları verilmelidir.
  </para><para>
<filename>rcS</filename> içerisinde <userinput>mount</userinput> komutunu kullanma şeklimize bakacak olursanız dosya sistemi türü, aygıt ismi gibi ayrıntıların verilmediğini görmektesiniz. Bu da doğru ayarlanmış bir <filename>/etc/fstab</filename> dosyası sayesinde olabilmektedir. Şimdi bu dosyayı da gene <userinput>vi /hedef/etc/fstab</userinput> komutu ile aşağıdaki gibi oluşturalım:
  </para><example>
  <title><filename>/etc/fstab</filename></title>
<screen>
# Device                Point   Type    Options         Dump    Pass
/dev/hda1               /       minix   defaults,rw     1       0
proc                    /proc   proc    defaults        0       0
</screen>
  </example><para>
Artık <filename>rcS</filename> dosyamız çalışmaya hazır. Şimdi tek yapmamız gereken önyükleyici programımızı ayarlamak ve sistemi yeniden başlatmak olacak.
  </para>
  </sect2>

  <sect2  id="embedded-lilo_ayar"><title>LILO Ayarları</title>
  <para>
Sistemimiz neredeyse kendi başına açılabilecek hale geldi. Şimdi çekirdeği yüklememizi sağlayacak bir önyükleyici kurmamız ve ayarlamamız gerekiyor. Ben burada önyükleyici olarak LILO kullandım, siz alternatif olarak aynı işlemleri GRUB ile de yapabilirsiniz.
  </para><para>
Öncelikle <userinput>lilo</userinput> uygulaması bir disket ile normal Linux bilgisayarınızdan SBC üzerine taşınmalıdır. Bazı sistemlerde <userinput>/sbin/lilo</userinput> dosyası bir yönlendirici olup uygulamanın kendisi <userinput>/sbin/lilo.real</userinput> olarak kurulu olabilir. Benzeri bir durum sizin için de geçerli ise uygulamanın aslını (ismi farklı olsa da) diskete <filename>lilo</filename> adıyla kopyalayın. Disketi SBC'ye takıp bağlayın ve <filename>lilo</filename>'yu buradaki <filename>/hedef/sbin</filename> dizini altına kopyalayın.
  </para><para>
LILO uygulamasının çalışabilmesi için gereken bir kaç dosya daha var. Bu dosyaları da her zaman olduğu gibi Linux yüklü bilgisayarımızdan disket yardımı ile SBC üzerine taşımalıyız. Aşağıdaki dosyaları Linux sisteminizden bir diskete kopyalayın:
  </para><itemizedlist>
  <listitem><filename>/boot/boot-menu.b</filename></listitem>
  <listitem><filename>/boot/boot.b</filename></listitem>
  <listitem><filename>/boot/chain.b</filename></listitem>
  <listitem><filename>/boot/map</filename></listitem>
  </itemizedlist><para>
Ardından bu disketi SBC üzerine takarak dosyaları <filename>/hedef/boot</filename> dizini altına kopyalayın.
  </para><note><para>
Hazırlamış olduğumuz Linux çekirdeğinin de bu aşamaya gelinene kadar <filename>/hedef/boot</filename> dizini altına <filename>kernel</filename> adıyla atılmış olduğunu varsayıyoruz.
  </para></note><para>
Gerekli dosyaları bu şekilde SBC üzerine attıktan sonra şimdi bu ana kadar <filename>/hedef</filename> dizini altında oluşturduğumuz SBC sistemine <emphasis>chroot</emphasis> edelim (Bu işi <userinput>busybox</userinput> kurulumu bittikten sonra herhangi bir adımda yapabilirdik :).
  </para><para>
<screen>
<prompt># </prompt><userinput>chroot /hedef</userinput>


BusyBox v0.60.5 (2003.05.29-21:02+0000) Built-in shell (ash)
Enter 'help' for a list of built-in commands.

<prompt>/ # </prompt>
</screen>
  </para><para>
Artık kök dizinimiz <filename>/</filename>, <filename>/hedef</filename> dizininin altına kaydırılmış durumdadır. Şimdi burada <userinput>vi /etc/lilo.conf</userinput> komutuyla aşağıdaki gibi bir ayar dosyası oluşturalım.
  </para><caution><para>
<userinput>chroot</userinput>> işleminden sonra zaten <filename>/hedef</filename> dizin yapısı içerisinde olduğumuzdan artık <filename>/hedef/etc/lilo.conf</filename> demek yerine doğrudan <filename> /etc/lilo.conf</filename> demeliyiz, çünkü bu noktada <filename>/hedef</filename> dizini bizim için erişilemez durumdadır (zaten biz oyuz, matrix :p) Eski sisteme dönmek için <userinput>exit</userinput> komutu kullanılmalıdır. Ayrıca burada kullandığımız <userinput>vi</userinput> programı öncekilerden farklı olarak gerçekte bizim derlediğimiz <userinput>busybox</userinput> içerisinden çıkan ve ilk açılışta kullandığımız sisteme göre <filename>/hedef/bin/vi</filename> yani <filename>/hedef/bin/busybox</filename> olan uygulamadır.
  </para></caution>
  <example><title><filename>/etc/lilo.conf</filename></title>
<screen>
lba32
boot=/dev/hda
install=/boot/boot-menu.b
map=/boot/map
prompt
timeout=150
vga=normal
default=Linux

image=/boot/kernel
      root=/dev/hda1
      label=Linux
      read-only
</screen>
  </example><para>
Lilo formatıyla ilgili bilgi almak için Linux yüklü bilgisayarınızda <userinput>man 5 lilo.conf</userinput> komutunu verebilirsiniz. Şimdi artık son adım olarak <userinput>lilo</userinput> uygulamasını çalıştırıp diskimizin Ana Önyükleme Kaydının (MBR -Master Boot Record) açılışa uygun hale getirilmesini sağlayalım:
  </para><para>
<screen>
<prompt>/ # </prompt><userinput>/sbin/lilo -v</userinput>
LILO version 22.2, Copyright (C) 1992-1998 Werner Almesberger
Development beyond version 21 Copyright (C) 1999-2001 John Coffman
Released 05-Feb-2002 and compiled at 20:57:26 on Apr 13 2002
MAX_IMAGES=27

Reading boot sector from /dev/hda
Merging with /boot/boot-menu.b
Boot image: /boot/kernel
Added Linux *

Backup copy of boot sector in /boot/boot.0300
Writing boot sector.
<prompt>/ # </prompt>
</screen>
  </para><para>
Artık sistemin tek başına çalışabilmesi için her şey hazır. Şimdi sistemi yeniden başlatalım.
  </para><para>
<screen>
<prompt>/ # </prompt><userinput>exit</userinput>
<prompt># </prompt><userinput>reboot</userinput>
</screen>
  </para><para>
Disket sürücüde disket olmadığından emin olunuz :) Sisteminiz açılmazsa karşılaştığınız sorunları <email>murat@debian.org</email> eposta adresine gönderirseniz bu belgenin sonuna "Problemler ve Çözümler" bölümü ekleyebiliriz.
  </para>
  </sect2>
  </sect1>
  </chapter>

  <chapter  id="embedded-kullanicilar_ve_gruplar">
  <title>Sistem Kullanıcıları ve Gruplar</title>
  <para>
Bu aşamada artık tek başına açılabilir bir sistemimiz olduğuna göre, elimizdeki sistemi daha ayrıntılı bir şekilde yapılandırmak için ayarlamalara başlayabiliriz. İşe sistemdeki kullanıcı ve grupların yapılandırılması, sisteme girişlerin düzenlenmesinden başlayalım.
  </para>
  <para>
Sistemdeki ana kullanıcı olan <literal>root</literal> için gerekli ayarları elle yapmak durumundayız. Bunun için <userinput>vi /etc/passwd</userinput> komutuyla açtığımız dosyaya aşağıdaki satırı girelim:
  </para><para>
<screen>
root::0:0:root:/root:/bin/sh
</screen>
  </para><para>
Dosyayı kaydedip çıktıktan sonra <userinput>vi /etc/group</userinput> komutu ile <literal>root</literal> kullanıcısının gurubunu aşağıdaki gibi oluşturalım:
  </para><para>
<screen>
root:x:0:
</screen>
  </para><para>
Artık root kullanıcısı sisteme eklenmiş durumdadır. Ancak programların kullanıcı kimliklerinden (uid) kullanıcı isimlerine dönüşüm yapabilmeleri için sistemde <filename>libnss_files</filename> kütüphanesi kurulu olmalıdır. Bunun için Linux yüklü bilgisayarınızdan <filename>/lib/libnss_files.so.2</filename> dosyasını disket ile SBC üzerindeki <filename>/lib</filename> dizini altına taşımalısınız. Ardından <userinput>vi /etc/nsswitch.conf</userinput> komutuyla örnekteki gibi bir ayar dosyası oluşturmanız gereklidir:
  </para><example><title><filename>/etc/nsswitch.conf</filename></title>
<screen>
passwd: files
group: files
shadow: files

publickey: files

hosts: files dns
networks: files

protocols: db files
services: db files
ethers: db files
rpc: db files

netgroup: db files
</screen>
  </example><para>
Sisteme kullanıcı veya grup ekleme çıkarma işlemlerini <userinput>adduser</userinput>, <userinput>deluser</userinput>, <userinput>addgroup</userinput>, <userinput>delgroup</userinput> uygulamaları ile yapabilirsiniz (!). Ancak bu yazının hazırlandığı zamanki son <userinput>tinylogin</userinput> sürümü olan <literal>1.4</literal>'te bahsedilen uygulamaların davranışı sizin onlardan beklediğiniz yönde değil. <userinput>tinylogin</userinput> bu anlamda ağabeyi <userinput>busybox</userinput> kadar yetenekli değil. Bu yüzden kullanıcı ve grupları <filename>/etc/group</filename> ve <filename>/etc/passwd</filename> dosyalarını düzenleyerek eklemenizi öneriyorum. Örnek olarak <literal>ali</literal> kullanıcısını <literal>users</literal> gurubuna dahil olacak şekilde eklemek için öncelikle <filename>/etc/group</filename> dosyasına <literal>users</literal> grubuna ait bir kayıt ekleyelim, <userinput>echo "users:x:100:" >> /etc/group</userinput> ve ardından <filename>/etc/passwd</filename> dosyasına aşağıdaki kaydı girelim, <userinput>vi /etc/passwd</userinput>
  </para><para>
<screen>
ali::1000:100:Ali Hemenkavrar:/home/ali:/bin/sh
</screen>
  </para><para>
Şimdi <literal>ali</literal> kullanıcısının parolasını değiştirelim:
  </para><para>
<screen>
<prompt>/etc # </prompt><userinput>passwd ali</userinput>
Changing password for ali
Enter the new password (minimum of 5, maximum of 8 characters)
Please use a combination of upper and lower case letters and numbers
Enter new password:
Re-enter new password:
Password changed.
<prompt>/etc # </prompt>
</screen>
  </para><para>
Şimdi isterseniz daha önce <userinput>getty</userinput> ile ilişkilendirdiğiniz 3. sanal konsoldan bu kullanıcı ile sisteme giriş yapabilirsiniz. Bunun için <userinput>Alt - F3</userinput> ile 3. konsola geçelim:
  </para><para>
<screen>
<prompt>(none) login: </prompt><userinput>ali</userinput>
Password:

BusyBox v0.60.5 (2003.05.29-21:02+0000) Built-in shell (ash)
Enter 'help' for a list of built-in commands.

<prompt>~ $ </prompt><userinput>id</userinput>
uid=1000(ali) gid=100(users)
<prompt>~ $ </prompt>
</screen>
  </para><para>
Burada dikkatinizi çekti ise, sistem ismi <emphasis>(none)</emphasis> olarak gözükmektedir. Sisteme verdiğiniz ismin burada gözükmesi için neler yapılması gerektiğine <xref linkend="embedded-ag_ayarlari"/> bölümünden bakabilirsiniz.
  </para>
  </chapter>

  <chapter id="embedded-ag_ayarlari"><title>Ağ Ayarları</title>
  <para>
Kullandığınız SBC üzerinde bir ethernet kartı varsa bu hayatınızı ciddi orada kolaylaştıracaktır. Dosya aktarımları, sisteme erişim vb. gibi konularda getirileri oldukça fazladır. Ayrıca SBC'yi bir ağa dahil etme, onunla yapabileceklerinizi de elbette artıracaktır.
  </para><para>
Belgenin yazımında kullandığımız SBC üzerinde bir Realtek 8139 ethernet arayüzü mevcut idi. Bu nedenle çekirdeği derlerken RTL8139 desteğini de seçtik ve ethernet kartımızın Linux çekirdeği tarafından tanınabilmesini sağladık. Benzer işlemleri kendi ethernet kartınıza göre sizin de yapmanız gerekiyor.
  </para><para>
<screen>
<prompt># </prompt><userinput>cat /proc/pci | grep -i eth</userinput>
  Ethernet controller: Realtek Semiconductor Co., Ltd. RTL-8139/8139C/8139C+ ¬
  (rev 16).
<prompt># </prompt><userinput>dmesg | grep eth</userinput>
eth0: RealTek RTL8139 Fast Ethernet at 0xc2800000, 00:05:b7:01:20:16, IRQ 10
eth0:  Identified 8139 chip type 'RTL-8139C'
<prompt># </prompt>
</screen>
  </para><para>
Kartımız sistem tarafından tanındığına göre ayarlamaları yapabiliriz. Bunun için değişebilir nitelikte olan bilgileri statik olarak açılışta çalışacak kabuk programına yazmak yerine <filename>/etc</filename> dizini altında bir genel ayar dosyası oluşturup buraya yazma yöntemini seçelim. Dosyamızın adı <filename>/etc/config</filename> olsun. Şimdi <userinput>vi /etc/config</userinput> ile bu dosyanın içeriğini aşağıdaki gibi oluşturalım:
  </para><para>
<screen>
HOSTNAME=embed
IP=192.168.0.155
NETMASK=255.255.255.0
GATEWAY=192.168.0.1
</screen>
  </para><para>
Gerekli parametrelerimizi burada ayarladık. Şimdi bu parametrelerle sistemin açılışı esnasında <filename>/etc/hosts</filename> dosyasını düzenleyecek ve <literal>HOSTNAME</literal> değerini atayacak, ardından ağ kartına ilişkin IP ve yönlendirme ayarlarını yapacak program satırlarını açılışta çalışan betiğimiz olan <filename>/etc/init.d/rcS</filename> dosyasına ekleyelim.
  </para><para>
<screen>
## Ayar dosyasını oku
. /etc/config

## Ağ ayarlamaları
if [ -n "$HOSTNAME" ]; then
    hostname $HOSTNAME
    echo "127.0.0.1    localhost" > /etc/hosts
    echo "$IP    $HOSTNAME" >> /etc/hosts
fi

ifconfig lo 127.0.0.1 netmask 255.0.0.0 up

ifconfig eth0 $IP netmask $NETMASK up

if [ -n "$GATEWAY" ]; then
    route add default gw $GATEWAY
fi
</screen>
  </para><para>
Bu değişiklikleri yaptıktan sonra sistemi yeniden başlatmaya gerek olmaksızın <filename>/etc/init.d/rcS</filename> betiğini çalıştırıp istenilen sonucu verip vermediğini görebiliriz:
  </para><para>
<screen>
<prompt># </prompt><userinput>/etc/init.d/rcS</userinput>
mount: Mounting proc on /proc failed: Device or resource busy
eth0: Setting 100mbps full-duplex based on auto-negotiated partner ability 45e1
<prompt># </prompt><userinput>ifconfig eth0</userinput>
eth0    Link encap:Ethernet  HWaddr 00:05:B7:01:20:16
        inet addr:192.168.0.155  Bcast:192.168.0.255  Mask:255.255.255.0
        UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
        RX packets:10 errors:0 dropped:0 overruns:0 frame:0
        TX packets:7 errors:0 dropped:0 overruns:0 carrier:0
        collisions:0 txqueuelen:100
        RX bytes:1234 (1.2 kiB)  TX bytes:610 (610.0 iB)
        Interrupt:10

<prompt># </prompt><userinput>ping 212.156.4.1</userinput>
PING 212.156.4.1 (212.156.4.1): 56 data bytes
64 bytes from 212.156.4.1: icmp_seq=0 ttl=57 time=23.2 ms
64 bytes from 212.156.4.1: icmp_seq=1 ttl=57 time=22.7 ms
64 bytes from 212.156.4.1: icmp_seq=2 ttl=57 time=21.8 ms
</screen>
  </para><para>
SBC üzerinden ağ bağlantısını artık gerçekleştirdiğimize göre sisteme <userinput>FTP</userinput> ve <userinput>telnet</userinput> sunucularını kurabiliriz. Bunun için öncelikle <literal>inetd</literal> servisinin kurulması gereklidir.
  </para>

  <sect1 id="embedded-inetd"><title>Inetd Kurulumu</title>
  <para>
Sisteme TCP/IP tabanlı bir ağ üzerinden dosya göndermek veya sisteme bağlanmak için FTP ve telnet servislerini kurabiliriz. Bu amaçla basit bir FTP sunucu ygulaması <userinput>in.ftpd</userinput> ve telnet sunucu uygulaması <userinput>in.telnetd</userinput> Linux yüklü sistemden SBC üzerine aktarılmalıdır. FTP ve telnet servisleri, ilgili portları sürekli dinlemeyecektir. Bunun yerine her iki port (ve olursa ileride diğer servislerin de ihtiyaç duyduğu portlar) <userinput>inetd</userinput> <emphasis>(Internet Daemon)</emphasis> programı tarafından dinlenecek, porta veri geldiğinde ilgili program arka planda çalıştırılacak, gelen istek programa yönlendirilecektir. <userinput>inetd</userinput>, <userinput>busybox</userinput> içerisinden çıkmadığından programın çalıştırılabilmesi için Linux yüklü sistemden <filename>/usr/sbin/inetd</filename> dosyasının da SBC üzerine aktarılması gereklidir. Ayrıca <userinput>inetd</userinput> kendi içinde <literal>tcp</literal> uygulama yönlendiricisi olarak <userinput>/usr/sbin/tcpd</userinput> uygulamasınıı kullandığından gene bu dosyanın da aktarılması gerekmektedir.
  </para><para>
Burada dikkat edilmesi gereken bir nokta, artık SBC üzerine attığımız uygulamaların çok fazla kütüphaneye bağımlı olmaya başlamalarıdır. Temel işlerden daha özel işlere doğru çıktığımızda uygulamaların kullandığı kütüphanelerin sayısı da artmaktadır. <userinput>tcpd</userinput> bunun en basit örneğini oluşturuyor. Linux yüklü bilgisayarımızda aşağıdaki gibi <userinput>tcpd</userinput> uygulamasının ihtiyaç duyduğu kütüphanelerin neler olduğunu öğrenebiliriz:
  </para><para>
<screen>
<prompt>laptop:~/docbook/embedded$ </prompt><userinput>ldd /usr/sbin/tcpd</userinput>
      libwrap.so.0 => /lib/libwrap.so.0 (0x4001b000)
      libc.so.6 => /lib/libc.so.6 (0x40024000)
      libnsl.so.1 => /lib/libnsl.so.1 (0x40134000)
      /lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x40000000)
</screen>
  </para><para>
Son üç kütüphane SBC sistemimizde zaten mevcut iken <filename>libwrap.so.0</filename> henüz mevcut değildir. Dolayısıyla <userinput>tcpd</userinput> uygulamasının çalışabilmesi için bu dosyanın da dosya sistemi üzerine atılması gereklidir. Aksi takdirde uygulama çalışmayacak ve aşağıdaki gibi bir hata mesajı verecektir:
  </para><para>
<screen>
/usr/sbin/tcpd: error while loading shared libraries: libwrap.so.0: cannot open
shared object file: No such file or directory
</screen>
  </para><para>
Bu aşamadan sonra SBC üzerine atacağımız çalıştırılabilir her uygulama için buradaki işlem adımlarını tekrarlayarak gerekli kütüphanelerle birlikte atmalıyız.
  </para><para>
Inetd programı, hangi portları dinleyeceğini ve gerektiğinde çalıştırması gereken uygulamaların neler olduğunu <filename>/etc/inetd.conf</filename> ayar dosyasından okur. <userinput>man inetd</userinput> ve <userinput>man inetd.conf</userinput> komutlarıyla program ve ayar dosyasının biçimi hakkında sisteminizden yardım alabilirsiniz. Ftp ve telnet servisleri için gerekli <filename>inetd.conf</filename> dosyası aşağıdaki gibi olmalıdır:
  </para><example><title>/etc/inetd.conf</title>
<screen>
# /etc/inetd.conf dosyamız
ftp  stream tcp nowait root /usr/sbin/tcpd /usr/sbin/in.ftpd
telnet stream tcp nowait root /usr/sbin/tcpd  /usr/sbin/in.telnetd
</screen>
  </example><para>
Bu dosyanın satırlarındaki ilk sözcük servisin ismini göstermektedir. Buradan alınan isim bilgisi (<literal>ftp</literal>, <literal>telnet</literal>) <filename>/etc/services</filename> dosyası içerisinde aranacaktır.  Bu durumda <filename>/etc/services</filename> dosyası Linux yüklü bir sistemden aynen kopyalanmalı veya sadece aşağıdaki kayıtları içerecek şekilde oluşturulmalıdır:
  </para><para>
<screen>
telnet          23/tcp
ftp-data        20/tcp
ftp             21/tcp
</screen>
  </para><para>
<userinput>inetd</userinput>, <userinput>telnet</userinput> vb. gibi servislerin ilk ayarlanması süreci boyunca <userinput>syslogd</userinput> programının arka planda çalışıyor olması çıkabilecek problemlerin çözümünde oldukça faydalı bilgiler sağlayacaktır. <userinput>syslogd</userinput> açık olduğu müddetçe, <literal>syslog</literal> mekanizmasını kullanan programlar hata durumlarını günlüğe yazabileceğinden <filename>/var/log</filename> dizini altındaki dosyaların incelenmesiyle sorunun nereden kaynaklandığını bulmak çok daha kısa zaman alacaktır. <userinput>syslogd</userinput> programını çalıştırmak için komut satırında <userinput>syslogd</userinput> yazmanız yeterlidir. Her açılışta çalışması istenirse bu defa <filename>/etc/init.d/rcS</filename> dosyası içerisinde herhangi bir satıra
  </para><para>
<screen>
syslogd &amp;
</screen>
  </para><para>
kaydı eklenmelidir. Kullanımına artık gerek kalmadığı görüldüğünde <filename>rcS</filename> içerisinden bu satır kaldırılmalıdır (gömülü bir sistemde bu anlamda günlük tutulması, sistem belirli bir kararlılığa ulaştıktan sonra mutlaka önlenmelidir).
  </para><para>
Bu ayarlamalar yapıldıktan sonra <filename>rcS</filename> içerisinde <literal>inetd</literal> şeklinde <userinput>inetd</userinput> servisinin açılışta çalışabilmesi için  gerekli satırın bulunduğundan emin olunmalıdır. Sistemi yeniden başlatmadan <userinput>inetd</userinput> programını test edebilmek için komut satırından <userinput>inetd</userinput> yazılması yeterlidir. Eğer bir hata oluşursa <filename>/var/log/messages</filename> dosyası incelenmelidir.
  </para>
  </sect1>

  <sect1  id="embedded-ftp"><title>FTP Sunucu Kurulumu</title>
  <para>
SBC üzerine kuracağınız FTP sunucu için dikkat etmeniz gereken bazı noktalar vardır. Bir kere amacımız sadece basit anlamda dosya aktarımını gerçekleştirebilmektir. Karmaşık özelliklere sahip çok büyük bir FTP sunucu değil, olabildiği kadar küçük, sağlam ve güvenilir bir uygulama bizim için yeterlidir. Bir diğer önemli özellik, FTP sunucunun PAM desteği olmadan doğrudan sistemdeki <filename>passwd</filename> ve <filename>shadow</filename> dosyaları ile çalışabilmesi gerekliliğidir. Aksi takdirde FTP sunucuyu çalıştırmak için SBC üzerindeki sistemimize PAM desteği vermek zorunda kalabiliriz ki bu da "Türkler için ayda nasıl yürünür?" konulu bir eğitim kadar gereksizdir.
  </para><para>
Yukarıda bahsettiğim koşullar ve yıllardan beri kendini kanıtlamış sağlam yapısı nedeniyle ben <userinput>bsd-ftpd</userinput> sunucusunu kullanmaya karar verdim. <userinput>bsd-ftpd</userinput>, OpenBSD FTP sunucusunun Linux işletim sistemine taşınmış halidir. Programı <ulink url="http://www.eleves.ens.fr:8080/home/madore/programs/"/> adresinden indirebilirsiniz. Arşivi indirip açtıktan sonra içerisinden çıkan <filename>Makefile</filename> dosyasını bir metin düzenleyicide açarak dosyanın başındaki ilgili yerleri aşağıdaki hale getiriniz:
  </para><para>
<screen>
#CFLAGS = $(OPT_CFLAGS) $(EXTRA_CFLAGS) -DTCPWRAPPERS -DUSE_PAM ¬
-DAUTO_UNCOMPRESS -DINTERNAL_LS
#LIBS = $(EXTRA_LIBS) -lutil -lwrap -lnsl -lcrypt -lpam -ldl
## If you prefer shadow password support, try this:
CFLAGS = $(OPT_CFLAGS) $(EXTRA_CFLAGS) -DTCPWRAPPERS -DUSE_SHADOW ¬
-DAUTO_UNCOMPRESS -DINTERNAL_LS
LIBS = $(EXTRA_LIBS) -lutil -lwrap -lnsl -lcrypt
</screen>
  </para><para>
Bu sayede programın PAM ile çalışmak üzere değil, sistemdeki kullanıcı veritabanıyla çalışabilecek şekilde derlenmesini sağladık.
  </para><para>
<filename>Makefile</filename> üzerinde gerekli değişiklikleri yaptıktan sonra <userinput>make</userinput> komutu ile programı derleyebiliriz. Derleme işlemi bittiğinde yaklaşık 80 kB büyüklüğünde <userinput>ftpd</userinput> uygulaması oluşacaktır. <userinput>strip ftpd</userinput> komutu ile uygulama içerisinden ihtiyaç duymayacağımız sembollerin çıkartılmasını da sağlayınca uygulamanın boyu 65 kB seviyelerine inecektir. Bu uygulamayı SBC sistemimizdeki <filename>/usr/sbin</filename> dizini altına <filename>in.ftpd</filename> adıyla taşımalıyız.
  </para><note><para>
<userinput>bsd-ftpd</userinput> uygulamasını derlemek için GNU Libc kütüphanelerin yanısıra <filename>libwrap0-dev</filename> paketinden çıkan geliştirme kütüphanelerine de ihtiyaç vardır (<filename>tcpd.h</filename> vb. için).
  </para></note><para>
Derlediğimiz uygulamayı SBC üzerine atıp arka planda <userinput>inetd</userinput>'nin de çalıştığından emin olunca Linux yüklü sistemimizden SBC üzerindeki FTP sunucumuzu test edebiliriz:
  </para><para>
<screen>
<prompt>laptop:~$ </prompt><userinput>ftp 192.168.0.155</userinput>
Connected to 192.168.0.155.
220 embed FTP server (Version 6.5/OpenBSD, linux port 0.3.3) ready.
Name (192.168.0.155:demirten): <userinput>root</userinput>
331 Password required for root.
Password:
230 User root logged in.
Remote system type is UNIX.
Using binary mode to transfer files.
ftp> <userinput>ls /boot</userinput>
200 PORT command successful.
150 Opening ASCII mode data connection for '/bin/ls'.
total 764
-rw-r--r--  1 root  root    7964 Jun  1 10:49 boot-menu.b
-rw-r--r--  1 root  root     512 Jun  1 14:34 boot.0300
-rw-r--r--  1 root  root    7964 Jun  1 10:50 boot.b
-rw-r--r--  1 root  root     728 Jun  1 10:50 chain.b
-rw-r--r--  1 root  root  744821 Jun  1 12:05 kernel
-rw-------  1 root  root   12288 Jun  1 14:34 map
226 Transfer complete.
ftp> <userinput>bye</userinput>
221 Goodbye.
<prompt>laptop:~$ </prompt>
</screen>
  </para><para>
Bu ekran çıktısı artık disket sürücüyü sistemden çıkarabileceğimizin müjdesini veriyor bize :) Peki ağ bağlantısı sağlayamayanlar ne yapacak? Bunun için <xref linkend="embedded-seri_portlar"/> bölümüne bakın.
  </para>
  </sect1>

  <sect1 id="embedded-telnet"><title>Telnet Sunucu Kurulumu</title>
  <para>
Bir önceki bölümde anlatılan FTP sunucu kurulumuna benzer şekilde şimdi de <userinput>telnet</userinput> servisini sisteme kuralım. FTP'ye oranla bu kurulumumuz daha basit olacak çünkü uygulamayı yeniden derlemeye ihtiyacımız yok.
  </para><para>
<userinput>telnet</userinput> servisi için temelde <userinput>in.telnetd</userinput> ve <userinput>/usr/lib/telnetlogin</userinput> uygulamasının kurulumu yeterlidir. Hemen gerekli kütüphanelerin bizde olup olmadığına bakalım:
  </para><para>
<screen>
<prompt>laptop:~$ </prompt><userinput>ldd /usr/sbin/in.telnetd</userinput>
        libutil.so.1 => /lib/libutil.so.1 (0x4001b000)
        libc.so.6 => /lib/libc.so.6 (0x4001f000)
        /lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x40000000)
</screen>
  </para><para>
Buradaki çıktıda yer alan <filename>libutil.so.1</filename> kütüphanesi SBC sistemimizde mevcut değil. Bu durumda taşımamız gereken dosyalar arasına bunu da ekliyoruz. FTP servisimiz çalıştığına göre hemen FTP kullanarak dosyaları SBC üzerine aktaralım:
  </para><para>
<screen>
<prompt>laptop:~$ </prompt><userinput>ncftp -u root 192.168.0.155</userinput>
NcFTP 3.1.3 (Mar 27, 2002) by Mike Gleason (ncftp@ncftp.com).
Connecting to 192.168.0.155...
embed FTP server (Version 6.5/OpenBSD, linux port 0.3.3) ready.
Logging in...
Password requested by 192.168.0.155 for user "root".

    Password required for root.

Password:
User root logged in.
Logged in to 192.168.0.155.
ncftp /root > <userinput>cd /usr/sbin</userinput>
ncftp /usr/sbin > <userinput>put /usr/sbin/in.telnetd</userinput>
/usr/sbin/in.telnetd:                                   31.73 kB  993.88 kB/s
ncftp /usr/sbin > <userinput>cd /usr/lib</userinput>
ncftp /usr/lib > <userinput>put /usr/lib/telnetlogin</userinput>
/usr/lib/telnetlogin:                                    5.60 kB  147.83 kB/s
ncftp /usr/lib > <userinput>cd /lib</userinput>
ncftp /lib > <userinput>put /lib/libutil.so.1</userinput>
/lib/libutil.so.1:                                       7.25 kB  193.60 kB/s
ncftp /lib >
</screen>
  </para><note><para>
FTP üzerinden gönderdiğiniz dosyaların izinleri kaybolabilir. Çalıştırılabilir dosyalar FTP ile gönderildiklerinde bu özelliklerini kaybedeceklerdir. Bu nedenle SBC sisteminde <userinput>chmod</userinput> komutu ile gerekli erişim hakları verilmelidir. Bu örnek için gerekli komut <userinput>chmod 755 /usr/sbin/in.telnetd /usr/lib/telnetlogin</userinput> şeklindedir.
  </para></note><para>
Her şey hazır olduğuna göre Linux yüklü bilgisayarımızdan SBC üzerindeki <userinput>telnet</userinput> servisini test edelim:
  </para><para>
<screen>
<prompt>laptop:~$ </prompt><userinput>telnet 192.168.0.155</userinput>
Trying 192.168.0.155...
Connected to 192.168.0.155.
Escape character is '^]'.

Linux 2.4.20 (embed) (ttyp1)


embed login: <userinput>ali</userinput>
Password:


BusyBox v0.60.5 (2003.05.29-21:02+0000) Built-in shell (ash)
Enter 'help' for a list of built-in commands.

<prompt>~ $ </prompt>
</screen>
  </para><para>
İçerdeyiz :) <userinput>telnet</userinput> servisimiz düzgün bir şekilde çalışıyor.
  </para><caution><para>
FTP ve telnet servislerini bu şekilde ayarladıktan sonra <filename>/etc/init.d/rcS</filename> dosyası içerisinde <userinput>inetd</userinput> uygulamasının her sistem açılışında başlatılması için
  </para><para>
<screen>
/usr/sbin/inetd
</screen>
  </para><para>
satırı eklenmelidir (sonunda &amp; yok).
  </para></caution>
  </sect1>
  </chapter>

  <chapter id="embedded-seri_portlar"><title>Seri Portların Kullanımı</title>
  <para>
Önceki bölümde ethernet arayüzünü yapılandırarak ağa dahil olma, FTP ve telnet servislerini kullanma konularını işledik. Bu sayede FTP kullanarak dosyaları disketlerle taşıma zahmetinden kurtulurken telnet servisini kullanarak SBC'ye bir monitor bağlamadan çalışabilme şansına sahip oluyorduk. Ancak sisteminizde ethernet desteği yoksa benzeri kolaylıkları seri portu kullanarak sağlayabiliriz. Sisteminizde ethernet desteği olsa bile buradaki adımları uygulayarak seri portu farklı amaçlar için kullanabilirsiniz.
  </para><para>
Buradaki adımları uygulayabilmeniz için seri iletişim kablosuna ihtiyacınız vardır. Bu kablo aslında iki ucu <emphasis>dişi</emphasis> DSUB girişli bir telefon kablosunun bir tarafındaki Transmit Data bacağının diğer taraftaki Receive Data, Receive Data bacağının ise diğer taraftaki Transmit Data'ya bağlandığı basit bir kablodur ve sadece bu iki bağlantıyı yapmak aslında yeterlidir. Ancak, akış kontrolleri (<emphasis>hardware flow control</emphasis>) için RTS/CTS vb. sinyallerinin de iki sistemin seri portu arasında taşınabilmesi gereklidir. Bu nedenle aşağıdaki diyagrama göre yapacağınız bir seri iletişim kablosu daha çok işinize yarayacaktır: (İkili bükülü çiftler <emphasis>çiftler</emphasis> sütununda gösterilmiştir.)
  </para><table>
  <title>Seri iletişim kablosunun bağlantı bilgisi</title>
  <tgroup align="center" cols="7">
  <colspec colwidth="0.4"/>
  <colspec colwidth="0.1"/>
  <colspec colwidth="0.1"/>
  <colspec colwidth="0.1"/>
  <colspec colwidth="0.1"/>
  <colspec colwidth="0.1"/>
  <colspec colwidth="0.1"/>
  <tbody>
    <row>
      <entry></entry><entry>25 Pin</entry><entry>9 Pin</entry><entry>Çiftler</entry><entry>9 Pin</entry>
      <entry>25 Pin</entry><entry></entry>
    </row>
    <row>
      <entry>FG (Frame Ground)</entry><entry>1</entry><entry>1</entry><entry>X</entry>
      <entry>-</entry><entry>1</entry><entry>FG</entry>
    </row>
    <row>
      <entry>TD (Transmit Data)</entry><entry>2</entry><entry>3</entry><entry>1</entry>
      <entry>2</entry><entry>3</entry><entry>RD</entry>
    </row>
    <row>
      <entry>RD (Receive Data)</entry><entry>3</entry><entry>2</entry><entry>1</entry>
      <entry>3</entry><entry>2</entry><entry>TD</entry>
    </row>
    <row>
      <entry>RTS (Request To Send)</entry><entry>4</entry><entry>7</entry><entry>2</entry>
      <entry>8</entry><entry>5</entry><entry>CTS</entry>
    </row>
    <row>
      <entry>CTS (Clear To Send)</entry><entry>5</entry><entry>8</entry><entry>2</entry>
      <entry>7</entry><entry>4</entry><entry>RTS</entry>
    </row>
    <row>
      <entry>SG (Signal Ground)</entry><entry>7</entry><entry>5</entry><entry>-</entry>
      <entry>5</entry><entry>7</entry><entry>SG</entry>
    </row>
    <row>
      <entry>DSR (Data Set Ready)</entry><entry>6</entry><entry>6</entry><entry>3</entry>
      <entry>4</entry><entry>20</entry><entry>DTR</entry>
    </row>
    <row>
      <entry>DTR (Data Terminal Ready)</entry><entry>20</entry><entry>4</entry><entry>3</entry>
      <entry>6</entry><entry>6</entry><entry>DSR</entry>
    </row>
  </tbody>
  </tgroup>
  </table>

  <sect1 id="embedded-seri_dosya"><title>Seri Porttan Dosya Aktarımı</title>
  <para>
Önceki bölümde anlatılan niteliklere uygun seri iletişim kablosu edinebildiyseniz şimdi seri portlar arasından dosya transferi için gerekli ayarlamaları yapabiliriz. Bunun için çok gerekli olmamakla birlikte, seri portu kullanacak isek başka amaçlar için de bize yardımcı olabilecek <userinput>minicom</userinput> uygulamasını sisteme kurabiliriz. Hemen gerekli kütüphanelerin neler olduğunu öğrenelim:
  </para><para>
<screen>
<prompt>laptop:~/docbook/embedded$ </prompt><userinput>ldd /usr/bin/minicom</userinput>
        libncurses.so.5 => /lib/libncurses.so.5 (0x4001b000)
        libc.so.6 => /lib/libc.so.6 (0x4005a000)
        /lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x40000000)
</screen>
  </para><para>
Çıktıdan görüldüğü gibi <userinput>minicom</userinput> uygulamasının yanısıra SBC sistemimizde henüz bulunmayan <filename>libncurses.so.5</filename> kütüphanesinin de taşınması gereklidir. Bu dosyaları (ağ bağlantımızın olmadığını varsayarsak) disketle SBC üzerine taşımalıyız.
  </para><para>
<userinput>minicom</userinput> uygulamasının çalışabilmesi için <filename>/usr/share/terminfo</filename> dizini altında kullanacağımız uçbirim türlerine uygun dosyalar bulunmalıdır (Aslında bu gereklilik kullanılan <filename>ncurses</filename> kütüphanesinden kaynaklanmaktadır). SBC üzerinde <filename>linux</filename>, <filename>xterm</filename> ve <filename>xterm-color</filename> uçbirim türlerinin kullanılacak olduğunu düşünerek Linux yüklü sistemden aşağıdaki dosyaları, SBC üzerinde aynı dizine taşıyın:
  </para><para>
<literallayout indent="0">
    /usr/share/terminfo/l/linux
    /usr/share/terminfo/x/xterm
    /usr/share/terminfo/x/xterm-color
</literallayout>
  </para><note><para>
SBC üzerinde bu dizinler olmadığından oluşturmalısınız:
  </para><para>
<screen>
mkdir -p /usr/share/terminfo/l
mkdir -p /usr/share/terminfo/x
</screen>
  </para></note><para>
Programı <userinput>minicom -c on</userinput> komutuyla çalıştırırsanız renk desteğini etkin hale getirebilir daha güzel bir ekran ile çalışabilirsiniz.
  </para><para>
Her iki sistemde <userinput>minicom</userinput>'u çalıştırıp seri port ayarlarını yaptıktan sonra (port, baudrate vb.) dosya aktarım işlemlerini gerçekleştirebiliriz. Bunun için <literal>ZModem</literal> protokolünü kullanabiliriz. <userinput>minicom</userinput> tek başına bunu yapamaz, <userinput>lrzsz</userinput> uygulamasından  çıkan <userinput>sz</userinput> ve <userinput>rz</userinput> programlarına ihtiyaç duymaktadır. Linux yüklü sisteminizden <filename>/usr/bin/sz</filename> ve <filename>/usr/bin/rz</filename> uygulamalarını SBC üzerine aktardıktan sonra <userinput>minicom</userinput> uygulaması içerisinden <userinput>Ctrl - A - S</userinput> ile dosya aktarım menüsüne ulaşabilir, oradan <literal>ZModem</literal> protokolünü ve aktarmak istediğiniz dosyaları seçerek iki sistem arasında veri alışverişi yapabilirsiniz (her iki tarafta <userinput>minicom</userinput> uygulaması açık olmalı).
  </para><figure><title>Minicom ile dosya transferi</title>
  <inlinemediaobject><imageobject>
  <imagedata fileref="minicom.jpg" format="JPEG"/>
  </imageobject><textobject><phrase>Minicom ile dosya transferi</phrase></textobject>
  </inlinemediaobject>
  </figure>
  </sect1>

  <sect1 id="embedded-seri_konsol"><title>Seri Konsol</title>
  <para>
Seri port kullanarak Linux sisteminize erişebilmek, özellikle SBC'ye bir monitor takmak istemediğinizde oldukça faydalı bir özelliktir. Bu yöntemde de <emphasis>seri iletişim kablosu</emphasis> kullanılmalıdır. Seri konsol hakkında ayrıntılı bilgiler Linux çekirdek kaynak kodlarından çıkan <filename> Documentation/serial-console.txt</filename> belgesinde mevcuttur. Burada hızlıca seri konsolu nasıl ayarlabileceğinizden bahsedeceğim.
  </para><para>
Öncelikle işe çekirdekten başlamak gerekiyor. Seri konsol üzerinden bir Linux sistemine erişilecek ise, o sistemde kullanılacak olan çekirdekte bu destek etkin hale getirilmelidir. İlgili seçenek, çekirdek bileşenlerini seçim menülerinden <emphasis>Character devices</emphasis> bölümü altındaki <emphasis>Support for console on serial port</emphasis> seçeneğidir.
  </para><para>
Çekirdek kısmı tamamlandıktan sonra şimdi bir seri portu bu amaçla kullanacağımızı belirtmemiz gerekiyor. Bunun için <filename>/etc/inittab</filename> dosyasının altına aşağıdaki gibi bir kayıt eklemeliyiz:
  </para><para>
<screen>
ttyS1::respawn:/sbin/getty -L ttyS1 38400 vt100
</screen>
  </para><para>
Bu örnekte <filename>ttyS1</filename> yani COM2 portuna seri konsol olarak bağlanılabileceğini belirtiyoruz. İletişim hızı 38400 bps olarak ayarlanmış başka bir sistemden, seri port aracılığıyla bu sistemin COM2 portuna veri gönderildiğinde <userinput>getty</userinput> programı devreye girecek ve kimlik doğrulama aşamasından sonra kabuğa düşülebilecektir. Bu amaçla *NIX sistemlerde <userinput>minicom</userinput>, windows sistemlerde ise <userinput>HyperTerminal</userinput> gibi programlar kullanılabilir.
  </para><para>
Yukarıdaki gibi ayarlamış olduğumuz bir seri konsol ile SBC sistemini yükledikten sonra (ve de <userinput>/sbin/init</userinput> çalıştıktan sonra) seri porttan sisteme girmemiz mümkün olmaktadır. Ancak bazen LILO satırına da müdahale etmemiz gerekebilir veya Linux çekirdeğinin yüklenirken normalde ekrana çıkardığı mesajları görmek isteyebiliriz. Bu aşamada henüz <userinput>init</userinput> programı çalışmaya başlamadığından seri konsol kullanımımıza hazır değildir. Seri konsolu LILO'dan itibaren kullanmak istediğimizde bu defa  <filename>/etc/lilo.conf</filename> ayar dosyası içerisine aşağıdakine benzer bir kayıt ekleyerek <userinput>lilo</userinput> programına seri konsolu kullanmak istediğimizi belirtebilir ve istemiş olduğumuz verileri normalde olduğu gibi seri port üzerinden başka bir sisteme alabiliriz.
  </para><para>
<screen>
## Ortak ayarlar kısmına aşağıdaki satır eklenir
<userinput>serial = 1,38400n8    ## 1 = ttyS1, 38400 baud rate, no parity, 8 bits</userinput>

## çekirdek ayarları kısmına aşağıdaki satır eklenir
## Böyle bir kullanımda çıktı hem COM2 portuna hem de tty0'a gönderilir
<userinput>append = "console=ttyS1,38400n8 console=tty0"</userinput>
</screen>
  </para><para>
Bu satırları ekledikten sonra değişikliklerin etkin olması için <userinput>lilo -v</userinput> komutunu çalıştırmalısınız.
  </para><note><para>
GRUB kullanmadığım için aynı işlemlerin GRUB'da nasıl yapıldığı hakkında bir fikrim yok, yapan biri olursa ve bana da iletirse buraya ekleyebilirim.
  </para></note>
  </sect1>
  </chapter>

  <chapter id="embedded-linux_init"><title>Linux Açılış Süreci</title>
  <para>
Bu bölüm doğrudan gömülü sistemlerde Linux kullanımıyla ilgili olmasa da, sisteme daha fazla hakim olabilmek, Linux açılışında sırasıyla neler olup bittiğini öğrenmek ve de en önemlisi bir sonraki bölümde anlatılacak olan <emphasis>Initial Ramdisk</emphasis> kullanımını daha iyi açıklayabilmek amacıyla belgeye eklenmiştir. Özellikle <userinput>initrd</userinput> kullanacak iseniz hangi işlemi nerede yapmanız gerektiğini, bunun sistem açılışını hangi aşamalarda nasıl etkileyeceğini bilmeniz gereklidir, aksi takdirde işler içinden çıkılmaz bir hal alacaktır.
  </para><para>
Şimdi bilgisayarınıza elektrik verildiği andan itibaren neler olduğuna sırasıyla bakalım. Bu bölümde SBC sistemimizi değil, normal bir masaüstü bilgisayarı örnek alalım. SBC'ler genelde daha özel BIOS ve donanımlara sahip olduğundan ekranda göreceğiniz mesajlar farklı olacaktır.
  </para><para>
Bilgisayarınızın açma butonuna bastınız, anakartınıza elektrik gelmeye başladı. Bakalım neler olacak.
  </para><variablelist><varlistentry>
  <term>Anakart BIOS'u, ekran kartının BIOS'unu tetikler</term>
  <listitem><para>
Bilgisayarınıza elektrik verildiğinde anakartınız üzerindeki BIOS uygulaması çalışmaya başlar ve o da ilk iş olarak ekran kartınızın BIOS'unu çalışması için tetikler. Ekran kartı BIOS'u çalışır ve kendini ilklendirir. Çoğu ekran kartı markası ve modeliyle ilgili ekrana bir şeyler yazar. Bu nedenle dikkat ederseniz ilk açılışta daha anakartın BIOS bilgilerinin gösterildiği ekran gelmeden, öncelikle ekran kartıyla ilgili bilgiler görüntülenir.
  </para><tip><para>
Bilgisayarınızı yeniden başlattığınızda <emphasis>(soft reset)</emphasis> ekran kartı BIOS'u ilklendirme işlemlerini yeniden yapmaz, daha doğrusu anakart tarafından bu amaçla tetiklenmez.
  </para></tip><para>
<screen>
ATI Technologies Inc Radeon Mobility M6 LW
32768 kB

VGA/VBE BIOS, Version 2.2
....
</screen>
  </para><para>
ve ekran temizlenir.
  </para></listitem>
  </varlistentry><varlistentry>
  <term>Anakartınızın BIOS'u kendini ilklendirir</term>
  <listitem><para>
Bu aşamada anakart BIOS'u çalışarak donanımların varlığından haberdar olur. Bellek, disket sürücü vb. gibi aygıtları test eder. Ekrana aşağıdakine benzer mesajlar çıkarır:
  </para><para>
<screen>
Memory Test: 131072K OK
Award Plug and Play BIOS Extension v1.0A
Copyright (C) 1998, Award Software, Inc.
Press DEL to enter SETUP
</screen>
  </para><para>
ve ekran temizlenir.
  </para></listitem>
  </varlistentry><varlistentry>
  <term>SCSI Controller BIOS'u tetiklenir</term>
  <listitem><para>
Sisteminizde bir SCSI kartı var ise SCSI veriyoluyla ilgili ilklendirmeleri yapar ve aşağıdakine benzer mesajlar çıkarır:
  </para><para>
<screen>
Adaptec AHA-2940 Ultra/Ultra W BIOS v 1.23
(C) 1996 Adaptec, Inc. All Rights Reserved.
>>> Press  for SCSISelect(TM)
    SCSI ID:LUNNUMBER #:# 0:0 - MICROP  3243-19 1128RQAV - Drive C: (80h)
</screen>
  </para><para>
ve ekran temizlenir.
  </para></listitem>
  </varlistentry><varlistentry>
  <term>Donanım Özet Bilgisi</term>
  <listitem><para>
Bu aşamada BIOS'unuz donanımınız hakkındaki bilgileri özetler (BIOS'tan yapılacak ayarlarla bu ekranların çıkması engellenmiş olabilir veya anakartınızın BIOS'u bu türden bir bilgi sunmayabilir).
  </para><para>
<literallayout indent="0">
                            Award Software, Inc.
 +------------------+------------------------+--------------------+---------+
 | CPU Type         | Cyrix M II/IBM 6x86MX  | Base Memory        |    640K |
 | Co-Processor     | Installed              | Extended Memory    | 130048K |
 | CPU Clock        | 233                    | Cache Memory       |   1024K |
 +==================+========================+====================+=========+
 | Diskette Drive A | 1.44M, 3.5 in.         | Display Type       | EGA/VGA |
 | Diskette Drive B | None                   | Serial Port(s)     | 3F8 2F8 |
 | Pri. Master Disk | None                   | Parallel Port(s)   | 278     |
 | Pri. Slave Disk  | None                   | Bank 0/1 DRAM Type | None    |
 | Sec. Master Disk | None                   | Bank 2/3 DRAM Type | EDO     |
 | Sec. Slave Disk  | None                   | Bank 4/5 DRAM Type | EDO     |
 +------------------+------------------------+--------------------+---------+
</literallayout>
  </para><para>
Ardından eğer varsa önyükleme sektörü virüslerine karşı BIOS'taki virüs kontrol kodu çalıştırılır ve önyükleme sektörü bilgisinin değişip değişmediği test edilir:
  </para><para>
<screen>
!!!! Trend ChipAwayVirus On Guard !!!! Now Detecting Boot Sector Type Virus...
ChipAwayVirus BIOS Version 1.62
Verifying DMI Pool Data.....
</screen>
  </para><para>
ve ekran temizlenir.
  </para></listitem>
  </varlistentry><varlistentry>
  <term>LILO çalışır</term>
  <listitem><para>
Ardından önyükleme için kullandığınız ortamın Ana Önyükleme Kaydı (MBR) okunur. Lilo kullandığınızı varsayarsak LILO içerisinden yapılacak ayarlamalarla değiştirilebilir olmasına karşın temelde ekrana <literal>LILO</literal> mesajı çıkartılır. Bu mesajdaki her bir karakterin aslında özel bir anlamı vardır. Bazen LILO yerine LI veya LIL deyip takılı kaldığını görebilirsiniz.
  </para><para>
İlk "L" karakteri, <userinput>lilo</userinput>'nun kendini daha rahat hissedeceği <literal>0x0009A000</literal> adresine taşıması sonrasında ekrana çıkartılır.
  </para><para>
"I" karakteri önyükleyici kodunun ikinci aşamasına geçilmeden hemen önce çıkartılır.
  </para><para>
<userinput>lilo</userinput>'nun ikincil önyükleyici kodu ikinci "L" karakterini ekrana çıkartır, çekirdeğin bölümlerini gösteren tanımlayıcıları <literal>0x0009d200</literal> adresine yükler ve son olarak işlem bitince ekrana "O" karakterini çıkartır.
  </para><para>
Ardından yapılan <userinput>lilo</userinput> ayarlamalarına göre değişebilecek bir <prompt>boot</prompt> komut istemi gelir. Burada  birazdan yükleyecek olduğumuz Linux çekirdeğine parametre aktarabiliriz (örneğin kök dosya sisteminin ne olacağı).
  </para><note><para>
Eğer <userinput>lilo</userinput> kullanılmıyorsa ve önyükleyici kodu Linux çekirdeğinin başını gösteriyorsa <filename>linux/arch/i386/boot/bootsect.S</filename> <emphasis>Loading...</emphasis> mesajını ekrana çıkartır.
  </para></note></listitem>
  </varlistentry><varlistentry>
  <term>Linux çekirdeği çalışır</term>
  <listitem><para>
<filename>/linux/arch/i386/boot/setup.S</filename> kod parçası işlemciyi gerçek kipten 32 bit korumalı kipe geçirir. Sıkıştırılmış çekirdek <emphasis>(bzImage)</emphasis> açılır ve <literal>0x00100000</literal> adresine yüklenir. <filename>linux/arch/i386/head.S</filename> ve <filename> linux/arch/i386/boot/compressed/misc.c</filename> kodları sıkıştırılmış çekirdeği açma işlemlerini tamamlar ve işlemcinin yazmaçlarını <emphasis>(register)</emphasis> ayarlar. Bu aşamalarda aşağıdaki satır ekrana bastırılır:
  </para><para>
<screen>
Uncompressing Linux... Ok. Booting kernel.
</screen>
  </para><para>
Intel x86 mimarisine özgü <filename>setup.S</filename> görevini tamamladıktan sonra <literal>0x00100000</literal> adresine atlama <emphasis>(jump)</emphasis> yapar ve genel Linux kodunun çalışmasını sağlar:
  </para><variablelist>
    <varlistentry>
    <term>İşlemci, konsol ve bellek ilklendirmeleri</term>
    <listitem><para>
Kesmelerin tanımlandığı <filename>linux/init/main.c</filename>'de <function>start_kernel(void) </function> çalışmaya başlar. Ardından <filename>linux/kernel/module.c</filename> konsol ve PCI veriyolu için gerekli sürücüleri yükler. Bu noktadan itibaren çekirdek mesajları bellekte saklanmaya başlar, bu mesajlara <filename>/bin/dmesg</filename> ile bakılabilir. Mesajların kalıcı olarak saklanabilmesi için çoğu zaman sistem tarafından <filename>/var/log</filename> dizini altında ayrıca bir dosyada kaydedilir. Sonra aşağıdaki satır <filename>linux/init/version.c</filename> tarafından ekrana çıkartılır:
    </para><para>
<screen>
Linux version 2.4.20 (root@laptop) (gcc version 2.95.4 20011002 ¬
(Debian prerelease)) #16
Cts May 3 19:06:51 EEST 2003
</screen>
    </para><para>
Ardından <function>console_init(..)</function> işlevi tarafından aşağıda mesaj ekrana çıkartılır:
    </para><para>
<screen>
Console: colour VGA+ 80x25
</screen>
    </para><para>
Bu işlevden hemen sonra <function>calibrate_delay()</function> işlevi çalışır ve aşağıdaki  mesaj ekrana çıkartılır:
    </para><para>
<screen>
Calibrating delay loop... 2392.06 BogoMIPS
</screen>
    </para><para>
Sonra <function>mem_init()</function> işlevi çalışır ve işlem bitince aşağıdaki mesajı verir:
    </para><para>
<screen>
Memory: 257316k/262116k available (900k kernel code, 4412k reserved, ¬
410k data, 64k init, 0k highmem)
</screen>
    </para><para>
Ardından önbellek alanları düzenlenir ve işlemci türü test edilir, işlemcinin kabiliyetleri tespit edilir.
    </para><para>
<screen>
Dentry cache hash table entries: 32768 (order: 6, 262144 bytes)
Inode cache hash table entries: 16384 (order: 5, 131072 bytes)
Mount-cache hash table entries: 4096 (order: 3, 32768 bytes)
Buffer-cache hash table entries: 16384 (order: 4, 65536 bytes)
Page-cache hash table entries: 65536 (order: 6, 262144 bytes)
CPU: L1 I cache: 0K, L1 D cache: 8K
CPU: L2 cache: 512K
Intel machine check architecture supported.
Intel machine check reporting enabled on CPU#0.
CPU:     After generic, caps: bfebf9ff 00000000 00000000 00000000
CPU:             Common caps: bfebf9ff 00000000 00000000 00000000
CPU: Intel Mobile Intel(R) Pentium(R) 4 - M CPU 1.80GHz stepping 07
Enabling fast FPU save and restore... done.
Enabling unmasked SIMD FPU exception support... done.
Checking 'hlt' instruction... OK.
POSIX conformance testing by UNIFIX
</screen>
    </para></listitem>
    </varlistentry><varlistentry>
    <term>PCI veriyolu ilklendirmeleri</term>
    <listitem><para>
<function>mpci_init()</function> işlevi <filename>linux/arch/i386/kernel/bios32.c</filename> aşağıdaki mesajları çıkartır:
    </para><para>
<screen>
PCI: PCI BIOS revision 2.10 entry at 0xf0e40, last bus=2
PCI: Using configuration type 1
</screen>
    </para><para>
Hemen ardından <function>pci_init()</function> işlevi çalışarak PCI veriyolunu test etmeye başlar, alttaki mesajı çıkartır:
    </para><para>
<screen>
PCI: Probing PCI hardware
</screen>
    </para></listitem>
    </varlistentry><varlistentry>
    <term>Ağ ilklendirmeleri</term>
    <listitem><para>
<function>socket_init()</function> işlevi ağ ile ilgili ilklendirmeleri yapar. <filename>linux/net/socket.c</filename> içerisinden aşağıdaki mesaj çıkartılır:
    </para><para>
<screen>
Linux NET4.0 for Linux 2.4
Based upon Swansea University Computer Society NET3.039
</screen>
    </para></listitem>
    </varlistentry><varlistentry>
    <term>İlk süreç başlatılır (0): Kernel Idle Thread</term>
    <listitem><para>
Bu noktada <function>init()</function> işlevi tarafından <function>mkswapd_setup()</function> çağırılır ve aşağıdaki mesaj çıkartılır <emphasis>(Linux çekirdeği tamamen aktif olduktan sonra çağırılan <filename>/sbin/init</filename> ile karıştırmayın)</emphasis>
    </para><para>
<screen>
Starting kswapd
</screen>
    </para></listitem>
    </varlistentry><varlistentry>
    <term>Aygıt sürücülerine ilişkin ilklendirmeler</term>
    <listitem><para>
Çekirdek kodu bu noktadan sonra desteklediği aygıtlar ve dosya sistemleri için ilklendirmeleri yapar, işlemlerini tamamlar ve ardından <userinput>/sbin/init</userinput> programını <literal>fork()</literal> ile çalıştırır.
    </para><para>
Bu aşamalarda seri ve paralel portlar, karakter ve blok tabanlı erişim sağlanan aygıtlar, varsa SCSI veriyolu üzerindeki aygıtlar, ethernet kartı, farklı dosya sistemleri, PPP protokolü vb. tüm destekler ilklendirilir ve kullanıma hazır hale getirilir. Kullanılan donanım ve çekirdeğin özelliklerine göre çok farklı mesajlar ekrana çıkartılır, aşağıdaki örnek de bunlardan biridir:
    </para><para>
<screen>
Serial driver version 5.05c (2001-07-08) with MANY_PORTS SHARE_IRQ ¬
SERIAL_PCI enabled
ttyS00 at 0x03f8 (irq = 4) is a 16550A
ttyS01 at 0x02f8 (irq = 3) is a 16550A
PCI: Found IRQ 11 for device 00:1f.6
PCI: Sharing IRQ 11 with 00:1f.5
PCI: Sharing IRQ 11 with 02:07.1
Uniform Multi-Platform E-IDE driver Revision: 6.31
ide: Assuming 33MHz system bus speed for PIO modes; override with ¬
idebus=xx
ICH3M: IDE controller on PCI bus 00 dev f9
PCI: Found IRQ 9 for device 00:1f.1
PCI: Sharing IRQ 9 with 02:07.2
ICH3M: chipset revision 2
ICH3M: not 100% native mode: will probe irqs later
    ide0: BM-DMA at 0x8400-0x8407, BIOS settings: hda:DMA, hdb:pio
    ide1: BM-DMA at 0x8408-0x840f, BIOS settings: hdc:DMA, hdd:pio
hda: IC25N040ATCS04-0, ATA DISK drive
hdc: TOSHIBA DVD-ROM SD-R2102, ATAPI CD/DVD-ROM drive
ide0 at 0x1f0-0x1f7,0x3f6 on irq 14
ide1 at 0x170-0x177,0x376 on irq 15
blk: queue c027fde4, I/O limit 4095Mb (mask 0xffffffff)
hda: 78140160 sectors (40008 MB) w/1768KiB Cache, CHS=4864/255/63, ¬
UDMA(100)
Partition check:
 hda: hda1 hda2 hda3 hda4 &lt; hda5 hda6 >
Floppy drive(s): fd0 is 1.44M
</screen>
    </para><para>
İlklendirme işlemleri bittikten sonra kök dosya sistemi bağlanır ve <userinput>/sbin/init</userinput> programı çalıştırılır. Çekirdek son olarak aşağıdaki satırları ekrana çıkartarak açılış işlemini tamamlar. Bu aşamadan sonra <literal>dmesg</literal> ile gördüğünüz çekirdek mesajları artık <userinput>/sbin/init</userinput> tarafından gerçekleştirilen sistem açılışı, sonradan eklenen, çıkarılan çekirdek modülleri vb. hakkında olacaktır, yükleme işlemi çekirdek için tamamlanmıştır.
  </para><para>
<screen>
VFS: Mounted root (ext3 filesystem) readonly.
Freeing unused kernel memory: 64k freed
</screen>
    </para></listitem>
    </varlistentry></variablelist>
  </listitem></varlistentry></variablelist><para>
Çekirdek içerisinden başlatılan <emphasis>idle thread</emphasis> (süreç numarası 0) tarafından çalıştırılan <userinput>/sbin/init</userinput> uygulaması daima sistemdeki 1 numaralı süreçtir. Geri kalan tüm süreçlerin anası durumundadır. Çalıştığında ekrana <emphasis>INIT: version 2.76 booting</emphasis> gibi bir mesaj çıkarır ve <filename>/etc/inittab</filename> dosyasını okuyarak gerekli işlemleri yapmaya başlar.
  </para>
  </chapter>

  <chapter id="embedded-initrd"><title>Initial Ramdisk (Initrd)</title></chapter>

  <chapter id="embedded-xwindow"><title>X Window System Kurulumu</title></chapter>

  <chapter id="embedded-turkce_nasil"><title>Türkçe Nasıl?</title>
  <sect1 id="embedded-tr_locale">
  <title>Yerel <emphasis>(Locale)</emphasis> Desteği</title>
  <para>
Programlarınızın Türkçe yerelinden haberdar olabilmesi için yapmamız gereken bir kaç işlem var. Ancak bu işlemlere geçmeden önce bir hatırlatma yapmak istiyorum. Eğer beklediğiniz etkiye ulaşmak için sisteme hangi dosyaları kopyalamanız gerektiğini bir türlü bulamıyorsanız, SBC sistemine <userinput>strace</userinput> uygulamasını kurmanızı şiddetle öneririm. <userinput>strace</userinput> çok küçük fakat inanılmaz işe yarayan bir uygulamadır. Programların hangi sistem komutlarını ve sinyallerini kullandıklarını gösterir. Peki doğru dosyayı bulmakta bize nasıl yardımcı olabilir? Hemen bir örnek verelim:
  </para><example><title>Strace kullanımı</title>
<screen>
<prompt>/ # </prompt><userinput>export LANG=tr_TR</userinput>
<prompt>/ # </prompt><userinput>date</userinput>
Sat Jun  7 19:20:18 UTC 2003
<prompt>/ # </prompt><userinput>strace date</userinput>
...
open("/usr/lib/locale/locale-archive", O_RDONLY|O_LARGEFILE) = -1 ENOENT ¬
(No such file or directory)
...
</screen>
  </example><para>
Ekranınız binlerce satırla dolabilir, ama o satırlar arasından yukarıdaki gibi bir tanesi çok işimize yarayacak. Görüldüğü gibi <userinput>date</userinput> programı çalışma esnasında <filename>/usr/lib/locale/locale-archive</filename> dosyasını okumaya çalışıyor ancak bizde öyle bir dosya olmadığı için okuyamıyor. Bu örneği benzeri uygulamalar için de sıkıştığımız zaman tekrar edebiliriz.
  </para><para>
Yukarıdaki örnekte bizde eksik olduğunu gördüğümüz dosyaya gerçekten ihtiyaç vardır. Bu dosyayı Linux sistemimizden SBC üzerine, aynı yere aktarmalıyız: <filename>/usr/lib/locale/locale-archive</filename>
  </para><para>
<filename>locale-archive</filename> dosyasını SBC üzerine aktardıktan sonra <userinput>date</userinput> komutumuzun çıktısına tekrar bakalım:
  </para><para>
<screen>
<prompt>/ # </prompt><userinput>date</userinput>
Cts Haz  7 19:26:59 UTC 2003
</screen>
  </para><para>
Gördüğünüz gibi gün ve ay isimleri Türkçe oldu.
  </para><para>
Türkçe yerel ayarlamaları için yapmamız gereken en temel işlem, <filename>/usr/share/locale</filename> dizin yapısını SBC üzerinde oluşturmaktır. Bunun için aşağıdaki dosyaları SBC üzerine aktarmalıyız:
  </para><para>
<literallayout indent="0">
    /usr/share/locale/locale.alias
    /usr/share/locale/tr
    /usr/share/locale/tr/LC_MESSAGES
    /usr/share/locale/tr/LC_MESSAGES/libc6.mo
</literallayout>
  </para><para>
Son adım olarak karakter çevirimleri için aşağıdaki dosyalar da aynı dizinlerle SBC üzerine aktarılmalıdır:
  </para><para>
<literallayout indent="0">
    /usr/lib/gconv/gconv-modules
    /usr/lib/gconv/ISO8859-9.so
</literallayout>
  </para><para>
Dosyaların tamamı SBC üzerine aktarıldıktan sonra artık <literal>LANG</literal> değişkenimizin değerini <emphasis>tr_TR</emphasis> olarak atayabiliriz. Hemen bu işlemi yapıp yerellerin çalışıp çalışmadığını test edelim:
  </para><para>
<screen>
<prompt>/ # </prompt><userinput>export LANG=tr_TR</userinput>
<prompt>/ # </prompt><userinput>ls /yokboylebirdosya</userinput>
ls: /yokboylebirdosya: Böyle bir dosya ya da dizin yok
</screen>
  </para><para>
Yaptığımız ayarlar işe yarıyor, <emphasis>No such file or directory</emphasis> mesajı yerine <filename>libc6.mo</filename> içerisinden alınan <emphasis>Böyle bir dosya ya da dizin yok</emphasis> mesajı görüntülenmektedir.
  </para><para>
Her sistem açılışında yerel ayarlarının Türkçe olması için <filename>/etc/init.d/rcS</filename> içerisine
  </para><para>
<screen>
export LANG=tr_TR
</screen>
  </para><para>
satırını ekleyebiliriz.
  </para>
  </sect1>

  <sect1 id="embedded-tr_konsol"><title>Konsolda Türkçe Desteği</title>
  <para>
Konsolda Türkçe yazıtiplerinin görüntülenmesi ve Türkçe klavye kullanımı için bir miktar uğraşmamız gerekiyor. Bu işlemi yapabilmek için standart bir yöntem mevcut değil. Mümkün olduğu kadar hızlı bir şekilde Türkçe desteğini verebilmek için işlemlerimize başlayalım.
  </para><para>
Öncelikle Türkçe klavye ayarlamalarından bahsedelim. Bunun için Linux yüklü sisteminizden <filename>trq.kmap.gz</filename> dosyasını kopyalamanız gerekiyor. Bu dosya genellikle <filename>/usr/share/keymaps/i386/qwerty</filename> dizini altında bulunur. Dosyayı buradan alıp SBC üzerinde <filename>/usr/share/keymaps</filename> adında bir dizin yaratıp buraya atalım <emphasis>(i386 .. gibi alt dizinleri de yaratmamıza gerek yok)</emphasis>. Test için başka bir dizin içerisine, bu sıkıştırılmış <filename>trq.kmap.gz</filename> dosyasını açarak dosyanın içeriğine bir metin düzenleyici ile bakın. Eğer <literal>include euro</literal> gibi satırlar varsa bu durumda <literal>include</literal> edilen bu dosyaları da taşımamız gerekiyor. Bendeki sistemde <emphasis>euro</emphasis>, <emphasis>linux-keys-bare</emphasis> ve <emphasis> linux-with-alt-and-altgr</emphasis> için <literal>include</literal> tanımları mevcut. Bu nedenle aşağıdaki dosyaları Linux yüklü sistemimdeki <filename>/usr/share/keymaps/include</filename> dizini altından kopyalayıp SBC üzerindeki <filename>/usr/share/keymaps</filename> dizini altına atıyorum.
  </para><para>
<literallayout indent="0">
    /usr/share/keymaps/include/euro.inc.gz
    /usr/share/keymaps/include/linux-keys-bare.inc.gz
    /usr/share/keymaps/include/linux-with-alt-and-altgr.inc.gz
</literallayout>
  </para><para>
Eğer bu belgedeki örnek üzerinden gidiyor ve dosya sistemi olarak <emphasis>minix</emphasis> seçmiş iseniz <filename>linux-with-alt-and-altgr.inc.gz</filename> dosyasını kopyalarken <emphasis>File name too long</emphasis> şeklinde bir hata almış olmalısınız <computeroutput>:)</computeroutput> Bu hata mesajını almanız normaldir çünkü minix dosya sisteminde bir dosya ismi maksimum 30 karakter uzunluğunda olabilir. Bu tamamen dosya sisteminde kaynaklanan bir sıkıntıdır. Eğer minix yerine <emphasis>ext2</emphasis> kullanıyor olsaydık böyle bir sorunumuz kalmayacaktı.
  </para><note><para>
Aslında ilk geliştirilen minix dosya sisteminde dosya ismi uzunluğu maksimum 14 karakterdir. Burada bahsedilen minix versiyon 2'dir ve standart haline gelmiştir. Versiyon 2 bir takım iyileştirmeler içermektedir ve dosya adlarının 30 karaktere çıkması bunların başında gelmektedir.
  </para></note><para>
Şimdi ne yapacağız? Elbette bu sorunun üstesinden gelmek için pek çok farklı yöntem mevcut. Ancak biz <filename>trq.kmap.gz</filename> dosyası içerisinden include satırını ve dosya ismini değiştirmek yerine sadece uzun olan dosyayı açarak <emphasis>.gz</emphasis> uzantısından kurtaracağız. Bu sayede dosya ismi 28 karaktere inecek ve <filename>linux-with-alt-and-altgr.inc</filename> şeklini alacaktır. Klavye kodlarını yükleyen programımız dosyanın hem sıkıştırılmış hem de açık haline baktığı için sorun olmayacaktır. Dosyayı önce Linux yüklü sisteminizde <userinput>gunzip</userinput> ile açtıktan sonra disket, ağ veya seri port üzerinden SBC'ye transfer edebilirsiniz.
  </para><para>
Gerekli klavye dosyalarını attıktan sonra şimdi bunları sisteme yükleyebilmek için gerekli olan <userinput>loadkeys</userinput> uygulamasını SBC sistemimiz üzerine taşıyalım. Bunun için öncelikle Linux yüklü sistemimizde aşağıdaki komutla uygulamanın ihtiyaç duyduğu kütüphaneleri öğrenelim:
  </para><para>
<screen>
<prompt>laptop:~/docbook/embedded$ </prompt><userinput>ldd /bin/loadkeys</userinput>
      libcfont.so.0 => /lib/libcfont.so.0 (0x4001b000)
      libctutils.so.0 => /lib/libctutils.so.0 (0x40020000)
      libconsole.so.0 => /lib/libconsole.so.0 (0x40025000)
      libc.so.6 => /lib/libc.so.6 (0x40035000)
      /lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x40000000)
</screen>
  </para><para>
Buradaki <filename>libcfont.so.0</filename>, <filename>libctutils.so.0</filename> ve <filename>libconsole.so.0</filename> kütüphaneleri SBC sistemimiz üzerinde henüz mevcut değil ve bu nedenle onlarında taşınması gerekiyor. Gerekli dosyaları taşıdıktan ve <userinput>loadkeys</userinput> uygulamasının çalıştırma yetkisine sahip olduğundan emin olduktan sonra klavyemiz için gerekli kodların aşağıdaki komutla yüklenmesini sağlayabiliriz:
  </para><para>
<screen>
<prompt>/ # </prompt><userinput>loadkeys /usr/share/keymaps/trq.kmap.gz</userinput>
Loading /usr/share/keymaps/trq.kmap.gz
</screen>
  </para><para>
Artık klavyemiz hazır.
  </para><para>
Klavye ile işimiz bittikten sonra sırada Türkçe konsol yazıtipini ayarlamak var. Ayrıntıya girmeden doğrudan nasıl yapacağınızı anlatmaya çalışacağım, ancak her zaman olduğu gibi kullandığımız uygulamaların kılavuz sayfalarına <emphasis>(manual)</emphasis> vakit buldukça bakmanızda fayda var.
  </para><para>
Öncelikle gerekli font dosyalarını SBC üzerine aktaralım. Bunun için öncelikle SBC üzerinde <filename>/usr/share/consolefonts</filename> ve <filename>/usr/share/consoletrans</filename> dizinlerini oluşturmalıyız. Ardından Linux sisteminizdeki <filename>/usr/share/consoletrans/iso09.acm.gz</filename> ve <filename>/usr/share/consolefonts/iso9-16.psf.gz</filename> dosyalarını SBC üzerindeki aynı dizinlere kopyalayınız.
  </para><para>
Yazıtiplerini sisteme taşıdıktan sonra <userinput>consolechars</userinput> uygulamasını da Linux yüklü sistemimizden taşımalıyız. İhtiyaç duyulan kütüphaneleri kontrol edip uygulamayı SBC üzerindeki <filename>/bin</filename> dizini altına kopyalamalı ve çalıştırma hakları yoksa vermeliyiz. Şimdi <keycode>Alt - F1</keycode> ile girilen birinci sanal konsolda çalışıyorsanız Türkçe fontları görebilmek için aşağıdaki komutları girmelisiniz:
  </para><para>
<screen>
<prompt>/ # </prompt><userinput>consolechars -f iso9-16</userinput>
<prompt>/ # </prompt><userinput>consolechars --tty=/dev/tty1 -f iso9-16 -m iso09</userinput>
<prompt>/ # </prompt><userinput>echo -en "\033(K" > /dev/tty1</userinput>
<prompt>/ # </prompt><userinput>echo -en "\017" > /dev/tty1</userinput>
</screen>
  </para><para>
Şimdi içerisinde bolca Türkçe karakterler olan bir dosyayı ağ, disket veya seri port üzerinden SBC üzerine aktarıp <userinput>cat dosya_adı</userinput> komutuyla karakterlerin ekranda düzgün olarak görünüp görünmediğini test edin. Eğer bir problem varsa işlem adımlarını tekrarlayın (özellikle yukarıdaki komutları dikkatlice yazmayı deneyin).
  </para><para>
Buraya kadar ki adımları sorunsuz bir şekilde atlattı iseniz şimdi de her sistem açılışında otomatik olarak Türkçe ayarlamalarının yapılmasını sağlayalım. Dikkat ederseniz yazıtipi ayarlamalarını sanal konsolların sadece biri için yaptık. Sistemimizdeki ilk dört konsol için Türkçe yazıtipi ayarlamalarının yapılmasını istiyorsak <filename>/etc/config</filename> dosyamızın sonuna aşağıdaki gibi bir satır ekleyelim:
  </para><para>
<screen>
TR_KONSOL="tty1 tty2 tty3 tty4"
</screen>
  </para><para>
Ardından <filename>/etc/init.d/rcS</filename> kabuk programımızın sonuna aşağıdaki satırları ekleyelim:
  </para><para>
<screen>
echo "Klavye ve fontlar ayarlanıyor"
loadkeys /usr/share/keymaps/trq.kmap.gz

consolechars -f iso9-16

for tty in ${TR_KONSOL}
do
    consolechars --tty=/dev/$tty -f iso9-16 -m iso09
    echo -en "\033(K" > /dev/$tty
    echo -en "\017" > /dev/$tty
done
</screen>
  </para><para>
Bu sayede her açılışta ilk dört konsol için gerekli font ayarlamaları da yapılmış olacaktır. Bu sayıyı artırmak veya azaltmak isterseniz tek yapmanız gereken <filename>/etc/config</filename> dosyanızdaki <literal>TR_KONSOL</literal> değişkeninin değerine ilgili <literal>tty</literal> adlarını eklemek veya çıkarmak olacaktır.
  </para><note><para>
Konsolda Türkçe problemi burada anlattıklarımızla çözülüyor olmasına rağmen aynı şeyi BusyBox içerisinden çıkan programlar için söylemek o kadar kolay değil. Busybox ile birlikte gelen kabuk olan <userinput>ash</userinput> ve gene Busybox içinden çıkan <userinput>vi</userinput> editörü ile Türkçe konusunda başarılı olamadım. Ancak Linux yüklü bir sistemden kopyaladığım <userinput>bash</userinput> kabuğu ve <userinput>vi</userinput> metin düzenleyici ile Türkçe karakterleri görüp yazabildim. Eğer aynı işi BusyBox içerisindeki araçlarla yapabilir ve eposta ile beni de bilgilendirirseniz çok sevinirim.
  </para></note>
  </sect1>

  <sect1 id="embedded-tr_xwindow"><title>X Window System Türkçe Desteği</title>
  </sect1>

  </chapter>
</book>
