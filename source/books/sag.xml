<?xml version="1.0" encoding="UTF-8"?>
<!-- ********************************************************************
       books/sag.xml, v0.9, YK, GFDL1.2+
     ******************************************************************** -->
<book xml:id="sag" xmlns="http://docbook.org/ns/docbook"
 xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="tr"
 userlevel="onelevel">
 <?dbhtml dir="../sag"?>
 <info>
  <title>Linux Sistem Yöneticisinin Kılavuzu</title>
  <subtitle>Sürüm 0.9</subtitle>
  <pubdate>Aralık 2022</pubdate>
  <authorgroup>
   <author role="translator">
    <personname>
     <firstname>Yalçın Kolukısa</firstname>
    </personname>
   </author>
   <author role="prep">
    <personname>
     <firstname>Nilgün Belma Bugüner</firstname>
    </personname>
    <affiliation>
     <address>
      <link xl:href="https://github.com/nilgun"/>
     </address>
    </affiliation>
   </author>
   <author>
    <personname>
     <firstname>Lars</firstname>
     <surname>Wirzenius</surname>
    </personname>
   </author>
   <author>
    <personname>
     <firstname>Joanna</firstname>
     <surname>Oja</surname>
    </personname>
   </author>
   <author>
    <personname>
     <firstname>Stephen</firstname>
     <surname>Stafford</surname>
    </personname>
   </author>
   <author>
    <personname>
     <firstname>Alex</firstname>
     <surname>Weeks</surname>
    </personname>
   </author>
  </authorgroup>
  <revhistory><title>Bu çevirinin sürüm bilgileri:</title>
   <revision>
    <revnumber>0.3</revnumber>
    <date>Aralık 2022</date>
    <authorinitials>Nilgün Belma Bugüner</authorinitials>
    <revremark>
     <link xl:href="https://github.com/tLDP/LDP/commits/master/LDP/guide/docbook/sag">tLDP'nin Github deposundan</link> 0.9 sürümüne güncellendi. Disketler ile ilgili bölümler belgeden çıkarıldı.
    </revremark>
   </revision>
   <revision>
    <revnumber>0.2</revnumber>
    <date>Ocak 2004</date>
    <authorinitials>Yalçın Kolukısa</authorinitials>
   </revision>
   <revision>
    <revnumber>0.1</revnumber>
    <date>Ocak 2003</date>
    <authorinitials>Yalçın Kolukısa</authorinitials>
    <revremark>
     Çeviri, Yalçın Kolukısa tarafından .doc biçemli olarak yapılmış, Nilgün Belma Bugüner tarafından gözden geçirilip, çevrilmemiş kısımları tamamlanmış (bazı terimler, konsol çıktıları ve resimler) ve XML biçemine dönüştürülmüştür.
    </revremark>
   </revision>
  </revhistory>
  <revhistory><title>Özgün belgenin sürüm bilgileri:</title>
   <revision>
    <revnumber>0.9</revnumber>
    <date>2005/07/26 14:19:27 UTC</date>
    <authorinitials>Alex Weeks</authorinitials>
   </revision>
   <revision>
    <revnumber>0.8</revnumber>
    <date>2003/12/03 08:58:41 -500</date>
    <authorinitials>
     Stephen Stafford ve Alex Weeks
    </authorinitials>
   </revision>
   <revision>
    <revnumber>0.7</revnumber>
    <date>2001/11/06 11:26:32</date>
    <authorinitials>
     Lars Wirzenius, Joanna Oja ve Stephen Stafford
    </authorinitials>
   </revision>
  </revhistory>
   <copyright>
   <year>1993--1998</year>
   <holder>Lars Wirzenius - Özgün belge</holder>
  </copyright>
   <copyright>
   <year>1998--2001</year>
   <holder>Joanna Oja - Özgün belge</holder>
  </copyright>
   <copyright>
   <year>2001--2003</year>
   <holder>Stephen Stafford - Özgün belge</holder>
  </copyright>
   <copyright>
   <year>2003--2004</year>
   <holder>Stephen Stafford &amp; Alex Weeks - Özgün belge</holder>
  </copyright>
   <copyright>
   <year>2003--2022</year>
   <holder>Alex Weeks - Özgün belge</holder>
  </copyright>
  <copyright>
   <year>2003--2022</year>
   <holder>Yalçın Kolukısa - Türkçe çeviri</holder>
  </copyright>
  <legalnotice><title>Yasal Uyarı</title>
   <para>
    Bu belgeyi, Free Software Foundation tarafından yayınlanmış bulunan
    GNU Özgür Belgeleme Lisansının 1.2 ya da daha sonraki sürümünün
    koşullarına bağlı kalarak kopyalayabilir, dağıtabilir ve/veya
    değiştirebilirsiniz. Bu Lisansın bir kopyasını
    <link linkend="sag-gfdl">GNU Özgür Belgeleme Lisansı</link> başlıklı
    bölümde bulabilirsiniz.
   </para>
  </legalnotice>
  <legalnotice><title>Legal Notice</title>
   <para>Copyright 1993--1998 Lars Wirzenius.</para>
   <para>Copyright 1998--2001 Joanna Oja.</para>
   <para>Copyright 2001 Stephen Stafford.</para>
   <para>Copyright 2001--2003 Stephen Stafford.</para>
   <para>Copyright 2003--Present Stephen Stafford &amp; Alex Weeks.</para>
   <para>Turkish Translation: Copyright 2003-2004 Yalçın Kolukısa.</para>
   <para>Trademarks are owned by their owners.</para>
   <para>
    Permission is granted to copy, distribute and/or modify this
    document under the terms of the GNU Free Documentation License,
    Version 1.1; with no Invariant Sections, with no Front-Cover Texts,
    and with no Back-Cover Texts.  A copy of the license is included in
    the section entitled "GNU Free Documentation License".
   </para>
  </legalnotice>
  <abstract>
   <para>
    Bu belge sistem yönetimi hakkında hemen hemen hiçbir şey bilmeyen ama
    temel komutları bilenler için hazırlanmıştır.
   </para>
  <para>
   Kitabın ingilizce sürümünün kaynak kodu <link xl:href="https://github.com/tLDP/LDP/commits/master/LDP/guide/docbook/sag"/> adresinde bulunabilir. İngilizce sürümün HTML, PS, PDF, vb. biçimleri <link xl:href="https://tldp.org/guides.html"/> adresinden edinilebilir.
  </para>
  </abstract>
 </info>
 <preface xml:id="sag-preface">
  <title>Giriş</title>
  <blockquote>
   <para>
    "Başlangıçta dosyalar boş ve şekilsizdi. Ve Yazarın Parmakları
     klavyenin üzerinde gezindi. Orada kelimeler olmasını istedi ve
     kelimeler oldu."
    </para>
  </blockquote>
  <para>
   Linux Sistem Yöneticisinin Kılavuzu,  sistem yöneticilerinin Linux
   kullanımını anlatmaktadır. Bu belge sistem yönetimi hakkında hemen hemen
   hiçbir şey bilmeyen ama temel yönetim komutlarını ve mantığını bilenler
   için hazırlanmıştır.  Bu kılavuz Linux kurulumunu anlatmaz. Bu tür
   bilgiler Kurulum ve Başlangıç Kılavuzunda bulunmaktadır.  Aşağıda daha
   ayrıntılı bilgi yer almaktadır.
 </para>
  <para>
   Sistem yönetimi,  bir bilgisayar sistemini kararlı ve kullanılabilir tutmak
   için gereken her türlü faaliyeti kapsamaktadır.  Bu : dosyalarının
   yedeklenmesi ve geri yüklenmesini; yeni uygulamaların yüklenmesini; yeni
   kullanıcılar eklenmesi ve eskilerin silinmesini; dosya sistemlerinin
   sağlamlığının sağlanmasını; vb... olayları kapsamaktadır. Eğer bir
   bilgisayarı bir ev olarak kabul edersek; sistem yöneticisini bu evin
   kahyası ve hizmetçisi olarak tanımlayabiliriz. Evin temizlik, bakım-onarım
   ve benzeri bütün işlerinin sorumluluğu sistem yöneticisine aittir.
  </para>
  <para>
   Bu kılavuz birbirinden bağımsız bölümlerden oluşmaktadır. Şayet sadece
   yedekleme ile ilgileniyorsanız, doğrudan o bölüme geçebilirsiniz.
   Bununla beraber bu kılavuzun bir ilk olduğu ve ders notları şeklinde
   hazırlandığı unutulmamalıdır.  Bu kılavuzu ister bölümler bazında ele
   alın, isterseniz bir bütün olarak okuyun.
  </para>
  <para>
   Bu kılavuz tamamen bağımsız bir kullanım için tasarlanmamıştır. Diğer
   Linux belgelerinde de Sistem Yöneticileri için çok faydalı bilgiler
   bulunmaktadır. Sistem yöneticisi bazı özel görev ve yetkileri olan bir
   kullanıcıdır. Başvurabileceğiniz çok sayıda faydalı <link
   xl:href="/man/manpages.html">kılavuz sayfası</link> bulunmaktadır.
   Buralardan komutlar hakkında ayrıntılı bilgiler almanız mümkündür. Şayet
   hangi komuta ihtiyacınız olduğunu bilmiyorsanız <command>apropos</command>
   komutunu kullanabilirsiniz. Bu komut hakkında ayrıntılı bilgi
   Linux kılavuz sayfalarında mevcuttur.
  </para>
  <para>
   Bu kılavuz Linux işletim sistemi için tasarlanmakla birlikte, Unix tabanlı
   diğer işletim sistemleri içinde kullanılabilir.  Unix sistemlerinin genel
   özellikleri ile sistem yöneticiliğinin bazı özellikleri arasında tam bir
   uyum olmadığı için, bu kılavuzun bütün Unix tabanlı işletim sistemlerini
   kapsadığı söylenemez. Linux işletim sistemlerinin doğal gelişiminden
   dolayı, bu kılavuzun  bütün Linux sistemlerini kapsaması da  çok zordur.
 </para>
  <para>
   Linux işletim sistemi dağıtımlarının çok çeşitli olmasından dolayı bu
   kılavuz her hangi bir dağıtıma yönelik yazılmamıştır. Mümkün olan
   durumlarda çeşitli dağıtımlar arasındaki farklılıklar bu kılavuzda
   belirtilmiştir.
  </para>
  <para>
   Bu kılavuz olayları "5 temel adım" gibi sınıflandırmalar yapmadan,
   bütün ayrıntıları ile anlatmaktadır. Bu yüzden bazı bölümler herkesin
   işine yaramayabilir. Bu bölümleri atlamakta kendinizi serbest
   hissedebilirsiniz. Fakat burada yazılmış olan bütün bölümleri okumak,
   doğal olarak,  sistem hakkındaki bilgilerinizi daha ayrıntılı ve kuvvetli
   hale getirecek ve yöneticilik işiniz daha kolaylaşacaktır.
  </para>
  <para>
   Linux bağlantılı bütün geliştirme ve belgelendirme işlerinde olduğu gibi,
   bu kılavuzun yazım işi tamamen gönüllük esasına dayanılarak
   gerçekleştirilmiştir. Bunun eğlenceli olacağını ve olması gerektiğini
   düşündüğüm için bu kılavuzu hazırladım. Bununla birlikte, her gönüllü
   işte olduğu gibi, burada da kısıtlı zaman, bilgi ve deyenim söz konusudur.
   Bu kılavuzun para karşılığı hazırlanmış olanlar kadar profesyonel olduğunu
   düşünmeyin. Benden uyarması.
 </para>
  <para>
   Bir şeyi daha belirtmek isterim ki; gönüllü olarak hazırlanmış son derece
   kapsamlı ve iyi kılavuz sayfaları İnternet üzerinde mevcuttur  ve onlar
   bu kılavuzun konusu dışında bırakılmıştır.  Uygulamalar ve komutlara
   yönelik ayrıntılı anlatımlara bu kılavuzda yer verilmemiştir. Sadece bu
   uygulamaların temel kullanımı ve özellikleri burada anlatılmıştır.
   Ayrıntılı bilgi almak isterseniz kılavuz sayfalarına baş vurmanız
   gerekmektedir. Genellikle bu kılavuzlar Linux belgelendirme
   çalışmalarının bir parçasıdır.
  </para>
  <sect1 xml:id="sag_about">
   <?dbhtml stop-chunking?>
   <title>Bu Kitap Hakkında</title>
   <sect2 xml:id="sag_about-ack">
    <title>Teşekkürler</title>
    <sect3><title>Joanna'nın Teşekkürleri</title>
     <para>
      Lars bu kılavuzun mümkün olan en iyi şekilde çıkartılması için çok
      uğraştı. Bu işin temel sorumlusu olarak, ben de en iyiyi elde etmek ve
      onu korumak isterim. Bu kılavuzu daha iyi hale getirmek için bir
      fikriniz var ise lütfen bana bunu bildirin. Dilbilgisi hataları,
      gerçeklere dayanmayan bilgiler, eklenmesini veya tekrar yazılmasın
      istediğinizi bölümler hakkında lütfen bana yazın.
      Erişim bilgilerimi <link xl:href="http://www.iki.fi/viu/"/> adresinde
      bulabilirsiniz.
     </para>
     <para>
      Bu kitabın yazımına pek çok insan dolaylı ve dolaysız yollardan yardım
      ettiler. LDP gibi muhteşem bir fikre öncülük ettiği için Matt Welsh'e
      özellikle teşekkür etmek isterim. Andy Oram'a o çok değerli destekleri
      için teşekkür ederim. Olaf Kirch'e bu işin yapılabileceğine beni
      inandırdığı için teşekkür ederim. Yggdrasil'deki bu işi ilginç bulan
      bütün insanlara ve Adam Richter'e teşekkür ederim.
     </para>
     <para>
      Stephen Tweedie, H. Peter Anvin, Remy Card, Thedore Ts'o kendi
      çalışmalarını bana ödünç vermiş ve bu kitabın daha kalın ve etkileyici
      bir görünüme kavuşmasını sağlamışlardır. Bu eserler: xia ve ext2
      dosya sistemleri hakkında karşılaştırma, ext2 dosya sisteminin
      tanımı ve araç listeleridir. Bunun için kendilerine minnettarım.
      Eski sürümlerdeki bu eksiklik için özür dilerim.
     </para>
     <para>
      Ek olarak Mark Komarinski'ye 1993'deki materyalleri ve Linux Journal'da
      yer alan sistem yönetimi hakkındaki bilgileri bana ulaştırdığı için
      çok teşekkür ederim. Bu belgeler bilgilendirici ve ilham verici
      olmuştur.
     </para>
     <para>
      Çok sayıda insan tarafından çok faydalı yorumlar gönderildi. Minyatür
      arşivim hepsinin ismini bulmama izin vermiyor ama alfabetik olarak
      bazı isimler şunlardır: Paul Caprioli, Dave Dobson, Ales Cepek, Olaf
      Flebbe, Marie-France Declerfayt ve babası, Stephan Harris, Jyrki Havia,
      Jim Haynes, York Lon, Timothy Andrew Lister, Jim Lynch, Michael J.Micek,
      Jacob Navia, Dan Poirier, Daniel Quinlan, Jouni K. Seppanon, Philippe
      Steindi, G. B. Stotte. Unuttuğum herkesten özür dilerim.
     </para>
    </sect3>
    <sect3>
     <title>Stephen'ın Teşekkürleri</title>
     <para>
      Yeni sorumlu  olarak Lars ve Joanna'ya bu kılavuz üzerine yapmış
      oldukları sıkı çalışmalardan dolayı teşekkür ederim.  Bütün
      kılavuzlarda olduğu gibi bu kılavuzda da bazı hatalar bulunmaktadır.
      Ve zaman zaman bazı bölümler güncelliğini yitirmektedir.  Bu tür
      hatalara rastlarsanız lütfen <email>bagpuss@debian.org</email>
      adresinden bana bildirin. HTML, salt metin ya da her neyse hemen
      bütün biçemlerde eposta kabul ediyorum.
     </para>
     <para>
      Helen Topring Shaw'a bu kılavuzu çok daha iyi bir hale getirdiği
      için sonsuz teşekkürlerimi sunarım.
     </para>
    </sect3>
    <sect3>
     <title>Alex'in Teşekkürleri</title>
     <para>
      Lars'a, Joanna'ya ve Stephen'a bu kılavuz için senelerden beri yaptıkları muhteşem çalışmalar için teşekkür etmek isterim. Umarım başlattıkları işi geregince devam ettirebilirim.
     </para>
     <para>
      "Penceresiz Bir Dünyaya" doğru yapmış olduğum bu yolculukta pek çok
      kişinin yardımlarını gördüm. Özellikle, benim ilk gerçek  Un*x satıcım
      Mike Velasco'naya teşekkür etmek isterim. SCO'nun "pis bir kelime"
      olmasından önce, Mike bana, <uri xl:href="man1-tar"/>,
      <uri xl:href="man1-cpio"/> ve diğer pek çok kılavuz sayfaları
      konusunda oldukça yardımcı olmuştu.
      Teşekkürler Mike! Sen gerçek "Sofa King"sin.
     </para>
    </sect3>
   </sect2>
   <sect2 xml:id="sag_about-conven">
    <title>Yazım Düzeni</title>
    <para>
     Okunurluğu kolaylaştırmak için bu kılavuzda tek tip bir yazım
     düzeni kullanılmıştır. Şayet daha iyi fikirleriniz olursa lütfen
     bildirmekten çekinmeyin.
    </para>
    <para>
     Dizin/Dosya isimleri: <filename>/usr/share/doc/foo</filename>
    </para>
    <para>
     Komutlar ve uygulamalar: <command>fsck</command>
    </para>
    <para>
     URL'ler: <link xl:href="http://www.tldp.org"/>
    </para>
   </sect2>
  </sect1>
 </preface>
 <chapter xml:id="sag_overview">
  <title>Linux Sistemine Genel Bakış</title>
  <preliminary>
   <blockquote>
    <para>
     "Oku! Kalemle öğreten, insana bilmediğini bildiren Rabbin, en büyük
     kerem sahibidir." - Kur'an-ı Kerim
    </para>
   </blockquote>
   <para>
    Bu bölüm Linux işletim sistemi hakkında genel bir bilgi vermektedir.
    Öncelikle  işletim sistemi tarafından yapılan temel işlevler
    tanımlanmaktadır. Daha sonra fazla ayrıntıya girmeden bu hizmetlerin
    işletilmesini sağlayan uygulamalar anlatılmıştır. Bu bölümün amacı
    sistem hakkında bütünsel bir şekilde bilgi vermektir. Bu sebeple
    her bölüm hakkındaki ayrıntılı bilgi başka yerlerde bulunmaktadır.
   </para>
  </preliminary>
  <sect1 xml:id="sag_overview-parts">
   <title>İşletim sisteminin çeşitli parçaları</title>
   <para>
    Bir Unix işletim sistemi çekirdek ve bazı sistem yazılımlarından
    oluşur. Bazı uygulama yazılımları da vardır. Çekirdek işletim
    sisteminin kalbidir.<footnote>
    <para>
     Aslında bu sık sık karşılaşılan bir hatadır. Pek çok kişi
     çekirdeği işletim sisteminin kendisi sanmaktadır. Bir işletim
     sistemi düzenlenmiş bir çekirdekten daha fazlasını sunmaktadır.
    </para></footnote> Diskteki dosyaların izlerini tutar, uygulamaları
    başlatır ve yürütür, belleği ve çeşitli süreçlerin kaynaklarını düzenler,
    ağdan paketleri alır ve gönderir, vb... Çekirdek kendi başına çok az iş
    yapar, fakat diğer hizmetlerin kullanabileceği araçları sağlar. Ayrıca
    donanımlara doğrudan ulaşan kişileri önleyerek, onları kendi sunduğu
    araçları kullanmaya zorlar. Bu yolla çekirdek, kullanıcıları diğer
    kullanıcılara karşı koruyacak bir yol izler. Çekirdek tarafından sağlanan
    bu araçlar sistem çağrıları üzerinden kullanılır.  Sistem yazılımları
    işletim sisteminin ihtiyacı olan çeşitli hizmetleri yerine getirmek için
    çekirdek tarafından sağlanan bu araçları kullanır.
   </para>
   <para>
    Sistem yazılımları ve diğer bütün uygulamalar kullanıcı kipi  olarak
    adlandırılan 'çekirdeğin en üst bölgesi' olan yerde çalışır.
    Sistem yazılımları ve uygulama yazılımları arasındaki en önemli fark:
    sistem yazılımlarının işletim sisteminin çalışması için gerekli olan
    yazılımlar olması, uygulama yazılımları ise sistemde faydalı ve
    eğlenceli işlerin ( oyun ,vb..) yapılmasını sağlıyor olmasıdır.
    Kelime işlemcisi bir uygulama yazılımıdır. <uri xl:href="man8-mount"/>
    ise bir sistem yazılımıdır. Bunlar arasındaki farklar sadece
    sınıflama işlemleri için önemlidir.
   </para>
   <para>
    İşletim sistemleri bazı derleyicileri ve onların uygun
    kütüphanelerini (Linux altındaki GCC ve C++  kütüphaneleri gibi)
    ihtiva edebilir. Bununla beraber bütün yazılım geliştirme dilleri bir
    işletim sisteminin parçası olmak zorunluluğunda değildir.
    Belgeler ve bazen oyunlar da bir işletim sisteminin parçaları
    olabilir.  Geleneksel olarak işletim sistemleri kurulum teybi
    veya disklerinin içerisindeki uygulamalar olarak tanımlanabilir;
    bu tanım içerisinde Linux'ün durumu pek berrak  değildir. Çünkü
    Linux, bütün dünya üzerinde internet üzerinden yayılmaktadır.
   </para>
  </sect1>
  <sect1 xml:id="sag_overview-kernel-parts">
   <title>Çekirdeğin önemli parçaları</title>
   <para>
    Linux çekirdeğinin çeşitli önemli bölümleri vardır: işlemci ve
    bellek yönetimi, donanım ve dosya sistemleri sürücüleri, ağ yönetimi
    ve çeşitli parçalar. Şekil 3.1 de bunlardan bazıları görünmektedir.
   </para>
   <figure xml:id="kerneloverview" floatstyle="1">
    <title>Linux çekirdeğinin bazı önemli parçaları</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="images/overview-kernel-tr.png"/>
     </imageobject>
    </mediaobject>
   </figure>
   <para>
    Büyük ihtimalle çekirdeğin en önemli parçaları (onlar olmadan hiçbir şey
    çalışmaz) işlemci ve bellek yönetim bölümleridir. Bellek yönetimi,
    bellek modüllerinin alanlarını ve takas alanını, süreçler ile
    çekirdeğin bölümleri ve tampon önbelleği için ayarlar. Süreç yönetimi
    ise süreçleri yaratır, işlemcide etkin olan süreçleri değiştirerek
    çokgörevliliği sağlar.
   </para>
   <para>
    Çekirdeğin en alt seviyesinde, çekirdeğin desteklediği donanımlar
    için gerekli olan sürücüler bulunmaktadır. Dünyada çok çeşitli donanım
    bulunmasından dolayı, donamın sürücüleri de çok büyük bir
    çeşitlilik göstermektedir. Donanımların, yazılımlar tarafından
    denetlenen parçaları sıklıkla benzerlik göstermektedir. Bu sayede
    aynı işlevleri destekleyen sürücüler arasında bir sınıflama yapmak
    mümkün olmaktadır. Bu sınıflandırmadaki her bir sürücü kendi aygıtını
    yönetmek için gerekli olan yazılımın haricindeki bölümlerde
    çekirdeğin aynı parçasındaki aynı yazılımı kullanır. Örneğin: Bütün
    disk sürücüleri temelde aynı işlevi yerine getirir: sürücüyü
    başlatmak, N sektörünü okumak ve yazmak gibi.
   </para>
   <para>
    Çekirdeğin içinde bulunan benzer özelliklere sahip bazı yazılım
    hizmetleri aynı sınıflar içinde özetlenmiştir. Örneğin  çeşitli ağ
    protokolleri tek bir BSD soket kütüphanesi içinde özetlenmişlerdir.
    Başka bir örnek de sanal dosya sistemi (VFS) katmanıdır ve  kendi
    gerçekleştirdiği dosya sistemi işlevlerini özetler. Her bir dosya
    sistemi türü, her bir dosya sisteminin gerçekleştirmesi gereken
    işlevleri sağlar. Bağımsız işlevler dosya sistemi ile ilişkiye
    girdiği zaman bilgiler VFS üzerinden uygun dosya sistemi sürücüsüne
    gider.
   </para>
  </sect1>
  <sect1 xml:id="sag_overview-services">
   <title>Bir UNIX sisteminde temel hizmetler</title>
   <para>
    Bu bölüm fazla ayrıntıya girmeden bazı önemli Unix hizmetlerini
    anlatmaktadır. Daha sonraki bölümlerde daha ayrıntılı
    açıklanmaktadır.
   </para>
   <sect2><title>init</title>
    <para>
     Bir Unix işletim sistemindeki en önemli hizmet tek başına
     <command>init</command> tarafından sağlanmaktadır. Açılış esnasında
     ilk başlayan ve önyükleme sonrasında son kapanan hizmet
     <command>init</command> hizmetidir.  <command>init</command> açılışta;
     artalan süreçlerinin başlatılması, dosya sisteminin bağlanması ve
     denetlenmesi gibi bazı ufak tefek işlerin yapılmasını sağlar.
    </para>
    <para>
     <command>init</command>'in yaptığı işlerin tam listesi
     <command>init</command>'in açılış kipinde yapılan seçime bağlıdır.
    </para>
    <para>
     <glossterm>Tek kullanıcılı kip</glossterm>: root haricinde hiç
     kimse bağlanamaz ve root, konsolda bir kabuk kullanır.
    </para>
    <para>
     <glossterm>Çok kullanıcılı kip</glossterm>:aynı anda pek çok
     kullanıcının bağlanabildiği kiptir. Linux sistemleri genelde bu
     kipte açılır.
    </para>
    <para>
     Bazı sürümlerde bu iki kip genel konumlar olarak alındıktan sonra
     X kipi de eklenerek bunlar üçlenmiştir. Bunlara <glossterm>çalışma
     seviyeleri</glossterm> (runlevel) denir.
    </para>
    <para>
     Linux 0-9 arasında 10 adet çalışma seviyesine izin verir. Ama
     çoğu dağıtımda bunları bazıları tanımlıdır. Diğerleri kullanılmaz.
    </para>
    <simplelist>
     <member><code>0</code>: sistemi kapatır.</member>
     <member><code>1</code>: tek kullanıcılı kip</member>
     <member><code>2</code>: çok kullanıcılı ancak NFS kapalı</member>
     <member><code>3</code>: çok kullanıcılı kip</member>
     <member><code>5</code>: çok kullanıcılı kip, açılışta X'e geçiş yapılır.</member>
     <member><code>6</code>: sistemi yeniden başlatır.</member>
    </simplelist>
    <para>
     <filename>/etc/inittab</filename> dosyasının içeriği bu seviyeler
     hakkında bilgi içermektedir ve açılışta hangi kipte çalışmaya
     başlanılacağı yine bu dosya içinde tanımlanmıştır. Bu dosya
     sayesinde  dağıtımınızda hangi çalışma seviyelerinin tanımlı
     olduğunu bulabilirsiniz.
    </para>
    <para>
     Normal bir açılışta <command>init</command>, <uri xl:href="man8-agetty"/> sürecinin çalışmasını sağladıktan sonra sistemdeki öksüz
     süreçleri evlat edinir. (Unix işletim sisteminde bütün süreçler
     tek bir ağaç altında olmak zorundadır. Bu yüzden bağımsız
     süreçler <command>init</command>'e bağlanır.)
    </para>
    <para>
     Sistem kapatıldığı zaman <command>init</command>, süreçleri öldürür,
     dosya sistemlerini ayırır, işlemciyi durdurur ve yapılması istenen
     tanımlı diğer işlevleri yerine getirir. Bir Unix işletim sisteminde
     ilk gelen ve en son giden her zaman <command>init</command>'tir.
    </para>
   </sect2>
   <sect2>
    <title>Uçbirimlerden bağlanmak</title>
    <para>
     Seri hatlar üzerinden uçbirimden ve X window oturumu kapalı
     iken konsoldan bağlanmak için <uri xl:href="man8-agetty"/> kullanılır. <command>init</command> her uçbirimden ayrı ayrı
     bağlanabilmek için <uri xl:href="man8-agetty"/> sürecinin bağımsız
     örneklerinin oluşturulmasını sağlar. <uri xl:href="man8-agetty"/>
     kullanıcı isimlerini okur ve parolaları okumak üzere
     <uri xl:href="man1-login"/> uygulamasını çalıştırır. Şayet kullanıcı
     ismi ve parolası doğru ise <uri xl:href="man1-login"/> kullanıcının
     çalışması için bir kabuk açar. Her hangi bir sebepten dolayı kabuk
     kapatılırsa (kullanıcının ayrılması, vb...) veya kullanıcı ismi ile
     parola uyuşmaz ve <uri xl:href="man1-login"/> uygulaması kapatılırsa,
     <command>init</command> bunu fark eder ve yeni bir <uri xl:href="man8-agetty"/> sürecini devreye sokar. Çekirdeğin kullanıcıların sisteme bağlanması ile bir alakası yoktur. Bunlar tamamen sistem yazılımları tarafından düzenlenir.
    </para>
   </sect2>
   <sect2>
    <title>Syslog</title>
    <para>
     Çekirdek ve bir çok sistem yazılımı hata, uyarı ve buna benzer
     pek çok ileti üretir. Bu iletilerin daha sonra (fazla geç olmadan)
     incelenmesi çok önemlidir. Bu nedenle bu iletiler bir dosya içerisine
     yönlendirilmelidir. Bunu <uri xl:href="man3-syslog"/> yapar.
     Şayet istenirse iletilerin içerik ve önemlerine göre ayrı ayrı
     dosyalama yapmak da, bu uygulamanın ayarları sayesinde mümkündür.
     Örneğin; çekirdek iletileri içeriklerinin önemli olmasından dolayı
     ayrı bir dosyaya yönlendirilmekte ve oraya yazılmaktadır.
     Oluşabilecek sorunların çözümü için bu iletiler düzenli olarak
     izlenmelidir.
   </para>
   </sect2>
   <sect2>
    <title>Süreli komut uygulamaları: cron ve at</title>
    <para>
     Sistem yöneticileri ve kullanıcılar sık sık belli komutları düzenli
     olarak kullanmak zorundadır. Örneğin; sistem yöneticisi, geçici
     dosya ve dizinlerin tutulduğu <filename>/tmp</filename> ve
     <filename>/var/tmp</filename>
     dizinlerinin içerisini, disk üzerinde yer açmak -eski dosyalardan
     kurtulmak- çalışması bittikten sonra kendini temizleyemeyen
     dosyalardan kurtulmak amacıyla silmek isteyebilir.
    </para>
    <para>
     <uri xl:href="man8-cron"/> hizmeti bu tür işleri yapar. Her kullanıcı,
     kendi istediği zamanda istediği komutların çalışmasını sağlayacak bir
     <uri xl:href="man5-crontab"/> dosyasına sahip olabilir ve içeriğini
     düzenleyebilir. <uri xl:href="man8-cron"/> bu tanımlanmış komutların
     çalıştırılmasından sorumludur.
    </para>
    <para>
     <command>at</command> hizmeti de <command>cron</command> hizmetine
     benzer, ama aralarında temel bir farklılık vardır. <command>at</command>
     hizmetinde komutlar verildiği anda sadece bir kez çalıştırılır ve daha
     sonra tekrar edilmezler.
    </para>
    <para>
     Daha ayrıntılı bilgi için <uri xl:href="man8-cron"/>, <uri xl:href="man1-crontab"/>, <uri xl:href="man5-crontab"/>, <uri xl:href="man1-at"/> ve <uri xl:href="man8-atd"/> man sayfalarına bakabilirsiniz.
    </para>
   </sect2>
   <sect2>
    <title>Grafik kullanıcı arayüzü</title>
    <para>
     Unix ve Linux işletim sistemleri kullanıcı arayüzlerini çekirdeğe
     dahil etmezler onun yerine, bu arayüzlerin kullanıcı seviyesi
     uygulamalar tarafından yönlendirilmesine izin verir.
    </para>
    <para>
     Bu hem metin hem de grafik arayüzler için geçerlidir. Bu düzen;
     sisteme geniş bir esneklik sağlamasının yanı sıra, kullanıcı
     arayüzlerinin eklenmesinin kolaylığından kaynaklanan, sistemi
     öğrenme zorluğunu da yanında getirmektedir.
    </para>
    <para>
     Linux ile kullanılan bu grafik ortam ilk önceleri X Pencere Sistemi
     olarak adlandırılmıştır. Kısaca X sistemi de denir. X bir kullanıcı
     arayüzü eklemez, sadece kullanıcı ara yüzüne geçiş sağlayan
     araçlardan oluşur.  Bazı popüler pencere yöneticileri şunlardır:
     fvwm, icewm, blackbox ve windowmaker. KDE ve GNOME ise popüler
     masaüstü yöneticileri olarak bilinir.
    </para>
   </sect2>
   <sect2>
    <title>Ağ İşlemleri</title>
    <para>
     Ağ, iki ya da daha fazla sayıda bilgisayarı birbirine bağlayarak,
     onlar arasında iletişim sağlanmasıdır. Bu bağlama ve iletişimin
     sağlanması biraz karmaşık bir olaydır, ama sonuçlar son derece
     faydalı ve kullanışlı olmaktadır.
    </para>
    <para>
     Unix işletim sistemi pek çok ağ özelliğine sahiptir. Pek çok basit
     hizmet (yedekleme, yazıcıya gönderme, dosya sistemleri işlevleri ,vb..)
     ağ üzerinden yapılabilir. Bu özellikler sistem yönetimi
     kolaylaştırmaktadır. Hem merkezi hem de yayılmış bir yönetim
     olanağı sunmasından dolayı; ucuz maliyet ve hatalara karşı
     dayanıklılık imkanlarını sağlamaktadır.
    </para>
    <para>
     Bu kılavuz, network konusunu kısaca anlatmakta, sadece nasıl
     çalıştığını açıklamaktadır. Daha ayrıntılı bilgi için
     Linux Ağ Yöneticisinin Kılavuzu (Linux Network Administrator's
     Guide) isimli kılavuza
     <link xl:href="http://www.tldp.org/LDP/nag2/index.html"/>
     adresinden ulaşabilirsiniz.
    </para>
   </sect2>
   <sect2>
    <title>Ağdan sisteme bağlanma</title>
    <para>
     Ağ bağlantıları, normal kullanıcı bağlantılarından biraz farklıdır.
     Üzerinden bağlanılması mümkün olan çeşitli fiziksel seri bağlantıları
     mevcuttur. Ağ üzerinden bağlanan her kişi için ayrı bir sanal
     ağ bağlantısı mevcuttur ve bu bağlantı sayısı bant genişliğinin
     elverdiği ölçüde çok çeşitli olabilir. Bu yüzden muhtemel her sanal
     bağlantıda bağımsız bir <uri xl:href="man8-agetty"/> çalıştırmak
     mümkün değildir. Bir ağa bağlanmak için çok çeşitli yollar
     mevcuttur; TCP/IP ağlarında, <command>telnet</command> ve
     <command>rlogin</command> gibi temel uygulamlar kullanılabilmektedir.
    </para>
    <para>
     Son zamanlarda <command>ssh</command>  güvenlik gerekçesi ile
     sistem yöneticileri tarafından daha çok tercih edilir olmaktadır.
     Ağ bağlantılarında her bağlantı için bağımsız bir artalan süreci
     mevcuttur (<command>telnet</command> ve <command>rlogin</command>
     ayrı birer artalan sürecine sahiptir). Bir bağlantı istemi
     geldiğinde; bağımsız bir girişim için kendinin bir örneğini
     oluşturur ve bu sırada orjinal örnek diğer girişimleri dinlemeye
     devam eder. Oluşturulan yeni örnek <uri xl:href="man8-agetty"/>
     gibi çalışır.
    </para>
   </sect2>
   <sect2>
    <title>Ağ Dosya Sistemleri</title>
    <para>
     Bir ağ sistemi üzerinden yapılabilecek en faydalı işlerden birisi
     <glossterm>Ağ Dosya Sistemi</glossterm> üzerinden yapılacak dosya
     aktarımları ve dosya paylaşımıdır. Genellikle Sun firması
     tarafından geliştirilmiş olan ağ dosya sistemi <glossterm>Network
     File System</glossterm> (NFS) kullanılmaktadır. Bir ağ dosya sistemi
     ile bir makine üzerinde her hangi bir uygulama tarafından yapılmış
     olan herhangi bir dosya işlemi ağ üzerinden başka bir makineye
     gönderilebilir. Bu çalışan uygulamanın, karşı makinedeki dosyaları,
     sanki kendi çalıştığı makinede bulunan dosyalar olarak görmesinden
     kaynaklanır ve bu sayede bu işlevler yerine getirilir. Bu sayede
     bilgi paylaşımı her hangi bir uygulama değişikliğine gerek kalmadan
     basit bir şekilde sağlanmış olur. Diğer bir popüler dosya paylaşım
     sistemi ise <link xl:href="http://www.samba.org/"/> adresinde
     bulunabilecek olan Samba dosya sistemidir. Bu protokol MS Windows
     makineleri üzerinden dosya ve yazıcı paylaşımına izin verir (Ağdaki
     Komşular üzerinden).
    </para>
   </sect2>
   <sect2>
    <title>Eposta</title>
    <para>
     Bilgisayarlar üzerinden haberleşmede  en popüler yöntem elektronik
     postadır. Elektronik mektup özel uygulamalar aracılığıyla dosyalar
     içine depolanır ve göndermek/almak/okumak için özel uygulamalar
     kullanılır.
    </para>
    <para>
     Bütün kullanıcılar yeni epostalarının depolandığı, özel bir
     biçeme sahip olan <glossterm>gelen postalar kutusu</glossterm>
     olarak adlandırılabilen bir dosyaya sahiptir. Birisi size
     eposta gönderdiği zaman, eposta uygulaması bunu sizin posta kutunuza
     yerleştirir ve gelen mektubu gelen postaların tutulduğu dosyaya ekler.
     Şayet posta kutunuz başka bir makine üzerinde ise posta bu makineye
     gönderilir ve burada saklanır.
    </para>
    <para>
     Posta sistemleri pek çok uygulama ile kullanılabilir. Kullanıcılar
     pek çok çeşitteki uygulamaları kullanırken (Eposta istemcisi - Mail
     User Agent - MUA; örneğin: pine, mutt, elm) postaların yerel ya da
     uzaktaki makinelerin posta kutularına dağıtımını başka bir uygulama
     (Eposta Aktarım Aracısı - Mail Transfer Agent - MTA; örneğin:
     sendmail veya qmail) yapar. Posta kutuları genellikle
     <literal>/var/spool/mail</literal>'de depolanır.
    </para>
   </sect2>
   <sect2>
    <title>Yazdırma</title>
    <para>
     Aynı anda bir yazıcıyı sadece bir tek kullanıcı kullanabilir.
     Yazıcıların paylaşılması oldukça ekonomik bir çözümdür. Bütün yazım
     işleri bir yazılım olan bir <glossterm>yazdırma kuyruğu</glossterm>
     tarafından yönetilir. Burada bütün işler sıraya konur ve sırası gelen
     iş kuyruktan alınıp yazılmak üzere otomatik olarak yazıcıya gönderilir.
     Bu kullanıcının, bütün bu işleri organize etmek için büyük bir çaba
     ve zaman harcamasını önler.
    </para>
    <para>
     Bu yazılım çıktı işlemlerini disk üzerinde ayrı bir dosya haline
     getirir ve bu sayede bir uygulama işleri parçalayarak
     yazıcıya gönderme şansına sahip olur. Böylece uygulama, çıktı işlemi
     bitene kadar beklemek zorunda kalmaz. Bu son derece kullanışlı bir
     olaydır. Çünkü bu sayede birisi bir basım işini bitirmek için,
     diğerinin bütün işlerinin bitmesini beklemek zorunda kalmaz. Kendi
     işinin kuyruk sırası gelince, işleri otomatik olarak işleme konur
     ve yazıcıdan çıktı alınır.
    </para>
   </sect2>
   <sect2>
    <title>Dosya Sisteminin Yerleşim Düzeni</title>
    <para>
     Bir dosya sistemi kök dosya sisteminin  kolları boyunca çeşitli
     bölümlere ayrılır: <filename>/bin, /lib, /etc, /dev</filename> ve
     birkaç benzeri; uygulama ve değişmeyen verilerden oluşan
     <filename>/usr</filename> dosya sistemi; değişen verilerden oluşan <filename>/var</filename> dosya sistemi; ve herkesin kişisel
     dosyalarının bulunduğu <filename>/home</filename> dosya sistemi.
     Donanım yapılandırmasına ve sistem yöneticisinin kararlarına göre
     bu dosya sistemleri farklı olabilir. Hepsi tek bir dosya sistemi
     halinde de olabilir.
    </para>
    <para>
     <xref linkend="sag_dir-tree-overview"/> bölümünde dosya sisteminin
     yerleşim düzeni daha ayrıntılı bir biçimde anlatılmıştır. En ayrıntılı
     bilgi <link xl:href="/fhs/fhs.html">Dosya Sistemi Hiyerarşisi
     Standardı</link>nda bulunabilir.
    </para>
   </sect2>
  </sect1>
 </chapter>
 <chapter xml:id="sag_dir-tree-overview">
  <title>Dizin Yapısına Genel Bakış</title>
  <preliminary>
   <blockquote>
    <para>
     "İki gün sonra, Pooh daldan ayaklarını sarkıtmış bir biçimde orada
     duruyordu, yanında dört çanak bal vardı." (A.A. Milne)
    </para>
   </blockquote>
   <para>
    Bu bölüm; dosya sistemi dizin ağacı standardını göz önüne alarak, Linux
    standart dizin yapısının en önemli parçalarını anlatmaktadır. Çeşitli
    amaçlar ile dizin yapısını farklı dosya sistemlerine bölebilirsiniz.
    Bu Linux'ün esnek yapısından kaynaklanmaktadır.  Aynı disk üzerinde
    çeşitli dosya sistemleri olabilir. Bütün Linux dağıtımlarında bu mümkün
    olmayabilir. Ama burada genel bir bilgi verilmeye çalışılmaktadır.
   </para>
  </preliminary>
  <sect1 xml:id="sag_dir-tree-overview_bg">
   <title>Arkaplan</title>
   <para>
    Bu bölüm Dosyasistemi Hiyerarşisi Standardının
    (<link xl:href="http://www.pathname.com/fhs/">Filesystem Hierarchy Standart -
    FHS</link>) 2.1 sürümü üzerinden, Linux dizin yapısının nasıl
    organize edildiğini anlatmaktadır.  Standardizasyon, Linux işletim
    sistemleri için yazılım hazırlanmasını ve uyarlanabilmesini daha
    kolaylaştırır,  her şey belli bir standart içinde olduğundan sistem
    yönetiminde pek çok kolaylıklar sağlar. Bu standardizasyon için her
    hangi bir otorite tarafından yapılan bir baskı söz konusu değildir,
    ama pek çok Linux dağıtımı bu standardizasyonu desteklemektedir. Çok
    önemli ve geçerli sebepler olmadıkça FHS'yi bırakmak hiç de akıllıca
    bir fikir değildir. FHS, Unix gelenek ve göreneklerini izleyerek
    diğer Unix sürümleri ile Linux arasında bir uyum ve köprü vazifesi
    görmektedir.
   </para>
   <para>
    Bu bölümde FHS ayrıntılı bir biçimde anlatılmamıştır. Sistem
    yöneticilerinin FHS'i anlayabilmeleri için FHS ile ilgili kılavuzu
    tamamen okuması daha yararlı olur.
   </para>
   <para>
    Bu bölümde bütün dosyalar ayrıntılı bir biçimde anlatılmamış,
    sadece genel bir bakış açısı kazandırmak amacıyla dosya sistemleri
    konusu temelinde genel bir anlatım yapılmıştır. Bununla beraber bu
    kılavuz içinde veya diğer kılavuz sayfalarında burada anlatılan
    dosyalar hakkında daha geniş bilgi bulmak mümkündür.
   </para>
   <para>
    Dizin ağacının tamamı çeşitli görevleri yerine getirmek, sistem
    yedeklerini daha kolay almak veya disk üst limitleri nedeniyle;
    kendi diski ya da bağımsız diskler üzerinde çeşitli küçük parçalara
    ayrılmış olabilir.  Ana parçalar: kök (<filename>/</filename>),
    <filename>/usr</filename>, <filename>/var</filename>, ve
    <filename>/home</filename> dosya sistemleridir (Bakınız:
    <xref linkend="sag_dir-tree-overview_bg-fstree"/>).  Her bölüm farklı
    bir amaca hizmet etmektedir. Dizin yapısı bir Linux makinesinin
    ağ üzerinde daha hızlı ve daha verimli çalışmasını sağlamak amacıyla
    yapılır.
   </para>
   <figure xml:id="sag_dir-tree-overview_bg-fstree" floatstyle="1">
    <title>Bir Unix dizin ağacının yapısı</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="images/fstree-tr.gif"/>
     </imageobject>
     <caption>
      Kesikli çizgiler disk bölümlerinin sınırlarını belirtir.
     </caption>
    </mediaobject>
   </figure>
   <para>
    Dizin ağacının farklı parçalarının rolleri aşağıda açıklanmıştır.
   </para>
   <itemizedlist>
    <listitem>
     <para>
      Kök dosya sisteminin kendine özgü bir yapısı vardır. Genellikle
      yerel sabit disk üzerinde olabileceği gibi ram diskte veya ağ
      tarafından da yönetilebilir. Kök dosya sistemi, sistemin açılıp,
      diğer dosya sistemlerinin bu sisteme bağlanabilir bir hale
      getirilmesi için gereklidir. Kök dosya sistemi tek kullanıcılı
      bir makine için yeterli olacaktır. Ayrıca bozulan bir sistemi
      tamir etmek için ve kaybolan yedeklenmiş dosyaların geri
      getirilmesini sağlayan araçlara da sahiptir.
     </para>
    </listitem>
    <listitem>
     <para>
      <filename>/usr</filename> dosya sistemi, bütün kütüphaneleri,
      komutları, normal işlemler sırasında değişmeyen dosyaları ve
      kılavuz sayfalarını içerir. <filename>/usr</filename> dosya
      sistemindeki hiçbir dosya her hangi bir makine için özelleştirilmez.
      Hepsi normal kullanım amacına yönelik hazırlanmış dosyalardır.
      Bu sayede buradaki dosyalar ağ üzerinden paylaşılabilir. Bu sayede
      sabit disklerden önemli ölçüde  yer kazanmak mümkün olur. Bu da çok
      büyük bir tasarruf sağlar. Bir uygulamanın güncellenmesinde sadece
      ana <filename>/usr</filename> değiştirilir. Bu da
      <filename>/usr</filename>'yi ağ sistemine bağlamayı oldukça
      kolaylaştırır. Dosya sistemi yerel bir disk üzerinde olsa bile
      sadece okunabilir şekilde ayarlanması daha uygun olur. Bu sayede
      herhangi bir çökme durumunda dosyaların hasar görme ihtimalini
      azaltmış oluruz.
     </para>
    </listitem>
    <listitem>
     <para>
      <filename>/var</filename> dosya sistemi sürekli değişen
      dosyaları barındırır. Epostalar, iletiler, spool dizinleri
      (news, printer, vb..), düzenlenmiş kılavuz sayfaları ve temp
      dosyaları bu dosya sisteminin içindedir. Geleneksel olarak
      <filename>/var</filename> dizininin altındaki her şey
      <filename>/usr</filename> dizini altında bir yerlerde mutlaka
      vardır. Bu da <filename>/usr</filename> dosya sisteminin
      salt okunur yapılmasına olanak verir.
    </para>
    </listitem>
    <listitem>
     <para>
      <filename>/home</filename> dosya sistemi kullanıcıların ev
      dizinlerini yani sistemde bulunan bütün gerçek verileri ihtiva
      eder. Ev dizinlerini çeşitli parçalara ayırmak yedekleme açısından
      son derece faydalı olabilir. Nede olsa bütün dizinler aynı hızla
      değişmiyor. Büyük <filename>/home</filename> dizinlerinin;
      <filename>/home/staff</filename>, <filename>/home/student</filename>
      gibi parçalara ayrılması  daha akıllıca olacaktır.
     </para>
    </listitem>
   </itemizedlist>
   <para>
    Bununla beraber yukarıda dosya sistemi olarak adlandırılan
    bölümlerin her birinin ayrı birer dosya sistemi olması gerekmemektedir.
    Bütün bunlar tek bir dosya sistemi altında kolaylıkla tutulabilir.
    Özellikle tek kullanıcılı basit sistemlerde.  Ayrıca sabit diskin
    yapısına ve büyüklüğüne göre çeşitli dosya sistemleri kullanılabilir.
   </para>
   <para>
    Unix  dosya sistemi yapısı bütün dosyaları amaçlarına göre gruplara
    ayırır. Bütün komutlar bir  yerde, bütün veriler başka bir yerde,
    bütün belgeler üçüncü bir yerde gibi. Diğer bir olasılık ise
    dosyaları ait oldukları uygulamalara göre sınıflamaktır: bütün emacs
    dosyaları bir yerde, TeX dosyaları başka bir yerde gibi. Daha sonra
    paylaşılan dosyaların bulunmasında bir sorun ortaya çıkmaktadır.
    Kılavuz sayfalarının hepsini bulan bir uygulama yapmak ve dosyaları
    paylaştırmak tam bir kabusa dönmektedir.
   </para>
  </sect1>
  <sect1 xml:id="sag_dir-tree-overview_rootfs">
   <title>Kök Dosya Sistemi</title>
   <para>
    Kök dosya sistemi çok önemli ve nadiren değişen bilgileri içerdiği
    için, bozulma riskine karşın küçük tutulmalıdır. Bozulmuş bir kök
    dosya sistemi, bütün sistemin çökmesi anlamına gelir ki bu da oldukça
    büyük bir risktir.
   </para>
   <para>
    Kök dizini genellikle <filename>boot.image(vmlinuz)</filename> dosyası
    haricinde başka bir dosya içermez ve sadece dizinleri ihtiva eder:
   </para>
   <glosslist>
    <glossentry>
     <glossterm>
      <filename>/bin</filename>
     </glossterm>
     <glossdef>
      <para>
       Açılış sonrası normal kullanıcılar tarafından kullanılacak
       komutları içerir.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <filename>/sbin</filename>
     </glossterm>
     <glossdef>
      <para>
       <filename>/bin</filename> dizinine benzer ama buradaki
       komutlar, normal kullanıcıların kullanabilmesi için ayrıca
       tanımlanmadıkça sadece root kullanıcı içindir.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <filename>/etc</filename>
     </glossterm>
     <glossdef>
      <para>
       Makineye özel yapılandırma dosyaları bulunur.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <filename>/root</filename>
     </glossterm>
     <glossdef>
      <para>
       root kullanıcısı için ev dizini. Diğer kullanıcılar
       genellikle buraya erişemezler.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <filename>/lib</filename>
     </glossterm>
     <glossdef>
      <para>
       Kök dosya sistemindeki uygulamalar tarafından ihtiyaç duyulan
       paylaşımlı kütüphaneler.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <filename>/lib/modules</filename>
     </glossterm>
     <glossdef>
      <para>
       Genellikle sistemin açılışı sırasında sorunların önlenmesi
       için ihtiyaç duyulan yüklenebilir çekirdek modüllerini içerir.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <filename>/dev</filename>
     </glossterm>
     <glossdef>
      <para>
       Aygıt dosyaları bulunur. Bazı çok kullanılan aygıt dosyaları
       <xref linkend="sag_device-list"/> bölümünde incelenmiştir.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <filename>/tmp</filename>
     </glossterm>
     <glossdef>
      <para>
       Geçici dosyalar bulunur. Açılış sonrası çalışan uygulamalar
       genelde daha fazla yer olmasından dolayı <filename>/var/tmp</filename>
       dizinini kullanır. Sıklıkla <filename>/tmp</filename>
       dizininden <filename>/var/tmp</filename> dizinine sembolik
       bir bağ verilir.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <filename>/boot</filename>
     </glossterm>
     <glossdef>
      <para>
       Grub ve benzeri uygulamaların dosyaları burada bulunur. Genellikle
       önyükleme kaydının dosyası kök dizin yerine burada saklanır. Eğer
       birden çok çekirdek imgesi sistemde mevcut ise bu dizin çok fazla
       büyür. Bu nedenle, böyle durumlarda ayrı bir dosya sistemi
       açmak daha iyi olur. Veya <filename>/boot</filename> dizini
       disk üzerinde ilk 1024 silindir içinde olduğundan emin olmak
       için ayrı bir dosya sistemi açılabilir.  Daha fazla bilgi için
       <command>grub</command> kılavuz sayfasına bakınız.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <filename>/mnt</filename>
     </glossterm>
     <glossdef>
      <para>
       Sistem yöneticileri tarafından geçici dosya sistemi bağlama
       işlemlerinin yapıldığı yerdir. Dosya sistemi bağlama işlemleri
       bu dizine yönlendirilir.  Bazı durumlarda bu dizin de alt
       dizinlere ayrılabilir. Msdos ve ext2 dosya sistemlerine ait
       aygıtları ayrı ayrı bağlamak için ayrım yapılabilir. Bazı
       dağıtımlarda <filename>/mnt/cdrom</filename> ve
       <filename>/mnt/floppy</filename> dizinleri ön tanımlı olarak
       gelir.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <filename>/proc</filename>, <filename>/usr</filename>,
      <filename>/var</filename>, <filename>/home</filename>
     </glossterm>
     <glossdef>
      <para>
       Diğer dosya sistemleri için bağlama noktalarıdır.
       <footnote><para><filename>/proc</filename> dizini gerçekte
       disk üzerinde bulunmaz. <filename>/proc</filename> hakkında
       <xref linkend="sag_dir-tree-overview_procfs"/> bölümünde daha ayrıntılı bilgi verilmiştir.</para></footnote>
      </para>
     </glossdef>
    </glossentry>
   </glosslist>
  </sect1>
  <sect1 xml:id="sag_dir-tree-overview_etcdir">
   <title><filename>/etc</filename> dizini</title>
   <para>
    <filename>/etc</filename> dizini pek çok dosyayı ihtiva eder.
    Bazıları aşağıda tanımlanmıştır. Diğerlerinin hangi uygulamalara
    ait olduğuna siz karar vermeli ve onlara ait kılavuz sayfalarını
    okumalısınız. Ağ ile ilgili pek çok yapılandırma dosyası bu
    dizin altında bulunmaktadır.  Bunlar Ağ Yöneticilerinin Kılavuzunda
    (<link xl:href="http://www.linux.doc.org/LDP/nag2/index.html">Network Administrator's Guide</link>) ayrıntılı bir biçimde
    anlatılmaktadır.
   </para>
   <glosslist>
    <glossentry>
     <glossterm>
      <filename>/etc/rc</filename>, <filename>/etc/rc.d</filename>,
      <filename>/etc/rc?.d</filename>
     </glossterm>
     <glossdef>
      <para>
       Açılışta veya çalışma seviyesi değiştiği zaman çalışacak
       betikler ve betik dizinleri burada bulunur.
       <xref linkend="sag_init"/> bölümünde daha ayrıntılı bilgi
       bulabilirsiniz.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <filename>/etc/passwd</filename>
     </glossterm>
     <glossdef>
      <para>
       Her kullanıcı hakkında ayrıntılı bilgilerin bulunduğu,
       kullanıcı veritabanı olarak da düşünebileceğimiz yerdir.
       Burada kullanıcıların gerçek ismi, kullanıcı isimleri,
       şifrelenmiş parolaları, ev dizinleri gibi bilgiler yer
       almaktadır. Dosya biçemi hakkında ayrıntılı bilgi almak
       için <uri xl:href="man1-passwd"/> kılavuz sayfasına bakınız.
       Bu günlerde şifrelenmiş parolalar  genel olarak
       <filename>/etc/shadow</filename> dosyasında saklanmaktadır.
       Bu, kullanıcı hakkında parola hariç bütün bilgilerin
       <uri xl:href="man5-passwd"/>
       dosyası içerisinde saklanmakta olduğu anlamına gelir.
     </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <filename>/etc/fstab</filename>
     </glossterm>
     <glossdef>
      <para>
       Açılış esnasında <command>mount -a</command>
       (<filename>/etc/rc</filename> ya da buna benzer bir başlangıç
       dosyası aracılığı ile)  komutu ile otomatik olarak bağlanılan
       dosya sistemleri hakkında bilgi verir.  Ayrıca  Linux'de
       <command>swapon -a</command>  komutu ile otomatik olarak
       kullanılan takas alanları hakkında bilgi de içerir. Daha fazla
       bilgi için <xref linkend="sag_fs_mount-and-umount"/> bölümüne
       ve <uri xl:href="man8-mount"/> kılavuz sayfasına bakınız.
       Ayrıca <uri xl:href="man5-fstab"/> dosyası için de kendine ait bir
       kılavuz sayfası bulunmaktadır.
     </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <filename>/etc/group</filename>
     </glossterm>
     <glossdef>
      <para>
       <filename>/etc/passwd</filename> dosyasına benzer ama
       kullanıcılar yerine grupları tanımlar. Ayrıntılı bilgi
       <uri xl:href="man5-passwd"/> kılavuz sayfasında bulunabilir.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <filename>/etc/inittab</filename>
     </glossterm>
     <glossdef>
      <para>
       <command>init</command> için yapılandırma dosyasıdır.
       Ayrıntılı bilgi <uri xl:href="man5-inittab"/> kılavuz sayfasında
       bulunabilir.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <filename>/etc/issue</filename>
     </glossterm>
     <glossdef>
      <para>
       Login isteminden önceki <uri xl:href="man8-agetty"/> çıktıları
       burada tutulur. Genellikle sistem yöneticileri tarafından
       hazırlanan açılış ve hoş geldin iletileri yer alır.
       Sistem yöneticisinin isteğine göre düzenlenir.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <filename>/etc/magic</filename>
     </glossterm>
     <glossdef>
      <para>
       <command>file</command> komutu için yapılandırma dosyasıdır.
       Hangi tür dosya biçeminin neye göre saptandığı burada yer
       alır. <uri xl:href="man1-file"/> ve <uri xl:href="man5-magic"/>
       kılavuz sayfalarında ayrıntılı bilgi mevcuttur.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <filename>/etc/motd</filename>
     </glossterm>
     <glossdef>
      <para>
       Her başarılı girişten sonra görüntülenen günün iletisi burada
       bulunur. Kullanıcıları günlük işler hakkında uyarmak amacıyla
       kullanılır.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <filename>/etc/mtab</filename>
     </glossterm>
     <glossdef>
      <para>
       Bağlı dosya sistemlerinin tam listesini verir.
       <filename>/proc/mounts</filename> dosyasına sembolik bağdır.
       <command>mount</command> komutu ile otomatik olarak güncellenir.
       Bağlı dosya sistemlerinin listesine ihtiyaç olduğu zaman kullanılır.
       Örneğin; <uri xl:href="man1-df"/>  komutu gibi.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <filename>/etc/shadow</filename>
     </glossterm>
     <glossdef>
      <para>
       Shadow parola yazılımları kurulu sistemlerdeki shadow parola
       dosyaları burada yer alır.  Shadow parolaları
       <filename>/etc/passwd</filename>'deki şifrelenmiş parolaları
       <filename>/etc/shadow</filename>'a taşır.
       <filename>/etc/shadow</filename> içeriğini root kullanıcıdan başkası
       okuyamaz.  Bu parolaların kırılmasını zorlaştırır.  Şayet elinizdeki
       Linux dağıtımı size bu seçeneği sunuyorsa, ki pek çok dağıtım bu
       seçeneği sunar, bu seçeneğin etkin olması şiddetle tavsiye edilir.
     </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <filename>/etc/login.defs</filename>
     </glossterm>
     <glossdef>
      <para>
       <uri xl:href="man1-login"/> komutu için yapılandırma dosyasıdır.
       <uri xl:href="man5-login.defs"/> kılavuz sayfalarında ayrıntılı
       bilgi mevcuttur.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <filename>/etc/printcap</filename>
     </glossterm>
     <glossdef>
      <para>
       <filename>/etc/termcap</filename>'a benzer ama yazıcı ayarları
       içindir. Daha farklı bir sözdizimi kullanır.
       <link linkend="termcap">Termcap</link> belgesinde ayrıntılı
       bilgi mevcuttur.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <filename>/etc/profile</filename>, <filename>/etc/csh.login</filename>,
      <filename>/etc/csh.cshrc</filename>
     </glossterm>
     <glossdef>
      <para>
       Sisteme giriş ve başlatma sırasında Bourne veya C kabukları
       tarafından yürütülen dosyalardır. Bu sistem yöneticisine,
       bütün kullanıcılar için aynı kuralları koyma şansı verir.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <filename>/etc/securetty</filename>
     </glossterm>
     <glossdef>
      <para>
       Güvenli uçbirimleri ayarlar. Örneğin root kullanıcının hangi
       uçbirimden bağlanacağı gibi. Genel olarak sadece sanal
       uçbirimler listelenir. Böylece ağ veya bir modem üzerinden
       yapılan izinsiz girişlerde kötü niyetli kişilerin süper
       kullanıcı haklarını elde etmesi imkansızlaşır (en kötü
       ihtimal ile çok zorlaşmış olur). Bir ağ üzerinden root
       kullanıcı bağlantısına izin vermeyin.  Normal bir kullanıcı
       gibi bağlanın ve <uri xl:href="man1-su"/> veya
       <uri xl:href="man8-sudo"/> komutlarını root haklarını
       kazanmak için kullanın.
     </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <filename>/etc/shells</filename>
     </glossterm>
     <glossdef>
      <para>
       Güvenli kabukların listesidir. <uri xl:href="man1-chsh"/> komutu
       kullanıcılara bu listede bulunan kabuklar arasından
       istediklerini seçme hakkı verir. Kullanıcı giriş sonrası seçtiği
       kabuğa düşer. <command>ftpd</command>, bir makine için FTP
       hizmeti veren sunucu işlemleri,  bağlanan kullanıcının kabuğunun
       <filename>/etc/shells</filename> içerisinde listelenmiş olup
       olmadığına bağlı olarak bağlantıya izin vermeyebilir.
     </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <filename>/etc/termcap</filename>
     </glossterm>
     <glossdef>
      <para>
       Uçbirim yetenekleri veritabanıdır. Ne çeşit önceleme dizgelerinin
       hangi uçbirimlerce kullanılacağını tanımlar. Dışarıya doğru
       yapılan çıkışların sadece belirli cins uçbirimler üzerinden
       yapılmasını sağlar ve bunu denetler. Pek çok uygulama pek çok
       çeşit uçbirim ile çalışabilir. Daha fazla bilgi için
       <uri xl:href="man5-terminfo"/>,
       <uri xl:href="man3-curs_termcap"/> ve
       <uri xl:href="man3-curs_terminfo"/> kılavuz sayfalarına bakınız.
      </para>
     </glossdef>
    </glossentry>
   </glosslist>
  </sect1>
  <sect1 xml:id="sag_dir-tree-overview_devdir">
   <title><filename>/dev</filename> dizini</title>
   <para>
    <filename>/dev</filename> dizini pek çok çeşit aygıt için aygıt
    giriş/çıkış dosyaları içerir. Ethernet kartı hariç tüm aygıtlar için
    bu dizin altında - sistemde olsun ya da olmasın - bir düğüm vardır.
    Özel bir düzendeki aygıt dosyaları <xref linkend="sag_device-list"/>
    bölümünde açıklanmıştır. Sistem kurulumu sırasında aygıt dosyaları
    yaratılır. Daha sonra ise <filename>/dev/MAKEDEV</filename> betiği ile
    yenileri yapılabilir. Sadece yerel aygıt dosyalarını veya bağlarını
    tanımlamak için sistem yöneticileri tarafından yazılmış olan
    <filename>/dev/MAKEDEV.local</filename> betiği kullanılır. Bu işlem
    standart <command>MAKEDEV</command> betiği ile oluşturulamayan
    aygıt dosyaları ve bağları için yapılır.
   </para>
  </sect1>
  <sect1 xml:id="sag_dir-tree-overview_usrfs">
   <title><literal>/usr</literal> dosya sistemi</title>
   <para>
    Bütün uygulamalar buraya yüklendiği için bu dizin oldukça geniştir.
    <filename>/usr</filename> içindeki bütün dosyalar bir Linux dağıtımı
    ile gelir. Yerel kullanıcılar tarafından yüklenen diğer uygulamalar
    <filename>/usr/local</filename> altına gider. Bu sayede aynı
    dağıtımdan güncelleme veya başka bir dağıtımdan kurulum yapmak
    mümkün olur. Bu olaylar sırasında yerel dosyalarda bir kayıp söz
    konusu olmaz. Ve bütün dosyaları yeniden yüklemek gerekmez.
    <filename>/usr</filename> dosya sisteminin bazı alt dizinleri
    aşağıda belirtilmiştir.
  </para>
   <glosslist>
    <glossentry>
     <glossterm>
      <filename>/usr/X11R6</filename>
     </glossterm>
     <glossdef>
      <para>
       X Pencere Sistemi dosyalarını içerir. X'in yüklenmesi ve
       geliştirilmesi için X dosyaları sisteme entegre değildir.
       <filename>/usr/X11R6</filename> dizinin içeriği
       <filename>/usr</filename> dizininkine benzer.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <filename>/usr/bin</filename>
     </glossterm>
     <glossdef>
      <para>
       Hemen hemen bütün kullanıcı komutları burada yer alır. Bazı
       komutlar <filename>/bin</filename> veya
       <filename>/usr/local/bin</filename> altındadır.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <filename>/usr/sbin</filename>
     </glossterm>
     <glossdef>
      <para>
       Kök dosya sisteminde ihtiyaç duyulmayan sistem yöneticisi
       komutları burada bulunur. Örneğin pek çok sunucu burada bulunur.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <filename>/usr/share/man</filename>, <filename>/usr/share/info</filename>, <filename>/usr/share/doc</filename>
     </glossterm>
     <glossdef>
      <para>
       Kılavuz sayfaları, GNU bilgi sayfaları, SSS ve çeşitli diğer
       belgeler.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <filename>/usr/include</filename>
     </glossterm>
     <glossdef>
      <para>
       C dilinin başlık dosyaları bulunur. Geleneksel olarak
       <filename>/usr/lib</filename> altında olması gerekirken, ezici
       bir çoğunluk bu ismi desteklemektedir.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <filename>/usr/lib</filename>
     </glossterm>
     <glossdef>
      <para>
       Uygulamalar ve alt sistemler için değişmeyen veri dosyaları
       burada bulunur. <filename>lib</filename> kısaltması library
       (kütüphane) den gelir. Genel yazılım kütüphaneleri buradadır.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <filename>/usr/local</filename>
     </glossterm>
     <glossdef>
      <para>
       Yerel kullanıcılar tarafından yüklenmiş uygulamalar burada
       bulunur. Dağıtımlar buraya hiçbir şey yüklemez. Burası
       tamamen yerel yöneticinin kullanımına tahsis edilmiştir.
       Herhangi bir güncelleme veya yükseltme durumunda buradaki
       uygulamalar üzerine kesinlikle hiçbir şey yazılmayacaktır.
      </para>
     </glossdef>
    </glossentry>
   </glosslist>
  </sect1>
  <sect1 xml:id="sag_dir-tree-overview_varfs">
   <title><literal>/var</literal> dosya sistemi</title>
   <para>
    Sürekli değişen sistem bilgileri burada saklanır. Her sistem için
    özeldir. İstisnalar dışında diğer sistemler ile paylaşılmaz.
   </para>
   <glosslist>
    <glossentry>
     <glossterm>
      <filename>/var/cache/man</filename>
     </glossterm>
     <glossdef>
      <para>
       İsteğe göre düzenlenmiş kılavuz sayfalar için önbellekleme alanı.
       Bazı kılavuz sayfaları ön-biçemli gelebilir. Bunlar
       <filename>/usr/share/man/cat*</filename> dizinlerinde
       bulunabilir, biçemlendikten sonra <filename>/var/cache/man</filename>
       altında saklanır. Genellikle kılavuz sayfaları
       <filename>/usr/share/man/man?/</filename> (? = kılavuz
       sayfalarının bölüm numarası - bilgi için man7 dizininde
       bulunan <command>man</command> kılavuz sayfasına bakınız)
       altında depolanır.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <filename>/var/games</filename>
     </glossterm>
     <glossdef>
      <para>
       <filename>/usr</filename> altındaki oyunlara ait her türlü
       bilgi burada saklanır. Böylece <filename>/usr</filename>
       ile salt okunur bağlantı sağlanır.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <filename>/var/lib</filename>
     </glossterm>
     <glossdef>
      <para>
       Sistemin normal çalışması esnasında değişen dosyalar ve
       bilgiler burada tutulur.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <filename>/var/local</filename>
     </glossterm>
     <glossdef>
      <para>
       <filename>/usr/local</filename> altında kurulmuş çeşitli
       uygulamalara ait bilgiler burada bulunur (Örneğin; sistem
       yöneticileri tarafından kurulmuş uygulamalar). Şayet ayarlanmış veya
       yönlendirilmiş iseler yerel olarak kurulmuş bile olsalar
       bu uygulamalar, <filename>/var</filename> dizini altındaki
       diğer bölgeleri de kullanır.
     </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <filename>/var/lock</filename>
     </glossterm>
     <glossdef>
      <para>
       Kilit (lock) dosyaları. Pek çok süreç belirli aygıt ya da
       dosyaları kullandıklarını göstermek için
       <filename>/var/lock</filename> dizini altında bir kilit
       dosyası oluşturur. Diğer süreçler buraya dikkat eder ve
       böylece aygıt ya da dosya çakışması olması önlenir.
     </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <filename>/var/log</filename>
     </glossterm>
     <glossdef>
      <para>
       Sistem yöneticisini ilgilendiren günlük kayıtları burada tutulur.
       Syslog (tüm çekirdek ve sistem yazılımlarının iletileri
       <filename>/var/log/messages</filename> dosyasında saklanır) ve
       <uri xl:href="man1-login"/> (sisteme kullanıcı giriş ve çıkışları
       <filename>/var/log/wtmp</filename> dosyasında saklanır)
       uygulamalarının kayıtları burada tutulur.
     </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <filename>/var/mail</filename>
     </glossterm>
     <glossdef>
      <para>
       FHS tarafından onaylanan, kullanıcı eposta kutularının bulunduğu
       dosyalardır. Bazı dağıtımlarda <filename>/var/spool/mail</filename>
       içinde tutulur.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <filename>/var/run</filename>
     </glossterm>
     <glossdef>
      <para>
       Bir sonraki açılışa kadar geçerli olan sistem hakkında bilgi
       içeren dosyalar burada tutulur.  Örneğin
       <filename>/var/run/utmp</filename> sisteme bağlı durumdaki
       kişiler hakkında bilgi içerir.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <filename>/var/spool</filename>
     </glossterm>
     <glossdef>
      <para>
       Haberler, yazıcı kuyrukları ve diğer kuyruktaki işler hakkında
       bilgi içeren dizindir. Her biri için ayrı bir alt dizin mevcuttur.
       <filename>/var/spool/news</filename> gibi.. Bazı dağıtımlarda
       eposta kutularını içeren dosyalarda
       <filename>/var/spool/mail</filename> dizini altındadır.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <filename>/var/tmp</filename>
     </glossterm>
     <glossdef>
      <para>
       Çok büyük veya çok uzun bir zamandır var olan <filename>/tmp</filename>
       dizini içerisindeki geçici dosyaları içerir. Sistem yöneticisi
       <filename>/var/tmp</filename> içerisinde çok eski dosyalara
       müsaade etmeyebilir.
      </para>
     </glossdef>
    </glossentry>
   </glosslist>
 </sect1>
 <sect1 xml:id="sag_dir-tree-overview_procfs">
  <title><literal>/proc</literal> dosya sistemi</title>
  <para>
       Sanal dosya sistemidir. Disk üzerinde yer kaplamaz. Çekirdek
       <filename>/proc</filename> dizinini  bellekte yaratır.
       Sistem hakkında bilgiler burada saklanır (süreçler ve isimleri ,vb..).
       <filename>/proc</filename> dosya sistemi ayrıntılı olarak kılavuz
       sayfasında açıklanmıştır. Bazı çok önemli dosya ve dizinler:
     </para>
   <glosslist>
    <glossentry>
     <glossterm>
      <filename>/proc/1</filename>
     </glossterm>
     <glossdef>
      <para>
             1 numaralı süreç hakkında bilgi içerir. Her sürecin kendi
             numarası ile anılan bir dizini vardır.
           </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <filename>/proc/cpuinfo</filename>
     </glossterm>
     <glossdef>
      <para>
             İşlemci hakkında türü, üreticisi, modeli gibi bilgileri içerir.
           </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <filename>/proc/devices</filename>
     </glossterm>
     <glossdef>
      <para>
             Çekirdekte o an için çalışan aygıt sürücülerinin listesini verir.
           </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <filename>/proc/dma</filename>
     </glossterm>
     <glossdef>
      <para>
             O anda kullanılan DMA kanallarını gösterir.
           </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <filename>/proc/filesystems</filename>
     </glossterm>
     <glossdef>
      <para>
             Çekirdekte tanımlanmış olan dosya sistemlerini gösterir.
           </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <filename>/proc/interrupts</filename>
     </glossterm>
     <glossdef>
      <para>
             Hangi kesmelerin kullanıldığını ve hangilerinin halihazırda
             beklediğini gösterir.
           </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <filename>/proc/ioports</filename>
     </glossterm>
     <glossdef>
      <para>
             Hangi giriş/çıkış portlarının kullanıldığını gösterir.
           </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <filename>/proc/kcore</filename>
     </glossterm>
     <glossdef>
      <para>
       Sistemdeki fiziksel belleğin bir görüntüsü. Fiziksel bellek
       ile aynı boyuttadır. Çalışan uygulamalar için oluşturulmuştur
       ama gerçek bir bellek değildir. Siz herhangi bir yere
       kopyalanmadıkça  <filename>/proc</filename> altındaki bilgiler
       diske yazılmaz.
     </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <filename>/proc/kmsg</filename>
     </glossterm>
     <glossdef>
      <para>
       Çekirdek iletileri. Ayrıca <command>syslog</command>'a yollanır.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <filename>/proc/ksyms</filename>
     </glossterm>
     <glossdef>
      <para>
       Çekirdek sembol tablosu.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <filename>/proc/loadavg</filename>
     </glossterm>
     <glossdef>
      <para>
       Sistemin ortalama yükü. Üç adet anlamsız gösterge sistemin
       o an ne kadar çalıştığını gösterir.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <filename>/proc/meminfo</filename>
     </glossterm>
     <glossdef>
      <para>
       Hem fiziksel bellek hem de takas hakkında bilgi verir.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <filename>/proc/modules</filename>
     </glossterm>
     <glossdef>
      <para>
       O an yüklü çekirdek modüllerini gösterir.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <filename>/proc/net</filename>
     </glossterm>
     <glossdef>
      <para>
       Ağ protokolleri hakkında durum bilgisi verir.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <filename>/proc/self</filename>
     </glossterm>
     <glossdef>
      <para>
       O an <filename>/proc</filename>'a göz atan uygulamaların süreç
       dizinine sembolik bağ. Eğer iki süreç söz konusu ise ikisi
       de ayrı bağ alır. Böylece uygulamaların süreç dizinlerine
       ulaşmaları daha uygun hale getirilmiş olur.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <filename>/proc/stat</filename>
     </glossterm>
     <glossdef>
      <para>
       Sistem hakkında çeşitli istatistikler bulunur. Örneğin sistem
       açılışından beri meydana gelen hataların sayfa sayısı gibi.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <filename>/proc/uptime</filename>
     </glossterm>
     <glossdef>
      <para>
       Sistemin açık kaldığı süreyi verir.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <filename>/proc/version</filename>
     </glossterm>
     <glossdef>
      <para>
       Çekirdek sürüm bilgilerini içerir.
      </para>
     </glossdef>
    </glossentry>
   </glosslist>
   <para>
    Yukarıda adı geçen dosyaların pek çoğu kolayca okunabilecek şekilde
    metin dosyaları halindedir. Fakat bazılarının düzenlenmesi gerekebilir.
    Bunları okumaktansa içeriklerini gösteren komutları kullanmak daha
    kolaydır.  Örneğin <command>free</command> <filename>/proc/meminfo</filename>'yu okur ve bayt olan değerleri kB'a çevirerek gösterir
    (ve biraz daha fazla bilgi verir).
   </para>
  </sect1>
 </chapter>
 <chapter xml:id="sag_device-list">
  <title>Aygıt Dosyaları</title>
  <preliminary>
   <para>
    Bu bölümde aygıt dosyalarının ne olduğu ve nasıl yaratılacağı temel
    bilgiler eşliğinde anlatılmaktadır.  Ayrıca daha genel aygıt
    dosyaları listelenmiştir. Şayet Linux çekirdeğinin kaynak kodlarına
    sahipseniz genel olarak aygıt listelerini
    <filename>/usr/src/linux/Documentation/devices.txt</filename>
    içerisinde bulabilirsiniz.
   </para>
   </preliminary>
  <sect1 xml:id="sag_device-list_makedev">
   <title><literal>MAKEDEV</literal> Betiği</title>
   <para>
    Aygıt dosyalarının pek çoğu sistem yüklemesi sırasında kurulmuş
    ve kullanıma hazır bir biçimde beklemektedir. Şayet sisteminizde
    olmayan bir aygıt dosyası yaratmak zorunda kalırsanız <command>MAKEDEV</command>
    betiğini kullanmalısınız.  Bu betik <filename>/dev/MAKEDEV</filename>
    olarak bulunabir. Fakat <filename>/sbin/MAKEDEV</filename>'e de
    sembolik bir bağ verilmiş olabilir. Şayet PATH içerisinde
    tanımlanmamışsa, bu betiği kullanabilmek için yolunu PATH içeriğinde
    tanımlamalısınız. Betiğin genel kullanımı şu şekildedir:
   </para>
   <screen>
<prompt>#</prompt><userinput>/dev/MAKEDEV -v ttyS0</userinput>
create ttyS0   c 4 64 root:dialout 0660
</screen>
   <para>
    Burada 4. anadüğüm, 64. altdüğümde sahibi root ve grubu dialout için
    erişim izni 660 olan <filename>/dev/ttyS0</filename> karakter
    aygıtı yaratılmış oldu.
   </para>
   <para>
    <filename>ttyS0</filename> bir seri porttur.  Anadüğüm ve altdüğüm
    numaraları, çekirdek tarafından algılanacak olan numaralardır.
    Çekirdek donanım aygıtlarına numaralar aracılığı ile ulaşır.
    Bizim için bunu yapmak çok zor olduğundan biz dosya isimlerini
    kullanırız.  Erişim izinleri kullanıcı için (root) okuma ve yazma;
    grubu (dialout) için okuma ve yazma şeklindedir. Başka hiçbir
    kimse bu aygıta erişemez.
   </para>
  </sect1>
  <sect1 xml:id="sag_device-list_mknod">
   <title><literal>mknod</literal> komutu</title>
   <para>
    <command>MAKEDEV</command> halihazırda var olmayan aygıt dosyalarını
    yaratmak için kullanılır. Bununla beraber bazı zamanlar
    <command>MAKEDEV</command>  yaratmak istediğiniz aygıta ilişkin
    dosyayı tanımayabilir. Burada <uri xl:href="man1-mknod"/> komutu
    devreye girer. Bu komutu kullanabilmek için anadüğüm ve altdüğüm
    numaralarını bilmek zorundasınız.  Çekirdek içerisindeki
    <filename>devices.txt</filename> dosyası, bu bilgilerin yer aldığı
    temel kaynaktır.
   </para>
   <para>
    Diyelim ki bizim elimizdeki <command>MAKEDEV</command> istediğimiz
    <filename>/dev/ttyS0</filename> aygıt dosyasını nasıl yapacağını
    bilmiyor. Bu durumda <command>mknod</command> komutunu kullanmak
    zorundayız. <filename>devices.txt</filename> dosyasından bakarak
    4. anadüğüm ve 64. altdüğümde bir karakter aygıt yapmamız
    gerektiğini öğreniriz.
   </para>
   <screen>
<prompt>#</prompt> <userinput>mknod /dev/ttyS0 c 4 64</userinput>
<prompt>#</prompt> <userinput>chown root.dialout /dev/ttyS0</userinput>
<prompt>#</prompt> <userinput>chmod 0644 /dev/ttyS0</userinput>
<prompt>#</prompt> <userinput>ls -l /dev/ttyS0</userinput>
crw-rw----   1 root dialout    4,   64 Oct 23 18:23 /dev/ttyS0
</screen>
   <para>
    Gördüğünüz gibi bir dosyayı çok fazla adımda yaratmak durumundayız.
    Bu örnekte gereken süreçleri görebilmekteyiz.  Burada
    <filename>/dev/ttyS0</filename> aygıt dosyasının
    <command>MAKEDEV</command> komutu tarafından yaratılamamış
    olması uç bir örnektir.
   </para>
  </sect1>
  <sect1 xml:id="sag_device-list_list">
   <title>Aygıt Listesi</title>
   <para>
    Aşağıdaki aygıt listesinde çok fazla ayrıntıya girilmemiştir.
    Bu aygıt dosyalarının pek çoğu çekirdekte derlenmiş halde
    bulunmakta ve donanımları doğrudan desteklemektedir. Daha
    fazla ayrıntı için çekirdek belgelerini okuyabilirsiniz.
   </para>
   <para>
    Şayet burada bulunması gerektiğini düşündüğünüz ama burada
    olmayan aygıt dosyaları var ise lütfen bana bildirin.
    Onları da diğer sürümde bu listeye ekleyeceğim.
   </para>
   <glosslist>
    <glossentry>
     <glossterm>
      <filename>/dev/dsp</filename>
     </glossterm>
     <glossdef>
      <para>
       Digital Signal Processor - Sayısal Sinyal İşlemci.
       Ses kartı ile ses üreten yazılım arasındaki arayüz olarak
       tanımlanabilir.  14. anadüğüm, 3. altdüğümde bulunan bir
       karakter aygıtıdır.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <filename>/dev/fb0</filename>
     </glossterm>
     <glossdef>
      <para>
       Birinci karetamponu (framebuffer) aygıtı. Karetamponu grafik
       donanımı ile yazılımı arasındaki soyut bir katmandır.
       Uygulamalar, ne tür grafik donanımı kullandığınızı bilmek
       zorunda kalmadan, sadece açıkça  tanımlanmış ve standart
       haline getirilmiş  olan karetamponu sürücüsünün uygulama
       geliştirme arayüzü (API - Application Programming Interface)
       ile nasıl haberleşeceklerini bilir.  Birinci karetamponu
       29. anadüğüm, 0. altdüğümde bir karakter aygıtıdır.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <filename>/dev/hda</filename>
     </glossterm>
     <glossdef>
      <para>
       <filename>/dev/hda</filename> birincil IDE denetleyicisine bağlı
       ana IDE sürücüdür. Birinci IDE kablosuna bağlı
       <literal>master</literal> olarak ayarlanmış sabit disk olarak da
       tanımlanabilir.  <filename>/dev/hdb</filename> birincil IDE
       denetleyicisine bağlı yardımcı sürücüdür.  <filename>/dev/hdc</filename>
       <filename>/dev/hdd</filename> ise ikincil IDE denetleyicisine
       bağlı ana ve yardımcı IDE sürücüleridir.  Her disk bölümlere
       ayrılmıştır. 1-4 arası bölümler birincil bölümler, 5 ve üzeri
       bölümler ise ek bölüm içindeki mantıksal bölümlerdir.  Bu
       yüzden her bölüm için yapılmış aygıt dosyaları çeşitli
       bölümlerden meydana gelmişlerdir. Örneğin; <filename>/dev/hdc9</filename>
       ikincil IDE denetleyicisine takılmış bir ana IDE sabit diskinin
       ek bölümü içerisindeki bir mantıksal bölümü  işaret eder.
       Ana ve alt düğüm numaraları biraz karmaşıktır. Birincil IDE
       denetleyicisi için bütün bölümler 3. anadüğümdeki blok
       aygıtlarıdır. Ana sürücü <filename>hda</filename> için
       altdüğüm 0, yardımcı sürücü <filename>hdb</filename> için
       altdüğüm 64'tür. Sürücü içindeki her bölümün, bölüm numarası
       bu altdüğüm numarasına eklenir.  Örneğin; <filename>/dev/hdb5</filename>
       için anadüğüm 3,  altdüğüm ise 69 (64+5) dur. İkincil IDE
       sürücüye bağlı sürücünün hesaplamaları da aynı yöntemle
       yapılır. Tek fark  anadüğüm numarası 22 dir.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <filename>/dev/ht0</filename>
     </glossterm>
     <glossdef>
      <para>
       Birinci IDE teyp sürücüdür. Sonraki sürücüler <filename>ht1</filename>,
       <filename>ht2</filename> şeklinde sıralanır. 37. anadüğümdeki
       karakter aygıtlarıdır ve <filename>ht0</filename> için
       altdüğüm 0, <filename>ht1</filename> için 1, <filename>ht2</filename>
       için 2  olarak sıralanır.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <filename>/dev/js0</filename>
     </glossterm>
     <glossdef>
      <para>
       Birinci analog oyun çubuğu. Sonraki oyun çubukları
       <filename>js1</filename>, <filename>js2</filename>,
       <filename>js1</filename>, ... şeklinde sıralanır.
       15. ana düğümdeki karakter aygıtlarıdır.  Analog oyun çubukları
       0. alt düğümden 127. alt düğüme kadar sıralanır. Sayısal
       oyun çubukları ise 128. alt düğümden başlar.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <filename>/dev/lp0</filename>
     </glossterm>
     <glossdef>
      <para>
       Birinci paralel yazıcı aygıtı. Diğer yazıcılar
       <filename>lp1</filename>, <filename>lp2</filename>,
       <filename>lp3</filename>, ... şeklinde sıralanır.
       6. ana düğümdeki karakter aygıtlardır. Alt düğümler 0 dan
       başlar ve her aygıt için ardışık şekilde devam eder.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <filename>/dev/loop0</filename>
     </glossterm>
     <glossdef>
      <para>
       Birinci geridönüş (loopback) aygıttır.  Geridönüş aygıtları
       diskler üzerinde bulunmayan blok aygıtlarındaki dosya
       sistemlerini bağlamak için kullanılır. Şayet bir
       iso9660 CD ROM'u bir CD'yi okumadan bağlamak istiyorsak
       geridönüş aygıtlarını kullanmalıyız.  Bu genellikle
       kullanıcıya açıktır ve  <command>mount</command> komutu
       tarafından kullanılır. <uri xl:href="man8-mount"/>  ve
       <uri xl:href="man8-losetup"/> kılavuz sayfalarına göz atmanız
       bu kavramları anlamak için oldukça faydalı olacaktır.
       Geri dönüş aygıtları 7. ana düğümdeki blok aygıtlarıdır.
       Alt düğümler 0 dan başlar ve ardışık devam eder.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <filename>/dev/md0</filename>
     </glossterm>
     <glossdef>
      <para>
       Birinci meta disk grubu. Meta diskler RAID (Redundant Array
       of Independent Disk - Birleştirilmiş Bağımsız Disk Dizisi)
       aygıtları ile bağlantılıdır. Daha ayrıntılı bilgi için
       LDP'deki (Linux Document Project - Linux Belgelendirme
       Projesi) RAID-HOWTO belgelerine başvurabilirsiniz.
       Meta diskler 6. ana düğümdeki blok aygıtlarıdır. 0. alt düğümden
       başlar ve ardışık devam eder.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <filename>/dev/mixer</filename>
     </glossterm>
     <glossdef>
      <para>
       Bu OSS'nin ( Open Sound Driver - Açık Ses Sürücüsü) bir
       parçasıdır. <link xl:href="http://www.opensound.com/"/> adresindeki
       OSS belgelerinden daha ayrıntılı bilgi edinebilirsiniz.
       14. ana düğüm, 0. alt düğümdeki karakter aygıtıdır.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <filename>/dev/null</filename>
     </glossterm>
     <glossdef>
      <para>
       Gönderilen her verinin bir daha tekrar geri dönmemek üzere yok
       edildiği bir kara deliktir. <filename>/dev/null</filename>'a
       gönderilen her şey görünmez olur. Bu, bir komut çalıştırmak ama
       uçbirimde her hangi bir geri bildirim almamak istediğiniz
       durumlarda faydalı olabilir. 1. ana düğüm, 3. alt düğümdeki bir
       karakter aygıtıdır.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <filename>/dev/psaux</filename>
     </glossterm>
     <glossdef>
      <para>
       PS/2 fare portudur.  10. ana düğüm, 1. alt düğümdeki bir karakter
       aygıtıdır.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <filename>/dev/pda</filename>
     </glossterm>
     <glossdef>
      <para>
       Paralel port IDE diskleri. Dahili IDE denetleyicileri gibi
       isimlendirilir. Blok aygıtlardır ve anadüğüm numarası 45 dir.
       Alltdüğüm numaraları için biraz daha fazla açıklamaya ihtiyaç
       vardır.  İlk aygıt <filename>/dev/pda</filename>'dır ve
       aldüğüm numarası 0 dır. Bölüm numaraları altdüğüm numarasına
       eklenerek  bu aygıttaki bölümler bulunur. Her aygıt 15 bölüm
       ile sınırlandırılmıştır. Dahili IDE aygıtlarında bu 63 dür.
       <filename>/dev/pdb</filename> için aldüğüm numarası 16'da başlar,
       <filename>/dev/pdc</filename> için 32'de, <filename>/dev/pdd</filename>
       için 48'de başlar. Örneğin; <filename>/dev/pdc6</filename> için
       altdüğüm numarası 38 (32+6) dir. Bu düzen her biri 15 bölümlü 4
       paralel disk ile bizi sınırlar.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <filename>/dev/pcd0</filename>
     </glossterm>
     <glossdef>
      <para>
       Paralel port CD ROM sürücüsü.  0'dan başlayarak
       numaralandırılır.  46. anadüğümdeki blok aygıtlarıdır.
       Altdüğümler <filename>/dev/pcd0</filename> için 0 dan başlar
       ve ardışık devam eder (<filename>/dev/pcd1</filename> için 1,
       <filename>/dev/pcd2</filename> için 2, <filename>/dev/pcd3</filename>
       için 3, ...).
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <filename>/dev/pt0</filename>
     </glossterm>
     <glossdef>
      <para>
       Paralel port teyp sürücüsü. Teyplerin bölümleri olmadığı
       için  sadece ardışık biçimde numaralandırılır. Karakter
       aygıtlardır ve anadüğüm numarası 96 dır. Altdüğümi
       <filename>/dev/pt0</filename> için 0, <filename>/dev/pt1</filename>
       için 1, <filename>/dev/pt2</filename> için 2, ... şeklinde
       sıralanır.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <filename>/dev/parport0</filename>
     </glossterm>
     <glossdef>
      <para>
       İşlenmemiş paralel port. Paralel porta bağlanan pek çok aygıt
       kendi sürücülerini kullanır. Bu ise porta doğrudan ulaşmak
       için kullanılan bir aygıttır. Anasüğüm numarası 99 olan karakter
       aygıtıdır. Alltdüğüm numarası 0'dan başlar ve ardışık olarak her
       bir aygıt için birer artarak devam eder.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm><filename>/dev/random</filename> veya <filename>/dev/urandom</filename></glossterm>
     <glossdef>
      <para>
       Bunlar çekirdeğin rasgele sayı üreteçleridir.
       <filename>/dev/random</filename>
       rasgele sayı üreten ve o an için üretilmiş sayıya bakıp
       gelecek sayısı tahmin edilebilen üreteçlere benzemez. Sayı
       üretmek için sistem donanımlarının arabirimlerinin ürettiği
       ganimetler (entropy)<footnote><para>Ç.N.: Burada entropy ile
       ifade edilen şey, farenin ekran koordinatları, diskin okunan
       ya da yazılan sektör numarası, klavyede basılan tuş numarası
       gibi sayılardır. Olay bir oyunda oyuncunun ganimet
       toplamasına benzetilebilir.</para></footnote> kullanır.
       Kullanılacak ganimet kalmadığında daha fazlasının toplanması
       için beklemek zorunda kalır. Bu durumda iken daha fazla sayı
       okunmasına izin vermez.  <filename>/dev/urandom</filename> da
       buna benzer şekilde çalışır. İlk olarak sistem donanımlarının
       ganimetlerini kullanır ama  ganimetler bitince karışık rasgele
       sayı üreten bir formül üzerinden çalışmaya ve sayı vermeye
       devam eder.  Şifrelenmiş çift anahtar üreteçleri gibi çok
       önemli amaçlar için bu sistem biraz  güvensiz görünebilir.
       Şayet güvenlik birinci planda önemli ise
       <filename>/dev/random</filename>'u kullanın, eğer hız önemli
       ise <filename>/dev/urandom</filename>'u kullanın.
       Rasgele sayı üreteçleri ana düğüm numarası 1 olan karakter
       aygıtlarındandır.
       <filename>/dev/random</filename> için alt düğüm numarası 8,
       <filename>/dev/urandom</filename>/dev/urandom için ise  9'dur.
      </para>
     </glossdef>
    </glossentry>
    <glossentry>
     <glossterm>
      <filename>/dev/zero</filename>
     </glossterm>
     <glossdef>
      <para>
       Pek çok sıfır elde etmenin en kolay yoludur. Bu aygıttan her
       okuduğunuzda veri sıfıra dönüşür.  İçeriği önemli olmayan
       sabitlenmiş uzunluktaki bir dosya ile ilgilendiğiniz zamanlarda
       bu aygıt yararlı olabilir. 1. ana düğümün 5. alt düğümündeki
       karakter aygıtıdır.
      </para>
     </glossdef>
    </glossentry>
   </glosslist>
  </sect1>
 </chapter>

 <chapter xml:id="sag_disks">
  <title>Diskler ve Diğer Depolama Ortamları</title>
  <preliminary>
   <blockquote>
    <para>
     "temiz bir diskte sonsuza kadar araştırma yapabilirsiniz."
    </para>
   </blockquote>
   <para>
    Sisteminizi güncellediğinizde veya kurduğunuzda yapmanız gereken
    pek çok iş vardır. Diskiniz üzerinde bilgi depolayabilmek için
    dosya sistemleri yapmalısınız  ve sisteminizin çeşitli bölümleri
    için yer ayırmalısınız.
   </para>
   <para>
    Bu bölümde bütün bu öncelikli adımlar açıklanmaktadır. Genellikle,
    bir kere sistemi ayarladıktan sonra tekrar bu tür işleri yapmak
    zorunda kalmazsınız. Yeni bir disk eklediğinizde veya disk kullanımını
    daha verimli bir hale getirmek istediğinizde bu bölüme tekrar
    dönmelisiniz.
   </para>
   <para>
    Diskleri yönetmek için temel basamaklar şunlardır (bu basamak sıraları
    değişebilir):
   </para>
   <itemizedlist>
    <listitem>
     <para>
      Diski biçemleyin. Bu kullanıma hazırlamak için gereken pek çok
      işlevi yerine getirir. Günümüzde diskler genellikle biçemlenmeye
      ihtiyaç duymazlar.
     </para>
    </listitem>
    <listitem>
     <para>
      Diski bölümleyin. Şayet bir bölümün diğerine karışmasını
      istemiyorsanız disk üzerinde bölümler (partition) oluşturun.
      Aynı disk üzerinde farklı işletim sistemleri kurmak istiyorsanız
      diski mutlaka bölümlemek zorundasınız.  Diğer bir sebep de
      sistem dosyalarının kullanıcı dosyaları ile karışmasını önlemek
      olarak sayılabilir. Ayrıca yedekleme amacı ile de diski bölümlere
      ayırabilirsiniz.
     </para>
    </listitem>
    <listitem>
     <para>
      Her diskte ve her bölümde amacına uygun bir dosya sistemi yaratın.
      Siz bir dosya sistemi yaratmadıkça disk Linux'den hiçbir şey
      anlamayacaktır. Zaten bu durumda diski kullanmanız mümkün değildir.
      Dosya sistemi yaratıldıktan sonra (ext2, fat32, vfat, vb..) disk
      üzerine dosyalar kaydedilebilir.
     </para>
    </listitem>
    <listitem>
     <para>
      İster otomatik, ister el ile değişik dosya sistemlerini tek bir
      çatı altında toplayın. Unutmayın ki el ile  bağlanmış bir dosya
      sistemi mutlaka el ile  ayrılmalıdır.
     </para>
    </listitem>
   </itemizedlist>
   <para>
    <xref linkend="sag_memory-management"/> bölümü
    sanal bellek ve disk üzerindeki önbellek hakkında bilgiler
    içermektedir. Diski kullanırken bu bilgiler çok işinize yarayacaktır.
   </para>
  </preliminary>
  <sect1 xml:id="sag_disks-kinds">
   <title>Aygıtların iki çeşidi</title>
   <para>
    Linux ve Unix işletim sistemleri aygıtları iki şekilde tanır.
    Birinci rasgele erişimli blok aygıtları (diskler gibi), diğeri
    ise karakter aygıtlardır (seri hatlar ve teypler gibi).
    Sistemdeki bazı aygıtlar seri, bazıları rasgele erişimli olabilir.
    Her desteklenen aygıt dosya sisteminde bir aygıt dosyası ile temsil
    edilir. Bir aygıt dosyasına yazdığınız veya okuduğunuz zaman veriler
    temsil edilen aygıttan gelir ve aynı aygıta gider. Yazıcıya dosya
    göndermek istiyorsak sadece komut vermemiz yeterli olacaktır.
   </para>
   <screen>
<prompt>$</prompt> <userinput>cat dosya &gt; /dev/lp1</userinput>
<prompt>$</prompt>
</screen>
   <para>
    Tabii ki bu, böyle bir durumda sistemde <filename>dosya"</filename>
    adında bir dosya olmalı ve bu dosyanın içeriği yazıcının
    anlayabileceği bir yapıda olmalıdır. Bu komut sayesinde yazıcıdan
    <filename>dosya</filename> isimli dosyanın çıktısını alabiliriz.
    Bununla birlikte, sistem üzerinde pek çok kişi  <command>cat</command>
    komutunu kullanarak yazıcıdan çıktı almaya çalışabileceği göz önünde
    tutularak, birisi de  özel bir uygulama kullanabilir. Bu genellikle
    <command>lpr</command>'dir. Bu uygulama aynı anda sadece tek bir
    dosyanın basılacağını garanti eder ve bu dosya bittikten sonra
    diğerlerini otomatik olarak yazıcıya yollar. Buna benzer şeyler
    bütün aygıtlar için gereklidir. Aslında aygıt dosyaları için çok
    nadiren endişe etmemiz gerekir.
   </para>
   <para>
    Aygıtlar sistemde dosyalar olarak gösterildiği için <command>ls</command>
    veya başka bir komut yardımı ile sistemde bulunan aygıtları
    (<filename>/dev</filename> dizininde ) görebiliriz. <command>ls -l</command>
    komutunun çıktısında satırın en başında aygıt türünü ve erişim
    izinlerini görmek mümkündür.  Örneğin seri bir aleti inceleyecek
    olursak;
   </para>
    <screen><prompt>$</prompt><userinput>ls -l /dev/ttyS0</userinput>
crw-rw-r--    1 root     dialout    4,  64 Aug 19 18:56 /dev/ttyS0
<prompt>$</prompt>
</screen>
   <para>
    Birinci satırın ilk karakteri, yani <literal>crw-rw-rw-</literal>
    harflerinin en başındaki `<literal>c</literal>' harfi bu aygıtın
    türünü bize gösterir. Bu aygıt bir karakter aygıtıdır. Normal dosyalar
    için ilk karakter `<literal>-</literal>', dizinler için
    `<literal>d</literal>', blok aygıtları için `<literal>b</literal>',
    bağ dosyaları için ise `<literal>l</literal>'dir. Daha ayrıntılı bilgiyi
    <uri xl:href="man1-ls"/> komutunın kılavuz sayfasında bulabilirsiniz.
   </para>
   <para>
    Unutmayın ki sistemde olsun olmasın bütün aygıt dosyaları sistem
    içerisinde mevcuttur. Sisteminizde <filename>/dev/sda</filename>
    olması sizin SCSI sabit diske sahip olduğunuz anlamına gelmez.
    Bütün aygıt dosyalarına sahip olmak ilerde ekleyeceğiniz donanımlar
    için  doğru parametreleri bulmak ve aygıt dosyası yapmak zahmetinden
    sizi kurtarır. Aynı zamanda yükleme uygulamalarını daha basit hale
    getirir. Bu sayede sistemi yüklerken her donanım aygıtınız için tek
    tek uğraşmak zorunda kalmazsınız.
   </para>
  </sect1>
  <sect1 xml:id="sag_disks-hd">
   <title>Sabit diskler</title>
   <para>
    Bu bölümde sabit disklere ait terimler ve terminolojiye yer
    verilmiştir. Şayet bu konuda bilgi sahibi iseniz bu bölümü
    atlayabilirsiniz.
   </para>
   <para>
    <xref linkend="sag_disks-hd-schematic"/> de bir sabit
    diskin önemli parçaları gösterilmiştir. Bir sabit disk bir veya daha
    fazla sayıda metal <glossterm>plaka</glossterm> ihtiva eder. Bu
    disklerin her iki <glossterm>yüzey</glossterm>i de bilgi depolayabilmek
    için manyetik bir tabaka ile kaplanmıştır.  Her yüzeyde bilgileri
    okuyan ya da değiştiren bir <glossterm>okuma/yazma kafası</glossterm>
    bulunur. Diskler ortak bir eksen/mil  etrafında döner. Genellikle
    5400 devir/dak ile 7200 devir/dak arası bir hıza sahiptir. Yeni
    sabit disklerin bazıları daha hızlı olabilmektedir. Bazı eski sabit
    disklerin hızı ise daha düşüktür. Kafalar plakaların/disklerin yarı
    çapları boyunca hareket eder.  Bu hareket plakaların dönüşü ile
    birleştirilerek kafaların bütün plaka/disk yüzeyini okuması/işlemesi
    sağlanır.
   </para>
   <para>
    İşlemci (CPU) ve disk, bir disk denetleyicisi vasıtası ile haberleşir.
    Çeşitli türdeki diskler bilgisayarın işlemci dışında kalan kısmı ile
    haberleşmek için aynı arayüzü kullanır, bu sayede bilgisayarın geri
    kalan parçalarının disk ile haberleşmek için ne kullanmaları gerektiğine
    dair bir fikir elde etmeleri gerekmez ve bu da işlemleri kolaylaştırır.
    Bu sayede bilgisayar diske  "hey disk ne istiyorsam çabuk ver" diyebilir.
    Bu işler böyle olmasa idi bilgisayar karmaşık ve uzun elektrik
    sinyallerini diskin kafasına yollayacak, kafa disk üzerinde belli bir
    konumda doğru verileri bulana kadar bekleyecek ve tekrar bunları
    bilgisayara iletecekti. Yapması gereken pek çok karışık ve hoş olmayan
    işlerle uğraşacaktı. Bu da sistemin performansını olumsuz etkileyecekti.
    Aslında  diskin kullandığı bu arayüz de karmaşık olarak nitelenebilir.
    Ama diğer yapılması gereken işlemlere göre çok daha az karmaşıklık
    ihtiva eder. Denetleyiciler otomatik hatalı sektör taraması ve
    düzeltmesi gibi değişik işler yapabilir.
   </para>
   <para>
    Yukarıdaki açıklamalar birisinin sabit diskleri anlaması için gereken
    açıklamaların hepsini içermektedir. Ayrıca sabit disklerde kafanın
    ve plakaların çalışmasını ve dönmesini sağlayan bir motor, mekanik
    bölümleri denetleyen elektronik bölümler de vardır. Fakat bunların,
    sabit diskin çalışma mantığının anlaşılması ile doğrudan bir ilgisi yoktur.
   </para>
   <para>
    Yüzeyler eş merkezli çemberlere ayrılmıştır. <glossterm>İz</glossterm>
    olarak adlandırılan bu bölümlerde <glossterm>sektör</glossterm>lere
    ayrılmıştır. Bu sayede disk yüzeyindeki yerleşimleri tanımlamak,
    bilgilerin bulunduğu yeri tespit etmek ve dosyaları disk yüzeyine
    yerleştirmek mümkün olabilmektedir. Disk yüzeyindeki bir yeri bulmak
    için "yüzey 3, iz 5, sektör 7" gibisinden bir tanımlama yapılabilir.
    Genellikle sektör sayısı bütün izler için aynıdır. Ama bazı sabit
    disklerde, dıştaki izlerde içtekilerden daha fazla sektör olabilmektedir. Genel olarak bir sektör 512 byte bilgi içerir.
   </para>
   <figure xml:id="sag_disks-hd-schematic" floatstyle="1">
    <title>Bir sabit diskin yapısı</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="images/hd-schematic-tr.png"/>
     </imageobject>
    </mediaobject>
   </figure>
   <para>
    Aynı yolla bütün yüzeyler iz ve sektörlere ayrılmıştır. Bir yüzeydeki
    bir kafa bir iz üzerindeyken diğer yüzeydeki kafa da ona mukabil gelen
    iz üzerindedir. Bütün karşılıklı izlerin hepsine birden <glossterm>silindir</glossterm> denir.
    Bir izden diğerine geçmek zaman alır. Sık sık kullanılan dosyalar aynı
    silindir üzerine yazılarak kafaların bütün disk yüzeyinde hareket
    etmeleri mecburiyeti ortadan kaldırılmış olur. Bu sayede zamandan
    tasarruf sağlanır ve performans artışı elde edilir. Tabii bu her zaman
    mümkün olmaz, bu durumdaki dosyalara <glossterm>parçalanmış</glossterm>
    (fragmented) dosyalar denir.
   </para>
   <para>
    Kafaların veya yüzeylerin sayısı, ki ikisi de aynı şeyi ifade eder (her
    yüzeye bir kafa), silindirler ve sektörler bir sabit diskte çok
    çeşitlilik gösterebilir. Her birinin numaralarının tarifine diskin
    <glossterm>geometri</glossterm>si denir. Bu geometri <glossterm>CMOS RAM</glossterm>
    diye anılan batarya destekli özel bir bellek bölümünde saklanır.
    İşletim sistemi açılış sırasında ya da  sürücü başlangıcında gidip bu
    bölümden gerekli bilgileri alır.
  </para>
   <para>
    Büyük bir şanssızlık eseri  CMOS RAM'de iz sayısı 1024 ile
    sınırlandırılmıştır. Bu büyük sabit diskler göz önüne alındığında
    oldukça küçük bir rakam olarak kalmaktadır.  Bu sorunun üstesinden
    gelmek için denetleyici bilgisayara yalan söyler (günümüzde bu tür
    sorunlar ortadan kalkmıştır. Pek çok yerde standart olarak 60-80Gb
    sabit diskler satılmakta ve BIOS ayarlarında LBA kipinin etkinleştirilmesi
    sayesinde 1024 silindir sınırı ortadan kalkmaktadır).
   </para>
   <para>
    Bu sınır SCSI diskler için söz konusu değildir. Çünkü SCSI diskler
    işlemci ile farklı bir yol ile haberleşir.  SCSI disk denetleyicileri
    ardışık sektör numaraları sayesinde haberleşir.  Bilgisayar bu
    durumda diskin gerçek geometrisini asla bilmemektedir.
   </para>
   <para>
    Linux, böyle durumlarda diskin gerçek yapısını bilememekte olup, asla
    dosyaları bir silindir içine depolamaz, onun yerine ardışık sektör
    numaralarının olduğu bölüme bilgileri yazar, ki bu sistemde diğeri
    kadar iyi performans verir. Buradaki en önemli nokta bunların ve
    daha fazlasının denetleyicinin önbelleği sayesinde yapılıyor olmasıdır.
    Bütün bu işlemler otomatik olarak yönetilir.
   </para>
   <para>
    Her sabit disk bağımsız birer aygıt dosyası ile temsil edilir.
    Genellikle 2 veya 4 adet IDE disk  sisteme bağlı haldedir
    (bir veya üç adet disk olmasının IDE sabit diskler için hiçbir
    mahsuru yoktur.). Bunlar <filename>/dev/hda</filename>,
    <filename>/dev/hdb</filename>, <filename>/dev/hdc</filename> ve
    <filename>/dev/hdd</filename> olarak sıralanır ve adlandırılır.
    SCSI diskler ise <filename>/dev/sda</filename>, <filename>/dev/sdb</filename>,
    <filename>/dev/sdc</filename>, ... olarak sıralanır.  Sabit disk
    çeşitleri ve isimleri hakkında daha ayrıntılı bilgi <xref linkend="sag_device-list"/> bölümünde mevcuttur.  Unutmayın ki bu
    isimler disk bölümlerine ulaşmak için değil, bütün sabit diske
    ulaşmak için geçerlidir. Böyle durumlarda çok dikkatli olunmazsa
    bilgiler ve bölümler karıştırılabilir. Disk aygıt dosyaları sadece
    MBR'ye (Master Boot Record - Ana Önyükleme Kaydı) ulaşmak için
    kullanılırdı. Bu konu da ilerde açıklanacaktadır.
  </para>
  </sect1>
  <sect1 xml:id="sag_disks-cdrom">
   <title>CD-ROM'lar</title>
   <para>
    Bir CD sürücüsü plastik kaplı bir diski optik okuyucusu yardımı
    ile okur. Bu diskte kaydedilmiş olan bilgiler, yüzey üzerinde
    merkezden kenarlara kadar spiral biçimde uzanan "delikler" içinde
    kayıtlı olarak tutulur. Sürücü buraları okumak için lazer ışını
    kullanır. Lazer bir deliğe çarptığında farklı, düz bir yüzeye
    çarptığında farklı bir tepki verir.  Okuyucu kafa bunları "0" ve "1" ler
    olarak alır ve disk yüzeyindeki bilgiyi çözümler.
   </para>
   <para>
    CDROM'lar sabit disklere nazaran daha yavaştır. Ortalama bir sabit
    diske tarama için 15 milisaniye yeterli olurken, en hızlısından bir
    CDROM için saniyeler gereklidir. Aslında bir CDROM'un veri aktarım
    hızı saniyede yüzlerce KB ile ölçülür. Burada ifade edilmek istenen
    CDROM'un sabit diskler kadar hızlı olamadığıdır. Bazı Linux dağıtımları;
    "canlı" CDROM dosya sistemleri ile  dağıtılmakta ve bu sayede
    bilgiler sabit diske kopyalanmak zorunda kalmamakta, bunun sonucunda
    hatırı sayılır bir disk alanı tasarruf edilmektedir. Yeni bir yazılımı
    yüklemek için CDROM'lar iyi bir alternatif sayılır. Ne de olsa
    yükleme sırasında çok yüksek hız gerekli değildir.
   </para>
   <para>
    Bir CDROM'daki bilgileri düzenlemenin pek çok yolu vardır. En
    popüler yöntem uluslararası standart olan iso9660 dır. Bu
    standart MSDOS'un kullandığından daha "ham" bir dosya sistemini
    tanımlar. Oldukça küçüktür.  Diğer taraftan bu kadar küçük olması
    her türlü işletim sisteminin onu tanımasına olanak verir.
   </para>
   <para>
    Normal bir Unix kullanımı esnasında iso9660 yeterli gelmemektedir.
    Bu nedenle  "Rock Ridge extension" denen bir ekleme yapılmaktadır.
    Rock Ridge, uzun dosya isimlerine, sembolik bağlara ve daha pek
    çok şeye izin verir. CDROM'un az çok Unix dosya sistemine
    benzemesini sağlar.  İşin iyi tarafı Rock Ridge dosya sistemi
    geçerli bir iso9660 dosya sistemi gibi kullanılabilmekte ve diğer
    dosya sistemine sahip bilgisayarlar ile kullanılabilmektedir.
    Linux iso9660'ı ve Rock Ridge dosya sistemini desteklemektedir.
    Uzantılar otomatik tanımlı ve kullanımlıdır.
   </para>
   <para>
    Dosya sistemi sorunların yarısıdır.  Pek çok CDROM'un içindeki
    bilgilerin okunabilmesi için özel uygulamalar gerekmekte ve bu
    uygulamaların pek çoğu Linux altında çalışmamaktadır (dosemu
    Linux Msdos öykünümü altında ve wine windows öykünümü hariç.
    Ayrıca ticari bir yazılım olan, X86 makinesindeki yazılımları
    komple çeviren VMWARE de bunların içinde  sayılabilir).
   </para>
   <para>
    Bir CDROM sürücüye, karşılıklı aygıt dosyası üzerinden ulaşılır.
    Bir CDROM sürücüyü, bilgisayara bağlamanın çok çeşitli yolları
    vardır: ses kartı üzerinden bağlayabilirsiniz, SCSI veya EIDE
    üzerinden bağlayabilirsiniz. Donanım "hacking" bu kitabın konusu
    dışındadır fakat bağlantı şekli hangi aygıt  dosyasının
    kullanılacağına karar verir.
   </para>
  </sect1>
  <sect1 xml:id="sag_disks-tape">
   <title>Teypler</title>
   <para>
    Bir teyp sürücü müzik kasetlerine benzeyen bantlar kullanır.
    Normalde teypler seri aygıtlardır. Bu nedenle bir yeri okumak
    için o yere kadar gitmeniz gerekir. Bir diske ise rasgele erişim
    mümkündür. İsterseniz diskin her hangi bir yerine doğrudan
    ulaşabilirsiniz.  Seri erişimli teypler bu yüzden nispeten daha
    yavaştır.
   </para>
   <para>
    Diğer taraftan hızlı olmaları gerekmediği için teypler oldukça
    ucuzdur.  Oldukça uzun olabilir ve bu sayede daha fazla veri
    saklayabilir. Arşivleme ve yedekleme işlemleri için büyük
    kapasiteli ama hızlı olması gerekmeyen ucuz bir yöntem arıyorsanız
    teypler sizin için çok uygundur.
   </para>
  </sect1>
  <sect1 xml:id="sag_disks-format">
   <title>Biçemleme</title>
   <para>
    <glossterm>Biçemleme</glossterm> izlerin ve sektörlerin
    işaretlenmesi için kullanılan, manyetik ortama işaretlerin
    yazılması sürecidir. Biçemlenmiş bir disk yüzeyi karışık
    manyetik işaretler ile doludur. Biçemlendiği zaman
    çizgilerin gittiği izler ve bölümlere ayrılmış sektörler haline
    dönerek karmaşıklığa bir son verilmiş olur ve disk yüzeyine
    düzen gelir. Her biçemleme işlemi tam olarak bu şekilde meydana
    gelmeyebilir. Burada önemli olan biçemlenmemiş bir diskin
    kullanılamayacak olmasıdır. Kısaca biçemleme, bir diskin manyetik
    olarak adımlanması ve dosya sistemi haline (bu MSDOS için
    geçerlidir) getirilmesi demektir.
   </para>
   <para>
    Terminoloji burada biraz çelişkilidir: MS-DOS ve MS Windows'da,
    biçemleme dosya sistemini oluşturulmasını da kapsar. Bu iki işlem
    birleşiktir. Gerçek biçemleme
    <glossterm>düşük seviyeli biçemleme</glossterm> olarak bilinirken,
    dosya sisteminin oluşturulması <glossterm>yüksek seviyeli
    biçemleme</glossterm> olarak bilinir. Bu kitabın kapsamında bu ikisi
    biçemleme ve dosya sistemi oluşturma olarak ele alınacaktır.
   </para>
   <para>
    Pek çok kişi biçemleme işlemlerinden endişe duyduğu için SATA ve bazı
    SCSI diskler fabrika çıkışlı olarak biçemlidir. Ve bu işlemin
    tekrarlanması gerekmez. Bu da pek çok endişeyi ortadan kaldırır.
    Gerçekten de bir sabit diskin biçemlenmesi başarım kaybına
    uğramasına sebep olabilir. Disk yüzeyindeki bozuk sektörlerin bazen
    özel bir uygulama tarafından atlanması gerekebilmektedir.
  </para>
   <para>
    Biçemlenmesi gereken veya gerekebilecek olan disklerin biçemlenmesi
    için özel uygulamalara sıklıkla ihtiyaç olmaktadır. Çünkü disk sürücü
    içinde bulunan biçemleme arayüzü aygıttan aygıta değişiklik
    gösterebilmektedir. Biçemleme uygulamasını BIOS içinde veya MS DOS
    uygulaması şeklinde  bulabilirsiniz. Şayet ikisi de yoksa  Linux
    içinde size uygun olabilecek bir tanesini mutlaka bulursunuz.
   </para>
   <para>
    Biçemleme esnasında <glossterm>hatalı sektör</glossterm> /
    <glossterm>hatalı iz</glossterm> olarak adlandırılan
    bozuk sektör ve bozuk izler ile karşılaşmak olasıdır.  Bunlar
    genellikle sürücü tarafından kolaylıkla halledilecek sorunlardır,
    fakat bu bozuk alanlar ilerlemiş ise bunların kullanımını ve
    dolayısı ile ilerde meydana gelebilecek veri kayıplarını önlemek
    için bazı uygulamalar kullanılabilir.  Bunu yapmak için aşağıda
    dosya sistemine nasıl bilgi eklenebileceğini anlatan bölümle aynı
    mantığı kullanabilirsiniz. Bunun yerine bu bozuk kısımları
    kapsayan küçük bir disk bölümü oluşturulabilir. Bu yaklaşım, genişlemiş
    bozuk yüzeylerin olduğu durumda daha akıllıcadır. Çünkü dosya sistemleri,
    geniş bozuk alanlar ile pek iyi geçinemezler.
   </para>
   <para>
    <uri xl:href="man8-badblocks"/> komutu her hangi bir diski veya disk
    bölümünü denetlemek için kullanılabilir.
    Biçemleme işlemi yapmadığı için hali hazırda kurulu olan dosya
    sistemleri üzerinde de denenebilir.
   </para>
   <para>
    <uri xl:href="man8-badblocks"/> komutu bulduğu bozuk blokların
    numaralarını ekrana çıktı olarak verir. Pek çok dosya sistemi bozuk
    bloklardan uzak durmaya çalışır.  Dosya sisteminin kurulumu
    esnasında tespit edilen bozuk blokların listesi tutularak, daha
    sonra  bunlar üzerinde değişiklikler yapılır.  İlk tarama, dosya
    sistemini başlangıç durumuna getiren <uri xl:href="man8-mke2fs"/>
    komutu ile yapılabilir. Fakat daha sonraki taramalar mutlaka
    <uri xl:href="man8-badblocks"/> komutu ile yapılmalıdır.  Ve yeni
    tespit edilen bozuk bloklar <uri xl:href="man8-e2fsck"/> ile
    eklenmelidir. <command>mke2fs</command> ve <command>e2fsck</command>  daha
    sonra anlatılacaktır.
   </para>
   <para>
    Yeni disklerin pek çoğu bozuk blokları otomatik olarak bulmakta ve
    özel bir işlem olarak onları saklanmış (reserved) sağlam bloklar
    ile değiştirmeye çalışmaktadır. Bu işletim sistemi tarafından
    görülemez.  Şayet sizin diskinizin de bu özelliğe sahip olup
    olmadığını merak ediyorsanız diskin kullanım kılavuzuna bakın,
    eğer böyle bir özellik var ise burada mutlaka belirtilmiş olması
    gerekir.  Eğer disk içindeki bozuk blok sayısı iyice artarsa, disk
    kullanılamaz hale gelebilir. Ve diskiniz ile vedalaşmak zorunda
    kalabilirsiniz.
   </para>
  </sect1>
  <sect1 xml:id="sag_disks-partiton">
   <title>Disk Bölümleri</title>
   <warning>
    <para>
     UEFI-GPT bu kılavuzun konusu değildir. Bu kılavuzdan yararlanmak için
     makinenizin BIOS ayarlarında "UEFI Mode" değil "legacy BIOS Mode"
     seçilmiş olmalıdır. "UEFI Mode" seçili ise bu bölümde anlatılanlar
     size uygun değildir, bu bölümü atlayabilirsiniz.
    </para>
   </warning>
   <para>
    Bir sabit disk çeşitli <glossterm>bölüm</glossterm>lere ayrılabilir.
    Her bölüm ayrı bir sabit diskmiş gibi faaliyet gösterebilir. Diyelim ki;
    bir sabit diskiniz var ve siz iki adet işletim sistemine sahip olmak
    istiyorsunuz. Bu durumda sabit diski ikiye bölmeniz gerekecektir.
    Her işletim sistemi kendi bölümünü kullanır ve diğerininkine dokunmaz.
    Bu yöntemle iki ayrı işletim sistemi aynı disk üzerinde kardeşçe
    yaşayabilir. Bölümleme olmasa idi her kurmak istediğimiz işletim
    sistemi için ayrı bir sabit disk almamız gerekecekti.
   </para>
   <sect2>
    <title>MBR, önyükleme sektörleri ve bölümleme tablosu</title>
    <para>
     Bir sabit diskin nasıl bölümlendiğine ait bilgi, birinci plakanın
     birinci izinin içindeki birinci sektörde yer alır. Makine ilk
     açıldığı anda BIOS'un okuyup çalıştırdığı bu ilk sektöre
     Ana Önyükleme Kaydı (MBR - Master Boot Record) adı verilir.
     MBR içerisinde bölümleme tablolarının ve hangi bölümüm etkin
     olduğunu belirten küçük bir yazılım vardır. Ayrıca bu etkin
     bölümün açılış sektörü de burada belirtilir.(MBR aynı zamanda
     bir önyükleme sektörü olmasına rağmen özel durumundan dolayı
     ayrı bir adla anılır.) Önyükleme sektörü içinde de işletim
     sisteminin başlamasını sağlayan küçük bir yazılım vardır.
     Bu yazılım işletim sisteminin ilk bölümünü okur ve sistemi
     başlatır.
    </para>
    <para>
     Bölümleme işlemi donanımla ya da BIOS ile doğrudan
     alakalı bir şey değildir. Bu işletim sistemlerinin geleneksel
     olarak kabul ettikleri ve uyguladıkları bir işlemdir. Pek çok
     işletim sistemi disk bölümlenmesine olanak verir. Bazıları ise
     istisnadır ve disk bölümlemesine izin vermezler. Bazı işletim
     sistemleri bölümlemeyi destekler fakat, sabit disk üzerindeki
     bir bölümü işgal edip orada bulunan bölümleme yöntemi ile diski
     böler. Diğerleri ise, Linux dahil, başka bir işletim sistemi
     ile aynı disk üzerinde hiçbir sorun çıkarmadan yaşayabilir.
     Özel bir şey yapmamıza gerek kalmaz. Ama disk bölümlemeyi
     desteklemeyen bir işletim sistemi ile aynı disk üzerinde başka
     bir işletim sistemi kuramazsınız.
   </para>
    <para>
     Bir güvenlik önlemi olarak bölümleme tablosunu bir kağıda yazmak
     akıllıca olacaktır. Şayet bir arıza olursa bu yolla düzeltme
     imkanınız olur. Bozulmuş bir bölümleme tablosu <command>fdisk</command>
     ile düzeltilebilir.  <command>sfdisk -l</command>  komutu ile
     sisteminizdeki tüm sabit disklerin bölümleme tablolarını
     görebilirsiniz.
    </para>
    <screen>
<prompt>#</prompt><userinput>sfdisk -l</userinput>
Disk /dev/hda: 4870 silindir, 255 kafa, 63 sektör/iz
birimler = 8225280 baytlık silindir, 1024 baytlık blok, 0'dan başlayarak

   Aygıt Önykl Başlangıç Bitiş silindir blok   Kiml Sistem
                                sayısı sayısı
/dev/hda1   *      0+     65      66-   530113+   b  Win95 FAT32
/dev/hda2         66    4869    4804  38588130    f  Win95 Ext'd (LBA)
/dev/hda3          0       -       0         0    0  Boş
/dev/hda4          0       -       0         0    0  Boş
/dev/hda5         66+   1266    1201-  9647001   83  Linux
/dev/hda6       1267+   2467    1201-  9647001    b  Win95 FAT32
/dev/hda7       2468+   3646    1179-  9470286   83  Linux
/dev/hda8       3647+   4869    1223-  9823716   83  Linux
<prompt>#</prompt>
</screen>
   </sect2>
   <sect2>
    <title>Ek ve Mantıksal Bölümler</title>
    <para>
     PC sabit disklerinin orijinal bölümleme planı sadece dört
     bölüme izin verir. Gerçek hayatta bu sınırlama bazı insanlar
     için hiç hoş bir olay olmamaktadır. Çünkü onlar bilgisayarlarında
     dört taneden fazla işletim sistemi (Linux, MS DOS, OS/2, FreeBSD,
     NetBSD, Windows NT, vb.) kurmak istemektedir. Aslında bir
     işletim sistemi bulunan diskleri de bölümlemek oldukça iyi bir
     fikirdir. Örneğin hızdan feragat etmemek için takas alanını,
     Linux'un kendi bölümüne değil de, takasın kendine ayrılmış olan
     bölüme kurmak daha akıllıcadır (disk üzerinde Linux ve Linux takas
     olarak iki bölüm yapabilirsiniz - yukarıdaki /dev/hdd gibi).
    </para>
    <para>
     Bu sorunu aşmak için <glossterm>ek</glossterm> bölümler
     kullanılmaktadır. Bu hile <glossterm>birincil bölüm</glossterm>ü alt
     bölümlere ayırmaya izin verir. Birincil bölüm
     <glossterm>ek bölümler</glossterm> adıyla alt bölümlere ayrılır.
     Bu alt bölümler <glossterm>mantıksal bölümler</glossterm>dir.
     Bu bölümler birincil bölüm gibi davranır fakat yaratılma biçimleri
     farklıdır. Bu bölümler ile birincil bölümler arasında bir hız farkı
     yoktur.
   </para>
    <para>
     Bir sabit diskin bölümlemesi <xref linkend="sag_disks-hd-layout"/>'ye
     benzetilebilir. Disk üç adet birincil bölüme, bunlardan ikincisi ise iki
     adet mantıksal bölüme ayrılmıştır. Disk tamamen bölümlenmemiştir. Her
     birincil bölümün kendine ait bir önyükleme sektörü vardır.
    </para>
    <figure xml:id="sag_disks-hd-layout" floatstyle="1">
     <title>Bir sabit diskin MBR bölümlemesi örneği</title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="images/hd-layout-tr.gif"/>
      </imageobject>
     </mediaobject>
    </figure>
   </sect2>
   <sect2>
    <title>Bölüm türleri</title>
    <para>
     Bölümleme tabloları (biri MBR'da diğeri ek bölümde) her bölüm için
     bölüm türünü tanımlayan birer baytlık bilgi içerir. Bu sayede
     bölümü kullanan işletim sistemine neyi kullandığı bildirilir.
     Buradaki amaç büyük ihtimal ile iki ayrı işletim sisteminin tek
     bir bölümü kullanmasını engellemektir. Bununla beraber ,özellikle
     Linux; gerçekte bölüm türü baytları ile ilgilenmez. Daha da kötüsü
     bazı işletim sistemleri bu bilgileri yanlış kullanır. DR DOS'un bazı
     sürümleri  iletilen bayt sinyallerini  önemsemezler ve yok sayar.
    </para>
    <para>
     Baytların anlamları standartlaşmamıştır fakat genel kabul gören
     bazıları aşağıda sıralanmıştır. Tam bir listesi Linux
     <command>cfdisk</command> uygulamasında bulunabilir.
    </para>
    <table xml:id="sag_disks-partition-ids">
     <title>Bölüm türleri</title>
     <tgroup cols="6">
      <tbody>
       <row>
        <entry>0</entry>
        <entry>Boş</entry>
        <entry>40</entry>
        <entry>Venix 80286</entry>
        <entry>94</entry>
        <entry>Amoeba BBT</entry>
       </row>
       <row>
        <entry>1</entry>
        <entry>DOS 12-bit FAT</entry>
        <entry>51</entry>
        <entry>Novell?</entry>
        <entry>a5</entry>
        <entry>BSD/386</entry>
       </row>
       <row>
        <entry>2</entry>
        <entry>XENIX kök</entry>
        <entry>52</entry>
        <entry>Microport</entry>
        <entry>b7</entry>
        <entry>BSDI fs</entry>
       </row>
       <row>
        <entry>3</entry>
        <entry>XENIX usr</entry>
        <entry>63</entry>
        <entry>GNU HURD</entry>
        <entry>b8</entry>
        <entry>BSDI takas</entry>
       </row>
       <row>
        <entry>4</entry>
        <entry>DOS 16-bit FAT &lt;32M</entry>
        <entry>64</entry>
        <entry>Novell</entry>
        <entry>c7</entry>
        <entry>Syrinx</entry>
       </row>
       <row>
        <entry>5</entry>
        <entry>Linux Ek</entry>
        <entry>75</entry>
        <entry>PC/IX</entry>
        <entry>db</entry>
        <entry>CP/M</entry>
       </row>
       <row>
        <entry>6</entry>
        <entry>DOS 16-bit &gt;=32M</entry>
        <entry>80</entry>
        <entry>Old MINIX</entry>
        <entry>e1</entry>
        <entry>DOS erişimi</entry>
       </row>
       <row>
        <entry>7</entry>
        <entry>OS/2 HPFS</entry>
        <entry>81</entry>
        <entry>Linux/MINIX</entry>
        <entry>e3</entry>
        <entry>DOS R/O</entry>
       </row>
       <row>
        <entry>8</entry>
        <entry>AIX</entry>
        <entry>82</entry>
        <entry>Linux takas</entry>
        <entry>f2</entry>
        <entry>DOS ikincil</entry>
       </row>
       <row>
        <entry>9</entry>
        <entry>AIX önyüklenebilir</entry>
        <entry>83</entry>
        <entry>Linux</entry>
        <entry>ff</entry>
        <entry>BBT</entry>
       </row>
       <row>
        <entry>f</entry>
        <entry>Win95 Ek (LBA)</entry>
        <entry>93</entry>
        <entry>Amoeba</entry>
        <entry/>
        <entry/>
       </row>
      </tbody>
     </tgroup>
    </table>
   </sect2>
   <sect2>
    <title>Bir sabit diskin bölümlenmesi</title>
    <para>
     Bölüm oluşturmak ve kaldırmak için pek çok uygulama kullanılabilir.
     Pek çok işletim sistemi kendine ait bir uygulama kullanır. Disk
     bölümlemek için bu uygulamayı kullanmak daha akıllıca olur, çünkü
     işletim sistemi ile alakalı bazı işleri diğer uygulamalar yapamazken,
     bu uygulama alışılmadık şeyleri de yapabilir.  Bu uygulamaların pek
     çoğu  <uri xl:href="man8-fdisk"/> olarak adlandırılır.  Linux
     <uri xl:href="man8-fdisk"/>  hakkında ayrıntılı bilgiyi kılavuz
     sayfasında bulabilirsiniz.  <uri xl:href="man8-cfdisk"/> komutu
     <command>fdisk</command>  ile aynı işi yapar ama daha hoş bir
     tam ekran arayüze sahiptir.
    </para>
    <para>
     Bir bölümün boyutunu değiştirirken ilk önce kurtarmak istediğiniz
     bilgileri yedekleyin, sonra bölümü silip yeni bölümü oluşturun ve
     yedeklenmiş bilgileri geri yükleyin. Şayet bölüm boyutunu
     değiştiriyorsanız ve bunu diğer bölümlerden alan alarak yapıyorsanız
     bu işlemleri (yedekle-sil-oluştur-yükle) onlara da yapmak
     zorundasınız.
    </para>
    <para>
     Bölümlerin boyutlarını değiştirmek çok sancılı ve sıkıntılı bir
     işlem olduğundan, bunu en başta bir kere yapmak, sağlam ve
     kullanışlı bir yedekleme uygulaması kullanmak daha mantıklıdır.
     Eğer dışarıdan pek fazla müdahaleye ihtiyaç duymadan bir araçtan
     yükleme yapıyorsanız (CD ROM gibi) en başta kolaylıkla çeşitli
     yapılandırmalar deneyebilirsiniz. Elimizde yedeklenmiş ve tekrar
     yüklenilmesi gereken bir bilgi yığını olmadığı, daha doğrusu boş
     bir diske sahip  olduğumuz için, çeşitli defalar yükleme yapmak,
     yedeklenmiş bilgileri geri yüklemek kadar zor değildir.
    </para>
   </sect2>
   <sect2>
    <title>Aygıt dosyaları ve disk bölümleri</title>
    <para>
     Her bölüm ve ek bölüm kendi aygıt dosyasına sahiptir. Geleneksel
     isimlendirme yöntemine göre aygıt isminden sonra bir numara
     gelmektedir.  Yine geleneksel olarak 1-4 arası numaralar kaç adet
     olduğuna bakılmaksınız birincil bölümlere ayrılır. 5 ve daha
     sonrakiler ise mantıksal bölümlere aittir. Buradaki önemli nokta
     sistemde kaç adet birincil veya mantıksal bölüm olduğunun
     ÖNEMLİ OLMADIĞIDIR. Örneğin <filename>/dev/hda1</filename> birinci
     IDE sabit diskteki ilk birincil bölümdür.  <filename>/dev/sdb7</filename>
     ikinci SCSI sabit diskteki üçüncü ek bölümdür.
    </para>
   </sect2>
  </sect1>
  <sect1 xml:id="sag_fs">
  <title>Dosya Sistemleri</title>
   <sect2 xml:id="sag_fs-whatis">
    <title>Dosya sistemleri nedir?</title>
    <para>
     <glossterm>Dosya sistemi</glossterm> disk üzerindeki dosyaları
     hiyerarşik bir düzende yerleştirebilmeyi sağlar. Bir işletim sisteminin
     bir disk veya bölümleri üzerindeki dosyalarının yerlerini bulmak için
     kullandığı yapıya dosya sistemi (filesystem) denir.
     Ayrıca dosya sistemi terimi, dosyaların
     veya dosya sistemlerinin depolandığı  bir disk veya disk üzerindeki
     bir bölümü tanımlamak için de kullanılabilir. Bu nedenle birisi
     "ben iki adet dosya sistemine sahibim" derken; aslında disk üzerinde
     her birinde dosyaların tutulduğu, iki adet bölüme veya ek bir disk
     bölümüne sahip olduğu anlaşılmalıdır.
    </para>
    <para>
     Bir disk veya disk bölümü ile dosya sistemi arasındaki fark önemlidir.
     Çok az uygulama işlenmemiş disk veya bölüm yüzeyinde işlem yapabilir.
     Buna dosya sistem yapabilen uygulamalar da dahildir. Şayet orada bir
     dosya sistemi var ise bu uygulamaların kullanılması sonucu ya silinir
     veya büyük ölçüde hasar görür. Pek çok uygulama ise dosya sistemleri
     üzerinde çalışır; olmayan veya yanlış girdiler içeren bölümler üzerinde
     çalışamazlar. Genelde dosya sistemi olmayan bir disk yüzeyinde bir
     uygulama çalışmaz. Uygulamaların çalışması için bir dosya sistemine
     ihtiyaç vardır; dosya sistemlerinin olabilmesi için de bir disk veya disk
     bölümüne ihtiyaç duyulur.
    </para>
    <para>
     Bir disk veya disk bölümü dosya sistemi olarak kullanılmadan
     önce, disk yüzeyi ilk haline döndürülmeli ve gerekli bilgiler diske
     yazılmalıdır. Bu işlem <glossterm>dosya sistemi oluşturma</glossterm>
     olarak adlandırılır.
    </para>
    <para>
     Pek çok Unix dosya sistemi küçük farklılıklar dışında benzer bir
     genel yapıya sahiptir.  Genel kavramlar olarak
     <glossterm>süper blok</glossterm>, <glossterm>dosya düğümü</glossterm>
     (inode), <glossterm>veri bloğu</glossterm>  ve
     <glossterm>dolaylı blok</glossterm> sayılabilir. Süper blok, dosya
     sisteminin bütünü hakkında bilgi içerir. Aslında bu dosya sistemlerine
     göre değişiklik gösterebilir. Dosya sisteminin boyutu gibi bilgiler
     burada yer alır. Dosya düğümü ise bir dosya hakkında, ismi hariç, bütün
     bilgileri ihtiva eder. Dosya ismi dizin içinde dosya düğümünün numarası
     ile birlikte yer alır. Bir dizin girişi; dosya ismine ve bu dosyanın yer
     aldığı dosya düğümünün numarasına bağlıdır. Dosya düğümü; dosyalardaki
     bilgileri depolamak için kullanılan veri bloklarının numaralarını
     içerir. Dosya düğümü içinde birkaç tane veri bloğu numarası için yer
     vardır. Bununla beraber daha fazla yere ihtiyaç olursa dinamik bir
     yapıyla bu yeni yer ayrılır. Bu dinamik yerleştirilmiş bloklar dolaylı
     bloklardır. Bu veri bloklarını bulmak için önce dolaylı veri bloklarının
     numaralarını bulmamız gerekir.
    </para>
    <para>
     Unix dosya sistemleri genellikle <uri xl:href="man2-lseek"/>
     sistem çağrısı vasıtası ile bir dosya içerisinde
     <glossterm>delik</glossterm> oluşturulmasına izin verir.  Burada
     dosya sistemi, dosya içerisindeki özel bir alanda sanki sıfır byte
     varmış gibi davranır.  Aslında dosya içerisinde bunun için ayrılmış
     bir disk sektörü yoktur (disk üzerinde daha az yer kaplanmış olur).
     Bu olay genellikle küçük çalıştırılabilir dosyalar, paylaşılmış Linux
     kütüphaneleri, bazı veri tabanları ve bazı özel durumlarda sık sık
     ortaya çıkar.  Delikler dolaylı bloklardaki veya dosya düğümü
     içindeki veri bloklarının adresleri gibi özel değerler verilerek
     kullanılır. Bu özel adresler, dosyanın bahsi geçen bölümü için
     her hangi bir veri bloğunun ayrılamamış olduğunu, orada bir delik
     bulunduğunu gösterir.
    </para>
   </sect2>
   <sect2 xml:id="sag_fs-types">
    <title>Dosya sistemi bolluğu</title>
    <para>
     Linux çok çeşitli dosya sistemlerini desteklemektedir. En
     önemlileri aşağıda tanıtılmıştır:
    </para>
    <variablelist>
     <varlistentry>
      <term>minix</term>
      <listitem>
       <para>
        En eski, en güvenli olarak kabul edilen ama kısıtlı
        yeteneklere ve özelliklere sahip olan dosya sistemidir.
        (En fazla 64 MB lık dosya sistemi, en çok 30 karakterlik
        dosya isimleri, ara sıra kaybolan tarih zaman damgaları gibi...
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>xia</term>
      <listitem>
       <para>
        Dosya isimleri ve dosya sistemi boyutlarının sınırlarını
        kaldıran ama bundan başka pek bir yenilik getirmeyen, sadece
        minix dosya sisteminin yenilenmiş halidir. Çok popüler
        değildir ama oldukça iyi çalıştığı rapor edilmektedir.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>ext3/ext4</term>
      <listitem>
       <para>
        ext3 dosya sistemi, ext2'nin bütün özelliklerine sahip bir dosya sistemidir. Aradaki temel fark, günlükleme özelliğinin eklenmiş olmasıdır. Böylece, herhangi bir sistem çökmesi esnasında, geri kurtarma zamanı kısaltılır ve başarım artışı sağlanır.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>ext2</term>
      <listitem>
       <para>
        En yetenekli Linux dosya sistemidir. İleriye
        dönük kolay geliştirilebilen bir dosya sistemi olarak
        tasarlanmıştır.  Dolayısıyla yeni sürümü, dosya sistemi
        kodlarını, kurulu bir sisteme uygulamak için yeni ayarlar
        yapmayı gerektirmez.
      </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>ext</term>
      <listitem>
       <para>
        Ext2'nin geliştirilmeye uygun olmayan eski sürümüdür.
        Pek çok insan ext2 dosya sistemine yönelmiştir.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>reiserfs</term>
      <listitem>
       <para>
        Çok sağlam bir dosya sistemidir. Veri kayıplarını en aza
        indirmek için günlükleme (journalling) yöntemi kullanılır.
        Günlükleme; yapılmış veya yapılan  işlemlerin kayıtlarının
        tutulması mekanizmasıdır. Bu sayede dosya sistemi meydana
        gelmiş olan hasarları son derece kolay bir biçimde onarabilir.
       </para>
       <warning>
        <para>
         <option>reiserfs</option> dosya sisteminin geliştiricisi kalmadığından Linux 5.18 sürümünden beri kullanımı önerilmemekte
         olup muhtemelen 2025'te çekirdek desteği sonlandırılacaktır (Kaynak:
         <link xl:href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/ ?id=eb103a51640ee32ab01c51e13bf8fca211f25f61"/>).
        </para>
       </warning>
      </listitem>
     </varlistentry>
    </variablelist>
    <para>
     Bunlara ek olarak, çok sayıda yabancı dosya sistemine destek
     bulunmaktadır. Böylece işletim sistemleri arasında dosyaları
     değişmek kolaylaştırılmıştır. Bu yabancı dosya sistemleri,
     makine üzerinde doğal Linux dosya sistemleri gibi çalışabilir.
     Ama Unix'in bazı özelliklerinden faydalanamazlar, bazı kısıtlamalara
     tabidir veya bazı acayiplikler sergiler.
    </para>
   <variablelist>
    <varlistentry>
     <term>msdos</term>
     <listitem>
      <para>
       MS-DOS FAT dosya sistemleri (OS/2 ve Windows NT) ile uyumlu
       bir dosya sistemidir.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>umsdos</term>
     <listitem>
      <para>
       Msdos dosya sistemi sürücülerine, Linux altında daha uzun
       dosya isimleri, sahipler, izinler, bağlar ve aygıt
       dosyaları erişimi sağlar. Bu sistem; normal bir MSDOS
       dosya sisteminin sanki Linux dosya sistemiymiş gibi
       kullanılmasını sağlar ve böylece Linux için bağımsız
       bir bölüm oluşturulması zorunluluğunu ortadan kaldırır.
     </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>vfat</term>
     <listitem>
      <para>
       FAT32 olarak bilinen dosya sisteminin bir uzantısıdır.
       Pek çok MS Windows diski vfat'tır.  FAT'tan daha büyük
       disk alanlarını destekler.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>iso9660</term>
     <listitem>
      <para>
       CD ROM'lar için standart dosya sistemleridir.
       Daha uzun dosya isimlerine izin veren Rock Ridge uzantısı
       otomatik olarak desteklenir.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>nfs</term>
     <listitem>
      <para>
       Bir ağ dosya sistemidir. Dosya sisteminin pek çok
       bilgisayar tarafından paylaşılmasını sağlar.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>smbfs</term>
     <listitem>
      <para>
       MS Windows bilgisayarlarla paylaşım sağlayan bir ağ dosya
       sistemidir. Windows dosya paylaşım protokolleri ile
       uyumludur.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>hpfs</term>
     <listitem>
      <para>OS/2 dosya sistemi.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>sysv</term>
     <listitem>
      <para>
       SystemV/386, Coherent ve Xenix dosya sistemleri.
       </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    Dosya sistemi seçimi duruma göre değişir. Uyumluluk ve diğer sebepler
    doğal olmayan dosya sistemlerinin kullanılması mecburiyetini
    getirebilir.  Şayet özgürce seçebilseydik, en mantıklısı ext3
    dosya sistemi olurdu çünkü hem ext2'nin bütün özelliklerine sahiptir,
    hem de günlükleme yapabilmektedir.
   </para>
   <para>
    Ayrıca bir de "proc" dosya sistemi vardır. <filename>/proc</filename>
    dizini altından ulaşılabilen bu dosya sistemi aslında bir dosya
    sistemi değildir. Proc dosya sistemi bazı çekirdek yapı bilgilerine
    (süreç listesi gibi) ulaşımı kolaylaştırır. Böylece bu veri
    yapılarının bir dosya sistemi gibi görünmesini sağlar ve dosya
    sisteminin sağlamış olduğu bütün olanakları kullanıma açar. Örneğin
    bütün süreçlerin listesini alabilmek için şu komutu kullanabiliriz.
  </para>
    <screen>
<prompt>$</prompt> <userinput>ls -l /proc</userinput>
toplam 525256
dr-xr-xr-x    3 root     root            0 Oca 13 04:41 1
dr-xr-xr-x    3 root     root            0 Oca 13 04:41 11
dr-xr-xr-x    3 root     root            0 Oca 13 04:41 111
dr-xr-xr-x    3 root     root            0 Oca 13 04:41 112
dr-xr-xr-x    3 root     root            0 Oca 13 04:41 14
dr-xr-xr-x    3 root     root            0 Oca 13 04:41 1563
dr-xr-xr-x    3 root     root            0 Oca 13 04:41 21
dr-xr-xr-x    3 root     root            0 Oca 13 04:41 3
dr-xr-xr-x    3 root     root            0 Oca 13 04:41 4
dr-xr-xr-x    3 root     root            0 Oca 13 04:41 5
dr-xr-xr-x    3 root     root            0 Oca 13 04:41 6
dr-xr-xr-x    3 root     root            0 Oca 13 04:41 7
dr-xr-xr-x    3 xfs      xfs             0 Oca 13 04:41 747
dr-xr-xr-x    3 apache   apache          0 Oca 13 04:41 766
dr-xr-xr-x    3 root     root            0 Oca 13 04:41 8
dr-xr-xr-x    3 root     root            0 Oca 13 04:41 9
-r--r--r--    1 root     root            0 Oca 13 04:41 apm
dr-xr-xr-x    6 root     root            0 Oca 13 04:41 bus
-r--r--r--    1 root     root            0 Oca 13 04:41 cmdline
-r--r--r--    1 root     root            0 Oca 13 04:41 cpuinfo
-r--r--r--    1 root     root            0 Oca 13 04:41 devices
-r--r--r--    1 root     root            0 Oca 13 04:41 dma
dr-xr-xr-x    3 root     root            0 Oca 13 04:41 driver
-r--r--r--    1 root     root            0 Oca 13 04:41 execdomains
-r--r--r--    1 root     root            0 Oca 13 04:41 fb
-r--r--r--    1 root     root            0 Oca 13 04:41 filesystems
dr-xr-xr-x    3 root     root            0 Oca 13 04:41 fs
dr-xr-xr-x    4 root     root            0 Oca 13 04:41 ide
-r--r--r--    1 root     root            0 Oca 13 04:41 interrupts
-r--r--r--    1 root     root            0 Oca 13 04:41 iomem
-r--r--r--    1 root     root            0 Oca 13 04:41 ioports
dr-xr-xr-x   18 root     root            0 Oca 13 04:41 irq
-rw-r--r--    1 root     root            0 Oca 13 04:41 isapnp
-r--------    1 root     root     536809472 Oca 13 04:41 kcore
-r--------    1 root     root            0 Oca 12 14:31 kmsg
-r--r--r--    1 root     root            0 Oca 13 04:41 ksyms
-r--r--r--    1 root     root            0 Oca 13 04:41 loadavg
-r--r--r--    1 root     root            0 Oca 13 04:41 locks
-r--r--r--    1 root     root            0 Oca 13 04:41 mdstat
-r--r--r--    1 root     root            0 Oca 13 04:41 meminfo
-r--r--r--    1 root     root            0 Oca 13 04:41 misc
-r--r--r--    1 root     root            0 Oca 13 04:41 modules
-r--r--r--    1 root     root            0 Oca 13 04:41 mounts
-rw-r--r--    1 root     root          208 Oca 13 04:41 mtrr
dr-xr-xr-x    3 root     root            0 Oca 13 04:41 net
dr-xr-xr-x    2 root     root            0 Oca 13 04:41 nv
-r--r--r--    1 root     root            0 Oca 13 04:41 partitions
-r--r--r--    1 root     root            0 Oca 13 04:41 pci
lrwxrwxrwx    1 root     root           64 Oca 12 14:31 self -&gt; 1563
-rw-r--r--    1 root     root            0 Oca 13 04:41 slabinfo
-r--r--r--    1 root     root            0 Oca 13 04:41 stat
-r--r--r--    1 root     root            0 Oca 13 04:41 swaps
dr-xr-xr-x   11 root     root            0 Oca 13 04:41 sys
dr-xr-xr-x    2 root     root            0 Oca 13 04:41 sysvipc
dr-xr-xr-x    4 root     root            0 Oca 13 04:41 tty
-r--r--r--    1 root     root            0 Oca 13 04:41 uptime
-r--r--r--    1 root     root            0 Oca 13 04:41 version
dr-xr-xr-x    3 root     root            0 Oca 13 04:41 video
<prompt>$</prompt>
</screen>
    <para>
     (Yukarıdaki örnek kısaltılmıştır. Birkaç tane daha süreç ismi
     listelenebilir.)
    </para>
    <para>
     Her ne kadar bir dosya sistemi diye adlandırılsa bile proc dosya
     sistemi sadece çekirdeğin bir hayalidir. Diskte yer kaplamaz.
     Proc dosya sisteminin her hangi bir bölümüne bakmak istediğimiz zaman,
     çekirdek sanki bu bölüm varmış gibi davranır ki aslında böyle bir
     bölüm yoktur.  Öyle ki, disk üzerinde yer kaplamayan çok-megabytelık
     bir <filename>/proc/kcore</filename> dosyası vardır.
    </para>
   </sect2>
   <sect2 xml:id="sag_fs-whose">
    <title>Hangi dosya sistemi kullanılmalı?</title>
    <para>
     Pek çok değişik dosya sistemi arasında genellikle küçük farklılıklar
     vardır. Kesinlikle ext4 en popüler dosya sistemidir. Çünkü günlükleme
     yapabilmektedir. Günlüklemenin aşırı yük getiren yapısından,
     verimlilikten, güvenilirlikten, uyumdan ve pek çok diğer sebeplerden
     dolayı; başka bir dosya sistemi kullanmak daha uygun olabilir. Dosya
     sistemi seçimi kişilere ve ihtiyaçlarına göre değişiklik gösterir.
    </para>
    <para>
     Günlükleme yapma yeteneğine sahip dosya sistemleri, aynı zamanda,
     günlüklü dosya sistemleri diye de adlandırılır. Günlüklemeli bir
     dosya sistemi, sistemde olan bitenin kaydını veya günlüğünü tutar.
     Bir sistem çökmesi durumunda ya da benim iki yaşındaki oğlumun yapmayı
     çok sevdiği gibi, bilgisayarın fişinin aniden çıkarılması durumunda;
     günlükleme sistemi kaydedilmemiş veya zarar görmüş verilerin
     kurtarılmasını sağlar. Böylece, veri kayıpları oldukça aşağıya çekilmiş
     olur. Bu nedenle, muhtemelen gelecek Linux dağıtımlarında, bu özellik
     standart hale gelecektir. Bununla birlikte, günlüklemenin, sizde boş bir
     güven duygusu yaratmasına izin vermeyin. Acil durumlarda kullanabilmek
     için, verilerinizin yedeğini almayı asla ihmal etmeyin.
    </para>
   </sect2>
   <sect2 xml:id="sag_fs-create">
    <title>Bir dosya sisteminin oluşturulması</title>
    <para>
     Dosya sistemleri <uri xl:href="man8-mkfs"/> komutu ile oluşturulurdu.
     <command>mkfs</command>, dosya sistemine özel
     <command>mkfs</command>.<replaceable>ds-türü</replaceable> araçları
     lehine kullanımdan kaldırılmıştır. Yani her dosya sistemi türü için
     ayrı bir komut kullanılır. Örneğin <command>mkfs.ext2</command> (aslında
     <uri xl:href="man8-mke2fs"/> çalışır.) için genel ve en önemli
     seçenekler aşağıda belirtilmiştir. Ayrıntılı bilgi için komutun kılavuz
     sayfasına bakılabilir.
    </para>
    <variablelist>
     <varlistentry>
      <term><option>-c</option></term>
      <listitem>
       <para>
        Dosya sistemi oluşturulmadan önce aygıtta bozuk bloklar aranır.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>
       <option>-l</option> <replaceable>DOSYA</replaceable>
      </term>
      <listitem>
       <para>
        İsmi <replaceable>DOSYA</replaceable> ile belirtilen bozuk
        blokların listesini içeren dosyayı okur.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect2>
   <sect2 xml:id="sag_fs_mount-and-umount">
    <title>Dosya sistemlerinin bağlanması ve ayrılması</title>
    <para>
     Bir dosya sistemi kullanılmadan önce mutlaka bağlanmalıdır.
     Daha sonra işletim sistemi her şeyin doğru bir şekilde
     çalıştığından emin olmak için çeşitli muhasebe işlemleri
     yapar. Unix altında bütün dosya sistemleri tek bir dizin
     ağacı altında gözüktüğü için, işletim sistemi yeni bağlanan
     dosya sistemlerini eskiden bağlanmış olan dosya sistemlerinin
     alt dizinleriymiş gibi gösterir ve bu şekilde işlem yapar.
    </para>
    <para>
     Aşağıda <xref linkend="sag_fs-mount-root"/>'de kendi kök dizinleri
     altında bulunan birbirinden bağımsız üç dosya sistemi gösterilmektedir.
     Son iki dosya sistemi sırayla, birincinin <filename>/home</filename>
     ve <filename>/usr</filename> dizinleri altına bağlanırsa
     <xref linkend="sag_fs-mount-all"/>'deki gibi tek bir dizin ağacı
     elde ederiz.
    </para>
    <figure xml:id="sag_fs-mount-root" floatstyle="1">
     <title>Üç ayrı dosya sistemi</title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="images/hd-mount-separate.gif"/>
      </imageobject>
     </mediaobject>
    </figure>
    <figure xml:id="sag_fs-mount-all" floatstyle="1">
     <title>
      <filename>/home</filename> ve <filename>/usr</filename> bağlı.
     </title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="images/hd-mount-mounted.gif"/>
      </imageobject>
     </mediaobject>
    </figure>
    <para>
     Aşağıdaki örnekte gösterildiği şekilde bu bağlama işlemleri
     yapılabilir.
    </para>
    <screen>
<prompt>#</prompt> <userinput>mount /dev/hda2 /home</userinput>
<prompt>#</prompt> <userinput>mount /dev/hda3 /usr</userinput>
<prompt>#</prompt>
</screen>
    <para>
     <command>mount</command> komutu iki argüman alır. Birincisi diske
     uygun bir aygıt dosyası veya dosya sistemini içeren bir disk bölümüdür.
     İkincisi ise  bağlandığı dizindir. Bu işlemler yapıldıktan sonra
     bu iki aygıtın içerikleri sanki disk üzerindeki <filename>/home</filename>
     ve <filename>/usr</filename> dizinlerinin içerikleriymiş gibi
     kullanılabilir.  Şayet bağlama işlemi başka bir dizin altına
     yapılmış olsaydı, aygıtların içeriklerini görebilmek için o
     dizinlerin altına bakmamız gerekecekti. Ayrıca  aygıt dosyası ve
     bağlanılan dizin arasındaki farkı mutlaka göz önünde bulundurmalıyız.
     Unutmayın ki aygıt dosyası, (<filename>/dev/hda2</filename>)
     diskin ham içeriğini verir. Bağlandığı dizin ise (<filename>/home</filename>)
     disk üzerindeki dosyalara ulaşım imkanı verir. Disk bölümünün
     bağlandığı dizine <glossterm>bağlama noktası</glossterm> adı
     verilir.
    </para>
    <para>
     Linux pek çok dosya sistemini destekler. <command>mount</command>
     dosya sisteminin türünü tahmin etmeye çalışır. İsterseniz
     <option>-t fstype</option> seçeneğini dosya sisteminin türünü
     belirtmek için kullanabiliriz. Bazı zamanlar bu gerekli olmaktadır,
     <command>mount</command> komutu dosya sistemini tanımlayamayabilir.
    </para>
    <para>
     Bağlantı dizini mutlaka sistemde var olmalıdır ve içi boş değilse
     dosya sistemi bağlı olduğu sürece o içerik erişilmez olacaktır
     (hali hazırda açılmış dosyalar ve başka bir dizinden sabit bağ verilmiş
     olan dosyalar hala ulaşılabilir durumdadır). Örneğin; bazı kişiler
     <filename>/tmp</filename> ve <filename>/var/tmp</filename> dizinlerini
     eş anlamlı olarak kullanır ve <filename>/tmp</filename> dizinini
     <filename>/var/tmp</filename> dizinine sembolik bağ olarak atar.
     Sistem açılırken, <filename>/tmp</filename> dosya sistemi bağlanmadan
     önce kök dosya sisteminde bulunan <filename>/var/tmp</filename>
     dizini onun yerine  kullanılır. <filename>/var</filename> dizini
     bağlandığı zaman, bu kök dosya sistemi altındaki
     <filename>/var/tmp</filename> dizinini ulaşılmaz kılar. Şayet
     <filename>/var/tmp</filename> dizini kök dosya sistemde yok ise,
     <filename>/var</filename> dizinini bağlamadan geçici dosyaları
     kullanmak imkansız olacaktır.
    </para>
    <para>
     Dosya sistemine her hangi bir şey yazmaya niyetiniz yok ise
     bağlama işlemi sırasında bu bağlantının salt okunur olmasını
     sağlayacak <option>-r</option> seçeneğini kullanabilirsiniz.
     Bu çekirdeğin her hangi bir yazım girişiminde bulunmasını ve
     dosya düğümleri içindeki erişim zamanlarının güncellenmesini
     engeller. Üzerine yazılamayan ortamları (örn; CDROM) bağlarken
     bu seçenek gereklidir.
    </para>
    <para>
     Uyanık okuyucular küçük bir mantıksal sorunu fark etmiştir.
     Birinci dosya sistemi (burada kök dosya sistemi oluyor) nasıl
     bağlanmıştır? Kök dosya sistemi açılış esnasında sihirli bir
     şekilde bağlanmıştır ve kullanıcı bunun her açılışta tekrar
     olacağına güvenmelidir. Şayet kök dosya sistemi bağlanmazsa
     açılış yapılamaz. Sihirli bir biçimde kök dosya sistemini
     bağlayan dosya sisteminin adı çekirdek içinde derlenmiştir veya
     LILO ya da <command>rdev</command> kullanılarak ayarlanmıştır.
    </para>
    <para>
     Kök dosya sistemi ilk olarak salt okunabilir şekilde bağlanır.
     Daha sonra başlayan betikler onun geçerliliğini kanıtlamak için
     <command>fsck</command> çalıştırır. Şayet bir sorun çıkmaz ise
     oku-yaz olarak tekrar bağlanır. Böylece yazma işlemlerine olanak
     sağlanır. <command>fsck</command>, oku-yaz bağlı bir dosya sistemi
     üzerinde yapılmamalıdır. Çünkü dosya sisteminde meydana gelen her
     değişiklik <command>fsck</command>'nın çalışmasını etkileyecek ve çalışması esnasında sorunlar ortaya çıkmasına sebep olacaktır.
     Kök dosya sistemi, denetlenirken salt okunur şekilde bağlanmış olduğu
     için <command>fsck</command> herhangi bir sorunu sıkıntıya girmeden
     giderebilir. Dosya sisteminin bellekte tuttuğu bütün bilgiler yeniden
     bağlama işlemi esnasında silinecektir.
    </para>
    <para>
     Pek çok sistemde açılış esnasında otomatik olarak bağlanması gereken
     dosya sistemleri mevcuttur.  Bunlar <filename>/etc/fstab</filename>
     dosyası içinde belirtilmişlerdir. Ayrıntılı bilgi <command>fstab</command>
     kılavuz sayfasında mevcuttur. Açılış esnasında bağlanılacak dosya
     sistemlerinin özellikleri çok çeşitli faktörlere dayanır ve bu
     sistem yöneticisinin şahsi ihtiyaç ve görüşlerine göre değişiklik
     gösterebilir.  Daha ayrıntılı bilgi <xref linkend="sag_boots-and-shutdowns"/>
     bölümünde mevcuttur.
    </para>
    <para>
     Bir dosya sisteminin daha fazla bağlı durumda kalması gerekmiyorsa
     <command>umount</command> komutu ile dosya sistemi sistemden
     ayrılmalıdır.<footnote><para>Tabii ki <command>umount</command>
     komutunun aslı unmount'tur. Fakat 1970'li yıllarsa "n" esrarengiz
     bir şekilde ortadan kayboldu. Şayet "n" yi görürseniz lütfen Bell
     Laboratuarlarına haber verin.</para></footnote> <command>umount</command>
     argüman olarak aygıt dosyası ismini veya bağlama noktası dizininin
     adını kullanır. Bu işlem aşağıdaki  şekillerden birisi ile
     gerçekleştirilir:
    </para>
    <screen>
<prompt>#</prompt> <userinput>umount /dev/hda2</userinput>
<prompt>#</prompt> <userinput>umount /usr</userinput>
<prompt>#</prompt>
</screen>
    <para>
     Sadece root kullanıcı dosya istemlerini bağlayabilir ve ayırabilir.
     Şayet her kullanıcı istediği bir dizine bir disk bağlarsa, sonuçta
     <filename>/bin/sh</filename> dizini gibi görünen bir truva atı
     yaratmak çok kolay hale gelirdi.  Bununla beraber kullanıcılara
     disk bağlama izni vermek kaçınılmazdır.  Bunun çeşitli yolları vardır:
    </para>
    <itemizedlist>
     <listitem>
      <para>
       Kullanıcılara root parolasını vermek. En kolay fakat en az
       güvenli seçenektir.  Ağa bağlı olmayan kişisel sistemler
       için en uygun çözümdür.
      </para>
     </listitem>
     <listitem>
      <para>
       Kullanıcıların dosya sistemi bağlama işlemlerini yapabilmesine
       izin vermek için <command>sudo</command> kullanabilirsiniz.
       Bu hala az güvenli bir seçenektir,
       sadece süper kullanıcı yetkileri herkese doğrudan verilmemiş
       olur.<footnote><para>Yine de bu durum kullanıcının bir kaç
       saniye düşünmesi ile aşılabilen bir güvenliktir. Ancak,
       <command>sudo</command> komutu, kullanıcıların belirli komutları
       çalıştırabilmesi için sınırlandırılabilir. Bu konu hakkında
       ayrıntılı bilgi <uri xl:href="man8-sudo"/>,
       <uri xl:href="man5-sudoers"/> ve <uri xl:href="man8-visudo"/>
       kılavuz sayfalarında bulunabilir.</para></footnote>
      </para>
     </listitem>
     <listitem>
      <para>
       <filename>/etc/fstab</filename> dosyası içinde bağlanması olası
       dizin ve aygıt dosyası adlarını uygun seçeneklerle tanımlayın.
      </para>
     </listitem>
    </itemizedlist>
    <para>
     Birinci sütundan itibaren, bağlanacak aygıt dosyası, bağlantı dizini,
     dosya  sistemi, seçenekler, yedekleme yapma sıklığını
     (<command>dump</command> tarafından kullanılır) ve açılış esnasında
     hangi dosya sistemlerinin <command>fsck</command> tarafından
     denetleneceğini belirten numaralar (sıfır = birşey yapma) belirtilir.
    </para>
    <para>
     <option>noauto</option> seçeneği açılış esnasında dosya sisteminin
     otomatik olarak bağlanmayacağını belirtir. <option>user</option> ve
     <option>users</option> seçenekleri ise bütün kullanıcılara bu dosya
     sistemini bağlama izni verir.
    </para>
   </sect2>
   <sect2 xml:id="sag_fs-fsck">
    <title>
     <literal>fsck</literal> ile dosya sistemi bütünlüğünün sınanması
    </title>
    <para>
     Dosya sistemleri zaman zaman hata vermeye eğilimli olan karmaşık
     yapılardır. Bir dosya sisteminin doğruluğu ve geçerliliği
     <command>fsck</command> komutu ile sınanır. Bulduğu  küçük hataları
     onarmak ve onaramadığı daha önemli hatalar için kullanıcıyı uyarmak
     üzere yapılandırılabilir. Şans eseri dosya sistemlerinin kodlarını
     onarma işleminde oldukça etkilidir. Bununla birlikte çok nadir
     olarak kullanıcı, donanım veya elektrik kesintilerinden kaynaklanan
     hatalar meydana gelir.
    </para>
    <para>
     Pek çok sistemde <command>fsck</command> komutu açılışta çalışmak
     üzere ayarlanır. Ve bu sayede dosya sisteminde meydana gelmiş olan
     hataların sistem kullanıma başlanmadan önce düzeltilmesi umulur.
     Bozulmuş dosya sistemleri işleri yanlış yönlendirir: veri
     sistemleri karıştıysa, dosya sistemi büyük olasılıkla onları
     daha fazla karıştıracaktır. Bununla birlikte büyük dosya
     sistemlerinde <command>fsck</command> komutunun çalışması biraz
     vakit alabilir ama sistem düzgün kapatılmış ise dosya sisteminde
     hata meydana gelme olasılığı hemen hemen hiç yoktur. Böyle
     durumlarda sınamanın yapılmasını önlemek için bazı hileler vardır.
     Birincisi: şayet <filename>/etc/fastboot</filename> dosyası varsa
     sınama işlemi yapılmaz. İkincisi ise: süper bloklar içinde sistemin
     bir önceki kapanışta düzgün kapatılıp kapatılmadığını belirten
     işaretlerdir.  Şayet sistem düzgün bir şekilde ayrılmışsa
     <command>e2fsck</command> (ext2 dosya sistemi için <command>fsck</command>) komutu işleme girmez. <filename>/etc/fastboot</filename>
     hilesi sizin açılış esnasında kullandığınız betiklere göre çalışır
     ama ext2 hilesi <command>e2fsck</command> kullandığınız sürece işe
     yarar. <command>e2fsck</command>'den kurtulmak için açık bir
     şekilde seçenekler belirtilmiş olmalıdır. Güncel bilgiler için
     <uri xl:href="man8-e2fsck"/> kılavuz sayfasına bakınız.
    </para>
    <para>
     Otomatik sınama sadece açılış esnasında otomatik bağlanan dosya
     sistemleri için geçerlidir.
    </para>
    <para>
     Şayet <command>fsck</command> tamir edemeyeceği sorunlar ile
     karşılaşırsa; iyi yedekleme, dosya sistemlerinin kullanımı ve
     bozulmuş dosya sistemlerinin türleri hakkında ayrıntılı ve derin
     bilgiye sahip olmanız gerekecektir. Daha sonrası kolaydır,
     genellikle de sıkıcı. Kendi kendinize yetemeyeceğiniz durumda bir
     arkadaşınızdan, posta listelerinden, haber gruplarından veya
     bunlara benzer bir yerlerden yardım alınabilir. Size daha
     fazlasını anlatmak isterdim fakat bu konuda ki eğitimimim ve
     deneyimlerim eksikliği buna engel olmaktadır. <uri xl:href="man8-debugfs"/> kılavuz sayfası bu konuda yardımcı olabilir.
    </para>
    <para>
     <command>fsck</command> mutlaka bağlı olmayan dosya sistemleri
     üzerinde yapılmalıdır. Sadece açılış esnasında salt okunur konumdaki
     kök dosya sistemi bu durum için istisnadır. Bunun sebebi <command>fsck</command>
     komutunun  disk yüzeyine doğrudan erişerek dosya sistemi üzerinde
     yaptığı  bazı değişikliklerin, işletim sistemi tarafından anlaşılamama
     olasılığı bulunması ve bunun da işletim sistemi üzerinde sorunlar
     yaratabilecek olmasıdır.
    </para>
   </sect2>
   <sect2 xml:id="sag_fs-badblocks">
    <title>Disk hatalarının <literal>badblocks</literal> ile denetlenmesi</title>
    <para>
     Bozuk bloklar için periyodik denetimler yapmak iyi bir fikir olabilir.
     Bu işlem <command>badblocks</command> komutu ile yapılabilir. Bu komut
     bulabildiği bütün bozuk bloklar için bir liste verir. Bu liste
     <command>fsck</command> için dosya sistemi veri yapısı içinde bulunan
     kayıtlara yönlendirilebilir, böylece işletim sisteminin bozuk blok
     hatalarının kaydı tutulmak zorunda kalınmaz. Aşağıdaki örnek bunun
     nasıl yapılacağını açıklamaktadır.
    </para>
    <screen>
<prompt>#</prompt> <userinput>badblocks -o bad-blocks /dev/fd0u1440</userinput>
<prompt>#</prompt> <userinput>fsck -t ext2 -l bad-blocks /dev/fd0u1440</userinput>
fsck 1.25 (20-Sep-2001)
e2fsck 1.25 (20-Sep-2001)
1. geçiş: dosya indeksleri, bloklar ve uzunluklar denetleniyor
2. geçiş: Dizin yapısı denetleniyor
3. geçiş: Dizin bağlanabilirliği denetleniyor
4. geçiş: Başvuru sayısı denetleniyor
5. geçiş: grup özet bilgileri denetleniyor

/dev/fd0u1440: ***** DOSYA SİSTEMİ DEĞİŞTİRİLDİ *****
/dev/fd0u1440: 11/184 dosya (0.%0 yanyana olmayan düğüm), 41/1440 blok
<prompt>#</prompt>
</screen>
   <para>
    Şayet kullanımdaki bir bloğun hatalı olduğu rapor edilirse
    <command>e2fsck</command> bu bloğu başka bir yere taşıyacaktır.
    Şayet durum gerçekten kötü ise bu blok içindeki dosyaların
    içeriği bile bozulabilir.
   </para>
  </sect2>
  <sect2 xml:id="sag_fs-tools-all">
   <title>Diğer dosya sistemi araçları</title>
   <para>
    Dosya sistemlerini yönetmek için başka araçlar da vardır.
    <command>df</command> komutu seçeneksiz kullanıldığında
    bağlı tüm dosya sistemlerinin dolu ve boş alanları hakkında
    bilgi verir. <command>du</command> komutu bir dizinin ve
    içerdiği dosyaların ne kadar disk alanı kullandığını gösterir.
    Bu araçlar disk alanının kullanımı hakkında bilgi vermesi
    bakımından olası sorunlarn yakalanmasında yardımcı olabilir.
    Ayrıntılı bilgi için her ikisinin de kılavuz sayfalarına
    bakabilirsiniz.
   </para>
   <para>
    <command>sync</command> komutu diske henüz yazılmamış ve tampon
    bellekte tutumakta olan bilgilerin diske yazılmasını sağlar.
    (<xref linkend="sag_memory-management_buffer-cache"/> bölümüne
    bakınız.) Bunu yapmak nadiren gerekli olur. Çünkü bir artalan
    süreci olan <command>update</command> bu işlemi otomatik olarak
    yapar. Genellikle yıkım anlarında faydalı olur; örneğin
    <command>update</command> ya da onun yardımcı süreci
    <command>bdflush</command> ölmüşse veya <emphasis>now</emphasis>
    seçeneği ile sistemi kapatmak üzereyken <command>update</command>'in
    devreye girmesini bekleyemeyecekseniz... Bu konuda daha ayrıntılı
    bilgileri kılavuz sayfalarından bulabileceğinizi tekrarlıyorum.
    <command>man</command> komutu Linux'da en iyi arkadaşınızdır.
    Kuzeni olan <command>apropos</command> komutu da kullanmak istediğiniz
    komutun ya da konunun adını hatırlayamadığınızda ve bir anahtar sözcük
    verdiğinizde ilgili kılavuz sayfalarının bir listesini göstererek
    size yardımcı olacaktır.
   </para>
  </sect2>
  <sect2 xml:id="sag_fs-tools-ext2">
   <title>Diğer ext2/ext3 dosya sistemi araçları</title>
   <para>
    Dosya sistemi yaratıcısı <command>mke2fs</command> ve denetleyicisi
    <command>e2fsck</command>'ye ek olarak ext2 dosya sistemi, dosya
    sisteminden bağımsız olarak ulaşılabilen ve yahut doğrudan
    kullanılabilen, bazı yararlı  ek araçlara da sahiptir.
   </para>
   <para>
    <command>tune2fs</command> dosya sistemi parametrelerini ayarlar.
    Bazı ilginç parametreler şunlardır:
   </para>
    <itemizedlist>
     <listitem>
      <para>
       Maksimum bağlama sayısı. Dosya sistemleri belirli bir bağlama
       sayısına ulaşılınca, sistem temiz işaretine rağmen,
       <command>e2fsck</command> dosya sistemini denetlemeye kalkışır.
       Geliştirme veya sınama amacıyla kullanılan bir sistemde bu sayıyı
       düşürmek iyi bir fikir olabilir.
      </para>
     </listitem>
     <listitem>
      <para>
       Denetimler arasındaki maksimum zaman. Sistem temiz işaretine ve
       denetim için gerekli bağlama sayısına ulaşılmamış olsa bile; en
       son denetimden beri geçen süre belli bir değere ulaşınca
       <command>e2fsck</command> sistemi denetlemek isteyebilir.
       Bu seçenek istenirse kapatılabilir.
      </para>
     </listitem>
     <listitem>
      <para>
       root kullanıcı için ayrılmış blok sayısı. Ext2, dosya sistemi
       dolmuş olsa bile, root kullanıcının her hangi bir şeyi silmeden
       işlerine devam edebilmesi için bazı bloklar ayrılmıştır. Bunun
       için ayrılan blokların oranı öntanımlı %5'dir. Bu da pek çok disk
       için fazla sayılmayacak bir orandır.
      </para>
     </listitem>
    </itemizedlist>
   <para>
    Daha fazla bilgi edinmek için <uri xl:href="man8-tune2fs"/> kılavuz
    sayfasına bakınız.
   </para>
   <para>
    <uri xl:href="man8-dumpe2fs"/> ext2 dosya sistemi hakkında, genellikle
    süper bloktan alınan, bilgileri gösterir. Bu bilgilerden bazıları
    teknik ayrıntılardır ve dosya sisteminin nasıl çalıştığının
    bilinmesini gerektirir, fakat pek çoğu kolayca anlaşılabilir
    açıklamalardır.  Aşağıda böyle bir çıktı vardır:
   </para>
   <screen>
 <prompt>#</prompt> <userinput>dumpe2fs -h /dev/hdb2</userinput>
dumpe2fs 1.25 (20-Sep-2001)
Filesystem volume name:   /b2
Last mounted on:          &lt;not available&gt;
Filesystem UUID:          ad9437d2-0e25-490b-8c9d-9a0da50c95df
Filesystem magic number:  0xEF53
Filesystem revision #:    1 (dynamic)
Filesystem features:      has_journal filetype needs_recovery sparse_super
Filesystem state:         clean
Errors behavior:          Continue
Filesystem OS type:       Linux
Inode count:              366592
Block count:              2931862
Reserved block count:     146593
Free blocks:              780635
Free inodes:              306325
First block:              1
Block size:               1024
Fragment size:            1024
Blocks per group:         8192
Fragments per group:      8192
Inodes per group:         1024
Inode blocks per group:   128
Last mount time:          Mon Jan 13 16:47:05 2003
Last write time:          Mon Jan 13 16:47:05 2003
Mount count:              821
Maximum mount count:      -1
Last checked:             Thu Oct 25 16:02:44 2001
Check interval:           0 (&lt;none&gt;)
Reserved blocks uid:      0 (user root)
Reserved blocks gid:      0 (group root)
First inode:              11
Inode size:               128
Journal UUID:             &lt;none&gt;
Journal inode:            8
Journal device:           0x0000
First orphan inode:       0


Grup 0: (1 ile 8192 arasındaki bloklar)
    İlk süperbloğun yeri:  1
  Grup tanımının yeri:     2-13
  Blok biteşleminin yeri:  14 (+13)
  Düğüm biteşleminin yeri: 15 (+14)
  Düğüm tablosunun yeri:   16-143 (+15)
  Serbest blok sayısı:     0
  Serbest düğüm sayısı:    792
  Dizin sayısı:            19
  Serbest bloklar:
  Serbest düğümler:        233-1024
Grup 1: (8193 ile 16384 arasındaki bloklar)
  Yedek süperbloğun yeri:  8193
  Grup tanımının yeri:     8194-8205
  Blok biteşleminin yeri:  8206 (+13)
  Düğüm biteşleminin yeri: 8207 (+14)
  Düğüm tablosunun yeri:   8208-8335 (+15)
  Serbest blok sayısı:     0
  Serbest düğüm sayısı:    855
  Dizin sayısı:            31
  Serbest bloklar:
  Serbest düğümler:        1194-2048

<emphasis>[çıktının Grup 1 ile Grup 357 arasında grup bilgileri silindi]</emphasis>

Grup 357: (2924545 ile 2931861 arasındaki bloklar)
  Blok biteşleminin yeri:  2924545 (+0)
  Düğüm biteşleminin yeri: 2924546 (+1)
  Düğüm tablosunun yeri:   2924560-2924687 (+15)
  Serbest blok sayısı:     5452
  Serbest düğüm sayısı:    812
  Dizin sayısı:            25
  Serbest bloklar:         2924699, 2925104-2925488, 2925495-2925498, 2925525, \
                           2926801-2931861
  Serbest düğümler:        365580, 365607, 365783-366592
<prompt>#</prompt>
</screen>
    <para>
     <uri xl:href="man8-debugfs"/> dosya sistemleri için kullanılan bir
     hata ayıklama uygulamasıdır. Disk üzerinde bulunan dosya sistemi veri
     yapısına doğrudan erişim sağlar ve <command>fsck</command> komutunun
     onaramadığı hataları düzeltmeye yarar.  Ayrıca silinmiş dosyaları
     geri almak için kullanıldığı da bilinmektedir. Bununla birlikte
     <command>debugfs</command> ne yaptığınızı bilmeniz gereken bir
     uygulamadır, aksi halde bütün bilgilerinizi yok edebilirsiniz.
    </para>
    <para>
     <command>dump</command> ve <command>restore</command> ext2 dosya
     sisteminin yedekleme işlemlerinde kullanılır. Geleneksel Unix
     işletim sistemlerinin, ext2 dosya sistemi için geliştirilmiş özel
     sürümleridir. <xref linkend="sag_backups"/> bölümünde yedekleme
     hakkında daha ayrıntılı bilgi bulabilirsiniz.
    </para>
   </sect2>
  </sect1>
  <sect1 xml:id="sag_fs-wo-fs">
   <title>Dosya sistemleri olmayan diskler</title>
   <para>
    Bütün bölümler ve diskler dosya sistemlerini kullanmaz.
    Örneğin takas bölümü bir dosya sistemine sahip değildir.
   </para>
   <para>
    Dosya sistemleri disklerin daha kullanışlı olmalarını sağlamakla
    birlikte, daima aşırı kayıtlama olayından dolayı, bu özelliklerini
    kısıtlamaktadır.  Diskleri diğer sistemler ile daha uyumlu hale
    getirir. Örneğin  dosya sistemleri pek çok sistemde farklı olduğu
    durumlarda bile, tar  dosya şekli bütün sistemlerde aynıdır.
   </para>
   <para>
    İşlenmemiş diskleri kullanmamızın bir sebebi de onların biteşlem
    kopyalarını yaratmaktır.  Eğer bir disk kısmen zarar görmüş bir
    dosya sistemi içeriyorsa, onu tamir etmeye çalışmadan önce tam
    bir kopyasını çıkarmak, meydana gelebilecek sorunlara karşı iyi
    bir önlem olabilir.  Böylece tamir işlememiz  başarısız olsa bile,
    bu işlemi tekrar yapabilme şansımız olur.
   </para>
  </sect1>
  <sect1 xml:id="sag_disks-allocate">
   <title>Disk Alanının Ayarlanması</title>
   <sect2 xml:id="sag_disks-allocate-partioning">
    <title>Diski dosya sistemine uygun bölümlemek</title>
    <para>
     Bir diski bölümlere ayırmanın hem en iyi hem de en kolay bir
     yolu yoktur. Daha kötüsü bunu yapmanın genelleşmiş bir yolu da yoktur.
     Çünkü bölümleme kararınızı etkileyecek pek çok faktör vardır.
    </para>
    <para>
     Geleneksel yöntem; küçük bir kök dosya sistemi yaratmak ve bunun
     içinde  <filename>/bin</filename>, <filename>/etc</filename>,
     <filename>/dev</filename>, <filename>/lib</filename>, <filename>/tmp</filename>,
     gibi sistemin çalıştırılması ve yönetilmesi için ihtiyaç duyulan
     dosya  sistemlerinin yerleştirilmiş olmasıdır.  Bu yolla, kök dosya
     sistemi sistemin açılması ve çalışması için gerekli her şeyi ihtiva
     etmiş olur. Kök dosya sisteminin küçük tutulmasındaki ve daha az
     iş yüküne sahip olmasındaki ana sebep, sistem çökmeleri esnasında
     kök dosya sisteminde daha az hasar meydana gelmesini ve kolayca tamir
     edilebilmesini sağlamaktır. Daha sonra başka bölümler ya da başka
     diskler kullanarak dizin ağacına <filename>/usr</filename> dosya
     sistemini, kullanıcılar için ayrı bir <filename>/home</filename>
     dizini ve bağımsız bir takas bölümü oluşturabilirsiniz. Ev dizinlerini
     bağımsız  bölümler içinde yerleştirmek yedekleme işleminde büyük
     kolaylıklar sağlar. Bir ağ ortamında <filename>/usr</filename>
     dizinini çeşitli makineler arasında paylaştırmak da mümkündür.
     Böylece her makinenin ihtiyaç duyduğu yüzlerce megabytelık alanlara
     olan ihtiyaç azaltılmış olur.
    </para>
    <para>
     Pek çok disk bölümüne sahip olmak, boş disk yüzeyinin parçalar
     halinde ayrılmış olması sorununu yanında getirir. Günümüzde,
     işletim sistemlerinin ve disklerin daha güvenli olması ile,
     kullanıcılar bütün dizinleri kapsayan tek bir dizine doğru
     yönelmektedir. Bununla birlikte küçük bir ikinci bölüm yedekleme
     işleminin daha kolay yapılmasını sağlayabilir.
    </para>
    <para>
     Küçük bir sabit diske sahipseniz (çekirdek geliştirmesi
     yapmayacağınız varsayılarak) tek bir bölüme sahip olmanız daha
     uygun olacaktır. Büyük bir diske sahipseniz, herhangi bir şeyin
     ters gidebileceği ihtimalini göz önüne alarak, birkaç adet büyük
     disk bölümüne sahip olmanız daha mantıklı olacaktır. (Buradaki
     büyük ve küçük kelimeleri tamamen öznel kavramlardır. Disk
     bölümlerinin büyüklüğünü tamamen sizin kullanım amaç ve
     gereksinimlerinize göre ayarlamalısınız.)
    </para>
    <para>
     Şayet birkaç tane sabit diske sahipseniz; birine <filename>/usr</filename>
     dizinini de içeren bir kök dizini, diğerinde ise
     <filename>/home</filename> dizini yarleştirebilirsiniz.
    </para>
    <para>
     Çeşitli bölümleme tabloları için değişik deneyler yapmanız iyi
     olabilir. Bu biraz iş yükü getirmektedir. Çünkü her seferinde
     çeşitli kereler işletim sistemini yeniden kurmanız gerekecektir.
     Ama bu da yaptığınız işin doğruluğundan emin olmanın tek yoludur.
    </para>
   </sect2>
   <sect2 xml:id="sag_disks-allocate-space">
    <title>Alan gereksinimleri</title>
    <para>
     Kuracağınız Linux dağıtımı, size değişik yapılandırmalara göre ne
     kadarlık bir disk alanına ihtiyacınız olduğunu bildirir.
     Bağımsız olarak kurulan uygulamalar da bunu yapar.  Bu sayede
     disk alanının kullanımı için planlarınızı yapabilirsiniz, ama
     ilerisi için hazırlıklı olmalı ve ilerde duyabileceğiniz ihtiyaçları
     göz önünde bulundurarak fazladan disk alanı ayırmalısınız.
    </para>
    <para>
     Kullanıcı dosyaları için ayıracağınız bölümün hacmi, kullanıcıların
     ne yapmak istediklerine göre değişir. Pek çok insanın, dosyaları için
     daha fazla alana ihtiyaçları varmış gibi görünmektedir, fakat ihtiyaç
     duyulan alan kişiden kişiye değişiklik gösterir. Bazı kişiler hafif
     yazım işleri ile uğraşır ve onlar için birkaç gigabyte alan yeterli
     olabilir. Bazıları ise onlarca gigabyte gerektirecek grafik işleri
     ile uğraşır.
    </para>
    <para>
     Sırası gelmişken, kB veya MB cinsinden belirtilen dosya boyutları ile,
     MB cinsinden belirtilen disk boyutunu karşılaştırırken, her iki
     birimin farklılıklar içerebileceğini unutmayın. Bazı üreticiler bir
     kilobyte'ı 1000 byte, bir megabyte'ı 1000 kilobyte olarak ayarlamışken,
     bazıları 1024 ve katlarını birimler olarak kullanır. Bu nedenle
     benim  345 MB'lık hard diskim aslında 330Mb'dır.
    </para>
    <para>
     Takas alanının ayrılması
     <xref linkend="sag_memory-management-swap-allocation"/>
     bölümünde anlatılmıştır.
    </para>
   </sect2>
   <sect2 xml:id="sag_disks-allocate-sample">
    <title>Bölümleme örnekleri</title>
    <para>
     Daha önce 109 Mb lık bir sabit diskim vardı. Şu an ise 330 MB lık
     bir disk kullanıyorum. Bu diskleri nasıl ve niçin bölümlediğimi
     anlatacağım.
    </para>
    <para>
     Kullandığım işletim sistemleri ve ihtiyaçlarım değiştiği için pek çok
     defalar 109 Mb lık sabit diski bölümledim. İlk önceleri Linux ile
     birlikte MS-DOS kullandım.  Bunun için 20 MB lık bir diske
     ihtiyacım vardı veya klostrofobiye kapılmadan MS-DOS, bir C derleyici,
     çeşitli yararlı araçlar, bir metin düzenleyici ve üzerinde çalıştığım
     yazılım için ancak yeten bir yere sahip olduğumu söylemeliyim.
     Linux takas alanı için 10 Mb ayırmıştım, geri kalan 79 MB ise Linux
     için ayrılmış tek bir dizin idi.  Kök, <filename>/usr</filename>,
     ve <filename>/home</filename> dizinlerini bağımsız bir şekilde
     yerleştirmek için çeşitli teşebbüslerde bulundum fakat bu olayı
     ilginç ve gerekli kılacak kadar disk alanım maalesef yoktu.
    </para>
    <para>
     MS DOS'a daha fazla ihtiyacım kalmadığı zaman diski 12 MB takas alanı
     ve geri kalanını tek bir dizin halinde Linux olarak tekrar
     biçimlendirdim.
    </para>
    <para>
     330 MB'lik disk ise şu şekilde çeşitli bölümlere ayrıldı.
    </para>
     <informaltable>
      <tgroup cols="2">
       <tbody>
        <row>
         <entry>5 MB</entry>
         <entry>kök dosya sistemi</entry>
        </row>
        <row>
         <entry> 10 MB</entry>
         <entry>takas alanı</entry>
        </row>
        <row>
         <entry>180 MB</entry>
         <entry><filename>/usr</filename> dosya sistemi</entry>
        </row>
        <row>
         <entry>120 MB</entry>
         <entry><filename>/home</filename> dosya sistemi</entry>
        </row>
        <row>
         <entry> 15 MB</entry>
         <entry>karalama bölümü</entry>
        </row>
       </tbody>
      </tgroup>
     </informaltable>
    <para>
     Karalama bölümü üzerinde oynanmak için kendilerine ayrı bir bölüm
     isteyen şeyler içindir. Örneğin çeşitli dosya sistemlerinin
     karşılaştırılması veya çeşitli dosya sistemlerinin hızlarının
     karşılaştırılması gibi... başka bir şeye ihtiyaç kalmayınca bu
     bölümü takas alanı olarak kullanırdım. (günümüzde karalama bölümü
     tarih olmuş sayılabilir. Artık pek çok kullanıcın gigabytelar ile
     ölçülen disk alanları var.)
    </para>
   </sect2>
   <sect2 xml:id="sag_disks-allocate-more">
    <title>Linux için daha fazla disk alanı eklemek</title>
    <para>
     Donanımınız doğru bir şekilde yüklenmiş ise Linux'e fazladan yer
     vermek çok kolay bir iştir.  Yukarıda tanımlandığı şekilde
     gerekiyorsa diski biçemleyin, disk bölümlerini ayırın ve dosya
     sistemlerini kurun. <filename>/etc/fstab</filename> dosyasına
     otomatik bağlama işlemi için gerekli satırları ekleyin.
    </para>
   </sect2>
   <sect2 xml:id="sag_disks-allocate-tips">
    <title>Disk alanını kazanmak için ipuçları</title>
    <para>
     En iyi tavsiye gereksiz paketleri kurmamanızı söylemek olacaktır.
     Pek çok Linux dağıtımı içerdikleri paketlerin belirli bölümlerini
     kurmanız için gereken kurulum seçeneklerine sahiptir.  Dikkatle
     seçim yaparsanız pek çok pakete ihtiyacınız olmadığını
     görebilirsiniz. Bazı paketler çok büyük olduğu için bu yolla geniş
     bir disk alanını kazanabilirsiniz.  Bir paket ya da uygulamanın bir
     bölümüne ihtiyacınız olsa bile hepsine ihtiyacınız olmayabilir.
     Örneğin: bazı belgeler gereksiz olabilir,  GNU Emacs için bazı Elisp
     dosyaları gereksiz olabilir, X11 için bazı yazıtipleri gereksiz
     olabilir veya yazılım kütüphaneleri gereksiz olabilir.
    </para>
    <para>
     Paketleri kaldıramıyorsanız, en azından sıkıştırın.
     <uri xl:href="man1-gzip"/> veya <command>zip</command> gibi sıkıştırma
     uygulamaları kişisel veya grup dosyalarınızı sıkıştıracaklardır.
     <command>gzexe</command> sıkıştırma ve açma işlemlerini
     kullanıcıya hissettirmeden yapar (kullanılmayan dosyaları sıkıştırır
     ve ihtiyaç olunca geri açar).  Daha gelişmiş DouBle sistemi bir dosya
     sistemindeki bütün dosyaları onları kullanan uygulamalara hissettirmeden
     sıkıştırır (windows'taki drivespace veya msdos'taki stacker gibi
     uygulamalar hakkında bilgi sahibiyseniz, bu uygulamanın mantığını daha
     iyi anlayabilirsiniz. Temel çalışma mantıkları benzerlik gösterir).
    </para>
   </sect2>
  </sect1>
 </chapter>
 <chapter xml:id="sag_memory-management">
  <title>Bellek Yönetimi</title>
  <preliminary>
   <blockquote>
    <para>
     "Minnet, jag har tappat mitt minne, är jag svensk eller finne,
     kommer inte ihåg..."   (Bosse Österberg)
    </para>
    <para>
     A Swedish drinking song, (rough) translation: ``Memory, I have lost
     my memory.  Am I Swedish or Finnish?  I can't remember''
    </para>
   </blockquote>
   <para>
    Bu bölümde Linux bellek yönetiminin özellikleri anlatılmıştır. Sanal
    bellek ve disk  tampon belleği gibi şeylerin çalışma prensipleri,
    amaçları  ve sistem yöneticisinin dikkat etmesi gereken durumlar
    anlatılmaktadır.
   </para>
  </preliminary>
  <sect1 xml:id="sag_memory-management-vm">
   <title>Sanal bellek nedir?</title>
   <para>
    Linux, disk yüzeyini RAM belleğin bir uzantısıymış gibi kullanan ve
    böylelikle fiziksel belleğin görünürdeki miktarını arttıran
    <glossterm>sanal bellek</glossterm> desteğine sahiptir. Çekirdek
    bellekteki kullanılmayan bloklarda
    bulunan bilgileri, disk yüzeyine yazar ve bellek başka işler için
    serbest kalmış olur. Bu bölümler gerektiği zaman bunlar belleğe
    tekrar alınır. Bu olaylar kullanıcıdan bağımsız bir şekilde
    gerçekleşir. Linux altında çalışan uygulamalar geniş bir bellek
    alanı görürken, aslında bazı bilgilerin hemen yanı başlarında
    olduğundan habersizlerdir. Elbette ki sanal bellek kullanımı RAM
    kullanımı kadar hızlı değildir, bu nedenle uygulama hızlarında
    düşüş yaşanır. Sabit disk üzerinde sanal bellek için kullanılan
    bölüme <glossterm>takas alanı</glossterm> denir.
   </para>
   <para>
    Linux, dosya sistemi içindeki normal bir dosyayı veya bağımsız bir
    disk bölümünü takas alanı olarak kullanabilir. Bağımsız bir takas
    bölümü daha hızlı iken, bir takas dosyasının boyutunu değiştirmek
    daha kolaydır (bütün sabit diski yeniden bölümlemeniz gerekmez).
    Ne kadarlık bir takas alanına ihtiyacınız olduğunu biliyorsanız
    bağımsız bir takas bölümü oluşturun; ama şayet bundan emin
    değilseniz bir süre bir takas dosyası kullanın ve sistemin ne
    kadarlık bir takas alanına ihtiyaç duyduğundan emin olunca bir
    takas bölümü oluşturun.
    </para>
   <para>
    Ayrıca bilmelisiniz ki Linux çeşitli takas bölümleri ve/veya
    dosyalarını aynı anda kullanmanıza izin verir. Şayet arada sırada
    daha büyük bir takas alanına ihtiyaç duyuyorsanız, bütün sistemi
    baştan ayarlamak yerine, kendinize bir takas dosyası yaratabilirsiniz.
   </para>
   <para>
    İşletim sistemi terminolojisine ait bir not: bilgisayar bilimi takas
    (bütün işlemleri takas alanına yazmak) ve sayfalama (belirli bir
    zamanda belirli bir parçayı yazmak) olaylarını ayrı şeyler olarak
    almaktadır. Linux'un yapmış olduğu şey sayfalamadır ama Linux
    terminolojisinde bu takas olarak yerleşmiştir.
   </para>
  </sect1>
  <sect1 xml:id="sag_memory-management-swap">
   <title>Bir takas alanının oluşturulması</title>
   <para>
    Bir takas dosyası çekirdek ile özel bir bağı olmayan sıradan bir
    dosyadır. Çekirdeği ilgilendiren tek şey, o dosya içinde oyukların
    (hole) olmadığı ve  <uri xl:href="man8-mkswap"/>'ın kullanımı için
    hazırlanmış olduğudur. Ayrıca yerel bir disk üzerinde bulunması
    zorunludur. Bir NFS sistemi üzerinde bulunması uygulama
    şartlarından dolayı mümkün değildir.
   </para>
   <para>
    Oyuklar hakkındaki ayrıntı
    önemlidir. Bir takas dosyası belli bir disk yüzeyini ayırır ve böylece
    çekirdek hızlı bir şekilde sayfa değiş tokuşunu sağlar. Bunu yaparken
    normal zamanlarda, bir disk yüzeyinin bir dosya için ayrılması işlemi
    için gerekli olan bütün işlemleri yerine getirmek zorunda kalmaz.
    Çekirdek sadece dosyaya ayrılmış sektörleri kullanır. Çünkü bir dosya
    içindeki oyuklar, ayrılmış bir sektör olmadığı anlamına gelir ve
    bunları kullanmaya çalışmak çekirdek için hiç de iyi bir fikir değildir.
   </para>
   <para>
    Aşağıdaki komutla içinde oyuklar olmayan bir takas dosyası
    oluşturabilirsiniz:
   </para>
    <screen>
<prompt>#</prompt> <userinput>dd if=/dev/zero of=/ek-takas bs=1024 count=1024</userinput>
1024+0 records in
1024+0 records out
<prompt>#</prompt>
</screen>
   <para>
    <filename>/ek-takas</filename> takas dosyasının adıdır ve boyutu
    <literal>count=</literal>'dan sonra belirtilmektedir. 4kB'ın
    katlarından oluşan bir alan ayırmak daha uygundur çünkü çekirdek
    bu alana 4 Kb lık boyutlar ile yazma yapar. Şayet 4kB'ın katları
    şeklinde bir alan ayırmazsanız, son bölüm kullanılamayan bir alan
    haline gelebilir.
    </para>
   <para>
    Aslında bir takas bölümü özel bir bölüm değildir. Onu da diğer
    bölümleri yaratır gibi yaratırız, tek fark onun içinde işlenememiş
    bir alan bulunması ve bir dosya sistemi ihtiva etmemesidir. Aslında
    çekirdek için gerekli olmasa da takas alanını tür 82 (linux takas)
    olarak işaretlemek iyi olur.  Bu, bölüm listesinin daha temiz ve kolay
    anlaşılır olmasını sağlayacaktır.
   </para>
   <para>
    Bir swap dosyası veya bölümü oluşturulduktan sonra onun başlangıç
    bölümüne, çekirdek tarafından kullanılan ve bazı yönetim bilgilerini
    içeren, bir imza/iz koymalısınız. Bunun için <command>mkswap</command>
    komutu kullanılır:
   </para>
    <screen>
<prompt>#</prompt> <userinput>mkswap /ek-takas 1024</userinput>
Takas alanı sürüm 1, uzunluk = 1044480 bayt olarak ayarlanıyor
<prompt>#</prompt>
</screen>
   <para>
    Takas dosyası var olmasına rağmen henüz kullanımda değildir.
    Çekirdek bu bölümü sanal bellek sağlaması için kullanmamaktadır.
   </para>
   <warning>
    <para>
     <command>mkswap</command> komutunu kullanırken çok dikkatli olun,
     çünkü bu komut işlem yapacağı bölüm veya dosyanın herhangi bir
     şey içermesine önem vermez. Kolaylıkla son derece önemli bilgiler
     bulunan bir dosya veya bölüm üzerine yazabilirsiniz.  Şans eseri,
     <command>mkswap</command> komutuna sadece işletim sistemini
     kurarken ihtiyaç duyabilirsiniz.
    </para>
   </warning>
   <para>
    Linux bellek yönetimi çeşitli teknik sebeplerden dolayı takas
    alanı boyutunu 127 MB [( 4096-10) * 8*4096= 139890048 byte] ile
    sınırlar. Bununla beraber toplam 8 adet takas alanı kullanabilirsiniz.
   </para>
   <para>
    Aslında bu, şu an için doğru değildir. Yeni çıkan çekirdeklerin ve
    <command>mkswap</command> komutunun yeni sürümlerinin mimarilerine
    göre değişiklik göstermektedir. Takas alanları ile ilgili ayrıntılı
    bilgi <uri xl:href="man8-mkswap"/> kılavuz sayfasında bulunabilir.
   </para>
  </sect1>
  <sect1 xml:id="sag_memory-management-swapusage">
   <title>Bir takas alanının kullanılması</title>
   <para>
    Hazırlanmış bir takas alanı <uri xl:href="man8-swapon"/> ile kullanıma
    sunulur. Bu komutla çekirdeğe takas alanını kullanabileceğini iletiriz.
    Bir fikir olarak, takas alanını yolu da belirtilebilir. Bu komutla geçici
    bir takas dosyası üzerine yazılmaya başlanır.
   </para>
   <screen>
<prompt>#</prompt> <userinput>swapon /ek-takas</userinput>
<prompt>#</prompt>
</screen>
   <para>
    Takas alanları <filename>/etc/fstab</filename> dosyası içinde
    listelenerek otomatik olarak kullanılabilir.
   </para>
   <screen>
/dev/hda8        none        swap        sw     0     0
/swapfile        none        swap        sw     0     0
</screen>
   <para>
    Başlangıç betikleri <command>swapon -a</command> komutunu çalıştıracak
    ve böylece <filename>/etc/fstab</filename> dosyasında listelenmiş bütün
    takas alanları kullanıma açılacaktır. Bununla beraber, <command>swapon</command>
    komutu genellikle ek takas alanına ihtiyaç duyulduğu zamanlarda
    kullanılır.
   </para>
   <para>
    Takas alanı kullanımını <command>free</command> komutu ile
    görüntüleyebilirsiniz.
   </para>
    <screen>
<prompt>$</prompt> <userinput>free</userinput>
             total       used       free     shared    buffers     cached
Mem:        512368     453692      58676      40144      35568     201236
-/+ buffers/cache:     216888     295480
Swap:      1951856          0    1951856
<prompt>$</prompt>
</screen>
   <para>
    Çıktının birinci satırı (<literal>Mem:</literal>) fiziksel belleği
    gösterir. 1 Mb civarı, çekirdek tarafından kullanılan bellek,
    burada gösterilmez.  <literal>used</literal> sütunu kullanılan
    bellek miktarını gösterir (ikinci sıradaki <literal>-/+ buffers/cache:</literal>
    sayılmaz). <literal>free</literal> sütunu  tamamen boş olan alanı
    gösterir. <literal>shared</literal> sütunu çeşitli uygulamalar
    tarafından paylaşılan alanı gösterir. <literal>buffers</literal>
    sütunu ise diskin tampon bellek alanını gösterir.
   </para>
   <para>
    Son satır (<literal>Swap:</literal>) ise takas alanları için
    benzer bilgileri gösterir. Bu alan tamamen sıfır ise bu takas
    alanınızın etkinleştirilmediğini gösterir.
   </para>
   <para>
    Aynı bilgiler <command>top</command> komutu ile veya proc dosya
    sistemindeki <filename>/proc/meminfo</filename> sayesinde de
    elde edilebilir.  Belirli bir takas alanının kullanımı hakkında
    bilgi almak oldukça zordur.
   </para>
   <para>
    Bir takas alanı <command>swapoff</command> ile kullanımdan
    kaldırılabilir. Bu normal olarak gerekli değildir, sadece geçici
    takas alanlarını kaldırmak için kullanılır.  Takas alanı içinde
    öncelikle kullanımdaki sayfalar takas edilir. Bunları tutacak
    yeterli fiziksel bellek yok ise bir diğer takas alanına gönderilir.
    Şayet bu sayfaları tutacak yeterli sanal bellek yok ise Linux
    kıvranmaya başlar. Uzun bir süre sonra kendine gelir fakat bu
    arada sistemi kullanamazsınız.  Kullanımdaki bir takas alanını
    kaldırmadan önce <command>free</command> komutu ile yeterli
    miktarda boş bellek bulunup bulunmadığına bakmalısınız.
   </para>
   <para>
    <command>swapon -a</command> ile otomatik bağlanan bütün takas
    alanları <command>swapoff -a</command> ile kaldırılabilir.
    Sistem neyi kaldıracağını bulmak için <filename>/etc/fstab</filename>
    dosyasının içine bakar. El ile açılmış takas alanları ise kullanılmaya
    devam eder.
   </para>
   <para>
    Bazı zamanlar büyük miktarda  boş fiziksel bellek olmasına rağmen,
    pek çok takas alanı kullanımda olabilir.  Bu olabilir, örneğin: bir
    yerde takas işlemine ihtiyaç vardır ama daha sonra bellekte çok yer
    kaplayan bir süreç  öldürülür ve bellek boşaltılır. Dışarıya takas
    edilmiş bilgi ihtiyaç duyulana kadar geri alınmaz. Bunun için boş
    yere endişe duymaya gerek yoktur fakat ne olup bittiğini bilmek
    rahatlatıcı olabilmektedir.
   </para>
   <sect2 xml:id="sag_memory-management-swapshare">
    <title>Takas alanının başka işletim sistemleriyle paylaşılması</title>
    <para>
     Pek çok işletim sisteminde sanal bellek vardır. Bu alana sadece
     çalıştıkları vakit ihtiyaç duydukları için, çalışmayan işletim
     sistemleri için ayrılmış olan alan boşa israftır. Hepsinin tek bir
     takas alanını paylaşması daha etkili bir çözüm olacaktır. Bu mümkün
     fakat biraz beceri ister.  Bunun nasıl yapılacağına dair bir HOWTO
     (NASIL) belgesi vardır.
    </para>
   </sect2>
  </sect1>
  <sect1 xml:id="sag_memory-management-swap-allocation">
   <title>Takas alanının ayrılması</title>
   <para>
    Bazı insanlar size, sahip olduğunuz RAM miktarının iki katı kadar bir
    takas alanı ayırmanızı söyleyebilir. Bu tamamen geçersiz/sahte bir
    kuraldır.  Bunun doğru bir şekilde nasıl yapılacağı aşağıda
    anlatılmaktadır.
   </para>
   <itemizedlist>
    <listitem>
     <para>
      Yaklaşık bellek ihtiyacınızı belirleyin. Bu genellikle bir seferde
      çalıştıracağınız uygulamaların ihtiyaç duyacağı toplam RAM
      miktarıdır. Yani bir seferde en fazla ne kadar belleğe ihtiyacınız
      olduğunu bulun. Bunu aynı anda çalıştırmak istediğiniz uygulamaları
      çalıştırarak öğrenebilirsiniz.
     </para>
     <para>
      Şayet X oturumunu çalıştırmak istiyorsanız 8MB, gcc için, bazı
      zamanlar 10 MB civarı belleğe ihtiyaç duysa da,  genellikle 4 MB.
      Çekidek 1MB alanı kendine ayırır. Kabuklar ve diğer birkaç araç
      yüzlerce KB yer ister - bunu da 1 Mb olarak kabul edebiliriz.
      Bunu tam olarak tahmin etmek gereksizdir, kabaca ne kadarlık bir
      belleğe ihtiyaç duyduğumuzu  bulmak yeterli olacaktır. Fakat siz
      kötümserlerin yanında yer almak isteyebilirsiniz.
     </para>
     <para>
      Aklınızdan çıkarmayın ki; sistemde birden fazla kullanıcı aynı anda
      yer alacaksa, hepsi ayrı ayrı bellek tüketeceklerdir. Bununla beraber,
      iki kişi aynı anda aynı uygulamayı kullanıyorsa; aynı veri ve
      kütüphaneleri kullanıyor olacaklarından bellek tüketimi iki kat
      olmayacaktır.
     </para>
     <para>
      Bellek ihtiyaçlarını değerlendirmek için <command>free</command> ve
      <command>ps</command> komutları oldukça uygundur.
     </para>
    </listitem>
    <listitem>
     <para>
      Birinci adımda anlatılan değerlendirmeler için bir parça yanılma
      payı ekleyin. Büyük ihtimalle kullanmak istediğiniz bazı
      uygulamaları bu hesaplama sırasında unutabilirsiniz, bazılarının
      gereksinimlerini yanlış hesaplayabilirsiniz veya ileride daha fazla
      alan ihtiyacı duyabilirsiniz.  Birkaç MB disk alanını fazladan
      ayırmak her zaman iyi olur. Çok küçük bir takas alanı yapmaktansa,
      biraz büyük bir alan yaratmak her zaman daha iyidir. Ama bunu da
      fazla abartıp bütün diski takas alanı olarak ayırmayın. Unutmayın ki
      kullanılmayan alan boşa gitmiş sayılır. Daha sonradan da takas
      alanına ekleme yapılabileceğini göz önünde bulundurun. Tam sayılarla
      uğraşmak daha kolay olacağından ihtiyaç duyulan alan hesaplamasını
      yuvarlayabilir, bir MB büyük alabilirsiniz.
     </para>
    </listitem>
    <listitem>
     <para>
      Yukarıdaki karşılaştırmalar ve hesaplamalar sonucu şu an ne kadarlık
      bir belleğe ihtiyaç duyabileceğinizi biliyor olmalısınız.
      Yerleştireceğiniz takas alanını hesaplamak için, toplam ihtiyaç
      duyulan alandan fiziksel belleği çıkarın. Kalan sonuç takas alanının
      boyutunu belirtir. Bazı Unix sürümlerinde bu alanı RAM'in bir
      yansıması gibi yerleştirmeniz gerekeceğinden, ikinci basamakta
      hesaplanan alan sizin ihtiyacınızı gösterecek ve çıkartma işlemine
      gerek kalmayacaktır.
     </para>
    </listitem>
    <listitem>
     <para>
      Şayet hesaplarınız sonucu ortaya çıkan takas alanı, fiziksel
      belleğinizin bir kaç katıysa, yeni bir RAM eklemenin zamanı
      gelmiş demektir. Aksi taktirde performansta çok büyük bir düşüş
      yaşayabilirsiniz.
     </para>
    </listitem>
   </itemizedlist>
   <para>
    Hiç ihtiyacınız olmasa bile bir parça takas alanına sahip olmak iyi
    olur. Linux, takas alanını oldukça tasarruflu bir biçimde kullanır ve
    bu size mümkün mertebe boş bir fiziksel bellek sağlar. Takas ihtiyacı
    olmasa bile, Linux kullanılmayan bellek sayfalarını takas alanına
    gönderir. Bu sayede, disk pasif halde iken takas yapılarak takasa
    ihtiyaç duyulduğu anlarda bekleme yapılması önlenir.
   </para>
   <para>
    Takas alanı çeşitli diskler arasında bölünebilir. Bazı zamanlarda,
    disklerin hızları ve erişim durumlarına göre,  bu performans artışı
    sağlayabilir. Birkaç değişik alternatif alan tablosu ile uğraşmak
    isteyebilirsiniz ama bunun oldukça zor bir iş olduğunu ve aslında
    hiç birinin diğerine karşı büyük bir üstünlüğünün olmadığını unutmayın.
    Asla tam doğruyu bulamazsınız.<footnote><para>
    Ç.N.: Dizüstü/masaüstü kullanıcısıysanız, gün gelir kış uykusunu
    (hibernation) keşfedersiniz ve çalışması için takas alanının belleğinizin
    2 katı olması gerektiğini öğrenirsiniz ve eski bildikleriniz uçar gider.</para></footnote>
   </para>
  </sect1>
  <sect1 xml:id="sag_memory-management_buffer-cache">
   <title>Tampon bellek</title>
   <para>
    Bir diskten okumak gerçek bellekten okumaktan çok daha yavaştır.
    Ek olarak, nispeten kısa zaman aralıkları ile aynı disk yüzeyi
    tekrar tekrar okunacaktır.  Örneğin birisi; evvelce gelmiş bir iletiyi
    okuyabilir, daha sonra cevaplarken metin düzenleyiciden o
    iletiyi okur ve postalarken, sistemin eposta dizinine bir kopyasının
    konması için onu okutabilir. Veya <command>ls</command> komutunun
    bir sistem üzerinde kullanıcılar tarafından ne kadar sıklıkla
    kullanıldığını bir düşünün.  Diskten bir kere okutup, bu bilgiyi
    işi bitince bellekte tutmak yöntemiyle sistem hızını artırabiliriz
    fakat önce okuyun. Bu işleme <glossterm>disk tamponlanması</glossterm>
    ve bu iş için kullanılan belleğe <glossterm>tampon bellek</glossterm>
    denir.
   </para>
   <para>
    Bellek sınırlı ve kıt kaynaklara sahip olduğu için tampon bellek
    yeterli büyüklükte olamaz (ihtiyaç duyulan tüm bilgileri bir seferde
    okutmak için). Tampon dolduğu zaman, uzun süre kullanılmayan bilgiler
    yeni bilgilerin alınabilmesi için silinir.
   </para>
   <para>
    Disk tamponlama tabii ki yazarak çalışır. Bir yanda, sık sık yazılan
    ve hemen ardından okunan bir bilgiyi (örneğin; bir dosyaya kopyalanan
    bir kaynak kodu dosyası ve ardından onu okuyan derleyici uygulama)
    tampon belleğe yerleştirmek iyi bir fikir olabilir.  Diğer yandan,
    bilgiyi tampona yerleştirerek yazma işleminin bir seferde yapılmasını
    sağlayamazsınız çünkü yazma işlemi oldukça yavaştır.  Yazma işlemi,
    diğer uygulamaları yavaşlatmaksızın, artalanda  yapılır.
   </para>
   <para>
    Pek çok işletim sistemi bu isimle anılmasa da bir önbelleğe sahiptir.
    Fakat çalışma prensipleri farklı olabilir. Bazıları <glossterm>doğrudan
    yazma</glossterm> (write-through) prensibiyle, bilgiler önbellek içinde
    saklanırken diske bir seferde yazma işlemini yapar; yazma işlemi daha
    sonra yapılan önbellekler <glossterm>arkadan yazma</glossterm>
    (write-back) olarak adlandırılır.  Arkadan yazma, doğrudan yazma
    işlemine göre daha etkili ama hatalara daha meyillidir. Şayet sistem
    kilitlenirse, elektrik kesilirse, genellikle önbellek
    içinde yapılan değişiklikler kaybolur.  Belki de yazılamayan bilgiler
    çok önemli muhasebe/kayıt bilgileri içermekteydi. Bu yüzden de dosya
    sistemi tam kapasite kullanıma geçemiyor da olabilir.
   </para>
   <para>
    Bu sebeplerden dolayı sistemi her zaman normal bir şekilde kapatın.
    (<xref linkend="sag_boots-and-shutdowns"/> bölümüne de bakın.)
    Bağlı bir çıkarılabilir diski <command>umount</command> komutu ile sistemden ayırmadan yuvasından çıkarmayın, elektrik akımını sistem açıkken
    kapatmayın, disk sürücünün işini bitirmesini bekleyin.
    <command>sync</command> komutu önbelleğe baskı uygular ve bütün
    yazılmamış ama yazılması gereken bilgilerin disk üzerine yazılmasını
    sağlar. Bu komutla işlemin tam yapıldığından emin olabilirsiniz.
    Geleneksel Unix sistemlerinde her 30 saniyede bir <command>sync</command>
    komutunun çalışmasını sağlayan <command>update</command> isimli
    bir uygulama bulunur. Bu uygulama arka planda çalışır ve bu sayede
    <command>sync</command> komutunu kullanmanıza gerek kalmaz.
    Linux <command>sync</command>'in ağır disk G/Ç hatalarına sebep
    olması nedeniyle meydana gelen ani donmaları önlemek amacıyla
    daha etkili ve doğru <command>sync</command> sinyali gönderilmesini
    sağlayan <command>bdflush</command>  isimli bir uygulamayı kullanır.
   </para>
   <para>
    Linux altında <command>bdflush</command>,  <command>update</command>
    tarafından başlatılır. Genellikle endişelenecek bir durum olmaz ama
    her hangi bir sebepten dolayı <command>bdflush</command> durur ise,
    çekirdek sizi uyaracaktır. Bunu <command>/sbin/update</command>
    kullanarak elle yeniden başlatabilirsiniz.
   </para>
   <para>
    Önbelleğin etkili olamamasının sebebi onun boyutlarına bağlıdır.
    Çok küçük bir önbellek içinde bulunan bilgiler tekrar kullanılamadan,
    yeni gelenlere yer açmak için silinecektir. Kritik alan; aynı bilgiye
    hangi sıklıkla ulaşıldığı, ne kadar bilgi okunup yazıldığıdır.
   </para>
   <para>
    Sabit boyutta bir önbellek alanınız varken onu çok büyük bir hale
    getirmek iyi olmayabilir. Çünkü bu gerçek belleğin boş alanının
    kısıtlanmasına ve çok yavaş olan takas işlemine ihtiyaç duyulmasına
    sebep olabilir.  Gerçek belleğin daha verimli kullanılması için,
    Linux otomatik olarak boştaki bütün RAM alanını disk önbelleği
    olarak ayırır ve kullanır. Şayet bir uygulama RAM alanına ihtiyaç
    duyarsa Linux önbellek alanını otomatik olarak küçültür.
   </para>
   <para>
    Linux altında çalışırken önbelleği kullanmak için özel bir işlem
    yapmanız gerekmez, her şey otomatik olarak yapılmaktadır. Kapatma
    ve disk ayırma işlemlerini  düzgün uyguladığınız sürece, hiçbir
    şey hakkında endişelenmeniz gerekmez.
   </para>
  </sect1>
 </chapter>
 <chapter xml:id="sag-system-monitoring">
  <title>Sistemin İzlenmesi</title>
  <preliminary>
   <blockquote>
    <para>"Bu senin için, Nöbetçi!" - Süngerbob Karepantolon</para>
   </blockquote>
   <para>
    Bir sistem yöneticisinin sahip olduğu en önemli sorumluluklardan biri,
    sistemlerini izlemektir. Bir sistem yöneticisi olarak, herhangi bir
    zamanda sisteminizde neler olup bittiğini öğrenme yeteneğinize
    ihtiyacınız olacak. Şu anda kullanılan sistem kaynaklarının yüzdesi,
    hangi komutların çalıştırıldığı veya kimin oturum açtığı gibi.
    Bu bölümde, sisteminizi nasıl izleyeceğinizi ve bazı durumlarda ortaya
    çıkabilecek sorunları nasıl çözeceğinizi ele alacağız.
   </para>
   <para>
    Bir başarım sorunu ortaya çıktığında dikkate alınması gereken 4 ana
    alan vardır: CPU, Bellek, Disk G/Ç ve Ağ. Darboğazın nerede olduğunu
    belirleme yeteneği size çok zaman kazandırabilir.
   </para>
  </preliminary>
  <sect1 xml:id="sag-system-resources">
   <title>Sistem Kaynakları</title>
   <para>
    Sisteminizin başarımını izleyebilmek çok önemlidir. Sistem kaynakları
    çok azalırsa, birçok soruna neden olabilir. Sistem kaynakları, bireysel
    kullanıcılar tarafından veya sisteminizin barındırabileceği e-posta veya
    HTML sayfaları gibi hizmetler tarafından kullanılabilir. Neler olduğunu
    bilme yeteneği, sistem yükseltmelerinin gerekip gerekmediğini veya bazı
    hizmetlerin başka bir makineye taşınması gerekip gerekmediğini
    belirlemeye yardımcı olabilir.
   </para>
   <sect2 xml:id="sag-top">
    <title><literal>top</literal> komutu</title>
    <para>
     Bu komutlardan en yaygın olanı <uri xl:href="man1-top"/> komutudur. <command>top</command>, sürekli olarak güncellenen sistem kaynakları kullanım raporunu görüntüler.
   </para>
   <screen>
<prompt>#</prompt> <userinput>top</userinput>
12:10:49  up 1 day,  3:47,  7 users,  load average: 0.23, 0.19, 0.10
125 processes: 105 sleeping, 2 running, 18 zombie, 0 stopped
CPU states:   5.1% user   1.1% system   0.0% nice   0.0% iowait  93.6% idle
Mem:   512716k av,  506176k used,    6540k free,       0k shrd,   21888k buff
Swap: 1044216k av,  161672k used,  882544k free                  199388k cached

  PID USER     PRI  NI  SIZE  RSS SHARE STAT %CPU %MEM   TIME CPU COMMAND
 2330 root      15   0  161M  70M  2132 S     4.9 14.0  1000m   0 X
 2605 weeksa    15   0  8240 6340  3804 S     0.3  1.2   1:12   0 kdeinit
 3413 weeksa    15   0  6668 5324  3216 R     0.3  1.0   0:20   0 kdeinit
18734 root      15   0  1192 1192   868 R     0.3  0.2   0:00   0 top
 1619 root      15   0   776  608   504 S     0.1  0.1   0:53   0 dhclient
    1 root      15   0   480  448   424 S     0.0  0.0   0:03   0 init
    2 root      15   0     0    0     0 SW    0.0  0.0   0:00   0 keventd
    3 root      15   0     0    0     0 SW    0.0  0.0   0:00   0 kapmd
    4 root      35  19     0    0     0 SWN   0.0  0.0   0:00   0 ksoftirqd_CPU0
    9 root      25   0     0    0     0 SW    0.0  0.0   0:00   0 bdflush
    5 root      15   0     0    0     0 SW    0.0  0.0   0:00   0 kswapd
   10 root      15   0     0    0     0 SW    0.0  0.0   0:00   0 kupdated
   11 root      25   0     0    0     0 SW    0.0  0.0   0:00   0 mdrecoveryd
   15 root      15   0     0    0     0 SW    0.0  0.0   0:01   0 kjournald
   81 root      25   0     0    0     0 SW    0.0  0.0   0:00   0 khubd
 1188 root      15   0     0    0     0 SW    0.0  0.0   0:00   0 kjournald
 1675 root      15   0   604  572   520 S     0.0  0.1   0:00   0 syslogd
 1679 root      15   0   428  376   372 S     0.0  0.0   0:00   0 klogd
 1707 rpc       15   0   516  440   436 S     0.0  0.0   0:00   0 portmap
 1776 root      25   0   476  428   424 S     0.0  0.0   0:00   0 apmd
 1813 root      25   0   752  528   524 S     0.0  0.1   0:00   0 sshd
 1828 root      25   0   704  548   544 S     0.0  0.1   0:00   0 xinetd
 1847 ntp       15   0  2396 2396  2160 S     0.0  0.4   0:00   0 ntpd
 1930 root      24   0    76    4     0 S     0.0  0.0   0:00   0 rpc.rquotad
</screen>
    <para>
     Raporun üst kısmında sistem süresi, çalışma süresi, işlemci (CPU)
     kullanımı, fiziksel ve takas bellek kullanımı ve süreç sayısı gibi
     bilgiler listelenir. Aşağıda, işlemci kullanımına göre sıralanmış
     işlemlerin bir listesi bulunmaktadır.
    </para>
    <para>
     Çalışırken <command>top</command> çıktısını değiştirebilirsiniz.
     <option>i</option>'ye basarsanız, <command>top</command> artık boşta olan
     süreçleri göstermez. Tekrar görmek için tekrar <option>i</option> tuşuna
     basın. <option>M</option>'ye basmak, bellek kullanımına göre sıralar,
     <option>S</option> süreçlerin ne kadar süredir çalıştığına göre
     sıralar ve <option>P</option> tekrar işlemci kullanımına göre sıralar.
    </para>
    <para>
     Görüntüleme seçeneklerine ek olarak, süreçleri <command>top</command> komutundan da değiştirebilirsiniz. Belirli bir kullanıcının sahip olduğu süreçleri görüntülemek için <option>u</option>'yu, süreçleri sonlandırmak için <option>k</option>'yı ve yeniden önceliklendirmek için <option>r</option>'yi kullanabilirsiniz.
    </para>
    <para>
     Süreçler hakkında daha ayrıntılı bilgi için <filename>/proc</filename> dosya sistemine bakabilirsiniz. <filename>/proc</filename> dosya sisteminde, sayısal adlara sahip bir dizi alt dizin bulacaksınız. Bu dizinler, o anda çalışan işlemlerin süreç kimlikleriyle ilişkilendirilir. Her dizinde, süreç hakkında bilgi içeren bir dizi dosya bulacaksınız.
    </para>
    <para>
     <filename>/proc</filename> DİZİNİNDEKİ DOSYALARDA DEĞİŞİKLİK YAPMAMALISINIZ, YAPARSANIZ SİSTEM SORUNLARINA SEBEP OLABİLİR!
    </para>
   </sect2>
   <sect2 xml:id="sag-iostat">
    <title><literal>iostat</literal> komutu</title>
    <para>
     <uri xl:href="man1-iostat"/>, geçerli CPU yük ortalamasını ve disk
     G/Ç bilgilerini görüntüler. Bu, disk G/Ç kullanımını izlemek için
     harika bir komuttur.
    </para>
    <screen>
<prompt>#</prompt> <userinput>iostat</userinput>
Linux 2.4.20-24.9 (myhost)       12/23/2003

avg-cpu:  %user   %nice    %sys   %idle
          62.09    0.32    2.97   34.62

Device:            tps   Blk_read/s   Blk_wrtn/s   Blk_read   Blk_wrtn
dev3-0            2.22        15.20        47.16    1546846    4799520
</screen>
    <para>
     2.4 çekirdekler için aygıtlar, aygıtın ana ve alt numaralarını kullanan adlardır. Bu durumda listelenen aygıt <filename>/dev/hda</filename>'dır. <command>iostat</command>'ın verileri daha ayrıntılı göstermesini sağlamak için <option>-x</option> seçeneğini kullanın.
    </para>
    <screen>
<prompt>#</prompt> <userinput>iostat -x</userinput>
Linux 2.4.20-24.9 (myhost)       12/23/2003

avg-cpu:  %user   %nice    %sys   %idle
          62.01    0.32    2.97   34.71

Device:  rrqm/s wrqm/s r/s  w/s rsec/s wsec/s rkB/s wkB/s avgrq-sz avgqu-sz await svctm %util
/dev/hdc   0.00   0.00 .00 0.00   0.00   0.00  0.00  0.00     0.00     2.35  0.00  0.00 14.71
/dev/hda   1.13   4.50 .81 1.39  15.18  47.14  7.59 23.57    28.24     1.99 63.76 70.48 15.56
/dev/hda1  1.08   3.98 .73 1.27  14.49  42.05  7.25 21.02    28.22     0.44 21.82  4.97  1.00
/dev/hda2  0.00   0.51 .07 0.12   0.55   5.07  0.27  2.54    30.35     0.97 52.67 61.73  2.99
/dev/hda3  0.05   0.01 .02 0.00   0.14   0.02  0.07  0.01     8.51     0.00 12.55  2.95  0.01
</screen>
    <para>
     <uri xl:href="man1-iostat"/> kılavuz sayfası, bu sütunların her birinin ne anlama geldiğine dair ayrıntılı bir açıklama içerir.
    </para>
   </sect2>
   <sect2 xml:id="sag-ps">
    <title><literal>ps</literal> komutu</title>
    <para>
     <uri xl:href="man1-ps"/> şu anda çalışan süreçlerin bir listesini sağlayacaktır. Bu komutun size sunduğu çok çeşitli seçenekler vardır.
    </para>
    <para>
     Yaygın bir kullanım, şu anda çalışan tüm süreçleri listelemek olacaktır. Bunu yapmak için <command>ps -ef</command> komutunu kullanırsınız. (Bu komutun ekran çıktısı eklenemeyecek kadar büyük, aşağıya yalnızca çıktının bir bölümü alınmıştır.)
    </para>
    <screen>
UID        PID  PPID  C STIME TTY          TIME CMD
root         1     0  0 Dec22 ?        00:00:03 init
root         2     1  0 Dec22 ?        00:00:00 [keventd]
root         3     1  0 Dec22 ?        00:00:00 [kapmd]
root         4     1  0 Dec22 ?        00:00:00 [ksoftirqd_CPU0]
root         9     1  0 Dec22 ?        00:00:00 [bdflush]
root         5     1  0 Dec22 ?        00:00:00 [kswapd]
root         6     1  0 Dec22 ?        00:00:00 [kscand/DMA]
root         7     1  0 Dec22 ?        00:01:28 [kscand/Normal]
root         8     1  0 Dec22 ?        00:00:00 [kscand/HighMem]
root        10     1  0 Dec22 ?        00:00:00 [kupdated]
root        11     1  0 Dec22 ?        00:00:00 [mdrecoveryd]
root        15     1  0 Dec22 ?        00:00:01 [kjournald]
root        81     1  0 Dec22 ?        00:00:00 [khubd]
root      1188     1  0 Dec22 ?        00:00:00 [kjournald]
root      1675     1  0 Dec22 ?        00:00:00 syslogd -m 0
root      1679     1  0 Dec22 ?        00:00:00 klogd -x
rpc       1707     1  0 Dec22 ?        00:00:00 portmap
root      1813     1  0 Dec22 ?        00:00:00 /usr/sbin/sshd
ntp       1847     1  0 Dec22 ?        00:00:00 ntpd -U ntp
root      1930     1  0 Dec22 ?        00:00:00 rpc.rquotad
root      1934     1  0 Dec22 ?        00:00:00 [nfsd]
root      1942     1  0 Dec22 ?        00:00:00 [lockd]
root      1943     1  0 Dec22 ?        00:00:00 [rpciod]
root      1949     1  0 Dec22 ?        00:00:00 rpc.mountd
root      1961     1  0 Dec22 ?        00:00:00 /usr/sbin/vsftpd /etc/vsftpd/vsftpd.conf
root      2057     1  0 Dec22 ?        00:00:00 /usr/bin/spamd -d -c -a
root      2066     1  0 Dec22 ?        00:00:00 gpm -t ps/2 -m /dev/psaux
bin       2076     1  0 Dec22 ?        00:00:00 /usr/sbin/cannaserver -syslog -u bin
root      2087     1  0 Dec22 ?        00:00:00 crond
daemon    2195     1  0 Dec22 ?        00:00:00 /usr/sbin/atd
root      2215     1  0 Dec22 ?        00:00:11 /usr/sbin/rcd
weeksa    3414  3413  0 Dec22 pts/1    00:00:00 /bin/bash
weeksa    4342  3413  0 Dec22 pts/2    00:00:00 /bin/bash
weeksa   19121 18668  0 12:58 pts/2    00:00:00 ps -ef
</screen>
    <para>
     İlk sütun sürecin sahibini gösterir. İkinci sütun süreç kimliğidir.
     Üçüncü sütun, üst süreç kimliğidir. Bu, süreci oluşturan veya başlatan
     süreçtir. Dördüncü sütun işlemci kullanımıdır (yüzde olarak). Beşinci
     sütun, süreç yeterince uzun süredir çalışıyorsa, başlatma tarihidir.
     Altıncı sütun, varsa, işlemle ilişkili tty'dir. Yedinci sütun topyekün
     işlemci kullanımıdır (çalışırken kullanılan toplam işlemci süresi).
     Sekizinci sütun, komutun kendisidir.
    </para>
    <para>
     Bu bilgilerle, sisteminizde tam olarak neyin çalıştığını görebilir ve boşta kalmış veya sorunlara neden olan süreçleri sonlandırabilirsiniz.
    </para>
   </sect2>
   <sect2 xml:id="sag-vmstat">
    <title><literal>vmstat</literal> komutu</title>
    <para>
     <uri xl:href="man1-vmstat"/> komutu, sistem süreçleri, bellek,
     takas, G/Ç ve işlemciler için istatistikleri gösteren bir rapor
     gösterecektir. Bu istatistikler, komutun en son çalıştırıldığı
     zamandan itibaren elde edilen veriler kullanılarak oluşturulur.
     Hiç komut çalıştırılmaması durumunda, sistemin yeniden
     başlatılmasından itibaren elde edilen veriler kullanılır.
    </para>
    <screen>
<prompt>#</prompt> <userinput>vmstat -a</userinput>
procs -----------memory---------------swap-- -----io--- -system-- ------cpu-----
 r  b   swpd    free   inact active si   so    bi    bo   in   cs us sy id wa st
 1  0      0 2328840 3067588 638812  0    0     8     5   66  210  1  0 98  0  0
</screen>
    <para>
     Aşağıdakiler <uri xl:href="man1-vmstat"/> kılavuz sayfasından
     alınmıştır.
    </para>
    <glosslist><title>ALAN AÇIKLAMALARI</title>
     <glossentry>
      <glossterm><option>procs</option> (Süreçler)</glossterm>
      <glossdef>
       <simpara>
        r: Çalıştırılabilir süreçlerin sayısı (çalışan veya çalışmayı bekleyen).
       </simpara>
       <simpara>
        b: G/Ç işlemlerinin tamamlanmasını bekleyen engellenen süreçlerin sayısı.
       </simpara>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm><option>memory</option> (Bellek)</glossterm>
      <glossdef>
       <simpara>
        Bunlar <option>--unit</option> seçeneğinden etkilenir.
       </simpara>
       <simpara>
        swpd: kullanılan takas belleği miktarı.
       </simpara>
       <simpara>
        free: kullanılmamış bellek miktarı.
       </simpara>
       <simpara>
        buff: tampon olarak kullanılan bellek miktarı.
       </simpara>
       <simpara>
        cache: önbellek olarak kullanılan bellek miktarı.
       </simpara>
       <simpara>
        inact: etkin olmayan bellek miktarı. (<option>-a</option> seçeneği)
       </simpara>
       <simpara>
        active: etkin bellek miktarı. (<option>-a</option> seçeneği)
       </simpara>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm><option>swap</option> (Takas)</glossterm>
      <glossdef>
       <simpara>
        Bunlar <option>--unit</option> seçeneğinden etkilenir.
       </simpara>
       <simpara>
        si: Diskten takas edilen bellek miktarı/saniye.
       </simpara>
       <simpara>
        so: Diske takas edilen bellek miktarı/saniye.
       </simpara>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm><option>I/O</option> (G/Ç)</glossterm>
      <glossdef>
       <simpara>
        bi: Blok aygıtından alınan blok miktarı/saniye.
       </simpara>
       <simpara>
        bo: Blok aygıtına gönderilen blok miktarı/saniye.
       </simpara>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm><option>system</option> (Sistem)</glossterm>
      <glossdef>
       <simpara>
        in: Sistem sayacı dahil, saniyedeki sistem kesmesi sayısı.
       </simpara>
       <simpara>
        cs: Saniyedeki bağlam değiştirme sayısı.
       </simpara>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm><option>cpu</option> (İşlemci)</glossterm>
      <glossdef>
       <simpara>
        Bunlar, toplam işlemci süresinin yüzdeleridir.
       </simpara>
       <simpara>
        us: Çekirdek dışı kod çalıştırmak için harcanan süre. (kullanıcı zamanı, çalışma süresi dahil)
       </simpara>
        <simpara>
        sy: Çekirdek kodunu çalıştırmak için harcanan süre. (Sistem zamanı)
       </simpara>
       <simpara>
        id: Boşta geçirilen süre. Linux 2.5.41'den önce buna G/Ç bekleme süresi dahildir.
       </simpara>
        <simpara>
         wa: G/Ç beklerken geçen süre. Linux 2.5.41'den önce, boşta geçen süre dahildir.
       </simpara>
       <simpara>
        st: Sanal bir makineden çalınan zaman. Linux 2.6.11 öncesi, bilinmiyor.
       </simpara>
       </glossdef>
     </glossentry>
    </glosslist>
   </sect2>
   <sect2 xml:id="sag-lsof">
    <title><literal>lsof</literal> komutu</title>
    <para>
      <uri xl:href="man8-lsof"/> komutu, kullanımda olan her dosyanın bir
      listesini gösterir. Linux her şeyi bir dosya olarak kabul ettiğinden,
      bu liste çok uzun olabilir. Ancak, bu komut sorunların tanılanmasında
      yararlı olabilir. Bunun bir örneği, bir dosya sistemini ayırmak
      istemeniz, ancak size bunun kullanımda olduğunun bildirilmesidir. Kimin
      kullandığını görmek için dosya sisteminin adı ile bu komutu ve <uri
       xl:href="man1-grep"/>'i kullanabilirsiniz.
    </para>
    <para>
     Veya belirli bir süreç tarafından kullanılan tüm dosyaları görmek
     istediğinizi varsayarsak <command>lsof -p</command> <replaceable>süreç-
     kimliği</replaceable> komutunu kullanabilirsiniz.
    </para>
   </sect2>
   <sect2 xml:id="sag-more-utils">
    <title>Daha Fazla Yardımcı Araç Bulmak</title>
    <para>
     Hangi komut satırı araçlarının mevcut olduğu hakkında daha fazla bilgi
     edinmek için Kıvılcım Hindistan, <link
     xl:href="/howto/kitapcik.html">Linux Kitapçığı</link> adlı bir
     başvuru kılavuzu yazdı. Hangi araçların olduğunu ve bir dizi görevi
     nasıl yapacağınızı öğrenmek için iyi bir kaynaktır.
    </para>
   </sect2>
  </sect1>
  <sect1 xml:id="sag-fs-usage">
   <title>Dosya Sistemi Kullanımı</title>
   <para>
    Şu anda çoğu yerde, depolamanın ne kadar ucuzladığından bahsediliyor,
    ancak bizim gibiler için yeterince ucuz değil, çoğumuzun sınırlı bir
    alanı var ve onu izleyebilmemiz, nasıl kullanıldığını denetleyebilmemiz
    gerekiyor.
   </para>
   <sect2 xml:id="sag-df">
    <title><literal>df</literal> komutu</title>
    <para>
     <uri xl:href="man1-df"/>, disk kullanımını görüntülemek için en basit araçlardan biridir. Basitçe  <command>df</command> yazın ve tüm bağlı dosya sistemleriniz için 1K bloklar halinde disk kullanımı gösterilsin:
    </para>
    <screen>
<prompt>user@server:~></prompt> <userinput>df</userinput>
Dosyasistemi     1K-blok     Dolu      Boş Kull% Bağlanılan yer
/dev/hda3        5242904   759692  4483212   15% /
tmpfs             127876        8   127868    1% /dev/shm
/dev/hda1         127351    33047    87729   28% /boot
/dev/hda9       10485816    33508 10452308    1% /home
/dev/hda8        5242904   932468  4310436   18% /srv
/dev/hda7        3145816    32964  3112852    2% /tmp
/dev/hda5        5160416   474336  4423928   10% /usr
/dev/hda6        3145816   412132  2733684   14% /var
</screen>
    <para>
     Çıktıyı "daha anlaşılır" biçimde görmek için <option>-h</option>'yı
     kullanabilirsiniz. Değerler dosya sisteminin boyutuna bağlı olarak
     K, M veya G birimleri ile gösterilecektir. Ayrıca, blok boyutunu
     belirtmek için <option>-B</option>'yi de kullanabilirsiniz.
    </para>
    <para>
     Alan kullanımına ek olarak, kullanılabilir ve kullanılmış dosya indisi
     düğümlerinin sayısını da görüntülemek için <option>-i</option>
     seçeneğini kullanabilirsiniz.
    </para>
    <screen>
<prompt>user@server:~></prompt> <userinput>df -i</userinput>
Dosyasistemi   Dosyaindisi   Dolu     Boş IKull% Bağlanılan yer
/dev/hda3                0      0       0     -  /
tmpfs                31969      5   31964     1% /dev/shm
/dev/hda1            32912     47   32865     1% /boot
/dev/hda9                0      0       0     -  /home
/dev/hda8                0      0       0     -  /srv
/dev/hda7                0      0       0     -  /tmp
/dev/hda5           656640  26651  629989     5% /usr
/dev/hda6                0      0       0     -  /var
</screen>
   </sect2>
   <sect2 xml:id="sag-du">
    <title><literal>du</literal> komutu</title>
    <para>
     Artık dosya sisteminde ne kadar alan kullanıldığını bildiğinize göre,
     bu verilerin nerede olduğunu nasıl öğrenebilirsiniz? Bir dizine veya
     dosyaya göre kullanımı görüntülemek için <uri xl:href="man1-du"/> kullanabilirsiniz. Bir dosya adı belirtmediğiniz sürece,
     <uri xl:href="man1-du"/> ardışık olarak hareket edecektir. Örneğin:
    </para>
    <screen>
<prompt>user@server:~> </prompt><userinput>du file.txt</userinput>
1300    file.txt
</screen>
    <para>
     Veya <command>df</command>'de olguğu gibi  <option>-h</option>'yı kullanabilir ve aynı çıktıyı "daha anlaşılır" biçimde alabilirsiniz.
    </para>
    <screen>
<prompt>user@server:~> </prompt><userinput>du -h file.txt</userinput>
1.3M     file.txt
</screen>
    <para>
     Bir dosya adı belirtilmezse <command>du</command> dosyaları ardışık olarak listeler.
    </para>
    <screen>
<prompt>user@server:~> </prompt><userinput>du -h /usr/local</userinput>
4.0K    /usr/local/games
16K     /usr/local/include/nessus/net
180K    /usr/local/include/nessus
208K    /usr/local/include
62M     /usr/local/lib/nessus/plugins/.desc
97M     /usr/local/lib/nessus/plugins
164K    /usr/local/lib/nessus/plugins_factory
97M     /usr/local/lib/nessus
12K     /usr/local/lib/pkgconfig
2.7M    /usr/local/lib/ladspa
104M    /usr/local/lib
112K    /usr/local/man/man1
4.0K    /usr/local/man/man2
4.0K    /usr/local/man/man3
4.0K    /usr/local/man/man4
16K     /usr/local/man/man5
4.0K    /usr/local/man/man
</screen>
    <para>
     Bu dizinin sadece ne kadar yer kapladığını öğrenmek istiyorsanız,
     <command>-s</command> seçeneğini kullanabilirsiniz.
    </para>
    <screen>
<prompt>user@server:~> </prompt><userinput>du -hs /usr/local</userinput>
210M    /usr/local
</screen>
   </sect2>
  </sect1>
  <sect1 xml:id="sag-monitoring-users">
   <title>Kullanıcıların izlenmesi</title>
   <blockquote>
    <para>
     "Sırf paranoyaksın diye SANMA ki seni aldatmıyorlar..." - Kaynağı
     Bilinmiyor
    </para>
   </blockquote>
   <para>
    Zaman zaman insanların sisteminizde tam olarak ne yaptığını bilmek
    isteyeceğiniz durumlar olacaktır. Belki çok fazla RAM kullanıldığını
    veya çok fazla işlemci etkinliği olduğunu fark etmişsinizdir. Sistemde
    kimlerin olduğunu, neleri çalıştırdıklarını ve ne tür kaynaklar
    kullandıklarını görmek isteyeceksiniz.
   </para>
   <sect2 xml:id="sag-who">
    <title><literal>who</literal> komutu</title>
    <para>
     Sistemde kimin olduğunu görmenin en kolay yolu <uri xl:href="man1-who"/> veya <uri xl:href="man1-w"/> yapmaktır.  <command>who</command>, -->sistemde -->kimin oturum açtığını ve hangi port veya uçbirimde oturum açıldığını listeleyen basit bir araçtır.
    </para>
    <screen>
<prompt>user@server:~></prompt> <userinput> who</userinput>
<computeroutput>
bjones   pts/0        May 23 09:33
wally    pts/3        May 20 11:35
aweeks   pts/1        May 22 11:03
aweeks   pts/2        May 23 15:04
</computeroutput>
</screen>
   </sect2>
   <sect2 xml:id="sag-ps-u">
    <title><literal>ps</literal> komutu, tekrar!</title>
    <para>
     Önceki çıktıda, aweeks kullanıcısının hem <filename>pts/1</filename>
     hem de <filename>pts/2</filename>'de oturum açtığını görebiliriz,
     peki ya ne yaptıklarını görmek istiyorsak?
     <command>ps -u aweeks</command> komutunu verebilir ve aşağıdaki
     çıktıyı alabiliriz:
    </para>
    <screen>
<prompt>user@server:~> </prompt><userinput>ps -u aweeks</userinput>
20876 pts/1    00:00:00 bash
20904 pts/2    00:00:00 bash
20951 pts/2    00:00:00 ssh
21012 pts/1    00:00:00 ps
</screen>
    <para>
     Buradan kullanıcının <command>ps ssh</command> yaptığını görebiliriz.
    </para>
    <para>
     Bu, evvelce incelediğimiz ps'nin takviyeli kullanımıdır.
    </para>
   </sect2>
   <sect2 xml:id="sag-w">
    <title><literal>w</literal> komutu</title>
    <para>
     <command>who</command> ve <command>ps -u</command> komutlarını kullanmaktan daha da kolayı <uri xl:href="man1-w"/> kullanmaktır. <command>w</command> sadece sistemde kimin olduğunu değil, çalıştırdıkları komutları da gösterecektir.
    </para>
    <screen>
<prompt>user@server:~></prompt> <userinput>w</userinput>
aweeks   :0        09:32   ?xdm?  30:09   0.02s -:0
aweeks   pts/0     09:33    5:49m  0.00s  0.82s kdeinit: kded
aweeks   pts/2     09:35    8.00s  0.55s  0.36s vi sag-0.9.sgml
aweeks   pts/1     15:03   59.00s  0.03s  0.03s /bin/bash
</screen>
    <para>
     Buradan çalışan bir <command>kde</command> oturumum olduğunu
     görebiliriz, bir uçbirim üzerinde bu belgede çalışıyorum :-)
     ve bash istemiyle boşta duran başka bir uçbirimim daha var.
    </para>
   </sect2>
  </sect1>
 </chapter>
 <chapter xml:id="sag_boots-and-shutdowns" userlevel="notoc">
  <?dbhtml stop-chunking?>
  <title>Açılışlar ve Kapanışlar</title>
  <preliminary>
   <blockquote>
    <literallayout>
Start me up
Ah... you've got to... you've got to
Never, never never stop
Start it up
Ah... start it up, never, never, never
You make a grown man cry,
 you make a grown man cry
(Rolling Stones)
</literallayout>
   </blockquote>
   <para>
    Bu bölümde açılış ve kapanışlar esnasında Linux içinde neler olduğu
    ve bu işlemin düzgün bir şekilde nasıl yapılacağı anlatılmaktadır.
    Şayet süreçleri düzgün bir şekilde izlemezseniz dosyalar kaybolabilir
    veya bozulabilir.
   </para>
  </preliminary>
  <sect1 xml:id="sag_boots-and-shutdowns_overview">
   <title>Açılışlar ve kapanışlara genel bir bakış</title>
   <para>
    Bilgisayar sistemine enerji verilmesi ve işletim sisteminin yüklenmeye
    başlaması olayına <glossterm>önyükleme</glossterm> (booting) denir.
    İsim, kendini kendini bir bilgisayardan kendi çabası ile çeken bir
    bilgisayar resminden gelmektedir, fakat eylemin kendisi biraz daha
    gerçekçidir.
   </para>
   <para>
    Kendi kendini çekme çabası esnasında ilk önce, işletim sisteminin
    yüklenmesini ve başlatılmasını sağlayan küçük bir kod parçası
    yüklenir. Bu kodlara <glossterm>önyükleyici</glossterm> denir.
    Önyükleyici bir ayrılabilir disk ya da sabit disk üzerinde sabit bir yerde
    bulunur. Bu iki basamaklı işlemin  sebebi, işletim sisteminin
    büyük ve karmaşık olması, fakat bilgisayarın yükleyebildiği kodların
    ilk parçasının küçük olması (birkaç yüz byte) ve donanım
    yazılımların karmaşık hale gelmemesini sağlamaktır.
   </para>
   <para>
    Bilgisayar mimarilerinde bu önyükleme işlemini farklılık gösterir.
    PC'ler için; BIOS, sabit diskten <glossterm>önyükleme
    sektörü</glossterm> diye adlandırılan ilk sektörü okur. Önyükleyici
    bu sektör içindedir.  Böylece işletim sistemi disk üzerinde her
    nerede ise önyükleyiciden bu bilgi okunup o bölümden yüklenir.
   </para>
   <para>
    Linux çekirdeği yüklendikten sonra donanım ve aygıt sürücüleri yüklenir
    ve sonra <command>init</command> çalıştırılır. Kullanıcıların
    bağlanması ve diğer işlerin yapılması için gereken süreçler
    <command>init</command>  tarafından yüklenir.  Bunun ayrıntıları
    aşağıda anlatılmıştır.
   </para>
   <para>
    Bir Linux sistemini kapatmak için, ilk önce çalışan süreçlere;
    işlerini sonlandırıp, kendilerini durdurmaları söylenir. Daha
    sonra dosya sistemleri ve takas alanı ayrılır ve en sonunda
    sistemin kapatıldığını söyleyen bir ileti belirir. Şayet bu
    süreç düzgün bir şekilde takip edilmezse korkunç şeyler olabilir
    ve genellikle olur; en önemlisi dosya sisteminin tampon belleği
    içinde bulunan bütün bilgi kaybolmuş ve sistem istikrarsız bir
    hale dönmüş olabilir. Ve bu nedenle kullanılmaz hale de gelebilir.
  </para>
  </sect1>
  <sect1 xml:id="sag_boots-and-shutdowns_booting">
   <title>Önyükleme sürecine yakından bakalım</title>
   <para>
    Linux işletim sistemini sabit diskten veya bir CD'den
    başlatabilirsiniz. "Kurulum ve Başlatma Kılavuzu"nun (Installation
    and Getting Start Guide) Kurulum bölümü Linux'un nasıl kurulacağını
    ve nasıl istediğiniz şekilde açılış işlemini gerçekleştirebileceğinizi
    anlattır.
   </para>
   <para>
    Bir PC açıldığında BIOS her şeyin sağlıklı bir şekilde çalışıp
    çalışmadığını anlamak için pek çok test yapar<footnote><para>
    Buna kısaca POST (Power On Self Test), açılışta kendi kendini sınama
    adı verilir.</para></footnote> ve daha sonra asıl açılış işlemine
    geçilir.  Bir disk sürücüsü seçip onun ilk sektörünü okur. Seçim sırası
    genelde BIOS yapılandırmasına bağlıdır. Tercih edilen yol şu şekildedir:
    İlk önce sabit diske bakılır, orada önyükleme sektörü yoksa CDROM sürücü
    ve diğer aygıtlara bakılır. Bu ilk sektöre <glossterm>önyükleme
    sektörü</glossterm> denir, şayet bu önyükleme sektörü bir sabit disk
    üzerinde ise buna <glossterm>Ana Önyükleme Sektörü</glossterm>
    (Master Boot Sector - MBR) adı verilir, "Ana" olmasının sebebi, sabit disk
    üzerinde pek çok bölüm ve her bölümün kendine ait bir önyükleme sektörü
    olabilmesidir.
   </para>
   <para>
    Bir sabit diskten açılış yapılırsa önce MBR içindeki kodlar
    bölümleme tablosunu inceler, açılabilir olarak işaretlenmiş
    etkin bölümü bulur, o bölümden önyükleme sektörünü okur ve
    daha sonra bu önyükleme sektörü içindeki kodları çalıştırır.
    Bu önyükleme sektörü içerisinde bulunan kodlar,
    bölüm içerisindeki çekirdeği okur ve onu başlatır.
    Ayrıntılar çeşitli olmakla birlikte; sadece çekirdek için ayrı
    bir bölüme sahip olmak genellikle pek kullanışlı olmaz.
    Çekirdek için ayrı bir bölüm açılırsa, önyükleme sektörü içerisindeki
    kodlar gerekli bilgileri zincirleme bir halde okuyamaz ve dosya
    sistemi onları hangi sektörlere koydu ise oraları bulmak zorunda
    kalır. Bu sorunu çözmenin pek çok yöntemi vardır ama en genel
    kabul göreni grub'dır.  Bunun konumuzla bir alakası yoktur, ama
    grub belgelerine bakmanız yararlı olabilir.
   </para>
   <para>
    Grub ile açılış işleminde, grub yapılandırmasının bulunduğu disk okunur ve buradan öntanımlı çekirdeğin yeri okunarak çekirdek yüklenir.
    Grub ile çeşitli yapılandırmalar mümkündür. Çekirdekler arasında
    seçim yapılabilir, farklı işletim sistemlerini yüklenebilir ve
    açılış esnasında kullanıcının bu işletim sistemlerinden birisini
    seçmesi sağlanabilir.
    </para>
   <para>
    Linux çekirdeği belleğe okunduktan sonra ya da adına ne dersin
    deyin, gerçekte başlatıldıktan sonra, kabaca aşağıdaki olaylar
    gerçekleşir:
   </para>
   <itemizedlist>
    <listitem>
     <para>
      Linux çekirdeği diskte sıkıştırılmış olarak tutulur. Bu nedenle
      ilk önde kendi kendini  çözer. Bu, çekirdeğin başlangıcındaki
      küçük bir yazılımla yapılır.
     </para>
    </listitem>
    <listitem>
     <para>
      Şayet Linux'un tanıdığı ve çeşitli metin kipleri bulunan
      bir ekran kartınız varsa, Linux size hangi metin kipinde çalışmak
      istediğinizi sorar. Çekirdek derlemesi sırasında bir video kipi
      girilebilir ve böylece daima bu kip kullanılır.
     </para>
    </listitem>
    <listitem>
     <para>
      Bundan sonra çekirdek diğer donanımları denetler (sabit disk,
      ağ bağdaştırıcısı, ekran kartı vb) ve bazı donanım sürücülerini
      uygun bir şekilde yapılandırır ve bunu yaparken buldukları ile
      ilgili bir çıktı verir.
     </para>
     <para>
      Bu çıktı sistemdeki donanımlara, kullanılan işletim sistemi
      çeşidine ve yapılmış olan ayarlara göre değişiklik gösterebilir.
     </para>
    </listitem>
    <listitem>
     <para>
      Daha sonra çekirdek kök dosya sistemini bağlamayı deneyecektir.
      Dosya sistemi türü otomatik olarak bulunur. Kök dosya sisteminin
      bağlanması esnasında bir terslik olursa, örneğin: çekirdek içinde
      uygun dosya sistemi sürücüsü yoksa, çekirdek PANİKLER ve sistemi
      kapatır. Aslında yapabileceği başka da bir şey yoktur zaten.
     </para>
     <para>
      Kök dosya sistemi genellikle salt okunur bir şekilde bağlanır.
      Bu dosya sistemi bağlı durumdayken, dosya sisteminin sınanmasını
      sağlar. Oku-yaz kipinde bağlanmış bir dosya sistemi üzerinde
      sınama yapmak hiç de iyi bir fikir değildir. Burada bahsedilen
      sınama işlemi <command>fsck</command> ile yapılır.
     </para>
    </listitem>
    <listitem>
     <para>
      Bundan sonra çekirdek, <command>init</command> (<filename>/sbin/init</filename>) sürecini başlatır (daima süreç numarası olarak 1'i alır).
      <command>init</command> pek çok ufak tefek iş yapar. Aslında
      yaptıkları ne şekilde ayarlandığına bağlıdır.
      <xref linkend="sag_init"/> bölümünde daha ayrıntılı
      bilgi bulabilirsiniz.  En azından, çok gerekli olan birkaç
      artalan sürecini çalıştırır.
     </para>
    </listitem>
    <listitem>
     <para>
      <command>init</command> daha sonra çok kullanıcılı kipe geçer,
      sanal konsollar ve seri bağlantılar için <uri xl:href="man8-agetty"/>
      uygulamasını çalıştırır. <uri xl:href="man8-agetty"/>, kişilerin
      sanal konsollar veya seri hatlar üzerinden sisteme bağlanmasını sağlar.
      <command>init</command> ayrıca nasıl ayarlandığına bağlı olarak
      diğer uygulamaları da çalıştırır.
     </para>
    </listitem>
    <listitem>
     <para>
      Bütün bunlardan sonra açılış işlemi bitmiş olur, artık sistem
      açık ve normal çalışma kipine geçmiş haldedir.
     </para>
    </listitem>
   </itemizedlist>
  </sect1>
  <sect1 xml:id="sag_boots-and-shutdowns-shuts">
   <title>Kapanışla ilgili ayrıntılar</title>
   <para>
    Bir Linux sistemini kapatırken, doğru süreci izlemek çok önemlidir.
    Şayet bunu doğru yapmazsanız, dosya sisteminiz değersiz bir çöp
    yığınına dönebilir. Bunun sebebi, Linux'un bir kerede doğrudan değil de
    daha sonra yazan (write-back) bir disk önbellekleme sistemine
    sahip olmasıdır.  Bu performans artışı sağlamakla birlikte bazı
    sorunları da yanında getirmektedir.  Şayet bir kapris anında
    enerjiyi keserseniz, önbellekte bulunan ama henüz diske yazılmamış
    olan bütün bilgiler yok olup gidecektir.
   </para>
   <para>
    Başka bir sebep de, galeyana gelip artalanda çalışan pek çok sürecin
    olduğu, çok işlevli bir sistemin açma/kapama düğmesine vurursanız, bu
    tam bir yıkım olabilir.  Sistemi uygun bir şekilde kapatarak, artalanda
    çalışan bütün uygulamaların verilerini kurtardığından emin olabiliriz.
   </para>
   <para>
    Bir Linux sistemini kapatmak için gereken komut
    <command>shutdown</command>'dır<footnote><para>Ç.N.: Son çıkan
    bazı donanımlar açma-kapama düğmesine dokunmadan işletim sistemi
    tarafından tamamen kapatılabilmektedir. Bunun için kullanılan
    komut <command>poweroff</command>'tur</para></footnote>.
    Genellikle bunu yapmak için iki yoldan birisi kullanılır.
   </para>
   <para>
    Tek kullanıcısı olduğunuz bir sistemde alışılmış yöntem: çalıştığınız
    bütün uygulamalardan çıkmak, bütün sanal konsollardan çıkıp, root
    kullanıcı olarak tekrar girmek (şayet hali hazırda root olarak
    bağlıysanız orada beklemek - ama kök dizininin veya root'un
    ev dizininin (<filename>/root</filename> dizini) dosya sistemlerinin
    ayrılması sırasında bir sorunla karşılaşmasını önlemek için, o
    dizinlerden başka dizinlere geçin) ve daha sonra
    <command>shutdown -h now</command> komutunu verin (<literal>now</literal>
    parametresi yerine bir artı işaretiyle birlikte dakikaları belirten
    sayılar da kullanabilirsiniz. Böylece, genellikle çok kullanıcılı
    bir sistemde kapanma işlemi istenen süre kadar ertelenmiş olur).
   </para>
   <para>
    Ayrıca, <command>shutdown -h +</command><replaceable>süre
     uyarı</replaceable> komutunu kullanabilirsiniz.
    <replaceable>süre</replaceable> sistemin ne kadarlık bir
    süre sonra kapatılacağını, <replaceable>uyarı</replaceable> ise
    kapatma sebebini belirten küçük bir uyarı metnidir.
   </para>
    <screen>
<prompt>#</prompt> <userinput>shutdown -h +10 'Yeni bir disk ekliyoruz. Sistem 3 saat kapalı kalacak.'</userinput>
<prompt>#</prompt>
</screen>
   <para>
    Bu herkesi, sistemin 10 dakika sonra kapatılacağını ve verilerini
    kaybedebilecekleri konusunda uyarır. Bu uyarı X uçbirimleri dahil
    birilerinin bağlı olduğu bütün uçbirimlere gönderilir. Ve birkaç
    kez daha uyarı gider. Kapanma anı yaklaştıkça uyarılar sıklaşır.
   </para>
    <screen>
Broadcast message from root (ttyp0) Wed Aug  2 01:03:25 1995...

Yeni bir disk ekliyoruz. Sistem 3 saat kapalı kalacak.
The system is going DOWN for system halt in 10 minutes !!
</screen>
   <para>
    Erteleme süresi sonunda gerçek kapatma işlemi başlayınca; kök
    dosya sistemi hariç bütün dosya sistemleri ayrılır, halen bağlı
    kullanıcı olsa bile bütün kullanıcı süreç ve uygulamaları
    öldürülür, artalan süreçleri kapatılır, bütün dosya sistemleri
    ayrılır ve her şey tatlıya bağlanmış olur. Bu yapılırken,
    <command>init</command>  makineyi kapatabileceğinizi söyleyen
    bir ileti yayınlar. Bundan sonra yapmanız gereken tek şey sabit
    disk ve enerji ışığının sönmesini beklemektir.
  </para>
   <para>
    Bazen, nadiren iyi sistemlerde bile, düzgün bir kapanış yapmak
    mümkün olmaz.  Örneğin; şayet çekirdek paniklemişse, çöker ve
    hatalı davranmaya başlar, bu durumda yeni bir komut vermek
    imkansız olabilir.  Düzgün bir şekilde  kapatmanız mümkün
    olmayınca yapabileceğiniz tek şey, başınıza kötü bir şey
    gelmemesini ummak ve sistem enerji düğmesine basmaktır.
    Şayet sorun biraz daha büyükse (örneğin birisi baltası ile
    klavyenize vurduysa) ve çekirdekle <command>update</command> halen
    düzgün bir şekilde çalışıyorsa, <command>update</command>'in
    işlevini yapması ve önbellekte bulunan bilgileri yazılmaya
    zorlaması için birkaç dakika beklemek daha uygun olacaktır.
    Ondan sonra enerjiyi kesebilirsiniz.
   </para>
   <para>
    Bazı insanlar <command>sync</command> komutunu 3 kere ard arda
    kullanıp disk G/Ç'larının bitmesini bekleyip sistemi kapatmayı
    tercih eder. Şayet çalışan bir uygulama yok ise bu işlem
    <command>shutdown</command> komutu ile aynı işi yapmış olur.
    Bununla beraber bu işlem sırasında dosya sistemleri ayrılmadığı
    için ext2fs  "temiz dosya sistemi" bayrağı ile ilgili hatalar
    ortaya çıkabilir. Bu nedenle üçlü <command>sync</command> komutu ile
    sistemi kapatmak <emphasis>tavsiye edilmez</emphasis>.
   </para>
   <note>
    <para>
     Üçlü sync'in sebebi, komutların ayrı ayrı yazıldığı
     Unix'in ilk zamanlarında disk G/Ç işlemlerinin bitmesi için
     yeterli zamanı kazanmaktı.
    </para>
   </note>
  </sect1>
  <sect1 xml:id="sag_boots-and-shutdowns_reboot">
   <title>Sistemin yeniden başlatılması</title>
   <para>
    Sistemi yeniden başlatmak için sistemi kapatıp, elektriği kesip,
    sonra tekrar vererek de yapabilirsiniz. Daha basit bir yol ise,
    sadece kapatmak yerine, <command>shutdown</command> komutunun
    sistemi yeniden başlatmasını sağlamaktır. Bunu <option>-r</option>
    seçeneğini kullanarak yapabiliriz. Örneğin;
    <command>shutdown -r now</command> yazmanız yeterlidir.
   </para>
   <para>
    Pek çok Linux sistemi ctrl+alt+del tuşlarına aynı anda basılmasıyla
    yeniden başlatma işlemini yapabilmektedir.
    Bu <command>shutdown -r now</command> komutunu çalıştırmış olur.
    Bu <uri xl:href="man8-ctrlaltdel"/> tuşları yapılandırılabilir.
    Çok kullanılıcılı bir sistemde bir miktar erteleme vermek uygun
    olacaktır.  Başkalarının fiziksel olarak ulaşabilecekleri yerlerde
    bulunan sistemlerde bu tuşların işlevi kapatılabilir.
   </para>
  </sect1>
  <sect1 xml:id="sag_boots-and-shutdowns_rl3">
   <title>Tek kullanıcı kipi</title>
   <para>
    <command>shutdown</command> komutu sistemi tek kullanıcılı
    hale getirmek için de kullanılabilir. Böylece sisteme sadece
    konsoldan root bağlanır ama başkaları bağlanamaz.  Bu yöntem,
    sistem normal çalışırken yapılamayan, sistem yöneticisi
    görevlerini yapmak için yararlı olabilir.
   </para>
  </sect1>
  <sect1 xml:id="sag_boots-and-shutdowns_bootfloppy">
   <title>Kurtarma Diskleri</title>
   <para>
    CD'den çalışan sistemlerle açılış yaparak sistem kurtarılabilir.
    Yapacağınız böyle bir ISO indirip CD'ye yakmaktır.
   </para>
  </sect1>
 </chapter>
 <chapter xml:id="sag_init">
  <title><literal>init</literal></title>
  <preliminary>
   <blockquote>
    <para>
     "Uuno on numero yksi"       (Bir Finlandiya dizi filmi sloganı.)
    </para>
   </blockquote>
   <para>
    Bu bölümde çekirdek tarafından başlatılan ve ilk kullanıcı seviyeli
    süreç olan <command>init</command> anlatılmaktadır. <command>init</command>
    çok önemli görevlere sahiptir. Örneğin <uri xl:href="man8-agetty"/>
    sürecini başlatır (bu sayede kullanıcılar sisteme bağlanabilir),
    kullanıcı seviyelerini ayarlar, öksüz süreçler ile ilgilenir.
    Bu bölüm <command>init</command>'in nasıl ayarlandığını ve çalışma
    seviyelerinin nasıl kullanılacağını anlatmaktadır.
   </para>
  </preliminary>
  <sect1 xml:id="sag_init_first">
   <title>İlk önce <literal>init</literal> gelir</title>
   <para>
    <command>init</command> bir Linux işletim sistemi için kesinlikle
    gerekli olan uygulamalardan birisidir. Fakat siz bunu halen önemsemiyor
    olabilirsiniz. İyi bir Linux dağıtımı, pek çok sistem altında
    çalışabilecek şekilde ayarlı bir <command>init</command> ile
    birlikte gelir; ve bu sistemler altında <command>init</command>
    ayarları ile uğraşmanız gerekmez. Genellikle, çalışma seviyesini
    değiştirmek istediğiniz zamanlarda, seri uçbirimler üzerinden veya
    modemler üzerinden bağlanmaya çalıştığınız zamanlarda
    <command>init</command> ile ilgilenmeniz gerekir.
   </para>
   <para>
    Çekirdek kendini başlattığı (belleğe yüklendiği, çalışmaya başladığı
    ve aygıt dosyaları, veri yapıları ve benzeri şeyleri başlattığı zaman)
    ve kullanıcı seviyeli bir uygulama olan <command>init</command>
    sürecini başlattığında, kendi üstüne düşen açılış işlemlerini
    bitirmiş olur.  Bundan dolayı <command>init</command> her zaman için
    ilk süreçtir ve süreç numarası da daima 1'dir.
   </para>
   <para>
    Çekirdek, <command>init</command> için daha önceden de kullanılmış
    olan birkaç yere bakar ama genellikle bir Linux sistemi altındaki
    en uygun yer <filename>/sbin/init</filename>'dir. Şayet çekirdek
    <command>init</command>'i bulamazsa <filename>/bin/sh</filename>'yi
    çalıştırmayı dener, eğer bunu da beceremezse sistem hatasını başlatır.
   </para>
   <para>
    <command>init</command> başladığı zaman, idari görevlerce
    gerçekleştirilen; sistemlerinin denetlenmesi,
    <filename>/tmp</filename>'nin boşaltılması, çeşitli hizmetlerin
    başlatılması ve kullanıcıların bağlanabileceği her uçbirim ve sanal
    konsol için <uri xl:href="man8-agetty"/>'nin
    başlatılması vb. işlemlerin başlatılması ile açılış işlemi
    bitirilmiş olur (<xref linkend="sag_log-in-and-out"/> bölümüne bakınız).
   </para>
   <para>
    Sistem düzgünce açıldıktan sonra, <command>init</command> kullanıcı
    tarafından terk edilen her uçbirim için ayrı ayrı bir <uri xl:href="man8-agetty"/>
    süreci başlatılır. Böylece bir sonraki kullanıcı buraya bağlantı
    yapabilir.  <command>init</command> ayrıca her öksüz süreci evlat
    edinir: bir süreç yavru bir süreç başlatır ve bu yavru süreçten önce
    ölürse, bu öksüz yavru süreç  <command>init</command>'in yavrusu olur.
    Bu pek çok teknik sebepten kaynaklanır; bunun böyle olduğunu bilmek
    süreç listesi ve süreç yapı ağacını anlamayı kolaylaştırması açısından
    faydalıdır.
    <footnote><para><command>init</command> kendisinin öldürülmesine
    izin vermez. SIGKILL bile gönderseniz <command>init</command>'i
    öldüremezsiniz.</para></footnote>
    <command>init</command>'in kullanılabilir birkaç çeşidi
    vardır. Pek çok Linux dağıtımı, System V <command>init</command>
    tabanlı <command>sysvinit</command> (Miquel van Smoorenborg tarafından
    yazılmıştır) kullanır.  Unix'in BSD versiyonu farklı bir
    <command>init</command> kullanır. Birinci fark çalışma
    seviyelerindedir:  çalışam seviyeleri System V'de bulunurken,
    BSD'de bulunmazlar (en azından geleneksel olanlarında). Bu temel
    farklılık değildir. Biz sadece <command>sysvinit</command>'e bakacağız.
   </para>
  </sect1>
  <sect1 xml:id="sag_init-getty">
   <title>
    <literal>init</literal>'in <literal>agetty</literal>'yi başlatmak
    için yapılandırılması:  <literal>/etc/inittab</literal> dosyası
   </title>
   <para>
    Başladığı zaman, <command>init</command>
    <filename>/etc/inittab</filename> yapılandırma dosyasını okur.
    Şayet HUP sinyali gönderirseniz,<footnote>
    <para>
     <command>kill -HUP 1</command> komutunu root olarak çalıştırarak
     <command>init</command>'in <filename>/etc/inittab</filename>
     dosyasını yeniden okumasını sağlayabilirsiniz.
    </para></footnote>
    bu dosyayı tekrar okur. Böylece değişikliklerin etkin olması için
    sistemin yeniden başlatılması gerekmez.
   </para>
   <para>
    <filename>/etc/inittab</filename> dosyası biraz karışık bir yapıdadır.
    Biz <uri xl:href="man8-agetty"/> uygulamasının basit yapılandırılması ile başlayalım. <filename>/etc/inittab</filename> satırları iki nokta
    üstüste imleri ile ayrılmış 4 alan içerir:
   </para>
   <screen>
id:çalışma_seviyeleri:eylem:süreç
</screen>
   <para>
    Bu alanlar aşağıda tanımlanmıştır.  Ek olarak
    <filename>/etc/inittab</filename>, boş satırlar ve
    <literal>#</literal> işaretiyle başlayan satırlar içerebilir.
    Tüm bunlar göz ardı edilir.
   </para>
    <variablelist>
     <varlistentry>
      <term>id</term>
      <listitem>
       <para>
        Dosya içerisindeki satırı tanımlar. <uri xl:href="man8-agetty"/>
        satırları için, üzerinde çalıştığı uçbirimleri belirtir (aygıt
        dosya isimlerinde <filename>/dev/tty</filename>'den sonra
        gelen karakterler). Diğer satırlar için bu önemli değildir
        (uzunluk sınırlamaları dışında), fakat bu eşsiz olmalıdır.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>çalışma_seviyeleri</term>
      <listitem>
       <para>
        Bu satırın hangi çalışma seviyeleri için kullanılacağı belirtilir.
        Çalışma seviyeleri tek rakamlarla ayraçsız olarak yanyana verilir.
        Gelecek bölümde bu seviyeler açıklanmıştır.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>eylem</term>
      <listitem>
       <para>
        Satırın ne iş yapacağını belirtir. Örneğin; <literal>respawn</literal>
        ile sonraki alandaki komutun çıkışta tekrar çalıştırılacağını,
        <literal>once</literal> ile ise sadece bir kez çalıştırılacağını
        tanımlarız.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>süreç</term>
      <listitem>
       <para>Çalıştırılacak komut.</para>
      </listitem>
     </varlistentry>
    </variablelist>
   <para>
    Birinci sanal uçbirim üzerinde (<filename>/dev/tty1</filename>),
    normal çok kullanıcılı seviyelerde (2-5) bir
    <uri xl:href="man8-agetty"/> çalıştırmak için şu satırı yazmalıyız:
   </para>
    <screen>
1:2345:respawn:/sbin/getty 9600 tty1
</screen>
   <para>
    Birinci bölüm bu satırın <filename>/dev/tty1</filename> için olduğunu
    belirtir. İkinci bölüm ise 2,3,4 ve 5. çalışma seviyelerinin
    kullanılacağını belirtir. Üçüncü bölüm ise, çıkışta bu komutun tekrar
    çalıştırılması gerektiğini ve böyle bir kullanıcının ayrıldıktan
    sonra isterse tekrar bağlanabilmesinin sağlanacağını belirtir.
    Son bölüm ise bu uçbirim üzerinde <uri xl:href="man8-agetty"/>
    komutunun çalıştırılacağını belirtir. <uri xl:href="man8-agetty"/>
    sürümüne göre çalışma şekli değişik olabilir.
    Kılavuz sayfasına bakmayı unutmayın.
   </para>
   <para>
    Şayet bir sisteme uçbirimler veya aranacak modem hatları eklemek
    isterseniz, <filename>/etc/inittab</filename> dosyasına daha fazla
    satır eklemeniz gerekecektir.  Her uçbirim veya hat için bir satır
    yazmak zorundasınız.  Ayrıntılı bilgi için <command>init</command>,
    <filename>inittab</filename> ve <uri xl:href="man8-agetty"/> kılavuz
    sayfasına bakmanız faydalı olacaktır.
   </para>
   <para>
    Bir komut çalıştırılmaya başlarken hata verirse ve <command>init</command>
    onu tekrar başlatmak için ayarlanmışsa, bu büyük miktarda sistem
    kaynağı tüketir: <command>init</command> komutu başlatır, komut hata
    verir; <command>init</command> komutu tekrar başlatır, komut hata verir;
    init komutu bir daha başlatır, komut yine hata verir ve bu sonsuza
    kadar devam eder. Bunu önlemek için, <command>init</command> bir komutu
    ne sıklıkta tekrar başlatacağının izlerini tutar. Şayet çalıştırma
    sıklığı artarsa, tekrar başlatmadan önce 5 dakika geçmesini bekler.
   </para>
  </sect1>
  <sect1 xml:id="sag_init_runlevels">
   <title>Çalışma seviyeleri</title>
   <para>
    Bir <glossterm>çalışma seviyesi</glossterm> <command>init</command>'in
    durumunu ve sistem hizmetlerinin ne tür işlevler gerçekleştirdiğini
    tanımlayan bir göstergedir. Çalışma seviyeleri
    <xref linkend="sag_run-levels"/> de açıklanmıştır. 2 ile 5 arasındaki
    kullanıcı tanımlı seviyelerin nasıl kullanılacağına dair ortak bir
    karar yoktur.  Bazı sistem yöneticileri, çalışma seviyelerini hangi
    alt sistemlerin çalıştığını göstermek için ayarlar. Örneğin;
    X çalışıyor, ağ etkin, vb. Başkaları bütün alt sistemlerin çalıştığını
    veya  teker teker başlatılıp durdurulduklarını (çalışma seviyesi
    değişmeden) göstermek üzere ayarlayabilir. Buna kendiniz için karar
    vermelisiniz. Ama Linux sisteminizin tanımladığı seviyeleri kullanmak daha
    kolay olabilir.
   </para>
    <table xml:id="sag_run-levels">
     <title>Çalışma seviyesi numaraları</title>
     <tgroup cols="2">
      <tbody>
       <row>
        <entry>0</entry>
        <entry>Sistemi kapatır.</entry>
       </row>
       <row>
        <entry>1</entry>
        <entry>Tek kullanıcılı kip (sistem yöneticisine özel).</entry>
       </row>
       <row>
        <entry>2-5</entry>
        <entry>Kullanıcı tanımlı normal işlev</entry>
       </row>
       <row>
        <entry>6</entry>
        <entry>Sistemi yeniden başlatır.</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   <para>
    Çalışma seviyeleri <filename>/etc/inittab</filename> içinde aşağıdaki
    satıra benzer şekilde ayarlanır:
   </para>
    <screen>
l2:2:wait:/etc/init.d/rc 2
</screen>
   <para>
    İlk bölüm isteğe göre verilmiş bir etikettir, ikinci alan 2.çalışma
    seviyesinin uygulanacağını söyler. Üçüncü bölüm ise <command>init</command>'in
    dördüncü bölümde yer alan komutu bir sefer çalıştırmasını ve çalışma
    seviyesine girildiğinde <command>init</command>'in işlemin
    tamamlanmasını beklemesi söylenir. <filename>/etc/init.d/rc</filename>
    komutu ise 2. çalışma seviyesine girmek için gerekli olan hizmetlerin
   </para>
   <para>
    Dördüncü alandaki komut, bir çalışma seviyesinin başlaması için
    gerekli olan bütün tatsız işleri yapar. Hali hazırda çalışmayan
    hizmetleri çalıştırır ve yeni seviyede daha fazla çalışmasına
    ihtiyaç duyulmayan hizmetleri kapatır. Tam olarak komutun ne
    olduğu ve çalışma seviyelerinin nasıl ayarlandığı Linux dağıtımına
    bağlıdır.
   </para>
   <para>
    <command>init</command> başladığı zaman <filename>/etc/inittab</filename>
    dosyası içinde geçerli çalışma seviyesinin tanımlandığı satırı arar:
   </para>
    <screen>
id:2:initdefault:
</screen>
   <para>
    <literal>single</literal> veya <literal>emergency</literal>
    gibi bir çekirdek komutu vererek, <command>init</command>'ten
    geçerli olarak tanımlanmış çalışma seviyesinden başka bir
    seviyede başlamasını isteyebilirsiniz. Örneğin,  çekirdek komut
    satırı LILO üzerinden de verilebilir. Bu size 1. çalışma seviyesini
    (tek kullanıcılı çalışma seviyesini) seçme şansı verir.
   </para>
   <para>
    Sistem çalışırken <command>telinit</command> komutu ile çalışma
    seviyesini değiştirebilirsiniz. Çalışma seviyesi değiştiğinde,
    <command>init</command>  <filename>/etc/inittab</filename> dosyası
    içinde konuyla ilgili satırı çalıştırır.
   </para>
  </sect1>
  <sect1 xml:id="sag_init_inittab">
   <title><literal>/etc/inittab</literal> içinde özel ayarlamalar</title>
   <para>
    <filename>/etc/inittab</filename> dosyası <command>init</command>'in
    özel durumlara tepki vermesini sağlayacak özel yetenekler içerir.
    Bu özel nitelikler üçüncü alanlar içerisindeki özel kelime/kelime
    grupları tarafından belirlenir. Örneğin:
   </para>
    <variablelist>
     <varlistentry>
      <term>
       <literal>powerwait</literal>
      </term>
      <listitem>
       <para>
        Enerji kesintisi durumunda, <command>init</command>'in sistemi
        kapatmasına izin verir. Burada bir kesintisiz güç kaynağı ve
        bu kaynağı takip edip sonuçları <command>init</command>
        sürecine bildiren bir yazılım kullandığınız varsayılmaktadır.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>ctrlaltdel</literal></term>
      <listitem>
       <para>
        Kullanıcının klavyeden ctrl+alt+del tuşlarına basması durumunda
        <command>init</command> sistemin yeniden başlatılmasını sağlar.
       </para>
       <note>
        <para>
         Sistem yöneticisi ctrl+alt+del tuşlarını istediği başka
         bir şeyi yapması veya hiçbir şey yapmaması için ayarlayabilir.
        </para>
       </note>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>
       <literal>sysinit</literal>
      </term>
      <listitem>
       <para>
        Sistem açılışında çalıştırılacak komut.  Bu komut örneğin
        <filename>/tmp</filename> dizininin temizlenmesini sağlayabilir.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   <para>
    Yukarıdaki liste ayrıntılı bir liste değildir. Bu nedenle
    <filename>inittab</filename> kılavuz sayfasının incelenmesi
    faydalı olabilir.
   </para>
  </sect1>
  <sect1 xml:id="sag_init_rl3-booting">
   <title>Tek kullanıcılı kipte açılış</title>
   <para>
    <glossterm>Tek kullanıcılı kip</glossterm> önemli bir çalışma
    seviyesidir.  Bu kipte iken sadece sistem yöneticisi ve pek az
    sayıda süreç çalışır.  Tek kullanıcılı kip, yönetici görevlerinin
    yerine getirilmesi için gereklidir. Örneğin; <filename>/usr</filename>
    dizini üzerinde <command>fsck</command> çalıştırmak gibi...
    Bu komutu çalıştırırken  disk bölümünün bağlanmamış olması
    gerekmektedir, üstelik kok dosya sistemi için bütün sistem süreçleri
    öldürülmeden bu yapılamaz.
   </para>
   <para>
    Çalışan bir sistem, <command>telinit</command> ile 1. çalışma seviyesi
    istenerek tek kullanıcılı kipe çevrilebilir. Açılış esnasında
    çekirdek komut satırından <literal>emergency</literal>  veya
    <literal>single</literal> kelimeleri girilerek de, <command>init</command>'e öntanımlı açılış seviyesini çalıştırmaması gerektiği
    belirtilebilir (Çekirdek komut satırı sistemin açılışının nasıl
    yapıldığına bağlı olarak değişik şekillerde kullanılabilir).
   </para>
   <para>
    Tek kullanıcılı kip; bazı zamanlar herhangi bir dosya sistemi
    bağlanmadan önce <command>fsck</command> komutunun el ile
    çalıştırılması için gerekli olabilmektedir. Örneğin, bozulmuş
    bir <filename>/usr</filename> bölümü üzerinde yapacağınız her işlem
    onun iyice bozulmasına sebep olabilir. Bu nedenle mümkün olan en
    kısa süre içinde <command>fsck</command> komutunun çalıştırılması
    gerekli olabilir.
   </para>
   <para>
    Şayet başlangıçta otomatik devreye giren <command>fsck</command>
    hata verirse, açılış betikleri <command>init</command>'i tek
    kullanıcılı kipte açılmaya zorlar. Bu <command>fsck</command>
    komutunun otomatik olarak onaramadığı bir dosya sisteminin
    kullanılmasını önlemeye yönelik bir tedbirdir. Bu tür bozulmalar
    gerçekte çok nadiren görülür ve bozulmuş bir sabit disk veya
    deneysel bir çekirdek tarafından meydana getirilir.
   </para>
   <para>
    Bir güvenlik önlemi olarak; düzgün ayarlanmış bir işletim sistemi,
    tek kullanıcılı kipte kabuk çalıştırmadan önce, root
    parolasının girilmesini isteyecektir.
    (Dosya sistemi sorunları nedeniyle <filename>/etc/passwd</filename>
    dosyası bozulmuşsa, girişte parola istenmeyecektir.
   </para>
  </sect1>
 </chapter>
 <chapter xml:id="sag_log-in-and-out">
  <title>Kullanıcı Giriş ve Çıkışları</title>
  <preliminary>
   <blockquote>
    <para>
     "Benim gibi insanları üye olarak kabul eden klüplere girmekle
     ilgilenmiyorum." (Groucho Marx)
    </para>
   </blockquote>
   <para>
    Bu bölümde bir kullanıcının sisteme girişi ve çıkışı esnasında neler
    olduğu açıklanmaktadır. Çeşitli etkileşimli artalan süreçleri, günlük
    dosyaları, ayar dosyaları ve benzeri şeyler ayrıntılı bir biçimde
    anlatılmıştır.
   </para>
  </preliminary>
  <sect1 xml:id="sag_log-in-and-out-w-term">
   <title>Uçbirim üzerinden giriş</title>
   <para>
    <xref linkend="sag_terminal-logins"/> uçbirimler üzerinden
    bağlantıların nasıl yapıldığını göstermektedir. İlk önce,
    <command>init</command> uçbirim veya konsol üzerinden yapılacak
    bağlantıyı sağlamak için bir <uri xl:href="man8-agetty"/> çalıştırır. <uri xl:href="man8-agetty"/> uçbirimi dinler ve kullanıcının
    bağlantı için hazır olduğuna dair bir işaret göndermesini bekler.
    (Genellikle bu işaret kullanıcının klavyeden bir şeyler yazmasıdır).
    Bir kullanıcı tespit ettiği zaman, <filename>/etc/issue</filename>
    içerisinde bulunan "hoş geldin" iletisi ekrana yansıtılır ve bir
    kullanıcı adı girilmesini ister. Kullanıcı ismi alındıktan sonra
    <uri xl:href="man1-login"/> çalıştırılır.
    <uri xl:href="man1-login"/> kullanıcı adını girdi olarak alır ve parola
    girilmesini bekler.Bu bilgiler uyuşursa <uri xl:href="man1-login"/> süreci
    bu kullanıcı için önceden tanımlanmış olan kabuğu çalıştırır, aksi
    taktirde süreci durdurur ve çıkar. (Belki de kullanıcıya yeni bir
    kullanıcı adı ve parolası girmek için bir şans daha verir).
    <command>init</command>, sürecin tamamlandığı uyarısını aldığında
    uçbirim için yeni bir <uri xl:href="man8-agetty"/> çalıştırılmasını sağlar.
   </para>
   <figure xml:id="sag_terminal-logins" floatstyle="1">
    <title>Uçbirim üzerinden giriş</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="images/login-via-terminals-tr.gif"/>
     </imageobject>
     <caption>
      <para>
       <command>init</command>, <uri xl:href="man8-agetty"/>,
       <uri xl:href="man1-login"/> ve kabuk arasındaki etkileşim
      </para>
     </caption>
    </mediaobject>
   </figure>
   <para>
    Unutmayın ki <command>init</command>'in <function>fork</function>
    sistem çağrısını kullanarak yarattığı süreç bir tanedir.
    <uri xl:href="man8-agetty"/> ve <uri xl:href="man1-login"/>,
    süreçte çalışan uygulama ile yer değiştirmektedir
    (<function>exec</function> sistem çağrısı yardımıyla).
   </para>
   <para>
    Seri hatlar üzerindeki kullanıcıları tespit edebilmek için ayrı bir
    uygulamaya ihtiyaç vardır, çünkü bu uçbirimlerin etkin hale geldiğini
    tespit etmek biraz daha karışıktır. <uri xl:href="man8-agetty"/>
    girdilerin çağrıdan çağrıya değiştiği modem bağlantıları için
    çok önemli olan hız ve diğer bağlantı ayarlarına kendini uyarlayabilir.
   </para>
   <para>
    Sevapları ve günahları ile, kullanımda bulunan pek çok çeşit
    <command>init</command> ve <uri xl:href="man8-agetty"/> vardır.
    Sisteminizde bulunan sürümünü ve diğerlerini öğrenmek iyi bir fikir
    olabilir (Bunun için  Linux Software Map - Linux Yazılım Haritası
    kullanılabilir). Sisteme modem üzerinden erişim etkin değilse
    <uri xl:href="man8-agetty"/> hakkında endişelenmenize gerek kalmaz ama
    <command>init</command> önemini korur.
   </para>
  </sect1>
  <sect1 xml:id="sag_log-in-and-out-via-net">
   <title>Ağ üzerinden giriş</title>
   <para>
    Aynı ağ üzerindeki iki ayrı bilgisayar, genellikle tek bir fiziksel
    kablo üzerinden bağlanmıştır. Bu bilgisayarlar ağ üzerinden
    haberleşirken, bu haberleşme işleminde kullanılan ve her bir
    bilgisayarda ayrı ayrı bulunan uygulamalar, bir sanal bağlantı
    üzerinden birbirlerine bağlanmıştır.  Bu bir çeşit hayali
    kablodur.  Bu sanal bağlantı üzerinde bulunan her hangi bir
    bilgisayardaki uygulamalar etkin durumda kaldığı sürece kendi kablosu
    üzerinde tekel konumuna sahip olur.  Bununla beraber bu bağlantılar
    hayali olduğu  için her iki bilgisayarın işletim sistemleri pek çok
    sanal bağlantıyı aynı fiziksel kablo üzerinde paylaştırabilir.
   </para>
   <para>
    Bu yolla çeşitli uygulamalar, diğer iletişimler ile uğraşmak zorunda
    kalmadan, tek bir kablo üzerinden iletişim sağlayabilir. Aynı
    kablo üzerinde çeşitli bilgisayarlara sahip olmak mümkün olmasına
    rağmen, bu iki bilgisayarın kurduğu sanal hat dışında kalan
    bilgisayarlar, parçası olmadıkları bu iletişim işini yok sayar.
   </para>
   <para>
    Bu gerçeğin oldukça karmaşık ve soyut ötesi bir açıklamasıdır. Belki de
    öyledir, ama bununla birlikte, ağ bağlantılarının normal bağlantılardan
    neden değişik olduğunu, daha kolay anlaşılır olmasını sağlamaktadır.
    Değişik bilgisayarlar üzerindeki süreçler birbirleri ile iletişime
    geçmek istedikleri zaman sanal bağlantılar kurulur. Bir ağ üzerindeki
    her hangi bir bilgisayardan diğerine bağlanabilmek yöntem olarak mümkün
    olduğu için çok fazla sayıda olası sanal iletişim mevcuttur.
    Bu nedenledir ki her olası bağlantı için ayrı bir
    <uri xl:href="man8-agetty"/> başlatmak hiç de uygun olmayacaktır.
   </para>
   <para>
    Bütün ağ bağlantılarını denetleyen (ve <uri xl:href="man8-agetty"/>'ye
    karşılık gelen) <command>inetd</command> isimli tek bir süreç vardır.
    Gelen bir ağ bağlantı sinyali aldığı zaman, bu tek bağlantıyı denetim
    altında tutmak için yeni bir süreç başlatır. Orjinal süreç bekler ve
    olası yeni bağlantıları dinlemeye devam eder.
   </para>
   <para>
    Ağ bağlantıları için  birden fazla iletişim protokolü olduğundan dolayı
    bu iş biraz karışıktır. En önemli iki tanesi <command>telnet</command> ve
    <command>rlogin</command>'dir.  Bu bağlantılara ek olarak, FTP,
    Gopher, http gibi, yapılması muhtemel diğer bağlantılar da mevcuttur.
    Belirli bir bağlantı türü için ayrı bir süreç yaratmak etkisiz olacaktır.
    Bu nedenle, bağlantı türlerini tanımlayabilecek ve doğru hizmetlerin
    çalışması için doğru uygulamaları yükleyebilecek tek bir dinleyici
    kullanılır. Bu dinleyici <command>inetd</command> olarak adlandırılır.
    Daha ayrıntılı bilgiyi  <link
    xl:href="http://www.linux.doc.org/LDP/nag2/index.html">Linux Ağ
    Yöntecisinin Kılavuzu</link> isimli e-kitapta bulabilirsiniz.
   </para>
  </sect1>
  <sect1 xml:id="sag_log-in-and-out_what">
   <title><literal>login</literal> ne yapar?</title>
   <para>
    <uri xl:href="man1-login"/> kullanıcı adı ile parolanın
    uyuşup uyuşmadığına bakar ve kabuğun başlatılması, seri
    hatlara izin verilmesi gibi ayarların yapılmasını sağlayarak
    kullanıcıya gerekli ortamı hazırlar.
   </para>
   <para>
    Başlangıç ayarlarının bir parçası da <filename>/etc/motd</filename>
    içindeki günün iletisinin ve elektronik posta kutusunun denetim
    sonuçlarının ekrana yansıtılmasıdır. Bunlar kullanıcının
    ev dizini içerisinde <filename>.hushlogin</filename> isimli bir
    dosya oluşturularak engellenebilir.
   </para>
   <para>
    Şayet <filename>/etc/nologin</filename> isimli bir dosya mevcutsa
    kullanıcı girişleri engellenir. Bu dosya genellikle
    <uri xl:href="man8-shutdown"/> benzeri komutlar tarafından oluşturulur.
    <uri xl:href="man1-login"/> süreci önce bu dosyaya bakar ve şayet
    bulursa kullanıcıların giriş isteklerini reddeder.  Şayet bu dosya var
    ise,  <uri xl:href="man1-login"/> kapanmadan önce, bu dosyanın
    içeriğini uçbirime çıktılar.
   </para>
   <para>
    <uri xl:href="man1-login"/> bütün hatalı bağlantı girişimlerini bir
    sistem günlük kayıt dosyasında tutar (<command>syslog</command>
    üzerinden). Ayrıca root kullanıcı tarafından yapılan bütün bağlantıların
    kayıtlarını tutar.  Bunlar, davetsiz misafirlerin izini sürmek açısından
    oldukça faydalı olabilir.
   </para>
   <para>
    Sisteme giriş yapmış olan (ve halen sistemde bulunan)  herkes
    <filename>/var/run/utmp</filename> içinde listelenir. Bu dosya
    sistem kapatılana veya yeniden başlatılana kadar geçerlidir; sistem
    tekrar açıldığında bu dosyanın içeriği silinmiş olacaktır.
    Bu dosya her kullanıcı ve uçbirimini (veya ağ bağlantısını) ve bazı
    yararlı bilgileri listeler.<command>who</command>, <command>w</command>
    ve diğer benzeri komutlar sistemde bağlı bulunan kullanıcıları
    listelemek için <filename>utmp</filename> içine bakar.
   </para>
   <para>
    Bütün başarılı bağlantılar <filename>/var/log/wtmp</filename> içinde
    kayıtlıdır. Bu dosya sınırsızca büyüyecektir. Bu nedenle düzenli
    olarak temizlenmesi gerekir. Bunun için haftalık temizlik yapacak bir
    <command>cron</command> işi düzenleyebilirsiniz. <command>last</command>
    komutu <filename>wtmp</filename>içerisini tarar.
   </para>
   <para>
    Hem <filename>utmp</filename> hem de <filename>wtmp</filename>
    ikilik biçemdedir ve ne yazık ki özel araçlar olmadan incelemeye
    uygun değillerdir. (Daha ayrıntılı bilgi için <filename>utmp</filename>
    kılavuz sayfasına bakınız.)
   </para>
  </sect1>
  <sect1 xml:id="sag_log-in-and-out_ac">
   <title>Erişim denetimi</title>
   <para>
    Kullanıcı veritabanı geleneksel olarak <filename>/etc/passwd</filename>
    dosyası içerisinde saklanır.  Bazı sistemler gölge (shadow) parolalar
    kullanır ve parolaları <command>/etc/shadow</command> dosyasına
    yönlendirir.  NIS kullanan hesapları paylaşan bilgisayarların
    bulunduğu alanlarda veya kullanıcı veri tabanını saklamak için diğer
    yöntemleri kullananlar; kullanıcı veritabanını merkezi bir yerden
    tüm diğer bilgisayarlara otomatik olarak kopyalıyor olabilir.
   </para>
   <para>
    Kullanıcı veritabanları sadece kullanıcı parolalarını değil,
    kullanıcılar hakkında; ev dizinleri, isimleri ve kullandıkları
    kabuklar gibi bazı ek bilgileri de içerir. Bu diğer bilgiler
    topluma açık olmalıdır, böylece herkes okuyabilir. Ama parolalar
    şifreli bir şekilde depolanır. Bu, sistemde kayıtlı olmayan ama
    bir şekilde şifrelenmiş parolalara ulaşıp ve onları tahmin etmede
    çeşitli  kriptografi yöntemleri deneyecek kişilere bir engel oluşturmak
    üzere gölge parolalar şifreli olarak sadece root kullanıcısının
    okuyabildiği ayrı bir dosyada saklanır. Bununla birlikte,
    gölge parolaların desteklenmediği bir sisteme sonradan aktarılması,
    zorluk çıkarabilir.
   </para>
   <para>
    Şifreli veya değil bütün parolaların güvenilir ve kolay tahmin
    edilemez olduğundan emin olmalıyız. <command>crack</command> uygulaması
    parolaları kırmak için kullanılır; tanımından  bulunabilecek
    parolalar iyi değildir. <command>crack</command> izinsiz misafirlerce
    çalıştırılabileceği gibi, sistem yöneticisi tarafından kötü parolaları
    bulmak için de çalıştırılabilir. <command>passwd</command> komutu
    uygun parolalar kullanmamız için bizi zorlar; bu gerçekte CPU
    turlarından daha etkilidir. Çünkü bir parolayı kırmak için pek çok
    hesaplamalar yapmak gerekmektedir.
   </para>
   <para>
    Kullanıcı gruplarının veri tabanları <filename>/etc/group</filename>
    içerisinde tutulur; gölge parolalar kullanan sistemlerde bu
    <filename>/etc/shadow.group</filename> içerisinde olur.
   </para>
   <para>
    Root genellikle pek çok uçbirimden ve ağ üzerinden bağlanamaz,
    <filename>/etc/securetty</filename> dosyası içinde listelenmiş
    uçbirimleri kullanmak zorundadır. Bu, adı geçen uçbirimlerden birisine
    fiziksel erişim kurulmasını zorunlu kılar.  Bununla birlikte her
    hangi bir uçbirim veya ağ üzerinden normal bir kullanıcı gibi
    bağlanıp, root durumuna geçmek için <command>su</command> komutunu
    kullanmakta olasıdır.
   </para>
  </sect1>
  <sect1 xml:id="sag_log-in-and-out-shell">
   <title>Kabuk başlangıcı</title>
   <para>
    Bir etkileşimli bağlantı kabuğu başladığı zaman; kabuk, daha önceden
    tanımlanmış bir veya daha fazla dosyayı çalıştırır. Değişik kabuklar
    değişik dosyaları çalıştırır. Ayrıntılı bilgi için her kabuğu
    kendi belgelerine bakmalısınız.
   </para>
   <para>
    Pek çok kabuk ilk önce bazı genel dosyaları çalıştırır; örneğin: Bourne
    Shell (<command>/bin/sh</command>) ve türevleri <filename>/etc/profile</filename>
    ve ek olarak kullanıcı ev dizini içerisindeki <filename>.profile</filename>
    dosyasını çalıştırır. <filename>/etc/profile</filename> dosyası
    root kullanıcıya; kullanıcılar için genel çalışma ortamı hazırlama,
    <envar>PATH</envar> ortam değişkeni ile yerel komut dizinlerini
    diğerlerinin yanına ekleme gibi ayarlamalar yapma olanağı sağlar.
    Diğer yandan <filename>.profile</filename> dosyası ise kullanıcının
    kendi zevkine göre çalışma ortamı hazırlamasını sağlar ve şayet
    gerekiyorsa öntanımlı olarak atar.
   </para>
  </sect1>
 </chapter>
 <chapter xml:id="sag_user-accounts">
  <title>Kullanıcı Hesaplarının Yönetimi</title>
  <preliminary>
   <blockquote>
    <para>
     "Sistem yöneticiliği ile uyuşturucu satıcılığı arasındaki benzerlik:
     her ikisinde de ölçü biriminin kilo olması ve kullanıcıların
     varlığıdır." (eski bir bilgisayar şakası)
   </para>
   </blockquote>
   <para>
    Bu bölümde yeni kullanıcı hesaplarının açılması, bu hesapların
    özelliklerinin nasıl düzenleneceği ve bu hesapların nasıl kapatılacağı
    açıklanmaktadır. Değişik Linux dağıtımları bunları yapmak için değişik
    araçlar kullanabilir.
   </para>
  </preliminary>
  <sect1 xml:id="sag_user-accounts_what">
   <title>Hesap nedir?</title>
   <para>
    Bir bilgisayar çeşitli farklı kişiler tarafından kullanıldığı
    durumlarda, kullanıcılar arasında ayrım yapmak gerekli olmaktadır.
    Bu sayede kişiye özel dosyalar kişisel hale getirilebilir. Pek çok
    bilgisayarda olduğu gibi, tek bir kullanıcı varsa bile bunu yapmak
    faydalı olabilir. Sonuçta, her kullanıcı için benzersiz bir
    kullanıcı ismi verilir ve herkes bağlanmak için kendi ismini kullanır.
   </para>
   <para>
    Bununla birlikte kullanıcı için bir isimden daha fazlası mevcuttur.
    Bir hesap, kullanıcının  ismini, dosyalarını, kaynaklarını ve ona
    ait her şeyi temsil eder. Bu terim bankacılığa aittir ve bir ticari
    sistemde her hesapta biraz para vardır. Ve bu para kullanıcıların
    sisteme yaptığı baskıya göre değişen hızlarda eriyip gider. Örneğin;
    disk alanı günler ve Mb'lara göre bir fiyata sahip olabilir ve
    işlem süresinin de  saniyelere göre bir fiyatı olabilir.
   </para>
  </sect1>
  <sect1 xml:id="sag_user-accounts_create">
   <title>Bir kullanıcının oluşturulması</title>
   <para>
    Linux çekirdeği, kullanıcıları sadece basit sayılar olarak algılar.
    Her kullanıcı için tam sayılardan oluşan benzersiz bir tanımlama
    yapılmıştır, çünkü bir bilgisayar için  sayılarla uğraşmak
    harflerden oluşan isimler ile uğraşmaktan daha kolaydır. Bunlara
    <glossterm>kullanıcı kimliği</glossterm> (uid) ve <glossterm>grup
    kimliği</glossterm> (gid) denir. Çekirdek dışında ayrı oluşturulmuş
    veritabanlarında her bir kimlik için <glossterm>kullanıcı ismi</glossterm>
    olarak tanımlanan metinsel adlar tutulur. Ve tabii ki bu veritabanı
    bazı ek bilgileri de içerir.
   </para>
   <para>
    Bir kullanıcı oluşturmak için, kullanıcı veritabanına bir kullanıcı
    hakkında bilgiler eklemelisiniz ve bu kullanıcı için bir ev dizini
    yaratmalısınız.  Ayrıca kullanıcıyı eğitmek ve ona başlangıç için
    uygun bir ortam hazırlamak da gerekebilir.
   </para>
   <para>
    Pek çok Linux dağıtımı kullanıcı hesapları oluşturmak için gereken
    araçlar ile gelir. Bu araçların kullanışlı sürüm ve
    çeşitleri bulunur. Bunlardan komut satırı uygulaması olan ikisi
    <command>adduser</command> ve <command>useradd</command> dışında
    bir GUI araç da bulunabilir. Hangisi olursa olsun sonuçta,
    geriye el ile yapılması gereken pek az iş kalır. Ayrıntılar pek çok
    ve karmaşık olsa da bu araçlar önemsiz görünen her şeyi yapar.
    Bununla birlikte <xref linkend="sag_manual-adduser"/> bölümünde
    bütün bu ıvır zıvır şeylerin el ile nasıl yapılacağı açıklanmaktadır.
   </para>
   <sect2 xml:id="sag_user-accounts_passwdfile">
    <title><literal>/etc/passwd</literal> ve diğer bilgi dosyaları</title>
    <para>
     Bir Unix işletim sistemindeki en basit veri tabanı; geçerli
     kullanıcıların ve onların birleştirilmiş bilgilerinin listelendiği
     <filename>/etc/passwd</filename> bir metin dosyasıdır. Bu dosya
     parola dosyası olarak anılır. Bu dosyada her kullanıcı için bir
     satır ve her satırda iki nokta üstüste işaretleri ile ayrılmış
     7 sütun bulunur:
    </para>
    <simplelist>
     <member>Kullanıcı ismi.</member>
     <member>Şifrelenmiş olarak parola.</member>
     <member>Kullanıcı kimliği (bir numara).</member>
     <member>Grup kimliği (bir numara).</member>
     <member>Kullanıcının gerçek ismi ve heapla ilgili diğer açklamalar</member>
     <member>Ev dizini.</member>
     <member>Bağlantı kabuğu (başlangıçta çalışacak kabuk)</member>
    </simplelist>
    <para>
     <filename>passwd</filename> kılavuz sayfasında bu dosya biçemi
     hakkında daha ayrıntılı bilgi bulunmaktadır.
    </para>
    <para>
     Sistemdeki her hangi bir kullanıcı bu parola dosyasını okuyabilir ve
     böylece diğer kullanıcıların adlarını öğrenebilir. Bunun anlamı,
     ikinci bölümde bulunan parolaların da herkes tarafından görülebileceğidir.
     Bu parolalar şifreli olduğu için, teorik olarak ortada bir sorun yoktur.
     Bununla beraber bu şifreler kırılabilir, özelliklede bir sözlükte
     bulunabilecek bir şeyse veya çok kısaysa. Bu nedenle, parolaları bir
     parola dosyasında saklamak iyi bir fikir sayılmaz.
    </para>
    <para>
     Pek çok Linux sistemi <glossterm>gölge parolalar</glossterm>
     kullanır. Bu parola saklamanın güveni bir yoludur: bu sistemde
     parolalar şifrelenmiş bir şekilde, sadece root tarafından okunabilen,
     <filename>/etc/shadow</filename> dosyasında tutulur.
     <filename>/etc/shadow</filename> dosyası ikinci alanda sadece özel
     bir işaret ihtiva eder.  Kullanıcı kimliğini kanıtlaması gereken
     herhangi bir uygulama setuid'dir ve bu nedenle gölge parola
     dosyasına erişimi vardır.  Normal uygulamalar diğer alanları
     kullanır ve parolalara erişemez.
    </para>
   </sect2>
   <sect2>
    <title>Sayısal kullanıcı ve grup kimliklerinin seçilmesi</title>
    <para>
     Pek çok sistemde sayısal kullanıcı ve grup kimliklerinin ne olduğu
     pek de önemli değildir, fakat şayet bir ağ dosya sistemi (NFS)
     kullanıyorsanız, bütün sistemlerde aynı uid ve gid'ye sahip
     olmanız gerekmektedir. (uid=user id - kullanıcı kimliği,
     gid=group id - grup kimliği). Bu NFS'nin kullanıcıları sayısal
     kullanıcı kimlikleri ile tanımlamasından kaynaklanır. Şayet NFS
     kullanmıyorsanız, hesap oluşturma araçlarının bunları otomatik
     olarak sizin yerinize seçmesine izin verebilirsiniz.
    </para>
    <para>
     Şayet NFS kullanıyorsanız, kullanıcı bilgilerinin birbirine
     uyması için bir mekanizma bulmak zorundasınız.  Alternatif yollardan
     birisi NIS sistemidir (XXX network-admin-guide'a  bakabilirsiniz).
    </para>
    <para>
     Bunun yanında, sayısal kullanıcı kimliklerinin tekrar kullanılmasını
     önlemeyi denemelisiniz, çünkü kullanıcı kimliğinin yeni sahibi,
     eski sahibinin dosyalarına, postalarına veya her neyse onlara
     ulaşabilir.
    </para>
   </sect2>
   <sect2>
    <title>Ortamın hazırlanması: <literal>/etc/skel</literal></title>
    <para>
     Yeni bir kullanıcı için ev dizini bu <filename>/etc/skel</filename>
     dizinin içindeki dosyalarla oluşturulur.  Sistem yöneticisi,
     kullanıcılar için daha hoş öntanımlı ortamlar sağlamak için,
     <filename>/etc/skel</filename> içinde dosyalar oluşturabilir.
     Örneğin <filename>/etc/skel/.profile</filename> dosyasını oluşturup,
     içinde, yeni kullanıcılar için <envar>EDITOR</envar> ortam
     değişkenininde daha kullanıcı dostu metin düzenleyiciler belirtebilir.
   </para>
    <para>
     Bununla beraber, <filename>/etc/skel</filename> dizinini mümkün
     olduğunca küçük tutmak daha iyidir, çünkü mevcut kullanıcıların
     dosyalarını güncellemesi imkansızlaşabilir. Örneğin kullanıcı dostu
     metin düzenleyicinin adı değiştirilirse, bütün mevcut kullanıcılar
     kendi <filename>.profile</filename> dosyalarını düzenlemek zorunda
     kalacaktır. Sistem yöneticisi bir betik kullanarak bunu otomatik
     olarak yapmayı deneyebilir, fakat bu yöntemle birilerinin dosyalarının
     bozulması neredeyse kesindir.
    </para>
    <para>
     Mümkün olduğunca, genel ayarları genel dosyalarda yapmak daha iyi
     olacaktır, örneğin <filename>/etc/profile</filename> dosyası gibi.
     Bu yolla, hiç kimsenin dosyalarına ve ayarlarına  zarar vermeden
     güncelleme yapmak mümkün olacaktır.
    </para>
   </sect2>
   <sect2 xml:id="sag_manual-adduser">
    <title>Kullanıcıların elle oluşturulması</title>
    <para>
     Kullanıcıları elle oluşturmak için aşağıdaki adımları izleyin
    </para>
     <itemizedlist>
      <listitem>
       <para>
        <filename>/etc/passwd</filename> dosyasını
        <uri xl:href="man8-vipw"/> ile düzenleyin ve yeni bir hesap için
        yeni bir satır ekleyin. Sözdizimleri konusunda dikkatli olun.
        <emphasis>BİR SATIRI BİR METİN DÜZENLEYİCİ İLE DOĞRUDAN DOĞRUYA
        ASLA DÜZENLEMEYİN!</emphasis> <command>vipw</command> dosyayı
        kilitleyeceği için diğer komutlar aynı anda güncelleme yapmayı
        deneyemezler. Parola alanını `<literal>*</literal>' yapmalısınız,
        böylece sisteme bağlanmak imkansız olur.
      </para>
      </listitem>
      <listitem>
       <para>
        Şayet yeni bir grup oluşturmanız gerekiyorsa, aynı yöntemle
        <filename>/etc/group</filename> dosyasını
        <uri xl:href="man8-vigr"/> ile düzenleyin.
      </para>
      </listitem>
      <listitem>
       <para>
        Kullanıcı ev dizinini <uri xl:href="man1-mkdir"/> kullanarak oluşturun.
       </para>
      </listitem>
      <listitem>
       <para>
        <filename>/etc/skel</filename> dizininin içeriğini yeni ev
        dizinine kopyalayın.
       </para>
      </listitem>
      <listitem>
       <para>
        <uri xl:href="man1-chown"/> ve <uri xl:href="man1-chmod"/> ile
        sahipleri ve izinleri sabitleyin. <option>-R</option> seçeneği
        oldukça kullanışlıdır. Doğru izinler durumdan duruma farklılık
        gösterir fakat  genellikle aşağıdaki komutlar doğru işlemleri yapar:
       </para>
       <screen>
<prompt>#</prompt> <userinput>cd /home/</userinput><replaceable>kullanıcı</replaceable>
<prompt>#</prompt> <userinput>chown -R</userinput> <replaceable>kullanıcı.grup</replaceable> .
<prompt>#</prompt> <userinput>chmod -R go=u,go-w .</userinput>
<prompt>#</prompt> <userinput>chmod go= .</userinput>
</screen>
      </listitem>
      <listitem>
       <para>
        <uri xl:href="man1-passwd"/> ile parolayı belirleyin.
       </para>
      </listitem>
     </itemizedlist>
    <para>
     Son adımda parolayı düzenledikten sonra kullanıcı hesabı çalışmaya
     başlar. Her şey bitmeden parolayı düzenlemeyin; yoksa kullanıcı
     bir dikkatsizlik sonucu, siz hala dosyaları kopyalarken, sisteme
     bağlanabilir.
    </para>
    <para>
     Bazen hiç kimse tarafından kullanılmayan "aptal" hesaplar
     oluşturmak gerekebilir. Örneğin; anonim bir FTP sunucusunu
     düzenleyebilmek için <literal>ftp</literal> adında bir kullanıcı hesabı
     açmanız gerekir (böylece herkes,bir kullanıcı hesabı açmadan buradan
     dosya indirebilir).  Bu gibi durumlarda, genellikle parola ayarlamak
     gerekmez. Gerçekte, bunu yapmamak daha iyidir, böylece bu hesabı, root
     herhangi bir kullanıcı haline gelebildiğinden root dışında hiç kimse
     kullanamaz.
    </para>
   </sect2>
  </sect1>
  <sect1 xml:id="sag_user-accounts_change">
   <title>Kullanıcı özelliklerinin değiştirilmesi</title>
   <para>
    Bir hesabın çeşitli özelliklerini (<filename>/etc/passwd</filename>
    dosyasında konuyla alakalı alanları) değiştirmek için bir kaç
    komut vardır:
   </para>
    <glosslist>
     <glossentry>
      <glossterm>
       <uri xl:href="man1-chfn"/>
      </glossterm>
      <glossdef>
       <para>
        Kullanıcının gerçek ismini değitirir.
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm>
       <uri xl:href="man1-chsh"/>
      </glossterm>
      <glossdef>
       <para>
        Kullanıcı oturum açtıktan sonra çalıştırılan kabuğu değiştirir.
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm>
       <uri xl:href="man1-passwd"/>
      </glossterm>
      <glossdef>
       <para>
        Kullanıcı parolasını değiştirir.
       </para>
      </glossdef>
     </glossentry>
    </glosslist>
   <para>
    Süper kullanıcı herhangi bir hesabın özelliklerini değiştirmek için
    bu komutları kullanır. Normal kullanıcılar ise sadece kendilerine
    ait özellikleri değiştirebilir. Bazen <uri xl:href="man1-chmod"/>
    komutunu kullanarak bu komutları normal kullanıcılar için yasaklamak
    gerekebilir. Özellikle acemi kullanıcıların çok olduğu ortamlarda.
   </para>
   <para>
    Diğer görevler el ile yapılmalıdır. Örneğin: kullanıcı ismini
    değiştirmek için, doğrudan <filename>/etc/passwd</filename>
    içinde düzenleme yapmak zorundasınız (<uri xl:href="man8-vipw"/> ile).
    Benzer şekilde, bir kullanıcıyı bir gruba eklemek ya da çıkartmak
    için <filename>/etc/group</filename> dosyasını düzenlemelisiniz
    (<uri xl:href="man8-vigr"/> ile).  Çok nadiren bu tür işler ile
    uğraşmak zorunda kalırsınız, bununla beraber, bu işleri bir uyarı
    eşliğinde yapmalısınız. Örneğin: şayet siz kullanıcı adını
    değiştirirseniz, posta kutusuna bir takma ad tanımlanmadığı
    sürece, kullanıcıya gönderilen postalar ulaşılmaz olur.
   </para>
  </sect1>
  <sect1 xml:id="sag_user-accounts_remove">
   <title>Bir kullanıcının silinmesi</title>
   <para>
    Bir kullanıcıyı sistemden kaldırmak için, ilk önce bu kullanıcıya
    ait ne varsa: dosyaları, posta kutuları, yazdırma işleri,
    <command>cron</command> ve <command>at</command> işleri ile
    kullanıcıya ait diğer her şey silinmelidir. Daha sonra
    <filename>/etc/passwd</filename> ve <filename>/etc/group</filename>
    dosyalarından ilgili satırlar kaldırılır (kullanıcının dahil olduğu
    bütün gruplardan ismini silmeyi unutmayın). Kullanıcının sisteme
    bağlanıp, silme işleri sırasında hesabı kullanmasını önlemek için;
    silme işlemlerine başlamadan önce, hesabı kapatmak daha iyi olabilir
    (Aşağıya, <xref linkend="sag_user-accounts_tmp-disable"/> bölümüne
    bakınız).
  </para>
   <para>
    Unutmayın ki kullanıcıların kendi ev dizinleri dışında da dosyaları
    olabilir. Bunları bulmak için <uri xl:href="man1-find"/> komutunu
    kullanın.
   </para>
   <screen>
<prompt>#</prompt> <userinput>find / -user</userinput> <replaceable>kullanıcı</replaceable>
</screen>
   <para>
    Bunun yanında, üstteki komut, şayet çok büyük bir diskiniz varsa,
    oldukça uzun bir zaman alacaktır.  Şayet ağ diskleri de bağlıysa
    çok dikkatli olun, sunucuyu veya ağı değersiz bir çöp yığınına
    çevirmeniz işten bile değildir.
   </para>
   <para>
    Bazı Linux dağıtımları bu iş için <uri xl:href="man8-deluser"/>
    ya da <uri xl:href="man8-userdel"/> gibi özel komutlarla gelir.
    Ancak elle yapmak da kolaydır ve bu komutlar herşeyi yapmayabilir.
   </para>
  </sect1>
  <sect1 xml:id="sag_user-accounts_tmp-disable">
   <title>Bir kullanıcı hesabının geçici olarak kapatılması</title>
   <para>
    Bazı zamanlar kimi kullanıcı hesaplarını, silmeden kapatmak gerekir.
    Örneğin; kullanıcı aidatını ödememiş olabilir veya sistem yöneticisi
    bir yabancının bu hesaba ait parolayı ele geçirdiğinden şüpheleniyor
    olabilir.
   </para>
   <para>
    Bir hesabı kapatmanın en iyi yolu, o hesaba ait kabuğu, sadece bir
    ileti veren özel bir uygulama ile değiştirmektir. Böylece, hesaba
    bağlanmak isteyen her hangi birisinin bu eylemi durdurulacak ve
    nedeni kendisine bildirilecektir.  İleti, kullanıcıya sorunu
    çözmek üzere sistem yöneticisine başvurmasını söyleyebilir.
   </para>
   <para>
    Kullanıcı ismi veya parolanın değiştirilmesi de mümkündür ama bu
    durumda  kullanıcı neler olup bittiğini anlayamayacaktır. Kafası
    karışan kullanıcı daha çok uğraşacaktır.
   </para>
   <para>
    Özel bir betik oluşturmanın en basit yolu bir "tail betiği" yazmaktır:
   </para>
    <screen>
#!/usr/bin/tail +2
Bu hesap güvenlik nedeniyle askıya alınmıştır.
Hesabınızı açtırmak için lütfen müşteri hizmetleriyle görüşünüz.
</screen>
   <para>
    İlk iki karakter (`<literal>#!</literal>') çekirdeğe bu satırın
    devamın bir komut olduğunu ve bu komutun  bu dosyayı yorumlamak
    için çalıştırılması gerektiğini söyler. Bu durumdaki
    <uri xl:href="man1-tail"/> komutu ilk satır hariç her şeyi standart
    çıktıya gönderir.
   </para>
   <para>
    Şayet <literal>aliveli</literal> isimli kullanıcısının hesabında bir
    güvenlik açığından şüpheleniliyorsa sistem yöneticisi şuna benzer bir
    şeyler yapmalıdır:
   </para>
   <screen>
<prompt>#</prompt> <userinput>chsh -s /usr/local/lib/no-login/security aliveli</userinput>
<prompt>#</prompt><userinput>su - tester</userinput>
Bu hesap güvenlik nedeniyle askıya alınmıştır.
Hesabınızı açtırmak için lütfen müşteri hizmetleriyle görüşünüz.
<prompt>#</prompt>
</screen>
   <para>
    Burada <uri xl:href="man1-su"/> komutunun kullanılmasındaki amaç;
    değişikliklerin düzgün bir şekilde çalışıp çalışmadığını görmektir.
   </para>
   <para>
    Tail betikleri ayrı bir dizinde tutulmalıdır, böylece normal kullanıcı
    komutları ile karışması önlenebilir.
   </para>
  </sect1>
 </chapter>
 <chapter xml:id="sag_backups">
  <title>Yedek Alma</title>
  <preliminary>
   <blockquote>
    <literallayout>
Donanım belirlenmezciye göre güvenilirdir.
Yazılım belirlenimciye göre güvenilir değildir.
Toplum belirlenmezciye göre güvenilir değildir.
Doğa belirlenimciye göre güvenilirdir.
</literallayout>
   </blockquote>
   <para>
    Bu bölüm neden, nasıl ve ne zaman yedek almanız ve geri yüklemeniz
    gerektiğini anlatmaktadır.
   </para>
  </preliminary>
  <sect1 xml:id="sag_backups_import">
   <title>Yedeklemenin önemi üzerine</title>
   <para>
    Bilgileriniz değerlidir.  Onları tekrar meydana getirmek; zaman, para
    veya en azından kişisel keder ve göz yaşına mal olabilir.  Şayet bu
    bilgiler bazı deneylerin sonucu ise onları tekrar meydana getirmek
    mümkün olmayabilir.  Bilgileriniz bir yatırım olduğuna göre, onları
    korumalı ve kaybetmemek için  bazı adımlar atmalısınız.
   </para>
   <para>
    Temel olarak bilgi kayıplarının 4 ana sebebi vardır: donanım arızaları,
    yazılım hataları, insandan kaynaklanan olaylar ve doğal afetler.
    Modern donanımların oldukça güvenilir olmasına rağmen, halen
    kendiliğinden arızalar çıkabilecekmiş gibi görünmektedir.  Bilgi
    depolama donanımlarının en kritik parçası sabit disktir,  ki bu diskler,
    elektromanyetik gürültü ile dolu bir dünya içine tam olarak kalabilen
    manyetik alanlara bel bağlamaktadır.  Modern yazılımlar pek güvenilir
    gözükmese bile, kaya sertliğindeki bir uygulama istisnadır, kural değil.
    İnsanlar kesinlikle güvenilmezdir, sırf keyif olsun diye veya bir amaç
    uğruna bilgilerinizi yok edebilir ve yahut bir hata yapabilir.
    Doğa kötü değildir,  fakat her şey iyi giderken birden öfke kusabilir.
    Her şeyi hesaba katınca, her hangi bir şeyin doğru çalışmasının hiç de
    küçük bir mucize olmadığını görürüz.
   </para>
   <para>
    Yedekleme bilgi yatırımımızı korumanın bir yoludur. Bilgilerimizin
    çeşitli kopyalarına sahip olursak, her hangi bir kopyanın bozulması
    bizim için sorun teşkil etmez (en fazla yedeklerimizden yüklememizi
    gerektirir).
   </para>
   <para>
    Düzenli olarak yedeklemek çok önemlidir. Fiziksel dünyaya ait her hangi
    bir şey gibi, yedeklerde yakında veya ileri bir tarihte hata verebilir.
    İyi bir yedekleme yapmanın bir parçası da yedeklerin çalıştığından emin
    olmaktır; yedeklerinizin çalışmadığını görmek istemezsiniz her halde.
    Hasara  tuz biber olarak, yedekleme işlemi esnasında bir hata meydana
    gelebilir; elinizde sadece yarım bir yedek varken sizi ortada bırakabilir,
    tek bir yedekleme aracınız vardır ve bozulabilir. Veya geri yüklemeyi
    denerken fark edersiniz ki: 15000 kullanıcılı alandaki önemli bir
    kullanıcı veritabanını yedeklememişsinizdir.  Hepsinin en iyisi de;
    bütün yedeklerinin mükemmel bir şekilde çalışıyordur fakat sonuncu
    teyp sürücünüzün içine bir kova su dolmuş olabilir.
   </para>
   <para>
    İş yedeklemeye geldiğinde, paranoya bu işin mayasında vardır.
   </para>
  </sect1>
  <sect1 xml:id="sag_backups_medium">
   <title>Yedekleme ortamının seçimi</title>
   <para>
    Yedekleme işindeki en önemli karar; yedekleme aracını seçmektir.
    Fiyatını, güvenilirliğini, hızını, kullanılabilirliğini ve bulunabilir
    olup olmadığını hesaba katmak zorundasınız.
   </para>
   <para>
    Fiyat önemlidir, çünkü; tercihen, ihtiyacınız olan bilgilerden daha
    fazlasını yedeklemek isteyebilirsiniz.  ucuz bir araç genellikle
    bir zorunluluktur.
   </para>
   <para>
    Bozulmuş bir yedek, yetişkin bir adamı bile ağlatabileceği için:
    güvenilirlik çok önemlidir.  Bir yedekleme aracı, bilgileri her
    hangi bir bozulma olmadan yıllarca saklayabilmelidir.  Bir denetim
    gerektirmediği sürece yedekleme işinin kaç saate mal olduğu önemli
    değildir. Diğer yandan, bilgisayar boş durduğu sürece yedekleme işi
    başarılamayacaktır, bu nedenle hız da ayrı bir noktadır.
   </para>
   <para>
    Bulunabilirlik kesinlikle çok önemlidir: piyasada olmayan bir yedekleme
    aracını kullanamazsınız.  Gelecekte de kullanılabilecek, sadece sizin
    değil diğer insanların bilgisayarlarında da, yedekleme aygıtı seçmeniz
    önemlidir.  Aksi taktirde her hangi bir sorundan sonra yedeklerinizi
    yükleyememek gibi bir sorunla karşılaşabilirsiniz.
   </para>
   <para>
    Kullanılabilirlik: ne kadar sıklıkla yedekleme yapılacağını belirleyen
    temel faktördür.  En kolay yedekleme yapma yöntemi en iyisidir. Bir
    yedekleme aracının kullanımı zor ve sıkıcı olmamalıdır.
   </para>
   <para>
    Geleneksel yedekleme araçları teyplerdir. Teypler biraz pahalı, güvenilir,
    nispeten hızlı, bulunabilir ve kullandığınız bandın boyutuna göre oldukça
    kullanışlı aygıtlardır.
   </para>
   <para>
    Başka seçenekler de vardır. Genellikle pek bulunabilir olmasalar da,
    şayet bu sizin için sorun değilse, diğer yollardan daha iyidir.
    Örneğin, manyetik optik diskler hızlı, rasgele erişimli, tek bir
    dosyayı oldukça hızlı geri yükleyebilen, büyük boyutlu araçlardır.
   </para>
  </sect1>
  <sect1 xml:id="sag_backups_tool">
   <title>Yedekleme aracının seçimi</title>
   <para>
    Yedekleme yapmak için pek çok araç vardır. Yedekleme yapmak için
    kullanılan geleneksel Unix araçları <uri xl:href="man1-tar"/>,
    <uri xl:href="man1-cpio"/> ve <command>dump</command>'dır. Ek olarak
    pek çok üçüncü parti yedekleme yazılımı da mevcuttur. Yedekleme
    aygıtının seçimi, yedekleme aracının seçimini de etkileyebilir.
   </para>
   <para>
    <command>tar</command> ve <command>cpio</command> türdeştir ve
    yedeklemeye bakış açıları büyük  benzerlikler içerir. Her ikisi de
    teyplere yedeklemek ve onlardan geri alabilmek yeteneklerine
    sahiptir. Her ikisi de hemen hemen bütün saklama ortamlarını
    kullanmaya muktedirdir. Çünkü çekirdek aygıt sürücüleri alt
    seviye aygıtlarıyla ilgilenir ve onları kullanıcı seviyeli aygıtlarmış
    gibi davranmaya yönlendirir.  Bazı Unix dağıtımlarında
    <command>tar</command> ve <command>cpio</command> özel
    türdeki bazı dosyalarla bazı sorunlar çıkarabilir (sembolik
    bağlar, aygıt dosyaları gibi) ama tüm Linux dağıtımlarında bu
    uygulamaların doğru çalışıyor olması gerekmektedir.
    </para>
   <para>
    <command>dump</command> biraz farklıdır, dosya sistemi üzerinden
    okuma yapmak yerine, doğrudan doğruya dosya sistemini okur. Ayrıca
    özellikle yedekleme için yazılmıştır; <command>tar</command> ve
    <command>cpio</command> ise aslında dosyaları arşivler ama
    yedeklemeler için de iyi çalışır.
   </para>
   <para>
    Dosya sistemini doğrudan doğruya okumanın bazı getirileri vardır.
    Dosyaların zaman izlerini etkilemeden onları yedeklemeyi mümkün
    kılar; <command>tar</command> ve <command>cpio</command> için, dosya
    sistemini salt okunur olarak bağlamak zorundasınız. Şayet her şeyin
    yedeklenmesi gerekiyorsa, dosya sisteminin doğrudan doğruya okunması
    daha etkili bir yoldur çünkü disk kafaları daha az hareket etmek
    zorunda kalır.  Buradaki temel götürü ise yedeklerin sadece bir
    tek dosya sistemine özel hale getirilmiş olmasıdır. Linux
    <command>dump</command> komutu sadece ext2 dosya sistemini tanır.
   </para>
   <para>
    <command>dump</command> ayrıca, aşağıda tartışacağımız yedekleme
    seviyelerini desteklemektedir. <command>tar</command> ve
    <command>cpio</command>'da bunu diğer aygıtları etkinleştirmek
    yolu ile yaparız.
   </para>
   <para>
    Üçüncü parti yazılımlar arası bir karşılaştırma bu kitabın konusu
    dışındadır. Linux Yazılım Haritası, bu uygulamaların freeware
    olanlarının pek çoğunu listelemektedir.
   </para>
  </sect1>
  <sect1 xml:id="sag_backups_simple">
   <title>Basit yedekleme</title>
   <para>
    Basit yedekleme şeması her şeyin bir seferde yedeklenmesi ve daha
    sonra önceki yedekleme işleminden beri meydana gelmiş olan
    değişikliklerin yedeklenmesidir. Birinci yedekleme  <glossterm>tam
    yedek</glossterm>, sonrakiler <glossterm>fark yedekleri</glossterm>
    olarak adlandırılır.  Tam yedekler, fark yedeklerinden daha
    fazla işçilik gerektirir, çünkü; teybe yazılması gereken daha çok
    bilgi vardır ve genellikle tek teybe sığmazlar.
    Fark yedeklerinden geri yüklemek tam yedeklerden geri yüklemekten
    daha çok zamana mal olur.  Geri yükleme eniyilenebilir, bu sayede
    daima bir önceki tam yedeklemeden itibaren olan her şeyleri
    yedeklersiniz. Bu yolla yedekleme biraz daha fazla iş ister fakat
    geri yükleme sırasında bir tam yedek ve bir fark yedeğinden daha
    fazlasını yüklemek gerekmez.
   </para>
   <para>
    Şayet her gün yedek almak istiyor ve altı adet bandınız varsa; birinci
    bandı birinci tam yedek için ayırın (diyelim ki Cuma günü), 2 ile 5
    arasındaki bantları her bir gün için (pazartesi-Perşembe arası)
    fark yedeklerinde ve altıncı banda yeni bir tam yedekleme (ikinci Cuma
    günü) yapın.  Ve daha sonra 2-5 arasındaki bantları fark yedeklemesi
    için kullanmaya devam edin.  Tam yedekleme yaparken her hangi bir şey
    olmasın diye, yeni bir tam yedekleme bandınız olana kadar 1. bant
    üzerine yazmayabilirsiniz.  Altıncı banda tam yedekleme yaptıktan sonra,
    birinci tam yedekleme bandını başka bir yerlerde saklayabilirsiniz ve
    bu sayede yangında bütün yedek bantlarınız yansa bile geriye, en
    azından bir şeyler kalmış olur.
   </para>
   <para>
    Şayet altı banttan fazlasına sahipseniz, diğerlerini tam yedekler
    için kullanabilirsiniz. Her yeni tam yedek yaptığınızda, daha eski
    olan bir bandı kullanırsınız.  Bu yolla, çeşitli geçmiş haftalara
    ait kayıtlarınız olur ve şayet şu an silinmiş eski bir bilgiye
    ihtiyacınız olursa bunları kullanabilirsiniz.
   </para>
   <sect2>
    <title><literal>tar</literal> ile yedekleme</title>
    <para>
     Bir tam yedekleme <command>tar</command> ile kolayca yapılabilir:
    </para>
     <screen>
<prompt>#</prompt> <userinput>tar --create --file /dev/ftape /usr/src</userinput>
tar: Üye isimlerinin sonundaki / kaldırılıyor
<prompt>#</prompt>
</screen>
    <para>
     Yukarıda ki örnek <command>tar</command>'ın GNU sürümünü ve onun uzun
     seçenek isimlerini kullanmaktadır. <command>tar</command>'ın geleneksel
     sürümü sadece tek harflerden oluşan seçenekleri kullanır. GNU sürümü bir
     teypten daha fazlasını isteyen yedeklemeleri yapabilir ve çok uzun dosya
     yolu tanımlamalarını da kabul edebilir,  fakat bütün geleneksel sürümler
     bu tür şeyleri yapamaz. Linux sadece GNU <command>tar</command> sürümünü
     kullanın.
    </para>
    <para>
     Şayet yedekleriniz bir teybe sığmadıysa <option>--multi-volume</option>
     (<option>-M</option>) seçeneğini kullanmak zorundasınız:
    </para>
    <screen>
<prompt>#</prompt> <userinput>tar -cMf /dev/fd0u1440 /usr/src</userinput>
tar: Üye isimlerinin sonundaki / kaldırılıyor
#2. bölümü /dev/fd0u1440 için hazırdıktan sonra return tuşuna basınız:
<prompt>#</prompt>
</screen>
    <para>
     Bir yedekleme yaptıktan sonra düzgün çalışıp çalışmadığını anlamak
     için <option>--compare</option> (<option>-d</option>) seçeneği kullanılmalıdır:
    </para>
     <screen>
<prompt>#</prompt> <userinput>tar --compare --verbose -f /dev/ftape</userinput>
usr/src/
usr/src/linux
usr/src/linux-1.2.10-includes/
....
<prompt>#</prompt>
</screen>
    <para>
     Bir yedekleme sınamasını hata vermesi, orijinal bilgileri
     kaybedip yedeklerinizin çalışmadığı uyarısını almayacağınız
     anlamına gelir.
    </para>
    <para>
     Bir fark yedeklemesi <command>tar</command>'ın <option>--newer</option>
     (<option>-N</option>) seçeneği ile yapılır:
    </para>
     <screen>
<prompt>#</prompt> <userinput>tar --create --newer '8 Sep 1995' --file /dev/ftape /usr/src --verbose</userinput>
tar: Üye isimlerinin sonundaki / kaldırılıyor
usr/src/
usr/src/linux-1.2.10-includes/
usr/src/linux-1.2.10-includes/include/
usr/src/linux-1.2.10-includes/include/linux/
usr/src/linux-1.2.10-includes/include/linux/modules/
usr/src/linux-1.2.10-includes/include/asm-generic/
usr/src/linux-1.2.10-includes/include/asm-i386/
usr/src/linux-1.2.10-includes/include/asm-mips/
usr/src/linux-1.2.10-includes/include/asm-alpha/
usr/src/linux-1.2.10-includes/include/asm-m68k/
usr/src/linux-1.2.10-includes/include/asm-sparc/
usr/src/patch-1.2.11.gz
<prompt>#</prompt>
</screen>
    <para>
     Şansızlık eseri, <command>tar</command> bir dosyanın düğüm
     bilgisinin değiştiğini algılayamaz, örneğin: değişmiş izin
     bitlerini veya isminin ne zaman değiştiğini. Bu <command>find</command>
     kullanılarak ve mevcut dosya sistemindeki dosyaların durumu ile
     daha önceki yedeklemenin karşılaştırılması şeklinde yapılabilir.
     Bunu yapacak betikler ve uygulamalar Linux FTP sitelerinde bulunabilir.
    </para>
   </sect2>
   <sect2>
    <title><literal>tar</literal> ile dosyaların geri yüklenmesi</title>
    <para>
     <option>--extract</option> (<option>-x</option>) seçeneği ile
     <command>tar</command> dosyaları geri alır:
    </para>
     <screen>
<prompt>#</prompt> <userinput>tar --extract --same-permissions --verbose --file /dev/fd0u1440</userinput>
usr/src/
usr/src/linux
usr/src/linux-1.2.10-includes/
usr/src/linux-1.2.10-includes/include/
usr/src/linux-1.2.10-includes/include/linux/
usr/src/linux-1.2.10-includes/include/linux/hdreg.h
usr/src/linux-1.2.10-includes/include/linux/kernel.h
...
<prompt>#</prompt>
</screen>
    <para>
     Komut satırında isimleri belirterek belirli dosya veya klasörleri
     ve onların alt klasörleri ve dosyalarını geri yükleyebilirsiniz:
    </para>
    <screen>
<prompt>#</prompt> <userinput>tar xpvf /dev/fd0u1440 usr/src/linux-1.2.10-includes/include/linux/hdreg.h</userinput>
usr/src/linux-1.2.10-includes/include/linux/hdreg.h
<prompt>#</prompt>
</screen>
    <para>
     Yedeklenmiş bilgiler içinde hangi dosyaların olduğunu görmek için
     <option>--list</option> (<option>-t</option>) seçeneğini kullanın:
    </para>
    <screen>
<prompt>#</prompt> <userinput>tar --list --file /dev/fd0u1440</userinput>
usr/src/
usr/src/linux
usr/src/linux-1.2.10-includes/
usr/src/linux-1.2.10-includes/include/
usr/src/linux-1.2.10-includes/include/linux/
usr/src/linux-1.2.10-includes/include/linux/hdreg.h
usr/src/linux-1.2.10-includes/include/linux/kernel.h
...
<prompt>#</prompt>
</screen>
    <para>
     Unutmayın ki <command>tar</command> yedek isimlerini ardışık
     olarak okur ve bu yüzden biraz yavaştır. Bununla birlikte, teyp
     sürücü veya sıralı erişim sağlayan aygıtlar ile rasgele erişimli
     veritabanı tekniklerini kullanmak mümkün değildir.
    </para>
    <para>
     <command>tar</command> silinmiş dosyalar için uyarmaz.  Bir tam ve
     fark yedeğinden bir dosya sistemini geri yüklemeniz gerekiyorsa,
     iki yedekleme arasında bir dosyayı sildiyseniz,  yükleme sonrası
     bu dosya tekrar ortaya çıkacaktır.  Şayet bu dosya sistemde
     bulunmaması gereken hassas bilgiler içeriyorsa, bu büyük bir sorun
     yaratabilir.
    </para>
   </sect2>
  </sect1>
  <sect1 xml:id="sag_backups_levels">
   <title>Çok seviyeli yedekleme</title>
   <para>
    Bir önceki bölümde anlatılan basit yedekleme yöntemi kişisel
    kullanımlar ve küçük siteler için yeterlidir.  Daha ağır görevler
    için kullanılan sistemlerde, çok seviyeli yedekleme daha uygun
    olacaktır.
   </para>
   <para>
    Basit yöntemin iki seviyesi vardır: tam ve fark.  Bunlar her hangi
    bir seviye numarası kullanılarak genelleştirilebilir. Bir tam yedek 0
    ve diğerleri 1, 2, 3 gibi numaralandırılabilir. Her bir fark yedeği
    seviyesinde, daha önceki yedeklemeden beri değişen her şeyi yeniden
    yedeklemeniz gerekir.
   </para>
   <para>
    Bunu yapmamızın sebebi, daha ucuz bir şekilde bir <glossterm>yedekleme
    geçmişi</glossterm> oluşturmaktır. Bir önceki bölümde bulunan örnekte,
    yedekleme geçmişi birinci tam yedeğe kadar gitmektedir. Daha fazla banda
    sahip olarak bunu uzatabilirsiniz. Fakat her hafta için bir bant biraz
    pahalı olabilir.  Uzun bir yedekleme geçmişi faydalı olabilir, çünkü
    bozulmuş veya silinmiş dosyalar uzun bir süre fark edilmeyebilir.
    Dosyanın sürümü yeni olmasa bile, hiç olmamasından daha iyidir.
   </para>
   <para>
    Çok seviyeli yedekleme sayesinde, yedekleme geçmişi daha ucuz bir şekilde
    uzatılabilir. Örneğin: şayet 10 adet bant alırsak; birinci ve ikinci
    bantları aylık olarak (her ayın birinci cuması) yedekleriz, 3-6 arası
    bantları haftalık (bir ayın diğer cumaları için, unutmadan bazı aylarda
    5 Cuma olabilir, bunun  için 4 adet fazladan banda ihtiyacımız var)
    yedeklemeler için, 7-10 arası bantları günlük (pazartesi, Salı, Çarşamba,
    Perşembe) yedekleme için  kullanılabilir.  Sadece 4 adet yeni bant ile
    yedekleme tarihini 2 haftadan (bütün günlük teypler kullanıldıktan sonra)
    iki aya kadar uzatabiliriz.   Bu iki ay esnasındaki dosyaların tüm
    sürümlerini saklayamayacağımız doğrudur ama yeterince sık aralıklar ile
    saklama yapabiliriz.
   </para>
   <para>
    <xref linkend="sag_backup-history-timeline"/> her gün için hangi yedekleme
    seviyelerinin kullanıldığını ve ay sonunda hangi yedeklemelerin geri
    yüklenebilir olduğunu göstermektedir.
   </para>
    <figure xml:id="sag_backup-history-timeline" floatstyle="1">
     <title>Çok seviyeli yedekleme tablosu örneği</title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="images/backup-timeline-tr.gif"/>
      </imageobject>
     </mediaobject>
    </figure>
   <para>
    Yedekleme seviyeleri, dosya sistemlerinin geri yükleme süresini
    minimumda tutmak için de kullanılabilir.  Şayet sıkıcı bir şekilde
    artan seviye numaralarına sahip pek çok fark yedeğiniz var ise
    bütün sistemi yeniden kurmak için, onların hepsini yeniden yüklemek
    zorundasınız.
   </para>
   <para>
    Geri yüklenmesi gereken bant sayısını minimize etmek için, her bir
    fark yedeği bandı için daha küçük seviyeler kullanabilirsiniz. Bunun
    yanında, yedekleme için gereken süre artacaktır (her yedek bir önceki
    tam yedeklemeden itibaren her şeyi kopyalar). En iyi tablo
    <command>dump</command> kılavuz sayfasında önerilmektedir. Bu sıralı
    yedekleme seviyelerini kullanınız: 3, 2, 5, 4, 7, 6, 9, 8, 9... Bu hem
    yedekleme hem de geri yükleme süresini kısa tutacaktır.  En fazla
    iki günlük işe eşit bilgileri yedeklemeniz gerekmektedir. Geri
    yüklemeniz gereken bant sayısı iki tam yedekleme arasını ne kadar
    uzun tuttuğunuza dayanır.
   </para>
    <table xml:id="sag_efficient-backup-levels">
     <title>Çok sayıda yedekleme seviyesi ile verimli bir yedekleme örneği</title>
     <tgroup cols="4">
      <thead>
       <row>
        <entry>Bant</entry>
        <entry>Seviye</entry>
        <entry>Yedekleme (gün)</entry>
        <entry>Geri Yükleme (bant nr)</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>1</entry>
        <entry>0</entry>
        <entry>yok</entry>
        <entry>1</entry>
       </row>
       <row>
        <entry>2</entry>
        <entry>3</entry>
        <entry>1</entry>
        <entry>1, 2</entry>
       </row>
       <row>
        <entry>3</entry>
        <entry>2</entry>
        <entry>2</entry>
        <entry>1, 3</entry>
       </row>
       <row>
        <entry>4</entry>
        <entry>5</entry>
        <entry>1</entry>
        <entry>1, 2, 4</entry>
       </row>
       <row>
        <entry>5</entry>
        <entry>4</entry>
        <entry>2</entry>
        <entry>1, 2, 5</entry>
       </row>
       <row>
        <entry>6</entry>
        <entry>7</entry>
        <entry>1</entry>
        <entry>1, 2, 5, 6</entry>
       </row>
       <row>
        <entry>7</entry>
        <entry>6</entry>
        <entry>2</entry>
        <entry>1, 2, 5, 7</entry>
       </row>
       <row>
        <entry>8</entry>
        <entry>9</entry>
        <entry>1</entry>
        <entry>1, 2, 5, 7, 8</entry>
       </row>
       <row>
        <entry>9</entry>
        <entry>8</entry>
        <entry>2</entry>
        <entry>1, 2, 5, 7, 9</entry>
       </row>
       <row>
        <entry>10</entry>
        <entry>9</entry>
        <entry>1</entry>
        <entry>1, 2, 5, 7, 9, 10</entry>
       </row>
       <row>
        <entry>11</entry>
        <entry>9</entry>
        <entry>1</entry>
        <entry>1, 2, 5, 7, 9, 10, 11</entry>
       </row>
       <row>
        <entry>...</entry>
        <entry>9</entry>
        <entry>1</entry>
        <entry>1, 2, 5, 7, 9, 10, 11, ...</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   <para>
    Bu hayali tablo işçilerin sayısını azaltabilir, ama dikkatle izlemenizi
    gerektiren pek çok şey olduğu anlamına da gelmektedir. Değip
    değmeyeceğine siz karar vermelisiniz.
   </para>
   <para>
    <command>dump</command> komutu yedekleme seviyelerini desteklemek
    için yaratılmıştır. <command>tar</command> ve <command>cpio</command>
    komutları için ek araçlar kullanmanız gerekir.
   </para>
  </sect1>
  <sect1 xml:id="sag_backups_to">
   <title>Neler yedeklenmeli?</title>
   <para>
    Mümkün oldukça çok yedekleme yapmak isteyebilirsiniz. Temel istisna;
    kurulması daha kolay olan uygulamalardır, yedeklenmesi gereken bazı
    ayar dosyaları olsa bile ve siz bunları tekrar tekrar düzenlemek
    istemeseniz bile  hangi yöntemin daha kolay olacağına siz karar
    vereceksiniz).  Bir diğer temel istisna <filename>/proc</filename>
    dosya sistemidir. Çünkü burası çekirdek tarafından otomatik olarak
    yenilenen bilgiler ihtiva eder. Burayı yedeklemek hiç de akıllıca
    bir şey değildir.  Özelliklede <filename>/proc/kcore</filename>
    dosyasının yedeklenmesi tamamen gereksizdir, çünkü burası
    fiziksel belleğinizin bir yansımasıdır ve genellikle çok büyüktür.
   </para>
   <para>
    Yarı önemli bölümler: <filename>/var</filename> dizini içindeki haber
    havuzları, günlük kayıt dosyaları ve diğer şeylerdir. Neyin önemli
    olduğuna siz karar vermek zorundasınız.
   </para>
   <para>
    Açık olan; kullanıcı dizinlerinin (<filename>/home</filename>) ve
    sistem ayar dosyalarının (<filename>/etc</filename> dizini ve
    mümkünse sistemde yayılmış olan diğerleri) yedeklenmesi gerektiğidir.
   </para>
  </sect1>
  <sect1 xml:id="sag_backups_compress">
   <title>Sıkıştırılmış yedekler</title>
   <para>
    Yedeklemek çok büyük alanlara ve çok paraya mal olabilir. Yer ihtiyacını
    azaltmak için yedekler sıkıştırılabilir. Bunu yapmanın çeşitli yolları
    vardır.  Bazı uygulamalar sıkıştırmayı desteklemek için yapılmışlardır.
    Örneğin; <option>--gzip</option> (<option>-z</option>) seçeneği, GNU
    <command>tar</command>'ı yedekleme ortamına yazmadan önce sıkıştırılmak
    üzere <command>gzip</command> sıkıştırma uygulamasına yönlendirir.
   </para>
   <para>
    Maalesef sıkıştırma işlemleri sorun çıkarabilir. Sıkıştırmanın nasıl
    çalıştığına bağlı olarak, şayet bir bitlik alanda sorun varsa bütün
    sıkıştırılmış bilgi heba olabilir.  Bazı yedekleme uygulamaları
    içlerinde hata düzeltmesi yerleşik olarak gelir, fakat  hiçbir
    sistem bu kadar çok sayıda hatayı düzeltemez. Bunun anlamı bir
    yedekleme GNU <command>tar</command>'ın yaptığı gibi bütün çıktı
    tek bir birim olacak şekilde sıkıştırılırsa ve tek bir hata bile
    geri kalan bütün bilgiyi çöpe gönderebilir.  Yedekler güvenilir
    olmalıdır ve bu sıkıştırma metotları  hiç de iyi bir fikir değildir.
   </para>
   <para>
    Başka bir yol ise, her bir dosyayı ayrı ayrı sıkıştırmaktadır.
    Bu yolla bir dosya zarar gördüğü halde, diğerleri herhangi bir
    zarara uğramamış durumda bulunur. Kayıp dosya her halükarda
    bozulmuş olacaktır, ama bu durum sıkıştırmayı hiç kullanmamaktan
    daha  kötü değildir. <command>afio</command> uygulaması
    (<command>cpio</command>'nun  bir çeşidi) bunu yapabilir.
   </para>
   <para>
    Sıkıştırma biraz zaman alan bir iştir. Bu da yedekleme uygulamasının
    banda yeterince hızlı bir şekilde yazamaması sonucunu ortaya çıkarır
    ve bu durumda teyp sürücüsü durur. Bu hem bant hem de sürücüsü için
    hiç iyi değildir. Bundan kaçmak için çıktının tamponlanması sistemi
    kullanılabilir, fakat bu da yeterince iyi çalışmayabilir. Bu sadece
    yavaş bilgisayarlar için bir sorun teşkil edebilir.
   </para>
  </sect1>
 </chapter>
 <chapter xml:id="sag_time">
  <title>Zaman Ayarları</title>
   <preliminary>
    <blockquote>
     <simpara>
      "Zaman bir gözboyamadır. Öğle yemeği zamanı iki kere gözboyamadır."
     </simpara>
     <simpara>
      (Douglas Adams.)
    </simpara>
   </blockquote>
   <para>
    Bu bölümde Linux sisteminin zamanı nasıl koruduğu ve sorunlardan
    kaçmak için ne yapmanız gerektiği anlatılmaktadır. Genellikle
    zaman hakkında endişe etmeniz gerekmez, ama nasıl çalıştığını
    bilmek iyidir.
   </para>
  </preliminary>
  <sect1 xml:id="sag_time-zones">
   <title>Zaman dilimleri</title>
   <para>
    Zamanın ölçümü en doğal ve düzenli olay üzerine kurulmuştur: dünyanın
    dönmesinden kaynaklanan gündüz ve gece değişim periyotları üzerine.
    Bu iki ardışık periyodun oluşturduğu toplam zaman sabittir. Sadece
    gece ve gündüzün uzunluğu değişir. Diğer bir sabit ise öğle vaktidir.
   </para>
   <para>
    Öğle, Güneşin en yüksek noktada olduğu andır. Dünya yuvarlak olduğu
    için değişik bölgelerde değişik zamanlarda öğle olmaktadır. Bu
    <glossterm>yerel zaman</glossterm> kavramını ortaya çıkarmıştır.
    İnsanlar zamanı pek çok birim kullanarak ölçer, pek çoğu doğal
    bir olgu olan "öğle" ye bağlıdır.  Aynı yerde bulunduğunuz sürece
    yerel zamanın ne olduğu önemli değildir.
   </para>
   <para>
    Uzak yerlerle haberleşme ihtiyacı ortaya çıkar çıkmaz, genel zaman
    kavramının zaruretini anlayacaksınız. Modern zamanlarda, dünyanın
    pek çok yeri diğer yerleri ile iletişim halindedir ve bu nedenle
    zamanı ölçmenin küresel bir standardı tanımlanmıştır. Bu zamana
    <glossterm>evrensel zaman</glossterm> denir (UT ya da UTC - evrensel
    zaman, resmi olarak Greenwich Mean Time, GMT olarak geçer, çünkü
    İngiltere'de ki Greenwich bölgesinin yerel zamanına göre ayarlanmıştır).
    Değişik yerel zamanlara sahip  insanlar birbirleri ile haberleşme
    ihtiyacı duydukları zaman, zamanı evrensel saate çevirir ve böylece
    neyin ne zaman yapılması gerektiği ortaya çıkar.
   </para>
   <para>
    Her bir yerel zaman, zaman dilimi diye adlandırılır. Coğrafi şartlar,
    aynı anda öğle olan yerlerde aynı zaman dilimini kullanmaya imkan
    verirken, politikalar bunu  zorlaştırmaktadır. Çok çeşitli
    sebeplerden dolayı, pek çok ülke <glossterm>yaz saati</glossterm>
    kullanmaktadır.  Bu çalışırken daha fazla doğal
    ışık alabilmek için kendi saatlerini ileri almaları ve kış gelince
    geri çekmeleri anlamına gelir. Diğer ülkeler bunu yapmazlar. Bunu
    yapanlar, saatlerin ne zaman değiştirilmesi gerektiği konusunda
    anlaşamazlar ve kuralları her yıl değiştirir. Bu da zaman bölgeleri
    değişimini çok önemsiz bir hale getirir.
   </para>
   <para>
    Zaman bölgeleri, en iyi, yerleşim bölgesine göre ya da evrensel
    zamandan olan farkı söylenerek adlandırılır. ABD ve diğer bazı
    ülkelerde yerel zaman isimlere ve üç harften oluşan kısaltmalara
    sahiptir.  Kısaltmalar benzersiz değildir ve ülkenin adı
    belirtilmeden kullanılmamalıdır. En iyisi konuşurken Helsinki,
    Doğu Avrupa diye söylemektir. Çünkü bütün Doğu Avrupa ülkeleri
    aynı kuralları kullanmazlar.
   </para>
   <para>
    Linux bir zaman dilimleri paketine sahiptir ve bunun sayesinde
    bütün varolan zaman bölgelerini bilir ve gerekirse kolayca
    güncellenebilir.  Bütün sistem yöneticileri kendilerine uygun
    zaman bölgesini seçmek zorundadır. Ayrıca, kullanıcılar kendi
    zaman ayarlarını yapabilir, bu özellikle Internet üzerinden
    tek bir bilgisayarda çalışan ama farklı ülkelerde yaşayan kişiler
    için uygun olacaktır. İçinde bulunduğunuz zaman bölgesinde
    kullanılan yaz saati kuralları değiştiğinde,
    Linux sisteminin en azından bu bölümünü güncellediğinizden emin olun.
    Sistem zaman dilimini ayarlamak ve güncellemekten başka, zaman için
    endişelenmenizi gerektirecek çok az durum meydana gelir.
   </para>
  </sect1>
  <sect1 xml:id="sag_time-hwclock">
   <title>Yazılım ve donanım saatleri</title>
   <para>
    Bir kişisel bilgisayar donanım saatini çalıştırmak için bir pil
    kullanır. Bu pil sayesinde, bilgisayarda elektrik olmasa bile
    saatin çalışması sağlanır. Donanım saati BIOS ayar ekranından
    veya işletim sisteminin her neresinde bulunuyorsa oradan
    ayarlanabilir. Linux çekirdeği zamanı, donanım saatinden bağımsız
    olarak saklar. Açılış esnasında Linux kendi saatini, donanım
    saatine göre ayarlar. Bundan sonrasında her iki saatte birbirinden
    bağımsız olarak çalışır. Linux kendi saatini korur, çünkü her
    seferinde donanım saatine bakmak yavaş ve karışık bir iştir.
   </para>
   <para>
    Çekirdek saati daima evrensel zamanı gösterir. Böylece çekirdek
    bütün zaman dilimleri hakkında bilgi sahibi olmak zorunda kalmaz.
    En basit sonuçları daha yüksek güvenilirlik ve güncelleme esnasında
    kolaylıktır. Her süreç, kendi zaman değişimini kendi denetler
    (timezone paketinin parçası olan standart araçları kullanarak).
   </para>
   <para>
    Donanım saati evrensel veya yerel saatte olabilir.  Bunu evrensel
    zamanda tutmak genellikle daha iyidir, çünkü yaz saati uygulaması
    başladığı ya da bittiği zaman donanım saatini değiştirmek
    zorunda kalmazsınız. (UTC, yaz saati farkını içermez.)
    Şansızlık eseri, bazı PC işletim sistemleri; MS-DOS, Windows ve OS/2
    dahil, donanımın yerel zamanı gösterdiğini varsayar. Linux birinden
    birini kullanabilir, fakat şayet donanım zamanı yerel saati gösteriyorsa
    yaz saatinin başlangıç ve bitimlerinde sistemi
    yeniden ayarlamanız gerekir (aksi taktirde saat yerel zamanı göstermez).
   </para>
  </sect1>
  <sect1 xml:id="sag_time-showing">
   <title>Zaman gösterimi ve ayarlanması</title>
   <para>
    Linux Sistemlerinde, sistem zaman dilimi ayarı
    <filename>/etc/localtime</filename> sembolik bağı ile ayarlanır. Bu bağ
    yerel zaman dilimini gösteren bir zaman bölge bilgi dosyasını işaret eder.
    Zaman dilimi bilgi dosyaları, kullandığınız dağıtıma bağlı olarak ya
    <filename>/usr/lib/zoneinfo</filename> ya da
    <filename>/usr/share/zoneinfo</filename> içerisinde saklanır.
   </para>
   <para>
    Örneğin New Jersey'de bulunan bir SUSE sisteminde
    <filename>/etc/localtime</filename> bağı
    <filename>/usr/share/zoneinfo/US/Eastern</filename> dosyasını işaret
    eder. Bir Debian sisteminde ise <filename>/etc/localtime</filename> bağı
    <filename>/usr/lib/zoneinfo/US/Eastern</filename> dosyasını işaret eder.
   </para>
   <para>
    Eğer <filename>zoneinfo</filename> dizinini ne
    <filename>/usr/lib</filename> nede <filename>/usr/share</filename>
    dizinleri altında bulamıyorsanız; ya <userinput>find /usr -print | grep
    zoneinfo</userinput> komutunu kullanın ya da dağıtımınızın belgelerine
    bakın.
   </para>
   <para>
    Farklı bir zaman diliminde yerleşik bir kullanıcınız varsa ne olur? Bir
    kullanıcı kendi zaman dilimi ayarını <envar>TZ</envar> ortam değişkeninde
    belirterek  değiştirebilir. <envar>TZ</envar> ortam değişkeni
    ayaranmamışsa, sistem zaman dilimi geçerli olur. <envar>TZ</envar>
    değişkeninin sözdizimi <uri xl:href="man3-tzset"/> kılavuz sayfasında
    açıklanmıştır.
   </para>
   <para>
    <uri xl:href="man1-date"/> komutu o anki tarih ve saati gösterir.<footnote>
    <para>
     Dikkat, <command>time</command> komutu o an ki zamanı göstermez.
    </para></footnote> Örneğin:
   </para>
   <screen>
<prompt>$</prompt><userinput>date +%c</userinput>
Prş 16 Oca 2003 18:10:26 EET
<prompt>$</prompt>
</screen>
   <para>
    Günlerden Perşembe, 2003 yılının 16 Ocağı, akşam 6'yı 10 geçiyor
    (Saat EET yani Doğu Avrupa zaman dilimine göre ayarlı,
    <option>+%c</option> seçeneği tarih ve saati yerel biçemde göstermek
    içindir). <command>date</command> aynı zamanda evrensel zamanı da
    gösterebilir:
   </para>
   <screen>
<prompt>$</prompt><userinput>date -u +%c</userinput>
Prş 16 Oca 2003 16:10:26 UTC
<prompt>$</prompt>
</screen>
   <para>
    Ayrıca <command>date</command> çekirdeğin yazılım saatini
    ayarlamak için de kullanılabilir:
   </para>
   <screen>
<prompt>#</prompt> <userinput>date 1042734297</userinput>
Prş Oca 16 18:24:57 EET 2003
<prompt>#</prompt> <userinput>date +%c</userinput>
Prş 16 Oca 2003 18:25:10 EET
<prompt>#</prompt>
</screen>
   <para>
    Ayrıntılı bilgi için <command>date</command> kılavuz sayfasına
    bakabilirsiniz.  Sözdizimleri biraz esrarlı olabilir. Sadece
    root saat ayarı yapabilir. Her kullanıcı kendi için zaman dilimi
    ayarı yapabilirken, saat herkes için aynıdır.
   </para>
   <para>
    <command>date</command> sadece yazılım saatini gösterir veya ayarlar.
    <command>clock</command> komutu yazılım ve donanım saatleri arasındaki
    uyumu sağlar. Sistem açılış esnasında donanım saatini okumak ve
    yazılım saatini ayarlamak için kullanılır. Şayet her iki saati de
    ayarlamanız gerekirse önce yazılım saatini <command>date</command>
    ile ayarlayın ve daha sonra <command>clock -w</command> ile bunu
    donanım saatine yazın.
   </para>
   <para>
    <command>clock</command> ile kullanılan <option>-u</option> seçeneği,
    donanım saatine evrensel zaman içinde olmasını söyler.
    <option>-u</option> deçeneğini doğru bir şekilde kullanmalısınız.
    Aksi taktirde zaman konusunda, bilgisayarınızın kafası biraz karışabilir.
   </para>
   <para>
    Saat dikkatli bir şekilde değiştirilmelidir. Unix sisteminin pek çok
    parçası, saatin düzgün bir şekilde çalışmasına bağlıdır.  Örneğin:
    <command>cron</command> süreçleri komutları periyodik olarak
    çalıştırır.  Şayet saati değiştirirseniz, komutları çalıştırıp
    çalıştırmama konusunda karışıklık ortaya çıkabilir. Daha eski bir
    Unix sisteminde,  birileri saati geleceğe, yirmi yıl sonraki bir zamana
    ayarladı ve  cron  bu yirmi yıllık periyodik komutların hepsini
    birden yapmaya kalktı. <command>cron</command>'un şu anki sürümü
    bunu yapabiliyor ama siz yine de çok dikkatli olmalısınız.
    İleri veya geriye doğru sıçrayışlar, küçüklerden ve ileri doğru
    sıçramalardan daha tehlikelidir.
   </para>
  </sect1>
  <sect1 xml:id="sag_time-wrong">
   <title>Saat yanlışsa</title>
   <para>
    Linux sistem saati daima doğru değildir. PC donanımı tarafından
    üretilen periyodik bir <glossterm>zaman kesmesi</glossterm>nin
    çalıştırılması ile tutulur. Şayet sistemin yapması gereken pek
    çok iş var ise  zaman kesmesinin kullanılması çok gecikebilir ve
    sistem saati geri kalabilir. Donanım saati bağımsız çalışır ve
    çok daha doğrudur. Şayet sisteminizi sık sık açarsanız (sunucu
    harici bilgisayarlarda olduğu gibi) saatiniz daha doğru olacaktır.
   </para>
   <para>
    Şayet donanım saatini ayarlamak isterseniz, sistem enerjisini
    kapatıp BIOS ayarlarına girip orada gerekenleri yapın. Bu sistem
    saatini değişmesi sonucu ortaya çıkabilecek bütün sorunlardan
    sizi kurtarır.  Şayet bu ayarları BIOS üzerinde yapma şansınız
    yoksa, sırasıyla <userinput>date</userinput> ve
    <userinput>clock</userinput>
    komutlarını kullanın ve bazı süreçlerin komik hareketlerine
    karşı sistemi yeniden başlatmaya hazır olun.
   </para>
   <para>
    Donanım saatinizin, sistem saatinize ayarlanmasını diğer bir yolu ise,
    <userinput>hwclock -w</userinput>  veya
    <userinput>hwclock --systohc</userinput> komutlarından birisini
    kullanmaktır. Eğer sistem saatinizin donanım saatinize göre
    ayarlanmasını istiyorsanız; <userinput>hwclock -s</userinput> veya
    <userinput>hwclock --hctosys</userinput> komutlarından birisini
    kullanmalısınız.
   </para>
  </sect1>
  <sect1 xml:id="sag_network_time">
   <title>Ağ Zaman Protokolü</title>
   <para>
    Bir ağ bilgisayarı (bir modemin ucunda bile olsa) kendi saatini otomatik
    olarak ayarlayabilir.  Bunu diğer bilgisayarların zamanı ile
    karşılaştırarak yapar. NTP (Ağ Zaman Protokolü)'nin yaptığı şey budur.
    Sisteminizin saatini, test eder ve uzak sunucudaki saat ile uyumlu hale
    getirir. NTP ile, sisteminiz milisaniyeler içinde, Evrensel Zamana Uyumlu
    (Coordinated Universal Time/ UTC) hale getirilir.<footnote>
    <para>
     Ayrıntılı bilgi için <link xl:href="http://www.time.gov/about.html/"/> adresini ziyaret ediniz.
    </para></footnote>
   </para>
   <para>
    Pek çok Linux kullanıcısı için bu oldukça hoş bir lükstür. Benim evimdeki
    bütün saatler, Linux sistemine göre ayarlıdır. Daha büyük organizasyonlar
    için bu lüks, kaçınılmaz bir gereklilik olabilir.  Zamanlarına göre
    ayrılmış olaylar için kütük dosyalarında arama yapabilmek, işleri oldukça
    kolaylaştırır ve hata ayıklamada "tahmini işlerle" uğraşmak zorunda
    kalmanızı önler.
   </para>
   <para>
    Pek çok Linux dağıtımı bir NTP paketi ile gelir. Bu ya
    <filename>.deb</filename> ya da <filename>.rpm</filename> paketi olabilir.
    Bu paketleri NTP kurmak için kullanabilirsiniz ve yahut  kaynak kodlarını
    <link xl:href="http://www.ntp.org/downloads.html"/> adresinden
    alabilirsiniz ve kendiniz derleyebilirsiniz. Her halükarda temel ayarlar
    aynıdır.
   </para>
  </sect1>
  <sect1 xml:id="sag_basic_ntp_confs">
   <title>Temel NTP Ayarları</title>
   <para>
    Hangi dağıtımı kullandığınıza bağlı olarak NTP ayarları ya
    <filename>/etc/ntp.conf</filename> ya da
    <filename>/etc/xntp.conf</filename> dosyasından yapılır. NTP ayarlarının
    ayrıntılarına çok fazla girmeyeceğim. Burada sadece temel ve basit
    ayarları anlatacağım.
   </para>
   <para>
    Temel bir <filename>ntp.conf</filename> dosyası şuna benzer:
   </para>
    <screen>
# --- GENEL YAPILANDIRMA ---
server  aaa.bbb.ccc.ddd
server  127.127.1.0
fudge   127.127.1.0 stratum 10

# Hedef dosya.

driftfile /etc/ntp/drift
</screen>
   <para>
    Pek çok temel yapılandırmalı <filename>ntp.conf</filename> dosyasında
    iki adet sunucu ismi mevcuttur. Birisi, saat ayarının yapılmasını istenen
    sunucunun adı ve sahte bir IP adresinden oluşur (bu örnekte 127.127.1.0).
    Sahte IP adresi ağ sorunları olması durumunda veya NTP sunucunun kapalı
    olması/çökmesi durumunda kullanılır. Sisteminizdeki NTP uygulaması, uzak
    NTP sunucusu ayağa kalkınca, sistem saatini tekrar ona göre
    ayarlayacaktır. Bir iki sunucudan birincisi asıl sunucu olarak işlem
    yapar, ikincisi ise yedek amaçlıdır: Kötü günlerinizde kullanın diye.
   </para>
   <para>
    Ayrıca bu hedef dosyanın yerini de belirtmelisiniz. Zamanla NTP, sistem
    saatindeki hata oranını "öğrenecek" ve kendini buna göre ayarlayacaktır.
   </para>
   <para>
    Daha iyi bir denetim sağlamak ve güvenliği elden bırakmamak için NTP'de
    kısıtlama/restrict seçeneği kullanılabilir. Örneğin:
   </para>
   <screen>
# Bu hizmete genel erişimi yasakla.
resrict default ignore

# Bu ağdaki sistemlere, şu zaman hizmetleri ile ayarlama
# yapmalarına izin ver. Fakat bizim zaman ayarımızı değiştirme.
restrict aaa.bbb.ccc.ddd nomodify

# ntpd'ye aşağıdaki şu kısıtlanmamış erişime izin ver.

restrict aaa.bbb.ccc.ddd
restrict 127.0.0.1
</screen>
   <para>
    Kısıtlama seçeneğini kullanmadan önce, düzgün çalışan bir NTP (Ağ Zaman
    protokolü) hizmetine sahip olmanız şiddetle tavsiye edilir. Kazara,
    uyarlama yapılmasına kısıtlama getirebilir ve nerede hata olduğunu bulmak
    için saatlerinizi harcayabilirsiniz.
   </para>
   <para>
    NTP hizmeti, sistem saatinizi yavaşca ayarlayacaktır. Sabırlı olun!!!
    Basit bir test: Yatmaya gitmeden 10 dakika önce sistem saatini değiştirin
    ve yatın. Sabah kalktığınızda sistem saatinizin doğru olduğunu
    göreceksiniz.
   </para>
  </sect1>
  <sect1 xml:id="sag_ntp_toolkit">
   <title>NTP Araçları</title>
   <para>
    NTP hizmetinin işni düzgün yapıp yapmadığını görmek için birkaç araç
    vardır. <userinput>ntpq -p</userinput> komutu, sisteminizin o anki zaman
    durumunu gösterecektir.
   </para>
   <screen>
<prompt>#</prompt> <userinput>ntpq -p</userinput>
     remote           refid      st t when poll reach   delay   offset  jitter
==============================================================================
*cudns.cit.corne ntp0.usno.navy.  2 u  832 1024  377   43.208    0.361   2.646
 LOCAL(0)        LOCAL(0)        10 l   13   64  377    0.000    0.000   0.008
</screen>
   <para>
    <userinput>ntpdc -c loopinfo</userinput> komutu; uzak sunucuya yapılan
    en son bağlantıdan beri sistem saatinin ne kadarlık bir hata yaptığını
    saniye cinsinden gösterir.
   </para>
   <screen>
<prompt>#</prompt> <userinput>ntpdc -c loopinfo</userinput>
offset:               -0.004479 s
frequency:            133.625 ppm
poll adjust:          30
watchdog timer:       404 s
</screen>
   <para>
    <userinput>ntpdc -c kerninfo</userinput> komutu, o anki kalan doğrulamayı
    gösterir.
   </para>
    <screen>
<prompt>#</prompt> <userinput>ntpdc -c kerninfo</userinput>
pll offset:           -0.003917 s
pll frequency:        133.625 ppm
maximum error:        0.391414 s
estimated error:      0.003676 s
status:               0001  pll
pll time constant:    6
precision:            1e-06 s
frequency tolerance:  512 ppm
pps frequency:        0.000 ppm
pps stability:        512.000 ppm
pps jitter:           0.0002 s
calibration interval: 4 s
calibration cycles:   0
jitter exceeded:      0
stability exceeded:   0
calibration errors:   0
</screen>
   <para>
    <userinput>ntpdc -c kerninfo</userinput> komutunun çok az değişik bir
    sürümü de <userinput>ntptime</userinput> komutudur.
   </para>
   <screen>
<prompt>#</prompt> <userinput>ntptime</userinput>
ntp_gettime() returns code 0 (OK)
  time c35e2cc7.879ba000  Thu, Nov 13 2003 11:16:07.529, (.529718),
  maximum error 425206 us, estimated error 3676 us
ntp_adjtime() returns code 0 (OK)
  modes 0x0 (),
  offset -3854.000 us, frequency 133.625 ppm, interval 4 s,
  maximum error 425206 us, estimated error 3676 us,
  status 0x1 (PLL),
  time constant 6, precision 1.000 us, tolerance 512 ppm,
  pps frequency 0.000 ppm, stability 512.000 ppm, jitter 200.000 us,
  intervals 0, jitter exceeded 0, stability exceeded 0, errors 0.
</screen>
   <para>
    NTP'nin nasıl çalıştığını görmenin bir diğer yöntemide
    <userinput>ntpdate -d</userinput> komutudur. Bu komutla sisteminiz bir
    NTP sunucuya bağlanır ve zaman sapması var ise bunu size gösterir ama
    sistem saatini ayarlamaz.
   </para>
    <screen>
<prompt>#</prompt> <userinput>ntpdate -d 132.236.56.250</userinput>
13 Nov 14:43:17 ntpdate[29631]: ntpdate 4.1.1c-rc1@1.836 Thu Feb 13 12:17:20
transmit(132.236.56.250)
receive(132.236.56.250)
transmit(132.236.56.250)
receive(132.236.56.250)
transmit(132.236.56.250)
receive(132.236.56.250)
transmit(132.236.56.250)
receive(132.236.56.250)
transmit(132.236.56.250)
sunucu 132.236.56.250, port 123
stratum 2, precision -17, leap 00, trust 000
refid [192.5.41.209], delay 0.06372, dispersion 0.00044
transmitted 4, in filter 4
reference time:    c35e5998.4a46cfc8  Thu, Nov 13 2003 14:27:20.290
originate timestamp: c35e5d55.d69a6f82  Thu, Nov 13 2003 14:43:17.838
transmit timestamp:  c35e5d55.d16fc9bc  Thu, Nov 13 2003 14:43:17.818
filter delay:  0.06522  0.06372  0.06442  0.06442
         0.00000  0.00000  0.00000  0.00000
filter offset: 0.000036 0.001020 0.000527 0.000684
         0.000000 0.000000 0.000000 0.000000
delay 0.06372, dispersion 0.00044
ofset 0.001020

13 Nov 14:43:17 ntpdate[29631]: adjust time server 132.236.56.250 ¬
offset 0.001020 sec
</screen>
   <para>
    Sistem saatinizin ayarlanma sürecini izlemek istiyorsanız
    <userinput>ntptrace</userinput> komutunu kullanın.
   </para>
    <screen>
<prompt>#</prompt> <userinput>ntptrace 132.236.56.250</userinput>
cudns.cit.cornell.edu: stratum 2, offset -0.003278, synch distance 0.02779
dtc-truetime.ntp.aol.com: stratum 1, offset -0.014363, synch distance 0.00000, ¬
refid 'ACTS'
</screen>
   <para>
    Şayet sistem saatinizin acilen ayarlanması gerekiyorsa,
    <userinput>ntpdate uzak-sunucu-ismi</userinput> komutunu
    kullanabilirsiniz. Ayar için beklemeniz gerekmez!
   </para>
    <screen>
<prompt>#</prompt> <userinput>ntpdate 132.236.56.250</userinput>
13 Nov 14:56:28 ntpdate[29676]: adjust time server 132.236.56.250 ¬
offset -0.003151 sec
</screen>
   <!-- Add section why ntpdate as a cron job is not favorable -->
  </sect1>
  <sect1 xml:id="sag_some_npt_servers">
   <title>Bazı NTP sunucuları</title>
   <para>
    Halka açık NTP sunucularının bir listesini <link xl:href="https://www.pool.ntp.org/zone/tr/"/> adresinden alabilirsiniz. Bir sunucuyu kullanmadan önce sayfadaki açıklamaları dikkatlice okuyunuz. Bütün sunucular, kendisine bağlanan herkesin zaman ayarlarını yapacak kadar  bant genişliğine sahip değildir. Bu nedenle, bir sistem yöneticisine başvurup, onun bilgisayarını bir NTP sunucu olarak kullanmak istediğinizi bildirmek daha uygun olabilir.
   </para>
   <para>
    NTP'ler hakkında daha ayrıntılı bilgi NTP ana sayfasından elde edilebilir:
    <link xl:href="http://www.ntp.org/"/>
   </para>
   <para>
    Veya <link xl:href="http://www.ntp.org/ntpfaq/NTP-a-faq.htm"/> sayfasını kullanabilirsiniz.
   </para>
  </sect1>
 </chapter>
 <!-- Open Source bölümü yeni bir bölüm olarak eklenecek-->
 <chapter xml:id="sag_helpme">
  <title>Yardım Bulmak</title>
  <preliminary>
   <blockquote>
    <para>
     "Help me if you can I'm feeling down. And I do appreciate you
     being 'round." - The Beatles
    </para>
   </blockquote>
   <para>
    Yardım dışarda. Sadece nereye bakacağını bilmelisin. Linux ile
    gidebileceğiniz inanılmaz sayıda yer var. Posta listeleri, IRC kanalları,
    halka açık forumları olan siteler ve diğer birçok kaynak mevcuttur. Bu
    bölüm, yardım arayışınızdan en iyi şekilde yararlanmanıza yardımcı
    olmaya çalışacak.
   </para>
  </preliminary>
  <sect1 xml:id="sag_helpme-lists">
   <title>Haber grupları ve eposta listeleri</title>
   <para>
    Bu kılavuz size Linux hakkında her şeyi öğretemez. Bunun için
    yeterli yerimiz yok. Aynı konular üzerinde başka bilgilere
    ihtiyaç duymanız kaçınılmazdır. Ve bu LDP'deki  herhangi bir
    kılavuzda açıklanmamış olabilir.
   </para>
   <para>
    Linux'un hoş taraflarından biriside, kendini bu işe adamış pek çok
    forumun bulunmasıdır. Yeni başlayanlar için SSS'lardan
    çekirdek gelişimine kadar Linux'un her yönünü kapsayan forumlar
    mevcuttur.  Bunlardan faydalanmak için yapmanız gereken birkaç
    şey vardır.
   </para>
   <sect2>
    <title>Doğru forumun bulunması</title>
    <para>
     İlk önce uygun bir forum bulmalısınız. Pek çok haber grubu ve
     posta listeleri vardır, sizin sorularınıza en uygun olan birini
     bulmayı ve kullanmayı deneyin. Örneğin: Linux çekirdek gelişimine
     adanmış bir forumda sendmail hakkında soru sormak pek mantıklı
     değildir. En iyi ihtimalle birkaç cevap alırsınız ve insanlar
     sizin aptal olduğunuzu düşünür veya daha kötüsü aşağılayıcı pek
     çok cevap alabilirsiniz. Çabuk bir araştırma sonucu
     comp.mail.sendmail adında, sendmail ile ilgili soru sormaya uygun
     bir yer bulabilirsiniz. Haber istemcinizin size uygun haber gruplarını
     içeren bir listesi olabilir veya tüm haber gruplarının tam bir
     listesini şu adresten bulabilirsiniz.
     <link xl:href="http://groups.google.com/groups?group=*"/>
    </para>
   </sect2>
   <sect2>
    <title>Postalamadan önce</title>
    <para>
     Şimdi uygun bir forum buldunuz ve sorunuzu yollamaya hazır
     olduğunuzu düşünüyorsunuz. Durun. Henüz hazır değilsiniz.
     Kendi kendinize sorunun cevabını bulmaya çalıştınız mı?
     Pek çok NASIL ve SSS belgesi mevcuttur; bunlardan birisi
     sizin sorununuzu içeriyorsa önce bu belgeyi okuyun. Sorunuzun
     cevabını içermese bile, sorununuzu daha doğru ve etkin bir
     şekilde aktarmak için gereken bilgiyi size kazandırabilir.
     Ayrıca haber gruplarının ve posta listelerinin arşivleri
     vardır ve muhtemelen sizin sorunuz daha önce sorulmuş ve
     cevaplanmış olabilir. <link xl:href="http://www.google.com"/>
     ve benzeri arama motorları sorunuzu göndermeden önce
     bakabileceğiniz diğer yerlerdir.
    </para>
   </sect2>
   <sect2>
    <title>Posta iletisinin yazılması</title>
    <para>
     Tamam, doğru forumu buldunuz, ilgili SSS ve NASIL belgelerini
     okudunuz, web'i taradınız ama sorunuzun cevabını halen bulamadınız.
     Şimdi postanızı yazmaya başlayabilirsiniz.  Aşağıdakine benzer
     bir şeyler söyleyerek, konu hakkında daha önceden bazı belgeleri
     okuduğunuzu açıklığa kavuşturmak iyi  bir şey olacaktır:
     "WinModem HOWTO ve PPP FQA belgelerini okudum, ama hiç biri
     benim aradığım şeyi ihtiva etmiyor. 'WinModem Linux PPP ayarı'
     ile ilgili Google'da hiçbir şey bulamadım." Bu cümle, kaşıkla
     beslenmeye ihtiyaç duyan tembel bir gerzek yerine sizi biraz
     çaba sarf etmiş biri olarak gösterecektir. İlk şey, şayet cevabı
     bilen birisi varsa size bir cevap geleceğidir, sonraki ise; derin
     bir sessizlik ile karşılaşmak gibidir.
    </para>
    <para>
     Açık seçik, imlâ ve yazım kurallarına dikkat ederek yazın. Bu çok
     önemlidir.  Bu sizin düşünceli ve titiz birisi olduğunuz izlenimini
     verir.  Aptal gibi görünmektense eğitimli ve akıllı birisi gibi
     görünmeyi deneyin. Söz veriyorum işinize yarayacaktır.
    </para>
    <para>
     BENİM YAPTIĞIM GİBİ büyük harfler kullanmayın. Bu bağırdığınız ve
     kaba biri olduğunuz anlamına gelecektir.
    </para>
    <para>
     Sorunun ayrıntılarını ve bu sorunu gidermek için neler
     yaptığınızı açıkça gösterin.  "Linux çalışmayı durdurdu,
     ne yapmalıyım?" gibi bir soru hiçbir işe yaramaz. Nerede
     çalışma durdu? Ne şekilde çalışmayı durdurdu? Mümkün olduğunca
     kusursuz olmalısınız. Bunun yanında sınırlar da vardır. Konuyla
     alakasız bilgiler göndermeyin. Şayet posta alıcınız ile ilgili
     bir sorununuz varsa, bunun çekirdeğinizin açılış kayıtlarının
     (<command>dmesg</command>) aptallığı ile bir ilgisi olma ihtimali
     yoktur.
    </para>
    <para>
     Asla özel eposta göndererek soru sormayın. Bu listelerdeki ana nokta,
     herkesin birbirinden bir şeyler öğrenmesidir. Özel soru iletileri,
     haber grupları veya posta listelerinin değerini ortadan kaldırır.
    </para>
   </sect2>
   <sect2>
    <title>Epostanın biçimi</title>
    <para>
     HTML biçeminde postalamayın. Pek çok Linux kullanıcısı, HTML iletileri
     rahatça okuyamayacakları posta alıcılarına sahiptir.   Biraz çaba
     ile okuyabileceklerken, onlar bunu yapmazlar. Şayet HTML ileti
     yollarsanız genellikle okunmadan silinir. Düz yazı iletiler gönderin,
     bu yolla daha geniş bir kitleye ulaşabilirsiniz.
   </para>
   </sect2>
   <sect2>
    <title>Takip edin</title>
    <para>
     Sorununuz çözüldükten sonra, sorunun ne olduğunu ve nasıl
     çözdüğünüzü içeren kısa bir ileti yollayın. Bu hem, gelecekte
     aynı sorunla karşılaşacak birisine yardımcı olacaktır, hem de
     insanlar bu sorunla ilgili tartışmanın bittiğini anlayacaklardır.
     Haber grubu veya posta listesi arşivine baktıkları zaman sizin de
     bu sorunla karşılaştığınızı, sorunuzu ve sorunun çözümünü
     göreceklerdir.
    </para>
   </sect2>
   <sect2>
    <title>Daha fazla bilgi</title>
    <para>
     Bu bölümdeki kısa kılavuz, Eric S. Raymond tarafından yazılmış
     daha ayrıntılı ve mükemmel bir kılavuz olan
     <link xl:href="/howto/smart-questions.html">Doğru Düzgün Soru
     Sormanın Yolları</link>'nın kısa bir özetidir. Herhangi bir şey
     postalamadan önce bu kılavuzu okumanız tavsiye edilir. Cevabını
     aradığınız sorunuz için cevap bulma olasılığınızı yükseltecek formüller
     içermektedir.
    </para>
   </sect2>
  </sect1>
  <sect1 xml:id="sag_helpme_irc">
   <title>IRC</title>
   <para>
    IRC (Internet Relay Chat), Eric Raymond'ın kılavuzunda
    anlatılmamaktadır ama IRC ihtiyaçlarınıza cevap verebilecek
    mükemmel bir seçenek olabilir.  Bununla birlikte, bu doğru bir
    şekilde soru sorma hakkında biraz pratik gerektirir. Pek çok IRC
    #Linux kanalları oldukça meşguldür ve şayet sorununuzun cevabı
    kılavuz sayfalarında ve NASIL belgelerinde varsa, bunları okumanızın
    söyleneceğini umabilirsiniz.  İmla ve yazım kuralları burada da
    geçerlidir.
   </para>
   <para>
    Posta listeleri ve haber grupları ile ilgili söylenenlerin pek çoğu
    IRC içinde geçerlidir. Ek olarak aşağıdakiler vardır.
   </para>
   <sect2>
    <title>Renkler</title>
    <para>
     Renkli, kalın, altı çizgili veya garip karakterler kullanmayın.
     Bunlar bazı eski istemcilerle uyumlu değildir ve okunması çok zor
     olan metinlerdir. Bir kanala girer ve hemen renkler veya kalınlık
     kusmaya başlarsanız dışarı atılmanız an meselesidir.
    </para>
   </sect2>
   <sect2>
    <title>Kibar olun</title>
    <para>
     Cevap almak size verilmiş bir hak değildir. Şayet düzgün bir şekilde
     sorarsanız, büyük ihtimalle bir cevap alırsınız ama bir cevap almak
     "hakkınız" yoktur.  Linux IRC kanallarındaki insanlar kendi zamanlarını
     harcıyor ve hiç kimse onlara bunun için bir ödeme yapmıyor,
     özellikle de siz.
    </para>
    <para>
     Kibar olun. Size nasıl davranılmasını istiyorsanız, diğerlerine de
     öyle davranın. Şayet insanların size karşı nazik olmadığını
     düşünüyorsanız bile, kibar olun, sinirlenmeyin ve insanları isimleri
     ile çağırmayın.  Bu sizin onların seviyesine inmenizdense, onların
     aptal görünmesini sağlayacaktır.
    </para>
    <para>
     Büyük bir alabalık gibi, gidip kimseye vurmayın. Bunun daha
     önceden bir veya iki kere yapıldığını ve komik bulunduğunu mu
     sanıyorsun?
    </para>
   </sect2>
   <sect2>
    <title>Bulunduğunuz kanalda kullanılan dilde ve düzgün yazın.</title>
    <para>
     Pek çok #Linux kanalı İngilizce'dir. Onlarla İngilizce konuşun.
     Büyük IRC ağlarının pek çoğu diğer dillerde de kanallar açar.
     Örneğin; Fransızca kanalının adı #Linuzfr, İspanyolca'sının adı
     #linuxes veya #linuxlatino olabilir.  Şayet size uygun bir kanal
     bulamazsanız, ana #linux kanalında İngilizce olarak bunu sorun,
     büyük ihtimalle yardım bulabilirsiniz.<footnote>
     <para>
      Ç.N.: Tabii Türkçe konuşulan IRC sunucuları da var. Genellikle
      belli başlı ISS'lerin IRC sunucularında bir #linux kanalı mutlaka
      vardır. Herhangi birine girip diğer sunucuların adreslerini de
      edinebilirsiniz.
     </para></footnote>
    </para>
    <para>
     "1337 Hhghgdka456745 kjfksj +%%&amp;57677" şekline ileti yazmayın. Diğer
     insanlar yapsa bile. Bu aptal görünür ve sizin de bir aptal gibi
     görünmenize sebep olur.  En iyisi, sadece salak gibi görünmektir,
     daha da kötüsü kıçınıza tekmeyi yiyebilirsiniz.
    </para>
   </sect2>
   <sect2>
    <title>Port taraması</title>
    <para>
     Asla herhangi bir kişiden port taraması yapmasını veya sizi
     hacklemesini istemeyin. Bu çok ayıptır.  Bağlantı yaptığınız IP'nin
     sizin olduğunun bilinmesine veya olduğunu söylediğiniz kişi olup
     olmadığınızın tespit edilmesine imkan yoktur. İnsanları, böyle bir
     isteğe hayır deme zahmetine sokmayın.
    </para>
    <para>
     İstemiş olsalar bile, hiç kimsenin portlarını taramayın. Kim
     olduklarını veya kullandıkları IP'nin kendilerine ait olup
     olmadığını bilmenize imkan yoktur.  Bazı yargılamalarda port
     taraması suç olarak kabul edilir ve pek çok ISS'nin
     anlaşmalarına aykırıdır.  Pek çok kişi TCP bağlantılarının
     kayıtlarını tutar ve port taramasından geçirildiklerini
     anlayabilir.  Ve pek çok kişi sizi ISS'ye şikayet edecektir.
     Kim olduğunuzu bulmak çok kolay bir iştir.
    </para>
   </sect2>
   <sect2>
    <title>Kanalda kalın</title>
    <para>
     Sizden istenmedikçe kimseye /msg göndermeyin. Bu kanalın
     yararlılığını azaltmakta ve bazıları ise sadece, bunu tercih
     etmemektedir.
    </para>
   </sect2>
   <sect2>
    <title>Konu içinde kalın</title>
    <para>
     Konuda kalın.  Bu kanal bir Linux kanalıdır.  "İbo geçen hafta
     kimi dövdü" kanalı değildir.  Başkalarının konu dışına çıkmış
     olması, sizin de çıkabileceğiniz anlamına gelmez. Onlar büyük
     ihtimal ile kanalın düzenli takipçileridir ve onlara farklı
     kurallar uygulanmaktadır.
    </para>
   </sect2>
   <sect2>
    <title>CTCP'ler</title>
    <para>
     Kanalı CTCP kalabalığı, sürümleri veya buna benzer bir şeyle
     doldurmak istiyorsan tekrar düşün.  Çok çabuk atılmana sebep
     olabilir.
    </para>
   </sect2>
   <sect2>
    <title>Hacking, Cracking, Phreaking, Warezing</title>
    <para>
     Selamsız bir şekilde dışarı atılmak istemiyorsanız, istismar
     edici davranışlar hakkında soru sormayın.
    </para>
    <para>
     Bir #Linux kanalında iken her hangi bir
     hacker/cracker/phreaker/warezer kanallarında bulunmayın.
     Bazı sebeplerden dolayı, #Linux kanallarındaki görevliler,
     başkalarının yazılımlarını çalmayı veya donanımlarına zarar vermeyi
     düşünen insanlardan nefret eder;<footnote><para>Ç.N.:
     bu nefret kelimesi bence çok hafif kalmış ama yine de özgün
     metne uymak gerekiyor.</para></footnote> nedenini hayal
     edebilir misiniz?
    </para>
   </sect2>
   <sect2>
    <title>Toparlayalım</title>
    <para>
     Çok fazla YAPMA ve az sayıda YAP için özür dilerim. YAPlar,
     posta listeleri ve haber grupları bölümünde çokça kullanıldı.
    </para>
    <para>
     Muhtemelen yapabileceğiniz en iyi şey; bir #Linux kanalına girmek
     ve doğru tonlamayı bulmak için hiçbir şey söylemeden bir yarım
     saat beklemek olacaktır.
    </para>
   </sect2>
   <sect2>
    <title>Daha fazla okunacak kaynak</title>
    <para>
     IRC #Linux kanallarından nasıl daha fazla yararlanılacağına dair
     mükemmel FAQ'lar vardır.  Pek çok #Linux kanalı bir FAQ veya
     kurallar sayfasına sahiptir.  Bunu nasıl bulacağınız genellikle
     kanal konusu içinde açıklanır veya /topic komutunu kullanabilirsiniz.
     Şayet kurallar var ise bunları okuduğunuzdan emin olun.
     <link xl:href="https://www.irchelp.org/faq/faq1irc.html"/> adresinde
     bulabileceğiniz  "Undernet IRC FAQ" belgesini tavsiye ederim.
    </para>
   </sect2>
  </sect1>
 </chapter>
 <appendix xml:id="sag_glossary">
  <title>Terim Dağarcığı</title>
  <para>
   Burada Linux ve sistem yönetimi ile ilgili  bazı terimlerin kısa
   tanımları bulunmaktadır. Terimlerin İngilizce karşılıkları yanlarında
   ayraç içinde verilmiştir.
  </para>
  <variablelist>
   <varlistentry>
    <term><anchor xml:id="sag_glossary-booting"/>açılış [ İng.: booting ]</term>
    <listitem>
     <para>
      Bilgisayarın enerji düğmesine basılması ile işletim sisteminin komut
      kabul edebilir bir duruma gelmesi için geçen süre içinde olan her şeye
      <glossterm>açılış</glossterm> denir.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><anchor xml:id="sag_glossary-post"/>açılışta kendi kendini sınama [ İng.: Power on self test (POST) ]</term>
    <listitem>
     <para>
      Bilgisayara enerji verildiği zaman yapılan bir dizi teşhis amaçlı
      sınamalardır. Bu sınama genellikle; belleğin denetlenmesini, donanım
      yapılandırılmasının en son kayıtlı şekilde olup olmadığını, BIOS’a
      kayıtlı herhangi çalışır bir USB disk sürücü veya sabit disk sürücünün
      denetlenmesi şeklindedir.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><anchor xml:id="sag_glossary-nfs"/>ağ dosya sistemi [ İng.: Network File System (NFS) ]</term>
    <listitem>
     <para>
      Sun Microsystems firması tarafından geliştirilmiş ve RFC 1094 olarak
      tanımlanmış; bir bilgisayarın ağ üzerinden sanki kendi yerel diskine
      ulaşırmış gibi erişim yapmasını sağlayan protokoldür.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><anchor xml:id="sag_glossary-mbr"/>ana önyükleme kaydı  [ İng.: Master Boot Record (MBR) ]</term>
    <listitem>
     <para>
      Bir disk yüzeyindeki ilk mantıksal sektördür. Bilgisayarın açılabilmesi
      için BIOS buradaki küçük bir yazılımı kullanır.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><anchor xml:id="sag_glossary-daemon"/>artalan süreci [ İng.: daemon ]</term>
    <listitem>
     <para>
      Genellikle farkedilemeyen ve arka planda gizlenen, kendilerini
      tetiklemek için bir şeylerin olmasını bekleyen süreçlerdir.
      Örneğin; <command>sendmail</command> birisi eposta gönderince
      uyanır, <command>update</command> her 30 saniyede bir
      tampon belleğin içeriğini diske yazmak üzere uyanır.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><anchor xml:id="sag_glossary-formatting"/>biçemleme [ İng.: formatting ]</term>
    <listitem>
     <para>
      Basitçe; <glossterm>biçemleme</glossterm> bir disk yüzeyinin izler,
      sektörler ve silindirlere ayrılması ve düzenlenmesi işlemidir. Bazen,
      yanlış bir biçimde, bir dosya sisteminin disk yüzeyine yazılması
      olarak da kullanılır (MS Windows/MS DOS çevrelerinde) Dosya
      sisteminin disk üzerinde yazılması işlemine <glossterm>dosya
      sisteminin oluşturulması</glossterm> denir.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><anchor xml:id="sag_glossary-badblock"/>bozuk blok [ İng.: bad block ]</term>
    <listitem>
     <para>
      Güvenilir bir şekilde bilgi depolayamayan sektörler. Genellikle bir
      disk üzerindeki manyetik özelliklerini kaybetmiş bir sektör grubudur.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><anchor xml:id="sag_glossary-badsector"/>bozuk sektör [ İng.: bad sector ]</term>
    <listitem>
     <para>
      Güvenilir bir şekilde bilgi depolayamayan bir sektör. Genellikle bir
      disk üzerindeki manyetik özelliklerini kaybetmiş bir sektördür.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><anchor xml:id="sag_glossary-cmosram"/>CMOS RAM</term>
    <listitem>
     <para>
      CMOS (<command>C</command>omplenmentary <command>M</command>etal
      <command>O</command>xide <command>S</command>emiconductor)
      "Eşlenik Metal Oksit Yarıiletken" in kısaltmasıdır.  Karışık bir
      teknolojidir ama basitçe; elektrik akımı olmadığı durumlarda
      durumlarını değiştirmeyen transistör çiftleridir denebilir. Böylece
      bu yarıiletken, enerjisiz durumda iken bilgi saklayabilen bir durağan
      (statik) RAM olarak kullanılabilir.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><anchor xml:id="sag_glossary-runlevel"/>çalışma seviyesi [ İng.: run level ]</term>
    <listitem>
     <para>
      Linux genellikle 7 tanesi tanımlanmış olan 10 adet (0-9) çalışma
      seviyesine sahiptir.  Her bir çalışma seviyesi değişik hizmetler
      ve sisteme verilmiş değişik yapılandırmalar ile başlayabilir.
      Çalışma seviyesi 0 "sistemin durdurulması", çalışma seviyesi 1
      "tek kullanıcılı kip", çalışma seviyesi 6 "sistemin yeniden
      başlatılması” olarak tanımlanmıştır. Teorik olarak geri kalan
      seviyeler sistem yöneticisi tarafından tanımlanabilir. Bununla
      birlikte pek çok dağıtım bunların bazılarını öntanımlı olarak
      bulundurur. Örneğin; çalışma seviyesi 2 "çok kullanıcılı konsol"
      ve çalışma seviyesi 5 "çok kullanıcılı X Pencere Sistemi"
      olarak tanımlamış olabilir. Bunlar dağıtımdan dağıtıma göre
      farklılıklar gösterebilir, bu nedenle kendi sisteminizi incelemeniz
      gerekir.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><anchor xml:id="sag_glossary-kernel"/>çekirdek [ İng.: kernel ]</term>
    <listitem>
     <para>
      Kaynakların paylaşımı ve donanımlar arası etkileşimi sağlayan işletim
      sistemi parçasıdır. Ayrıca <link linkend="sag_glossary-sysprg">sistem
      yazılımları</link>na bakınız.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><anchor xml:id="sag_glossary-partition"/>disk bölümü [ İng.: partition ]</term>
    <listitem>
     <para>
      Diskin ayrılmış bölümlerinden her biri. Her bölüm normalde kendi dosya
      sistemine sahiptir. Unix, bölümlerin sanki bağımsız fiziksel
      aygıtlarmış gibi davranmalarına izin verir.
      </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><anchor xml:id="sag_glossary-diskcontroller"/>disk denetleyici [ İng.: Disk Controller ]</term>
    <listitem>
     <para>
      İşletim sistemindeki disk erişimi hakkındaki bilgileri fiziksel
      diskin anlayabileceği şekle çeviren bir donanım devresidir.
      Bu soyutlanmış bir tabaka sağlayarak, işletim sisteminin değişik
      türdeki diskler ile nasıl iletişim sağlaması gerektiğini bilmesi
      zorunluluğunu ortadan kaldırır, sadece <glossterm>disk
      denetleyici</glossterm> türlerinin sayısının bilinmesini zorunlu
      kılar. Çok bilinen <glossterm>disk denetleyici</glossterm>ler SATA
      ve SCSI'dir.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><anchor xml:id="sag_glossary-inode"/>dosya düğümü [ İng.: inode ]</term>
    <listitem>
     <para>
      Bir Unix dosya sisteminde, dosyalar hakkında bilgi saklayan
      veriyapısıdır. Her bir dosya için bir
      <glossterm>dosya düğümü</glossterm> vardır ve  her bir dosyanın
      bulunduğu yer ile sistemdeki <glossterm>dosya düğümü</glossterm>
      numarası benzersizdir. Her <glossterm>dosya düğümü</glossterm> şu
      bilgileri içerir: <glossterm>dosya düğümü</glossterm>nün bulunduğu
      aygıt; kilitleme bilgileri; dosyanın türü, kipi ve boyu; dosyaya
      bulunan bağların sayısı; sahibinin kullanıcı ve grup kimlikleri; son
      erişim ve düzenleme tarihleri <glossterm>dosya düğümü</glossterm>nün
      kendisinin en son düzenlediği tarih ve dosyanın disk üzerindeki blok
      adresi. Bir Unix dizini dosyaların isimleri ile dosya düğümleri
      arasındaki ilişkiyi sağlar. Şayet <command>ls</command> komutunu
      <option>–i</option> seçeneğiyle beraber kullanırsanız bir dosyanın
      <glossterm>dosya düğümü</glossterm> numarasını bulabilirsiniz.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><anchor xml:id="sag_glossary-ds"/>dosya sistemi [ İng.: filesystem ]</term>
    <listitem>
     <para>
      İki ayrı amaç ve anlam için kullanılan bir terimdir. Bir sürücü
      üzerindeki hiyerarşik dosya veya dizin topluluğudur (örneğin;
      CD-ROM, sabit disk üzerindeki dosya sistemleri.) veya
      işletim sisteminin dosyaları yazacağı yere karar
      vermesini sağlayan dosya düğümleri, bloklar ve süper bloklar gibi
      disk ortamı üzerindeki özel kayıtların oluşturduğu bütündür.
      Terimin anlamını cümle içindeki kullanımına göre değerlendirin.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><anchor xml:id="sag_glossary-llf"/>düşük seviyeli biçemleme [ İng.: low level formatting ]</term>
    <listitem>
     <para>
      <link linkend="sag_glossary-formatting">Biçemleme</link> ile
      eşanlamlıdır,  bazan yanlış olarak biçemlemek olarak da bilinen dosya
      sistemi oluşturmaktan farklılığı belirlemek için MS-DOS ve Windows
      ortamlarında kullanılır.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><anchor xml:id="sag_glossary-incrbackup"/>fark yedekleme [ İng.: incremental backup ]</term>
    <listitem>
     <para>
      Son <link linkend="sag_glossary-fullbackup">tam yedekleme</link>den
      beri dosya sistemi üzerinde değişen şeylerin yedeklenmesi.  Bir
      yedekleme sisteminde düzenli bir şekilde kullanılırsa, bilgileri
      depolama zamanından ve çabasından önemli ölçüde tasarruf sağlar.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><anchor xml:id="sag_glossary-geometry"/>geometri [ İng.: geometry ]</term>
    <listitem>
     <para>
      Bir diskin kaç silindire, kaç kafaya ve her silindirde kaç sektöre
      sahip olduğu belirtmekte kullanılır. Disk geometrileri genellikle
      <literal>silindir * kafa * sektör</literal> sayıları olarak verilir ve
      bu çarpıma bazan kısaca CHS (Cylinders * Heads * Sectors) denir.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><anchor xml:id="sag_glossary-shadow-password"/>gölge parolalar [ İng.: shadow passwords ]</term>
    <listitem>
     <para>
      Unix sistemlerindeki <glossterm>parola dosyaları</glossterm> çok geniş
      bir kesim tarafından okunabildiği için, kullanıcı hesaplarının
      şifrelenmiş parolalarını bulundurmaz. Bir <filename>shadow</filename>
      dosyası herkes tarafından okunamadığı için kullanıcı hesaplarının
      şifrelenmiş parolaları bu dosyada bulundurulur.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><anchor xml:id="sag_glossary-account"/>hesap [ İng.: account ]</term>
    <listitem>
     <para>
       Bir Unix işletim sistemi her bir kullanıcıya bir
       <glossterm>hesap</glossterm> açar. Bu hesaba girebilmek için bir
       kullanıcı adı ve parola verir. Dosyaların depolanabilmesi için
       genellikle bir ev dizini tahsis edilir, donanım  ve yazılımlara
       ulaşabilmek için gerekli izinler verilir.
       Bütün bunların toplamına <glossterm>hesap</glossterm> denir.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><anchor xml:id="sag_glossary-is"/>işletim sistemi [ İng.: operating system ]</term>
    <listitem>
     <para>
       Bilgisayar yazılımlarının yürütülmesini sağlayan ve hata ayıklama,
       giriş-çıkış denetimi, sıralama, sayışım, derleme, bellek atama,
       veri düzenleme ve benzer hizmetlerle sistem kaynaklarını (işlemci,
       bellek, disk alanı, vb.) kullanıcı ve uygulama yazılımları arasında
       paylaştıran yazılımların oluşturduğu bütündür. Güvenliği sağlamak
       için sistem erişimini de denetler. Ayrıca <link linkend="sag_glossary-kernel">çekirdek</link> ve
       <link linkend="sag_glossary-sysprg">sistem yazılımı</link>na bakınız.
      </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><anchor xml:id="sag_glossary-track"/>iz [ İng.: track ]</term>
    <listitem>
     <para>
      Disk dönerken ama kafa sabitken kafanın altından geçen yüzey parçasıdır.
      Her <glossterm>iz</glossterm> <link linkend="sag_glossary-sector">sektör</link>lere ayrılır ve her izin “dikey” toplamı bir <link linkend="sag_glossary-cylinder">silindir</link>i
      oluşturur.
      </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><anchor xml:id="sag_glossary-rootfs"/>kök dosya sistemi [ İng.: root filesystem ]</term>
    <listitem>
     <para>
      Bir Unix dosya sistemindeki bütün dosya sistemlerinin bağlı olduğu
      en tepedeki dosya sistemidir. "/" ismiyle bağlanır ve diğer sistemler
      onun üzerine "/usr" şeklinde bağlanır. Şayet kök dosyasistemi
      bağlanamazsa çekirdek panikler ve
      <link linkend="sag_glossary-booting">açılış</link> işlemi devam edemez.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><anchor xml:id="sag_glossary-shadow-spool"/>kuyruklama, havuzlama [ İng.: spool ]</term>
    <listitem>
     <para>
      Bir dosyanın bir kuyruğa gönderilmesi. Bu terim IBM tarafından
      ilk zamanlarda ``Simultaneous Peripheral Operation On-Line''
      sözcüklerinden türetilmiş bir kısaltma olarak sadece paralel porta
      yönlendirilen dosyaları sıraya sokmak anlamında kullanılmış olmakla
      beraber, günümüzde bu terim epostaların kuyruklanması (sözcüğün sözlük
      anlamındaki gibi epostaların gönderilinceye kadar havuzlanması),
      çiziciler ve diğer çizim aygıtları için işlerin sıraya sokulması gibi
      farklı işlemler için de kullanılmaktadır. Bu işlemi yapan yazılımlara
      da kuyruklayıcı (spooler) denmekte ve genellikle bir artalan süreci
      olarak çalıştırılmaktadır.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><anchor xml:id="sag_glossary-logical-partition"/>mantıksal bölüm [ İng.: logical partition ]</term>
    <listitem>
     <para>
      <glossterm>Ek bölüm</glossterm> içerisindeki bölüm. Gerçekte
      <glossterm>mantıksal bölüm</glossterm> yoktur sadece yazılımın
      mantıksal  yapısı içerisine bulunur.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><anchor xml:id="sag_glossary-rw-head"/>oku/yaz kafası [ İng.: Read-write head ]</term>
    <listitem>
     <para>
      Bir diskin manyetik yüzeyine yazmak ve okumak için kullanılan ince
      bir elektromanyetik bobin ve metal nüvedir.  Bu alet, plakaların dönme
      yönüne dik olarak hareket eder.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><anchor xml:id="sag_glossary-bootsector"/>önyükleme sektörü [ İng.: boot sector ]</term>
    <listitem>
     <para>
      Genellikle herhangi bir atanmış disk bölümünün (diskin değil) ilk
      sektörüdür. İşletim sisteminin düzgün bir şekilde yüklenmesi ve
      çalışmasını sağlayacak çok kısa (birkaç yüz bytelık) bir yazılım
      (<link linkend="sag_glossary-bootloader">önyükleyici</link>)
      içermek üzere ayrılmış özel bir sektördür.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><anchor xml:id="sag_glossary-bootloader"/>önyükleyici [ İng.: Bootstrap loader ]</term>
    <listitem>
     <para>
      İlk bilgisayarlarda genellikle ROM içerisinde bulunan çok küçük bir
      yazılımdı. Şimdilerde bir disk üzerindeki sabit/belirli bir bölgenin
      okunup, oradaki yazılımın denetimi almasına izin verilir. Bu bölge
      genellikle MBR olur. Bu bölgedeki yazılım genellikle karışık ve büyük
      hacimlidir ve daha sonra işletim sisteminin seçimi, yüklenmesi ve
      denetimi ele alması için gerekli işlemlerin sorumluluğunu alır.
      Bu yazılıma genel olarak <glossterm>önyükleyici</glossterm> denir.
      (LILO, GRUB ve benzerleri birer önyükleyicidir.)
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><anchor xml:id="sag_glossary-fragmented"/>parçalanma [ İng.: fragmentation ]</term>
    <listitem>
     <para>
      Bir dosyanın bir disk üzerine ardışık bloklar halinde yazılamaması
      durumudur.  Şayet bir dosyanın tamamını ardışık bloklar halinde yazmak
      için gerekli boş disk yüzeyi olmaz ise, dosya disk yüzeyinde iki veya
      üç parçaya ayrılır.  Buna <glossterm>parçalanma</glossterm>
      denir ve bu olay; dosyanın parçalarını aramasını gerektirdiği için,
      dosyanın yüklenme süresi uzar.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><anchor xml:id="sag_glossary-password-file"/>parola dosyası [ İng.: password file ]</term>
    <listitem>
     <para>
      Kullanıcı adlarını ve bu hesap hakkındaki bilgileri tutan dosyadır.
      Bir Unix işletim sisteminde bu dosya genellikle
      <filename>/etc/passwd</filename>'dir.  Pek çok modern
      Linux sisteminde bu dosya parolaları ihtiva etmez.
      Güvenlik nedeniyle başka bir dosyaya (<filename>/etc/shadow</filename>)
      yönlendirilmiştir. Ayrıntılı bilgi için <command>passwd</command>(5) ve
      <command>shadow</command>(5) kılavuz sayfalarına bakınız.
      </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><anchor xml:id="sag_glossary-platters"/>plakalar [ İng.: Platters ]</term>
    <listitem>
     <para>
      Bir sabit disk içindeki fiziksel disklerdir.  Genellikle bir sabit
      disk birbiri üzerine istiflenmiş pek çok fiziksel
      <glossterm>plaka</glossterm>dan oluşur. Her bir bağımsız diske
      <glossterm>plaka</glossterm> denir.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><anchor xml:id="sag_glossary-mta"/>posta aktarım aracısı [ İng.: Mail Transfer Agent (MTA) ]</term>
    <listitem>
     <para>
      Epostaları dağıtmakla görevli uygulamadır.  Başka bir MTA’dan ileti
      alır veya onu geçici bir yerel bölgeye depolar, kime ait olduğunu
      analiz eder ve başka bir MTA’ya gönderir. Her durumda bir ileti
      başlığı ekleyebilir veya düzenleyebilir. Unix’te genellikle, MTA
      olarak, <command>sendmail</command> kullanılır.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><anchor xml:id="sag_glossary-mua"/>posta istemcisi [ İng.: Mail User Agent (MUA) ]</term>
    <listitem>
     <para>
      Kullanıcıların elektronik posta oluşturmalarını ve okumalarını
      sağlayan uygulama.  Kullanıcı ve MTA arasında arayüzdür. Dışarıya
      gönderilen iletiler dağıtılmak için bir MTA’da tutulurken,
      gelen iletiler MTA her nereye koydu ise oradan toplanır.
      MUA için örnek uygulamalara olarak pine, elm, mutt sayılabilir.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><anchor xml:id="sag_glossary-sector"/>sektör [ İng.: sector ]</term>
    <listitem>
     <para>
      Bilgi depolanabilecek en küçük boydaki <glossterm>iz</glossterm>e
      verilen addır. Genellikle 512 bayttır.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><anchor xml:id="sag_glossary-cylinder"/>silindir [ İng.: cylinder ]</term>
    <listitem>
     <para>
      Çok kafalı bir sabit disk üzerinde, okuyucu kafaların bir anda
      üzerinde bulundukları izlerden oluşan göreli bölüm.  Diğer bir
      deyişle plaka milinden eşit uzaklıktaki izler topluluğudur ve bu
      izler alt alta geldiğinde göreli bir <glossterm>silindir</glossterm>
      oluşur. Aynı <glossterm>silindir</glossterm> üzerine aynı anda
      ulaşılabilecek şekilde yerleştirilmiş bilgiler, oku/yaz kafasının
      disk dönüş hızından daha yavaş olmasından kaynaklanan erişim süresi
      uzunluğunu önemli bir miktarda kısaltır.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><anchor xml:id="sag_glossary-syscall"/>sistem çağrısı [ İng.: system call ]</term>
    <listitem>
     <para>
      Uygulama yazılımları için çekirdek tarafından sağlanan işlevlerdir.
      Kılavuz sayfalarının 2. bölümü sistem çağrılarını içerir.
      </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><anchor xml:id="sag_glossary-sysprg"/>sistem yazılımı [ İng.: system program ]</term>
    <listitem>
     <para>
      Bir işletim sisteminde yüksek seviyeli görevleri yerine getiren
      yazılımlardır. Örneğin donanıma dayanmayan işleri yapar. Bazı
      zamanlar çalışmak için özel durumlara  ihtiyaç duyar; örneğin
      elektronik posta dağıtımı gibi. Ama genellikle sistemin bir parçası
      olarak düşünülebilir (örneğin: derleyici). Ayrıca
      <link linkend="sag_glossary-apprg">uygulama yazılımı</link>,
      <link linkend="sag_glossary-kernel">çekirdek</link> ve
      <link linkend="sag_glossary-is">işletim sistemi</link>ne bakınız.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><anchor xml:id="sag_glossary-swap"/>takas alanı [ İng.: swap space ]</term>
    <listitem>
     <para>
      Sistemin bellek yerine kullanabildiği disk yüzeyidir.  Bu genellikle
      ayrılmış bir bölümdür ama bir dosya da olabilir.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><anchor xml:id="sag_glossary-fullbackup"/>tam yedekleme [ İng.: full backup ]</term>
    <listitem>
     <para>
      Bütün bir dosya sisteminin bir yedekleme aygıtına (teyp, CD gibi)
      kopyalanması.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><anchor xml:id="sag_glossary-runlevel1"/>tek kullanıcılı kip [ İng.: single user mode ]</term>
    <listitem>
     <para>
      Genellikle 1. çalışma seviyesini tanımlar. Sadece root kullanıcı
      bağlanabilir. Sistem onarımı (dosya sisteminin zarar gördüğü ama
      hala açılabildiği durumlarda) veya dosya sistemlerinin bölümler
      arası taşınmaları için kullanılır. Bunlar sadece iki örnektir.
      Bir sistemde disk üzerine tek bir kişinin yazmasını gerektirecek
      her durumda <glossterm>tek kullanıcılı kip</glossterm> kullanılır.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><anchor xml:id="sag_glossary-apprg"/>uygulama yazılımı [ İng.: application programs ]</term>
    <listitem>
     <para>
      Yazılımlar faydalı işler yapar. Bir uygulama yazılımını kullanmanın
      sonuçları, bilgisayarın alınma sebepleri ile aynıdır. Ayrıca
      <link linkend="sag_glossary-sysprg">sistem yazılımı</link> ve
      <link linkend="sag_glossary-is">işletim sistemi</link>ne bakınız.
    </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><anchor xml:id="sag_glossary-dst"/>yaz saati uygulaması [ İng.: Daylight Saving Time ]</term>
    <listitem>
     <para>
      Enerji tasarrufu için yılın belirli bir döneminde saatlerin bir saat
      ileri alınmasıdır. Yazın güneş ışığından daha fazla faydalanmak için
      dünya çapında uygulanan bir yöntemdir.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><anchor xml:id="sag_glossary-pqueue"/>yazıcı kuyruğu, yazdırma kuyruğu [ İng.: print queue ]</term>
    <listitem>
     <para>
      Yazıcıyı kullanmak isteyen kullanıcıların, yazım işleminin bitmesini
      beklemeden kendi işlerine devam etmesini sağlayan bir yazıcı
      <link linkend="sag_glossary-daemon">artalan süreci</link> tarafından
      kullanılan bir dosya veya dosyalar topluluğu.
      Ayrıca bir yazıcının pek çok kişiye paylaştırılmasına izin verir.
      </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><anchor xml:id="sag_glossary-localtime"/>yerel zaman [ İng.: local time ]</term>
    <listitem>
     <para>
      Yerel bir bölge üzerinde yasalar, standartlar veya geleneklerle
      belirlenmiş resmî zaman.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><anchor xml:id="sag_glossary-hlf"/>yüksek seviyeli biçemleme [ İng.: high level formatting ]</term>
    <listitem>
     <para>
      Bir dosya sisteminin bir diske yazılmasını tanımlamak için kullanılan
      yanlış bir terimdir. Genellikle Windows ve MS-DOS ortamlarında kullanılır.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </appendix>
 <appendix xml:id="sag-copying">
  <title>GNU Özgür Belgeleme Lisansı</title>
  <para>
   GNU Özgür Belgeleme Lisansı ile lisanslanmış belgelerin bu lisansı içermesi
   gerektiğinden ve bu lisans kendisinin değiştirilmesine izin vermediğinden
   (buna tercüme de dahildir) lisans hiçbir değişiklik yapılmaksızın burada
   belgeye eklenmiştir.
  </para>
  <para>
   (Ç.N. - GNU Özgür Belgeleme Lisansı bu özelliği sebebiyle dili İngilizce olmayan belgelerde kullanmak için uygun değildir; Türkçe belgenize İngilizce bir metin eklemek istemezsiniz, herhalde. Daha özgür -kendinin belgeye eklenmesini zorunlu kılmayan- lisanslar da var. Örneğin "Creative Commons Share Alike" kendinin belgeye eklenmesini zorunlu kılmaması dışında GNU ÖBL'ye hemen hemen eşdeğerdir.)
  </para>
  <bridgehead xml:id="sag-gfdl" renderas="sect1">GNU Free Documentation License</bridgehead>
  <para>Version 1.2, November 2002</para>
<screen>
Copyright © 2000,2001,2002 Free Software Foundation, Inc.
59 Temple Place, Suite 330, Boston, MA  02111-1307, USA

Everyone is permitted to copy and distribute verbatim copies
of this license document, but changing it is not allowed.
</screen>
  <orderedlist numeration="arabic">
   <listitem>
    <para>PREAMBLE</para>
    <para>
     The purpose of this License is to make a manual, textbook, or other
     functional and useful document <firstterm>free</firstterm> in the sense of freedom: to
     assure everyone the effective freedom to copy and redistribute it,
     with or without modifying it, either commercially or noncommercially.
     Secondarily, this License preserves for the author and publisher a way
     to get credit for their work, while not being considered responsible
     for modifications made by others.
    </para>
    <para>
     This License is a kind of "copyleft", which means that derivative
     works of the document must themselves be free in the same sense.  It
     complements the GNU General Public License, which is a copyleft
     license designed for free software.
    </para>
    <para>
     We have designed this License in order to use it for manuals for free
     software, because free software needs free documentation: a free
     program should come with manuals providing the same freedoms that the
     software does.  But this License is not limited to software manuals;
     it can be used for any textual work, regardless of subject matter or
     whether it is published as a printed book.  We recommend this License
     principally for works whose purpose is instruction or reference.
    </para>
   </listitem>
   <listitem>
    <para>APPLICABILITY AND DEFINITIONS</para>
    <para>
     This License applies to any manual or other work, in any medium, that
     contains a notice placed by the copyright holder saying it can be
     distributed under the terms of this License.  Such a notice grants a
     world-wide, royalty-free license, unlimited in duration, to use that
     work under the conditions stated herein.  The "Document", below,
     refers to any such manual or work.  Any member of the public is a
     licensee, and is addressed as "you".  You accept the license if you
     copy, modify or distribute the work in a way requiring permission
     under copyright law.
    </para>
    <para>
     A "Modified Version" of the Document means any work containing the
     Document or a portion of it, either copied verbatim, or with
     modifications and/or translated into another language.
    </para>
    <para>
     A "Secondary Section" is a named appendix or a front-matter section
     of the Document that deals exclusively with the relationship of the
     publishers or authors of the Document to the Document's overall
     subject (or to related matters) and contains nothing that could fall
     directly within that overall subject.  (Thus, if the Document is in
     part a textbook of mathematics, a Secondary Section may not explain
     any mathematics.)  The relationship could be a matter of historical
     connection with the subject or with related matters, or of legal,
     commercial, philosophical, ethical or political position regarding
     them.
    </para>
    <para>
     The "Invariant Sections" are certain Secondary Sections whose titles
     are designated, as being those of Invariant Sections, in the notice
     that says that the Document is released under this License.  If a
     section does not fit the above definition of Secondary then it is not
     allowed to be designated as Invariant.  The Document may contain zero
     Invariant Sections.  If the Document does not identify any Invariant
     Sections then there are none.
    </para>
    <para>
     The "Cover Texts" are certain short passages of text that are listed,
     as Front-Cover Texts or Back-Cover Texts, in the notice that says that
     the Document is released under this License.  A Front-Cover Text may
     be at most 5 words, and a Back-Cover Text may be at most 25 words.
    </para>
    <para>
     A "Transparent" copy of the Document means a machine-readable copy,
     represented in a format whose specification is available to the
     general public, that is suitable for revising the document
     straightforwardly with generic text editors or (for images composed of
     pixels) generic paint programs or (for drawings) some widely available
     drawing editor, and that is suitable for input to text formatters or
     for automatic translation to a variety of formats suitable for input
     to text formatters.  A copy made in an otherwise Transparent file
     format whose markup, or absence of markup, has been arranged to thwart
     or discourage subsequent modification by readers is not Transparent.
     An image format is not Transparent if used for any substantial amount
     of text.  A copy that is not "Transparent" is called "Opaque".
    </para>
    <para>
     Examples of suitable formats for Transparent copies include plain
     ascii without markup, Texinfo input format, LaTeX input
     format, <acronym>SGML</acronym> or <acronym>XML</acronym> using a
     publicly available <acronym>DTD</acronym>, and standard-conforming
     simple <acronym>HTML</acronym>, PostScript or <acronym>PDF</acronym>
     designed for human modification.  Examples of transparent image formats
     include <acronym>PNG</acronym>, <acronym>XCF</acronym> and
     <acronym>JPG</acronym>.  Opaque formats include proprietary formats
     that can be read and edited only by proprietary word processors,
     <acronym>SGML</acronym> or <acronym>XML</acronym> for which the
     <acronym>DTD</acronym> and/or processing tools are not generally
     available, and the machine-generated <acronym>HTML</acronym>,
     PostScript or <acronym>PDF</acronym> produced by some word processors
     for output purposes only.
    </para>
    <para>
     The "Title Page" means, for a printed book, the title page itself,
     plus such following pages as are needed to hold, legibly, the material
     this License requires to appear in the title page.  For works in
     formats which do not have any title page as such, "Title Page" means
     the text near the most prominent appearance of the work's title,
     preceding the beginning of the body of the text.
    </para>
    <para>
     A section "Entitled XYZ" means a named subunit of the Document whose
     title either is precisely XYZ or contains XYZ in parentheses following
     text that translates XYZ in another language.  (Here XYZ stands for a
     specific section name mentioned below, such as "Acknowledgements",
     "Dedications", "Endorsements", or "History".)  To "Preserve the Title"
     of such a section when you modify the Document means that it remains a
     section "Entitled XYZ" according to this definition.
    </para>
    <para>
     The Document may include Warranty Disclaimers next to the notice which
     states that this License applies to the Document.  These Warranty
     Disclaimers are considered to be included by reference in this
     License, but only as regards disclaiming warranties: any other
     implication that these Warranty Disclaimers may have is void and has
     no effect on the meaning of this License.
    </para>
   </listitem>
   <listitem>
    <para>VERBATIM COPYING</para>
    <para>
     You may copy and distribute the Document in any medium, either
     commercially or noncommercially, provided that this License, the
     copyright notices, and the license notice saying this License applies
     to the Document are reproduced in all copies, and that you add no other
     conditions whatsoever to those of this License.  You may not use
     technical measures to obstruct or control the reading or further
     copying of the copies you make or distribute.  However, you may accept
     compensation in exchange for copies.  If you distribute a large enough
     number of copies you must also follow the conditions in section 3.
    </para>
    <para>
     You may also lend copies, under the same conditions stated above, and
     you may publicly display copies.
    </para>
   </listitem>
   <listitem>
    <para>COPYING IN QUANTITY</para>
    <para>
     If you publish printed copies (or copies in media that commonly have
     printed covers) of the Document, numbering more than 100, and the
     Document's license notice requires Cover Texts, you must enclose the
     copies in covers that carry, clearly and legibly, all these Cover
     Texts: Front-Cover Texts on the front cover, and Back-Cover Texts on
     the back cover.  Both covers must also clearly and legibly identify
     you as the publisher of these copies.  The front cover must present
     the full title with all words of the title equally prominent and
     visible.  You may add other material on the covers in addition.
     Copying with changes limited to the covers, as long as they preserve
     the title of the Document and satisfy these conditions, can be treated
     as verbatim copying in other respects.
    </para>
    <para>
     If the required texts for either cover are too voluminous to fit
     legibly, you should put the first ones listed (as many as fit
     reasonably) on the actual cover, and continue the rest onto adjacent
     pages.
    </para>
    <para>
     If you publish or distribute Opaque copies of the Document numbering
     more than 100, you must either include a machine-readable Transparent
     copy along with each Opaque copy, or state in or with each Opaque copy
     a computer-network location from which the general network-using
     public has access to download using public-standard network protocols
     a complete Transparent copy of the Document, free of added material.
     If you use the latter option, you must take reasonably prudent steps,
     when you begin distribution of Opaque copies in quantity, to ensure
     that this Transparent copy will remain thus accessible at the stated
     location until at least one year after the last time you distribute an
     Opaque copy (directly or through your agents or retailers) of that
     edition to the public.
    </para>
    <para>
     It is requested, but not required, that you contact the authors of the
     Document well before redistributing any large number of copies, to give
     them a chance to provide you with an updated version of the Document.
    </para>
   </listitem>
   <listitem>
    <para>MODIFICATIONS</para>
    <para>
     You may copy and distribute a Modified Version of the Document under
     the conditions of sections 2 and 3 above, provided that you release
     the Modified Version under precisely this License, with the Modified
     Version filling the role of the Document, thus licensing distribution
     and modification of the Modified Version to whoever possesses a copy
     of it.  In addition, you must do these things in the Modified Version:
    </para>
    <orderedlist numeration="upperalpha">
     <listitem>
      <para>
       Use in the Title Page (and on the covers, if any) a title distinct
       from that of the Document, and from those of previous versions
       (which should, if there were any, be listed in the History section
       of the Document).  You may use the same title as a previous version
       if the original publisher of that version gives permission.
      </para>
     </listitem>
     <listitem>
      <para>
       List on the Title Page, as authors, one or more persons or entities
       responsible for authorship of the modifications in the Modified
       Version, together with at least five of the principal authors of the
       Document (all of its principal authors, if it has fewer than five),
       unless they release you from this requirement.
      </para>
     </listitem>
     <listitem>
      <para>
       State on the Title page the name of the publisher of the
       Modified Version, as the publisher.
      </para>
     </listitem>
     <listitem>
      <para>
       Preserve all the copyright notices of the Document.
      </para>
     </listitem>
     <listitem>
      <para>
       Add an appropriate copyright notice for your modifications
       adjacent to the other copyright notices.
      </para>
     </listitem>
     <listitem>
      <para>
Include, immediately after the copyright notices, a license notice
giving the public permission to use the Modified Version under the
terms of this License, in the form shown in the Addendum below.
       </para>
     </listitem>
     <listitem>
      <para>
Preserve in that license notice the full lists of Invariant Sections
and required Cover Texts given in the Document's license notice.
       </para>
     </listitem>
     <listitem>
      <para>
Include an unaltered copy of this License.
       </para>
     </listitem>
     <listitem>
      <para>
Preserve the section Entitled "History", Preserve its Title, and add
to it an item stating at least the title, year, new authors, and
publisher of the Modified Version as given on the Title Page.  If
there is no section Entitled "History" in the Document, create one
stating the title, year, authors, and publisher of the Document as
given on its Title Page, then add an item describing the Modified
Version as stated in the previous sentence.
       </para>
     </listitem>
     <listitem>
      <para>
Preserve the network location, if any, given in the Document for
public access to a Transparent copy of the Document, and likewise
the network locations given in the Document for previous versions
it was based on.  These may be placed in the "History" section.
You may omit a network location for a work that was published at
least four years before the Document itself, or if the original
publisher of the version it refers to gives permission.
       </para>
     </listitem>
     <listitem>
      <para>
For any section Entitled "Acknowledgements" or "Dedications", Preserve
the Title of the section, and preserve in the section all the
substance and tone of each of the contributor acknowledgements and/or
dedications given therein.
       </para>
     </listitem>
     <listitem>
      <para>
Preserve all the Invariant Sections of the Document,
unaltered in their text and in their titles.  Section numbers
or the equivalent are not considered part of the section titles.
       </para>
     </listitem>
     <listitem>
      <para>
Delete any section Entitled "Endorsements".  Such a section
may not be included in the Modified Version.
       </para>
     </listitem>
     <listitem>
      <para>
Do not retitle any existing section to be Entitled "Endorsements" or
to conflict in title with any Invariant Section.
       </para>
     </listitem>
     <listitem>
      <para>
Preserve any Warranty Disclaimers.
       </para>
     </listitem>
    </orderedlist>
    <para>
If the Modified Version includes new front-matter sections or
appendices that qualify as Secondary Sections and contain no material
copied from the Document, you may at your option designate some or all
of these sections as invariant.  To do this, add their titles to the
list of Invariant Sections in the Modified Version's license notice.
These titles must be distinct from any other section titles.
     </para>
    <para>
You may add a section Entitled "Endorsements", provided it contains
nothing but endorsements of your Modified Version by various
parties--for example, statements of peer review or that the text has
been approved by an organization as the authoritative definition of a
standard.
     </para>
    <para>
You may add a passage of up to five words as a Front-Cover Text, and a
passage of up to 25 words as a Back-Cover Text, to the end of the list
of Cover Texts in the Modified Version.  Only one passage of
Front-Cover Text and one of Back-Cover Text may be added by (or
through arrangements made by) any one entity.  If the Document already
includes a cover text for the same cover, previously added by you or
by arrangement made by the same entity you are acting on behalf of,
you may not add another; but you may replace the old one, on explicit
permission from the previous publisher that added the old one.
     </para>
    <para>
The author(s) and publisher(s) of the Document do not by this License
give permission to use their names for publicity for or to assert or
imply endorsement of any Modified Version.
     </para>
   </listitem>
   <listitem>
    <para>
COMBINING DOCUMENTS
     </para>
    <para>
You may combine the Document with other documents released under this
License, under the terms defined in section 4 above for modified
versions, provided that you include in the combination all of the
Invariant Sections of all of the original documents, unmodified, and
list them all as Invariant Sections of your combined work in its
license notice, and that you preserve all their Warranty Disclaimers.
     </para>
    <para>
The combined work need only contain one copy of this License, and
multiple identical Invariant Sections may be replaced with a single
copy.  If there are multiple Invariant Sections with the same name but
different contents, make the title of each such section unique by
adding at the end of it, in parentheses, the name of the original
author or publisher of that section if known, or else a unique number.
Make the same adjustment to the section titles in the list of
Invariant Sections in the license notice of the combined work.
     </para>
    <para>
In the combination, you must combine any sections Entitled "History"
in the various original documents, forming one section Entitled
"History"; likewise combine any sections Entitled "Acknowledgements",
and any sections Entitled "Dedications".  You must delete all
sections Entitled "Endorsements."
     </para>
   </listitem>
   <listitem>
    <para>
COLLECTIONS OF DOCUMENTS
     </para>
    <para>
You may make a collection consisting of the Document and other documents
released under this License, and replace the individual copies of this
License in the various documents with a single copy that is included in
the collection, provided that you follow the rules of this License for
verbatim copying of each of the documents in all other respects.
     </para>
    <para>
You may extract a single document from such a collection, and distribute
it individually under this License, provided you insert a copy of this
License into the extracted document, and follow this License in all
other respects regarding verbatim copying of that document.
     </para>
   </listitem>
   <listitem>
    <para>
AGGREGATION WITH INDEPENDENT WORKS
     </para>
    <para>
A compilation of the Document or its derivatives with other separate
and independent documents or works, in or on a volume of a storage or
distribution medium, is called an "aggregate" if the copyright
resulting from the compilation is not used to limit the legal rights
of the compilation's users beyond what the individual works permit.
When the Document is included an aggregate, this License does not
apply to the other works in the aggregate which are not themselves
derivative works of the Document.
     </para>
    <para>
If the Cover Text requirement of section 3 is applicable to these
copies of the Document, then if the Document is less than one half of
the entire aggregate, the Document's Cover Texts may be placed on
covers that bracket the Document within the aggregate, or the
electronic equivalent of covers if the Document is in electronic form.
Otherwise they must appear on printed covers that bracket the whole
aggregate.
     </para>
   </listitem>
   <listitem>
    <para>
TRANSLATION
     </para>
    <para>
Translation is considered a kind of modification, so you may
distribute translations of the Document under the terms of section 4.
Replacing Invariant Sections with translations requires special
permission from their copyright holders, but you may include
translations of some or all Invariant Sections in addition to the
original versions of these Invariant Sections.  You may include a
translation of this License, and all the license notices in the
Document, and any Warranty Disclaimers, provided that you also include
the original English version of this License and the original versions
of those notices and disclaimers.  In case of a disagreement between
the translation and the original version of this License or a notice
or disclaimer, the original version will prevail.
     </para>
    <para>
If a section in the Document is Entitled "Acknowledgements",
"Dedications", or "History", the requirement (section 4) to Preserve
its Title (section 1) will typically require changing the actual
title.
     </para>
   </listitem>
   <listitem>
    <para>
TERMINATION
     </para>
    <para>
You may not copy, modify, sublicense, or distribute the Document except
as expressly provided for under this License.  Any other attempt to
copy, modify, sublicense or distribute the Document is void, and will
automatically terminate your rights under this License.  However,
parties who have received copies, or rights, from you under this
License will not have their licenses terminated so long as such
parties remain in full compliance.
     </para>
   </listitem>
   <listitem>
    <para>
FUTURE REVISIONS OF THIS LICENSE
     </para>
    <para>
The Free Software Foundation may publish new, revised versions
of the GNU Free Documentation License from time to time.  Such new
versions will be similar in spirit to the present version, but may
differ in detail to address new problems or concerns.  See
http://www.gnu.org/copyleft/.
     </para>
    <para>
Each version of the License is given a distinguishing version number.
If the Document specifies that a particular numbered version of this
License "or any later version" applies to it, you have the option of
following the terms and conditions either of that specified version or
of any later version that has been published (not as a draft) by the
Free Software Foundation.  If the Document does not specify a version
number of this License, you may choose any version ever published (not
as a draft) by the Free Software Foundation.
     </para>
   </listitem>
  </orderedlist>
  <bridgehead renderas="sect2">ADDENDUM: How to use this License for your documents</bridgehead>
  <para>
To use this License in a document you have written, include a copy of
the License in the document and put the following copyright and
license notices just after the title page:
    </para>
  <para>
   <screen>
  Copyright (C)  <varname>year</varname>  <varname>your name</varname>.
  Permission is granted to copy, distribute and/or modify this document
  under the terms of the GNU Free Documentation License, Version 1.2
  or any later version published by the Free Software Foundation;
  with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
  A copy of the license is included in the section entitled ``GNU
  Free Documentation License''.
     </screen>
  </para>
  <para>
If you have Invariant Sections, Front-Cover Texts and Back-Cover Texts,
replace the "with...Texts." line with this:
    </para>
  <para>
   <screen>
with the Invariant Sections being <varname>list their titles</varname>, with
the Front-Cover Texts being <varname>list</varname>, and with the Back-Cover Texts
being <varname>list</varname>.
</screen>
  </para>
  <para>
If you have Invariant Sections without Cover Texts, or some other
combination of the three, merge those two alternatives to suit the
situation.
    </para>
  <para>
If your document contains nontrivial examples of program code, we
recommend releasing these examples in parallel under your choice of
free software license, such as the GNU General Public License,
to permit their use in free software.
    </para>
 </appendix>
</book>
