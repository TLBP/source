<?xml version="1.0" encoding="UTF-8"?>
<!--DOCTYPE article SYSTEM "../../docbook/dtd/docbookx.dtd"-->
<!-- ********************************************************************
     $Id: ncurses.xml,v 1.1 2002/12/20 22:51:00 nilgun Exp $
     ******************************************************************** -->
<article xml:id="ncurses" lang="tr">
  <info>
    <title>Ncurses'a Giriş</title>
    <author>
     <personname><firstname>Reha K. Gerçeker</firstname>
    </author>
    <pubdate>28 Ocak 2003</pubdate>
    <releaseinfo>v1.0</releaseinfo>

    <abstract>
      <para>
<command>ncurses</command> metin tabanlı uçbirimler için pencereler oluşturma ve kullanmaya, ekranı farklı renklerde boyamaya ve işlev tuşlarını kullanmaya imkan veren bir kütüphanedir.
      </para><para>
Bu belgenin özgün sürümünü <link xlink:href="http://www.linuxfocus.org/Turkce/March2002/article233.shtml"/> adresinde bulabilirsiniz.
      </para>
    </abstract>

    <legalnotice><title>Yasal Açıklamalar</title>
      <para>
Bu belgenin, <emphasis>Ncurses'a Giriş</emphasis>, 1.0 sürümünün <emphasis role="bold">telif hakkı © 2003 <emphasis>Reha K. Gerçeker</emphasis></emphasis>'e aittir. &notice.gfdl.orig;</para>
      &notice.disc;
    </legalnotice>
  </info>

<sect1 xml:id="ncurses-nedir"><title>Ncurses Nedir?</title>
  <para>
Yazdığınız bir yazılımın renkli ve pencere temelli bir arayüze sahip olmasını mı istiyorsunuz? <command>ncurses</command> metin tabanlı uçbirimler için pencereler oluşturma ve kullanmaya, ekranı farklı renklerde boyamaya ve işlev tuşlarını kullanmaya imkan veren bir kütüphanedir. <command>ncurses</command> ile yapabilecekleriniz:
  </para><para>
    <itemizedlist>
      <listitem>Ekranın her yerini isteğinize göre kullanmak.</listitem>
      <listitem>Pencereler oluşturmak ve onları yönetmek.</listitem>
      <listitem>8 farklı renk kullanmak.</listitem>
      <listitem>Yazılımınıza fare desteği vermek.</listitem>
      <listitem>Klavyedeki işlev tuşlarını kullanmak.</listitem>
  </itemizedlist></para><para>
<command>ncurses</command> kütüphanesini ANSI/POSIX uyumlu UNIX sistemlerde kullanmak mümkündür. Bunun yanında, hangisi kullanılıyor olursa olsun uçbirim özelliklerini sistemden öğrenerek uçbirimden bağımsız bir arayüz sunmaktadır. Bu açılardan yazılımcının farklı platformlar ve uçbirimler için bile güvenerek kullanabileceği bir kütüphanedir.
  </para><para>
Midnight Commander, <command>ncurses</command> kullanılarak yazılmış yazılımlara verilecek örneklerden bir tanesidir. Ayrıca konsolda çekirdek yapılandırması için kullanılan arayüz <command>ncurses</command> ile hazırlanmıştır. Bu iki yazılıma ilişkin ekran görüntülerini aşağıda görüyorsunuz.
  </para><para>
    <mediaobject>
      <imageobject>
        <imagedata align="center" fileref="ncurses/mc.jpg"/>
      </imageobject>
    </mediaobject>
  </para><para>
    <mediaobject>
      <imageobject>
        <imagedata align="center" fileref="ncurses/menuconfig.jpg"/>
      </imageobject>
    </mediaobject>
 </para><sect2><title>Nereden Bulabilirim?</title>
  <para>
<command>ncurses</command> GNU/Linux altında geliştirilmektedir. <link xlink:href="http://www.gnu.org/software/ncurses/"/> adresinden güncel sürümünü, ayrıntılı bilgileri ve diğer gerekli adresleri öğrenebilirsiniz.
  </para>
 </sect2></sect1>
 <sect1 xml:id="ncurses-temel"><title>Temel Bilgiler</title>
  <para>
<command>ncurses</command> kütüphanesini kullanmak için <filename>curses.h</filename> başlık dosyasını kodunuza eklemeli ve kodunuzu <userinput>gcc</userinput> ile derlerken <option>-lcurses</option> seçeneğini kullanmayı unutmamalısınız.
  </para><para>
<command>ncurses</command> konusuna girerken kütüphane için temel bir veri yapısından bahsetmek gerekir. <literal>WINDOW *</literal> türünde olan bu yapı, adından da anlaşıldığı gibi, <command>ncurses</command> ile oluşturacağınız pencereleri temsil etmek için kullanılır. Hemen hemen tüm <command>ncurses</command> işlevleri <literal>WINDOW *</literal> türünden bir akımı bağımsız değişken olarak alırlar.
  </para>
  <para>
Pencereler, <command>ncurses</command>'da en çok kullanılan bileşenlerdir. Siz hiçbir pencere oluşturmasanız bile ekran tek başına bir pencere olarak kabul edilir. Standart giriş/çıkış kütüphanesinde (yönlendirmeler olmadığı sürece) çıktı ekranını <literal>FILE *</literal> türünde <literal>stdout</literal> adlı akımın temsil etmesi gibi <command>ncurses</command>'da da ekran <literal>WINDOW *</literal> türünde <literal>stdscr</literal> adlı bir akım ile temsil edilir. <literal>stdscr</literal> akımına ek olarak, kütüphane tarafından <literal>curscr</literal> adlı bir başka <literal>WINDOW *</literal> türünde akım daha tanımlanır. <literal>stdscr</literal> öntanımlı çıktı ekranı temsil ettiği halde, <literal>curscr</literal> o anki çıktı ekran görüntüsünü temsil eder. "<emphasis>İkisinin arasında ne fark var ki?</emphasis>" diye düşünüyor olabilirsiniz, okumaya devam edin.
  </para><para>
Yazılımınızda <command>ncurses</command> işlevlerini ve değişkenlerini kullanabilmek için herşeyden önce <userinput>initscr</userinput> işlevini çağırmanız gerekir. Bu işlev <literal>stdscr</literal> ve <literal>curscr</literal> akımlarını ilklendirir (bellek ayırır) ve kütüphaneyi hazır hale getirir. Dolayısıyla her <command>ncurses</command> işlevi <userinput>initscr</userinput> işlevini takip etmek zorundadır. Benzer şekilde <command>ncurses</command> ile işinizi bitirdiğinizde <userinput>endwin</userinput> işlevini kullanarak kütüphanenin oluşturduğu akımların yokedilmesini sağlayabilirsiniz. Bunu yaptıktan sonra yeniden <userinput>initscr</userinput> çağrısı yapmadığınız sürece <command>ncurses</command> işlevlerini kullanamazsınız.
  </para><para>
Yazılımınızda <userinput>initscr</userinput> ve <userinput>endwin</userinput> çağrıları arasında standart C kütüphanesinin giriş/çıkış işlevlerini kullanarak ekrana çıktı göndermemelisiniz. Bu durumda beklediğiniz görüntüyü elde edemeyebilirsiniz. <command>ncurses</command> kütüphanesi etkin olduğu sürece ekran çıktısı için sadece onun işlevlerini kullanmaya dikkat edin. <userinput>initscr</userinput> çağırmadan önce ya da <userinput>endwin</userinput> çağırdıktan sonra istediğinizi yapabilirsiniz.
  </para></sect1>
  <sect1 xml:id="ncurses-refresh"><title>Ekran Görüntüsünün Tazelenmesi</title>
  <para>
<literal>WINDOW *</literal> yapısı içinde pencerenin eni, boyu, konumu gibi bilgiler tutulduğu gibi içeriği de saklanır. <command>ncurses</command> işlevleri ile bir pencereye yazı yazıldığı zaman bu o yazının hemen ekranda görünmesi anlamına gelmez. Yazılan yazı öncelikle ilgili pencerenin içeriğinde güncellenir. Ekran görüntüsünün güncellenmesi için <userinput>refresh</userinput> ya da <userinput>wrefresh</userinput> işlevlerinın çağrılması gerekir.
  </para><para>
<literal>stdscr</literal> ile <literal>curscr</literal> arasında yukarıda kafanıza takılmış olabilecek fark buradadır. <literal>curscr</literal> ekranın o anki görüntüsünü içerirken, <literal>stdscr</literal>'nin içeriği yapılmış yeni işlev çağrıları sonucu farklı olabilir. <literal>stdscr</literal> ile <literal>curscr</literal>'nin örtüşmesi için <userinput>refresh</userinput> işlevinin çağrılması gerekir. Diğer bir deyişle, <literal>curscr</literal>'nin içeriğini <literal>stdscr</literal>'nin içeriği ile değiştiren tek işlev <userinput>refresh</userinput> işlevidir. Sizin <literal>curscr</literal>'yi kurcalamamanız ve onunla ilgili işleri <userinput>refresh</userinput> işlevine havale etmeniz tavsiye edilir.
  </para><para>
<userinput>refresh</userinput> işlevi ekranı güncelleme işini mümkün olduğunca hızlı yapabilmek için değişik bir mekanizmaya sahiptir. İşlev çağrıldığında görüntüsü güncellenecek olan pencerenin yalnızca değişen satırlarını günceller. Böylece değişmeyen satırları yeniden ekrana yazmak için işlemci zamanı tüketmez. <command>ncurses</command> ile standart giriş/çıkış kütüphanesi işlevlerinın birlikte kullanılmasının istenmeyen sonuçlar doğurmasının sebebi bu mekanizmadır; <command>ncurses</command> işlevleri bir pencereye yazdığı zaman o satırın değiştiğini belirten bayrağı doğrularlar, standart giriş/çıkış işlevleri ise bu işi yapmaz.
  </para><para>
<userinput>refresh</userinput> ile <userinput>wrefresh</userinput> işlevleri temelde aynı işi yaparlar. <userinput>wrefresh</userinput> işlevi bağımsız değişken olarak <literal>WINDOW *</literal> türünde bir akım alır ve bu pencerenin görüntüsünü günceller. <function>refresh()</function> ise <function>wrefresh(stdscr)</function> çağrısı yapmaya denktir. Daha sonra da bahsedeceğim gibi birçok <command>ncurses</command> işlevinin (<userinput>wrefresh</userinput> gibi) <literal>stdscr</literal> için yazılmış makroları vardır.
  </para>
</sect1><sect1 xml:id="ncurses-pencere-olusturma"><title>Yeni Pencerelerin Oluşturulması</title>
  <para>
Şimdi kendi pencerelerinizi oluşturmanızı sağlayan <userinput>subwin</userinput> ve <userinput>newwin</userinput> işlevlerindan bahsedelim. Bu iki işlev de bağımsız değişken olarak oluşturmak istediğiniz pencerenin enini, boyunu, sol üst köşesinin koordinatlarını alırlar. Dönüş değerleri ise yeni pencereyi temsil eden bir <literal>WINDOW *</literal> türünde bir pencere akımıdır. Bu yeni akımı yukarıda bahsettiğim <userinput>wrefresh</userinput> ve daha sonra bahsedeceğim diğer işlevlerle birlikte kullanabilirsiniz.
  </para><para>
"Madem aynı işi yapıyorlar, neden iki tane işlev var?" diye düşünebilirsiniz. Haklısınız, tam olarak aynı işi yapmıyorlar. <userinput>subwin</userinput> işlevi yeni oluşturulan pencereyi bir başka pencerenin alt penceresi olarak oluşturur. Bu şekilde oluşturulan pencere ana pencerenin o anki tüm özelliklerini miras alır. Bu özellikler daha sonra ana pencereden bağımsız olarak değiştirilebilir. Bu durum ana pencere ile alt pencereyi birbirine bağlayan bir durum değildir.
  </para><para>
Bunun dışında ana ve alt pencereyi birbirine bağlayan bir özellik vardır: Pencere içeriğinin tutulduğu karakter dizisi ana ve alt pencereler için ortaktır. Diğer bir deyişle, ana pencere ile alt pencerenin kesiştiği bir noktadaki karakter her iki pencere tarafından da değiştirilebilir. Böyle bir kareye alt pencere yazarsa ana pencerenin, ana pencere yazarsa alt pencerenin o noktadaki karakterinin üzerine yazılır.
  </para><para>
<userinput>newwin</userinput> ise tamamiyle yeni bir pencere oluşturur. Böyle bir pencere, kendi alt pencereleri olmadığı sürece karakter dizisini başka pencerelerle paylaşmaz. <userinput>subwin</userinput> işlevini kullanmanın yararı, ortak karakter dizisi kullanımı sebebiyle daha az bellek tüketilmesidir. Ancak pencerelerin birbirlerinin bilgilerinin üzerine yazmasının istenmediği durumlarda <userinput>newwin</userinput> kullanmak doğru harekettir.
  </para><para>
Alt pencerelerinizi koşullar elverdiği sürece istediğiniz derinlikte oluşturabilirsiniz. Her alt pencerenin de kendi alt pencereleri olabilir, fakat bu durumda aynı karakter dizisini ikiden de fazla pencerenin paylaştığını unutmayın.
  </para><para>
Oluşturduğunuz pencerelerle işiniz bittiğinde <userinput>delwin</userinput> işleviyle onları yokedebilirsiniz. İşlevlerin bağımsız değişkenlerini öğrenmek için man sayfalarına bakmanızı tavsiye ederim.
  </para>
</sect1><sect1 xml:id="ncurses-pencere-calisma"><title>Pencerelere Yazma ve Pencerelerden Okuma</title>
  <para>
Ncurses standart akımları olan <literal>stdscr</literal> ve <literal>curscr</literal>'den, ekran görüntüsünü tazelemekten ve yeni pencereler oluşturmaktan bahsettik. Peki pencerelerin içeriğini nasıl değiştireceğiz? Pencerelere nasıl yazacağız ve pencerelerden nasıl bilgi okuyacağız?
  </para><para>
Bunlar için standart giriş/çıkış kütüphanesinin işlevlerine çok benzeyen işlevler kullanılmaktadır. <userinput>printf</userinput> yerine <userinput>printw</userinput>, <userinput>scanf</userinput> yerine <userinput>scanw</userinput>, <userinput>putc</userinput> ya da <userinput>putchar</userinput> yerine <userinput>addch</userinput>, <userinput>getc</userinput> ya da <userinput>getchar</userinput> yerine <userinput>getch</userinput> kullanılır. Kullanımları alışıldığı gibidir, kullanım olarak sadece isimleri değişiktir. Benzer şekilde pencereye dizge yazmak için <userinput>addstr</userinput>, pencereden bir dizge okumak için <userinput>getstr</userinput> kullanılabilir. Tüm bu işlev başlarına bir '<userinput>w</userinput>' harfi eklenerek ve birinci bağımsız değişken olarak <literal>WINDOW *</literal> türünde bir pencere akımı alarak akımı belirtilen bir başka pencereye de yazabilirler. Örneğin, <literal>printw(...)</literal> ile <literal>wprintw(stdscr, ...)</literal> aynı işi yapan iki çağrıdır, aynı <literal>refresh()</literal> ve <literal>wrefresh(stdscr)</literal> durumunda olduğu gibi.
  </para><para>
Bu işlevlere çok ayrıntılı olarak değinmek fazla yer kaplayacaktır. Yaptıkları işleri, prototiplerini, dönüş değerlerini ve uyarıları öğrenmek için en iyi kaynak her zaman olduğu gibi man sayfalarıdır. Sözünü ettiğim her işlev için kullanmadan önce man sayfasına bir bakmanızı tavsiye ederim. Çok daha ayrıntılı bilgiler edinebilirsiniz. Ayrıca yazının son bölümünü öğretici bir örneğe ayırdım. Şu ana kadar anlattığım ve anlatacağım hemen hemen tüm işlev ve kavramları bu örnek yazılımda takip etme imkanı bulacaksınız.
  </para>
</sect1><sect1 xml:id="ncurses-imlecler"><title>Fiziksel ve Mantıksal İmleç</title>
  <para>
<command>ncurses</command> ile pencerelere yazmak ve pencerelerden okumak sözkonusu olduğu zaman <wordasword>mantıksal ve fiziksel imleç</wordasword> kavramlarına da değinmek gerekir. Fiziksel imleçten kasıt yanıp sönerek sürekli ekranda görünen bildiğimiz imleçtir ve bir tanedir. Mantıksal imleçler ise <command>ncurses</command> pencerelerine ait olan ve her pencerenin mutlaka sahip olduğu başka imleçlerdir. Birden çok pencere olabileceğine göre mantıksal imleç de birden fazla olabilir.
  </para><para>
Mantıksal imlecin görevi pencereye bir yazı yazılacağı zaman yazma işleminin başlayacağı ya da pencereden bir bilgi okunacağı zaman bu bilginin okunacağı kareyi göstermektir. Mantıksal imleci isteğinize göre hareket ettirebilmeniz demek ekranın ya da oluşturduğunuz pencerenin istediğiniz karesine istediğiniz zaman yazı yazabilmeniz anlamına gelir. Bu, standart giriş/çıkış kütüphanesinin sağlamadığı bir avantajdır.
  </para><para>
İmleçlerin hareket ettirilmesi işini yapan işlev <userinput>move</userinput> ya da hemen tahmin edeceğiniz üzere <userinput>wmove</userinput> işlevleridir. <userinput>move</userinput> işlevi <userinput>wmove</userinput> işlevinin <literal>stdscr</literal> için yazılmış bir makrosudur.
  </para><para>
Bir de mantıksal imleç ile fiziksel imlecin koordinasyonunun sağlanması durumu sözkonusudur. Herhangi bir yazma işleminin ardından fiziksel imlecin bulunacağı konum, her pencerenin sahip olduğu <literal>_leave</literal> bayrağının değerine bakılarak kararlaştırılır. Eğer <literal>_leave</literal> doğruysa, mantıksal imleç yazma işleminden sonra fiziksel imlecin üzerine (son harfin yazıldığı kareye) getirilir. Eğer <literal>_leave</literal> yanlışsa, fiziksel imleç mantıksal imlecin bulunduğu kareye (ilk harfin yazıldığı kareye) geri getirilir. <literal>_leave</literal> bayrağını yöneten işlev <userinput>leaveok</userinput> işlevidir.
  </para><para>
Fiziksel imlecin hareket ettirilmesini sağlayan işlev <userinput>mvcur</userinput> işlevidir. Diğer işlevlerden farklı olarak <userinput>mvcur</userinput> işlevi bir sonraki <userinput>refresh</userinput>'te değil, hemen etkin olur. Fiziksel imlecin ekranda görünmesini istemiyorsanız, <userinput>curs_set</userinput> işlevini ilgili bağımsız değişkenleri ile kullanabilirsiniz. Ayrıntılar için man sayfalarına bakınız.
  </para><para>
Yukarıda bahsettiğim imleci hareket ettirme ve yazı yazma işlemlerini tek bir çağrı ile de yapabilirsiniz. Bu, işlev çağrılarını birleştiren makroların varlığı sayesinde mümkündür. Bu çağrılar da <userinput>addch, addstr, printw, getch, getstr, scanw</userinput> işlevlerinin man sayfalarında ayrıntılı olarak açıklanmıştır.
  </para>
</sect1><sect1 xml:id="ncurses-pencere-temizlik"><title>Pencerelerin Temizlenmesi</title>
  <para>
Pencelere yazmak tamam. Peki pencereleri nasıl temizleyeceğiz, istediğimiz satırları ve karakterleri nasıl sileceğiz?
  </para><para>
<command>ncurses</command>'da silme, silinecek karenin, satırın ya da pencerenin içeriğinin boşluklarla doldurulması demektir. Aşağıda değindiğim silme işlevlerinın yaptığı da silinecek yerleri boşlukla doldurmaktır.
  </para>
  <para>
Önce tek tek karakterler ya da satırlarla uğraşan işlevlere değinelim. <userinput>delch</userinput> ve <userinput>wdelch</userinput> pencerede o an mantıksal imlecin altında olan karakteri siler ve aynı satırda mantıksal imlecin sağında bulunan karakterleri birer sola kaydırır. <userinput>deleteln</userinput> ve <userinput>wdeleteln</userinput> ise mantıksal imlecin bulunduğu satırı sildikten sonra alttaki satırları birer yukarı kaydırır.
  </para><para>
<userinput>clrtoeol</userinput> ve <userinput>wclrtoeol</userinput> işlevleri mantıksal imlecin bulunduğu satırda imlecin sağında kalan tüm karakterleri silerler. <userinput>clrtobot</userinput> ve <userinput>wclrtobot</userinput> işlevleri ise önce bir <userinput>wclrtoeol</userinput> çağırıp satırda mantıksal imlecin solunda kalan karakterleri, daha sonra da mantıksal imlecin bulunduğu satırın altında kalan tüm satırları silerler.
  </para><para>
Bunların dışında bir de tüm ekranı ya da pencereyi temizlemeye yarayan işlevler vardır. Tüm ekranı silecek işlevlerin kullanabileceği iki yöntem vardır. Birincisi tüm ekranı boşluklarla doldurup <userinput>refresh</userinput> işlevini çağırmak, diğeri de uçbirime ekranı temizlemesini belirten kontrol kodunu göndermektir. Birinci yöntem ikinciden daha yavaştır çünkü tek tek her karakterin ekrana yeniden yazılmasını gerektirir. İkincisi ise tüm ekranı hemen temizler.
  </para><para>
<userinput>erase</userinput> ve <userinput>werase</userinput> işlevleri bir pencerenin karakter dizisini boşluklarla dolduran işlevlerdir. Bir sonraki <userinput>refresh</userinput> çağrısında pencere temizlenmiş olacaktır. Bu işlevleri kullanmak temizlenmek istenen pencere tam ekran boyutunda ise çok mantıklı değildir. Çünkü bu işlevler yukarıda bahsedilen yöntemlerden ilkini kullanmaktadır. Temizlenecek pencere tam ekran boyutunda olduğu zaman aşağıda anlatacağım işlevleri kullanmak daha yararlıdır.
  </para><para>
Diğer işlevlere geçmeden önce <literal>_clear</literal> bayrağından sözetmek gerekir. Her pencerede olan <literal>_clear</literal> bayrağı, eğer doğruysa bir sonraki <userinput>refresh</userinput>'te uçbirime kontrol kodunun gönderilmesini ister. Ancak <userinput>refresh</userinput> bunu yapmadan önce bunu isteyen pencerenin tam ekran boyutunda olup olmadığını (<literal>_FULLWIN</literal> bayrağı ile) kontrol eder. Eğer pencere tam ekran boyutundaysa, <userinput>refresh</userinput> uçbirimin ekranı temizlemesini sağlar ve sadece boşluktan farklı olan karakterleri ekrana yazar. Bu, tüm ekran boyutunda temizlemenin hızlı olmasını sağlar. Uçbirim yönteminin sadece tam ekran boyutundaki pencerelerin temizlenmesi için kullanılmasının sebebi, uçbirime kontrol kodu gönderildiği zaman tüm ekranın temizlenmesidir. Pencere tam ekran boyutunda değilse, tüm ekranın temizlenmesi istenmez. <literal>_clear</literal> bayrağını <userinput>clearok</userinput> işlevi kontrol eder.
  </para><para>
<userinput>clear</userinput> ve <userinput>wclear</userinput> işlevleri tam ekran boyutundaki pencerelerin temizlenmesi için tercih edilir. Aslında bu işlevler bir <userinput>werase</userinput> ve bir <userinput>clearok</userinput> çağrısı yapmaya denktir. Öncelikle pencerenin karakter dizisini boşluklarla doldururlar. Daha sonra da <literal>_clear</literal> bayrağını doğrulayarak pencere tam ekran boyutunda ise uçbirim yoluyla, değilse de tek tek tüm karelerin üzerine boşluk karakteri yazmak yoluyla pencereyi temizlerler.
  </para><para>
Sonuç olarak, temizlenecek pencerenin tam ekran boyutunda olduğunu biliyorsanız, <userinput>clear</userinput> yoksa <userinput>wclear</userinput> kullanın. Daha hızlı bir sonuç elde edersiniz. Fakat silinecek pencere tam ekran boyutunda değilse, <userinput>wclear</userinput> ya da <userinput>werase</userinput> kullanmanız arasında bir performans farkı yoktur.
  </para>
</sect1><sect1 xml:id="ncurses-renkler"><title>Renkler</title>
  <para>
Ekran üzerinde görülen renkleri renk çiftleri olarak adlandırmak gerekir. Çünkü her karenin bir artalan rengi, bir de yazı rengi vardır. <command>ncurses</command> ile renkli yazabilmenin yolu da kendinize ait renk çiftleri oluşturmak ve yazılarınızın bu çiftler kullanılarak yazılmasını sağlamaktır.
  </para><para>
<command>ncurses</command> işlevlerini kullanabilmek için <userinput>initscr</userinput> çağrısı yapmanızın gerekmesi gibi, renk işlevlerini kullanmadan önce de <userinput>start_color</userinput> işlevini çağırmanız gerekir. Bundan sonra renk çiftleri oluşturmak için kullanmanız gereken işlev <userinput>init_pair</userinput> işlevidir. <userinput>init_pair</userinput> ile bir renk çifti oluşturduğunuzda, işleve aktarmış olduğunuz ilk bağımsız değişken olan sayı ile bu renk çiftini ilişkilendirmiş olursunuz. Daha sonra yazılımınızda bu çifti kullanmak istediğinizde <literal>COLOR_PAIR</literal> makrosunu bu sayı ile çağırmanız yeterli olacaktır.
  </para><para>
Renk çiftleri oluşturmanın dışında yazılarınızın bu çiftlerle yazılmasını sağlamanız gerekir. Bunu yapan işlevler <userinput>attron</userinput> ve <userinput>wattron</userinput> işlevleridır. Bu işlevler, <userinput>attroff</userinput> veya <userinput>wattroff</userinput> çağrıları yapılana kadar ilgili pencereye yazılacak her yazının belirtilen renk çifti ile yapılmasını sağlarlar.
  </para><para>
Bir de pencerelerin genel artalan ve yazı renklerini değiştiren <userinput>bkgd</userinput> ile <userinput>wbkgd</userinput> işlevleri vardır. Bu işlevler çağrıldıkları zaman ilgili pencerenin renk çiftini istenen renk çifti olarak değiştirirler ve bundan sonra pencerenin tüm karelerinin artalan rengi ile tüm yazıların rengi otomatik olarak değişir.
  </para><para>
Kullanabileceğiniz renkler ve adı geçen işlevlerin kullanımları ile ilgili ayrıntılar için man sayfalarına bakınız.
  </para>
</sect1><sect1 xml:id="ncurses-pencerler-kutulama"><title>Pencerelerin Kutulanması</title>
  <para>
Güzel bir görüntü oluşturmak için pencerelerinizi kutu içine alabilirsiniz. Kütüphane içerisinde bunu sizin için yapacak <userinput>box</userinput> adlı bir makro vardır. Ancak diğer işlevlerden farklı olarak <userinput>wbox</userinput> mevcut değildir; <userinput>box</userinput> makrosu zaten bir pencere akımını bağımsız değişken olarak alır.
  </para><para>
Makronun kolay kullanımları ile ilgili ayrıntıları man sayfasından öğrenebilirsiniz. Burada başka bir noktaya dikkat etmeniz gerekmektedir. Bu makroyla pencerelerinizi kutu içine almanızın tek anlamı, o pencerenin karakter dizisinde pencereyi sınırlayan karelere kutuyu oluşturacak karakterlerin yazılmasıdır. Eğer siz bu karakterlerin üzerine yazarsınız kutunun görüntüsünü bozabilirsiniz. Bunun için, asıl pencerenin içinde <userinput>subwin</userinput> ile yeni bir pencere oluşturup dıştaki pencereyi kutu içine almanız ve yazı yazmak için içteki pencereyi kullanmanız güvenilir bir yöntem olabilir.
  </para>
</sect1><sect1 xml:id="ncurses-islev-tuslari"><title>İşlev Tuşları</title>
  <para>
Klavyedeki işlev tuşlarını kullanabilmeniz için öncelikle klavyeden bilgi okuyacağınız pencerede <literal>_use_keypad</literal> bayrağının değerinin doğrulanması gerekir. Bunu yapan işlev <userinput>keypad</userinput> işlevidir. Bu işleve çağrı yaparak işlev tuşlarını kullanılır hale getirdikten sonra normal girdi işlevleri ile klavyeden giriş alabilirsiniz.
  </para><para>
Ancak bu durumda, örneğin <userinput>getch</userinput> ile aldığınız bir bilgiyi, <userinput>char</userinput> türünde değil de <userinput>int</userinput> türünde bir değişkenin içerisinde tutmaya dikkat edin. Çünkü işlev tuşlarının sayısal değerleri bir <userinput>char</userinput> türü değişken içinde saklayabileceğiniz değerlerden büyüktür. İşlev tuşlarının sayısal değerlerini bilmenize gerek yoktur, bu sayısal değerler yerine kullanabileceğiniz isimleri <userinput>getch</userinput> işlevinin man sayfasında bulabilirsiniz.
  </para>
 </sect1><sect1 xml:id="ncurses-ornek"><title>Örnek Yazılım</title>
  <para>
Burada inceleyeceğimiz örnek yazılım basit ama öğretici bir yazılımdır. Bu yazılımda <command>ncurses</command> kullanılarak menüler oluşturulmuş ve menüdeki seçeneklerden bir tanesinin seçilmesi basit bir biçimde uygulanmıştır. Bu yazılımda önemli olan <command>ncurses</command>'in pencere bileşenlerini menü etkisi yaratabilecek şekilde kullanmaktır. Yazılımın ekran görüntüsünü aşağıda görüyorsunuz:
  </para><para>
    <mediaobject>
      <imageobject>
        <imagedata align="center" fileref="ncurses/example.jpg"/>
      </imageobject>
    </mediaobject>
  </para><para>
Yazılımda her zaman olduğu gibi önce kullanılan kütüphanelerin başlık dosyaları yazılır. Bir de yazılım içerisinde kullanacağımız <literal>&lt;enter></literal> ve <literal>&lt;escape></literal> tuşlarının ASCII karşılıkları yerine kullanılacak sabitler tanımlanır.
  </para><para>
 <screen>
#include &lt;curses.h>
#include &lt;stdlib.h>

#define ENTER 10
#define ESCAPE 27
</screen>
  </para><para>
Aşağıdaki <function>init_curses</function> işlevi yazılımın ilk çalıştığı zaman çağırdığı işlevdir. Önce <userinput>initscr</userinput> çağrısı yaparak <command>ncurses</command> çalıştırılır, daha sonra <userinput>start_color</userinput> ile renkler kullanılır hale getirilir ve ardından da yazılım boyunca kullanılacak renk çiftleri tanımlanır. <userinput>curs_set(0)</userinput> çağrısı fiziksel imlecin ekran üzerinde görünmemesini sağlarken, <userinput>noecho</userinput> çağrısı da kullanıcının klavyeden girdiği karakterlerin ekrana yazılmasını engeller. <userinput>noecho</userinput> işlevini girdileri kontrol ederek almak ve sadece kabul edilen karakterleri ekrana aktarmak gibi bir amaç için de kullanabilirsiniz. <userinput>noecho</userinput> işlevinin etkisini kaldırmak için gerektiği zaman <userinput>echo</userinput> çağrısı yapılır. Aşağıdaki işlev son olarak <userinput>keypad</userinput> çağrısı yaparak <literal>stdscr</literal>'den alınacak girdilerde işlev tuşlarının da kullanılabilmesini sağlar. F1 ve F2 ile ok tuşlarını kullabilmek için bu çağrı gereklidir.
  </para><para>
<screen>
void init_curses()
{
  initscr();

  start_color();
  init_pair(1, COLOR_WHITE, COLOR_BLUE);
  init_pair(2, COLOR_BLUE, COLOR_WHITE);
  init_pair(3, COLOR_RED, COLOR_WHITE);

  curs_set(0);
  noecho();
  keypad(stdscr, TRUE);
}
</screen>
  </para><para>
Bundan sonraki işlev üzerinde menü isimleri bulunan satırı yazan işlevdir. Biraz aşağılara inerek yazılımda yalnızca bir satır olarak görülen menü çubuğunun, <function>main</function> işlevi içerisinde <literal>stdscr</literal>'nin alt penceresi olarak tanımlanmış tek satırlık bir pencere olduğunu görebilirsiniz. İşte aşağıdaki işlev o pencereyi bağımsız değişken olarak alıp önce artalan rengini değiştirir, sonra da menü isimlerini yazar. Menü isimlerini burada <userinput>waddstr</userinput> ile yazıyoruz. Bu tercihin belirli bir sebebi yok, istenilen işlev kullanılabilirdi. İlk satırdaki <userinput>wbkgd</userinput> çağrısı ile pencerenin renk çifti olarak tanımlanan 2 numaralı çiftin dışında bir renk çifti (3) ile yazmak istediğimizde <userinput>wattron</userinput> işlevini kullandığımıza dikkat edin. Yeniden 2 numaralı çift ile yazmak için ise <userinput>wattroff</userinput> kullanıyoruz.
  </para><para>
<screen>
void draw_menubar(WINDOW *menubar)
{
  wbkgd(menubar, COLOR_PAIR(2));
  waddstr(menubar, "Menu1");

  wattron(menubar, COLOR_PAIR(3));
  waddstr(menubar, "(F1)");
  wattroff(menubar, COLOR_PAIR(3));

  wmove(menubar, 0, 20);
  waddstr(menubar, "Menu2");

  wattron(menubar, COLOR_PAIR(3));
  waddstr(menubar, "(F2)");
  wattroff(menubar, COLOR_PAIR(3));
}
</screen>
  </para><para>
Sıradaki işlev F1 ya da F2 tuşlarına basıldığı zaman menülerin açılmasını sağlayan işlevdir. Menü açılma etkisi oluşturmak için artalanı oluşturan pencere (mavi renkli) üzerine menü çubuğu ile aynı renkte (beyaz) yeni bir pencere açılmaktadır. Ancak bu yeni pencere açıldığı zaman altta kalan pencerede yazılmış olan yazıların silinmesini istemiyoruz. Menü kapandığı zaman bu yazıların yeniden görünmesini istiyoruz. Bu sebeple yeni oluşturulan pencerenin <literal>stdscr</literal>'nin bir alt penceresi olarak oluşturulması doğru değildir. Aşağıda da görüldüğü gibi <varname>items[0]</varname> adlı pencere <userinput>newwin</userinput> işleviyle oluşturulmuştur. Diğer 8 tane <varname>items</varname> penceresi ise <varname>items[0]</varname>'ın alt pencereleri olarak oluşturulmuştur. Burada <varname>items[0]</varname> menüyü sınırlayan çerçeveyi çizmek için kullanılırken diğer pencereler ise hem çerçeveyi oluşturan karakterlerin üzerine yazmamak hem de menüde seçili olan elemanı göstermek için kullanılacaktır. Seçili olan elemanı göstermek için karşılık gelen <varname>items</varname> penceresinin artalan rengini diğerlerinden farklı yapmak yeterlidir. Sondan iki önceki satırda da bu yapılmaktadır ve menü ilk açıldığında birinci sıradaki eleman seçili olarak görünmektedir.
  </para><para>
<screen>
WINDOW **draw_menu(int start_col)
{
  int i;
  WINDOW **items;

  items = (WINDOW **) malloc(9 * sizeof(WINDOW *));
  items[0] = newwin(10,19,1,start_col);
  wbkgd(items[0], COLOR_PAIR(2));
  box(items[0], ACS_VLINE, ACS_HLINE);
  items[1] = subwin(items[0], 1, 17, 2, start_col + 1);
  items[2] = subwin(items[0], 1, 17, 3, start_col + 1);
  items[3] = subwin(items[0], 1, 17, 4, start_col + 1);
  items[4] = subwin(items[0], 1, 17, 5, start_col + 1);
  items[5] = subwin(items[0], 1, 17, 6, start_col + 1);
  items[6] = subwin(items[0], 1, 17, 7, start_col + 1);
  items[7] = subwin(items[0], 1, 17, 8, start_col + 1);
  items[8] = subwin(items[0], 1, 17, 9, start_col + 1);

  for (i = 1; i &lt; 9; i++)
    wprintw(items[i], "Item%d", i);

  wbkgd(items[1], COLOR_PAIR(1));
  wrefresh(items[0]);

  return items;
}
</screen>
  </para><para>
Sıradaki işlev yukarıdaki işlev tarafından oluşturulan menü pencerelerini yokeden işlevdir. Bunun için önce pencereler tek tek <userinput>delwin</userinput> ile yokedilip daha sonra da <varname>items</varname> akım göstericisi için alınan bellek geri verilmektedir.
  </para><para>
<screen>
void delete_menu(WINDOW **items, int count)
{
  int i;

  for (i = 0; i &lt; count; i++)
    delwin(items[i]);

  free(items);
}
</screen>
  </para><para>
<function>scroll_menu</function> işlevi menüler arasında ve menü içinde gezmeyi sağlayan işlevdir. Sonsuz bir döngü içinde <userinput>getch</userinput> işlevi ile klavyeden girilen tuşları okumaktadır. Kullanıcı aşağı yukarı ok tuşlarına basarsa menüde aşağıdaki ya da yukarıdaki eleman seçili olarak gösterilmektedir. Bu, yukarıda da bahsettiğim gibi, seçili olan elemanın bulunduğu pencerenin artalan rengini diğerlerinden farklı yaparak sağlanmaktadır. Kullanıcı eğer sağ ve sol ok tuşlarına basarsa içinde bulunulan menü kapatılmakta ve diğer menü açılmaktadır. Kullanıcı &lt;Enter> tuşuna basarsa seçilmiş olan elemanın değeri geri döndürülür. &lt;Escape> tuşu ise herhangi bir elemanı seçmeden menüleri kapatmaya yarar. İşlev diğer tuşları dikkate almamaktadır. Bu işlevde <userinput>getch</userinput> ile klavyeden ok tuşlarının okunabilmesi için iki hatırlatma yapmakta fayda var. Öncelikle en baştaki <userinput>init_curses</userinput> işlevinde <literal>keypad(stdscr, TRUE)</literal> çağrısı yapılarak <literal>stdscr</literal>'den işlev tuşlarının okunabilmesi sağlanmıştı. Buna ek olarak bir de <userinput>getch</userinput> ile okunan değer <userinput>int</userinput> türünde bir değişkende saklanmaktadır, çünkü ok tuşları ve diğer işlev tuşlarının sayısal değerleri <userinput>char</userinput> türünde bir değişkenin tutabileceğinden büyüktür.
  </para><para>
<screen>
int scroll_menu(WINDOW **items, int count, int menu_start_col)
{
  int key;
  int selected=0;

  while(1)
  {
    key = getch();
    if (key == KEY_DOWN || key == KEY_UP)
    {
      wbkgd(items[selected + 1], COLOR_PAIR(2));
      wnoutrefresh(items[selected + 1]);

      if (key == KEY_DOWN)
        selected = (selected + 1) % count;
      else
        selected = (selected + count - 1) % count;

      wbkgd(items[selected + 1], COLOR_PAIR(1));
      wnoutrefresh(items[selected + 1]);
      doupdate();
    }
    else if (key == KEY_LEFT || key == KEY_RIGHT)
    {
      delete_menu(items, count + 1);
      touchwin(stdscr);
      refresh();
      items = draw_menu(20 - menu_start_col);
      return scroll_menu(items, 8, 20 - menu_start_col);
    }
    else if (key == ESCAPE)
      return -1;
    else if (key == ENTER)
      return selected;
  }
}
</screen>
  </para><para>
Son olarak sırada <function>main</function> işlevi var. <function>main</function> işlevi yukarıda anlatılan işlevleri kullanarak yazılımın çalışmasını sağlamaktadır. Bu işlev de <userinput>getch</userinput> ile basılan tuş değerleri okumakta ve eğer F1 ya da F2 tuşlarına basılmışsa <function>draw_menu</function> ile karşılık gelen menüyü çizdirmektedir. Menü çizildikten sonra <function>scroll_menu</function> işlevi ile menülerden bir eleman seçilmesi sağlanmaktadır. <function>scroll_menu</function> işlevi geri döndükten sonra da önce menü pencereleri silinmekte ve ardından seçilen eleman <varname>messagebar</varname> penceresine yazdırılmaktadır.
  </para><para>
Burada <userinput>touchwin</userinput> işlevine değinmekte fayda var. Menüler kapandıktan sonra <userinput>touchwin</userinput> çağrılmadan <userinput>refresh</userinput> yapılsaydı en son açılan menü ekranda durmaya devam ederdi. Bunun sebebi menüler oluşturulduğu zaman <literal>stdscr</literal> üzerinde hiçbir değişiklik yapılmaması ve <userinput>refresh</userinput> çağrıldığı zaman <literal>stdscr</literal> hiç değişmemiş olarak görüldüğü için yeniden yazılmamasıdır. <userinput>touchwin</userinput> işlevi bağımsız değişken olarak aldığı pencerenin tüm satırlarındaki satırın değiştiğini belirten bayrakları doğrulayarak bir sonraki <userinput>refresh</userinput>'te pencerenin, hiç değişmemiş olsa bile, en baştan çizilmesini sağlar. Menüler oluşturulduğu zaman <literal>stdscr</literal>'ye hiç dokunulmamış olması sayesinde, menüler kapandığı zaman <literal>stdscr</literal>'de yazan bilgi kaybolmamıştır.
  </para><para>
<screen>
int main()
{
  int key;
  WINDOW *menubar, *messagebar;

  init_curses();

  bkgd(COLOR_PAIR(1));
  menubar = subwin(stdscr, 1, 80, 0, 0);
  messagebar = subwin(stdscr, 1, 79, 23, 1);
  draw_menubar(menubar);
  move(2, 1);
  printw("Press F1 or F2 to open the menus. ");
  printw("ESC quits.");
  refresh();

  do {
    int selected_item;
    WINDOW **menu_items;

    key = getch();
    werase(messagebar);
    wrefresh(messagebar);

    if (key == KEY_F(1)) {
      menu_items = draw_menu(0);
      selected_item = scroll_menu(menu_items, 8, 0);
      delete_menu(menu_items, 9);

      if (selected_item &lt; 0)
        wprintw(messagebar, "You haven't selected any item.");
      else
        wprintw(messagebar, "You have selected menu item %d.", selected_item + 1);

      touchwin(stdscr);
      refresh();
    } else if (key == KEY_F(2)) {
      menu_items = draw_menu(20);
      selected_item = scroll_menu(menu_items, 8, 20);
      delete_menu(menu_items, 9);
      wprintw(messagebar, "You have selected menu item %d.", selected_item + 1);

      if (selected_item &lt; 0)
        wprintw(messagebar, "You haven't selected any item.");
      else
        wprintw(messagebar, "You have selected menu item %d.", selected_item + 1);

      touchwin(stdscr);
      refresh();
    }
  } while (key != ESCAPE);

  delwin(menubar);
  delwin(messagebar);
  endwin();

  return 0;
}
</screen>
  </para><para>
Aralara yazdığım açıklamaları çıkarıp kaynak kodunu <filename>example.c</filename> adlı dosyaya kaydettiğinizi varsayarak,
  </para><para>
<screen>gcc example.c -o example -lcurses</screen>
  </para><para>
komutu ile kodu derleyebilir ve yazılımı test edebilirsiniz.
  </para>
</sect1><sect1 xml:id="ncurses-son"><title>Sonuç</title>
  <para>
<command>ncurses</command> kullanarak yazılımınız için güzel bir arayüz oluşturabilmeniz için gereken temel konulara değindim. Ancak bu kütüphaneyle yapabilecekleriniz burada anlatılanlarla sınırlı değildir. Sık sık bakmanızı tavsiye ettiğim man sayfalarında kütüphane ile ilgili başka yönler de keşfedecek ve bu anlattıklarımın yalnızca giriş düzeyinde bilgiler olduğunu göreceksiniz.
  </para>
</sect1>
<appendix xml:id="ncurses-kaynakca"><title>example.c</title>
<para>
<screen>
#include &lt;curses.h>
#include &lt;stdlib.h>

#define ENTER 10
#define ESCAPE 27
void init_curses()
{
        initscr();
        start_color();
        init_pair(1,COLOR_WHITE,COLOR_BLUE);
        init_pair(2,COLOR_BLUE,COLOR_WHITE);
        init_pair(3,COLOR_RED,COLOR_WHITE);
        curs_set(0);
        noecho();
        keypad(stdscr,TRUE);
}
void draw_menubar(WINDOW *menubar)
{
        wbkgd(menubar,COLOR_PAIR(2));
        waddstr(menubar,"Menu1");
        wattron(menubar,COLOR_PAIR(3));
        waddstr(menubar,"(F1)");
        wattroff(menubar,COLOR_PAIR(3));
        wmove(menubar,0,20);
        waddstr(menubar,"Menu2");
        wattron(menubar,COLOR_PAIR(3));
        waddstr(menubar,"(F2)");
        wattroff(menubar,COLOR_PAIR(3));
}
WINDOW **draw_menu(int start_col)
{
        int i;
        WINDOW **items;
        items=(WINDOW **)malloc(9*sizeof(WINDOW *));

        items[0]=newwin(10,19,1,start_col);
        wbkgd(items[0],COLOR_PAIR(2));
        box(items[0],ACS_VLINE,ACS_HLINE);
        items[1]=subwin(items[0],1,17,2,start_col+1);
        items[2]=subwin(items[0],1,17,3,start_col+1);
        items[3]=subwin(items[0],1,17,4,start_col+1);
        items[4]=subwin(items[0],1,17,5,start_col+1);
        items[5]=subwin(items[0],1,17,6,start_col+1);
        items[6]=subwin(items[0],1,17,7,start_col+1);
        items[7]=subwin(items[0],1,17,8,start_col+1);
        items[8]=subwin(items[0],1,17,9,start_col+1);
        for (i=1;i&lt;9;i++)
                wprintw(items[i],"Item%d",i);
        wbkgd(items[1],COLOR_PAIR(1));
        wrefresh(items[0]);
        return items;
}
void delete_menu(WINDOW **items,int count)
{
        int i;
        for (i=0;i&lt;count;i++)
                delwin(items[i]);
        free(items);
}
int scroll_menu(WINDOW **items,int count,int menu_start_col)
{
        int key;
        int selected=0;
        while (1) {
                key=getch();
                if (key==KEY_DOWN || key==KEY_UP) {
                        wbkgd(items[selected+1],COLOR_PAIR(2));
                        wnoutrefresh(items[selected+1]);
                        if (key==KEY_DOWN) {
                                selected=(selected+1) % count;
                        } else {
                                selected=(selected+count-1) % count;
                        }
                        wbkgd(items[selected+1],COLOR_PAIR(1));
                        wnoutrefresh(items[selected+1]);
                        doupdate();
                } else if (key==KEY_LEFT || key==KEY_RIGHT) {
                        delete_menu(items,count+1);
                        touchwin(stdscr);
                        refresh();
                        items=draw_menu(20-menu_start_col);
                        return scroll_menu(items,8,20-menu_start_col);
                } else if (key==ESCAPE) {
                        return -1;
                } else if (key==ENTER) {
                        return selected;
                }
        }
}
int main()
{
    int key;
    WINDOW *menubar,*messagebar;

    init_curses();

    bkgd(COLOR_PAIR(1));
    menubar=subwin(stdscr,1,80,0,0);
    messagebar=subwin(stdscr,1,79,23,1);
    draw_menubar(menubar);
    move(2,1);
    printw("Press F1 or F2 to open the menus. ");
    printw("ESC quits.");
    refresh();

    do {
        int selected_item;
        WINDOW **menu_items;
        key=getch();
        werase(messagebar);
        wrefresh(messagebar);
        if (key==KEY_F(1)) {
            menu_items=draw_menu(0);
            selected_item=scroll_menu(menu_items,8,0);
            delete_menu(menu_items,9);
            if (selected_item&lt;0)
                wprintw(messagebar,"You haven't selected any item.");
            else
                wprintw(messagebar,
                  "You have selected menu item %d.",selected_item+1);
            touchwin(stdscr);
            refresh();
        } else if (key==KEY_F(2)) {
            menu_items=draw_menu(20);
            selected_item=scroll_menu(menu_items,8,20);
            delete_menu(menu_items,9);
            if (selected_item&lt;0)
                wprintw(messagebar,"You haven't selected any item.");
            else
                wprintw(messagebar,
                  "You have selected menu item %d.",selected_item+1);
            touchwin(stdscr);
            refresh();
        }
    } while (key!=ESCAPE);

    delwin(menubar);
    delwin(messagebar);
    endwin();
    return 0;
}
</screen>
</para>
</appendix>
</article>
