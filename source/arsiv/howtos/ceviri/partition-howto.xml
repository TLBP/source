<?xml version="1.0" encoding="UTF-8"?>
<!-- ********************************************************************
     $Id:partition-howto.xml,v 1.20 2005/10/29 09:25:04 nilgun Exp $
     ******************************************************************** -->
<article xml:id="partition-howto" lang="tr">
<info>
<title>Linux Disk Bölümleme NASIL</title>
    <author><firstname>Anthony Lissot</firstname></author>
    <author><firstname>Kristian Koehntopp</firstname></author>
    <author role="translator">
     <personname><firstname>Oğuz Yarımtepe</firstname>
    </author>

    <revhistory><title>Bu çevirinin sürüm bilgileri:</title>
      <revision>
        <revnumber>1.2</revnumber>
        <date>Nisan 2006</date>
        <authorinitials>NBB</authorinitials>
        <revremark>Çevirinin lisansı GPL yapıldı.</revremark>
      </revision>
      <revision>
        <revnumber>1.1</revnumber>
        <date>Ocak 2006</date>
        <authorinitials>OY</authorinitials>
        <revremark>Güncelleme</revremark>
      </revision>
      <revision>
        <revnumber>1.0</revnumber>
        <date>Ekim 2005</date>
        <authorinitials>oy</authorinitials>
        <revremark>İlk çeviri</revremark>
      </revision>
    </revhistory>
    <revhistory><title>Özgün belgenin sürüm bilgileri:</title>
    <revision>
      <revnumber>3.5</revnumber>
      <date>26 Aralık 2005</date>
      <revremark>
Sayfa sıralaması düzenlendi. Takas alanı ayarlanamasıyla ilgili sayfa eklendi. Disk bölümleri etiketleriyle ilgili sayfa eklendi. 4. bölümdeki en büyük takas alnıyla ilgili bilgi güncellendi. ext2/3 dosya sistemleri oluşturma adımları eklendi. Richard Calmbach tarafından bildirilen hatalı bağlar düzeltildi. XML sürüm hazırlandı.
      </revremark>
      </revision><revision>
        <revnumber>3.4.4</revnumber>
        <date>08 Mart 2004</date>
        <revremark>HTML sürüm, XML sürümden üretildi. Lilo yerleştirilmesi ve takas alanı boyu konuları güncellendi.
        </revremark>
      </revision><revision>
        <revnumber>3.3</revnumber>
        <date>04 Nisan 2003</date>
        <revremark>HTML sürüm SGML sürümden üretildi.
        </revremark>
      </revision>
      <revision>
        <revnumber>3.3</revnumber>
        <date>10 Temmuz 2001</date>
        <revremark>6. Bölüm'deki silindir numaralarının hesaplanması düzeltildi.
        </revremark>
      </revision>
      <revision>
        <revnumber>3.2</revnumber>
        <date>1 Eylül 2000</date>
        <revremark>2 Ekim 2000'de Dan Scott sgml sürümünü hazırladı. Giriş kısmı yeniden yazıldı. Mantıksal Aygıtlardaki aygıt isimleri kısmı yeniden yazıldı. Bölüm Türleri yeniden organize edildi. Bölümleme Gereksinimleri düzenlendi. Silinmiş bir bölüm tablosunun kurtarılması kısmı eklendi.
        </revremark>
      </revision>
      <revision>
        <revnumber>3.1</revnumber>
        <date>12 Haziran 2000</date>
        <revremark>Bölümleme Gereksinimlerindeki takas boyu sınırlaması düzeltildi, Giriş kısmındaki pek çok bağlantı güncellendi, fdisk ile Bölümleme Nasıl kısmına gönderilen örnek eklendi, Bölümleme Gereksinimleri kısmına dosya sistemi konusu eklendi.
        </revremark>
      </revision>
      <revision>
        <revnumber>3.0</revnumber>
        <date>1 Mayıs 2000</date>
        <revremark>Kristian Koehntopp tarafından yazılan "Linux Disk Bölümleme NASIL" (Linux Partition HOWTO) belgesine dayanılarak Tony Harris tarafından yazılmış ilk gözden geçirme..
        </revremark>
      </revision>
      <revision>
        <revnumber>2.4</revnumber>
        <date>3 Kasım 1997</date>
        <revremark>Kristian Koehntopp tarafından yapılan son gözden geçirme.
        </revremark>
      </revision>
    </revhistory>

<copyright><year>2000-2004</year><holder>Anthony Lissot ve Kristian Koehntopp - Özgün belge</holder></copyright> 
<copyright><year>2005</year><holder>Oğuz Yarımtepe - Türkçe çeviri</holder></copyright>
<abstract><para>
Bu küçük Linux NASIL belgesi, IDE ve SCSI disklerde bölümlemenin nasıl planlandığını ve yapıldığını öğretmektedir. Bölümleme terimlerini irdelemekte, büyüklük ve yer konularını ele almaktadır. Bölümleme tabloları oluştururken ve kurtarırken fdisk bölümleme uygulamasının kullanımı da ele alınmıştır.
</para><para>
Bu belgenin en güncel sürümünü <link xlink:href="http://lissot.net/partition"/> adresinde bulabilirsiniz.
</para></abstract>
<legalnotice><title>Yasal Açıklamalar</title><para>
Bu belgenin çevirisinin, <emphasis>Linux Disk Bölümleme NASIL</emphasis> 1.2 sürümünün <emphasis role="bold">telif hakkı © 2005 <emphasis>Oğuz Yarımtepe</emphasis>'ye </emphasis>aittir.&notice.gpl;
  </para>&notice.disc;
</legalnotice>

</info>

<sect1 xml:id="partition-howto-intro"><title>Giriş</title>
  <sect2 xml:id="partition-howto-explanation"><title>Disk bölümü nedir?</title><para>
Disk bölümleme, tek bir diski mantıksal pek çok sürücüye bölmek için kullanılan bir araçtır. Bir disk bölümü, bağımsız bir disk gibi ele alınan, bitişik blok kümeleridir. Bölümleme tablosu (bu NASIL belgesinin oluşturulma sebebidir) disk bölümleriyle fiziksel disk alanlarını ilişkilendirilen bir dizindir.
    </para><para>
Neden birden çok disk bölümümüz olur?
    </para><itemizedlist>
    <listitem><para>
Verilerinizi diskin belirli bir bölgesiyle sınırlamış (encapsulate) olursunuz. Dosya sistemi ayrı bir disk bölümü üzerindeyse, bir kaza durumunda sadece bazı verilerinizi kaybedersiniz.
    </para></listitem><listitem><para>
Disk alanından beklenen verimini arttırır. Disk bölümlerini, kullanımınıza göre,  değişen blok boyutlarına göre biçimlendirebilirsiniz. Eğer verileriniz küçük boyuttaki (1k'dan daha az) çok sayıda dosyadan oluşuyorsa ve de disk bölümünüz 4k'lık bloklar kullanıyorsa, her dosya için 3k boşa harcıyosunuzdur. Genelde, her dosya için ortamala olarak bir bloğun yarısını boşa harcarsınız, bundan dolayı eğer pek çok dosyanız varsa blok büyüklüğü ile ortalama dosya büyüklüğünü uyuşturmak çok önemlidir.
    </para></listitem><listitem><para>
Veri büyümesini önler. Denetimden çıkmış süreçler veya çılgın kullanıcılar, işletim sisteminin kaydını tuttuğu işlemler için artık yer kalmayacak şekilde çok fazla disk alanı harcayabilir. Bu bir felakete dönüşebilir. Disk alanını ayırararak, ayrılan disk alanı tükense dahi buradaki işlerin işletim sistemini etkilemeden öleceğini garantilemiş olursunuz.
    </para></listitem></itemizedlist>
  </sect2>

  <sect2><title>Diğer Disk Bölümleme Yazılımları</title>
  <para><itemizedlist><listitem>
<command>sfdisk</command>: fdisk'in komut satırı sürümü.
  </listitem><listitem>
<command>cfdisk</command>: fdisk'in konsoldaki grafik tabanlı (curses-based) sürümü.
  </listitem><listitem>
<link xlink:href="http://www.gnu.org/software/parted/parted.html"><command>parted</command></link>: GNU disk bölümleme düzenleyicisi.
  </listitem><listitem>
<link xlink:href="http://www.powerquest.com/partitionmagic/index.html"><productname>Partition Magic</productname></link>: Verileri yok etmeden disk bölümlerini dönüştüren, birleştiren, yeniden boyutlandıran ve oluşturan ticari bir uygulama.
  </listitem><listitem>
<link xlink:href="http://www.linux-mandrake.com/diskdrake"><productname>Disk Drake</productname></link>: Disk bölümlerini silmek, yeniden boyutlandırmak ve oluşturmak için bir Perl/Gtk yazılımı.
  </listitem></itemizedlist></para>
  </sect2><sect2 xml:id="partition-howto-howtos"><title>İlgili NASIL'lar</title>
<para><table frame="all">
<title>İlgili NASIL'lar</title>
<tgroup cols="3" colsep="1" rowsep="1">
<colspec colwidth=".35" />
<colspec colwidth=".25" />
<colspec colwidth=".4" />
<thead>
<row>
  <entry>Başlık</entry>
  <entry>Yazar</entry>
  <entry>Açıklama</entry>
</row>
</thead>
<tbody>
<row><entry>
<link xlink:href="http://www.tldp.org/HOWTO/Install-Strategies">İkili önyükleyici yükleme yöntemleri</link> (Dual boot install strategies)
  </entry><entry>
Gjoen Stein
  </entry><entry>
Dosya sisteminin farklı bölümleri için farklı boyut büyüklükleri ve hız gereksinimlerine nasıl karar vermelidir?
  </entry></row>
<row><entry>
<link xlink:href="http://www.nyx.net/~sgjoen/disk.html">Linux Çoklu Disk Ayarlama</link> (Linux Multiple Disk System Tuning)
  </entry><entry>Gjoen Stein 
  </entry><entry>
Dosya sisteminin farklı kısımları için değişik hız ve boyut gereksinimleri nasıl değerlendirilmelidir.
   </entry></row>
<row><entry>
<link xlink:href="http://metalab.unc.edu/mdw/HOWTO/Large-Disk-HOWTO.html">Büyük Linux Diski</link> (Linux Large Disk)
  </entry><entry>Andries Brouwe
  </entry><entry>
1024 silindirden daha fazlasına sahip disklerin tanıtımı ve görüşler.
   </entry></row>
<row><entry>
<link xlink:href="http://metalab.unc.edu/mdw/HOWTO/mini/Quota.html">Linux Kota</link> (Linux Quota)
  </entry><entry>Ralf van Dooren
  </entry><entry>
Her kullanıcı için disk alanı kullanımını sınırlamayla ilgili ilk öğretiler.
   </entry></row>
<row><entry>
<link xlink:href="http://www.linuxdocs.org/HOWTOs/mini/Partition-Rescue.html">Disk Bölümü Kurtarma küçük-NASIL Belgesi</link>
  </entry><entry>Jean-Daniel Dodin 
  </entry><entry>
Bir Windows yüklenmesinden sonra silinen Linux disk bölümleri, verileri içeren kısım gözükmüyorsa, nasıl kurtarılır.
   </entry></row>
<row><entry>
<link xlink:href="http://www.tldp.org/HOWTO/ADSM-Backup.html">Linux ADSM Yedekleme</link> (Linux ADSM Backup)
  </entry><entry>Thomas Koenig 
  </entry><entry>
Linux'u bir IBM ADSM yedekleme ortamına uyarlamak için gerekli açıklamalar.
   </entry></row>
<row><entry>
<link xlink:href="http://www.ibiblio.org/pub/Linux/docs/HOWTO/other-formats/html_single/Backup-With-MSDOS.html">MSDOS ile Linux Yedekleme</link> (Linux Backup with MSDOS)
  </entry><entry>Christopher Neufeld 
  </entry><entry>
MSDOS kaynaklı Linux yedeklemeleriyle ilgili açıklamalar.
   </entry></row>
<row><entry>Linux NASIL Listesi (Linux HOWTO Index)
  </entry><entry>Tim Bynum
  </entry><entry>
Bir NASIL belgesi yazma ve göndermenin adımları
   </entry></row>
</tbody>
</tgroup>
</table>
</para>
  </sect2><sect2><title>Sistemdeki ek kaynaklar</title>
    <para><itemizedlist>
      <listitem><para>
<filename>/usr/src/linux/Documentation</filename>
     </para><para><itemizedlist>
        <listitem>
<filename>/usr/src/linux/Documentation/ide.txt</filename>: IDE sürücülerinizle ilgili bilgi
        </listitem><listitem>
<filename>/usr/src/linux/Documentation/scsi.txt</filename>:  SCSI sürücülerinizle ilgili bilgi
        </listitem>
    </itemizedlist></para></listitem>
   </itemizedlist></para>
  </sect2>
</sect1>

<sect1 xml:id="partition-howto-devices"><title>Aygıtlar</title><para>
Bu bölümdeki açıklamaları anlamak için, Linux'un disk bölümlerinin gösteriminde kullandığı özel sınıflandırmayı bilmeniz gerekir.
  </para><para>
Linux'ta, disk bölümleri aygıt dosyaları olarak temsil edilir. Bunlar <filename>/dev</filename> altına yerleştirilmiş sözde dosyalardır. Birkaçı şu şekildedir:
  </para><para>
<screen>
brw-rw----    1 root     disk       3,   0 May  5  1998 hda
brw-rw----    1 root     disk       8,   0 May  5  1998 sda
crw-------    1 root     tty        4,  64 May  5  1998 ttyS0
</screen>
  </para><para>
Bir aygıt dosyası c (karakter aygıtı anlamında, tampon bellek kullanmayan aygıtlar) veya b (blok aygıt anlamında, tampon bellek kullanan aygıtlar) türünde bir dosyadır. Linux'ta, tüm diskler blok aygıtları olarak temsil edilir.
  </para>
  <sect2 xml:id="partition-howto-names"><title>Aygıt adları</title>
    <sect3 xml:id="partition-howto-NamingConvention"><title>İsimlendirme Kuralları</title>
    <para>
Uzlaşımsal olarak, IDE sürücülere <literal>/dev/hda</literal>'dan başlayıp <literal>/dev/hdd</literal>'ye giden aygıt isimleri verilir. <emphasis>A</emphasis> olarak geçen disk (<literal>/dev/hda</literal>) ilk disk sürücüsü ve <emphasis>C</emphasis> olarak geçense (<literal>/dev/hdc</literal>) üçüncü disk sürücüsüdür.
    </para><para>
<table frame="all">
  <title>IDE denetleyici isimlendirme kuralları</title>
  <tgroup cols="3" align="center" colsep="1" rowsep="1">
  <colspec colname="sürücü adı"/>
  <colspec colname="sürücü denetleyicisi"/>
  <colspec colname="sürücü numarası"/>
  <tbody>
    <row>
      <entry>sürücü adı</entry><entry>sürücü denetleyici</entry><entry>sürücü numarası</entry>
    </row>
    <row>
      <entry>/dev/hda</entry><entry>1</entry><entry>1</entry>
    </row>
    <row>
      <entry>/dev/hdb</entry><entry>1</entry><entry>2</entry>
    </row>
    <row>
      <entry>/dev/hdc</entry><entry>2</entry><entry>1</entry>
    </row>
    <row>
      <entry>/dev/hdd</entry><entry>2</entry><entry>2</entry>
    </row>
   </tbody>
   </tgroup>
</table>
  </para><para>
Tipik bir kişisel bilgisayarda, her birine iki sürücü bağlanabilen iki IDE denetleyici vardır. Örneğin, <filename>/dev/hda</filename> ilk IDE denetleyicideki ilk sürücüdür (master) ve <filename>/dev/hdd</filename> ikinci IDE denetleyicideki ikinci sürücüdür (slave - bilgisayardaki dördüncü sürücü).
  </para><para>
Bu aygıtlara doğrudan yazabilirsiniz (<command>cat</command> veya <command>dd</command> kullanarak). Bununla birlikte, bu aygıtlar ilk bloktan başlayarak tüm diski temsil ettiklerinden, yanlışlıkla, sürücünün kullanım dışı kalmasına sebep olabilcek, MBR (master boot record) ve bölümleme tablosunun üzerine yazabilirsiniz.
  </para><para>
<table frame="all">
  <title>bölüm adları</title>
  <tgroup cols="5" align="center" colsep="1" rowsep="1">
  <colspec colname="sürücü adı"/>
  <colspec colname="sürücü denetleyicisi"/>
  <colspec colname="sürücü numarası"/>
  <colspec colname="bölüm türü"/>
  <colspec colname="bölüm numarası"/>

  <tbody>
    <row>
      <entry>sürücü adı</entry>
      <entry>sürücü denetleyici</entry>
      <entry>sürücü numarası</entry>
      <entry>bölüm türü</entry>
      <entry>bölüm numarası</entry>
    </row>
    <row>
      <entry>/dev/hda1</entry>
      <entry>1</entry>
      <entry>1</entry>
      <entry>birincil</entry>
      <entry>1</entry>
    </row>
    <row>
      <entry>/dev/hda2</entry>
      <entry>1</entry>
      <entry>1</entry>
      <entry>birincil</entry>
      <entry>2</entry>
    </row>
    <row>
      <entry>/dev/hda3</entry>
      <entry>1</entry>
      <entry>1</entry>
      <entry>birincil</entry>
      <entry>3</entry>
    </row>
    <row>
      <entry>/dev/hda4</entry>
      <entry>1</entry>
      <entry>1</entry>
      <entry>takas</entry>
      <entry>NA</entry>
    </row>
    <row>
      <entry>/dev/hdb1</entry>
      <entry>1</entry>
      <entry>2</entry>
      <entry>birincil</entry>
      <entry>1</entry>
    </row>
    <row>
      <entry>/dev/hdb2</entry>
      <entry>1</entry>
      <entry>2</entry>
      <entry>birincil</entry>
      <entry>2</entry>
    </row>
    <row>
      <entry>/dev/hdb3</entry>
      <entry>1</entry>
      <entry>2</entry>
      <entry>birincil</entry>
      <entry>3</entry>
    </row>
    <row>
      <entry>/dev/hdb4</entry>
      <entry>1</entry>
      <entry>2</entry>
      <entry>birincil</entry>
      <entry>4</entry>
    </row>
   </tbody>
   </tgroup>
</table>
  </para><para>
Bir sürücü bir kere bölümlendirildi mi, bölümler isimlerin sonundaki numaralar olarak temsil edilir. Örneğin, ikinci disk sürücüsündeki ikinci disk bölümü  <filename>/dev/hdb2</filename> olacaktır. Birincil bölüm türü, 3. Bölümdeki <xref linkend="partition-howto-primary" /> kısmına kadar açıklanmayacak olsa da yukarıda listelenmiştir.
  </para><para>
<table frame="all">
  <title>SCSI Sürücüler</title>
  <tgroup cols="5" align="center" colsep="1" rowsep="1">
  <colspec colname="sürücü adı"/>
  <colspec colname="sürücü denetleyici"/>
  <colspec colname="sürücü numarası"/>
  <colspec colname="bölüm türü"/>
  <colspec colname="bölüm numarası"/>
  <tbody>
    <row>
      <entry>sürücü adı</entry>
      <entry>sürücü denetleyici</entry>
      <entry>sürücü numarası</entry>
      <entry>bölüm türü</entry>
      <entry>bölüm numarası</entry>
    </row><row>
      <entry>/dev/sda1</entry>
      <entry>1</entry>
      <entry>6</entry>
      <entry>birincil</entry>
      <entry>1</entry>
    </row><row>
      <entry>/dev/sda2</entry>
      <entry>1</entry>
      <entry>6</entry>
      <entry>birincil</entry>
      <entry>2</entry>
    </row><row>
      <entry>/dev/sda3</entry>
      <entry>1</entry>
      <entry>6</entry>
      <entry>birincil</entry>
      <entry>3</entry>
    </row>
   </tbody>
   </tgroup>
</table>
  </para><para>
SCSI sürücüler de benzer bir modeli takip ederler; 'hd' yerine 'sd' ile gösterilirler. Bundan dolayı da ikinci SCSI diskin ilk bölümü <filename>/dev/sdb1</filename> olacaktır. Yukarıdaki tabloda, sürücü numaraları rastgele 6 seçilerek SCSI ID numaralarının aygıt numaralarıyla bire bir uyuşmadığı gösterilmiştir.
    </para>
  </sect3><sect3><title>İsim Atama</title><para>
(Sun) Solaris ve (SGI) IRIX altında, SCSI sürücülere verilen aygıt isimlerinin onları nereye taktığınızla ilgisi vardır. Linux altında, sadece hayıflanma ve diş gıcırtıları vardır.
    </para><para><emphasis>Önce</emphasis></para><para>
<screen>
SCSI ID #2        SCSI ID #5       SCSI ID #7        SCSI ID #8
/dev/sda          /dev/sdb         /dev/sdc          /dev/sdd
</screen>
    </para><para><emphasis>Sonra</emphasis></para><para>
<screen>
SCSI ID #2                         SCSI ID #7        SCSI ID #8
/dev/sda                           /dev/sdb          /dev/sdc
</screen>
  </para><para>
SCSI sürücüler 1'den başlayıp 15'e kadar uzanan ve ID olarak kullanılan sayılar kullanır. Düşük SCSI ID numaralılara alfabetik sıradaki önce gelen harfler atanır. Örneğin eğer 2 ve 5 numaralı iki sürücünüz varsa, 2 numaralı sürücü <filename>/dev/sda</filename> ve 5 numaralı sürücü de <filename>/dev/sdb</filename> olacaktır. Eğer herhangi biri sistemden kaldırılırsa bu sürücülerden yüksek numaralı sürücülerin sistemin yeniden başlatılmasında yeniden isimlendirilecektir.
  </para><para>
Eğer Linux makinanızda iki tane SCSI denetleyici varsa, <filename>/bin/dmesg</filename> çıktısına bakarak her bir sürücüye hangi isim verildiğini görmek isteyebilirsiniz. Eğer bir veya iki denetleyiciyi çıkarırsanız, geri kalanların hepsi sürücü adlarını yeniden isimlendireceklerdir. Grrr...
  </para><para>
İki tane alternatif çözüm vardır; her ikisi de bir yazılım kullanarak her bir disk bölümüne bir etiket vermeyi içermektedir (bknz. <xref linkend="partition-howto-labels" />). Verilen etiket kalıcıdır ve aygıt fiziksel olarak kaldırılırsa da erişilebilir. Daha sonra disk bölümüne doğrudan veya dolaylı olarak bu etiket ile erişebilirsiniz.
    </para>
  </sect3><sect3><title>Mantıksal Disk Bölümleri</title><para>
<table frame="all">
  <title>Mantıksal Disk Bölümleri</title>
  <tgroup cols="5" align="center" colsep="1" rowsep="1">
  <colspec colname="sürücü adı"/>
  <colspec colname="sürücü denetleyici"/>
  <colspec colname="sürücü numarası"/>
  <colspec colname="bölüm türü"/>
  <colspec colname="bölüm numarası"/>

  <tbody>
    <row>
      <entry>sürücü adı</entry>
      <entry>sürücü denetleyici</entry>
      <entry>sürücü numarası</entry>
      <entry>bölüm türü</entry>
      <entry>bölüm numarası</entry>
    </row>
    <row>
      <entry>/dev/hdb1</entry>
      <entry>1</entry>
      <entry>2</entry>
      <entry>birincil</entry>
      <entry>1</entry>
    </row>
    <row>
      <entry>/dev/hdb2</entry>
      <entry>1</entry>
      <entry>2</entry>
      <entry>ek</entry>
      <entry>yok</entry>
    </row>
    <row>
      <entry>/dev/hdb5</entry>
      <entry>1</entry>
      <entry>2</entry>
      <entry>mantıksal</entry>
      <entry>2</entry>
    </row>
    <row>
      <entry>/dev/hdb6</entry>
      <entry>1</entry>
      <entry>2</entry>
      <entry>mantıksal</entry>
      <entry>3</entry>
    </row>
   </tbody>
   </tgroup>
</table>
    </para><para>
Yukarıdaki tablo isim atamalarında gizemli bir atlamayı göstermektedir. Bu, daha sonra <xref linkend="partition-howto-mixed"/> bölümünde anlatılacak olan ve daima 5 ile başlayan <xref linkend="partition-howto-logical"/> kullanımından kaynaklanır.
    </para><para>
Linux disk aygıtlarını idare edebilmeniz için tüm bilmeniz gerekenler bunlardır. Bütünlüğün sağlanması için, aşağıdaki  Kristian'ın aygıt numaralarıyla ilgili açıklamalarına bakınız.
    </para>
  </sect3></sect2>
  <sect2 xml:id="partition-howto-numbers"><title>Aygıt numaraları</title><!--Kristian 3 Nov 97-->
    <para>
Bir aygıt dosyasıyla ilgili tek önemli nokta, dosya boyu yerine ana ve alt aygıt numaralarının gösterilmesidir.
    </para><para>
<screen>$ <command>ls -l /dev/hda</command>
</screen>
    </para><para>
<table frame="all">
  <title>Aygıt dosyalarının öznitelikleri</title>
  <tgroup cols="8" align="center" colsep="1" rowsep="1">
  <colspec colname="c1" />
  <colspec colname="c2" />
  <colspec colname="c3" />
  <colspec colname="c4" />
  <colspec colname="c5" />
  <colspec colname="c6" />
  <colspec colname="c7" />
  <colspec colname="c8" />
  <tbody>
    <row>
      <entry>brw-rw----</entry>
      <entry>1</entry>
      <entry>root</entry>
      <entry>disk</entry>
      <entry>3,</entry>
      <entry>0</entry>
      <entry>Temmuz 18  1994</entry>
      <entry>/dev/hda</entry>
    </row>
    <row>
      <entry>izinler</entry>
      <entry></entry>
      <entry>sahibi</entry>
      <entry>grubu</entry>
      <entry>ana aygıt numarası</entry>
      <entry>alt aygıt numarası</entry>
      <entry>tarih</entry>
      <entry>aygıt adı</entry>
    </row>
   </tbody>
   </tgroup>
</table>
    </para><para>
Bir aygıt dosyasına erişirken, ana aygıt numarası giriş/çıkış işlemlerinde hangi aygıt sürücüsünün çağrılacığını belirtmek için kullanılır. Bu çağrı bağımsız değişken olarak alt aygıt numarasının alınmasıyla gerçeklenir ve bu alt aygıt numarasının nasıl ifade edildiği tamamen sürücüye bağlıdır. Sürücü belgelendirmesi genelde bu alt aygıt numarasının nasıl kullanıldığını anlatmaktadır. IDE diskler için bu belgelendirme <link xlink:href="file:/usr/src/linux/Documentation/ide.txt"/> altındadır. SCSI diskler için ise <link xlink:href="file:/usr/src/linux/Documentation/scsi.txt"/> olduğu düşünülebilir ama orada değildir. Emin olmak için sürücü kaynak koduna bakılmalıdır (<link xlink:href="file:/usr/src/linux/driver/scsi/sd.c"/>:184-196). Ne şansı ki, <link xlink:href="file:/usr/src/linux/Documentation/devices.txt"/> içerisinde  Peter Anvin'in aygıt numara ve isimleri listesi vardır; IDE'ler için 3, 22, 33, 34 ana aygıt numaralarına, SCSI aygıtlar için ise 8 ana aygıt numarasına bakınız. Ana ve alt aygıt numaraların her biri birer bayt yer kaplar, bu da her disk bölümündeki disk bölümü sayısının neden sınırlı olduğunu açıklamaktadır.
    </para>
  </sect2>
</sect1>

<sect1 xml:id="partition-howto-partiton-types">
 <title>Disk Bölümü Türleri</title>
 <sect2 xml:id="partition-howto-types"><title>Disk Bölümü Türleri</title><para>
<!-- Tony 1 Sept 00-->
Bir disk bölümü belli bir dosya sistemine sahip olması için etiketlendirilir (disk etiketleri ile karıştırılmamalıdır. bknz. <xref linkend="partition-howto-labels" />). Böylesi bir dosya sistemi standart linux ext2 dosya sistemi veya linux takas alanı va hatta (Microsoft) NTFS veya (Sun) UFS gibi yabancı dosya sistemleri de olabilir. Her bir disk bölümünün türüyle ilişkilendirilmiş sayısal bir kod vardır. Örneğin, ext2 için kod <literal>0x83</literal> ve linux takas alanı için kod <literal>0x82</literal>'dir. Disk bölümü türlerini ve karşılık gelen kodlarını görmek için <userinput><command>/sbin/sfdisk</command> -T </userinput> komutunu çalıştırın.
    </para>
  </sect2><sect2><title>Yabancı Disk Bölümü Türleri</title><para>
Disk bölümü türü numaraları rasgele seçilmiştir (ne olmaları gerektiğini anlayamazsınız) ve ele alınan işletim sistemine özel olarak verilmişlerdir. Bu yüzden, aynı diskte iki işletim sistemi kullanıyorsanız, aynı kod farklı iki disk türünü belirlemek için kullanılabilir.
    </para><para>
<!-- Kristian 3 Nov 97-->
OS/2 ve Windows NT'nin NTFS'i disk bölümlerini <literal>0x07</literal> ile işaretler. MS-DOS, değişik çeşitlilikteki FAT dosya sistemi için değişik kodlar tahsis etmiştir: <literal>0x01</literal>, <literal>0x04</literal> ve <literal>0x06</literal> bilinenleridir. DR-DOS, korumalı FAT disk bölümlerini belirtmek için, Linux/Minix ile o zamanlarda fikir ayrılığı oluşturan <literal>0x81</literal>'i kullanırdı, fakat artık ne Linux/Minix ne de DR-DOS geniş çapta kullanılmaktadır.
    </para>
  </sect2><sect2 xml:id="partition-howto-primary"><title>Birincil Disk Bölümleri</title><para>
Intel-tabanlı bir sistemde disk bölümü sayısı, işin başında sınırlandırılmıştır: Asıl disk bölümü tablosu önyükleyici bölümünün bir parçası olarak yüklenir ve de sadece 4 disk bölümü girişi için yer ayrılmıştır. Bu disk bölümleri birincil disk bölümleri olarak isimlendirilir.
    </para>
  </sect2><sect2 xml:id="partition-howto-logical">
    <title>Mantıksal Disk Bölümleri</title>
<!--Tony 1 Sep 00-->
    <para>
Diskin birincil bölümlerinden birisi alt bölümlere ayrılabilir. Bunlara mantıksal disk bölümleri denir. Bu durum da bize verimli bir şekilde, dört disk bölümü sınırını aşmamızı sağlar.
    </para><para>
Mantıksal disk bölümlerini barındıran birincil disk bölümüne ek disk bölümü denir ve kendi dosya sistemi türü (<literal>0x05</literal>) vardır. Birincil disk bölümlerinin tersine, mantıksal disk bölümleri birbirini takip eder olmalıdır. Her bir mantıksal disk bölümü, mantıksal disk bölümü sayısının sınırsız olacağı sonucunu ifade eden, bir sonraki mantıksal disk bölümüne bir gösterici içerir. Yine de, Linux, disk üzerinde olası disk bölümü sayısında belli bir sınır kabul ettirmiştir, bu da sonuç olarak mantıksal disk bölümü sayısını sınırlamaktadır. Bu sayı SCSI diskleri için 15 disk bölümü iken IDE diskler için 63'tür.
    </para>
  </sect2><sect2 xml:id="partition-howto-swap-partitions">
    <title>Takas Bölümleri</title><para>
Bilgisayarınızda çalışan her bir süreç RAM'de bir takım blokları kullanmaktadır. Bu bloklara sayfa adı verilir. Bellek içerisindeki, işlemci tarafından çok kısa süreler içerisinde kullanılacak olan sayfalara çalışma kümesi denir. Linux belleğe yapılan bu erişimleri tahmin etmeye çalışarak (en son kullanılan sayfaların yakın zamanda tekrar kullanılacağını varsayarak) eğer mümkünse bu sayfaların RAM'de tutulmasını sağlar.
    </para><para>
Eğer makinanızda çalışan pek çok süreç varsa, çekirdek, sayfaları diske yazarak RAM'in boşaltılmasını sağlayacaktır. İşte takas alanı bu durumda devreye girer. Verimli bir şekilde var olan erişilebilir bellek alanınızı arttırır. Yine de, RAM'den okuyup RAM'e yazmaya kıyasla disk Giriş/Çıkışları çok yavaştır. Bunu ilave bir bellek olarak değil de acil durumlarda kullanılan bir bellek olarak düşünün.
    </para><para>
Eğer, çekirdeğin bir başka süreç için çalışan bir sürecin sayfalarını kaldırması anlamına gelen, bellek sıkıntısı varsa, makinanız artık dökülmeye başlamış demektir. Okuyuculardan bazıları istemeyerek bu durumla karşılaşmış olabilir: disk çılgınlar gibi çalışıyor ama bilgisayar kullanılamayacak kadar yavaş. Takas alanı sahip olmanız gereken bir alandır, fakat RAM'in yerine geçecek bir alan değildir. İhtiyacınız olan takas alanının boyuyla ilgili olarak <xref linkend="partition-howto-SwapSize"/> bölümündeki açıklamalara bakın.
    </para>
  </sect2>
</sect1>

<sect1 xml:id="partition-howto-requirements">
  <title>Bölümlendirme gereksinimleri</title>
  <sect2 xml:id="partition-howto-number">
    <title>Hangi Disk Bölümlerine İhtiyacım Var?</title>
<!-- Tony, 1 May 00-->
    <para>
Önyükleyici Sürücüsü: Eğer işletim sisteminizi yeni bölümleyeceğiniz diskten açacaksanız, sahip olmanız gereken disk bölümleri şunlardır:
    </para><para><itemizedlist>
<listitem>Bir birincil disk bölümü</listitem>
<listitem>Bir veya daha fazla sayıda takas alanı</listitem>
<listitem>Sıfır veya daha fazla sayıda birincil veya mantıksal disk bölümü</listitem>
</itemizedlist>
    </para><para>
Başka bir diskten açacaksanız:
    </para><para><itemizedlist>
  <listitem>Bir veya daha fazla sayıda birincil veya mantıksal disk bölümü</listitem>
  <listitem>Sıfır veya daha fazla sayıda takas alanı</listitem>
  </itemizedlist>
    </para>
  </sect2><sect2><title>Durum Analizi</title>
    <variablelist><varlistentry xml:id="partition-howto-boot">
      <term>Önyükleyici Disk Bölümü</term>
      <listitem><para>
Önyükleyici disk bölümünüzün mantıksal değil birincil disk bölümü olması gerekir. Bu durum herhangi bir felaket durumunda kurtarmayı sağlamaktadır, fakat teknik olarak gerekli değildir. <literal>0x83</literal> "Linux native" dosya türünde olmalıdır. Eğer 21-3 sürümünden önceki bir <link xlink:href="http://tldp.org/HOWTO/LILO.html"><command>lilo</command></link> kullanıyorsanız (örn., 1990lardan kalma), önyükleyici bölümünüz diskin ilk 1024 silindiri içerinde yer almalıdır. (Tipik olarak, önyükleyicinin tek ihtiyacı çekirdek görüntüsünü içermesidir.)
  </para><para>
Eğer birden fazla önyükleyici disk bölümünüz varsa (diğer işletim sistemlerinden olabilir), hepsini ilk 1024 silindir içerisinde tutun (<emphasis>Tüm</emphasis> DOS bölümleri ilk 1024 silindir içerisinde olmalıdır). Eğer modern bir lilo sürümü veya çekirdeğinizi yüklemeye yarayan başka araçlar kullanıyorsanız (örneğin, bir önyükleyici disket veya MS-DOS tabanlı çalışan <command>LOADLIN.EXE</command> Linux yükleyicisi), disk bölümü herhangi bir yerde olabilir. Ayrıntılı bilgi için <link xlink:href="http://www.tldp.org/HOWTO/Large-Disk-HOWTO.html">Büyük-disk (Large-disk) NASIL</link> belgesine bakabilirsiniz.
    </para></listitem></varlistentry><varlistentry xml:id="partition-howto-swap-definition">
      <term>Takas Bölümü</term>
      <listitem><para>
Dosyalara takas (bknz. <xref linkend="partition-howto-swapfiles" />) yapamadığınız sürece ayrılmış bir takas bölümüne ihtiyacınız olacaktır. Bu bölüm <literal>0x82</literal> "Linux swap" tipinde olmalıdır. Disk üzerinde herhangi bir yerde konumlandırılabilir (siz yine de yerleştirme notlarına bakınız: <xref linkend="partition-howto-SwapPlacement" />). Birincil veya mantıksal disk bölümlerinden herhangi biri takas alanı olarak kullanılabilir. Bir disk üzerinde birden fazla takas alanı olabilir. Toplam 8 tanesine (sürücüler içerisinde) izin verilmiştir. Aşağıdaki takas alanı boyu notlarına bakınız (<xref linkend="partition-howto-SwapSize" />).
    </para></listitem></varlistentry><varlistentry xml:id="partition-howto-logical-definition">
      <term>Mantıksal Disk Bölümleri</term>
      <listitem><para>
Tek bir birincil disk bölümü mantıksal disk bölümleri içerecek şekilde (ek disk bölümü) kullanılmalıdır. Ek disk bölümü disk üzerinde herhangi bir yerde olabilir. Mantıksal disk bölümleri ardışık olmalıdır, fakat ek disk bölümünü doldurmaları gerekmemektedir.
    </para></listitem></varlistentry></variablelist>
  </sect2><sect2><title>Dosya Sistemleri</title>
<!-- Tony, 12 June 00-->
    <sect3 xml:id="partition-howto-filesystems">
      <title>Hangi dosya sistemleri kendi disk bölümlerine ihtiyaç duyar?</title>
      <para>
Linux dosya sisteminizdeki herşey aynı (tek bir) disk bölümü altına yerleştirilebilir. Fakat, belli dosya sistemlerinin büyümesini sınırlamak isteyeceğiniz durumlar vardır. Örneğin, eposta kuyruğunuz kök dosya sisteminizle aynı dizindeyse, disk bölümündeki kalan alanı doldurması durumunda bilgisayarınızın çalışması sekteye uğrayacaktır.
      </para><para><variablelist><varlistentry>
      <term><filename>/var</filename></term>
      <listitem><para>
Bu dosya sistemi ileti ve yazıcılar için kuyruk dizinlerini içermektedir. Buna ek olarak, hata kayıt dosyalarını da içerir. Eğer makinanız bir sunucuysa ve sürekli bir hata üretiyorsa, bu iletiler disk bölümünü doldurabilir. Sunucu bilgisayarların <filename>/var</filename> dosya sistemini kök <filename>/</filename> dosya sisteminin disk bölümünde değil farklı bir disk bölümünde bulundurmaları gerekmektedir.
      </para></listitem></varlistentry><varlistentry>
      <term><filename>/usr</filename></term>
      <listitem><para>
Bu kısım hemen her çalıştırılabilir ikiliğin bulunduğu yerdir. Ek olarak, çekirdek kaynak ağacı ve belgelerin çoğu burada bulunur.
      </para></listitem></varlistentry><varlistentry>
      <term><filename>/tmp</filename></term>
      <listitem><para>
Bazı yazılımlar geçici dosyalarını buraya yazar. Genellikle, oldukça küçüktürler. Yine de, hesaba dayalı, fen ve mühendislik uygulamaları gibi, oldukça yoğun işler çalıştırırsanız, yüzlerle ifade edilen megabaytlara kısa süre içerisinde ihtiyaç  duyulabilir. Bu durumda <filename>/tmp</filename>'yi kök <filename>/</filename> dosya sisteminin disk bölümünde değil farklı bir disk bölümünde tutun.
      </para></listitem></varlistentry><varlistentry>
      <term><filename>/home</filename></term>
      <listitem><para>
Burası kullanıcı ev dizinlerinin olduğu yerdir. Kullanıcılarınız için alan sınırlaması yapmazsanız,  kendi disk bölümünde olmalıdır.
      </para></listitem></varlistentry><varlistentry>
      <term><filename>/boot</filename></term>
      <listitem><para>
Burası çekirdek bellekeşlemlerinin bulunduğu yerdir. Eski sistemlerdeki yerleri için yukarılardaki açıklamalara bakınız.
      </para></listitem></varlistentry></variablelist></para>
    </sect3><sect3 xml:id="partition-howto-backups">
<title>Disk bölümleme ölçütü olarak dosya ömrü ve yedekleme sıklığı</title>
      <para>
Ext2 ile disk bölümleme kararları, yedekleme ihtiyaçlarına bağlı olarak ve dosyaların farklı yaşam sürelerinde disk üzerine <link linkend="partition-howto-fragmentation">saçılmalarından</link> kaçınacak şekilde verilir.
      </para><para>
Dosyaların birer ömrü vardır. Bir dosya oluşturulduktan sonra, sistemde belli bir süre kalacak ve daha sonra silinecektir. Dosya ömrü sistemin her yerinde farklılık gösterir ve kısmen dosyanın yoluna bağlıdır. Örneğin, <filename>/bin</filename>, <filename>/sbin</filename>, <filename>/usr/sbin</filename>, <filename>/usr/bin</filename> ve benzeri dizinler, aylar ve hatta daha uzun sürelerle ifade edilen oldukça uzun yaşam sürelerine sahiptir. <filename>/home</filename> dizini altındakiler ise haftalarla ifade edilen ömürlere sahiptir. <filename>/var</filename> altındaki dosyaların ise oldukça kısa yaşam süreleri vardır: <filename>/var/spool/news</filename> altındaki bir dosya bir kaç günden fazla kalmaz, <filename>/var/spool/lpd</filename> altındakilerinse ömürleri dakikalarla ölçülür.
      </para><para>
Yedekleme sözkonusu olduğunda, günlük yapılan yedeklemelerin kullanılan tekil yedekleme aygıtının kapasitesinden daha küçük olması faydalıdır. Günlük yedekleme, sistemin tümünde yapılmış bir yedekleme olabileceği gibi arttırımlı bir yedekleme de olabilir.
      </para><para>
Disk bölümü büyüklüklerinin bir yedekleme aygıtına sığacak şekilde  yeterince küçük olmasına karar verebilirsiniz (günlük yedeklemeyi seçersiniz). Her halükarda bir disk bölümü günlük yapılan yedeklemelerde (değişikliğe uğramış tüm dosyalar ile) tek bir yedekleme aygıtına sığabilmelidir (arttırımlı yedeklemeyi seçin ve yedekleme aygıtının haftalık/aylık olarak dolacağını umarak değiştirin - gözetimsiz bir işlem olası değildir).
      </para><para>
Yedekleme stratejiniz bu karara bağlıdır.
      </para><para>
Disk alırken veya planlarken, yedekleme için de bir miktar para ayırmayı unutmayın! Yedeklenmemiş bilginin değeri yoktur! Verilerin yeniden oluşturulması hemen herkes için yedeklenmesinden daha fazla maliyet gerektirmektedir!
      </para><para>
Yararlılık açısından farklı ömürlere sahip dosyaların farklı disk bölümlerinde bulundurulması faydalıdır. Bu şekilde "news" disk bölümündeki kısa ömürlü dosyalar çok güç saçılmaya uğrayabilir. Bunun <filename>/</filename> veya <filename>/home</filename> üzerindeki yararlılığa bir etkisi yoktur.
      </para>
    </sect3>
  </sect2><sect2><title>Takas Bölümleri</title>
<!-- Kristian 3 Nov 97-->
<!-- Tony 04 Apr 03 -->
    <sect3 xml:id="partition-howto-SwapSize">
      <title>Takas alanı ne kadar büyük olmalıdır?</title><para>
Genel kural RAM miktarınız kadar büyük olması şeklindedir.
      </para><para>
Fakat bu genel geçerli bir kural değildir. Programların çalışan kümelerinin oldukça büyük veya oldukça küçük olduğu hayali senaryolar oluşturmak mümkündür (bknz. <xref linkend="partition-howto-swap-partitions" />). Örneğin, çalışması sırasında rasgele erişim sağladığı geniş bir veri kümesine sahip olan bir simulasyon yazılımı yerel olarak çalışan yazılımının veri bloğundan bu kümeye her an işaretçiler barındırmayabilir. Bu durumda çalışan kümesi oldukça büyük olacaktır.
      </para><para>
Diğer taraftan aynı açılmış pekçok JPEG formatlı resmi içeren bir grafik yazılımının geniş bir veri bloğu olacaktır. Fakat aynı anda sadece tek resim üzerinde çalışılabilineceğinden resim üzerindeki işlemlerde belleğin yazılım tarafından kullanılan kısmının büyük kısmına erişilmez. Aynı durum pekçok penceresi düzenleme yazılımları için de gerçerlidir. Eğer bu yazılımlar iyi tasarlanmışlarsa oldukça büyük yerel referans değerlerine sahiptir. Bu durum da onların büyük takas alanları kullanma zorunluluğunu ortadan kaldırır, sistem üzerinde ölümcül etkiler yapmalarını önler. Aynı nedenden yazılımlarından hiç çıkmadan pekçok yazılım çalıştıran bir kullanıcı daha çok takas alanı isteyecektir.
      </para><para>
Sunucular masaüstü akranlarına göre daha fazla takas alanıyla ayarlanırlar  Verilmiş olan takas alanı işlemleri için yeterli olsa da sunucu olduça büyük sayfalamalar yapması gereken iş yükleriyle karşılaşabilir. Bazı sistem yöneticileri bu durumun sunucuyu çökeltmesine göz yumarlar. Bu durumlarda takas alanının boyu bellekten kat kat büyük olabilir.
      </para></sect3>

      <sect3 xml:id="max_swap_size">
      <title>Takas alanım ne kadar büyük <emphasis>olabilir?</emphasis></title><para>
Takas alanının büyüklüğü günümüzde mimariye bağlıdır.  i386, m68k, ARM ve PowerPC'ler için bu değer "resmi" olarak 2Gb'dir. Alpha makinalarda 128Gb, sparc işlemcilerde 1Gb ve sparc64 mimarilerinde 3Tb'tır. 2.6 çekirdekle çalışan bir opteron 16 Tb takas alanına yazabilir. Linux çekirdeğinin 2.1 ve önceki sürümlerinde sınır 129 Mb'dir. Takas alanı 128 MB'den daha büyük olabilri ama taşan kısım kullanılmaz. Çekirdeğin 2.1 ve önceki sürümleri için 128 MB'den daha büyük takas alanları kullanmak istiyorsanız birden fazla takas alanı oluşturmalısınız (en çok 9). 2.4 sürümden sonra 32 takas alanı oluşturabilmek mümkün hale gelmiştir. Takas alanı oluşturma detaylarına bakınız.<footnote><para>
<command>mkswap</command> kılavuz sayfasında belirtilmese de 2.4 sürüm çekirdek ile takas alanı sayısı her biri en büyük 64Gb olan 64 taneye kadar çıkmıştır. 2.6 çekirdek üzerinde çalışan 64 bitlik opteronda her biri 16 Tb olan 128 takas alanı oluşturmak mümkündür (Peter Chubb'a hesaplaması için teşekkürler).</para></footnote>
          </para>
        </sect3>

      <sect3 xml:id="partition-howto-SwapPlacement">
      <title>Takas alanımı nereye koymalıyım?</title>
      <para>
Kısa cevap herhangi bir yer şeklindedir. Yine de, mümkün olduğunca çok hız elde etme istiyorsanız, iki temel strateji vardır (daha fazla RAM almak yerine).
      </para><para><itemizedlist>
<listitem>Takas alanını farklı sürücülere parçalayın ya da az sıklıkla yazdığınız sürücü üzerinde bu parçalamayı yapın.</listitem>
<listitem>Her bir takas disk bölümünü dıştaki izlere yerleştirin.</listitem>
      </itemizedlist></para><para>
Gözönüne alınması gerekenler:
      </para><para><itemizedlist><listitem><para>
Eğer biri çok kafalı diğeri daha az disk kafalı olan iki diskiniz varsa ve diğer özellikler bakımından aynıysalar, çok disk kafası olan daha hızlı olacaktır. Farklı disk kafaları üzerinden veri okunması tamamen elektronik olduğundan daha hızlı olacaktır. Farklı izlerden veri okumak, kafanın hareketini gerektirdiğinden yavaştır.
      </para><para>
Takasın başka bir diske yazılması, disk kafasının tek bir sürücü üzerinde ileri geri hareketinden daha hızlı olacağı sonucu çıkmaktadır.
      </para></listitem><listitem><para>
<emphasis>Yerleşim</emphasis>: Eski diskler tüm izlerde aynı sayıda sektör içermektedir. Bu disklerle, takas alanını ortaya yerleştirmek, disk kafası rasgele hareket sırasında takas alanından geçeceğinden, en hızlı olacaktır.
      </para></listitem><listitem><para>
Daha yeni diskler ZBR (zone bit recording: bölge biti kaydı) kullanmaktadır. Dış izlerinde daha çok sektörleri barındırırlar. Sabit bir dönme hızında, içteki izlere göre bu daha büyük bir performans gerektirir. Takas alanınızı hızlı olan izler üzerine koyunuz. (Genel olarak düşük silindir numaraları düşük dik bölüm numaralarıyla eşleşir. Gene de bu konuyla ilgili güncel yorumları <link xlink:href="http://lissot.net/partition/mapping.html"/> adresinden inceleyiniz)
      </para></listitem><listitem><para>
<emphasis>Kullanım</emphasis>: Elbette, sizin disk kafanız rasgele hareket etmeyecektir. Eğer sürekli meşgul olan bir ev dizini disk bölümüyle, neredeyse hiç kullanılmayan bir arşiv disk bölümü arasında bir takas alanınız varsa, takas alanınızın ev dizini altında olması, disk kafasının kısa hareketler yapacak olmasından dolayı daha iyi bir yaklaşım olacaktır. Aslında, takas alanınız başka amaçla kullanılmayan bir diskte olursa, daha iyi olurdu.
      </para></listitem><listitem><para>
<emphasis>Bölme</emphasis>: Hız birden fazla takas alanını aynı anda kullanmakla arttırılabilir. Aynı önceliğe sahip takas alanları RAID cihazlar gibi ele alınıp kullanılır. (bknz. <xref linkend="partition-howto-multiple_swap_areas" />)
        </para></listitem>
</itemizedlist></para><para>
<emphasis>Özet</emphasis>: Takas alanınızı pek çok disk kafası olan ve başka işler yapmakla meşgul olmayan hızlı bir diske yerleştirin. Eğer birden çok diskiniz varsa: takas alanınız bölerek bunu tüm disklere hatta farklı denetleyicilere dağıtın.
      </para>
    </sect3>
  </sect2>
</sect1>

<sect1 xml:id="partition-howto-fdisk">
 <title>fdisk ile diski bölümleme</title>
 <sect2><title>fdisk ile disk bölümü oluşturmak</title><para>
Bu kısım aslında diskinizi <command>fdisk</command> uygulaması ile nasıl bölümlendireceğinizi anlatmaktadır. Linux sadece 4 tane birincil disk bölümüne izin vermektedir. Tek bir disk bölümünü alt bölümlere bölerek çok sayıda mantıksal bölüme sahip olabilirsiniz. Birincil disk bölümlerinden sadece bir tanesi alt bölümlere bölünebilir.
    </para><para><emphasis>Örnekler:</emphasis>
    </para><para><orderedlist>
   <listitem>
Dört tane birincil disk bölümü: <xref linkend="partition-howto-primary-example"/>
    </listitem><listitem>
Birincil ve mantıksal disk bölümleri karışık: <xref linkend="partition-howto-mixed"/>
    </listitem></orderedlist></para>
    <sect3 xml:id="partition-howto-about-fdisk"><title>fdisk kullanımı</title><para>
<command>fdisk</command>, komut satırında (root olarak) <userinput>fdisk </userinput><replaceable>aygıt-adı</replaceable> yazarak çalıştırılır. (<xref linkend="partition-howto-NamingConvention"/>). Aygıt adı <filename>/dev/hda</filename> veya <filename>/dev/sda</filename> gibi bir şey olabilir. İhtiyacınız olacak temel fdisk komutları şunlardır:
    </para><para><variablelist><varlistentry>
    <term><literal>p</literal></term>
    <listitem><para>disk bölümleme tablosunu göster
    </para></listitem></varlistentry><varlistentry>
    <term><literal>n</literal></term>
    <listitem><para>yeni bir disk bölümü oluştur
    </para></listitem></varlistentry><varlistentry>
    <term><literal>d</literal></term>
    <listitem><para>disk bölümü sil
    </para></listitem></varlistentry><varlistentry>
    <term><literal>q</literal></term>
    <listitem><para>değişiklikleri kaydetmeden çık
    </para></listitem></varlistentry><varlistentry>
    <term><literal>w</literal></term>
    <listitem><para>mevcut disk bölüm tablosunu yaz ve çık
    </para></listitem></varlistentry></variablelist>
    </para><para>
Disk bölümü tablosunda yaptıklarınız <command>w</command> komutu ile yazana kadar etkisini göstermez. Aşağıda basit bir disk bölümleme tablosu bulunmaktadır:
    </para><para>
<screen>Disk /dev/hdb: 64 kafa, 63 sektör/iz, 621 silindir
Birimler = silindir / 4032 * 512 bayt

   Aygıt Açılış    Başlangıç     Bitiş  BlokSayısı Kml Sistem
/dev/hdb1   *           1        184       370912+  83  Linux
/dev/hdb2             185        368       370944   83  Linux
/dev/hdb3             369        552       370944   83  Linux
/dev/hdb4             553        621       139104   82  Linux takas / Solaris
</screen>
    </para><para>
İlk satır diskin geometrisini göstermektedir. Fiziksel olarak tam doğru olmayabilir ama siz öyle olduğunu varsayabilirsiniz. Bu örnekteki disk her biri üzerinde bir disk kafası olan çift yönlü 32 tane plakadan oluşmuştur (muhtemelen doğru değil). Her bir plakanın eşmerkezli 621 izi bulunmaktadır. Üç boyutlu bir ize (tüm disk üzerindeki aynı izlere) silindir denir. Her bir iz 63 sektöre bölünmüştür. Her bir sektör 512 bayt veri içermektedir. Bundan dolayı disk bölümü tablosundaki blok sayısı 64 disk kafası * 63 sektör * 512 bayt / 1024'tür.(Bu problemin çözümü <xref linkend="partition-howto-BlockSize"/> bölümünde açıklanmıştır.) Başlangıç ve bitiş değerleri silindirlerdir.
      </para>
    </sect3><sect3 xml:id="partition-howto-primary-example">
      <title>Dört disk bölümü</title><para>
<emphasis>Gözden geçirme</emphasis>: Takas alanınızın <link linkend="partition-howto-SwapSize">boyuna</link> ve nereye <link linkend="partition-howto-SwapPlacement">yerleşmesi</link> gerektiğine karar verin. Kalan alanı diğer üç disk bölümü için bölün.
    </para><para>Örnek:</para><para>
<command>fdisk</command>'i komut satırından başlattım:
    </para><para>
<screen># <command>fdisk /dev/hdb</command>
</screen>
    </para><para>
Bu, IDE denetleyicinin üzerindeki ikinci sürücüyü kullandığım anlamına gelmektedir.
(<xref linkend="partition-howto-names"/> kısmına bakın.) (Boş) disk bölümleme tablosunu görüntülediğim zaman, sadece ayarlarla ilgili bilgi alırım.
    </para><para>
<screen>Command (m for help): <userinput>p</userinput>

Disk /dev/hdb: 64 heads, 63 sectors, 621 cylinders
Units = cylinders of 4032 * 512 bytes
</screen>
    </para><para>
1.2GB disk kapasitem olduğunu biliyordum ama artık eminim: <literal>64 * 63 * 512 * 621 = 1281982464 bayt</literal>. Bu alanın 128MB'ını takas için ayırmaya karar verdim, geriye 1153982464 kaldı. Eğer takas için birincil disk bölümlerinden birini kullanırsam ext2 disk bölümleri için geriye 3 tane  kalmış olur. Eşit olarak bölün, bu da 384MB olacak şekilde her birini oluşturmak demektir. Artık şimdi çalışmaya başlayabilir.
    </para><para>
<screen>Command (m for help): <userinput>n</userinput>
Command action
   e   extended
   p   primary partition (1-4)
<userinput>p</userinput>
Partition number (1-4): <userinput>1</userinput>
First cylinder (1-621, default 1):<userinput>&lt;RETURN&gt;</userinput>
Using default value 1
Last cylinder or +size or +sizeM or +sizeK (1-621, default 621): <userinput>+384M</userinput>
</screen>
    </para><para>
Daha sonra takas alanı için kullanacağım alanı ayarlıyorum:
    </para><para>
<screen>Command (m for help): <userinput>n</userinput>
Command action
   e   extended
   p   primary partition (1-4)
p
Partition number (1-4): <userinput>2</userinput>
First cylinder (197-621, default 197):<userinput>&lt;RETURN&gt;</userinput>
Using default value 197
Last cylinder or +size or +sizeM or +sizeK (197-621, default 621): <userinput>+128M</userinput>
</screen>
    </para><para>
Artık disk bölümleme tablosu şu şekilde gözüküyor:
    </para><para>
<screen>   Device Boot    Start       End    Blocks   Id  System
/dev/hdb1             1       196    395104   83  Linux
/dev/hdb2           197       262    133056   83  Linux
</screen>
    </para><para>
Diğer kalan iki disk bölümünü de ilkini yaptığım gibi ayarlıyorum. Son olarak da ilk disk bölümünü önyüklenebilir yapıyorum:
    </para><para>
<screen>Command (m for help): <userinput>a</userinput>
Partition number (1-4): <userinput>1</userinput>
</screen>
    </para><para>
Ve ayrıca ikinci disk bölümünün türünü de takas alanı olarak ayarlıyorum:
    </para><para>
<screen>Command (m for help): <userinput>t</userinput>
Partition number (1-4): <userinput>2</userinput>
Hex code (type L to list codes): <userinput>82</userinput>
Changed system type of partition 2 to 82 (Linux swap)
Command (m for help): <userinput>p</userinput>
</screen>
    </para><para>
Sonuç şu şekilde gözüküyor:
    </para><para>
<screen>
Disk /dev/hdb: 64 heads, 63 sectors, 621 cylinders
Units = cylinders of 4032 * 512 bytes

   Device Boot    Start       End    Blocks   Id  System
/dev/hdb1   *         1       196    395104+  83  Linux
/dev/hdb2           197       262    133056   82  Linux swap
/dev/hdb3           263       458    395136   83  Linux
/dev/hdb4           459       621    328608   83  Linux
</screen>
    </para><para>
Son olarak da <command>w</command> ile tabloyu diske yazdırıyorum.
    </para><para>
İlgili konular:
    </para><para><itemizedlist>
<listitem><xref linkend="partition-howto-swap"/></listitem>
<listitem><xref linkend="partition-howto-formating"/></listitem>
<listitem><xref linkend="partition-howto-mounting"/></listitem>
      </itemizedlist></para>
    </sect3><sect3 xml:id="partition-howto-mixed">
<title>Birincil ve mantıksal disk bölümleri karışık</title><para>
<emphasis>Gözden geçirme:</emphasis>Tüm diğer alt disk bölümlerini içermesi için bir tane birincil disk bölümü oluşturun. Daha sonra onun içerisinde mantıksal disk bölümleri oluşturun. Diğer birincil disk bölümlerini mantıksal disk bölümleri oluşturmadan önce veya sonra oluşturabilirsiniz.
      </para><para>Örnek:</para><para>
<command>fdisk</command>'i komut satırından çalıştırıyorum:
      </para><para>
<screen># <command>fdisk /dev/sda</command>
</screen>
      </para><para>
Bu, SCSI zincirimin ilk sürücüsü anlamına gelmektedir. (<xref linkend="partition-howto-names" /> kısmına bakın.)
      </para><para>
Öncelikle kaç tane disk bölümü istediğime karar veriyorum. Diskimin 183GB kapasitesi olduğunu biliyorum ve 26GB'lık disk bölümleri istiyorum (çünkü yaklaşık bu boyutta yedekleme teyplerim var)
      </para><para>
<literal>183GB / 26GB = ~7</literal>
      </para><para>
Dolayısiyle 7 disk bölümüne ihtiyacım var. <command>fdisk</command> disk bölümü boylarını MB ve kB olarak kabul etmesine rağmen, her bir disk bölümü sonundaki silindir numaralarını hesaplamaya karar veriyorum çünkü fdisk silindirlerin başlangıç ve bitiş silindir numaralarının bilgisini vermektedir. fdisk'e başladığım zaman 22800 silindirim olduğunu görüyorum.
      </para><para>
<screen>
&gt; The number of cylinders for this disk is set to 22800.  There is
&gt; nothing wrong with that, but this is larger than 1024, and could in
&gt; certain setups cause problems with: 1) software that runs at boot
&gt; time (e.g., LILO) 2) booting and partitioning software from other
&gt; OSs  (e.g., DOS FDISK, OS/2 FDISK)
</screen>
      </para><para>
Bu durumda, toplam 22800 silindirin 7 disk bölümünün her birine 3258 silindir düşer. Yani, her bir disk bölümü yaklaşık olarak 3258 silindir boyunda olacaktır. Önyükleme uyarısını dikkate almıyorum çünkü burası benim önyükleme amacıyla kullanacağım sürücüm (<xref linkend="partition-howto-requirements"/>) değil.
    </para><para>
4 tane birincil disk bölümüm olduğundan, bunlardan 3 tanesi 3258 uzunluğunda olabilir. Ek bölüm <literal>(4 * 3258)</literal> yani <literal>13032</literal> silindir uzunluğunda olmalı, böylece 4 mantıksal disk bölümü buraya sığar.
    </para><para>
İlk 3 birincil disk bölümünü oluşturmak için aşağıdaki komutları giriyorum (koyu ile yazdıklarım):
    </para><para>
<screen>Command (m for help): <userinput>n</userinput>
Command action
   e   extended
   p   primary partition (1-4)
<userinput>p</userinput>
Partition number (1-4): <userinput>1</userinput>
First cylinder (1-22800, default 1): <userinput>&lt;RETURN&gt;</userinput>
Using default value 1
Last cylinder or +size or +sizeM or +sizeK (1-22800, default 22800): <userinput>3258</userinput>
</screen>
    </para><para>
Son bölüm, ek disk bölümü:
    </para><para>
<screen>Partition number (1-4): <userinput>4</userinput>
First cylinder (9775-22800, default 9775): <userinput>&lt;RETURN&gt;</userinput>
Using default value 9775
Last cylinder or +size or +sizeM or +sizeK (9775-22800, default 22800): <userinput>&lt;RETURN&gt;</userinput>
Using default value 22800
</screen>
    </para><para>
Tabloyu göster komutunun çıktısı şöyle:
    </para><para>
<screen>/dev/sda1             1      3258  26169853+  83  Linux
/dev/sda2          3259      6516  26169885   83  Linux
/dev/sda3          6517      9774  26169885   83  Linux
/dev/sda4          9775     22800 104631345    5  Extended
</screen>
    </para><para>
Sonra, ilk mantıksal disk bölümünden başlayarak, ek bölümü her biri 3258-silindirlik 4 alt bölüme ayırıyorum. Mantıksal disk bölümleri böylece /dev/sda5'ten başlıyor.
    </para><para>
<screen>Command (m for help):  <userinput>n</userinput>
First cylinder (9775-22800, default 9775): <userinput>&lt;RETURN&gt;</userinput>
Using default value 9775
Last cylinder or +size or +sizeM or +sizeK (9775-22800, default 22800): 13032
</screen>
    </para><para>
Sonuç şu şekilde:
    </para><para>
<screen>   Device Boot    Start       End    Blocks   Id  System
/dev/sda1             1      3258  26169853+  83  Linux
/dev/sda2          3259      6516  26169885   83  Linux
/dev/sda3          6517      9774  26169885   83  Linux
/dev/sda4          9775     22800 104631345    5  Extended
/dev/sda5          9775     13032  26169853+  83  Linux
/dev/sda6         13033     16290  26169853+  83  Linux
/dev/sda7         16291     19584  26459023+  83  Linux
/dev/sda8         19585     22800  25832488+  83  Linux
</screen>
    </para><para>
Son olarak, <command>w</command> komutu ile tabloyu diske yazdırıyorum. Disk bölümlerinin kullanılabilir olması için onları <link linkend="partition-howto-formating">biçimlendirecek</link> ve kök dizine <link linkend="partition-howto-mounting">bağlayacağım</link>.
      </para>
    </sect3><sect3 xml:id="partition-howto-submitted">
      <title>Sunulan Örnekler</title><para>
Kendi disk bölümü yerleşimimi göstermek isterim, çünkü herhangi bir Linux dağıtımıyla iyi çalışabilmektedir (hatta büyük RPM tabanlı olanlarda bile). 10 GB olan tek bir sabit diskim var. Windows bunun 9.4 GB'tan fazlasını göremiyor, fakat Linux görüp kullanabiliyor. Aynı zamanda diskim 1024 silindirden fazlasını içeriyor.
      </para><para><table frame="all">
      <title>Bölüm yerleşim örneği</title>
<tgroup cols="3">
  <colspec colname="c1" />
  <colspec colname="c2" />
  <colspec colname="c3" />
<thead>
  <row>
    <entry>Disk Bölümü</entry>
    <entry>Bağlama noktası</entry>
    <entry>Büyüklük</entry>
  </row>
</thead>
<tbody>
  <row>
    <entry>/dev/hda1</entry>
    <entry>/boot</entry>
    <entry>(15 MB)</entry>
  </row>
  <row>
    <entry>/dev/hda2</entry>
    <entry>windows 98 bölümü</entry>
    <entry>(2 GB)</entry>
  </row>
  <row>
    <entry>/dev/hda3</entry>
    <entry>ek bölüm</entry>
    <entry>(kullanışsız)</entry>
  </row>
  <row>
    <entry>/dev/hda5</entry>
    <entry>takas alanı</entry>
    <entry>(64 MB)</entry>
  </row>
  <row>
    <entry>/dev/hda6</entry>
    <entry>/tmp</entry>
    <entry>(50 MB)</entry>
  </row>
  <row>
    <entry>/dev/hda7</entry>
    <entry>/</entry>
    <entry>(150 MB)</entry>
  </row>
  <row>
    <entry>/dev/hda8</entry>
    <entry>/usr</entry>
    <entry>(1.5 GB)</entry>
  </row>
  <row>
    <entry>/dev/hda9</entry>
    <entry>/home</entry>
    <entry>diskin geri kalanı</entry>
  </row>
</tbody>
</tgroup>
</table>
      </para><para>
Yeni çekirdekleri USB diskleri bakımından deniyorum, bu da büyük <filename>/boot</filename> disk bölümlerini açıklıyor. LILO'yu MBR'ye kurdum ve öntanımlı olarak windows'un başlamasına ayarladım (bu bilgisayarı kullanan tek ben değilim).
      </para><para>
Ayrıca, örneklerde GERÇEK disk bölümleme tablolarının kullanılmadığını da belirteyim, yeni başlayanlar için ÖZELLİKLE bir iki tane konulmasını öneririm<footnote><para>Ç.N.: Linux Sistem Yöneticisinin Kılavuzu kitabının <xref linkend="sag_disks-partiton"/> bölümünde gerçekçi bir örnek bulabilirsiniz.</para></footnote>. Artık yeni başlayan statüsünde değilim ve disk bölümleme beni en zorlayan konulardan biriydi.
      </para><para>
Valkor 
      </para>
    </sect3>
  </sect2>
</sect1>

<sect1 xml:id="partition-howto-labels">
        <title>Etiketler</title>
        <para>
Linux kullanımında disk sürücüleri aygıtlar olarak düşünülür, bu aygıtlar da <filename>/dev</filename> altındaki sanal dosyalardır. Örneğin, en düşük numaralı SCSI sürücüsünün ilk disk bölümü <filename>/dev/sdb1</filename> olarak gösterilir. <filename>/dev/sda</filename> olarak işaret edilen sürücü sistemden kaldırılırsa <filename>/dev/sda1</filename> disk bölümünden sonraki bölüm bir sonraki sistem açılışında otomatik olarak yeniden isimlendirilecektir.
        </para>
        <sect2 xml:id="partition-howto-volumelabels"><title>Aygıt Etiketleri</title><para>
Aygıt etiketleri nereye ve başka nelerin bağlı olduğuna bakmaksızın disk bölümleri için isimlendirilme yapılmasını sağlar. Bir linux aygıtı için etiketler zorunlu değildir. Her biri en fazla 16 karakter uzunluğunda olabilir.
        </para><para>
Aygıt etiketleri oluşturmak için kullanılan  üç araç vardır: mke2fs, tune2fs ve e2label.
        </para><sect3 xml:id="partition-howto-labelinvocation">
        <title>Basit Çalıştırma</title><para>
<literallayout>
<command>e2label</command>      /dev/hdb1 pubsw

<command>tune2fs</command> -L   pubsw /dev/hdb1
</literallayout>
          </para><para>
Bu komutların her ikisi de ikinci sürücünün ilk disk bölümünü "pubsw" olarak isimlendirir. Bu isim sürücü başka bir kontrol birimine takılsa veya başka bir bilgisayar taşınsa bile değişmeden kalır.
          </para><para>
<literallayout>
<command>mke2fs</command>       pubsw /dev/hdb1

<command>mke2fs</command> -L    pubsw /dev/hdb1
</literallayout>
          </para><para>
Bu iki komut bu işi dosya sistemi oluşturduktan sonra yapması dışında yukarıdaki iki komutla aynı işi yapar. Bu aynı zamanda var olan disk bölümlerinin de sileceğini belirtir.
          </para></sect3>
          <sect3 xml:id="howtousevolumelabels"><title>Kullanım</title><para>
Aşağıda bir <filename>fstab</filename> içeriği görüntülenmiştir. Bu dosya, sistem kurulumu sırarında /etc altında oluşturulur. Hangi disk bölümlerinin nasıl bağlanacağı bilgisini içerir. Yeni aygıtlar eklenip çıkarıldığında çeşitli uygulamalar tarafından veya sizin tarafınızdan değiştirilebilir.
          </para><para>
<screen>
LABEL=/        /                    ext3    defaults        1 1
LABEL=/boot    /boot                ext2    defaults        1 2
none           /dev/pts             devpts  gid=5,mode=620  0 0
none           /dev/shm             tmpfs   defaults        0 0
LABEL=HOME     /home                ext3    defaults        1 2
none           /proc                proc    defaults        0 0
none           /sys                 sysfs   defaults        0 0
LABEL=/usr     /usr                 ext3    defaults        1 2
/dev/hdc1      /k-space             ext3    defaults        1 2
/dev/hda6      swap                 swap    defaults        0 0
/dev/hdd       /media/cdrecorder    auto    pamconsole,ro,exec,noauto,managed 0 0
/dev/fd0       /media/floppy        auto    pamconsole,exec,noauto,managed 0 0
</screen>
          </para><para>
En sol sütün aygıtları hemem onun karşısındaki sütunsa bağlanacakları noktaları gösterir. Bu örnek etiket ve bağlama noktalarını karma içeren bir örnektir. İkinci disk kontrolündeki ana sürücü daima <filename>/k-space</filename> dizinine bağlanır. "HOME" etiketli disk sürücüsü ise hangi sürücü olduğuna ya da disk bölümü numarasına bakmaksızın <filename>/home</filename> dizinine bağlanır. Bağlama noktaları da, "/usr" gibi,  etiket olarak kullanılabilir.
          </para></sect3>
        </sect2>

        <sect2 xml:id="devicelabels"><title>Aygıt Etiketleri</title><para>
<command>devlabel</command> aygıtlara sembolik bağlar oluşturmak için kullanılan bir betiktir. Örneğin,
          </para><para>
<literallayout>
<command>devlabel</command> -d /dev/hdb1 -s /dev/home
</literallayout>
          </para><para>
<filename>/dev/hdb1</filename>'den <filename>/home</filename> dizinine bir bağ oluşturur. <filename>/dev/hdb1</filename> üzerindeki tekil bir belirteci de belirtilen bağ ile birlikte /etc/sysconfig/devlabel dosyasında da saklar. Eğer donanım <filename>/dev/hdc1</filename> olarak taşınırsa ona ait olan tekil belirteç (/usr/bin/partition_uuid kullanılarak) /etc/sysconfig/devlabel dosyasındaki karşılığına bakılarak <filename>/dev/home</filename>'u işaret edecek şekilde ayarlanır.
          </para>
        </sect2>
</sect1>

<sect1 xml:id="partition-howto-formatting">
        <title>Bir ext2/3 disk bölümünü biçimlendirmek</title><para>
Bir sabit disk bölümlendirildiğinde, birtakım alanlara haritası çıkarılır ve bu alanların içeriği boştur. Tıpkı rafları yeni oluşturulmuş bir kütüphaneye benzer. Tek ihtiyacı olan kitap kataloğunun ve işaretlerin oluşturulmasıdır.
        </para><para>
Disk bölümü içerisideki organize bilgisine dosya sistemi denir. Linux iler standart dosya sistemi ext2 ve ext3'tür ext3 dosya sistemi ext2 özelliklerine ilave olarak günlük olarak isimlendirilebilen disk kayıtlarını da içermektedir. Bu günlük ani güç kesilmelerinde ve başka durumlarda diskin kurtarılmasını sağlar.
        </para><para>
ext2/3 dosya sistemi oluşturmak için kullanılan temel araç <command>mke2fs</command>'tir. Genelde <filename>/sbin</filename> altında bulunur. <command>mkfs.ext2</command> ve <command>mkfs.ext3</command> <command>mke2fs</command> üzerinde çalışan ve ona çeşitli seçenekler gönderen komutlardır.
        </para>
        <sect2 xml:id="formatting-invocation"><title>Basit Çalıştırma</title><para>
<literallayout>
<command>mke2fs</command> /dev/hdb1

<command>mkfs.ext2</command> /dev/hdb1
</literallayout>
        </para><para>
her ikisi de ikinci sürücünün ilk disk bölümünde ext2 dosya sistemi oluşturur. Ve,
        </para><para>
<literallayout>
<command>mke2fs</command> -j /dev/hdb1

<command>mkfs.ext3</command> /dev/hdb1
</literallayout>
        </para><para>
bir ext3 dosya sistemi oluşturur.
        </para>
        </sect2>
        <sect2 xml:id="reservedblocks"><title>Atanmış bloklar</title><para>
<option>-m seçeneği</option> uzman olmayanların muhtemelen sıklıkla kullandığı bir özelliktir. Eğer dosya sistemi doldurulmuş ve yazılacak alan kalmadıysa temel olarak işletim sistemin sürekli yazmaya çalışmasından kullanım dışıdır. Varsayılan olarak disk bölümün yüzde beşi root kullanıcısının kullanımına ayrılır. Bu da root kullanıcısının disy üzerinde yönetimsel işlemler yapmasını veya gerekliyse bri takım verileri kaldırmasını sağlar. Yine de, bu durum disk bölümünün / veya home dizinlerini içermesi durumunda en kritik halini alır. Saf veri disk bölümleri için bu durum bir alan israfıdır. 250GB lık alanın yüzde beşi 12.5 GB'tır. Büyük disk bölümlerinin olması durumunda ayrılan alanı en az tutmak gerekir, ki bu da yüzde birdir.
        </para><para>
<literallayout>
<command>mkfs.ext3</command> -m 1 /dev/hdb1
</literallayout>
        </para><para>
root kullanıcısının kullanımına %1'lik bir ayrılmış alan oluşturarak dosya sistemini oluşturur. <command>tune2fs -m</command>, ayrılan blokların, diske verilerin yüklenmesinden sonra, ayarlanmasını sağlar.
        </para>
      </sect2>
</sect1>

<sect1 xml:id="partition-howto-recovering">
<title>Silinmiş bir Disk Bölümünü Kurtarmak</title>
<!--Tony, 1 Sept 00-->
  <para>
Aşağıda silinmiş bir disk tablosunu el ile kurtarmanın adımları anlatılmıştır. <link xlink:href="http://www.stud.uni-hannover.de/user/76201/gpart">gpart</link> veya <link xlink:href="http://www.cgsecurity.org/index.html?testdisk.html">TestDisk</link> gibi bu işlemi oldukça kolay hale getiren uygulamalar vardır. Eğer bunu okuyor ve şansınız hiç kalmadıysa, yapacaklarınız:
  </para><para><orderedlist>
  <listitem><para>
İlk disk bölümünüzün büyüklüğü kadar bir disk bölümü oluşturun. Bu kısmı asıl disk bölümünden daha büyük de yapabilirsiniz. Eğer daha küçük yaparsanız, çok hayıflanıp diş gıcırdatacaksınız.
    </para><para>
<screen>Command (m for help): <userinput>n</userinput>
Command action
   e   extended
   p   primary partition (1-4)
<userinput>p</userinput>
Partition number (1-4): <userinput>1</userinput>
First cylinder (1-23361, default 1): <userinput>&lt;RETURN&gt;</userinput>
Using default value 1
Last cylinder or +size or +sizeM or +sizeK (1-22800, default 22800): <userinput>13032</userinput>

Command (m for help): <userinput>w</userinput>
</screen>
  </para></listitem><listitem><para>
<command>dumpe2fs</command>'i ilk disk bölümünde çalıştırarak blok sayısını bulun.
  </para><para>Örnek:</para><para>
<screen>% <command>dumpe2fs /dev/sda1 | grep "Block count:"</command>
Block count:              41270953
</screen>
    </para><para>
Eğer bu değerden emin değilseniz, 1. Adımı daha büyük bir disk boyutu için tekrarlayın. Eğer blok sayısı değiştiyse, asıl disk bölümü blok sayısını iyi tahmin edememişsiniz demektir. 1. Adımı kararlı bir blok sayı bulana kadar sürdürün.
  </para></listitem><listitem><para>
Yeni oluşturduğunuz disk bölümünü silin.
    </para><para>
<screen>Command (m for help): <userinput>d</userinput>
Partition number (1-4): <userinput>1</userinput>
</screen>
  </para></listitem><listitem xml:id="partition-howto-BlockSize"><para>
Elde ettiğiniz blok sayısına bakarak yeni bir disk bölümü oluşturun. <command>fdisk</command>'e blok sayısı giremediğinizden, kaç tane silindir istendiğini hesaplamanız gerekmektedir. İşte formulü:
    </para><para>
<literallayout indent="0">
(gerekli silindir sayısı) = (blok sayısı) / (blok büyüklüğü)

(blok büyüklüğü) = (birim büyüklüğü) / 1024

(birim büyüklüğü) = (kafa sayısı) * (sektör/silindir sayısı) * (bayt/sektör sayısı)
</literallayout>
  </para><para>
1, 2, 4 ve 8 silindirlik 4 birincil disk bölümüne ayrılmış aşağıdaki disk bölümleme örneğine bakınız.
  </para><para>
<screen>disk /dev/sda: 16 heads, 63 sectors, 23361 cylinders
Units = cylinders of 1008 * 512 bytes

   Device Boot    Start       End    Blocks   Id  System
/dev/sda1             1         2       976+  83  Linux
/dev/sda2             3         5      1512   83  Linux
/dev/sda3             6        10      2520   83  Linux
/dev/sda4            11        19      4536   83  Linux
</screen>
  </para><para>
<command>fdisk</command> çıktı başlangıcında ihtiyacım olan ayar bilgisini de sunmaktadır.
  </para><para>
<literallayout>
Birim büyüklüğü <userinput>516096</userinput>
  = <userinput>16</userinput> disk kafası * <userinput>63</userinput> sektör/silindir * <userinput>512</userinput> bayt/sektör

Blok büyüklüğü <userinput>504</userinput>
  = <userinput>516096 / 1024</userinput>
</literallayout>
  </para><para>
Dolasiyle ikinci disk bölümü için gerekli silindir sayısı <userinput>3</userinput>'tür (<userinput>1512</userinput> blok <userinput>/ 504</userinput>).
  </para><para>
Disk bölümleme tablosu da bunun gerçekten de böyle olduğunu söylüyor: ilk silindir <userinput>3</userinput>, ikincisi <userinput>4</userinput> ve en sonuncu da <userinput>5</userinput>, toplam 3 silindir.
  </para><para>
Üçüncü disk bölümü için gerekli silindir sayısı da benzer şekilde hesaplanır: <userinput>2520</userinput> blok <userinput>/ 504 = 5</userinput>, bunlar da bloklara karşı gelecek şekilde <userinput>6,7,8,9,10</userinput>'dur. Bu hesaplamanın ilk disk bölümünde çalışmayacağına dikkat edin (<userinput>1008</userinput> yerine <userinput>976</userinput>). Artı işareti tüm blokların fdisk uygulamasına katıldıklarını gösterir. Hesaplamayı denediğiniz zaman (<userinput>976 / 504 </userinput>) <userinput>1.937</userinput> elde edersiniz. Silindir sayısının tamsayı olması gerektiğini bilerek bunu yuvarlayabilirsiniz.
  </para></listitem><listitem><para>
<command>e2fsck</command>'i çalıştırarak yeni disk bölümününün okunup okunamayağına bakın.
  </para></listitem><listitem><para>
1'den 5'e kadar adımları kalan diğer disk bölümleri için de tekrarlayın.
  </para></listitem></orderedlist></para><para>
Disk bölümünüzü tekrar bağlayın. Şaşırtıcı bir şekilde bilgilerinizi orada olduğunu göreceksiniz.
  </para><para><itemizedlist>
  <listitem><para>
jedi sistem yöneticisi ve MGH'nin en iyisi olan Mike Vevea'a, bu ipuçlarını verdiği için teşekkürler.
  </para></listitem></itemizedlist></para>
</sect1>

<sect1 xml:id="partition-howto-setting_up_swap">
  <title>Takas Alanını Ayarlamak</title>
  <sect2 xml:id="partition-howto-swap_partitions">
    <title>Takas Dosyaları</title><para>
Bir takas alanı oluşturmanın, ayarlamanın ve bunu /etc/fstab dosyasına eklemenin iki adımı vardır. /dev/hda6 olarak ayarlanmış bir takas alanının fstab dosyasındaki görüntüsü şu şekildedir:
    </para><para>
<screen>
/dev/hda6       swap    swap    defaults        0       0
</screen>
    </para><para>
Sistemi yeniden başlattığınızda yazılan bu takas alanı otomatik olarak etkin olacaktır.
    </para><para>
Fakat, takas alanını hemen kullanmak isterseniz bunu elle yapmalısınız. root olarak şunları yazın:
    </para><para>
<screen>
<command>mkswap</command> -f /dev/hda6
<command>swapon</command> /dev/hda6
</screen>
        </para></sect2>

  <sect2 xml:id="partition-howto-swapfiles">
    <title>Takas Dosyaları</title><para>
Takas alanının yetersiz kaldığı durumlar olabilir, böylesi durumlarda yeniden disk bölümlendirmek ya da yeni bir tane eklemek pek pratik değildir. Tek yapmanız gereken istediğiniz büyüklükte bir dosya oluşturmak
    </para><para>
<command>dd</command><literal> if=/dev/zero of=/var/my_swap bs=1024 count=131072</literal>
    </para><para>ve etkin kılmaktır
    </para><para>
<screen>
<command>mkswap</command> -f /var/my_swap
<command>swapon</command> /var/my_swap
</screen>
    </para><para>
Bu şekilde <filename>/var</filename> altında <filename>my_swap</filename> isimli bir dosya oluşturulur. Boyutu başlangıçta 128 Mb'tir (128 x 1024 = 131072). İlklendirme sırasında sıfırlar ile doldurulur. <command>mkswap</command> bu dosyayı takas alanı kullanılması için işaretler ve <command>swapon</command> da çekirdeğin bunu takas alanı olarak kallanmaya başlamasını söyler. İşiniz bittikten sonra,
    </para><para>
<screen>
<command>swapoff</command> /var/my_swap
<command>rm</command> /var/my_swap
</screen>
    </para><para>
komutlarını çalıştırır.
    </para>
  </sect2><sect2 xml:id="partition-howto-multiple_swap_areas">
    <title>Çoklu Takas Alanları</title><para>
Tek bir sistem üzerinde birden fazla takas alanı kullanılabilir. Tek bir takas alanının olduğu bir fstab örneğine bakalım:
    </para><para>
<screen>
/dev/hda5   /        ext3   defaults        1   1
/dev/hda1   /boot    ext2   defaults        1   2
none        /dev/pts devpts gid=5,mode=620  0   0
none        /proc    proc   defaults        0   0
/dev/hda7   /usr     ext3   defaults        1   2
/dev/hda6   swap     swap   defaults        0   0
</screen>
    </para><para>
Takas alanı girdileri şu şekilde değiştirdiğimiz düşünelim:
    </para><para>
<screen>
/dev/hda6   none    swap    sw,pri=3    0       0
/dev/hdb2   none    swap    sw,pri=2    0       0
/dev/hdc2   none    swap    sw,pri=1    0       0
</screen>
    </para><para>
Bu ayarlama ile en yüksek önceliğe sahip olan (pri=3) /dev/hda6 çekirdek tarafından ilk olarak kullanılacaktır. En yüksek öncelik değeri 32767 en düşüğü ise 0'dır. Eğer ilk kullanılan yetersiz kalırsa sırasıyla önce /dev/hdb2 ve sonra da /dev/hdc2 kullanılacaktır. En yeni (en hızlı) sürücülere en büyük öncelik değerinin verildiğini düşünün. Bu durum takas alanının aşırı kullanımında hız kaybını en aza indirir.
    </para><para>
Her üç bölüme de aynı anda yazmak mümkündür. Çekirdek bir RAID aygıta yazar gibi her disk bölümüne aynı anda yazacaktır.
    </para><para>
<screen>
/dev/hda6   none   swap   sw,pri=3   0   0
/dev/hdb2   none   swap   sw,pri=3   0   0
/dev/hdc2   none   swap   sw,pri=3   0   0
</screen>
    </para><para>
Bu disk bölümlerinin farklı sürücülerde olduğunu ve bunun da hız artışı için yapıldığını düşünebilirsiniz.
    </para>
  </sect2>
</sect1>
<sect1 xml:id="partition-howto-appendix"><title>Son Söz</title>
  <sect2 xml:id="partition-howto-formating">
    <title>Disk Bölümlerinin Biçimlendirilmesi</title>
<!--Tony, 1 May 00-->
  <para>
Komut satırında disk bölümlerim üzerindeki dosya sistemlerini oluşturmaya başlıyorum.
<xref linkend="partition-howto-mixed"/> örneğini takiben:
  </para><para>
<screen># <command>mke2fs /dev/sda1</command>
</screen>
  </para><para>
Bunu /dev/sda4 (ek disk bölümü) dışındakilerin hepsi için yapmalıyım.
  </para><para>
Linux ext2 dışındaki dosya sistemlerini de destekler. <filename>/usr/src/linux/include/linux/fs.h</filename> dosyasının içeriğine bakarak çekirdeğinizin hangi dosya sistemi türlerini desteklediğini öğrenebilirsiniz.
    </para><para>
Yaygın dosya sistemleri <filename>/sbin</filename> içerisindeki <literal>mk</literal> ile başlayan <command>mkfs.msdos</command> ve <command>mke2fs</command> gibi yazılımlarla yapılabilir.
</para></sect2>
  <sect2 xml:id="partition-howto-swap">
<title>Takas Alanınının Etkinleştirilmesi</title><para>
<!--Tony, 1 May 00-->
Bir takas alanını yapılandırmak için:
    </para><para>
<screen># <command>mkswap -f /dev/hda5</command>
</screen>
    </para><para>
Takas alanını etkinleştirmek için:
    </para><para>
<screen># <command>swapon  /dev/hda5</command>
</screen>
    </para><para>
Normalde, takas alanı önyükleme sırasında ilklendirme betikleri tarafından etkinleştirilir.
    </para>
  </sect2><sect2 xml:id="partition-howto-mounting">
<title>Disk Bölümlerinin Bağlanması</title><para>
<!--Tony, 1 May 00-->
Disk bölümlerini bağlamak onları linux dosya sistemi ile ilişkilendirmek demektir. Bir linux disk bölümünü bağlamak için:
    </para><para>
<screen># <command>mount -t ext2 /dev/sda1 /opt</command>
</screen>
    </para><para><variablelist>  <varlistentry>
    <term><literal>-t ext2</literal></term>
    <listitem><para>
Dosya sistemi türü. Kullanmak isteyebileceğiniz diğer dosya sistemi türleri:
    </para><para><itemizedlist>
<listitem>ext3 (ext2 tabalı günlüklemeli (journaling) dosya sistemi)</listitem>
<listitem>msdos (DOS)</listitem>
<listitem>hfs (mac)</listitem>
<listitem>iso9660 (CDROM)</listitem>
<listitem>nfs (ağ dosya sistemi)</listitem>
    </itemizedlist>
    </para></listitem></varlistentry><varlistentry>
    <term><filename>/dev/sda1</filename></term>
    <listitem><para>
Aygıt adı. Kullanmak isteyebiledeğiniz diğer aygıt dosyası adları:
    </para><para><itemizedlist>
<listitem><filename>/dev/hdb2</filename> (ikinci IDE sürücüsündeki ikinci disk bölümü)</listitem>
<listitem><filename>/dev/fd0</filename>  (floppy disk A)</listitem>
<listitem><filename>/dev/cdrom</filename>  (CDROM)</listitem>
    </itemizedlist>
    </para></listitem></varlistentry><varlistentry>
    <term><filename>/opt</filename></term>
    <listitem><para>
Bağlama noktası. Burası <userinput>ls /opt</userinput> yazdığınız zaman "görmek" istediğiniz yerdir, böylece <filename>/dev/sda1</filename> içerisinde ne varmış diye görebilirsiniz. Eğer <filename>/opt</filename> altında halihazırda dizinler ve/veya dosyalar varsa bağlama işleminden sonra bunlar görünmez olacaklardır.
    </para></listitem></varlistentry></variablelist></para>
  </sect2><sect2 xml:id="partition-howto-fragmentation">
<title>Saçılım ve Dosya sistemleri hakkında bazı gerçekler</title><para>
Disk alanı işletim sistemi tarafından bloklar ve blok kayıtları olarak yönetilir. ext2'de, bloklar ve blok kayıtları aynı büyüklükte olmalıdır, böylece açıklamamızı bloklarla sınırlandırabiliriz.
    </para><para>
Dosyalar herhangi bir büyüklükte olabilir. Blok sınırlarıyla sonlanmazlar. Dolayısiyle her bir dosya için bloğun bir kısmı boşa harcanır. Dosya boylarının rasgele olduğunu varsayarsak, her bir dosya için diskinizde yaklaşık yarım blok boşa harcanmaktadır. Tanenbaum "İşletim Sistemleri" ("Operating Systems") isimli kitabında buna "dahili saçılım" ("internal fragmentation") demektedir.
    </para><para>
Kaç dosyanız olduğunu dosya düğümü (inode) sayısına bakarak tahmin edebilirsiniz. Benim diskimde
    </para><para>
<screen># <command>df -i</command>
Dosyasistemi      Dosyaindeksi Dolu    Boş    Kull% Bağlanılan yer
/dev/hda3              64256   12234   52022    19%  /
/dev/hda5              96000   43058   52942    45%  /var
</screen>
    </para><para>
<filename>/</filename> üzerinde yaklaşık 12000, <filename>/var</filename> üzerinde ise yaklaşık 44000 dosya var. 1 kB'lık blok büyüklüğü için, yaklaşık  6+22 = 28 MB'lık disk alanı dosyaların blok sonlarındaki kısımlarında kaybedilir. 4 KB'lık blok büyüklüğü seçmiş olsaydım, bu büyüklüğün 4 katı kadarını kaybetmiş olacaktım.
    </para><para>
Veri aktarımı tek ve kesintisiz bir veri tomarında daha hızlı gerçekleşir. Bu da, dosyalar büyüdükçe ext2'nin ardışık 8 blokluk birimler tahsis etmesinin sebebidir. Dosya kapatıldığında ayrıldığı halde kullanılmayan bloklar serbest bırakılır ve böylece boşa alan harcanmaz.
    </para><para>
Dosyaların ardışık olmayan bloklardan oluşması performans açısından kötüdür, çünkü genelde dosyalara erişimde sıralı erişimle kullanılır. Bu durum da işletim sisteminin diske erişimini bölmeye zorlamakta ve de disk kafalarını hareketine sebep olmaktadır. Buna da harici saçılım ("external fragmentation") veya basitçe saçılım ("fragmentation") denir ki MS-DOS dosya yapılarındaki temel sorundur. MS-DOS'un kullandığı berbat önbelleğin birleşimi ile dosya saçılmalarının etkileri dikkat çekici boyutlardadır. DOS kullanıcıları disklerini birleştirmeyi bir kaç haftada bir yaptıkları mutad işler arasına almışlardır hatta bazıları disk birleştirmeyle ilgili törensel fikirler geliştirmiştir.
    </para><para>
Bu alışkanlıklarının hiç birisinin Linux ve ext2 üzerinde işi yoktur. Linux dosya yapısı normal kullanımda ve azından %5'lik bir disk alanının boş olması durumunda hiçbir koşulda disk birleştirmeye gerek duymaz. ext2'de disk birleştirmek için defrag isimli bir araç vardır, fakat kullanıcılar dikkatsiz kullanımı konusunda uyarılmaktadır. Böylesi bir işlem sırasındaki güç kesintisi sisteminizi çökertebilir. Verilerinizi yedeklemeniz gerekeceğinden, kopyasından yazmak iş görecektir.
    </para><para>
MS-DOS dosya yapısı aynı zamanda dahili saçılımdan dolayı büyük miktarda alan kaybetmesiyle bilinir. 256 MB'dan büyük disk kısımları için, DOS blok boyutu kullanılamayacak kadar büyür (Bu durum belli ölçülerde FAT32 için de geçerlidir). Ext2, 0.5 TB (terabayt, 1 TB = 1024 GB'tır) ve üstü büyüklükler dışında, sizi büyük dosya yapıları için büyük bloklar seçmeye zorlamaz. Bu durumlarda küçük blok büyüklükleri verimsiz hale gelmektedir. Dolayısiyle, DOS'takinin aksine büyük diskleri blok büyüklüğünü küçük tutmak için bir kaç bölüme ayırmanın gereği yoktur.
    </para><para>
Eğer pek çok küçük dosyanız varsa 1 kB'lık blok büyüklükleri kullanın. Büyük disk bölümleri için 4 kB yeterlidir.
    </para>
  </sect2>
</sect1>
</article>