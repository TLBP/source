<?xml version="1.0" encoding="UTF-8"?>

<!--DOCTYPE book SYSTEM "../docbook/dtd/docbookx.dtd"-->

<!-- ********************************************************************
     $Id: tlkg-lis.xml,v 1.3 2002/12/20 22:34:38 nilgun Exp $
     ******************************************************************** -->
<book id="archive-tlkg-lis">
<?dbhtml dir="../lis""?>
<?dbpdf pdf="no"?>
  <bookinfo>
    <title>Linux İşletim Sistemi</title>
    <author>
      <firstname>Türkiye Linux Kullanıcıları Grubu</firstname>
    </author>
    <releaseinfo><ulink url="http://www.linux.org.tr"/></releaseinfo>
    <abstract>
      <para>
Bu kitap, Türkiye Linux Kullanıcıları Grubu'nun inet-tr'97 ve öncesi çalışmalarını kapsar.
      </para><para>
Bu kitap, 5846 sayılı Fikir ve Sanat Eserleri Kanunu, Madde 34 (Eğitim ve Öğretim  İçin Seçme ve Toplama Eserler) ve Madde 35 ( İktibas Serbestisi ) uyarınca yayınlanmaktadır.
     </para>
    </abstract>
    <pubdate>v0.1, Temmuz 1997</pubdate>
    <legalnotice><title>Yasal Açıklamalar</title>
      <para>
BU BELGE "ÜCRETSİZ" OLARAK RUHSATLANDIĞI İÇİN, İÇERDİĞİ BİLGİLER İÇİN İLGİLİ KANUNLARIN
İZİN VERDİĞİ ÖLÇÜDE HERHANGİ BİR GARANTİ VERİLMEMEKTEDİR. AKSİ YAZILI OLARAK BELİRTİLMEDİĞİ
MÜDDETÇE TELİF HAKKI SAHİPLERİ VE/VEYA BAŞKA ŞAHISLAR BELGEYİ "OLDUĞU GİBİ", AŞİKAR VEYA
ZIMNEN, SATILABİLİRLİĞİ VEYA HERHANGİ BİR AMACA UYGUNLUĞU DA DAHİL OLMAK ÜZERE HİÇBİR
GARANTİ VERMEKSİZİN DAĞITMAKTADIRLAR. BİLGİNİN KALİTESİ İLE İLGİLİ TÜM SORUNLAR SİZE AİTTİR.
HERHANGİ BİR HATALI BİLGİDEN DOLAYI DOĞABİLECEK OLAN BÜTÜN SERVİS, TAMİR VEYA DÜZELTME
MASRAFLARI SİZE AİTTİR.
    </para><para>
İLGİLİ KANUNUN İCBAR ETTİĞİ DURUMLAR VEYA YAZILI ANLAŞMA HARİCİNDE HERHANGİ BİR ŞEKİLDE
TELİF HAKKI SAHİBİ VEYA YUKARIDA İZİN VERİLDİĞİ ŞEKİLDE BELGEYİ DEĞİŞTİREN VEYA YENİDEN
DAĞITAN HERHANGİ BİR KİŞİ, BİLGİNİN KULLANIMI VEYA KULLANILAMAMASI (VEYA VERİ KAYBI OLUŞMASI,
VERİNİN YANLIŞ HALE GELMESİ, SİZİN VEYA ÜÇÜNCÜ ŞAHISLARIN ZARARA UĞRAMASI VEYA BİLGİLERİN
BAŞKA BİLGİLERLE UYUMSUZ OLMASI) YÜZÜNDEN OLUŞAN GENEL, ÖZEL, DOĞRUDAN YA DA DOLAYLI HERHANGİ
BİR ZARARDAN, BÖYLE BİR TAZMİNAT TALEBİ TELİF HAKKI SAHİBİ VEYA İLGİLİ KİŞİYE BİLDİRİLMİŞ
OLSA DAHİ, SORUMLU DEĞİLDİR.
    </para><para>
Tüm telif hakları aksi özellikle belirtilmediği sürece sahibine aittir. Belge içinde geçen herhangi bir terim, bir ticari isim ya da kuruma itibar kazandırma olarak algılanmamalıdır. Bir ürün ya da markanın kullanılmış olması ona onay verildiği anlamında görülmemelidir.
      </para>
    </legalnotice>
  </bookinfo>

<chapter id="archive-tlkg-lis-1">
<title>Linux Nedir?</title>
  <sect1 id="archive-tlkg-lis-1g">
    <title>Giriş</title>
    <para>
      Linux, serbestçe dağıtılabilen, çokgörevli, çok kullanıcılı UNIX
      işletim sistemi türevidir. Linux, Internet üzerinde ilgili ve meraklı
      birçok kişi tarafından ortak olarak geliştirilmekte olan ve başta
      IBM-PC uyumlu kişisel bilgisayarlar olmak üzere birçok platformda
      çalışabilen ve herhangi bir maliyeti olmayan bir işletim sistemidir.
    </para><para>
      UNIX 70'li yılların ortalarında büyük bilgisayarlar üzerinde çok
      kullanıcılı bir işletim sistemi olarak geliştirilmiştir. Zaman
      içerisinde yayılmış ve birçok türevi ortaya çıkmıştır. UNIX ismi UNIX
      Research Laboratories INC şirketinin tescilli markası olduğundan dolayı
      birçok şirket, aynı temele dayanan işletim sistemleri için değişik
      isimler kullanagelmişlerdir. Örnek olarak
    </para><para>
      <itemizedlist>
        <listitem>Hewlett-Packard HP-UX</listitem>
        <listitem>IBM AIX</listitem>
        <listitem>Sun Microsystems SunOS</listitem>
      </itemizedlist>
    </para><para>
      kullanmaktadırlar. Bugün kişisel bilgisayarlardan süper bilgisayarlara
      kadar biçok bilgisayar için yazılmış bulunan UNIX türevleri mevcuttur.
      Ne var ki bu türevlerin çoğu gelişimi belirli bir noktada durmuş ve
      yüksek fiyatla satılan ticari yazılımlardır.
    </para><para>
      Linux, temel olarak Finlandiya Üniversitesinde öğrenci olan Linus
      Torvalds'ın ve Internet üzerinde meraklı bir çok yazılımcının
      katkıları  ile geliştirilmiştir. Linux gelişimi açık bir şekilde
      yapılmaktadır. Bunun anlamı, işletim sisteminin her aşaması açık olarak
      Internet üzerinde yayınlanmakta, dünyanın dört bir yanında kullanıcılar
      tarafından test edilmekte, hataları ve eksiklikleri tesbit edilerek
      düzeltilmekte ve geliştirilmektedir. Zaman zaman bu deneme aşamaları
      belirli bir noktada durdurulur ve güvenilir bir işletim sistemi
      sunulup, geliştirme için ayrı bir seriye devam edilir. Geliştirmede yer
      alan bu açıklık Linux'un en büyük avantajlarından biridir. Gelişimi
      evrimseldir, hatalar anında kullanıcılar tarafından tesbit edilip rapor
      edilmekte ve birçok kişinin katkısıyla düzeltilmektedir. Bazı işletim
      sistemi sürümleri saatler içerisinde güncellenebilmektedir.
    </para><para>
      Linux, Andy Tannenbaum tarafından geliştirilmiş olan Minix işletim
      sistemine dayanmaktadır. Linus Torvalds boş zamanlarında Minix'ten daha
      iyi bir Minix işletim sistemi yaratmak düşüncesiyle 1991 Ağustos
      sonlarında ilk çalışan Linux çekirdeğini oluşturdu. 5 Ekim 1991
      tarihinde 0.02 sürümü Linux ilk defa tanıtıldı. Linus, comp.os.minix
      haber grubuna gönderdiği yazıda yeni bir işletim sistemi geliştirmekte
      olduğunu ve ilgilenen herkesin yardımını beklediğini yazmıştı. İşletim
      sisteminin çekirdeği için verilen numaralar kısa sürede bir standart
      kazandı. a.x.y seklinde belirtilen çekirdek türevlerinde y bulunulan
      seviyeyi, x gelişim aşamasını göstermektedir. Tek sayılı x'ler
      geliştirme aşamalarını çift sayılı x' ler ise güvenilir Linux
      çekirdeklerini göstermektedirler. a ise değişik Linux sürümlerini
      belirtir. Bu yazının hazırlandığı Ağustos 1997 içerisinde en son
      güvenilir (kararlı) Linux çekirdeği 2.0.30, en son gelişim aşamasındaki
      çekirdek ise 2.1.47'dir.
    </para><para>
      Linux gerçekten son yıllarda hızlı bir gelişme göstermiş, çesitli
      ülkelerden birçok kullanıcıya erişmiş ve yazılım desteği günden güne
      artmıştır. Değişik kuruluşlar Linux sistemi ve uygulama
      yazılımlarını biraraya getirerek dağıtımlar oluşturmuşlar ve
      kullanımını yaygınlaştırmışlardır.
    </para>
  </sect1>
  <sect1 id="archive-tlkg-lis-1.1">
  <title>Linux'un Desteklediği Donanımlar</title>
    <para>
      <itemizedlist>
        <listitem>
          <para>
            Linux şu anda başta IBM-PC uyumlu kişisel bilgisayarlar olmak üzere
            Apple, Atari ve Amiga gibi 68000 tabanlı bilgisayarlar üzerinde, Sun
            Sparc işlemcili iş istasyonları, Alpha işlemcili kişisel bilgisayarlar,
            MIPS, PowerPC, HP PA-RISC ve ARM mimarilerinde çalışmaktadır.
          </para>
        </listitem><listitem>
          <para>
            IBM uyumlu kişisel bilgisayarlar üzerinde 80386 ve üzeri (80486
            80586 Pentium PentiumPro ve türevleri) değişik üreticilerin işlemcileri
            ile sorunsuz olarak çalışmaktadır. 80286 ve 8086 işlemcili
            bilgisayarlar için sınırlı kabiliyette Linux uygulamaları mevcuttur.
          </para>
        </listitem><listitem>
          <para>
            AGP, PCI, VESA, ISA ve MCA mimarilerinde her türlü anakartı desteklemektedir.
          </para>
        </listitem><listitem>
          <para>
            Teorik olarak 4 Gbyte'a kadar RAM desteklenmektedir.
          </para>
        </listitem><listitem>
          <para>
            AT uyumlu diskler (IDE, EIDE ve 16 bitlik MFM,RLL veya ESDI)
            desteklenmektedir. Kontrol kartına uyumlu destek bulunduğu sürece SCSI
            diskler ve diğer cihazlar desteklenmektedir.
          </para>
        </listitem><listitem>
          <para>
            IDE-ATAPI CD-ROM sürücüleri ve bazı özel CD-ROM kontrol kartları
            desteklenmektedir.
          </para>
        </listitem><listitem>
          <para>
            Metin ekranlarda CGA, EGA, VGA, Hercules veya uyumlu kartlar
            desteklenmektedir. X Pencere ortamında genel VGA ve SVGA uyumlu kartlar
            ve S3, ET4000, 8514/A, ATI MACH8, ATI MACH32 gibi birçok görüntü kartı
            desteklenmektedir.
          </para>
        </listitem><listitem>
          <para>
            Birçok 10 ve 100 Mbit ethernet kartı, ISDN, ATM, FDDI, SLIP, CSLIP,
            PPP desteği verilmektedir.
          </para>
        </listitem><listitem>
          <para>
            Başta SoundBlaster, Gravis Ultrasound olmak üzere birçok ses kartı
            desteklenmektedir.
          </para>
        </listitem>
      </itemizedlist>
    </para><para>
      Linux altında hangi donanımların desteklendiği ile ilgili ayrıntılı
      bilgiyi <emphasis>Hardware-HOWTO</emphasis>'dan alabilirsiniz. HOWTO belgeleri hakkında
      daha geniş bilgi ve nereden temin edeceğiniz kitabın  sonunda ayrıntılıca
      anlatılmıştır.
    </para><para>
      Makinanızda Linux çalıştırmak için kullanacağınız uygulamalara bağlı
      olarak en az bir 386SX işlemci ve 4 Mbyte RAM'a ihtiyaç duyacaksınız.
      Sabit disk üzerinde ise en az 40 Mbyte'lik bir alan ayırmanız
      gerekecektir. Rahat bir kullanım için en az 8 Mbyte RAM ve 200 Mbyte
      sabit disk ve bir 486 işlemci önerilmektedir.
    </para>
  </sect1>
  <sect1 id="archive-tlkg-lis-1.2">
    <title>Linux'un Kullanım Amaçları</title>
    <para>
      Ücretsiz olarak dağıtılıyor ve gelişiminin hala devam ediyor olması
      biçcok kişinin Linux'un profesyonel alanlarda kullanılamayacağının
      düşünmesine yol açmaktadır. Oysa Linux işletim sistemini kullanan
      bilgisayarlar özel kullanım başta olmak üzere birçok alanda yaygın
      olarak kullanılmaktadırlar.
    </para>
    <sect2>
      <title>Kişisel Kullanım</title>
      <para>
        Linux evinde veya işinde UNIX işletim sistemi altında çalışmak
        isteyenler için ideal bir platformdur. Özellikle işi veya eğitimi
        sırasında UNIX platformlar altında çalışmak, uygulamalar kullanmak
        veya yazılım geliştiren kişiler kendi kişisel bilgisayarlarında benzer
        ortamı yakalayabilmekte ve işlerini kendi kişisel bilgisayarlarında
        gerçekleştirebilmektedirler. Bunlara ek olarak Linux altında yer alan
        uygulamalar giderek sıradan bir kullanıcı için bile bu işletim sisteminin
        ilgi çekici hale gelmesini sağlamaktadır. Gelişimleri henüz tamamlanmamış
        olmasına rağmen, herhangi bir kişisel bilgisayardan beklenebilecek yazı
        editörleri, hesap cetvelleri, çizim yazılımları, veri tabanları birçok
        ihtiyaca cevap verecek düzeye gelmiştir. Örneğin LaTeX kullanıcıları
        MS-DOS altında buldukları desteğin çok daha fazlasını Linux altında
        bulabilmektedirler.
      </para>
    </sect2><sect2>
      <title>Internet Sunucusu</title>
      <para>
        Linux doğrudan TCP/IP desteği ile gelmektedir. Bu yönü ile TCP/IP
        temelli bilgisayar ağlarında hem istemci hem de sunucu olarak yaygın
        kullanım bulmuştur. Üzerinde hali hazırda bulunan servislerin
        çeşitliliği, yeni çıkan servislere hızlı ayak uydurması, kolay
        yapılandırılabilmesi ve özellikle de düşük maliyeti sebebi ile yaygın
        olarak Internet servislerinin verilmesi amacıyla kullanılmaktadır.
        Zamanla verdiği ağ servisleri başka protokollere destek verecek sekilde
        genişletilmiştir. Şu anda Linux
      </para><para>
        <itemizedlist>
          <listitem>WWW sunucu </listitem>
          <listitem>DNS sunucu </listitem>
          <listitem>NFS sunucu </listitem>
          <listitem>NIS sunucu </listitem>
          <listitem>X Pencere sunucu </listitem>
          <listitem>BOOTP sunucu </listitem>
          <listitem>SMTP sunucu </listitem>
          <listitem>FTP sunucu </listitem>
          <listitem>listitemST sunucu </listitem>
          <listitem>NEWS sunucu</listitem>
        </itemizedlist>
      </para><para>
        gibi yaygın TCP/IP servislerinin yanısıra
      </para><para>
        <itemizedlist>
          <listitem>
            NOVELL sunucu (Novell protokolü kullanarak disk ve yazıcı servisi)
          </listitem><listitem>
            SAMBA sunucu (Windows 3.1, Windows95, Windows NT ve
            WfW için disk ve yazıcı servisi)
          </listitem><listitem>
            APPLETALK sunucu (MacOS kullanan Apple makinalar için
            disk ve yazıcı servisi)
          </listitem>
        </itemizedlist>
      </para><para>
        verebilmektedir.
      </para>
    </sect2><sect2>
      <title>Ağ Elemanı</title>
      <para>
        Linux yazılım desteği ile birçok ağ elemanının yerine geçebilecek bir
        alternatif olarak kullanılabilmektedir. Birden fazla ağın birbirine
        bağlanması amacıyla bir <emphasis>yönlendirici (router)</emphasis> olarak da
        kullanılabilmektedir. Özellikle farklı protokoller arası bir geçiş
        elemanı olarak yaygın şekilde Linux'tan yararlanılmaktadır.
        Ayırca yönlendirici olarak kullanıldığında kolaylıkla güvenlik amacıyla
        <emphasis>güvenlik duvarı (firewall)</emphasis> olarak yapılandırılabilmektedir. Buna ek
        olarak bir ağ üzerinde bulunan iki segmanın trafiğini birbirinden
        ayıran bir <emphasis>köprü (bridge)</emphasis> olarak da hizmet verebilmektedir. Birçok
        kurumda bir veya daha çok modemin bağlanması amacıyla bir <emphasis>terminal
        sunucu (terminal server)</emphasis> olarak Linux kullanılmaktadır.
      </para>
    </sect2>
  </sect1>
  <sect1 id="archive-tlkg-lis-1.3">
    <title>Nereden Linux Bulabilirim?</title>
    <para>
      Linux işletim sistemiminin temelini oluşturan çekirdek, bu çekirdeğin
      kullandığı destek kütüphaneleri ve uygulama yazılımları bir araya
      getirilerek, yükleme yazılımları da eklenerek Linux dağıtımları meydana
      getirilmektedir. Bu dağıtımlar temel olarak bir kullanıcının Linux
      kullanmak için ihtiyaç duyabileceği bir çok yazılımı bir araya
      getirirler. Bu dağıtımların çoğu Internet üzerinde anonim FTP
      arşivlerinde bulunabilmektedirler. Internet erişimi bulunmayan
      kişilerinde (veya Internet'ten 120 Mbyte kopyalamak istemeyen
      kişilerin) yararlanabilmesi için çesitli CD-ROM şirketleri tarafından
      CD-ROM üzerinde dağıtımlar meydana getirilmiştir.
    </para><para>
      Linux dağıtımları ve bunların nereden temin edilebileceği hakkında
      ayrıntılı bilgi, <xref linkend="archive-tlkg-lis-2"/> başlığı altında
      bulunabilir.
    </para>
    <sect2>
      <title>Belge Temini</title>
      <para>
      Linux hakkında yazılan kitapların sayısı gün geçtikçe artmaktadır. Yine
      de en güncel bilgi Internet üzerinde bulunmaktadır. Elektronik ortamda
      bulunan iki temel belge çeşidi bulunmaktadır. Bunlar:
      </para><para>
        <orderedlist>
        <listitem>
          <ulink url="http://w3.metu.edu.tr/ldp">Linux Documentation Project</ulink></listitem>
        <listitem>
          <ulink url="ftp://ftp.metu.edu.tr/pub/sunsite/docs/HOWTO/">NASIL (HOWTO)</ulink> </listitem>
        </orderedlist>

      </para><para>
        belgeleridir. NASIL belgelerinin bir kısmının Türkçeye çevrilmesi işlemi devam
        etmektedir. Şu ana kadar çevrilen belgeleri
        <ulink url="http://linux.org.tr">Linux Kullanıcıları</ulink> Grubu WWW
        sayfasından bulabilirsiniz.
      </para>
    </sect2>
  </sect1>
  <sect1 id="archive-tlkg-lis-1.4">
    <title>Yazılım Özellikleri</title>
    <para>
      Bir işletim sistemi, ne kadar mükemmel olursa olsun, uygulama
      yazılımlarının çokluğu ve kalitesi ile varolabilirler. Herhangi bir
      Linux dağıtımı içerisinde, değişik amaçlara hizmet eden birçok yazılım
      bulunmaktadır. Ancak her geçen gün bu dağıtımlarda yer almayan yeni
      yeni yazılımlar çıkmaktadır.
    </para><para>
      UNIX makinalar üzerinde yer alan uygulamaların çoğu, değişik
      platformlar altında bulunduğundan çalıştırılabilir (executable) olarak
      dağıtılmaz, kaynak kodu şeklinde sunulurlar. Sözkonusu yazılımı
      kullanmak isteyen bir kullanıcı bu kaynak kodunu kendi platformunda
      derleyerek çalıştırır. Bu tür yazılımların birçoğu Linux altında
      kolaylıkla çalıştırılabilmektedir. Bu tür yazılımları Internet üzerinde
      çeşitli FTP arşivlerinde bulmak mümkündür.
    </para><para>
      Linux'a özel veya Linux üzerinde geliştirilen yazılımlar için standart
      bazı FTP arşivleri vardır. Bunların en bilineni
      <ulink url="ftp://sunsite.unc.edu/pub/Linux">Sunsite FTP arşivi</ulink>dir.
      Burada çeşitli dizinler altında konularına göre
      ayrılmış bir durumda elektronik devre tasarım yazılımlarından oyun
      programlarına kadar birçok değişik yazılım bulunmaktadır. Bu arşivin
      Türkiye'de yeralan bir kopyası
      <ulink url="ftp://ftp.metu.edu.tr/pub/linux/sunsite"/> adresinde vardır.
    </para><para>
      Linux'un bu denli sevilmesi ve yaygınlaşması çesitli şirketlerin
      (Macintosh, Sun, SSC gibi) Linux üzerinde çalışan ticari yazılımlar
      geliştirmesi sonucunu verdi. Bu konuda ayrıntılı bilgi için
      <emphasis>Commercial-HOWTO</emphasis> belgelerinden yararlanabilirsiniz.
    </para><para>
      Linux üzerinde bulunan uygulamaların ve yazılımların listeleri için
      aşağıdaki adreslerden yararlanabilirsiniz:
    </para><para>
      <itemizedlist>
      <listitem>
        <ulink url="http://www.redhat.com/linux-info/linux-app-list/linapps.html"
        >Linux Applications and Utilities</ulink>
      </listitem><listitem>
        <ulink url="http://sal.kachinatech.com">Scientific Applications on Linux</ulink>
      </listitem><listitem>
        <ulink url="http://www.execps.com/lsm">Linux Software Map</ulink>
      </listitem>
      </itemizedlist>
    </para>
    <sect2>
      <title>Temel Komutlar</title>
      <para>
        Daha önce UNIX tabanlı bir işletim sisteminde çalışanlar için Linux,
        öğrenilmesi çok kolay bir sistem olacaktır. Standart bir UNIX
        sisteminde yeralan hemen hemen tüm komutlar, Linux'a taşınmıştır.
        Onlarca çeşit kabuğun yanı sıra, <literal>sed</literal>, <literal>awk</literal> gibi programcının işini
        kolaylaştıran diller, <literal>ls, less, finger</literal> gibi temel her türlü komut,
        Linux'ta vardır.
      </para><para>
        Ağ ve Internet uygulamaları için <literal>elm</literal> ve <literal>pine</literal> (Pine Is Not Elm :-)
        yanında metin editörleri olarak <literal>vi, vim</literal> (vi'ın daha gelişmiş sürümü),
        <literal>pico</literal> ve <literal>joe</literal> sayılabilir. Editörlerden, bizde fazla bilinmeyen Emacs da
        Linux altında denemeye değer programlardandır. Kelime işlem
        programlarından <literal>troff, groff</literal> (GNU roff) ve daha modern metin işleme
        yazılımlarından <literal>TeX</literal> ve <literal>LaTeX</literal> sayılabilir.
      </para><para>
        Bazı program isimlerinin (GNU-tar, GNU-bash gibi) başında görebileceğiniz
        <emphasis>GNU</emphasis> (Gnu is Not UNIX!), Linux için de yazılım ve programlar
        üreten bir kuruluştur. GNU, lisansını ve yazarını korumak koşuluyla
        programları kaynak koduyla birlikte Linux kullanıcılarına dağıtır. GNU
        <literal>bash</literal> ve <literal>tcsh</literal>, Linux altında en çok rağbet edilen iki kabuk
        ismidir. Diğer kabuklar arasında <literal>zsh</literal>, <literal>ash</literal>, <literal>ksh</literal> ve <literal>csh</literal>
        sayılabilir. Kabuklar hakkında daha geniş bilgiyi, <xref linkend="archive-tlkg-lis-6"/> konu başlığı
        altında bulabilirsiniz.
      </para>
    </sect2><sect2>
      <title>Uygulama Programları</title>
      <para>
        Linux üzerinde ver tabanı uygulamaları ortalama bir kullanıcının
        ihtiyacını karşılayabilir.
        <ulink url="http://www.postgresql.org">Postgres</ulink>, <literal>Mbase</literal>,
        <literal>msql</literal> ve <literal>Ingres</literal> gibi profesyonel
        yazılımlar Linux ve diğer platformlarda istemci/sunucu bazda görev
        yapabilirler. Özellikle Postgres, uygulama kolaylığı ve C, perl, tcl
        gibi birçok dile yönelik arabirimiyle göze çarpar.
      </para><para>
        Mühendislik yazılımları arasında <literal>gnuplot</literal> (grafiksel veri analiz
        yazılımı), <literal>xspread</literal> ve <literal>xfractint</literal> (fraktal yaratma programı)
        sayılabilir.
      </para><para>
        Doğru seçilmiş bir donanım üzerinde kurulan bir Linux makinası, hemen
        her tür çokluortam (multimedia) uygulamalarını rahatlıkla
        çalıştırabilir. En az Pentium tabanlı, 32Mbayt RAM ve 2GB sabit diske
        sahip makina yardımıyla ticari olarak satılan çokluortam uygulamalarını
        kullanabilirsiniz. Linux, hemen her türlü ses kartını desteklediğinden
        ses dosyalarının, workman, Cdplayer gibi programlar yardımıyla kolayca
        çalınması mümkün olur. MIDI editörleri ve bir sentezleyici ile kendi
        müzik stüdyonuzu kurabilirsiniz.
      </para><para>
        Biraz oyun oynamak mı istediniz? Doom, Quake, Abuse, Xtetris, FreeCiv(ya
        da CivNet), Imaze ve benzeri onlarca oyun Linux'ta da var. ODTÜ'de
        yüzlerce öğrenciyi bilgisayar başına mıhlayan MUD (Multi User Dungeon)
        oyunlarını sunan makinaların birkısmı Linux idi.
      </para><para>
        Bu oyunları çeşitli ftp adrteslerinden ücretsiz temin edebilirsiniz.
      </para>
    </sect2><sect2>
      <title>X Pencere Arabirimi</title>
      <para>
        Linux işletim sistemi altında X Pencere sistemi ile Windows altındaki
        gibi grafik arabirimiyle birlikte çalışabilirsiniz. Windows ile uğraşan
        herkes rahatlıkla X Pencere Arabirimine geçiş yapabilir. X ile ekranda aynı anda
        birden fazla pencere açılabilir, fare yardımıyla birden fazla uygulama
        aynı anda kontrol edilebilir.
      </para><para>
        Pekçok uygulamanın (özellikle Internet tabanlı) X üzerinde çalışan
        sürümleri vardır. Bu sayede metin tabanlı ekrana (vt100) dönmeden her
        işinizi X yardımıyla tamamlayabilme şansınız olur. Bu sayede Linux, bir
        iş istasyonu görünümüne ve kullanışlılığına sahip olacaktır.
      </para><para>
        X pencere denetleyici (window manager - wm) kullanıcı ile X arasında
        bekler ve klavye ile fareden aldığı emirleri ekranda yerine getirir. Bu
        emirler, pencerelerin açılması, kapatılması ve yerlerinin
        değiştirilmesi gibi komutlardır. Sıkça kullanılan pencere
        denetleyicileri <literal>fvwm</literal>, <literal>twm</literal> ve
        <literal>olwm</literal>'dir.
      </para>
    </sect2>
  </sect1>
  <sect1 id="archive-tlkg-lis-1.5">
    <title>Linux ve Diğer İşletim Sistemleri</title>
    <para>
      Linux ve diğer işletim sistemleri arasındaki ilişkiyi, benzerlikleri ve
      farklılıkları bilmek önemlidir. Linux işletim sistemi, diğer sistemler
      ile birlikte aynı sabit diski paylaşabilir. UNIX'i öğrenmek için
      kesinlikle en kolay ve ucuz yol olan Linux, diğer işletim sistemlerine
      karşı her zaman güçlü bir alternatif olmaktadır. Internet servis
      sağlayıcılarının büyük çoğunluğu, Linux kullanmakta, Internet
      bağlantılarını, e-posta ve haber grubu alış-verişini Linux sayesinde
      yapmaktadır.
    </para><para>
      Bir kişisel bilgisayarı satın aldığınız zaman çok büyük ihtimalle
      üzerinde MS-DOS veya türevi bir işletim sistemi yüklenmiş olduğunu
      göreceksiniz. Her kullanıcı o veya bu şekilde MS-DOS ile tanışır.
      MS-DOS,  üzerinde en fazla program yazılan işletim sistemi olmuş, bu
      yüzden modern işletim sistemleri çıkmadan önce her kullanıcının
      kurtarıcısı gözüyle bakılmıştır. Fakat MS-DOS arabirimi programlanırken
      ileriyi düşünemeyen programcılar, bu işletim sistemine Linux'ta olan
      bazı hayati özellikleri kazandıramamışlardır. MS-DOS, çok kullanıcılı bir
      sistem değildir ve aynı anda birden çok işi yapamaz. İsterseniz
      çalıştırılabilecek en geniş programın büyüklüğünü görmek için <literal>mem</literal>
      komutunu kullanmayı deneyin. Linux, sadece üzerindeki hafıza ile
      sınırlıdır. 80x86 tabanlı mikroişlemcinin her özelliğini sonuna kadar
      kullanır. Bunun sonucu olarak verimli bir işletim sistemi sayılabilir.
    </para><para>
      Tüm bu olumsuzluklara rağmen yine de MS-DOS kullanmak istiyorsunuz. Onun
      da kolayını bulmuş Linux programcıları. Ücretsiz dağıtılan MS-DOS ve
      Windows emülatörü yardımıyla MS-DOS altında çalışan programların hemen
      hepsi Linux'la birlikte de çalışabilir. <literal>WinWord 2.0, sysinfo, Civilization ve Qbasic</literal> Linux altında sorunsuz çalışan
      MS-DOS/Windows programlarından birkaçı.
    </para><para>
      Profesyonel bir yatırım sayılabilecek Windows NT'nin
      çokgörevlilik ve hafızayı mükemmel kullanma gibi özellikleri vardır.
      Buna karşılık fiyatı oldukça yüksektir ve çalışmak için gayet yüksek
      standartlı bir makina ister.
    </para><para>
      IBM firmasının geliştirdiği OS/2 de NT'ye benzer şekilde çokgörevli
      işletim sistemi olup fiyat/performans oranı açısından makul
      sayılabilecek bir işletim sistemi olarak göze çarpar.
    </para><para>
      Linux, herkese göre bir işletim sistemi değildir. UNIX'i
      benimsemeyen bir kullanıcıdan Linux'u kullanmasını bekleyemezsiniz.
      Internet'in kendisi UNIX tabanlı olduğu için Linux bu alanda yukarıda
      sözü geçen sistemlerden daha avantajlı bir duruma gelir. Dağıtımı tek
      firmayla sabit olmadığı için geliştirilme aşamasında dünyanın dört bir
      yanından katkı ve destek gelir. UNIX'e belirli bir standart getirilmesi
      için yapılan çalışmalara uyan Linux, POSIX standardını destekler.
    </para><para>
      RedHat, Caldera gibi çeşitli Linux sürümleri da piyasada satılmakta,
      çok zengin bir belge ve arşiv kaynağı ile kullanıcılara
      sunulmaktadır. 80x86 tabanlı işlemciler üzerinde kurulabilen ve
      Internet üzerinde bedava dağıtılan diğer işletim sistemlerinden birisi
      FreeBSD'dir. FreeBSD, bir grup programcı tarafından BSD standartını
      80x86 bilgisayarlara taşımak üzere geliştirilmiştir ve  Linux ile büyük
      benzerlikleri bulunur.
    </para><para>
      Linux işletim sisteminin güvenilir ve sağlam yapısından haberdar
      olmayan, hatta bu gerçeği bilerek ücretli sistemlerdem medet uman
      kişiler vardır. Sabit fikirli olmadan önce bu sistem hakkında daha
      fazla verinin dağıtılması, kullanıcıların bilinçlendirilmesi
      gereklidir. Bu da ancak, Linux'un yapabildiklerini göstermekle
      olabilir.
    </para>
  </sect1>
  <sect1 id="archive-tlkg-lis-1.6">
    <title>Türkiye'de ve Dünyada Linux</title>
    <para>
      Eğer Linux'u sever ve bu sistemin yaygınlaşmasında, bihaber
      kullanıcılara tanıtımında öncülük etmek isterseniz, bu bölüm tam size
      göredir.
    </para><para>
      Henüz tüzel kişiliği olmayan
      <ulink url="http://www.linux.org.tr">Türkiye Linux Kullanıcıları Grubu sayfası</ulink> Türkiye'de Linux çalışmaları için iyi
      bir başlangıç noktasıdır.
      Türkçe ve İngilizce Türkiye'deki en geniş kapsamlı Linux sunucusunun
      genişlemesinde yeni fikirlere, çözüm önerilerine ihtiyaç vardır. Bu da
      ancak Linux seven bir kitlenin varlığıyla mümkündür.
    </para><para>
      Dünyada ve Türkiye'de Internet Servis Sağlayıcıları (İSS) Linux'u
      uzunca bir süredir ticari olarak kullanıyorlar. Uygulama yazılımları da
      bu yönde kullanıcıların hizmetine sunuluyor. Fakat güvenlik sorunları
      nedeniyle Linux kullanan servis sağlayıcıları, müşterilerini bu
      hizmetten yoksun tutuyorlar. Açık sistem kavramının yaygınlaşması da bu
      sebepten dolayı sekteye uğruyor.
      <ulink url="http://www.10mb.com/linux/">http://www.10mb.com/linux/</ulink>
      adresinde, ticari uygulama yazılımlarına destek veren bir proje
      yeralmakta.
    </para><para>
      <ulink url="http://www.scc.com">SSC (Specialized Systems Consultants)</ulink>,
      ``Linux Journal'' adında bir
      dergiyi başarıyla dağıtıyor. Tirajı onbinleri bulan bu aylık dergide bu
      işletim sistemini aktif kullanan herkes için, her konuda, her düzeyde
      makale bulmak mümkündür.
    </para>
  </sect1>
  <sect1 id="archive-tlkg-lis-1.7">
    <title>Linux ve Donanım Desteği</title>
    <para>
      Bir işletim sisteminin tüm kartları tanıması, tüm sabit disklerle
      çalışabilmesi, tüm giriş/çıkış kartlarıyla uyum içinde çalışması mümkün
      değildir. Bu konuda çok iddalı olan tak-çalıştır sistemine sahip
      Windows95 bile bazen yetersiz kalabilmekte. Linux da piyasada yeralan
      hemen hemen bütün donanımlarla birlikte çalışabilir.
    </para><para>
      Linux, üzerinde matematiksel işlemci olsun veya olmasın Intel
      386SX/DX, 486SX/DX/SX2/DX2/DX4, Pentium ve PentiumPro işlemcilerde sorunsuz
      çalışır. Bunlarla beraber (Cyrix 486 tabanlı işlemcilerinde nadiren sorun
      çıkarsa da) AMD, Cyrix gibi firmaların işlemcileri de Linux tarafından
      desteklenir. Matematik işlemcisi olmayan bilgisayarlarda Linux'un beyni
      sayılan çekirdek, matematik işlemcisine gerek duyulan kod parçalarında
      bu işlemciyi emüle edebilir. Burada belirtilen IBM uyumlu PCler dışında
      ALPHA, PowerPC, MIPS, farklı Sparc modelleri, PA-RISC gibi birçok farklı
      işlemciye de başarılı bir şekilde taşınmıştır.
    </para><para>
      Linux, kişisel bilgisayarlarda kullanılan ISA, VLB (Vesa Local Bus -
      yerel veri yolu), EISA, MCA (IBM Microchannel) veya PCI veriyolu
      mimarisi ile çalışabilirler.
    </para><para>
      Linux, SMP (symmetric multi processor) olarak da bilinen birden fazla
      işlemcili bilgisayarlar üzerinde de çalışabilir ve birden fazla işlemciyi
      en verimli şekilde kullanır.
    </para><para>
      Kişisel bilgisayarların kullandığı 80x86 tabanlı işlemciler dışında,
      taşınan ve sorunsuzca  çalıştığı bilinen işlemciler ve bilgisayarlar
      ile konu hakkında daha fazla bilgi alınabilecek Internet adresleri
      aşağıda verilmiştir.
    </para><para>
      <itemizedlist>
        <listitem>
          <ulink url="http://www-users.informatik.rwth-aachen.de/~hn/linux68k.html"
          >Linux/68000</ulink>
        </listitem><listitem>
          <ulink url="http://www.waldorf-gmbh.de/linux-mips-faq.html"
          >Linux/MIPS</ulink>
        </listitem><listitem>
        <ulink url="ftp://sunsite.unc.edu/pub/Linux/docs/ports/Linux-PowerPC-FAQ.gz">Linux/PowerPC</ulink> </listitem>
        <listitem>
          <ulink url="http://www.ph.kcl.ac.uk/~amb/linux.html"
          >Linux for Acorn</ulink>
        </listitem><listitem>
          <ulink url="http://www.mklinux.apple.com">MacLinux</ulink>
        </listitem><listitem>
          <ulink url="http://www-c724.uibk.ac.at/XL/">Compaq Deskpro XL</ulink>
        </listitem><listitem>
          <ulink url="ftp://invaders.dcrl.nd.edu/pub/misc/">IBM PS/2 MCA systems</ulink>
        </listitem><listitem>
          <ulink url="http://domen.uninett.no/~hta/linux/aero-faq.html"
          >Compaq Contura Aero</ulink>
        </listitem><listitem>
          <ulink url="http://peipa.essex.ac.uk/tp-linux/tp-linux.html"
          >IBM ThinkPad</ulink>
        </listitem><listitem>
          <ulink url="http://lena.fnet.fr/">Linux/MIPS</ulink>
        </listitem><listitem>
          <ulink url="http://www.azstarnet.com/~axplinux/">Linux/Alpha</ulink>
        </listitem><listitem>
          <ulink url="http://www.osf.org/mall/os/pa-mklinux/index.html">HP PA-RISC</ulink>
        </listitem><listitem>
          <ulink url="http://www.geog.ubc.ca/sparclinux.html">SPARC/Linux</ulink>
        </listitem>
      </itemizedlist>
    </para><para>
      Linux, metin modu kullanırken tüm ekran kartlarıyla (Hercules, CGA, EGA,
      CGA, IBM monokrom) sorunsuz çalışır. X Pencere çalıştırmak isterseniz
      hızlandırılmış bir SVGA kart önerilir. Sürekli yenileri eklense de aşağıda
      şu anda desteklenen kartların tam listesi vardır.
    </para><para>
      <itemizedlist>
        <listitem>Hercules mono</listitem>
        <listitem>VGA / VGA Mono</listitem>
        <listitem>EGA</listitem>
        <listitem>ARK Logic ARK1000PV/2000PV, ARK1000PV/VL</listitem>
        <listitem>ATI VGA Wonder, ATI Mach32, ATI Mach8, ATI Mach64</listitem>
        <listitem>Cirrus 542x, 543x, 62x5, 6420/6440</listitem>
        <listitem>OAK OTI-037/67/77/87</listitem>
        <listitem>Trident TVGA8900, TVGA8800, TVGA9xxx</listitem>
        <listitem>Tseng ET3000/ET4000/W32, ET4000/W32/W32i/W32p, ET4000AX</listitem>
        <listitem>IBM 8514/A, IBM XGA, XGA-II</listitem>
        <listitem>IIT AGX-010/014/015/016 (16 bpp)</listitem>
        <listitem>Oak OTI-087, OTI-067, OTI-077</listitem>
        <listitem>S3 911, 924, 801, 805, 928, 864, 964, Trio32, Trio64, 868, 968</listitem>
        <listitem>Weitek P9000 (16/32 bpp)</listitem>
        <listitem>Diamond Viper VLB/PCI</listitem>
        <listitem>Orchid P9000</listitem>
        <listitem>Western Digital PVGA1, WD90C00/10/11/24/30/31/33</listitem>
        <listitem>Avance Logic AL2101/2228/2301/2302/2308/2401</listitem>
        <listitem>Chips &amp; Technologies 65520/65530/65540/65545</listitem>
        <listitem>Compaq AVGA</listitem>
        <listitem>Genoa GVGA</listitem>
        <listitem>MCGA (320x200)</listitem>
        <listitem>MX MX68000/MX68010</listitem>
        <listitem>NCR 77C22, 77C22E, 77C22E+</listitem>
        <listitem>RealTek RTG3106</listitem>
        <listitem>Video 7 / Headland Technologies HT216-32</listitem>
        <listitem>Western Digital/Paradise PVGA1, WD90C00/10/11/24/30/31/33</listitem>
        <listitem>Hyundai HGC-1280</listitem>
        <listitem>Sigma LaserView PLUS</listitem>
      </itemizedlist>
    </para>
    <sect2>
      <title>Sabit Diskler ve Sabit Disk Denetleyicileri</title>
      <para>
        Linux, standart IDE, bazı ESDI, hemen hemen tüm SCSI ve nadiren
        kullanılsa da MFM ve RLL denetleyicilerini desteklerler. Aslında Linux
        çalıştırmak için sabit diske gerek yoktur. Ağ üzerinden, Bootp
        protokolü yardımıyla Linux yüklü başka bir bilgisayarın kaynaklarını
        kullanmak mümkündür. Sabit disk denetleyiciniz en az 16 bit olmalıdır.
        Genellikle MS-DOS altında sorunsuz çalışan her sabit diski Linux da
        görebilir.
      </para><para>
        Sabit disk üzerinde Linux için bir miktar yer ayırmalısınız. Birden
        fazla disk de kullanabilirsiniz, Linux her diski ayrı bir dizin
        altından erişebilir. Bu konuda daha geniş bilgiyi Linux kurulumu
        bölümünde bulabilirsiniz.
      </para><para>
        Sabit diskler, denetleyicileri desteklendiği sürece Linux altında
        kullanılabilirler. Artık neredeyse tüm CD-ROM'lar SCSI denetleyicilerle
        çalışıyorlar. Bir SCSI denetleyiciniz varsa makinanız CD-ROM'u da
        tanıyacaktır. Linux, CD-ROM'ların standart iso9660 dosya sistemini de
        tanır.
      </para><para>Desteklenenen kartlar,</para><para>
        <itemizedlist>
          <listitem>AMI Fast Disk VLB/EISA</listitem>
          <listitem>Adaptec AVA-1505/1515, AHA-1510/152x, AHA-154x, AHA-174x, AHA-274x, AHA-2940/3940, ACB-40xx</listitem>
          <listitem>Always IN2000</listitem>
          <listitem>BusLogic (ISA/EISA/VLB/PCI)</listitem>
          <listitem>DPT PM2001, PM2012A (EATA-PIO)</listitem>
          <listitem>DTC 329x (EISA) (Adaptec 154x compatible)</listitem>
          <listitem>Future Domain TMC-16x0, TMC-3260 (PCI), TMC-8xx, TMC-950</listitem>
          <listitem>Media Vision Pro Audio Spectrum 16 SCSI (ISA)</listitem>
          <listitem>NCR 5380 generic, 53c400, 53c406a, 53c7x0, 53c8x0 (PCI)</listitem>
          <listitem>Qlogic / Control Concepts SCSI/IDE (FAS408) (ISA/VLB)</listitem>
          <listitem>Seagate ST-01/ST-02 (ISA)</listitem>
          <listitem>SoundBlaster 16 SCSI-2 (ISA)</listitem>
          <listitem>Trantor T128/T128F/T228 (ISA)</listitem>
          <listitem>UltraStor 14F (ISA), 24F (EISA), 34F (VLB)</listitem>
          <listitem>Western Digital WD7000 SCSI</listitem>
          <listitem>AMD AM53C974, AM79C974 (PCI)</listitem>
          <listitem>Adaptec SCSI-MFM/RLL bridgeboard</listitem>
          <listitem>Iomega PC2/2B</listitem>
          <listitem>Qlogic (ISP1020) (PCI)</listitem>
          <listitem>Ricoh GSI-8</listitem>
        </itemizedlist>
      </para>
    </sect2><sect2>
      <title>Ethernet Kartları</title>
      <para>
      Piyasada çok çeşitli ethernet kartları vardır. Genellikle yaygın olarak
      kullanılanlar 3Com veya NE2000 uyumlulardır. Aşağıda desteklenen
      ethernet kartların bir listesi yeralmaktadır. PCMCIA, Tokenring, ISDN,
      AX25 kartlarının uyumlu olanları, çok nadir kullanıldıkları için
      burada belirtilmeyecektir.
      </para><para>
        <itemizedlist>
          <listitem>3Com 3C501, 3Com 3C503, 3C505, 3C507, 3C509/3C509B (ISA) / 3C579 (EISA)</listitem>
          <listitem>AMD LANCE (79C960) / PCnet-ISA/PCI (AT1500, HP J2405A,</listitem>
          <listitem>NE1500, NE2100, NE2000, NE1000</listitem>
          <listitem>AT&amp;T GIS WaveLAN</listitem>
          <listitem>Allied Telesis AT1700</listitem>
          <listitem>Ansel Communications AC3200 EISA</listitem>
          <listitem>Apricot Xen-II</listitem>
          <listitem>Cabletron E21xx</listitem>
          <listitem>DEC DE425 (EISA) / DE434/DE435 (PCI), DEC DEPCA</listitem>
          <listitem>HP PCLAN 27245,  27247, 27252A, 10/100VG PCLAN</listitem>
          <listitem>Intel EtherExpress, EtherExpress Pro</listitem>
          <listitem>New Media Ethernet</listitem>
          <listitem>Racal-Interlan NI5210, NI6510</listitem>
          <listitem>PureData PDUC8028, PDI8023</listitem>
          <listitem>SEEQ 8005</listitem>
          <listitem>SMC Ultra</listitem>
          <listitem>Schneider &amp; Koch G16</listitem>
          <listitem>Western Digital WD80x3</listitem>
          <listitem>Zenith Z-Note / IBM ThinkPad 300 built-in adapter</listitem>
        </itemizedlist>
      </para>
    </sect2><sect2>
      <title>Ses Kartları</title>
      <para>
      Linux üzerinde hemen her türlü ses kartı desteği var. SoundBlaster16
      ses kartlarının üzerinde ASP çipi veya 4.11 ve 4.12 DSP (digital signal
      processor - sayısal ses işleyici) bulunanları Linux üzerinde
      kullanamazsınız.
      </para><para>Desteklenen ses kartları,</para><para>
        <itemizedlist>
          <listitem>6850 UART MIDI</listitem>
          <listitem>Adlib (OPL2)</listitem>
          <listitem>Audio Excell DSP16</listitem>
          <listitem>Aztech Sound Galaxy NX Pro</listitem>
          <listitem>Crystal CS4232</listitem>
          <listitem>CHO-PSS (Orchid SoundWave32, Cardinal DSP16)</listitem>
          <listitem>Ensoniq SoundScape</listitem>
          <listitem>AWE 32 </listitem>
          <listitem>Gravis Ultrasound, Gravis Ultrasound MAX</listitem>
          <listitem>Logitech SoundMan Games, Logitech SoundMan Wave</listitem>
          <listitem>Logitech SoundMan 16 (PAS-16 uyumlu)</listitem>
          <listitem>MPU-401 MIDI</listitem>
          <listitem>MediaTriX AudioTriX Pro</listitem>
          <listitem>Media Vision Premium 3D (Jazz16), Pro Sonic 16 (Jazz), Pro Audio Spectrum 16</listitem>
          <listitem>Microsoft Sound System (AD1848)</listitem>
          <listitem>OAK OTI-601D cards (Mozart)</listitem>
          <listitem>OPTi 82C928/82C929 cards (MAD16/MAD16 Pro)</listitem>
          <listitem>Sound Blaster, Sound Blaster Pro, Sound Blaster 16</listitem>
          <listitem>Turtle Beach Wavefront cards (Maui, Tropez)</listitem>
          <listitem>Wave Blaster</listitem>
        </itemizedlist>
      </para>
    </sect2><sect2>
      <title>Fare</title>
      <para>
        Linux, <literal>Microsoft serial mouse, Mouse Systems serial mouse, Logitech
        Mouseman serial mouse, Logitech serial mouse, ATI XL Inport busmouse,
        Microsoft busmouse, Logitech busmouse</literal> ve
        <literal>PS/2 mouse</literal> destekler.
      </para><para>
        Genellikle kullanacağınız farenin türü Microsoft ya da Mouse Systems
        serial mouse olacaktır.
      </para>
    </sect2><sect2>
      <title>Modem, Yazıcı ve Oyun Çubuğu</title>
      <para>
        Hem internal (kasa içine takılan) hem de external (kasanın dışında kalan)
        tüm modemler Linux tarafından desteklenir. Aynı şekilde paralel veya
        seri porta takılan her yazıcı ve çizici desteklenir. İsterseniz bunları
        yerel bir ağ üzerinden birden fazla makinaya paylaştırabilirsiniz. Linux
        altında <literal>lpr</literal> yazılımı, yazıcılara erişimi sağlamak için
        kullanılır.
      </para><para>
        Oyun çubukları için sürücüler ister doğrudan çekirdeğe eklenebilir,
        istenirse de modül olarak derlenebilir.
      </para><para>
        Aşağıda, Linux'un desteklediği giriş/çıkış kartlarının geniş bir listesi
        vardır.
      </para><para>
        <itemizedlist>
          <listitem>AST FourPort and clones</listitem>
          <listitem>Accent Async-4</listitem>
          <listitem>Arnet Multiport-8</listitem>
          <listitem>Bell Technologies HUB6</listitem>
          <listitem>Boca BB-1004, 1008, BB-2016, IO/AT66, IO 2by4</listitem>
          <listitem>Computone ValuePort</listitem>
          <listitem>DigiBoard PC/X (4, 8, 16 port)</listitem>
          <listitem>Comtrol Hostess 550 (4, 8 port)</listitem>
          <listitem>PC-COMM 4-port (4 port)</listitem>
          <listitem>SIIG I/O Expander 4S (4 port, uses 4 IRQ's)</listitem>
          <listitem>STB 4-COM (4 port)</listitem>
          <listitem>Twincom ACI/550</listitem>
          <listitem>Usenet Serial Board II (4 port)</listitem>
          <listitem>Cyclades Cyclom-8Y/16Y (8, 16 port) (ISA/PCI)</listitem>
          <listitem>Stallion EasyIO, EasyConnection 8/32, 8/64</listitem>
        </itemizedlist>
      </para>
    </sect2>
  </sect1>
  <sect1 id="archive-tlkg-lis-1.8">
    <title>Linux'un Getirileri ve Götürüleri</title>
    <para>
      Pekçok insan, ``neden Linux?'' diye sorabilir. Belki de cevap önce
      kullanıcının kendini tanıması ile bulunabilir. Değişik yerlerde Linux
      kullanılması ve bunun sonuçları hakkında gözlemlediklerimizin ışığı
      altında çok kabaca:
    </para><para>
      Eğer,
    </para><para>
      Bilgisayarla ilişkiniz belirli paket programlara dayanıyorsa,
      bilgisayar kullanmak için bilgisayar konusunda bilgi sahibi olmanız
      gerektiğine inanmıyorsanız, bilgisayar ile uğraşmak hoşunuza
      gitmiyorsa, sorunlarınızı kendi başınıza çözmeyi denemekten
      hoşlanmıyorsanız, bir sorun çıktığında para vererek de olsa bu
      sorununuzu birisi aracılığı ile çözmek istiyorsanız
    </para><para>
      Linux kesinlikle size göre değil.
    </para><para>
      Ama eğer,
    </para><para>
      Bilgisayarınızla ilgilenmekten hoşlanıyorsanız, bilgisayarda çıkan
      problemlerle uğraşmak hoşunuza gidiyorsa, diğer işletim sistemlerinin
      sizi sıktığına ve sınırladığına inanıyorsanız, donanımınızdan daha çok
      performans istiyorsanız, UNIX işletim sistemi ile çalışmayı
      seviyorsanız
    </para><para>
      Linux size göre olabilir.
    </para>
    <sect2>
      <title>Getirileri</title>
      <para>
        UNIX işletim sistemine sahip bir bilgisayar kullanmak istiyorsanız ve
        bu işletim sisteminde platforma bağımlı bir yazılım kullanmıyorsanız,
        Linux ideal bir çözümdür.
      </para><para>
        Linux ücretsizder. Sadece işletim sisteminin maliyeti açısından değil,
        verdiği performans için ihtiyaç duyduğu donanım açısından da çok
        ucuzdur. Üstüne üstlük çok kullanılan ve bol yedek parçası bulunan bir
        platform altında çalıştığı için belirli bir Linux sisteminin
        performansını artırmak için yapılması gereken yatırım başka bir UNIX iş
        istasyonunu aynı oranda geliştirmek için gereken yatırıma göre çok
        düşüktür. Herhangi bir Sun bilgisayarın hafizasını iki katına çıkarmak
        için harcanacak para ile bir Linux-PC'nin hafizasını iki katına
        çıkarmak için harcanması gereken parayı kıyaslamayı deneyin. Fakat
        şirketler bazında Linux'un bedava bir işletim sistemi olması genelde
        gözardı edilir.
      </para><para>
        Bir Linux makine bu sayede sadece işletim sistemi açısından değil
        donanım olarak da ucuza gelmektedir.
      </para><para>
        Linux hızla geliştirilmektedir. Bu gelişimin en büyük yararı,
        eksikliklerin kullanıcıların talepleri ve çabaları sonucunda hızla
        giderilmesidir. Linux diğer tüm işletim sistemlerine göre belirli bir
        donanım için daha hızlı destek verebilmektedir.
      </para><para>
        Linux çok değişik donanımlar ve servisler icin özel olarak hazırlanır.
        İşletim sisteminin temelini oluşturan çekirdek kullanıcı tarafından da
        derlenebildiği için, bu derleme sırasında sadece kullanım amacına
        yönelik alt programlarla donatılır. Bu genel olarak daha sistemin
        performansını artırmaktadır. (Örnek olarak SCSI donanımınız yoksa
        çekirdeğinizde SCSI ile ilgili alt programlara yer vermezsiniz)
      </para>
    </sect2><sect2>
      <title>Dezavantajları</title>
      <para>
        Linux'un serbestçe dağıtılıyor olması bir çok kişinin bu işletim
        sistemine güvenmemesine yol açmıştır. ``Ciddi bir şey olsa, bedava
        olmazdı !'' kanısı oldukça yaygındır.
      </para><para>
        Linux'un sürekli gelişiyor olması en büyük dezavantajlarından biridir.
        Henüz tüm ihtiyaçlara cevap vermemesi (hala Windows95 programlarını
        çalıştıramıyor :) ), gelişimin bazı aşamalarında topyekün değişiklikler
        yapılması, gelişimi takip etmek için bazen sürekli yenileme yapılması,
        birçok kullanıcının bu işletim sistemine güvenmemesine yol açmıştır.
      </para><para>
        Linux herhangi bir ticari destek altında gelişmemektedir. Bunun en
        büyük yararı işletim sisteminin ticari kaygılar taşımamasıdır. Ancak
        bunun yanısıra diğer işletim sistemlerinde olan teknik destek, dağıtım
        ve belgelendirme alanlarında eksikleri vardır. Özellikle teknik destek
        eksikliği, anahtar teslim çözümlere alışmış kullanıcıların çokluğu
        Linux kullanıcılarının sayısını sınırlayan temel faktörler
        olmuşlardır.
      </para><para>
        Bu konudaki eksikliği gidermek için çeşitli gönüllü kuruluşlar,
        kullanıcı grupları oluşmuştur. Zamanla Linux teknik desteği ticari bir
        konu olarak ortaya çıkmıştır. Şu anda tüm dünyada Linux çözümleri
        konusunda teknik destek veren danışmanlar bulunmaktadır. Bu kişiler ve
        kurumlar hakkında ayrıntılı bilgiyi <emphasis>Consultants-HOWTO</emphasis> belgesinde
        bulabilirsiniz.
      </para><para>
        Linux işletim sistemini geliştirenlerin ticari kaygılar gütmemeleri
        bazı ticari yazılımların Linux üzerinde gelişmemesine sebep olmuştur.
        Linux üzerinde belirli konularda diğer işletim sistemlerinden aşağı
        kalmayan yazılımlar bulunmasına rağmen, belirli bazı konularda çok
        zayıf kalmıştır. ( Mesela oyunlar :) )
      </para><para>
        Linux üzerinde yer alan çözümlerin hepsi, basit kullanıcıların rahatça
        kullanabileceği düzeyde değildir. Bazı çözümler kullanıcıların belirli
        bir yazılım ve işletim sistemi bilgisine sahip olmalarını
        gerektirmektedir.
      </para><para>
        Sonuç olarak: Biz uzun süre Linux kullandık ve çok zevk aldık. Diğer
        işletim sistemleri ile yapamadığımız birçok uygulamayı Linux sayesinde
        gerçekleştirdik. Belirli bir donanım ile gösterdiği performansın bir
        çok işletim sisteminin üzerinde olduğunu gördük. Ne var ki her uygulama
        için Linux'un ideal bir çözüm olarak ortaya çıkmadığının bilincinde
        olmak gerekir. Belki ilerleyen senelerde üzerinde geliştirilen uygulama
        yazılımları daha çok kişiyi başka işletim sistemleri kullanmaktan
        vazgeçirecektir.
      </para>
    </sect2>
  </sect1>
</chapter>

<chapter id="archive-tlkg-lis-2">
  <title>Linux Kurulumu ve Başlangıç</title>
  <sect1 id="archive-tlkg-lis-2g">
    <title>Giriş</title>
    <para>
      Linux hakkında ilk belgeler yazıldığında, Linux çalıştırabilecek
      bilgisayarların özellikleri önemliydi. Linux 32 bitlik bir işletim
      olduğundan en az 80386SX işlemcilerle çalışmaktadır. 8086 ve 80286
      işlemcili IBM-PC uyumlu kişisel bilgisayarlar Linux tarafından
      desteklenmemektedir. Hafıza olarak en az 4 Mbyte RAM (yoğun işlemler
      için 12 veya 16) tavsiye edilmektedir. Teknik olarak 2 Mbyte ile de
      çalışabilmesi gerekir. Pratik olarak bugün piyasada bulunan hemen hemen
      her IBM-PC uyumlu kişisel bilgisayarda Linux çalışabilmektedir.
    </para><para>
      8 Mbyte RAM'a sahip herhangi bir 486 üzerinde hemen hemen her türlü
      uygulama rahatlıkla çalıştırılabilmektedir. Tabii ki daha fazla RAM
      ve daha hızlı işlemciler sistemin genel olarak daha hızlı çalışmasını
      sağlayacaklardır.
    </para><para>
      Linux tarafından desteklenen donanımlar her geçen gün değişiyor.
      Bilgisayarınızda bulunan herhangi bir donanımın desteklenip
      desteklenmediğini <emphasis>Hardware-HOWTO</emphasis> dosyasından
      öğrenebilirsiniz.
    </para><para>
      Yine de daha önce yazılanları kısaca tekrar edersek,
    </para><para>
      <orderedlist>
        <listitem>Kişisel bilgisayarlarda INTEL, AMD, CYRIX şirketlerinin tüm 80386, 486, 586, 686, Pentium, PentiumPro işlemcileri </listitem>
        <listitem>Tüm IDE, MFM, RLL sabit diskler</listitem>
        <listitem>Çoğu SCSI sabit disk denetçileri</listitem>
        <listitem>Çoğu ethernet ve G/Ç kartları</listitem>
        <listitem>Birçok VGA, SVGA, EGA, HERCULES görüntü kartları </listitem>
      </orderedlist>
    </para><para>
      Linux tarafından desteklenmektedir.
    </para><para>
      Linux başka işletim sistemleri ile aynı sabit diskte
      bulunabilir. Makinanıza Linux yüklemek için mevcut işletim sisteminizi
      kaldırmak zorunda değilsiniz. Fakat yine de Linux yükleyebileceğiniz bir miktar
      alan ayırmak zorundasınız. Bir bilgisayara Linux yüklemek için bilgisayarınız
      üzerinde bir başka işletim sisteminin bulunmasına gerek yoktur, Linux
      tam anlamıyla kendi başına çalışabilen bir işletim sistemidir.
    </para><para>
      ``Linux sabit disk üzerinde ne kadar yer kaplar?'' sorusuna kesin bir cevap
      vermek oldukça zor, zira bu hangi yazılımları yükleyeceğinize ve ne kadar
      kullanıcı alanı istediğinize çok bağlıdır. Yine de kaba rakamlar vermek
      gerekirse, 40 Mbyte'lık bir alana çalışılabilir durumda ve işinizin
      çoğunu görebilecek bir Linux kurulabilir. Tüm paketleri yüklemeye
      kalktığınızda ise kabaca 250 Mbyte kadar yer kaplayacaktır.
    </para><para>
      Linux, çok çeşitli gruplar tarafından sürekli geliştirilen bir işletim
      sistemidir. Belirli kişiler ve topluluklar Linux için geliştirilen
      temel işletim sistemini ve uygulama yazılımlarını bir araya getirerek
      dağıtımlar oluştururlar. Bir Linux dağıtımı temel olarak bir makineye
      Linux kurmak ve o bilgisayar üzerinde Linux'la çalışmak için gerekecek
      tüm yazılımları ve paketleri içerir, bu yazılımların yüklenmesi için
      bir yükleme yazılımı sağlar.
    </para><para>
      Şu an mevcut çok çeşitli Linux dağıtımları mevcuttur. Bu dağıtımlar
      içerdikleri paketler ve yükleniş şekilleri açısından bazı ufak tefek
      farklılıklar gösterseler de temelde aynı işletim sistemini yüklerler. Bir
      Linux dağıtımı bir araya getirildiği zamandaki güncel işletim sistemini
      içermektedir. Örnek olarak Linux işletim sisteminin temeli olan çekirdek
      neredeyse her hafta yenilenerek  geliştirilmektedir. Oysa dağıtımlar
      senede ancak birkaç kere oluşturulurlar.
    </para><para>
      Linux dağıtımları geleneksel olarak CD'ler halinde hazırlanır.
    </para>
  </sect1>
  <sect1 id="archive-tlkg-lis-2.1">
    <title>Mevcut Dağıtımlar</title>
    <para>
      Yaygın olarak kullanılan dağıtımlar aşağıda yer almaktadırlar.
      Burada anlatılacak olan kurulum bilgileri, Linux Slackware dağıtımına
      sahip olduğunuz farzedilerek hazırlanmıştır.
    </para>
    <sect2>
      <title>Slackware</title>
      <para>
      Belki de en yaygın olarak yer alan dağıtım Slackware dağıtımıdır. Bu
      belge boyunca anlatılacak olan komutlar ve sistem özellikleri Slackware dağıtımına göre
      düzenlenmiştir. Diğer dağıtımlar için anlatılan işlemlerin karşılıkları
      için dağıtım hakkındaki açıklamalara başvurabilirsiniz. Slackware
      dağıtımlarının temin edilebileceği yerler,
      </para><para>
        <itemizedlist>
          <listitem>
            <ulink url="http://www.cdrom.com/titles/slackware.html"
            >Slackware dağıtıcısı Walnut Creek</ulink>
          </listitem><listitem>
            <ulink url="http://ftp.cdrom.com/pub/slackware"
            >Orjinal Slackware FTP arşivi</ulink>
          </listitem>
        </itemizedlist>
      </para><para>
        Türkiye içerisinde Slackware Dağıtımı bulunduran bazı FTP arşivleri:
      </para><para>
        <itemizedlist>
          <listitem>
            <ulink url="ftp://ftp.metu.edu.tr/pub/linux/sunsite/distributions/slackware"
            >Orta Doğu Teknik Üniversitesi</ulink>
          </listitem><listitem>
            <ulink url="ftp://ftp.ege.edu.tr/pub/Linux/">Ege Üniversitesi</ulink>
          </listitem><listitem>
            <ulink url="ftp://ftp.akdeniz.edu.tr/pub/linux"
            >Akdeniz Üniversitesi</ulink>
          </listitem><listitem>
            <ulink url="ftp://ftp.itu.edu.tr/pub/linux/sunsite/distributions/slackware"
            >İstanbul Teknik Üniversitesi</ulink>
          </listitem>
        </itemizedlist>
      </para>
    </sect2><sect2>
      <title>Red Hat</title>
      <para><command>Genel dağıtım</command></para><para>
<literallayout>
  Red Hat Software
  3201 Yorktown Rd, Suite 123 DeKalb Center
  Durham, NC 27713
  Internet adresi:  redhat@redhat.com
</literallayout>
      </para><para>
        <ulink url="http://www.redhat.com">RED-HAT Linux dağıtımı WWW sayfası</ulink>
      </para><para>
        <ulink url="ftp://ftp.redhat.com/pub">Orjinal RED-HAT FTP arşivi</ulink>
        <command>Türkiye içerisinde Red Hat dağıtımı bulunduran FTP arşivleri</command>
      </para><para>
        <ulink url="ftp://ftp.ege.edu.tr/pub/linux/redhat">Ege Üniversitesi</ulink>
        </para><para>
        <ulink url="ftp://ftp.metu.edu.tr/pub/linux/redhat">ODTÜ</ulink>
      </para>
    </sect2><sect2>
      <title>Debian</title>
      <para>
        <command>Genel dağıtım</command>
      </para><para>
<literallayout>
  The Debian Linux Association
  Software in the Public Interest
  P.O. Box 70152
  Pt. Richmond CA 94807-0152
</literallayout>
      </para><para>
        <ulink url="http://www.debian.org">Debian Linux dağıtımı WWW
        sayfası</ulink>
      </para><para>
        <ulink url="ftp://ftp.debian.org/debian">Orjinal Debian FTP arşivi</ulink>
      </para><para>
        <command>Türkiye içerisinde Debian dağıtımı bulunduran FTP arşivleri</command>
      </para><para>
        <ulink url="ftp://ftp.metu.edu.tr/pub/linux/distributions/debian">ODTÜ</ulink>
      </para>
    </sect2><sect2>
      <title>InfoMagic</title>
      <para>
        <command>Genel dağıtım</command>
      </para><para>
<literallayout>
  InfoMagic, Inc.
  PO Box 30370. Flagstaff, AZ 86003-0370
  Tel: (800)-800-6613 (siparis)
  (520)-526-9852 (teknik destek)
  Fax: (520)-526-9573
  Internet adresi: info@infomagic.com
</literallayout>
      </para><para>
        <ulink url="http://www.infomagic.com">InfoMagic WWW sayfası</ulink>
      </para><para>
        Bu konuda daha ayrıntılı ve güncel bilgi için
        <emphasis>Distribution-HOWTO</emphasis>'dan yararlanabilirsiniz.
      </para>
    </sect2>
  </sect1>
  <sect1 id="archive-tlkg-lis-2.2">
    <title>Ne Şekilde Bulabilirim?</title>
    <sect2>
      <title>CD-ROM</title>
      <para>
      Çeşitli dağıtımlara ait CD-ROM'lar çeşitli dükkanlarda
      satılmaktadırlar. Linux aslında ücretsiz bir işletim sistemidir. Alınan
      ücret CD'nin basımı dağıtımı, ambalajını karşılaması için
      alınmaktadır. fiyatları kabaca 1$-30$ mertebesinde
      (bazen birkaç yüz doları da bulabiliyor) değişmektedir. Bazı dağıtımlarda
      telif kitapların bulunması bu dağıtımları daha pahalı yapabilmektedir. Eğer
      herhangi bir şekilde bir Internet erişiminiz yoksa ve bir akademik
      çevrede değilseniz en pratik Linux elde etme yöntemi CD-ROM'lardır.
      </para><para>
      Türkiye içerisinde Linux dağıtımı bulunduran CD-ROM satıcıları,
      </para><para>
<literallayout>
ADA Multimedia Center
Tunus Cad. 70/2 Kavaklıdere Ankara
Tel : (312) 467 37 28
(312) 467 33 32
</literallayout></para>
    </sect2><sect2>
      <title>Internet</title>
      <para>
        Tüm Linux dağıtımları Internet üzerinde anonim FTP hizmeti ile
        sunulmaktadır. Ancak bireysel olarak dağıtımın tüm disketlerini bu
        yolla almak çok pratik olmayacaktır. Örnek olarak son slackware
        dağıtımı 110 Mbyte civarında yer kaplamaktadır. Internet aracıyla
        dağıtım elde etmek, yerel kullanıcılarına yeni dağıtımlar sunmak
        isteyen sistem sorumluları için ilginç bir çözüm olmaktadır.
      </para>
    </sect2><sect2>
      <title>NFS</title>
      <para>
        Bir yerel bilgisayar ağına sahip kurumlarda paylaşılan bir disk alanı
        üzerinden Linux yüklemek mümkündür. Bu sayede CD-ROM veya Internet
        aracılığı ile elde edilen bir dağıtım kurumda ortak bir disk alanına
        yerleştirilir ve ağa bağlı makinalara yükleme yapılabilir.
      </para><para>
        Birçok kurumda Linux yüklemek için, geçici olarak bir ethernet kartı
        takılır, bilgisayar ağ desteği veren bir şekilde açılır ve Linux
        disketleri bu şekilde ağ üzerinden yapılır.
      </para>
    </sect2><sect2>
      <title>Sabit Disk</title>
      <para>
        Herhangi bir şekilde Linux dağıtımı disketleri bir sabit diske de
        kopyalanmış olabilir. Bu durumda mevcut sabit disk üzerindeki disketler
        kullanılarak da yükleme yapılabilir. Bu yöntem yine daha çok eğitim
        kurumlarında başka kaynaklardan elde edilmiş bir Linux dağıtımını
        kopyalamak için kullanılır.
      </para><para>
        Bir kullanıcı makinesine Linux yüklerken tüm özelliklerini yüklemek
        istemeyebilir. Yüklediği yazılımların bazılarının gereksiz olduğunu
        düşünüyorsa ileride bazı uygulamaları kaldırabilir veya sonradan gerekli
        gördüğü yazılımları dağıtım disketlerinden rahatlıkla ekleyebilir.
      </para><para>
        Linux sadece dağıtımlarda bulunan yazılımlarla sınırlı bir işletim sistemi
        değildir. Dağıtımlarda bulunan yazılımlara ek olarak çok çeşitli başka
        uygulamalar mevcuttur. (Örnek olarak Netscape hiç bir Linux dağıtımında
        bulunmamaktadır). Bu ek yazılımların birçoğu Internet üzerinde FTP
        arşivlerinde bulunmaktadırlar. Kitabın sonundaki ek,  Linux uygulama
        yazılımlarının nerede bulunduğu hakkında biraz bilgi veriyor.
      </para><para>
        CD-ROM üzerindeki dağıtımlarda, dağıtımların yanısıra bir çok tanınmış FTP
        arşivinde yer alan yazılımlar ve çeşitli belgelerde yer alır. Internet
        bağlantısı olan bir kurumda çalışmayan (veya bu tür bir kuruma erişimi
        bulunmayan) birisi için bir CD-ROM çok iyi bir çözümdür.
      </para><para>
        Internet bağlantısı bulunan (özellikle akademik) kurumlarda güncel
        dağıtımların Internet üzerinden aktarılması ve buradaki kullanıcılara
        NFS ve sabit disk üzerinde aktarılması daha pratik bir uygulamadır. Aynı
        kurumlar kendi çalışma alanları ile ilgili buldukları ek yazılımları da
        FTP arşivlerinden toparlayabilir ve kullanıcılarına bu ek yazılımları
        sunabilirler.
      </para>
    </sect2>
  </sect1>
  <sect1  id="archive-tlkg-lis-2.3">
    <title>Sabit Disk Üzerinde Linux İçin Yer Açmak</title>
    <para>
      Linux işletim sistemini yüklemek için sabit diskiniz üzerinde Linux
      için bir miktar yer ayırmak zorundasınız. Herhangi bir sabit disk
      bir işletim sisteminde kullanılabilmesi için ilk olarak bölümlere
      (partition) ayrılır. Daha sonra bu bölümler işletim sistemine uygun
      şekilde biçemlenir. Linux işletim sistemi kendi disk biçemini (ext2) kullanır.
      En yüksek verimi sabit disk üzerinde, kendi bölümünde, kendi disk
      biçemi altında çalıştığı zaman verebilir. Eğer ayrı bir bölümlendirme
      yapılamıyorsa, tavsiye edilmese bile MS-DOS biçemli bir disk üzerinde
      de Linux kurulabilir (UMSDOS) ancak bu sistemin performansı diğerine
      göre oldukça düşük olacaktır. Bu belgenin geriye kalan tüm kısımlarında
      bilgisayarınıza Linux yüklemek için sabit disk üzerinde Linux'a özgü
      bir bölüm ayrılacağı ve bu bölüme yükleneceği kabul edilecektir. MS-DOS
      biçemli bir disk hiyerarşisi altına Linux kurmak için <emphasis>UMSDOS-HOWTO</emphasis>
      belgesinden yararlanabilirsiniz.  Eğer bilgisayarınızı bir süredir
      kullanıyorsanız, büyük bir ihtimalle sabit diskinizin tümünü kullandığınız
      işletim sistemi için ayrımış durumdasınızdır. MS-DOS kullanıyorsanız
      diskiniz bir (sadece C:) veya birden fazla (C: D: ..) bölüme ayrılmış
      durumda olabilir. MS-DOS altında  bir disk üzerinde en fazla 4 temel
      bölüm olabilir (primary partition). Eğer daha fazla bölüme ihtiyaç
      varsa temel bölümlerden biri genişletilmiş bir bölüm olarak ayrılır
      (extended partition) ve bu bölüm üzerinde mantıksal bölümler  ayrılır
      (logical partitions).
    </para><para>
      Bilgisayarınızda birden fazla bölüm varsa bir bölümü boşaltıp bu bölümü
      Linux için ayırabilirsiniz. Eğer tek bölümünüz varsa veya mevcut
      bölümlerinizden birini tümüyle harcamak istemiyorsanız diskinizi yeniden
      bölümlemeniz gerekecektir. Klasik olarak bu durumda bölmek istediğiniz
      bölümdeki yazılımların yedeğini almanız, daha sonra MS-DOS altında
      <emphasis>fdisk</emphasis> yazılımı yardımı ile sözkonusu bölümü silmeniz, yeni boyutu ile
      yeniden yaratmanız, bu bölümü <literal>format</literal> komutu ile biçemlemeniz ve yedeğini
      aldığınız yazılımları yeniden yerleştirmeniz gerekecektir (Çok iş :) )
    </para><para>
      Bazı yazılımlar mevcut bölümünüzü iki parçaya ayırabilirler. Örnek
      olarak <emphasis>fips</emphasis> bu amaçla kullanılan bir yazılımdır. (Diskiniz üzerinde
      işlem yapan her yazılım az da olsa disk üzerindeki bilgilere zarar verme
      riski taşır. Bu tür yazılımlar ile çalışmadan önce önemli olduğunu
      düşündüğünüz bilgilerin yedeğini almaya özen gösterin). fips, defrag
      programı kullanıldıktan sonra bölümünüzü sizin belirleyeceğiniz boyutlarda
      iki bölüme ayırabilir.
    </para><para>
      Eğer bilgisayaranızı yeni alıyorsanız veya yeni bir disk alıyorsanız,
      bu diskin tamamını veya bir bölümünü Linux için kullanabilirsiniz. Bu
      amaçla diskinizde sadece Linux kullanmak istemediğiniz bölümleri ayırmanız
      (ve gerisini boş bırakmanız) yeterlidir. Linux bölümlerinin Linux altından
      biçemlenmesi gerekecektir.
    </para><para>
      Linux sabit disk üzerinde bir bölümden fazlasını kullanabilir. Özel
      olarak normal dosyaların yazılmadığı, hafıza gereken işler sırasında
      geçici bir alan olması amacıyla Linux bir takas alanına (swap space)
      ihtiyaç duyar. Bu takas alanı için en verimlisi sadece takas işlemi için
      ayrılmış küçük bir disk bölümü yaratmaktır.
    </para><para>
      Yoğun olarak Linux kullanan yerler için standart olarak dağıtımdan
      gelen işletim sistemini ayrı bir bölüme yüklemeleri kullanıcı alanları
      (<literal>/home</literal>) ve sonradan yüklenen yazılımlar (<literal>/usr/local</literal>) için ayrı bir alan
      ayırmaları tavsiye edilebilir. Bu sayede, işletim sistemi güncellemek
      son derece kolaylaşır, yeni işletim sistemi yüklerken sadece işletim
      sisteminin bulunduğu bölüm üzerinde işlem yapılır ve bu sayede kullanıcı
      alanlarının veya sonradan (dağıtım dışı) yüklenen yazılımların zarar
      görmeleri engellenebilir.
    </para><para>
      Her bir bölüm için ne kadar yer ayrılacağı hakkında çok şey
      yazılmıştır. Ne var ki yazılanların birçoğu sabit disklerin nadiren 200
      Mbyte sınırını geçtiği günlerden kalmaktadır. Linux'un kaplayacağı alan,
      hangi paketleri  kullanacağınıza çok bağlıdır. Kabaca her disketin
      2-3 Mbyte arasında yer kaplayacağını düşünerek, yüklemek istediğiniz
      disketleri hesaplayarak kaba bir tablo çıkarabilirsiniz. Tecrübeli bir
      Linux kullanıcısı hangi yazılımları kullanıp hangilerini kullanmadığını
      daha iyi belirleyebilecek durumda olacaktır. Dolayısı ile yeni bir
      kullanıcı ortalama olarak 200 - 300 Mbyte kadar bir yer ayırmak
      isteyecektir. Bu, günümüzün disk kapasiteleri düşünülünce o kadar büyük
      bir alan değildir.
    </para><para>
      Takas alanı konusunda da çok şey yazılmıştır. Birçok kaynak takas
      bölümü için ayrılması gereken alanının gerçek hafızanın 2 katının
      biraz fazlası olarak kabul etmektedir. Pratikte 64-1000 Mbyte arasında
      bir alan fazlasıyla yeterli kalmaktadır. Ancak takas bölmeleri 2
      gigabaytdan daha büyük olamaz. Eğer 2 gigabaytdan daha büyük takas
      alanı gerekiyorsa birden fazla takas bölmesi yaratmalısınız. Toplam 16
      tane takas bölmeniz olabilir.
    </para><para>
      Takas alanı kullanırken, bir seferde daha fazla uygulama çalışmanızı
      sağlayacak şekilde Linux kullanılmayan sayfaları hafızadan diske
      taşır. Ancak, takas işlemi genelde yavaş olduğundan gerçek fiziksel
      hafızanın yerini dolduramaz. Ama çok fazla hafıza isteyen uygulamalar
      (X Pencere System gibi) eğer yeteri kadar fiziksel hafızanız yoksa takas
      alanına bel bağlar.
    </para><para>
    Tercih olarak, 20 GByte'lık bir disk üzerinde,
    (Güncellenmiş bilgi - Aralık 2002)
    </para><para>
    <command>Linux nedir denemek isteyen bir kişi için</command>
    </para><para>
<literallayout>
  Bölüm 1: DOS                                     1 Gbyte
  Bölüm 2: Linux                                   2 Gbyte
  Bölüm 3: Linux 'swap' bölümü                   128 Mbyte
</literallayout>
    </para><para>
    <command>İşinde arada sırada Linux kullanan birisi için</command>
    </para><para>
<literallayout>
  Bölüm 1: DOS                                     4 GByte
  Bölüm 2: Linux                                   4 GByte
  Bölüm 3: Linux takas bölümü                    256 MByte
  Bölüm 4: DOS (DOS altında D: olarak gözükecek)   4 MByte
</literallayout>
    </para><para>
    <command>Internet üzerinde sadece Linux kullanılan bir bilgisayar için</command>
    </para><para>
<literallayout>
  Bölüm 1: Linux                                   1 GByte
  Bölüm 2: Linux takas bölümü                      1 GByte
  Bölüm 3: Linux /usr                              4 GByte
  Bölüm 4: Linux /home                             6 GByte
</literallayout>
    </para>
  </sect1>
  <sect1 id="archive-tlkg-lis-2.4">
    <title>Bilgisayarın Linux ile Açılması</title>
    <para>
      Bilgisayarın sabit diski üzerinde yer ayırdıktan, bir Linux dağıtımı
      bulduktan sonra artık Linux yüklemek için yapılması gereken, yükleme
      yapmanıza yardımcı olmaya yetecek şekilde bilgisayarınızı Linux altında
      çalıştırmaktır. Bu amaçla <emphasis>boot</emphasis> ve <emphasis>root disketi</emphasis> adı verilen iki disket
      kullanılması yeterlidir.Bu disketlerden boot disketi bilgisayarınız
      üzerindeki donanıma uygun bir Linux çekirdeği (kernel) içerir ve
      bilgisayarın Linux ile açılmasını sağlar, root disketi adı verilen diğeri
      ise makinanız Linux olarak açıldığı zaman çalıştıracağı yazılımları içeren
      ve Linux' un çalışması için gereken sistem programlarını içerir. Bu
      iki disketi, MS-DOS altındaki sistem disketine benzetmek mümkündür.
    </para><para>
      Boot ve root disketleri, Linux dağıtımı ile birlikte gelirler. Eğer
      bir CD-ROM dağıtımı ullanıyorsanız, büyük ihtimal disketler CD-ROM
      ile beraber geleceklerdir. Eğer dağıtımı Internet'ten alıyorsanız bu
      disketler bir disket görüntüsü olarak bulunacaklardır. Yapmanız gereken
      bu disket görüntülerini normal disketlere bu amaç için yazılmış bir
      yazılımla aktarmak ve açılış disketlerini oluşturmaktır. Bunun için
      <literal>RAWRITE.EXE</literal> programını kullanabilirsiniz.
    </para><para>
      Root disketi için genelde bir veya iki seçenek bulunmaktadır. Genelde
      kullanılan disket <literal>color.gz</literal> adını alır.
    </para><para>
      Boot disketi için aynı şeyi söylemek mümkün değildir. Zira boot disketi
      Linux çekirdeğini içermektedir. Her işletim sistemi, o işletim sistemi
      altında çalışacak olan bilgisayar üzerindeki donanıma erişebilmek için
      bazı destekler içerir. Ne var ki her donanım kendisine göre bir takım
      farklılıklar gösterir. Linux bilgisayarınız üzerinde bulunan birçok
      donanım için destek verebilir, ne var ki tüm donanım desteğini tek bir
      çekirdekte toplamak çekirdeğin gereksiz yere büyümesine ve hantallaşmasına
      neden olacaktı (Bilgisayarınızda ses kartı donanımı yoksa çekirdeğin
      ses kartı desteğine ihtiyacınız olmayacaktır, yapılan sadece gereken
      destekleri ekleyerek çekirdeğin verimini artırmak demektir). Linux
      çekirdeği gerektiğinde destek verdiği donanımları destekleyecek şekilde
      güncellenebilir. Ancak Linux yükleyebilmek için, seçeceğiniz yükleme
      yöntemine göre bazı donanımlara destek vermesi gereklidir. Örnek vermek
      gerekirse, NFS üzerinden Linux yüklemek için çekirdek içerisinde mutlaka
      ağ (network) desteğinin olması gerekmektedir ama ses kartı desteğinin
      olmasına gerek yoktur. Linux yükledikten sonra derleyeceğiniz bir
      çekirdeğe ses kartı desteği vermesini sağlayabilirsiniz.
    </para><para>
      Bir işletim sisteminin sabit diske yüklenme aşamasında kullanıcıya
      sağlayacağı en büyük kolaylık, deneyimli kullanıcılar için tüm paketleri
      kurmadan önce sormak, Linux'u bilmeyen ve sabit diskine Linux kurmak
      isteyen yeni kullanıcılar için ise kurulum aşamasını mümkün olan en az
      soru ile bitirip daha önceden belirlenmiş birtakım paketleri otomatik
      olarak yüklemektir.
    </para><para>
      Çok farklı donanımların olması Linux yükleyebilmek için bir dizi boot
      disketinin oluşmasına neden olmuştur. Güncel bir Linux dağıtımında hangi
      boot disketlerinin hangi donanımlara destek verebildiğini görmek için
      ilgili dağıtımla gelen <literal>README</literal> dosyalarına bakmak gerekecektir. Şu anki
      Slackware dağıtımı ile gelen boot disketlerinden bazıları
    </para><para>
      <variablelist>
        <varlistentry>
          <term>bare.i</term>
          <listitem><para>
            IDE sabit disklere, sabit disk veya IDE/ATAPI CD-ROM'lardan yükleme
            yapmak için
          </para></listitem>
        </varlistentry>
        <varlistentry>
          <term>net.i</term>
          <listitem><para>
            IDE sabit disklere, NFS üzerinden yükleme yapmak için
          </para></listitem>
        </varlistentry>
        <varlistentry>
          <term>scsinet.s</term>
          <listitem><para>
            SCSI sabit disklere, NFS üzerinden yükleme yapmak için. Buna ek
            olarak değişik SCSI denetçileri için 25 kadar değişik boot disketi
            bulunmaktadır.
          </para></listitem>
        </varlistentry>
        <varlistentry>
          <term>xt.i</term>
          <listitem><para>
            Bu açılış disketinde sadece IDE ve XT sabit disk sürücüleri vardır.
          </para></listitem>
        </varlistentry>
      </variablelist>
    </para><para>
      Boot disketleri hakkında geniş bilgi için <emphasis>Bootdisk-HOWTO</emphasis> belgesinden
      yararlanabilirsiniz.
    </para><para>
      Boot ve root disketlerinizi de elde ettikten sonra artık bilgisayar ilk
      defa Linux altında çalışmak için hazırdır. Boot disketini takarak sistemi
      açın (PC'nin açılma sırasının A:,C: olmasına dikkat edin). Disket açılır
      açılmaz yaklaşık bir sayfalık bir mesaj verecek ve kullanıcıdan ek bir
      parametre isteyip istemediğini soracaktır. Bu noktada çalışacak olan
      çekirdeğe birçok ek parametre verilebilir. Eğer herşey yolunda giderse
      bu noktada özel bir parametre belirtmeye gerek kalmayacaktır. Boot
      disketi parametreleri hakkında <emphasis>BootPrompt-HOWTO</emphasis> içerisinde ayrıntılı bilgi
      bulabilirsiniz. Bu aşamayı geçtikten sonra çekirdek yüklenmeye başlayacak
      ve bir dizi mesaj geçecektir. Bu mesajlar çekirdeğinizin bilgisayar
      üzerindeki donanımları tanıması ve çeşitli hizmetleri çalıştırması
      ile ilgili mesajlardır. Çekirdeğin donanımınızı ne şekilde tanıdığı bu
      mesajlardan anlaşılır. Yükleme yapabilmek için çekirdeğin sabit diskinizi
      ve ağ bağlantısı kullanacaksanız ethernet kartınızı doğru olarak tanımış
      olması gerekecektir.
    </para><para>
      Daha sonra kullanıcıdan root disketini yüklemesi için bir mesaj
      çıkacaktır. Bu aşamada boot disketi yerine root disketi takılmalıdır. Kısa
      bir yüklemeden sonra bir mesaj çıkacak ve ardından
    </para><para>
      <screen>login:</screen>
    </para><para>
      mesajı ile karşılaşılacaktır. Tebrikler! Artık Linux altında çalışmaya
      başlayabilirsiniz. Bilgisayar şu anda sizden bir kullanıcı ismi
      beklemektedir. 'root' yazarak sisteme girin.
    </para>
    <sect2>
      <title>Ön Hazırlıklar</title>
      <para>
        Slackware dağıtımında yükleme işi için <literal>setup</literal>
        isimli bir yazılım bulunmaktadır. Yüklemenin her aşaması bu yazılım
        tarafından yürütülebilir. Ancak ilk olarak Linux için disk alanlarının
        tanımlanması gerekmektedir. Bu amaçla <literal>fdisk</literal> programı
        kullanılır. Linux altında bir bilgisayara bağlı her türlü cihaza bir
        dosya gibi erişmek mümkündür. Her cihaza karşılık gelen bir sistem
        dosyası mevcuttur. Cihazlarla ilgili dosyalar <literal>/dev</literal>
        dizini altında yer alırlar. Burada IDE sabit diskler "hd" SCSI sabit
        diskler "sd" olarak isimlendirilirler. Aynı anda bir bilgisayarda
        birden fazla disk bağlanmış olabilir. Diskler sırayla a b c d olarak
        isimlendirilirler. Her disk üzerinde birden fazla bölüm yer alabilir.
        Bu bölümler ise 1 2 3 4 olarak numaralandırılırlar. Örnek olarak
      </para><para>
        <itemizedlist>
          <listitem>
            <literal>/dev/hda</literal>, bir numaralı IDE (Primary Master) diski
          </listitem><listitem>
            <literal>/dev/hda1</literal>, bir numaralı IDE diskin ilk bölümü
            (DOS altında C:)
          </listitem><listitem>
            <literal>/dev/hda2</literal>, bir numaralı IDE diskin ikinci bölümünü
          </listitem><listitem>
            <literal>/dev/hdb</literal>, iki numaralı IDE (Primary Slave) diski
          </listitem><listitem>
            <literal>/dev/hdc</literal>, üç numaralı IDE (Secondary Master) diski
          </listitem><listitem>
            <literal>/dev/hdd</literal>, dört numaralı IDE (Secondary Slave) diski
          </listitem><listitem>
            <literal>/dev/sdb3</literal>, ikinci SCSI sabit diskin üçüncü bölümünü
          </listitem>
        </itemizedlist>
      </para><para>
        göstermektedir. Birden fazla sabit diskiniz varsa hangi sabit disk'le
        ilgileneceğinizi belirtmeniz gerekir. Eğer iki sabit diskiniz varsa
        fdisk'i kullanırken dikkat edin, her an yanlış bir diski biçemleme
        şansınız var.
      </para><para>
        <screen># fdisk /dev/hda</screen>
      </para><para>
        Bu noktadan sonra artık fdisk ile istediğiniz bölümleri tanımlamanız
        mümkündür.
      </para><para>
        fdisk komutu harddisk bölümlerinin düzenlenmesi için kullanılan
        bir yazılımdır. Komut satırından genelde tek harflik komutlarla
        kullanılır. Eğer komut satırında bir parametre verilmezse fdisk ilk
        bulduğu disk üzerinde işlem yapacaktır. Birden fazla disk mevcutsa komut
        satırında istenilen diskin belirtilmesi gerekecektir. Aşağıdaki örnekte
        fdisk herhangi bir parametre ile çağrılmamış ve sistemde bulunan öncelikli
        disk olarak bir numaralı SCSI disk (<literal>/dev/sda</literal>) seçilmiştir.
      </para><para>
        fdisk, komutunun yanında bazı parameteler alır:
      </para><para>
        <variablelist>
          <varlistentry>
            <term>/fdisk -v</term>
            <listitem><para>Fdisk programının sürümü ekrana gelir.</para></listitem>
          </varlistentry>
          <varlistentry>
            <term>fdisk -l</term>
            <listitem><para>
              <literal>/dev/hda, /dev/hdb, /dev/sda, /dev/sdb, /dev/sdc, /dev/sdd, /dev/sde,
              /dev/sdf, /dev/sdg</literal> ve <literal>/dev/sdh</literal>
              disklerinin (varsa) bölümlendirme tablosunu ekrana yazar ve çıkar.
            </para></listitem>
          </varlistentry>
          <varlistentry>
            <term>fdisk -s &lt;disk-bölümü&gt;</term>
            <listitem><para>
              Eğer bir DOS bölümü değilse (bölüm numarası 10'dan büyük) , sözkonusu disk
              bölümünün büyüklüğü bayt cinsinden ekrana yazılır.
            </para></listitem>
          </varlistentry>
        </variablelist>
      </para><para>
        Aşağıda, fdisk yazılımının kullanımı hakkında örnek bir fdisk çalışması
        yeralıyor.
      </para>
    </sect2><sect2>
      <title>Örnek FDISK Çalışması</title>
      <para>
        Bu örnek içerisinde 1 Gbyte'lık SCSI sabit disk'e sahip bir makine
        üzerinde LINUX için gerekli kısımların ayrılması adım adım incelenmiştir.
        Sözkonusu sabit disk üzerinde kullanıcı önceden 400 Mbyte'lık bir
        kullanıcı alanı tanımlamış ve geri kalan alanı LINUX için ayırmıştı.
        Düşünülen dağılım:
      </para><para>
        <itemizedlist>
          <listitem>400 Mbyte DOS</listitem>
          <listitem>250 Mbyte LINUX işletim sistemi</listitem>
          <listitem>60 Mbyte Takas alanı</listitem>
        </itemizedlist>
      </para><para>
        ve geri kalan alan LINUX altında kullanıcı alanı.
      </para><para>
        <literal>fdisk</literal> programı çalışır çalışmaz ilk iş olarak mevcut
        bölümler hakkında bilgi almak için <literal>p</literal> komutunu ( Print
        Partition Info) kullanıyoruz.
      </para><para>
<screen>
Command (m for help): p

Disk /dev/sda: 34 heads, 61 sectors, 1017 cylinders
Units = cylinders of 2074 * 512 bytes

   Device Boot   Begin    Start      End   Blocks   Id  System
/dev/sda1   *        1        1      395   409584+   6  DOS 16-bit &gt;=32M
</screen>
      </para><para>
        Bu tablo bize sadece tek bölüm ayrıldığını, ayrılan alanın DOS
        biçeminde olduğunu, boot edecek bölüm olduğunu belirtiyor.
        Bölümün adı <literal>/dev/sda1</literal>, yani ilk SCSI sabit disk
        üzerinde tanımlanan ilk bölüm. İlk iş olarak LINUX işletim sistemi
        için yeni bir bölüm yaratmalıyız.
      </para><para>
<screen>
Command (m for help): n
Command action
   e   extended
   p   primary partition (1-4)
p
Partition number (1-4): 2
First cylinder (396-1017): 396
Last cylinder or +size or +sizeM or +sizeK ([396]-1017): +250M
</screen>
      </para><para>
        n komutu ile kendimize yeni bir bölüm yarattık. İlk seçenek temel bir
        disk bölümümü yoksa gelişmiş bir disk bölümü üzerinde mi işlem
        yapacağımızı sordu. Temel bir bölüm için p komutunu girdik. Daha
        sonra hangi bölümü yaratacağımızı sordu. Halen mevcut 1 bölüm var,
        bu bölüm ikinci bölüm olacak bu yüzden 2 yazdık.
      </para><para>
        Bölümün başlangıç adresini giriyoruz. Bu değer otomatik olarak bir
        önceki bölümün bitiş değerinden hesaplanmaktadır. Sadece onaylıyoruz.
        Daha sonra istediğimiz boyutu belirtiyoruz. +250M tanımı 250 Mbyte'lık
        bir kısım istediğimizi belirtiyor. Yarattığımız bu bölümü p komutu ile
        inceliyoruz
      </para><para>
<screen>
Command (m for help): p

Disk /dev/sda: 34 heads, 61 sectors, 1017 cylinders
Units = cylinders of 2074 * 512 bytes

   Device Boot   Begin    Start      End   Blocks   Id  System
/dev/sda1   *        1        1      395   409584+   6  DOS 16-bit &gt;=32M
/dev/sda2          396      396      642   256139   83  Linux native
</screen>
      </para><para>
        fdisk yaratılan her bölümü otomatik olarak (LINUX native) olarak yaratmaktadır.
        Şimdi takas alanı için 60 Mbyte'lık 3. temel bölümü tanımlayalım:
      </para><para>
<screen>
Command (m for help): n
Command action
   e   extended
   p   primary partition (1-4)
p
Partition number (1-4): 3
First cylinder (643-1017): 643
Last cylinder or +size or +sizeM or +sizeK ([643]-1017): +60M

Command (m for help): p

Disk /dev/sda: 34 heads, 61 sectors, 1017 cylinders
Units = cylinders of 2074 * 512 bytes

   Device Boot   Begin    Start      End   Blocks   Id  System
/dev/sda1   *        1        1      395   409584+   6  DOS 16-bit &gt;=32M
/dev/sda2          396      396      642   256139   83  Linux native
/dev/sda3          643      643      702    62220   83  Linux native
</screen>
      </para><para>
        Dikkat edilecek olursa bu bölüm de <emphasis>LINUX native</emphasis>
        olarak tanımlandı. LINUX tarafından takas bölümü olarak kullanılacak
        olan bölümler farklı bir yapıya sahiptirler ve ayrıca tanımlanmaları
        gerekmektedir. Bu amaçla t komutu ile herhangi bir bölümün tipini
        değiştirmek mümkündür. (Tip değiştirmekle o  bölümün yapısı (biçemi)
        değişmiş olmuyor, biçemleme sonradan yapılan bir işlemdir)
      </para><para>
<screen>
Command (m for help): t
Partition number (1-4): 3
Hex code (type L to list codes): 82
Changed system type of partition 3 to 82 (Linux swap)

Command (m for help): p

Disk /dev/sda: 34 heads, 61 sectors, 1017 cylinders
Units = cylinders of 2074 * 512 bytes

   Device Boot   Begin    Start      End   Blocks   Id  System
/dev/sda1   *        1        1      395   409584+   6  DOS 16-bit &gt;=32M
/dev/sda2          396      396      642   256139   83  Linux native
/dev/sda3          643      643      702    62220   82  Linux swap
</screen>
      </para><para>
        Yukarıda yapılan işlemle 3 numaralı bölümün tipini
        <literal>Linux swap</literal> olarak değiştirmiş olduk. Şu anda üç
        farklı türden alanımız mevcut. Son bölümü de yine n komutu ile ekleriz.
      </para><para>
<screen>
Command (m for help): n
Command action
   e   extended
   p   primary partition (1-4)
p
Partition number (1-4): 4
First cylinder (703-1017): 703
Last cylinder or +size or +sizeM or +sizeK ([703]-1017): 1017

Command (m for help): p

Disk /dev/sda: 34 heads, 61 sectors, 1017 cylinders
Units = cylinders of 2074 * 512 bytes

   Device Boot   Begin    Start      End   Blocks   Id  System
/dev/sda1   *        1        1      395   409584+   6  DOS 16-bit &gt;=32M
/dev/sda2          396      396      642   256139   83  Linux native
/dev/sda3          643      643      702    62220   82  Linux swap
/dev/sda4          703      703     1017   326655   83  Linux native
</screen>
      </para><para>
        Bu örnekte boyut Mbyte cinsinden verilmedi. Zaten amaç kalan alanı tümüyle
        kullanıcı alanı olarak ayırmaktı. Bu nedenle son silindirin numarasının
        girilmesi yeterli oldu. Artık yapılması gereken bu bilginin diske
        yazılmasıdır. Şu ana kadar yapılan hiç bir değişiklik sistem üzerinde
        herhangi bir etki yapmamıştır. Ancak bölümleme bilgisi diske yazıldıktan
        sonra geri dönüş yoktur. <command>Lütfen  yaptığınız değişiklikleri bir kez
        daha gözden geçirin!</command>
      </para><para>
<screen>
Command (m for help): w
The partition table has been altered!

Calling ioctl() to re-read partition table.
(Reboot to ensure the partition table has been updated.)
Syncing disks.
Reboot your system to ensure the partition table is updated.
</screen>
      </para><para>
        Sabit diski bölümleme esnasında karşılaşılan bazı sorunlar vardır.
        Bunlarn en önemlisi Linux'un nasıl çalıştırılacağı ile ilgilidir.
        Linux açmak için belli başlı üç yöntem vardır:
      </para><para>
        <itemizedlist>
          <listitem>LILO ile bir boot menüsünden </listitem>
          <listitem>DOS altından <literal>LOADLIN</literal> isimli bir yazılımla</listitem>
          <listitem>Yüklemek için yapıldığı gibi bir boot diskiyle </listitem>
        </itemizedlist>
      </para><para>
        Son iki yöntem herhangi bir sınırlama getirmezken ilk yöntemin bir
        sınırlaması vardır. LILO isimli yazılım ile kullanıldığı zaman
        bilgisayar açıldığı zaman minik bir yazılım çalıştırır ve gerektiğinde
        Linux çekirdeğini yükler. Ancak çekirdek yüklenmesine kadar geçen süre
        içerisinde sistemin BIOS komutları çalışır. Bu komutların önemli bir
        sınırlaması bir disk üzerindeki bir yazılımı belirleyen üç parametreden
        (silindir sayısı, kafa numarası, sektör numarası) silindir sayısının
        en fazla 1024 ile sınırlı olmasıdır. Bu bakımdan LILO kullanılacaksa
        Linux çekirdeğinin yer alacağı bölüm bu 1024 numaralı silindir sınırının
        altında kalmalıdır. Bu sınırlama tamamıyla DOS'un kullandığı BIOS'un
        bir sınırlamasıdır. Yeni BIOS'lar bu sınırlamadan kurtulmak için LBA
        adı verilen bir yöntem kullanırlar. Bu yöntemin temelinde BIOS'ta kafa
        sayısı için gereksiz yere ayrılan kısımların silindir sayısını belirtmek
        için kullanılmasıdır. (BIOS, bir sabit disk için 64'e kadar kafa kabul
        edebilmektedir. Pratik olarak 15 kafadan fazla sabit diskin üretilmesi
        çok zor olduğu için yapılan kafa sayısını iki veya dört ile çarparak,
        silindir sayısını iki veya dörde bölmektir.) Böylelikle 1654 silindirli
        16 kafalı bir sabit disk, LBA olarak 827 silindirli ve 32 kafalı olarak
        tanımlanabilmektedir. İkinci durumda bu disk üzerinde tanımlanabilecek
        her bölümün yukarıda belirtilen sınırlama içerisinde kalacağına dikkat
        ediniz.
      </para>
    </sect2><sect2>
      <title>Setup Programı</title>
      <para>
      Disk üzerindeki tanımlamaları da bitirdikten sonra artık setup yazılımı
      çalıştırılabilir. Setup Linux yüklemek için gereken temel birçok
      işlemi yapabilir. Ok tuşları yardımı ile menüler arasında gezerek
      işlemleri tamamlayabilirsiniz. Burada yukarıdan aşağıya doğru bir sıra
      izleyebilirsiniz.
      </para><para>
      Şu anki güncel Slackware dağıtımının setup komutu çalıştırılınca ekrana
      gelen menüleri aşağıdadır.
      </para><para>
<literallayout>
              Welcome to Slackware Linux Setup.

 Hint: If you have trouble using the arrow keys on your keyboard,
 you can use ''+'', ''-'', and TAB instead. Which option would you like?

       HELP       Read the Slackware Setup HELP file
       KEYMAP     Remap your keyboard
       MAKE TAGS  Tagfile customization program
       TARGET     Select target directory [now: /]
       SOURCE     Select source media
       DISK SETS  Decide which disk sets you wish to install
       INSTALL    Install selected disk sets
       CONFIGURE  Reconfigure your Linux system
       PKGTOOL    Install or remove packages with Pkgtool
       EXIT       Exit Slackware Linux Setup

                        &lt;  OK  &gt;      &lt;Cancel&gt;
</literallayout>
      </para><para>
        <variablelist>
          <varlistentry>
            <term>HELP Menüsü</term>
            <listitem><para>
              Setup programı hakkında bazı ipuçları verecektir.
            </para></listitem>
          </varlistentry>
          <varlistentry>
            <term>KEYMAP Menüsü</term>
            <listitem><para>
              Bu menü ile  Amerikan klavye dışında bir klavye tanımlamak mümkün olacaktır.
              Henüz türkçe q veya f klavye desteği bulunmamaktadır.
            </para></listitem>
          </varlistentry>
          <varlistentry>
            <term>MAKE TAGS Menüsü</term>
            <listitem><para>
              Bu menü yardımı ile dağıtım disketlerinde özel uzantılı dosyalar
              hazırlayarak hangi paketlerin yükleneceğini otomatik olarak
              belirlemek mümkündür. Bu sayede eğer benzer makinalar yüklenecekse
              yüklenecek paketler bir kere belirlenir ve bir daha menülerden
              ekstradan paketlerin seçilmesine gerek kalmaz.
            </para></listitem>
          </varlistentry>
          <varlistentry>
            <term>ADDSWAP Menüsü</term>
            <listitem><para>
              fdisk ile ayırdığınız takas bölümünü uygun şekilde biçemler ve bu
              bölümü kullanıma açar. Setup yazılımı hangi disk bölümünün takas
              bölümü olarak ayrıldığını otomatik olarak bulacaktır. Daha sonra
              sözkonusu alanları biçemleyecek ve bu takas alanını sistem
              belleğine ekleyecektir. (Her adımda bir onay isteyecektir)
            </para></listitem>
          </varlistentry>
          <varlistentry>
            <term>TARGET Menüsü</term>
            <listitem><para>
              Linux'un hangi bölüme yükleneceğini belirler. Bu menüye girildiği
              zaman Linux'un disk biçemine (ext2) sahip (sabit disk bölümü
              numarası 83 olan) tüm disk bölümleri gösterilecek ve içerlerinden
              hangisine Linux kurulması istenileceği sorulacaktır. Bu aşamadan
              sonra o disk bölümü kullanıcı isterse biçemlenecektir. Burada iki
              biçemleme seçeneği vardır. Bu seçeneklerin ikincisinde disk önce
              hatalar için taranacak daha sonra biçemlencecektir. Eğer Linux disk
              biçeminde başka bölümler varsa bu bölümlerin kullanılmasının istenip
              istenmediği sorulacaktır. Bu sayede disk hiyerarşisinin herhangi bir
              kısmını bu ek disk bölümleri üzerine kurmak mümkündür. Son olarak
              Linux tarafından desteklenen başka disk bölümleri varsa (Örneğin DOS)
              bu bölümlere Linux altından erişim yapılmasının istenip istenmediği
              sorulacak ve bu bölümler için hiyerarşi içerisinde bir dizin atanması
              istenecektir.
            </para></listitem>
          </varlistentry>
          <varlistentry>
            <term>SOURCE Menüsü</term>
            <listitem>
              <para>
                Bu menü Linux dağıtımının nerede aranması gerektiğini belirler.
                Buradaki seçenekler
              </para><para>
<literallayout>
       SOURCE MEDIA SELECTION

 Where do you plan to install Slackware Linux from?


        1 Install from a hard drive partition
        2 Install from floppy disks
        3 Install via NFS
        4 Install from a pre-mounted directory
        5 Install from CD-ROM
</literallayout>
              </para><para>
                <variablelist>
                  <varlistentry>
                    <term>1 Numaralı seçenek</term>
                    <listitem><para>
                      Linux dağıtımını bir sabit disk bölümünde aramak için
                      kullanılacaktır. Bu seçenekle örnek olarak DOS kısmında
                      bulunan dağıtım disketlerinden yükleme yapılabilir.
                    </para></listitem>
                  </varlistentry>
                  <varlistentry>
                    <term>2 Numaralı seçenek</term>
                    <listitem><para>
                      Disketlerden yükleme yapmaktır. Çalışır bir sistemi birkaç
                      disketle oluşturmak mümkündür. Ancak günümüzde pek tercih
                      edilen bir yöntem değildir.
                    </para></listitem>
                  </varlistentry>
                  <varlistentry>
                    <term>3 Numaralı seçenek</term>
                    <listitem><para>
                      NFS üzerinden yükleme yapmak için kullanılmaktadır. Burada
                      bilgisayarın bir yerel bilgisayar ağına bağlı olması, bu
                      bilgisayar ağı üzerindeki bir sunucu üzerinde erişim izni
                      bulunan bir dizin altında dağıtım disketlerinin bulunması
                      gerekmektedir. Bu seçenekle yükleme yapmak için boot disketi
                      içerisinde yer alan diskette ağ desteğinin bulunması
                      gerekmektedir. Bu seçeneğin ardından bilgisayarın (geçici)
                      IP numarası varsa ağ üzerindeki yönlendirici'nin
                      (router-gateway) IP numarası, ağ maskesi (subnet mask),
                      NFS sunucusu IP numarası ve sunucu üstünde dağıtım
                      disketlerinin bulunduğu hiyerarşi gibi ağ ile ilgili
                      parametreler sorulacaktır. Bu soruların cevabını sistem
                      yetkilisinden öğrenmeniz ve onun onayını almanız gerekecektir.
                    </para></listitem>
                  </varlistentry>
                  <varlistentry>
                    <term>4 Numaralı seçenek</term>
                    <listitem><para>
                      Aslında 1 numaralı seçeneğe çok benzemektedir. Aradaki fark
                      bu durumda sistem hiyerarşisine bağlanmış (mounted) bir
                      dizin içerisinde dağıtım disketlerinin bulunmasıdır.
                    </para></listitem>
                  </varlistentry>
                  <varlistentry>
                    <term>5 Numaralı seçenek</term>
                    <listitem><para>
                      CD-ROM'dan yükleme yapmak içindir.
                    </para></listitem>
                  </varlistentry>
                </variablelist>
              </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <command>DISKSETS Menüsü</command>
            <listitem>
              <para>
                Artık nereye ve nereden yükleyeceğiniz belirlenmiştir. Sıra yüklemek
                istediğiniz disket serilerini seçmeye gelmiştir. Disk serileri:
              </para><para>
<literallayout>
    CUS         Also prompt for CUSTOM disk sets
    A           Base Linux system
    AP          Various Applications that do not need X
    D           Program Development (C, C++, Lisp, Perl, etc.)
    E           GNU Emacs
    F           FAQ lists, HOWTO documentation
    K           Linux kernel source
    N           Networking (TCP/IP, UUCP, Mail, News)
    T           TeX typesetting software
    TCL         Tcl/Tk script languages
    X           XFree86 X Pencere System
    XAP         X Applications
    XD          X Server development kit
    XV          XView (OpenLook Window Manager, apps)
    Y           Games (that do not require X)
</literallayout>
              </para><para>
                <variablelist>
                  <varlistentry>
                    <term>A Serisi (8 disket)</term>
                    <listitem><para>
                      Temel işletim sistemi bu disketlerde yer alır. Temel disk
                      hiyerarşisi yaratılır, sistemin çalışması için hayati olan
                      yazılımlar, terminal yazılımları, kabuklar (shell), disk
                      düzenleme yazılımları, kütüphaneler, Linux çalıştırmak
                      için LILO ve LOADLIN bu disketlerdedir.
                    </para></listitem>
                  </varlistentry>
                  <varlistentry>
                    <term>AP Serisi (5 disket)</term>
                    <listitem><para>
                      X Pencere ortamı gerektirmeyen uygulama yazılımlar. Metin
                      editörleri, ghostscript, man sayfaları, midnight commander
                      (Norton commander benzeri bir yazılım) bu disketlerde yer
                      alır.
                    </para></listitem>
                  </varlistentry>
                  <varlistentry>
                    <term>D Serisi (13 disket)</term>
                    <listitem><para>
                      Tüm programlama dilleri ve destek yazılımları bu disketlerde
                      yer alır. Eğer kendinize yeni bir Linux çekirdeği derlemeyi
                      düşünüyorsanız bu seriye ihtiyacınız var.
                    </para></listitem>
                  </varlistentry>
                  <varlistentry>
                    <term>E Serisi (8 disket)</term>
                    <listitem><para>
                      EMACS editörü.
                    </para></listitem>
                  </varlistentry>
                  <varlistentry>
                    <term>F Serisi (2 disket)</term>
                    <listitem>
                      <para>
                        Linux hakkında birçok belge ve açıklama bu disketlerde yer
                        almaktadır. Yeni başlayan birisinin bu disketleri mutlaka
                        yüklemesi gerekir. Söz konusu belgeler sıkıştırılmış halde
                      </para><para>
<literallayout>
  /usr/doc
  /usr/doc/faq
  /usr/doc/faq/HOWTO
</literallayout>
                      </para><para>
                        dizinlerine yüklenecektir. Birçok kullanıcı cevap aradığı
                        soruların birçoğunun zaten makinelerinde yazılı olduğunu
                        sonradan öğrenince çok şaşırmaktadır. Belgeler
                        sıkıştırılmış olduklarından <literal>zless</literal>
                        gibi sıkıştırılmış dosyaları destekleyen bir yazılımla
                        okunmaları gerekir.
                      </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                    <term>K Serisi (6 disket)</term>
                    <listitem><para>
                      Çekirdeğin kaynak kodu burada bulunur. Eğer kendi
                      donanımınıza uygun bir çekirdek derlemek istiyorsanız
                      bu seriye muhakkak ihtiyaç duyacaksınız. FTP arşivlerinden
                      kaynak kodu olarak bulacağınız bazı yazılımlar da bu
                      hiyerarşi altında yer alan bazı dosyalara ihtiyaç
                      duyacaklardır.
                    </para></listitem>
                  </varlistentry>
                  <varlistentry>
                    <term>N Serisi (6 disket)</term>
                    <listitem><para>
                      Ağ desteği bu disketler ile sağlanmaktadır. E-posta okuma
                      yazılımları, lynx, www sunucusu, haber grubu okuma
                      yazılımları bu disketlerin içerisinde yer alan yazılımlardır.
                    </para></listitem>
                  </varlistentry>
                  <varlistentry>
                    <term>T Serisi (9 disket)</term>
                    <listitem><para>
                      TeX. TeX yüklerken üç temel seçenekle karşılaşacaksınız.
                      İlk seri seçenek hangi TeX yardımcı paketlerini
                      isteyeceğinizi sorar, ikinci seçenekler hangi dil için
                      makro tanımları istediğinizi sorar, son seçenek ise yazı
                      tipleri hakkında tercihlerinizi sorar. (Burada gerçekten
                      çok fazla seçenek var)
                    </para></listitem>
                  </varlistentry>
                  <varlistentry>
                    <term>TCL Serisi (2 disket)</term>
                    <listitem><para>
                      X Pencere altında kullanımı basit bir programlama dili ve
                      bu dili ile yazılmış bazı uygulama yazılımları (tkdesk)
                    </para></listitem>
                  </varlistentry>
                  <varlistentry>
                    <term>X Serisi (16 disket)</term>
                    <listitem><para>
                      X Pencere desteği. Bu disketlerin büyük kısmı değişik grafik
                      kartları için X window sunucuları ve yazı karakterlerinden
                      oluşmaktadır. Linux yüklediğiniz bilgisayar üzerindeki
                      grafik kartını bilmeniz ve buna uygun bir sunucu seçmeniz
                      gerekmektedir.
                    </para></listitem>
                  </varlistentry>
                  <varlistentry>
                    <term>XAP Serisi (4 disket)</term>
                    <listitem><para>
                      X window altında çeşitli uygulamalar: satranç, gnuplot, xv,
                      xfileman, windows95 benzeri X Pencere arayüzü bu seriler
                      içerisinde yer almaktadır.
                    </para></listitem>
                  </varlistentry>
                  <varlistentry>
                    <term>XD Serisi (3 disket)</term>
                    <listitem><para>
                      Xserver geliştirmek için kütüphaneler ve uygulama
                      yazılımları
                    </para></listitem>
                  </varlistentry>
                  <varlistentry>
                    <term>XV Serisi (3 disket)</term>
                    <listitem><para>
                      OpenLook desteği veren yazılımlar. Bu sayede X Pencere
                      altında Sun bilgisayarlarda yer alan OpenWindows benzeri
                      bir ortam kullanılabilir.
                    </para></listitem>
                  </varlistentry>
                  <varlistentry>
                    <term>Y Serisi (1 disket)</term>
                    <listitem><para>
                      Minik birkaç oyun. (özellikle bog) Seçtiğiniz disk serileri
                      ilgi alanınızı genel olarak belirler. Her seri içerisinde
                      birçok yazılım pakedi yer almaktadır. Bu paketlerden
                      istediklerinizi yükleyebilirsiniz.
                    </para></listitem>
                  </varlistentry>
                </variablelist>
              </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>INSTALL Menüsü</term>
            <listitem><para>
              Seçtiğiniz disk serilerini belirlediğiniz kaynaktan, belirtilen
              hedef disk bölümüne aktarır. Disk serileri içerisinde yer alan
              paketleri ne şekilde yüklemek istediğiniz konusunda birtakım
              seçenekleriniz olacaktır. Bunlar:
            </para><para>
<literallayout>
          NORMAL         Use the default tagfiles for verbose prompting
          MENU           Choose package subsystems from interactive menus
          CUSTOM         Use custom tagfiles in the package directories
          PATH           Use tagfiles in the subdirectories of a custom path
          EXPERT         Choose individual packages from interactive menus
          NONE           Use no tagfiles - install everything
</literallayout>
            </para><para>
              <variablelist>
                <varlistentry>
                  <term>NORMAL</term>
                  <listitem><para>
                    Sistem her disk serisi içerisindeki paketleri 'gerekli
                    (required)', 'olsa iyi olur (recommended)' ve 'seçime
                    bağlı (optional)' olarak sınıflar. Bu seçenek ile
                    gerekli paketler yüklenir, diğer paketler için kısa bir
                    açıklama yazılır ve kullanıcının fikri sorulur. İlk
                    yüklemeler için tavsiye edilen bir seçenektir. Ancak
                    özellikle T serisi insanın sabrını taşıracak derecede
                    çok ufak tefek paket yüklemekte ve her paketi sormaktadır
                    (mesela klingon fontlarını yüklemek isteyip istemediğinizi
                    soruyor, bilmeyenler için klingonlar uzay yolu dizisindeki
                    kötü uzaylı yaratıklardır :) )
                  </para></listitem>
                </varlistentry>
                <varlistentry>
                  <term>MENU ve EXPERT</term>
                  <listitem><para>
                    Bu seçeneklerde her disk serisi yüklenmeye başlanırken o
                    seride yer alan tüm paketler bir menü içerisinde görülür.
                    Kullanıcı istediği paketleri işaretler ve bunların
                    yüklenmesini sağlar.
                  </para></listitem>
                </varlistentry>
                <varlistentry>
                  <term>CUSTOM ve PATH</term>
                  <listitem><para>
                    Daha önce belirtilen TAGFILE dosyaları yardımıyla yükleme
                    yapmak için kullanılır. Bu durumda belirli bir uzantıya
                    sahip dosyalar içerisinde (TAGFILE) yüklenmesi gereken
                    yazılımlar belirtilir. Bu seçenek ile TAGFILE' ların
                    uzantısı belirtilir ve o uzantılı dosyalarda bulunan
                    paketler yüklenir.
                  </para></listitem>
                </varlistentry>
                <varlistentry>
                  <term>NONE</term>
                  <listitem><para>
                    Tembellerin seçeneği. Her şeyi kuracaktır. Sadece belirli
                    paketler için anlamlıdır. Zira birçok paket içerisinde
                    içinden seçilmesi gereken seçenekler mevcuttur. (Mesela
                    Xserver 10 seçenek arasından seçilecektir)
                  </para></listitem>
                </varlistentry>
              </variablelist>
              Bu noktadan sonra artık yükleme başlayacaktır.
            </para></listitem>
          </varlistentry>
        </variablelist>
      </para>
    </sect2><sect2>
      <title>Yapılandırma</title>
      <para>
        Yükleme bittikten sonra yapılacak iş artık sisteminiz için tanıtımlarınızı
        yapmaktır. Bu işlemin ilk aşaması sistemi açacak bir çekirdek
        belirlemektir. Bu konuda üç seçeneğiniz var:
      </para><para>
<literallayout>
  bootdisk    Use the kernel from the installation bootdisk
  cdrom       Use a kernel from the Slackware CD
  floppy      Install a zimage or bzimage file from a DOS floppy
</literallayout>
      </para><para>
        <variablelist>
          <varlistentry>
            <term>Bootdisk</term>
            <listitem><para>
              Bu seçenekte yüklemede kullandığınız çekirdek boot disketinden
              kopyalanacaktır. Sisteminizi yükleyebildiğinize göre bu çekirdek
              ile çalışabilirsiniz. Eğer bir değişiklik yapmamışsanız bu anda
              sürücü içerisinde boot disketi değil root disketi bulunuyor olmalı,
              değiştirmeyi unutmayın!
            </para></listitem>
          </varlistentry>
          <varlistentry>
            <term>CD-ROM</term>
            <listitem><para>
              Slackware CD-ROM'unda bulunan önceden derlenmiş çekirdeklerden
              herhangi birini seçebilirsiniz.
            </para></listitem>
          </varlistentry>
          <varlistentry>
            <term>Floppy</term>
            <listitem><para>
              Herhangi bir DOS disketinde yer alan çekirdeği yüklemenizi sağlar.
            </para></listitem>
          </varlistentry>
        </variablelist>
      </para><para>
        Daha sonra sisteminiz için bir boot disketi yaratmak isteyip istemediğiniz
        sorulacaktır. Ne olursa olsun, elinizin altında her zaman bir boot ve root disketi
        bulundurmak zorundasınız. Herhangi bir sorun olduğunda sisteminizi açmak
        için bir boot disketi bulmanız gerekecektir. Bunun için yükleme sırasında
        kullandığınız boot ve root disketlerini de kullanabilirsiniz.
      </para><para>
        Ardından setup size modem, mouse, CD-ROM, bulunduğunuz zaman dilimini
        soracak ve <literal>liloconfig</literal> yazılımı çalışacaktır.
        <emphasis>LILO</emphasis>, Linux Loader (Linux yükleyicisi)
        kelimelerinden meydana gelir. LILO Linux yüklemek için kullanılan
        çok pratik ve etkili bir yazılımdır. Bilgisayar açılır açılmaz,
        boot eden ilk sabit diskin üzerinde (boot partition) kendini yazar,
        bilgisayar açılır açılmaz, birden fazla işletim sistemi için seçenek
        sunabilir. Yapılandırma sırasında LILO kendisinin nereye yazılacağını
        sorar, bu seçenekler arasında
      </para><para>
<literallayout>
  1. The Master Boot Record of your first hard drive
  2. The superblock of your root Linux partition
  3. A formatted floppy disk
</literallayout>
      </para><para>
        yer alır.
      </para><para>
        <variablelist>
          <varlistentry>
            <term>1 numaralı seçenek</term>
            <listitem><para>
              birçok uygulamada kullanılacak olan seçenektir. MBR bir bilgisayar
              açarken ilk bakılan yerdir.
            </para></listitem>
          </varlistentry>
          <varlistentry>
            <term>2 numaralı seçenek</term>
            <listitem><para>
              MBR'yi kullanmamaktadır. Bunun sebebi, MBR üzerinde bir başka
              işletim sisteminin benzer bir yazılımının bulunması olabilir.
              (örneğin OS/2 Bootmanager)
            </para></listitem>
          </varlistentry>
          <varlistentry>
            <term>3 numaralı seçenek</term>
            <listitem><para>
              LILO kendisini bir diskete yükleyecektir. Bu disketten açıldığı
              zaman menü ortaya çıkacaktır.
            </para></listitem>
          </varlistentry>
        </variablelist>
      </para><para>
        Daha sonra boot işlemi sırasında çekirdeğe gönderilecek ekstra
        parametreler belirtilebilir. Birçok sistem için bu tür bir parametre
        gereksizdir. Bu parametre boot diski ile açıldığı zaman sorulan
        parametrenin aynısıdır. Sonraki seçenek LILO'nun yükleme sırasındaki
        davranışını belirler. LILO yapılandırması sırasında birden fazla boot
        edebilecek sabit disk bölümü tanımlanabilir. Shift tuşuna basıldığı
        zaman LILO mevcut bölümler için bir liste çıkaracaktır. LILO için tanımlı
        dört davranış vardır:
      </para><para>
<literallayout>
  1 -- None, don't wait at all - boot straight into the first OS
  2 -- 5 seconds
  3 -- 30 seconds
  4 -- Present a prompt and wait until a choice is made without timing out
</literallayout>
      </para><para>
        <variablelist>
          <varlistentry>
            <term>1 numaralı seçenek</term>
            <listitem><para>
              Hiç beklemeden doğrudan listede belirtilen ilk işletim sistemini
              yükleyecektir. Sadece Linux bulunan bilgisayarlar için kullanılan
              seçenek budur.
            </para></listitem>
          </varlistentry>
          <varlistentry>
            <term>2 ve 3 numaralı seçenek</term>
            <listitem><para>
              Sırasıyla 5 ve  30 saniye beklerler, eğer bu süre içerisinde Shift
              tuşuna basılmazsa ilk sırada yer alan işletim sistemini yüklerler.
            </para></listitem>
          </varlistentry>
          <varlistentry>
            <term>4 numaralı seçenek</term>
            <listitem><para>
              Bir işletim sistemi seçilene kadar bekler.
            </para></listitem>
          </varlistentry>
        </variablelist>
      </para><para>
        Daha sonra sırasıyla yüklenmesini tercih ettiğiniz disk bölümlerini
        tanıtabilirsiniz. LILO her bölüm için sizden ayıredici bir kelime
        isteyecektir. LILO yükleme anında sizden komut beklerken bu kelimeye
        göre işletim sistemi yükleyecetir.
      </para><para>
        LILO hakkında bazı örnekler için <emphasis>LILO-NASIL</emphasis>
        belgesinden yararlanabilirsiniz.
      </para>
    </sect2><sect2>
      <title>Makinayı Açmak</title>
      <para>
        Linux yükleme işlemi sona erdi. Artık bundan sonra sıra makinanızı Linux
        çalışacak şekilde çalışmasını sağlamaktır. Bunun için temel olarak iki
        değişik yöntem mevcuttur:
      </para><para>
        <variablelist>
          <varlistentry>
            <term>LILO</term>
            <listitem><para>
              En çok kullanılan en pratik açılış şekli. Burada bilgisayar
              açıldığı zaman isteğe göre bir süre bekler ve bu esnada shift,
              tab veya control tuşuna basılırsa birden fazla işletim sistemi
              ile çalıştırma seçeneği sunar.
            </para></listitem>
          </varlistentry>
          <varlistentry>
            <term>LOADLIN</term>
            <listitem><para>
              Dos altından çalışan bir yazılımdır. DOS altında çalışırken Linux
              yüklemenize yarar. Eğer kurulum aşamasında <literal>LOADLIN</literal>
              pakedini (A serisi disketler içinde ) seçmişseniz bu paket
              <literal>/root</literal> dizini altında <literal>LOADLIN.ZIP</literal>
              ismi ile kaydedilmiş olacaktır. Yapmanız gereken bu yazılımı ve mevcut
              çekirdeğinizi (<literal>/vmlinuz</literal> ) DOS kısmına aktarmaktır.
            </para></listitem>
          </varlistentry>
        </variablelist>
      </para><para>
        Aşağıda yer alan örnekte,
      </para><para>
      <orderedlist>
        <listitem>IDE bir sabit disk kullanıldığı</listitem>
        <listitem><literal>/dev/hda1</literal>'in DOS olduğu</listitem>
        <listitem><literal>/dev/hda3</literal> üzerine Linux yüklendiği </listitem>
        <listitem>DOS kısmına (henüz) Linux altından erişilemediği </listitem>
        <listitem>Makinanın Linux olarak açılmış olduğu </listitem>
      </orderedlist>
      </para><para>
        varsayılmıştır.
      </para><para>
<screen>
linux:~# ls /root
lodlin16.txt  lodlin16.zip
linux:~# mkdir /dos
linux:~# mount -t msdos /dev/hda1 /dos
linux:~# cd /dos
linux:/dos# unzip /root/lodlin16.zip
Archive:  lodlin16.zip
 creating: loadlin/
  inflating: loadlin/readme.1st
  inflating: loadlin/loadlin.exe
  inflating: loadlin/copying
  inflating: loadlin/test.par
  inflating: loadlin/linux.bat
 extracting: loadlin/initrd.tgz
  inflating: loadlin/files
   creating: loadlin/doc/
  inflating: loadlin/doc/changes
  inflating: loadlin/doc/announce.txt
  inflating: loadlin/doc/lodlin16.lsm
  inflating: loadlin/doc/quicksta.rt
  inflating: loadlin/doc/initrd.txt
  inflating: loadlin/doc/manual.txt
  inflating: loadlin/doc/params.doc
   creating: loadlin/src/
  inflating: loadlin/src/loadlin.asm
  inflating: loadlin/src/loadlina.asm
  inflating: loadlin/src/loadlini.asm
  inflating: loadlin/src/loadlinj.asm
  inflating: loadlin/src/loadlinm.asm
  inflating: loadlin/src/makefile
 extracting: loadlin/src/srclinux.tgz
  inflating: loadlin/src/pgadjust.asm
linux:/dos# cp /vmlinuz /dos/loadlin/zimage
linux:/dos# cd loadlin
linux:/dos/loadlin# ls
copying*      files*        linux.bat*    readme.1st*   test.par*
doc/          initrd.tgz*   loadlin.exe*  src/          zimage
linux:/dos/loadlin# cat linux.bat

rem  First, ensure any unwritten disk buffers are flushed:
smartdrv /C
rem  Start the LOADLIN process:
c:\loadlin\loadlin  c:\loadlin\zimage  root=/dev/hda3  ro  vga=3
linux:/dos/loadlin# cp linux.bat /dos
</screen>
      </para><para>
        Burada verilen örnekte yapılan sırasıyla
      </para><para>
        <itemizedlist>
          <listitem>
            <para>Sabit diskin DOS kısmını Linux altından ulaşılır yapmak</para>
          </listitem>
          <listitem><para>
            <literal>/root</literal> altında yer alan
            <literal>lodlin16.zip</literal> isimli dosyayı DOS diski altında
            açmak. Bu işlem <literal>C:\LOADLIN</literal> isimli bir dizin
            yaratıp içerisine gereken dosyaları yerleştirmektedir.
          </para></listitem>
          <listitem><para>
            Çalışan çekirdeği (<literal>/vmlinuz</literal>) bu dizine kopyalamak
            ve <literal>LINUX.BAT</literal> dosyasını kendimize uygun hale
            getirmek. Bu dosya <literal>C:\LOADLIN\ZIMAGE</literal> isimli bir
            çekirdeği kullanarak <literal>/dev/hda3</literal> bölümünde Linux
            çalıştırmak için kullanılır.
          </para></listitem>
          <listitem><para>
            <literal>LINUX.BAT</literal> dosyasını PATH içinde tanımlı bir yere
            kopyalamak, mesela <literal>C:\DOS</literal>.
          </para></listitem>
        </itemizedlist>
      </para><para>
        Artık bilgisayar DOS açıldıktan sonra <literal>linux</literal> komutu
        ile tekrar Linux çalıştırmak mümkün olacaktır.
      </para><para>
        Bilgisayarınıza Linux yüklediğiniz disketlerle her zaman bilgisayarınızı
        Linux olarak açıp çalışabilirsiniz.
      </para><para>
        Tavsiye edilen mümkünse LILO kullanmaktır. LOADLIN ise bir ikinci
        alternatif olarak çokça kullanılır. Boot disketlerine ise genelde
        son çare olarak başvurulur.
      </para><para>
        Bütün bu adımlardan sonra artık elinizde çalışmaya hazır bir Linux
        makine vardır. Makinayı kapatıp tekrar açın. Ekranda çekirdek mesajları
        geçtikten sonra
      </para><para>
<screen>
login:
</screen>
      </para><para>
        belirecektir. Buraya <literal>root</literal> yazın ve sisteme girin.
        İlk denemeniz için
      </para><para>
<screen>
# shutdown -rf now
</screen>
      </para><para>
        yazabilirsiniz. Linux bir makine çalıştığı sürece hafıza içerisinde birçok
        tampon bellek açar. Mümkün olduğu kadar makineyi kapama tuşuna basarak
        kapatmayın. Shutdown komutu işletim sisteminin tampon belleklerde tuttuğu
        bilgileri güncellemesini sağlayacaktır. <literal>-r</literal> parametresi sistemin
        reboot etmesini sağlayacaktır. Bilgisayarı kapatmak için
      </para><para>
<screen>
# shutdown -hf now
</screen>
      </para><para>
        komutunu kullanabilirsiniz. Burada yer alan h parametresi sistemin "halt"
        edeceğini (tamamen kilitlenme) ve bir daha açılmayacağını belirtecektir.
      </para><para>
        Eğer herşey yolunda giderse makinanızın başında oturup çalışmaya
        başlayabilirsiniz.
      </para><para>
        Sistemde çalışmaya başlamak üzere ilk iş olarak kendinize çalışmak
        amacıyla bir kullanıcı tanmlayın. Sistemde başka kullanıc olacaksa,
        onlar için de hesap açacaksınız. Kullanıcı hesabı açmak için
      </para><para>
<screen>
# adduser
</screen>
      </para><para>
        komutu size bu konuda yardımcı olacaktır. <literal>adduser</literal> (veya <literal>useradd</literal>)
        komutu , kullanıcı ismi, isim ve soyad, GID (grup kimliği), UID (kullanıcı
        kimliği) gibi birtakım sorular soracaktır. Bu komut hakkında ayrıntılı
        bilgiyi <emphasis>Sistem Yönetimi</emphasis> bölümü altında bulabilirsiniz. root kullanıcısı
        sistem üzerinde sınırsız yetkiye sahip olduğundan sistem dosyalarını
        kazara değiştirmenize veya silmenize sebep olabilir.
      </para><para>
        Şimdi yeni hesabınızla sisteme girebilirsiniz. Alt F1 'den Alt F6
        'ya kadar olan tuşlarla birden çok ekranda (sanal ekranlar) aynı anda
        çalışabilirsiniz.
      </para><para>
        Bu noktadan sonra bazı uygulamaların ayarlamalarını yapmanız
        gerekecektir. Artık Linux yüklemek ile ilgili bir sorunuzunun kalmamış
        olmasını umuyorum. DOS kullanıcılarına Linux hakkında bilgi veren
        sevimli bir belge için <emphasis>DOS2Linux Mini-HOWTO</emphasis> iyi bir başlangıç
        olabilir.
      </para><para>
        Açılış esnasında makinanızın ismi <literal>/etc/rc.d/rc.M</literal> dosyasında
        belirlenir. Bu dosyayı uygun şekilde değiştirerek makinanızın ismini
        de yeniden tanımlayabilirsiniz. Makinanızın ilk ismi <literal>darkstar</literal>
        olacaktır. Eğer TCP/IP ağ üzerinde çalışıyorsanız, <literal>/etc/HOSTNAME</literal>
        dosyasının içeriğini değiştirerek veya hostname komutu kullanılara makina
        ismi de değiştirilebilir.
      </para><para>
        Bunların dışında yapılandırma gerektiren birçok durum vardır. Bunlar
        için <emphasis>NET-3 HOWTO</emphasis> dosyasını iyice okumalısınız.
      </para>
    </sect2>
  </sect1>
  <sect1 id="archive-tlkg-lis-2.5">
    <title>LILO Yapılandırması</title>
    <para>
      Eğer linux ve OS/2 ile birlikte aynı disk üzerinde çalışmayacaksanız,
      LILO'yu öncelikli yükleyici olarak diskinizdeki diğer işletim
      sistemlerinin açılışında rahatlıkla kullanabilirsiniz. Daha önce
      de belirttiğim gibi OS/2'nin kendine özgü önyükleyicisi olduğundan
      birincil önyükleyici olarak bunu kullanın, LILO'yu ise linux açmak
      için çalıştırın.
    </para><para>
      Slackware LILO kurulum işlemi, bazı özel durumlar için yetersiz
      kalmaktadır. Bu gibi durumlarda dosyanın el yardımıyla yapılandırılması
      gereklidir.
    </para><para>
      LILO'yu değiştirmek için <literal>/etc/lilo.conf</literal> dosyası üzerinde
      değişiklikler yapmalısınız. Aşağıda bir LILO yapılandırma örneği
      görülüyor. Burada Linux bölümü <literal>/dev/hda2</literal>'de , MS-DOS bölümü
      ise <literal>/dev/hdb1</literal>'de (ikinci sabit diskin ilk bölümü) bulunuyor.
    </para><para>
<screen>
# LILO, /dev/hda uzerinde kurulacak.
boot = /dev/hda

# Linux yuklemek icin
image = /vmlinuz      => Cekirdegin diskteki ismi /vmlinuz
  label = linux       => Buna &quot;linux&quot; ismini ver. Acilis aninda
                         ekranda &quot;linux&quot; yazisi gorunur
  root = /dev/hda2    => Kok dosya sistemi olarak /dev/hda2 kullan
  vga = ask           => (VGA ekran modu icin kullanicidan komut bekle

# MS-DOS yuklemek icin
other = /dev/hdb1     => MS-DOS bolumu
  label = msdos       => &quot;msdos&quot; ismini ver
  table = /dev/hdb    => ikinci surucu icin bolumlendirme tablosu)
</screen>
    </para><para>
      Yukarıda bir örneği görülen <literal>/etc/lilo.conf</literal> dosyasında gerekli
      değişiklik veya düzeltmeleri yaptıktan sonra <literal>/sbin/lilo</literal> dosyasını
      root olarak çalıştırın. Bu komut LILO önyükleyicisini sabit diske
      kuracaktır. Bundan sonra her yeni çekirdek derlemenin ardından dosyada
      uygun değişiklikleri yapıp aynı komutu çalıştırmalısınız.
    </para><para>
      Şimdi sistemi sabit disten tekrar açabilirsiniz. LILO,
      <literal>/etc/lilo.conf</literal> dosyasındaki ilk işletim sistemini
      yükleyecektir. Başka bir sistemle açmak için önyükleme menüsünü ekrana
      getirmelisiniz. Bunun için makina açılırken shift veya kontrol tuşlarına
      basılı tutun. Ekrana bir açılış istemcisi gelecektir:
    </para><para>
      <screen>Boot:</screen>
    </para><para>
      Burada ya açılmasını istediğiniz işletim sisteminin ismini yazın (ilk
      kurulum sırasında MS-DOS veya linux) ya da tab tuşuna basarak listeyi
      ekrana getirin.
    </para><para>
      OS/2 kullanabilmek için Linux önyükleyicisini ikincil kullanmanız
      gerekecektir. Linux'u OS/2 önyükleyicisinden açmalısınız. Bunu yapmak
      için Linux sabit disk bölümünü OS/2 fdisk kullanarak yaratın. Ardından
      sözkonusu bölümü FAT veya HPFS olarak biçemleyin ki OS/2 tanıyabilsin.
    </para><para>
      Bundan sonra LILO'yu linux dosya sisteminin olduğu bölüme
      kurun. (yukarıdaki örnekte <literal>/dev/hda2</literal>).
      <literal>/etc/lilo.conf</literal> dosyasının linux
      için kullanılan satırlarının son durumu şu şekilde olacaktır:
    </para><para>
<screen>
 boot = /dev/hda2

 image = /vmlinuz
   label = linux
   root = /dev/hda2
</screen>
    </para><para>
      <literal>/sbin/lilo</literal> dosyasının çalıştırılmasının ardından
      OS/2 önyükleyicisine linux bölümünü tanıtın. Benzer yordamları, sorun
      çıkaran işletim sistemleri için de kullanabilirsiniz.
    </para>
  </sect1>
  <sect1 id="archive-tlkg-lis-2.6">
    <title>Sorun Çıktığında</title>
    <para>
      Tabii ki temennimiz sorun çıkmaması, ama her nedense her zaman bu satırları
      okuyacak birkaç kişi olacaktır. Linux üzerinde kendi ihtiyacınıza göre
      ayarlanamayacak bir parametre yok gibidir. Bu özelliği sayesinde son derece
      esnek bir çalışma ortamı haline gelebilir. Aynı özellik kişilerin çoğu zaman
      kendi çözümlerini bulmalarını da beraberinde getirmektedir. Kendi
      bilgisayarınızda Linux çalışmak için bir miktar belge karıştırmanız
      kaçınılmazdır.
    </para><para>
      Çıkabilecek en önemli sorun bilgisayarın açılmamasıdır. Bunun birçok sebebi
      olabilir. Açılış esnasında
    </para><para>
      <orderedlist>
        <listitem>İlk olarak LILO çalışır.</listitem>
        <listitem>Çekirdek yüklenir.</listitem>
        <listitem>Hizmet veren yazılımlar teker teker çalışmaya başlarlar.</listitem>
      </orderedlist>
    </para><para>
      Her aşama birçok satırda durumunu belirtecektir. Çalışan yazılımlar veya
      yazılım parçalarının her biri birbirinden bağımsız olduğu için açılış
      sırasında geldiğiniz nokta çok önemlidir. LILO çalışmadığında veya
      çekirdek yüklenirken takılırsa boot disketi ile rahatlıkla sistemi
      açabilirsiniz. Örnek olarak Linux yüklü disk bölümünüzün /dev/hda2
      olduğunu varsayalım. Boot disketi parametre istediğinde
    </para><para>
      <screen>mount root=/dev/hda2</screen>
    </para><para>
      yazmanız yeterli olacaktır. Bu durumda boot disketinde yer alan çekirdek
      ile belirttiğiniz bölümde yer alan Linux hiyerarşisi açılacaktır. Çalışan
      bu sisteminiz içerisinde artık hatanın kaynağını daha rahat bulabilirsiniz.
    </para><para>
      Çekirdeğin yükleme esanasında takılması büyük ölçüde çekirdeğin donanımı
      doğru belirleyememesinden çıkar. Mesela ethernet kartınızı yanlış tanımış
      olabilir. Bunu çözmenin temel yöntemi çekirdek içerisinde kullanmayacağınız
      donanımlara ilişkin destekleri kaldırmak (Tüm ethernet kartlarını destekleyen
      bir çekirdek yerine sadece kullanmanızın muhtemel olduğu ethernet kartlarına
      destek veren bir çekirdek derlemek) veya çekirdeğe yardımcı olabilecek açılış
      parametreleri vermek.
    </para><para>
      Çekirdek derlemek hakkında <emphasis>Kernel-HOWTO</emphasis> ve boot
      parametreleri hakkında <emphasis>BootPromt-HOWTO</emphasis> yardımcı
      olabilirler. Çalışan sisteminizde bir arıza meydana gelip de makina aniden
      çalışmamaya başlarsa en son yaptığınız değişiklikleri gözden geçirin.
    </para><para>
      Ve son olarak, sistemin çalışmaması her zaman Linux'tan kaynaklanmayabilir,
      donanım ile ilgili sorunlar da yaşayabilirsiniz. Rasgele davranışlar,
      durup dururken çakılmalar, panik mesajları altında, bozuk sabit diskler,
      normalden yüksek frekansta çalıştırılan işlemciler ve sistem saatine göre
      yavaş kaçan veya bozuk RAM'lar yatabilir.
    </para>
  </sect1>
  <sect1 id="archive-tlkg-lis-2.7">
    <title>Başlangıçta</title>
    <para>
      Bu satırları okuduğunuza göre çalışır durumda bir Linux sisteminiz
      var demektir. Hala silmediniz mi yoksa? Şaka bir yana, büyük
      badireler atlattınız. Önünüze sayısız engeller çıkabilirdi. Kurarken
      elektrikler kesilebilirdi, sabit disk çizilebilirdi veya yanlış bölümü
      biçemleyebilirdiniz. Özellikle Linux Slackware dağıtımını kurmak,
      belgelendirme olmadan veya hatırlı bir arkadaşın yardımı olmaksızın
      gerçekten zordur.
    </para><para>
      Bu bölümde Linux'a küçük bir giriş yapılacak, daha sonra da UNIX
      kullanmayanlar sistemle tanıştıracaktır. Bölüm boyunca yapmanız gereken
      korkmadan sistem üzerinde kolaylıkla gezinti yapmak ve dosyaları
      kurcalamaktır.
    </para><para>
      Önceki bölünde sisteme girebilmek için parolası olmayan "root" kullanıcıyı
      kullanmıştınız. Bu kullanıcı sistemde en fazla yetkiye sahip kullanıcı
      olup sistem görevlisi (sorumlusu) adını alır. Eğer root dışında bir
      kullanıcı hesabı tanımlanmışsa onu kullanın. Parola yazıldıktan sonra
      komut istemcisine, yani kısaca kabuk dediğimiz programa girilir.
      Parola yazılırken, başkalarının görmemesi için ekrana basılmaz.
    </para><para>
      Kullanıcı isimleri veya parolalarda büyük ve küçük harfler arasında fark
      vardır. Root, root ve ROOT, farklı kullanıcılara işaret eder. Klavyenin
      en sağındaki Caps Lock  tuşunun yanmadığına emin olun.
    </para><para>
      Sisteme ilk girişte, aşağıdaki gibi bir satırla karşılaşacaksınız.
    </para><para>
<screen>Welcome to Linux 1.2.13.

linux login: root
password:
Last login: Thu Feb 13 12:46:35 on tty1
Linux 1.2.13.
You have mail.
linux:~#
</screen>
    </para><para>
      Genellikle komut istemcisinin sonundaki karakter, root kullanıcısı
      için <literal>#</literal>, diğer kullanıcılar için <literal>$</literal> olur. Bu
      karakterden önce de makina ismi yeralır. MS-DOS'ta olduğu gibi burada
      UNIX komutlarını girebileceğiniz kabuk (shell) üzerindesiniz.
    </para><para>
      Parolayı değiştirmek için kullanılan komut <literal>passwd</literal>'dir.
      Bir kullanıcı sadece kendi parolasını değiştirebilirken root'a herkesin
      parolasını değiştirme yetkisi verilmiştir. Herhangi bir sistemde hesap
      parolanızı unutursanız, bunu sadece root değiştirebilir. Root
      iken <literal>passwd</literal> yazın ve enter tuşuna basın.
    </para><para>
<screen>linux:~# passwd
Changing password for root
Enter new password: *******
Re-type new password: ******
Password changed.
linux:~#
</screen>
    </para><para>
      Parolanızı iyi saklayın. Root parolasını ele geçiren birisi sistemde
      istediği değişikliği yapabilir. Parola seçimi için <emphasis>Linux İşletim
      Sisteminde Güvenlik</emphasis> konu başlığına göz gezdirin.
    </para><para>
      Linux komutları hakkında bilgi almak için <literal>man</literal> komutu
      kullanılır. Eğer kurulum aşamasında man dosyalarının kopyalanması
      sorusuna olumlu yanıt verilmişse bunlar <literal>/usr/man</literal> dizini altında
      bulunurlar. Örneğin <literal>passwd</literal> komutu hakkında daha ayrıntılı bilgi
      almak için
    </para><para>
      <screen>$ man passwd</screen>
    </para><para>
      yazın. Tüm man sayfaları <literal>/usr/man</literal> dizini altında 8 ayrı dizinde
      saklanır (man1 .. man8). Bazı komutların man dosyaları birden fazla dizin
      altında bulunur, bir dosya komut hakkında temel bilgi verirken diğeri
      sistem programcılarına yönelik olabilir. Örnek olarak <literal>mount</literal> komutu,
      hem 2, hem de 8 numaralı man dosyalarıyla birlikte arşivlenmiştir. C
      programlayıcısı, mount komutuna ulaşmak için
    </para><para>
      <screen>$ man 2 mount</screen>
    </para><para>
      yazarken normal kullanıcı,
    </para><para>
      <screen>$ man 8 mount</screen>
    </para><para>
      yazmalıdır. Bunun yanında başlığında belirli bir anahtar sözcüğü içeren
      tüm man dosyalarını araştırmak için <literal>apropos</literal> komutu
      kullanılır.
    </para><para>
      Her komut, bir veya birden çok parametre alabilir. Örnek olarak,
    </para><para>
      <screen>$ find . -name &quot;*.txt&quot; -print</screen>
    </para><para>
      komutu, bulunduğunuz yerden itibaren tüm dosyaları araştıracak ve bunların
      arasından sonu <literal>.txt</literal> ile bitenleri ekrana basacaktır.
      Parametreler genel olarak "-" işaretleri ve bu işaretten sonra gelen
      parametre ismi ile belirtilirler.
    </para>
  </sect1>
  <sect1 id="archive-tlkg-lis-2.8">
    <title>Linux Komut Yapısı</title>
    <para>
    UNIX ve benzeri işletim sitemlerinde kullanıcının komut yazmasını
    sağlayan, bu komutları yorumlayarak gerekli işlemleri yapan programlara
    <emphasis>kabuk</emphasis> (shell) adı verilir. UNIX'te bir kullanıcı bir dizi kabuktan
    istediğini seçebilir. Kabuklar ile ilgili ayrıntılı bilgi ileride
    verilecektir. Kullandığınız kabuk ne olursa olsun, gerek kabuktan
    kaynaklanan, gerekse UNIX komutlarının hepsinin uyduğu bazı
    standartlardan kaynaklanan bazı geleneksel yapılar vardır. Bunları
    bilmeniz ilk kez duyduğunuz bir komutun kullanımını bile kolayca
    çıkarabilmenizin yanı sıra, bir dizi genel hatadan kaçınmanızı da
    sağlayacaktır.
    </para><para>
      <itemizedlist>
        <listitem><para>
          UNIX'te (ve Linux'ta) bütün komutlar ve dosya isimlerinde
          büyük/küçük harf ayrımı önemlidir. Sistem komutlarının ve
          dosyaların çoğu küçük harfle yazılır.
        </para></listitem><listitem><para>
          Komut ve dosya adlarında kullanacağınız bazı karakterlerin gerek
          dosya ve dizin yapısı, gerekse kabuk ve diğer komutlar nedeniyle
          bazı özel anlamları vardır. Bu karakterlerden yeri geldikçe söz
          edilecektir. Örneğin, `/' karakteri hiçbir dosya adında
          bulunamaz (dosya ve dizinler için ayraç olarak
          kullanıldığından). `-' ile başlayan bir dosya oluşturulabilir
          olsa da silmeye kalktığında yeni bir UNIX kullanıcısının başına
          dert açabilir.
        </para></listitem><listitem><para>
          UNIX'te komutlara seçenek verirken seçenekten önce `-' karakteri
          kullanılır.  Örneğin <literal>ls -l</literal>
        </para></listitem><listitem><para>
          UNIX komutları tersi istenmedikçe girdilerini <emphasis>standart
          girdiden</emphasis> (klavye) alır, çıktılarını <emphasis>standart çıktıya</emphasis>
          (ekran) yazar. Bu özellik ileride anlatılacak olan yönlendirme
          ve boru (pipe) öperatorleri ile birlikte komut satırından birçok
          işlemi kolayca yapmanızı sağlar.
        </para></listitem><listitem><para>
          UNIX kabukları komut satırından verilen komutu çalıştırmadan önce
          bir dizi karakteri yorumlayarak dosya ad(lar)ına çevirirler. Bu
          karakterler:
        </para><para>
          <itemizedlist>
            <listitem><para>
              <command>*</command> 0 dahil herhangi bir sayıda karakter yerine geçer.
              Örneğin <literal>rm *</literal> komutu bütün dosyaları siler, <literal>ls
              -l a*</literal> komutu `a' ile başlayan dosyaların listesini
              verir.
            </para></listitem><listitem><para>
              <command>?</command> tek bir karakter yerine geçer. Örneğin <literal>??</literal> adı iki
              karakterden oluşan bütün dosyalar anlamına gelir.
            </para></listitem><listitem><para>
              <command>[]</command> karakterleri arasında yazılan liste
              içindeki herhangi bir harfe dönüştürülür. Örneğin <literal>cp
              *[abc] /tmp </literal> komutu `a', `b' ya da `c' ile
              biten bütün dosyaları <literal>/tmp</literal> dizinine
              kopyalayacaktır. liste içinde aralarına `-' işareti
              koyarak aralıklar verebilirsiniz. Örneğin,
              <literal>[A-Z]*</literal> büyük harfle başlayan bütün
              dosyalar anlamına gelir. Liste içindeki `^'
              karakteri sonrasında belirtilen liste dışındaki bütün
              karakterler anlamına gelir. Örneğin
              <literal>*[^0-9]*</literal> adında rakam olmayan
              herhangi bir dosya anlamına gelecektir.
            </para></listitem>
          </itemizedlist>
        </para></listitem>
      </itemizedlist>
    </para>
  </sect1>
  <sect1 id="archive-tlkg-lis-2.9">
    <title>Dosya ve Dizin Yapısı</title>
    <para>
      UNIX altında bazı karakterlerin özel anlamları vardır.
      Dizin ve dosya
      isimlerinin başında nokta olması durumunda bu dosyalar gizli dosya haline
      gelir ve parametresiz yazılan <literal>ls</literal> komutuyla görünmez.
    </para><para>
      Dosya ve dizin isimleri 255 karakteri aşamazlar.
    </para><para>
      Sisteme girince önceden tanımlanmış bir dizin altında bulunursunuz. Bu
      dizin normal kullanıcılar için  genellikle <literal>/home/</literal> ve ardından gelen
      kullanıcı dizini ismidir. Bulunduğunuz dizinin ismini görmek için <literal>pwd</literal>
      (print working directory) yazın. Temel dosya ve dizin kavramları hakkında
      ayrıntılı bilgi alabilmek için MS-DOS veya en iyisi bir UNIX kitabı edinin.
    </para><para>
<screen>
$ pwd
/home/gorkem
$
</screen>
    </para><para>
      UNIX komut yapısı DOS'a çok benzer. Dizin değiştirmek için <literal>cd</literal>,
      dizin yaratmak için <literal>mkdir</literal> komutlarını sistemde sıkça kullanılır.
    </para><para>
<screen>
$ cd /
$ pwd
/
</screen>
    </para><para>
      Hiyerarşik bir sıraya sahip olan UNIX'te en üstte <literal>/</literal> dizini
      (kök dizin) yeralır. Sistemdeki tüm diğer dosya ve dizinler bunun
      altında toplanırlar.
    </para><para>
      <screen>~</screen>
    </para><para>
      işareti, kullanıcının ev dizinini gösterir. Ev dizinine geçin ve
      <literal>mkdir</literal> komutu ile <literal>benim</literal> isimli
      bir dizin yaratın. Dizini patikasını, bir başka deyişle kök dizininden
      itibaren ismini vererek de yaratabilirsiniz.
    </para><para>
<screen>
$ cd ~
$ pwd
/home/gorkem
$ mkdir /home/gorkem/benim
</screen>
    </para>
    <sect2>
      <title>Dosya Listesi ve İçeriklerinin Görüntülenmesi</title>
      <para>
        Dosya ve dizinleri görebilmek için <literal>ls</literal> komutu kullanılır.
        Parametresiz yazarak bulunduğunuz dizin hakkında bilgi alın. Linux
        altında değişik uzantılı dosyalar okunabilirliği artırmak amacıyla
        farklı renkte görülecektir. <literal>/etc/DIR_COLORS</literal> dosyası,
        dosya renklerini ayarlar. Bu dosyayı değiştirerek belirli dosyalar için
        istenilen renkleri göstermesini sağlayabilirsiniz.
      </para><para>
<screen>
linux:~$ ls
README  article.txt     mail       typescript
adres   linux           perl
</screen>
      </para><para>
        <literal>ls</literal> komutu <literal>-a</literal> parametresiyle birlikte kullanılırsa normalde
        görükmeyen ve nokta karakteriyle başlayan dosya ve dizinler de
        görükür.
      </para><para>
<screen>
linux:~$ ls -a
.               .bashrc         .term           article.txt     typescript
..              .kermrc         .xinitrc                linux
.Xdefaults      .less           README  mail
.bash_history   .lessrc         adres           perl
</screen>
      </para><para>
        <literal>-l</literal> parametresi de dosyalar hakkında tüm bilgiyi verir. Bunlar,
        dosyanın sahibi, ne zaman yaratıldığı, sahibi ve grubu gibi
        bilgilerdir. Dosya izinleri hakkında daha geniş bilgi bir sonraki
        bölümde verilmiştir.
      </para><para>
<screen>
linux:~$ ls -al
total 91
drwxr-xr-x   6 gorkem   users        1024 Feb 13 12:56 .
drwxr-xr-x   4 root     root         1024 Jan  7  1980 ..
-rw-r--r--   1 gorkem   users         390 Feb 13 12:56 .Xdefaults
-rw-r--r--   1 gorkem   ftpadm        230 Feb 13 12:57 .bash_history
-rw-r--r--   1 gorkem   users           1 Feb 13 12:57 .bashrc
-rw-r--r--   1 gorkem   users         163 Nov 24  1993 .kermrc
-rw-r--r--   1 gorkem   users          34 Nov 24  1993 .less
-rw-r--r--   1 gorkem   users         114 Nov 24  1993 .lessrc
drwxr-xr-x   2 gorkem   users        1024 Jan  7  1980 .term
-rw-r--r--   1 gorkem   users          87 Feb 13 12:56 .xinitrc
-rw-r--r--   1 gorkem   users       26264 Feb 13 12:53 README
-rw-r--r--   1 gorkem   users        2795 Feb 13 12:55 adres
-rw-r--r--   1 gorkem   users       47970 Feb 13 12:53 article.txt
drwxr-xr-x   2 gorkem   users        1024 Feb 13 12:54 linux
drwxr-xr-x   2 gorkem   users        1024 Feb 13 12:54 mail
drwxr-xr-x   2 gorkem   users        1024 Feb 13 12:54 perl
-rw-r--r--   1 gorkem   users           0 Feb 13 12:57 typescript
</screen>
      </para><para>
        Yukarıda her iki parametrenin de birleştirilerek birlikte kullanımı
        yeralmaktadır. Dosyaların içeriklerini görmek için kullanılan birkaç
        komuttan en pratiği <literal>less</literal>'tir. Ok tuşları ile dosya içinde hareket
        edebilir ve q karakteri ile dosyadan çıkarsınız. Dosyanın içeriği birden
        fazla sayfadan ibaretse dosya sayfalar halinde ekrana gelir. Tüm dosyayı
        ekrana basmak için <literal>cat</literal> kullanın.
      </para><para>
        <screen>$ cat README</screen>
      </para><para>
      Bir dosyanın başından veya sonundan itibaren belirli miktarda satırı
      ekrana getirmek de mümkündür. Bunun için <literal>head</literal> ve <literal>tail</literal> komutları
      kullanıcının hizmetine sunulmuştur.
      </para><para>
<screen>
linux:~$ head -6 README  => <emphasis>dosyanin ilk 6 satirini ekrana basar</emphasis>
This is the README file for the 28 August 1994 public release of the
Info-ZIP group's portable UnZip zipfile-extraction program (and related
utilities).

unzip512.zip    portable UnZip, version 5.12, source code distribution
unzip512.tar.Z  same as above, but compress'd tar format

linux:~$ tail -3 README (dosyanin son 3 satirini ekrana getirir)

-- Greg Roelofs (Cave Newt), UnZip maintainer/container/explainer and
   developer guy, with inspiration from David Kirschbaum
</screen>
      </para>
    </sect2><sect2>
    <title>Dosyaların Kopyalanması</title>
      <para>
        Dosyaları kopyalamak için <literal>cp</literal> ve bir yerden başka bir dizine almak
        için <literal>mv</literal> komutu kullanılır. <literal>mv</literal> komutu, aynı zamanda dosya
        isimlerini değiştirmek üzere de işletilebilir.
      </para><para>
        <screen>linux:~$ cp article.txt /tmp</screen>
      </para><para>
        <literal>article.txt</literal> isimli dosyayı
        <literal>/tmp</literal> dizinine kopyalar.
      </para><para>
        <screen>linux:~$ mv article.txt /tmp/article</screen>
      </para><para>
        <literal>article.txt</literal> isimli dosyayı
        <literal>/tmp</literal> dizini altina ismini <literal>article</literal>
        olarak degistirerek koyar.
      </para><para>
        Kopyalama işlemi sadece dosyalar üzerinde değil, dizinler üzerinde
        de yapılabilir. Farklı dosya sistemleri üzerinde olmamak kaydıyla
        bir dizin ve altındaki herşeyi, başka bir dizine kopyalayabilir veya
        hareket ettirebilirsiniz. Kopyalarken bu işlem için <literal>-R</literal>
        parametresi kullanılır, <literal>mv</literal> komutu için
        <literal>-r</literal> parametresine gerek yoktur.
      </para><para>
        <screen>$ cp -R /home/gorkem/temp /tmp</screen>
      </para><para>
        <literal>/home/gorkem/temp</literal> dizinini ve içindeki her dosyayı
        <literal>/tmp</literal> altına kopyalar.
      </para><para>
        <screen>$ mv article.txt ~/benim</screen>
      </para><para>
        <literal>article.txt</literal> isimli dosyayı çalışma dizini altındaki
        <literal>benim</literal> dizinine kopyalar.
      </para>
    </sect2><sect2>
      <title>Dosyaların Silinmesi</title>
      <para>
        Bir daha kullanılmayacak olan dosyalar, <literal>rm</literal> komutuyla
        silinebilir. Dosyaları silerken iki kere düşünün, zira Linux altında
        silinen bir dosyanın geri dönüşü olmaz. Eğer bu tür hataları çok
        yapıyorsanız <literal>rm</literal> komutunu <literal>-i</literal> parametresi ile birlikte kullanın,
        bu sayede Linux, dosyayı silmeden önce kullanıcının da onayını alır.
      </para><para>
<screen>
linux:~$ rm -i README
rm: remove `README'? y  (sileyim mi ?)
linux:~$
</screen>
      </para><para>
        Eğer dosya ismi <literal>-</literal> karakteri ile başlıyor ise, <literal>rm</literal> komutunu
        kullandığınız zaman dosya ismi bir parametre olarak algılanacak ve
        hata verecektir. Bunun için dosya isminden önce <literal>--</literal> karakterlerini
        yerleştirin.
      </para><para>
        <screen>linux:~$ rm -- -dosya</screen>
      </para><para>
        Bir dizin, boş iken <literal>rmdir</literal> komutu ile silinebilir, eğer boş değilse
        bu komut işe yaramaz. Onun yerine <literal>rm</literal> komutunu <literal>-r</literal> parametresiyle
        kullanın.
      </para><para>
<screen>
linux:~$ rm mail
rm: mail: is a directory
linux:~$ rm -rf linux/          (linux dizinini icindekilerle birlikte silinir)
</screen>
      </para><para>
        <literal>-f</literal> parametresi ile kullanıcının onayını almadan tüm dosyaları tek
        adımda silmek mümkündür. Bulunduğunuz dizindeki tüm dosyaları silmek
        için * karakterini kullanın.
      </para><para>
        <screen>$ rm *</screen>
      </para>
    </sect2>
  </sect1>
</chapter>

<chapter id="archive-tlkg-lis-3">
  <title>Kabuk İşlemleri</title>
  <sect1 id="archive-tlkg-lis-3g">
    <title>Giriş</title>
    <para>
      Sisteme girdiğiniz anda kabuk programının çalıştırıldığından
      bahsetmiştik. Bu andan sonra yapacağınız tüm işlemler bu kabuk programı
      tarafından yönetilir ve denetlenir. Kabuk, klavyeden girilen komutları
      çalıştırarak bir arabirim görevi yapar. UNIX (ve Linux) altında
      geliştirilen sayısız kabuk çeşidi ve bunların herbirinin kendine ait
      özelliği vardır. Her programcı kendi zevkine hitap eden kabuğu seçebilir,
      sistemde yeralan kullanıcılar farklı kabuklar üzerinde çalışabilirler.
    </para><para>
      O an hangi kabuk üzerinde yeraldığınızı öğrenmek için
      <literal>echo $SHELL</literal> yazın.
    </para><para>
<screen>
$ echo $SHELL
/bin/bash
</screen>
    </para><para>
      Sıkça kullanılan kabuklar,
    </para><para>
      <command>sh (Shell ya da Bourne Shell):</command> İlk UNIX kabuğu.
    </para><para>
      <command>ksh (Korn Shell):</command> sh uyumlu, birçok ek programlama
      özelliği içeren bir kabuk. Bu kabuk da yaygın bir kitle tarafından
      kullanılıyor.
    </para><para>
      <command>bash(Bourne Again Shell):</command> Kullanım kolaylığı bakımından
      en çok rağbet gören bash, GNU tarafından kaynak kodu olarak dağıtılıyor.
      <literal>bash</literal> <literal>sh</literal> ve <literal>ksh</literal>
      uyumluluğunu korurken, özellikle etkileşimli kullanıma yönelik (komut
      tamamlama, gibi) birçok yenilik de içerir. Bu yazının hazırlandığı 1997
      Temmuz ayı başlarında Bash 2.0.1 sürümü çıkmıştı.
    </para><para>
      <command>csh (C shell):</command> Berkeley Üniversitesi'nde geliştirilen
      csh'in C diline benzer bir programlama yapısı vardır.
    </para><para>
      <command>tcsh:</command> csh'ın biraz geliştirilmiş hali.
    </para><para>
      Yukarıdaki kabuk programlarından <literal>sh, ksh ve bash</literal>
      birbirleriyle uyumludur ve yukarıda en ilkelden en gelişmişe göre
      sıralanmışlardır. Aynı durum <literal>csh ve tcsh</literal> için de
      geçerlidir. Kullanılan shell genellikle kişisel bir tercih nedeni olsa da,
      bütün sistem betikleri <literal>sh</literal> ile yazıldığından, sistem
      yöneticilerine <literal>sh</literal> ailesinden bir
      kabuk kullanmaları önerilir.
    </para><para>
      Kabuk programları genellikle <literal>/bin</literal> dizini altında
      yeralır.  Kullanıcının sisteme girerken hangi kabuğu kullanacağı
      <literal>/etc/passwd</literal> dosyasında yeralır. Bunu değiştirmek için
      <literal>chsh</literal> (change shell) komutunu kullanabilirsiniz.
    </para><para>
<screen>
$ chsh
Password:
Changing the login shell for cagri
Enter the new value, or press return for the default

        Login Shell [/bin/sh]: /bin/bash
$
</screen>
    </para><para>
      Sisteminizde <emphasis>NIS</emphasis> kullanılıyorsa <literal>chsh</literal>
      yerine <literal>yppasswd -s</literal> komutunu kullanmalısınız.
    </para>
  </sect1>
  <sect1 id="archive-tlkg-lis-3.1">
    <title>Yönlendirme</title>
    <para>
      Kullanıcı, ekrana yazdığı bir komutun neler yaptığını en rahat şekilde
      komut tarafından ekrana yönlendirilen bilgilerden anlayabilir. Program,
      kullanıcıyı bilgilendirme amacıyla mümkün olduğu kadar çok, fakat
      ortalığı fazla karıştırmamak için de mümkün olduğu kadar az bilgiyi
      ekrana vermelidir.
    </para>
  </sect1>
  <sect1 id="archive-tlkg-lis-3.2">
    <title>Standart Girdi, Çıktı ve Hata</title>
    <para>
      Linux'ta, programın ekrana yazılan bilgiyi iki sınıf altında
      toplayabiliriz. Birincisi, olağandışı bir durumu bildiren standart hata,
      diğeri de her türlü verinin yazıldığı standart çıktı. Program çalıştığı
      andan itibaren bu iki kanal üzerinden akan bilgiler, programın çalıştığı
      sanal terminale yazılırlar. Program girdilerini ise standart girdi
      aracı olan klavyeden alır.
    </para><para>
      Eğer bu bilgiler bir ekran boyundan (25 satır) fazla tutuyorsa bazı
      satırlar programcının gözünden kaçabilir. Bunu önlemek amacıyla standart
      çıktı ve hata bir dosyaya yazılacak şekilde ayarlanabilir. Yönlendirme
      olarak da bilinen bu işlem UNIX altında (DOS'ta olduğu gibi) <literal>&gt;</literal>
      karakteri ile gerçekleştirilir.
    </para><para>
      Örnek olarak o an bulunduğunuz dizinde yeralan dosyaları ekrana getirin:
    </para><para>
      <screen>$ ls -al</screen>
    </para><para>
      Bu komut, standart çıktı olarak dosyaların bilgilerini ekrana
      getirecektir. Bu çıktıyı, bir dosyaya yönlendirelim ve dosyanın içeriğine
      göz atalım:
    </para><para>
<screen>
linux:~$ ls -al &gt; liste
linux:~$ cat liste
total 16
drwxr-xr-x   5 gorkem   users        1024 Feb 13 13:10 .
drwxr-xr-x   4 root     root         1024 Jan  7  1980 ..
-rw-r--r--   1 gorkem   users         390 Feb 13 12:56 .Xdefaults
-rw-r--r--   1 gorkem   ftpadm       2016 Feb 13 13:09 .bash_history
-rw-r--r--   1 gorkem   users           1 Feb 13 12:57 .bashrc
-rw-r--r--   1 gorkem   users         163 Nov 24  1993 .kermrc
-rw-r--r--   1 gorkem   users          34 Nov 24  1993 .less
-rw-r--r--   1 gorkem   users         114 Nov 24  1993 .lessrc
drwxr-xr-x   2 gorkem   users        1024 Jan  7  1980 .term
-rw-r--r--   1 gorkem   users          87 Feb 13 12:56 .xinitrc
-rw-r--r--   1 gorkem   users        2795 Feb 13 13:06 adres
-rw-r--r--   1 gorkem   users           0 Feb 13 13:10 liste
drwxr-xr-x   2 gorkem   users        1024 Feb 13 12:54 mail
drwxr-xr-x   2 gorkem   users        1024 Feb 13 12:54 perl
-rw-r--r--   1 gorkem   users           0 Feb 13 13:10 typescript
linux:~$
</screen>
    </para><para>
      <literal>&gt;</literal> karakteri standart hatayı dosyaya yönlendirmez. Bu işlem için
      <literal>2&gt;</literal> kullanılır. Ama hatayı görebilmek için, hata yaratan bir
      komut yazmalıyız, değil mi?
    </para><para>
<screen>
$ ls /deneme
/deneme : No such file or directory
$ ls /deneme 2&gt; hata
$ cat hata
/deneme : No such file or directory
</screen>
    </para><para>
      Aşağıdaki komutun işletilmesinin ardından standart çıktı <literal>oku1</literal> dosyasına,
      standart hata ise <literal>oku2</literal> dosyasına yazılacaktır. Bu dosyaları komutu
      çalıştırdıktan sonra incelemek suretiyle neler olup bittiğini anlamak
      mümkün olur.
    </para><para>
<screen>
$ mkdir ~/deneme           (deneme isimli bir dizin yaratır)
$ touch ~/deneme/gecici    (gecici isimli bir dosya yaratır)
$ cat ~/deneme 2&gt;oku2 &gt;oku1
</screen>
    </para><para>
      Kabuk, standart çıktı ve standart girdi için sırayla 2 ve 1 numaralarının
      kullanımına izin verir. Yukarıda yeralan son komutta, standart
      hata mesajları için 2 kullanılarak hataların <literal>oku2</literal> dosyasına
      yazılmıştır. Aşağıda, çekirdek derlemek için sürekli kullandığım
      program yeralıyor. Yönlendirme sayesinde ekrana gelmesi gereken mesajlar
      kullanılmayan 9. sanal konsola yönlendiriliyor.
    </para><para>
<screen>
# make config
# make dep &gt; /dev/tty9
# make clean &gt; /dev/tty9
# time make zImage &gt; /dev/tty9
</screen>
    </para><para>
      Son satırdaki <literal>time</literal> komutu, kendinden sonra gelen komutun ne kadar
      zaman içinde çalıştırıldığını gösterir. Çekirdek derlemede geçen zaman,
      makinanın gücü hakkında bir fikir verebilir. Peki ne hata, ne de çıktıyı
      ekranda görmek istemiyorsam ne yapmalıyım ? Bunun için standart çıktı
      ve hatayı biraraya getirerek yönlendirilen her çıktının kaybolduğu
      ``kara deliğe'' atmak yeterlidir:
    </para><para>
<screen>
$ ls /deneme &gt; /dev/null 2&gt;&amp;1
</screen>
    </para><para>
      Yukarıdaki komutun yazılış sırasına dikkat edin.
    </para><para>
      <emphasis>Standart çıktı</emphasis> ya da <emphasis>standart hata</emphasis>yı yönlendirirken, <literal>&gt;</literal>
      işareti kullanırsanız: dosya yoksa, oluşturulur ve komutun çıktısı dosyaya
      yazılır. Dosya varsa, içeriği yok olur ve komutun çıktısı dosyanın yeni
      içeriği olur. Var olan bir dosyayının eski içeriğini tamamen silmek
      değil de komutun çıktısını dosyaya eklemek istiyorsanız <literal>&gt;&gt;</literal>
      kullanmalısınız.  Bu durumda dosya varsa komutun çıktısı dosyanın eski
      içeriği korunarak sonuna eklenir, dosya yoksa oluşturulur ve komutun
      çıktısı dosyaya yazılır. Örneğin:
    </para><para>
<screen>
$ echo deneme1 &gt;&gt;deneme.txt
$ cat deneme.txt
deneme1
$ echo deneme2 &gt;&gt;deneme.txt
$ cat deneme.txt
deneme1
deneme2
$
</screen>
    </para><para>
      Örnekte görüldügü gibi ilk komut <literal>deneme.txt</literal> dosyasını
      oluşturdu. İkincisi ise oluşan dosyanın içeriğini koruyarak ikinci komutun
      çıktısını bu dosyanın sonuna ekliyor.
    </para><para>
      Standart hata ve çıktıya ek olarak UNIX'in desteklediği bir yönlendirme
      daha vardır: Standart girdi sayesinde bir dosyayı oluşturan satırlar,
      bir komut veya programa yönlendirilebilir. Daha önce bir metin editor
      kullanarak hazırlamış olduğumuz raporu patrona kısa yoldan göndermek
      için,
    </para><para>
<screen>
$ mail -s &quot;rapor&quot; patron &lt; rapor.txt
</screen>
    </para><para>
      Dosyanın içeriği, mail komutuna girdi olmuş ve <literal>rapor.txt</literal> dosyası
      <literal>patron</literal> kullanıcısına ``rapor'' konu başlığıyla e-posta ile
      gönderilmiştir.
    </para>
  </sect1>
  <sect1 id="archive-tlkg-lis-3.3">
    <title>Kanallama (pipe) İşlemleri</title>
    <para>
      Bazı durumlarda, bir komutun çıktısı diğer bir komuta
      yönlendirilebilir. Başka bir deyişle, komutun standart çıktısını
      bir dosyaya değil, bu çıktıyı işleyecek başka bir komuta yönlendirmek
      istiyorsunuz. Bu amaçla UNIX altında (yine DOS'ta olduğu gibi) boru (|)
      karakteri kullanılır. Bu karakter, kendinden önce gelen komut veya komut
      serisinin çıktısını, kendinden sonra gelen komuta gönderir. Örneğin bir
      dizinde yeralan tüm dosyaları yazıcıya aktarmak için,
    </para><para>
<screen>
$ ls -al | lpr
</screen>
    </para><para>
      komutları kullanılabilir. Artık <literal>ls -al</literal> komutunun ekrana vermesi gereken
      tüm bilgiler, <literal>lpr</literal> komutu aracılığıyla yazıcıya gönderilmiştir. İlk komutun
      standart çıktısı, ikinci komuta standart girdi olarak atanır. Diğer bir
      örnekte, <literal>README</literal> dosyasında kaç satır olduğu bulunuyor. Bir dosyadaki
      veya komut çıktısındaki satır, karakter ve kelime sayılarını bulmak için
      <literal>wc</literal> komutunu  kullanabilirsiniz.
    </para><para>
<screen>
$ who | wc -l
40
</screen>
    </para><para>
      Yönlendirme ve kanallama işlemleri bazen insanın kafasını
      karıştırabilir. Yönlendirme, bir programdan bir dosyaya yapılabilir,
      fakat bir programdan başka bir programa yönlendirme yapamazsınız. Benzer
      şekilde, iki dosyanın arasında kanallama işlemi uygulamak mümkün olmaz.
    </para><para>
      Şimdi de biraz karışık bir örnek:
    </para><para>
<screen>
# ps -aux | grep inetd | grep -v grep | awk '{print $2}' | xargs kill -1
</screen>
    </para><para>
      Yukarıdaki örnek zorlama bir örnek değil, bir Linux sistem yöneticisinin
      her an kullanması gerekebilecek türden. Bu örneği burada ayrıntılı
      olarak açıklamayacağız, sadece <emphasis>pipe</emphasis> kullanarak ne kadar fazla
      sayıda komutun birbirine bağlanabildiğini göstemek amacıyla verdik.
      Bu ve benzeri komutların ayrıntılı açıklamaların kabuk programlamayla
      ilgili bölümde bulabilirsiniz.
    </para>
  </sect1>
  <sect1 id="archive-tlkg-lis-3.4">
    <title>Çokgörevlilik</title>
    <para>
      UNIX'in en büyük silahlarından biri süreçlerdir. Her süreç sistemde
      bağımsız çalışan, birbirini etkilemeyen ve herbiri kendi kaynağını
      kullanan programdır. Süreçler arkaplanda veya kabuğun kontrolünde
      çalışabilir. Çekirdek, her sürecin kullandığı sistem kaynağından
      haberdar olur ve bu kaynakların süreçler arasında adilce paylaşılmasından
      sorumludur.
    </para><para>
      Bir süreç, aksi belirtilmedikçe çalıştığı süre içinde klavyeden bilgi
      alır ve ekrana bilgi verir.
    </para><para>
      Kullanıcıların haberi bile olmadan çalışan süreçler, Linux makinasındaki
      G/Ç işlemlerini gerçekleştirebilmek için sürekli faaliyet içinde
      bulunurlar. Onlarca süreçten bazıları kullanıcıların sisteme girmesini
      sağlarken (getty) bazıları da WWW ve FTP gibi İnternet tabanlı istekleri
      yerine getirir (httpd, ftpd).
    </para>
    <sect2>
      <title>Arkaplanda Çalıştırma</title>
      <para>
        Bir komutu arkaplanda çalıştırmak için, komutun sonuna <literal>&amp;</literal> karakteri
        getirin. Komutu girdikten sonra tekrar kabuk istemcisine düşecek ve kaldığınız
        yerden devam edebileceksiniz. Program, arkaplanda diğer süreçlerle
        çakışmadan bir süre çalışır ve işi bittiğinde durur.
      </para><para>
<screen>
$ sort buyuk_dosya &gt; buyuk_dosya.sirali &amp;
[1] 772
</screen>
      </para><para>
        Komutun arkaplana atılmasından sonra ekranda yeralan <literal>[1]</literal> , sürecin sıra
        numarasını, 772 sayısı ise süreç kimliğini (PID - Process ID) gösterir.
        Her program, sistem kaynaklarını biraz daha azalttığından Linux'çuların
        deyimiyle makina <emphasis>yavaşlar</emphasis>.
      </para><para>
        Çalışan programların listesini görmek için <literal>ps</literal> komutunu kullanın. Hiç
        parametre vermeden yazılırsa sadece üzerinde çalışılan kullanıcının
        süreçleri ekrana gelir. Sık kullanılan bir başka parametre dizisi de <literal>uax</literal>
        tir. Bu sayede sistemdeki o anda çalışan tüm programlar daha ayrıntılı
        bir şekilde ekrana listelenir.
      </para><para>
<screen>
$ ps
PID TTY STAT  TIME COMMAND
   76 v02 S     0:00 -bash
  111 v02 R     0:00 ps
</screen>
      </para><para>
<screen>
$ ps -aux
USER       PID %CPU %MEM SIZE  RSS TTY STAT START   TIME COMMAND
bin         63  0.0  5.5   64  364  ?  S    11:12   0:00 /usr/sbin/rpc.portmap
gorkem      76  0.0  9.7  101  644 v02 S    11:12   0:00 -bash
gorkem     112  0.0  5.0   59  332 v02 R    11:16   0:00 ps -aux
root         1  0.0  5.0   56  332  ?  S    11:12   0:00 init [5]
root         6  0.0  4.2   35  284  ?  S    11:12   0:00 bdflush (daemon)
root         7  0.0  4.2   35  284  ?  S    11:12   0:00 update (bdflush)
root        48  0.0  5.1   45  340  ?  S    11:12   0:00 /usr/sbin/crond -l10
root        59  0.0  5.5   53  364  ?  S    11:12   0:00 /usr/sbin/syslogd
root        61  0.0  5.0   44  336  ?  S    11:12   0:00 /usr/sbin/klogd
root        65  0.0  5.5   62  364  ?  S    11:12   0:00 /usr/sbin/inetd
root        67  0.0  5.8   79  388  ?  S    11:12   0:00 /usr/sbin/rpc.mountd
root        69  0.0  6.0   88  400  ?  S    11:12   0:00 /usr/sbin/rpc.nfsd
root        75  0.1  9.9  115  660 v01 S    11:12   0:00 -bash
root        77  0.0  4.6   52  304 v03 S    11:12   0:00 /sbin/agetty 38400 tty3
root        78  0.0  4.6   52  304 v04 S    11:12   0:00 /sbin/agetty 38400 tty4
root        79  0.0  4.6   52  304 v05 S    11:12   0:00 /sbin/agetty 38400 tty5
root        80  0.0  4.6   52  304 v06 S    11:12   0:00 /sbin/agetty 38400 tty6
root        81  0.0  5.5   42  368  ?  S    11:12   0:00 gpm -t ms
</screen>
      </para><para>
        Burada yeralan bilgiler sırasıyla:
      </para><para>
        <variablelist>
          <varlistentry>
            <term>PID</term>
            <listitem><para>
              Süreç numarası. Her sürecin farklı bir numara alması sistem
              tarafından düzenlenir.
            </para></listitem>
          </varlistentry>
          <varlistentry>
            <term>%CPU</term>
            <listitem><para>
              İşlemcinin % olarak ne kadarı süreç tarafından kullanılıyor ?
            </para></listitem>
          </varlistentry>
          <varlistentry>
            <term>%MEM</term>
            <listitem><para>
              % olarak hafızada kapladığı yer
            </para></listitem>
          </varlistentry>
          <varlistentry>
            <term>SIZE</term>
            <listitem><para>
              Programın toplam kullandığı bellek alanı (kilobyte)
            </para></listitem>
          </varlistentry>
          <varlistentry>
            <term>RSS</term>
            <listitem><para>
              Programın bellekte kapladığı gerçel alan. Bu değer
              paylaşılan sistem kütüphaneleri (shared library) nedeniyle
              genellikle <literal>SIZE</literal> değerinden küçüktür.
            </para></listitem>
          </varlistentry>
          <varlistentry>
            <term>TTY</term>
            <listitem><para>
              Sürecin çalıştırıldığı (sanal) terminal
            </para></listitem>
          </varlistentry>
          <varlistentry>
            <term>STAT:</term>
            <listitem><para>
              Süreç o sırada ne yapıyor?
            </para><para>
              <variablelist>
                <varlistentry>
                  <term>S</term>
                  <listitem><para>
                    Uyumakta, bu durum genellikle sürecin bir
                    G/Ç işlemi (örneğin fare'nin hareketi ya da
                    ağdan gelecek veriler) beklemesi sırasında olur.
                  </para></listitem>
                </varlistentry>
                <varlistentry>
                  <term>R</term>
                  <listitem><para>
                    Çalışabilir. Çalışabilir süreçler, gereksinim
                    duydukları bütün sistem kaynaklarına sahip olan
                    süreclerdir. Çekirdek (tek işlemcili bir makinada) belirli
                    aralıklarla bu süreçlerden sadece birini çalıştırır.
                  </para></listitem>
                </varlistentry>
                <varlistentry>
                  <term>T</term>
                  <listitem><para>
                    Durmuş. Bu durum sürecin kullanıcı tarafından
                    (örneğin <literal>Control-Z</literal> tuşlarına basılarak)
                    durdurulmasında görülür.
                  </para></listitem>
                </varlistentry>
                <varlistentry>
                  <term>Z</term>
                  <listitem><para>
                    Zombie. Bu tür süreçler, kendisini çalıştıran sürece
                    mesaj bırakamadıklarından takılmış süreçlerdir.
                    <emphasis>Öldürülemezler</emphasis> ancak sitem kaynaklarını da
                    kullanmazlar.
                  </para></listitem>
                </varlistentry>
                <varlistentry>
                  <term>D</term>
                  <listitem><para>
                    Kesilemez uykuda. Bazı G/Ç işlemleri o
                    sırada bu işlemi yapan sürecin kesilmemesini gerektirir.
                    Böyle durumdaki süreçleri de ilgili G/Ç işlemi bitinceye
                    kadar öldüremezsiniz.
                  </para></listitem>
                </varlistentry>
              </variablelist>
            </para></listitem>
          </varlistentry>
          <varlistentry>
            <term>START</term>
            <listitem><para>
              Sürecin çalıştığı zaman
            </para></listitem>
          </varlistentry>
          <varlistentry>
            <term>COMMAND:</term>
            <listitem><para>
              komut satırından girilen programın ismi
            </para></listitem>
          </varlistentry>
        </variablelist>
      </para><para>
        <literal>ps</literal> komutuna bilgisayar üzerinde çalıştığınız her an
        ihtiyaç duymanız mümkündür, bu yüzden çeşitli parametrelerle kullanmayı
        öğrenmelisiniz.
      </para>
    </sect2><sect2>
      <title>Klavye Üzerinden Kesinti</title>
      <para>
        Linux (ve UNIX) altında, klavyeden bazı tuş kombinasyonları yardımıyla
        çalışmakta olan program kesintiye uğratılabilir.
      </para><para>
        Klavyeden kabuk komut satırına yazılan bir programın uzun sürmesi halinde,
        eğer daha önceden komutun arkasına <literal>&amp;</literal> işareti koyup arkaplanda çalışır
        halde bırakılmamışsa, klavyeden yapılan bir müdahele ile durdurulup
        arkaplanda çalışır hale getirilebilir. Örnek vermek gerekirse, uzun
        sürmesi beklenen bir komutu klavyeden yazalım ve ardından <literal>Control-Z</literal>
        tuşlarına basalım:
      </para><para>
<screen>
linux:/etc/rc.d# find /usr -name &quot;o*&quot; -print
/usr/bin/od
/usr/lib/lilo/doc/other.fig
/usr/lib/lilo/doc/other.tex
/usr/man/man1/od.1.gz

[1]+  Stopped                 find /usr -name &quot;o*&quot; -print
linux:/etc/rc.d#
</screen>
      </para><para>
        Bu esnada sürecin çalışmasına ara verilmiş, fakat program tamamen
        durmamıştır. Programın çalışmasını arkaplanda sürdürmek için <literal>bg</literal>
        komutunu kullanın.
      </para><para>
        <screen>$ bg</screen>
      </para><para>
        Bu komutu tekrar komut satırında çalışacak ve klavyeden bilgi girilecek
        şekilde terminale bağlamak için <literal>fg</literal> yazın:
      </para><para>
        <screen>$ fg</screen>
      </para><para>
        Bir programı çalıştırmaya başlattıktan sonra tamamen durdurmaya karar
        vermişseniz klavyeden <literal>Control-C</literal> tuşlarına basın.
      </para><para>
        Durdurulup arkaplanda çalışmaya yönlendirilen süreçlere kısaca <emphasis>görev</emphasis>
        ismi verilir. Tüm görevleri görebilmek için
      </para><para>
        <screen>$ jobs</screen>
      </para><para>
        yazın. Görevler, birden fazla oldukları zaman sıra numarası ile
        belirtilirler.
      </para>
    </sect2><sect2>
      <title>Süreçlerin Sona Erdirilmesi</title>
      <para>
        Her an çalışan süreçlerden biri veya birkaçı, beklenmedik döngüye
        girebilir. Bunun sonucu olarak sistemin kaynaklarını, özellikle hafızayı
        tüketici bir duruma gelebilir. Bu tür kısır döngüye giren süreçleri bulup,
        eğer hayati önem taşımıyorlarsa `öldürmek' gerekir. Süreci öldürmekten
        kasıt, programı tamamen durdurarak sistemle ilişkisini kesmektir. Bu
        sayede programın hafızada kapladığı bölge serbest kalacak, çekirdek
        de hafıza düzenlemesini tekrar yaparak başka süreçlere daha fazla yer
        ayıracaktır. Bir süreci öldürmek için <literal>kill</literal> komutu kullanılır.
        Yukarıdaki 67 numaralı sürece ait <literal>/usr/sbin/rpc.mountd</literal>
        programını öldürmek için şunları yazın:
      </para><para>
        <screen>$ kill 67</screen>
      </para><para>
        Birçok süreç sizden bu mesajı aldıktan sonra, dosya sistemi üzerinde
        yarattığı geçici dosyaları, dosyalar üzerine koyduğu kilitleri
        temizlemek gibi yapması gereken işlemleri yaptiktan sonra çalışmasına
        son verecektir. Eğer öldürmeye çalıştığınız süreç herhangi bir nedenle
        takılmışsa ve bu komuta tepki vermiyorsa aşağıdakini deneyin:
      </para><para>
        <screen>$ kill -9 67</screen>
      </para><para>
        Artık programın sistemle ilişkisi tamamen kesilmiştir. Kill komutu,
        <literal>-9</literal> seçeneğiyle sürece 9 numaralı sinyali gönderir. Bu sinyali
        alan sürecin yukarıda sözü edilen iki özel durum dışında çalışmayı
        sürdürmesi olanaksızdır. <literal>-9</literal> seçeneğini özellikle sistem süreçleri
        üzerinde gerekmedikçe kullanmamalısınız. Diğer sinyaller ve anlamları
        yeri geldikçe diğer bölümlerde anlatılacaktır.
      </para>
    </sect2>
  </sect1>
</chapter>

<chapter id="archive-tlkg-lis-4">
  <title>Dosya ve Dizin İşlemleri</title>
  <sect1 id="archive-tlkg-lis-4g">
    <title>Giriş</title>
    <para>Tıpkı MS-DOS'ta olduğu gibi Linux dosya yapısının da hiyerarşik bir
    yapıya sahip olduğunu söylemiştik. Temel dosya bilgisi önceki konularda
    anlatıldığından burada sadece dosya ve dizinlerle ilgili özelliklere
    değinilecektir.</para>
  </sect1>
  <sect1 id="archive-tlkg-lis-4.1">
    <title>Erişim Hakları</title>
    <para>
      Erişim hakları, Linux dosya sistemi güvenliğinin belkemiğini
      oluşturur. Her dosyaya ayrı verilebilen erişim izinleri sayesinde çok
      daha rahat bir sistem yönetimi gerçekleştirilebilir. Bu, konuya sadece
      sistem görevlisi tarafından yaklaşıldığı zaman çıkartılabilecek bir
      sonuçtur. Kullanıcı bazında erişim hakları bazen daha da anlamlı
      olabilir. Yanlış kullanıldığında hoş olmayan süprizlere yol
      açabilir. Linux altında üç çeşit erişim hakkı vardır:
    </para><para>
      <variablelist>
        <varlistentry>
          <term>Okuma izni</term>
          <listitem><para>
            Dosyanın okuma izni varsa içeriği görülebilir, dizinin okuma izni
            varsa içerdiği dosyaların listesi alınabilir.
          </para></listitem>
        </varlistentry>
        <varlistentry>
          <term>Yazma izni</term>
          <listitem><para>
            Dosyanın yazma izni varsa dosyayı değiştirebilir veya silebilirsiniz.
            Dizine yazma izni verildiğinde dizin altındaki dosyalar yazılabilir
            veya silinebilir.
          </para></listitem>
        </varlistentry>
        <varlistentry>
          <term>Çalıştırma izni</term>
          <listitem><para>
            Dosyayı çalıştırma hakkını verir.
          </para></listitem>
        </varlistentry>
      </variablelist>
    </para><para>
      Bir dosya veya dizin ilk yaratıldığı anda Linux tarafından öntanımlı
      bazı izinler verilir. Genellikle bu izin çalıştırma ve okumadır. Dosyanın
      oluşma anında verilen izini değiştirmek için erişim yetki kalıbı olarak
      da bilinen <literal>umask</literal> komutu kullanılır. Daha fazla bilgi için komuta
      ait man dosyasına bakın.
    </para><para>
      Erişim haklarının dışında bir dosyanın üç izin düzeyi daha vardır. Bunlar,
      dosyanın sahibi, dosyanın grubu ve diğer kullanıcılardır. Dosyanın sahibi,
      o dosyayı oluşturan kişidir. Her kullanıcının bir grubu da olduğu için,
      dosya oluşturulurken kullanıcı hangi grupta ise dosya da o gruba ait
      olacaktır. Dosyanın sahibi olmayan ve grubu da dosyanın grubuyla uyuşmayan
      sistemdeki kullanıcılar ``diğer'' sınıfına girerler. Gruplar hakkında daha
      fazla bilgi için <emphasis>Linux Sistem Yönetimi</emphasis> konusuna bakın.
    </para>
    <sect2>
      <title>Dosya İzinlerinin Değiştirilmesi</title>
      <para>
        Dosya izin bilgilerini görebilmek için <literal>ls</literal> komutu, <literal>-l</literal>
        parametresiyle kullanılır. Aşağıdaki dosya üzerindeki erişim haklarına
        göz atalım:
      </para><para>
<screen>
-rwxr-xr-x   2 gorkem   users          182 Feb 12 03:58 deneme
</screen>
      </para><para>
        Dosya bilgisinin en sol kısmında izin hakları yeralır. En baştaki ``-''
        işareti bunun düz dosya olduğunu belirtir. ``gorkem'', dosyanın sahibi;
        ``users'' ise grubudur. Ardından sırayla uzunluk, son değiştirilme tarihi ve
        dosya ismi gibi bilgiler gelir. Son harf kümesine dosyanın modu da denir.
      </para><para>
        Solda yeralan r,w ve x karakterleri sırayla okuma, çalıştırma ve yazma
        haklarını belirtir. En soldaki ``-'' işaretini ayırdığımız zaman geri
        kalan harfleri üç adet üçlü grup haline getirelim:
      </para><para>
        <screen>rwx     r-x    r-x</screen>
      </para><para>
        Sırayla birinci harf kümesi dosya sahibinin izinlerini, ikinci harf
        kümesi grup izinleri ve son küme de diğer kullanıcıların izinlerini
        belirtir. Buna göre yukarıdaki dosyada
      </para><para>
        <variablelist>
          <varlistentry>
            <term>rwx</term>
            <listitem><para>
              kullanıcı okuyabilir, yazabilir, çalıştırabilir
            </para></listitem>
          </varlistentry>
          <varlistentry>
            <term>r-x</term>
            <listitem><para>
              grup okuyabilir, çalıştırabilir fakat yazamaz.
            </para></listitem>
          </varlistentry>
          <varlistentry>
            <term>r-x</term>
            <listitem><para>
              diğerleri okuyabilir, çalıştırabilir fakat yazamaz.
            </para></listitem>
          </varlistentry>
        </variablelist>
      </para><para>
        Sol baştaki karakter ``d'' olsaydı, bir dizini inceliyor olacaktık.
      </para><para>
        Dosyanın izinlerini değiştirmek için <literal>chmod</literal> komutu kullanılır. Bu
        komutu kullanırken hangi izin düzeyine (kullanıcı, grup veya diğerleri)
        hangi izinlerin verileceği veya kaldırılacağı yazılır.
      </para><para>
        Örnek olarak yukarıdaki dosyanın okuma iznini kaldırmak için
      </para><para>
        <screen>$ chmod -r deneme</screen>
      </para><para>
        kullanılabilir. "-" işareti, iznin kaldırılacağını belirtir. İzin vermek
        için ise "+" yazın. Dosyanın yeni görüntüsü şöyle olur:
      </para><para>
<screen>
--wx--x--x   2 gorkem   users          182 Feb 12 03:58 deneme
</screen>
      </para><para>
        Sadece grubun, sadece kullanıcının veya sadece diğerlerinin erişim
        hakkını değiştirebilmek için her izin düzeyi için bir harf tanımlanmıştır.
        Kullanıcı için "u", grup için "g" ve diğerleri için "o" yazarak belirli
        bir izin düzeyi için erişim hakkını değiştirmek mümkün olur. Bu üç harf,
        izinden hemen önce yazılır.
      </para><para>
<screen>
$ chmod u+x deneme              <emphasis>(dosyanin sahibi calistirabilir)</emphasis>
$ chmod o+r t2sac               <emphasis>(digerleri okuyabilir)</emphasis>
$ chmod g-w deneme              <emphasis>(dosyanin grubu yazamaz)</emphasis>
</screen>
      </para><para>
        Her izin için aynı zamanda sayılar da tanımlanmıştır. Dosyanın erişim
        izinlerinideğiştirmek için her izne ait sayıları kullanabilirsiniz.
        Aşağıdaki tabloda, her izin düzeyi (dosyanın sahibi, grubu ve diğerleri)
        için üçer tane olmak üzere toplam 9 sayıdan oluşan izin numaralarını
        görebilirsiniz. Bir izni vermek için sırayla numaraları toplayın.
        Örneğin sahibinin okuması (400), yazması (200), çalıştırması (100),
        grubun okuması (40), çalıştırması (10) ve diğerlerinin okuması (4)
        ve çalıştırması (1) için kullanılan rakamların toplamı 755'tir.
      </para><para>
        <screen>$ chmod 755 deneme</screen>
      </para><para>
<literallayout>
400      sahibi okur
200      sahibi yazar
100      sahibi çalıştırır

040      grubu okur
020      grubu yazar
010      grubu çalıştırır

004      diğerleri okur
002      diğerleri yazar
001      diğerleri çalıştırır
</literallayout>
      </para><para>
        Başka bir değişiklikle konuyu pekiştirelim. Sahibinin okuması (400),
        yazması (100), grubun okuması (40), diğerlerinin okuması (4) için izin
        numarasını bulmak için bu cümlede parantez içinde yeralan sayıları
        toplarsak 644 yapacaktır.
      </para><para>
        <screen>$ chmod 644 deneme</screen>
      </para><para>
        Aynen dosyalarda olduğu gibi, bir dizinin de sahibi ve grubu vardır.
      </para>
    </sect2><sect2>
      <title>Dosyanın Sahibinin ve Grubunun Değiştirilmesi</title>
      <para>
        Bir dosyanın sahibini sadece sistemdeki <emphasis>root</emphasis>
        kullanıcı değiştirebilme yetkisine sahiptir. Dosya sahibinin
        değiştirilmesi için <literal>chown</literal> komutu kullanılabilir.
        Yukarıdaki dosyanın sahibini <emphasis>ozgur</emphasis> isimli
        kullanıcı yapalım.
      </para><para>
        <screen># chown ozgur deneme</screen>
      </para><para>
        Dosyanın yeni hali şöyle olur:
      </para><para>
<screen>
-rwxr-xr-x   2 ozgur   users          182 Feb 12 03:58 deneme
</screen>
      </para><para>
        <literal>chgrp</literal> komutu yardımıyla da dosyanın grubunu
        değiştirilebilir. Yukarıdaki dosyanın grubunu www yapmak için
      </para><para>
        <screen># chgrp www deneme</screen>
      </para><para>
        komutu kullanılabilir. <literal>chown</literal> komutu, dosyanın hem
        kullanıcısını, hem de grubunu değiştirme özelliğine sahiptir. <literal>chown</literal>
        komutundan sonra kullanıcı ve grup isimlerini aralarında bir nokta
        kalacak şekilde yazın.
      </para><para>
<screen>
$ chown ozgur.www deneme
$ ls -l deneme
-rwxr-xr-x   2 ozgur   www          182 Feb 12 03:58 deneme
</screen>
      </para>
    </sect2>
  </sect1>
  <sect1 id="archive-tlkg-lis-4.2">
    <title>Diğer Dosya Sistemlerinin Kullanılması</title>
    <para>
      Bir Linux işletim sisteminde dosyaların ve dizinlerin herbirisi sabit disk,
      CDROM veya diğer bilgi saklamaya yarayan cihazların birer parçası olan
      "dosya sistemlerinde" tutulur. Linux'un desteklediği pek çok dosya sistemi
      vardır ve bunların her birisinin veri depolarken kullandıkları yöntem
      birbirinden farklıdır.
    </para><para>
      Linux'ta her dosya sistemi farklı bir dizinde tutulur ve bu dizinlerin
      bilgisi <literal>/etc/fstab</literal> dosyasında yeralır. Açılış anında bu
      dosyada hangi dosya sistemlerinin hangi dizinler altına yerleştirileceği
      okunur ve buna göre makina açılır. Linux, kendisi için özel olarak
      geliştirilen ext2 dosya sistemini kullanır.
    </para><para>
      Bir sistem görevlisi olarak çeşitli dosya sistemlerini tanımalı, bu dosya
      sistemleri üzerinde hata oluşması durumunda zararı en aza indirecek yolu
      bilmelisiniz. Bilgisayar başında geçireceğiniz zamanınızın büyük bir
      bölümünü dosya sistemleri üzerinde harcayacaksınız.
    </para>
    <sect2>
      <title>mount İşlemi</title>
      <para>
        Bir dosya sisteminin kullanılabilmesi için boş bir dizin altına
        yerleştirilmesi gerekir. Ancak bu gerçekleştirilirse sözkonusu
        dosya sistemini oluşturan dosyalar üzerinde işlem yapılabilir.
        Bu işlem <literal>mount</literal> komutu yardımıyla yapılır.
      </para><para>
        <literal>mount</literal> komutunun şu şekilde kullanılır:
      </para><para>
        <screen>mount -t &lt;tip&gt; &lt;nereye&gt; &lt;aygit&gt;</screen>
      </para><para>
        <command>tip</command>: Dosya sistemi çeşidi. Örnek dosya sistem
        çeşitleri arasında ext2, minix, msdos sayılabilir. Dosya sistemleri
        hakkında daha geniş bilgi için Çekirdek yapılandırması konusuna
        bakın. Genellikle mount programı ne tür bir diske
        eriştiğini otomatik olarak anlayacaktır.
      </para><para>
        <command>nereye</command>: mount edilecek dosya sistemi hangi dizin
        altına yerleştirileceğini belirtir.
      </para><para>
        <command>aygıt</command>: Üzerinde dosya sisteminin bulunduğu sabit disk,
        CD-ROM benzeri aygıt.
      </para><para>
        Linux'a bağlı olan tüm donanımlara ait bir giriş, <literal>/dev</literal>
        dizini altında bulunur. Bu dizin altındaki dosyalar özel olarak
        tanımlanmıştır ve bunlara kısaca "düğüm" adı verilir. Örneğin
        <literal>/dev/hda2</literal>, birinci IDE sabit diskin ikinci bölümünü;
        <literal>/dev/tty1</literal> ise birinci sanal konsolu gösterir.
      </para><para>
        Çeşitli sabit disklere ait <literal>/dev</literal> düğümleri,
        <emphasis>Linux Kurulumu</emphasis> bölümünde ayrıntılı olarak
        anlatılmıştı. mount programı bu düğümlere ihtiyaç duyacaktır.
        Bu yüzden bir dosya sistemini erişilebilir hale getirebilmek için
        hangi düğüm ismine sahip olduğunu bilmelisiniz. Örnek olarak
        CD-ROM için <literal>/dev/cdrom</literal>, birinci disket sürücü
        için <literal>/dev/fd0</literal> gibi.
      </para><para>
        CD-ROM sürücüsünü <literal>/mnt</literal> altına mount etmek için
      </para><para>
        <screen># mount -t iso9660 /dev/cdrom /mnt</screen>
      </para><para>
        yazın. Eğer çekirdekte CD-ROM dosya sistemi desteği varsa ve sistem
        açılırken çekirdek CD-ROM'u tanımışsa <literal>/mnt</literal> dizini
        altına CD'deki dosya sistemi yerleştirilir. Buna benzer şekilde MS-DOS
        disket içeren disket sürücüyü ve üzerinde ext2 dosya sistemi bulunan
        ikinci IDE sabit diskin birinci bölümünü sırasıyla
        <literal>/mnt/disket</literal> ve <literal>/mnt/disk</literal>
        dizinlerine bağlamak için
      </para><para>
        <screen># mount -t msdos /dev/fd0 /mnt/disket</screen>
      </para><para>
        ve
      </para><para>
        <screen># mount -t ext2 /dev/hdb1 /mnt/disk</screen>
      </para><para>
        yazılabilir. Bir mount işleminin tersini yapmak ve dosya sistemini
        erişilemez kılmak için <literal>umount</literal> komutu kullanılır.
        <literal>/disk</literal> altındaki <literal>/dev/hdb1</literal> sabit
        disk bölümünü ayırmak etmek için
      </para><para>
        <screen># umount /disk</screen>
      </para><para>
        veya
      </para><para>
        <screen># umount /dev/hdb1</screen>
      </para><para>
        kullanılır. Her iki yazım şekli de kabul edilir. Son olarak o an
        sistemde bindirilmiş halde bulunan tüm dosya sistemlerini görmek için
        <literal>mount</literal> komutunu parametresiz yazın. Bu komut hakkında daha ayrıntılı
        bilgi ve aldığı diğer parametreler için man sayfasına bakın.
      </para><para>
        <literal>mount</literal> ve <literal>umount</literal> komutları ile bir dizin yapısını disk üzerinde
        konumlandırırken veya ayırırken üzerinde işlem yapılan dizinde
        bulunmamanız ya da o dizinde başka bir süreç çalışıyor olmaması
        gereklidir. Aksi takdirde aşağıdaki hata mesajını alırsınız:
      </para><para>
<screen>
# pwd
/disk
# umount /disk
umount: /dev/hdb1: device is busy
</screen>
      </para><para>
        Yapmanız gereken, ayıracağınız dizinden dışarı çıkıp tekrar denemek. Diğer
        bir seçenek de <literal>fuser</literal> komutunu kullanmak. Bu komut, ayırmak istediğiniz
        dizini kullanan tüm süreçleri ekranda gösterir. Böylelikle
        rahatlıkla yukarıdaki örnekteki gibi <literal>umount</literal> işlemini
        gerçekleştirebilirsiniz. <literal>fuser</literal> komutunun -km seçeneğiyle o dizini
        kullanan süreçleri öldürülebilir.
      </para><para>
<screen>
# cd /
# fuser /disk
/disk:                   78c
# fuser -km /disk
# umount /disk
</screen>
      </para><para>
        <literal>fuser</literal> komutunu kullanırken dikkatli olun, zira sistemi kilitlenme noktasına
        getirebilirsiniz.
      </para>
    </sect2><sect2>
      <title>Dosya Sistemi Bilgileri</title>
      <para>
        Linux açılırken <literal>mount</literal> komutu yardımıyla root dosya
        sistemine ekleyeceği her değişik dosya sistemini
        <literal>/etc/fstab</literal> dosyasından okur ve işleme koyar.
        Aşağıda örnek bir fstab dosyası yeralıyor.
      </para><para>
<screen>
/dev/hda2       /               ext2            defaults  1 1
/swap           none            swap            defaults  1 1
/dev/cdrom      /cdrom          iso9660         defaults  1 1
none            /proc           proc            defaults  1 1
/dev/hda1       /dos            msdos           defaults  1 1
</screen>
      </para><para>
        Çekirdek açılış mesajları içinde
      </para><para>
<screen>
VFS: Mounted root (ext2 filesystem) readonly.
</screen>
      </para><para>
        gibi bir satır göreceksiniz. Sistem açılırken en önce <literal>/</literal>
        dosya sistemini bağlar. Bu sayede bu dosya sistemi altında yeralan ve hayati
        önem taşıyan yazılımlara (<literal>fsck</literal>, <literal>mount</literal>
        gibi) ulaşır. Daha sonra yerel dosya sistemleri ve en son da ağ üzerinden
        erişilen dosya sistemlerine (NFS) bağlanır. fstab dosyasında kullanıcının
        kendi dosyalarını yerleştiremediği, fakat sistem tarafından kullanılan
        <emphasis>swap</emphasis> ve <emphasis>proc</emphasis> dosya sistemleri
        için de mount bilgileri bulunur.
      </para><para>
        Yukarıdaki fstab dosyasında ext2 dosya sistemine sahip
        <literal>/dev/hda2</literal> sabit disk bölümü, / dizinini oluşturuyor.
        MS-DOS biçemli <literal>/dev/hda1</literal> bölümü de
        <literal>/dos</literal> dizinine erişilebilir olarak açılış anında eklenecektir.
      </para><para>
        Sistemdeki CD-ROM sürücü <literal>/cdrom</literal> dizini altına
        yerleştirilmiş olup root kullanıcı bunu istediği dizine koyabilir.
        Bu dosyaya, mount komutundaki gibi parametreler de eklenebilir.
        Dördüncü sırada yeralan defaults parametresinin yanına eklemek
        istediğiniz seçenekleri yazın. Bu parametrelerden sıkça kullanılan
        bir tanesi de "user" olup root dışındaki kullanıcılara mount hakkını
        verir. CD-ROM sürücüyü normal sistem kullanıcılarının mount veya umount
        yapabilmesi için fstab dosyasındaki ilgili satırı
      </para><para>
<screen>
/dev/cdrom      /cdrom          iso9660                 defaults,user 1 1
</screen>
      </para><para>
        satırıyla değiştirin. <emphasis>defaults</emphasis> parametresi ise,
        halihazırdaki dosya sistemini okunup yazılabildiğini, asenkron olduğunu,
        üzerindeki bilgileri bloklar halinde alıp verdiğini (buna diğer örnekler
        CD-ROM ve disket sürücülerdir), içerdiği programların çalıştırılabilir
        olduğunu ve normal kullanıcıların <literal>mount</literal>,
        <literal>umount</literal> yapamadığını gösterir. <emphasis>user</emphasis>
        parametresiyle kullanıcılara <literal>mount</literal> ve
        <literal>umount</literal> hakkı yukarıda verilmiştir.
      </para>
    </sect2><sect2>
      <title>Dosya Sistemi Oluşturulması ve Denetlenmesi</title>
      <para>
        Bazen MS-DOS altından oluşturulamayan dosya sistemlerini (ext2 gibi)
        oluşturmak gerekebilir. Linux altında bir dosya sistemini oluştururken aynı
        zamanda bunu kontrol eden programlar vardır. Bunların en çok kullanılanı,
        Slackware sürümünde gelen <literal>mkfs</literal>/'tir.
      </para><para>
        <literal>mkfs</literal> ile Linux native (ext2) dosya sistemi oluşturmak
        için <literal>mkfs.ext2</literal> programı kullanılır.
      </para><para>
<screen>
mkfs.ext2 &lt;aygit&gt; &lt;blok-sayisi&gt;
</screen>
      </para><para>
        "aygıt" yerine üzerine dosya sistemi kurulacak olan cihazın
        <literal>/dev</literal> dizini altındaki düğüm dosyasının ismi
        yazılır. Blok sayısı yerine, <literal>fdisk</literal> yazılımından
        o bölümün kaç blok olduğunu öğrenip bu sayıyı girmelisiniz. Bir
        blok 1024 bayttan oluşur. Örneğin
      </para><para>
<screen>
# mke2fs /dev/hda3 163829
</screen>
      </para><para>
        komutu, <literal>/dev/hda3</literal> disk bölümünde ext2 dosya sistemi
        kurar. Bu komutu kullanmadan önce iyi düşünün, zira burada yeralan tüm
        dosyalar silinir ve bu hatanın geri dönüşü olmaz. Aşağıdaki komut ile
        bir disket üzerinde ext2 dosya sistemi kuruluyor.
      </para><para>
<screen>
# mke2fs /dev/fd0 1440
</screen>
      </para><para>
        <literal>mke2fs</literal> ile <literal>mkfs.ext2</literal> komutları
        aynıdır. Benzer şekilde, MS-DOS dosya sistemi yaratmak için
        <literal>mkfs.msdos</literal>, minix dosya sistemi yaratmak için
        <literal>mkfs.minix</literal> kullanılabilir. Blok sayısı girilmez ise
        <literal>mke2fs</literal> bunu otomatik olarak bulacaktır.
      </para><para>
        Herhangi bir sebepten dolayı diskte bozulma ve veri kaybını en aza
        indirmek için de yazılımlar vardır. <literal>fsck</literal> ile dosya
        sistemi kontrolü yapılabilir. <literal>fsck</literal> ile ext2,
        <literal>dosfsck</literal> (veya <literal>fsck.msdos</literal>) ile
        MS-DOS biçemli alanlar kontrol edilir.
      </para><para>
<screen>
linux:~# fsck /dev/hda2
Parallelizing fsck version 0.5b (14-Feb-95)
e2fsck 0.5b, 14-Feb-95 for EXT2 FS 0.5a, 95/03/19
/dev/hda2 is mounted.  Do you really want to continue (y/n)? yes

Pass 1: Checking inodes, blocks, and sizes
Pass 2: Checking directory structure
Pass 3: Checking directory connectivity
Pass 4: Checking reference counts
Pass 5: Checking group summary information
Fix summary information&lt;y&gt;? yes

Block bitmap differences: -46486 -46487 -46488 -46489 -46490.  FIXED
Free blocks count wrong for group 5 (2803, counted=2808).  FIXED
Free blocks count wrong (16326, counted=16331).  FIXED

/dev/hda2: ***** FILE SYSTEM WAS MODIFIED *****
/dev/hda2: ***** REBOOT LINUX *****
/dev/hda2: 3494/29632 files, 42904/59235 blocks
</screen>
      </para><para>
        Bir dosya sistemini kontrol etmeden önce okunan bölümü root dosya
        sisteminden ayırın ve kontrol işleminden sonra bilgisayarı kapatıp
        tekrar açın.
      </para><para>
        <literal>debugfs</literal> programı, dosya sistemi parametrelerini
        incelemek için kullanılır. Disk üzerine doğrudan erişım yaptığı için dikkatli
        kullanmalısınız. ext2fs yardımıyla kurtarılamayan bazı dosyalar (özellikle
        silinmiş dosyalar) <literal>debugfs</literal> yardımıyla kurtarılabilir.
      </para>
    </sect2>
  </sect1>
  <sect1 id="archive-tlkg-lis-4.3">
    <title>Sembolik Bağlantılar</title>
    <para>
      Bazı durumlarda, bir dosyayı oluşturup bu dosyanın başka bir dosyayı
      işaret etmesi istenebilir. Genellikle sistem yöneticileri tarafından
      kullanılan sembolik bağlantı yardımıyla bir dosya veya dizin, bunlara
      karşılık gelen başka bir dosya veya dizin olarak gösterilir.
    </para><para>
      Aşağıda bir sembolik bağlantı örneği yeralıyor. Sistem görevlisi,
      <literal>/root</literal> dizini altındayken
      <literal>/usr/src/linux</literal> dizinine geçmek istiyor.
      <literal>/usr/src/linux</literal> dizinine işaret eden bir bağlantı
      kurmak için <literal>ln</literal> komutu kullanılır. <literal>-s</literal>
      parametresi, bu bağlantının sembolik olacağına işaret eder.
    </para><para>
<screen>
ln -s &lt;nereye-baglanti-yapilacak&gt; &lt;hangi-isimle-yapilacak&gt;
</screen>
    </para><para>
<screen>
linux:~# ls -l
total 116
drwxr-xr-x   2 root     root         1024 Feb 14 08:13 kernel
-rw-r--r--   1 root     root       115695 Sep 15  1994 lodlin15.zip
drwx------   2 root     root         1024 Jan  7  1980 mail
-rw-r--r--   1 root     root            0 Feb 15 08:14 typescript
linux:~# ln -s /usr/src/linux linux
linux:~# ls -l
total 116
drwxr-xr-x   2 root     root         1024 Feb 14 08:13 kernel
-rw-r--r--   1 root     root       115695 Sep 15  1994 lodlin15.zip
drwx------   2 root     root         1024 Jan  7  1980 mail
lrwxrwxrwx   1 root     root            9 Feb 15 08:14 linux -&gt; /usr/src/linux
-rw-r--r--   1 root     root            0 Feb 15 08:14 typescript
</screen>
    </para><para>
      Bu işlemden sonra kullanıcının <literal>/usr/src/linux</literal>
      dizinine geçmesi için <literal>cd linux</literal>" yazması yetecektir.
      Sembolik bağlantı dosyasını diğerlerinden ayıran, satırın en solundaki
      <literal>l</literal> karakteridir.
    </para>
  </sect1>
  <sect1 id="archive-tlkg-lis-4.4">
    <title>Dosya Arşivleme ve Sıkıştırma</title>
    <para>
      Linux altında dosya arşivlenmesi ve sıkıştırılması neredeyse belirli ve
      standartlaşmış birkaç komut ile gerçekleştiriliyor. <literal>tar</literal>
      komutu yardımıyla istenilen dosyaları arşivleyebilir, bunların üzerine
      yenilerini ekleyebilir, istediğiniz zaman da tekrar açıp eski haline
      getirebilirsiniz. GNU <literal>gzip</literal> komutu ise dosyaların
      sıkıştırılması (zip) ve sıkıştırılmış dosyaların açılması (unzip)
      işlemlerini yapabiliyor. Fazla disk alanınız yoksa bu iki komut her
      zaman yardımınıza koşacaktır.
    </para>
    <sect2>
      <title>Dosya Arşivleme</title>
      <para>
        <literal>tar</literal> (Tape ARchive) programı, bir veya birden fazla
        dosyayı tek bir forma sokar. Genellikle bir dizin ve bu dizinin altında
        yer alan tüm alt dizinleri biraraya getirmek için kullanılır.
        <literal>tar</literal>, dosyaların üzerinde sıkıştırma işlemini normalde
        uygulamaz. Fakat <literal>tar</literal>'ın GNU sürümü (Linux'ta da
        kullanılan) bu işlemi gzip kullanmadan da yapabiliyor.
      </para><para>
        <literal>tar</literal> komutuna bir örnek verelim:
      </para><para>
<screen>
$ tar -cf arsiv.tar tmp/
</screen>
      </para><para>
        Bu komut, <literal>-c</literal> (create archive) parametresi yardımıyla
        <literal>tmp</literal> dizini altındaki herşeyi paketleyip
        <literal>arsiv.tar</literal> isimli dosyaya yollar. <literal>-f</literal>
        parametresi, hangi dosyaya yazılacağını belirtir. İstediğiniz zaman
        dosyayı tekrar açmak isterseniz:
      </para><para>
<screen>
$ tar -xf arsiv.tar
</screen>
      </para><para>
        komutunu kullanın. <literal>-x</literal> (extract) parametresi,
        <literal>-f</literal> ile belirtilen dosyayı açacaktır.
      </para><para>
        <literal>-r</literal>seçeneği ile daha önce yaratılmış bir arşive
        dosya eklenebilir. Böylece dosyayı açma ve tekrar arşiv oluşturma
        işleminden kurtulmuş olursunuz.
      </para><para>
<screen>
$ tar -rf arsiv.tar ekleme.txt
</screen>
      </para><para>
        Dosyanın içeriğini önceden görebilmek için <literal>-t</literal>
        parametresini kullanın ve bu işlemi de alışkanlık haline getirin.
        Bazı durumlarda arşivlenmiş yazılım, kendine ait bir dizin açmak
        yerine içerdiği dosyaları bulunduğu yere yazabilir.
      </para><para>
<screen>
tar -tf arsiv.tar
</screen>
      </para><para>
        Hangi dosyaların açıldığını ekranda görebilmek için
        <literal>-v</literal> parametresini ekleyin:
      </para><para>
<screen>
# tar -zcvf tmp.tgz /tmp
tar: Removing leading / from absolute path names in the archive.
tmp/
tmp/tar-error
tmp/.X11-unix/
tmp/rc.inet1.OLD
tmp/networks.OLD
tmp/linux/
tmp/linux/fss.txt
tmp/lilo.conf
tmp/PKGTOOL.REMOVED
</screen>
      </para><para>
        Aşağıdaki komut, arşivlenen dosyaları diskete kaydetmeye yarıyor. Bunun
        için temiz bir disketi yuvasına yerleştirin ve aşağıdaki satırı yazın.
      </para><para>
<screen>
# tar -cf /dev/fd0 tmp/
</screen>
      </para><para>
        <literal>tmp</literal> dizini altındaki herşeyi diskete kaydetmiş olduk.
        Açmak için bilinen yöntemi kullanırız:
      </para><para>
<screen>
# tar -xf /dev/fd0
</screen>
      </para>
    </sect2><sect2>
      <title>Dosya Sıkıştırma ve Açma</title>
      <para>
        Dosya sıkıştırma amacıyla sıkça kullanan iki yazılım vardır:
        <literal>gzip</literal> ve <literal>compress</literal>. Her iki
        yazılım da <emphasis>Slackware Linux</emphasis> dağıtımında
        bulunuyor. GNU'nun dağıtımı olan <literal>gzip</literal>,
        <literal>tar</literal> ile birlikte kullanılan ve dosya
        sıkıştırma ve arşivlemede neredeyse standart haline gelmiş bir
        program. Bir dosyayı sıkıştırmak için parametre girmeden <literal>gzip</literal>
        komutunun ardından dosya ismini yazın.
      </para><para>
<screen>
$ gzip elvis
$ ls -al
elvis.gz
</screen>
      </para><para>
        <literal>gzip</literal> ile sıkıştırılmış dosyaların sonu <literal>.gz</literal> ile biter.
        Bunları açmak için <literal>gunzip</literal> komutunu kullanın:
      </para><para>
<screen>
$ gunzip elvis.gz
</screen>
      </para><para>
        <literal>compress</literal> ve <literal>uncompress</literal> de sırayla
        bir dosyayı sıkıştırmak ve açmak için kullanılır. Aslında Linux'ta
        <literal>uncompress</literal> adında bir yazılım yoktur, bu dosya ismi
        <literal>compress</literal> dosyasına bağlantılıdır.
        <literal>compress</literal> ile sıkıştırılan dosyaların sonu
        <literal>.Z</literal> ile biter.
      </para><para>
<screen>
$ ls -al web.html
-rw-r--r--   1 gorkem   users       41450 Jan 27 13:40 web.html
$ compress web.html
$ ls -al web.html.Z
-rw-r--r--   1 gorkem   users       18906 Jan 27 13:40 web.html.Z
</screen>
      </para><para>
        Yukarıdaki <literal>web.html</literal> dosyasını sıkıştırdığımızda
        dosyanın boyutu 41450 bayttan 18906 bayta indi. Açmak için:
      </para><para>
<screen>
$ uncompress web.html.Z
</screen>
      </para><para>
        Bir dosyanın uzantısından ne tür bir dosya olduğunu anlayamazsanız file
        komutu imdadınıza koşar. Linux'ta belirli uzantılı dosyaların başı
        bilinen bir harf veya harf grubu ile başlar. file komutu dosyanın başındaki
        karakterleri kontrol ederek ve bunları bir listeyle
        (<literal>/etc/magic</literal>) karşılaştırarak dosyanın ne tür olduğunu söyler.
      </para><para>
<screen>
# file tmp.gz
tmp.tgz: gzip compressed data - deflate method , last modified: Sat Feb 15 08:21:50 1997 os: Unix
# file tmp.tar.Z
tmp.tar.Z: compressed data 16 bits
</screen>
      </para>
    </sect2><sect2>
      <title>Birlikte Kullanım</title>
      <para>
        ftp adreslerinde Linux için yeralan yazılımlar genellikle <literal>tar</literal> ve
        <literal>gzip</literal>, nadiren de <literal>tar</literal> ve <literal>compress</literal> ile sıkıştırılıp
        arşivelenerek saklanırlar. Çünkü tar komutu tek başına arşivi sıkıştırmaz, bu
        işlem için <literal>gzip</literal> veya <literal>compress</literal> kullanılır. Bunların
        açılabilmesi için <literal>tar</literal> komutu ve birkaç parametre yeterli olur.
      </para><para>
<screen>
$ ls
netscape-4.0.linux-elf.tar.gz
</screen>
      </para><para>
        Yukarıdaki dosya önce tar ile arşivlenmiş, ardından
        <literal>gzip</literal> ile sıkıştırılmış. Tek adımda bu iki dosyayı
        açmak için tar dosyasına x ve f parametrelerinin dışında z parametresini
        de ekleyin:
      </para><para>
<screen>
$ tar -zxf netscape-4.0.linux-elf.tar.gz
$ ls
netscape-4.0.linux-elf
</screen>
      </para><para>
        Eğer dosya sıkıştırılırken compress komutu kullanılmışsa z yerine
        Z parametresini yazın.
      </para><para>
<screen>
$ ls
folder.tar.Z
$ tar -Zxf folder.tar.Z
$ ls
folder
</screen>
      </para><para>
        Benzer şekile, bir dosyayı aynı anda hem tar ile arşivlemek, hem de
        sıkıştırmak istersek c ve f parametreleri dışında compress ile Z,
        gzip ile z parametrelerini girmek yeterlidir. Aşağıda sırayla
        gn-gopher dizisinin önce tar ve gzip ile, ardından tar ve compress
        ile arşivlenmesi görülüyor.
      </para><para>
<screen>
$ ls
gn-gopher/
$ tar -zcf gopher.tgz gn-gopher/
$ tar -Zcf gopher.tar.Z gn-gopher/
</screen>
      </para>
    </sect2>
  </sect1>
  <sect1 id="archive-tlkg-lis-4.5">
    <title>Dizin Tarama</title>
    <para>
      Linux işletim sistemini ilk kurduğunuz anda, yüzlerce dizin altında
      binlerce dosyanız olacaktır. <literal>find</literal> komutu, bu
      dosyaların arasında tarama yapabilmek için geliştirilmiştir. Bu
      komutla sadece dosya isimlerine değil, dosyanın sahibi, erişim hakları,
      son erişim tarihi gibi verilere de ulaşmak mümkündür.
      <literal>find</literal> komutunun en sık kullanış şekli şudur:
    </para><para>
<screen>
find &lt;dizin-ismi&gt; -name &lt;ne-aratiliyor&gt;
</screen>
    </para><para>
      dizin-ismi yerine taranacak olan dosyanın bulunduğu dizin ismi yazılır.
      <literal>-name</literal> parametresinden sonra ise aranan dosyanın ismini girin. Burada
      "*" ve "?" gibi joker karakterlerini de kullanabilirsiniz. (Bu gibi
      özel karakterler hakkında daha geniş bilgi
      <xref linkend="archive-tlkg-lis-6"/> konusu altında bulunabilir)
    </para><para>
      Aşağıda, find komutunun kullanımına ilişkin birkaç örnek yeralıyor.
    </para><para>
<screen>
$ find . -name &quot;*.html&quot;
(bulundugunuz dizinden itibaren sonu .html ile biten dosyalari arar)
$ find /home/halil -name &quot;screen&quot;
(/home/halil dizininden itibaren screen isimli dosyalari arar)
</screen>
    </para><para>
      Bu komut, <literal>-type d</literal> parametresi yardımıyla sadece dizin
      isimleri arasında arama yapar.
    </para><para>
<screen>
$ find /usr/ -name &quot;linux&quot; -type d
</screen>
    </para><para>
      <literal>find</literal> komutuna bir alternatif olan
      <literal>locate</literal> komutu ile dosyalar çok kısa bir
      sürede taranabiliyor. <literal>update</literal> komutu, her
      sabah belirli bir saatte sistemdeki tüm dosya ve dizin isimlerini bir veri
      tabanına yükler. Daha sonra bu dosyada yeralan belirli bir dosya veya dizin
      ismini <literal>locate</literal> ile arayabilirsiniz:
    </para><para>
<screen>
# locate pico
/usr/bin/pico
/usr/man/man1/pico.1.gz
</screen>
    </para><para>
      Yukarıdaki komut ile içinde pico kelimesi geçen dosyaları bulduk.
    </para>
  </sect1>
  <sect1 id="archive-tlkg-lis-4.6">
    <title>mtools MSDOS Arabirimi</title>
    <para>
      Linux altından, MS-DOS biçemli disketlere ulaşmayı kolaylaştıran paketin
      ismi <literal>mtools</literal> olarak biliniyor. Bu isim, paketin tüm
      komutlarının ilk harfinin "m" olmasından kaynaklanmış. Paketle birlikte
      gelen çeşitli yardımcı programlar sayesinde MS-DOS biçemli diskette
      yeralan dosyalar listelenebilir, silinebilir, disket biçemlenebilir,
      hatta disketin kimliği değiştirilebilir.
    </para><para>
      Son çıkan <literal>mtools</literal> paketi, 2MB biçemli disketleri
      de tanıyabiliyor. Aşağıda, <literal>mtools</literal> paketinden çıkan
      bazı komutlar ve örnek kullanımları gösteriliyor.
    </para><para>
      <command>mdir</command> : disketin içeriğini görüntüler.
    </para><para>
<screen>
linux:~# mdir a:
 Volume in drive A is SYSTEM_BT
 Directory for A:/

IO       SYS       40566    9-30-93   6:20a
MSDOS    SYS       38138    9-30-93   6:20a
AUTOEXEC BAT          91    3-29-95  10:23a
NDD              &lt;DIR&gt;      3-29-95  10:26a
CHKLIST  MS           81   11-07-96   7:00p
VGA_45           &lt;DIR&gt;      3-29-95  10:28a
YARDIM           &lt;DIR&gt;      3-29-95  10:17a
UTIL             &lt;DIR&gt;      3-29-95  10:17a
VIRUS            &lt;DIR&gt;      3-29-95  10:17a
       9 File(s)     291328 bytes free
linux:~#
</screen>
    </para><para>
      <command>mcopy</command>: Bir dosyayı Linux'tan diskete, disketten Linux'a
      aktarır.
    </para><para>
<screen>
linux:~# mcopy a:/autoexec.bat .
Copying AUTOEXEC.BAT
</screen>
    </para><para>
      <command>mdel</command>: DOS dosyasını siler.
    </para><para>
      <command>mformat</command>: Disketi biçemler.
    </para><para>
      <command>mmd</command>: Disket üzerinde dizin oluşturur.
    </para><para>
      MSDOS <literal>mtools</literal> arabirimi aynı zamanda VFAT tipi uzun dosya
      isimlerini de ekranda gösterebilir. Eğer dosya ismi, tek bir DOS ismi içine
      sığmıyorsa ve 8+3 kuralını bozuyorsa uygun bir kısa isim yaratılır.
    </para><para>
      Bunun yanında <literal>mtools</literal>'un 2 Mb'lık disketleri okuyabilme
      özelliği de vardır.
      mtools paketinin yapılandırma dosyası
      <literal>/etc/mtools.conf</literal>'tur. Bu
      dosyanın kullanımı için mtools(1) man dosyasından yararlanabilirsiniz.
    </para>
  </sect1>
</chapter>

<chapter id="archive-tlkg-lis-5">
  <title>Linux Sistem Yönetimi</title>
  <sect1 id="archive-tlkg-lis-5g">
    <title>Giriş</title>
    <para>
      Bir işletim sistemi, marka ve modeli ne olursa olsun bakım isteyen bir
      araçtır. Yapılacak küçük bir hata veya hatayı gösteren bir işaretin
      gözardı edilmesi, zaten değerli olan zamanın boşa gitmesine neden olur.
      Linux da açık bir işletim sistemi olduğundan, sorumluluk sahibi
      sistem yöneticisi tarafından açık tutulduğu süre içinde verimli ve
      düzgün çalışması için gerekli özen gösterilmelidir. İnternet üzerinde
      üzerinde 500 kullanıcı olan , veya
      <ulink url="ftp://ftp.linux.org">ftp.linux.org</ulink> adresi gibi
      her hafta onbinlerce ziyaretçisi olup ağır sorumluluklar yüklenen
      Linux makinaları vardır. Bunların bir saat boyunca bile kapalı kalması, o
      anda bağlanmayı bekleyen pek çok kullanıcıyı mağdur durumda bırakacaktır.
    </para><para>
      Performansı etkileyen unsurların başında, önlemek pek de elinizde olmasa
      da elektrik kesintileri ve makinanın kapalı olduğu zamana denk gelen
      çekirdek değişimleridir. Bu tür donanımsal etkileri bir tarafa bırakırsak
      sistem yöneticisinin uyması gereken ve İnternet etikleri dediğimiz
      davranış kuralları vardır. Bu kurallara öncelikle sistem sorumlusu uymalı
      ve kullanıcıları da uymaya zorlamalıdır. Açık işletim sistemlerinin
      en büyük sorunlarından biri olan güvenlik konusuna sistem yöneticisi
      belirli günler zamanının bir bölümünü ayırmalıdır. Kullanıcılardan
      gelebilecek her türlü saldırı, sisteme onarılması çok zor olabilecek zararlar
      verebilir. Bunun için düzenli olarak dosyaları kontrol edin ve şüpheli
      durumlarda araştırma yapmaktan çekinmeyin. Bu konuda daha fazla bilgiyi
      <link linkend="security-howto">Linux Güvenlik NASIL</link> belgesinde
      bulabilirsiniz.
    </para><para>
      Yukarıdaki tabloya bakarak işinizin zor olduğu kanısına kapılmayın, zira
      tüm bu denetleme mekanizmasını basitleştirebilirsiniz. Yapılacak tüm
      rutin işleri bir programa yazıp günün veya haftanın belirli saatlerinde
      bu programı çalıştırın ve olabilecek tüm hata mesajlarını bir dosyaya
      yazın. Bu dosyayı boş bir vakitte inceleyerek programın ne kadar düzgün
      çalıştığını gözlemleyebilirsiniz. Bunun yanında sistem yönetimini zevkli
      kılacak uygulama programları da vardır. Bu uygulama yazılımlarından
      bazıları o kadar gelişmiştir ki yapamadıkları tek iş yemek pişirmektir.
    </para><para>
      Yabancı kaynaklı yayınlardan <emphasis>Essential System Management (Frisch)</emphasis> ve
      <emphasis>Essential System Administration (O'Reilly)</emphasis> bu yönde tavsiye edilebilecek
      kitaplar. Piyasada bulunan Türkçe kitapların hiçbirisinde sistem
      yönetimine ciddi olarak değinilmediği için Türkçe yayın bulmak gayet zor.
    </para>
  </sect1>
  <sect1 id="archive-tlkg-lis-5.1">
    <title>Yetkili Kullanıcı ve Diğer Kullanıcılarla İlişkiler</title>
    <para>
      Sistemin en büyük sorumlusu <emphasis>root</emphasis> parolasını bilen
      kullanıcıdır. Yukarıda da
      belirtildiği gibi bu parolanın sorumluluğu büyüktür. Sistem yöneticisi,
      makinadaki kullanıcıların isteklerini ve şikayetlerini yönelttikleri tek
      merci durumundadır. Burada karşılıklı güven sözkonusudur, bunu da sistem
      görevlisi herkese hissettirmelidir. root kullanıcısının, başkalarından
      gözünüz gibi sakladığınız e-posta ve dosyaları sizden habersiz okuduğunu
      öğrenseydiniz tepkiniz ne olurdu?
    </para><para>
      root kullanıcısının sahibinin haberi olmaksızın sistem kullanıcılarına
      ait dosyaların yerini ve izinlerini değiştirmesi de uygun değildir. Zorda
      kalsanız bile, başkalarına ait hiçbir dosyayı silmeyin veya içeriğini
      değiştirmeyin. Belki de sıkışık bir durumdan kurtulmanın başka bir yolu
      vardır?
    </para><para>
      Temel olarak zaman zaman kullanıcıları bilgilendirmek hoş bir
      davranış olarak karşılanır ve onların Linux'a olan ilgilerini
      perçinleyebilir. Örneğin <literal>/etc/motd</literal> ve <literal>/etc/issue</literal>
      dosyalarına periyodik olarak çekirdek değişimlerini ve eklenen uygulama
      programlarını haber
      veren birkaç satır iliştirebilirsiniz. Sistemde açılan her kullanıcı
      hesabına
      <ulink url="http://www.linux.org.tr/linuxtrfaq.html">Linux Çokça Sorulan
      Sorular (Linux ÇSS)</ulink>, çeşitli UNIX belgeleri
      ve İnternet hakkında bilgilendirici dökümanlarının yeraldığı bir dizi
      e-posta da yollanabilir. Bu konuda yaratıcılığınızı konuşturun.
    </para>
  </sect1>
  <sect1 id="archive-tlkg-lis-5.2">
    <title>Sistem Kuralları</title>
    <para>
      Kullanıcı hesabı açmadan önce birkaç basit kuralı tanımlayıp
      kullanıcılardan bunlara uymalarını istemelisiniz. En basitinden birkaç
      kural, bir hesabın birden fazla kişi ile kullanılmaması, sistemin
      güvenliğini zedeleyecek <literal>crack, cops, satan</literal> gibi programların diğer
      kullanıcıların zararına çalıştırılmaması ve sistem kaynaklarının
      sorumsuzca tüketilmemesi olarak sayılabilir.
    </para><para>
      Siz, en iyisi yukarıda yeralan kuralları birkaç madde halinde yazın
      ve sistemdeki herkesin bu maddelere uyacağını taahhüt eden imzasını
      alın. Tatsız durumların çıkmaması için de önlem almayı ihmal etmeyin.
    </para>
  </sect1>
  <sect1 id="archive-tlkg-lis-5.3">
    <title>Kullanıcı İşlemleri</title>
    <para>
      Aşağıda yeralan konularda, kullanıcı hesaplarının açılması ve kapatılması
      anlatılıyor.
    </para>
    <sect2>
      <title>Kullanıcı Hesabı Açmak (adduser)</title>
      <para>
        Kullanıcı hesabı açmak iki yoldan yapılabilir. Birincisi, <literal>adduser</literal>
        komutu yardımıyla, diğeri de bu komutun yaptığı işlemleri sırasıyla
        elden yapmak. root olarak sisteme girin ve komutu çalıştırın :
      </para><para>
<screen>
# adduser

Login name for new user (8 characters or less) []: mehmet

User id for mehmet [ defaults to next available]:

Initial group for mehmet [users]:

Additional groups for mehmet []:

mehmet's home directory [/home/mehmet]:

mehmet's shell [/bin/bash]:

mehmet's account expiry date (MM/DD/YY) []:

OK, I'm about to make a new account. Here's what you entered so far:

New login name: mehmet
New UID: [İleri available]
Initial group: users
Additional groups: [none]
Home directory: /home/mehmet
Shell: /bin/bash
Expiry date: [no expiration]

This is it... if you want to bail out, hit Control-C.  Otherwise, press
ENTER to go ahead and make the account.


Making new account...

Changing the user information for mehmet
Enter the new value, or press return for the default

        Full Name []: linux kullanicisi
        Room Number []:
        Work Phone []:
        Home Phone []:
        Other []:

Changing password for mehmet
Enter the new password (minimum of 6, maximum of 8 characters)
Please use a combination of upper and lower case letters and numbers.
New password:
Bad password: too simple.
Warning: weak password (enter it again to use it anyway).
New password:
Re-enter new password:
Password changed.
Done...
</screen>
      </para><para>
        Kullanıcının isminin 3 karakterden az, 8 karakterden fazla olmamasına
        özen gösterin. Sistem sizden kullanıcının gerçek ismini, ev dizinini,
        (genellikle /home içinde olur), grubunu isteyecektir. <literal>adduser</literal> komutu, eğer özel
        olarak değiştirmek istemezseniz her kullanıcının grup numarasını GID =
        Group ID) 100 olarak tanımlayacaktır. Bu gruba karşılık gelen isim (Group
        Name) <emphasis>users</emphasis> dır. Kullanıcı kimliği (UID = User ID) ise genellikle 500'den sonra
        gelen ve kullanılmayan ilk sayı olarak atanır.
        Eğer UID olarak 0 girerseniz sistemde sizinle beraber bir süper-kullanıcı
        daha yaratmış olursunuz :)
      </para><para>
        Sisteme girişte çalıştırılacak olan kabuk için seçimi ister kullanıcıya
        bırakın, isterseniz öntanımlı olarak bash verin. Bash'in sistemdeki
        tam patikasını (<literal>/bin/bash</literal>) yazmalısınız. Bu alana sadece kabuk ismi
        girmek şart değildir.
      </para><para>
        Yukarıda sistem bizi güçlü bir parola seçmediğimiz için uyardı.
        Parola olarak, herkesin kolayca tahmin edemeyeceği zorlukta, fakat
        kullanıcının bir yere yazmasını önleyici kolaylıkta bir kelime
        bulun. Kullanıcı, hesabının açılmasından hemen sonra sisteme girecekse
        ve parolasını değiştirecekse kısa ve kolay bir parola yeterli olacaktır.
      </para><para>
        Her şeyin doğru olduğuna eminseniz, sorulan soruya "y" ile, değilseniz
        "n" ile cevap verin. Hemen ardından <literal>/etc/skel</literal> dizini altında yeralan
        tüm dosyalar bu kullanıcının dizinine kopyalanacaktır. Buraya, her
        kullanıcının ev dizinine önceden yüklenmesini istediğiniz sistem
        dosyalarını yerleştirebilirsiniz. Bu andan itibaren yeni kullanıcı
        sisteme girebilir.
      </para><para>
        Sisteme kullanıcı ekleme işlemini el yordamıyla yapmak isterseniz,
        <literal>/etc/passwd</literal> ve <literal>/etc/shadow</literal>
        dosyalarına birer satır eklemelisiniz. <literal>/etc/passwd</literal>'de
        aralarında birer ':' karakteri olmak kaydıyla sırayla hesap ismi, "x",
        grup kimliği, kullanıcı kimliği, kullanıcı isim ve soyadı, ev dizini ve
        kabuk programı yeralır. <literal>/etc/passwd</literal> içine bu satırı
        ekleyin:
      </para><para>
<screen>
ozgur:x:100:502:Misafir Sanatci:/home/ozgur:/bin/bash
</screen>
      </para><para>
        <literal>/etc/shadow</literal> içine ise aşağıdaki satırı yerleştirin,
        tabi diğer satırlara dokunmadan.
      </para><para>
<screen>
ozgur::9990:0:99999:7::::
</screen>
      </para><para>
        Bu satırda yeralan ikinci girdi mirkelam kullanıcısının parolasını
        belirtiyor. <literal>/etc/shadow</literal> dosyasına yazılacak olan
        parolayı önce boş bırakıp, ardından <literal>passwd ozgur</literal>
        komutuyla bir parola atayın.
      </para><para>
        <literal>/etc/shadow</literal> dosyasında kullanılabilecek parametreler
        için shadow(5) man dosyasına göz gezdirin.
      </para><para>
        Ardından <literal>/home/ozgur</literal> dizinini oluşturun. Dizinin grubunu da ayarlayın. Çok gerekli olmasa da gelen e-postalar için <literal>/var/spool/mail</literal> dizininde bir dosya tanımlayın ve <literal>/etc/skel</literal> içinde yeralan dosyaları kullanıcının
        dizinine kopyalayın.
      </para><para>
<screen>
# mkdir /home/ozgur
# chown -R ozgur.users /home/ozgur
# touch /var/spool/mail/ozgur
# chown ozgur.mail /var/spool/mail/ozgur
</screen>
      </para><para>
        Yukarıda yazılan elle kullanıcı girme işlemi, shadow kullanan Linux
        makinaları için geçerlidir. Shadow için <emphasis>Güvenlik</emphasis>
        bölümüne göz atın.
      </para>
    </sect2><sect2>
      <title>Kullanıcı Grubu</title>
      <para>
        Eğer Linux makinanız birkaç yoğun görev üstlenmişse (örneğin www veya
        ftp sunucusu olarak kullanılıyorsa) her bir işlem için birden fazla
        grup tanımlanabilir. <emphasis>users</emphasis> grubuna bağlı kalmadan <emphasis>wwwadm</emphasis> veya
        <emphasis>ftpadm</emphasis> gibi grup isimleri belirtebilir, bu grupları da bir veya
        birkaç kullanıcıya ait olacak şekilde değiştirebilirsiniz.
      </para><para>
        <emphasis>users</emphasis> grubunun dışında birden fazla grup tanımlanması, sistemin
        denetlenmesini bir miktar güçleştirse de sistem güvenliğini artırır. Bazı
        kullanıcıların birden fazla grubunun olmasıyla bu kullanıcılar rahatlıkla
        sistemde <emphasis>root</emphasis> kullanıcısının üstlenmesi gereken işleri yapabilirler.
      </para><para>
        Grup kimliğinin değiştirilmesi veya yeni grubun eklenmesi için
        <literal>/etc/group</literal> dosyası kullanılır. Bu dosyaya grubun ismi,
        numarası, grup parolası ve gruba ait kullanıcılar yazılır. Her
        kullanıcının en az bir grubu vardır.
      </para><para>
        <literal>/etc/group</literal> dosyasının iki satırında yeralan parametreler,
      </para><para>
<screen>
root::0:root
sys::3:root,bin,sys,adm
</screen>
      </para><para>
        gibidir. Sırayla ":" karakteri ile ayrılmış her kolon,
      </para><para>
        <orderedlist>
          <listitem>Grup ismi </listitem>
          <listitem>Grup parolası </listitem>
          <listitem>Grup numarası </listitem>
          <listitem>Gruba ait kullanıcılar</listitem>
        </orderedlist>
      </para><para>
        şeklinde özetlenebilir. İlk sütun grup ismini belirtir. Grup ismi,
        <literal>ls -l</literal> komutunu işletince kullanıcı isminin hemen sağında görülen
        kelimedir. Grup parolası, gruba ait olmayan kullanıcıların dosyalarına
        erişim sağlamak için kullanılır.
      </para><para>
        Grup parolası nadiren kullanılır. Grup numarası, kullanıcının ait olduğu
        grubun karşılığıdır. Son sütunda ise gruba ait kullanıcılar, her biri
        birer virgülle ayrılmış olarak yazılır. Kullanıcı sisteme girdiği zaman
        otomatik olarak <literal>/etc/passwd</literal> dosyasında yeralan grup ismi aktif olur, bu
        yüzden her kullanıcının ismi <literal>/etc/groups</literal> dosyasına yazılmaz. Sistem ilk
        kurulduğu anda birkaç grup halihazırda zaten vardır. Örneğin root grubunun
        grup numarası 0'dır ve pekçok sistem dosyasının sahibidir, bin grubunun
        numarası is 2 olup <literal>/usr/bin</literal> ve <literal>/bin</literal>
        dizinlerindeki çoğu dosyanın grubudur.
      </para><para>
        Hangi grubun (veya tanımlanmışsa grupların) içinde olduğunuzu öğrenmek
        için <literal>groups</literal> komutunu kullanabilirsiniz.
      </para><para>
<screen>
$ groups gorkem
users
</screen>
      </para>
    </sect2><sect2>
      <title>Kullanıcının  Hesabının Silinmesi</title>
      <para>
        Bir kullanıcıya ait hesabı silmek için <literal>/etc/passwd</literal> dosyasında bu
        kullanıcıya ait olan satırdaki parola kolonunun başına <emphasis>*</emphasis> işareti
        koyun. Bir şifrelenmiş bir parolanın içinde <emphasis>*</emphasis> karakteri olamayacağından
        bu kullanıcı bir daha sisteme giremez.
      </para><para>
        Hesabı tamamen silmek için, kullanıcının ev dizinini ve e-postalarını
        yedekledikten sonra sistemde kullanıcıya ait olan dosyaları
        (<literal>/tmp</literal> altında) ve ev dizinini silin.
      </para><para>
        <literal>/etc/passwd</literal> ve <literal>/etc/group</literal>
        dosyasından kullanıcının isminin geçtiği satırları kaldırın.
      </para><para>
        Sistemde kullanıcıya ait olabilecek tüm dosyaları da silmeniz
        gerekebilir. Bunun için <literal>find</literal> kullanabilirsiniz.
      </para><para>
<screen>
$ find / -user gorkem -ls -exec rm {} \;
</screen>
      </para><para>
        Bu komutu <literal>/etc/passwd</literal> dosyasından kullanıcı ismine
        ait olan satırı kaldırmadan önce yapmalısınız.
      </para>
    </sect2>
  </sect1>
  <sect1 id="archive-tlkg-lis-5.4">
    <title>Sistemin Yedeklenmesi</title>
    <para>
      Makinanızın belirli aralıklarla yedeklenmesi, sistem güvenliğinin
      bir parçası sayılabilir. Donanımdan meydana gelen bir hata
      sonucu veya yanlışlıkla girilen bir komut, sistemi açılamaz hale
      getirebilir. Ancak yedekleme ile bu tür kullanıcı hatalarının önüne
      geçebilirsiniz. Yedekleme genellikle tüm sistem üzerinde yapılmaz. Sadece
      önemli sistem bilgilerini içeren dizinler yedekleme aşamasına girmelidir.
    </para><para>
      Yedekleme üniteleri olarak teyp, disket veya başka diskler
      kullanılabilir. Teypler, büyük miktarda yedekleme işlemleri için ön
      plana çıksa da birkaç dosyadan oluşan paketlerin korunması söz konusu olacaksa
      disketler daha pratiktir. İnternet üzerinde ise bağımsız bir makina,
      kendi rutin görevi dışında yerel ağda bulunan makinaların yedeklerini
      belirli gün ve saatlerde almak üzere programlanabilir.
    </para><para>
      Sistemde fazla miktarda kullanıcı varsa yedekleme işlemi ciddi bir düzene
      oturtulmalıdır. Sistemdeki hayati dosyalar örneğin her hafta, üzerinde
      kullanıcıların bulunmadığı akşam saatlerinde yedeklemeye sokulabilir.
    </para><para>
      Yedekleme için birkaç yol önerilebilir. Kullanışlı olması için
      yedeklemeyi yapan program, yedeklenen dosyalar arasındaki belirli bir
      dosyayı kolayca açabilmelidir. Bunun yanında, yedek bilginin de bozulması
      ihtimali vardır. Yedeğin içindeki tek baytın bozulması, bazı durumlarda
      tüm yedeğin çöp yığını haline gelmesine yol açabilir. Doğru yedekleme
      programının kullanılması bu anda önem kazanır.
    </para><para>
      Yedeklenecek olan dizinlerden en önemlileri, sistem yaplandırma
      dosyalarının yeraldığı <literal>/etc</literal>, kullanıcı dizinlerinin yeraldığı /home,
      bazı X Pencere dosyalarının bulunduğu /usr/X11/lib/X11 dizini altındaki
      bazı dosya ve dizinler,
      <literal>/usr</literal> ve <literal>/usr/local</literal> dizinde yeralan bazı dizin
      ve dosyalar ile <literal>/root</literal> dizinidir. Şart olmasa da yedekleme için yeriniz
      bolsa <literal>/tmp</literal> dizinini de koyabilirsiniz.
    </para><para>
      Elektronik postaları ( <literal>/var/spool/mail</literal>) da unutmamak gerekir. Yoksa,
      çok meşhur olan "e-meyılım cyber-space'de kayboldu" cümlesini sıkça
      duymaya başlarsınız.
    </para><para>
      Aşağıdaki komut, <literal>/usr</literal> ve <literal>/home</literal>
      dizinlerini diskete yedekler.
    </para><para>
<screen>
$ tar cvMf /dev/fd0 /usr /home
</screen>
    </para><para>
      <literal>tar</literal> komutununa verilen M parametresi yardımıyla bir disket dolduğu
      zaman başka bir diskete devam etmenizi sağlar. Dizinleri sıkıştırarak
      atmak için z seçeneğini vermek yeterli olur. Sıkıştırarak yedekleme
      disket ya da teyp'te yer kazandıracaktır, ancak hata olduğunda verilerin
      kurtarılması daha zor olacaktır. Açmak için
    </para><para>
<screen>
$ tar xf /dev/fd0
</screen>
    </para><para>
      komutu yeterlidir. Sıkıştırılarak diskete atılan yedekler için açarken
      de "z" kullanın. Disketleri sıra ile numaralandırmayı ihmal etmeyin,
      yoksa bir disketten fazla yer kaplayan arşivleri açamazdınız.
    </para><para>
      Linux'ta gerek SCSI, gerek floppy teyp desteği vardır. Özellikle çok
      veri yedekleyecekseniz teypler kaçınılmaz olur. Teyplere yedek alırken
      de yukarıdaki floppy orneklerindeki gibi <literal>tar</literal> kullanabilirsiniz.
      <literal>tar</literal>'ın yanı sıra sıkça kullanılan yedekleme komutları arasında
      <literal>dump ve restore</literal>, <literal>cpio</literal> ve <literal>dd</literal> gösterilebilir. Linux'ta
      ilk SCSI teyp sürücüye <literal>/dev/st0</literal>, ikinciye <literal>/dev/st1</literal> ...
      kullanarak, PC'lerde sıkça kullanılan ``floppy teyp''lere de
      <literal>/dev/ftape</literal> üzerinden erişebilirsiniz. Piyasada bulacağınız
      ortalama floppy teyplerin kapasiteleri 120M, 4mm SCSI teyplerin 4G, 8mm
      SCSI teyplerin ise 7G kadar olacaktır. Teybin kapasitesi kullandığınız
      sürücünün yeteneğine ve teybinizin uzunluğuna göre değişir. Örnek olarak,
      bütün sistemin tar kullanarak ilk SCSI teybe yedeklemek için,
    </para><para>
<screen>
# tar cvf /dev/st0 /
</screen>
    </para><para>
      Bir TCP/IP ağınız varsa ve birden fazla Linux ya da UNIX makinası
      kullanıyorsanız, tek bir teyp sürücü ile bütün makinalarınızın, hatta
      Windows makinalarınızın bile (Linux'un yardımıyla) yedeğini
      alabilirsiniz. Bu iş için <emphasis>amanda</emphasis> gibi daha özelleşmiş ve yedekleme
      işlemini otomatikleştiren bir program kullanabileceğiniz gibi, <literal>GNU
      tar</literal>'dan da yararlanabilirsiniz. Örneğin <literal>tar</literal> ile, <emphasis>cclub.metu.edu.tr</emphasis>
      makinasından, <emphasis>linux.org.tr</emphasis> makinasındaki floppy teybe yedek almak için,
    </para><para>
<screen>
cclub:~# tar cvf linux.org.tr:/dev/ftape /home
</screen>
    </para><para>
      yukarıdaki komutun çalışması için linux.org.tr makinasının
      <literal>root</literal>'unun <literal>.rhosts</literal> dosyasında
      cclub makinasının <literal>root</literal>'una
      izin verilmiş olması gerekir. Bu işlem güvenlik için sakıncalı
      olduğundan, bu iş için özel bir kullanıcı açmak gibi bir yönteme
      başvurulabilir. Örneğin linux.org.tr'da <literal>yedek</literal>
      adlı bir kullanıcı
      açtığımızı düşünelim. Bu durumda yukarıdaki komutu,
    </para><para>
<screen>
cclub:~# tar cvf yedek@linux.org.tr:/dev/ftape /home
</screen>
    </para><para>
      şeklinde yazabiliriz.
    </para>
  </sect1>
  <sect1 id="archive-tlkg-lis-5.5">
    <title>Sistemin Güncellenmesi</title>
    <para>
      Tekrar Linux yüklenecek olan makina üzerinde halihazırda Linux
      bulunmasının yararları olduğu gibi bazı sakıncaları vardır. İlk olarak
      yararlarına değinmek gerekirse, yapılacak aslında sadece işletim
      sisteminin bulunduğu bölümü değiştirmektir. Takas alanının ayrılması,
      kullanıcı alanının ayrılması gibi işlemler bu durumda önceden yapılmış
      oluyorlar. Ancak yeni işletim sisteminin yüklenmesinin bazı zararları da
      var.
    </para><para>
      Herşeyden önce çalıştığı bilinen bir işletim sistemi yenisi ile
      değiştiriliyor. Gerçekten bunu gerektirecek bir sebep olmadıkça bu tür
      güncellemelerden kaçınılması veya en aza indirilmesi gerekir. Yeni bir
      sistem, yeni bilinmeyenler ve az da olsa bile çalışmama riski
      getirecektir.
    </para><para>
      Eğer sistem üzerinde belirli hizmetler veriliyorsa o hizmetlere ilişkin
      verilerin bu güncelleme esnasında yok olmamasına dikkat edilmeli. Mesela
      makina bir web sunucu olarak kullanılıyorsa web dosyalarının bir şekilde
      yeni sisteme aktarılması gerekecektir.
    </para><para>
      Benzer bir şekilde makinaya ait tanımların (<literal>/etc</literal>) ve standart dağıtım
      dışında yüklenmiş paketlerin önceden yedeklenmesi gerekir. Yoksa herşeye
      yeniden başlamak gerekebilir.
    </para><para>
      Güncelleme için iki yöntem akla gelebilir, doğrudan yeni sistemi eskisinin
      üzerine bindirmek veya eskisini silerek yeniden yüklemek. Slackware sürümü
      için en sağlıklısı eski sistemi silmektir. Çünkü değişik dağıtımlarda
      dosya dağılımı farklılıklar göstere bilmektedir. Bunun sonucunda bazı
      dosyalar birden fazla yerde gözükebilmektedirler. Bir diğer sakınca ise
      setup yazılımının bazen bu durumda şaşırabilmesi ve hata vermesi. Bazı
      ticari Linux sürümleri (<emphasis>Red-Hat, Debian, Caldera gibi</emphasis>) eski sürümü silmeye
      gerek bırakmadan sistemi güncelleme özelliğine sahipler.
    </para><para>
      Güncellemeniz gerekebilecek dizinler, <literal>/var/spool/mail</literal>, kullanıcı
      dizinleri (root dahil), <literal>/usr</literal> altında gerekli dizinler,<literal>/var/adm/</literal> ve
      <literal>/etc</literal> olarak sayılabilir.  Bazen <literal>/etc</literal> içinde yer alan
      dosyaların yeri veya şekli değişmiş olabilir.  Onun için en güvenlisi
      teker teker dosyaları inceleyip kopyalamaktır.  Belirli dosyaları yeni
      sistemi kurduktan sonra hemen kopyalayabilirsiniz:
    </para><para>
<screen>
/etc/group
/etc/printcap
/etc/hosts ...
</screen>
    </para><para>
      Daha önce shadow kullanmayan bir sistemden shadow sistemine geçiyorsanız,
      <literal>/etc/passwd</literal> ve <literal>/etc/shadow</literal>
      dosyalarında gerekli değişiklikleri yapmadan yeni yerine kopyalamayın.
    </para><para>
      Ayrıca ne olur ne olmaz diye çalıştığını bildiğiniz bir çekirdeği de
      yedeğe almayı ihmal etmeyin.
    </para>
  </sect1>
  <sect1 id="archive-tlkg-lis-5.6">
    <title>Çekirdeğin Derlenmesi</title>
    <para>
      Bu bölümde, çekirdeğin yapılandırması ve derlenmesi için gerekli
      bilgiler vardır. Çekirdek derleme uzun ve zahmetli bir işlemdir. Derleme
      aşamasını en kısa zamanda ve en uygun yoldan gerçekleştirmek gerekir.
      Derleme işlemi, kullanıcının önüne kafasını karıştıracak kadar çok seçenek
      sunar.
    </para><para>
      Nedir bu çekirdek? Genel anlamda çekirdek, yazılımın ve donanımın arasında
      bekleyerek iletişimi sağlayan bir arabirimdir. Çalışan tüm programların
      ve süreçlerin hafıza ile olan ilişkilerini düzenler. İşlemcinin gücünün
      tüm bu programlar arasında adil bir şekilde dağıtımını üzerine alır. Bu
      işlemleri kullanıcının haberi olmadan her an durmaksızın yapar.
    </para><para>
      Çekirdek kaynak dosyaları diskte hatırı sayılır bir alan tutar. Örneğin sürüm 2.0.20 yaklaşık 6Mb disk alanı kaplar. Açıldığı zaman ise toplam kapladığı
      alan 24 Mb olur. Derleme aşamasından sonra bu rakam 30 Mb'yi geçer. Her
      eklenen  aygıt sürücü desteği bir miktar daha yer alır.
    </para><para>
      Kullandığınız sisteme göre çekirdeğin derlenme süresi değişkenlik
      gösterir. 12 Mb 486DX4/100 makinasında, 5 dosya sistemi desteği,
      ağ desteği ve ses kartı sürücüsü ile yaklaşık 30 dakika sürer. Aynı
      yapılandırmayı içeren çekirdeğin derlenmesi ise daha güçsüz bir makina
      olan 8Mb 386DX/40 altında 1.5 saati bulur. Derlerken gidip çayınızı için,
      biraz televizyon seyredin. Makinaniz 386 ise bir banyo alıp dışarı çıkın,
      alışveriş yapın. Çok ümitsiz bir durumdaysanız, yapılacak en iyi şey en
      yakın bilgisayar satıcısına uğrayarak yeni fiyatları sormak :-)
    </para><para>
      Çekirdek kaynak kodu ,
      <ulink url="ftp://ftp.metu.edu.tr/pub/linux/tsx/sources/system">ODTÜ ftp arşivindeki</ulink> adresinden veya tsx-11.mit.edu adresinin
      yansısını tutan herhangi bir adresten alınabilir. Bu dizin altındaki
      Linux sürümlerinin bir tanesini (v1.2, v2.0, v2.1 gibi) seçtikten
      sonra altındaki dosyayı alabilirsiniz. Dosyanın ismi linux-x.y.z.tar.gz
      yapısındadır.
    </para><para>
      Aşağıdaki örnekte ODTÜ ftp arşivinden 2.0.20 sürümünün alınışı gösterilmektedir:
    </para><para>
<screen>
$ ftp ftp.metu.edu.tr
Connected to ephesus.cc.metu.edu.tr.
220-
220-Welcome to METU Ftp Site !
220-
220-All logins and transfers are logged with your hostname.
220-If you do not agree with this policy, please cancel now.
220-
220 ephesus FTP server (Version wu-2.4(5) Wed Jan 10 18:06:56 EET 1996) ready.
Name (ftp.metu.edu.tr:gorkem): ftp
331 Guest login ok, send your complete e-mail address as password.
Password:
230-##########################################################################
230-##    Welcome to the Middle East Technical University Ftp Archive       ##
230-##########################################################################
230-
230-
230-Hello ftp@compclup.ceng.metu.edu.tr !
230-You are the 19. anonymous user.
230-Maximum number of users allowed is 100.
230-Local Time is Tue Nov  5 12:19:41 1996.
230-
230-Mirrored sites are placed under the directory /pub
230-This archive is maintained by ftpload@ftp.metu.edu.tr
230-You can reach this archive via FSP at port 21.
230-
230-You can reach public directories via &quot;cd dirname&quot;
230-command independent of your current location;
230-e.g. &quot;cd linux&quot; instead of &quot;cd /pub/linux&quot;
230-
230 Guest login ok, access restrictions apply.
ftp&gt; cd /pub/linux/tsx/sources/system/
250-Please read the file README
250-  it was last modified on Mon Sep 16 11:36:00 1996 - 50 days ago
250 CWD command successful.
ftp&gt; dir
200 PORT command successful.
150 Opening ASCII mode data connection for /bin/ls.
total 66
-rw-r--r--  1 ftpload  ftp-adm     36981 Sep 16 12:36 CREDITS
drwxr-xr-x  3 ftpload  ftp-adm       512 Oct 13 15:59 Historic
-rw-r--r--  1 ftpload  ftp-adm     12056 Sep 16 12:36 README
drwxr-xr-x  2 ftpload  ftp-adm       512 Oct 14 11:47 SillySounds
drwxr-xr-x  2 ftpload  ftp-adm       512 Oct 13 18:17 testing
drwxr-xr-x  2 ftpload  ftp-adm       512 Oct 14 11:47 v1.0
drwxr-xr-x  2 ftpload  ftp-adm      2048 Oct 31 21:55 v1.1
drwxr-xr-x  2 ftpload  ftp-adm      1024 Jun 25 11:34 v1.2
drwxr-xr-x  2 ftpload  ftp-adm      6656 Sep 27 04:24 v1.3
drwxr-xr-x  2 ftpload  ftp-adm      1536 Nov  2 00:05 v2.0
drwxr-xr-x  2 ftpload  ftp-adm       512 Nov  2 21:33 v2.1
226 Transfer complete.
ftp&gt; cd v2.0
250 CWD command successful.
ftp&gt; bin
200 Type set to I.
ftp&gt; dir linux*
200 PORT command successful.
150 Opening ASCII mode data connection for /bin/ls.
total 141009
-rw-r--r--  1 ftpload  ftp-adm   5859566 Jul  3 11:22 linux-2.0.1.tar.gz
-rw-r--r--  1 ftpload  ftp-adm   5940281 Jul 27 06:39 linux-2.0.10.tar.gz
-rw-r--r--  1 ftpload  ftp-adm   5952403 Aug  5 03:01 linux-2.0.11.tar.gz
-rw-r--r--  1 ftpload  ftp-adm   5954278 Aug  9 12:53 linux-2.0.12.tar.gz
-rw-r--r--  1 ftpload  ftp-adm   5981780 Aug 16 06:19 linux-2.0.13.tar.gz
-rw-r--r--  1 ftpload  ftp-adm   5984960 Aug 20 11:52 linux-2.0.14.tar.gz
-rw-r--r--  1 ftpload  ftp-adm   5986368 Aug 25 06:20 linux-2.0.15.tar.gz
-rw-r--r--  1 ftpload  ftp-adm   5990228 Aug 31 14:03 linux-2.0.16.tar.gz
-rw-r--r--  1 ftpload  ftp-adm   5991606 Sep  2 06:37 linux-2.0.17.tar.gz
-rw-r--r--  1 ftpload  ftp-adm   5993351 Sep  5 10:38 linux-2.0.18.tar.gz
-rw-r--r--  1 ftpload  ftp-adm   5997342 Sep 11 10:21 linux-2.0.19.tar.gz
-rw-r--r--  1 ftpload  ftp-adm   5861789 Jul  5 12:09 linux-2.0.2.tar.gz
-rw-r--r--  1 ftpload  ftp-adm   5997693 Sep 13 08:53 linux-2.0.20.tar.gz
-rw-r--r--  1 ftpload  ftp-adm   5999162 Sep 20 09:51 linux-2.0.21.tar.gz
-rw-r--r--  1 ftpload  ftp-adm   6009488 Oct  8 13:02 linux-2.0.22.tar.gz
-rw-r--r--  1 ftpload  ftp-adm   6010694 Oct 18 08:20 linux-2.0.23.tar.gz
-rw-r--r--  1 ftpload  ftp-adm   5931967 Jul  6 07:53 linux-2.0.3.tar.gz
-rw-r--r--  1 ftpload  ftp-adm   5926911 Jul  8 08:48 linux-2.0.4.tar.gz
-rw-r--r--  1 ftpload  ftp-adm   5927899 Jul 10 08:23 linux-2.0.5.tar.gz
-rw-r--r--  1 ftpload  ftp-adm   5929807 Jul 12 07:22 linux-2.0.6.tar.gz
-rw-r--r--  1 ftpload  ftp-adm   5931378 Jul 15 07:38 linux-2.0.7.tar.gz
-rw-r--r--  1 ftpload  ftp-adm   5936467 Jul 20 02:52 linux-2.0.8.tar.gz
-rw-r--r--  1 ftpload  ftp-adm   5939510 Jul 26 04:09 linux-2.0.9.tar.gz
-rw-r--r--  1 ftpload  ftp-adm   5843677 Jun  9 23:36 linux-2.0.tar.gz
226 Transfer complete.
ftp&gt; get linux-2.0.20.tar.gz
200 PORT command successful.
150 Opening BINARY mode data connection for linux-2.0.20.tar.gz (5997693 bytes).
226 Transfer complete.
5997693 bytes received in 136 secs (43 Kbytes/sec)
ftp&gt; quit
221 Goodbye.
</screen>
    </para><para>
      Sisteme root olarak giriş yapın ve <literal>/usr/src</literal> dizinine geçin. Linux'un
      kurulması aşamasında çekirdekleri de kurmuş iseniz bu dizinde 'linux'
      isminde ve eski çekirdeğin kaynak kodlarını kapsayan bir alt dizin
      göreceksiniz. Genellikle her kullanıcının yaptığı, bu dizinin ismini o
      an çalışan çekirdeğin sürümüne göre değiştirmektir. Çekirdek sürümünü
      bulmak için ise <literal>uname -r</literal> komutunu kullanabilirsiniz.
    </para><para>
<screen>
$ uname -r
  2.0.23
</screen>
    </para><para>
      Bu komuttan çekirdeğin 2.0.23 sürümü olduğunu anlayabiliriz.
    </para><para>
      Çekirdek kodunu içeren paketi açmadan önce <literal>/usr/src</literal> dizinine
      kopyalayın ve açmadan önce bu dizinde 'linux' isimli bir dizinin
      olmadığına emin olun. Şimdi <literal>/usr/src</literal> içinde iken sıkıştırılmış
      çekirdek kodunu 'tar' komutu yardımıyla açın.
    </para><para>
<screen>
# tar -zxf linux-x.y.z.tar.gz
</screen>
    </para><para>
      Komutun işletimi bitince 'linux' dizini oluşur. İlk defa derleme işlemi
      yapacaksanız aşağıdaki komutları sırasıyla yazın.
    </para><para>
<screen>
# cd /usr/include
# rm -rf asm linux scsi
# ln -s /usr/src/linux/include/asm-i386 asm
# ln -s /usr/src/linux/include/linux linux
# ln -s /usr/src/linux/include/scsi scsi
# cd /usr/src/linux
# make mrproper
</screen>
    </para>
    <sect2>
      <title>Çekirdeğin Yapılandırılması</title>
      <para>
        <literal>/usr/src/linux</literal> dizini altinda iken <literal>make config</literal> yazın. Bu
        komut, bir yapılandırma dosyası yaratmak amacıyla sorular sorar.
      </para><para>
        Karşınıza çıkan sorulara 'y' (evet) veya 'n' (hayır) ile cevap vermeniz
        gerekir. Bazı aygıt sürücülerde 'm' seçeneği de olabilir. Bunun anlamı,
        sistem o programı <emphasis>modül</emphasis> olarak derleyecek ve çekirdeğe dahil etmeyecek
        demektir. Kullanıcı derleme aşamasından sonra istediği zaman bu modülü
        çekirdeğe dahil edebilir, işini bitirdikten sonra da çıkarabilir.
      </para><para>
        2.0.x ve daha yukarı sürümlerde '?' tuşuna basmakla daha ayrıntılı
        bilgi alabilirsiniz. Aşağıda bazı yapılandırma parametreleri verilmiştir.
      </para><para>
        <variablelist>
          <varlistentry>
            <term>Matematik işlemci emülasyonu (Kernel math emulation)</term>
            <listitem><para>
              Kullandığınız makinanın işlemcisi yardımcı matematik işlemcisine sahip değilse (486SX,
              386SX veya daha düşük makinalar) bu seçeneğe evet cevabını vermelisiniz.
            </para></listitem>
          </varlistentry>
          <varlistentry>
            <term>Normal (MFM/RLL) disk ve IDE disk/cdrom desteği (Normal disk and
            IDE disk/cdrom support)</term>
            <listitem><para>
              Hemen herkesin kullandığı PC sabit
              disklerinin standart olması sebebiyle bu seçenege 'y' cevabı
              verilebilir. Daha ileride SCSI sabit disk ve cdrom desteği de
              sorulacaktır.  Ardından gelecek olan 'old disks-only' ve 'new IDE'
              sürücülerinden birini seçerken, aralarındaki farkın ilkinde tek
              arabirim üzerinden iki adet diski desteklemesi, diğerinde ise ikinci
              arabirim ile birlikte IDE/ATAPI cdrom'ları desteklemesidir.
            </para></listitem>
          </varlistentry>
          <varlistentry>
            <term>Ağ desteği (Networking support)</term>
            <listitem><para>
              Makinanız herhangi bir ağ üzerinde
              ise (İnternet gibi) veya İnternet'e bağlanmak için SLIP, PPP
              gibi programları kullanmak istiyorsanız bu bölüme 'y' cevabı
              vermelisiniz. Fakat, ağ üzerinde olmasanız bile her geçen gün yeni yeni
              uygulama programlarının ve paketlerin ağ desteğine ihtiyacı olduğunu
              düşünürsek (X Pencere gibi) bu bölüme 'y' cevabı vermeniz şart görünüyor.
            </para></listitem>
          </varlistentry>
          <varlistentry>
            <term>En fazla 16Mb hafıza (Limit memory to low 16Mb)</term>
            <listitem><para>
              Bazı hatalı 386 DMA
              denetleyicileri hafızanın 16Mb'tan yüksek bölümlerine ulaşamazlar. Çok
              nadir görülen bu durum makinanızda varsa bu seçeneği 'y' ile geçin.
            </para></listitem>
          </varlistentry>
          <varlistentry>
            <term>System V IPC (System V IPC):</term>
            <listitem><para>
              IPC (Interprocess Communication) desteği
              verir. Bazı Perl programları ve oyunlar (DOOM gibi) bu seçenek olmadan
              çalışamazlar. Bu durumda ne yaptığınızı iyi bilmiyorsanız bu seçeneğe
              'y' -evet- cevabı verin.
            </para></listitem>
          </varlistentry>
          <varlistentry>
            <term>İşlemci tipi (386, 486, Pentium, PPro):</term>
            <listitem><para>
              Burada, çekirdeğinizi hangi
              tür makina için derliyorsanız, o makinanın tipini giriniz.
            </para></listitem>
          </varlistentry>
          <varlistentry>
            <term>SCSI desteği (SCSI Support):</term>
            <listitem><para>
              SCSI aygıtlarınız var ise bu seçenek için
              'evet' deyin. Daha sonra da karşınıza gelecek SCSI aygıtlar arasından
              size uygun olanları alın.
            </para></listitem>
          </varlistentry>
          <varlistentry>
            <term>Ağ kartı desteği (Network Device Support):</term>
            <listitem><para>
              Ağa bağlanmak için bir kart
              kullanacaksanız veya SLIP, PPP bağlantıları ya da paralel port üzerinden
              yapacağınız her türlü işlemler için bu seçeneği işaretleyin. Ardından
              ekrana gelen kart tiplerinden uygun olanlarını seçin.
            </para></listitem>
          </varlistentry>
          <varlistentry>
            <term>Dosya sistemleri (Filesystems):</term>
            <listitem><para>
              Burada, aşağıdaki dosya sistemlerinden
              kullanmak istediklerinizi seçebilirsiniz.
            </para><para>
              <variablelist>
                <varlistentry>
                  <term>minix</term>
                  <listitem><para>
                    Yeni dağıtımlar , artik tarih olmaya başlayan bu dosya
                    sistemini desteklememekte. Bazı kurtarma disketleri yaratmak
                    için daha yaygın, fakat daha az kararlı olan ext2 dosya
                    sistemine tercih edilirler.
                  </para></listitem>
                </varlistentry>
                <varlistentry>
                  <term>Extended file system (ext)</term>
                  <listitem><para>
                    Bu da artık kullanımı olmayan bir dosya
                    sistemi. Desteğini ekleyip eklememek size kalmış.
                  </para></listitem>
                </varlistentry>
                <varlistentry>
                  <term>Second extended file system (ext2)</term>
                  <listitem><para>
                    Linux'un kullandığı en önemli dosya sistemi. Alınması şart.
                  </para></listitem>
                </varlistentry>
                <varlistentry>
                  <term>xiafs</term>
                  <listitem><para>
                    Artık kullanılmıyor.
                  </para></listitem>
                </varlistentry>
                <varlistentry>
                  <term>msdos</term>
                  <listitem><para>
                    Sabit diskinizde DOS bölümü varsa ya da DOS disketi kullanmak
                    istiyorsanız, alın.
                  </para></listitem>
                </varlistentry>
                <varlistentry>
                  <term>umsdos</term>
                  <listitem><para>
                    MS-DOS dosya sistemine bazı yenilikler (uzun dosya isimleri
                    gibi) getirilerek oluşturulan bir teknoloji. MS-DOS desteği
                    almadıysanız buna da gerek yok.
                  </para></listitem>
                </varlistentry>
                <varlistentry>
                  <term>proc</term>
                  <listitem><para>
                    Bu aslında gerçek bir dosya sistemi değil, çekirdek
                    görüntüsüdür. `y' cevabını vermezseniz ileride başınız
                    çok ağrır.
                  </para></listitem>
                </varlistentry>
                <varlistentry>
                  <term>NFS</term>
                  <listitem><para>
                    Linux makinaniz bir ağ üzerinde kurulu iken ağ üzerindeki
                    diğer makinaların dosya sistemlerini kullanabilmenizi sağlar.
                  </para></listitem>
                </varlistentry>
                <varlistentry>
                  <term>ISO9660</term>
                  <listitem><para>
                    CD-ROM sürücünüzü Linux altında kullanabilmek için 'y' cevabı
                    verin.
                  </para></listitem>
                </varlistentry>
                <varlistentry>
                  <term>OS/2 HPFS</term>
                  <listitem><para>
                    OS/2 dosya sistemlerini okuyabilmek için 'y' cevabı verin.
                  </para></listitem>
                </varlistentry>
                <varlistentry>
                  <term>System V</term>
                  <listitem><para>
                    Bir UN*X sürümü olan System V makinalarının dosya sistemleri
                    üzerinde çalışabilmeyi sağlar.
                  </para></listitem>
                </varlistentry>
              </variablelist>
            </para></listitem>
          </varlistentry>
          <varlistentry>
            <term>Karakter aygıtlar (Character devices)</term>
            <listitem><para>
              Bu bölümde yazıcı, fare ve bazı teyp yedekleme sürücüleri gibi
              karakter aygıtları (iletişimini karakter karakter sağlayan aygıtlar)
              için sürücüleri ekleyebilirsiniz.
            </para></listitem>
          </varlistentry>
          <varlistentry>
            <term>Ses kartı (Sound Card Support)</term>
            <listitem><para>
              Linux'un ses kapasitesini "duyabilmek" için bu desteği ekleyin.
            </para></listitem>
          </varlistentry>
          <varlistentry>
            <term>Çekirdek işlemleri (Kernel Hacking)</term>
            <listitem><para>
              Çekirdekten doğan hataların bulunmasını kolaylaştıran bu seçenek, programcılara yönelik.
            </para></listitem>
          </varlistentry>
        </variablelist>
      </para><para>
        Tüm bu işlemlerin ardından <literal>make config</literal> komutunun
        görevi bitmiş olur.
      </para>
    </sect2><sect2>
      <title>Temizlik</title>
      <para>
        Fazla dosyaları temizlemek, gerekli olan dosyaların da yerinde olup
        olmadığını kontrol etmek için , sırasıyla
      </para><para>
<screen>
# make dep
# make clean
</screen>
      </para><para>
        yazın. Ardından tüm nesne dosyaları ve eski sürümden arta kalan dosyalar
        silinecektir. Bu adımı es geçmemelisiniz.
      </para><para>
        Temizlik işleminden sonra,
      </para><para>
        <screen># make zImage</screen>
      </para><para>
        veya
      </para><para>
        <screen># make zdisk</screen>
      </para><para>
        yazın. Eğer bir kişisel bilgisayarda çalışıyorsanız, ilk seçenekte
        çekirdek derlenip <literal>/usr/src/linux/arch/i386/boot</literal>
        dizini altına <literal>zImage</literal> adıyla yerleştirilecektir.
        Buraya yerleştirilmeden önce yerden kazanmak için çekirdek
        sıkıştırılır. Diğer durumda ise yeni çekirdek sabit disk yerine
        <literal>A:</literal> disket sürücüsüne yazılır. Disket üzerine
        yazmanın bir avantajı, kararlı olmayan ve sistemi açmayan çekirdek
        ile karşılaşılması halinde, sistemi sabit disk üzerindeki eski
        çekirdekten açabilme imkanı bırakmasıdır.
      </para>
    </sect2><sect2>
      <title>Çekirdeğin Kurulması</title>
      <para>
        LILO, bilgisayarın açılışı anında çekirdek ile ilgili düzenlemeleri
        okur, buna göre hangi çekirdekten açması gerektiğini anlar.
        Yapılandırma dosyası biraz karmaşık olmasına rağmen kullanım
        aşamasında büyük yararlar sağlar. <literal>/etc/lilo.conf</literal> dosyasının
        içinde gerekli olan kurulum bilgileri vardır. Bu dosyanın bir bölüm
        aşağıda görülüyor.
      </para><para>
<screen>
image = /vmlinuz
  label = linux
  root = /dev/hda1

other = /dev/hda1
  label = dos
  table = /dev/hda
</screen>
      </para><para>
        <literal>image =</literal> ibaresi kurulu olan çekirdeğe işaret eder. Çoğu kullanıcı bu
        kısma <literal>vmlinuz</literal> yazar. <literal>label =</literal> bölümünde hangi işletim sistemi veya
        çekirdek sürümünun açılışta kullanılacağı yazılır. Hemen altındaki <literal>root</literal>
        bölümünde ise <literal>label =</literal> kısmında seçilen işletim sisteminin hiyerarşik
        sırada en üst dizin yapısı yazılır. Eski çekirdeğin bir yedeğini alın
        ve yeni derlediğiniz çekirdeği <literal>image =</literal> satırında belirtilen yere
        kopyalayın.
      </para><para>
<screen>
# cp zImage /vmlinuz
</screen>
      </para><para>
Şimdi LILO programını çalıştırın. Komut satırında <literal>lilo</literal> yazmak
yeterlidir. `*' karakteri, çalıştırılacak ilk çekirdeği veya sistemi gösterir.
      </para><para>
<screen>
# lilo
Added linux *
Added dos
</screen>
      </para><para>
        LILO ve yapılandırılması hakkında , daha fazla bilgi
        <ulink url="http://www.linux.org.tr/tr-ldp/lilo/">LILO-NASIL çevirisinden</ulink> alınabilir.
      </para><para>
        Yeni bir çekirdeği derledikten sonra LILO üzerinden ekleme yapmak ve
        açılış anında kullanmak için
        <literal>/etc/lilo.conf</literal> dosyasındaki
      </para><para>
<screen>
image = /vmlinuz
  label = Linux
  root = /dev/hda1
</screen>
      </para><para>
        satırlarının kopyasını çıkarın, <literal>image</literal>,
        <literal>label</literal> ve <literal>root</literal> yerine
        sırasıyla yeni derlenen çekirdeğin sabit disk üzerindeki yerini, ismini
        ve Linux işletim sisteminizin kök dizinini yazın. Bunlara ek olarak,
        açılış anında bekleme sağlamak ve seçim yapabilmek için yapılandırma
        dosyasının başına <literal>delay = xxx</literal> ekleyebilirsiniz.
        <emphasis>xxx</emphasis> sayısı, gecikme
        zamanı saniyenin onda biri olarak verilir. Bu sayede açılış anında,
        örneğin <emphasis>shift</emphasis> tuşuna basılarak istenen çekirdeğin
        ismi (<literal>label =</literal>
        satırında yazılan isim) seçilir ve çalıştırılır.
      </para>
    </sect2><sect2>
      <title>Çekirdeğin Yamanması (patch)</title>
      <para>
        Çekirdeğin her yeni sürümüyle birlikte bir önceki sürümünun yaması
        da gelir. Yamayı uygulamak, tüm çekirdeğin tekrar derlenmesinden daha
        kolaydır. Örnek olarak, elinizde 2.0.10 çekirdeği var ve ftp adresinde
        2.0.11 sürümü bekliyor. Halihazırdaki çekirdeği 2.0.11 sürümüne
        yükseltelim:
      </para><para>
        Yamayı önce <literal>/usr/src</literal> dizinine kopyalayın. Bu dizin
        altında iken
      </para><para>
<screen>
# zcat patch-2.0.11.gz | patch -p0
</screen>
      </para><para>
        veya eğer sıkıştırılmış değilse
      </para><para>
<screen>
# patch -p0 &lt; patch-2.0.11
</screen>
      </para><para>
        yazın. Bu komutun ardından satırlar ekrandan kaymaya başlayacak ve
        yama işlemi tamamlanacaktır. Satırlar bazen o kadar hızlı kayar ki
        neler yazdığını bile göremeyebilirsiniz. Yamanın başarılı bir şekilde
        tamamlandığından emin olmak amacıyla, <literal>/usr/src/linux</literal> dizini
        altında <literal>.rej</literal> uzantılı dosyalara bakın.
      </para><para>
<screen>
# find . -name '*.rej' -print
</screen>
      </para><para>
        Komut, <literal>.rej</literal> uzantılı dosyalar bulursa yama işlemi tamamlanamamış
        demektir. Eğer yama işlemi tamamlanırsa, sırasıyla
      </para><para>
<screen>
# make clean
# make config
# make dep
</screen>
      </para><para>
        komutlarını yazın. Bu komutlarla ilgili ayrıntılı bilgi önceki konuda
        anlatılmıştır.
      </para><para>
        <literal>patch</literal> komutunun alabildiği bazı seçenekler vardır.
        <literal>patch -s</literal> komutu
        oluşabilecek tüm hata mesajlarını ekrana yazar. Diğer yama seçenekleri
        <literal>man patch</literal> yazarak görülebilir.
      </para><para>
        Birkaç yamanın ardından, .orig uzantılı dosyalar etrafta dolaşmaya
        başlar. Bu dosyalar gereksizdir, büyük yer kapladıkları için silinmeleri
        gerekir. Aşağıdaki komut yardımıyla <literal>/usr/src/linux</literal> dizini altında
        <literal>.orig</literal> uzantılı dosyaları silebilirsiniz.
      </para><para>
<screen>
# find /usr/src/linux  -name '*.orig' -exec rm -f {} ';'
</screen>
      </para>
    </sect2><sect2>
      <title>Çıkabilecek Sorunlar</title>
      <para>
        Eger rutin bir çekirdek güncellemesinden sonra yeni çekirdeğiniz gerçekten
        garip şeyler yapıyorsa, büyük ihtimalle yeni çekirdeğinizi derlemeden önce
        "make clean" komutunu kullanmayı unutmuşsunuzdur.
      </para><para>
        Eğer çekirdek çok fazla hafıza harcıyorsa, çok büyükse veya yeni
        786DX6/440 makinanızda bile derlenmesi sonsuza kadar sürüyorsa, büyük ihtimalle
        ayarlanmış bir çok gereksiz parça (aygıt sürücüleri, dosya sistemleri, vb.)
        vardır. Büyük çekirdeklerin en belirgin özelliği sürekli hafızadan diske ve
        diskten hafızaya takas yapmalarıdır.
      </para><para>
        Çekirdeğinizin ne kadar hafıza kullandığını makinanın toplam
        hafızasından <literal>/proc/meminfo</literal> dosyasındaki
        <literal>total mem</literal>
        değerini çıkararak veya <literal>free</literal> komutunun çıktısından
        öğrenebilirsiniz. Ayrıca <literal>dmesg</literal> komutunu kullanarak
        (veya çekirdek kayıt dosyasına bakarak) da bu değere ulaşabilirsiniz.
      </para><para>
<screen>
Memory: 15124k/16384k available (552k kernel code, 384k reserved, 324k data)
</screen>
      </para><para>
        LILO'yu çalışıtırmayı unuttunuz veya sistem hiç açılmıyorsa bu durumda
        yapacağınız en iyi şey disketten açılış yapmak ve daha sonra açılış
        yapabilen başka bir disket hazırlamaktır.
      </para><para>
        Eğer eski çekirdek 1.2.X ve daha düşükse ve bunu 2.0.x sürümüne
        yükseltmek istiyorsanız, 2.0.x çekirdek kurulumunda getirilen bazı
        değişiklikler sorun çıkartabilir.
        <literal>/usr/src/linux/Documentation/Changes</literal> dosyasında yapmanız
        gereken değişklik listesi vardır. <literal>gcc</literal>, <literal>libc</literal>
        gibi birkaç paketi yeniden kurmanız gerekebilir.
      </para><para>
        Aynı anda birkaç çekirdek kaynak kodunu sistemde bulundurmayı
        düşünüyorsanız, izlenecek en güvenilir yol, her birine
        <literal>/usr/src/linux-x.y.z</literal> ismini vermektir (<emphasis>x.y.z</emphasis>
        halihazırdaki çekirdek sürümünü gösterir). Ardından sembolik bir
        bağlantı yardımıyla istediğiniz kaynak dizinini seçebilirsiniz, örneğin
      </para><para>
<screen>
# ln -sf linux-2.0.2 /usr/src/linux
</screen>
      </para><para>
        komutu, <literal>linux-2.0.2</literal> dizinini aktif hale getirir.
        Artık kaynak dosyalarının
        bulunduğu yer <literal>linux-2.0.2</literal> dizinidir.
      </para>
    </sect2>
  </sect1>
  <sect1 id="archive-tlkg-lis-5.7">
    <title>Modüller (Yüklenebilir Çekirdek Parçaları)</title>
    <para>
      Linux işletim sistemi çekirdeğinin boyu genellikle 400-600Kb
      arasındadır. Hantal çekirdeklerde bu sayı 800Kb'lara kadar
      çıkabilir. Çekirdeğin boyunun büyümesi, sistemin performansını olumsuz
      yönde etkiler. Özellikle bilgisiz kullanıcıların gerekli gereksiz
      tüm desteği çekirdeğe yüklemesi sıkça görülür. Bunun önüne geçmek de
      deneyim ister.
    </para><para>
      Linux'a özgü özelliklerden birisi modüllerdir (yüklenebilir çekirdek
      parçaları). Modüller sayesinde nadiren gerekli duyulan bir çekirdek
      parçası sadece gerektiği zaman çekirdeğe eklenir. Örneğin Java
      programlarını her zaman çalıştırmak istemiyorsanız, bu desteği modül
      olarak derleyip bir kenara koyarsınız. Ne zaman bir Java programı
      çalıştırılacaksa bu modül hafızaya yüklenecektir.
    </para><para>
      Bir modül, çekirdeğin derleme aşamasında `M' parametresiyle tanımlanır. Her
      desteğin modülü henüz geliştirilmemiş olmasına rağmen bu sayı gün
      geçtikçe artmaktadır. İlginizi çekebilecek modüller arasında disket
      desteği, yazıcı desteği, minix dosya sistemi desteği veya SCSI aygıt
      sürücü desteği sayılabilir.
    </para><para>
      Bir modülü derledikten sonra modüle ait dosya <literal>/lib/modules</literal>
      dizini altında yeralır. Burada istenilen bir modül
    </para><para>
<screen>
# insmod modul-ismi
</screen>
    </para><para>
      komutuyla çekirdeğe eklenir. Modülü hafızadan çıkarmak için
    </para><para>
<screen>
# rmmod modul-ismi
</screen>
    </para><para>
      yazın. Hafızadaki modüllerin bir listesini görebilmek için de lsmod
      komutu kullanılabilir.
    </para><para>
      <literal>kerneld</literal> komutu, arkaplanda çalışarak gerekli olan modülleri anında
      yükler. Bu sayede çekirdeğe eklemek için <literal>insmod</literal> komutuna gerek
      kalmaz. Ayrıca belirli bir süre içinde kullanılmayan modülleri de
      çekirdekten atar.
    </para>
  </sect1>
  <sect1 id="archive-tlkg-lis-5.8">
    <title>Yeni Yazılımların Yüklenmesi</title>
    <para>
      Linux işletim sistemi, benzerlerine nazaran çok büyük bir hızla
      genişliyor. Her an yeni bir program, yeni bir yazılım piyasaya çıkıyor
      ve bunları takip etmek de gittikçe zorlaşıyor. Bir ftp adresini kontrol
      ettikten iki gün sonra tekrar bakıyorsunuz ki üç-beş yeni yazılım
      gelivermiş.
    </para><para>
      Tabi ki her an her programı makinanıza indirip açmak zorunda
      değilsiniz. Buna ne zamanınız, ne de sabit diskiniz yeter (Linux'un
      sunsite arşivi 20GB'tan fazla yer kaplıyor!). Öyleyse tespih çeker
      gibi program indirmek veya varolan yazılımları güncellemek komik
      olur. Sadece gereken zamanda gereken dosyaları makinanıza kurmalı veya
      güncellemelisiniz.
    </para><para>
      Bu işlem çekirdek için de geçerlidir. Bazı çekirdek fanatikleri çekirdeği
      çıktığı anda makinalarına indirir ve derlerler. Linux'a çok önemli bir
      fonksiyon kazandırmayacaksa her an çekirdek derlemek hem zaman kaybı olur,
      hem de derleme esnasında sistemi yavaşlatarak diğer kullanıcıları kızdırır.
    </para><para>
      Kurmak istediğiniz ve ftp adresinden bulup getirilen dosya çok büyük
      ihtimalle <literal>tar</literal> ve <literal>gzip</literal> ile arşivlenip
      sıkıştırılmıştır. Bu dosyanın sonu genellikle <literal>tar.gz</literal>,
      <literal>tgz</literal> veya <literal>tar.Z</literal> ile biter. Dosya
      kaynak koduyla veya çalıştırılabilir program olarak dağıtılıyor olabilir.
      Her iki durumda da yapılacak işlemler birbirine benzer.
    </para><para>
      Öncelikle yazılımın açıldığı zaman hangi dizine kendini yerleştireceğine
      bakmak gerekir. Bunu tar komutunun <literal>-t</literal> seçeneği ile kontrol edin.
      compress ve gzip ile sıkıştırılmış dosyalar için,
    </para><para>
<screen>
# tar -ztvf dosya.tar.gz
</screen>
    </para><para>
      komutu kullanılabilir. Çok nadir durumlarda dosya, kendine ait bir dizin
      yaratmaz, onlarca programı ve yapılandırma dosyasını bulunduğunuz dizine
      yazar. Karmaşıklık yaratan bu durumdan ancak arşivi ayrı bir dizin altında
      açmakla kurtulabilirsiniz.
    </para><para>
      Linux'çular yeni bir yazılımı denemek istediklerinde arşivi genellikle
      <literal>/usr/src</literal> veya <literal>/usr/local/src</literal> dizini altına
      kopyalarlar ve burada açarak biraz sonra anlatılacak yapılandırma
      işlemini uygularlar. Derleme gerektirmeyen bazı programların ise
      doğrudan kök dizinde açılmaları gerekebilir. Bu programlar açıldıkları
      anda çalışmaya hazırdırlar.
    </para><para>
      <literal>/usr/src</literal> veya <literal>/usr/local/src</literal> dizini altına dosyayı
      açtıktan sonra bol miktarda dosya ve dizinle karşılaşabilirsiniz. Buna
      en iyi örnek Linux çekirdeğidir. Burada yeralan bazı anahtar dosyalar
      yazılımın kurulması için hayati önem arzeder.
    </para><para>
      Öncelikle <literal>README</literal>, <literal>README.linux</literal> ve varsa <literal>INSTALL</literal>
      dosyalarının gözden geçirilmesi gerekir. Bunlar sırayla bir kullanıcı
      olarak dosyaları nasıl kuracağınızı ayrıntılarıyla söyler. Kurma
      aşamasında dikkat edilecek dosyalardan ilki <literal>Makefile</literal> veya
      <literal>makefile</literal> dosyasıdır. Bu dosyanın içinde (nadiren) küçük birkaç
      değişiklik yapmak gerekebilir. Diğer kontol edilmesi gereken dosya ise
      varsa <literal>config.h</literal> dosyasıdır. Bunu da sistem gereksinimize göre
      değiştirmelisiniz.
    </para><para>
      Bazen başta derleyici olmak üzere sistemdeki yazılımı baştan aşağı kontrol
      eden programlar olabilir (<literal>configure</literal> gibi). Bunların da komut satırından
      çalıştırılmaları gerekir.
    </para><para>
      Varsa <literal>Makefile</literal> dosyasına göre yazılımı kurmak için <literal>make</literal> komutunu
      kullanın. make komutu kuruluma <literal>make all</literal>, <literal>make install</literal> gibi bazı
      parametreler alabilir. <literal>make all</literal>, halihazırda yeralan tüm yazılımları
      kurarken <literal>make install</literal>, bu yazılımı yapılandırma dosyalarının gösterdiği
      dizinlere yerleştirirler.
    </para><para>
      Çoğu büyük paketler, man dosyalarıyla birlikte gelirler. Bunları da diğer
      man dosyalarının yanına (<literal>/usr/man</literal>) koymak için ayrı bir
      <literal>make install.man</literal> türü komut kullanmak gerekebilir.
    </para><para>
      Her durumda, mutlaka <literal>README</literal> dosyasını okuyun. Biraz sıkıcı gelse
      de sizi zaman kaybından kurtaracaktır.
    </para><para>
      Slackware dağıtımını kullanıyorsanız, yüklenmiş yazılımları silmek için 2
      yolunuz var. Birincisi, root olarak sisteme girip, istemediğiniz
      programları tek tek komut satırından silebilirsiniz. Ama bu size
      önerebileceğimiz bir yol değil ve çok fazla sakıncası var. Örneğin,
      programı silip, ona olan bağlantıları unutabilirsiniz. Ya da tam tersi
      olabilir. İkinci yol ve en geçerlisi, Slackware dağıtımı ile gelen
      <emphasis>pkgtool</emphasis> programı kullanmanız. <literal>pkgtool</literal> seçenekleri arasındaki
      <emphasis>remove package</emphasis> işinize yarayacaktır.
    </para>
  </sect1>
  <sect1 id="archive-tlkg-lis-5.9">
    <title>Sistem Açılış Dosyaları</title>
    <para>
      Linux makinası açılırken onlarca dosyayı okur. Birkaç dakika
      içinde çekirdeği hafızaya yükler, belirli dizinlerin altındaki
      programları arkaplanda çalıştırır. Sistem uyanırken hatırı sayılır
      nicelikte yapılandırma dosyası elden geçer. Açık bir işletim sistemini
      diğerlerinden ayıran bir özellik de kullanıcının büyük bir kolaylıkla bu
      yapılandırma dosyalarını değiştirebilmesidir. Sistem açılış dosyalarında,
      özellikle ağ temelli dosyalarda değişiklik yapabilmek için TCP/IP konusunda
      basit temelleri anlayabilmiş olmanız gerekir.
    </para><para>
      Açılış dosyalarında, tek bir kullanıcı için veya sistemde hesabı olan
      herkese yönelik olarak değişiklik yapmak mümkündür. Pek çok kullanıcı
      bu açılış dosyalarıyla oynayarak Linux'u daha yakından öğrenme imkanına
      sahip olur.
    </para><para>
      İnternet servisi veren bir makina bu servisini daemon'lar aracılığıyla
      yapar. Bir daemon, her makina tarafından bilinen bir port numarasını açar
      ve dinlemeye koyulur. Eğer sorumlu olduğu port adresine istek gelirse
      bu isteğe cevap vererek servise başlar.
    </para><para>
      <emphasis>Bash</emphasis> kabuğunun anlatıldığı konu içinde sisteme girerken okunan dosyaları
      anlatmıştım. Sistemde yeralan önemli dizinler de dosya sistemi yapısı
      konusunda ayrıntılı olarak belirtilmişti. Bu bölümde daemonlardan kısaca
      bahsedip açılış anında çalıştırılan programlara ve bunların yapılandırma
      dosyalarına kısa bir giriş yapılacaktır.
    </para>
    <sect2>
      <title>inetd ve /etc/inetd.conf</title>
      <para>
        <emphasis>inetd</emphasis>, en ağır görevleri üstlenen ve en önemli İnternet
        servislerindendir. Bu program sistem açılırken arkaplanda çalışmaya
        bırakılır. inetd'nin görevi belirli portları dinleyerek bu portlara
        yapılan bağlantıları denetlemektir. Bir bağlantı yapıldığı anda inetd
        bu portla ilgilenecek olan programı çalıştırır. Örnek olarak Linux'a
        ftp isteği geldiği anda inetd, ftp isteğine cevap verecek olan <emphasis>wu.ftpd</emphasis>
        programını uyandırır ve geri kalanını bu programa bırakır.
      </para><para>
        inetd olmasaydı her standart port numarası için bu portu dinleyecek olan
        bir program arkaplanda çalışıyor olacaktı. Bu da sisteme normalden daha
        fazla yükün binmesi demektir. inetd'nin kullandığı yapılandırma dosyası
        <literal>/etc/inetd.conf</literal>'tur. Bu dosyadan bir bölüm aşağıda
        yeralmaktadır:
      </para><para>
<screen>
# &quot;kill -HUP &lt;pid of inetd&gt;&quot;.
# The inetd will re-read this file whenever it gets that signal.
#
# &lt;service_name&gt; &lt;sock_type&gt; &lt;proto&gt; &lt;flags&gt; &lt;user&gt; &lt;server_path&gt; &lt;args&gt;
#
time    stream  tcp     nowait  root    internal
time    dgram   udp     wait    root    internal
ftp     stream  tcp     nowait  root    /usr/sbin/tcpd  wu.ftpd
telnet  stream  tcp     nowait  root    /usr/sbin/tcpd  in.telnetd
#nntp   stream  tcp     nowait  root    /usr/sbin/tcpd  in.nntpd
shell   stream  tcp     nowait  root    /usr/sbin/tcpd  in.rshd -L
login   stream  tcp     nowait  root    /usr/sbin/tcpd  in.rlogind
ntalk   dgram   udp     wait    root    /usr/sbin/tcpd  in.talkd
pop3    stream  tcp     nowait  root    /usr/sbin/tcpd  in.pop3d
imap2   stream  tcp     nowait  root    /usr/sbin/tcpd  imapd
finger  stream  tcp     nowait  nobody  /usr/sbin/tcpd  in.fingerd -w
systat  stream  tcp     nowait  nobody  /usr/sbin/tcpd  /bin/ps -auwwx
netstat stream  tcp     nowait  root    /usr/sbin/tcpd  /bin/netstat    -a
# End of inetd.conf.
</screen>
      </para><para>
        <literal>/etc</literal> altında bir yapılandırma dosyasını değiştirmek
        isterseniz, o dosyayı okuyan ve arkaplanda çalışıyor durumda bulunan
        süreçleri bundan haberdar etmelisiniz. Çünkü bu dizindeki bazı dosyalar
        sadece açılışta okunur. inetd, yukarıdaki <literal>inetd.conf</literal>
        dosyasını sistem açılırken okuyacaktır. Değişiklik yaptıktan sonra
        inetd'nin bu değişiklikten tekrar haberinin olması için bu sürecin
        <literal>PID</literal> numarasını <literal>ps -aux</literal> komutu ile
        bir kenara not edin ve şunları yazın.
      </para><para>
<screen>
# kill -HUP &lt;PID-inetd&gt;
</screen>
      </para><para>
        <emphasis>PID-inetd</emphasis> yerine not ettiğiniz süreç numarasını girmelisiniz. Bu
        sayede inetd kendisine ait olan inetd.conf dosyasını tekrar okuyacak ve
        değişiklikler işleme konacaktır.
      </para><para>
        Her bilgisayar tarafından bilinen servislerin isimleri ve hangi portları
        (portları) kullandıkları <literal>/etc/services</literal> dosyasında
        tutulur.
      </para>
    </sect2><sect2>
      <title>syslogd ve /etc/syslog.conf</title>
      <para>
        syslogd programı Linux'taki çeşitli olayların kayıtlarını
        tutar. Bunlar genellikle hata mesajları veya çekirdek mesajları gibi
        kayıtlardır. syslogd sistem açılırken arkaplanda işlemeye bırakılır.
      </para><para>
        <literal>/etc/syslog.conf</literal>, syslogd programının yapılandırılması için
        kullanılır. Normal olarak sistem kayıtları <literal>/usr/adm/messages</literal>
        dosyasının sonuna eklenir. Bu dosyanın yapısı biraz karışık olmasına
        rağmen eğer sistem yöneticiyseniz syslogd sizin en büyük yardımcınız
        olabilir.
      </para><para>
        Örnek bir <literal>syslog.conf</literal> dosyası aşağıda yeralıyor.
      </para><para>
<screen>
*.info;*.notice                                 /usr/adm/messages
*.debug                                         /usr/adm/debug
*.warn                                          /usr/adm/syslog
*.emerg;*.alert;*.crit                          /dev/tty8
mail.*                                          /dev/tty9
kern.*                                          /dev/tty10
</screen>
      </para><para>
        Bu dosyanın en solunda yeralan ve nokta ile ayrılmış olan iki kelimeden
        ilki, kaydı yapılan program grubudur. Bu kısma kern (çekirdek mesajları),
        mail (sendmail mesajları), login (sisteme giriş veya sistemden çıkış
        mesajları), auth, authpriv veya security (güvenlik mesajları), cron
        (cron mesajları), daemon (deamon'lardan gelen mesajlar),lpr (yazıcı mesajları),
        news (haber grubu mesajları), user (kullanıcı mesajları) veya uucp (uucp
        mesajları) yazılabilir. Noktanın sağındaki kelime ise kaydı yapılan program
        grubunun mesaj önem sırasını belirler. Bu kısımda önem sırasına göre debug,
        info, notice, warning, err, crit, alert ve emerg bulunur.
      </para><para>
        Dosyanın sağında yeralan kısımda ise bu mesajların hangi dosyaya
        yazılacağı vardır. Yukarıda verilen örnekte, syslogd'den gelen mesajlar
        sanal konsollardan kullanılmayanlara yönlendirilmiştir. Böylece sistem
        yöneticisi F8, F9 ve F10 tuşlarını kullanarak sistem kayıtlarına anında
        ulaşabilir.
      </para><para>
        Başka bir makinaya kayıt tutturmak da mümkündür. Uzak makinanın ismi
        <literal>syslog.conf</literal> dosyasının sağ bölümüne yazılır. Böylece
        diğer makina yerel olarak sistem kayıtlarını tutacaktır.
      </para><para>
<screen>
mail.err                     @ordek.cclub.metu.edu.tr
</screen>
      </para><para>
        Bazı kritik ve sistemin düzgün çalışmadığını haber verebilecek mesajların
        konsola yönlendirilmesinde fayda vardır.
      </para><para>
<screen>
kern.crit                    /dev/console
</screen>
      </para><para>
        Sisteme bağlanmış olan kullanıcılar hakkında bilgiyi ise
      </para><para>
<screen>
/var/adm/wtmp
</screen>
      </para><para>
        dosyası tutar. Bu dosya ASCII olmadığından doğrudan okunamaz, <literal>last</literal> komutu
        ile içeriği incelenebilir. Buna ek olarak çeşitli paketler
        çalıştırılıyorsa onların yarattığı kayıt dosyaları da incelenmelidir.
        Örneğin ftp çalışıyorsa <literal>/var/adm/xferlog</literal> kimin ftp ile hangi dosyaları
        aktardığını gösterir. Bu tür dosyalar içerisinde elde edilebilecek
        ipuçları ile sistemin çalışma performansı artırılabilir, kendisini pek
        belli etmeyen hatalar bulunabilir.
      </para>
    </sect2><sect2>
      <title>init ve /etc/inittab</title>
      <para>
        <literal>init</literal>, sistemde ilk çalışan programdır. Neredeyse sistemin tüm
        açılış yükünü elinde tutar. init sayesinde açılış anında hangi
        programların çalışacağı belirlenir. Bu programları da
        <literal>/etc/inittab</literal> dosyasından öğrenir.
      </para><para>
        Burada <literal>/etc/inittab</literal> dosyasından alınan birkaç örnek satır
        yeralıyor. Her satırın sonunda çalıştırılacak olan dosyalar var.
      </para><para>
<screen>
# Default runlevel.
id:3:initdefault:

# System initialization (runs when system boots).
si:S:sysinit:/etc/rc.d/rc.S

# Script to run when going single user (runlevel 1).
su:1S:wait:/etc/rc.d/rc.K

# Script to run when going multi user.
rc:23456:wait:/etc/rc.d/rc.M

# What to do at the &quot;Three Finger Salute&quot;.
ca::ctrlaltdel:/sbin/shutdown -t5 -rfn now

# Runlevel 0 halts the system.
l0:0:wait:/etc/rc.d/rc.0

# Runlevel 6 reboots the system.
l6:6:wait:/etc/rc.d/rc.6

# What to do when power fails (shutdown to single user).
pf::powerfail:/sbin/shutdown -f +5 &quot;THE POWER IS FAILING&quot;

# If power is back before shutdown, cancel the running shutdown.
pg:0123456:powerokwait:/sbin/shutdown -c &quot;THE POWER IS BACK&quot;

# If power comes back in single user mode, return to multi user mode.
ps:S:powerokwait:/sbin/init 5

c1:1235:respawn:/sbin/agetty 38400 tty1 linux
c2:1235:respawn:/sbin/agetty 38400 tty2 linux
c3:1235:respawn:/sbin/agetty 38400 tty3 linux
c4:1235:respawn:/sbin/agetty 38400 tty4 linux
c5:1235:respawn:/sbin/agetty 38400 tty5 linux
c6:12345:respawn:/sbin/agetty 38400 tty6 linux

# Serial lines
#s1:12345:respawn:/sbin/agetty 19200 ttyS0 vt100
#s2:12345:respawn:/sbin/agetty 19200 ttyS1 vt100

# Dialup lines
#d1:12345:respawn:/sbin/agetty -mt60 38400,19200,9600,2400,1200 ttyS0 vt100
#d2:12345:respawn:/sbin/agetty -mt60 38400,19200,9600,2400,1200 ttyS1 vt100

x1:4:wait:/etc/rc.d/rc.4
</screen>
      </para><para>
        Bir Linux makinasının birkaç tane çalışma düzeni vardır. Bunlardan
        birkaçı 3 (çok kullanıcılı konum), 1 (tek kullanıcılı konum) ve 4 (X Pencere
        konumu)'tür. Her konum, bir sayı veya bu sayılara karşılık gelen tek harften
        oluşur. Bir konum altında çalışırken diğerine geçebilmek için <literal>init</literal> veya
        <literal>telinit</literal> komutu kullanılır.
      </para><para>
        <literal>/etc/inittab</literal>'da yeralan dosya isimleri değiştirilebilir
        veya kullanıcının isteği doğrultusunda her çalışma modu için farklı
        dosyalar çalıştırilabilir.
      </para><para>
<screen>

# init 1
Switching to runlevel 1
Sending all processes the TERM signal
Waiting for processes to terminate........
Turning off quota..
Single user mode.
</screen>
      </para><para>
        <literal>init</literal> komutundan sonra açmak istediğiniz çalışma düzenine ait
        olan sayıyı yazabilirsiniz. Örneğin init 0 komutu sistemi kapatacaktır.
        Yukarıdaki komut çalıştıktan sonra <literal>/etc/inittab</literal> dosyasında
        bu konuma ait olan <literal>/etc/rc.d/rc.K</literal> dosyası çalıştırılır. Bu
        dosya çalıştıktan sonra dışarıdan yapılan bağlantılara izin verilmez.
      </para><para>
        <literal>/etc/inittab</literal> dosyasında yapılacak her değişikliğin ardından
      </para><para>
<screen>
# init q
</screen>
      </para><para>
        komutunu vererek init programının inittab dosyasını tekrar okuyup
        değişikliklerden haberdar olmmasını sağlamalısınız. O an sistemin hangi
        konumda çalıştığını bulabilmek için runlevel komutunu kullanın:
      </para><para>
<screen>
$ runlevel
N 3
</screen>
      </para><para>
        Sistem, yukarıdaki bilgilere göre 3 numaralı konumda (çok kullanıcılı konum)
        çalışıyor.
      </para>
    </sect2><sect2>
      <title>/etc/rc.d/* Dosyaları</title>
      <para>
        İşte sistemin kalbinin attığı yer. Ne yaparsanız yapın ama bu dosyaları
        gözünüz gibi koruyun. Sistem açılırken arkaplanda çalışmaya başlayan
        programlar burada yazılıdır. Tüm bu dosyalar Slackware dağıtımına özgüdür.
      </para><para>
        <variablelist>
          <varlistentry>
            <term>rc.0</term>
            <listitem><para>
              Bu dosya, 0 (halt) çalışma düzenine geçerken okunur. Sistemin shutdown
              veya halt komutları ile kapatılmak istenirse bu program çalıştırılır.
              Önce sistemdeki tüm süreçler öldürülür, ardından sistemin kapandığını
              belirten bazı satırları kayıt dosyalarına atar. Tüm dosya sistemlerini
              umount işleminden geçirdikten sonra da sistemi dondurur.
            </para></listitem>
          </varlistentry>
          <varlistentry>
            <term>rc.K</term>
            <listitem><para>
              Bu dosya, init tarafından 1 numaralı çalışma düzenine (tek kullanıcılı
              konum) geçilirken çalıştırılır. Tüm süreçler öldürülür ve sistem sadece
              konsoldan giriş yapılacak şekilde tekrar açılır.
            </para></listitem>
          </varlistentry>
          <varlistentry>
            <term>rc.cdrom</term>
            <listitem><para>
              Bu dosya, bulduğu CDROM sürücüsünü /cdrom dizini altına mount
              yardımıyla ekler.
            </para></listitem>
          </varlistentry>
          <varlistentry>
            <term>rc.local</term>
            <listitem><para>
              Çok kullanıcılı açılış anında çalıştırılan bu dosyaya istediğiniz
              programları ekleyebilirsiniz.
            </para></listitem>
          </varlistentry>
          <varlistentry>
            <term>rc.4</term>
            <listitem><para>
            4 numaralı çalışma düzenine geçilirken bu dosya çağırılır. Tüm sanal
            konsollara vt100 terminalleri yerine grafik tabanlı bir program
            kullanılarak girilir.
            </para></listitem>
          </varlistentry>
          <varlistentry>
            <term>rc.M</term>
            <listitem><para>
              init tarafından çok kullanıcılı konuma geçmek için kullanılır.
            </para></listitem>
          </varlistentry>
          <varlistentry>
            <term>rc.S</term>
            <listitem><para>
            Sistem açılırken bu dosya mutlaka çalıştırılır. Takas alanı açılır, dosya
            sisteminde hata olması halinde bunu gidermeye çalışır. Bazı kontrollerden
            sonra kontrolü diğer rc programlarına bırakır.
            </para></listitem>
          </varlistentry>
        </variablelist>
      </para>
    </sect2>
  </sect1>
  <sect1 id="archive-tlkg-lis-5.10">
    <title>Çekirdek Mesajları</title>
    <para>
      Çekirdek, hafızaya yüklenip çalıştırıldıktan sonra kendisi ve sistemdeki
      donanım hakkındaki her türlü bilgiyi ekrana yazar. Her türlü bilginin
      içine hata mesajları da girer. Çekirdeğin hata verip vermemesi açılış
      anında ekrana bakmakla anlaşılabilir. Bu nedenle sistem açılırken
      gözünüzü monitörden ayırmamalısınız. Aşağıda bir çekirdeğin açılış kaydı
      yeralıyor:
    </para><para>
<screen>
Console: colour EGA+ 80x25, 1 virtual console (max 63)
bios32_init : BIOS32 Service Directory structure at 0x000faf10
bios32_init : BIOS32 Service Directory entry at 0xfb390
pcibios_init : PCI BIOS revision 2.10 entry at 0xfb3c0
Calibrating delay loop.. ok - 30.22 BogoMips
Serial driver version 4.11 with no serial options enabled
tty00 at 0x03f8 (irq = 4) is a 16550A
tty01 at 0x02f8 (irq = 3) is a 16550A
lp1 at 0x0378, using polling driver
ftape: allocated 3 buffers aligned at: 00210000
hda: QUANTUM ELS170A, 162MB w/32KB Cache, CHS=1011/15/22, MaxMult=8
ide0: primary interface on irq 14
Floppy drive(s): fd0 is 1.44M
FDC 0 is a post-1991 82077
lance.c: PCI bios is present, checking for devices...
Memory: 6612k/8192k available (760k kernel code, 384k reserved, 436k data)
This processor honours the WP bit even when in supervisor  mode. Good.
Swansea University Computer Society NET3.019
Swansea University Computer Society TCP/IP for NET3.019
IP Protocols: ICMP, UDP, TCP
PPP: version 0.2.7 (4 channels) NEW_TTY_DRIVERS OPTIMIZE_FLAGS
TCP compression code copyright 1989 Regents of the University of California
PPP line discipline registered.
SLIP: version 0.8.3-NET3.019-NEWTTY (4 channels) (6 bit encapsulation enabled)
CSLIP: code copyright 1989 Regents of the University of California
eth0: D-Link DE-600 pocket adapter: at I/O 0x378.
Checking 386/387 coupling... Ok, fpu using exception 16 error reporting.
Checking 'hlt' instruction... Ok.
Linux version 1.2.13 (root@bigkitty) (gcc version 2.7.0) #1 Wed Aug 23 01:06:43 CDT 1995
Partition check:
  hda: multiple mode turned off
  hda: hda1 hda2
VFS: Mounted root (ext2 filesystem) readonly.
Adding Swap: 8188k swap-space
</screen>
    </para><para>
      Yukarıdaki mesajda swap alanı belirlenmesi, sabit diskin tanınması,
      disketin tanınması, aygıt sürücülerinin, ethernet kartını tanıması ve
      ekranın özelliklerinin yazılması gibi bilgiler vardır. Bu bilgilere
      sistem açıldıktan sonra <literal>/var/adm/messages</literal> dosyasıından da
      erişilebilir.
    </para>
  </sect1>
  <sect1 id="archive-tlkg-lis-5.11">
    <title>Linux Dosya Sistemi Yapısı</title>
    <para>
      Bu bölümde Linux'un kullandığı dosya sistemi hakkında bilgi verilecektir.
      Dosya sistemini oluşturan dizinler, kapsadıkları dosyalar ve bunların
      Linux işletim sistemindeki görevleri de kısaca belirtilecektir.
    </para><para>
      Bir işletim sisteminin dosya sisteminin performansı, hızı ve buna
      benzer çeşitli özellikleri sistemin verimli ve kararlı çalışması
      üzerinde doğrudan etkisi vardır. Linux dizin yapısının
      geliştirilmesinde <emphasis>FSSTND</emphasis> (file system standard) grubunun
      çalışmalarının payı çok büyük oldu. Programcılardan oluşan grup,
      standartların belirlenmesinde ve uygulama aşamasında Linux ile
      ilgilenenlere yardım etti. 1993 yılında Olaf Kirsh, Linux haber grubuna
      yazdığı bir e-postasında Linux dosya sistemi üzerindeki çalışmaların
      tamamlandığını haber verdi.
    </para><para>
      Linux dizin yapısında bazı dizinlerin işlevi birbiriyle aynıdır. Bu durum,
      özellikle birbirini takip eden iki Linux sürümünde belirginleşir. Örnek
      olarak bir dağıtımda <literal>/usr/bin</literal> dizini altında yeralan dosya,
      diğer sürümde <literal>/bin</literal> altına yerleştirilebiyor.
    </para><para>
      Dosya sistemleri ve dizinler paylaşımlı olarak da kullanılabilir.
      Birden fazla kişisel bilgisayarın bağlandığı ağda, disk alanından yer
      kazanmak için bir makina <emphasis>sunucu</emphasis> (ana makina) olarak tayin edilir. Ağ
      üzerindeki diğer makinalar da sunucu üzerindeki diski paylaşır. Buna
      örnek olarak kullanıcı ev dizinlerinin yeraldığı <literal>/home</literal>,
      çalıştırılabilir dosyaların bulunduğu <literal>/usr</literal>, e-posta ve haber
      grubu bilgilerinin bulunduğu <literal>/var/spool/mail</literal> ve
      <literal>/var/spool/news</literal> dizinleri verilebilir.
    </para><para>
      Kök dizini, kendisine bağlı diğer tüm dizinleri de içerdiğinden, Linux
      dosya sisteminde önemli bir yere sahiptir. Linux açılırken önce kök
      dizini <literal>/etc/fstab</literal> dosyasına uygun şekilde bağlanır. Diğer dosya
      sistemlerinin onarımı ve kontrolü için gerekli olan <literal>fsck</literal> programları, bu
      dizinde bulunmalıdır. Benzer şekilde yedekleme için gerekli olan <literal>tar, zip,
      compress</literal> gibi arşiv programlarına da kök dizin altından erişilebilmeli,
      açılış esnasında hafızaya yüklenen çekirdek de kök dizininde yeralmalıdır.
    </para><para>
      Bir programı yerine koymadan önce bazı "dengelerin" gözönünde tutulmasında
      yarar vardır. Programlanan her yazılımı kök dizinine koyarsanız, bir süre
      sonra bu dosya sisteminin şiştiğini görürsünüz. Kök dizinini başlangıçta
      küçük (20-30Mb kadar) tutmak, geliştirilen programları daha önceden
      belirlenen başka bir dosya sistemi altına koymak akıllıca olur. Bu yol,
      ağ üzerinden genellikle paylaşımı mümkün olmayan kök dizininin her
      makinadaki sabit diskte mümkün olan en az yer işgal etmesini sağlar.
    </para><para>
      Sistemdeki önemli dizinlere göz atarsak,
    </para><para>
      <variablelist>
        <varlistentry>
          <term>/bin</term><listitem><para>
            Sistemin açılışı ve kontrolü için gerekli komutlar. Hem
            kullanıcıların, hem de sistem görevlisinin kullanabileceği
            dosyalar (kök dizinde ise fazla şişmemesi koşuluyla) buraya
            atılabilir. Sadece root kullanıcının ihtiyaç duyacağı init,
            getty, updatedb gibi programlar /sbin veya /usr/sbin'de
            durabilir. Bu dizinde bulunan dosyalara örnek olarak cat,
            chgrp, chown, date, dd, df, ln, mkdir, mount, ps, rm, sh,
            su, sync ve umount verilebilir.
          </para></listitem>
        </varlistentry>
        <varlistentry>
          <term>/dev</term><listitem><para>
            G/Ç dosyaları. Linux çekirdeğinde desteklenen her aygıta ait dosya /dev dizini altında bulunur. Kurulum anında bu dosyalar yerine
            yerleştirilir, bu dosyaların silinmesi durumunda /dev/MAKEDEV ile tekrar
            yaratılabilirler.
          </para></listitem>
        </varlistentry>
        <varlistentry>
          <term>/etc</term><listitem><para>
            Sistem yapılandırma dosyaları. Bu dizinde çalıştırılabilir
            dosyalar bulunmamalıdır.
          </para><para>
            <variablelist>
              <varlistentry>
                <term>skel</term><listitem><para>
                  Buradaki dosyalar, kullanıcı hesabı açıldığında kullanıcının ev
                  dizinine kopyalanır.
                </para></listitem>
              </varlistentry>
              <varlistentry>
                <term>rc.d</term><listitem><para>
                  Bu dizinin içinde, init sürecinin başvurduğu yapılandırma
                  dosyaları vardır. Bunlara "rc dosysları" da denir.
                </para></listitem>
              </varlistentry>
              <varlistentry>
                <term>passwd</term><listitem><para>
                  Kullanıcı veritabanı
                </para></listitem>
              </varlistentry>
              <varlistentry>
                <term>fstab</term><listitem><para>
                  Linux'un açılışı esnasında bindirilecek dosya sistemleri burada
                  listelenir.
                </para></listitem>
              </varlistentry>
              <varlistentry>
                <term>group</term><listitem><para>
                  passwd'e benzer şekilde kullanıcıların gruplarını tutar.
                </para></listitem>
              </varlistentry>
              <varlistentry>
                <term>inittab</term><listitem><para>
                  init daemon için yapılandırma dosyası
                </para></listitem>
              </varlistentry>
              <varlistentry>
                <term>motd</term><listitem><para>
                  Kullanıcı sisteme girdikten sonra ekranına basılması istenen mesaj
                  burada tutulur.
                </para></listitem>
              </varlistentry>
              <varlistentry>
                <term>profile</term><listitem><para>
                  Kullanıcı sisteme girdiği zaman çalıştırılan dosya (csh ve sh
                  türevi kabuklar için)
                </para></listitem>
              </varlistentry>
              <varlistentry>
                <term>shells</term><listitem><para>
                  Sistemde kullanılabilecek kabuk isimleri burada tutulur.
                </para></listitem>
              </varlistentry>
              <varlistentry>
                <term>login.access</term><listitem><para>
                  login komutu için yapılandırma dosyası. Sisteme girişi
                  kullanıcı bazında sınırlamak için kullanılir.
                </para></listitem>
              </varlistentry>
            </variablelist>
          </para></listitem>
        </varlistentry>
        <varlistentry>
          <term>/home</term><listitem><para>
            Kullanıcılara ayrılmış dizin. Başka şekilde ayarlanmamış ise,
            açılan her hesaba ait kullanıcı, burayı kullanır. Büyük sistemlerde,
            bu kısım alt parçalara ayrılabilir (/home/ftpadm , /home/ogrenci gibi)
          </para></listitem>
        </varlistentry>
        <varlistentry>
          <term>/lib</term><listitem><para>
            Kütüphane dosyaları.
          </para></listitem>
        </varlistentry>
        <varlistentry>
          <term>/mnt</term><listitem><para>
            Geçici mount edilen dosya sistemleri. Sadece bu iş için
            kullanıldığından sistem görevlisine zaman kazandırır.
          </para></listitem>
        </varlistentry>
        <varlistentry>
          <term>/proc</term><listitem><para>
            Süreç kontrollerini ve diğer sistem bilgilerini tutan dosya sistemi.
            Bu dosya sistemi aslında disk üzerinde yer kaplamaz, tüm dosyalar
            çekirdeğin bir uzantısı sayılabilir.
          </para><para>
            <variablelist>
              <varlistentry>
                <term>cpuinfo</term><listitem><para>
                  işlemci modeli, tipi ve performansını bildirir.
                </para></listitem>
              </varlistentry>
              <varlistentry>
                <term>devices</term><listitem><para>
                  Halihazırda çalışan çekirdek içinde desteği bulunan aygıt
                  sürücülerini listeler.
                </para></listitem>
              </varlistentry>
              <varlistentry>
                <term>dma</term><listitem><para>
                  Hangi dma kanallarının kullanıldığını belirtir.
                </para></listitem>
              </varlistentry>
              <varlistentry>
                <term>filesystems</term><listitem><para>
                  Halihazırda çalışan çekirdek içinde desteği bulunan dosya
                  sistemlerini listeler.
                </para></listitem>
              </varlistentry>
              <varlistentry>
                <term>interrupts</term><listitem><para>
                  Hangi kesintilerin kullanımda olduğunu söyler.
                </para></listitem>
              </varlistentry>
              <varlistentry>
                <term>iports</term><listitem><para>
                  Halen hangi giriş/çıkış iskelelerinin kullanıldığını belirtir.
                </para></listitem>
              </varlistentry>
              <varlistentry>
                <term>kcore</term><listitem><para>
                  Sistem hafızasının görüntüsü
                </para></listitem>
              </varlistentry>
            </variablelist>
          </para></listitem>
        </varlistentry>
        <varlistentry>
          <term>/root</term><listitem><para>
            Sistem görevlisinin ev dizini. Mümkünse bu dizini sistemdeki diğer
            kullanıcıların görmeyeceği şekilde ayarlayın.
          </para></listitem>
        </varlistentry>
        <varlistentry>
          <term>/sbin</term><listitem><para>
            Hayati sistem komutları. Bir zamanlar bu dosyalar /etc dizini
            altında yeralıyorlardı. Sadece sistem görevlisinin ihtiyacı olan komutlar,
            /sbin veya /usr/sbin içinde bulunur.
          </para></listitem>
        </varlistentry>
        <varlistentry>
          <term>/tmp</term><listitem><para>
            Geçici dosyaların koyulduğu dizin. Belirli zaman aralıklarında
            temizlenmelidir.
          </para></listitem>
        </varlistentry>
        <varlistentry>
          <term>/usr</term><listitem><para>
            Diğer önemli sistem dosyalarını tutar. Bu bölüm genelde en kalabalık
            dizindir, zira yeni kurulan tüm programlar buraya konulur.
          </para><para>
            <variablelist>
              <varlistentry>
                <term>X11R6</term><listitem><para>
                  X Pencere sistemi bilgileri tutulur.
                </para></listitem>
              </varlistentry>
              <varlistentry>
                <term>doc</term><listitem><para>
                  Belge ve dökümanlar, genellikle HOWTO ve FAQ dosyaları.
                </para></listitem>
              </varlistentry>
              <varlistentry>
                <term>lib</term><listitem><para>
                  Bazı kütüphaneler
                </para></listitem>
              </varlistentry>
              <varlistentry>
                <term>man</term><listitem><para>
                  Man dosyaları
                </para></listitem>
              </varlistentry>
              <varlistentry>
                <term>src</term><listitem><para>
                  Bazı kaynak dosyaları ve linux çekirdeğini oluşturan kodları
                  (/usr/src/linux) içeren dizin.
                </para></listitem>
              </varlistentry>
              <varlistentry>
                <term>sbin</term><listitem><para>
                  Kök dosya sisteminde yeralması gerekmeyen çalıştırılabilir sistem
                  görevlisi dosyaları
                </para></listitem>
              </varlistentry>
            </variablelist>
          </para></listitem>
        </varlistentry>
        <varlistentry>
          <term>/var</term><listitem><para>
            Sürekli değişen sistem bilgileri burada tutulur. İstisnalar dışında
            diğer makinalarla paylaştırılmaz.
          </para></listitem>
        </varlistentry>
        <varlistentry>
          <term>adm</term><listitem><para>
            Sistem yönetimini ilgilendiren kayıtlar
          </para></listitem>
        </varlistentry>
        <varlistentry>
          <term>preserve</term><listitem><para>
            Sistemin göçmesinden sonra zarar görmesi mümkün dosyaların
            kaydedildiği yer.
          </para></listitem>
        </varlistentry>
        <varlistentry>
          <term>spool</term><listitem><para>
            Sonra işlenecek olan veriler buraya atılır (e-posta gibi)
          </para></listitem>
        </varlistentry>
      </variablelist>
    </para><para>
      Eğer sistem yöneticisi iseniz düzenli olarak dosya ve dizin yapısını
      kontrol etmelisiniz. Örneğinn <literal>/tmp</literal> dizini normal kullanıcıların
      kullanımına açık olduğu için çok kısa bir sürede dolabilir. Burayı
      periyodik olarak silmek için find komutu işe yarayabilir:
    </para><para>
<screen>
# find /tmp -atime +7 -exec rm -rf  {} \;
</screen>
    </para><para>
      Yukarıdaki komut, <literal>tmp</literal> dizini altında yeralan tüm dosyaları kontrol
      edecek ve 7 günden daha eski dosyaları silecektir. Benzer şekilde,
      kullanıcıların dosyalarının yer aldığı <literal>/home</literal> dizini de çok kısa bir
      sürede dolmaya mahkumdur. Sistemde ne kadar büyük sabit disk olursa
      olsun bir gün gelecek burası dolacaktır. Periyodik olarak buraya da
      göz gezdirmek gerekir. Aşağıda yeralan kısa program, <literal>/home</literal> dizininde
      yeralan kullanıcı dizinlerideki disk kullanımını büyükten küçüğe doğru
      <literal>disk</literal> isimli dosyaya yollayacaktır. Bu dosyanın incelenmesiyle hangi
      kullanıcıları "cezalandıracağınızı" görebilirsiniz :)
    </para><para>
<screen>
# du -skx /home/* | sort -rn &gt; disk
</screen>
    </para><para>
      <literal>du</literal> (disk usage), sistem kullanıcılarının sıkça başvurduğu bir
      komuttur. Kullanılabilecek parametreler için <emphasis>du(1)</emphasis> man sayfasına bakın.
    </para><para>
      UNIX, (ve dolayısıyla Linux) iki tip aygıt tanır. Bunlardan ilki karakter
      aygıtları, başka bir deyişle veri alışverişini bayt bazında yapan
      cihazlar, diğeri de blok aygıtları, yani veri alışverişini blok cinsinden
      yapan cihazlardır. Karakter aygıtlarına örnek olarak seri bağlanan
      cihazlar ve teypler, disk aygıtlarına örnek olarak da diskler verilebilir.
      Bu cihazlardan bir bilgi yazılıp okunduğunda dosya sistemi altında bunları
      tanımlayan dosyalar (<literal>/dev/*</literal>) kullanılmış olur.
      Örnek olarak bir yazıcıya bilgi göndermek için,
    </para><para>
<screen>
$ cat dosya &gt; /dev/lp1
</screen>
    </para><para>
      komutunu kullanabilirsiniz. Dosya, yazıcının anlayabileceği bir yapıda
      olmalıdır (örneğin düz metin).
    </para><para>
      Her aygıt, bir dosya olarak dosya sisteminde kendine yer bulduğuna göre
      hangi aygıt dosyalarının bulunduğunu görmek mümkün olabilir.
    </para><para>
<screen>
$ ls -l /dev/cua0
crw-rw-rw- 1 root uucp 5, 64 Nov 30 1993 /dev/cua0
</screen>
    </para><para>
      İlk kolondaki ilk karakter (c), bu dosyanın bir karakter aygıtına ait
      olduğunu belirtiyor. Normal dosyalar için buradaki karakter '-' olmalıydı.
      Benzer şekilde blok aygıtlar için ise 'b' kullanılr.
    </para><para>
      Aygıt sürücü desteği çekirdekte olmasa bile <literal>/dev</literal> dizini
      altında genellikle tüm aygıt dosyaları bulunur. Bu demektir ki
      <literal>/dev/sda</literal> dosyasına sahip olduğunuz halde bir SCSI sabit
      diski sistemde takılı olmayabilir. Tüm aygıt sürücülerinin bulunması,
      programların kurulumunu ve yeni donanımın eklenmesini kolaylaştırır.
    </para>
  </sect1>
  <sect1 id="archive-tlkg-lis-5.12">
    <title>Konsolda Türkçe Yazmak</title>
    <para>
      (Türkçe desteği için <link linkend="turkish-howto">Türkçe NASIL</link>
      belgesine bakınız.)
    </para><para>
      Linux sanal terminallerinde bir tuşa basıldığı zaman bilgisayarın
      ekranda herhangi bir dildeki alfabeye ait harfi göstermesi kolayca
      sağlanabilir. Bunun yanında 12 fonksiyon tuşunun herbirine belirli bir
      dizisel değer atanabilir ve bu sayede bu tuşlara basıldığında bir komutun
      veya programın çalışması mümkün olur.
    </para><para>
      Aslında bunları yapabilmek için önümüzdeki iki temel sorunu aşmamız
      gerekiyor. Birincisi standart olmayan karakterlerin (örneğin Türkçe)
      ekranda görüntülenebilmesi, ikincisi de bilgisayara standart dışı bir
      klavye olduğunun belirtilmesidir.
    </para><para>
      Dünya üzerindeki belli başlı dillerin hepsi yıllar önce bir standart
      geliştirilmesi amacıyla sınıflandırıldı. Avrupa'da Slav dilleri
      hariç hemen tüm dillerin karakterleri ISO (Uluslararası Standartlar
      Organizasyonu) tarafından tek bir sınıfa yerleştirildi ve buna ISO8859-1
      (latin 1) dendi. O vakit izlenen yanlış politikalar nedeniyle Türkçe bu
      sınıfa dahil edilmedi ve sadece Türkçe için ISO8859-9 (latin 5) isminde
      ayrı bir sınıf açıldı.
    </para><para>
      Türkçe yazabilme sorununu hemen her işletim sisteminde hissediyor
      olmalısınız. Linux altında Türkçe desteğini sağlamak için birkaç işlem
      yapılmalıdır. Bu işlemlerin başında Linux'a Türkçe destekli klavye ve
      font tanıtmak geliyor.
    </para><para>
      <literal>/usr/lib/kbd/keytables</literal> dizini altında yeralan dosyalar, çeşitli ülke
      dillerine ait klavye dağılımını içeriyor. Buradaki bilgileri kullanarak
      klavye üzerinde yeralan tuşlara basılması halinde yazılı tuş dışında
      bir karakterin ekranda gösterimi sağlanabilir.
    </para><para>
      Sistem açıldığı zaman -eğer kurulum aşamasında bir font beğenip
      sürekli onu kullanmıyorsanız- <literal>defkeymap.map</literal> dosyasında yeralan klavye
      dağılımını kullanacaktır. Farklı bir klavye düzeni kullanmak için .map
      dosyalarını yüzeysel olarak anlamanız gerekiyor. <literal>/usr/lib/kbd/keytables</literal>
      dizini altındaki herhangi bir dosyada 300'den fazla satır ve üç ana
      tanımlamayla karşılaşacaksınız. Birinci grup, "keycode", "alt", "control"
      gibi bir satırla, ikinci grup "string" ile, üçüncü grup ise "compose"
      kelimesiyle başlar.
    </para><para>
      Dosyanın yapısını daha iyi kavrayabilmek için üzerinde bir örnekle
      açıklamaya çalışalım. Control-Alt-Del tuşlarına basılınca bilgisayar
      kendini "reset"ler. Eğer yanlışlıkla bu üç tuşa basmışsanız, klavyeden
      girilecek bir <literal>shutdown -c</literal> komutunu yazmak ve sistemi kapanmaktan
      kurtarmak için sadece 3-4 saniyeniz vardır. Fakat <literal>shutdown -c</literal> komutunu
      bir fonksiyon tuşuna bağlar ve bu tuşa basarsanız sistem eski haline
      dönecektir. Örnek olarak Control-F1 tuşunu bu işe ayıralım.
    </para><para>
      Öncelikle <literal>/usr/lib/kbd/keytables</literal> dosyasında yeralan <literal>defkeymap.map</literal>
      dosyasındaki F1 fonksiyon tuşunun hangi tuş tanımına denk geldiğini
      bulmalıyız. Dosyadaki F1 ile ilgili satırlar şunlardır:
    </para><para>
<screen>
keycode  59 = F1               F13              Console_13
        control keycode  59 = F25
        shift   control keycode  59 = F37
        alt     keycode  59 = Console_1
        control alt     keycode  59 = Console_1
</screen>
    </para><para>
      Linux, her satıra bir numara atar. Yukarıdaki satırda, F1 tuşunun
      numarasının 59 olduğu kolayca görülüyor. 59 numaralı tuşa basılınca,
      F1 ile tanımlanan dizi ekrana yazılacaktır. Benzer şekilde F1'e control
      ile birlikte basılması halinde ise F25 dizisini ekrana basar. Önceden
      tanımlanan değerlerden <emphasis>Console_1</emphasis>, 1 numaralı sanal konsolun ekranda
      gösterilmesini işaret eder. Tüm bu dizilerin içeriğini görebiliriz. Aynı
      dosyanın sonlarında şu satır yeralıyor:
    </para><para>
<screen>
string F1 = &quot;\033[[A&quot;
</screen>
    </para><para>
      Bunun anlamı,  F1'e basınca  <literal>ESC[[A</literal> dizisini ekrana gönder demektir.
      sayısı, Escape tuşunun oktal (sekizli) sistemde gösterimidir.
    </para><para>
      Bu satırı veya F1'den itibaren seçeceğimiz bir fonksiyon tuşu ismini
      istediğimiz şekilde değiştirebiliriz. Yanlız dikkat etmemiz gereken
      bir husus, bu tuşun başka uygulamalar tarafından kullanılabiliyor
      olmasıdır. Örnek olarak F61 ve karşılık gelen dizi değeri dosyada
      yeralmıyor. Dosyaya küçük bir ekleme yapalım:
    </para><para>
<screen>
string F61 = &quot;shutdown -c\n&quot;
</screen>
    </para><para>
      Dosyayı farklı bir isimde (örneğin <literal>bas.map</literal>) kaydedip
      çıkın. Yeni klavye dağılımını denemek için
    </para><para>
<screen>
# loadkeys bas.map
</screen>
    </para><para>
      komutunu kullanın. Artık yeni klavye standardı sisteme
      yerleşmiştir. Sistemin çalıştığına emin olmak için Shift-Control-F1
      tuşuna basın. <literal>shutdown -c</literal> komutu işletilmelidir.
    </para><para>
      Artık Türkçe yazabilmeye geldik. Bunun için standart dışı klavyeden gelen bir
      Türkçe karakteri ekranda gösterebilmek amacıyla bir font dosyası oluşturmamız
      gerekecek. Linux altında bu dosyalar <literal>/usr/lib/kbd/consolefonts</literal>
      dizini altında yeralıyor.
    </para><para>
      Linux'ta standart dışı bir font yüklemek için <literal>setfont</literal> komutu
      kullanılır. Türkçe fontları,
      <ulink url="ftp://ftp.linux.org.tr">Linux Kullanıcıları Grubu ftp arşivinden</ulink> temin edebilir veya iso09 ön adlı herhangi bir
      fontu kullanabilirsiniz. Aşağıdaki komut, 8 piksel eni, 16 piksel boyu
      olan Türkçe font yükleyecektir.
    </para><para>
<screen>
setfont tr8x16.map
</screen>
    </para><para>
      Türkce klavye düzenlerini içeren dosyaları ftp ile yine aynı
      adresten alabilirsiniz. Burada <literal>tr.map</literal> ve <literal>trq.map</literal> adlı iki dosya
      bulacaksınız. Bunlardan <literal>tr.map</literal>, normal klavye düzeninin yanında `alt'
      tuşları ile "c, g, i, s, o, u" tuşlarına basıldığında karşılık gelen
      özel Türkçe karakterler görüntülenir. <literal>trq.map</literal> yaygın olarak kullanılmakta
      olan Q-Türkçe klavye düzenini içerir.
    </para><para>
      Bash kabuğu altında Türkçe yazabilmek için aşağıdaki üç komutu <literal>.inputrc</literal>
      dosyanıza eklemeniz gerekir.
    </para><para>
<screen>
set meta-flag on
set output-meta on
set convert-meta off
</screen>
    </para><para>
      <literal>less</literal> komutununu Türkçe karakterleri göstermesi için de
      aşağıdaki gibi LESSCHARSET değişkenini latin5 yapmak gerekiyor.
    </para><para>
<screen>
LESSCHARSET=latin5
</screen>
    </para><para>
      <literal>loadkeys</literal> ve <literal>setfont</literal> komutlarını sistem
      açılırken aktif olmaları için
      bunları <literal>/etc/rc.d/rc.local</literal> dosyasına yerleştirebilirsiniz. Fontu ve
      klavye düzenini ayarladıktan sonra sistemde çıkın ve tekrar girin.
    </para><para>
      Artık Türkçe yazabilirsiniz.
    </para>
  </sect1>
  <sect1 id="archive-tlkg-lis-5.13">
    <title>Belirli Zamanlarda Komut İşletilmesi</title>
    <para>
      crontab dosyası yardımıyla sistem üzerinde olmadığınız zamanlarda
      Linux'tan bazı belirli işleri yapmasını istemek mümkündür. Örneğin
      gereksiz trafik sıkışıklığı yaratamak için akşam geç saatlerde sistemi
      yedeklemek için evden İnternet'e bağlanmak yerine crontab ile bu işlemi
      otomatikleştirmek mümkün olur.
    </para><para>
      Bir crontab dosyasında toplam 6 alan bulunur. Bunlardan ilk beşi
      komutun ne zaman işleneceğini gösterirken son kısımda bu saatler içinde
      çalıştırılacak olan komutu gösterir. Zamanı belirten sütunlardan ilki
      dakikayı (0 ile 59 arası), ikincisi saati (0 ile 23 arası), üçüncüsü
      günü (1-31 arası), dördüncüsü ayı (1-12 arası), son kısım ise haftanın
      gününü (0 pazarı göstermek üzere 0-6 arası) verir. Yine crontab'ın güzel
      özelliklerinden birisi de bu alanların her birisinde zaman aralıklarını
      yazmaya izin vermesidir. Mesela haftanın üçüncü ve beşinci günleri arası,
      saat 4 ve 9 arası gibi. Eğer bir zaman alanına * girilirse, bunun anlamı
      "her zaman" olur. Örneğin saat yerine * konulması "her saat", ay yerine *
      konulması "her ay" anlamına gelecektir.
    </para><para>
      Önce aşağıda yeralan küçük bir crontab dosyası incelenecek, ardından crontab
      işlemine nasıl başlanılacağı kısaca anlatılacaktır.
    </para><para>
<screen>
40 06 * * * updatedb
</screen>
    </para><para>
      Yukarıdaki örnekte birinci ve ikinci sayılar 06:40 saatini
      gösteriyor. Diğer zaman kısımları * ile doldurulmuş olduklarından her
      gün 06:40'ta <literal>updatedb</literal> isimli program çalışacaktır.
    </para><para>
      Komut yerine kullanılacak olan program ismi parametre alabilir. Bu
      örnekteki crontab dosyası pazartesi günleri saat 1'de, <literal>/tmp</literal> dizinindeki
      üç günden daha eski dosyaları siler.
    </para><para>
<screen>
0 1 * * mon find /tmp -atime 3 -exec rm -f {} \;
</screen>
    </para><para>
      Bu örnekte kullanılan virgül, her ayın 9, 19 ve 29'unu gösterir. Aynı
      alanda birden fazla sayı kullanacaksanız arada boşluk bırakmamaya
      dikkat edin.
    </para><para>
<screen>
0 1 9,19,29 * * find /tmp -atime 3 -exec rm -rf {} \;
</screen>
    </para><para>
      Ay isimlerinde <emphasis>ocak, şubat, mart, nisan, mayıs, haziran, temmuz,
      ağustos, eylül, ekim, kasım, aralık</emphasis> için sırasıyla <emphasis>january, february,
      march, april, may, june, july, august, september, october, november,
      december</emphasis> kullanabilirsiniz. Benzer şekilde <emphasis>pazar, pazartesi, salı,
      çarşamba, perşembe, cuma, cumartesi</emphasis> ve <emphasis>pazar yerine sunday, monday,
      tuesday, wednesday, thursday, friday ve saturday</emphasis> kullanın. Aşağıdaki
      crontab girdisi yardımıyla iki ayda bir çalıştırılan komutla önce teyp
      başa alınıyor, ardından <literal>/home</literal> dizini bu teybe yedekleniyor:
    </para><para>
<screen>
0 2 1 */2 * mt -f /dev/rft0 rewind; tar -cf /dev/rft0 /home
</screen>
    </para><para>
      */2 ile belirtilen zaman dilimini ikiye bölebilirsiniz. 2 yerine uygun
      herhangi bir tamsayı yazılabilir.
    </para><para>
      Bu girdileri bir crontab dosyasına nasıl yazacağız? Bunun için root
      kullanıcısı olarak girin ve aşağıdaki satırları yazın:
    </para><para>
<screen>
# crontab -e
</screen>
    </para><para>
      Ekrana bilgisayar ilk kurulduğu anda ön tanımlı olarak girilen crontab
      satırları gelecektir. Buraya yukarıda belirtilen yapıda istediğiniz
      kadar crontab girdisi yapabilirsiniz. Eğer daha önceden <emphasis>VISUAL</emphasis> çevresel
      değişkenini uygun bir editöre ayarlamamışsanız, vi altında çalışmanız
      gerekecektir. Başka bir editörle çalışabilmek için bu değişkeni,
      editörün patikasını gösterecek şekilde değiştirin. İleride de kısaca
      bahsedilecek olan tin (haber grubu okuyucu yazılımı) de VISUAL değişkenine
      göre metin editörünün patikasını ayarlayacaktır.
    </para><para>
<screen>
# export VISUAL=/usr/bin/pico
</screen>
    </para><para>
      Crontab dosyasının normal olarak işletilmesinden crond sorumludur. Sistem
      açılırken <literal>/etc/rc.d</literal> dizini içindeki dosyalardan bir tanesi crond
      programını çalıştırır ve bu andan itibaren <literal>crontab -e</literal> komutuyla
      yarattığınız dosyadaki emirler zamanı geldikçe yerine getirilir.
    </para>
  </sect1>
</chapter>

<chapter id="archive-tlkg-lis-6">
  <title>Bash Kabuğu</title>
  <sect1 id="archive-tlkg-lis-6g">
    <title>Giriş</title>
    <para>
      UNIX için geliştirilen en önemli ve en çok kullanılan kabukların başında
      <emphasis>tcsh</emphasis>, <emphasis>bash</emphasis> (Bourne Again Shell) ve <emphasis>ksh</emphasis> (Korn Shell)
      gelir. Bash, Bourne Shell'in biraz daha geliştirilmiş sürümüdür. Tcsh
      ise C-shell üzerine eklenen yeniliklerle genişletilmiştir. Unix altında,
      bash kabuğu diğer benzerlerine nazaran daha fazla özelliğe ve işleve
      sahiptir. Linux işletim sistemi için de derlenen bash ise hem tcsh,
      hem de ksh'dan özellikler taşır.
    </para><para>
      Bir Slackware dağıtımında tüm bu kabuklar kullanıcının hizmetine sunulmuş
      olup bash kabuğu sistem ilk açıldığında tanımlıdır. Kullanıcı sisteme
      girdiği zaman bu kabuk aktif olur, bundan sonra kullanıcı herhangi bir
      kabuk altında çalışmalarına devam edebilir. Bunun için sadece ismini
      komut satırında yazması yeterlidir.
    </para>
  </sect1>
  <sect1 id="archive-tlkg-lis-6.1">
    <title>Bash'in Özellikleri</title>
    <para>
      Bash'in kullanıcıya zaman kazandıran en önemli özelliklerinden birisi
      de dosya isimlerini tamamlamasıdır. Komut satırında tamamlanmamış
      bir komut veya dosya ismi yazdıktan sonra TAB tuşuna basılırsa satır
      tamamlanacaktır. Eğer komut satırındaki karakter kümesiyle başlayan
      birden fazla komut varsa bir sinyal sesi duyulacak ve sizden yeteri
      kadar karakteri yazmanızı bekleyecektir.
    </para><para>
<screen>
$ ls
postgres        mandel.doc      lilo-howto
$ vi post &lt;TAB&gt;
$ vi postgres
</screen>
    </para><para>
      Komut satırındaki karakterler dosyayı veya komutu tanıtmaya yetmiyorsa,
      &lt;TAB&gt; tuşunun iki kez ard arda basılmasıyla ekrana mümkün olan
      tüm dosya isimleri getirilebilir.
    </para><para>
<screen>
$ ta &lt;TAB&gt; &lt;TAB&gt;
tac   tail  talk  tar
$ talk
</screen>
    </para><para>
      Bash, komut satırında iken satırın kolayca değiştirilebilmesini
      sağlar. Böylece komut çalıştırılmadan önce birkaç tuş darbesiyle
      üzerinde değişiklik yapılabilir. Klavye üzerindeki alt ve üst yön
      tuşları, daha önce yazdığınız komutları görmenizi ve arasında seçim
      yapmanızı sağlar. Sağ ve sol yön tuşları ile seçtiğiniz komutun üzerinde
      değişiklikleri uygulabilirsiniz.
    </para>
  </sect1>
  <sect1 id="archive-tlkg-lis-6.2">
    <title>Takma Adlar (alias)</title>
    <para>
      <literal>alias</literal> komutu ile bir komut veya komut kümesinin yerine bir isim
      tahsis edilebilir. İşleyişi bir makroya benzeyen bu komut yardımıyla uzun
      komutlar, daha kısa komutlarla tanımlanabilir. Bir <literal>alias</literal> komutu ,
      anahtar kelimeyle başlar, ardından bir eşittir (=) işareti ve yerine
      kullanılacağı komut yazılır. Arada boşluk bırakılmaz.
    </para><para>
<screen>
$ alias dir='ls -al'
$ dir
total 668
-rw-r--r--   1 gorkem   users        1016 Dec  7 13:51 .profile
-rw-r--r--   1 gorkem   users         277 Nov 26 13:02 .signature
drwxr-xr-x   4 gorkem   users        1024 Dec  3 18:24 .tin/
drwxr-xr-x   2 gorkem   users        1024 Nov 12 10:58 .wine/
-rw-r--r--   1 gorkem   users         231 Nov 23 17:40 .xinitrc
drwxr-xr-x   2 gorkem   users        1024 Oct  3 16:17 Mail/
-rw-r--r--   1 gorkem   users        26721 Dec  3 14:55 NIS-HOWTO
drwxr-xr-x   2 gorkem   users        1024 Nov 17 14:09 News/
</screen>
    </para><para>
      Daha karmaşık alias 'lar da tanımlanabilir:
    </para><para>
<screen>
$ alias yedek=&quot;cd /var/log; tar -zcvf yedek.tgz cron debug lastlog; cd -&quot;
</screen>
    </para>
  </sect1>
  <sect1 id="archive-tlkg-lis-6.3">
    <title>Özel Kabuk Tanımları</title>
    <para>
      Bazı özellikleriyle bash, benzeri kabuklar arasından kolayca sıyrılır.
      Bunlardan birisi de tanımlardır. Tanımlamalar set komutu yardımıyla yapılır,
      tüm tanımlar küçük harflerle yazılırlar, bu özellikleri yardımıyla
      değişkenlerden ayrılırlar.
    </para><para>
<screen>
$ set -o tanim          # tanimi isletir
$ set +o tanim          # tanimi kaldirir
</screen>
    </para><para>
      Aşağıda en çok kullanılan iki tanım yeralmaktadır:
    </para><para>
      <command>noclobber</command>: Bu tanımın seçilir kılınmasından sonra bir
      komutun çıktısı bir dosyaya gönderildiğinde, dosyanın eski içeriği aynı
      kalır. Bu tanım sayesinde kazara bir dosyanın üzerine başka bilgilerin
      yazılması önlenebilir.
    </para><para>
<screen>
$ ls -al dosya
-rw-r--r--   1 gorkem   users        1409 Nov 29 13:58 dosya
$ set -o noclobber
$ ls &gt; dosya
bash: dosya: Cannot clobber existing file
</screen>
    </para><para>
      <command>ignoreeof</command>: ignoreeof, kabuktan
      <emphasis>control-d</emphasis> tuş takımı ile çıkılmasını engeller.
      Yanlışlıkla basılan <emphasis>control-d</emphasis> ile sistemden
      anından çıkmak mümkün olduğu için kullanışlı bir tanımdır.
    </para><para>
<screen>
$ set -o ignoreeof
$ (control-d 'ye basin)
Use &quot;logout&quot; to leave the shell.
$ set +o ignoreeof
$ (control-d 'ye basin, sistemden hemen cikar)
$ ignoreeof=4
</screen>
    </para><para>
      Yukarıdaki son örnekte 4 kere control-d tuşuna basılırsa kabuktan çıkılır.
    </para>
  </sect1>
  <sect1 id="archive-tlkg-lis-6.4">
    <title>Özel Kabuk Değişkenleri</title>
    <para>
      Sisteme girdiğiniz zaman Linux size bir kabuk tahsis eder ve kabuk üzerinde
      değişkenler tanımlayabilmenize izin verir. Kabuk içinde bir kabuk betiği
      (script) çalıştırılınca sistem tarafından bir alt kabuk daha yaratılır.
      Bu andan itibaren iki kabuk çalışır, birisi sisteme girdiğiniz anda tahsis
      edilen, diğeri de programın çalıştırılabilmesi için sistem tarafından
      çağırılan. Program bittiği anda alt kabuğun işlevi sona erer ve sistem
      tarafından öldürülür.
    </para><para>
      Bir kabuk altında tanımlanan değişken o kabuğa özgüdür. Bir kabuk altında
      erişilebilen değişkene diğer bir kabuk erişemez. Fakat bash kabuğu altında
      bir çevre değişkeni yaratılırsa, sistem tarafından her alt kabuğa bu çevre
      değişkeni kopyalanır. Böylece bir değişken yaratılır, ama her alt kabuk
      tarafından kullanılabilir. bash kabuğunda yaratılan çevre değişkenlerinin
      normal değişkenlerden tek farkı, bu değişkenin diğer alt kabuklar tarafından
      tanınmasıdır.
    </para><para>
      Bir çevre değişkeni belirtmek için <literal>export</literal> komutu kullanılır.
      Aşağıdaki örnekte <emphasis>dosyam</emphasis> isimli çevre değişkeni
      tanımlanıyor.
    </para><para>
<screen>
$ export dosyam=&quot;internet.97.txt&quot;
$ echo $dosyam
internet.97.txt
</screen>
    </para><para>
      Bu esnadan sonra tüm kabuklar altında bu değişken tanımlı olacaktır.
    </para><para>
      <literal>env</literal> komutu yardımıyla sistemde öntanımı yapılan veya
      sonradan tanımlanan tüm değişkenler ekrana listelenir.
    </para><para>
<screen>
$ env
HOME=/home/gorkem
SHELL=/bin/bash
LS_OPTIONS=--8bit --color=tty -F -b -T 0
PS1=\h:\w\$
PS2=&gt;
LOGNAME=gorkem
OSTYPE=Linux
</screen>
    </para><para>
      Sisteme girdiğiniz anda tanımlanan bazı komutlar ve açıklamaları aşağıda
      verilmiştir:
    </para><para>
      <command>HISTFILE</command>: Tüm yazdığınız komutlar
      <literal>.bash_history</literal> adlı bir dosya içinde tutulur. Her
      kullanıcının kendi ev dizinleri içinde kullanıcıya özgü bu dosyadan
      vardır. <literal>$HISTFILE</literal> değişkeni ile dosyanın ismi
      değiştirilebilir.
    </para><para>
<screen>
$ echo $HISTFILE
/home/gorkem/.bash_history
$ HISTFILE=&quot;komutlar&quot;
$ echo $HISTFILE
komutlar
</screen>
    </para><para>
      <command>PATH</command>: PATH değişkeninde bir komut yazıldığı anda sistem tarafından
      aranacak olan patika listesi görüntülenir. Örnek olarak <literal>who</literal> komutu
      <literal>/usr/bin/</literal> dizini altındadır ve bu bilgi PATH değişkeninde saklı
      tutulur. Kullanıcının yaptığı programları çalıştırabilmesi için PATH
      değişkeninde bulunduğu dizini de tanımlaması gerekir.
    </para><para>
      PATH değişkeninde her dizin iki nokta üstüste işareti ile birbirinden
      ayrılır. Örnek olarak <literal>/usr/local/bin:/usr/bin</literal> dizisi sırasıyla
      <literal>/usr/local/bin</literal> ve <literal>/usr/bin</literal> patikalarına karşılık gelir.
    </para><para>
      Kullanıcı PATH değişkenine yeni girdiler ekleyebilir. Aşağıdaki örnekte
      bunun nasıl uygulandığı görülüyor. Kullanıcı kısaca PATH değişkeninin
      sonuna kendisinin istediği patikayı veya patikaları ekler.
    </para><para>
<screen>
$ echo $PATH                    # PATH degiskenini ekrana bas
$ export PATH=$PATH:/usr/net    # buna /usr/net patikasini ekle
</screen>
    </para><para>
      <command>SHELL</command>: O an kullanılan kabuğun patika ismini verir.
      Kabuk programları genellikle <literal>/bin</literal> dizini altında
      tutulurlar. Her kabuğun patika ismi sistemdeki
      <literal>/etc/shells</literal> dosyasında bulunmalıdır.
    </para><para>
<screen>
$ echo $SHELL
/bin/bash
</screen>
    </para><para>
      <command>HOME</command>: Kullanıcının ev dizinini gösteren patikayı
      ekrana basar. Her kullanıcının ev dizini, sistemde hesap açılırken
      sistem görevlisi tarafından belirlenir. Linux Slackware dağıtımı
      altında bu dizin öntanımlı olarak <literal>/home</literal> 'dur.
      Aşağıdaki örnek kullanıcının ev dizinine ait patikayı ekrana basıyor.
    </para><para>
<screen>
$ echo $HOME
/home/gorkem
</screen>
    </para><para>
      <command>LOGNAME</command>: Sistemdeki kullanıcı hesabınının ismini tutar.
      Her kullanıcı için farklı bir değerde olur.
    </para><para>
<screen>
$ echo $LOGNAME
gorkem
</screen>
    </para><para>
      <command>TERM</command>: Kullanıcının halen üzerinde çalıştığı terminal
      tipini görüntüler. <literal>vi</literal> ve <literal>pico</literal>
      gibi editörler çalıştırıldıkları anda TERM çevresel değişkenine bakarlar.
      Bu sayede ekran ile ilgili bilgileri önceden düzenleyebilirler.
      Aşağıdaki komut önce halihazırdaki TERM değişkenini görüntülüyor, ardından
      değişkene başka bir değer atıyor.
    </para><para>
<screen>
$ echo $TERM
linux
$ export TERM=vt100
$ echo $TERM
vt100
</screen>
    </para><para>
      <command>PS1 ve PS2</command>: Ekranda komut satırının başına gelecek olan
      karakterleri belirlerler. Komut isteminin en başındaki yazı bu iki değişken
      yardımıyla değiştirilebilir. PS1, birinci satırın karakterlerini tutarken
      satıra sığmayan komutlar bir satır aşağı geçeceklerinden ikinci satırın
      karakterlerini de PS2 belirler. Aşağıdaki satır, bu iki değişkenin
      öntanımlı olan "$" işaretini bir kelimeyle değiştiriyorlar.
    </para><para>
<screen>
$ export PS1='-&gt; '
-&gt; export PS2='&gt;'
-&gt;
</screen>
    </para><para>
      Önceden tanımlanan kodlar yardımıyla komut satırı değiştirilebilir.
      Her kodun başında \ karakteri vardır. Bu kodların herbiri örneğin o
      anki saati, makinanın ismini veya bulunduğunuz dizini ekrana yazabilirler.
      Örneğin \h ve \w kodları sırasıyla çalışılan makinanın ismini ve çalışma
      dizinini gösterirler. Bu örnekte PS1 değişkeni bu iki kod yardımıyla
      değiştiriliyor.
    </para><para>
<screen>
$ export PS1='\h:\w\$ '
linux:~$                        # yeni komut satiri goruntusu
linux:~$ cd /tmp
linux:/tmp$                     # calisma dizinini de gosteriyor
</screen>
    </para><para>
      Aşağıda, sıkça kullanılan kodların bir listesi görülüyor.
    </para><para>
      <itemizedlist>
        <listitem><command>\t</command>, saat </listitem>
        <listitem><command>\d</command>, tarih</listitem>
        <listitem><command>\s</command>, kabuk ismi</listitem>
        <listitem><command>\w</command>, çalışma dizini</listitem>
        <listitem><command>\u</command>, kullanıcı ismi</listitem>
        <listitem><command>\h</command>, makina ismi</listitem>
      </itemizedlist>
    </para>
  </sect1>
  <sect1 id="archive-tlkg-lis-6.5">
    <title>Sisteme Giriş Dosyaları</title>
    <para>
      Sisteme girerken her giriş anında çalıştırılan birtakım dosyalar bulunur.
      Bash kabuğu ile doğrudan ilgili olan giriş dosyaları arasında
    </para><para>
<screen>
/etc/profile
~/.bash_profile
~/.bash_login
~/.profile
~/.bashrc
</screen>
    </para><para>
      sayılabilir. Kullanıcı bu dosyaların kendine ait olanlarını dilediği
      gibi değiştirebilir. Sisteme girerken tanımlamak istediği değişkenleri
      tanımlar, çalıştıracaği programları yazar. <literal>/etc/profile</literal>
      dosyasını tüm kullanıcılar ortak kullanır. Her kullanıcı sisteme
      girdiğinde sistem tarafından bu dosya çalıştırılır. Bu dosyada
      kullanıcıların ihtiyacına yönelik özel sistem değişkenleri bulunur, ek
      olarak birtakım kontrol ve kayıt işlemleri yapılır.
    </para><para>
      Örnek bir <literal>/etc/profile</literal> dosyası şekildeki gibidir.
    </para><para>
<screen>
if [ &quot;$TERM&quot; = &quot;&quot; -o &quot;$TERM&quot; = &quot;unknown&quot; ]; then
 TERM=linux
fi
#PS1='`hostname`:`pwd`# '
if [ &quot;$SHELL&quot; = &quot;/bin/pdksh&quot; -o &quot;$SHELL&quot; = &quot;/bin/ksh&quot; ]; then
 PS1=&quot;! $ &quot;
elif [ &quot;$SHELL&quot; = &quot;/bin/zsh&quot; ]; then
 PS1=&quot;%m:%~%# &quot;
elif [ &quot;$SHELL&quot; = &quot;/bin/ash&quot; ]; then
 PS1=&quot;$ &quot;
else
 PS1='\h:\w\$ '
fi
PS2='&gt; '
ignoreeof=2
export PATH DISPLAY LESS TERM PS1 PS2 ignoreeof
umask 022
# set up the color-ls environment variables:
if [ &quot;$SHELL&quot; = &quot;/bin/zsh&quot; ]; then
  eval `dircolors -z`
elif [ &quot;$SHELL&quot; = &quot;/bin/ash&quot; ]; then
  eval `dircolors -s`
else
  eval `dircolors -b`
fi
</screen>
    </para><para>
      <literal>.bashrc</literal> dosyası, her bash kabuğu veya alt kabuk
      çalıştırıldığı anda okunur. Her kabuk programı çalıştırılınca bir
      alt kabuğa ihtiyaç olduğundan bu durumda <literal>.bashrc</literal>
      dosyası da okunacak ve içerdiği değişkenler proram çalışmadan önce
      tanımlanacaktır.

      Sistemden çıkarken varsa çalıştırılan dosyanın ismi
      <literal>.bash_logout</literal>'tur. Bu dosya ile kullanıcı sistemi
      terkederken fazladan işlemler yapabilir. Aşağıdaki örnekteki
      <literal>.bash_logout</literal> dosyasında kullanıcı sistemden her
      çıktığında ekran temizlenecek ve en üste 'Hoscakal' yazacaktır.
    </para><para>
<screen>
clear
echo &quot;Hoscakal!&quot;
</screen>
    </para>
  </sect1>
  <sect1 id="archive-tlkg-lis-6.6">
    <title>Kabuk Programlamaya Giriş</title>
    <para>
      Her kabuğun kendine özgü programlama dili yapısı vardır. Bash kabuğu
      ise güçlü programlama özellikleriyle karmaşık programların rahatça
      yazılmasına izin verir. Mantıksal operatörler, döngüler, değişkenler
      ve modern programlama dillerinde bulunan pek çok özellik bash kabuğunda
      da vardır ve işleyiş tarzları da hemen hemen aynıdır.
    </para><para>
      Genellikle, bir programı oluşturacak olan komutlar bir dosyaya yazılırlar
      ve ardından bu dosya çalıştırılır. Herhangi bir editör yardımıyla yazılan
      program, daha sonra kabuk altında çalıştırılır. Bir kabuk programı
      diğerlerini çalıştırabilir. Bu düzende kabuk programlarını daha karmaşık
      komutların biraraya gelmiş ve büyümüş haline benzetebiliriz.
    </para>
    <sect2>
      <title>Kabuk Programları</title>
      <para>
        Kabuk programları, bir veya birden fazla linux komutunu tutan dosyalardır.
        Bu dosya yaratıldıktan sonra doğrudan dosyanın ismi girilerek veya
        dosya isminden önce '.' karakteri getirerek çalıştırılabilir. Bir
        kabuk programı, çalıştırma bitini 1 yapmak suretiyle "çalıştırılabilir"
        hale getirilir. <literal>chmod</literal> komutu yardımıyla bir programı
        çalıştırılabilir yapmak için,
      </para><para>
<screen>
$ chmod +x komut-ismi
</screen>
      </para><para>
        yazılabilir. Bundan sonra programın ismi yazılıp enter tuşuna basıldığı
        zaman bir program Linux komutuymuş gibi çalışacaktır.
      </para><para>
<screen>
$ cat calistir
echo -n &quot;Tarih : &quot;
date
$ chmod +x calistir
$ calistir
Tarih : Sun Dec  8 07:11:51 EET 1996
</screen>
      </para><para>
        Yukarıdaki örnekte "calistir" isimli iki satırlık bir kabuk programının
        önce içeriği ekrana yazıldı, ardından çalıştırılacak duruma getirildi
        ve çalıştırıldı.
      </para><para>
        Kabuk programları yazarken dosyanın işlevini ve her satırdaki komutun
        veya komut kümesinin ne amaçla kullanıldığını gösteren açıklama satırları
        kullanmak işe yarar. Bir açıklama eklemek için satır başına (veya boş
        satıra) <literal>#</literal> işareti eklenir ve ardından istenilen
        cümle girilir. <literal>#</literal> işaretinden sonraki tüm satır
        kabuk tarafından gözardı edilir. Aşağıdaki programda komut öncesinde
        yeralan açıklama satırı, komut hakkında bilgi veriyor.
      </para><para>
<screen>
# gunzip komutu dosya acmak icin kullanilir.
gunzip sistem.gz
</screen>
      </para><para>
        Yorum satırı, komutun sonuna da eklenebilir.
      </para><para>
<screen>
ps -aux         # sistem surecleri hakkinda ayrintili bilgi..
</screen>
      </para><para>
        Bir kabuk altında çalışırken başka bir kabuk için yazılmış bir
        programı çalıştırmak mümkündür. Örneğin tcsh altındasınız ve daha
        evvel bash kullanarak yazdığınız bir programı çalıştırmak istiyorsunuz.
        Önce bash yazarak kabuk değiştirmeli, ardından programı çalıştırmalı,
        ve tekrar tcsh'a dönmelisiniz. Tüm bunları otomatik olarak
        yaptırabilirsiniz. Programın en başına <literal>#</literal>!
        karakterini, ardından programın çalışacağı kabuğun patikasını
        yazın. Örneğin <literal>#!/bin/bash</literal> komutunu programın
        en üstüne eklerseniz bu program bash kabuğu altında çalışacaktır.
      </para>
    </sect2><sect2>
      <title>Değişkenlerin Kullanımı</title>
      <para>
        Bir değişkene değer atandığı anda sistem tarafından tanınır.
        Değişkenler alfabetik veya sayısal karakterlerden oluşabilirler
        fakat bir değişken sayısal bir değer ile başlayamaz. Bunların
        dışında değişken isminin içinde "_" karakteri de bulunabilir.
        Bir değişkene değer ataması "=" işareti yardımıyla yapılır.
      </para><para>
<screen>
$ mesaj=&quot;aksama yemege geliyorum&quot;
</screen>
      </para><para>
        İçeriği olan bir değişkene başına "$" işareti konularak ulaşılır.
        Aşağıda, <literal>echo</literal> komutu yardımıyla bir değişkenin
        içeriği ekrana basılıyor.
      </para><para>
<screen>
$ echo $mesaj
aksama yemege geliyorum
$ echo yarin $mesaj
yarin aksama yemege geliyorum
</screen>
      </para><para>
        Aynı mesajı değişken kullanmadan da görüntüleyebiliriz.
      </para><para>
<screen>
$ echo &quot;Aksama yemege geliyorum&quot;
Aksama yemege geliyorum
</screen>
      </para>
    </sect2><sect2>
      <title>Giriş/Çıkış İşlemleri</title>
      <para>
        Bir kabuk programı çalışırken kullanıcıdan klavye yardımıyla bilgi
        girmesi sağlanabilir. Bu tür işlemler için tanımlanan
        <literal>read</literal> komutu klavyeyi okur ve aldığı bilgiyi
        bir değişkene atar. Aşağıdaki komutları içeren program yardımıyla
        klavyeden okunan değer ekrana yazılıyor. <literal>echo</literal>
        komutundan sonra birden fazla değişken grubu veya hem değişken,
        hem de dizi kullanılabilir.
      </para><para>
<screen>
echo Bir sayi giriniz..
read sayi
echo Girilen sayi : $sayi
</screen>
      </para><para>
        Bazı durumlarda girilen değer özel karakterleri içerebilir. Bu durumda
        istenmeyen bazı sonuçların doğması kaçınılmaz olur. Aşağıdaki örneği
        bir dosya içine yazın ve dosyayı çalıştırdıktan sonra "*" tuşuna basın.
      </para><para>
<screen>
echo Bir karakter giriniz
read a
echo Girdiginiz karakter: $a
</screen>
      </para>
    </sect2><sect2>
      <title>Aritmetik İşlemler</title>
      <para>
        bash kabuğunda matematiksel işlemlere büyük sınırlamalar getirilmiştir.
        Tamsayı değişkeni dışında matematiksel değişken kullanmak için bu işlemler
        için geliştirilmiş ve kolaylıklar sağlayan awk veya bc kullanabilirsiniz.
      </para><para>
        Aritmetik işlemler için <literal>eval</literal> komutunu veya bash kabuğu
        altında yerleşik (builtin) komut olan <literal>let</literal> komutunu
        kullanabilirsiniz. Aşağıda let komutunun kullanımı görülüyor.
      </para><para>
<screen>
let &quot;degisken=aritmetik islem&quot;
</screen>
      </para><para>
        Bu örnekte iki sayı çarpılıp çıkan sonuç başka bir değişkene yazılıyor.
      </para><para>
<screen>
$ let &quot;carpim=2*7&quot;
$ echo $carpim
</screen>
      </para><para>
        Aritmetik değişken tanımlamanın diğer bir yolu da <literal>typeset</literal>
        komutu kullanmaktır.
      </para><para>
<screen>
$ typeset -i sonuc      (sonuc degiskeni bir dogal sayi icerecek)
$ a=100 ; b=56          (iki komutu ayirmak icin ; kullanilabilir)
$ sonuc=a*b
$ echo $sonuc
5600
</screen>
      </para>
    </sect2><sect2>
      <title>if-else Kalıbı ve Kontrol İşlemleri</title>
      <para>
        Hemen her programlama dilinde olan <literal>if</literal> kalıbı bir
        Linux komutunun çalışmasını kontrol (<literal>test</literal>) eder.
        <literal>if</literal> komutu yerleşik bir komuttur ve her
        <literal>if</literal>, bir <literal>fi</literal> komutuyla bitmelidir.
        <literal>if</literal> komutunun ardından gelen Linux komutu çalıştırılır
        ve komutun çıkış durumu (exit status) gözönüne alınarak ardından gelen
        <literal>then</literal> deyimiyle birlikte devamı işletilir. Genellikle
        komutun iki türlü çıkış durumu olacağından <literal>else</literal>
        komutunun ardından gelen komut zinciri, diğer çıkış durumunda çalıştırılır.
        Aşağıda if-else-then komutunun örnek sözdizimi görülüyor.
      </para><para>
<screen>
if linux komutu
    then
        komut1
        komut2
        ...
    else
        komut1
        komut2
        ...
fi
</screen>
      </para><para>
        <literal>if</literal> komutu genellikle kendine <literal>test</literal>
        komutu ile birlikte kullanım bulur. Bu komut yardımıyla mantıksal
        işlemler yapılabilir, sayılar ve hatta diziler karşılaştırılabilir.
        Anahtar sözcük olan <literal>test</literal>'ten sonra seçenekler
        ve/veya karşılaştırılacak olan değerler yazılır. Her seçenek bir
        mantıksal işleme karşılık gelir. Örneğin <literal>-lt</literal>
        seçeneği ilk girilen aritmetik değişkenin ikinci değerden küçük
        olup olmadığını denetler. Benzer şekilde <literal>=</literal>
        seçeneği da iki karakter kümesinin eşitliğini kontrol eder.
        Aşağıda <literal>test</literal> komutunun örnek kullanımı yeralıyor.
      </para><para>
<screen>
$ test 5 -eq 3
$ a=&quot;linux&quot;
$ test $a=&quot;linux&quot;
</screen>
      </para><para>
        komutun işletilmesinin ardından kabuğa bir değer dönderilir.
        Bu değer komut başarılı olarak işletilmişse 0, değilse 1'dir.
        Son çalıştırılan tüm Linux komutlarının çıkış değeri $? değişkeninde
        tutulur. test komutunun çıkış değeri de bu yolla öğrenilebilir.
      </para><para>
<screen>
$ sayi=4
$ test $sayi -eq 4
$ echo $?
0
$ test $sayi -lt 2
$ echo $?
1
</screen>
      </para><para>
        <literal>test</literal> komutu yerine parantezler de kullanılabilir.
        Yukarıdaki iki örnek, parantez kullanılarak şu şekilde yazılabilir:
      </para><para>
<screen>
$ [ $sayi -eq 4 ]
$ [ $sayi -lt 12 ]
</screen>
      </para><para>
        Dikkat edilmesi gereken bir nokta, köşeli parantez kullanırken araya
        boşlukların eklenmesidir. Parantezler başlı başına bir komut olarak
        görüldüklerinden sağında ve solunda en az bir boşluk bırakılmalıdır.
        <literal>test</literal> komutunda sıkça kullanılan diğer seçenekler
        şunlardır:
      </para><para>
        Aritmetik karşılaştırmalar
      </para><para>
<literallayout>
<command>-gt</command>  büyük
<command>-lt</command>  küçük
<command>-ge</command>  büyük eşit
<command>-le</command>  küçük eşit
<command>-eq</command>  eşit
<command>-ne</command>  eşit değil
</literallayout>
      </para><para>
        Dizisel karşılaştırma
      </para><para>
<literallayout>
<command>-z</command>  boş dizi
<command>-n</command>  tanımlı dizi
<command>= </command>  eşit diziler
<command>!=</command>  farklı diziler
</literallayout>
      </para><para>
        Dosya karşılaştırması
      </para><para>
<literallayout>
<command>-f</command>  dosya var
<command>-s</command>  dosya boş değil
<command>-r</command>  dosya okunabilir
<command>-w</command>  dosyaya yazılabilir
<command>-x</command>  çalıştırılabilir dosya
<command>-h</command>  sembolik bağlantı
<command>-c</command>  karakter aygıt
<command>-b</command>  blok aygıt
</literallayout>
      </para><para>
        Mantıksal karşılaştırmalar
      </para><para>
<literallayout>
<command>-a</command>  VE
<command>-o</command>  VEYA
<command>! </command>  DEĞİL
</literallayout>
      </para><para>
        <literal>if</literal> komutunun <literal>test</literal> ile birlikte
        kullanılabildiğini daha önce belirtmiştik. Aşağıda bununla ilgili
        küçük bir örnek yeralıyor.
      </para><para>
<screen>
#!/bin/bash
echo &quot;0 ile 20 arasinda bir sayi secin&quot;
read sec
if [ $sec -lt 10 ]
   then
        echo &quot;Secilen sayi tek basamakli&quot;
   else
        echo &quot;Secilen sayi cift basamakli&quot;
fi
</screen>
      </para><para>
        Her <literal>if</literal> komutu bir <literal>fi</literal> ile son bulmalıdır.
      </para>
    </sect2><sect2>
      <title>case Kalıbı</title>
      <para>
Birkaç alternatif arasından seçim yapmak için kullanılan bir komut
olan <literal>case</literal>, bir eşleştirme gördüğü anda belirli
bir komut kümesini işleme sokar. case yapısı <literal>case</literal>
komutu ile başlar, eşleştirilecek olan anahtar sözcük yazılır ve
seçenekler alt alta, her seçeneğe ait olan komutlarla birlikte
belirtilir. Tüm yapı <literal>esac</literal> komutu ile son bulur.
      </para><para>
<screen>
case anahtar-sozcuk in
        secenek1)
                komutlar
                ;;
        secenek2)
                komutlar
                ;;
        *)
                komutlar
                ;;
esac
</screen>
      </para><para>
        Seçenekler arasında özel karakterler <emphasis>(*, [] , ? gibi)</emphasis>
        kullanılabilir. Hiçbir eşleme yapılmadığı zaman *) seçeneği değerlendirilecek
        ve buna bağlı olan komutlar işletilecektir. * kullanımı isteğe bağlıdır.
        Aşağıda <literal>case</literal> komutuna ilişkin kısa bir örnek veriliyor.
      </para><para>
<screen>
#!/bin/bash

clear
echo    &quot;1. ekrani temizle&quot;
echo    &quot;2. sistemdekileri goruntule&quot;
echo    &quot;3. dizindeki dosyalari goster&quot;

echo -n &quot;Secenegi giriniz : &quot;
read secenek

case $secenek in
        1)
          clear
          ;;
        2)
          w
          ;;
        3)
          ls -al
          ;;
        *)
          echo Hatali secenek
esac
</screen>
      </para>
    </sect2>
  </sect1>
  <sect1 id="archive-tlkg-lis-6.7">
    <title>Döngüler</title>
    <para>
      Diğer hemen tüm programlama dillerinin en büyük gücü olan döngü
      işlemlerine kabuk altında da izin veriliyor. Burada programcı
      tarafından en çok kullanılan 2 döngü tipi anlatılacaktır:
      <literal>while</literal> ve <literal>for</literal>.
    </para><para>
      <literal>while</literal> komutu her döngüde bir denetleme mekanizmasını
      harekete geçirirken <literal>for</literal> döngüsü daha değişik bir
      mantıkla çalışır.
    </para>
    <sect2>
      <title>while-do Döngüsü</title>
      <para>
        Döngü bloğu <literal>while</literal> anahtar kelimesiyle başlar,
        ardından gelen koşul sağlandığı sürece döngü işletilir. Önce koşulun
        sağlanıp sağlanmadığına bakılır. Döngüden çıkabilmek için mutlaka
        döngü içindeki koşul ifadesinin değerini yanlış yapacak bir durum
        oluşmalıdır, aksi halde sonsuz döngü oluşur.
      </para><para>
<screen>
while kosul ifadesi
   do
        komutlar
   done
</screen>
      </para><para>
        <literal>if</literal> komutuyla birlikte kullanılan
        <literal>test</literal> komutu, <literal>while</literal> döngüsünde
        koşul ifadesi olarak da yer alabilir. Aşağıda 1'den 100'e kadar
        sayan ve ekrana basan bir döngü görülüyor.
      </para><para>
<screen>
#!/bin/bash
deger=0
while [ $deger -lt 100 ]
   do
        deger=$((deger+1))
        echo $deger
   done
</screen>
      </para><para>
        Yukarıda kullanılan (( ve )) karakterleri arasına matematiksel bir işlem
        getirilebilir. Bu özellik bash kabuğuna özgüdür.
      </para>
    </sect2><sect2>
      <title>for-do döngüsü</title>
      <para>
        Bir liste dahilindeki tüm değerlere sırayla erişimi sağlar. for
        komutundan sonra yeralan liste sırayla kullanılır ve herbirisi için
        döngü çalıştırılır. Listenin sonuna gelindiğinde ise döngüden çıkılır.
      </para><para>
<screen>
for degisken1 in deger1 deger2 ... degerX
   do
        komutlar
   done
</screen>
      </para><para>
        Aşağıdaki örnek bu döngüyü kullanarak ekrana bir dizi kelime yazıyor.
        Döngü boyunca akasya, elma ve visne kelimeleri "agac" değişkenine
        kopyalanıyor ve her döngüde bu değişkenin içerdiği bilgiler ekrana
        yazılıyor.
      </para><para>
<screen>
for agac in akasya elma visne
   do
        echo $agac
   done
</screen>
      </para><para>
        for-do döngüsü, dosya isimleri üzerinde yapılan işlemlerde de büyük
        kolaylıklar sağlar. Bunun için özel karakterlerden yararlanmak da
        olasıdır. Örnek olarak * karakteri o anki çalışma dizini içindeki
        tüm dosyaları seçer.
      </para><para>
<screen>
for a in *.pl ; do
        file $a
        done
</screen>
      </para>
    </sect2>
  </sect1>
  <sect1 id="archive-tlkg-lis-6.8">
    <title>Örnek Kabuk Programı</title>
    <para>
      Sistem görevlisinin en çok kullandığım komutlardan birisi
      <literal>ps -aux | grep -i xxx</literal> komutudur. Bu satır
      yardımıyla çalışan <emphasis>xxx</emphasis> isimli program
      hakkında daha ayrıntılı bilgi elde edilebilir.
      <literal>ps</literal> komutu ayrıntılı bir süreç listesini
      ekrana verirken çıktı doğrudan grep komutuna yönlendirilir ve
      sadece istediğimiz bilgi monitörde görünür. Fakat her zaman aynı
      uzun satırı tekrar tekrar yazmaktansa bu satırı bir dosyaya gönderip,
      dosya adını komut satırından çalıştırmak zamandan tasarruf sağlayacaktır.
      Biz de öyle yapalım ve aşağıdaki satırları "p" isimli dosyaya yazalım.
    </para><para>
<screen>
#!/bin/bash
if [ $# = 1 ]
  then
  ps -ax | grep -i $1
else
  ps -ax
fi
</screen>
    </para><para>
      Ardından dosyayı PATH değişkeninin işaret ettiği dizinlerden
      <literal>/usr/local/bin</literal> altına yerleştirip çalıştırılabilir
      olması için <literal>chmod +x /usr/local/bin/p</literal> komutunu
      uygulayın. Kendi yazdığınız dosyaları <literal>/usr/local</literal>
      veya <literal>~/bin</literal> dizini altına kopyalamanız bunların derli
      toplu olarak tek bir dizinde her an erişilebilir şekilde durmaları
      açısından önem taşır.
    </para><para>
      <literal>grep</literal> komutu, bir dosyadaki veya standart girişteki
      satırlar içinden belirli bir kelime, harf veya harf grubunu bulmaya yarar.
      Aşağıdaki birkaç örnek <literal>grep</literal>'i özetlemeye yeter.
    </para><para>
<screen>
$ grep while sort.c
sort.c dosyasinda while kelimesini iceren tum satirlari ekrana yazar.
$ w | grep demir
sistemde demir isimli kullanici var mi?
$ ls -al | grep &quot;^d&quot;
</screen>
    </para><para>
      Son örnek, <literal>ls -al</literal> çıktısında satır başında ``d''
      varsa ekrana getirir. Sadece dizin isimlerinin başında ``d'' harfi
      bulunur. Şapka isareti, satır başlangıcını gösterir.
    </para><para>
      Dosyaya biraz daha yakından bakalım. İlk satır, bu dosyanın
      <literal>/bin/bash</literal> programı tarafından çalıştırılacağını gösterir.
      İkinci satır yardımıyla komut satırı üzerinde kaç tane seçenek olduğu
      bulunur. $# çevresel değişkeni her biri TAB veya boşluk karakteri ile ayrılmış
      komut satırı seçeneklerinin sayısını verir. Aşağıdaki komutta toplam 3
      seçenek vardır.
    </para><para>
<screen>
$ ls --8bit  -F -b
</screen>
    </para><para>
      <literal>$#</literal> komutuna benzer şekilde $1, $2, $3...
      değişkenleri de seçenekleri verir. Yukarıdaki komutta $1, $2, $2
      değişkenleri sırasıyla
    </para><para>
<screen>
--8bit
-F
-b
</screen>
    </para><para>
      değerlerini alırlar. Komut satırından çalıştırılan komut ise $0
      değişkenine atılır. Yukarıdaki örnekte $0 değişkeni
      <literal>ls</literal> değerini tutacaktır.
    </para><para>
      <literal>p</literal> dosyasına tek seçenek yollayacağız. Bu seçenek de
      hakkında ayrıntılı bilgi alacağımız süreç olacaktır. Dosya içinde
      $1 değişkenini <literal>ps</literal> komutuna yerleştirmek için:
    </para><para>
<screen>
ps -ax | grep -i $1;
</screen>
    </para><para>
      yazılır. Bundan sonra komut satırında, örneğin:
    </para><para>
<screen>
$ p bash
</screen>
    </para><para>
      girilirse $1 değişkeni <literal>bash</literal> e eşit olacak ve bu da
      <literal>ps -ax | grep -i bash</literal> eşdeğer komutunu çalıştıracaktır.
      Komut olarak sadece <literal>p</literal> girilirse $# değişkeni 0'a
      eşit olacağından dosyada yeralan ve hiç bir filtreleme yapmayan
      <literal>ps -ax</literal> komutu çalışır.
    </para><para>
      Linux'u yüklerken <emphasis>HOWTO</emphasis> dökümanlarını da eklemeyi
      ihmal etmediniz, değil mi? Aşağıdaki kısa program, bu dosyalara en hızlı
      şekilde ulaşmanıza yarıyor. Tüm HOWTO'lar kurulum aşamasında
      <literal>/usr/doc/faq/howto</literal> dizini altına kopyalanır ve sıkıştırılır.
    </para><para>
      Bu programı herhangi bir isimle kaydedin. Ardından komut satırından
      programın ismi ile birlikte ekranda görüntülemek istediğiniz
      <emphasis>HOWTO</emphasis> dökümanının ismini yazın (örneğin PPP).
      Bir parametre girilmez ise <literal>/usr/doc/faq/howto</literal>
      dizinindeki dosyalar ekrana gelir.
    </para><para>
<screen>
#!/bin/bash
if [ &quot;$1&quot; = &quot;&quot; ]; then
    ls /usr/doc/faq/howto | less
else
    gunzip -c /usr/doc/faq/howto/$1-HOWTO.gz | less
fi
</screen>
    </para>
  </sect1>
</chapter>

<chapter id="archive-tlkg-lis-7">
  <title>Sed ve Vi</title>
  <sect1 id="archive-tlkg-lis-7.1">
    <title>SED (Stream editor)</title>
    <para>
      Metin dosyaları üzerinde sürekli işlem yapanlar için <emphasis>sed</emphasis> ve
      <emphasis>vi</emphasis> hemen imdada yetişir. Bu iki programın yapabildiklerini
      etkileşimli olarak bir metin editörü üzerinden gerçekleştirebilmek de
      mümkündür. <emphasis>sed</emphasis> ve <emphasis>vi</emphasis> tam anlamıyla zaman kaybını önleyen kullanıcı
      dostu iki uygulamadır. Yapısal olarak diğer programlama dillerinden
      biraz farklı olduklarından öğrenmesi biraz zaman alır. Buna rağmen eğer
      metin editörlüğü işinizin bir parçası ise <emphasis>sed</emphasis> ve <emphasis>vi</emphasis>'ı öğrenip
      bunlardan verimli bir şekilde yararlanmanız uygun olacaktır.
    </para>
    <sect2>
      <title>Sed ve Özellikleri</title>
      <para>
        Sed bir dosyadan veya standart girdiden(klavyeden) bilgi okur ve
        standart çıktıya (ekrana) okuduğu bilgileri kullanıcının belirlediği
        düzene sokarak yazar. Bu veriyi de kullanıcı genellikle bir dosyaya
        yerleştirir.
      </para><para>
        Sed komut satırında iken veya bir kabuk programı içinden kullanılabilir.
      </para>
    </sect2><sect2>
      <title>Örnekler</title>
      <para>
Sed kullanırken en çok başvuracağınız işleç `<emphasis>s</emphasis>' işlecidir. Bir karakteri
veya karakter kümesini başka bir diziye çevirmeye yarar. Buna basit bir örnek:
      </para><para>
<screen>
sed 's/hapisane/hapishane/g' dosya
</screen>
      </para><para>
        Komutun sonundaki `<emphasis>g</emphasis>' işleci, sed'e dosyanın tamamını araştırmasını
        söyler. Eğer bunu kaldırırsanız, sed her satırın başında bulduğu ilk
        değiştirmeyi yapacak ve satırın geri kalanına dokunmayacaktır.
      </para><para>
        Aşağıdaki karakterler sed tarafından kullanılan özel karakterler
        kapsamına girer. Bu karakterlerin herbirisinin anlamı olduğundan dikkatli
        kullanılmaları gerekir.
      </para><para>
<screen>
.*[]^$\&amp;
</screen>
      </para><para>
        Yukarıdaki karakterleri gözönüne almadan yapılan aşağıdaki gibi bir
        kullanım hataya yol açar.
      </para><para>
<screen>
sed 's/[J.S. Bach]/[Bach, J.S]/' dosya
</screen>
      </para><para>
        Bunun yerine her özel karakterin başına `<emphasis>\</emphasis>' karakteri getirilerek
        özel anlamlarının yitirilmesi sağlanabilir (saklama işlemi). Yukarıda
        çalışmayan örneği yeniden düzenleyerek yazalım:
      </para><para>
<screen>
sed 's/\[J\.S\. Bach\]/[Bach, J.S ]/' dosya
</screen>
      </para><para>
        Aynı anda birden çok değiştirme yapabilmek için ise her argüman için
        <literal>-e</literal> kullanılır.
      </para><para>
<screen>
sed -e 's/computer/bilgisayar/g' -e 's/server/sunucu/g' dosya
</screen>
      </para><para>
        İçinde '/' karakteri olan bir diziyi değiştirmek için ne yapmalı? Bu,
        özel karakter sınıfına girdiği için karakterin özel anlamını yitirmesi
        sağlanır.
      </para><para>
<screen>
sed 's/\/usr\/bin/\/bin/g' dosya
</screen>
      </para>
    </sect2><sect2>
      <title>Düzenli İfadeler (Regular Expressions)</title>
      <para>
        Sed, UNIX üzerinde metin işleyen birçok program gibi düzenli ifadelerden
        yararlanır. Aşağıdaki bu duruma birkaç örnekle yer veriliyor.
        '<emphasis>^</emphasis>' karakteri satır başlangıcını gösterir. Bu komut,
      </para><para>
<screen>
sed 's/^Pts /Pazartesi/' dosya
</screen>
      </para><para>
        bir satırın başında ``Pts'' varsa bunu ``Pazartesi'' haline getirir. Dikkat
        ederseniz komut dahilinde `<emphasis>g</emphasis>' işleci kullanılmamıştır. Çünkü her satırda
        sadece bir satır başı olabilir.
      </para><para>
        $ karakteri satır sonunu belirtir. Aşağıdaki örnekte,
      </para><para>
<screen>
sed 's/ $//' dosya
</screen>
      </para><para>
        Sed komutu satır sonundaki tüm boşluk karakterlerini siler.
        Her satır sonuna ``SATIR_SONU'' karakter kümesini getirmek için
      </para><para>
<screen>
sed 's/$/SATIR_SONU/' dosya
</screen>
      </para><para>
        yazılabilir. Boş bir satırı bulmak için satır başı ve satır sonu
        belirteçleri birlikte kullanılır.
      </para><para>
<screen>
sed 's/^$/bu daha once bos bir satirdi/' dosya
</screen>
      </para><para>
        `<emphasis>.</emphasis>' (nokta) karakteri <emphasis>herhangi bir karakter</emphasis> anlamına gelir. Örneğin
        üzerinde işlem yapacağımız dosyada bütün satırlardaki ilk iki karakteri
        silmek için:
      </para><para>
<screen>
sed 's/^..//' dosya
</screen>
      </para><para>
        Köşeli parantezler birden fazla sayıda karakter içinde seçim yapar.
      </para><para>
<screen>
sed 's/[Oo]pen[Ww]in/openwin/g' dosya
</screen>
      </para><para>
        Alfabedeki iki karakterin arasındaki tüm karakterleri seçmek için köşeli
        parantezlerin içinde `<emphasis>-</emphasis>' karakteri kullanılabilir. Bu karakter, sağındaki
        ve solundaki de dahil olmak üzere aradaki tüm harfleri seçer. Örnek
        dosyadaki tüm büyük harfleri silelim.
      </para><para>
<screen>
sed 's/[A-Z]//g' dosya
</screen>
      </para><para>
        Bir karakter kümesinin dışında kalan karakterleri seçmek için ise
        `<emphasis>^</emphasis>'
        kullanılır. Örnek dosyada, rakamların ve küçük harflerin dışındaki tüm
        harfleri silmek istiyoruz.
      </para><para>
<screen>
sed 's/[^1-9a-z]//g' dosya
</screen>
      </para><para>
        '*' karakteri, <emphasis>kendisinden bir önce gelen karakterin veya küme
        içine alınmış karakter gruplarının <command>sıfır</command> veya daha fazla tekrarı</emphasis>
        anlamına gelir.
      </para><para>
<screen>
sed 's/^ *//' dosya
</screen>
      </para><para>
        komutu her satır başındaki boşluk karakterlerini
        siler. Aşağıdaki sed komutu her satırdaki son kelimeyi (boşluk
        karakterlerinden oluşmayan karakterler grubunu) siler.
      </para><para>
<screen>
sed 's/[^ ]*$//' dosya
</screen>
      </para><para>
        unutulmaması gereken bir nokta, `<emphasis>*</emphasis>' karakteri önceki grubun
        <emphasis>sıfır</emphasis> kere tekrarını da gözönüne alır, bu durumda aşağıdaki satırda
        görülen ve bir tamsayı değerini ``TAMSAYI'' sözcüğü haline getirmek için
        kullanılan komut Linux tarafından yanlış işletilecektir.
      </para><para>
<screen>
sed 's/ [0-9]* / TAMSAYI /g' dosya
</screen>
      </para><para>
        Bu satır aynı zamanda her boşluk karakterini ``TAMSAYI'' ya çevirir. Bunu
        engellemek için, en azından bir haneyi arama kapsamına sokmak gerekir:
      </para><para>
<screen>
sed 's/ [0-9][0-9]* / TAMSAYI /g' dosya
</screen>
      </para><para>
        `<emphasis>.*</emphasis> harf kombinasyonu <emphasis>herhangi bir sayıda karakter grubu</emphasis>
        anlamındadır. Aşağıdaki örnekte, ``ku'' ve ``ik'' arasında ne olursa olsun
        bulunan satırı değiştirecek ve bunların yerine ``kuru erik'' koyacaktır.
      </para><para>
<screen>
sed 's/ku.*ik/kuru erik/g' dosya
</screen>
      </para><para>
        Buraya kadarki bölümde eşleştirdiğimiz harf veya harf gruplarını ya
        başka bir forma soktuk ya da tamamen sildik. Ancak sed'in kelime işleme
        kapasitesi sadece yaptıklarımızla sınırlı değildir.  `<emphasis>\(</emphasis>'
        ve `<emphasis>\)</emphasis>' operatörleri yardımıyla eşleştirildiği anda hafızaya
        kaydedilen kelime grupları daha sonra tekrar çağırılabilir. Parantezler
        özel anlamlı karakterlerin anlamlarını yitirmesini sağlamak
        amacıyla daha önceki kullanıma uygun konulmuşlardır. İlk kullanılan
        `<emphasis>\(\)</emphasis>' operatörü `<emphasis>\1</emphasis>' adlı alana, ikinci
        kullanılan `<emphasis>\(\)</emphasis>' operatörü `<emphasis>\2</emphasis>' adlı alana
        eşleştirilir (kayıt edilir). Aşağıdaki sed komutu,
      </para><para>
<screen>
sed 's/^\([A-Za-z][A-Za-z]*\) \([A-Za-z][A-Za-z]*\)/\2 \1/' dosya
</screen>
      </para><para>
        bir dosyadaki ``isim soyisim'' sırasını ``soyisim isim'' sırasına çevirmekte
        kullanılabilir. Örnek olarak içeriği aşağıdaki gibi olan bir dosya
        üzerinde bu komut çalıştırılırsa
      </para><para>
<screen>
Mehmet Kırk
Biray Çift
Gürkan Ballı
</screen>
      </para><para>
        ekranda aşağıdaki çıktı görünür:
      </para><para>
<screen>
Kırk Mehmet
Çift Biray
Ballı Gürkan
</screen>
      </para><para>
        Bazı durumlarda tüm dosya üzerinde değil de bazı özellikleri sağlayan
        satırlar üzerinde işlem yapmak isteyebilirsiniz. Bunun için 'adresleme'
        yapmanız gerekir. Adresleme işlemi, `<emphasis>s</emphasis> işlecinden hemen önce yapılır. Bu
        komut ile dosyanın sadece 1 ve 20. satırları arasında işlem yapılacaktır.
      </para><para>
<screen>
sed '1,20s/Karadeniz/Akdeniz/g' dosya
</screen>
      </para><para>
        ``Makina'' kelimesiyle başlayan tüm satırlardaki ``Endüstri'' kelimesi yerine
        ``Elektronik'' kelimesini yerleştirelim.
      </para><para>
<screen>
sed '/^Makina/s/Maden /Elektronik /g' dosya
</screen>
      </para><para>
        ``Makina'' kelimesiyle <emphasis>başlamayan</emphasis> tüm satırlara benzer işlemi
        uygulayalım. `<emphasis>!</emphasis>' karakterinin yerine dikkat edin.
      </para><para>
<screen>
sed '/^Makina/!s/Maden /Elektronik /g' dosya
</screen>
      </para>
    </sect2><sect2>
      <title>Sed Kaynak Dosyası</title>
      <para>
Eğer sed kaynak satırınız bir iki satıra sığmayacak kadar büyük ise
komutları tek dosya altında toplayabilirsiniz. Bu örnekte <literal>degistir.sed</literal>
isimli dosyaya üç satırlık sed komutu yazalım.
      </para><para>
<screen>
s/tiren/tren/g
s/Pazar/Pazartesi/g
s/1996/1997/g
</screen>
      </para><para>
        Ardından sed komutunu <literal>-f</literal> parametresiyle çalıştıralım.
      </para><para>
<screen>
sed -f degistir.sed dosya
</screen>
      </para><para>
        Bunların yerine kendi kendine çalışan bir sed programı yazmaya ne dersiniz?
      </para><para>
<screen>
#!/usr/bin/sed -f
# degistir.sed dosyasi
s/tiren/tren/g
s/Pazar/Pazartesi/g
s/1996/1997/g
</screen>
      </para><para>
        Çalıştırmak için dosya izni verdikten sonra
      </para><para>
<screen>
chmod u+x degistir.sed
</screen>
      </para><para>
        Komut satırı üzerinden rahatlıkla çalıştırabiliriz
      </para><para>
<screen>
$ degistir.sed dosya
</screen>
      </para>
    </sect2>
  </sect1>
  <sect1 id="archive-tlkg-lis-7.2">
    <title>vi Editörü</title>
    <para>
      Bir linux sistemde her kullanıcının zevkine hitap eden çeşitli metin
      editörler vardır. Bunların arasında en çok kullanılan ve standart olan
      ed ve vi, UNIX sistemler için özel olarak tasarlanmış editörlerdir. vi
      kadar çok kullanılmasa da ed, pico ve joe da büyük bir taraftar kitlesine
      sahiptir. vi ilk başta karmaşık görünse de hızı ve verimi ile her
      kullanıcının işini büyük ölçüde kolaylaştıracak bir editördür. En çok
      kullanılan komut takımlarını öğrendikten sonra vi ile aynı dili konuşuyor
      olduğunuzu göreceksiniz.
    </para>
    <sect2>
      <title>vi'a Başlangıç</title>
      <para>
        PC editörlerin büyük çoğunluğunda klavye, editör komutlarını
        almak ve basılan tuşları ekrana göndermek için kullanılan iki
        gruba ayrılmıştır. Kullanıcı aynı anda hem komut işletip hem de
        yazı yazabilir. Bu tip editörler geniş bir klavye haritasına sahip
        oldukları için, örneğin fonksiyon tuşlarını veya klavyenin en sağındaki
        sayısal tuşları da kullanıyor olabilirler. vi' ın tasarım aşamasında bu
        durumdan kaçınılmış, standart dışı klavyesi olan bilgisayarların da var
        olabileceği düşünülerek klavye üzerinde kullanılması gereken tuşların
        sayısını mümkün olduğunca indirilmesine çalışılmıştır. Burada karşımıza
        vi editörünün çalışma aşamasında üç ayrı işlev geliyor. Birincisi,
        bilgisayara komutların girdisi sırasında kullanılan <emphasis>komut modu</emphasis>, ikincisi
        yazı yazarken kullanılan <emphasis>yazı modu</emphasis> ve <emphasis>satır modu</emphasis>.
      </para><para>
        Komut modunda klavye üzerinde görevi olan tüm tuşlar, bilgisayar komut
        vermek için kullanılıyor. Yazı modunda ise diğer editörlerdekine benzer
        şekilde yazı yazmak mümkün oluyor. Klavye modunu değiştirdiğinizde
        klavye tuşlarının işlevleri de hemen değişiyor. vi editörünü ilk
        çalıştırdığınız anda komut moduna girersiniz. Bu anda her tuşa ait
        bir komut çalıştırılmaya hazırdır (örneğin `<emphasis>j</emphasis>' bir karakter aşağı,
        `<emphasis>k</emphasis>' bir karakter yukarı gider). Bu anda kullanıcı yazı moduna geçmek
        isterse `<emphasis>i</emphasis>' tuşuna basabilir.
      </para><para>
        Yazı moduna iken klavyeden girilen her karakter ekranda görünür. Bundan
        sonrası daktilo kullanmaya benzer. Tekrar komut moduna geçmek için <emphasis>ESC</emphasis>
        tuşu yardımcı olur. Bir dosya yazarken veya düzeltmede bulunurken her
        iki yazım stili arasında sürekli gidip geldiğinizi farkedeksiniz.
      </para><para>
        Bunlara ek olarak dosya işlemleri veya eşleme (substitution) yaparken
        iki mod da kullanılmaz. Linux kullanıcısı vi üzerinde çalışırken en alt
        satırda vi mesajlarını görür ve gerektiği zaman satır modunda komutları
        girer. Satır moduna geçmek için `<emphasis>:</emphasis>' (iki nokta üstüste) karakteri
        kullanılır. Bu tuşa basıldığında ekranın en altında bir satır açılır
        ve vi sizden bir komut girmenizi bekler. vi komutunu yazdıp enter'a
        bastıktan sonra tekrar editör komut moduna geçersiniz.
      </para>
    </sect2><sect2>
      <title>Dosya İşlemleri</title>
      <para>
        Sisteme girip ekrana <literal>vi telefon</literal> yazdığınızda aşağıdakine benzer bir
        metin üzerinde arama ve değiştirme görüntüsü monitörde belirecek ve
        program çalıştırılacaktır.
      </para><para>
<screen>
_
~
~
~
~
~
~
~
~
~
~
~
~
 &quot;telefon&quot; [NEW FILE]  1 line, 1 char
</screen>
      </para><para>
        vi'a ilk girdiğiniz anda komut modunda olursunuz. Yazı moduna geçmek için
        `<emphasis>i</emphasis>' veya `<emphasis>a</emphasis>' tuşuna basın. Bu andan itibaren zamanınızın büyük
        bir kısmını geçireceğiniz yazı moduna atlarsınız. Bıkana kadar yazıp
        önce <emphasis>ESC</emphasis> tuşuna, ardından iki kere `<emphasis>Z</emphasis>' tuşuna basın. Bu komut dizisi
        önce dosyayı kaydedecek, sonra da vi editörden çıkmanızı ve kabuğa
        dönmenizi sağlayacaktır.
      </para><para>
        vi' a yeni başlayanların yaptıkları en sık hatalardan biri yazı
        modundan komut moduna geçerken <emphasis>ESC</emphasis> tuşuna basmamalarıdır. `<emphasis>w</emphasis>' komutu
        `<emphasis>ZZ</emphasis>' komutuna benzer çalışır, hafızada halihazırda bulunan dosyayı,
        editörden çıkmadan diske kaydeder. Eğer isimsiz bir dosyada üzerinde
        çalışıyorsanız (örneğin vi telefon yerine sadece vi yazarak editöre
        girmişseniz) dosyayı sabit diske yazmak için `<emphasis>w</emphasis>' satır komutunu
        kullanmalısınız. Bunun için daha önce de belirtildiği gibi
      </para><para>
<screen>
:w telefon
</screen>
      </para><para>
        yazıp satır moduna geçerek komutu girmelisiniz
      </para><para>
        vi editörden çıkmak için `<emphasis>:q</emphasis>' yazın.
      </para>
    </sect2><sect2>
      <title>vi' da Yazma</title>
      <para>
        Şimdi vi yardımıyla bir dosya üzerinde denemeler yapalım. Aşağıdaki
        satırları kabuk satırında iken yazın ve <emphasis>ENTER</emphasis>'a basın.
      </para><para>
<screen>
metu:~$ vi deneme
</screen>
      </para><para>
        Ekran silinecek ve yukarıdakine benzer bir görüntüyle
        karşılaşacaksınız. Yazı moduna geçmek için `<emphasis>i</emphasis>' tuşuna basın. Hemen
        ardından bir zamanlar İnternet üzerinde görüp kaydettiğim birkaç satırı
        yazın.
      </para><para>
<screen>
Arada sırada kitapta bir şeyler ararken /'e basasım gelmiyor değil.
~
~
~
~
~
~
</screen>
      </para><para>
        Ekranın en sonuna geldiğinizde vi, alttaki satır başına
        geçmeyecektir. Bunun için <emphasis>ENTER</emphasis> tuşuna basarak yazmaya devam edin.
      </para><para>
<screen>
Arada sırada kitapta bir şeyler ararken /'e basasım gelmiyor değil.
Fazla vi kullanmaktan tembelliğe alışmışız anlaşılan,
~
~
~
~
~
</screen>
      </para><para>
        Satır sonuna geldiğiniz zaman komut satırına geçmek için <emphasis>ESC</emphasis> tuşuna
        basın. Klavyenin sağındaki yön tuşlarını kullanarak dosya içinde
        gezinebilirsiniz. vi'ın sevdiğim özelliklerinden birisi de kullanıcıyı
        10 parmak yazmaya zorlamasıdır. Yön tuşlarının görevini <emphasis>h, j, k</emphasis> ve
        <emphasis>l</emphasis> tuşları da yapabilir, böylece kullanıcı sağ elini klavye üzerinde
        sürekli gezdirmek zorunda kalmaz.
      </para><para>
        <itemizedlist>
          <listitem><command>j</command>, imleci bir satır aşağı indir </listitem>
          <listitem><command>k</command>, imleci bir satır yukarı gönder</listitem>
          <listitem><command>h</command>, imleci bir karakter sola al</listitem>
          <listitem><command>l</command>, imleci bir karakter sağa al</listitem>
        </itemizedlist>
      </para><para>
        Alternatif olarak <emphasis>ENTER</emphasis> tuşu komut modunda `<emphasis>j</emphasis>' tuşu yerine de
        kullanılabilir. Kursörü yön tuşları yardımıyla ``Fazla'' kelimesiyle
        başlayan satıra kadar taşıyın. `<emphasis>i</emphasis>' tuşuna basıp tekrar yazı moduna
        geçerek metin üzerinde biraz değişiklik yapın:
      </para><para>
<screen>
Arada sırada kitapta bir şeyler ararken /'e basasım gelmiyor değil.
Fazla vi kullanmaktan dolayı_tembelliğe alışmışız anlaşılan...
~
~
~
~
~
</screen>
      </para><para>
        ``dolayı'' kelimesini ekledikten sonra bir noktayı işaret etmek
        istiyorum. Kullandığım Linux makinası Türkçe destekli olduğu için Türkçe
        karakterleri okuyup yazmam mümkün, aslında Linux işletim sistemi hemen
        her ülkenin alfabesini desteklediğinden herhangi bir dilde (örneğin
        Alman alfabesi karakterlerini kullanarak) yazmak için birkaç komut
        yeterli oluyor.
      </para><para>
        `<emphasis>i</emphasis>' tuşu imlecin bulunduğu yerden yazmasına rağmen, `<emphasis>a</emphasis>' komutu bir
        karakter sağdan başlayarak yazmanızı sağlar. `<emphasis>o</emphasis>' komutu ise imlecin
        bulunduğu yerin altında bir satır boşluk bırakır ve boş satırın başına
        geçerek yazı moduna atlar. <emphasis>ESC</emphasis> tuşuna basarak komut modundayken en alt
        satıra inin ve `<emphasis>o</emphasis>' tuşuna basın. Burada bir satır daha ekleyelim:
      </para><para>
<screen>
Arada sırada kitapta bir şeyler ararken /'e basasım gelmiyor değil.
Fazla vi kullanmaktan dolayı tembelliğe alışmışız anlaşılan..
Sayfaları karıştırmak zor geliyor...
~
~
~
~
</screen>
      </para><para>
        Eğer ekrandaki bilgi birkaç sayfadan ibaretse <emphasis>Control-F</emphasis> tuşunu bir sayfa
        ileri gitmek için, <emphasis>Control-B</emphasis> tuşunu ise metni bir sayfa geriye almak
        için kullanabilirsiniz.
      </para><para>
        vi her satırı kendi içinde numaralandırır. Belirli bir satıra gitmek
        için tuşlar dışında satırın numarası kullanarak da gidilebilir. `<emphasis>G</emphasis>'
        komutu yardımıyla imlecin gideceği satırı belirtebilirsiniz. Bunun için
        komut modunda iken satır numarasını girin (ekranda görünmeyecektir) ve
        hemen ardından `<emphasis>G</emphasis>' tuşuna basın. Eğer satır numarası girilmezse
        imleci dosyanın sonunda konumlandırılır.
      </para>
    </sect2><sect2>
      <title>Silme ve Kopyalama</title>
      <para>
        Yazı modunda iken <emphasis>back space</emphasis> tuşu yardımıyla, komut modunda iken ise
        `<emphasis>x</emphasis>' komutu ile istediğiniz kadar harfi silmeniz mümkündür. `<emphasis>dd</emphasis>'
        komutu ise imleci üzerinde bulunduğu satırı siler ve alttaki tüm
        satırlar bir satır yukarı alınır. PC üzerindeki editörlerdeki satır sonuna
        gelince imlecin otomatik olarak bir satır aşağı kayması, <literal>:set wm=n</literal>
        satır komutu yardımıyla gerçekleştirilir.  Komuttaki <emphasis>n</emphasis> sayısı, sağdan
        kaç boşluk bırakılacağını söyler. Ekranın sağından 4 satır boşluk bırakmak
        için (bu durumda satır uzunluğu 76 karaktere inecektir) <literal>:set wm=4</literal> yazın.
      </para><para>
        `<emphasis>dd</emphasis>' veya `<emphasis>x</emphasis>' komutundan sonra silinen harf ve harf grupları hafızaya
        alınır ve istenildiği zaman `<emphasis>p</emphasis>' tuşu yardımıyla imlecin bulunduğu yerden
        itibaren ekrana basılır. `<emphasis>P</emphasis>' yardımıyla hafızadaki metni imlecin bir
        satır üzerine kopyalayabilirsiniz.
      </para><para>
        Kursörün bulunduğu yerden satır sonuna kadar silmek için
        `<emphasis>d$</emphasis>' , metin
        sonuna kadar silmek için `<emphasis>dG</emphasis>' kullanılabilir. ($ ve G harflerinin
        işlevlerine dikkat edin!)
      </para><para>
        Son kaldığımız yerden devam edelim. Son satırı `<emphasis>dd</emphasis>' ile
        silelim.
      </para><para>
<screen>
Arada sırada kitapta bir şeyler ararken /'e basasım gelmiyor değil.
Fazla vi kullanmaktan dolayı tembelliğe alışmışız anlaşılan..
~
~
~
~
~
</screen>
      </para><para>
Ardından kestiğimiz satırı <emphasis>P</emphasis> komutuyla en üste yapıştıralım .
      </para><para>
<screen>
Sayfaları karıştırmak zor geliyor...
Arada sırada kitapta bir şeyler ararken /'e basasım gelmiyor değil.
Fazla vi kullanmaktan dolayı tembelliğe alışmışız anlaşılan..
~
~
~
~
</screen>
      </para><para>
        Tek bir karakteri başka bir karakterle değiştirmek için önce komut modunda
        karakteri silip yazı moduna geçtikten sonra gerekli değişikliği yapmaya
        gerek yoktur. `<emphasis>r</emphasis>' komutu tek bir harfi değiştirmek için kullanılır. Bu
        tuşa basınca imlecin üzerinde bulunduğu karakter silinir ve editör
        kullanıcıdan yerine gelecek karakteri bekler. Bundan sonra vi tekrar
        komut moduna döner.
      </para><para>
        Bir kelimeyi silip üzerine yazmak için de `<emphasis>cw</emphasis>' komutu
        kullanılabilir. Kelimenin başına gelin ve sırayla önce `<emphasis>c</emphasis>' sonra
        `<emphasis>w</emphasis>' tuşlarına basın. Editör yazmayı bitirmenizi bekleyecektir. <emphasis>ESC</emphasis> tuşuna
        basıncaya kadar yazdıklarınız ekranda kalacak ve (varsa) kelimeden arta
        kalan harf(ler) silinecektir.
      </para><para>
        Her ölümlü gibi siz de hata yapabilirsiniz. Hata yaptıktan sonra eski
        konuma dönmek için `<emphasis>u</emphasis>' komutunu kullanın. Bu komut, üzerinde değişiklikler
        yaptığınız metni son çalıştırılan komuttan önceki duruma getirir. Yeni
        konuma tekrar geri dönmek için <emphasis>Control-R</emphasis> 'ye basın.
      </para>
    </sect2><sect2>
      <title>Komut Tekrarı</title>
      <para>
        20 satırı silmek için 20 kere dd tuşuna basmak gereksizdir. Bunun
        için `<emphasis>dd</emphasis>' komutundan önce klavyeden 20 rakamını girmek yeterli
        olur. Girilen rakamlar `<emphasis>G</emphasis>' komutundaki örneğe benzer şekilde ekranda
        görünmezler. Kullanılan rakamlar, kendinden sonra gelecek olan komutun kaç
        kere işletileceğini belirtir. Örnek olarak `<emphasis>8x</emphasis>' komutu sekiz karakteri
        siler, `<emphasis>12j</emphasis>' komutu 12 satır aşağı iner. Üzerinde çalıştığımız dosyada
        birkaç uygulama yapalım. Kursörü ilk satırdaki ``geliyor'' kelimesinin
        başına alın ve `<emphasis>7x</emphasis>' komutunu girin. Son durum yaklaşık şu şekilde
        olmalıdır:
      </para><para>
<screen>
Sayfaları karıştırmak zor ...
Arada sırada kitapta bir şeyler ararken /'e basasım gelmiyor değil.
Fazla vi kullanmaktan dolayı tembelliğe alışmışız anlaşılan..
~
~
~
</screen>
      </para><para>
        vi'ın komut tekrar özelliği sayesinde ekrana yazdıklarınızı ardarda
        kopyalayabilirsiniz. Örnek dosya üzerinde birinci satırın başına gidin ve
        `<emphasis>9i</emphasis>' yazın. Gireceğiniz yazı modunda ekrana ne gönderirseniz
        <emphasis>ESC</emphasis> tuşundan sonra 9 kopyası basılacaktır:
      </para><para>
<screen>
bip bip bip bip bip bip bip bip bipSayfaları karıştırmak zor ...
Arada sırada kitapta bir şeyler ararken /'e basasım gelmiyor değil.
Fazla vi kullanmaktan dolayı tembelliğe alışmışız anlaşılan..
~
~
~
~
</screen>
      </para>
    </sect2><sect2>
      <title>Kopyalama</title>
      <para>
        Silinen karakter veya karakter gruplarının hafızaya kaydedildiğini
        söylemiştik. Bu hafıza geçici bir tampon vazifesi görür. `<emphasis>yy</emphasis>' komutu
        üzerinde bulunduğu satırı kopyalar. Eğer komuttan önce sayı girilirse o
        kadar satır kopyalanır. Ardından kullanıcı metin üzerinde istediği yere
        gelip `<emphasis>p</emphasis>' tuşuna basarak hafızadaki satırları imlecin bulunduğu satırın
        altından itibaren basar. `<emphasis>yy</emphasis>' komutu yerine
        `<emphasis>Y</emphasis>' de tercih edilebilir.
      </para>
    </sect2><sect2>
      <title>Arama ve Eşleştirme</title>
      <para>
        vi'da çalışırken arama yapmak isteyebilirsiniz. Eğer üzerinde çalıştığınız
        metin uzun ise belirli bir kelime veya kelime gruplarını aramak çok zaman
        alabilir. Komut modunda iken `<emphasis>/</emphasis>' karakterine basarak arama/tarama moduna
        geçin. Ekranın en alt kısmında bir satır açılacaktır. Aramak istediğiniz
        kelimeyi yazın ve <emphasis>ENTER</emphasis> tuşuna basın. vi editörü imlecin bulunduğu
        yerden itibaren girilen anahtar sözcüğü metin içinde tarayacaktır. Eğer
        aranan kelime bulunmuşsa satır bunun üzerine konumlandırır.
      </para><para>
        `<emphasis>/</emphasis>' komutu dosyanın sonuna doğru arama yaparken `<emphasis>?</emphasis>' komutu
        başa doğru gider. Aynı kelimeyi tekrar aratmak için `<emphasis>n</emphasis>' tuşuna
        basın. Arama işlemi, `<emphasis>/</emphasis>' komutu yardımıyla yapılmışsa ileri doğru,
        `<emphasis>?</emphasis>' komutu yardımıyla yapılmışsa geriye doğru tekrar başlayacaktır.
      </para><para>
        Aslında arama yaparken komut modunda girilen her karakter grubu bir
        düzgün deyimdir. Örnek olarak komut modunda `<emphasis>d$</emphasis>' yazdığımızda
        $ harfinin satır sonunu belirttiğini, `<emphasis>dG</emphasis>' komutundaki
        `<emphasis>G</emphasis>' harfinin de metin sonunu işaret ettiğinden imlecin bulunduğu
        yerden itibaren dosya sonuna kadar sildiğini görmüştük. Metin içindeki
        büyük harfleri aramak için
      </para><para>
<screen>
/[A-Z]
</screen>
      </para><para>
        kullanılabilir. Burada gösterebildiğimiz özellikleri vi'ın sadece
        küçük bir parçasıdır. vi kullanıcılarının işine yarayabilecek birkaç
        arama-eşleştirme komutuna göz atalım.
      </para><para>
        <screen>:[a,b]s/deyim/eşlenecek deyim/işleç</screen>
      </para><para>
        Yukarıdaki komut metin içinde a ve b satırları arasındaki
        ``deyim''i, ``eşlenecek deyim''e çevirir. Özel tanımlı karakterleri de
        kullanabilirsiniz. Aşağıdaki komut da 1. ve 10. satırları arasında
        bulduğu tüm ``nümerik'' kelimelerini ``sayısal'' hale getirir.
      </para><para>
        <screen>:1,10s/nümerik/sayısal;</screen>
      </para><para>
        Satır sayısı yerine tüm dosya üzerinde eşleştirme yapmak için
        % sembolünü, satır sonunu belirtmek için $ sembolünü
        kullanabilirsiniz. Bu durumda satır sayısını belirten [a,b]
        tanımını boş bıraktığınızda değişiklik sadece imlecin bulunduğu satırda
        yapılacaktır. İşleçler de birkaç çeşit olabilir. `<emphasis>c</emphasis>' işleci, her
        eşleme öncesi kullanıcıdan izin alır. vi kullanırken çoğu durumda her
        satırda rastlanan ilk eşlemeyi yerine getirecek olan `<emphasis>g</emphasis>' işlecini
        kullandığınızı göreceksiniz. Daha az kullanılan `<emphasis>i</emphasis>' işleci ise
        aramanın büyük-küçük harf gözetimi yapmadan yerine getirmesini sağlar.
      </para><para>
<screen>
:%s/elektronik/s/nik//g
</screen>
      </para><para>
komutu, içinde ``elektronik'' kelimesi geçen her satırdaki ``elektronik''
kelimesini ``elektron'' haline getirir. Fakat ``mekanik'' kelimesine
dokunmaz. Sed altında kullanılan `<emphasis>\(\)</emphasis>' operatörü vi için de
geçerli bir tanımdır. Aşağıdaki komut da yukarıdaki uygulamaya benzer
şekilde her ``kalemlik'' kelimesini ``kalemler'' haline getirir.
      </para><para>
<screen>
:g/\(kalem\)lik/s//\1ler/g
</screen>
      </para>
    </sect2><sect2>
      <title>Diğer Dosyaların Metne Eklenmesi</title>
      <para>
        Kursörün bulunduğu yerden itibaren <literal>rehber.txt</literal> dosyasını halihazırda
        çalıştığınız metine kopyalamak için
      </para><para>
<screen>
:r rehber.txt
</screen>
      </para><para>
        komutunu kullanın.
      </para>
    </sect2><sect2>
      <title>Kabuk Komutlarının Çalıştırılması</title>
      <para>
        vi altında iken kabuk komutlarını, hatta kabuğun kendisini bile
        çalıştırmak mümkündür. `<emphasis>:!</emphasis>' ile komut ismini girebilirsiniz. Aşağıdaki
        komut vi'dan çıkmadan <literal>ls</literal> komutunu çalıştıracak ve sonucu ekrana
        verecektir.
      </para><para>
<screen>
:!ls -la
</screen>
      </para><para>
        Bunun yanısıra komut çıktısını ekran yerine üzerinde çalıştığımız metine
        aktarmak için aşağıdaki vi komutunu kullanın:
      </para><para>
<screen>
:r! ls -al
</screen>
      </para><para>
        Metnin son halini görelim:
      </para><para>
<screen>
bip bip bip bip bip bip bip bip bipSayfaları karıştırmak zor ...
Arada sırada kitapta bir şeyler ararken / 'e basasım gelmiyor değil.
Fazla vi kullanmaktan dolayı tembelliğe alışmışız anlaşılan..
bash.txt
index.html
images/
~
</screen>
      </para>
    </sect2><sect2>
      <title>vi Başlangıç Dosyaları</title>
      <para>
        vi her açıldığında belirli bir dosyayı okur ve gerekli düzenlemeleri
        ve düzeltmeleri yapar. Bu işlemler için kullanılan set komutu
        birtakım parametreler alır. Örneğin <literal>set wm=n</literal> , <emphasis>n</emphasis> karakter kenar
        boşluğu bırakmak için, set nu ise her satırın numaralandırılması için
        kullanılır. Bu komutlar ister vi içinde , ister başlangıç dosyası içinde
        çalıştırılabilir.
      </para><para>
        vi her açılışta öntanımlı olarak önce bulunduğunuz dizin içindeki,
        ardından ev dizininizin içindeki <literal>.exrc</literal> dosyasına bakar.
        Böylece
        açılış anında yapılandırma işlemlerini bu dosyayı kullanarak kolayca
        gerçekleştirebilirsiniz. Dosyaya her satırda bir set komutu gelecek
        şekilde istedinildiği kadar komut yerleştirilebilir. Aşağıda örnek bir
        .exrc dosyası görülüyor.
      </para><para>
<screen>
set ignorecase
set wrapmargin=2
set tabstop=6
</screen>
      </para><para>
        Yukarıdaki seçenekler arasında <literal>ignorecase</literal>, vi editörünün arama yaparken
        küçük-büyük harf ayrımı gözetmemesini; <literal>wrapmargin=2</literal> sol kenardan iki
        satır boşluk bırakmasını; <literal>tabstop=6</literal> ise <emphasis>TAB</emphasis> tuşuna her basıldığında
        imlecin 6 karakter ileri gitmesini sağlar. Daha kısa yazmak isterseniz
        sırasıyla <literal>ic, wm</literal> ve <literal>ts</literal> kullanın.
      </para>
    </sect2>
  </sect1>
</chapter>

<chapter id="archive-tlkg-lis-8">
  <title>TCP/IP</title>
  <sect1 id="archive-tlkg-lis-8g">
    <title>Giriş</title>
    <para>
      Diğer açık sistemler gibi Linux'un da en büyük özelliklerinden biri ağ
      protokolleri ve uygulamalarının sistemin en doğal parçalarından biri
      olmasıdır. Dolayısıyla ağ yapısını bilmeyen bir yöneticinin, açık sistemler
      üzerindeki bilgisini daha da geliştirebilmesi mümkün değildir. Bu
      bölümde anlatılacaklar Linux üzerinde TCP/IP'ye bir giriş yapılmasını
      sağlayacaktır. Ayrıntılı bilgi TCP/IP servislerinin ve uygulamalarının
      anlatıldığı diğer bölümlerden ve aşağıda sözü edilen kitap ve
      dökümanlardan edinilebilir.
    </para><para>
      TCP/IP üzerine önerebileceğimiz bir kitap, ilk baskıları TÜBİTAK
      tarafından bastırılan ve büyük bir okuyucu kitlesi bulmuş <link
      linkend="archive-hii">Herkes İçin İnternet</link> (Kürşat Çağıltay) 'tir.
      Bunun dışında İngilizce Prentice Hall tarafından yayınlanan
      <emphasis>Internetworking with TCP/IP Volume I (D.E. Comer)</emphasis>,
      O'Reilly &amp; Associates tarafından yayınlanan, <emphasis>TCP</emphasis>IP
      Network/ Administration (Craig Hunt) ve <emphasis>Linux Network
      Administrator's Guide</emphasis> (NAG - Olaf Kirsh).  NAG,
      <emphasis>Linux Documentation Project</emphasis>'in bir parçası
      olduğundan elektronik kopyası İnternet üzerinden ücretsiz olarak edinilebilir.
    </para><para>
      Linux Documentation Project grubunun hazırladığı <emphasis>NET-3-HOWTO</emphasis>, TCP/IP
      temelleri ve ağ uygulamalarını örnekleriyle işlemiş. Bu dökümanı nasıl
      temin edebileceğinizi kitabın sonunda bulabilirsiniz. NET-3, TCP/IP ve
      buna bağlı protokollerin Linux için geliştirilen bölümüne verilen isimdir.
    </para>
  </sect1>
  <sect1 id="archive-tlkg-lis-8.1">
    <title>Temel TCP/IP</title>
    <para>
      TCP/IP, ilk defa ABD'de ARPANet (Advanced Research Projects Agency
      Network) adı altında, askeri bir proje olarak geliştirildi. Önceleri
      askeri amaçlı düşünülen proje önce ünivesiteler tarafından kullanılmaya
      başlandı. Ardından
      ABD'nin dört bir yanında birbirinden bağımsız geliştirilen ağlar, tek
      bir omurga altında NSFNet olarak adlandırıldı ve ulusal boyutu aşarak
      dünyaya yayıldı. İnternet'in doğuşu da bu tarihe denk gelir.
    </para><para>
      Bir sokak üzerinde yeralan evlerin adresleri gibi, İnternet'e bağlı olan
      her makinanın da bir adresi vardır. Bu adres sayesinde bir bilgisayardan
      diğerine ulaşmak mümkün olur. İnternet adresi 4 bayttan (32 bit) ibaret
      olup yazılırken her bayt arasına bir nokta konulur. En çok kullanılan
      bu gösterim şekline örnek olarak, ODTÜ'deki bir bilgisayarın adresi olan
      <literal>144.122.199.20</literal>'yi verebiliriz.
    </para><para>
      Bununla beraber, 4 baytlık numaraların kolayca hatırlanmasının
      mümkün olmadığından, İnternet üzerindeki makinalara alfanümerik
      adlar da verilebilir. Yukarıda örneğini verdiğim adresin ismi,
      <emphasis>knidos.cc.metu.edu.tr</emphasis>'dır. ilk noktaya kadar olan kelime, makina
      adıdır(yukarıdaki örnekte knidos), bundan sonraki noktayla ayrılmış
      bölümler özelden genele doğru makinanın ait olduğu kurum, kurumun tipi
      ve ülke gibi bilgiler içerir. Bu adlandırma yöntemiyle ilgili ayrıntılı
      bilgiyi Alan İsimlendirme Sisteminin (Domain Name System - DNS)
      anlatıldığı bölümde bulabilirsiniz.
    </para>
  </sect1>
  <sect1 id="archive-tlkg-lis-8.2">
    <title>Internet Adresleri</title>
    <para>
      İnternet üzerinde 3 sınıf adres vardır. Avrupa'da RIPE (Réseaux IP
      Européens) tarafından dağıtılan bu adresler daha sonra o yerin ağ
      yöneticisi tarafından uygun şekilde bölünebilir. Bu bölümlendirmeye
      ``subnetting'' işlemi adı verilir. Bu sayede ağlar gruplanarak
      herbirisinin yönetimi bağımsız hale getirilmiş, aynı zamanda da kısıtlı
      olan IP adresleri daha verimli bir şekilde kullanılmış olur.
    </para><para>
      Üç çeşit İnternet adresi şunlardır:
    </para><para>
      <variablelist>
        <varlistentry>
          <term>A sınıfı İnternet adresi:</term>
          <listitem><para>
            Adresin ilk baytı 1 ile 126
            arasında bir sayıdır. Bu adrese verilen yetkiyle toplam 2^24 makina
            adreslenebilir. Dünya üzerinde 126 tane A sınıfı adres vardır.
          </para></listitem>
        </varlistentry>
        <varlistentry>
          <term>B sınıfı İnternet adresi:</term>
          <listitem><para>
            Adresin ilk baytı 128 ile 192
            arasında bir sayıdan oluşur. Bu adresin subnetlere bölünmesiyle 65534
            farklı makina adreslenebilir.
          </para></listitem>
        </varlistentry>
        <varlistentry>
          <term>C sınıfı İnternet adresi:</term>
          <listitem><para>
            Adresin ilk baytı 192 ile 223
            arasındadır. C sınıfı bir adresi blokuyla bağlı 254 bilgisayar
            adreslenebilir.
          </para></listitem>
        </varlistentry>
      </variablelist>
    </para><para>
      <emphasis>A</emphasis> ve <emphasis>B</emphasis> sınıfı adreslerin hepsi dağıtılmış ve şu anda intenet
      <emphasis>C</emphasis> sınıfı adreslerde de sıkıntı çekilmektedir. Adres
      yetersizliğine çözüm getirmek amacıyla <emphasis>IPv6</emphasis> ya da <emphasis>IPNG</emphasis>
      adlarıyla daha uzun İnternet adresleri kullanan protokoller geliştirilme
      ve test aşamasındadır.
    </para><para>
      Bir İnternet adresi iki kısımdan meydana gelir: <emphasis>ağ adresi</emphasis> ve <emphasis>düğüm
      adresi</emphasis>. Her makina, bir ağ üzerinde bulunur ve bu adres ``ağ adresi''
      olarak adlandırılır. Üç sınıf (A, B ve C) İnternet adresinin ağ ve düğüm
      adresleri farklı farklıdır. A sınıfı İnternet adreslerinde ağ adresini
      1 bayt tayin eder. Örnek olarak hayali yazılan 74.198.59.33 makinasını
      tanımlayan ağ adresi 74'tür. Ağ adresi uzun halde yazıldığı zaman kalan
      3 baytın yerine 0 konur. Bu durumda yukarıda adı geçen makinaya ait ağ
      adresi 74.0.0.0 olacaktır.
    </para><para>
      Ağ adresinden geriye kalan düğüm adresi, bir makinanın İnternet sınıfına
      göre 1,2 veya 3 bayttan ibaret olabilir. Örnek olarak,
    </para><para>
      195.12.288.3 makinasının (C sınıfı) ağ adresi 195.12.288.0, düğüm adresi
      3'tür.
    </para><para>
      130.11.195.62 makinasının (B sınıfı) ağ adresi 130.11.0.0, düğüm
      adresi 195.62'dir.
    </para><para>
      Düğüm adresleri yerine 4 baytı da kullanmak da olası. Yukarıdaki iki
      örnek için düğüm adreslerini sırasıyla 195.12.288.3 ve 130.11.195.62
      olarak kabul edebiliriz.
    </para><para>
      Yukarıda sözedilen <emphasis>subnetting</emphasis> (alt ağlara ayırma), çok sıkça
      kullanılan bir yöntem olup getirdiği birtakım kolaylıklar vardır. Büyük
      bir iletişim ağı alt ağlara ayrılırsa, kontrol edilmesi daha kolaylaşır.
    </para><para>
      Bir kuruluş, kendine ait olan B sınıfı adresi subnetlere bölmek
      isteyebilir. Gerekli düzenlemeleri yaparak bir B sınıfı adresi (örneğin)
      255 adet alt adrese ayırabilir. ODTÜ'nün NIC'den aldığı 144.122.0.0
      ağı, 254 parçaya bölünmüş, bu parçalardan 144.122.71.0 alt ağı Bilgisayar
      Mühendisliği bölümüne, 144.122.34.0 alt ağı Kimya Mühendisliği bölümüne
      verilmiştir. Bundan sonra her bölüm kendi ağı ve üzerindeki makinalardan
      sorumlu olur.
    </para>
  </sect1>
  <sect1 id="archive-tlkg-lis-8.3">
    <title>Protokoller</title>
    <para>
      Internet protokollerinin yaygınlaşmasındaki en önemli etkenlerden biri
      herhangi bir ağ donanımına ya da firmaya özel olmamalarıdır.
      Bilgisayarınız, işletim sistemiz ya da ağ bağlanma yönteminiz ne olursa
      olsun intenete bağlamanız mümkündür. İnternet protokolleri RFC adı
      verilen dökümanlarda açıklanır, bu dökümanlar herkese açıktır ve
      ücretsizdir. RFC'lere
      <ulink url="ftp://nic.ddn.mil/rfc/">NIC</ulink> ya da
      <ulink url="ftp://ftp.metu.edu.tr/pub/documents/rfc/">ODTÜ'deki yansısından</ulink> erişebilirsiniz.
    </para><para>
      Internet protokollerinin temeli <emphasis>Intenet Protocol (IP)</emphasis>'dir. İnternet
      üzerinde yönlendirme(routing) gibi temel ağ işlemlerinin gerçekleştirildiği
      protokol katmanıdır.  IP paketlerinin her biri kendi başlarına aradaki
      ağ cihazları tarafından yönlendirileren paket içinde belirtilen adrese
      ulaştırılır. Bu sırada fiziksel ağ farklılıklarından kaynaklanan paket
      parçalanmaları(fragmentation) ve bunların yeniden birleştirilmeleri
      aradaki ağ cihazlarının aşırı yüklenmelerini önlemek gibi görevler de
      IP katmanı tarafından gerçekleştirilir.IP bağlantı temelli(connection
      oriented) bir ağ protokolü değildir. Bunun yanı sıra IP paketlerin
      içeriklerinin doğruluğunu da garanti etmez. IP katmanı sadece başlık
      kısmında oluşan hataları bulur ve düzeltir.  Internet üzerinde
      yönlendirme, yukarida sözü edilen adreslerden yararlanılarak
      yapılır
    </para><para>
      Kullanıcı uygulamalarının IP katmanına doğrudan ulaşımları yoktur.
      IP ve uygulama programları arasındaki bağlantıyı sağlayan  iki protokol
      vardır: <emphasis>Transmission Control Protocol (TCP)</emphasis> ve <emphasis>User Datagram
      Protocol (UDP)</emphasis>. <emphasis>TCP</emphasis>, İnternet protokolleri arasındaki en önemli
      protokollerden biridir (İnternet protokol ailesi bu nedenle TCP/IP diye
      adlandırılır.). TCP, IP katmanının sağlamadığı bağlantı temelli, güvenilir
      servisi sağlar. TCP kullanarak ağ üzerinden veri aktaran programlar,
      bir dosyadan okuyormuş ya da yazıyormuş gibi güvenle ağ bağlantısını
      kullanabilirler. Arada oluşan hatalar TCP tarafından onarılır. IP protokol
      katmanına uygulma programları doğrudan erişemediklerinden, hata kontrolü
      ve bağlantı gerektirmeyen ya da bu işlemleri kendileri gerçekleştirmek
      isteyen uygulamalar <emphasis>UDP</emphasis> kullanarak ağ üzerinden iletişim sağlarlar.
    </para><para>
      Yukarıdaki protokollerin yanı sıra İnternet standardı olmuş birçok
      uygulama protokolü de vardır. Bunlar arasında, <emphasis>TELNET</emphasis>, <emphasis>FTP</emphasis>,
      <emphasis>SMTP</emphasis> ve <emphasis>HTTP</emphasis> gösterilebilir.
    </para><para>
      İnternet üzerinde paketler son makinaya ulaştıktan sonra, ilgili
      uygulama programına ulaşabilmesi için <emphasis>port</emphasis> adı verilen sanal
      numaralar kullnılır. Servis veren uygulamalar, önceden belirlenmiş
      standart port numraları kullanırlar. Örnek olarak SMTP 25 numaralı TCP
      portunu, talk ise 518 numaralı UDP portunu kullanır. Sisteminizin
      kullandığı port numaraları ve bunların isimlerini <literal>/etc/services</literal>
      dosyasından görebilirsiniz.
    </para>
  </sect1>
  <sect1 id="archive-tlkg-lis-8.4">
    <title>Internet'e Bağlanma</title>
    <para>
      Linux'u İnternet'e bağlamak ilk aşamada biraz zor görünse de biraz teori,
      biraz pratik yardımıyla mantık kolayca anlaşılabiliyor.
      Ağlar, bilgisayar sistemlerinde hata olma olasılığı en yüksek, en çok
      sorunun çıktığı alandır. Bu bölüm, özelde bir ethernet kartı ile
      bağlantı yapıldığı varsayılarak anlatılmıştır. Ancak anlatılan birçok
      kavram herhangi bir yapıdaki İnternet bağlantısı için geçerli olacaktır.
    </para><para>
      Öncelikle çekirdeği -daha önce yapmamışsanız- ağ bağlantısına destek
      verecek şekilde tekrar derleyin. Bunun için gerekli birkaç soruya "y"
      cevabı vermek yeterli olacaktır:
    </para><para>
<screen>
CONFIG NET ? [Y/n] y
...
TCP/IP networking (CONFIG_INET) [Y/n/?] y
...
Network device support (CONFIG_NETDEVICES) [Y/n/?]
...
Ethernet (10 or 100Mbit) (CONFIG_NET_ETHERNET) [N/y/?] y
...
Other ISA cards (CONFIG_NET_ISA) [N/y/?] y
...
NE2000/NE1000 support (CONFIG_NE2000) [N/y/m/?] y
</screen>
    </para><para>
      Yukarıdaki örnekte ethernet kartınızın ne2000/ne1000 ya da uyumlu bir kart
      olduğu var sayılıyor. Kartınızın marka/modeline uygun seçeneneğe `y'
      cevabı vermelisiniz. Ethernet kartlarının dışında bağlanma yönteminize
      bağlı olarak çekirdeği <emphasis>PPP</emphasis>, <emphasis>SLIP</emphasis>,
      <emphasis>Token Ring</emphasis> gibi bir destekle derlemeniz gerekebilir.
      Bunları <emphasis>modül</emphasis> olarak derlemeniz
      de mümkün. Çekirdek derlemek konusunda daha ayrıntılı bilgiyi bu kitabın
      ilgili bölümünde bulabilirsiniz.
    </para><para>
      Tabi ki çekirdeği derlemek yetmiyor, derleme aşamasından sonra ağ
      desteğine sahip olan çekirdek ile makinanın açılması gerekir.
    </para><para>
      Bağlantıyı gerçekleştirmek için ağ sorumlusundan bazı önemli bilgileri
      almalısınız. Makinanızın <emphasis>IP adresi</emphasis> bunların başında gelir. Diğer
      gerekli bilgiler de <emphasis>subnet mask</emphasis> ve <emphasis>broadcast adresi</emphasis>dir.
    </para><para>
      DNS adres çözümleyici olarak çalışan DNS makinası ve makinanızı İnternet'e
      bağlayacak olan yönlendiricinin IP adreslerini de biliyor olmalısınız.
    </para><para>
      Bu aşamadan sonra yapılandırma işlemlerine geçilebilir.
    </para>
    <sect2>
      <title>Ağ Yapılandırması</title>
      <para>
        Bu bölümde anlatılan <literal>rc.*</literal> yapılandırma dosyaları <emphasis>Slackware</emphasis>
        dağıtımına özeldir. Diğer dağıtımlarda da açılışta çalışan benzeri
        <emphasis>rc</emphasis> dosyaları değiştirilerek ya da sistemle birlikte gelen sistem
        yönetim araçları kullanılarak istediğiniz yapılandırmayı gerçekleştirebilirsiniz.
      </para><para>
        Linux, açılırken bazı dosyalara bakarak düzgün çalışması için gerekli
        yapılandırmayı yapar ve bazı yazılımları çalıştırır. Bu dosyalar
        <literal>/etc/rc.d</literal> dizini altında yeralır. İnternet bağlantısı için
        sadece iki dosyaya gerek duyulur. Slackware dağıtımı içinde bunlar,
        yapılandırmayı gerçekleştiren <literal>/etc/rc.d/rc.inet1</literal> ve temel ağ programlarını
        çalıştıran <literal>/etc/rc.d/rc.inet2</literal> dosyalarıdır.
      </para><para>
        Bu dosyadaki değerleri gerektiği şekilde düzenleyerek İnternet'e bağlanacağız.
        Öncelikle rc.inet1 dosyasının içeriğine göz atalım:
      </para><para>
<screen>
HOSTNAME=`cat /etc/HOSTNAME`

/sbin/ifconfig lo 127.0.0.1
/sbin/route add -net 127.0.0.0

IPADDR=&quot;144.122.71.55&quot;
NETMASK=&quot;255.255.255.0&quot;
NETWORK=&quot;144.122.71.0&quot;
BROADCAST=&quot;144.122.71.255&quot;
GATEWAY=&quot;144.122.71.1&quot;

/sbin/ifconfig eth0 $IPADDR broadcast $BROADCAST netmask $NETMASK
/sbin/route add -net $NETWORK netmask $NETMASK
/sbin/route add default gw $GATEWAY metric 1
</screen>
      </para><para>
        ifconfig komutu, ağ bağlantısı yapan kartın belirli parametreler ile
        yapılandırılmasını sağlar. Kart kimliğini bilgisayara tanıtmak için bu
        komut kullanılır.
      </para><para>
        İlk satırdaki ifconfig programı, makinanın kendisiyle haberleşmesini
        sağlamak amacıyla kendi ağ adresini (loopback device) 127.0.0.1 olarak
        tanıtmıştır. İnternet üzerindeki her makinanın loopback adresi 127.0.0.1
        'dir. 127 ile başlayan hiç bir adres, İnternet üzerinde gerçek bir adres
        olarak kullanılamaz.
      </para><para>
        Her paket, gönderileceği adrese gitmeden önce bir tabloya bakar. Bu
        tablo, paketin muhtemel rotasını içerir. route komutu yardımıyla bu
        tablo oluşturulur veya kontrol edilir. Genellikle bir kart için bir
        <literal>ifconfig</literal> kullanılırken, paketin yollanacağı birden fazla rotanın
        olması durumunda <literal>rc.inet1</literal> dosyasında birden fazla route komut
        girdisi yapılacaktır.
      </para><para>
        Kullanılan her ağ kartının bir veya birden fazla internet adresi
        olabilir. Linux'a takılan birinci kart <literal>eth0</literal> ismini alırken ikinci karta
        eth1, üçüncüye eth2 ... denir. Loopback cihazının ismi <literal>lo</literal> dur. ifconfig
        komutunu parametre vermeden kullanırsanız, Linux'a tanıtılan çevresel
        birimlerin listesi ekrana gelir.
      </para><para>
<screen>
$ ifconfig
lo        Link encap:Local Loopback
          inet addr:127.0.0.1  Bcast:127.255.255.255  Mask:255.0.0.0
          UP BROADCAST LOOPBACK RUNNING  MTU:3584  Metric:1
          RX packets:493 errors:0 dropped:0 overruns:0
          TX packets:493 errors:0 dropped:0 overruns:0

eth0      Link encap:10Mbps Ethernet  HWaddr 48:54:33:00:E8:3A
          inet addr:144.122.71.55  Bcast:144.122.71.255 Mask:255.255.255.0
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:171956 errors:0 dropped:0 overruns:0
          TX packets:113212 errors:3 dropped:0 overruns:0
          Interrupt:3 Base address:0x300
</screen>
      </para><para>
        <emphasis>cclub.metu.edu.tr</emphasis> makinasının ifconfig bilgisi yukarıdaki şekildedir. Bu
        makina üzerinde tek ethernet kartı olup, ifconfig bilgisinde ikinci sırada
        yeralıyor. Kartla ilgili ayrıntılı bilgi (her kart özgü donanım numarası,
        alınan ve verilen paket sayısı gibi) ifconfig çıktısında var.
      </para><para>
        <literal>route</literal> komutunun genel kullanımı şu şekildedir:
      </para><para>
<screen>
route [add | del] [-net | -host] varis_adresi [gw yonlendirici] secenekler...
</screen>
      </para><para>
        <command>host:</command> paketin gideceği yer başka bir makina
      </para><para>
        <command>net:</command> paketin gideceği yer başka bir ağ
      </para><para>
        <command>varış_adresi:</command> paketin gideceği yer
      </para><para>
        <command>yönlendirici:</command> bu paketin gidebilmesi için geçmesi
        gereken yönlendirici
      </para><para>
        <command>add:</command> tabloya ekle
      </para><para>
        <command>del:</command> tablodan sil
      </para><para>
        Tablonun genel durumunu kontrol etmek için <literal>route</literal> komutuna
        parametre vermeden komut satırından yazın:
      </para><para>
<screen>
cclub:~# route
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
localnet        *               255.255.255.0   U     0      0       67 eth0
loopback        *               255.0.0.0       U     0      0        3 lo
default         router71.ceng.m 0.0.0.0         UG    1      0      404 eth0
</screen>
      </para><para>
        Örnek tabloda üç ayrı yönlendirme girişi vardır. Birincisi, makinanın
        kendisi ile haberleşmesini sağlayacak olan loopback. İkinci satırda,
        yerel ağa gidecek olan tüm paketlerin yönlendiriciye verilmeden ağa
        yönlendirilmesi söylenmiş. Son sırada ise (default) paket ilk iki
        satırda yeralan varış adresinden farklı bir adrese gidecekse, önce
        yönlendiriciden geçip sonra dış dünyaya açılacağından yönlendiricinin
        IP adresi yazılmıştır.
      </para><para>
        <literal>ifconfig</literal>, biraz karmaşık bir komuttur. Sistem yöneticisinden öğrenmeniz
        gereken subnet maskesi, broadcast adresi ve IP adresini kullanıp kartları
        yapılandırır.
      </para><para>
<screen>
ifconfig eth0 144.122.71.55 netmask 255.255.255.0 broadcast 144.122.71.255
</screen>
      </para><para>
        Yukarıda <literal>ifconfig</literal> yardımıyla eth0 kartına hem bir IP adresi verilmiş,
        hem de bilgisayarın bulunduğu ağın özellikleri tanıtılmıştır.
      </para><para>
        Bu andan sonra istendiği kadar <literal>route</literal> komutu ile makinadan çıkacak
        paketler için yeni yollar tanımlanabilir.
      </para><para>
<screen>
route add -net ...
route add -host ...
</screen>
      </para><para>
        Dosyanın içeriğini sistem görevlisinin verdiği bilgiler doğrultusunda
        değiştirdikten sonra komut satırından çalıştırmanız, İnternet'e bağlantı
        için yeterli olacaktır.
      </para><para>
<screen>
# /etc/rc.d/rc.inet1
</screen>
      </para><para>
        Bağlantıyı kontrol etmek İnternet adresini bilip çalıştığından emin
        olduğunuz bir makinaya telnet ile bağlantı yapmaya çalışın:
      </para><para>
<screen>
$ telnet orca.cc.metu.edu.tr
Connected to orca.cc.metu.edu.tr
Escape character is ^]
</screen>
      </para><para>
        Ethernet kartının bağlantısını yazılım yoluyla kesmenin yolu <literal>ifconfig</literal>
        'in down seçeneğidir. Örneğin tek ethernet kartı üzerinden İnternet
        bağlantınız var ve bunu hemen kesmek için aşağıdaki satırı yazın.
      </para><para>
<screen>
# ifconfig eth0 down
</screen>
      </para><para>
        ethernet bağlantısını yeniden açmak için
      </para><para>
<screen>
# ifconfig eth0 up
</screen>
      </para><para>
        komutunu girmelisiniz. Bu işlem sonrasında yönlendirme bilgilerini
        yeniden girmeniz gerekebilir.
      </para><para>
        <literal>ping</literal> komutu, bağlantıları ve aynı zamanda bağlantı hızını ölçmek
        için kullanılan bir komuttur. Ping, ICMP protokolü yardımıyla hedef
        makinaya belirli uzunlukta paketler gönderir. Karşıdaki makina bunları
        aldığı anda bekletmeden geri yollar. Arada geçen zaman farklı, iki makina
        arasındaki bağlantı hızı hakkında fikir verir.
      </para><para>
<screen>
cclub:~# ping knidos.cc.metu.edu.tr
PING knidos.cc.metu.edu.tr (144.122.199.20): 56 data bytes
64 bytes from 144.122.199.20: icmp_seq=0 ttl=253 time=34.0 ms
64 bytes from 144.122.199.20: icmp_seq=1 ttl=253 time=487.7 ms
64 bytes from 144.122.199.20: icmp_seq=2 ttl=253 time=3.6 ms

--- knidos.cc.metu.edu.tr ping statistics ---
3 packets transmitted, 3 packets received, 0% packet loss
round-trip min/avg/max = 3.6/175.1/487.7 ms
</screen>
      </para><para>
        <literal>netstat</literal> komutu, makinanın ağ kartı üzerinden yapılan
        bağlantıların dökümünü çıkarır.
      </para><para>
<screen>
cclub:~# netstat
Active Internet connections (w/o servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State
tcp        0      0 cclub.metu.edu.tr:1947  ftp02.quicktime.appl:20 ESTABLISHED
tcp        0      0 cclub.metu.edu.tr:1943  despair.thebandit.c:ftp ESTABLISHED
tcp        0      0 cclub.metu.edu.tr:1424  despair.thebandit.co:20 ESTABLISHED
tcp        0      0 cclub.metu.edu.tr:1932  ftp02.quicktime.app:ftp ESTABLISHED
tcp        0      0 cclub.metu.edu.tr:1407  165.113.58.253:20       ESTABLISHED
tcp        0      0 cclub.metu.edu.tr:1392  165.113.58.253:ftp      ESTABLISHED
tcp        0      0 cclub.metu.edu.tr:1377  ppp23.cc.metu.ed:telnet ESTABLISHED
tcp        0      0 cclub.metu.edu.t:telnet pclabI_23.feas.met:7075 ESTABLISHED
tcp        1      0 cclub.metu.edu.t:telnet ppp23.cc.metu.edu.:1054 TIME_WAIT
tcp        0      0 cclub.metu.edu.t:telnet labmonitor.feas.m:10345 ESTABLISHED
tcp        0   9495 cclub.metu.edu.t:telnet a5-03-asy27.bil-ro:1026 ESTABLISHED
tcp        0      0 cclub.metu.edu.t:telnet pclabI_14.feas.me:15694 ESTABLISHED
tcp        0      0 cclub.metu.edu.t:telnet stu21.math.metu.e:16158 ESTABLISHED
Active UNIX domain sockets (w/o servers)
Proto RefCnt Flags       Type       State         I-Node Path
unix  1      [ ]         STREAM     CONNECTED     232
unix  1      [ ]         STREAM     CONNECTED     299
unix  1      [ ]         STREAM     CONNECTED     327
unix  1      [ ]         STREAM                   591
</screen>
      </para><para>
        İkinci önemli dosya olan <literal>/etc/rc.d/rc.inet2</literal>, belli başlı tüm
        İnternet sunucularını çalıştırır. Aşağıda bu dosyanın bir kısmı görülüyor.
      </para><para>
<screen>
#!/bin/sh

NET=&quot;/usr/sbin&quot;
IN_SERV=&quot;lpd&quot;
LPSPOOL=&quot;/var/spool/lpd&quot;

echo -n &quot;Starting daemons:&quot;

# inetd calistiriliyor.
if [ -f ${NET}/inetd ]; then
  echo -n &quot; inetd&quot;
  ${NET}/inetd
else
  echo &quot;no INETD found.  INET cancelled!&quot;
  exit 1
fi

# degisik internet servisleri sirasiyla calistiriliyor.
for server in ${IN_SERV} ; do
  if [ -f ${NET}/${server} ]; then
    echo -n &quot; ${server}&quot;
    ${NET}/${server}
  fi
done
</screen>
      </para><para>
        Bu açılış dosyası, ağ üzerinden servs veren bir dizi sunucu programı
        çalıştırıyor ve hataları engellemek için programların yerinde olup olmadığına
        da bakıyor.
      </para>
    </sect2><sect2>
      <title>Kontrol Dosyaları</title>
      <para>
        Yapılandırmayı tamamlamak için <literal>/etc</literal> dizini altında yeralan bazı
        dosyaların elden geçirilmesi gerekir. Bu dosyalar sistemin daha güvenli
        ve verimli çalışmasına yardım eder. Bu dosyaların belli başlı olanları
        ve ne işe yaradıklarını görelim.

        <literal>/etc/hosts</literal> dosyasında makinaların IP numaraları ve İnternet
        adresleri yazılır. Buraya sürekli kullanılan belli başlı önemli
        makinaların girişi yapılabilir. Her makinanın uzun isimleri yerine
        kısa bir kelime yazılarak sözkonusu makinaya ulaşılabilir. Örnek bir
        <literal>/etc/hosts</literal> dosyası:
      </para><para>
<screen>
127.0.0.1               localhost
144.122.199.20     knidos.cc.metu.edu.tr knidos
</screen>
      </para><para>
        İlk satırda loopback IP numarası ve buna karşılık gelen makina ismi
        vardır. Bu satırı silmemelisiniz. İkinci satırda ise knidos.cc.metu.edu.tr
        makinasının IP numarasını 144.122.199.20 olarak belirtilmiş ve bu
        bilgisayara "knidos" ismi ile de ulaşılabilmesi sağlanmıştır.
      </para><para>
        <literal>/etc/hosts.allow</literal> ve <literal>/etc/hosts.deny</literal> yapılandırma
        dosyaları, başka bir makinadan Linux'unuza yapılan bağlantıları
        denetler. <literal>/etc/hosts.deny</literal> içine, sınırlandırılma getirmek istediğiniz
        İnternet servislerini ve hangi makinalar için sınırlandırma istediğinizi
        yazabilirsiniz.
      </para><para>
<screen>
$ cat /etc/hosts.deny
#

in.fingerd: ALL except localhost, localhost : \
        echo &quot;request from %d@%h&quot; &gt;&gt; /tmp/req;
in.telnetd : .net.tr
</screen>
      </para><para>
        Yukarıdaki <literal>hosts.deny</literal> dosyasında dışarıdan gelebilecek finger
        istekleri filtreleniyor ve bu istekler hakkında ayrıntılı bilgi (hangi
        kullanıcı, hangi makinadan) <literal>/tmp/req</literal> dosyasına ekleniyor.
      </para><para>
        Sonraki satır <literal>in.telnetd</literal> yazılımını çalıştıran
        isteklerin *.net.tr adreslerinden gelmesi halinde bunların gözardı
        edileceğini belirtir.
      </para><para>
        <literal>hosts.allow</literal> dosyasında, genellikle <literal>hosts.deny</literal> dosyasına
        gruplanan makina isimlerinin sınırlandırma istenmeyen bir veya birkaç
        tanesi yazılır. Eğer bir makina ismi ve karşılık gelen İnternet adresi
        her iki dosyada da varsa, sözkonusu servise izin verilir.
      </para><para>
        Daha fazla bilgiyi <literal>hosts_access(5)</literal> man sayfalarından
        bulabilirsiniz.
      </para><para>
        <literal>/etc/resolv.conf</literal> dosyasında alan adı ve alan adı
        sunucusunun IP numarası yazılır.
      </para><para>
<screen>
$ cat /etc/resolv.conf
domain linux.org.tr
nameserver 144.122.199.20
</screen>
      </para><para>
        Yukarıdaki satırlardan üzerinde bulunduğum makinanın alan adının (domain
        name) linux.org.tr, alan adı sunucusunun ise 144.122.199.20 IP numaralı
        knidos makinası olduğu anlaşılıyor.
      </para>
    </sect2>
  </sect1>
  <sect1 id="archive-tlkg-lis-8.5">
    <title>Yönlendirme</title>
    <para>
      Daha önce de belirtildiği gibi birden fazla ağa fiziksel bağlantısı
      bulunan ve ağlar arası bilgi paketlerinin geçişine olanak tanıyan araçlara
      yönlendirici (router) adı verilir.
    </para><para>
      İki ayrı ağda yeralan makinaların haberleşmesine imkan tanıyan
      yönlendiriciler, kendilerine gönderilen paketleri bir ağdan diğerine
      iletirler.
    </para><para>
      Herhangi bir ağ içerisinde yer alan makinalar aynı IP ağ içerisinde
      bulunan makinalarla (ağ yapılandırması doğru olduğu sürece)
      haberleşebilirler. Başka adreslere ulaşabilmek için bulunulan ağ
      dışındaki ağlarla bağlantısı olan ve o ağ üzerinde bulunan bir makina ile
      haberleşmeleri gereklidir. Bu makina bilgisayar tanımlarında  <emphasis>gateway</emphasis>
      (yönlendirici, arabirim, arayol) olarak verilir.
    </para><para>
      Minimum yönlendirme, bir ağa bağlı olmayan makinalarda, <literal>ifconfig</literal>
      yardımıyla yapılan yönlendirmedir. En çok kullanılan statik yönlendirme
      çeşidinde,  az sayıda arayol ile dışarıya bağlı olan bir makinada,
      route komutuyla yapılır. Aynı adrese ulaşan birden fazla arayol
      olması durumunda ise, kendi yönlendirme tablosunu ağın durumuna göre
      değiştirebilen dinamik yönlendirmeye başvurulabilir.
    </para><para>
      Linux'un yönlendirici olarak kullanılmasına bir örnek
      verilebilir. Elimizde var olduğunu bildiğimiz iki ağ olsun. Bu ağlardan
      birincisini, 144.122.71.0 ağı, diğeri de 144.122.1.0 ağı olarak kabul
      edelim. 144.122.71.0 ağının İnternet'e bağlanabilmesi için 144.122.1.0
      ağına ulaşması gereklidir. Yönlendirici olarak kullanılacak makinayı
      71.0 ağında kurup gerekli yönlendirme talimatları verildiği anda bu ağa
      bağlı olan diğer makinalar da İnternet'e açılabilecektir.
    </para><para>
      Örnek olarak 144.122.71.0 ağı üzerindeki bir makina için ifconfig satırı
    </para><para>
<screen>
ifconfig eth0 144.122.71.1 broadcast 144.122.71.255 netmask 255.255.255.0
</screen>
    </para><para>
      olarak görünüyor. Bu makinanın yönlendirici görevi yapabilmesi için
      <literal>route</literal> komutu kullanılır. Bu sayede bu bilgisayar, diğerlerine
      ulaşacaktır.
    </para><para>
<screen>
route add -net 144.122.71.0 netmask 255.255.255.0 dev eth0
</screen>
    </para><para>
      Bu, 144.122.71.0 ağında olan makinaların eth0 kartı üzerinden
      erişilebileceğini gösterir. Diğer adreslere erişebilmek için ise bir
      çıkışa (gateway) ihtiyaç duyulmaktadır.
    </para><para>
<screen>
route add default gw 144.122.71.1 dev eth0
</screen>
    </para><para>
      Bu satır sayesinde eldeki tablo yardımıyla çözümlenemeyen adreslere
      gitmesi gereken tüm paketler 144.122.71.1 üzerinden gönderilmektedir. Bu
      durumda bu makinanın paketleri nereye göndereceğini bildiği
      varsayılmaktadır.
    </para><para>
      Bu makina içinde iki adet ethernet bağlantısı bulunmaktadır. Bunlardan
      biri yönlendiriciyi 144.122.71.0 ağına bağlarken diğeri 144.122.1.0
      ağına bağlamaktadır. İlk olarak bu iki kart için gereken tanımlamalar
      /etc/rc.d/rc.inet1 içerisinde aşağıdakine benzer şekilde tanımlanmıştır.
    </para><para>
<screen>
ifconfig eth0 144.122.71.1 broadcast 144.122.71.255 netmask 255.255.255.0
ifconfig eth1 144.122.1.200 broadcast 144.122.71.255 netmask 255.255.255.0
</screen>
    </para><para>
      Birinci ethernet kartı için eth0, ikinci ethernet kartı için de eth1
      kısaltmaları kullanılabilir. Doğal olarak her iki ağ için bir 'route'
      satırı gerekmekte:
    </para><para>
<screen>
route add -net 144.122.71.0 netmask 255.255.255.0 dev eth0
route add -net 144.122.1.0 netmask 255.255.255.0 dev eth1
</screen>
    </para><para>
      Bu sayede diğer makinalardan farklı olarak yönlendirici hem
      144.122.1.0 ağı, hem de 144.122.71.0 ağı üzerindeki adreslere direk
      ulaşabilmektedir. Diğer adreslere ulaşabilmek için benzer bir yöntem
      ile 144.122.1.0 ağı üzerindeki arayola (gateway) yönlendirme yapılır.
    </para><para>
<screen>
route add default gw 144.122.1.200 dev eth1
</screen>
    </para><para>
      Bu çeşit yönlendirmeye <command>statik yönlendirme</command> adı verilir. Burada tüm
      bağlantılar bir tablo halinde verilmiştir. Birbiri arkasına ağ eklendiği
      zaman statik yönlendirme basitlik avantajını kaybetmeye başlar. Bu
      amaçla yönlendiricilerin kendi aralarında bildikleri yolları (yönlendirme
      bilgilerini) birbirlerine aktardıkları dinamik yönlendirme kullanılır.
    </para><para>
      Ağa bağlanmak amacıyla birden fazla kart kullanıyorsanız, <emphasis>arp</emphasis> komutunu
      incelemenizi tavsiye ederim. Bu komut pekçok seçenek alır ve sistem
      yöneticisinin Linux üzerindeki ağı kontrolünü kolaylaştırır.
    </para><para>
<screen>
# arp -a
           IP address      HW type                 HW address
           191.72.1.3      10Mbps Ethernet         00:00:C0:5A:42:C1
           191.72.1.2      10Mbps Ethernet         00:00:C0:90:B3:42
           191.72.2.4      10Mbps Ethernet         00:00:C0:04:69:AA
</screen>
    </para>
    <sect2>
      <title>Birden Fazla Ethernet Kartının Tanıtılması</title>
      <para>
        Yukarıda örneğini verdiğimiz Linux yönlendirici üzerinde iki ethernet
        kartı bulunuyor. Bu sayede Linux makinası iki ethernet ağı arasında
        bir yönlendirici olarak kullanılabilmektedir. Bir Linux'a birden fazla
        ethernet kartı takmak mümkündür. Bu kartları takarken aşağıdaki maddelere
        dikkat etmek gerekir:
      </para><para>
        <orderedlist>
          <listitem>Çekirdek içerisinde her iki kart için destek bulunmalıdır.</listitem>
          <listitem>Ethernet kartları sistemdeki diğer IO ve IRQ ayarlarını
          çakışmayacak şekilde ve farklı değerlerde olmalıdır.</listitem>
        </orderedlist>
      </para><para>
        Birden fazla ethernet kartı (ya da gibi herhangi iki veya daha fazla
        PPP, SLIP gibi ağ bağlantısı) olan makina bir yönlendirici olarak
        kullanılacaksa, çekirdek <emphasis>IP FORWARDING</emphasis> desteğiyle derlenmelidir.
        Bunun yanı sıra Linux'unuzun birinci görevi yönlendiricilik olacaksa
        <emphasis>optimize as router</emphasis> sorusuna da `<emphasis>y</emphasis>' yanıtı vermeniz yararlı
        olacaktır.
      </para><para>
<screen>
IP: forwarding/gatewaying (CONFIG_IP_FORWARD) [N/y/?] y
...
IP: optimize as router not host (CONFIG_IP_ROUTER) [N/y/?] y
</screen>
      </para><para>
        Linux açılırken çekirdek tanıdığı donanımları teker teker arayarak
        bulmaya çalışır (probing). Birden fazla ethernet kartı kullanımına sık
        raslanmadığından Linux ilk ethernet kartını bulduktan sonra ikinci ve
        daha fazla ethernet kartı aramadığından iki kartınız bile olsa Linux
        sadece birini görecektir.  Çekirdeğe ethernet kartı ile ilgili
        parametreler vererek birden fazla ethernet kartının açılışta bulunması
        sağlanabilir. LILO kullanıldığı zaman <literal>/etc/lilo.conf</literal> içinde
      </para><para>
<screen>
append=&quot;ether=0,0,eth1&quot;
</screen>
      </para><para>
        Yukarıdaki paramatre ile çekirdek ikinci bir ethernet kartını (<literal>eth1</literal>)
        da arayacaktır. Ayni şekilde arka arkaya <literal>ether=....</literal> parametreleri
        vererek varsa üçüncü, dördüncü ve daha fazla ethernet kartının
        aratılması da mümkündür. Ethernet kartlarınızın adreslerini
        biliyorsanız, kartların yanlış sırayla bulunması tehlikesini de önlemek
        için,
      </para><para>
<screen>
append=&quot;ether=5,0x340,eth0 ether=15,0x300,eth1&quot;
</screen>
      </para><para>
        gibi bir satır eklenmesi yeterli olacaktır. Burada eth0 isimli bağlantı
        IRQ 5 ve IOBASE 0x340 ve diğer ethernet bağlantısı eth1 IRQ 15 ve IOBASE
        0x300 olacak şekilde ayarlanır, bu durumda çekirdek bir daha kartların
        hangi adres ve IRQ'da olduğuna dair tahmin yürütmez, girilen değerlerde
        bulunan kartları bulmaya çalışır.
      </para><para>
        Sistem açıldıktan sonra gerçekten istenen kartların istenen adreste
        çalıştığına emin olmak için <literal>/var/adm/messages</literal> dosyasına
        bakabilirsiniz ya da <literal>dmesg</literal> komutuyla çekirdek mesajlarını
        görebilirsiniz.
      </para>
    </sect2>
  </sect1>
  <sect1 id="archive-tlkg-lis-8.6">
    <title>NFS</title>
    <para>
      <emphasis>NFS</emphasis> (Network File System), bir ağ üzerinden disklerin paylaşımını
      sağlamak üzere geliştirilmiştir. NFS sayesinde bir makinada yeralan
      belirli bir disk bölümü, başka makinalar tarafından okunabilir
      veya yazılabilir. Bu işleme özellikle büyük organizasyonlarda, disk
      alanından tasarruf etmek için başvurulur. Her makinada aynı dosyalar,
      çalıştırılabilir programlar olması yerine bunlar tek sunucuda toplanır,
      diğer bilgisayarlar bu alanı ortaklaşa paylaşırlar. Paylaşılan dizin,
      sanki yerel makinanın bir diziniymiş gibi davranır. Kendi disk alanını
      paylaştıran makinaya NFS sunucusu, bu diske erişim yapan makinalara da
      NFS istemcisi adı verilir.
    </para><para>
      NFS kullanımının pek çok avantajı sayılabilir. Bunlar kısaca:
    </para><para>
      <itemizedlist>
        <listitem>Yerel bir işletmede tüm kullanıcılar tek bilgisayar üzerindeki
        aynı disk alanını paylaşabilirler. Diğer bilgisayarlar açıldıktan sonra
        bu diskleri kendi dosya sisteminlerine bindirebilirler. NFS'in NIS ile
        birlikte kullanımı sayesinde bir kullanıcı herhangi bir makinaya girip
        diğer kullanıcılarla birlikte aynı dosya yapısı ile çalışabilir.</listitem>
        <listitem>Paylaşım sayesinde büyük disk alanı isteyen programlar tek bir
        sunucuda toplanabilir ve bu sayede önemli miktarda diskten tasarruf
        sağlanabilir.</listitem>
        <listitem>Bir makina üzerinde yapılan değişiklik, her makinada yapılmış
        gibi olur. Böylece aynı yazılımı örneğin 20 bilgisayara yüklemek zorunda
        kalmazsınız.</listitem>
      </itemizedlist>
    </para>
    <sect2>
      <title>Ağ Üzerinde Paylaşım</title>
      <para>
        NFS'in çalışması, yerel bir diskin mount edilmesi kadar kolaydır. Örnek
        olarak NFS sunucusu olan aspendos makinasında yeralan <literal>/home</literal> dizinini,
        yerel makinadaki <literal>/users</literal> dizinine yerleştirmek için:
      </para><para>
<screen>
# mount -t nfs aspendos:/home /users
</screen>
      </para><para>
        kullanılır. mount, karşı makinanın erişim izinleri doğru olduğunu teyit
        ettiği anda bu işlemi gerçekleştirir. Sunucu ile istemci arasındaki
        mesaj alış-verişini <literal>mountd</literal> programı üstlenir.
      </para><para>
        NFS kullanabilmek için çekirdekte NFS desteği olması şarttır. Çekirdeğin
        hangi dosya sistemlerini desteklediğini <literal>/proc</literal> dosya sistemi
        altındaki filesystems dosyasını okuyarak anlayabilmek mümkündür.
        Eğer aşağıdaki satırlarda nfs kelimesi geçmiyorsa çekirdeğe NFS desteği
        verilerek tekrar derlenmesi gerekir.
      </para><para>
<screen>
$ cat /proc/filesystems
        minix
        ext2
        msdos
nodev   proc
nodev   nfs
</screen>
      </para><para>
        NFS için mount programının genel kullanımı şu şekildedir:
      </para><para>
<screen>
mount -t nfs &lt;sunucu-adresi:paylasma-dizini&gt; &lt;yerel-dizin&gt; -o &lt;secenekler&gt;
</screen>
      </para><para>
        Sistem açılırken <literal>/etc/fstab</literal> dosyasında yeralan bilgilerle
        uzak makinanın diski otomatik olarak paylaştırılabilir. Mount programı
        bazı seçenekleri destekler. Bu seçenekler <literal>-o</literal> yardımıyla
        komut satırında verilebildiği gibi <literal>/etc/fstab</literal> içinde de
        belirtilebilir. Her iki durumda da birden fazla seçenek kullanılırsa
        bunlar birbirlerinden virgülle ayrılırlar.
      </para><para>
        Açılış sırasında <emphasis>news</emphasis> makinasındaki <literal>/usr/spool/news</literal>
        dosyasını yerel makinadaki <literal>/usr/spool/news</literal> dizini altına
        yerleştiren <literal>/etc/fstab</literal> satırı
      </para><para>
<screen>
news:/usr/spool/news  /usr/spool/news   nfs   timeo=20
</screen>
      </para><para>
        şeklinde yazılır. NFS ile kullanılan timeo seçeneğinin karşısında yeralan
        sayı (saniyenin onda biri olarak), bağlantının kurulabilmesi için geçecek
        maksimum zamanı gösterir. Bu zamanın aşılması halinde sunucuyla bağlantı
        kesilir.
      </para>
    </sect2><sect2>
      <title>NFS Kurulumu</title>
      <para>
        Yerel makinanın sunucu olabilmesi için nfsd ve mountd programlarının
        çalıştırılması gerekir. Bu yazılımlar açılış esnasında aşağıda görülen
        <literal>/etc/rc.d/rc.inet2</literal> dosyasından başlatılırlar. <literal>telnetd</literal>,
        <literal>fingerd</literal> ve benzeri süreçlerin aksine bu iki program <literal>inetd</literal>
        tarafından yönetilmezler. Dikkat etmeniz gereken bir durum da <literal>nfsd</literal>
        ve <literal>mountd</literal> programlarının <literal>rpc.portmap</literal> programından sonra
        çalıştırılması gerektiğidir:
      </para><para>
<screen>
if [ -x /usr/sbin/rpc.mountd ]; then
# (rpc.mountd programi var ve calistirilabilir mi ?)
        /usr/sbin/rpc.mountd; echo -n &quot; mountd&quot;
fi
if [ -x /usr/sbin/rpc.nfsd ]; then
# (rpc.nfsd programi var ve calistirilabilir mi ?)
        /usr/sbin/rpc.nfsd; echo -n &quot; nfsd&quot;
fi
</screen>
      </para><para>
        Sunucunun hangi dizinlerini, hangi istemci(ler) tarafından
        paylaşılabileceği <literal>/etc/exports</literal> dosyasında belirtilir. Örnek
        bir exports dosyasının görünümü aşağıdaki gibidir:
      </para><para>
<screen>
/home            davul.cclub.metu.edu.tr, ordek.cclub.metu.edu.tr
/usr/ftp         (ro)
/cdrom           *.edu.tr
</screen>
      </para><para>
        Her satır, yerel makinadaki dizin ismi ile başlar, bu dizini mount etmeye
        izin verilen bilgisayar isimleri ile devam eder. Makina isimlerinde
        ? veya * joker karakterleri kullanılabilir. Dosyanın üçüncü satırı, sonu
        .edu.tr ile biten tüm makinaların <literal>/cdrom</literal> dizinine ulaşabileceğini
        belirtir.
      </para><para>
        Aynı dizini paylaşacak birden fazla makina adı, aralarında virül konarak
        yazılabilir. Parantez içinde yeralan ro kelimesi, dizinlerin salt okunur
        mount edilmesi gerektiğini belirtir.
      </para><para>
        Daha geniş bilgi için <literal>mount</literal> programının man dosyasına göz
        atmanızı tavsiye ederim.
      </para>
    </sect2>
  </sect1>
  <sect1 id="archive-tlkg-lis-8.7">
    <title>Uzaktan Bağlantı Kurulması</title>
    <para>
      İnternet üzerinde kesinlikle yanlız olmadığınıza göre, kimi durumlarda
      kendi Linux'unuz dışındaki sistemlere girmek isteyeceksiniz. Bunun için
      uyarlanmış çeşitli komutlar mevcuttur. Bu komutlar sadece bağlanmak için
      değil, iki makina arasında birtakım dosya transferi gerçekleştirmek için
      de kullanılabilir.
    </para><para>
      Linux (ve UNIX) için ağ uygulamalarında kullanılmak üzere geliştirilen
      temel olarak iki sistem vardır. Bunlardan <command>UUCP</command> (Unix to Unix CoPy),
      genel olarak iki makina arasında bir kere bağlantı kurup veriyi iletir
      ve bağlantıyı kapatır. Eski bir protokol olan UUCP, genellikle modemler
      arası veri iletişiminde işe yarar.
    </para><para>
      TCP/IP ise daha önce de belirtildiği gibi yerel ağ veya İnternet üzerinde
      rahatlıkla kullanılabilen bir protokoldür. TCP / IP 'nin uzaktan bağlantı
      komutları "r" harfi ile başlar. Örneğin <literal>rlogin</literal> (remote login) bir
      sistemden diğerine telnet bağlantısı yaparken <literal>rcp</literal> (remote copy)
      ise bir makinadan diğerine dosya kopyalar. Bu ve buna benzer uzaktan
      bağlantı komutları iyi bilmeniz size çalışmalarınız sırasında zaman
      kazandıracaktır.
    </para><para>
      "<literal>r</literal>" komutlarını kullanabilmeniz için kesinlikle TCP/IP protokolünü
      tanıyan bir ağ (PPP, Ethernet, SLIP gibi) üzerinde olmalısınız.
    </para><para>
      <command>rlogin</command> : Geçerli bir hesabınızın olduğu makinaya girmenizi
      sağlar. telnet komutuyla benzerlik gösterir. Ayrıldıkları nokta, karşıdaki
      sisteme girerken gerekli yaıplandırmalar yapılırsa parola sormamasıdır. Bu
      kısma ileride değineceğim.
    </para><para>
      Aşağıdaki komut ile ordek isimli makinaya giriş yapılıyor.
    </para><para>
<screen>
$ rlogin ordek
</screen>
    </para><para>
      Eğer yukarıdaki gibi yazarsanız, ordek makinasına ait IP numarası
      veya bu adresin tam isminin, örneğin <literal>ordek.cclub.metu.edu.tr/etc/hosts</literal> dosyasında yeraldığına emin olmanız gerekir. Karşı
      makinada bağlanılacak kullanıcı ismi de komut satırından belirlenebilir.
    </para><para>
<screen>
cclub:~$ rlogin ordek -l httpd
Password:
Last login: Fri Feb 21 22:02:46 from cclub.metu.edu.tr
Linux 2.0.27.
ordek:~$
</screen>
    </para><para>
      Yukarıda yaptığımız, cclub makinasından ordek isimli makinadaki httpd
      kullanıcısına bağlanmak oldu. Üzerinde Linux çalışan ordek makinası doğal
      olarak bana bu kullanıcıya ait parolayı sordu. ordek makinasında yeralan
      bir dosya üzerinde değişiklik yaparak istersem parola sorulmadan anında
      girilmesini sağlayabilirim. Bunu <literal>.rhosts</literal> (remote hosts)
      dosyası sağlar.
    </para><para>
      <literal>.rhosts</literal> dosyasında makinaya bağlanabilecek olan kullanıcılar
      ve bunların hangi makinalardan bağlanacaklarını gösteren bir liste
      vardır. Biraz karışık mı oldu? Şu örneği inceleyelim:
    </para><para>
<screen>
ordek:~$ uname -a
Linux ordek 2.0.27 #1 Sun Jan 19 13:06:08 EET 1997 i486
ordek:~$ whoami
httpd
ordek:~$ cat ~/.rhosts
cclub.metu.edu.tr gorkem
</screen>
    </para><para>
      Yukarıda ördek makinası üzerindeki httpd kullanıcısının çalışma dizininde
      bulunan <literal>.rhosts</literal> dosyasında iki sütun yeralıyor. İlki, güvenilen
      makinanın ismi (cclub.metu.edu.tr), ikincisi de bu makina üzerindeki
      güvenilen kullanıcı (gorkem). <literal>.rhosts</literal> dosyası parolanızı başkalarına
      vermeden istediğiniz makinadaki bir kullanıcının hesabınızı kullanmasını
      sağlar. Kısaca bir satırda herhangi bir kullanıcının makina ismi ve
      hesap ismi bu dosyada varsa, sisteme giriş izni verilir.
    </para><para>
      Bu aşamadan sonra cclub.metu.edu.tr adresindeki gorkem kullanıcısı parola
      girmeden ordek.cclub.metu.edu.tr adresindeki httpd kullanıcısı olarak
      çalışmak isterse yapması gereken:
    </para><para>
<screen>
cclub:~$ whoami
gorkem
cclub:~$ rlogin ordek.cclub.metu.edu.tr -l httpd
Last login: Sun Feb 23 11:19:04 from cclub.metu.edu.tr
Linux 2.0.27.
ordek:~$
</screen>
    </para><para>
      Artık ordek makinası üzerindeyiz. Parola girmeden bir makinadan diğerine
      atlamış olduk. <literal>.rhosts</literal> dosyasında eğer makina ismi yerine "+"
      işareti kullanılırsa her makinanın veya kullanıcı ismi yerine "+" işareti
      kullanılırsa her kullanıcının giriş izni olduğu anlaşılır. Makina isimleri
      yerine IP adreslerini de kullanabilirsiniz. Birkaç örnek:
    </para><para>
<screen>
144.122.71.55  +
# (144.122.71.55 makinasi uzerindeki tum kullanicilara giris izni ver)
+ murat
# Butun makinalar uzerindeki murat kullanicilarina giris izni ver.
# (Cok buyuk bir guvenlik acigi)
</screen>
    </para><para>
      <command>rsh</command> : Bazı durumlarda çalıştığınız makinada dışındaki bir sistemde
      bir veya birkaç kısa komut çalıştırmak isteyebilirsiniz. Örneğin karşı
      sistemde kimler, hangi işleri yapıyor veya çalışma dizininde yeralan
      dosyaları görmek gibi. Bütün bunlar telnet veya rlogin programına gerek
      duymadan <literal>rsh</literal> (remote shell) ile yapılabilir. Tek şart, üzerinde komut
      işletilecek makinadaki <literal>.rhosts</literal> dosyasında gerekli makina ve kullanıcı
      ismi girişi olmasıdır.
    </para><para>
      Diyelim ki <command>davul.cclub.metu.edu.tr</command> makinası üzerindeki
      <literal>/home/gorkem</literal> dizininde yeralan tüm dizin ve dosyaları görmek
      için:
    </para><para>
<screen>
$ rsh davul.cclub.metu.edu.tr ls -al /home/gorkem
</screen>
    </para><para>
      komutunu girmelisiniz. <literal>rsh</literal> komutundan sonra uzaktaki sistemin ismi,
      ardından da çalıştırılacak olan komut gelmelidir. Diğer bir örnek
    </para><para>
<screen>
$ rsh davul.cclub.metu.edu.tr cat README | lpr
</screen>
    </para><para>
      karşı sisteme giriş yapmadan <literal>README</literal> dosyasını yazıcıdan çıkmasını
      sağlayacaktır.
    </para>
  </sect1>
  <sect1 id="archive-tlkg-lis-8.8">
    <title>Linux'ta Örnek Ağ Uygulamaları</title>
    <para>
      Aşağıda, Linux ile gerçekleştirilebilecek birkaç örnek ağ uygulamaları
      yeralmaktadır. Her konu ile ilgili ayrıntılı bilgileri
      <emphasis>HOWTO</emphasis> dosyalarından öğrenebilirsiniz.
    </para>
    <sect2>
      <title>IP Accounting</title>
      <para>
        <emphasis>IP accounting</emphasis> özelliği, çekirdeğin ağ üzerindeki trafiğin analizini yapmasını
        sağlar. Toplanan veriler, makinanın açıldığı andan itibaren kart üzerinden geçen
        paket ve toplam bayt sayısıdır. Bir yapılandırma dosyası yardımıyla bu bilgiler
        belirli sınıflara ayrılabilir. Çekirdeğin derlenmesi aşamasında IP accounting
        seçeneği kullanılmalıdır.
      </para><para>
<screen>
* Networking options
...
IP: accounting (CONFIG_IP_ACCT) [N/y/?] y
</screen>
      </para><para>
        Çekirdeğin derlenmesinden ve makinanın yeni çekirdekle açılmasından sonra,
        <literal>ipfwadm</literal> komutu ile IP accounting işlemlerine başlanabilir. ipfwadm
        paketi standart Slackware dağıtımı ile beraber gelmektedir.
      </para>
    </sect2><sect2>
      <title>IP Aliasing</title>
      <para>
        Tek ağ arabirimi (örneğin ethernet veya seri bağlantı) kartı için birden fazla IP numarası
        gereken durumlarda IP Aliasing kullanılır. Genellikle İnternet Servis
        Sağlayıcıları, müşterilerinin ftp ve www sunucularını tek makina
        üzerinde toplamak için bu yola başvururlar. Bu sayede bir makinaya atanmış
        birden fazla www adresi ve herbirinin ayrı html dosyaları farklı makinalardaymış
        gibi kullanılabilir.
      </para><para>
        Bu özellikten yararlanabilmek için çekirdekte IP Aliasing desteği vermelisiniz.
      </para><para>
<screen>
*
* Networking options
...
Network aliasing (CONFIG_NET_ALIAS) [N/y/?] y
...
IP: aliasing support (CONFIG_IP_ALIAS) [N/y/m/?] y
</screen>
      </para><para>
        Her sanal ağ adresi için bir <emphasis>arabirim</emphasis> (interface) tanımlamalısınız. Bu sayede
        aynı bilgisayarda 255 adede kadar sanal makinaya izin verilebilir. Her sanal
        arabirim, bağlı bulunduğu gerçek arabirim üzerinden işgörür.
      </para><para>
        Örnek olarak, elimizde kullanabileceğimiz ikinci adres (örnek olarak
        100.100.100.101) ve tek ethernet kartı bulunsun. İnternet
        üzerindeki diğer makinaların, bu iki adrese ulaşabilmeleri için şu satırlar
        yeterli olacaktır:
      </para><para>
<screen>
# ifconfig eth0:0 100.100.100.101 netmask 255.255.255.0 up
# route add -net 100.100.100.0 netmask 255.255.255.0 eth0:0
</screen>
      </para><para>
        Sanal bir arabirimi kaldırmak için ise, ismin sonuna '-' karakteri getirmek
        yeterli olur.
      </para><para>
<screen>
# ifconfig eth0:0- 0
</screen>
      </para>
    </sect2><sect2>
      <title>IP Maskelemesi</title>
      <para>
        IP Maskelemesi, bir ağın arkasındaki birden fazla makinanın bir Linux
        üzerinden dışarıya bağlanmasıdır. Tüm makinalar dışarıdan aynı IP adresi
        gibi görünürler.
      </para><para>
        Örnek olarak İnternet'e bağlandınız. İnternet Servis Sağlayıcınız size
        sadece bir IP numarası verdi ve odanızda İnternet'e bağlanmayı bekleyen
        birden fazla bilgisayar var. Servis Sağlayıcıya her makina için para
        ödeyip bir hesap ismi almaktansa odadaki tüm makinalar bir Linux ve telefon
        bağlantısı yardımıyla İnternet'e erişebilirler.
      </para><para>
        IP Maskelemesi kullanabilmek için çekirdekte bu desteğin verilmesi gerekiyor.
        Bunun için IP Forwarding, IP Firewalling ve IP Masquerading seçeneklerini
        açık tutmalısınız.
      </para><para>
        IP Maskelemesi için gerekli yazılımlar Slackware dağıtımı ile birlikte
        gelmektedir.
      </para>
    </sect2><sect2>
      <title>SAMBA (NetBEUI ve NetBios desteği)</title>
      <para>
        SMB,  Windows 3.11, NT ve 95 tarafından kullanılan ve disk ve yazıcı
        paylaşımına olanak veren bir protokoldür. Linux, Samba desteği ile bu işletim
        sistemleri veya kendi üzerinde bulunan disk ve yazıcıların tüm makinalar
        tarafından paylaşılmasını sağlar.
      </para><para>
        Samba ile 4 işlem gerçekleştirilebilir: Windows makinalarının Linux diskini
        paylaşmaları, Linux makinalarının Windows sistemi diskini paylaşmaları, Windows
        makinalarının Linux yazıcısını paylaşmaları ve Linux makinalarının Windows
        yazıcısını paylaşmaları.
      </para><para>
        Yine bu özelliği kullanabilmek için çekirdekte Samba desteği vermeniz
        gerekecektir.
      </para><para>
<screen>
SMB filesystem support (to mount WfW shares etc..) (CONFIG_SMB_FS) [Y/m/n/?]
</screen>
      </para><para>
        <emphasis>smbfs</emphasis>, SMB protokolünü tanıyan dosya sistemine verilen isimdir.
        smbfs servisi verebilmek için smbfs.tgz paketini indirip derlemelisiniz.
      </para><para>
        <emphasis>smbfs.tgz</emphasis> paketini
        <ulink url="ftp://ftp.metu.edu.tr/pub/linux/suniste/systems/filesystems/smbfs/">ftp.metu.edu.tr</ulink>
        adresinden bulabilirsiniz.
      </para>
    </sect2><sect2>
      <title>Novell Desteği</title>
      <para>
        NCP (NetWare Core Protocol), IPX üzerinde yeralan ve Novell NetWare
        istemcilerinin sunucularla konuşmasını sağlayan protokole verilen isimdir.
        Bu seçenek ile, NetWare dosya sunucularına diğer Unix makinalardaki
        gibi bağlanmak olasıdır.
      </para><para>
        NetWare dosya sistemlerine erişebilmek için özel bir mount programı
        (<literal>ncpmount/ncpumount</literal>) kullanmanız gerekecektir. Bu ve diğer programlar,
        <ulink url="ftp://ftp.metu.edu.tr/pub/linux/sunsite/system/filesystems/ncpfs">ncpfs</ulink>
        paketinin içinde vardır. Bunun için çekirdekte
      </para><para>
<screen>
The IPX protocol (CONFIG_IPX) [Y/m/n/?]
</screen>
      </para><para>ve</para><para>
<screen>
NCP filesystem support (to mount NetWare volumes) (CONFIG_NCP_FS) [Y/m/n/?]
</screen>
      </para><para>
        desteğini vermelisiniz.
      </para><para>
        <emphasis>lwared</emphasis> ve <emphasis>mars_nwe</emphasis> paketleri, Linux İşletim Sistemi'ne Novell sunucu
        olma özelliği verir.
      </para>
    </sect2><sect2>
      <title>Apple Desteği</title>
      <para>
        Aynı ağ üzerinde yeralan Apple Macintosh makinaları ile aynı disk ve yazıcıların
        paylaşımını sağlayan pakete <emphasis>netatalk</emphasis> ismi verilir. Bu desteği kullanabilmek
        için çekirdeğin derlenmesi sırasında
      </para><para>
<screen>
IP: multicasting (CONFIG_IP_MULTICAST) [Y/n/?]
...
The IPX protocol (CONFIG_IPX) [Y/m/n/?]
...
Appletalk DDP (CONFIG_ATALK) [Y/m/n/?]
</screen>
      </para><para>
        parametrelerine evet cevabı vermelisiniz. Appletalk için daha fazla bilgiye
        ve disk ile yazıcı paylaşımı yapan pakete
        <ulink url="http://www.umich.edu/~rsug/netatalk"
        >http://www.umich.edu/~rsug/netatalk</ulink> adresinden erişebilirsiniz.
      </para>
    </sect2>
  </sect1>
  <sect1 id="archive-tlkg-lis-8.9">
    <title>NIS</title>
    <para>
      NIS Network Information Service kelimelerinin baş harflerinden
      oluşmaktadır. Amacı bir ağ üzerindeki bütün makinalara, bütün ağ
      tarafından bilinmek kaydıyla bilgi akışı sağlamaktır. NIS tarafından
      dağıtılacak bilgiler, hesap isimleri, parolalar, kullanıcı dizinleri
      ve grup bilgileri olabilir.
    </para><para>
      NIS yardımıyla, örneğin size ait parola NIS veri tabanında kayıtlı ise,
      ağ üzerinde NIS istemci programlarını çalıştıran bütün makinalara
      girebilirsiniz.
    </para><para>
      NIS'in biraz daha gelişmiş bir sürümü olan NIS+ , verileri korumak
      amacıyla şifreleme yöntemi kullanır. Bu avantajına rağmen NIS+ 'ın
      kurulumu ve kullanımı daha zordur.
    </para>
    <sect2>
      <title>NIS'in Çalışma Prensipleri</title>
      <para>
        Bir ağ üzerinde en az bir makina NIS sunucusu olmak
        zorundadır. İster herbiri farklı NIS ``domain'' lerine hizmet eden çoklu NIS
        sunucularına sahip olabilirsiniz ya da beraber çalışan NIS sunucularınız
        olur. Bu durumda sunuculardan biri ana NIS sunucusu, diğerleri ise
        ikincil (slave) NIS sunucusu olabilirler.
      </para><para>
        İkincil sunucular sadece NIS veritabanının kopyalarına sahiptirler ve bu
        kopyaları ana NIS sunucusunda bulunan veri tabanlarında değişiklik yapıldığı
        zaman ana sunucudan alırlar. Ağ üzerinde bulunan makina sayısına ve
        ağ güvenliğine bağlı olarak bir veya daha fazla ikincil sunucu
        kurulabilir. Bir NIS sunucusu kapandığında veya çok yavaş cevap
        verdiğinde, diğer NIS istemcileri çalışan veya daha hızlı bir
        sunucu bulmaya çalışacaktır.
      </para><para>
        NIS veritabanları DBM adı verilen yapıdadır ve bu yapı ASCII
        veritabanlarından çıkarılır.
        Ana NIS sunucusu hem ASCII veritabanlarını hemde DBM
        veritabanlarını içermelidir. NIS sunucusu, ASCII yapıdaki <literal>/etc/passwd</literal>
        gibi veri tabanlarını DBM veri tabanına çevirerek <literal>/var/yp</literal> dizini
        altında tutar.
      </para><para>
        İkincil sunucular NIS haritalarında oluşacak değişikliklerden <literal>yppush</literal>
        programı aracılığıyla haberdar edilecek ve veritabanlarını senkronize
        etmek için otomatik olarak gereken değişiklikleri alacaklardır. NIS
        istemcilerinin bunu yapmasına gerek yoktur çünkü sunucudaki DBM
        veritabanlarında bulunan bilgileri okumak için devamlı olarak NIS sunucusu
        ile bağlantı kurmaktadır. İkincil sunuculara gayet büyük ağlar üzerinde
        ihtiyaç duyulur.
      </para>
    </sect2><sect2>
      <title>NIS İstemcisi</title>
      <para>
        NIS'i kurmak için herşeyden önce <literal>/usr/sbin/rpc.portmap</literal>
        programını çalıştırmanız gerekir. Bazı Linux dağıtımları (örneğin
        Slackware) bu daemon'u çalıştırmak için gereken kodu <literal>/etc/rc.d/rc.inet2</literal>
        dosyasında barındırırlar.
      </para><para>
        RPC portmapper (<literal>man 8 portmap</literal>) programı bir sunucu olup RPC program
        numaralarını TCP/IP (veya UDP/IP) protokol port numaralarına çevirir. RPC
        portmapper o makina üzerinde RPC çağrılarını (NIS istemci yazılımının
        yaptığı iş) RPC sunucularına (NIS sunucuları gibi) yapılabilmesi için
        çalışıyor olmalıdır. Bir RPC sunucusu başladığı zaman, portmap'a hangi
        port numarasını dinlediğini ve hangi RPC program numaralarına hizmet
        edeceğini bildirir. Bir istemci verilen bir program numarasına RPC
        çağrısı yapmak istediği zaman, ilk önce sunucu makina üzerindeki portmap
        ile bağlantı kurarak RPC paketlerinin nereye gönderileceğini belirler.
      </para><para>
        Normal olarak, bazı RPC sunucuları <emphasis>inetd(8)</emphasis> tarafından başlatılır,
        bu yüzden portmap, inetd'den önce çalıştırılmalıdır.
      </para><para>
        NIS kurmadan önce, yukarıda da belirtildiği gibi iki durumu değerlendirmek
        zorundasınız. Ya sizin makinanız halihazırdaki NIS sunucularının
        bulunduğu bir ağın parçası olacaktır ya da henüz ağınızda herhangi bir
        NIS sunucusu yoktur.
      </para><para>
        Birinci durumda, sadece istemci programlara (<literal>ypbind, ypwhich, ypcat,
        yppoll, ypmatch</literal>) ihtiyacınız vardır.  En önemli program
        <literal>ypbind</literal>'dır. Bu programı her zaman çalıştırıyor olmalısınız.
        <literal>ypbind</literal> çalışır çalışmaz, makinanız bir NIS
        istemcisi durumuna gelir.
      </para><para>
        İkinci durumda, eğer NIS sunucularınız yoksa, bir de NIS sunucu programına
        (<literal>ypserv</literal>) ihtiyacınız vardır.
      </para>
    </sect2><sect2>
      <title>NIS İstemcisi Kurulması</title>
      <para>
        Slackware dağıtımıyla gelen NIS yazılımını daha önce kurmamışsanız,
        sisteminize yükleyin. NIS istemcisi için <literal>ypbind</literal> dışındaki
        çalıştırılabilir dosyalar (<literal>ypwhich, yppoll, ypmatch</literal>)
        bütün kullanıcılar tarafından erişilebilir bir dizinde bulunmalıdır.
        Öncelikle yapılması gereken <literal>ypbind</literal>'ı test etmektir. Bunun için,
      </para><para>
        <itemizedlist>
          <listitem><para>
            Domain adınızı belirlediğinizden emin olun. Bunun için,
          </para><para>
<screen>
/bin/domainname-yp nis.domain
/bin/domainname-yp &gt; /etc/defaultdomain
</screen>
          </para><para>
            komutunu girin. İkinci satırda, sistemde daha sonra kullanılmak üzere
            <literal>/etc/defaultdomain</literal> dosyasına domain adı yazılır. Yukarıdaki komutta
            <emphasis>nis.domain</emphasis> herhangi bir kelime olabilir.
          </para></listitem>
          <listitem><para>
            Eğer çalışmıyorsa <literal>/usr/sbin/rpc.portmap</literal> programını çalıştırın.
          </para></listitem>
          <listitem><para>
            <literal>/usr/sbin/ypbind</literal> programını çalıştırın.
          </para></listitem>
          <listitem><para>
            <literal>rpcinfo -p localhost</literal> komutunu kullanarak <literal>ypbind</literal>
            programının <literal>portmapper</literal>'da servislerini kayıt ettirdiğini kontrol
            edin. <literal>rpcinfo</literal> şöyle bir çıktı üretmelidir:
          </para><para>
<screen>
program vers    proto   port
100000  2       tcp     111     portmapper
100000  2       udp     111     portmapper
100007  2       udp     637     ypbind
100007  2       tcp     639     ypbind
300019  1       udp     660
</screen>
          </para></listitem>
          <listitem><para>
            Ayrıca <literal>rpcinfo -u localhost ypbind</literal> komutunu da
            çalıştırabilirsiniz. Bu komut ise şöyle bir çıktı verir:
          </para><para>
<screen>
program 100007 version 2 ready and waiting
</screen>
          </para></listitem>
          <listitem><para>
            En son olarak, makina isim taramaları (host lookup) için
            <literal>/etc/host.conf</literal>
            dosyasında lookup sırasına nis bilgisini ekleyin. Bu dosyada yeralan
            <emphasis>order</emphasis> satırını istediğiniz gibi düzenleyebilirsiniz.
            Daha fazla bilgi için <emphasis>resolv(8)</emphasis> man sayfasına bakın.
          </para><para>
<screen>
$ cat /etc/host.conf
order nis, bind, hosts
multi on
</screen>
          </para></listitem>
        </itemizedlist>
      </para><para>
        Bu noktadan sonra <literal>ypcat</literal>, vb gibi NIS istemci programları
        kullanılabilir. Örneğin, <literal>ypcat passwd</literal> komutu bütün NIS
        parola veritabanını gösterir.
      </para><para>
        Şimdi sistemde bulunan <literal>/etc/rc.d/rc.inet2</literal> dosyasını ypbind
        programının sistem açılırken çalışması ve sisteminizin bir NIS istemcisi olarak görev yapması için değiştirmek gerekir. Ayrıca, <literal>/etc/rc.d/rc.inet2</literal> dosyasını açın ve <literal>ypbind</literal>'ı çalıştıran ve
        domain adını belirleyen satırların başındaki # işaretini kaldırın.
      </para><para>
<screen>
# domainname

if [ -r /etc/defaultdomain ] ; then
domainname-yp `cat /etc/defaultdomain`
fi

# Start the ypbind daemon

if [ -f ${NET}/ypbind -a -d /var/yp ]; then
  echo -n &quot; ypbind&quot;
  ${NET}/ypbind
fi
</screen>
      </para><para>
        NIS'i çalıştırmak için <literal>/etc/passwd</literal> ve <literal>/etc/group</literal>
        dosyalarının sonuna ``+:*:0:0:::'' satırını ekleyin. <literal>ypbind</literal>'ı
        öldürüp yeniden çalıştırın.
      </para>
    </sect2><sect2>
      <title>NIS Sunucusu Kurulması</title>
      <para>
        NIS aracılığı ile kullanıma açık olacak dosyalardan ihtiyacınız
        olanların belirlenmesi gerekir. <literal>/var/yp/Makefile/</literal> dosyasında
        gerekli ekleme/çıkartmaları yapın.

        NIS veri tabanını aşağıdaki satırı yazarak oluşturun:
      </para><para>
<screen>
$ cd /var/yp; make
</screen>
      </para><para>
        Bu programın çalıştırılmasından sonra <literal>/var/yp</literal> dizini
        altında NIS domain adıyla bir dizin yaratılır ve tüm veri tabanları
        burada tutulur. <literal>portmapper</literal> programının (<literal>rpc.portmap</literal>) çalıştığından emin olduktan sonra <literal>ypserv</literal> sunucusunu çalıştırın. <literal>rpcinfo</literal> komutu
        ile <literal>ypserv</literal>'in çalışmasını kontrol edin.
      </para><para>
<screen>
$ rpcinfo -u localhost ypserv
program 100004 version 2 ready and waiting
</screen>
      </para><para>
        Artık sunucu çalışmaktadır.
      </para>
    </sect2><sect2>
      <title>yppasswdd Programı</title>
      <para>
        NIS parola veritabanının güvenilir olması için ``yppasswd daemon'' gereklidir.
        Kullanıcılar <literal>yppasswd</literal> komutu yardımıyla sunucu üzerindeki parolalarını
        değiştirebilirler. <literal>yppasswd daemon</literal> (kısaca <literal>yppasswdd</literal>) bu
        değişikliklerin doğru bir şekilde yapılmasını ve bu parola değiştirme
        sürecini kontrol eden sunucudur.
      </para>
    </sect2><sect2>
      <title>NIS'in Kontrol Edilmesi</title>
      <para>
        NIS, birkaç basit komut ile kontrol edilebilir.
      </para><para>
<screen>
$ ypwhich
</screen>
      </para><para>
        <literal>ypwhich</literal> NIS sunucusunun hangi makina olduğunu söyleyecektir.
        Bu komut ise
      </para><para>
<screen>
$ ypmatch userid passwd
</screen>
      </para><para>
        (<emphasis>userid</emphasis> herhangi bir kullanıcının login adı olmak kaydıyla) size bu
        kullanıcının NIS parola dosyasındaki bilgilerini verir. <literal>ypwhich</literal> ve
        <literal>ypmatch</literal> programları NIS dağıtımı içinde gelirler.

        Bir NIS sunucusu kapandığı ve tekrar başladığı zaman <literal>ypbind</literal> aşağıdaki
        gibi bir mesaj ile başlayabilir:
      </para><para>
<screen>
yp_match: clnt_call:RPC: Unable to receive; errno = Connection refused
</screen>
      </para><para>
ve NIS veritabanında kayıtlı olanlar sisteme giremezler. root olarak
sisteme girmeyi deneyin ve başarılı olursanız <literal>ypbind</literal> işlemini
öldürüp yeniden başlatın.
      </para>
    </sect2>
  </sect1>
</chapter>

<chapter id="archive-tlkg-lis-9">
  <title>DNS (Alan İsimlendirme Sistemi)</title>
  <sect1 id="archive-tlkg-lis-9.1">
    <title>Giriş</title>
    <para>
      Bilgisayar  ağlarının  günümüzde  oldugu  kadar  yaygın  olmadığı
      dönemlerde makina,  sunucu,  yazıcı  vb. ağ üzerindeki cihazlara ilgili
      sayısal adresleri ile erişmek  kullanıcılar  için fazla zor  değildi.
      İnternet'in  beklenenden  daha  hızlı  büyümesiyle birlikte artan
      kullanıcı ve ağ  üzerindeki  cihazlarla  birlikte sayısal isimler
      yerine   alfanümerik hatırlanması  kolay bir  yapı geliştirildi.  Bu
      yapıya  Alan  İsimlendirme Sistemi (Domain Name System)  adı
      verilmektedir. Genellikle kısaltılmış şekliyle DNS  olarak da
      kullanılmaktadır.
    </para><para>
      Alan isimleri verilirken alt isimler (subdomain) genelden  özele  doğru
      sıra izler. Örneğin, Türkiye Linux Kullanıcıları Grubu olarak ODTÜ'de yer alan
      kullanıcıların kullanabileceği alan adı,
    </para><para>
      <literal> metu.linux.org.tr </literal>
    </para><para>
      şeklindedir. Burda alt isim (.) ile  birbirinden  ayrılmıştır.
      En  alt  seviye  olan 'metu' ODTÜ'de yer alan Linux kullanıcılarını,
      'linux' Linux  grubunu,  'org'  Linux  grubunun ticari  kaygılar
      gütmeyen  bir organizasyon olduğunu, 'tr' ise ISO tarafından  belirlenen
      Türkiye'nin  ülke  kodudur.
    </para><para>
      En üst düzeydeki bazı alan isimleri asağıda listelenmiştir.
    </para><para>
      <orderedlist>
        <listitem>  .com            ticari  kuruluşlar (commercial)</listitem>
        <listitem>  .edu            üniversite düzeyindeki eğitim  kurumları  (educational)</listitem>
        <listitem>  .k12            lise düzeyindeki eğitim kurumları</listitem>
        <listitem>  .org            ticari olmayan organizasyonlar</listitem>
        <listitem>  .mil            askeri kuruluşlar (military)</listitem>
        <listitem>  .net            ağ  organizayonları  (network)</listitem>
        <listitem>  .ülke kodu      ISO tarafından belirlenen ülke kodu</listitem>
      </orderedlist>
    </para>
  </sect1>
  <sect1 id="archive-tlkg-lis-9.2">
    <title>TCP/IP uygulamaları ve DNS</title>
    <para>
      Makinalara ait isimlerin sayısal adresleri yerine  alfanümerik
      isimlerin kullanılmasıyla birlikte  DNS  standart  bir  hale gelmiş
      olup İnternet üzerindeki çoğu uygulamalarda doğrudan alan
      isimleri kullanılmaktadır.  TCP/IP uygulamalarında ise alan isimleri
      günlük kullanımda IP (32-bitlik) adreslerinin yerini  almış
      durumdadır.  Örneğin,  <literal>metu.linux.org.tr</literal>'a telnet bağlantısı
      yapabilmek için hem,
    </para><para>
<screen>
$ telnet metu.linux.org.tr
</screen>
    </para><para>komutu</para><para>
<screen>
$ telnet 144.122.199.199
</screen>
    </para><para>
      komutu yardımıyla ulaşabilirsiniz.  Fakat  herhangi  bir  şekilde
      ODTÜ'de  yeralan <literal>metu.linux.org.tr</literal> sunucusunun  IP
      adresinde değişiklik olursa yukarıdaki IP adresini kullanarak
      erişemezsiniz.  Oysa IP adresi yerine <literal>metu.linux.org.tr</literal>
      sunucusuna bağlanırken alan adını kullanırsanız bu ve benzeri
      değişiklikler sizi etkilemez.
    </para><para>
      Şimdi  kabaca   herhangi   bir   kullanıcının   <literal>metu.linux.org.tr</literal>
      adresine bağlanmak   istediğinde   gerçeklesen   DNS   sorgusunun   nasıl
      işlediğini  ve   Türkiye'deki  yapıyı  da   anlatacak   şekilde
      örnekleyelim.
    </para><para>
      Örneğin, Amerika'da herhangi bir İnternet Servis Sağlayıcısı'ndan (İSS)
      bağlantı yapan bir kullanıcı <literal>http://www.linux.org.tr</literal>
      adresine  bağlanmak  istedi.  Kullanıcının  bu  adresi  tarayıcısına
      girmesinden itibaren öncelikli olarak kendi  alan adı sunucusuna (name
      server)  bu adrese karşılık gelen IP adresini bulmak için gerekli
      sorguyu yollayacaktır.  Kendi  alan adı sunucusu en üst düzeyde yer
      alan <literal>.tr</literal>'ı gördüğü  andan  itibaren  bu  sorguya  kendinin  yanıt
      veremeyeceğini anlayıp  bir üst alan adı sunucusuna ilgili sorguyu
      yollacaktır. Türkiye'nin alan adı sunucusunun <literal>knidos.cc.metu.edu.tr</literal> olduğu
      bilgisini aldığı andan itibaren sorguyu bu kez <literal>knidos.cc.metu.edu.tr</literal>
      sunucusuna gönderecek ve buradan da <literal>linux.org.tr</literal> alanına ait
      bilgilerin <literal>metu.linux.org.tr</literal>
      sunucusunda tutulduğunu öğrenecek. Nihayet son sorgu
      <literal> metu.linux.org.tr</literal> sunucusuna yollanacak ve buradan da
      <literal>www.linux.org.tr</literal>
      adresine karşılık gelen IP adresini öğrenecek.
    </para>
  </sect1>
  <sect1 id="archive-tlkg-lis-9.3">
    <title>BIND Yapılandırması</title>
    <para>
      BIND, Linux dağıtımlarının hepsi ile gelen ve
      alan adı sorgularına yanıt veren yazılım paketidir.
      Açılımı Berkley Internet Domain Name şeklindedir.
    </para><para>
      Doğrudan Linux kurulu olan bir sunucu üzerindeki BIND
      yapılandırmasına  geçmeden  DNS  ile  ilgili  temel birkaç konudan
      bahsetmekte fayda var.   DNS  ile  ilgili
      yazılımları   <emphasis>istemci</emphasis> ve <emphasis>sunucu</emphasis> olarak ikiye
      ayırmak daha doğru  olur:
    </para><para>
      Sunucu, istemciden gelen sorgulara yanıt veren ve sürekli çalışan
      bir  işlem  olup  BIND  paketinden  çıkan <literal> named </literal> yazılımı bu işi
      görür. İstemcilerse Linux dağıtımlarıyla  gelen  <literal>host</literal>,  <literal>nslookup</literal>
      vb. programlar olup  sorguyu  yapan  yazılımlardır.  Bununla  birlikte BIND
      yapılandırmasında sıklıkla karşımıza çıkacak olan  birkaç  kavram
      aşağıda açıklanmaktadır. Yeri  geldikçe  diğer  kavramlara da
      değinilecektir.
    </para><para>
      <variablelist>
        <varlistenry>
          <term>primary name server </term>
          <listitem><para>
            O alana ait bütün  bilgilerin  bulunacağı
            sunucu  olup  bu amaçla yapılandırılmış sunucudur. ``primary name server''
            bir alan için ancak bir  tane  olabilir.  ``primary name server''
            tanımlarken,  <literal>named.hosts</literal>,  <literal>named.boot</literal>,
            <literal>named.rev</literal> ve <literal>named.cache</literal> gibi
            dosyalara ihtiyaç vardır.
          </para></listitem>
        </varlistenry>
        <varlistenry>
          <term>secondary  name server </term>
          <listitem><para>
            O  alana  ait  veritabanındaki  bilgileri
            ``primary name server'' dan belirli aralıklarla alan sunucudur. Belirli
            aralıklarla transfer edilen bu dosyalara zone-file  adı  verilir.
            ``primary name server'' dan  alınabilecek  yanıtların aynısı ``secondary name
            server'' dan da doğru şekilde alınabilir.
          </para></listitem>
        </varlistenry>
        <varlistenry>
          <term>caching only name server </term>
          <listitem><para>
            Bu şekilde yapılandırılan  DNS
            sunucuları   yapılan   sorguları   ``cache'' de   tutup   bir sonraki
            sorgu için bir önceki aynı sorguya alınan yanıt  kullanılır.  Bir
            çok  DNS   sunucusu   bu   şeklide  yapılandırılmasına
            rağmen ``caching only''  sunucular   her   zaman   sorgulara    doğru
            yanıt vermeyebilir.
          </para></listitem>
        </varlistenry>
      </variablelist>
    </para><para>
      BIND paketi bütün Linux dağıtımları ile gelir. BIND'ın yeni versiyonuna
      ihtiyaç duyduğunuzda
      <ulink url="ftp://ftp.metu.edu.tr/sunsite/system/daemons/dns/"
      >ftp.metu.edu.tr</ulink> adresinden paketi transfer edebilirsiniz.
      Gerekli  kurulumları  yaptığınızda <literal>/usr/sbin</literal> dizini
      altına <literal>named</literal> binary dosyasını koyacaktır.
    </para><para>
      <literal>named</literal>  yapılandırması  ile  ilgili dosyalar  ve işlevleri
      aşağıda yeralıyor.
    </para><para>
      <variablelist>
        <varlistenry>
          <term>named.boot</term>
          <listitem><para>
            Genel <literal> named </literal> parametrelerini ve o alana  ait
            veritabanı bilgilerinin nerede olacağı belirtilir.
          </para></listitem>
        </varlistenry>
        <varlistenry>
          <term>named.cache</term>
          <listitem><para>
            İnternet üzerindeki root domain sunucularının listesini içerir.
          </para></listitem>
        </varlistenry>
        <varlistenry>
          <term>named.local</term>
          <listitem><para>
            loopback adresine ait tanımları içerir.
          </para></listitem>
        </varlistenry>
        <varlistenry>
          <term>named.hosts</term>
          <listitem><para>
            O domain ait makina isimlerine karşılık
            gelen IP numaralarının bulunduğu dosya.
          </para></listitem>
        </varlistenry>
        <varlistenry>
          <term>named.reverse</term>
          <listitem><para>
            IP  adresine karşılık gelen isimlerin listesinin tutulduğu dosya.
          </para></listitem>
        </varlistenry>
      </variablelist>
    </para><para>
      Yukarıda belirtilen dosya isimlerinden named.boot dışındaki dosya
      isimleri  genelde karşılaşılan isimler olduğu için kullanılmıştır.
      Bu dosya isimlerini istediğiniz gibi değiştirebilirsiniz.
    </para><para>
      ``named''  yapılandırmasıyla ilgili kullanılan örnek dosyalar
      <literal>linux.org.tr</literal> alanının alan adı sunuculuğunu yapan
      <literal>metu.linux.org.tr</literal> makinasından alınmıştır
      (<literal>linux.org.tr</literal> ve
      <literal>metu.linux.org.tr</literal> aynı sunuculardır).
    </para>
    <sect2>
      <title>named.boot Dosyası</title>
      <para>
        <literal>named.boot</literal> dosyası <literal>named</literal> programı çalıştığı  zaman
        baktığı  ilk yapılandırma dosyasıdır ve <literal>/etc</literal> dizini
        altındadır. <literal>named</literal>, bu yapılandırma dosyası ile diğer
        dosyalara veya  DNS  tanımlarının tutulduğu  diğer  dosyalara  nasıl
        ulaşacağını öğrenir. Aşağıda <literal>linux.org.tr</literal> sunucusuna ait
        <literal>named.boot</literal> dosyasını göreceksiniz.
      </para><para>
<screen>
;
;    boot file for name server
;
directory /etc/namedb

;type           domain                source host/file          backup file

cache           .                                               root.cache
primary         linux.org.tr                                    named.hosts
primary         0.0.127.IN-ADDR.ARPA                            named.local
forwarders      144.122.199.20
</screen>
      </para><para>
        <literal>named.boot</literal> dosyasında yer alan satırlara kısaca
        göz atacak olursak,
      </para><para>
        <variablelist>
          <varlistenry>
            <term>directory</term>
            <listitem><para>
              <literal> named.boot</literal> dosyasında belirtilen  diğer dosyaları
              hangi dizin altında <literal> named</literal> programının arayacağını
              belirtir.
            </para></listitem>
          </varlistenry>
          <varlistenry>
            <term>cache</term>
            <listitem><para>
              cache dosyasını belirtir.
            </para></listitem>
          </varlistenry>
          <varlistenry>
            <term>primary</term>
            <listitem><para>
              primary'den hemen sonra gelen alanın primary name
              server  olduğunu  belirtir  ve  ilgili bilgileri de alan adından
              hemen sonra verilen dosya içerisinde tutar. Bu satır birden fazla
              olabilir, bu durumda ise yapılandırılan sunucu birden fazla
              alan için primary name server olarak görev yapar.
            </para></listitem>
          </varlistenry>
          <varlistenry>
            <term>forwarders</term>
            <listitem><para>
              Sorgularına yanıt veremediği istekleri
              yönlendireceği sunucuların listelendiği satır.
            </para></listitem>
          </varlistenry>
          <varlistenry>
            <term>slave</term>
            <listitem><para>
              Yukarıdaki yapılandırma dosyasında olmayan fakat
              başka  bir yerde karşınıza çıkabilecek olan slave satırı eklendiği
              zaman name server sorgulara yanıt vermek için  sadece  ve  sadece
              forwarders satırında belirtilen sunucuları kullanabilir.
            </para></listitem>
          </varlistenry>
        </variablelist>
      </para>
    </sect2><sect2>
      <title>Caching Only Alan Adı Sunucu Yapılandırması</title>
      <para>
        <literal>linux.org.tr</literal> sunucusu üzerindeki alan adı sunucu sadece
        <emphasis>caching only</emphasis> olarak  çalışacak  olsaydı,  yukarıda belirtilen
        yapılandırma satırı aşağıdaki hale gelirdi.
      </para><para>
<screen>
named.boot
-----------
;
;    boot file for name server
;
;type           domain                source host/file          backup file

cache           .                                               root.cache
primary         0.0.127.IN-ADDR.ARPA                            named.local
</screen>
      </para><para>
Bu yapılandırmayla çalışan alan adı sunucusu, <literal>named.cache</literal> dosyasında yer
alan  root  sunucuları  kullanarak  gelen  sorgulara  yanıt verip,
sorguların yanıtlarını cache'te tutmaktadır.
      </para>
    </sect2><sect2>
      <title>Birincil ve İkincil Alan Adı Sunucusu Yapılandırması</title>
      <para>
        Yine <literal>linux.org.tr named.boot</literal> dosyasına bakacak olursak,
      </para><para>
<screen>
primary         linux.org.tr            named.hosts
</screen>
      </para><para>
        satırıyla  <literal>linux.org.tr</literal> makinası <literal>linux.org.tr</literal>  alanı   için
        primary sunucu ve bu domain ile ilgili bilgilerin tutulduğu dosya
        ise <literal>named.hosts</literal> dosyasıdır.
      </para><para>
        Yukarıdaki satırı named.boot  dosyasına   yazmamızla   aslında
        işimiz  bitmiyor.
      </para><para>
        <literal>linux.org.tr</literal> sunucusu   <literal>linux.org.tr</literal>  alanı için
        primary  olduğunu, Türkiye için root sunucu olan <literal>knidos.cc.metu.edu.tr</literal> sunucusunun da bilmesi gerekiyor. Bunun için de
        <literal>http://www.metu.edu.tr/~dnsadmin</literal> adresinden gerekli form
        doldurup tanımların ODTÜ'deki yöneticiler tarafından yapılması
        gerekiyor. Bu form doğrultusunda da <literal>knidos.cc.metu.edu.tr</literal>
        sunucusunda aşağıdaki satırların girilmesi şarttır.
      </para><para>
<screen>
linux.org.tr.           IN      NS      metu.linux.org.tr.
metu.linux.org.tr.      IN      A       144.122.199.199
</screen>
      </para><para>
        Şu an bu işlemler zaten yapılmış olup sadece bilginiz olması için
        bu satırlar yazılmıştır.
      </para><para>
<screen>
primary         0.0.127.IN-ADDR.ARPA    named.local
</screen>
      </para><para>
        satırıyla <literal>linux.org.tr</literal> makinasında 127.0.0.1 IP adresine karşılık
        gelen  <emphasis>loopback</emphasis> isminin  tanımlarının  yer  alacağı  dosya  adı
        verilmiştir.
        Eğer Türkiye Linux Kullanıcıları Grubunun  kendine  ait  bir  IP
        adres  bloğu, örneğin şu an ODTÜ'de kullanılan 144.122.199.0 bloğu
        verilmiş ve bu blok kendi alt gruplarına dağıtılmış
        olsaydı bu  adreslere  ait  reverse  tanımlar  yine  <literal>linux.org.tr</literal>
        makinasında  tutulacaktı. Böyle bir durumda <literal>named.boot</literal> dosyasına
        aşağıdaki satır benzeri bir satır daha  eklemek  gerekecekti.
      </para><para>
<screen>
primary         199.122.144.IN-ADDR.ARPA    named.144.122.199
</screen>
      </para><para>
        Türkiye Linux Kullanıcıları Grubu için kullanılan IP adresine ait
        gerekli reverse tanımı ilgili üniversitenin alan adı sunucusunda
        girilmiş durumdadır. Örneğin, <literal>metu.linux.org.tr</literal>
        için <literal>knidos.cc.metu.edu.tr</literal> sunucusunda aşağıdaki
        satır tanımlanmıştır.
      </para><para>
<screen>
199.199.122.144         IN      PTR     metu.linux.org.tr.
</screen>
      </para><para>
        Bazı programların reverse tanımlarını kullanıyor olması nedeniyle
        (örneğin tcpd) bu tür tanımların girilmesi önemlidir. Bir veya daha fazla
        C sınıfı şeklinde IP adres blokları aldığınız zaman IP adresi aldığınız
        kurumdan,
        bu adres aralığının reverse tanımlarını sizin alan adı sunucunuza
        yönlendirilmesini isteyebilirsiniz.   Bir C sınıfından az sayıdaki IP adresleri
        içinse yine IP adresini aldığınız kurum gerekli reverse tanımları sizin
        için yapmak zorundadır.
      </para><para>
        Şu an <literal>linux.org.tr</literal> makinası herhangi bir başka primary sunucunun
        secondary  sunucusu olmadığı için <literal>named.boot</literal> dosyasında secondary
        geçen bir satıra rastlamadık. Örneğin <literal>linux.org.tr</literal> sunucusu
        <literal>linux.org</literal> sunucusunun secondary  alan adı sunucusu  olduğunu
        varsayalım, bu durumda aşağıdaki satırı <literal>named.boot</literal> dosyasına
        eklemememiz gerekecek.
      </para><para>
<screen>
secondary         linux.org     198.182.196.49    SEC.linux.org
</screen>
      </para><para>
Bu satırı eklediğimiz andan itibaren  <emphasis>named</emphasis>  belirli  aralıklarla
gidip linux.org sunucusundan  DNS dosyalarının bir kopyasını
linux.org.tr sunucusuna aktaracak. linux.org alanının secondary
sunucusu oldugumuza dair bilginin de ayrıca linux.org alanının primary
tanımlarını tutan sunucuda belirtilmesi gerekir.
      </para>
    </sect2><sect2>
      <title>named Yapılandırma Dosyası</title>
      <para>
        named  yapılandırma dosyalarında (<literal>named.hosts, named.local,
        named.cache, named.rev</literal>) karşılaşılan yapılandırma
        parametreleri ve ne anlama geldikleri aşağıda yeralmaktadır.
      </para><para>
        <variablelist>
          <varlistenry>
            <term>SOA (Start  of   authority)</term>
            <listitem><para>
              İlgili   dosyanın   ne   kadar
              zaman aralıklarında yenilenebileceği gibi bilgileri içerir.
            </para></listitem>
          </varlistenry>
          <varlistenry>
            <term>NS  (Name  Server)</term>
            <listitem><para>
              Alan adı sunucusu olduğunu belirtir.
            </para></listitem>
          </varlistenry>
          <varlistenry>
            <term>A(Adress)</term>
            <listitem><para>
              Makina ismini IP adresine çevirir.
            </para></listitem>
          </varlistenry>
          <varlistenry>
            <term>PTR (Pointer)</term>
            <listitem><para>
              IP adresini makina ismine çevirir.
            </para></listitem>
          </varlistenry>
          <varlistenry>
            <term>MX (Mail Exchange)</term>
            <listitem><para>
              O alana ait mesajları hangi makinanın dağıtacağını belirtir.
            </para></listitem>
          </varlistenry>
          <varlistenry>
            <term>CNAME(Canonical  Name)</term>
            <listitem><para>
              Bir  makinaya  verilen   isimler
              birden fazla ise bu isimleri belirtirken kullanılır.
            </para></listitem>
          </varlistenry>
          <varlistenry>
            <term>HINFO (Host  Information)</term>
            <listitem><para>
              Belirtilen  sunucunun   işletim
              sistemi veya donanımı konusunda bilgi verir.
            </para></listitem>
          </varlistenry>
        </variablelist>
      </para><para>
        <literal>named.hosts, named.local</literal> vb. dosyalara girilen standart  bir  DNS
        kaydı aşağıdaki yapıda karşımıza çıkar.
      </para><para>
<screen>
[name] [ttl] IN type data
</screen>
      </para><para>
        [ ] içerisinde belirtilen değerler isteğe bağlı olup
        gerekmediği durumlarda yazılmayabilir.
      </para><para>
        <variablelist>
          <varlistenry>
            <term>name</term>
            <listitem><para>
              Bu kısma tam domain ismi, makina ismi yazılabilir.
            </para></listitem>
          </varlistenry>
          <varlistenry>
            <term>ttl (time-to-live)</term>
            <listitem><para>
              Burada belirtilen süre kadar (bu süre saniye
              cinsindendir)  cache tutulabilecegini belirtir.  Eğer herhangi bir
              süre  verilmemiş  ise  SOA  kısmında verilen süre kullanılır.
            </para></listitem>
          </varlistenry>
          <varlistenry>
            <term>IN</term>
            <listitem><para>
              Girilen kaydın DNS kaydı olduğunu belirtir.
            </para></listitem>
          </varlistenry>
          <varlistenry>
            <term>type</term>
            <listitem><para>
              Yukarıda  bahsettiğimiz   kısaltmalardan   ilgili   olanı
              yazılır.
            </para></listitem>
          </varlistenry>
          <varlistenry>
            <term>data</term>
            <listitem><para>
              Bu kısma IP adresi yazılır.
            </para></listitem>
          </varlistenry>
        </variablelist>
      </para><para>
        Şimdi de  bu  kısaltmaların  bulunduğu  <literal>named.cache,  named.hosts,
        named.local</literal>  gibi  dosyalardan  birer  kesit alıp içeriklerine göz
        atalım.
      </para><para>
<screen>
metu:/etc/namedb# more named.cache
;       last update:    Nov 8, 1995
;       related version of root zone:   1995110800
;
;
; formerly NS.INTERNIC.NET
;
.                        3600000  IN  NS    A.ROOT-SERVERS.NET.
A.ROOT-SERVERS.NET.      3600000      A     198.41.0.4
;
; formerly NS1.ISI.EDU
;
.                        3600000      NS    B.ROOT-SERVERS.NET.
B.ROOT-SERVERS.NET.      3600000      A     128.9.0.107
;
;
</screen>
      </para><para>
        Yukarıdaki dosya, root name server'ların listesinin yer aldığı
        dosyadır. Süregelen değişiklikler doğrultusunda bu dosyada  yer
        alan kayıtlar da değişebilirler. Sürekli güncel tutmak
        amacıyla <literal>ftp://nic.ddn.mil/netinfo/root-servers.txt</literal>    adresinden
        dosyanın yeni halini belirli aralıklarla almakta fayda vardır.
      </para><para>
        <emphasis>ttl</emphasis> süresi  ise  olabildiğince büyük verilerek root sunucuların
        herhangi bir şekilde cache'ten silinmesi önlenmiş olur.
      </para><para>
<screen>
metu:/etc/namedb# more named.local
;
;       @(#)named.local 1.1     (Berkeley)      86/01/21
;
$ORIGIN 0.0.127.in-addr.arpa.
@       IN      SOA     metu.linux.org.tr. root.metu.linux.org.tr.  (
                                1996012201 ; Serial
                                3600    ; Refresh
                                300     ; Retry
                                3600000 ; Expire
                                14400 )  ; Minimum
        IN      NS      metu.linux.org.tr.
1       IN      PTR     localhost.
</screen>
      </para><para>
        <literal>IN SOA</literal> ile başlayan satırda <literal>metu.linux.org.tr</literal> adresi
        ilgili domain konusunda yetkili sunucuyu,
        <literal>root.metu.linux.org.tr</literal> ise herhangi bir şekilde sorun
        olduğunda bağlantı kurulacak e-posta adresini
        (<emphasis>root@metu.linux.org.tr</emphasis>) belirtir.
      </para><para>
        Diğer bilgilerse sırayla <literal>metu.linux.org.tr</literal>'ın ``primary name server''
        olduğunu ve 127.0.0.1 IP adresine localhost isminin karşılık geldiğini
        belirtir.
      </para><para>
<screen>
metu:/etc/namedb# more named.hosts
; Authoritative data for Berkeley.EDU (ORIGIN assumed Berkeley.EDU)
;
$ORIGIN linux.org.tr.
@               IN      SOA     metu.linux.org.tr. root.metu.linux.org.tr. (
                                1997072902      ; Serial
                                10800   ; Refresh 3 hours
                                3600    ; Retry   1 hour
                                3600000 ; Expire  1000 hours
                                86400 ) ; Minimum 24 hours
                IN      MX          10 metu
                IN      NS          metu
                IN      HINFO       &quot;i486&quot; &quot;Linux 2.0.27&quot;
localhost.      IN      A           127.1
metu            IN      A           144.122.199.199
                IN      A           144.122.199.199
www             IN      CNAME       metu
ftp             IN      CNAME       metu
gopher          IN      CNAME       metu
listproc        IN      CNAME       metu
ege             IN      A           155.223.97.31
www.ege         IN      CNAME       ege
</screen>
      </para><para>
        burada diğer <literal>named.local</literal> dosyasından farklı olarak makina ismi - IP
        adresi eşlemesi yapılmış olup <literal>MX</literal> ve <literal>CNAME</literal>
        kavramları kullanılmıştır.
      </para><para>
        <command>MX</command> tanımın bulunduğu satırda
        <literal>linux.org.tr</literal> domaini için e-postaları alabilecek sunucu
        <literal>metu.linux.org.tr</literal> olarak tanımlanmış. 10 rakamı ise
        <literal>metu.linux.org.tr</literal>'nin <literal>linux.org.tr</literal> olarak gelmesi
        gereken mesajlardaki önceliğini belirtir. Sayı ne kadar küçük
        verilirse önceliği o kadar fazladır.
      </para><para>
        <command>HINFO</command> tanımının bulunduğu satır <literal>metu.linux.org.tr</literal>'ın
        donanım, işletim sistemi ve sürüm bilgilerini tutuyor.
      </para><para>
        <command>CNAME</command> geçen satırlar ise <literal>metu.linux.org.tr</literal> makinasının
        olması düşünülen diğer isimlerini tanımlamak için kullanıldı. Örneğin,
        <literal>www.linux.org.tr</literal> ile <literal>metu.linux.org.tr</literal> aynı sunucular
        olup <literal>www.linux.org.tr</literal>, <literal>metu.linux.org.tr</literal>'ın bir diğer
        adı (alias'ı) olarak gözükmektedir.
      </para><para>
        Bütün bu yapılandırma işlemleri bittikten sonra,
      </para><para>
<screen>
metu:/etc/namedb# named
</screen>
      </para><para>
        komutunu çalıştırıp <literal>nslookup</literal> veya <literal>host</literal> gibi programlar
        yardımıyla name server'ımızın çalışıp çalışmadığını denemek kalıyor.
        Çalıştırdığımızda verilen hata mesajları <literal>/usr/adm/mesages</literal>
        dosyasına yazılır.
      </para>
    </sect2>
  </sect1>
  <sect1 id="archive-tlkg-lis-9.4">
    <title>host ve nslookup Programlarının Kullanımı</title>
    <para>
      <literal>host</literal> veya <literal>nslookup</literal> programları yardımıyla <emphasis>bind</emphasis>
      yapılandırmamızın ilgili sunucuda doğru çalışıp çalışmadığını
      test edelim.
    </para><para>
      Örnek olarak, <literal>host</literal> komutunu kullanarak <literal>linux.org.tr</literal> için
      <literal>knidos.cc.metu.edu.tr</literal> 'da girilmesi gereken tanımların
      doğruluğunu kontrol edebiliriz.
    </para><para>
<screen>
$ nslookup
Default Server:  knidos.cc.metu.edu.tr
Address:  144.122.199.20

&gt; linux.org.tr
Server:  knidos.cc.metu.edu.tr
Address:  144.122.199.20

Name:    linux.org.tr
Address:  144.122.199.199

&gt; exit
</screen>
    </para><para>
      Yukarıdaki satırlarda <literal>nslookup</literal> yardımıyla öntanımlı DNS sunucusu
      olan <literal>knidos</literal> makinasına linux.org.tr makinasının IP adresini sorduk.
      <literal>nslookup</literal> komutunun -t seçeneği yardımıyla bir makina hakkında
      daha başka veriler almak da mümkündür.
    </para><para>
<screen>
&gt; server metu.linux.org.tr
Default Server:  metu.linux.org.tr
Address:  144.122.199.199

&gt; ls -t HINFO linux.org.tr
[metu.linux.org.tr]
 linux.org.tr.                  Linux       2.0.27
&gt;
</screen>
    </para><para>
<literal>nslookup</literal> üzerine daha fazla bilgi için komuta ait man sayfasına
gözatın.

<literal>host</literal> komutu da <literal>nslookup</literal> komutunun bir tamamlayıcısı gibidir.
Aşağıda birkaç örnekle <literal>host</literal> komutu anlatılıyor.
    </para><para>
<screen>
$ host linux.org.tr
linux.org.tr has address 144.122.199.199
linux.org.tr mail is handled (pri=10) by metu.linux.org.tr
$ host www.ege.linux.org.tr
www.ege.linux.org.tr is a nickname for ege.linux.org.tr
ege.linux.org.tr has address 155.223.97.31
</screen>
    </para><para>
      Yukarıda yeralan ilk komut yardımıyla <literal>linux.org.tr</literal> makinasının isim-IP
      dönüşümü yapılmış ve makinaya karşılık gelen adresin 144.122.199.199
      olduğu anlaşılmıştır.
    </para><para>
      İkinci <literal>host</literal> komutuyla da benzer şekilde <literal>www.ege.linux.org.tr</literal>
      adresinin IP numarasını öğrendik. Ayrıca aynı IP numarasına karşılık gelen
      ve linux.org.tr domain'ine ait olan iki isim bulunduğu da yukarıdan
      kolayca anlaşılıyor.
    </para>
  </sect1>
</chapter>
</book>
