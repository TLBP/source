<?xml version="1.0" encoding="UTF-8"?>
<!-- ********************************************************************
     $Id: spam-filtering-howto.xml,v 1.1 2003/09/28 10:06:47 nilgun Exp $
     ******************************************************************** -->

<article id="spam-filtering">
  <articleinfo>
    <title>Eposta Alıcısında (MX'te) Spam Engelleme</title>
    <subtitle>Gelen SMTP bağlantılarında istenmeyen posta nasıl reddedilir?</subtitle>
    <authorgroup>
      <author>
        <firstname>Tor</firstname>
        <surname>Slettnes</surname>
        <affiliation>
          <address><email>tor@slett.net</email></address>
        </affiliation>
      </author>
      <author role="editor">
        <firstname>Joost</firstname>
        <surname>De Cock</surname>
        <affiliation>
          <address><email>joost.decock@astrid.be</email></address>
        </affiliation>
        <contrib>Teknik gözden geçirme</contrib>
      </author>
      <author role="editor">
        <firstname>Devdas</firstname>
        <surname>Bhagat</surname>
        <affiliation>
          <address><email>devdas@dvb.homelinux.org</email></address>
        </affiliation>
        <contrib>Teknik gözden geçirme</contrib>
      </author>
      <author role="editor">
        <firstname>Tom</firstname>
        <surname>Wright</surname>
        <affiliation>
          <address><email>tom@maladmin.com</email></address>
        </affiliation>
        <contrib>Dil bakımından gözden geçirme</contrib>
      </author><author role="translator">
        <firstname>Nilgün Belma Bugüner</firstname>
        <affiliation>
          <address>
            <email>&nilgun.buguner;</email>
          </address>
        </affiliation>
      </author><author role="editor">
        <firstname>Yücel Haluk Bugüner</firstname>
        <affiliation>
          <address><email>&haluk.buguner;</email></address>
        </affiliation>
        <contrib>Çeviri bakımından gözden geçirme</contrib>
      </author>
    </authorgroup>
    <edition>Sürüm 1.0</edition>
  <pubdate>2005-11-02</pubdate>
    <revhistory><title>Bu çevirinin sürüm bilgileri:</title>
      <revision>
        <revnumber>1.0</revnumber>
        <date>2 Kasım 2005</date>
        <authorinitials>NBB</authorinitials>
        <revremark>İlk çeviri</revremark>
      </revision>
    </revhistory>
    <revhistory><title>Özgün belgenin sürüm bilgileri:</title>
    <revision>
      <revnumber>1.0</revnumber>
      <date>08 Eylül 2005</date>
      <authorinitials>TS</authorinitials>
      <revremark>Halka açık sürüm</revremark>
    </revision>
  </revhistory>
<copyright><year>2004</year><holder>Tor Slettnes - Özgün belge</holder></copyright><sbr/>
<copyright><year>2005</year><holder>Nilgün Belma Bugüner - Türkçe çeviri</holder></copyright>
    <legalnotice><title>Yasal Açıklamalar</title>
      <para>
Bu belgenin, <emphasis>Eposta Aktarımcılarında Spam Engelleme</emphasis> çevirisinin 1.0 sürümünün <emphasis role="bold">telif hakkı © 2005 <emphasis>Nilgün Belma Bugüner</emphasis>'e</emphasis>, özgün İngilizce sürümünün  <emphasis role="bold">telif hakkı © 2004 <emphasis>Tor Slettnes</emphasis>'a</emphasis> aittir. Bu belgeyi, Free Software Foundation tarafından yayınlanmış bulunan <link linkend="gpl">GNU Genel Kamu Lisansının</link> 2. ya da daha sonraki sürümünün koşullarına bağlı kalarak kopyalayabilir, dağıtabilir ve/veya değiştirebilirsiniz. Bu Lisansın bir kopyasını <ulink url="http://www.fsf.org/licensing/licenses/gpl.html"/> adresinde bulabilirsiniz.
  </para><para>
BU BELGE "ÜCRETSİZ" OLARAK RUHSATLANDIĞI İÇİN, İÇERDİĞİ BİLGİLER İÇİN İLGİLİ KANUNLARIN İZİN VERDİĞİ ÖLÇÜDE HERHANGİ BİR GARANTİ VERİLMEMEKTEDİR. AKSİ YAZILI OLARAK BELİRTİLMEDİĞİ MÜDDETÇE TELİF HAKKI SAHİPLERİ VE/VEYA BAŞKA ŞAHISLAR BELGEYİ "OLDUĞU GİBİ", AŞİKAR VEYA ZIMNEN, SATILABİLİRLİĞİ VEYA HERHANGİ BİR AMACA UYGUNLUĞU DA DAHİL OLMAK ÜZERE HİÇBİR GARANTİ VERMEKSİZİN DAĞITMAKTADIRLAR. BİLGİNİN KALİTESİ İLE İLGİLİ TÜM SORUNLAR SİZE AİTTİR. HERHANGİ BİR HATALI BİLGİDEN DOLAYI DOĞABİLECEK OLAN BÜTÜN SERVİS, TAMİR VEYA DÜZELTME MASRAFLARI SİZE AİTTİR.
  </para>
  <para>
İLGİLİ KANUNUN İCBAR ETTİĞİ DURUMLAR VEYA YAZILI ANLAŞMA HARİCİNDE HERHANGİ BİR ŞEKİLDE TELİF HAKKI SAHİBİ VEYA YUKARIDA İZİN VERİLDİĞİ ŞEKİLDE BELGEYİ DEĞİŞTİREN VEYA YENİDEN DAĞITAN HERHANGİ BİR KİŞİ, BİLGİNİN KULLANIMI VEYA KULLANILAMAMASI (VEYA VERİ KAYBI OLUŞMASI, VERİNİN YANLIŞ HALE GELMESİ, SİZİN VEYA ÜÇÜNCÜ ŞAHISLARIN ZARARA UĞRAMASI VEYA BİLGİLERİN BAŞKA BİLGİLERLE UYUMSUZ OLMASI) YÜZÜNDEN OLUŞAN GENEL, ÖZEL, DOĞRUDAN YA DA DOLAYLI HERHANGİ BİR ZARARDAN, BÖYLE BİR TAZMİNAT TALEBİ TELİF HAKKI SAHİBİ VEYA İLGİLİ KİŞİYE BİLDİRİLMİŞ OLSA DAHİ, SORUMLU DEĞİLDİR.
  </para>
  <para>
Tüm telif hakları aksi özellikle belirtilmediği sürece sahibine aittir. Belge içinde geçen herhangi bir terim, bir ticari isim ya da kuruma itibar kazandırma olarak algılanmamalıdır. Bir ürün ya da markanın kullanılmış olması ona onay verildiği anlamında görülmemelidir.
  </para>
    </legalnotice>
    <abstract><para>
Bu belgede bir Posta Alıcısına, SMTP gelişi sırasında Dolaylı Spama yol açmadan spam ve kötücül yazılımdan kurtulabilme konusunda düşük tesirlilerden üstün tesirlilere kadar çeşitli yollar açıklanmış ve Exim üzerinde bunlar gerçeklenmiştir. Eğer siz bir son kullanıcı iseniz, yani Evolution, Thunderbird veya KMail gibi bir eposta istemcisi kullanarak sadece eposta okuyan ve spamdan kurtulmanın yollarını arayan biriyseniz bu belge size göre değildir.
    </para></abstract>
</articleinfo>

  <sect1 id="spam-filtering-introduction">
    <title>Giriş</title>
    <sect2 chunkthis="1" id="spam-filtering-purpose">
      <title>Belgenin Amacı</title>
      <para>
Bu belgede bir <xref linkend="spam-filtering-mx"/>na, SMTP gelişi sırasında  <xref linkend="spam-filtering-colspam"/>a  yol açmadan spam ve kötücül yazılımdan kurtulabilme konusunda düşük tesirlilerden üstün tesirlilere kadar çeşitli yollar açıklanmıştır.
      </para><para>
Açıklamalar doğal olarak kavramsaldır, ancak Exim MTA ve diğer konuya özgü yazılım araçları kullanılarak örnek bir gerçeklenim de sağlanmıştır. Bir takım toleranssızlıklara belge içinde yer yer değinilmiştir.
      </para>
    </sect2>

    <sect2 chunkthis="1" id="spam-filtering-audience">
      <title>Belgenin hedef kitlesi</title>
      <para>
Bu belgenin hedef kitlesi SMTP, MTA/MDA/MUA, DNS/rDNS ve MX kayıtları gibi kısaltmalara zaten aşina olan eposta sistemi yöneticileridir. Eğer siz bir son kullanıcı iseniz, yani Evolution, Thunderbird veya Outlook Express gibi bir eposta istemcisi kullanarak sadece eposta okuyan ve spamdan kurtulmanın yollarını arayan biriyseniz bu belge size göre değildir; ama sizin eposta sisteminizin (okul, şirket, servis sağlayıcı, vs.) yöneticisinin böyle bir belgenin varlığından haberdar olmasını sağlamak isteyebilirsiniz.
      </para>
    </sect2>
    <sect2 chunkthis="1" id="spam-filtering-updates">
      <title>Belgenin güncel sürümleri</title>
      <para>
Bu belgenin en yeni sürümününü <ulink url="http://slett.net/spam-filtering-for-mx/"/>  adresinde bulabilirsiniz. Lütfen düzeltmeler ve eklemeler için düzenli aralıklarla bu adrese bakmayı ihmal etmeyin.
      </para>
    </sect2>
    <sect2 chunkthis="1" id="spam-filtering-history">
      <title>Sürüm Tarihçesi</title><para>
Ayrıntılı sürüm tarihçesi için <ulink url="http://www.tldp.org/HOWTO/html_single/Spam-Filtering-for-MX/#history">özgün belgeyi</ulink> inceleyebilirsiniz.
    </para></sect2>
    <sect2 chunkthis="1" id="spam-filtering-credits">
      <title>Teşekkür</title><para>
<ulink url="http://www.tldp.org/HOWTO/html_single/Spam-Filtering-for-MX/#history">Sürüm tarihçesi</ulink>nde de bahsedildiği gibi bu belgeye geri bildirimde bulunarak, düzeltmeler yollayarak, yazımına yardım ederek bir çok kişi katkıda bulundu.
      </para><para>
Bu belgeye sağladıkları araçlarla ve fikirleriyle katkıda bulunan bazı kişiler ve gruplar (belli bir sıra gözetilmeksizin):
      </para><para>
      <itemizedlist>
        <listitem><para>
<xref linkend="spam-filtering-greylisting"/> tasarımını yapan ve belgeleyen Evan Harris'e <email>eharris@puremagic.com</email>,
        </para></listitem>
        <listitem><para>
<link linkend="spam-filtering-smtpdelays">katran çukuru</link>nun (teergrube) tasarımını yapan Axel Zinser'e <email>fifi@hiss.org</email>,
        </para></listitem>
        <listitem><para>
<ulink url="http://www.openspf.org/">SPF</ulink>, <ulink url="http://www.danisch.de/work/security/antispam.html">RMX++</ulink> ve diğer <xref linkend="spam-filtering-senderauth"/> geliştiricilerine,
        </para></listitem>
        <listitem><para>
<ulink url="http://rhyolite.com/anti-spam/dcc/">DCC</ulink>, <ulink url="http://razor.sf.net/">Razor</ulink> ve <ulink url="http://pyzor.sf.net/">Pyzor</ulink> gibi istenmeyen eposta imza depolarını işbirliği içinde sürdüren, dağıtan ve bunları oluşturanlarlara,
        </para></listitem>
        <listitem><para>
DNS kara ve ak listelerini oluşturan ve bunları sürdüren <ulink url="http://www.spamcop.net/">SpamCop</ulink>, <ulink url="http://www.spamhaus.org/">SpamHaus</ulink>,  <ulink url="http://www.sorbs.net/">SORBS</ulink>, <ulink url="http://cbl.abuseat.org/">CBL</ulink> ve  <ulink url="http://moensted.dk/spam/">birçok diğerleri</ulink>ne.
        </para></listitem>
        <listitem><para>
Oldukça karmaşık ve ampirik yaklaşımlarla çeşitli spam filtreleme tekniklerini birleştirip geliştirerek büyük bir atak yapan <ulink url="http://www.spamassassin.org/">SpamAssassin</ulink> <ulink url="http://www.spamassassin.org/full/3.0.x/dist/CREDITS">geliştiricileri</ulink>ne,
        </para></listitem>
        <listitem><para>
SpamAssassin ile kullanmak için <xref linkend="spam-filtering-bogusviruswarning"/> listesini düzenleyen ve sürdüren Tim Jackson'a <email>tim (at) timj.co.uk</email>,
        </para></listitem>
        <listitem><para>
Mükkemel <link linkend="spam-filtering-exim">Exim</link> MTA'sını geliştiren zeki insanlar: Geliştirici Philip Hazel'e <email>ph10@cus.cam.ac.uk</email>, SMTP sırasında içerik sınaması yapan Exiscan-ACL yamasını yazan  Tom Kistner'e <email>tom@duncanthrax.net</email>, Exim 4 Debian paketlerini hazırlayarak gerçekten iyi bir iş çıkaran Andreas Metzler'e <email>ametzler@debian.org</email>,
        </para></listitem>
        <listitem><para>
Bu spam salgınına karşı çıkmak için gerek fikirleri gerek  yazılımları ve gerekse teknikleriyle katkıda bulunan daha bir çok kişiye,
        </para></listitem>
        <listitem><para>
Bu belgeyi okuyup uygulayarak e-postaları yararlı bir iletişim aracı olarak iyileştirecek biri olabileceğiniz için size
        </para></listitem>
      </itemizedlist></para><para>Teşekkür ederim.</para>
    </sect2>
    <sect2 chunkthis="1" id="spam-filtering-feedback">
      <title>Geri bildirim</title>
      <para>
Bu belgede bahsedilen tekniklerle ilgili deneyimlerinizi, önerilerinizi, sorularınızı, yorumlarınızı ve/veya katkıda bulunma isteklerinizi duymaktan mutlu olurum. Lütfen bu gibi durumlarda bana bir eposta gönderin: <email>tor@slett.net</email>.
      </para><para>
Eğer bu teknikleri Sendmail veya Postfix gibi diğer <link linkend="spam-filtering-mta">posta aktarımcıları</link> üzerinde de uygulayabiliyorsanız,  lütfen bunları bizimle paylaşın.
      </para>
    </sect2>
    <sect2 chunkthis="1" id="spam-filtering-prerequisites">
      <title>Neye İhtiyacınız var?</title>
      <para>
Bu belgede açıklanan teknikler epostalarınızı aldığınız internet alan adınız için yapılandırılmış <link linkend="spam-filtering-mx">posta alıcılarına</link> sistem erişimi üzerinedir. Esasen, ihtiyacınız olan şey, sisteminiz üzerinde çalıştırdığınız <xref linkend="spam-filtering-mta"/> için yazılım kurabilme ve yapılandırma dosyalarını değiştirebilme yetkisine sahip olmanızdır.
      </para><para>
Bu belgede açıklananlar doğasında kavramsal olmasına rağmen bir çok farklı posta aktarımcısına uyarlanabilir. Belgedeki örnekler Exim 4 gerçeklenimine göre verilmiştir. Bu gerçeklenim, <ulink url="http://www.spamassassin.org/">SpamAssassin</ulink> gibi başka yazılım araçları ile birlikte çalışabilir. Ayrıntılı bilgi için <xref linkend="spam-filtering-exim"/> bölümüne bakınız.
      </para>
    </sect2>
    <sect2 chunkthis="1" id="spam-filtering-conventions">
      <title>Bu belgede kullanılan uzlaşımlar</title>
      <para>
Bu metinde kullanılan sözdizimsel uzlaşımlar:
      </para><para>
      <table id="spam-filtering-conventiontable" frame="all">
        <title>Sözdizimsel Uzlaşımlar</title>
        <tgroup cols="2" align="left" colsep="1" rowsep="1">
          <thead>
            <row>
              <entry>Metin türü</entry>
              <entry>Anlamı</entry>
            </row>
          </thead>
          <tbody>
            <row>
<entry><quote>Tırnak içine alınmış metin</quote></entry>
<entry>Başkalarının yorumları ve bilgisayar çıktıları tırnak içine alınmıştır.</entry>
            </row><row>
<entry><screen>ekran görüntüsü</screen></entry>
<entry>Uçbirimden kopyalanmış bilgisayar girdileri ve çıktılarının birebir görüntüsü. Çerçeveli açık renk bir zemin kullanılmıştır.</entry>
            </row><row>
<entry><command>komut</command></entry>
<entry>Komut satırından girilebilen komutlar.</entry>
            </row><row>
<entry><varname>değişken</varname></entry>
<entry>Bir değişken veya bir değişkenin değerine gösterici ismi.</entry>
            </row><row>
<entry><option>seçenek</option></entry>
<entry>Komut seçenekleri; <command>ls</command> gibi bir komuta argüman olarak verilen <option>-a</option> gibi bir seçenek böyle gösterilmiştir.</entry>
            </row><row>
<entry><replaceable>argüman</replaceable></entry>
<entry>Bir komuta verilen argümünlar; <quote><command>man </command><replaceable>ls</replaceable> yazınız</quote> gibi.</entry>
            </row><row>
<entry><synopsis>
<command>komut seçenek</command> <emphasis>argüman</emphasis> ... argüman
</synopsis></entry>
<entry>Komut kullanım şablonları</entry>
            </row><row>
<entry><filename>dosyaismi</filename></entry>
<entry>Dosya ve dizin isimleri, örn. <quote><filename>/usr/bin</filename> dizinine geçiniz</quote></entry>
            </row><row>
<entry><keycap>Tuş</keycap></entry>
<entry>Klavyedeki tuşlar, örn. <quote>çıkmak için <keycap>Q</keycap> tuşuna basınız</quote></entry>
            </row><row>
<entry><guibutton>Düğme</guibutton></entry>
<entry><guibutton>Tamam</guibutton> gibi tıklanacak bir çizgesel düğme.</entry>
            </row><row>
<entry>
  <menuchoice>
    <guimenu>Menü</guimenu>
    <guimenuitem>Seçim</guimenuitem>
  </menuchoice>
</entry>
<entry>Bir çizgesel menüden nelerin seçileceği belirtilirken kullanılır. Örneğin, <quote>İstemciden <menuchoice><guimenu>Yardım</guimenu><guimenuitem>Mozilla hakkında...</guimenuitem></menuchoice> seçiniz.</quote></entry>
            </row><row>
<entry><wordasword>Terminoloji</wordasword></entry>
<entry>Bir kavram veya terimin ismi; örnek: <quote><wordasword>Çekirdek</wordasword> sistemin kalbidir.</quote></entry>
            </row><row>
<entry><xref linkend="spam-filtering-glossary" /> bölümüne bakınız.</entry>
<entry>Belge içindeki bir konu başlığına bağ.</entry>
            </row><row>
<entry><ulink url="http://slett.net/gallery/2003-05/IMG_1655">Yazar</ulink></entry>
<entry>Bir dış kaynağa erişim için bağ.</entry>
            </row>
          </tbody>
        </tgroup>
      </table></para>
    </sect2>
    <sect2 chunkthis="1" id="spam-filtering-organization">
      <title>Belge içeriği hakkında</title> <para>
Bu belge özetle şu bölümleri içerir:
      </para><para>
      <variablelist><varlistentry>
        <term><xref linkend="spam-filtering-background"/></term>
        <listitem><para>
SMTP'ye ve SMTP sırasında yapılan filtrelemeye genel bir bakış.
        </para></listitem>
        </varlistentry><varlistentry>
          <term><xref linkend="spam-filtering-techniques"/></term>
          <listitem><para>
Bir SMTP aktarımında istenmeyen postanın engellenmesinin yolları
          </para></listitem>
        </varlistentry><varlistentry>
          <term><xref linkend="spam-filtering-considerations"/></term>
          <listitem><para>
Aktarım sırasında yapılan filtreleme ile ilgili ele alınacaklar.
          </para></listitem>
        </varlistentry><varlistentry>
          <term><xref linkend="spam-filtering-qanda"/></term>
          <listitem><para>
Sorularınız ve vermeye çalıştığım yanıtları.
          </para></listitem>
        </varlistentry>
      </variablelist>
      </para><para>
Örnek bir Exim gerçeklenimi <xref linkend="spam-filtering-exim"/> bölümünde ele alınmıştır.
      </para>
    </sect2>
  </sect1>

<sect1 id="spam-filtering-background">
  <title>Altyapı</title>
    <para>
Postaların kabulü ve gönderilmesinde sıklıkla yapıldığı gibi görevi bir şekilde geçiştirmek yerine, gelen SMTP aktarımları sırasında posta filtrelemenin getirileri üzerinde durulmuştur. Ayrıca, SMTP aktarımı konusuna kısa bir giriş hazırladık.
    </para>
  <sect2 chunkthis="1" id="spam-filtering-whysmtptime" >
    <title>Posta Filtrelemesi Neden SMTP Aktarımı Sırasında Yapılır?</title>
    <sect3 id="spam-filtering-statusquo">
      <title>Mevcut Durum</title>
      <para>
Spam alıyorsanız, ellerinizi havaya kaldırın. İndirmeyin.
      </para><para>
Bilgisayar virüsleri ve kötücül yazılımlar alıyorsanız siz de ellerinizi havaya kaldırın.
      </para><para>
<quote>Message Undeliverable</quote> (İleti Teslim Edilemiyor), <quote>Virus found</quote> (Virüs bulundu), <quote>Please confirm delivery</quote> (Lütfen teslimi onaylayın), vs. gibi sizin göndermediğiniz iletilerle ilgili <xref linkend="spam-filtering-dsn"/> iletileri alıyorsanız, siz de ellerinizi havaya kaldırın. Bu <xref linkend="spam-filtering-colspam"/> olarak bilinir.
      </para><para>
Bu sonuncu türdekiler özellikle sorunludur çünkü istenmeyen veya kötü niyetli iletilere göre temizlenmeleri daha zordur, başlık bölümlerini yorumlamada tanrısal becerilere sahip olmayanlar için bunlarla uğraşmak boşa bir çabadır. Virüs uyarıları söz konusu olduğunda ise alıcılar gereksiz bir endişeye kapılırlar ve daha büyük bir bölümü bunları toptan gözden çıkarır, dolayısıyla <xref linkend="spam-filtering-dsn"/> geçerli olan meşru iletiler de bu arada kaybedilir.
      </para><para>
Son olarak, spam ya da virüs tarayıcıların hatalı değerlendirmeler yapmalarından dolayı meşru postalarınızı bir karadelikte kaybedenlerdenseniz ---- Siz ayaklarınızı da kaldırın.
      </para><para>
Eğer hala ayaktaysanız, postalarınızın başına neler geldiği konusunda tam bir bilginiz olmayabileceğini düşünürüm. Bir şekilde spam engellemesi yapıyorsanız, tek başına DNS karalisteleri (SpamHaus, SPEWS, SORBS...) gibi ilkel filtreleme tekniklerinde deneyimli de olsanız, hatta, posta istemcinizde postaları elle bizzat çöp kutusuna taşıyor olsanız bile geçerli postalarınızı kaybetme ihtimaliniz hala vardır.
      </para>
    </sect3>
    <sect3 id="spam-filtering-cause">
      <title>Sebep</title><para>
Spam, açgözlülüğün birçok ilkel ürünlerinden biri olarak bir sosyal bozukluktur. Siz buna zenginlik diyebilirsiniz, ne derseniz deyin; daha geniş bir ekosistemi yoketmeye çalışan alt yaşam biçimleri eğer başarılı olurlarsa, aslında eninde sonunda kendi yaşam alanlarını yıkıma uğratırlar.
      </para><para>
Toplumsal yaşam, felsefe, vs. bırakın bunları bir kenara: Sen - posta sisteminin yöneticisi - bu döküntüden kurtulmanın bir yolunu bulmak gibi çok somut bir görevin var, bununla yüzleş.
      </para><para>
Konumuza dönersek, posta aktarım ve teslimat yazılımlarının ceşitli bileşenleri tarafından işleme sokulan postalarla ilgili üzerinde uzlaşılmış bazı sınırlamalar vardır. Geleneksel yapılandırmada, bir alanın adreslerine gelen posta teslimatlarının çoğu ya da tamamı bir veya daha fazla sayıda <xref linkend="spam-filtering-mx"/> tarafından kabul edilir. Çoğunlukla, bunlar postayı kullanıcıların posta kutularına teslim edilmek üzere dahili ağdaki bir veya daha fazla sayıda makineyi gönderirler. Eğer bu sunuculardan biri istenen teslimatın veya işlemin gerçekleştirilemeyeceğini saptarsa, özgün postanın göndericisine özdevinimli üretilmiş bir <xref linkend="spam-filtering-dsn"/> döndürür.
    </para><para>
Spam ve virüs tarayıcıları konuşlandıran organizasyonlar genellikle, <link linkend="spam-filtering-mx">posta alıcılarından</link> gelen postaları dahili konaklara ya da yazılımlara yönlendirmeden önce iletinin olası en düşük dirençle teslimat yolunu aşmalarını sağlamaya çalışırlar. Spamı filtreleme için tercih edilen yöntem, iletiyi kullanıcının posta kutusuna teslim etmeden önce SpamAssassin veya benzeri bir yazılım üzerinden geçirmek ve/veya kullanıcının <xref linkend="spam-filtering-mua"/>ndeki spam filtreleme yeteneklerine güvenmek şeklindedir.
    </para><para>
Bu noktada spam ya da virüslü olarak tasnif edilmiş postalara uygulanacak işlemler sınırlıdır:
      </para><para>
      <itemizedlist><listitem><para>
Göndericiye bir <xref linkend="spam-filtering-dsn"/> döndürebilirsiniz. Burada sorun, hemen hemen tüm spamların ya da virüslü postaların taklit edilmiş bir gönderici adresiyle yollanmasıdır. Eğer böyle bir postayı gönderirseniz, posta büyük ihtimalle bunda bir kabahati olmayan kişilere gidecektir. Kimbilir, belki de bilgisayarlar hakkında pek bilgisi olmayan bir ninenin bilgisayarına Blaster kurdunu bulaştırmış olacaksınız. Başka bir deyişle <xref linkend="spam-filtering-colspam"/> üretmiş olacaksınız.
      </para></listitem><listitem><para>
Göndericiye herhangi bir uyarı döndürmeksizin iletiyi çöpe gönderebilirsiniz. Gerek gönderici gerekse alıcı (böyle bir iletinin varlığından bile haberi olmaz) iletiye ne olduğunu bilmeyeceği için bu işlem, <xref linkend="spam-filtering-falsepos"/> durumuna uyan daha büyük bir soruna dönüşür.
      </para></listitem><listitem><para>
Kullanıcıların postalarına nasıl eriştiğine bağlı olarak (örneğin, IMAP protokolü üzerinden veya POP-3 ile almaksızın web tabanlı posta okuyucu kullanarak erişenler) ve hesaplarına bir seçenek olarak sunarak, bu tür postaların kullanıcının alanındaki ayrı bir döküntü dizinine konmasını sağlayabilirsiniz.
     </para><para>
Bu, bu üç seçenekten belki de en iyisi. Öyle de olsa, bazı meşru iletiler alıcının kendi döküntü dizinini tarama sıklığına bağlı olarak gözden uzak kalabilir veya silme sırasında gözden kaçabilirler.
     </para></listitem>
     </itemizedlist></para>
    </sect3>
    <sect3 id="spam-filtering-solution">
      <title>Çözüm</title><para>
Artık sizin de tahmin edebileceğiniz gibi bu sorunun <emphasis>tek doğru</emphasis> çözümü, spam ve virüs filtrelemesini alanınıza gelen postaları alan <xref linkend="spam-filtering-mx"/> üzerinde SMTP diyaloğu sırasında yapmaktır. Bu yolla, eğer posta istenmeyen türdeyse, yukarıda açıklanan çözümsüzlüklere düşmeden, bir SMTP <emphasis>red</emphasis> yanıtı yeterli olur. Sonuç olarak:
      </para><para>
      <itemizedlist><listitem><para>
Asıl ileti alınmadan önce, SMTP aktarımının başında, istenmeyen postanın çoğunun teslimatını durdurmanız mümkün olur. Böylece, ağ band genişliğini daha verimli kullanmış olmanın yanında işlemcinizi de daha az meşgul etmiş olursunuz.
      </para></listitem><listitem><para>
Daha sonra yapıldığında yararı olmayan, <xref linkend="spam-filtering-smtpdelays"/>, <xref linkend="spam-filtering-greylisting"/> gibi spam filtreleme tekniklerini devreye sokmak mümkün olur.
      </para></listitem><listitem><para>
Bir teslimatın mümkün olmadığı durumlarda (alıcı adresin geçersiz olması gibi), <xref linkend="spam-filtering-colspam"/> üretmeksizin göndericiyi uyarmanız mümkün olur.
      </para><para>
Posta listeleri, başka sitelerin posta hesapları gibi güvenilir kaynaklardan yönlendirilen postaların reddedilmesinin bir sonucu olarak dolaylı spama sebep olmaktan nasıl kaçınacağınızı anlatacağız<footnote><para>
Eğer postayı reddederseniz, güvenilmez üçünçül sunucular hala dolaylı spam üretebilir. Yine de, bu sunucu bir <xref linkend="spam-filtering-openproxy"/> veya <xref linkend="spam-filtering-openrelay"/> olmadıkça, büyük ihtimalle postaları meşru göndericilerin geçerli adreslerine teslim edecektir. Postayı reddederek postanın sizin gelen posta kuyruğunuzda donması yerine onların giden posta kuyruklarında donmasını sağlamak daha iyidir. Böylelikle, bu sunucuların sahiplerine de bir ipucu verilmiş olur.</para></footnote>.
      </para></listitem><listitem><para>
Başkalarından kaynaklanan dolaylı spama (antivirüs yazılımlarının <quote>Sizde virüs var</quote> tarzı hatalı uyarıları) karşı kendinizi korumanız mümkün olur.
      </para></listitem></itemizedlist>
      </para><para>
Artık havadaki eller inebilir. Ayakları da havada olanlar siz de ayağa kalkabilirsiniz.
      </para>
    </sect3>
  </sect2>
  <sect2 chunkthis="1" id="spam-filtering-goodbadugly">
    <title>İyi, Kötü, Çirkin</title><para>
Filtreleme tekniklerinin bazıları SMTP aktarımı sırasında kullanılmaya diğerlerinden daha elverişlidir. Bunların bazıları da biraz daha iyidir. Hemen hemen hepsinin taraftarları olduğu gibi muhalifleri de vardır.
    </para><para>
Yorum yapmadan, tartışmalara yolaçan yöntemleri de burada açıklayalım. Örneğin:
    </para><para>
    <itemizedlist><listitem><para>
Bir iddia, <xref linkend="spam-filtering-dnschecks"/>nın, posta göndericilerini, gönderdikleri iletilerin liyakatine bakmaksızın, tamamen kullandıkları internet hizmet sağlayıcılarından (İSS'lerinden) dolayı cezalandırdığı şeklindedir.
    </para></listitem><listitem><para>
Bazıları, <xref linkend="spam-filtering-smtpdelays"/> ve <xref linkend="spam-filtering-greylisting"/> gibi <xref linkend="spam-filtering-ratware"/> tuzaklarının kolayca üstesinden gelindiğini ve uzun vadede meşru postalar açısından servis kalitesini düşürerek etkilerinin azalacağına işaret etmektedir.
    </para></listitem><listitem><para>
Bazıları, <xref linkend="spam-filtering-spf"/> gibi <xref linkend="spam-filtering-senderauth"/>nın servis sağlayıcılara, epostalarını farklı ağlar arasında dolaştıran ya da bir konaktan diğerine yönlendiren müşterilerini içerde tutmanın yolunu açacağını savunmaktadır.
      </para></listitem></itemizedlist>
    </para><para>
Bu tartışmaların çoğundan uzak durararak, kullanılabilir olan çeşitli tekniklerin olası yan etkilerini de dahil ederek işlevsel açıklamalarını yapmaya çalışırken, biraz da bunların kullanımıyla ilgili kendi deneyimlerimden bahsedeceğim.
    </para><para>
Bilinçli olarak bu belgenin kapsamına almadığım ve günümüzde hala kullanılmakta olan bazı filtreleme teknikleri var:
    </para><para>
    <itemizedlist>
      <listitem><para>
Soru/cevaplı kimlik kanıtlama sistemleri (<ulink url="http://tmda.net/">TMDA</ulink> gibi).  Postayı alır almaz röleledikten sonra <xref linkend="spam-filtering-envfrom"/>ne bir doğrulama isteği döndürmeleri sebebiyle bu sistemler SMTP sırasında filtrelemeye uygun değildirler. Bu sebepten bu teknik bu belgenin kapsamı dışında tutulmuştur<footnote><para>
Kişisel olarak, hiçbir durumda bu tekniklerin iyi bir fikir olmadığını düşünüyorum. Bunlar, <xref linkend="spam-filtering-colspam"/> üretirler. Bunlar örneğin aylık banka talimatları gibi özdevinimli hale getirilmiş kaynaklardan posta gönderimi sözkonusu olduğunda özel bir dikkat gerektirirler ve kişilerin birbiriyle iletişim kurabilmesi için önlerine aşmaları gereken engeller konulmuş olduğundan epostanın kullanım rahatlığını bozarlar. Çoğu zaman, meşru posta göndericileri doğrulama isteği karşısında neler yapılması gerektiğini bilmediklerinden ya da bununla uğraşmak istemediklerinden posta kaybolur.</para></footnote>.
      </para></listitem><listitem><para>
<xref linkend="spam-filtering-bayesian"/>. Bunların belli bir kullanıcıya ve/veya dile özgü eğitilmeleri gerekir. Bu sebeple bunlar da SMTP aktarımı sırasında kullanılmaya uygun değillerdir (Fakat, yine de <xref linkend="spam-filtering-usersettings"/> bölümüne bakın).
      </para></listitem><listitem><para>
<xref linkend="spam-filtering-micropay"/>, bütün dünyanın meşru postası bir sanal <emphasis>posta damgası</emphasis> ile gönderildiği sürece, döküntü postayı ayıklamada aslında bir yararı olmayacaktır. (Orta ya da uzun vadede, tamamen zıt amaçlar için kullanılmaya başlanabilir - normalde reddedilmesi gereken bir postanın sırf damgalı diye kabul edilmesi durumu.)
      </para></listitem></itemizedlist>
    </para><para>
Genel olarak önerdiğim teknikler somut ve <xref linkend="spam-filtering-falsepos"/> sonucunu doğurmayacak tekniklerdir. Kişilerin epostaları hazırlamak için harcadıkları çabaya ve bu iletilerin onlar için taşıdığı öneme göstereceğimiz saygının gereği olarak büyük miktarda meşru iletinin reddedilmesine yol açabilecek tekniklerden bilinçli bir şekilde kaçınmamız çok önemlidir.<footnote><para>
<ulink url="http://www.spews.org/">SPEWS</ulink> <link linkend="spam-filtering-dnsbl">karalistesi</link> benzeri listeleri ortaya koyan <quote>spam filtreylemcileri</quote>nden çok kesin bir şekilde farklı bir yaklaşım ortaya koymaya çalıştım. Örnek olarak SPEWS listesinin benimsediği yaklaşım, <link linkend="spam-filtering-coldamage">yaratılacak ikincil hasar</link> üzerinden İSS'ler üzerinde baskı oluşturmak ve kullanıcılardan gelecek şikayetlere İSS'lerin yanıt vermesini sağlamaktır. Kullanıcıların ikincil hasar yaratanlara yaptıkları şikayetlere aldıkları yanıt tipik olarak <quote>sizin İSS'niz bundan sorumlu, gidin onlara başvurun</quote> veya <quote>İSS'nizi değiştirin</quote> şeklinde olmaktadır.
        </para><para>
Mamafi bunlar uygulanabilir seçenekler değildir. Gelişmekte olan ülkeleri ele alırsak kullanıcıların daha iyi hizmet alabilecekleri başka bir İSS olmayabilir. Gelişmiş ülkelerdeki geniş bant sağlayıcılarını ele aldığımızda ise çoğu yerde bunların birer tekel olduğunu görmekteyiz. Dolayısıyla SPEWS gibi listelere güvenmekle karşılacağımız sorunlar aşikardır.
        </para><para>
Daha basit bir şekilde ifade edersek, döküntü postayı ayıklamak için başka çok daha iyi ve doğruluğu yüksek yöntemler mevcuttur.
        </para>
      </footnote>
Bu özellikle SMTP sırasında sistem çapında filtreleme yapıldığında önem kazanıyor, çünkü postaların son alıcılarının postaları filtrelemede kullanılan kriterler hakkında ya hiç bilgileri yok ya da bunlar üzerinde çok az hakimiyet sağlayabiliyorlar.
    </para>
  </sect2>
  <sect2 chunkthis="1" id="spam-filtering-smtpintro">
    <title>SMTP Aktarımı</title><para>
SMTP internette posta teslimatı için kullanılan protokolün ismidir. Protokolün ayrıntılı açıklamasını <link linkend="rfc2821">RFC 2821</link>'de bulabilirsiniz. Ayrıca, Dave Crocker'ın <ulink url="http://www.brandenburg.com/specifications/draft-crocker-mail-arch-00.htm">İnternet Postalarının Mimarisi</ulink>'ne bakışını da okumanızı öneririm.
    </para><para>
Posta teslimatları bağlanan konak (istemci) ile bağlanılan konak (sunucu) arasındaki SMTP işlemleri ile yapılır.
    </para><para>
Tipik bir SMTP aktarımında, istemci <command>EHLO</command>, <command>MAIL FROM:</command>, <command>RCPT TO:</command> ve <command>DATA</command> gibi komutlar gönderir. Sunucunuz her komuta 3 rakamlık bir sayısal kod (komutun kabul edildiğini belirmek için  <command>2<parameter>xx</parameter></command>, geçici bir sorun ya da kısıtlayıcı bir durum için <command>4<parameter>xx</parameter></command>, kesin ve mutlak başarısızlık halinde <command>5<parameter>xx</parameter></command>) ve bunu izleyen insanların anlayabileceği bir açıklama ile yanıt verir. Bu kodların tamamı <link linkend="rfc2821">RFC 2821</link>'de açıklanmıştır.
    </para><para>
SMTP aktarımında eniyi durum senaryosu genel olarak birbirini izleyen şu adımlardan oluşur:
    </para><para>
    <table id="spam-filtering-smtpdialogue" frame="all">
      <title>Basit SMTP diyaloğu</title>
      <tgroup cols="2" align="left" colsep="1" rowsep="1">
        <thead><row>
            <entry>İstemci</entry>
            <entry>Sunucu</entry>
        </row></thead>
        <tbody><row>
<entry><para>Sunucuya bir TCP bağlantısı kurar.</para></entry>
<entry><para>SMTP (veya halefi olan ESMTP) diyaloğuna hazır olduğunu belirtmek için  <command>220</command> koduyla başlayan bir karşılama iletisi gönderir:
  </para><para>
<screen>
220 <emphasis>sunucu.f.q.d.n</emphasis> ESTMP...
</screen>
</para></entry>
        </row><row>
<entry><para>
Bir <command>HELO</command> (artık atıl) ya da  <command>EHLO</command> ile başlayan ve kendi <xref linkend="spam-filtering-fqdn"/>nı içeren bir selamlaşma komutu ile kendini tanıtır:
  </para><para>
<screen>
EHLO <emphasis>istemci.f.q.d.n</emphasis>
</screen>
</para></entry><entry><para>
Bir <command>250</command> yanıtı ile bu selamı kabul eder. Eğer istemci selamlaşma komutunun gelişmiş sürümünü (<command>EHLO</command>) kullanmışsa, sunucunuz onun çok satırlı yanıtları işleme yeterliliğinde olduğunu anlar ve normal olarak kendi yeteneklerini belirten satırları gönderir:
  </para><para>
<screen>
250-<emphasis>sunucu.f.q.d.n</emphasis> Hello ...
250-SIZE 52428800
250-8BITMIME
250-PIPELINING
250-STARTTLS
250-AUTH
250 HELP
</screen>
  </para><para>
Bu yanıt <command>PIPELINING</command> yetisini içeriyorsa, istemci bu noktadan sonra herbiri için ayrı ayrı yanıt beklemeksizin bir çok komutu bir kerede gönderir.
</para></entry>
          </row><row>
<entry><para>
<xref linkend="spam-filtering-envfrom"/>ni belirterek yeni bir posta aktarımı başlatır:
  </para><para>
<screen>
MAIL FROM:&lt;<emphasis>gönderen</emphasis>@<emphasis>adres</emphasis>&gt;
</screen>
</para></entry><entry><para>
Göndericinin kabul edildiğini belirten bir <command>250</command> yanıtı gönderir.
</para></entry>
          </row><row>
<entry><para>
İletinin <link linkend="spam-filtering-envto">Zarf Alıcıları</link>nı bir defada liste halinde yollar:
  </para><para>
<screen>
RCPT TO:&lt;<emphasis>alıcı</emphasis>@<emphasis>adres</emphasis>&gt;
</screen>
</para></entry><entry><para>
Her komuta o alıcı için teslimatın kabul mü edildiğine (<command>2<emphasis>xx</emphasis></command>), geçici bir sorun mu oluştuğuna (<command>4<emphasis>xx</emphasis></command>) yoksa red mi edildiğine (<command>5<emphasis>xx</emphasis></command>) dair bir yanıt döndürür.
</para></entry>
          </row><row>
<entry><para>
İletiyi göndermeye hazır olduğunu belirten bir <command>DATA</command> komutu gönderir.
</para></entry><entry><para>
Komutun geçici olarak kabul edildiğini belirten <command>354</command> yanıtını gönderir.
</para></entry>
          </row><row>
<entry><para>
<link linkend="rfc2822">RFC 2822</link> uyumlu başlık satırları (<option>From:</option>, <option>To:</option>, <option>Subject:</option>, <option>Date:</option>, <option>Message-ID:</option> gibi) ile başlayan iletiyi aktarmaya başlar. Başlık ve gövde bir boş satırla ayrılır. İletinin sonunda ileti sonunu belirten ve tek bir nokta içeren ek bir satır göndererek ileti aktarımını bitirir.
</para></entry><entry><para>
İletinin kabul edildiğin belirten <command>250</command> yanıtını gönderir.
</para></entry>
          </row><row>
<entry><para>
Eğer teslim edilecek başka iletiler de varsa, bir <command>MAIL FROM:</command> komutu gönderir. Aksi takdirde, <command>QUIT</command> der ya da yaygın bir durum olarak basitçe bağlantıyı keser.
</para></entry><entry><para>
Bağlantıyı keser.
</para></entry>
          </row>
        </tbody>
      </tgroup>
    </table></para>
  </sect2>
</sect1>

<sect1 id="spam-filtering-techniques">
  <title>Teknikler</title>
    <para>
Bu bölümde, uzak konaklardan SMTP aktarımı sırasında döküntü postayı ayıklamanın çeşitli yollarına bakacağız. Ayrıca, bu teknikleri konuşlandırmanın bazı yan etkilerini önceden tahmin etmeye çalışacağız.
    </para>
  <sect2 chunkthis="1" id="spam-filtering-smtpdelays">
    <title>SMTP Aktarımının Geciktirilmesi</title><para>
Açıkça ortaya çıktığı gibi, spamı durdurmanın en etkin yollarından biri SMTP diyaloğu sırasında aktarıma gecikmeler koymaktır. Bu  ilkel bir <emphasis>katran çukuru</emphasis> (teergrubing) türüdür (bkz. <ulink url="http://www.iks-jena.de/mitarb/lutz/usenet/teergrube.en.html"/>).
    </para><para>
Virüs taşıyan epostaların hemen hepsi ve çoğu spam çok kısa sürede büyük miktarda postayı göndermek üzere eniyilenerek amaca uygun hale getirilmiş bir SMTP istemci yazılımı yoluyla sunucunuza doğrudan doğruya teslim edilir. Böyle istemciler genel olarak <xref linkend="spam-filtering-ratware"/> olarak bilinir.
    </para><para>
Kalleş yazılım yazarları bu işlemi yerine getirmek için <link linkend="rfc2821">RFC 2821</link> belirtimindekinden birazcık farklı birkaç kısayol kullanırlar. Kalleş yazılımların asıl hedefleri, sabırsızlıklarıyla ve özellikle yavaş yanıt vermeleriyle  nam salmış posta sunucularıdır. Sunucu daha SMTP aktarımına hazır olduğunu belirtmeden sunucuya bir <command>HELO</command> veya <command>EHLO</command> komutu gönderirler ve/veya sunucunun <command>PIPELINING</command> yetisini ilan etmesini beklemeksizin çeşitli SMTP komutlarıyla boru hattı oluşturmayı denerler.
    </para><para>
Bellibaşlı <link linkend="spam-filtering-mta">posta aktarımcıları</link> (Exim gibi) özdevinimli olarak SMTP protokolünün bu şekilde hiçe sayılmasını <emphasis>eşzamanlama hataları</emphasis> olarak ele alır ve gelen bağlantıyı hemen keser. Eğer böyle bir posta aktarımcısı kullanıyorsanız, günlük kayıt dosyalarında bu tür bir bağlantı reddine rastlamışsınızdır. Aslında, sunucunuza SMTP aktarımının hemen başında aktarıma hazır olduğunu belirtmeden önce, zaman kaybına sebep olan bazı sınamalar yaptırıyorsanız (<xref linkend="spam-filtering-dnschecks"/> gibi) böyle hatalar sıkça olur ve kalleş yazılımlar sunucunuzun canlanabilmek için biraz zamana ihtiyacı olabileceğini dikkate almadıklarından (spamcılar böyle düşünür) bir şansınız olur.
    </para><para>
Ek gecikmeler koyarak da bunun oluşmasına yardımcı olabiliriz. Örneğin biraz bekleme kararı verebiliriz:
    </para><para>
    <itemizedlist><listitem>
SMTP aktarımına hazır olduğunu bildirmeden önce 20 saniye,
    </listitem><listitem>
selamlaşmadan (<command>EHLO</command> veya <command>HELO</command>) sonra 20 saniye,
    </listitem><listitem>
<command>MAIL FROM:</command> komutundan sonra 20 saniye ve
    </listitem><listitem>
her <command>RCPT TO:</command> komutundan sonra 20 saniye.
    </listitem></itemizedlist>
    </para><para>
Nereden çıktı bu 20 saniye diyebilirsiniz. Neden bir dakika değil? Ya da birkaç dakika değil? Herşeyden önce, <link linkend="rfc2821">RFC 2821</link> gönderici konağın (istemcinin) her SMTP yanıtı için birkaç dakika beklemesini zorunlu kılar. Bazı alıcı konaklar, bilhassa Exim kullananlar, gelen posta teslimat bağlantılarına yanıt olarak <xref linkend="spam-filtering-callback"/> uygularlar. Siz veya kullanıcılarınızdan biri böyle bir konağa posta gönderdiğinde, bu konak sizin alanınız için yetkilendirdiğiniz <xref linkend="spam-filtering-mx"/>na bağlanıp gönderici adresinin doğrulanmasını sağlamak üzere bir SMTP diyaloğu başlatacaktır. Böyle bir <xref linkend="spam-filtering-callback"/> için öntanımlı zamanaşımı 30 saniyedir. Eğer koyduğunuz gecikme bu sürenin aşılmasına sebep oluyorsa, istemcideki <xref linkend="spam-filtering-callback"/> başarısız olacağından sizin ya da kullanıcınızın istediği posta teslimatı reddedilebilecektir (genellikle, posta teslimatının geri iade edilmeden önce 5 gün boyunca gerçekleştirilmeye çalışılacağını belirten bir geçici başarısızlık olarak).
    </para><para>
Başka bir deyişle, meşru posta teslimatı ile ilgili girişimin başlamasını geciktirebileceğiniz en uzun süre 20 saniyedir.
    </para><para>
Her SMTP aktarımına böyle gecikmeler uygulamak istemiyorsanız (çok meşgul bir siteniz vardır ve makinenizin kaynakları kıt kanaat yetiyordur), bu gecikmeleri <quote>seçimlik</quote> kullanabilirsiniz. Böyle durumlar:
    </para><para>
    <itemizedlist>
      <listitem><para>
İstemcinin DNS yapılandırmasıyla ilgili bir sorun varsa (bkz. <xref linkend="spam-filtering-dnschecks"/>).
      </para></listitem><listitem><para>
SMTP aktarımı sırasında bazı sorunların izleri saptandıktan sonra (bkz. <xref linkend="spam-filtering-smtpchecks"/>).
      </para></listitem><listitem><para>
Sadece DNS kaydınızdaki en yüksek numaralı yani en düşük öncelikli <xref linkend="spam-filtering-mx"/> üzerinde. Çoğunlukla, meşru posta göndericilerinin <link linkend="spam-filtering-mta">posta aktarımcıları</link> en düşük numaralı <link linkend="spam-filtering-mx">posta alıcılarını</link> denediği halde <xref linkend="spam-filtering-ratware"/>lar özellikle bu konakları tercih ederler.
      </para></listitem></itemizedlist>
    </para><para>
Aslında seçimlik aktarım gecikmeleri, bundan sonraki bölümlerde açıklayacağımız sınamalardan daha az kesin sınamalarla birlikte kullanıldığında iyi bir yöntem olabilir. Siz, büyük ihtimalle SPEWS gibi <link linkend="spam-filtering-dnsbl">karalisteler</link>den kaynaklı olarak posta reddini tercih etmezsiniz, ama bu listeleri gecikmenin uygulanmasında sorunun belirleyicisi olarak kullanabilirsiniz. Tüm bunlardan sonra, aşağılayıcı bir gecikmeye konu olanlar dışında kalan meşru postaların teslimatları bundan etkilenmeyecektir.
    </para><para>
Diğer taraftan, spam yapıldığının kesin kanıtını bulursanız (örn. <xref linkend="spam-filtering-smtpchecks"/> yoluyla) ve sunucunuzun gücü yetiyorsa, teslimatı reddetmeden önce 15 dakikalık veya buna yakın uzunca bir gecikme uygulayabilirsiniz<footnote><para>
Gelen bir SMTP bağlantısını kapının önünde bekletirken dikkatlı olmalısınız, çünkü kendi sunucunuzun TCP soketini de meşgul ediyor olacağınız gibi bu işleme ayrılmış bellek ve diğer sunucu kaynakları da fazladan harcanıyor olacaktır. Eğer sunucunuz genel olarak meşgul durumdaysa servis reddi (DoS) saldırılarına da açık hale gelecektir. Daha kabul edilebilir bir seçenek, göndericinin bir kalleş yazılım olduğunun kesin kanıtını elde ettikten sonra bağlantıyı kesmek olabilir.</para></footnote>.
Bunun spamcının yavaşlatılmasından başka bir yararı yoktur. Ama ne var ki, bunlar DNS karalistelerine ve bunlarla işbirliği yapanlara yakalanmadan önce daha az kişiye ulaşmalarını sağlamış olursunuz ve fedakarlığınızla başbaşa kalırsınız. <literal>:-)</literal>
    </para><para>
Benim durumumda, gelen teslimat bağlantılarından reddedilenlerin %50'si, seçimlik aktarım gecikmeleri ve SMTP eşzamanlama hatalarının sonucu reddediliyor. Kabaca bir yaklaşımla, gelen döküntü postanın yaklaşık %50'si tek başına SMTP aktarım gecikmelerinin sonucu olarak durdurulmaktadır, diyebiliriz.
    </para><para>
Ayrıca <xref linkend="spam-filtering-qanda-adapt"/>'e de bakınız.
    </para>
  </sect2>

  <sect2 chunkthis="1" id="spam-filtering-dnschecks">
    <title>DNS Sınamaları</title><para>
SMTP bağlantısı kurmak isteyen tarafın dürüstlüğünün belirtileri <xref linkend="spam-filtering-dns"/>'nden doğrudan toplanabilir, hatta bu SMTP komutlarının alınmasından önce yapılabilir. Bunun için, belirli koşulları yerine getirenlerin ya da bunlarla çeliştikleri bilinenlerin IP adreslerini bulmak için çeşitli DNS karalistelerine başvurulabilir ve/veya konağın genel olarak dürüstlüğünün ayırıcı bir belirtisi olan normal/ters DNS çifti arasındaki uyuma bakmak için basit bir DNS sorgusu yapılabilir.
    </para><para>
Bununla birlikte, SMTP diyaloğu sırasında sunulan çeşitli veri öğeleri (örn, selamlaşmada belirtilen isim) alındıktan sonra bunlar DNS doğrulamasına konu edilebilir. Bu veri öğelerinin açıklamalarını <xref linkend="spam-filtering-smtpchecks"/> bölümünde bulabilirsiniz.
    </para><para>
Yalnız, DNS sınamalarının olumsuz sonuçları tek başına spamın belirtisi olarak ele alınamaz (Sınama için kullanılan sunucu bir sorundan dolayı yanıt vermeyebilir). Bununla birlikte, eğer çok meşgul bir site iseniz, her ileti için harcanacak işlem zamanı pahalıya malolabilir. Bu durumda şu söylenebilir, DNS sınamaları oturum açabilmek için yararlı bilgileri elde edebilmek için ve/veya daha karmaşık dürüstlük sınalamarının bir parçası olarak kullanılabilir.
    </para>
    <sect3 id="spam-filtering-dnsbl">
      <title>DNS Karalisteleri</title><para>
DNS karalisteleri, aktarım sırasında spam engelleme amacıyla kullanılmak üzere oluşturulmuş araçlardır<footnote><para>Karaliste denince <quote>mail-abuse.org</quote> anlaşıldığından bunlara DNS karalisteleri - DNSbl - ya da daha tanımlayıcı olarak <quote>Gerçek zamanlı Karadelik Listeleri</quote> denir.
  </para><para>
Farklı amaçlar için kullanılan benzer listeler de vardır. Örneğin, <quote>bondedsender.org</quote> bir DNS aklistesidir (DNSwl); bunlarda kayıtlı olan <quote>güvenilir</quote> IP adreslerinin sahipleri kendilerinden bir spam kaynaklandığı takdirde bir ceza ödemeyi (bir senetle) taahhüt etmişlerdir. Diğer listeler, ülkelere ve İSS'lere özel IP adresleri içeren listelerdir.</para></footnote>
      </para><para>
DNS adresine ("A" kaydı) ek olarak bir girdinin "TXT" kaydına da bakmak isterseniz, bir SMTP red yanıtında kullanılabilecek tek satırlık bir liste açıklaması alırsınız. Bunu denemek isterseniz, çoğu Unix ve Linux sisteminde bulunan "host" komutunu kullanabilirsiniz:
    </para><para>
<screen>
host -t txt 2.0.0.127.dnsbl.sorbs.net
</screen>
      </para><para>
Bu listelerin farklı listeleme/listelememe kuralları olan yüzlerce çeşidi vardır. Bazı listeler bu farklı listeleme kurallarının bir bütünü olarak tek bir liste oluşturup, ters DNS sorgularına belirtilen adresin etkilendiği koşullara uyan farklı bir veri ile yanıt verirler. Örneğin, <option>sbl-xbl.spamhaus.org</option>'a yöneltilen bir ters DNS sorgusuna, SpamHaus kadrosu tarafından spamcılara ve onların İSS'lerine ait olduğunu sanılan IP adresleri için 127.0.0.2, <xref linkend="spam-filtering-zombie"/>lar için 127.0.0.4 ve <xref linkend="spam-filtering-openproxy"/> sunucuları için 127.0.0.6 yanıtı döner.
      </para><para>
Ne yazık ki, bu listelerden bazıları iyi tanımlanmamış listeleme kurallarıyla listelenen adresler hakkında yanlış bilgiler verirler ve iddia ettikleri çelişkilere uygun olmayan büyük IP bloklarını içerirler<footnote><para>
Örneğin, dünyanın en büyük İSS'sinin, comcast.net'in posta aktarımcıları bu belgenin yazımı sırasında SPEWS'in 1. seviye listesine kaydedilmişti. Comcast'ın kendi müşterilerini kurallara uymaya daha etkin zorlaması gerektiğinden bu tamamen haksız bir uygulama olmasa da, bunun sonuçlarından benim gibi bunda hiç suçu olmayanlarla birlikte, ABD internet kullanıcılarının %30'u etkileniyor.
        </para><para>
Duruma açıklık kazandırmak için <ulink url="http://spews.org/faq.html">SPEWS SSS</ulink>'inde yayınlanmış olan açıklamaya bakalım:<emphasis>
1. seviye listesi ekseriyetle, birkaç meşru müşterisi varmış gibi görünen ama genelde spamcılar veya spam işlemine destek verenlerin sahibi oldukları IP bloklarından oluşur.</emphasis>
Teknik olarak, bu bilgi doğrudur, ancak (a) Comcast'ın bir <quote>spam destekçisi</quote> olduğunu, (b) <quote>diğerleri</quote>nin azınlık olduğunu varsayarsanız. Duruma bakınca bu bilginin açıkça yanlış olduğu görülür.</para></footnote>.
Böyle listelere körükörüne güvenmek çoğunlukla <xref linkend="spam-filtering-coldamage"/> olarak bilinen (<xref linkend="spam-filtering-colspam"/> sonucu olmayan) duruma yolaçar.
      </para><para>
Bu sebeplerden, DNS karalistelerine bağlı tek bir olumlu yanıta bağlı kalarak posta teslimatlarını reddetmek yerine, çoğu yönetici bu listeleri biraz daha ayrıntılı bir inceleminin konusu yaparlar. Çeşitli listelere başvurup her olumlu yanıta bir puan verirler. Toplam puanın önceden belirlenmiş bir eşiği aşması durumunda bu adresten gelen teslimatı reddederler. DNS listelerinin bu şekilde kullanımı daha çok SpamAssassin (bkz. <xref linkend="spam-filtering-spamscanners"/>) gibi filtreleme yazılımlarının kullandıkları yöntemi andırır.
      </para><para>
Böyle listelerin bir diğer kullanım şekli de, SMTP aktarımına koşullu gecikmeler koymuşsanız (nam-ı diğer "katran çukuru") bunların tetiklenmesi için kullanımıdır. Eğer bir konak DNS karalistesindeyse, bu konağın gönderdiği her komuta bir gecikme ile (örn, 20 saniye) yanıt vermek tercih edilebilir. Bu tür gecikmeleri tetiklemek için kullanılabilen başka önkoşullar da vardır; <xref linkend="spam-filtering-smtpdelays"/> bölümüne bakınız.
      </para>
    </sect3>
    <sect3 id="spam-filtering-rdns">
      <title>DNS Düzgünlük Sınamaları</title><para>
DNS kullanımının diğer bir yolu karşı tarafın IP adresinde bir ters DNS kaydı olup olmadığına bakmaktır. Bu tür sorguların sonucu, böyle bir kayıt varsa, bir alan adı olacaktır. Bu sonuç özgün IP adresini de içeriyorsa, DNS düzgünlüğü doğrulanmış olur. Aksi takdirde, bağlanan konağın DNS bilgileri geçersiz kabul edilir.
      </para><para>
Eğer DNS polislerinden biriyseniz, bunu postaların reddedilmesi için bir önkoşul olarak kullanabilirsniz. Kişisel alanınızın posta alıcısını buna göre yapılandırır, meşru posta göndericilerine, sistem yöneticilerinin DNS kayıtlarını düzeltmelerini istemeleri için onlara uyarılar gönderebilirsiniz. Bunun dışında, DNS düzgünlük sınamalarının sonucu daha kapsamlı bir filtrelemenin parametrelerinden biri olarak kullanılabilir. Ancak, yukarıdaki gibi DNS kayıtları yanlış yapılandırılmış konaklar için sırf ters DNS kaydı düzgün değil diye SMTP aktarım gecikmeleri kullanmak iyi bir fikir olmayabilir.
      </para>
    </sect3>
  </sect2>
  <sect2 chunkthis="1"  id="spam-filtering-smtpchecks">
    <title>SMTP Sınamaları</title><para>
SMTP diyaloğu başladıktan sonra, karşı taraftan gönderilen komutlar ve bunların parametreleri üzerinde çeşitli sınamalar yapabilirsiniz. Örneğin, selamlaşma sırasında karşı tarafın belirttiği ismin geçerli olup olmadığına bakabilirsiniz.
    </para><para>
Bununla birlikte, teslimatı reddetmeye daha SMTP aktarımının başlarında karar verseniz bile bunu hemen yapmamak, bir <command>RCPT TO:</command> komutu gelene kadar SMTP aktarım gecikmesiyle göndericiyi bekletmek ve <command>RCPT TO:</command> komutunu aldıktan sonra reddetmek daha iyidir.
    </para><para>
Bunun sebebi, bazı kalleş yazılımların SMTP aktarımının daha başlarında reddedildiklerini ama bekletilmeye çalışıldıklarını anlamamaları içindir. Ayrıca, bunların reddedilme sebebinin <command>RCPT TO:</command> başarısızlığından kaynaklandığını sanmaları da sağlanmış olur.
    </para><para>
Bu, küçük de olsa bir katran çukuru yapmak için ayrıca hoş bir vesiledir.
    </para>
    <sect3 id="spam-filtering-helocheck">
      <title>Selamlaşma (HELO/EHLO) Sınamaları</title><para>
<link linkend="rfc2821">RFC 2821</link>'e göre, istemci tarafından gönderilecek ilk SMTP komutu EHLO (ya da desteklenmiyorsa HELO) olmalı ve komuta parametre olarak kendi birincil <xref linkend="spam-filtering-fqdn"/>nı vermelidir. Bu işleme Selamlaşma (Hello greeting) adı verilir. Eğer anlamlı bir nitelikli alan adı veremiyorsa, istemci köşeli ayraç içine alınmış IP adresini belirtebilir: "[1.2.3.4]". Bu biçime IPv4 adresinin "dizgesel" gösterimi denir.
      </para><para>
Anlaşılacağı üzere, bir <xref linkend="spam-filtering-ratware"/> da selamlaşma sırasında kendi nitelikli alan adını genelde sunar. Ama, kalleş yazılım amacına uygun olarak gönderici konağın kimliğini gizlemeye ve/veya karışıklık yaratmaya ve/veya ileti başlığında "Received:" gibi başlıklarla sunucuyu yanıltmaya çalışır. Bu tür selamlaşma örneklerinden bazıları:
      </para><para>
      <itemizedlist>
        <listitem>
Alıcı adresindeki kullanıcı ismi gibi niteliksiz isimler (noktasız isimler).
        </listitem><listitem>
Çıplak IP adresi (köşeli ayraç içine alınmamış olarak); genellikle sizinki, ama rasgele bir adres de olabilir.
        </listitem><listitem>
Sizin alan adınız ya da sunucunuzun nitelikli alan adı.
        </listitem><listitem>
<option>yahoo.com</option>,  <option>hotmail.com</option> gibi çok bilinen alan adları.
        </listitem><listitem>
Mevcut olmayan alan adları veya isim sunucusu olmayan alanların adları.
        </listitem><listitem>
Hiç selamlaşmaz.
        </listitem>
      </itemizedlist>
      </para>
      <sect4 id="spam-filtering-helosyntax">
        <title>Basit HELO/EHLO sözdizimi sınamaları</title><para>
Bu <link linkend="rfc2821">RFC 2821</link> kurallarına uymayanlara karşı ve bazı <xref linkend="spam-filtering-ratware"/> türlerininin bilinen belirtileri nedeniyle bu sınamalarını yapmak kolaydır. Böyle selamlaşmaları ya hemen ya da <command>RCPT TO:</command> komutundan sonra reddedebilirsiniz.
        </para><para>
Öncelikle, selamlaşma sırasında çıplak IP adresi belirtenleri gönül rahatlığıyla reddedebilirsiniz. Eğer <link linkend="rfc2821">RFC 2821</link>'in zorunlu kıldığı, tavsiye ettiği ya da seçiminize bıraktığı herşeye genel anlamda izin vermekten yanaysanız, bir isim yerine belirtildiğinde IP adreslerinin köşeli ayraç içine alınması gerektiğini aklınızdan çıkarmayın<footnote><para>
Döküntü postayı normal postadan ayırmak açısından bu sınama normalde yeterliymiş gibi görünse de, <ulink url="http://www.lsoft.com/products/default.asp?item=listserv">listserv</ulink> kurulumlarının liste sunucusunun çıplak IP adresiyle selamlaşmayı başlattığı şeklinde L-Soft'un hata raporları vardır.</para></footnote>
        </para><para>
Özellikle, <emphasis>sizin</emphasis> IP adresinizi kullanarak selamlaşmaya girişen konakları sert bir dille yazılmış bir iletiyle reddedebilirsiniz. Bunlar açıkça yalancıdır. Hatta, böyle selamlaşmalara girişenleri uzunca süren (saatlerce) SMTP aktarım gecikmeleriyle kapıda bekletirseniz hiç fena olmaz.
        </para><para>
Bu konuda benim kendi deneyimlerim, internette kendilerini dizgesel IP adresi belirterek ([x.y.z.w] gösterimiyle) başka sitelere tanıtan bir meşru site olmadığı gibi bunların internete posta gönderen bütün konakları kendilerinin geçerli <xref linkend="spam-filtering-fqdn"/>ndan başka bir isim kullanmamaktadırlar. Dizgesel IP adresi kullanımını sadece yerel ağımdan, o da gönderici SMTP sunucusu olarak benim sunucumu kullanmak üzere yapılandırılmış Ximian Evolution gibi posta istemcilerinden gelirse kabul ediyorum. Yani, dizgesel IP adresi kullananları sadece yerel ağımdan geliyorlarsa kabul ediyorum.
        </para><para>
Niteliksiz konak isimlerini (nokta içermeyen konak isimleri) reddedip etmemek size kalmış, Bunların yaygın olarak meşru kabul edildiklerini biliyorum (ama her zaman değil - çifte yanlış olumlama sebebi olabilirler).
        </para><para>
Benzer şekilde, geçersiz karakter içeren konak isimlerini reddedebilirsiniz. İnternet alan adları için sadece harfler, rakamlar ve tire işareti geçerli karakterlerdir ve tire işaretine ilk karakter olarak izin verilmez. (Ayrıca, altçizgi karakterini de geçerli bir karakter olarak kabul edebilirsiniz, basitçe yanlış yapılandırmanın bir sonucudur ama Windows istemciler için bu bir yanlış değildir.)
        </para><para>
Son olarak, sosyal kişilerin ilk yaptığı şeyi yapmayan yani selamlaşmadan bir <command>MAIL FROM:</command> komutu gönderen bir istemci ile karşı karşıyaysanız bu bağlantıyı da reddedebilirsiniz.
        </para><para>
Kendi sunucularımda, bu sözdizimi sınamalarından geçemeyenleri reddediyorum. Yine de reddetme işlemini <command>RCPT TO:</command> komutunu alana kadar yapmıyorum. Böyle bir durumda, her SMTP komutuna (<command>HELO/EHLO</command>, <command>MAIL FROM:</command>, <command>RCPT TO:</command>) 20 saniyelik bir aktarım gecikmesi uyguluyorum.
        </para>
      </sect4>

      <sect4 id="spam-filtering-heloverify">
        <title>Selamlaşmanın DNS üzerinden doğrulanması</title><para>
Konaklar selamlaşmayı gayet yüzeysel bir manada yaparlar. Selamlaşma, bu sırada belirtilen ismi DNS üzerinden doğrulatmak için en doğru zamandır. Şunları yapabilirsiniz:
        </para><para>
        <itemizedlist>
          <listitem>
Belirtilen ismi DNS sunucusundan sorgulayıp bağlanan konağın IP adresi ile bu ismin eşleşip eşleşmediğine bakabilirsiniz.
          </listitem><listitem>
Bağlanan konağın IP adresine bir ters DNS sorgusu yapıp, gelen ismin selamlaşmada belirtilen isim ile eşleşip eşleşmediğine bakarsınız.
          </listitem>
        </itemizedlist>
        </para><para>
Eğer bu iki sınama da başarılı olursa, isim doğrulanmış olur.
        </para><para>
Posta aktarımcınız yerleşik bir seçenek olarak bu sınamayı yapabiliyor olabilir. Örneğin <link linkend="spam-filtering-exim">Exim</link> için "helo_try_verify_hosts = *" atamasını yapıp, "verify = helo" koşuluna göre işlem yapan ACL'ler oluşturabilirsiniz.
        </para><para>
Bu sınama, basit sözdizimsel sınamalardan biraz daha fazla ağ özkaynağı tüketir ve biraz daha fazla işlem süresi gerektirir. Bununla birlikte, sözdizimsel sınamaların aksine, bir eşleşmenin olmayışı bir kalleş yazılımın varlığını işaret etmeyebilir. hotmail.com, yahoo.com ve amazon.com gibi büyük internet sitelerinin selamlaşmaları doğrulanabilir türde değildir.
        </para><para>
Eğer, sınama öncesi aktarım gecikmeleri ile göndericiyi zaten oyalamıyorsam, sunucularımda selamlaşma sırasında bir DNS doğrulaması yapıyorum. Bu sınama başarısız olduğu takdirde, her SMTP komutuna 20'şer saniyelik gecikmeler uyguluyorum. Ayrıca ileti başlığına bir <quote>X-HELO-Warning:</quote> ekliyorum ve bunu iletinin tamamı alındıktan sonra olası bir red için <link linkend="spam-filtering-spamassassin">SpamAssassin</link> puanını arttırmakta kullanıyorum.
        </para>
      </sect4>
    </sect3>

    <sect3 id="spam-filtering-senderchecks">
      <title>Gönderici adresi sınamaları</title><para>
Bağlanan konak <command>MAIL FROM:</command> &lt;<parameter>adres</parameter>&gt; komutunu gönderdikten sonra, bu komutla belirtilen <xref linkend="spam-filtering-envfrom"/> adresini doğrulatmaya çalışabilirsiniz<footnote><para>
<xref linkend="spam-filtering-dsn"/> ve özdevinimli üretilmiş diğer yanıtlarda kullanılan <command>MAIL FROM:</command> &lt;&gt; gibi boş zarf göndericili komutlar <emphasis>özel</emphasis> bir durumdur.</para></footnote>.
      </para><para><variablelist><varlistentry>
      <term id="spam-filtering-sendersyntax">Gönderici adresinin sözdizimsel sınaması</term>
      <listitem><para>
Belirtilen adres &lt;<parameter>yerelkısım</parameter>@<parameter>alan</parameter>&gt; biçimine uygun mu? <parameter>alan</parameter> parçası sözdizimsel olarak geçerli bir <xref linkend="spam-filtering-fqdn"/> mı?
        </para><para>
Çoğunlukla, posta aktarımcınız bu sınamaları zaten yapar.
        </para></listitem></varlistentry><varlistentry>
      <term id="spam-filtering-impostor">Sahtekarlık sınaması</term>
      <listitem><para>
Siz ya da kullanıcılarınız, postalarını sadece belli başlı sunucular üzerinden gönderiyorsa, diğer konaklardan sizin alan adınızı taşıyan zarf göndericisi adresli olarak gelen iletileri reddedebilirsiniz.
        </para><para>
Bu sınamayı da kapsayan daha geniş amaçlı bir sınama <xref linkend="spam-filtering-spf"/>dır.
        </para></listitem></varlistentry><varlistentry>
      <term id="spam-filtering-sendervalid">Basit gönderici adresi doğrulaması</term>
      <listitem><para>
Adres yerelse, adresin yerel kısmı (@ işaretinden önceki isim) sisteminizdeki geçerli posta kutularından birinin ismi mi?
        </para><para>
Adres uzaksa, adresin alanadı kısmı (@ işaretinden sonraki parça) mevcut mu?
        </para></listitem></varlistentry><varlistentry>
      <term id="spam-filtering-callback">Gönderici Varlık Sınaması</term>
      <listitem><para>(Sender Callout Verification)</para><para>
Exim ve Postfix gibi bazı posta aktarımcıları tarafından uzak gönderici adresindeki <quote>yerel kısmı</quote> doğrulatmakta kullanılan bir mekanizmadır. Postfix terminolojisinde buna <quote>Gönderici Adresinin Doğrulanması</quote> (Sender Address Verification) adı verilir.
        </para><para>
Sunucunuz gönderici adreste belirtilen <parameter>alan adı</parameter>'nın posta alıcısına bağlanır ve bu adrese posta teslim ediyormuş gibi ikincil bir SMTP aktarımı başlatır. Aslında herhangi bir posta göndermez; bir <command>RCPT TO:</command> komutunun uzak konak tarafından kabul edilip edilmeyeceğine baktıktan sonra bir <command>QUIT</command> komutu gönderir.
        </para><para>
Exim böyle bir varlık sınamasında öntanımlı olarak boş zarf göndericisi adresi kullanır. Bunun amacı, göndericiye döndürülecek olası bir <xref linkend="spam-filtering-dsn"/>nin kabul edilip edilmeyeceğini saptamaktır.
        </para><para>
Postfix ise, adresi doğrulamak amacıyla öntanımlı kullanıcı adresi olarak &lt;<option>postmaster@</option><parameter>alanadı</parameter>&gt; adresini kullanır (<parameter>alanadı</parameter> parçası <option>$myorigin</option> değişkeninden alınır). Boş zarf göndericisi adresine yaptığınız gibi bu gönderici adresine aynı uygulamayı yapabilirsiniz (örneğin, <xref linkend="spam-filtering-smtpdelays"/> veya <xref linkend="spam-filtering-greylisting"/>'tan kaçınmak için, ama alıcı adreslerde <xref linkend="spam-filtering-signedsender"/> gerekir). Daha fazlası için eklerdeki gerçeklenimlere bakınız.
        </para><para>
Bu sınamanın tek başına gelen postayı reddetmek bakımından elverişli olmadığını görebilirsiniz. Ara sıra, örneğin, bankanızın yaptığınız bir ödemenin dekontunu göndermesi gibi durumlarda, meşru posta özdevinimli hale getirilmiş bir mekanizma tarafından geçersiz bir dönüş adresi ile gönderilir. Ayrıca, spamın talihsiz yan etkilerinden biri olarak bazı kullanıcılar, giden postalarına dönüş adresi olarak adreslerini biraz bozarak yazarlar (bu daha çok <xref linkend="spam-filtering-envfrom"/>ni değil de, iletinin <quote>From:</quote> başlığını etkileyebilir).
        </para><para>
Dolayısıyla, bu sınama sadece bir adresin geçersizliğini sınamaya yarar, iletinin gerçek göndericisini değil (bir de <xref linkend="spam-filtering-signedsender"/> bölümüne bakınız).
        </para><para>
Son olarak, <quote>aol.com</quote> gibi bazı sitelerin raporları vardır. Bunlar gönderici varlık sınaması yaptıklarını keşfettikleri her sistemi koşulsuz karalisteye alacaklarını belirtirler. Bu siteler belki de sıkça <xref linkend="spam-filtering-joejob"/> spamın mağduru olmuşlar ve sonuç olarak, gönderici varlık sınaması fırtınalarına maruz kalmış olabilirler. Siz de bu dağıtık servis reddi (DDoS - Distributed Denial-of-Service) saldırılarının bir parçası haline gelerek kendinizi spamcıların elindeki bir piyona dönüşebilirsiniz.
        </para></listitem></varlistentry>
      </variablelist></para>
    </sect3> <!-- Sender Address Checks -->

    <sect3 id="spam-filtering-rcptchecks">
      <title>Alıcı adresinin sınanması</title><para>
Düşündüğünüz gibi bu basit olmalıdır. Bir alıcı adresi ya mevcuttur ya da değildir. Mevcutsa posta teslim alınır, yoksa posta aktarımcı tarafından öntanımlı olarak reddedilir.
      </para><para>
Bir bakalım, öyle mi acaba?
      </para><para><variablelist><varlistentry>
      <term id="spam-filtering-relayprevent">Açık Röleye meydan vermemek</term>
      <listitem><para>
<emphasis>Postaları uzak konaklardan uzak adreslere röleleyemezsiniz!</emphasis> (Gönderici kimliğini kanıtlamadıkça).
        </para><para>
Bu çoğumuzun farkında olduğu ama belli ki yeterince önem verilmeyen bir konu. Ayrıca, eposta adresleri ve bunların teslim yolları ile ilgili çeşitli internet standartları ("ünlemli teslimat yolları", "yüzde işaretli alan adları" (<ulink url="http://www.livinginternet.com/e/ew_addr.htm">bang paths, percent hack domains</ulink>) gibi)  herkesin elinin altında olmayabilir.
        </para><para>
Posta aktarımcınızın bir <xref linkend="spam-filtering-openrelay"/> gibi davranıp davranmadığını bilmiyorsanız, bunu  <quote>relay-test.mail-abuse.org</quote> üzerinden sınayabilirsiniz. Bunun için kabukta şu komutu vermeniz yeterli olacaktır:
        </para><para>
<screen>telnet relay-test.mail-abuse.org</screen>
        </para><para>
Bu, SMTP sunucunuzun uzak posta adreslerine postayı röleleyip rölelemediğini ve/veya bazı adres türlerini kabul edip etmediğini çeşitli denemeler yaparak sınayan bir servistir.
        </para><para>
Sunucularınızın birer açık röle gibi davranmasını önlemek fazlasıyla önemlidir. Eğer sunucunuz bir açık röle ise ve spamcılar sizi bulmuşsa, bellibaşlı DNS karalistelerine kalıcı olarak kaydedilirsiniz. Spamcılardan önce bazı DNS karalistelerince farkedilirseniz (rasgele ve/veya şikayet üzerine yoklanarak), uzunca bir süre kalmak üzere bu DNS karalistelerine kaydedilirsiniz.
        </para></listitem></varlistentry><varlistentry>
      <term id="spam-filtering-rcptvalid">Alıcı adresine bakılması</term>
      <listitem><para>
Bu da çoğumuza bayağı görünebilir. Ama öyle değil.
        </para><para>
Eğer kullanıcılarınızın posta hesapları ve posta kutuları posta alıcınızın çalıştığı makinede saklanıyorsa, alıcı adresinin yerel kısmının bu posta kutularının isimlerinden biri ile aynı olup olmadığna bakmak kolay olur. Burada bir sorun çıkmaz.
        </para><para>
Alıcı adresinin doğrulanmasını güçleştiren iki durum vardır:
        </para><para>
        <itemizedlist>
          <listitem>
Makineniz alıcı alan adı için yedek posta alıcısı olabilir.
          </listitem><listitem>
Makineniz aldığı postayı alanınınızdaki (muhtemelen dahili ağınızdaki) diğer makinelere dağıtıyordur.
          </listitem>
        </itemizedlist>
        </para><para>
Bu durumlarda posta alıcısı konak, alıcı adresini doğrulamaksızın, alıcı adreslerin tümünü herbiri kendi alanları içinde kalmak üzere kabul edebilir. Hedef sunucu alıcı adresin geçersiz olması durumunda bir <xref linkend="spam-filtering-dsn"/> üretir. Eninde sonunda, bu işlem dolaylı spam üretimine sebep olur.
        </para><para>
Niyetimizi aklımızdan çıkarmadan, bu iki durumda alıcıyı nasıl doğrulayabileceğimize bakalım.
        </para><para><variablelist><varlistentry>
      <term id="spam-filtering-callforward">Alıcı Varlık Sınaması</term>
      <listitem><para>(Recipient Callout Verification)</para><para>
Bir uzak alıcı adresin yerel kısmını doğrulamak için kullanılan bu mekanizma Exim ve Postfix gibi bazı posta aktarımcılarında mevcuttur bunun nasıl çalıştığı <xref linkend="spam-filtering-callback"/> bölümünde açıklanmıştır. Postfix terminolojisinde bu mekanizmaya <quote>Alıcı Adresi Doğrulaması</quote> (Recipient Address Verification) adı verilir.
          </para><para>
Bu durumda, sunucu karşı taraftan <command>RCPT TO:</command> komutuyla aldığı her alıcı adresini doğrulatmak için hedef sunucuya bağlanmaya çalışır.
          </para><para>
Bu çözüm basit ve şıktır. Herhangi bir rehber hizmetine erişmeksizin hedef konakta çalışabilecek herhangi bir posta aktarımcısı ile bu gerçekleştirilebilir. Bununla birlikte, eğer bu posta aktarımcısı alıcı adreslerde bir bulanık eşleşme uyguluyorsa (Lotus Domino sunucuların yaptığı gibi), bu sınama alıcı adresin neticede kabul edilip edilmeyeceğini tam olarak yansıtır ama aşağıda açıklanan mekanizmalar açısından birşeyler yanlış gidebilir.
          </para><para>
Özgün <xref linkend="spam-filtering-envfrom"/>nin alıcı varlık sınamaları için değişmeden kalmasına, aksi takdirde, hedef sunucudan dönen yanıtın doğruyu yansıtmayabileceğine dikkat edin.  Örneğin, hedef sunucu <xref linkend="spam-filtering-dsnrealuser"/> bölümünde açıklandığı gibi sistem kullanıcıları ve takma adları için gönderilen göndericisiz (örn, zarf göndericisi olmayan) postaları reddebilir.
          </para><para>
Bellibaşlı posta aktarımcılarından Exim ve Postfix bu mekanizmayı destekler.
          </para></listitem></varlistentry><varlistentry>
      <term id="spam-filtering-ldap">Adres Rehberi Hizmetleri</term>
      <listitem><para>
Posta aktarımcınızın sorgulayabileceği bir rehber hizmetinin olması (örn, bir veya daha fazla LDAP sunucusu) diğer bir iyi çözüm olurdu. Çoğu posta aktarımcısı kullanıcı hesap bilgilerini sağlayan LDAP, NIS gibi artalan uygulamalarını kullanabilmektedir.
          </para><para>
Asıl can alıcı nokta, epostanın hedef konağının kullanıcı isimleri ile posta kutularını eşleştirmek için böyle bir rehber hizmetini kullanmaması halinde bazı karışıklıkların ortaya çıkabileceğidir (Hem posta alıcısı hem de hedef konak sınamayı aynı kaynaktan yapmalı).
          </para></listitem></varlistentry><varlistentry>
      <term id="spam-filtering-replicdir">Posta Kutusu Listeleri</term>
      <listitem><para>
Eğer yukarıdaki seçeneklerin hiçbiri uygulanabilir değilse, son çare olarak <quote>yoksul işi bir rehber hizmeti</quote> kullanabilirsiniz. Düzenli aralıklarla posta kutularının listesini, bulundukları makinelerden posta alıcısı makinelerinize kopyalayabilir ve bu listeyi <command>RCPT TO:</command> komutlarında belirtilen alıcıları doğrulamak için kullanabilirsiniz.
          </para><para>
Eğer, posta kutularını içeren makinelerinizde bir UNIX veya Linux çalışıyorsa, böyle bir listeyi muhtemelen <link linkend="tr-man5-passwd">/etc/passwd</link> dosyasından üretecek ve <ulink url="http://www.openssh.org/">OpenSSH</ulink> paketindeki <link linkend="tr-man1-scp">scp</link> komutunu kullanarak bu listeyi posta alıcınızın bulunduğu makineye kopyalayacak bir betik yazabilirsiniz. Sonra da bir <link linkend="tr-man8-cron">cron</link> işi olarak bu betiğin belli aralıklarla çalıştırılmasını sağlayabilirsiniz.
          </para></listitem></varlistentry></variablelist>
        </para></listitem></varlistentry><varlistentry>
      <term id="spam-filtering-rcptmisses">Sözlük Saldırılarının Önlenmesi</term>
      <listitem><para>
<emphasis>Sözlük Saldırısı</emphasis> (Dictionary Attack), çok kullanılan isimleri bazan alfabetik, bazen ters alfabetik bazan da rasgele seçilmiş isimler şeklinde <command>RCPT TO:</command> komutlarıyla deneyerek alıcı adreslerinin saptanması şeklinde gelişen SMTP aktarımlarını açıklamakta kullanılan bir terimdir. Böyle bir adresin kabul edilmesi halinde, bu adres spamcının cephaneliğinde yerini alır.
        </para><para>
Bazı siteler, özellikle büyük olanları sıklıkla böyle saldırıların hedefi haline gelirler. Spamcılar açısından, çok sayıda kullanıcısı olan sitelerde bir ismin bulunabilme şansı bir kaç kullanıcısı olanlardan daha yüksektir.
        </para><para>
Sözlük saldırılarıyla mücadele etmenin tek etkin yolu, her başarısız adreste aktarım gecikmesini arttırmaktır. Örneğin, mevcut olmayan ilk alıcı adresi için bekleme süresi 20 saniye, ikincisinde 30 saniye, 3. için 40 saniye, ... gibi.
        </para></listitem></varlistentry><varlistentry>
      <term id="spam-filtering-dsnonercpt">Teslimat durum bildirimlerini tek alıcı için kabul edin</term>
      <listitem><para>
Meşru <xref linkend="spam-filtering-dsn"/> tek bir alıcı adrese - bildirimi tetikleyen özgün iletiyi yazana - gönderilmiş olmalıdır. <xref linkend="spam-filtering-envfrom"/> adresi boş olan ve birden fazla alıcıya teslimat yapmaya çalışan bağlantıları kesebilirsiniz (drop).
        </para></listitem></varlistentry>
      </variablelist></para>
    </sect3>
  </sect2>

  <sect2 chunkthis="1" id="spam-filtering-greylisting">
    <title>Grilisteleme</title><para>
<emphasis>Griliste</emphasis> kavramı Evan Harris tarafından <ulink url="http://projects.puremagic.com/greylisting/"/> adresinde açıklanmıştır.
    </para>
    <sect3 id="spam-filtering-greylisting-theory">
      <title>Nasıl Çalışır</title><para>
Grilisteleme, <xref linkend="spam-filtering-ratware"/> üzerinden teslim edilmeye çalışılan iletileri ayıklamak için <xref linkend="spam-filtering-smtpdelays"/> gibi basit ama oldukça etkili bir mekanizmadır. Ana fikir. bir iletinin göndericisi ile alıcısı arasında bir ilişkinin mevcudiyetini sağlamaktır. Çoğu meşru posta için böyle bir ilişki kurulabilir ve teslimat normal şekilde gerçekleşir.
      </para><para>
Diğer yandan, böyle bir ilişki evvelce mevcut değilse, teslimat geçici olarak reddedilir (bir <command>451</command> SMTP yanıtı ile). Meşru posta aktarımcıları böyle bir durumda biraz gecikmeyle teslimatı yinelerler<footnote id="spam-filtering-noretrysenders"><para>
Nadiren, <option>groups.yahoo.com</option> gibi bazı <quote>meşru</quote> büyük hacimli posta göndericileri geçici başarısızlığa uğramış teslimatları gerçekleştirmeye çalışmazlar. Evan Harris böyle göndericileri aklisteler için yararlı olabileceğini düşünerek liste halinde derlemiş:<sbr/><ulink url="http://cvs.puremagic.com/viewcvs/greylisting/schema/whitelist_ip.txt?view=markup"/>.</para></footnote>.
Kalleş yazılımlar ise, tersine ya teslimatı hemen yinelerler ya da basitçe vazgeçip adres listelerindeki sonraki hedefe yönelirler.
      </para><para>
Bir teslimat sırasında verilen bilgilerden üçü, bir <emphasis>üçlü</emphasis> olarak, bir gönderici ile alıcı arasındaki eşsiz ilişkiyi tanımlamak için kullanılır:
      </para><para>
      <itemizedlist><listitem>
<xref linkend="spam-filtering-envfrom"/>.
        </listitem><listitem>
Gönderen konağın IP adresi.
        </listitem><listitem>
<xref linkend="spam-filtering-envto"/>.
        </listitem></itemizedlist>
      </para><para>
Bir teslimat reddedilmişse bu üçlü belli bir süre (normalde 1 saat) grilisteli olarak saklanır ve bu sürenin sonunda aklisteye alınır. Belli bir sürenin sonunda (normalde 4 saat) bu üçlü için bir teslimat gerçekleşmemişse, bu üçlü listeden silinir.
      </para><para>
Eğer aklisteye alınmış bir üçlüye uzunca bir süre (aylık faturalama dönemli hesaplar düşünülerek, en az bir aylık bir süre) teslimat olmazsa, bu üçlü listeden silinir. Bu işlem listenin sınırsız büyümemesi için yapılır.
      </para><para>
Bu zamanaşımları Evan Harris'in grilistelemeyi açıkladığı belgesinden alınmıştır. Bazıları için, grilisteye alınmış üçlülere daha uzun zamanaşımları gerekebilir, çünkü bazı İSS'ler (<emphasis>earthlink.net</emphasis> gibi) teslimatlarını her 6 saat ya da buna yakın aralıklarla yinelerler<footnote><para>
Büyük siteler giden postalar için çoğunlukla birden fazla sunucu kullanırlar. Örneğin, anlık teslimatlar için bir sunucu veya bir sunucu havuzu kullanılırken, ilk teslimat başarısız olduğunda posta, büyük kuyrukları idare edecek şekilde yapılandırılmış son çare sunucularına devredilir. Bu nedenle, böyle sitelerden gelen ilk iki teslimat başarısız olacaktır (IP adresinin değişmesi nedeniyle).</para></footnote>.
      </para>
    </sect3>
    <sect3 id="spam-filtering-greylisting-multimx">
      <title>Çok sayıda posta alıcısı olması durumu</title><para>
Birden fazla posta alıcısı kullanıyorsanız ve her sunucu kendi grilistesini oluşturuyorsa:
      </para><para>
      <itemizedlist>
        <listitem><para>
Belli bir göndericiden kullanıcılarınızdan birine gelen ilk teslimatlar teorik olarak, <parameter>N</parameter> posta alıcısı konakların sayısını göstermek üzere <parameter>N</parameter> çarpı 1 saatlik ilk gecikme süresi  kadar geciktirilir. Bunun sebebi, farklı bir sunucuya yapılan yinelenmiş bir teslimatın bu sunucu açısından ilk teslimat olması ve <command>451</command> yanıtıyla reddedilmesidir. En kötü durumda, gönderici konak başa dönüp teslimatı ilk posta alıcısına teslim etmeye çalışması sırasında 4 saatlik süre veya grilistenin ikinci zamanaşımı süresi dolar ve bu kısır döngü gönderici postayı teslim etmekten vazgeçinceye kadar (genelde bu süre 4 gün civarındadır) sürer.
          </para><para>
Uygulamada bu böyle olmaz. Bir teslimat geçici bir başarısızlıkla reddedilirse, gönderici konak hemen diğer posta alıcısından teslimatı gerçekleştirmeye çalışır. Böylece 1 saat sonra bu posta alıcılarından biri bu teslimatı kabul eder.
        </para></listitem>
        <listitem><para>
Bir üçlü, posta alıcılarınızdan biri tarafından aklisteye alınmış olsa bile, aynı üçlü farklı bir posta alıcısında teslimat için kullanıldığında o sunucu açısından grilisteli olarak işlem görür.
        </para></listitem>
      </itemizedlist>
      </para><para>
Bu sebeplerden, posta alıcılarınız arasında paylaşılan bir grilisteleme veritabanı gerçekleştirmek iyi bir çözüm olabilir. Ancak, bu veritabanını tutan makinenin başına gelecek bir talihsizlik bütün posta alıcıları için teslimatların başarısız olmasına sebep olacaktır. Bunun yerine veritabanlarının birebir kopyalanması tekniklerinden birini kullanılabilir ve bu sunuculardan birini sorgulara yanıt verecek bir son çare SMTP sunucu yapabilirsiniz.
      </para>
    </sect3>
    <sect3 id="spam-filtering-greylisting-results">
      <title>Sonuç</title><para>
Şahsi deneyimlerime göre, evvelce açıklanan <xref linkend="spam-filtering-smtpchecks"/> uygulandıktan sonra grilistelemenin uygulanması halinde bu iki yöntem birlikte döküntü postanın %90'ından kurtulmayı sağlıyor. Eğer grilistelemeyi ilk savunma mekanizması olarak kullanırsanız, gelen döküntü postanın önemli bir kısmını tek başına yakalayacaktır.
      </para><para>
Buna karşın, bu tekniğin kullanımından sıfıra yakın <xref linkend="spam-filtering-falsepos"/> ortaya çıkar. Bellibaşlı <link linkend="spam-filtering-mta">posta aktarımcılarının</link> tümü bir geçici başarısızlıktan sonra eninde sonunda başarılı bir teslimatı gerçekleştirmek amacıyla teslimat yinelemeleri yaparlar.
      </para><para>
Grilistelemenin perde arkasında, birinin belli bir alıcıya bir saatlik gecikmeye konu olarak hemen teslim alınmamış bir meşru posta vardır (bu bir saatlik gecikme, çok sayıda posta alıcısı kullanıyorsanız bir kaç saat de olabilir).
      </para><para>
Ayrıca, <xref linkend="spam-filtering-qanda-adapt"/>'in yanıtına da bakınız.
      </para>
    </sect3>
  </sect2>

  <sect2 chunkthis="1" id="spam-filtering-senderauth">
    <title>Gönderici Yetkilendirme Şemaları</title><para>
Gönderici adresinin sınanması anlamında, sadece göndericinin varlığının değil, ayrıca kimliğinin de kanıtlanmasını sağlayacak çeşitli kullanıcı doğrulama şemaları geliştirilmiştir. İnternet alanının sahibi kendi alanındaki göndericilerden teslimata yetkili olanları belirleyen bazı kurallar belirtir.
    </para><para>
Bu şemaların ilklerinden iki örnek:
    </para><para>
    <itemizedlist>
      <listitem><para>
<option>MAIL-FROM</option> MX kayıtları, Paul Vixie <email>paul@vix.com</email> tarafından tasarlanmıştır.
      </para></listitem>
      <listitem><para>
Ters Posta Alıcısı (RMX - Reverse Mail Exchanger) kayıtları (DNS'ye ek olarak); Hadmut Danisch <email>hadmut@danisch.de</email> tarafından tasarlanmış ve yayınlanmıştır.
      </para></listitem>
    </itemizedlist>
    </para><para>
Bu iki şema altında, <literal>kullanıcı@alanadı.dom</literal> adresli tüm postalar <literal>alanadı.dom</literal>'un DNS kayıtlarında bulunan konaklardan gelmek zorundadır.
    </para><para>
Bu iki şema gelişmiş, hatta benzer çalışmalara çatallanmıştır.
    </para>
    <sect3 id="spam-filtering-spf">
      <title>Gönderici Yetkilendirme Dizgesi (SPF)</title><para>
SPF (<quote>Sender Policy Framework</quote> veya <quote>Sender Permitted From</quote> kısaltması), gönderici yetkilendirme için en iyi bilinen şemalardan biridir. Yukarıdaki şemalardan hareketle ortaya çıkmıştır ama kuralları belirtmek bakımından biraz daha esnek bir yapıdadır.
      </para><para>
SPF bilgisi bir alan adının üst düzey DNS kayıtları arasında bir <option>TXT</option> kaydı olarak görünür. Bu kayıt bu alanın kullanıcısının ağzından basitçe şunu der: "Ben postamı sadece bu makinelerden gönderiyorum. Eğer başka bir makine benim postamı oradan gönderdiğini iddia ediyorsa, o bir yalancıdır." Bu kayıtta şunlar belirtilmiş olabilir:
      </para><para>
      <itemizedlist>
        <listitem>
bu alandan posta göndermesine izin verilen makineler
        </listitem><listitem>
bu alandan giden postada zorunlu bir GPG imzasının varlığı
        </listitem><listitem>
diğer kurallar; ayrıntılar için <ulink url="http://www.openspf.org/" /> adresine bakınız.
        </listitem></itemizedlist>
      </para><para>
Bu <command>TXT</command> kaydının geliştirilmesi hala sürmektedir, yine de temel özellikler yukarıda bahsedildiği gibidir. Bir <option>v=spf1</option> dizgesi ile başlar ve şu belirteçlerden bazıları ya da hepsi kullanılabilir:
      </para><para>
      <itemizedlist>
        <listitem><para>
<option>a</option> - geçerli gönderici makine bu alanın kendi IP adresidir.
        </para></listitem>
        <listitem><para>
<option>mx</option> - bu alanın posta alıcıları, ayrıca geçerli göndericilerdir.
        </para></listitem>
        <listitem><para>
<option>ptr</option> - eğer gönderenin IP adresi için ters DNS kaydındaki isim, gönderici adresin alan adı kısmındaki isimle eşleşiyorsa, gönderen konak geçerli göndericidir.
        </para></listitem>
      </itemizedlist>
      </para><para>
Bu belirteçlerin herbirinin önüne bir yetkili kaynak olduğunu belirtmek için bir artı işareti (bu öntanımlıdır), yetkisiz olduğunu belirtmek için bir eksi işareti, yetki bakımından nötr olduğunu belirtmek için soru işareti veya yetkisiz olarak değerlendirilebilineceğini belirtmek üzere bir yaklaşık işareti (~) konabilir.
      </para><para>
Her belirteç bir ikinokta üstüste işaretinden sonra bir alan adı belirtmek üzere kullanılabilir. Örneğin, bir Comcast müşterisiyseniz, sizin DNS kayıtlarınız arasında <quote><option>v=spf1 -ptr:client.comcast.net ptr:comcast.net -all</option></quote> şeklinde bir <command>TXT</command> kaydı olabilir. Bu kayıt, bu alandan posta gönderen makinenin IP adresi çözümlendiğinde elde edilen isim <parameter>birşey</parameter>.client.comcast.net şeklindeyse bu adres yetkisizdir, <parameter>birşey</parameter>.comcast.net şeklindeyse yetkilidir, belirtilenler dışında kalanlar da yetkisizdir ("-all") anlamına gelir.
      </para><para>
Her alan adı için bir SPF kaydı bulunmalıdır. Bazı büyük siteler artık bu kaydın bulunmadığı alanlardan posta kabul etmemektedir.
      </para><para>
Gönderici yetkilendirme şemaları genelde kabul görmemiş olmasına rağmen SPF evrensel olarak büyük oranda kabul görmüştür. SPF'ye karşı çıkanlar, alan adı sahiplerinin posta gönderen müşterileri/kullanıcıları üzerinde bir tekel kurmak için bunu kullanabileceklerini ileri sürmektedirle<footnote><para>Ç.N.: Alan adı sahibi olmak hiçte zor olmadığından bu iddia sönük kalmakta, ayrıca İSS gibi kurumların müşterilerinin dinamik adreslerden gönderdikleri postaların genel bir kabul olarak spam olarak değerlendirildiği de gözönüne alındığında bu iddia iyice mesnetsiz kalmaktadır.</para></footnote>.
      </para><para>
Diğer bir idda, SPF'nin geleneksel eposta yönlendirmesini bozduğu şeklindedir; yönlendiren konak, zarf göndericisinin alan adındaki SPF kaydında yetkisiz olabilir. Bu sorun, <ulink url="http://www.openspf.org/srs.html">Göndericiyi Yeniden Yazma Şeması</ulink> (SRS - Sender Rewriting Scheme) ile kısmen halledilebilir. SRS'de postanın yönlendiricisi <xref linkend="spam-filtering-envfrom"/> adresinin biçimini değiştirir:
      </para><para>
<screen>
<emphasis>kullanıcı</emphasis>=<emphasis>kaynak.alanadı</emphasis>@<emphasis>yönlendirici.alanadı</emphasis>
</screen>
      </para>
    </sect3> <!-- SPF -->
    <sect3 id="spam-filtering-ms-cide">
      <title>Epostalar için Microsoft Çağrı Kimliği</title><para>
Kurallarının gönderici alan adının DNS bilgileri arasında bir TXT kaydı olarak görünmesi bakımından SPF'ye benzer. Ancak, basit anahtar sözcükler yerine, XML olarak kodlanmış oldukça geniş kapsamlı MS CIDE bilgilerinden oluşur. Bu XML şeması Microsoft tarafından bir lisans altında yayınlanmıştır.
      </para><para>
SPF, bir postanın sadece <xref linkend="spam-filtering-envfrom"/> adresine bakarak çalışırken, MS CIDE iletinin <link linkend="rfc2822">RFC 2822</link> başlıklarını değerlendiren bir araç olarak karşımıza çıkar. Böyle bir sınamanın SMTP aktarımında yapılabileceği en erken nokta, ileti verisi alındıktan sonra ve son <command>250</command> yanıtını göndermeden öncedir.
      </para><para>
Dobra dobra ölü doğmuş denebilir. Patentiyle ve karmaşıklığıyla bir engelli olarak doğmuş da denebilir.
      </para><para>
<ulink url="http://www.openspf.org/"/>'da SPF'ye ek olarak MS Çağrı kimliğini de (MS CIDE) sınayacak araçlar bulabilirsiniz.
      </para>
    </sect3> <!-- Microsoft Caller-ID for E-mail -->
    <sect3 id="spam-filtering-rmxplus">
      <title>RMX++</title><para>
Basit Çağrıcı Yetkilendirme Yapısının (SCAF - Simple Caller Authorization Framework) bir parçası. Bu şema, zaten özgün RMX'in tasarımcısı olan Hadmut Danisch tarafından geliştirilmiştir.
      </para><para>
RMX++, HTTP sunucular üzerinden özdevimli yetkilendirmeyi mümkün kılar. Alanadı sahibi DNS üzerinden bir sunucu belirtir ve posta alıcısı konak bu sunucuya bağlanarak göndericinin geçerliliğini saptamak için oradan bir yetkilendirme kaydı elde etmeye çalışır.
      </para><para>
Bu şema alanadı sahibine gönderici adreslerini yetkilendirmede kullanılacak kuralları daha ayrıntılı belirleme imkanı verir (SPF kayıtlarıyla, ağının yapısını kamuya açık alanlarda ilan etmeksizin). Hadmut'tan bir örnek: Hergün iş saatleri dışında belli bir adresten beş iletiden fazlasına izin vermeyen bir yetkilendirme sunucusu bu sınır aşıldığında bir uyarı verecektir.
      </para><para>
Keza, SCAF epostalarla sınırlı değildir, ayrıca IP üzerinden sesli iletişim (VoIP) gibi hizmetler için çağrıcı yetkilendirmesi için kullanılabilir.
      </para><para>
Rick Stewart <email>rick.stewart@theinternetco.net</email> RMX++'nın makine ve ağ kaynaklarına etkisine dikkat çekerek RMX++'in perde arkasında kalan bir olasılıktan sözetmiştir: HTTP sunucularının yanıtları DNS sunucularının ki gibi geniş çapta önbelleklenmediğinden bir HTTP isteği yapmak bir DNS isteğinden kat kat pahalıya malolacaktır.
      </para><para>
Rick devam ediyor, RMX++'nın özdevimli doğası bir başarısızlığın nedenlerinin bulunmasını da zorlaştıracaktır. Eğer günlük beş iletilik bir sınır varsa, bu sınır, tek bir iletinin beş kere sınanması ile dolacaktır. Yani şema, bir iletinin defalarca sınanmasına imkan vermiyor.
      </para><para>
RMX, RMX++ ve SCAF hakkında daha fazla bilgi edinmek için<sbr/><ulink url="http://www.danisch.de/work/security/antispam.html"/> adresine bakınız.
      </para>
    </sect3> <!-- RMX+ -->
  </sect2> <!-- Sender Address Verification Schemes -->


  <sect2 chunkthis="1" id="spam-filtering-datachecks">
    <title>İleti verisinin sınanması</title><para>
İletinin içeriğine bakmanın zamanı geldi. Bu, ileti tamamen kabul edildikten sonra spam ve virüs tarayıcılarının yaptıklarına benzer bir işlemdir.  Ancak, bizim durumumuzda bu sınamaları, posta kabul edilmeden yani, sonuncu <command>250</command> yanıtından önce yapacağız. Böylece, daha sonra reddederek <xref linkend="spam-filtering-colspam"/> üretmeksizin postayı daha SMTP aktarımı bitmeden reddetme şansımız olacak.
    </para><para>
Eğer posta alıcılarınız çok meşgulse (büyük bir site ve bir kaç tane MX), bu makinelerde bu sınamaların bir kaçını bile uygulamak oldukça pahalıya malolabilir. Özellikle, <xref linkend="spam-filtering-virusscanners"/> ve <xref linkend="spam-filtering-spamscanners"/>'nın çalıştırlması büyük miktarda işlemci zamanı harcanmasına sebep olur.
    </para><para>
Böyle bir durumda, bu tarama işlemlerine adanmış bir makine ayarlamak iyi bir çözüm olabilir. Sunucu tarafında çalışabilen çoğu anti-spam ve anti-virus yazılım ağ üzerinden çalıştırılabilmektedir.
    </para>
    <sect3 id="spam-filtering-headerchecks">
      <title>İleti başlıklarının sınanması</title><para>
      <variablelist><varlistentry>
      <term id="spam-filtering-headersmissing">Eksik başlık satırları</term>
      <listitem><para>
<link linkend="rfc2822">RFC 2822</link> bir iletinin en azından şu başlıkları içermesini <emphasis>zorunlu</emphasis> kılar:
        </para><para>
<screen>
From: ...
To: ...
Subject: ...
Message-ID: ...
Date: ...
</screen>
        </para><para>
Bu satırlardan herhangi birinin yokluğu iletinin bir <xref linkend="spam-filtering-mua"/> tarafından üretilmediğini ve büyük olasılıkla bir döküntü posta olduğunu gösterir<footnote><para>
Posta listelerinin sunucuları gibi bazı özel amaçlı posta aktarımcıları "boş adresli" (bkz. <xref linkend="spam-filtering-dsn"/>) iletiler için kendiliklerinden bir <option>Message-ID:</option> başlığını üretmezler. Bu tür iletiler boş bir <xref linkend="spam-filtering-envfrom"/>nin varlığıyla kendilerini belli ederler.</para></footnote>.
        </para></listitem></varlistentry><varlistentry>
      <term id="spam-filtering-headersyntax">Başlık Adresinin Sözdizimi Sınaması</term>
      <listitem><para>
İleti başlığındaki adresler (<command>To:</command>, <command>Cc:</command>, <command>From:</command> ... başlıkları), sözdizimsel olarak geçerli olmak zorundadır. Daha fazla birşey söylemeye gerek yok.
        </para></listitem></varlistentry><varlistentry>
      <term id="spam-filtering-headeraddress">Basit Başlık Adresi Doğrulaması</term>
      <listitem><para>
İleti başlığındaki her adres için:
        </para><para>
        <itemizedlist><listitem>
Eğer adres yerelse,  <emphasis>yerel kısım</emphasis> (@ işaretinden önceki parça) geçerli bir posta kutusu ismi mi?
          </listitem><listitem>
Eğer adres uzaksa, <emphasis>alanadı parçası</emphasis>  (@ işaretinden sonraki parça) mevcut mu?
        </listitem></itemizedlist>
      </para></listitem></varlistentry><varlistentry>
      <term id="spam-filtering-headercallout">Başlık Adresi Varlık Doğrulaması</term>
      <listitem><para>
Bu, <xref linkend="spam-filtering-callback"/> ve <xref linkend="spam-filtering-callforward"/>'na benzer şekilde çalışır. Bir <xref linkend="spam-filtering-dsn"/>'nın kabul edilip edilmeyeceğini saptamak için her gönderici adresin birincil posta alıcısına erişilerek adres doğrulatılmaya çalışılır.
      </para></listitem></varlistentry></variablelist></para>
    </sect3>
    <sect3 id="spam-filtering-jmsr">
      <title>Döküntü Posta İmza Depoları</title><para>
Döküntü postayı diğerlerinden ayıran bir özellik, çok sayıda adrese gönderilmiş olmasıdır. Eğer 50 alıcı belli bir iletiyi spam olarak nitelemişse, posta size teslim edilirken, iletiyi kabul edip etmemek noktasında neden bu fiili durumu kullanmayasınız? Daha da iyisi, spamcıları bilen kamuya açık bir havuzu beslemek için neden bir <xref linkend="spam-filtering-spamtrap"/> ayarlamayasınız?
      </para><para>
Böyle havuzlar var:
      </para><para>
      <itemizedlist>
        <listitem><ulink url="http://razor.sf.net/">Razor</ulink></listitem>
        <listitem><ulink url="http://pyzor.sf.net/">Pyzor</ulink></listitem>
        <listitem><ulink url="http://rhyolite.com/anti-spam/dcc/">Distributed Checksum Clearinghouse (DCC)</ulink></listitem>
      </itemizedlist>
      </para><para>
Bu araçlar sadece, döküntü posta olarak bilinen bir iletinin bir eşdeğer kopyasını aldığınızda tetiklenen basit imza sınamaları yaparak çalışırlar. Bunlar ileti içinde bilinen kalıpları arayarak değil, ileti başlığındaki ve gövdesindeki belli değişiklikleri hesaba katarak değerlendirme yaparlar.
      </para>
    </sect3>

    <sect3 id="spam-filtering-garbagechars">
      <title>Baskı karakteri olmayan karakterlerin varlığı</title><para>
Baskı karakteri olmayan karakterleri içeren iletilere nadir de olsa rastlanır. Böyle bir ileti, hemen hemen daima bir virüs ya da uygun bir MIME kodlaması olmaksızın batı dillerinde yazılmamış bir spam türü olarak karşımıza çıkar.
      </para><para>
Özel bir durum, iletinin boş karakter (sıfırıncı karakter - `\0') içermesi durumudur. Baskı karakteri olmayan karakterlerin karmaşıklığı karşısında bunun yararından çok zararı olacağını düşünseniz bile en azından bu karakteri sınamayı düşünebilirsiniz. Çünkü, <ulink url="http://asg.web.cmu.edu/cyrus/">Cyrus Posta Araçları</ulink> gibi bazı <link linkend="spam-filtering-mda">posta teslimatçıları</link> bu karakteri içeren postaları eninde sonunda reddedecektir<footnote><para>
IMAP protokolü posta istemcilerine boş karakterlerin aktarılmasına izin vermez. Bu bakımdan, Cyrus geliştiricileri bu karakteri içeren postalardan kurtulmanın en kolay yolu olarak onları reddetme kararı aldılar.</para></footnote>.
Eğer böyle bir yazılım kullanıyorsanız, boş karakterlerden kurtulmayı kesinlikle hesaba katmalısınız.
      </para><para>
Diğer taraftan, RFC 822 belirtimi (artık atıl) iletilerde boş karakteri açıkça yasaklamamıştır. Bu sebeple, bu tür postaları reddetmek yerine, iletiden bu karakterleri ayıkladıktan sonra postayı Cyrus'a teslim etmek daha iyi bir yol olabilir.
      </para>
    </sect3>
    <sect3 id="spam-filtering-mimeerrors">
      <title>MIME sınamaları</title><para>
Benzer şekilde, gelen iletinin MIME yapısı değerlendirmeye alınırsa bu işlem çekilen zahmete değebilir. MIME çözümleme hataları veya tutarsızlıkları çok sık ortaya çıkmaz; fakat bu olursa, ileti kesinlikle döküntüdür. Üstelik böyle hatalar bundan sonraki <xref linkend="spam-filtering-fileext"/>, <xref linkend="spam-filtering-virusscanners"/>, <xref linkend="spam-filtering-spamscanners"/> gibi sınamalar açısından ortaya çıkabilecek sorunların habercisi olabilir.
      </para><para>
Başka bir deyişle, eğer MIME kodlaması kuraldışıysa iletiyi reddedin.
      </para>
    </sect3>


    <sect3 id="spam-filtering-fileext">
      <title>Eklenti Sınamaları</title><para>
Son zamanlarda istemediğiniz halde birileri size bir Windows ekran koruyucusu (<quote>.scr</quote>) veya bir Windows Program bilgi dosyası (<quote>.pif</quote>) gönderdi mi?
      </para><para>
Ekinde <quote>Windows çalıştırılabilirleri</quote> - yukarıdaki gibi üç harfli uzantıları olan dosyalar - olan iletileri önlemeyi gözönünde bulundurun. Bu sınama <xref linkend="spam-filtering-virusscanners"/>nın tükettiğinden daha az sistem kaynağı tüketeceği gibi ayrıca, anti-virus tarayıcınızda henüz imzası bulunmayan yeni virüsleri de yakalamanızı sağlayacaktır.
      </para><para>
Bu tür dosya uzantılarının az çok kapsamlı bir listesini<sbr/><ulink url="http://support.microsoft.com/default.aspx?scid=kb;EN-US;290497"/> adresinde bulabilirsiniz.
      </para>
    </sect3>
    <sect3 id="spam-filtering-virusscanners">
      <title>Virüs Tarayıcıları</title><para>
Sunucu tarafında çalışan bir miktar virüs tarayıcı mevcuttur. Bazıları:
      </para><para>
      <itemizedlist>
<listitem><ulink url="http://www.vanja.com/tools/sophie/">Sophie</ulink></listitem>
<listitem><ulink url="http://www.kapersky.com/">KAVDaemon</ulink></listitem>
<listitem><ulink url="http://clamav.elektrapro.com/">ClamAV</ulink></listitem>
<listitem><ulink url="http://www.sald.com/">DrWeb</ulink></listitem>
      </itemizedlist>
      </para><para>
Tehlike arzetmesi olası dosyaları (<quote>.zip</quote> dosyaları gibi) sadece isimlerine bakarak engellemek istemiyorsanız böyle tarayıcılar işe yarar. Ayrıca bunlar bir posta eki olmayan  <quote>Bagle.R</quote> virüsü (2004 Mart'ında ortaya çıkmıştı) gibi virüsleri de yakalayabilir.
      </para><para>
Çoğu durumda, virüs taraması yapan makinenin sizin posta alıcınız olması gerekmez. Bu virüs tarayıcıların çoğu bir ağ bağlantısı üzerinden başka bir konakta çalıştırılabilir.
      </para><para>
Antivirüs yazılımları genellikle bilinen virüsleri imzalarından ya da <emphasis>virüs tanımlarından</emphasis> saptar. Yeni virüsler geliştirildiğinden bunların düzenli aralıklarla güncellenmeleri gerekir. Ayrıca, olası en yüksek doğruluğun sağlanması için yazılımın kendisinin de güncel olması gerekir.
      </para>
    </sect3>
    <sect3 id="spam-filtering-spamscanners">
      <title>Spam Tarayıcıları</title><para>
Benzer şekilde, anti-spam yazılımlar iletileri standartlara uyumluluk açısından değerlendirerek, <xref linkend="spam-filtering-dnsbl"/> ve <xref linkend="spam-filtering-jmsr"/> gibi sınamalar yaparak ve içeriklerini büyükçe bir ampirik kümeye göre değerlendirerek sınıflandırmakta kullanılabilir. Sonuçta, bu tür yazılımlar iletinin ne derece spam olabileceğini belirten bir puan verirler. Eğer bu puan belli bir eşik değeri aşmışsa iletinin spam olabileceğine karar verilebilir.
      </para><para>
Sunucu tarafında çalışan ampirik antispam filtrelerinden çok tanınmış ikisi:
      </para><para>
        <itemizedlist>
        <listitem id="spam-filtering-spamassassin">
<ulink url="http://www.spamassassin.org/">SpamAssassin</ulink>
        </listitem><listitem id="spam-filtering-brightmail">
<ulink url="http://www.brightmail.com/">BrightMail</ulink>
        </listitem></itemizedlist>
      </para><para>
Spamcılar bu araçların kullandıkları çeşitli sınamaları alt edecek yöntemler (örn, <quote>GR0W lO 1NCH35</quote> gibi oldukça yaratıcı dizgeler) buldukça bu araçlar da sürekli geliştirilmektedir. Antivirüs yazılımlarında olduğu gibi bu yazılımlar da olası en yüksek doğruluğu sağlamak için sıkça güncellenmelidir.
      </para><para>
Ben SpamAssassin kullanıyorum, makine özkaynaklarına olan etkisini en aza indirmek için onu savunma hattımın önüne yerleştirmedim. Benim kişisel adresime günde 500 civarında döküntü posta teslim edilmeye çalışılıyor. Bunlardan yaklaşık 50 tanesi SpamAssassin tarafından sınanacağı noktaya ulaşabiliyorlar. Bu 50 iletinin dışında posta kutuma her iki ya da üç günde bir, tek bir ileti düşüyor.
      </para>
    </sect3>
  </sect2>

  <sect2 chunkthis="1" id="spam-filtering-collateral">
    <title>Dolaylı Spamın Engellenmesi</title>
    <para>
<xref linkend="spam-filtering-colspam"/>ın şimdiye kadar açıklanan tekniklerle engellenmesi zordur, çünkü bunlar normalde standart posta aktarımcılarını (Sendmail, Postfix veya Exim gibi) kullanan meşru sitelerden gelirler. Asıl sorun, kendi kullanıcılarınızın gönderdikleri postalara yanıt olarak gelen geçerli <link linkend="spam-filtering-dsn">teslimat durum bildirimleri</link>nden bu iletileri ayırmaktır. Bu ayrımı yapanların kullandıkları yöntemlerden bazıları:
    </para>

    <sect3 id="spam-filtering-bogusviruswarning">
      <title>Hatalı Virüs Uyarıları Filtresi</title><para>
Çoğu zaman, dolaylı spam antivirüs tarayıcılarının ürettiği virüs uyarıları şeklinde karşımıza çıkar<footnote><para>
Virüs tarama yazılımı üreticilerinin virüs içeren epostalardaki gönderici adreslerine neden güvendiklerini açıklamak ancak psikoanalitik bir çalışmanın konusu olabilir.
</para></footnote>.
Bu virüs uyarılarının <option>Subject:</option> satırı dahil birçok karakteristik özelliği antivirüs yazılımının kendisi tarafından oluşturulur. Dolayısıyla, ortak karakteristik özelliklerin bir listesini yapıp böyle hatalı virüs uyarılarını filtreleyebilirsiniz.
      </para><para>
Ne yazık ki, şansınız yok -- birileri bunu zaten sizin için yapmış. <literal>:-)</literal>
      </para><para>
Tim Jackson <email>tim@timj.co.uk</email>, <link linkend="spam-filtering-spamassassin">SpamAssassin</link> ile kullanmak için bir hatalı virüs uyarı listesi yapmış bile. Bu listeyi <ulink url="http://www.timj.co.uk/linux/bogus-virus-warnings.cf"/> adresinden edinebilirsiniz.
      </para>
    </sect3>

    <sect3 id="spam-filtering-addspf">
      <title>Alanınız için SPF kaydı oluşturun</title><para>
<xref linkend="spam-filtering-spf"/>'nin amacı özellikle <xref linkend="spam-filtering-joejob"/>nden korunmaktır. Yani geçerli bir eposta adresinin taklit edilmesini önlemektir.
      </para><para>
Eğer alanadınızın DNS bilgileri arasında bir SPF kaydı varsa, SPF sınamaları yapan alıcı konaklar, taklit edilmiş adreslerle gönderilmiş postaları kabul etmeyecektir. Böyle bir durumda da, size bir <xref linkend="spam-filtering-dsn"/> gönderilmeyecektir.
      </para>
    </sect3>
    <sect3 id="spam-filtering-signedsender">
      <title>Zarf Gönderici İmleri</title><para>
Benim kendim için de denemekte olduğum bir başka farklı yaklaşım, giden postanın <xref linkend="spam-filtering-envfrom"/> adresinin yerel kısmına bir dizgecik eklemek ve <link linkend="spam-filtering-dsn">teslimat durum bildirimleri</link>ni kabul etmeden önce <xref linkend="spam-filtering-envto"/> adresinde bu dizgeciğin varlığına bakmaktır. Örnek olarak, böyle bir gönderici adresinin biçimi şöyle olabilir:
      </para><para>
<literallayout>
    <emphasis>yerelkısım</emphasis>=<emphasis>dizgecik</emphasis>@<emphasis>alanadı</emphasis>
</literallayout>
      </para><para>
Normal ileti yanıtları bundan etkilenmez. Çünkü bu yanıtlar, bu işlem sırasında içeriğine dokunulmayan <option>From:</option> veya <option>Reply-To:</option> başlıklarındaki adreslerle yapılır.
      </para><para>
Söylemesi kolay, değil mi? Maalesef, bu amaca uygun bir imleme biraz karmaşık bir işlem. Hesaba katılması gereken bir takım olumsuz durumlar mevcut:
      </para><para>
      <itemizedlist>
        <listitem><para>
Bu yöntemin yararlı olabilmesi için, imli gönderici adresini spamcıların kullanamaması lazım. İm olarak bir zaman damgası kullanıp bir süre sonra kullanışsız hale gelecek bir adres oluşturulabilir:
        </para><para>
<literallayout>
    <emphasis>gönderen</emphasis>=<emphasis>zamandamgası</emphasis>=<emphasis>dizgecik</emphasis>@<emphasis>alanadı</emphasis>
</literallayout>
        </para></listitem>
        <listitem><para>
Postanızın <xref linkend="spam-filtering-greylisting"/> yapan bir siteye de gidebileceğini gözönüne alırsak, zarf gönderici adresinizin belli bir alıcı için değişmez olması gerekir, aksi halde sürekli grilistede kalırsınız.
          </para><para>
Bu durumda, <xref linkend="spam-filtering-envto"/>na uygun bir <xref linkend="spam-filtering-envfrom"/> üretebilirsiniz:
          </para><para>
<literallayout>
    <emphasis>gönderen</emphasis>=<emphasis>alıcı</emphasis>=<emphasis>alıcının.alanadı</emphasis>=<emphasis>dizgecik</emphasis>@<emphasis>alanadı</emphasis>
</literallayout>
          </para><para>
Bu adres zamanaşımına uğramayacağından, bu adresle ilgili döküntü postalar görmeye başlarsanız, en azından kaçağın kaynağını öğrenmiş olursunuz. Bununla birlikte, aynı alıcıdan size gelen normal teslimatları etkilemeksizin, imli adresinize bu alıcıdan gelen postaları kolayca reddebilirsiniz.
        </para></listitem>
        <listitem><para>
Posta listelerinin sunucuları ile ilgili iki durum vardır. Genellikle, sunuculara yapılan isteklerde  (<quote>subscribe</quote>/<quote>unsubscribe</quote> gibi), yanıtlar zarf gönderici adresi boş bırakılarak gönderilir.
          </para><para>
          <itemizedlist>
            <listitem><para>
İlk durum, sunucunun istek postasının <xref linkend="spam-filtering-envfrom"/> adresine gönderdiği yanıt ile ilgilidir. Posta listesi sunucusu ile ilgili sorun, komutların (<command>subscribe</command> veya <command>unsubscribe</command> gibi) genellikle farklı adreslere (<email>discuss@en.tldp.org</email> listesi için <email>discuss-subscribe@en.tldp.org</email> ve <email>discuss-unsubscribe@en.tldp.org</email> gibi) gönderilmesidir. Böyle bir durumda, üyelik adresi ile listeye gönderilecek iletinin gönderici adresi farklı olacaktır -- ve bu örnekte, ayrıca, üyelikten çıkma isteğinde kullanılan adresten de farklı olacaktır. Sonuçta, ne listeye posta göndermek ne de üyelikten çıkmak mümkün olacaktır.
              </para><para>
Bu durumda uzlaşma ancak gönderici adresinde imleme için sadece alıcının alan adının bulunmasıyla sağlanabilir. Yani, gönderici adresi şöyle üretilebilir:
        </para><para>
<literallayout>
    <emphasis>üyeismi</emphasis>=en.tldp.org=<emphasis>dizgecik</emphasis>@<emphasis>üyelik.alanadı</emphasis>
</literallayout>
            </para></listitem>
            <listitem><para>
İkinci durum, yanıtların, istek postasının (<email>spam-l-request@peach.ease.lsoft.com</email> gibi bir adrese istek yapılması gibi) ileti başlığındaki yanıtlama adresine gönderilmesi ile ilgilidir. Bu adres imli olmayacağından, liste sunucusundan gelen yanıt sunucunuz tarafından reddedilecektir.
              </para><para>
Postayı imsiz alıcı adresine yollayan bu tür sunucuları <quote>aklisteye</quote> almaktan başka yapabileceğiniz pek birşey yoktur.
            </para></listitem>
          </itemizedlist>
        </para></listitem>
      </itemizedlist>
      </para><para>
Bu noktada bu yaklaşım kenarından köşesinden kırılmaya başlar. Bununla birlikte, özgün postası sizin sunucunuzdan gönderilmemiş meşru teslimat durum bildirimleri de reddedilir. Bu durumda, postalarını sadece sizin denetiminizde olan sunucular üzerinden gönderen kullanıcılarınız için bunu yapmayı düşünebilirsiniz.
      </para><para>
Sonuç olarak, yukarıda bahsedilen durumların hiçbirinin mevcut olmadığı durumlarda, bu yöntem dolaylı spamı engelleme imkanı vermekten başka, bunları üreten site sahiplerini eğitme imkanı da verir. Bunun yanında, yararlı bir yan etki olarak, <xref linkend="spam-filtering-callback"/> yapan siteler, özgün postanın sadece sizin sunucunuzdan gitmiş olması durumunda bir olumlu yanıt alacaklardır. Özünde, spamcılar tarafından gönderici adreslerin taklit edilmesine maruz kalma şansını düşürürsünüz.
      </para><para>
Kullanıcılarınızın giden postalarında imli adresler belirtmek isteyip istemediklerine bağlı olarak, adreslerinin imsiz türlerine dönen postalara izin verecek konakları belirleyebilirsiniz. Örneğin, bu kullanıcılar posta sunucunuzun aynı zamanda sisteme kayıtlı kullanıcıları iseler, onların ev dizinlerindeki belli bir dosyanın içeriğine bakarak bunu yapabilirsiniz.
      </para>
    </sect3>
    <sect3 id="spam-filtering-dsnrealuser">
      <title>Göndericisi olmayan postaları sadece gerçek kullanıcılar için kabul edin</title><para>
Zarf gönderici imleri ile ilgili sınamalar yapıyor olsanız bile, göndericisiz postaların istenmeyenleri arasından kaçanlar olabilir. Özellikle, bu şemayı yeğleyen kullanıcılarınız varsa, <option>postmaster</option> veya <option>mailer-daemon</option> gibi takma adlara gönderilmiş postalarda böyle bir imin varlığına bakmazsınız. Mantıken, bu takma adlı kullanıcılar için giden bir posta olmayacağından, bunlara göndericisiz postalar da gelmemesi gerekir.
      </para><para>
Bu tür takma adlı kullanıcılar için hatta, alıcı adresi için bir posta kutusu olmayan postaları reddedebilirsiniz.
      </para>
    </sect3>
  </sect2>
</sect1>

<sect1 id="spam-filtering-considerations">
  <title>Dikkate Alınacak Diğer Hususlar</title><para>
Sistem çapında filtrelemenin bir sonucu olarak devreye giren bazı özel durumlar vardır. Burada bunlar üzerinde duracağız.
    </para>
  <sect2 chunkthis="1" id="spam-filtering-multimx">
    <title>Çok Sayıda Posta Alıcısı</title><para>
Çoğu DNS kaydı birden fazla <xref linkend="spam-filtering-mx"/> (MX) belirtir. Siz de birden fazla posta alıcısı kullanıyorsanız, birincil posta alıcınızda uyguladığınız filtrelemeleri diğerleri için de yapmalısınız. Aksi takdirde, postayı birincil posta alıcınıza teslim edemeyen gönderici konak teslimatı yedek posta alıcılarınızda yapacaktır.
    </para><para>
Eğer yedek posta alıcılarınız sizin denetiminiz altında değilse, <emphasis>çok sayıda posta alıcısına gerçekten ihtiyacım var mı</emphasis> diye kendi kendinize sormalısınız. Yedek posta sunucularınız, gelen postaları alıp sizin birincil posta alıcınıza göndermekten başka bir şey yapmıyorsa, <emphasis>gereksiz</emphasis> posta sunucuları olarak davranıyorlar demektir. Böyle bir durum varsa, şüphesiz onlara ihtiyacınız yok demektir. Birincil posta sunucunuz bir süre için devre dışı kalacaksa, bunlar devreye sokulabilir, yine de işini iyi yapan konakların postayı teslim etmek için günlerce işlemi yineleyeceklerini aklınızdan çıkarmayın<footnoteref linkend="spam-filtering-noretrysenders"/>.
    </para><para>
Çok sayıda posta alıcısı gerektiren bir durum da çeşitli sunucular arasında yükün dağıtılmak istendiği durumdur. Örneğin o kadar çok posta geliyordur ki, bir makine tek başına bunlara yetmiyordur. Bu durumda bu gereksinimi ortadan kaldırmak için bazı görevleri (<link linkend="spam-filtering-virusscanners">virus</link> ve <link linkend="spam-filtering-spamscanners">spam</link> tarayıcıları gibi) diğer makinelere paylaştırabilirsiniz.
    </para><para>
Tekrar belirtelim, eğer çok sayıda posta alıcısı kullanacaksanız, yedek sunucularınız da en azından birincil sunucu kadar filtreleme yapmıyorsa, birincil sunucunun yaptığı filtrelemenin bir faydası olmayacaktır.
    </para><para>
Çok sayıda posta alıcısı kullanımı ile ilgili diğer durumlar için <xref linkend="spam-filtering-greylisting"/> bölümüne de bakınız.
    </para>
  </sect2>

  <sect2 chunkthis="1" id="spam-filtering-otherservers">
    <title>Diğer SMTP Sunucularına Erişimin Engellenmesi</title><para>
DNS kaydınızda <xref linkend="spam-filtering-mx"/> olarak listelenmemiş SMTP sunucularınız varsa, bunlara internetten gelen bağlantıları kabul etmemelisiniz. İnternetten gelen tüm posta trafiğini sadece posta alıcılarınız kabul etmelidir.
    </para><para>
Bu husus SMTP sunucuları ile sınırlı değildir. Eğer sitenizde sadece dahili kullanıma yönelik hizmet sunan makineler varsa, bunlara erişimi güvenlik duvarı kullanarak sınırlamalısınız.
    </para><para>
Bu bir kural olmakla beraber istisnaları da vardır. Eğer bunların neler olduğunu dair bir fikriniz yoksa bu kural tam size göredir.
    </para>
  </sect2>



  <sect2 chunkthis="1" id="spam-filtering-forwardedmail">
    <title>Yönlendirilen Postalar</title><para>
Aşağıdaki gibi <quote>dost</quote> kaynaklardan yönlendirilmiş postaları spam filtrelemenin bir sonucu olarak reddetme konusunda dikkatli olmalısınız:
    </para><para>
    <itemizedlist>
      <listitem><para>
Varsa, yedek posta alıcılarınız.Bunların döküntü postanın çoğunu zaten filtrelediğini varsayarak (bkz. <xref linkend="spam-filtering-multimx"/>).
      </para></listitem>
      <listitem><para>
Sizin ya da kullanıcılarınızın üyesi oldukları posta listeleri. Böyle postaları yine de filtreleyebilirsiniz (bir kara delikte kaybolmaları hayati önemde olmayabilir). Ancak, postayı reddetmeniz, liste sunucusunun bu üyeyi üyelikten çıkarmasına sebep olabilir.
      </para></listitem>
      <listitem><para>
Alıcının diğer hesapları. Tekrar belirtelim, postaların reddedilmesi dolaylı spam üretecek ve/veya posta yönlendiren konaklarda sorunlara yolaçacaktır.
      </para></listitem>
    </itemizedlist>
    </para><para>
Son iki kaynak ile ilgili bir mantıksal çıkarım yapabiliriz: Bu iki kaynak kullanıcıya özeldir. Dolayısıyla, şu sorular akla gelir: Aklisteye alınmasını istedikleri konakları belirtebilmeleri için kullanıcılara nasıl bir imkan sunabilirim ve böyle ayrı ayrı aklisteleri sistem çapında SMTP sırasında filtreleme yaparken nasıl kullanabilirim? Eğer, çeşitli alıcılarıma bu iletiler bir yönlendirmenin sonucu olarak geliyorsa (posta listeleri buna bir örnektir), kullanacağım aklisteye nasıl karar vereceğim?
    </para><para>
Sihirli bir reçetemiz yok. Bu durumlardan her biri birazcık çalışma yapmayı gerektirir. Alıcılarınızın herhangi birinin aklistesindeki konaklardan posta geldikçe, bunları spam sınıflamasına sokmaksızın kabul etmeye karar verebilirsiniz. Örneğin, her <command>RCPT TO:</command> komutunda bu alıcının aklistesinde gönderici konağın bulunup bulunmadığına bakarsınız. Eğer varsa, daha sonra reddedilmesini önlemek için bir bayrak kullanırsınız. Daha da verimli olması açısından, alıcıların aklistelerinden üretilmiş bir <emphasis>ortak</emphasis> akliste kullanabilirsiniz.
    </para><para>
Eklerdeki gerçeklenimlerde daha fazla ayrıntı bulabilirsiniz.
    </para>
  </sect2>

  <sect2 chunkthis="1" id="spam-filtering-usersettings">
    <title>Kullanıcı Verileri ve Ayarları</title><para>
Sitedeki her kullanıcı için verileri ve ayarları desteklemek isteyebileceğiniz başka durumlar da mevcuttur. Örneğin, gelen postayı SpamAssassin (bkz. <xref linkend="spam-filtering-spamscanners"/>) ile tarıyorsanız, spam eşikleri, kabul edilecek dil ve karakter kodlamaları ve Bayes eğitimi/verileri gibi ayarları kullanıcıya özel hale getirmeyi ve bu alıcılara gelen postaları bu ayarlara göre taramayı düşünebilirsiniz.
    </para><para>
Bu sadece, SMTP sırasında gelen posta belli bir alıcı için teslim alınmadan önce sistem seviyesinde yapılabilir ve böyle bir işlem kişisel tercihlere çok iyi uyum sağlamaz. Tek bir iletinin çok sayıda alıcısı olabilir; ve  <xref linkend="spam-filtering-forwardedmail"/>daki durumun aksine, alıcıların tercihlerinin bir toplamı olarak ortak bir aklistenin kullanımı iyi bir seçenek olmaz. Kullanıcılarınızın anadillerinin farklı farklı olduğu bir senaryo mevcut olabilir.
    </para><para>
Anlaşılacağı üzere, bu duruma uygun bir değişiklik yapılabilir. İşin püf noktası, gelen iletinin alıcılarının sayısını birle sınırlamaktır, böylece ileti kullanıcının ayarlarına ve verilerine uygun olarak analiz edilebilir.
    </para><para>
Bunu yapmak için, ilk <command>RCPT TO:</command> komutunu aldıktan sonra diğer komutlara bir SMTP <command>451</command> (defer) yanıtı verilir. Eğer gönderici posta aktarımcısı işini bilen bir aktarımcı ise bu yanıtı nasıl yorumlayacağını bilir ve teslimatı daha sonra yineler. (Eğer bunu yapmazsa, büyük ihtimalle bu postanın göndericisi sizin kendisinden posta almak istemediklerinizden biridir.)
    </para><para>
Açıkça bu durumu kurtarmaya çalışmaktan başka bir şey değildir. Çok sayıda alıcıya gönderilmiş postalar her alıcı için yarım saat veya daha uzun bir süre gecikir. Bilhassa postanın zamanında ulaşmasının önemli olduğu şirket ortamlarında, gerek şirket için de gerekse dışında postaların teslim alınıp alınmaması dolayısıyla işlerin zamanında yapılması ile ilgili tartışmalar görülmeye başlar. Bu gibi ortamlar sözkonusu olduğunda bu iyi bir çözüm değildir.
    </para><para>
Özellikle tüzel girişimler ve çok büyük sitelerle ilgili diğer bir durum, gelen postanın teslimat için dahili makinelere yönlendirildiği durumdur. Bu durumda, posta alıcısında kullanıcıların hesapları bulunmaz. Ama hala veritabanı ya da LDAP sorguları gibi işlemlerle kullanıcıya özel verileri desteklemek mümkündür. Yine de, attığınız taş ürküttüğünüz kurbağaya değer mi, bu tartışılır.
    </para><para>
Ama şu olur, küçük bir siteyseniz ve teslimatların gecikmesinden korkunuz yoksa, her kullanıcının kendi filtreleme koşullarına uygun filtreleme yapabilirsiniz.
    </para>
  </sect2>
</sect1>

<sect1 id="spam-filtering-qanda">
  <title>Sorular ve Cevaplar</title>
    <para>
Bu bölümde, sizlerden gelen sorulara yanıt vermeye çalışacağım. Eğer burada yanıtlarını bulamadığınız sorularınız varsa ya da bu yanıtlara ekleyebileceğiniz bilgiler varsa, lütfen bunları bana <link linkend="spam-filtering-feedback">bildirin</link> ki, onları da buraya ekleyebileyim.
    </para>
  <qandaset defaultlabel="number">
    <title>Spamcılar Uyum Sağlarsa</title>
    <qandaentry>
      <question id="spam-filtering-qanda-adapt">
        <para>
Spamcılar uyum sağlayıp bu belgede açıklanan teknikleri aşmanın çarelerini bulurlarsa ne olacak?
      </para></question><answer><para>
Olur mu olur, bakalım neler olur. <literal>:-)</literal>
        </para><para>
Açıklanan bazı sınamalar (<xref linkend="spam-filtering-smtpchecks"/> ve <xref linkend="spam-filtering-greylisting"/> gibi) özellikle <emphasis>kalleş yazılımların</emphasis> davranışlarını hedef alır. Eğer yeterince site bu sınamaları yapmaya başlarsa bu davranışların değişeceğini düşünmek elbette mümkündür. Hatmut Danisch bu konuda şöyle diyor:
        </para><para><blockquote><para>
Kalleş yazılımlar SMTP protokolünü kendilerine uydurarak kullanırlar, çünkü daha iyisine ihtiyaçları yoktur. Onlar bu şekilde çalışır, hem niye fazla zaman kaybetsinler ki? Bu arada kalleş yazılımlarda kalite yükselmiştir, hatta spam iletilerinin kalitesinde bile önemli bir iyileşme göze çarpmaktadır. Kötü SMTP protokolü nedeniyle spam iletilerini reddeden kullanıcı sayısı yeterli bir seviyeye ulaştığında spam yazarları da yazılımlarını iyileştirecektir.
          </para></blockquote></para><para>
Böyle kalleş yazılımların uyum sağlamaya çalışacakları durumlara bir bakalım:
        </para><para>
        <itemizedlist>
          <listitem><para>
<link linkend="spam-filtering-smtpdelays">SMTP aktarımındaki gecikmeleri</link> kandırmak için alıcı durumundaki SMTP sunucusundan gelecek her yanıtı beklemek zorundalar. Bu noktada, spam yapan konağın birim zamanda teslim edebileceği posta sayısını bu gecikmeleri birarada kullanarak önemli ölçüde düşürebiliyoruz. Spamcılar, DNS karalistelerine ve içerik filtrelerine yakalanmadan önce mümkün olduğunca çok postayı teslim edebilmek için zamana karşı yarıştıklarından, bu araçların etkinliğini olabildiğince arttırmaya çalışıyoruz.
            </para><para>
<xref linkend="spam-filtering-micropay"/>na benzer bir etki sağlamak üzere, gönderici, postanın her alıcısı için hesaplamalı bir kimlik denetim dizgesi hazırlamak için birkaç saniye harcayıp bunu alıcının doğrulayabilmesi için ileti başlığına ekleyebilir. Bu şemaların karmaşıklığı, uygulanabilirliğini zorlaştıran faktörlerden biri gibi görünse de, asıl önemlisi, dünyadaki herkesin katılımını gerektirmesidir. Halbuki SMTP gecikmelerinin etkinliği daha uygulandığı ilk makinede ortaya çıkmaya başlar.
          </para></listitem>
          <listitem><para>
<xref linkend="spam-filtering-helocheck"/>nı kandırmak için selamlaşmayı olması gerektiği gibi yapmak, yani kendilerini geçerli bir <xref linkend="spam-filtering-fqdn"/> ile tanıtmak zorundalar. Özellikle,  kendiliklerinden rDNS sorgusunun sonucunu iletinin Received: başlığına eklemeyen <link linkend="spam-filtering-mta">posta aktarımcıları</link> açısından böyle bir selamlaşma izlenebilirliği arttıracaktır.
          </para></listitem>
          <listitem><para>
<xref linkend="spam-filtering-senderchecks"/>nı kandırmak için ise, sürekli geçerliliği olan bir gönderici adresi belirtmek zorundalar. Bunu yaparlar mı?
          </para></listitem>
          <listitem><para>
<xref linkend="spam-filtering-greylisting"/>yi kandırmak için geçici olarak başarısızlığa uğramış teslimatları bir saat sonra (ama dört saat geçmeden) yinelemek zorundalar. (İyi bir gerçeklenimin yaptığı gibi başarısız olmuş her postanın bir kopyasını tutmak yerine, başarısız olmuş alıcıların bir listesini tutmak kalleş yazılımlar için yeterli olacağından bu adreslere bir veya iki saat sonra bir atak başlatabilirler.)
            </para><para>
Öyle bile olsa, <link linkend="spam-filtering-spamtrap">spam tuzakları</link> ile beslenen <xref linkend="spam-filtering-dnsbl"/> ile birlikte <emphasis>grilisteleme</emphasis> hala etkinliğini koruyacaktır. Bu bir saatlik zorunlu gecikme, gönderici konağı listelerine almak için bu karalistelere yeterli süreyi verecektir.
          </para></listitem>
        </itemizedlist>
        </para><para>
<xref linkend="spam-filtering-spamscanners"/> ve  <xref linkend="spam-filtering-virusscanners"/> gibi yazılım araçları sürekli geliştirilmektedir. Spamcılar kendilerini geliştirdikçe bunlar da geliştirilmektedir, dolayısıyla bu araçların daima son sürümlerini kullanarak bunların etkin kalmasını sağlayabilirsiniz.
        </para><para>
Sonuç olarak, bu belge de gelişmeye ve değişikliklere açık. Döküntü postaların değişken tabiatına uygun olarak, bunları engellemek isteyenler de hep yeni ve oldukça yaratıcı fikirlerle ortaya çıkmaktalar.
        </para>
      </answer>
    </qandaentry>
  </qandaset>
</sect1>

<appendix id="spam-filtering-exim">
  <title>Exim Gerçeklenimi</title>
    <para>
Burada, bu belgede açıklanan tekniklerin ve araçların Exim <xref linkend="spam-filtering-mta"/>na uyarlanması üzerinde duracağız.
    </para>

  <sect1 id="spam-filtering-exim-prereq">
    <title>Öngereksinimler</title><para>
Bu örnekler için, <option>Exim</option> <xref linkend="spam-filtering-mta"/>na ihtiyacınız olacak, Tom Kistner'in <option>Exiscan-ACL</option> yamasının uygulanmış olması tercih edilmelidir. İkisi <option>Exim+Exiscan-ACL</option> olarak tek bir paket halinde çoğu Linux dağıtımında, hatta FreeBSD'de bulunmaktadır. Daha fazla bilgi edinmek için <ulink url="http://duncanthrax.net/exiscan-acl/">Exiscan-ACL</ulink> ana sayfasına bakınız<footnote><para>
Dağıtımın öntanımlı posta aktarımcısının <option>Exim</option> olması <ulink url="http://www.debian.org/">Debian GNU/Linux</ulink> kullanıcılarının özelinde,  <option>Exim</option>'i en çok tercih edilen posta aktarımcısı haline getirmektedir. Eğer siz de bir Debian (<quote>Sarge</quote> veya üstü) kullanıcısı iseniz,  Exim+Exiscan-ACL'ye <option>exim4-daemon-heavy</option> paketini kurarak kavuşabilirsiniz:
</para><para>
<screen>
# <command>apt-get install exim4-daemon-heavy</command>
</screen></para></footnote>.
    </para><para>
Son gerçeklenim örneğinin birlikte çalışabildiği ek araçlar:
    </para><para>
    <itemizedlist>
      <listitem><para>
<ulink url="http://www.spamassassin.org/">SpamAssassin</ulink> - posta içeriğini ampirik yaklaşımlardan oluşmuş çok sayıda ve oldukça karmaşık araçlarla analiz eden çok popüler bir spam filtreleme aracı.
      </para></listitem>
      <listitem><para>
<ulink url="http://packages.debian.org/unstable/mail/greylistd">greylistd</ulink> - Exim ile kullanmak için bu belgenin yazarı tarafından geliştirilmiş basit bir grilisteleme çözümü.
      </para></listitem>
    </itemizedlist>
    </para><para>
Örnekler üzerinde başka araçlar da kullanılmıştır.
    </para>
  </sect1>

  <sect1 id="spam-filtering-exim-configfile">
    <title>Exim Yapılandırma Dosyası</title><para>
Exim yapılandırma dosyası genel tanımlarla başlar (buna <emphasis>ana bölüm</emphasis> diyeceğiz) ve çeşitli alt bölümlerden oluşur<footnote><para>
<emphasis>Debian kullanıcılarının dikkatine:</emphasis>
<option>exim4-config</option> paketi Exim yapılandırmasını tek bir yapılandırma dosyası halinde mi tutacağınızı yoksa <option>/etc/exim4/conf.d</option> altındaki çeşitli dizinlere ve dosyalara bölünmüş olarak mı tutacağınızı seçme imkanı tanır.
      </para><para>
Eğer, çok dosyalı yapılandırmayı seçerseniz (ben bunu öneriyorum!), <option>exim4-config</option> ile sağlanan dosyalara dokunmadan (içeriklerini değiştirmeden) bu alt dizinlere kendi oluşturduğunuz dosyaları ekleyerek yapılandırmayı özelleştirebilirsiniz. Örneğin, <command>RCPT TO:</command> komutu için kendi ACL'nizi belirtmek isterseniz, <option>/etc/exim4/conf.d/acl/80_local-config_rcpt_to</option> isimli bir dosya oluşturabilirsiniz (bkz. <xref linkend="spam-filtering-acl_rcpt_to_1"/>).
      </para><para>
Exim başlatma betiği (<option>/etc/init.d/exim4</option>) her çalıştırılışında bu dosyalardan büyükçe ve tek bir çalışma anı yapılandırma dosyası oluşturur.</para></footnote>.
Bu alt bölümlerin her biri şöyle bir satırla başlar:
      </para><para>
<screen>
begin <emphasis>bölümismi</emphasis>
</screen>
    </para><para>
Zamanımızın çoğunu <option>acl</option> bölümünde (<option>begin acl</option> ile başlayan bölüm) harcayacağız; ama dosyanın başındaki ana bölüm ile <option>transports</option> ve <option>routers</option> bölümlerine de bir kaç öğe ekleyecek ya da bazılarında değişiklik yapacağız.
    </para>
    <sect2 chunkthis="1" id="spam-filtering-exim-acl">
      <title>Erişim Denetim Listeleri</title>
      <para>(ACL - Access Control Lists)</para><para>
4.xx sürümünden itibaren Exim, SMTP sırasındaki filtrelemeler için <emphasis>Erişim Denetim Listeleri</emphasis> (ACL'ler) adı verilen oldukça karmaşık ve esnek bir mekanizma kullanmaktadır.
      </para><para>
Bir ACL, SMTP aktarımı sırasında gelen iletinin red mi yoksa kabul mü edileceğine karar verebilmek için, uzak konak ilk bağlantıyı kurduğunda veya <command>HELO/EHLO</command>, <command>MAIL FROM:</command>, <command>RCPT TO:</command> gibi aktarımın çeşitli aşamalarından birinde değerlendirmeler yapabilmek amacıyla kullanılabilir. Örneğin, karşıdan gelen her <command>RCPT TO:</command> komutunda değerlendirmeler yapmak için <option>acl_rcpt_to</option> isimli ACL'yi kullanabilirsiniz.
      </para><para>
Bir ACL, <emphasis>deyimler</emphasis>den (veya <emphasis>kurallar</emphasis>dan) oluşur. Her deyim eylem belirten <option>accept</option> (kabul et), <option>warn</option> (uyar), <option>require</option> (gerekir),  <option>defer</option> (ertele) veya <option>deny</option> (reddet) gibi bir emir ile başlar ve bunu koşullar, seçenekler ve diğer ayarlamalardan oluşan bir liste izler. Her deyim, tanımlayıcı bir eyleme rastlanıncaya kadar (<option>warn</option> hariç) sırayla değerlendirilir. Her ACL'nin sonunda örtük bir <option>deny</option> vardır.
      </para><para>
<option>acl_rcpt_to</option> ACL'sinden örnek bir deyim:
      </para><para>
<screen>
  deny
    message  = relay not permitted
    !hosts   = +relay_from_hosts
    !domains = +local_domains : +relay_to_domains
    delay    = 1m
</screen>
      </para><para>
Bu deyim, <command>RCPT TO:</command> komutu <literal>+relay_from_hosts</literal> (röleleme yapmasına izin verilen konaklar) listesindeki konaklardan birinden alınmamışsa ve alıcı konak <quote>+local_domains</quote> (yerel alanlar) veya <quote>+relay_to_domains</quote> (röleleme yapılacak alanlar) listelerindeki konaklardan biri değilse, postayı reddedecektir. Bu arada, <quote>550</quote> yanıtını vererek reddetmeden önce karşı sunucuyu bir dakika bekletecektir.
      </para><para>
SMTP aktarımının belli bir aşamasında bir ACL'nin değerlendirmeye alınabilmesi için Exim'in <emphasis>kural denetimleri</emphasis>nde bu ACL'yi belirtmek gerekir. Örneğin, önceki örnekteki <option>acl_rcpt_to</option> ACL'sinin <command>RCPT TO:</command> komutunda değerlendirmeye alınabilmesi için Exim yapılandırma dosyasının ana bölümüne (<option>begin</option> ile başlayan ilk satırdan önceki bölüm) şöyle bir satır eklemek gerekir:
      </para><para>
<screen>
acl_smtp_rcpt = acl_rcpt_to
</screen>
      </para><para>
Bu tür <emphasis>kural denetimleri</emphasis>nin tam listesini <ulink url="http://www.exim.org/exim-html-4.60/doc/html/spec.html/ch14.html#id2571138">Exim belirtiminin 14.11 bölümünde</ulink> bulabilirsiniz.
      </para>
    </sect2>

    <sect2 chunkthis="1" id="spam-filtering-exim-expansions">
      <title>Yerleşikler</title><para>
Çalışma anı değişkenleri, sorgu işlevleri, dizgeler ve düzenli ifadeler, konak ve alan adı listeleri, vs. gibi çok sayıda oluşum desteklenmektedir. Bunların kapsamlı bir listesini son x.x0 sürümleriyle gelen <quote>spec.txt</quote> dosyasında bulabilirsiniz. ACL'ler ise <ulink url="http://www.exim.org/exim-html-4.60/doc/html/spec.html/ch39.html">Exim belirtiminin 39. bölümünde</ulink> açıklanmıştır.
      </para><para>
Özellikle, ACL deyimlerinde değer atamak için kullanılmak üzere genel amaçlı yirmi yerleşik değişken tanımlıdır:
      </para><para>
      <itemizedlist>
        <listitem><para>
<varname>$acl_c0</varname> - <varname>$acl_c9</varname> değşkenlerine SMTP bağlantısı boyunca kalıcı olacak değerler atanabilir.
        </para></listitem>
        <listitem><para>
<varname>$acl_m0</varname> - <varname>$acl_m9</varname> değişkenlerine bir ileti alınırken değer atanabilir, fakat alım sonunda bunlara yeniden değer atanmaz. Bunlara, <command>HELO</command>, <command>EHLO</command>, <command>MAIL</command> ve  <command>RSET</command> komutları tarafından da yeniden değer atanabilir.
        </para></listitem>
      </itemizedlist>
    </para></sect2>
  </sect1>

  <sect1 id="spam-filtering-exim-options">
    <title>Seçenekler ve Ayarlar</title><para>
Exim yapılandırma dosyasının ana bölümü (<option>begin</option> ile başlayan ilk satırdan önceki bölüm) çeşitli makrolar, kural denetimleri ile genel ayarları içerir. Daha sonra kullanacağımız bazı makroları tanımlayarak başlayalım:
    </para><para>
<screen>
# İleti boyutunun sınırı; bunu DATA ACL içinde kullanacağız.
MESSAGE_SIZE_LIMIT = 10M

# Spam veya Virus taraması için azami ileti boyutu.
# Büyük iletiler sunucuyu aşırı yüklemesin diye düşük tutuyoruz.
MESSAGE_SIZE_SPAM_MAX = 1M

# Çırpılama için kullanmak üzere gizemli bir dizge tanımlayan makro.
# BUNU KENDİNİZE GÖRE DÜZENLEYİN!.
SECRET = <emphasis>gizemli-dizge</emphasis>
</screen>
    </para><para>
Genel Exim ayarlarının bazılarını yapalım:
    </para><para>
<screen>
# DNS başarısızlıklarını (SERVFAIL) sorgu başarısızlığı olarak
# ele alacağız. Böylece, daha sonra mevcut olmayan alanlara veya
# alanadı sunucusu olmayan alanlara ait gönderici adreslerden
# gelen teslimatları reddedebileceğiz. (Bu tanıma göre, yerel
# alanlar ve röleleme yapılan alanlar için sorgu yapılmayacak.)
dns_again_means_nonexist = !+local_domains : !+relay_to_domains

# Tüm konaklar için ACL'lerde HELO doğrulamasını etkinleştirelim.
helo_try_verify_hosts = *

# Bir defada hizmet sunacağımız gelen bağlantı sayısına bir
# sınırlama koymuyoruz. Daha sonra spamcılara SMTP aktarım
# gecikmeleri uygulayacağımız için bu sırada yeni gelen bağlantıları
# böylece kabul edebileceğiz.
smtp_accept_max = 0

# Ama, sistemin yükü de 10'nun üzerini çıkmamalı.
smtp_load_reserve = 10

# Hiçbir konağa ESMTP "PIPELINING" yapabileceğimizi söylemeyeceğiz.
# Bu, kalleş yazılımlar için gerekli, boruhattı açmaya bayılırlar.
pipelining_advertise_hosts = :
</screen>
    </para><para>
Son olarak, gelen bir SMTP aktarımının çeşitli aşamalarında değerlendirmeye alınmasını istediğimiz beş ACL'yi Exim kural denetimcisine tanıtacağız:
    </para><para>
<screen>
acl_smtp_connect = acl_connect
acl_smtp_helo    = acl_helo
acl_smtp_mail    = acl_mail_from
acl_smtp_rcpt    = acl_rcpt_to
acl_smtp_data    = acl_data
</screen>
    </para>
  </sect1> <!-- Options and Settings -->

  <sect1 id="spam-filtering-exim-firstpass">
    <title>ACL'lerin Hazırlanması - İlk Aşama</title><para>
ACL bölümünde (<option>begin acl</option> ile başlayan bölüm) ihtiyacımız olacak ACL'leri tanımlayacağız. Bunu yaparken bu belgede daha önce açıkladığımız <xref linkend="spam-filtering-dnschecks"/> ve <xref linkend="spam-filtering-smtpchecks"/> gibi temel <xref linkend="spam-filtering-techniques"/>den bazılarını da kullanacağız.
    </para><para>
Bu aşamada, sınamaların çoğunu <xref linkend="spam-filtering-acl_rcpt_to_1"/> altında yapacağız ve diğer ACL'leri ise büyük oranda boş bırakacağız. Bunu böyle yapmamızın sebebi kalleş yazılımların daha SMTP aktarımının başlarında keşfedildiklerini anlamamaları içindir - aksi takdirde tekrar gelirler. Diğer taraftan, çoğu kalleş yazılım <command>RCPT TO:</command> başarısızlıklarında teslimattan vazgeçer.
    </para><para>
Bu ACL'leri daha sonra kullanmak üzere şimdiden oluşturacağız.
    </para>

    <sect2 chunkthis="1" id="spam-filtering-acl_connect_1">
      <title><literal>acl_connect</literal></title><para>
<screen>
# Bu erişim denetim listesi gelen bağlantının başlangıcında
# kullanılır. Bu sınamalar bağlantı kabul ya da red edilinceye
# kadar sırayla yapılır.

acl_connect:

  # Bu aşamada, herhangi bir sınama yapmıyoruz ve bağlantıyı
  # kabul ediyoruz.
  accept
</screen>
      </para>
    </sect2>

    <sect2 chunkthis="1" id="spam-filtering-acl_helo_1">
      <title><literal>acl_helo</literal></title><para>
<screen>
# Bu erişim denetim listesi gelen bir SMTP aktarımında HELO veya EHLO
# komutları için kullanılır. Bu sınamalar selamlaşma kabul ya da
# red edilinceye kadar sırayla yapılır.

acl_helo:

  # Bu aşamada, herhangi bir sınama yapmıyoruz.
  accept
</screen>
      </para>
    </sect2> <!-- acl_helo -->

    <sect2 chunkthis="1" id="spam-filtering-acl_mail_from_1">
      <title><literal>acl_mail_from</literal></title><para>
<screen>
# Bu erişim denetim listesi gelen bir SMTP aktarımında MAIL FROM:
# komutu için kullanılır. Bu sınamalar gönderici adresi kabul
# ya da red edilinceye kadar sırayla yapılır.

acl_mail_from:

  # Bu aşamada, herhangi bir sınama yapmıyoruz.
  accept
</screen>
      </para>
    </sect2>

    <sect2 chunkthis="1" id="spam-filtering-acl_rcpt_to_1">
      <title><literal>acl_rcpt_to</literal></title><para>
<screen>
# Bu erişim denetim listesi gelen bir SMTP aktarımında RCPT
# komutu için kullanılır. Bu sınamalar alıcı adresi kabul
# ya da red edilinceye kadar sırayla yapılır.

acl_rcpt_to:

  # Posta yerel SMTP üzerinden alınmışsa (yani, TCP/IP bağlantısı
  # ile gelmiyorsa) kabul et. Bunu boş bir konak alanını
  # sınayarak yapacağız. Ayrıca, postalarını rölelediğimiz
  # konaklardan gelen postaları da kabul edeceğiz.
  #
  # Alıcı doğrulamasını burada atlıyoruz, çünkü çoğu durumda
  # istemciler kullanıcıların posta istemcileridir ve SMTP
  # hata iletileri ile ne yapacaklarını bilmezler.
  #
  accept
    hosts       = : +relay_from_hosts


  # İleti, kimlik kanıtlaması yapılan bir bağlantı üzerinden
  # geliyorsa kabul ediyoruz. Yine, bu iletiler kullanıcıların posta
  # istemcilerinden geldiklerinden alıcı doğrulaması yapmıyoruz.
  #
  accept
    authenticated = *


  ######################################################################
  # DNS sınamaları
  ######################################################################
  #
  # Bu sınamaların sonuçları arabelleğe alınır, böylece çok sayıda alıcı
  # olduğunda çok sayıda DNS sorgusu yapılmasına gerek kalmaz.
  #

  # Eğer bağlanan konak seçtiğimiz birkaç DNS karalistesinde kayıtlı
  # ise iletiyi reddediyoruz. Bu listeleri seçerken dikkatli olun,
  # çoğu yanlış olumlama yapar ve/veya kara listeden silme konusunda
  # kuralları iyi belirlenmemiştir.
  #
  deny
    dnslists    = dnsbl.sorbs.net : \
                  dnsbl.njabl.org : \
                  cbl.abuseat.org : \
                  bl.spamcop.net
    message     = $sender_host_address is listed in $dnslist_domain\
                  ${if def:dnslist_text { ($dnslist_text)}}


  # Eğer gönderici konağın ters DNS sorgusu başarısız olursa
  # (rDNS kaydı yoksa veya sonuçlar normal DNS sorgusuyla eşleşmiyorsa)
  # iletiyi reddediyoruz.
  #
  deny
    message     = Reverse DNS lookup failed for host $sender_host_address.
    !verify     = reverse_host_lookup



  ######################################################################
  # Selamlaşma sınamaları
  ######################################################################

  # Bağlanan konak selamlaşma sırasında bir IP adresi belirtmişse,
  # postayı reddediyoruz.
  #
  deny
    message     = Message was delivered by ratware
    log_message = remote host used IP address in HELO/EHLO greeting
    condition   = ${if isip {$sender_helo_name}{true}{false}}


  # Bağlanan konak selamlaşma sırasında bizim isimlerimizden birini
  # kullanmışsa reddediyoruz.
  #
  deny
    message     = Message was delivered by ratware
    log_message = remote host used our name in HELO/EHLO greeting.
    condition   = ${if match_domain{$sender_helo_name}\
                  {$primary_hostname:+local_domains:+relay_to_domains}\
                  {true}{false}}


  # Bağlanan konak selamlaşma sırasında kendini tanıtmamışsa
  # reddediyoruz.
  #
  deny
    message     = Message was delivered by ratware
    log_message = remote host did not present HELO/EHLO greeting.
    condition   = ${if def:sender_helo_name {false}{true}}


  # HELO doğrulaması başarısız olmuşsa, ileti başlığına bir
  # X-HELO-Warning: satırı ekliyoruz.
  #
  warn
    message     = X-HELO-Warning: Remote host $sender_host_address \
                  ${if def:sender_host_name {($sender_host_name) }}\
                  incorrectly presented itself as $sender_helo_name
    log_message = remote host presented unverifiable HELO/EHLO greeting.
    !verify     = helo



  ######################################################################
  # Gönderici adresi sınamaları
  ######################################################################

  # Gönderici adresini doğrulatamazsak iletiyi reddedeceğiz.
  #
  # "callout" seçeneğini isterseniz silebilirsiniz. Özellikle, postanızı
  # doğrudan değil de göstermelik sunucu (smarthost) olarak
  # gönderiyorsanız, bu seçenek anlamsız olacaktır.
  #
  # Başarısız varlık doğrulamalarının ayrıntıları genelde 550 yanıtları
  # içerir; bunları yoksaymak için "sender/callout" dizgesini
  # "sender/callout,no_details" olarak değiştirebilirsiniz.
  #
  deny
    message     = &lt;$sender_address&gt; does not appear to be a \
                  valid sender address.
    !verify     = sender/callout



  ######################################################################
  # Alıcı adresi sınamaları
  ######################################################################

  # Yerel kısım @  %  / | ! karakterlerinden birini içeriyorsa,
  # iletiyi reddediyoruz. Bunlar normal yerel kısımlarda çok nadir
  # görülür, çoğunlukla röleleme sınırlamalarını aşmaya çalışanlarca
  # kullanılır.
  #
  # Ayrıca, yerel kısım bir nokta ile başlıyorsa da reddediyoruz.
  # Boş bileşenler RFC 2822'de kuraldışıdır, fakat Exim bu yaygın
  # olduğundan bunlara izin verir. Buna rağmen, bir nokta ile
  # başlayan bir yerel kısım bir dosya ismi olarak kullanılmışsa
  # (örneğin, bir posta listesi), sorunlara yol açabilir.
  #
  deny
    local_parts = ^.*[@%!/|] : ^\\.


  # Zarf göndericisi adresi boş olduğu halde iletinin birden fazla alıcısı
  # varsa, bağlantıyı kesiyoruz. Meşru teslimat durum bildirimleri asla
  # birden fazla adrese gönderilmez.
  #
  drop
    message      = Legitimate bounces are never sent to more than one \
                   recipient.
    senders      = : postmaster@*
    condition    = $recipients_count


  # Alıcı adres bizim postalarını kabul ettiğimiz alanlardan birine
  # ait değilse, iletiyi reddediyoruz.
  #
  deny
    message     = relay not permitted
    !domains    = +local_domains : +relay_to_domains


  # Alıcının geçerli bir posta kutusu yoksa iletiyi reddediyoruz.
  # Eğer posta kutuları sistemimizde bulunmuyorsa (alıcı alanadı
  # için yedek posta alıcısı isek), bir varlık sınaması yaparız;
  # ama hedef sunucu yanıt vermezse postayı mecburen kabul edeceğiz.
  #
  deny
    message     = unknown user
    !verify     = recipient/callout=20s,defer_ok


  # Aksi takdirde, alıcı adres geçerlidir.
  #
  accept

</screen>
      </para>
    </sect2>

    <sect2 chunkthis="1" id="spam-filtering-acl_data_1">
      <title><literal>acl_data</literal></title><para>
<screen>
# Bu erişim denetim listesi gelen bir SMTP aktarımında ileti
# tamamen alındıktan sonra kullanılır. Bu sınamalar alıcı adresi
# kabul ya da red edilinceye kadar sırayla yapılır.

acl_data:

  # İleti kendi konaklarımızdan alınmış ve Message-ID başlığını
  # içermiyorsa, onu biz ekleyeceğiz.
  #
  warn
    condition   = ${if !def:h_Message-ID: {1}}
    hosts       = : +relay_from_hosts
    message     = Message-ID: &lt;E$message_id@$primary_hostname&gt;


  # Posta yerel SMTP üzerinden alınmışsa (yani, TCP/IP bağlantısı
  # ile gelmiyorsa), kabul ediyoruz. Bunu boş bir konak alanını
  # sınayarak yapacağız. Ayrıca, postalarını rölelediğimiz
  # konaklardan gelen postaları da kabul edeceğiz.
  #
  accept
    hosts       = : +relay_from_hosts

  # İleti, kimlik kanıtlaması yapılan bir bağlantı üzerinden
  # geliyorsa kabul ediyoruz.
  #
  accept
    authenticated = *


  # İleti boyutu ile ilgili sınırlama aşılıyorsa iletiyi reddediyoruz.
  #
  deny
    message     = Message size $message_size is larger than limit of \
                  MESSAGE_SIZE_LIMIT
    condition   = ${if &gt;{$message_size}{MESSAGE_SIZE_LIMIT}{true}{false}}


  # Adres listesinin sözdizimi hatalıysa reddediyoruz.
  #
  deny
    message     = Your message does not conform to RFC2822 standard
    log_message = message header fail syntax check
    !verify     = header_syntax


  # Dışardan gelen ve Message-ID veya Date başlığı bulunmayan postaları
  # reddediyoruz.
  #
  # Bazı özelleştirilmiş posta aktarımcılarının, örneğin posta listesi
  # sunucularının boy gönderici adresi ile gönderdikleri postalara
  # kendiliklerinden bir Message-ID üretmedikleri bilinmektedir;
  # böyle durumlar için boş bir gönderici adresin varlığına da bakacağız.
  #
  deny
    message     = Your message does not conform to RFC2822 standard
    log_message = missing header lines
    !hosts      = +relay_from_hosts
    !senders    = : postmaster@*
    condition   = ${if or {{!def:h_Message-ID:}\
                           {!def:h_Date:}\
                           {!def:h_Subject:}} {true}{false}}


  # "Sender:", "Reply-To:" veya "From:" satırlarından en azından birindeki
  # gönderici adres doğrulanabilir değilse, bir uyarı veriyoruz.
  #
  warn
    message     = X-Sender-Verify-Failed: No valid sender in message header
    log_message = No valid sender in message header
    !verify     = header_sender


  # İletiyi kabul ediyoruz
  #
  accept
</screen>
      </para>
    </sect2> <!-- acl_data -->
  </sect1> <!-- Building ACLs - First Pass -->

  <sect1 id="spam-filtering-exim-smtpdelays">
    <title>SMTP aktarım gecikmelerinin eklenmesi</title>
    <sect2 chunkthis="1" id="spam-filtering-exim-smtpdelays-simple">
      <title>Basit yöntem</title>
      <para>
SMTP aktarım gecikmeleri uygulamanın en basit yolu hazırladığımız ACL'lerin sonundaki <option>accept</option> deyimine bir <option>delay</option> denetimi eklemektir:
      </para><para>
<screen>
  accept
    delay = 20s
</screen>
      </para><para>
Buna ek olarak, <xref linkend="spam-filtering-acl_rcpt_to_1"/> içindeki geçersiz kullanıcı (<quote>unknown user</quote>) ile ilgili <option>deny</option> deyimine arttırımlı gecikmeler de ekleyebilirsiniz. Bu, sözlük saldırılarını yavaşlatmak için oldukça yararlıdır. Örnek:
      </para><para>
<screen>
  deny
    message     = unknown user
    !verify     = recipient/callout=20s,defer_ok,use_sender
    delay       = ${eval:$rcpt_fail_count*10 + 20}s
</screen>
      </para><para>
Bu noktada birşeye dikkatinizi çekmek isterim, ileti verisi alındıktan bunu yapmanın yararı yoktur, bunun yapılabileceği tek yer <xref linkend="spam-filtering-acl_rcpt_to_1"/> ACL'sidir. Kalleş yazılımlar genellikle ileti verisini aktardıktan sonra sunucunuzun yanıtını beklemeden bağlantıyı keserler. İstemci bağlantıyı kessin ya da kesmesin bu noktada Exim'in iletinin teslimatı ile ilgili ne işlem yapacağının artık bir önemi kalmaz.
      </para>
    </sect2>

    <sect2 chunkthis="1" id="spam-filtering-exim-smtpdelays-selective">
      <title>Seçimlik Gecikmeler</title><para>
Benim gibi, SMTP aktarım gecikmelerine konu edeceğiniz konaklar için biraz daha seçici davranmak isteyebilirsiniz. Örneğin, bu belgede daha önce açıklandığı gibi, DNS karalistelerinde bulunma durumunda ya da kesin bir redde konu olmayan ama doğrulama da yapılamayan selamlaşmalar sonucunda bu gecikmeleri uygulamaya karar verebilirsiniz.
      </para><para>
Seçimlik gecikmelerin uygulayabilmek için <xref linkend="spam-filtering-acl_rcpt_to_1"/> ACL'sindeki bazı sınamaları diğer ACL'lere taşımak gerekir. Böylelikle, sorunların işaretlerini gördüğümüz anda gecikmeleri uygulayabilir ve kalleş yazılımların eşzamanlama hataları verme ve başka sorunlarla karşılaşma talihsizliğini arttırmış oluruz.
      </para><para>
Özellikle yapacaklarımız:
      </para><para>
      <itemizedlist>
        <listitem><para>
DNS sınamalarını <xref linkend="spam-filtering-acl_connect_final"/> ACL'sine taşıyacağız.
        </para></listitem>
        <listitem><para>
Selamlaşma sınamalarını <xref linkend="spam-filtering-acl_helo_final"/> ACL'sine taşıyacağız. Bir istisna: Bu noktada henüz selamlaşmanın olmayışını sınayamayız, çünkü bu ACL bir EHLO veya HELO komutunun varlığı halinde devreye girer. Bu sınamayı <xref linkend="spam-filtering-acl_mail_from_final"/> ACL'sinde yapacağız.
        </para></listitem>
        <listitem><para>
Gönderici adresi sınamalarını <xref linkend="spam-filtering-acl_mail_from_final"/> ACL'sine taşıyacağız.
        </para></listitem>
      </itemizedlist>
      </para><para>
Bununla birlikte, evvelce açıkladığımız sebeplerle, asıl reddi <command>RCPT TO:</command> komutunu alana dek yapmayacağız. Bunu gerçekleştirmek için önceki ACL'lerdeki <option>deny</option> deyimlerini <option>warn</option> deyimlerine dönüştüreceğiz ve <command>RCPT TO:</command> komutunu alana kadar hata iletilerini ve uyarıları saklamak için Exim'in genel amaçlı ACL değişkenlerini kullanacağız. Şöyle ki:
      </para><para>
      <itemizedlist>
        <listitem><para>
Teslimatı reddetmeye karar verirsek, gönderilecek <command>550</command> yanıtlarında kullanmak üzere hata iletisini saklamak için <literal>$acl_c0</literal> veya <literal>$acl_m0</literal> değişkenini kullanacağız:
          </para><para>
          <itemizedlist>
            <listitem><para>
Eğer gerekli koşullar bir posta teslimatından önce sağlanmışsa (örn, <xref linkend="spam-filtering-acl_connect_final"/> veya <xref linkend="spam-filtering-acl_helo_final"/> ACL'sinde), bağlantı boyunca değer saklayabilen <literal>$acl_c0</literal> değişkenini kullanacağız.
            </para></listitem>
            <listitem><para>
Posta aktarımı başladıktan sonra (örn. <command>MAIL FROM:</command> komutundan sonra), <literal>$acl_c0</literal> içeriğini iletilere özel değişken olan <literal>$acl_m0</literal>'a kopyalayacağız ve bu noktadan sonra bu değişkeni kullanacağız. Böylece, bu ileti ile belirlenmiş bir durum, aynı bağlantıdan alınan daha sonraki iletilerden etkilenmemiş olacak.
            </para></listitem>
          </itemizedlist>
          </para><para>
Ayrıca, benzer şekilde, <emphasis>günlükleme iletilerini</emphasis> <literal>$acl_c1</literal> veya <literal>$acl_m1</literal> değişkeninde saklayacağız.
        </para></listitem>
        <listitem><para>
Eğer, kesin reddine karar verilecek yeterli koşulların sağlanmadığı bir durumla karşılaşırsak, <literal>$acl_c1</literal> veya <literal>$acl_m1</literal> değişkeninde sadece bir uyarı iletisi saklayacağız. Posta aktarımı başladığında (örn, <xref linkend="spam-filtering-acl_mail_from_final"/> ACL'sinde), bu değişkenin içeriğini ileti başlığına da ekleyeceğiz.
        </para></listitem>
        <listitem><para>
Daha sonraki sınamaların (SpamAssassin taraması gibi) sonuçlarına bakmaksızın bir iletiyi <emphasis>kabul etmeye</emphasis> karar verirsek, durum belirtecini <literal>$acl_c0</literal> veya <literal>$acl_m0</literal> değişkeninde saklayacak ama <literal>$acl_c1</literal> ve <literal>$acl_m1</literal> değişkenlerini boş bırakacağız.
        </para></listitem>
        <listitem><para>
Her ACL'nin başlangıcında ve <xref linkend="spam-filtering-acl_mail_from_final"/> ACL'sinde, o anki zaman damgasını <literal>$acl_m2</literal> değişkenine atayacağız. ACL'nin sonunda ise, <literal>$acl_c1</literal> veya <literal>$acl_m1</literal> değişkeninin varlığına bakıp zaman damgasındaki değerden başlayarak 20 saniyelik gecikmeyi dolduracak şekilde SMTP aktarım gecikmesini uygulayacağız.
        </para></listitem>
      </itemizedlist>
      </para><para>
Kullandığımız değişkenleri bir tablo halinde özetlersek:
      </para><para>
      <table id="spam-filtering-aclvarusage" frame="all">
        <title>ACL bağlantı/ileti değişkenlerinin kullanımı</title>
        <tgroup cols="3" align="left" colsep="1" rowsep="1">
          <thead><row>
<entry>Değişkenler:</entry>
<entry><literal>$acl_[cm]0</literal> boş</entry>
<entry><literal>$acl_[cm]0</literal> dolu</entry>
          </row></thead>
          <tbody><row>
<entry><literal>$acl_[cm]1</literal> boş</entry>
<entry>(Henüz bir karar yok)</entry>
<entry>Postayı kabul ediyoruz</entry>
          </row><row>
<entry><literal>$acl_[cm]1</literal> dolu</entry>
<entry>Başlığa bir uyarı ekliyoruz</entry>
<entry>Postayı reddediyoruz</entry>
          </row></tbody>
        </tgroup>
      </table>
      </para><para>
Bu yaklaşıma bir örnek olarak, selamlaşma ile ilgili iki sınama yapacağız; birinde karşı taraf kendini IP adresi ile tanıtırsa postayı reddedeceğiz, diğerinde ise doğrulanabilir olmayan bir isim belirtirse bir uyarıyı kayda alacağız. Önceden, bu iki sınamayı <xref linkend="spam-filtering-acl_rcpt_to_1"/> ACL'sinde yapmıştık, şimdi <xref linkend="spam-filtering-acl_helo_final"/> ACL'sine alacağız.
      </para><para>
<screen>
acl_helo:
  # Gecikme uygularken başlangıç olarak kullanmak üzere o anki zaman
  # bilgisini kaydediyoruz.
  warn
    set acl_m2  = $tod_epoch

  # Posta yerel SMTP üzerinden alınmışsa (yani, TCP/IP bağlantısı
  # ile gelmiyorsa), kabul ediyoruz. Bunu boş bir konak alanını
  # sınayarak yapacağız. Ayrıca, postalarını rölelediğimiz
  # konaklardan gelen postaları da kabul edeceğiz.
  #
  accept
    hosts       = : +relay_from_hosts

  # Karşı taraf selamlaşmayı IP adresi ile yaparsa, $acl_c0'a red
  # iletisini, $acl_c1'e ise günlük iletisini kaydedeceğiz. Bunları
  # daha sonra "deny" deyiminde kullanacağız. Bu değişkenlerin varlığı
  # göndericinin oyalanacağını belirtecek.
  #
  warn
    condition   = ${if isip {$sender_helo_name}{true}{false}}
    set acl_c0  = Message was delivered by ratware
    set acl_c1  = remote host used IP address in HELO/EHLO greeting

  # Selamlaşmada doğrulaması başarısız olursa, acl_c1'e bir uyarı iletisi
  # kaydedeceğiz. Bu iletiyi daha sonra ileti başlığına ekleyeceğiz.
  # Bu değişkenin varlığı göndericinin oyalanacağını belirtecek.
  #
  warn
    condition   = ${if !def:acl_c1 {true}{false}}
    !verify     = helo
    set acl_c1  = X-HELO-Warning: Remote host $sender_host_address \
                  ${if def:sender_host_name {($sender_host_name) }}\
                  incorrectly presented itself as $sender_helo_name
    log_message = remote host presented unverifiable HELO/EHLO greeting.

  #
  # ... bu örnek için diğer sınamaları atlıyoruz ...
  #

  # Bağlantıyı kabul ediyoruz ama $acl_c1'de bir ileti varsa, göndericiyi
  # 20 saniye oyalıyoruz.
  accept
    set acl_m2  = ${if def:acl_c1 {${eval:20 + $acl_m2 - $tod_epoch}}{0}}
    delay       = ${if &gt;{$acl_m2}{0}{$acl_m2}{0}}s

</screen>
      </para><para>
Sonra, <xref linkend="spam-filtering-acl_mail_from_final"/> ACL'sinde iletileri <option>$acl_c{0,1}</option>'den <option>$acl_m{0,1}</option> değişkenlerine aktaracağız. Ayrıca, <literal>$acl_c1</literal> içeriğini ileti başlığına ekleyeceğiz.
      </para><para>
<screen>
acl_mail_from:
  # Gecikme uygularken başlangıç olarak kullanmak üzere o anki zaman
  # bilgisini kaydediyoruz.
  warn
    set acl_m2  = $tod_epoch

  # Posta yerel SMTP üzerinden alınmışsa (yani, TCP/IP bağlantısı
  # ile gelmiyorsa), kabul ediyoruz. Bunu boş bir konak alanını
  # sınayarak yapacağız. Ayrıca, postalarını rölelediğimiz
  # konaklardan gelen postaları da kabul edeceğiz.
  #
  accept
    hosts     = : +relay_from_hosts

  # $acl_c0 ve $acl_c1 değişkenleri bu SMTP aktarımı sırasında yapılmaya
  # çalışılacak her teslimat için kullanılacak red ve/veya uyarı iletilerini
  # içeriyor olacak (böyle bir durum varsa). Bu değişkenlerin içeriklerini
  # $acl_m{0,1} iletiye özel değişkenlere aktaracağız ve $acl_m1'deki uyarıyı
  # ileti başlığına ekleyeceğiz. (Bir red durumunda, $acl_m1 artık bir günlük
  # kaydı içeriyor olacak, ama iletiyi bununla değil başlığındaki kayıtla
  # reddedeceğiz.)
  #
  warn
    set acl_m0  = $acl_c0
    set acl_m1  = $acl_c1
    message     = $acl_c1


  #
  # ... bu örnek için diğer sınamaları atlıyoruz ...
  #

  # Bağlantıyı kabul ediyoruz ama $acl_c1'de bir ileti varsa, göndericiyi
  # 20 saniye oyalıyoruz.
  accept
    set acl_m2  = ${if def:acl_c1 {${eval:20 + $acl_m2 - $tod_epoch}}{0}}
    delay       = ${if &gt;{$acl_m2}{0}{$acl_m2}{0}}s

</screen>
      </para><para>
Kalan değişiklikler için <xref linkend="spam-filtering-exim-final"/> bölümüne bakınız.
      </para>
    </sect2>
  </sect1>

  <sect1 id="spam-filtering-exim-greylisting">
    <title>Grilisteleme Desteğinin Eklenmesi</title><para>
Exim ile kullanmak üzere hazırlanmış çeşitli grilisteleme gerçeklenimleri vardır. Burada bunların bir kısmına değineceğiz.
    </para>

    <sect2 chunkthis="1" id="spam-filtering-exim-greylistd">
      <title>greylistd</title><para>
Bu, belgenin yazarı tarafından bir Python gerçeklenimi olarak geliştirilmiş bir grilisteleme gerçeklenimidir. (Doğal olarak, bu gerçeklenim <xref linkend="spam-filtering-exim-final"/> bölümünde uygulanacak.) Tek başına bir artalan süreci olarak çalışır ve herhangi bir veritabanını kullanmaz. Grilesteleme verisi verimlilik açısından 32 bitlik basit bir çırpı olarak saklanır.
      </para><para>
Paketi <ulink url="http://packages.debian.org/unstable/mail/greylistd"/> adresinde bulabilirsiniz. Debian kullanıcıları APT ile kolayca kurabilir:
      </para><para>
<screen>
# <command>apt-get install greylistd</command>
</screen>
      </para><para>
<option>greylistd</option>'yi devreye sokmak için, <xref linkend="spam-filtering-acl_rcpt_to_final"/> ACL'sinde sonuncu <option>accept</option> deyiminden hemen önceye iki deyim ekleyeceğiz.
      </para><para>
<screen>
  # Belli bir sunucu/gönderici/alıcı üçlüsü için grilisteleme durumunu
  # belirleyecek "greylistd"'yi devreye sokacağız.
  #
  # Grilisteleme iletilerini bir boş gönderici için yapmıyoruz, çünkü
  # boş gönderici adresli varlık doğrulaması işimize yaramaz (gerçek
  # göndericinin varlığını sınamak için bir konağa posta gönderemeyiz).
  #
  defer
    message     = $sender_host_address is not yet authorized to deliver mail \
                  from &lt;$sender_address&gt; to &lt;$local_part@$domain&gt;. \
                  Please try later.
    log_message = greylisted.
    domains     = +local_domains : +relay_to_domains
    !senders    = : postmaster@*
    set acl_m9  = $sender_host_address $sender_address $local_part@$domain
    set acl_m9  = ${readsocket{/var/run/greylistd/socket}{$acl_m9}{5s}{}{}}
    condition   = ${if eq {$acl_m9}{grey}{true}{false}}
</screen>
      </para><para>
Hatalı <link linkend="spam-filtering-dsn">teslimat durum bildirimlerini</link> engellemek için <link linkend="spam-filtering-exim-sign">zarf gönderici imlerini</link> kullanmıyorsanız, bunun benzeri bir deyimi <xref linkend="spam-filtering-acl_data_final"/> ACL'sine ayrıca boş göndericili grilisteleme iletileri olarak ekleyebilirsiniz.
      </para><para>
Grilistelemenin amaçlarına uygun olarak veriyi burada yukarıdakinden biraz farklı olarak kullanıyoruz. Boş olan <option>$sender_address</option>'e ek olarak, bu noktada ne <option>$local_part</option> ne de <option>$domain</option> tanımlıdır. Ancak, <option>$recipients</option>, tüm alıcı adreslerinin virgüllerle ayrılmış bir listesini içerir. Meşru teslimat durum bildirimleri için bu değişken sadece bir adres içermelidir.
      </para><para>
<screen>
  # Burada, zarf gönderici adresi olmayan iletilere grilisteleme
  # uygulayacağız. Bunları RCPT TO:'dan sonra grilistelemeye konu
  # etmeyeceğiz, çünkü gönderici varlık doğrulamaları yaparken
  # karşı konaklarla olumsuz etkileşime girilebilir.
  #
  defer
    message     = $sender_host_address is not yet authorized to send \
                  delivery status reports to &lt;$recipients&gt;. \
                  Please try later.
    log_message = greylisted.
    senders     = : postmaster@*
    set acl_m9  = $sender_host_address $recipients
    set acl_m9  = ${readsocket{/var/run/greylistd/socket}{$acl_m9}{5s}{}{}}
    condition   = ${if eq {$acl_m9}{grey}{true}{false}}
</screen>
      </para>
    </sect2>

    <sect2 chunkthis="1" id="spam-filtering-exim-greylist-mysql">
      <title>MySQL gerçeklenimi</title><para>
Bu gerçeklenim, aşağıdaki gerçeklenimlerin üzerine inşa edilerek Johannes Berg <email>johannes@sipsolutions.net</email> tarafından geliştirilmiştir:
      </para><para>
      <itemizedlist>
        <listitem><para>
İlk olarak bir Postgres gerçeklenimi olarak Tollef Fog Heen <email>tfheen@raw.no</email> tarafından oluşturuldu.<sbr/><ulink url="http://raw.no/personal/blog/tech/Debian/2004-03-14-15-55_greylisting"/> adresinden edinilebilir.
        </para></listitem>
        <listitem><para>
Ardından, Rick Stewart <email>rick.stewart@theinternetco.net</email> üzerinde çalıştı ve çalışmasını<sbr/><ulink url="http://theinternetco.net/projects/exim/greylist"/> adresinde yayınladı.
        </para></listitem>
      </itemizedlist>
      </para><para>
Başka bir pograma ihtiyaç duymaz - gerçeklenim tamamen MySQL veritabanında yapılandırılmıştır.
      </para><para>
Yapılandırmanın gelişimini içeren bir arşiv ve bir <option>README</option> dosyası<sbr/><ulink url="http://johannes.sipsolutions.net/wiki/Projects/exim-greylist"/> adresinde mevcuttur.
      </para><para>
Sisteminizde MySQL kurulu olmalıdır. MySQL komut satırında <option>exim_greylist</option> ve <option>exim_greylist_log</option> isimli iki tablo ile <option>exim4</option> veritabanı oluşturulur:
      </para><para>
<screen>
CREATE DATABASE exim4;
use exim4;

CREATE TABLE exim_greylist (
   id bigint(20) NOT NULL auto_increment,
   relay_ip varchar(80) default NULL,
   sender varchar(255) default NULL,
   recipient varchar(255) default NULL,
   block_expires datetime NOT NULL default '0000-00-00 00:00:00',
   record_expires datetime NOT NULL default '9999-12-31 23:59:59',
   create_time datetime NOT NULL default '0000-00-00 00:00:00',
   type enum('AUTO','MANUAL') NOT NULL default 'MANUAL',
   passcount bigint(20) NOT NULL default '0',
   blockcount bigint(20) NOT NULL default '0',
   PRIMARY KEY  (id)
);

CREATE TABLE exim_greylist_log (
   id bigint(20) NOT NULL auto_increment,
   listid bigint(20) NOT NULL,
   timestamp datetime NOT NULL default '0000-00-00 00:00:00',
   kind enum('deferred', 'accepted') NOT NULL,
   PRIMARY KEY (id)
);
</screen>
      </para><para>
Exim yapılandırma dosyasının ana bölümüne bazı makrolar eklenir:
      </para><para>
<screen>
# Eğer başka veritabanları da kullanıyorsanız, bu veritabanına erişimi
# mysql_servers = localhost/exim4/<emphasis>kullanıcı</emphasis>/<emphasis>parola</emphasis> şeklinde sağlayabilirsiniz.

# seçenekler
# bunlar, xxx olarak mysql'in DATE_ADD(..,INTERVAL xxx) deyiminde
# geçerli olacak şekilde belirtilmelidir, örneğin çoğul olarak
# "2 HOUR" yerine "2 HOURS" belirtilirse geçersiz olacaktır.
GREYLIST_INITIAL_DELAY = 1 HOUR
GREYLIST_INITIAL_LIFETIME = 4 HOUR
GREYLIST_WHITE_LIFETIME = 36 DAY
GREYLIST_BOUNCE_LIFETIME = 0 HOUR

# tablo isimlerini değiştirebilirsiniz
GREYLIST_TABLE=exim_greylist
GREYLIST_LOG_TABLE=exim_greylist_log

# grilistelemeyi (geçici olarak) iptal etmek için bu satırı açıklama
# haline getirin
GREYLIST_ENABLED=

# günlük kayıtlarını etkinleştirmek için bu satırın başındaki # işaretini
# kaldırın
#GREYLIST_LOG_ENABLED=

# bundan sonrasında normalde bir düzenleme yapılmamalıdır

.ifdef GREYLIST_ENABLED
# veritabanı makroları
GREYLIST_TEST = SELECT CASE \
   WHEN now() > block_expires THEN "accepted" \
   ELSE "deferred" \
 END AS result, id \
 FROM GREYLIST_TABLE \
 WHERE (now() &lt; record_expires) \
   AND (sender      = '${quote_mysql:$sender_address}' \
     OR (type='MANUAL' \
       AND (    sender IS NULL \
         OR sender = '${quote_mysql:@$sender_address_domain}' \
           ) \
        ) \
      ) \
   AND (recipient   = '${quote_mysql:$local_part@$domain}' \
     OR (type = 'MANUAL' \
       AND (    recipient IS NULL \
         OR recipient = '${quote_mysql:$local_part@}' \
          OR recipient = '${quote_mysql:@$domain}' \
            ) \
         ) \
       ) \
   AND (relay_ip    = '${quote_mysql:$sender_host_address}' \
     OR (type='MANUAL' \
       AND (    relay_ip IS NULL \
         OR relay_ip = \
         substring('${quote_mysql:$sender_host_address}',1,length(relay_ip)) \
           ) \
         ) \
      ) \
 ORDER BY result DESC LIMIT 1

GREYLIST_ADD = INSERT INTO GREYLIST_TABLE \
  (relay_ip, sender, recipient, block_expires, \
   record_expires, create_time, type) \
 VALUES ( '${quote_mysql:$sender_host_address}', \
  '${quote_mysql:$sender_address}', \
  '${quote_mysql:$local_part@$domain}', \
  DATE_ADD(now(), INTERVAL GREYLIST_INITIAL_DELAY), \
  DATE_ADD(now(), INTERVAL GREYLIST_INITIAL_LIFETIME), \
  now(), \
  'AUTO' \
)

GREYLIST_DEFER_HIT = UPDATE GREYLIST_TABLE \
                     SET blockcount=blockcount+1 \
                     WHERE id = $acl_m9

GREYLIST_OK_COUNT = UPDATE GREYLIST_TABLE \
                    SET passcount=passcount+1 \
                    WHERE id = $acl_m9

GREYLIST_OK_NEWTIME = UPDATE GREYLIST_TABLE \
                      SET record_expires = DATE_ADD(now(), \
                      INTERVAL GREYLIST_WHITE_LIFETIME) \
                      WHERE id = $acl_m9 AND type='AUTO'

GREYLIST_OK_BOUNCE = UPDATE GREYLIST_TABLE \
                     SET record_expires = DATE_ADD(now(), \
                     INTERVAL GREYLIST_BOUNCE_LIFETIME) \
                     WHERE id = $acl_m9 AND type='AUTO'

GREYLIST_LOG = INSERT INTO GREYLIST_LOG_TABLE \
               (listid, timestamp, kind) \
               VALUES ($acl_m9, now(), '$acl_m8')
.endif
</screen>
      </para><para>
Artık, ACL bölümünde (<option>begin acl</option> satırından sonra) <quote>greylist_acl</quote> ismiyle yeni bir ACL tanımlayabiliriz:
      </para><para>
<screen>
.ifdef GREYLIST_ENABLED
# Bu acl ya deny ya da accept döndürecek.
# acl = greylist_acl'yi ber deger ile kullandığımızdan,
# bir accept, kuralı DOĞRU yapacak, dolayısıyla bir erteleme olacak;
# bir deny ise kuralı YANLIŞ yapacak, dolayısıyla erteleme olmayacak.
greylist_acl:
  # Normal teslimatlar için griliste sınanacak.

  # Griliste sınanıp, acl_m8'e "accepted", "deferred" veya "unknown"
  # ve acl_m9'a kayıt numarası döndürülecek.

  warn set acl_m8 = ${lookup mysql{GREYLIST_TEST}{$value}{result=unknown}}
       # Burada acl_m8 = "result=x id=y"

       set acl_m9 = ${extract{id}{$acl_m8}{$value}{-1}}
       # Artık acl_m9 kayıt numarasını (veya -1) içerecek.

       set acl_m8 = ${extract{result}{$acl_m8}{$value}{unknown}}
       # acl_m8 unknown/deferred/accepted içerecek.

  # Bu üçlüyü bilmiyorsak, ileti ekleyeceğiz yoksa erteleyeceğiz
  accept
       # yukarıdaki sınama unknown (henüz kayıt yok) döndürmüşse
       condition = ${if eq{$acl_m8}{unknown}{1}}
       # ayrıca bir kayıt ekleyeceğiz
       condition = ${lookup mysql{GREYLIST_ADD}{yes}{no}}

  # Şimdi günlük kaydı yapacağız, sonucun önemi yok.
  # Üçlüyü bilmiyorsak bir günlük girdisine gerek yok çünkü
  # yukarıda oluşturma sırasında dolaylı olarak yapıldı.
  #
  .ifdef GREYLIST_LOG_ENABLED
  warn condition = ${lookup mysql{GREYLIST_LOG}}
  .endif

  # Üçlü hala engelleniyor mu bakalım
  accept
       # Yukarıdaki sınama deferred döndünmüşse ertele
       condition = ${if eq{$acl_m8}{deferred}{1}}
       # ve kayda geçir
       condition = ${lookup mysql{GREYLIST_DEFER_HIT}{yes}{yes}}

  # Bakılan kayıtları saymak için bir warn deyimi kullanıyoruz.
  warn condition = ${lookup mysql{GREYLIST_OK_COUNT}}

  # Özdevinimli kayıtlarda zaman aşımını belirlemek için bir
  # warn deyimi kullanıyoruz. Ancak, posta boş göndericili değilse
  # zamanaşımı uygulanacak, aksi takdirde zamanaşımı uygulanmayacak.
  #
  warn !senders = : postmaster@*
       condition = ${lookup mysql{GREYLIST_OK_NEWTIME}}
  warn senders = : postmaster@*
       condition = ${lookup mysql{GREYLIST_OK_BOUNCE}}

  deny
.endif
</screen>
      </para><para>
Gönderici adresi boş olmayan üçlüleri grilistelemek için bu ACL'yi <xref linkend="spam-filtering-acl_rcpt_to_final"/> ACL'nize yerleştirin. Böylece, gönderici varlık doğrulaması yapmanız mümkün olacak:
      </para><para>
<screen>
.ifdef GREYLIST_ENABLED
  defer !senders = : postmaster@*
        acl      = greylist_acl
        message  = greylisted - try again later
.endif
</screen>
      </para><para>
Onu ayrıca <xref linkend="spam-filtering-acl_data_1"/>'e de yerleştirin, fakat sadece gönderici adresinin boş olduğunu tespit ettikten sonraya. Bu, spamcıların grilistelemeyi gönderici adresini boş bırakarak aşmaya çalışmalarını önlemek içindir.
      </para><para>
<screen>
.ifdef GREYLIST_ENABLED
  defer senders  = : postmaster@*
        acl      = greylist_acl
        message  = greylisted - try again later
.endif
</screen>
      </para>
    </sect2>
  </sect1>

  <sect1 id="spam-filtering-exim-spf">
    <title>SPF Sınamalarının Eklenmesi</title><para>
Burada Exim kullanarak <xref linkend="spam-filtering-spf"/> kayıtlarını sınamak için iki yöntemden bahsedeceğiz. Bu doğrudan sınama mekanizmalarından başka, yakın bir gelecekte SpamAssassin (2.70 sürümünde sanırım) çeşitli SPF sınamalarına derecelendirme uygulayan, biraz daha ince eleyip sık dokuyan SPF sınamaları ile gelecek.
    </para><para>
Bu sınamayı en erken <xref linkend="spam-filtering-acl_mail_from_final"/> ACL'sinde yapabiliriz. Bu kararı almamızı sağlayan etken: SPF geleneksel eposta yönlendirmesi ile uyumlu değildir. Yönlendiren konak <ulink url="http://www.openspf.org/srs.html">SRS</ulink> uygulamıyorsa, yönlendirilen postayı reddetmek kaçınılmaz olur, çünkü postanın <xref linkend="spam-filtering-envfrom"/> adresindeki alanadının DNS kayıtlarındaki SPF kaydı böyle bir konağı posta göndermeye yetkili konaklardan biri olarak içermeyecektir.
    </para><para>
Bunu yapmaktan kaçınmak için, kabul edilmesi gereken yönlendirilmiş postaları gönderen konakların kullanıcı tarafından belirlendiği listelere bakmamız gerekir (bu durum, <xref linkend="spam-filtering-exim-forward"/> bölümünde açıklanmıştır). Bu da sadece alıcının kullanıcı adını bilebileceğimiz <command>RCPT TO:</command> komutundan sonra mümkün olur.
    </para><para>
Böyle bir durumda, bu sınamayı <xref linkend="spam-filtering-acl_rcpt_to_final"/> içinde sonuncu <option>accept</option> deyiminden önce ve/veya varsa grilisteleme sınamasından önceye ekleyeceğiz.
    </para>

    <sect2 chunkthis="1" id="spam-filtering-exim-spf-exiscan">
      <title>Exiscan-ACL üzerinden SPF sınamaları</title><para>
Tom Kistner'in <option>Exiscan-ACL</option> yamasının son sürümü (bkz. <xref linkend="spam-filtering-exim-prereq"/>) SPF için destek içermektedir<footnote><para>
Debian Kullanıcılarının dikkatine: 14 Temmuz 2004 itibariyle Exiscan-ACL'nin SPF desteği içeren sürümü <option>exim4-daemon-heavy</option> paketine dahil edilmemişti. (Ç.N.: Bu çeviri yapılırken Debian'ın kararlı dağıtımıyla gelen <option>exim4-daemon-heavy</option> paketi hala bu desteği içermiyordu - Aralık 2005. Ancak diğer Debian dağıtımlarında bu destek var.) Şimdilik, başka bir SPF gerçeklenimi kurabilirsiniz:
  </para><para>
<screen>
# <command>apt-get install libmail-spf-query-perl</command>
</screen>
</para></footnote>. Kullanımı çok basittir. Bir <option>spf</option> ACL kuralı eklenir ve <option>pass</option>, <option>fail</option>,  <option>softfail</option>, <option>none</option>, <option>neutral</option>, <option>err_perm</option> veya <option>err_temp</option> anahtar sözcükleriyle karşılaştırma yapılır.
      </para><para>
<xref linkend="spam-filtering-acl_rcpt_to_final"/> ACL'sine grilisteleme sınamalarının ve/veya sonuncu <option>accept</option> deyiminin öncesine aşağıdaki satırları yerleştirin:
      </para><para>
<screen>
  # Gönderici adresinin alanadı için varsa, SPF kayıtlarını sorgulayalım.
  # Gönderici konak bu alanadı için yetkilendirilmişse teslimatı kabul
  # yoksa red edeceğiz.
  #
  deny
    message     = [SPF] $sender_host_address is not allowed to send mail \
                  from $sender_address_domain
    log_message = SPF check failed.
    spf         = fail


  # İleti başlığına bir SPF-Received: satırı ekleyelim.
  warn
    message     = $spf_received
</screen>
      </para><para>
Bu deyim, eğer gönderici adresinin alanadının sahibi, postayı teslim etmeye çalışan konağı teslimat için yetkilendirmemişse postayı reddedecektir. Bazılarına göre alan adı sahibi için bu kadar kontrol yetkisi fazladır, hatta bu yetkiyle istem dışı olarak rahatça kendilerini sabote edebilirler.  SPF sınamalarını başka sınamalarla birleştirmek de önerilmektedir. Örneğin, Gönderici Varlık Sınamaları ile birlikte (fakat eğer posta sunucunuz göstermelik sunucu ise - yani, postaları bir dış sunucu üzerinden gönderiyorsa - bunu yapamazsınız).
      </para><para>
<screen>
  # Gönderici adresini varlık doğrulamaları ile doğrulatamazsak ve
  # gönderici adresin alanadı sahibi SPF kaydıyla teslimatı yapmaya
  # çalışan konağı yetkilendirmemişse postayı reddedeceğiz.
  #
  deny
    message     = The sender address does not seem to be valid, and SPF \
                  information does not grant $sender_host_address explicit \
                  authority to send mail from $sender_address_domain
    log_message = SPF check failed.
    !verify     = sender/callout,random,postmaster
    !spf        = pass


  # İleti başlığına bir SPF-Received: satırı ekleyelim.
  warn
    message     = $spf_received
</screen>
      </para>
    </sect2>

    <sect2 chunkthis="1" id="spam-filtering-exim-spf-query-perl">
      <title>Mail::SPF::Query üzerinden SPF sınamaları</title><para>
<option>Mail::SPF::Query</option> bir resmi SPF deneme paketidir ve <ulink url="http://www.openspf.org/downloads.html"/> adresinden edinilebilir.  Debian kullanıcıları,
  </para><para>
<screen>
# <command>apt-get install libmail-spf-query-perl</command>
</screen>
   </para><para>
ile kolayca kurabilir.
      </para><para>
<option>Mail::SPF::Query</option> paketi gelen istekleri bir UNIX soketinden dinleyen bir artalan süreci (<command>spfd</command>) ile gelir. Ama, bu artalan sürecini başlatmak için bir başlatma betiği ile gelmez. Bu bakımdan, aşağıdaki örnekte, bizim SPF isteklerimiz için anlık bir uygulama olarak çalıştırılan <command>spfquery</command> aracını kullanacağız.
      </para><para>
Aşağıdaki satırları <xref linkend="spam-filtering-acl_rcpt_to_1"/> içinde, yukarıdaki gibi sonuncu <option>accept</option> deyiminden önce ve/veya varsa grilisteleme sınamasından önceye yerleştirin:
      </para><para>
<screen>
  # Bu gönderici/konak için SPF durumunu öğrenmek için "spfquery"
  # kullanacağız. Eğer komuttan dönen kod 1 ise bu bir yetkisiz
  # göndericidir.
  #
  deny
    message     = [SPF] $sender_host_address is not allowed to send mail \
                  from $sender_address_domain.
    log_message = SPF check failed.
    set acl_m9  = -ipv4=$sender_host_address \
                  -sender=$sender_address \
                  -helo=$sender_helo_name
    set acl_m9  = ${run{/usr/bin/spfquery $acl_m9}}
    condition   = ${if eq {$runrc}{1}{true}{false}}
</screen>
      </para>
    </sect2>
  </sect1>

  <sect1 id="spam-filtering-exim-mime">
    <title>MIME ve Dosya türü Sınamalarının Eklenmesi</title><para>
Bu sınamalar Tom Kistner'in <option>Exiscan-ACL</option> yamasındaki özelliklere bağımlıdır - ayrıntılar için <xref linkend="spam-filtering-exim-prereq"/> bölümüne bakınız.
    </para><para>
Exiscan-ACL yaması MIME kodlamasının ve dosya ismi soneklerinin (Windows'çası uzantılarının) sınamalarını içerir. Bu sınamalar tek başlarına çoğu Windows virüsünü engelleyecektir - ama bunlar <option>.ZIP</option> arşivleri olarak geliyorsa ya da ileti içeriği zarar verici Outlook/MSIE HTML kodları içeriyorsa bunları engelleyemez - bkz. <xref linkend="spam-filtering-virusscanners"/>.
    </para><para>
Bu sınamalar <xref linkend="spam-filtering-acl_data_1"/> içindeki sonuncu <option>accept</option> deyiminin öncesine yerleştirilmelidir:
    </para><para>
<screen>
  # Birtakım MIME hataları olan iletileri reddedeceğiz.
  #
  deny
    message     = Serious MIME defect detected ($demime_reason)
    demime      = *
    condition   = ${if &gt;{$demime_errorlevel}{2}{1}{0}}


  # MIME taşıyıcıyı aç ve kurtlar tarafından kullanılan dosya uzantıları
  # varsa reddet. Bu çağrılar tekrar demime uygulayacaktır, ama sonuçlar
  # arabellekli olarak dönecektir.
  # Uzantı listesinin eksik olabileceğini unutmayın.
  #
  deny
    message     = We do not accept ".$found_extension" attachments here.
    demime      = bat:btm:cmd:com:cpl:dll:exe:lnk:msi:pif:prf:reg:scr:vbs:url
</screen>
    </para><para>
Yukarıdaki örnekte, <option>demime</option> koşulunun iki defa çağrıldığına dikkat edin. Bununla birlikte, sonuçlar arabelleğe alındığından ileti aslında iki defa baştan değerlendirilmeyecektir.
    </para>
  </sect1>

  <sect1 id="spam-filtering-exim-av">
    <title>AntiVirüs Yazılımlarının Eklenmesi</title><para>
Exiscan-ACL yaması bazı virüs tarayıcılarının doğrudan eklemlenebilmesine, bir kısmının da <option>cmdline</option> arkayüzü vasıtasıyla komut satırından çalıştırılmasına imkan tanır.
    </para><para>
Bu özelliği kullanabilmek için Exim yapılandırma dosyanızın <link linkend="spam-filtering-exim-options">ana bölümünde</link> hangi virüs tarayıcısını kullanacağınızı, tarayıcıya aktarılacak seçeneklerle birlikte belirtmelisiniz. Bununla ilgili sözdizimi şöyledir:
    </para><para>
<literallayout>
    av_scanner = <emphasis>tarayıcı-türü</emphasis>:<emphasis>seçenek1</emphasis>:<emphasis>seçenek</emphasis>:...
</literallayout>
    </para><para>
Örneğin:
    </para><para>
<screen>
av_scanner = sophie:/var/run/sophie
av_scanner = kavdaemon:/opt/AVP/AvpCtl
av_scanner = clamd:127.0.0.1 1234
av_scanner = clamd:/opt/clamd/socket
av_scanner = cmdline:/path/to/sweep -all -rec -archive %s:found:'(.+)'
...
</screen>
    </para><para>
DATA ACL'de asıl taramayı gerçekleştirmek için <option>malware</option> koşulunu kullanabilirsiniz:
    </para><para>
<screen>
  deny
    message  = This message contains a virus ($malware_name)
    demime   = *
    malware  = */defer_ok
</screen>
    </para><para>
Paketle gelen <option>exiscan-acl-spec.txt</option> dosyasında ayrıntılı kullanım bilgilerini bulabilirsiniz.
    </para>
  </sect1>

  <sect1 id="spam-filtering-exim-sa">
    <title>SpamAssassin'in Eklenmesi</title><para>
SMTP sırasında SpamAssassin çağrısı Exim'de genelde şu iki yoldan biri ile yapılır:
    </para><para>
    <itemizedlist>
      <listitem><para>
<option>Exiscan-ACL</option> yamasının içerdiği <option>spam</option> kuralı üzerinden. Bu, bizim burada kullanacağımız mekanizma olacak.
      </para></listitem>
      <listitem><para>
<option>SA-Exim</option> üzerinden. Marc Merlins <email>marc (at) merlins.org</email> tarafından özellikle Exim'in SMTP sırasında SpamAssassin'i çalıştırması için yazılmıştır. Bu uygulama Exim'in <option>local_scan()</option> arayüzünden işlem yapar. Ya doğrudan Exim'e bir yama olarak uygulanarak ya da  Marc'ın kendi <option>dlopen()</option> eklentisi üzerinden (Debian'ın <option>exim4-daemon-light</option> ve <option>exim4-daemon-heavy</option> paketleri ikinci yolu kullanır).
        </para><para>
<option>SA-Exim</option> başka özellikler de içerir: <emphasis>grilisteleme</emphasis> ve <emphasis>katran çukuru</emphasis>. Bununla birlikte, tarama işlemi ileti verisi alındıktan sonra yapıldığından, bu iki özelliğin  yararlı olabilmeleri için SMTP aktarımının başlarında uygulanmaları gerektiğinden, faydalı olmayabilir.
        </para><para>
<option>SA-Exim</option> <ulink url="http://marc.merlins.org/linux/exim/sa.html"/> adresinden edinilebilir.
      </para></listitem>
    </itemizedlist>
    </para>

    <sect2 chunkthis="1" id="spam-filtering-exim-sa-exiscan">
      <title>SpamAssassin'in Exiscan üzerinden çağrılması</title><para>
<option>Exiscan-ACL</option>'nin  <quote><option>spam</option></quote> kuralı hem SpamAssassin hem de Brightmail'i kullanabilir ve ileti bir döküntüyse bu kural bunu belirtecek şekilde tetiklenir. Exim öntanımlı olarak, <option>localhost</option> üzerinde çalışan bir SpamAssassin artalan sürecine (<option>spamd</option>) bağlanır. Ancak konak adresi ve port, Exim yapılandırma dosyasının <emphasis>ana</emphasis> bölümüne bir <option>spamd_address</option> ataması ile belirtilerek başka bir konaktaki SpamAssassin'in kullanılması sağlanabilir. Daha ayrıntılı bilgi için bu yamayla birlikte gelen <option>exiscan-acl-spect.txt</option> dosyasına bakınız.
      </para><para>
Bizim gerçeklenimimizde, spam olarak tasnif edilmiş iletileri reddedeceğiz. Bununla birlikte, bu tür iletilerin bir kopyasını, kullanıcı arasıra <xref linkend="spam-filtering-falsepos"/>lar için bu dizini tarayabilsin diye, bir süreliğine ayrı bir posta dizininde tutacağız.
      </para><para>
Exim, kabul edilen bir iletiye <option>freeze</option> adı verilen bazı denetimler uygulayabilir. Exiscan-ACL yaması bu denetimlere, <option>fakereject</option> ismiyle başka denetimler ekler. Bu şöyle bir SMTP yanıtına sebep olur:
      </para><para>
<screen>
550-FAKEREJECT id=<emphasis>ileti-kimliği</emphasis>
550-İletiniz reddedildi ancak değerlendirilmek üzere tutuluyor.
550 Eğer meşru bir iletiyse, hala alıcılarına teslim edilebilir.
</screen>
      </para><para>
Bu özelliği kendi gerçeklenimimize aşağıdaki satırları <xref linkend="spam-filtering-acl_data_1"/> içinde sonuncu <option>accept</option> deyiminden önceye yerleştirerek kullanacağız:
      </para><para>
<screen>
  # $spam_score ve $spam_report'a veri sağlamak için SpamAssassin'i
  # çağıracağız. Tasnife bağlı olarak, $acl_m9 "ham" veya "spam"
  # değerini alacak.
  #
  # İleti spam olarak tasnif edilmişse, reddetmiş gibi yapacağız.
  #
  warn
    set acl_m9  = ham
    spam        = mail
    set acl_m9  = spam
    control     = fakereject
    logwrite    = :reject: Rejected spam (score $spam_score): $spam_report

  # İletinin başlığına bir X-Spam-Status: satırı ekleyelim.
  #
  warn
    message     = X-Spam-Status: \
                  ${if eq {$acl_m9}{spam}{Yes}{No}} (score $spam_score)\
                  ${if def:spam_report {: $spam_report}}
    logwrite    = :main: Classified as $acl_m9 (score $spam_score)

</screen>
      </para><para>
Bu örnekte, <literal>$acl_m9</literal> değişkeni <quote>ham</quote> değeriyle ilklendirildi. SpamAssassin <option>mail</option> kullanıcısı olarak çağrıldı. Eğer ileti spam olarak tasnif edilmişse, <literal>$acl_m9</literal>'a <quote>spam</quote> değeri atanıp, yukarıdaki <option>FAKEREJECT</option> yanıtı verildi. Bunu yapmada ana fikir, <xref linkend="spam-filtering-mda"/>nın veya alıcının <xref linkend="spam-filtering-mua"/>nin bu başlığı kullanarak döküntü postayı ayrı bir dizinde toplayabilmesine imkan sağlamaktır.
      </para>
    </sect2>

    <sect2 chunkthis="1" id="spam-filtering-exim-sa-config">
      <title>SpamAssassin yapılandırması</title><para>
Öntanımlı olarak, SpamAssassin raporunu ayrıntılı olarak tablo benzeri bir biçimde ya ileti gövdesine yazar ya da bir eklenti olarak iletiye ekler. Biz ise, yukarıdaki örnekte olduğu gibi <option>X-Spam-Status:</option> başlığına uygun kısa ve özlü bir rapor istiyoruz. Bunun olması için, aşağıdaki satırları SpamAssassin'in yapılandırma dosyasına ekleyeceğiz (<option>/etc/spamassassin/local.cf</option>, <option>/etc/mail/spamassassin/local.cf</option>, vb.):
      </para><para>
<screen>
### Rapor şablonu
clear_report_template
report "_TESTSSCORES(, )_"
</screen>
      </para><para>
Ayrıca, bir <link linkend="spam-filtering-bayesian">Bayes</link> derecelendirme özelliği yerleşik olarak vardır ve öntanımlı olarak etkindir. Bunu normal olarak biz kapatacağız, çünkü kullanıcıya özel eğitilmesi gerekir, dolayısıyla SMTP sırasındaki filtreleme için kullanıma uygun değildir:
      </para><para>
<screen>
### Bayes derecelendirmesi kapalı
use_bayes 0
</screen>
      </para><para>
Bu değişikliklerin etkin olabilmesi için SpamAssassin artalan süreci olan <command>spamd</command>'yi yeniden başlatmalıyız.
      </para>
    </sect2>

    <sect2 chunkthis="1" id="spam-filtering-exim-per-user">
      <title>Kullanıcı verileri ve ayarları</title><para>
Kullanıcılarınızın bazıları kişisel SpamAssassin tercihlerini belirtebilmek isteyebilirler; örneğin, spam eşiği, posta kabul ettikleri diller ve karakter kümeleri, kara ve ak listeli kullanıcılar, vs. Hatta, SpamAssassin'in yerleşik Bayes derecelendirmesini kullanmanın bile mümkün olmasını isteyebilirler (bunun anlamlı olacağını düşünmesem de<footnote><para>
Her ne kadar Bayes eğiticisi işleyiş olarak kullanıcıya özel ise de SpamAssassin'in Bayes eğiticisi naçizane fikrime göre herhalükarda o kadar da parlak değildir. Örnek olarak spam göndericiler sözlükten rasgele seçilmiş kelimeler ve öykülerle bu tür sistemleri tohumlayarak alt edebilmektedir.</para></footnote>).
      </para><para>
Bu belgede evvelce <xref linkend="spam-filtering-usersettings"/> bölümünde açıklandığı gibi, bunu yapmanın bir yolu vardır.  Gelen her teslimattaki alıcı sayısını bir ile sınırlandırmamız gerekir. İlk <command>RCPT TO:</command> komutunu kabul ettikten sonra diğerlerini bir <command>451</command> SMTP yanıtı ile erteleriz. <xref linkend="spam-filtering-exim-greylisting"/>nde olduğu gibi, eğer bağlanan posta aktarımcısı işini iyi bilen bir yazılımsa, bu yanıtın nasıl yorumlanacağını bilecek ve teslimatı yineleyecektir.
      </para>

      <sect3 id="spam-filtering-exim-limit-one-user">
        <title>Exim'e "her teslimatı sadece bir alıcı için kabul et" demek istersek</title><para>
<xref linkend="spam-filtering-acl_rcpt_to_final"/> ACL'sinde, alıcı adresi doğrulandıktan sonra ve uzak konaklardan yerel kullanıcılara kimlik kanıtlamasız gelen bağlantılar için bir <option>accept</option> deyiminin öncesine (yani, grilistelemeyi ve zarf gönderici imlerini sınamadan önceye) aşağıdaki deyimi yerleştireceğiz:
      </para><para>
<screen>
  # Kullanıcı verilerini ve ayarlarını (Spamassasin gibi) destekleyebilmek
  # için gelen her iletinin alıcı sayısını bir ile sınırlayalım.
  #
  # BİLGİ: Çok sayıda kullanıcınıza gönderilmiş bir postanın yerine
  #        ulaşması her alıcı için 30 dakika veya daha fazla olmak
  #        üzere katlanarak gecikecektir. Bu, özellikle zamanın kritik
  #        önemde olduğu durumlarda sorunlara yol açacaktır.
  #
  defer
    message      = We only accept one recipient at a time - please try later.
    condition    = $recipients_count

</screen>
        </para>
      </sect3>

      <sect3 id="spam-filtering-exim-sa-as-user">
        <title>SpamAssassin'e alıcının kullanıcı isminin aktarılması</title><para>
<xref linkend="spam-filtering-acl_data_final"/> ACL'sinde, evvelce bahsettiğimiz <option>spam</option> kuralını değiştirerek, alıcı adresindeki yerel kısımda belirtilmiş kullanıcı ismini SpamAssassin'e aktaracağız.
      </para><para>
<screen>
  # $spam_score ve $spam_report'a veri sağlamak için SpamAssassin'i
  # çağıracağız. Tasnife bağlı olarak, $acl_m9 "ham" veya "spam"
  # değerini alacak.
  #
  # Alıcı adresinin kullanıcı adını SpamAssassin'e aktaralım.
  # Bunun için adresin '=' veya '@' karakterinden önceki kısmını
  # küçük harfe dönüştüreceğiz. Evvelce bir defadaki alıcı sayısını
  # önceden bir ile sınırladığımızdan çok sayıda alıcı olmayacak.
  #
  # İleti spam olarak tasnif edilmişse, reddetmiş gibi yapacağız.
  #
  warn
    set acl_m9  = ham
    spam        = ${lc:${extract{1}{=@}{$recipients}{$value}{mail}}}
    set acl_m9  = spam
    control     = fakereject
    logwrite    = :reject: Rejected spam (score $spam_score): $spam_report

</screen>
        </para><para>
Dikkat ederseniz, Exim'in <option>${local_part:...}</option> işlevini kullanmak yerine <quote>@</quote> veya <quote>=</quote> karakterinden önceki kısmı kendimiz ayırdık. Bunun sebebi, ileride <link linkend="spam-filtering-exim-sign">zarf gönderici imlemesi</link> için <quote>=</quote> karakterini kullanacak olmamızdır.
        </para>
      </sect3>

      <sect3 id="spam-filtering-exim-per-user-sa">
        <title>SpamAssassin'de kullanıcı verilerinin ve ayarlarının etkinleştirilmesi</title><para>
SpamAssassin'e tekrar bakalım. Herşeyden önce, yapılandırma dosyasına evvelce yerleştirdiğimiz <option>use_bayes 0</option> atamasını silebilirsiniz. Bu durumda, her kullanıcı kendi ayarlarını belirtebilme ayrıcalığına kavuşacaktır.
        </para><para>
Eğer sisteminizdeki posta kutularının isimleri yerel UNIX hesaplarına göre açılmışsa bu mümkün olur. Öntanımlı olarak SpamAssassin artalan süreci, kendisine aktarılan kullanıcı ismine önce bir <option>setuid()</option> uygular ve kullanıcının verilerini ve ayarlarını kullanıcının ev dizinine kaydeder.
        </para><para>
Eğer yapınız bu işleme uygun değilse (örneğin, posta hesaplarınız Cyrus SASL veya başka bir sunucu tarafından yönetiliyordur), SpamAssassin'e kullanıcı tercihlerini ve verilerini içeren dosyaları nerede bulacağını belirtmeniz gerekir. Ayrıca, <command>spamd</command>'nin mevcut olmayan bir kullanıcıya <option>setuid()</option> yapmasını önlemek için onun belli bir yerel kullanıcı adıyla çalışmasını sağlamanız gerekir.
        </para><para>
Biz bu seçenekleri <command>spamd</command>'yi başlatırken belirteceğiz:
        </para><para>
        <itemizedlist>
          <listitem><para>
Debian'da <option>/etc/default/spamassassin</option> dosyasının <option>OPTIONS=</option> satırını düzenleyerek.
            </para></listitem>
            <listitem><para>
Red Hat'ta <option>/etc/sysconfig/spamassassin</option> dosyasının <option>SPAMDOPTIONS=</option> satırını düzenleyerek.
      </para></listitem>
      <listitem><para>
Diğerlerini siz bulun.
          </para></listitem>
        </itemizedlist>
        </para><para>
Gereken seçenekler:
        </para><para>
        <itemizedlist>
          <listitem><para>
<option>-u</option> <parameter>kullanıcı</parameter> - <command>spamd</command>'nin hangi kullanıcının (örn. <option>mail</option>) aidiyetinde çalışacağı belirtilir.
      </para></listitem>
      <listitem><para>
<option>-x</option> - kullanıcıların ev dizinlerindeki yapılandırma dosyalarına bakılmaz.
      </para></listitem>
      <listitem><para>
<option>--virtual-config-dir=/var/lib/spamassassin/%u</option> - kullanıcı verilerinin ve ayarlarının yeri belirtilir. <quote>%u</quote> SpamAssassin tarafından kullanıcı ismi ile değiştirilerek kullanılır. <command>spamd</command> bu dizini oluşturmaya veya bu dizinde değişiklik yapmaya yetkili olmalıdır:
          </para><para>
<screen>
# <command>mkdir /var/lib/spamassassin</command>
# <command>chown -R mail:mail /var/lib/spamassassin</command>
</screen>
          </para></listitem>
        </itemizedlist>
        </para><para>
Bu kadar, bu değişiklikleri yaptıktan sonra <command>spamd</command>'yi yeniden başlatmanız yetecektir.
        </para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="spam-filtering-exim-sign">
    <title>Zarf Gönderici İmlerinin Eklenmesi</title><para>
Burada, giden posta için <xref linkend="spam-filtering-signedsender"/> uygulayacak ve zarf göndericisi boş olarak gelen postalarda bu imlerin varlığına bakacağız.
    </para><para>
Makinemizden giden postaların zarf göndericisi adresini şu şekilde değiştireceğiz:
    </para><para>
<literallayout>
    <emphasis>gönderici</emphasis>=<emphasis>alıcı</emphasis>=<emphasis>alıcı.alanadı</emphasis>=<emphasis>birdeğer</emphasis>@<emphasis>gönderici.alanadı</emphasis>
</literallayout>
    </para><para>
Ancak, bu şema istenmeyen sonuçlar doğuracağından (posta listelerinin sunucularından gelen postalar gibi), bu şemanın kullanımını kullanıcıların tercihine bırakacağız. Eğer kullanıcının ev dizininde <quote>.return-path-sign</quote> isminde bir dosya varsa, giden postanın zarf göndericisini imlemeyi sadece bu kullanıcılar için ve sadece bu dosyada belirtilen alan adları için yapacağız. Bu dosyanın içi boş bırakılmışsa, tüm alan adları için bu sınamanın yapılacağını anlayacağız.
    </para><para>
Bu yolla, sadece zarf gönderici adresi boş bırakılmış olarak gelen postalardan, sadece ev dizininde böyle bir dosya bulunan kullanıcılara gelenlerde alıcı adresi imlemesinin varlığına bakacağız. Kullanıcılar bazı konakları <xref linkend="spam-filtering-exim-forward"/> bölümünde açıklandığı gibi kullanıcıya özel aklistelere kaydederek bu sınamaların dışında bırakabilirler.
    </para><para>
Bu şema, Exim'in yapılandırma dosyasındaki ACL'lerden başka yönlendiriciler ve aktarıcılar bölümlerinde de değişiklik yapmayı gerektirdiğinden bu sınamayı <xref linkend="spam-filtering-exim-final"/>e doğrudan dahil etmeyeceğiz. Bu bölümdeki açıklamaları okuyarak isterseniz, burada açıklanan ACL bölümünü kendiniz ekleyebilirsiniz.
    </para>

    <sect2 chunkthis="1" id="spam-filtering-exim-sign-transport">
      <title>Gönderici adresini imlemek için bir Transport oluşturmak</title><para>
Önce giden postalarda kullanmak üzere gönderici adresini imleyen bir Exim <emphasis>transport</emphasis>' u oluşturacağız.
      </para><para>
<screen>
remote_smtp_signed:
  debug_print    = "T: remote_smtp_signed for $local_part@$domain"
  driver         = smtp
  max_rcpt       = 1
  return_path    = $sender_address_local_part=$local_part=$domain=\
                   ${hash_8:${hmac{md5}{SECRET}{${lc:\
                     $sender_address_local_part=$local_part=$domain}}}}\
                   @$sender_address_domain
</screen>
      </para><para>
Bu deyime göre, gönderici adresinin <quote>yerel kısmı</quote> birbirlerinden eşit işaretleri ile ayrılmış şu parçalardan oluşacak:
      </para><para>
      <itemizedlist><listitem>
Göndericinin kullanıcı ismi, yani adresin yerel kısmı,
        </listitem><listitem>
alıcı adresinin yerel kısmı,
        </listitem><listitem>
alıcı adresinin alanadı kısmı,
        </listitem><listitem><para>
Gönderici/alıcı/sunucu üçlüsüne özel bir dizge. Şöyle üretilir:
          </para><para>
          <itemizedlist><listitem><para>
Gönderici adresinin yeniden yazilan ilk üç elemanı ile yapılandırma dosyasının <link linkend="spam-filtering-exim-options">ana bölümünde tanımladığımız <option>SECRET</option> dizgesi</link> Exim'in <option>${hmac{md5}...}</option> işlevi ile şifrelenir<footnote><para>
Eğer bu işlemin bu derece karmaşık olması gerekmediğini düşünüyorsanız, çok yüzeysel bakıyorsunuz demektir. Bu belgenin eski sürümlerinde imin son elemanını üretmek için basitçe <option>${hash_8:SECRET=....}</option> kullanmıştım. Ancak, Exim'in <option>${hash...}</option> işlevini biraz kavrayınca ve farklı alıcılara gönderilen örnekleri biraz inceleyince, teknik olarak imlemenin taklit edilmesinin mümkün olacağını görürsünüz. Matthew Byng-Maddic <email>mbm@colondot.net</email> bu konuda şöyle diyor:
  </para><para><blockquote><para>
Normal şartlar altında ürettiğiniz belgeyi çok sayıda insan kullansın diye hazırlarsınız. Ama aynı zamanda Kirşof kanunu da işlemeye başlar, tüm gizliliği sağlayan şey kullandığınız anahtardır. Spam göndericileri için bir kaç tane geri dönüş yolunu kullanarak bu anahtarı geri kazanmak imkansız değildir ve bir kez bunu yaptıklarında aynı alan adından tekrar geçerli geri dönüş yolu içeren spam iletilerini yaymaya başlarlar, siz de başladığınız yere geri dönmüş olursunuz. [...] Bana göre daha iyisi, işi baştan sıkı tutmaktır.
  </para></blockquote></para></footnote>.
            </para></listitem>
            <listitem><para>
Sonuç, 8 küçük harf üretecek şekilde Exim'in <option>${hash...}</option> işlevi ile çırpılanır.
            </para></listitem>
          </itemizedlist>
        </para></listitem>
      </itemizedlist>
      </para><para>
Eğer sunucunuz, başka bir göstermelik konağın kimlik kanıtlamalı olarak postalarını gönderiyorsa, uygun bir <option>hosts_try_auth</option> satırını da buraya ekleyin. (Onu mevcut <quote>smarthost transport</quote>'undan alabilirsiniz.)
      </para>
    </sect2>

    <sect2 chunkthis="1" id="spam-filtering-exim-sign-router-remote">
      <title>Giden teslimatlar için yeni bir yönlendirici oluşturmak</title><para>
Giden postalarınızı işleme sokmakta olan mevcut yönlendiricilerinizin (<emphasis>router</emphasis>) önüne yeni bir yönlendirici ekleyeceğiz. Bu yönlendirici uzak teslimatlar için yukarıdaki aktarımı (<emphasis>transport</emphasis>) kullanacak, fakat sadece kullanıcının ev dizininde bir <quote>.return-path-sign</quote> dosyası varsa ve alıcının alanadı bu dosyada mevcutsa. Örneğin, postanızı doğrudan internet üzerinden son hedefine gönderiyorsanız:
      </para><para>
<screen>
# Kullanıcının ev dizininde bir <quote>.return-path-sign</quote> dosyası
# varsa ve alıcının alanadı bu dosyada mevcutsa, uzak konaklara posta
# teslimatı yaparken zarf göndericisi adresini imleyeceğiz. Eğer dosya
# var ama içi boşsa, zarf göndericisi adresini daima imleyeceğiz.
#
dnslookup_signed:
  debug_print   = "R: dnslookup_signed for $local_part@$domain"
  driver        = dnslookup
  transport     = remote_smtp_signed
  senders       = ! : *
  domains       = ! +local_domains : !+relay_to_domains : \
      ${if exists {/home/$sender_address_local_part/.return-path-sign}\
                  {/home/$sender_address_local_part/.return-path-sign}\
                  {!*}}
  no_more
</screen>
      </para><para>
Veya, bir göstermelik sunucu (smarthost) kullanıyorsanız:
      </para><para>
<screen>
# Kullanıcının ev dizininde bir <quote>.return-path-sign</quote> dosyası
# varsa ve alıcının alanadı bu dosyada mevcutsa, uzak konaklara posta
# teslimatı yaparken zarf göndericisi adresini imleyeceğiz. Eğer dosya
# var ama içi boşsa, zarf göndericisi adresini daima imleyeceğiz.
#
smarthost_signed:
  debug_print   = "R: smarthost_signed for $local_part@$domain"
  driver        = manualroute
  transport     = remote_smtp_signed
  senders       = ! : *
  route_list    = * <emphasis>göstermelik.sunucu.adresi</emphasis>
  host_find_failed = defer
  domains       = ! +local_domains : !+relay_to_domains : \
      ${if exists {/home/$sender_address_local_part/.return-path-sign}\
                  {/home/$sender_address_local_part/.return-path-sign}\
                         {!*}}
  no_more
</screen>
      </para><para>
Sizce olması gereken diğer seçenekleri de (<option>same_domain_copy_routing = yes</option> gibi) ekleyin, tabii mevcut yönlendiricilerinizi tamamen oluşturduktan sonra.
      </para><para>
Dikkat ederseniz, bu yönlendiriciyi zarf göndericisi adresi boş olan postalar için kullanmıyoruz - bunları birbirine karıştırmayalım!<footnote><para>
Yukarıdaki örneklerde, <option>/home//.return-path-sign</option> dosyası mevcut olmayabileceğinden <option>senders</option> kuralı aslında gereksizdir. Ancak, ongunluk açısından kuralı açıkça kullanıyoruz.</para></footnote>
      </para>
    </sect2>

    <sect2 chunkthis="1" id="spam-filtering-exim-sign-router-redirect">
      <title>Gelen teslimatlar için <literal>redirect</literal> yönlendiricisi oluşturmak</title><para>
Bundan sonra yapacağınız iş, Exim'e yukarıdaki biçimde adreslenmiş olarak gelen teslimatların alıcı adresine ait posta kutusunun ilk eşit işaretinden önceki kısım olduğunu belirtmektir. Bunu gerçekleştirmek için yapılandırma dosyanızın <option>routers</option> bölümünün başlarında bir yere bir  <option>redirect</option> yönlendirici yerleştirmeniz gerekir - yerel teslimatlarla (örn, <emphasis>system alias</emphasis> yönlendiricisi) ilgili yönlendiricilerin öncesine):
      </para><para>
<screen>
hashed_local:
  debug_print       = "R: hashed_local for $local_part@$domain"
  driver            = redirect
  domains           = +local_domains
  local_part_suffix = =*
  data              = $local_part@$domain
</screen>
      </para><para>
Eşit işareti içeren alıcı adreslerinin yerel kısmı eşit işaretinden arındırılarak yeniden yazılır ve tüm yönlendiricilerde tekrar işleme sokulur.
      </para>
    </sect2>

    <sect2 chunkthis="1" id="spam-filtering-exim-sign-acl">
      <title>İmleme Sınama ACL'si</title><para>
Bu şemanın son parçası, Exim'e imli olarak geçerli alıcı adreslere gelen teslimatların daima kabul edileceğini ve boş gönderici adresli diğer teslimatların ise eğer alıcı bu şemayı seçmişse reddedileceğini belirtmektir. Böyle durumlarda grilisteleme yapılmamalıdır.
      </para><para>
Aşağıdaki satırları <xref linkend="spam-filtering-acl_rcpt_to_final"/> ACL'sinde olası bir SPF, grilisteleme ve/veya sonuncu <option>accept</option> deyiminin öncesine yerleştirin:
      </para><para>
<screen>
  # Kendine özgü imlemesini içeriyorsa, alıcı adresini kabul ediyoruz.
  # Bu, teslimatın, daha önce bizden gönderilmiş bir postanın teslimat
  # durum bildirimi olduğunu gösterir.
  #
  accept
    domains     = +local_domains
    condition   = ${if and {{match{${lc:$local_part}}{^(.*)=(.*)}}\
                            {eq{${hash_8:${hmac{md5}{SECRET}{$1}}}}{$2}}}\
                           {true}{false}}

  # Aksi takdirde, posta boş gönderici adresli ise ama alıcı, imlemeli zarf
  # gönderici adresi şemasını seçenlerden biri ise postayı reddediyoruz.
  #
  deny
    message     = This address does not match a valid, signed \
                  return path from here.\n\
                  You are responding to a forged sender address.
    log_message = bogus bounce.
    senders     = : postmaster@*
    domains     = +local_domains
    set acl_m9  = /home/${extract{1}{=}{${lc:$local_part}}}/.return-path-sign
    condition   = ${if exists {$acl_m9}{true}}

</screen>
      </para><para>
Postayı gönderirken iletinin başlığındaki adreslere (örneğin, gönderdiğiniz postanın <option>From:</option> alanındaki adrese) varlık doğrulaması yapan  konakların varlığını bu noktada dikkate almak gerekir. Buradaki <option>deny</option> deyimi normal olarak böyle bir doğrulatma çabasına olumsuz yanıt verecektir.
      </para><para>
Bunun olmaması için, <option>deny</option> deyimini <option>warn</option> deyimi haline getirmek, red iletisini <literal>$acl_m0</literal> değişkeninde saklayıp asıl reddi <command>DATA</command> komutundan sonra yapmak isteyebilirsiniz:
      </para><para>
<screen>
  # Aksi takdirde, posta boş gönderici adresli ise ama alıcı, imlemeli zarf
  # gönderici adresi şemasını seçenlerden biri ise, red iletisini $acl_m0
  # ve günlük iletisini $acl_m1 değişkenine kaydedip, bunları daha sonra
  # postayı reddederken kullanacağız. Red sırasında göndericinin oyalanıp
  # oyalanmayacağına bunların varlığına bakarak karar vereceğiz.
  #
  warn
    senders     = : postmaster@*
    domains     = +local_domains
    set acl_m9  = /home/${extract{1}{=}{${lc:$local_part}}}/.return-path-sign
    condition   = ${if exists {$acl_m9}{true}}
    set acl_m0  = The recipient address &lt;$local_part@$domain&gt; does not \
                  match a valid, signed return path from here.\n\
                  You are responding to a forged sender address.
    set acl_m1  = bogus bounce for &lt;$local_part@$domain&gt;.
</screen>
      </para><para>
Ayrıca, alıcı giden postasında imlemeli zarf gönderici adresi kullanmayı seçmiş bile olsa, bazı konaklardan gelen postaların zarf gönderici adresi boş olsa bile sınama dışı tutulmasını isteyebilir. Bilhassa eposta listelerinin sunucuları buna en iyi örnektir, bu konuda daha ayrıntılı bilgi için <xref linkend="spam-filtering-signedsender"/> bölümüne bakınız.
      </para>
    </sect2>
  </sect1>

  <sect1 id="spam-filtering-exim-bounces">
    <title>Göndericisi Olmayan Postaların sadece Gerçek Kullanıcılar için Kabul Edilmesi</title><para>
<xref linkend="spam-filtering-dsnrealuser"/> bölümünde açıklandığı gibi, <option>postmaster</option> gibi sistem kullanıcılarına ve rumuzlarına gönderilmiş hatalı <link linkend="spam-filtering-dsn">teslimat durum bildirimlerini</link> yakalamamızı önleyen bir durum vardır. Burada, göndericisi olmayan postaları sadece gerçekten posta göndericisi olan kullanıcılar için kabul/red ettiğimizden emin olmamızı sağlayacak iki yöntem üzerinde duracağız.
    </para>

    <sect2 chunkthis="1" id="spam-filtering-exim-dsn-mailbox">
      <title>Alıcı posta kutuluranın sınanması</title><para>
İlk yöntem için <xref linkend="spam-filtering-acl_rcpt_to_final"/> ACL'sini kullanacağız. Burada, yerel bir posta kutusu olan bir alıcı adresinin varlığını sınayacağız:
      </para><para>
<screen>
  # Eğer gönderici adresi boşsa, bir posta kutusu olmayan kullanıcılara
  # (örn, postmaster, webmaster, v.s.) gelen postayı reddediyoruz.
  # Bu kullanıcılar posta göndermezler, dolayısıyla onlara bir posta
  # (teslimat durum bildirimi) dönemez.
  #
  deny
    message     = This address never sends outgoing mail. \
                  You are responding to a forged sender address.
    log_message = bogus bounce for system user &lt;$local_part@$domain&gt;
    senders     = : postmaster@*
    domains     = +local_domains
    !<emphasis>posta kutusu sınaması</emphasis>
</screen>
      </para><para>
Talihsizliğe bakın ki, postanızı nasıl teslim ettiğinize bağlı olarak <parameter>posta kutusu sınaması</parameter> için yapacağımız işlem farklı olacak (örn, <link linkend="spam-filtering-exim-sign">imlemeli zarf göndericisi adresleri</link> için alıcı adresinin eşit işaretinden önceki kısmını ayırmak gibi):
      </para><para>
      <itemizedlist>
        <listitem><para>
Eğer posta kutusu isimleri olarak sunucunuzdaki kullanıcıların hesapları kullanılmışsa, alıcı isimleri ile normal kullanıcıların kullanıcı kimlikleri (500 ile 60000 arasında) karşılaştırılabilir:
      </para><para>
<screen>
  set acl_m9 = ${extract{1}{=}{${lc:$local_part}}}
  set acl_m9 = ${extract{2}{:}{${lookup passwd {$acl_m9}{$value}}}{0}}
  condition  = ${if and {{&gt;={$acl_m9}{500}} {&lt;${acl_m9}{60000}}} {true}}
</screen>
        </para></listitem>
        <listitem><para>
Posta teslimatlarınızı <ulink url="http://asg.web.cmu.edu/cyrus/">Cyrus</ulink> IMAP yapıyorsa, posta kutularının varlığına bakmak için <command>mbpath</command> komut satırı aracını kullanabilirsiniz. Bunun için, Exim'in posta kutularını sınama yetkisine sahip olmasını sağlamanız gerekir (örn, onu <option>cyrus</option> grubuna ekleyebilirsiniz:<sbr/><command># adduser exim4 cyrus</command>).
      </para><para>
<screen>
  set acl_m9 = ${extract{1}{=}{${lc:$local_part}}}
  condition  = ${run {/usr/sbin/mbpath -q -s user.$acl_m9} {true}}
</screen>
        </para></listitem>
        <listitem><para>
Tüm postaları teslim etmesi için bir dış makineye yolluyorsanız, bu makinenin postayı kabul edip etmeyeceğine karar verebilmek için bir <xref linkend="spam-filtering-callforward"/> uygulamanız gerekebilir. Varlık sınaması için özgün zarf göndericisi adresini aynen kullanmanız gerekir:
      </para><para>
<screen>
  verify = recipient/callout=use_sender
</screen>
          </para>
        </listitem>
      </itemizedlist>
      </para><para>
Postanın yerel olarak teslimatı durumunda, bu posta kutusu sınamaları yönlendiricilerde (routers) uygulananların birer tekrarı olacağından ve posta teslimat mekanizması bizim siteye özel olacağından, bu işlem bizim gibi mükemmelliyetçiler için biraz zorlu bir süreç olur. Bu bakımdan, şimdi başka bir yönteme bakacağız.
      </para>
    </sect2>

    <sect2 chunkthis="1" id="spam-filtering-exim-dsn-noalias">
      <title>Boş göndericilerin <option>system_aliases</option> yönlendiricisinde sınanması</title><para>
<option>postmaster</option> ve <option>mailer-demon</option> gibi sistem rumuzlarına gelen postaları asıl alıcısına yönlendiren <option>system_aliases</option> veya benzer isimli bir yönlendiriciniz herhalde vardır. Normalde bu rumuzlar giden postalarda gönderici olarak kullanılmazlar. Dolayısıyla, bunlara hiç gelmemesi gereken <link linkend="spam-filtering-dsn">teslimat durum bildirimlerini</link> yönlerdiriciye bir kural ekleyerek yakalayabilirsiniz:
      </para><para>
<screen>
!senders = : postmaster@*
</screen>
      </para><para>
Örnek bir rumuz yönlendiricisi şöyle görünürdü:
      </para><para>
<screen>
system_aliases:
  driver         = redirect
  domains        = +local_domains
  !senders       = : postmaster@*
  allow_fail
  allow_defer
  data           = ${lookup{$local_part}lsearch{/etc/aliases}}
  user           = mail
  group          = mail
  file_transport = address_file
  pipe_transport = address_pipe
</screen>
      </para><para>
Böylece bazı sistem rumuzlarına gelen göndericisiz postaları engelleyebilmemize rağmen mevcut sistem kullanıcılarınının rumuzlarına (<quote>root</quote>, <quote>daemon</quote>, v.s) gelenleri henüz engelleyemedik. Yerel posta teslimatı için <option>accept</option> sürücüsünü ve alıcı adresleri doğrulamak için <option>check_local_user</option> kullanıyorsanız, kendinizi bu sistem hesaplarına posta yönlendirirken bulabilirsiniz.
      </para><para>
Bu sorunu gidermek için, yerel postanızı elde etmekte kullandığınız yönlendiricide (örn,  <emphasis>local_user</emphasis>), alıcının sadece mevcudiyetine değil, <quote>gerçek</quote> bir kullanıcı olup olmadığına da bakabilirsiniz. Örneğin, önceki bölümdeki gibi 500 ile 60000 arasındaki kullanıcı kimlikleriyle eşleşen kullanıcıları seçebilirsiniz:
      </para><para>
<screen>
  condition  = ${if and {{&gt;={$local_user_uid}{500}}\
                         {&lt;{$local_user_uid}{60000}}}\
                    {true}}
</screen>
      </para><para>
Yerel teslimatlar için örnek bir yönlendirici şöyle görünürdü:
      </para><para>
<screen>
local_user:
  driver           = accept
  domains          = +local_domains
  check_local_user
  condition        = ${if and {{&gt;={$local_user_uid}{500}}\
                               {&lt;{$local_user_uid}{60000}}}\
                              {true}}
  transport        = <emphasis>transport</emphasis>
</screen>
      </para><para>
Bu yöntemi kullanırken dikkatli olun, sistem kullanıcılarına ve rumuzlarına gönderilmiş göndericisiz postalar için red yanıtı bilinmeyen alıcı şeklinde (burada <command>550 Unknown User</command> olarak) olacaktır.
      </para>
    </sect2>
  </sect1>

  <sect1 id="spam-filtering-exim-forward">
    <title>Yönlerdirilmiş Postaların Sınama Dışı Tutulması</title><para>
SMTP aktarımına bu sınamaları ekledikten sonra, kendimizi posta listelerinden veya diğer sitelerin posta hesaplarından yönlendirilmiş postaları reddederek dolaylı spam yapar bir halde bulabiliriz (<xref linkend="spam-filtering-forwardedmail"/> bölümüne bakınız). En azından bizim spam ve/veya virüs filtrelemelerimiz sonucunda gönderdikleri postaların reddedilmemesii için bu konakları aklisteye alabilir ve sınamalarımızın dışında tutabiliriz.
    </para><para>
Bu örnekte, her <command>RCPT TO:</command> komutuna yanıt verirken iki dosyaya bakıyoruz:
    </para><para>
    <itemizedlist>
      <listitem><para>
Yedek posta alıcılarını ve diğer aklisteli göndericileri içeren genel amaçlı bir ak liste: <option>/etc/mail/whitelist-hosts</option>
      </para></listitem>
      <listitem><para>
Yönlendirimiş posta alıcısı olan kullanıcıların postalarını yönlendiren konakları belirttikleri <option>/home/<emphasis>kullanıcı</emphasis>/.forwarders</option> dosyaları.
      </para></listitem>
    </itemizedlist>
    </para><para>
Eğer posta kullanıcılarınızın yerel hesapları ve ev dizinleri yoksa, bu dosyaların bulunacağı yolları değiştirebilir ve/veya sisteminize uygun bazı arama mekanizmaların kullanılmasını sağlayabilirsiniz (örn, veritabanı veya LDAP sorguları).
    </para><para>
Eğer gönderici konak bu aklistelerden birindeyse, <xref linkend="spam-filtering-exim-smtpdelays-selective"/> bölümünde anlatıldığı gibi <quote>accept</quote> sözcüğünü <literal>$acl_m0</literal> değişkenine kaydedip <varname>$acl_m1</varname> değişkeninin içini boşaltacağız. Böylece bu postanın daha sonraki sınamalarda reddedilmesini önlemiş olacağız.
    </para><para>
<xref linkend="spam-filtering-acl_rcpt_to_final"/> ACL'sinde alıcı adresini doğruladıktan sonraya ve uzak konaklardan yerel kullanıcılara kimlik kanıtlamasız teslimatlarla ilgili <option>accept</option> deyimlerinin öncesine (varsa grilisteleme ve zarf gönderici imlemesi sınamalarının öncesine) aşağıdaki satırları yerleştireceğiz:
      </para><para>
<screen>
  # Gönderici konak genel akliste içindeyse postayı kabul edeceğiz.
  # Geçici olarak $acl_m9 değişkenine bu dosyayı atayacağız.
  # Konak listedeyse, $acl_m0'a bir değer yerleştirip $acl_m1'i
  # temizleyeceğiz, böylece daha sonra bu postayı reddetmeyeceğiz.
  #
  accept
    set acl_m9  = /etc/mail/whitelist-hosts
    hosts       = ${if exists {$acl_m9}{$acl_m9}}
    set acl_m0  = accept
    set acl_m1  =


  # Gönderici konak alıcının ev dizinindeki ".forwarders" dosyasındaysa
  # postayı kabul edeceğiz. Geçici olarak $acl_m9 değişkenine bu dosyayı
  # atayacağız. Konak listedeyse, $acl_m0'a bir değer yerleştirip $acl_m1'i
  # temizleyeceğiz, böylece daha sonra bu postayı reddetmeyeceğiz.
  #
  accept
    domains     = +local_domains
    set acl_m9  = /home/${extract{1}{=}{${lc:$local_part}}}/.forwarders
    hosts       = ${if exists {$acl_m9}{$acl_m9}}
    set acl_m0  = accept
    set acl_m1  =
</screen>
    </para><para>
<xref linkend="spam-filtering-acl_data_final"/> ACL'sinin çeşitli deyimlerinde <varname>$acl_m0</varname>'ın değerine bakarak eğer yukarıdaki gibi boş bırakılmışsa postayı reddetmeyeceğiz. Örneğin, aklisteli konaklardan gelen bir postanın <link linkend="rfc2822">RFC 2822</link> başlığının bulunmayışı sebebiyle reddedilmesini önlemek istersek:
      </para><para>
<screen>
  deny
    message     = Your message does not conform to RFC2822 standard
    log_message = missing header lines
    !hosts      = +relay_from_hosts
    !senders    = : postmaster@*
    condition   = ${if !eq {$acl_m0}{accept}{true}}
    condition   = ${if or {{!def:h_Message-ID:}\
                           {!def:h_Date:}\
                           {!def:h_Subject:}} {true}{false}}
</screen>
    </para><para>
Bu ve ilgili diğer sınamalar sonraki <xref linkend="spam-filtering-exim-final"/> bölümünde bulunabilir.
    </para>
  </sect1>

  <sect1 id="spam-filtering-exim-final">
    <title>Tamamlanmış ACL'ler</title><para>
Tamam, artık canlanalım! Çok uzun bir okumadan sonra buraya kadar gelebildiğinize göre bir tebriği hakettiniz!
    </para><para>
Bu bölümdeki ACL'ler, bu belgede bu gerçeklenim için şimdiye dek bahsettiğimiz sınamaların tamamını içermektedir. Ancak bazıları iptal edilmiştir (açıklama haline getirilerek). Bunların bazı sebepleri var:
    </para><para>
    <itemizedlist>
      <listitem> <para>
<link linkend="spam-filtering-exim-greylisting">Grilisteleme</link>. Bunun sağlanması ya ek bir yazılımın kurulu olmasını ya da Exim yapılandırma dosyasına ek ACL'ler ve tanımlamalar eklemek yoluyla oldukça karmaşık bir yapılandırma gerektirir. Yine de şiddetle tavsiye ederim.
      </para></listitem>
      <listitem><para>
<link linkend="spam-filtering-exim-av">Virüs tarama</link>. Spamı tanımlamakta kullanılan SpamAssassin gibi herkesin kullandığı <emphasis>her yerde hazır ve nazır</emphasis> bir tarayıcı olmadığından. Diğer yandan,  <option>Exiscan-ACL</option> ile gelen belgede bu konuda epey bilgi bulabilirsiniz.
      </para></listitem>
      <listitem><para>
<link linkend="spam-filtering-exim-per-user">SpamAssassin'in kullanıcıya özel ayarları</link>.  İletinin ilk alıcısı dışında kalan tüm alıcılarının postalarının ertelenmesi prensibiyle çalıştığından herkesin yararına değildir.
      </para></listitem>
      <listitem><para>
<link linkend="spam-filtering-exim-sign">Zarf Göndericisi İmleri</link>. Dolaşımdaki kullanıcılar gibi bazıları için bazı olumsuzlukları vardır. Ayrıca diğer ACL'lerde olduğu kadar yönlendiricilerin ve aktarımcıların yapılardırılmasında da değişiklikler yapılmasını gerektirir. Daha ayrıntılı bilgi için <xref linkend="spam-filtering-exim-sign"/> bölümüne bakınız.
      </para></listitem>
      <listitem><para>
<xref linkend="spam-filtering-exim-bounces"/>.  Bunu yapmanın çeşitli yolları vardır ve gerçek kullanıcıların nasıl saptanacağı posta teslimatının nasıl yapıldığıyla çok ilgilidir.
      </para></listitem>
    </itemizedlist>
    </para><para>
Telaşa gerek yok, hepimizin beklediği sınamaları düzgün sıralanmış ACL'lerin hepsi burada.
    </para>

    <sect2 chunkthis="1" id="spam-filtering-acl_connect_final">
      <title><literal>acl_connect</literal></title><para>
<screen>
# Bu erişim denetim listesi gelen bağlantının başlangıcında
# kullanılır. Bu sınamalar bağlantı kabul ya da red edilinceye
# kadar sırayla yapılır.

acl_connect:
  # Gecikme uygularken başlangıç olarak kullanmak üzere o anki zaman
  # bilgisini kaydediyoruz.
  warn
    set acl_m2  = $tod_epoch


  # Posta yerel SMTP üzerinden alınmışsa (yani, TCP/IP bağlantısı
  # ile gelmiyorsa), kabul ediyoruz. Bunu boş bir konak alanını
  # sınayarak yapacağız. Ayrıca, postalarını rölelediğimiz
  # konaklardan ve yerel arabirimlerden gelen postaları da kabul edeceğiz.
  accept
    hosts       = : +relay_from_hosts


  # Eğer bağlanan konak DNS karalistelerinde kayıtlıysa, $acl_c1'e
  # bir uyarı iletisi kaydedeceğiz. Bu iletiyi daha sonra posta
  # başlığına ekleyeceğiz. Varlığı bize geciktirme uygulayacağımızı
  # belirtecek.
  #

  warn
    !hosts      = ${if exists {/etc/mail/whitelist-hosts} \
                              {/etc/mail/whitelist-hosts}}
    dnslists    = list.dsbl.org : \
                  dnsbl.sorbs.net : \
                  dnsbl.njabl.org : \
                  bl.spamcop.net : \
                  dsn.rfc-ignorant.org : \
                  sbl-xbl.spamhaus.org : \
                  l1.spews.dnsbl.sorbs.net
    set acl_c1  = X-DNSbl-Warning: \
                  $sender_host_address is listed in $dnslist_domain\
                  ${if def:dnslist_text { ($dnslist_text)}}


  # Benzer şekilde, gönderici konağın DNS sorgusu başarısız olursa
  # (örn, rDNS kaydı yoksa veya belirtilen isim bağlantı kudulan IP
  # ile eşleşmiyorsa), $acl_c1'e bir uyarı iletisi kaydedeceğiz. Bu
  # iletiyi daha sonra posta başlığına ekleyeceğiz.
  warn
    condition   = ${if !def:acl_c1 {true}{false}}
    !verify     = reverse_host_lookup
    set acl_m9  = Reverse DNS lookup failed for host $sender_host_address
    set acl_c1  = X-DNS-Warning: $acl_m9


  # Bağlantıyı kabul ediyoruz, fakat $acl_c1'de evvelce kaydedilmiş bir
  # ileti varsa, göndericiyi 20 saniye dolana kadar bekletiyoruz.
  accept
    set acl_m2  = ${if def:acl_c1 {${eval:20 + $acl_m2 - $tod_epoch}}{0}}
    delay       = ${if &gt;{$acl_m2}{0}{$acl_m2}{0}}s
</screen>
      </para>
    </sect2>

    <sect2 chunkthis="1" id="spam-filtering-acl_helo_final">
      <title><literal>acl_helo</literal></title><para>
<screen>
# Bu erişim denetim listesi gelen bir SMTP aktarımında HELO veya EHLO
# komutları için kullanılır. Bu sınamalar selamlaşma kabul ya da
# red edilinceye kadar sırayla yapılır.


acl_helo:
  # Gecikme uygularken başlangıç olarak kullanmak üzere o anki zaman
  # bilgisini kaydediyoruz.
  warn
    set acl_m2  = $tod_epoch


  # Posta yerel SMTP üzerinden alınmışsa (yani, TCP/IP bağlantısı
  # ile gelmiyorsa), kabul ediyoruz. Bunu boş bir konak alanını
  # sınayarak yapacağız. Ayrıca, postalarını rölelediğimiz
  # konaklardan gelen postaları da kabul edeceğiz.
  #
  accept
    hosts       = : +relay_from_hosts


  # Bağlanan konak selamlaşma sırasında bir IP adresi belirtmişse, $acl_c0'a
  # bir red iletisi ve $acl_c1'e bir günlük iletisi kaydedeceğiz. Bunları
  # sonra bir "deny" deyiminde kullanacağız ve bu sırada göndericiyi 20 saniye
  # bekleteceğiz.
  #
  warn
    condition   = ${if isip {$sender_helo_name}{true}{false}}
    set acl_c0  = Message was delivered by ratware
    set acl_c1  = remote host used IP address in HELO/EHLO greeting


  # Bağlanan konak selamlaşma sırasında bizim isimlerimizden birini
  # belirtmişse aynı işleme tabi tutuyoruz.
  #
  warn
    condition   = ${if match_domain{$sender_helo_name}\
                   {$primary_hostname:+local_domains:+relay_to_domains}\
                   {true}{false}}
    set acl_c0  = Message was delivered by ratware
    set acl_c1  = remote host used our name in HELO/EHLO greeting.


  # HELO doğrulaması başarısız olmuşsa, acl_c1'e bir uyarı iletisi
  # kaydediyoruz. Bu iletiyi daha sonra posta başlığına ekleyeceğiz.
  # Varlığı bize geciktirme uygulayacağımızı belirtecek.
  #
  warn
    condition   = ${if !def:acl_c1 {true}{false}}
    !verify     = helo
    set acl_c1  = X-HELO-Warning: Remote host $sender_host_address \
                  ${if def:sender_host_name {($sender_host_name) }}\
                  incorrectly presented itself as $sender_helo_name
    log_message = remote host presented unverifiable HELO/EHLO greeting.


  # Selamlaşmayı kabul ediyoruz, fakat $acl_c1'de evvelce kaydedilmiş
  # bir ileti varsa, göndericiyi 20 saniye dolana kadar bekletiyoruz.
  accept
    set acl_m2  = ${if def:acl_c1 {${eval:20 + $acl_m2 - $tod_epoch}}{0}}
    delay       = ${if &gt;{$acl_m2}{0}{$acl_m2}{0}}s

</screen>
      </para>
    </sect2> <!-- acl_helo -->
    <sect2 chunkthis="1" id="spam-filtering-acl_mail_from_final">
      <title><literal>acl_mail_from</literal></title><para>
<screen>
# Bu erişim denetim listesi gelen bir SMTP aktarımında MAIL FROM:
# komutu için kullanılır. Bu sınamalar gönderici adresi kabul
# ya da red edilinceye kadar sırayla yapılır.
#

acl_mail_from:
  # Gecikme uygularken başlangıç olarak kullanmak üzere o anki zaman
  # bilgisini kaydediyoruz.
  warn
    set acl_m2  = $tod_epoch


  # Posta yerel SMTP üzerinden alınmışsa (yani, TCP/IP bağlantısı
  # ile gelmiyorsa), kabul ediyoruz. Bunu boş bir konak alanını
  # sınayarak yapacağız. Ayrıca, postalarını rölelediğimiz
  # konaklardan gelen postaları da kabul edeceğiz.
  #
  # Alıcı doğrulamasını burada atlıyoruz, çünkü çoğu durumda
  # istemciler kullanıcıların posta istemcileridir ve SMTP
  # hata iletileri ile ne yapacaklarını bilmezler.
  #
  accept
    hosts     = : +relay_from_hosts


  # İleti, kimlik kanıtlaması yapılan bir bağlantı üzerinden
  # geliyorsa kabul ediyoruz. Yine, bu iletiler kullanıcıların posta
  # istemcilerinden geldiklerinden alıcı doğrulaması yapmıyoruz.
  #
  accept
    authenticated = *


  # Bu SMPT aktarımı sırasında yapılacak her teslimata uygulanacak red
  # ve/veya uyarı iletileri varsa, bunlar $acl_c0 ve $acl_c1 değişkenlerinde
  # kayıtlıdır. Bunları iletiye özel değişkenler olan $acl_m{0,1}'a
  # kopyalayıp, $acl_m1'deki uyarı iletisini ileti başlığına ekleyeceğiz.
  # (Bir red durumunda, $acl_m1 artık bir günlük kaydı içeriyor olacak,
  # ama iletiyi bununla değil başlığındaki kayıtla reddedeceğiz.)
  #
  warn
    set acl_m0  = $acl_c0
    set acl_m1  = $acl_c1
    message     = $acl_c1


  # Gönderici bir HELO/EHLO selamlaşması yapmamışsa, $acl_m0'e bir red,
  # ve $acl_m1'e bir günlük iletisi kaydedeceğiz. Bunları sonra bir
  # "deny" deyiminde kullanacağız ve bu sırada göndericiyi 20 saniye
  # bekleteceğiz.
  #
  warn
    condition   = ${if def:sender_helo_name {0}{1}}
    set acl_m0  = Message was delivered by ratware
    set acl_m1  = remote host did not present HELO/EHLO greeting.


  # Gönderici adresi doğrulanamazsa, $acl_m1'e bir uyarı iletisi
  # kaydedeceğiz ve bunu ileti başlığına ekleyeceğiz.
  # Varlığı bize geciktirme uygulayacağımızı belirtecek.
  #
  # "callout" seçeneğini isterseniz silebilirsiniz. Özellikle, postanızı
  # doğrudan değil de göstermelik sunucu (smarthost) olarak
  # gönderiyorsanız, bu seçenek anlamsız olacaktır.
  #
  warn
    condition   = ${if !def:acl_m1 {true}{false}}
    !verify     = sender/callout
    set acl_m1  = Invalid sender &lt;$sender_address&gt;
    message     = X-Sender-Verify-Failed: $acl_m1
    log_message = $acl_m1


  # Göndericiyi kabul ediyoruz, fakat $acl_c1'de evvelce kaydedilmiş
  # bir ileti varsa, göndericiyi 20 saniye dolana kadar bekletiyoruz.
  accept
    set acl_m2  = ${if def:acl_c1 {${eval:20 + $acl_m2 - $tod_epoch}}{0}}
    delay       = ${if &gt;{$acl_m2}{0}{$acl_m2}{0}}s

</screen>
      </para>
    </sect2>

    <sect2 chunkthis="1" id="spam-filtering-acl_rcpt_to_final">
      <title><literal>acl_rcpt_to</literal></title><para>
<screen>
# Bu erişim denetim listesi gelen bir SMTP aktarımında RCPT
# komutu için kullanılır. Bu sınamalar alıcı adresi kabul
# ya da red edilinceye kadar sırayla yapılır.

acl_rcpt_to:

  # Posta yerel SMTP üzerinden alınmışsa (yani, TCP/IP bağlantısı
  # ile gelmiyorsa) kabul et. Bunu boş bir konak alanını
  # sınayarak yapacağız. Ayrıca, postalarını rölelediğimiz
  # konaklardan gelen postaları da kabul edeceğiz.
  #
  # Alıcı doğrulamasını burada atlıyoruz, çünkü çoğu durumda
  # istemciler kullanıcıların posta istemcileridir ve SMTP
  # hata iletileri ile ne yapacaklarını bilmezler.
  #
  accept
    hosts       = : +relay_from_hosts


  # İleti, kimlik kanıtlaması yapılan bir bağlantı üzerinden
  # geliyorsa kabul ediyoruz. Yine, bu iletiler kullanıcıların posta
  # istemcilerinden geldiklerinden alıcı doğrulaması yapmıyoruz.
  #
  accept
    authenticated = *


  # Yerel kısım @  %  / | ! karakterlerinden birini içeriyorsa,
  # iletiyi reddediyoruz. Bunlar normal yerel kısımlarda çok nadir
  # görülür, çoğunlukla röleleme sınırlamalarını aşmaya çalışanlarca
  # kullanılır.
  #
  # Ayrıca, yerel kısım bir nokta ile başlıyorsa da reddediyoruz.
  # Boş bileşenler RFC 2822'de kuraldışıdır, fakat Exim bu yaygın
  # olduğundan bunlara izin verir. Buna rağmen, bir nokta ile
  # başlayan bir yerel kısım bir dosya ismi olarak kullanılmışsa
  # (örneğin, bir posta listesi), sorunlara yol açabilir.
  #
  deny
    local_parts = ^.*[@%!/|] : ^\\.


  # Eğer $acl_m0'da kayıtlı bir sebep varsa, göndericiyi 20 saniye
  # beklettikten sonra reddediyoruz.
  #
  deny
    message     = $acl_m0
    log_message = $acl_m1
    condition   = ${if and {{def:acl_m0}{def:acl_m1}} {true}}
    delay       = 20s


  # Alıcı adres bizim postalarını kabul ettiğimiz alanlardan birine
  # ait değilse, göndericiyi 20s beklettikten sonra reddediyoruz.
  #
  deny
    message     = relay not permitted
    !domains    = +local_domains : +relay_to_domains
    delay       = 20s


  # Alıcı adres bizim postalarını kabul ettiğimiz alanlardan birine
  # ait fakat geçersizse, göndericiyi beklettikten sonra reddediyoruz.
  #
  deny
    message     = unknown user
    !verify     = recipient/callout=20s,defer_ok,use_sender
    delay       = ${if def:sender_address {1m}{0s}}



  # Zarf göndericisi adresi boş fakat postanın birden fazla alıcısı
  # varsa, bağlantıyı kesiyoruz. Meşru teslimat durum bildirimleri
  # asla bir defada birden fazla alıcıya gönderilmez.
  #
  drop
    message      = Legitimate bounces are never sent to more than one \
                   recipient.
    senders      = : postmaster@*
    condition    = $recipients_count
    delay        = 5m


  # --------------------------------------------------------------------
  # Kullanıcı verilerini ve ayarlarını (Spamassasin gibi) destekleyebilmek
  # için gelen her iletinin alıcı sayısını bir ile sınırlayalım.
  #
  # BİLGİ: Çok sayıda kullanıcınıza gönderilmiş bir postanın yerine
  #        ulaşması her alıcı için 30 dakika veya daha fazla olmak
  #        üzere katlanarak gecikecektir. Bu, özellikle zamanın kritik
  #        önemde olduğu durumlarda sorunlara yol açacaktır.
  #
  #defer
  #  message      = We only accept one recipient at a time - please try later.
  #  condition    = $recipients_count
  # --------------------------------------------------------------------


  # Gönderici konak alıcının ev dizinindeki ".forwarders" dosyasındaysa
  # postayı kabul edeceğiz. Geçici olarak $acl_m9 değişkenine bu dosyayı
  # atayacağız. Konak listedeyse, $acl_m0'a bir değer yerleştirip $acl_m1'i
  # temizleyeceğiz, böylece daha sonra bu postayı reddetmeyeceğiz.
  #
  accept
    domains     = +local_domains
    set acl_m9  = /home/${extract{1}{=}{${lc:$local_part}}}/.forwarders
    hosts       = ${if exists {$acl_m9}{$acl_m9}}
    set acl_m0  = accept
    set acl_m1  =


  # Gönderici konak genel akliste içindeyse postayı kabul edeceğiz.
  # Geçici olarak $acl_m9 değişkenine bu dosyayı atayacağız.
  # Konak listedeyse, $acl_m0'a bir değer yerleştirip $acl_m1'i
  # temizleyeceğiz, böylece daha sonra bu postayı reddetmeyeceğiz.
  #
  accept
    set acl_m9  = /etc/mail/whitelist-hosts
    hosts       = ${if exists {$acl_m9}{$acl_m9}}
    set acl_m0  = accept
    set acl_m1  =


  # --------------------------------------------------------------------
  # Zarf Gönderici İmlemesinin Sınanması.
  # Bu kısım öntanımlı olarak iptal edilmiştir, çünkü 'transports' ve
  # 'routers' bölümlerindeki yapılandırmanın da değiştirilmesi gerekir.
  #
  # Kendine özgü imlemesini içeriyorsa, alıcı adresini kabul ediyoruz.
  # Bu, teslimatın, daha önce bizden gönderilmiş bir postanın teslimat
  # durum bildirimi olduğunu gösterir.
  #
  #accept
  #  domains     = +local_domains
  #  condition   = ${if and {{match{${lc:$local_part}}{^(.*)=(.*)}}\
  #                          {eq{${hash_8:${hmac{md5}{SECRET}{$1}}}}{$2}}}\
  #                         {true}{false}}
  #
  # Aksi takdirde, posta boş gönderici adresli ise ama alıcı, imlemeli zarf
  # gönderici adresi şemasını seçenlerden biri ise postayı reddediyoruz.
  #
  #deny
  #  message     = This address does not match a valid, signed \
  #                return path from here.\n\
  #                You are responding to a forged sender address.
  #  log_message = bogus bounce.
  #  senders     = : postmaster@*
  #  domains     = +local_domains
  #  set acl_m9  = /home/${extract{1}{=}{${lc:$local_part}}}/.return-path-sign
  #  condition   = ${if exists {$acl_m9}{true}}
  # --------------------------------------------------------------------


  # --------------------------------------------------------------------
  # Eğer gönderici adresi boşsa, bir posta kutusu olmayan kullanıcılara
  # (örn, postmaster, webmaster, v.s.) gelen postayı reddediyoruz.
  # Bu kullanıcılar posta göndermezler, dolayısıyla onlara bir posta
  # (teslimat durum bildirimi) dönemez.
  #
  # BİLGİ: Bu kısım öntanımlı olarak iptal edilmiştir, çünkü uygulanacak
  #        kural yerel postanın teslimat biçimine özeldir. Bu sınamayı
  #        etkinleştirmek isterseniz, aşağıdaki kurallardan size uygun
  #        olan birini (ama sadece birini) devreye sokun.
  #
  #deny
  #  message     = This address never sends outgoing mail. \
  #                You are responding to a forged sender address.
  #  log_message = bogus bounce for system user &lt;$local_part@$domain&gt;
  #  senders     = : postmaster@*
  #  domains     = +local_domains
  #  set acl_m9  = ${extract{1}{=}{${lc:$local_part}}}
  #
  # --- Alıcıların yerel hesapları varsa, bu iki satırı devreye alın:
  #  set acl_m9  = ${extract{2}{:}{${lookup passwd {$acl_m9}{$value}}}{0}}
  #  !condition  = ${if and {{&gt;={$acl_m9}{500}} {&lt;${acl_m9}{60000}}} {true}}
  #
  # --- Posta teslimatını Cyrus yapıyorsa bu satırı devreye alın:
  #  condition  = ${run {/usr/sbin/mbpath -q -s user.$acl_m9} {true}}
  # --------------------------------------------------------------------



  # Gönderici adresinin alanadı için varsa, SPF kayıtlarını sorgulayalım.
  # Gönderici konak bu alanadı için yetkilendirilmişse teslimatı kabul
  # yoksa red edeceğiz.
  #
  deny
    message     = [SPF] $sender_host_address is not allowed to send mail \
                  from $sender_address_domain
    log_message = SPF check failed.
    spf         = fail


  # İleti başlığına bir SPF-Received: satırı ekleyelim.
  warn
    message     = $spf_received


  # --------------------------------------------------------------------
  # Belli bir sunucu/gönderici/alıcı üçlüsü için grilisteleme durumunu
  # sınayacağız. Bu satırları devreye almadan önce "greylistd"'yi
  # kurmuş olmanız gerekir.
  # Bkz:  http://packages.debian.org/unstable/main/greylistd
  #
  # Grilisteleme iletilerini bir boş gönderici için yapmıyoruz, çünkü
  # boş gönderici adresli varlık doğrulaması işimize yaramaz (gerçek
  # göndericinin varlığını sınamak için bir konağa posta gönderemeyiz).
  #
  #defer
  #  message     = $sender_host_address is not yet authorized to deliver mail \
  #                from &lt;$sender_address&gt; to &lt;$local_part@$domain&gt;. \
  #                Please try later.
  #  log_message = greylisted.
  #  domains     = +local_domains : +relay_to_domains
  #  !senders    = : postmaster@*
  #  set acl_m9  = $sender_host_address $sender_address $local_part@$domain
  #  set acl_m9  = ${readsocket{/var/run/greylistd/socket}{$acl_m9}{5s}{}{}}
  #  condition   = ${if eq {$acl_m9}{grey}{true}{false}}
  #  delay       = 20s
  # --------------------------------------------------------------------

  # Alıcıyı kabul ediyoruz.
  accept
</screen>
      </para>
    </sect2>
    <sect2 chunkthis="1" id="spam-filtering-acl_data_final">
      <title><literal>acl_data</literal></title><para>
<screen>
# Bu erişim denetim listesi gelen bir SMTP aktarımında ileti verisi
# tamamen alındıktan sonra kullanılır. Bu sınamalar alıcı adresi
# kabul ya da red edilinceye kadar sırayla yapılır.

acl_data:
  # Bazı başlık satırlarını günlüğe kaydedelim.
  warn
    logwrite    = Subject: $h_Subject:


  # İleti kendi konaklarımızdan alınmış ve Message-ID başlığını
  # içermiyorsa, onu biz ekleyeceğiz.
  warn
    condition   = ${if !def:h_Message-ID: {1}}
    hosts       = +relay_from_hosts
    message     = Message-ID: &lt;E$message_id@$primary_hostname&gt;


  # Posta yerel SMTP üzerinden alınmışsa (yani, TCP/IP bağlantısı
  # ile gelmiyorsa), kabul ediyoruz. Bunu boş bir konak alanını
  # sınayarak yapacağız. Ayrıca, postalarını rölelediğimiz
  # konaklardan gelen postaları da kabul edeceğiz.
  #
  accept
    hosts       = : +relay_from_hosts

  # İleti, kimlik kanıtlaması yapılan bir bağlantı üzerinden
  # geliyorsa kabul ediyoruz.
  #
  accept
    authenticated = *


  # Eğer $acl_m0'da kayıtlı bir sebep varsa, göndericiyi 20 saniye
  # beklettikten sonra reddediyoruz.
  #
  deny
    message     = $acl_m0
    log_message = $acl_m1
    condition   = ${if and {{def:acl_m0}{def:acl_m1}} {true}{false}}
    delay       = 20s


  # İleti uzunluğu sınırlamasını devreye sokalım.
  #
  deny
    message     = Message size $message_size is larger than limit of \
                  MESSAGE_SIZE_LIMIT
    condition   = ${if &gt;{$message_size}{MESSAGE_SIZE_LIMIT}{yes}{no}}


  # Başlıktaki adreslerin sözdizimi hatalıysa reddediyoruz.
  #
  deny
    message     = Your message does not conform to RFC2822 standard
    log_message = message header fail syntax check
    !verify     = header_syntax


  # Message-ID:, Date: veya Subject: başlıklarından biri olmayan bir
  # ileti dışardan gelmişse reddetmek için aşağıdaki satırları devreye alın.
  #
  # Bazı özelleştirilmiş posta aktarımcılarının, örneğin posta listesi
  # sunucularının boş gönderici adresi ile gönderdikleri postalara
  # kendiliklerinden bir Message-ID üretmedikleri bilinmektedir;
  # böyle durumlar için boş bir gönderici adresin varlığına da bakacağız.
  #
  #deny
  #  message     = Your message does not conform to RFC2822 standard
  #  log_message = missing header lines
  #  !hosts      = +relay_from_hosts
  #  !senders    = : postmaster@*
  #  condition   = ${if !eq {$acl_m0}{accept}{true}}
  #  condition   = ${if or {{!def:h_Message-ID:}\
  #                         {!def:h_Date:}\
  #                         {!def:h_Subject:}} {true}{false}}


  # "Sender:", "Reply-To:" veya "From:" satırlarından en azından birindeki
  # gönderici adres doğrulanabilir değilse, bir uyarı veriyoruz.
  #
  warn
    message     = X-Sender-Verify-Failed: No valid sender in message header
    log_message = No valid sender in message header
    !verify     = header_sender



  # --------------------------------------------------------------------
  # Burada, zarf gönderici adresi olmayan iletilere grilisteleme
  # uygulayacağız. Bunları RCPT TO:'dan sonra grilistelemeye konu
  # etmeyeceğiz, çünkü gönderici varlık doğrulamaları yaparken
  # karşı konaklarla olumsuz etkileşime girilebilir.
  #
  # Bu deyimi devreye almadan önce "greylistd" kurmuş olmalısınız.
  # Bkz:  http://packages.debian.org/unstable/main/greylistd
  #
  #defer
  #  message     = $sender_host_address is not yet authorized to send \
  #                delivery status reports to &lt;$recipients&gt;. \
  #                Please try later.
  #  log_message = greylisted.
  #  senders     = : postmaster@*
  #  condition   = ${if !eq {$acl_m0}{accept}{true}}
  #  set acl_m9  = $sender_host_address $recipients
  #  set acl_m9  = ${readsocket{/var/run/greylistd/socket}{$acl_m9}{5s}{}{}}
  #  condition   = ${if eq {$acl_m9}{grey}{true}{false}}
  #  delay       = 20s
  # --------------------------------------------------------------------



  # --- EXISCAN yapılandırmasının BAŞLANGICI ---

  # Birtakım MIME hataları olan iletileri reddedeceğiz.
  #
  deny
    message     = Serious MIME defect detected ($demime_reason)
    demime      = *
    condition   = ${if &gt;{$demime_errorlevel}{2}{1}{0}}


  # MIME taşıyıcıyı aç ve kurtlar tarafından kullanılan dosya uzantıları
  # varsa reddet. Bu çağrılar tekrar demime uygulayacaktır, ama sonuçlar
  # arabellekli olarak dönecektir. Uzantı listesinin eksik olabileceğini
  # unutmayın.
  #
  deny
    message     = We do not accept ".$found_extension" attachments here.
    demime      = bat:btm:cmd:com:cpl:dll:exe:lnk:msi:pif:prf:reg:scr:vbs:url


  # İletinin boyutu MESSAGE_SIZE_SPAM_MAX'dan büyükse spam veya virüs
  # taraması yapmaksızın kabul ediyoruz.
  accept
    condition   = ${if &gt;{$message_size}{MESSAGE_SIZE_SPAM_MAX} {true}}
    logwrite    = :main: Not classified \
                  (message size larger than MESSAGE_SIZE_SPAM_MAX)


  # --------------------------------------------------------------------
  # Antivirüs taraması
  # Ana bölümde bir 'av_scanner' tanımı yapmış olmanız gerekir.
  #
  #deny
  #  message  = This message contains a virus ($malware_name)
  #  demime   = *
  #  malware_name  = */defer_ok
  # --------------------------------------------------------------------



  # $spam_score ve $spam_report'a veri sağlamak için SpamAssassin'i
  # çağıracağız. Tasnife bağlı olarak, $acl_m9 "ham" veya "spam"
  # değerini alacak.
  #
  # İleti spam olarak tasnif edilmişse ve evvelce $acl_m0'ı iletiyi ne
  # olursa olsun kabul edeceğimizi belirtecek şekilde ayarlamamışsak,
  # iletiyi reddetmiş gibi yapacağız.
  #
  warn
    set acl_m9  = ham
    # ------------------------------------------------------------------
    # SpamAssassin için kullanıcı bazında ayarların kullanımını mümkün
    # kılmak için aşağıdaki satırı devreye alıp "spam = mail" satırını
    # iptal ediniz.
    # Alıcı adresinin kullanıcı adını SpamAssassin'e aktaralım.
    # Bunun için adresin '=' veya '@' karakterinden önceki kısmını
    # küçük harfe dönüştüreceğiz. Evvelce bir defadaki alıcı sayısını
    # önceden bir ile sınırladığımızdan çok sayıda alıcı olmayacak.
    #
    # spam        = ${lc:${extract{1}{=@}{$recipients}{$value}{mail}}}
    # ------------------------------------------------------------------
    spam        = mail
    set acl_m9  = spam
    condition   = ${if !eq {$acl_m0}{accept}{true}}
    control     = fakereject
    logwrite    = :reject: Rejected spam (score $spam_score): $spam_report



  # İletinin başlığına bir X-Spam-Status: satırı ekleyelim.
  #
  warn
    message     = X-Spam-Status: \
                  ${if eq {$acl_m9}{spam}{Yes}{No}} (score $spam_score)\
                  ${if def:spam_report {: $spam_report}}
    logwrite    = :main: Classified as $acl_m9 (score $spam_score)


  # --- EXISCAN yapılandırmasının SONU ---


  # İletiyi kabul ediyoruz.
  #
  accept
</screen>
      </para>
    </sect2> <!-- acl_data -->
  </sect1> <!-- Final ACLs -->
</appendix>

<glossary id="spam-filtering-glossary">
  <title>Terimler Sözlüğü</title>
  <simpara>
Burada, belge içinde kullanılan bazı terimlerin tanımlarına yer verilmiştir.
  </simpara>
    <glossentry id="spam-filtering-openrelay">
      <glossterm><emphasis role="bold">Açık Röle</emphasis></glossterm>
      <glossdef><para>(İng.: Open Relay)
Her yerden açıkça posta kabul eden ve bu postaları heryere gönderen bir <xref linkend="spam-filtering-relay"/> çeşidi.
      </para><para>
1980'lerde sanal olarak her SMTP sunucusu birer açık röle idi. İletileri çoğunlukla tüm makineler kabul eder ve yerlerine gönderirdi. Şimdilerde ise, meşru postalar özellikle doğrudan gönderici uçtaki bir <xref linkend="spam-filtering-mta"/> tarafından gönderilmekte ve alıcının alan adı için tahsis edilmiş <link linkend="spam-filtering-mx">Posta Alıcıları</link> tarafından kabul edilmektedir.
      </para><para>
Hala internette röle işlemine açık sunucular bulunmakta ve bunlar şans eseri DNS karalistelerine girene kadar, özellikle kimliklerini gizlemek isteyen spamcılar tarafından istismar edilmekte, çoğunlukla da milyonlarca iletiyi gönderirken yükü dağıtmak amacıyla kullanılmaktadırlar.
      </para><para>
Ayrıca <xref linkend="spam-filtering-relayprevent"/> bölümüne de bakınız.
        </para>
      </glossdef>
    </glossentry><glossentry id="spam-filtering-openproxy">
      <glossterm><emphasis role="bold">Açık Vekil</emphasis></glossterm>
      <glossdef><para>(İng.: Open Proxy)</para><para>
Her yerden açıkça TCP/IP bağlantısı kabul eden ve bunları her yere yönlendiren bir <xref linkend="spam-filtering-proxy"/> çeşidi.
      </para><para>
Bunlar, IP adreslerine gizli tutmak isteyen ve/veya yükü çeşitli konaklara ve ağlara daha verimli olarak dağıtmak isteyen spamcılar ve virüsler tarafından istismar edilirler.
      </para><para>
Ayrıca bakınız: <xref linkend="spam-filtering-zombie" />
        </para>
      </glossdef>
    </glossentry><glossentry id="spam-filtering-rfc">
      <glossterm><emphasis role="bold">Açıklama İsteği</emphasis></glossterm>
      <glossdef><para>
(İng.: Request for Comments - <emphasis>RFC</emphasis>)
      </para><para>
<ulink url="http://www.rfc-editor.org/"/>'daki tanımı:
      </para><para><blockquote><para>
Açıklama İsteği (RFC) belgeleri internet hakkında teknik ve organizasyonel bilgiler içeren belgelerdir [...].  RFC serisindeki açıklamalar, bilgisayar ağları ile ilgili protokoller, yordamlar,  programlar ve kavramlar hakkında bilgiler yanında bu konularda yapılmış toplantılardan elde edilmiş notlar, fikirler ile biraz da mizahi unsurlar içerir.
     </para></blockquote></para><para>
Bu belgeler protokollerin veri biçimlerinin açıklamalarını yaparak internet yönetimi ile ilgili kuralları oluşturur. Özellikle posta teslimatçıları ile ilgili olanlar:
     </para><para><itemizedlist>
<listitem><link linkend="rfc2821">RFC 2821</link>, "Simple Mail transfer Protocol" (Basit Posta Aktarım Protokolü),</listitem>
<listitem><link linkend="rfc2822">RFC 2822</link>, "Internet Message Format" (Genel Ağ İleti Biçimi).</listitem>
     </itemizedlist></para></glossdef>
    </glossentry><glossentry id="spam-filtering-bayesian">
      <glossterm><emphasis role="bold">Bayes Filtreleri</emphasis></glossterm>
      <glossdef><para>(İng.: Bayesian Filters)</para><para>
İleti içinde geçen sözcüklere ve sözcüklerin dizilişlerine bakarak iletinin spam olma olasılığıyla ilgili bir derecelendirme yapan bir filtre.
      </para><para>
Meşru (ham) ve gayrimeşru (spam) iletileri belirterek bu filtreyi eğitebilirsiniz. Bu iletilerde (ham ve spam) geçen sözcüklerin bulunma sıklığına bağlı olarak her sözcüğe veya deyime bir puan verilir. Bu sözcükler ve puanları <emphasis>Bayes indeksinde</emphasis> saklanır.
      </para><para>
Bu tür filtreler, yazılımcılar tarafından el yordamıyla oluşturulan anahtar sözcük tabanlı filtrelerden kaçanları yakalayabilmektedir. Çünkü bu işlemi özdevimli hale getirmektedirler.
      </para><para>
Bayes sözcük indeksleri çoğunlukla eğitildikleri dile özeldirler. Hatta kullanıcıya özeldirler. Bu bakımdan sistem çapında, SMTP sırasında yapılan filtrelemeden ziyade kişisel içerik filtrelemesine uygundurlar (bkz. <xref linkend="spam-filtering-mua"/>).
      </para><para>
Ancak, spamcılar iletilerine kısa hikayeler ve sözlükten rasgele seçilmiş sözcükler  ekleyerek basit bayes filtrelerini etkisiz kılacak teknikler geliştirdiler. Bu, bayes filtrelerinin atadığı spam puanını düşürerek uzun vadede bayes indeksinin kalitesini düşürmektedir.
      </para><para>
Ayrıca bakınız: <ulink url="http://www.everything2.com/index.pl?node=Bayesian"/>.
      </para></glossdef>
    </glossentry><glossentry id="spam-filtering-dns">
      <glossterm><emphasis role="bold">Alan Adı Sistemi</emphasis></glossterm>
      <glossdef><para>
(İng.: Domain Name System - <emphasis>DNS</emphasis>)
      </para><para>
İnternet alan adları hakkında bilgi sağlayan fiili standart. Bu bilgilere örnek olarak, sunucuların IP adresleri (<emphasis>A kayıtları</emphasis>), posta alıcılarının adları (<emphasis>MX kayıtları</emphasis>), genel sunucu bilgileri (<emphasis>SRV kayıtları</emphasis>) ve muhtelif dizgesel bilgiler (<emphasis>TXT kayıtları</emphasis>) verilebilir.
       </para><para>
DNS, hiyerarşik ve dağıtık bir sistemdir; Her alan adı içerdiği her alt alan adı ile ilgili bilgileri içeren bir veya daha fazla sayıda DNS sunucusu ile ilişkilendirilir.
       </para><para>
Örneğin, üst seviye alan adı olarak <quote>org</quote> The Public Interest Registry tarafından işleme sokulur; onun DNS sunucuları <quote>tldp.org</quote> alan adı sorguları için Linux Belgelendirme Projesine özel isim sunucularını görevlendirir. Sonuçta, TLDP isim sunucuları (aslında UNC sunucuları) <quote>www.tldp.org</quote> için ya bu alana ait bilgileri döndürür ya da bu alan adıyla ilgili bir alt seviye isim sunucusunu görevlendirir.
      </para><para>
DNS sorguları genelde, sorgular bir internet servis sağlayıcının isim sunucularına yönlendirilerek (örn. DHCP üzerinden) gerçekleştirilir.
      </para></glossdef>
    </glossentry><glossentry>
      <glossterm><emphasis role="bold">Bal Çanağı</emphasis></glossterm>
      <glossdef><para>(İng.: Honeypot<footnote><para>"Bal Çanağı" özgün belgede yoktur. Çevirmen tarafından eklenmiştir.</para></footnote> - <emphasis>Sugarcane</emphasis>)</para><para>
Bir bal çanağı bilgi sistemlerini yetkisiz kullanmaya çalışanları saptamak ya da caydırmak amacıyla kurulan bir tuzaktır. Genelde saldırgan açısından değerli olabilecek bir bilgi içeriyormuş gibi görünen bir bilgisayardan, bir veri parçasından ya da bir ağ parçasından oluşur ve bir ağın parçasıymış gibi görünmesine rağmen ağdan yalıtılmış ve korunmuştur. Bunların açık vekil gibi davrananlarına şekerkamışı ismi verilir.
      </para><para>
Daha ayrıntılı bilgi için <ulink url="http://spamlinks.net/track-trace-honeypot.htm"/> adresine bakınız.
      </para></glossdef>
    </glossentry><glossentry id="spam-filtering-coldamage">
      <glossterm><emphasis role="bold">Çevresel Bozunma</emphasis></glossterm>
      <glossdef><para>(İng.: Collateral Damage)</para><para>
Bir meşru gönderici konağın bir DNS karalistesindeki bir girdiden dolayı engellenmesi.
      </para><para>
Bazı karalisteler (SPEWS gibi) şikayetler karşısında duyarsız davranan servis sağlayıcılarını, <emphasis>tüm</emphasis> müşterilerini de kapsayacak şekilde, bir IP bloğu halinde veritabanlarına kaydederler.
      </para><para>
Ayrıca bakınız: <xref linkend="spam-filtering-falsepos"/>
        </para>
      </glossdef>
    </glossentry><glossentry id="spam-filtering-colspam">
      <glossterm><emphasis role="bold">Dolaylı Spam</emphasis></glossterm>
      <glossdef><para>(İng.: Collateral Spam)</para><para>
Gönderici adresi taklit edilerek bir özgün iletiye yanıt gibi gönderilen otomatikleştirilmiş iletiler. Dolaylı spama örnek olarak virüs tarama raporları (<quote>Virüs bulundu</quote>) veya <link linkend="spam-filtering-dsn">teslimat durum bildirimleri</link> verilebilir.
      </para></glossdef>
    </glossentry><glossentry id="spam-filtering-micropay">
      <glossterm><emphasis role="bold">Gönderici ücretlendirme şemaları</emphasis></glossterm>
      <glossdef><para>
(İng.: Micropayment Schemes -- <emphasis>sender pay</emphasis> schemes)
      </para><para>
Bir iletinin her alıcısı için bir sanal <emphasis>posta damgası</emphasis> oluşturmak adına bazı makine kaynaklarını kullanma karşılığı olarak göndericinin ücret ödemesi şeklinde çalışan bir sistem. Bu posta damgası büyük miktarda bellek okuma/yazma işlemleri gerektiren bir matematiksel kimlik kanıtlama işleminin çözümlemesinin sonucudur. Bu damga iletinin başlığına eklenir ve alıcı bu damgayı daha basit bir kod çözme işlemi ile doğrulatır.
      </para><para>
Ana fikir, iletinin her alıcısı için bir posta damgası gerektirmesi nedeniyle böyle bir sistemde yüzlerce binlerce kişiye spam göndermenin oldukça pahalıya malolacak olmasıdır.
      </para><para>
Böyle iki sistem vardır:
        </para><para>
        <itemizedlist><listitem>
<ulink url="http://www.camram.org/">Camram</ulink>
        </listitem><listitem>
<ulink url="http://research.microsoft.com/research/sv/PennyBlack/">Microsoft's Penny Black Project</ulink>
        </listitem></itemizedlist><para/>
      </para></glossdef>
    </glossentry><glossentry id="spam-filtering-falsepos">
      <glossterm><emphasis role="bold">Hatalı Olumlama</emphasis></glossterm>
      <glossdef><para>(İng.: False Positive)</para><para>
Yanlışlıkla gayrimeşru posta olarak sınıflandırılmış (dolayısıyla engellenmiş) meşru posta.
        </para><para>
Ayrıca bakınız: <xref linkend="spam-filtering-coldamage"/>.
        </para>
      </glossdef>
    </glossentry><glossentry id="spam-filtering-falseneg">
      <glossterm><emphasis role="bold">Hatalı Olumsuzlama</emphasis></glossterm>
      <glossdef><para>(İng.: False Negative)</para><para>
Yanlışlıkla meşru posta olarak sınıflandırılmış (dolayısıyla filtrelenmemiş) gayrimeşru posta (spam, virüs, kötücül yazılım).
        </para>
      </glossdef>
    </glossentry><glossentry id="spam-filtering-joejob">
      <glossterm><emphasis role="bold">Joe İşi</emphasis></glossterm>
      <glossdef><para>
Çoğunlukla üçüncü şahıslar nezdinde adres sahibine zarar vermek, hakkında yanlış kanaatler uyandırmak için onun geçerli adresinden geliyormuş gibi görünmek üzere tasarlanmış bir spam türü.
        </para><para>
Ayrıca bakınız: <ulink url="http://www.everything2.com/index.pl?node=Joe%20Job"/>
      </para></glossdef>
    </glossentry><glossentry id="spam-filtering-ratware">
      <glossterm><emphasis role="bold">Kalleş Yazılım</emphasis></glossterm>
      <glossdef><para>(İng.: Ratware)</para><para>
Çok kısa bir sürede büyük miktarlarda postayı teslim etmek üzere tasarlanmış spamcılar tarafından kullanılan eposta yazılımı ve postalama virüsleri.
      </para><para>
Çoğu kalleş yazılım gerçeklenimi en iyi senaryo altında mümkün olduğunca sadece posta teslimatı için gerekli olan SMTP istemci koduyla işbirliğine girer. Alıcı konakla yaptıkları SMTP diyaloğunda yanlış veya belli-belirsiz bilgi verirler. Komutları göndermek için alıcının yanıtını beklemezler ve eğer alıcı taraftan birkaç saniye içinde bir yanıt alamazlarsa, bağlantıyı keserler. Geçici hataların oluşması durumunda işlem yineleme mekanizmasını kullanmazlar.
      </para></glossdef>
    </glossentry><glossentry id="spam-filtering-fqdn">
      <glossterm><emphasis role="bold">Nitelikli Alan Adı</emphasis></glossterm>
      <glossdef><para>
(İng: Fully Qualified Domain Name - <quote>FQDN</quote>)
      </para><para>
DNS alanını da içeren, küresel olarak eşsiz internet ismi. Örneğin: <quote>www.belgeler.org</quote>.
      </para><para>
Nitelikli bir alan adı her zaman tek bir makineyi göstermez. Örneğin, yük dengelemesi amacıyla bazı hizmetler sunuculara dağıtılır, dolayısiyle <quote>www</quote> gibi hizmet isimleri çok sayıda IP adresini gösterebilir. Yine de, belli bir makinenin birincil konak ismi o makineye özel olmalıdır; örneğin: <quote>p16.www.scd.yahoo.com</quote>.
        </para><para>
Nitelikli bir alan adı daima bir nokta (".") içerir. İlk noktadan önceki parça küresel olarak eşsiz olmayan <emphasis>niteliksiz isimdir</emphasis>.
        </para>
      </glossdef>
    </glossentry><glossentry id="spam-filtering-mta">
      <glossterm><emphasis role="bold">Posta Aktarımcısı</emphasis></glossterm>
      <glossdef><para>
(İng.: Mail Transport Agent - <emphasis>MTA</emphasis>)
      </para><para>
Bir posta sunucusunda çalışan, internet alanının posta alıcısı olarak davranabilen diğer konaklarla posta alışverişi yapabilen bir yazılım. Sendmail, Postfix, Exim ve Smail tanınmış posta aktarımcıları arasında sayılabilir.
      </para></glossdef>
    </glossentry><glossentry id="spam-filtering-mx">
      <glossterm><emphasis role="bold">Posta Alıcısı</emphasis></glossterm>
      <glossdef><para>
(İng.: Mail Exchanger - <emphasis>MX</emphasis>)
      </para><para>
Özellikle, bir internet alanına gelen postaları almaya (bazan göndermeye de) adanmış bir makine.
      </para><para>
Bir internet alanının DNS bilgileri normalde, bu alan için gelen postaları alacak makinelerin bir listesini içerir. Bu listeye <quote>MX kaydı</quote> denir ve öncelik sırasını belirten bir numarayla imlenmiş makine isimleri içerir. Listedeki en küçük numaralı makine postaları almada en yüksek önceliğe sahip makine kabul edilir ve bu makineye <quote>birincil posta alıcısı</quote> denir.
      </para></glossdef>
    </glossentry><glossentry id="spam-filtering-loop">
      <glossterm><emphasis role="bold">Posta Döngüsü</emphasis></glossterm>
      <glossdef><para>(İng.: Mail Loop -- <emphasis>Ringing</emphasis>)</para><para>
Bir özdevinimli iletinin bir diğerini tetiklemesiyle dolaylı veya doğrudan ilk iletinin tekrar tetiklenmesiyle süregiden bir durum.
      </para><para>
Üyelerinden birinin adresinin o eposta listesinin adresi olduğu durum buna bir örnek olarak verilebilir.  Bu gibi durumların üstesinden, liste sunucusu tarafından iletinin başlığına bir <quote>X-Loop:</quote> satırı eklenerek gelinir; bu satırı içeren bir posta tekrar işleme sokulmaz.
      </para></glossdef>
    </glossentry><glossentry id="spam-filtering-mua">
      <glossterm><emphasis role="bold">Posta İstemcisi</emphasis></glossterm>
      <glossdef><para>
(İng.: Mail User Agent - <emphasis>MUA</emphasis> veya <emphasis>Mail Reader</emphasis>)
      </para><para>
Posta alma, gönderme, indirme, erişim gibi yetenekleri olan kullanıcı yazılımı. Örneğin, Microsoft Outlook/Outlook Express, Apple Mail, Mozilla Thunderbird, Ximian, Evolution, KMail.
      </para></glossdef>
    </glossentry><glossentry id="spam-filtering-mda">
      <glossterm><emphasis role="bold">Posta Teslimatçısı</emphasis></glossterm>
      <glossdef><para>
(İng.: Mail Delivery Agent - <emphasis>MDA</emphasis>)
      </para><para>
Kullanıcıların posta kutularının bulunduğu makinede çalışan, görevi postaları bu eposta kutularına teslim etmek olan yazılım. Bu teslimat çoğunlukla <xref linkend="spam-filtering-mta"/> tarafından ikincil bir görev olarak yerine getirilir. Sadece posta teslimatçısı olan yazılımlara, Deliver, Procmail, Cyrmaster ve/veya Cyrdeliver (Cyrus IMAP ailesinden) örnek verilebilir.
      </para></glossdef>
    </glossentry><glossentry id="spam-filtering-relay">
      <glossterm><emphasis role="bold">Röle</emphasis></glossterm>
      <glossdef><para>
Bir epostayı internetten alıp internete gönderen bir makine. Röleye örnek olarak bir servis sağlayıcının müşterilerine epostalarını gönderebilmeleri için tahsis ettiği konak (<quote>smarthost</quote>) gösterilebilir.
      </para><para>
Ayrıca bakınız: <xref linkend="spam-filtering-openrelay"/>, <xref linkend="spam-filtering-proxy"/>
        </para>
      </glossdef>
    </glossentry><glossentry id="spam-filtering-spamtrap">
      <glossterm><emphasis role="bold">Spam Tuzağı</emphasis></glossterm>
      <glossdef><para>
(İng.: Spam Trap)</para><para>
Kamuya açık alanlardan eposta adresi toplayan robotları <emphasis>yemlemekte</emphasis> kullanılan bir eposta adresi. Tuzağa yakalananlar <xref linkend="spam-filtering-dnsbl"/> ve <xref linkend="spam-filtering-jmsr"/> gibi dost araçları beslemekte kullanılır.
      </para><para>
Bu adreslere gönderilmiş postalar normal olarak ya spamdır ya da kötücül yazılımdır. Ancak bazıları dolaylı spam olacaktır - gönderici adreslerinin taklit edilmesi durumu (<xref linkend="spam-filtering-dsn"/>). Bu tür (dolaylı spam) iletilerin spam olarak kayda geçirilmemesi için gerekli önlemler alınmış olmalıdır, aksi taktirde spam tuzağı
güvenilir olmayacaktır.
      </para></glossdef>
    </glossentry><glossentry id="spam-filtering-dsn">
      <glossterm><emphasis role="bold">Teslimat Durum Bildirimi</emphasis></glossterm>
      <glossdef><para>
(İng.: Delivery Status Notification, <emphasis>DSN</emphasis>)
      </para><para>
Bir özgün iletinin göndericisini durum hakkında bilgilendirmek için bir <xref linkend="spam-filtering-mta"/> veya <xref linkend="spam-filtering-mda"/> tarafından özdevinimli olarak oluşturulan bir ileti.  Teslimat Durum Bildirimleri genelde, bir iletinin geçici veya kalıcı bir sorundan dolayı teslim edilemediği ve/veya bir süre daha bu teslimatın gerçekleştirilmesinin denenip denenmeyeceğini hakkında özgün iletinin göndericisine bilgi vermek için gönderilir.
        </para><para>
Teslimat Durum Bildirimleri bir boş <xref linkend="spam-filtering-envfrom"/> adresiyle gönderilir.
      </para></glossdef>
    </glossentry><glossentry id="spam-filtering-proxy">
      <glossterm><emphasis role="bold">Vekil</emphasis></glossterm>
      <glossdef><para>
Başkalarının yararına çalışan bir makine. TCP/IP bağlantıları ya da HTTP istekleri için genellikle internet adresleriyle ilgili yönlendirme yapar. Örneğin, şirketlerin - bazan bir ülkenin tamamının - dahili ağlarından yapılan HTTP isteklerini filtrelemek için sıkça kullanılır. Bundan, son kullanıcının haberi olabileceği gibi olmayabilir de.
      </para><para>
Ayrıcı bakınız: <xref linkend="spam-filtering-openproxy" />, <xref linkend="spam-filtering-relay" />.
        </para>
      </glossdef>
    </glossentry><glossentry id="spam-filtering-envto">
      <glossterm><emphasis role="bold">Zarf Alıcısı</emphasis></glossterm>
      <glossdef>
        <para>(İng.: Envelope Recipient)</para><para>
İletinin gönderildiği e-posta adres(ler)i. Bunlar SMTP aktarımı sırasında <command>RCPT TO</command> komutuyla kullanılır. Bu adres(ler) iletinin <quote>To:</quote> ve <quote>Cc:</quote> başlıklarında belirtilenden farklı adres(ler) olabilir.
        </para><para>
Ayrıca bakınız: <xref linkend="spam-filtering-smtpintro"/>
        </para>
      </glossdef>
    </glossentry><glossentry id="spam-filtering-envfrom">
      <glossterm><emphasis role="bold">Zarf Göndericisi</emphasis></glossterm>
      <glossdef><para>(İng.: Envelope Sender)</para><para>
Bir iletinin SMTP aktarımı sırasında, <command>MAIL FROM:</command> komutunda gönderici olarak belirtilen e-posta adresi. Bu adres iletinin <quote>From:</quote> başlığında belirtilenden farklı bir adres olabilir.
        </para><para>
Tek özel durum <xref linkend="spam-filtering-dsn"/> (gönderici adresi olmayan [bounced] ileti, return receipt, vacation message..) durumudur. Böyle postalar için <xref linkend="spam-filtering-envfrom"/> boştur. Bu genellikle, <xref linkend="spam-filtering-loop"/>nden kaçınmak ve bunları <quote>normal</quote> postalardan ayırmayı mümkün kılmak için yapılır.
        </para><para>
Ayrıca bakınız: <xref linkend="spam-filtering-smtpintro"/>
        </para>
      </glossdef>
    </glossentry><glossentry id="spam-filtering-zombie">
      <glossterm><emphasis role="bold">Zombi Konak</emphasis></glossterm>
      <glossdef><para>(İng.: Zombie Host)</para><para>
Postalama virüsleri veya kurtları bulaşmış internete bağlı bir makine. Bu makineler değişmez bir şekilde Microsoft® Windows® ailesinden bir işletim sistemi kullanan makinelerdir ve hemen hemen daima mahalli IP adres bloklarındadırlar. Bunların sahiplerinin makinelerine virüs bulaştığından ya haberleri yoktur ya da önemsemiyorlardır ve çoğunlukla da bunların servis sağlayıcıları bunlara hizmet vermemek gibi bir önleme başvurmaz.
      </para><para>
Bu sebeplerden, böyle "mahalli" adres bloklarını veritabanlarına ekleyen <quote>dul.dnsbl.sorbs.net</quote> gibi bazı DNS karalisteleri vardır. Böyle servis sağlayıcılardan hizmet alanlar meşru postalarını göndermek için normalde servis sağlayıcının posta sunucusunu kullandıklarından mahalli adreslerden gelen postaları reddetmek için bu karalisteleri kullanmalısınız.
      </para></glossdef>
    </glossentry>
  </glossary>
</article>
