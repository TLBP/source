<?xml version="1.0" encoding="UTF-8"?>
<!-- ********************************************************************
     $Id: ncurses-howto.xml,v 1.20 2003/07/19 09:25:04 nilgun Exp $
     ******************************************************************** -->
<article xml:id="ncurses-howto" lang="tr">
<info>
    <title>NCURSES ile Yazılım Geliştirme NASIL</title>
    <authorgroup>
      <author>
       <personname><firstname>Pradeep</firstname>
        <surname>Padala</surname></personname>
      </author><author role="translator">
       <personname><firstname>Oğuz Yarımtepe</firstname>
      </author>
    </authorgroup>
     <pubdate>Ekim 2005</pubdate>
    <revhistory><title>Bu çevirinin sürüm bilgileri:</title>
      <revision>
        <revnumber>1.0</revnumber>
        <date>Aralık 2005</date>
        <authorinitials>OY</authorinitials>
        <revremark>İlk çeviri</revremark>
      </revision>
    </revhistory>
    <revhistory><title>Özgün belgenin sürüm bilgileri:</title>
      <revision>
        <revnumber>1.9</revnumber>
        <date>2005-06-20</date>
        <authorinitials>ppadala</authorinitials>
        <revremark>
Lisans NCURSES tarafından kullanılan MIT-türü lisansa dönüştürüldü. Program da bunun altında tekrar lisanslandırıldı.
        </revremark>
    </revision>

    <revision>
        <revnumber>1.8</revnumber>
        <date>2005-06-17</date>
        <authorinitials>ppadala</authorinitials>
        <revremark>
Pekçok güncelleme yapıldı. Referanslar ve perl örnekleri eklendi. Pekçok dil bilgisi ve stil değişikliği içeriğe eklendi. NCURSES tarihçesinde değişiklik yapıldı.
        </revremark>
    </revision>

    <revision>
        <revnumber>1.7.1</revnumber>
        <date>2002-06-25</date>
        <authorinitials>ppadala</authorinitials>
        <revremark>
Kaynak koddan kurulum için README dosyası ve talimatlar eklendi.
        </revremark>
    </revision>

    <revision>
        <revnumber>1.7</revnumber>
        <date>2002-06-25</date>
        <authorinitials>ppadala</authorinitials>
        <revremark>
"Diğer biçimler" kısmı eklendi ve programda pekçok hoş görünümlü değişiklik yapıldı. Satır içi programlar çıkarıldı.
        </revremark>
    </revision>

    <revision>
        <revnumber>1.6.1</revnumber>
        <date>2002-02-24</date>
        <authorinitials>ppadala</authorinitials>
        <revremark>Eski Değişiklik Kaydı (Changelog) kısmı çıkarıldı, programı oluşturmak için kullanılan dosyalar (makefiles) temizlendi.
        </revremark>
    </revision>

    <revision>
        <revnumber>1.6</revnumber>
        <date>2002-02-16</date>
        <authorinitials>ppadala</authorinitials>
        <revremark>Pekçok yazım hatası düzeltildi, ACS değişkenleri eklendi</revremark>
    </revision>

    <revision>
        <revnumber>1.5</revnumber>
        <date>2002-01-05</date>
        <authorinitials>ppadala</authorinitials>
        <revremark>Yapı şu anki uygun TOC (İçerik Tablosu) yapısına dönüştürüldü</revremark>
    </revision>

    <revision>
        <revnumber>1.3.1</revnumber>
        <date>2001-07-26</date>
        <authorinitials>ppadala</authorinitials>
        <revremark>Paket yapımcılarıyla ilgili paragraf düzeltildi, kararlı sürüm numarası düzeltildi.
        </revremark>
    </revision>

    <revision>
        <revnumber>1.3</revnumber>
        <date>2001-07-24</date>
        <authorinitials>ppadala</authorinitials>
        <revremark>
        Ana belgeye (LDP lisansı) ve programalara (GPL lisansı) lisans bilgisi eklendi, printw_ örneği düzeltildi.
        </revremark>
    </revision>

    <revision>
        <revnumber>1.2</revnumber>
        <date>2001-06-05</date>
        <authorinitials>ppadala</authorinitials>
        <revremark>
        Ravi'nin daha çok giriş, menu, form ve sadece eğlenmek için ile ilgili değiklikleri uygulandı.
        </revremark>
    </revision>

    <revision>
        <revnumber>1.1</revnumber>
        <date>2001-05-22</date>
        <authorinitials>ppadala</authorinitials>
        <revremark>
        "pencere hakkında bir çift söz" kısmı eklendi, scanw_ örneği eklendi.
        </revremark>
    </revision>

    </revhistory>
    <pubdate>v1.9, 2005-06-20</pubdate>
    <abstract><para>
Bu belge ncurses ve kardeş kütüphaneleriyle yazılım geliştirmek için "Herşey Dahil"  bir kılavuz olmayı hedeflemektedir. Basit bir "Merhaba Dünya" programından başlayıp daha karmaşık yapılara doğru giden bir anlatım kullandık. Ncurses ile ilgili herhangi bir ön deneyim gerekli değildir.
    </para></abstract>
<copyright><year>2001 - 2004</year><holder>Pradeep Padala - Özgün belge</holder></copyright> 
<copyright><year>2005</year><holder>Oğuz Yarımtepe - Türkçe çeviri</holder></copyright>
    <legalnotice><title>Yasal Açıklamalar</title>
      <para>
Bu belgenin, <emphasis>NCURSES ile Yazılım Geliştirme NASIL</emphasis> çevirisinin 1.0 sürümünün <emphasis role="bold">telif hakkı © 2005 <emphasis>Oğuz Yarımtepe</emphasis>'ye</emphasis>, özgün İngilizce sürümünün  <emphasis role="bold">telif hakkı © 2001-2004 <emphasis>Pradeep Padala</emphasis>'ya</emphasis> aittir.
  </para><para>
Bu yazılımın bir kopyasını ve beraberindeki belgelendirmeleri edinen herhangi birine sınırlama olmaksızın kullanma, kopyalama, değiştirme, birleştirme, yayınlama, dağıtma, değiştirerek dağıtma, alt lisanslar oluşturma ve/veya yazılımın kopyalarını satma ve bu yazılıma sahip olanlara da aynı hakları sağlayacak şekilde yazılım ile ilgilenme izni bedelsiz olarak aşağıdaki durumlar altında sağlanmıştır:
</para><para>
Yukarıdaki telif hakkı ve bu izin uyarısı bu belgenin tüm kopyalarında ve yazılımın esas bölümlerinde belirtilmelidir.
</para>
&notice.disc;
<para>
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, distribute with
modifications, sublicense, and/or sell copies of the Software, and to permit
persons to whom the Software is furnished to do so, subject to the following
conditions:
</para><para>
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
</para>
<para>
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
</para><para>
Except as contained in this notice, the name(s) of the above copyright holders
shall not be used in advertising or otherwise to promote the sale, use or
other dealings in this Software without prior written authorization.
</para>
  </legalnotice>
</info>

<sect1 xml:id="ncurses-howto-intro"> <title>Giriş</title>
<para>
Aptal uçbirimlerin olduğu eski zamanlarda, uçbirimler bilgisayarlardan uzakta ve onlara bağlantıları seri kablolar ile idi. Uçbirimler seri şekilde bayt verileri göndermek için ayarlanabiliyordu. Uçbirimlerin tüm bu yetenekleri (imleci yeni bir noktaya taşımak, ekranın belli bir kısmını silmek, ekranda gezinmek, durumlar arası geçişler, v.b. gibi) seri şekilde gönderilen bu baytlar ile sağlanmaktaydı. Bu denetim ardışılları genelde kaçış tuşu dizisi olarak adlandırılırdı, çünkü kaçış karakteri olan (0x1B) ile başlamaktaydı. Şimdi bile uygun bir benzetim ile benzeticiye kaçış karakterlerini göndererek uçbirim penceresinde aynı etkiyi oluşturabiliriz.
</para><para>
Bir satırı renkli olarak yazmak istediğinizi düşünelim. Konsolda şunu yazmayı deneyin.
</para><para>
<programlisting>
echo -e "\033[1;37;44mRenkli"
</programlisting>
</para><para>
Baştaki "\033[" dizgesi kaçış karakteridir. Diğer karakterler ekrana yazılabilir karakterlerdir. Sonucu mavi zemin üzerine beyaz "Renkli" olarak görüyor olmalısınız. Bu renklendirme, bu şekilde kalır, eski haline dönmek için şunu yazın:
</para><para>
<programlisting>
echo -e "\033[0;39;49mRenkli"
</programlisting>
</para><para>
Şimdi, bu sihirli karakterler de ne anlama geliyor? Anlaması zor mu? Bunlar farklı uçbirimler için farklı bile olabilir. Bunun için UNIX'ı tasarlayanlar <command>termcap</command> isimli bir mekanizma bulmuşlardır. Belli bir uçbirimin tüm yetenekleri ile belli bir etkiyi elde etmek için gerekli kaçış karakterlerini listeleyen bir dosyadır. Sonraki yıllarda bu <command>terminfo</command> ile yer değiştirmiştir. Çok fazla ayrıntıya inmeden, bu mekanizma uygulama programlarının terminfo veritabanını sorgulamasını ve uçbirime veya uçbirim benzeticisine gönderilecek denetim karakterlerini edinmelerini sağlar, demekle yetineceğiz.
</para>

<sect2 userlevel="chunkthis" xml:id="ncurses-howto-whatis"> <title>NCURSES nedir?</title>
<para>
Tüm bu teknik saçmalıkların ifade edilmesinin nedenini merak ediyor olabilirsiniz. Yukarıdaki senaryoda her uygulama programının terminfo'yu sorgulaması ve gerekli işlemleri yapması gerekmektedir (denetim karakterlerinin gönderilmesi v.s.). Bu karmaşıklıkla uğraşmak bir süre sonra zorlaştı ve bu da 'CURSES''ın doğmasına sebep oldu. Curses "imleç eniyileme" ("cursor optimization") anlamına gelen bir kelime oyunudur. Curses kütüphanesi ham uçbirim kodları ile çalışırken onları sarmalayıcı bir yapı ve verimli bir API (Uygulama Programlama Arayüzü) oluşturmaktadır. İmleci hareket ettirmek, pencereler oluşturmak, renkler üretmek, fare ile oynamak v.b. için işlevler sağlamaktadır. Uygulama programları alt kısımdaki uçbirim yeteneklerini düşünmek zorunda kalmazlar.
</para><para>
Yani NCURSES ne demektir? Asıl System V gözden geçirme 4.0 (SVr4) curses'ın bir kopyasıdır. Özgür olarak dağıtılan ve eski curses sürümleriyle tamamen uyumlu olan bir kütüphanedir. Kısacası, bir uygulamanın karakter tabanlı uçbirimlerde görüntüleri üzerinde çalışabilmeyi sağlayan işlevler kütüphanesidir. Belgenin geri kalanında, curses ve ncurses birbirleri yerine kullanılmıştır.
</para><para>
NCURSES hakkındaki ayrıntılı bilgi kaynak dağıtımındaki NEWS dosyasından bulunabilir. Şu anki paket Thomas Dickey tarafından geliştirilmektedir. Paketi hazırlayanlarla <email>bug-ncurses@gnu.org</email> adresinden iletişime geçebilirsiniz.
</para>
</sect2>
<sect2 userlevel="chunkthis" xml:id="ncurses-howto-whatcanwedo"> <title>NCURSES ile Ne Yapabiliriz?</title>
<para>
NCURSES sadece uçbirim yetenekleri sarmalayan bir yapı oluşturmaz aynı zamanda metin kipinde hoş görüşünüşlü arayüzler oluşturmak için sağlam bir çalışma taslağı da oluşturur. Pencereler v.b. görünümleri oluşturmak için işlevler sağlar. Kardeş kütüphaneleri olan panel, menu ve form, temel curses kütüphanesine bir genişleme sağlar. Bu kütüphaneler genelde curses kütüphanesiyle beraber gelmektedir. Pekçok pencere, menu, panel ve formlar içeren bir uygulama oluşturulabilir. Pencereler üzerinde bağımsız olarak çalışılabilir, gezinilebilir ve hatta pencereler gizlenebilir.
</para><para>
Menüler kullanıcıya kolay şekilde komut seçimini sağlamaktadır. Formlar kolay kullanımlı veri girişi ve pencere görünümleri oluşturulmasına izin verir. Paneller ncurses'ın yeteneklerini üst üste binmiş ve yığılmış pencereler ile uğraşabilmeyi sağlar.
</para><para>
Tüm bunlar ncurses ile yapabileceğimiz bazı temel şeylerdir. Devam ettikçe tüm bu kütüphanelerin yeteneklerini göreceğiz.
</para>
</sect2>
<sect2 userlevel="chunkthis" xml:id="ncurses-howto-wheretogetit"><title>Nereden Edinilebilir?</title>
<para>
Tamam, artık ncurses ile ne yapabileceğinizi biliyorsunuz, başlamaya yaklaşmalısınız. NCURSES genelde yüklediğiniz dağıtım ile gelmektedir. Kütüphaneye sahipseniz veya onu kendiniz derlemek istiyorsanız okumaya devam edin.
</para><para><variablelist><varlistentry>
<term>Paketin derlenmesi</term>
<listitem><para>
NCURSES <link xlink:href="ftp://ftp.gnu.org/pub/gnu/ncurses/ncurses.tar.gz"/> adresinden veya <link xlink:href="http://www.gnu.org/order/ftp.html"/> adresinde belirtilen ftp adreslerinden edinilebilir.
</para><para>
Yüklemek için README ve INSTALL dosyalarını dikkatlice okuyunuz. Genelde aşağıdaki adımları içermektedir.
</para><para>
<programlisting>
tar zxvf ncurses-<emphasis>sürüm</emphasis>.tar.gz           # arşivi açın
cd ncurses-<emphasis>sürüm</emphasis>                        # oluşan dizine geçin
./configure                             # ortam değişkenlerinize göre
                                        # yapılandırın
make                                    # derleyin
su root                                 # root olun
make install                            # kurun
</programlisting>
</para></listitem></varlistentry><varlistentry>
<term>RPM'den kurulum</term>
<listitem><para>
NCURSES'ün RPM paketi  <link xlink:href="http://rpmfind.net"/> adresinden indirilebilir. RPM'si root olduktan sonra aşağıdaki komut kullanılarak yüklenebilir.
</para><para>
<programlisting>
rpm -i <emphasis>indirilmiş-rpm-paketi</emphasis>
</programlisting>
</para></listitem></varlistentry></variablelist></para>
</sect2>

<sect2 userlevel="chunkthis" xml:id="ncurses-howto-purpose"><title>Belgenin Amacı/Kapsamı</title>
<para>
Bu belge ncurses ve kardeş kütüphanelerini kullanarak yazılım geliştirmek için "Hepsi Bir Arada" bir yol gösterici olmayı hedeflemektedir. Basit bir "Hello World" programından daha karmaşık olanlara doğru yol alacağız. Ncurses ile bir ön tecrübe yaşamış olmak gerekmemektedir. Yazım şekli kurallara sıkı bağlı değildir fakat örneklerde pek çok ayrıntı sağlanmıştır.
</para>
</sect2>
<sect2 userlevel="chunkthis" xml:id="ncurses-howto-aboutprograms"><title>Programlar Hakkında</title>
<para>
Belgedeki tüm programlar sıkıştırılmış olarak <link xlink:href="http://www.tldp.org/HOWTO/NCURSES-Programming-HOWTO/ncurses_programs.tar.gz"/> adresinde mevcuttur. Sıkıştırılmış olan bu dosyayı açtığınız zaman dizin yapısı şu şekilde gözükecektir.
</para>
<literallayout indent="0">
ncurses
   |
   |----&gt; JustForFun     -- sadece eğlence için yazılmış programlar
   |----&gt; basics         -- temel programlar
   |----&gt; demo           -- derlemeden sonra çıktı dosyaları bu dizin
   |          |          -- altına gider
   |          |----&gt; exe -- tüm örnek programlar için exe dosyaları
   |----&gt; forms          -- form kütüphanesiyle ilgili programlar
   |----&gt; menus          -- menü kütüphanesiyle ilgili programlar
   |----&gt; panels         -- panel kütüphanesiyle ilgili programlar
   |----&gt; perl           -- örneklerin perl karşılıklar
   |                     --(Anuradha Ratnaweera tarafından sağlanmıştır)
   |----&gt; Makefile       -- en tepedeki Makefile dosyası
   |----&gt; README         -- en tepedeki README dosyası. Talimatları ve
   |----&gt; COPYING        -- telif bilgisini içerir
</literallayout>
<para>Tek tek ele alırsak dizinler aşağıdaki dosyaları içerir.

</para>
<literallayout indent="0">
Her bir dizindeki dosyaların açıklamaları
--------------------------------------
JustForFun
    |
    |----&gt; hanoi.c   -- Hanoi Kulesi problemini çözücü
    |----&gt; life.c    -- Hayat Oyunu, demo
    |----&gt; magic.c   -- Tek Sıralı Sihirli Kare yapıcı
    |----&gt; queens.c  -- Meşhur N-Vezir sorusunu çözücü
    |----&gt; shuffle.c -- Öldürmek için zamanınız varsa, eğlenceli bir oyun
    |----&gt; tt.c      -- Oldukça deneysel bir yazma öğreticisi

  basics
    |
    |----&gt; acs_vars.c            -- ACS_ değişkenleri örneği
    |----&gt; hello_world.c         -- Basit bir "Merhaba Dünya" örneği
    |----&gt; init_func_example.c   -- İlklendirme işlevleri örneği
    |----&gt; key_code.c            -- Basılan karakteri gösterir
    |----&gt; mouse_menu.c          -- Fare ile erişilebilir menüler
    |----&gt; other_border.c        -- box() işlevinden başka diğer çerçeve
    |                            -- işlevlerinin kullanımını gösterir
    |----&gt; printw_example.c      -- Basit bir printw() örneği
    |----&gt; scanw_example.c       -- Basit bir getstr() örneği
    |----&gt; simple_attr.c         -- Bir c dosyasını yorum satırlarına
    |                            -- belli bir özellik kazandırarak gösterir
    |----&gt; simple_color.c        -- Renkleri gösteren basit bir örnek
    |----&gt; simple_key.c          -- Klavyenin YUKARI, AŞAĞI ok tuşlarıyla
    |                            -- erişilebilen bir menü
    |----&gt; temp_leave.c          -- Geçici olarak curses kipini terk etmeyi
    |                            -- gösterir
    |----&gt; win_border.c          -- Pencere ve çerçevelerin oluşturulmasını
    |                            -- gösterir
    |----&gt; with_chgat.c          -- chgat() kullanım örneği

  forms
    |
    |----&gt; form_attrib.c     -- Alan özelliklerinin kullanımı
    |----&gt; form_options.c    -- Alan seçeneklerinin kullanımı
    |----&gt; form_simple.c     -- Basit bir form örneği
    |----&gt; form_win.c        -- Formlarla birleşik bir pencere örneği

  menus
    |
    |----&gt; menu_attrib.c     -- Menü özelliklerinin kullanımı
    |----&gt; menu_item_data.c  -- item_name() v.b. işlevlerinın kullanımı
    |----&gt; menu_multi_column.c    -- Çok sütunlu menüler oluşturur
    |----&gt; menu_scroll.c     -- Menülerin gezinilebilme yetilerini gösterir
    |----&gt; menu_simple.c     -- Ok tuşlarıyla erişilebilen basit bir menü
    |----&gt; menu_toggle.c     -- Çok değerli menüler oluşturur ve
    |                        -- REQ_TOGGLE_ITEM'ı açıklar
    |----&gt; menu_userptr.c    -- Kullanıcı göstericisinin kullanımı
    |----&gt; menu_win.c        -- Menülerle pencerelerin beraber kullanımı

  panels
    |
    |----&gt; panel_browse.c    -- Sekme ile paneller üzerinde gezinme.
    |                        -- Kullanıcı göstericisinin kullanımı
    |----&gt; panel_hide.c      -- Panelleri saklamak ve açığa çıkarmak
    |----&gt; panel_resize.c    -- Panelleri hareket ettirmek ve yeniden
    |                        -- boyutlandırmak
    |----&gt; panel_simple.c    -- Basit bir panel örneği

  perl
    |----&gt; 01-10.pl          -- İlk on örneğin Perl karşılığı
</literallayout>
<para>
Ana dizin içerisinde temel bir Makefile dosyası bulunmaktadır. Tüm dosyaları derleyerek kullanıma hazır exe dosyalarını  demo/exe dizinine koymaktadır. Dizinlerin kendilerine de girerek de derleme işlemini o dizine özgü gerçekleyebilirsiniz. Her dizinde, içerisindeki c dosyalarının amacını içeren bir README dosyası bulunmaktadır.
</para><para>
Her örnek için, örnekler dizininde bulunacağı yolu eklemiştim.
</para><simpara>
Eğer programlara tek tek erişmek isterseniz <ulink
url="http://tldp.org/HOWTO/NCURSES-Programming-HOWTO/ncurses_programs/"/> adresine gidin.
</simpara><para>
Tüm programlar ncurses tarafından kullanılan lisans ile yayınlanmıştır (MIT-tarzı). Bu da size kendinize ait olduklarını söylemeniz dışında pekçok şeyi yapmanıza imkan sağlamaktadır. Yazılımınızda gerektiği takdirde kullanmaktan çekinmeyin.
</para>
</sect2>
<sect2 userlevel="chunkthis" xml:id="ncurses-howto-otherformats"><title>Belgenin Diğer Biçimleri</title>
<para>
Bu belge tldp.org sayfasında değişik biçimlerde de edinilebilir. Bu belgenin diğer biçimlerine bağlantılar şu şekildedir:
</para>
<sect3 xml:id="ncurses-howto-listformats"><title>tldp.org sayfasındaki kolayca erişilebilir dosya biçimleri:</title>
<para>
<itemizedlist>
<listitem>
<link xlink:href="http://www.ibiblio.org/pub/Linux/docs/HOWTO/other-formats/pdf/NCURSES-Programming-HOWTO.pdf">Acrobat PDF Biçimi</link>
</listitem><listitem>
<link xlink:href="http://www.ibiblio.org/pub/Linux/docs/HOWTO/other-formats/ps/NCURSES-Programming-HOWTO.ps.gz">PostScript Biçimi</link>
</listitem><listitem>
<link xlink:href="http://www.ibiblio.org/pub/Linux/docs/HOWTO/other-formats/html/NCURSES-Programming-HOWTO-html.tar.gz">Çok Sayfalı HTML biçimi</link>
</listitem><listitem>
<link xlink:href="http://www.ibiblio.org/pub/Linux/docs/HOWTO/other-formats/html_single/NCURSES-Programming-HOWTO.html">Tek Sayfalık HTML biçimi</link>
</listitem>
</itemizedlist>
</para>
</sect3>

<sect3 xml:id="ncurses-howto-buildsource"><title>Kaynaktan Kurmak</title>
<para>
Eğer yukarıdaki adresler hatalıysa ve sgml'yi denemek istiyorsanız okumaya devam edin.
</para><para>
<programlisting>
    http://cvsview.tldp.org/index.cgi/LDP/howto/docbook/
        NCURSES-HOWTO/NCURSES-Programming-HOWTO.sgml
    http://cvsview.tldp.org/index.cgi/LDP/howto/docbook/
        NCURSES-HOWTO/ncurses_programs.tar.gz
adreslerindeki gzip ile sıkıştırılmış tar dosyalarını ve
kaynak dosyalarını edinin.

ncurses_programs.tar.gz'i şu şekilde açın:
<command>tar zxvf ncurses_programs.tar.gz</command>

Değişik dosya biçimleri oluşturmak için jade'i kullanın.
Örneğin sadece çoklu html'ler oluşturacaksanız, sadece
şunu kullanacaksınız:
<command>jade -t sgml -i html -d </command><emphasis>docbook html için dsssl yolu</emphasis> \
    <command>NCURSES-Programming-HOWTO.sgml</command>

pdf elde etmek için önce NASIL'ın tek sayfalık html dosyasını
şu şekilde oluşturun:
<command>jade -t sgml -i html -d</command> <emphasis>docbook html için dsssl yolu</emphasis> <command>-V nochunks</command> \
    <command>NCURSES-Programming-HOWTO.sgml &gt; NCURSES-TEK-BUYUK-DOSYA.html</command>
daha sonra htmldoc'u pdf elde etmek için şu şekilde kullanın
<command>htmldoc --size universal -t pdf --firstpage p1 -f </command><emphasis>çıktı dosyası adı.pdf</emphasis> \
    <command>NCURSES-TEK-BUYUK-DOSYA.html</command>
ps için şunu kullanıyor olacaksınız
<command>htmldoc --size universal -t ps --firstpage p1 -f </command><emphasis>çıktı dosyası adı.ps</emphasis> \
    <command>NCURSES-TEK-BUYUK-DOSYA.html</command>
</programlisting>
</para><para>
Ayrıntılar için <link xlink:href="http://www.tldp.org/LDP/LDP-Author-Guide/">LDP yazar rehberine</link> bakın. 
</para>
</sect3>
</sect2>

<sect2 userlevel="chunkthis" xml:id="ncurses-howto-credits"><title>Katkıda Bulunanlar</title>
<para>
Sharath ve Emre Akbas'a bir kaç bölümde bana yardım ettikleri için teşekkürler. Giriş kısmı ilk olarak sharath tarafından yazıldı. Daha sonra onun ilk çalışmasından az bir bölümü tekrar yazdım. Emre, printw ve scanw bölümlerini yazmada yazdım etti.
</para><para>
Örnek programların Perl karşılıkları Anuradha Ratnaweera  tarafından hazırlandı.
</para><para>
Sırada benim sevgili arkadaşım Ravi Parimi  var, bu proje çevrimiçi yazıldığından beri o da yer aldı. Düzenli olarak önerilerle beni topa tuttu ve tüm yazılı metni sabırla gözden geçirdi. Her bir programı da ayrıca Linux ve Solaris ortamında kontrol etti.
</para>
</sect2>

<sect2 userlevel="chunkthis" xml:id="ncurses-howto-wishlist"><title>İstek Listesi</title>
<para>
Bu kısım öncelik sırasına göre istek listesidir. Eğer bir istek üzerinde çalışmak istiyor veya bir öneriniz varsa bana yazın.
</para><para>
<itemizedlist>
<listitem>
Form kısımlarının sonuna örnekler eklemek
</listitem><listitem>
Tüm programları gösteren bir örnek hazırlamak ve her kullanıcıya tüm programları taraması imkanı sağlamak. Kullanıcılara derleme ve programın çıktısını görme imkanı vermek. Etkileşimli bir arayüz tercih edilir.
</listitem><listitem>
Hata ayıklama bilgilerini eklemek. _tracef, _tracemouse konuları.
</listitem><listitem>
Ncurses paketlerinin sunduğu işlevleri kullanarak termcap, terminfo'ya erişmek
</listitem><listitem>
İki uçbirimde de aynı anda çalışmak.
</listitem><listitem>
"Çeşitli" kısmına daha fazla eleman eklemek
</listitem>
</itemizedlist></para>
</sect2>
</sect1>

<sect1 xml:id="ncurses-howto-helloworld"><title>Merhaba Dünya !!!</title>
<para>
Curses dünyasına hoş geldiniz. Kütüphanelere dalmadan ve onların değişik özelliklerine bakmadan önce basit bir program yazarak gezegene merhaba diyelim.
</para>

<sect2 userlevel="chunkthis" xml:id="ncurses-howto-compilecurses">
<title>NCURSES Kütüphaneleriyle Derleme</title>
<para>
Ncurses kütüphane işlevlerini kullanabilmek için programınıza <filename>ncurses.h</filename> başlık dosyasını eklemelisiniz. Programlarınızı ncurses kütüphanesiyle ilintileyebilmek için <option>-lncurses</option> seçeneğiyle derleyin.
</para><para>
<programlisting>
#include &lt;ncurses.h&gt;
.
.
.

derleyin ve bağlayın: <command>gcc </command><emphasis>program dosyası</emphasis> <command>-lncurses</command>
</programlisting>
</para><example xml:id="ncurses-howto-bhw">
<title>Merhaba Dünya !!! Programı</title><para>
<programlisting>
include &lt;ncurses.h>

int main()
{
  initscr();                      /* Curses kipine giriş           */
  printw("Merhaba Dünya !!!");    /* Merhaba Dünya yazdırma        */
  refresh();                      /* Onu gerçek ekrana yazdırın    */
  getch();                        /* Kullanıcıyı bekleyin          */
  endwin();                       /* Curses kipinden çıkış         */

  return 0;
}
</programlisting>
</para></example>
</sect2>

<sect2 userlevel="chunkthis" xml:id="ncurses-howto-dissection"><title>İnceleme</title>
<para>
Yukarıdaki program ekrana "Meraha Dünya !!!" yazıp sonlanır. Bu program curses kipinin nasıl ilklendirileceğini, nasıl ekran değişikliği yapılacağını ve curses kipini nasıl sonlandırılacağını göstermektedir. Şimdi satır satır inceleyelim.
</para>
<sect3 xml:id="ncurses-howto-about-initscr"><title><function>initscr()</function> hakkında</title>
<para>
<function>initscr()</function> uçbirimi curses kipinde ilklendirir. Bazı gerçekleştirmelerinde ekranı temizleyip boş bir ekran göstermektedir. Ekran üzerinde curses kullanarak bir değişiklik yapılacağında bu işlev ilk olarak çağrılmalıdır. Bu işlev curses sistemini ilklendirip şu anki pencere için (<command>stdscr</command> olarak isimlendirilen) ve bazı veri yapıları için bellekten yer ayırır. Bazı istisnai durumlarda bu işlev curses kütüphane veri yapıları için bellekten yer ayırırken yetersiz bellek yüzünden sekteye uğrayabilir.
</para><para>
Bu yapıldıktan sonra kendi curses ayarlarımınızı özelleştirmek için değişik ilklendirmeler yapabiliriz. Bu ayrıntılar <link linkend="ncurses-howto-init">daha sonra</link> anlatılacaktır.
</para>
</sect3>
<sect3 xml:id="ncurses-howto-myst-refresh"><title>Gizemli <function>refresh()</function></title>
<para>
Sonraki satır "Merhaba Dünya !!!" dizgeını ekrana yazar. Bu işlev, veriyi <literal>stdscr</literal> olarak isimlendirilen pencerenin o anki <literal>(y,x)</literal> koordinatlarına  yazması dışında bildiğiniz <function>printf</function> işlevine her yönüyle benzemektedir. Şu anki koordinatlarımız <literal>0,0</literal> olduğundan, dizge pencerenin sol tarafından itibaren yazılır.
</para><para>
Bu da bizi şu sihirli bildiğiniz <function>refresh()</function>'e getirmektedir. <function>printw</function>'yi çağırdığımızda veri, hayali ve henüz ekranda güncellenmemiş bir pencereye yazılır. <function>printw</function>'nin görevi bazı bayrakları ve veri yapılarını güncelleyerek <literal>stdscr</literal>'ye karşılık gelen ön bellek alanına veriyi yazmaktır. Bunu ekranda göstermek için, <function>refresh()</function>'i çağırarak curses sistemine içeriği ekrana boşaltmasını söylemeliyiz.
</para><para>
Bunun arkadasındaki felsefe programcının hayali ekran veya penreler üzerinde birden fazla güncelleme yapması ve bu güncelemelerden sonra ekranını tazelemesidir. <function>refresh()</function> pencereyi kontrol eder ve kontrol edilen kısmı günceller. Bu da performans ve büyük bir esneklik sağlamaktadır. Fakat bazen yeni başlayanlar için sinir bozudur. Yeni başlayanların yaptığı en temel hatalardan biri <function>printw()</function> sınıfı işlevleri kullanarak güncelleme yaptıktan sonra <function>refresh()</function>'i çağırmayı unutmalarıdır. Ben bile bazen eklemeyi unutuyorum <literal>:-)</literal>
</para>
</sect3>

<sect3 xml:id="ncurses-howto-about-endwin"><title><function>endwin()</function> hakkında</title>
<para>
Ve son olarak curses kipini sonlandırmayı unutmayın. Aksi halde uçbiriminiz program sonlandıktan sonra garip davranabilir. <function>endwin()</function>, curses alt sistemi tarafından alınan bellek bölgesini onun veri yapılarını geri verir ve uçbirimi normal çalışma kipine döndürür. Bu işlev curses kipiyle çalışmanız bittikten sonra çağrılmalıdır.
</para>
</sect3>
</sect2>
</sect1>

<sect1 xml:id="ncurses-howto-gory"><title>Kanlı Ayrıntılar</title>
<para>
Basit bir curses programının nasıl yazılacağını şu ana kadar gördük artık ayrıntılara inelim. Ekranda gördüklerinizi özeleştirmeniz için pekçok işlev ve tam olarak kullanabileceğiniz pekçok özellik vardır.
</para><simpara>İşte başlıyoruz...</simpara>
</sect1>

<sect1 xml:id="ncurses-howto-init"> <title>İlklendirme</title>
<para>
Artık curses sisteminin ilklendirilmesi için <function>initscr()</function> işlevinin çağrılması gerektiğini biliyoruz. Bu ilklendirmeden sonra curses oturumuzu özelleştirmemizi sağlayan işlevler vardır. Curses sisteminden uçbirimi ham kipe ayarlamasını veya renkendirmeyi ilklendirmesini veya fareyi etkin kılmasını v.b. isteyebiliriz. <function>initscr()</function>'den hemen sonra çağrılan işlevler hakkında biraz konuşalım:
</para>

<sect2 xml:id="ncurses-howto-rawcbreak"><title><function>raw()</function> ve <function>cbreak()</function></title>
<para>
Normal durumda uçbirim sürücüsü satırsonu veya satırbaşı karakteri ile karşılaşana kadar kullanıcın yazdığı karakterleri ön belleğine alır. Fakat bazı programlar kullanıcı yazar yazmaz karakterlerin erişilebilir olmasını ister. Yukarıdaki iki işlev satır önbelleğini etkisizleştirir. Bu iki işlev arasındaki fark duraklatma (CTRL-Z), kesme ve çıkış (CTRL-C) için kullanılan kontrol karakterlerinin programa gönderilme şeklidir. <command>raw()</command> kipinde bu karakterler herhangi bir sinyal üretilmeden programa gönderilir. <command>cbreak()</command> kipinde ise bu karakterler herhangi bir diğer karakter gibi uçbirim sürücüsü tarafından algılanır. Kullanıcının neler yaptığı üzerinde daha fazla hakimiyet sağladığıdan kişisel olarak <function>raw()</function>'ı tercih ediyorum.
</para>
</sect2>

<sect2 xml:id="ncurses-howto-echonoecho">
<title><function>echo()</function> ve <function>noecho()</function></title>
<para>
Bu işlevler kullanıcı tarafından yazılan karakterlerin uçbirim penceresine yansıtılmasını kontrol eder. <command>noecho()</command> bu yansıtmayı etkisizleştirir. Bunu yapmanızın sebebi yazılanı ekrana yansıtmada daha fazla kontrol sağlanması veya <function>getch()</function> v.b. işlevler ile kullanıcıdan girdi alınırken gereksiz karakter gösterimlerinin önüne geçmektir. Kullanıcıyla etkileşimli pek çok yazılım ilklendirme sırasında <command>noecho()</command> işlevin çağırır ve karakterlerin ekrana yansıtılması işlemini kontrollü bir şekilde gerçeklştirir. Bu da programcıya o anki <literal>(y,x)</literal> koordinatlarını güncellemeden karakterlerin ekrana yansıtılması esnekliğini kazandırır.
</para>
</sect2>

<sect2 xml:id="ncurses-howto-keypad">
<title><function>keypad()</function></title>
<para>
Bu benim en sevdiğim ilklendirme işlevim. F1, F2, ok tuşları, v.b gibi tuşların okunabilirliğini sağlar. Kullanıcı ile etkileşimli hemen her program ok tuşlarının bir kullanıcı arayüzünde vazgeçilmez olmasından dolayı bunu etkinleştirmektedir. <command>keypad(stdscr, TRUE)</command> ile öntanımlı olarak atanmış ekran için (<literal>stdscr</literal>) bu özelliğin etkin olmasını sağlayın. Klavye yönetimi hakkında daha fazla bilgiyi bu belgenin daha sonraki bölümlerinde öğreneceksiniz.
</para>
</sect2>

<sect2 xml:id="ncurses-howto-halfdelay">
<title><function>halfdelay()</function></title>
<para>
Bu işlev çok sık kullanılmasa da, bazen oldukça yararlıdır. <function>halfdelay()</function>, <function>cbreak()</function> kipine benzer şekilde basılan karakterlerin program için edinilebilir olmasını sağlayan yarım-gecikme kipini etkinleştirir. Bununla beraber girdi için saniyenin <literal>'X' * 10</literal> birimi kadar bekleyip herhangi bir giriş yapılmazsa <literal>ERR</literal> geri döndürür. <literal>'X'</literal>, <function>halfdelay()</function> işlevine gönderilen zaman aşımı süresidir. Bu işlev kullanıcıdan bir girdi istediğiniz zaman kullanışlıdır, eğer belli zaman içerisinde bu giriş gerçeklemezse bir şeyler yapabiliriz. Muhtemel bir örnek olarak parola giriş ekranındaki zaman aşımı verilebilir.
</para>
</sect2>

<sect2 xml:id="ncurses-howto-miscinit">
<title>Muhtelif İlklendirme İşlevleri</title>
<para>
Curses davranışlarını ilklendirirken çağrılan bir kaç işlev daha vardır. Yukarıda belirtilenler kadar yoğun şekilde kullanılmazlar. Gerekli oldukları yerlerde bazıları açıklanmıştır.
</para>
</sect2>
<sect2 userlevel="chunkthis" xml:id="ncurses-howto-initex"><title>Bir Örnek</title>
<simpara>
Bu işlevlerin kullanımını açıklayacak bir program yazalım.
</simpara>
<example xml:id="ncurses-howto-binfu">
<title>İlklendirme İşlevlerini Kullanım Örneği</title><para>
<programlisting>
#include &lt;ncurses.h>

int main()
{ int ch;

  initscr();                   /* Curses kipine giriş                     */
  raw();                       /* Satır önbelleği etkisizleştirildi       */
  keypad(stdscr, TRUE);        /* F1, F2, v.b. etkin                      */
  noecho();                    /* getch için karakterleri ekrana yansıtma */

  printw("Koyu görmek istediğiniz bir karakteri yazınız\n");
  ch = getch();                /* Eğer raw() çağrılmamış olsa              *
                                * karakterin programa gönderilmesi için    *
                                * enter'a basmamız gerekecekti             */
  if(ch == KEY_F(1))           /* Klavye tuşları etkinleştirilmeden        */
    printw("F1 tuşuna basıldı");   /* bu değeri de alamayacaktık           */
                               /* noecho() olmadan                         *
                                * bazı çirkin gözünüşlü karakterler        *
                                * ekranda gözükebilir                      */
  else
  { printw("Basılan tuş ");
    attron(A_BOLD);
    printw("%c", ch);
    attroff(A_BOLD);
  }
  refresh();                   /* Karakteri gerçek ekrana yazdır */
  getch();                     /* Kullanıcı girişi için bekle    */
  endwin();                    /* Curses kipinin sonu            */

  return 0;
}
</programlisting></para>
</example>
<para>
Bu program kendisini açıklayabilmektedir. Fakat henüz açıklanmayan işlevler kullandım. <command>getch()</command> komutu kullanıcıdan bir karakter almak için kullanılır. Bildik <command>getchar()</command>'a &lt;enter&gt; kullanımından kaçınmak için satır önbelleğiniz etkisizleştirebilmemiz dışında aynen benzemektedir. <command>getch()</command> ve tuşların okunmasıyla ilgili <link
linkend="ncurses-howto-keys">klavye tuşları yönetimi</link> kısmına bakınız. <function>attron</function> ve <function>attroff</function> işlevleri sırasıyla bazı özellikleri açmak ve kapamak için kullanılır. Örnekte karakterleri koyu yazmak için kullandım. Bu işlevler daha sonra ayrıntılı olarak anlatılacaktır.
</para>
</sect2>
</sect1>

<sect1 xml:id="ncurses-howto-awordwindows">
<title>Pencereler Hakkında Bir Çift Söz</title>
<para>
Bir sürü ncurses işlevine dalmadan önce pencereler hakkında bir iki şeyi açıklığa kavuşturmama müsade edin. Pencereler <link linkend="ncurses-howto-windows">bölümünde</link> ayrıntılı şekilde açıklanmıştır.
</para><para>
Pencere, curses sistemi tarafından tanımlanan hayali bir ekrandır. Pencere, genellikle Win9X ortamında gördüğünüz çerçeveli pencereler anlamına gelmemektedir. Curses ilklendirildiği zaman <command>stdscr</command> isminde sizin 80x25 boyutlarındaki (veya çalıştığınız pencerenin boyutu) ekranınızı temsil eden varsayılan bir pencere oluşturur. Bazı dizgelerin ekrana yazılması, giriş okuma v.b. gibi basit işler yapıyorsanız bu tek pencereyi tüm amaçlarınız için güvenle kullanabiliriniz. Ayrıca pencereler oluşturabilir ve belirtilen pencere üzerinde açık şekilde çalışacak işlevler çağırabilirsiniz.
</para><para>
Örneğin şu işlevi çağırırsanız
</para><para>
<programlisting>
  printw("Selam millet !!!");
  refresh();
</programlisting>
</para><para>
Dizgeyi imlecin o anki konumunda <literal>stdscr</literal> üzerinde yazacaktır. Benzer şekilde <function>refresh()</function> çağrısı sadece <literal>stdscr</literal> üzerinde çalışır.
</para><para>
Artık bir <link linkend="ncurses-howto-windows">pencere</link> oluşturduğunuzu söyleyebilirsiniz ve bundan sonra bildik C işlevlerini 'w' eklenmiş olarak çağırabilirsiniz.
</para><para>
<programlisting>
  wprintw(win, "Selam millet !!!");
  wrefresh(win);
</programlisting>
</para><para>
Belgenin geri kalanında göreceğiniz gibi işlevlerin isimlendirilmesi aynı öngörüye dahildir. Her işlev için genelde üç tane daha işlev vardır.
</para>
<literallayout indent="0">
<command>printw</command>(<emphasis>dizge</emphasis>);
  stdscr üzerine kursorun bulunduğu konumdan itibaren yazar.
<command>mvprintw</command>(<emphasis>y, x, dizge</emphasis>);
  (y, x) konumuna gider ve dizgeyi oraya yazar.
<command>wprintw</command>(<emphasis>win, dizge</emphasis>);
  Pencere içerisinde imlecin bulunduğu yerden itibaren
  <emphasis>win</emphasis> isimli pencereye yazar
<command>mvwprintw</command>(<emphasis>win, y, x, dizge</emphasis>);
  pencereye göre (y, x) koordinatlarına git ve <emphasis>dizge</emphasis>yi buraya yaz
</literallayout>
<para>
Genelde <literal>w</literal>'siz işlevler, karşılık gelen <literal>w</literal>'li işlevlere pencere değişkeni olarak <literal>stdscr</literal> aktarılan makrolardır.
</para>
</sect1>

<sect1 xml:id="ncurses-howto-printw"><title>Çıktı işlevleri</title>
<para>
Sanırım artık biraz hareket görmek için bekleyemiyorsunuz. Curses işlevlerimizle olan uzun ve serüvenli yolculuğa geri dönelim. Artık curses ilklendirildi haydi onla oynayalım.
</para><para>
Ekrana çıktılama işlemleri için kullanabileceğiniz üç sınıf işlev bulunmaktadır.
</para><para>
<orderedlist><listitem>
<function>addch()</function> sınıfı: Tek bir karakteri öznitelliklerle yazar
</listitem><listitem>
<function>printw()</function> sınıfı: <function>printf()</function>'e benzer biçimlendirilmiş çıktı sağlar
</listitem><listitem>
<function>addstr()</function> sınıfı: Dizgelerin yazar</listitem>
</orderedlist>
</para><para>
Bu işlevler birbirleri yerine kullanılabilir. Hangi sınıfı kullandığınız tamamen bir tarz meselesidir.
</para>

<sect2 userlevel="chunkthis" xml:id="ncurses-howto-addchclass">
<title><function>addch()</function> sınıfı işlevler</title>
<para>
Bu işlevler imlecin bulunduğu konuma tek bir karakter yazar ve imleç konumunu ilerletir. Görüntülenecek karakteri işleve verebilirsiniz, fakat genelde bir karakteri belli bir görüntüleme özelliği ile ekrana yazarlar. Görüntüleme özellikleri, belgenin <xref linkend="ncurses-howto-attrib"/> bölümünde ayrıntılı olarak anlatılmıştır. Eğer bir karakter bir öznitelik (kalın, ters video v.b.) ile beraber kullanılırsa, curses karakteri belirtilen öznitelik ile basar.
</para><para>
Bir karakteri belli özniteliklerle bağdaştırmak isterseniz iki seçeneğiniz bulunmaktadır:
</para><para>
<itemizedlist><listitem>
<para>
İstenen öznitelik makrosunu tek bir karakter ile VEYA'lamaktır. Bu öznitelikler  <filename>ncurses.h</filename> başlık dosyası içerisinde bulunabilir. Örneğin bir <varname>krk</varname> karakterini (<literal>char</literal> türünde) koyu ve altı çizili olarak yazmak istiyorsanız,<function>addch()</function>'ı şu şekilde çağırmalısınız:
</para><para>
<programlisting>
  addch (krk | A_BOLD | A_UNDERLINE);
</programlisting>
</para></listitem><listitem><para>
İkinci yöntemse <command>attrset(), attron(), attroff()</command> gibi işlevler kullanmaktır Bu işlevler <xref linkend="ncurses-howto-attrib"/> bölümünde anlatılmıştır. Özetle, o anki pencerenin özniteliklerini değiştirirler. Bir kere ayarlandılar mı,  etkisiz kılınana kadar pencereye yazılan karakter bu özniteliklerle ekrana yazılır.
</para></listitem>
</itemizedlist>
</para><para>
Ek olarak <command>curses</command>, karakter tabanlı grafikler için bazı özel karakterler sunmaktadır. Tablolar, yatay veya dikey çizgiler, v.b. çizebilirsiniz. Tüm kullanılabilir karakterleri <filename>ncurses.h</filename> başlık dosyasında bulabilirsiniz. Bu dosya içerisindeki <literal>ACS_</literal> ile başlayan makrolara bakınız.
</para>
</sect2>

<sect2 userlevel="chunkthis" xml:id="ncurses-howto-addch">
<title><function>mvaddch(), waddch()</function> ve <function>mvwaddch()</function></title><para>
<command>mvaddch()</command>, imleci verilen konuma  hareket ettirir ve buraya yazar. Bundan dolayı şu çağrı,
</para>
<literallayout indent="0">
    <command>move</command>(<emphasis>satır</emphasis>,<emphasis>sütun</emphasis>);
/*imleci <emphasis>satır</emphasis>ıncı satırın <emphasis>sütun</emphasis>uncu sütununa hareket ettirir. */
    <command>addch</command>(<emphasis>krk</emphasis>);
</literallayout>
<para>
şununla yer değiştirilebilir:
</para>
<literallayout indent="0">
    <command>mvaddch</command>(<emphasis>satır</emphasis>, <emphasis>sütun</emphasis>, <emphasis>krk</emphasis>);
</literallayout>
<para>
<command>waddch()</command> işlevi, verilmiş bir pencere içerisine karakter eklemesi dışında <command>addch()</command> işlevine benzemektedir. (<command>addch()</command>'ın <literal>stdscr</literal> penceresine bir karakter eklediğini unutmayın)
</para><para>
Benzer şekilde <command>mvwaddch()</command> işlevi de verilmiş olan koordinatlarda belirtilen pencereye bir karakter eklemek için kullanılır.
</para><para>
Artık temel çıktı işlevi <command>addch()</command>'a yabancı değiliz. Fakat, eğer bir dizgeyi yazdırmak istiyorsak onu karakter karakter yazdırmak oldukça sinir bozucu olacaktır. Ne iyi ki, ncurses, <command>printf</command> benzeri veya <command>puts</command> benzeri işlevler sunmaktadır.
</para>
</sect2>

<sect2 userlevel="chunkthis" xml:id="ncurses-howto-printwclass">
<title><function>printw()</function> sınıfı işlevler </title><para>
Bu işlevler <command>printf()</command> işlevine benzemeleri yanında ekran üzerindeki herhangi bir konuma da yazabilmeyi de sağlamaktadırlar.
</para>
<sect3 xml:id="ncurses-howto-printwmvprintw">
<title><function>printw()</function> ve <function>mvprintw()</function></title>
<para>
Bu iki işlev <command>printf()</command>'e benzer çalışmaktadır. <command>mvprintw()</command> imleci belirtilen konuma hareket ettirir ve buraya yazar. Eğer önce imleci hareket ettirip daha sonra <command>printw()</command> kullanarak ekrana yazmak isterseniz önce <command>move()</command>'u daha sonra da <command>printw()</command>'yi kullanın. Hoş, birinin <command>mvprintw()</command> kullanımından kaçınmasında bir mantık göremesem de değiştirme esnekliğiniz bulunmaktadır.
</para>
</sect3>
<sect3 xml:id="ncurses-howto-wprintwmvwprintw">
<title><function>wprintw()</function> ve <function>mvwprintw()</function></title>
<para>
Bu işlevler, değiştirge olarak verilen pencerelere yazmaları dışında yukarıdakilere benzemektedir.
</para>
</sect3>
<sect3 xml:id="ncurses-howto-vwprintw"><title><function>vwprintw()</function></title>
<para>
Bu işlev <command>vprintf()</command>'e benzemektedir. Değişken sayıda değiştirge ile kullanılabilir.
</para>
</sect3>

<sect3 xml:id="ncurses-howto-simpleprintwex">
<title>Basit bir <function>printw</function> örneği</title>
<example xml:id="ncurses-howto-bprex">
<title>Basit bir <function>printw</function> örneği</title><para>
<programlisting>
#include &lt;ncurses.h>       /* stdio.h başlık dosyasını da ekler */
#include &lt;string.h>

int main()
{
 char ileti[]="Sadece bir dizge"; /* ekranda görünecek ileti       */
 int sat, sut;                    /* ekrandaki satır sayısını ve    *
                                   * sütün sayısını tutmak için     */
 initscr();                       /* curses kipine başlama          */
 getmaxyx(stdscr, sat, sut);      /* satır ve sütun sayısını alma   */
 mvprintw(sat/2, (sut-strlen(ileti))/2, "%s", ileti);
                                  /* iletiyi ekranın ortasına yazdır */
 mvprintw(sat-2, 0, "Bu ekranda %d satır ve %d sütun var\n", sat, sut);
 printw("Ekran boyunu degistirerek (eger mümkünse)"
        " programı yeniden çalıstırın");
 refresh();
 getch();
 endwin();

 return 0;
}
</programlisting></para>
</example>
<para>
Yukarıdaki program <command>printw</command> kullanımının ne kadar kolay olduğunu göstermektedir. Sadece koordinatları ve göstermek istediğiniz iletiyi belirtmektesiniz ve o da isteğinizi yerine getirmektedir.
</para><para>
Yukarıdaki program bize <command>getmaxyx()</command> isimli <filename>ncurses.h</filename> içerisinde tanımlı yeni bir makroyu tanıtmaktadır. Verilen penceredeki satır ve sütün sayısını hesaplar. <command>getmaxyx()</command> bunu kendisine verilen değişkenleri güncelleyerek yapar.  <command>getmaxyx()</command> işlev olmadığından değiştirge olarak gösterici aktaramayız, sadece iki tamsayı değişken verebiliriz.
</para>
</sect3>
</sect2>

<sect2 userlevel="chunkthis" xml:id="ncurses-howto-addstrclass">
<title><function>addstr()</function> sınıfı işlevler</title><para>
<command>addstr()</command> bir karakter dizisini verilen pencereye yazdırmak için kullanılır. Bu işlev her bir karakter için <command>addch()</command> işlevini çağırmaya benzer. Bu tüm çıktı işlevleri için geçerlidir. Bu aileden <command>mvaddstr(), mvwaddstr()</command> ve <command>waddstr()</command> gibi, curses'in isimlendirme kurallarına uyan (örn. <function>mvaddstr(), move()</function> ve daha sonra <function>addstr()</function> çağrılmasıyla aynıdır) işlevler de vardır. Bu ailenin bir başka işlevi ise ek olarak <literal>n</literal> tam sayı değiştirgesini alan <function>addnstr()</function> işlevidir. Bu işlev ekrana en fazla <literal>n</literal> karakter yazdırır. Eğer <literal>n</literal> negatif ise tüm dizge yazdırılır.
</para>
</sect2>

<sect2 userlevel="chunkthis" xml:id="ncurses-howto-acaution">
<title>Dikkat edilmesi gereken nokta</title>
<para>
Tüm bu işlevler değiştirge olarak önce <literal>y</literal> daha sonra da <literal>x</literal> koordinatını almaktadır. Yeni başlayanların yaptığı en temel hata <literal>x, y</literal> şeklinde değiştirge göndermektir. Eğer <literal>(y,x)</literal> koordinatları üzerinde çok fazla değişiklik yapıyorsanız, ekranı her biriyle ayrı ayrı ilgilenmek için pencerelere bölün. Pencereler <xref linkend="ncurses-howto-windows"/> bölümünde açıklanmıştır.
</para>
</sect2>
</sect1>

<sect1 xml:id="ncurses-howto-scanw"><title>Girdi işlevleri</title>
<para>
Aslında girdi almadan ekrana yazdırmak sıkıcıdır. Kullanıcıdan girdi almamızı sağlayan işlevlere bir bakalım. Bu işlevler üç bölüme ayrılabilir;
</para><para>
<orderedlist>
<listitem><function>getch()</function> sınıfı: Bir karakter alır</listitem>
<listitem><function>scanw()</function> sınıfı: Biçimlenmiş girdi alır</listitem>
<listitem><function>getstr()</function> sınıfı: Dizge alır</listitem>
</orderedlist>
</para>
<sect2 userlevel="chunkthis" xml:id="ncurses-howto-getchclass">
<title><function>getch()</function> sınıfı işlevler</title>
<para>
Bu işlevler uçbirimden tek bir karakter okur. Fakat gözönüne alınması gereken bir kaç ince nokta vardır. Örneğin, eğer <function>cbreak()</function> işlevini kullanmazsanız, curses girdiğiniz karakterleri art arda değil sadece satırsonu veya  dosyasonu karakteri ile karşılaşana kadar okuyacaktır. Bundan kaçınmak için <function>cbreak()</function> işlevi kullanılmalıdır, böylece karakterler anında programınızdan erişilebilir olacaktır. Yaygın olarak kullanılan işlevlerdan biri <function>noecho()</function>'dur. İsminden de anlaşılacağı üzere, bu işlev çağrıldığında (kullanıldığında) kullanıcının girdiği karakterler ekranda gösterilmez. <function>cbreak()</function> ve <function>noecho()</function> işlevleri tuş yönetimi üzerindeki en tipik örneklerdir. Bu türden işlevler <xref linkend="ncurses-howto-keys"/> bölümünde anlatılmıştır.
</para>
</sect2>

<sect2 userlevel="chunkthis" xml:id="ncurses-howto-scanwclass">
<title><function>scanw()</function> sınıfı işlevler</title>
<para>
Bu işlevler <command>scanf()</command> işlevine benzemektedir, ek olarak ekran üzerindeki herhangi bir konumdan veri girişine olanak sağlamaktadırlar.
</para>
<sect3 xml:id="ncurses-howto-scanwmvscanw">
<title><function>scanw()</function> ve <function>mvscanw()</function></title>
<para>
Bu işlevlerin kullanımı taranacak satırın <command>wgetstr()</command> işlevi ile sağlandığı <command>sscanf()</command> kullanımına benzemektedir. Başka deyişle, bu işlevler <command>wgetstr()</command> işlevini çağırır (aşağıda anlatılmıştır) ve sonuç satırını taramak için kullanırlar.
</para>
</sect3>
<sect3 xml:id="ncurses-howto-wscanwmvwscanw">
<title><function>wscanw()</function> ve <function>mvwscanw()</function></title>
<para>
Bunlar da değiştirgesiz olarak verilen bir pencereden okumaları dışında yukarıdaki iki işleve benzemektedir.
</para>
</sect3>

<sect3 xml:id="ncurses-howto-vwscanw"><title><function>vwscanw()</function></title>
<para>
Bu işlev <command>vscanf()</command>'ye benzemektedir. Bu, değişken sayıda değiştirge okunacağı zaman kullanılabilir.
</para>
</sect3>
</sect2>

<sect2 userlevel="chunkthis" xml:id="ncurses-howto-getstrclass">
<title><function>getstr()</function> sınıfı işlevler</title>
<para>
Bu işlevler uçbirimden dizge okumak için kullanılır. Aslında bu işlev satırsonu veya satırbaşı veya dosyasonu karakteri görene kadar <command>getch()</command> işlevinin art arda kullanımıyla aynı işi yapmaktadır. Oluşan karakter dizisi, kullanıcı tarafından tanımlanmış bir karakter göstericisi olan <varname>dizge</varname> tarafından tutulur.
</para>
</sect2>

<sect2 userlevel="chunkthis" xml:id="ncurses-howto-getstrex">
<title>Bazı örnekler</title>
<example xml:id="ncurses-howto-bscex">
<title>Basit bir <function>scanw</function> örneği </title><para>
<programlisting>
#include &lt;ncurses.h>          /* ncurses.h, stdio.h da ekler */
#include &lt;string.h>

int main()
{
 char ileti[]="Bir dizge giriniz: ";  /* ekranda gözükecek mesaj */
 char dizge[80];
 int sat,sut;                     /* ekranın satır ve sütün sayısını  *
                                   * tutmak için */
 initscr();                       /* curses kipine başlama */
 getmaxyx(stdscr,sat,sut);        /* satır ve sütün satısını elde et */
 mvprintw(sat/2, (sut-strlen(ileti))/2, "%s", ileti);
                                  /* iletiyi ekranın ortasına yaz */
 getstr(dizge);
 mvprintw(LINES - 2, 0, "Şunu girdiniz: %s", dizge);
 getch();
 endwin();

 return 0;
}
</programlisting></para>
</example>
</sect2>
</sect1>

<sect1 xml:id="ncurses-howto-attrib"><title>Öznitelikler</title>
<para>
Karakterlere özel etkilerle nasıl öznitelikler kazandırılabileceğini daha önce görmüştük. Öznitelikler, özenli ayarlanmaları halinde, verilerin kolay ve anlaşılır bir şekilde basılmasını sağlarlar. Aşağıdaki program bir C dosyasını değiştirge olarak almakta ve  yorum satırlarını koyu olarak göstermektedir. Kodu inceleyin.
</para>
<example xml:id="ncurses-howto-bsiat">
<title>Basit bir öznitelik verme örneği</title><para>
<programlisting>
/* pager functionality by Joseph Spainhour" &lt;spainhou (at) bellsouth.net> */
#include &lt;ncurses.h>
#include &lt;stdlib.h>

int main(int argc, char *argv[])
{
  int ch, prev, row, col;
  prev = EOF;
  FILE *fp;
  int y, x;

  if(argc != 2)
  {
    printf("Kullanım: %s &lt;bir dosya adı>\n", argv[0]);
    exit(1);
  }
  fp = fopen(argv[1], "r");
  if(fp == NULL)
  {
    perror("Girdi dosyası açılamadı");
    exit(1);
  }
  initscr();                            /* Curses kipi başlangıcı    */
  getmaxyx(stdscr, row, col);           /* ekran sınırlarını bul     */
  while((ch = fgetc(fp)) != EOF)        /* dosyayı sonuna kadar oku  */
  {
    getyx(stdscr, y, x);                /* o anki imleç konumunu al  */
    if(y == (row - 1))                  /* ekranın sonunda mıyız?    */
    {
      printw("&lt;-Bir tuşa basınız->");
                              /* kullanıcıya bir tuşa basmasını söyle */
      getch();
      clear();                          /* ekranı temizle */
      move(0, 0);                       /* ekranın başına git */
    }
    if(prev == '/' &amp;&amp; ch == '*') /* Eğer sadece / ve * karakteri ise
                                         * koyu göstermeyi etkinleştir */
    {
      attron(A_BOLD);                   /* koyu gösterme etkin */
      getyx(stdscr, y, x);              /* imlecin o anki konumunu al */
      move(y, x - 1);                   /* bir karakter geri git */
      printw("%c%c", '/', ch);          /* esas görüntüleme burada yapılmakta */
    }
    else
      printw("%c", ch);
    refresh();
    if(prev == '*' &amp;&amp; ch == '/')
      attroff(A_BOLD);                  /* eğer * ve / okunduysa *
                                         * koyu göstermeyi kapat */
    prev = ch;
  }
  endwin();                             /* curses kipi sonu */
  fclose(fp);
  return 0;
}
</programlisting></para>
</example><para>
Tüm şu ilklendirme ve ıvır zıvırlardan korkmayın. <literal>While</literal> döngüsüne dikkatinizi verin. Her bir karakteri okuyarak <literal>/*</literal> karakter ikilisini aranmaktadır. Bir kere örüntüyü buldu mu <command>attron()</command> ile BOLD (koyu gösterme) özelliğini etkin hale getirmektedir. <literal>*/</literal> karakter ikilisi okunduğunda bu öznitelik <command>attroff()</command> ile kapatılmaktadır.
</para><para>
Yukarıdaki program bize <command>getyx() </command> ve <command>move()</command> gibi iki faydalı işlevi tanıtmaktadır. İlk işlev imlecin o anki koordinatlarını <literal>y, x</literal> değerlerine alır. <function>getyx()</function> bir makro olduğundan işleve gösterici aktarmak zorunda değiliz.  <command>move()</command> işlevi imleci verilen koordinatlara hareket ettirir.
</para><para>
Yukarıdaki program pek de fazla bir iş yapmayan gerçekten de basit bir örnektir. Bu satırlarda birileri bir C dosyasını okuyup, onu ayrıştırıp değişik renklerde gösteren daha kullanışlı bir program yazabilir. Birisi bunu başka dillere de genişletebilir.
</para>
<sect2 userlevel="chunkthis" xml:id="ncurses-howto-attribdetails">
<title>Özniteliklerle ilgili ayrıntılar</title>
<para>
Özniteliklerin ayrıntılarına inelim. <command>attron(), attroff(), attrset() </command> ve onun kardeş işlevleri <command> attr_get()</command> v.b gibi işlevler öznitelikleri açıp, özniteliğin ne olduğu bilgisini almada ve renkli bir görüntü sağlamada kullanılabilir.
</para><para>
<function>attron</function> ve <function>attroff</function> işlevleri bir grup özniteliği değiştirge olarak alabilmekte ve onları sırasıyla açıp kapamaktadır. Aşağıdaki <filename>curses.h</filename> içerisinde tanımlanmış öznitelikler bu işlevlere gönderilebilir:
</para>
<literallayout indent="0">
    A_NORMAL        Normal görüntü (parlaklaştırma yok)
    A_STANDOUT      Uçbirimin en iyi parlaklaştırma kipi.
    A_UNDERLINE     Alt çizgili
    A_REVERSE       Ters video
    A_BLINK         Yanıp sönme
    A_DIM           Yarım parlak
    A_BOLD          Daha fazla parlak ve koyu
    A_PROTECT       Korumalı kip
    A_INVIS         Görünmez veya boş kip
    A_ALTCHARSET    İlave karakter kümesi
    A_CHARTEXT      Bir karakteri açığa çıkarmak için bit maskesi
    COLOR_PAIR(n)   Renk çifti numarası n
</literallayout>
<para>
En sonuncusu en renkli olanıdır <literal>:-)</literal> ve <xref linkend="ncurses-howto-color"/> bölümünde renkler anlatılmıştır.
</para><para>
Yukarıdaki özniteliklerden pekçoğunu VEYA (|)'layarak değişik özellikler elde edebiliriz. Ters video görüntüsü ve yanıp sönme isterseniz şunu kullanabilirsiniz:
</para><para>
<programlisting>
attron(A_REVERSE | A_BLINK);
</programlisting>
</para>
</sect2>

<sect2 userlevel="chunkthis" xml:id="ncurses-howto-attronvsattrset">
<title><function>attron()</function>'a karşı <function>attrset()</function></title>
<para>
Peki öyleyse <function>attron()</function> ve <function>attrset()</function> arasındaki fark nedir? <function>attrset</function>, pencerenin özniteliklerini ayarlarken <function>attron</function> sadece kendisine verilen özniteliği etkin yapar. Bu yüzden <function>attrset()</function> daha önceki pencere özniteliklerinin üstüne yazar ve yeni öznitelikleri ayarlar. Benzer çekilde <function>attroff()</function> sadece değiştirge olarak verilen özniteliği etkisizleştirir. Bu bize görünüm özelliklerini rahat şekilde yönetebilme imkanı verir. Fakat bunları dikkatsizce kullanırsanız pencerenin hangi özniteliğe sahip olduğunu takip etmekte zorlanıp görüntünün bozulmasına sebep olabilirsiniz. Bu öznitelikler renkli menüler ve parlaklaştırma üzerinde çalışırken önemlidir. Bu yüzden belli bir yöntemi takip edin ve hep onu kullanın. Her zaman <command>attrset(A_NORMAL)</command> komutuna eşit olan <command>standend()</command>'i tüm öznitelikleri etkisizleştirmek ve normal görünüme dönmek için kullanabilirsiniz.
</para>
</sect2>

<sect2 userlevel="chunkthis" xml:id="ncurses-howto-attr_get">
<title><function>attr_get()</function></title>
<para>
<function>attr_get()</function> işlevi o anki özniteliği ve renk çifti bilgisini alır. Her ne kadar yukarıdaki işlevler kadar sık kullanmasak da, ekranın belli kısımlarını tararken kullanışlıdır. Diyelim ki ekran üzerinde belli bir göncelleme yapmak istiyoruz ve her karakterin hangi özniteliğe sahip olduğunu bilmiyoruz. Bu işlev <function>attrset</function> veya <function>attron</function> işlevlerinden herhangi birisi ile istenen özniteliğin üretilmesi için kullanılabilir.
</para>
</sect2>

<sect2 userlevel="chunkthis" xml:id="ncurses-howto-attr_funcs">
<title><function>attr_</function> işlevleri</title><para>
<function>attr_set()</function>, <function>attr_</function> gibi birçok işlev vardır. Yukarıdakilere benzemekle beraber <command>attr_t</command> türünde değiştirge alırlar.
</para>
</sect2>

<sect2 userlevel="chunkthis" xml:id="ncurses-howto-wattrfuncs">
<title><function>wattr</function> işlevleri</title><para>
Yukarıdaki her bir işleve karşılık gelen ve belli pencere üzerinde çalışan '<function>w</function>''li işlevler de vardır. Yukarıdaki işlevler <literal>stdscr</literal> üzerinde çalışır.
</para>
</sect2>

<sect2 userlevel="chunkthis" xml:id="ncurses-howto-chgat">
<title><function>chgat()</function> işlevleri</title><para>
<function>chgat()</function> işlevi, <filename>curs_attr</filename> kılavuz sayfalarının sonunda listelenmiştir. Aslında faydalı bir işlevdir. Belli karakterlere hareket etmeden öznitelikleri kazandırmak için kullanılabilir. İmleci hareket ettirmeden !!! demek istedim <literal>:-)</literal>. O anki imleç konumundan itibaren belirtilen sayıdaki öznitelik değiştirilebilir.
</para><para>
Karakter sayısı olarak -1 vererek satır sonuna kadar güncelleyebiliriz. O anki konumdan satır sonuna kadar öznitelikleri değiştirmek için sadece şunu kullanın:
</para><para>
<programlisting>
chgat(-1, A_REVERSE, 0, NULL);
</programlisting>
</para><para>
Bu işlev halihazırda ekranda olan karakterlerin özniteliklerini değiştirmek için faydalıdır. Değiştirmek istediğiniz karaktere konumlanın ve özniteliğini değiştirin.
</para><para>
<function>wchgat(), mvchgat(), wchgat()</function> işlevleri de belirtilen pencere üzerinde çalışmaları dışında benzerdir. <function>mv</function> işlevleri önce imleci hareket ettirip daha sonra kendilerine verilen işi yapar. Aslında <function>chgat</function>, <function>wchgat()</function> işlevinin pencere değiştirgesi olarak <literal>stdscr</literal>'yi aldığı duruma bir makrodur. Pekçok "<function>w</function>'siz" işlev aslında birer makrodur.
</para>
<example xml:id="ncurses-howto-bwich">
<title><function>chgat()</function> Kullanım Örneği </title><para>
<programlisting>
#include &lt;ncurses.h>

int main(int argc, char *argv[])
{ initscr();                      /* Curses kipine başlama  */
  start_color();                  /* Renk özelliği etkin    */

  init_pair(1, COLOR_CYAN, COLOR_BLACK);
  printw("Yazmaya üsendigim oldukça uzun bir dizge ");
  mvchgat(0, 0, -1, A_BLINK, 1, NULL);
  /*
    * İlk iki değiştirge başlangıç konumunu
    * üçüncü değiştirge güncellenecek karakter sayısını belirtir.
    * -1 satır sonuna kadar demektir.
    * Dördüncü değiştirge karaktere kazandırmak istediğiniz özniteliktir
    * Beşincisi renk indisidir. init_pair() sırasında verilen indistir.
    * Renk istemiyorsanız 0 kullanın.
    * Altıncısı her zaman NULL değerdir.
    */
  refresh();
  getch();
  endwin();                       /* Curses kipi sonu  */
  return 0;
}
</programlisting></para>
</example><para>
Bu örnek aynı zamanda curses dünyasının renk kullanımını da göstermektedir. Renkler konusu  <link linkend="ncurses-howto-color">daha sonra</link> ayrıntılı olarak açıklanacaktır. Renkli görüntü istemiyorsanız 0 kullanın.
</para>
</sect2>
</sect1>

<sect1 xml:id="ncurses-howto-windows"><title>Pencereler</title><para>
Pencereler curses kütüphanesinde en önemli konuyu oluşturmaktadır. Tüm işlevlerin gizli şekilde üzerinde çalıştıkları standart <literal>stdscr</literal> penceresini bu ana kadar gördünüz. Basit bir kullanıcı arayüzü tasarlamak için bile, pencereler kullanmalısınız. Pencere kullanmanızın temel sebebi, daha iyi bir tasarım için güncellenmesi gereken pencereleri değiştirerek, daha verimli bir çalışma için ekranın belli kısımlarını bağımsız olarak değiştirmektir. Son söylediğim pencereler ile ilgili en önemli noktadır. Her zaman programınızda kolay yönetilebilir ve daha iyi tasarımlara yönelmelisiniz. Eğer büyük ve karmaşık kullanıcı arayüzleri yazıyorsanız, bu yaklaşım, herhangi bir iş yapmadan önce hayati öneme sahip bir noktadır.
</para>
<sect2 userlevel="chunkthis" xml:id="ncurses-howto-windowbasics">
<title>Temel bilgiler</title><para>
Bir pencere <command>newwin()</command> işlevini çağırarak oluşturulabilir. Ekran üzerinde aslında birşey oluşturmaz. Pencereyi değiştirecek yapılar için bellekten yer ayırır ve pencerenin boyutu, başladığı y koordinatı, başladığı x koordinatı, v.b bilgilerle ilgili yapıları günceller. Böylece curses kullanımında pencere kavramı, ekranın diğer kısımlarından bağımsız olarak değiştirilebilen hayali bir soyutlamadır.  <function>newwin()</function> işlevi, <function>wprintw()</function> ve v.b. pencere ilişkili işlevlerde kullanılabilecek  WINDOW veri yapısı türünden bir gösterici döndürür. Son olarak pencere <function>delwin()</function> işlevi ile yok edilebilir. Bu işlev pencere yapısıyla bellekte ayrılmış alanı geri verecektir.
</para>
</sect2>

<sect2 userlevel="chunkthis" xml:id="ncurses-howto-letbewindow">
<title>Bana bir Pencere göster !!!</title><para>
Eğer bir pencere oluşturuldu ve biz de göremiyorsak bu komik bir durumdur. Eğlenceli kısım pencereyi göstermekle başlar. <command>box()</command> işlevi pencere etrafına bir çerçeve çizmek için kullanılır. Bu işlevleri aşağıdaki örnekte daha ayrıntılı inceleyelim.
</para>
<example xml:id="ncurses-howto-bwibo">
<title>Pencere Çerçevesi örneği</title><para>
<programlisting>
#include &lt;ncurses.h>

WINDOW *create_newwin(int height, int width, int starty, int startx);
void destroy_win(WINDOW *local_win);

int main(int argc, char *argv[])
{ WINDOW *my_win;
  int startx, starty, width, height;
  int ch;

  initscr();                      /* Curses kipini ilklendirme    */
  cbreak();                       /* Satır önbelleği etkisiz,     *
                                   * herşeyi bana gönder          */
  keypad(stdscr, TRUE);           /* Şu şeker F1'e ihtiyacım var  */

  height = 3;
  width = 10;
  starty = (LINES - height) / 2;  /* Pencerenin ortasına yazmak için */
  startx = (COLS - width) / 2;    /* hesaplama yapılıyor             */
  printw("Press F1 to exit");
  refresh();
  my_win = create_newwin(height, width, starty, startx);

  while((ch = getch()) != KEY_F(1))
  { switch(ch)
    { case KEY_LEFT:
        destroy_win(my_win);
        my_win = create_newwin(height, width, starty,--startx);
        break;
      case KEY_RIGHT:
        destroy_win(my_win);
        my_win = create_newwin(height, width, starty,++startx);
        break;
      case KEY_UP:
        destroy_win(my_win);
        my_win = create_newwin(height, width, --starty,startx);
        break;
      case KEY_DOWN:
        destroy_win(my_win);
        my_win = create_newwin(height, width, ++starty,startx);
        break;
    }
  }

  endwin();                       /* Curses kipi sonu */
  return 0;
}

WINDOW *create_newwin(int height, int width, int starty, int startx)
{ WINDOW *local_win;

  local_win = newwin(height, width, starty, startx);
  box(local_win, 0 , 0);          /* 0, 0 yatay ve düşey çizgiler    *
                                   * için öntanımlı karakteri verir  */
  wrefresh(local_win);            /* Kutuyu gösterir                 */

  return local_win;
}

void destroy_win(WINDOW *local_win)
{
  /* box(local_win, ' ', ' '); : Bu istenen pencere silme sonucunu
    * vermeyecektir. Pencerenin dört köşesi ve
    * çirkin küçük bir kısmı kalacaktır.
    */
  wborder(local_win, ' ', ' ', ' ',' ',' ',' ',' ',' ');
  /* Alınan değiştirgeler şu şekildedir
    * 1. win: üzerinde çalışılacak pencere
    * 2. ls: pencerenin sol kenarı için kullanılacak karakter
    * 3. rs: pencerenin sağ kenarı için kullanılacak karakter
    * 4. ts: pencerenin üst kenarı için kullanılacak karakter
    * 5. bs: pencerenin alt kenarı için kullanılacak karakter
    * 6. tl: pencerenin sol üst köşesi için kullanılacak karakter
    * 7. tr: pencerenin sağ üst köşesi için kullanılacak karakter
    * 8. bl: pencerenin sol alt köşesi için kullanılacak karakter
    * 9. br: pencerenin sağ alt köşesi için kullanılacak karakter
    */
  wrefresh(local_win);
  delwin(local_win);
}
</programlisting></para>
</example>
</sect2>
<sect2 userlevel="chunkthis" xml:id="ncurses-howto-borderexexpl">
<title>Örneğin açıklaması</title><para>
Çığlık atmayın. Biliyorum büyük bir örnek. Fakat bazı önemli noktaları burada anlatmalıyım :-). Bu program sol, sağ, üst ve aşağı ok tuşlarıyla hareket eden dikdörtgen bir pencere oluşturur. Ardışıl olarak kullanıcının her tuşa basışında pencereyi yıkıp yeniden oluşturur. Ekran sınırlarının ötesine gitmeyin. Bu sınırların kontrol edilmesi okuyucuya bir örnek olarak bırakılmıştır. Şimdi satır satır inceleyelim.
</para><para>
<command>create_newwin()</command> işlevi <command>newwin() </command> ile yeni bir pencere oluşturur ve etrafına <function>box()</function> işlevi ile bir çerçeve çizer. <command>destroy_win()</command> işlevi ilk önce ' ' karakteri ile bir çerçeve oluşturarak pencereyi ekrandan siler ve daha sonra <command>delwin()</command>'i çağırarak onunla ilişkili belleği geri verir. Kullanıcının bastığı tuşa bağlı olarak, <varname>starty</varname> ve <varname>startx</varname> değişir ve yeni bir pencere oluşturulur.
</para><para>
<function>destroy_win</function> içerisinde gördüğünüz gibi, <function>wborder</function> yerine <function>box</function> işlevini kullandım. Nedeni açıklama satırlarında yazılı (Atladınız. Biliyorum. Kodu okuyun <literal>:-)</literal>). <function>wborder</function>, belirtilen 4 köşe ve 4 çizgi değiştirgesiyle pencere etrafına bir çerçeve çizer. Daha açık hale getirmek için, eğer <function>wborder</function>'ı aşağıdaki şekilde çağırırsanız:

</para><para>
<programlisting>wborder(win, '|', '|', '-', '-', '+', '+', '+', '+');
</programlisting>
</para><para>
şöyle bir şey üretir:
</para><para>
<programlisting>
  +------------+
  |            |
  |            |
  |            |
  |            |
  |            |
  |            |
  +------------+
</programlisting></para>
</sect2>

<sect2 userlevel="chunkthis" xml:id="ncurses-howto-otherstuff">
<title>Örnekteki diğer kısımlar</title><para>
Yukarıdaki örnekte aynı zamanda <function>initscr()</function> kullanımından sonra ekran boyutlarına ilklendirilen <varname>COLS</varname> ve <varname>LINES</varname> değişkenlerini kullandığım gözükmektedir. Ekran boyutlarının bulunmasında ve yukarıdaki gibi ekranın ortasının koordinatlarının bulunmasında faydalı olabilir. <command>getch()</command> bilindiği gibi klavyeden bir tuş bilgisi alır ve basılan tuşa karşılık gelen işi yapar. Bu şekildeki <statement>switch- case</statement>
kullanımı kullanıcı grafik arayüzü programlamada çok yaygındır.
</para>
</sect2>

<sect2 userlevel="chunkthis" xml:id="ncurses-howto-otherborderfuncs">
<title>Diğer Çerçeve işlevleri</title><para>
Yukarıdaki program, her tuşa basımda bir pencerenin yıkılıp yenisinin oluşturulmasından dolayı oldukça verimsizdir. Bunun için diğer çerçeve çizimi ile ilgili işlevleri kullanarak daha verimli bir program yazalım.
</para><para>
Aşağıdaki programda <command>mvhline()</command> ve <command>mvvline()</command> kullanarak benzer etki sağlanmıştır. Bu iki işlev basittir. Belirtilen boyda ve belirtilen konumda yatay ve düşey çizgiler oluştururlar.
</para>
<example xml:id="ncurses-howto-botbo">
<title>Daha çok çerçeve işlevi</title><para>
<programlisting>
#include &lt;ncurses.h>

typedef struct _win_border_struct {
  chtype  ls, rs, ts, bs,
          tl, tr, bl, br;
}WIN_BORDER;

typedef struct _WIN_struct {
  int startx, starty;
  int height, width;
  WIN_BORDER border;
}WIN;

void init_win_params(WIN *p_win);
void print_win_params(WIN *p_win);
void create_box(WIN *win, bool flag);

int main(int argc, char *argv[])
{ WIN win;
  int ch;

  initscr();                      /* curses ilklendirme           */
  start_color();                  /* Renk özelliğini başlat       */
  cbreak();                       /* Satır önbelleği etkisiz,     *
                                   * herşeyi bana gönder          */
  keypad(stdscr, TRUE);           /* Şu şeker F1'e ihtiyacım var  */
  noecho();
  init_pair(1, COLOR_CYAN, COLOR_BLACK);

  /* Pencere değiştirgelerini ilklendir */
  init_win_params(&amp;win);
  print_win_params(&amp;win);

  attron(COLOR_PAIR(1));
  printw("Çıkmak için F1'e basınız");
  refresh();
  attroff(COLOR_PAIR(1));

  create_box(&amp;win, TRUE);
  while((ch = getch()) != KEY_F(1))
  { switch(ch)
    { case KEY_LEFT:
        create_box(&amp;win, FALSE);
        --win.startx;
        create_box(&amp;win, TRUE);
        break;
      case KEY_RIGHT:
        create_box(&amp;win, FALSE);
        ++win.startx;
        create_box(&amp;win, TRUE);
        break;
      case KEY_UP:
        create_box(&amp;win, FALSE);
        --win.starty;
        create_box(&amp;win, TRUE);
        break;
      case KEY_DOWN:
        create_box(&amp;win, FALSE);
        ++win.starty;
        create_box(&amp;win, TRUE);
        break;
    }
  }
  endwin();                       /* Curses kipi sonu */
  return 0;
}
void init_win_params(WIN *p_win)
{
    p_win->height = 3;
    p_win->width = 10;
    p_win->starty = (LINES - p_win->height)/2;
    p_win->startx = (COLS - p_win->width)/2;

    p_win->border.ls = '|';
    p_win->border.rs = '|';
    p_win->border.ts = '-';
    p_win->border.bs = '-';
    p_win->border.tl = '+';
    p_win->border.tr = '+';
    p_win->border.bl = '+';
    p_win->border.br = '+';
}
void print_win_params(WIN *p_win)
{
#ifdef _DEBUG
  mvprintw(25, 0, "%d %d %d %d", p_win->startx, p_win->starty,
           p_win->width, p_win->height);
  refresh();
#endif
}
void create_box(WIN *p_win, bool flag)
{ int i, j;
  int x, y, w, h;

  x = p_win->startx;
  y = p_win->starty;
  w = p_win->width;
  h = p_win->height;

  if(flag == TRUE)
  { mvaddch(y, x, p_win->border.tl);
    mvaddch(y, x + w, p_win->border.tr);
    mvaddch(y + h, x, p_win->border.bl);
    mvaddch(y + h, x + w, p_win->border.br);
    mvhline(y, x + 1, p_win->border.ts, w - 1);
    mvhline(y + h, x + 1, p_win->border.bs, w - 1);
    mvvline(y + 1, x, p_win->border.ls, h - 1);
    mvvline(y + 1, x + w, p_win->border.rs, h - 1);

  }
  else
    for(j = y; j &lt;= y + h; ++j)
      for(i = x; i &lt;= x + w; ++i)
        mvaddch(j, i, ' ');

  refresh();
}
</programlisting></para>
</example>
</sect2>
</sect1>

<sect1 xml:id="ncurses-howto-color"><title>Renkler</title>
<sect2 userlevel="chunkthis" xml:id="ncurses-howto-colorbasics">
<title>Temel bilgiler</title><para>
Hayat renkler olmadan çok donuk gözükürdü. Curses kütüphanesi renkler üzerinde işlem yapmak için hoş bir mekanizmaya sahiptir. Basit bir program ile işlerin ayrıntılarına inelim.
</para>
<example xml:id="ncurses-howto-bsico">
<title>Basit Bir Renk Örneği </title><para>
<programlisting>
#include &lt;ncurses.h>

void print_in_middle(WINDOW *win, int starty, int startx,
                     int width, char *string);
int main(int argc, char *argv[])
{ initscr();                      /* curses kipi ilklendirmesi */
  if(has_colors() == FALSE)
  { endwin();
    printf("Uçbiriminiz renkleri desteklemiyor\n");
    exit(1);
  }
  start_color();                  /* Renk başlat */
  init_pair(1, COLOR_RED, COLOR_BLACK);

  attron(COLOR_PAIR(1));
  print_in_middle(stdscr, LINES / 2, 0, 0, "Keman !!! Renkli ...");
  attroff(COLOR_PAIR(1));
  getch();
  endwin();
}
void print_in_middle(WINDOW *win, int starty, int startx,
                     int width, char *string)
{ int length, x, y;
  float temp;

  if(win == NULL)
    win = stdscr;
  getyx(win, y, x);
  if(startx != 0)
    x = startx;
  if(starty != 0)
    y = starty;
  if(width == 0)
    width = 80;

  length = strlen(string);
  temp = (width - length)/ 2;
  x = startx + (int)temp;
  mvwprintw(win, y, x, "%s", string);
  refresh();
}
</programlisting></para>
</example><para>
Görüdüğünüz üzere renkleri kullanabilmeniz için öncelikle <command>start_color()</command> işlevini çağırmalısınız. Bundan sonra değişik işlevler kullanarak uçbiriminizin renk yeteneklerini kullanabilirsiniz. Bir uçbirimin renk özniteliklerinin olup olmadığını anlamak için <command>has_colors()</command> işlevini kullanabilirsiniz. Eğer FALSE dönerse, uçbirimin renk desteği yoktur.
</para><para>
<function>start_color()</function> işlevi çağrıldığı anda Curses uçbirim tarafından desteklenen tüm renkleri ilklendirir. Bu renklere <command>COLOR_BLACK</command> v.b. gibi tanımlanmış sabitlerle erişilebilir. Aslında renkleri tam olarak kullanabilmek için çiftleri tanımlamalısınız. Renkler daima çiftler halinde kullanılır. Bunun anlamı <command>init_pair()</command> işlevini kullanarak artalan ve karakter rengi için bir renk çifti belirtmeniz demektir. Bundan sonra bu renk çifti <command>COLOR_PAIR()</command> ile normal bir öznitelik olarak kullanılabilir. İlk başta karmaşık gelebilir. Fakat bu zeki yaklaşım renk çiftleri üzerinde rahatça işlem yapabilmemizi sağlar. Kullanımına hayran olmak için, kabuk betiklerinden etkileşimli iletiler çıkaran "dialog" uygulamasının kaynak koduna bakmalısınız. Geliştiriciler ihtiyaç olabilecek her renk için artalan ve karakter rengi türevlerini tanımlamışlar ve başlangıçta ilklendirmişlerdir. Bu da halihazırda sabit olarak tanımlanmış çiftlere erişip görünüm özelliklerini ayarlamada kolaylık sağlamaktadır.
</para><para>
Aşağıdaki renkler <filename>curses.h</filename> başlık dosyasında tanımlanmıştır. Bunları pekçok renk işlevi için değiştirge olarak kullanabilirsiniz.
</para>
<literallayout indent="0">
      COLOR_BLACK   0
      COLOR_RED     1
      COLOR_GREEN   2
      COLOR_YELLOW  3
      COLOR_BLUE    4
      COLOR_MAGENTA 5
      COLOR_CYAN    6
      COLOR_WHITE   7
</literallayout>
</sect2>

<sect2 userlevel="chunkthis" xml:id="ncurses-howto-changecolordefs">
<title>Renk Tanımlamalarını Değiştirmek</title><para>
<command>init_color()</command> işlevi curses kipi ilklendirildiğindeki rgb değerlerini değiştirmek için kullanılabilir. Diyelim ki kırmızı rengin yoğunluğunu biraz açmak istiyorsunuz. O zaman bu işlevi şu şekilde kullanabilirsiniz:
</para><para>
<programlisting>
init_color(COLOR_RED, 700, 0, 0);
  /* 1. değiştirge         : renk adı
   * 2, 3, 4. değiştirgeler: rgb içeriği; 0 ile 1000 arasında bir değer */
</programlisting>
</para><para>
Eğer kullandığınız uçbirim renk tanımlamalarını değiştiremiyorsa işlev <literal>ERR</literal> ile geri döner.  <command>can_change_color()</command> işlevi uçbirimin renk içeriğini değiştirme yeteneği olup olmadığını öğrenmek için kullanılabilir. RGB içeriği 0 dan 1000'e kadar ölçeklenmiştir. Kırmızı renk 1000(r), 0(g), 0(b) ile tanımlanmıştır.
</para>
</sect2>

<sect2 userlevel="chunkthis" xml:id="ncurses-howto-colorcontent">
<title>Renk İçeriği</title><para>
<command>color_content()</command> ve <command>pair_content()</command> işlevleri renk içeriğini bulmak ve renk çifti için ön ve art alan bilgisini almak için kullanılabilir.
</para>
</sect2>
</sect1>

<sect1 xml:id="ncurses-howto-keys"><title>Klavye ile etkileşim</title>
<sect2 userlevel="chunkthis" xml:id="ncurses-howto-keysbasics">
<title>Temel bilgiler</title><para>
Hiçbir grafik kullanıcı arabirimi güçlü bir arayüze sahip olmadan tamamlanmış sayılmaz ve kullanıcı ile etkileşimde olabilmek için bir curses programı tuş basımına veya fare hareketlerine duyarlı olmalıdır. Önce tuşlarla ilgilenelim.
</para><para>
Önceki hemen her örnekte gördüğünüz gibi kullanıcıdan klavye girdisi almak çok kolaydır. Tuş basımlarını almanın en basit yolu <command>getch()</command> işlevidir. Satır karakterlerinin tamamı yerine (genelde satır sonu karakteri ile biter) tek bir karakter okunmasıyla ilgilenirseniz <function>cbreak</function> kipi etkin hale getirilmelidir. İşlev, ok v.b. tuşlarını kullanabilmek için tuş takımı etkin hale getirilmelidir. Ayrıntılar için <xref linkend="ncurses-howto-init"/> bölümüne bakınız.
</para><para>
<command>getch()</command> komutu basılan tuşa uygun olarak bir tam sayı döndürür. Eğer normal bir karakterse tam sayı değeri karaktere eşit olacaktır. Aksi halde <filename>curses.h</filename> başlık dosyasında sabit olarak tanımlanmış bir sayı ile döner. Örneğin kullanıcı F1'e basarsa geri dönen tam sayı değeri 265'tir. Bu, <filename>curses.h</filename> içerisinde tanımlanmış olan <function>KEY_F()</function> makrosu kullanılarak kontrol edilebilir. Bu tuşları okumayı ve taşınabilmelerini kolay ve üzerinde işlem yapılabilir hale getirmektedir.
</para><para>
Örneğin <function>getch()</function>'ı şu şekilde çağırırsanız,
</para><para>
<programlisting>
  int ch;

  ch = getch();
</programlisting>
</para><para>
<function>getch()</function> kullanıcıdan bir tuşa basmasını bekleyecek (eğer belli bir zaman aşımı tanımlamadıysanız) ve kullanıcı tuşa bastığı anda karşılık gelen tamsayıyı döndürülecektir. Daha sonra dönen değeri <filename>curses.h</filename> içerisinde tanımlanmış sabitlerle kıyaslayarak istediğiniz tuşlarla eşleşmeyi sağlayabilirsiniz.
</para><para>
Aşağıdaki kod parçası bu işi yapacaktır.
</para><para>
<programlisting>
  if(ch == KEY_LEFT)
    printw("Sola ok tusuna basıldı\n");
</programlisting>
</para><para>
Yukarı ve aşağı ok tuşlarıyla hareket edilebilen bir menü yazalım.
</para>
</sect2>

<sect2 userlevel="chunkthis" xml:id="ncurses-howto-simplekeyex">
<title>Basit bir tuş kullanım örneği </title>
<example xml:id="ncurses-howto-bsike">
<title>Basit bir tuş kullanım örneği</title><para>
<programlisting>
#include &lt;stdio.h>
#include &lt;ncurses.h>

#define WIDTH 30
#define HEIGHT 10

int startx = 0;
int starty = 0;

char *choices[] = {
  "Choice 1",
  "Choice 2",
  "Choice 3",
  "Choice 4",
  "Exit",
};
int n_choices = sizeof(choices) / sizeof(char *);
void print_menu(WINDOW *menu_win, int highlight);

int main()
{ WINDOW *menu_win;
  int highlight = 1;
  int choice = 0;
  int c;

  initscr();
  clear();
  noecho();
  cbreak();       /* Satır ön belleği etkisiz. Herşeyi bana gönder */
  startx = (80 - WIDTH) / 2;
  starty = (24 - HEIGHT) / 2;

  menu_win = newwin(HEIGHT, WIDTH, starty, startx);
  keypad(menu_win, TRUE);
  mvprintw(0, 0, "Yukarı ve asagı için ok tuslarını kullanın, "
          "Seçmek için enterı kullanın");
  refresh();
  print_menu(menu_win, highlight);
  while(1)
  { c = wgetch(menu_win);
    switch(c)
    { case KEY_UP:
        if(highlight == 1)
          highlight = n_choices;
        else
          --highlight;
        break;
      case KEY_DOWN:
        if(highlight == n_choices)
          highlight = 1;
        else
          ++highlight;
        break;
      case 10:
        choice = highlight;
        break;
      default:
        mvprintw(24, 0,
          "Basılan karakter = %3d Muhtemelen şu şekilde de yazılabilir '%c'",
          c, c);
        refresh();
        break;
    }
    print_menu(menu_win, highlight);
    if(choice != 0) /* Sonsuz döngüden çıkmak için kullanıcı bir seçim yapar */
      break;
  }
  mvprintw(23, 0, "%d'yi %s ile seçtiniz\n",
           choice, choices[choice - 1]);
  clrtoeol();
  refresh();
  endwin();
  return 0;
}


void print_menu(WINDOW *menu_win, int highlight)
{
  int x, y, i;

  x = 2;
  y = 2;
  box(menu_win, 0, 0);
  for(i = 0; i &lt; n_choices; ++i)
  { if(highlight == i + 1) /* O an seçileni parlaklaştır */
    { wattron(menu_win, A_REVERSE);
      mvwprintw(menu_win, y, x, "%s", choices[i]);
      wattroff(menu_win, A_REVERSE);
    }
    else
      mvwprintw(menu_win, y, x, "%s", choices[i]);
    ++y;
  }
  wrefresh(menu_win);
}
</programlisting></para>
</example>
</sect2>
</sect1>

<sect1 xml:id="ncurses-howto-mouse">
<title>Fare ile Etkileşim</title><para>
Artık tuşlar ile etkileşimi biliyorsunuz, şimdi aynısını fare ile yapalım. Genelde her kullanıcı arayüzü hem klavye hem de fare ile kullanıcının etkileşimine izin vermektedir.
</para>

<sect2 userlevel="chunkthis" xml:id="ncurses-howto-mousebasics">
<title>Temel bilgiler </title><para>
Herhangi bir şey yapmadan önce almak istediğiniz olaylar <command>mousemask()</command> ile etkin hale getirilmelidir.
</para><para>
<programlisting>
mousemask(  mmask_t newmask,    /* Dinlemek istediğiniz olaylar */
            mmask_t *oldmask)   /* Eski olay maskesi            */
</programlisting>
</para><para>
Yukarıdaki işleve ilk değiştirge dinlemek istediğiniz olaylara bir bit maskesidir. Öntanımlı olarak her olay etkisizleştirilmiştir. <command>ALL_MOUSE_EVENTS</command> bit maskesi tüm olayları almak için kullanılabilir.
</para><para>
Aşağıdakiler tüm olay maskeleridir.
</para>
<literallayout indent="0">
    İsim                     Açıklama
    ---------------------------------------------------------------------
    BUTTON1_PRESSED          fare tuşu 1 basılı
    BUTTON1_RELEASED         fare tuşu 1 serbest
    BUTTON1_CLICKED          fare tuşu 1 tıklandı
    BUTTON1_DOUBLE_CLICKED   fare tuşu 1 iki kere tıklandı
    BUTTON1_TRIPLE_CLICKED   fare tuşu 1 üç kere tıklandı
    BUTTON2_PRESSED          fare tuşu 2 basılı
    BUTTON2_RELEASED         fare tuşu 2 serbest
    BUTTON2_CLICKED          fare tuşu 2 tıklandı
    BUTTON2_DOUBLE_CLICKED   fare tuşu 2 iki kere tıklandı
    BUTTON2_TRIPLE_CLICKED   fare tuşu 2 üç kere tıklandı
    BUTTON3_PRESSED          fare tuşu 3 basılı
    BUTTON3_RELEASED         fare tuşu 3 serbest
    BUTTON3_CLICKED          fare tuşu 3 tıklandı
    BUTTON3_DOUBLE_CLICKED   fare tuşu 3 iki kere tıklandı
    BUTTON3_TRIPLE_CLICKED   fare tuşu 3 üç kere tıklandı
    BUTTON4_PRESSED          fare tuşu 4 basılı
    BUTTON4_RELEASED         fare tuşu 4 serbest
    BUTTON4_CLICKED          fare tuşu 4 tıklandı
    BUTTON4_DOUBLE_CLICKED   fare tulu 4 iki kere tıklandı
    BUTTON4_TRIPLE_CLICKED   fare tuşu 4 üç kere tıklandı
    BUTTON_SHIFT             tuş durumu değiştiğinde shift'e basılıydı
    BUTTON_CTRL              tuş durumu değiştiğinde control'e basılıydı
    BUTTON_ALT               tuş durumu değiştiğinde alt'a basılıydı
    ALL_MOUSE_EVENTS         tüm tuş durumu değişikliklerini bildir
    REPORT_MOUSE_POSITION    fare hareketini bildir
</literallayout>
</sect2>

<sect2 userlevel="chunkthis" xml:id="ncurses-howto-gettingevents">
<title>Olayları yakalamak</title><para>
Bir kere bir fare sınıfı olayları etkin hale getirildi mi, <function>getch()</function> türü işlevler her fare olayı olduğunda <literal>KEY_MOUSE</literal> döndürürler. Daha sonra da fare olayı <command>getmouse()</command> ile alınabilir.
</para><para>
Kod yaklaşık olarak şuna benzer:
</para><para>
<programlisting>
  MEVENT event;

  ch = getch();
  if(ch == KEY_MOUSE)
    if(getmouse(&amp;event) == OK)
      /* Olay ile ilgili bir şeyler yap */
      .
      .
</programlisting>
</para><para>
<function>getmouse()</function> olayı kendisine verilen göstericide döndürür. Göstericinin gösterdiği değer aşağıdakileri içeren bir yapıdır:
</para><para>
<programlisting>
typedef struct
{
  short id;         /* Pekçok aygıtı tanımlamak için ID */
  int x, y, z;      /* olay koordinatları */
  mmask_t bstate;   /* tuş durumu bitleri */
}
</programlisting>
</para><para>
<literal>bstate</literal> ilgilendiğimiz temel değişkendir. Farenin tuş durumu bilgisini verir.
</para><para>
Aşağıdakine benzer bir kodla ne olduğunu bulabiliriz.
</para><para>
<programlisting>
  if(event.bstate &amp; BUTTON1_PRESSED)
    printw("Sol Tuş Basıldı");
</programlisting></para>
</sect2>

<sect2 userlevel="chunkthis" xml:id="ncurses-howto-mousetogether">
<title>Hepsini Bir Araya Getirelim</title><para>
Fare ile etkileşmek için bunlar oldukça fazla. Aynı menüyü oluşturup fare etkileşimini etkin hale getirelim. İşleri basit hale getirmek için tuş etkileşimi kaldırılmıştır.
</para>
<example xml:id="ncurses-howto-bmome">
<title>Menüye fare ile erişim !!!</title><para>
<programlisting>
#include &lt;ncurses.h>

#define WIDTH 30
#define HEIGHT 10

int startx = 0;
int starty = 0;

char *choices[] = {
  "Choice 1",
  "Choice 2",
  "Choice 3",
  "Choice 4",
  "Exit",
};

int n_choices = sizeof(choices) / sizeof(char *);

void print_menu(WINDOW *menu_win, int highlight);
void report_choice(int mouse_x, int mouse_y, int *p_choice);

int main()
{ int c, choice = 0;
  WINDOW *menu_win;
  MEVENT event;

  /* curses kipini etkinleştirelim */
  initscr();
  clear();
  noecho();
  cbreak();       //Satır önbelleği etkisiz. Herşeyi gönder

  /* Pencereyi ekranın ortasına koymaya çalışıyoruz */
  startx = (80 - WIDTH) / 2;
  starty = (24 - HEIGHT) / 2;

  attron(A_REVERSE);
  mvprintw(23, 1, "Çıkmak için exit'e tıklayın "
          "(Sanal konsolda iyi çalışır)");
  refresh();
  attroff(A_REVERSE);

  /* Menüyü ilk olarak oluştur*/
  menu_win = newwin(HEIGHT, WIDTH, starty, startx);
  print_menu(menu_win, 1);
  /* Tüm fare olaylarını yakala*/
  mousemask(ALL_MOUSE_EVENTS, NULL);

  while(1)
  { c = wgetch(menu_win);
    switch(c)
    { case KEY_MOUSE:
        if(getmouse( &amp;event) == OK)
        { /* sol fare tuşuna basılınca */
          if(event.bstate  &amp; BUTTON1_PRESSED)
          { report_choice(event.x + 1, event.y + 1,  &amp;choice);
            if(choice == -1) //Çıkış seçildi
              goto end;
            mvprintw(22, 1, "Yapılan seçim : %d Seçilen \"%10s\"",
                     choice, choices[choice - 1]);
            refresh();
          }
        }
        print_menu(menu_win, choice);
        break;
    }
  }
end:
  endwin();
  return 0;
}

void print_menu(WINDOW *menu_win, int highlight)
{
  int x, y, i;

  x = 2;
  y = 2;
  box(menu_win, 0, 0);
  for(i = 0; i &lt; n_choices; ++i)
  { if(highlight == i + 1)
    { wattron(menu_win, A_REVERSE);
      mvwprintw(menu_win, y, x, "%s", choices[i]);
      wattroff(menu_win, A_REVERSE);
    }
    else
      mvwprintw(menu_win, y, x, "%s", choices[i]);
    ++y;
  }
  wrefresh(menu_win);
}

/* Fare konumuna göre seçimi bildir */
void report_choice(int mouse_x, int mouse_y, int *p_choice)
{ int i,j, choice;

  i = startx + 2;
  j = starty + 3;

  for(choice = 0; choice &lt; n_choices; ++choice)
    if(mouse_y == j + choice
       &amp;&amp; mouse_x >= i
       &amp;&amp; mouse_x &lt;= i + strlen(choices[choice]))
    { if(choice == n_choices - 1)
        *p_choice = -1;
      else
        *p_choice = choice + 1;
      break;
    }
}
</programlisting></para>
</example>
</sect2>

<sect2 userlevel="chunkthis" xml:id="ncurses-howto-miscmousefuncs">
<title>Çeşitli İşlevler</title><para>
<function>mouse_trafo()</function> ve <function>wmouse_trafo()</function> işlevleri fare koordinatlarını ekran koordinatlarına dönüştürmek için kullanılabilir. <link linkend="tr-man3-curs_mouse">curs_mouse(3X)</link> kılavuz sayfasını ayrıntılar için inceleyiniz.
</para><para>
<function>mouseinterval</function> işlevi tıklamaları tanımlayabilmek için tuşa basma ile çekme arasındaki en büyük zamanı saniyenin binde biri cinsinden ayarlar. Bu işlev önceki tıklama süresini döndürür. Öntanımlı değer saniyenin beşte biridir.
</para>
</sect2>
</sect1>

<sect1 xml:id="ncurses-howto-screen">
<title>Ekran Düzenleme</title><para>
Bu bölümde ekranı verimli olarak yönetmemizi sağlayan bazı işlevlere bakacağız ve bazı güzel programlar yazacağız. Bu özellikle oyun yazımında önemlidir.
</para>

<sect2 userlevel="chunkthis" xml:id="ncurses-howto-getyx">
<title><function>getyx()</function> işlevleri</title><para>
<command>getyx()</command> işlevi o anki imleç koordinatlarını bulmak için kullanılır. x ve y koordinat değerlerini kendisine verilmiş değişkenlere aktaracaktır. <function>getyx()</function> bir makro olduğundan değişkenlerin adreslerini göndermenize gerek yoktur. Şu şekilde çağrılabilir:
</para><para>
<programlisting>
  getyx(win, y, x);
  /* win: pencere gösterici
    *   y, x: kooridatlar bu değişkenlere aktarılır
    */
</programlisting>
</para><para>
<function>getparyx()</function> işlevi içteki pencerenin başlangıç koordinatlarını dıştakine göre döndürür. Bu bazen içteki pencereyi güncellemek gerektiğinde gereklidir. Pekçok menüden oluşan güzel bir uygulama tasarımında, menü konumlarını, ilk seçenek koordinatlarını, v.b. kaydetmek zor bir hal alır. Buna basit bir yöntem alt pencereler içerisinde menüler oluşturmak ve <function>getparyx()</function> kullanarak menülerin başlangıç koordinatlarını bulmaktır.
</para><para>
<function>getbegyx()</function> ve <function>getmaxyx()</function> işlevleri o anki pencerenin başlangıç ve en büyük koordinatlarını tutar. Bu işlevler yukarıdakine benzer şekilde pencere ve iç pencerelerde çalışırken faydalıdır.
</para>
</sect2>

<sect2 userlevel="chunkthis" xml:id="ncurses-howto-screendump">
<title>Ekran dökümünün alınması</title><para>
Oyun yazarken bazen ekran durumunun kaydedilmesi ve aynı duruma tekrar dönülmesi gerekmektedir. <function>scr_dump()</function> işlevi kendisine değiştirge olarak verilen dosyaya ekranın o anki konumuyla ilgili bilgileri yazmaktadır. Daha sonra <function>scr_restore</function> işlevi ile ekran durumu geri yüklenebilir. Bu iki basit işlev değişen senaryolara sahip hızlı bir oyunda verimli bir şekilde kullanılabilir.
</para>
</sect2>

<sect2 userlevel="chunkthis" xml:id="ncurses-howto-windowdump">
<title>Pencere dökümünün alınması</title><para>
Pencereleri kaydetmek ve geri yüklemek için <command>putwin()</command> ve <command>getwin()</command> işlevleri kullanılabilir. <command>putwin()</command>, daha sonra <command>getwin()</command> tarafından geri yüklenebilen pencere durumunu bir dosyaya yazar.
</para><para>
<command>copywin()</command> işlevi bir pencere durumunu tamamen diğer bir pencereye kopyalamak için kullanılır. Değiştirge olarak kaynak ve hedef pencerelerini alır, tanımlanan dikdörtgene göre dikdörtgen bölgeyi kaynaktan hedef pencereye doğru kopyalar. Son değiştirgesi hedef pencere üzerine yazılma mı yoksa diğer durum bilgileriyle beraber bulunma mı olduğunu belirtir. Eğer değiştirge mantıksal olarak doğru ise, kopyalama işlemi zarar verici değildir.
</para>
</sect2>
</sect1>

<sect1 xml:id="ncurses-howto-misc">
<title>Çeşitli Özellikler</title><para>
Artık, ıslık ve zil sesleri çıkartan güzel bir program yazacak yeterli sayıda özellik biliyorsunuz. Değişik durumlarda kullanışlı olabilecek çeşitli bazı işlevler vardır. Bunların bazılarını ele alalım.
</para>

<sect2 userlevel="chunkthis" xml:id="ncurses-howto-cursset">
<title><function>curs_set()</function></title>
<para>
Bu işlev imleci görünmez yapmak için kullanılır. Bu işleve gönderilebilecek değiştirgeler şunlardır:
</para>
<literallayout indent="0">
    0 : görünmez
    1 : normal
    2 : çok görünür
</literallayout>
</sect2>

<sect2 userlevel="chunkthis" xml:id="ncurses-howto-templeave">
<title>Curses Kipini Geçici Olarak Terk Etmek</title><para>
Bazen ilk işlemleri gerçekleştirdiğiniz kipe (satır tamponlu kip) geçici bir süre için geri dönmek isteyebilirsiniz. Böylesi bir durumda ilk olarak tty kiplerini <command>def_prog_mode()</command> çağrısı ile kaydetmeniz ve curses kipini sonlandırmak için <command>endwin()</command> işlevini kullanmanız gerekmektedir. Bu sizi asıl tty kipine gönderecektir. İşiniz bitip tty kipine dönmek için <command>reset_prog_mode()</command> işlevini çağırın. Bu işlev tty kipini <command>def_prog_mode()</command> ile kaydedilmiş kipe dönüştürür. Daha sonra <function>refresh()</function>'i kullanın ve işte yine curses kipindesiniz. Aşağıda yapılan işlemlerin sırasını gösteren bir örnek bulunmaktadır.
</para>
<example xml:id="ncurses-howto-btele">
<title>Geçici Olarak Curses Kipini Terk Etmek</title><para>
<programlisting>
#include &lt;ncurses.h>

int main()
{
  initscr();                        /* Curses kipi başlangıcı */
  printw("Merhaba Dünya !!!\n");    /* Ekrana Merhaba Dünya yaz */
  refresh();                        /* Gerçek ekranda bunu yaz */
  def_prog_mode();                  /* tty kiplerini kaydet */
  endwin();                         /* Curses kipini geçici olarak sonlandır */
  system("/bin/sh");                /* Kabukta ne yapmak istiyorsanız yapın */
  reset_prog_mode();                /* Bir önceki tty kipine dönüş */
  refresh();                        /* Ekran içeriğini geri yükleyelim */
  printw("Tekrar Merhaba\n");       /* Curses'a döndük mü bakalım */
  refresh();                        /* Ekranı tampondan tazeleyelim */
  endwin();                         /* Curses kipinin sonu */

  return 0;
}
</programlisting></para>
</example>
</sect2>

<sect2 userlevel="chunkthis" xml:id="ncurses-howto-acsvars">
<title><literal>ACS_</literal> değişkenleri</title><para>
Eğer DOS'ta programlama yaptıysanız genişletilmiş karakter kümesi içerisindeki şu güzel görünümlü olanları biliyorsunuzdur. Sadece bazı uçbirimlerde gösterilirler. NCURSES'ün <command>box()</command> gibi işlevleri bu karakterleri kullanır. Tüm bu karakterler seçimlik karakter kümesi anlamına gelen ACS (alternative character set) ile başlar. Yukarıdaki programların bazılarında bu karakterleri kullandığımı farketmiş olabilirsiniz. Aşağıda tüm karakterleri gösteren bir örnek vardır.
</para>
<example xml:id="ncurses-howto-bacsvars">
<title><literal>ACS_</literal> değişkenleri örneği</title><para>
<programlisting>
#include &lt;ncurses.h>

int main()
{
  initscr();

  printw("Sol üst köşe         "); addch(ACS_ULCORNER); printw("\n");
  printw("Sol alt köşe         "); addch(ACS_LLCORNER); printw("\n");
  printw("Sağ alt köşe         "); addch(ACS_LRCORNER); printw("\n");
  printw("Sağı dönük T         "); addch(ACS_LTEE); printw("\n");
  printw("Sola dönük T         "); addch(ACS_RTEE); printw("\n");
  printw("Yukarı dönük T       "); addch(ACS_BTEE); printw("\n");
  printw("Aşağı dönük T        "); addch(ACS_TTEE); printw("\n");
  printw("Yata çizgi           "); addch(ACS_HLINE); printw("\n");
  printw("Dikey çizgi          "); addch(ACS_VLINE); printw("\n");
  printw("Büyük artı           "); addch(ACS_PLUS); printw("\n");
  printw("Tarama satırı 1      "); addch(ACS_S1); printw("\n");
  printw("Tarama satırı 3      "); addch(ACS_S3); printw("\n");
  printw("Tarama satırı 7      "); addch(ACS_S7); printw("\n");
  printw("Tarama satırı 9      "); addch(ACS_S9); printw("\n");
  printw("Eşkenar görtgen      "); addch(ACS_DIAMOND); printw("\n");
  printw("Noktalı onay kutusu  "); addch(ACS_CKBOARD); printw("\n");
  printw("Derece sembolü       "); addch(ACS_DEGREE); printw("\n");
  printw("Artı/Eksi işareti    "); addch(ACS_PLMINUS); printw("\n");
  printw("Madde imi            "); addch(ACS_BULLET); printw("\n");
  printw("Solu gösteren ok     "); addch(ACS_LARROW); printw("\n");
  printw("Sağı gösteren ok     "); addch(ACS_RARROW); printw("\n");
  printw("Aşağı gösteren ok    "); addch(ACS_DARROW); printw("\n");
  printw("Yukarı gösteren ok   "); addch(ACS_UARROW); printw("\n");
  printw("Diyez işareti        "); addch(ACS_BOARD); printw("\n");
  printw("İçi boş kare         "); addch(ACS_LANTERN); printw("\n");
  printw("İçi dolu kare blok   "); addch(ACS_BLOCK); printw("\n");
  printw("Küçük/Eşit işareti   "); addch(ACS_LEQUAL); printw("\n");
  printw("Büyük/Eşit işareti   "); addch(ACS_GEQUAL); printw("\n");
  printw("Pi                   "); addch(ACS_PI); printw("\n");
  printw("Eşit değil           "); addch(ACS_NEQUAL); printw("\n");
  printw("UK ound sembolü      "); addch(ACS_STERLING); printw("\n");

  refresh();
  getch();
  endwin();

  return 0;
}
</programlisting></para>
</example>
</sect2>
</sect1>

<sect1 xml:id="ncurses-howto-otherlib">
<title>Diğer Kütüphaneler</title><para>
Curses kütüphanesinden başka daha fazla özellik ve işlevsellik sağlayan birkaç kütüphane daha vardır. Takip eden kısımlarda curses ile dağıtılan üç standart kütüphane incelenecektir.
</para>
</sect1>

<sect1 xml:id="ncurses-howto-panels">
<title>Panel Kütüphanesi</title><para>
Artık curses kullanımında yetenekli hale geldiniz ve daha büyük bir şeyler yapmak istiyorsunuzdur. Üst üste çalışan ve profosyonel bir pencere görünümü sağlayan bir sürü pencere oluşturdunuz. Ne yazık ki, bir süre sonra bunları idare etmek oldukça zor olacaktır. Çoklu tazeleme ve güncellemeler sizi bir kabusa itecektir. Üst üste çalışan pencereler, pencereleri doğru sırada tazelemeyi unuttuğunuzda büyük lekeler bırakır.
</para><para>
Ümizsitliğe kapılmayın. Panel kütüphanesinde sunulmuş zekice bir çözüm bulunmaktadır. ncurses geliştiricilerinin dünyasında şöyle denir:
</para><para><blockquote><para>
Eğer arayüz tasarımınızda pencere yığıtınız çok derinlere iniyorsa çalışma zamanında bu pencereleri yığıttan çekmek için durmadan düzenlemeler yapmak yorucu ve üstesinden gelinmez bir hal alabilir. Böylece karşımıza panel kütüphanesi çıkar.
</para></blockquote></para><para>
Eğer pekçok üst üste çalışan pencereniz varsa kullanmanız gereken panel kütüphanesidir. Seri şekilde ve doğru sırada (yukardan aşağı) <function>wnoutrefresh()</function> ve <function>doupdate()</function> bunun üstesinden gelir. Kütüphane, pencerelerin sıraları, üst üstelikleri hakkındaki bilgileri ve ekranı düzgün şekilde güncelemekle ilgili işleri yönetmektedir. O zaman ne duruyoruz? Panellere yakından bakalım.
</para>

<sect2 userlevel="chunkthis" xml:id="ncurses-howto-panelbasics">
<title>Temel Bilgiler</title><para>
Panel nesneleri, içerisinde tüm diğer panel nesnelerini barındıran bir destenin parçası olarak işleme örtük olarak alınan birer penceredir. Deste en üstteki panelin görünür olduğu diğerlerinin konumlarına göre belirli veya belirsiz olabileceği bir yığın gibi davranış gösterir. Dolayısiyle temel fikir üst üste çalışan panel yığını oluşturmak ve panel kütüphanesini kullanarak bunları düzgün göstermektir. <function>refresh()</function>'e benzeyen ve çağrıldığında panellerin düzgün gözükmesini sağlayan bir işlev vardır. Panelleri gösteren, gizleyen, hareket ettiren, boyutlarını değiştiren, v.b. işlevler vardır. Üst üste çalışma sorunu panel kütüphanesi tarafından tüm bu işlev çağrımları sırasında halledilir.
</para><para>
Bir panel programının genel akışı şuna benzer:
</para><para>
<orderedlist>
<listitem><para>
Panellere eklenecek pencereler oluşturulur (<function>newwin()</function> ile)
</para></listitem><listitem><para>
Görünme sırasına göre paneller oluşturulur. Görünmesi istenen sıraya göre bir yığıt oluşturulur. Yeni panel oluşturmak için <function>new_panel()</function> işlevi kullanılır.
</para></listitem><listitem><para>
Panelleri ekrana doğru görüntülenme sırasıyla yazmak için <function>update_panels()</function> işlevi kullanılır. Görüntülenmelerini sağlamak için ise <function>doupdate()</function> işlevi kullanılır.
</para></listitem><listitem><para>
Panelleri düzenlemek için <function>show_panel(), hide_panel(), move_panel()</function> v.b. işlevler kullanılır. <function>panel_hidden()</function> ve  <function>panel_window()</function> gibi yardımcı işlevlerden yararlanılır.  Bir panelin kullanıcı göstericisini belirtmek ve bilgi almak için <function>set_panel_userptr()</function> ve <function>panel_userptr()</function> işlevleri kullanılır.
</para></listitem><listitem><para>
Panel kullanımı bittikten sonra <function>del_panel()</function> ile panel silinir.
</para></listitem>
</orderedlist>
</para><para>
Bazı programlar ile konuyu açıklığa kavuşturalım. Aşağıda 3 tane üst üste çalışan panel oluşturup bunları ekranda gösteren bir program bulunmaktadır.
</para>
</sect2>

<sect2 userlevel="chunkthis" xml:id="ncurses-howto-compilepanels">
<title>Panel Kütüphanesi ile derleme</title><para>
Panel kütüphanesi işlevlerini kullanabilmek için <filename>panel.h</filename> başlık dosyası programa dahil edilmeli ve programı panel kütüphanesi ile ilintili derlemek için <option>-lpanel -lncurses</option> seçenekleri kullanılmalıdır.
</para><para>
<programlisting>
#include &lt;panel.h&gt;.
.
.

derleme ve ilintileme: <command>gcc</command> <emphasis>program dosyası</emphasis> <command>-lpanel -lncurses</command>
</programlisting>
</para>
<example xml:id="ncurses-howto-ppasi">
<title>Panellerin temelleri</title><para>
<programlisting>
#include &lt;panel.h>

int main()
{ WINDOW *my_wins[3];
  PANEL  *my_panels[3];
  int lines = 10, cols = 40, y = 2, x = 4, i;

  initscr();
  cbreak();
  noecho();

  /* Paneller için pencereler oluşturun */
  my_wins[0] = newwin(lines, cols, y, x);
  my_wins[1] = newwin(lines, cols, y + 1, x + 5);
  my_wins[2] = newwin(lines, cols, y + 2, x + 10);

  /*
   * Pencereler etrafında çerçeve oluşturun
   * böylece Panel etkilerini görebilirsiniz
   */
  for(i = 0; i &lt; 3; ++i)
          box(my_wins[i], 0, 0);

  /* Her pencereyi bir panele bağlayın. Sıralama alttan üste doğru */
  my_panels[0] = new_panel(my_wins[0]);   /* 0'a  it, sıra: stdscr-0 */
  my_panels[1] = new_panel(my_wins[1]);   /* 1'e  it, sıra: stdscr-0-1 */
  my_panels[2] = new_panel(my_wins[2]);   /* 2'ye it, sıra: stdscr-0-1-2 */

  /* Yığın sıralamasını güncelle. 2. panel en üstte olacak */
  update_panels();

  /* Ekranda göster */
  doupdate();

  getch();
  endwin();
}
</programlisting></para>
</example>
<para>
Gördüğünüz gibi yukarıdaki program açıklandığı gibi basit bir akış takip etmektedir. Pencereler <function>newwin()</function> ile oluşturulup <function>new_panel()</function> ile panellere bağlanmıştır. Bir paneli diğeri ardına bağladığımızda, panel yığını güncellenmektedir. Bunları ekrana yazdırmak için <function>update_panels()</function> ve göstermek için <function>doupdate()</function> işlevleri çağrılmıştır.
</para>
</sect2>

<sect2 userlevel="chunkthis" id ="ncurses-howto-panelbrowsing">
<title>Panel Penceresinde Gezinmek</title><para>
Biraz karmaşık bir örnek aşağıda verilmiştir. Bu program sekme tuşu kullanılarak gezilebilen 3 pencere oluşturmaktadır. Koda bir göz atın.
</para>
<example xml:id="ncurses-howto-ppabr">
<title>Panel Penceresi Gezinti Örneği</title><para>
<programlisting>
#include &lt;panel.h>

#define NLINES 10
#define NCOLS 40

void init_wins(WINDOW **wins, int n);
void win_show(WINDOW *win, char *label, int label_color);
void print_in_middle(WINDOW *win, int starty, int startx, int width,
    char *string, chtype color);

int main()
{ WINDOW *my_wins[3];
  PANEL  *my_panels[3];
  PANEL  *top;
  int ch;

  /* Curses kipini ilklendir */
  initscr();
  start_color();
  cbreak();
  noecho();
  keypad(stdscr, TRUE);

  /* Tüm renkleri ilklendir */
  init_pair(1, COLOR_RED, COLOR_BLACK);
  init_pair(2, COLOR_GREEN, COLOR_BLACK);
  init_pair(3, COLOR_BLUE, COLOR_BLACK);
  init_pair(4, COLOR_CYAN, COLOR_BLACK);

  init_wins(my_wins, 3);

  /* Her pencereyi bir panele bağla */    /* Sıralama aşağıdan yukarıya */
  my_panels[0] = new_panel(my_wins[0]);   /* 0'a  it, sıra: stdscr-0 */
  my_panels[1] = new_panel(my_wins[1]);   /* 1'e  it, sıra: stdscr-0-1 */
  my_panels[2] = new_panel(my_wins[2]);   /* 2'ye it, sıra: stdscr-0-1-2 */

  /* Kullanıcı işaretçilerini bir sonraki panele ayarla */
  set_panel_userptr(my_panels[0], my_panels[1]);
  set_panel_userptr(my_panels[1], my_panels[2]);
  set_panel_userptr(my_panels[2], my_panels[0]);

  /* Yığını güncelle. 2. panel en üstte olacak */
  update_panels();

  /* Ekranda göster */
  attron(COLOR_PAIR(4));
  mvprintw(LINES - 2, 0,
    "Pencerelerde gezinmek için tab kullanın (Çıkmak için F1)");
  attroff(COLOR_PAIR(4));
  doupdate();

  top = my_panels[2];
  while((ch = getch()) != KEY_F(1))
  { switch(ch)
    { case 9:
        top = (PANEL *)panel_userptr(top);
        top_panel(top);
        break;
    }
    update_panels();
    doupdate();
  }
  endwin();
  return 0;
}

/* Tüm pencereleri yazdır */
void init_wins(WINDOW **wins, int n)
{ int x, y, i;
  char label[80];

  y = 2;
  x = 10;
  for(i = 0; i &lt; n; ++i)
  { wins[i] = newwin(NLINES, NCOLS, y, x);
    sprintf(label, "Pencere Numaası %d", i + 1);
    win_show(wins[i], label, i + 1);
    y += 3;
    x += 7;
  }
}

/* Pencereyi bir çerçeve ve isimle göster */
void win_show(WINDOW *win, char *label, int label_color)
{ int startx, starty, height, width;

  getbegyx(win, starty, startx);
  getmaxyx(win, height, width);

  box(win, 0, 0);
  mvwaddch(win, 2, 0, ACS_LTEE);
  mvwhline(win, 2, 1, ACS_HLINE, width - 2);
  mvwaddch(win, 2, width - 1, ACS_RTEE);

  print_in_middle(win, 1, 0, width, label, COLOR_PAIR(label_color));
}

void print_in_middle (WINDOW *win, int starty, int startx, int width,
    char *string, chtype color)
{ int length, x, y;
  float temp;

  if(win == NULL)
    win = stdscr;
  getyx(win, y, x);
  if(startx != 0)
    x = startx;
  if(starty != 0)
    y = starty;
  if(width == 0)
    width = 80;

  length = strlen(string);
  temp = (width - length)/ 2;
  x = startx + (int)temp;
  wattron(win, color);
  mvwprintw(win, y, x, "%s", string);
  wattroff(win, color);
  refresh();
}
</programlisting></para>
</example>
</sect2>

<sect2 userlevel="chunkthis" xml:id="ncurses-howto-userptrusing">
<title>Kullanıcı İşaretçilerini Kullanmak</title><para>
Yukarıdaki örnekte sıralamadaki bir sonraki pencereyi bulmak için kullanıcı işaretçilerini kullandım. Bir kullanıcı göstericisi tanımlayarak herhangi bir bilgiyi panele bağlayabilir ve saklamak istediğimiz herhangi bir bilgiye işaret edebiliriz. Bu örnekte bir sonraki panel için kullandım. Kullanıcı işaretçileri <command>set_panel_userptr()</command> ile tanımlanır. <command>panel_userptr()</command> ile değiştirge olarak verilen panele kullanıcı göstericisi döndürülür. Bir sonraki paneli bulduktan sonra işlem <function>top_panel()</function> işlevine geçmektedir. Bu işlev verilen paneli panel yığını içerisinde en tepeye taşır.
</para>
</sect2>

<sect2 userlevel="chunkthis" xml:id="ncurses-howto-panelmoveresize">
<title>Panelleri Hareket Ettirmek ve Boyutlandırmak</title><para>
<command>move_panel()</command> işlevi paneli istenen konuma taşımak için kullanılabilir. Panelin yığın içerisindeki konumunu değiştirmez. Panele bağlı pencereler üzerinde <function>mvwin()</function> yerine <function>move_panel()</function> kullandığınızdan emin olun.
</para><para>
Bir paneli yeniden boyutlandırmak biraz karmaşıktır. Doğrudan bu işi yapacak bir işlev yoktur. Bir paneli yeniden boyutlandırmanın yolu istenen boyutlarda bir pencere oluşturmak ve <function>replace_panel()</function> ile boyutu değiştirilmek istenen pencereyi değiştirmektir. Eski pencereyi silmeyi unutmayın. Bir panele bağlı pencere <function>panel_window()</function> ile bulunabilir.
</para><para>
Aşağıdaki program bahsedilenleri basit bir şekilde göstermektedir. Her zamanki gibi pencereler üzerinde sekme tuşu ile hareket edebilirsiniz. Etkin paneli yeniden boyutlandırmak için 'r''ye taşımak için 'm''ye basın. Daha sonra ok tuşları ile taşıma ve boyutlandırmanızı yapın, bitince enter ile sonlandırın. Bu örnek kullanıcı bilgilerini kullanarak işlemler yapmaktadır.
</para>
<example xml:id="ncurses-howto-ppare">
<title>Panel Taşıma ve Yeniden Boyutlandırma Örneği</title><para>
<programlisting>
#include &lt;panel.h>

typedef struct _PANEL_DATA {
  int x, y, w, h;
  char label[80];
  int label_color;
  PANEL *next;
}PANEL_DATA;

#define NLINES 10
#define NCOLS 40

void init_wins(WINDOW **wins, int n);
void win_show(WINDOW *win, char *label, int label_color);
void print_in_middle(WINDOW *win, int starty, int startx, int width,
     char *string, chtype color);
void set_user_ptrs(PANEL **panels, int n);

int main()
{ WINDOW *my_wins[3];
  PANEL  *my_panels[3];
  PANEL_DATA  *top;
  PANEL *stack_top;
  WINDOW *temp_win, *old_win;
  int ch;
  int newx, newy, neww, newh;
  int size = FALSE, move = FALSE;

  /* Curses kipi ilklendirme */
  initscr();
  start_color();
  cbreak();
  noecho();
  keypad(stdscr, TRUE);

  /* Tüm renkleri ilklendir */
  init_pair(1, COLOR_RED, COLOR_BLACK);
  init_pair(2, COLOR_GREEN, COLOR_BLACK);
  init_pair(3, COLOR_BLUE, COLOR_BLACK);
  init_pair(4, COLOR_CYAN, COLOR_BLACK);

  init_wins(my_wins, 3);

  /* Her panele bir oencere ata */        /* Sıra aşağıdan yukarıya */
  my_panels[0] = new_panel(my_wins[0]);   /* 0'a  it, sıra: stdscr-0 */
  my_panels[1] = new_panel(my_wins[1]);   /* 1'e  it, sıra: stdscr-0-1 */
  my_panels[2] = new_panel(my_wins[2]);   /* 2'ye it, sıra: stdscr-0-1-2 */

  set_user_ptrs(my_panels, 3);
  /* Yığın sıralamasını güncelle. 2. panel en tepede olacak */
  update_panels();

  /* Ekrana göster */
  attron(COLOR_PAIR(4));
  mvprintw(LINES - 3, 0,
    "Taşımak için 'm' , yeniden boyutlandırma için 'r' kullanın");
  mvprintw(LINES - 2, 0,
    "Pencereler arasında gezinmek için tab kullanın (Çıkmak için F1)");
  attroff(COLOR_PAIR(4));
  doupdate();

  stack_top = my_panels[2];
  top = (PANEL_DATA *)panel_userptr(stack_top);
  newx = top->x;
  newy = top->y;
  neww = top->w;
  newh = top->h;
  while((ch = getch()) != KEY_F(1))
  { switch(ch)
    { case 9:         /* Tab */
        top = (PANEL_DATA *)panel_userptr(stack_top);
        top_panel(top->next);
        stack_top = top->next;
        top = (PANEL_DATA *)panel_userptr(stack_top);
        newx = top->x;
        newy = top->y;
        neww = top->w;
        newh = top->h;
        break;
      case 'r':       /* Yeniden boyutlandır */
        size = TRUE;
        attron(COLOR_PAIR(4));
        mvprintw(LINES - 4, 0,
            "Yeniden boyutlandırmaya giriş: "
            "Ok tuşları ile boyutlandırın ve "
            "bitirmek için &lt;ENTER> kullanın");
        refresh();
        attroff(COLOR_PAIR(4));
        break;
      case 'm':       /* Move */
        attron(COLOR_PAIR(4));
        mvprintw(LINES - 4, 0,
          "Taşıma kipine girildi: "
          "Taşımak için ok tuşlarını ve "
          "bitirmek için &lt;ENTER> kullanın");
        refresh();
        attroff(COLOR_PAIR(4));
        move = TRUE;
        break;
      case KEY_LEFT:
        if(size == TRUE)
        { --newx;
          ++neww;
        }
        if(move == TRUE)
          --newx;
        break;
      case KEY_RIGHT:
        if(size == TRUE)
        { ++newx;
          --neww;
        }
        if(move == TRUE)
          ++newx;
        break;
      case KEY_UP:
        if(size == TRUE)
        { --newy;
          ++newh;
        }
        if(move == TRUE)
          --newy;
        break;
      case KEY_DOWN:
        if(size == TRUE)
        { ++newy;
          --newh;
        }
        if(move == TRUE)
          ++newy;
        break;
      case 10:        /* Enter */
        move(LINES - 4, 0);
        clrtoeol();
        refresh();
        if(size == TRUE)
        { old_win = panel_window(stack_top);
          temp_win = newwin(newh, neww, newy, newx);
          replace_panel(stack_top, temp_win);
          win_show(temp_win, top->label, top->label_color);
          delwin(old_win);
          size = FALSE;
        }
        if(move == TRUE)
        { move_panel(stack_top, newy, newx);
          move = FALSE;
        }
        break;
    }
    attron(COLOR_PAIR(4));
    mvprintw(LINES - 3, 0,
      "Taşımak için 'm', yeniden boyutlandırmak için 'r' kullanın");
    mvprintw(LINES - 2, 0,
      "Pencereler arasında gezinti için tab kullanın "
        "(Çıkmak için F1)");
    attroff(COLOR_PAIR(4));
    refresh();
    update_panels();
    doupdate();
  }
  endwin();
  return 0;
}

/* Tüm pencereleri yazdır */
void init_wins(WINDOW **wins, int n)
{ int x, y, i;
  char label[80];

  y = 2;
  x = 10;
  for(i = 0; i &lt; n; ++i)
  { wins[i] = newwin(NLINES, NCOLS, y, x);
    sprintf(label, "Pencere Numarası %d", i + 1);
    win_show(wins[i], label, i + 1);
    y += 3;
    x += 7;
  }
}

/* Herbir panel için PANEL_DATA veri yapısını tanımla */
void set_user_ptrs(PANEL **panels, int n)
{ PANEL_DATA *ptrs;
  WINDOW *win;
  int x, y, w, h, i;
  char temp[80];

  ptrs = (PANEL_DATA *)calloc(n, sizeof(PANEL_DATA));

  for(i = 0;i &lt; n; ++i)
  { win = panel_window(panels[i]);
    getbegyx(win, y, x);
    getmaxyx(win, h, w);
    ptrs[i].x = x;
    ptrs[i].y = y;
    ptrs[i].w = w;
    ptrs[i].h = h;
    sprintf(temp, "Pencere Numarası %d", i + 1);
    strcpy(ptrs[i].label, temp);
    ptrs[i].label_color = i + 1;
    if(i + 1 == n)
      ptrs[i].next = panels[0];
    else
      ptrs[i].next = panels[i + 1];
    set_panel_userptr(panels[i], &amp;ptrs[i]);
  }
}

/* Pencereyi bir çerçeve ve bir isimle göster */
void win_show(WINDOW *win, char *label, int label_color)
{ int startx, starty, height, width;

  getbegyx(win, starty, startx);
  getmaxyx(win, height, width);

  box(win, 0, 0);
  mvwaddch(win, 2, 0, ACS_LTEE);
  mvwhline(win, 2, 1, ACS_HLINE, width - 2);
  mvwaddch(win, 2, width - 1, ACS_RTEE);

  print_in_middle(win, 1, 0, width, label, COLOR_PAIR(label_color));
}

void print_in_middle(WINDOW *win, int starty, int startx, int width,
    char *string, chtype color)
{ int length, x, y;
  float temp;

  if(win == NULL)
    win = stdscr;
  getyx(win, y, x);
  if(startx != 0)
    x = startx;
  if(starty != 0)
    y = starty;
  if(width == 0)
    width = 80;

  length = strlen(string);
  temp = (width - length)/ 2;
  x = startx + (int)temp;
  wattron(win, color);
  mvwprintw(win, y, x, "%s", string);
  wattroff(win, color);
  refresh();
}
</programlisting></para>
</example><para>
Ana programdaki <statement>while</statement> döngüsüne dikkatinizi verin. Bir kere basılan tuşun türünü buldu mu uygun davranışı göstermektedir. Eğer 'r' basıldıysa yeniden boyutlandırma başlamaktadır. Bundan sonra kullanıcı ok tuşlarına bastıkça yeni boyutları güncellenmektedir. Kullanıcı &lt;ENTER&gt;'a bastığı anda o anki seçim sona erer ve panel açıklanan mantıkla yeniden boyutlandırılır. Yeniden boyutlandırma kipinde program pencerenin nasıl yeniden boyutlandırıldığını göstermez. Okuyucuya yeniden boyutlandırma sırasında noktalı bir çerçeve ile yeni boyutu gösterme işi bir alıştırma olarak bırakılmıştır.
</para><para>
Kullanıcı 'm''e bastığında taşıma kipi başlar. Bu, yeniden boyutlandırmaktan daha kolaydır. Ok tuşlarına bastıkça yeni konum güncellenir ve &lt;ENTER&gt; ile <function>move_panel()</function> çağrılarak panel taşıma işlemi sonlandırılır.
</para><para>
Bu programda <literal>PANEL_DATA</literal> olarak ifade edilen kullanıcı bilgisi önemli bir rol oynamaktadır. Açıklama satırlarında da yazdığı gibi <literal>PANEL_DATA</literal> panel boyutu, ismi, isim rengi ve sıralamadaki sonraki panele işaretçi bilgilerini tutmaktadır.
</para>
</sect2>

<sect2 userlevel="chunkthis" xml:id="ncurses-howto-panelshowhide">
<title>Panelleri Gizlemek ve Göstermek</title><para>
Bir panel <function>hide_panel()</function> işlevi kullanılarak gizlenebilir. Bu işlev sadece onu panel yığınından kaldırır, böylece <function>update_panels()</function> ve <function>doupdate()</function> işlevleri kullanıldığında ekrandan saklanmış olur. Gizlenmiş panel ile ilintili PANEL yapısını bozmaz. Tekrar gösterilmek istenirse <function>show_panel()</function> işlevi kullanılmalıdır.
</para><para>
Aşağıdaki program panellerin gizlenmesini göstermektedir. 'a' veya 'b' veya 'c' ye sırasıyla birinci, ikinci ve üçüncü pencereleri gizlemek veya göstermek için basın. Pencerenin gizlenip gizlenmediği bilgisini saklayan küçük bir hide isimli değişken ile kullanıcı verisini kullanmaktadır. Bir nedenden ötürü panelin gizlenip gizlenmediğini söyleyen <command>panel_hidden()</command> işlevi çalışmamaktadır. Michael Andres tarafından gönderilen bir hata raposu <link xlink:href="http://www.geocrawler.com/archives/3/344/1999/9/0/2643549/">buradadır</link>.
</para>
<example xml:id="ncurses-howto-ppahi">
<title> Panel Gizleme ve Gösterme Örneği</title><para>
<programlisting>
#include &lt;panel.h>

typedef struct _PANEL_DATA {
  int hide;       /* eğer panel gizlenmişse TRUE */
}PANEL_DATA;

#define NLINES 10
#define NCOLS 40

void init_wins(WINDOW **wins, int n);
void win_show(WINDOW *win, char *label, int label_color);
void print_in_middle(WINDOW *win, int starty, int startx, int width,
     char *string, chtype color);

int main()
{ WINDOW *my_wins[3];
  PANEL  *my_panels[3];
  PANEL_DATA panel_datas[3];
  PANEL_DATA *temp;
  int ch;

  /* Curses kipi ilklendir */
  initscr();
  start_color();
  cbreak();
  noecho();
  keypad(stdscr, TRUE);

  /* Tüm renkleri ilklendir */
  init_pair(1, COLOR_RED, COLOR_BLACK);
  init_pair(2, COLOR_GREEN, COLOR_BLACK);
  init_pair(3, COLOR_BLUE, COLOR_BLACK);
  init_pair(4, COLOR_CYAN, COLOR_BLACK);

  init_wins(my_wins, 3);

  /* Her panele bir pencere bağla */      /* Sıralama aşağıdan yukarıya */
  my_panels[0] = new_panel(my_wins[0]);   /* 0'a  it, sıra: stdscr-0 */
  my_panels[1] = new_panel(my_wins[1]);   /* 1'e  it, sıra: stdscr-0-1 */
  my_panels[2] = new_panel(my_wins[2]);   /* 2'ye it, sıra: stdscr-0-1-2 */

  /* Hiçbir şeyin gizlenmediğiniz söyleyerek panel bilgisini ilklendir */
  panel_datas[0].hide = FALSE;
  panel_datas[1].hide = FALSE;
  panel_datas[2].hide = FALSE;

  set_panel_userptr(my_panels[0], &amp;panel_datas[0]);
  set_panel_userptr(my_panels[1], &amp;panel_datas[1]);
  set_panel_userptr(my_panels[2], &amp;panel_datas[2]);

  /* Yığın sıralamasını güncelle. 2. panel en üstte olacak */
  update_panels();

  /* Ekranda göster */
  attron(COLOR_PAIR(4));
  mvprintw(LINES - 3, 0, "Pencereleri şu tuşlarla gizleyin veya gösterin"
      " 'a'(ilk pencere)  'b'(ikinci pencere)  'c'(üçüncü pencere)");
  mvprintw(LINES - 2, 0, "Çıkmak için F1");

  attroff(COLOR_PAIR(4));
  doupdate();

  while((ch = getch()) != KEY_F(1))
  { switch(ch)
    { case 'a':
        temp = (PANEL_DATA *)panel_userptr(my_panels[0]);
        if(temp->hide == FALSE)
        { hide_panel(my_panels[0]);
          temp->hide = TRUE;
        }
        else
        { show_panel(my_panels[0]);
          temp->hide = FALSE;
        }
        break;
      case 'b':
        temp = (PANEL_DATA *)panel_userptr(my_panels[1]);
        if(temp->hide == FALSE)
        { hide_panel(my_panels[1]);
          temp->hide = TRUE;
        }
        else
        { show_panel(my_panels[1]);
          temp->hide = FALSE;
        }
        break;
      case 'c':
        temp = (PANEL_DATA *)panel_userptr(my_panels[2]);
        if(temp->hide == FALSE)
        { hide_panel(my_panels[2]);
          temp->hide = TRUE;
        }
        else
        { show_panel(my_panels[2]);
          temp->hide = FALSE;
        }
        break;
    }
    update_panels();
    doupdate();
  }
  endwin();
  return 0;
}

/* Tüm pencereleri ekrana yazdır */
void init_wins(WINDOW **wins, int n)
{ int x, y, i;
  char label[80];

  y = 2;
  x = 10;
  for(i = 0; i &lt; n; ++i)
  { wins[i] = newwin(NLINES, NCOLS, y, x);
    sprintf(label, "Window Number %d", i + 1);
    win_show(wins[i], label, i + 1);
    y += 3;
    x += 7;
  }
}

/* Penceleri bir çerçeve ve isimle göster */
void win_show(WINDOW *win, char *label, int label_color)
{ int startx, starty, height, width;

  getbegyx(win, starty, startx);
  getmaxyx(win, height, width);

  box(win, 0, 0);
  mvwaddch(win, 2, 0, ACS_LTEE);
  mvwhline(win, 2, 1, ACS_HLINE, width - 2);
  mvwaddch(win, 2, width - 1, ACS_RTEE);

  print_in_middle(win, 1, 0, width, label, COLOR_PAIR(label_color));
}

void print_in_middle(WINDOW *win, int starty, int startx, int width,
     char *string, chtype color)
{ int length, x, y;
  float temp;

  if(win == NULL)
          win = stdscr;
  getyx(win, y, x);
  if(startx != 0)
          x = startx;
  if(starty != 0)
          y = starty;
  if(width == 0)
          width = 80;

  length = strlen(string);
  temp = (width - length)/ 2;
  x = startx + (int)temp;
  wattron(win, color);
  mvwprintw(win, y, x, "%s", string);
  wattroff(win, color);
  refresh();
}
</programlisting></para>
</example>
</sect2>

<sect2 userlevel="chunkthis" xml:id="ncurses-howto-panelabove">
<title><function>panel_above()</function> ve <function>panel_below()</function></title><para>
<command>panel_above()</command> ve <command>panel_below()</command> işlevleri bir panelin altındaki ve üstündeki panelleri bulmak için kullanılabilir. Eğer bu işlevlere gönderilen değiştirgeler NULL ise, o zaman sırasıyla en alttaki ve en üstteki panellere bir işaretçi döndürürler.
</para>
</sect2>
</sect1>

<sect1 xml:id="ncurses-howto-menus"><title>Menü Kütüphanesi</title><para>
Menü kütüphanesi curses kütüphanesinin temel özelliklerine menüler oluşturmanızı sağlayan hoş özellik kazandırır. Menüler oluşturmak için bir takım işlevler sunar. Fakat güzel bir görünüm için renkler v.b. özelliklerle özelleştirilmeleri gerekir. Ayrıntılara bir bakalım.
</para><para>
Bir menü verilmiş olan öğe kümesinden kullanıcının bazı alt kümeleri seçmesini sağlayan ekran görüntüsüdür. Basitçe söylersek, içerisinden bir veya daha fazla öğe seçilebilen öğeler kümesidir. Bazı okuyucular birden fazla öğe seçilebilme özelliğinin olduğunun farkında olmayabilir. Menü kütüphanesi kullanıcının birden fazla seçim yapmasını sağlayabilen menüler yazma özelliği sunmaktadır. Bu, daha sonraki kısımda ele alınacaktır. Şimdi bazı ilkeleri öğrenmenin zamanı.
</para>

<sect2 userlevel="chunkthis" xml:id="ncurses-howto-menubasics">
<title>Temel Bilgiler</title><para>
Menüleri oluşturmak için önce öğeler oluşturulur ve sonra da ekranda menü oluşturulur. Bundan sonra, kullanıcının tüm işlemleri menü programının dolap beygiri olan <function>menu_driver()</function> işlevi tarafından zekice gerçeklenir.
</para><para>
Bir menü programının genel akışı şu şekildedir.
</para><para>
<orderedlist><listitem>
Curses kipi ilklendirilir
</listitem><listitem>
<function>new_item()</function> kullanarak öğeler oluşturulur. Öğeler için isim ve tanımlama belirtebilirsiniz.
</listitem><listitem>
<function>new_menu()</function> ile kendisine ilintilenecek öğeler belirtilerek menü oluşturulur.
</listitem><listitem>
Menü <function>menu_post()</function> ile ekrana yazdırılır ve ekran tazelenir.
</listitem><listitem>
Bir döngü ile kullanıcı isteklerini işlenir ve <function>menu_driver</function> ile menü üzerinde gerekli güncellemeler yapılır.
</listitem><listitem>
<function>menu_unpost()</function> ile ekrandan menü görüntüsü silinir.
</listitem><listitem>
<function>free_menu()</function> ile menü tarafından kullanılan bellek alanı serbest bırakılır.
</listitem><listitem>
Menü içerisindeki öğelere ayrılan bellek alanı <function>free_item()</function> ile serbest bırakılır.
</listitem><listitem>
Curses kipi sonlandırılır.
</listitem></orderedlist>
</para><para>
Şimdi, yukarı ve aşağı ok tuşları kullanarak seçilen öğeyi güncelleyen basit bir program görelim.
</para>
</sect2>

<sect2 userlevel="chunkthis" xml:id="ncurses-howto-compilemenus">
<title> Menü Kütüphanesi ile derleme</title><para>
Menü kütüphanesini kullanmak için <filename>menu.h</filename> başlık dosyası programa eklenmeli ve programı menü kütüphanesiyle ilintileyerek derlemek için de <option>-lmenu -lncurses</option> seçenekleri kullanılmalıdır.
</para><para>
<programlisting>
#include &lt;menu.h&gt;
.
.
.

derleme ve bağlama: <command>gcc </command><emphasis>program file</emphasis> <command>-lmenu -lncurses</command>
</programlisting>
</para>
<example xml:id="ncurses-howto-mmesi">
<title>Menülerin Temelleri</title><para>
<programlisting>
#include &lt;curses.h>
#include &lt;menu.h>

#define ARRAY_SIZE(a) (sizeof(a) / sizeof(a[0]))
#define CTRLD   4

char *choices[] = {
  "Choice 1",
  "Choice 2",
  "Choice 3",
  "Choice 4",
  "Exit",
};

int main()
{ ITEM **my_items;
  int c;
  MENU *my_menu;
  int n_choices, i;
  ITEM *cur_item;


  initscr();
  cbreak();
  noecho();
  keypad(stdscr, TRUE);

  n_choices = ARRAY_SIZE(choices);
  my_items = (ITEM **)calloc(n_choices + 1, sizeof(ITEM *));

  for(i = 0; i &lt; n_choices; ++i)
          my_items[i] = new_item(choices[i], choices[i]);
  my_items[n_choices] = (ITEM *)NULL;

  my_menu = new_menu((ITEM **)my_items);
  mvprintw(LINES - 2, 0, "F1 to Exit");
  post_menu(my_menu);
  refresh();

  while((c = getch()) != KEY_F(1))
  { switch(c)
    { case KEY_DOWN:
        menu_driver(my_menu, REQ_DOWN_ITEM);
        break;
      case KEY_UP:
        menu_driver(my_menu, REQ_UP_ITEM);
        break;
    }
  }

  free_item(my_items[0]);
  free_item(my_items[1]);
  free_menu(my_menu);
  endwin();
}
</programlisting></para>
</example>
<para>
Bu program menü kütüphanesi kullanılarak bir menü oluşturmanın temel adımlarını göstermektedir. Öncelikle <function>new_item()</function> ile öğeleri oluşturup onları daha sonra <function>new_menu()</function> ile menüye ekleyerek menüyü ilklendirdik. Menüyü ekrana yazdırıp ekranı tazeledikten sonra ana işlem döngüsü başlamaktadır. Kullanıcı girdisini alarak buna karşılık gelen işlemi gerçekleştirmektedir. <function>menu_driver()</function> işlevi menü sisteminin dolap beygiridir. Bu işlevin ikinci değiştirgesi menü ile ilgili ne yapılacağını söyler. Değiştirgeye göre, <function>menu_driver()</function> karşılık gelen görevi yapmaktadır. Değiştirge değeri, bir menü gezinti isteği, bir ascii karakter veya bir tuş ile ilişkili <literal>KEY_MOUSE</literal> özel anahtarı olabilir.
</para><para>
<function>menu_driver</function> aşağıdaki istekleri kabul eder.
</para>
<literallayout indent="0">
    REQ_LEFT_ITEM       Bir öğenin soluna hareket et
    REQ_RIGHT_ITEM      Bir öğenin sağına hareket et
    REQ_UP_ITEM         Bir öğenin üstüne hareket et
    REQ_DOWN_ITEM       Bir öğenin altına hareket et
    REQ_SCR_ULINE       Bir satır yukarı
    REQ_SCR_DLINE       Bir satır aşağı
    REQ_SCR_DPAGE       Bir sayfa aşağı
    REQ_SCR_UPAGE       Bir sayfa yukarı
    REQ_FIRST_ITEM      İlk öğeye hareket et
    REQ_LAST_ITEM       Son öğeye hareket et
    REQ_NEXT_ITEM       Sonraki öğeye hareket et
    REQ_PREV_ITEM       Önceki öğeye hareket et
    REQ_TOGGLE_ITEM     Bir öğeyi seç/seçimi kaldır
    REQ_CLEAR_PATTERN   Menü örüntü belleğini sil
    REQ_BACK_PATTERN    Örüntü belleğinden bir önceki karakteri sil
    REQ_NEXT_MATCH      Örüntü eşine uygun bir sonraki öğeye git
    REQ_PREV_MATCH      Örüntü eşine uygun bir önceki öğeye git
</literallayout>
<para>
Seçeneklerin sayısından dolayı bunalmış hissetmeyin. Herbirini tek tek göreceğiz. Bu listedeki ilgi alanımız <literal>REQ_UP_ITEM</literal> ve <literal>REQ_DOWN_ITEM</literal> öğeleridir. Bu iki seçenek <function>menu_driver</function> işlevine gönderildiklerinde, o anki öğeyi sırasıyla bir öğe yukarı veya aşağı günceller.
</para>
</sect2>

<sect2 userlevel="chunkthis" xml:id="ncurses-howto-menudriver">
<title><function>menu_driver</function>: Menü sisteminin dolap beygiri</title>
<para>
Yukarıdaki örnekte gördüğünüz gibi <function>menu_driver</function> menüyü güncellemede önemli bir rol oynamaktadır. Aldığı çeşitli seçenekleri ve neler yaptığını anlamak oldukça önemlidir. Yukarıda açıklandığı üzere <function>menu_driver()</function>)'ın ikinci değiştirgesi bir menü gezinti isteği, yazılabilir bir karakter veya <literal>KEY_MOUSE</literal> anahtarı olabilir. Değişik gezinti isteklerini parçalara ayırıp inceleyelim.
</para><para><glosslist><glossentry>
<glossterm><literal>REQ_LEFT_ITEM</literal> ve <literal>REQ_RIGHT_ITEM</literal></glossterm>
<glossdef><para>
Bir menü bir öğe için birden fazla sütun ile gösterilebilir. <command>menu_format()</command> işlevi kullanılarak bu gerçeklenebilir. Çok sütunlu bir menü gösterildiği zaman yukarıdaki istekler menü sürücüsünün o anki seçimin sağa ya da sola hareket etmesini sağlar.
</para></glossdef></glossentry><glossentry>
<glossterm><literal>REQ_UP_ITEM</literal> ve <literal>REQ_DOWN_ITEM</literal></glossterm>
<glossdef><para>
Yukarıdaki örnekte bu seçenekleri görmüştünüz. Bu istekler verildiğinde <function>menu_driver</function>'ın o anki seçimi yukarı veya aşağı kaydırmasını sağlar.
</para></glossdef></glossentry><glossentry>
<glossterm><literal>REQ_SCR_*</literal> seçenekleri</glossterm>
<glossdef><para>
<literal>REQ_SCR_ULINE, REQ_SCR_DLINE, REQ_SCR_DPAGE</literal> ve <literal>REQ_SCR_UPAGE</literal> seçenekleri kaydırma ile ilgili seçeneklerdir. Eğer menüdeki tüm öğeler alt pencere menüsünde gösterilemiyorsa o zaman menü kaydırılabilirdir. Bu istekler <function>menu_driver</function>'a verilerek sırasıyla kaydırmanın yukarı, aşağı, bir sayfa aşağı veya yukarı yapılması sağlanabilir.
</para></glossdef></glossentry><glossentry>
<glossterm><literal>REQ_FIRST_ITEM, REQ_LAST_ITEM, REQ_NEXT_ITEM</literal> ve <literal>REQ_PREV_ITEM</literal></glossterm>
<glossdef><para>
Bu istekler kendilerini açıklar niteliktedir (Sırayla ilk, son, sonraki, önceki).
</para></glossdef></glossentry><glossentry>
<glossterm><literal>>REQ_TOGGLE_ITEM</literal></glossterm>
<glossdef><para>
Bu istek verildiğinde o anki seçim değiştirilir. Bu seçenek çok değerli menülerde kullanılmalıdır. Bu isteği kullanabilmek için <literal>O_ONEVALUE</literal> değeri etkisizleştirilmelidir. Bu seçenek <function>set_menu_opts()</function> ile etkin veya etkisiz yapılabilir.
</para></glossdef></glossentry><glossentry>
<glossterm>Örüntü İstekleri</glossterm>
<glossdef><para>
Her menünün kullanıcın girdiği karakterlere en yakın olan ascii karakter karşılığını bulmak için bir örüntü önbelleği bulunmaktadır. <function>menu_driver</function>'a ascii karakterler verildiği zaman örüntü önbelleğine alınır. Aynı zamanda listedeki örüntüye en yakın olan eşleşmeyi de bulmaya çalışır ve o anki seçimi o öğeye hareket ettirir. <literal>REQ_CLEAR_PATTERN</literal> isteği örüntü belleğini siler. <literal>REQ_BACK_PATTERN</literal> isteği örüntü belleğindeki bir önceki karakteri siler. Örüntünün birden fazla öğe ile eşlemesi halinde eşleşen öğeler <literal>REQ_NEXT_MATCH</literal> ve <literal>REQ_PREV_MATCH</literal> ile seçim üzerinden sonraki veya öncekine hareket sağlanabilir.
</para></glossdef></glossentry><glossentry>
<glossterm>Fare İstekleri</glossterm>
<glossdef><para>
<literal>KEY_MOUSE</literal> istekleri durumunda farenin konumuna göre bir davranış sergilenir. Gösterilecek davranış kılavuz sayfalarında açıklanmıştır:
</para>
<literallayout indent="0">
    Eğer  ikinci  değiştirge  KEY_MOUSE  özel  karakteri  ise bununla
    ilişkili fare  olayı,  yukarıda  önceden  tanımlanmış  isteklere
    çevrilir.  Sadece  kullanıcı  penceresindeki  (örn. menü görüntü
    alanı  veya  dekor  penceresi)   tıklamalar   işlenir.   Menünün
    görüntülenebilir alanı üzerine tıklanırsa REQ_SCR_ULINE üretilir,
    eğer  çift  tıklarsanız  REQ_SCR_UPAGE  üretilir ve eğer üç kere
    tıklarsanız  REQ_FIRST_ITEM  üretilir.  Eğer  menü   görüntüleme
    alanı aşağısına tıklanırsa REQ_SCR_DLINE üretilir, eğer iki kere
    tıklanırsa  REQ_SCR_DPAGE  üretilir  ve  eğer üç kere tıklanırsa
    REQ_LAST_ITEM   üretilir.   Eğer   menü   görüntüleme   alanının
    içerisinde bir öğeye tıklanırsa  menü imleci bu öğeye konumlanır.
</literallayout>
</glossdef></glossentry></glosslist>
</para><para>
Yukarıdaki isteklerin her biri takip eden satırlarda değişik örneklerle gerekli oldukça açıklanacaktır.
</para>
</sect2>

<sect2 userlevel="chunkthis" xml:id="ncurses-howto-menuwindows">
<title> Menü Pencereleri</title><para>
Oluşturulan her bir menü bir pencere ve bir alt menü ile ilişiklendirilir. Menü penceresi menü ile ilişiklendirilmiş herhangi bir başlığı veya çerçeveyi gösterir. Menü alt penceresi seçimi mümkün olan menü öğelerini gösterir. Fakat basit örnekte herhangi bir pencere veya alt pencere belirtmedik. Bir pencere belirtilmediği zaman, temel pencere olarak <literal>stdscr</literal> alınır ve daha sonra menü sistemi öğelerin gösterimi için pencere büyüklüğünü ayarlar. Daha sonra öğeler hesaplanmış alt menüde gösterilir. Öyleyse şimdi bu pencerelerle oynayıp bir çerçeve ve başlıkla bir menü gösterelim.
</para>
<example xml:id="ncurses-howto-mmewi">
<title>Menü Pencereleri Kullanım örneği</title><para>
<programlisting>
#include &lt;menu.h>

#define ARRAY_SIZE(a) (sizeof(a) / sizeof(a[0]))
#define CTRLD   4

char *choices[] = {
  "Choice 1",
  "Choice 2",
  "Choice 3",
  "Choice 4",
  "Exit",
  (char *)NULL,
};
void print_in_middle(WINDOW *win, int starty, int startx, int width,
     char *string, chtype color);

int main()
{ ITEM **my_items;
  int c;
  MENU *my_menu;
  WINDOW *my_menu_win;
  int n_choices, i;

  /* Curses kipini ilklendir */
  initscr();
  start_color();
  cbreak();
  noecho();
  keypad(stdscr, TRUE);
  init_pair(1, COLOR_RED, COLOR_BLACK);

  /* Öğeleri oluştur */
  n_choices = ARRAY_SIZE(choices);
  my_items = (ITEM **)calloc(n_choices, sizeof(ITEM *));
  for(i = 0; i &lt; n_choices; ++i)
    my_items[i] = new_item(choices[i], choices[i]);

  /* Menüyü oluştur */
  my_menu = new_menu((ITEM **)my_items);

  /* Menü ile ilişiklendirilecek pencereyi oluştur */
  my_menu_win = newwin(10, 40, 4, 4);
  keypad(my_menu_win, TRUE);

  /* Ana pencereyi ve alt pencereleri ayarla */
  set_menu_win(my_menu, my_menu_win);
  set_menu_sub(my_menu, derwin(my_menu_win, 6, 38, 3, 1));

  /* Menü göstericisini " * " olarak ayarla*/
  set_menu_mark(my_menu, " * ");

  /* Ana pencere etrafında bir çerçeve çiz ve bir başlık yaz */
  box(my_menu_win, 0, 0);
  print_in_middle(my_menu_win, 1, 0, 40, "My Menu", COLOR_PAIR(1));
  mvwaddch(my_menu_win, 2, 0, ACS_LTEE);
  mvwhline(my_menu_win, 2, 1, ACS_HLINE, 38);
  mvwaddch(my_menu_win, 2, 39, ACS_RTEE);
  mvprintw(LINES - 2, 0, "F1 to exit");
  refresh();

  /* Menüyü ekrana yaz */
  post_menu(my_menu);
  wrefresh(my_menu_win);

  while((c = wgetch(my_menu_win)) != KEY_F(1))
  { switch(c)
    { case KEY_DOWN:
        menu_driver(my_menu, REQ_DOWN_ITEM);
        break;
      case KEY_UP:
        menu_driver(my_menu, REQ_UP_ITEM);
        break;
    }
    wrefresh(my_menu_win);
  }

  /* Menüyü ekrandan sil ve tahsis edilen belleği geri ver */
  unpost_menu(my_menu);
  free_menu(my_menu);
  for(i = 0; i &lt; n_choices; ++i)
    free_item(my_items[i]);
  endwin();
}

void print_in_middle(WINDOW *win, int starty, int startx, int width,
     char *string, chtype color)
{ int length, x, y;
  float temp;

  if(win == NULL)
    win = stdscr;
  getyx(win, y, x);
  if(startx != 0)
    x = startx;
  if(starty != 0)
    y = starty;
  if(width == 0)
    width = 80;

  length = strlen(string);
  temp = (width - length)/ 2;
  x = startx + (int)temp;
  wattron(win, color);
  mvwprintw(win, y, x, "%s", string);
  wattroff(win, color);
  refresh();
}
</programlisting></para>
</example>
<para>
Bu örnek bir başlık, çerçeve ve öğelerle başlığı ayıran hoş bir çizgiye sahip bir menü oluşturur. Gördüğünüz gibi, bir pencereyi bir menüye ilişiklendirmek için <function>set_menu_win()</function> işlevi kullanılmak zorundadır. Böylece alt pencereyi de bağlamış oluruz. Bu, öğeleri alt pencerede gösterir. Seçilen öğenin sol tarafında gözüken işaretleme dizgesini <function>set_menu_mark()</function> ile ayarlayabilirsiniz.
</para>
</sect2>

<sect2 userlevel="chunkthis" xml:id="ncurses-howto-scrollmenus">
<title>Kaydırılabilen Menüler</title><para>
Eğer pencere için oluşan alt pencere tüm öğeler için yeterince büyük değilse o zaman menü kaydırılabilir olur. O anki listedeki son öğede olduğunuzda eğer <literal>REQ_DOWN_ITEM</literal> isteğini gönderirseniz <literal>REQ_SCR_DLINE</literal>'e çevrilir ve menü bir adım aşağı kayar. El ile de <literal>REQ_SCR_</literal> isteklerini kaydırma işlemi için verebilirsiniz. Nasıl yapılabileceğine bakalım:
</para>
<example xml:id="ncurses-howto-mmesc">
<title>Kaydırılabilir Menü örneği</title><para>
<programlisting>
#include &lt;curses.h>
#include &lt;menu.h>

#define ARRAY_SIZE(a) (sizeof(a) / sizeof(a[0]))
#define CTRLD   4

char *choices[] = {
  "Choice 1",
  "Choice 2",
  "Choice 3",
  "Choice 4",
  "Choice 5",
  "Choice 6",
  "Choice 7",
  "Choice 8",
  "Choice 9",
  "Choice 10",
  "Exit",
  (char *)NULL,
};
void print_in_middle(WINDOW *win, int starty, int startx, int width,
     char *string, chtype color);

int main()
{ ITEM **my_items;
  int c;
  MENU *my_menu;
  WINDOW *my_menu_win;
  int n_choices, i;

  /* Curses kipini ilklendir */
  initscr();
  start_color();
  cbreak();
  noecho();
  keypad(stdscr, TRUE);
  init_pair(1, COLOR_RED, COLOR_BLACK);
  init_pair(2, COLOR_CYAN, COLOR_BLACK);

  /* Öğeleri oluştur */
  n_choices = ARRAY_SIZE(choices);
  my_items = (ITEM **)calloc(n_choices, sizeof(ITEM *));
  for(i = 0; i &lt; n_choices; ++i)
    my_items[i] = new_item(choices[i], choices[i]);

  /* Menüyü oluştur */
  my_menu = new_menu((ITEM **)my_items);

  /* Menü ile ilişiklendirilecek pencereyi oluştur */
  my_menu_win = newwin(10, 40, 4, 4);
  keypad(my_menu_win, TRUE);

  /* Ana ve alt pencereyi ayarla*/
  set_menu_win(my_menu, my_menu_win);
  set_menu_sub(my_menu, derwin(my_menu_win, 6, 38, 3, 1));
  set_menu_format(my_menu, 5, 1);

  /* Menü göstericisini" * " olarak ayarla*/
  set_menu_mark(my_menu, " * ");

  /* Ana pencere etrafında bir çerçeve çiz ve başlığı yaz */
  box(my_menu_win, 0, 0);
  print_in_middle(my_menu_win, 1, 0, 40, "My Menu", COLOR_PAIR(1));
  mvwaddch(my_menu_win, 2, 0, ACS_LTEE);
  mvwhline(my_menu_win, 2, 1, ACS_HLINE, 38);
  mvwaddch(my_menu_win, 2, 39, ACS_RTEE);

  /* Menüyü ekrana yaz */
  post_menu(my_menu);
  wrefresh(my_menu_win);

  attron(COLOR_PAIR(2));
  mvprintw(LINES - 2, 0,
    "Sayfayı aşağı yukarı kaydırmak için PageUp ve PageDown kullanın.");
  mvprintw(LINES - 1, 0,
    "Hareket etmek için Ok tuşları kullanın (Çıkmak için F1)");
  attroff(COLOR_PAIR(2));
  refresh();

  while((c = wgetch(my_menu_win)) != KEY_F(1))
  { switch(c)
    { case KEY_DOWN:
        menu_driver(my_menu, REQ_DOWN_ITEM);
        break;
      case KEY_UP:
        menu_driver(my_menu, REQ_UP_ITEM);
        break;
      case KEY_NPAGE:
        menu_driver(my_menu, REQ_SCR_DPAGE);
        break;
      case KEY_PPAGE:
        menu_driver(my_menu, REQ_SCR_UPAGE);
        break;
    }
    wrefresh(my_menu_win);
  }

  /* Menüyü ekrandan sil ve ayrılan bellek alanını geri ver */
  unpost_menu(my_menu);
  free_menu(my_menu);
  for(i = 0; i &lt; n_choices; ++i)
    free_item(my_items[i]);
  endwin();
}

void print_in_middle(WINDOW *win, int starty, int startx, int width,
     char *string, chtype color)
{ int length, x, y;
  float temp;

  if(win == NULL)
    win = stdscr;
  getyx(win, y, x);
  if(startx != 0)
    x = startx;
  if(starty != 0)
    y = starty;
  if(width == 0)
    width = 80;

  length = strlen(string);
  temp = (width - length)/ 2;
  x = startx + (int)temp;
  wattron(win, color);
  mvwprintw(win, y, x, "%s", string);
  wattroff(win, color);
  refresh();
}
</programlisting></para>
</example>
<para>
Bu program kendisini açıklar niteliktedir. Bu örnekte seçenek sayısı, alt menümüzün 6 tane gösterebilme kapasitesi olan öğe sayısından 10'a çıkarılmıştır. Bu mesaj menü sistemine açık bir şekilde <function>set_menu_format()</function> ile haber verilmelidir. Burada, tek bir sayfa için gösterilmesini istediğimiz satır ve sütun sayısını belirttik. Satır değişkenlerinde, eğer alt menü yüksekliğinden küçükse, herhangi bir sayıdaki öğeyi gösterilmesi için tanımlayabiliriz. Eğer kullanıcı tarafından basılan tuş PAGE UP veya  PAGE DOWN ise, <function>menu_driver()</function> tarafından verilen isteklerden dolayı (<literal>REQ_SCR_DPAGE</literal> ve <literal>REQ_SCR_UPAGE</literal>) menü bir sayfa kayar.
</para>
</sect2>

<sect2 userlevel="chunkthis" xml:id="ncurses-howto-multicolumn">
<title>Çok Sütunlu Menüler</title><para>
Yukarıdaki örnekte <function>set_menu_format()</function> işlevini nasıl kullanacağınızı gördünüz. Sütun değişkeninin (3. değişken) ne yaptığından bahsetmedim. Aslında, eğer alt menünüz yeterince genişse bir satırda birden fazla öğe gösterimini seçebilirsiniz. Bu, sütun değişkenlerinde tanımlanabilir. İşleri daha basit hale getirmek için, aşağıdaki örnek öğeler için açıklamaları göstermemektedir.
</para>
<example xml:id="ncurses-howto-mmemuco">
<title>Çok Sütunlu Menü Örneği</title><para>
<programlisting>
#include &lt;curses.h>
#include &lt;menu.h>

#define ARRAY_SIZE(a) (sizeof(a) / sizeof(a[0]))
#define CTRLD   4

char *choices[] = {
  "Choice 1",  "Choice 2",  "Choice 3",  "Choice 4",  "Choice 5",
  "Choice 6",  "Choice 7",  "Choice 8",  "Choice 9",  "Choice 10",
  "Choice 11", "Choice 12", "Choice 13", "Choice 14", "Choice 15",
  "Choice 16", "Choice 17", "Choice 18", "Choice 19", "Choice 20",
  "Exit",
  (char *)NULL,
};

int main()
{ ITEM **my_items;
  int c;
  MENU *my_menu;
  WINDOW *my_menu_win;
  int n_choices, i;

  /* Curses kipini ilklendir */
  initscr();
  start_color();
  cbreak();
  noecho();
  keypad(stdscr, TRUE);
  init_pair(1, COLOR_RED, COLOR_BLACK);
  init_pair(2, COLOR_CYAN, COLOR_BLACK);

  /* Öğeleri oluştur */
  n_choices = ARRAY_SIZE(choices);
  my_items = (ITEM **)calloc(n_choices, sizeof(ITEM *));
  for(i = 0; i &lt; n_choices; ++i)
    my_items[i] = new_item(choices[i], choices[i]);

  /* Menüyü oluştur */
  my_menu = new_menu((ITEM **)my_items);

  /* Menü seçeneğini açıklamayı göstermeyecek şekilde ayarla */
  menu_opts_off(my_menu, O_SHOWDESC);

  /* Menü ile ilişiklendirilecek pencereyi oluştur */
  my_menu_win = newwin(10, 70, 4, 4);
  keypad(my_menu_win, TRUE);

  /* Ana ve alt pencereyi oluştur */
  set_menu_win(my_menu, my_menu_win);
  set_menu_sub(my_menu, derwin(my_menu_win, 6, 68, 3, 1));
  set_menu_format(my_menu, 5, 3);
  set_menu_mark(my_menu, " * ");

  /* Ana pencere etrafında bir çerçeve çizer ve bir başlık yazar */
  box(my_menu_win, 0, 0);

  attron(COLOR_PAIR(2));
  mvprintw(LINES - 3, 0,
    "Menüyü kaydırmak için PageUp ve PageDown kullanın");
  mvprintw(LINES - 2, 0,
    "Hareket etmek için ok tuşlarını kullanın (Çıkmak için F1)");
  attroff(COLOR_PAIR(2));
  refresh();

  /* Ekranı yazdır */
  post_menu(my_menu);
  wrefresh(my_menu_win);

  while((c = wgetch(my_menu_win)) != KEY_F(1))
  { switch(c)
    { case KEY_DOWN:
        menu_driver(my_menu, REQ_DOWN_ITEM);
        break;
      case KEY_UP:
        menu_driver(my_menu, REQ_UP_ITEM);
        break;
      case KEY_LEFT:
        menu_driver(my_menu, REQ_LEFT_ITEM);
        break;
      case KEY_RIGHT:
        menu_driver(my_menu, REQ_RIGHT_ITEM);
        break;
      case KEY_NPAGE:
        menu_driver(my_menu, REQ_SCR_DPAGE);
        break;
      case KEY_PPAGE:
        menu_driver(my_menu, REQ_SCR_UPAGE);
        break;
    }
    wrefresh(my_menu_win);
  }

  /* Ekrandan sil ve tahsis edilen belleği geri ver */
  unpost_menu(my_menu);
  free_menu(my_menu);
  for(i = 0; i &lt; n_choices; ++i)
    free_item(my_items[i]);
  endwin();
}
</programlisting></para>
</example>
<para>
<function>set_menu_format()</function> işlev çağrısına bakın. Olması gereken sütun sayısını 3 olarak tanımlar ve bu yüzden de her satırda 3 öğe gözükür. <function>menu_opts_off()</function> ile de menü açıklamalarını kapatmıştık. Menü seçeneklerini değiştirmek için <function>set_menu_opts(), menu_opts_on()</function> ve <function>menu_opts()</function> gibi birkaç işlev vardır. Aşağıdaki menü seçenekleri belirtilebilir.
</para>
<literallayout indent="0">
    O_ONEVALUE
        Bu menü için sadece tek öğe seçilebilir.

    O_SHOWDESC
        Menü ekrana yazıldığıda öğe açıklamalarını göster.

    O_ROWMAJOR
        Menüyü satır-düzensel sırada göster.

    O_IGNORECASE
        Örüntü eşlemede büyük küçük harfe duyarsız ol.

    O_SHOWMATCH
        Örüntü eşleme sırasında imleci öğe isminin içerisine konumlandır.

    O_NONCYCLIC
       İmleci menünün sonundan başına (veya tersi) aktarma.
</literallayout>
<para>
Öntanımlı olarak tüm seçenekler etkindir. Belli özellikleri <function>menu_opts_on()</function> ve <function>menu_opts_off()</function> işlevleri ile açıp kapatabilirsiniz. Aynı zamanda doğrudan, bazı özellikleri <function>set_menu_opts()</function> ile belirtebilirsiniz. Bu işleve değiştirge yukarıdaki sabitlerle VEYA'lanmış bir değer olmalıdır.  <function>menu_opts()</function> işlevi menünün halihazırdaki seçeneklerini bulmak için kullanılabilir.
</para>
</sect2>

<sect2 userlevel="chunkthis" xml:id="ncurses-howto-multivaluemenus">
<title>Çok Değerli Menüler</title><para>
<literal>O_ONEVALUE</literal> seçeneğini kapattığımızda ne olur diye merak ediyor olabilirsiniz. Bunun anlamı birden çok öğe seçebilirsiniz demektir. Bu da bizi <literal>REQ_TOGGLE_ITEM</literal> isteğine getirmektedir. Bir örnekle görelim:
</para>
<example xml:id="ncurses-howto-mmeto">
<title>Çok Değerli Menü Örneği</title><para>
<programlisting>
#include &lt;curses.h>
#include &lt;menu.h>

#define ARRAY_SIZE(a) (sizeof(a) / sizeof(a[0]))
#define CTRLD   4

char *choices[] = {
  "Choice 1",
  "Choice 2",
  "Choice 3",
  "Choice 4",
  "Choice 5",
  "Choice 6",
  "Choice 7",
  "Exit",
};

int main()
{ ITEM **my_items;
  int c;
  MENU *my_menu;
  int n_choices, i;
  ITEM *cur_item;

  /* Curses kipini ilklendir */
  initscr();
  cbreak();
  noecho();
  keypad(stdscr, TRUE);

  /* Öğeleri ilklendir */
  n_choices = ARRAY_SIZE(choices);
  my_items = (ITEM **)calloc(n_choices + 1, sizeof(ITEM *));
  for(i = 0; i &lt; n_choices; ++i)
    my_items[i] = new_item(choices[i], choices[i]);
  my_items[n_choices] = (ITEM *)NULL;

  my_menu = new_menu((ITEM **)my_items);

  /* Menüyü çok değerli yap */
  menu_opts_off(my_menu, O_ONEVALUE);

  mvprintw(LINES - 3, 0,
    "&lt;SPACE>'i seçmek veya seçileni iptal için kullanın.");
  mvprintw(LINES - 2, 0,
    "&lt;ENTER> 'ı o anki seçileni görmek için kullanın "
    "(Çıkmak için F1)");
  post_menu(my_menu);
  refresh();

  while((c = getch()) != KEY_F(1))
  { switch(c)
    { case KEY_DOWN:
        menu_driver(my_menu, REQ_DOWN_ITEM);
        break;
      case KEY_UP:
        menu_driver(my_menu, REQ_UP_ITEM);
        break;
      case ' ':
        menu_driver(my_menu, REQ_TOGGLE_ITEM);
        break;
      case 10:        /* Enter */
      { char temp[200];
        ITEM **items;

        items = menu_items(my_menu);
        temp[0] = '\0';
        for(i = 0; i &lt; item_count(my_menu); ++i)
          if(item_value(items[i]) == TRUE)
          { strcat(temp, item_name(items[i]));
            strcat(temp, " ");
          }
        move(20, 0);
        clrtoeol();
        mvprintw(20, 0, temp);
        refresh();
      }
      break;
    }
  }

  free_item(my_items[0]);
  free_item(my_items[1]);
  free_menu(my_menu);
  endwin();
}
</programlisting></para>
</example>
<para>
Vay canına, bir sürü yeni işlev daha. Teker teker her birini ele alalım. İlk olarak <literal>REQ_TOGGLE_ITEM</literal> ile başlayalım. Çok değerli bir menüde kullanıcı birden fazla öğe seçebilmeli veya seçimi iptal edebilmelidir. <literal>REQ_TOGGLE_ITEM</literal> isteği o anki seçimi değiştirir (etkinleştirme veya iptal etme). Bu durumda space tuşuna basıldığında <literal>REQ_TOGGLE_ITEM</literal> isteği <function>menu_driver</function>'a sonucu gerçekleştirmek için gönderilir.
</para><para>
İşte şimdi kullanıcı &lt;ENTER&gt;'a bastığında onun seçtiği öğeleri görürüz. Önce menü ile ilişiklendirilmiş öğeleri <function>menu_items()</function> işlevini kullanarak bulduk. Daha sonra öğenin seçili mi değil mi olduğunu anlamak için öğeler üzerinde gezindik. Eğer öğe seçiliyse <function>item_value()</function> işlevi <literal>TRUE</literal> döndürür. <function>item_count()</function> işlevi menüdeki öğe sayısını döndürür. Ayrıca öğe açıklamalarını <function>item_description()</function> ile alabilirsiniz.
</para>
</sect2>

<sect2 userlevel="chunkthis" xml:id="ncurses-howto-menuopt">
<title>Menü Seçenekleri</title><para>
Evet, şimdi artık menünüzde pekçok özellikler ile birtakım farklılıklar oluşturmak için can atıyorsunuzdur. Biliyorum. Renk istiyorsunuz!!! Metin kipinde çalışan şu <link xlink:href="http://www.jersey.net/~debinjoe/games/">dos oyunları</link> gibi hoş menüler oluşturmak istiyorsunuz. <function>set_menu_fore()</function> ve <function>set_menu_back()</function> işlevleri seçili öğenin görünüm özelliklerini değiştirmek için kullanılır. İsimleri yanıltıcıdır. Hiçbir işe yaramayacak olan menünün ön ve arka fon renklerini değiştirmezler.
</para><para>
<function>set_menu_grey()</function> işlevi menüdeki seçilemez öğelerinin görünüm özelliklerini değiştirmek için kullanılır. Bu da bizi bir öğe için oldukça ilginç ve tekil olan <literal>O_SELECTABLE</literal>'a getirmektedir. Bunu <function>item_opts_off()</function> işlevi ile kapatabiliriz ve bundan sonra öğe seçilemez hale gelir. Bu durum şu hoş pencere menülerindeki gri öğe durumuna benzemektedir. Bütün bunları pratiğe bir örnekle dökelim.
</para>
<example xml:id="ncurses-howto-mmeat">
<title>Menü Seçenekleri Örneği</title><para>
<programlisting>
#include &lt;menu.h>

#define ARRAY_SIZE(a) (sizeof(a) / sizeof(a[0]))
#define CTRLD   4

char *choices[] = {
  "Choice 1",
  "Choice 2",
  "Choice 3",
  "Choice 4",
  "Choice 5",
  "Choice 6",
  "Choice 7",
  "Exit",
};

int main()
{ ITEM **my_items;
  int c;
  MENU *my_menu;
  int n_choices, i;
  ITEM *cur_item;

  /* Curses kipini ilklendir */
  initscr();
  start_color();
  cbreak();
  noecho();
  keypad(stdscr, TRUE);
  init_pair(1, COLOR_RED, COLOR_BLACK);
  init_pair(2, COLOR_GREEN, COLOR_BLACK);
  init_pair(3, COLOR_MAGENTA, COLOR_BLACK);

  /* Öğeleri ilklendir */
  n_choices = ARRAY_SIZE(choices);
  my_items = (ITEM **)calloc(n_choices + 1, sizeof(ITEM *));
  for(i = 0; i &lt; n_choices; ++i)
    my_items[i] = new_item(choices[i], choices[i]);
  my_items[n_choices] = (ITEM *)NULL;
  item_opts_off(my_items[3], O_SELECTABLE);
  item_opts_off(my_items[6], O_SELECTABLE);

  /* Menüyü oluştur */
  my_menu = new_menu((ITEM **)my_items);

  /* Menünün ön ve arka fon rengini ayarla */
  set_menu_fore(my_menu, COLOR_PAIR(1) | A_REVERSE);
  set_menu_back(my_menu, COLOR_PAIR(2));
  set_menu_grey(my_menu, COLOR_PAIR(3));

  /* Menüyü ekrana yaz */
  mvprintw(LINES - 3, 0,
    "Seçilen öğeyi görmek için &lt;ENTER>'a basınd");
  mvprintw(LINES - 2, 0,
    "Hareket etmek için Yukarı ve Aşağı tuşlarını kullanın "
    "(Çıkmak için F1)");
  post_menu(my_menu);
  refresh();

  while((c = getch()) != KEY_F(1))
  { switch(c)
    { case KEY_DOWN:
        menu_driver(my_menu, REQ_DOWN_ITEM);
        break;
      case KEY_UP:
        menu_driver(my_menu, REQ_UP_ITEM);
        break;
      case 10: /* Enter */
        move(20, 0);
        clrtoeol();
        mvprintw(20, 0, "Seçilen öğe : %s",
                 item_name(current_item(my_menu)));
        pos_menu_cursor(my_menu);
        break;
    }
  }
  unpost_menu(my_menu);
  for(i = 0; i &lt; n_choices; ++i)
    free_item(my_items[i]);
  free_menu(my_menu);
  endwin();
}
</programlisting></para>
</example>
</sect2>

<sect2 userlevel="chunkthis" xml:id="ncurses-howto-menuuserptr">
<title>Faydalı Kullanıcı Göstericisi</title><para>
Menüdeki her öğeye bir kullanıcı göstericisi atayabiliriz. Panellerdeki kullanıcı göstericisi ile aynı şekilde çalışmaktadır. Menü sistemi tarafından kullanılmazlar. Bunlar içerisine istediğiniz herhangi bir şeyi koyabilirsiniz. Ben genelde menü seçeneği seçildiğinde çalışacak işlevi (seçilen ve muhtemelen kullanıcının &lt;ENTER&gt;'ladığı) tutmak için kullanırım.
</para>
<example xml:id="ncurses-howto-mmeus">
<title>Menü Kullanıcı Göstericilerinin Kullanımı</title><para>
<programlisting>
#include &lt;curses.h>
#include &lt;menu.h>

#define ARRAY_SIZE(a) (sizeof(a) / sizeof(a[0]))
#define CTRLD   4

char *choices[] = {
  "Choice 1",
  "Choice 2",
  "Choice 3",
  "Choice 4",
  "Choice 5",
  "Choice 6",
  "Choice 7",
  "Exit",
};
void func(char *name);

int main()
{ ITEM **my_items;
  int c;
  MENU *my_menu;
  int n_choices, i;
  ITEM *cur_item;

  /* Curses Kipi İlklendir */
  initscr();
  start_color();
  cbreak();
  noecho();
  keypad(stdscr, TRUE);
  init_pair(1, COLOR_RED, COLOR_BLACK);
  init_pair(2, COLOR_GREEN, COLOR_BLACK);
  init_pair(3, COLOR_MAGENTA, COLOR_BLACK);

  /* Öğeleri İlklendir */
  n_choices = ARRAY_SIZE(choices);
  my_items = (ITEM **)calloc(n_choices + 1, sizeof(ITEM *));
  for(i = 0; i &lt; n_choices; ++i)
  { my_items[i] = new_item(choices[i], choices[i]);
    /* Set the user pointer */
    set_item_userptr(my_items[i], func);
  }
  my_items[n_choices] = (ITEM *)NULL;

  /* Menüyü oluştur */
  my_menu = new_menu((ITEM **)my_items);

  /* Menüyü ekrana yaz */
  mvprintw(LINES - 3, 0,
    "Seçili öğeyi görmek için &lt;ENTER>'a basın");
  mvprintw(LINES - 2, 0,
    "Hareket etmek için Yukarı ve Aşağı ok tuşlarını kullanın "
    "(Çıkmak için F1)");
  post_menu(my_menu);
  refresh();

  while((c = getch()) != KEY_F(1))
  { switch(c)
    { case KEY_DOWN:
        menu_driver(my_menu, REQ_DOWN_ITEM);
        break;
      case KEY_UP:
        menu_driver(my_menu, REQ_UP_ITEM);
        break;
      case 10: /* Enter */
      { ITEM *cur;
        void (*p)(char *);

        cur = current_item(my_menu);
        p = item_userptr(cur);
        p((char *)item_name(cur));
        pos_menu_cursor(my_menu);
        break;
      }
      break;
    }
  }
  unpost_menu(my_menu);
  for(i = 0; i &lt; n_choices; ++i)
    free_item(my_items[i]);
  free_menu(my_menu);
  endwin();
}

void func(char *name)
{ move(20, 0);
  clrtoeol();
  mvprintw(20, 0, "Seçili öge: %s", name);
}
</programlisting></para>
</example>
</sect2>
</sect1>

<sect1 xml:id="ncurses-howto-forms"><title>Form Kütüphanesi</title>
<para>
Aslında, eğer web sayfalarında şu kullanıcıdan girdi alan ve bir takım işler yapan formları gördüyseniz, bunların metin kipinde nasıl oluşturulacağını merak ediyor olabilirsiniz. Bu etkileyici formların yalın ncurses ortamında yazılması biraz zordur. Form kütüphanesi formların kolay şekilde oluşturulması ve üzerinde çalışılması için temel bir çalışma taslağı oluşturur. Doğrulama, alanların çalışma zamanında genişlemesi v.b. gibi pekçok özellikleri (işlevleri) vardır. Hepsini görelim.
</para><para>
Bir form alanların bir araya gelmesinden oluşur; her bir alan bir etiket (durağan metin) veya veri girişi alanı olabilir. Forms, formların birden fazla sayfaya bölünmesini sağlayan bir kütüphanedir.
</para>

<sect2 userlevel="chunkthis" xml:id="ncurses-howto-formbasics">
<title>Temel Bilgiler</title><para>
Formlar menülerle aynı şekilde oluşturulur. Önce form ile ilgili alanlar <function>new_field()</function> ile oluşturulur. Alanlar için bir takım güzel özellikler ile gösterilmelerini sağlayan seçenekler tanımlayabilirsiniz: alandan imleci çekmeden önce alan içerisine yazılanı kontrol etmek v.b.. Daha sonra alanlar formlara ilintilenir. Bundan sonra form görüntülenmek için ve girdi almak için hazırdır. <function>menu_driver()</function> satırlarına benzer şekilde form için sürücü, <function>form_driver()</function> ile değiştirilir. <function>form_driver</function>'a bir takım istekler göndererek belli alanlara odaklanabiliriz, alanın sonuna konumlanabiliriz, v.b.. Kullanıcının alanlara veri girmesinden ve doğrulamanın yapılmasından sonra form ekrandan silinip ayrılan bellek alanları geri verilebilir.
</para><para>
Bir form programının genel akışı şu şekildedir:
</para><para>
<orderedlist>
<listitem>
Curses kipini ilklendirilir
</listitem><listitem>
<function>new_field()</function> kullanılarak alanlar oluşturulur. Alanın form üzerindeki konumu, yükseklik ve genişliğini tanımlayabilirsiniz.
</listitem><listitem>
Formlar kendilerine ilintilenecek alanlar ile birlikte <function>new_form()</function> kullanarak oluşturulur.
</listitem><listitem>
<function>form_post()</function> ile ekrana yazılır ve ekran tazelenir.
</listitem><listitem>
Bir döngü ile kullanıcıdan gelen istekleri işlenir ve <function>form_driver</function> ile gerekli güncelleştirmeler yapılır.
</listitem><listitem>
Form ekrandan <function>form_unpost()</function> ile silinir.
</listitem><listitem>
<function>free_form()</function> ile tahsis edilen bellek alanını geri verilir.
</listitem><listitem>
Alanlar için ayrılan bellek alanını <function>free_item()</function> ile geri verilir.
</listitem><listitem>
Curses kipi sonlandırılır.
</listitem></orderedlist>
</para><para>
Gördüğünüz gibi form kütüphanesi ile çalışmak menüler üzerinde işlemler yapmaya benzemektedir. Aşağıdaki örnekler form işlemenin değişik durumlarını gösterecektir. Basit bir örnekle yolculuğumuza başlayalım.
</para>
</sect2>

<sect2 userlevel="chunkthis" xml:id="ncurses-howto-compileforms">
<title>Form Kütüphanesi ile derleme</title><para>
Form kütüphanesi işlevlerini kullanmak için <filename>form.h</filename> başlık dosyasını programınıza eklemeniz ve kütüphane ile ilintileyerek derlemek için <option>-lform -lncurses</option> seçeneklerini kullanmanız gerekmektedir.
</para><para>
<programlisting>
#include &lt;form.h&gt;
.
.
.

derleme ve ilintileme: <command>gcc </command><emphasis>program dosyası </emphasis><command>-lform -lncurses</command>
</programlisting>
</para>
<example xml:id="ncurses-howto-ffosi">
<title>Formların Temelleri</title><para>
<programlisting>
#include &lt;form.h>

int main()
{ FIELD *field[3];
  FORM  *my_form;
  int ch;

  /* Curses kipini ilklendir*/
  initscr();
  cbreak();
  noecho();
  keypad(stdscr, TRUE);

  /* Alanları ilklendir */
  field[0] = new_field(1, 10, 4, 18, 0, 0);
  field[1] = new_field(1, 10, 6, 18, 0, 0);
  field[2] = NULL;

  /* alan seçeneklerini ayarla*/
  set_field_back(field[0], A_UNDERLINE);  /* Seçenek için bir satır yazın  */
  field_opts_off(field[0], O_AUTOSKIP);   /* Eğer alan dolduyda            */
                                          /* alan içerisinde ilerleme      */
  set_field_back(field[1], A_UNDERLINE);
  field_opts_off(field[1], O_AUTOSKIP);

  /* Form2u oluştur ve ekrana yaz */
  my_form = new_form(field);
  post_form(my_form);
  refresh();

  mvprintw(4, 10, "Değer 1:");
  mvprintw(6, 10, "Değer 2:");
  refresh();

  /* Kullanıcı isteklerinde hareket edin */
  while((ch = getch()) != KEY_F(1))
  { switch(ch)
    { case KEY_DOWN:
        /* Sonraki alana gidin */
        form_driver(my_form, REQ_NEXT_FIELD);
        /* O anki önbelleğin sonuna gidin */
        /* Son karakterde döngüden çık */
        form_driver(my_form, REQ_END_LINE);
        break;
      case KEY_UP:
        /* Bir önceki alana git */
        form_driver(my_form, REQ_PREV_FIELD);
        form_driver(my_form, REQ_END_LINE);
        break;
      default:
        /* Eğer normal bir karakterse */
        /* Ekrana yazılır             */
        form_driver(my_form, ch);
        break;
    }
  }

  /* Formu ekrandan sil ve ayrılan bellek alanını geri ver */
  unpost_form(my_form);
  free_form(my_form);
  free_field(field[0]);
  free_field(field[1]);

  endwin();
  return 0;
}
</programlisting></para>
</example>
<para>
Yukarıdaki örnek oldukça açık şekildedir. <command>new_field()</command> ile iki alan oluşturur. <function>new_field()</function> değiştirge olarak yükseklik, genişlik, y başlangıç koordinatı, x başlangıç koordinatı, ekranda gözükmeyen satır sayısı ve ilave çalışma önbelleği sayısını almaktadır. Beşinci değiştirge, ekranda gözükmeyen satır sayısı alanın ne kadarının gözükeceğini belirtir. Eğer sıfırsa, tüm alan gösterilir, aksi halde kullanıcı alanın görüntülenmeyen alanlarına taştığında form kaydırılabilir olacaktır. Form kütüphanesi kullanıcının girdiği verilerin saklanması için her alan için bir önbellek tahsis eder. <function>new_field()</function>'in son değiştirgesini kullanarak ilave ek bellekler tahsis etmesini sağlayabiliriz. İstediğiniz herhangi bir amaç için kullanılabilir.
</para><para>
Alanları oluşturduktan sonra, <function>set_field_back()</function> ile artalan özellikleri bir alt çizgi olarak ayarlanır. <literal>AUTOSKIP</literal> seçeneği <function>field_opts_off()</function> kullanılarak kapatılır. Eğer bu özellik açıksa, odak eğer üzerinde işlem yapılan alan tamamen dolduysa bir sonraki alana kayacaktır.
</para><para>
Alanlar forma ilintilendikten sonra ekrana yazılır. İşte şu <statement>while</statement> döngüsü içerisinde de kullanıcı girdileri <function>form_driver</function>'daki uygun karşılıkları ile işlenir. <function>form_driver()</function>'a yapılacak olan isteklerin ayrıntıları daha sonra açıklanacaktır.
</para>
</sect2>

<sect2 userlevel="chunkthis" xml:id="ncurses-howto-playfields">
<title>Alanlar ile Oynamak</title><para>
Her bir form alanı birden fazla özellik ile ilintilenmiştir. İstenilen özelliği elde etmek ve eğlenmek için değiştirilebilirler. Daha ne bekliyoruz?
</para>

<sect3 xml:id="ncurses-howto-fetchinfo">
<title>Alan Konumunun ve Boyutununun Alınması</title><para>
Alan oluşturulması sırasında verdiğimiz değiştirgeler <function>field_info()</function> ile okunabilir. Kendisine verilen değiştirgelere yükseklik, genişlik, y başlama koordinatı, x başlama koordinatı, görünmeyen satır sayısı ve ilave önbellek miktarını geri döndürür. <function>new_field()</function> bu işlevin bir çeşit ters işlevidir.
</para><para>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <function>field_info</function></funcdef>
<parameters><parameter>
  <paramdef>(FIELD *<emphasis>alan</emphasis>,</paramdef>
  <paramdesc>/* döndürülecek alan */</paramdesc>
</parameter><parameter>
  <paramdef>int    *<emphasis>yukseklik</emphasis>,</paramdef>
  <paramdesc>/* alan yüksekliği */</paramdesc>
</parameter><parameter>
  <paramdef>int    *<emphasis>genislik</emphasis>,</paramdef>
  <paramdesc>/* alan genişliği */</paramdesc>
</parameter><parameter>
  <paramdef>int    *<emphasis>ust</emphasis>,</paramdef>
  <paramdesc>/* üst kenar */</paramdesc>
</parameter><parameter>
  <paramdef>int    *<emphasis>sol</emphasis>,</paramdef>
  <paramdesc>/* sol kenar */</paramdesc>
</parameter><parameter>
  <paramdef>int    *<emphasis>gorunmeyen</emphasis>,</paramdef>
  <paramdesc>/* görünmeyen satır sayısı */</paramdesc>
</parameter><parameter>
  <paramdef>int    *<emphasis>tampon_boyu</emphasis>);</paramdef>
  <paramdesc>/* tampon boyu */</paramdesc>
</parameter></parameters>
</funcprototype></funcsynopsis></para>
</sect3>

<sect3 xml:id="ncurses-howto-movefield"><title>Alanı taşımak</title><para>
Alanın konumu farklı bir konuma <function>move_field()</function> ile taşınabilir.
</para><para>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>move_field</command></funcdef><parameters>
<parameter>
  <paramdef>(FIELD *<emphasis>alan</emphasis>,</paramdef>
  <paramdesc>/* değiştirilecek alan */</paramdesc>
</parameter><parameter>
  <paramdef>int     <emphasis>ust</emphasis>,</paramdef>
  <paramdesc>/* yeni üst kenar */</paramdesc>
</parameter><parameter>
  <paramdef>int     <emphasis>sol</emphasis>);</paramdef>
  <paramdesc>/* yeni sol kenar */</paramdesc>
</parameter></parameters>
</funcprototype></funcsynopsis>
</para><para>
Alışıldığı gibi, değişen konum bilgileri <function>field_infor()</function> ile alınabilir.
</para>
</sect3>

<sect3 xml:id="ncurses-howto-justifyfield"><title>Alan Hizalama</title><para>
Alanlar için hizalama <function>set_field_just()</function> işlevi ile yapılabilir.
</para><para>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>set_field_just</command></funcdef><parameters>
<parameter>
  <paramdef>(FIELD *<emphasis>alan</emphasis>,</paramdef>
  <paramdesc>/* değiştirilecek alan */</paramdesc>
</parameter><parameter>
  <paramdef>int     <emphasis>kip</emphasis>);</paramdef>
  <paramdesc>/* ayarlanacak kip */</paramdesc>
</parameter></parameters>
</funcprototype></funcsynopsis>
</para><para><funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>field_just</command></funcdef><parameters>
<parameter>
  <paramdef>(FIELD *<emphasis>alan</emphasis>);</paramdef>
  <paramdesc>/* alan için hizalama kipi */</paramdesc>
</parameter></parameters>
</funcprototype></funcsynopsis>
</para><para>
Bu işlevler tarafından kullanılan ve geri döndürülen hizalama kipleri: <literal>NO_JUSTIFICATION</literal>, <literal>JUSTIFY_RIGHT</literal>, <literal>JUSTIFY_LEFT</literal>, or <literal>JUSTIFY_CENTER</literal>
</para>
</sect3>

<sect3 xml:id="ncurses-howto-fielddispattrib">
<title>Alan Görüntüleme Öznitelikleri</title><para>
Gördüğünüz gibi, yukarıdaki örnekte alan için görünüm öznitelikleri <function>set_field_fore()</function> ve <function>setfield_back()</function> ile ayarlanabilir. Bu işlevler alanların ön ve artalan özelliklerini ayarlar. Aynı zamanda alanın doldurulmamış kısımları için bir tampon karakteri tanımlayabilirsiniz. Tampon karakteri <function>set_field_pad()</function> çağrısıyla tanımlanır. Varsayılan tampon karakteri boşluktur. <function>field_fore(), field_back, field_pad()</function> işlevleri ön, artalan özniteliklerini ve tampon karakterini sorgulamak için kullanılabilir. Aşağıdaki liste işlevlerin kullanımını vermektedir.
</para><para>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>set_field_fore</command></funcdef><parameters>
<parameter>
  <paramdef>(FIELD *<emphasis>alan</emphasis>,</paramdef>
  <paramdesc>/* değiştirilecek alan */</paramdesc>
</parameter><parameter>
  <paramdef>chtype  <emphasis>öznitelik</emphasis>);</paramdef>
  <paramdesc>/* ayarlanacak öznitelik */</paramdesc>
</parameter></parameters>
</funcprototype></funcsynopsis>
</para><para>
<funcsynopsis><funcprototype role="işlev">
<funcdef>chtype <command>field_fore</command></funcdef><parameters>
<parameter>
  <paramdef>(FIELD *<emphasis>alan</emphasis>);</paramdef>
  <paramdesc>/* sorgulanacak alan */</paramdesc>
</parameter><parameter>
  <paramdef></paramdef>
  <paramdesc>/* önalan özniteliğini döndürür */</paramdesc>
</parameter></parameters>
</funcprototype></funcsynopsis>
</para><para>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>set_field_back</command></funcdef><parameters>
<parameter>
  <paramdef>(FIELD *<emphasis>alan</emphasis>,</paramdef>
  <paramdesc>/* değiştirilecek alan */</paramdesc>
</parameter><parameter>
  <paramdef>chtype  <emphasis>öznitelik</emphasis>);</paramdef>
  <paramdesc>/* ayarlanacak öznitelik */</paramdesc>
</parameter></parameters>
</funcprototype></funcsynopsis>
</para><para>
<funcsynopsis><funcprototype role="işlev">
<funcdef>chtype <command>field_back</command></funcdef><parameters>
<parameter>
  <paramdef>(FIELD *<emphasis>alan</emphasis>);</paramdef>
  <paramdesc>/* sorgulanacak alan */</paramdesc>
</parameter><parameter>
  <paramdef></paramdef>
  <paramdesc>/* artalan özniteliğini döndürür */</paramdesc>
</parameter></parameters>
</funcprototype></funcsynopsis>
</para><para>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>set_field_pad</command></funcdef><parameters>
<parameter>
  <paramdef>(FIELD *<emphasis>alan</emphasis>,</paramdef>
  <paramdesc>/* değiştirilecek alan */</paramdesc>
</parameter><parameter>
  <paramdef>int     <emphasis>dolgu_krk</emphasis>);</paramdef>
  <paramdesc>/* adımlama karakteri */</paramdesc>
</parameter></parameters>
</funcprototype></funcsynopsis>
</para><para>
<funcsynopsis><funcprototype role="işlev">
<funcdef>chtype <command>field_pad</command></funcdef><parameters>
<parameter>
  <paramdef>(FIELD *<emphasis>alan</emphasis>);</paramdef>
  <paramdesc>/* sorgulanacak alan */</paramdesc>
</parameter><parameter>
  <paramdef></paramdef>
  <paramdesc>/* adımlama karakterini döndürür */</paramdesc>
</parameter></parameters>
</funcprototype></funcsynopsis>
</para><para>
Her ne kadar yukarıdaki işlevler oldukça basit gözükse de <function>set_field_fore()</function> ile renkleri kullanmak başlangıçta korkutucu olabilir. Öncelikle alanın ön ve artalan özniteliklerini açıklamama izin verin. Önalan özniteliği karakter ile ilişiklendirilmiştir. Bunun anlamı bir karakterin <function>set_field_fore()</function> ile ayarlanmış öznitelik ile gösterilmesidir. Artalan özniteliği alanın arka fonunu doldurmak için kullanılan özelliktir, bir karakter olmak zorunda değildir. Peki ya renkler? Renkler çiftler halinde tanımlandığından renklendirilmiş alanları göstermenin en iyi yolu nedir? İşte renk görüntü özelliklerini netleştiren bir özellik:
</para>
<example xml:id="ncurses-howto-ffoat">
<title>Form Öznitelikleri Örneği</title><para>
<programlisting>
#include &lt;form.h>

int main()
{ FIELD *field[3];
  FORM  *my_form;
  int ch;

  /* Curses kipini ilklendir */
  initscr();
  start_color();
  cbreak();
  noecho();
  keypad(stdscr, TRUE);

  /* Bazı renk çiftlerini ilklendir */
  init_pair(1, COLOR_WHITE, COLOR_BLUE);
  init_pair(2, COLOR_WHITE, COLOR_BLUE);

  /* alanları ilklendir */
  field[0] = new_field(1, 10, 4, 18, 0, 0);
  field[1] = new_field(1, 10, 6, 18, 0, 0);
  field[2] = NULL;

  /* Alan özelliklerini ayarla */
  /* Alanların arka fonunu mavi yap */
  set_field_fore(field[0], COLOR_PAIR(1));
  /* ön fonun beyaz ya */
  set_field_back(field[0], COLOR_PAIR(2));
  /* karakterler beyaz olarak gösterilir         */
  /* bu alan dolduğunda */
  field_opts_off(field[0], O_AUTOSKIP);
  /* sonraki alana geçme           */
  set_field_back(field[1], A_UNDERLINE);
  field_opts_off(field[1], O_AUTOSKIP);

  /* Alanı oluştur ve ekrana yaz */
  my_form = new_form(field);
  post_form(my_form);
  refresh();

  /* Renklendirilmiş alana odaklan */
  set_current_field(my_form, field[0]);
  mvprintw(4, 10, "Değer 1:");
  mvprintw(6, 10, "Değer 2:");
  mvprintw(LINES - 2, 0,
      "Alanlar arasında geçiş için YUKARI ve AŞAĞI ok tuşlarını kullanın");
  refresh();

  /* Kullanıcı isteklerini almak için döngü */
  while((ch = getch()) != KEY_F(1))
  { switch(ch)
    { case KEY_DOWN:
        /* Sonraki alana git */
        form_driver(my_form, REQ_NEXT_FIELD);
        /* O anki önbelleğin sonuna git */
        /* Son karakterde döngüden çık */
        form_driver(my_form, REQ_END_LINE);
        break;
      case KEY_UP:
        /* Önceki alana git */
        form_driver(my_form, REQ_PREV_FIELD);
        form_driver(my_form, REQ_END_LINE);
        break;
      default:
        /* Eğer bu normal bir karakterse */
        /* ekrana yazılır                */
        form_driver(my_form, ch);
        break;
    }
  }

  /* Formu ekrandan sil ve ayrılan belleği geri ver */
  unpost_form(my_form);
  free_form(my_form);
  free_field(field[0]);
  free_field(field[1]);

  endwin();
  return 0;
}
</programlisting></para>
</example>
<para>
Renk çiftleriyle oynayarak ön ve artalan özniteliklerini anlamaya çalışın. Genelde sadece <function>set_field_back()</function> ile artalanı ayarlarım. Curses tek tek renk özniteliklerinin doğrudan ayarlanmasını izin vermemektedir.
</para>
</sect3>

<sect3 xml:id="ncurses-howto-fieldoptionbits"><title>Alan Seçenek Bitleri</title>
<para>
Bunların yanında ayrıca form işlemenin pekçok yönünü kontrol etmenizi sağlayan geniş bir alan seçenekleri bit kümesi de bulunmaktadır. Şu işlevlerle bunları değiştirebilirsiniz:
</para><para>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>set_field_opts</command></funcdef><parameters>
<parameter>
  <paramdef>(FIELD *<emphasis>alan</emphasis>,</paramdef>
  <paramdesc>/* değiştirilecek alan */</paramdesc>
</parameter><parameter>
  <paramdef>int     <emphasis>öznitelik</emphasis>);</paramdef>
  <paramdesc>/* ayarlanacak öznitelik */</paramdesc>
</parameter></parameters>
</funcprototype></funcsynopsis>
</para><para>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>field_opts_on</command></funcdef><parameters>
<parameter>
  <paramdef>(FIELD *<emphasis>alan</emphasis>,</paramdef>
  <paramdesc>/* değiştirilecek alan */</paramdesc>
</parameter><parameter>
  <paramdef>int     <emphasis>öznitelik</emphasis>);</paramdef>
  <paramdesc>/* etkinleştirilecek öznitelik */</paramdesc>
</parameter></parameters>
</funcprototype></funcsynopsis>
</para><para>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>field_opts_off</command></funcdef><parameters>
<parameter>
  <paramdef>(FIELD *<emphasis>alan</emphasis>,</paramdef>
  <paramdesc>/* değiştirilecek alan */</paramdesc>
</parameter><parameter>
  <paramdef>int     <emphasis>öznitelik</emphasis>);</paramdef>
  <paramdesc>/* etkisizleştirilecek öznitelik */</paramdesc>
</parameter></parameters>
</funcprototype></funcsynopsis>
</para><para>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>field_opts</command></funcdef><parameters>
<parameter>
  <paramdef>(FIELD *<emphasis>alan</emphasis>);</paramdef>
  <paramdesc>/* sorgulanacak alan */</paramdesc>
</parameter></parameters>
</funcprototype></funcsynopsis>
</para><para>
<function>set_field_opts()</function> işlevi bir alanın özelliklerini değiştirmek için doğrudan kullanılabilir veya <function>field_opts_on()</function> ve <function>field_opts_off()</function> ile bazı özellikleri seçime göre etkinleştirebilir veya kapatabilirsiniz. Herhangi bir zamanda bir alanın özelliklerini <function>field_opts()</function> ile sorugulayabilirsiniz. Aşağıda kullanılabilir özellikler listesi bulunmaktadır. Öntanımlı olarak, tüm özellikler etkindir.
</para><para>
<variablelist>
<varlistentry><term>O_VISIBLE</term>
<listitem><para>
Alanın ekranda görünüp görünmediğini kontrol eder. Ana alanın özelliğine bağlı olarak form işleme sırasında alanları saklamak ya da göstermek için kullanılır.
</para></listitem></varlistentry>
<varlistentry><term>O_ACTIVE</term>
<listitem><para>
Form işleme sırasında alanın etkin olup olmadığını kontrol eder (örn. form gezinti tuşları tarafından ziyaret edilimiş mi?). Kullanıcı tarafından değil ama form uygulamasının kendisi tarafından değiştirilebilen önbellek değerleri ile türetilmiş alanlar veya etiketler yapmak için kullanılabilir.
</para></listitem></varlistentry>
<varlistentry><term>O_PUBLIC</term>
<listitem><para>
Alana veri girişi sırasında verinin gösterilip gösterilmediğini kontrol eder. Eğer bu seçenek bir alan için kapatılırsa kütüphane, alan içerisindeki verileri alıp düzenleyecek, fakat  veriler görülebilir olmayacak ve görünmesi gereken imleç de ilerlemeyecektir. Parola alanlarını tanımlamak için <literal>O_PUBLIC</literal> bitini kapatabilirsiniz.
</para></listitem></varlistentry>
<varlistentry><term>O_EDIT</term>
<listitem><para>
Bir alan verisinin değiştirilip değiştirilemeyeceğini kontrol eder. Bu özellik kapalı olduğunda, <literal>REQ_PREV_CHOICE</literal> ve <literal>REQ_NEXT_CHOICE</literal> dışındaki tüm düzenleme istekleri sekteye uğrayacaktır. Bu sadece okunabilir alanlarda yardım iletileri için faydalı olabilir.
</para></listitem></varlistentry>
<varlistentry><term>O_WRAP</term>
<listitem><para>
Çok satırlı alanlarda satırın sarmalanmasını sağlar. Normal çalışma şeklinde (boşluklarla ayrılmış) bir kelimenin herhangi bir karakteri o anki satırın sonuna geldiğinde, kelimenin tamamı bir sonraki satıra (yeni bir satır olduğunu varsayıyoruz) olduğu gibi taşınır. Bu seçenek etkisizleştirildiğinde satırsonu ile beraber kelime parçalanacaktır.
</para></listitem></varlistentry>
<varlistentry><term>O_BLANK</term>
<listitem><para>
Alanların boşaltılmasını kontrol eder. Bu seçenek etkin olduğunda, alanın ilk konumuna bir karakter girmek tüm alanı siler (hali hazırda var olan karakterler dışında).
</para></listitem></varlistentry>
<varlistentry><term>O_AUTOSKIP</term>
<listitem><para>
Alanın kendisi dolduğunda otomatik olarak sonraki alana atlamayı kontrol eder. Normalinde, form kullanıcısı alana alabileceğinden fazlasını yazmaya kalkarsa yazılanlar sonraki alana geçer. Bu seçenek etkisiz olduğunda kullanıcı imleci alanın sonunda ilerlemeden duracaktır. Bu özellik çalışma zamanında boyutları değişen alanlar için ihmal edilir.
</para></listitem></varlistentry>
<varlistentry><term>O_NULLOK</term>
<listitem><para>
Boş alanlara doğrulama yapılıp yapılmadığını kontrol eder. Normal olarak, bu yapılmaz; kullanıcı bir alanı boş bırakıp çıkabilir. Eğer bu seçenek bir özellik için etkisizse, alandan çıkarken doğrulama yapılır.
</para></listitem></varlistentry>
<varlistentry><term>O_PASSOK</term>
<listitem><para>
Alandaki odaklanmadan her ayrılmada doğrulama yapılacak mı yoksa sadece alan değiştiğinde mi bir doğrulama yapılacak diye kontrol eder. Normalinde sonuncusu doğrudur. <literal>O_PASSOK</literal>'u ayarlamak form işlemeniz sırasında eğer alanın doğrulama işlevi değişiyorsa faydalı olabilir.
</para></listitem></varlistentry>
<varlistentry><term>O_STATIC</term>
<listitem><para>
Alanın ilk boyutunda sabit olup olmadığını kontrol eder. Bu seçeneği etkisizleştirdiğinizde, alan çalışma zamanında değişken bir hal alır ve yazılan girdiye göre genişleyebilir bir özellik kazanır.
</para></listitem></varlistentry>
</variablelist>
</para><para>
Bir alanın özelliği o alan seçildiği anda değiştirilemez. Yine de, henüz seçilmemiş fakat ekranda gözüken alanların seçenekleri değiştirilebilir.
</para><para>
Seçenek değerleri bit maskeleridir ve açık şekilde, mantıksal VEYA kullanarak oluşturulabilir. <literal>O_AUTOSKIP</literal> değerinin etkisizleştirilmesini daha önce görmüştünüz. Aşağıdaki örnek birkaç seçeneğin daha kullanımını açıklamaktadır. Diğer seçenekler gerekli görüldüğü yerde açıklanmıştır.
</para>
<example xml:id="ncurses-howto-ffoop">
<title>Alan Özelliklerini Kullanım Örneği</title><para>
<programlisting>
#include &lt;form.h>

#define STARTX 15
#define STARTY 4
#define WIDTH 25

#define N_FIELDS 3

int main()
{ FIELD *field[N_FIELDS];
  FORM  *my_form;
  int ch, i;

  /* Curses kipini ilklendir */
  initscr();
  cbreak();
  noecho();
  keypad(stdscr, TRUE);

  /* Alanları ilklendir */
  for(i = 0; i &lt; N_FIELDS - 1; ++i)
    field[i] = new_field(1, WIDTH, STARTY + i * 2, STARTX, 0, 0);
  field[N_FIELDS - 1] = NULL;

  /* Alan özelliklerini ayarla */
  set_field_back(field[1], A_UNDERLINE);  /* Seçenek için bir satır yaz  */

  field_opts_off(field[0], O_ACTIVE); /* Bu alan durağan bir etiket */
  field_opts_off(field[1], O_PUBLIC); /* Bu alan bir parola alanı gibi*/
  field_opts_off(field[1], O_AUTOSKIP); /* Son karakter girildikten sonra */
                                        /* aynı alana girişi önlemek için */

  /* Alanı oluştur ve ekrana yaz */
  my_form = new_form(field);
  post_form(my_form);
  refresh();

  set_field_just(field[0], JUSTIFY_CENTER); /* Ortalama ayarı */
  set_field_buffer(field[0], 0, "Bu durağan bir alandır");
                                            /* Alanı ilklendir  */
  mvprintw(STARTY, STARTX - 10, "Alan 1:");
  mvprintw(STARTY + 2, STARTX - 10, "Alan 2:");
  refresh();

  /* Kullanıcıdan elen istekler için dögü */
  while((ch = getch()) != KEY_F(1))
  { switch(ch)
    { case KEY_DOWN:
        /* Sonraki alana git */
        form_driver(my_form, REQ_NEXT_FIELD);
        /* O anki önbelleğin sonuna git */
        /* Son karakterde döngüden çık */
        form_driver(my_form, REQ_END_LINE);
        break;
      case KEY_UP:
        /* Önceki alana git */
        form_driver(my_form, REQ_PREV_FIELD);
        form_driver(my_form, REQ_END_LINE);
        break;
      default:
        /* Eğer bu normal bir karakterse */
        /* Ekrana yazılır                                */
        form_driver(my_form, ch);
        break;
    }
  }

  /* Formu ekrandan sil ve tahsis edilen belleği geri ver */
  unpost_form(my_form);
  free_form(my_form);
  free_field(field[0]);
  free_field(field[1]);

  endwin();
  return 0;
}
</programlisting></para>
</example><para>
Bo örnek, işe yaramaz olsa da, seçeneklerin kullanımını göstermektedir. Eğer düzgün kullanılırsa, bir form içerisindeki bilgileri çok verimli şekilde gösterebilirler. <literal>O_PUBLIC</literal> olmayan ikinci alan yazdığınız karakterleri göstermez.
</para>
</sect3>

<sect3 xml:id="ncurses-howto-fieldstatus"><title>Alan Durumu</title>
<para>
Alan durumu alan üzerinde düzenleme yapılıp yapılmadığını söyler. Başlangıçta <literal>FALSE</literal> değerindedir. Kullanıcı bir takım veriler girdiğinde ve veri belleğini değiştirdiğinde <literal>TRUE</literal> değerini alır. Dolayısıyla bir alanın durum bilgisi, alan verisi üzerinde değişiklik yapılıp yapılmadığının kontrolü için kullanılabilir. Aşağıdaki işlevler bu türden işlemlere yardım edebilir:
</para><para>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>set_field_status</command></funcdef><parameters>
<parameter>
  <paramdef>(FIELD *<emphasis>alan</emphasis>,</paramdef>
  <paramdesc>/* değiştirilecek alan */</paramdesc>
</parameter><parameter>
  <paramdef>int     <emphasis>durum</emphasis>);</paramdef>
  <paramdesc>/* atanacak durum */</paramdesc>
</parameter></parameters>
</funcprototype></funcsynopsis>
</para><para>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>field_status</command></funcdef><parameters>
<parameter>
  <paramdef>(FIELD *<emphasis>alan</emphasis>);</paramdef>
  <paramdesc>/* sorgulanacak alan */</paramdesc>
</parameter><parameter>
  <paramdef></paramdef>
  <paramdesc>/* alanın durumu ile döner */</paramdesc>
</parameter></parameters>
</funcprototype></funcsynopsis>
</para><para>
Alanın durumunu alandan ayrılırken kontrol etmek, veri doğrulama halen devam ettiğinden ve veri önbelleği henüz değişmemiş olabileceğinden daha sağlıklıdır. Dönen doğru değeri almak için, alanın ayrılma ile ilgili kısmına veya alan veya formun ilklendirme veya sonlandırılma kısımlarında veya hemen form sürücüsü tarafından <literal>REQ_VALIDATION</literal> isteği işlendikten sonra <function>field_status()</function> çağrılmalıdır.
</para>
</sect3>

<sect3 xml:id="ncurses-howto-fielduserptr">
<title>Alan Kullanıcı Göstericisi</title><para>
Her alan yapısı kullanıcı tarafından değişik amaçlar için kullanılabilen bir gösterici içerir. Form kütüphanesi tarafından kullanılmaz ama kullanıcı tarafından herhangi bir amaç için kullanılabilir. Sıradaki işlevler kullanıcı göstericilerini ayarlar ve onları eşler.
</para><para>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>set_field_userptr</command></funcdef><parameters>
<parameter>
  <paramdef>(FIELD *<emphasis>alan</emphasis>,</paramdef>
  <paramdesc>/* değiştirilecek alan */</paramdesc>
</parameter><parameter>
  <paramdef>char   *<emphasis>kull_gost</emphasis>);</paramdef>
  <paramdesc>/* ilişiklendirilecek kullanıcı</paramdesc>
</parameter><parameter>
  <paramdef></paramdef><paramdesc>   göstericisi */</paramdesc>
</parameter></parameters>
</funcprototype></funcsynopsis>
</para><para>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>field_userptr</command></funcdef><parameters>
<parameter>
  <paramdef>(FIELD *<emphasis>alan</emphasis>);</paramdef>
  <paramdesc>/* sorgulanacak alan */</paramdesc>
</parameter><parameter>
  <paramdef></paramdef>
  <paramdesc>/* kullanıcı göstericisini döndürür */</paramdesc>
</parameter></parameters>
</funcprototype></funcsynopsis></para>
</sect3>

<sect3 xml:id="ncurses-howto-variablesizefields">
<title>Değişken Boydaki Alanlar</title><para>
Eğer çalışma zamanında değişken genişlikte bir alan istiyorsanız bu, tüm özellikleri ile kullanmanız gereken bir özelliktir. Bu, kullanıcının, asıl alan boyundan daha büyük değerler girmesini ve alanın büyümesini sağlar. Alan, yerleştirilme konumuna göre yeni girilen veriler ile bütünleşik olabilmek için yatay veya dikey kaydırılabilir olacaktır.
</para><para>
Bir alanın dinamik olarak büyümesini sağlamak için <literal>O_STATIC</literal> seçeneği etkisiz olmalıdır. Bu da,
</para><para>
<programlisting>
field_opts_off(field_pointer, O_STATIC);
</programlisting>
</para><para>
ile yapılabilir. Fakat bir alanın sonsuz boyda uzamasına izin vermek pek de tavsiye edilmez. Alanın genişleyebileceği en fazla büyüklüğü tanımlayabilirsiniz.
</para><para>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>set_max_field</command></funcdef><parameters>
<parameter>
  <paramdef>(FIELD *<emphasis>alan</emphasis>,</paramdef>
  <paramdesc>/* değiştirilecek alan */</paramdesc>
</parameter><parameter>
  <paramdef>char    <emphasis>azm_buy</emphasis>);</paramdef>
  <paramdesc>/* alan için olası azami büyüme miktarı */</paramdesc>
</parameter></parameters>
</funcprototype></funcsynopsis>
</para><para>
Dinamik olarak büyüyebilen bir alandan bilgiler şu şekilde alınabilir:
</para><para>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>dynamic_field_info</command></funcdef><parameters>
<parameter>
  <paramdef>(FIELD *<emphasis>alan</emphasis>,</paramdef>
  <paramdesc>/* değiştirilecek alan */</paramdesc>
</parameter><parameter>
  <paramdef>int    *<emphasis>sat_say</emphasis>,</paramdef>
  <paramdesc>/* sığdırılacak satır sayısı */</paramdesc>
</parameter><parameter>
  <paramdef>int    *<emphasis>sut_say</emphasis>,</paramdef>
  <paramdesc>/* sığdırılacak sütun sayısı */</paramdesc>
</parameter><parameter>
  <paramdef>int    *<emphasis>azm_buy</emphasis>);</paramdef>
  <paramdesc>/* sığdırılacak azami büyüme miktarı */</paramdesc>
</parameter></parameters>
</funcprototype></funcsynopsis>
</para><para>
<function>field_inf</function> bildik şekilde çalışmasına rağmen, çalışma zamanında genişleyen alanların özellikleri ile ilgili bilgileri bu işlevi kullanarak almanız tavsiye edilir.
</para><para>
<function>new_field</function> kütüphane yordamını hatırlayın; bir birim yüksekliğinde ve tek satırlık bir alan oluşturuluyordu. Bir birimden fazla yüksekliğe sahip alanlar çok satırlı alanlar olarak tanımlanacaklardır.
</para><para>
<literal>O_STATIC</literal> özelliği etkisizleştirilmiş tek satırlık bir alan tek bir sabit satır içerecektir, fakat sütun sayısı kullanıcının ilk alanın taşıyabileceğinden fazlasını girmesi durumunda artabilir. Görüntülenen alan sayısı sabit kalacak ve ilave veriler kaydırılabilir olacaktır.
</para><para>
Çok satırlı ve <literal>O_STATIC</literal> özelliği etksizleştrilmiş bir alan ise (çalışma zamanında genişleyebilen) sabit sayıda sütun içerecek, fakat satır sayısı alanın ilk tutabileceği değerden daha fazlası girilmesi durumunda artacaktır. Görüntülenen satır sayısı sabit olacak ve ilave veriler kaydırılabilir olacaktır.
</para><para>
Yukarıdaki iki paragraf çalışma zamanında genişleyen alanların davranış özellikleriyle ilgili oldukça açıklayıcıdır. Diğer form alanlarının davranış özellikleri aşağıda açıklanmıştır:
</para><para>
<orderedlist>
<listitem><para>
<literal>O_AUTOSKIP</literal> seçeneği eğer <literal>O_STATIC</literal> etkisiz ve alan için tanımlanmış azami büyüyebilme miktarı tanımlı değilse  gözardı edilecektir. Şu anda, kullanıcı alanın en sonuna gelip bir karakter yazdığında <literal>O_AUTOSKIP</literal> otomatik şekilde <literal>REQ_NEXT_FIELD</literal> form sürücüsü isteğini üretmektedir. En fazla büyüyebilme miktarı tanımlanmamış genişleyebilir bir alanda son karakter için bir konum yoktur. Eğer en fazla genişleme oranı tanımlanmışsa, <literal>O_AUTOSKIP</literal> seçeneği eğer alan en büyük değerine kadar genişlediyse normal çekilde çalışacaktır.
</para></listitem><listitem><para>
<literal>O_STATIC</literal> özelliği eğer etkisizse alan içerisinde hizalama gözardı edilecektir. Şu anda, <function>set_field_just</function> tek satıra <literal>JUSTIFY_LEFT, JUSTIFY_RIGHT, JUSTIFY_CENTER</literal> özellikleri kazandırmak için kullanılabilir. Genişleyebilir tek satırlık alan yatay olarak genişleyip kaydırılabilir ve hizalanabilen çok daha fazla veri içerebilir. <function>field_just</function>'ten geri dönen değer değişmemiş olacaktır.
</para></listitem><listitem><para>
Aşırı yüklenmiş form sürücü isteği <literal>REQ_NEW_LINE, O_NL_OVERLOAD</literal> form seçeneğinde <literal>O_STATIC</literal> değerinin etkisiz olmasına ve alan için en fazla genişleme miktarı tanımlanmamasına bakmaksızın aynı şekilde çalışır. Şu anda eğer <literal>O_NL_OVERLOAD</literal> etkinse, <literal>REQ_NEW_LINE</literal> eğer alanın son satırında çağrılırsa gizli olarak <literal>REQ_NEXT_FIELD</literal> üretir. Eğer bir alan sınırlara bağlı kalmadan genişleyebiliyorsa, son bir satır yoktur, <literal>REQ_NEW_LINE</literal> hiç bir zaman gizli olarak <literal>REQ_NEXT_FIELD</literal> üretmez. Eğer en fazla büyüme miktarı belirtilmişse ve <literal>O_NL_OVERLOAD</literal> form özelliği etkinse, eğer alan büyüyebileceği en büyük büyüklüğe gelmiş ve son satırda ise <literal>REQ_NEW_LINE</literal> sadece gizli olarak <literal>REQ_NEXT_FIELD</literal> üretecektir.
</para></listitem><listitem><para>
<function>dup_field</function> çağrısı bilindiği gibi çalışır; alanı o anki önbellek boyunu ve alanın içeriği ile ikileştirecektir. Belirtilmiş en fazla büyüme miktarı da ikileştirilecektir.
</para></listitem><listitem><para>
<function>link_field</function> bilindiği gibi çalışacaktır; O an bağlanan alan ile birlikte tüm alan özelliklerini ve paylaşılan önbelleği ikileştirecektir. Eğer <literal>O_STATIC</literal> alan seçeneği alanı paylaşımlı önbellek tarafından ardışıl olarak değiştirilirse, önbelleğin sahip olduğu veri miktarından fazlasının alana girilmesi durumunda nasıl davranış göstereceği o anki alanın özellik ayarına bağlıdır.
</para></listitem><listitem><para>
<function>field_info</function> bilindiği gibi çalışacaktır; <parameter>sat_say</parameter> değişkeni <function>new_field</function>'a yapılan asıl çağrının değerini tutacaktır. Kullanıcı o anki önbellek boyutunu sorgulamak için <function>dynamic_field_info</function>'yu kullanmalıdır.
</para></listitem></orderedlist>
</para><para>
Yukarıdakilerin bazıları sadece form sürücüsünden sonra açıklanınca anlam kazanmaktadır. Sonraki bir kaç kısımda buna bakıyor olacağız.
</para>
</sect3>
</sect2>

<sect2 userlevel="chunkthis" xml:id="ncurses-howto-formwindows">
<title>Form Pencereleri</title><para>
Form penceresi mantığı menü pencerelerinkine oldukça benzemektedir. Her bir form bir ana pencere ve alt pencere ile ilişiklendirilir. Ana pencere başlık, etiket, çerçeve veya kullanıcı her ne istiyorsa gösterir. Alt pencere ise tüm alanları içerir ve onları konumlarına göre gösterir. Bu durum hoş görüntüler üzerinde esnek şekilde değişiklik yapma imkanı verir.
</para><para>
Menü pencerelerine çok benzediğinden oldukça açıklamalı bir örnek sunuyorum. İşlevler aynıdır ve aynı şekilde çalışır.
</para>
<example xml:id="ncurses-howto-ffowi">
<title>Form Pencereleri Örneği</title><para>
<programlisting>
#include &lt;form.h>

void print_in_middle(WINDOW *win, int starty, int startx, int width,
     char *string, chtype color);

int main()
{
  FIELD *field[3];
  FORM  *my_form;
  WINDOW *my_form_win;
  int ch, rows, cols;

  /* Curses kipi ilklendir */
  initscr();
  start_color();
  cbreak();
  noecho();
  keypad(stdscr, TRUE);

  /* Renk çiftlerini ilklendir */
  init_pair(1, COLOR_RED, COLOR_BLACK);

  /* Alanları ilklendir */
  field[0] = new_field(1, 10, 6, 1, 0, 0);
  field[1] = new_field(1, 10, 8, 1, 0, 0);
  field[2] = NULL;

  /* alan seçeneklerini ayarla */
  set_field_back(field[0], A_UNDERLINE);
  field_opts_off(field[0], O_AUTOSKIP); /* Bu alan dolduğunda */
                                        /* sonraki alana geçme */
  set_field_back(field[1], A_UNDERLINE);
  field_opts_off(field[1], O_AUTOSKIP);

  /* Formu oluştur ve ekrana yaz */
  my_form = new_form(field);

  /* Form için gerekli alanı hesapla */
  scale_form(my_form, &amp;rows, &amp;cols);

  /* Form ile ilişiklendirilecek pencereyi oluştur */
  my_form_win = newwin(rows + 4, cols + 4, 4, 4);
  keypad(my_form_win, TRUE);

  /* Ana pencereyi ve alt pencereyi ata */
  set_form_win(my_form, my_form_win);
  set_form_sub(my_form, derwin(my_form_win, rows, cols, 2, 2));

  /* Ana pencere etrafında bir çerçeve çiz ve başlık yaz */
  box(my_form_win, 0, 0);
  print_in_middle(my_form_win, 1, 0, cols + 4,
    "Benim Formum", COLOR_PAIR(1));

  post_form(my_form);
  wrefresh(my_form_win);

  mvprintw(LINES - 2, 0,
    "YUKARI ve AŞAĞI ok tuşlarıyla alanlar arasında geçiş yapın");
  refresh();

  /* Kullanıcı istekleri için döngü */
  while((ch = wgetch(my_form_win)) != KEY_F(1))
  { switch(ch)
    { case KEY_DOWN:
        /* sonraki alana git */
        form_driver(my_form, REQ_NEXT_FIELD);
        /* O anki önbelleğin sonuna git */
        /* Son karakterde döngüden çık */
        form_driver(my_form, REQ_END_LINE);
        break;
      case KEY_UP:
        /* Önceki alana git */
        form_driver(my_form, REQ_PREV_FIELD);
        form_driver(my_form, REQ_END_LINE);
        break;
      default:
        /* Eğer bu normak bir karakterse */
        /* Ekrana yazılır                                */
        form_driver(my_form, ch);
        break;
    }
  }

  /* Ekrandan sil ve ayrılan bellek alanını geri ver */
  unpost_form(my_form);
  free_form(my_form);
  free_field(field[0]);
  free_field(field[1]);

  endwin();
  return 0;
}

void print_in_middle(WINDOW *win, int starty, int startx, int width,
     char *string, chtype color)
{ int length, x, y;
  float temp;

  if(win == NULL)
    win = stdscr;
  getyx(win, y, x);
  if(startx != 0)
    x = startx;
  if(starty != 0)
    y = starty;
  if(width == 0)
    width = 80;

  length = strlen(string);
  temp = (width - length)/ 2;
  x = startx + (int)temp;
  wattron(win, color);
  mvwprintw(win, y, x, "%s", string);
  wattroff(win, color);
  refresh();
}
</programlisting></para>
</example>
</sect2>

<sect2 userlevel="chunkthis" xml:id="ncurses-howto-filedvalidate">
<title>Alan Doğrulama</title><para>
Varsayılan olarak bir alan kullanıcıdan herhangi bir girdiyi kabul eder. Alana bir doğrulama özelliği ilintilemek mümkündür. Böylece kullanıcının alanı terk ederken alan içerisindeki veriler onaylanması gereken şekille eşleşmezse o zaman işlem sekteye uğrayacaktır. Bazı doğrulama türleri karakter seviyesinde alana her bir karakter girilirken gerçeklenmektedir.
</para><para>
Alana doğrulama özelliği aşağıdaki işlevlerle ilintilenebilir.
</para><para>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>set_field_type</command></funcdef><parameters>
<parameter>
  <paramdef>(FIELD   *<emphasis>alan</emphasis>,</paramdef>
  <paramdesc>/* değiştirilecek alan */</paramdesc>
</parameter><parameter>
  <paramdef>FIELDTYPE *<emphasis>alanozelligi</emphasis>,</paramdef>
  <paramdesc>/* ilintilenecek özellik */</paramdesc>
</parameter><parameter>
  <paramdef>...);</paramdef>
  <paramdesc>/* ilave değiştirgeler */</paramdesc>
</parameter></parameters>
</funcprototype></funcsynopsis>
</para><para>
Bir kere ayarlandıktan sonra bir alan için doğrulama türü şu şekilde sorgulanabilir:
</para><para>
<funcsynopsis><funcprototype role="işlev">
<funcdef>FIELDTYPE *<command>field_type</command></funcdef><parameters>
<parameter>
  <paramdef>(FIELD *<emphasis>alan</emphasis>);</paramdef>
  <paramdesc>/* sorgulanacak alan */</paramdesc>
</parameter></parameters>
</funcprototype></funcsynopsis>
</para><para>
Form sürücüsü bir alan içerisindeki veriyi sadece son kullanıcı tarafından girildiğinde doğrular.
</para><para>
<itemizedlist><listitem><para>
Uygulama programının kendisi <function>set_field_buffer</function> çağırarak alan değerini değiştirdiğinde ise doğrulama gerçeklenmez.
</para></listitem><listitem><para>
Birbirine bağlı alanlar dolaylı şekilde değiştirilir: Bağlı oldukları alanın değeri değiştirilir.
</para></listitem>
</itemizedlist>
</para><para>
Aşağıdakiler önceden tanımlanmış doğrulama türleridir. Kendiniz de yorucu ve biraz ustalık isteyen bir iş olmasına rağmen doğrulama türü tanımlayabilirsiniz.
</para><bridgehead>TYPE_ALPHA</bridgehead><para>
Bu alan türü alfabetik verileri kabul eder; boşluk, sayı, özel karakter olmayan (karakter girişi tarafından bu kontrol edilir). Şu şekilde ayarlanır:
</para><para>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>set_field_type</command></funcdef><parameters>
<parameter>
  <paramdef>(FIELD *<emphasis>alan</emphasis>,</paramdef>
  <paramdesc>/* değiştirilecek alan */</paramdesc>
</parameter><parameter>
  <paramdef><literal>TYPE_ALPHA</literal>,</paramdef>
  <paramdesc>/* ilişiklendirilecek tür */</paramdesc>
</parameter><parameter>
  <paramdef>int     <emphasis>genişlik</emphasis>);</paramdef>
  <paramdesc>/* alanın en fazla genişliği */</paramdesc>
</parameter></parameters>
</funcprototype><funcdescr><para>
<varname>genişlik</varname> değiştirgeleri veri için an az genişlik değerini ayarlar. Kullanıcının alandan veri girişini terk edebilmesi için en az bu ayarlanan değer genişliğinde veri girmesi gerekir. Tipik olarak bunu alan genişliği ile aynı ayarlamak isteyeceksiniz; eğer alan genişliğinden daha büyük olursa alan doğrulama sekteye uğrayacaktır. Değer olarak sıfır girilmesi ise alanın tamamlanmasını isteğe bağlı yapar.
</para></funcdescr></funcsynopsis>
</para><bridgehead>TYPE_ALNUM</bridgehead><para>
Bu alan türü alfabetik veriler ve sayılar kabul eder; boşluk ve özel karakterler (karakter girişi sırasında kontrol edilir) olmaz. Şu şekilde ayarlanır:
</para><para>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>set_field_type</command></funcdef><parameters>
<parameter>
  <paramdef>(FIELD *<emphasis>alan</emphasis>,</paramdef>
  <paramdesc>/* değiştirilecek alan */</paramdesc>
</parameter><parameter>
  <paramdef><literal>TYPE_ALNUM</literal>,</paramdef>
  <paramdesc>/* ilişiklendirilecek tür */</paramdesc>
</parameter><parameter>
  <paramdef>int     <emphasis>genişlik</emphasis>);</paramdef>
  <paramdesc>/* alanın en fazla genişliği */</paramdesc>
</parameter></parameters>
</funcprototype><funcdescr><para>
<varname>genişlik</varname> değiştirgeleri verinin en az genişliğini ayarlar. <literal>TYPE_ALPHA</literal> ile bunu alanın genişliği ile aynı yapmak isteyeceksiniz; eğer alanın genişliğinden daha büyük olursa doğrulama sekteye uğrar. Değeri sıfır olarak ayarlanırsa alanın tamamlanması isteğe bağlı hale gelir.
</para></funcdescr></funcsynopsis>
</para><bridgehead>TYPE_ENUM</bridgehead><para>
Bu tür bir ayarlama alan değerlerinin belli dizgelerden biri (örneğin, iki harfli posta kodu) olmasını zorunlu kılar. Şu şekilde ayarlanır:
</para><para>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>set_field_type</command></funcdef><parameters>
<parameter>
  <paramdef>(FIELD *<emphasis>alan</emphasis>,</paramdef>
  <paramdesc>/* değiştirilecek alan */</paramdesc>
</parameter><parameter>
  <paramdef><literal>TYPE_ENUM</literal>,</paramdef>
  <paramdesc>/* ilişiklendirilecek tür */</paramdesc>
</parameter><parameter>
  <paramdef>char  **<emphasis>değerlistesi</emphasis>,</paramdef>
  <paramdesc>/* olası değerlerin listesi */</paramdesc>
</parameter><parameter>
  <paramdef>int     <emphasis>buyukluk</emphasis>,</paramdef>
  <paramdesc>/* büyük küçük harf duyarlı mı? */</paramdesc>
</parameter><parameter>
  <paramdef>int     <emphasis>tekillik</emphasis>);</paramdef>
  <paramdesc>/* tekil olarak belirtilmeli mi? */</paramdesc>
</parameter></parameters>
</funcprototype><funcdescr><para>
<varname>değerlistesi</varname> değiştirgeleri NULL ile sonlanmış geçerli dizgeler listesini işaret etmelidir. <varname>buyukluk</varname> değişkeni dizge ile karşılaştırmayı büyük küçük harfe duyarlı hale getirir.
</para><para>
Kullanıcı <literal>TYPE_ENUM</literal> alanını terk ettiğinde, doğrulama işlemi önbellekteki veriyi geçerli bir girişe tamamlamaya çalışır. Tam bir dizge seçeneği girildiyse, elbette ki geçerlidir. Fakat aynı zamanda bir dizgenin öneklerini girmek te mümkündür, bu durumda kalanı tamamlanacaktır.
</para><para>
Öntanımlı olarak eğer böylesi bir önek girer ve bununla eşleşen birden fazla dizge listesi bulunursa, ilk eşlenen değere tamamlanır. Fakat eğer <varname>tekillik</varname> değeri mantıksal doğru ise, bu eşlenenin tekil olması zorunluluğunu getirir.
</para><para>
<literal>REQ_NEXT_CHOICE</literal> ve <literal>REQ_PREV_CHOICE</literal> girdi istekleri bu alanlar ile faydalı şekilde kullanılabilir.
</para></funcdescr></funcsynopsis>
</para><bridgehead>TYPE_INTEGER</bridgehead><para>
Bu alan türü bir tamsayı kabul eder. Şu şekilde ayarlanır:
</para><para>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>set_field_type</command></funcdef><parameters>
<parameter>
  <paramdef>(FIELD *<emphasis>alan</emphasis>,</paramdef>
  <paramdesc>/* değiştirilecek alan */</paramdesc>
</parameter><parameter>
  <paramdef><literal>TYPE_INTEGER</literal>,</paramdef>
  <paramdesc>/* ilişiklendirilecek tür */</paramdesc>
</parameter><parameter>
  <paramdef>char    <emphasis>adimlama</emphasis>,</paramdef>
  <paramdesc>/* sıfırlarla doldurulacak yer sayısı */</paramdesc>
</parameter><parameter>
  <paramdef>int     <emphasis>vmin</emphasis>,</paramdef>
  <paramdesc>/* geçerli aralık */</paramdesc>
</parameter><parameter>
  <paramdef>int     <emphasis>vmax</emphasis>);</paramdef>
  <paramdesc>/* geçerli aralık */</paramdesc>
</parameter></parameters>
</funcprototype><funcdescr><para>
Geçerli karakterler önlerinde eksi işareti olabilen sayılardır. Menzil kontrolü çıkış anında gerçeklenir. Eğer aralığın en büyük değeri en az değerden küçük veya eşitse aralık gözardı edilir.
</para><para>
Eğer değer aralık kontrolünü geçerse, <varname>adimlama</varname> değiştirgesindeki değere göre uygun sıfırlarla doldurma gerçeklenir.
</para><para>
<literal>TYPE_INTEGER</literal> değer önbelleği C kütüphanesindeki <link linkend="tr-man3-atoi">atoi(3)</link> işlevi ile uygun şekilde ifade edilebilir.
</para></funcdescr></funcsynopsis>
</para><bridgehead>TYPE_NUMERIC</bridgehead><para>
Bu alan türü 10 tabanında bir sayı kabul eder. Şu şekilde ayarlanır:
</para><para>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>set_field_type</command></funcdef>
<parameters>
<parameter>
  <paramdef>(FIELD *<emphasis>alan</emphasis>,</paramdef>
  <paramdesc>/* değiştirilecek alan */</paramdesc>
</parameter><parameter>
  <paramdef> <literal>TYPE_NUMERIC</literal>,</paramdef>
  <paramdesc>/* ilişiklendirilecek tür */</paramdesc>
</parameter><parameter>
  <paramdef> int    <emphasis>hassasiyet</emphasis>,</paramdef>
  <paramdesc>/* noktadan sonraki hassasiyet */</paramdesc>
</parameter><parameter>
  <paramdef> int    <emphasis>vmin</emphasis>,</paramdef>
  <paramdesc>/* geçerli aralık */</paramdesc>
</parameter><parameter>
  <paramdef> int    <emphasis>vmax</emphasis>);</paramdef>
  <paramdesc>/* geçerli aralık */</paramdesc>
</parameter></parameters>
</funcprototype><funcdescr><para>
Geçerli karakterle önlerinde eksi işareti de olabilen sayılardır. Muhtemelen bir de ondalık belirteci bir nokta vardır. Menzil kontrolü çıkışta kontrol edilir. Eğer aralığın en büyük değeri en küçük değerden küçük veya ona eşitse aralık gözardı edilir.
</para><para>
Eğer değer, aralık kontrolünü geçerse <varname>hassasiyet</varname> kısmındaki değere göre uygun olarak sağ taraf sıfırlarla doldurulur.
</para><para>
Bir <literal>TYPE_NUMERIC</literal> değeri C kütüphanesindeki <link linkend="tr-man3-atof">atof(3)</link> işlevi ile uygun şekilde ifade edilebilir.
</para></funcdescr></funcsynopsis></para>
<bridgehead>TYPE_REGEXP</bridgehead>
<para>
Bu alan düzenli ifadeler şeklinde yazılmış verileri kabul eder. Şu şekilde ayarlanır:
</para><para>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>set_field_type</command></funcdef><parameters>
<parameter>
  <paramdef>(FIELD *<emphasis>alan</emphasis>,</paramdef>
  <paramdesc>/* değiştirilecek alan */</paramdesc>
</parameter><parameter>
  <paramdef><literal>TYPE_REGEXP</literal>,</paramdef>
  <paramdesc>/* ilişiklendirilecek tür */</paramdesc>
</parameter><parameter>
  <paramdef>char   *<emphasis>duzifd</emphasis>);</paramdef>
  <paramdesc>/* eşleşecek ifade */</paramdesc>
</parameter></parameters>
</funcprototype><funcdescr><para>
Düzensiz ifade sözdizimi <link linkend="tr-man3-regcomp">regcomp(3)</link> işlevindeki ile aynıdır. Düzensiz ifadeyi kontrol etmek için kontrol, çıkış anında gerçeklenir.
</para></funcdescr></funcsynopsis>
</para>
</sect2>

<sect2 userlevel="chunkthis" xml:id="ncurses-howto-formdriver">
<title><function>form_driver</function>: Form sisteminin dolap beygiri</title>
<para>
Menü sisteminde olduğu gibi, <function>form_driver()</function> form sisteminde çok önemli bir rol oynamaktadır. Form sistemine yapılan tüm istekler <function>form_driver()</function>'dan süzülmek zorundadır.
</para><para>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>form_driver</command></funcdef><parameters>
<parameter>
  <paramdef>(FORM *<emphasis>form</emphasis>,</paramdef>
  <paramdesc>/* değiştirilecek form */</paramdesc>
</parameter><parameter>
  <paramdef>int    <emphasis>istek</emphasis>);</paramdef>
  <paramdesc>/* form istek kodu */</paramdesc>
</parameter></parameters>
</funcprototype></funcsynopsis>
</para><para>
Yukarıdaki örneklerin bazılarında da gördüğünüz gibi, bir döngü kurup kullanıcıdan gelen istekleri kontrol edip bunun bir veri mi yoksa kullanıcı isteği mi olduğuna karar vermeniz gerekir. Form istekleri daha sonra işlemi gerçeklemesi için <function>form_driver()</function>'a gönderilir.
</para><para>
İstekler kabaca şu alt sınıflara ayrılabilir. Değişik isteklerin kulanımları aşağıda açıklanmıştır:
</para>

<sect3 xml:id="ncurses-howto-pagenavreq">
<title>Sayfada Gezinti İstekleri</title><para>
Bu istekler form içerisinde sayfa bazında hareketlere sebep olur, form ekranının kayması sağlanır. Bir form pek çok sayfadan oluşmuş olabilir. Eğer çok sayıda alandan ve mantıksal bölümden oluşmuş büyük bir formunuz varsa onu sayfalara bölebilirsiniz.  <function>set_new_page()</function> belirtilen alanda yeni bir sayfa oluşturur.
</para><para>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>set_new_page</command></funcdef><parameters>
<parameter>
  <paramdef>(FIELD *<emphasis>alan</emphasis>,</paramdef>
  <paramdesc>/* değiştirilecek alan */</paramdesc>
</parameter><parameter>
  <paramdef>bool    <emphasis>sayfa_kesme</emphasis>);</paramdef>
  <paramdesc>/* sayfa kesmesi yapılacak mı? */</paramdesc>
</parameter></parameters>
</funcprototype></funcsynopsis>
</para><para>
Aşağıdaki istekler farklı sayfalara hareket etmenizi sağlar.
</para><para>
<itemizedlist>
<listitem><literal>REQ_NEXT_PAGE</literal> Sonraki form sayfasına hareket
</listitem>
<listitem><literal>REQ_PREV_PAGE</literal> Önceki form sayfasına hareket
</listitem>
<listitem><literal>REQ_FIRST_PAGE</literal> İlk form sayfasına hareket
</listitem>
<listitem><literal>REQ_LAST_PAGE</literal> Son form sayfasına hareket
</listitem>
</itemizedlist>
</para><para>
Bu istekler döngüsel şekilde liste üzerinde hareket eder; yani <literal>REQ_NEXT_PAGE</literal> son sayfadan sonra ilk sayfaya gider, <literal>REQ_PREV_PAGE</literal> ilk sayfadan sonra son sayfaya gider.
</para>
</sect3>

<sect3 xml:id="ncurses-howto-interfieldnavreq">
<title> Alan İçi Gezinti İstekleri</title><para>
Aynı sayfadaki alanlarda gezinti isteklerinde bunlar kullanılır:
</para><para>
<itemizedlist>
<listitem><literal>REQ_NEXT_FIELD</literal> Sonraki alana git
</listitem>
<listitem><literal>REQ_PREV_FIELD</literal> Önceki alana git
</listitem>
<listitem><literal>REQ_FIRST_FIELD</literal> İlk alana git
</listitem>
<listitem><literal>REQ_LAST_FIELD</literal>  Son alana git
</listitem>
<listitem><literal>REQ_SNEXT_FIELD</literal> Sıralanmış sonraki alana git
</listitem>
<listitem><literal>REQ_SPREV_FIELD</literal> Sıralanmış önceki alana git
</listitem>
<listitem><literal>REQ_SFIRST_FIELD</literal> Sıralanmış ilk alana git
</listitem>
<listitem><literal>REQ_SLAST_FIELD</literal> Sıralanmış son alana git
</listitem>
<listitem><literal>REQ_LEFT_FIELD</literal> Alanın soluna git
</listitem>
<listitem><literal>REQ_RIGHT_FIELD</literal> Alanın sağına git
</listitem>
<listitem><literal>REQ_UP_FIELD</literal> Alanın yukarısına git
</listitem>
<listitem><literal>REQ_DOWN_FIELD</literal> Alanın aşağısına git
</listitem>
</itemizedlist>
</para><para>
Bu istekler bir sayfadaki alan listesi üzerinde döngüsel şekilde işlenir; yani <literal>REQ_NEXT_FIELD</literal> son alandan sonra ilk alana döner, <literal>REQ_PREV_FIELD</literal> ilk alandan sonra son alana döner. Bunlar için (aynı zamanda <literal>REQ_FIRST_FIELD</literal> ve <literal>REQ_LAST_FIELD</literal>) alanların sırası form dizisindeki alan göstericisinin sırasıdır (<function>new_form()</function> veya <function>set_form_fields()</function> ile oluşturulmuştur).
</para><para>
Alanları ekranda görüntülendikleri şekilde soldan sağa ve yukarıdan aşağı gezmek de mümkündür. Bunu gerçeklemek için sıralanmış hareket listesinden ikinci guruptakileri kullanın.
</para><para>
Son olarak da alanlar arasında görsel yukarı, aşağı, sağ, sol yönlerini kullanarak gezinmek mümkündür. Bunu gerçeklemek için, üçüncü guruptaki dört isteği kullanın. Bir formun bu tür işler için başlangıcının sol üst köşesi olduğunu unutmayın.
</para><para>
Örneğin, çok satırlı bir B alanı, tek satırlı A ve C alanlarının aynı satırda A, B, C şeklinde sıralandığını düşünün. A alanından verilmiş <literal>REQ_MOVE_RIGHT</literal> isteği A, B ve C nin aynı satırı paylaşması halinde B alanına geçmeyi sağlayacaktır. Aksi halde B ve C alanlarını atlayacaktır.
</para>
</sect3>

<sect3 xml:id="ncurses-howto-intrafieldnavreq">
<title>Alan İçi Dahili Gezinti İstekleri</title><para>
Bu istekler o an düzenlenilen alan içerisinde imlecin hareketini sağlar.
</para><para>
<itemizedlist>
<listitem><literal>REQ_NEXT_CHAR</literal> Bir sonraki karaktere git</listitem>
<listitem><literal>REQ_PREV_CHAR</literal> Bir önceki karaktere git</listitem>
<listitem><literal>REQ_NEXT_LINE</literal> Bir sonraki satıra git</listitem>
<listitem><literal>REQ_PREV_LINE</literal> Bir önceki satıra git</listitem>
<listitem><literal>REQ_NEXT_WORD</literal> Bir sonraki kelimeye git</listitem>
<listitem><literal>REQ_PREV_WORD</literal> Bir önceki kelimeye git </listitem>
<listitem><literal>REQ_BEG_FIELD</literal> Alanın başına git</listitem>
<listitem><literal>REQ_END_FIELD</literal> Alanın sonuna git</listitem>
<listitem><literal>REQ_BEG_LINE</literal> Satır başına git</listitem>
<listitem><literal>REQ_END_LINE</literal> Satır sonuna git</listitem>
<listitem><literal>REQ_LEFT_CHAR</literal> Alan içerisinde sola git</listitem>
<listitem><literal>REQ_RIGHT_CHAR</literal> Alan içerisinde sağa git</listitem>
<listitem><literal>REQ_UP_CHAR</literal> Alan içerisinde yukarı git</listitem>
<listitem><literal>REQ_DOWN_CHAR</literal> Alan içerisinde aşağı git</listitem>
</itemizedlist>
</para><para>
Her kelime bir önceki bir sonraki kelimeler arasında boşluk karakteriyle ayrılır. Satır veya alanın başına ve sonuna gitmeye yarayan komutlar kendi menzilleri içerisindeki ilk veya son dolgu karakteri olmayan karakteri arar.
</para>
</sect3>

<sect3 xml:id="ncurses-howto-scrollreq">
<title>Kaydırma İstekleri</title><para>
Çalışma zamanında büyüyebilen ve açık şekilde ekranda görülmeyen satırlardan oluşmuş alanlar kaydırılabilir. Tek satırlık alanlar yatay olarak kaydırılır, çok satırlık alanlar dikey olarak kaydırılır. Pek çok kaydırma işlemi alan içi hareketlerle ve düzenleme ile başlatılır (kütüphane imleci görünür kılmak için alan içerisinde kaydırma işlemi gerçekler). Açık şekilde kaydırma işlemlerine istekte bulunmak aşağıdaki şekilde mümkündür:
</para><para>
<itemizedlist>
<listitem><literal>REQ_SCR_FLINE</literal> Bir satırın ilerisine dikey olarak kaydırma</listitem>
<listitem><literal>REQ_SCR_BLINE</literal> Bir satırın gerisine dikey olarak kaydırma</listitem>
<listitem><literal>REQ_SCR_FPAGE</literal> Bir sayfanın ilerisine dikey kaydırma</listitem>
<listitem><literal>REQ_SCR_BPAGE</literal> Bir sayfanın gerisine dikey olarak kaydırma</listitem>
<listitem><literal>REQ_SCR_FHPAGE</literal> Bir sayfanın yarısına ileri yönde dikey kaydırma</listitem>
<listitem><literal>REQ_SCR_BHPAGE</literal> Bir sayfanın yarısına geri yönde dikey kaydırma</listitem>
<listitem><literal>REQ_SCR_FCHAR</literal> Yatay olarak bir karakter ilerisine kaydırma</listitem>
<listitem><literal>REQ_SCR_BCHAR</literal> Yatay olarak bir karakter gerisine kaydırma</listitem>
<listitem><literal>REQ_SCR_HFLINE</literal> Yatay olarak bir alan ilerisine kaydırma</listitem>
<listitem><literal>REQ_SCR_HBLINE</literal> Yatay olarak bir alan gerisine kaydırma</listitem>
<listitem><literal>REQ_SCR_HFHALF</literal> Yatay olarak yarım alan ilerisine kaydırma</listitem>
<listitem><literal>REQ_SCR_HBHALF</literal> Yatay olarak yarım alan gerisine kaydırma</listitem>
</itemizedlist>
</para><para>
Kaydırma işlemleri için, bir alanın sayfası görünür kısmının yüksekliğidir.
</para>
</sect3>

<sect3 xml:id="ncurses-howto-editreq">
<title>İstekleri Düzenlemek</title><para>
Form sürücüsüne bir ASCII karakter gönderdiğiniz zaman, alan veri belleğine bir karakter eklemek için bir istek olarak algılanır. Bunun bir araya ekleme mi yoksa üzerine yazma mı olduğu alanın düzenleme kipine bağlıdır (varsayılan araya eklemedir).
</para><para>
Aşağıdaki istekler alanı düzenlemeyi ve düzenleme kipini değiştirmeyi sağlar:
</para><para>
<itemizedlist>
<listitem><literal>REQ_INS_MODE</literal> Araya ekleme kipini ayarla</listitem>
<listitem><literal>REQ_OVL_MODE</literal> Üzerine yazma kipini ayarla</listitem>
<listitem><literal>REQ_NEW_LINE</literal> Yeni satır isteği (açıklama için aşağıya bakınız)</listitem>
<listitem><literal>REQ_INS_CHAR</literal> Karakterin olduğu konuma boşluk yerleştir</listitem>
<listitem><literal>REQ_INS_LINE</literal> Karakterin olduğu konuma boş satır ekle</listitem>
<listitem><literal>REQ_DEL_CHAR</literal> İmlecin olduğu konumdaki karakteri sil</listitem>
<listitem><literal>REQ_DEL_PREV</literal> İmlecin olduğu konumdan önceki kelimeyi sil</listitem>
<listitem><literal>REQ_DEL_LINE</literal> İmlecin olduğu satırı sil</listitem>
<listitem><literal>REQ_DEL_WORD</literal> İmlecin olduğu konumdaki kelimeyi sil</listitem>
<listitem><literal>REQ_CLR_EOL</literal> Satırı sonuna kadar temizle </listitem>
<listitem><literal>REQ_CLR_EOF</literal> Alanı sonuna kadar temizle</listitem>
<listitem><literal>REQ_CLR_FIELD</literal> Alanın tüm içeriğini temizle</listitem>
</itemizedlist>
</para><para>
<literal>REQ_NEW_LINE</literal> ve <literal>REQ_DEL_PREV</literal> istekleri kısmen bazı form seçenek çiftleri tarafından kontrol edilen karmaşık isteklerdir. Özel durumlar imlecin alanın başında veya alanın sonunda olması durumunda etkin olur.
</para><para>
Önce <literal>REQ_NEW_LINE</literal> isteğini gözönüne alalım:
</para><para>
Araya ekleme kipinde <literal>REQ_NEW_LINE</literal>, halihazırdaki imlecin olduğu konumdan satırı keser, kalanı yeni bir satır olarak ekler ve imleci o satırın başına konumlandırır (bunu alan önbelleğine yeni satır eklemek olarak düşünebilirsiniz).
</para><para>
Üzerine yazma kipinde <literal>REQ_NEW_LINE</literal>, imlecin o an bulunduğu konumdan itibaren satırı satır sonuna kadar siler. Daha sonra imleç yeni satırın başına konumlanır.
</para><para>
Yine de alanın başında veya sonunda <literal>REQ_NEW_LINE</literal> aslında, <literal>REQ_NEXT_FIELD</literal> gerçekler. Bu özel durumun gerçekleşmesi için <literal>O_NL_OVERLOAD</literal> özelliği kapalı olmalıdır.
</para><para>
Şimdi de <literal>REQ_DEL_PREV</literal> isteğini ele alalım:
</para><para>
<literal>REQ_DEL_PREV</literal>'in normal davranışı bir önceki karakteri silmek şeklindedir. Eğer araya ekleme kipi açık, imleç satır başındaysa ve o satırdaki metin bir öncekine sığıyorsa, o anki satırın içeriğini bir öcnekinin sonuna ekler ve o anki satırı siler (bunu alan önbellek alanından bir satırın silinmesi olarak düşünebilirsiniz).
</para><para>
Aslında <literal>REQ_DEL_PREV</literal> alanın başında <literal>REQ_PREV_FIELD</literal> gibi davranır.
</para><para>
Eğer <literal>O_BS_OVERLOAD</literal> kapalıysa, bu özel davranış biçimi etkisizdir ve form sürücüsü sadece <literal>E_REQUEST_DENIED</literal> üretir.
</para>
</sect3>

<sect3 xml:id="ncurses-howto-orderreq">
<title>Emir İstekleri</title><para>
Eğer alanınızın türü emir türünde ve verilmiş bir türün sonraki ve önceki değerlerini almakla ilişkilendirilmiş işlevler içeriyorsa, alan ön belleğinde bu değeri eşleyecek istekler vardır:
</para><para>
<itemizedlist>
<listitem><literal>REQ_NEXT_CHOICE</literal> O anki değerden sonrakini önbelleğe yerleştir.
</listitem>
<listitem><literal>REQ_PREV_CHOICE</literal> O anki değerin öncekisini önbelleğe yerleştir.
</listitem>
</itemizedlist>
</para>
<para>
Yerleşik alan türleri için sadece <literal>TYPE_ENUM</literal>'un yerleşik önceki ve sonraki işlevleri vardır. Kendinize ait bir alan türü tanımlarsanız, kendi sıralama işlevlerinizi ilişiklendirebilirsiniz  (Özel Doğrulama Türleri'ne bakınız -- Ç.N.: belgede bulunamadı).
</para>
</sect3>

<sect3 xml:id="ncurses-howto-appliccommands">
<title>Uygulama Komutları</title><para>
<literal>KEY_MAX</literal>'tan büyük ve sabit <literal>MAX_COMMAND</literal>'den küçük veya eşit imleç değerleri üzerindeki form istekleri tamsayı olarak gösterilir. Bu sınır değerleri içerisindeki bir değer <function>form_driver()</function> tarafından ihmal edilir. Dolayısıyla bu, uygulama tarafından herhangi bir amaç için kullanılabilir. Uygulamaya özgü bir davranış olarak ele alınıp buna özgü bir davranış sergilenebilir.
</para>
</sect3>
</sect2>
</sect1>

<sect1 xml:id="ncurses-howto-tools">
<title>Araçlar ve Küçük Uygulama Kütüphaneleri</title><para>
Şimdiye kadar ncurses kütüphanesinin yeteklerini ve kardeş kütüphanelerini tanıdınız, ekranınızı göz doldurucu şekilde değiştirecek bir proje için heyecanla beklemektesinizdir. Fakat acele etmeyin. Karmaşık grafik arayüzleri tasarlamak ve onlar üzerinde çalışmak ek kütüphanelerle bile yalın ncurses içerisinde oldukça zor olmaktadır. Halihazırda kendi küçük uygulamalarınızı yazarken kullanabileceğiniz araçlar ve küçük uygulama kütüphaneleri bulunmaktadır. Bazılarını kullanabilirsiniz, kodlardan ilham almaya bakın, bazılarını genişletip kullanın.
</para>

<sect2 userlevel="chunkthis" xml:id="ncurses-howto-cdk">
<title>CDK Curses Geliştirme Kiti (Curses Development Kit)</title><para>
Yazarının sözleri şöyle:
</para><para><blockquote><para>
CDK, Curses Geliştirme Kiti anlamına gelir ve tam ekran curses program geliştirmesinin hızlı bir şekilde olmasını sağlayan 21 tane gereç içerir.
</para></blockquote></para><para>
Uygulama kümesi, programlarınızda doğrudan kullanabileceğiniz gereçler (widget) içermektedir. Oldukça güzel yazılmıştır ve belgelendirmesi de oldukça iyidir. Yeni başlayanlar için örnekler dizinindeki örnekler başlamak için iyi bir yer olabilir. CDK <link xlink:href="http://invisible-island.net/cdk/"/> adresinden indirilebilir. Yüklemek için README dosyasındaki adımları takip ediniz.
</para>

<sect3 xml:id="ncurses-howto-widgetlist"><title>Gereç Listesi</title><para>
Aşağıda CDK ile gelen gereçlerin listesi ve açıklamaları bulunmaktadır.
</para><para>
<variablelist><varlistentry><term><literal>Alphalist</literal></term>
<listitem><para>
Aranan kelimeyle ilgili ilk bir kaç karakterinin yazılmasıyla arama listesinin daraltılmasını sağlayabilme özelliği sayesinde kullanıcının bir listeden kelime seçmesini sağlar.
</para></listitem></varlistentry><varlistentry>
<term><literal>Buttonbox</literal></term><listitem><para>
Çok butonlu bir küçük programcık oluşturur.
</para></listitem></varlistentry><varlistentry>
<term><literal>Calendar</literal></term><listitem><para>
Küçük basit bir takvim programcığı oluşturur.
</para></listitem></varlistentry><varlistentry>
<term><literal>Dialog</literal></term><listitem><para>
Kullanıcıya bir ileti ile seçim hakkı verir, kullanıcı da sunulan düğmelerden bir tanesini seçer.
</para></listitem></varlistentry><varlistentry>
<term><literal>Entry</literal></term><listitem><para>
Kullanıcının değişik türlerde bilgi girmesini sağlar.
</para></listitem></varlistentry><varlistentry>
<term><literal>File Selector</literal></term><listitem><para>
CDK tabanlı küçük uygulamalardan oluşan bir dosya seçme  uygulamasıdır. Bu örnek, CDK gereç kütüphanesini  kullanarak daha karmaşık uygulamaların nasıl oluşturulacağını gösterir.
</para></listitem></varlistentry><varlistentry>
<term><literal>Graph</literal></term><listitem><para>
Bir grafik çizer.
</para></listitem></varlistentry><varlistentry>
<term><literal>Histogram</literal></term><listitem><para>
İstatistik grafiği çizer.
</para></listitem></varlistentry><varlistentry>
<term><literal>Item List</literal></term><listitem><para>
Kullanıcının ufak bir alandaki pek çok seçenek içerisinden birisini seçmesini sağlayan ekrana çıkagelen bir alan oluşturur. Haftanın günleri veya ay adları için çok kullanışlıdır.
</para></listitem></varlistentry><varlistentry>
<term><literal>Label</literal></term><listitem><para>
Ekrana çıkagelen bir kutu içerisinde iletileri gösterir veya etiket ekranın bir parçası olarak düşünebilir.
</para></listitem></varlistentry><varlistentry>
<term><literal>Marquee</literal></term><listitem><para>
Ekranda kayan bir ileti gösterir.
</para></listitem></varlistentry><varlistentry>
<term><literal>Matrix</literal></term><listitem><para>
Karmaşık bir matriksi pek çok seçeneklerle oluşturur.
</para></listitem></varlistentry><varlistentry>
<term><literal>Menu</literal></term><listitem><para>
Tıklayınca aşağı doğru açılan menu arayüzünü oluşturur.
</para></listitem></varlistentry><varlistentry>
<term><literal>Multiple Line Entry</literal></term><listitem><para>
Çok satırlı alan girişi. Uzun alanlar için oldukça kullanışlıdır (açıklama alanı gibi).
</para></listitem></varlistentry><varlistentry>
<term><literal>Radio List</literal></term><listitem><para>
Radyo düğmesi oluşturur.
</para></listitem></varlistentry><varlistentry>
<term><literal>Scale</literal></term><listitem><para>
Sayısal bir derecelendirme oluşturur. Kullanıcıdan sayısal bir değer alınmasını fakat bunun belli bir değerler alanı içerisinde sınırlı kalmasını sağlar.
</para></listitem></varlistentry><varlistentry>
<term><literal>Scrolling List</literal></term><listitem><para>
Kayan bir menü/liste oluşturur.
</para></listitem></varlistentry><varlistentry>
<term><literal>Scrolling Window</literal></term><listitem><para>
Kaydırılabilir bir günlük kayıt dosyası göstericisi oluşturur. Çalışırken içerisine bilgi girişi yapılabilir. Bir işlemin gelişimini göstermek için güzel bir küçük uygulamadır (konsol penceresine benzer).
</para></listitem></varlistentry><varlistentry>
<term><literal>Selection List</literal></term><listitem><para>
Çok seçenekli bir seçim listesi oluşturur.
</para></listitem></varlistentry><varlistentry>
<term><literal>Slider</literal></term><listitem><para>
Derecelendirme uygulamasına benzer, yan tarafta duran görsel bir çubukta sayısal değeri yansıtır.
</para></listitem></varlistentry><varlistentry>
<term><literal>Template</literal></term><listitem><para>
Karakterlerin bulunduğu konuma duyarlı bir giriş alanı oluşturur. Önceden biçimlenmiş tarih ve telefon numaraları gibi alanlar için kullanılır.
</para></listitem></varlistentry><varlistentry>
<term><literal>Viewer</literal></term><listitem><para>
Bu bir dosya/bilgi göstericisidir.   Çok fazla bilgiyi göstermek istediğinizde çok faydalıdır.
</para></listitem></varlistentry></variablelist>
</para><para>
Son sürümde bazı küçük uygulamalar Thomas Dickey tarafından değiştirilmiştir.
</para>
</sect3>

<sect3 xml:id="ncurses-howto-cdkattract">
<title>Bazı Çekici Özellikler</title><para>
Kullanışlı küçük gereçlerle hayatınızı daha kolay bir hale getirmesinin yanında CDK, hizalanmış ve çok renkli dizgeleri yazdırılma gibi can sıkıcı bir çok sorunu da zekice çözer. CDK işlevlerine dizge içerisine gömülmüş biçimlendirme etiketleri gönderilebilir. Örneğin;
</para><para>
eğer dizge şu şekildeyse,
</para>
<literallayout indent="0">
  "&lt;/B/1&gt;Bu satır sarı arka fon ve mavi ön fon rengine sahip olmalıdır.&lt;!1&gt;"
</literallayout>
<para>
ve bu değiştirge olarak <function>newCDKLabel()</function> işlevine verilirse, satırı sarı artalanlı ve mavi karakterli olarak yazar. Dizgeyi hizelemek, içerisine özel çizim karakterleri eklemek, v.b. için de başka özel etiketler mevcuttur. Lütfen ayrıntılar için <link linkend="tr-man3-cdk_display">cdk_display(3X)</link> kılavuz sayfasına bakınız. Kılavuz sayfası kullanışı hoş örneklerle açıklamaktadır.
</para>
</sect3>

<sect3 xml:id="ncurses-howto-cdkconclusion"><title>Sonuç</title>
<para>
Herşeyi hesaba katarsak, CDK gereçler içeren iyi yazılmış ve eğer uygun şekilde kullanılırsa karmaşık bir grafik arayüzün gelişiminin güçlü bir taslağını oluşturabilen bir pakettir.
</para>
</sect3>
</sect2>

<sect2 userlevel="chunkthis" xml:id="ncurses-howto-dialog">
<title><literal>dialog</literal> hakkında</title><para>
Uzun uzun yıllar önce, 1994 Eylülünde, çok az insanın Linux'u bildiği zamanlarda Jeff Tranter, Linux Journal'daki bir söyleşiden yola çıkarak <link xlink:href="http://www2.linuxjournal.com/lj-issues/issue5/2807.html">makalesini</link> yazdı. Makalesine şu sözlerle başlamıştır:
</para><para><blockquote><para>
Linux, Unix işletim sistemi temellidir, fakat çok sayıda kendine has ve kullanışlı çekirdek özellikleri ve uygulama programları sunmasıyla Unix altında edinilebilenden ötelere gitmiştir. Bilinen küçük bir tanesi "dialog" ismindeki profesonel görünümlü etkileşimli kutuları kabuk betikleriyle hazırlamaya yarayan uygulamasıdır. Bu makale giriş seviyesinde dialog uygulamasına bir ders niteliği taşımakta ve nerede ve nasıl kullanılabileceğini örneklerle göstermektedir.
</para></blockquote></para><para>
Açıklamasını sürdürdüğü sıralarda, dialog gerçekten de kolay şekilde profosyonel görünümlü etkileşimli kutular oluşturmak için kullanılabilecek bir uygulamaydı. Pek çok değişik etkileşimli kutular, menüler, işaretlenebilir listeler v.b. oluşturmaktaydı. Genelde öntanımlı olarak yükleniyordu. Değilse bile <link xlink:href="http://invisible-island.net/dialog/">Thomas Dickey</link>'in sayfasından indirebilirsiniz.
</para><para>
Yukarıda bahsedilen makale, uygulamaları ve onunla yapılabilecekler ilgili çok iyi bir ön bilgi vermektedir. Kılavuz sayfaları daha ayrıntılı bilgiye sahiptir. Pek çok değişik durumda kullanılabilir. Bir tanesi linux çekirdeğini metin kipinde yapılandırmadır. Linux çekirdeği, dialog uygulamasının ihtiyaçlarına göre uygun hale getirilmiş bir sürümünü kullanmaktadır.
</para><para>
Dialog ilk başlarda kabuk betikleri ile beraber kullanılmak için tasarlandı. Eğer onun özelliklerini bir C programında kullanmak isterseniz o zaman <filename>libdialog</filename>'u kullanın. Bununla ilgili belgelendirme biraz dağınıktır. En belirgin yardım alınabilecek nokta kütüphane ile beraber gelen <filename>dialog.h</filename> başlık dosyasıdır. Orada ve burada bazı kotarımları, isteğinizi almak için gerçeklemeniz gerekebilir. Kaynak kolay şekilde özelleştirilebilirdir. Kodunu değiştirerek onu pekçok değişik durumda kollandım.
</para>
</sect2>

<sect2 userlevel="chunkthis" xml:id="ncurses-howto-perlcurses">
<title>Perl Curses Modullleri: <literal>CURSES::FORM</literal> ve <literal>CURSES::WIDGETS</literal></title>
<para>
Curses'ın perl modülleri  <literal>Curses::Form</literal> ve <literal>Curses::Widgets</literal> Perl içerisinden curses kipine erişimi sağlar. Curses ve temel Perl yüklü ise bu modülleri  <link xlink:href="http://www.cpan.org/modules/01modules.index.html"> CPAN
Modül Sayfası</link>ndan edinebilirsiniz. Curses kategorisi içerisindeki üç zipli dosyayı indirin. Bir kere yükledikten sonra bu modülleri perl betikleri içerisinden diğer modüller gibi kullanabilirsiniz. Perl modülleri ile ilgili ayrıntılı bilgi için <literal>perlmod</literal> kılavuz sayfasına bakın. Yukarıdaki modüller iyi bir belgelendirme ve denemeniz için bir takım demo betiklerle beraber gelmektedir. Gereçler çok gelişmemiş olmasına rağmen bu modüller Perl içerisinden curses'a iyi bir şekilde erişimi sağlamaktadır.
</para><para>
Örneklerimin bazıları Anuradha Ratnaweera tarafından Perl hallerine dönüştürüldü ve <command>perl</command> dizini içerisinden alınabilir.
</para><para>
Daha fazla ayrıntı için <literal>Curses(3)</literal> , <literal>Curses::Form(3)</literal> ve <literal>Curses::Widgets(3)</literal> kılavuz sayfalarına bakınız. Bu sayfalar sadece yukarıdaki modüller yüklendikten sonra yüklenir.
</para>
</sect2>
</sect1>

<sect1 xml:id="ncurses-howto-justforfun"> <title>Sadece Eğlence İçin !!!</title>
<para>
Bu kısım eğlence olsun diye yazılmış bir kaç uygulamadan oluşmaktadır. Bunlar en iyi programlama tekniklerini ya da ncurses kütüphanesinin en iyi kullanım şekillerini göstermemektedir. Yeni başlayanlara birer fikir vermesi ve bu alana daha çok program eklemeleri için oluşturulmuşlardır. Eğer curses içerisinde bir iki hoş, basit program yazdıysanız ve onların da burada yer almasını istiyorsanız bana yazın.
</para>

<sect2 userlevel="chunkthis" xml:id="ncurses-howto-gameoflife">
<title>Hayat Oyunu</title><para>
Hayat Oyunu matematikteki bir mucize. <link xlink:href="http://www.math.com/students/wonders/life/life.html">Paul Callahan</link>'ın sözleriyle
</para><para>
<blockquote><para>
Hayat Oyunu (veya sadece Hayat) anlaşıldığı manada oyun değildir. Herhangi bir oynayıcı, kazanan ya da kaybeden yoktur. Parçalar bir kere başlangıç konumuna yerleştirildi mi kurallar sonra olacak herşeyi sonradan belirler. Herşeye rağmen, Hayat süprizlerle doludur! Pekçok durumda başlangıç konumuna dönmek (veya biçimine) imkansızdır veya gelecekte ne olacağını görmek. Keşfetmenin tek yolu oyunun kurallarını takip etmektir.
</para></blockquote>
</para><para>
Bu program basit bir ters U örüntüsü ile başlar ve hayatın nasıl mükemmel çalıştığını gösterir. Program içerisinde geliştirilecek pekçok oda vardır. Kullanıcıların kendi örüntülerini girmelerini veya bir dosyadan girdi almayı sağlayabilirsiniz. Pekçok değişiklikle oyunun kurallarını değiştirebilirsiniz. <link xlink:href="http://www.google.com">google</link>'da hayat oyunu hakkında ilginç sonuçlar için aramalar yapın.
</para><para>
<emphasis role="bold">Dosya Yolu:</emphasis> <filename>JustForFun/life.c</filename>
</para>
</sect2>

<sect2 userlevel="chunkthis" xml:id="ncurses-howto-magic">
<title>Sihirli Kare</title><para>
Sihirli Kare, başka bir matematiksel hayret veren sonuçlardan biridir. Anlaşılması çok kolay fakat yapması oldukça zordur. Sihirli karede her satır ve sütundaki sayıların toplamı eşittir. Köşegensel toplam dahi eşittir. Daha pekçok özel niteliklere sahiptir.
</para><para>
Bu program tek sırada sayılardan oluşan basit bir sihirli kare oluşturur.
</para><para>
<emphasis role="bold">Dosya Yolu:</emphasis> <filename>JustForFun/magic.c</filename>
</para>
</sect2>

<sect2 userlevel="chunkthis" xml:id="ncurses-howto-hanoi"> <title>Hanoi Kuleleri</title>
<para>
Meşhur Hanoi kulesi çözücüsü. Oyunun amacı en tepedeki askıdan sondakine kadar ortadakini geçici bir askı gibi kullanarak sıralamaktır. Herhangi bir zamanda büyük diski diğerinin üzerine yerleştirmeme hilesine dayanır.
</para><para>
<emphasis role="bold">Dosya Yolu:</emphasis> <filename>JustForFun/hanoi.c</filename>
</para>
</sect2>

<sect2 userlevel="chunkthis" xml:id="ncurses-howto-queens">
<title>Vezir Yerleştirme</title><para>
Meşhur N-Vezir sorusudur. N*N'lik bir satranç tahtasında hiç birisi birbirini tehdit etmeyecek şekilde N tane veziri yerleştirme amacına dayanır.
</para><para>
Basit bir geri dönüş tekniği kullanarak problemi çözer.
</para><para>
<emphasis role="bold">Dosya Yolu:</emphasis> <filename>JustForFun/queens.c</filename>
</para>
</sect2>

<sect2 userlevel="chunkthis" xml:id="ncurses-howto-shuffle"><title>Shuffle </title>
<para>
Eğer öldürecek zamanınız varsa eğlenceli bir oyundur.
</para><para>
<emphasis role="bold">Dosya Yolu:</emphasis> <filename>JustForFun/shuffle.c</filename>
</para>
</sect2>

<sect2 userlevel="chunkthis" xml:id="ncurses-howto-tt"> <title>Onparmak Eğitmeni</title>
<para>
Basit bir yazma yardımcısı. İhtiyaçtan daha çok kolay kullanımı için tasarladım. Eğer parmaklarınızı nasıl koyacağınızı biliyorsanız fakat pratik eksiğiniz varsa bu yardımcı olabilir.
</para><para>
<emphasis role="bold">Dosya Yolu:</emphasis> <filename>JustForFun/tt.c</filename>
</para>
</sect2>
</sect1>


<sect1 xml:id="ncurses-howto-ref"> <title>Kaynakça</title>
<para><itemizedlist>
<listitem>NCURSES kılavuz sayfaları</listitem>
<listitem>NCURSES SSS <ulink
url="http://invisible-island.net/ncurses/ncurses.faq.html"/>
</listitem><listitem>
Eric Raymond ve Zeyd M. Ben-Halim tarafından <link xlink:href="http://invisible-island.net/ncurses/ncurses-intro.html"/> adresinde bulunan NCURSES ile program yazma kılavuzu. Biraz eskidir. O belgeden ilham aldım, zaten bu NASIL belgesinin yapısı da asıl belgeyi takip etmektedir.
</listitem>
</itemizedlist>
</para></sect1>
</article>

