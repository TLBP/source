<?xml version="1.0" encoding="UTF-8"?>
<!-- ********************************************************************
       ceviri/linux-i386-boot-code-howto.xml
     ******************************************************************** -->
<article xml:id="linux-i386-boot-code-howto"
 xmlns="http://docbook.org/ns/docbook" version="5.0"
 xmlns:xlink="http://www.w3.org/1999/xlink" xml:lang="tr">
 <info>
  <title>Linux i386 Önyükleme Kodu NASIL</title>
  <authorgroup>
   <author>
    <personname>Feiyun Wang</personname>
   </author>
   <author role="translator">
    <personname>A.Kemal Ökmen</personname>
   </author>
  </authorgroup>
  <pubdate>Mart 2006</pubdate>
  <revhistory>
   <title>Bu çevirinin sürüm bilgileri:</title>
   <revision>
    <revnumber>1.0</revnumber>
    <date>Mart 2006</date>
    <authorinitials>akö</authorinitials>
    <revremark>İlk çeviri</revremark>
   </revision>
  </revhistory>
  <revhistory>
   <title>Özgün belgenin sürüm bilgileri:</title>
   <revision>
    <revnumber>1.0</revnumber>
    <date>2004-02-19</date>
    <authorinitials>FW</authorinitials>
    <revremark>İlk yayın, LDP tarafından gözden geçirildi</revremark>
   </revision>
   <revision>
    <revnumber>0.3.3</revnumber>
    <date>2004-01-23</date>
    <authorinitials>fyw</authorinitials>
    <revremark>decompress_kernel() ayrıntıları eklendi; LDP son gözden  geçirme hataları düzeltildi.
    </revremark>
   </revision>
   <revision>
    <revnumber>0.3</revnumber>
    <date>2003-12-07</date>
    <authorinitials>fyw</authorinitials>
    <revremark>SMP, GRUB ve LILO içerikleri eklendi; Düzeltme ve geliştirme.</revremark>
   </revision>
   <revision>
    <revnumber>0.2</revnumber>
    <date>2003-08-17</date>
    <authorinitials>fyw</authorinitials>
    <revremark>Linux 2.4.20'ya uyarlandı.</revremark>
   </revision>
   <revision>
    <revnumber>0.1</revnumber>
    <date>2003-04-20</date>
    <authorinitials>fyw</authorinitials>
    <revremark>DocBook XML biçimine dönüştürüldü.</revremark>
   </revision>
  </revhistory>
  <abstract>
   <para>
Bu belge Linux i386 önyükleme kodu için bir çalışma kılavuzu ve kaynak kod açıklamaları sunar. C-benzeri yalancı kaynak kod açıklamalarına ek olarak, çekirdek geliştirme ile ilgili araç silsilelerinin önemli notlarını ve belirtimlerini de sunar.
    </para>
   <para>
Aşağıdaki konularda yardımcı olmak için tasarlanmıştır:
    </para>
    <para>
    <simplelist>
     <member>
Çekirdek konusunda acemilerin Linux i386 önyükleme kodunu anlaması ve
    </member>
     <member>
Çekirdek konusunda tecrübelilerin Linux önyükleme işlemini hatırlamaları.
    </member>
    </simplelist>
   </para>
  </abstract>
  <legalnotice>
   <title>Yasal Açıklamalar</title>
   <para>
Bu belgenin, <emphasis>Linux i386 Önyükleme NASIL</emphasis> çevirisinin 1.0 sürümünün <emphasis role="bold">telif hakkı © 2006 <emphasis>A. Kemal Ökmen</emphasis>'e</emphasis>, özgün İngilizce sürümünün  <emphasis role="bold">telif hakkı © 2003, 2004 <emphasis>Feiyun Wang</emphasis>'a</emphasis> aittir. Bu belgeyi, Free Software Foundation tarafından yayınlanmış bulunan GNU Özgür Belgeleme Lisansının 1.2 ya da daha sonraki sürümünün koşullarına bağlı kalarak kopyalayabilir, dağıtabilir ve/veya değiştirebilirsiniz. Bu Lisansın bir kopyasını <link xlink:href="&gnu-licences;#FDL">GNU Özgür Belgelendirme Lisansı</link> başlıklı bölümde bulabilirsiniz.
  </para>
   <para>
BU BELGE "ÜCRETSİZ" OLARAK RUHSATLANDIĞI İÇİN, İÇERDİĞİ BİLGİLER İÇİN İLGİLİ KANUNLARIN İZİN VERDİĞİ ÖLÇÜDE HERHANGİ BİR GARANTİ VERİLMEMEKTEDİR. AKSİ YAZILI OLARAK BELİRTİLMEDİĞİ MÜDDETÇE TELİF HAKKI SAHİPLERİ VE/VEYA BAŞKA ŞAHISLAR BELGEYİ "OLDUĞU GİBİ", AŞİKAR VEYA ZIMNEN, SATILABİLİRLİĞİ VEYA HERHANGİ BİR AMACA UYGUNLUĞU DA DAHİL OLMAK ÜZERE HİÇBİR GARANTİ VERMEKSİZİN DAĞITMAKTADIRLAR. BİLGİNİN KALİTESİ İLE İLGİLİ TÜM SORUNLAR SİZE AİTTİR. HERHANGİ BİR HATALI BİLGİDEN DOLAYI DOĞABİLECEK OLAN BÜTÜN SERVİS, TAMİR VEYA DÜZELTME MASRAFLARI SİZE AİTTİR.
  </para>
   <para>
İLGİLİ KANUNUN İCBAR ETTİĞİ DURUMLAR VEYA YAZILI ANLAŞMA HARİCİNDE HERHANGİ BİR ŞEKİLDE TELİF HAKKI SAHİBİ VEYA YUKARIDA İZİN VERİLDİĞİ ŞEKİLDE BELGEYİ DEĞİŞTİREN VEYA YENİDEN DAĞITAN HERHANGİ BİR KİŞİ, BİLGİNİN KULLANIMI VEYA KULLANILAMAMASI (VEYA VERİ KAYBI OLUŞMASI, VERİNİN YANLIŞ HALE GELMESİ, SİZİN VEYA ÜÇÜNCÜ ŞAHISLARIN ZARARA UĞRAMASI VEYA BİLGİLERİN BAŞKA BİLGİLERLE UYUMSUZ OLMASI) YÜZÜNDEN OLUŞAN GENEL, ÖZEL, DOĞRUDAN YA DA DOLAYLI HERHANGİ BİR ZARARDAN, BÖYLE BİR TAZMİNAT TALEBİ TELİF HAKKI SAHİBİ VEYA İLGİLİ KİŞİYE BİLDİRİLMİŞ OLSA DAHİ, SORUMLU DEĞİLDİR.
  </para>
   <para>
Tüm telif hakları aksi özellikle belirtilmediği sürece sahibine aittir. Belge içinde geçen herhangi bir terim, bir ticari isim ya da kuruma itibar kazandırma olarak algılanmamalıdır. Bir ürün ya da markanın kullanılmış olması ona onay verildiği anlamında görülmemelidir.
  </para>
  </legalnotice>
 </info>
 <para role="only.html">Ek - <link xlink:href="&gnu-licences;#FDL">GNU Özgür Belgelendirme Lisansı</link></para>
 <sect1 xml:id="linux-i386-boot-code-howto-intro">
  <title>Giriş</title>
  <para>
Bu belge Linux i386 önyükleme kodu hakkında bir çalışma kılavuzu ve kaynak kod açıklamaları sunar. C-benzeri yalancı kaynak kod açıklamalarına ek olarak, çekirdek geliştirme ile ilgili araç silsilelerinin önemli notlarını ve belirtimlerini de sunar. Aşağıdaki konularda yardımcı olmak
 için tasarlanmıştır:
    </para>
  <para>
   <simplelist>
    <member>
Çekirdek konusunda acemilerin Linux i386 önyükleme kodunu anlaması ve
    </member>
    <member>
Çekirdek konusunda tecrübelilerin Linux önyükleme işlemini hatırlamaları.
    </member>
   </simplelist>
  </para>
  <para>
Bu belgede Linux 2.4.20 temel almıştır.
    </para>
  <para>
Bu belgenin proje sanalyöresi <link xlink:href="http://sf.linuxforum.net/projects/i386bc">China Linux Forum</link> tarafından sunulmaktadır. Belge ile ilgili çalışmalar ayrıca yazarın kişisel sanalyöresi <link xlink:href="http://www.geocities.com/feiyunw/linux/">Yahoo! GeoCities</link>'de bulunabilir.
    </para>
  <sect2 xml:id="linux-i386-boot-code-howto-credits">
   <title>Teşekkür</title>
   <para>
Kılavuzun çevirisi sırasında yardımlarını esirgemeyen <link xlink:href="http://members.comu.edu.tr/nyucel">Necdet Yücel</link>'e teşekkür ederim.
      </para>
  </sect2>
  <sect2 xml:id="linux-i386-boot-code-howto-feedback">
   <title>Geribildirim</title>
   <para>
Bu belge için geribildirim memnuniyetle karşılanır. Eklemelerinizi, yorumlarınızı ve eleştirilerinizi  gönderiniz.
      </para>
  </sect2>
  <sect2 xml:id="linux-i386-boot-code-howto-translations">
   <title>Çeviriler</title>
   <para>Özgün İngilizce belge ve Türkçe çevirisi.</para>
  </sect2>
 </sect1>
 <sect1 xml:id="linux-i386-boot-code-howto-makefiles">
  <title>Linux Makefile'lar</title>
  <para>
Linux kodunu incelemeden önce Linux'un nasıl oluşturulduğu, derlendiği ve bağlandığı konusunda bazı temel fikirlere sahip olmalıyız. Bunu en baştan başlayarak yapmanın bir yolu Linux makefile'ları anlamaktır. Çevrimiçi kaynak gösterimini tercih ediyorsanız <link xlink:href="http://lxr.linux.no/source?v=2.4.20">Cross-Referencing Linux</link> bağlantısını kontrol edin.
   </para>
  <sect2 xml:id="linux-i386-boot-code-howto-linux_makefile">
   <title>linux/Makefile</title>
   <para>
Bu üst seviye için bazı iyi bilinen makefile hedefleri şunlardır:
   </para>
   <variablelist>
    <varlistentry>
     <term>
      <literal>xconfig, menuconfig, config, oldconfig</literal>
     </term>
     <listitem>
      <para><filename>linux/.config</filename> çekirdek yapılandırma dosyasını üretir;
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>
      <literal>depend, dep</literal>
     </term>
     <listitem>
      <para>
alt dizinlerde <filename>linux/.depend</filename>, <filename>linux/.hdepend</filename> ve <filename>.depend</filename> gibi bağımlılık dosyalarını üretir;
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>
      <literal>vmlinux</literal>
     </term>
     <listitem>
      <para>
en önemli hedef olan <filename>linux/vmlinux</filename> yerleşik çekirdek görüntüsünü üretir;
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>
      <literal>modules, modules_install</literal>
     </term>
     <listitem>
      <para><filename>/lib/modules/$(KERNELRELEASE)</filename>içerisindeki modülleri üretir ve kurar;
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>
      <literal>tags</literal>
     </term>
     <listitem>
      <para><link xlink:href="http://vim.sourceforge.net">vim</link> ile kaynağın görüntülenmesi için <filename>linux/tags</filename> etiket dosyasını üretir.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <para><filename>linux/Makefile</filename> anahatları ile aşağıdaki gibidir:
   </para>
<screen>include .depend
include .config
include arch/i386/Makefile

vmlinux: linux/vmlinux üretir
        /* "stext" giriş noktası arch/i386/kernel/head.S dosyasında tanımlı*/
        $(LD) -T $(TOPDIR)/arch/i386/vmlinux.lds -e stext
        /* $(HEAD) */
        + from arch/i386/Makefile
                arch/i386/kernel/head.o
                arch/i386/kernel/init_task.o
        init/main.o
        init/version.o
        init/do_mounts.o
        --start-group
        /* $(CORE_FILES) */
        + from arch/i386/Makefile
                arch/i386/kernel/kernel.o
                arch/i386/mm/mm.o
        kernel/kernel.o
        mm/mm.o
        fs/fs.o
        ipc/ipc.o
        /* $(DRIVERS) */
        drivers/...
                char/char.o
                block/block.o
                misc/misc.o
                net/net.o
                media/media.o
                cdrom/driver.o
                and other static linked drivers
                + from arch/i386/Makefile
                        arch/i386/math-emu/math.o (ifdef CONFIG_MATH_EMULATION)
        /* $(NETWORKS) */
        net/network.o
        /* $(LIBS) */
        + from arch/i386/Makefile
                arch/i386/lib/lib.a
        lib/lib.a
        --end-group
        -o vmlinux
        $(NM) vmlinux | grep ... | sort &gt; System.map
tags: vim için linux/tags üretir
modules: modülleri üretir
modules_install: modülleri kurar
clean mrproper distclean: derlemenin yapıldığı dizini temizler
psdocs pdfdocs htmldocs mandocs: çekirdek belgelerini üretir

include Rules.make

rpm: bir rpm üretir
</screen>
   <para>
Burada <option>--start-group</option> ve <option>--end-group</option>, sembol referans sorununu çözmek için <command>ld</command> komut satırı seçenekleridir. Ayrıntılar için <link xlink:href="http://www.gnu.org/software/binutils/manual/ld-2.9.1/html_chapter/ld_2.html#SEC3">Using LD, the GNU linker: Command Line Options</link> belgesine başvurabilirsiniz.
      </para>
   <para><filename>Rules.make</filename> çoklu Makefile dosyaları için kurallar içerir.
   </para>
  </sect2>
  <sect2 xml:id="linux-i386-boot-code-howto-vmlinux.lds">
   <title>linux/arch/i386/vmlinux.lds</title>
   <para>
Derlemeden sonra <command>ld</command> birkaç nesne ve arşiv dosyasını biraraya getirir, verilerini yeniden yerleştirir ve sembol referansları bağlayıp kapatır. <filename>linux/arch/i386/vmlinux.lds</filename> dosyası <filename>linux/Makefile</filename> tarafından yerleşik çekirdek görüntüsü <filename>linux/vmlinux</filename> 'un ilintilenmesinde kullanılan ilintileyici betik olarak tasarlanmıştır.
    </para>
   <para>
<screen>/* i386 Linux çekirdeği oluşturmak için ld betiği
 * Martin Mares &lt;mj@atrey.karlin.mff.cuni.cz&gt; tarafından yazılmıştır;
 */
OUTPUT_FORMAT("elf32-i386", "elf32-i386", "elf32-i386")
OUTPUT_ARCH(i386)
/* "ENTRY" linux/Makefile içinde "-e stext" komut satırı seçeneği ile değiştirilir */
ENTRY(_start)
/* Çıktı dosyası (linux/vmlinux) yerleşimi.
 * Bakınız <link xlink:href="http://www.gnu.org/software/binutils/manual/ld-2.9.1/html_chapter/ld_3.html#SEC17">Using LD, the GNU linker: Specifying Output Sections</link> */
SECTIONS
{
/* Çıktı bölümü .text 3G+1M adresinden başlar.
 * Bakınız <link xlink:href="http://www.gnu.org/software/binutils/manual/ld-2.9.1/html_chapter/ld_3.html#SEC10">Using LD, the GNU linker: The Location Counter</link> */
  . = 0xC0000000 + 0x100000;
  _text = .;                    /* Metin ve salt okunur veri */
  .text : {
        *(.text)
        *(.fixup)
        *(.gnu.warning)
        } = 0x9090
/* Tahsis edilmemiş oyuklar 0x9090 ile doldurulur, örn. "NOP NOP" için opcode.
 * Bakınız <link xlink:href="http://www.gnu.org/software/binutils/manual/ld-2.9.1/html_chapter/ld_3.html#SEC21">Using LD, the GNU linker: Optional Section Attributes</link> */

  _etext = .;                   /* text bölümünün sonu */

  .rodata : { *(.rodata) *(.rodata.*) }
  .kstrtab : { *(.kstrtab) }

/* Sonraki 16 baytlık sınıra hizalandı.
 * Bakınız <link xlink:href="http://www.gnu.org/software/binutils/manual/ld-2.9.1/html_chapter/ld_3.html#SEC14">Using LD, the GNU linker: Arithmetic Functions</link> */
  . = ALIGN(16);                /* Olağandışılık tablosu */
  __start___ex_table = .;
  __ex_table : { *(__ex_table) }
  __stop___ex_table = .;

  __start___ksymtab = .;        /* Çekirdek sembol tablosu */
  __ksymtab : { *(__ksymtab) }
  __stop___ksymtab = .;

  .data : {                     /* Veri */
        *(.data)
        CONSTRUCTORS
        }
/* "CONSTRUCTORS" için bakınız:
 * <link xlink:href="http://www.gnu.org/software/binutils/manual/ld-2.9.1/html_chapter/ld_3.html#SEC26">Using LD, the GNU linker: Option Commands</link> */

  _edata = .;                   /* data bölümünün sonu */

  . = ALIGN(8192);              /* init_task */
  .data.init_task : { *(.data.init_task) }

  . = ALIGN(4096);              /* Init kodu ve veri */
  __init_begin = .;
  .text.init : { *(.text.init) }
  .data.init : { *(.data.init) }
  . = ALIGN(16);
  __setup_start = .;
  .setup.init : { *(.setup.init) }
  __setup_end = .;
  __initcall_start = .;
  .initcall.init : { *(.initcall.init) }
  __initcall_end = .;
  . = ALIGN(4096);
  __init_end = .;

  . = ALIGN(4096);
  .data.page_aligned : { *(.data.idt) }

  . = ALIGN(32);
  .data.cacheline_aligned : { *(.data.cacheline_aligned) }

  __bss_start = .;              /* BSS */
  .bss : {
        *(.bss)
        }
  _end = . ;

/* Çıktı bölümü /DISCARD/ son ilintileme çıktısına dahil edilmeyecektir.
 * Bakınız <link xlink:href="http://www.gnu.org/software/binutils/manual/ld-2.9.1/html_chapter/ld_3.html#SEC18">Using LD, the GNU linker: Section Definitions</link> */
  /* Çıkarılacak bölümler */
  /DISCARD/ : {
        *(.text.exit)
        *(.data.exit)
        *(.exitcall.exit)
        }

/* Aşağıdaki çıktı bölümleri 0. bellek konumuna adreslenmiştir.
 * Bakınız <link xlink:href="http://www.gnu.org/software/binutils/manual/ld-2.9.1/html_chapter/ld_3.html#SEC21">Using LD, the GNU linker: Optional Section Attributes</link> */
  /* Stab hata ayıklama bölümleri.  */
  .stab 0 : { *(.stab) }
  .stabstr 0 : { *(.stabstr) }
  .stab.excl 0 : { *(.stab.excl) }
  .stab.exclstr 0 : { *(.stab.exclstr) }
  .stab.index 0 : { *(.stab.index) }
  .stab.indexstr 0 : { *(.stab.indexstr) }
  .comment 0 : { *(.comment) }
}</screen>
   </para>
  </sect2>
  <sect2 xml:id="linux-i386-boot-code-howto-i386_makefile">
   <title>linux/arch/i386/Makefile</title>
   <para><filename>linux/arch/i386/Makefile</filename>, <filename>linux/Makefile</filename> tarafından i386'ya özel öğelerin ve kuralların sağlanması için dahil edilmiştir.
      </para>
   <para>
Aşağıdaki bütün hedefler linux/Makefile'ının <literal>vmlinux</literal> hedefine bağımlıdır. Bunlar, <filename>linux/arch/i386/boot/Makefile</filename> içinde bazı seçenekler ile ilgili hedefler oluşturarak yapılır.
   </para>
   <para>
    <table frame="all">
     <title>linux/arch/i386/Makefile içindeki hedefler</title>
     <tgroup cols="2">
      <colspec colwidth=".2"/>
      <colspec colwidth=".8"/>
      <thead>
       <row>
        <entry>Hedef</entry>
        <entry>Komut</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>zImage<footnote><para><literal>zImage</literal> mahlası: sıkıştırılmış;</para></footnote></entry>
        <entry>
         <command>@$(MAKE) -C arch/i386/boot zImage</command>
         <footnote>
          <para><option>-C</option> makefile'ları okumadan önce dizin değiştirmek için kullanılan bir <command>make</command> komut satırı seçeneğidir.
          </para>
          <para>
Bakınız <link xlink:href="http://www.gnu.org/software/make/manual/html_chapter/make_9.html#SEC102">GNU make: Summary of Options</link> ve <link xlink:href="http://www.gnu.org/software/make/manual/html_chapter/make_5.html#SEC58">GNU make: Recursive Use of make</link>.</para>
         </footnote>
        </entry>
       </row>
       <row>
        <entry>bzImage</entry>
        <entry>
         <command>@$(MAKE) -C arch/i386/boot bzImage</command>
        </entry>
       </row>
       <row>
        <entry>zlilo</entry>
        <entry>
         <command>@$(MAKE) -C arch/i386/boot BOOTIMAGE=zImage zlilo</command>
        </entry>
       </row>
       <row>
        <entry>bzlilo</entry>
        <entry>
         <command>@$(MAKE) -C arch/i386/boot BOOTIMAGE=bzImage zlilo</command>
        </entry>
       </row>
       <row>
        <entry>zdisk</entry>
        <entry>
         <command>@$(MAKE) -C arch/i386/boot BOOTIMAGE=zImage zdisk</command>
        </entry>
       </row>
       <row>
        <entry>bzdisk</entry>
        <entry>
         <command>@$(MAKE) -C arch/i386/boot BOOTIMAGE=bzImage zdisk</command>
        </entry>
       </row>
       <row>
        <entry>install</entry>
        <entry>
         <command>@$(MAKE) -C arch/i386/boot BOOTIMAGE=bzImage install</command>
        </entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </para>
   <para>
Bu makefile'ın <filename>linux/Makefile</filename> tarafından ihraç edilen bazı çevre değişkenlerini yeniden tanımlaması önemlidir. Özellikle:
      </para>
   <para>
<screen>OBJCOPY=$(CROSS_COMPILE)objcopy -O binary -R .note -R .comment -S</screen>
   </para>
   <para>
Etki, altdizindeki makefile'lara geçecek ve aracın davranışı değişecektir. <command>objcopy</command> komut satırı seçeneklerinin ayrıntıları için <link xlink:href="http://www.gnu.org/software/binutils/manual/html_chapter/binutils_3.html">GNU Binary Utilities: objcopy</link>'ye bakınız.
   </para>
   <para><literal>$(LIBS)</literal>'in niçin "$(TOPDIR)/arch/i386/lib/lib.a"'yı iki defa içerdiği belli değildir.
   </para>
   <para>
<screen>LIBS := $(TOPDIR)/arch/i386/lib/lib.a $(LIBS) $(TOPDIR)/arch/i386/lib/lib.a</screen>
   </para>
   <para>
Bazı araç dizileri ile ortaya çıkan ilintileme sorunları üzerinde çalıştırmak için olabilir.
   </para>
  </sect2>
  <sect2 xml:id="linux-i386-boot-code-howto-i386_boot_makefile">
   <title>linux/arch/i386/boot/Makefile</title>
   <para><filename>linux/arch/i386/boot/Makefile</filename> ne <filename>linux/arch/i386/Makefile</filename> içerisine ne de <filename>linux/Makefile</filename> içerisine dahil edilmediği için biraz daha bağımsızdır.
   </para>
   <para>
Bununla birlikte biraz ilişki vardır:
   </para>
   <simplelist>
    <member><filename>linux/Makefile</filename>: yerleşik çekirdek görüntüsü <filename>linux/vmlinux</filename>'u üretir;</member>
    <member><filename>linux/arch/i386/boot/Makefile</filename>: önyükleme kodunu üretir;</member>
    <member><filename>linux/arch/i386/Makefile</filename>: <filename>linux/vmlinux</filename>'un önyükleme kodu oluşturulmadan önce hazır olduğunu kontrol eder ve hedefleri <filename>linux/Makefile</filename>'a ihraç eder (<literal>bzImage</literal> gibi).</member>
   </simplelist>
   <para><literal>zdisk, zlilo</literal> veya <literal>zdisk</literal> hedefleri için gereken $(BOOTIMAGE) değeri <filename>linux/arch/i386/Makefile</filename>'dan gelir.
   </para>
   <para>
    <table frame="all">
     <title>linux/arch/i386/boot/Makefile içindeki hedefler</title>
     <tgroup cols="2">
      <colspec colwidth=".09"/>
      <colspec colwidth=".91"/>
      <thead>
       <row>
        <entry>Hedef</entry>
        <entry>Komut</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>zImage</entry>
        <entry>
<screen>$(OBJCOPY) compressed/vmlinux compressed/vmlinux.out
tools/build bootsect setup compressed/vmlinux.out $(ROOT_DEV) &gt; zImage
</screen>
        </entry>
       </row>
       <row>
        <entry>bzImage</entry>
        <entry>
<screen>$(OBJCOPY) compressed/bvmlinux compressed/bvmlinux.out
tools/build -b bbootsect bsetup compressed/bvmlinux.out $(ROOT_DEV) \
        &gt; bzImage
</screen>
        </entry>
       </row>
       <row>
        <entry>zdisk</entry>
        <entry>
<screen>dd bs=8192 if=$(BOOTIMAGE) of=/dev/fd0</screen>
        </entry>
       </row>
       <row>
        <entry>zlilo</entry>
        <entry>
<screen>if [ -f $(INSTALL_PATH)/vmlinuz ]; then mv $(INSTALL_PATH)/vmlinuz
        $(INSTALL_PATH)/vmlinuz.old; fi
if [ -f $(INSTALL_PATH)/System.map ]; then mv $(INSTALL_PATH)/System.map
        $(INSTALL_PATH)/System.old; fi
cat $(BOOTIMAGE) &gt; $(INSTALL_PATH)/vmlinuz
cp $(TOPDIR)/System.map $(INSTALL_PATH)/
if [ -x /sbin/lilo ]; then /sbin/lilo; else /etc/lilo/install; fi
</screen>
        </entry>
       </row>
       <row>
        <entry>install</entry>
        <entry>
<screen>sh -x ./install.sh $(KERNELRELEASE) $(BOOTIMAGE) $(TOPDIR)/System.map
        "$(INSTALL_PATH)"
</screen>
        </entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </para>
   <para><command>tools/build</command> {bootsect, setup, compressed/vmlinux.out}'dan <literal>zImage</literal>'ı veya <literal>{bbootsect, bsetup, compressed/bvmlinux,out}</literal>'dan <literal>bzImage</literal>'ı derler. <filename>linux/Makefile "export ROOT_DEV = CURRENT"</filename>. Dikkat ederseniz <literal>$(OBJCOPY)</literal> <xref linkend="linux-i386-boot-code-howto-i386_makefile"/> içerisindeki <filename>linux/arch/i386/Makefile</filename> tarafından yeniden tanımlanmıştır.
    </para>
    <table frame="all">
     <title>linux/arch/i386/boot/Makefile içindeki hedeflerin desteklenmesi</title>
     <tgroup cols="2">
      <colspec colwidth=".5"/>
      <colspec colwidth=".5"/>
      <thead>
       <row>
        <entry>Hedef: Öngereksinimler</entry>
        <entry>Komut</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>
         <literal>compressed/vmlinux: linux/vmlinux</literal>
        </entry>
        <entry>
         <command>@$(MAKE) -C compressed vmlinux</command>
        </entry>
       </row>
       <row>
        <entry>
         <literal>compressed/bvmlinux: linux/vmlinux</literal>
        </entry>
        <entry>
         <command>@$(MAKE) -C compressed bvmlinux</command>
        </entry>
       </row>
       <row>
        <entry>
         <literal>tools/build: tools/build.c</literal>
        </entry>
        <entry>
         <command>$(HOSTCC) $(HOSTCFLAGS) -o $@ $&lt; -I$(TOPDIR)/include</command>
         <footnote>
          <para>"$@" hedef anlamındadır, "$&lt;" ilk öngereksinim anlamındadır; Bakınız <link xlink:href="http://www.gnu.org/software/make/manual/html_chapter/make_10.html#SEC111">GNU make: Automatic Variables</link>;</para>
         </footnote>
        </entry>
       </row>
       <row>
        <entry>
         <literal>bootsect: bootsect.o</literal>
        </entry>
        <entry>
         <command>$(LD) -Ttext 0x0 -s --oformat binary bootsect.o</command>
         <footnote>
          <para><option>--oformat binary</option> çalıştırılabilirin bellek dökümüne eşdeğer bir ham ikilik çıktı arar; Bakınız <link xlink:href="http://www.gnu.org/software/binutils/manual/ld-2.9.1/html_chapter/ld_2.html#SEC3">Using LD, the GNU linker: Command Line Options</link>.</para>
         </footnote>
        </entry>
       </row>
       <row>
        <entry>
         <literal>bootsect.o: bootsect.s</literal>
        </entry>
        <entry>
         <command>$(AS) -o $@ $&lt;</command>
        </entry>
       </row>
       <row>
        <entry>
         <literal>bootsect.s: bootsect.S ...</literal>
        </entry>
        <entry>
         <command>$(CPP) $(CPPFLAGS) -traditional $(SVGA_MODE) $(RAMDISK) $&lt; -o $@</command>
        </entry>
       </row>
       <row>
        <entry>
         <literal>bbootsect: bbootsect.o</literal>
        </entry>
        <entry>
         <command>$(LD) -Ttext 0x0 -s --oformat binary $&lt; -o $@</command>
        </entry>
       </row>
       <row>
        <entry>
         <literal>bbootsect.o: bbootsect.s</literal>
        </entry>
        <entry>
         <command>$(AS) -o $@ $&lt;</command>
        </entry>
       </row>
       <row>
        <entry>
         <literal>bbootsect.s: bootsect.S ...</literal>
        </entry>
        <entry>
         <command>$(CPP) $(CPPFLAGS) -D__BIG_KERNEL__ -traditional $(SVGA_MODE) $(RAMDISK) $&lt; -o $@</command>
        </entry>
       </row>
       <row>
        <entry>
         <literal>setup: setup.o</literal>
        </entry>
        <entry>
         <command>$(LD) -Ttext 0x0 -s --oformat binary -e begtext -o $@ $&lt;</command>
        </entry>
       </row>
       <row>
        <entry>
         <literal>setup.o: setup.s</literal>
        </entry>
        <entry>
         <command>$(AS) -o $@ $&lt;</command>
        </entry>
       </row>
       <row>
        <entry>
         <literal>setup.s: setup.S video.S ...</literal>
        </entry>
        <entry>
         <command>$(CPP) $(CPPFLAGS) -D__ASSEMBLY__ -traditional $(SVGA_MODE) $(RAMDISK) $&lt; -o $@</command>
        </entry>
       </row>
       <row>
        <entry>
         <literal>bsetup: bsetup.o</literal>
        </entry>
        <entry>
         <command>$(LD) -Ttext 0x0 -s --oformat binary -e begtext -o $@ $&lt;</command>
        </entry>
       </row>
       <row>
        <entry>
         <literal>bsetup.o: bsetup.s</literal>
        </entry>
        <entry>
         <command>$(AS) -o $@ $&lt;</command>
        </entry>
       </row>
       <row>
        <entry>
         <literal>bsetup.s: setup.S video.S ...</literal>
        </entry>
        <entry>
         <command>$(CPP) $(CPPFLAGS) -D__BIG_KERNEL__ -D__ASSEMBLY__ -traditional $(SVGA_MODE) $(RAMDISK) $&lt; -o $@</command>
        </entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   <para>
Dikkat ederseniz <filename>bootsect.S</filename> <filename>bbootsect.s</filename>'ye ve <filename>setup.S</filename> <filename>bsetup.s</filename>'ye derlendiğinde <option>-D__BIG_KERNEL__</option>'e sahipti. Bunların kodları Yerden Bağımsız Kod (Place Independent Code - PIC) olmalı, bu durumda <option>-Ttext</option> seçeneğinin ne yaptığının önemi yoktur.
   </para>
  </sect2>
  <sect2 xml:id="linux-i386-boot-code-howto-i386_boot_compressed_makefile">
   <title>linux/arch/i386/boot/compressed/Makefile</title>
   <para>
Bu dosya görüntüsünün sıkıştırılıp çözülmesi mekanizmasını yerine getirir.
   </para>
   <para>
Sıkıştırma/çözmeyi önyükleme kodundan ayırmak iyidir. Bu böl-ve-yönet çözümü bizim sıkıştırma/çözme mekanizmasını kolayca geliştirmemize veya yeni bir önyükleme yöntemi uyarlamamıza imkan sağlar.
   </para>
   <para><filename>linux/arch/i386/boot/compressed/</filename> dizini <filename>head.S</filename> ve <filename>misc.c</filename> dosyalarını içerir.
   </para>
    <table frame="all">
     <title>linux/arch/i386/boot/compressed/Makefile içindeki hedefler</title>
     <tgroup cols="2">
      <colspec colwidth=".15"/>
      <colspec colwidth=".85"/>
      <thead>
       <row>
        <entry>Hedef</entry>
        <entry>Komut</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>
         <literal>vmlinux</literal>
         <footnote>
          <para>Hedef <literal>vmlinux</literal> burada <filename>linux/Makefile</filename> içinde tanımlanana göre değişiktir;</para>
         </footnote>
        </entry>
        <entry>
         <command>$(LD) -Ttext 0x1000 -e startup_32 -o vmlinux head.o misc.o piggy.o</command>
        </entry>
       </row>
       <row>
        <entry>
         <literal>bvmlinux</literal>
        </entry>
        <entry>
         <command>$(LD) -Ttext 0x100000 -e startup_32 -o bvmlinux head.o misc.o piggy.o</command>
        </entry>
       </row>
       <row>
        <entry>
         <literal>head.o</literal>
        </entry>
        <entry>
         <command>$(CC) $(AFLAGS) -traditional -c head.S</command>
        </entry>
       </row>
       <row>
        <entry>
         <literal>misc.o</literal>
        </entry>
        <entry>
<screen>$(CC) $(CFLAGS) ¬
  -DKBUILD_BASENAME=$(subst $(comma),_,$(subst -,_,$(*F))) ¬
  -c misc.c<footnote><para>"subst" bir MAKE işlevidir; Bakınız <link xlink:href="http://www.gnu.org/software/make/manual/html_chapter/make_8.html#SEC85">GNU make: Functions for String Substitution and Analysis</link>.</para></footnote>
</screen>
        </entry>
       </row>
       <row>
        <entry>
         <literal>piggy.o</literal>
        </entry>
        <entry>
<screen>tmppiggy=_tmp_$$$$piggy; \
rm -f $$tmppiggy $$tmppiggy.gz $$tmppiggy.lnk; \
$(OBJCOPY) $(SYSTEM) $$tmppiggy; \
gzip -f -9 &lt; $$tmppiggy &gt; $$tmppiggy.gz; \
echo "SECTIONS { .data : { input_len = .; \
        LONG(input_data_end - input_data) input_data = .; \
        *(.data) input_data_end = .; }}" &gt; $$tmppiggy.lnk; \
$(LD) -r -o piggy.o -b binary $$tmppiggy.gz -b elf32-i386 \
        -T $$tmppiggy.lnk; \
rm -f $$tmppiggy $$tmppiggy.gz $$tmppiggy.lnk
</screen>
        </entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   <para><filename>piggy.o</filename><literal>input_len</literal> değişkeninini ve gzip ile sıkıştırılmış <filename>linux/vmlinux'ı içerir. </filename><literal>input_len</literal> <filename>piggy.o</filename>'nun başında yer alır ve <literal>input_len</literal>'in kendisi hariç <filename>piggy.o</filename>'nun boyutuna eşittir. <literal>piggy.o</literal> bağlayıcı betiğinde geniş açıklamalar için bakınız <link xlink:href="http://www.gnu.org/software/binutils/manual/ld-2.9.1/html_chapter/ld_3.html#SEC20">Using LD, the GNU linker: Section Data Expressions</link>.
  </para>
   <para>
Tam olarak söylemek gerekirse <command>objcopy</command> tarafından üretilen gzip ile sıkıştırılmış olan <filename>linux/vmlinux</filename>'un kendisi (ELF biçiminde) değil onun ikili görüntüsüdür. Dikkat ederseniz <filename>$(OBJCOPY), linux/arch/i386/Makefile</filename> <xref linkend="linux-i386-boot-code-howto-i386_makefile"/> içerisinde <option>-O binary</option> seçeneğini kullanarak ham ikili çıktı almak için yeniden tanımlanmıştır.
   </para>
   <para><literal>{bootsect, setup}</literal> veya <literal>{bbootsect, bsetup}</literal> bağlandığı zaman, <literal>$(LD)</literal> onların ikili biçimde çıktı alınması için <option>--oformat binary</option> seçeneğini belirtir. <literal>zImage</literal> (veya <literal>bzImage</literal>) yapıldığında, $(OBJCOPY) <literal>compressed/vmlinux</literal> (veya <literal>compressed/bvmlinux</literal>)'dan da bir ara ikili çıktı üretir. <literal>zImage</literal> veya <literal>bzImage</literal>'ın tüm bileşenlerinin ham ikili biçimde olması görüntünün kendi kendini bir yükleyiciye başvurmadan yükleyebilmesi ve yerleştirebilmesi için elzemdir.
   </para>
   <para>
Hem <literal>vmlinux</literal> hem de <literal>bvmlinux</literal> <filename>head.o</filename> ve <filename>misc.o</filename>'yu <filename>piggy.o</filename>'dan önce hazırlar, fakat farklı başlangıç adreslerine (0x1000 ve 0x100000) bağlanırlar.
   </para>
  </sect2>
  <sect2 xml:id="linux-i386-boot-code-howto-i386_tools_build.c">
   <title>linux/arch/i386/tools/build.c</title>
   <para><filename>linux/arch/i386/tools/build.c</filename><literal>zImage</literal> veya <literal>bzImage</literal> üretmek için konak aracıdır.
   </para>
   <para><filename>linux/arch/i386/boot/Makefile</filename> içinde:
   </para>
<screen>tools/build bootsect setup compressed/vmlinux.out $(ROOT_DEV) &gt; zImage

tools/build -b bbootsect bsetup compressed/bvmlinux.out $(ROOT_DEV) &gt; bzImage</screen>
   <para><option>-b</option> büyük_çekirdek_mi (is_big_kernel) anlamındadır, sistem görüntüsünün çok büyük olup olmadığını kontrol eder.
   </para>
   <para><command>tools/build</command> aşağıdaki <literal>zImage</literal> veya <literal>bzImage</literal>'a yeniden yönlendirilen çıktıları standart çıktı birimine verir:
   </para>
   <orderedlist>
    <listitem>
     <para>
      <literal>bootsect</literal> veya <literal>bbootsect</literal>: <filename>linux/arch/i386/boot/bootsect.S</filename>'dan, 512 bytes;
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>setup</literal> veya <literal>bsetup</literal>: <filename>linux/arch/i386/boot/setup.S</filename>'den, 4 sektör veya daha fazla, sektör hizalı;
     </para>
    </listitem>
    <listitem>
     <para>
aşağıdakileri de içeren, <literal>compressed/vmlinux.out</literal> veya <literal>compressed/bvmlinux.out</literal>:
     </para>
     <orderedlist>
      <listitem>
       <para>
        <filename>head.o: linux/arch/i386/boot/compressed/head.S</filename> dosyasından;
       </para>
      </listitem>
      <listitem>
       <para>
       <filename>misc.o: linux/arch/i386/boot/compressed/misc.c</filename> dosyasından;
       </para>
      </listitem>
      <listitem>
       <para>
       <literal>piggy.o: input_len</literal> ve gzip'li <filename>linux/vmlinux</filename> dosyasından.
       </para>
      </listitem>
     </orderedlist>
    </listitem>
   </orderedlist>
   <para><command>tools/build</command> standart çıktıya yazarken <literal>bootsect</literal> veya <literal>bbootsect</literal>'ın bazı içeriklerini değiştirecektir:
   </para>
    <table frame="all">
     <title>tools/build tarafından yapılan değişiklikler</title>
     <tgroup cols="4">
      <colspec colwidth=".12"/>
      <colspec colwidth=".1"/>
      <colspec colwidth=".18"/>
      <colspec colwidth=".6"/>
      <thead>
       <row>
        <entry>Offset</entry>
        <entry>Byte</entry>
        <entry>Değişken</entry>
        <entry>Komut</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>1F1 (497)</entry>
        <entry>1</entry>
        <entry>setup_sectors</entry>
        <entry>kurulum sektörleri sayısı, &gt;=4</entry>
       </row>
       <row>
        <entry>1F4 (500)</entry>
        <entry>2</entry>
        <entry>sys_size</entry>
        <entry>system size in 16-bytes cinsinden sistem boyutu, küçük-biten</entry>
       </row>
       <row>
        <entry>1FC (508)</entry>
        <entry>1</entry>
        <entry>minor_root</entry>
        <entry>root dev minor</entry>
       </row>
       <row>
        <entry>1FD (509)</entry>
        <entry>1</entry>
        <entry>major_root</entry>
        <entry>root dev major</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   <para>
Takip eden bölümde <literal>compressed/vmlinux vmlinux</literal> olarak ve <literal>compressed/bvmlinux bvmlinux</literal> olarak anılacaktır.
   </para>
  </sect2>
  <sect2 xml:id="linux-i386-boot-code-howto-makefile_ref">
   <title>Kaynakça</title>
    <simplelist>
     <member>
Linux Kernel Makefiles: <filename>linux/Documentation/kbuild/makefiles.txt</filename>
     </member>
     <member>
      <link xlink:href="http://tldp.org/HOWTO/Kernel-HOWTO/">The Linux Çekirdeği NASIL</link>
     </member>
     <member>
      <link xlink:href="http://www.gnu.org/software/make/manual/">GNU make</link>
     </member>
     <member>
      <link xlink:href="http://www.gnu.org/software/binutils/manual/ld-2.9.1/">Using LD, the GNU linker</link>
     </member>
     <member>
      <link xlink:href="http://www.gnu.org/software/binutils/manual/">GNU Binary Utilities</link>
     </member>
     <member>
      <link xlink:href="http://www.gnu.org/software/bash/manual/">GNU Bash</link>
     </member>
    </simplelist>
  </sect2>
 </sect1>
 <sect1 xml:id="linux-i386-boot-code-howto-bootsect">
  <title>linux/arch/i386/boot/bootsect.S</title>
  <para>
Verildiği gibi <literal>bbootsect</literal>, <literal>bsetup</literal> ve <literal>bvmlinux</literal>'dan oluşan (<literal>head.o, misc.o, piggy.o</literal>),<literal>bzImage</literal>'ı yüklüyoruz. İlk floppy sektörü, <literal>bbootsect</literal> (512 bytes) <filename>linux/arch/i386/boot/bootsect.S</filename>'dan derlenmiştir. BIOS tarafından 07C0:0'a yüklenir. <literal>bzImage</literal>'ın sıfırlaması (<literal>bsetup</literal> ve <literal>bvmlinux</literal>) henüz yüklenmiş değildir.
  </para>
  <sect2 xml:id="linux-i386-boot-code-howto-move_bootsect">
   <title>Bootsect'i Taşı</title>
   <para>
<screen>SETUPSECTS = 4                     /*varsayılan kurulum sektörü sayısı*/
BOOTSEG    = 0x07C0                /*önyükleme sektörünün orjinal adresi*/
INITSEG    = DEF_INITSEG  (0x9000) /*önyüklemeyi buraya taşıyoruz;yolun dışına*/
SETUPSEG   = DEF_SETUPSEG (0x9020) /*kurulum buradan başlar*/
SYSSEG     = DEF_SYSSEG   (0x1000) /*sistem 0x10000 (65536) adresine yüklendi*/
SYSSIZE    = DEF_SYSSIZE  (0x7F00) /*sistem boyutu: 16-bayt sayısı*/
                                   /*yüklenecek*/
ROOT_DEV   = 0                     /*ROOT_DEV şimdi "build" tarafından yazıldı*/
SWAP_DEV   = 0                     /*SWAP_DEV şimdi "build" tarafından yazıldı*/

.code16
.text

///////////////////////////////////////////////////////////////////////////////
_start:
{
        // kendimizi 0x7C00'den 0x90000'e taşıdık ve oraya sıçradık.
        move BOOTSEG:0 to INITSEG:0 (512 bytes);
        goto INITSEG:go;
}</screen>
   </para>
   <para><literal>bbootsect INITSEG:0</literal> (0x9000:0)'a taşınmıştır. Artık <literal>BOOTSEG</literal>'i unutabiliriz.
   </para>
  </sect2>
  <sect2 xml:id="linux-i386-boot-code-howto-get_disk_para">
   <title>Disk değiştirgelerini Al</title>
<screen>///////////////////////////////////////////////////////////////////////////////
// yığıtı ve disk değiştirge tablosunu hazırla
go:
{
  SS:SP = INITSEG:3FF4;   // yığıtı INITSEG:0x4000-12'ye koy
  /* 0x4000 keyfi bir değerdir &gt;=
    *   bootsect boyutu + setup boyutu + yığıt için oda;
    * 12 disk değiştirge boyutudur. */
  disk değiştirgesini (0:0078'deki gösterici) \
  INITSEG:3FF4 adresine kopyala (12 bytes);
  // <link xlink:href="http://www.ctyme.com/intr/rb-2445.htm">int1E: SYSTEM DATA - DISKETTE PARAMETERS</link>
  yama sektör sayısı 36'ya (değiştirge tablosunda 4. konum, 1 byte);
  disk değiştirge tablosu göstericisine (0:0078, int1E) INITSEG:3FF4 ata;
}</screen>
   <para>
SS kaydedicisinden hemen sonra SP'nin başlatıldığından emin olun. SS'nin tavsiye edilen değişiklik yöntemi <literal>lss</literal> komutunu kullanmaktır (<link xlink:href="http://developer.intel.com/design/pentium4/manuals/">IA-32 Intel Architecture Software Developer's Manual</link>, (Vol.3. Ch.5.8.3. Masking Exceptions and Interrupts When Switching Stacks).
      </para>
   <para>
İtme ve çekme gibi yığıt işlemleri artık kabul edilebilir. Önce disk değiştirgelerinin 12 byte'ı <literal>INITSEG:3FF4</literal>'e kopyalanmıştı.
<screen>///////////////////////////////////////////////////////////////////////////////
// disk sürücü değiştirgelerini al, özellikle sektör/iz sayısı.
  char disksizes[] = {36, 18, 15, 9};
  int sectors;
{
  SI = disksizes;                         // i = 0;
  do {
probe_loop:
    sectors = DS:[SI++];            // sectors = disksizes[i++];
    if (SI&gt;=disksizes+4) break;     // if (i&gt;=4) break;
    int13/AH=02h(AL=1, ES:BX=INITSEG:0200, CX=sectors, DX=0);
    // <link xlink:href="http://www.ctyme.com/intr/rb-0607.htm">int13/AH=02h: DISK - READ SECTOR(S) INTO MEMORY</link>
  } while (sektör okuma hatası);
}</screen>
   </para>
   <para>
"<literal>lodsb</literal>" <literal>DS:[SI]</literal>'dan <literal>AL</literal>'ye baytları yükler ve <literal>SI</literal>'yı otomatik olarak arttırır.
   </para>
   <para>
İz başına düşen sektör sayısı <literal>sectors</literal> değişkenine kaydedilir.
   </para>
  </sect2>
  <sect2 xml:id="linux-i386-boot-code-howto-load_setup">
   <title>Kurulum Kodunu Yükle</title>
   <para><literal>bsetup</literal> (<literal>setup_sects</literal> sektörü) <literal>bbotsect</literal>'den hemen sonra yüklenecektir, örn. <literal>SETUPSEG:0</literal>. Dikkat ederseniz <literal>INITSEG:0200==SETUPSEG:0</literal> ve <literal>setup_sects</literal> <command>tools/build</command> tarafından <literal>bsetup</literal> boyutunun <xref linkend="linux-i386-boot-code-howto-i386_tools_build.c"/>'dekiyle eşleşmesi için değiştirilmiştir.
  </para>
<screen>///////////////////////////////////////////////////////////////////////////////
got_sectors:
  word sread;             // geçerli iz için sektörlerin okunması
  char setup_sects;       // tools/build tarafından üzerine yazılmış
{
  print out "Loading";
  /* <link xlink:href="http://www.ctyme.com/intr/rb-0088.htm">int10/AH=03h(BH=0): VIDEO - İMLEÇ KONUMUNU VE BOYUTUNU AL</link>
    * <link xlink:href="http://www.ctyme.com/intr/rb-0210.htm">int10/AH=13h(AL=1, BH=0, BL=7, CX=9, DH=DL=0, ES:BP=INITSEG:$msg1):</link>
    *   <link xlink:href="http://www.ctyme.com/intr/rb-0210.htm">VIDEO - DİZGEYİ YAZ</link> */

  // kurulum-sektörlerini taşınan (0x90200 adresine) önyükleme bloğundan
  // (bootblock) sonra doğrudan yükle.
  SI = &amp;sread;        // sread, head ve track indekslemek için SI kullanımı
  sread = 1;              // önyükleme sektörü okundu

  int13/AH=00h(DL=0);     // <link xlink:href="http://www.ctyme.com/intr/rb-0605.htm">reset FDC</link>

  BX = 0x0200;            // bsetup'ı bbootsect'den (512 bytes) hemen sonra oku
  do {
next_step:
    /* silindir çapraz okumayı (cylinder crossing reading) engellemek için,
      * bu sefer kaç tane sektörün oknacağını hesapla */
    uint16 pushw_ax = AX = MIN(sectors-sread, setup_sects);
no_cyl_crossing:
    read_track(AL, ES:BX);          // AX değiştirilmez
    // ES:BX, sread, head and track'e read_track()için değer ata
    set_next(AX);
    setup_sects -= pushw_ax;        // kalanlar - sonraki adım
  } while (setup_sects);
}</screen>
   <para>
SI <literal>sread, head</literal> ve <literal>track</literal> değişkenlerini indekslemek için  <literal>sread</literal> adresine atanmıştır. Onlar bellekte art arda bulunur. <function>read_track()</function> ve <function>set_next()</function> yöntemlerinin ayrıntıları için bakınız <xref linkend="linux-i386-boot-code-howto-read_disk"/>
   </para>
  </sect2>
  <sect2 xml:id="linux-i386-boot-code-howto-load_compressed">
   <title>Sıkıştırılmış İmgeyi Yükle</title>
   <para><literal>bvmlinux</literal> (<literal>head.o, misc.o, piggy.o</literal>) 0x100000 adresine yüklenecektir, <literal>syssize*16</literal> bayt.
   </para>
<screen>///////////////////////////////////////////////////////////////////////////////
// vmlinux/bvmlinux'u yükle (head.o, misc.o, piggy.o)
{
  read_it(ES=SYSSEG);
  kill_motor();                           // disket sürücü motorunu kapat
  print_nl();                             // CR LF yazar
}</screen>
   <para><literal>read_it()</literal> ayrıntıları için bakınız <xref linkend="linux-i386-boot-code-howto-read_disk"/>. Eğer <literal>zImage</literal>'ı yüklüyorsak, <literal>vmlinux</literal> 0x10000 (<literal>SYSSEG:0</literal>) adresine yüklenir.
      </para>
   <para><literal>bzImage</literal> (<literal>bbootsect, bsetup, bvmlinux</literal>) artık tümüyle bellekte bulunuyor.
   </para>
  </sect2>
  <sect2 xml:id="linux-i386-boot-code-howto-go_setup">
   <title>Ayarlara Git</title>
<screen>///////////////////////////////////////////////////////////////////////////////
// hangi kök aygıtın kullanılacağına bak ve setup.S'e sıçra
  int root_dev;                     // tools/build tarafından üzerine yazılır
{
  if (!root_dev) {
    switch (sectors) {
    case 15: root_dev = 0x0208;     // /dev/ps0 - 1.2Mb
        break;
    case 18: root_dev = 0x021C;     // /dev/PS0 - 1.44Mb
        break;
    case 36: root_dev = 0x0220;     // /dev/fd0H2880 - 2.88Mb
        break;
    default: root_dev = 0x0200;     // /dev/fd0 - auto detect
        break;
    }
  }

  // önyükleme bloğundan sonra doğrudan yüklenen ayar yordamına sıçra
  goto SETUPSEG:0;
}</screen>
   <para>
Denetimi <literal>bsetup</literal>'a geçirir. <xref linkend="linux-i386-boot-code-howto-setup"/> bölümündeki <literal>linux/arch/i386/boot/setup.S:start</literal>'a bakınız.</para>
  </sect2>
  <sect2 xml:id="linux-i386-boot-code-howto-read_disk">
   <title>Diski Oku</title>
   <para>
Aşağıdaki işlev <literal>bsetup</literal> ve <literal>bvmlinux</literal>'u diskten yüklemek için kullanılır. Dikkat ederseniz <literal>syssize</literal> <xref linkend="linux-i386-boot-code-howto-i386_tools_build.c"/> içindeki <command>tools/build</command> tarafından değiştirilmiştir.
      </para>
<screen>sread:  .word 0                         # geçerli iz'in (track) sektör okuması
head:   .word 0                         # geçerli kafa
track:  .word 0                         # geçerli iz
///////////////////////////////////////////////////////////////////////////////
// load the system image at address SYSSEG:0
read_it(ES=SYSSEG)
  int syssize;                    /* 16-bayt türünden sistem boyutu
                                   * tools/build tarafından üzerine yazıldı */
{
  if (ES &amp; 0x0fff) die;           // hizalama 64KB değil

  BX = 0;
  for (;;) {
rp_read:
#ifdef __BIG_KERNEL__
    bootsect_helper(ES:BX);
    /* INITSEG:0220==SETUPSEG:0020 - bootsect_kludge,
      *   SETUPSEG:bootsect_helper() gösterici içerir.
      * Bu işlev bazı veriyapılarını başlangıç durumuna getirir
      *   ilk sefer çağırımda,
      *   ve SYSSEG:0'dan 0x100000'a taşır, her seferinde 64KB,
      *   aşağıdaki çağırımda.
      * Bakınız <xref linkend="linux-i386-boot-code-howto-bootsect_helper"/>. */
#else
    AX = ES - SYSSEG + ( BX &gt;&gt; 4);  // kaç tane 16-bayt okuma
#endif
    if (AX &gt; syssize) return;       // herşey yüklendi
ok1_read:
    /* bu sefer uygun AL (okunacak sektörler) al
     * çapraz silindir okumasını ve BX taşmasını önlemek için. */
    AX = sectors - sread;
    CX = BX + (AX &lt;&lt; 9);            // 1 sector = 2^9 bytes
    if (CX overflow &amp;&amp; CX!=0) {     // &gt; 64KB
      AX = (-BX) &gt;&gt; 9;
    }
ok2_read:
    read_track(AL, ES:BX);
    set_next(AX);
  }
}

///////////////////////////////////////////////////////////////////////////////
// diski değiştirgelerle oku (sread, track, head)
read_track(AL sektörler, ES:BX hedef)
{
  for (;;) {
    printf(".");
    // <link xlink:href="http://www.ctyme.com/intr/rb-0106.htm">int10/AH=0Eh: VIDEO - TELETYPE ÇIKTI</link>

    // sread, track, head) değerlerine göre CX, DX değerlerini ata
    DX = track;
    CX = sread + 1;
    CH = DL;

    DX = head;
    DH = DL;
    DX &amp;= 0x0100;

    int13/AH=02h(AL, ES:BX, CX, DX);
    // <link xlink:href="http://www.ctyme.com/intr/rb-0607.htm">int13/AH=02h: DISK - SEKTÖRLERİ BELLEĞE OKU</link>
    if (disk okuma başarılı) return;
    // "addw $8, %sp" önceki 4 "pushw" işlemini iptal etmek için.
bad_rt:
    print_all();            // yazma hata kodu, AX, BX, CX ve DX
    int13/AH=00h(DL=0);     // <link xlink:href="http://www.ctyme.com/intr/rb-0605.htm">reset FDC</link>
  }
}

///////////////////////////////////////////////////////////////////////////////
// set ES:BX, sread, head and track for next read_track()
set_next(AX sectors_read)
{
  CX = AX;                        // sektörleri oku
  AX += sread;
  if (AX==sectors) {
    head = 1 ^ head;        // head'i 0 ve 1 arasında değiştir
    if (head==0) track++;
ok4_set:
    AX = 0;
  }
ok3_set:
  sread = AX;
  BX += CX &amp;&amp; 9;
  if (BX overflow) {              // &gt; 64KB
    ES += 0x1000;
    BX = 0;
  }
set_next_fn:
}</screen>
  </sect2>
  <sect2 xml:id="linux-i386-boot-code-howto-bootsect_helper">
   <title>Bootsect Yardımcısı</title>
   <para><literal>setup.S:bootsect_helper()</literal> sadece <literal>bootsect.S:read_it()</literal> tarafından kullanılır.
      </para>
   <para><literal>bbootsect</literal> ve <literal>bsetup</literal> yarı ayrı bağlandıkları için kendi kod/veri bölütlerine bağlı konumlar kullanırlar. Değişik bölütlerde <literal>bootsect_helper()</literal> için "call far" (lcall) çağırmak zorundayız ve "return far" dönmeli. Bu çağırma, CS!=DS durumunu yaratan CS değişikliği ile sonuçlanır ve <filename>setup.S</filename> içindeki değişkenleri belirtmek için bölütü niteleyici kullanmak zorundayız.
      </para>
<screen>///////////////////////////////////////////////////////////////////////////////
// bzImage yüklendiğinde bootsect yükleyici tarafından çağırılır
bootsect_helper(ES:BX)
  bootsect_es = 0;                // setup.S içinde tanımlı
  type_of_loader = 0;             // setup.S içinde tanımlı
{
  if (!bootsect_es) {             // ilk sefer için çağırılır
    type_of_loader = 0x20;  // bootsect-yükleyici, version 0
    AX = ES &gt;&gt; 4;
    *(byte*)(&amp;bootsect_src_base+2) = AH;
    bootsect_es = ES;
    AX = ES - SYSSEG;
    return;
  }
bootsect_second:
  if (!BX) {                      // 64KB full
    // SYSSEG:0'dan hedefe taşı, her seferinde 64KB
    int15/AH=87h(CX=0x8000, ES:SI=CS:bootsect_gdt);
    // <link xlink:href="http://www.ctyme.com/intr/rb-1527.htm">int15/AH=87h: SİSTEM - GENİŞLETİLMİŞ BELLEĞE KOPYALA</link>
    if (kopyalama hatası) {
      bootsect_panic() {
        prtstr("INT15 refuses to access high mem, giving up.");
bootsect_panic_loop:            goto bootsect_panic_loop;   // never return
      }
    }
    ES = bootsect_es;       // ES'i daima 0x10000 noktasına ata
    *(byte*)(&amp;bootsect_dst_base+2)++;
  }
bootsect_ex:
  // AX içindeki taşınmış çerçeveler (16-bayt)
  AH = *(byte*)(&amp;bootsect_dst_base+2) &lt;&lt; 4;
  AL = 0;
}

///////////////////////////////////////////////////////////////////////////////
// data used by bootsect_helper()
bootsect_gdt:
  .word   0, 0, 0, 0
  .word   0, 0, 0, 0

bootsect_src:
  .word   0xffff

bootsect_src_base:
  .byte   0x00, 0x00, 0x01                # base = 0x010000
  .byte   0x93                            # typbyte
  .word   0                               # limit16,base24 =0

bootsect_dst:
  .word   0xffff

bootsect_dst_base:
  .byte   0x00, 0x00, 0x10                # base = 0x100000
  .byte   0x93                            # typbyte
  .word   0                               # limit16,base24 =0
  .word   0, 0, 0, 0                      # BIOS CS
  .word   0, 0, 0, 0                      # BIOS DS

bootsect_es:
  .word   0

bootsect_panic_mess:
  .string "INT15 refuses to access high mem, giving up."
</screen>
   <para><literal>type_of_loader</literal> değerinin değiştiğine dikkat edin. Bu konu <xref linkend="linux-i386-boot-code-howto-check_loader"/> bölümünde açıklanmıştır.
      </para>
  </sect2>
  <sect2 xml:id="linux-i386-boot-code-howto-bootsect_misc">
   <title>Muhtelif</title>
   <para>
Kalanlar destek işlevleridir; değişkenler ve "gerçek kip çekirdek başlığı" parçaları. Dikkat ederseniz <literal>.text</literal> bölütündeki veri kod olarak bulunur, böylece yüklendiğinde uygun bir şekilde başlangıç durumuna getirilebilir.
      </para>
<screen>///////////////////////////////////////////////////////////////////////////////
// bazı küçük işlevler
print_all();  /* hata kodu yaz, AX, BX, CX and DX */
print_nl();   /* CR LF yaz*/
print_hex();  /* SS:BP tarafından gösterilen kelimeyi onaltılık olarak yaz*/
kill_motor()  /* disket sürücü motorunu kapat */
{
#if 1
  int13/AH=00h(DL=0);     // <link xlink:href="http://www.ctyme.com/intr/rb-0605.htm">reset FDC</link>
#else
  outb(0, 0x3F2);         // outb(val, port)
#endif
}

///////////////////////////////////////////////////////////////////////////////
sectors:        .word 0
disksizes:      .byte 36, 18, 15, 9
msg1:           .byte 13, 10
                .ascii "Loading"
</screen>
   <para>
"gerçek kip çekirdek başlığı"nın bir parçası olan bootsect taşıyıcı 497. konumdan başlar.
    </para>
<screen>.org 497
setup_sects:    .byte SETUPSECS       // tools/build tarafından üzerine yazılır
root_flags:     .word ROOT_RDONLY
syssize:        .word SYSSIZE         // tools/build tarafından üzerine yazılır
swap_dev:       .word SWAP_DEV
ram_size:       .word RAMDISK
vid_mode:       .word SVGA_MODE
root_dev:       .word ROOT_DEV        // tools/build tarafından üzerine yazılır
boot_flag:      .word 0xAA55
</screen>
   <para>
Bu "başlık" <filename>linux/Documentation/i386/boot.txt</filename> içindeki yerleşim örneğiyle uyuşmalıdır.
   </para>
<literallayout>Konum   Proto   İsim            Anlam
/Boyut
01F1/1  ALL     setup_sects     setup'ın sektör cinsinden boyutu
01F2/2  ALL     root_flags      Sıfırdan farklı ise, kök dizin salt okunur
                                olarak bağlanır
01F4/2  ALL     syssize         KULLANMAYIN - sadece bootsect.S kullanımı için
01F6/2  ALL     swap_dev        KULLANMAYIN - atıl oldu
01F8/2  ALL     ram_size        KULLANMAYIN - sadece bootsect.S kullanımı için
01FA/2  ALL     vid_mode        Video kip kontrolü
01FC/2  ALL     root_dev        Varsayılan kök aygıt sayısı
01FE/2  ALL     boot_flag       0xAA55 sihirli numara
</literallayout>
  </sect2>
  <sect2 xml:id="linux-i386-boot-code-howto-bootsect_ref">
   <title>Kaynakça</title>
   <para>
    <simplelist>
     <member>
THE LINUX/I386 BOOT PROTOCOL: <filename>linux/Documentation/i386/boot.txt</filename>
     </member>
     <member>
      <link xlink:href="http://developer.intel.com/design/pentium4/manuals/">IA-32 Intel Architecture Software Developer's Manual</link>
     </member>
     <member>
      <link xlink:href="http://www.cs.cmu.edu/~ralf/files.html">Ralf Brown's Interrupt List</link>
     </member>
    </simplelist>
   </para>
   <para>
&lt;IA-32 Intel Mimarisi Yazılım Geliştiricisinin Kılavuzu&gt; belgesine bu belgede bir çok kez başvurulduğundan kısaca "IA-32 Kılavuzu" diyeceğim.
      </para>
  </sect2>
 </sect1>
 <sect1 xml:id="linux-i386-boot-code-howto-setup">
  <title>linux/arch/i386/boot/setup.S</title>
  <para><filename>setup.S</filename> sistem verilerinin BIOS'dan alınmasından ve onların uygun bir bellek bölgesine yerleştirilmesinden sorumludur.
   </para>
  <para><link xlink:href="http://www.gnu.org/software/grub">GNU GRUB</link> ve <link xlink:href="http://freshmeat.net/projects/lilo">LILO</link> gibi diğer önyükleyiciler de <literal>bzImage</literal>'ı yükleyebilirler. Bu tür önyükleyiciler <literal>bzImage</literal>'ı belleğe yüklemeli ve "gerçek-biçim çekirdek başlıkları"nı kurmalıdırlar, özellikle <literal>type_of_loader</literal>; sonra denetimi <literal>bsetup</literal>'a devreder. <filename>setup.S</filename> şunları varsayar:
  </para>
   <itemizedlist>
    <listitem>
     <para><literal>bsetup</literal> veya <literal>setup</literal> SETUPSEG:0'a yüklenmemiş olabilir, örn. denetim <filename>setup.S</filename>'ye geçtiğinde CS SETUPSEG'e eşit olmayabilir;
        </para>
    </listitem>
    <listitem>
     <para><literal>setup</literal>'ın ilk 4 sektörü <literal>bootsect</literal>'den hemen sonra yüklenir. Sıfırlama <literal>vmlinux</literal>'den önce gelecek şekilde SYSSEG:0'da yüklü olabilir, bu varsayım <literal>bsetup</literal>'ta etkili olmaz.
        </para>
    </listitem>
   </itemizedlist>
  <sect2 xml:id="linux-i386-boot-code-howto-setup_header">
   <title>Başlık</title>
<screen>/* LILO'nun doğru yüklendiğinden emin olmak için imza kelimeleri */
#define SIG1    0xAA55
#define SIG2    0x5A5A

INITSEG  = DEF_INITSEG         # 0x9000, önyüklemeyi buraya taşır, yolun dışına
SYSSEG   = DEF_SYSSEG          # 0x1000, sistem 0x10000'a yüklenir (65536).
SETUPSEG = DEF_SETUPSEG        # 0x9020, bu geçerli bölüttür
                               # ... ve CS'nin önceki içeriği

DELTA_INITSEG = SETUPSEG - INITSEG      # 0x0020

.code16
.text

///////////////////////////////////////////////////////////////////////////////
start:
{
  goto trampoline();              // sıradaki başlığı atla
}

# Bu setup başlığıdır ve %cs:2 (old 0x9020:2) adresinden başlamalıdır
                .ascii  "HdrS"          # başlık imzası
                .word   0x0203          # başlık sürüm numarası (&gt;= 0x0105)
                                        # yoksa eski loadlin-1.5 başarısız olur
realmode_swtch: .word   0, 0            # default_switch, SETUPSEG
start_sys_seg:  .word   SYSSEG
                .word   kernel_version  # çekirdek sürüm dizgesini göstererek
                                        # yukarıdaki başlık bölümü
                                        # loadlin-1.5 (başlık v1.5) ile uyumlu.
                                        # Değiştirmeyin
// kernel_version defined below
type_of_loader: .byte   0               # = 0, eski (LILO, Loadlin,
                                        #      Bootlin, SYSLX, bootsect...)
                                        # atanmış id değerleri için
                                        # bakınız Documentation/i386/boot.txt
# bayraklar, kullanılmayan bitler 0 olmalı, (RFU) loadflags arasındaki bitler
loadflags:
LOADED_HIGH     = 1               # Sıfır değilse, çekirdek yüksek yüklenmiştir
CAN_USE_HEAP    = 0x80            # Sıfır değilse, yükleyici ayrıca setup.S'nin
                                  # gerisinde ne kadar alanın yığın (heap)
                                  # olarak kullanılacağını tutmak için
                                  # heap_end_ptr'ye sahiptir.
                                  # Neyin boş olduğunu sadece yükleyici bilir
#ifndef __BIG_KERNEL__
                .byte   0
#else
                .byte   LOADED_HIGH
#endif
setup_move_size: .word  0x8000    # kurulum 0x90000'ye yüklenmediğinde
                                  # taşıma boyutu. Çekirdeğe sıçramadan
                                  # hemen önce kurulumu 0x90000'a taşıyacağız.


                                  # Bununla birlikte geride bıraktığımız
                                  # ne kadar yüklenmesi gereken veri
                                  # bulunduğunu sadece yükleyici bilir.
                                  # burada yükleyiciler 32-bit kod
code32_start:                     # için farklı başlangıç
                                  # adresleri koyarlar.
#ifndef __BIG_KERNEL__
                .long   0x1000    #   0x1000 = zImage için varsayılan
#else
                .long   0x100000  # 0x100000 = büyük çekirdek için öntanımlı
#endif
ramdisk_image:  .long   0         # yüklü ramdisk görüntüsünün adresi
                                  # Burada yükleyici görüntüyü yüklediği
                                  # 32-bit adresi koyar. Bu sadece
                                  # çekirdek tarafından okunacaktır.
ramdisk_size:   .long   0         # boyutu bayt cinsindendir
bootsect_kludge:
                .word  bootsect_helper, SETUPSEG
heap_end_ptr:   .word   modelist+1024  # (Başlık sürümü 0x0201 veya daha büyük)
                                       # buradan sonra kurulum sonuna kadar
                                  # boşluklar (özel) kurulum tarafından
                                  # yerel yığın amaçları için kullanılabilir.
// modelist .text bölümünün sonundadır
pad1:           .word   0
cmd_line_ptr:   .long 0           # (Başlık sürümü 0x0202 veya daha büyük)
                                  # Sıfır değilse, çekirdek komut
                                  # satırına 32-bit bir gösterici.
                                  # Komut satırı kurulumun başı ile
                                  # alçak bellek arasına (0xa0000)
                                  # yerleştirilmeli veya okunmadan önce
                                  # üzerine yazılmalı. Eğer bu alan
                                  # kullanılırsa, 0x90000 bölütüyle ilgili
                                  # sihirli birşey kalmaz; kurulum
                                  # alçak bellekte 0x10000 veya
                                  #  daha yüksek herhangi bir
                                  # yere yerleştirilebilir.
ramdisk_max:    .long __MAXMEM-1  # (Başlık sürümü 0x0203 veya daha büyük)
                                  # initrd içeriği için en
                                  # yüksek güvenli adres
</screen>
   <para><literal>__MAXMEM</literal> tanımlaması <filename>linux/asm-i386/page.h</filename> içindedir:
   </para>
<screen>/*
 * 0xC0000000'ın bir __PAGE_OFFSET değeri çekirdeğin bir gigabayt
 * sanal adres boşluğuna sahip olduğu anlamına gelir ki bu da
 * kullanabileceğiniz fiziksel bellek miktarını 950MB'a sınırlar
 */
#define __PAGE_OFFSET           (0xC0000000)

/*
 * Bu kadar adres boşluğu vmalloc() ve iomap() olduğu kadar
 * "fixmap" eşleştirmeleri (mappings) için de tahsis edilir.
 */
#define __VMALLOC_RESERVE       (128 &lt;&lt; 20)

#define __MAXMEM                (-__PAGE_OFFSET-__VMALLOC_RESERVE)
</screen>
   <para><literal>__MAXMEM</literal> = 1G - 128M değerini verir.
   </para>
   <para>
Bu başlık bazı plan örneklerini takip etmelidir. <filename>linux/Documentation/i386/boot.txt</filename> belgesine başvurun:
  </para>
<literallayout>Konum   Proto   İsim            Anlamı
/Boyut
0200/2  2.00+   jump            Sıçrama komutu
0202/4  2.00+   header          Sihirli imza "HdrS"
0206/2  2.00+   version         Desteklene önyükleme protokolü sürümü
0208/4  2.00+   realmode_swtch  Önyükleme yükleyici çengeli (hook)
020C/2  2.00+   start_sys       load-low bölütü (0x1000) (modası geçmiş)
020E/2  2.00+   kernel_version  Çekirdek sürüm dizgesi göstericisi
0210/1  2.00+   type_of_loader  Önyükleme yükleyici belirteci
0211/1  2.00+   loadflags       Önyükleme protokolü seçenek bayrakları
0212/2  2.00+   setup_move_size Yüksek bellek boyutuna taşı
                                (çengellerle kullanılır)
0214/4  2.00+   code32_start    Önyükleyici çengeli
0218/4  2.00+   ramdisk_image   initrd yükleme adresi
                                (önyükleyici tarafından atanır)
021C/4  2.00+   ramdisk_size    initrd boyutu (önyükleyici tarafından atanır)
0220/4  2.00+   bootsect_kludge KULLANMAYIN - sadece bootsect.S kullanımı için
0224/2  2.01+   heap_end_ptr    kurulum bittikten sonra boş bellek
0226/2  N/A     pad1            Kullanılmaz
0228/4  2.02+   cmd_line_ptr    çekirdek komut satırına 32-bit gösterici
022C/4  2.03+   initrd_addr_max En yüksek yasal initrd adresi
</literallayout>
  </sect2>
  <sect2 xml:id="linux-i386-boot-code-howto-check_code">
   <title>Kod Bütünlüğünü Kontrol Et</title>
   <para><literal>setup</literal> kodu sürekli olmayabileceği için önce kod bütünlüğünü kontrol etmeliyiz.
   </para>
<screen>///////////////////////////////////////////////////////////////////////////////
trampoline()
{
  start_of_setup();       // asla dönmez
  .space 1024;
}

///////////////////////////////////////////////////////////////////////////////
// tüm kodun yüklenip yüklenmediğini görmek için imzayı kontrol et
start_of_setup()
{
  // Bootlin bunun daha önce yapılmasına bağlıdır, bakınız <link xlink:href="http://ftp.us.xemacs.org/ftp/pub/linux/suse/suse/i386/7.3/dosutils/bootlin/technic.doc">bootlin:technic.doc</link>
  int13/AH=15h(AL=0, DL=0x81);
  // <link xlink:href="http://www.ctyme.com/intr/rb-0639.htm">int13/AH=15h: DİSK - DİSK TÜRÜNÜ AL</link>

#ifdef SAFE_RESET_DISK_CONTROLLER
  int13/AH=0(AL=0, DL=0x80);
  // <link xlink:href="http://www.ctyme.com/intr/rb-0605.htm">int13/AH=00h: DİSK - DİSK SİSTEMİNİ RESETLE</link>
#endif

  DS = CS;
  // kurulum sonunda imzayı kontrol et
  if (setup_sig1!=SIG1 || setup_sig2!=SIG2) {
    goto bad_sig;
  }
  goto goodsig1;
}

///////////////////////////////////////////////////////////////////////////////
// bazı küçük işlevler
prtstr();  /* DS:SI'teki ascii'leri yaz */
prtsp2();  /* çift boşluk yaz */
prtspc();  /* tek boşluk yaz  */
prtchr();  /* AL'deki ascii'leri yaz */
beep();    /* CTRL-G yaz, örn. bip */
</screen>
   <para>
Kod bütünlüğünü doğrulamak için imza kontrol edilir.
      </para>
   <para>
İmza bulunmazsa kalan <literal>setup</literal> kodu <literal>SYSSEG:0</literal>'da <literal>vmlinux</literal> öncesinde yer alır.
      </para>
<screen>no_sig_mess: .string "No setup signature found ..."

goodsig1:
  goto goodsig;                           // yakın sıçrama yap

///////////////////////////////////////////////////////////////////////////////
// kalan setup kodunu SYSSEG:0'dan CS:0800'e taşı
bad_sig()
  DELTA_INITSEG = 0x0020 (= SETUPSEG - INITSEG)
  SYSSEG = 0x1000
  word start_sys_seg = SYSSEG;            // kurulum başlığında tanımlı
{
  DS = CS - DELTA_INITSEG;                // INITSEG olarak da bilinir
  BX = (byte)(DS:[497]);                  // örn. setup_sects

  // ilk 4 sekctör zaten yüklü
  CX = (BX - 4) &lt;&lt; 8;           // kelime cinsinden kalan kod (2-bayt)
  start_sys_seg = (CX &gt;&gt; 3) + SYSSEG;     // gerçek sistem kodu başlangıcı
  move SYSSEG:0 to CS:0800 (CX*2 bytes);

  if (setup_sig1!=SIG1 || setup_sig2!=SIG2) {
no_sig:
    prtstr("No setup signature found ...");
no_sig_loop:
    hlt;
    goto no_sig_loop;
  }
}</screen>
   <para><literal>hlt</literal> komutu komut çalıştırmayı durdurur ve işlemciyi halt durumuna getirir. İşlemci halt kipine girildiğini belirtecek şekilde özel bir taşıt dizisi üretir. Etkin bir kesme (NMI dahil) oluştuğunda, işlemci çalıştırmayı <literal>hlt</literal> komutundan sonra devam ettirir ve komut göstericisi, <literal>hlt</literal>'ı takip eden komutu göstererek, kesme yöneticisi çağırılmadan önce yığıta kaydedilecektir. Böylece işlemciyi tekrar halt durumuna koymak için <literal>hlt</literal>'tan sonra <literal>jmp</literal> komutuna ihtiyaç duyarız.
      </para>
   <para><literal>setup</literal> kodu doğru yere taşınmıştır. <literal>start_sys_seg</literal> değişkeni gerçek sistem kodunun başladığı yeri gösterir. Eğer <literal>bad_sig</literal> olmazsa <literal>start_sys_seg, SYSSEG</literal> olarak kalır.
      </para>
  </sect2>
  <sect2 xml:id="linux-i386-boot-code-howto-check_loader">
   <title>Yükleyici Türünü Kontrol Et</title>
   <para>
Yükleyicinin imgeyle uyumluluğunu olduğunu kontrol et.
      </para>
<screen>///////////////////////////////////////////////////////////////////////////////
good_sig()
  char loadflags;                 // setup başlığı içinde
  char type_of_loader;            // setup başlığı içinde
  LOADHIGH = 1
{
  DS = CS - DELTA_INITSEG;        // INITSEG olarak da bilinir
  if ( (loadflags &amp; LOADHIGH) &amp;&amp; !type_of_loader ) {
    // Hata, eski yükleyiciler büyük-çekirdek yüklemeye çalışırlar
    prtstr("Wrong loader, giving up...");
    goto no_sig_loop;             // yukarıda bad_sig()'de tanımlı
  }
}

loader_panic_mess: .string "Wrong loader, giving up..."
</screen>
   <para><literal>bootsect_helper()</literal> tarafından <literal>bvmlinux</literal> yüklendiğinde <literal>type_of_loader</literal>'un 0x20 olarak  değiştiğine dikkat edin.
      </para>
  </sect2>
  <sect2 xml:id="linux-i386-boot-code-howto-get_mem_size">
   <title>Bellek Boyutunu</title>
   <para>
kB cinsinden genişletilmiş bellek boyutunu (1M üzeri) elde etmek için üç değişik bellek saptama şeması dene.
      </para>
   <para>
İlk olarak bir bellek haritası oluşturmamızı sağlayan <literal>e820h</literal>'yi dene; sonra 32 bitlik bellek boyutu döndüren <literal>e801h</literal>'yi ve son olarak 0-64M döndüren <literal>88h</literal>'yi dene.
      </para>
<screen>///////////////////////////////////////////////////////////////////////////////
// bellek boyunu al
loader_ok()
  E820NR  = 0x1E8
  E820MAP = 0x2D0
{
  // bu işleve girerken, DS = CS-DELTA_INITSEG; INITSEG olarak da bilinir
  (long)DS:[0x1E0] = 0;

#ifndef STANDARD_MEMORY_BIOS_CALL
  (byte)DS:[0x1E8] = 0;                   // E820NR

  /* method E820H: bakınız <link xlink:href="http://www.acpi.info">ACPI spec</link>
    * bellek haritası (from hell).  e820h belleği farklı türlerden
    * bir bütün deste olarak sınıflandırılmış şekilde döndürür, ve
    * bellek deliklerine ve herşeye izin verir. Biz bu bellek
    * haritasını tararız ve ilk 32 bellek alanının listesini oluştururuz,
    * [E820MAP]'den döneriz. */
meme820:
  EBX = 0;
  DI = 0x02D0;                            // E820MAP
  do {
jmpe820:
    int15/EAX=E820h(EDX='SMAP', EBX, ECX=20, ES:DI=DS:DI);
    // <link xlink:href="http://www.ctyme.com/intr/rb-1741.htm">int15/AX=E820h: GET SYSTEM MEMORY MAP</link>
    if (failed || 'SMAP'!=EAX) break;
    // if (1!=DS:[DI+16]) continue; // kullanışsız
good820:
    if (DS:[1E8]&gt;=32) break;        // entry# &gt; E820MAX
    DS:[0x1E8]++;                   // entry# ++;
    DI += 20;                       // tamponu sonraki için ayarla
again820:
  } while (!EBX)                          // bitmedi
bail820:

  /* method E801H:
    * 1k parça boyutuyla bellek boyutu, loadlin karıştırmamak için.
    * 0xe801 bellek boyutunu tamamen farklı bir yerde tutarız
    * çünkü muhtemelen 16 bitten daha uzun olacaktır
    * (1e0 kullanınız çünkü bu Larry Augustine'in alternatif bellek
    * tespit şemasını kullanma yöntemidir ve bu yöntem
    * herşeyi aynı yere yazma konusunda hassastır.) */
meme801:
  stc;            // hatalı BIOSlar için uğraş
  CX = DX = 0;
  int15/AX=E801h;
  /* <link xlink:href="http://www.ctyme.com/intr/rb-1739.htm">int15/AX=E801h: &gt;64M YAPILANDIRMALAR İÇİN BELLEK BOYUTUNU AL</link>
    *   AX = K cinsinden 1M ve 16M arasında bellek boyutu (en çok 3C00 = 15MB)
    *   BX = genişletilmiş bellek, 16M üzeri, 64K bloklar halinde
    *   CX = K cinsinden 1M'dan 16M'a yapılandırılmış bellek
    *   DX = 16M üzeri yapılandırılmış bellek, 64K bloklar halinde */
  if (failed) goto mem88;
  if (!CX &amp;&amp; !DX) {
    CX = AX;
    DX = BX;
  }
e801usecxdx:
  (long)DS:[0x1E0] = ((EDX &amp; 0xFFFF) &lt;&lt; 6) + (ECX &amp; 0xFFFF);      // in K
#endif

mem88:  // eski geleneksel yöntem
  int15/AH=88h;
  /* <link xlink:href="http://www.ctyme.com/intr/rb-1529.htm">int15/AH=88h: SİSTEM - GENİŞLETİLMİŞ BELLEK BOYUTU</link>
   *   AX = mutlak 100000h adresinden başlayan sürekli kB'ların sayısı */
  DS:[2] = AX;
}</screen>
  </sect2>
  <sect2 xml:id="linux-i386-boot-code-howto-hw_support">
   <title>Donanım Desteği</title>
   <para>
Klavye, ekran kartı, harddisk, MCA bus'ı ve işaretleme cihazı gibi donanımların desteğini kontrol et.
      </para>
<screen>{
  // klavye tekrarlama oranını en çoğa ayarla
  int16/AX=0305h(BX=0);
  // <link xlink:href="http://www.ctyme.com/intr/rb-1757.htm">int16/AH=03h: KEYBOARD - SET TYPEMATIC RATE AND DELAY</link>

  /* Ekran kiplerini kullanıcıya göstermek için
    *   ekran kartını ve değiştirgelerini kontrol et. */
  video();                        // see video.S

  // hd0 ve hd1 verisini al
  hd0 verisini (*int41)'dan CS-DELTA_INITSEG:0080'ya (16 bytes) kopyala;
  // <link xlink:href="http://www.ctyme.com/intr/rb-6135.htm">int41: SYSTEM DATA - HARD DISK 0 PARAMETRE TABLO ADRESİ</link>
  hd1 verisini (*int46)'dan CS-DELTA_INITSEG:0090'ya (16 bytes) kopyala;
  // <link xlink:href="http://www.ctyme.com/intr/rb-6184.htm">int46: SYSTEM DATA - HARD DISK 1 PARAMETRE TABLE ADRESİ</link>
  // hd1 var mı kontrol et
  int13/AH=15h(AL=0, DL=0x81);
  // <link xlink:href="http://www.ctyme.com/intr/rb-0639.htm">int13/AH=15h: DISK - DİSK TÜRÜNÜ AL</link>
  if (failed || AH!=03h) {        // AH==03h eğer harddisk ise
no_disk1:
    temizle CS-DELTA_INITSEG:0090 (16 bytes);
  }
is_disk1:

  // Mikro Kanal veriyolu (Micro Channel-MCA bus) için kontrol et
  CS-DELTA_INITSEG:[0xA0] = 0;    // tablo uzunluğunu 0'a ayarla
  int15/AH=C0h;
  /* <link xlink:href="http://www.ctyme.com/intr/rb-1594.htm">int15/AH=C0h: SİSTEM - YAPILANDIRMAYI AL</link>
    *   ES:BX = ROM yapılandırma tablosu */
  if (failed) goto no_mca;
    ROM yapılandırma tablosunu (ES:BX)'den CS-DELTA_INITSEG:00A0 adresine taşı;
  // CX = (table length&lt;14)? CX:16;    sadece ilk 16 bayt
no_mca:

  // PS/2 noktalama cihazlarını (pointing device) kontrol et
  CS-DELTA_INITSEG:[0x1FF] = 0;   // varsayılan noktalama cihazı 0
  int11h();
  // <link xlink:href="http://www.ctyme.com/intr/rb-0575.htm">int11h: BIOS - EKİPMAN LİSTESİNİ AL</link>
  if (AL &amp; 0x04) {                // fare kuruldu
          DS:[0x1FF] = 0xAA;
  }
}</screen>
  </sect2>
  <sect2 xml:id="linux-i386-boot-code-howto-apm_support">
   <title>APM Desteği</title>
   <para>
BIOS APM desteğini kontrol et.
      </para>
<screen>#if defined(CONFIG_APM) || defined(CONFIG_APM_MODULE)
{
  DS:[0x40] = 0;                  // sürüm = 0 APM BIOS olmadığı anlamına gelir
  int15/AX=5300h(BX=0);
  // <link xlink:href="http://www.ctyme.com/intr/rb-1394.htm">int15/AX=5300h: Advanced Power Management v1.0+ - INSTALLATION CHECK</link>
  if (failed || 'PM'!=BX || !(CX &amp; 0x02)) goto done_apm_bios;
  // (CX &amp; 0x02) 32 bit desteklendiği anlamına gelir
  int15/AX=5304h(BX=0);
  // <link xlink:href="http://www.ctyme.com/intr/rb-1398.htm">int15/AX=5304h: Advanced Power Management v1.0+ - DISCONNECT INTERFACE</link>
  EBX = CX = DX = ESI = DI = 0;
  int15/AX=5303h(BX=0);
  /* <link xlink:href="http://www.ctyme.com/intr/rb-1397.htm">int15/AX=5303h: Advanced Power Management v1.0+</link>
    *   <link xlink:href="http://www.ctyme.com/intr/rb-1397.htm">- CONNECT 32-BIT PROTMODE INTERFACE</link> */
  if (failed) {
no_32_apm_bios:                     // no_32_apm_bios etiketini buraya taşıdım
    DS:[0x4C] &amp;= ~0x0002;   // 32 bit destekleme bitini kaldır
    goto done_apm_bios;
  }
  DS:[0x42] = AX, 32-bit kod bölütü temel adresi;
  DS:[0x44] = EBX, giriş noktası konumu;
  DS:[0x48] = CX, 16-bit kod bölütü temel adresi;
  DS:[0x4A] = DX, 16-bit veri bölütü temel adresi;
  DS:[0x4E] = ESI, APM BIOS kod bölütü uzunluğu;
  DS:[0x52] = DI, APM BIOS veri bölütü uzunluğu;
  int15/AX=5300h(BX=0);     // tekrar kontrol et
  // <link xlink:href="http://www.ctyme.com/intr/rb-1394.htm">int15/AX=5300h: Advanced Power Management v1.0+ - INSTALLATION CHECK</link>
  if (success &amp;&amp;  'PM'==BX) {
          DS:[0x40] = AX, APM version;
          DS:[0x4C] = CX, APM flags;
  } else {
apm_disconnect:
    int15/AX=5304h(BX=0);
    /* <link xlink:href="http://www.ctyme.com/intr/rb-1398.htm">int15/AX=5304h: Advanced Power Management v1.0+</link>
     * <link xlink:href="http://www.ctyme.com/intr/rb-1398.htm">- DISCONNECT INTERFACE</link> */
  }
done_apm_bios:
}
#endif</screen>
  </sect2>
  <sect2 xml:id="linux-i386-boot-code-howto-prepare_protmode">
   <title>Korumalı Kip için Hazırlık</title>
<screen>// kip seçiciyi çağır
{
  if (realmode_swtch) {
    realmode_swtch();               // kip seçme çengeli
  } else {
rmodeswtch_normal:
    default_switch() {
      cli;                    // hiçbir kesmeye izin yok
      outb(0x80, 0x70);       // NMI etkinleştirmeyi kaldır
    }
  }
rmodeswtch_end:
}

// gerekliyse kodu tekrar konumla
{
  (long)code32 = code32_start;
  if (!(loadflags &amp; LOADED_HIGH)) {       // düşük yüklü zImage
    // 0x0100 &lt;= start_sys_seg &lt; CS-DELTA_INITSEG
do_move0:
    AX = 0x100;
    BP = CS - DELTA_INITSEG;        // INITSEG olarak da bilinir
    BX = start_sys_seg;
do_move:
    sistem imgesini (start_sys_seg:0 .. CS-DELTA_INITSEG:0)'dan
      0100:0'a taşı;                // her seferinde 0x1000 bayt taşı
  }
end_move:</screen>
   <para><literal>code32_start</literal>'ın <literal>zImage</literal> için <literal>0x1000</literal> adresi ile  <literal>bzImage</literal> için ise <literal>0x100000</literal> adresi ile ilklendirildiğine dikkat edin. <literal>code32</literal> değeri denetimin <xref linkend="linux-i386-boot-code-howto-switch_protmode"/> içindeki<filename>linux/arch/i386/boot/compressed/head.S</filename>'e geçirilmesi için kullanılacaktır. <literal>zImage</literal> önyüklemesi yapılırsa <literal>vmlinux</literal>'u <literal>0100:0</literal>'a taşır; <literal>bzImage</literal> önyüklemesi yapılırsa <literal>bvmlinux start_sys_seg:0</literal>'da kalır. Taşıma adresi <filename>linux/arch/i386/boot/compressed/Makefile</filename> içindeki <option>-Ttext</option> seçeneğiyle uyuşmalıdır. Bakınız <xref linkend="linux-i386-boot-code-howto-i386_boot_compressed_makefile"/>.
      </para>
   <para>
Sonra, eğer gerekliyse, kod <literal>CS-DELTA_INITSEG:0</literal>'dan (<literal>bbootsect</literal> ve <literal>bsetup</literal>) <literal>INITSEG:0</literal>'a taşınır.
      </para>
<screen>  DS = CS;                // SETUPSEG olarak da bilinir
  // sürüm &lt;=201 ile geriye dönük uyumluluğa ihtiyacımız olup olmadığını kontrol et
  if (!cmd_line_ptr &amp;&amp; 0x20!=type_of_loader &amp;&amp; SETUPSEG!=CS) {
    cli;            // taşınırken kesme olarak yığıtı kullanabilir
    // store new SS in DX
    AX = CS - DELTA_INITSEG;
    DX = SS;
    if (DX&gt;=AX) {   // yığıt çerçevesi birlikte taşınacak
      DX = DX + INITSEG - AX; // i.e. SS-CS+SETUPSEG
    }
move_self_1:
    /* CS-DELTA_INITSEG:0'dan INITSEG:0'ya taşı (setup_move_size bayt)
      *  CS:IP üzerindeki kodun üzerine yazmamak için iki adımda
      * (src &lt; dest) taşı fakat aşağıya doğru ("std") */
    move CS-DELTA_INITSEG:move_self_here+0x200
      to INITSEG:move_self_here+0x200,
      setup_move_size-(move_self_here+0x200) bytes;
    // INITSEG:move_self_here+0x200 == SETUPSEG:move_self_here
    goto SETUPSEG:move_self_here;   // artık CS=SETUPSEG
move_self_here:
    move CS-DELTA_INITSEG:0 to INITSEG:0,
      move_self_here+0x200 bytes;   // goto'dan önce eski CS anlamında
    DS = SETUPSEG;
    SS = DX;
  }
end_move_self:
}</screen>
   <para>
Tekrar dikkat edin, <literal>bvmlinux</literal>'u yüklediğinde <literal>bootsect_helper()</literal> tarafından <literal>type_of_loader</literal>'un değeri <literal>0x20</literal> olarak değiştirilmektedir.
      </para>
  </sect2>
  <sect2 xml:id="linux-i386-boot-code-howto-enable_a20">
   <title>A20'yi Etkinleştir</title>
   <para>
A20 sorunu ve çözümü için <link xlink:href="http://www.win.tue.nl/~aeb/linux/kbd/A20.html">A20 - a pain from the past</link>'e başvurun.
      </para>
<screen>  A20_TEST_LOOPS          =  32   # Bekleme başına adım sayısı
  A20_ENABLE_LOOPS        = 255   # deneme için toplam döngü
{
#if defined(CONFIG_MELAN)
  // Enable A20. AMD Elan bug fix.
  outb(0x02, 0x92);               // outb(val, port)
a20_elan_wait:
  while (!a20_test());            // testi geçemedi
  goto a20_done;
#endif

a20_try_loop:
  // Önce, A20 kapısı olmayan bir sistemde olup olmadığımıza bak.
a20_none:
  if (a20_test()) goto a20_done;  // testi geçti

  // Sonra, BIOS'u (INT 0x15, AX=0x2401) dene
a20_bios:
  int15/AX=2401h;
  // <link xlink:href="http://www.ctyme.com/intr/rb-1336.htm">Int15/AX=2401h: SYSTEM - later PS/2s - ENABLE A20 GATE</link>
  if (a20_test()) goto a20_done;  // testi geçti

  // Klavye denetleyici üzerinden A20'yi etkinleştirmeye çalış
a20_kbc:
  empty_8042();
  if (a20_test()) goto a20_done;  // BIOS gecikmesi durumunda testi tekrarla
  outb(0xD1, 0x64);               // komut yaz
  empty_8042();
  outb(0xDF, 0x60);               // A20 etkin
  empty_8042();
  // a20 gerçekten etkin olana kadar bekle
a20_kbc_wait:
  CX = 0;
a20_kbc_wait_loop:
  do {
          if (a20_test()) goto a20_done;  // testi geçti
  } while (--CX)

  // Son girişim: "yapılandırma portu A"'yı kullan
  outb((inb(0x92) | 0x02) &amp; 0xFE, 0x92);
  // yapılandırma portu A etkilenene kadar bekle
a20_fast_wait:
  CX = 0;
a20_fast_wait_loop:
  do {
          if (a20_test()) goto a20_done;  // testi geçti
  } while (--CX)

  // A20 hala cevap vermiyor. Tekrar ayarlamayı dene.
  if (--a20_tries) goto a20_try_loop;
  prtstr("linux: fatal error: A20 gate not responding!");
a20_die:
  hlt;
  goto a20_die;
}

a20_tries:
  .byte   A20_ENABLE_LOOPS                // i.e. 255
a20_err_msg:
  .ascii  "linux: fatal error: A20 gate not responding!"
  .byte   13, 10, 0
</screen>
   <para>
I/O port işlemleri için, <xref linkend="linux-i386-boot-code-howto-setup_ref"/> içindeki ilgili başvuru materyallerine bakın.
      </para>
  </sect2>
  <sect2 xml:id="linux-i386-boot-code-howto-switch_protmode">
   <title>Korumalı Kipe Geç</title>
   <para>
Tüm 32 bitlik IA-32 işlemcileri ile kod uyumluluğunu sağlamak için, aşağıdaki korumalı kipe geçmeyi sağlayacak adımları yerine getirin:
      </para>
    <orderedlist>
     <listitem>
      <para>İlk GDT girdisinde boş tanımlayıcılı GDT'yi hazırlayın, bir kod bölütü tanımlayıcı ve bir veri bölütü tanımlayıcı;
      </para>
     </listitem>
     <listitem>
      <para>Maskelenebilir donanım kesmeleri ve NMI dahil kesmeleri etkisiz kılın;
      </para>
     </listitem>
     <listitem>
      <para><literal>lgdt</literal> asm komutunu kullanarak GDTR yazmacına taban adresini ve GDT sınırını yükleyin;
      </para>
     </listitem>
     <listitem>
      <para><literal>mov cr0</literal> (Intel 386 ve üstü) veya <literal>lmsw</literal> komutu (Intel 286 ile uyumluluk için) kullanarak CR0 yazmacındaki PE bayrağını etkinleştirin;
      </para>
     </listitem>
     <listitem>
      <para>Ardından bir uzak <literal>jmp</literal> veya bir uzak <literal>call</literal> komutu çalıştırın.
      </para>
     </listitem>
    </orderedlist>
   <para>
Yığıt normal oku/yaz veri bölütüne yerleştirilebilir, böylece adanmış tanımlayıcıya gerek kalmaz.
      </para>
<screen>a20_done:
{
  lidt    idt_48;         // load idt with 0, 0;

  // DS:gdt'yi doğrusal göstericiye dönüştür
  *(long*)(gdt_48+2) = DS &lt;&lt; 4 + &amp;gdt;
  lgdt    gdt_48;

  // yardımcı işlemciyi sıfırla
  outb(0, 0xF0);
  delay();
  outb(0, 0xF1);
  delay();

  // kesmeleri yeniden yazılımla
  outb(0xFF, 0xA1);       // tüm kesmeleri maskele
  delay();
  outb(0xFB, 0x21);       // irq2 dışında tüm irq'ları maskele

  // korumalı kip!
  AX = 1;
  lmsw ax;                // makina durumu kelimesi (word), CR0'ın 0'dan 15'e
                          // kadar bitleri sadece PE, MP, EM ve TS bayraklarını
                          // etkiler
  goto flush_instr;

flush_instr:
  BX = 0;                                 // bir önyükleme gösteren bayrak
  ESI = (CS - DELTA_INITSEG) &lt;&lt; 4;        // gerçek kip kod göstericisi
  /* NOT: Yüksek yüklenen büyük çekirdekler için
    * jmpi    0x100000,__KERNEL_CS'ye gereksinim duyarız
    *
    * fakat henüz CS yazmacını yüklemedik,
    * bu yüzden hedef konumun varsayılan boyutu hala 16 bit.
    * Bununla birlikte, bir terim öneki (0x66) kullanarak,
    * CPU bizim 48 bit uzak göstericimizi uygun bir şekilde alır.
    * Bakınız (INTeL 80386 Programmer's Reference Manual,
    * Mixing 16-bit and 32-bit code, page 16-6) */

  // __KERNEL_CS:[(uint32*)code32]'e git;
  .byte   0x66, 0xea
code32: .long   0x1000          // <xref linkend="linux-i386-boot-code-howto-prepare_protmode"/>
                                // içinde üstüne yazılır
  .word   __KERNEL_CS           // bölüt 0x10
  // bakınız linux/arch/i386/boot/compressed/head.S:startup_32
}</screen>
   <para>
Uzak <literal>jmp</literal> komutu (0xea) CS kaydedicisini günceller. kalan bölüt kaydedicileri (DS, SS, ES, FS ve GS) içeriği daha sonra yeniden yüklenmelidir. terim boyutu öneki (0x66) <literal>jmp</literal>'ı 32 bitlik terim <literal>code32</literal>'ye kadar çalıştırılmasına zorlamak için kullanılır. Terim boyutu öneki ayrıntıları için bakınız: IA-32 Manual (Vol.1. Ch.3.6. Operand-size and Address-size Attributes, and Vol.3. Ch.17. Mixing 16-bit and 32-bit Code).
      </para>
   <para>
Denetim <literal>linux/arch/i386/boot/compressed/head.S:startup_32</literal>'ye geçirilir. <literal>zImage</literal> için 0x1000 adresinde; <literal>bzImage</literal> için 0x100000 adresinde. Bakınız: <xref linkend="linux-i386-boot-code-howto-compressed_head"/>.
      </para>
   <para>
ESI toplanan sistem verilerinin bellek alanını gösterir. 16 bitlik gerçek kip çekirdek kodundan 32 bitlik kısma değiştirge geçirmek için kullanılır. Ayrıntılar için <filename>linux/Documentation/i386/zero-page.txt</filename> dosyasına bakınız.
      </para>
   <para>
Daha fazla anahtarlama ayrıntısı için IA-32 Manual Vol.3. (Ch.9.8. Software Initialization for Protected-Mode Operation, Ch.9.9.1. Switching to Protected Mode, and Ch.17.4. Transferring Control Among Mixed-Size Code Segments) belgesine başvurun.
      </para>
  </sect2>
  <sect2 xml:id="linux-i386-boot-code-howto-setup_misc">
   <title>Muhtelif</title>
   <para>
Kalanlar destek işlevleri ve değişkenleridir.
      </para>
<screen>/* linux/Makefile hedefleri tarafından oluşturulan makrolar:
 *   include/linux/compile.h ve include/linux/version.h */
kernel_version: .ascii  UTS_RELEASE
                .ascii  " ("
                .ascii  LINUX_COMPILE_BY
                .ascii  "@"
                .ascii  LINUX_COMPILE_HOST
                .ascii  ") "
                .ascii  UTS_VERSION
                .byte   0

///////////////////////////////////////////////////////////////////////////////
default_switch() { cli; outb(0x80, 0x70); } /* Kesmeleri ve NMI'yi iptal et */
bootsect_helper(ES:BX); /* bkz. <xref linkend="linux-i386-boot-code-howto-bootsect_helper"/> */

///////////////////////////////////////////////////////////////////////////////
a20_test()
{
  FS = 0;
  GS = 0xFFFF;
  CX = A20_TEST_LOOPS;                    // i.e. 32
  AX = FS:[0x200];
  do {
a20_test_wait:
    FS:[0x200] = ++AX;
    delay();
  } while (AX==GS:[0x210] &amp;&amp; --CX);
  return (AX!=GS[0x210]);
  // ZF==0 (i.e. NZ/NE, a20_test!=0) means test passed
}

///////////////////////////////////////////////////////////////////////////////
// klavye komut kuyruğu boş mu, bak
empty_8042()
{
  int timeout = 100000;

  for (;;) {
empty_8042_loop:
          if (!--timeout) return;
          delay();
          inb(0x64, &amp;AL);                 // 8042 durum portu
          if (AL &amp; 1) {                   // çıktı
            delay();
            inb(0x60, &amp;AL);               // oku
no_output:} else if (!(AL &amp; 2)) return;   // girdi yok
  }
}

///////////////////////////////////////////////////////////////////////////////
// CMOS saatini oku, AL'den saniyeyi döndür, video.S'de kullanılır
gettime()
{
  int1A/AH=02h();
  /* <link xlink:href="http://www.ctyme.com/intr/rb-2273.htm">int1A/AH=02h: SAAT - GERÇEK SAAT ZAMANINI AL</link>
    * DH = BCD gösterimli saniye*/
  AL = DH &amp; 0x0F;
  AH = DH &gt;&gt; 4;
  aad;
}

///////////////////////////////////////////////////////////////////////////////
delay() { outb(AL, 0x80); }                     // I/O yaptıktan sonra gerekli

// Tanımlayıcı tablo
gdt:
  .word   0, 0, 0, 0                      # dummy
  .word   0, 0, 0, 0                      # kullanılmadı
  // bölüt 0x10, __KERNEL_CS
  .word   0xFFFF                          # 4Gb - (0x100000*0x1000 = 4Gb)
  .word   0                               # taban adres = 0
  .word   0x9A00                          # kodu oku/çalıştır
  .word   0x00CF                          # tanelilik (granularity) = 4096, 386
                                          #  (sınırın 5. yarım baytı)
  // bölüt 0x18, __KERNEL_DS
  .word   0xFFFF                          # 4Gb - (0x100000*0x1000 = 4Gb)
  .word   0                               # taban adres = 0
  .word   0x9200                          # veri oku/yaz
  .word   0x00CF                          # tanelilik = 4096, 386
                                          #  (sınırın 5. yarım baytı)
idt_48:
  .word   0                               # idt sınırı = 0
  .word   0, 0                            # idt tabanı = 0L
/* [gdt_48] komutla eşleşmesi için 0x0800 (2048) olmalı,
 *   Linux 2.2.22'nin yaptığı gibi. */
gdt_48:
  .word   0x8000                          # gdt sınırı=2048,
                                          #  256 GDT girdisi
  .word   0, 0                            # gdt tabanı (daha sonra doldurulur)

#include "video.S"

// setup.S'nin sonundaki imza:
{
setup_sig1:     .word   SIG1                    // 0xAA55
setup_sig2:     .word   SIG2                    // 0x5A5A
modelist:
}</screen>
   <para><filename>video.S</filename> içindeki video ayar ve algılama kodu:
   </para>
<screen>ASK_VGA = 0xFFFD  // defined in linux/include/asm-i386/boot.h
///////////////////////////////////////////////////////////////////////////////
video()
{
        pushw DS;               // farklı bölütler kullan
        FS = DS;
        DS = ES = CS;
        GS = 0;
        cld;
        basic_detect();         // temel kart türü testi (EGA/VGA/MDA/CGA)
#ifdef CONFIG_VIDEO_SELECT
  if (FS:[0x01FA]!=ASK_VGA) {     // kullanıcı seçimli video kipi
    mode_set();
    if (failed) {
      prtstr("You passed an undefined mode number.\n");
      mode_menu();
    }
  } else {
vid2:
    mode_menu();
  }
vid1:
#ifdef CONFIG_VIDEO_RETAIN
  restore_screen();               // ekran içeriğini geri yükle
#endif /* CONFIG_VIDEO_RETAIN */
#endif /* CONFIG_VIDEO_SELECT */
    mode_params();                  // kip değiştirgelerini sakla
    popw ds;                        // orjinal DS'yi geri yükle
}</screen>
   <para>
/* YAPILACAKLAR: video() ayrıntıları */
   </para>
  </sect2>
  <sect2 xml:id="linux-i386-boot-code-howto-setup_ref">
   <title>Kaynakça</title>
   <simplelist>
    <member>
     <link xlink:href="http://www.win.tue.nl/~aeb/linux/kbd/A20.html">A20 - a pain from the past</link>
    </member>
    <member><link xlink:href="http://www.student.cs.uwaterloo.ca/~cs452/postscript/book.ps">Real-time Programming</link> Appendix A: Complete I/O Port List
          </member>
    <member>
     <link xlink:href="http://developer.intel.com/design/pentium4/manuals/"> IA-32 Intel Architecture Software Developer's Manual</link>
    </member>
    <member>
Summary of empty_zero_page layout (kernel point of view):  <filename>linux/Documentation/i386/zero-page.txt</filename>
          </member>
   </simplelist>
  </sect2>
 </sect1>
 <sect1 xml:id="linux-i386-boot-code-howto-compressed_head">
  <title>linux/arch/i386/boot/compressed/head.S</title>
  <para>
Artık <literal>bvmlinux</literal> içindeyiz! <literal>misc.c:decompress_kernel()</literal>'in yardımıyla, çekirdek imgemiz <filename>linux/vmlinux</filename>'u elde etmek için <literal>piggy.o</literal>'yu açacağız.
    </para>
  <para>
Bu dosya saf 32 bitlik açılış kodudur. Önceki iki dosyadan farklı olarak kaynak kodun içinde hiç <literal>.code16</literal> deyimi yoktur. Ayrıntılar için <link xlink:href="http://www.gnu.org/software/binutils/manual/gas-2.9.1/html_chapter/as_16.html#SEC205">Using as: Writing 16-bit Code</link> belgesine başvurun.
    </para>
  <sect2 xml:id="linux-i386-boot-code-howto-decompress_kernel">
   <title>Sıkıştırılmış Çekirdeğin Açılması</title>
   <para>
Bölüt tanımlayıcılarındaki (bölüt seçicisi __KERNEL_CS ve __KERNEL_DS'ye tekabül eden) bölüt taban adresleri 0'a eşittir; bu yüzden, eğer bu iki adresten her ikisi de kullanıldıysa, mantıksal konum adresi (bölüt:konum biçiminde) kendi doğrusal adresine eşit olacaktır. <literal>zImage</literal> için, CS:EIP şimdi 10:1000 mantıksal adresinde (doğrusal 0x1000 adresi), <literal>bzImage</literal> ise 10:100000 (doğrusal 0x100000) adresindedir.
      </para>
   <para>
Sayfalama etkinleştirilmediği için doğrusal adres fiziksel adres ile özdeştir. Adres konuları için IA-32 Manual (Vol.1. Ch.3.3. Memory Organization, and Vol.3. Ch.3. Protected-Mode Memory Management) ve <link xlink:href="http://www.xml.com/ldd/chapter/book/ch13.html#t1">Linux Device Drivers: Memory Management in Linux</link> belgelerine bakınız.
      </para>
   <para>
BX=0 ve ESI=INITSEG&lt;&lt;4 olması <filename>setup.S</filename>'den ileri gelir.
      </para>
<screen>.text
///////////////////////////////////////////////////////////////////////////////
startup_32()
{
  cld;
  cli;
  DS = ES = FS = GS = __KERNEL_DS;
  SS:ESP = *stack_start;  // user_stack[] sonu, misc.c içinde tanımlı
  // korumalı kip etkinleştirildikten sonra
  // tüm bölüt kaydedicileri yeniden yüklenir

  // A20'nin gerçekten etkin olup olmadığını kontrol et
  EAX = 0;
  do {
1:  DS:[0] = ++EAX;
  } while (DS:[0x100000]==EAX);

  EFLAGS = 0;
  clear BSS;                              // _edata'dan _end'e

  struct moveparams mp;                   // subl $16,%esp
  if (!decompress_kernel(&amp;mp, ESI)) {     // AX'deki değeri döndür
    ESI'yi yığıttan geri yükle;
    EBX = 0;
    goto __KERNEL_CS:100000;
    // bkz. linux/arch/i386/kernel/head.S:startup_32
  }

  /*
  * Yüksek yüklediysek buraya geliriz.
  * move-in-place rutinini aşağı 0x1000'e taşımamız gerekir
  * ve sonra yığıttan aldığımız yazmaçlardaki
  * tampon adresleri ile başlatırız.
  */
3:   move_rountine_start..move_routine_end 0x1000'e taşı;
  // move_routine_start &amp; move_routine_end aşağıda tanımlanmıştır

  // move_routine_start() değiştirgelerini hazırla
  EBX = real mode pointer;        // ESI değeri setup.S'den geçer
  ESI = mp.low_buffer_start;
  ECX = mp.lcount;
  EDX = mp.high_buffer_star;
  EAX = mp.hcount;
  EDI = 0x100000;
  cli;                    // kesme almadığımızdan emin ol.
  goto __KERNEL_CS:1000;  // move_routine_start();
}

/* Eğer yüksek yüklediysek, yerinde çözülmüş çekirdeği taşımak için
 * yordam (şablon). Bu PIC kodu olmalı! */
///////////////////////////////////////////////////////////////////////////////
move_routine_start()
{
  mp.low_buffer_start'ı 0x100000'a taşı, mp.lcount bayt,
    iki adımda: (lcount &gt;&gt; 2) kelime + (lcount &amp; 3) bayt;
  move/append mp.high_buffer_start, ((mp.hcount + 3) &gt;&gt; 2) kelime
  // 1 kelime == 4 bayt, 32 bitlik kod/veri anlamında.

  ESI = EBX;              // gerçek kip gösterici, setup.S'deki gibi
  EBX = 0;
  goto __KERNEL_CS:100000;
  // bkz. linux/arch/i386/kernel/head.S:startup_32()
move_routine_end:
}</screen>
   <para><literal>je 1b</literal> ve <literal>jnz 3f</literal>'nin anlamları için <link xlink:href="http://www.gnu.org/software/binutils/manual/gas-2.9.1/html_chapter/as_5.html#SEC48">Using as: Local Symbol Names</link> belgesine başvurunuz.
      </para>
   <para><literal>_edata</literal> ve <literal>_end</literal> tanımlamalarını bulamadınız mı? Sorun değil, onlar "dahili ilintileme betiği" içinde tanımlanmıştır. <option>-T</option> (<option>--script=</option>) seçeneği belirtilmeksizin kullanılırsa, <command>ld</command> bu yerleşik betiği <literal>compressed/bvmlinux</literal>'u ilintilemek için kullanır. Bu betiği görüntülemek için "<command>ld --verbose</command>" komutunu kullanınız ya da <xref linkend="linux-i386-boot-code-howto-internel_lds"/> bölümüne bakınız.
      </para>
   <para>
-T (--script=), -L (--library-path=) ve --verbose seçimlerinin tarifi için <link xlink:href="http://www.gnu.org/software/binutils/manual/ld-2.9.1/html_chapter/ld_2.html#SEC3">Using LD, the GNU linker: Command Line Options</link> belgesine başvurunuz. Ayrıca "<command>man ld</command>" ve "<command>info ld</command>" de yardımcı olabilir.
      </para>
   <para><literal>piggy.o</literal> çözüldü ve kontrol __KERNEL_CS:100000'ye geçirildi, örn.  <literal>linux/arch/i386/kernel/head.S:startup_32()</literal>. Bakınız <xref linkend="linux-i386-boot-code-howto-kernel_head"/>.
      </para>
<screen>#define LOW_BUFFER_START      0x2000
#define LOW_BUFFER_MAX       0x90000
#define HEAP_SIZE             0x3000
///////////////////////////////////////////////////////////////////////////////
asmlinkage int decompress_kernel(struct moveparams *mv, void *rmode)
|-- setup real_mode(=rmode), vidmem, vidport, lines and cols;
|-- if (is_zImage) setup_normal_output_buffer() {
|       output_data      = 0x100000;
|       free_mem_end_ptr = real_mode;
|   } else (is_bzImage) setup_output_buffer_if_we_run_high(mv) {
|       output_data      = LOW_BUFFER_START;
|       low_buffer_end   = MIN(real_mode, LOW_BUFFER_MAX) &amp; ~0xfff;
|       low_buffer_size  = low_buffer_end - LOW_BUFFER_START;
|       free_mem_end_ptr = &amp;end + HEAP_SIZE;
|       // get mv-&gt;low_buffer_start and mv-&gt;high_buffer_start
|       mv-&gt;low_buffer_start = LOW_BUFFER_START;
|       /* To make this yazılım work, we must have
|        *   high_buffer_start &gt; &amp;end+HEAP_SIZE;
|        * As we will move low_buffer from LOW_BUFFER_START to 0x100000
|        *   (max low_buffer_size bytes) finally, we should have
|        *   high_buffer_start &gt; 0x100000+low_buffer_size; */
|       mv-&gt;high_buffer_start = high_buffer_start
|           = MAX(&amp;end+HEAP_SIZE, 0x100000+low_buffer_size);
|       mv-&gt;hcount =  0 if (0x100000+low_buffer_size &gt;  &amp;end+HEAP_SIZE);
|                  = -1 if (0x100000+low_buffer_size &lt;= &amp;end+HEAP_SIZE);
|       /* mv-&gt;hcount==0 : we need not move high_buffer later,
|        *   as it is already at 0x100000+low_buffer_size.
|        * Used by close_output_buffer_if_we_run_high() below. */
|   }
|-- makecrc();          // create crc_32_tab[]
|   puts("Uncompressing Linux... ");
|-- gunzip();
|   puts("Ok, booting the kernel.\n");
|-- if (is_bzImage) close_output_buffer_if_we_run_high(mv) {
|       // get mv-&gt;lcount and mv-&gt;hcount
|       if (bytes_out &gt; low_buffer_size) {
|           mv-&gt;lcount = low_buffer_size;
|           if (mv-&gt;hcount)
|               mv-&gt;hcount = bytes_out - low_buffer_size;
|       } else {
|           mv-&gt;lcount = bytes_out;
|           mv-&gt;hcount = 0;
|       }
|   }
`-- return is_bzImage;  // return value in AX
</screen>
   <para>
    <literal>end</literal> "dahili ilintileme betiği" içinde de tanımlanmıştır.
   </para>
   <para>
    <literal>decompress_kernel()</literal> bir <literal>asmlinkage</literal> değiştiricisine sahiptir. <filename>linux/include/linux/linkage.h</filename> dosyasında:
   </para>
<screen>#ifdef __cplusplus
#define CPP_ASMLINKAGE extern "C"
#else
#define CPP_ASMLINKAGE
#endif

#if defined __i386__
#define asmlinkage CPP_ASMLINKAGE __attribute__((regparm(0)))
#elif defined __ia64__
#define asmlinkage CPP_ASMLINKAGE __attribute__((syscall_linkage))
#else
#define asmlinkage CPP_ASMLINKAGE
#endif</screen>
   <para><literal>asmlinkage</literal> makrosu derleyiciyi yığıttaki tüm işlev değiştirgelerini aktarması için (bazı eniyileştirme yöntemleri bunu değiştirmeye çalışsa bile) zorlayacaktır. Ayrıntılar için <link xlink:href="http://gcc.gnu.org/onlinedocs/gcc-3.3.2/gcc/Function-Attributes.html#Function%20Attributes">Using the GNU Compiler Collection (GCC): Declaring Attributes of Functions</link> (regparm) ve <link xlink:href="http://kernelnewbies.org/faq/index.php3#asmlinkage">Kernelnewbies FAQ: What is asmlinkage</link> belgelerine bakınız.
   </para>
  </sect2>
  <sect2 xml:id="linux-i386-boot-code-howto-gunzip">
   <title>gunzip()</title>
   <para><literal>decompress_kernel()</literal> sadece <literal>bzImage</literal> için sıkıştırılmış çekirdek imgesini düşük (<literal>output_data</literal> ile gösterilen) ve yüksek (<literal>high_buffer_start</literal> ile gösterilen) tamponlara açmak için <filename>linux/lib/inflate.c</filename> dosyasında tanımlı <literal>gunzip() -&gt; inflate()</literal> çağrısını yapar.
      </para>
   <para>
gzip dosya biçimi <link xlink:href="http://www.ietf.org/rfc/rfc1952.txt">RFC 1952</link> içinde belirtilmiştir.
      </para>
    <table frame="all">
     <title>gzip dosya biçimi</title>
     <tgroup cols="4">
      <colspec colwidth=".11"/>
      <colspec colwidth=".39"/>
      <colspec colwidth=".06"/>
      <colspec colwidth=".44"/>
      <thead>
       <row>
        <entry>Bileşen</entry>
        <entry>Açılımı</entry>
        <entry>Bayt sayısı</entry>
        <entry>Yorumu</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>ID1</entry>
        <entry>IDentification 1 (1. belirteç)</entry>
        <entry>1</entry>
        <entry>31 (0x1f, \037)</entry>
       </row>
       <row>
        <entry>ID2</entry>
        <entry>IDentification 2 (2. belirteç)</entry>
        <entry>1</entry>
        <entry>139 (0x8b, \213)<footnote><para>ID2 değeri gzip 0.5 için 158 (0x9e, \236) olabilir;</para></footnote></entry>
       </row>
       <row>
        <entry>CM</entry>
        <entry>Compression Method (Sıkıştırm Yöntemi)</entry>
        <entry>1</entry>
        <entry>8 - "deflate" sıkıştırma yöntemini gösterir</entry>
       </row>
       <row>
        <entry>FLG</entry>
        <entry>FLaGs (Seçenekler)</entry>
        <entry>1</entry>
        <entry>çoğu durumda 0</entry>
       </row>
       <row>
        <entry>MTIME</entry>
        <entry>Modification TIME (Değişiklik zamanı)</entry>
        <entry>4</entry>
        <entry>özgün dosyanın değişiklik zamanı</entry>
       </row>
       <row>
        <entry>XFL</entry>
        <entry>eXtra FLags (ek seçenekler)</entry>
        <entry>1</entry>
        <entry>2 - sıkıştırıcı en yavaş algoritmayı<footnote><para>XFL değeri 4 olduğunda ise sıkıştırıcı en hızlı algoritmayı kullanacaktır.</para></footnote> kullanır, azami sıkıştırma yapar</entry>
       </row>
       <row>
        <entry>OS</entry>
        <entry>Operating System (İşletim Sistemi)</entry>
        <entry>1</entry>
        <entry>3 - Unix</entry>
       </row>
       <row>
        <entry>ek alanlar</entry>
        <entry>-</entry>
        <entry>-</entry>
        <entry>değişken uzunluk, alan FLG ile belirtilir<footnote><para>FLG biti 0 olduğunda FTEXT, herhangi bir ek alan belirtmez.</para></footnote></entry>
       </row>
       <row>
        <entry>sıkıştırılmış bloklar</entry>
        <entry>-</entry>
        <entry>-</entry>
        <entry>değişken uzunluk</entry>
       </row>
       <row>
        <entry>CRC32</entry>
        <entry>-</entry>
        <entry>4</entry>
        <entry>sıkıştırılmamış verinin CRC değeri</entry>
       </row>
       <row>
        <entry>ISIZE</entry>
        <entry>Input SIZE (Girdi uzunluğu))</entry>
        <entry>4</entry>
        <entry>sıkıştırılmamış girdi verisi boyunun 2^32 ile bölümünden kalan</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   <para>
Bu dosya biçimi bilgisini gzipli <filename>linux/vmlinux</filename>'un başlangıcını bulmak için kullanabiliriz.
   </para>
<screen>[root@localhost boot]# <command>hexdump -C /boot/vmlinuz-2.4.20-28.9 | grep '1f 8b 08 00'</command>
00004c50  1f 8b 08 00 01 f6 e1 3f  02 03 ec 5d 7d 74 14 55  |.......?...]}t.U|
[root@localhost boot]# <command>hexdump -C /boot/vmlinuz-2.4.20-28.9 -s 0x4c40 -n 64</command>
00004c40  00 80 0b 00 00 fc 21 00  68 00 00 00 1e 01 11 00  |......!.h.......|
00004c50  1f 8b 08 00 01 f6 e1 3f  02 03 ec 5d 7d 74 14 55  |.......?...]}t.U|
00004c60  96 7f d5 a9 d0 1d 4d ac  56 93 35 ac 01 3a 9c 6a  |......M.V.5..:.j|
00004c70  4d 46 5c d3 7b f8 48 36  c9 6c 84 f0 25 88 20 9f  |MF\.{.H6.l..%. .|
00004c80
[root@localhost boot]# <command>hexdump -C /boot/vmlinuz-2.4.20-28.9 | tail -n 4</command>
00114d40  bd 77 66 da ce 6f 3d d6  33 5c 14 a2 9f 7e fa e9  |.wf..o=.3\...~..|
00114d50  a7 9f 7e fa ff 57 3f 00  00 00 00 00 d8 bc ab ea  |..~..W?.........|
00114d60  44 5d 76 d1 fd 03 33 58  c2 f0 00 51 27 00        |D]v...3X...Q'.|
00114d6e</screen>
   <para>
Yukarıdaki örnekte gzipli dosyanın 0x4c50 adresinde başladığını görebiliriz. "1f 8b 08 00"den önceki dört byte <literal>input_len</literal>'dir (küçük sonlu olarak 0x0011011e) ve 0x4c50+0x0011011e=0x114d6e değeri <literal>bzImage</literal> (<filename>/boot/vmlinuz-2.4.20-28.9</filename>) dosyasının boyuna eşittir.
      </para>
<screen>static uch *inbuf;           /* girdi tamponu */
static unsigned insize = 0;  /* inbuf içindeki geçerli baytlar*/
static unsigned inptr = 0;   /* inbuf içinde işlenecek sonraki baytın indisi */
///////////////////////////////////////////////////////////////////////////////
static int gunzip(void)
{
  Girdi tamponunu {ID1, ID2, CM} için kontrol et, şöyle olmalı:
          {0x1f, 0x8b, 0x08} (normal durum), veya
          {0x1f, 0x9e, 0x08} (gzip 0.5 için);
  FLG'yi (seçenek baytı) kontrol et, 1, 5, 6 ve 7. bitler atanmamalı;
  Ignore {MTIME, XFL, OS};
  FLG biti 2,3 ve 4'e karşılık gelen seçimlik yapıları yönet;
  inflate();              // sıkıştırılmış blokları yönet
  Validate {CRC32, ISIZE};
}</screen>
   <para><filename>linux/arch/i386/boot/compressed/misc.c</filename> içinde tanımlı <literal>get_byte()</literal> ilk defa çağırıldığında, girdi tamponunu <literal>inbuf=input_data</literal> ve <literal>insize=input_len</literal> olacak şekilde ayarlamak için <literal>fill_inbuf()</literal> işlevini çağırır. <literal>input_data</literal> ve <literal>input_len</literal> sembolleri <literal>piggy.o</literal> ilintileme betiğinde tanımlanmıştır. Bakınız <xref linkend="linux-i386-boot-code-howto-i386_boot_compressed_makefile"/>.
      </para>
  </sect2>
  <sect2 xml:id="linux-i386-boot-code-howto-inflate">
   <title>inflate()</title>
<screen>// misc.c içindeki bazı önemli tanımlamalar
#define WSIZE 0x8000            /* Pencere boyutu en azından 32k olmalı,
                                 * ve ikinin üssü olmalı */
static uch window[WSIZE];       /* Kayan pencere tamponu */
static unsigned outcnt = 0;     /* çıktı tamponundaki bayt sayısı */

// linux/lib/inflate.c
#define wp outcnt
#define flush_output(w) (wp=(w),flush_window())
STATIC unsigned long bb;        /* bit tamponu */
STATIC unsigned bk;             /* bit tamponundaki bit sayısı */
STATIC unsigned hufts;          /* belleği kullanımı izlemek*/
static long free_mem_ptr = (long)&amp;end;
///////////////////////////////////////////////////////////////////////////////
STATIC int inflate()
{
  int e;                  /* son blok seçeneği */
  int r;                  /* sonuç kod */
  unsigned h;             /* struct huft'un azami belleği */
  void *ptr;

  wp = bb = bk = 0;

  // sıkıştırılmış blokları birer birer şişir (inflate)
  do {
          hufts = 0;
          gzip_mark() { ptr = free_mem_ptr; };
          if ((r = inflate_block(&amp;e)) != 0) {
                  gzip_release() { free_mem_ptr = ptr; };
                  return r;
          }
          gzip_release() { free_mem_ptr = ptr; };
          if (hufts &gt; h)
          h = hufts;
  } while (!e);

  /* Çok fazla ileri bakmayı (lookahead) geri al. Sonraki okuma bayt hizalı
   * olacak böylece son anlamlı bayttaki kullanılmayan bitleri çıkarabileceğiz.
   */
  while (bk &gt;= 8) {
          bk -= 8;
          inptr--;
  }

  /* çıktı penceresini (window[0..outcnt-1]) çıktı verisine (output_data) yaz,
    * output_ptr/output_data, crc ve bytes_out'u da buna bağlı olarak güncelle
    * ve outcnt'yi 0'a ayarla. */
  flush_output(wp);

  /* başarılı olduğunu döndür */
  return 0;
}</screen>
   <para><literal>free_mem_ptr</literal> dinamik bellek tahsisi için <literal>misc.c:malloc()</literal> içinde kullanılır. Sıkıştırılmış her bir bloğu şişirmeden önce, <literal>gzip_mark()</literal> <literal>free_mem_ptr</literal> değerini saklar. Şişirmeden sonra <literal>gzip_release()</literal> bu değeri geri yükleyecektir. Bu <literal>inflate_block()</literal> içinde ayırılan belleğin serbest bırakılma işlemidir.
      </para>
   <para><link xlink:href="http://www.gzip.org">Gzip</link> dosyaları sıkıştırmak için Lempel-Ziv (LZ77) kodlamasını kullanır. Sıkıştırılmış veri biçimi <link xlink:href="http://www.ietf.org/rfc/rfc1951.txt">RFC 1951</link> içinde belirtilmiştir. <literal>inflate_block()</literal> bit düzeni olarak ele alınabilen sıkıştırılmış blokları şişirir.
      </para>
   <para>
Sıkıştırılmış her bir bloğun veri yapısı anahatlarıyla şöyledir:
      </para>
<literallayout>
BFINAL (1 bit)
  0  - son blok değil
  1  - son blok
BTYPE  (2 bit)
  00 - sıkıştırma yok
      bayt sınırına kadar kalan bitler;
      LEN      (2 bayt);
      NLEN     (2 bayt, LEN'in tamamlayıcısı);
      data     (LEN bayt);
  01 - düzeltilmiş Huffman kodu ile sıkıştırılmış
      {
      literal  (7-9 bitleri, 256 hariç 0..287 kodunu temsil eder);
                    // Bakınız RFC 1951, 3.2.6 paragrafındaki tablo.
      length   (0-5 bitleri, literal &gt; 256 ise 3..258 arasında bir uzunluktur);
                    // Bkz. RFC 1951, 3.2.5 paragrafındaki 1. alfabe tablosu.
      data     (literal &lt; 256 ise literal baytlarının verileri);
      distance (literal == 257..285 ise 5 artı 0-13 ek bit,
                        1..32768 arasında bir mesafe belirtir;
                /* Bakınız RFC 1951, 3.2.5 paragrafındaki 2. alfabe tablosu,
                  * 3.2.6 paragrafındaki deyim değil*/
                /* Çıktı akımında "distance" bayt geri git
                  * ve "length" baytı kopyala. */
      }*        // çok sayıda örnek olabilir
      literal  (7 bit, tümü 0, literal == 256, blok sonu belirtir);
  10 - Dinamik Huffman koduyla sıkıştırılmış
      HLIT     (5 bit, Literal/Length kodlarının sayısı - 257, 257-286);
      HDIST    (5 bit, Distance kodlarının sayısı       - 1, 1-32);
      HCLEN    (4 bit, Code Length kodlarının sayısı    - 4, 4 - 19);
      Code Length dizisi    ((HCLEN+4)*3 bit)
      /* Aşağıdaki 2 alfabe tablosu, önceki Code Length dizisinden üretilen
        * Huffman kod çözme tablosu kullanılarık çözülecektir. */
      Literal/Length alfabesi (HLIT+257 kod)
      Distance alfabesi       (HDIST+1 kod)
      // Kod çözme tabloları bu alfabe tablolarından oluşturur.
      /* Aşağıdaki, farklı kod çözme tabloları kullanmak dışında düzeltilmiş
        * Huffman kodları kısmı ile benzerlik gösterir. */
      {
      literal/length
                (değişken uzunluk, Literal/Length alfabesine bağımlı);
      data     (literal &lt; 256 ise literal baytlarının verisi);
      distance (literal == 257..285 ise değişken uzunlukta,
                        Distance alfabesine bağımlı);
      }*           // çok sayıda örnek olabilir
      literal  (literal değeri 256, blok sonu anlamında);
  11 - reserved (hata)
</literallayout>
   <para>
Dikkat ederseniz Huffman kodları MSB'den başlarken, veri elemanları En-Değersiz-Bit'ten (Least-Significant Bit - LSB) başlayıp En-Değerli-Bit'e (Most-Significant Bit - MSB) kadar byte'ları paketler. Ayrıca <literal>literal</literal> değerleri 286-287 ve <literal>distance</literal> kodları 30-31'in asla oluşmayacağına dikkat edin.
      </para>
   <para>
RFC 1951 ve yukarıdaki veri yapısı elinizdeyken <literal>inflate_block()</literal> işlevini anlamak çok da zor olmayacaktır. Huffman kodlaması ve alfabe tablosu üretimi için RFC 1951 içindeki ilgili paragraflara başvurunuz.
      </para>
   <para>
Daha fazla ayrıntı için <filename>linux/lib/inflate.c</filename> belgesine, gzip kaynak koduna (bir çok yorum satırı var) ve ilgili başvuru materyallerine bakınız.
      </para>
  </sect2>
  <sect2 xml:id="linux-i386-boot-code-howto-chead_ref">
   <title>Kaynakça</title>
    <simplelist>
     <member>
      <link xlink:href="http://www.gnu.org/software/binutils/manual/gas-2.9.1/">Using as</link>
     </member>
     <member>
      <link xlink:href="http://www.gnu.org/software/binutils/manual/ld-2.9.1/">Using LD, the GNU linker</link>
     </member>
     <member>
      <link xlink:href="http://developer.intel.com/design/pentium4/manuals/">IA-32 Intel Architecture Software Developer's Manual</link>
     </member>
     <member>
      <link xlink:href="http://www.gzip.org"> The gzip home page</link>
     </member>
     <member>
      <link xlink:href="http://freshmeat.net/projects/gzip">gzip (freshmeat.net)</link>
     </member>
     <member>
      <link xlink:href="http://www.ietf.org/rfc/rfc1951.txt"> RFC 1951: DEFLATE Compressed Data Format Specification version 1.3</link>
     </member>
     <member>
      <link xlink:href="http://www.ietf.org/rfc/rfc1952.txt">RFC 1952: GZIP file format specification version 4.3</link>
     </member>
    </simplelist>
  </sect2>
 </sect1>
 <sect1 xml:id="linux-i386-boot-code-howto-kernel_head">
  <title>linux/arch/i386/kernel/head.S</title>
  <para>
Sonunda çekirdek imgesi <filename>linux/vmlinux</filename> yerini aldı. İki girdiye ihtiyaç var:
    </para>
   <simplelist>
    <member>
16 bitlik gerçek kip kodunun yerini göstermek için <literal>ESI</literal>; INITSEG&lt;&lt;4 durumu;
     </member>
     <member>
Hangi işlemcinin çalıştığını belirtmek için <literal>BX</literal>, 0 BSP anlamına gelir, diğer değerler AP için.
    </member>
   </simplelist>
  <para>
ESI, daha sonra <literal>empty_zero_page</literal>'e kopyalanacak 16 bitlik gerçek kip kodundaki değiştirge alanını gösterir. ESI sadece BSP için geçerlidir.
    </para>
  <para>
BSP (BootStrap Processor) ve APler (Application Processors) Intel terminolojileridir. Çoklu işlemci (MP) ilklendirme işlemleri hakkında bakınız: IA-32 Manual (Vol.3. Ch.7.5. Multiple-Processor (MP) Initialization) ve <link xlink:href="http://www.intel.com/design/pentium/datashts/242016.htm">MultiProcessor Specification</link>.
    </para>
  <para>
Yazılım açısından bakıldığında, çok işlemcili bir sistemde, BSP ve APler fiziksel belleği paylaşırlar, fakat kendi yazmaç kümelerini kullanırlar. BSP ilk olarak çekirdek kodunu çalıştırır, işletim sistemi çalıştırma ortamını kurar ve APleri de onun üzerinde çalışması için tetikler. AP BSP onu uyarıncaya kadar uyku kipinde kalır.
    </para>
  <sect2 xml:id="linux-i386-boot-code-howto-enable_paging">
   <title>Sayfalamayı Etkinleştir</title>
<screen>.text
///////////////////////////////////////////////////////////////////////////////
startup_32()
{
  /* bölütleri bilinen değerlere ata */
  cld;
  DS = ES = FS = GS = __KERNEL_DS;

#ifdef CONFIG_SMP
#define cr4_bits mmu_cr4_features-__PAGE_OFFSET
  /* long mmu_cr4_features linux/arch/i386/kernel/setup.c içinde tanımlı
    * __PAGE_OFFSET = 0xC0000000, örn. 3G */

  // CR4 desteği ile ApP (&gt; Intel 486) CR'ü BSP'den kopyalayacak
  if (BX &amp;&amp; cr4_bits) {
    // sayfalama seçeneklerini aç (turn on) (PSE, PAE, ...)
    CR4 |= cr4_bits;
  } else
#endif
  {
    /* sayfa tablolarını (pg0..empty_zero_page-1) sadece BSP ilklendirir
      *   .org 0x2000'de pg0
      *   .org 0x4000'de empty_zero_page
      *   toplam (0x4000-0x2000)/4 = 0x0800 girdi */
    pg0 = {
      0x00000007,             // 7 = PRESENT + RW + USER
      0x00001007,             // 0x1000 = 4096 = 4K
      0x00002007,
      ...
    pg1:    0x00400007,
      ...
      0x007FF007              // toplam 8M
    empty_zero_page:
    };
  }</screen>
   <para>
Bir çekirdek sembolüne başvuracağımız zaman neden <literal>-__PAGE_OFFSET</literal> eklemek zorundayız, örneğin <literal>pg0</literal> gibi?
      </para>
   <para><filename>linux/arch/i386/vmlinux.lds</filename> içinde şunlar bulunur:
      </para>
<screen>  . = 0xC0000000 + 0x100000;
  _text = .;                    /* Metin ve salt-okunur veri */
  .text : {
        *(.text)
...</screen>
   <para><filename>linux/vmlinux</filename> için bağlanacak ilk dosya olan <filename>linux/arch/i386/kernel/head.o</filename> içinde, <literal>pg0 .text</literal> bölümü 0x2000 konumunda olduğu için, çıktı bölümü <literal>.text </literal> içinde 0x2000 konumunda olacaktır. Böylece ilintilendikten sonra 0xC0000000+0x100000+0x2000 adresinde olacaktır.
      </para>
<screen>[root@localhost boot]# <command>nm --defined /boot/vmlinux-2.4.20-28.9 | \</command>
<command>grep 'startup_32\|mmu_cr4_features\|pg0\|\&lt;empty_zero_page\&gt;' | sort</command>
c0100000 t startup_32
c0102000 T pg0
c0104000 T empty_zero_page
c0376404 B mmu_cr4_features
</screen>
   <para>
Korumalı kipte sayfalama etkinleştirilmeden, doğrusal adres doğrudan fiziksel adrese eşlenecektir. "<literal>movl $pg0-__PAGE_OFFSET,%edi</literal>" <literal>pg0</literal>'ın fiziksel adresine eşit olan <literal>EDI=0x102000</literal> değerini atayacaktır (<filename>linux/vmlinux</filename> 0x100000 adresine yerleştirildiği için). <literal>-PAGE_OFFSET</literal> şeması olmadan, yanlış ve muhtemelen RAM alanının ötesinde olacak 0xC0102000 fiziksel adresine erişecektir.
      </para>
   <para><literal>mmu_cr4_features .bss</literal> bölümü içindedir ve yukarıdaki örnekte 0x376404 fiziksel adresine yerleştirilmiştir.
      </para>
   <para>
Sayfa tablosu ilklendirildikten sonra sayfalama etkinleştirilebilir.
      </para>
<screen>  // sayfa dizini temel göstericisini ata, fiziksel adres
  CR3 = swapper_pg_dir - __PAGE_OFFSET;
  // sayfalama etkin!
  CR0 |= 0x80000000;      // PG bitini ayarla
  goto 1f;                // flush prefetch-queue
1:
  EAX = &amp;1f;          // sonraki komutu takip eden adres
  goto *(EAX);            // EIP'yi yeniden konumla
1:
  SS:ESP = *stack_start;
</screen>
   <para>
Sayfa dizini <literal>swapper_pg_dir</literal> (<xref linkend="linux-i386-boot-code-howto-khead_misc"/> bölümündeki tanımlamalara bakınız), sayfa tabloları <literal>pg0</literal> ve <literal>pg1</literal> ile birlikte, doğrusal 0..8M-1 ve 3G..3G+8M-1 adreslerinin her ikisinin de 0..8M-1 fiziksel adresine eşlendiğini belirtir. Artık çekirdek sembollerine "<literal>-__PAGE_OFFSET</literal>" olmadan erişebiliriz. Çünkü çekirdek alanı (&gt;=3G doğrusal adresinde bulunur) sayfalama etkinleştirildikten sonra doğru bir şekilde kendi fiziksel adresine eşlenecektir.
      </para>
   <para>
"<literal>lss stack_start,%esp</literal>" (<literal>SS:ESP = *stack_start</literal>) yeni bir yığıt kuran "<literal>-PAGE_OFFSET</literal>" olmadan bir sembole başvuran ilk örnektir. BSP için, yığıt <literal>init_task_union</literal>'ın sonundadır. AP için, <literal>stack_start.esp</literal> <literal>linux/arch/i386/kernel/smpboot.c:do_boot_cpu()</literal> tarafından <xref linkend="linux-i386-boot-code-howto-smp_init"/> içinde "<literal>(void *) (1024 + PAGE_SIZE + (char *)idle)</literal>" olacak şekilde yeniden tanımlanmıştır.
      </para>
   <para>
Sayfalama mekanizmaları ve veri yapıları için bakınız: IA-32 Manual Vol.3. (Ch.3.7. Page Translation Using 32-Bit Physical Addressing, Ch.9.8.3. Initializing Paging, Ch.9.9.1. Switching to Protected Mode ve Ch.18.26.3. Enabling and Disabling Paging).
      </para>
  </sect2>
  <sect2 xml:id="get_kernel_para">
   <title>Çekirdek Değiştirgelerini Al</title>
<screen>#define OLD_CL_MAGIC_ADDR       0x90020
#define OLD_CL_MAGIC            0xA33F
#define OLD_CL_BASE_ADDR        0x90000
#define OLD_CL_OFFSET           0x90022
#define NEW_CL_POINTER          0x228   /* Gerçek kip veriye göreli */

#ifdef CONFIG_SMP
  if (BX) {
    EFLAGS = 0;             // AP EFLAGS'leri temizler
  } else
#endif
  {
    // İlk CPU BSS'yi temizler
    clear BSS;              // örn. __bss_start .. _end
    setup_idt() {
      /* idt_table[256]; arch/i386/kernel/traps.c içinde tanımlı
        *   .data.idt bölümüne yerleştirilmiş
      EAX = __KERNEL_CS &lt;&lt; 16 + ignore_int;
      DX = 0x8E00;    // kesme kapısı, dpl = 0, mevcut
      idt_table[0..255] = {EAX, EDX};
    }
    EFLAGS = 0;
    /*
      * Önyükleme değiştirgelerini yolun dışına kopyala (ayak altından al).
      * _empty_zero_page'in ilk 2kB'lık bölümü önyükleme değiştirgeleri için,
      * ikinci 2kB'lık bölümü komut satırı içindir.
      */
    taşı *ESI (gerçek kip başlık)'dan empty_zero_page'e, 2KB;
    temizle empty_zero_page+2K, 2KB;
    ESI = empty_zero_page[NEW_CL_POINTER];
    if (!ESI) {             // 32 bitlik komut satırı göstericisi
      if (OLD_CL_MAGIC==(uint16)[OLD_CL_MAGIC_ADDR]) {
        ESI = [OLD_CL_BASE_ADDR]
              + (uint16)[OLD_CL_OFFSET];
        taşı *ESI'dan empty_zero_page+2K'ya, 2KB;
      }
    } else {                // 2.02+'da geçerli
      taşı *ESI'dan empty_zero_page'e, 2KB;
    }
  }
}</screen>
   <para>
BSP için çekirdek değiştirgeleri <literal>ESI</literal> tarafından gösterilen bellekten <literal>empty_zero_page</literal>'e  kopyalanır. Eğer uygulanabilir ise çekirdek komut satırı <literal>empty_zero_page+2K</literal>'ya kopyalanacaktır.
      </para>
  </sect2>
  <sect2 xml:id="linux-i386-boot-code-howto-check_cpu_type">
   <title>İşlemci Türünü Kontrol Et</title>
   <para>
İşlemci türünün ve işlemci içeriğinin nasıl belirlendiği konusunda bakınız: IA-32 Manual Vol.1. (Ch.13. Processor Identification and Feature Determination).
      </para>
<screen>struct cpuinfo_x86;                  // bakınız: include/asm-i386/processor.h
struct cpuinfo_x86 boot_cpu_data;    // bakınız: arch/i386/kernel/setup.c

#define CPU_PARAMS      SYMBOL_NAME(boot_cpu_data)
#define X86             CPU_PARAMS+0
#define X86_VENDOR      CPU_PARAMS+1
#define X86_MODEL       CPU_PARAMS+2
#define X86_MASK        CPU_PARAMS+3
#define X86_HARD_MATH   CPU_PARAMS+6
#define X86_CPUID       CPU_PARAMS+8
#define X86_CAPABILITY  CPU_PARAMS+12
#define X86_VENDOR_ID   CPU_PARAMS+28

checkCPUtype:
{
  X86_CPUID = -1;                 // CPUID yok

  X86 = 3;                        // en azından 386
  save original EFLAGS to ECX;
  flip AC bit (0x40000) in EFLAGS;
  if (AC bit not changed) goto is386;

  X86 = 4;                        // en azından 486
  flip ID bit (0X200000) in EFLAGS;
  restore original EFLAGS;        //  AC ve ID seçenekleri için
  if (ID bit değişemez) goto is486;

  // işlemci bilgilerini al
  CPUID(EAX=0);
  X86_CPUID = EAX;
  X86_VENDOR_ID = {EBX, EDX, ECX};
  if (!EAX) goto is486;

  CPUID(EAX=1);
  CL = AL;
  X86 = AH &amp; 0x0f;                // aile
  X86_MODEL = (AL &amp; 0xf0) &gt;&gt; 4;   // model
  X86_MASK = CL &amp; 0x0f;           // adımlama kimliği (stepping id)
  X86_CAPABILITY = EDX;               // özellik
</screen>
   <para>
x87 aritmetik işlemcisinin ayarlanışı için bakınız: IA-32 Manual Vol.3. (Ch.9.2. x87 FPU Initialization, and Ch.18.14. x87 FPU).
      </para>
<screen>is486:
  // PG, PE, ET'yi kaydet AM, WP, NE, MP'yi ise ayarla
  EAX = (CR0 &amp; 0x80000011) | 0x50022;
  goto 2f;                   // "is386:" işlemeyi atla
is386:
  orjinal EFLAGS'ları ECX'den yeniden al;
  // PG, PE, ET'yi kaydet MP'yi ayarla
  EAX = (CR0 &amp; 0x80000011) | 0x02;

  /* ET: Eklenti Türü (Extension Type) (CR0'ın 4 biti).
    * Intel 386 ve Intel 486 işlemcilerde bu seçenek atandığı (set) zaman
    * Intel 387 DX aritmetik işlemcisi komutlarının desteklendiğini gösterir.
    * Pentium 4, Intel Xeon ve P6 ailesi işlemcilerde ise
    * bu seçenek sabit 1 olur.
    *     -- IA-32 Manual Vol.3. Ch.2.5. Control Registers (p.2-14) */

2:
  CR0 = EAX;
  check_x87() {
    /* Doğru olması için ET'ye bağımlıyız.
     * Bu 287/387 için sınar. */
    X86_HARD_MATH = 0;
    clts;                   // CR0.TS = 0;
    fninit;                 // Init FPU;
    fstsw AX;               // AX = ST(0);
    if (AL) {
      CR0 ^= 0x04;    // yardımcı işlemci (coprocessor) yok, EM'i ata
    } else {
      ALIGN
1:    X86_HARD_MATH = 1;
      /* IA-32 Manual Vol.3. Ch.18.14.7.14. FSETPM komutu
        * 287 işlemcisinin korumalı kipte olduğunu söyler
        * 387 tarafından dikkate alınmaz*/
      fsetpm;
    }
  }
}</screen>
   <para><filename>linux/include/linux/linkage.h</filename> içinde tanımlanan ALIGN makrosu, 16-byte hizalama ve 0x90 değeri doldurma (NOP için opcode) belirtir. <literal>.align</literal> talimatının anlamı için ayrıca <link xlink:href="http://www.gnu.org/software/binutils/manual/gas-2.9.1/html_chapter/as_7.html#SEC70">Using as: Assembler Directives</link> belgesine bakınız.
      </para>
  </sect2>
  <sect2 xml:id="linux-i386-boot-code-howto-go_start_kernel">
   <title>Çekirdeği Başlat</title>
<screen>  ready:  .byte 0;        // global değişken
{
  ready++;                // kaç işlemci hazır
  lgdt gdt_descr;         // yeni betimleme tablosunu güvenli yerde kullan
  lidt idt_descr;
  goto __KERNEL_CS:$1f;   // "lgdt"den sonra bölüt yazmaçlarını yeniden yükle
1:
  DS = ES = FS = GS = __KERNEL_DS;
#ifdef CONFIG_SMP
  SS = __KERNEL_DS;       // sadece bölütü yeniden yükle
#else
  SS:ESP = *stack_start;  /* init_task_union'ın sonu,
                           * linux/arch/i386/kernel/init_task.c'de tanımlı */
#endif
  EAX = 0;
  lldt AX;
  cld;

#ifdef CONFIG_SMP
  if (1!=ready) {         // ilk işlemci değil
    initialize_secondary();
    // bakınız: linux/arch/i386/kernel/smpboot.c
  } else
#endif
  {
    start_kernel(); // bakınız: linux/init/main.c
  }
L6:
  goto L6;
}</screen>
   <para>
İlk işlemci (BSP) <literal>linux/init/main.c:start_kernel()</literal>'i çağıracak ve diğerleri (AP) <literal>linux/arch/i386/kernel/smpboot.c:initialize_secondary()</literal>'yi çağıracak. <xref linkend="linux-i386-boot-code-howto-init_main"/> içinde <literal>start_kernel()</literal>'e ve <xref linkend="linux-i386-boot-code-howto-initialize_secondary"/> içindeki <literal>initialize_secondary()</literal>'e bakınız.
      </para>
   <para><literal>init_task_union</literal> ilk süreç olan "idle" süreci (pxml:id=0) için görev yapısı olmak üzere oluşur. "idle" sürecinin yığıtı <literal>init_task_union</literal>'ın sonundan itibaren gelişir. Aşağıdaki kod <literal>init_task_union</literal> ile ilgilidir.
      </para>
<screen>ENTRY(stack_start)
  .long init_task_union+8192;
  .long __KERNEL_DS;

#ifndef INIT_TASK_SIZE
# define INIT_TASK_SIZE 2048*sizeof(long)
#endif

union task_union {
  struct task_struct task;
  unsigned long stack[INIT_TASK_SIZE/sizeof(long)];
};

/* INIT_TASK ilk görev tablosunu kurmak için kullanıldı,
 * riski göze alarak kullanın! Base=0, limit=0x1fffff (=2MB) */
union task_union init_task_union
  __attribute__((__section__(".data.init_task"))) =
    { INIT_TASK(init_task_union.task) };
</screen>
   <para><emphasis>init_task_union</emphasis> BSP "idle" süreci içindir. <xref linkend="linux-i386-boot-code-howto-init_proc"/> bölümünde değinilen "init" süreciyle karıştırmayın.
      </para>
  </sect2>
  <sect2 xml:id="linux-i386-boot-code-howto-khead_misc">
   <title>Muhtelif</title>
<screen>
///////////////////////////////////////////////////////////////////////////////
// öntanımlı kesme yöneticisi ("handler")
ignore_int() { printk("Unknown interrupt\n"); iret; }

/*
 * Kesme belirtici tablosu 256 idt için odaya (room) sahiptir,
 * global belirtici tablosu sahip olabileceğimiz
 * görev sayısına bağımlıdır...
 */
#define IDT_ENTRIES     256
#define GDT_ENTRIES     (__TSS(NR_CPUS))

.globl SYMBOL_NAME(idt)
.globl SYMBOL_NAME(gdt)

  ALIGN
  .word 0
idt_descr:
  .word IDT_ENTRIES*8-1           # idt 256 girdi içerir
SYMBOL_NAME(idt):
  .long SYMBOL_NAME(idt_table)

  .word 0
gdt_descr:
  .word GDT_ENTRIES*8-1
SYMBOL_NAME(gdt):
  .long SYMBOL_NAME(gdt_table)

/*
 * Bu, 0-8M'de (önyükleme amaçları için) bir kimlik eşleşmesi ve
 * PAGE_OFFSET sanal adresinde başka bir 0-8M eşleşmesi oluşturmak
 * üzere ilklendirilir.
 */
.org 0x1000
ENTRY(swapper_pg_dir)   // "ENTRY" linux/include/linux/linkage.h'da tanımlı
  .long 0x00102007
  .long 0x00103007
  .fill BOOT_USER_PGD_PTRS-2,4,0
  /* öntanımlı: 766 girdi */
  .long 0x00102007
  .long 0x00103007
  /* öntanımlı: 254 girdi */
  .fill BOOT_KERNEL_PGD_PTRS-2,4,0

/*
 * Sayfa tablolarının burada sadece 8MB'ı ilklendirilir
 * - sonuncu sayfa tabloları bellek boyutuna bağlı
 * olarak daha sonra ayarlanır.
 */
.org 0x2000
ENTRY(pg0)

.org 0x3000
ENTRY(pg1)

/*
 * empty_zero_page hemen sayfa tablosunu takip etmelidir !
 * (İlklendirme döngüsü empty_zero_page'e kadar sayar)
 */
.org 0x4000
ENTRY(empty_zero_page)

/*
 * normal "text" bölütünün gerçek başlangıcı
 */
.org 0x5000
ENTRY(stext)
ENTRY(_stext)

///////////////////////////////////////////////////////////////////////////////
/*
 * Bu veri bölümünü başlatır. Dikkat ederseniz yukarıda tümü
 * text bölümündedir çünkü bu bizim başka bir şekilde
 * gideremeyeceğimiz hizalama gereksinimidir.
 */
.data

ALIGN
/*
 * Tipik olarak 140 "quadwords" içerir; NR_CPUS'a bağlı olarak.
 *
 * DİKKAT! Herhangi bir şeyi değiştirirseniz, bunun head.S'deki
 * gdt belirticisiyle eşleştiğinden emin olun.
 */
ENTRY(gdt_table)
  .quad 0x0000000000000000        /* NULL belirtici */
  .quad 0x0000000000000000        /* kullanılmadı */
  .quad 0x00cf9a000000ffff        /* 0x10 kernel 4GB code at 0x00000000 */
  .quad 0x00cf92000000ffff        /* 0x18 kernel 4GB data at 0x00000000 */
  .quad 0x00cffa000000ffff        /* 0x23 user   4GB code at 0x00000000 */
  .quad 0x00cff2000000ffff        /* 0x2b user   4GB data at 0x00000000 */
  .quad 0x0000000000000000        /* kullanılmadı */
  .quad 0x0000000000000000        /* kullanılmadı */
  /*
    * APM bölütleri bayt taneciklilik özelliğine sahiptir ve
    * tabanları ile sınırları çalışma zamanında atanır.
    */
  .quad 0x0040920000000000        /* 0x40 kötü BIOS'lar için APM ataması */
  .quad 0x00409a0000000000        /* 0x48 APM CS    kod */
  .quad 0x00009a0000000000        /* 0x50 APM CS 16 kod (16 bit) */
  .quad 0x0040920000000000        /* 0x58 APM DS    veri */
  .fill NR_CPUS*4,8,0             /* TSS'ler ve LDT'ler için boşluk */
</screen>
   <para><literal>idt_descr</literal> ve <literal>gdt_table</literal>'dan önce olan <literal>ALIGN</literal> makrosu performans ile ilgilidir.
      </para>
  </sect2>
  <sect2 xml:id="linux-i386-boot-code-howto-khead_ref">
   <title>Kaynakça</title>
    <simplelist>
     <member>
      <link xlink:href="http://developer.intel.com/design/pentium4/manuals/">IA-32 Intel Architecture Software Developer's Manual</link>
     </member>
     <member>
      <link xlink:href="http://www.intel.com/design/pentium/datashts/242016.htm">MultiProcessor Specification</link>
     </member>
     <member>
      <link xlink:href="http://www.gnu.org/software/binutils/manual/gas-2.9.1/">Using as</link>
     </member>
     <member>
      <link xlink:href="http://www.gnu.org/software/binutils/manual/">GNU Binary Utilities</link>
     </member>
    </simplelist>
  </sect2>
 </sect1>
 <sect1 xml:id="linux-i386-boot-code-howto-init_main">
  <title>linux/init/main.c</title>
  <para>
Bu bölümü yazarken kendimi suçlu hissettim çünkü yeterince olmasa bile hakkında çok sayıda belge var. <literal>start_kernel()</literal> destekli işlevler, sürekli gelişen işletim sistemi dahili bileşenlerine bağımlı olduğu için, sürümden sürüme değişir. Sık sık belge güncellemek için vaktim olmadığından bu bölümü olabildiğince basit tutmaya karar verdim.
    </para>
  <sect2 xml:id="linux-i386-boot-code-howto-start_kernel">
   <title>start_kernel()</title>
<screen>///////////////////////////////////////////////////////////////////////////////
<link xlink:href="http://kernelnewbies.org/faq/index.php3#asmlinkage">asmlinkage</link> void <link xlink:href="http://www.tldp.org/LDP/lki/lki-1.html#ss1.8">__init</link> start_kernel(void)
{
  char * command_line;
  extern char saved_command_line[];
/*
 * Kesmeler hala etkin değil. Gerekli kurulumu yap, sonra etkinleştir
 */
  lock_kernel();
  printk(linux_banner);

  /* <link xlink:href="http://www.symonds.net/~abhi/files/mm/mm.html">Linux'da bellek yönetimi</link>, esp. for setup_arch()
    * <link xlink:href="http://linux-mm.org/docs/initialization.html">Linux-2.4.4 MM Başlangıç durumuna getirme</link> */
  setup_arch(&amp;command_line);
  printk("Kernel command line: %s\n", saved_command_line);

  /* <filename>linux/Documentation/kernel-parameters.txt</filename>
    * <link xlink:href="http://www.tldp.org/HOWTO/BootPrompt-HOWTO.html">The Linux BootPrompt-HowTo</link> */
  parse_options(command_line);

  trap_init() {
#ifdef CONFIG_EISA
    if (isa_readl(0x0FFFD9) == 'E'+('I'&lt;&lt;8)+('S'&lt;&lt;16)+('A'&lt;&lt;24))
      EISA_bus = 1;
#endif
#ifdef CONFIG_X86_LOCAL_APIC
    init_apic_mappings();
#endif
    set_xxxx_gate(x, &amp;func);    // kurulum kapıları
    cpu_init();
  }
  init_IRQ();
  sched_init();
  softirq_init() {
    for (int i=0; i&lt;32: i++)
            tasklet_init(bh_task_vec+i, bh_action, i);
    open_softirq(TASKLET_SOFTIRQ, tasklet_action, NULL);
    open_softirq(HI_SOFTIRQ, tasklet_hi_action, NULL);
  }
  time_init();

  /*
    * HACK ALERT! Bu erken. PCI ve bunun gibi kurulumları bitirdikten
    * ve console_init()'in bunu farketmesinde önce konsolu etkinleştirmeliyiz.
    * Birşeylerin kötü gitmesi durumunda bunun erkenden çıktı olmasını isteriz.
    */
  console_init();
#ifdef CONFIG_MODULES
  init_modules();
#endif
  if (prof_shift) {
    unsigned int size;
    /* only text is profiled */
    prof_len = (unsigned long) &amp;_etext - (unsigned long) &amp;_stext;
    prof_len &gt;&gt;= prof_shift;
    size = prof_len * sizeof(unsigned int) + PAGE_SIZE-1;
    prof_buffer = (unsigned int *) alloc_bootmem(size);
  }

  kmem_cache_init();
  sti();

  // <link xlink:href="http://www.tldp.org/HOWTO/BogoMips.html">BogoMips mini-Howto</link>
  calibrate_delay();

  // <filename>linux/Documentation/initrd.txt</filename>
#ifdef CONFIG_BLK_DEV_INITRD
  if (initrd_start &amp;&amp; !initrd_below_start_ok &amp;&amp;
            initrd_start &lt; min_low_pfn &lt;&lt; PAGE_SHIFT) {
    printk(KERN_CRIT "initrd overwritten (0x%08lx &lt; 0x%08lx) - "
        "disabling it.\n",initrd_start,min_low_pfn &lt;&lt; PAGE_SHIFT);
    initrd_start = 0;
  }
#endif

  mem_init();
  kmem_cache_sizes_init();
  pgtable_cache_init();

  /*
    * Yüksek belleğe (highmem) sahip olan mimariler için, num_mappedpages
    * çekirdeğin kullanabileceği bellek miktarını ifade eder. Diğer mimariler
    * için toplam sayfa ile aynıdır. Her iki rakama da ihtiyaç duyarız çünkü
    * bazı altsistemler çekirdeğin ne kadar bellek kullanabileceğine dayanarak
    * başlangıç durumuna getirilir.
    */
  if (num_mappedpages == 0)
          num_mappedpages =  num_physpages;

  fork_init(num_mempages);
  proc_caches_init();
  vfs_caches_init(num_physpages);
  buffer_init(num_physpages);
  page_cache_init(num_physpages);
#if defined(CONFIG_ARCH_S390)
  ccwcache_init();
#endif
  signals_init();
#ifdef CONFIG_PROC_FS
  proc_root_init();
#endif
#if defined(CONFIG_SYSVIPC)
  ipc_init();
#endif
  check_bugs();
  printk("POSIX conformance testing by UNIFIX\n");

  /*
    *      İlk işlemdeki (thread) iyi gidenleri sayarız
    *      atıl (idlers) gibi init de kilitsiz bir çekirdek işlemidir,
    *      sistem çağrısı yapar (ve böylece kilitlenir).
    */
  smp_init() {
#ifndef CONFIG_SMP
# ifdef CONFIG_X86_LOCAL_APIC
    APIC_init_uniprocessor();
#  else
    do { } while (0);
# endif
#else
    /* Check <xref linkend="linux-i386-boot-code-howto-smp_init"/>. */
#endif
  }

  rest_init() {
    // init process, pid = 1
    kernel_thread(init, NULL, CLONE_FS | CLONE_FILES | CLONE_SIGNAL);
    unlock_kernel();
    current-&gt;need_resched = 1;
    // idle process, pid = 0
    cpu_idle();     // never return
  }
}</screen>
   <para><literal>start_kernel()</literal> "init" işlemi oluşturmak için <literal>rest_init()</literal>'i çağırır ve kendisi "idle" işlem durumuna geçer.
      </para>
  </sect2>
  <sect2 xml:id="linux-i386-boot-code-howto-init_proc">
   <title>init()</title>
   <para>
"Init" süreci:
      </para>
<screen>///////////////////////////////////////////////////////////////////////////////
static int init(void * unused)
{
  lock_kernel();
  do_basic_setup();

  prepare_namespace();

  /*
    * Tamam, ilk önyüklemeyi (bootup) tamamladık, ayakta ve
    * çalışır durumdayız. initmem bölütlerinden kurtul ve
    * kullanıcı kipini başlat...
    */
  free_initmem();
  unlock_kernel();

  if (open("/dev/console", O_RDWR, 0) &lt; 0)        // stdin
          printk("Warning: unable to open an initial console.\n");

  (void) dup(0);                                  // stdout
  (void) dup(0);                                  // stderr

  /*
    * Biri başarılı olana kadar her birini deneyeceğiz
    * Gerçekten bozuk bir makinayı toparlamaya çalışıyorsak
    * init yerine Bourne kabuğu kullanılabilir.
    */

  if (execute_command)
          execve(execute_command,argv_init,envp_init);
  execve("/sbin/init",argv_init,envp_init);
  execve("/etc/init",argv_init,envp_init);
  execve("/bin/init",argv_init,envp_init);
  execve("/bin/sh",argv_init,envp_init);
  panic("No init found.  Try passing init= option to kernel.");
}</screen>
   <para>
Kullanıcı kipi "init" süreciyle ilgili bilgiler için <command>man init</command> veya <link xlink:href="http://freshmeat.net/projects/sysvinit">SysVinit</link>'e bakınız.
      </para>
  </sect2>
  <sect2 xml:id="linux-i386-boot-code-howto-idle_proc">
   <title>cpu_idle()</title>
   <para>
"Idle" süreç:
      </para>
<screen>/*
 * Boşta bekleme (idle) evresi. Yapılacak yararlı bir iş yok,
 * bu yüzden sadece gücü korumaya çalış ve düşük çıkış gecikmesine
 * sahip ol (örn. birinin yeniden iş yapma isteği
 * belirtmesini bekleyen bir döngü içinde kal)
 */
void cpu_idle (void)
{
  /* hiç bir önceliği olmayan sonsuz atıl döngü */
  init_idle();
  current-&gt;nice = 20;
  current-&gt;counter = -100;

  while (1) {
    void (*idle)(void) = pm_idle;
    if (!idle)
      idle = default_idle;
    while (!current-&gt;need_resched)
      idle();
    schedule();
    check_pgt_cache();
  }
}

///////////////////////////////////////////////////////////////////////////////
void __init init_idle(void)
{
  struct schedule_data * sched_data;
  sched_data = &amp;aligned_data[smp_processor_id()].schedule_data;

  if (current != &amp;init_task &amp;&amp; task_on_runqueue(current)) {
    printk("UGH! (%d:%d) was on the runqueue, removing.\n",
            smp_processor_id(), current-&gt;pid);
    del_from_runqueue(current);
  }
  sched_data-&gt;curr = current;
  sched_data-&gt;last_schedule = get_cycles();
  clear_bit(current-&gt;processor, &amp;wait_init_idle);
}

///////////////////////////////////////////////////////////////////////////////
void default_idle(void)
{
  if (current_cpu_data.hlt_works_ok &amp;&amp; !hlt_counter) {
    __cli();
    if (!current-&gt;need_resched)
      safe_halt();
    else
      __sti();
  }
}

/* linux/include/asm-i386/system.h içinde tanımlı */
#define __cli()                 __asm__ __volatile__("cli": : :"memory")
#define __sti()                 __asm__ __volatile__("sti": : :"memory")

/* atıl döngü içinde kullanıldı; sti'nin tamamlanması bir komut süresi alır */
#define safe_halt()             __asm__ __volatile__("sti; hlt": : :"memory")
</screen>
   <para>
İşlemci bir kesme eylemcisinden dönen "hlt"yi takip eden komut ile kod çalıştırmaya devam edecektir.
      </para>
  </sect2>
  <sect2 xml:id="linux-i386-boot-code-howto-main_ref">
   <title>Kaynakça</title>
   <para>
    <simplelist>
     <member>
      <link xlink:href="http://www.tldp.org/LDP/lki/index.html"> Linux Kernel 2.4 Internals</link>
     </member>
     <member>
      <link xlink:href="http://kernelnewbies.org/documents/">Kerneldoc</link>
     </member>
     <member>
      <link xlink:href="http://www.tldp.org/HOWTO/HOWTO-INDEX/index.html">LDP HOWTO-INDEX</link>
     </member>
     <member>
      <link xlink:href="http://www.xml.com/ldd/chapter/book">Linux Device Drivers, 2nd Edition</link>
     </member>
    </simplelist>
   </para>
  </sect2>
 </sect1>
 <sect1 xml:id="linux-i386-boot-code-howto-smpboot">
  <title>SMP Önyükleme</title>
  <para>
SMP ile ilgili <literal>CONFIG_SMP, CONFIG_X86_LOCAL_APIC, CONFIG_X86_IO_APIC, CONFIG_MULTIQUAD</literal> ve <literal>CONFIG_VISWS</literal> gibi bir kaç makro bulunmaktadır. Birçok insanın dikkate almadığı (eğer IBM üst-uç çok işlemcili sunucu veya SGI Görsel İşistasyonu kullanmıyorsa) <literal>CONFIG_MULTIQUAD</literal> veya <literal>CONFIG_VISWS</literal> gerektiren kodları yoksayacağım.
    </para>
  <para>
BSP APleri tetiklemek için <literal>start_kernel() -&gt; smp_init() -&gt; smp_boot_cpus() -&gt; do_boot_cpu() -&gt; wakeup_secondary_via_INIT()</literal>'i çalıştırır. Teknik ayrıntılar için bakınız: <link xlink:href="http://www.intel.com/design/pentium/datashts/242016.htm">MultiProcessor Specification</link> ve IA-32 Manual Vol.3 (Ch.7. Multile-Processor Management, and Ch.8. Advanced Programmable Interrupt Controller).
    </para>
  <sect2 xml:id="linux-i386-boot-code-howto-before_smpinit">
   <title>smp_init() Öncesi</title>
   <para><literal>smp_init()</literal>'i çağırmadan önce, <literal>start_kernel()</literal> SMP ortamını kurmak için birşeyler yapar.
      </para>
<screen>start_kernel()
|-- setup_arch()
|   |-- parse_cmdline_early();  // SMP "noht" ve "acpismp=force" arar
|   |   `-- /* "noht" çoklu işlem (HyperThreading) özelliğini iptal eder
|   |        * (Xeon başına 2 mantıksal işlemci) */
|   |       if (!memcmp(from, "noht", 4)) {
|   |           disable_x86_ht = 1;
|   |           set_bit(X86_FEATURE_HT, disabled_x86_caps);
|   |       }
|   |       /* "acpismp=force" ACPI SMP tablosunu kullanıma ve
|   |        * çözümlemeye zorlar */
|   |       else if (!memcmp(from, "acpismp=force", 13))
|   |           enable_acpi_smp_table = 1;
|   |-- setup_memory();         // MP yapılandırma tablosu için bellek ayırır
|   |   |-- reserve_bootmem(PAGE_SIZE, PAGE_SIZE);
|   |   `-- find_smp_config();
|   |       `-- find_intel_smp();
|   |           `-- smp_scan_config();
|   |               |-- set flag <literal>smp_found_config</literal>
|   |               |-- set MP floating pointer <literal>mpf_found</literal>
|   |               `-- reserve_bootmem(mpf_found, PAGE_SIZE);
|   |-- if (disable_x86_ht) {   // çoklu işlem iptal edilmişse
|   |       clear_bit(X86_FEATURE_HT, &amp;boot_cpu_data.x86_capability[0]);
|   |       set_bit(X86_FEATURE_HT, disabled_x86_caps);
|   |       enable_acpi_smp_table = 0;
|   |   }
|   |-- if (test_bit(X86_FEATURE_HT, &amp;boot_cpu_data.x86_capability[0]))
|   |       enable_acpi_smp_table = 1;
|   |-- smp_alloc_memory();
|   |   `-- /* AP işlemcilerinin gerçek kip kod uzayını düşük bellekte ayırır */
|   |       trampoline_base = (void *) alloc_bootmem_low_pages(PAGE_SIZE);
|   `-- get_smp_config();     /* önyükleme anı MP yapılandırmasını al */
|       |-- config_acpi_tables();
|       |   |-- memset(&amp;acpi_boot_ops, 0, sizeof(acpi_boot_ops));
|       |   |-- acpi_boot_ops[ACPI_APIC] = acpi_parse_madt;
|       |   `-- /* <literal>have_acpi_tables</literal> değerini ACPI tablosunda
|       |        * MADT kullanıldığını belirtecek şekilde değiştirir;
|       |        * başarısız olursa MPS kullan. */
|       |       if (enable_acpi_smp_table &amp;&amp; !acpi_tables_init())
|       |           have_acpi_tables = 1;
|       |-- set <literal>pic_mode</literal>
|       |   /* =1, IMCR varsa ve PIC Kipi gerçekleştirilmişse;
|       |    * =0, aksi taktirde Sanal Tel Tipi (Virtual Wire Mode)
|       |    *     gerçekleştirilmiştir. */
|       |-- <literal>mp_lapic_addr</literal>'deki yerel APIC adresini sakla
|       `-- MP_PROCESSOR, MP_BUS, MP_IOAPIC, MP_INTSRC ve MP_LINTSRC.MP gibi
|             yapılandırma tablo girdilerini tara.
|
|-- trap_init();
|   `-- init_apic_mappings();   // PTE'yi APIC için ayarla
|       |-- /* Eğer hiç yerel APIC bulunmazsa tüm sıfır sayfalarını
|       |    * (zeroes page) yerel APIC'i ve bir de IO-APIC'i
|       |    * taklit edecek şekilde ayarla. */
|       |   if (!smp_found_config &amp;&amp; detect_init_APIC()) {
|       |       apic_phys = (unsigned long) alloc_bootmem_pages(PAGE_SIZE);
|       |       apic_phys = __pa(apic_phys);
|       |   } else
|       |       apic_phys = mp_lapic_addr;
|       |-- /* yerel APIC adresini,
|       |    *  çoğu durumda <literal>mp_lapic_addr</literal>'dir (0xfee00000),
|       |    *  bunu doğrusal FIXADDR_TOP (0xffffe000) adresine eşle */
|       |   set_fixmap_nocache(FIX_APIC_BASE, apic_phys);
|       |-- /* öntanımlı yapılandırmamız (veya MP tablosunun bozuk olması)
|       |    * durumu için BSP'nin APIC ID değerini al. */
|       |   if (boot_cpu_physical_apicid == -1U)
|       |       boot_cpu_physical_apicid = GET_APIC_ID(apic_read(APIC_ID));
|       `-- // IOAPIC adresini arabelleksiz doğrusal adrese eşle
|           set_fixmap_nocache(idx, ioapic_phys);
|       // Artık APIC uzayına erişmek için doğrusal adres kullanabiliriz.
|-- init_IRQ();
|   |-- init_ISA_irqs();
|   |   |-- /* sanal tel kipinin ilk kurulumu. */
|   |   |   init_bsp_APIC();
|   |   `-- init_8259A(auto_eoi=0);
|   `-- setup SMP/APIC interrupt handlers, esp. IPI.
`-- mem_init();
    `-- /* SMP için düşük adresleme geçişini (zapping)
         * geciktir: zap_low_mappings() */
</screen>
   <para>
IPI (İşlemcilerarası Kesme - InterProcessor Interrupt), yani işlemciden işlemciye yerel APIC üzerinden kesme, BSP'nin APleri tetiklemek için kullandığı mekanizmadır.
      </para>
   <para>
Bilmeniz gerekir ki MP-uyumlu sistemlerde "CPU başına bir yerel APIC gereklidir". İşlemciler APIC yerel birimlerinin adres uzayını (0xFEE00000 - 0xFEEFFFFF fiziksel adresini) paylaşmazlar, fakat APIC giriş-çıkış birimlerini (0xFEC00000 - 0xFECFFFFF) paylaşırlar. Her iki adres uzayı da arabelleklenebilir değildir.
      </para>
  </sect2>
  <sect2 xml:id="linux-i386-boot-code-howto-smp_init">
   <title>smp_init()</title>
   <para>
BSP her bir işlemcinin veri yapılarını kurmak ve kalan APleri etkinleştirmek için <literal>start_kernel() -&gt; smp_init() -&gt; smp_boot_cpus()</literal> çağrısı yapar.
      </para>
<screen>///////////////////////////////////////////////////////////////////////////////
static void __init smp_init(void)
{
  /* Get other processors into their bootup holding patterns. */
  smp_boot_cpus();
  wait_init_idle = cpu_online_map;
  clear_bit(current-&gt;processor, &amp;wait_init_idle); /* Don't wait on me! */

  smp_threads_ready=1;
  smp_commence() {
    /* Lets the callins below out of their loop. */
    Dprintk("Setting commenced=1, go go go\n");
    wmb();
    atomic_set(&amp;smp_commenced,1);
  }

  /* Wait for the other cpus to set up their idle processes */
  printk("Waiting on wait_init_idle (map = 0x%lx)\n", wait_init_idle);
  while (wait_init_idle) {
    cpu_relax();    // i.e. "rep;nop"
    barrier();
  }
  printk("All processors have done init_idle\n");
}

///////////////////////////////////////////////////////////////////////////////
void __init smp_boot_cpus(void)
{
  // ... çok ilginç olmayan birşey :-)

  /* Initialize the logical to physical CPU number mapping
    * and the per-CPU profiling router/multiplier */
  prof_counter[0..NR_CPUS-1] = 0;
  prof_old_multiplier[0..NR_CPUS-1] = 0;
  prof_multiplier[0..NR_CPUS-1] = 0;

  init_cpu_to_apicid() {
    physical_apicid_2_cpu[0..MAX_APICID-1] = -1;
    logical_apicid_2_cpu[0..MAX_APICID-1] = -1;
    cpu_2_physical_apicid[0..NR_CPUS-1] = 0;
    cpu_2_logical_apicid[0..NR_CPUS-1] = 0;
  }

  /* Setup boot CPU information */
  smp_store_cpu_info(0); /* Final full version of the data */
  printk("CPU%d: ", 0);
  print_cpu_info(&amp;cpu_data[0]);

  /* We have the boot CPU online for sure. */
  set_bit(0, &amp;cpu_online_map);
  boot_cpu_logical_apicid = logical_smp_processor_id() {
    GET_APIC_LOGICAL_ID(*(unsigned long *)(APIC_BASE+APIC_LDR));
  }
  map_cpu_to_boot_apicid(0, boot_cpu_apicid) {
    physical_apicid_2_cpu[boot_cpu_apicid] = 0;
    cpu_2_physical_apicid[0] = boot_cpu_apicid;
  }

  global_irq_holder = 0;
  current-&gt;processor = 0;
  init_idle();    // will clear corresponding bit in <literal>wait_init_idle</literal>
  smp_tune_scheduling();

  // ... some conditions checked

  connect_bsp_APIC();     // enable APIC mode if used to be PIC mode
  setup_local_APIC();

  if (GET_APIC_ID(apic_read(APIC_ID)) != boot_cpu_physical_apicid)
    BUG();

  /* Scan the CPU present map and fire up the other CPUs
    *   via do_boot_cpu() */
  Dprintk("CPU present map: %lx\n", phys_cpu_present_map);
  for (bit = 0; bit &lt; NR_CPUS; bit++) {
    apicid = cpu_present_to_apicid(bit);
    /* Don't even attempt to start the boot CPU! */
    if (apicid == boot_cpu_apicid)
      continue;
    if (!(phys_cpu_present_map &amp; (1 &lt;&lt; bit)))
      continue;
    if ((max_cpus &gt;= 0) &amp;&amp; (max_cpus &lt;= cpucount+1))
      continue;
    do_boot_cpu(apicid);
    /* Make sure we unmap all failed CPUs */
    if ((boot_apicid_to_cpu(apicid) == -1) &amp;&amp;
        (phys_cpu_present_map &amp; (1 &lt;&lt; bit)))
      printk("CPU #%d not responding - cannot use it.\n", apicid);
  }

  // ... SMP BogoMIPS
  // ... B stepping processor warning
  // ... HyperThreading handling

  /* Set up all local APIC timers in the system */
  setup_APIC_clocks();

  /* Synchronize the TSC with the AP */
  if (cpu_has_tsc &amp;&amp; cpucount)
    synchronize_tsc_bp();

smp_done:
  zap_low_mappings();
}

///////////////////////////////////////////////////////////////////////////////
static void __init do_boot_cpu (int apicid)
{
  cpu = ++cpucount;

  // 1. prepare "idle process" task struct for next AP

  /* We can't use kernel_thread since we must avoid to
    * reschedule the child. */
  if (fork_by_hand() &lt; 0)
    panic("failed fork for CPU %d", cpu);
  /* We remove it from the pidhash and the runqueue
    * once we got the process: */
  idle = init_task.prev_task;
  if (!idle)
    panic("No idle process for CPU %d", cpu);

  /* we schedule the first task manually */
  idle-&gt;processor = cpu;
  idle-&gt;cpus_runnable = 1 &lt;&lt; cpu; // only on this AP!

  map_cpu_to_boot_apicid(cpu, apicid) {
    physical_apicid_2_cpu[apicid] = cpu;
    cpu_2_physical_apicid[cpu] = apicid;
  }

  idle-&gt;thread.eip = (unsigned long) start_secondary;

  del_from_runqueue(idle);
  unhash_process(idle);
  init_tasks[cpu] = idle;

  // 2. prepare stack and code (CS:IP) for next AP

  /* start_eip had better be page-aligned! */
  start_eip = setup_trampoline() {
    memcpy(trampoline_base, trampoline_data,
            trampoline_end - trampoline_data);
    /* <literal>trampoline_base</literal> was reserved in
      * <literal>start_kernel() -&gt; setup_arch() -&gt; smp_alloc_memory()</literal>,
      * and will be shared by all APs (one by one) */
    return virt_to_phys(trampoline_base);
  }

  /* So we see what's up */
  printk("Booting processor %d/%d eip %lx\n", cpu, apicid, start_eip);
  stack_start.esp = (void *) (1024 + PAGE_SIZE + (char *)idle);
  /* this value is used by next AP when it executes
    *   "lss stack_start,%esp" in
    *   linux/arch/i386/kernel/head.S:startup_32(). */

  /* This grunge runs the startup process for
    * the targeted processor. */
  atomic_set(&amp;init_deasserted, 0);
  Dprintk("Setting warm reset code and vector.\n");

  CMOS_WRITE(0xa, 0xf);
  local_flush_tlb();
  Dprintk("1.\n");
  *((volatile unsigned short *) TRAMPOLINE_HIGH) = start_eip &gt;&gt; 4;
  Dprintk("2.\n");
  *((volatile unsigned short *) TRAMPOLINE_LOW) = start_eip &amp; 0xf;
  Dprintk("3.\n");
  // we have setup 0:467 to <literal>start_eip (trampoline_base)</literal>

  // 3. kick AP to run (AP gets CS:IP from 0:467)

  // Starting actual IPI sequence...
  boot_error = wakeup_secondary_via_INIT(apicid, start_eip);
  if (!boot_error) {      // looks OK
    /* allow APs to start initializing. */
    set_bit(cpu, &amp;cpu_callout_map);

    /* ... Wait 5s total for a response */

    // bit cpu in cpu_callin_map is set by AP in smp_callin()
    if (test_bit(cpu, &amp;cpu_callin_map)) {
      print_cpu_info(&amp;cpu_data[cpu]);
    } else {
      boot_error= 1;
      // marker 0xA5 set by AP in trampoline_data()
      if (*((volatile unsigned char *)phys_to_virt(8192)) == 0xA5)
        /* trampoline started but... */
        printk("Stuck ??\n");
      else
        /* trampoline code not run */
        printk("Not responding.\n");
    }
  }
  if (boot_error) {
    /* Try to put things back the way they were before ... */
    unmap_cpu_to_boot_apicid(cpu, apicid);
    clear_bit(cpu, &amp;cpu_callout_map); /* set in do_boot_cpu() */
    clear_bit(cpu, &amp;cpu_initialized); /* set in cpu_init() */
    clear_bit(cpu, &amp;cpu_online_map);  /* set in smp_callin() */
    cpucount--;
  }

  /* mark "stuck" area as not stuck */
  *((volatile unsigned long *)phys_to_virt(8192)) = 0;
}</screen>
   <para><literal>start_secondary()</literal> ile <literal>trampoline_data()</literal>'yı karıştırmayın. İlki AP "idle" süreci görev yapısı EIP değeridir, ikincisi ise AP'nin BSP onu uyardıktan sonra (<literal>wakeup_secondary_via_INIT()</literal> kullanarak) çalıştırdığı gerçek kipli koddur.
      </para>
  </sect2>
  <sect2 xml:id="linux-i386-boot-code-howto-trampoline">
   <title>linux/arch/i386/kernel/trampoline.S</title>
   <para>
Bu dosya 16 bitlik gerçek kipli AP başlatma kodunu içerir. BSP <literal>start_kernel() -&gt; setup_arch() -&gt; smp_alloc_memory()</literal> içinde <literal>trampoline_base</literal> bellek uzayını ayırdı. BSP APyi tetiklemeden önce trampoline kodunu <literal>trampoline_data</literal> ve <literal>trampoline_end</literal> arasından <literal>trampoline_base</literal>'e (<literal>do_boot_cpu() -&gt; setup_trampoline()</literal> içindeki) kopyalar. BSP 0:467 noktasını, AP bu noktadan itibaren çalışabilmesi için, <literal>trampoline_base</literal> olarak atar.
      </para>
<screen>///////////////////////////////////////////////////////////////////////////////
trampoline_data()
{
r_base:
  wbinvd;         // diğeri için zararsız olması gereken NUMA-Q için gerekli
  DS = CS;
  BX = 1;         // Bir SMP trampoline seçeneği
  cli;

  // master'in çalıştığımızı bilmesi için imleyiciyi yaz
  trampoline_base = 0xA5A5A5A5;

  lidt idt_48;
  lgdt gdt_48;

  AX = 1;
  lmsw AX;        // korumalı kip!
  goto flush_instr;
flush_instr:
  goto CS:100000; // see linux/arch/i386/kernel/head.S:startup_32()
}

idt_48:
  .word   0                       # idt limit = 0
  .word   0, 0                    # idt base = 0L

gdt_48:
  .word   0x0800                  # gdt limit = 2048, 256 GDT girdisi
  .long   gdt_table-__PAGE_OFFSET # gdt base = gdt (ilk SMP CPU)

.globl SYMBOL_NAME(trampoline_end)
SYMBOL_NAME_LABEL(trampoline_end)
</screen>
   <para>
Dikkat ederseniz AP <filename>linux/arch/i386/kernel/head.S:startup_32()</filename>'ye geçtiğinde, BSPninkinden (BX=0) farklı olarak, BX=1 oluyor. Bakınız: <xref linkend="linux-i386-boot-code-howto-kernel_head"/>.
      </para>
  </sect2>
  <sect2 xml:id="linux-i386-boot-code-howto-initialize_secondary">
   <title>initialize_secondary()</title>
   <para>
BSP'den farklı olarak, <xref linkend="linux-i386-boot-code-howto-go_start_kernel"/> bölümündeki <literal>linux/arch/i386/kernel/head.S:startup_32()</literal>'nin sonunda AP <literal>start_kernel()</literal> yerine <literal>initialize_secondary()</literal>'yi çağırır.
      </para>
<screen>/* İkincil işlemciler için herşey kurulmuş durumda;
 * bunlar sadece görev yapısındaki herşeyi yeniden
 * yüklemek için gerekli.
 * Bu işlev değer döndürmemeli. */
void __init initialize_secondary(void)
{
  /* Aslında tüm TSS'yi yüklememiz gerekmiyor,
    * basitçe sadece yığıt göstericisi ve eip. */
  asm volatile(
    "movl %0,%%esp\n\t"
    "jmp *%1"
    :
    :"r" (current-&gt;thread.esp),"r" (current-&gt;thread.eip));
}</screen>
   <para>
BSPnin <literal>thread.eip</literal>'yi <literal>start_secondary()</literal>'ye atamak için <literal>do_boot_cpu()</literal>'yu çağırmasıyla denetim bu işleve geçer. AP, BSP tarafından <literal>do_boot_cpu() -&gt; fork_by_hand() -&gt; do_fork()</literal> içinde kurulan, yeni bir yığıt çerçevesi kullanır.
      </para>
  </sect2>
  <sect2 xml:id="linux-i386-boot-code-howto-start_secondary">
   <title>start_secondary()</title>
   <para>
Tüm APler <xref linkend="linux-i386-boot-code-howto-smp_init"/> içindeki <literal>smp_init() -&gt; smp_commence()</literal> ile tetiklenen BSP'den <literal>smp_commenced</literal> sinyalini beklerler. Bu sinyali aldıktan sonra "idle" süreçlerini çalıştırırlar.
      </para>
<screen>///////////////////////////////////////////////////////////////////////////////
int __init start_secondary(void *unused)
{
  /* smp_callin() öncesine birşey koyma, en yapılması gereken şeyleri
   * yapmak için yapılacak şeyleri sınırlamak istediğimiz bu yerde
   * SMP önyüklemesi çok kırılgandır.*/
  cpu_init();
  smp_callin();
  while (!atomic_read(&amp;smp_commenced))
          rep_nop();
  /* düşük bellek adreslemesi temizlendi,
    * onları yerel TLB'lerden de çıkar (flush). */
  local_flush_tlb();
  return cpu_idle();      // asla dönmez, bakınız: <xref linkend="linux-i386-boot-code-howto-idle_proc"/>
}</screen>
   <para><literal>cpu_idle() -&gt; init_idle()</literal><literal>wait_init_idle</literal> içindeki ilgili biti temizler ve son olarak BSPnin <literal>smp_init()</literal>'i bitirmesini sağlar ve <literal>start_kernel()</literal> içindeki takip eden işlevle devam eder (örn. <literal>rest_init()</literal>).
      </para>
  </sect2>
  <sect2 xml:id="linux-i386-boot-code-howto-smpboot_ref">
   <title>Kaynakça</title>
   <para>
    <simplelist>
     <member>
      <link xlink:href="http://www.intel.com/design/pentium/datashts/242016.htm">MultiProcessor Specification</link>
     </member>
     <member>
      <link xlink:href="http://developer.intel.com/design/pentium4/manuals/">IA-32 Intel Architecture Software Developer's Manual</link>
     </member>
     <member>
      <link xlink:href="http://www.tldp.org/LDP/lki/lki-1.html#ss1.7">Linux Kernel 2.4 Internals: Ch.1.7. SMP Bootup on x86</link>
     </member>
     <member>
      <link xlink:href="http://www.tldp.org/HOWTO/SMP-HOWTO.html">Linux SMP HOWTO</link>
     </member>
     <member>
      <link xlink:href="http://www.acpi.info">ACPI spec</link>
     </member>
     <member>
Bir çokişlemcili Linux gerçeklenimi: <filename>linux/Documentation/smp.tex</filename>
     </member>
    </simplelist>
   </para>
  </sect2>
 </sect1>
 <!-- use "sect1" instead of "appendix" to work around broken pdf generator -->
 <!-- bizim böyle bir derdimiz yok; bizim pdf generator işini bilir. -->
 <appendix xml:id="linux-i386-boot-code-howto-kbuild">
  <title>Çekirdek Derleme ve Kurulum Örneği</title>
  <para>
Aşağıda bir çekirdek kurulum örneği var (<link xlink:href="http://www.redhat.com">Redhat</link> 9.0 üzerinde). "/*" ve "*/" arasındaki ifadeler konsol çıktısı değil yorum satırlarıdır.
</para>
<screen>[root@localhost root]# <command>ln -s /usr/src/linux-2.4.20 /usr/src/linux</command>
[root@localhost root]# <command>cd /usr/src/linux</command>
[root@localhost linux]# <command>make xconfig</command>
   <emphasis>/* .config dosyasını oluşturun:</emphasis>
    <emphasis>*   1. "Load Configuration from File" ile</emphasis>
    <emphasis>*       /boot/config-2.4.20-28.9 veya istediğiniz bir config</emphasis>
    <emphasis>*       dosyasını yükleyin.</emphasis>
    <emphasis>*   2. Çekirdek yapılandırma değiştirgelerini değiştirin.</emphasis>
    <emphasis>*   3. "Kaydedip çıkın" */</emphasis>
[root@localhost linux]# <command>make oldconfig</command>
        <emphasis>/* isterseniz .config'i yeniden kontrol edin */</emphasis>
[root@localhost linux]# <command>vi Makefile</command>
        <emphasis>/* isterseniz linux/Makefile içindeki EXTRAVERSION</emphasis>
         <emphasis>* değerini değiştirin */</emphasis>
[root@localhost linux]# <command>make dep</command>
        <emphasis>/* .depend vs. yi oluşturun */</emphasis>
[root@localhost linux]# <command>make bzImage</command>
        <emphasis>/* ... Bazı çıktılar atlandı */</emphasis>
ld -m elf_i386 -T /usr/src/linux-2.4.20/arch/i386/vmlinux.lds -e stext arch/i386
/kernel/head.o arch/i386/kernel/init_task.o init/main.o init/version.o init/do_m
ounts.o \
        --start-group \
        arch/i386/kernel/kernel.o arch/i386/mm/mm.o kernel/kernel.o mm/mm.o fs/f
s.o ipc/ipc.o \
         drivers/char/char.o drivers/block/block.o drivers/misc/misc.o drivers/n
et/net.o drivers/media/media.o drivers/char/drm/drm.o drivers/net/fc/fc.o driver
s/net/appletalk/appletalk.o drivers/net/tokenring/tr.o drivers/net/wan/wan.o dri
vers/atm/atm.o drivers/ide/idedriver.o drivers/cdrom/driver.o drivers/pci/driver
.o drivers/net/pcmcia/pcmcia_net.o drivers/net/wireless/wireless_net.o drivers/p
np/pnp.o drivers/video/video.o drivers/net/hamradio/hamradio.o drivers/md/mddev.
o drivers/isdn/vmlinux-obj.o \
        net/network.o \
        /usr/src/linux-2.4.20/arch/i386/lib/lib.a /usr/src/linux-2.4.20/lib/lib.
a /usr/src/linux-2.4.20/arch/i386/lib/lib.a \
        --end-group \
        -o vmlinux
nm vmlinux | grep -v '\(compiled\)\|\(\.o$\)\|\( [aUw] \)\|\(\.\.ng$\)\|\(LASH[R
L]DI\)' | sort &gt; System.map
make[1]: Entering directory `/usr/src/linux-2.4.20/arch/i386/boot'
gcc -E -D__KERNEL__ -I/usr/src/linux-2.4.20/include -D__BIG_KERNEL__ -traditiona
l -DSVGA_MODE=NORMAL_VGA  bootsect.S -o bbootsect.s
as -o bbootsect.o bbootsect.s
bootsect.S: Assembler messages:
bootsect.S:239: Warning: indirect lcall without `*'
ld -m elf_i386 -Ttext 0x0 -s --oformat binary bbootsect.o -o bbootsect
gcc -E -D__KERNEL__ -I/usr/src/linux-2.4.20/include -D__BIG_KERNEL__ -D__ASSEMBL
Y__ -traditional -DSVGA_MODE=NORMAL_VGA  setup.S -o bsetup.s
as -o bsetup.o bsetup.s
setup.S: Assembler messages:
setup.S:230: Warning: indirect lcall without `*'
ld -m elf_i386 -Ttext 0x0 -s --oformat binary -e begtext -o bsetup bsetup.o
make[2]: Entering directory `/usr/src/linux-2.4.20/arch/i386/boot/compressed'
tmppiggy=_tmp_$$piggy; \
rm -f $tmppiggy $tmppiggy.gz $tmppiggy.lnk; \
objcopy -O binary -R .note -R .comment -S /usr/src/linux-2.4.20/vmlinux $tmppigg
y; \
gzip -f -9 &lt; $tmppiggy &gt; $tmppiggy.gz; \
echo "SECTIONS { .data : { input_len = .; LONG(input_data_end - input_data) inpu
t_data = .; *(.data) input_data_end = .; }}" &gt; $tmppiggy.lnk; \
ld -m elf_i386 -r -o piggy.o -b binary $tmppiggy.gz -b elf32-i386 -T $tmppiggy.l
nk; \
rm -f $tmppiggy $tmppiggy.gz $tmppiggy.lnk
gcc -D__ASSEMBLY__ -D__KERNEL__ -I/usr/src/linux-2.4.20/include -traditional -c
head.S
gcc -D__KERNEL__ -I/usr/src/linux-2.4.20/include -Wall -Wstrict-prototypes -Wno-
trigraphs -O2 -fno-strict-aliasing -fno-common -fomit-frame-pointer -pipe -mpref
erred-stack-boundary=2 -march=i686 -DKBUILD_BASENAME=misc -c misc.c
ld -m elf_i386 -Ttext 0x100000 -e startup_32 -o bvmlinux head.o misc.o piggy.o
make[2]: Leaving directory `/usr/src/linux-2.4.20/arch/i386/boot/compressed'
gcc -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer -o tools/build tools/buil
d.c -I/usr/src/linux-2.4.20/include
objcopy -O binary -R .note -R .comment -S compressed/bvmlinux compressed/bvmlinu
x.out
tools/build -b bbootsect bsetup compressed/bvmlinux.out CURRENT &gt; bzImage
Root device is (3, 67)
Boot sector 512 bytes.
Setup is 4780 bytes.
System is 852 kB
make[1]: Leaving directory `/usr/src/linux-2.4.20/arch/i386/boot'
[root@localhost linux]# <command>make modules modules_install</command>
        <emphasis>/* ... Bazı çıktılar atlandı */</emphasis>
cd /lib/modules/2.4.20; \
mkdir -p pcmcia; \
find kernel -path '*/pcmcia/*' -name '*.o' | xargs -i -r ln -sf ../{} pcmcia
if [ -r System.map ]; then /sbin/depmod -ae -F System.map  2.4.20; fi
[root@localhost linux]# <command>cp arch/i386/boot/bzImage /boot/vmlinuz-2.4.20</command>
[root@localhost linux]# <command>cp vmlinux /boot/vmlinux-2.4.20</command>
[root@localhost linux]# <command>cp System.map /boot/System.map-2.4.20</command>
[root@localhost linux]# <command>cp .config /boot/config-2.4.20</command>
[root@localhost linux]# <command>mkinitrd /boot/initrd-2.4.20.img 2.4.20</command>
[root@localhost linux]# <command>vi /boot/grub/grub.conf</command>
        <emphasis>/* Aşağıdaki satırları grub.conf dosyasına ekleyin:</emphasis>
<emphasis>title Linux (2.4.20)</emphasis>
        <emphasis>kernel /vmlinuz-2.4.20 ro root=LABEL=/</emphasis>
        <emphasis>initrd /initrd-2.4.20.img */</emphasis>
</screen>
  <para>
Daha fazla ayrıntı için <link xlink:href="http://kernelnewbies.org/faq/index.php3#compile">Kernelnewbies FAQ: How do I compile a kernel</link> ve <link xlink:href="http://www.digitalhermit.com/linux/kernel.html">Kernel Rebuild Procedure</link> belgelerine başvurunuz.
      </para>
  <para>
Çekirdeği <link xlink:href="http://www.debian.org">Debian</link> üzerinde kurmak için ayrıca <link xlink:href="http://www.debian.org/releases/stable/i386/ch-post-install.en.html#s-kernel-baking">Debian Installation Manual: Compiling a New Kernel</link>, <link xlink:href="http://www.debian.org/doc/manuals/debian-faq/ch-kernel.en.html">The Debian GNU/Linux FAQ: Debian and the kernel</link> ve <link xlink:href="http://www.debian.org/doc/manuals/reference/ch-kernel.en.html">Debian Reference: The Linux kernel under Debian</link> belgelerine başvurunuz. Eğer bir sorunla karşılaşırsanız "<command>zless /usr/share/doc/kernel-package/Problems.gz</command>" dosyasına bakınız.
    </para>
 </appendix>
 <appendix xml:id="linux-i386-boot-code-howto-internel_lds">
  <title>Dahili İlintileme Betiği</title>
  <para><option>-T</option> (<option>--script=</option>) seçeneği olmadan, hedefleri ilintilemek için <command>ld</command> bu yerleşik betiği kullanacaktır:
    </para>
<screen>[root@localhost linux]# <command>ld --verbose</command>
GNU ld version 2.13.90.0.18 20030206
  Desteklenen öykünümler:
   elf_i386
   i386linux
iç ilintileme betiği kullanılıyor:
==================================================
/* -z combreloc için betik: yeniden yerleştirme (reloc) bölümlerini
 * birleştirir ve sıralar */
OUTPUT_FORMAT("elf32-i386", "elf32-i386",
              "elf32-i386")
OUTPUT_ARCH(i386)
ENTRY(_start)
SEARCH_DIR("/usr/i386-redhat-linux/lib"); SEARCH_DIR("/usr/lib"); SEARCH_DIR("/u
sr/local/lib"); SEARCH_DIR("/lib");
/* "elf" için bunlardan herhangi birine ihtiyacımız var mı?
   __DYNAMIC = 0;    */
SECTIONS
{
  /* Salt okunur bölümler, metin bölütü üzerinde birleştirilmiş:*/
  . = 0x08048000 + SIZEOF_HEADERS;
  .interp         : { *(.interp) }
  .hash           : { *(.hash) }
  .dynsym         : { *(.dynsym) }
  .dynstr         : { *(.dynstr) }
  .gnu.version    : { *(.gnu.version) }
  .gnu.version_d  : { *(.gnu.version_d) }
  .gnu.version_r  : { *(.gnu.version_r) }
  .rel.dyn        :
    {
      *(.rel.init)
      *(.rel.text .rel.text.* .rel.gnu.linkonce.t.*)
      *(.rel.fini)
      *(.rel.rodata .rel.rodata.* .rel.gnu.linkonce.r.*)
      *(.rel.data .rel.data.* .rel.gnu.linkonce.d.*)
      *(.rel.tdata .rel.tdata.* .rel.gnu.linkonce.td.*)
      *(.rel.tbss .rel.tbss.* .rel.gnu.linkonce.tb.*)
      *(.rel.ctors)
      *(.rel.dtors)
      *(.rel.got)
      *(.rel.bss .rel.bss.* .rel.gnu.linkonce.b.*)
    }
  .rela.dyn       :
    {
      *(.rela.init)
      *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*)
      *(.rela.fini)
      *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*)
      *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*)
      *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.*)
      *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.*)
      *(.rela.ctors)
      *(.rela.dtors)
      *(.rela.got)
      *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*)
    }
  .rel.plt        : { *(.rel.plt) }
  .rela.plt       : { *(.rela.plt) }
  .init           :
  {
    KEEP (*(.init))
  } =0x90909090
  .plt            : { *(.plt) }
  .text           :
  {
    *(.text .stub .text.* .gnu.linkonce.t.*)
    /* .gnu.warning bölümleri özellikle elf32.em. tarafından yönetilir */
    *(.gnu.warning)
  } =0x90909090
  .fini           :
  {
    KEEP (*(.fini))
  } =0x90909090
  PROVIDE (__etext = .);
  PROVIDE (_etext = .);
  PROVIDE (etext = .);
  .rodata         : { *(.rodata .rodata.* .gnu.linkonce.r.*) }
  .rodata1        : { *(.rodata1) }
  .eh_frame_hdr : { *(.eh_frame_hdr) }
  .eh_frame       : ONLY_IF_RO { KEEP (*(.eh_frame)) }
  .gcc_except_table   : ONLY_IF_RO { *(.gcc_except_table) }
  /* Veri bölütü için adresi ayarla.  Bir sonraki sayfa yukarıda sayfadaki
     aynı adrese kadar ayarlamak istiyoruz. */
  . = ALIGN (0x1000) - ((0x1000 - .) &amp; (0x1000 - 1)); . = DATA_SEGMENT_ALIGN
(0x1000, 0x1000);
  /*  aşağıdaki *_array_* bölümünü desteklemeyen araçların (tools)
     geriye dönük uyumluluğu için, glibc'mizin crt dosyaları başvurdukları
     sembollerin zayıf tanımlamalarını içerir. Kesinlikle zorunlu
     olmadıkça onları kullanmak istemiyoruz, çünkü bize boş bölümler
     getirirler; aşağıdaki PROVIDE'dan faklı olarak.
     Bu yüzden crt dosyalarından olan bölümleri çıkartırız. */
  /DISCARD/ : {
      */crti.o(.init_array .fini_array .preinit_array)
      */crtn.o(.init_array .fini_array .preinit_array)
  }
  /* __preinit_array_start etiketinin uygun bir şekilde hizalandığından emin
     olun. Bunun yerine etiket tanımlamasını bölümün içine taşıyabilirdik fakat
     bağlayıcı ozaman boş olsa bile bölümü oluşturacaktı ki bu iyi değildir. */
  . = ALIGN(32 / 8);
  PROVIDE (__preinit_array_start = .);
  .preinit_array     : { *(.preinit_array) }
  PROVIDE (__preinit_array_end = .);
  PROVIDE (__init_array_start = .);
  .init_array     : { *(.init_array) }
  PROVIDE (__init_array_end = .);
  PROVIDE (__fini_array_start = .);
  .fini_array     : { *(.fini_array) }
  PROVIDE (__fini_array_end = .);
  .data           :
  {
    *(.data .data.* .gnu.linkonce.d.*)
    SORT(CONSTRUCTORS)
  }
  .data1          : { *(.data1) }
  .tdata          : { *(.tdata .tdata.* .gnu.linkonce.td.*) }
  .tbss           : { *(.tbss .tbss.* .gnu.linkonce.tb.*) *(.tcommon) }
  .eh_frame       : ONLY_IF_RW { KEEP (*(.eh_frame)) }
  .gcc_except_table   : ONLY_IF_RW { *(.gcc_except_table) }
  .dynamic        : { *(.dynamic) }
  .ctors          :
  {
    /* yapıcıların başlangıcını bulmak için gcc crtbegin.o'yu
       kullanır, böylece biz bunun ilk olduğunu anlarız.
       Bu bir joker karakter (wildcard) olduğundan, kullanıcının
       crtbegin.o'ya karşı ilintilememesinin bir önemi yoktur.
       bağlayıcı bir joker karakteri eşleştirmek için bir dosya
       aramayacaktır. Joker karakter ayrıca crtbegin.o'nun hangi
       dizinde bulunduğunun önemli olmadığı anlamına gelir. */
    KEEP (*crtbegin.o(.ctors))
    /* yapıcıların (ctors) sıralanmasının bitişine kadar,
       crtend.o dosyasından .ctor bölümünü dahil etmek istemiyoruz.
       crtend dosyasındaki .ctor bölümü yapıcıların sonu işaretini
       (end of ctors marker ) içerir ve bu sonuncu olmalıdır. */
    KEEP (*(EXCLUDE_FILE (*crtend.o ) .ctors))
    KEEP (*(SORT(.ctors.*)))
    KEEP (*(.ctors))
  }
  .dtors          :
  {
    KEEP (*crtbegin.o(.dtors))
    KEEP (*(EXCLUDE_FILE (*crtend.o ) .dtors))
    KEEP (*(SORT(.dtors.*)))
    KEEP (*(.dtors))
  }
  .jcr            : { KEEP (*(.jcr)) }
  .got            : { *(.got.plt) *(.got) }
  _edata = .;
  PROVIDE (edata = .);
  __bss_start = .;
  .bss            :
  {
   *(.dynbss)
   *(.bss .bss.* .gnu.linkonce.b.*)
   *(COMMON)
   /* .bss bölümlerinin _end'e kadar olan boşlukları kullandığından emin olmak
      için buraya hizala. Herhangi bir girdi olmadığından dolayı .bss bölümleri
      görünmese bile hizalamanın doğru olduğundan emin olmak için .bss'den sonra
      hizala.  */
   . = ALIGN(32 / 8);
  }
  . = ALIGN(32 / 8);
  _end = .;
  PROVIDE (end = .);
  . = DATA_SEGMENT_END (.);
  /* Stabs hata ayıklama bölümleri.  */
  .stab          0 : { *(.stab) }
  .stabstr       0 : { *(.stabstr) }
  .stab.excl     0 : { *(.stab.excl) }
  .stab.exclstr  0 : { *(.stab.exclstr) }
  .stab.index    0 : { *(.stab.index) }
  .stab.indexstr 0 : { *(.stab.indexstr) }
  .comment       0 : { *(.comment) }
  /* DWARF hata ayıklama bölümleri.
     DWARF hata ayıklama bölümlerindeki semboller
     bölümün başına bağıldır, bu yüzden onları 0'dan başlatırız.*/
  /* DWARF 1 */
  .debug          0 : { *(.debug) }
  .line           0 : { *(.line) }
  /* GNU DWARF 1 eklentileri (extensions) */
  .debug_srcinfo  0 : { *(.debug_srcinfo) }
  .debug_sfnames  0 : { *(.debug_sfnames) }
  /* DWARF 1.1 and DWARF 2 */
  .debug_aranges  0 : { *(.debug_aranges) }
  .debug_pubnames 0 : { *(.debug_pubnames) }
  /* DWARF 2 */
  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }
  .debug_abbrev   0 : { *(.debug_abbrev) }
  .debug_line     0 : { *(.debug_line) }
  .debug_frame    0 : { *(.debug_frame) }
  .debug_str      0 : { *(.debug_str) }
  .debug_loc      0 : { *(.debug_loc) }
  .debug_macinfo  0 : { *(.debug_macinfo) }
  /* SGI/MIPS DWARF 2 eklentileri */
  .debug_weaknames 0 : { *(.debug_weaknames) }
  .debug_funcnames 0 : { *(.debug_funcnames) }
  .debug_typenames 0 : { *(.debug_typenames) }
  .debug_varnames  0 : { *(.debug_varnames) }
}


==================================================
[root@localhost linux]#</screen>
 </appendix>
 <appendix xml:id="linux-i386-boot-code-howto-bootloader">
  <title>GRUB ve LILO</title>
  <para>
Hem <link xlink:href="http://www.gnu.org/software/grub">GNU GRUB</link> hem de <link xlink:href="http://freshmeat.net/projects/lilo">LILO</link> gerçek kipli çekirdek başlık biçimini tanır ve bootsect'i (tek sektör), kurulum kodunu (<literal>setup_sects</literal> sektörleri) ve sıkıştırılmış çekirdek imgesini (<literal>syssize</literal>*16 bayt) belleğe yükler. Onlar yükleyici belirletecini (<literal>type_of_loader</literal>) doldurur ve çekirdeğe uygun değiştirgeleri ve seçenekleri aktarmaya çalışır. İşlerini bitirdikten sonra denetim kurulum koduna geçer.
    </para>
  <sect1 xml:id="linux-i386-boot-code-howto-grub">
   <title>GNU GRUB</title>
   <para>
Aşağıdaki GNU GRUB yazılım taslağı grub-0.93 tabanlıdır.
      </para>
<screen>stage2/stage2.c:cmain()
`-- run_menu()
    `-- run_script();
        |-- builtin = find_command(heap);
        |-- kernel_func();            // "kernel" komutu için builtin-&gt;func()
        |   `-- load_image();         // boot.c içinde BOOTSEC_SIGNATURE'ı ara
        |   /* 0x100000'dan başlayan bellek (bvmlinux, bbootsect, bsetup)
        |    * veya (vmlinux, bootsect, setup) sırasında onlar tarafından
             * doldurulur */
        |-- initrd_func();            // "initrd" komutu için
        |   `-- load_initrd();
        `-- boot_func();              // örtük "boot" komutu için
            `-- linux_boot();         // stage2/asm.S içinde tanımlı
                or big_linux_boot();  // grub/asmstub.c! içinde değil

// stage2/asm.S içinde
linux_boot:
        /* çekirdeği kopyala */
        sistem kodunu 0x100000 adresinden 0x10000 adresine
          taşı (linux_text_len bytes);
big_linux_boot:
        /* gerçek kip kısmını kopyala */
        EBX = linux_data_real_addr;
        kurulum kodunu linux_data_tmp_addr (0x100000+text_len) adresinden
            linux_data_real_addr (0x9100 bytes) adresine taşı;
        /* %ebx değerini bölüt adresi olarak değiştir*/
        linux_setup_seg = (EBX &gt;&gt; 4) + 0x20;
        /* XXX çağıran işlevler için güvenli alandaki yeni yığıt göstericisi
        ESP = 0x4000;
        stop_floppy();
        /* linux önyüklemesi için son ayarlama */
        prot_to_real();
        cli;
        SS:ESP = BX:9000;
        DS = ES = FS = GS = BX;
        /* başlangıca sıçra, örn. ljmp linux_setup_seg:0
         * Dikkat ederseniz linux_setup_seg BX olarak değiştirildi. */
        .byte   0xea
        .word   0
linux_setup_seg:
        .word   0
</screen>
   <para>
GRUB kılavuzu için <command>info grub</command>'a bakın.
      </para>
   <para>
grub-0.93'ü uyarlıyorsanız ve <literal>bsetup</literal>'da değişiklik yapacaksanız <link xlink:href="http://mail.gnu.org/archive/html/bug-grub/2003-03/msg00030.html">bildirilmiş tek GNU GRUB hatası</link> dikkate alınmalıdır.</para>
  </sect1>
  <sect1 xml:id="linux-i386-boot-code-howto-lilo">
   <title>LILO</title>
   <para>
GRUB'dan farklı olarak, LILO sistemi önyüklerken yapılandırma dosyasını kontrol etmez. <command>lilo</command> uçbirimden çağırıldığında bazı trikler ortaya çıkar.
      </para>
   <para>
Aşağıdaki LILO yazılım anahatları lilo-22.5.8 tabanlıdır.
      </para>
<screen>lilo.c:main()
|-- cfg_open(config_file);
|-- cfg_parse(cf_options);
|-- bsect_open(boot_dev, map_file, install, delay, timeout);
|   |-- open_bsect(boot_dev);
|   `-- map_create(map_file);
|-- cfg_parse(cf_top)
|   `-- cfg_do_set();
|       `-- do_image();             // "image=" bölümü için walk-&gt;action
|           |-- cfg_parse(cf_image) -&gt; cfg_do_set();
|           |-- bsect_common(&amp;descr, 1);
|           |   |-- map_begin_section();
|           |   |-- map_add_sector(fallback_buf);
|           |   `-- map_add_sector(options);
|           |-- boot_image(name, &amp;descr) veya boot_device(name, range, &amp;descr);
|           |   |-- int fd = geo_open(&amp;descr, name, O_RDONLY);
|           |   |   read(fd, &amp;buff, SECTOR_SIZE);
|           |   |   map_add(&amp;geo, 0, image_sectors);
|           |   |   map_end_section(&amp;descr-&gt;start, setup_sects+2+1);
|           |   |       /* bsect_common()içinde iki sektör yaratıldı,
|           |   |        * bootsect için ise başka bir sektör*/
|           |   |   geo_close(&amp;geo);
|           |   `-- fd = geo_open(&amp;descr, initrd, O_RDONLY);
|           |       map_begin_section();
|           |       map_add(&amp;geo, 0, initrd_sectors);
|           |       map_end_section(&amp;descr-&gt;initrd,0);
|           |       geo_close(&amp;geo);
|           `-- bsect_done(name, &amp;descr);
`-- bsect_update(backup_file, force_backup, 0); // önyükleme sektörünü güncelle
    |-- make_backup();
    |-- map_begin_section();
    |   map_add_sector(table);
    |   map_write(&amp;param2, keytab, 0, 0);
    |   map_close(&amp;param2, here2);
    |-- // ... önyükleme sektörünün yeniden yerleştirilmesini yap
    |-- // ... bsect_wr'yi doğru yere ayarla
    |-- write(fd, bsect_wr, SECTOR_SIZE);
    `-- close(fd);
</screen>
   <para><literal>map_register()</literal> tüm kayıtlı sektörleri tanımlamakta kullanılan (<literal>CX, DX, AL</literal>) üçlüsü (veri yapısı <literal>SECTOR_ADDR</literal>) için bir liste tutarken <literal>map_add(), map_add_sector()</literal> ve <literal>map_add_zero()</literal> işlerini tamamlamak için <literal>map_register()</literal>'ı çağırabilir.
      </para>
   <para>
LILO sistemi yüklemek için <filename>first.S</filename> ve <filename>second.S</filename>'yi çalıştırır. Eşlem (map) dosyasını, bootsect ve kurulum kodunu yüklemek için <literal>second.S:doboot()</literal> yöntemini çağırır. Sonra, sistem kodunu yüklemek için <literal>lfile()</literal> yöntemini çağırır, <literal>launch2() -&gt; launch() -&gt; cl_wait() -&gt; start_setup() -&gt; start_setup2()</literal> yöntemini çağırır ve son olarak ayar kodunu çalıştırmak için <literal>jmpi 0,SETUPSEG</literal> komutunu çalıştırır.
      </para>
   <para>
LILO'nun ayrıntıları için "<command>man lilo</command>" ve "<command>man lilo.conf</command>"a bakınız.
      </para>
  </sect1>
  <sect1 xml:id="linux-i386-boot-code-howto-bootloader_ref">
   <title>Kaynakça</title>
   <simplelist>
    <member>
     <link xlink:href="http://www.gnu.org/software/grub/">GNU GRUB</link>
     </member>
     <member>
     <link xlink:href="http://www.openbg.net/sto/os/xml/grub.html">GRUB Tutorial</link>
     </member>
     <member>
     <link xlink:href="http://freshmeat.net/projects/lilo">LILO (freshmeat.net)</link>
     </member>
     <member>
     <link xlink:href="http://www.tldp.org/HOWTO/HOWTO-INDEX/os.html#OSBOOT">LDP HOWTO-INDEX: Boot Loaders and Booting the OS</link>
    </member>
   </simplelist>
  </sect1>
 </appendix>
 <appendix xml:id="linux-i386-boot-code-howto-faq">
  <title>SSS</title>
  <para>Henüz yok.</para>
 </appendix>
 <!-- rest of document follows... -->
</article>
