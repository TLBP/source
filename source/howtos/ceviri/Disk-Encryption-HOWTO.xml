<?xml version="1.0" encoding="UTF-8"?>
<!-- ********************************************************************
     Disk-Encryption-HOWTO.xml, v 1.4, GFDLv1.2 , Ocak 2004
     ******************************************************************** -->
<article xml:id="disk_sifreleme" xml:lang="tr">
 <?dbpdf pdf="no"?>
 <info>
  <title>Disk Şifreleme NASIL</title>
  <authorgroup>
   <author>
    <personname>
     <firstname>David</firstname>
     <surname>Braun</surname>
    </personname>
    <affiliation>
     <address>
      <email>cruhmoz602@sneakemail.com</email>
     </address>
    </affiliation>
   </author>
   <author role="translator">
    <personname>
     <firstname>Emin İslam</firstname>
     <surname>Tatlı</surname>
    </personname>
    <affiliation>
     <address>
      <email>eminislam@web.de</email>
     </address>
    </affiliation>
   </author>
   <author role="update">
    <personname>
     <firstname>Necdet</firstname>
     <surname>Yücel</surname>
    </personname>
    <affiliation>
     <address>
      <email>nyucel@comu.edu.tr</email>
     </address>
    </affiliation>
   </author>
  </authorgroup>
  <pubdate>Ocak 2004</pubdate>
  <revhistory>
   <revision>
    <revnumber>1.4</revnumber>
    <date>Kasım 2005</date>
    <authorinitials>NY</authorinitials>
    <revremark>Özgün belgeye uygun güncellendi</revremark>
   </revision>
   <revision>
    <revnumber>1.3</revnumber>
    <date>Ocak 2004</date>
    <authorinitials>EİT</authorinitials>
    <revremark>İlk çeviri</revremark>
   </revision>
  </revhistory>
  <revhistory>
   <revision>
    <revnumber>1.5</revnumber>
    <date>2004-11-17</date>
    <authorinitials>DB</authorinitials>
    <revremark>dm-crypt hakkında uyarı eklendi</revremark>
   </revision>
   <revision>
    <revnumber>1.4</revnumber>
    <date>2004-08-17</date>
    <authorinitials>DB</authorinitials>
    <revremark>Hata düzeltmeleri yapıldı, makul reddedebilme ve dm-crypt hakkında ipuçları eklendi</revremark>
   </revision>
   <revision>
    <revnumber>1.3</revnumber>
    <date>2003-12-18</date>
    <authorinitials>DB</authorinitials>
    <revremark>Diceware bağı eklendi.</revremark>
   </revision>
   <revision>
    <revnumber>1.2</revnumber>
    <date>2003-10-09</date>
    <authorinitials>DB</authorinitials>
    <revremark>boş oturumu kapatma ve Gentoo yönergeleri eklendi</revremark>
   </revision>
   <revision>
    <revnumber>1.1</revnumber>
    <date>2003-09-13</date>
    <authorinitials>DB</authorinitials>
    <revremark>Anahtar zincirinin sıfırlanma adımı eklendi</revremark>
   </revision>
   <revision>
    <revnumber>1.0</revnumber>
    <date>2003-08-28</date>
    <authorinitials>tmm</authorinitials>
    <revremark>LDP tarafından gözden geçirilen ilk yayım</revremark>
   </revision>
   <revision>
    <revnumber>0.92</revnumber>
    <date>2003-08-27</date>
    <authorinitials>DB</authorinitials>
    <revremark>LDP'ye ilk sunuş</revremark>
   </revision>
  </revhistory>
  <copyright>
   <year>2004</year>
   <holder>David Braun - Özgün belge</holder>
  </copyright>
  <sbr/>
  <copyright>
   <year>2004</year>
   <holder>Emin İslam Tatlı - Türkçe çevirinin 1.3 sürümü</holder>
  </copyright>
  <copyright>
   <year>2005</year>
   <holder>Necdet Yücel - Türkçe çevirinin 1.4 sürümü</holder>
  </copyright>
 </info>
 <para role="only.html">Ek - <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="fdl.html">GNU Free Documentation License</link></para>
 <section xml:id="disk_sifreleme-giris">
  <info>
   <title>GİRİŞ</title>
  </info>
  <para>
Linux yüklü bir dizüstü bilgisayarım var ve onun kaybolması ya da çalınması durumunda birinin kişisel bigilerimi okumasından endişelenmek istemiyorum. Oturum açma parolam birinin ön yükleme yapmasını     engelleyebilir ancak bu saldırganın diski söküp verileri okumasını engellemez. Daha kuvvetli bir korumaya ihtiyacım var.
   </para>
  <para>
Şanslıyız ki; şifreleme oldukça basittir. Böylece disk kötü ellere geçse bile, diskin verilerini okunabilir değildir. Şifreleme sadece dizüstü bilgisayarlar gibi taşınabilir bilgisayarlar için yararlı değildir-kişisel bilgi içeren her bilgisayarı korumak için kullanılabilir. Evde dosya dolabını hangi amaç ile kilitliyorsam, bilgisayarımın dosyalarınıda şifreleme ile bu sebeple koruyorum. Daha fazla motivasyon için, Michael Crawford'un <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.goingware.com/encryption/">Niçin Şifreleme Kullanmalısınız</link> yazısını okumak size ilginç gelebilir.
   </para>
  <para>
Sadece belirli dosyaları şifrelemeliydim, örneğin ev dizinimdeki dosyaları. Bu dosyalarımı koruyacaktı, fakat bu sefer disk üzerindeki şifrelenmemiş yerlerin açığa çıkmasından dolayı endişelenecektim. Bunun yerine bütün diski şifrelerim ve böylece bu sorunla uğraşmak zorunda kalmam.
   </para>
  <para>
Seçilebilecek birçok algoritma vardır. Ben <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://csrc.nist.gov/CryptoToolkit/aes/">AES</link>'i seçtim, çünkü Birleşik Devletler'in <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.nist.gov/">Ulusal Standartlar ve Teknoloji Enstitüsü</link> tarafından onaylıdır ve Kriptografi Topluluğu tarafından itibar görmektedir. Sözlük saldırılarına dayanıklı olmasını istediğim için uzun ve rastgele üretilmiş anahtar kullanırım. Böyle bir anahtarı ezberleme imkanım yoktur, bu sebepten dolayı anahtarı beraberimde kolayca taşıyabileceğim bir biçimde tutarım: USB flash sürücüde anahtar zincirimde. Anahtarı bir parola ile korurum böylece verilerim iki yolla korunmuş olurlar:  a) Elimde ne var ise (USB flash sürücü) ve b) Ne biliyorsam (parolam). Hatta arkadaşıma parolamı vermeden bilgisayarımı kullandırabilirim-arkadaşım kendi USB flash sürücüsünü ve parolasını kullanır.
  </para>
  <para>
İşletim sistemi şifrelenmiş verileri her zaman disk üzerinde tutar ve sadece kullanıldıklarında belleğe deşifre eder. Bu yolla bilgisayar aniden elektrik kesintisine uğrasada veriler güvenli kalırlar. Deşifre anahtarı belleğe ön yükleme esnasında yüklenir ve bilgisayar açık kaldığı sürece bellekte kalır, böylece bilgisayarı başlattıktan sonra USB flash sürücünün sürekli takılı  olmasına gerek kalmaz.
   </para>
  <para>
Bu NASIL belgesinde anlatılan yordam Linux 2.4 çekirdeği için yazılmıştır. Yerleşik şifreleme desteği ile gelen ve geridönüş aygıtlarının bölümlerinin yönetilmesi konusunda daha iyi olan Linux 2.6 çekirdeği ile bu yordam daha az karmaşık olacaktır.
   </para>
  <para>
Bu belge okuyucunun Linux hakkında orta seviyede tecrübesi olduğunu farzetmektedir.(<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.tldp.org/HOWTO/Kernel-HOWTO/index.html">Çekirdeğin yamanması ve derlenmesi </link> , <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.tldp.org/HOWTO/Multi-Disk-HOWTO.html">bölümleme, bağlama ve devreden çıkarma</link>) konularında yeterli bilgiye sahip olmalısınız.
   </para>
  <section xml:id="disk_sifreleme_teknikozet">
   <info>
    <title>Teknik Özet</title>
   </info>
   <para>
Şifreleme özel bir <wordasword>geridönüş aygıtı</wordasword> ile gerçekleştirilir. Geridönüş aygıtının kendisi herhangi bir veri depolamaz; bunun yerine bütün veri deposunu ve geridönüş isteklerini alır ve bunları disk ya da dosya gibi gerçek depolama aygıtına taşır. Verinin geçişi esnasında veri filtrelenir ve bizim durumumuzda kullanılan filtre şifrelemedir.
    </para>
   <para>
Sistem çalıştırıldığında, çıkarılabilir ortam (USB flash sürücü) GRUB, çekirdek ve initrd'yi kullanarak önyüklemeyi gerçekleştirir. GRUB menüsünden hem anahtar hem de çekirdek seçimi yapılır ve böylece bir tek çıkarılabilir ortamın bütün bilgisayarlar ile birlikte kullanılabilmesi sağlanır. <command>initrd</command> sadece parolayı sorabilecek ve şifreleme geridönüş aygıtını düzenleyip sisteme bağlamayı sağlayacak araçları içerir. Sisteme bağlama işleminden sonra, <literal>pivot_root</literal> önyükleme işlemini şifreleme aygıtından devralarak devam ettirir. Şifreleme geridönüş aygıtının takas ve kök dizin dosya sistemlerine ulaşmak için bölümler yerine geridönüş aygıtı göreli konumları kullanılırlar, çünkü 2.4 çekirdeği geridönüş aygıtı içinde bölümlere erişim hakkı sağlamaz. Göreli konumlar yöntemi çoklu bölümleri desteklemez, (ne yazık ki) çünkü  <command>losetup</command>'ın tanıyabildiği azami göreli konum 2GB dır.
    </para>
  </section>
  <section xml:id="disk_sifreleme_yasal">
   <info>
    <title>Telif Hakkı ve Lisans</title>
   </info>
   <para>
Bu belgeyi, Free Software Foundation tarafından yayınlanmış bulunan GNU Özgür Belgeleme Lisansının 1.2 ya da daha sonraki sürümünün koşullarına bağlı kalarak kopyalayabilir, dağıtabilir ve/veya değiştirebilirsiniz. Bu Lisansın bir kopyasını <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="fdl.html">GNU Free Documentation License</link> başlıklı bölümde bulabilirsiniz.
      </para>
   <para><trademark class="registered">Linux</trademark>, Linus Torvalds adına kayıtlı bir ticarî isimdir.
      </para>
  </section>
  <section xml:id="disk_sifreleme_disclaimer">
   <info>
    <title>Feragatname</title>
   </info>
   <para>
Bu belgedeki bilgilerin kullanımından doğacak sorumluluklar ve olası zararlardan belge yazarı sorumlu tutulamaz. Bu belgedeki bilgileri uygulama sorumluluğu uygulayana aittir.
      </para>
   <para>
Tüm telif hakları aksi özellikle belirtilmediği sürece sahibine aittir. Belge içinde geçen herhangi bir terim bir ticarî isim ya da kuruma itibar kazandırma olarak algılanmamalıdır. Bir ürün ya da markanın kullanılmış olması ona onay verildiği anlamında görülmemelidir.
      </para>
   <para>
Direktifleri okumaktan nefret ettiğinizi ve biliyorum, fakat herhangi birşeye dokunmadan önce bütün belgeyi okumanızı tavsiye ederim. Bütün NASILların bunu söylediğini biliyorum, fakat ben gerçekten bu belgeyi kastediyorum. Okumaya değer; bana güvenin. Yordamları gerçek sistemde uygulamadan önce bir deneme sisteminde denemeniz iyi olacaktır.
    </para>
  </section>
  <section xml:id="disk_sifreleme_tesekkur">
   <info>
    <title>Teşekkürler</title>
   </info>
   <para>Linus Torvalds'a, Jari Ruusu'a ve varlığı sayesinde bu NASIL belgesini var kılan Linux'a katkıda bulunan herkese teşekkürlerimi sunarım.
      </para>
   <para><link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.nist.gov/">Ulusal Standartlar ve Teknoloji Enstitüsü</link>'ne  böyle sağlam ve açık şifreleme algoritması seçtiği için teşekkürlerimi sunarım.
      </para>
   <para>
Mark Garboden'a ve <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://mail.nl.linux.org/linux-crypto/">linux-crypto</link> e-posta listesindekilere  ve yazdıklarımı gözden geçiren ve tavsiyelerde bulunan <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.tldp.org/mailinfo.html#maillists">Linux Belgelendirme Projesi e-posta listesindekilere</link> teşekkürlerimi sunarım.
      </para>
   <para>
Dikkatli okuyucular olan Ladislao Bastetti ve Norris Pouhovitch'e sıradışı donanım yapılandımaları için uğraştıkları
için, NASIL belgesinde hatalar buldukları ve güzel fikirler önerdikleri için teşekkürlerimi sunarım.
      </para>
  </section>
  <section xml:id="disk_sifrelem_feedback">
   <info>
    <title>Geribildirim</title>
   </info>
   <para>
Bu belge için geribildirimlerinizi gönderebilirsiniz. Lütfen eklemelerinizi, yorumlarınızı ve kritiklerinizi yazara gönderiniz.
    </para>
  </section>
  <section xml:id="disk_sifreleme_yaklasimlar">
   <info>
    <title>Yaklaşımlar</title>
   </info>
   <para>
Diski şifrelemek için üç farklı yaklaşım vardır: bütün hepsini, sadece bir bölümü ya da sadece bir dosyayı şifreleme. Ben en iyi güvenlik için birinci yaklaşımı özellikle tavsiye ederim. İlk iki yaklaşım önyüklemenin USB flash sürücü ya da kartvizit ebatındaki CD-ROM gibi çıkarılabilir ortamdan       yapıldığını farzeder. Bunu yapmak istemiyorsanız, yöntemi küçük, şifresiz önyükleme bölümü oluşturarak diskten önyükleme yapacak şekilde değiştirebilirsiniz. Bilgisayarınızın önyüklemeyi USB flash sürücüden yapmasını istiyorsanız, öncelikle anakartınızın bunu desteklediğinden emin olun. Bu belgenin hazırlandığı esnada birçok anakart bunu desteklemiyordu.
     </para>
   <para>
Heryerde bu üç yaklaşımı teker teker sıralamamak için neyi koruyorsanız bu <wordasword>şifrelenen veri</wordasword> olarak anılacaktır. Anahtarı depolamak için kullanılan çıkarılabilir ortamı ise <wordasword>anahtar zinciri</wordasword> diye adlandıracağım. Bunu anahtar yerine anahtar zinciri şeklinde kullanacağım, çünkü aynı ortamda herbiri farklı bilgisayar için kullanılan birden fazla anahtar depolayabiliriz.
     </para>
   <para>
    <warning>
     <para>
Bütün disk ve bölümleme yaklaşımlarında, bir adet takas alanı ve bir adet kök dizin dosya sistemi oluştururuz. Bazı kimseler kök dizin dosya sistemi için birden  fazla şifreli bölüm isterler. Ne yazık ki, burada açıklanan yöntem şifrelenen veri içerisinde alt bölümler oluşturmak için <command>losetup</command>'ın göreli konum değiştirgesine dayanır. Göreli konum değiştirgesi son bölüm hariç azami 2GB ile sınırlıdır. Bu 2GB ile sınırlı olan i386 mimarisi üzerinde takas alanı için gayet güzel çalışmaktadır, fakat harici kullanımlar için pratik olmayacağını tahmin ediyorum. 2GB dan ufak birden fazla bölümler oluşturma işlemini alıştırma için kullanıcıya bırakıyorum. Eğer 2GB dan daha büyük birden fazla bölüm sizin için önemli ise, size göreli konum değişkenini ortadan kaldıran Linux 2.6'yı beklemenizi öneririm.
     </para>
    </warning>
   </para>
   <section xml:id="disk_sifreleme_butundisk">
    <info>
     <title>Bütün Diskin Şifrelenmesi</title>
    </info>
    <para>
Veriniz etrafta dolaşmayı sevdiğinden veriyi şifreleyerek gizli tutmak bir sorudur. Şifrelemeyi verinizin etrafındaki çit gibi düşünebilirsiniz. Veri, çitin iç tarafında güvenlidir. Fakat veri en fazla yarar sağlamak için ağda iletilmeyi, CD-ROM gibi çıkarılabilir disklere kopyalanmayı ve arkadaşlar arasında paylaşılmayı sever. Ne zaman veriniz çiti terk ederse korumasız kalır. Verimizin gezindiği her yeri çevreleyecek şekilde bir şifreleme çiti koyamayız fakat çitinde olabildiğince geniş olmasını istemeyiz. Şifreleme çitini bütün diskin etrafına koyduğunuzda, veriniz diskin başka bölümüne geçse dahi veriniz korumasız kaldı diye endişelenmenize gerek yoktur.
       </para>
   </section>
   <section xml:id="disk_sifreleme_bolum">
    <info>
     <title xml:id="Partition">Disk Bölümlerinin Şifrelenmesi (çoklu önyüklemeli sistemler için)</title>
    </info>
    <para>
Eğer sistemdeki tek işletim sistemi Linux ise bütün diski şifrelemek uygundur, fakat bilgisayarlarında <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.kernel.org">Linux</link>, <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.netbsd.org/">NetBSD</link> ve <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://developer.apple.com/darwin/">Darwin</link> gibi birden fazla işletim sistemlerini kullananlar için bu mümkün değildir. Bu durumda sadece Linux bölümünü şifreleriz ve diğer bölümlere dokunmayız. Önyüklemeyi çıkarılabilir ortamdan yaptığımız için, Linux bölümünü çoklu önyüklemeli menü'ye eklemeye gerek yoktur. Bunun bütün diski şifrelemeye göre niye daha az güvenli olduğunu anlamak için <xref linkend="disk_sifreleme_Attack_Tree"/>'i  okuyunuz.
      </para>
   </section>
   <section xml:id="disk_sifreleme_file">
    <info>
     <title>Sadece Dosyaların Şifrelenmesi (ev dizinleri için)</title>
    </info>
    <para>
Bir dosya sistemindeki sadece bir dosyayı şifrelemek isteyebilirsiniz. Onu bir kere şifreledikten sonra, onun içine başka dosya sistemleri de dahil olmak üzere istediğinizi koyabilirsiniz. Örneğin bu yaklaşımı sadece ev dizininizi şifrelemekte kullanabilirsiniz. Bu bahsi geçen üç yaklaşımdan en az güvenli olanıdır ve tavsiye edilmez. Bu yaklaşımı seçerseniz, aşağıda bazı bölümleri atlamak için yönergeler göreceksiniz. Çünkü işletim sisteminizin önyüklemeyi tamamladığını ve takaslama konularını hallettiğinizi farzediyorum, dolayısı ile bu bölümler sizi ilgilendirmiyor. Bu NASIL belgesi sizin gereksinimizin çok üzerinde olabilir. Bunun yerine <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://sourceforge.net/projects/loop-aes/">loop-AES</link> ile birlikte gelen <literal><link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://loop-aes.sourceforge.net/loop-AES.README">README</link></literal> dosyasını okuyabilirsiniz. Bu yolu izleyecesiniz, burada bitirmeden önce <xref linkend="disk_sifreleme_Threat_Model"/> bölümünü okuyun.</para>
   </section>
  </section>
  <section xml:id="disk_sifreleme_Threat_Model">
   <info>
    <title>Saldırı Modeli</title>
   </info>
   <para>
Şifrelenecek verimizi iyi korumak için, öncelikle neyi neye karşı koruduğumuzu anlamak zorundayız. Genel düşünce sizin çalınmaya ve kaybolmaya açık bir dizüstü bilgisayarınız var ve bir de bu tehlikelere karşı anahtar deponuzu içeren güvenli USB flash sürücünüz var, sonuç olarak sistem dizüstü bilgisayarınızın çalınması durumuna göre tasarlnacaktır. Anahtar deponuzun cebinizde olduğu için kolay kolay çalınmayacağını farz ediyorum, çünkü saldırgan cebinizde önemli birşey olduğundan habersiz olacaktır. Eğer USB flash sürücüyü cebinizden çıkardığınızda teknik bilgisi olmayan biri onun ne olduğunu sorarsa ona bunun bir <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.pez.com/">Pez dispenser</link> olduğunu söyleyin.
      </para>
   <para>
    <note>
     <para>
Bu sistem, kişisel verinizin şifrelenebilirliği gerçeğini saklamanın hiçbir yolu olmaması anlamını taşıyan <wordasword>makul reddedebilme</wordasword> konusunda yetersiz kalır. Bu mücevherlerinizi bir kasaya kilitleyip, kasayı oturma odasında herkesin görebileceği bir yere koymanız gibidir. Kasayı sadece siz açabilirsiniz, fakat silahlı birisi sizden kasayı onun adına açmanızı isteyebilir. Eğer <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://zdnet.com.com/2100-11-502433.html?legacy=zdnn">bilgisayarınıza el konulacağından</link> endişeleniyorsanız ve dizüstü bilgisayarınızı, anahtar deponuzu ve paralonazı vermeniz söylendi ise, <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://stegfs.sourceforge.net/">StegFS</link> gibi farklı çözümlere başvurmanızı tavsiye ederim.
      </para>
     <para>Reddedebilme sorununa Norris Pouhovitch tarafından aşağıdaki çözüm önerilmiştir. Diskin başlangıcındaki küçük bir bölüme Windows kurup diskin geri kalanını şifrelemek mümkündür. Bilgisayar anahtar zinciri olmadan başlatılırsa normal olarak Windows açılır. Anahtar zinciriyle başlatıldığında ise Windows bölümü atlanır ve diskin geri kalanı deşifrelenerek Linux açılır.</para>
     <para>Bu planın avantajı eğer dizüstü bilgisayar çalınır ve başlatılırsa dikkatsiz saldırganlara görmeyi bekledikleri şeyi (bir Windows bilgisayarı) göstermesidir. Diğer yandan ciddi bir saldırgan sıradışı küçük disk bölümünü farkedecek ve meraklanacaktır. Bu NASIL belgesinin ilerideki sürümlerinde bu fikri ayrıntılarıyla anlatacağım.</para>
    </note>
   </para>
   <para>
    <table xml:id="disk_sifreleme_Attack_Tree">
     <info>
      <title>Saldırı Ağacı</title>
     </info>
     <tgroup cols="6">
      <colspec colname="A1"/>
      <colspec colname="A2"/>
      <colspec colname="A3"/>
      <colspec colname="A4"/>
      <colspec align="center"/>
      <thead>
       <row>
        <entry align="center" nameend="A4" namest="A1">Saldırı</entry>
        <entry>Tepki</entry>
        <entry align="center">Notlar</entry>
       </row>
      </thead>
      <tbody>
       <row valign="middle">
        <entry morerows="3">saldırgan dizüstü bilgisayarı çalar</entry>
        <entry nameend="A4" namest="A2">çalışır vaziyette iken</entry>
        <entry>
         <glossterm linkend="disk_sifreleme_SOL">ÜSN</glossterm>
        </entry>
        <entry>Şifrelenecek veri bilgisayar çalışırken korumasızdır çünkü şifreleme anahtarı bellektedir. Riski, işlem yapmama durumunda oturum kapama ile azaltabilirsiniz (<xref linkend="disk_sifreleme_Idle_Logout"/>), fakat bilgisayarınızın çalınmak üzere olduğunu düşünüyorsanız, derhal bilgisayarı kapatın ve hemen <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.aikidofaq.com/">Aikido NASIL</link>'ı okuyun.</entry>
       </row>
       <row valign="middle">
        <entry morerows="2">kapalı vaziyette iken</entry>
        <entry nameend="A4" namest="A3">saldırgan anahtar deposunu çalmadı ise</entry>
        <entry>
         <glossterm linkend="disk_sifreleme_new_key">yeni anahtar</glossterm>
        </entry>
       </row>
       <row valign="middle">
        <entry morerows="1">saldırgan anahtar zincirini çaldı ise</entry>
        <entry>saldırgan parolanızı biliyor ise</entry>
        <entry>
         <glossterm linkend="disk_sifreleme_SOL">ÜSN</glossterm>
        </entry>
       </row>
       <row valign="middle">
        <entry>saldırgan parolanızı bilmiyor ise</entry>
        <entry>
         <glossterm linkend="disk_sifreleme_new_key">yeni anahtar</glossterm>
        </entry>
       </row>
       <row valign="middle">
        <entry morerows="2">saldırgan anahtar zincirini ele geçirmiş fakat dizüstü bilgisayara sahip değil ise</entry>
        <entry nameend="A4" namest="A2">saldırgan parolayı biliyor ise</entry>
        <entry>
         <glossterm linkend="disk_sifreleme_new_key">yeni anahtar</glossterm>
        </entry>
        <entry>Şifrelenen veriniz risk altındadır, çünkü saldırgan verinizin şifresini çözebilir.</entry>
       </row>
       <row valign="middle">
        <entry morerows="1">saldırgan parolayı bilmiyor ise</entry>
        <entry nameend="A4" namest="A3">kendinizi tembel hissediyorsunuz ya da anahtar deponuzun çalınmadığına ama kaybolduğuna ikna olmuşsunuz</entry>
        <entry>
         <glossterm linkend="disk_sifreleme_new_passphrase">yeni parola</glossterm>
        </entry>
        <entry>Şifrelenen verinin parolasını değiştirme gereği duymuyorsunuz çünkü saldırgan parola olmadan şifreli verinin şifresini çözemez.</entry>
       </row>
       <row valign="middle">
        <entry nameend="A4" namest="A3">kendinizi paranoyak hissediyorsunuz</entry>
        <entry>
         <glossterm linkend="disk_sifreleme_new_key">yeni anahtar</glossterm>
        </entry>
       </row>
       <row valign="middle">
        <entry nameend="A4" namest="A1">saldırgan ağ üzerinden bilgi göndermeniz konusunda sizi ikna eder ise</entry>
        <entry>
         <glossterm linkend="disk_sifreleme_SOL">ÜSN</glossterm>
        </entry>
       </row>
       <row valign="middle">
        <entry nameend="A4" namest="A1">saldırgan çıkarılabilir ortamdan veri kopyalama konusunda sizi ikna eder ise</entry>
        <entry>
         <glossterm linkend="disk_sifreleme_SOL">ÜSN</glossterm>
        </entry>
       </row>
       <row valign="middle">
        <entry nameend="A4" namest="A1">sadece bir bölümü şifrelemiş iseniz ve işlem veriyi farklı bir bölüme yazar ise</entry>
        <entry>
         <glossterm linkend="disk_sifreleme_SOL">ÜSN</glossterm>
        </entry>
       </row>
       <row valign="middle">
        <entry nameend="A4" namest="A1">sadece bir dosyayı şifrelemiş iseniz ve işlem veriyi bellekten şifresiz takas alanına ya da <literal>/tmp</literal> altındaki bir dosyaya ya da şifresiz disk üzerinde bir yere yazar ise</entry>
        <entry>
         <glossterm linkend="disk_sifreleme_SOL">ÜSN</glossterm>
        </entry>
       </row>
       <row valign="middle">
        <entry nameend="A4" namest="A1">saldırgan tehlike arzedecek şekilde senden dizüstü bilgisayarı, anahtar zincirini ve parolayı teslim etmeni ister ise</entry>
        <entry>
         <glossterm linkend="disk_sifreleme_SOL">ÜSN</glossterm>
        </entry>
        <entry>Sistemde makul reddedebilme mümkün değildir.</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </para>
   <para>
    <glosslist xml:id="disk_sifreleme_reactions" xreflabel="Corrective Reactions">
     <glossentry>
      <glossterm xml:id="disk_sifreleme_new_passphrase">yeni parola</glossterm>
      <glossdef>
       <para>anahtar zincirinin yedekleme ünitesini tekrar yükle ve yeni bir parola seç.
          </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm xml:id="disk_sifreleme_new_key">yeni anahtar</glossterm>
      <glossdef>
       <para>Şifrelenen veriyi tekrar şifrelemek için yeni rastgele anahtar üret, yeni bir parola seç ve şifrelenen verinin yedek ünitesini tekrar yükle.
          </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm xml:id="disk_sifreleme_SOL">
       <acronym>ÜSN</acronym>
      </glossterm>
      <glossdef>
       <para>Üzgünüm! Son Nokta</para>
      </glossdef>
     </glossentry>
    </glosslist>
   </para>
  </section>
  <section xml:id="disk_sifreleme_caveats">
   <info>
    <title>Yetersizlikler</title>
   </info>
   <para>
    <itemizedlist>
     <listitem>
      <para>
Bu yöntem <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://swsusp.sourceforge.net/">Linux için Yazılım Askıya Alma</link> ile henüz çalışmamaktadır.
      </para>
     </listitem>
     <listitem>
      <para>
Diski şifreleme şüphesiz sistemi yavaşlatacaktır. Ne kadar yavaşlatacağı konusunda fikrim yok. Eğer karşılaştırmalı değerlendirme yaparsanız, lütfen bana gönderiniz.
      </para>
     </listitem>
     <listitem>
      <para><glossterm>makul reddebilmeyi</glossterm> destekleyen hiçbir şey bu yöntemde yoktur (<xref linkend="disk_sifreleme_Threat_Model"/>'e göz       atınız).
      </para>
     </listitem>
     <listitem>
      <para>
Bu yöntem ağ ve çıkarılabilir diskler yolu ile bilgi sızdırılmasını engellemeyecektir.
      </para>
     </listitem>
     <listitem>
      <para>
Şifreleme yedeklemeleri bu NASIL belgesinin içeriğine dahil değildir.
     </para>
     </listitem>
    </itemizedlist>
   </para>
  </section>
  <section xml:id="disk_sifreleme_requirements">
   <info>
    <title>Gereksinimler</title>
   </info>
   <para>
    <itemizedlist>
     <listitem>
      <para>
Kolayca erişim sağlanabilen çıkarılabilir ortam okuyuculu (USB kapı ya da CD-ROM sürücü gibi) bir bilgisayar
      </para>
     </listitem>
     <listitem>
      <para>
çıkarılabilir ortamdan önyüklemeyi destekleyen anakart (USB'yi dikkatlice kontrol edin, bütün hepsi desteklemiyor)
      </para>
     </listitem>
     <listitem>
      <para><glossterm>anahtar zinciri</glossterm> olarak kullanılabilen çıkarılabilir ortam (örneğin <glossterm>USB flash sürücü</glossterm>)
      </para>
     </listitem>
     <listitem>
      <para><link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.kernel.org/">Linux</link> 2.4
      </para>
     </listitem>
     <listitem>
      <para>
       <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://sourceforge.net/projects/loop-aes/">loop-AES</link>
      </para>
     </listitem>
    </itemizedlist>
   </para>
   <section xml:id="disk_sifreleme_digression">
    <info>
     <title>USB Flash Sürücüsü Hakkında</title>
    </info>
    <para>
Piyasada birçok seçenek bulunmaktadır. Ben kendiminkini aldığımda, aşağıdaki özelliklere sahip olandan satın aldım:
        </para>
    <para>
     <itemizedlist>
      <listitem>
       <para>
Fiziksel olarak ufak (beraberimde taşıyorum)
        </para>
      </listitem>
      <listitem>
       <para>
Azami hızda USB 2.0'ı  destekler
        </para>
      </listitem>
      <listitem>
       <para>
Yazma koruması anahtarına sahip, böylece şifreleme anahtarıma yanlışlıkla zarar vermiyorum.
        </para>
      </listitem>
     </itemizedlist>
    </para>
    <para>
Bir parmakizi okuyucu almanız konusunda kandırılmış olabilirsiniz. Almamanızı kesinlikle tavsiye ederim. Başlangıçta iyi bir fikir gibi gözükür, fakat işin içine biyometri girince, güvenliğiniz şunlara genişler:
        </para>
    <para>
     <itemizedlist>
      <listitem>
       <para>
Sahip olduğunuz birşey (USB flash sürücü)
        </para>
      </listitem>
      <listitem>
       <para>
Bildiğiniz birşey (parola)
        </para>
      </listitem>
      <listitem>
       <para>
olduğunuz birşey (parmak iziniz ya da herneyse)
        </para>
      </listitem>
     </itemizedlist>
    </para>
    <para>
Fakat birşeyin yanlış gittiğini düşünün. Eğer şimdi kendinize 'Ne yanlış gitmiş olabilir?' diye sorarsanız, o zaman niçin bu NASIL belgesini okuyorsunuz? Eğer birşey yanlış giderse, bir değişiklik yaparsınız (<xref linkend="disk_sifreleme_reactions"/> bölümüne göz atın):
         </para>
    <para>
     <itemizedlist>
      <listitem>
       <para>
Farklı bir USB flash sürücü kullanınır ve anahtarınızı değiştirirsiniz.
         </para>
      </listitem>
      <listitem>
       <para>
Eski parolayı değiştirir ve yeni bir parola kullanırsınız.
         </para>
      </listitem>
      <listitem>
       <para>
        <emphasis>Kendinizi değiştiremezsiniz.</emphasis>
       </para>
      </listitem>
     </itemizedlist>
    </para>
    <para>
Burada durun ve son satırı bir müddet düşünün.
        </para>
   </section>
  </section>
  <section xml:id="disk_sifreleme_future">
   <info>
    <title>Geleceğe Bakış</title>
   </info>
   <para>
       Bu belgeyi 2.4 çekirdek kullandığım dönemde yazdım. Linux 2.6 sizi losetup'ın göreli konumlarıyla oynamaktan kurtaran <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://sources.redhat.com/dm/">Device-mapper</link> ile gelir. Linux 2.6 aynı zamanda Device-mapper için oldukça şık bir şifreleme katmanı olan <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.saout.de/misc/dm-crypt/">dm-crypt</link>'i de ortaya çıkarmıştır. Maalesef <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://mareichelt.de/pub/texts.cryptoloop.php">güvenli değildir!</link> Umarım birgün hataları düzeltilir ama bugünlerde bile loop-AES ile birlikte en iyi yöntemdir.</para>
   <para>Bu NASIL belgesinin gelecekteki sürümlerinde Device-mapper'ın Linux 2.6 ile birlikte nasıl kullanıldığını açıklayacağım.</para>
  </section>
 </section>
 <section xml:id="disk_sifreleme_procedure">
  <info>
   <title>İşlemler</title>
  </info>
  <para>
Bu yöntem şifreli verinin şifrelenmeden önce içeriğinin silinmesine göre tasarlanmıştır. Şifrelenecek veriniz diskin üzerinde ise, geçici olarak veriyi başka biryere kopyalamalısınız ve daha sonra verinizi şifreleme işleminden sonra geri kopyalayabilirsiniz. Veriyi bulunuğu yerde şifrelemek mümkündür, ancak şu an için bunun bu NASIL belgesi için çok ileri seviyede olacağını düşünüyorum. Bu yöntem ilginizi çekiyor ise, daha fazla bilgi için <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://sourceforge.net/projects/loop-aes/">loop-AES</link>'in <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://loop-aes.sourceforge.net/loop-AES.README">README</link> belgesini okuyunuz.
    </para>
  <para>
Aşağıdaki işlemleri yapmak için <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://sourceforge.net/projects/loop-aes/">loop-AES</link> destekli çekirdeğe sahip bir sisteminiz olmalı. Şayet elinizde bir tane yok ise, <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.knoppix.com/">KNOPPIX</link> kullanmanızı tavsiye ederim. KNOPPIX önyüklemeyi CD-ROM'dan yapar ve kurulmasına gerek yoktur, yani KNOPPIX soruna neden olmayacak bir seçenektir.
    </para>
  <para>
Bu yönergeler, basitleştirmek için anahtar zinciri ile şifrelenecek verinin aynı bilgisayarda olduğunu farzeder, fakat bu şart değil. Yönergeleri sizin için hangisi daha uygunsa o şekilde değiştirebilirsiniz.
    </para>
  <section xml:id="disk_sifreleme_preparekeychain">
   <info>
    <title>Anahtar Zincirinin Hazırlanması</title>
   </info>
   <para>
Eğer bir disk ya da bölüm şifrelemek yerine sadece bir dosya şifreleme amacında iseniz, bu bölümü atlayabilir ve doğruca <xref linkend="disk_sifreleme_Asset"/> bölümü ile devam edebilirsiniz.
      </para>
   <para>
En ideal kurulum için <glossterm>USB flash sürücü</glossterm> ya da kartvizit boyutunda CD-ROM gibi önyüklemeli anahtar zinciri aygıtı kullanabilirsiniz. Bunun amacı, diskinizi mümkün olduğunca az açıkta bırakmak istiyoruz, fakat çok ufak bir önyükleme işlemi açığa vurulacaktır ya da bilgisayar hiçbir zaman çalıştırılmayacaktır. Önyükleme işlemi ancak şifresiz gerçekleştirilmesi gerektiğinden, anahtar zincirini bilgisayarda bulundurmamak daha iyidir. Birtakım nedenlerden dolayı önyüklemeli anahtar zinciri kullanamıyorsanız ya da kullanmak istemiyorsanız, o zaman bu yönergeleri yined e takip edebilirsiniz fakat anahtarları anahtar zinciri yerine diskin ufak bir önyükleme bölümü'nde bulundurabilirsiniz.
       </para>
   <para>
Aşağıdaki örnekte anahtar zinciri ilk SCSI sürücüsü <literal>/dev/sda</literal> olarak gözüküyor. <literal>/dev/sda</literal>'ı sürücünüzün aygıtı ile uygun olacak şekilde değiştirin.
       </para>
   <para>
İlk adım- anahtar zincirini sıfırlama-teknik açıdan gereksizdir, fakat <xref linkend="disk_sifreleme_Testing_and_Backup"/>'de tavsiye edildiği gibi eğer eşlem olarak yedeklerseniz, bu anahtar zincirini daha küçük yapacaktır.
       </para>
   <para>
    <screen>
     <prompt>bash# </prompt>
     <command>dd if=/dev/zero of=/dev/sda</command>
    </screen>
   </para>
   <para>
Sonra, anahtar zincirini herhangi bir önyüklemeli diski bölümlediğiniz gibi bölümleyin. Bölümleme konusunda yardıma ihtiyacınız var ise <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.tldp.org/HOWTO/Partition/index.html">Linux Bölümleme NASIL</link> belgesine göz atınız.
       </para>
   <para>
    <screen>
     <prompt>bash# </prompt>
     <command>cfdisk /dev/sda</command>
    </screen>
   </para>
   <para>
İlk bölüme bir dosya sistemi yerleştirin.
       </para>
   <para>
    <screen>
     <prompt>bash# </prompt>
     <command>mkfs /dev/sda1</command>
    </screen>
   </para>
   <para>
Anahtar zincirine bağlayın.
       </para>
   <para>
    <screen>
     <prompt>bash# </prompt>
     <command>mkdir /tmp/keychain</command>
     <prompt>bash# </prompt>
     <command>mount /dev/sda1 /tmp/keychain</command>
     <prompt>bash# </prompt>
     <command>cd /tmp/keychain</command>
    </screen>
   </para>
   <section xml:id="disk_encryption_buildkernel">
    <info>
     <title>Çekirdek Derleme</title>
    </info>
    <para>
Anahtar zincirini birden fazla bilgisayar ile birlikte kullanacaksanız, herbiri için farklı bir çekirdek derlemeniz gerekir.
        </para>
    <para>
Muhtemelen anahtar zinciriniz için özel bir çekirdek derlemeniz gerekecektir, böylece iki şeyden emin olabilirsiniz:
        </para>
    <para>
     <itemizedlist>
      <listitem>
       <para><link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://sourceforge.net/projects/loop-aes/">loop-AES</link> ile doğru şekilde yamanmıştır ve şifreleme desteği etkinleştirilmiştir.
        </para>
      </listitem>
      <listitem>
       <para>
Bilgisayarınızı önyüklemesini sağlayan ve şifrelenecek  veriye erişimi sağlayan bütün aygıt sürücüleri modül olarak eklenmek yerine çekirdeğin içinde derlenmişlerdir.
        </para>
      </listitem>
     </itemizedlist>
    </para>
    <para><command>initrd</command> kullandığımız için aygıt sürücülerini modül olarak yükleyebilirsiniz, fakat ben önyükleme diskini mümkün olduğunca basit tutmak için çekirdeğin içine derlemeyi seçtim. Siz başka bir yol deneyebilirsiniz.
        </para>
    <para>
Geleneksel bir çekirdek oluşturmak için yardıma ihtiyacınız var ise <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.tldp.org/HOWTO/Kernel-HOWTO/index.html">Linux Çekidek NASIL</link> belgesini okuyabilirsiniz. Çekirdeği <literal>CONFIG_BLK_DEV_RAM</literal> içerecek şekilde oluşturduğunuzdan emin olun, böylece çekirdek <command>initrd</command> kullanarak önyükleme gerçekleştirebilir.
        </para>
    <para><link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://sourceforge.net/projects/loop-aes/">loop-AES</link> ile birlikte gelen yönergeleri izleyerek döngü aygıtını oluşturun.
Ayrıca bir kısmını daha sonra anahtar zincirine kopyalayacağımız <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.kernel.org/pub/linux/utils/util-linux/">util-linux</link> araçlarını tekrar oluşturmak için yönergeleri izleyin.
Dağıtımınız bunları sizin için zaten yapmış olabilir (örneğin, Debian'nın <literal>loop-aes-utils</literal> ve <literal>loop-aes-source</literal> paketleri).
        </para>
    <para>
Çekirdeği oluşturduktan sonra, anahtar zincirine kopyalayın.
        </para>
    <para>
     <screen>
      <prompt>bash# </prompt>
      <command>mkdir boot</command>
      <prompt>bash# </prompt>
      <command>cp arch/i386/boot/bzImage boot/vmlinuz-laptop</command>
     </screen>
    </para>
    <para><link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.gnu.org/software/grub/grub.html">GRUB</link>'u ya da favoriniz olan önyükleyiciyi yükleyiniz.
        </para>
    <para>
     <screen>
      <prompt>bash# </prompt>
      <command>grub-install --root-directory=. /dev/sda</command>
     </screen>
    </para>
    <para>
Burada GRUB için örnek bir <filename>menu.lst</filename> dosyası bulunmaktadır. Bu dosya <systemitem class="systemname">laptop</systemitem> ve <systemitem class="systemname">desktop</systemitem> isimli iki bilgisayar için girdi içermektedir.
        </para>
    <para>
     <important>
      <para>
Anahtar ismini (bilgisayarın ardından isimlendirilmesini tavsiye ederim) <xref linkend="disk_sifreleme_linuxrc"/>'ye ilk parametre olarak aktarmak gerekmektedir.
        </para>
     </important>
    </para>
    <example>
     <info>
      <title>
       <filename>/tmp/keychain/boot/grub/menu.lst</filename>
      </title>
     </info>
     <programlisting>title  laptop
root (hd0,0)
kernel /boot/vmlinuz-laptop root=/dev/ram0 init=/linuxrc laptop
initrd /boot/initrd

title  desktop
root (hd0,0)
kernel /boot/vmlinuz-desktop root=/dev/ram0 init=/linuxrc desktop
initrd /boot/initrd.old
</programlisting>
    </example>
   </section>
   <section xml:id="disk_encryption_makeinitrd">
    <info>
     <title>initrd Oluşturma</title>
    </info>
    <para>
Anahtar zincirini <command>initrd</command>'yi kullanarak önyükleriz, böylece önyükleme başladıktan sonra anahtar zincirini çıkarabiliriz (kim bir kafeteryada otururken dizüstü bilgisayarından USB flash sürücünün sarkmasını ister ki?). Şifreli veriye ulaşabilmek için <command>initrd</command>'nin <filename>/dev/loop0</filename> dosyasına eklenmiş olan bir geridönüş aygıtı oluştururuz.  Aygıt dosyasını <command>initrd</command>'ye koymak, şifreli veri bağlı olduğu sürece <command>initrd</command>'nin de bağlı olması gerektiği anlamına gelir (sorun değil).
        </para>
    <para>
Başlangıç RAM diskleri hakkında daha fazla bilgi edinmek için <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.tldp.org/HOWTO/Bootdisk-HOWTO/index.html">Linux  Önyükleme Diski NASIL</link> ve Linux'ün <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://linux.bkbits.net:8080/linux-2.4/anno/Documentation/initrd.txt@1.2?nav=index.html%7Csrc/%7Csrc/Documentation"><filename>Documentation/initrd.txt</filename></link> belgelerini okuyabilirsiniz ya da bunu geçip devam edebilirsiniz.
        </para>
    <para>
Tamamını kullanmayacak olsak da 4MB büyüklüğünde başlangıç RAM diski seçiyoruz. Bu büyüklük geleneksel azami büyüklüktür (ve bir zararı yoktur).
        </para>
    <para>
     <screen>
      <prompt>bash# </prompt>
      <command>head -c 4m /dev/zero &gt; boot/initrd</command>
      <prompt>bash# </prompt>
      <command>mke2fs -F -m0 -b 1024 boot/initrd</command>
     </screen>
    </para>
    <para><command>initrd</command>'yi bağlayalım, böylece üzerinde çalışabiliriz.
        </para>
    <para>
     <screen>
      <prompt>bash# </prompt>
      <command>mkdir /tmp/initrd</command>
      <prompt>bash# </prompt>
      <command>mount -o loop=/dev/loop3 boot/initrd /tmp/initrd</command>
      <prompt>bash# </prompt>
      <command>cd /tmp/initrd</command>
     </screen>
    </para>
    <para>
İhtiyacımız olan en ufak dizin yapısını oluşturalım.
        </para>
    <para>
     <screen>
      <prompt>bash# </prompt>
      <command>mkdir -p {bin,dev,lib,mnt/{keys,new-root},usr/sbin,sbin}</command>
     </screen>
    </para>
    <para>
İhtiyacımız olan en ufak aygıt kümesini oluştalım. <filename>tty</filename>'nin parola istemi için gerekli olduğunu unutmayın. Bu komut şifrelenecek verinizin <filename>/dev/hda</filename> sürücüsü olduğunu farzeder. Bunu uygun şekilde değiştirebilirsiniz.
        </para>
    <para>
     <screen>
      <prompt>bash# </prompt>
      <command>cp -a /dev/{console,hda,loop0,loop1,tty} dev</command>
     </screen>
    </para>
    <para>
İhtiyacımız olan 6 yazışımı kopyalayacağız.
        </para>
    <para>
     <tip>
      <para><command>which</command> komutunu bir uygulamanın tam yolunu bulmak için kullanabilirsiniz, örneğin:
        </para>
      <para>
       <screen><prompt>bash# </prompt><command>which mount</command>
/bin/mount
</screen>
      </para>
     </tip>
    </para>
    <para>
Uygulamaları kopyalayalım:
        </para>
    <para>
     <screen>
      <prompt>bash# </prompt>
      <command>cp /bin/{mount,sh,umount} bin</command>
      <prompt>bash# </prompt>
      <command>cp /sbin/{losetup,pivot_root} sbin</command>
      <prompt>bash# </prompt>
      <command>cp /usr/sbin/chroot usr/sbin</command>
     </screen>
    </para>
    <para>
Şimdi de ugulamaların bağımlı olduğu paylaşımlı kütüphaneleri kopyalayalım.
        </para>
    <para>
     <tip>
      <para>
Bir uygulamanın (bu örnekte <literal>/bin/sh</literal>) kullandığı paylaşımlı kütüphaneleri bulmak için:
        </para>
      <para>
       <screen><prompt>bash# </prompt><command>ldd /bin/sh</command>
        libncurses.so.5 =&gt; /lib/libncurses.so.5 (0x40020000)
        libdl.so.2 =&gt; /lib/libdl.so.2 (0x4005c000)
        libc.so.6 =&gt; /lib/libc.so.6 (0x4005f000)
        /lib/ld-linux.so.2 =&gt; /lib/ld-linux.so.2 (0x40000000)
</screen>
      </para>
     </tip>
    </para>
    <para>
Kütüphaneleri kopyalayalım:
        </para>
    <para>
     <screen>
      <prompt>bash# </prompt>
      <command>cp /lib/{ld-linux.so.2,libc.so.6,libdl.so.2,libncurses.so.5} lib</command>
     </screen>
    </para>
   </section>
  </section>
  <section xml:id="disk_sifreleme_Asset">
   <info>
    <title>Şifrelenecek Verinin Hazırlanması</title>
   </info>
   <para>
Aynı anahtar zincirini kullanarak birden fazla bilgisayarı idare etmek için bu adımları tekrarlamak mümkündür. Her bilgisayar kendi anahtarına ve bir ihtimalle kendi çekirdeğine sahip olacaktır. Bu yönergeler bilgisayar isminin <systemitem class="systemname">laptop</systemitem> olduğunu farzeder; bu adımları her tekrarladığınız sefer bilgisayarınızın adını buna göre ayarlayınız.
      </para>
   <para>
İlk önce verinizi yedekleyin. <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.tldp.org/HOWTO/Linux-Complete-Backup-and-Recovery-HOWTO/index.html">Linux Tam Yedekleme ve Onarım NASIL</link>'ı okuyun.
      </para>
   <para>
Hayır, dur, beni dinle. Verinin yedeğini al. Gerçekten. Yaptığın bir hatadan dolayı şifrelediğin diskin şifresini çözememek zevk vermez. Bu araçlar kuvvetli sırdırlar; eğer verinizi uçurursanız, <emphasis>Bilgisayar Dahilerini</emphasis> çağırıp onların verilerinizi geri getirmelerini umamazsınız. Bu alıştırmanın ana noktası budur.
      </para>
   <para>
Bütün diskinizi şifreliyorsanız (tavsiye edilir), <filename>/dev/hda</filename>'yı sizin disk aygıtınız ile değiştirin.
      </para>
   <para>
    <screen>
     <prompt>bash# </prompt>
     <command>ln -s /dev/hda /tmp/asset</command>
    </screen>
   </para>
   <para>
Eğer bir bölümü şifreliyorsanız (çoklu önyükleme durumu), <filename>/dev/hda3</filename>'ü sizin bölümünüzün aygıtı ile değiştirin.
      </para>
   <para>
    <screen>
     <prompt>bash# </prompt>
     <command>ln -s /dev/hda3 /tmp/asset</command>
    </screen>
   </para>
   <para>
Sadece bir dosya şifreliyorsanız, <filename>~/encrypted</filename> dosyasını sizin dosyanız ile değiştirin ve <filename>/tmp/keychain</filename> isminde anahtar dosyanızı kaydedeceğiniz yeri (hazırda bulunan çıkarılabilir ortam, örneğin: <filename>/mnt/cf</filename>) işaret eden bir sembolik bağ oluşturun.
      </para>
   <para>
    <screen>
     <prompt>bash# </prompt>
     <command>ln -s ~/encrypted /tmp/asset</command>
     <prompt>bash# </prompt>
     <command>ln -s /mnt/cf /tmp/keychain</command>
    </screen>
   </para>
   <para>
Şifrelenecek verinizi rasgele veri ile hazırlayın. Bu saldırganın hangi bölümlerin boş alan olduğunu bulmasını zorlaştıracktır.
      </para>
   <para>
    <screen>
     <prompt>bash# </prompt>
     <command>shred -n 1 -v /tmp/asset</command>
    </screen>
   </para>
   <para>
Burada anahtarları bulunduracak şifreli bir dosya sistemi oluşturuyoruz. Daha fazla şifreleme, ister misiniz? Evet, anahtar deponuzun çalınması durumunda (<xref linkend="disk_sifreleme_Attack_Tree"/>), anahtarlarınızın ortaya çıkmasını istemezsiniz. Dosya sisteminin boyutu olarak 1 MB seçtim çünkü yuvarlak bir rakam. Anahtarlar için bu kadar bir alana ihtiyacımız olmayacak, o zaman isterseniz daha ufak bir boyut seçebilirsiniz (her anahtar 61 byte uzunluğundadır).
      </para>
   <para>
Tekrar rasgele veri ile ilklendirin.
      </para>
   <para>
    <screen>
     <prompt>bash# </prompt>
     <command>cd /tmp/initrd</command>
     <prompt>bash# </prompt>
     <command>head -c 1m /dev/urandom &gt; keys</command>
    </screen>
   </para>
   <para>
Parolayı sözlük saldırılarına dayanıklı kılmak için tohum üreteceğiz. Ne zaman <replaceable>&lt;seed&gt;</replaceable> sembolünü görürseniz, onu sizin oluşturduğunuz ile değiştirdiğinizden emin olun. Şu komut ekranda rasgele bir tohum gösterecektir.
      </para>
   <para>
    <screen>
     <prompt>bash# </prompt>
     <command>head -c 15 /dev/random | uuencode -m - | head -2 | tail -1</command>
    </screen>
   </para>
   <para>
Tohumu kullanarak geridönüş aygıtını kurun. Parolanızı burada seçiyorsunuz. Unutmayacağınız birşey seçin. <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://world.std.com/~reinhold/diceware.html">Diceware</link> yöntemini güvenli bir parola seçmek için kullanmak isteyebilirsiniz.
      </para>
   <para>
    <screen>
     <prompt>bash# </prompt>
     <command>losetup -e AES128 -C 100 -S <replaceable>&lt;seed&gt;</replaceable> -T /dev/loop1 keys</command>
    </screen>
   </para>
   <para>
Anahtar dosya sistemini biçimlendirin ve bağlayın (<xref linkend="disk_sifreleme_decrypt.sh"/> betiği <literal>ext2</literal> dosya sistemini kullandığınızı farzeder).
      </para>
   <para>
    <screen>
     <prompt>bash# </prompt>
     <command>mke2fs /dev/loop1</command>
     <prompt>bash# </prompt>
     <command>mkdir /tmp/keys</command>
     <prompt>bash# </prompt>
     <command>mount /dev/loop1 /tmp/keys</command>
    </screen>
   </para>
   <para>
Şimdi gerçek şifrelenecek verinin anahtarı için 45 byte, bilgisayarınızın oluşturabildiği kadar rasgele seçilmiş olsun. Saldırgan, şimdi sözlük saldırısı deneyebilir! Haha! Anahtarı <systemitem>laptop</systemitem> diye isimlendirdiğimiz bilgisayar adından sonra isimlendiririz. Bunun yerine bilgisayarınızın adını kullanın.
      </para>
   <para>
    <screen>
     <prompt>bash# </prompt>
     <command>head -c 45 /dev/random | uuencode -m - | head -2 | tail -1 &gt; /tmp/keys/laptop</command>
    </screen>
   </para>
   <para>
Şifrelenecek veriye şifreli erişim sağlayan geridönüş aygıtını anahtar ile birlikte kurun.
      </para>
   <para>
    <screen>
     <prompt>bash# </prompt>
     <command>losetup -e AES128 -p 0 /dev/loop0 /tmp/asset &lt; /tmp/keys/laptop</command>
    </screen>
   </para>
   <para>
Anahtar dosya sistemini devreden çıkarın.
      </para>
   <para>
    <screen>
     <prompt>bash# </prompt>
     <command>umount /tmp/keys</command>
     <prompt>bash# </prompt>
     <command>losetup -d /dev/loop1</command>
    </screen>
   </para>
   <section xml:id="disk_sifreleme_swappartition">
    <info>
     <title>Takas Bölümü</title>
    </info>
    <para>
Sadece bir dosya şifreliyorsanız bu bölümü atlayın.
        </para>
    <para><command>mkswap</command>'a boyut parametresi vermek kritiktir, çünkü bu komutu sadece ona adanmış bir bölüm için kullanmıyoruz. İstediğiniz boyutu seçin, ben 2GB seçtim.
        </para>
    <para>
     <screen><prompt>bash# </prompt><command>mkswap /dev/loop0 $((2*1024*1024))</command>
mkswap: warning: truncating swap area to 2097144kB
Setting up swapspace version 1, size = 2147471360 bytes
</screen>
    </para>
   </section>
   <section xml:id="disk_sifreleme_rootfilesystem">
    <info>
     <title>Kök Dosya Sistemi</title>
    </info>
    <para>
Sadece bir dosya şifreliyorsanız, bunun gibi bir dosya sistemi ile şifreleyin ve <xref linkend="disk_sifreleme_Scripts"/> bölümüne atlayın.
       </para>
    <para>
     <screen>
      <prompt>bash# </prompt>
      <command>mkfs /dev/loop0</command>
     </screen>
    </para>
    <para>
Takas alanından sonra kök 'bölümünü' oluşturacağız. 'bölüm' kelimesini tırnak içinde yazıyorum çünkü gerçek bir bölüm değildir. <command>losetup</command>'ın <command>-o</command> göreli konum argümanını kullanarak onu yanıltıyoruz.
       </para>
    <para><literal>mkswap</literal>'in takas alanın istenen boyutta olması gerekmeyen gerçek boyutunu bize nasıl belirttiğine dikkat edin. Göreli konumu kök dosya sistemine başlamak için belirlerken gerçek boyutu (yukarıdaki örnekte 2147471360 idi) kullanın.
       </para>
    <para>
     <screen>
      <prompt>bash# </prompt>
      <command>losetup -o <replaceable>&lt;root offset&gt;</replaceable> /dev/loop1 /dev/loop0</command>
     </screen>
    </para>
    <para>
Eğer şifrelenecek veri bütün disk ya da diskin son bölümü ise, o zaman dosya sistemi için bir boyut belirliyeceğiz diye telaşa gerek yoktur. Sizin durumunuz buna uyuyor ise aşağıdakileri yapın ve <xref linkend="disk_sifreleme_initrd_Mount_Point"/>kısmına geçin.
        </para>
    <para>
     <screen>
      <prompt>bash# </prompt>
      <command>mkfs /dev/loop1</command>
     </screen>
    </para>
    <para>
Şifrelenecek veri diskin son bölümü olmadığı için, <literal>mkfs</literal>'e boyut kısıtlaması vermek zorundayız ya da bunun ile diskin sonu arasındakı bütün bölümlere yazılacaktır. Tekrarlıyorum, <emphasis>eğer <command>mkfs</command>'e doğru boyutta parametre vermez iseniz, veri kaybına uğrayabilirsiniz</emphasis>.  <command>mkfs</command> aslında sadece bir ön uçtur, dolayısı ile azami ölçüde dikkatli olmak için gerçek bir dosya sistemi oluşturucusu seçeceğiz, bu durumda <command>mke2fs</command>'i.
        </para>
    <para>
Dosya sisteminin boyutunu öbeklerle belirtmek sureti ile kısıtlamak mümkündür, fakat <command>mke2fs</command> öbek boyutunu dosya sisteminin boyutuna dayanarak seçer. Klasik Catch-22! Bizim için öbek boyutun ne seçileceğini bulabilir (istediğimizden de fazlası).
        </para>
    <para>
     <screen><prompt>bash# </prompt><command>mke2fs -n -j /dev/loop1</command>
mke2fs 1.34-WIP (21-May-2003)
Filesystem label=
OS type: Linux
Block size=4096 (log=2)
Fragment size=4096 (log=2)
9781248 inodes, 19544448 blocks
977222 blocks (5.00%) reserved for the super user
First data block=0
597 block groups
32768 blocks per group, 32768 fragments per group
16384 inodes per group
Superblock backups stored on blocks:
        32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632, 2654208,
        4096000, 7962624, 11239424
</screen>
    </para>
    <para>
Bu durum için 4096 seçti. Ne seçerse seçsin bizim dosya sistemimiz için yakın bir değerdir. Doğru boyutu blok cinsinden hesaplayınız.
        </para>
    <para>
     <blockquote>
      <para>
dosya sistemi boyutu = (bölüm boyutu - takas alanın boyutu) / blok boyutu
        </para>
     </blockquote>
    </para>
    <para>
Bölümün boyutunu 10GB ve takas bölümünün boyutunu 2GB farzedin. <command>mke2fs</command> için doğru boyut:
        </para>
    <para>
     <literallayout class="normal">
(10 - 2) x 2<superscript>30</superscript> / 4096 = 2097152
</literallayout>
    </para>
    <para>
Yanlış anlamayın! Yedekleme yapın! İki kere ölçün, bir kere biçin!
         </para>
    <para>
     <screen>
      <prompt>bash# </prompt>
      <command>mke2fs -j /dev/loop1 2097152</command>
     </screen>
    </para>
    <section xml:id="disk_sifreleme_initrd_Mount_Point">
     <info>
      <title><literal>initrd</literal> Bağlama Noktası</title>
     </info>
     <para>
Yeni kök dosya sistemini bağlayın ve <filename>initrd</filename> bağlama noktasını oluşturun. Bu <xref linkend="disk_sifreleme_linuxrc"/> betiğinin <literal>pivot_root</literal> çağrısı için gereklidir.
          </para>
     <para>
      <screen>
       <prompt>bash# </prompt>
       <command>mount /dev/loop1 mnt/new-root</command>
       <prompt>bash# </prompt>
       <command>mkdir mnt/new-root/initrd</command>
       <prompt>bash# </prompt>
       <command>umount mnt/new-root</command>
      </screen>
     </para>
    </section>
   </section>
  </section>
  <section xml:id="disk_sifreleme_Scripts">
   <info>
    <title>Betikler</title>
   </info>
   <para>
Şifre çözme betiğini oluşturmak için yeterli bilgimiz var. Değişkenleri başlangıçta değiştirin (önceden ürettiğiniz tohum da dahil).
      </para>
   <para>
Bütün diski ya da bir bölümü şifreliyorsanız, <varname>ROOT_OFFSET</varname>'e <command>mkswap</command>'den aldığınız değeri atayın. Betiği  <filename>/tmp/initrd</filename> dizinine koyun ve ismini <filename>decrypt.sh</filename> olarak değiştirin.
      </para>
   <para>
Sadece bir dosya şifreliyorsanız, o zaman bu betik herhangi bir yerde bulunabilir. Bu durumda <varname>ROOT_OFFSET</varname>'e 0 atadığınızdan emin olun ve <varname>MOUNT</varname>'ta da uygun bir bağlama noktası atayın (muhtemelen <filename>/mnt/new-root</filename> değil).
      </para>
   <para>
    <figure xml:id="disk_sifreleme_decrypt.sh" xreflabel="decrypt.sh">
     <info>
      <title>
       <filename>/tmp/initrd/decrypt.sh</filename>
      </title>
     </info>
     <programlisting>#!/bin/sh

SEED=<replaceable>&lt;seed&gt;</replaceable>
ASSET=/dev/hda
ROOT_OFFSET=<replaceable>&lt;root offset&gt;</replaceable>
ROOT_TYPE=ext3
MOUNT=/mnt/new-root
KEY="$1"

# Anahtarları açmak için parola sor (bu anahtar zinciri sahibi
tarafından kaybedildiğinde anahtarların ortaya çıkmasını engeller).
Kullanıcıya parolayı bilebilmesi için üç hak verin.

for ((FAILED=1, TRY=1; ($FAILED != 0) &amp;&amp; (TRY &lt;= 3); TRY++))
do
        mount -n -t ext2 -o loop=/dev/loop1,encryption=AES128,itercountk=100,pseed=$SEED keys /mnt/keys
        FAILED=$?
done

if [ $FAILED -ne 0 ]; then
        echo "Üzgünüm, parolayı tahmin için sadece üç hakkınız var."
        exit 1
fi

# Şifreli veriyi çözmek için anahtarı kullan.
losetup -e AES128 -p 0 /dev/loop0 $ASSET &lt; "/mnt/keys/$KEY"

# Anahtarları kapat.
umount -n /mnt/keys
losetup -d /dev/loop1

# Kök dizin "bölüm" aygıtını kur.
losetup -o $ROOT_OFFSET /dev/loop1 /dev/loop0

# Kök dizin dosya sistemini bağlayın (fsck ile denetlenebilmesi için salt-okunur olmalıdır).
mount -n -r -t $ROOT_TYPE /dev/loop1 $MOUNT</programlisting>
    </figure>
    <para>Betiği çalıştırılabilir yapın.</para>
    <screen>
     <prompt>bash# </prompt>
     <command>chmod +x decrypt.sh</command>
    </screen>
   </para>
   <para>
Eğer sadece bir dosya şifreliyorsanız, <xref linkend="disk_sifreleme_Testing_and_Backup"/> bölümüne geçin. Aksi takdirde, aşağıdaki betiği <filename>linuxrc</filename> ismi ile kaydedin ve onu <filename>/tmp/initrd</filename> dizinine yerleştirin.
      </para>
   <para>
    <figure xml:id="disk_sifreleme_linuxrc" xreflabel="linuxrc">
     <info>
      <title>
       <filename>/tmp/initrd/linuxrc</filename>
      </title>
     </info>
     <programlisting>#!/bin/sh

# Şifreli veriyi çöz
source decrypt.sh "$1"

#Şifreli verinin kök dizin dosya sistemini değiştir.
cd $MOUNT
/sbin/pivot_root . initrd

# Kontrolü init'e ver.
shift 1
exec chroot . /sbin/init $* &lt;dev/console &gt;dev/console 2&gt;&amp;1
</programlisting>
    </figure>
   </para>
   <para>Betiği çalıştırılabilir yapın.</para>
   <screen>
    <prompt>bash# </prompt>
    <command>chmod +x linuxrc</command>
   </screen>
   <para>
Tamam, anahtar zinciri ve şifrelenen veri şimdi hazır. Herşeyi çözün.
      </para>
   <para>
    <screen>
     <prompt>bash# </prompt>
     <command>umount /tmp/{initrd,keychain}</command>
    </screen>
   </para>
   <para>
Şimdi boş şifreli bir dosya sisteminiz var. Yaşasın!
      </para>
  </section>
  <section xml:id="disk_sifreleme_Testing_and_Backup">
   <info>
    <title>Sınama ve Yedekleme</title>
   </info>
   <para>
Sisteminizi anahtar zincirinden önyükleme yaparak ya da <xref linkend="disk_sifreleme_decrypt.sh"/> betiğini uygun şekilde yürüterek sınayın (betiğe değiştirge olarak kullanmak istediğiniz anahtarın ismini verin). Önyüklemeden sonra <filename>/sbin/init</filename>'in varolmadığı gibi bir uyarı olabilir ama şimdilik bu sorun değil.
      </para>
   <para>
Kök dizininizin başarılı bir şekilde bağlanmış olduğunu kontrol edin. Herşeyin çalıştığından emin olduğunuzda, anahtar deponuzu yedekleyin. Aslında, birçok yedek alın. Şunu sorabilirsiniz, "Fakat anahtar depomun biryerlerde kopyasının olması güvenlik için tehlikeli değil mi?" Cevabı evettir, fakat anahtar deponuzu kaybetmek kadar tehlikeli değildir, eğer güvenliği "bilgime erişimi koruma" anlamında da kullanıyorsnız.
      </para>
   <para>
Anahtar depom ufak olduğu için bütün eşlemin yedeğini almaya karar verdim, böylece geri yüklemek kolaydır:
      </para>
   <para>
    <screen>
     <prompt>bash# </prompt>
     <command>bzip2 -c /dev/sda &gt; keychain.img.bz2</command>
    </screen>
   </para>
   <para>
Sadece bir dosyayı kopyalıyorsanız, arkanıza yaslanabilirsiniz çünkü işiniz bitti.
      </para>
  </section>
  <section xml:id="disk_sifreleme_Rescue_Disk">
   <info>
    <title>Kurtarma Diski</title>
   </info>
   <para>
Kurtarma diskleri, bir sistemin düzgün çalışmadığı ve/veya önyükleme yapmadığı durumlarda işe yarar. Kurtarma diskinizin çekirdeğinde <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://sourceforge.net/projects/loop-aes/">loop-AES</link> desteği olduğundan ve <application><link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.kernel.org/pub/linux/utils/util-linux/">util-linux</link></application> <command>losetup</command> ve <command>mount</command> gibi düzgün yamanmış araçlar olduğundan emin olun, aksi takdirde şifrelediğiniz veri işe yaramayacaktır. Gelecekte, bütün kurtarma diskleri bu desteği içerecekler, çünkü  2.6 çekirdeği ile birlikte standart olacak. Bu arada, <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.knoppix.com/">KNOPPIX</link> (örneğin) şimdiden gerekli desteği sağlar ve kurtarma diski olarak kullanılabilir.
      </para>
   <para>
Uygun bir kurtarma diski ile önyükleme yaptıktan sonra, anahtar deponuzu bağlayın ve <xref linkend="disk_sifreleme_decrypt.sh"/> betiğini yürütün.
      </para>
   <para>
    <screen>
     <prompt>bash# </prompt>
     <command>mkdir /tmp/{keychain,initrd}</command>
     <prompt>bash# </prompt>
     <command>mount /dev/sda1 /tmp/keychain</command>
     <prompt>bash# </prompt>
     <command>mount -o loop=/dev/loop3 /tmp/keychain/boot/initrd /tmp/initrd</command>
     <prompt>bash# </prompt>
     <command>pushd /tmp/initrd</command>
     <prompt>bash# </prompt>
     <command>./decrypt.sh laptop</command>
     <prompt>bash# </prompt>
     <command>popd</command>
     <prompt>bash# </prompt>
     <command>umount /tmp/{initrd,keychain}</command>
    </screen>
   </para>
   <para>
Şifreli verinize şimdi <xref linkend="disk_sifreleme_decrypt.sh"/>'de tanımlanan bağlama noktasından erişebilirsiniz.
      </para>
  </section>
  <section>
   <info>
    <title>Linux Kurma</title>
   </info>
   <para>
Son göreviniz yeni şifreli dosya sisteminize Linux kurmaktır. Bunu yaparken <filename>/etc/fstab</filename> dosyasında kök dizin ve takas alanı için girişlerin aşağıdaki gibi olduğundan emin olun:
      </para>
   <para>
    <informalexample>
     <programlisting># /etc/fstab: static file system information.
#
# &lt;file system&gt; &lt;mount point&gt;   &lt;type&gt;  &lt;options&gt;               &lt;dump&gt;  &lt;pass&gt;
/dev/loop0      none            swap    sw                      0       0
/dev/loop1      /               ext3    errors=remount-ro       0       1
</programlisting>
    </informalexample>
   </para>
   <para>
Daha önceden başka biryerde bir kurulumunuz varsa, <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.tldp.org/HOWTO/Hard-Disk-Upgrade/">Disk Yükseltme mini-NASIL</link> belgesini nasıl kopyalama yapıldığını öğrenmek için okuyabilirsiniz.
      </para>
   <para>
Yeni bir Linux kurmanın yordamı dağıtımdan dağıtıma değişir. Lütfen aşağıda listelenmeyen dağıtımlar için yönergeleri bana gönderiniz ve onları buraya ekleyeceğim.
      </para>
   <section xml:id="disk_sifreleme_debian">
    <info>
     <title>
      <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.debian.org">Debian</link>
     </title>
    </info>
    <para>
     <orderedlist inheritnum="ignore" continuation="restarts">
      <listitem>
       <para><xref linkend="disk_sifreleme_Rescue_Disk"/>'de ki yönergeleri takip ederek bir kurtarma diskinden önyükleme yapın.
        </para>
      </listitem>
      <listitem>
       <para><link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.debian.org/releases/stable/i386/ch-preparing.en.html#s-linux-upgrade">3.7  Unix/Linux Sisteminden Debian GNU/Linux Kurma</link> yöntemini kullanarak kurun.
        </para>
      </listitem>
     </orderedlist>
    </para>
   </section>
   <section xml:id="disk_sifreleme_Gentoo">
    <info>
     <title>
      <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.gentoo.org/">Gentoo</link>
     </title>
    </info>
    <para>
     <orderedlist inheritnum="ignore" continuation="restarts">
      <listitem>
       <para><xref linkend="disk_sifreleme_Rescue_Disk"/>'de ki yönergeleri takip ederek bir kurtarma diskinden (Gentoo's Live CD 1.4 çalışmayacaktır) önyükleme yapın.
        </para>
      </listitem>
      <listitem>
       <para>
Eğer oluşturduğunuz bir takas alanı var ise onu etkinleştirin.
        </para>
       <para>
        <screen>
         <prompt>bash# </prompt>
         <command>swapon /dev/loop0</command>
        </screen>
       </para>
      </listitem>
      <listitem>
       <para><filename>/mnt/gentoo</filename>'yu kök dizin dosya sistemine yönlendirin.
        </para>
       <para>
        <screen>
         <prompt>bash# </prompt>
         <command>ln -s new-root /mnt/gentoo</command>
        </screen>
       </para>
      </listitem>
      <listitem>
       <para><link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.gentoo.org/doc/en/gentoo-x86-install.xml">Gentoo Linux 1.4 Kurulum Yönergeleri</link>'de ki<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.gentoo.org/doc/en/gentoo-x86-install.xml#doc_chap8">8. Bölüm - Aşama Tar Paketleri ve chroot</link> bölümüne atlayın.
        </para>
      </listitem>
     </orderedlist>
    </para>
   </section>
   <section xml:id="disk_sifreleme_Idle_Logout">
    <info>
     <title>İşlevsizlik Halinde Oturumu Kapama</title>
    </info>
    <para>
Sisteminizin belirli bir süre etkin olmaması durumunda otomatik olarak oturum kapanacak şekilde ayarlayın.  Bu dizüstü bilgisayarınız açıkken çalınması durumunda şifreli verinizin ortaya çıkma riskini azaltacaktır (fakat tam olarak önlemez!) (<xref linkend="disk_sifreleme_Attack_Tree"/>'e bakın).
      </para>
   </section>
  </section>
 </section>
 <section xml:id="disk_sifreleme_more-data">
  <info>
   <title>Daha Fazla Bilgi</title>
  </info>
  <para>
   <itemizedlist>
    <listitem>
     <para><application><link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://sourceforge.net/projects/loop-aes/">loop-AES</link></application> ile birlikte gelen <filename><link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://loop-aes.sourceforge.net/loop-AES.README">OKUBENİ</link></filename> çoklu senaryolar için nasıl kullanılacağını açıklamaktadır.
    </para>
    </listitem>
    <listitem>
     <para><link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://linuxfromscratch.org/hints/downloads/files/OLD/cryptoapi.txt">Şifreli Dosya Sistemi NASIL</link>, dış anahtar deposu kullanmadan kök dizin dosya sistemini şifrelemenizi tanımlamaktadır.
    </para>
    </listitem>
    <listitem>
     <para><link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.gentoo.org/proj/en/hardened/">Dayanıklılaştırılmış Gentoo Projesi</link>'nde <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.sdc.org/~leila/usb-dongle/readme.html">Disk Şifrelemeye Yapılandırılmış Yaklaşım</link> daha geniş kapsamlıdır ve <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.gentoo.org/">Gentoo</link> kullanıcılarını hedefler.
    </para>
    </listitem>
   </itemizedlist>
  </para>
 </section>
 <glossary xml:id="disk_sifreleme_glossary">
  <info>
   <title>Terimler Sözlüğü</title>
  </info>
  <glossentry>
   <glossterm>
    <acronym>
     <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://csrc.nist.gov/CryptoToolkit/aes/">AES</link>
    </acronym>
   </glossterm>
   <glossdef>
    <para>
Advanced Encryption Standard (Gelişmiş Şifreleme Standartı), Birleşik Devletler <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.nist.gov/">Ulusal Standartlar ve Teknoloji Enstitüsü</link> tarafından seçilen sağlam ve saygın bir <glossterm>şifreleme</glossterm> algoritmasıdır.
    </para>
   </glossdef>
  </glossentry>
  <glossentry>
   <glossterm>
şifrelenen/şifrelenecek veri
    </glossterm>
   <glossdef>
    <para><glossterm>şifreleme</glossterm> ile korunan veri - disk, disk bölümü ya da dosya
    </para>
   </glossdef>
  </glossentry>
  <glossentry>
   <glossterm>şifreleme</glossterm>
   <glossdef>
    <para>
bir veriyi karıştırmanın matematiksel yolu, böylece veri ancak belirli bir <glossterm>anahtar</glossterm> kullanıldığında anlaşılabilir hale gelir.
      </para>
   </glossdef>
  </glossentry>
  <glossentry>
   <glossterm>anahtar</glossterm>
   <glossdef>
    <para>
şifreli veriyi anlaşılabilir kılmaya yarayan ufak bilgi parçası
      </para>
   </glossdef>
  </glossentry>
  <glossentry xml:id="disk_sifreleme_keychain">
   <glossterm>anahtar deposu</glossterm>
   <glossdef>
    <para>
şifreleme <glossterm>anahartarını</glossterm> tutan fiziksel ortam (<glossterm>USB flash sürücü</glossterm> gibi) (ve muhtemelen önyükleme işleminin başlangıcı)
      </para>
   </glossdef>
  </glossentry>
  <glossentry>
   <glossterm>geri-dönüm aygıtı</glossterm>
   <glossdef>
    <para>
Veri depolamak için kullanılan Linux öbek aygıtı (başka aygıt kullanmak suretiyle)
      </para>
   </glossdef>
  </glossentry>
  <glossentry>
   <glossterm>
    <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://sourceforge.net/projects/loop-aes/">loop-AES</link>
   </glossterm>
   <glossdef>
    <para><glossterm>geri-dönüm aygıtı</glossterm> kullanan <glossterm>AES</glossterm> algoritmasını gerçekleştiren ve Jari Ruusu tarafından yazılan yazılım
      </para>
   </glossdef>
  </glossentry>
  <glossentry>
   <glossterm>makul reddedebilme</glossterm>
   <glossdef>
    <para>
kişinin verisini bir saldırgan için zorla çözmeyi reddebilmenin bir yolu
      </para>
   </glossdef>
  </glossentry>
  <glossentry>
   <glossterm>USB flash sürücüsü</glossterm>
   <glossdef>
    <para>
ufak bir bellek çipi ve USB arabirimi içeren ufak elektronik aygıt
      </para>
   </glossdef>
  </glossentry>
 </glossary>
</article>
