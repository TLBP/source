<?xml version="1.0" encoding="UTF-8"?>
<!--DOCTYPE article SYSTEM "../../docbook/dtd/belgeler.dtd" [
  <!ENTITY % belgeler.dtd SYSTEM "../../belgeler.dtd">
  %belgeler.dtd;
]-->
<!-- ********************************************************************
       howtos/yerli/kernel-NASIL.xml
     ******************************************************************** -->
<article xml:id="kernel-nasil" xmlns="http://docbook.org/ns/docbook"
 version="5.0" xmlns:xlink="http://www.w3.org/1999/xlink"  xml:lang="tr">
 <info>
  <!-- Use "HOWTO", "mini HOWTO", "FAQ" in title, if appropriate -->
  <title>Çekirdeğe Yama Uygulanması ve Çekirdeğin Derlenmesi NASIL</title>
  <author>
   <personname>
    <firstname>Murat</firstname>
    <surname>Koç</surname>
   </personname>
   <affiliation>
    <address>
     <email>murat.koc@frontsite.com.tr</email>
    </address>
   </affiliation>
  </author>
  <pubdate>4 Şubat 2000</pubdate>
  <pubdate> </pubdate>
  <!-- Most recent revision goes at the top; list in descending order -->
  <revhistory>
   <revision>
    <revnumber>0.1</revnumber>
    <date>4 Şubat 2000</date>
    <authorinitials>MK</authorinitials>
   </revision>
  </revhistory>
  <abstract>
   <para>
    Bu belgede, Linux çekirdeğine yama uygulanması ve çekirdeğin derlenmesi
    anlatılmıştır.
   </para>
  </abstract>
 </info>
 <!-- Content follows...include introduction, license information, feedback -->
 <para role="only.html">
  Ek - <link xlink:href="&gfdl;">GNU Free Documentation License</link>
 </para>
 <sect1 xml:id="kernel-nasil_yamanir">
  <title>Çekirdeğe Yama Uygulanması</title>
  <sect2>
   <title>Yama Nedir?</title>
   <para>
    <literal>patch</literal> (yama) uygulaması, iki dosya arasındaki
    farklılıkları bulmak için kullanılan GNU'nun <literal>diff</literal>
    uygulaması elde edilen yama dosyasını kullanarak eski dosyanın yeni
    sürümünü elde etmekte kullanılır. <literal>diff</literal> oldukça fazla
    seçeneğe sahiptir fakat genellikle iki dosya arasında değişen satırları
    listelemek ve değişen satırları orjinal halleri ile göstermek için
    listeleyen bir dosyanın oluşturulması için kullanılır. Yama asıl olarak
    kaynak kodu dosyalarını içeren bir dizini, bütün kaynak kodunu
    Internet'ten indirmeden güncellemek için kullanılır. Bir yamayı indirmek
    esas olarak sadece değişen satırları indirmektir.
   </para>
  </sect2>
  <sect2>
   <title>Yamanın Kullanılması</title>
   <para>
    <literal>patch</literal> uygulaması, bütün seçeneklerini içeren oldukça
    iyi hazırlanmış bir kılavuz sayfası ile beraber gelmektedir. Fakat
    bunların sadece ikisi bütün işinizi görmek için yeterli olmaktadır.
   </para>
<synopsis><command>patch</command> <literal>-p1 &lt; [<replaceable>yama_dosyası</replaceable>]</literal>

<command>patch</command> <literal>-R &lt; [<replaceable>yama_dosyası</replaceable>]</literal></synopsis>
   <para>
    <literal>-p1</literal> seçeneği yama dosyası içindeki dosya adlarından en
    soldakini çıkarmak için kullanılır. Bu seçeneği kullanmak için yamayı,
    yamanacak dizine yerleştirin ve daha sonra bu dizin içinde
   </para>
<screen>patch -p1 &lt; [yama_dosyası]</screen>
   <para>komutunu verin.</para>
   <para>
    Bu seçeneği daha iyi anlamak için aşağıdaki <literal>PIII.patch</literal>
    örneğini ele alalım:
   </para>
<screen># <command>diff -u -r -N koc-yama/linux/Documentation/Configure.help \</command>
&gt; <command>linux/Documentation/Configure.help</command>
--- koc-yama/linux/Documentation/Configure.help Sat Jan 29 04:37:46 2000
+++ linux/Documentation/Configure.help Sat Jan 29 04:20:53 2000
@@ -1637,10 +1637,10 @@
    all x86 CPU types (albeit not optionally fast), you can specify "386" here.
-   if you specify one of "486" or "586" or "Pentium" or "PPro", then
-   the kernel will not necessarily run on earlier architectures (e.g. a
-   Pentium optimized kernel will run on a Ppro, but not necessarily on
-   a i486).
+   if you specify one of "486" or "586" or "Pentium" or "PPro" or "PIII",
+   then the kernel will not necessarily run on earlier architectures
+   (e.g. A Pentium optimized kernel will run on a Ppro, but not necessarily
+   on a i486).
</screen>
   <para>
    Bu şekilde hazırlanmış olan bir yamayı <literal>-p1</literal> seçeneği
    ile uyguladığımız zaman patch uygulaması bulunduğumuz dizinde
    <literal>Documentation</literal> adlı altdizini arar daha sonra ise
    <literal>Configure.help</literal> adlı dosyaya bakar. Bu örnekte eksi
    işaretli olan satır ile artı işaretli olan satır yer değiştirir.
    <literal>Patch</literal> çalışırken çıktıyı ekrana gönderir fakat bu
    çıktı genellikle çok hızlı ilerler. Özgün dosyalar, yeni yamanmış
    dosyalar onların yerini alırken <literal>*.orig</literal> diye tekrar
    isimlendirilir.
  </para>
  </sect2>
  <sect2>
   <title>Çekirdeğe Yama Uygulaması için Bazı Öneriler</title>
   <para>
    Birçok Linux kullanıcısı <literal>patch</literal>'i çekirdek kodunu
    yamamak için kullanır. Bunun için en kolay yol bir kabuk betiği olan
    <literal>patch-kernel</literal>'i kullanmaktır. Bu betik çekirdeğin kaynak
    kod dizini içinde <literal>scripts</literal> adlı altdizinde bulunur. Bu
    betik Nick Holloway tarafindan 1995 yılında yazılmıştır. Birkaç yıl sonra
    Adam Sulmicki bu betiğe bazı sıkıştırma algoritmaları desteğini
    eklemiştir. Bunlar <literal>*.bz, *.bz2, compress, gzip</literal> ve
    normal metindir. Bu betik sizin <literal>/usr/src/linux</literal> dizini
    içinde bulunduğunuzu ve yamanızında bu dizinde olduğunu varsayar. Bu iki
    değeri komut satırında
   </para>
<synopsis><command>patch-kernel</command> <literal>[ <replaceable>kaynakdizini</replaceable> [<replaceable>yamadizini</replaceable>] ]</literal></synopsis>
   <para>
    yazarak değiştirebilirsiniz. <literal>patch-kernel</literal>, herhangi
    bir yama başarısız olursa durur. Fakat eğer yama başarılı olursa
    <literal>find</literal> komutunu çalıştırır ve bütün
    <literal>*.orig</literal> dosyalarını siler. Eğer komutların çıktılarını
    görmek veya <literal>*.orig</literal> dosyalarını saklamak istiyorsaniz
    <literal>patch</literal> komutunu doğrudan uygulayabilirsiniz. Bu yöntem
    ben de dahil olmak üzere birçok kişi tarafından daha güvenilir bulunuyor.
    Sıkıştırılmış yamayı açmadan uygulamak için aşağıdaki borulama (pipe)
    kullanılabilir:
   </para>
<screen># gzip -cd patchXX.gz | patch -p1</screen>
   <para>veya</para>
<screen># bzip2 -dc patchXX.bz2 | patch -p1</screen>
   <para>
    Yama uygulandıktan sonra işlemin uygulanamadığı dosyaları bulmak için
    <literal>find</literal> komutu aşağıdaki şekilde kullanılır.
   </para>
<screen># find . -name *.rej</screen>
   <para>
    Eğer find, <literal>*.rej</literal> dosyasını bulursa ismini ekrana basar.
    Eğer find birşey bulamazsa yama doğru olarak uygulanmış demektir. Bir
    başka işlem <literal>*.orig</literal> dosyalarını bulmak ve silmektir.
    Bunun için find'i aşağıdaki şekilde kullanabiliriz:
   </para>
<screen># find . -name *.orig -print0 | xargs -0r rm -f</screen>
   <para>
    Eğer bu komutu her seferinde elle yazmak istemezseniz
    <literal>.bash_profile, .bash_login</literal> veya
    <literal>.profile</literal> dosyasına aşağıdaki şekilde bir
    <literal>alias</literal> ekleyebilirsiniz:
   </para>
<screen>alias origbul="find .-name *.orig -print0 | xargs -0r rm -f"</screen>
   <para>
    Bu size <literal>origbul</literal> yazarak yukarıdaki komutu
    çalıştırmanızı sağlar. Sistemden çıkmadan bu komutu çalıştırmanız için:
   </para>
<screen># source .profile</screen>
   <para>
    yazmanız yeterlidir. Şimdi bu anlattıklarımıza örnek olması amacı ile
    <literal>linux_dvd_2_2_12_diff.patch</literal> adlı yamayı uygulayalım ve
    sonra bu yamayı kaldıralım:
   </para>
<screen># cd /usr/src/linux
# patch -p1 &lt; linux_dvd_2.2.12_diff.patch
patching file drivers/block/ide-cd.c
Hunk #1 succeeded at 2097 (offset 10 lines).
Hunk #2 succeeded at 2631 (offset 2 lines).
patching file drivers/block/ide-cd.h
Hunk #2 succeeded at 666 (offset 4 lines).
Hunk #4 succeeded at 793 (offset 4 lines).
patching file include/linux/cdrom.h
# find . -name *.rej   =&gt; <emphasis>(ekrana birşey basılmazsa işlem başarı ile tamamlanmış)</emphasis>
# find . -name *.orig
./drivers/block/ide-cd.c.orig
./drivers/block/ide-cd.h.orig  =&gt; <emphasis>(yamanmış dosyaların orijinalleri)</emphasis>
# find . -name *.orig -print0 | xargs -0r rm -f  =&gt; <emphasis>(bu dosyaları silmek için)</emphasis>
</screen>
   <para>
    veya eğer yukarıdaki <literal>alias</literal>'ı tanımlamışsak:
   </para>
<screen>#origbul</screen>
   <para>
    Buraya kadar olan komutlar ile çekirdeği yamama işlemimiz bitiyor. Şimdi
    bu yamayı kaldıralım:
   </para>
<screen># patch -p1 -R &lt; linux_dvd_2_2_12_diff.patch
patching file drivers/block/ide-cd.c
Hunk #1 succeeded at 2097 (offset 10 lines).
Hunk #2 succeeded at 2308 (offset 2 lines).
patching file drivers/block/ide-cd.h.
Hunk #2 succeeded at 663 (offset 4 lines).
Hunk #4 succeeded at 784 (offset 4 lines).
patching file include/linux/cdrom.h.
# find . -name *.rej
# origbul
</screen>
   <para>
    Böylece uygulamış olduğumuz yamayı kaldırmış olduk.
   </para>
  </sect2>
 </sect1>
 <sect1 xml:id="kernel-nasil_derlenir">
  <title>Çekirdeğin Derlenmesi</title>
  <sect2>
   <title>Çekirdek Sürüm Numaraları</title>
   <para>
    Bütün Linux çekirdek sürüm numaraları <command>.</command> ile ayrılmış
    olan üç bölümden  oluşur. Şu an biz üçüncü çekirdek sürümü olan 2'deyiz.
    Bazılari sürüm 1'i kullanmaktadır ve hala bir tane bile olsa sürüm 0
    kullanan vardır.
   </para>
   <para>
    İkinci numara etkin sürüm numarasıdır. Bu numaralardan 0 da dahil
    olmak uzere çift sayıda olanları kararlı olarak nitelendirilir. Bu şu anlama geliyor: Bu çekirdekler herhangi bir önemli hata içermiyorlar ve çok fazla denenmiştir. Tek sayıda olan çekirdekler geliştirme aşamasında olan çekirdeklerdir. Bu çekirdekler o kadar fazla denenmemiştir ve daha çok bir sonraki kararlı sürümde yeralacak olan son yeniliklere ihtiyacı olan kullanıcılar tarafından kullanılır.
  </para>
   <para>
    Son numara edilgin sürüm olarak isimlendirilir ve her sürümde bir artar.
    Örneğin eğer çekirdek numarası olarak 2.2.14 görürseniz bu şu anlama gelir. 2.2 sürümü çekirdek, bu kararlı bir çekirdektir ve 15 inci sürümündedir. (0'ı da katarak sayıyoruz).
   </para>
  </sect2>
  <sect2>
   <title>Çekirdek Kaynak Paketinin Temini</title>
   <para>
    Çekirdek Kaynak Paketi oldukça fazla sayıda ftp sitesinden ve bütün Linux
    dağıtımlarının CD'lerinden elde edilebilir.
   </para>
   <para>
    Çekirdek siteleri:
   </para>
   <simplelist>
    <member><link xlink:href="ftp://ftp.kernel.org/"/></member>
    <member><link xlink:href="ftp://ftp.funet.fi/"/></member>
    <member><link xlink:href="ftp://ftp.linux.org/"/></member>
   </simplelist>
  </sect2>
  <sect2>
   <title>Hazırlık</title>
   <para>
    Kaynak kodunu aldıktan sonra onu <literal>/usr/src</literal> dizinine
    yerleştirin ve <literal>tar</literal> ile açmadan önce koyacağınız bir
    dizin oluşturun. Şu şekilde dizin isimlendirmesi yaparsanız daha iyidir:
    Örneğin <literal>2.2.14</literal> numaralı çekirdek için
    <literal>linux-2.2.14</literal> isimli bir dizin
    oluşturun. Daha sonra bu dizini şu şekilde <literal>linux</literal>
    dizinine sembolik bağ oluşturun:
   </para>
   <para>
    <screen># ln -fs linux-2.2.14 linux</screen>
   </para>
   <para>
    Burada <literal>-f</literal> seçeneğini kullanmamızın sebebi önceden
    <literal>/usr/src</literal> altında başka bir çekirdek kaynak kodunuz
    olabilir ve ona bağ yapmış olabilirsiniz. Bazı <literal>ln</literal>
    sürümlerinde <literal>-f</literal> seçeneği çalışmamaktadır (örnegin
    3.13'de olduğu gibi). Bu durumda önceki bağı silmeniz ve yeni dizine
    bağ oluşturmanız gerekebilir. <literal>ln-3.16</literal> sürümünde bu
    özellik doğru bir şekilde çalışmaktadır. Sorun yaşabileceğiniz tek durum
    eğer <literal>linux</literal> bir bağ dosyası değilde bir altdizin adı
    ise olabilir. Bu durumda ise bu dizini tekrar adlandırmanız sorunu
    çözecektir. Bunu şu şekilde yapabilirsiniz:
   </para>
<screen># mv linux linux-2.2.13</screen>
   <para>Şimdi şu komutu verelim:</para>
<screen># tar zxfv linux-sürümno.tar.gz</screen>
   <para>bz2 ile sıkıştırılmıs ise</para>
<screen># tar xfvI linux-sürümno.tar.bz2</screen>
   <para>komutunu vermeniz gerekli olacaktır.</para>
   <para>
    Çekirdeğin kaynak paketini açtıktan sonra uygulamak istediğiniz bir yama
    varsa (Örneğin <literal>PIII.patch</literal>) bunu bu aşamada daha önce
    anlatıldığı biçimde yapın. Yani:
   </para>
<screen># patch -p1 &lt; PIII.patch
# find . -name *.rej
# origbul</screen>
   <para>
    Son olarak çekirdeğin kaynak kodunun olduğu dizine girmeden ve derlemeye
    başlamadan önce yapmanız gereken tek şey bazı bağların varlığını kontrol
    etmeniz olacaktır bunlar,
   </para>
<screen>/usr/include/asm =&gt; /usr/src/linux/include/asm
/usr/include/linux =&gt; /usr/src/linux/include/linux
/usr/include/scsi =&gt; /usr/src/linux/include/scsi
</screen>
   <para>
    bağlarıdır. Bu bağlar olmadığında derleme işlemine devam edemezsiniz.
    Eğer bu bağlar yoksa bunları aşağıdaki biçimde oluşturabilirsiniz:
   </para>
<screen># ln -s /usr/src/linux/include/asm /usr/include/asm
# ln -s /usr/src/linux/include/linux /usr/include/linux
# ln -s /usr/src/linux/include/scsi /usr/include/scsi
</screen>
   <para>
    Bütün bu işlemlerin hepsini yaptıktan sonra
    <literal>/usr/src/linux</literal> dizinine geçin. Eğer bazı özel
    donanımlara ihtiyacınız varsa veya başka şeyler hakkında daha fazla bilgi
    almak istiyorsaniz <literal>Documentation</literal> dizinine geçin. Örneğin
    bazı CD-ROM sürücüleri bazı özel değerler ile derlenmelidir. Genelde
    çalışmalarına rağmen bunlar yüklendikleri sırada bazı uyarı mesajları
    verirler. Eğer bu tür mesajlar sizi ilgilendirmiyorsa bu dizine geçmenize
    gerek yoktur. Ama eğer sizi ilgilendiriyorsa bununla ilgili olan
    <literal>.txt, .h</literal> (başlık dosyaları) ve <literal>.c</literal>(C
    kodu) dosyalarını okuyun. Bunlar oldukça iyi açıklanmış olan dosyalardır.
    Fakat kendinizi bu kadar cesur hissetmiyorsanız bunu yapmak zorunda
    değilsiniz. Yine de elinizdeki orijinal <literal>.tar.gz</literal>'li veya
    <literal>.rpm</literal>'li paketlerle herşeyi düzeltecebileceğiniz
    aklınızda bulunsun.
   </para>
  </sect2>
  <sect2>
   <title>Derlemeye Başlama</title>
   <para>
    Şimdi yapılandırma işlemi için hazırız. Başlamadan önce biraz modüller
    hakkında bilgi verelim. Modülleri özel bir amaç için çekirdeğe sokup
    çıkartabildiğiniz programlar olarak düşünebilirsiniz. Eğer evde ufak bir
    ağınız varsa ve bu ağı her zaman değilde bazen kullanmayı düşünüyorsanız
    ethernet kartınızı bir modül olarak derleyebilirsiniz. Modülü
    kullanabilmek için makina çalışabilir ve <literal>/lib/modules</literal>
    dizinine erişilebilir olmalıdır. Bunun anlamı disk (IDE,SCSI,vs..., NFS
    olması durumunda ethernet kartı), dosya sistemi (normal olarak EXT2, NFS
    olabilir) ve çekirdek tipi (ELF) derlenmek zorundadır ve modül
    <command>OLMAMALADIR</command>. Modüller çekirdek
    yükleninceye, disk (veya ağ) erişilebilir oluncaya ve dosya sistemi
    bağlanıncaya kadar kullanılamazlar. Bu dosyalar çekirdeğin içinde
    derlenmelidir, aksi takdirde kök dizin bağlanamaz. Eğer kök dizinini ağ
    üzerinden bağlıyorsanız NFS ve ethernet kartınızı çekirdeğin içinde
    derlemiş olmanız gerekmektedir.
   </para>
   <para>
    Modüller niçin kullanılır? Modüller çekirdeği daha küçük yaparlar. Bu
    çekirdek tarafından ayrılan alanın boyutunu azaltır. Modüller yüklenir
    ve silinirler. Böylece kullandıkları bellek tekrar kullanılabilir. Eğer
    bir modülü makinanın açık kaldığı sürenin %90'ı boyunca kullanıyorsanız
    çekirdeğin içinde derleyin. Bir de şunu unutmayın çekirdek korunumlu bir
    alanda çalışır fakat modüller bu korunumlu alanın dışında çalışırlar.
   </para>
   <para>
    Sonraki adım çekirdeği yapılandırmak. Burada aynı işi yapan üç tane ayrı
    seçeneğimiz var. Benim size önereceğim ise grafik tabanlı olanlardan
    birini kullanmanız. Eski yöntem için <literal>make config </literal>
    demeniz yeterlidir. Böylece uzun bir sorular listesi ile karşı karşıya
    kalırsınız. Eğer bir hata yaparsanız <literal>ctrl-c</literal>'ye basıp
    baştan başlamak zorunda kalırsınız. Bunun yanında sorularda tekrar geri
    dönme şansınız yoktur. Tavsiye edilen seçenekler ise
    <literal>make menuconfig</literal> ve <literal>make xconfig</literal>'dir.
   </para>
   <para>
    Bunlar grafiksel olarak daha rahat bir çalışma ortamı sağlarlar.
    <literal>Menuconfig</literal>'i kullanabilmek için sisteminizde
    <literal>ncurses</literal> kitaplığı kurulu olmalıdır.
    <literal>Xconfig</literal>'i kullanabilmek için ise X'in sistemde kurulu
    ve yapılandırılmış olması gerekmektedir. Bunun yanında ayrıca
    <literal>Tk</literal>'nın da kurulu olması gerekmektedir. Birçok kişiye
    göre <literal>make xconfig</literal> çekirdeği yapılandırmak için en rahat
    ve en kolay yöntemdir. <literal>Menuconfig</literal>'de bir seçeneği
    kaldırdığınız zaman ona bağlı olan seçeneklerde ekrandan kalkar fakat
    <literal>xconfig</literal>'de bunu yaptığınız zaman ona bağlı seçenekler
    gri bir renk alırlar. Bu çekirdeğe en son nelerin eklendiğini görmek
    isteyen kişiler için oldukça hoş bir özellik olarak göze çarpar.
  </para>
  </sect2>
  <sect2>
   <title>Çekirdeğin Yapılandırılması</title>
   <para>
    Bu bölümde size çekirdek derlerken kullanılan bazı seçenekleri anlatacağım
    fakat bütün hepsini açıklamayacağım. Sizin için gerekenleri veya öğrenmek
    istediklerinizi seçeneklerin yanında <literal>help</literal> bölümünden
    öğrenebilirsiniz. Benim amacım en çok kullanılan ve problem ile
    karşılaşılanlara biraz açıklama getirmek. Buradaki açıklamalar 2.2.*
    serisi çekirdekler için yapılmıştır. 2.0.* serisi için gereken yerlerde
    açıklamalar yapılmıştır.
   </para>
   <sect3>
    <title>Kod Olgunluk Seviyesi Seçenekleri</title>
    <subtitle>Code Maturity Level Options</subtitle>
    <para>
     Burası ilk bölümdür. Buradaki tek soru geliştirme aşamasındaki sürücü ve
     kodları kullanmak isteyip istemediğinizdir. Eğer buna ihtiyaç duyan bir
     donanımınız varsa mecburen buna evet demeniz gerekiyor.
    </para>
   </sect3>
   <sect3>
    <title>İşlemci Türü ve Özellikleri</title>
    <subtitle>Processor Type and Features</subtitle>
    <para>
     İlk seçenek işlemci türünüz ile ilgilidir. Burada sizin işlemcinize uygun
     olan seçeneği seçin. Matematik işlemcisi seçenegini eğer makinanız 486SX
     veya 386 ise seçmeniz gerekiyor. MTRR ise Intel'in P6 ailesi
     işlemcilerinde kullanılır ve rahatlıkla bu seçenege evet diyebilirsiniz.
     SMP'yi (Symmetric Multi Processing) ise birden fazla işlemciniz varsa
     seçmeniz gerekiyor. Eğer 2.0.* bir çekirdeğiniz varsa
     <literal>/usr/src/linux/</literal> altında <literal>Makefile</literal>
     dosyasında <literal>SMP=0</literal> olan satırı <literal>SMP=1</literal>
     yapmanız gerekmektedir.
   </para>
  </sect3>
   <sect3>
    <title>Yüklenebilir Modül Desteği</title>
    <subtitle>Loadable Module Support</subtitle>
    <para>
     Eğer modülleri kullanmak istiyorsanız ilk seçeneğe cevabınız evet
     olmalıdır. Sistemde <literal>kerneld</literal> çalıştırıyorsanız üçüncü
     seçeneği seçmenize gerek yok. Bu seçenek <literal>kerneld</literal>'nin
     yaptığı işin biraz daha basitini yapıyor yani çekirdeğin ihtiyacı olduğu
     zamanlarda gerekli modüllerin yüklenmesini sağlıyor. Fakat sadece
     yüklüyor.
    </para>
   </sect3>
   <sect3>
    <title>Genel Ayarlar</title>
    <subtitle>General Setup</subtitle>
    <para>
     Burada yapılması gereken en önemli şey çekirdeğe <literal>ELF</literal>
     (Executable and Linkable Format - Çalıştırılabilir ve İlintilenebilir
     Biçem) desteğini vermektir. Çünkü Linux uzun zamandır bu biçemi
     kullanmaktadır. Eskiden kullanılan <literal>a.out</literal>
     (Assembler.OUTput) yerini <literal>ELF</literal>'e bırakmıştır. Fakat
     benim tavsiyem <literal>a.out</literal>, <literal>ELF</literal> ve
     <literal>misc</literal>'in üçüne de destek vermeniz yönünde olacaktır.
     Bunun nedeni ise sistemde halen bazı dosyaların <literal>a.out</literal>
     dosyalar olmasıdır. Eğer paralel portunuza bağlı aletleri (örneğin
     yazıcı) kullanmak istiyorsaniz paralel port desteğini vermeyi unutmayın.
    </para>
   </sect3>
   <sect3>
    <title>Tak/Çalıştır Desteği</title>
    <subtitle>Plug and Play Support</subtitle>
    <para>
     Makinanızdaki PnP kartları kullanabilmek için bu seçeneği seçmeniz
     gerekmekte.
    </para>
   </sect3>
   <sect3>
    <title>Blok Aygıtları</title>
    <subtitle>Block Devices</subtitle>
    <para>
     Burada da eğer IDE diskiniz varsa seçip derlemeniz gerekiyor.
     Söylenebilecek birkaç şeyden biri
     <literal>SCSI Emulation Support</literal> olabilir. Bu seçeneği örneğin
     elinizde IDE bir cd yazıcı varsa kullanmanız gerekmektedir.
     Ayrıca <xref linkend="kernel-nasil_scsi-support"/> ve
     <literal>SCSI Generic Support</literal> vermeniz gerekiyor. Yalnız dikkat
     edilmesi gereken nokta eğer elinizde SCSI aygıtlar varsa ve SCSI kontrol
     kartınız yoksa bu seçeneği seçerek bu aygıtları kullanamazsınız.
     <literal>Software-RAID</literal> (Yazılımsal-RAID) kullanmak için yine
     burada bulunan <literal>Multiple Devices Driver Support</literal> (Çoklu
     Aygıt Sürücüsü Desteği) seçeneğini işaretlemeniz gerekiyor. Bir başka
     seçenek ise <literal>loopback</literal> aygıt desteğidir. Bu size örnek
     olarak CD'ye yazmak için kullanacağınız bir imge dosyasını bir blok
     aygıtı olarak kullanmanızı ve ve dosya sisteminize bağlayabilmenizi
     sağlayacaktır. Bunu şu sekilde yapabilirsiniz:
    </para>
<screen># mount /dosya.iso /mnt -o loop</screen>
     <para>
      Ayrıca yine bu bölümde bulunan <literal>Parallel Port IDE Device
      Support</literal> seçeneği ile paralel porta bağlanan harici IDE
     aygıtlarını kullanabilirsiniz. Bu seçenek için öncelikle yanındaki
     <literal>help</literal>'i okumanızı tavsiye ederim.
    </para>
   </sect3>
   <sect3>
    <title>Ağ Seçenekleri</title>
    <subtitle>Networking Options</subtitle>
    <para>
     Eğer ağa bağlı olmayan bir makina kullanacaksanız bu bölümü doğrudan
     iptal edebilirsiniz. Fakat kullanacaksanız burada da bazı açıklamalar
     yapalım. Eğer güvenlik duvarı kullanmak istiyorsanız <literal>network
     firewalls</literal> seçeneğini seçmeniz gerekiyor. Yine <literal>TCP/IP
     networking</literal> seçilmeli. Ayrıca çeşitli protokoller için
     seçenekler yine mevcut, örneğin <literal>IPX</literal>. Burada
     ihtiyacınız olan seçenekleri yapmak istediklerinize göre seçmeniz
     gerekiyor. Bunları seçerken <literal>help</literal>'leri okumanızı
     tavsiye ederim. Örneğin tek bir ethernet kartına birden fazla IP vermek
     için kullanılan <literal>IP Aliasing Support</literal> veya 2.0.30
     çekirdekten beri bulunan ve <literal>SYN Flooding</literal> olarak
     adlandırılan saldırıyı önlemek için kullanılan <literal>IP: TCP Syncookie
     Support</literal>'u bu bölümde bulabilirsiniz.
    </para>
   </sect3>
   <sect3 xml:id="kernel-nasil_scsi-support">
    <title>SCSI Desteği</title>
    <subtitle>SCSI Support</subtitle>
    <para>
     Eğer kök dizininiz bir SCSI aygıt üzerinde ise
     <literal>SCSI support</literal>'u modül olarak SEÇMEMELİSİNİZ. Sistemdeki
     SCSI aygıtları kullanabilmek için bu bölümde onlara desteklerini vermeniz
     gerekiyor. Sadece SCSI aygıtları değil ayrıca eğer <literal>SCSI
     Emulation</literal> seçeneğini önceden seçmişseniz yine burada destek
     vermeniz gerekiyor. Bir sonraki bölüm <literal>SCSI low-level
     drivers</literal> bölümü. Burada da SCSI kontrol kartınız hangisi ise onu
     seçmelisiniz. Hemen hemen bütün kontrol kartlarının sürücüleri için
     burada destek bulabilirsiniz.
    </para>
   </sect3>
   <sect3>
    <title>Ağ Aygıtı Desteği</title>
    <subtitle>Network Device Support</subtitle>
    <para>
     Bu bölüm bizi ağa tekrar geri getiriyor. Burada ağa bağlanmak için
     kullandığınız aygıt için sürücüleri seçiyorsunuz.
     <literal>FDDI</literal>'den <literal>Token Ring</literal>'e birçok
     arabirim için sürücüleri bulabilirsiniz. Eğer modem bağlantısı
     yapacaksanız <literal>PPP</literal>'yi seçmeyi unutmayın. Ethernet
     kartlarından ise yine sizin için uygun olanı seçin. Örneğin kök dizininiz
     için NFS kullanıyorsanız ethernet kartınızı çekirdeğin içinde derlemeyi
     unutmayın.
    </para>
   </sect3>
   <sect3>
    <title>Amatör Radyo Desteği</title>
    <subtitle>Amateur Radio Support</subtitle>
    <para>
      Bu bölüm için önce <literal>HAM-HOWTO</literal> ve
      <literal>AX.25-HOWTO</literal>'yu okumanızı öneririm.
    </para>
   </sect3>
   <sect3>
    <title>IrDa Desteği</title>
    <subtitle>IrDa Subsystem Support</subtitle>
    <para>
     <trademark>Infrared Data Associations</trademark> tarafından belirlenen
     kablosuz kızılötesi iletişimde kullanılan <literal>IrDa</literal>
     protokollerinin standartları birçok dizüstü tarafından kabul
     edilmektedir. Eğer Linux'un bu protokollere destek vermesini istiyorsaniz
     bu seçeneği seçmeniz gerekmekte. Fakat bu tek başına yeterli olmamakta.
     Bunun yanında <literal>irmanager</literal> ve <literal>irattach</literal>
     gibi uygulamalara da ihtiyacınız bulunmaktadır. Kablosuz ağdan, kablosuz
     yazıcı ve hatta seri port öykünümüne kadar birçok alanda
     kullanılabilmektedir.
    </para>
   </sect3>
   <sect3>
    <title>ISDN Desteği</title>
    <subtitle>ISDN Subsystem</subtitle>
    <para>
     ISDN (Integrated Services Digital Networks) kullanıyorsanız seçmek zorunda olduğunuz bir seçenek.
    </para>
   </sect3>
   <sect3>
    <title>Eski CD-ROM Aygıtları (Ne SCSI ne de IDE)</title>
    <subtitle>Old CD-ROM Drivers (Not SCSI, Not IDE)</subtitle>
    <para>
     Eğer IDE veya SCSI bir CD-ROM kullanıyorsanız bu bölümü geçebilirsiniz.
     Ama CD-ROM'unuz listedekilerden bir tanesi ise onu işaretleyin.
    </para>
   </sect3>
   <sect3>
    <title>Karakter Aygıtları</title>
    <subtitle>Character Devices</subtitle>
    <para>
     Alt-F1, Alt-F2... gibi kullandığınız sanal uçbirimller için burada
     bulunan ilk seçenek olan <literal>Virtual Terminal</literal> ve
     <literal>Support For Console on Virtual Terminal</literal> secçneklerini
     işaretlemeyi unutmayın. Bunun yanında örneğin PS/2 olan farenize desteği
     bu bölümde bulabilirsiniz. Burada bulunan <literal>Unix98 PTY
     Support</literal> için glibc-2.1'in (libc-6.1 ile aynı, kontrol için
     <literal>ls -l /lib/libc.so.*</literal> komutunu verin.) sistemde yüklü
     olması gerekmekte.
    </para>
    <para>
     Ayrıca eğer bu seçeneği seçerseniz
     <xref linkend="kernel-nasil_filesystems"/> bölümünde
     <literal>/dev/pts filesystem for UNIX98 PTYs </literal>
     seçeneğini seçmeyi unutmayın. Eğer daha önce SMP (Symmetric Multi
     Processing) desteğini seçmişseniz bu bölümde <literal>Enhanced Real
     TimeClock Support</literal> seçeneğini seçmeyi unutmayın. Yine
     <literal>Video for Linux</literal> bölümünde televizyon ve radyo
     kartlarınız için desteği bulabilirsiniz. Floppy'ye bağlı olan teyp
     sürücüleri için destek ise <literal>Ftape, The Floppy Tape
     Device Driver</literal> bölümünde bulunmaktadır. Paralel portunuza bağlı
     olan yazıcıyı kullanmak için daha önceden vermiş olduğunuz paralel port
     desteğine ek olarak bu bölümde bulunan <literal>Parallel Printer
     Support</literal> seçeneğini de seçmeniz gerekmektedir. Yine oyun çubuğu
     kullanmak için desteği burada <literal>Joystick Support</literal> altında
     bulabilirsiniz.
    </para>
   </sect3>
   <sect3 xml:id="kernel-nasil_filesystems">
    <title>Dosya Sistemleri</title>
    <subtitle>Filesystems</subtitle>
    <para>
     Değişik dosya sistemlerini kullanabilmek için onlara bu bölümde destek
     vermeniz gerekmektedir. Ek bilgi olarak bütün bu değişik dosya
     sistemlerini Linux altında kullanmanızı sağlayan sistemin adı VFS
     (Virtual File System) Sanal Dosya Sistemidir. Burada daima seçilmesi
     gereken <literal>Second Extended FS Support</literal>'dur. Bu şu an
     Linux'un kullandığı dosya sistemi olan <literal>ext2</literal>'dir ve
     daha önce belirtildiği gibi makinanın açılabilmesi için seçilmesi
     gerekmektedir. Yine <literal>/dev/proc</literal> desteği de
     unutulmamalıdır. Kota türü
     uygulamalar için burada destek bulabilirsiniz. Eger NFS kullanıyorsanız
     <literal>Network File System</literal> bölümünde desteğini
     verebilirsiniz. Burada DOS, UMSDOS, VFAT, ISO9660 gibi desteklerin
     hepsini modül olarak vermenizi tavsiye ederim. Bunlar ihtiyaç oldugu
     zaman <literal>kerneld</literal> tarafından yüklenirler.
    </para>
    <para>
     Buraya <literal>kerneld</literal> için ufak bir açıklama koyalım.
     <literal>Kerneld</literal> sistemde ilk çalıştırılan
     <literal>rc</literal> betiklerinden biri olmalıdır.
    </para>
   </sect3>
   <sect3>
    <title>Konsol Sürücüleri</title>
    <subtitle>Console Drivers</subtitle>
    <para>
     Burada size ek olarak söyleyebileceğim <literal>Video Mode Selection
     Support</literal> seçeneğini seçerseniz
     <literal>/etc/lilo.conf</literal>'un içinde <literal>vga=ask</literal>
     veya <literal>ask</literal> yerine kullanmak istediğiniz kipin numarasını
     girmeyi unutmamanızdır. Eğer <literal>Frame Buffer Device</literal>
     kullanmak istiyorsanız bu bölümde desteğini vermeniz gerekmektedir.
    </para>
   </sect3>
   <sect3>
    <title>Ses</title>
    <subtitle>Sound</subtitle>
    <para>
     Sanırım birçok kişinin en çok sorun ile karşılaştığı bölüm burasıdır.
     Bu bölümde ses kartınızı doğru olarak seçmeniz gerekmekte. Ayrıca
     <literal>I/O</literal> ve <literal>IRQ</literal> değerlerini doğru
     olarak girdiğinizden emin olun. Eğer <literal>SoundBlaster</literal>
     bir kartınız varsa IRQ değeri olan 7 yi 5 olarak değiştirin. Yine MPU401
     I/O 0 olarak gözüküyorsa bu degeri 330 yapın. Bunun dışında diğer
     kartlarda girdiğiniz değerlerin doğru olduğundan emin olun. PnP bir ses
     kartına sahipseniz ISA PnP uygulamlarını kullanmanız gerekiyor. Fakat her
     koşulda yine de ses desteğini modül olarak vermeniz gerekiyor. Dolayısı
     ile eğer bir ses kartınız varsa ses desteği en azından modül olarak
     verilmiş olması gerekiyor. Ses kartınız yoksa fakat PC'nizin hoparlörünü
     (bip sesini veren) kullanmak istiyorsaniz
     <link xlink:href="ftp://ftp.infradead.org/pub/pcsp/"/> adresinden gerekli
     olan çekirdek yamalarını ve uygulamaları indirmeniz gerekiyor.
    </para>
    <para>
     Yine de ses ile ilgili ayarlamaları yapmadan once Türkçe'ye sevgili R.
     Tolga Korkunçkaya tarafından çevrilen Sound-HOWTO, Ses-NASIL'ı okumanızı
     tavsiye ederim. Bunun yanında
     <literal>/usr/src/linux/Documentation/sound/</literal> dizini altında
     ses kartınız ile ilgili olan açıklama dosyasını okumanızı da öneririm.
    </para>
    <para>
     SB Live ses kartına sahipseniz bunun için sürücüleri
     <link xlink:href="http://opensource.creative.com/"/>
     adresinden indirebilirsiniz. Daha sonra çektiğiniz paketin içindeki
     <literal>INSTALL</literal> dosyasını okuyarak bu kartı kullanabilirsiniz.
     Bu paketteki işlemleri yaptığınız zaman <literal>emu10k1.o</literal> diye
     bir modul dosyası oluşacaktır ve
     <literal>/lib/modules/linux-2.2.*</literal>
     dizininde <literal>misc</literal> altdizinine kopyalanacaktır. Yine bunu
     kullanabilmek için önce Ses desteğini modül olarak vermeniz gerekmekte.
     Yani burada <literal>soundcore.o</literal> ve
     <literal>emu10k1.o</literal> adlı iki modül bulunmalı bunlardan önce
     <literal>soundcore.o</literal>'yu sonra <literal>emu10k1.o</literal>'yu
     <literal>insmod</literal> ile yükleyerek SB Live ses kartınızı
     kullanabilirsiniz. Daha ayrıntılı açıklama için bu paketteki
     <literal>INSTALL</literal> dosyasını okumanız gerekmekte.
    </para>
   </sect3>
   <sect3>
    <title>Çekirdek Programlama</title>
    <subtitle>Kernel Hacking</subtitle>
    <para>
     Bu bölüme genel olarak hemen hemen herkesin cevabı hayırdır.
     <literal>Alt+PrintScreen</literal> tuşları ile beraber çeşitli tuş
     kombinasyonları ile bir takım kontrol oğelerine sahip olmanızı sağlayan
     bu seçenek aslında oldukça faydalı fakat en azından ben de şimdilik
     sadece makinayı bir anda kapatması nedeniyle tavsiye etmeyeceğim. Sorunun
     nerede olduğunu bulursam ve düzgün çalışırsa o zaman tavsiye ederim.
    </para>
   </sect3>
  </sect2>
  <sect2>
   <title>Çekirdeğin Derlenmesi</title>
   <para>
    Şimdi yapmanız gereken şey yapılandırmanızı saklamanız ve çıkmanız.
    Bunları <literal>save</literal> ve <literal>exit</literal> ile
    yapabilirsiniz. Bunu yaptığınız zaman saklamış olduğunuz yapılandırma bir
    metin dosyasında saklanır. Bu dosyayı istediğiniz bir metin düzenleyici
    (Emacs, vi, Crisplite, joe,pico, ...) ile değiştirebilirsiniz. Bu dosya
    <literal>.config</literal> dosyasıdır. Sırada ise
    <literal>make dep</literal> geliyor. Bunun amacı ise sizin
    <literal>.config</literal> dosyasındaki yapılandırmanızı alt dizinlere
    yaymaktır. Böylece yapılandırma işlemini tamamlamaktır. Daha sonra
    <literal>make clean</literal> komutunu vermeniz gerekiyor. Bunun amacı ise
    core dosyaları *.tmp dosyaları System.map gibi dosyaları temizlemektir.
   </para>
   <para>
    Evet şimdi çekirdeği derlemeye başlamak için tamamen hazırız. Bunun için
    önümüzde birkaç tane yol var. Bunları açıklayalım.
   </para>
   <variablelist>
    <varlistentry>
     <term>make zImage</term>
     <listitem>
      <para>
       Basit, sıkıştırılmış olan çekirdeği oluşturur ve
       <literal>/usr/src/linux/arch/i386/boot/</literal> altına
       <literal>zImage</literal> adı altında yerleştirir.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>make zlilo</term>
     <listitem>
      <para>
       <literal>zImage</literal>'ı kök dizine kopyalar ve
       <literal>lilo</literal>'yu çalıştırır. Eğer bunu seçerseniz
       <literal>/etc/lilo.conf</literal>'u önceden ayarlamış olmanız
       gerekmektedir.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>make zdisk</term>
     <listitem>
      <para>
       <literal>zImage</literal>'ı <literal>/dev/fd0</literal>'daki bir
       diskete yazar. Bunun olabilmesi için doğal olarak önceden sürücüye
       bir disket koymuş olmanız gerekmektedir. 720K'lık disketlere çekirdek
       sığmaz, bu yüzden kullanmayın.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>make boot</term>
     <listitem>
      <para><literal>make zImage</literal> ile aynı şekilde çalışır.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>make bzImage</term>
     <listitem>
      <para>
       Büyük çekirdekler için kullanılır ve <literal>make zImage</literal> ile
       aynı şekilde çalışır. <literal>/usr/src/linux/arch/i386/boot/</literal>
       altına <literal>bzImage</literal> adı altında yerleştirir. Birçok kişi
       bu seçenekte bzip gibi bir sıkıştırma algoritmasının kullanıldığını
       zanneder. Bu tamamen yanlış bir düşüncedir. <literal>bzImage</literal>
       kullanıldığı zaman nelerin yapıldığı
       <literal>/usr/src/linux/arch/i386/boot/tools/</literal> altında
       <literal>build.c</literal> adlı dosyada bulunmaktadır. Bu seçeneği
       çekirdek derlenmesi sırasında "<emphasis>System is too big. Try using
       bzImage or modules</emphasis>" hata mesajını aldığınız zaman
       kullanmalısınız.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>make bzdisk</term>
     <listitem>
      <para>
       Büyük çekirdekler için kullanılır ve <literal>make zdisk</literal> ile
       aynı şekilde çalışır. Yukarıdaki hata mesajını <literal>make zdisk</literal>
       seçeneğinde alırsanız bunu kullanmalısınız.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    Bunların dışında <literal>make</literal> seçenekleri de vardır fakat daha
    özel oldukları için açıklamayacağım. Yukarıdaki seçenekler yeterlidir.
    Benim bunların içinde tavsiyem <literal>make bzImage</literal>'dır.
   </para>
   <para>
    Yapılandırma sırasında modül kullanmışsanız aşağıdaki komutları vermeniz
    gerekmektedir:
   </para>
<screen># make modules
# make modules_install
</screen>
   <para>Bu komutları böylede verebilirsiniz:</para>
<screen># make bzImage;make modules;make modules_install</screen>
   <para>
    Böylece bir komutun bitmesini beklemek zorunda kalmazsınız.
   </para>
   <para>
    Eğer bu kadar komutu nasıl aklınızda tutacağınızı düşünüyorsanız veya
    bütün bunları teker teker yazmak istemiyorsaniz.
    <literal>/etc/profile</literal> dosyasına örneğin <literal>derle</literal>
    adlı bir alias ekleyin bu tek bir satırda ve şu şekilde olsun.
   </para>
<screen>alias derle='cd /usr/src/linux;make mrproper;make menuconfig;make dep;make \
clean;make bzImage;make modules;make modules_install'
</screen>
   <para>Daha sonra</para>
<screen># source /etc/profile</screen>
   <para>
    komutunu verin. Böylece bir dahaki çekirdek derleme işleminde önceden
    kaynak kodunu <literal>/usr/src/</literal> altına koyduktan ve gerekli
    bağları yaptıktan sonra
   </para>
<screen># derle </screen>
   <para>
    dersiniz. Böylece hiç vakit kaybetmeden <literal>make menuconfig</literal>
    ile de çekirdeği yapılandırır, çekirdeği ve modülleri derler ve yerlerine
    yerleştirmiş olursunuz.
   </para>
   <para>
    Çekirdek derlendikten sonra yapmanız gereken birkaç şey kalıyor. İlk önce
    çekirdeği nereye isterseniz oraya yerleştirin. Bu isterseniz kök dizini,
    <literal>/boot</literal> dizini veya sizin istediğiniz başka bir yer
    olabilir ama eğer düzenli olmasını istiyorsanız <literal>/boot</literal>
    dizinine yerleştirmek daha iyi olacaktır. Ayrıca
    <literal>/usr/src/linux/</literal> altındaki <literal>System.map</literal>
    dosyasını da bu dizine yerleştirin.
   </para>
   <para>
    Yukarıdaki <literal>/boot</literal> dizinine yerleştirme işlemlerini tek
    komutla da halledebilirsiniz:
   </para>
<screen># make install</screen>
   <para>
    Daha sonra <literal>/etc/lilo.conf</literal> dosyasını düzenleyin. Bu
    çok önemlidir. Eğer <literal>/etc/lilo.conf</literal>'da yeni çekirdeği
    belirtmezseniz bu çekirdek ile sistemi başlatamazsınız. Çekirdeğin olduğu
    yere bakarsanız orada <literal>vmlinuz</literal> adlı bir çekirdek imgesi
    görürsünüz. Bu sizin ilk çekirdeğinizdir. Bu çekirdeğin çalıştığını
    biliyorsanız ona dokunmayın. <literal>Vmlinuz</literal> adı şu anlamlara
    geliyor:
    <simplelist>
     <member>
      <command>v</command>: "virtual" ve "sticky" (sanal ve yapışkan)
     </member>
     <member>
      <command>m</command>: "memory" ve "disk management" (bellek ve disk yönetimi)
     </member>
     <member><command>z</command>: çekirdek sıkıştırılmış.</member>
    </simplelist>
   </para>
   <sect3>
    <title><literal>/etc/lilo.conf</literal> Dosyasının Düzenlenmesi</title>
    <para>
     <literal>/etc/lilo.conf</literal>'u yeni çekirdeği ekleyecek biçimde
     düzenleyelim. Bunun için <literal>image=/boot/vmlinuz</literal> olan
     bölümlere yeni imgemizi eklememiz gerekiyor.
     <literal>/etc/lilo.conf</literal>'un şu şekilde olduğunu varsayalım:
    </para>
<screen>boot=/dev/hda
map=/boot/map
install=/boot/boot.b
prompt
timeout=50
linear
default=linux

image=/boot/vmlinuz-2.2.12
  label=linux
  read-only
  root=/dev/hdb1

other=/dev/hda1
  label=dos
</screen>
    <para>Şimdi yeni çekirdeği ekleyelim.</para>
<screen>boot=/dev/hda
map=/boot/map
install=/boot/boot.b
prompt
timeout=50
linear
default=linux

image=/boot/vmlinuz-2.2.15
  label=linux
  read-only
  root=/dev/hdb1

image=/boot/vmlinuz-2.2.12
  label=eski
  read-only
  root=/dev/hdb1

other=/dev/hda1
  label=dos
</screen>
    <para>
     Böylece yeni çekirdeğimizi <literal>/etc/lilo.conf</literal>'a eklemiş
     olduk. Bunu yaptıktan sonra lilo komutunu vermeyi unutmayın. lilo komutunu verdikten sonra ekranda çekirdek etiketlerini görürüz şöyle ki:
    </para>
<screen># lilo
Added linux *
Added eski
Added dos
</screen>
    <para>
     Burada "*" işaretli olan öntanımlı yüklenecek çekirdektir. Bu
     <literal>default=linux</literal> satırında <literal>label</literal>'i
     belirtilen çekirdektir. Eğer ekranda bu çıktıları göremediyseniz veya
     hata mesajı ile karşılaştıysanız tekrar
     <literal>/etc/lilo.conf</literal>'u düzenleyin ve lilo komutunu tekrar
     verin.
    </para>
   </sect3>
  </sect2>
  <sect2>
   <title>Makinanın Yeni Çekirdekle Açılması</title>
   <para> Şimdi makinayı yeniden başlatalım. Bunu:</para>
<screen># shutdown -r now</screen>
   <para>ya da makinanız destekliyorsa</para>
<screen># poweroff</screen>
   <para>
    ile yapabilirsiniz. <literal>reboot</literal> ve
    <literal>ctrl+alt+del</literal>'de aynı işi yapmasına rağmen bazı
    durumlarda dosya sistemlerin düzgün olarak ayrılmasını sağlayamıyor ve
    açık olan dosyaların tahrip olmasına neden olabiliyor.
   </para>
   <para>
    Eğer açılışta LILO satırından sonra çekirdeğe bazı parametreler girmek
    isterseniz ve boot: ibaresini göremiyorsaniz shift tuşuna basarak
    görebilirsiniz. Böylece boot: ibaresi ekranda gözükür. Bu ibareyi
    gördükten sonra <literal>tab</literal> tuşuna basarak elimizdeki çekirdek
    etiketlerini görebiliriz. Hangi çekirdeğin yüklenmesini istiyorsanız onun
    etiketini yazın ve yanına parametrelerinizi girin. Eğer açılış sırasında
    "VFS, cannot mount root" gibi bir hata mesajı görürseniz daha önceden
    bahsetmiş olduğum disk veya dosya sistemi desteklerinden birini vermemişsiniz demektir.
   </para>
   <para>
    Bütün hepsi bu kadar artık yeni çekirdeğiniz ile çalışıyorsunuz.
   </para>
  </sect2>
 </sect1>
 <appendix xml:id="kernel-nasil_copyright">
  <title>Telif Hakkı ve Lisans</title>
  <!-- The LDP recommends, but doesn't require, the GFDL -->
  <para>
   Bu belgenin, <emphasis>Çekirdeğe Yama Uygulanması ve Çekirdeğin Derlenmesi
   NASIL</emphasis>, 0.1 sürümünün telif hakkı © 2000
   <emphasis>Murat Koç</emphasis>'a aittir. Bu belgeyi, Free Software
   Foundation tarafından yayınlanmış bulunan GNU Özgür Belgeleme Lisansının
   1.1 ya da daha sonraki sürümünün koşullarına bağlı kalarak kopyalayabilir,
   dağıtabilir ve/veya değiştirebilirsiniz. Bu Lisansın bir kopyasını <link
   xlink:href="&gfdl;">GNU Free Documentation License</link> başlıklı
   bölümde bulabilirsiniz.
  </para>
  <para>
   Linux, Linus Torvalds adına kayıtlı bir ticarî isimdir.
  </para>
 </appendix>
 <appendix xml:id="kernel-nasil_disclaimer">
  <title>Feragatname</title>
  <para>
   Bu belgedeki bilgilerin kullanımından doğacak sorumluluklar,
   ve olası zararlardan belge yazarı sorumlu tutulamaz.
   Bu belgedeki bilgileri uygulama sorumluluğu uygulayan aittir.
  </para>
  <para>
   Tüm telif hakları aksi özellikle belirtilmediği sürece sahibine
   aittir. Belge içinde geçen herhangi bir terim bir ticarî isim
   yada kuruma itibar kazandırma olarak algılanmamalıdır. Bir ürün
   ya da markanın kullanılmış olması ona onay verildiği anlamında
   görülmemelidir.
  </para>
 </appendix>
</article>
