<?xml version="1.0" encoding="UTF-8"?>
<!--DOCTYPE article SYSTEM "../../docbook/dtd/docbookx.dtd"-->
<!-- ********************************************************************
     $Id: SDL-NASIL.xml,v 1.4 2002/09/30 18:21:13 nilgun Exp $
     ******************************************************************** -->

<article id="gdb-NASIL" lang="tr">
  <articleinfo>
    <title>SDL Kütüphanesi Kullanımı</title>
    <author>
       <firstname>Ozan Emirhan</firstname>
       <surname>Bayyurt</surname>
       <affiliation>
         <address>
          <email>ragnor_whr@yahoo.com</email>
         </address>
       </affiliation>
     </author>
     <pubdate>Temmuz 2005</pubdate>
     <pubdate> </pubdate>

     <!-- Most recent revision goes at the top; list in descending order -->
     <revhistory>
       <revision>
          <revnumber>1.0</revnumber>
          <date>Temmuz 2005</date>
          <authorinitials>OEB</authorinitials>
          <revremark>Belgenin özgün sürümü <ulink url="http://www.oyunyapimi.org/modules.php?name=Sections&op=viewarticle&artid=87"/> adresinde bulunabilir.</revremark>
       </revision>
    </revhistory>
    <abstract>
      <para>
SDL, Simple DirectMedia Layer yani basit direkmedya katmanı kütüphanesidir. Anlaşılır bir ifade ile SDL ses, klavye, fare, oyun çubuğu, 3d donanımı ve 2d çizgeleri için hazırlanmış platform bağımsız bir çokluortam (multimedia) yazılım geliştirme kütüphanesidir.
      </para>
    </abstract>
    <legalnotice><title>Yasal Açıklamalar</title>
      <para>
Bu belgenin, <emphasis>SDL Kütüphanesi Kullanımı</emphasis> 1.0 sürümünün <emphasis role="bold"> telif hakkı © 2005 <emphasis>Ozan Emirhan Bayyurt</emphasis></emphasis>'a aittir. Bu belgeyi, Free Software Foundation tarafından yayınlanmış bulunan GNU Özgür Belgeleme Lisansının 1.1 ya da daha sonraki sürümünün koşullarına bağlı kalarak kopyalayabilir, dağıtabilir ve/veya değiştirebilirsiniz. Bu Lisansın bir kopyasını <ulink url="http://www.gnu.org/copyleft/fdl.html"/>  adresinde bulabilirsiniz.
    </para><para>
BU BELGE "ÜCRETSİZ" OLARAK RUHSATLANDIĞI İÇİN, İÇERDİĞİ BİLGİLER İÇİN İLGİLİ KANUNLARIN
İZİN VERDİĞİ ÖLÇÜDE HERHANGİ BİR GARANTİ VERİLMEMEKTEDİR. AKSİ YAZILI OLARAK BELİRTİLMEDİĞİ
MÜDDETÇE TELİF HAKKI SAHİPLERİ VE/VEYA BAŞKA ŞAHISLAR BELGEYİ "OLDUĞU GİBİ", AŞİKAR VEYA
ZIMNEN, SATILABİLİRLİĞİ VEYA HERHANGİ BİR AMACA UYGUNLUĞU DA DAHİL OLMAK ÜZERE HİÇBİR
GARANTİ VERMEKSİZİN DAĞITMAKTADIRLAR. BİLGİNİN KALİTESİ İLE İLGİLİ TÜM SORUNLAR SİZE AİTTİR.
HERHANGİ BİR HATALI BİLGİDEN DOLAYI DOĞABİLECEK OLAN BÜTÜN SERVİS, TAMİR VEYA DÜZELTME
MASRAFLARI SİZE AİTTİR.
    </para><para>
İLGİLİ KANUNUN İCBAR ETTİĞİ DURUMLAR VEYA YAZILI ANLAŞMA HARİCİNDE HERHANGİ BİR ŞEKİLDE
TELİF HAKKI SAHİBİ VEYA YUKARIDA İZİN VERİLDİĞİ ŞEKİLDE BELGEYİ DEĞİŞTİREN VEYA YENİDEN
DAĞITAN HERHANGİ BİR KİŞİ, BİLGİNİN KULLANIMI VEYA KULLANILAMAMASI (VEYA VERİ KAYBI OLUŞMASI,
VERİNİN YANLIŞ HALE GELMESİ, SİZİN VEYA ÜÇÜNCÜ ŞAHISLARIN ZARARA UĞRAMASI VEYA BİLGİLERİN
BAŞKA BİLGİLERLE UYUMSUZ OLMASI) YÜZÜNDEN OLUŞAN GENEL, ÖZEL, DOĞRUDAN YA DA DOLAYLI HERHANGİ
BİR ZARARDAN, BÖYLE BİR TAZMİNAT TALEBİ TELİF HAKKI SAHİBİ VEYA İLGİLİ KİŞİYE BİLDİRİLMİŞ
OLSA DAHİ, SORUMLU DEĞİLDİR.
    </para><para>
Tüm telif hakları aksi özellikle belirtilmediği sürece sahibine aittir. Belge içinde geçen herhangi bir terim, bir ticari isim ya da kuruma itibar kazandırma olarak algılanmamalıdır. Bir ürün ya da markanın kullanılmış olması ona onay verildiği anlamında görülmemelidir.
      </para>
    </legalnotice>
  </articleinfo>

  <sect1><title>SDL Nedir?</title><para>
SDL, Simple DirectMedia Layer yani basit direkmedya katmanı kütüphanesidir. Anlaşılır bir ifade ile SDL ses, klavye, fare, oyun çubuğu, 3d donanımı ve 2d çizgeleri için hazırlanmış platform bağımsız bir çokluortam (multimedia) yazılım geliştirme kütüphanesidir. Mpeg oynatıcılarda, emülatorlerde, birçok popüler oyunda ve Linux'a uyarlanan edilen birçok windows oyununda kullanılmaktadır.
    </para><para>
SDL Linux, Windows, BeOS, MacOS Classic, MacOS X, FreeBSD, OpenBSD, BSD/OS, Solaris, IRIX ve QNX ortamlarını destekler. Ayrıca resmi olmasada kod açık olduğu için gönüllü çalışmalar sonucunda Windows CE, AmigaOS, Dreamcast, Atari, NetBSD, AIX, OSF/Tru64, RISC OS ve SymbianOS üzerinde de çalışması sağlanmıştır.
    </para><para>
SDL C dili ile yazılmış olmasına rağmen C++ ile doğal hali ile çalışmakta ve Ada, Eiffel, Java, Lua, ML, Perl, PHP,Pike, Python ve Ruby gibi birçok dil içinde uyarlamaları bulunmaktadır.
  </para></sect1>
  <sect1><title>Kurulum</title><para>
Bu konu aslında basit olmasına rağmen yeni başlayanları biraz zorlayabilir. Yine de elimden geldiğince her platform'da SDL'i nasıl kurup kullanmaya hazır hale getireceğimizi yazmaya çalışacağım.
  </para>
  <sect2><title>Linux</title><para>
Kütüphanenin kaynak paketini <ulink url="http://www.libsdl.org/"/> adresinden teminedebilirsiniz. Libsdl, hemen tüm dağıtımlarla gelmektedir. Dağıtımınızın paket yöneticisinde kısa bir araştırma ile bulup en son sürümünü geliştirme paketiyle birlikte kolayca kurabilirsiniz.
    </para><para>
Bu belgedeki örnekleri derlemek için genel olarak (örneğin Debian Sarge için),
    </para><para>
<literallayout>   <command>gcc -Wall -lSDL -I/usr/include/SDL -o </command><emphasis>dnm dnm.c</emphasis>
</literallayout>
    </para><para>
komutunu kullanabilirsiniz. Derleme seçenekleri sizin sisteminizde farklı olabilir (örneğin başlık dosyaları <filename>/usr/include/SDL</filename> dizininde değil de <filename>/usr/local/include/SDL</filename> dizininde olabilir). Kütüphane ile ilgili bazı önemli bilgileri <command>sdl-config</command> komutu ile öğrenebilirsiniz. Örneğin, derleme seçeneklerini öğrenmek için <command>sdl-config --libs --cflags</command> komutunu verebilirsiniz.
  </para><sect2><title>Windows</title>
Windows ortamında en yaygın olarak MS Visual Studio, Borland C++ Builder ve Dev-C++ IDE'leri kullanılmaktadır. Ama ben daha önce hiç C++ Builder kullanmadığım ve internette de C++
Builder için yazılmış bir kurulum yazısı bulamadığım için size tahmini bilgi verebileceğim, gerisi size kalmış. Yine de pek sorun yaşayacağınızı sanmıyorum.
  </sect2><sect3><title>Visual Studio</title><para>
İlk olarak MS'in IDE'si Visual Studio ile başlayalım. Ben Dev-C++ kullandığım için bu IDE hakkında pek bilgim yok ama internette yayınlanmış ingilizce derslerden topladığım bilgi ile
yardımcı olmaya çalışacağım.
    </para><para><orderedlist><listitem><para>
<ulink url="http://www.libsdl.org/download-1.2.php"/> adresinden "Development Libraries" başlığı altındaki Visual C++ için olan dosyayı (<filename>SDL-devel-1.2.8-VC6.zip</filename> gibi bir adı olması lazım) indirin.
    </para></listitem><listitem><para>
Sıkıştırılmış dosyayı açın. Zip dosyasının içinden çıkan dosyalar arasında iki tane önemli dizin var. Bunlar <filename>include</filename> ve <filename>lib</filename> dizinleri. <filename>lib</filename> dizininden çıkanları <filename>C:\Program Files\Microsoft Visual Studio\VC98\Lib</filename><footnote><para>Büyük ihtimalle sizin bilgisayarınızda da aynı dizindir ama eğer MS VC++'ı kurduğunuz yer farklı ise bu yoluda ona göre değiştirin.</para></footnote> dizini altına kopyalayın. <filename>include</filename> dizinindeki
dosyaları da <filename>C:\Program Files\Microsoft Visual Studio\VC98\Include\SDL</filename><footnote><para>Diğeri ile aynı şekilde farklı bir dizin
olabilir sizin ki, artık duruma göre değişikliği siz yaparsınız. Bir de <filename>include</filename> dizinin altında <filename>SDL</filename> dizini yok onu sizin oluşturmanız gerek.</para></footnote> dizini altına kopyalayın.
    </para></listitem><listitem><para>
Şimdi Visual C++'ı çalıştırın ve yeni bir proje başlatın. "Win32 Application" seçeneğini ve "empty project" seçeneğini seçin. File menüsündeki New seçeneği ile yeni bir c++ kaynak
dosyası (c++ source file) oluşturun ve adını <filename>main.cpp</filename> koyun.
    </para></listitem><listitem><para>
Daha sonra proje ayarları (project settings) (project->settings menüsü yolu ile) bölümüne
gidin. LINK tabına tıklayın listelenmiş diğer lib dosyalarının altına <filename>sdl.lib</filename> ve <filename>sdlmain.lib</filename> dosyalarını ekleyin.
    </para></listitem><listitem><para>
Ardından yine proje ayarları bölümünde C/C++ sekmesine tıklayın. Listeli menüden "Code Generation" seçeneğini seçin. Ardından da 'Use run-time library' menüsünden 'Multithreaded DLL' seçeneğini seçin.
    </para></listitem><listitem><para>
Son birşey daha. Sıkıştırılmış dosyanın içinde son bir önemli dosya bulunmakta, <filename>SDL.DLL</filename> dosyası. Bu dosyayı alıp ister işletim sisteminizin system dizinine (win 95, 98, ME için <filename>c:\windows\system</filename> dizini ya da windows NT, 2000 and XP için <filename>c:\windows\system32</filename> dizini), ister uygulamanızın exe dosyasının çalışacağı dizine kopyalayın. Eğer DLL dosyasını system dizinine kopyalarsanız
yapacağınız her SDL programı için dll dosyasını baştan baştan kopyalamanıza gerek kalmaz. Aksi takdirde her programın dizinine koymanız gerekir. Ayrıca programlarınızı dağıtırken de bu dll
dosyasını programınız ile vermeniz gerekiyor. Aksi halde yaptığınız program başka bilgisayarlarda çalışmaz.
    </para></listitem><listitem><para>
MS Visual Studio ile işimiz bu kadar bütün bu adımları gerçekleştirdikten sonra MS VC, SDL ile yazılım geliştirmeye hazır halegeliyor.
    </para></listitem></orderedlist></para>
    </sect3><sect3><title>Dev-Cpp</title><para>
Dev-C++ için SDL yüklemenin iki yolu var. Birincisi <ulink url="http://www.devpaks.org/"/> sitesine gidip SDL için gerekli devpak dosyasını indirmek ve Dev-C++ içerisindeki Package Manager ile bu devpak dosyasını yüklemek. Bu sayede hem SDL kütüphanesi sorunsuzca bilgisayarınıza yüklenecek hem de elinizin altında hızla program yazmaya başlamanız için hazır bir SDL kodu olacak. Diğer yol ise yukarıdaki gibi geliştirme paketini indirip her dosyayı yerine kurmak. Bu yolu izlerken yapmamız gerekenler;
    </para><para><orderedlist><listitem><para>
<ulink url="http://www.libsdl.org/download-1.2.php"/> adresinden Development Libraries başlığı altındaki MinGW32 için olan dosyayı (<filename>SDL-devel-1.2.8-mingw32.tar.gz</filename> gibi bir adı olması lazım) indirin.
    </para></listitem><listitem><para>
Sıkıştırılmış dosyayı açın. Zip dosyasının içinden çıkan dosyalar arasında iki tane önemli dizin var. Bunlar <filename>include</filename> ve <filename>lib</filename> dizinleri. <filename>lib</filename> dizininden çıkanları <filename>C:\Dev-Cpp\lib</filename> dizini altına kopyalayın. <filename>include</filename> dizinindeki dosyaları da <filename>C:\Dev-Cpp\include\SDL</filename> (<filename>include</filename>'un altında <filename>SDL</filename> dizini yok onu sizin oluşturmanız gerek.) dizini altına kopyalayın.
    </para></listitem><listitem><para>
Sıkıştırılmış dosyanın içinde son bir önemli dosya bulunmakta, <filename>SDL.DLL</filename> dosyası. Bu dosyayı alıp ister işletim sisteminizin system dizinine (win 95, 98, ME için
<filename>c:\windows\system</filename> dizini ya da windows NT, 2000 and XP için <filename>c:\windows\system32</filename> dizini), ister uygulamanızın exe dosyasının çalışacağı dizine kopyalayın. Eğer DLL dosyasını system dizinine kopyalarsanız yapacağınız her SDL programı
için dll dosyasını baştan baştan kopyalamanıza gerek kalmaz. Ayrıca <filename>SDL.DLL</filename> dosyasını <filename>c:\Dev-Cpp\dll</filename> dizininin altına da kopyalayın.
    </para></listitem><listitem><para>
Dev-Cpp'ı çalıştırın. New Project butonu ile yeni bir proje açın. Eğer Devpak'ı yüklediyseniz
proje şablonları arasında Multimedia sekmesi altında SDL için hazır bir şablon hazır
bulunmakta. Verdiğim dosya ile bu şablondaki dosyayı değiştirdiyseniz bu şablon sorunsuzca çalışacaktır. Bu şablon üzerinden dilediğinizce SDL uygulamalarınızı geliştirebilirsiniz. Ama
eğer Devpak ile değilde SDL'in sitesinden indirdiğiniz sıkıştırılmış dosyadan kurduysanız proje ayarlarını elle yapmalısınız. İlk olarak yeni bir proje açın (New Project). Ardından Project Browser'da çıkan projenizin adına sağ tuşla tıklayın ve Project Options'ı seçin. Burda ilk olarak Type bölümünden Win32 GUI seçeneğini seçin. Eğer Win32 Console'u seçerseniz SDL programınız her çalıştığında önce dos penceresi açılır. Ardından programınız çalışır. Devamında aynı pencerede Parameters sekmesini açın. Compiler başlığı altına <option>-I"&lt;INCLUDE>\SDL" -Dmain=SDL_main</option> seçeneklerini girin. Linker başlığı altına ise <option>-lmingw32 -lSDLmain -lSDL</option> seçeneklerini girin. Ayarlamalar bu kadar. İsterseniz şimdi projenizi
kaydedin ve SDL projesine başlayacakken ayarları hazır olduğundan bu proje üzerinden başlayın. Geriye bir tek kod yazmanız kaldı. O da sonraki bölümlerde anlatılacak.
    </para></listitem></orderedlist></para>
    </sect3><sect3><title>Mingw32</title><para>
Dev-Cpp'ta kendi içerisinde Mingw32 derleyicisi kullandığı için aşağı yukarı aynı ayarlar geçerli. Uzun uzadıya anlatmayacağım. Yukarıdaki açıklamalar yardımı ile sorunsuzca
ayarlamaları yapabilirsiniz diye düşünüyorum.
    </para></sect3></sect2>
  </sect1><sect1><title>SDL'e Giriş</title><para>
SDL öğrenmesi oldukça kolay bir kütüphanedir. Bu nedenle hızla kod yazmaya girişeceğim. Kısa sürede öğreneceksiniz zaten. SDL, sekiz alt sistemin bileşiminden oluşmaktadır. Bunlar:
    </para><para><itemizedlist>
<listitem>Ses(Audio)</listitem>
<listitem>CDROM</listitem>
<listitem>Olay yönetimi(Event Handling)</listitem>
<listitem>Dosya G/Ç(File I/O)</listitem>
<listitem>Oyur çubuğu yönetimi(Joystick Handling)</listitem>
<listitem>Çok evrelilik (Threading)</listitem>
<listitem>Zamanlayıcı(Timers)</listitem>
<listitem>Çizge(Video)</listitem>
    </itemizedlist></para><para>
Bu alt sistemleri kullanmak için ilk önce bu sistemleri ilklendirmeniz gerekir. Bunun için iki işlev bulunmaktadır. Bunlar <command>SDL_Init</command> ve <command>SDL_InitSubSystem</command>'dir. <command>SDL_Init</command> bütün SDL kodlarından önce çalıştırılmalıdır. Bu işlev SDL sistemini ilklendirir. <command>SDL_InitSubSystem</command> ise çalışma anında istediğiniz alt sistemin ilklendirilmesini sağlar. Öntanımlı alt sistemi ve çizge alt sistemini ilklendirmek için şöyle bir çağrı yapmalısınız:
    </para><para>
<screen>SDL_Init ( SDL_INIT_VIDEO );</screen>
    </para><para>
Öntanımlı alt sistem, çizge alt sistemi ile birlikte zamanlayıcı alt sistemini de ilklendirmek isterseniz şöyle bir çağrı yapmalısınız:
    </para><para>
<screen>SDL_InitSubSystem ( SDL_INIT_AUDIO | SDL_INIT_TIMER );</screen>
    </para><para><table frame="none" style=";background:#999999;">
      <title>İşleve argüman olarak belirtilebilecek sabitlerin listesi</title>
<tgroup cols='2'>
<tbody><row style="background:#ffffee;">
<entry><literal>SDL_INIT_TIMER</literal></entry>
<entry>Zamanlayıcı altsistemini ilklendirir</entry>
</row><row style="background:#ffffee;">
<entry><literal>SDL_INIT_AUDIO</literal></entry>
<entry>Ses altsistemini ilklendirir</entry>
</row><row style="background:#ffffee;">
<entry><literal>SDL_INIT_VIDEO</literal></entry>
<entry>Çizgesel altsistemi ilklendirir</entry>
</row><row style="background:#ffffee;">
<entry><literal>SDL_INIT_CDROM</literal></entry>
<entry>CDROM altsistemini ilklendirir</entry>
</row><row style="background:#ffffee;">
<entry><literal>SDL_INIT_JOYSTICK</literal></entry>
<entry>Oyun çubuğu altsistemini ilklendirir</entry>
</row><row style="background:#ffffee;">
<entry><literal>SDL_INIT_EVERYTHING</literal></entry>
<entry>Yukarıdakileren hepsini ilklendirir</entry>
</row><row style="background:#ffffee;">
<entry><literal>SDL_INIT_NOPARACHUTE</literal></entry>
<entry>SDL'nin ölümcül sinyalleri yakalamasını önler</entry>
</row><row style="background:#ffffee;">
<entry><literal>SDL_INIT_EVENTTHREAD</literal></entry>
<entry>Çok evrelilik</entry>
</row></tbody></tgroup></table>
      </para><para>
Alt sistemleri ilklendirmeyi öğrendik ama ya bunları sonlandırmayı? Şimdi de ilklendirdiğimiz SDL sistemini ve alt sistemlerini nasıl sonlandıracağımızı öğreneceğiz.
      </para><para>
İlk işlevimiz <command>SDL_Quit</command>. Bu işlev <command>SDL_Init</command> işlevinin yaptığı işin tam tersini yapar ve ilklendirdiğimiz SDL sistemini sonlandırır. Bu işlevi kullanırken herhangi bir argüman girmenize gerek yoktur. Kullanışı:
      </para><para>
<screen>SDL_Quit();</screen>
      </para><para>
şeklindedir. Bu işlev ile hali hazırda çalışan bütün SDL sistemi alt sistemleri sonlanır. Diğer işlevimiz ise <command>SDL_QuitSubSystem</command>. Bu işlev ile ilklendirmiş olduğumuz bir alt
sistemi sonlandırabiliriz. Kullanımı:
      </para><para>
<screen>SDL_QuitSubSystem ( SDL_INIT_TIMER );</screen>
      </para><para>
şeklindedir. Örneğimizde zamanlayıcı alt sistemini sonlandırdık ama SDL yazılımımız çalışmaya devam etti. Ayrıca <command>SDL_WasInit</command> işlevi ile istediğiniz alt sistemin ilklendirilmiş olup olmadığını kontrol edebilirsiniz. Bu işlevin kullanımı şöyledir:
      </para><para>
<screen>if (SDL_WasInit(SDL_INIT_VIDEO) != 0)
  printf("Çizgesel alt sistem yüklü.\n");
else
  printf("Çizgesel alt sistem yüklü değil.\n");
</screen>
      </para><para>
Şimdi öğrendiklerimizle örnek bir SDL yazılımı üzerinde pekiştirelim:
      </para><example>
<screen>
#include "SDL.h"  /* SDL başlık dosyası. Bütün SDL yazılımları için gereklidir. */
#include &lt;stdio.h>

int
main() {
  printf("SDL ilklendiriliyor.\n");

  /*  SDL sistemini ilklendirip çizge ve ses
   *  alt sistemlerini etkin duruma getirelim.
   */
  if ((SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO) == -1))
  {
    fprintf(stderr,"SDL ilklendirilemedi: %s.\n", SDL_GetError());
    exit(-1);
  }

  fprintf(stdout,
    "SDL sistemi ilklendirildi, çizge ve ses alt sistemleri etkin duruma getirildi.\n");

  fprintf(stdout,"SDL sistemi sonlandırılıyor.\n");
  SDL_Quit();

  fprintf(stdout,"Çıkılıyor....\n");

  exit(0);
}
</screen>
      </example>
  </sect1>
  <sect1><title>SDL ve Çizgeler</title><para>
Sırada çizge işlevlerini kullanmayı öğrenmek var. İlk olarak yapmamız gereken şey çizgesel alt sistemi etkin duruma getirmek. Ardından bir yüzey (surface) tanımlamamız ve <command>SDL_SetVideoMode</command> işlevi ile bu yüzeyi kullanarak istediğimiz çözünürlükte bir pencere oluşturmamız gerekir. İlk olarak yüzey terimini açıklamak istiyorum. SDL'de ekrana çizdirmek istediğiniz her şeyin verileri bir yüzeyde saklanır. Bu yüzeyler aslında önceden tanımlanmış yapılardır (struct). Bir yüzeyi şöyle tanımlayabiliriz:
    </para><para>
<screen>SDL_Surface *screen;</screen>
    </para><para>Çizgesel yüzey yapısının tanımı</para><para>
<funcsynopsis><funcprototype role="veri türü">
<paramdef>typedef struct SDL_Surface {
    Uint32           flags;      /* Salt okunur */
    SDL_PixelFormat *format;     /* Salt okunur */
    int              w, h;       /* Salt okunur */
    Uint16           pitch;      /* Salt okunur */
    void            *pixels;     /* Salt okunur */

    /* kırpma bilgileri */
    SDL_Rect         clip_rect;  /* Salt okunur */

    /* Başvuru sayacı -- yüzey serbest bırakılırken kullanılır */
    int              refcount;   /* Çok okunur */

    /* Bu yapı ayrıca, burda gösterilmeyen bazı özel alanlara da sahiptir */
} <command>SDL_Surface</command>;
</paramdef>
</funcprototype></funcsynopsis>
    </para><para>
Gördüğünüz gibi <command>SDL_Surface</command> yapısı ile uğraşırken sadece <literal>pixels</literal> değişkenini kullanabilirsiniz. Bu değişken de yüzeyin her beneğinin
renk bilgisini taşıyor ve isterseniz her beneği teker teker değiştirebilirsiniz. Bu konuya ileride daha ayrıntılı olarak değineceğiz ama şimdi devam edelim.
    </para><para>
Yazılımın başında ekrana yansıtacağımız görüntüler için bir yüzey tanımlarız ve bu yüzey ile bir pencere açarız. Bunu <command>SDL_SetVideoMode</command> işlevi ile yaparız. Kullanımı aşadığaki gibidir.
    </para><para>
<screen>screen = SDL_SetVideoMode (640, 480, 8, SDL_SWSURFACE);</screen>
    </para><para>
Bu satır, <literal>screen</literal> değişkeni ile ekrana yansıtacağımız ana yüzeyi tanımlar ve 640'a 480 benek çözünürlükte bir pencere oluşturur. Ekrandaki benek başına düşen bit sayısı 8 olur. Ve <literal>SDL_SWSURFACE</literal> sabiti ile ekran yüzeyine ait verilerin sistem belleğinde tutulması sağlanır. Bu işlevde kullanmak için birçok farklı sabit bulunmaktadır.
<table frame="none" style=";background:#999999;">
<title><literal>SDL_SetVideoMode</literal> işlevine argüman olarak belirtilebilecek sabitlerin listesi</title>
<tgroup cols='2'>
<tbody><row style="background:#ffffee;">
<entry><literal>SDL_SWSURFACE</literal></entry>
<entry>Yüzeye ait bilgiler sistem belleğinde saklanır</entry>
</row><row style="background:#ffffee;">
<entry><literal>SDL_HWSURFACE</literal></entry>
<entry>Yüzeye ait bilgiler ekran kartının belleğinde saklanır</entry>
</row><row style="background:#ffffee;">
<entry><literal>SDL_ASYNCBLIT</literal></entry>
<entry>Mümkünse, bit bloklarının aktarımı (blit)<footnote><para>blit - bit block transfer - Tek işlemcili makinelerde bit bloklarının eşzamansız aktarımı bit işlemeyi yavaşlatırken, çok işlemcili makinelerde hız artışı sağlayabilir.</para></footnote> eşzamansız yapılır.</entry>
</row><row style="background:#ffffee;">
<entry><literal>SDL_ANYFORMAT</literal></entry>
<entry>Bütün benek biçimlerine izin verilir<footnote><para>Normalde eğer ekran yüzeyi desteklenmeyen bir renk derinliği (bpp) isterse SDL gölge bir yüzey ile bunu taklit eder. <literal>SDL_ANYFORMAT</literal> kipinde SDL'in bunu yapması engellenir ve SDL'in yüzeyin renk derinliğini umursamadan onu kullanması sağlanır.</para></footnote></entry>
</row><row style="background:#ffffee;">
<entry><literal>SDL_HWPALETTE</literal></entry>
<entry>Yüzeyin ayrıcalıklı bir paleti olur<footnote><para><literal>SDL_HWPALETTE</literal> sabiti belirtilmemiş bir <command>SDL_SetColors</command> işlevi ile istediğiniz renkleri her zaman kullanamayabilirsiniz.</para></footnote></entry>
</row><row style="background:#ffffee;">
<entry><literal>SDL_DOUBLEBUF</literal></entry>
<entry>Çifte tamponlamayı etkin hale getirir<footnote><para><literal>SDL_DOUBLEBUF</literal> sabiti sadece <literal>SDL_HWSURFACE</literal> sabiti ile beraber kullanılabilir. <command>SDL_Flip</command> işlevi tamponların içeriğini değiştirir ve ekranı tazeler. Eğer çifte tamponlama etkinleştirilmemişse <command>SDL_Flip</command> bütün ekran üzerine <command>SDL_UpdateRect</command> işlevi uygulanmış gibi davranır.</para></entry>
</row><row style="background:#ffffee;">
<entry><literal>SDL_FULLSCREEN</literal></entry>
<entry>Yüzey ekranın tamamını kullanır</entry>
</row><row style="background:#ffffee;">
<entry><literal>SDL_OPENGL</literal></entry>
<entry>Yüzey bir OpenGL bağlamı kullanır<footnote><para><command>SDL_GL_SetAttribute</command>
işlevi ile OpenGL ayarlamalarına başlamadan önce <literal>SDL_OPENGL</literal> kipinin etkinleştirilmesi gerekir.</para></footnote></entry>
</row><row style="background:#ffffee;">
<entry><literal>SDL_OPENGLBLIT</literal></entry>
<entry>Yüzey bit bloklarının aktarımının OpenGL tarzında yapılmasını destekler</entry>
</row><row style="background:#ffffee;">
<entry><literal>SDL_RESIZABLE</literal></entry>
<entry>Yüzey boyutlandırılabilir<footnote><para>Pencere
boyutları değiştirildiği zaman <literal>SDL_VIDEORESIZE</literal> kipi tetiklenir ve <command>SDL_SetVideoMode</command> yeni boyut ile tekrar çağırılabilir.</para></footnote></entry>
</row><row style="background:#ffffee;">
<entry><literal>SDL_NOFRAME</literal></entry>
<entry>Mümkün ise çerçevesiz bir yüzey kullanılır.<footnote><para><literal>SDL_FULLSCREEN</literal> kipi kullanıldığında <literal>SDL_NOFRAME</literal> kipi de kendiliğinden etkinleştirilmiş olur.</para></footnote></entry>
</row><row style="background:#ffffee;">
<entry><literal>SDL_HWACCEL</literal></entry>
<entry>Yüzey bit bloklarının aktarımı donanımca gerçekleştirilir</entry>
</row><row style="background:#ffffee;">
<entry><literal>SDL_SRCCOLORKEY</literal></entry>
<entry>Yüzey bit bloklarının aktarımı için renk anahtarı (colorkey) kullanılır</entry>
</row><row style="background:#ffffee;">
<entry><literal>SDL_RLEACCEL</literal></entry>
<entry>Renk anahtarlı bit bloklarının aktarımı RLE ile yapılır</entry>
</row><row style="background:#ffffee;">
<entry><literal>SDL_SRCALPHA</literal></entry>
<entry>Yüzey bit bloklarının aktarımında alfa köreltmesi (alpha blending) kullanılır.</entry>
</row><row style="background:#ffffee;">
<entry><literal>SDL_PREALLOC</literal></entry>
<entry>Yüzey önceden ayrılmış bellek kullanır</entry>
</row></tbody></tgroup></table>
    </para><para>
Eğer istediğiniz ekran kipinin uygun olup olmadığını öğrenmek istiyorsanız <command>SDL_VideoModeOK</command> işlevini kullanabilirsiniz. Kullanımı,
    </para><para>
<screen>if (!SDL_VideoModeOK(640, 480, 16, SDL_HWSURFACE))
  printf("Ekran kipi uygun değil.\n");
else
  printf("Ekran kipi uygun.\n");
</screen>
    </para><para>
şeklindedir. Bunlar dışında <command>SDL_GetVideoInfo</command>, <command>SDL_GetVideoSurface</command>, <command>SDL_GetVideoDriverName</command> ve <command>SDL_ListModes</command> gibi çizgesel kip işlevleri de bulunmakla beraber  bunlara ileride değineceğiz.
    </para><para>
Şu ana kadar öğrendiklerimizle bir SDL penceresi açabileceğimiz bir SDL yazılımı geliştirebiliriz. Ama karşımıza çıkacak simsiyah bir pencere oldukça sıkıcı değil mi? Hadi ortamı biraz renklendirelim. İlk olarak oldukça basit olduğu için bir BMP dosyasını okuyup ekranda çizdirmeyi göstereceğim.
    </para><sect2><title>Resim dosyaları ile çalışma</title><para>
İlk olarak okuyacağımız BMP dosyasının içeriğini saklayacağımız bir yüzey oluşturmalıyız. Yüzeyler SDL'de resim bilgisinin saklanılacağı her yerde kullanılır.
    </para><para>
<screen>SDL_Surface *image;</screen>
    </para><para>
SDL'in kendi içerisinde BMP uzantılı dosyaları okuyup belleğe alan hazır bir işlev bulunmakta. Adı <command>SDL_LoadBMP</command>. Kullanımı:
    </para><para>
<screen>image = SDL_LoadBMP("images/a.bmp");</screen>
    </para><para>
şeklindedir. Bu sayede <literal>image</literal> adlı yüzeye <filename>a.bmp</filename> dosyasını yüklemiş bulunmaktayız. Şimdi sıra bu resmi ekrana çizdirmekte. Bunun içinse <command>SDL_BlitSurface</command> işlevini kullanacağız:
    </para><para>
<screen>SDL_BlitSurface(image, NULL, screen, NULL);</screen>
    </para><para>
Bu işlev ile <literal>image</literal> yüzeyindeki resmi <literal>screen</literal> yüzeyine yani ekrandaki görüntünün saklanacağı yüzeye çizdiririz. <literal>NULL</literal> değer verilen parametrelerde çizdirilecek yüzeylerin boyutları ve koordinatları belirlenir. Eğer iki parametreyede <literal>NULL</literal> girersek <literal>image</literal> yüzeyinin tamamı <literal>screen</literal> yüzeyinin 0,0 noktasından başlanarak çizdirilir. Eğer resmin belirli bir kısmını çizdirmek istersek veya ekranda 0,0 noktasından başka bir noktaya koymak istersek ne yapacağız? <command>SDL_Rect</command> kullanacağız. <command>SDL_Rect</command> SDL içerisinde dörtgen alanlar tanımlamak için kullanılan yapıdır. İçinde sadece dörtgenin kenar uzunlukları ile x,y düzlemindeki başlangıç koordinatları bulunur.
    </para><para><command>SDL_Rect</command> yapısının tanımı</para><para>
<funcsynopsis><funcprototype role="veri türü">
<paramdef>typedef struct{
  Sint16 <literal>x</literal>, <literal>y</literal>;
  Uint16 <literal>w</literal>, <literal>h</literal>;
} <command>SDL_Rect</command>;
</paramdef>
</funcprototype></funcsynopsis>
    </para><para>
<literal>x</literal> ve <literal>y</literal> koordinatları üst sol köşenin koordinatlarıdır. <literal>w</literal> ve <literal>h</literal> ise dörtgenin genişlik ve uzunluğudur. Oldukça basit ama niye böyle bir yapıya ihtiyacımız var diye düşünebilirsiniz. Bu yapıya ihtiyacımız var çünkü yüzeylerdeki resim alanları aslen dikdörtgen ve bunları kırpmak ya da belirli koordinatlara yerleştirmek isterseniz bu dikdörtgen yapısı oldukça kullanışlı oluyor. Yapmamız gereken,
    </para><para>
<screen>SDL_Rect dikdortgen;</screen>
    </para><para>
şeklinde bir bildirim yapmak. Eğer amacımız resmi belirli bir koordinata koymak ise şu yöntemi kullanmalıyız:
    </para><para>
<screen>SDL_Rect hedef;
hedef.x = x; // resmi koymak istediğimiz noktanın x koordinatı
hedef.y = y; // resmi koymak istediğimiz noktanın y koordinatı
SDL_BlitSurface(image, NULL, screen, &amp;hedef);
</screen>
    </para><para>
Ama eğer amacımız resmin sadece bir bölümünü çizdirmek ise bu yöntemi
kullanmalıyız:
    </para><para>
<screen>SDL_Rect dortgen1, dortgen2;

dortgen1.x = x; // resmin ekrana çizilecek parçasının x noktası
dortgen1.y = y; // resmin ekrana çizilecek parçasının y noktası
dortgen1.w = w; // resmin ekrana çizilecek parçasının genişliği
dortgen1.h = h; // resmin ekrana çizilecek parçasının uzunluğu

dortgen2.x = x2; // resmin ekrana yerleştirileceği x başlangıç noktası
dortgen2.y = y2; // resmin ekrana yerleştirileceği y başlangıç noktası

SDL_BlitSurface(image, &amp;dortgen1, screen, &amp;dortgen2);
</screen>
    </para><para>
(İşlev <literal>image</literal> yapısının içeriğinde <literal>dortgen1</literal> parçasını alırken değişiklik yapmaz.)
    </para></sect2><sect2><title>Ekrana doğrudan çizmek</title><para>
<command>SDL_Rect</command> yapısını kullanarak ekrana bir dikdörtgen çizdirmenizde mümkün. Dörtgeni yerleştireceğiniz <literal>x</literal> ve <literal>y</literal> koordinatlarını, dörtgenin genişliği ile uzunluğunu ve rengini belirledikten sonra <command>SDL_FillRect</command> işlevi ile ekrana istediğiniz koordinatta istediğiniz boyutlarda ve istediğiniz renkte bir dörtgen çiziliyor. Kod şöyle :
    </para><para>
<screen>Uint32 renk; // dörtgenimizin renk değeri
SDL_Rect dortgen;
dortgen.x = x; // dörtgeni ekran üzerinde yerleştireceğimiz x noktası
dortgen.y = y; // dörtgeni ekran üzerinde yerleştireceğimiz y noktası
dortgen.w = w; // dörtgenimizin genişliği
dortgen.h = h; // dörtgenimizin uzunluğu
SDL_FillRect (screen, &amp;dortgen, renk);
</screen>
    </para><para>
Oldukça kolay değil mi? Sanırım rengi nasıl belirttiğimizi merak ediyorsunuz. Yüzeylerin yapısını tanıtırken sadece <literal>pixels</literal> değişkeninin değiştirilebilir olduğu belirtilmişti. Bu değişkende yüzeyin beneklerinin renk bilgisi saklanmaktadır. Bu değişken dizisinin değerleri değiştirilebilir ve bu değişiklikler sayesinde ekrandaki beneklerin rengi değiştirilir. Bu işi yapan basit iki benek işlevi yazacağız. Biri seçtiğimiz yüzeye istediğimiz renkte bir benek yerleştirmeye diğeri de seçtiğimiz yüzeydeki istediğimiz beneğin renk değerini almamıza yarar.
    </para><example><title>Beneğin rengini öğrenmek</title><para>
<screen>Uint32
getpixel(SDL_Surface *surface, int x, int y)
{
  int bpp = surface->format->BytesPerPixel;

  /* p renk değerini almak istediğimiz beneğin adresi */
  Uint8 *p = (Uint8 *)surface->pixels + y * surface->pitch + x * bpp;

  switch(bpp)
  {
    case 1:
      return *p;
    case 2:
      return *(Uint16 *)p;
    case 3:
      if(SDL_BYTEORDER == SDL_BIG_ENDIAN)
        return p[0] &lt;&lt; 16 | p[1] &lt;&lt; 8 | p[2];
      else
        return p[0] | p[1] &lt;&lt; 8 | p[2] &lt;&lt; 16;
    case 4:
      return *(Uint32 *)p;
    default:
      return 0; /* Bu sonuç çıkmaz ama ne olur ne olmaz. */
  }
}
</screen>
    </para><para>
İşlevden dönen <literal>pixel</literal> dizisinde koordinatlar <literal>0,0</literal> koordinatından başlar ilk eleman ve her elemanda ilk olarak <literal>x</literal> değeri büyür. Bu büyüme benek başına düşen bit sayısıkadar olur. Benek başına 1 bit düşüyorsa her bit ayrı bir koordinattır. Ama 3 bit düşüyorsa 3 bitte bir koordinatlar bir ileri gider. <literal>x</literal>x koordinatı değeri sınıra ulaştığında sıfırlanır ve <literal>y</literal> değeri bir artar.
    </para><para>
<screen>Uint8 *p = (Uint8 *)surface->pixels + y * surface->pitch + x * bpp;</screen>
    </para><para>
Satırında yaptığımız işlemde <literal>x</literal> değerini <literal>bpp</literal> değişkeni ile çarpıyoruz. <literal>bpp</literal> değişkeni yüzeyin benek başına düşen byte sayısını saklıyor.
Yukarıda dizinin bir sonraki elemanı, koordinat sisteminde ki bir sonraki noktanın rengini saklar demiştik ama eğer yüzeyde benek başına düşen byte sayısı 1 ise bu doğrudur. Ama bazı durumlarda benek başına düşen byte sayısı 2 veya 3'e çıkabilir. Mesela RGB renk paleti kullanıldığında her koordinat için ilk byte kırmızı renk değeri, ikincisi yeşil ve üçüncüsü mavi renk değeridir. RGBA renk paletinde ise ilk üçü RGB değerleri, dördüncüsü ise alfa
değeridir. İşte bu yüzden <literal>x</literal> değerini <literal>bpp</literal> ile
çarptık. <literal>pitch</literal> değişkeninde ise yüzeyin bir satırının uzunluğu tutuluyor. <literal>y</literal> değeri için bir demek <literal>x</literal> koordinatının sınırından bir benek daha ileri gitmek demektir.
</para></example><example><title>Benek yerleştirme</title><para>
<screen>void
putpixel(SDL_Surface *surface, int x, int y, Uint32 pixel)
{
  int bpp = surface->format->BytesPerPixel;

  /* p yerleştirmek istediğimiz beneğin adresi */
  Uint8 *p = (Uint8 *)surface->pixels + y * surface->pitch + x * bpp;

  switch(bpp)
  {
    case 1:
      *p = pixel;
      break;
    case 2:
      *(Uint16 *)p = pixel;
      break;
    case 3:
      if(SDL_BYTEORDER == SDL_BIG_ENDIAN) {
        p[0] = (pixel >> 16) &amp; 0xff;
        p[1] = (pixel >> 8) &amp; 0xff;
        p[2] = pixel &amp; 0xff;
      } else {
        p[0] = pixel &amp; 0xff;
        p[1] = (pixel >> 8) &amp; 0xff;
        p[2] = (pixel >> 16) &amp; 0xff;
      }
      break;
    case 4:
    *(Uint32 *)p = pixel;
    break;
  }
}
</screen>
    </para><para>
<function>getpixel</function> işlevine oldukça benziyor. <function>getpixel</function> işlevinde hedef beneğin adresini bulup ordaki değerleri alıyorduk, burada ise yine hedef beneğinin adresini buluyoruz, ardından hedef beneğin değerlerini istediğimiz renk değeri ile değiştiriyoruz. Dikkat edilecek nokta ise renk değerini değiştirirken pixel başına düşen bit sayısına göre hesaplama yapıyoruz. Oldukça basit ama kullanışlı. Şimdi ise size ekran tazeleme işlevlerini anlatacağım.
    </para></sect2><sect2><title>Ekranın tazelenmesi</title><para>
2D çizgesel geliştirmede ekrana çizdireceğimiz görüntüleri önce çizdirmek sonra ekranı tazelemek ve sonra tekrar çizdirmek gerekir. Tazelemezsek ne olacağını basit bir örnek ile
açıklayayım. Diyelim ki arkaplanda tam ekran çalışmakta olan bir penceredeki uygulamanız dondu. Onun önündeki daha küçük bir pencerede çalışan uygulamanızın penceresini yana taşırsanır
fark edeceğiniz üzere küçük pencerenin bulunduğu yerde görüntüsü (en azından görüntüsünün bir kısmı) hala durmakta. İşte ekrana çizim yaptıktan sonra ekranı tazelemezsek bu veya buna benzer bir sonuç alırız.
    </para><para>
Peki ekranı nasıl tazeleyeceğiz? Bunun iki yolu bulunmakta. Birincisi
<command>SDL_UpdateRect</command> işlevi ile.
    </para><para>
<screen>SDL_UpdateRect(screen, 0, 0, image->w, image->h);</screen>
    </para><para>
Burada işleve, ekrandaki görüntüyü sakladığımız <literal>screen</literal> yüzeyinin <literal>0,0</literal> koordinatından ekrana çizdireceğimiz <literal>image</literal> yüzeyinin genişliği ve yüksekliği boyunca uzanan alanı tazele diyoruz. Bunun yerine bütün çizim işlemini bitirince ekranın tamamını tazeleyecek bir <command>SDL_UpdateRect</command> işlevi daha kullanışlı olabilir. Şöyle ki:
    </para><para>
<screen>SDL_UpdateRect(screen, 0, 0, 0, 0);</screen>
    </para><para>
Ekranı tazelemek için kullanabileceğimiz bir diğer yöntem ise <command>SDL_Flip</command> işlevidir. Bu işlev sadece çizgesel kip seçilirken çifte tamponlama sabiti (<literal>SDL_DOUBLEBUF</literal>) seçilmiş ise kullanılabilir. Çünkü bu işlev tamponların değişmesini sağlamak yolu ile ekranı tazeler. Eğer çifte tamponlama özelliğini kullanamıyorsanız bu işlev yerine yukarıdaki bütün ekranı tazeleyen <command>SDL_UpdateRect(screen,0,0,0,0);</command> işlevini kullanın. Ama imkanınız varsa <command>SDL_Flip</command>'i kullanmaya gayret edin. Kullanımı:
    </para><para>
<screen>SDL_Flip(screen);</screen>
    </para><para>
Bunun dışında bir de <command>SDL_UpdateRect</command> işlevinin <command>SDL_UpdateRects</command> adında birden fazla dörtgeni aynı anda tazeleyen farklı bir sürümü de bulunmaktadır. Bu işlevin kullanımı ise şöyledir:
    </para><para>
<screen>SDL_UpdateRects(screen, dortgensayisi, *dortgenler);</screen>
    </para></example></para></sect2>
    <sect2><title>Yüzeylerin kilitlenme gereksinimi</title><para>
Bu arada bu benek işlevlerini kullanırken veya bir yüzeyin benek verilerine doğrudan ulaşırken ilk olarak üzerinde çalışacağınız yüzeyi kilitlemelisiniz. Açıkcası dalgınlık ve
merak ile kilitlemeden de çalıştırdığım oldu. Bunun nedeni ise bütün yüzeylerin kilitlenmeye ihtiyacı olmamasıdır.  Neden diye sormayın bilmiyorum. Ama öyle. Peki bunu nasıl anlayacaksınız? <command>SDL_MUSTLOCK</command> işlevi ile. En iyisi size bunu yapan bir kod ile açıklamak.
    </para><para>
<screen>if ( SDL_MUSTLOCK(screen) ) {
  if ( SDL_LockSurface(screen) ) {
    fprintf(stderr, "Yüzey kilitlenemiyor: %s\n", SDL_GetError());
    return;
  }
}
</screen>
    </para><para>
Burada ilk olarak <literal>screen</literal> yüzeyini <command>SDL_MUSTLOCK</command> işlevi ile sınar ve kilitleme gerekip gerekmediğine bakarız. 0 değeri dönerse istediğiniz zaman
istediğiniz beneğe veri yazabilir, istediğiniz benekten veri okuyabilirsiniz. Ama 0 değeri dönmezse bu yüzeyi kilitlemeniz gerekir. Böyle olunca da <command>SDL_LockSurface</command> işlevi devreye girer ve parametre olarak girilen yüzey kilitlenir ama bir sorun olurda kilitlenemezse <command>fprintf</command> işlevi
ile <command>stderr</command> dosyasına "Yüzey kilitlenemiyor: Hata iletisi" şeklinde bir hata bildirimi yazdırırız.
    </para><para>
Bu arada SDL 1.1.8'den beri yüzey kilitlemesi ardarda yapılabilmektedir. Yani bir yüzeye istediğiniz kadar çok kilit atabilirsiniz ama bu gibi durumlarda da attığınız her kilidi tek tek açmanız gerekir.
    </para><para>
Peki kilitlenen yüzeyi nasıl açacağız? <command>SDL_UnLockSurface</command> işlevi ile.
Kullanımı şöyledir:
    </para><para>
<screen>SDL_UnlockSurface(screen);</screen>
    </para><para>
Ama <command>SDL_MUSTLOCK</command> işlevi ile beraber kullanmak istiyorsanız - ki
tavsiye ederim - şöyle olacak:
    </para><para>
<screen>if ( SDL_MUSTLOCK(screen) ) {
  SDL_UnlockSurface(screen);
}
</screen>
    </para><para>
Bu kadar basit.İlk ders için bu kadarı yeterli. Bu noktaya kadar anlattıklarım ile SDL yazılımları geliştirmeye başlayabilirsiniz.
    </para>
  </sect1>
  <sect1><title>SDL ve Çizgeler - Bölüm II</title>
Hala çizge konusundayız ama temel konularda fazla birşey kalmadı. Sadece birkaç çizge işlevi ve birkaç yardımcı işlevi anlatacağım. Ardından Olaylara geçeceğiz. İlk olarak <command>SDL_MapRGB</command> işlevinden bahsedeceğim. Bu işlev girdiğiniz parametreler ile RGB cinsinden belirttiğiniz renk değerini <command>Uint32</command> türünde bir değişkene atar. Bu işlevin bir de <command>SDL_MapRGBA</command> sürümü bulunmaktadır. Kullanımı aynıdır. Tek fark RGBA değerini girmeniz gerekir. Kullanımları;
    </para><para>
<screen>Uint32 renk;
renk = SDL_MapRGB (surface->format, kirmizi, yesil, mavi);

Uint32 renk;
renk = SDL_MapRGB (surface->format, kirmizi, yesil, mavi, alfa);
</screen>
    </para><para>
<varname>surface</varname> olarak renk paletini kullanacağınız bir yüzeyi ya da en basiti
ekrana çizdirdiğiniz yüzeyi kullanın. Renk değeri olarak seçtiğiniz değer yüzeyin benek biçiminde belirtilen palet değerlerine göre belirlenir. <command>SDL_PixelFormat</command> yüzeylerin benek verilerinin biçiminin saklandığı veri yapısıdır.
    </para><para><command>SDL_PixelFormat</command> yapısının tanımı</para><para>
<funcsynopsis><funcprototype role="veri türü">
<paramdef>typedef struct{
  SDL_Palette *<literal>palette</literal>;
  Uint8        <literal>BitsPerPixel</literal>;
  Uint8        <literal>BytesPerPixel</literal>;
  Uint32       <literal>Rmask, Gmask, Bmask, Amask</literal>;
  Uint8        <literal>Rshift, Gshift, Bshift, Ashift</literal>;
  Uint8        <literal>Rloss, Gloss, Bloss, Aloss</literal>;
  Uint32       <literal>colorkey</literal>;
  Uint8        <literal>alpha</literal>;
} <command>SDL_PixelFormat</command>;
</paramdef>
</funcprototype><funcdescr><para>
  <glosslist><glossentry>
  <glossterm><literal>palette</literal></glossterm><glossdef><para>
Renk paletine gösterici; <literal>BitsPerPixel > 8</literal> ise boş göstericidir.
  </para></glossdef></glossentry><glossentry>
  <glossterm><literal>BitsPerPixel</literal></glossterm><glossdef><para>
Yüzeydeki her beneğin bit sayısı (8, 16, 24, 32)
  </para></glossdef></glossentry><glossentry>
  <glossterm><literal>[RGBA]mask</literal></glossterm><glossdef><para>
Her renk elemanının tek başına renk değerlerini getirmek için kullanılan maske değeri
  </para></glossdef></glossentry><glossentry>
  <glossterm><literal>[RGBA]shift</literal></glossterm><glossdef><para>
Benek değerindeki her renk elemanının ikil sola kaydırma değeri
  </para></glossdef></glossentry><glossentry>
  <glossterm><literal>[RGBA]loss</literal></glossterm><glossdef><para>
Her renk elemanındaki hassasiyet kaybı (2<subscript>[RGBA]loss</subscript>)
  </para></glossdef></glossentry><glossentry>
  <glossterm><literal>colorkey</literal></glossterm><glossdef><para>
Şeffaf beneklerin benek değeri
  </para></glossdef></glossentry><glossentry>
  <glossterm><literal>alpha</literal></glossterm><glossdef><para>
bütün yüzeyin alfa değeri
   </para></glossdef></glossentry></glosslist>
</para></funcsynopsis>
    </para><para>
Benek biçiminin içeriğinde <literal>colorkey</literal> adlı alan uyduğunu ve şeffaf bir
renk sağladığını gördük. Ama bunu nasıl yapabileceğinizi anlatmadım. Şimdi anlatacağım. Bunun yolu <command>SDL_SetColorKey</command> işlevinden geçmekte.
    </para><para>
<funcsynopsis><funcprototype role="işlev">
<funcdef>int <command>SDL_SetColorKey</command></funcdef>
<paramdef>(SDL_Surface *<varname>yuzey</varname>,
 Uint32       <varname>secenek</varname>,
 Uint32       <varname>anahtar</varname>)</paramdef>
</funcprototype><funcdescr><para>
Örnek kullanım:
    </para><para>
<screen>SDL_SetColorKey(yuzey, SDL_SRCCOLORKEY, SDL_MapRGB(yuzey->format, r, g, b));</screen>
    </para><para>
Örnekte de gördüğünüz gibi ilk olarak renk anahtarı belirlemek istediğimiz yüzeyi, ardından da işlem seçeneğini giriyoruz, en son olarakta şeffaf olmasını istediğimiz rengi giriyoruz. Seçenek olarak, <literal>SDL_SRCCOLORKEY</literal> değerini vererek belirttiğimiz rengin, belirttiğimiz yüzeyde şeffaf olmasını sağlıyoruz. Daha önce belirlenmiş bir renk anahtarını kaldırmak için seçenek olarak 0 değerini vermeniz yeterli.
</para></funcdescr></funcsynopsis></para><para>
Grafik konusunda bahsedeceğim son işlev <command>SDL_DisplayFormat</command>.
    </para><para>
<funcsynopsis><funcprototype role="işlev">
<funcdef>SDL_Surface *<command>SDL_DisplayFormat</command></funcdef>
<paramdef>(SDL_Surface *<varname>yuzey</varname>)</paramdef>
</funcprototype><funcdescr><para>
Bir yüzeyin biçimini ekran biçimine dönüştürür. Bu işlev en basit hali ile uyguladığınız yüzeyin bitlerinin kopyalama ve aynı zamanda çizdirme (sonuçta çizdirirken yaptığınız iş çizimi ekran yüzeyine kopyalamak olduğu için aynı şey oluyor) hızını arttırmaya yarıyor.
    </para><para>
Örnek kullanım:
    </para><para>
<screen>yeni_hizlandirilmis_yuzey = SDL_DisplayFormat(eskiyuzey);</screen>
    </para><para>
Bu işlevin yaptığı şey yüzeyin benek verisini RLE hızlandırma kodlaması ile kodlamaktır.
    </para>
  </sect1>
  <sect1><title>SDL ile OpenGL Kullanımı</title><para>
SDL, OpenGL bağlamını çeşitli platfomlarda (Linux/X11, Win32, BeOS, MacOS Classic/Toolbox, MacOS X, FreeBSD/X11 and Solaris/X11) oluşturma ve kullanma yeteneğine sahiptir. Böylece, OpenGL uygulamalarınızda SDL'nin ses ve olay yakalama, çok evrelilik ve zamanlama özelliklerini kullanmanızı mümkün kılar.
    </para>
    <sect2><title>İlklendirme</title><para>
OpenGL kullanımında SDL ilklendirmesi, SDL'nin normal ilklendirmesinden çok farklı değildir. Üç fark vardır; <command>SDL_SetVideoMode</command> işlevine <literal>SDL_OPENGL</literal> aktarmalı, çeşitli GL özniteliklerini <command>SDL_GL_SetAttribute</command> işlevini kullanarak belirtmeli ve son olarak, eğer çifte tamponlama kullanmak isterseniz, <command>SDL_SetVideoMode</command> işlevini <literal>SDL_DOUBLEBUF</literal> sabiti ile çağırmak yerine, onu bir GL özniteliği olarak belirtmelisiniz.
      </para><example><title>SDL'nin OpenGL ile ilklendirilmesi</title>
<screen>/* Geçerli çizgesel ayarlar hakkındaki bilgiler. */
const SDL_VideoInfo* info = NULL;
/* Penceremizin boyutları. */
int width = 0;
int height = 0;
/* Penceremizin bit cinsinden renk derinliği. */
int bpp = 0;
/* SDL_SetVideoMode'a aktaracağımız seçenekler. */
int flags = 0;

/* Önce, SDL'nin çizgesel altsistemini ilklendirelim. */
if( SDL_Init( SDL_INIT_VIDEO ) &lt; 0 ) {
    /* Olmadı, çık. */
    fprintf( stderr, "çizgesel altsistem ilklendirilemedi: %s\n",
          SDL_GetError( ) );
    bitir();
}

/* Çizgesel altsisteme ilişkin bilgileri alalım. */
info = SDL_GetVideoInfo( );

if( !info ) {
    /* Muhtemelen bu hiç olmayacak. */
    fprintf( stderr, "Çizgesel altsistem sorgulaması başarısız oldu: %s\n",
          SDL_GetError( ) );
    bitir();
}

/*
  * Genişlik ve yüksekliği 640'a 480 yapalım (muhtemelen
  * siz buna kullanıcının karar vermesini isterdiniz).
  * Ekranın bpp değerini alalım. X11 üzerinde VidMode
  * çözünürlüğü değiştiremez, dolayısıyla bu değer
  * epeyce güvenilir olacaktır. Win32'de ise
  * ChangeDisplaySettings bpp'yi değiştirebilir.
  */
width = 640;
height = 480;
bpp = info->vfmt->BitsPerPixel;

/*
  * Şimdi, OpenGL penceremiz için istediğimiz
  * pencere özniteliklerini ayarlayacağız.
  * Kırmızı, yeşil ve mavinin en azından 5 bitlik
  * olmasını istiyoruz. Ayrıca, en azından 16
  * bitlik de bir derinlik tamponu istiyoruz.
  *
  * İsteyeceğimiz son şey, bir çifte tamponlu
  * pencere. Çifte tamponlamanın etkin olması için '1',
  * aksi takdirde '0' belirtilmeli.
  *
  * SDL_SetVideoMode işlevinde SDL_DOUBLEBUF
  * seçeneğini kullanmayacağız, çünkü GL özniteliklerinin
  * durumlarına bir etkisi olmaz, sadece standart
  * 2D bit bloklarının aktarımlarında etkisi olur.
  */
SDL_GL_SetAttribute( SDL_GL_RED_SIZE, 5 );
SDL_GL_SetAttribute( SDL_GL_GREEN_SIZE, 5 );
SDL_GL_SetAttribute( SDL_GL_BLUE_SIZE, 5 );
SDL_GL_SetAttribute( SDL_GL_DEPTH_SIZE, 16 );
SDL_GL_SetAttribute( SDL_GL_DOUBLEBUFFER, 1 );

/*
  * SDL'nin bize tam ekran çizgesel kipte bir
  * OpenGL pencere sağlamasını istiyoruz.
  *
  * ALIŞTIRMA:
  * Başlangıcı bir seçenek olarak pencereli olarak yapın
  * ve boyutlandırma olaylarını glViewport ile olması
  * gerektiği gibi yakalayın.
  */
flags = SDL_OPENGL | SDL_FULLSCREEN;

 /*
  * Çizgesel kipi etkinleştirelim.
  */
if( SDL_SetVideoMode( width, height, bpp, flags ) == 0 ) {
    /*
      * Bu çeşitli sebeplerle ortaya çıkabilir;
      * DISPLAY etkin olmayabilir, belirtilen
      * çözünürlük kullanılabilir olmayabilir, vs.
      */
    fprintf( stderr, "Çizgesel kip etkinleştirilemedi: %s\n",
          SDL_GetError( ) );
    quit_tutorial( 1 );
}
</screen>
      </example>
    </sect2><sect2><title>Çizim</title><para>
İlklendirme dışında, OpenGL'in SDL içinde kullanımı, OpenGL'in GLUT gibi diğer arayüzlerle birlikte kullanımıyla aynıdır. Hala aynı işlev çağrılarını ve veri türlerini kullanabilirsiniz. Ancak, eğer ekranı çifte tamponlu kullanıyorsanız, tamponları takaslamak ve ekranı güncellemek için <command>SDL_GL_SwapBuffers()</command> işlevini kullanmalısınız. Çifte tamponlamayı OpenGL ile yapmak isterseniz, <command>SDL_GL_SetAttribute</command> işlevini <literal>SDL_GL_DOUBLEBUFFER</literal> ile kullanmalı ve <command>SDL_GL_GetAttribute</command> ile bunun gerçekleşip gerçekleşmediğini sınamalısınız.
      </para><para>
Eksiksiz bir örnek artık mevcut:
      </para><example><title>SDL ve OpenGL</title><para>
<screen>
/*
 * SDL OpenGL Eğitmeni.
 * (c) Michael Vance, 2000
 * briareos@lokigames.com
 *
 * LGPL koşulları altında dağıtılmaktadır.
 */

#include &lt;SDL/SDL.h>
#include &lt;GL/gl.h>
#include &lt;GL/glu.h>

#include &lt;stdio.h>
#include &lt;stdlib.h>

static GLboolean should_rotate = GL_TRUE;

static void quit_tutorial( int code )
{
    /*
     * SDL'den çıkış; tam ekran kipini bırakıp,
     * ekranı, vesaireyi önceki ayarlarına getirip
     * çıkıyoruz.
     */
    SDL_Quit( );

    /* Süreci de sonlandıralım. */
    exit( code );
}

static void handle_key_down( SDL_keysym* keysym )
{

    /*
     * Sadece 'Esc' tuşuna basılması ile ilgileniyoruz.
     *
     * ALIŞTIRMA:
     * Ok tuşlarını yakalayarak görünümün konumunu
     * ve açısını değiştirmeyi deneyin.
     */
    switch( keysym->sym ) {
    case SDLK_ESCAPE:
        quit_tutorial( 0 );
        break;
    case SDLK_SPACE:
        should_rotate = !should_rotate;
        break;
    default:
        break;
    }
}

static void process_events( void )
{
    /* SDL olayları için yertutucu. */
    SDL_Event event;

    /* Kuyruktaki tüm olaylara elkoyalım. */
    while( SDL_PollEvent( &amp;event ) ) {

        switch( event.type ) {
        case SDL_KEYDOWN:
            /* Tuşları yakalayalım. */
            handle_key_down( &amp;event.key.keysym );
            break;
        case SDL_QUIT:
            /* Çıkış isteklerini yakalayalım (mesela Ctrl-c). */
            quit_tutorial( 0 );
            break;
        }
    }
}

static void draw_screen( void )
{
    /* Döndürme açımız. */
    static float angle = 0.0f;

    /*
     * ALIŞTIRMA:
     * Buradaki herşeyi vertex dizileri ile
     * değiştirip bir glDrawElements çağrısı yapın.
     *
     * ALIŞTIRMA:
     * Üsttekini tamamladıktan sonra, kodu derlenmiş
     * vertex dizilerini kullanacak şekilde değiştirin.
     *
     * ALIŞTIRMA:
     * Benim burada yaptıklarımı doğrulayın ;).
     */
    static GLfloat v0[] = { -1.0f, -1.0f,  1.0f };
    static GLfloat v1[] = {  1.0f, -1.0f,  1.0f };
    static GLfloat v2[] = {  1.0f,  1.0f,  1.0f };
    static GLfloat v3[] = { -1.0f,  1.0f,  1.0f };
    static GLfloat v4[] = { -1.0f, -1.0f, -1.0f };
    static GLfloat v5[] = {  1.0f, -1.0f, -1.0f };
    static GLfloat v6[] = {  1.0f,  1.0f, -1.0f };
    static GLfloat v7[] = { -1.0f,  1.0f, -1.0f };
    static GLubyte red[]    = { 255,   0,   0, 255 };
    static GLubyte green[]  = {   0, 255,   0, 255 };
    static GLubyte blue[]   = {   0,   0, 255, 255 };
    static GLubyte white[]  = { 255, 255, 255, 255 };
    static GLubyte yellow[] = {   0, 255, 255, 255 };
    static GLubyte black[]  = {   0,   0,   0, 255 };
    static GLubyte orange[] = { 255, 255,   0, 255 };
    static GLubyte purple[] = { 255,   0, 255,   0 };

    /* Renk ve derinlik tamponlarını temizleyelim. */
    glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );

    /* Projeksiyon matrisini değiştirmek istemiyoruz. */
    glMatrixMode( GL_MODELVIEW );
    glLoadIdentity( );

    /* z eksenini aşağı taşıyalım. */
    glTranslatef( 0.0, 0.0, -5.0 );

    /* Döndürelim. */
    glRotatef( angle, 0.0, 1.0, 0.0 );

    if( should_rotate ) {

        if( ++angle > 360.0f ) {
            angle = 0.0f;
        }

    }

    /* Üçgen verimizi boruhattına yollayalım. */
    glBegin( GL_TRIANGLES );

    glColor4ubv( red );
    glVertex3fv( v0 );
    glColor4ubv( green );
    glVertex3fv( v1 );
    glColor4ubv( blue );
    glVertex3fv( v2 );

    glColor4ubv( red );
    glVertex3fv( v0 );
    glColor4ubv( blue );
    glVertex3fv( v2 );
    glColor4ubv( white );
    glVertex3fv( v3 );

    glColor4ubv( green );
    glVertex3fv( v1 );
    glColor4ubv( black );
    glVertex3fv( v5 );
    glColor4ubv( orange );
    glVertex3fv( v6 );

    glColor4ubv( green );
    glVertex3fv( v1 );
    glColor4ubv( orange );
    glVertex3fv( v6 );
    glColor4ubv( blue );
    glVertex3fv( v2 );

    glColor4ubv( black );
    glVertex3fv( v5 );
    glColor4ubv( yellow );
    glVertex3fv( v4 );
    glColor4ubv( purple );
    glVertex3fv( v7 );

    glColor4ubv( black );
    glVertex3fv( v5 );
    glColor4ubv( purple );
    glVertex3fv( v7 );
    glColor4ubv( orange );
    glVertex3fv( v6 );

    glColor4ubv( yellow );
    glVertex3fv( v4 );
    glColor4ubv( red );
    glVertex3fv( v0 );
    glColor4ubv( white );
    glVertex3fv( v3 );

    glColor4ubv( yellow );
    glVertex3fv( v4 );
    glColor4ubv( white );
    glVertex3fv( v3 );
    glColor4ubv( purple );
    glVertex3fv( v7 );

    glColor4ubv( white );
    glVertex3fv( v3 );
    glColor4ubv( blue );
    glVertex3fv( v2 );
    glColor4ubv( orange );
    glVertex3fv( v6 );

    glColor4ubv( white );
    glVertex3fv( v3 );
    glColor4ubv( orange );
    glVertex3fv( v6 );
    glColor4ubv( purple );
    glVertex3fv( v7 );

    glColor4ubv( green );
    glVertex3fv( v1 );
    glColor4ubv( red );
    glVertex3fv( v0 );
    glColor4ubv( yellow );
    glVertex3fv( v4 );

    glColor4ubv( green );
    glVertex3fv( v1 );
    glColor4ubv( yellow );
    glVertex3fv( v4 );
    glColor4ubv( black );
    glVertex3fv( v5 );

    glEnd( );

    /*
     * ALIŞTIRMA:
     * Kullanıcının 'Spc' tuşladığında döndürme işleminin
     * bekletileceğini, 'Esc' tuşladığında ise uygulamadan
     * çıkılacağını belirten metni çizdirin.
     * Do it using vectors and textured quads.
     */

    /*
     * Tamponları takaslayalım. Bu, sürücüye, sonraki çerçeveyi
     * arka tamponun içeriğinden çizmesini ve bu işlemleri
     * ön tamponda oluyor gibi belirlemesini söyler.
     *
     * Çifte tamponlama, uygulamanın ekran alanlarını
     * aynı anda güncellemesi sırasında olabilecek
     * tehlikeli sanal yırtılmaları önler.
     */
    SDL_GL_SwapBuffers( );
}

static void setup_opengl( int width, int height )
{
    float ratio = (float) width / (float) height;

    /* Gölgeleme modelimiz--Gouraud (yumuşak). */
    glShadeModel( GL_SMOOTH );

    /* Seçmece. */
    glCullFace( GL_BACK );
    glFrontFace( GL_CCW );
    glEnable( GL_CULL_FACE );

    /* Silme rengini belirleyelim. */
    glClearColor( 0, 0, 0, 0 );

    /* Çizim alanımızı ayarlayalım. */
    glViewport( 0, 0, width, height );

    /*
     * Projeksiyon matrisine geçelim ve
     * görünüm alanımızı ayarlayalım.
     */
    glMatrixMode( GL_PROJECTION );
    glLoadIdentity( );
    /*
     * ALIŞTIRMA:
     * Bunu glFrustum çağrısı ile değiştirin.
     */
    gluPerspective( 60.0, ratio, 1.0, 1024.0 );
}

int main( int argc, char* argv[] )
{
    /* Mevcut çizgesel ayarlar hakkında bilgi. */
    const SDL_VideoInfo* info = NULL;
    /* Penceremizin bayutları. */
    int width = 0;
    int height = 0;
    /* Penceremizin bit cinsinden renk derinliği. */
    int bpp = 0;
    /* SDL_SetVideoMode işlevine aktaracağımız seçenekler. */
    int flags = 0;

    /* Önce SDL'nin çizgesel alt sistemini ilklendirelim. */
    if( SDL_Init( SDL_INIT_VIDEO ) < 0 ) {
        /* Olmadı, çık. */
        fprintf( stderr, "Çizgesel alt sistem ilklendirilemedi: %s\n",
             SDL_GetError( ) );
        quit_tutorial( 1 );
    }

    /* Çizgesel alt sistem ile ilgili bilgileri alalım. */
    info = SDL_GetVideoInfo( );

    if( !info ) {
        /* Muhtemelen bu hiç olmayacak.. */
        fprintf( stderr, "Çizgesel alt sistem sorgusu başarısız oldu: %s\n",
             SDL_GetError( ) );
        quit_tutorial( 1 );
    }

    /*
     * Genişlik ve yüksekliği 640'a 480 yapalım (muhtemelen
     * siz buna kullanıcının karar vermesini isterdiniz).
     * Ekranın bpp değerini alalım. X11 üzerinde VidMode
     * çözünürlüğü değiştiremez, dolayısıyla bu değer
     * epeyce güvenilir olacaktır. Win32'de ise
     * ChangeDisplaySettings bpp'yi değiştirebilir.
     */
    width = 640;
    height = 480;
    bpp = info->vfmt->BitsPerPixel;

    /*
     * Şimdi, OpenGL penceremiz için istediğimiz
     * pencere özniteliklerini ayarlayacağız.
     * Kırmızı, yeşil ve mavinin en azından 5 bitlik
     * olmasını istiyoruz. Ayrıca, en azından 16
     * bitlik de bir derinlik tamponu istiyoruz.
     *
     * İsteyeceğimiz son şey, bir çifte tamponlu
     * pencere. Çifte tamponlamanın etkin olması için '1',
     * aksi takdirde '0' belirtilmeli.
     *
     * SDL_SetVideoMode işlevinde SDL_DOUBLEBUF
     * seçeneğini kullanmayacağız, çünkü GL özniteliklerinin
     * durumlarına bir etkisi olmaz, sadece standart
     * 2D bit bloklarının aktarımlarında etkisi olur.
     */
    SDL_GL_SetAttribute( SDL_GL_RED_SIZE, 5 );
    SDL_GL_SetAttribute( SDL_GL_GREEN_SIZE, 5 );
    SDL_GL_SetAttribute( SDL_GL_BLUE_SIZE, 5 );
    SDL_GL_SetAttribute( SDL_GL_DEPTH_SIZE, 16 );
    SDL_GL_SetAttribute( SDL_GL_DOUBLEBUFFER, 1 );

    /*
     * SDL'nin bize tam ekran çizgesel kipte bir
     * OpenGL pencere sağlamasını istiyoruz.
     *
     * ALIŞTIRMA:
     * Başlangıcı bir seçenek olarak pencereli olarak yapın
     * ve boyutlandırma olaylarını glViewport ile olması
     * gerektiği gibi yakalayın.
     */
    flags = SDL_OPENGL | SDL_FULLSCREEN;

    /*
     * Çizgesel kipi etkinleştirelim.
     */
    if( SDL_SetVideoMode( width, height, bpp, flags ) == 0 ) {
        /*
         * Bu çeşitli sebeplerle ortaya çıkabilir;
         * DISPLAY etkin olmayabilir, belirtilen
         * çözünürlük kullanılabilir olmayabilir, vs.
         */
        fprintf( stderr, "Çizgesel kip etkinleştirilemedi: %s\n",
             SDL_GetError( ) );
        quit_tutorial( 1 );
    }

    /*
     * Bu noktada, çifte tamponlu penceremizi OpenGL
     * ile kullanmak için düzgün olarak ayarlamalıyız.
     */
    setup_opengl( width, height );

    /*
     * Artık normal uygulama işlemlerini başlatabiliriz;
     * yeniden çizdirmeli bir olay döngüsü.
     */
    while( 1 ) {
        /* Gelen olayları işleme sokalım. */
        process_events( );
        /* Ekrana çizdirelim. */
        draw_screen( );
    }

    /*
     * ALIŞTIRMA:
     * Zamanlamayı SDL_GetTicks() kullanarak kaydedin ve
     * uygulamadan çıkışta saniyedeki çerçeve sayısını basın.
     */

    /* Buraya hiç gelinmeyecek. */
    return 0;
}
</screen>
      </para>
    </sect2>
  <sect1><title>SDL ve Olaylar (Events)</title><para>
SDL'de olay yakalama işlemleri için her tür olaya ait bir yapıyı içerisinde bulunduran bir olay yapısı bulunmaktadır. Oluşan olaylar bir kuyruğa atılır ve bu kuyruktan <command>SDL_PollEvent</command> işlevi yardımı ile çekilir. Kuyruktan alınan bilgide <command>SDL_Event</command> yapısı içerisinde olayın türü ve olay hakkında bilinmesi gereken diğer bilgiler bulunur. Örnek bir kod;
    </para><para>
<screen>SDL_Event olay;


while (SDL_PollEvent(&amp;olay)) {
  switch (olay.type){
    case SDL_KEYDOWN:
    /* tuşa basıldı durumu */
    break;
  }
}
</screen>
    </para><para>
Yukarıda SDL içerisinde olay yakalama ve işlemeyi gösteren basit bir örnek var. Bu örneği <command>SDL_Event</command> yapısının içeriğinde bulunan diğer türler yardımı ile geliştirebilirsiniz. Aşağıda <command>SDL_Event</command> birleşik yapısının ve bu yapının içinde bulunan diğer alt yapıların tanımlarını bulacaksınız.
    </para><para>
<command>SDL_Event</command> birleşik yapısının tanımı:
    </para><para>
<funcsynopsis><funcprototype role="veri türü">
<paramdef>typedef union{
  Uint8                <literal>type</literal>;
  SDL_ActiveEvent      <literal>active</literal>;
  SDL_KeyboardEvent    <literal>key</literal>;
  SDL_MouseMotionEvent <literal>motion</literal>;
  SDL_MouseButtonEvent <literal>button</literal>;
  SDL_JoyAxisEvent     <literal>jaxis</literal>;
  SDL_JoyBallEvent     <literal>jball</literal>;
  SDL_JoyHatEvent      <literal>jhat</literal>;
  SDL_JoyButtonEvent   <literal>jbutton</literal>;
  SDL_ResizeEvent      <literal>resize</literal>;
  SDL_QuitEvent        <literal>quit</literal>;
  SDL_UserEvent        <literal>user</literal>;
  SDL_SywWMEvent       <literal>syswm</literal>;
} <command>SDL_Event</command>;
</paramdef></funcprototype></funcsynopsis>
    </para><para>
Yapı üyelerinin açıklamaları:
    </para><para>
<literallayout><command>type</command>    Olayın türü
<command>active</command>  Etkinleşme olayları
<command>key</command>     Klavye olayları
<command>motion</command>  Fare hareket olayları
<command>button</command>  Fare düğmesi olayları
<command>jaxis</command>   Oyun çubuğu eksenel hareket olayları
<command>jball</command>   Oyun çubuğu topunun hareket olayları
<command>jhat</command>    Oyun çubuğu kepinin hareket olayları
<command>jbutton</command> Oyun çubuğu düğmesi olayları
<command>resize</command>  Uygulama penceresi boyut değiştirme olayları
<command>quit</command>    Uygulamadan çıkış isteği olayları
<command>user</command>    Kullanıcı tanımlı olaylar
<command>syswm</command>   Tanımsız pencere yöneticisi olayları
</literallayout>
    </para><para>
<command>SDL_Event</command>, SDL'de kullanılan tüm olay yapılarının bir birleşimidir (union). Hangi üyenin hangi olay türü ile ilişkili olduğu bilindiği takdirde kullanımı basittir:
    </para><para>
<table frame="none" style=";background:#999999;">
<tgroup cols='2'>
<tbody><row style="background:#ffffee;">
<entry>Olay Türü</entry><entry>Olay Yapısı</entry>
</row><row style="background:#ffffee;">
<entry><literal>SDL_ACTIVEEVENT</literal></entry>
<entry><command>SDL_ActiveEvent</command></entry>
</row><row style="background:#ffffee;">
<entry><literal>SDL_KEYDOWN/UP</literal></entry>
<entry><command>SDL_KeyboardEvent</command></entry>
</row><row style="background:#ffffee;">
<entry><literal>SDL_MOUSEMOTION</literal></entry>
<entry><command>SDL_MouseMotionEvent</command></entry>
</row><row style="background:#ffffee;">
<entry><literal>SDL_MOUSEBUTTONDOWN/UP</literal></entry>
<entry><command>SDL_MouseButtonEvent</command></entry>
</row><row style="background:#ffffee;">
<entry><literal>SDL_JOYAXISMOTION</literal></entry>
<entry><command>SDL_JoyAxisEvent</command></entry>
</row><row style="background:#ffffee;">
<entry><literal>SDL_JOYBALLMOTION</literal></entry>
<entry><command>SDL_JoyBallEvent</command></entry>
</row><row style="background:#ffffee;">
<entry><literal>SDL_JOYHATMOTION</literal></entry>
<entry><command>SDL_JoyHatEvent</command></entry>
</row><row style="background:#ffffee;">
<entry><literal>SDL_JOYBUTTONDOWN/UP</literal></entry>
<entry><command>SDL_JoyButtonEvent</command></entry>
</row><row style="background:#ffffee;">
<entry><literal>SDL_QUIT</literal></entry>
<entry><command>SDL_QuitEvent</command></entry>
</row><row style="background:#ffffee;">
<entry><literal>SDL_SYSWMEVENT</literal></entry>
<entry><command>SDL_SysWMEvent</command></entry>
</row><row style="background:#ffffee;">
<entry><literal>SDL_VIDEORESIZE</literal></entry>
<entry><command>SDL_ResizeEvent</command></entry>
</row><row style="background:#ffffee;">
<entry><literal>SDL_VIDEOEXPOSE</literal></entry>
<entry><command>SDL_ExposeEvent</command></entry>
</row><row style="background:#ffffee;">
<entry><literal>SDL_USEREVENT</literal></entry>
<entry><command>SDL_UserEvent</command></entry>
</row></tbody></tgroup></table>
    </para><para>
SDL'i kullanmaktaki -en azından bu belgede - asıl amacımız oyun yapımı olduğu için burada sadece oyun yapımında en çok ihtiyaç duyacağınız olay yapılarının ayrıntılarını vereceğim, diğerleri için SDL Kütüphanesi ile dağıtılan belgeye başvurmalısınız. İlk olarak klavye olaylarından bahsedelim.
    </para><para>
<command>SDL_KeyboardEvent</command> yapısının tanımı:
    </para><para>
<funcsynopsis><funcprototype role="veri türü">
<paramdef>typedef struct{
  Uint8      <literal>type</literal>;
  Uint8      <literal>state</literal>;
  SDL_keysym <literal>keysym</literal>;
} <command>SDL_KeyboardEvent</command>;
</paramdef></funcprototype></funcsynopsis>
    </para><para>
Yapı üyelerinin açıklamaları:
    </para><para>
<literallayout><command>type</command>      SDL_KEYDOWN veya SDL_KEYUP
<command>state</command>     SDL_PRESSED veya SDL_RELEASED
<command>keysym</command>    basılan tuşun bilgisini içerir
</literallayout>
    </para><para>
Burda gördüğünüz üzere iki tür olay bulunmakta,  tuşun basılması ve
kaldırılması. <command>SDL_KEYDOWN</command> ve <command>SDL_PRESSED</command> bir tuşa basıldığını, <command>SDL_KEYUP</command> ve <command>SDL_RELEASED</command> ise bir tuşun bırakıldığını belirtir. Bu ikisi arasında fark yoktur. Sadece farklı değişkenler tarafından belirtiliyorlar. Hangi tuşa basıldığına ait bilgi ise <literal>keysym</literal> yapısında tutuluyor.
    </para><para>
<command>SDL_keysym</command> yapısının tanımı:
    </para><para>
<funcsynopsis><funcprototype role="veri türü">
<paramdef>typedef struct{
  Uint8  <literal>scancode</literal>;
  SDLKey <literal>sym</literal>;
  SDLMod <literal>mod</literal>;
  Uint16 <literal>unicode</literal>;
} <command>SDL_keysym</command>;
</paramdef></funcprototype></funcsynopsis>
    </para><para>
Yapı üyelerinin açıklamaları:
    </para><para>
<literallayout><command>scancode</command>    donanıma özel tarama kodu
<command>sym</command>         SDL sanal tuş sembolü
<command>mod</command>         O an basılı olan değiştirici (Shift/CapsLock/Ctrl/Alt/NumLock)
<command>unicode</command>     Tuşun karakter karşılığı
</literallayout>
    </para><para>
<literal>scancode</literal> üyesinin değeri klavyeden dönen donanıma özel veridir ve genellikle
dokunulmaz, kurcalanmaz. <literal>sym</literal> ise en önemli ve en kullanışlı alandır. <literal>sym</literal> içerisinde SDL'de tanımlı tuş değeri saklanır. Bu tuşların tanımları için <command>SDLKey</command> yapısının içeriğine bakmak gerekiyor ama bu yapının içeriği çok uzun
olduğu için en sona bırakıyorum.Bunlar dışında <literal>mod</literal> üyesinde yukarıda da belirttiğim gibi shift, control, alt tuşları gibi tuşlara basılması durumunda basılan tuşa ait
veriyi içinde saklar. Bu veriye ulaşmanın bir diğer yoluda <command>SDL_GetModState</command> işlevini kullanmaktır. Kullanımı;
    </para><para>
<screen>SDLMod mod;
mod = SDL_GetModState();
</screen>
    </para><para>
<command>SDLMod</command> yapısının tanımı:
    </para><para>
<funcsynopsis><funcprototype role="veri türü">
<paramdef>typedef enum {
  <literal>KMOD_NONE</literal>   = 0x0000,  // Bir değiştirici basılı değil
  <literal>KMOD_LSHIFT</literal> = 0x0001,  // Sol Shift tuşu basılı
  <literal>KMOD_RSHIFT</literal> = 0x0002,  // Sağ Shift tuşu basılı
  <literal>KMOD_LCTRL</literal>  = 0x0040,  // Sol Ctrl tuşu basılı
  <literal>KMOD_RCTRL</literal>  = 0x0080,  // Sağ Ctrl tuşu basılı
  <literal>KMOD_LALT</literal>   = 0x0100,  // Sol Alt tuşu basılı
  <literal>KMOD_RALT</literal>   = 0x0200,  // Sağ Alt tuşu basılı
  <literal>KMOD_LMETA</literal>  = 0x0400,  // Sol Meta tuşu basılı (PC klavyelerinde yoktur)
  <literal>KMOD_RMETA</literal>  = 0x0800,  // Sağ Meta tuşu basılı (PC klavyelerinde yoktur)
  <literal>KMOD_NUM</literal>    = 0x1000,  // Num Lock tuşu basılı
  <literal>KMOD_CAPS</literal>   = 0x2000,  // Caps Lock tuşu basılı
  <literal>KMOD_MODE</literal>   = 0x4000,  // Bir fikrim yok
} <command>SDLMod</command>;
</paramdef></funcprototype></funcsynopsis>
    </para><para>
SDL içerisinde ayrıca şu tanımlamalarda mevcut;
    </para><para>
<literallayout>#define KMOD_CTRL   (KMOD_LCTRL|KMOD_RCTRL)       // herhangi bir Ctrl tuşu
#define KMOD_SHIFT  (KMOD_LSHIFT|KMOD_RSHIFT)     // herhangi bir Shift tuşu
#define KMOD_ALT    (KMOD_LALT|KMOD_RALT)         // herhangi bir Alt tuşu
#define KMOD_META   (KMOD_LMETA|KMOD_RMETA)       // herhangi bir Meta tuşu
</literallayout>
    </para><para>
SDL'de iki tane de normal tuşların değerini alabileceğimiz işlev bulunmaktadır: <command>SDL_GetKeyState</command> ve <command>SDL_GetKeyName</command>.
    </para><para>
<screen>Uint8 *keystate;
keystate = SDL_GetKeyState(NULL);
if ( keystate[SDLK_RETURN] ) printf("Return tuşuna basıldı.\n")
</screen>
    </para><para>
<screen>char *keyname;
keyname = SDL_GetKeyName(SDLK_RETURN);
</screen>
    </para><para>
<command>SDL_GetKeyState</command> işlevi, <command>SDLKey</command> yapısında tanımlı tüm tuşların durumlarını içeren bir dizi ile döner. <command>SDL_GetKeyName</command> işlevi ise <command>SDLKey</command> yapısında tanımlı bir tuşun ismini içeren bir dizge döndürür. <command>SDLKey</command> yapısında tanımlı tuş sembolleri, ASCII değerleri ve isimleri:
    </para><para>
<literallayout>
SDLKey değeri    ASCII değeri     İsmi
---------------  -------------   ----------
SDLK_BACKSPACE      '\b'          backspace
SDLK_TAB            '\t'          tab
SDLK_CLEAR                        clear
SDLK_RETURN         '\r'          return
SDLK_PAUSE                        pause
SDLK_ESCAPE         '^['          escape
SDLK_SPACE          ' '           space
SDLK_EXCLAIM        '!'           exclaim
SDLK_QUOTEDBL       '"'           quotedbl
SDLK_HASH           '#'           hash
SDLK_DOLLAR         '$'           dollar
SDLK_AMPERSAND      '&amp;'           ampersand
SDLK_QUOTE          '''           quote
SDLK_LEFTPAREN      '('           left parenthesis
SDLK_RIGHTPAREN     ')'           right parenthesis
SDLK_ASTERISK       '*'           asterisk
SDLK_PLUS           '+'           plus sign
SDLK_COMMA          ','           comma
SDLK_MINUS          '-'           minus sign
SDLK_PERIOD         '.'           period
SDLK_SLASH          '/'           forward slash
SDLK_0              '0'           0
SDLK_1              '1'           1
SDLK_2              '2'           2
SDLK_3              '3'           3
SDLK_4              '4'           4
SDLK_5              '5'           5
SDLK_6              '6'           6
SDLK_7              '7'           7
SDLK_8              '8'           8
SDLK_9              '9'           9
SDLK_COLON          ':'           colon
SDLK_SEMICOLON      ';'           semicolon
SDLK_LESS           '&lt;'           less-than sign
SDLK_EQUALS         '='           equals sign
SDLK_GREATER        '>'           greater-than sign
SDLK_QUESTION       '?'           question mark
SDLK_AT             '@'           at
SDLK_LEFTBRACKET    '['           left bracket
SDLK_BACKSLASH      '\'           backslash
SDLK_RIGHTBRACKET   ']'           right bracket
SDLK_CARET          '^'           caret
SDLK_UNDERSCORE     '_'           underscore
SDLK_BACKQUOTE      '`'           grave
SDLK_a              'a'           a
SDLK_b              'b'           b
SDLK_c              'c'           c
SDLK_d              'd'           d
SDLK_e              'e'           e
SDLK_f              'f'           f
SDLK_g              'g'           g
SDLK_h              'h'           h
SDLK_i              'i'           i
SDLK_j              'j'           j
SDLK_k              'k'           k
SDLK_l              'l'           l
SDLK_m              'm'           m
SDLK_n              'n'           n
SDLK_o              'o'           o
SDLK_p              'p'           p
SDLK_q              'q'           q
SDLK_r              'r'           r
SDLK_s              's'           s
SDLK_t              't'           t
SDLK_u              'u'           u
SDLK_v              'v'           v
SDLK_w              'w'           w
SDLK_x              'x'           x
SDLK_y              'y'           y
SDLK_z              'z'           z
SDLK_DELETE         '^?'          delete
SDLK_KP0                          keypad 0
SDLK_KP1                          keypad 1
SDLK_KP2                          keypad 2
SDLK_KP3                          keypad 3
SDLK_KP4                          keypad 4
SDLK_KP5                          keypad 5
SDLK_KP6                          keypad 6
SDLK_KP7                          keypad 7
SDLK_KP8                          keypad 8
SDLK_KP9                          keypad 9
SDLK_KP_PERIOD      '.'           keypad period
SDLK_KP_DIVIDE      '/'           keypad divide
SDLK_KP_MULTIPLY    '*'           keypad multiply
SDLK_KP_MINUS       '-'           keypad minus
SDLK_KP_PLUS        '+'           keypad plus
SDLK_KP_ENTER       '\r'          keypad enter
SDLK_KP_EQUALS      '='           keypad equals
SDLK_UP                           up arrow
SDLK_DOWN                         down arrow
SDLK_RIGHT                        right arrow
SDLK_LEFT                         left arrow
SDLK_INSERT                       insert
SDLK_HOME                         home
SDLK_END                          end
SDLK_PAGEUP                       page up
SDLK_PAGEDOWN                     page down
SDLK_F1                           F1
SDLK_F2                           F2
SDLK_F3                           F3
SDLK_F4                           F4
SDLK_F5                           F5
SDLK_F6                           F6
SDLK_F7                           F7
SDLK_F8                           F8
SDLK_F9                           F9
SDLK_F10                          F10
SDLK_F11                          F11
SDLK_F12                          F12
SDLK_F13                          F13
SDLK_F14                          F14
SDLK_F15                          F15
SDLK_NUMLOCK                      numlock
SDLK_CAPSLOCK                     capslock
SDLK_SCROLLOCK                    scrollock
SDLK_RSHIFT                       right shift
SDLK_LSHIFT                       left shift
SDLK_RCTRL                        right ctrl
SDLK_LCTRL                        left ctrl
SDLK_RALT                         right alt
SDLK_LALT                         left alt
SDLK_RMETA                        right meta
SDLK_LMETA                        left meta
SDLK_LSUPER                       left windows key
SDLK_RSUPER                       right windows key
SDLK_MODE                         mode shift
SDLK_HELP                         help
SDLK_PRINT                        print-screen
SDLK_SYSREQ                       SysRq
SDLK_BREAK                        break
SDLK_MENU                         menu
SDLK_POWER                        power
SDLK_EURO                         euro
</literallayout>
    </para><para>
Gördüğünüz gibi uzun bir liste. Son olarak, <command>SDL_keysym</command> veri yapısı içerisindeki son üye olan <literal>unicode</literal>'da ise basılan tuşun unicode verisi saklanır. Tabii bunun için önceden <command>SDL_EnableUNICODE</command> işlevi ile Unicode'u
etkin duruma getirmek gerekir. Ayrıntılar için SDL kütüphanesi ile dağıtılan belgelere bakınız.. Oyun yapımı konusunda çok da gerekli olmadığı için burada anlatmayacağım.Bunun yerine size çok işe yarar bulduğum bir işlevi tanıtmak istiyorum: <command>SDL_EnableKeyRepeat</command> işlevi. Bu işlev basılı tuttuğunuz tuşun tekrar oranını belirler veya tekrar özelliğini etkisiz hale getirir. Kullanımı;

int
SDL_EnableKeyRepeat(int delay, int interval);



şeklindedir. delay değişkeni tuş tekrar edilmeden önce ne kadar basılı
tutulması gerektiği belirtir. interval ise tekrar hızını belirtir.
İkisininde değeri milisaniye cinsindendir. Eğer
delay değişkenini 0 yaparsanız tekrar özelliği tamamiyle etkisiz hale
gelir. Uygun varsayılan değerler SDL
içerisinde SDL_DEFAULT_REPEAT_DELAY ve SDL_DEFAULT_REPEAT_INTERVAL
adları ile tanımlanmıştır.


Klavye olayları ile ilgili anlatacaklarım bu kadar sırada mouse
olayları var. Mouse ile ilgili olaylar için kullanılan iki tane yapı
var. Bunlar SDL_MouseMotionEvent ve SDL_MouseButtonEvent. Bu yapılar
SDL_Event yapısı içerisinde motion ve button adları ile
tanımlanmışlardır. Motion mouse'un hareket etmesi ile oluşan olayları
kapsar. Button ise
mouse'un tuşlarına bastığınızda oluşan olayları kapsar. İlk olarak
motion'dan bahsedelim.


SDL_MouseMotionEvent yapısının içeriği;

typedef
struct{
Uint8
type;
Uint8 state;
Uint16 x, y;
Sint16 xrel, yrel;

} SDL_MouseMotionEvent;



şeklindedir. Ve;


type        için tek bir tip
bulunmaktadır ve o da SDL_MOUSEMOTION 'dur.

state        o an ki mouse tuşlarının
durumları

x, y        mouse'un X/Y koordinatları

xrel, yrel    mouse'un X/Y koordinatlarındaki göreceli
hareketi


temsil eder.


SDL_MouseButtonEvent yapısının içeriği ise;

typedef
struct{
Uint8
type;
Uint8 button;
Uint8 state;
Uint16 x, y;

} SDL_MouseButtonEvent;



şeklindedir. Açıklamak gerekirse;


type    SDL_MOUSEBUTTONDOWN veya SDL_MOUSEBUTTONUP
tipleri

button    Olayın hangi tuşla alakalı olduğu
(SDL_BUTTON_LEFT, SDL_BUTTON_MIDDLE, SDL_BUTTON_RIGHT)

state    SDL_PRESSED veya SDL_RELEASED yani tuşa basıldı
mı? yoksa tuş bırakıldı mı?

x, y    Basılma veya bırakılma anındaki X/Y koordinatları


dır.


Mouse olaylarını yakalamak için klavye olaylarında olduğu gibi en başta
belirttiğimden farklı bir yol daha vardır. Bu yol ise SDL_GetMouseState
işlevindan geçer.

Uint8
SDL_GetMouseState(int *x, int *y);



şeklinde yazılır. X veya Y koordinatlarını girmek istemezseniz NULL
değeri girebilirsiniz. Bu işlev geriye basılan tuşa ait bilgiyi
geri döndürür. Tuşa ait bilgiye ulaşmak için
SDL_BUTTON(X) makrosunu kullanabilirsiniz. Bir örnek vereyim.

SDL_PumpEvents();
if(SDL_GetMouseState(NULL,
NULL)&SDL_BUTTON(1))
printf("Sol
Mouse tuşuna basıldı.\n");




Yukarıda SDL_PumpEvents işlevinu kullandık. Bu işlev oluşan
olaylardan gelen bilgileri derleyip olay kuyruğuna koyar. Bir olayın
olay kuyruğuna konması için bu işlevin
çağrılması gerekir ama SDL_PollEvent ya da SDL_WaitEvent
işlevlarını kullanıyorsanız bu işlevi
kullanmanıza gerek kalmaz. SDL_WaitEvent işlevi ise özel olarak
belirtilmiş bir olayın
gerçekleşmesini bekler. Bu olay gerçekleşene kadar programın
kapanmasını engeller. Kullanımı;

int
SDL_WaitEvent(SDL_Event *event);



Kullanımı nerede ise SDL_PollEvent'ın aynısıdır ama aradaki fark
SDL_WaitEvent bir olay gerçekleşene kadar programı bekletir.
SDL_PollEvent ise gerçekleşen olay var mı diye bakar, varsa
işlem yapar, yoksa devam eder.
</sect1><sect1><title>7. SDL ve Ses (Audio)</title>

SDL içerisindeki ses işlevları genel olarak aşağı seviye (low
level) ses programlaması kullanılacak yazılımlar için tasarlanmıştır.
Bu nedenle ses konusunda SDL'e kendi yazdığınız
kod ile taklalar attırmak istemiyorsanız ya da tek yapacağınız basit
bir wav dosyasını açıp çalmak değilse size
kolaylıklar ve gelişmiş özellikler sunan bir ses kütüphanesi olan
SDL_Mixer'ı kullanmanızı tavsiye ederim. Bu kütüphane
SDL üzerinden çalışıyor ve size oldukça gelişmiş bir çok özelliği
kolayca kullanım imkanı sunuyor. Bu
kütüphaneye SDL'in websitesinden "Libraries" bölümünden
ulaşabilirsiniz. SDL içerisindeki ses işlevlarına
dönelim. İlk olarak bilmeniz gereken bu işlevları kullanmak için
önce SDL_INIT_AUDIO alt sistemini aktif
hale getirmelisiniz. Basitçe açıklamak gerekirse ilk olarak ses
sistemini açacağız. Ardından
ses dosyasından veriyi ki bu dosya Wav uzantılı olmalı, hafizaya
yükleyeceğiz. Daha sonra ise bu veriyi ses
sistemine çalması için ileteceğiz. Şimdi fazla detaya inmeden basitçe
ses sistemini nasıl açacağınızı ve
bir ses dosyasını nasıl yükleyip, çalacağınızı anlatacağım. İlk önce
ses sistemini nasıl açacağımızdan
bahsedeceğim.

SDL_AudioSpec
fmt;  /* SDL_AudioSpec ses
ayarlarına ait bilgilerin saklandığı veri yapısı.

      ılk olarak bu
tip bir yapı tanımlayıp ona istediğimiz değerleri giriyoruz.

      Ardındanda bu
yapıyı SDL_OpenAudio işlevinda parametre olarak kullanarak

      istediğimiz
değerlerde ses sistemini açıyoruz */

/* 22 Khz 'de 16 bit stereo ses */
fmt.freq = 22050;

 // frekans değeri
fmt.format =
AUDIO_S16;    //
veri
formatı
fmt.channels = 2;

 // kanal sayısı 1- mono, 2- stereo
fmt.samples = 512;

 // sample'ların tampon büyüklüğü
fmt.callback = mixaudio;    // ses
tamponunu doldurmak için çağırılacak işlev
// bu işlevi aşağıda yazacağım
fmt.userdata = NULL;    // işleva
girilecek parametrelerin işaretçisi

/* Yukarıdaki değerler oyunlar
için uygun
değerlerdir */

/* SDL_OpenAudio işlevina
parametre olarak
yukarıda değerlerini
girdiğimiz SDL_AudioSpec veri
yapısı verilir ve
"Voila!" ses sistemi açılır.
Geriye -1 değeri dönerse bir sorun
çıkmış ve ses
sistemi açılamamış demektir. */

if ( SDL_OpenAudio(&fmt,
NULL) < 0 ) {
fprintf(stderr,
"Ses sistemi
açılamıyor : %s\n", SDL_GetError());
exit(1);

}

/* Bu satırı girmeden
programınızdan ses
gelmeyecektir.
Bunun nedeni SDL'in program hazır
olana kadar
istediğiniz
ses ayarlarını yapabilmenize imkan
tanımasıdır */

SDL_PauseAudio(0);

    ....


/* ses ile işiniz bitince
SDL_CloseAudio
işlevinu kullanarak ses sistemini kapatmayı unutmayın. */
SDL_CloseAudio();




Ses sistemini açmak kısaca böyle. Sırada bir ses dosyasını hafizaya
yüklemek ve çalmak var.


Örnek kodumuzda ilk olarak ses verisini saklayacağımız veri yapısını
tanımlıyoruz.

#define
NUM_SOUNDS 2

struct sample {
Uint8 *data;

Uint32 dpos;

Uint32 dlen;

} sounds[NUM_SOUNDS];



Ses stereo olacağı için ses sayısını 2 yaptık. data ses verileri için,
dpos verilerin pozisyonu için ve dlen ise ise verinin uzunluğuna
ulaşmak için kullanılıyor.


Bu işlev ile yaptığımız şey temel olarak SDL_LoadWav işlevi ile
hafızaya yükleyeceğimiz bir ses dosyasının verilerini SDL için uygun
şekilde formatlamak. Bu işlev yukarıdaki
ses sistemini açmak için kullanabileceğimiz kodlar arasında
kullanılıyor.


void
mixaudio(void *unused, Uint8 *stream, int len)

{
int i;

Uint32 amount;



for ( i=0; i<NUM_SOUNDS; ++i )
{
amount =
(sounds[i].dlen-sounds[i].dpos);

if ( amount
> len ) {
amount = len;


}

SDL_MixAudio(stream,
&sounds[i].data[sounds[i].dpos], amount,
SDL_MIX_MAXVOLUME);

sounds[i].dpos
+= amount;

}

}





Bu işlev ise kendisine parametre olarak girilen dosyayı yükler ve
çalar. Ama önceden ses sisteminin açılması gerekir. Yukarıdaki
işlevi ise ses sistemini açarken kullandığımız
kodlar arasında kullanmıştık. Aklınızda bulunsun.

void
PlaySound(char *file)

{
int index;
         //sayaç değişkeni

SDL_AudioSpec wave;
 //ses verisi ayarları

Uint8 *data;
     //ses
verisi

Uint32 dlen;
     //uzunluğu

SDL_AudioCVT cvt;
 //ses verisinin formatını değiştirirken kullanılan veri yapısı


/*
Boş veya bitmiş bir ses slotu
aranır */

for ( index=0;
index<NUM_SOUNDS; ++index ) {
if (
sounds[index].dpos == sounds[index].dlen ) {

break;

}

}

if ( index == NUM_SOUNDS )
return;


/* Ses dosyası yüklenir ve 22kHz
16-bit stereo ya çevrilir */

if ( SDL_LoadWAV(file, &wave,
&data, &dlen) == NULL ) {
fprintf(stderr, "Yüklenemiyor %s:
%s\n", file, SDL_GetError());

return;

}

SDL_BuildAudioCVT(&cvt,
wave.format, wave.channels, wave.freq,AUDIO_S16,
2,
22050);

cvt.buf =
malloc(dlen*cvt.len_mult);

memcpy(cvt.buf, data, dlen);

cvt.len = dlen;

SDL_ConvertAudio(&cvt);

SDL_FreeWAV(data);


/* Ses verisini slota yerleştir
(hemen çalmaya başlar) */

if ( sounds[index].data ) {
free(sounds[index].data);

}

SDL_LockAudio();

sounds[index].data = cvt.buf;

sounds[index].dlen = cvt.len_cvt;

sounds[index].dpos = 0;

SDL_UnlockAudio();

}




Fazla detaylı değil biliyorum. Ama yakın zamanda sizin için daha
kullanışlı olacağını düşündüğüm SDL_Mixer kütüphanesi içinde bir
dökümantasyon hazırlayacağım. Orda istediğiniz
miktarda bilgiye erişebileceksiniz. şimdilik hepsi bu kadar.
</sect1><sect1><title>8. SDL ve Zaman</title>

Sıra geldi SDL içerisindeki zamanla ilgili işlevlara. İlk olarak
SDL_Delay işlevinu anlatacağım. Yazılışı;

Uint32
zaman=10;
SDL_Delay(zaman);



Bu işlev girilen parametre kadar milisaniye süresince programı
bekletir. Ekrana yeni bir çizim yapmadan hemen öncesine ya da bütün
çizimler bittikten hemen sonrasına bir adet
SDL_Delay(1); satırı eklemeniz programınızın güçlü makinalarda
beklediğinizden hızlı çalışmasını engeller. [ ed: Günümüzde
bu yöntem kesinlikle tavsiye edilmez. Programınızın her bilgisayarda
beklediğiniz sabit hızda çalışmasını istiyorsanız
dökümanlar bölümünde yer alan "Oyun Programlarında Doğru Zamanlama"
isimli dökümanda anlatılan
yönemlere benzer teknikleri uygulamanız gerekir ]


Bunun dışında SDL_GetTicks işlevi oldukça işinize yarayabilecek bir
işlevdur. Bu işlev SDL programı çalıştırıldığından beri kaç
milisaniye geçtiği değerini verir. 49
günden sonra değer başa dönüyormuş sanırım. Kullanımı;

Uint32
gecenzaman;
gecenzaman=SDL_GetTicks();



Bunlar dışında 3 tanede timer işlevi bulunmaktadır. Bunlar
SDL_AddTimer, SDL_RemoveTimer ve SDL_SetTimer dır. Ve SDL_Delay ve
SDL_GetTicks işlevları için gerekmese de, bu
işlevları kulllanabilmek için SDL_INIT_TIMER alt sistemini aktif
hale getirmeniz gerekmektedir. SDL_AddTimer
işlevi belirtilen miktarda milisaniye geçince
belirtilen bir işlevi çağıran bir timer ekler. Yazılışı;

my_timer_id
= SDL_AddTimer(30, cagrilan_fonk,
fonk_parametreleri);



şeklindedir. SDL_RemoveTimer() işlevi ise eklenmiş bir timer'ı
kaldırmak için
kullanılır. Bunun için işleva parametre olarak kaldırmak
istediğiniz timer'ın id'si girilir. Bu işlevin
yazılışı;

SDL_RemoveTimer(my_timer_id);



şeklindedir.SDL_SetTimer işlevi ise belirtilen miktarda milisaniye
geçince
belirtilen işlevi çağırır. Yazılışı;

SDL_SetTimer(30,
cagrilan_fonk);



şeklindedir. SDL_SetTimer ile çalıştırılan bir timer'ı iptal etmek için;

SDL_SetTimer(0,
NULL);



kodunu kullanmalıyız. Aslında bu işlev eski sürümlerle uyumluluğu
bozmamak için saklanmıştır ama SDL_AddTimer ve SDL_RemoveTimer
işlevları bu işlevdan daha yeni ve daha
üstündür ayrıca birden çok timer'ı kullanmanıza imkan tanırlar.Dikkat
edilmesi gereken nokta Timer işlevları
çalışırken ayrı bir
thread veya alarm sinyalleri (alarm signals) kullanırlar ve makinaya
bağımlıdırlar. Bu nedenle kullanırken dikkatli
olunmalıdır.
</sect1><sect1><title>Ozan Emirhan Bayyurt {ragnor}

Website: http://www.geocities.com/ragnor_whr/

E-mail: ragnor_whr@yahoo.com

Tarih: 27/06/2005


www.oyunyapimi.org
</title>



</entry>

  </row>

  </tbody></informaltable>
</entry>

  </row>

  </tbody></informaltable>




    Bu haberin geldigi yer: oyunyapimi.org
 <ulink url="http://www.oyunyapimi.org/">http://www.oyunyapimi.org</ulink>


    Bu haber icin adres:
 <ulink url="http://www.oyunyapimi.org/modules.php?name=Sections&op=viewarticle&artid=87">http://www.oyunyapimi.org/modules.php?name=Sections&op=viewarticle&artid=87</ulink>
    </entry>

  </row>

  </tbody></informaltable>
</article>
