<?xml version="1.0" encoding="UTF-8"?>
<!-- ********************************************************************
         md.xml, v 1.0, GFDLv1.1, Ekim 2003
     ******************************************************************** -->
<article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="md" xml:lang="tr">
 <info>
  <title>İleti Özeti NASIL</title>
  <subtitle>MD - Message Digest</subtitle>
  <author>
   <personname>
    <firstname>Emin İslâm Tatlı</firstname>
   </personname>
   <affiliation>
    <address>
     <email>eminislam@hotmail.com</email>
    </address>
   </affiliation>
  </author>
  <pubdate>Ekim 2003</pubdate>
  <releaseinfo>v1.0</releaseinfo>
  <legalnotice>
   <para>
       Bu belgenin, <emphasis>İleti Özeti</emphasis>,
       1.0 sürümünün <emphasis role="bold">
       telif hakkı © 2003 <emphasis>Emin İslâm Tatlı</emphasis></emphasis>'ya
       aittir.
     </para>
   <para>
       Bu belgeyi, Free Software Foundation tarafından yayınlanmış
       bulunan GNU Özgür Belgeleme Lisansının 1.1 ya da daha sonraki sürümünün
       koşullarına bağlı kalarak kopyalayabilir, dağıtabilir ve/veya
       değiştirebilirsiniz. Bu Lisansın bir kopyasını <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="fdl.html">GNU Free Documentation License</link> başlıklı bölümde bulabilirsiniz.
      </para>
   <para>
       Linux, Linus Torvalds adına kayıtlı bir ticarî isimdir.
      </para>
   <para>
        Bu belgedeki bilgilerin kullanımından doğacak sorumluluklar,
        ve olası zararlardan belge yazarı sorumlu tutulamaz.
        Bu belgedeki bilgileri uygulama sorumluluğu uygulayan aittir.
      </para>
   <para>
        Tüm telif hakları aksi özellikle belirtilmediği sürece sahibine
        aittir. Belge içinde geçen herhangi bir terim bir ticarî isim
        yada kuruma itibar kazandırma olarak algılanmamalıdır. Bir ürün
        ya da markanın kullanılmış olması ona onay verildiği anlamında
        görülmemelidir.
      </para>
  </legalnotice>
 </info>
 <para role="only.html">Ek - <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="fdl.html">GNU Free Documentation License</link></para>
 <section xml:id="md-nedir">
  <info>
   <title>MD Nedir?</title>
  </info>
  <para>
MD en basit şekilde <emphasis>herhangi uzunluktaki bir veriyi işleyip sonuç olarak sabit uzunlukta bir veri elde eden işlev</emphasis> olarak tanımlanabilir. Matematiksel olarak tanımlayacak olursak:
</para>
  <para>
   <literallayout class="normal">
M: değişken uzunlukta veri, h: sabit uzunlukta veri, H: işlev
                     <userinput>h = H(M)</userinput>
</literallayout>
  </para>
  <para>
Sabit uzunkta çıktı elde etmenin yanında, MD işlevinin sağlaması gereken bazı özellikler vardır. Bu özellikler söyle sıralanabilir:
</para>
  <para>
   <itemizedlist>
    <listitem><userinput>M</userinput> verildiği zaman, <userinput>h</userinput>'yı hesaplamak kolay olmalı</listitem>
    <listitem><userinput>h</userinput> verildiği zaman <userinput>M</userinput>'yi hesaplamak çok zor olmalı (hatta imkansız olmalı). Bu yönüyle MD işlevi <wordasword>tek yönlü işlev</wordasword> (one-way function) olarak adlandırılır.</listitem>
    <listitem><userinput>M</userinput> veridiğinde <literal>H(M) = H(M')</literal> eşitliğini sağlayan <userinput>M'</userinput> çok zor bulunmalı (hatta imkansız olmalı)</listitem>
   </itemizedlist>
  </para>
  <section>
   <info>
    <title>Nerelerde Kullanılabilir?</title>
   </info>
   <para>
MD işlevinin taşıması gereken özelliklerinden bahsettikten sonra, nerelerde kullanılabilir sorusu daha kolay anlaşılabilir. <emphasis>MD, verilerin bütünlük denetimi yani verinin değişikliğe uğrayıp uğramadığının denetlenmesi için kullanılmaktadır</emphasis> şeklinde özetlenebilir.
</para>
   <para>
Örneğin internete indirilmek üzere yerleştirdiğiniz bir dosyaya ek olarak bu dosyanın MD sonucunuda dağıtırsanız, bu dosyayı sizin sitenizden indiren kullanıcılar, kendi bilgisayalarında bu dosyanın MD'sini hesaplayıp sizin hesapladığınız MD değeri ile kontrol ederler ve böylece indirdikleri dosyanın değiştirilip değiştirilmediğini, yani güvenilir olup olmadığını anlayabilirler (Bu noktada sizin güvenlir olduğunuz farzedilmektedir).
</para>
  </section>
 </section>
 <section xml:id="md-algoritmalar">
  <info>
   <title>İleti Özümleme Algoritmaları</title>
  </info>
  <para>
Bugüne kadar MD işlevi için bir çok algoritma tasarlanmıştır, fakat bunlardan sadece bir kısmı yukarıda sıralanan özellikleri birarada barındırdığından genel kabul görmüşlerdir. Bu algoritmaların başta gelenleri md5 (message digest 5) ve sha'dır (secure hash algorithm).
</para>
  <section>
   <info>
    <title>MD5 (Message Digest 5)</title>
   </info>
   <para>
MD5, Ron Rivest tarafıdan 1992 yılında tasarlanmış bir MD algoritmasıdır. Ron Rivest, yine kendi tasarladığı MD4 algoritmasındaki bir takım zayıflıkları gidermiş ve günümüzde sıkça kuallanılan MD5 algoritması ortaya çıkmıştır. MD5, sonsuz uzunlukta veriyi girdi olarak kabul edebilir ve sonuçta 128 bit uzunluğunda bir çıktı üretir. Kısaca algoritmanın nasıl işlediğine bakacak olursak:
</para>
   <para>
    <itemizedlist>
     <listitem>
      <para>
MD5, veriyi 512 bitlik bloklara ayırır ve her bir blok üzerinde aynı işlem uygulanır.
</para>
     </listitem>
     <listitem>
      <para>
Üzerinde işlem yapılacak verinin 512 bitin katları olması gerekmektedir, fakat gerçek verimiz bu özelliği sağlamayabilir. Bu sorunu çözmek için ekleme (padding) işlemi uygulanır (gerçek verimiz 512 in katı olsa dahi ekleme yapılır!).
</para>
      <para>
Ekleme işleminde şu kural gözetilir: Verinin uzunluğu 512 bitin en yakın katından 64 eksik olacak şekilde, verinin sonuna bir adet <userinput>1</userinput> ve geri kalanlar için ise <userinput>0</userinput> eklenir. Bu 64 bitlik fark verinin uzunluğunu belirtmekte kullanılır.
</para>
      <para>
Bir örnekle açıklayacak olursak; diyelim verimiz 300 bit uzunlukta olsun. Bunu 448 bite (512-64) tamamlamız gerekmektedir. Dolayısı ile 301. bit olarak <userinput>1</userinput> ve geri kalan 147 tane bit için ise <userinput>0</userinput> ataması yaparız. Elimizde şu anda 448 bit var. Gerçek verimizin uzunluğu 300 bit idi ve bunuda ikilik tabanda  64 bit ile ifade edip 448 bitlik verimize ekleriz. Böylece 512-bitlik yeni oluşturduğumuz veri üzerinde MD5 algoritmasını uygulayabiliriz.
</para>
     </listitem>
     <listitem>
      <para>
Ekleme işleminden sonra, MD5 veriyi işlemeye başlar. Ana döngü <xref linkend="md-mainloop"/>'de görülmektedir.
</para>
      <para>
       <figure xml:id="md-mainloop">
        <info>
         <title>MD5 Ana Döngüsü</title>
        </info>
        <mediaobject>
         <imageobject>
          <imagedata fileref="md/mainloop.jpg"/>
         </imageobject>
        </mediaobject>
       </figure>
      </para>
      <para>
Döngünün başlangıcında 32 bitlik dört tane (A,B,C,D) değişken bulunur. Başlangıçta bunların değeri sabittir ve her 512 bitlik bloğu işleme soktukça bu değişkenlerin değerleri değişir ve en sondaki bloğuda işledikten sonra elde ettiğimiz A,B,C ve D değişkenlerinin değerlerini yanyana dizdiğimizde (A-B-C-D) 128 bitlik MD sonucumuzu elde etmiş oluruz.
</para>
      <para>
Burada 4 adım (F-G-H-I) göze çarpmaktadır. Her adımın önceden tanımlı ve kendisine özgü birer işlevi bulunmaktadır ve bu işlevler her adımda 16 kez çağırılarak elde edilen sonuç bir sonraki adıma iletilir. Yani her bir 512 bitlik blok için MD5 algoritması 4 adım * 16 işlem = 64 adet işlem yapmaktadır. Bu kadar fazla adımın amacı simetrikliği engelleyip farklı girdiler için farklı sonuçlar üretebilme özelliğini sağlayabimektir. Aşağıda her adımda kullanılan işlevler gösterilmiştir.
</para>
      <para>
       <literallayout class="normal">
Her adımda 16 kez FF işlevi hesaplanır:
from (j = 0 to 15)
        FF (a, b, c, d, Mj, s, ti)
Burada:
i: adım numarası
FF (a, b, c, d, Mj, s, ti) =&gt; a = b + ((a + F(b, c, d) + Mj + ti) &lt;&lt;&lt; s)
1. adım için  F(X, Y, Z) = (X and Y) or ((not X) and Z)
2. adım için  F(X, Y, Z) = (X and Z) or (Y and (not Z))
3. adım için  F(X, Y, Z) = X xor Y xor Z
3. adım için  F(X, Y, Z) = Y xor (X or (not Z))
</literallayout>
      </para>
     </listitem>
    </itemizedlist>
   </para>
  </section>
  <section>
   <info>
    <title>SHA (Secure Hash Algorithm)</title>
   </info>
   <para>
NİST (National Institute of Standards and Technology) ve NSA (National Security Agency) kuruluşlarının ortak çalışmaları sonucunda 1994 yılında Sayısal İmza Standardında (DSA-Digital Signature Standard) kullanılmak üzere tasarlanmış bir algoritmadır. MD5'le benzerlik göstermektedir. MD5 ile karşılaştıracak olursak;
</para>
   <section>
    <info>
     <title>MD5 - SHA Karşılaştırması</title>
    </info>
    <para>
     <itemizedlist>
      <listitem>
MD5'in çıktısı 128 bit iken, SHA'nın çıktısı 160 bittir. Yani MD5'te 4 adet 32 bitlik değişken kullanılırken, SHA'da 5 adet 32 bitlik değişken kullanılır.
</listitem>
      <listitem>
Her ikiside 512 bitlik bloklar üzerinde işlem yaparlar.
</listitem>
      <listitem>
SHA'da ekleme (padding) işlemi, MD5'teki ile aynı şekilde yapılır.
</listitem>
      <listitem>
SHA'da da her 512 bitlik blok için 4 adımda işlemler yapılır, fakat bir farkla: MD5'de her adımda önceden tanımlı işlevlerin kullanımı 16 kez tekrarlanırken, bu sayı SHA'da 20 kezdir.
</listitem>
      <listitem>
SHA girdi olarak maksimum 2<superscript>64-1</superscript> uzunluğunda veriyi kabul eder. Bunu yanında MD5 için böyle bir kısıtlama yoktur.
</listitem>
      <listitem>
SHA ürettiği 160 bitlik sonuç ile brute-force (bütün olası sonuçların denenmesi ile gerçekleştirilir) ataklara karşı daha dayanıklıdır.
</listitem>
     </itemizedlist>
    </para>
   </section>
   <section>
    <info>
     <title>Diğerleri</title>
    </info>
    <para>
MD5 ve SHA'nın yanında daha birçok MD algoritması tasarlanmıştır. Bunlardan bazıları MD2, MD4, Haval, Ripe-MD, Snefru, N-Hash'dır.
</para>
   </section>
  </section>
 </section>
 <section xml:id="md-uygulamalar">
  <info>
   <title>Uygulamalar</title>
  </info>
  <para>
Çok çeşitli MD algoritmalarını gerçekleyen uygulamaları farklı platformlar için bulmak mümkündür.
</para>
  <section>
   <info>
    <title>Unix/Linux Uygulamaları</title>
   </info>
   <para>
Unix/Linux platformlarında MD5 ve SHA algoritmaların gerçekleyen en bilindik uygulamalar sırasıyla <userinput>md5sum</userinput> ve <userinput>sha1sum</userinput>'dır. Uygulamaların çalıştırılmasına ilişkin örnekler:
</para>
   <para>
    <screen><prompt>~$</prompt><userinput>md5sum deneme</userinput>
d39100ac38f7bde184d48d1ad0af0318  deneme
<prompt>~$</prompt> <userinput>sha1sum deneme</userinput>
394916cffc20a1e087ede73a8b66ce1063ea4b9f  deneme
<prompt>~$</prompt>
</screen>
   </para>
   <para>
Bu uygulamaları <uri xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.rpmfind.net/">http://www.rpmfind.net/</uri>  adresinden temin edebilirsiniz.
</para>
  </section>
  <section>
   <info>
    <title>Windows Uygulamaları</title>
   </info>
   <para>
Windows platformu için ücretsiz MD uygulamaları bulmak mümkündür. MD5 algoritması için <literal>www.md5summer.com</literal>  ve yine MD2, MD4, MD5, RIPEMD-128, SHA-1 gibi birçok algoritmayı destekleyen Jacksum (<literal>http://www.jonelo.de/java/jacksüm/index.html</literal>)  uygulaması windows platformunda kullanılabilir.
</para>
  </section>
 </section>
 <section xml:id="md-gelistirme">
  <info>
   <title>Yazılım Geliştirme</title>
  </info>
  <para>
Bir çok yazılım geliştirme dilinin kütüphanesinde MD algoritmaları için hazır işlevler mevcuttur. Java'da bu amaç için <literal>MessageDigest</literal> sınıfı kullanılmaktadır.
</para>
  <section>
   <info>
    <title>Java</title>
   </info>
   <para>
Java'da <literal>MessageDigest</literal> sınıfı <literal>java.security</literal> paketi içinde bulunmaktadır ve sadece “md5” ve “sha” algoritmalarını desteklemektedir. Örnek:
</para>
   <example>
    <info>
     <title>Java <literal>MessageDigest</literal> sınıfının kullanımına örnek</title>
    </info>
    <para>
     <screen linenumbering="numbered">
MessageDigest  md;
String veri = new String("MD5 uygulanacak veri");
try {
     md = MessageDigest.getInstance("md5");
     md.update(veri.getBytes());
     byte[] sonuc = md.digest();
}catch (NoSuchAlgorithmException exc)  {
     System.err.println(exc.getMessage());
}
</screen>
    </para>
    <para>
4. satırda "md5" algoritmasını gerçekleştiren <literal>MessageDigest</literal> nesnesi oluşturulur.
</para>
    <para>
5. satırda <varname>md</varname> nesnesinin verisini, <varname>veri</varname> nesnesinin baytlarını kullanarak değiştirir.
</para>
    <para>
6. satırda yapılması gereken ek işlem varsa yapılır (ekleme gibi), MD işlemi başlatılır ve hesaplama yapılıp sonuç üretilir.
</para>
   </example>
  </section>
 </section>
 <section xml:id="md-biblio">
  <info>
   <title>Faydalanılan kaynaklar</title>
  </info>
  <para>Schneier, Bruce (1996), "One-way hash functions", "Applied Cryptography", 2nd. Ed.</para>
 </section>
</article>
