<?xml version="1.0" encoding="UTF-8"?>
<!--DOCTYPE article SYSTEM "../../docbook/dtd/docbookx.dtd"-->
<!-- ********************************************************************
     $Id: windows-ve-linux.xml,v 1.2 2002/10/03 19:38:23 nilgun Exp $
     ******************************************************************** -->

<article xml:id="windows-ve-linux" lang="tr">

  <info>

    <title>Windows Ağında Linux Terminalleri</title>
    <author>
     <personname><firstname>Nilgün Belma Bugüner</firstname>
    </author>
    <pubdate>7 Temmuz 2004</pubdate>

     <!-- Most recent revision goes at the top; list in descending order -->
     <revhistory>
       <revision>
          <revnumber>1.0</revnumber>
          <date>7 Temmuz 2004</date>
          <authorinitials>NBB</authorinitials>
          <revremark>
             İlk sürüm
          </revremark>
       </revision>
     </revhistory>

     <!-- Provide a good abstract; a couple of sentences is sufficient -->
     <abstract>
        <para>
Bu belge asıl olarak, güncelliğini yitirmiş bilgisayarlarla kurulmuş ve ancak W98'lerin çalışabildiği  bir ağdaki bilgisayarların, ağa sunucu olarak hızlı bir makina eklenmesi ve buna Linux kurulması ile nasıl hızlı bilgisayarlara dönüştürülebileceğinden bahsedilmiştir.
        </para><para>
Geçen aylarda, Boğaziçi Üniversitesi Mütercim-Tercümanlık Bölümünden Linux uygulamalarına ve belgelerine türkçe çeviri desteği verebileceklerini belirten bir eposta geldi. GNU-TR projesi kapsamında bazı çalışmalar yapıyorlar. Bu arada, bilgisayar laboratuarlarında Linux kullanabilmek istediklerini de belirttiler, ama Windows'larından da vazgeçemiyorlardı. Bir çözüm, bir öneri istendi. Deniz hanım, İstanbul'da olduğundan onlarla temasa geçti ve LTSP ve PXES gibi hazır çözümler olduğundan bahsetti ayrıca bu isteğin gerçekleştirilebilmesi için yardım isteğini de LKD dernek listesine aktardı.
        </para><para>
Böyle bir isteğin varlığı, bir fikrin gelişmesine sebep oldu. Madem windows'larından vazgeçemiyorlardı; ki ben de Linux'u öğrenmeye başladığım zamanlar uzun süre vazgeçememiştim; o halde windows üzerinden Linux'un çalıştırılmasını sağlayacak bir çözüm geliştirebilirdim. Bu belge bu fikirden yola çıkılarak yapılan çalışmayı belgelendirir.
        </para>
     </abstract>
     <legalnotice><title>Yasal Açıklamalar</title>
    <para>
Bu belgenin, <emphasis>Windows Ağında Linux Terminalleri</emphasis> 1.0 sürümünün <emphasis role="bold"> telif hakkı © 2004 <emphasis>Nilgün Belma Bugüner</emphasis></emphasis>'e aittir.&notice.gpl;</para>
      &notice.disc;
    </legalnotice>
  </info>
<!-- Content follows...include introduction, license information, feedback -->
  <sect1 xml:id="windows-ve-linux_giris"><title>Giriş</title>
    <para>
Önce projenin oturduğu zemini açıklamalıyım. Üzerlerinde Windows 98'ler kurulu zayıf PC'lerden oluşmuş bir ağ var. Bu ağı yönetenler, Linux'u da kullanmak istiyor ama Windows'ların çalışabildiği o zayıf makinalarda Linux'u verimli kullanamayacaklarını düşünüyorlar. Haklıdırlar, günümüz Linux sistemleri en az 256 MB bellek en az 1GHz'lik işlemci ile 3-5 GB disk alanı istiyor. Bu pahalı bir çözüm. Ama o yavaş PC'lerde günümüz yazılımlarını günümüz bilgisayarlarının hızında çalıştırmak da en ekonomik yoldan sadece Linux ile mümkün :-) Ne tezat değil mi?
    </para><para>
Bu zemine oturan bu projenin, gerçekleşebilmesi için ağın sunucusunu kaçınılmaz olarak Linux yapmak gerekiyor, hem de oldukça hızlı bir işlemcisi (bir P4), en az 512MB belleği olan bir makina lazım. Linux sunucu Samba ile hem ağdaki Windows'ları yönetmek için hem de onlarda Linux çalıştırıldığında onlara X terminal sunucusu olmak için gerekli. Sunucu dışında diğer makinalara Linux kurulumu yapmayacağız. Her makinanın dosya sistemine 3 küçük dosya (toplamı 6 MB civarında) konacak ve bir makina üzerinde Linux çalıştırılmak istendiğinde Windows, Linux'u çalıştıracak. Olur mu demeyin. Nasıl olduğunu bu belgede anlatıyorum. Makinalarınızda - şu ucuz 10/100 Mbit ağ kartlarından varsa ve ağınız 100Mbit hızda çalışıyorsa, Linux makinaların sürat rekoru kıracağından endişeniz olmasın. 2.5 MHz AMD işlemcili, 1GB bellekli bir makinanın sunucu olarak kullanıldığı, 100-200 MHz işlemci ve 24-32 MB belleği olan 13 makinalı bir X terminalleri ağındaki makinalarda 262 sayfalık bir Excel dosyasının 1 saniyede açıldığından Linux listelerinde bahsedilmişti.
    </para><para>
Bu projenin amacı sadece bu işlemi belgelendirmektir. Bir dağıtım yapılması amaçlanmamış, Linux'u kuracak ve üzerinde basit bir kaç işlem yapabilecek kadar Linux bilen biri tarafından uygulanabilecek bir işlemin belgelendirilmesi amaçlanmıştır. Bu belgeyi tamamen okuduktan sonra, başa dönüp işlemleri adım adım uygulamanız yeterli olacaktır. Yetmezse bana yazın, bilmeyenin ne bilmediğini bilmek gibi bir yeteneğim yok <literal>:-)</literal>. Belgeyi daha anlaşılır yapmak isterim, bunun için de sizden geribesleme almaya ihtiyacım var.
    </para><para>
İşe başlarken önce sunucuyu yapılandıracağız. Sunucunun yapılandırılması hem ağdaki makinalardan donanım bilgilerinin toplanması hem de üzerlerinde çalışacak dosyaların hazırlanması için gerekli. Bu dosyalardan çekirdek (<userinput>vmlinuz</userinput>) ve ramdisk eşlemini (<userinput>initrd.img</userinput>) kendimiz hazırlayacağız. <userinput>loadlin.exe</userinput> ise zaten Linux'u kurduğunuz CD'lerin ilkinde vardır. CD'den kurulan Linux'lar <userinput>loadlin.exe</userinput> ile kuruluma başlatılır. Yani yapacağımız işlem Linux kurulumu başlatan işlemin özel bir hali olacak. İşlemin sadece başlatma aşaması olan bellekte çalışan kısmı üzerinde çalışıp diğer kurulum adımlarına hiç girmeyeceğiz. Yani bizim Linux'umuz belleğe yüklenecek, hiç sabit diskle ilgilenmeyecek, hep bellekte çalışacak. Windows'un bu süreç içindeki rolü, sadece işlemi başlatmak. Bir kere Linux çalışmaya başladı mı, Linux tüm sistem kaynaklarını kullanmaya başlıyor, ama sabit disk, disket sürücüsü, CDROM devre dışı; onlara ihtiyacımız yok. Ancak, Linux ile işiniz bittiğinde Windows'a dönmek için makinayı tekrar başlatmaktan başka çare yok. Biz makina açıp kapatmaya alışkın değiliz ama Windows kullanıyorsanız bu kaçınılmaz. Ancak, Linux'u başlatmaya hazır olduğunuzda Linux'u başlatmak için Windows'u kapatmanız gerekmeyecek. Onu Linux sizin yerinize yapar.
    </para><para>
Hiç böyle bir işleme ihtiyacınız olmasa bile bu belgede yazılanları bir kere uygulayın, bu kursu kaçırmayın derim.
    </para>
  </sect1>
  <sect1 xml:id="windows-ve-linux_sunucu">
    <title>Sunucu Makinaya Linux kurulması</title>
    <titleabbrev>Sunucunun Linux olması lazım</titleabbrev>
    <para/><para>
Burada sabit diskimde hem Windows hem Linux olsun diyorsanız, bu konuya dahil değil. Internete de bağlanacak bir makinada Linux çalışmalı. Virüslerle uğraşmak istemiyorsanız buna dikkat edin. Bu makinada sadece Linux olduğunu varsayıyorum. Sunucunuza kuracağınız dağıtım için bir kısıtlama yok. Ama ben Fedora Core kurduğunuzu varsayacağım ve ona göre anlatacağım. Dağıtımların dosya sistemi üzerindeki farklarını biliyorsanız herhangi bir dağıtımı kurabilirsiniz. Ek olarak elinizin altında bir Knoppix CD'si olmalı. Bilgi toplamak için ona ihtiyacımız olacak.
    </para><para>
Linux'u kurarken kurulum size Linux kuracağınız disk bölümünü soracaktır. Kurulum bir disk yapılandırma aracı içerir. Bu disk yapılandırma aracını kullanarak kök disk bölümünü ve takas alanı olarak kullanılacak bölümü kendiniz ayarlayacaksınız. Bunu kurulum kendiliğinden yapabilir ama ona bırakmayın, çünkü bizim üzerinde ramdisk'i yapılandıracağımız küçük bir disk bölümüne ihtiyacımız var. Kök disk bölümü için en az 10 GB yer ayırın, takas alanı olarak 1GB ayırın, özel disk bölümü için ise 100kB bile fazla gelir ama böyle yapmayın, ona da diskinizin boyutuna bağlı olarak büyükçe bir yer ayırın, başka amaçlar için de kullanabilirsiniz. Örneğin indirdiğiniz bazı paketleri ve dosyaları burada tutarsınız. Kök disk bölümü ve takas alanı kurulum sırasında yapılandırılacak. Ayırdığımız ek bölüme kurulum dokunmayacaktır, onu zamanı gelince biz yapılandıracağız. Sisteme kurulacak paketlerin seçimine sıra geldiğinde tam kurulumu seçin, çünkü ağınızda çalışan kullanıcıların hemen herşeye ihtiyacı olacaktır. Onları seçimlerinde özgür bırakmak için tam kurulum yapmalısınız. Kimi GNOME'u sever, kimi KDE'yi, kim çeviri yapar, kimi yazılım geliştirir.     </para><para>
Kurulum sırasında dil olarak türkçeyi seçin, Fedora ve bir çok dağıtım artık tamamen türkçe kuruluma sahip, kurulumdan sonra çoğu uygulama sizinle türkçe iletişim kuracak. Çeviri ekiplerimiz iyi çalışıyor, haklarını vermek ve türkçe kurulumu seçmek sonra da bir çeviri ekibine katılıp destek olmak lazım.
    </para><para>
Ağ yapılandırmasında makinanıza olması gerektiği gibi bir isim verin, yani <filename>isim.alan.uzantı</filename> biçiminde bir isim seçin. Ben belge içinde sunucu isminin <filename>nilgun.buguner.home</filename> olduğunu varsayacağım. Siz de bu ismi kendi verdiğiniz makina ismi ile değiştireceksiniz. Yine kurulum sırasında ağ yapılandırmasında makinanızın ağ kartına sabit bir IP adresi atayın. Bu numarayı yerel ağlara ayrılmış olan ve internette kullanılmayan IP ailelerinden seçmelisiniz. Hatırlaması kolay olduğu için ben hep <filename>10.0.0.0</filename> ailesini tercih ederim. Ben sunucucu makinasının iç ağa bakan ağ kartının IP adresinin <filename>10.10.10.1</filename>, ağ maskesinin (netmask) <filename>255.255.255.0</filename>, ağ geçidi adresinin (gateway address) <filename>10.10.10.254</filename> olduğunu ve <filename>10.10.10.0</filename> ağına (network address) hizmet verdiğini varsayacağım. Yani ağınızdaki makinalara 10.10.10.2 ile 10.10.10.253 arasındaki herhangi bir adresi atayabileceksiniz. Makinanızda dış ağa bağlanmak için başka bir ağ kartı varsa ona atanacak isim ve adres konumuz dışında. Kurulum bitip sistemi başlattıktan sonra sistem üzerinde bazı yapılandırmalarla uğraşacağız.
    </para><warning><para>
Burada önemli gördüğüm bir noktayı vurgulamadan geçmek istemiyorum. Makinanın iç işlemler için kullandığı IP adresi <filename>127.0.0.1</filename>'dir ve bu numara ile ilişkilendirilen isim <filename>localhost.localdomain</filename>'dir. Bu standart ismi değiştirmiyoruz. Ya da bu adresle ilişkilendirilecek bir isim ataması yapmıyoruz. Yaparsanız saçma sapan hatalarla ceremesini siz çekersiniz. Benden söylemesi. Hele bu numaraya isim nasıl atanır bilmiyorsanız, bunu bana hiç sormayın. Bir ağ sunucusunun ya da istemcisinin bu isme ihtiyacı olmaz.
    </para></warning><para>
Kurulumu bitirdiğinize göre sistemimizi yapılandırmaya hazırız demektir. Önce ağdaki makinalara IP adreslerini dağıtacak DHCP sunucusunu yani <userinput>dhcpd</userinput>'yi yapılandıracağız. Bunun ardından Samba'yı yapılandıracağız. Sonrada ağdaki windows'ların birinde Samba ile ilgili ayarlarını yapacağız. Bu makinayı sunucu makinanın yanına alıp istemcilerde çalışacak linux'u yapmaya başlayacağız. Bu makina üzerinde edindiğiniz deneyimle diğerleri için farklı bir yapılandırma gerekiyorsa onları artık "makinayı sunucunun yanına almadan" yapacaksınız.
    </para><para>
Eğer sistem GNOME oturumuyla açılıyorsa (genelde böyledir), <filename>root</filename> dışında tanımladığınız diğer kullanıcı ismiyle oturumu açın. GNOME oturumu açıldıktan sonra bir konsol açın ve <userinput>su</userinput> komutunu verin. Parola isteyecektir. <filename>root</filename> kullanıcısı için tanımladığınız parolayı verin. Artık root yetkilerine sahipsiniz. Yani sistem üzerinde her türlü işlemi yapmaya yetkilisiniz, çok dikkatli olun, bir dosya silerseniz kurtarma şansı yok, gitti-gider. <userinput>mc</userinput> komutu ile Midnight Commander'ı çalıştırın. Bir Norton Commander klonudur. Acemilik çekmeyeceksiniz. <userinput>cd /etc</userinput> komutu ile <filename>etc</filename> dizine geçin ve <filename>hosts.allow</filename> dosyasını bulun. <filename>F4</filename> ile dosyayı düzenleme kipinde açın. İçini aşağıdaki dosyaya benzer şekilde düzenleyin:
    </para>
<screen># Bu dosyada yerel ag hizmetlerinden hangi makinalarin
# faydalanabilecegi belirtilir.
#
ALL: .buguner.home
ALL: 127
</screen><para>
<literal>.buguner.home</literal> yerine makinanıza verdiğiniz ismin <literal>.alan.uzantı</literal> kısmını yazacaksınız. Başındaki noktaya dikkat! Gerekli değişikliği yaptıktan sonra <filename>F2</filename> ile kaydedin ve çıkın (<filename>ESC ESC</filename>). Artık dosya düzenlenecek dediğimde ne yapılacağını biliyorsunuz: mc çalıştırılacak, dizine geçilecek, kürsör dosyanın üzerine getirilecek, F4 ile dosya açılacak, değişiklikler yapılacak, F2 ile kaydedilecek ve ESC ESC ile düzenleme kipinden çıkılacak.
      </para><sect2 xml:id="windows-ve-linux_dhcpd" chunkthis="1">
      <title>DHCPD Yapılandırması</title>
      <titleabbrev>Ağdaki makinalara birisi IP adreslerini dağıtmalı</titleabbrev>
      <para>
DHCP sunuculuğu yapan uygulamanın ismi <userinput>dhcpd</userinput> ve <userinput>dhcpd</userinput>'nin yapılandırma dosyası <filename>/etc/dhcpd.conf</filename>'dur. Alışılagelen, bir DHCP sunucunun bir DNS sunucusu ile birlikte çalışmasıdır. DNS sunucusu her Linux dağıtımında bulunur. Ama biz kullanmayacağız. Küçük Windows ağlarında istemci Windows'lar sunucularına kendi isimlerini kendileri gönderirler. Kuracağımız X terminali ağında ise Linux'ların sadece sunucuya bağlanana kadar ve sadece IP adresine ihtiyaçları olur, bağlandıktan sonra ise bu adresin önemi kalmaz, her türlü işlem için sunucu makinanın IP adresini ve ismini kullanırlar. Yani bir DNS sunucusuna asla ihtiyacımız yok. İsim çözümlemesi de gerekmiyor, yani <filename>hosts</filename> dosyası filan düzenlemeyeceğiz. Samba kendi ile ilgili kısmı kendisi zaten hallediyor olacak.
      </para><para>
Bir önceki bölümde makinadan yararlanabilecek harici makinaların hangi ağdan gelebileceklerini belirlemiştik. Bunun dışında bir istek daha DHCP sunucuna gelmeden durdurulacağından, DHCP sunucuna gelen her isteğe sen kimsin nesin diye sormadan istediği IP adresini verebiliriz. <filename>/etc/dhcpd.conf</filename> dosyasını bu politika doğrultusunda düzenliyoruz. Eğer <filename>/etc</filename> dizininde bu dosya yoksa <userinput>touch dhcpd.conf</userinput> komutu ile dosyayı oluşturun. Eğer bir önceki bölümde anlatılan <filename>hosts.allow</filename> dosyasını düzenlemeden buraya geçtiyseniz bir önceki sayfaya geçip bu işlemi yapın. Bu, sistem güvenliği ile ilgili temel bir yapılandırmadır.
      </para><para>
<screen>allow booting;
allow bootp;
ddns-update-style none;

option domain-name "buguner.home";
max-lease-time 720;
default-lease-time 360;

subnet 10.10.10.0 netmask 255.255.255.0 {
  server-name "nilgun.buguner.home";
  pool {
    range 10.10.10.2 10.10.10.253;
    allow all clients;
  }
}</screen>
      </para><para>
Şimdi <userinput>dhcpd</userinput>'yi başlatalım ve bakalım çalışıyor mu?
       </para><para>
<screen><prompt># </prompt><userinput>/sbin/chkconfig dhcpd on</userinput>
<prompt># </prompt><userinput>/sbin/service dhcpd start</userinput>
dhcpd başlatılıyor:                                                [  TAMAM  ]
<prompt># </prompt><userinput>netstat -Nlp | grep dhcp</userinput>
udp        0      0 0.0.0.0:bootps          0.0.0.0:*
¬   1181/dhcpd
raw        0      0 0.0.0.0:icmp            0.0.0.0:*               7
¬   1181/dhcpd
</screen>
       </para><para>
Çalışıyormuş <literal>:-)</literal>. İlk komut, <userinput>dhcpd</userinput>'nin makinanın her açılışında çalışmasını sağlayacak düzenlemeyi yapar, ikinci komut ise hizmeti hemen başlatır. Makinamızı bu işlem için açıp kapatmak zorunda kalmadık. Eğer <userinput>dhcpd</userinput>'yi başlattığınızda yukarıdakinden farklı olarak bazı iletiler alıyorsanız <filename>dhcpd.conf</filename> dosyanızda birşeyler yanlış olmuş demektir. Bu takdirde gerekli düzeltmeyi yapıp, birinci komut hariç işlemi tekrarlayın. <literal>1181/dhcpd</literal> sizin çıktınızda farklı olabilir. <literal>1181</literal>, <userinput>dhcpd</userinput>'nin süreç kimlik numarasıdır (PID).
      </para>
    </sect2><sect2 xml:id="windows-ve-linux_samba" chunkthis="1">
      <title>Samba ve Ağ Yapılandırması</title>
      <titleabbrev>Ağdaki Windows'lara bir yönetici lazım</titleabbrev>
      <para>
Samba'yı da yapılandırdıktan sonra sunucu makinamız, windows ağına hizmet vermeye hazır olacak. Diğer işlemler için acele etmenize gerek kalmayacak.
      </para><para>
Samba yapılandırmasını anlatan çok belge var ama burada yapacağımız yapılandırmayı anlatan bir belge yok. Onun için bildiklerinizi bir kenara bırakıp buradaki adımları dikkatle yapın.
      </para><para>
Önce <filename>/etc/samba</filename> dizindeki <filename>smb.conf</filename> dosyasını yapılandıracağız. Aşağıdaki satırları yeni açacağınız <filename>smb.conf</filename> dosyasına kopyalayın ve kaydedip çıkın.
      </para><para>
<screen>[global]
        workgroup = LAB
        security = SHARE
        null passwords = Yes
        guest account = depocu
        passdb backend = guest
        domain logons = Yes
        mangle case = Yes

[netlogon]
        comment = Sistemle ilgili dosyalar
        path = /export/netlogon
        write list = root
        guest ok = Yes

[depo]
        comment = Dosya Deposu
        path = /export/depo
        write list = guest
        force user = depocu
        force group = users
        read only = No
        guest ok = Yes
</screen>
      </para><para>
Bu yapılandırmada Samba daha çok bir dosya sunucusu olarak çalışıyor. Kullanıcıların kimlikleri ile ilgilenmiyor. Samba'ya kullanıcılar değil Windows sisteminin kendisi oturum açıyor ve tüm paylaşımlar için yapay bir kullanıcı kimliği belirtiyor.  Yani <literal>[depo]</literal> paylaşımına tüm Windows kullanıcıları dosya yazıp silebiliyor.
       </para><para>
Ama bu yapılandırma dosyasında bir çelişki var. <literal>security = SHARE</literal> satırı ile <literal>domain logons = Yes</literal> satırı Samba'ya göre teorik olarak bir arada olamazlar. Yani bir paylaşım sunucusu aynı zamanda bir kullanıcının bir makina kimliği bile olsa oturum isteği yaptığı bir sunucu ile birlikte olamaz. <userinput>testparm -s</userinput> komutunu verdiğinizde Samba bunu size belirtecektir. Herşeye rağmen bizim bu çelişkiye ihtiyacımız var. Samba sunucusunu çalıştırmadan önce bu dosyada yazılı yapılandırmaların gereğini yapmamız lazım.
      </para><para>
<literal>[netlogon]</literal> paylaşımını Linux için gereken dosyaları bulunduracağımız dizin olarak tasarladım. Windows kullanıcıları bu paylaşımdaki dosyaları değiştiremeyeceker ve silemeyecekler. Bu paylaşımla erişilecek dizinleri oluşturalım:
      </para><para>
<screen># <userinput>cd /</userinput>
# <userinput>mkdir export</userinput>
# <userinput>cd export</userinput>
# <userinput>mkdir netlogon</userinput>
</screen>
      </para><para>
<screen>        force user = depocu
        force group = users
</screen>
      </para><para>
Satırlarına dikkatinizi çekerim. <filename>depocu</filename> kullanıcısını oluşturmamız lazım; ayrıca, bu kullanıcının parolasız bir kullanıcı olması lazım:
      </para><para>
<screen># <userinput>/usr/sbin/useradd -g users -d /export/depo depocu</userinput>
# <userinput>passwd -l depocu</userinput>
Locking password for user depocu.
passwd: Success
</screen>
      </para><para>
Windows'lara "domain logon" yaptıracağımız için, Samba'ya makina isimlerini de tanıtmamız lazım. Ben işlemi bir makina için yapacağım, siz ağınızdaki bütün makinalar için yapacaksınız.
      </para><para>
<screen># <userinput>/usr/sbin/useradd -g users -d /dev/null -c "ws belma" -s /bin/false belma$</userinput>
# <userinput>passwd -l belma$</userinput>
Locking password for user belma$.
passwd: Success
# <userinput>smbpasswd -a -m belma</userinput>
Added user belma$.
</screen>
      </para><para>
Makina hesapları makina isimlerinin sonuna <literal>$</literal> işareti eklenerek oluşturuluyor. Bir ev dizinleri yok. Onlara bir kabuk da açılmadığı gibi parolaları da yok. Bir sistem kullanıcısı olarak işlem görüyorlar. Burada benim hesap açtığım makinanın ismi <literal>belma</literal> ve <literal>users</literal> grubunun bir üyesi.
      </para><para>
Yapılandırmamız bitti. Samba sunucusunu çalıştıralım ve neler yapmışız görelim:
      </para><para>
<screen># <userinput>/sbin/chkconfig smb on</userinput>
# <userinput>/sbin/service smb start</userinput>
Starting SMB services:                                             [  TAMAM  ]
done.
# <userinput>smbclient -L localhost -U%</userinput>
Server's Role (logon server) conflicts with share-level security
Domain=[LAB] OS=[Unix] Server=[Samba 3.0.4]

        Sharename       Type      Comment
        ---------       ----      -------
        netlogon        Disk      Sistemle ilgili dosyalar
        depo            Disk      Dosya Deposu
        IPC$            IPC       IPC Service (Samba 3.0.4)
        ADMIN$          IPC       IPC Service (Samba 3.0.4)
Domain=[LAB] OS=[Unix] Server=[Samba 3.0.4]

        Server               Comment
        ---------            -------
        NILGUN               Samba 3.0.4

        Workgroup            Master
        ---------            -------
        LAB
</screen>
      </para><para>
Sunucumuz gayet sağlıklı çalışıyor. Malum çelişkili durum bu çıktıda da belirtilmiş ama onu bilerek öyle yaptım. Windows'ları yapılandırmaya geçmeden önce bunu neden yaptığımı açıklayayım. Üzerinde bu çalışmaları yaptığım w98,
"domain logon" işlemi yapılmadığı zaman bazan kullanıcı girişlerinde Samba'ya bağlanmayabiliyordu. Ama "domain logon" işlemini yapmaya zorladığımda hiç kaçma şansı yok. Kendisi kullanıcıdan önce Samba'ya bağlanmak zorunda :-)...
N'apalım. O mu yaman ben mi... Şimdi sesler gelecek bir yerlerden w98'ler "domain logon" yapmazlar diye, kim demiş, öyle de bir yaparlar ki... benim elime düşmemişler... Neyse, latife bir yana w95 ve w98'ler için bir paket var onu şimdiden indirin bu işi w98'e yaptıran herşey o paketin içinde: <link xlink:href="http://support.microsoft.com/default.aspx?kbid=142794"/> adresinden <userinput>nexus.exe</userinput>'yi indirin. 1 MB'lık küçük bir paket.
    </para></sect2><sect2 xml:id="windows-ve-linux_w" chunkthis="1">
    <title>Windows'ların Samba sunucusuna bağlanması</title>
    <titleabbrev>Windows'lar üzerinde yapılacak ayarlar</titleabbrev>
      <para>
İlk iş, Windows'ları "domain logon" işlemini olmadan Samba'ya bağlanmak olacak.
Ondan önce, indirdiğiniz <userinput>nexus.exe</userinput> dosyasını <filename>/export/depo</filename> dizinine koyun, bağlandığınızda onu oradan alıp kuracaksınız ve ondan sonra "domain logon" işlemi yani ilk oturumu makinanın açtığı işlem devreye girebilecek.
      </para><para>
Şimdi Windows kurulu makinalardan birinin başına geçin ve aşağıdaki işlemleri yapın. Benim kullandığım w98 ingilizce olduğundan yanlarında ingilizce terimlerin türkçe karşılıklarını da vereceğim ama Windows türkçesi ile tam uyumlu olmayabilir.
      </para><para><orderedlist><listitem>
<emphasis>Network Neighborhood</emphasis> [Ağ Komşuları] simgesine farenin sağ tuşu ile tıklayın.
      </listitem><listitem>
Açılan menüden <emphasis>Properties</emphasis>'e [Özellikler] tıklayın.
      </listitem><listitem><para>
Açılan pencerede <emphasis>Identification</emphasis> [Kimlik Bilgileri] sekmesine tıklayın ve alanları aşağıdakine benzer şekilde doldurun:
</para><para><literallayout>
<emphasis>Computer name</emphasis> [Makina ismi]: BELMA
<emphasis>Workgroup</emphasis> [Çalışma Grubu]: LAB
<emphasis>Computer Description</emphasis> [Açıklama]: Windows 98 workstation
</literallayout>
      </para></listitem><listitem>
<emphasis>Access Control</emphasis> [Erişim Denetimi] sekmesine tıklayın ve burada <emphasis>Share-level access control</emphasis> [Paylaşım seviyesinde erişim denetimi] düğmesini seçili duruma getirin.
      </listitem><listitem>
<emphasis>Configuration</emphasis> [Yapılandırma] sekmesine tıklayın ve listeden <emphasis>Client for Microsoft Networks</emphasis> [Microsoft Ağları için İstemci] satırını seçin ve <emphasis>Properties</emphasis> [Özellikler] düğmesine tıkayın.
      </listitem><listitem>
<emphasis>Log on to Windows NT domain</emphasis> [Windows NT alanına Bağlan] kutucuğunu işaretli duruma getirin ve <emphasis>Windows NT domain</emphasis> alanına LAB yazın. Windows NT alanına yani bizim sistemimiz için Samba sunucuya makinanın oturum açmasını sağlayacak olan bu bölümde yapılan işlemdir. Ancak <userinput>nexus.exe</userinput> kurulumunu yapıldıktan sonra bu yapılandırma bir işe yarayacak. Şimdilik bir hükmü yok.
      </listitem><listitem>
<emphasis>Network logon options</emphasis> [Ağ oturumu seçenekleri] bölümünde ise <emphasis>Logon and restore network connections</emphasis> [Oturumu aç ve ağa bağlan] düğmesini seçili duruma getiriyoruz ve OK'e [TAMAM] basıp çıkıyoruz.
      </listitem><listitem>
Yine listeden Ağ kartının TCP/IP ayarları satırını seçiyoruz ve <emphasis>Properties</emphasis> yani Özellikler düğmesine tıklıyoruz.
      </listitem><listitem>
<emphasis>Gateway</emphasis> [Ağ Geçidi] sekmesinde <emphasis>New gateway</emphasis> [Yeni ağ geçidi] alanına 10.10.10.254 yazıp <emphasis>Add</emphasis> [Ekle] düğmesine tıklıyoruz.
      </listitem><listitem>
<emphasis>Wins Configuration</emphasis> [Wins Yapılandırması] sekmesine tıklayıp, En alttaki <emphasis>Use DHCP for WINS Resolution</emphasis> [WINS çözümlemesi için DHCP kullanılsın] düğmesini seçili duruma getiriyoruz. Eğer bu seçenek erişilebilir değilse, <emphasis>IP Address</emphasis> sekmesinden <emphasis>Obtain  an IP address automatically</emphasis> [IP adresini özdevinimli al] düğmesini seçili duruma getirdikten sonra geri dönüp DHCP ile bağlanma işlemi yapıyoruz.
      </listitem><listitem>
Buradaki işimiz bu kadar. OK düğmesine tıklayıp buradan çıkıyoruz.
      </listitem><listitem>
Son olarak <emphasis>Primary Network Logon</emphasis> [Birincil Ağ Oturumu] alanında listeden <emphasis>Windows Logon</emphasis>'u [Windows Oturumu] seçtikten sonra OK düğmesine tıklıyoruz. Bu noktada Windows sizden yeniden başlatılmayı talep edecektir. İzin verin, yapsın.
      </listitem></orderedlist></para><para>
Sistem açıldığında kullanıcı ismi ve parola istenen alana bir isim yazın, parola isteğe bağlı. Yazacağınız ismin Linux üzerinde tanımlı olması gerekmiyor. Her kullanıcı Windows üzerinde kendine bir isim seçip onunla bağlanmakta özgür. Ancak tek yapMAMAsı gereken <emphasis>Cancel</emphasis> [İptal] düğmesine tıklamak. O zaman kullanıcı Sambaya bağlanamayacaktır. OK düğmesine tıklayıp oturum açıldığında Samba üzerindeki paylaşımları Windows Explorer [Dosya Yöneticisi]nde Ağ komşularının altındaki NILGUN adı altında görüyor olacaksınız. Eğer göremiyorsanız oturumu sonlandırıp, aynı kullanıcı ismiyle tekrar sisteme giriş yapın (makinayı yeniden başlatmayacaksınız sadece kullanıcının oturumdan çıkmasını sağlayacaksınız -- Windows türkçesini bir türlü öğrenemedim...)
      </para><para>
Daha önce Linux sistemindeki <filename>/export/depo</filename> dizinine koyduğumuz <userinput>nexus.exe</userinput> dosyası depo paylaşımı altında sizi bekliyor olacak. Onu <filename>c:\temp</filename> dizinine kopyalayıp orada çalıştırın. İçinden bir sürü dosya çıkacak. Sırayla <emphasis>Start</emphasis> [Başlat] -> <emphasis>Settings</emphasis> [Ayarlar] -> <emphasis>Control Panel</emphasis> [Denetim Masası] menü alanlarına tıklayın. <emphasis>Add/Remove Programs</emphasis> [Program Ekle/Kaldır]'a tıklayın. Açılan pencerede önce <emphasis>Windows Setup</emphasis> [Windows Kurulumu] sekmesine sonra da <emphasis>Have Disk</emphasis> [Diski Var] düğmesine tıklayın. Dosya araması ile <filename>c:\temp</filename> dizine gidin, oradaki tek <filename>.inf</filename> dosyası olan <filename>Srvtools.inf</filename> dosyasını kendi bulacak. Tamam'a tıkladığınızda kurulum gerçekleşecek. Bundan sonra makinayı yeniden başlattığınızda Samba'ya gayet hızlı bir biçimde bağlanacak ve paylaşımları göreceksiniz. <userinput>nexus.exe</userinput> paketinden çıkan uygulamalar bu yapılandırma altında beklendiği gibi çalışmayacaktır. Böylesi daha iyi aksi takdirde Linux makinasındaki tüm kullanıcılar (gizli sistem kullanıcıları dahil) görüntüleniyor.
      </para><para>
Bu işlemleri her makinaya farklı isimler vererek tekrarlayın. İşlemler bittiğinde Windows ağınız kullanıma hazır olacak.
      </para><para>
Ağa sunucu olarak Linux üzerinde Samba'yı yerleştirip ağı tekrar çalışır duruma getirdiğinize göre artık, X terminallerinizi yapılandıracak işlemlere başlayabilirsiniz. Bunların o kadar acelesi olmayacaktır. Önce donanımları aynı olan makinalarla başlar, sonra diğer makinalara zaman içinde uygularsınız. Sunucu makinayı artık X terminallerine hizmet verecek şekilde yapılandırmaya başlayabiliriz.
      </para></sect2><sect2 xml:id="windows-ve-linux_xfs" chunkthis="1">
      <title>XFS yapılandırması</title>
      <titleabbrev>X terminallerine bir yazıtipi sunucusu lazım</titleabbrev>
      <para>
<userinput>xfs</userinput>, X Pencere Sisteminin yazıtipi sunucusudur (XFS - X Font Server). İstemci makina üzerine kurulacak ramdiske X yazıtiplerini ve xfs sunucusunu koymayacağız. İstemci makinanın X Pencere Sistemi sunucu makinadaki <userinput>xfs</userinput> sunucusunu kullanacak.  Bunun için bu makinadaki <userinput>xfs</userinput> sunucusunu dinlemeye almamız lazım. Hemen yapalım:
       </para><para>
<filename>/etc/X11/fs/config</filename> dosyasının en alt satırına gidin,
       </para><para>
<screen># don't listen to TCP ports by default for security reasons
no-listen = tcp
</screen>
       </para><para>
son satırı iptal edeceğiz ki, <userinput>xfs</userinput> ağdan gelen istekleri dinlesin:
       </para><para>
<screen># don't listen to TCP ports by default for security reasons
# no-listen = tcp
</screen>
       </para><para>
Eğer <userinput>xfs</userinput>'i kullanmıyorsanız başlatın, ben kullanıyordum, yeniden başlatıyorum ve dinlemeye geçmiş mi bakıyorum:
       </para><para>
<screen># <userinput>/sbin/chkconfig xfs on</userinput>
# <userinput>/sbin/service xfs restart</userinput>
xfs yeniden başlatılıyor:
xfs durduruluyor:                                                  [  TAMAM  ]
xfs başlatılıyor:                                                  [  TAMAM  ]
<prompt># </prompt><userinput>netstat -Npl | grep xfs</userinput>
tcp        0      0 0.0.0.0:xfs             0.0.0.0:*               LISTEN
¬   1249/xfs
unix  2      [ ACC ]     STREAM     LISTENING     9433   1249/xfs
¬   /tmp/.font-unix/fs7100
</screen>
       </para><para>
Bu da tamamdır.
      </para></sect2><sect2 xml:id="windows-ve-linux_gdm" chunkthis="1">
      <title>GDM yapılandırması</title>
      <titleabbrev>Bu, X terminallerine hoşgeldiniz diyecek</titleabbrev>
      <para>
GDM, X terminallerin sunucuya bağlanabilmesi için onlarda başlatılmış X oturumlarından gelecek istekleri dinler, bu isteklere GDM oturum açma ekranını gönderir ve kullanıcı girişi bekler. Verilen kullanıcı ismi ve parolası, üzerinde çalıştığı Linux sisteminde tanımlı kullanıcılardan biri ise üzerinde çalıştığı makinanın hemen tüm kaynaklarını oturum açmak isteyen kullanıcıya sunar. Bizim yapılandırmamızda ise kullanıcı 10 saniye içinde bir isim ve parola girmezse öntanımlı kullanıcı ismiyle sunucuya bağlanabiliyor. Ayrıca GDM, sadece terminalleri yönetiyor. Sunucu makina üzerinde bir X oturumu açılmak istenirse normal bir X oturumu olarak çalıştırılabilir.
       </para><para>
<userinput>gdm</userinput> yapılandırması <filename>/etc/X11/gdm/gdm.conf</filename> dosyasında yapılıyor. Masaüstünde çalışan görsel bir GDM yapılandırma uygulaması olmasına rağmen biz onu kullanmayacağız. Çünkü bu yapılandırmayı yapabilmek için yeterli değil. <filename>/etc/X11/gdm/gdm.conf</filename> dosyasının içeriğini aşağıdaki örneğe göre düzenleyin:
       </para><para>
<screen>[daemon]
# X terminallerinden bir kullanıcı 10 saniye içinde bir kullanıcı ismi ve
# parolası girmezse "talebe" kullanıcısı ile oturum açılacak.
# Bunu aşağıdaki seçeneklerle sağlıyoruz. "talebe" için makinada bir
# parolasız bir hesap tanımlanmış olmalı.
TimedLoginEnable=true
TimedLogin=talebe
TimedLoginDelay=10

# X terminallerinin bağlanması için kullanıcıya gösterilen oturum
# açma ekranını çalıştıran komut. Ağ yükü ağır gelirse daha basit
# görünümdeki gdmlogin ile değiştirebilirsiniz.
#RemoteGreeter=/usr/bin/gdmlogin
RemoteGreeter=/usr/bin/gdmgreeter

# gdm'nin sistem üzerinde çeşitli amaçlar için kullandığı kullanıcı ve
# grup ismi. Bunlara dokunmuyoruz.
User=gdm
Group=gdm

# gdm'nin günlük kayıtlarını tuttuğu dizin ve süreç kimliğini sakladığı dosya.
# Dokunmuyoruz, bilgi için kalsın.
LogDir=/var/log/gdm
PidFile=/var/run/gdm.pid

# X terminallerine oturum açmadan önce açarken ve açtıktan sonra
# yapılan eylemlerle ilgi yapılandırma. Dokunmuyoruz.
PostLoginScriptDir=/etc/X11/gdm/PostLogin/
PreSessionScriptDir=/etc/X11/gdm/PreSession/
PostSessionScriptDir=/etc/X11/gdm/PostSession/
DisplayInitDir=/etc/X11/gdm/Init

# X çökerse çalıştırılacak betik. Dokunmuyoruz.
XKeepsCrashing=/etc/X11/gdm/XKeepsCrashing

# Kimlik denetimi ile ilgili kayıtların tutulacağı dizin. Dokunmuyoruz.
ServAuthDir=/var/gdm

# Hangi masaüstünün çalıştırılacağının saptandığı betik.
BaseXsession=/etc/X11/gdm/Xsession

# Kullanıcı yetkilendirmesi ile ilgili X dosyaları için.
# Kullanıcının ev dizini yazılabilir değilse bu dizin kullanılacak.
UserAuthFBDir=/tmp
UserAuthFile=.Xauthority

# X sunucusu
StandardXServer=/usr/X11R6/bin/X

# X nest komutu
Xnest=/usr/X11R6/bin/Xnest -audit 0 -name Xnest

# Sistemde 6 tane kullanılabilir metin konsolu var (tty1-6).
# 7. konsolu bu makina üzerinde çalıştırılacak X oturumuna ayırıyoruz.
# Dolayısıyla bir terminalin alabileceği ilk konsol 8. olacak.
# /etc/securetty dosyanızdaki tty'ler tüm X terminallerinize yetmiyorsa
# sayısını arttırın.
FirstVT=8
VTAllocation=true


[security]
# X terminallerinden root kullanıcısının oturum açmasına izin vermiyoruz.
AllowRemoteRoot=false

# Terminallerden 10 saniye içinde giriş yapılmazsa oturumun "talebe"
# kullanıcısı ile açılmasına izin veren seçenek.
AllowRemoteAutoLogin=true

# yazma yetkisi: 0 kullanıcı, 1 grup, 2 herkes
# Bu yapılandırmada hiçbir önemi yok. Dokunmuyoruz.
RelaxPermissions=0

# gdm'nin terminallerden gelen istekleri dinlememesini sağlayan seçenek.
# Bu yapılandırma dinlemesini gerektiriyor.
DisallowTCP=false


[xdmcp]
# Standart xdmcp portu olan 177/udp portunun dinlenmesini sağlar.
Enable=true


[gui]
# Burada değiştireceğimiz bir şey yok.


[greeter]
# Oturum açma ekranı ile ilgil görsel ayarlar.

# Paneldeki saatin 24 saatlik olmasını isteriz.
Use24Clock=true

# Oturum açma ekranında kullanılan tema ve temaların bulunduğu yer.
#GraphicalTheme=circles
GraphicalThemeDir=/usr/share/gdm/themes/


[chooser]
# chooser, ağdaki diğer X terminal sunucularını listesini gösterir.
# Oturumun seçilen sunucuda açılmasını sağlar.
# Bu seçenekler çok sayıda X terminal sunucusu çalıştıracaksanız anlamlı.

#DefaultHostImg=/usr/share/pixmaps/nohost.png
# Directory with host images, they are named by the hosts: host or host.png
HostImageDir=/usr/share/hosts/
# Time we scan for hosts (well only the time we tell the user we are
# scanning actually, we continue to listen even after this has
# expired)
#ScanTime=4
# A comma separated lists of hosts to automatically add (if they answer to
# a query of course).  You can use this to reach hosts that broadcast cannot
# reach.
Hosts=
# Broadcast a query to get all hosts on the current network that answer
Broadcast=true
# Set it to true if you want to send a multicast query to hosts.
Multicast=false
# It is an IPv6 multicast address.It is hardcoded here and will be replaced when
# officially registered xdmcp multicast address of TBD will be available
#Multicast_Addr=ff02::1
# Allow adding random hosts to the list by typing in their names
#AllowAdd=true

[debug]
# Hata ayıklama iletilerini isterseniz true yapın.
Enable=false

[servers]
# gdm'nin bu makina üzerindeki X oturumunu da yönetmesini istiyorsanız
# bu satırlardan ilkini etkinleştirin. İkisini de etkinleştirebilirsiniz.
#0=Standard
#1=Standard

[server-Standard]
# servers bölümündeki ayarlara bağlı olarak buradaki seçenekler
# anlam kazanır.
name=Standard server
command=/usr/X11R6/bin/X -audit 0
flexible=true

[server-Terminal]
# Bu X terminal sunucusu.
name=Terminal server
command=/usr/X11R6/bin/X -audit 0 -terminate
# Make this not appear in the flexible servers (we need extra params
# anyway, and terminate would be bad for xdmcp choosing).  You can
# make a terminal server flexible, but not with an indirect query.
# If you need flexible indirect query server, then you must get rid
# of the -terminate and the only way to kill the flexible server will
# then be by Ctrl-Alt-Backspace
flexible=false
# Not local, we do not handle the logins for this X server
handled=false

[server-Chooser]
# Diğer sunucuları seçmeyi sağlayan ekran.
name=Chooser server
command=/usr/X11R6/bin/X -audit 0
</screen>
       </para><para>
Yapılandırma dosyasında bir öntanımlı kullanıcı belirtmiştik. Şimdi o kullanıcı için sistemde bir hesap açalım. Bu kullanıcının parolası olmayacak:
       </para><para>
<screen># <userinput>/usr/sbin/useradd -g users talebe</userinput>
# <userinput>passwd -l talebe</userinput>
</screen>
       </para><para>
Bu komutlarla sisteme talebe kullanıcısını tanımlamış olduk. Artık dosya sisteminde bir <filename>/home/talebe</filename> dizini var. X terminallerinden bir kullanıcı ismi belirtmeden oturum açan bütün kullanıcılar bu dizini ev dizini olarak ortak kullanacaklar. Bu hoş bir durum değil, kullanıcılara istedikleri takdirde bir kullanıcı ismi vermeniz daha iyi olur. Diğer yandan sahipsiz kalmış kullanıcı isimlerine ait ev dizinlerinin varolacak olması da sizin açınızdan hoş olmayabilir. Karar sizin. Her iki durum da bu yapılandırma ile mümkün.
       </para><para>
<filename>/home/talebe</filename> dizininde <filename>.dmrc</filename> adıyla bir dosya açın ve içine aşağıdakileri yazın:
       </para><para>
<screen>[Desktop]
Session=kde
Language=tr_TR.UTF-8
</screen>
       </para><para>
Bu dosyayı oturum açarken <userinput>gdm</userinput> okuyacak ve oturumu türkçe olarak <literal>Session</literal> satırında belirtilen masaüstü yöneticisi ile açacak.
       </para><para>
Şimdi sıra <filename>/etc/inittab</filename> dosyasında. Bu makina üzerinde X oturumunu hiç başlatmaz, siz konsolda kalabilirsiniz ve isterseniz <userinput>startx</userinput> komutu ile bir X oturumu açabilirsiniz. Bir sunucu için en elverişli yöntem budur. <filename>inittab</filename> dosyasını buna göre yapılandırıyoruz ve sadece <literal>initdefault</literal> satırını 3. çalışma seviyesine ayarlıyoruz. Zaten böyleyse dokunmayın:
       </para><para>
<screen>id:3:initdefault:</screen>
       </para><para>
<userinput>gdm</userinput> bu makinada artalanda bir sunucu olarak çalışacağından sistem açılışında çalışmasını sağlamamız lazım. Bunun için <filename>/etc/rc.d/rc.local</filename> dosyasının sonuna:
       </para><para>
<screen>/usr/bin/gdm</screen>
       </para><para>
satırını ekliyoruz.
      </para><para>
Sistemi yeniden başlattığınızda X sunucusu ağdan gelecek istekleri  bekliyor olacak. <userinput>nmap</userinput> ile bakarsanız aşağıdakine benzer bir çıktı alacaksınız:
    </para><para>
<screen><prompt># </prompt><userinput>nmap -sTU 127.0.0.1</userinput>

Starting nmap V. 3.00 ( www.insecure.org/nmap/ )
Interesting ports on localhost (127.0.0.1):
(The 3044 ports scanned but not shown below are in state: closed)
Port       State       Service
22/tcp     open        ssh
67/udp     open        dhcpserver
137/udp    open        netbios-ns
138/udp    open        netbios-dgm
139/tcp    open        netbios-ssn
177/udp    open        xdmcp
445/tcp    open        microsoft-ds
514/tcp    open        shell
901/tcp    open        samba-swat
6000/tcp   open        X11
7100/tcp   open        font-service

Nmap run completed -- 1 IP address (1 host up) scanned in 9 seconds
</screen>
    </para><para>
<literallayout>22/tcp     open        ssh</literallayout> satırı sizde olmayabilir. Ama olacak. Yeri geldiğinde ondan bahsedeceğim.
    </para></sect2>
  </sect1><sect1 xml:id="windows-ve-linux__terminal">
    <title>X Terminal Sisteminin Yapılması</title>
    <titleabbrev>Bu tek kullanıcılı ama ağ bağlantısı kurabilen bir Linux aslında</titleabbrev>
    <para/><para>
Bu kısım bu belgenin en önemli bölümü. Burada en temel Linux sistemini sıfırdan oluşturacağız. Gerekenlerin çoğunu sunucu makinaya zaten kurdunuz. Onlardan bize gerekenleri toplayacağız, biraz da internetten birşeyler toplayacağız, hepsini harmanlayıp, tek kullanıcılı bir Linux yapacağız. Ancak, bu sistem terminal makinalarının sadece belleğinde varolacağından, mümkün olduğunca az yer kaplayan bir sistem olacak. İşimizi görecek olan herşey olacak ama işimizi görecek herhangi bir şeyi değil, en az yer kaplayanını kullanacağız. Önce bize neler lazım bir bakalım:
    </para><para><variablelist><varlistentry>
    <term>Ramdisk oluşturma araçları</term><listitem><para>
Bunlar sisteminizde mevcut.
    </para></listitem></varlistentry><varlistentry>
    <term>Çekirdek</term><listitem><para>
Bir Linux sisteminin olmazsa olmaz parçası, herşeyi yöneten en temel parça.
Herhangi bir Linux çekirdeği işimizi görür. Ben linux-2.4.22 çekirdeğini kullandım. Çekirdeği kendimiz derleyeceğiz. İçinde bize gerekli olmayan hiçbir şey olmamalı ki, bellekte fazla yer işgal etmesin.
    </para></listitem></varlistentry><varlistentry>
    <term>init</term><listitem><para>
Çekirdek kendini yükledikten sonra sistemin kullanıcıya hazırlanmasını sağlayan <userinput>init</userinput>'i çalıştırır. <userinput>init</userinput>'de yapılandırmasına bağlı olarak bazı betikleri çalıştırır.
    </para></listitem></varlistentry><varlistentry>
    <term>Kabuk</term><listitem><para>
<userinput>init</userinput> bazı betikleri çalıştırır dedik mi, o betikleri çalıştıracak bir kabuk gerektiği anlaşılır. Bu kabuk az yer kaplamalı. <userinput>init</userinput> ile <userinput>sh</userinput> kabuğunu ve bir sistem için gereken en temel komutları biraraya getiren bir uygulama var: <link xlink:href="http://busybox.net/downloads/busybox-1.00-pre10.tar.bz2"><userinput>busybox</userinput></link>.
Biz onu kullanacağız. Hemen indirin. Dağıtımlarla gelen bir paket değildir. Böyle çok özel uygulamalar için tasarlanmıştır.
    </para></listitem></varlistentry><varlistentry>
    <term>DHCP istemcisi</term><listitem><para>
Sunucu makinaya bağlanmak için ağ kartını DHCP sunucusundan aldığımız bilgilerle yapılandıracağız. Pek çok DHCP istemcisi var ama biz <userinput>busybox</userinput> içinde yerleşik olarak bulunan <userinput>udhcpc</userinput>'yi kullanacağız.
    </para></listitem></varlistentry><varlistentry>
    <term>X sunucusu</term><listitem><para>
X sunucusu; X'in ismi sunucu. İsmi sunucu da olsa burada X terminal istemcisi olarak çalışacak. X, kendi kütüphaneleri ve modülleri olan devasa bir sistem. Ama biz onu da küçülteceğiz! <userinput>xfs</userinput>'i baştan attık, dolayısıyla yazıtiplerinden kurtulduk. Sunucu kurulumunda hatırlarsanız <userinput>xfs</userinput>'i dinlemeye almıştık. Yazıtiplerini ondan yükleyeceğiz. Daha kullanmayacağımız çok şey bulacağız. Sırası var, sırası gelince ayrıntısına gireceğim.
    </para></listitem></varlistentry></variablelist>
    </para><para>
Çekirdek dışındaki herşey ramdiski oluşturacak olan <filename>initrd.img</filename> dosyası içinde bulunacak. Bu dosya çok özel bir dosya; içinde bir dosya sistemi barındırıyor olacak. Önce bu dosyayı oluşturacağız. Sonra bize uygun bir çekirdek derleyeceğiz. Ardından basit bir Linux oturumu sağlayacak şekilde bir <filename>initrd.img</filename> oluşturup onu deneyeceğiz. En son aşamada ise  <filename>initrd.img</filename> dosyasına X ile ilgili dosyaları yerleştirip X terminalimizi oluşturacağız.
    </para>
    <sect2 xml:id="windows-ve-linux__initrd" chunkthis="1">
    <title><filename>initrd.img</filename> Dosyasının Oluşturulması</title>
    <titleabbrev>Önce sistemi oluşturacağımız altyapıyı hazırlayalım</titleabbrev>
    <para>
Burada, önce kurulum sırasında ayırdığımız ek disk bölümü üzerinde bir dosya sistemi oluşturacağız sonra da onu kök dosya sistemine bağlayacağız. Kök dosya sisteminizin <filename>/dev/hda1</filename> disk bölümünde olduğunu, takas alanının <filename>/dev/hda2</filename> bölümünde olduğunu, ayırdığınız ek disk bölümünün de <filename>/dev/hda3</filename> olduğunu varsayacağım. Hangi disk bölümlerinin ne için kullanıldığını <userinput>sfdisk</userinput> komutu ile öğrenebilirsiniz:
    </para><para>
<screen># <userinput>/sbin/sfdisk -l</userinput>

Disk /dev/hda: 4870 silindir, 255 kafa, 63 sektör/iz
birimler = 8225280 baytlık silindir, 1024 baytlık blok, 0'den başlayarak

                              silindir   blok
   Aygıt Önykl Balangıç Bitiş sayısı   sayısı
/dev/hda1   *      0+   1200    1200-   9647001+  83  Linux
/dev/hda2       1201    1324     123-    987966   82  Linux takas
/dev/hda3       1325+   2525    1200-   9647001       Boş
  ...
</screen>
    </para><para>
Siz tam böyle olmasa da benzer bir liste alacaksınız. Şimdi <filename>/dev/hda3</filename> üzerinde bir ext3 dosya sistemi oluşturalım:
    </para><para>
<screen># <userinput>/sbin/mke2fs -b 1024 -O sparse_super,filetype,has_journal /dev/hda3</userinput>
</screen>
    </para><para>
Bu komut ile blok boyu 1024 bayt olan bir dosya sistemi oluşturduk. Blok boyunu özellikle 1024 bayt olarak seçtim. Çünkü çekirdek ramdiski 1024 baytlık bloklarla oluşturur. Ramdiskin bir örneğini bu disk bölümü üzerinde oluşturacağımızdan doğru boyut raporu alabilmek için 1024 bayt blok boyuna sahip bir dosya sistemine ihtiyacımız var. Kök disk bölümü genelde 4096 baytlık blok boyunda oluştururlur. Onun için kök disk bölümünde bu işi yapmamız doğru olmazdı.
    </para><para>
Oluşturduğumuz dosya sisteminini kök dizine bağlamadan kullanamayız. Onun için <filename>/a3</filename> isminde bir dizin oluşturacağız, sonra da <filename>/dev/hda3</filename>'ü buraya bağlayacağız. Disk bölümünü bağlamadan önce bu disk bölümü ile ilgili bilgiyi <filename>/etc/fstab</filename> dosyasına ek bir satır olarak girelim ki, sistemi her yeniden başlattığınızda bu disk bölümü açılış sırasında <filename>/a3</filename> altına bağlansın:
    </para><para>
<screen># <userinput>echo "/dev/hda3    /a3     ext3    defaults  1 2" >> /etc/fstab</userinput>
# <userinput>mount /a3</userinput>
</screen>
    </para><para>
İlk komutta <filename>/dev/hda3</filename> ile ilgili bilgiyi <filename>/etc/fstab</filename> dosyasının sonuna bir satır olarak ekledik. Bu komutta dikkat edeceğini şey <filename>/etc/fstab</filename>'dan önce iki tane <filename>></filename> konulması gerektiğidir. Bir tane <filename>></filename> koyarsanız dosya silinir va dosyaya sadece bu satır yazılır. Halbuki biz dosya sonuna ek bir satır girmek istiyoruz. Onun için <filename>></filename> işaretinden peşpeşe 2 tane kullanmamız gerekiyor. Dikkatli olun!
    </para><para>
İkinci satırda ise <filename>/dev/hda3</filename>'ü <filename>/a3</filename> dizinine bağladık. Nereden belli? <userinput>mount</userinput> komutu böyle tek parametreli kullanıldığında diğer parametreleri almak için <filename>/etc/fstab</filename> dosyasına bakar. Bu komutu bir daha kullanmayacağız. Bundan sonra sistemi her açtığınızda <filename>/a3</filename> bağlı olacak.
    </para><para>
<filename>/a3</filename> dizinine geçip, bir dizin açıyoruz (ramdisk dizini) ve ramdisk dizinine giriyoruz:
    </para><para>
<screen># <userinput>cd /a3</userinput>
# <userinput>mkdir ramdisk</userinput>
# <userinput>cd ramdisk</userinput>
</screen>
    </para><para>
Bu dizine <userinput>initrdyap</userinput> isminde bir dosya açıyoruz ve bu dosyayı çalıştırılabilir bir dosya yapıyoruz:
    </para><para>
<screen># <userinput>touch initrdyap</userinput>
# <userinput>chmod +x initrdyap</userinput>
</screen>
    </para><para>
Sonra da bu dosyanın içine aşağıdakileri yazıyoruz:
    </para><para>
<screen>#!/bin/bash

compress=1
target="/export/netlogon/autoboot/initrd.img"
rc=0

IMAGESIZE=12000

MNTIMAGE="/a3/ramdisk/initrd"
IMAGE="/a3/ramdisk/initrd.rd"
MNTPOINT="/a3/ramdisk/initrd.mnt"

dd if=/dev/zero of=$IMAGE bs=1k count=$IMAGESIZE 2> /dev/null || exit 1

LODEV=$(echo findlodev | /sbin/nash --quiet)

if [ -z "$LODEV" ]; then
    echo "loopback aygıtlarının hepsi kullanılmış." >&amp;2
    exit 1
fi

/sbin/losetup ${LODEV} $IMAGE || exit 1

echo y | /sbin/mke2fs $LODEV $IMAGESIZE >/dev/null 2>/dev/null
/sbin/tune2fs -i0 $LODEV >/dev/null

if [ -n "$verbose" ]; then
    echo "$LODEV aygıtı kullanılıyor"
fi

mount -t ext2 $LODEV $MNTPOINT || {
        echo "Loopback aygıtı yok"
        exit 1
}

(cd $MNTIMAGE; tar cf - .) | (cd $MNTPOINT; tar xf -) || exit 1

umount $MNTPOINT
/sbin/losetup -d $LODEV

if [ -n "$compress" ]; then
    gzip -9 &lt; $IMAGE > $target || rc=1
else
    cp -a $IMAGE $target || rc=1
fi

exit $rc
</screen>
    </para><para>
Bu betiği adından da anlaşılacağı üzere <filename>initrd.img</filename> dosyasını oluşturmakta kullanacağız. Şimdi bu betiğin çalışması için gereken dizinleri oluşturalım:
    </para><para>
<screen># <userinput>mkdir initrd</userinput>
# <userinput>mkdir initrd.mnt</userinput>
</screen>
    </para><para>
Ramdiski oluşturacağımız dizin <filename>initrd</filename> dizini; <filename>initrd.mnt</filename> dizini boş kalacak. Orayı betik kullanacak.
Betiği şimdi çalıştıracağız ve betik 12000 kB'lık <filename>/a3/ramdisk/initrd.rd</filename> dosyası ile bu dosyanın sıkıştırılmış hali olan <filename>/export/netlogon/autoboot/initrd.img</filename> dosyasını oluşturacak:
    </para><para>
<screen># <userinput>./initrdyap</userinput></screen>
    </para><para>
Komut, herşey yolunda giderse konsolda hiçbir çıktı vermeyecek ve bahsettiğim 2 dosyayı oluşturacak. Konsola bir çıktı veriyorsa bu bir hata iletisidir. Birşeyleri eksik ya da yanlış yapmış olabilirsiniz. Bu betiği kendim yazmadım, <userinput>/sbin/mkinitrd</userinput> betiğinden bizim için gereksiz satırları temizledim ve kalan kodu biraz değiştirdim. (Amerika'yı yeniden keşfetmenin alemi yok). <userinput>/sbin/mkinitrd</userinput>'nin kullandığı yöntem bize <filename>/a3/ramdisk/initrd</filename> dizininde normal bir dizin gibi çalışma imkanı veriyor. Yani oraya yerleştireceğimiz ve kaldıracağımız dosyalar <filename>initrd.img</filename> dosyasında değişiklik bilgisi olarak görünmeyecek. Diğer yöntemlerde görünür ve dosya gereksiz yere şişer.
   </para>
  </sect2><sect2 xml:id="windows-ve-linux_kernel" chunkthis="1">
    <title>Çekirdeğin derlenmesi</title>
    <titleabbrev>Bize küçük bir çekirdek yeter</titleabbrev>
    <para>
Bu belgenin yazıldığı tarihte güncel çekirdek sürümleri 2.6.x idi. Ancak 2.6 çekirdekleri derlemek için sistemin bu çekirdeğe uygun olması gerekir. Benim elimdeki sistem buna uygun olmadığından ben 2.4 çekirdeklerle çalışmak zorundaydım. Yapacağımız iş için çekirdeğin 2.4 ya da 2.6 olmasının bir önemi yok. Ben zaten kullanmakta olduğum 2.4.22 çekirdeğinin kaynak kodunu kullandım.
Siz de kurduğunuz sistemde bulunan çekirdeğin sürümü 2.4 serisinde ise onun kaynak kodunu kullanabilirsiniz. 2.6 çekirdeklerin derlenmesi biraz farklı sanırım (Hiç 2.6 çekirdek derlemedim). Yalnız çekirdeği derledikten sonra onu sisteme kuracağımızdan ismini değiştireceğiz. 2.4.22-x yapacağız ki, sistemde kurulu çekirdekle karıştırmayalım.
   </para><para>
Çekirdeğin kaynak kodunun yeri dağıtımdan dağıtıma değişmez, yeri <filename>/usr/src/linux</filename> dizinidir. <filename>/usr/src/linux</filename> genelde kullanılan çekirdeğin kaynak kodunun bulunduğu dizini işaret eden bir sembolik bağ olarak düzenlenir. Bizim çalışacağımız dizin <filename>/usr/src/linux-2.4.22</filename> dizini olacak.
    </para><para>
X terminalleri için kullanacağımız çekirdek kaynak kodunun sisteminizin çekirdek kaynak kodundan farklı bir yerde durması daha iyidir. <filename>linux-2.4.22-x</filename> diye bir dizin açıp <filename>linux-2.4.22</filename> dizininin içeriğini bu dizine kopyalayın. Daha önce bir çekirdek derlemişseniz yeni açtığınız dizine geçip <userinput>make mrproper</userinput> komutunu verin. Bu komut çekirdek kaynak kodunu sıfırlar. Yani onu hiç derleme yapılmamış duruma getirir. Kaynak kodunu derlememişseniz bu işlemi yapmanıza gerek yoktur. Ancak, birşeyler yanlış gider ve derleme işlemini yinelemek isterseniz derlemeye başlamadan önce vereceğiniz ilk komut bu olmalı.
    </para><para>
Eğer <filename>/usr/src</filename> altında bir linux dizini yoksa ve siz de X terminalleri için 2.4.22 çekirdeğini kullanmak isterseniz, bu çekirdeğin kaynak paketini <link xlink:href="ftp://ftp.kernel.org/pub/linux/kernel/v2.4/linux-2.4.22.tar.bz2"/> adresinden <filename>/usr/src</filename> dizinine indirin ve aşağıdaki komutlarla paketi açın:
    </para><para>
<screen># <userinput>bunzip2 linux-2.4.22.tar.bz2</userinput>
# <userinput>tar xfv linux-2.4.22.tar</userinput>
</screen>
    </para><para>
Bu iki komut kaynak paketini <filename>linux-2.4.22</filename> dizini altında açacaktır. Dizine geçin ve Makefile dosyasını düzenlemek üzere açıp 4. satırı
    </para><para>
<screen>EXTRAVERSION = -x</screen>
    </para><para>
yapın. Bu derlenmiş çekirdeğin ismini <filename>vmlinuz-2.4.22-x</filename> yapacak. Böylece bu çekirdeğin X terminalleri için derlediğimiz çekirdek olduğunu hatırlayacağız. Hatırlamamız lazım da, çünkü bu çekirdekle üzerinde çalıştığınız Linux sistemini açamayacaksınız. Bu çekirdek sadece X terminallerini çalıştırabilecek kadar yeteneğe sahip olacak. Örneğin ağ kartı, fare, ekran kartı ve makinanın belleği gibi temel donanım bilgilerinden başka donanım bilgisi içermeyecek. Sabit diskleri, disket sürücülerini, CDROM'ları ses kartlarını v.s. tanımayacak. Bir terminale bunlar gerekmez.
    </para><para>
Linux çekirdeğini derlemek için iyi derecede İng. bilmek daha da ötesi iyi derecede sistem bilgisi gerekir. Bu derece ayrıntı bu küçük belgenin sınırlarını aşar. Bu bilgi ayrı bir kitap olur.
    </para><para>
Ben sadece çekirdek yapılandırmasının sonucu olan <filename>.config</filename> dosyasının içeriğini vereceğim. Bunun yanında da neyi niçin yaptığım hakkında kısa bir bilgi vereceğim. <link linkend="windows-ve-linux_app1">Yapılandırma dosyasını</link> eklerde bulabilirsiniz. Onu ayrı bir pencerede açıp burada yapacağım açıklamaları oradan izleyebilirsiniz.
    </para><para><itemizedlist><listitem>
14. satırda başlayan bölümde çekirdeğe yüklenebilir modül desteği veriyoruz.
    </listitem><listitem>
21. satırda başlayan bölümde çekirdeğin 386 ve sonraki işlemciler için geçerli olmasını sağlıyoruz. Böylece 386, 486, 586 ve 686 işlemcileri ve bunlarla uyumlu (AMD gibi) çekirdeklerle çekirdeğimiz çalışabilecek. Alt satırlarda bir 386 çekirdeğin desteklemediği hiçbir özelliği çekirdeğe vermiyoruz. 386SX'lerde bu çekirdek çalışmaz. En az 386DX gerekir. Bunların ne olduğunu bilmiyoranız, boşverin. Karşılaşmamışsınız demektir (antika).
    </listitem><listitem>
67. satırda başlayan genel ayarlar bölümünde çekirdeğe, 69. satırda ağ desteği, 70'de PCI desteği ve devamında sistemin genelini etkileyen bazı özel durumlara ilişki destekleri veriyoruz.
    </listitem><listitem>
112. satırda başlayan blok aygıtları bölümünde sadece ramdisk ve initrd ile ilgili destekleri veriyoruz.
    </listitem><listitem>
142. satırda başlayan ağ seçenekleri bölümünde bir linux ağı için gerekli ne varsa bunların desteğini veriyoruz.
    </listitem><listitem>
242. satırda başlayan bölümde ağ aygıtları ile ilgili desteği açıyoruz ve 257. satırda başlayan 10/100 Mbitlik ethernet kartlarının tamamının modül olarak derlenmesini istiyoruz. Piyasadaki en ucuz, en kullanışlı ve en çok kullanılan ağ kartları bunlar. Sizinki bunlardan biri değilse biraz paraya kıyıp bunlardan temin edin ve ağınızı bunlara göre oluşturun. 100MBitlik bir ağın tadına doyum olmaz.
    </listitem><listitem>
404. satırda başlayan bölümde klavye ve fare için donanımsal destek, 415. satırda başlayan bölümde seri portlarla ve konsol ile ilgili  destek, 449. satırda başlayan bölümde ise fare türleri ile ilgili destek var.
    </listitem><listitem>
496. satırda başlayan bölümde sadece donanım saati desteğini veriyoruz.
    </listitem><listitem>
534. satırda başlayan bölümde ramdisk için gereken dosya sistemi ile ilgili destekleri veriyoruz.
    </listitem></itemizedlist></para><para>
Bu dosyayı <filename>/usr/src/linux-2.4.22</filename> dizini altına <filename>.config</filename> ismiyle kaydedin (başında . olacak).
    </para><para>
<screen># <userinput>make menuconfig</userinput></screen>
    </para><para>
Komutunu verin. Bir takım işlemlerden sonra bir pencere açılacak. Hiç orada dolaşmayın. <literal>ESC ESC</literal> ile çıkın ve ardından sırasıyla şu komutları verin:
    </para><para>
<screen># <userinput>make dep</userinput>
# <userinput>make bzImage</userinput>
# <userinput>make modules</userinput>
# <userinput>make install</userinput>
# <userinput>make modules_install</userinput>
</screen>
    </para><para>
Bu komutların herbiri biraz vakit alır, bu işlemler sürerken makinada oyun filan oynayabilirsiniz <literal>:-)</literal> Merak etmeyin işlemi öyle aman aman yavaşlatmaz.
    </para><para>
Bu işlemler sonucunda <filename>/boot</filename> dizininde isminde <filename>2.4.22-x</filename> bulunan bazı dosyalar oluşacak. Bunlardan <filename>vmlinuz-2.4.22-x</filename> isimli dosya çekirdeğimizdir. Onu <filename>/export/netlogon/autoboot</filename> dizinine <filename>vmlinuz</filename> ismiyle kopyalayın. <filename>vmlinuz-2.4.22-x</filename> çekirdeğinin sistemin kendi çekirdeğine göre ne kadar küçük olduğuna dikkat edin (yarısı kadar).
    </para><para>
Ayrıca derlenen modüller de <filename>/lib/modules/2.4.22-x</filename> dizini altındaki dizinlere konulmuş olacak. Bize <filename>/lib/modules/2.4.22-x/kernel/drivers/net</filename> dizini altındaki modüllerden biri gerekecek. Hangisi olacağını nasıl tespit edeceğiz? derseniz ona da sıra gelecek.
    </para>
  </sect2>
  <sect2 xml:id="windows-ve-linux_temel-sistem" chunkthis="1">
    <title>Tek Başına (basit) Linux</title>
    <titleabbrev>1. adım - Sorunlarla başa çıkabilmek için adım adım gitmeli</titleabbrev>
    <para>
Kullanacağımız çekirdek hazır. Artık ramdiskimizin içini doldurmaya başlayabiliriz. Önce bu bölümde en temel ve en basit bir konsol oturumu oluşturacağız. Bu sistem henüz sunucu makinaya bağlanabilen bir yapı içermeyecek, her türlü donanımla çalışabilen temel yapıyı oluşturup deneyeceğiz. Sonraki bölümde bunu çalıştıracağımız makinanın donanımına göre özelleştireceğiz ve sunucuya bağlanabilir hale getireceğiz ve tekrar deneyeceğiz. Son olarak da üzerine X ile ilgili dosyaları yerleştirip X terminalimizi oluşturacağız.
    </para><para>
Sistemimiz bir pakete çok bağımlı, bu paket <userinput>busybox</userinput> kabuğunu içeriyor. <userinput>busybox</userinput>, <userinput>bash</userinput> gibi salt bir kabuk değil, içinde bize lazım olan hemen her sistem komutu var. Bu tür sistemler için özel olarak hazırlanmış bir paket. Önce onu indirip derleyeceğiz.
    </para><para>
<link xlink:href="http://www.busybox.net/downloads"/> adresinden <userinput>busybox</userinput>'ın son sürümünü indirin ve <filename>/usr/src</filename> dizinine taşıyın. Ben <filename>busybox-1.00-pre7</filename> sürümü ile çalıştım. Bu belgeyi hazırlarken indirdiğim <filename>busybox-1.00-pre10</filename> sürümünü derleyemedim. Komut geçmişi desteğini kaldırınca derleniyordu. Komut geçmişi olmadan da konsolda çalışmak işkence oluyor. Onun için size de <filename>busybox-1.00-pre7</filename> sürümünü öneririm.
    </para><para>
<filename>busybox-1.00-pre7</filename> paketini önce açın; çekirdek için yaptığımız gibi. <filename>busybox-1.00-pre7</filename> dizinine eklerde verdiğim <link linkend="windows-ve-linux_app2">yapılandırma dosyasını</link> <filename>.config</filename> ismiyle kopyalayın.
<userinput>busybox</userinput>'da tıpkı çekirdek gibi bir yapılandırma arayüzüne sahip. <userinput>make menuconfig</userinput> komutundan sonra <userinput>make</userinput> sonra da <userinput>make install</userinput> komutlarını verdiğinizde derlenmiş <userinput>busybox</userinput>'ı <filename>/usr/src/busybox-1.00-pre7/_install</filename> dizinin altındaki dizinlerde bulacaksınız.
    </para><para>
Bütün araçları tamamladığımıza göre <filename>/a3/ramdisk/initrd</filename> dizininin içini oluşturmaya başlayabiliriz. <filename>/a3/ramdisk/initrd</filename> dizine geçeceğiz ve dizinin içinde bazı alt dizinler oluşturacağız. Bu dizin ağacı ramdisk içindeki kök dizinimizin ağacı olacağından, bir kök dizin için gereken bütün dizinleri değil, sadece bize gerekli olan dizinleri oluşturacağız. Çünkü bizim yerimiz az ve kıymetli. Aşağıdaki satırları <filename>/a3/ramdisk</filename> dizinine <filename>kokyap</filename> ismiyle kaydedin:
    </para><para>
<screen>
ilk=`pwd`
cd initrd
kok=`pwd`
mkdir bin dev etc lib loopfs proc sysroot tmp usr var
ln -s bin sbin
mkdir etc/X11 etc/init.d etc/X11/xserver
mkdir lib/X11 lib/modules
cd lib/modules
mkdir 2.4.22-x drivers extensions fonts input linux
mkdir 2.4.22-x/kernel 2.4.22-x/kernel/drivers 2.4.22-x/kernel/drivers/net
cd $kok
cd lib/X11
mkdir app-defaults locale xkb
ln -s ../../etc/X11/xserver xserver
cd $kok
cd etc/X11
ln -s ../../lib/X11/xkb xkb
cd $kok
cd usr
ln -s .. X11R6
ln -s ../bin bin
ln -s ../bin sbin
ln -s ../lib lib
cd $kok
cd var
mkdir lib lock log run lib/dhcp lib/xkb lock/subsys
cd ../dev
ln -s /proc/self/fd fd
ln -s fd/0 stdin
ln -s fd/1 stdout
ln -s fd/2 stderr
mkfifo -m 600 initctl
mknod -m 666 tty c 5 0
mknod -m 600 console c 5 1
mknod -m 660 initrd b 1 250
mknod -m 640 ram0 b 1 0
mknod -m 640 ram1 b 1 1
mknod -m 640 mem c 1 1
mknod -m 640 kmem c 1 2
mknod -m 666 null c 1 3
mknod -m 644 random c 1 8
mknod -m 640 apm_bios c 10 134
mknod -m 640 rtc c 10 135
mknod -m 600 tty1 c 4 1
mknod -m 600 tty2 c 4 2
mknod -m 600 tty3 c 4 3
mknod -m 600 tty4 c 4 4
mknod -m 600 tty5 c 4 5
mknod -m 600 ttyS0 c 4 64
mknod -m 600 ttyS1 c 4 65
mknod -m 640 psaux c 10 1
mknod -m 644 urandom c 1 9
mknod -m 444 zero c 1 5
ln -s ttyS0 mouse
ln -s ram1 ram
ln -s ram0 ramdisk
ln -s console tty0
cd $ilk
</screen>
    </para><para>
<userinput>kokyap</userinput> betiğini,
    </para><para>
<screen># <userinput>. ./kokyap</userinput></screen>
    </para><para>
komutunu vererek çalıştırın. Betiğin yaptığı işlemleri <filename>initrd</filename> dizinine geçip görebilirsiniz. Betik tarafından oluşturulan dizinlerin hepsini biz kullanmayacağız, bazı dizinleri çalıştırdığımız uygulamalar kullanacak. Yani bazı dizinleri boş bırakacağız. <userinput>kokyap</userinput> betiğinin içindeki komutları komut satırından tek tek vererek de aynı işlemi kendiniz yapabilirsiniz. Betikte kullanılan komutların pek çoğunun bir türkçe kılavuz sayfası var: <xref linkend="tr-man1-ln"/>, <xref linkend="tr-man1-mkdir"/>, <link linkend="tr-man1-mkfifo">mkfifo</link>, <link linkend="tr-man1-mknod">mknod</link>. <link linkend="bashref_bourne.shell.builtins-cd">cd</link> komutu ise, kabuğun <link linkend="bashref_commands.index">yerleşik komutlarından</link> biridir.
    </para><para>
Şimdi sistem açılışı için gerekli dosyaları yerleştireceğiz. Bir Linux sisteminin açılışında ne gibi işlemler yürütüldüğünü <xref linkend="tr-man4-initrd"/> kılavuz sayfasında açıklanmıştır. Ayrıca, <xref linkend="tr-man8-init"/>, <xref linkend="tr-man5-inittab"/> kılavuz sayfalarını da okursanız yapacağımız işlemleri niçin yaptığımızı, neden bazı şeyleri orada yazılanlardan biraz farklı yaptığımızı daha kolay anlayabilirsiniz.
    </para><para>
<xref linkend="tr-man4-initrd"/> kılavuz sayfasında yazdığı gibi önce <filename>/linuxrc</filename> betiğini yazacağız. Aşağıdaki betiği <filename>/a3/ramdisk/initrd</filename> dizinine <filename>linuxrc</filename> ismiyle kaydedin:
    </para><para>
<screen>#!/bin/nash

echo /proc dosya sistemi baglaniyor
mount -t proc /proc /proc
echo Blok aygitlari olusturuluyor
mkdevices /dev
echo Kok aygiti olusturuluyor
mkrootdev /dev/root
echo 0x0100 > /proc/sys/kernel/real-root-dev
echo "Init sureci basliyor"
rm -f /linuxrc
</screen>
    </para><para>
Bu dosyayı oluşturduktan sonra,
    </para><para>
<screen># <userinput>chmod +x linuxrc</userinput></screen>
    </para><para>
komutuyla betiğe çalıştırılabilirlik özelliği verin.
    </para><para>
Bu betiği biraz inceleyelim. İlk satır, betiğin <filename>/bin</filename> dizininde bulunan <userinput>nash</userinput> isimli bir betik yorumlayıcısı tarafından yorumlanacağını söylüyor. Yani bu betik içinde yazılan komutları bu uygulama çalıştıracak. <userinput>nash</userinput>, sadece linuxrc betiklerini çalıştırmak için tasarlanmış, küçük bir betik yorumlayıcıdır. Bir kabuk değildir. Sisteminizde <userinput>nash</userinput> vardır. Komut satırına <userinput>whereis nash</userinput> yazarsanız, <userinput>nash</userinput>'ın sisteminizde nerede durduğunu öğrenebilirsiniz. Ben bu komutu verdiğimde:
    </para><para>
<screen># <userinput>whereis nash</userinput>
nash: /sbin/nash /usr/share/man/man8/nash.8 /usr/share/man/man8/nash.8.gz
</screen>
    </para><para>
şeklinde bir çıktı alıyorum. O halde yapacağımız işlem basit bir kopyalama işlemi:
    </para><para>
<screen># <userinput>cp /sbin/nash /a3/ramdisk/initrd/bin/</userinput>
</screen>
    </para><para>
İşimiz <userinput>nash</userinput>'ı kopyalamakla bitmiyor. <userinput>nash</userinput>'ın içerdiği yerleşik komutlar için <userinput>nash</userinput>'a birer sembolik bağ yerleştireceğiz:
    </para><para>
<screen># <userinput>cd bin</userinput>
# <userinput>ln -s losetup nash</userinput>
# <userinput>ln -s mkdevices nash</userinput>
# <userinput>ln -s makerootdev nash </userinput>
# <userinput>ln -s pivot_root nash</userinput>
# <userinput>ln -s showlabels nash</userinput>
</screen>
    </para><para>
Böylece <filename>linuxrc</filename> betiğinin çalışması için gerek ve yeter şart sağlanmış oldu. Betik <userinput>echo 0x0100 > /proc/sys/kernel/real-root-dev</userinput> satırıyla çekirdeğe kök dosya sistemimizin ramdisk olduğunu söylüyor. Init süreci başladığında çekirdeğin kök dosya sistemi olarak nereyi kullanacağını belirtmiş olduk. <filename>linuxrc</filename> betiğinin tekrar tekrar çalıştırılmasını önlemek için son satırda betiği siliyoruz ve <filename>linuxrc</filename> betiğinin işi bitiyor, görevi <userinput>init</userinput> süreci devralıyor.
    </para><para>
<userinput>init</userinput> bir uygulama ismi. Ama bizim sistemimizde henüz yok. Şimdi onu ve bir sistemde kullanılan bir çok komutu içeren <userinput>busybox</userinput>'ı sistemimize yerleştireceğiz. Busybox'ı bu bölümün başlangıcında indirmiş ve derlemiştik. <filename>/usr/src/busybox-1.00-pre7/_install/bin</filename> dizinindeki herşeyi <filename>/a3/ramdisk/initrd/bin</filename> dizinine kopyalayın. <filename>/usr/src/busybox-1.00-pre7/_install/</filename> atındaki diğer dizinlerin içeriğini de <filename>/a3/ramdisk/initrd/bin</filename> dizinine kopyalayın. (Kopyalama için <userinput>mc</userinput>'den yararlanmıyorsanız, sembolik bağları kopyalarken <userinput>cp</userinput> komutunu <option>-d</option> seçeneği ile kullanmalısınız.) <filename>/usr/src/busybox-1.00-pre7/_install/</filename> dizini altındaki <filename>linuxrc</filename>'yi biz kullanmayacağız. Biz onu zaten yazmıştık. <filename>/a3/ramdisk/initrd/bin</filename> dizinine girdiğinizde <userinput>mc</userinput> kullanıyorsanız, bazı sembolik bağ dosyalarının hedeflerini bulamadıklarını göreceksiniz. Onların hedeflerini bulmalarını sağlamalısınız. İmleci onlardan birinin üzerine getirip CTRL tuşu basılıyken X ve S tuşladığınızda açılan pencereye <literal>busybox</literal> yazmanız yeterlidir. Hepsi için bu işlemi yapın.
    </para><para>
<filename>bin</filename> dizinindeki sembolik bağlar arasında <userinput>init</userinput>'in de bulunduğunu göreceksiniz. Ama sistemin açılması için <userinput>init</userinput>'in varlığı yeterli değil. <userinput>init</userinput> çalıştığında önce <filename>/etc/inittab</filename> dosyasına bakacak ve oradaki satırları yorumlarak sistemi kullanıcı ile etkileşimli çalışacak duruma getirecek. O halde,  <filename>etc/inittab</filename> dosyasını hazırlamamız lazım. <userinput>busybox</userinput> ile gelen <userinput>init</userinput>'in çalışacağı <filename>inittab</filename> dosyasının içeriği, <xref linkend="tr-man5-inittab"/> kılavuz sayfasında anlatılan içerikten farklı. Bu konuda daha ayrıntılı bilgiyi <link xlink:href="file:/usr/src/busybox-1.00-pre7/docs/BusyBox.html#item_init"/> adresinde bulabilirsiniz. Kullanacağımız <filename>inittab</filename> dosyası:
    </para><para>
<screen>
::sysinit:/etc/init.d/baslat

tty1::askfirst:/bin/busybox sh
tty2::askfirst:/bin/busybox sh

::ctrlaltdel:/bin/reboot -d 0
::restart:/sbin/init
</screen>
    </para><para>
Burada ilk satırda, sistemi ilklendirecek betiğin yerini belirttim. <userinput>init</userinput> bu satırı ve orada belirtilen betiği icra ettikten sonra diğer satırlara geçecek.
Sonraki iki satırda iki konsolumuz (<filename>tty1</filename> ve <filename>tty2</filename>) olacağını belirtim. Bu konsolları etkinleştirmeden önce onay almasını istedim. Son iki satırda ise <filename>CTRL-ALT-DEL</filename> tuşlandığında ne işlem yapacağını ve yeniden başlatma durumunda ne yapacağını belirttim. Sistemi kapatmak için birşey belirtmek gerekmiyor. Konsolda komut olarak <userinput>poweroff</userinput> verildiğinde <userinput>busybox</userinput> sistemi sonlandırıyor. Normalde sistemi kapatması lazım ama bunun için ek modüller gerekiyor. Bu lükse ihtiyacınız varsa siz eklersiniz.
    </para><para>
İki konsol belirttim. İlk konsolda açılış iletilerine bakmak ve bir takım komutlar orada çalıştırılabilsin istedim. İkinci konsolu daha sonra <userinput>X</userinput>'i çalıştırmak için kullanacağız. Şimdilik o da ilk konsol gibi bir konsol.
    </para><para>
Şimdi <filename>inittab</filename>'ın ilk satırında belirtiğimiz betiği hazırlamalıyız. Betik:
    </para><para>
<screen>
#!/bin/sh
# Bu betik sistemi ilklendirir

PATH="/bin"

umask 022

# Biraz yer acalim
rmdir /lost+found

# Saatimiz dogru kalsin
hwclock -s

echo "lo arayuzu etkinlestiriliyor"
ip link set lo up
ip addr add 127.0.0.1 dev lo
ip route add 127.0.0.0/8 dev lo

exit 0
</screen>
    </para><para>
Çok basit bir betik. <userinput>rmdir /lost+found</userinput> satırında, ramdisk üzerinde dosya sistemini oluşturulurken <filename>/lost+found</filename> isminde bir dizin oluşur. Bu dizin bize lazım olmadığından yerimizi işgal etmesin diye siliyoruz. <userinput>hwclock -s</userinput> satırıyla çekirdeğin, sistem saatini donanım saatiyle eşzamanlamasını söylüyoruz. Böylece <userinput>date</userinput> komutu bize doğru zamanı gösterecek. Son olarak da sistemin yerel IP adresi ile ilgili yapılandırmayı gerçekleştiriyoruz.
    </para><para>
Yalnız <userinput>busybox</userinput>'ın çalışması için bazı kütüphane dosyalarına ihtiyacı var. Bunların neler olduğunu öğrenmek için <userinput>ldd</userinput> komutunu kullanacağız:
    </para><para>
<screen># <userinput>ldd /a3/ramdisk/initrd/bin/busybox</userinput>
        libc.so.6 => /lib/i686/libc.so.6 (0x40030000)
        /lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x40000000)
</screen>
    </para><para>
Bu çıktıya göre <filename>libc.so.6</filename> ve <filename>ld-linux.so.2</filename> dosyalarını <filename>lib</filename> dizinimize yerleştirmemiz gerekli. Sistemin <filename>/lib</filename> dizine baktığımızda bu dosyaların sırasıyla <filename>libc-2.3.2.so</filename> ve <filename>ld-2.3.2.so</filename> dosyalarına sembolik bağ olduklarını görüyoruz. Yani 4 dosyayı da bizim <filename>lib</filename> dizinimize kopyalamamız lazım:
    </para><para>
<screen># <userinput>cp -d /lib/libc.so.6 /a3/ramdisk/initrd/lib/</userinput>
# <userinput>cp /lib/libc-2.3.2.so /a3/ramdisk/initrd/lib/</userinput>
# <userinput>cp -d /lib/ld-linux.so.2 /a3/ramdisk/initrd/lib/</userinput>
# <userinput>cp /lib/ld-2.3.2.so /a3/ramdisk/initrd/lib/</userinput>
</screen>
    </para><para>
Birinci ve üçüncü satırdaki <option>-d</option> seçeneğine dikkat edin. Dosya sistemimiz artık hazır, deneyebiliriz. <filename>/a3/ramdisk/initrdyap</filename> betiğini çalıştırıp <filename>/export/netlogon/autoboot/initrd.img</filename> dosyasını oluşturalım:
    </para><para>
<screen># <userinput>/a3/ramdisk/initrdyap</userinput></screen>
    </para><para>
<filename>/export/netlogon/autoboot</filename> dizininde bir önceki bölümde derlediğimiz çekirdeği yerleştirmiştik. Bu dizine Linux'u kurduğunuz CD'lerin ilkinde bulunan <filename>loadlin.exe</filename> dosyasını da kopyalayın. CD'yi CDROM sürücünüze yerleştirin ve <userinput>mount /mnt/cdrom</userinput> komutunu verin. CD'nin içeriğini <filename>/mnt/cdrom</filename> dizini altında bulacaksınız. <filename>mc</filename> ile CD'nin dizinlerinde <filename>loadlin.exe</filename> dosyasını bulun ve <filename>F5</filename> ile <filename>/export/netlogon/autoboot</filename> dizine kopyalayın.
<filename>/mnt/cdrom</filename> dizininde çıkın ve <userinput>umount /mnt/cdrom</userinput> komutunu verdikten sonra CD'yi yuvasından çıkarın.
    </para><para>
Şimdi bu 3 dosyadan yemek yapacağız. <filename>/export/netlogon/autoboot</filename> dizininde <filename>linux.bat</filename> ismiyle bir dosya açın (<userinput>touch linuxbat</userinput>) ve içine aşağıdaki satırı yazın:
    </para><para>
<screen>loadlin autoboot\vmlinuz initrd=autoboot\initrd.img ramdisk_size=12000</screen>
    </para><para>
Bir üst dizine geçin ve <filename>linuxyukle.bat</filename> isminde bir dosya açın ve içine aşağıdakileri yazın.
    </para><para>
<screen>net use z: \\NILGUN\netlogon /y
copy z:\autoboot\vmlinuz c:\autoboot
copy z:\autoboot\initrd.img c:\autoboot
copy z:\autoboot\loadlin.exe c:\
copy z:\autoboot\linux.bat c:\
</screen>
    </para><para>
İlk satırdaki <filename>\\NILGUN\</filename> yerine makinanıza verdiğini ismi yazmalısınız. Benim için bu isim <filename>nilgun.buguner.home</filename> olduğundan <filename>NILGUN</filename> yazdım. Ayrıca, bu dosyayı windows altında çalıştıracağımız için dosyayı DOS dosya biçimine dönüştürmemiz ve dosyanın çalıştırılabilir bir dosya olmasını sağlamamız lazım. Bunun için aşağıdaki komutları çalıştırın:
    </para><para>
<screen># <userinput>unix2dos linuxyukle.bat</userinput>
# <userinput>chmod +x linuxyukle.bat</userinput>
</screen>
    </para><para>
Linux'da her satır LF (10 numaralı karakter)ile biterken, DOS'da CRLF (13 ve 10 numaralı karakterler) ile biter. Bu komut satır sonlarındaki LF'leri CRLF ile değiştirir.
    </para><para>
Sunucu makina üzerindeki işimiz bitti. İstemci makinaya geçin ve Ağ Komşularında <filename>netlogon</filename> dizinine girin ve <filename>linuxyukle.bat</filename> dosyasını çalıştırın. Bu betiği çalıştırdığınızda <filename>\\NILGUN\netlogon</filename>'un karşılığı olarak <filename>Z:</filename> diski oluşacak ve <filename>Z:</filename> diskindeki dosyalar <filename>C:</filename> diskine kopyalanacak.
    </para><para>
Şimdi windows masaüstünde bir kısayol oluşturacağız. <filename>C:\linux.bat</filename> dosyasının üzerindeyken farenin sağtuşu ile açılan menüden kısayol oluştur'u seçin ve oluşan kısayolu masaüstüne taşıyıp ismini <filename>LINUX OL</filename> olarak değiştirin. Simgenin üzerine sağ tıklayıp <filename>Özellikler</filename>'e girin. Program sekmesinde <filename>Gelişmiş</filename> düğmesine tıklayın. 2. ve 3. seçenekleri seçili hale getirin. <filename>MS-DOS kipi</filename> başlıklı bölümde, <filename>Mevcut MD-DOS ayarlarını kullan</filename> seçeneğini seçil duruma, <filename>MS-DOS kipine girerken uyar</filename> seçeneğini ise seçilmemiş durma getirin ve Tamam'a tıklayıp çıkın.
Şimdi sıra <filename>config.sys</filename> dosyasında, <filename>C:\config.sys</filename> dosyasında aşağıdakilerin bulunmasını sağlayın (bu dosyalar sizin sisteminizde farklı yerdeyse ona göre düzeltin):
    </para><para>
<screen>
DEVICE=C:\WINDOWS\HIMEM.SYS
DEVICE=C:\WINDOWS\EMM386.EXE
DOS=HIGH,UMB
</screen>
    </para><para>
Bundan sonra windows'u yeniden başlatın ve windows açılınca <filename>LINUX OL</filename> simgesine tıklayıp Linux sistemini başlatın. Ekran kararacak, önce çekirdek, ardından <filename>initrd.img</filename> yüklenecek. Çekirdek çalışacak, <userinput>init</userinput>'i başlatacak ve en son Enter'a basıp konsola düşeceksiniz. <userinput>ifconfig</userinput>, <userinput>ls</userinput>, <userinput>date</userinput>, <userinput>df</userinput> gibi bazı komutları deneyin.
Bu konsolda yapabileceklerimiz bu gibi komut satırından bir takım komutlar girmekle sınırlı. Sistemi kapatmak için <userinput>halt</userinput> veya <userinput>poweroff</userinput> komutlarını girebileceğiniz gibi, makinayı doğrudan da kapatabilirsiniz. Çünkü sistemin çalışması için herhangi bir sabit diski bağlamadık. Kaybedilecek ya da bozulacak bir bilgi yok.
    </para><para>
Bundan sonraki adım, iki makinayı birbirine bağlamak.
    </para>
  </sect2><sect2 xml:id="windows-ve-linux_baglan" chunkthis="1">
    <title>Ağa Bağlanan Linux Terminali</title>
    <titleabbrev>2. adım - Linux ağa bağlanıyor</titleabbrev>
    <para>
Bu adımda, Linux terminalimizin DHCP sunucusundan IP adresi almasını, yani sunucu makinaya bağlanmasını sağlayacağız. Bunu yapmadan önce, istemci makina üzerinde bulunan ağ kartı için hangi çekirdek modülünün gerektiğini öğrenmemiz lazım. Bunu yapmışken, X yapılandırması ile ilgili dosyaları da alacağız. Nasıl mı? Hani belgenin başında elinizin altında bir Knoppix CD'si olsun demiştim. Şimdi onu kullanacağız. Knoppix, tamamen CD'den başlatılıp, sabit diske kurulmadan doğrudan CD'den çalışan bir Linux dağıtımıdır. Eğer bir ağ bulur ve bu ağda da bir DHCP sunucusu algılarsa kendine bir IP adresi alıp ağa bağlanır. Biz bu özelliğinden yararlanarak, onun çalışmak için oluşturduğu yapılanmayla ilgili dosyaları bu ağ bağlantısı üzerinden sunucumuza aktarabiliriz. Bunu yapabilmek için önce sunucu makina üzerinde SSH sunucusunu başlatmamız lazım. SSH bağlantısı kuracağız, çünkü <userinput>telnet</userinput> öntanımlı ayarlarıyla <literal>root</literal> kullanıcısının sisteme bağlanmasına izin vermez. SSH için böyle bir sorun yok. Sunucu makina üzerinde şu komutları girin:
    </para><para>
<screen># <userinput>/sbin/chkconfig sshd on</userinput>
# <userinput>/sbin/service sshd start</userinput>
</screen>
    </para><para>
Böylece sshd'nin her sistem açılışında çalışmasını da sağlamış olduk. İstemci makinanın CD sürücüsündeki Knoppix CD'sinden açılmasını sağlayın. İstemci makina benimki gibi yavaş bir makinaysa (P133) Knoppix'in açılması biraz zahmetli olacaktır. Böylece neden bir Knoppix CD'si alıp kullanın demediğimi daha iyi anlayacaksınız. Bizim oluşturacağımız sistem Knoppix'e göre sürat rekoru kıracak.
    </para><para>
Knoppix'in masaüstü açıldığında <userinput>CTRL-ALT-F1</userinput> tuşu ile konsola düşün. Bu konsol bizim konsol gibi, yani parola filan sormuyor ve sistem root yetkileri ile kullanılıyor. <userinput>mc</userinput> var, isterseniz çalıştırın. Şu komutu girin:
    </para><para>
<screen># <userinput>scp /proc/modules root@10.10.10.1:/a3/ramdisk/</userinput>
</screen>
    </para><para>
Bu komuttan sonra <userinput>scp</userinput> size parola soracak. Sunucu makinadaki <filename>root</filename> kullanıcısı için kullandığınız parolayı girin. <filename>/proc/modules</filename> dosyası sunucu makina üzerindeki <filename>/a3/ramdisk</filename> dizinine kopyalanacak. <filename>XF86Config</filename> dosyası ile <filename>XFree86.0.log</filename> dosyasını da alalım:
    </para><para>
<screen>
# <userinput>scp /etc/X11/XF86Config root@10.10.10.1:/a3/ramdisk/</userinput>
# <userinput>scp /var/log/XFree86.0.log root@10.10.10.1:/a3/ramdisk/</userinput>
</screen>
    </para><para>
Bu komutları girmeden önce <filename>/etc/X11</filename> ve <filename>/var/log</filename> dizinlerine bakmayı ihmal etmeyin. Dosyaların isimleri biraz farklı olabilir, bu takdirde komutlardaki dosya isimlerini değiştirmelisiniz. Bu işlemden sonra Knoppix ile işimiz bitti. Bize gerekli bilgileri topladık. Sunucu makinaya geçip, yeni sistemi hazırlayabiliriz.
    </para><para>
Knoppix'den kopyaladığımız <filename>modules</filename> dosyası, istemci makinadaki donanım için gerekli çekirdek modüllerini içerir. Bunlardan biri de ağ kartını sisteme tanıtan modüldür. <filename>modules</filename> dosyasındaki modül isimlerini makinanızdaki ağ kartları ile ilgili modül dosyalarının (<filename>/lib/modules/2.4.22-x/kernel/drivers/net</filename> dizinindeki modüller) isimleriyle karşılaştırın. En az bir eşleşme bulacaksınız, bazı modüller bir ek modüle daha ihtiyaç duyar, örneğin <filename>8139too.o</filename> modülü <filename>mii.o</filename> modülüne ihtiyaç duyar ve <filename>modules</filename> dosyasında bir modül bir başka modüle bağımlıysa bu bilgi dosyada vardır. Bunu göz önüne alarak <filename>modules</filename> dosyasını önce bir inceleyin. Ağ kartı ilk algılanan donanımlardan biri olduğundan onunla ilgili modül ya da modüller <filename>modules</filename> dosyasının son satırlarındadır. Dosyayı sondan başa tararsanız işiniz çabuk biter.
    </para><para>
Bu modül benim istemci makinam için <filename>dmfe.o</filename> ve ek bir modül gerektirmiyor. <filename>/lib/modules/2.4.22-x/kernel/drivers/net/dmfe.o</filename> dosyasını <filename>/a3/ramdisk/initrd/lib/modules/2.4.22-x/kernel/drivers/net/</filename> dizinine kopyalıyorum, siz de kendi modül ya da modülleriniz için aynı işlemi yapın:
    </para><para>
<screen># <userinput>cp /lib/modules/2.4.22-x/kernel/drivers/net/dmfe.o</userinput> \
> <userinput>/a3/ramdisk/initrd/lib/modules/2.4.22-x/kernel/drivers/net/</userinput>
</screen>
    </para><para>
Ağ kartının çekirdeğe tanıtılmasını sağlayacak modülü sistemimize yerleştirdiğimize göre sistemi ağa bağlayacak işlemlere başlayabiliriz. <filename>/etc/init.d/baslat</filename> dosyasını aşağıdaki biçime getirin:
    </para><para>
<screen>
#!/bin/sh
# Bu betik sistemi ilklendirir

PATH="/bin"

umask 022

# Biraz yer acalim
rmdir /lost+found

# modulleri yoklarken cekirdek birsey basmasin
echo "0" > /proc/sys/kernel/printk
depmod -a
modprobe -a -q *

# Saatimiz dogru kalsin
hwclock -s

echo "lo arayuzu etkinlestiriliyor"
ip link set lo up
ip addr add 127.0.0.1 dev lo
ip route add 127.0.0.0/8 dev lo

echo "eth0 arayuzu etkinlestiriliyor"
udhcpc -i eth0 -s /etc/init.d/dhcpc.sh

exit 0
</screen>
    </para><para>
Önceki <userinput>baslat</userinput> betiğiyle karşılaştırıldığında hangi satırların eklendiğini gördünüz. <userinput>depmod</userinput> komutuyla modül bağımlılıkları tespit ediliyor ve hemen altındaki <userinput>modprobe</userinput> komutuyla gerekli modüller çekirdeğe ekleniyor. <userinput>depmod</userinput> ve <userinput>modprobe</userinput> komutlarını <userinput>bin</userinput> dizinimize eklemeliyiz. Ayrıca bir <filename>/etc/modules.conf</filename> dosyası oluşturup ağ kartı için gereken modülü bu dosyada belirtmeliyiz.
    </para><para>
Dosyanın sonundaki <userinput>udhcpc</userinput> komutu ise <userinput>busybox</userinput> içindeki yerleşik komutlardan biri. DHCP sunucusundan ağ kartımız için IP adresinin alınmasını bu komut gerçekleştiriyor. Komut parametrelerinde <option>-i</option> seçeneği ile ağ arayüzünün ismini, <option>-s</option> seçeneği ile de komutun dönemsel olarak çalıştıracağı betiğin yerini belirtiyoruz. Bu betiği de biz yazacağız.
    </para><para>
Şimdi bu işlemleri sırayla yapalım. <userinput>depmod</userinput> ve <userinput>modprobe</userinput> komutlarını sistemde bulunduğu yeri <userinput>whereis</userinput> ile tespit ettikten sonra bu dizine girip bu komutların dosyalarını buluyoruz. <userinput>modprobe</userinput> genelde <userinput>insmod</userinput> dosyasına bir sembolik bağdır. <userinput>insmod</userinput> dosyasına sembolik bağ olarak çalışan başka komutlar da var. Hepsini <filename>initrd/bin</filename> dizinine kopyalıyoruz:
    </para><para>
<screen># <userinput>cd /a3/ramdisk/initrd/bin</userinput>
# <userinput>cp /sbin/depmod ./</userinput>
# <userinput>cp /sbin/insmod ./</userinput>
# <userinput>cp -d /sbin/kallsyms ./</userinput>
# <userinput>cp -d /sbin/ksyms ./</userinput>
# <userinput>cp -d /sbin/lsmod ./</userinput>
# <userinput>cp -d /sbin/modprobe ./</userinput>
</screen>
    </para><para>
Sembolik bağları kopyalarken <option>-d</option> seçeneğini kullandığımıza dikkat edin. Bu seçeneği kullanmazsanız bağ dosyası değil, bağın hedefindeki dosya kopyalanır ki, bu bizim istemediğimiz bir durum.
    </para><para>
<userinput>depmod</userinput> ve <userinput>insmod</userinput> komutlarının bağımlı olduğu kütüphanelerin neler olduğuna da bakmamız lazım:
    </para><para>
<screen># <userinput>ldd ./insmod</userinput>
        libc.so.6 => /lib/i686/libc.so.6 (0x40030000)
        /lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x40000000)
# <userinput>ldd ./depmod</userinput>
        libc.so.6 => /lib/i686/libc.so.6 (0x40030000)
        /lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x40000000)
</screen>
    </para><para>
Bu dosyaları <userinput>busybox</userinput> için sistemimize dahi etmiştik. Farklı bir kütüphaneye ihtiyaç duymadıklarından birşey yapmamıza gerek yok.
    </para><para>
Şimdi <filename>etc</filename> dizinine geçip oradaki işlemleri yapalım. Önce <filename>etc</filename> dizininde <filename>modules.conf</filename> dosyasını oluşturun ve içine aşağıdaki satırı sizin ağ kartınızın modül ismini <filename>.o</filename> uzantısız olarak içerecek şekilde yazın (benimki <filename>dmfe</filename>):
    </para><para>
<screen>alias eth0 dmfe</screen>
    </para><para>
<filename>init.d</filename> dizinine geçip <filename>dhcpc.sh</filename> dosyasını oluşturacağız ve dosyayı çalıştırılabilir yapacağız:
    </para><para>
<screen># <userinput>touch dhcpc.sh</userinput>
# <userinput>chmod +x dhcpc.sh</userinput>
</screen>
    </para><para>
Dosyanın içine aşağıdaki satırları kopyalayın:
    </para><para>
<screen>#!/bin/sh

RESOLV_CONF="/etc/resolv.conf"
[ -n "$broadcast" ] &amp;&amp; BROADCAST="broadcast $broadcast"
[ -n "$subnet" ] &amp;&amp; NETMASK="netmask $subnet"

case "$1" in
    deconfig)
      ifconfig $interface 0.0.0.0
      ;;

    renew|bound)
      ifconfig $interface $ip $BROADCAST $NETMASK

      if [ -n "$router" ] ; then
          while ip route del default scope global nexthop dev $interface ; do
            :
          done 2>/dev/null

          for i in $router ; do
                  ip route add default via $i dev $interface
          done
      fi

      echo -n > $RESOLV_CONF
      [ -n "$domain" ] &amp;&amp; echo search $domain >> $RESOLV_CONF

      for i in $dns ; do
        echo nameserver $i >> $RESOLV_CONF
      done
      ;;
esac

exit 0
</screen>
    </para><para>
Bu betik tek başına çalışmaz, betiği <userinput>udhcpc</userinput> komutu bazı parametreler aktararak çalıştırır. Bu konu hakkında daha fazla bilgi almak için <userinput>busybox</userinput> paketindeki <filename>networking/udhcp</filename> dizinindeki README dosyalarındaki açıklamalara bakabilirsiniz.
    </para><para>
<userinput>initrdyap</userinput> betiğini çalıştırıp <filename>initrd.img</filename> dosyasını oluşturduktan sonra istemci makinaya geçip, <filename>netlogon</filename> dizinindeki betiği çalıştırıp dosyaları windows'a aktarın ve <filename>LINUX OL</filename> simgesine tıklayıp yaptıklarınızı deneyin.
    </para><para>
İstemci makinadaki Linux sistemi açıldığında <userinput>ifconfig</userinput> komutunu vererek <literal>eth0</literal> yapılandırmasını görebilir. Sunucu makinaya <userinput>ping</userinput> atabilir (<userinput>ping 10.10.10.1</userinput>), böylece ağ bağlantınızı sınayabilirsiniz.
    </para><para>
İstemci makinanın Linux ile ağa bağlanmasını gerçekleştirdiğimize göre son adıma geçebilir, X terminalimizi oluşturmaya başlayabiliriz.
    </para>
  </sect2><sect2 xml:id="windows-ve-linux_x-terminali" chunkthis="1">
    <title>X Terminalinin Oluşturulması</title>
    <titleabbrev>Son ve büyük adım</titleabbrev>
    <para>
Knoppix'i istemci makinada çalıştırdığımızda X yapılandırmasını içeren iki dosya kopyalamıştık. Biri X çalıştırıldığında X'in okuyup kendini yapılandırdığı <filename>XF86Config</filename> dosyası, diğeri ise X çalıştığında yaptığı işlemleri günlüklediği <filename>XFree86.0.log</filename> dosyası. <filename>XF86Config</filename> dosyasını biraz değiştirip kullanacağız. <filename>XFree86.0.log</filename> dosyasından ise  X çalıştığında hangi dosyaları yüklediğini öğrenip bu dosyaları sistemimize yerleştireceğiz ki, bizim sistemimizde çalıştırıldığında bu dosyaları bulabilsin. Ancak bu dosyalarda gereken bütün dosyalara ilişkin bilgi yok. Bazılarını da X çalıştığında verdiği hatalardan öğrendim. Siz de X çalıştırıldığında benzer hatalar alabilirsiniz. En azından benim aldığım hataları almayacaksınız. Çünkü ben en azından bu sistemi daha önce çalıştırdığım için gerekli bazı dosyaları biliyorum. Hemen ürkmeyin öyle; siz bir hata yapmamışsanız, büyük ihtimalle hiç hata almayacaksınız.
    </para><para>
X ile ilgili herşey başlıca iki dizin altında bulunur: <filename>/usr/X11R6</filename> ve <filename>/etc/X11</filename>. Bu iki dizinin yeri bütün dağıtımlarda aynıdır. Bu benzerliği bizde kullanıyoruz; bir farkla: <filename>/usr/X11R6</filename> dizininin içeriğine baktığımızda kök dizine benzediğini görüyoruz. Bu benzerlikten yararlanarak <filename>/usr/X11R6</filename> dizinini kök dizini gösteren bir bağ dosyası yapabiliyoruz. Böylece büyükçe ayrı bir dizin ağacı oluşturmak yerine kök dizinindeki dizin yapısından yararlanabiliyoruz. <filename>initrd</filename> dizininin içeriğini incelediğinizde bunun burada anlattığım şekilde oluşturulmuş olduğunu göreceksiniz. Yani, normal bir sistemde <filename>/usr/X11R6</filename> altında olan herşeyi <filename>initrd</filename> dizini içindeki dizinlere yerleştireceğiz.
    </para><para>
Önce <filename>/usr/X11R6/bin/X</filename> sembolik bağı ile bu bağın hedefindeki dosyayı kendi sistemimize yerleştirelim:
    </para><para>
<screen># <userinput>cp -d /usr/X11R6/bin/X /a3/ramdisk/initrd/bin/</userinput>
# <userinput>cp /usr/X11R6/bin/XFree86 /a3/ramdisk/initrd/bin/</userinput>
</screen>
    </para><para>
Bunun ardından <userinput>XFree86</userinput>'nın hangi kütüphanelere bağımlı olduğunu tespit edip bunları da sistemimize yerleştirelim:
    </para><para>
<screen># <userinput>ldd /a3/ramdisk/initrd/bin/XFree86</userinput>
        libz.so.1 => /usr/lib/libz.so.1 (0x40030000)
        libm.so.6 => /lib/i686/libm.so.6 (0x4003e000)
        libpam.so.0 => /lib/libpam.so.0 (0x40060000)
        libdl.so.2 => /lib/libdl.so.2 (0x40068000)
        libpam_misc.so.0 => /lib/libpam_misc.so.0 (0x4006b000)
        libc.so.6 => /lib/i686/libc.so.6 (0x4006e000)
        /lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x40000000)
</screen>
    </para><para>
Bu kütüphanelerden son ikisini zaten sistemimize daha önce kopyalamıştık. Diğerlerini de kopyalayalım:
    </para><para>
<screen># <userinput>cd /a3/ramdisk/initrd/lib</userinput>
# <userinput>cp -d /usr/lib/libz.so.1 ./</userinput>
# <userinput>cp -d /lib/libm.so.6 ./</userinput>
# <userinput>cp -d /lib/libpam.so.0 ./</userinput>
# <userinput>cp -d /lib/libdl.so.2 ./</userinput>
# <userinput>cp -d /lib/libpam_misc.so.0 ./</userinput>
</screen>
    </para><para>
Sembolik bağları kopyaladık. Bu sembolik bağların hedefindeki dosyalar hatta bu sembolik bağlar bile sizin sisteminizde farklı olabilir. Ben benimkileri aşağıdaki gibi kopyaladım, siz de sizinkilerin hedeflerindeki dosyaları kopyalayın:
    </para><para>
<screen># <userinput>cp /usr/lib/libz.so.1.1.4 ./</userinput>
# <userinput>cp /lib/libm-2.3.2.so ./</userinput>
# <userinput>cp /lib/libpam.so.0.77 ./</userinput>
# <userinput>cp /lib/libdl-2.3.2.so ./</userinput>
# <userinput>cp /lib/libpam_misc.so.0.77 ./</userinput>
</screen>
    </para><para>
X'in çalışması için gerekli en temel koşulları sağladık. X çalıştıktan sonra sistem yapılandırmasını öğrenmek için <filename>/etc/X11/XF86Config</filename> dosyasına bakar ve oradaki verilere göre bazı kütüphaneleri ve dosyaları yükler. Hangi kütüphaneleri yüklediğini ise günlük kayıt dosyası olan <filename>/var/log/XFree86.0.log</filename> dosyasına yazar. Bu dosyaların birer kopyasını Knoppix sayesinde edinmiştik. Önce Knoppix için anlamlı olan <filename>XF86Config</filename> dosyasını kendi sistemimiz için anlamlı olan biçime getirmeliyiz. Bunun için önce <literal>"Files"</literal> bölümünde <literal>Fontpath</literal> satırını düzenleyeceğiz:
    </para><para>
<screen>Section "Files"
        RgbPath      "/usr/X11R6/lib/X11/rgb"
        FontPath     "tcp/10.10.10.1:7100"
EndSection
</screen>
    </para><para>
Dosyanın görünümü sizinkinde farklı olabilir ama işe yarayan satırlar, bunlar. <literal>FontPath</literal> satırını yukarıdaki gibi düzenleyin. Bu satırdaki <literal>10.10.10.1</literal>, <userinput>xfs</userinput> sunucusunun çalıştığı makinanın IP adresi olmalı. Bu satır sayesinde X çalıştırıldığında gerekli yazıtiplerini bu adresteki <userinput>xfs</userinput> sunucusundan yükleyecek.
    </para><para>
İkinci düzenleme klavye ile ilgili. Şüphesiz Türkçe karakterleri kullanmak isteyeceksiniz. Klavye ile ilgili bölüm fazlalıkları temizlenmiş olarak aşağıdaki gibi olmalı:
    </para><para>
<screen>Section "InputDevice"
        Identifier  "Keyboard0"
        Driver      "keyboard"
        Option      "XkbRules" "xfree86"
        Option      "XkbModel" "pc105"
        Option      "XkbLayout" "tr_q,tr_f"
        Option      "XkbOptions" "caps:shift,grp:shift_toggle"
EndSection
</screen>
    </para><para>
Bu yapılandırma, her iki Shift tuşuna birlikte basıldığında Q ve F klavyeleri arasında geçiş yapar.
    </para><para><warning><para>Bu yapılandırma standart X ile uyumlu değildir. Sistem bu özel duruma göre yapılandırılacaktır (Türkçe X klavyesinin yazarından bir hediye).</para></warning>
    </para><para>
Bu düzenlemeleri yaptıktan sonra dosyayı <filename>/a3/ramdisk/initrd/etc/X11</filename> dizini altına kopyalayın.
    </para><para>
İstemci makinalardaki fare, bir PS/2 fare ise <filename>dev</filename> dizinindeki <filename>mouse</filename> sembolik bağını <filename>psaux</filename> dosyasını gösterecek duruma getirmelisiniz (Normalde birinci seri portu gösterir).
    </para><para>
Şimdi sıra <filename>XFree86.0.log</filename> dosyasına bakarak gerekli kütüphaneleri sistemimize yerleştirmeye geldi. <filename>XFree86.0.log</filename> dosyasına baktığınızda <literal>(II) Loading</literal> ile başlayan aşağıdakine benzer satırlar göreceksiniz:
    </para><para>
<screen>(II) Loading /usr/X11R6/lib/modules/fonts/libbitmap.a</screen>
    </para><para>
Bu satırlar sistemimize kopyalamamız gereken kütüphane dosyalarını belirtir. Bu satırlara bakarak, X'in aynı dosya yolunda aynı dosyayı bulabilmesini sağlamamız gerekir. Yukarıdaki dosya için bu işlem şöyle yapılmalıdır:
    </para><para>
<screen># <userinput>cp /usr/X11R6/lib/modules/fonts/libbitmap.a /a3/ramdisk/initrd/lib/modules/fonts/</userinput>
</screen>
    </para><para>
Bu işlemi benzer şekilde <filename>XFree86.0.log</filename> dosyasındaki diğer kütüphane yükleme satırları için yapın. <filename>XFree86.0.log</filename> dosyasından önce bu satırları seçiyorum:
    </para><para>
<screen># <userinput>cat XFree86.0.log | grep "Loading /"</userinput>
(II) Loading /usr/X11R6/lib/modules/fonts/libbitmap.a
(II) Loading /usr/X11R6/lib/modules/libpcidata.a
(II) Loading /usr/X11R6/lib/modules/extensions/libdbe.a
(II) Loading /usr/X11R6/lib/modules/extensions/libextmod.a
(II) Loading /usr/X11R6/lib/modules/linux/libfbdevhw.a
(II) Loading /usr/X11R6/lib/modules/extensions/libglx.a
(II) Loading /usr/X11R6/lib/modules/extensions/libGLcore.a
(II) Loading /usr/X11R6/lib/modules/extensions/librecord.a
(II) Loading /usr/X11R6/lib/modules/fonts/libfreetype.a
(II) Loading /usr/X11R6/lib/modules/fonts/libtype1.a
(II) Loading /usr/X11R6/lib/modules/extensions/libdri.a
(II) Loading /usr/X11R6/lib/modules/linux/libdrm.a
(II) Loading /usr/X11R6/lib/modules/drivers/s3virge_drv.o
(II) Loading /usr/X11R6/lib/modules/input/mouse_drv.o
(II) Loading /usr/X11R6/lib/modules/libvgahw.a
(II) Loading /usr/X11R6/lib/modules/libvbe.a
(II) Loading /usr/X11R6/lib/modules/linux/libint10.a
(II) Loading /usr/X11R6/lib/modules/libddc.a
(II) Loading /usr/X11R6/lib/modules/libi2c.a
(II) Loading /usr/X11R6/lib/modules/libfb.a
(II) Loading /usr/X11R6/lib/modules/libxaa.a
(II) Loading /usr/X11R6/lib/modules/libramdac.a
</screen>
    </para><para>
Bu liste büyük ihtimalle sizin için farklı olacaktır. Şimdi bu listeye göre bu dosyaları ramdisk sistemine kopyalayacağım:
    </para><para>
<screen># <userinput>cd /a3/ramdisk/initrd/lib/modules</userinput>
# <userinput>cp /usr/X11R6/lib/modules/fonts/libbitmap.a ./fonts/</userinput>
# <userinput>cp /usr/X11R6/lib/modules/libpcidata.a ./</userinput>
# <userinput>cp /usr/X11R6/lib/modules/extensions/libdbe.a ./extensions/</userinput>
# <userinput>cp /usr/X11R6/lib/modules/extensions/libextmod.a ./extensions/</userinput>
# <userinput>cp /usr/X11R6/lib/modules/linux/libfbdevhw.a ./linux/</userinput>
# <userinput>cp /usr/X11R6/lib/modules/extensions/libglx.a ./extensions/</userinput>
# <userinput>cp /usr/X11R6/lib/modules/extensions/libGLcore.a ./extensions/</userinput>
# <userinput>cp /usr/X11R6/lib/modules/extensions/librecord.a ./extensions/</userinput>
# <userinput>cp /usr/X11R6/lib/modules/fonts/libfreetype.a ./fonts/</userinput>
# <userinput>cp /usr/X11R6/lib/modules/fonts/librecord.a ./fonts/</userinput>
# <userinput>cp /usr/X11R6/lib/modules/extensions/libdri.a ./extensions/</userinput>
# <userinput>cp /usr/X11R6/lib/modules/linux/libdrm.a ./linux/</userinput>
# <userinput>cp /usr/X11R6/lib/modules/input/mouse_drv.o ./input/</userinput>
# <userinput>cp /usr/X11R6/lib/modules/libvgahw.a ./</userinput>
# <userinput>cp /usr/X11R6/lib/modules/libvbe.a ./</userinput>
# <userinput>cp /usr/X11R6/lib/modules/linux/libint10.a ./linux/</userinput>
# <userinput>cp /usr/X11R6/lib/modules/libddc.a ./</userinput>
# <userinput>cp /usr/X11R6/lib/modules/libi2c.a ./</userinput>
# <userinput>cp /usr/X11R6/lib/modules/libfb.a ./</userinput>
# <userinput>cp /usr/X11R6/lib/modules/libxaa.a ./</userinput>
# <userinput>cp /usr/X11R6/lib/modules/libramdac.a ./</userinput>
</screen>
    </para><para>
X bunlardan başka klavye için gereken bazı dosyaları da arar ve bunlar günlük dosyasında görünmezler. Şimdi bu dosyaları yükleyeceğiz. Yalnız bu dosyaları sadece türkçe klavye yüklenecek biçimde küçülteceğiz. Bu işlemleri burada anlattığım gibi aynen yapmalısınız. Önce gerekli dizinleri oluşturun:
    </para><para>
<screen># <userinput>cd /a3/ramdisk/initrd/lib/X11/xkb</userinput>
# <userinput>mkdir compat geometry keycodes keymap rules semantics symbols symbols/pc types</userinput>
# <userinput>ln -s ../../../var/lib/xkb compiled</userinput>
</screen>
    </para><para>
<userinput>xkbcomp</userinput> dosyasını kopyalayalım ve hangi kütüphanelere ihtiyaç duyduğuna bakalım:
    </para><para>
<screen># <userinput>cp /usr/X11R6/lib/X11/xkb/xkbcomp ./</userinput>
# <userinput>ldd ./xkbcomp</userinput>
        libXext.so.6 => /usr/X11R6/lib/libXext.so.6 (0x40030000)
        libX11.so.6 => /usr/X11R6/lib/libX11.so.6 (0x4003e000)
        libc.so.6 => /lib/i686/libc.so.6 (0x4011d000)
        libdl.so.2 => /lib/libdl.so.2 (0x40258000)
        /lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x40000000)
</screen>
    </para><para>
Son 3 kütüphane zaten var. Diğerlerini kopyalamamız lazım:
    </para><para>
<screen># <userinput>cd /a3/ramdisk/initrd/lib</userinput>
# <userinput>cp -d /usr/X11R6/lib/libXext.so.6 ./</userinput>
# <userinput>cp -d /usr/X11R6/lib/libX11.so.6 ./</userinput>
# <userinput>cp /usr/X11R6/lib/libXext.so.6.4 ./</userinput>
# <userinput>cp /usr/X11R6/lib/libX11.so.6.2 ./</userinput>
# <userinput>cd /a3/ramdisk/initrd/lib/X11/xkb</userinput>
</screen>
    </para><para>
Bu dizinde 6 tane de dosya bulunacak. Bu dosyalar ve içerikleri aşağıdaki gibi olmalı. Ben basitçe dosyaları <userinput>cat</userinput> komutu ile aldığım konsol çıktılarını aşağıya kopyaladım, siz bunları dosya haline getirin. (Bu dosyalar sisteminizde de vardır ama genel amaçlı olduklarından çok yer kaplarlar, bu dosyalar fazlalıklarından temizlenmiştir. Ama, sisteminizdeki dosyaları değiştirmeyin, sakın. Sabit diske kurulmuş bir sistemin böyle bir yer kazancına ihtiyacı yoktur.):
    </para><para>
<screen># <userinput>cat compat.dir</userinput>
-dp----- -------- accessx(basic)
--p----- -------- accessx(full)
-d------ -------- basic(basic)
-d------ -------- complete(complete)
-d------ -------- default(default)
-d------ -------- group_led(group_led)
-dp----- -------- iso9995(default)
h-p----- -------- keypad(overlay)
h-p----- -------- keypad(overlay1)
h-p----- -------- keypad(overlay2)
--p----- -------- leds(scroll)
--p----- -------- leds(num)
--p----- -------- leds(caps)
-dp----- -------- misc(misc)
-dp----- -------- mousekeys(mousekeys)
-dp----- -------- norepeat(norepeat)
-dp----- -------- pc(pc)
-dp----- -------- xfree86(basic)
-d------ -------- xtest(xtest)
# <userinput>cat geometry.dir</userinput>
-d------ -------- pc(pc101)
-------- -------- pc(pc102)
-------- -------- pc(pc104)
-------- -------- pc(pc105)
# <userinput>cat keycodes.dir</userinput>
-d------ -------- xfree86(xfree86)
-------- -------- xfree86(basic)
-------- -------- xfree86(102)
-d------ -------- xfree86.xkb-broken-capslock-fix-CVS11006(xfree86)
-------- -------- xfree86.xkb-broken-capslock-fix-CVS11006(basic)
-------- -------- xfree86.xkb-broken-capslock-fix-CVS11006(102)
# <userinput>cat keymap.dir</userinput>
-------- -------- xfree86(tr_q)
-------- -------- xfree86(tr_f)
# <userinput>cat symbols.dir</userinput>
--p----- -m------ altwin(meta_alt)
--p----- -m------ altwin(meta_win)
--p----- -m------ altwin(left_meta_win)
--p----- -m------ altwin(super_win)
--p----- -m------ altwin(hyper_win)
--p----- -m------ altwin(menu)
--p----- -m------ compose(ralt)
--p----- -m------ compose(rwin)
--p----- -m------ compose(menu)
--p----- -m------ ctrl(nocaps)
--p----- -m------ ctrl(swapcaps)
--p----- -m------ ctrl(ctrl_ac)
--p----- -m------ ctrl(ctrl_aa)
--p----- -m------ group(switch)
--p----- -m------ group(lswitch)
--p----- -m------ group(win_switch)
--p----- -m------ group(lwin_switch)
--p----- -m------ group(rwin_switch)
--p----- -m------ group(toggle)
--p----- -m------ group(shift_toggle)
--p----- -m------ group(ctrl_shift_toggle)
--p----- -m------ group(caps_toggle)
--p----- -m------ group(ctrl_alt_toggle)
--p----- -m------ group(alt_shift_toggle)
--p----- -m------ group(menu_toggle)
--p----- -m------ group(lwin_toggle)
--p----- -m------ group(rwin_toggle)
--p----- -m------ group(ctrls_toggle)
--p----- -m------ group(alts_toggle)
--p----- -m------ group(lshift_toggle)
--p----- -m------ group(rshift_toggle)
--p----- -m------ group(lalt_toggle)
--p----- -m------ group(lctrl_toggle)
--p----- -m------ group(rctrl_toggle)
h-p----- am--g--- iso9995-3(full_common)
--p----- am--g--- iso9995-3(full)
--p----- am--g--- iso9995-3(full101)
h-p----- --k----- keypad(overlay)
h-p----- --k----- keypad(overlay1)
h-p----- --k----- keypad(overlay2)
--p----- -m------ level3(switch)
--p----- -m------ level3(ralt_switch)
--p----- -m------ level3(ralt_switch_multikey)
--p----- -m------ level3(menu_switch)
--p----- -m------ level3(win_switch)
--p----- -m------ level3(lwin_switch)
--p----- -m------ level3(rwin_switch)
h-p----- -m------ lock(shift)
h-p----- -m------ lock(caps)
h-p----- -m------ lock(group)
-dp----- -m------ pc104(altmeta)
-------- -------- pc104(compose)
--p----- -m------ pc104(menu)
--p----- --kf---- srvr_ctrl(xfree86)
--p----- --k----- srvr_ctrl(stdkeypad)
--p----- ---f---- srvr_ctrl(fkey2vt)
-dp----- -------- pc/latin(basic)
--p----- -------- pc/latin(type2)
--p----- -------- pc/latin(type3)
--p----- -------- pc/latin(type4)
--p----- -------- pc/latin(nodeadkeys)
--p----- -------- pc/latin(type2_nodeadkeys)
--p----- -------- pc/latin(type3_nodeadkeys)
--p----- -------- pc/latin(type4_nodeadkeys)
h-p----- am------ pc/pc(basic)
-------- -------- pc/pc(pc101)
-------- -------- pc/pc(pc102)
-d------ -------- pc/pc(pc104)
-------- -------- pc/pc(pc105)
-------- -------- pc/pc(common)
-dp----- -------- pc/tr_q(basic)
--p----- -------- pc/tr_f(basic)
-dp----- -------- pc/tr.xkb-broken-capslock-fix-CVS11006(basic)
h-p----- am------ pc/pc.xkb-sysreq(basic)
-------- -------- pc/pc.xkb-sysreq(pc101)
-------- -------- pc/pc.xkb-sysreq(pc102)
-d------ -------- pc/pc.xkb-sysreq(pc104)
-------- -------- pc/pc.xkb-sysreq(pc105)
-------- -------- pc/pc.xkb-sysreq(common)
--p----- -m------ level3.xkb-broken-capslock-fix-CVS11006(switch)
--p----- -m------ level3.xkb-broken-capslock-fix-CVS11006(menu_switch)
--p----- -m------ level3.xkb-broken-capslock-fix-CVS11006(win_switch)
--p----- -m------ level3.xkb-broken-capslock-fix-CVS11006(lwin_switch)
--p----- -m------ level3.xkb-broken-capslock-fix-CVS11006(rwin_switch)
--p----- -m------ level3.xkb-ru-group-number-fix-CVS11092(switch)
--p----- -m------ level3.xkb-ru-group-number-fix-CVS11092(ralt_switch)
--p----- -m------ level3.xkb-ru-group-number-fix-CVS11092(ralt_switch_multikey)
--p----- -m------ level3.xkb-ru-group-number-fix-CVS11092(menu_switch)
--p----- -m------ level3.xkb-ru-group-number-fix-CVS11092(win_switch)
--p----- -m------ level3.xkb-ru-group-number-fix-CVS11092(lwin_switch)
--p----- -m------ level3.xkb-ru-group-number-fix-CVS11092(rwin_switch)
# <userinput>cat types.dir</userinput>
-d------ -------- basic(basic)
-dp----- -------- cancel(Shift_Cancels_Caps)
--p----- -------- caps(internal)
--p----- -------- caps(internal_nocancel)
--p----- -------- caps(shift)
--p----- -------- caps(shift_nocancel)
-d------ -------- complete(complete)
-d------ -------- default(default)
-dp----- -------- extra(default)
-dp----- -------- iso9995(default)
-dp----- -------- mousekeys(default)
-dp----- -------- nocancel(nocancel)
-dp----- -------- pc(default)
</screen>
    </para><para>
<filename>compat</filename> dizini için aşağıdaki işlemleri yapın:
    </para><para>
<screen># <userinput>cp /usr/X11R6/lib/X11/xkb/compat/* ./compat/</userinput>
# <userinput>rm -f ./compat/README</userinput>
</screen>
    </para><para>
<filename>geometry</filename> dizini için aşağıdaki işlemi yapın:
    </para><para>
<screen># <userinput>cp /usr/X11R6/lib/X11/xkb/geometry/pc ./geometry/</userinput>
</screen>
    </para><para>
<filename>keycodes</filename> dizini için aşağıdaki işlemleri yapın:
    </para><para>
<screen># <userinput>cp /usr/X11R6/lib/X11/xkb/keycode/aliases ./geometry/</userinput>
# <userinput>cp /usr/X11R6/lib/X11/xkb/keycode/xfree86 ./geometry/</userinput>
</screen>
    </para><para>
<filename>keymap</filename> dizini için aşağıdaki işlemi yapın:
    </para><para>
<screen># <userinput>cp /usr/X11R6/lib/X11/xkb/keymap/xfree86 ./keymap/</userinput>
</screen>
    </para><para>
<filename>rules</filename> dizini için aşağıdaki işlemi yapın:
    </para><para>
<screen># <userinput>cp /usr/X11R6/lib/X11/xkb/rules/xfree86 ./rules/</userinput>
</screen>
    </para><para>
<filename>semantics</filename> dizini için aşağıdaki işlemi yapın:
    </para><para>
<screen># <userinput>cp /usr/X11R6/lib/X11/xkb/semantics/* ./semantics/</userinput>
</screen>
    </para><para>
<filename>symbols</filename> dizinine,  <filename>/usr/X11R6/lib/X11/xkb/symbols/</filename> dizininden <filename>altwin, ctrl, iso9995-3, level3, lt_std, pc104, srvr_ctrl, us_group3, compose, group, keypad, lock, ralt, us_group2</filename> ve <filename>us_intl</filename> dosyalarını kopyalayın.
    </para><para>
<filename>symbols/pc</filename> dizinine,  <filename>/usr/X11R6/lib/X11/xkb/symbols/pc</filename> dizininden <filename>latin</filename> ve <filename>pc</filename> dosyalarını kopyalayın. Aşağıdaki 2 dosyayı oluşturun:
    </para><para>
<screen># <userinput>cat tr_q</userinput>
// based on
// Turkish keyboard symbols for PC and xkb
// This file distributed without any expressed or implied warranty
// Nilgün Belma Bugüner &lt;nilgun@superonline.com>, 2004
//
//Default Layout (Turkish Q)
default partial
xkb_symbols "basic" {

    include "pc/latin"

    name[Group1]="Turkish_Q";

    key &lt;AE01>  { [         1,    exclam,    onesuperior,    exclamdown ] };
    key &lt;AE02>  { [         2, apostrophe,      sterling,   twosuperior ] };
    key &lt;AE03>  { [        3, asciicircum,    numbersign, threesuperior ] };
    key &lt;AE04>  { [         4,       plus,        dollar,    onequarter ] };
    key &lt;AE06>  { [         6,  ampersand, threequarters,    VoidSymbol ] };
    key &lt;AE07>  { [         7,      slash,     braceleft,    VoidSymbol ] };
    key &lt;AE08>  { [         8,  parenleft,   bracketleft,    VoidSymbol ] };
    key &lt;AE09>  { [         9, parenright,  bracketright,     plusminus ] };
    key &lt;AE10>  { [         0,      equal,    braceright,        degree ] };
    key &lt;AE11>  { [  asterisk,   question,     backslash,  questiondown ] };
    key &lt;AE12>  { [     minus, underscore,      division,    VoidSymbol ] };

    key &lt;AD02>  { [         w,          W,   VoidSymbol,   VoidSymbol ] };
    key &lt;AD03>  { [         e,          E,     EuroSign,   VoidSymbol ] };
    key &lt;AD05>  { [         t,          T,    trademark,   VoidSymbol ] };
    key &lt;AD07>  { [         u,          U,  ucircumflex,  Ucircumflex ] };
    key &lt;AD08>  { [  idotless,          I,  icircumflex,  Icircumflex ] };
    key &lt;AD09>  { [         o,          O,  ocircumflex,  Ocircumflex ] };
    key &lt;AD10>  { [         p,          P,   VoidSymbol,   VoidSymbol ] };
    key &lt;AD11>  { [    gbreve,     Gbreve ] };
    key &lt;AD12>  { [udiaeresis, Udiaeresis,   asciitilde,  dead_macron ] };

    key &lt;AC01>  { [         a,          A,  acircumflex,  Acircumflex ] };
    key &lt;AC02>  { [         s,          S,      section,   VoidSymbol ] };
    key &lt;AC03>  { [         d,          D,   VoidSymbol,   VoidSymbol ] };
    key &lt;AC04>  { [         f,          F,  ordfeminine,   VoidSymbol ] };
    key &lt;AC05>  { [         g,          G,   VoidSymbol,   VoidSymbol ] };
    key &lt;AC06>  { [         h,          H,   VoidSymbol,   VoidSymbol ] };
    key &lt;AC08>  { [         k,          K,   VoidSymbol,   VoidSymbol ] };
    key &lt;AC09>  { [         l,          L,   VoidSymbol,   VoidSymbol ] };
    key &lt;AC10>  { [  scedilla,   Scedilla,        acute,   dead_acute ] };
    key &lt;AC11>  { [         i,  Iabovedot,   apostrophe,   dead_caron ] };
    key &lt;TLDE>  { [  quotedbl,  backslash,    plusminus,       degree ] };

    key &lt;BKSL>  { [     comma,  semicolon,        grave,   dead_grave ] };
    key &lt;LSGT>  { [      less,    greater,          bar,    brokenbar ] };
    key &lt;AB08>  { [odiaeresis, Odiaeresis,     multiply,   VoidSymbol ] };
    key &lt;AB09>  { [  ccedilla,   Ccedilla, periodcentered,     division ] };
    key &lt;AB10>  { [    period,      colon, dead_abovedot, dead_abovedot ] };
    key &lt;SPCE>  { [     space,      space, nobreakspace,   nobreakspace ] };

    include "level3(ralt_switch_multikey)"
    modifier_map Mod5   { &lt;RALT> };
};
# <userinput>cat tr_f</userinput>
// based on
// Turkish keyboard symbols for PC and xkb
// This file distributed without any expressed or implied warranty
// Nilgün Belma Bugüner &lt;nilgun@superonline.com>, 2004
//
//Default Layout (Turkish F)
default partial
xkb_symbols "basic" {

    include "pc/latin"

    name[Group1]="Turkish_F";

    key &lt;AE01>  { [         1,     exclam,  onesuperior,   exclamdown ] };
    key &lt;AE02>  { [         2,   quotedbl,  twosuperior,   VoidSymbol ] };
    key &lt;AE03>  { [         3, asciicircum, numbersign, threesuperior ] };
    key &lt;AE04>  { [         4,     dollar,   onequarter,   VoidSymbol ] };
    key &lt;AE06>  { [         6,  ampersand, threequarters,  VoidSymbol ] };
    key &lt;AE07>  { [         7, apostrophe,    braceleft,   VoidSymbol ] };
    key &lt;AE08>  { [         8,  parenleft,  bracketleft,   VoidSymbol ] };
    key &lt;AE09>  { [         9, parenright, bracketright,    plusminus ] };
    key &lt;AE10>  { [         0,      equal,   braceright,       degree ] };
    key &lt;AE11>  { [     slash,   question,    backslash, questiondown ] };
    key &lt;AE12>  { [     minus, underscore,     division,   VoidSymbol ] };

    key &lt;AD01>  { [         f,          F,           at,   VoidSymbol ] };
    key &lt;AD02>  { [         g,          G,   VoidSymbol,   VoidSymbol ] };
    key &lt;AD03>  { [    gbreve,     Gbreve,   VoidSymbol,   VoidSymbol ] };
    key &lt;AD04>  { [  idotless,          I,    paragraph,   VoidSymbol ] };
    key &lt;AD05>  { [         o,          O,  ocircumflex,  Ocircumflex ] };
    key &lt;AD06>  { [         d,          D,          yen,   VoidSymbol ] };
    key &lt;AD07>  { [         r,          R,   registered,   VoidSymbol ] };
    key &lt;AD08>  { [         n,          N,   VoidSymbol,   VoidSymbol ] };
    key &lt;AD09>  { [         h,          H,       degree,   VoidSymbol ] };
    key &lt;AD10>  { [         p,          P,     sterling,   VoidSymbol ] };
    key &lt;AD11>  { [         q,          Q, dead_diaeresis, dead_abovering ] };
    key &lt;AD12>  { [         w,          W,   asciitilde,   dead_breve ] };

    key &lt;AC01>  { [         u,          U,  ucircumflex,  Ucircumflex ] };
    key &lt;AC02>  { [         i,  Iabovedot,  icircumflex,  Icircumflex ] };
    key &lt;AC03>  { [         e,          E,     EuroSign,   VoidSymbol ] };
    key &lt;AC04>  { [         a,          A,  acircumflex,  Acircumflex ] };
    key &lt;AC05>  { [udiaeresis, Udiaeresis,  ucircumflex,  Ucircumflex ] };
    key &lt;AC06>  { [         t,          T,    trademark,   VoidSymbol ] };
    key &lt;AC07>  { [         k,          K,   VoidSymbol,   VoidSymbol ] };
    key &lt;AC08>  { [         m,          M,           mu,   VoidSymbol ] };
    key &lt;AC09>  { [         l,          L,   VoidSymbol,   VoidSymbol ] };
    key &lt;AC10>  { [         y,          Y,        acute,   dead_acute ] };
    key &lt;AC11>  { [  scedilla,   Scedilla,   numbersign,   dead_caron ] };
    key &lt;TLDE>  { [      plus,   asterisk,      notsign,    plusminus ] };

    key &lt;BKSL>  { [         x,          X,        grave,   dead_grave ] };
    key &lt;AB01>  { [         j,          J, guillemotleft,  VoidSymbol ] };
    key &lt;AB02>  { [odiaeresis, Odiaeresis, guillemotright, VoidSymbol ] };
    key &lt;AB03>  { [         v,          V, leftdoublequotemark, VoidSymbol ] };
    key &lt;AB04>  { [         c,          C,         cent,    copyright ] };
    key &lt;AB05>  { [  ccedilla,   Ccedilla, rightdoublequotemark, VoidSymbol] };
    key &lt;AB06>  { [         z,          Z,   VoidSymbol,   VoidSymbol ] };
    key &lt;AB07>  { [         s,          S,      section,   VoidSymbol ] };
    key &lt;AB08>  { [         b,          B,     multiply, nobreakspace ] };
    key &lt;AB09>  { [    period,      colon,     division, dead_abovedot] };
    key &lt;AB10>  { [     comma,  semicolon, periodcentered, VoidSymbol ] };
    key &lt;SPCE>  { [    space,       space, nobreakspace, nobreakspace ] };
    key &lt;LSGT>  { [     less,     greater,          bar,    brokenbar ] };

    include "level3(ralt_switch_multikey)"
    modifier_map Mod5   { &lt;RALT> };
};
</screen>
    </para><para>
<filename>types</filename> dizini için aşağıdaki işlemleri yapın:
    </para><para>
<screen># <userinput>cp /usr/X11R6/lib/X11/xkb/types/* ./types/</userinput>
# <userinput>rm -f ./types/README</userinput>
</screen>
    </para><para>
Klavye yapılandırması ile ilgili olarak <filename>/a3/ramdisk/initrd/lib/X11/locale</filename> dizininde de bazı işlemler yapacağız. Önce bize gereken dizinleri açalım:
    </para><para>
<screen># <userinput>cd /a3/ramdisk/initrd/lib/X11/locale</userinput>
# <userinput>mkdir C en_US.UTF-8 iso8859-9 lib lib/common</userinput>
</screen>
    </para><para>
Bu dizinde 3 dosya oluşturacağız. Bunlar:
    </para><para>
<screen># <userinput>cat compose.dir</userinput>
iso8859-1/Compose               C
iso8859-1/Compose               en_US.ISO8859-1
iso8859-9/Compose               tr_TR.ISO8859-9
#
en_US.UTF-8/Compose             en_US.UTF-8
en_US.UTF-8/Compose             tr_TR.UTF-8
# <userinput>cat locale.alias</userinput>
POSIX                                           C
POSIX-UTF2                                      C
C_C.C                                           C
C.en                                            C
C.iso88591                                      en_US.ISO8859-1
Cextend                                         en_US.ISO8859-1
Cextend.en                                      en_US.ISO8859-1
English_United-States.437                       C
en_US                                           en_US.ISO8859-1
en_US.88591                                     en_US.ISO8859-1
en_US.88591.en                                  en_US.ISO8859-1
en_US.iso88591                                  en_US.ISO8859-1
en_US.iso885915                                 en_US.ISO8859-15
en_US.ISO-8859-1                                en_US.ISO8859-1
en_US.ISO_8859-1                                en_US.ISO8859-1

tr                                              tr_TR.ISO8859-9
tr_TR                                           tr_TR.ISO8859-9
tr_TR.iso88599                                  tr_TR.ISO8859-9
tr_TR.ISO-8859-9                                tr_TR.ISO8859-9
tr_TR.utf8                                      tr_TR.UTF-8

tr:                                             tr_TR.ISO8859-9
tr_TR:                                          tr_TR.ISO8859-9
tr_TR.iso88599:                                 tr_TR.ISO8859-9
tr_TR.ISO-8859-9:                               tr_TR.ISO8859-9
tr_TR.utf8:                                     tr_TR.UTF-8
# <userinput>cat locale.dir</userinput>
C/XLC_LOCALE                            C
iso8859-1/XLC_LOCALE                    en_US.ISO8859-1
iso8859-9/XLC_LOCALE                    tr_TR.ISO8859-9
en_US.UTF-8/XLC_LOCALE                  en_US.UTF-8
en_US.UTF-8/XLC_LOCALE                  tr_TR.UTF-8

C/XLC_LOCALE:                           C
iso8859-15/XLC_LOCALE:                  en_US.ISO8859-15
iso8859-9/XLC_LOCALE:                   tr_TR.ISO8859-9
en_US.UTF-8/XLC_LOCALE:                 en_US.UTF-8
en_US.UTF-8/XLC_LOCALE:                 tr_TR.UTF-8
</screen>
    </para><para>
<filename>C</filename> dizini için aşağıdaki işlemi yapın:
    </para><para>
<screen># <userinput>cp /usr/X11R6/lib/X11/locale/C/* ./C/</userinput>
</screen>
    </para><para>
<filename>en_US.UTF-8</filename> dizini için aşağıdaki işlemi yapın:
    </para><para>
<screen># <userinput>cp /usr/X11R6/lib/X11/locale/en_US.UTF-8/* ./en_US.UTF-8/</userinput>
</screen>
    </para><para>
<filename>iso8859-9</filename> dizini için aşağıdaki işlemi yapın:
    </para><para>
<screen># <userinput>cp /usr/X11R6/lib/X11/locale/iso8859-9/* ./iso8859-9/</userinput>
</screen>
    </para><para>
<filename>lib/common</filename> dizini için aşağıdaki işlemi yapın:
    </para><para>
<screen># <userinput>cp /usr/X11R6/lib/X11/locale/lib/common/* ./lib/common/</userinput>
</screen>
    </para><para>
Bu dosyalardan başka X'in yüklediği bazı dosyalar var. Bunları bulamazsa hata verip çalışmasını durduruyor. Siz böyle bir durumda X terminaliniz çalışmazsa komut satırından <userinput>cat /var/log/XFree86.0.log</userinput> komutunu verip, hatanın sebebini öğrenip X'in aradığı dosyayı sisteminize eklemelisiniz.
    </para><para>
Son işlemlerden olarak, aşağıdaki işlemleri yapın:
    </para><para>
<screen># <userinput>cd /a3/ramdisk/initrd/lib/X11</userinput>
# <userinput>cp /usr/X11R6/lib/X11/app-defaults/Xmessage ./app-defaults/</userinput>
# <userinput>cp /usr/X11R6/lib/X11/Cards ./</userinput>
# <userinput>cp /usr/X11R6/lib/X11/Options ./</userinput>
# <userinput>cp /usr/X11R6/lib/X11/rgb.txt ./</userinput>
# <userinput>cp /usr/X11R6/lib/X11/XErrorDB ./</userinput>
# <userinput>cp /usr/X11R6/lib/X11/XKeysymDB ./</userinput>
# <userinput>ln -s /etc/X11/XF86Config</userinput>
# <userinput>cd /a3/ramdisk/etc/X11</userinput>
# <userinput>ln -s ../../bin/XFree86 X</userinput>
# <userinput>cp /etc/X11/xserver/SecurityPolicy ./xserver/</userinput>
</screen>
    </para><para>
X ile ilgili olarak sistemin yapılandırılması bitti. Şimdi açılış sırasında X'in yüklenmesini sağlayacak işlemleri yapalım. <filename>etc/inittab</filename> dosyasını aşağıdaki biçime getirin:
    </para><para>
<screen>
::sysinit:/etc/init.d/baslat

tty1::askfirst:/bin/busybox sh
tty2::askfirst:/bin/X -query 10.10.10.1

::ctrlaltdel:/bin/reboot -d 0
::restart:/sbin/init
</screen>
    </para><para>
Bu dosyanın bir önceki inittab dosyasından farkı <literal>tty2::askfirst:/bin/X -query 10.10.10.1</literal> satırı. Bu satırla 2. konsola geçip enter tuşuna bastığımızda X çalıştırılacak. <option>-query 10.10.10.1</option> seçeneği ile de bağlanacağı X sunucusunun IP adresini belirtiyoruz.
    </para><para>
<filename>etc/init.d/baslat</filename> betiğine de bazı açıklamalar koysak iyi olur. Dosyanın sonununa aşağıdaki satırları ya da siz ne uygun görürseniz yazın. Bu, sadece, X terminalinin kullanıcısına bilgi vermek için:
    </para><para>
<screen>clear

echo ""
echo ""
echo ""
echo "          +-----------------------------------------------+"
echo "          | X oturumunu baslatmak icin: ALT-F2 ve ENTER   |"
echo "          |                                               |"
echo "          | X Oturumunundan cikmak icin : CTRL-ALT-F1     |"
echo "          |                                               |"
echo "          | Sistemi kapatmak icin:                        |"
echo "          | X oturumundan ciktiktan sonra poweroff yazip  |"
echo "          | ENTER'a basin.                                |"
echo "          +-----------------------------------------------+"

exit 0
</screen>
    </para><para>
Son olarak, <userinput>initrdyap</userinput> betiğini çalıştırıp <literal>initrd.img</literal> dosyasını oluşturduktan sonra istemci makinaya geçip, <literal>netlogon</literal> dizinindeki betiği çalıştırıp dosyaları windows'a aktarın ve <literal>LINUX OL</literal> simgesine tıklayıp yaptıklarınızı deneyin.
    </para><para>
Sunucu makinaya bağlantı kurulduğunda karşınıza <userinput>gdm</userinput>'nin oturum açma ekranı gelecek. 10 saniye içinde bir kullanıcı ismi ve parolası vermezseniz <literal>talebe</literal> kullanıcısı ile size bir oturum açılacaktır. Bu noktadan sonra artık sunucu makinanın bir kullanıcısı olacaksınız ve ev dizininiz <literal>/home/talebe</literal> dizini olacaktır. Eğer tüm X terminali kullanıcılarının ayrı ev dizinleri olmasını isterseniz (hepsi <literal>talebe</literal>'nin ev dizinini kullanırsa kavga çıkabilir) onlar için sunucu makina üzerinde kullanıcı oluşturup, daha sonra değiştirmelerini söyleyerek bir parola vermelisiniz. Kullanıcılar sisteme kendi kullanıcı isimleriyle bağlandıktan sonra parolalarını <userinput>passwd</userinput> komutu ile değiştirebilirler. <literal>talebe</literal> kullanıcısı için bunu yapamazlar, çünkü yapmaları sistem tarafından engellenir.
    </para><para>
<filename>/a3/ramdisk/initrd</filename> dizini altındaki sistemin ne kadar yer kapladığını <userinput>du /a3/ramdisk/initrd</userinput> komutunu vererek öğrenebilirsiniz. Çıktının son satırı dizinin sabit diskte kapladığı alanı kB cinsinden verir. Bu değer benim oluşturduğum sistem için 11279 kB idi. Eğer oluşturduğunuz sistem (12000 - 500) kB'ı aşıyorsa, <userinput>initrdyap</userinput> betiğindeki 12000 lik değeri arttırmalısınız. <filename>linux.bat</filename> dosyasında da bu değeri değiştirmelisiniz. X terminalinin konsolunda <userinput>df -k</userinput> komutu ile ramdiskin boyutunu ve ne kadarının kullanıldığı ile ne kadar yerin boş olduğunu öğrenebilirsiniz. Bu değerlere bakarak <filename>initrd.rd</filename> dosyasının boyutunun ne olması gerektiği hakkında bir fikir edinebilirsiniz. Ben 200 kB kadar bir boş alan kalmasına dikkat ettim ve bu dosyayı <userinput>initrdyap</userinput> betiği ile 12000 kB olarak oluşturdum. Çok sınır değerler için <userinput>initrdyap</userinput> betiği hata verecektir. Biraz bol tutmakta (ben ~700 kB kadar artı yer ayırdım) yarar var.
    </para>
  </sect2></sect1>
  <sect1 xml:id="windows-ve-linux_sonuc">
    <title>Sonuç</title>
    <para>
Bu belgedeki herşeyi adım adım uygulayarak yazdım. Ancak, elimde sadece 2 bilgisayar vardı. Daha fazla örnekleme imkanım yoktu. Eğer, uygulamada bir sorunla karşılaşırsanız, sorunun sizden kaynaklanmadığına iyice emin olduktan sonra bana bildirirseniz, geneli ilgilendiren bir sorunsa hem bir çözüm bulmaya çalışır hem de bu bilgiyi bu belgeye eklerim. Böylece bilgi paylaşılmış olur.
    </para><para>
Umarım birilerine yararı olur.
    </para></sect1>
  <appendix xml:id="windows-ve-linux_app1"><title>Çekirdek Yapılandırma Dosyası (<filename>.config</filename>)</title>
    <para>
<screen linenumbering = "numbered">
#
# Automatically generated by make menuconfig: don't edit
#
CONFIG_X86=y
# CONFIG_SBUS is not set
CONFIG_UID16=y

#
# Code maturity level options
#
CONFIG_EXPERIMENTAL=y

#
# Loadable module support
#
CONFIG_MODULES=y
# CONFIG_MODVERSIONS is not set
CONFIG_KMOD=y

#
# Processor type and features
#
CONFIG_M386=y
# CONFIG_M486 is not set
# CONFIG_M586 is not set
# CONFIG_M586TSC is not set
# CONFIG_M586MMX is not set
# CONFIG_M686 is not set
# CONFIG_MPENTIUMIII is not set
# CONFIG_MPENTIUM4 is not set
# CONFIG_MK6 is not set
# CONFIG_MK7 is not set
# CONFIG_MK8 is not set
# CONFIG_MELAN is not set
# CONFIG_MCRUSOE is not set
# CONFIG_MWINCHIPC6 is not set
# CONFIG_MWINCHIP2 is not set
# CONFIG_MWINCHIP3D is not set
# CONFIG_MCYRIXIII is not set
# CONFIG_MVIAC3_2 is not set
# CONFIG_X86_CMPXCHG is not set
# CONFIG_X86_XADD is not set
CONFIG_X86_L1_CACHE_SHIFT=4
CONFIG_RWSEM_GENERIC_SPINLOCK=y
# CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
CONFIG_X86_PPRO_FENCE=y
# CONFIG_X86_F00F_WORKS_OK is not set
CONFIG_X86_MCE=y
# CONFIG_TOSHIBA is not set
# CONFIG_I8K is not set
# CONFIG_MICROCODE is not set
# CONFIG_X86_MSR is not set
# CONFIG_X86_CPUID is not set
CONFIG_NOHIGHMEM=y
# CONFIG_HIGHMEM4G is not set
# CONFIG_HIGHMEM64G is not set
# CONFIG_HIGHMEM is not set
# CONFIG_MATH_EMULATION is not set
# CONFIG_MTRR is not set
# CONFIG_SMP is not set
# CONFIG_X86_UP_APIC is not set
# CONFIG_X86_UP_IOAPIC is not set
# CONFIG_X86_TSC_DISABLE is not set
CONFIG_X86_TSC=y

#
# General setup
#
CONFIG_NET=y
CONFIG_PCI=y
# CONFIG_PCI_GOBIOS is not set
# CONFIG_PCI_GODIRECT is not set
CONFIG_PCI_GOANY=y
CONFIG_PCI_BIOS=y
CONFIG_PCI_DIRECT=y
CONFIG_ISA=y
CONFIG_PCI_NAMES=y
# CONFIG_EISA is not set
# CONFIG_MCA is not set
# CONFIG_HOTPLUG is not set
# CONFIG_PCMCIA is not set
# CONFIG_HOTPLUG_PCI is not set
CONFIG_SYSVIPC=y
CONFIG_BSD_PROCESS_ACCT=y
CONFIG_SYSCTL=y
CONFIG_KCORE_ELF=y
# CONFIG_KCORE_AOUT is not set
# CONFIG_BINFMT_AOUT is not set
CONFIG_BINFMT_ELF=y
CONFIG_BINFMT_MISC=m
# CONFIG_PM is not set
# CONFIG_ACPI is not set
# CONFIG_APM is not set

#
# Memory Technology Devices (MTD)
#
# CONFIG_MTD is not set

#
# Parallel port support
#
# CONFIG_PARPORT is not set

#
# Plug and Play configuration
#
# CONFIG_PNP is not set
# CONFIG_ISAPNP is not set

#
# Block devices
#
# CONFIG_BLK_DEV_FD is not set
# CONFIG_BLK_DEV_XD is not set
# CONFIG_PARIDE is not set
# CONFIG_BLK_CPQ_DA is not set
# CONFIG_BLK_CPQ_CISS_DA is not set
# CONFIG_CISS_SCSI_TAPE is not set
# CONFIG_BLK_DEV_DAC960 is not set
# CONFIG_BLK_DEV_UMEM is not set
CONFIG_BLK_DEV_LOOP=y
# CONFIG_BLK_DEV_NBD is not set
CONFIG_BLK_DEV_RAM=y
CONFIG_BLK_DEV_RAM_SIZE=4096
CONFIG_BLK_DEV_INITRD=y
# CONFIG_BLK_STATS is not set

#
# Multi-device support (RAID and LVM)
#
# CONFIG_MD is not set
# CONFIG_BLK_DEV_MD is not set
# CONFIG_MD_LINEAR is not set
# CONFIG_MD_RAID0 is not set
# CONFIG_MD_RAID1 is not set
# CONFIG_MD_RAID5 is not set
# CONFIG_MD_MULTIPATH is not set
# CONFIG_BLK_DEV_LVM is not set

#
# Networking options
#
CONFIG_PACKET=y
CONFIG_PACKET_MMAP=y
CONFIG_NETLINK_DEV=m
# CONFIG_NETFILTER is not set
CONFIG_FILTER=y
CONFIG_UNIX=y
CONFIG_INET=y
CONFIG_IP_MULTICAST=y
CONFIG_IP_ADVANCED_ROUTER=y
CONFIG_IP_MULTIPLE_TABLES=y
CONFIG_IP_ROUTE_NAT=y
# CONFIG_IP_ROUTE_MULTIPATH is not set
# CONFIG_IP_ROUTE_TOS is not set
# CONFIG_IP_ROUTE_VERBOSE is not set
# CONFIG_IP_ROUTE_LARGE_TABLES is not set
# CONFIG_IP_PNP is not set
# CONFIG_NET_IPIP is not set
# CONFIG_NET_IPGRE is not set
# CONFIG_IP_MROUTE is not set
# CONFIG_ARPD is not set
# CONFIG_INET_ECN is not set
CONFIG_SYN_COOKIES=y
# CONFIG_IPV6 is not set
# CONFIG_KHTTPD is not set
# CONFIG_ATM is not set
# CONFIG_VLAN_8021Q is not set
# CONFIG_IPX is not set
# CONFIG_ATALK is not set

#
# Appletalk devices
#
# CONFIG_DEV_APPLETALK is not set
# CONFIG_DECNET is not set
# CONFIG_BRIDGE is not set
# CONFIG_X25 is not set
# CONFIG_LAPB is not set
# CONFIG_LLC is not set
# CONFIG_NET_DIVERT is not set
# CONFIG_ECONET is not set
# CONFIG_WAN_ROUTER is not set
# CONFIG_NET_FASTROUTE is not set
# CONFIG_NET_HW_FLOWCONTROL is not set

#
# QoS and/or fair queueing
#
# CONFIG_NET_SCHED is not set

#
# Network testing
#
# CONFIG_NET_PKTGEN is not set

#
# Telephony Support
#
# CONFIG_PHONE is not set
# CONFIG_PHONE_IXJ is not set
# CONFIG_PHONE_IXJ_PCMCIA is not set

#
# ATA/IDE/MFM/RLL support
#
# CONFIG_IDE is not set
# CONFIG_BLK_DEV_IDE_MODES is not set
# CONFIG_BLK_DEV_HD is not set

#
# SCSI support
#
# CONFIG_SCSI is not set

#
# Fusion MPT device support
#
# CONFIG_FUSION is not set
# CONFIG_FUSION_BOOT is not set
# CONFIG_FUSION_ISENSE is not set
# CONFIG_FUSION_CTL is not set
# CONFIG_FUSION_LAN is not set

#
# IEEE 1394 (FireWire) support (EXPERIMENTAL)
#
# CONFIG_IEEE1394 is not set

#
# I2O device support
#
# CONFIG_I2O is not set
# CONFIG_I2O_PCI is not set
# CONFIG_I2O_BLOCK is not set
# CONFIG_I2O_LAN is not set
# CONFIG_I2O_SCSI is not set
# CONFIG_I2O_PROC is not set

#
# Network device support
#
CONFIG_NETDEVICES=y

#
# ARCnet devices
#
# CONFIG_ARCNET is not set
CONFIG_DUMMY=m
# CONFIG_BONDING is not set
# CONFIG_EQUALIZER is not set
# CONFIG_TUN is not set
# CONFIG_ETHERTAP is not set

#
# Ethernet (10 or 100Mbit)
#
CONFIG_NET_ETHERNET=y
# CONFIG_SUNLANCE is not set
CONFIG_HAPPYMEAL=m
# CONFIG_SUNBMAC is not set
# CONFIG_SUNQE is not set
CONFIG_SUNGEM=m
CONFIG_NET_VENDOR_3COM=y
CONFIG_EL1=m
CONFIG_EL2=m
CONFIG_ELPLUS=m
CONFIG_EL16=m
CONFIG_EL3=m
CONFIG_3C515=m
# CONFIG_ELMC is not set
# CONFIG_ELMC_II is not set
CONFIG_VORTEX=m
CONFIG_TYPHOON=m
CONFIG_LANCE=m
CONFIG_NET_VENDOR_SMC=y
CONFIG_WD80x3=m
# CONFIG_ULTRAMCA is not set
CONFIG_ULTRA=m
# CONFIG_ULTRA32 is not set
CONFIG_SMC9194=m
CONFIG_NET_VENDOR_RACAL=y
CONFIG_NI5010=m
CONFIG_NI52=m
CONFIG_NI65=m
CONFIG_AT1700=m
CONFIG_DEPCA=m
CONFIG_HP100=m
CONFIG_NET_ISA=y
CONFIG_E2100=m
CONFIG_EWRK3=m
CONFIG_EEXPRESS=m
CONFIG_EEXPRESS_PRO=m
CONFIG_HPLAN_PLUS=m
CONFIG_HPLAN=m
CONFIG_LP486E=m
CONFIG_ETH16I=m
CONFIG_NE2000=m
CONFIG_NET_PCI=y
CONFIG_PCNET32=m
CONFIG_AMD8111_ETH=m
CONFIG_ADAPTEC_STARFIRE=m
CONFIG_AC3200=m
CONFIG_APRICOT=m
CONFIG_CS89x0=m
CONFIG_TULIP=m
CONFIG_TULIP_MWI=y
CONFIG_TULIP_MMIO=y
CONFIG_DE4X5=m
CONFIG_DGRS=m
CONFIG_DM9102=m
CONFIG_EEPRO100=m
CONFIG_EEPRO100_PIO=y
CONFIG_E100=m
# CONFIG_LNE390 is not set
CONFIG_FEALNX=m
CONFIG_NATSEMI=m
CONFIG_NE2K_PCI=m
# CONFIG_NE3210 is not set
# CONFIG_ES3210 is not set
CONFIG_8139CP=m
CONFIG_8139TOO=m
CONFIG_8139TOO_PIO=y
CONFIG_8139TOO_TUNE_TWISTER=y
CONFIG_8139TOO_8129=y
CONFIG_8139_OLD_RX_RESET=y
CONFIG_SIS900=m
CONFIG_EPIC100=m
CONFIG_SUNDANCE=m
CONFIG_SUNDANCE_MMIO=y
CONFIG_TLAN=m
CONFIG_TC35815=m
CONFIG_VIA_RHINE=m
CONFIG_VIA_RHINE_MMIO=y
CONFIG_WINBOND_840=m
# CONFIG_NET_POCKET is not set

#
# Ethernet (1000 Mbit)
#
# CONFIG_ACENIC is not set
# CONFIG_DL2K is not set
# CONFIG_E1000 is not set
# CONFIG_MYRI_SBUS is not set
# CONFIG_NS83820 is not set
# CONFIG_HAMACHI is not set
# CONFIG_YELLOWFIN is not set
# CONFIG_R8169 is not set
# CONFIG_SK98LIN is not set
# CONFIG_TIGON3 is not set
# CONFIG_FDDI is not set
# CONFIG_HIPPI is not set
# CONFIG_PLIP is not set
CONFIG_PPP=m
CONFIG_PPP_MULTILINK=y
CONFIG_PPP_FILTER=y
CONFIG_PPP_ASYNC=m
CONFIG_PPP_SYNC_TTY=m
CONFIG_PPP_DEFLATE=m
CONFIG_PPP_BSDCOMP=m
CONFIG_PPPOE=m
# CONFIG_SLIP is not set

#
# Wireless LAN (non-hamradio)
#
# CONFIG_NET_RADIO is not set

#
# Token Ring devices
#
# CONFIG_TR is not set
# CONFIG_NET_FC is not set
# CONFIG_RCPCI is not set
CONFIG_SHAPER=m

#
# Wan interfaces
#
# CONFIG_WAN is not set

#
# Amateur Radio support
#
# CONFIG_HAMRADIO is not set

#
# IrDA (infrared) support
#
# CONFIG_IRDA is not set

#
# ISDN subsystem
#
# CONFIG_ISDN is not set

#
# Old CD-ROM drivers (not SCSI, not IDE)
#
# CONFIG_CD_NO_IDESCSI is not set

#
# Input core support
#
CONFIG_INPUT=y
CONFIG_INPUT_KEYBDEV=y
CONFIG_INPUT_MOUSEDEV=y
CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
CONFIG_INPUT_JOYDEV=m
CONFIG_INPUT_EVDEV=m

#
# Character devices
#
CONFIG_VT=y
CONFIG_VT_CONSOLE=y
CONFIG_SERIAL=y
# CONFIG_SERIAL_CONSOLE is not set
# CONFIG_SERIAL_EXTENDED is not set
CONFIG_SERIAL_NONSTANDARD=y
# CONFIG_COMPUTONE is not set
# CONFIG_ROCKETPORT is not set
# CONFIG_CYCLADES is not set
# CONFIG_DIGIEPCA is not set
# CONFIG_DIGI is not set
CONFIG_ESPSERIAL=m
# CONFIG_MOXA_INTELLIO is not set
# CONFIG_MOXA_SMARTIO is not set
# CONFIG_ISI is not set
# CONFIG_SYNCLINK is not set
# CONFIG_SYNCLINKMP is not set
# CONFIG_N_HDLC is not set
# CONFIG_RISCOM8 is not set
# CONFIG_SPECIALIX is not set
# CONFIG_SX is not set
# CONFIG_RIO is not set
# CONFIG_STALDRV is not set
CONFIG_UNIX98_PTYS=y
CONFIG_UNIX98_PTY_COUNT=256

#
# I2C support
#
# CONFIG_I2C is not set

#
# Mice
#
# CONFIG_BUSMOUSE is not set
CONFIG_MOUSE=y
CONFIG_PSMOUSE=y
# CONFIG_82C710_MOUSE is not set
# CONFIG_PC110_PAD is not set
# CONFIG_MK712_MOUSE is not set

#
# Joysticks
#
# CONFIG_INPUT_GAMEPORT is not set
# CONFIG_INPUT_NS558 is not set
# CONFIG_INPUT_LIGHTNING is not set
# CONFIG_INPUT_PCIGAME is not set
# CONFIG_INPUT_CS461X is not set
# CONFIG_INPUT_EMU10K1 is not set
# CONFIG_INPUT_SERIO is not set
# CONFIG_INPUT_SERPORT is not set
# CONFIG_INPUT_ANALOG is not set
# CONFIG_INPUT_A3D is not set
# CONFIG_INPUT_ADI is not set
# CONFIG_INPUT_COBRA is not set
# CONFIG_INPUT_GF2K is not set
# CONFIG_INPUT_GRIP is not set
# CONFIG_INPUT_INTERACT is not set
# CONFIG_INPUT_TMDC is not set
# CONFIG_INPUT_SIDEWINDER is not set
# CONFIG_INPUT_IFORCE_USB is not set
# CONFIG_INPUT_IFORCE_232 is not set
# CONFIG_INPUT_WARRIOR is not set
# CONFIG_INPUT_MAGELLAN is not set
# CONFIG_INPUT_SPACEORB is not set
# CONFIG_INPUT_SPACEBALL is not set
# CONFIG_INPUT_STINGER is not set
# CONFIG_INPUT_DB9 is not set
# CONFIG_INPUT_GAMECON is not set
# CONFIG_INPUT_TURBOGRAFX is not set
# CONFIG_QIC02_TAPE is not set
# CONFIG_IPMI_HANDLER is not set
# CONFIG_IPMI_PANIC_EVENT is not set
# CONFIG_IPMI_DEVICE_INTERFACE is not set
# CONFIG_IPMI_KCS is not set
# CONFIG_IPMI_WATCHDOG is not set

#
# Watchdog Cards
#
# CONFIG_WATCHDOG is not set
# CONFIG_SCx200_GPIO is not set
# CONFIG_AMD_RNG is not set
# CONFIG_INTEL_RNG is not set
# CONFIG_AMD_PM768 is not set
CONFIG_NVRAM=m
CONFIG_RTC=y
# CONFIG_DTLK is not set
# CONFIG_R3964 is not set
# CONFIG_APPLICOM is not set
# CONFIG_SONYPI is not set

#
# Ftape, the floppy tape device driver
#
# CONFIG_FTAPE is not set
# CONFIG_AGP is not set
CONFIG_DRM=y
# CONFIG_DRM_OLD is not set
CONFIG_DRM_NEW=y
# CONFIG_DRM_TDFX is not set
# CONFIG_DRM_R128 is not set
# CONFIG_DRM_RADEON is not set
# CONFIG_DRM_I810 is not set
# CONFIG_DRM_I810_XFREE_41 is not set
# CONFIG_DRM_I830 is not set
# CONFIG_DRM_MGA is not set
# CONFIG_DRM_SIS is not set
# CONFIG_MWAVE is not set

#
# Multimedia devices
#
# CONFIG_VIDEO_DEV is not set

#
# File systems
#
CONFIG_QUOTA=y
# CONFIG_QFMT_V1 is not set
# CONFIG_QFMT_V2 is not set
# CONFIG_QIFACE_COMPAT is not set
# CONFIG_AUTOFS_FS is not set
# CONFIG_AUTOFS4_FS is not set
# CONFIG_REISERFS_FS is not set
# CONFIG_REISERFS_CHECK is not set
# CONFIG_REISERFS_PROC_INFO is not set
# CONFIG_ADFS_FS is not set
# CONFIG_ADFS_FS_RW is not set
# CONFIG_AFFS_FS is not set
# CONFIG_HFS_FS is not set
# CONFIG_BEFS_FS is not set
# CONFIG_BEFS_DEBUG is not set
# CONFIG_BFS_FS is not set
# CONFIG_EXT3_FS is not set
# CONFIG_JBD is not set
# CONFIG_JBD_DEBUG is not set
# CONFIG_FAT_FS is not set
# CONFIG_MSDOS_FS is not set
# CONFIG_UMSDOS_FS is not set
# CONFIG_VFAT_FS is not set
# CONFIG_EFS_FS is not set
# CONFIG_JFFS_FS is not set
# CONFIG_JFFS2_FS is not set
# CONFIG_CRAMFS is not set
CONFIG_TMPFS=y
CONFIG_RAMFS=y
# CONFIG_ISO9660_FS is not set
# CONFIG_JOLIET is not set
# CONFIG_ZISOFS is not set
# CONFIG_JFS_FS is not set
# CONFIG_JFS_DEBUG is not set
# CONFIG_JFS_STATISTICS is not set
# CONFIG_MINIX_FS is not set
# CONFIG_VXFS_FS is not set
# CONFIG_NTFS_FS is not set
# CONFIG_NTFS_RW is not set
# CONFIG_HPFS_FS is not set
CONFIG_PROC_FS=y
# CONFIG_DEVFS_FS is not set
# CONFIG_DEVFS_MOUNT is not set
# CONFIG_DEVFS_DEBUG is not set
# CONFIG_DEVPTS_FS is not set
# CONFIG_QNX4FS_FS is not set
# CONFIG_QNX4FS_RW is not set
CONFIG_ROMFS_FS=m
CONFIG_EXT2_FS=y
CONFIG_SYSV_FS=m
# CONFIG_UDF_FS is not set
# CONFIG_UDF_RW is not set
# CONFIG_UFS_FS is not set
# CONFIG_UFS_FS_WRITE is not set
# CONFIG_XFS_FS is not set
# CONFIG_XFS_POSIX_ACL is not set
# CONFIG_XFS_RT is not set
# CONFIG_XFS_QUOTA is not set
# CONFIG_XFS_DMAPI is not set
# CONFIG_XFS_DEBUG is not set
# CONFIG_PAGEBUF_DEBUG is not set

#
# Network File Systems
#
# CONFIG_CODA_FS is not set
# CONFIG_INTERMEZZO_FS is not set
# CONFIG_NFS_FS is not set
# CONFIG_NFS_V3 is not set
# CONFIG_ROOT_NFS is not set
# CONFIG_NFSD is not set
# CONFIG_NFSD_V3 is not set
# CONFIG_NFSD_TCP is not set
# CONFIG_SUNRPC is not set
# CONFIG_LOCKD is not set
# CONFIG_SMB_FS is not set
# CONFIG_NCP_FS is not set
# CONFIG_NCPFS_PACKET_SIGNING is not set
# CONFIG_NCPFS_IOCTL_LOCKING is not set
# CONFIG_NCPFS_STRONG is not set
# CONFIG_NCPFS_NFS_NS is not set
# CONFIG_NCPFS_OS2_NS is not set
# CONFIG_NCPFS_SMALLDOS is not set
# CONFIG_NCPFS_NLS is not set
# CONFIG_NCPFS_EXTRAS is not set
# CONFIG_ZISOFS_FS is not set

#
# Partition Types
#
CONFIG_PARTITION_ADVANCED=y
# CONFIG_ACORN_PARTITION is not set
# CONFIG_OSF_PARTITION is not set
# CONFIG_AMIGA_PARTITION is not set
# CONFIG_ATARI_PARTITION is not set
# CONFIG_MAC_PARTITION is not set
CONFIG_MSDOS_PARTITION=y
# CONFIG_BSD_DISKLABEL is not set
# CONFIG_MINIX_SUBPARTITION is not set
# CONFIG_SOLARIS_X86_PARTITION is not set
# CONFIG_UNIXWARE_DISKLABEL is not set
CONFIG_LDM_PARTITION=y
# CONFIG_LDM_DEBUG is not set
# CONFIG_SGI_PARTITION is not set
# CONFIG_ULTRIX_PARTITION is not set
# CONFIG_SUN_PARTITION is not set
# CONFIG_EFI_PARTITION is not set
# CONFIG_SMB_NLS is not set
# CONFIG_NLS is not set

#
# Console drivers
#
CONFIG_VGA_CONSOLE=y
CONFIG_VIDEO_SELECT=y
# CONFIG_MDA_CONSOLE is not set

#
# Frame-buffer support
#
# CONFIG_FB is not set

#
# Sound
#
# CONFIG_SOUND is not set

#
# USB support
#
# CONFIG_USB is not set

#
# Bluetooth support
#
# CONFIG_BLUEZ is not set

#
# Kernel hacking
#
CONFIG_DEBUG_KERNEL=y
# CONFIG_DEBUG_STACKOVERFLOW is not set
# CONFIG_DEBUG_HIGHMEM is not set
# CONFIG_DEBUG_SLAB is not set
# CONFIG_DEBUG_IOVIRT is not set
CONFIG_MAGIC_SYSRQ=y
# CONFIG_DEBUG_SPINLOCK is not set
# CONFIG_FRAME_POINTER is not set

#
# Library routines
#
CONFIG_ZLIB_INFLATE=m
CONFIG_ZLIB_DEFLATE=m

</screen>
    </para>
  </appendix><appendix xml:id="windows-ve-linux_app2">
  <title>Busybox Yapılandırma Dosyası (<filename>.config</filename>)</title>
    <para>
<screen>
#
# Automatically generated make config: don't edit
#
HAVE_DOT_CONFIG=y

#
# General Configuration
#
# CONFIG_FEATURE_BUFFERS_USE_MALLOC is not set
CONFIG_FEATURE_BUFFERS_GO_ON_STACK=y
# CONFIG_FEATURE_BUFFERS_GO_IN_BSS is not set
CONFIG_FEATURE_VERBOSE_USAGE=y
CONFIG_FEATURE_INSTALLER=y
# CONFIG_LOCALE_SUPPORT is not set
# CONFIG_FEATURE_DEVFS is not set
# CONFIG_FEATURE_DEVPTS is not set
# CONFIG_FEATURE_CLEAN_UP is not set
# CONFIG_FEATURE_SUID is not set
# CONFIG_SELINUX is not set

#
# Build Options
#
# CONFIG_STATIC is not set
# CONFIG_LFS is not set
# USING_CROSS_COMPILER is not set
EXTRA_CFLAGS_OPTIONS=""

#
# Installation Options
#
# CONFIG_INSTALL_NO_USR is not set
PREFIX="./_install"

#
# Archival Utilities
#
# CONFIG_AR is not set
# CONFIG_BUNZIP2 is not set
# CONFIG_CPIO is not set
# CONFIG_DPKG is not set
# CONFIG_DPKG_DEB is not set
# CONFIG_GUNZIP is not set
# CONFIG_GZIP is not set
# CONFIG_RPM2CPIO is not set
# CONFIG_RPM is not set
# CONFIG_TAR is not set
# CONFIG_UNCOMPRESS is not set
# CONFIG_UNZIP is not set

#
# Coreutils
#
CONFIG_BASENAME=y
# CONFIG_CAL is not set
CONFIG_CAT=y
# CONFIG_CHGRP is not set
# CONFIG_CHMOD is not set
# CONFIG_CHOWN is not set
CONFIG_CHROOT=y
# CONFIG_CMP is not set
CONFIG_CP=y
# CONFIG_CUT is not set
CONFIG_DATE=y
CONFIG_FEATURE_DATE_ISOFMT=y
# CONFIG_DD is not set
CONFIG_DF=y
# CONFIG_DIRNAME is not set
# CONFIG_DOS2UNIX is not set
CONFIG_DU=y
CONFIG_FEATURE_DU_DEFALT_BLOCKSIZE_1K=y
CONFIG_ECHO=y
CONFIG_FEATURE_FANCY_ECHO=y
CONFIG_ENV=y
# CONFIG_EXPR is not set
CONFIG_FALSE=y
# CONFIG_FOLD is not set
CONFIG_HEAD=y
# CONFIG_FEATURE_FANCY_HEAD is not set
# CONFIG_HOSTID is not set
# CONFIG_ID is not set
# CONFIG_INSTALL is not set
# CONFIG_LENGTH is not set
CONFIG_LN=y
# CONFIG_LOGNAME is not set
CONFIG_LS=y
CONFIG_FEATURE_LS_FILETYPES=y
CONFIG_FEATURE_LS_FOLLOWLINKS=y
CONFIG_FEATURE_LS_RECURSIVE=y
CONFIG_FEATURE_LS_SORTFILES=y
CONFIG_FEATURE_LS_TIMESTAMPS=y
CONFIG_FEATURE_LS_USERNAME=y
CONFIG_FEATURE_LS_COLOR=y
# CONFIG_MD5SUM is not set
CONFIG_MKDIR=y
# CONFIG_MKFIFO is not set
CONFIG_MKNOD=y
CONFIG_MV=y
# CONFIG_OD is not set
# CONFIG_PRINTF is not set
CONFIG_PWD=y
# CONFIG_REALPATH is not set
CONFIG_RM=y
CONFIG_RMDIR=y
# CONFIG_SEQ is not set
# CONFIG_SHA1SUM is not set
CONFIG_SLEEP=y
# CONFIG_FEATURE_FANCY_SLEEP is not set
CONFIG_SORT=y
# CONFIG_STTY is not set
CONFIG_SYNC=y
CONFIG_TAIL=y
CONFIG_FEATURE_FANCY_TAIL=y
# CONFIG_TEE is not set
CONFIG_TEST=y

#
# test (forced enabled for use with shell)
#
CONFIG_TOUCH=y
CONFIG_TR=y
CONFIG_TRUE=y
CONFIG_TTY=y
CONFIG_UNAME=y
CONFIG_UNIQ=y
# CONFIG_USLEEP is not set
# CONFIG_UUDECODE is not set
# CONFIG_UUENCODE is not set
# CONFIG_WATCH is not set
CONFIG_WC=y
# CONFIG_WHO is not set
# CONFIG_WHOAMI is not set
CONFIG_YES=y

#
# Common options for cp and mv
#
CONFIG_FEATURE_PRESERVE_HARDLINKS=y

#
# Common options for ls and more
#
CONFIG_FEATURE_AUTOWIDTH=y

#
# Common options for df, du, ls
#
CONFIG_FEATURE_HUMAN_READABLE=y

#
# Console Utilities
#
CONFIG_CHVT=y
CONFIG_CLEAR=y
# CONFIG_DEALLOCVT is not set
# CONFIG_DUMPKMAP is not set
# CONFIG_LOADFONT is not set
# CONFIG_LOADKMAP is not set
# CONFIG_OPENVT is not set
CONFIG_RESET=y
# CONFIG_SETKEYCODES is not set

#
# Debian Utilities
#
# CONFIG_MKTEMP is not set
# CONFIG_PIPE_PROGRESS is not set
# CONFIG_READLINK is not set
# CONFIG_RUN_PARTS is not set
# CONFIG_START_STOP_DAEMON is not set
CONFIG_WHICH=y

#
# Editors
#
# CONFIG_AWK is not set
# CONFIG_PATCH is not set
CONFIG_SED=y
# CONFIG_VI is not set

#
# Finding Utilities
#
CONFIG_FIND=y
CONFIG_FEATURE_FIND_MTIME=y
CONFIG_FEATURE_FIND_PERM=y
CONFIG_FEATURE_FIND_TYPE=y
CONFIG_FEATURE_FIND_XDEV=y
# CONFIG_FEATURE_FIND_NEWER is not set
# CONFIG_FEATURE_FIND_INUM is not set
CONFIG_GREP=y
# CONFIG_FEATURE_GREP_EGREP_ALIAS is not set
# CONFIG_FEATURE_GREP_FGREP_ALIAS is not set
CONFIG_FEATURE_GREP_CONTEXT=y
# CONFIG_XARGS is not set

#
# Init Utilities
#
CONFIG_INIT=y
CONFIG_FEATURE_USE_INITTAB=y
CONFIG_FEATURE_INITRD=y
# CONFIG_FEATURE_INIT_COREDUMPS is not set
CONFIG_FEATURE_EXTRA_QUIET=y
CONFIG_HALT=y
CONFIG_POWEROFF=y
CONFIG_REBOOT=y
# CONFIG_MESG is not set

#
# Login/Password Management Utilities
#
CONFIG_USE_BB_PWD_GRP=y
# CONFIG_ADDGROUP is not set
# CONFIG_DELGROUP is not set
# CONFIG_ADDUSER is not set
# CONFIG_DELUSER is not set
# CONFIG_GETTY is not set
# CONFIG_LOGIN is not set
# CONFIG_PASSWD is not set
# CONFIG_SU is not set
# CONFIG_SULOGIN is not set
# CONFIG_VLOCK is not set

#
# Miscellaneous Utilities
#
# CONFIG_ADJTIMEX is not set
# CONFIG_CROND is not set
# CONFIG_CRONTAB is not set
# CONFIG_DC is not set
# CONFIG_DEVFSD is not set
# CONFIG_LAST is not set
# CONFIG_HDPARM is not set
# CONFIG_MAKEDEVS is not set
# CONFIG_MT is not set
# CONFIG_RX is not set
CONFIG_STRINGS=y
# CONFIG_TIME is not set
# CONFIG_WATCHDOG is not set

#
# Linux Module Utilities
#
# CONFIG_INSMOD is not set
# CONFIG_LSMOD is not set
# CONFIG_MODPROBE is not set
# CONFIG_RMMOD is not set

#
# Networking Utilities
#
# CONFIG_FEATURE_IPV6 is not set
# CONFIG_ARPING is not set
# CONFIG_FTPGET is not set
# CONFIG_FTPPUT is not set
CONFIG_HOSTNAME=y
# CONFIG_HTTPD is not set
CONFIG_IFCONFIG=y
CONFIG_FEATURE_IFCONFIG_STATUS=y
# CONFIG_FEATURE_IFCONFIG_SLIP is not set
CONFIG_FEATURE_IFCONFIG_MEMSTART_IOADDR_IRQ=y
CONFIG_FEATURE_IFCONFIG_HW=y
CONFIG_FEATURE_IFCONFIG_BROADCAST_PLUS=y
# CONFIG_IFUPDOWN is not set
# CONFIG_INETD is not set
CONFIG_IP=y
CONFIG_FEATURE_IP_ADDRESS=y
CONFIG_FEATURE_IP_LINK=y
CONFIG_FEATURE_IP_ROUTE=y
# CONFIG_FEATURE_IP_TUNNEL is not set
CONFIG_IPCALC=y
CONFIG_FEATURE_IPCALC_FANCY=y
# CONFIG_IPADDR is not set
# CONFIG_IPLINK is not set
# CONFIG_IPROUTE is not set
# CONFIG_IPTUNNEL is not set
# CONFIG_NAMEIF is not set
# CONFIG_NC is not set
CONFIG_NETSTAT=y
CONFIG_NSLOOKUP=y
CONFIG_PING=y
CONFIG_FEATURE_FANCY_PING=y
# CONFIG_ROUTE is not set
# CONFIG_TELNET is not set
# CONFIG_TELNETD is not set
# CONFIG_TFTP is not set
# CONFIG_TRACEROUTE is not set
# CONFIG_VCONFIG is not set
# CONFIG_WGET is not set

#
# udhcp Server/Client
#
# CONFIG_UDHCPD is not set
CONFIG_UDHCPC=y
# CONFIG_FEATURE_UDHCP_SYSLOG is not set
# CONFIG_FEATURE_UDHCP_DEBUG is not set

#
# Process Utilities
#
CONFIG_FREE=y
CONFIG_KILL=y
CONFIG_KILLALL=y
CONFIG_PIDOF=y
CONFIG_PS=y
# CONFIG_RENICE is not set
# CONFIG_TOP is not set
CONFIG_UPTIME=y
# CONFIG_SYSCTL is not set

#
# Another Bourne-like Shell
#
CONFIG_FEATURE_SH_IS_ASH=y
# CONFIG_FEATURE_SH_IS_HUSH is not set
# CONFIG_FEATURE_SH_IS_LASH is not set
# CONFIG_FEATURE_SH_IS_MSH is not set
# CONFIG_FEATURE_SH_IS_NONE is not set
CONFIG_ASH=y

#
# Ash Shell Options
#
# CONFIG_ASH_JOB_CONTROL is not set
CONFIG_ASH_ALIAS=y
CONFIG_ASH_MATH_SUPPORT=y
CONFIG_ASH_GETOPTS=y
CONFIG_ASH_CMDCMD=y
# CONFIG_ASH_MAIL is not set
CONFIG_ASH_OPTIMIZE_FOR_SIZE=y
# CONFIG_HUSH is not set
# CONFIG_LASH is not set
# CONFIG_MSH is not set

#
# Bourne Shell Options
#
# CONFIG_FEATURE_SH_EXTRA_QUIET is not set
CONFIG_FEATURE_SH_STANDALONE_SHELL=y
# CONFIG_FEATURE_SH_APPLETS_ALWAYS_WIN is not set
CONFIG_FEATURE_COMMAND_EDITING=y
CONFIG_FEATURE_COMMAND_HISTORY=15
CONFIG_FEATURE_COMMAND_SAVEHISTORY=y
CONFIG_FEATURE_COMMAND_TAB_COMPLETION=y
# CONFIG_FEATURE_COMMAND_USERNAME_COMPLETION is not set
CONFIG_FEATURE_SH_FANCY_PROMPT=y

#
# System Logging Utilities
#
# CONFIG_SYSLOGD is not set
# CONFIG_LOGGER is not set

#
# Linux System Utilities
#
# CONFIG_DMESG is not set
# CONFIG_FBSET is not set
# CONFIG_FDFLUSH is not set
# CONFIG_FDFORMAT is not set
# CONFIG_FDISK is not set
# CONFIG_FREERAMDISK is not set
# CONFIG_FSCK_MINIX is not set
# CONFIG_MKFS_MINIX is not set
# CONFIG_GETOPT is not set
# CONFIG_HEXDUMP is not set
CONFIG_HWCLOCK=y
CONFIG_FEATURE_HWCLOCK_LONGOPTIONS=y
# CONFIG_LOSETUP is not set
# CONFIG_MKSWAP is not set
# CONFIG_MORE is not set
# CONFIG_PIVOT_ROOT is not set
# CONFIG_RDATE is not set
# CONFIG_SWAPONOFF is not set
CONFIG_MOUNT=y
# CONFIG_NFSMOUNT is not set
CONFIG_UMOUNT=y
CONFIG_FEATURE_MOUNT_FORCE=y

#
# Common options for mount/umount
#
# CONFIG_FEATURE_MOUNT_LOOP is not set
# CONFIG_FEATURE_MTAB_SUPPORT is not set

#
# Debugging Options
#
# CONFIG_DEBUG is not set
</screen></para></appendix>
</article>


