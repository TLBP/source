<?xml version="1.0" encoding="UTF-8"?>
<!--DOCTYPE article SYSTEM "../../docbook/dtd/docbookx.dtd"-->
<!-- ********************************************************************
     $Id: makefile-NASIL.xml,v 1.4 2002/09/30 18:21:13 nilgun Exp $
     ******************************************************************** -->
<article xml:id="makefile-nasil" lang="tr">
  <info>
  <date>21 Haziran 2003</date>
  <title>GNU Paket Yapılandırma Sistemi</title>
  <subtitle>Makefile, autoconf, automake kullanımı</subtitle>
  <authorgroup>
    <author>
     <personname><firstname>Murat</firstname>
      <surname>Demirten</surname></personname>
    </author>
  </authorgroup>
  <abstract>
    <para>
Bu belge *NIX sistemler üzerinde uygulama geliştiren, geliştirmek isteyenlere yardımcı olabilmek amacıyla hazırlanmıştır. Belge kapsamında <filename>Makefile</filename> dosyalarının nasıl hazırlanabileceği, büyük projeler için birden fazla <filename>Makefile</filename> dosyası yazma/yazmama, bunun yerine <command>autoconf</command> ve <command>automake</command> kullanarak <filename>Makefile</filename> dosyalarının otomatik üretilebilmesi,
<command>autoconf</command>'un özelliklerini kullanarak taşınabilir kod geliştirme gibi konular üzerinde durulacaktır.
    </para>
  </abstract>
  <revhistory>
    <revision>
      <revnumber>Versiyon 1.0.0</revnumber>
      <date>21 Haziran 2003</date>
      <authorinitials>murat</authorinitials>
      <revremark>İlk versiyon, bir gece vakti uykum yok, başlıyorum</revremark>
    </revision>
  </revhistory>
  <legalnotice><title>Yasal Uyarı</title><para>
Bu belgenin, <emphasis>GNU Paket Yapılandırma Sistemi</emphasis> 1.0.0 sürümünün <emphasis role="bold"> telif hakkı © 2003 <emphasis>Murat Demirten</emphasis></emphasis>'e aittir.
    &notice.gfdl.orig;</para>
      &notice.disc;
  </legalnotice>
  </info>

  <sect1 xml:id="makefile-nasil-giris"><title>Giriş</title>
  <para>
*NIX sistemlerde uygulama geliştirmek gerçekten eğlenceli bir iştir. Öğrenilecek o kadar çok şey var ki. Uzun zamandır Linux ile uğraşmama rağmen sürekli çok şeyler öğrenmeye devam ediyorum, işin en güzel yanı da bu. Üç yıl öncesine kadar geliştirdiğim uygulamalarda yeniden derleme işlemini tek tek komutlarla yapıyordum. Fakat programlar büyüdükçe bu işi yapmak inanılmaz zor hale geldi. Hele bir de yazdığınız programların başkaları tarafından da derlenmesi söz konusu olunca işler daha da karışmaktadır. O zaman <literal>Makefile</literal> yazmam gerektiğini anladım. Oturdum 3-5 saatlik bir araştırmadan sonra <command>make</command> kullanımıyla ilgili pek çok bilgi edindim ve orada kaybettiğim (!) 3-5 saat bana şimdiye dek kat kat fazlasını kazandırdı. Bu belgeyi okuduğunuza göre bir şekilde siz de bu konulara ilgi duyuyorsunuzdur. Eğer henüz yeni iseniz, bir iki saatinizi ayırıp burada yazılanları uygulamanızı şiddetle öneririm.
  </para>
  <para>
Bu belgede önce nasıl kendi <filename>Makefile</filename> dosyalarımızı oluşturabileceğimizden bahsedeceğiz. Temel <command>make</command> kullanımını öğreneceğiz. Ardından taşınabilirlik özelliğine sahip, daha büyük uygulamaların derlenebilmesi için tek tek tüm <filename>Makefile</filename> dosyalarını elle oluşturmanın zorluğundan bahsedecek ve sizleri  <command>autoconf</command> ve <command>automake</command> kullanmaya zorlayacağız. Sizi ikna ettikten sonra ise örneklerle bu araçların da kullanımından bahsedeceğiz.
  </para>
  </sect1>
  <sect1 xml:id="makefile-nasil-kullanimi"><title>Makefile Kullanımı</title>
  <para>
Uygulama geliştirirken sıklıkla nesne dosyalarımızı yeniden ve yeniden oluşturmak zorunda kalırız. Yerine göre <command>gcc</command>, <command>ld</command>, <command>ar</command> vb. uygulamaları tekrar tekrar aynı değiştirgelere çağırırız. İşte <command>make</command> ugulaması, programların yeniden derlenme sürecini otomatik hale getirmek, sadece değişen kısımların yeniden derlenmesini sağlamak suretiyle zamandan kazanmak ve işlemleri her zaman otomatik olarak doğru sırada yapmak için tasarlanmıştır.
  </para>
  <sect2 xml:id="makefile-nasil-kurallar"><title>Temel Kurallar</title>
  <para>
<command>make</command> uygulaması çalıştırıldığında, bulunulan dizinde sırasıyla <filename>GNUmakefile</filename>, <filename>makefile</filename> ve <filename>Makefile</filename> dosyalarını arar. Alternatif olarak <option>-f</option> seçeneği ile <literal>Makefile</literal> olarak kullanacağınız dosyayı da belirlemeniz mümkün olsa da standartların dışına çıkmamakta fayda var. <command>make</command> neyi nasıl yapacağını bu dosyalardan öğrenecektir. Eğer bulunduğunuz dizinde bir <literal>Makefile</literal> yok ise aşağıdaki gibi bir çıktı alacaksınız demektir:
  </para>
<screen>
<prompt>$ </prompt><command>make</command>
make: *** No targets specified and no makefile found.  Stop.
</screen>
  <tip><para>
Genel kabul görmüşlüğü ve göz alışkanlığı açısından dosya adı olarak alternatiflerin yerine <filename>Makefile</filename> kullanmanızı öneririm.
  </para></tip><para>
Bir <filename>Makefile</filename> aslında işlemlerin nasıl yapılacağını gösteren kural tanımlamalarından oluşmaktadır. Genel olarak dosyanın biçimi aşağıdaki gibidir:
  </para>
<screen>
hedef: bağımlılıklar
<keycap>TAB</keycap> komut
<keycap>TAB</keycap> komut
<keycap>TAB</keycap> ...
Diğer kurala geçmeden bir boş satır
...
</screen>
  <para>
Burada en sık yapacağımız hata <keycap>TAB</keycap> tuşuna basmayı unutmak olacaktır. <filename>Makefile</filename> dosyasını hazırladığınız metin düzenleyiciden kaynaklanan bir sorun da olabilir. En iyisi <command>emacs</command> kullanarak <emphasis>makefile-mode</emphasis> ile yazmaktır, böylece hata yapma olasılığınız oldukça azalacaktır.
  </para>
  <para>
Kurallar arasında bir satır boş bırakılması <emphasis>GNU make</emphasis> için zorunlu olmamakla birlikte bazı Unix sürümleriyle uyumluluk için boşluk bırakılması gereklidir.
  </para>
  <para>
İlk satırda <emphasis>hedef</emphasis>'in oluşturulmasında etkili olan, bağımlılık yaratan dosyalar birbirinden boşluk ile ayrılmış olarak tek satırda listelenir. Eğer bağımlılık kısmında yer alan dosyalardan en az birinin son değiştirilme tarihi, hedef'ten daha yeni ise, hedef yeniden oluşturulur. Diğer durumda hedefin yeniden oluşturulmasına gerek olmadığı anlaşılır, çünkü hedefin bağımlı olduğu dosyalarda son oluşturmadan sonra bir değişiklik olmamıştır. Sonraki satırlarda bağımlılık yaratan bu dosyalardan hedefin oluşturulabilmesi için gerekli komutlar yer alır. Şimdi basit bir örnek yapalım:
  </para>
<screen>
  test: test.c
      gcc -o test test.c
</screen>
  <para>
Bu örnekte hedef olarak <command>test</command> uygulaması derlenecektir. Uygulamanın bağımlı olduğu dosya <filename>test.c</filename>'dir. <filename>test.c</filename> dosyasında herhangi bir değişiklik olduğunda veya <command>test</command> silindiğinde, <command>gcc -o test test.c</command> komutu çalıştırılacak ve <command>test</command> yeniden oluşturulacaktır. Şimdi daha karışık bir örnek yapalım:
  </para>
<screen>
CC = gcc
CFLAGS = -O2 -Wall -pedantic
LIBS = -lm -lnsl

test: test.o
    $(CC) $(CFLAGS) $(LIBS) -o test test.o

test.o: test.c
    $(CC) $(CFLAGS) -c test.c

clean:
    rm -f test *.o

install: test
    cp test /usr/bin

</screen>
  <para>
İlk satırda <literal>CC</literal> değişkenine kullanacağımız derleyiciyi atıyoruz. <filename>Makefile</filename> dosyaları içerisinde bu şekilde değişken tanımlaması yapıp, değişkeni dosya içerisinde <literal>$(değişken)</literal> olarak kullanabiliriz. İkinci satırda ise derleyiciye vereceğimiz bazı seçenekleri <literal>CFLAGS</literal> değişkenine atıyoruz. Üçüncü satırda uygulamamızın kullandığı kütüphaneleri listeledik. Ardından ilk kuralımız geliyor. <command>test</command> uygulaması <filename>test.o</filename> dosyasına bağımlı olarak belirtilmiş ve <filename>test.o</filename>'dan <command>test</command>'in oluşturulabilmesi için gerekli komut hemen altında listelenmiştir. Değişkenlerin değerlerini yerine koyduğumuzda komutumuz <command>gcc -O2 -Wall -pedantic -lm -lnsl -o test test.o</command> şeklinde olacaktır.
  </para>
  <para>
İkinci kuralımız <filename>test.o</filename>'nun nasıl oluşturulacağını belirtmektedir. Aslında bu iki kural bir önceki örnekte olduğu gibi birleştirilebilir, ancak mantığı anlatabilmek için burada ikiye bölünmüştür. <filename>test.c</filename> dosyasında bir değişiklik olduğunda <filename>test.o</filename> dosyası hemen altında listelenen komutla yeniden oluşturulur: <command>gcc -O2 -Wall -pedantic -c test.c</command>
  </para>
  <para>
Üçüncü kuralımızda çalıştığımız dizinde nasıl temizlik yapacağımızı belirtiyoruz. <command>make clean</command> komutunu çalıştırdığımızda <command>test</command> dosyası ve <filename>.o</filename> ile biten nesne dosyaları silinecektir. Bir sonraki kuralımız ise <command>install</command>. Bu kuralda da <command>test</command> dosyasında bir değişme olduğunda <command>cp test /usr/bin</command> komutu ile dosyayı <filename>/usr/bin</filename> dizini altına kopyalıyoruz.
  </para>
  <para>
<filename>Makefile</filename> içerisindeki her bir kural <command>make</command> uygulamasına seçenek olarak verilebilir ve ayrıca işletilebilir. Yukarıdaki gibi bir <filename>Makefile</filename> dosyasına sahipsek <command>make test.o</command>  komutuyla sadece <filename>test.o</filename> için verilen kuralın çalıştırılmasını sağlayabiliriz. Veya <command>make install</command> komutuyla sadece <command>install</command> kuralının çalışmasını sağlayabiliriz. Ancak <command>install</command> aynı zamanda <command>test</command>'e bağımlı olduğundan <command>test</command>'in kuralı da çalışır. Aynı şekilde <command>test</command> de <filename>test.o</filename>'ya bağlı olduğundan <filename>test.o</filename> kuralı da çalışacaktır. Komutu seçenek vermeden sadece <command>make</command> şeklinde çalıştırdığınızda ise <filename>Makefile</filename> dosyasını okur ve bulduğu ilk kuralı işler. Bizim örneğimizde ilk kural test olduğu için test dosyasının oluşturulabilmesi için gerekli işlemleri yapacaktır. Bu nedenle <filename>Makefile</filename> dosyalarında ilk kural çoğu zaman <literal>all: test install</literal> gibi olur. Böylece her defasında <command>make xxx</command> yazmak yerine sadece <command>make</command> yazarak hız kazanmış oluruz.
  </para><para>
Bu örneği iyice anlamadan sonraki bölümlere devam etmeyiniz. <command>make</command> uygulamasının bu basit ama bir o kadar da güçlü mantığını tam olarak anladığınızda onu sadece kodunuzu derlemek için değil, çok farklı amaçlar için de kullanabileceğinizi göreceksiniz. Hemen bir örnek verelim, bir sanaldoku (web) uygulamanız var ve buradan <literal>isim:telefon</literal> şeklinde bir metin dosyasına giriş yapılıyor. Eğer bu metin dosyası değiştiğinde çalışacak şekilde bir kural tanımlarsanız, mesela metin dosyası her değiştiğinde bu dosyayı okuyup ayrıştırarak veritabanına kayıt edecek bir uygulamanın çalıştırılması sağlanabilir. Örneğimiz pek işe yarar bir şey olmadı ama eminim mantığı anlamışsınızdır.
  </para><note><para>
Aslında <command>make</command> için verilebilecek en iyi örneklerden bir tanesi de Debian sanalyöresidir. Debian sanalyöresi, tamamen statik HTML sayfalardan oluşur. Bu sayede yansılanması daha kolay hale gelir ve statik sayfalar sanaldoku sunucusuna çok az yük getirir. Ancak binlerce sayfadan oluşan Debian sanalyöresi, statik olmasına rağmen çok hızlı güncellenebilmektedir. Aynı zamanda yöreyi ziyaret ettiyseniz farketmiş olacağınız gibi, sanaldoku istemciniz dil ayarına göre sayfanın o dile çevirilmiş bir sürümü mevcut ise karşınıza o getirilmektedir. Tüm bu dinamiklik alt tarafta kullanılan, çoğunluğu <literal>wml</literal>, binlerce dosya tarafından sağlanmaktadır. Her 3-4 saatte bir CVS'de bulunan kaynak kodu çekilerek <command>make</command> ile <literal>wml</literal> dosyalarından HTML dosyaları üretilmekte, sayfalar arası aşamalar düzenlenmekte, farklı dillere çevirilen sayfalar kontrol edilmekte, bazı programlar ve betikler çalıştırılmaktadır. Kısaca özetlemek gerekirse böyle ama gerçekte tüm yörenin yeniden oluşturulması için gerçekten oldukça karmaşık işlemler yapılmaktadır. İlgilenenler <link xlink:href="http://www.debian.org/devel/website/desc"/> adresine bakabilir.
  </para></note><para>
Yukarıdaki <filename>Makefile</filename> örneğimize tekrar dönelim. <command>make clean</command> komutunu çalıştırdığımızda derleme sonrasında oluşan dosyalar silinmektedir. Peki, bulunduğumuz dizinde ismi <filename>clean </filename> olan bir dosya mevcut ise ne olur?
  </para><para>
<screen>
<prompt>$ </prompt><command>make clean</command>
make: `clean' is up to date.
</screen>
  </para><para>
Gördüğünüz gibi <filename>clean</filename> adında bir dosya var olduğu ve <filename>clean</filename> için bağımlılık listesi olmadığından dolayı kuralın güncelliğini koruduğunu ve alttaki komutların çalıştırılmaması gerektiğini düşündü. İşte bu  gibi durumlar için özel bir kural mevcuttur: <literal>.PHONY</literal>
  </para>
  <para>
Yukarıda anlatılan sorunu giderebilmek için <filename>Makefile</filename> dosyamızın içeriğine aşağıdaki kuralı da eklemeliyiz:
  </para><screen>.PHONY: clean</screen><para>
Böylelikle <command>make clean</command> komutunun, bulunulan dizinde <filename>clean</filename> adında bir dosya olsa bile düzgün olarak çalışmasını sağlamış olduk.
  </para>
  </sect2>
  <sect2 xml:id="makefile-nasil-karmasik"><title>Daha Karmaşık Makefile Dosyaları</title>
  <para>
Önceki bölümde temel olarak <command>make</command> kullanımı üzerinde durduk. Örnek bir <filename>Makefile</filename> hazırladık. Ancak tek bir kaynak dosyasından oluşturulan bir uygulama için <command>make</command> o kadar da yararlı bir şey değil. Zaten gerçekte de en küçük uygulama bile onlarca kaynak dosyadan oluşur. Şimdi böyle bir uygulama için <filename>Makefile</filename> hazırlayalım.
  </para><example><title>Soyut kurallar kullanılmamış Makefile</title>
<screen>
CC = g++
CFLAGS = -O2 -Wall -pedantic
LIBS = -lnsl -lm
INCLUDES = -I/usr/local/include/custom

all: server client

server: ortak.o server.o list.o que.o \
            data.o hash.o
    $(CC) $(CFLAGS) $(LIBS) -o server ortak.o server.o \
            list.o que.o data.o hash.o

client: ortak.o client.o
    $(CC) $(CFLAGS) $(LIBS) -o client ortak.o client.o

ortak.o: ortak.cpp ortak.h
    $(CC) $(CFLAGS) $(INCLUDES) -c ortak.cpp

server.o: server.cpp server.h ortak.h
    $(CC) $(CFLAGS) $(INCLUDES) -c server.cpp

client.o: client.cpp client.h ortak.h
    $(CC) $(CFLAGS) $(INCLUDES) -c client.cpp

list.o: list.cpp list.h
    $(CC) $(CFLAGS) $(INCLUDES) -c list.cpp

que.o: que.cpp que.h
    $(CC) $(CFLAGS) $(INCLUDES) -c que.cpp

data.o: data.cpp data.h
    $(CC) $(CFLAGS) $(INCLUDES) -c data.cpp

hash.o: hash.cpp hash.h
    $(CC) $(CFLAGS) $(INCLUDES) -c hash.cpp

install: client server
    mkdir -p /usr/local/bin/test
    cp client /usr/local/bin/test
    cp server /usr/local/bin/test

uninstall:
    rm -rf /usr/local/bin/test

clean:
    rm -f *.o server client

.PHONY: clean
</screen>
  </example><para>
Kullandığımız derleyici, derleyici seçenekleri, kütüphaneler gibi değerleri değişkenlere atamakla neler kazandığımıza bir bakalım. Derleyici değiştirgelerini değiştirmeye karar verdiğimizde değişken kullanmıyor olsaydık 9 farklı yerde bu değişikliği el ile yapmak zorunda kalacaktır. Fakat şimdi ise sadece <literal>CFLAGS</literal> değişkeninin değerini değiştirmemiz yeterli olacaktır.
  </para>
  <para>
Ancak gene de yukarıdaki gibi bir <filename>Makefile</filename> yazmak uzun sürecek bir işlemdir. Eğer uygulamanız 60 cpp dosyasından oluşuyorsa ve 60 farklı nesne için tek tek kuralları yazmak zorunda kalıyorsanız bu hoş  olmaz. Çünkü tüm <filename>.o</filename> dosyalarını üretebilmek için vereceğimiz komut aynı: <literal>$(CC) $(CFLAGS) $(INCLUDES) -c xxx.cpp</literal>. Oysa biz 60 defa bu komutu tekrar yazmak zorundayız. İşte bu noktada soyut kurallar (<emphasis>abstract rules</emphasis>) imdadımıza yetişir.
  </para>
  <para>
Bir soyut kural <filename>*.u1</filename> uzantılı bir dosyadan nasıl <filename>*.u2</filename> uzantılı bir dosyanın üretileceğini tanımlar. Genel olarak kullanımı aşağıdaki gibidir:
  </para>
<screen>
.u1.u2:
    komutlar
    komutlar
...
</screen>
  <para>
Burada <literal>u1</literal> kaynak dosyanın uzantısı iken, <literal>u2</literal> hedef dosyanın uzantısıdır. Bu tür kullanımda dikkat ederseniz bağımlılık tanımlamaları yer almamaktadır. Çünkü tanımladığımız soyut genel kural için bağımlılık belirtmek çok anlamlı değildir. Bunun yerine <filename>.u1</filename>  uzantılı bir dosyadan <filename>.u2</filename> uzantılı dosya üretmede istisnai olarak farklı bağımlılıkları olan kurallar da ileride vereceğimiz örnekte olduğu gibi belirtilebilir.
  </para>
  <para>
Soyut kurallar tanımlarken aşağıdaki özel değişkenleri kullanmak gerekecektir:
  </para><itemizedlist>
    <listitem>
<command><![CDATA[ $< ]]></command> Değiştiği zaman hedefin yeniden oluşturulması gereken bağımlılıkları gösterir.
    </listitem><listitem>
<command><![CDATA[ $@ ]]></command> Hedefi temsil eder.
    </listitem><listitem>
<command><![CDATA[ $^ ]]></command> Geçerli kural için tüm bağımlılıkları temsil eder.
    </listitem>
  </itemizedlist><para>
Bu bilgiler ışığında hemen bir örnek verelim. Uzantısı <filename>.cpp</filename> olan bir kaynak kodundan nesne kodunu üretebilmek için aşağıdaki gibi bir kural tanımlayabiliriz:
  </para>
<screen>
.cpp.o:
    g++ -c $&lt;
</screen>
  <para>
Şimdi biraz daha açıklık getirelim. Kaynak dosyamızın adı <filename>helper.cpp</filename> ve amacımız <filename>helper.o</filename> nesne dosyasını üretmek olsun. Yukarıdaki kural kaynak dosyamız için çalıştığında <literal>.cpp.o:</literal> satırı yüzünden <filename>helper.cpp</filename>  oluşacak <filename>helper.o</filename> için bir bağımlılık durumunu alır. Bu nedenle $&lt; değişkeni <filename>helper.cpp</filename>'yi gösterir. Bu sayede <filename>helper.o</filename> dosyası üretilmiş olacaktır.
  </para>
  <para>
Şimdi aynı mantıkla nesne dosyalarından çalıştırılabilir programımızı üretelim.
  </para>
<screen>
.o:
    g++ $^ -o $@
</screen>
  <para>
Bu biraz daha karışık çünkü çalıştırılabilir dosyamızın uzantısı olmayacak. Eğer tek bir uzantı verilmiş ise bunun birinci uzantı olduğu ve ikincinin boş olduğu düşünülür.
  </para>
  <para>
Soyut kurallar tanımladığımızda yapmamız gereken iki işlem daha var. Bunlardan birincisi kullandığımız uzantıların neler olduğunu belirtmektir. Bu işlem için <literal>.SUFFIXES</literal> özel değişkeni kullanılır:
  </para><para><screen>.SUFFIXES: .cpp .o</screen></para><para>
Diğer yapmamız gereken işlem ise üretilecek çalıştırılabilir dosyamızın hangi nesne dosyalarına, nesne dosyalarımızın ise hangi kaynak dosyalarına bağımlı olduğunu belirtmek olacaktır. İşin en güç tarafı budur. Her zaman doğru değerleri yazmak o kadar kolay olmayabilir. Bu noktada <command>gcc</command> derleyicisi <literal>-MM</literal> seçeneğiyle bize yardımcı olacaktır. Aşağıdaki ekran çıktısına bakalım:
  </para>
<screen>
<prompt>$ </prompt><command>g++ -MM -c server.cpp</command>
server.o: server.cpp server.h ortak.h
<prompt>$ </prompt>
</screen>
  <para>
Görüldüğü gibi <literal>server.o</literal> için gerekli <filename>Makefile</filename> kuralını bizim için hatasız olarak verdi. Tek yapmamız gereken bu satırları kopyalayıp <filename>Makefile</filename> içerisine yapıştırmaktır. Şimdi bölümün başında verdiğimiz <filename>Makefile</filename> dosyasını bu yöntemle yeniden yazalım:
  </para><example><title>Soyut kuralların kullanıldığı Makefile</title>
<screen>
CC = g++
CFLAGS = -O2 -Wall -pedantic
LIBS = -lnsl -lm
INCLUDES = -I/usr/local/include/custom
SERVER_nesneCTS = ortak.o server.o list.o que.o data.o hash.o
CLIENT_nesneCTS = ortak.o client.o

all: server client

.SUFFIXES: .cpp .o

.cpp.o:
    $(CC) $(CFLAGS) $(INCLUDES) -c $&lt;

.o:
    $(CC) $(CFLAGS) $(LIBS) $^ -o $@

server: $(SERVER_nesneCTS)
client: $(CLIENT_nesneCTS)
ortak.o: ortak.cpp ortak.h
server.o: server.cpp server.h ortak.h
client.o: client.cpp client.h ortak.h
list.o: list.cpp list.h
que.o: que.cpp que.h
data.o: data.cpp data.h
hash.o: hash.cpp hash.h

install: client server
    mkdir -p /usr/local/bin/test
    cp client /usr/local/bin/test
    cp server /usr/local/bin/test

uninstall:
    rm -rf /usr/local/bin/test

clean:
    rm -f *.o server client

.PHONY: clean
</screen>
  </example>
  </sect2>
  </sect1>
  <sect1 xml:id="makefile-nasil-autoconf_automake">
  <title>Autoconf ve Automake Kullanımı</title>
  <para>
GNU Paket Kurgulama Sistemi iki temel amacın gerçekleştirilebilmesi için geliştirilmiştir: Programları platformlar arası daha rahat taşınabilir hale getirmek ve kaynak koddan program kurulumlarını mümkün olduğu kadar basite indirgeyebilmek.
  </para>
  <para>
Taşınabilir kod yazmak gerçekten oldukça zahmetli bir iştir. Hedef mimarinin ayrıntılı olarak özelliklerinin bilinmesi çoğu zaman mümkün değildir. Bir önceki bölümde örnek olarak yazdığımız <filename>Makefile</filename> dosyasında <command>mkdir -p /usr/local/bin/test</command> komutunu kullanmıştık. Oysa <command>mkdir</command> komutunun <literal>-p</literal> seçeneği tüm Unix sistemlerde aynı şekilde çalışmaz. Bu ve bunun gibi pek çok farklılık yüzünden her Unix sisteminde çalışabilecek bir <filename>Makefile</filename> yazmak çok zor iştir. Kullanılan kütüphanelerin sistemler arasındaki farklılıkları ise apayrı bir konudur. İşte GNU Paket Kurgulama Sistemi tüm bu zorlukların üstesinden gelebilmek için oluşturulmuştur. Kdevelop gibi programlar yeni proje oluşturduğunuzda b sistemi de otomatik olarak oluşturmaktadırlar. Ancak oluşan dosyalar fazlasıyla karışık olduğundan bu bölümde çok daha basit örneklerle yapıyı anlatmaya çalışacağım. Buradaki temel bilgilerden yararlandıktan sonra Kdevelop gibi programların ürettiği veya örütbağdan indirmiş olduğunuz herhangi bir uygulamanın kaynak kodu içerisinde gezinerek farklı kullanımları inceleyebilirsiniz.
  </para>
  <sect2 xml:id="makefile-nasil-araclar"><title>Gerekli Araçlar</title>
  <para>
GNU Paket Kurgulama Sistemi için gerekli araçlar ve kullanım alanları aşağıdaki gibidir:
  </para><orderedlist>
    <listitem><para>
<command>autoconf</command> yapılandırma için kullanılacak <filename>configure</filename> betiğini üretir. Kodun taşınabilir olmasını etkileyecek özellikleri, üzerinde çalıştığı platform için denetler. Elde ettiği değerleri, daha önceden belirtilmiş şablonlara uygun şekilde birleştirerek özelleştirilmiş <filename>Makefile</filename>, başlık dosyaları vb. oluşturur. Bu sayede programı derleyecek kullanıcı tek tek elle bu değişiklikleri yapmak zahmetinden kurtulur.
    </para></listitem>
    <listitem><para>
<command>automake</command>, <command>autoconf</command> için kullanılacak <filename>Makefile</filename> şablonlarını (<filename>Makefile.in</filename>) temel alarak <filename>Makefile.am</filename> dosyalarını  üretir. <command>automake</command> tarafından üretilen <filename>Makefile</filename> dosyaları GNU makefile standartlarına uygun olup, kullanıcıyı elle <filename>Makefile</filename> dosyası oluşturma zahmetinden kurtarır. <command>autoconf</command>'un çalışabilmesi için öncelikle <command>automake</command>'in düzgün olarak çalışması gereklidir.
    </para></listitem>
    <listitem><para>
<command>libtool</command> özellikle paylaşımlı kütüphanelerin taşınabilir bir yapıda oluşturulabilmesi için gereken pek çok ayrıntıyı kullanıcıdan soyutlar. Kullanımı için <command>autoconf</command> veya <command>automake</command> gerekli değildir, tek başına da kullanılabilir. <command>automake</command> ise <command>libtool</command>'u  destekler ve onunla birlikte çalışabilir.
    </para></listitem>
    <listitem><para>
<command>Autotools</command> GNU kodlama standartlarına uygun, taşınabilir kod üretmede yardımcı olur.
    </para></listitem>
  </orderedlist><para>
GNU Paket Kurgulama Sistemi tarafından gerçekleştirilen temel görevler şunlardır:
  </para><orderedlist>
    <listitem><para>
Çok sayıda alt dizin içeren kaynak kodlardan uygulamaları üretebilir. Her bir dizin için ayrıca <command>make</command> komutunu çağırmak zahmetinden geliştiriciyi kurtarır. Bu sayede tüm kaynak kodları aynı dizinde bulundurmak yerine aşamaları daha belirgin bir dizin yapısı kullanabilirsiniz.
    </para></listitem>
    <listitem><para>
Yapılandırma işlemini otomatik olarak yapar. Kullanıcıların <filename>Makefile</filename> dosyalarını düzenlemelerine gerek kalmaz.
    </para></listitem>
    <listitem><para>
<filename>Makefile</filename> dosyalarını otomatik olarak üretir. <filename>Makefile</filename> yazımı büyük projelerde sürekli tekrar gerektirir ve aynı zamanda hata yapmaya elverişli bir yapıdır. GNU Paket Kurgulama Sistemi için sadece <filename>Makefile.am</filename> şablonunun yazımı yeterlidir. Bu sayede hata yapma olasılığı azalır ve yönetimi kolay hale gelir.
    </para></listitem>
    <listitem><para>
Hedef platform için özel testler yapabilme imkanı sunar. <filename>Makefile.am</filename> dosyasına eklenecek bir kaç satırla hedef platformda programın derlenebilesi için aranan özelliklerin var olup olmadığı kontrol edilebilir.
    </para></listitem>
    <listitem><para>
Paylaşımlı kütüphanelerin oluşturulması statik kütüphanelerin oluşturulması kadar kolay hale gelir.
    </para></listitem>
  </orderedlist><para>
GNU Paket Kurgulama Sistemi için gerekli olan bu araçların sadece geliştirmenin yapıldığı sistemde kurulu olması yeterlidir. Bu programlar çalıştıktan sonra her platformda çalışabilecek betik programları üretirler. Bu sayede uygulamanızın kaynak kodunu indirip kurmak isteyen biri, <command>autoconf</command>, <command>automake</command> gibi araçları da sistemine kurmak zorunda kalmaz.
  </para>
  </sect2>
  <sect2><title>Basit Bir Autoconf, Automake Örneği</title>
  <para>
Şimdi aşağıdaki test programımız için GNU Paket Kurgulama Sistemini nasıl kullanacağımızı öğrenelim.
  </para>
<programlisting>
#include &lt;stdio.h>

int main()
{
  printf("Çalışıyor\n");
  return 0;
</programlisting>
  <para>
Programımızı <filename>test.c</filename> olarak kaydedelim. Şimdi programın derlenmesi işlemlerini <command>autoconf</command> ve <command>automake</command> ile yapmaya başlayalım. Bunun için öncelikle aşağıdaki <filename>Makefile.am</filename> dosyasını oluşturalım:
  </para>
<screen>
in_PROGRAMS = test
test_SOURCES = test.c
</screen>
  <para>
  Ardından aşağıdaki gibi bir <filename>configure.in</filename> dosyası oluşturalım:
  </para>
<screen>
AC_INIT(test.c)
AM_INIT_AUTOMAKE(test,0.1)
AC_PROG_CC
AC_PROG_INSTALL
AC_OUTPUT(Makefile)
</screen>
  <para>
Dosyaları oluşturup kaydettikten sonra şimdi aşağıdaki komutları çalıştıralım:
  </para>
<screen>
<prompt>$ </prompt><command>aclocal</command>
<prompt>$ </prompt><command>autoconf</command>
<prompt>$ </prompt><command>ls -l</command>
total 88
-rw-r--r--    1 demirten demirten    16626 Haz 22 17:32 aclocal.m4
-rwxr-xr-x    1 demirten demirten    50233 Haz 22 17:32 configure
-rw-r--r--    1 demirten demirten       90 Haz 22 17:31 configure.in
-rw-r--r--    1 demirten demirten       43 Haz 22 17:29 Makefile.am
-rw-r--r--    1 demirten demirten       71 Haz 22 17:28 test.c
</screen>
  <para>
Gördüğünüz gibi <command>aclocal</command> ve <command>autoconf</command> uygulamaları çalıştıktan sonra <filename>aclocal.m4</filename> ve <filename>configure</filename> dosyaları üretildi. Şimdi ise  <command>automake</command> programını çalıştıracağız:
  </para>
<screen>
<prompt>$ </prompt><command>automake -a</command>
automake: configure.in: installing `./install-sh'
automake: configure.in: installing `./mkinstalldirs'
automake: configure.in: installing `./missing'
automake: Makefile.am: installing `./INSTALL'
automake: Makefile.am: required file `./NEWS' not found
automake: Makefile.am: required file `./README' not found
automake: Makefile.am: installing `./COPYING'
automake: Makefile.am: required file `./AUTHORS' not found
automake: Makefile.am: required file `./ChangeLog' not found
automake: configure.in: installing `./depcomp'
</screen>
  <para>
<command>automake</command> ilk çalıştırıldığında öncelikle <filename>install-sh</filename>, <filename>mkinstalldirs</filename> ve <filename>missing</filename> dosyalarının daha önceden oluşturulup oluşturulmadığını kontrol eder. Eğer yoksa bu dosyaları oluşturur (Bendeki sistemde dosyaları oluşturmak yerine <filename>/usr/share/automake</filename> dizini altındaki asıllarına bağ veriyor). Bu dosyalar <command>automake</command> tarafından üretilen <filename>Makefile</filename> dosyaları için gereklidir. Ayrıca GNU kodlama standartlarına göre <filename>INSTALL</filename>, <filename>NEWS</filename>, <filename>COPYING</filename>, <filename>README</filename>, <filename>AUTHORS</filename> ve <filename>ChangeLog</filename> dosyalarının da bu dizinde bulunması gereklidir. Bu dosyalar olmadığı için <command>automake</command>  uyarı vermektedir. <command>make distcheck</command> komutunun hata vermemesi için bu dosyaları oluşturalım, sonra içlerini nasıl olsa doldururuz. Bendeki sistemde <command>automake</command> ilk çalıştırıldığında <filename>INSTALL</filename> ve <filename>COPYING</filename> dosyalarını da bağ olarak oluşturduğu için önce onları siliyorum:
  </para>
<screen>
<prompt>$ </prompt><command>rm INSTALL COPYING</command>
<prompt>$ </prompt><command>touch NEWS INSTALL README COPYING AUTHORS ChangeLog</command>
</screen>
  <para>
<command>automake</command> programını bu dosyalardan varlığından haberdar edelim:
  </para>
<screen>
<prompt>$ </prompt><command>automake -a</command>
<prompt>$ </prompt><command>ls</command>
aclocal.m4  configure     depcomp     Makefile.am  mkinstalldirs  test.c
AUTHORS     configure.in  install-sh  Makefile.in  NEWS
ChangeLog   COPYING       INSTALL     missing      README
</screen>
  <para>
Bu dizin yapısı size tanıdık gelmiş olmalı. Kaynak paketimiz bu haliyle artık son kullanıcının karşısına çıkmaya hazır, hemen paketleyip dağıtabiliriz. Şimdi kendimizi bu programi Genel Ağ'dan indirip bilgisayarına kurmak isteyen birinin yerine koyalım. Yapmamız gerekenler aşağıdaki gibidir:
  </para>
<screen>
<prompt>$ </prompt><command>./configure</command>
creating cache ./config.cache
checking for a BSD compatible install... /usr/bin/install -c
checking whether build environment is sane... yes
checking for mawk... mawk
checking whether make sets ${MAKE}... yes
checking for gcc... gcc
checking whether the C compiler (gcc  ) works... yes
checking whether the C compiler (gcc  ) is a cross-compiler... no
checking whether we are using GNU C... yes
checking whether gcc accepts -g... yes
checking for style of include used by make... GNU
checking dependency style of gcc... gcc
checking for a BSD compatible install... /usr/bin/install -c
updating cache ./config.cache
creating ./config.status
creating Makefile
<prompt>$ </prompt><command>make</command>
source='test.c' nesnect='test.o' libtool=no \
depfile='.deps/test.Po' tmpdepfile='.deps/test.TPo' \
depmode=gcc /bin/sh ./depcomp \
gcc -DPACKAGE=\"test\" -DVERSION=\"0.1\"  -I. -I. -g -O2 -c `test -f test.c
¬ || echo './'`test.c
gcc  -g -O2   -o test  test.o
<prompt>$ </prompt><command>./test</command>
Çalışıyor
</screen>
  <warning><para>
Aşağıda programı nasıl sisteminize kuracağınız anlatılmaktadır. Öntanımlı olarak <command>test</command> uygulaması <filename>/usr/local/bin</filename> dizini altına kopyalanır. Ancak bu dizinde test adında bir uygulamanız zaten varsa ve bunu kaybetmek istemiyorsanız veya yanlışlıkla <emphasis>prefix</emphasis> vererek uygulamayı varolan <filename>/usr/bin/test</filename> üzerine kopyalamamak için dikkatli olunuz.
  </para></warning><para>
Bu noktada dilerseniz uygulamayı sisteme kurabilirsiniz. Bunun için <literal>root</literal> kullanıcı haklarına sahip olmalısınız.
  </para>
<screen>
<prompt>$ </prompt><command>make install</command>
make[1]: Entering directory `/tmp/test'
/bin/sh ./mkinstalldirs /usr/local/bin
  /usr/bin/install -c test /usr/local/bin/test
make[1]: Nothing to be done for `install-data-am'.
make[1]: Leaving directory `/tmp/test'
</screen>
  <para>
Uygulamayı kaldırmak içinse <command>make uninstall</command> komutunu kullanabilirsiniz:
  </para>
<screen>
<prompt>$ </prompt><command>make uninstall</command>
rm -f /usr/local/bin/test
</screen>
  <para>
Uygulamanızın artık hazır olduğuna inandığınızda <command>make distcheck</command> komutu ile onu paket haline getirebilirsiniz (Ekran çıktısı biraz uzun olduğundan burada listelenmemiştir). Bu komut işini tamamladığında bulunduğunuz dizinde <filename>test-0.1.tar.gz</filename> adında bir dosya oluşacaktır. Artık bu dosya ile programınızın dağıtımını yapabilirsiniz.
  </para>
  <para>
Şimdi biraz da yaptığımız bu örneği biraz daha açıklayalım. <filename>Makefile.am</filename> içerisinde mantıksal bir dil kullandık. Yazdığımız hiç bir satır çalıştırılmadı. Diğer yandan <filename> configure.in</filename> içerisinde kullandığımız dil prosedüreldir, yazdığımız her satır çalıştırılacak  bir komutu göstermektedir. <filename>Makefile.am</filename> dosyası içerisindeki ilk satır programın ismini belirtirken ikinci satır programı oluşturan kaynak kodları belirtmektedir. Şimdi daha karışık olan <filename>configure.in</filename> içerisindeki komutlara sırasıyla bakalım:
  </para><itemizedlist>
    <listitem><para>
<command>AC_INIT</command> komutu <filename>configure</filename> betiği
 için ilklendirmeleri yapar. Değiştirge olarak kaynak dosyaların adlarını alır.
 </para></listitem>
 <listitem><para>
<command>AM_INIT_AUTOMAKE</command> komutu, <command>automake</command> kullanacağımızı gösterir. Değiştirge olarak programın ismini ve sürümünü alır. Eğer <filename>Makefile.in</filename> dosyalarını elle hazırlayacak olsaydık bu komutu kullanmamıza da gerek olmayacaktı.
    </para></listitem>
    <listitem><para>
<command>AC_PROG_CC</command> komutu kullanılan C derleyicisinin ne olduğunu belirler.
		</para></listitem>
    <listitem><para>
<command>AC_PROG_INSTALL</command> komutu BSD uyumlu <literal>install</literal> uygulamasına sahip olup olmadığımızı denetler. Eğer yoksa bu işlem için <filename>install-sh</filename>'ı kullanır.
    </para></listitem>
    <listitem><para>
<command>AC_OUTPUT</command> komutu <filename>configure</filename> betik programının <filename>Makefile</filename> dosyalarını <filename>Makefile.in</filename> dosyalarından üretmesi gerektiğini belirtir.
    </para></listitem>
  </itemizedlist><para>
Örneğimizdeki <filename>configure.in</filename> dosyası içerisinde yer almayan ama sıklıkla kullanacağımız bazı komutlar da şunlardır:
  </para><itemizedlist>
    <listitem><para>
<command>AC_PROG_RANLIB</command> komutuyla bir kütüphane geliştiriyorsak <command>ranlib</command>'in sistemde nasıl kullanılacağını öğrenebiliriz.
    </para></listitem>
    <listitem><para>
<command>AC_PROG_CXX</command> komutuyla sistemdeki C++ derleyicisinin ne olduğunu öğrenebiliriz.
		</para></listitem>
    <listitem><para>
<command>AC_PROG_YACC</command> ve <command>AC_PROG_LEX</command> komutlarıyla kaynak kodlarımız <literal>lex</literal> veya <literal>yacc</literal> dosyaları içeriyorsa bu uygulamaların sistemde varlığını denetleyebiliriz.
    </para></listitem>
    <listitem><para>
Eğer alt dizinlerde başka <filename>Makefile</filename> dosyalarımız da olacaksa bunu
    </para>
<screen>
AC_OUTPUT(Makefile         \
          dizin1/Makefile  \
          dizin2/Makefile  \
          )
</screen>
    <para>
komutlarıyla belirtebiliriz.
    </para></listitem>
  </itemizedlist><para>
Dosyaların içeriğinden bahsettikten sonra şimdi de biraz önce yaptığımız örnekte çalıştırdığımız komutlardan sonra neler olduğuna tekrar bakalım.
  </para><itemizedlist>
    <listitem><para>
<command>aclocal</command> komutu çalıştıktan sonra <filename>aclocal.m4</filename> dosyası üretilir. Bu dosya içerisinde <command>autoconf</command> tarafından kullanılacak olan makrolar yer almaktadır (kendi özel makrolarımızı nasıl hazırlayacağımıza ileride değinilecektir).
    </para></listitem>
    <listitem><para>
<command>autoconf</command> komutuyla <filename>aclocal.m4</filename> ve <filename> configure.in</filename> dosyaları işlenerek <filename>configure</filename> betik programı oluşturulur.
    </para></listitem>
    <listitem><para>
<command>automake</command> komutu <filename>Makefile.am</filename> dosyasını temel alan bir <filename>Makefile.in</filename> oluşturur. Ayrıca GNU kodlama standartlarına göre eksik olan dosyalar için örnek birer kopya üretir.
    </para></listitem>
    <listitem><para>
<command>./configure</command> komutuyla çalıştırılan betik programı daha önceden belirtilen özellikler için sistemimizi test eder ve <filename>Makefile.in</filename> dosyasını örnek alarak <filename>Makefile</filename> dosyalarını oluşturur. <command>AC_OUTPUT()</command> ile belirtilen tüm dosyalardaki <command>@FOO@</command> şeklindeki kayıtları <literal>FOO</literal> için elde edilen değerlerle değiştirir (örneğin C derleyicisinin ne olduğu gibi).
    </para></listitem>
  </itemizedlist>
  </sect2>
  <sect2 xml:id="makefile-nasil-baslik-dosyalari">
  <title>Yapılandırma Başlık Dosyalarının Kullanımı</title>
  <para>
Çoğu zaman derleme anında bazı makrolar tanımlamak isteriz. <command>-D</command> seçeneği ile derleyiciye bildirilen bu değerleri programımız içerisinden kullanarak ilgili kod parçacığının çalışma şeklini değiştirebiliriz. <command>autoconf</command> kullandığımız bir uygulama için böylesi seçenekleri kullanmanın yolu yapılandırma başlık dosyası, <filename>config.h</filename> kullanmaktan geçmektedir.
  </para>
  <para>
<filename>config.h</filename> mantığını kullanabilmemiz için <filename>test.c</filename> programımızın en başına aşağıdaki üç satırı eklemeliyiz:
  </para>
<programlisting>
#ifdef HAVE_CONFIG_H
#include &lt;config.h>
#endif
</programlisting>
  <para>
Burada unutulmaması gereken önemli bir nokta, <filename>config.h</filename> dosyasının mutlaka ilk olarak <emphasis>include</emphasis> edilmesidir.
  </para>
  <para>
Program kaynak kodunu bu şekilde değiştirdikten sonra <filename>configure.in</filename> dosyasını da aşağıdaki duruma getirmeliyiz:
  </para>
<screen>
AC_INIT(test.c)
AM_CONFIG_HEADER(config.h)
AM_INIT_AUTOMAKE(test,0.1)
AC_PROG_CC
AC_PROG_INSTALL
AC_OUTPUT(Makefile)
</screen>
  <para>
Ve çalıştırdığımız komutlara bir yenisini aşağıdaki sırada ekleyelim:
  </para>
<screen>
<prompt>$ </prompt><command>aclocal</command>
<prompt>$ </prompt><command>autoconf</command>
<prompt>$ </prompt><command>touch NEWS README AUTHORS ChangeLog</command>
<prompt>$ </prompt><command>autoheader</command>
<prompt>$ </prompt><command>automake -a</command>
</screen>
  <para>
Burada yaptıklarımızın bir önceki örneğimizden farkı <command>autoheader</command> programını da çalıştırmaktan ibarettir. <command>autoheader</command>, <filename>configure.in</filename> dosyasını tarayarak bir <filename>config.h.in</filename> şablon dosyası oluşturur. Bu dosyanın içerisine <filename>configure.in</filename> dosyasından öğrendiği, tanımlanabilecek değerleri ve açıklamalarını yerleştirir. Aynı zamanda kaynak kodumuzdan <filename>config.h</filename> dosyasının <emphasis>include</emphasis> edilebilmesi için gerekli <option>-I</option> seçeneklerini de derleyiciye geçirir. <command>./configure</command> komutundan sonra ise gerçek <filename>config.h</filename> dosyası oluşur. Şimdi örneğimizde oluşan <filename>config.h</filename> dosyasına bir bakalım.
  </para>
<screen>
/* config.h.  Generated automatically by configure.  */
/* config.h.in. Generated automatically from configure.in by autoheader 2.13. */

/* Name of package */
#define PACKAGE "test"

/* Version number of package */
#define VERSION "0.1"
</screen>
  </sect2>
  <sect2 xml:id="makefile-nasil-automake">
  <title>Automake ile ilgili ayrıntılar</title>
  <para>
Projemiz büyüdükçe kaynak kodların bulunduğu yerler gittikçe karışmaya başlar. Bunları düzenleyebilmek amacıyla daha hiyerarşik dizin yapıları kurarız. Ancak bu defa da her bir dizin için uygun <filename>Makefile</filename> dosyalarını üretmemiz gerekecektir. Bunun için bu bölümde <filename>Makefile.am</filename> dosyalarından daha ayrıntılı bir şekilde bahsedeceğiz.
  </para>
  <para>
<filename>Makefile.am</filename> dosyalarının genel biçimi <literal> değişken = değer</literal> şeklindedir. Ancak aynı zamanda, geleneksel <filename>Makefile</filename> mantığındaki gibi hedef ve soyut kural tanımlamalarını da destekler. Şimdi <filename>Makefile.am</filename> dosyalarında sıklıkla kullanacağımız satırlara bir bakalım.
  </para><glosslist><glossentry>
  <glossterm><command>INCLUDES = -I/usr/local/include -I/usr/custom/include ...</command></glossterm>
  <glossdef><para>
Nesne kodlarını oluştururken derleyiciye <emphasis>include</emphasis> edilen dosyaları hangi dizinlerde araması gerektiğini belirtir. Ayrıca proje kaynak kod yapısı içerisindeki bir dizin seçenek olarak verildi ise alt dizinlerde yer alan kaynak programların hepsinin bu dosyalara erişebilmelerini sağlamak amacıyla tanımlama <command>INCLUDES = -I$(top_srcdir)/src/libxxx</command> şeklinde yapılmalıdır. Buradaki <literal>$top_srcdir</literal> değişkeni kaynak kod yapısı içerisindeki en üst dizini tutar.
  </para></glossdef></glossentry><glossentry>
  <glossterm><command>LDFLAGS = -L/usr/local/lib ...</command></glossterm>
  <glossdef><para>
Derleyici çalıştırılabilir dosyaları üretirken ihtiyaç duyduğu kütüphaneleri hangi dizinlerde
  araması gerektiğini bu tanımla öğrenecektir.
  </para></glossdef></glossentry><glossentry>
  <glossterm><command>LDADD = test.o ... $(top_builddir)/lib/libfoo.a ... -lfoo ...</command></glossterm>
  <glossdef><para>
Tüm oluşacak çalıştırılabilir dosyalara sembolik bağlamak istediğiniz sisteme kurulu olan ve olmayan nesne dosyaları burada listelenir. Eğer listelenen nesne dosyası sistemde kurulu değilse dosyanı tam adresi verilmelidir (<literal>$top_builddir/lib/libfoo.a</literal> örneğindeki gibi).
  </para></glossdef></glossentry><glossentry>
  <glossterm><command>EXTRA_DIST = dosya1 dosya2 ...</command></glossterm>
  <glossdef><para>
Kaynak kod paketinizde bulunmasınıistediğiniz her türlü dosyayı burada listeleyebilirsiniz.
  </para></glossdef></glossentry><glossentry>
  <glossterm><command>SUBDIRS = dizin1 dizin2 ...</command></glossterm>
  <glossdef><para>
Bulunulan dizin için işlem yapmadan önce kuralların çalıştırılması gereken dizinlerdir. <command>make</command> uygulaması bulunulan dizinde işleme başlamadan önce, burada belirtilen dizinlerdeki <filename>Makefile</filename> kurallarını çalıştırır ve listelenen tüm dizinler için işlemleri bitirdikten sonra bu dizine geri döner.
  </para></glossdef></glossentry><glossentry>
  <glossterm><command>bin_PROGRAMS = test test2 ...</command></glossterm>
  <glossdef><para>
<command>make</command> komutu çalıştıktan sonra üretilecek ve <command>make install</command> komutuyla belirli bir dizin altına kopyalanacak program adları burada listelenir.
  </para></glossdef></glossentry><glossentry>
  <glossterm><command>lib_LIBRARIES = libfoo1.a libfoo2.a ...</command></glossterm>
  <glossdef><para>
<command>make</command> komutu çalıştıktan sonra üretilecek ve <command>make install</command> komutuyla belirli bir dizin altına kopyalanacak kütüphane dosyalarının adları burada listelenir.
  </para></glossdef></glossentry><glossentry>
  <glossterm><command>check_PROGRAMS = program1 program2 ...</command></glossterm>
  <glossdef><para>
<command>make</command> komutunun çalışması esnasında üretilmeyip, sadece <command>make check</command> komutuyla üretilecek, programınızın tümünü veya bir kısmını test edecek uygulamaların çalıştırılabilir dosya adları listelenir.
  </para></glossdef></glossentry><glossentry>
  <glossterm><command>TESTS = program1 program2 ...</command></glossterm>
  <glossdef><para>
<command>make check</command> komutu sonrasında test amaçlı çalıştırılacak dosya adlarını listeler. Çoğu durumda <literal> TEST = $(check_PROGRAMS)</literal> şeklinde bir tanımlama yapabilirsiniz.
  </para></glossdef></glossentry><glossentry>
  <glossterm><command>include_HEADERS = foo1.h foo2.h ...</command></glossterm>
  <glossdef><para>
<filename>/prefix/include</filename> dizini altına kurulmasını istediğiniz başlık dosyalarını burada listelemelisiniz.
  </para></glossdef></glossentry><glossentry>
  <glossterm><command>bin_PROGRAMS</command></glossterm>
  <glossdef><para>
Bu değişkende listelediğiniz her bir program için aşağıdaki tanımlamaları da yapmalısınız (<replaceable>program</replaceable> kelimesi yerine programın adını yazmalısınız):
  </para><para><glosslist><glossentry>
  <glossterm><replaceable>program</replaceable><command>_SOURCES = test.c test1.c test2.c test.h test1.h test2.h ...</command></glossterm>
  <glossdef><para>
<command>automake</command> programı burada belirtmiş olduğunuz dosya adları için, C, C++ ve Fortran dillerine özgün soyut <filename>Makefile</filename> kurallarını oluşturur. Eğer başka bir dil kullanılıyorsa gerekli kuralları siz vermelisiniz.
  </para></glossdef></glossentry><glossentry>
  <glossterm><replaceable>program</replaceable><command>_LDADD = $(top_builddir)/lib/libfoo.a -lnsl ...</command></glossterm>
  <glossdef><para>
Burada programınızla ilintilenmesi gereken kütüphaneleri listelemelisiniz.
  </para></glossdef></glossentry><glossentry>
  <glossterm><replaceable>program</replaceable><command>_LDFLAGS = -L/dizin1 ...</command></glossterm>
  <glossdef><para>
<literal>program_LDADD</literal> ile belirttiğiniz kütüphanelerin hangi dizinlerde aranması gerektiği burada listelenir.
  </para></glossdef></glossentry><glossentry>
  <glossterm><replaceable>program</replaceable><command>_DEPENDENCIES = dep1 dep2 ...</command></glossterm>
  <glossdef><para>
Programınızın derlenebilmesi için bağımlı olduğu diğer hedefleri burada listelemelisiniz.
  </para></glossdef></glossentry></glosslist>
  </para></glossdef></glossentry></glosslist>
  </sect2>
  </sect1>
  <sect1 xml:id="makefile-nasil-kaynakca"><title>Yararlı Belgeler</title>
  <para>
Daha ayrıntılı bilgi almak için aşağıdaki belgeleri inceleyebilirsiniz:
  </para><itemizedlist>
    <listitem><para>
<link xlink:href="http://www.gnu.org/software/make/manual/make.html">GNU Make Kılavuzu</link>
    </para></listitem>
    <listitem><para>
<link xlink:href="http://www.gnu.org/software/autoconf/manual/html_node/index.html">GNU Autoconf Kılavuzu</link>
    </para></listitem>
    <listitem><para>
<link xlink:href="http://www.gnu.org/software/automake/manual/html_node/index.html">GNU Automake Kılavuzu</link>
    </para></listitem>
  </itemizedlist>
  </sect1>
</article>


